--- kernel-maemo-2.6.28.old.orig/arch/arm/configs/rx51_defconfig
+++ kernel-maemo-2.6.28.old/arch/arm/configs/rx51_defconfig
@@ -265,7 +265,7 @@
 #
 # Processor Features
 #
-CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMB is not set
 # CONFIG_ARM_THUMBEE is not set
 # CONFIG_CPU_ICACHE_DISABLE is not set
 # CONFIG_CPU_DCACHE_DISABLE is not set
--- kernel-maemo-2.6.28.old.orig/arch/arm/configs/rx51_tiny_defconfig
+++ kernel-maemo-2.6.28.old/arch/arm/configs/rx51_tiny_defconfig
@@ -250,7 +250,7 @@
 #
 # Processor Features
 #
-CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMB is not set
 # CONFIG_ARM_THUMBEE is not set
 # CONFIG_CPU_ICACHE_DISABLE is not set
 # CONFIG_CPU_DCACHE_DISABLE is not set
--- kernel-maemo-2.6.28.old.orig/arch/arm/include/asm/page.h
+++ kernel-maemo-2.6.28.old/arch/arm/include/asm/page.h
@@ -10,8 +10,6 @@
 #ifndef _ASMARM_PAGE_H
 #define _ASMARM_PAGE_H
 
-#include <linux/const.h>
-
 /* PAGE_SHIFT determines the page size */
 #define PAGE_SHIFT		12
 #define PAGE_SIZE		(_AC(1,UL) << PAGE_SHIFT)
--- kernel-maemo-2.6.28.old.orig/arch/arm/lib/copy_page.S
+++ kernel-maemo-2.6.28.old/arch/arm/lib/copy_page.S
@@ -12,8 +12,9 @@
 #include <linux/linkage.h>
 #include <asm/assembler.h>
 #include <asm/asm-offsets.h>
+#include <asm/cache.h>
 
-#define COPY_COUNT (PAGE_SZ/64 PLD( -1 ))
+#define COPY_COUNT (PAGE_SZ / (2 * L1_CACHE_BYTES) PLD( -1 ))
 
 		.text
 		.align	5
@@ -26,17 +27,16 @@
 ENTRY(copy_page)
 		stmfd	sp!, {r4, lr}			@	2
 	PLD(	pld	[r1, #0]		)
-	PLD(	pld	[r1, #32]		)
+	PLD(	pld	[r1, #L1_CACHE_BYTES]		)
 		mov	r2, #COPY_COUNT			@	1
 		ldmia	r1!, {r3, r4, ip, lr}		@	4+1
-1:	PLD(	pld	[r1, #64]		)
-	PLD(	pld	[r1, #96]		)
-2:		stmia	r0!, {r3, r4, ip, lr}		@	4
-		ldmia	r1!, {r3, r4, ip, lr}		@	4+1
-		stmia	r0!, {r3, r4, ip, lr}		@	4
-		ldmia	r1!, {r3, r4, ip, lr}		@	4+1
+1:	PLD(	pld	[r1, #2 * L1_CACHE_BYTES])
+	PLD(	pld	[r1, #3 * L1_CACHE_BYTES])
+2:
+	.rept	(2 * L1_CACHE_BYTES / 16 - 1)
 		stmia	r0!, {r3, r4, ip, lr}		@	4
 		ldmia	r1!, {r3, r4, ip, lr}		@	4
+	.endr
 		subs	r2, r2, #1			@	1
 		stmia	r0!, {r3, r4, ip, lr}		@	4
 		ldmgtia	r1!, {r3, r4, ip, lr}		@	4
--- kernel-maemo-2.6.28.old.orig/arch/arm/mm/cache-v6.S
+++ kernel-maemo-2.6.28.old/arch/arm/mm/cache-v6.S
@@ -12,7 +12,6 @@
 #include <linux/linkage.h>
 #include <linux/init.h>
 #include <asm/assembler.h>
-#include <asm/page.h>
 
 #include "proc-macros.S"
 
@@ -93,13 +92,13 @@
  *	- the Icache does not read data from the write buffer
  */
 ENTRY(v6_coherent_user_range)
-
 #ifdef HARVARD_CACHE
 	bic	r0, r0, #CACHE_LINE_SIZE - 1
 1:
-USER(	mcr	p15, 0, r0, c7, c10, 1)		@ clean D line
+ USER(	mcr	p15, 0, r0, c7, c10, 1	)	@ clean D line
 	add	r0, r0, #CACHE_LINE_SIZE
-2:	cmp	r0, r1
+2:
+	cmp	r0, r1
 	blo	1b
 #endif
 	mov	r0, #0
@@ -111,10 +110,17 @@
 #endif
 	mov	pc, lr
 
-#ifdef HARVARD_CACHE
-9001:	add	r0, r0, #PAGE_SIZE
+/*
+ * Fault handling for the cache operation above. If the virtual address in r0
+ * isn't mapped, just try the next page.
+ */
+9001:
+	mov	r0, r0, lsr #12
+	mov	r0, r0, lsl #12
+	add	r0, r0, #4096
 	b	2b
-#endif
+ENDPROC(v6_coherent_user_range)
+ENDPROC(v6_coherent_kern_range)
 
 /*
  *	v6_flush_kern_dcache_page(kaddr)
--- kernel-maemo-2.6.28.old.orig/arch/arm/mm/cache-v7.S
+++ kernel-maemo-2.6.28.old/arch/arm/mm/cache-v7.S
@@ -13,7 +13,6 @@
 #include <linux/linkage.h>
 #include <linux/init.h>
 #include <asm/assembler.h>
-#include <asm/page.h>
 
 #include "proc-macros.S"
 
@@ -152,11 +151,12 @@
 	sub	r3, r2, #1
 	bic	r0, r0, r3
 1:
-USER(	mcr	p15, 0, r0, c7, c11, 1)		@ clean D line to the point of unification
+ USER(	mcr	p15, 0, r0, c7, c11, 1	)	@ clean D line to the point of unification
 	dsb
-	mcr	p15, 0, r0, c7, c5, 1		@ invalidate I line
+ USER(	mcr	p15, 0, r0, c7, c5, 1	)	@ invalidate I line
 	add	r0, r0, r2
-2:	cmp	r0, r1
+2:
+	cmp	r0, r1
 	blo	1b
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c5, 6		@ invalidate BTB
@@ -164,7 +164,14 @@
 	isb
 	mov	pc, lr
 
-9001:	add	r0, r0, #PAGE_SIZE
+/*
+ * Fault handling for the cache operation above. If the virtual address in r0
+ * isn't mapped, just try the next page.
+ */
+9001:
+	mov	r0, r0, lsr #12
+	mov	r0, r0, lsl #12
+	add	r0, r0, #4096
 	b	2b
 ENDPROC(v7_coherent_kern_range)
 ENDPROC(v7_coherent_user_range)
--- kernel-maemo-2.6.28.old.orig/arch/arm/plat-omap/dss_boottime.c
+++ kernel-maemo-2.6.28.old/arch/arm/plat-omap/dss_boottime.c
@@ -135,12 +135,17 @@
 	BUG_ON(!dss_fclk || !dss_iclk);
 
 	if ((r = clk_enable(dss_iclk)) < 0)
-		return r;
+		goto err1;
 
 	if ((r = clk_enable(dss_fclk)) < 0)
-		return r;
+		goto err2;
 
 	return 0;
+
+err2:
+	clk_disable(dss_iclk);
+err1:
+	return r;
 }
 EXPORT_SYMBOL_GPL(dss_boottime_enable_clocks);
 
--- kernel-maemo-2.6.28.old.orig/arch/arm/plat-omap/include/dspbridge/drv.h
+++ kernel-maemo-2.6.28.old/arch/arm/plat-omap/include/dspbridge/drv.h
@@ -189,6 +189,7 @@
 
 	/* DMM resources */
 	struct DMM_RES_OBJECT *pDMMList;
+	spinlock_t dmm_list_lock;
 
 	/* DSP Heap resources */
 	struct DSPHEAP_RES_OBJECT *pDSPHEAPList;
--- kernel-maemo-2.6.28.old.orig/drivers/dsp/bridge/rmgr/drv.c
+++ kernel-maemo-2.6.28.old/drivers/dsp/bridge/rmgr/drv.c
@@ -220,6 +220,8 @@
 	spin_lock_init(&(*pCtxt)->proc_list_lock);
 	INIT_LIST_HEAD(&(*pCtxt)->processor_list);
 
+	spin_lock_init(&(*pCtxt)->dmm_list_lock);
+
 	GT_0trace(curTrace, GT_ENTER,
 		 "\n In DRV_InsertProcContext Calling "
 		 "DRV_GetProcCtxtList\n");
@@ -451,7 +453,7 @@
 
 /* Release DMM resource element context
 * This is called from Proc_UnMap. after the actual resource is freed */
-DSP_STATUS 	DRV_RemoveDMMResElement(HANDLE hDMMRes, HANDLE hPCtxt)
+DSP_STATUS DRV_RemoveDMMResElement(HANDLE hDMMRes, HANDLE hPCtxt)
 {
 	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
 	struct DMM_RES_OBJECT *pDMMRes = (struct DMM_RES_OBJECT *)hDMMRes;
@@ -502,7 +504,7 @@
 }
 
 /* Actual DMM De-Allocation */
-DSP_STATUS  DRV_ProcFreeDMMRes(HANDLE hPCtxt)
+DSP_STATUS DRV_ProcFreeDMMRes(HANDLE hPCtxt)
 {
 	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
 	DSP_STATUS status = DSP_SOK;
--- kernel-maemo-2.6.28.old.orig/drivers/dsp/bridge/rmgr/proc.c
+++ kernel-maemo-2.6.28.old/drivers/dsp/bridge/rmgr/proc.c
@@ -1462,9 +1462,13 @@
 
 #ifndef RES_CLEANUP_DISABLE
 	if (DSP_SUCCEEDED(status)) {
+		spin_lock(&pr_ctxt->dmm_list_lock);
+
 		DRV_InsertDMMResElement(&dmmRes, pr_ctxt);
 		DRV_UpdateDMMResElement(dmmRes, (u32)pMpuAddr, ulSize,
 				(u32)pReqAddr, (u32)*ppMapAddr, hProcessor);
+
+		spin_unlock(&pr_ctxt->dmm_list_lock);
 	}
 #endif
 func_end:
@@ -1827,9 +1831,17 @@
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	if (pr_ctxt && DRV_GetDMMResElement((u32)pMapAddr, &dmmRes, pr_ctxt)
-							!= DSP_ENOTFOUND)
-		DRV_RemoveDMMResElement(dmmRes, pr_ctxt);
+	if (pr_ctxt) {
+		DSP_STATUS rc;
+
+		spin_lock(&pr_ctxt->dmm_list_lock);
+
+		rc = DRV_GetDMMResElement((u32)pMapAddr, &dmmRes, pr_ctxt);
+		if (rc != DSP_ENOTFOUND)
+			DRV_RemoveDMMResElement(dmmRes, pr_ctxt);
+
+		spin_unlock(&pr_ctxt->dmm_list_lock);
+	}
 #endif
 func_end:
 	GT_1trace(PROC_DebugMask, GT_ENTER,
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/COPYING
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/COPYING
@@ -1,5 +1,5 @@
 
-This software is Copyright (C) 2008 Imagination Technologies Ltd. 
+This software is Copyright (C) 2008 Imagination Technologies Ltd.
 			All rights reserved.
 
 You may use, distribute and copy this software under the terms of
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/Makefile
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/Makefile
@@ -5,7 +5,7 @@
 pvrsrvkm-objs		:= osfunc.o mmap.o module.o pdump.o proc.o	   \
 			   pvr_bridge_k.o pvr_debug.o mm.o mutex.o event.o \
 			   buffer_manager.o devicemem.o deviceclass.o	   \
-			   handle.o hash.o metrics.o pvrsrv.o queue.o ra.o \
+			   handle.o hash.o pvrsrv.o queue.o ra.o	   \
 			   resman.o power.o mem.o bridged_pvr_bridge.o	   \
 			   sgxinit.o sgxreset.o sgxutils.o sgxkick.o	   \
 			   sgxtransfer.o mmu.o pb.o perproc.o sysconfig.o  \
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/README
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/README
@@ -4,10 +4,10 @@
 ======================================================================
 
 
-About 
+About
 -------------------------------------------
 
-This is the Imagination Technologies SGX DDK for the Linux kernel. 
+This is the Imagination Technologies SGX DDK for the Linux kernel.
 
 
 License
@@ -16,7 +16,7 @@
 You may use, distribute and copy this software under the terms of
 GNU General Public License version 2.
 
-The full GNU General Public License version 2 is included in this 
+The full GNU General Public License version 2 is included in this
 distribution in the file called "COPYING".
 
 
@@ -24,4 +24,4 @@
 -------------------------------------------
 
 Imagination Technologies Ltd. <gpl-support@imgtec.com>
-Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/bridged_pvr_bridge.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/bridged_pvr_bridge.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -53,20 +53,19 @@
 #define PVRSRV_BRIDGE_ASSERT_CMD(X, Y) PVR_UNREFERENCED_PARAMETER(X)
 #endif
 
-PVRSRV_BRIDGE_DISPATCH_TABLE_ENTRY
+struct PVRSRV_BRIDGE_DISPATCH_TABLE_ENTRY
     g_BridgeDispatchTable[BRIDGE_DISPATCH_TABLE_ENTRY_COUNT];
 
 #if defined(DEBUG_BRIDGE_KM)
-PVRSRV_BRIDGE_GLOBAL_STATS g_BridgeGlobalStats;
+struct PVRSRV_BRIDGE_GLOBAL_STATS g_BridgeGlobalStats;
 #endif
 
 static IMG_BOOL abSharedDeviceMemHeap[PVRSRV_MAX_CLIENT_HEAPS];
 
 #if defined(DEBUG_BRIDGE_KM)
-static PVRSRV_ERROR
-CopyFromUserWrapper(PVRSRV_PER_PROCESS_DATA * pProcData,
-		    IMG_UINT32 ui32BridgeID,
-		    IMG_VOID * pvDest, IMG_VOID * pvSrc, IMG_UINT32 ui32Size)
+static enum PVRSRV_ERROR CopyFromUserWrapper(struct PVRSRV_PER_PROCESS_DATA
+		*pProcData, u32 ui32BridgeID,
+		void *pvDest, void __user *pvSrc, u32 ui32Size)
 {
 	g_BridgeDispatchTable[ui32BridgeID].ui32CopyFromUserTotalBytes +=
 	    ui32Size;
@@ -74,10 +73,10 @@
 	return OSCopyFromUser(pProcData, pvDest, pvSrc, ui32Size);
 }
 
-static PVRSRV_ERROR
-CopyToUserWrapper(PVRSRV_PER_PROCESS_DATA * pProcData,
-		  IMG_UINT32 ui32BridgeID,
-		  IMG_VOID * pvDest, IMG_VOID * pvSrc, IMG_UINT32 ui32Size)
+static enum PVRSRV_ERROR CopyToUserWrapper(
+		  struct PVRSRV_PER_PROCESS_DATA *pProcData,
+		  u32 ui32BridgeID,
+		  void __user *pvDest, void *pvSrc, u32 ui32Size)
 {
 	g_BridgeDispatchTable[ui32BridgeID].ui32CopyToUserTotalBytes +=
 	    ui32Size;
@@ -92,39 +91,36 @@
 #endif
 
 #define ASSIGN_AND_RETURN_ON_ERROR(error, src, res)		\
-	do							\
-	{							\
+	do {							\
 		(error) = (src);				\
-		if ((error) != PVRSRV_OK) 			\
-		{						\
-			return (res);				\
+		if ((error) != PVRSRV_OK) {			\
+			return res;				\
 		}						\
 	} while (error != PVRSRV_OK)
 
 #define ASSIGN_AND_EXIT_ON_ERROR(error, src)		\
 	ASSIGN_AND_RETURN_ON_ERROR(error, src, 0)
 
-static INLINE PVRSRV_ERROR
-NewHandleBatch(PVRSRV_PER_PROCESS_DATA * psPerProc, IMG_UINT32 ui32BatchSize)
+static inline enum PVRSRV_ERROR NewHandleBatch(struct PVRSRV_PER_PROCESS_DATA
+					  *psPerProc, u32 ui32BatchSize)
 {
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
 	PVR_ASSERT(!psPerProc->bHandlesBatched);
 
 	eError = PVRSRVNewHandleBatch(psPerProc->psHandleBase, ui32BatchSize);
 
-	if (eError == PVRSRV_OK) {
+	if (eError == PVRSRV_OK)
 		psPerProc->bHandlesBatched = IMG_TRUE;
-	}
 
 	return eError;
 }
 
 #define NEW_HANDLE_BATCH_OR_ERROR(error, psPerProc, ui32BatchSize)	\
-	ASSIGN_AND_EXIT_ON_ERROR(error, NewHandleBatch(psPerProc, ui32BatchSize))
+      ASSIGN_AND_EXIT_ON_ERROR(error, NewHandleBatch(psPerProc, ui32BatchSize))
 
-static INLINE PVRSRV_ERROR
-CommitHandleBatch(PVRSRV_PER_PROCESS_DATA * psPerProc)
+static inline enum PVRSRV_ERROR CommitHandleBatch(struct PVRSRV_PER_PROCESS_DATA
+					     *psPerProc)
 {
 	PVR_ASSERT(psPerProc->bHandlesBatched);
 
@@ -133,10 +129,10 @@
 	return PVRSRVCommitHandleBatch(psPerProc->psHandleBase);
 }
 
-#define COMMIT_HANDLE_BATCH_OR_ERROR(error, psPerProc) 			\
+#define COMMIT_HANDLE_BATCH_OR_ERROR(error, psPerProc)			\
 	ASSIGN_AND_EXIT_ON_ERROR(error, CommitHandleBatch(psPerProc))
 
-static INLINE IMG_VOID ReleaseHandleBatch(PVRSRV_PER_PROCESS_DATA * psPerProc)
+static inline void ReleaseHandleBatch(struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	if (psPerProc->bHandlesBatched) {
 		psPerProc->bHandlesBatched = IMG_FALSE;
@@ -145,11 +141,10 @@
 	}
 }
 
-static int
-PVRSRVEnumerateDevicesBW(IMG_UINT32 ui32BridgeID,
-			 IMG_VOID * psBridgeIn,
-			 PVRSRV_BRIDGE_OUT_ENUMDEVICE * psEnumDeviceOUT,
-			 PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVEnumerateDevicesBW(u32 ui32BridgeID,
+			 void *psBridgeIn,
+			 struct PVRSRV_BRIDGE_OUT_ENUMDEVICE *psEnumDeviceOUT,
+			 struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_ENUM_DEVICES);
 
@@ -163,15 +158,12 @@
 	return 0;
 }
 
-static int
-PVRSRVAcquireDeviceDataBW(IMG_UINT32 ui32BridgeID,
-			  PVRSRV_BRIDGE_IN_ACQUIRE_DEVICEINFO *
-			  psAcquireDevInfoIN,
-			  PVRSRV_BRIDGE_OUT_ACQUIRE_DEVICEINFO *
-			  psAcquireDevInfoOUT,
-			  PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVAcquireDeviceDataBW(u32 ui32BridgeID,
+	struct PVRSRV_BRIDGE_IN_ACQUIRE_DEVICEINFO *psAcquireDevInfoIN,
+	struct PVRSRV_BRIDGE_OUT_ACQUIRE_DEVICEINFO *psAcquireDevInfoOUT,
+	struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hDevCookieInt;
+	void *hDevCookieInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_ACQUIRE_DEVICEINFO);
@@ -180,9 +172,8 @@
 	    PVRSRVAcquireDeviceDataKM(psAcquireDevInfoIN->uiDevIndex,
 				      psAcquireDevInfoIN->eDeviceType,
 				      &hDevCookieInt);
-	if (psAcquireDevInfoOUT->eError != PVRSRV_OK) {
+	if (psAcquireDevInfoOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psAcquireDevInfoOUT->eError =
 	    PVRSRVAllocHandle(psPerProc->psHandleBase,
@@ -194,21 +185,18 @@
 	return 0;
 }
 
-static int
-SGXGetInfoForSrvinitBW(IMG_UINT32 ui32BridgeID,
-		       PVRSRV_BRIDGE_IN_SGXINFO_FOR_SRVINIT *
-		       psSGXInfoForSrvinitIN,
-		       PVRSRV_BRIDGE_OUT_SGXINFO_FOR_SRVINIT *
-		       psSGXInfoForSrvinitOUT,
-		       PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int SGXGetInfoForSrvinitBW(u32 ui32BridgeID,
+	struct PVRSRV_BRIDGE_IN_SGXINFO_FOR_SRVINIT *psSGXInfoForSrvinitIN,
+	struct PVRSRV_BRIDGE_OUT_SGXINFO_FOR_SRVINIT *psSGXInfoForSrvinitOUT,
+	struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hDevCookieInt;
-	IMG_UINT32 i;
+	void *hDevCookieInt;
+	u32 i;
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
-				 PVRSRV_BRIDGE_SGXINFO_FOR_SRVINIT);
+			PVRSRV_BRIDGE_SGXINFO_FOR_SRVINIT);
 
 	NEW_HANDLE_BATCH_OR_ERROR(psSGXInfoForSrvinitOUT->eError, psPerProc,
-				  PVRSRV_MAX_CLIENT_HEAPS);
+			PVRSRV_MAX_CLIENT_HEAPS);
 
 	if (!psPerProc->bInitProcess) {
 		psSGXInfoForSrvinitOUT->eError = PVRSRV_ERROR_GENERIC;
@@ -216,38 +204,36 @@
 	}
 
 	psSGXInfoForSrvinitOUT->eError =
-	    PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevCookieInt,
-			       psSGXInfoForSrvinitIN->hDevCookie,
-			       PVRSRV_HANDLE_TYPE_DEV_NODE);
+		PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevCookieInt,
+				psSGXInfoForSrvinitIN->hDevCookie,
+				PVRSRV_HANDLE_TYPE_DEV_NODE);
 
-	if (psSGXInfoForSrvinitOUT->eError != PVRSRV_OK) {
+	if (psSGXInfoForSrvinitOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psSGXInfoForSrvinitOUT->eError =
-	    SGXGetInfoForSrvinitKM(hDevCookieInt,
-				   &psSGXInfoForSrvinitOUT->sInitInfo);
+		SGXGetInfoForSrvinitKM(hDevCookieInt,
+				&psSGXInfoForSrvinitOUT->sInitInfo);
 
-	if (psSGXInfoForSrvinitOUT->eError != PVRSRV_OK) {
+	if (psSGXInfoForSrvinitOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	for (i = 0; i < PVRSRV_MAX_CLIENT_HEAPS; i++) {
-		PVRSRV_HEAP_INFO *psHeapInfo;
+		struct PVRSRV_HEAP_INFO *psHeapInfo;
 
 		psHeapInfo = &psSGXInfoForSrvinitOUT->sInitInfo.asHeapInfo[i];
 
 		if (psHeapInfo->ui32HeapID !=
-		    (IMG_UINT32) SGX_UNDEFINED_HEAP_ID) {
-			IMG_HANDLE hDevMemHeapExt;
+				(u32) SGX_UNDEFINED_HEAP_ID) {
+			void *hDevMemHeapExt;
 
-			if (psHeapInfo->hDevMemHeap != IMG_NULL) {
+			if (psHeapInfo->hDevMemHeap != NULL) {
 
 				PVRSRVAllocHandleNR(psPerProc->psHandleBase,
-						    &hDevMemHeapExt,
-						    psHeapInfo->hDevMemHeap,
-						    PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP,
-						    PVRSRV_HANDLE_ALLOC_FLAG_SHARED);
+					&hDevMemHeapExt,
+					psHeapInfo->hDevMemHeap,
+					PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP,
+					PVRSRV_HANDLE_ALLOC_FLAG_SHARED);
 				psHeapInfo->hDevMemHeap = hDevMemHeapExt;
 			}
 		}
@@ -258,175 +244,159 @@
 	return 0;
 }
 
-static int
-PVRSRVCreateDeviceMemContextBW(IMG_UINT32 ui32BridgeID,
-			       PVRSRV_BRIDGE_IN_CREATE_DEVMEMCONTEXT *
-			       psCreateDevMemContextIN,
-			       PVRSRV_BRIDGE_OUT_CREATE_DEVMEMCONTEXT *
-			       psCreateDevMemContextOUT,
-			       PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	IMG_HANDLE hDevCookieInt;
-	IMG_HANDLE hDevMemContextInt;
-	IMG_UINT32 i;
+static int PVRSRVCreateDeviceMemContextBW(u32 ui32BridgeID,
+       struct PVRSRV_BRIDGE_IN_CREATE_DEVMEMCONTEXT *psCreateDevMemContextIN,
+       struct PVRSRV_BRIDGE_OUT_CREATE_DEVMEMCONTEXT *psCreateDevMemContextOUT,
+       struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	void *hDevCookieInt;
+	void *hDevMemContextInt;
+	u32 i;
 	IMG_BOOL bCreated;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
-				 PVRSRV_BRIDGE_CREATE_DEVMEMCONTEXT);
+			PVRSRV_BRIDGE_CREATE_DEVMEMCONTEXT);
 
 	NEW_HANDLE_BATCH_OR_ERROR(psCreateDevMemContextOUT->eError, psPerProc,
-				  PVRSRV_MAX_CLIENT_HEAPS + 1);
+			PVRSRV_MAX_CLIENT_HEAPS + 1);
 
 	psCreateDevMemContextOUT->eError =
-	    PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevCookieInt,
-			       psCreateDevMemContextIN->hDevCookie,
-			       PVRSRV_HANDLE_TYPE_DEV_NODE);
+		PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevCookieInt,
+				psCreateDevMemContextIN->hDevCookie,
+				PVRSRV_HANDLE_TYPE_DEV_NODE);
 
-	if (psCreateDevMemContextOUT->eError != PVRSRV_OK) {
+	if (psCreateDevMemContextOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psCreateDevMemContextOUT->eError =
-	    PVRSRVCreateDeviceMemContextKM(hDevCookieInt,
-					   psPerProc,
-					   &hDevMemContextInt,
-					   &psCreateDevMemContextOUT->
-					   ui32ClientHeapCount,
-					   &psCreateDevMemContextOUT->
-					   sHeapInfo[0], &bCreated
-					   , abSharedDeviceMemHeap
-	    );
+		PVRSRVCreateDeviceMemContextKM(hDevCookieInt,
+				psPerProc,
+				&hDevMemContextInt,
+				&psCreateDevMemContextOUT->
+				ui32ClientHeapCount,
+				&psCreateDevMemContextOUT->
+				sHeapInfo[0], &bCreated
+				, abSharedDeviceMemHeap
+				);
 
-	if (psCreateDevMemContextOUT->eError != PVRSRV_OK) {
+	if (psCreateDevMemContextOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	if (bCreated) {
 		PVRSRVAllocHandleNR(psPerProc->psHandleBase,
-				    &psCreateDevMemContextOUT->hDevMemContext,
-				    hDevMemContextInt,
-				    PVRSRV_HANDLE_TYPE_DEV_MEM_CONTEXT,
-				    PVRSRV_HANDLE_ALLOC_FLAG_NONE);
+				&psCreateDevMemContextOUT->hDevMemContext,
+				hDevMemContextInt,
+				PVRSRV_HANDLE_TYPE_DEV_MEM_CONTEXT,
+				PVRSRV_HANDLE_ALLOC_FLAG_NONE);
 	} else {
 		psCreateDevMemContextOUT->eError =
-		    PVRSRVFindHandle(psPerProc->psHandleBase,
-				     &psCreateDevMemContextOUT->hDevMemContext,
-				     hDevMemContextInt,
-				     PVRSRV_HANDLE_TYPE_DEV_MEM_CONTEXT);
-		if (psCreateDevMemContextOUT->eError != PVRSRV_OK) {
+			PVRSRVFindHandle(psPerProc->psHandleBase,
+				&psCreateDevMemContextOUT->hDevMemContext,
+				hDevMemContextInt,
+				PVRSRV_HANDLE_TYPE_DEV_MEM_CONTEXT);
+		if (psCreateDevMemContextOUT->eError != PVRSRV_OK)
 			return 0;
-		}
 	}
 
 	for (i = 0; i < psCreateDevMemContextOUT->ui32ClientHeapCount; i++) {
-		IMG_HANDLE hDevMemHeapExt;
+		void *hDevMemHeapExt;
 
-		if (abSharedDeviceMemHeap[i])
-		{
+		if (abSharedDeviceMemHeap[i]) {
 
 			PVRSRVAllocHandleNR(psPerProc->psHandleBase,
-					    &hDevMemHeapExt,
-					    psCreateDevMemContextOUT->
-					    sHeapInfo[i].hDevMemHeap,
-					    PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP,
-					    PVRSRV_HANDLE_ALLOC_FLAG_SHARED);
-		}
-		else {
+					&hDevMemHeapExt,
+					psCreateDevMemContextOUT->
+					sHeapInfo[i].hDevMemHeap,
+					PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP,
+					PVRSRV_HANDLE_ALLOC_FLAG_SHARED);
+		} else {
 
 			if (bCreated) {
 				PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
-						       &hDevMemHeapExt,
-						       psCreateDevMemContextOUT->
-						       sHeapInfo[i].hDevMemHeap,
-						       PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP,
-						       PVRSRV_HANDLE_ALLOC_FLAG_NONE,
-						       psCreateDevMemContextOUT->
-						       hDevMemContext);
+						&hDevMemHeapExt,
+						psCreateDevMemContextOUT->
+						sHeapInfo[i].hDevMemHeap,
+						PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP,
+						PVRSRV_HANDLE_ALLOC_FLAG_NONE,
+						psCreateDevMemContextOUT->
+						hDevMemContext);
 			} else {
 				psCreateDevMemContextOUT->eError =
-				    PVRSRVFindHandle(psPerProc->psHandleBase,
-						     &hDevMemHeapExt,
-						     psCreateDevMemContextOUT->
-						     sHeapInfo[i].hDevMemHeap,
-						     PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP);
+					PVRSRVFindHandle(
+					    psPerProc->psHandleBase,
+					    &hDevMemHeapExt,
+					    psCreateDevMemContextOUT->
+					    sHeapInfo[i].hDevMemHeap,
+					    PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP);
 				if (psCreateDevMemContextOUT->eError !=
-				    PVRSRV_OK) {
+						PVRSRV_OK)
 					return 0;
-				}
 			}
 		}
 		psCreateDevMemContextOUT->sHeapInfo[i].hDevMemHeap =
-		    hDevMemHeapExt;
+			hDevMemHeapExt;
 	}
 
 	COMMIT_HANDLE_BATCH_OR_ERROR(psCreateDevMemContextOUT->eError,
-				     psPerProc);
+			psPerProc);
 
 	return 0;
 }
 
-static int
-PVRSRVDestroyDeviceMemContextBW(IMG_UINT32 ui32BridgeID,
-				PVRSRV_BRIDGE_IN_DESTROY_DEVMEMCONTEXT *
-				psDestroyDevMemContextIN,
-				PVRSRV_BRIDGE_RETURN * psRetOUT,
-				PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVDestroyDeviceMemContextBW(u32 ui32BridgeID,
+	struct PVRSRV_BRIDGE_IN_DESTROY_DEVMEMCONTEXT *psDestroyDevMemContextIN,
+	struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hDevCookieInt;
-	IMG_HANDLE hDevMemContextInt;
+	void *hDevCookieInt;
+	void *hDevMemContextInt;
 	IMG_BOOL bDestroyed;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
-				 PVRSRV_BRIDGE_DESTROY_DEVMEMCONTEXT);
+			PVRSRV_BRIDGE_DESTROY_DEVMEMCONTEXT);
 
 	psRetOUT->eError =
-	    PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevCookieInt,
-			       psDestroyDevMemContextIN->hDevCookie,
-			       PVRSRV_HANDLE_TYPE_DEV_NODE);
+		PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevCookieInt,
+				psDestroyDevMemContextIN->hDevCookie,
+				PVRSRV_HANDLE_TYPE_DEV_NODE);
 
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
-	    PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevMemContextInt,
-			       psDestroyDevMemContextIN->hDevMemContext,
-			       PVRSRV_HANDLE_TYPE_DEV_MEM_CONTEXT);
+		PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevMemContextInt,
+				psDestroyDevMemContextIN->hDevMemContext,
+				PVRSRV_HANDLE_TYPE_DEV_MEM_CONTEXT);
 
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
-	    PVRSRVDestroyDeviceMemContextKM(hDevCookieInt, hDevMemContextInt,
-					    &bDestroyed);
+		PVRSRVDestroyDeviceMemContextKM(hDevCookieInt,
+				hDevMemContextInt,
+				&bDestroyed);
 
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
-	if (bDestroyed) {
+	if (bDestroyed)
 		psRetOUT->eError =
-		    PVRSRVReleaseHandle(psPerProc->psHandleBase,
+			PVRSRVReleaseHandle(psPerProc->psHandleBase,
 					psDestroyDevMemContextIN->
 					hDevMemContext,
 					PVRSRV_HANDLE_TYPE_DEV_MEM_CONTEXT);
-	}
 
 	return 0;
 }
 
-static int
-PVRSRVGetDeviceMemHeapInfoBW(IMG_UINT32 ui32BridgeID,
-			     PVRSRV_BRIDGE_IN_GET_DEVMEM_HEAPINFO *
-			     psGetDevMemHeapInfoIN,
-			     PVRSRV_BRIDGE_OUT_GET_DEVMEM_HEAPINFO *
-			     psGetDevMemHeapInfoOUT,
-			     PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	IMG_HANDLE hDevCookieInt;
-	IMG_HANDLE hDevMemContextInt;
-	IMG_UINT32 i;
+static int PVRSRVGetDeviceMemHeapInfoBW(u32 ui32BridgeID,
+	   struct PVRSRV_BRIDGE_IN_GET_DEVMEM_HEAPINFO *psGetDevMemHeapInfoIN,
+	   struct PVRSRV_BRIDGE_OUT_GET_DEVMEM_HEAPINFO *psGetDevMemHeapInfoOUT,
+	   struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	void *hDevCookieInt;
+	void *hDevMemContextInt;
+	u32 i;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_GET_DEVMEM_HEAPINFO);
@@ -439,46 +409,37 @@
 			       psGetDevMemHeapInfoIN->hDevCookie,
 			       PVRSRV_HANDLE_TYPE_DEV_NODE);
 
-	if (psGetDevMemHeapInfoOUT->eError != PVRSRV_OK) {
+	if (psGetDevMemHeapInfoOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psGetDevMemHeapInfoOUT->eError =
 	    PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevMemContextInt,
 			       psGetDevMemHeapInfoIN->hDevMemContext,
 			       PVRSRV_HANDLE_TYPE_DEV_MEM_CONTEXT);
 
-	if (psGetDevMemHeapInfoOUT->eError != PVRSRV_OK) {
+	if (psGetDevMemHeapInfoOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psGetDevMemHeapInfoOUT->eError =
 	    PVRSRVGetDeviceMemHeapInfoKM(hDevCookieInt,
-					 hDevMemContextInt,
-					 &psGetDevMemHeapInfoOUT->
-					 ui32ClientHeapCount,
-					 &psGetDevMemHeapInfoOUT->sHeapInfo[0]
-					 , abSharedDeviceMemHeap
-	    );
+				 hDevMemContextInt,
+				 &psGetDevMemHeapInfoOUT->ui32ClientHeapCount,
+				 &psGetDevMemHeapInfoOUT->sHeapInfo[0],
+				 abSharedDeviceMemHeap);
 
-	if (psGetDevMemHeapInfoOUT->eError != PVRSRV_OK) {
+	if (psGetDevMemHeapInfoOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	for (i = 0; i < psGetDevMemHeapInfoOUT->ui32ClientHeapCount; i++) {
-		IMG_HANDLE hDevMemHeapExt;
-
-		if (abSharedDeviceMemHeap[i])
-		{
+		void *hDevMemHeapExt;
 
+		if (abSharedDeviceMemHeap[i]) {
 			PVRSRVAllocHandleNR(psPerProc->psHandleBase,
-					    &hDevMemHeapExt,
-					    psGetDevMemHeapInfoOUT->
-					    sHeapInfo[i].hDevMemHeap,
-					    PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP,
-					    PVRSRV_HANDLE_ALLOC_FLAG_SHARED);
-		}
-		else {
+			       &hDevMemHeapExt,
+			       psGetDevMemHeapInfoOUT->sHeapInfo[i].hDevMemHeap,
+			       PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP,
+			       PVRSRV_HANDLE_ALLOC_FLAG_SHARED);
+		} else {
 
 			psGetDevMemHeapInfoOUT->eError =
 			    PVRSRVFindHandle(psPerProc->psHandleBase,
@@ -486,9 +447,8 @@
 					     psGetDevMemHeapInfoOUT->
 					     sHeapInfo[i].hDevMemHeap,
 					     PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP);
-			if (psGetDevMemHeapInfoOUT->eError != PVRSRV_OK) {
+			if (psGetDevMemHeapInfoOUT->eError != PVRSRV_OK)
 				return 0;
-			}
 		}
 		psGetDevMemHeapInfoOUT->sHeapInfo[i].hDevMemHeap =
 		    hDevMemHeapExt;
@@ -499,15 +459,14 @@
 	return 0;
 }
 
-static int
-PVRSRVAllocDeviceMemBW(IMG_UINT32 ui32BridgeID,
-		       PVRSRV_BRIDGE_IN_ALLOCDEVICEMEM * psAllocDeviceMemIN,
-		       PVRSRV_BRIDGE_OUT_ALLOCDEVICEMEM * psAllocDeviceMemOUT,
-		       PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	PVRSRV_KERNEL_MEM_INFO *psMemInfo;
-	IMG_HANDLE hDevCookieInt;
-	IMG_HANDLE hDevMemHeapInt;
+static int PVRSRVAllocDeviceMemBW(u32 ui32BridgeID,
+	       struct PVRSRV_BRIDGE_IN_ALLOCDEVICEMEM *psAllocDeviceMemIN,
+	       struct PVRSRV_BRIDGE_OUT_ALLOCDEVICEMEM *psAllocDeviceMemOUT,
+	       struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	struct PVRSRV_KERNEL_MEM_INFO *psMemInfo;
+	void *hDevCookieInt;
+	void *hDevMemHeapInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_ALLOC_DEVICEMEM);
 
@@ -518,18 +477,16 @@
 			       psAllocDeviceMemIN->hDevCookie,
 			       PVRSRV_HANDLE_TYPE_DEV_NODE);
 
-	if (psAllocDeviceMemOUT->eError != PVRSRV_OK) {
+	if (psAllocDeviceMemOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psAllocDeviceMemOUT->eError =
 	    PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevMemHeapInt,
 			       psAllocDeviceMemIN->hDevMemHeap,
 			       PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP);
 
-	if (psAllocDeviceMemOUT->eError != PVRSRV_OK) {
+	if (psAllocDeviceMemOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psAllocDeviceMemOUT->eError =
 	    PVRSRVAllocDeviceMemKM(hDevCookieInt,
@@ -540,21 +497,19 @@
 				   psAllocDeviceMemIN->ui32Alignment,
 				   &psMemInfo);
 
-	if (psAllocDeviceMemOUT->eError != PVRSRV_OK) {
+	if (psAllocDeviceMemOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	OSMemSet(&psAllocDeviceMemOUT->sClientMemInfo,
 		 0, sizeof(psAllocDeviceMemOUT->sClientMemInfo));
 
-	if (psMemInfo->pvLinAddrKM) {
+	if (psMemInfo->pvLinAddrKM)
 		psAllocDeviceMemOUT->sClientMemInfo.pvLinAddrKM =
 		    psMemInfo->pvLinAddrKM;
-	} else {
+	else
 		psAllocDeviceMemOUT->sClientMemInfo.pvLinAddrKM =
 		    psMemInfo->sMemBlk.hOSMemHandle;
-	}
-	psAllocDeviceMemOUT->sClientMemInfo.pvLinAddr = 0;
+	psAllocDeviceMemOUT->sClientMemInfo.pvLinAddr = NULL;
 	psAllocDeviceMemOUT->sClientMemInfo.sDevVAddr = psMemInfo->sDevVAddr;
 	psAllocDeviceMemOUT->sClientMemInfo.ui32Flags = psMemInfo->ui32Flags;
 	psAllocDeviceMemOUT->sClientMemInfo.ui32AllocSize =
@@ -571,9 +526,9 @@
 	if (psAllocDeviceMemIN->ui32Attribs & PVRSRV_MEM_NO_SYNCOBJ) {
 
 		OSMemSet(&psAllocDeviceMemOUT->sClientSyncInfo,
-			 0, sizeof(PVRSRV_CLIENT_SYNC_INFO));
-		psAllocDeviceMemOUT->sClientMemInfo.psClientSyncInfo = IMG_NULL;
-		psAllocDeviceMemOUT->psKernelSyncInfo = IMG_NULL;
+			 0, sizeof(struct PVRSRV_CLIENT_SYNC_INFO));
+		psAllocDeviceMemOUT->sClientMemInfo.psClientSyncInfo = NULL;
+		psAllocDeviceMemOUT->psKernelSyncInfo = NULL;
 	} else {
 
 		psAllocDeviceMemOUT->psKernelSyncInfo =
@@ -610,14 +565,13 @@
 }
 
 
-static int
-PVRSRVFreeDeviceMemBW(IMG_UINT32 ui32BridgeID,
-		      PVRSRV_BRIDGE_IN_FREEDEVICEMEM * psFreeDeviceMemIN,
-		      PVRSRV_BRIDGE_RETURN * psRetOUT,
-		      PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVFreeDeviceMemBW(u32 ui32BridgeID,
+		      struct PVRSRV_BRIDGE_IN_FREEDEVICEMEM *psFreeDeviceMemIN,
+		      struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+		      struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hDevCookieInt;
-	IMG_VOID *pvKernelMemInfo;
+	void *hDevCookieInt;
+	void *pvKernelMemInfo;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_FREE_DEVICEMEM);
 
@@ -626,25 +580,22 @@
 			       psFreeDeviceMemIN->hDevCookie,
 			       PVRSRV_HANDLE_TYPE_DEV_NODE);
 
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVLookupHandle(psPerProc->psHandleBase, &pvKernelMemInfo,
 			       psFreeDeviceMemIN->psKernelMemInfo,
 			       PVRSRV_HANDLE_TYPE_MEM_INFO);
 
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVFreeDeviceMemKM(hDevCookieInt, pvKernelMemInfo);
 
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVReleaseHandle(psPerProc->psHandleBase,
@@ -654,60 +605,53 @@
 	return 0;
 }
 
-static int
-PVRSRVMapDeviceMemoryBW(IMG_UINT32 ui32BridgeID,
-			PVRSRV_BRIDGE_IN_MAP_DEV_MEMORY * psMapDevMemIN,
-			PVRSRV_BRIDGE_OUT_MAP_DEV_MEMORY * psMapDevMemOUT,
-			PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	PVRSRV_KERNEL_MEM_INFO *psSrcKernelMemInfo = IMG_NULL;
-	PVRSRV_KERNEL_MEM_INFO *psDstKernelMemInfo = IMG_NULL;
-	IMG_HANDLE hDstDevMemHeap = IMG_NULL;
+static int PVRSRVMapDeviceMemoryBW(u32 ui32BridgeID,
+			struct PVRSRV_BRIDGE_IN_MAP_DEV_MEMORY *psMapDevMemIN,
+			struct PVRSRV_BRIDGE_OUT_MAP_DEV_MEMORY *psMapDevMemOUT,
+			struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	struct PVRSRV_KERNEL_MEM_INFO *psSrcKernelMemInfo = NULL;
+	struct PVRSRV_KERNEL_MEM_INFO *psDstKernelMemInfo = NULL;
+	void *hDstDevMemHeap = NULL;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_MAP_DEV_MEMORY);
 
 	NEW_HANDLE_BATCH_OR_ERROR(psMapDevMemOUT->eError, psPerProc, 2);
 
 	psMapDevMemOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
-						    (IMG_VOID **) &
-						    psSrcKernelMemInfo,
-						    psMapDevMemIN->
-						    psSrcKernelMemInfo,
-						    PVRSRV_HANDLE_TYPE_MEM_INFO);
-	if (psMapDevMemOUT->eError != PVRSRV_OK) {
+					    (void **)&psSrcKernelMemInfo,
+					    psMapDevMemIN->psSrcKernelMemInfo,
+					    PVRSRV_HANDLE_TYPE_MEM_INFO);
+	if (psMapDevMemOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psMapDevMemOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
-						    &hDstDevMemHeap,
-						    psMapDevMemIN->
-						    hDstDevMemHeap,
-						    PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP);
-	if (psMapDevMemOUT->eError != PVRSRV_OK) {
+					    &hDstDevMemHeap,
+					    psMapDevMemIN->
+					    hDstDevMemHeap,
+					    PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP);
+	if (psMapDevMemOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psMapDevMemOUT->eError = PVRSRVMapDeviceMemoryKM(psPerProc,
 							 psSrcKernelMemInfo,
 							 hDstDevMemHeap,
 							 &psDstKernelMemInfo);
-	if (psMapDevMemOUT->eError != PVRSRV_OK) {
+	if (psMapDevMemOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	OSMemSet(&psMapDevMemOUT->sDstClientMemInfo,
 		 0, sizeof(psMapDevMemOUT->sDstClientMemInfo));
 	OSMemSet(&psMapDevMemOUT->sDstClientSyncInfo,
 		 0, sizeof(psMapDevMemOUT->sDstClientSyncInfo));
 
-	if (psDstKernelMemInfo->pvLinAddrKM) {
+	if (psDstKernelMemInfo->pvLinAddrKM)
 		psMapDevMemOUT->sDstClientMemInfo.pvLinAddrKM =
 		    psDstKernelMemInfo->pvLinAddrKM;
-	} else {
+	else
 		psMapDevMemOUT->sDstClientMemInfo.pvLinAddrKM =
 		    psDstKernelMemInfo->sMemBlk.hOSMemHandle;
-	}
-	psMapDevMemOUT->sDstClientMemInfo.pvLinAddr = 0;
+	psMapDevMemOUT->sDstClientMemInfo.pvLinAddr = NULL;
 	psMapDevMemOUT->sDstClientMemInfo.sDevVAddr =
 	    psDstKernelMemInfo->sDevVAddr;
 	psMapDevMemOUT->sDstClientMemInfo.ui32Flags =
@@ -722,8 +666,8 @@
 			    psDstKernelMemInfo,
 			    PVRSRV_HANDLE_TYPE_MEM_INFO,
 			    PVRSRV_HANDLE_ALLOC_FLAG_NONE);
-	psMapDevMemOUT->sDstClientSyncInfo.hKernelSyncInfo = IMG_NULL;
-	psMapDevMemOUT->psDstKernelSyncInfo = IMG_NULL;
+	psMapDevMemOUT->sDstClientSyncInfo.hKernelSyncInfo = NULL;
+	psMapDevMemOUT->psDstKernelSyncInfo = NULL;
 
 	if (psDstKernelMemInfo->psKernelSyncInfo) {
 		psMapDevMemOUT->psDstKernelSyncInfo =
@@ -760,28 +704,25 @@
 	return 0;
 }
 
-static int
-PVRSRVUnmapDeviceMemoryBW(IMG_UINT32 ui32BridgeID,
-			  PVRSRV_BRIDGE_IN_UNMAP_DEV_MEMORY * psUnmapDevMemIN,
-			  PVRSRV_BRIDGE_RETURN * psRetOUT,
-			  PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVUnmapDeviceMemoryBW(u32 ui32BridgeID,
+		  struct PVRSRV_BRIDGE_IN_UNMAP_DEV_MEMORY *psUnmapDevMemIN,
+		  struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+		  struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo = IMG_NULL;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo = NULL;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_UNMAP_DEV_MEMORY);
 
 	psRetOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
-					      (IMG_VOID **) & psKernelMemInfo,
+					      (void **) &psKernelMemInfo,
 					      psUnmapDevMemIN->psKernelMemInfo,
 					      PVRSRV_HANDLE_TYPE_MEM_INFO);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError = PVRSRVUnmapDeviceMemoryKM(psKernelMemInfo);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError = PVRSRVReleaseHandle(psPerProc->psHandleBase,
 					       psUnmapDevMemIN->psKernelMemInfo,
@@ -790,111 +731,146 @@
 	return 0;
 }
 
-static int
-FlushCacheDRI(IMG_UINT32 ui32Type, IMG_VOID *pvVirt, IMG_UINT32 ui32Length)
+static int FlushCacheDRI(int dir, struct BM_BUF *buf)
 {
-	switch (ui32Type) {
-	case DRM_PVR2D_CFLUSH_FROM_GPU:
-		PVR_DPF((PVR_DBG_MESSAGE,
-			 "DRM_PVR2D_CFLUSH_FROM_GPU 0x%08x, length 0x%08x\n",
-			 pvVirt, ui32Length));
-#ifdef CONFIG_ARM
-		dmac_inv_range((const void *)pvVirt,
-			       (const void *)(pvVirt + ui32Length));
-#endif
-		return 0;
-	case DRM_PVR2D_CFLUSH_TO_GPU:
-		PVR_DPF((PVR_DBG_MESSAGE,
-			 "DRM_PVR2D_CFLUSH_TO_GPU 0x%08x, length 0x%08x\n",
-			 pvVirt, ui32Length));
-#ifdef CONFIG_ARM
-		dmac_clean_range((const void *)pvVirt,
-				 (const void *)(pvVirt + ui32Length));
-#endif
+	unsigned long s, e;
+	struct IMG_SYS_PHYADDR *paddr;
+	int pg_cnt;
+
+	s = (unsigned long)buf->pMapping->CpuVAddr;
+	e = s + buf->pMapping->uSize;
+	if (s == e)
 		return 0;
-	default:
-		PVR_DPF((PVR_DBG_ERROR, "Invalid cflush type 0x%x\n",
-			 ui32Type));
-		return -EINVAL;
+
+	pg_cnt = (PAGE_ALIGN(e) - (s & PAGE_MASK)) / PAGE_SIZE;
+	paddr = buf->pvPageList;
+
+	for (; pg_cnt; pg_cnt--) {
+		struct page *page;
+		size_t chunk;
+		void *kaddr;
+
+		page = pfn_to_page(paddr->uiAddr >> PAGE_SHIFT);
+		kaddr = page_address(page);
+		/* Adjust for the first page */
+		kaddr += s & ~PAGE_MASK;
+		chunk = PAGE_SIZE - (s & ~PAGE_MASK);
+
+		/* Adjust for the last page */
+		chunk = min_t(ssize_t, e - s, chunk);
+		dma_cache_maint(kaddr, chunk, dir);
+
+		s += chunk;
+
+		paddr++;
 	}
 
 	return 0;
 }
 
-PVRSRV_ERROR
-PVRSRVIsWrappedExtMemoryBW(PVRSRV_PER_PROCESS_DATA *psPerProc,
-			   PVRSRV_BRIDGE_IN_CACHEFLUSHDRMFROMUSER *psCacheFlushIN)
-{
-	PVRSRV_ERROR eError;
-	IMG_HANDLE hDevCookieInt;
-
-	PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevCookieInt,
-						   psCacheFlushIN->hDevCookie,
-						   PVRSRV_HANDLE_TYPE_DEV_NODE);
-
-	eError = PVRSRVIsWrappedExtMemoryKM(
-					hDevCookieInt,
-					psPerProc,
-					&(psCacheFlushIN->ui32Length),
-					&(psCacheFlushIN->pvVirt));
+static struct BM_BUF *get_dev_buf(void *dev_cookie, void *virt_addr)
+{
+	struct BM_BUF *buf;
+	void *heap;
+	struct PVRSRV_DEVICE_NODE *devnode;
+	struct DEVICE_MEMORY_INFO *dev_mem_info;
 
-	return eError;
+	devnode = (struct PVRSRV_DEVICE_NODE *)dev_cookie;
+	dev_mem_info = &devnode->sDevMemoryInfo;
+	heap = dev_mem_info->
+		psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].hDevMemHeap;
+	buf = bm_get_buf_virt(heap, virt_addr);
+	if (buf)
+		return buf;
+
+	heap = dev_mem_info->
+		psDeviceMemoryHeap[SGX_ALT_MAPPING_HEAP_ID].hDevMemHeap;
+	buf = bm_get_buf_virt(heap, virt_addr);
+	return buf;
 }
 
-static int
-PVRSRVCacheFlushDRIBW(IMG_UINT32 ui32BridgeID,
-		      PVRSRV_BRIDGE_IN_CACHEFLUSHDRMFROMUSER * psCacheFlushIN,
-		      PVRSRV_BRIDGE_RETURN * psRetOUT,
-		      PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVCacheFlushDRIBW(u32 ui32BridgeID,
+	      struct PVRSRV_BRIDGE_IN_CACHEFLUSHDRMFROMUSER *psCacheFlushIN,
+	      struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	      struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	PVRSRV_ERROR eError;
+	void *dev_cookie_int;
+	void *start;
+	size_t length;
+	int res = 0;
+	struct BM_BUF *dev_buf;
+	int dir;
+
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_CACHE_FLUSH_DRM);
 
+	switch (psCacheFlushIN->ui32Type) {
+	case DRM_PVR2D_CFLUSH_FROM_GPU:
+		dir = DMA_FROM_DEVICE;
+		PVR_DPF(PVR_DBG_MESSAGE,
+			 "DRM_PVR2D_CFLUSH_FROM_GPU 0x%08x, length 0x%08x\n",
+			 pvVirt, ui32Length);
+		break;
+	case DRM_PVR2D_CFLUSH_TO_GPU:
+		dir = DMA_TO_DEVICE;
+		PVR_DPF(PVR_DBG_MESSAGE,
+			 "DRM_PVR2D_CFLUSH_TO_GPU 0x%08x, length 0x%08x\n",
+			 pvVirt, ui32Length);
+		break;
+	default:
+		PVR_DPF(PVR_DBG_ERROR, "Invalid cflush type 0x%x\n",
+			 ui32Type);
+		return -EINVAL;
+	}
+
+	PVRSRVLookupHandle(psPerProc->psHandleBase, &dev_cookie_int,
+			   psCacheFlushIN->hDevCookie,
+			   PVRSRV_HANDLE_TYPE_DEV_NODE);
+	PVR_ASSERT(dev_cookie_int);
+
+	start = psCacheFlushIN->pvVirt;
+	length = psCacheFlushIN->ui32Length;
+
 	down_read(&current->mm->mmap_sem);
 
-	eError = PVRSRVIsWrappedExtMemoryBW(psPerProc, psCacheFlushIN);
+	dev_buf = get_dev_buf(dev_cookie_int, start);
 
-	if (eError == PVRSRV_OK) {
-		psRetOUT->eError = FlushCacheDRI(psCacheFlushIN->ui32Type,
-											psCacheFlushIN->pvVirt,
-											psCacheFlushIN->ui32Length);
+	if (dev_buf && length <= dev_buf->pMapping->uSize) {
+		psRetOUT->eError = FlushCacheDRI(dir, dev_buf);
 	} else {
 		printk(KERN_WARNING
-			": PVRSRVCacheFlushDRIBW: Start address 0x%08x and length 0x%08x not wrapped \n",
-			(unsigned int)(psCacheFlushIN->pvVirt),
-			(unsigned int)(psCacheFlushIN->ui32Length));
+			"%s: Start address %p and length %#08x not wrapped \n",
+			__func__,
+			start, length);
+		res = -EINVAL;
 	}
 
 	up_read(&current->mm->mmap_sem);
-	return 0;
+
+	return res;
 }
 
-static int
-PVRSRVMapDeviceClassMemoryBW(IMG_UINT32 ui32BridgeID,
-			     PVRSRV_BRIDGE_IN_MAP_DEVICECLASS_MEMORY *
-			     psMapDevClassMemIN,
-			     PVRSRV_BRIDGE_OUT_MAP_DEVICECLASS_MEMORY *
-			     psMapDevClassMemOUT,
-			     PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	PVRSRV_KERNEL_MEM_INFO *psMemInfo;
-	IMG_HANDLE hOSMapInfo;
-	IMG_HANDLE hDeviceClassBufferInt;
-	PVRSRV_HANDLE_TYPE eHandleType;
+static int PVRSRVMapDeviceClassMemoryBW(u32 ui32BridgeID,
+	   struct PVRSRV_BRIDGE_IN_MAP_DEVICECLASS_MEMORY *psMapDevClassMemIN,
+	   struct PVRSRV_BRIDGE_OUT_MAP_DEVICECLASS_MEMORY *psMapDevClassMemOUT,
+	   struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	struct PVRSRV_KERNEL_MEM_INFO *psMemInfo;
+	void *hOSMapInfo;
+	void *hDeviceClassBufferInt;
+	enum PVRSRV_HANDLE_TYPE eHandleType;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
-				 PVRSRV_BRIDGE_MAP_DEVICECLASS_MEMORY);
+			PVRSRV_BRIDGE_MAP_DEVICECLASS_MEMORY);
 
 	NEW_HANDLE_BATCH_OR_ERROR(psMapDevClassMemOUT->eError, psPerProc, 2);
 
 	psMapDevClassMemOUT->eError =
-	    PVRSRVLookupHandleAnyType(psPerProc->psHandleBase,
-				      &hDeviceClassBufferInt, &eHandleType,
-				      psMapDevClassMemIN->hDeviceClassBuffer);
+		PVRSRVLookupHandleAnyType(psPerProc->psHandleBase,
+				&hDeviceClassBufferInt, &eHandleType,
+				psMapDevClassMemIN->hDeviceClassBuffer);
 
-	if (psMapDevClassMemOUT->eError != PVRSRV_OK) {
+	if (psMapDevClassMemOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	switch (eHandleType) {
 	case PVRSRV_HANDLE_TYPE_DISP_BUFFER:
@@ -906,70 +882,68 @@
 	}
 
 	psMapDevClassMemOUT->eError =
-	    PVRSRVMapDeviceClassMemoryKM(psPerProc,
-					 hDeviceClassBufferInt,
-					 &psMemInfo, &hOSMapInfo);
+		PVRSRVMapDeviceClassMemoryKM(psPerProc,
+				hDeviceClassBufferInt,
+				&psMemInfo, &hOSMapInfo);
 
-	if (psMapDevClassMemOUT->eError != PVRSRV_OK) {
+	if (psMapDevClassMemOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	OSMemSet(&psMapDevClassMemOUT->sClientMemInfo,
-		 0, sizeof(psMapDevClassMemOUT->sClientMemInfo));
+			0, sizeof(psMapDevClassMemOUT->sClientMemInfo));
 	OSMemSet(&psMapDevClassMemOUT->sClientSyncInfo,
-		 0, sizeof(psMapDevClassMemOUT->sClientSyncInfo));
+			0, sizeof(psMapDevClassMemOUT->sClientSyncInfo));
 
-	if (psMemInfo->pvLinAddrKM) {
+	if (psMemInfo->pvLinAddrKM)
 		psMapDevClassMemOUT->sClientMemInfo.pvLinAddrKM =
-		    psMemInfo->pvLinAddrKM;
-	} else {
+			psMemInfo->pvLinAddrKM;
+	else
 		psMapDevClassMemOUT->sClientMemInfo.pvLinAddrKM =
-		    psMemInfo->sMemBlk.hOSMemHandle;
-	}
-	psMapDevClassMemOUT->sClientMemInfo.pvLinAddr = 0;
+			psMemInfo->sMemBlk.hOSMemHandle;
+	psMapDevClassMemOUT->sClientMemInfo.pvLinAddr = NULL;
 	psMapDevClassMemOUT->sClientMemInfo.sDevVAddr = psMemInfo->sDevVAddr;
 	psMapDevClassMemOUT->sClientMemInfo.ui32Flags = psMemInfo->ui32Flags;
 	psMapDevClassMemOUT->sClientMemInfo.ui32AllocSize =
-	    psMemInfo->ui32AllocSize;
+		psMemInfo->ui32AllocSize;
 	psMapDevClassMemOUT->sClientMemInfo.hMappingInfo =
-	    psMemInfo->sMemBlk.hOSMemHandle;
+		psMemInfo->sMemBlk.hOSMemHandle;
 
 	PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
-			       &psMapDevClassMemOUT->sClientMemInfo.
-			       hKernelMemInfo, psMemInfo,
-			       PVRSRV_HANDLE_TYPE_MEM_INFO,
-			       PVRSRV_HANDLE_ALLOC_FLAG_NONE,
-			       psMapDevClassMemIN->hDeviceClassBuffer);
+			&psMapDevClassMemOUT->sClientMemInfo.
+			hKernelMemInfo, psMemInfo,
+			PVRSRV_HANDLE_TYPE_MEM_INFO,
+			PVRSRV_HANDLE_ALLOC_FLAG_NONE,
+			psMapDevClassMemIN->hDeviceClassBuffer);
 
-	psMapDevClassMemOUT->sClientSyncInfo.hKernelSyncInfo = IMG_NULL;
-	psMapDevClassMemOUT->psKernelSyncInfo = IMG_NULL;
+	psMapDevClassMemOUT->sClientSyncInfo.hKernelSyncInfo = NULL;
+	psMapDevClassMemOUT->psKernelSyncInfo = NULL;
 
 	if (psMemInfo->psKernelSyncInfo) {
 		psMapDevClassMemOUT->psKernelSyncInfo =
-		    psMemInfo->psKernelSyncInfo;
+			psMemInfo->psKernelSyncInfo;
 
 		psMapDevClassMemOUT->sClientSyncInfo.psSyncData =
-		    psMemInfo->psKernelSyncInfo->psSyncData;
+			psMemInfo->psKernelSyncInfo->psSyncData;
 		psMapDevClassMemOUT->sClientSyncInfo.sWriteOpsCompleteDevVAddr =
-		    psMemInfo->psKernelSyncInfo->sWriteOpsCompleteDevVAddr;
+			psMemInfo->psKernelSyncInfo->sWriteOpsCompleteDevVAddr;
 		psMapDevClassMemOUT->sClientSyncInfo.sReadOpsCompleteDevVAddr =
-		    psMemInfo->psKernelSyncInfo->sReadOpsCompleteDevVAddr;
+			psMemInfo->psKernelSyncInfo->sReadOpsCompleteDevVAddr;
 
 		psMapDevClassMemOUT->sClientSyncInfo.hMappingInfo =
-		    psMemInfo->psKernelSyncInfo->psSyncDataMemInfoKM->sMemBlk.
-		    hOSMemHandle;
+				psMemInfo->psKernelSyncInfo->
+				     psSyncDataMemInfoKM->sMemBlk.hOSMemHandle;
 
 		psMapDevClassMemOUT->sClientMemInfo.psClientSyncInfo =
-		    &psMapDevClassMemOUT->sClientSyncInfo;
+			&psMapDevClassMemOUT->sClientSyncInfo;
 
 		PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
-				       &psMapDevClassMemOUT->sClientSyncInfo.
-				       hKernelSyncInfo,
-				       psMemInfo->psKernelSyncInfo,
-				       PVRSRV_HANDLE_TYPE_SYNC_INFO,
-				       PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
-				       psMapDevClassMemOUT->sClientMemInfo.
-				       hKernelMemInfo);
+				&psMapDevClassMemOUT->sClientSyncInfo.
+				hKernelSyncInfo,
+				psMemInfo->psKernelSyncInfo,
+				PVRSRV_HANDLE_TYPE_SYNC_INFO,
+				PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
+				psMapDevClassMemOUT->sClientMemInfo.
+				hKernelMemInfo);
 	}
 
 	COMMIT_HANDLE_BATCH_OR_ERROR(psMapDevClassMemOUT->eError, psPerProc);
@@ -977,14 +951,12 @@
 	return 0;
 }
 
-static int
-PVRSRVUnmapDeviceClassMemoryBW(IMG_UINT32 ui32BridgeID,
-			       PVRSRV_BRIDGE_IN_UNMAP_DEVICECLASS_MEMORY *
-			       psUnmapDevClassMemIN,
-			       PVRSRV_BRIDGE_RETURN * psRetOUT,
-			       PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVUnmapDeviceClassMemoryBW(u32 ui32BridgeID,
+	 struct PVRSRV_BRIDGE_IN_UNMAP_DEVICECLASS_MEMORY *psUnmapDevClassMemIN,
+	 struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	 struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvKernelMemInfo;
+	void *pvKernelMemInfo;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_UNMAP_DEVICECLASS_MEMORY);
@@ -993,15 +965,13 @@
 	    PVRSRVLookupHandle(psPerProc->psHandleBase, &pvKernelMemInfo,
 			       psUnmapDevClassMemIN->psKernelMemInfo,
 			       PVRSRV_HANDLE_TYPE_MEM_INFO);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError = PVRSRVUnmapDeviceClassMemoryKM(pvKernelMemInfo);
 
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVReleaseHandle(psPerProc->psHandleBase,
@@ -1011,16 +981,15 @@
 	return 0;
 }
 
-static int
-PVRSRVWrapExtMemoryBW(IMG_UINT32 ui32BridgeID,
-		      PVRSRV_BRIDGE_IN_WRAP_EXT_MEMORY * psWrapExtMemIN,
-		      PVRSRV_BRIDGE_OUT_WRAP_EXT_MEMORY * psWrapExtMemOUT,
-		      PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	IMG_HANDLE hDevCookieInt;
-	PVRSRV_KERNEL_MEM_INFO *psMemInfo;
-	IMG_UINT32 ui32PageTableSize = 0;
-	IMG_SYS_PHYADDR *psSysPAddr = IMG_NULL;
+static int PVRSRVWrapExtMemoryBW(u32 ui32BridgeID,
+		      struct PVRSRV_BRIDGE_IN_WRAP_EXT_MEMORY *psWrapExtMemIN,
+		      struct PVRSRV_BRIDGE_OUT_WRAP_EXT_MEMORY *psWrapExtMemOUT,
+		      struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	void *hDevCookieInt;
+	struct PVRSRV_KERNEL_MEM_INFO *psMemInfo;
+	u32 ui32PageTableSize = 0;
+	struct IMG_SYS_PHYADDR *psSysPAddr = NULL;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_WRAP_EXT_MEMORY);
 
@@ -1030,19 +999,17 @@
 	    PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevCookieInt,
 			       psWrapExtMemIN->hDevCookie,
 			       PVRSRV_HANDLE_TYPE_DEV_NODE);
-	if (psWrapExtMemOUT->eError != PVRSRV_OK) {
+	if (psWrapExtMemOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	if (psWrapExtMemIN->ui32NumPageTableEntries) {
 		ui32PageTableSize = psWrapExtMemIN->ui32NumPageTableEntries
-		    * sizeof(IMG_SYS_PHYADDR);
+		    * sizeof(struct IMG_SYS_PHYADDR);
 
 		ASSIGN_AND_EXIT_ON_ERROR(psWrapExtMemOUT->eError,
 					 OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-						    ui32PageTableSize,
-						    (IMG_VOID **) & psSysPAddr,
-						    0));
+						   ui32PageTableSize,
+						   (void **)&psSysPAddr, NULL));
 
 		if (CopyFromUserWrapper(psPerProc,
 					ui32BridgeID,
@@ -1050,7 +1017,7 @@
 					psWrapExtMemIN->psSysPAddr,
 					ui32PageTableSize) != PVRSRV_OK) {
 			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32PageTableSize,
-				  (IMG_VOID *) psSysPAddr, 0);
+				  (void *) psSysPAddr, NULL);
 			return -EFAULT;
 		}
 	}
@@ -1068,24 +1035,23 @@
 		if (psWrapExtMemIN->ui32NumPageTableEntries)
 			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
 				  ui32PageTableSize,
-				  (IMG_VOID *) psSysPAddr, 0);
+				  (void *) psSysPAddr, NULL);
 		return 0;
 	}
 
-	if (psMemInfo->pvLinAddrKM) {
+	if (psMemInfo->pvLinAddrKM)
 		psWrapExtMemOUT->sClientMemInfo.pvLinAddrKM =
 		    psMemInfo->pvLinAddrKM;
-	} else {
+	else
 		psWrapExtMemOUT->sClientMemInfo.pvLinAddrKM =
 		    psMemInfo->sMemBlk.hOSMemHandle;
-	}
 
-	psWrapExtMemOUT->sClientMemInfo.pvLinAddr = 0;
+	psWrapExtMemOUT->sClientMemInfo.pvLinAddr = NULL;
 	psWrapExtMemOUT->sClientMemInfo.sDevVAddr = psMemInfo->sDevVAddr;
 	psWrapExtMemOUT->sClientMemInfo.ui32Flags = psMemInfo->ui32Flags;
 	psWrapExtMemOUT->sClientMemInfo.ui32AllocSize =
 	    psMemInfo->ui32AllocSize;
-	psWrapExtMemOUT->sClientMemInfo.hMappingInfo = IMG_NULL;
+	psWrapExtMemOUT->sClientMemInfo.hMappingInfo = NULL;
 
 	PVRSRVAllocHandleNR(psPerProc->psHandleBase,
 			    &psWrapExtMemOUT->sClientMemInfo.hKernelMemInfo,
@@ -1110,7 +1076,7 @@
 	PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
 			       &psWrapExtMemOUT->sClientSyncInfo.
 			       hKernelSyncInfo,
-			       (IMG_HANDLE) psMemInfo->psKernelSyncInfo,
+			       (void *) psMemInfo->psKernelSyncInfo,
 			       PVRSRV_HANDLE_TYPE_SYNC_INFO,
 			       PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
 			       psWrapExtMemOUT->sClientMemInfo.hKernelMemInfo);
@@ -1120,13 +1086,12 @@
 	return 0;
 }
 
-static int
-PVRSRVUnwrapExtMemoryBW(IMG_UINT32 ui32BridgeID,
-			PVRSRV_BRIDGE_IN_UNWRAP_EXT_MEMORY * psUnwrapExtMemIN,
-			PVRSRV_BRIDGE_RETURN * psRetOUT,
-			PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVUnwrapExtMemoryBW(u32 ui32BridgeID,
+		struct PVRSRV_BRIDGE_IN_UNWRAP_EXT_MEMORY *psUnwrapExtMemIN,
+		struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvMemInfo;
+	void *pvMemInfo;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_UNWRAP_EXT_MEMORY);
 
@@ -1135,15 +1100,13 @@
 			       &pvMemInfo,
 			       psUnwrapExtMemIN->hKernelMemInfo,
 			       PVRSRV_HANDLE_TYPE_MEM_INFO);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
-	    PVRSRVUnwrapExtMemoryKM((PVRSRV_KERNEL_MEM_INFO *) pvMemInfo);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	    PVRSRVUnwrapExtMemoryKM((struct PVRSRV_KERNEL_MEM_INFO *)pvMemInfo);
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVReleaseHandle(psPerProc->psHandleBase,
@@ -1153,13 +1116,10 @@
 	return 0;
 }
 
-static int
-PVRSRVGetFreeDeviceMemBW(IMG_UINT32 ui32BridgeID,
-			 PVRSRV_BRIDGE_IN_GETFREEDEVICEMEM *
-			 psGetFreeDeviceMemIN,
-			 PVRSRV_BRIDGE_OUT_GETFREEDEVICEMEM *
-			 psGetFreeDeviceMemOUT,
-			 PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVGetFreeDeviceMemBW(u32 ui32BridgeID,
+	 struct PVRSRV_BRIDGE_IN_GETFREEDEVICEMEM *psGetFreeDeviceMemIN,
+	 struct PVRSRV_BRIDGE_OUT_GETFREEDEVICEMEM *psGetFreeDeviceMemOUT,
+	 struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_GETFREE_DEVICEMEM);
 
@@ -1174,13 +1134,10 @@
 	return 0;
 }
 
-static int
-PVRMMapKVIndexAddressToMMapDataBW(IMG_UINT32 ui32BridgeID,
-				  PVRSRV_BRIDGE_IN_KV_TO_MMAP_DATA *
-				  psMMapDataIN,
-				  PVRSRV_BRIDGE_OUT_KV_TO_MMAP_DATA *
-				  psMMapDataOUT,
-				  PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRMMapKVIndexAddressToMMapDataBW(u32 ui32BridgeID,
+		  struct PVRSRV_BRIDGE_IN_KV_TO_MMAP_DATA *psMMapDataIN,
+		  struct PVRSRV_BRIDGE_OUT_KV_TO_MMAP_DATA *psMMapDataOUT,
+		  struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_KV_TO_MMAP_DATA);
 	PVR_UNREFERENCED_PARAMETER(psMMapDataIN);
@@ -1197,12 +1154,10 @@
 }
 
 #ifdef PDUMP
-static int
-PDumpIsCaptureFrameBW(IMG_UINT32 ui32BridgeID,
-		      IMG_VOID * psBridgeIn,
-		      PVRSRV_BRIDGE_OUT_PDUMP_ISCAPTURING *
-		      psPDumpIsCapturingOUT,
-		      PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PDumpIsCaptureFrameBW(u32 ui32BridgeID,
+	      void *psBridgeIn,
+	      struct PVRSRV_BRIDGE_OUT_PDUMP_ISCAPTURING *psPDumpIsCapturingOUT,
+	      struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_ISCAPTURING);
 	PVR_UNREFERENCED_PARAMETER(psBridgeIn);
@@ -1214,11 +1169,10 @@
 	return 0;
 }
 
-static int
-PDumpCommentBW(IMG_UINT32 ui32BridgeID,
-	       PVRSRV_BRIDGE_IN_PDUMP_COMMENT * psPDumpCommentIN,
-	       PVRSRV_BRIDGE_RETURN * psRetOUT,
-	       PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PDumpCommentBW(u32 ui32BridgeID,
+	       struct PVRSRV_BRIDGE_IN_PDUMP_COMMENT *psPDumpCommentIN,
+	       struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	       struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_COMMENT);
 	PVR_UNREFERENCED_PARAMETER(psPerProc);
@@ -1228,11 +1182,10 @@
 	return 0;
 }
 
-static int
-PDumpSetFrameBW(IMG_UINT32 ui32BridgeID,
-		PVRSRV_BRIDGE_IN_PDUMP_SETFRAME * psPDumpSetFrameIN,
-		PVRSRV_BRIDGE_RETURN * psRetOUT,
-		PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PDumpSetFrameBW(u32 ui32BridgeID,
+		struct PVRSRV_BRIDGE_IN_PDUMP_SETFRAME *psPDumpSetFrameIN,
+		struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_SETFRAME);
 	PVR_UNREFERENCED_PARAMETER(psPerProc);
@@ -1242,11 +1195,10 @@
 	return 0;
 }
 
-static int
-PDumpRegWithFlagsBW(IMG_UINT32 ui32BridgeID,
-		    PVRSRV_BRIDGE_IN_PDUMP_DUMPREG * psPDumpRegDumpIN,
-		    PVRSRV_BRIDGE_RETURN * psRetOUT,
-		    PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PDumpRegWithFlagsBW(u32 ui32BridgeID,
+		    struct PVRSRV_BRIDGE_IN_PDUMP_DUMPREG *psPDumpRegDumpIN,
+		    struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+		    struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_REG);
 	PVR_UNREFERENCED_PARAMETER(psPerProc);
@@ -1259,11 +1211,10 @@
 	return 0;
 }
 
-static int
-PDumpRegPolBW(IMG_UINT32 ui32BridgeID,
-	      PVRSRV_BRIDGE_IN_PDUMP_REGPOL * psPDumpRegPolIN,
-	      PVRSRV_BRIDGE_RETURN * psRetOUT,
-	      PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PDumpRegPolBW(u32 ui32BridgeID,
+	      struct PVRSRV_BRIDGE_IN_PDUMP_REGPOL *psPDumpRegPolIN,
+	      struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	      struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_REGPOL);
 	PVR_UNREFERENCED_PARAMETER(psPerProc);
@@ -1277,13 +1228,12 @@
 	return 0;
 }
 
-static int
-PDumpMemPolBW(IMG_UINT32 ui32BridgeID,
-	      PVRSRV_BRIDGE_IN_PDUMP_MEMPOL * psPDumpMemPolIN,
-	      PVRSRV_BRIDGE_RETURN * psRetOUT,
-	      PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PDumpMemPolBW(u32 ui32BridgeID,
+	      struct PVRSRV_BRIDGE_IN_PDUMP_MEMPOL *psPDumpMemPolIN,
+	      struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	      struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvMemInfo;
+	void *pvMemInfo;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_MEMPOL);
 
@@ -1292,12 +1242,11 @@
 			       &pvMemInfo,
 			       psPDumpMemPolIN->psKernelMemInfo,
 			       PVRSRV_HANDLE_TYPE_MEM_INFO);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
-	    PDumpMemPolKM(((PVRSRV_KERNEL_MEM_INFO *) pvMemInfo),
+	    PDumpMemPolKM(((struct PVRSRV_KERNEL_MEM_INFO *)pvMemInfo),
 			  psPDumpMemPolIN->ui32Offset,
 			  psPDumpMemPolIN->ui32Value,
 			  psPDumpMemPolIN->ui32Mask,
@@ -1309,15 +1258,15 @@
 	return 0;
 }
 
-static int
-PDumpMemBW(IMG_UINT32 ui32BridgeID,
-	   PVRSRV_BRIDGE_IN_PDUMP_DUMPMEM * psPDumpMemDumpIN,
-	   PVRSRV_BRIDGE_RETURN * psRetOUT, PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	IMG_VOID *pvMemInfo;
-	IMG_VOID *pvAltLinAddrKM = IMG_NULL;
-	IMG_UINT32 ui32Bytes = psPDumpMemDumpIN->ui32Bytes;
-	IMG_HANDLE hBlockAlloc = 0;
+static int PDumpMemBW(u32 ui32BridgeID,
+	   struct PVRSRV_BRIDGE_IN_PDUMP_DUMPMEM *psPDumpMemDumpIN,
+	   struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	   struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	void *pvMemInfo;
+	void *pvAltLinAddrKM = NULL;
+	u32 ui32Bytes = psPDumpMemDumpIN->ui32Bytes;
+	void *hBlockAlloc = 0;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_DUMPMEM);
 
@@ -1326,16 +1275,14 @@
 			       &pvMemInfo,
 			       psPDumpMemDumpIN->psKernelMemInfo,
 			       PVRSRV_HANDLE_TYPE_MEM_INFO);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	if (psPDumpMemDumpIN->pvAltLinAddr) {
 		if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 			       ui32Bytes,
-			       &pvAltLinAddrKM, &hBlockAlloc) != PVRSRV_OK) {
+			       &pvAltLinAddrKM, &hBlockAlloc) != PVRSRV_OK)
 			return -EFAULT;
-		}
 
 		if (CopyFromUserWrapper(psPerProc,
 					ui32BridgeID,
@@ -1355,19 +1302,17 @@
 		       ui32Bytes,
 		       psPDumpMemDumpIN->ui32Flags, MAKEUNIQUETAG(pvMemInfo));
 
-	if (pvAltLinAddrKM) {
+	if (pvAltLinAddrKM)
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32Bytes, pvAltLinAddrKM,
 			  hBlockAlloc);
-	}
 
 	return 0;
 }
 
-static int
-PDumpBitmapBW(IMG_UINT32 ui32BridgeID,
-	      PVRSRV_BRIDGE_IN_PDUMP_BITMAP * psPDumpBitmapIN,
-	      PVRSRV_BRIDGE_RETURN * psRetOUT,
-	      PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PDumpBitmapBW(u32 ui32BridgeID,
+	      struct PVRSRV_BRIDGE_IN_PDUMP_BITMAP *psPDumpBitmapIN,
+	      struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	      struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVR_UNREFERENCED_PARAMETER(psPerProc);
 	PVR_UNREFERENCED_PARAMETER(ui32BridgeID);
@@ -1387,11 +1332,10 @@
 	return 0;
 }
 
-static int
-PDumpReadRegBW(IMG_UINT32 ui32BridgeID,
-	       PVRSRV_BRIDGE_IN_PDUMP_READREG * psPDumpReadRegIN,
-	       PVRSRV_BRIDGE_RETURN * psRetOUT,
-	       PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PDumpReadRegBW(u32 ui32BridgeID,
+	       struct PVRSRV_BRIDGE_IN_PDUMP_READREG *psPDumpReadRegIN,
+	       struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	       struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_DUMPREADREG);
 	PVR_UNREFERENCED_PARAMETER(psPerProc);
@@ -1406,21 +1350,19 @@
 	return 0;
 }
 
-static int
-PDumpDriverInfoBW(IMG_UINT32 ui32BridgeID,
-		  PVRSRV_BRIDGE_IN_PDUMP_DRIVERINFO * psPDumpDriverInfoIN,
-		  PVRSRV_BRIDGE_RETURN * psRetOUT,
-		  PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PDumpDriverInfoBW(u32 ui32BridgeID,
+		  struct PVRSRV_BRIDGE_IN_PDUMP_DRIVERINFO *psPDumpDriverInfoIN,
+		  struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+		  struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_UINT32 ui32PDumpFlags;
+	u32 ui32PDumpFlags;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_DRIVERINFO);
 	PVR_UNREFERENCED_PARAMETER(psPerProc);
 
 	ui32PDumpFlags = 0;
-	if (psPDumpDriverInfoIN->bContinuous) {
+	if (psPDumpDriverInfoIN->bContinuous)
 		ui32PDumpFlags |= PDUMP_FLAGS_CONTINUOUS;
-	}
 	psRetOUT->eError =
 	    PDumpDriverInfoKM(&psPDumpDriverInfoIN->szString[0],
 			      ui32PDumpFlags);
@@ -1428,15 +1370,14 @@
 	return 0;
 }
 
-static int
-PDumpSyncDumpBW(IMG_UINT32 ui32BridgeID,
-		PVRSRV_BRIDGE_IN_PDUMP_DUMPSYNC * psPDumpSyncDumpIN,
-		PVRSRV_BRIDGE_RETURN * psRetOUT,
-		PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	IMG_VOID *pvAltLinAddrKM = IMG_NULL;
-	IMG_UINT32 ui32Bytes = psPDumpSyncDumpIN->ui32Bytes;
-	IMG_VOID *pvSyncInfo;
+static int PDumpSyncDumpBW(u32 ui32BridgeID,
+		struct PVRSRV_BRIDGE_IN_PDUMP_DUMPSYNC *psPDumpSyncDumpIN,
+		struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	void *pvAltLinAddrKM = NULL;
+	u32 ui32Bytes = psPDumpSyncDumpIN->ui32Bytes;
+	void *pvSyncInfo;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_DUMPSYNC);
 
@@ -1444,15 +1385,13 @@
 	    PVRSRVLookupHandle(psPerProc->psHandleBase, &pvSyncInfo,
 			       psPDumpSyncDumpIN->psKernelSyncInfo,
 			       PVRSRV_HANDLE_TYPE_SYNC_INFO);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	if (psPDumpSyncDumpIN->pvAltLinAddr) {
 		if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-			       ui32Bytes, &pvAltLinAddrKM, 0) != PVRSRV_OK) {
+			       ui32Bytes, &pvAltLinAddrKM, 0) != PVRSRV_OK)
 			return -EFAULT;
-		}
 
 		if (CopyFromUserWrapper(psPerProc,
 					ui32BridgeID,
@@ -1467,28 +1406,27 @@
 
 	psRetOUT->eError =
 	    PDumpMemKM(pvAltLinAddrKM,
-		       ((PVRSRV_KERNEL_SYNC_INFO *) pvSyncInfo)->
+		       ((struct PVRSRV_KERNEL_SYNC_INFO *)pvSyncInfo)->
 		       psSyncDataMemInfoKM, psPDumpSyncDumpIN->ui32Offset,
 		       ui32Bytes, 0,
-		       MAKEUNIQUETAG(((PVRSRV_KERNEL_SYNC_INFO *) pvSyncInfo)->
-				     psSyncDataMemInfoKM));
+		       MAKEUNIQUETAG(
+			       ((struct PVRSRV_KERNEL_SYNC_INFO *)pvSyncInfo)->
+				   psSyncDataMemInfoKM));
 
-	if (pvAltLinAddrKM) {
+	if (pvAltLinAddrKM)
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32Bytes, pvAltLinAddrKM,
 			  0);
-	}
 
 	return 0;
 }
 
-static int
-PDumpSyncPolBW(IMG_UINT32 ui32BridgeID,
-	       PVRSRV_BRIDGE_IN_PDUMP_SYNCPOL * psPDumpSyncPolIN,
-	       PVRSRV_BRIDGE_RETURN * psRetOUT,
-	       PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PDumpSyncPolBW(u32 ui32BridgeID,
+	       struct PVRSRV_BRIDGE_IN_PDUMP_SYNCPOL *psPDumpSyncPolIN,
+	       struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	       struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_UINT32 ui32Offset;
-	IMG_VOID *pvSyncInfo;
+	u32 ui32Offset;
+	void *pvSyncInfo;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_SYNCPOL);
 
@@ -1496,33 +1434,32 @@
 	    PVRSRVLookupHandle(psPerProc->psHandleBase, &pvSyncInfo,
 			       psPDumpSyncPolIN->psKernelSyncInfo,
 			       PVRSRV_HANDLE_TYPE_SYNC_INFO);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
-	if (psPDumpSyncPolIN->bIsRead) {
-		ui32Offset = offsetof(PVRSRV_SYNC_DATA, ui32ReadOpsComplete);
-	} else {
-		ui32Offset = offsetof(PVRSRV_SYNC_DATA, ui32WriteOpsComplete);
-	}
+	if (psPDumpSyncPolIN->bIsRead)
+		ui32Offset = offsetof(struct PVRSRV_SYNC_DATA,
+				      ui32ReadOpsComplete);
+	else
+		ui32Offset = offsetof(struct PVRSRV_SYNC_DATA,
+				      ui32WriteOpsComplete);
 
 	psRetOUT->eError =
-	    PDumpMemPolKM(((PVRSRV_KERNEL_SYNC_INFO *) pvSyncInfo)->
+	    PDumpMemPolKM(((struct PVRSRV_KERNEL_SYNC_INFO *)pvSyncInfo)->
 			  psSyncDataMemInfoKM, ui32Offset,
 			  psPDumpSyncPolIN->ui32Value,
 			  psPDumpSyncPolIN->ui32Mask, PDUMP_POLL_OPERATOR_EQUAL,
 			  IMG_FALSE, IMG_FALSE,
-			  MAKEUNIQUETAG(((PVRSRV_KERNEL_SYNC_INFO *)
-					 pvSyncInfo)->psSyncDataMemInfoKM));
+			  MAKEUNIQUETAG(((struct PVRSRV_KERNEL_SYNC_INFO *)
+					  pvSyncInfo)->psSyncDataMemInfoKM));
 
 	return 0;
 }
 
-static int
-PDumpPDRegBW(IMG_UINT32 ui32BridgeID,
-	     PVRSRV_BRIDGE_IN_PDUMP_DUMPPDREG * psPDumpPDRegDumpIN,
-	     PVRSRV_BRIDGE_RETURN * psRetOUT,
-	     PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PDumpPDRegBW(u32 ui32BridgeID,
+	     struct PVRSRV_BRIDGE_IN_PDUMP_DUMPPDREG *psPDumpPDRegDumpIN,
+	     struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	     struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_PDUMP_PDREG);
 	PVR_UNREFERENCED_PARAMETER(psPerProc);
@@ -1534,12 +1471,11 @@
 	return 0;
 }
 
-static int
-PDumpCycleCountRegReadBW(IMG_UINT32 ui32BridgeID,
-			 PVRSRV_BRIDGE_IN_PDUMP_CYCLE_COUNT_REG_READ *
-			 psPDumpCycleCountRegReadIN,
-			 PVRSRV_BRIDGE_RETURN * psRetOUT,
-			 PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PDumpCycleCountRegReadBW(u32 ui32BridgeID,
+		 struct PVRSRV_BRIDGE_IN_PDUMP_CYCLE_COUNT_REG_READi
+					*psPDumpCycleCountRegReadIN,
+		 struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+		 struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_PDUMP_CYCLE_COUNT_REG_READ);
@@ -1554,12 +1490,12 @@
 }
 
 static int
-PDumpPDDevPAddrBW(IMG_UINT32 ui32BridgeID,
-		  PVRSRV_BRIDGE_IN_PDUMP_DUMPPDDEVPADDR * psPDumpPDDevPAddrIN,
-		  PVRSRV_BRIDGE_RETURN * psRetOUT,
-		  PVRSRV_PER_PROCESS_DATA * psPerProc)
+PDumpPDDevPAddrBW(u32 ui32BridgeID,
+	  struct PVRSRV_BRIDGE_IN_PDUMP_DUMPPDDEVPADDR *psPDumpPDDevPAddrIN,
+	  struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	  struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvMemInfo;
+	void *pvMemInfo;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_PDUMP_DUMPPDDEVPADDR);
@@ -1568,30 +1504,28 @@
 	    PVRSRVLookupHandle(psPerProc->psHandleBase, &pvMemInfo,
 			       psPDumpPDDevPAddrIN->hKernelMemInfo,
 			       PVRSRV_HANDLE_TYPE_MEM_INFO);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
-	    PDumpPDDevPAddrKM((PVRSRV_KERNEL_MEM_INFO *) pvMemInfo,
+	    PDumpPDDevPAddrKM((struct PVRSRV_KERNEL_MEM_INFO *)pvMemInfo,
 			      psPDumpPDDevPAddrIN->ui32Offset,
 			      psPDumpPDDevPAddrIN->sPDDevPAddr,
 			      MAKEUNIQUETAG(pvMemInfo), PDUMP_PD_UNIQUETAG);
 	return 0;
 }
 
-static int
-PDumpBufferArrayBW(IMG_UINT32 ui32BridgeID,
-		   PVRSRV_BRIDGE_IN_PDUMP_BUFFER_ARRAY * psPDumpBufferArrayIN,
-		   IMG_VOID * psBridgeOut, PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	IMG_UINT32 i;
-	PVR3DIF4_KICKTA_DUMP_BUFFER *psKickTADumpBuffer;
-	IMG_UINT32 ui32BufferArrayLength =
+static int PDumpBufferArrayBW(u32 ui32BridgeID,
+	   struct PVRSRV_BRIDGE_IN_PDUMP_BUFFER_ARRAY *psPDumpBufferArrayIN,
+	   void *psBridgeOut, struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	u32 i;
+	struct PVR3DIF4_KICKTA_DUMP_BUFFER *psKickTADumpBuffer;
+	u32 ui32BufferArrayLength =
 	    psPDumpBufferArrayIN->ui32BufferArrayLength;
-	IMG_UINT32 ui32BufferArraySize =
-	    ui32BufferArrayLength * sizeof(PVR3DIF4_KICKTA_DUMP_BUFFER);
-	PVRSRV_ERROR eError = PVRSRV_ERROR_GENERIC;
+	u32 ui32BufferArraySize =
+	    ui32BufferArrayLength * sizeof(struct PVR3DIF4_KICKTA_DUMP_BUFFER);
+	enum PVRSRV_ERROR eError = PVRSRV_ERROR_GENERIC;
 
 	PVR_UNREFERENCED_PARAMETER(psBridgeOut);
 
@@ -1600,9 +1534,8 @@
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 		       ui32BufferArraySize,
-		       (IMG_PVOID *) & psKickTADumpBuffer, 0) != PVRSRV_OK) {
+		       (void **) &psKickTADumpBuffer, 0) != PVRSRV_OK)
 		return -ENOMEM;
-	}
 
 	if (CopyFromUserWrapper(psPerProc,
 				ui32BridgeID,
@@ -1615,7 +1548,7 @@
 	}
 
 	for (i = 0; i < ui32BufferArrayLength; i++) {
-		IMG_VOID *pvMemInfo;
+		void *pvMemInfo;
 
 		eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
 					    &pvMemInfo,
@@ -1624,19 +1557,18 @@
 					    PVRSRV_HANDLE_TYPE_MEM_INFO);
 
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
+			PVR_DPF(PVR_DBG_ERROR,
 				 "PVRSRV_BRIDGE_PDUMP_BUFFER_ARRAY: "
-				 "PVRSRVLookupHandle failed (%d)", eError));
+				 "PVRSRVLookupHandle failed (%d)", eError);
 			break;
 		}
 		psKickTADumpBuffer[i].hKernelMemInfo = pvMemInfo;
 	}
 
-	if (eError == PVRSRV_OK) {
+	if (eError == PVRSRV_OK)
 		DumpBufferArray(psKickTADumpBuffer,
 				ui32BufferArrayLength,
 				psPDumpBufferArrayIN->bDumpPolls);
-	}
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32BufferArraySize,
 		  psKickTADumpBuffer, 0);
@@ -1644,17 +1576,16 @@
 	return 0;
 }
 
-static int
-PDump3DSignatureRegistersBW(IMG_UINT32 ui32BridgeID,
-			    PVRSRV_BRIDGE_IN_PDUMP_3D_SIGNATURE_REGISTERS *
-			    psPDump3DSignatureRegistersIN,
-			    IMG_VOID * psBridgeOut,
-			    PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PDump3DSignatureRegistersBW(u32 ui32BridgeID,
+			    struct PVRSRV_BRIDGE_IN_PDUMP_3D_SIGNATURE_REGISTERS
+					*psPDump3DSignatureRegistersIN,
+			    void *psBridgeOut,
+			    struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_UINT32 ui32RegisterArraySize =
+	u32 ui32RegisterArraySize =
 	    psPDump3DSignatureRegistersIN->ui32NumRegisters *
-	    sizeof(IMG_UINT32);
-	IMG_UINT32 *pui32Registers = IMG_NULL;
+	    sizeof(u32);
+	u32 *pui32Registers = NULL;
 	int ret = -EFAULT;
 
 	PVR_UNREFERENCED_PARAMETER(psBridgeOut);
@@ -1662,15 +1593,14 @@
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_PDUMP_3D_SIGNATURE_REGISTERS);
 
-	if (ui32RegisterArraySize == 0) {
+	if (ui32RegisterArraySize == 0)
 		goto ExitNoError;
-	}
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 		       ui32RegisterArraySize,
-		       (IMG_PVOID *) & pui32Registers, 0) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PDump3DSignatureRegistersBW: OSAllocMem failed"));
+		       (void **) &pui32Registers, 0) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PDump3DSignatureRegistersBW: OSAllocMem failed");
 		goto Exit;
 	}
 
@@ -1679,8 +1609,8 @@
 				pui32Registers,
 				psPDump3DSignatureRegistersIN->pui32Registers,
 				ui32RegisterArraySize) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PDump3DSignatureRegistersBW: CopyFromUserWrapper failed"));
+		PVR_DPF(PVR_DBG_ERROR, "PDump3DSignatureRegistersBW: "
+					"CopyFromUserWrapper failed");
 		goto Exit;
 	}
 
@@ -1694,23 +1624,22 @@
 ExitNoError:
 	ret = 0;
 Exit:
-	if (pui32Registers != IMG_NULL) {
+	if (pui32Registers != NULL)
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32RegisterArraySize,
 			  pui32Registers, 0);
-	}
 
 	return ret;
 }
 
-static int
-PDumpCounterRegistersBW(IMG_UINT32 ui32BridgeID,
-			PVRSRV_BRIDGE_IN_PDUMP_COUNTER_REGISTERS *
-			psPDumpCounterRegistersIN, IMG_VOID * psBridgeOut,
-			PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	IMG_UINT32 ui32RegisterArraySize =
-	    psPDumpCounterRegistersIN->ui32NumRegisters * sizeof(IMG_UINT32);
-	IMG_UINT32 *pui32Registers = IMG_NULL;
+static int PDumpCounterRegistersBW(u32 ui32BridgeID,
+		struct PVRSRV_BRIDGE_IN_PDUMP_COUNTER_REGISTERS
+			*psPDumpCounterRegistersIN,
+		void *psBridgeOut,
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	u32 ui32RegisterArraySize =
+	    psPDumpCounterRegistersIN->ui32NumRegisters * sizeof(u32);
+	u32 *pui32Registers = NULL;
 	int ret = -EFAULT;
 
 	PVR_UNREFERENCED_PARAMETER(psBridgeOut);
@@ -1718,15 +1647,14 @@
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_PDUMP_COUNTER_REGISTERS);
 
-	if (ui32RegisterArraySize == 0) {
+	if (ui32RegisterArraySize == 0)
 		goto ExitNoError;
-	}
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 		       ui32RegisterArraySize,
-		       (IMG_PVOID *) & pui32Registers, 0) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PDumpCounterRegistersBW: OSAllocMem failed"));
+		       (void **) &pui32Registers, 0) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PDumpCounterRegistersBW: OSAllocMem failed");
 		ret = -ENOMEM;
 		goto Exit;
 	}
@@ -1736,8 +1664,8 @@
 				pui32Registers,
 				psPDumpCounterRegistersIN->pui32Registers,
 				ui32RegisterArraySize) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PDumpCounterRegistersBW: CopyFromUserWrapper failed"));
+		PVR_DPF(PVR_DBG_ERROR, "PDumpCounterRegistersBW: "
+					"CopyFromUserWrapper failed");
 		goto Exit;
 	}
 
@@ -1749,25 +1677,23 @@
 ExitNoError:
 	ret = 0;
 Exit:
-	if (pui32Registers != IMG_NULL) {
+	if (pui32Registers != NULL)
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32RegisterArraySize,
 			  pui32Registers, 0);
-	}
 
 	return ret;
 }
 
-static int
-PDumpTASignatureRegistersBW(IMG_UINT32 ui32BridgeID,
-			    PVRSRV_BRIDGE_IN_PDUMP_TA_SIGNATURE_REGISTERS *
-			    psPDumpTASignatureRegistersIN,
-			    IMG_VOID * psBridgeOut,
-			    PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PDumpTASignatureRegistersBW(u32 ui32BridgeID,
+		    struct PVRSRV_BRIDGE_IN_PDUMP_TA_SIGNATURE_REGISTERS
+				*psPDumpTASignatureRegistersIN,
+		    void *psBridgeOut,
+		    struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_UINT32 ui32RegisterArraySize =
+	u32 ui32RegisterArraySize =
 	    psPDumpTASignatureRegistersIN->ui32NumRegisters *
-	    sizeof(IMG_UINT32);
-	IMG_UINT32 *pui32Registers = IMG_NULL;
+	    sizeof(u32);
+	u32 *pui32Registers = NULL;
 	int ret = -EFAULT;
 
 	PVR_UNREFERENCED_PARAMETER(psBridgeOut);
@@ -1775,15 +1701,14 @@
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_PDUMP_TA_SIGNATURE_REGISTERS);
 
-	if (ui32RegisterArraySize == 0) {
+	if (ui32RegisterArraySize == 0)
 		goto ExitNoError;
-	}
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 		       ui32RegisterArraySize,
-		       (IMG_PVOID *) & pui32Registers, 0) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PDumpTASignatureRegistersBW: OSAllocMem failed"));
+		       (void **) &pui32Registers, 0) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PDumpTASignatureRegistersBW: OSAllocMem failed");
 		ret = -ENOMEM;
 		goto Exit;
 	}
@@ -1793,8 +1718,8 @@
 				pui32Registers,
 				psPDumpTASignatureRegistersIN->pui32Registers,
 				ui32RegisterArraySize) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PDumpTASignatureRegistersBW: CopyFromUserWrapper failed"));
+		PVR_DPF(PVR_DBG_ERROR, "PDumpTASignatureRegistersBW: "
+					"CopyFromUserWrapper failed");
 		goto Exit;
 	}
 
@@ -1810,22 +1735,20 @@
 ExitNoError:
 	ret = 0;
 Exit:
-	if (pui32Registers != IMG_NULL) {
+	if (pui32Registers != NULL)
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32RegisterArraySize,
 			  pui32Registers, 0);
-	}
 
 	return ret;
 }
 #endif
 
-static int
-SGXGetClientInfoBW(IMG_UINT32 ui32BridgeID,
-		   PVRSRV_BRIDGE_IN_GETCLIENTINFO * psGetClientInfoIN,
-		   PVRSRV_BRIDGE_OUT_GETCLIENTINFO * psGetClientInfoOUT,
-		   PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int SGXGetClientInfoBW(u32 ui32BridgeID,
+		   struct PVRSRV_BRIDGE_IN_GETCLIENTINFO *psGetClientInfoIN,
+		   struct PVRSRV_BRIDGE_OUT_GETCLIENTINFO *psGetClientInfoOUT,
+		   struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hDevCookieInt;
+	void *hDevCookieInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_SGX_GETCLIENTINFO);
 
@@ -1833,23 +1756,21 @@
 	    PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevCookieInt,
 			       psGetClientInfoIN->hDevCookie,
 			       PVRSRV_HANDLE_TYPE_DEV_NODE);
-	if (psGetClientInfoOUT->eError != PVRSRV_OK) {
+	if (psGetClientInfoOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psGetClientInfoOUT->eError =
 	    SGXGetClientInfoKM(hDevCookieInt, &psGetClientInfoOUT->sClientInfo);
 	return 0;
 }
 
-static int
-SGXReleaseClientInfoBW(IMG_UINT32 ui32BridgeID,
-		       PVRSRV_BRIDGE_IN_RELEASECLIENTINFO *
-		       psReleaseClientInfoIN, PVRSRV_BRIDGE_RETURN * psRetOUT,
-		       PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int SGXReleaseClientInfoBW(u32 ui32BridgeID,
+	       struct PVRSRV_BRIDGE_IN_RELEASECLIENTINFO *psReleaseClientInfoIN,
+	       struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	       struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	PVRSRV_SGXDEV_INFO *psDevInfo;
-	IMG_HANDLE hDevCookieInt;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo;
+	void *hDevCookieInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_SGX_RELEASECLIENTINFO);
@@ -1858,13 +1779,11 @@
 	    PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevCookieInt,
 			       psReleaseClientInfoIN->hDevCookie,
 			       PVRSRV_HANDLE_TYPE_DEV_NODE);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
-	psDevInfo =
-	    (PVRSRV_SGXDEV_INFO *) ((PVRSRV_DEVICE_NODE *) hDevCookieInt)->
-	    pvDevice;
+	psDevInfo = (struct PVRSRV_SGXDEV_INFO *)
+			((struct PVRSRV_DEVICE_NODE *)hDevCookieInt)->pvDevice;
 
 	PVR_ASSERT(psDevInfo->ui32ClientRefCount > 0);
 
@@ -1875,15 +1794,12 @@
 	return 0;
 }
 
-static int
-SGXGetInternalDevInfoBW(IMG_UINT32 ui32BridgeID,
-			PVRSRV_BRIDGE_IN_GETINTERNALDEVINFO *
-			psSGXGetInternalDevInfoIN,
-			PVRSRV_BRIDGE_OUT_GETINTERNALDEVINFO *
-			psSGXGetInternalDevInfoOUT,
-			PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int SGXGetInternalDevInfoBW(u32 ui32BridgeID,
+	struct PVRSRV_BRIDGE_IN_GETINTERNALDEVINFO *psSGXGetInternalDevInfoIN,
+	struct PVRSRV_BRIDGE_OUT_GETINTERNALDEVINFO *psSGXGetInternalDevInfoOUT,
+	struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hDevCookieInt;
+	void *hDevCookieInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_SGX_GETINTERNALDEVINFO);
@@ -1892,9 +1808,8 @@
 	    PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevCookieInt,
 			       psSGXGetInternalDevInfoIN->hDevCookie,
 			       PVRSRV_HANDLE_TYPE_DEV_NODE);
-	if (psSGXGetInternalDevInfoOUT->eError != PVRSRV_OK) {
+	if (psSGXGetInternalDevInfoOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psSGXGetInternalDevInfoOUT->eError =
 	    SGXGetInternalDevInfoKM(hDevCookieInt,
@@ -1913,14 +1828,13 @@
 	return 0;
 }
 
-static int
-SGXDoKickBW(IMG_UINT32 ui32BridgeID,
-	    PVRSRV_BRIDGE_IN_DOKICK * psDoKickIN,
-	    PVRSRV_BRIDGE_RETURN * psRetOUT,
-	    PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int SGXDoKickBW(u32 ui32BridgeID,
+	    struct PVRSRV_BRIDGE_IN_DOKICK *psDoKickIN,
+	    struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	    struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hDevCookieInt;
-	IMG_UINT32 i;
+	void *hDevCookieInt;
+	u32 i;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_SGX_DOKICK);
 
@@ -1930,9 +1844,8 @@
 			       psDoKickIN->hDevCookie,
 			       PVRSRV_HANDLE_TYPE_DEV_NODE);
 
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVLookupHandle(psPerProc->psHandleBase,
@@ -1940,44 +1853,40 @@
 			       psDoKickIN->sCCBKick.hCCBKernelMemInfo,
 			       PVRSRV_HANDLE_TYPE_MEM_INFO);
 
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
-	if (psDoKickIN->sCCBKick.hTA3DSyncInfo != IMG_NULL) {
+	if (psDoKickIN->sCCBKick.hTA3DSyncInfo != NULL) {
 		psRetOUT->eError =
 		    PVRSRVLookupHandle(psPerProc->psHandleBase,
 				       &psDoKickIN->sCCBKick.hTA3DSyncInfo,
 				       psDoKickIN->sCCBKick.hTA3DSyncInfo,
 				       PVRSRV_HANDLE_TYPE_SYNC_INFO);
 
-		if (psRetOUT->eError != PVRSRV_OK) {
+		if (psRetOUT->eError != PVRSRV_OK)
 			return 0;
-		}
 	}
 
-	if (psDoKickIN->sCCBKick.hTASyncInfo != IMG_NULL) {
+	if (psDoKickIN->sCCBKick.hTASyncInfo != NULL) {
 		psRetOUT->eError =
 		    PVRSRVLookupHandle(psPerProc->psHandleBase,
 				       &psDoKickIN->sCCBKick.hTASyncInfo,
 				       psDoKickIN->sCCBKick.hTASyncInfo,
 				       PVRSRV_HANDLE_TYPE_SYNC_INFO);
 
-		if (psRetOUT->eError != PVRSRV_OK) {
+		if (psRetOUT->eError != PVRSRV_OK)
 			return 0;
-		}
 	}
 
-	if (psDoKickIN->sCCBKick.h3DSyncInfo != IMG_NULL) {
+	if (psDoKickIN->sCCBKick.h3DSyncInfo != NULL) {
 		psRetOUT->eError =
 		    PVRSRVLookupHandle(psPerProc->psHandleBase,
 				       &psDoKickIN->sCCBKick.h3DSyncInfo,
 				       psDoKickIN->sCCBKick.h3DSyncInfo,
 				       PVRSRV_HANDLE_TYPE_SYNC_INFO);
 
-		if (psRetOUT->eError != PVRSRV_OK) {
+		if (psRetOUT->eError != PVRSRV_OK)
 			return 0;
-		}
 	}
 
 	if (psDoKickIN->sCCBKick.ui32NumSrcSyncs > SGX_MAX_SRC_SYNCS) {
@@ -1993,9 +1902,8 @@
 				       ahSrcKernelSyncInfo[i],
 				       PVRSRV_HANDLE_TYPE_SYNC_INFO);
 
-		if (psRetOUT->eError != PVRSRV_OK) {
+		if (psRetOUT->eError != PVRSRV_OK)
 			return 0;
-		}
 	}
 
 	if (psDoKickIN->sCCBKick.ui32NumTAStatusVals > SGX_MAX_TA_STATUS_VALS) {
@@ -2011,9 +1919,8 @@
 				       ahTAStatusSyncInfo[i],
 				       PVRSRV_HANDLE_TYPE_SYNC_INFO);
 
-		if (psRetOUT->eError != PVRSRV_OK) {
+		if (psRetOUT->eError != PVRSRV_OK)
 			return 0;
-		}
 	}
 
 	if (psDoKickIN->sCCBKick.ui32Num3DStatusVals > SGX_MAX_3D_STATUS_VALS) {
@@ -2029,12 +1936,11 @@
 				       ah3DStatusSyncInfo[i],
 				       PVRSRV_HANDLE_TYPE_SYNC_INFO);
 
-		if (psRetOUT->eError != PVRSRV_OK) {
+		if (psRetOUT->eError != PVRSRV_OK)
 			return 0;
-		}
 	}
 
-	if (psDoKickIN->sCCBKick.hRenderSurfSyncInfo != IMG_NULL) {
+	if (psDoKickIN->sCCBKick.hRenderSurfSyncInfo != NULL) {
 		psRetOUT->eError =
 		    PVRSRVLookupHandle(psPerProc->psHandleBase,
 				       &psDoKickIN->sCCBKick.
@@ -2042,9 +1948,8 @@
 				       psDoKickIN->sCCBKick.hRenderSurfSyncInfo,
 				       PVRSRV_HANDLE_TYPE_SYNC_INFO);
 
-		if (psRetOUT->eError != PVRSRV_OK) {
+		if (psRetOUT->eError != PVRSRV_OK)
 			return 0;
-		}
 	}
 
 	psRetOUT->eError = SGXDoKickKM(hDevCookieInt, &psDoKickIN->sCCBKick);
@@ -2052,15 +1957,14 @@
 	return 0;
 }
 
-static int
-SGXSubmitTransferBW(IMG_UINT32 ui32BridgeID,
-		    PVRSRV_BRIDGE_IN_SUBMITTRANSFER * psSubmitTransferIN,
-		    PVRSRV_BRIDGE_RETURN * psRetOUT,
-		    PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	IMG_HANDLE hDevCookieInt;
-	PVRSRV_TRANSFER_SGX_KICK *psKick;
-	IMG_UINT32 i;
+static int SGXSubmitTransferBW(u32 ui32BridgeID,
+		    struct PVRSRV_BRIDGE_IN_SUBMITTRANSFER *psSubmitTransferIN,
+		    struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+		    struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	void *hDevCookieInt;
+	struct PVRSRV_TRANSFER_SGX_KICK *psKick;
+	u32 i;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_SGX_SUBMITTRANSFER);
@@ -2073,39 +1977,35 @@
 			       &hDevCookieInt,
 			       psSubmitTransferIN->hDevCookie,
 			       PVRSRV_HANDLE_TYPE_DEV_NODE);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVLookupHandle(psPerProc->psHandleBase,
 			       &psKick->hCCBMemInfo,
 			       psKick->hCCBMemInfo,
 			       PVRSRV_HANDLE_TYPE_MEM_INFO);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
-	if (psKick->hTASyncInfo != IMG_NULL) {
+	if (psKick->hTASyncInfo != NULL) {
 		psRetOUT->eError =
 		    PVRSRVLookupHandle(psPerProc->psHandleBase,
 				       &psKick->hTASyncInfo,
 				       psKick->hTASyncInfo,
 				       PVRSRV_HANDLE_TYPE_SYNC_INFO);
-		if (psRetOUT->eError != PVRSRV_OK) {
+		if (psRetOUT->eError != PVRSRV_OK)
 			return 0;
-		}
 	}
 
-	if (psKick->h3DSyncInfo != IMG_NULL) {
+	if (psKick->h3DSyncInfo != NULL) {
 		psRetOUT->eError =
 		    PVRSRVLookupHandle(psPerProc->psHandleBase,
 				       &psKick->h3DSyncInfo,
 				       psKick->h3DSyncInfo,
 				       PVRSRV_HANDLE_TYPE_SYNC_INFO);
-		if (psRetOUT->eError != PVRSRV_OK) {
+		if (psRetOUT->eError != PVRSRV_OK)
 			return 0;
-		}
 	}
 
 	if (psKick->ui32NumSrcSync > SGX_MAX_TRANSFER_SYNC_OPS) {
@@ -2118,9 +2018,8 @@
 				       &psKick->ahSrcSyncInfo[i],
 				       psKick->ahSrcSyncInfo[i],
 				       PVRSRV_HANDLE_TYPE_SYNC_INFO);
-		if (psRetOUT->eError != PVRSRV_OK) {
+		if (psRetOUT->eError != PVRSRV_OK)
 			return 0;
-		}
 	}
 
 	if (psKick->ui32NumDstSync > SGX_MAX_TRANSFER_SYNC_OPS) {
@@ -2133,9 +2032,8 @@
 				       &psKick->ahDstSyncInfo[i],
 				       psKick->ahDstSyncInfo[i],
 				       PVRSRV_HANDLE_TYPE_SYNC_INFO);
-		if (psRetOUT->eError != PVRSRV_OK) {
+		if (psRetOUT->eError != PVRSRV_OK)
 			return 0;
-		}
 	}
 
 	psRetOUT->eError = SGXSubmitTransferKM(hDevCookieInt, psKick);
@@ -2145,15 +2043,14 @@
 
 
 
-static int
-SGXGetMiscInfoBW(IMG_UINT32 ui32BridgeID,
-		 PVRSRV_BRIDGE_IN_SGXGETMISCINFO * psSGXGetMiscInfoIN,
-		 PVRSRV_BRIDGE_RETURN * psRetOUT,
-		 PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	IMG_HANDLE hDevCookieInt;
-	PVRSRV_SGXDEV_INFO *psDevInfo;
-	SGX_MISC_INFO sMiscInfo;
+static int SGXGetMiscInfoBW(u32 ui32BridgeID,
+		 struct PVRSRV_BRIDGE_IN_SGXGETMISCINFO *psSGXGetMiscInfoIN,
+		 struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+		 struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	void *hDevCookieInt;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo;
+	struct SGX_MISC_INFO sMiscInfo;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_SGX_GETMISCINFO);
 
@@ -2162,31 +2059,26 @@
 					      psSGXGetMiscInfoIN->hDevCookie,
 					      PVRSRV_HANDLE_TYPE_DEV_NODE);
 
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
-	psDevInfo =
-	    (PVRSRV_SGXDEV_INFO *) ((PVRSRV_DEVICE_NODE *) hDevCookieInt)->
-	    pvDevice;
+	psDevInfo = (struct PVRSRV_SGXDEV_INFO *)
+		((struct PVRSRV_DEVICE_NODE *)hDevCookieInt)->pvDevice;
 
-	psRetOUT->eError = CopyFromUserWrapper(psPerProc,
-					       ui32BridgeID,
+	psRetOUT->eError = CopyFromUserWrapper(psPerProc, ui32BridgeID,
 					       &sMiscInfo,
 					       psSGXGetMiscInfoIN->psMiscInfo,
-					       sizeof(SGX_MISC_INFO));
-	if (psRetOUT->eError != PVRSRV_OK) {
+					       sizeof(struct SGX_MISC_INFO));
+	if (psRetOUT->eError != PVRSRV_OK)
 		return -EFAULT;
-	}
 	if (sMiscInfo.eRequest == SGX_MISC_INFO_REQUEST_HWPERF_RETRIEVE_CB) {
 		void *pAllocated;
-		IMG_HANDLE hAllocatedHandle;
-		void *psTmpUserData;
+		void *hAllocatedHandle;
+		void __user *psTmpUserData;
 		int allocatedSize;
 
-		allocatedSize =
-		    sMiscInfo.uData.sRetrieveCB.ui32ArraySize *
-		    sizeof(PVRSRV_SGX_HWPERF_CBDATA);
+		allocatedSize = sMiscInfo.uData.sRetrieveCB.ui32ArraySize *
+				sizeof(struct PVRSRV_SGX_HWPERF_CBDATA);
 
 		ASSIGN_AND_EXIT_ON_ERROR(psRetOUT->eError,
 					 OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
@@ -2194,7 +2086,8 @@
 						    &pAllocated,
 						    &hAllocatedHandle));
 
-		psTmpUserData = sMiscInfo.uData.sRetrieveCB.psHWPerfData;
+		psTmpUserData = (void __force __user *)
+				sMiscInfo.uData.sRetrieveCB.psHWPerfData;
 		sMiscInfo.uData.sRetrieveCB.psHWPerfData = pAllocated;
 
 		psRetOUT->eError = SGXGetMiscInfoKM(psDevInfo, &sMiscInfo);
@@ -2204,48 +2097,42 @@
 			return -EFAULT;
 		}
 
-		psRetOUT->eError = CopyToUserWrapper(psPerProc,
-						     ui32BridgeID,
-						     psTmpUserData,
-						     sMiscInfo.uData.
-						     sRetrieveCB.psHWPerfData,
-						     allocatedSize);
+		psRetOUT->eError = CopyToUserWrapper(
+				psPerProc, ui32BridgeID,
+				psTmpUserData,
+				sMiscInfo.uData.sRetrieveCB.psHWPerfData,
+				allocatedSize);
 
-		sMiscInfo.uData.sRetrieveCB.psHWPerfData = psTmpUserData;
+		sMiscInfo.uData.sRetrieveCB.psHWPerfData =
+						(void __force *)psTmpUserData;
 
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
 			  allocatedSize, pAllocated, hAllocatedHandle);
 
-		if (psRetOUT->eError != PVRSRV_OK) {
+		if (psRetOUT->eError != PVRSRV_OK)
 			return -EFAULT;
-		}
-	} else
-	{
+	} else {
 		psRetOUT->eError = SGXGetMiscInfoKM(psDevInfo, &sMiscInfo);
-		if (psRetOUT->eError != PVRSRV_OK) {
+		if (psRetOUT->eError != PVRSRV_OK)
 			return -EFAULT;
-		}
 	}
 
 	psRetOUT->eError = CopyToUserWrapper(psPerProc,
 					     ui32BridgeID,
 					     psSGXGetMiscInfoIN->psMiscInfo,
-					     &sMiscInfo, sizeof(SGX_MISC_INFO));
-	if (psRetOUT->eError != PVRSRV_OK) {
+					     &sMiscInfo,
+					     sizeof(struct SGX_MISC_INFO));
+	if (psRetOUT->eError != PVRSRV_OK)
 		return -EFAULT;
-	}
 	return 0;
 }
 
-static int
-SGXReadDiffCountersBW(IMG_UINT32 ui32BridgeID,
-		      PVRSRV_BRIDGE_IN_SGX_READ_DIFF_COUNTERS *
-		      psSGXReadDiffCountersIN,
-		      PVRSRV_BRIDGE_OUT_SGX_READ_DIFF_COUNTERS *
-		      psSGXReadDiffCountersOUT,
-		      PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int SGXReadDiffCountersBW(u32 ui32BridgeID,
+      struct PVRSRV_BRIDGE_IN_SGX_READ_DIFF_COUNTERS *psSGXReadDiffCountersIN,
+      struct PVRSRV_BRIDGE_OUT_SGX_READ_DIFF_COUNTERS *psSGXReadDiffCountersOUT,
+      struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hDevCookieInt;
+	void *hDevCookieInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_SGX_READ_DIFF_COUNTERS);
@@ -2255,38 +2142,27 @@
 			       psSGXReadDiffCountersIN->hDevCookie,
 			       PVRSRV_HANDLE_TYPE_DEV_NODE);
 
-	if (psSGXReadDiffCountersOUT->eError != PVRSRV_OK) {
+	if (psSGXReadDiffCountersOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psSGXReadDiffCountersOUT->eError = SGXReadDiffCountersKM(hDevCookieInt,
-								 psSGXReadDiffCountersIN->
-								 ui32Reg,
-								 &psSGXReadDiffCountersOUT->
-								 ui32Old,
-								 psSGXReadDiffCountersIN->
-								 bNew,
-								 psSGXReadDiffCountersIN->
-								 ui32New,
-								 psSGXReadDiffCountersIN->
-								 ui32NewReset,
-								 psSGXReadDiffCountersIN->
-								 ui32CountersReg,
-								 &psSGXReadDiffCountersOUT->
-								 ui32Time,
-								 &psSGXReadDiffCountersOUT->
-								 bActive,
-								 &psSGXReadDiffCountersOUT->
-								 sDiffs);
+			psSGXReadDiffCountersIN->ui32Reg,
+			&psSGXReadDiffCountersOUT->ui32Old,
+			psSGXReadDiffCountersIN->bNew,
+			psSGXReadDiffCountersIN->ui32New,
+			psSGXReadDiffCountersIN->ui32NewReset,
+			psSGXReadDiffCountersIN->ui32CountersReg,
+			&psSGXReadDiffCountersOUT->ui32Time,
+			&psSGXReadDiffCountersOUT->bActive,
+			&psSGXReadDiffCountersOUT->sDiffs);
 
 	return 0;
 }
 
-static int
-PVRSRVInitSrvConnectBW(IMG_UINT32 ui32BridgeID,
-		       IMG_VOID * psBridgeIn,
-		       PVRSRV_BRIDGE_RETURN * psRetOUT,
-		       PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVInitSrvConnectBW(u32 ui32BridgeID,
+		       void *psBridgeIn,
+		       struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+		       struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVR_UNREFERENCED_PARAMETER(psBridgeIn);
 
@@ -2308,11 +2184,10 @@
 }
 
 static int
-PVRSRVInitSrvDisconnectBW(IMG_UINT32 ui32BridgeID,
-			  PVRSRV_BRIDGE_IN_INITSRV_DISCONNECT *
-			  psInitSrvDisconnectIN,
-			  PVRSRV_BRIDGE_RETURN * psRetOUT,
-			  PVRSRV_PER_PROCESS_DATA * psPerProc)
+PVRSRVInitSrvDisconnectBW(u32 ui32BridgeID,
+	 struct PVRSRV_BRIDGE_IN_INITSRV_DISCONNECT *psInitSrvDisconnectIN,
+	 struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	 struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_INITSRV_DISCONNECT);
@@ -2339,23 +2214,22 @@
 }
 
 static int
-PVRSRVEventObjectWaitBW(IMG_UINT32 ui32BridgeID,
-			PVRSRV_BRIDGE_IN_EVENT_OBJECT_WAIT *
-			psEventObjectWaitIN, PVRSRV_BRIDGE_RETURN * psRetOUT,
-			PVRSRV_PER_PROCESS_DATA * psPerProc)
+PVRSRVEventObjectWaitBW(u32 ui32BridgeID,
+		struct PVRSRV_BRIDGE_IN_EVENT_OBJECT_WAIT *psEventObjectWaitIN,
+		struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hOSEventKM;
+	void *hOSEventKM;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_EVENT_OBJECT_WAIT);
 
 	psRetOUT->eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
-					      &hOSEventKM,
-					      psEventObjectWaitIN->hOSEventKM,
-					      PVRSRV_HANDLE_TYPE_EVENT_OBJECT_CONNECT);
+				&hOSEventKM,
+				psEventObjectWaitIN->hOSEventKM,
+				PVRSRV_HANDLE_TYPE_EVENT_OBJECT_CONNECT);
 
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError = OSEventObjectWait(hOSEventKM);
 
@@ -2363,12 +2237,10 @@
 }
 
 static int
-PVRSRVEventObjectOpenBW(IMG_UINT32 ui32BridgeID,
-			PVRSRV_BRIDGE_IN_EVENT_OBJECT_OPEN *
-			psEventObjectOpenIN,
-			PVRSRV_BRIDGE_OUT_EVENT_OBJECT_OPEN *
-			psEventObjectOpenOUT,
-			PVRSRV_PER_PROCESS_DATA * psPerProc)
+PVRSRVEventObjectOpenBW(u32 ui32BridgeID,
+	struct PVRSRV_BRIDGE_IN_EVENT_OBJECT_OPEN *psEventObjectOpenIN,
+	struct PVRSRV_BRIDGE_OUT_EVENT_OBJECT_OPEN *psEventObjectOpenOUT,
+	struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_EVENT_OBJECT_OPEN);
@@ -2381,17 +2253,15 @@
 			       psEventObjectOpenIN->sEventObject.hOSEventKM,
 			       PVRSRV_HANDLE_TYPE_SHARED_EVENT_OBJECT);
 
-	if (psEventObjectOpenOUT->eError != PVRSRV_OK) {
+	if (psEventObjectOpenOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psEventObjectOpenOUT->eError =
 	    OSEventObjectOpen(&psEventObjectOpenIN->sEventObject,
 			      &psEventObjectOpenOUT->hOSEvent);
 
-	if (psEventObjectOpenOUT->eError != PVRSRV_OK) {
+	if (psEventObjectOpenOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	PVRSRVAllocHandleNR(psPerProc->psHandleBase,
 			    &psEventObjectOpenOUT->hOSEvent,
@@ -2405,12 +2275,12 @@
 }
 
 static int
-PVRSRVEventObjectCloseBW(IMG_UINT32 ui32BridgeID,
-			 PVRSRV_BRIDGE_IN_EVENT_OBJECT_CLOSE *
-			 psEventObjectCloseIN, PVRSRV_BRIDGE_RETURN * psRetOUT,
-			 PVRSRV_PER_PROCESS_DATA * psPerProc)
+PVRSRVEventObjectCloseBW(u32 ui32BridgeID,
+	 struct PVRSRV_BRIDGE_IN_EVENT_OBJECT_CLOSE *psEventObjectCloseIN,
+	 struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	 struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hOSEventKM;
+	void *hOSEventKM;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_EVENT_OBJECT_CLOSE);
@@ -2420,19 +2290,16 @@
 			       &psEventObjectCloseIN->sEventObject.hOSEventKM,
 			       psEventObjectCloseIN->sEventObject.hOSEventKM,
 			       PVRSRV_HANDLE_TYPE_SHARED_EVENT_OBJECT);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
-							&hOSEventKM,
-							psEventObjectCloseIN->
-							hOSEventKM,
-							PVRSRV_HANDLE_TYPE_EVENT_OBJECT_CONNECT);
+				&hOSEventKM,
+				psEventObjectCloseIN->hOSEventKM,
+				PVRSRV_HANDLE_TYPE_EVENT_OBJECT_CONNECT);
 
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    OSEventObjectClose(&psEventObjectCloseIN->sEventObject, hOSEventKM);
@@ -2440,19 +2307,18 @@
 	return 0;
 }
 
-static int
-SGXDevInitPart2BW(IMG_UINT32 ui32BridgeID,
-		  PVRSRV_BRIDGE_IN_SGXDEVINITPART2 * psSGXDevInitPart2IN,
-		  PVRSRV_BRIDGE_RETURN * psRetOUT,
-		  PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int SGXDevInitPart2BW(u32 ui32BridgeID,
+		  struct PVRSRV_BRIDGE_IN_SGXDEVINITPART2 *psSGXDevInitPart2IN,
+		  struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+		  struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hDevCookieInt;
-	PVRSRV_ERROR eError;
+	void *hDevCookieInt;
+	enum PVRSRV_ERROR eError;
 	IMG_BOOL bDissociateFailed = IMG_FALSE;
 	IMG_BOOL bLookupFailed = IMG_FALSE;
 	IMG_BOOL bReleaseFailed = IMG_FALSE;
-	IMG_HANDLE hDummy;
-	IMG_UINT32 i;
+	void *hDummy;
+	u32 i;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_SGX_DEVINITPART2);
 
@@ -2466,9 +2332,8 @@
 			       &hDevCookieInt,
 			       psSGXDevInitPart2IN->hDevCookie,
 			       PVRSRV_HANDLE_TYPE_DEV_NODE);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
 				    &hDummy,
@@ -2507,12 +2372,11 @@
 	bLookupFailed |= (IMG_BOOL) (eError != PVRSRV_OK);
 
 	for (i = 0; i < SGX_MAX_INIT_MEM_HANDLES; i++) {
-		IMG_HANDLE hHandle =
+		void *hHandle =
 		    psSGXDevInitPart2IN->sInitInfo.asInitMemHandles[i];
 
-		if (hHandle == IMG_NULL) {
+		if (hHandle == NULL)
 			continue;
-		}
 
 		eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
 					    &hDummy,
@@ -2522,8 +2386,8 @@
 	}
 
 	if (bLookupFailed) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "DevInitSGXPart2BW: A handle lookup failed"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "DevInitSGXPart2BW: A handle lookup failed");
 		psRetOUT->eError = PVRSRV_ERROR_GENERIC;
 		return 0;
 	}
@@ -2570,22 +2434,22 @@
 	bReleaseFailed |= (IMG_BOOL) (eError != PVRSRV_OK);
 
 	for (i = 0; i < SGX_MAX_INIT_MEM_HANDLES; i++) {
-		IMG_HANDLE *phHandle =
+		void **phHandle =
 		    &psSGXDevInitPart2IN->sInitInfo.asInitMemHandles[i];
 
-		if (*phHandle == IMG_NULL)
+		if (*phHandle == NULL)
 			continue;
 
 		eError = PVRSRVLookupAndReleaseHandle(psPerProc->psHandleBase,
-						      phHandle,
-						      *phHandle,
-						      PVRSRV_HANDLE_TYPE_MEM_INFO);
+						   phHandle,
+						   *phHandle,
+						   PVRSRV_HANDLE_TYPE_MEM_INFO);
 		bReleaseFailed |= (IMG_BOOL) (eError != PVRSRV_OK);
 	}
 
 	if (bReleaseFailed) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "DevInitSGXPart2BW: A handle release failed"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "DevInitSGXPart2BW: A handle release failed");
 		psRetOUT->eError = PVRSRV_ERROR_GENERIC;
 
 		PVR_DBG_BREAK;
@@ -2624,10 +2488,10 @@
 	bDissociateFailed |= (IMG_BOOL) (eError != PVRSRV_OK);
 
 	for (i = 0; i < SGX_MAX_INIT_MEM_HANDLES; i++) {
-		IMG_HANDLE hHandle =
+		void *hHandle =
 		    psSGXDevInitPart2IN->sInitInfo.asInitMemHandles[i];
 
-		if (hHandle == IMG_NULL)
+		if (hHandle == NULL)
 			continue;
 
 		eError = PVRSRVDissociateDeviceMemKM(hDevCookieInt, hHandle);
@@ -2646,20 +2510,19 @@
 				      hKernelSGXHostCtlMemInfo);
 
 		for (i = 0; i < SGX_MAX_INIT_MEM_HANDLES; i++) {
-			IMG_HANDLE hHandle =
+			void *hHandle =
 			    psSGXDevInitPart2IN->sInitInfo.asInitMemHandles[i];
 
-			if (hHandle == IMG_NULL)
+			if (hHandle == NULL)
 				continue;
 
 			PVRSRVFreeDeviceMemKM(hDevCookieInt,
-					      (PVRSRV_KERNEL_MEM_INFO *)
-					      hHandle);
+				 (struct PVRSRV_KERNEL_MEM_INFO *)hHandle);
 
 		}
 
-		PVR_DPF((PVR_DBG_ERROR,
-			 "DevInitSGXPart2BW: A dissociate failed"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "DevInitSGXPart2BW: A dissociate failed");
 
 		psRetOUT->eError = PVRSRV_ERROR_GENERIC;
 
@@ -2674,16 +2537,15 @@
 	return 0;
 }
 
-static int
-SGXRegisterHWRenderContextBW(IMG_UINT32 ui32BridgeID,
-			     PVRSRV_BRIDGE_IN_SGX_REGISTER_HW_RENDER_CONTEXT *
-			     psSGXRegHWRenderContextIN,
-			     PVRSRV_BRIDGE_OUT_SGX_REGISTER_HW_RENDER_CONTEXT *
-			     psSGXRegHWRenderContextOUT,
-			     PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int SGXRegisterHWRenderContextBW(u32 ui32BridgeID,
+		     struct PVRSRV_BRIDGE_IN_SGX_REGISTER_HW_RENDER_CONTEXT
+				*psSGXRegHWRenderContextIN,
+		     struct PVRSRV_BRIDGE_OUT_SGX_REGISTER_HW_RENDER_CONTEXT
+				 *psSGXRegHWRenderContextOUT,
+		     struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hDevCookieInt;
-	IMG_HANDLE hHWRenderContextInt;
+	void *hDevCookieInt;
+	void *hHWRenderContextInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_SGX_REGISTER_HW_RENDER_CONTEXT);
@@ -2696,16 +2558,15 @@
 			       &hDevCookieInt,
 			       psSGXRegHWRenderContextIN->hDevCookie,
 			       PVRSRV_HANDLE_TYPE_DEV_NODE);
-	if (psSGXRegHWRenderContextOUT->eError != PVRSRV_OK) {
+	if (psSGXRegHWRenderContextOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	hHWRenderContextInt =
 	    SGXRegisterHWRenderContextKM(hDevCookieInt,
 					 &psSGXRegHWRenderContextIN->
 					 sHWRenderContextDevVAddr, psPerProc);
 
-	if (hHWRenderContextInt == IMG_NULL) {
+	if (hHWRenderContextInt == NULL) {
 		psSGXRegHWRenderContextOUT->eError = PVRSRV_ERROR_GENERIC;
 		return 0;
 	}
@@ -2722,31 +2583,28 @@
 	return 0;
 }
 
-static int
-SGXUnregisterHWRenderContextBW(IMG_UINT32 ui32BridgeID,
-			       PVRSRV_BRIDGE_IN_SGX_UNREGISTER_HW_RENDER_CONTEXT
-			       * psSGXUnregHWRenderContextIN,
-			       PVRSRV_BRIDGE_RETURN * psRetOUT,
-			       PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int SGXUnregisterHWRenderContextBW(u32 ui32BridgeID,
+		     struct PVRSRV_BRIDGE_IN_SGX_UNREGISTER_HW_RENDER_CONTEXT *
+			psSGXUnregHWRenderContextIN,
+		     struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+		     struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hHWRenderContextInt;
+	void *hHWRenderContextInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
-				 PVRSRV_BRIDGE_SGX_UNREGISTER_HW_RENDER_CONTEXT);
+			 PVRSRV_BRIDGE_SGX_UNREGISTER_HW_RENDER_CONTEXT);
 
 	psRetOUT->eError =
 	    PVRSRVLookupHandle(psPerProc->psHandleBase,
 			       &hHWRenderContextInt,
 			       psSGXUnregHWRenderContextIN->hHWRenderContext,
 			       PVRSRV_HANDLE_TYPE_SGX_HW_RENDER_CONTEXT);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError = SGXUnregisterHWRenderContextKM(hHWRenderContextInt);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVReleaseHandle(psPerProc->psHandleBase,
@@ -2756,19 +2614,18 @@
 	return 0;
 }
 
-static int
-SGXRegisterHWTransferContextBW(IMG_UINT32 ui32BridgeID,
-			       PVRSRV_BRIDGE_IN_SGX_REGISTER_HW_TRANSFER_CONTEXT
-			       * psSGXRegHWTransferContextIN,
-			       PVRSRV_BRIDGE_OUT_SGX_REGISTER_HW_TRANSFER_CONTEXT
-			       * psSGXRegHWTransferContextOUT,
-			       PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int SGXRegisterHWTransferContextBW(u32 ui32BridgeID,
+	       struct PVRSRV_BRIDGE_IN_SGX_REGISTER_HW_TRANSFER_CONTEXT
+		       *psSGXRegHWTransferContextIN,
+	       struct PVRSRV_BRIDGE_OUT_SGX_REGISTER_HW_TRANSFER_CONTEXT
+		       *psSGXRegHWTransferContextOUT,
+	       struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hDevCookieInt;
-	IMG_HANDLE hHWTransferContextInt;
+	void *hDevCookieInt;
+	void *hHWTransferContextInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
-				 PVRSRV_BRIDGE_SGX_REGISTER_HW_TRANSFER_CONTEXT);
+			 PVRSRV_BRIDGE_SGX_REGISTER_HW_TRANSFER_CONTEXT);
 
 	NEW_HANDLE_BATCH_OR_ERROR(psSGXRegHWTransferContextOUT->eError,
 				  psPerProc, 1);
@@ -2778,9 +2635,8 @@
 			       &hDevCookieInt,
 			       psSGXRegHWTransferContextIN->hDevCookie,
 			       PVRSRV_HANDLE_TYPE_DEV_NODE);
-	if (psSGXRegHWTransferContextOUT->eError != PVRSRV_OK) {
+	if (psSGXRegHWTransferContextOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	hHWTransferContextInt =
 	    SGXRegisterHWTransferContextKM(hDevCookieInt,
@@ -2788,7 +2644,7 @@
 					   sHWTransferContextDevVAddr,
 					   psPerProc);
 
-	if (hHWTransferContextInt == IMG_NULL) {
+	if (hHWTransferContextInt == NULL) {
 		psSGXRegHWTransferContextOUT->eError = PVRSRV_ERROR_GENERIC;
 		return 0;
 	}
@@ -2805,17 +2661,16 @@
 	return 0;
 }
 
-static int
-SGXUnregisterHWTransferContextBW(IMG_UINT32 ui32BridgeID,
-				 PVRSRV_BRIDGE_IN_SGX_UNREGISTER_HW_TRANSFER_CONTEXT
-				 * psSGXUnregHWTransferContextIN,
-				 PVRSRV_BRIDGE_RETURN * psRetOUT,
-				 PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int SGXUnregisterHWTransferContextBW(u32 ui32BridgeID,
+		 struct PVRSRV_BRIDGE_IN_SGX_UNREGISTER_HW_TRANSFER_CONTEXT
+				*psSGXUnregHWTransferContextIN,
+		 struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+		 struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hHWTransferContextInt;
+	void *hHWTransferContextInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
-				 PVRSRV_BRIDGE_SGX_UNREGISTER_HW_TRANSFER_CONTEXT);
+			 PVRSRV_BRIDGE_SGX_UNREGISTER_HW_TRANSFER_CONTEXT);
 
 	psRetOUT->eError =
 	    PVRSRVLookupHandle(psPerProc->psHandleBase,
@@ -2823,15 +2678,13 @@
 			       psSGXUnregHWTransferContextIN->
 			       hHWTransferContext,
 			       PVRSRV_HANDLE_TYPE_SGX_HW_TRANSFER_CONTEXT);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    SGXUnregisterHWTransferContextKM(hHWTransferContextInt);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVReleaseHandle(psPerProc->psHandleBase,
@@ -2843,14 +2696,13 @@
 }
 
 
-static int
-SGXFlushHWRenderTargetBW(IMG_UINT32 ui32BridgeID,
-			 PVRSRV_BRIDGE_IN_SGX_FLUSH_HW_RENDER_TARGET *
-			 psSGXFlushHWRenderTargetIN,
-			 PVRSRV_BRIDGE_RETURN * psRetOUT,
-			 PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int SGXFlushHWRenderTargetBW(u32 ui32BridgeID,
+			 struct PVRSRV_BRIDGE_IN_SGX_FLUSH_HW_RENDER_TARGET
+					*psSGXFlushHWRenderTargetIN,
+			 struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+			 struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hDevCookieInt;
+	void *hDevCookieInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_SGX_FLUSH_HW_RENDER_TARGET);
@@ -2860,9 +2712,8 @@
 			       &hDevCookieInt,
 			       psSGXFlushHWRenderTargetIN->hDevCookie,
 			       PVRSRV_HANDLE_TYPE_DEV_NODE);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	SGXFlushHWRenderTargetKM(hDevCookieInt,
 				 psSGXFlushHWRenderTargetIN->
@@ -2871,16 +2722,14 @@
 	return 0;
 }
 
-static int
-SGX2DQueryBlitsCompleteBW(IMG_UINT32 ui32BridgeID,
-			  PVRSRV_BRIDGE_IN_2DQUERYBLTSCOMPLETE *
-			  ps2DQueryBltsCompleteIN,
-			  PVRSRV_BRIDGE_RETURN * psRetOUT,
-			  PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	IMG_HANDLE hDevCookieInt;
-	IMG_VOID *pvSyncInfo;
-	PVRSRV_SGXDEV_INFO *psDevInfo;
+static int SGX2DQueryBlitsCompleteBW(u32 ui32BridgeID,
+	struct PVRSRV_BRIDGE_IN_2DQUERYBLTSCOMPLETE *ps2DQueryBltsCompleteIN,
+	struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	void *hDevCookieInt;
+	void *pvSyncInfo;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_SGX_2DQUERYBLTSCOMPLETE);
@@ -2889,47 +2738,41 @@
 	    PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevCookieInt,
 			       ps2DQueryBltsCompleteIN->hDevCookie,
 			       PVRSRV_HANDLE_TYPE_DEV_NODE);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVLookupHandle(psPerProc->psHandleBase, &pvSyncInfo,
 			       ps2DQueryBltsCompleteIN->hKernSyncInfo,
 			       PVRSRV_HANDLE_TYPE_SYNC_INFO);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
-	psDevInfo =
-	    (PVRSRV_SGXDEV_INFO *) ((PVRSRV_DEVICE_NODE *) hDevCookieInt)->
-	    pvDevice;
+	psDevInfo = (struct PVRSRV_SGXDEV_INFO *)
+		((struct PVRSRV_DEVICE_NODE *)hDevCookieInt)->pvDevice;
 
-	psRetOUT->eError =
-	    SGX2DQueryBlitsCompleteKM(psDevInfo,
-				      (PVRSRV_KERNEL_SYNC_INFO *) pvSyncInfo,
-				      ps2DQueryBltsCompleteIN->
-				      bWaitForComplete);
+	psRetOUT->eError = SGX2DQueryBlitsCompleteKM(psDevInfo,
+			      (struct PVRSRV_KERNEL_SYNC_INFO *)pvSyncInfo,
+			      ps2DQueryBltsCompleteIN->bWaitForComplete);
 
 	return 0;
 }
 
-static int
-SGXFindSharedPBDescBW(IMG_UINT32 ui32BridgeID,
-		      PVRSRV_BRIDGE_IN_SGXFINDSHAREDPBDESC *
-		      psSGXFindSharedPBDescIN,
-		      PVRSRV_BRIDGE_OUT_SGXFINDSHAREDPBDESC *
-		      psSGXFindSharedPBDescOUT,
-		      PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	IMG_HANDLE hDevCookieInt;
-	PVRSRV_KERNEL_MEM_INFO *psSharedPBDescKernelMemInfo;
-	PVRSRV_KERNEL_MEM_INFO *psHWPBDescKernelMemInfo;
-	PVRSRV_KERNEL_MEM_INFO *psBlockKernelMemInfo;
-	PVRSRV_KERNEL_MEM_INFO **ppsSharedPBDescSubKernelMemInfos = IMG_NULL;
-	IMG_UINT32 ui32SharedPBDescSubKernelMemInfosCount = 0;
-	IMG_UINT32 i;
-	IMG_HANDLE hSharedPBDesc = IMG_NULL;
+static int SGXFindSharedPBDescBW(u32 ui32BridgeID,
+	      struct PVRSRV_BRIDGE_IN_SGXFINDSHAREDPBDESC
+			*psSGXFindSharedPBDescIN,
+	      struct PVRSRV_BRIDGE_OUT_SGXFINDSHAREDPBDESC
+			*psSGXFindSharedPBDescOUT,
+	      struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	void *hDevCookieInt;
+	struct PVRSRV_KERNEL_MEM_INFO *psSharedPBDescKernelMemInfo;
+	struct PVRSRV_KERNEL_MEM_INFO *psHWPBDescKernelMemInfo;
+	struct PVRSRV_KERNEL_MEM_INFO *psBlockKernelMemInfo;
+	struct PVRSRV_KERNEL_MEM_INFO **ppsSharedPBDescSubKernelMemInfos = NULL;
+	u32 ui32SharedPBDescSubKernelMemInfosCount = 0;
+	u32 i;
+	void *hSharedPBDesc = NULL;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_SGX_FINDSHAREDPBDESC);
@@ -2938,7 +2781,7 @@
 				  PVRSRV_BRIDGE_SGX_SHAREDPBDESC_MAX_SUBMEMINFOS
 				  + 4);
 
-	psSGXFindSharedPBDescOUT->hSharedPBDesc = IMG_NULL;
+	psSGXFindSharedPBDescOUT->hSharedPBDesc = NULL;
 
 	psSGXFindSharedPBDescOUT->eError =
 	    PVRSRVLookupHandle(psPerProc->psHandleBase,
@@ -2967,8 +2810,9 @@
 	psSGXFindSharedPBDescOUT->ui32SharedPBDescSubKernelMemInfoHandlesCount =
 	    ui32SharedPBDescSubKernelMemInfosCount;
 
-	if (hSharedPBDesc == IMG_NULL) {
-		psSGXFindSharedPBDescOUT->hSharedPBDescKernelMemInfoHandle = 0;
+	if (hSharedPBDesc == NULL) {
+		psSGXFindSharedPBDescOUT->hSharedPBDescKernelMemInfoHandle =
+									NULL;
 
 		goto PVRSRV_BRIDGE_SGX_FINDSHAREDPBDESC_EXIT;
 	}
@@ -2997,14 +2841,15 @@
 
 	PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
 			       &psSGXFindSharedPBDescOUT->
-			       hBlockKernelMemInfoHandle, psBlockKernelMemInfo,
+			       hBlockKernelMemInfoHandle,
+			       psBlockKernelMemInfo,
 			       PVRSRV_HANDLE_TYPE_MEM_INFO_REF,
 			       PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
 			       psSGXFindSharedPBDescOUT->hSharedPBDesc);
 
 	for (i = 0; i < ui32SharedPBDescSubKernelMemInfosCount; i++) {
-		PVRSRV_BRIDGE_OUT_SGXFINDSHAREDPBDESC *psSGXFindSharedPBDescOut
-		    = psSGXFindSharedPBDescOUT;
+		struct PVRSRV_BRIDGE_OUT_SGXFINDSHAREDPBDESC *
+			psSGXFindSharedPBDescOut = psSGXFindSharedPBDescOUT;
 
 		PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
 				       &psSGXFindSharedPBDescOut->
@@ -3017,17 +2862,15 @@
 	}
 
 PVRSRV_BRIDGE_SGX_FINDSHAREDPBDESC_EXIT:
-	if (ppsSharedPBDescSubKernelMemInfos != IMG_NULL) {
+	if (ppsSharedPBDescSubKernelMemInfos != NULL)
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  sizeof(PVRSRV_KERNEL_MEM_INFO *)
-			  * ui32SharedPBDescSubKernelMemInfosCount,
-			  ppsSharedPBDescSubKernelMemInfos, IMG_NULL);
-	}
+			  sizeof(struct PVRSRV_KERNEL_MEM_INFO *) *
+					ui32SharedPBDescSubKernelMemInfosCount,
+			  ppsSharedPBDescSubKernelMemInfos, NULL);
 
 	if (psSGXFindSharedPBDescOUT->eError != PVRSRV_OK) {
-		if (hSharedPBDesc != IMG_NULL) {
+		if (hSharedPBDesc != NULL)
 			SGXUnrefSharedPBDescKM(hSharedPBDesc);
-		}
 	} else {
 		COMMIT_HANDLE_BATCH_OR_ERROR(psSGXFindSharedPBDescOUT->eError,
 					     psPerProc);
@@ -3036,15 +2879,12 @@
 	return 0;
 }
 
-static int
-SGXUnrefSharedPBDescBW(IMG_UINT32 ui32BridgeID,
-		       PVRSRV_BRIDGE_IN_SGXUNREFSHAREDPBDESC *
-		       psSGXUnrefSharedPBDescIN,
-		       PVRSRV_BRIDGE_OUT_SGXUNREFSHAREDPBDESC *
-		       psSGXUnrefSharedPBDescOUT,
-		       PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int SGXUnrefSharedPBDescBW(u32 ui32BridgeID,
+       struct PVRSRV_BRIDGE_IN_SGXUNREFSHAREDPBDESC *psSGXUnrefSharedPBDescIN,
+       struct PVRSRV_BRIDGE_OUT_SGXUNREFSHAREDPBDESC *psSGXUnrefSharedPBDescOUT,
+       struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hSharedPBDesc;
+	void *hSharedPBDesc;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_SGX_UNREFSHAREDPBDESC);
@@ -3054,16 +2894,14 @@
 			       &hSharedPBDesc,
 			       psSGXUnrefSharedPBDescIN->hSharedPBDesc,
 			       PVRSRV_HANDLE_TYPE_SHARED_PB_DESC);
-	if (psSGXUnrefSharedPBDescOUT->eError != PVRSRV_OK) {
+	if (psSGXUnrefSharedPBDescOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psSGXUnrefSharedPBDescOUT->eError =
 	    SGXUnrefSharedPBDescKM(hSharedPBDesc);
 
-	if (psSGXUnrefSharedPBDescOUT->eError != PVRSRV_OK) {
+	if (psSGXUnrefSharedPBDescOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psSGXUnrefSharedPBDescOUT->eError =
 	    PVRSRVReleaseHandle(psPerProc->psHandleBase,
@@ -3074,25 +2912,23 @@
 }
 
 static int
-SGXAddSharedPBDescBW(IMG_UINT32 ui32BridgeID,
-		     PVRSRV_BRIDGE_IN_SGXADDSHAREDPBDESC *
-		     psSGXAddSharedPBDescIN,
-		     PVRSRV_BRIDGE_OUT_SGXADDSHAREDPBDESC *
-		     psSGXAddSharedPBDescOUT,
-		     PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	IMG_HANDLE hDevCookieInt;
-	PVRSRV_KERNEL_MEM_INFO *psSharedPBDescKernelMemInfo;
-	PVRSRV_KERNEL_MEM_INFO *psHWPBDescKernelMemInfo;
-	PVRSRV_KERNEL_MEM_INFO *psBlockKernelMemInfo;
-	IMG_UINT32 ui32KernelMemInfoHandlesCount =
+SGXAddSharedPBDescBW(u32 ui32BridgeID,
+	   struct PVRSRV_BRIDGE_IN_SGXADDSHAREDPBDESC *psSGXAddSharedPBDescIN,
+	   struct PVRSRV_BRIDGE_OUT_SGXADDSHAREDPBDESC *psSGXAddSharedPBDescOUT,
+	   struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	void *hDevCookieInt;
+	struct PVRSRV_KERNEL_MEM_INFO *psSharedPBDescKernelMemInfo;
+	struct PVRSRV_KERNEL_MEM_INFO *psHWPBDescKernelMemInfo;
+	struct PVRSRV_KERNEL_MEM_INFO *psBlockKernelMemInfo;
+	u32 ui32KernelMemInfoHandlesCount =
 	    psSGXAddSharedPBDescIN->ui32KernelMemInfoHandlesCount;
 	int ret = 0;
-	IMG_HANDLE *phKernelMemInfoHandles = IMG_NULL;
-	PVRSRV_KERNEL_MEM_INFO **ppsKernelMemInfos = IMG_NULL;
-	IMG_UINT32 i;
-	PVRSRV_ERROR eError;
-	IMG_HANDLE hSharedPBDesc = IMG_NULL;
+	void **phKernelMemInfoHandles = NULL;
+	struct PVRSRV_KERNEL_MEM_INFO **ppsKernelMemInfos = NULL;
+	u32 i;
+	enum PVRSRV_ERROR eError;
+	void *hSharedPBDesc = NULL;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC);
@@ -3100,7 +2936,7 @@
 	NEW_HANDLE_BATCH_OR_ERROR(psSGXAddSharedPBDescOUT->eError, psPerProc,
 				  1);
 
-	psSGXAddSharedPBDescOUT->hSharedPBDesc = IMG_NULL;
+	psSGXAddSharedPBDescOUT->hSharedPBDesc = NULL;
 
 	PVR_ASSERT(ui32KernelMemInfoHandlesCount
 		   <= PVRSRV_BRIDGE_SGX_SHAREDPBDESC_MAX_SUBMEMINFOS);
@@ -3109,49 +2945,44 @@
 				    &hDevCookieInt,
 				    psSGXAddSharedPBDescIN->hDevCookie,
 				    PVRSRV_HANDLE_TYPE_DEV_NODE);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		goto PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC_RETURN_RESULT;
-	}
 
 	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
-				    (IMG_VOID **) & psSharedPBDescKernelMemInfo,
+				    (void **) &psSharedPBDescKernelMemInfo,
 				    psSGXAddSharedPBDescIN->
 				    hSharedPBDescKernelMemInfo,
 				    PVRSRV_HANDLE_TYPE_SHARED_SYS_MEM_INFO);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		goto PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC_RETURN_RESULT;
-	}
 
 	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
-				    (IMG_VOID **) & psHWPBDescKernelMemInfo,
+				    (void **) &psHWPBDescKernelMemInfo,
 				    psSGXAddSharedPBDescIN->
 				    hHWPBDescKernelMemInfo,
 				    PVRSRV_HANDLE_TYPE_MEM_INFO);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		goto PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC_RETURN_RESULT;
-	}
 
 	eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
-				    (IMG_VOID **) & psBlockKernelMemInfo,
+				    (void **) &psBlockKernelMemInfo,
 				    psSGXAddSharedPBDescIN->hBlockKernelMemInfo,
 				    PVRSRV_HANDLE_TYPE_SHARED_SYS_MEM_INFO);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		goto PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC_RETURN_RESULT;
-	}
 
 	if (!OSAccessOK(PVR_VERIFY_READ,
 			psSGXAddSharedPBDescIN->phKernelMemInfoHandles,
-			ui32KernelMemInfoHandlesCount * sizeof(IMG_HANDLE))) {
-		PVR_DPF((PVR_DBG_ERROR, "%s: PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC:"
-			 " Invalid phKernelMemInfos pointer", __FUNCTION__));
+			ui32KernelMemInfoHandlesCount * sizeof(void *))) {
+		PVR_DPF(PVR_DBG_ERROR, "%s: PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC:"
+			 " Invalid phKernelMemInfos pointer", __func__);
 		ret = -EFAULT;
 		goto PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC_RETURN_RESULT;
 	}
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       ui32KernelMemInfoHandlesCount * sizeof(IMG_HANDLE),
-		       (IMG_VOID **) & phKernelMemInfoHandles,
-		       0) != PVRSRV_OK) {
+		       ui32KernelMemInfoHandlesCount * sizeof(void *),
+		       (void **)&phKernelMemInfoHandles, NULL) != PVRSRV_OK) {
 		ret = -ENOMEM;
 		goto PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC_RETURN_RESULT;
 	}
@@ -3161,7 +2992,7 @@
 				phKernelMemInfoHandles,
 				psSGXAddSharedPBDescIN->phKernelMemInfoHandles,
 				ui32KernelMemInfoHandlesCount *
-				sizeof(IMG_HANDLE))
+				sizeof(void *))
 	    != PVRSRV_OK) {
 		ret = -EFAULT;
 		goto PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC_RETURN_RESULT;
@@ -3169,21 +3000,20 @@
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 		       ui32KernelMemInfoHandlesCount *
-		       sizeof(PVRSRV_KERNEL_MEM_INFO *),
-		       (IMG_VOID **) & ppsKernelMemInfos, 0) != PVRSRV_OK) {
+		       sizeof(struct PVRSRV_KERNEL_MEM_INFO *),
+		       (void **) &ppsKernelMemInfos, NULL) != PVRSRV_OK) {
 		ret = -ENOMEM;
 		goto PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC_RETURN_RESULT;
 	}
 
 	for (i = 0; i < ui32KernelMemInfoHandlesCount; i++) {
 		eError = PVRSRVLookupHandle(psPerProc->psHandleBase,
-					    (IMG_VOID **) &
+					    (void **) &
 					    ppsKernelMemInfos[i],
 					    phKernelMemInfoHandles[i],
 					    PVRSRV_HANDLE_TYPE_MEM_INFO);
-		if (eError != PVRSRV_OK) {
+		if (eError != PVRSRV_OK)
 			goto PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC_RETURN_RESULT;
-		}
 	}
 
 	eError = PVRSRVReleaseHandle(psPerProc->psHandleBase,
@@ -3220,9 +3050,8 @@
 				      ppsKernelMemInfos,
 				      ui32KernelMemInfoHandlesCount);
 
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		goto PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC_RETURN_RESULT;
-	}
 
 	PVRSRVAllocHandleNR(psPerProc->psHandleBase,
 			    &psSGXAddSharedPBDescOUT->hSharedPBDesc,
@@ -3232,23 +3061,20 @@
 
 PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC_RETURN_RESULT:
 
-	if (phKernelMemInfoHandles) {
+	if (phKernelMemInfoHandles)
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
 			  psSGXAddSharedPBDescIN->ui32KernelMemInfoHandlesCount
-			  * sizeof(IMG_HANDLE),
-			  (IMG_VOID *) phKernelMemInfoHandles, 0);
-	}
-	if (ppsKernelMemInfos) {
+				* sizeof(void *),
+			  (void *)phKernelMemInfoHandles, NULL);
+	if (ppsKernelMemInfos)
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
 			  psSGXAddSharedPBDescIN->ui32KernelMemInfoHandlesCount
-			  * sizeof(PVRSRV_KERNEL_MEM_INFO *),
-			  (IMG_VOID *) ppsKernelMemInfos, 0);
-	}
+				 * sizeof(struct PVRSRV_KERNEL_MEM_INFO *),
+			  (void *)ppsKernelMemInfos, NULL);
 
-	if (ret == 0 && eError == PVRSRV_OK) {
+	if (ret == 0 && eError == PVRSRV_OK)
 		COMMIT_HANDLE_BATCH_OR_ERROR(psSGXAddSharedPBDescOUT->eError,
 					     psPerProc);
-	}
 
 	psSGXAddSharedPBDescOUT->eError = eError;
 
@@ -3256,53 +3082,49 @@
 }
 
 
-static int
-PVRSRVGetMiscInfoBW(IMG_UINT32 ui32BridgeID,
-		    PVRSRV_BRIDGE_IN_GET_MISC_INFO * psGetMiscInfoIN,
-		    PVRSRV_BRIDGE_OUT_GET_MISC_INFO * psGetMiscInfoOUT,
-		    PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVGetMiscInfoBW(u32 ui32BridgeID,
+		    struct PVRSRV_BRIDGE_IN_GET_MISC_INFO *psGetMiscInfoIN,
+		    struct PVRSRV_BRIDGE_OUT_GET_MISC_INFO *psGetMiscInfoOUT,
+		    struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_GET_MISC_INFO);
 
-	OSMemCopy(&psGetMiscInfoOUT->sMiscInfo,
-		  &psGetMiscInfoIN->sMiscInfo, sizeof(PVRSRV_MISC_INFO));
+	OSMemCopy(&psGetMiscInfoOUT->sMiscInfo, &psGetMiscInfoIN->sMiscInfo,
+		  sizeof(struct PVRSRV_MISC_INFO));
 
-	if (psGetMiscInfoIN->sMiscInfo.
-	    ui32StateRequest & PVRSRV_MISC_INFO_MEMSTATS_PRESENT) {
+	if (psGetMiscInfoIN->sMiscInfo.ui32StateRequest &
+				PVRSRV_MISC_INFO_MEMSTATS_PRESENT) {
 
 		ASSIGN_AND_EXIT_ON_ERROR(psGetMiscInfoOUT->eError,
-					 OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-						    psGetMiscInfoOUT->sMiscInfo.
-						    ui32MemoryStrLen,
-						    (IMG_VOID **) &
-						    psGetMiscInfoOUT->sMiscInfo.
-						    pszMemoryStr, 0));
-
-		psGetMiscInfoOUT->eError =
-		    PVRSRVGetMiscInfoKM(&psGetMiscInfoOUT->sMiscInfo);
+		     OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
+			   psGetMiscInfoOUT->sMiscInfo.ui32MemoryStrLen,
+			   (void **)&psGetMiscInfoOUT->sMiscInfo.pszMemoryStr,
+			   NULL));
+
+		psGetMiscInfoOUT->eError = PVRSRVGetMiscInfoKM(
+				(struct PVRSRV_MISC_INFO __force *)
+					&psGetMiscInfoOUT->sMiscInfo);
 
 		eError = CopyToUserWrapper(psPerProc, ui32BridgeID,
-					   psGetMiscInfoIN->sMiscInfo.
-					   pszMemoryStr,
-					   psGetMiscInfoOUT->sMiscInfo.
-					   pszMemoryStr,
-					   psGetMiscInfoOUT->sMiscInfo.
-					   ui32MemoryStrLen);
+				(void __force __user *)
+					psGetMiscInfoIN->sMiscInfo.pszMemoryStr,
+				psGetMiscInfoOUT->sMiscInfo.pszMemoryStr,
+				psGetMiscInfoOUT->sMiscInfo.ui32MemoryStrLen);
 
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
 			  psGetMiscInfoOUT->sMiscInfo.ui32MemoryStrLen,
-			  (IMG_VOID *) psGetMiscInfoOUT->sMiscInfo.pszMemoryStr,
-			  0);
+			  (void *)psGetMiscInfoOUT->sMiscInfo.pszMemoryStr,
+			  NULL);
 
 		psGetMiscInfoOUT->sMiscInfo.pszMemoryStr =
 		    psGetMiscInfoIN->sMiscInfo.pszMemoryStr;
 
 		if (eError != PVRSRV_OK) {
 
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVGetMiscInfoBW Error copy to user"));
+			PVR_DPF(PVR_DBG_ERROR,
+				 "PVRSRVGetMiscInfoBW Error copy to user");
 			return -EFAULT;
 		}
 	} else {
@@ -3311,7 +3133,7 @@
 	}
 
 	if (psGetMiscInfoIN->sMiscInfo.
-	    ui32StateRequest & PVRSRV_MISC_INFO_GLOBALEVENTOBJECT_PRESENT) {
+	    ui32StateRequest & PVRSRV_MISC_INFO_GLOBALEVENTOBJECT_PRESENT)
 
 		psGetMiscInfoOUT->eError =
 		    PVRSRVAllocHandle(psPerProc->psHandleBase,
@@ -3321,16 +3143,14 @@
 				      sGlobalEventObject.hOSEventKM,
 				      PVRSRV_HANDLE_TYPE_SHARED_EVENT_OBJECT,
 				      PVRSRV_HANDLE_ALLOC_FLAG_SHARED);
-	}
 
 	return 0;
 }
 
-static int
-PVRSRVConnectBW(IMG_UINT32 ui32BridgeID,
-		IMG_VOID * psBridgeIn,
-		PVRSRV_BRIDGE_OUT_CONNECT_SERVICES * psConnectServicesOUT,
-		PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVConnectBW(u32 ui32BridgeID,
+		void *psBridgeIn,
+		struct PVRSRV_BRIDGE_OUT_CONNECT_SERVICES *psConnectServicesOUT,
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVR_UNREFERENCED_PARAMETER(psBridgeIn);
 
@@ -3342,11 +3162,10 @@
 	return 0;
 }
 
-static int
-PVRSRVDisconnectBW(IMG_UINT32 ui32BridgeID,
-		   IMG_VOID * psBridgeIn,
-		   PVRSRV_BRIDGE_RETURN * psRetOUT,
-		   PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVDisconnectBW(u32 ui32BridgeID,
+		   void *psBridgeIn,
+		   struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+		   struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVR_UNREFERENCED_PARAMETER(psPerProc);
 	PVR_UNREFERENCED_PARAMETER(psBridgeIn);
@@ -3359,11 +3178,10 @@
 	return 0;
 }
 
-static int
-PVRSRVEnumerateDCBW(IMG_UINT32 ui32BridgeID,
-		    PVRSRV_BRIDGE_IN_ENUMCLASS * psEnumDispClassIN,
-		    PVRSRV_BRIDGE_OUT_ENUMCLASS * psEnumDispClassOUT,
-		    PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVEnumerateDCBW(u32 ui32BridgeID,
+		    struct PVRSRV_BRIDGE_IN_ENUMCLASS *psEnumDispClassIN,
+		    struct PVRSRV_BRIDGE_OUT_ENUMCLASS *psEnumDispClassOUT,
+		    struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 	PVR_UNREFERENCED_PARAMETER(psPerProc);
 
@@ -3377,16 +3195,13 @@
 	return 0;
 }
 
-static int
-PVRSRVOpenDCDeviceBW(IMG_UINT32 ui32BridgeID,
-		     PVRSRV_BRIDGE_IN_OPEN_DISPCLASS_DEVICE *
-		     psOpenDispClassDeviceIN,
-		     PVRSRV_BRIDGE_OUT_OPEN_DISPCLASS_DEVICE *
-		     psOpenDispClassDeviceOUT,
-		     PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVOpenDCDeviceBW(u32 ui32BridgeID,
+     struct PVRSRV_BRIDGE_IN_OPEN_DISPCLASS_DEVICE *psOpenDispClassDeviceIN,
+     struct PVRSRV_BRIDGE_OUT_OPEN_DISPCLASS_DEVICE *psOpenDispClassDeviceOUT,
+     struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hDevCookieInt;
-	IMG_HANDLE hDispClassInfoInt;
+	void *hDevCookieInt;
+	void *hDispClassInfoInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_OPEN_DISPCLASS_DEVICE);
@@ -3399,18 +3214,16 @@
 			       &hDevCookieInt,
 			       psOpenDispClassDeviceIN->hDevCookie,
 			       PVRSRV_HANDLE_TYPE_DEV_NODE);
-	if (psOpenDispClassDeviceOUT->eError != PVRSRV_OK) {
+	if (psOpenDispClassDeviceOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psOpenDispClassDeviceOUT->eError =
 	    PVRSRVOpenDCDeviceKM(psPerProc,
 				 psOpenDispClassDeviceIN->ui32DeviceID,
 				 hDevCookieInt, &hDispClassInfoInt);
 
-	if (psOpenDispClassDeviceOUT->eError != PVRSRV_OK) {
+	if (psOpenDispClassDeviceOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	PVRSRVAllocHandleNR(psPerProc->psHandleBase,
 			    &psOpenDispClassDeviceOUT->hDeviceKM,
@@ -3423,13 +3236,12 @@
 	return 0;
 }
 
-static int
-PVRSRVCloseDCDeviceBW(IMG_UINT32 ui32BridgeID,
-		      PVRSRV_BRIDGE_IN_CLOSE_DISPCLASS_DEVICE *
-		      psCloseDispClassDeviceIN, PVRSRV_BRIDGE_RETURN * psRetOUT,
-		      PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVCloseDCDeviceBW(u32 ui32BridgeID,
+     struct PVRSRV_BRIDGE_IN_CLOSE_DISPCLASS_DEVICE *psCloseDispClassDeviceIN,
+     struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+     struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvDispClassInfoInt;
+	void *pvDispClassInfoInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_CLOSE_DISPCLASS_DEVICE);
@@ -3440,14 +3252,12 @@
 			       psCloseDispClassDeviceIN->hDeviceKM,
 			       PVRSRV_HANDLE_TYPE_DISP_INFO);
 
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError = PVRSRVCloseDCDeviceKM(pvDispClassInfoInt, IMG_FALSE);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVReleaseHandle(psPerProc->psHandleBase,
@@ -3456,15 +3266,12 @@
 	return 0;
 }
 
-static int
-PVRSRVEnumDCFormatsBW(IMG_UINT32 ui32BridgeID,
-		      PVRSRV_BRIDGE_IN_ENUM_DISPCLASS_FORMATS *
-		      psEnumDispClassFormatsIN,
-		      PVRSRV_BRIDGE_OUT_ENUM_DISPCLASS_FORMATS *
-		      psEnumDispClassFormatsOUT,
-		      PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVEnumDCFormatsBW(u32 ui32BridgeID,
+     struct PVRSRV_BRIDGE_IN_ENUM_DISPCLASS_FORMATS *psEnumDispClassFormatsIN,
+     struct PVRSRV_BRIDGE_OUT_ENUM_DISPCLASS_FORMATS *psEnumDispClassFormatsOUT,
+     struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvDispClassInfoInt;
+	void *pvDispClassInfoInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_ENUM_DISPCLASS_FORMATS);
@@ -3474,9 +3281,8 @@
 			       &pvDispClassInfoInt,
 			       psEnumDispClassFormatsIN->hDeviceKM,
 			       PVRSRV_HANDLE_TYPE_DISP_INFO);
-	if (psEnumDispClassFormatsOUT->eError != PVRSRV_OK) {
+	if (psEnumDispClassFormatsOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psEnumDispClassFormatsOUT->eError =
 	    PVRSRVEnumDCFormatsKM(pvDispClassInfoInt,
@@ -3486,13 +3292,12 @@
 	return 0;
 }
 
-static int
-PVRSRVEnumDCDimsBW(IMG_UINT32 ui32BridgeID,
-		   PVRSRV_BRIDGE_IN_ENUM_DISPCLASS_DIMS * psEnumDispClassDimsIN,
-		   PVRSRV_BRIDGE_OUT_ENUM_DISPCLASS_DIMS *
-		   psEnumDispClassDimsOUT, PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVEnumDCDimsBW(u32 ui32BridgeID,
+	   struct PVRSRV_BRIDGE_IN_ENUM_DISPCLASS_DIMS *psEnumDispClassDimsIN,
+	   struct PVRSRV_BRIDGE_OUT_ENUM_DISPCLASS_DIMS *psEnumDispClassDimsOUT,
+	   struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvDispClassInfoInt;
+	void *pvDispClassInfoInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_ENUM_DISPCLASS_DIMS);
@@ -3503,9 +3308,8 @@
 			       psEnumDispClassDimsIN->hDeviceKM,
 			       PVRSRV_HANDLE_TYPE_DISP_INFO);
 
-	if (psEnumDispClassDimsOUT->eError != PVRSRV_OK) {
+	if (psEnumDispClassDimsOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psEnumDispClassDimsOUT->eError =
 	    PVRSRVEnumDCDimsKM(pvDispClassInfoInt,
@@ -3516,16 +3320,13 @@
 	return 0;
 }
 
-static int
-PVRSRVGetDCSystemBufferBW(IMG_UINT32 ui32BridgeID,
-			  PVRSRV_BRIDGE_IN_GET_DISPCLASS_SYSBUFFER *
-			  psGetDispClassSysBufferIN,
-			  PVRSRV_BRIDGE_OUT_GET_DISPCLASS_SYSBUFFER *
-			  psGetDispClassSysBufferOUT,
-			  PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVGetDCSystemBufferBW(u32 ui32BridgeID,
+   struct PVRSRV_BRIDGE_IN_GET_DISPCLASS_SYSBUFFER *psGetDispClassSysBufferIN,
+   struct PVRSRV_BRIDGE_OUT_GET_DISPCLASS_SYSBUFFER *psGetDispClassSysBufferOUT,
+   struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hBufferInt;
-	IMG_VOID *pvDispClassInfoInt;
+	void *hBufferInt;
+	void *pvDispClassInfoInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_GET_DISPCLASS_SYSBUFFER);
@@ -3538,22 +3339,20 @@
 			       &pvDispClassInfoInt,
 			       psGetDispClassSysBufferIN->hDeviceKM,
 			       PVRSRV_HANDLE_TYPE_DISP_INFO);
-	if (psGetDispClassSysBufferOUT->eError != PVRSRV_OK) {
+	if (psGetDispClassSysBufferOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psGetDispClassSysBufferOUT->eError =
 	    PVRSRVGetDCSystemBufferKM(pvDispClassInfoInt, &hBufferInt);
 
-	if (psGetDispClassSysBufferOUT->eError != PVRSRV_OK) {
+	if (psGetDispClassSysBufferOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
 			       &psGetDispClassSysBufferOUT->hBuffer,
 			       hBufferInt,
 			       PVRSRV_HANDLE_TYPE_DISP_BUFFER,
-			       (PVRSRV_HANDLE_ALLOC_FLAG)
+			       (enum PVRSRV_HANDLE_ALLOC_FLAG)
 			       (PVRSRV_HANDLE_ALLOC_FLAG_PRIVATE |
 				PVRSRV_HANDLE_ALLOC_FLAG_SHARED),
 			       psGetDispClassSysBufferIN->hDeviceKM);
@@ -3564,13 +3363,12 @@
 	return 0;
 }
 
-static int
-PVRSRVGetDCInfoBW(IMG_UINT32 ui32BridgeID,
-		  PVRSRV_BRIDGE_IN_GET_DISPCLASS_INFO * psGetDispClassInfoIN,
-		  PVRSRV_BRIDGE_OUT_GET_DISPCLASS_INFO * psGetDispClassInfoOUT,
-		  PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVGetDCInfoBW(u32 ui32BridgeID,
+	  struct PVRSRV_BRIDGE_IN_GET_DISPCLASS_INFO *psGetDispClassInfoIN,
+	  struct PVRSRV_BRIDGE_OUT_GET_DISPCLASS_INFO *psGetDispClassInfoOUT,
+	  struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvDispClassInfo;
+	void *pvDispClassInfo;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_GET_DISPCLASS_INFO);
@@ -3580,9 +3378,8 @@
 			       &pvDispClassInfo,
 			       psGetDispClassInfoIN->hDeviceKM,
 			       PVRSRV_HANDLE_TYPE_DISP_INFO);
-	if (psGetDispClassInfoOUT->eError != PVRSRV_OK) {
+	if (psGetDispClassInfoOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psGetDispClassInfoOUT->eError =
 	    PVRSRVGetDCInfoKM(pvDispClassInfo,
@@ -3591,16 +3388,15 @@
 	return 0;
 }
 
-static int
-PVRSRVCreateDCSwapChainBW(IMG_UINT32 ui32BridgeID,
-			  PVRSRV_BRIDGE_IN_CREATE_DISPCLASS_SWAPCHAIN *
-			  psCreateDispClassSwapChainIN,
-			  PVRSRV_BRIDGE_OUT_CREATE_DISPCLASS_SWAPCHAIN *
-			  psCreateDispClassSwapChainOUT,
-			  PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVCreateDCSwapChainBW(u32 ui32BridgeID,
+		  struct PVRSRV_BRIDGE_IN_CREATE_DISPCLASS_SWAPCHAIN
+				*psCreateDispClassSwapChainIN,
+		  struct PVRSRV_BRIDGE_OUT_CREATE_DISPCLASS_SWAPCHAIN
+				*psCreateDispClassSwapChainOUT,
+		  struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvDispClassInfo;
-	IMG_HANDLE hSwapChainInt;
+	void *pvDispClassInfo;
+	void *hSwapChainInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_CREATE_DISPCLASS_SWAPCHAIN);
@@ -3614,9 +3410,8 @@
 			       psCreateDispClassSwapChainIN->hDeviceKM,
 			       PVRSRV_HANDLE_TYPE_DISP_INFO);
 
-	if (psCreateDispClassSwapChainOUT->eError != PVRSRV_OK) {
+	if (psCreateDispClassSwapChainOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psCreateDispClassSwapChainOUT->eError =
 	    PVRSRVCreateDCSwapChainKM(psPerProc, pvDispClassInfo,
@@ -3632,9 +3427,8 @@
 				      &psCreateDispClassSwapChainOUT->
 				      ui32SwapChainID);
 
-	if (psCreateDispClassSwapChainOUT->eError != PVRSRV_OK) {
+	if (psCreateDispClassSwapChainOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
 			       &psCreateDispClassSwapChainOUT->hSwapChain,
@@ -3649,14 +3443,13 @@
 	return 0;
 }
 
-static int
-PVRSRVDestroyDCSwapChainBW(IMG_UINT32 ui32BridgeID,
-			   PVRSRV_BRIDGE_IN_DESTROY_DISPCLASS_SWAPCHAIN *
-			   psDestroyDispClassSwapChainIN,
-			   PVRSRV_BRIDGE_RETURN * psRetOUT,
-			   PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVDestroyDCSwapChainBW(u32 ui32BridgeID,
+			   struct PVRSRV_BRIDGE_IN_DESTROY_DISPCLASS_SWAPCHAIN
+					*psDestroyDispClassSwapChainIN,
+			   struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+			   struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvSwapChain;
+	void *pvSwapChain;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_DESTROY_DISPCLASS_SWAPCHAIN);
@@ -3665,15 +3458,13 @@
 	    PVRSRVLookupHandle(psPerProc->psHandleBase, &pvSwapChain,
 			       psDestroyDispClassSwapChainIN->hSwapChain,
 			       PVRSRV_HANDLE_TYPE_DISP_SWAP_CHAIN);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError = PVRSRVDestroyDCSwapChainKM(pvSwapChain);
 
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVReleaseHandle(psPerProc->psHandleBase,
@@ -3683,14 +3474,13 @@
 	return 0;
 }
 
-static int
-PVRSRVSetDCDstRectBW(IMG_UINT32 ui32BridgeID,
-		     PVRSRV_BRIDGE_IN_SET_DISPCLASS_RECT *
-		     psSetDispClassDstRectIN, PVRSRV_BRIDGE_RETURN * psRetOUT,
-		     PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVSetDCDstRectBW(u32 ui32BridgeID,
+	 struct PVRSRV_BRIDGE_IN_SET_DISPCLASS_RECT *psSetDispClassDstRectIN,
+	 struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	 struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvDispClassInfo;
-	IMG_VOID *pvSwapChain;
+	void *pvDispClassInfo;
+	void *pvSwapChain;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_SET_DISPCLASS_DSTRECT);
@@ -3700,9 +3490,8 @@
 			       &pvDispClassInfo,
 			       psSetDispClassDstRectIN->hDeviceKM,
 			       PVRSRV_HANDLE_TYPE_DISP_INFO);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVLookupHandle(psPerProc->psHandleBase,
@@ -3710,9 +3499,8 @@
 			       psSetDispClassDstRectIN->hSwapChain,
 			       PVRSRV_HANDLE_TYPE_DISP_SWAP_CHAIN);
 
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVSetDCDstRectKM(pvDispClassInfo,
@@ -3721,14 +3509,13 @@
 	return 0;
 }
 
-static int
-PVRSRVSetDCSrcRectBW(IMG_UINT32 ui32BridgeID,
-		     PVRSRV_BRIDGE_IN_SET_DISPCLASS_RECT *
-		     psSetDispClassSrcRectIN, PVRSRV_BRIDGE_RETURN * psRetOUT,
-		     PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVSetDCSrcRectBW(u32 ui32BridgeID,
+     struct PVRSRV_BRIDGE_IN_SET_DISPCLASS_RECT *psSetDispClassSrcRectIN,
+     struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+     struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvDispClassInfo;
-	IMG_VOID *pvSwapChain;
+	void *pvDispClassInfo;
+	void *pvSwapChain;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_SET_DISPCLASS_SRCRECT);
@@ -3738,18 +3525,16 @@
 			       &pvDispClassInfo,
 			       psSetDispClassSrcRectIN->hDeviceKM,
 			       PVRSRV_HANDLE_TYPE_DISP_INFO);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVLookupHandle(psPerProc->psHandleBase,
 			       &pvSwapChain,
 			       psSetDispClassSrcRectIN->hSwapChain,
 			       PVRSRV_HANDLE_TYPE_DISP_SWAP_CHAIN);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVSetDCSrcRectKM(pvDispClassInfo,
@@ -3758,15 +3543,13 @@
 	return 0;
 }
 
-static int
-PVRSRVSetDCDstColourKeyBW(IMG_UINT32 ui32BridgeID,
-			  PVRSRV_BRIDGE_IN_SET_DISPCLASS_COLOURKEY *
-			  psSetDispClassColKeyIN,
-			  PVRSRV_BRIDGE_RETURN * psRetOUT,
-			  PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVSetDCDstColourKeyBW(u32 ui32BridgeID,
+       struct PVRSRV_BRIDGE_IN_SET_DISPCLASS_COLOURKEY *psSetDispClassColKeyIN,
+       struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+       struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvDispClassInfo;
-	IMG_VOID *pvSwapChain;
+	void *pvDispClassInfo;
+	void *pvSwapChain;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_SET_DISPCLASS_DSTCOLOURKEY);
@@ -3776,18 +3559,16 @@
 			       &pvDispClassInfo,
 			       psSetDispClassColKeyIN->hDeviceKM,
 			       PVRSRV_HANDLE_TYPE_DISP_INFO);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVLookupHandle(psPerProc->psHandleBase,
 			       &pvSwapChain,
 			       psSetDispClassColKeyIN->hSwapChain,
 			       PVRSRV_HANDLE_TYPE_DISP_SWAP_CHAIN);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVSetDCDstColourKeyKM(pvDispClassInfo,
@@ -3797,15 +3578,13 @@
 	return 0;
 }
 
-static int
-PVRSRVSetDCSrcColourKeyBW(IMG_UINT32 ui32BridgeID,
-			  PVRSRV_BRIDGE_IN_SET_DISPCLASS_COLOURKEY *
-			  psSetDispClassColKeyIN,
-			  PVRSRV_BRIDGE_RETURN * psRetOUT,
-			  PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVSetDCSrcColourKeyBW(u32 ui32BridgeID,
+	struct PVRSRV_BRIDGE_IN_SET_DISPCLASS_COLOURKEY *psSetDispClassColKeyIN,
+	struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+	struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvDispClassInfo;
-	IMG_VOID *pvSwapChain;
+	void *pvDispClassInfo;
+	void *pvSwapChain;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_SET_DISPCLASS_SRCCOLOURKEY);
@@ -3815,18 +3594,16 @@
 			       &pvDispClassInfo,
 			       psSetDispClassColKeyIN->hDeviceKM,
 			       PVRSRV_HANDLE_TYPE_DISP_INFO);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVLookupHandle(psPerProc->psHandleBase,
 			       &pvSwapChain,
 			       psSetDispClassColKeyIN->hSwapChain,
 			       PVRSRV_HANDLE_TYPE_DISP_SWAP_CHAIN);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVSetDCSrcColourKeyKM(pvDispClassInfo,
@@ -3836,17 +3613,14 @@
 	return 0;
 }
 
-static int
-PVRSRVGetDCBuffersBW(IMG_UINT32 ui32BridgeID,
-		     PVRSRV_BRIDGE_IN_GET_DISPCLASS_BUFFERS *
-		     psGetDispClassBuffersIN,
-		     PVRSRV_BRIDGE_OUT_GET_DISPCLASS_BUFFERS *
-		     psGetDispClassBuffersOUT,
-		     PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	IMG_VOID *pvDispClassInfo;
-	IMG_VOID *pvSwapChain;
-	IMG_UINT32 i;
+static int PVRSRVGetDCBuffersBW(u32 ui32BridgeID,
+     struct PVRSRV_BRIDGE_IN_GET_DISPCLASS_BUFFERS *psGetDispClassBuffersIN,
+     struct PVRSRV_BRIDGE_OUT_GET_DISPCLASS_BUFFERS *psGetDispClassBuffersOUT,
+     struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	void *pvDispClassInfo;
+	void *pvSwapChain;
+	u32 i;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_GET_DISPCLASS_BUFFERS);
@@ -3859,39 +3633,36 @@
 			       &pvDispClassInfo,
 			       psGetDispClassBuffersIN->hDeviceKM,
 			       PVRSRV_HANDLE_TYPE_DISP_INFO);
-	if (psGetDispClassBuffersOUT->eError != PVRSRV_OK) {
+	if (psGetDispClassBuffersOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psGetDispClassBuffersOUT->eError =
 	    PVRSRVLookupHandle(psPerProc->psHandleBase,
 			       &pvSwapChain,
 			       psGetDispClassBuffersIN->hSwapChain,
 			       PVRSRV_HANDLE_TYPE_DISP_SWAP_CHAIN);
-	if (psGetDispClassBuffersOUT->eError != PVRSRV_OK) {
+	if (psGetDispClassBuffersOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psGetDispClassBuffersOUT->eError =
 	    PVRSRVGetDCBuffersKM(pvDispClassInfo,
 				 pvSwapChain,
 				 &psGetDispClassBuffersOUT->ui32BufferCount,
 				 psGetDispClassBuffersOUT->ahBuffer);
-	if (psGetDispClassBuffersOUT->eError != PVRSRV_OK) {
+	if (psGetDispClassBuffersOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	PVR_ASSERT(psGetDispClassBuffersOUT->ui32BufferCount <=
 		   PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS);
 
 	for (i = 0; i < psGetDispClassBuffersOUT->ui32BufferCount; i++) {
-		IMG_HANDLE hBufferExt;
+		void *hBufferExt;
 
 		PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
 				       &hBufferExt,
 				       psGetDispClassBuffersOUT->ahBuffer[i],
 				       PVRSRV_HANDLE_TYPE_DISP_BUFFER,
-				       (PVRSRV_HANDLE_ALLOC_FLAG)
+				       (enum PVRSRV_HANDLE_ALLOC_FLAG)
 				       (PVRSRV_HANDLE_ALLOC_FLAG_PRIVATE |
 					PVRSRV_HANDLE_ALLOC_FLAG_SHARED),
 				       psGetDispClassBuffersIN->hSwapChain);
@@ -3905,14 +3676,13 @@
 	return 0;
 }
 
-static int
-PVRSRVSwapToDCBufferBW(IMG_UINT32 ui32BridgeID,
-		       PVRSRV_BRIDGE_IN_SWAP_DISPCLASS_TO_BUFFER *
-		       psSwapDispClassBufferIN, PVRSRV_BRIDGE_RETURN * psRetOUT,
-		       PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVSwapToDCBufferBW(u32 ui32BridgeID,
+      struct PVRSRV_BRIDGE_IN_SWAP_DISPCLASS_TO_BUFFER *psSwapDispClassBufferIN,
+      struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+      struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvDispClassInfo;
-	IMG_VOID *pvSwapChainBuf;
+	void *pvDispClassInfo;
+	void *pvSwapChainBuf;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_SWAP_DISPCLASS_TO_BUFFER);
@@ -3922,9 +3692,8 @@
 			       &pvDispClassInfo,
 			       psSwapDispClassBufferIN->hDeviceKM,
 			       PVRSRV_HANDLE_TYPE_DISP_INFO);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVLookupSubHandle(psPerProc->psHandleBase,
@@ -3932,9 +3701,8 @@
 				  psSwapDispClassBufferIN->hBuffer,
 				  PVRSRV_HANDLE_TYPE_DISP_BUFFER,
 				  psSwapDispClassBufferIN->hDeviceKM);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVSwapToDCBufferKM(pvDispClassInfo,
@@ -3947,14 +3715,13 @@
 	return 0;
 }
 
-static int
-PVRSRVSwapToDCSystemBW(IMG_UINT32 ui32BridgeID,
-		       PVRSRV_BRIDGE_IN_SWAP_DISPCLASS_TO_SYSTEM *
-		       psSwapDispClassSystemIN, PVRSRV_BRIDGE_RETURN * psRetOUT,
-		       PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVSwapToDCSystemBW(u32 ui32BridgeID,
+      struct PVRSRV_BRIDGE_IN_SWAP_DISPCLASS_TO_SYSTEM *psSwapDispClassSystemIN,
+      struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+      struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvDispClassInfo;
-	IMG_VOID *pvSwapChain;
+	void *pvDispClassInfo;
+	void *pvSwapChain;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_SWAP_DISPCLASS_TO_SYSTEM);
@@ -3964,9 +3731,8 @@
 			       &pvDispClassInfo,
 			       psSwapDispClassSystemIN->hDeviceKM,
 			       PVRSRV_HANDLE_TYPE_DISP_INFO);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError =
 	    PVRSRVLookupSubHandle(psPerProc->psHandleBase,
@@ -3974,24 +3740,20 @@
 				  psSwapDispClassSystemIN->hSwapChain,
 				  PVRSRV_HANDLE_TYPE_DISP_SWAP_CHAIN,
 				  psSwapDispClassSystemIN->hDeviceKM);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 	psRetOUT->eError = PVRSRVSwapToDCSystemKM(pvDispClassInfo, pvSwapChain);
 
 	return 0;
 }
 
-static int
-PVRSRVOpenBCDeviceBW(IMG_UINT32 ui32BridgeID,
-		     PVRSRV_BRIDGE_IN_OPEN_BUFFERCLASS_DEVICE *
-		     psOpenBufferClassDeviceIN,
-		     PVRSRV_BRIDGE_OUT_OPEN_BUFFERCLASS_DEVICE *
-		     psOpenBufferClassDeviceOUT,
-		     PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVOpenBCDeviceBW(u32 ui32BridgeID,
+   struct PVRSRV_BRIDGE_IN_OPEN_BUFFERCLASS_DEVICE *psOpenBufferClassDeviceIN,
+   struct PVRSRV_BRIDGE_OUT_OPEN_BUFFERCLASS_DEVICE *psOpenBufferClassDeviceOUT,
+   struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hDevCookieInt;
-	IMG_HANDLE hBufClassInfo;
+	void *hDevCookieInt;
+	void *hBufClassInfo;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_OPEN_BUFFERCLASS_DEVICE);
@@ -4004,17 +3766,15 @@
 			       &hDevCookieInt,
 			       psOpenBufferClassDeviceIN->hDevCookie,
 			       PVRSRV_HANDLE_TYPE_DEV_NODE);
-	if (psOpenBufferClassDeviceOUT->eError != PVRSRV_OK) {
+	if (psOpenBufferClassDeviceOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psOpenBufferClassDeviceOUT->eError =
 	    PVRSRVOpenBCDeviceKM(psPerProc,
 				 psOpenBufferClassDeviceIN->ui32DeviceID,
 				 hDevCookieInt, &hBufClassInfo);
-	if (psOpenBufferClassDeviceOUT->eError != PVRSRV_OK) {
+	if (psOpenBufferClassDeviceOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	PVRSRVAllocHandleNR(psPerProc->psHandleBase,
 			    &psOpenBufferClassDeviceOUT->hDeviceKM,
@@ -4028,14 +3788,12 @@
 	return 0;
 }
 
-static int
-PVRSRVCloseBCDeviceBW(IMG_UINT32 ui32BridgeID,
-		      PVRSRV_BRIDGE_IN_CLOSE_BUFFERCLASS_DEVICE *
-		      psCloseBufferClassDeviceIN,
-		      PVRSRV_BRIDGE_RETURN * psRetOUT,
-		      PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVCloseBCDeviceBW(u32 ui32BridgeID,
+   struct PVRSRV_BRIDGE_IN_CLOSE_BUFFERCLASS_DEVICE *psCloseBufferClassDeviceIN,
+   struct PVRSRV_BRIDGE_RETURN *psRetOUT,
+   struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvBufClassInfo;
+	void *pvBufClassInfo;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_CLOSE_BUFFERCLASS_DEVICE);
@@ -4045,15 +3803,13 @@
 			       &pvBufClassInfo,
 			       psCloseBufferClassDeviceIN->hDeviceKM,
 			       PVRSRV_HANDLE_TYPE_BUF_INFO);
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError = PVRSRVCloseBCDeviceKM(pvBufClassInfo, IMG_FALSE);
 
-	if (psRetOUT->eError != PVRSRV_OK) {
+	if (psRetOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psRetOUT->eError = PVRSRVReleaseHandle(psPerProc->psHandleBase,
 					       psCloseBufferClassDeviceIN->
@@ -4063,14 +3819,12 @@
 	return 0;
 }
 
-static int
-PVRSRVGetBCInfoBW(IMG_UINT32 ui32BridgeID,
-		  PVRSRV_BRIDGE_IN_GET_BUFFERCLASS_INFO *
-		  psGetBufferClassInfoIN,
-		  PVRSRV_BRIDGE_OUT_GET_BUFFERCLASS_INFO *
-		  psGetBufferClassInfoOUT, PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVGetBCInfoBW(u32 ui32BridgeID,
+   struct PVRSRV_BRIDGE_IN_GET_BUFFERCLASS_INFO *psGetBufferClassInfoIN,
+   struct PVRSRV_BRIDGE_OUT_GET_BUFFERCLASS_INFO *psGetBufferClassInfoOUT,
+   struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvBufClassInfo;
+	void *pvBufClassInfo;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_GET_BUFFERCLASS_INFO);
@@ -4080,9 +3834,8 @@
 			       &pvBufClassInfo,
 			       psGetBufferClassInfoIN->hDeviceKM,
 			       PVRSRV_HANDLE_TYPE_BUF_INFO);
-	if (psGetBufferClassInfoOUT->eError != PVRSRV_OK) {
+	if (psGetBufferClassInfoOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psGetBufferClassInfoOUT->eError =
 	    PVRSRVGetBCInfoKM(pvBufClassInfo,
@@ -4090,16 +3843,13 @@
 	return 0;
 }
 
-static int
-PVRSRVGetBCBufferBW(IMG_UINT32 ui32BridgeID,
-		    PVRSRV_BRIDGE_IN_GET_BUFFERCLASS_BUFFER *
-		    psGetBufferClassBufferIN,
-		    PVRSRV_BRIDGE_OUT_GET_BUFFERCLASS_BUFFER *
-		    psGetBufferClassBufferOUT,
-		    PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVGetBCBufferBW(u32 ui32BridgeID,
+    struct PVRSRV_BRIDGE_IN_GET_BUFFERCLASS_BUFFER *psGetBufferClassBufferIN,
+    struct PVRSRV_BRIDGE_OUT_GET_BUFFERCLASS_BUFFER *psGetBufferClassBufferOUT,
+    struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_VOID *pvBufClassInfo;
-	IMG_HANDLE hBufferInt;
+	void *pvBufClassInfo;
+	void *hBufferInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_GET_BUFFERCLASS_BUFFER);
@@ -4112,24 +3862,22 @@
 			       &pvBufClassInfo,
 			       psGetBufferClassBufferIN->hDeviceKM,
 			       PVRSRV_HANDLE_TYPE_BUF_INFO);
-	if (psGetBufferClassBufferOUT->eError != PVRSRV_OK) {
+	if (psGetBufferClassBufferOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psGetBufferClassBufferOUT->eError =
 	    PVRSRVGetBCBufferKM(pvBufClassInfo,
 				psGetBufferClassBufferIN->ui32BufferIndex,
 				&hBufferInt);
 
-	if (psGetBufferClassBufferOUT->eError != PVRSRV_OK) {
+	if (psGetBufferClassBufferOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	PVRSRVAllocSubHandleNR(psPerProc->psHandleBase,
 			       &psGetBufferClassBufferOUT->hBuffer,
 			       hBufferInt,
 			       PVRSRV_HANDLE_TYPE_BUF_BUFFER,
-			       (PVRSRV_HANDLE_ALLOC_FLAG)
+			       (enum PVRSRV_HANDLE_ALLOC_FLAG)
 			       (PVRSRV_HANDLE_ALLOC_FLAG_PRIVATE |
 				PVRSRV_HANDLE_ALLOC_FLAG_SHARED),
 			       psGetBufferClassBufferIN->hDeviceKM);
@@ -4140,15 +3888,12 @@
 	return 0;
 }
 
-static int
-PVRSRVAllocSharedSysMemoryBW(IMG_UINT32 ui32BridgeID,
-			     PVRSRV_BRIDGE_IN_ALLOC_SHARED_SYS_MEM *
-			     psAllocSharedSysMemIN,
-			     PVRSRV_BRIDGE_OUT_ALLOC_SHARED_SYS_MEM *
-			     psAllocSharedSysMemOUT,
-			     PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVAllocSharedSysMemoryBW(u32 ui32BridgeID,
+	  struct PVRSRV_BRIDGE_IN_ALLOC_SHARED_SYS_MEM *psAllocSharedSysMemIN,
+	  struct PVRSRV_BRIDGE_OUT_ALLOC_SHARED_SYS_MEM *psAllocSharedSysMemOUT,
+	  struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_ALLOC_SHARED_SYS_MEM);
@@ -4160,21 +3905,19 @@
 					 psAllocSharedSysMemIN->ui32Flags,
 					 psAllocSharedSysMemIN->ui32Size,
 					 &psKernelMemInfo);
-	if (psAllocSharedSysMemOUT->eError != PVRSRV_OK) {
+	if (psAllocSharedSysMemOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	OSMemSet(&psAllocSharedSysMemOUT->sClientMemInfo,
 		 0, sizeof(psAllocSharedSysMemOUT->sClientMemInfo));
 
-	if (psKernelMemInfo->pvLinAddrKM) {
+	if (psKernelMemInfo->pvLinAddrKM)
 		psAllocSharedSysMemOUT->sClientMemInfo.pvLinAddrKM =
 		    psKernelMemInfo->pvLinAddrKM;
-	} else {
+	else
 		psAllocSharedSysMemOUT->sClientMemInfo.pvLinAddrKM =
 		    psKernelMemInfo->sMemBlk.hOSMemHandle;
-	}
-	psAllocSharedSysMemOUT->sClientMemInfo.pvLinAddr = 0;
+	psAllocSharedSysMemOUT->sClientMemInfo.pvLinAddr = NULL;
 	psAllocSharedSysMemOUT->sClientMemInfo.ui32Flags =
 	    psKernelMemInfo->ui32Flags;
 	psAllocSharedSysMemOUT->sClientMemInfo.ui32AllocSize =
@@ -4193,22 +3936,19 @@
 	return 0;
 }
 
-static int
-PVRSRVFreeSharedSysMemoryBW(IMG_UINT32 ui32BridgeID,
-			    PVRSRV_BRIDGE_IN_FREE_SHARED_SYS_MEM *
-			    psFreeSharedSysMemIN,
-			    PVRSRV_BRIDGE_OUT_FREE_SHARED_SYS_MEM *
-			    psFreeSharedSysMemOUT,
-			    PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int PVRSRVFreeSharedSysMemoryBW(u32 ui32BridgeID,
+	    struct PVRSRV_BRIDGE_IN_FREE_SHARED_SYS_MEM *psFreeSharedSysMemIN,
+	    struct PVRSRV_BRIDGE_OUT_FREE_SHARED_SYS_MEM *psFreeSharedSysMemOUT,
+	    struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_FREE_SHARED_SYS_MEM);
 
 	psFreeSharedSysMemOUT->eError =
 	    PVRSRVLookupHandle(psPerProc->psHandleBase,
-			       (IMG_VOID **) & psKernelMemInfo,
+			       (void **) &psKernelMemInfo,
 			       psFreeSharedSysMemIN->psKernelMemInfo,
 			       PVRSRV_HANDLE_TYPE_SHARED_SYS_MEM_INFO);
 
@@ -4227,27 +3967,25 @@
 	return 0;
 }
 
-static int
-PVRSRVMapMemInfoMemBW(IMG_UINT32 ui32BridgeID,
-		      PVRSRV_BRIDGE_IN_MAP_MEMINFO_MEM * psMapMemInfoMemIN,
-		      PVRSRV_BRIDGE_OUT_MAP_MEMINFO_MEM * psMapMemInfoMemOUT,
-		      PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
-	PVRSRV_HANDLE_TYPE eHandleType;
-	IMG_HANDLE hParent;
+static int PVRSRVMapMemInfoMemBW(u32 ui32BridgeID,
+	      struct PVRSRV_BRIDGE_IN_MAP_MEMINFO_MEM *psMapMemInfoMemIN,
+	      struct PVRSRV_BRIDGE_OUT_MAP_MEMINFO_MEM *psMapMemInfoMemOUT,
+	      struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	enum PVRSRV_HANDLE_TYPE eHandleType;
+	void *hParent;
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_MAP_MEMINFO_MEM);
 
 	NEW_HANDLE_BATCH_OR_ERROR(psMapMemInfoMemOUT->eError, psPerProc, 2);
 
 	psMapMemInfoMemOUT->eError =
 	    PVRSRVLookupHandleAnyType(psPerProc->psHandleBase,
-				      (IMG_VOID **) & psKernelMemInfo,
+				      (void **) &psKernelMemInfo,
 				      &eHandleType,
 				      psMapMemInfoMemIN->hKernelMemInfo);
-	if (psMapMemInfoMemOUT->eError != PVRSRV_OK) {
+	if (psMapMemInfoMemOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	switch (eHandleType) {
 	case PVRSRV_HANDLE_TYPE_MEM_INFO:
@@ -4264,25 +4002,22 @@
 				  &hParent,
 				  psMapMemInfoMemIN->hKernelMemInfo,
 				  eHandleType);
-	if (psMapMemInfoMemOUT->eError != PVRSRV_OK) {
+	if (psMapMemInfoMemOUT->eError != PVRSRV_OK)
 		return 0;
-	}
-	if (hParent == IMG_NULL) {
+	if (hParent == NULL)
 		hParent = psMapMemInfoMemIN->hKernelMemInfo;
-	}
 
 	OSMemSet(&psMapMemInfoMemOUT->sClientMemInfo,
 		 0, sizeof(psMapMemInfoMemOUT->sClientMemInfo));
 
-	if (psKernelMemInfo->pvLinAddrKM) {
+	if (psKernelMemInfo->pvLinAddrKM)
 		psMapMemInfoMemOUT->sClientMemInfo.pvLinAddrKM =
 		    psKernelMemInfo->pvLinAddrKM;
-	} else {
+	else
 		psMapMemInfoMemOUT->sClientMemInfo.pvLinAddrKM =
 		    psKernelMemInfo->sMemBlk.hOSMemHandle;
-	}
 
-	psMapMemInfoMemOUT->sClientMemInfo.pvLinAddr = 0;
+	psMapMemInfoMemOUT->sClientMemInfo.pvLinAddr = NULL;
 	psMapMemInfoMemOUT->sClientMemInfo.sDevVAddr =
 	    psKernelMemInfo->sDevVAddr;
 	psMapMemInfoMemOUT->sClientMemInfo.ui32Flags =
@@ -4301,8 +4036,8 @@
 	if (psKernelMemInfo->ui32Flags & PVRSRV_MEM_NO_SYNCOBJ) {
 
 		OSMemSet(&psMapMemInfoMemOUT->sClientSyncInfo,
-			 0, sizeof(PVRSRV_CLIENT_SYNC_INFO));
-		psMapMemInfoMemOUT->psKernelSyncInfo = IMG_NULL;
+			 0, sizeof(struct PVRSRV_CLIENT_SYNC_INFO));
+		psMapMemInfoMemOUT->psKernelSyncInfo = NULL;
 	} else {
 
 		psMapMemInfoMemOUT->sClientSyncInfo.psSyncData =
@@ -4335,13 +4070,12 @@
 	return 0;
 }
 
-static int
-MMU_GetPDDevPAddrBW(IMG_UINT32 ui32BridgeID,
-		    PVRSRV_BRIDGE_IN_GETMMU_PD_DEVPADDR * psGetMmuPDDevPAddrIN,
-		    PVRSRV_BRIDGE_OUT_GETMMU_PD_DEVPADDR *
-		    psGetMmuPDDevPAddrOUT, PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int MMU_GetPDDevPAddrBW(u32 ui32BridgeID,
+	    struct PVRSRV_BRIDGE_IN_GETMMU_PD_DEVPADDR *psGetMmuPDDevPAddrIN,
+	    struct PVRSRV_BRIDGE_OUT_GETMMU_PD_DEVPADDR *psGetMmuPDDevPAddrOUT,
+	    struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	IMG_HANDLE hDevMemContextInt;
+	void *hDevMemContextInt;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID,
 				 PVRSRV_BRIDGE_GETMMU_PD_DEVPADDR);
@@ -4350,25 +4084,21 @@
 	    PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevMemContextInt,
 			       psGetMmuPDDevPAddrIN->hDevMemContext,
 			       PVRSRV_HANDLE_TYPE_DEV_MEM_CONTEXT);
-	if (psGetMmuPDDevPAddrOUT->eError != PVRSRV_OK) {
+	if (psGetMmuPDDevPAddrOUT->eError != PVRSRV_OK)
 		return 0;
-	}
 
 	psGetMmuPDDevPAddrOUT->sPDDevPAddr =
 	    MMU_GetPDDevPAddr(BM_GetMMUContextFromMemContext
 			      (hDevMemContextInt));
-	if (psGetMmuPDDevPAddrOUT->sPDDevPAddr.uiAddr) {
+	if (psGetMmuPDDevPAddrOUT->sPDDevPAddr.uiAddr)
 		psGetMmuPDDevPAddrOUT->eError = PVRSRV_OK;
-	} else {
+	else
 		psGetMmuPDDevPAddrOUT->eError = PVRSRV_ERROR_GENERIC;
-	}
 	return 0;
 }
 
-static int
-DummyBW(IMG_UINT32 ui32BridgeID,
-	IMG_VOID * psBridgeIn,
-	IMG_VOID * psBridgeOut, PVRSRV_PER_PROCESS_DATA * psPerProc)
+static int DummyBW(u32 ui32BridgeID, void *psBridgeIn,
+	void *psBridgeOut, struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
 #if !defined(DEBUG)
 	PVR_UNREFERENCED_PARAMETER(ui32BridgeID);
@@ -4378,28 +4108,34 @@
 	PVR_UNREFERENCED_PARAMETER(psPerProc);
 
 #if defined(DEBUG_BRIDGE_KM)
-	PVR_DPF((PVR_DBG_ERROR, "%s: BRIDGE ERROR: BridgeID %lu (%s) mapped to "
+	PVR_DPF(PVR_DBG_ERROR, "%s: BRIDGE ERROR: BridgeID %lu (%s) mapped to "
 		 "Dummy Wrapper (probably not what you want!)",
-		 __FUNCTION__, ui32BridgeID,
-		 g_BridgeDispatchTable[ui32BridgeID].pszIOCName));
+		 __func__, ui32BridgeID,
+		 g_BridgeDispatchTable[ui32BridgeID].pszIOCName);
 #else
-	PVR_DPF((PVR_DBG_ERROR, "%s: BRIDGE ERROR: BridgeID %lu mapped to "
+	PVR_DPF(PVR_DBG_ERROR, "%s: BRIDGE ERROR: BridgeID %lu mapped to "
 		 "Dummy Wrapper (probably not what you want!)",
-		 __FUNCTION__, ui32BridgeID));
+		 __func__, ui32BridgeID);
 #endif
 	return -ENOTTY;
 }
 
-#define SetDispatchTableEntry(ui32Index, pfFunction) \
-	_SetDispatchTableEntry(PVRSRV_GET_BRIDGE_ID(ui32Index), #ui32Index, (BridgeWrapperFunction)pfFunction, #pfFunction)
+#define SetDispatchTableEntry(ui32Index, pfFunction)			    \
+	_SetDispatchTableEntry(PVRSRV_GET_BRIDGE_ID(ui32Index), #ui32Index, \
+			(int (*)(u32 ui32BridgeID, void *psBridgeIn,        \
+				 void *psBridgeOut,			    \
+				 struct PVRSRV_PER_PROCESS_DATA *psPerProc))\
+			pfFunction, #pfFunction)
+
 #define DISPATCH_TABLE_GAP_THRESHOLD 5
-static IMG_VOID
-_SetDispatchTableEntry(IMG_UINT32 ui32Index,
-		       const IMG_CHAR * pszIOCName,
-		       BridgeWrapperFunction pfFunction,
-		       const IMG_CHAR * pszFunctionName)
+
+static void _SetDispatchTableEntry(u32 ui32Index, const char *pszIOCName,
+		       int (*pfFunction)(u32 ui32BridgeID, void *psBridgeIn,
+		       void *psBridgeOut,
+		       struct PVRSRV_PER_PROCESS_DATA *psPerProc),
+		       const char *pszFunctionName)
 {
-	static IMG_UINT32 ui32PrevIndex = ~0UL;
+	static u32 ui32PrevIndex = ~0UL;
 #if !defined(DEBUG)
 	PVR_UNREFERENCED_PARAMETER(pszIOCName);
 #endif
@@ -4410,37 +4146,43 @@
 
 	if (g_BridgeDispatchTable[ui32Index].pfFunction) {
 #if defined(DEBUG_BRIDGE_KM)
-		PVR_DPF((PVR_DBG_ERROR,
-			 "%s: BUG!: Adding dispatch table entry for %s clobbers an existing entry for %s",
-			 __FUNCTION__, pszIOCName,
-			 g_BridgeDispatchTable[ui32Index].pszIOCName));
+		PVR_DPF(PVR_DBG_ERROR, "%s: BUG!: "
+			"Adding dispatch table entry for %s "
+			"clobbers an existing entry for %s",
+			 __func__, pszIOCName,
+			 g_BridgeDispatchTable[ui32Index].pszIOCName);
 #else
-		PVR_DPF((PVR_DBG_ERROR,
-			 "%s: BUG!: Adding dispatch table entry for %s clobbers an existing entry (index=%lu)",
-			 __FUNCTION__, pszIOCName, ui32Index));
+		PVR_DPF(PVR_DBG_ERROR, "%s: BUG!: "
+			"Adding dispatch table entry for %s "
+			"clobbers an existing entry (index=%lu)",
+			 __func__, pszIOCName, ui32Index);
 #endif
-		PVR_DPF((PVR_DBG_ERROR,
-			 "NOTE: Enabling DEBUG_BRIDGE_KM_DISPATCH_TABLE may help debug this issue.",
-			 __FUNCTION__));
+		PVR_DPF(PVR_DBG_ERROR, "NOTE: "
+			"Enabling DEBUG_BRIDGE_KM_DISPATCH_TABLE "
+			"may help debug this issue.",
+			 __func__);
 	}
 
 	if ((ui32PrevIndex != ~0UL) &&
 	    ((ui32Index >= ui32PrevIndex + DISPATCH_TABLE_GAP_THRESHOLD) ||
 	     (ui32Index <= ui32PrevIndex))) {
 #if defined(DEBUG_BRIDGE_KM)
-		PVR_DPF((PVR_DBG_WARNING,
-			 "%s: There is a gap in the dispatch table between indices %lu (%s) and %lu (%s)",
-			 __FUNCTION__, ui32PrevIndex,
+		PVR_DPF(PVR_DBG_WARNING,
+			 "%s: There is a gap in the dispatch table "
+			 "between indices %lu (%s) and %lu (%s)",
+			 __func__, ui32PrevIndex,
 			 g_BridgeDispatchTable[ui32PrevIndex].pszIOCName,
-			 ui32Index, pszIOCName));
+			 ui32Index, pszIOCName);
 #else
-		PVR_DPF((PVR_DBG_WARNING,
-			 "%s: There is a gap in the dispatch table between indices %lu and %lu (%s)",
-			 __FUNCTION__, ui32PrevIndex, ui32Index, pszIOCName));
+		PVR_DPF(PVR_DBG_WARNING,
+			 "%s: There is a gap in the dispatch table "
+			 "between indices %lu and %lu (%s)",
+			 __func__, ui32PrevIndex, ui32Index, pszIOCName);
 #endif
-		PVR_DPF((PVR_DBG_ERROR,
-			 "NOTE: Enabling DEBUG_BRIDGE_KM_DISPATCH_TABLE may help debug this issue.",
-			 __FUNCTION__));
+		PVR_DPF(PVR_DBG_ERROR, "NOTE: "
+			"Enabling DEBUG_BRIDGE_KM_DISPATCH_TABLE "
+			"may help debug this issue.",
+			 __func__);
 	}
 
 	g_BridgeDispatchTable[ui32Index].pfFunction = pfFunction;
@@ -4454,9 +4196,9 @@
 	ui32PrevIndex = ui32Index;
 }
 
-PVRSRV_ERROR CommonBridgeInit(IMG_VOID)
+enum PVRSRV_ERROR CommonBridgeInit(void)
 {
-	IMG_UINT32 i;
+	u32 i;
 
 	SetDispatchTableEntry(PVRSRV_BRIDGE_ENUM_DEVICES,
 			      PVRSRVEnumerateDevicesBW);
@@ -4661,7 +4403,7 @@
 	SetDispatchTableEntry(PVRSRV_BRIDGE_SGX_READ_DIFF_COUNTERS,
 			      SGXReadDiffCountersBW);
 
-	for (i = 0; i < BRIDGE_DISPATCH_TABLE_ENTRY_COUNT; i++) {
+	for (i = 0; i < BRIDGE_DISPATCH_TABLE_ENTRY_COUNT; i++)
 		if (!g_BridgeDispatchTable[i].pfFunction) {
 			g_BridgeDispatchTable[i].pfFunction = DummyBW;
 #if defined(DEBUG_BRIDGE_KM)
@@ -4673,55 +4415,60 @@
 			g_BridgeDispatchTable[i].ui32CopyToUserTotalBytes = 0;
 #endif
 		}
-	}
 
 	return PVRSRV_OK;
 }
 
-int BridgedDispatchKM(PVRSRV_PER_PROCESS_DATA * psPerProc,
-		      PVRSRV_BRIDGE_PACKAGE * psBridgePackageKM)
+int BridgedDispatchKM(struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+		      struct PVRSRV_BRIDGE_PACKAGE *psBridgePackageKM)
 {
 
-	IMG_VOID *psBridgeIn;
-	IMG_VOID *psBridgeOut;
-	BridgeWrapperFunction pfBridgeHandler;
-	IMG_UINT32 ui32BridgeID = psBridgePackageKM->ui32BridgeID;
+	void *psBridgeIn;
+	void *psBridgeOut;
+	int (*pfBridgeHandler)(u32 ui32BridgeID,
+			      void *psBridgeIn,
+			      void *psBridgeOut,
+			      struct PVRSRV_PER_PROCESS_DATA *psPerProc);
+	u32 ui32BridgeID = psBridgePackageKM->ui32BridgeID;
 	int err = -EFAULT;
 
-
 #if defined(DEBUG_BRIDGE_KM)
 	g_BridgeDispatchTable[ui32BridgeID].ui32CallCount++;
 	g_BridgeGlobalStats.ui32IOCTLCount++;
 #endif
-
 	if (!psPerProc->bInitProcess) {
 		if (PVRSRVGetInitServerState(PVRSRV_INIT_SERVER_RAN)) {
 			if (!PVRSRVGetInitServerState
 			    (PVRSRV_INIT_SERVER_SUCCESSFUL)) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "%s: Initialisation failed.  Driver unusable.",
-					 __FUNCTION__));
+				PVR_DPF(PVR_DBG_ERROR,
+					 "%s: Initialisation failed.  "
+					 "Driver unusable.",
+					 __func__);
 				goto return_fault;
 			}
 		} else {
 			if (PVRSRVGetInitServerState
 			    (PVRSRV_INIT_SERVER_RUNNING)) {
-				PVR_DPF((PVR_DBG_ERROR,
+				PVR_DPF(PVR_DBG_ERROR,
 					 "%s: Initialisation is in progress",
-					 __FUNCTION__));
+					 __func__);
 				goto return_fault;
 			} else {
-
 				switch (ui32BridgeID) {
-				case PVRSRV_GET_BRIDGE_ID(PVRSRV_BRIDGE_CONNECT_SERVICES):
-				case PVRSRV_GET_BRIDGE_ID(PVRSRV_BRIDGE_DISCONNECT_SERVICES):
-				case PVRSRV_GET_BRIDGE_ID(PVRSRV_BRIDGE_INITSRV_CONNECT):
-				case PVRSRV_GET_BRIDGE_ID(PVRSRV_BRIDGE_INITSRV_DISCONNECT):
+				case PVRSRV_GET_BRIDGE_ID(
+					PVRSRV_BRIDGE_CONNECT_SERVICES):
+				case PVRSRV_GET_BRIDGE_ID(
+					PVRSRV_BRIDGE_DISCONNECT_SERVICES):
+				case PVRSRV_GET_BRIDGE_ID(
+					PVRSRV_BRIDGE_INITSRV_CONNECT):
+				case PVRSRV_GET_BRIDGE_ID(
+					PVRSRV_BRIDGE_INITSRV_DISCONNECT):
 					break;
 				default:
-					PVR_DPF((PVR_DBG_ERROR,
-						 "%s: Driver initialisation not completed yet.",
-						 __FUNCTION__));
+					PVR_DPF(PVR_DBG_ERROR,
+						 "%s: Driver initialisation "
+						 "not completed yet.",
+						 __func__);
 					goto return_fault;
 				}
 			}
@@ -4729,62 +4476,54 @@
 	}
 
 	{
+		struct SYS_DATA *psSysData;
 
-		SYS_DATA *psSysData;
-
-		if (SysAcquireData(&psSysData) != PVRSRV_OK) {
+		if (SysAcquireData(&psSysData) != PVRSRV_OK)
 			goto return_fault;
-		}
 
-		psBridgeIn =
-		    ((ENV_DATA *) psSysData->pvEnvSpecificData)->pvBridgeData;
-		psBridgeOut =
-		    (IMG_PVOID) ((IMG_PBYTE) psBridgeIn +
+		psBridgeIn = ((struct ENV_DATA *)
+				psSysData->pvEnvSpecificData)->pvBridgeData;
+		psBridgeOut = (void *)((u8 *)psBridgeIn +
 				 PVRSRV_MAX_BRIDGE_IN_SIZE);
 
 		if (psBridgePackageKM->ui32InBufferSize > 0) {
 			if (!OSAccessOK(PVR_VERIFY_READ,
 					psBridgePackageKM->pvParamIn,
-					psBridgePackageKM->ui32InBufferSize)) {
-				PVR_DPF((PVR_DBG_ERROR,
+					psBridgePackageKM->ui32InBufferSize))
+				PVR_DPF(PVR_DBG_ERROR,
 					 "%s: Invalid pvParamIn pointer",
-					 __FUNCTION__));
-			}
+					 __func__);
 
-			if (CopyFromUserWrapper(psPerProc,
-						ui32BridgeID,
-						psBridgeIn,
-						psBridgePackageKM->pvParamIn,
-						psBridgePackageKM->
-						ui32InBufferSize)
-			    != PVRSRV_OK) {
+			if (CopyFromUserWrapper(psPerProc, ui32BridgeID,
+					psBridgeIn,
+					psBridgePackageKM->pvParamIn,
+					psBridgePackageKM->ui32InBufferSize)
+			    != PVRSRV_OK)
 				goto return_fault;
-			}
 		}
 	}
 
 	if (ui32BridgeID >= (BRIDGE_DISPATCH_TABLE_ENTRY_COUNT)) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "%s: ui32BridgeID = %d is out if range!", __FUNCTION__,
-			 ui32BridgeID));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "%s: ui32BridgeID = %d is out if range!", __func__,
+			 ui32BridgeID);
 		goto return_fault;
 	}
-	pfBridgeHandler =
-	    (BridgeWrapperFunction) g_BridgeDispatchTable[ui32BridgeID].
-	    pfFunction;
+	pfBridgeHandler = (int (*)(u32 ui32BridgeID, void *psBridgeIn,
+				   void *psBridgeOut,
+				   struct PVRSRV_PER_PROCESS_DATA *psPerProc))
+			   g_BridgeDispatchTable[ui32BridgeID].pfFunction;
 	err = pfBridgeHandler(ui32BridgeID, psBridgeIn, psBridgeOut, psPerProc);
-	if (err < 0) {
+	if (err < 0)
 		goto return_fault;
-	}
 
 
 	if (CopyToUserWrapper(psPerProc,
 			      ui32BridgeID,
 			      psBridgePackageKM->pvParamOut,
 			      psBridgeOut, psBridgePackageKM->ui32OutBufferSize)
-	    != PVRSRV_OK) {
+	    != PVRSRV_OK)
 		goto return_fault;
-	}
 
 	err = 0;
 return_fault:
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/bridged_pvr_bridge.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/bridged_pvr_bridge.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -29,44 +29,38 @@
 
 #include "pvr_bridge.h"
 
-
 #define PVRSRV_GET_BRIDGE_ID(X)	_IOC_NR(X)
 
-	typedef int (*BridgeWrapperFunction) (IMG_UINT32 ui32BridgeID,
-					      IMG_VOID * psBridgeIn,
-					      IMG_VOID * psBridgeOut,
-					      PVRSRV_PER_PROCESS_DATA *
-					      psPerProc);
-
-	typedef struct _PVRSRV_BRIDGE_DISPATCH_TABLE_ENTRY {
-		BridgeWrapperFunction pfFunction;
+struct PVRSRV_BRIDGE_DISPATCH_TABLE_ENTRY {
+	int (*pfFunction)(u32 ui32BridgeID, void *psBridgeIn, void *psBridgeOut,
+			  struct PVRSRV_PER_PROCESS_DATA *psPerProc);
 #if defined(DEBUG_BRIDGE_KM)
-		const IMG_CHAR *pszIOCName;
-		const IMG_CHAR *pszFunctionName;
-		IMG_UINT32 ui32CallCount;
-		IMG_UINT32 ui32CopyFromUserTotalBytes;
-		IMG_UINT32 ui32CopyToUserTotalBytes;
+	const char *pszIOCName;
+	const char *pszFunctionName;
+	u32 ui32CallCount;
+	u32 ui32CopyFromUserTotalBytes;
+	u32 ui32CopyToUserTotalBytes;
 #endif
-	} PVRSRV_BRIDGE_DISPATCH_TABLE_ENTRY;
+};
 
 #define BRIDGE_DISPATCH_TABLE_ENTRY_COUNT (PVRSRV_BRIDGE_LAST_SGX_CMD+1)
 
-	extern PVRSRV_BRIDGE_DISPATCH_TABLE_ENTRY
+extern struct PVRSRV_BRIDGE_DISPATCH_TABLE_ENTRY
 	    g_BridgeDispatchTable[BRIDGE_DISPATCH_TABLE_ENTRY_COUNT];
 
 #if defined(DEBUG_BRIDGE_KM)
-	typedef struct _PVRSRV_BRIDGE_GLOBAL_STATS {
-		IMG_UINT32 ui32IOCTLCount;
-		IMG_UINT32 ui32TotalCopyFromUserBytes;
-		IMG_UINT32 ui32TotalCopyToUserBytes;
-	} PVRSRV_BRIDGE_GLOBAL_STATS;
+struct PVRSRV_BRIDGE_GLOBAL_STATS {
+	u32 ui32IOCTLCount;
+	u32 ui32TotalCopyFromUserBytes;
+	u32 ui32TotalCopyToUserBytes;
+};
 
-	extern PVRSRV_BRIDGE_GLOBAL_STATS g_BridgeGlobalStats;
+extern struct PVRSRV_BRIDGE_GLOBAL_STATS g_BridgeGlobalStats;
 #endif
 
-	PVRSRV_ERROR CommonBridgeInit(IMG_VOID);
+enum PVRSRV_ERROR CommonBridgeInit(void);
 
-	int BridgedDispatchKM(PVRSRV_PER_PROCESS_DATA * psPerProc,
-			      PVRSRV_BRIDGE_PACKAGE * psBridgePackageKM);
+int BridgedDispatchKM(struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+		      struct PVRSRV_BRIDGE_PACKAGE *psBridgePackageKM);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/buffer_manager.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/buffer_manager.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 #include "services_headers.h"
@@ -31,46 +31,41 @@
 #include "pdump_km.h"
 
 #include <linux/kernel.h>
+#include <linux/mm.h>
 
-#define MIN(a,b)       (a > b ? b : a)
+#define MIN(a, b)       (a > b ? b : a)
 
-static IMG_BOOL
-ZeroBuf(BM_BUF * pBuf, BM_MAPPING * pMapping, IMG_UINT32 ui32Bytes,
-	IMG_UINT32 ui32Flags);
-static void BM_FreeMemory(void *pH, IMG_UINTPTR_T base, BM_MAPPING * psMapping);
-static IMG_BOOL
-BM_ImportMemory(void *pH, IMG_SIZE_T uSize,
-		IMG_SIZE_T * pActualSize, BM_MAPPING ** ppsMapping,
-		IMG_UINT32 uFlags, IMG_UINTPTR_T * pBase);
-
-static IMG_BOOL
-DevMemoryAlloc(BM_CONTEXT * pBMContext,
-	       BM_MAPPING * pMapping,
-	       IMG_SIZE_T * pActualSize,
-	       IMG_UINT32 uFlags,
-	       IMG_UINT32 dev_vaddr_alignment, IMG_DEV_VIRTADDR * pDevVAddr);
-static void DevMemoryFree(BM_MAPPING * pMapping);
-
-static IMG_BOOL
-AllocMemory(BM_CONTEXT * pBMContext,
-	    BM_HEAP * psBMHeap,
-	    IMG_DEV_VIRTADDR * psDevVAddr,
-	    IMG_SIZE_T uSize,
-	    IMG_UINT32 uFlags, IMG_UINT32 uDevVAddrAlignment, BM_BUF * pBuf)
-{
-	BM_MAPPING *pMapping;
-	IMG_UINTPTR_T uOffset;
-	RA_ARENA *pArena = IMG_NULL;
-
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "AllocMemory (pBMContext=%08X, uSize=0x%x, uFlags=0x%x, align=0x%x, pBuf=%08X)",
-		 pBMContext, uSize, uFlags, uDevVAddrAlignment, pBuf));
+static IMG_BOOL ZeroBuf(struct BM_BUF *pBuf, struct BM_MAPPING *pMapping,
+		u32 ui32Bytes, u32 ui32Flags);
+static void BM_FreeMemory(void *pH, u32 base, struct BM_MAPPING *psMapping);
+static IMG_BOOL BM_ImportMemory(void *pH, size_t uSize,
+		size_t *pActualSize, struct BM_MAPPING **ppsMapping, u32 uFlags,
+		u32 *pBase);
+
+static IMG_BOOL DevMemoryAlloc(struct BM_CONTEXT *pBMContext,
+		struct BM_MAPPING *pMapping, size_t *pActualSize, u32 uFlags,
+		u32 dev_vaddr_alignment, struct IMG_DEV_VIRTADDR *pDevVAddr);
+static void DevMemoryFree(struct BM_MAPPING *pMapping);
+
+static IMG_BOOL AllocMemory(struct BM_CONTEXT *pBMContext,
+		struct BM_HEAP *psBMHeap, struct IMG_DEV_VIRTADDR *psDevVAddr,
+		size_t uSize, u32 uFlags, u32 uDevVAddrAlignment,
+		struct BM_BUF *pBuf)
+{
+	struct BM_MAPPING *pMapping;
+	u32 uOffset;
+	struct RA_ARENA *pArena = NULL;
+
+	PVR_DPF(PVR_DBG_MESSAGE, "AllocMemory (pBMContext=%08X, uSize=0x%x,"
+		 " uFlags=0x%x, align=0x%x, pBuf=%08X)",
+		 pBMContext, uSize, uFlags, uDevVAddrAlignment, pBuf);
 
 	if (uFlags & PVRSRV_MEM_RAM_BACKED_ALLOCATION) {
 		if (uFlags & PVRSRV_MEM_USER_SUPPLIED_DEVVADDR) {
 
-			PVR_DPF((PVR_DBG_ERROR,
-				 "AllocMemory: combination of DevVAddr management and RAM backing mode unsupported"));
+			PVR_DPF(PVR_DBG_ERROR, "AllocMemory: "
+				"combination of DevVAddr management "
+				"and RAM backing mode unsupported");
 			return IMG_FALSE;
 		}
 
@@ -80,97 +75,87 @@
 
 			pArena = psBMHeap->pImportArena;
 		} else {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "AllocMemory: backing store type doesn't match heap"));
+			PVR_DPF(PVR_DBG_ERROR, "AllocMemory: backing "
+					"store type doesn't match heap");
 			return IMG_FALSE;
 		}
 
 		if (!RA_Alloc(pArena,
 			      uSize,
-			      IMG_NULL,
+			      NULL,
 			      (void *)&pMapping,
 			      uFlags,
 			      uDevVAddrAlignment,
-			      0, (IMG_UINTPTR_T *) & (pBuf->DevVAddr.uiAddr))) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "AllocMemory: RA_Alloc(0x%x) FAILED", uSize));
+			      0, (u32 *) &(pBuf->DevVAddr.uiAddr))) {
+			PVR_DPF(PVR_DBG_ERROR,
+				 "AllocMemory: RA_Alloc(0x%x) FAILED", uSize);
 			return IMG_FALSE;
 		}
 
 		uOffset = pBuf->DevVAddr.uiAddr - pMapping->DevVAddr.uiAddr;
-		if (pMapping->CpuVAddr) {
+		if (pMapping->CpuVAddr)
 			pBuf->CpuVAddr =
-			    (void *)((IMG_UINTPTR_T) pMapping->CpuVAddr +
+			    (void *)((u32) pMapping->CpuVAddr +
 				     uOffset);
-		} else {
-			pBuf->CpuVAddr = IMG_NULL;
-		}
+		else
+			pBuf->CpuVAddr = NULL;
 
 		if (uSize == pMapping->uSize) {
 			pBuf->hOSMemHandle = pMapping->hOSMemHandle;
 		} else {
-			if (OSGetSubMemHandle(pMapping->hOSMemHandle,
-					      uOffset,
-					      uSize,
-					      psBMHeap->ui32Attribs,
-					      &pBuf->hOSMemHandle) != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,
-					 "AllocMemory: OSGetSubMemHandle FAILED"));
+			if (OSGetSubMemHandle(pMapping->hOSMemHandle, uOffset,
+					uSize, psBMHeap->ui32Attribs,
+					&pBuf->hOSMemHandle) != PVRSRV_OK) {
+				PVR_DPF(PVR_DBG_ERROR, "AllocMemory: "
+						"OSGetSubMemHandle FAILED");
 				return IMG_FALSE;
 			}
 		}
 
 		pBuf->CpuPAddr = pMapping->CpuPAddr;
 
-		if (uFlags & PVRSRV_MEM_ZERO) {
+		if (uFlags & PVRSRV_MEM_ZERO)
 			if (!ZeroBuf
 			    (pBuf, pMapping, uSize,
-			     psBMHeap->ui32Attribs | uFlags)) {
+			     psBMHeap->ui32Attribs | uFlags))
 				return IMG_FALSE;
-			}
-		}
 	} else {
 		if (uFlags & PVRSRV_MEM_USER_SUPPLIED_DEVVADDR) {
 
-			PVR_ASSERT(psDevVAddr != IMG_NULL);
+			PVR_ASSERT(psDevVAddr != NULL);
 
 			pBMContext->psDeviceNode->pfnMMUAlloc(psBMHeap->
-							      pMMUHeap, uSize,
-							      IMG_NULL,
-							      PVRSRV_MEM_USER_SUPPLIED_DEVVADDR,
-							      uDevVAddrAlignment,
-							      psDevVAddr);
-
+					      pMMUHeap, uSize, NULL,
+					      PVRSRV_MEM_USER_SUPPLIED_DEVVADDR,
+					      uDevVAddrAlignment, psDevVAddr);
 			pBuf->DevVAddr = *psDevVAddr;
 		} else {
 
 			pBMContext->psDeviceNode->pfnMMUAlloc(psBMHeap->
-							      pMMUHeap, uSize,
-							      IMG_NULL, 0,
-							      uDevVAddrAlignment,
-							      &pBuf->DevVAddr);
+							     pMMUHeap, uSize,
+							     NULL, 0,
+							     uDevVAddrAlignment,
+							     &pBuf->DevVAddr);
 		}
 
 		if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-			       sizeof(struct _BM_MAPPING_),
-			       (IMG_PVOID *) & pMapping, IMG_NULL) != PVRSRV_OK)
-		{
-			PVR_DPF((PVR_DBG_ERROR,
-				 "AllocMemory: OSAllocMem(0x%x) FAILED"));
+			       sizeof(struct BM_MAPPING),
+			       (void **) &pMapping, NULL) != PVRSRV_OK) {
+			PVR_DPF(PVR_DBG_ERROR,
+				 "AllocMemory: OSAllocMem(0x%x) FAILED");
 			return IMG_FALSE;
 		}
 
-		pBuf->CpuVAddr = IMG_NULL;
-		pBuf->hOSMemHandle = 0;
+		pBuf->CpuVAddr = NULL;
+		pBuf->hOSMemHandle = NULL;
 		pBuf->CpuPAddr.uiAddr = 0;
 
-		pMapping->CpuVAddr = IMG_NULL;
+		pMapping->CpuVAddr = NULL;
 		pMapping->CpuPAddr.uiAddr = 0;
 		pMapping->DevVAddr = pBuf->DevVAddr;
-		pMapping->psSysAddr = IMG_NULL;
+		pMapping->psSysAddr = NULL;
 		pMapping->uSize = uSize;
-		pMapping->hOSMemHandle = 0;
+		pMapping->hOSMemHandle = NULL;
 	}
 
 	pMapping->pArena = pArena;
@@ -178,54 +163,49 @@
 	pMapping->pBMHeap = psBMHeap;
 	pBuf->pMapping = pMapping;
 
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "AllocMemory: pMapping=%08X: DevV=%08X CpuV=%08X CpuP=%08X uSize=0x%x",
-		 pMapping,
-		 pMapping->DevVAddr.uiAddr,
-		 pMapping->CpuVAddr,
-		 pMapping->CpuPAddr.uiAddr, pMapping->uSize));
-
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "AllocMemory: pBuf=%08X: DevV=%08X CpuV=%08X CpuP=%08X uSize=0x%x",
-		 pBuf,
-		 pBuf->DevVAddr.uiAddr,
-		 pBuf->CpuVAddr, pBuf->CpuPAddr.uiAddr, uSize));
+	PVR_DPF(PVR_DBG_MESSAGE, "AllocMemory: "
+		 "pMapping=%08X: DevV=%08X CpuV=%08X CpuP=%08X uSize=0x%x",
+		 pMapping, pMapping->DevVAddr.uiAddr, pMapping->CpuVAddr,
+		 pMapping->CpuPAddr.uiAddr, pMapping->uSize);
+
+	PVR_DPF(PVR_DBG_MESSAGE, "AllocMemory: "
+		 "pBuf=%08X: DevV=%08X CpuV=%08X CpuP=%08X uSize=0x%x",
+		 pBuf, pBuf->DevVAddr.uiAddr, pBuf->CpuVAddr,
+		 pBuf->CpuPAddr.uiAddr, uSize);
 
 	PVR_ASSERT(((pBuf->DevVAddr.uiAddr) & (uDevVAddrAlignment - 1)) == 0);
 
 	return IMG_TRUE;
 }
 
-static IMG_BOOL
-WrapMemory(BM_HEAP * psBMHeap,
-	   IMG_SIZE_T uSize,
-	   IMG_UINT32 ui32BaseOffset,
-	   IMG_BOOL bPhysContig,
-	   IMG_SYS_PHYADDR * psAddr,
-	   IMG_VOID * pvCPUVAddr, IMG_UINT32 uFlags, BM_BUF * pBuf)
+static IMG_BOOL WrapMemory(struct BM_HEAP *psBMHeap,
+	   size_t uSize, u32 ui32BaseOffset, IMG_BOOL bPhysContig,
+	   struct IMG_SYS_PHYADDR *psAddr, void *pvCPUVAddr, u32 uFlags,
+	   struct BM_BUF *pBuf)
 {
-	IMG_DEV_VIRTADDR DevVAddr = { 0 };
-	BM_MAPPING *pMapping;
+	struct IMG_DEV_VIRTADDR DevVAddr = { 0 };
+	struct BM_MAPPING *pMapping;
 	IMG_BOOL bResult;
-	IMG_UINT32 const ui32PageSize = HOST_PAGESIZE();
+	u32 const ui32PageSize = HOST_PAGESIZE();
 
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "WrapMemory(psBMHeap=%08X, size=0x%x, offset=0x%x, bPhysContig=0x%x, pvCPUVAddr = 0x%x, flags=0x%x, pBuf=%08X)",
+	PVR_DPF(PVR_DBG_MESSAGE,
+		 "WrapMemory(psBMHeap=%08X, size=0x%x, offset=0x%x, "
+		 "bPhysContig=0x%x, pvCPUVAddr = 0x%x, flags=0x%x, pBuf=%08X)",
 		 psBMHeap, uSize, ui32BaseOffset, bPhysContig, pvCPUVAddr,
-		 uFlags, pBuf));
+		 uFlags, pBuf);
 
 	PVR_ASSERT((psAddr->uiAddr & (ui32PageSize - 1)) == 0);
 
-	PVR_ASSERT(((IMG_UINT32) pvCPUVAddr & (ui32PageSize - 1)) == 0);
+	PVR_ASSERT(((u32) pvCPUVAddr & (ui32PageSize - 1)) == 0);
 
 	uSize += ui32BaseOffset;
 	uSize = HOST_PAGEALIGN(uSize);
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 		       sizeof(*pMapping),
-		       (IMG_PVOID *) & pMapping, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR, "WrapMemory: OSAllocMem(0x%x) FAILED",
-			 sizeof(*pMapping)));
+		       (void **) &pMapping, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "WrapMemory: OSAllocMem(0x%x) FAILED",
+			 sizeof(*pMapping));
 		return IMG_FALSE;
 	}
 
@@ -242,15 +222,14 @@
 			pMapping->CpuPAddr = SysSysPAddrToCpuPAddr(psAddr[0]);
 
 			if (OSRegisterMem(pMapping->CpuPAddr,
-					  pMapping->CpuVAddr,
-					  pMapping->uSize,
-					  uFlags,
-					  &pMapping->hOSMemHandle) != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,
-					 "WrapMemory: OSRegisterMem Phys=0x%08X, CpuVAddr = 0x%08X, Size=%d) failed",
+					pMapping->CpuVAddr, pMapping->uSize,
+					uFlags,
+					&pMapping->hOSMemHandle) != PVRSRV_OK) {
+				PVR_DPF(PVR_DBG_ERROR, "WrapMemory: "
+					"OSRegisterMem Phys=0x%08X, "
+					"CpuVAddr = 0x%08X, Size=%d) failed",
 					 pMapping->CpuPAddr, pMapping->CpuVAddr,
-					 pMapping->uSize));
+					 pMapping->uSize);
 				goto fail_cleanup;
 			}
 		} else {
@@ -264,9 +243,10 @@
 						   uFlags,
 						   &pMapping->hOSMemHandle) !=
 			    PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "WrapMemory: OSRegisterDiscontigMem CpuVAddr = 0x%08X, Size=%d) failed",
-					 pMapping->CpuVAddr, pMapping->uSize));
+				PVR_DPF(PVR_DBG_ERROR, "WrapMemory: "
+					"OSRegisterDiscontigMem "
+					"CpuVAddr = 0x%08X, Size=%d) failed",
+					 pMapping->CpuVAddr, pMapping->uSize);
 				goto fail_cleanup;
 			}
 		}
@@ -275,15 +255,13 @@
 			pMapping->eCpuMemoryOrigin = hm_wrapped;
 			pMapping->CpuPAddr = SysSysPAddrToCpuPAddr(psAddr[0]);
 
-			if (OSReservePhys(pMapping->CpuPAddr,
-					  pMapping->uSize,
-					  uFlags,
-					  &pMapping->CpuVAddr,
-					  &pMapping->hOSMemHandle) != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,
-					 "WrapMemory: OSReservePhys Phys=0x%08X, Size=%d) failed",
-					 pMapping->CpuPAddr, pMapping->uSize));
+			if (OSReservePhys(pMapping->CpuPAddr, pMapping->uSize,
+					uFlags, &pMapping->CpuVAddr,
+					&pMapping->hOSMemHandle) != PVRSRV_OK) {
+				PVR_DPF(PVR_DBG_ERROR, "WrapMemory: "
+					"OSReservePhys Phys=0x%08X, "
+					"Size=%d) failed",
+					 pMapping->CpuPAddr, pMapping->uSize);
 				goto fail_cleanup;
 			}
 		} else {
@@ -296,9 +274,10 @@
 						   &pMapping->CpuVAddr,
 						   &pMapping->hOSMemHandle) !=
 			    PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "WrapMemory: OSReserveDiscontigPhys Size=%d) failed",
-					 pMapping->uSize));
+				PVR_DPF(PVR_DBG_ERROR, "WrapMemory: "
+					"OSReserveDiscontigPhys Size=%d) "
+					"failed",
+					 pMapping->uSize);
 				goto fail_cleanup;
 			}
 		}
@@ -306,63 +285,59 @@
 
 	bResult = DevMemoryAlloc(psBMHeap->pBMContext,
 				 pMapping,
-				 IMG_NULL,
+				 NULL,
 				 uFlags | PVRSRV_MEM_READ | PVRSRV_MEM_WRITE,
 				 ui32PageSize, &DevVAddr);
 	if (!bResult) {
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "WrapMemory: DevMemoryAlloc(0x%x) failed",
-			 pMapping->uSize));
+			 pMapping->uSize);
 		goto fail_cleanup;
 	}
 
 	pBuf->CpuPAddr.uiAddr = pMapping->CpuPAddr.uiAddr + ui32BaseOffset;
-	if (!ui32BaseOffset) {
+	if (!ui32BaseOffset)
 		pBuf->hOSMemHandle = pMapping->hOSMemHandle;
-	} else {
+	else
 		if (OSGetSubMemHandle(pMapping->hOSMemHandle,
 				      ui32BaseOffset,
 				      (pMapping->uSize - ui32BaseOffset),
 				      uFlags,
 				      &pBuf->hOSMemHandle) != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "WrapMemory: OSGetSubMemHandle failed"));
+			PVR_DPF(PVR_DBG_ERROR,
+				 "WrapMemory: OSGetSubMemHandle failed");
 			goto fail_cleanup;
 		}
-	}
-	if (pMapping->CpuVAddr) {
+	if (pMapping->CpuVAddr)
 		pBuf->CpuVAddr =
-		    (void *)((IMG_UINTPTR_T) pMapping->CpuVAddr +
+		    (void *)((u32) pMapping->CpuVAddr +
 			     ui32BaseOffset);
-	}
 	pBuf->DevVAddr.uiAddr = pMapping->DevVAddr.uiAddr + ui32BaseOffset;
 
-	if (uFlags & PVRSRV_MEM_ZERO) {
-		if (!ZeroBuf(pBuf, pMapping, uSize, uFlags)) {
+	if (uFlags & PVRSRV_MEM_ZERO)
+		if (!ZeroBuf(pBuf, pMapping, uSize, uFlags))
 			return IMG_FALSE;
-		}
-	}
 
-	PVR_DPF((PVR_DBG_MESSAGE, "DevVaddr.uiAddr=%08X", DevVAddr.uiAddr));
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "WrapMemory: pMapping=%08X: DevV=%08X CpuV=%08X CpuP=%08X uSize=0x%x",
+	PVR_DPF(PVR_DBG_MESSAGE, "DevVaddr.uiAddr=%08X", DevVAddr.uiAddr);
+	PVR_DPF(PVR_DBG_MESSAGE, "WrapMemory: pMapping=%08X: "
+				"DevV=%08X CpuV=%08X CpuP=%08X uSize=0x%x",
 		 pMapping, pMapping->DevVAddr.uiAddr,
 		 pMapping->CpuVAddr, pMapping->CpuPAddr.uiAddr,
-		 pMapping->uSize));
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "WrapMemory: pBuf=%08X: DevV=%08X CpuV=%08X CpuP=%08X uSize=0x%x",
+		 pMapping->uSize);
+	PVR_DPF(PVR_DBG_MESSAGE, "WrapMemory: "
+				"pBuf=%08X: DevV=%08X CpuV=%08X CpuP=%08X "
+				"uSize=0x%x",
 		 pBuf, pBuf->DevVAddr.uiAddr, pBuf->CpuVAddr,
-		 pBuf->CpuPAddr.uiAddr, uSize));
+		 pBuf->CpuPAddr.uiAddr, uSize);
 
 	pBuf->pMapping = pMapping;
 	return IMG_TRUE;
 
 fail_cleanup:
-	if (ui32BaseOffset && pBuf->hOSMemHandle) {
+	if (ui32BaseOffset && pBuf->hOSMemHandle)
 		OSReleaseSubMemHandle(pBuf->hOSMemHandle, uFlags);
-	}
 
-	if (pMapping && (pMapping->CpuVAddr || pMapping->hOSMemHandle)) {
+	if (pMapping && (pMapping->CpuVAddr || pMapping->hOSMemHandle))
 		switch (pMapping->eCpuMemoryOrigin) {
 		case hm_wrapped:
 			OSUnReservePhys(pMapping->CpuVAddr, pMapping->uSize,
@@ -386,80 +361,77 @@
 			break;
 		}
 
-	}
-
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_MAPPING), pMapping,
-		  IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct BM_MAPPING), pMapping,
+		  NULL);
 
 	return IMG_FALSE;
 }
 
-static IMG_BOOL
-ZeroBuf(BM_BUF * pBuf, BM_MAPPING * pMapping, IMG_UINT32 ui32Bytes,
-	IMG_UINT32 ui32Flags)
+static IMG_BOOL ZeroBuf(struct BM_BUF *pBuf, struct BM_MAPPING *pMapping,
+			u32 ui32Bytes, u32 ui32Flags)
 {
-	IMG_VOID *pvCpuVAddr;
+	void *pvCpuVAddr;
 
 	if (pBuf->CpuVAddr) {
 		OSMemSet(pBuf->CpuVAddr, 0, ui32Bytes);
 	} else if (pMapping->eCpuMemoryOrigin == hm_contiguous
 		   || pMapping->eCpuMemoryOrigin == hm_wrapped) {
-		pvCpuVAddr = OSMapPhysToLin(pBuf->CpuPAddr,
+		pvCpuVAddr = (void __force *)OSMapPhysToLin(pBuf->CpuPAddr,
 					    ui32Bytes,
-					    PVRSRV_HAP_KERNEL_ONLY
-					    | (ui32Flags &
+					    PVRSRV_HAP_KERNEL_ONLY |
+					    (ui32Flags &
 					       PVRSRV_HAP_CACHETYPE_MASK),
-					    IMG_NULL);
+					    NULL);
 		if (!pvCpuVAddr) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "ZeroBuf: OSMapPhysToLin for contiguous buffer failed"));
+			PVR_DPF(PVR_DBG_ERROR, "ZeroBuf: "
+				"OSMapPhysToLin for contiguous buffer failed");
 			return IMG_FALSE;
 		}
 		OSMemSet(pvCpuVAddr, 0, ui32Bytes);
-		OSUnMapPhysToLin(pvCpuVAddr,
+		OSUnMapPhysToLin((void __force __iomem *)pvCpuVAddr,
 				 ui32Bytes,
 				 PVRSRV_HAP_KERNEL_ONLY
 				 | (ui32Flags & PVRSRV_HAP_CACHETYPE_MASK),
-				 IMG_NULL);
+				 NULL);
 	} else {
-		IMG_UINT32 ui32BytesRemaining = ui32Bytes;
-		IMG_UINT32 ui32CurrentOffset = 0;
-		IMG_CPU_PHYADDR CpuPAddr;
+		u32 ui32BytesRemaining = ui32Bytes;
+		u32 ui32CurrentOffset = 0;
+		struct IMG_CPU_PHYADDR CpuPAddr;
 
 		PVR_ASSERT(pBuf->hOSMemHandle);
 
 		while (ui32BytesRemaining > 0) {
-			IMG_UINT32 ui32BlockBytes =
+			u32 ui32BlockBytes =
 			    MIN(ui32BytesRemaining, HOST_PAGESIZE());
 			CpuPAddr =
 			    OSMemHandleToCpuPAddr(pBuf->hOSMemHandle,
 						  ui32CurrentOffset);
 
-			if (CpuPAddr.uiAddr & (HOST_PAGESIZE() - 1)) {
+			if (CpuPAddr.uiAddr & (HOST_PAGESIZE() - 1))
 				ui32BlockBytes =
 				    MIN(ui32BytesRemaining,
 					HOST_PAGEALIGN(CpuPAddr.uiAddr) -
 					CpuPAddr.uiAddr);
-			}
 
-			pvCpuVAddr = OSMapPhysToLin(CpuPAddr,
+			pvCpuVAddr = (void __force *)OSMapPhysToLin(CpuPAddr,
 						    ui32BlockBytes,
-						    PVRSRV_HAP_KERNEL_ONLY
-						    | (ui32Flags &
-						       PVRSRV_HAP_CACHETYPE_MASK),
-						    IMG_NULL);
+						    PVRSRV_HAP_KERNEL_ONLY |
+						    (ui32Flags &
+						    PVRSRV_HAP_CACHETYPE_MASK),
+						    NULL);
 			if (!pvCpuVAddr) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "ZeroBuf: OSMapPhysToLin while zeroing non-contiguous memory FAILED"));
+				PVR_DPF(PVR_DBG_ERROR, "ZeroBuf: "
+					"OSMapPhysToLin while "
+				       "zeroing non-contiguous memory FAILED");
 				return IMG_FALSE;
 			}
 			OSMemSet(pvCpuVAddr, 0, ui32BlockBytes);
-			OSUnMapPhysToLin(pvCpuVAddr,
+			OSUnMapPhysToLin((void __force __iomem *)pvCpuVAddr,
 					 ui32BlockBytes,
 					 PVRSRV_HAP_KERNEL_ONLY
 					 | (ui32Flags &
 					    PVRSRV_HAP_CACHETYPE_MASK),
-					 IMG_NULL);
+					 NULL);
 
 			ui32BytesRemaining -= ui32BlockBytes;
 			ui32CurrentOffset += ui32BlockBytes;
@@ -469,33 +441,33 @@
 	return IMG_TRUE;
 }
 
-static void FreeBuf(BM_BUF * pBuf, IMG_UINT32 ui32Flags)
+static void FreeBuf(struct BM_BUF *pBuf, u32 ui32Flags)
 {
-	BM_MAPPING *pMapping;
+	struct BM_MAPPING *pMapping;
 
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "FreeBuf: pBuf=%08X: DevVAddr=%08X CpuVAddr=%08X CpuPAddr=%08X",
+	PVR_DPF(PVR_DBG_MESSAGE, "FreeBuf: "
+			"pBuf=%08X: DevVAddr=%08X CpuVAddr=%08X CpuPAddr=%08X",
 		 pBuf, pBuf->DevVAddr.uiAddr, pBuf->CpuVAddr,
-		 pBuf->CpuPAddr.uiAddr));
+		 pBuf->CpuPAddr.uiAddr);
 
 	pMapping = pBuf->pMapping;
 
 	if (ui32Flags & PVRSRV_MEM_USER_SUPPLIED_DEVVADDR) {
 
-		if (ui32Flags & PVRSRV_MEM_RAM_BACKED_ALLOCATION) {
+		if (ui32Flags & PVRSRV_MEM_RAM_BACKED_ALLOCATION)
 
-			PVR_DPF((PVR_DBG_ERROR,
-				 "FreeBuf: combination of DevVAddr management and RAM backing mode unsupported"));
-		} else {
+			PVR_DPF(PVR_DBG_ERROR, "FreeBuf: "
+				"combination of DevVAddr management "
+				"and RAM backing mode unsupported");
+		else
 
-			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_MAPPING),
-				  pMapping, IMG_NULL);
-		}
+			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+					sizeof(struct BM_MAPPING),
+				  pMapping, NULL);
 	} else {
 
-		if (pBuf->hOSMemHandle != pMapping->hOSMemHandle) {
+		if (pBuf->hOSMemHandle != pMapping->hOSMemHandle)
 			OSReleaseSubMemHandle(pBuf->hOSMemHandle, ui32Flags);
-		}
 		if (ui32Flags & PVRSRV_MEM_RAM_BACKED_ALLOCATION) {
 
 			RA_Free(pBuf->pMapping->pArena, pBuf->DevVAddr.uiAddr,
@@ -532,60 +504,29 @@
 
 			DevMemoryFree(pMapping);
 
-			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_MAPPING),
-				  pMapping, IMG_NULL);
+			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+				  sizeof(struct BM_MAPPING), pMapping, NULL);
 		}
 	}
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_BUF), pBuf, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct BM_BUF), pBuf, NULL);
 }
 
-PVRSRV_ERROR BM_DestroyContext(IMG_HANDLE hBMContext, IMG_BOOL * pbDestroyed)
+void BM_DestroyContext(void *hBMContext)
 {
-	PVRSRV_ERROR eError;
-	BM_CONTEXT *pBMContext = (BM_CONTEXT *) hBMContext;
-
-	PVR_DPF((PVR_DBG_MESSAGE, "BM_DestroyContext"));
-
-	if (pbDestroyed != IMG_NULL) {
-		*pbDestroyed = IMG_FALSE;
-	}
-
-	if (pBMContext == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR, "BM_DestroyContext: Invalid handle"));
-		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
-
-	pBMContext->ui32RefCount--;
-
-	if (pBMContext->ui32RefCount > 0) {
-
-		return PVRSRV_OK;
-	}
+	struct BM_CONTEXT *pBMContext = (struct BM_CONTEXT *)hBMContext;
 
-	eError = ResManFreeResByPtr(pBMContext->hResItem);
+	PVR_DPF(PVR_DBG_MESSAGE, "BM_DestroyContext");
 
-	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "BM_DestroyContext: ResManFreeResByPtr failed %d",
-			 eError));
-		return eError;
-	}
-
-	if (pbDestroyed != IMG_NULL) {
-		*pbDestroyed = IMG_TRUE;
-	}
-
-	return PVRSRV_OK;
+	ResManFreeResByPtr(pBMContext->hResItem);
 }
 
-static PVRSRV_ERROR BM_DestroyContextCallBack(IMG_PVOID pvParam,
-					      IMG_UINT32 ui32Param)
+static enum PVRSRV_ERROR BM_DestroyContextCallBack(void *pvParam, u32 ui32Param)
 {
-	BM_CONTEXT *pBMContext = pvParam;
-	BM_CONTEXT **ppBMContext;
-	BM_HEAP *psBMHeap, *psTmpBMHeap;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct BM_CONTEXT *pBMContext = pvParam;
+	struct BM_CONTEXT **ppBMContext;
+	struct BM_HEAP *psBMHeap, *psTmpBMHeap;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
@@ -597,12 +538,11 @@
 		if (psBMHeap->ui32Attribs
 		    & (PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG
 		       | PVRSRV_BACKINGSTORE_LOCALMEM_CONTIG)) {
-			if (psBMHeap->pImportArena) {
+			if (psBMHeap->pImportArena)
 				RA_Delete(psBMHeap->pImportArena);
-			}
 		} else {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "BM_DestroyContext: backing store type unsupported"));
+			PVR_DPF(PVR_DBG_ERROR, "BM_DestroyContext: "
+					"backing store type unsupported");
 			return PVRSRV_ERROR_GENERIC;
 		}
 
@@ -612,54 +552,50 @@
 
 		psBMHeap = psBMHeap->psNext;
 
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_HEAP),
-			  psTmpBMHeap, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct BM_HEAP),
+			  psTmpBMHeap, NULL);
 	}
 
-	if (pBMContext->psMMUContext) {
+	if (pBMContext->psMMUContext)
 		psDeviceNode->pfnMMUFinalise(pBMContext->psMMUContext);
-	}
 
-	if (pBMContext->pBufferHash) {
+	if (pBMContext->pBufferHash)
 		HASH_Delete(pBMContext->pBufferHash);
-	}
 
 	if (pBMContext == psDeviceNode->sDevMemoryInfo.pBMKernelContext) {
 
-		psDeviceNode->sDevMemoryInfo.pBMKernelContext = IMG_NULL;
+		psDeviceNode->sDevMemoryInfo.pBMKernelContext = NULL;
 	} else {
 
 		for (ppBMContext = &psDeviceNode->sDevMemoryInfo.pBMContext;
-		     *ppBMContext; ppBMContext = &((*ppBMContext)->psNext)) {
+		     *ppBMContext; ppBMContext = &((*ppBMContext)->psNext))
 			if (*ppBMContext == pBMContext) {
 
 				*ppBMContext = pBMContext->psNext;
 
 				break;
 			}
-		}
 	}
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_CONTEXT), pBMContext,
-		  IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct BM_CONTEXT),
+		  pBMContext, NULL);
 
 	return PVRSRV_OK;
 }
 
-IMG_HANDLE
-BM_CreateContext(PVRSRV_DEVICE_NODE * psDeviceNode,
-		 IMG_DEV_PHYADDR * psPDDevPAddr,
-		 PVRSRV_PER_PROCESS_DATA * psPerProc, IMG_BOOL * pbCreated)
-{
-	BM_CONTEXT *pBMContext;
-	BM_HEAP *psBMHeap;
-	DEVICE_MEMORY_INFO *psDevMemoryInfo;
+void *BM_CreateContext(struct PVRSRV_DEVICE_NODE *psDeviceNode,
+		 struct IMG_DEV_PHYADDR *psPDDevPAddr,
+		 struct PVRSRV_PER_PROCESS_DATA *psPerProc, IMG_BOOL *pbCreated)
+{
+	struct BM_CONTEXT *pBMContext;
+	struct BM_HEAP *psBMHeap;
+	struct DEVICE_MEMORY_INFO *psDevMemoryInfo;
 	IMG_BOOL bKernelContext;
-	PRESMAN_CONTEXT hResManContext;
+	struct RESMAN_CONTEXT *hResManContext;
 
-	PVR_DPF((PVR_DBG_MESSAGE, "BM_CreateContext"));
+	PVR_DPF(PVR_DBG_MESSAGE, "BM_CreateContext");
 
-	if (psPerProc == IMG_NULL) {
+	if (psPerProc == NULL) {
 		bKernelContext = IMG_TRUE;
 		hResManContext = psDeviceNode->hResManContext;
 	} else {
@@ -667,54 +603,50 @@
 		hResManContext = psPerProc->hResManContext;
 	}
 
-	if (pbCreated != IMG_NULL) {
+	if (pbCreated != NULL)
 		*pbCreated = IMG_FALSE;
-	}
 
 	psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
 
-	if (bKernelContext == IMG_FALSE) {
+	if (bKernelContext == IMG_FALSE)
 		for (pBMContext = psDevMemoryInfo->pBMContext;
-		     pBMContext != IMG_NULL; pBMContext = pBMContext->psNext) {
+		     pBMContext != NULL; pBMContext = pBMContext->psNext)
 			if (ResManFindResourceByPtr
 			    (hResManContext,
 			     pBMContext->hResItem) == PVRSRV_OK) {
 
 				pBMContext->ui32RefCount++;
 
-				return (IMG_HANDLE) pBMContext;
+				return (void *)pBMContext;
 			}
-		}
-	}
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(struct _BM_CONTEXT_),
-		       (IMG_PVOID *) & pBMContext, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR, "BM_CreateContext: Alloc failed"));
-		return IMG_NULL;
+		       sizeof(struct BM_CONTEXT),
+		       (void **) &pBMContext, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "BM_CreateContext: Alloc failed");
+		return NULL;
 	}
-	OSMemSet(pBMContext, 0, sizeof(BM_CONTEXT));
+	OSMemSet(pBMContext, 0, sizeof(struct BM_CONTEXT));
 
 	pBMContext->psDeviceNode = psDeviceNode;
 
 	pBMContext->pBufferHash = HASH_Create(32);
-	if (pBMContext->pBufferHash == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "BM_CreateContext: HASH_Create failed"));
+	if (pBMContext->pBufferHash == NULL) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "BM_CreateContext: HASH_Create failed");
 		goto cleanup;
 	}
 
 	if (psDeviceNode->pfnMMUInitialise(psDeviceNode,
 					   &pBMContext->psMMUContext,
 					   psPDDevPAddr) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "BM_CreateContext: MMUInitialise failed"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "BM_CreateContext: MMUInitialise failed");
 		goto cleanup;
 	}
 
 	if (bKernelContext) {
-
-		PVR_ASSERT(psDevMemoryInfo->pBMKernelContext == IMG_NULL);
+		PVR_ASSERT(psDevMemoryInfo->pBMKernelContext == NULL);
 		psDevMemoryInfo->pBMKernelContext = pBMContext;
 	} else {
 
@@ -753,35 +685,33 @@
 						 RESMAN_TYPE_DEVICEMEM_CONTEXT,
 						 pBMContext,
 						 0, BM_DestroyContextCallBack);
-	if (pBMContext->hResItem == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "BM_CreateContext: ResManRegisterRes failed"));
+	if (pBMContext->hResItem == NULL) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "BM_CreateContext: ResManRegisterRes failed");
 		goto cleanup;
 	}
 
-	if (pbCreated != IMG_NULL) {
+	if (pbCreated != NULL)
 		*pbCreated = IMG_TRUE;
-	}
-	return (IMG_HANDLE) pBMContext;
+	return (void *)pBMContext;
 
 cleanup:
 	BM_DestroyContextCallBack(pBMContext, 0);
 
-	return IMG_NULL;
+	return NULL;
 }
 
-IMG_HANDLE
-BM_CreateHeap(IMG_HANDLE hBMContext, DEVICE_MEMORY_HEAP_INFO * psDevMemHeapInfo)
+void *BM_CreateHeap(void *hBMContext,
+		    struct DEVICE_MEMORY_HEAP_INFO *psDevMemHeapInfo)
 {
-	BM_CONTEXT *pBMContext = (BM_CONTEXT *) hBMContext;
-	PVRSRV_DEVICE_NODE *psDeviceNode = pBMContext->psDeviceNode;
-	BM_HEAP *psBMHeap;
+	struct BM_CONTEXT *pBMContext = (struct BM_CONTEXT *)hBMContext;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode = pBMContext->psDeviceNode;
+	struct BM_HEAP *psBMHeap;
 
-	PVR_DPF((PVR_DBG_MESSAGE, "BM_CreateHeap"));
+	PVR_DPF(PVR_DBG_MESSAGE, "BM_CreateHeap");
 
-	if (!pBMContext) {
-		return IMG_NULL;
-	}
+	if (!pBMContext)
+		return NULL;
 
 	if (pBMContext->ui32RefCount > 0) {
 		psBMHeap = pBMContext->psBMHeap;
@@ -789,22 +719,20 @@
 		while (psBMHeap) {
 			if (psBMHeap->sDevArena.ui32HeapID ==
 			    psDevMemHeapInfo->ui32HeapID)
-			{
 
 				return psBMHeap;
-			}
 			psBMHeap = psBMHeap->psNext;
 		}
 	}
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(BM_HEAP),
-		       (IMG_PVOID *) & psBMHeap, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR, "BM_CreateHeap: Alloc failed"));
-		return IMG_NULL;
+		       sizeof(struct BM_HEAP),
+		       (void **) &psBMHeap, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "BM_CreateHeap: Alloc failed");
+		return NULL;
 	}
 
-	OSMemSet(psBMHeap, 0, sizeof(BM_HEAP));
+	OSMemSet(psBMHeap, 0, sizeof(struct BM_HEAP));
 
 	psBMHeap->sDevArena.ui32HeapID = psDevMemHeapInfo->ui32HeapID;
 	psBMHeap->sDevArena.pszName = psDevMemHeapInfo->pszName;
@@ -821,17 +749,17 @@
 				       &psBMHeap->sDevArena,
 				       &psBMHeap->pVMArena);
 	if (!psBMHeap->pMMUHeap) {
-		PVR_DPF((PVR_DBG_ERROR, "BM_CreateHeap: MMUCreate failed"));
+		PVR_DPF(PVR_DBG_ERROR, "BM_CreateHeap: MMUCreate failed");
 		goto ErrorExit;
 	}
 
 	psBMHeap->pImportArena = RA_Create(psDevMemHeapInfo->pszBSName,
-					   0, 0, IMG_NULL,
+					   0, 0, NULL,
 					   HOST_PAGESIZE(),
 					   BM_ImportMemory,
-					   BM_FreeMemory, IMG_NULL, psBMHeap);
-	if (psBMHeap->pImportArena == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR, "BM_CreateHeap: RA_Create failed"));
+					   BM_FreeMemory, NULL, psBMHeap);
+	if (psBMHeap->pImportArena == NULL) {
+		PVR_DPF(PVR_DBG_ERROR, "BM_CreateHeap: RA_Create failed");
 		goto ErrorExit;
 	}
 
@@ -839,9 +767,9 @@
 
 		psBMHeap->pLocalDevMemArena =
 		    psDevMemHeapInfo->psLocalDevMemArena;
-		if (psBMHeap->pLocalDevMemArena == IMG_NULL) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "BM_CreateHeap: LocalDevMemArena null"));
+		if (psBMHeap->pLocalDevMemArena == NULL) {
+			PVR_DPF(PVR_DBG_ERROR,
+				 "BM_CreateHeap: LocalDevMemArena null");
 			goto ErrorExit;
 		}
 	}
@@ -849,39 +777,40 @@
 	psBMHeap->psNext = pBMContext->psBMHeap;
 	pBMContext->psBMHeap = psBMHeap;
 
-	return (IMG_HANDLE) psBMHeap;
+	return (void *)psBMHeap;
 
 ErrorExit:
 
-	if (psBMHeap->pMMUHeap != IMG_NULL) {
+	if (psBMHeap->pMMUHeap != NULL) {
 		psDeviceNode->pfnMMUDelete(psBMHeap->pMMUHeap);
 		psDeviceNode->pfnMMUFinalise(pBMContext->psMMUContext);
 	}
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_HEAP), psBMHeap, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct BM_HEAP),
+		  psBMHeap, NULL);
 
-	return IMG_NULL;
+	return NULL;
 }
 
-IMG_VOID BM_DestroyHeap(IMG_HANDLE hDevMemHeap)
+void BM_DestroyHeap(void *hDevMemHeap)
 {
-	BM_HEAP *psBMHeap = (BM_HEAP *) hDevMemHeap;
-	PVRSRV_DEVICE_NODE *psDeviceNode = psBMHeap->pBMContext->psDeviceNode;
+	struct BM_HEAP *psBMHeap = (struct BM_HEAP *)hDevMemHeap;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode =
+					psBMHeap->pBMContext->psDeviceNode;
 
-	PVR_DPF((PVR_DBG_MESSAGE, "BM_DestroyHeap"));
+	PVR_DPF(PVR_DBG_MESSAGE, "BM_DestroyHeap");
 
 	if (psBMHeap) {
-		BM_HEAP **ppsBMHeap;
+		struct BM_HEAP **ppsBMHeap;
 
 		if (psBMHeap->ui32Attribs
 		    & (PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG
 		       | PVRSRV_BACKINGSTORE_LOCALMEM_CONTIG)) {
-			if (psBMHeap->pImportArena) {
+			if (psBMHeap->pImportArena)
 				RA_Delete(psBMHeap->pImportArena);
-			}
 		} else {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "BM_DestroyHeap: backing store type unsupported"));
+			PVR_DPF(PVR_DBG_ERROR, "BM_DestroyHeap: "
+					"backing store type unsupported");
 			return;
 		}
 
@@ -893,147 +822,141 @@
 
 				*ppsBMHeap = psBMHeap->psNext;
 				OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-					  sizeof(BM_HEAP), psBMHeap, IMG_NULL);
+					  sizeof(struct BM_HEAP), psBMHeap,
+					  NULL);
 				break;
 			}
 			ppsBMHeap = &((*ppsBMHeap)->psNext);
 		}
 	} else {
-		PVR_DPF((PVR_DBG_ERROR, "BM_DestroyHeap: invalid heap handle"));
+		PVR_DPF(PVR_DBG_ERROR, "BM_DestroyHeap: invalid heap handle");
 	}
 }
 
-IMG_BOOL BM_Reinitialise(PVRSRV_DEVICE_NODE * psDeviceNode)
+IMG_BOOL BM_Reinitialise(struct PVRSRV_DEVICE_NODE *psDeviceNode)
 {
-
-	PVR_DPF((PVR_DBG_MESSAGE, "BM_Reinitialise"));
+	PVR_DPF(PVR_DBG_MESSAGE, "BM_Reinitialise");
 	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
 
 	return IMG_TRUE;
 }
 
-IMG_BOOL
-BM_Alloc(IMG_HANDLE hDevMemHeap,
-	 IMG_DEV_VIRTADDR * psDevVAddr,
-	 IMG_SIZE_T uSize,
-	 IMG_UINT32 * pui32Flags,
-	 IMG_UINT32 uDevVAddrAlignment, BM_HANDLE * phBuf)
-{
-	BM_BUF *pBuf;
-	BM_CONTEXT *pBMContext;
-	BM_HEAP *psBMHeap;
-	SYS_DATA *psSysData;
-	IMG_UINT32 uFlags = 0;
+IMG_BOOL BM_Alloc(void *hDevMemHeap,
+	 struct IMG_DEV_VIRTADDR *psDevVAddr,
+	 size_t uSize,
+	 u32 *pui32Flags,
+	 u32 uDevVAddrAlignment, void **phBuf)
+{
+	struct BM_BUF *pBuf;
+	struct BM_CONTEXT *pBMContext;
+	struct BM_HEAP *psBMHeap;
+	struct SYS_DATA *psSysData;
+	u32 uFlags = 0;
 
-	if (pui32Flags) {
+	if (pui32Flags)
 		uFlags = *pui32Flags;
-	}
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "BM_Alloc (uSize=0x%x, uFlags=0x%x, uDevVAddrAlignment=0x%x)",
-		 uSize, uFlags, uDevVAddrAlignment));
+		 uSize, uFlags, uDevVAddrAlignment);
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
+	if (SysAcquireData(&psSysData) != PVRSRV_OK)
 		return IMG_FALSE;
-	}
 
-	psBMHeap = (BM_HEAP *) hDevMemHeap;
+	psBMHeap = (struct BM_HEAP *)hDevMemHeap;
 	pBMContext = psBMHeap->pBMContext;
 
-	if (uDevVAddrAlignment == 0) {
+	if (uDevVAddrAlignment == 0)
 		uDevVAddrAlignment = 1;
-	}
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(BM_BUF),
-		       (IMG_PVOID *) & pBuf, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR, "BM_Alloc: BM_Buf alloc FAILED"));
+		       sizeof(struct BM_BUF),
+		       (void **) &pBuf, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "BM_Alloc: BM_Buf alloc FAILED");
 		return IMG_FALSE;
 	}
-	OSMemSet(pBuf, 0, sizeof(BM_BUF));
+	OSMemSet(pBuf, 0, sizeof(struct BM_BUF));
 
 	if (AllocMemory(pBMContext,
 			psBMHeap,
 			psDevVAddr,
 			uSize, uFlags, uDevVAddrAlignment, pBuf) != IMG_TRUE) {
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_BUF), pBuf,
-			  IMG_NULL);
-		PVR_DPF((PVR_DBG_ERROR, "BM_Alloc: AllocMemory FAILED"));
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct BM_BUF), pBuf,
+			  NULL);
+		PVR_DPF(PVR_DBG_ERROR, "BM_Alloc: AllocMemory FAILED");
 		return IMG_FALSE;
 	}
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "BM_Alloc (uSize=0x%x, uFlags=0x%x)=%08X",
-		 uSize, uFlags, pBuf));
+		 uSize, uFlags, pBuf);
 
 	pBuf->ui32RefCount = 1;
-	*phBuf = (BM_HANDLE) pBuf;
+	pvr_get_ctx(pBMContext);
+	*phBuf = (void *) pBuf;
 	*pui32Flags = uFlags | psBMHeap->ui32Attribs;
 
 	return IMG_TRUE;
 }
 
-IMG_BOOL
-BM_IsWrapped(IMG_HANDLE hDevMemHeap,
-	     IMG_UINT32 ui32Offset, IMG_SYS_PHYADDR sSysAddr)
-{
-	BM_BUF *pBuf;
-	BM_CONTEXT *psBMContext;
-	BM_HEAP *psBMHeap;
+static struct BM_BUF *bm_get_buf(void *heap_handle,
+				 struct IMG_SYS_PHYADDR start, u32 offset)
+{
+	struct BM_BUF *buf;
+	struct BM_CONTEXT *context;
+	struct BM_HEAP *heap;
 
-	psBMHeap = (BM_HEAP *) hDevMemHeap;
-	psBMContext = psBMHeap->pBMContext;
-	sSysAddr.uiAddr += ui32Offset;
-	pBuf = (BM_BUF *) HASH_Retrieve(psBMContext->pBufferHash,
-					(IMG_UINTPTR_T) sSysAddr.uiAddr);
-	return pBuf != IMG_NULL;
+	heap = heap_handle;
+	context = heap->pBMContext;
+	start.uiAddr += offset;
+	buf = (struct BM_BUF *)HASH_Retrieve(context->pBufferHash,
+					     start.uiAddr);
+
+	return buf;
 }
 
-IMG_BOOL
-BM_IsWrappedCheckSize(IMG_HANDLE hDevMemHeap,
-		 IMG_UINT32 ui32Offset,
-		 IMG_SYS_PHYADDR sSysAddr,
-		 IMG_UINT32 ui32ByteSize)
+struct BM_BUF *bm_get_buf_virt(void *heap_handle, void *virt_start)
 {
-	BM_BUF *pBuf;
-	BM_CONTEXT *psBMContext;
-	BM_HEAP *psBMHeap;
+	struct BM_BUF *buf;
+	struct IMG_SYS_PHYADDR paddr;
+	void *wrap_mem;
+	unsigned long offset;
 
-	IMG_BOOL ret = IMG_FALSE;
+	offset = (unsigned long)virt_start & ~PAGE_MASK;
+	virt_start = (void *)((unsigned long)virt_start & PAGE_MASK);
 
-	psBMHeap = (BM_HEAP *) hDevMemHeap;
-	psBMContext = psBMHeap->pBMContext;
-	sSysAddr.uiAddr += ui32Offset;
-	pBuf = (BM_BUF *) HASH_Retrieve(psBMContext->pBufferHash,
-			(IMG_UINTPTR_T) sSysAddr.uiAddr);
-
-	if (pBuf != NULL) {
-		if (pBuf->pMapping->uSize >= ui32ByteSize)
-			ret = IMG_TRUE;
-		else
-			ret = IMG_FALSE;
+	if (OSAcquirePhysPageAddr(virt_start, PAGE_SIZE, &paddr,
+				  &wrap_mem, IMG_FALSE) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "%s: failed to get physical address for BM_BUF",
+			 __func__);
+		return NULL;
 	}
+	buf = bm_get_buf(heap_handle, paddr, offset);
+	OSReleasePhysPageAddr(wrap_mem, IMG_FALSE);
+
+	return buf;
+}
 
-	return ret;
+IMG_BOOL BM_IsWrapped(void *hDevMemHeap, u32 ui32Offset,
+		      struct IMG_SYS_PHYADDR sSysAddr)
+{
+	return bm_get_buf(hDevMemHeap, sSysAddr, ui32Offset) ?
+		IMG_TRUE : IMG_FALSE;
 }
 
-IMG_BOOL
-BM_Wrap(IMG_HANDLE hDevMemHeap,
-	IMG_UINT32 ui32Size,
-	IMG_UINT32 ui32Offset,
-	IMG_BOOL bPhysContig,
-	IMG_SYS_PHYADDR * psSysAddr,
-	IMG_BOOL bFreePageList,
-	IMG_VOID * pvCPUVAddr, IMG_UINT32 * pui32Flags, BM_HANDLE * phBuf)
+IMG_BOOL BM_Wrap(void *hDevMemHeap, u32 ui32Size, u32 ui32Offset,
+	IMG_BOOL bPhysContig, struct IMG_SYS_PHYADDR *psSysAddr,
+	IMG_BOOL bFreePageList, void *pvCPUVAddr, u32 *pui32Flags, void **phBuf)
 {
-	BM_BUF *pBuf;
-	BM_CONTEXT *psBMContext;
-	BM_HEAP *psBMHeap;
-	SYS_DATA *psSysData;
-	IMG_SYS_PHYADDR sHashAddress;
-	IMG_UINT32 uFlags;
+	struct BM_BUF *pBuf;
+	struct BM_CONTEXT *psBMContext;
+	struct BM_HEAP *psBMHeap;
+	struct SYS_DATA *psSysData;
+	struct IMG_SYS_PHYADDR sHashAddress;
+	u32 uFlags;
 
-	psBMHeap = (BM_HEAP *) hDevMemHeap;
+	psBMHeap = (struct BM_HEAP *)hDevMemHeap;
 	psBMContext = psBMHeap->pBMContext;
 
 	uFlags =
@@ -1043,9 +966,9 @@
 	if (pui32Flags)
 		uFlags |= *pui32Flags;
 
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "BM_Wrap (uSize=0x%x, uOffset=0x%x, bPhysContig=0x%x, pvCPUVAddr=0x%x, uFlags=0x%x)",
-		 ui32Size, ui32Offset, bPhysContig, pvCPUVAddr, uFlags));
+	PVR_DPF(PVR_DBG_MESSAGE, "BM_Wrap (uSize=0x%x, uOffset=0x%x, "
+			"bPhysContig=0x%x, pvCPUVAddr=0x%x, uFlags=0x%x)",
+			ui32Size, ui32Offset, bPhysContig, pvCPUVAddr, uFlags);
 
 	if (SysAcquireData(&psSysData) != PVRSRV_OK)
 		return IMG_FALSE;
@@ -1054,12 +977,11 @@
 
 	sHashAddress.uiAddr += ui32Offset;
 
-	pBuf =
-	    (BM_BUF *) HASH_Retrieve(psBMContext->pBufferHash,
-				     (IMG_UINTPTR_T) sHashAddress.uiAddr);
+	pBuf = (struct BM_BUF *)HASH_Retrieve(psBMContext->pBufferHash,
+				     (u32) sHashAddress.uiAddr);
 
 	if (pBuf) {
-		IMG_UINT32 ui32MappingSize =
+		u32 ui32MappingSize =
 		    HOST_PAGEALIGN(ui32Size + ui32Offset);
 
 		if (pBuf->pMapping->uSize == ui32MappingSize
@@ -1068,12 +990,13 @@
 			hm_wrapped_virtaddr
 			|| pBuf->pMapping->eCpuMemoryOrigin ==
 			hm_wrapped_scatter)) {
-			PVR_DPF((PVR_DBG_MESSAGE,
-				 "BM_Wrap (Matched previous Wrap! uSize=0x%x, uOffset=0x%x, SysAddr=%08X)",
-				 ui32Size, ui32Offset, sHashAddress.uiAddr));
+			PVR_DPF(PVR_DBG_MESSAGE,
+				 "BM_Wrap (Matched previous Wrap! "
+				 "uSize=0x%x, uOffset=0x%x, SysAddr=%08X)",
+				 ui32Size, ui32Offset, sHashAddress.uiAddr);
 
 			pBuf->ui32RefCount++;
-			*phBuf = (BM_HANDLE) pBuf;
+			*phBuf = (void *) pBuf;
 			if (pui32Flags)
 				*pui32Flags = uFlags;
 
@@ -1081,48 +1004,49 @@
 			if (bFreePageList && psSysAddr)
 				OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
 					  ui32MappingSize / HOST_PAGESIZE() *
-					  sizeof(IMG_SYS_PHYADDR),
-					  (IMG_VOID *) psSysAddr, 0);
+					  sizeof(struct IMG_SYS_PHYADDR),
+					  (void *)psSysAddr, NULL);
 			return IMG_TRUE;
 		}
 	}
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(BM_BUF),
-		       (IMG_PVOID *) & pBuf, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR, "BM_Wrap: BM_Buf alloc FAILED"));
+		       sizeof(struct BM_BUF),
+		       (void **) &pBuf, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "BM_Wrap: BM_Buf alloc FAILED");
 		return IMG_FALSE;
 	}
-	OSMemSet(pBuf, 0, sizeof(BM_BUF));
+	OSMemSet(pBuf, 0, sizeof(struct BM_BUF));
 
 	if (WrapMemory
 	    (psBMHeap, ui32Size, ui32Offset, bPhysContig, psSysAddr, pvCPUVAddr,
 	     uFlags, pBuf) != IMG_TRUE) {
-		PVR_DPF((PVR_DBG_ERROR, "BM_Wrap: WrapMemory FAILED"));
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_BUF), pBuf,
-			  IMG_NULL);
+		PVR_DPF(PVR_DBG_ERROR, "BM_Wrap: WrapMemory FAILED");
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct BM_BUF), pBuf,
+			  NULL);
 		return IMG_FALSE;
 	}
 
 	if (pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped
 	    || pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped_virtaddr
 	    || pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped_scatter) {
-		pBuf->uHashKey = (IMG_UINTPTR_T) sHashAddress.uiAddr;
+		pBuf->uHashKey = (u32) sHashAddress.uiAddr;
 		if (!HASH_Insert
 		    (psBMContext->pBufferHash, pBuf->uHashKey,
-		     (IMG_UINTPTR_T) pBuf)) {
+		     (u32) pBuf)) {
 			FreeBuf(pBuf, uFlags);
-			PVR_DPF((PVR_DBG_ERROR, "BM_Wrap: HASH_Insert FAILED"));
+			PVR_DPF(PVR_DBG_ERROR, "BM_Wrap: HASH_Insert FAILED");
 			return IMG_FALSE;
 		}
 	}
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "BM_Wrap (uSize=0x%x, uFlags=0x%x)=%08X(devVAddr=%08X)",
-		 ui32Size, uFlags, pBuf, pBuf->DevVAddr.uiAddr));
+		 ui32Size, uFlags, pBuf, pBuf->DevVAddr.uiAddr);
 
 	pBuf->ui32RefCount = 1;
-	*phBuf = (BM_HANDLE) pBuf;
+	pvr_get_ctx(psBMContext);
+	*phBuf = (void *) pBuf;
 	if (pui32Flags)
 		*pui32Flags = uFlags;
 
@@ -1132,19 +1056,21 @@
 	return IMG_TRUE;
 }
 
-void BM_Free(BM_HANDLE hBuf, IMG_UINT32 ui32Flags)
+void BM_Free(void *hBuf, u32 ui32Flags)
 {
-	BM_BUF *pBuf = (BM_BUF *) hBuf;
-	SYS_DATA *psSysData;
+	struct BM_BUF *pBuf = (struct BM_BUF *)hBuf;
+	struct SYS_DATA *psSysData;
 
-	PVR_DPF((PVR_DBG_MESSAGE, "BM_Free (h=%08X)", hBuf));
-	/* Calling BM_Free with NULL hBuf is either a bug or out-of-memory condition.
-	 * Bail out if in debug mode, continue in release builds */
-	PVR_ASSERT(pBuf != IMG_NULL);
+	PVR_DPF(PVR_DBG_MESSAGE, "BM_Free (h=%08X)", hBuf);
+	/*
+	   Calling BM_Free with NULL hBuf is either a bug or
+	   out-of-memory condition.
+	   Bail out if in debug mode, continue in release builds
+	*/
+	PVR_ASSERT(pBuf != NULL);
 #if !defined(DEBUG)
-	if (!pBuf) {
+	if (!pBuf)
 		return;
-	}
 #endif
 
 	if (SysAcquireData(&psSysData) != PVRSRV_OK)
@@ -1153,112 +1079,105 @@
 	pBuf->ui32RefCount--;
 
 	if (pBuf->ui32RefCount == 0) {
+		struct BM_MAPPING *map = pBuf->pMapping;
+		struct BM_CONTEXT *ctx = map->pBMHeap->pBMContext;
 		void *pPageList = pBuf->pvPageList;
-		IMG_UINT32 ui32ListSize =
-		    pBuf->pMapping->uSize / HOST_PAGESIZE() *
-		    sizeof(IMG_SYS_PHYADDR);
-		if (pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped
-		    || pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped_virtaddr
-		    || pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped_scatter) {
-			HASH_Remove(pBuf->pMapping->pBMHeap->pBMContext->
-				    pBufferHash, pBuf->uHashKey);
-		}
+		u32 ui32ListSize = map->uSize / HOST_PAGESIZE() *
+			sizeof(struct IMG_SYS_PHYADDR);
+		if (map->eCpuMemoryOrigin == hm_wrapped
+		    || map->eCpuMemoryOrigin == hm_wrapped_virtaddr
+		    || map->eCpuMemoryOrigin == hm_wrapped_scatter)
+			HASH_Remove(ctx->pBufferHash, pBuf->uHashKey);
 		FreeBuf(pBuf, ui32Flags);
+		pvr_put_ctx(ctx);
 		if (pPageList)
 			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32ListSize,
-				  pPageList, 0);
+				  pPageList, NULL);
 	}
 }
 
-IMG_CPU_VIRTADDR BM_HandleToCpuVaddr(BM_HANDLE hBuf)
+void *BM_HandleToCpuVaddr(void *hBuf)
 {
-	BM_BUF *pBuf = (BM_BUF *) hBuf;
+	struct BM_BUF *pBuf = (struct BM_BUF *)hBuf;
 
-	PVR_ASSERT(pBuf != IMG_NULL);
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "BM_HandleToCpuVaddr(h=%08X)=%08X", hBuf, pBuf->CpuVAddr));
+	PVR_ASSERT(pBuf != NULL);
+	PVR_DPF(PVR_DBG_MESSAGE,
+		 "BM_HandleToCpuVaddr(h=%08X)=%08X", hBuf, pBuf->CpuVAddr);
 	return pBuf->CpuVAddr;
 }
 
-IMG_DEV_VIRTADDR BM_HandleToDevVaddr(BM_HANDLE hBuf)
+struct IMG_DEV_VIRTADDR BM_HandleToDevVaddr(void *hBuf)
 {
-	BM_BUF *pBuf = (BM_BUF *) hBuf;
+	struct BM_BUF *pBuf = (struct BM_BUF *)hBuf;
 
-	PVR_ASSERT(pBuf != IMG_NULL);
-	PVR_DPF((PVR_DBG_MESSAGE, "BM_HandleToDevVaddr(h=%08X)=%08X", hBuf,
-		 pBuf->DevVAddr));
+	PVR_ASSERT(pBuf != NULL);
+	PVR_DPF(PVR_DBG_MESSAGE, "BM_HandleToDevVaddr(h=%08X)=%08X", hBuf,
+		 pBuf->DevVAddr);
 	return pBuf->DevVAddr;
 }
 
-IMG_SYS_PHYADDR BM_HandleToSysPaddr(BM_HANDLE hBuf)
+struct IMG_SYS_PHYADDR BM_HandleToSysPaddr(void *hBuf)
 {
-	BM_BUF *pBuf = (BM_BUF *) hBuf;
+	struct BM_BUF *pBuf = (struct BM_BUF *)hBuf;
 
-	PVR_ASSERT(pBuf != IMG_NULL);
-	PVR_DPF((PVR_DBG_MESSAGE, "BM_HandleToSysPaddr(h=%08X)=%08X", hBuf,
-		 pBuf->CpuPAddr.uiAddr));
+	PVR_ASSERT(pBuf != NULL);
+	PVR_DPF(PVR_DBG_MESSAGE, "BM_HandleToSysPaddr(h=%08X)=%08X", hBuf,
+		 pBuf->CpuPAddr.uiAddr);
 	return SysCpuPAddrToSysPAddr(pBuf->CpuPAddr);
 }
 
-IMG_HANDLE BM_HandleToOSMemHandle(BM_HANDLE hBuf)
+void *BM_HandleToOSMemHandle(void *hBuf)
 {
-	BM_BUF *pBuf = (BM_BUF *) hBuf;
+	struct BM_BUF *pBuf = (struct BM_BUF *)hBuf;
 
-	PVR_ASSERT(pBuf != IMG_NULL);
+	PVR_ASSERT(pBuf != NULL);
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "BM_HandleToOSMemHandle(h=%08X)=%08X",
-		 hBuf, pBuf->hOSMemHandle));
+		 hBuf, pBuf->hOSMemHandle);
 	return pBuf->hOSMemHandle;
 }
 
-IMG_BOOL
-BM_ContiguousStatistics(IMG_UINT32 uFlags,
-			IMG_UINT32 * pTotalBytes, IMG_UINT32 * pAvailableBytes)
+IMG_BOOL BM_ContiguousStatistics(u32 uFlags,
+			u32 *pTotalBytes, u32 *pAvailableBytes)
 {
-	if (pAvailableBytes || pTotalBytes || uFlags) ;
+	if (pAvailableBytes || pTotalBytes || uFlags)
+		;
 	return IMG_FALSE;
 }
 
-static IMG_BOOL
-DevMemoryAlloc(BM_CONTEXT * pBMContext,
-	       BM_MAPPING * pMapping,
-	       IMG_SIZE_T * pActualSize,
-	       IMG_UINT32 uFlags,
-	       IMG_UINT32 dev_vaddr_alignment, IMG_DEV_VIRTADDR * pDevVAddr)
+static IMG_BOOL DevMemoryAlloc(struct BM_CONTEXT *pBMContext,
+	       struct BM_MAPPING *pMapping, size_t *pActualSize, u32 uFlags,
+	       u32 dev_vaddr_alignment, struct IMG_DEV_VIRTADDR *pDevVAddr)
 {
-	PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
 #ifdef PDUMP
-	IMG_UINT32 ui32PDumpSize = pMapping->uSize;
+	u32 ui32PDumpSize = pMapping->uSize;
 #endif
 
 	psDeviceNode = pBMContext->psDeviceNode;
 
-	if (uFlags & PVRSRV_MEM_INTERLEAVED) {
+	if (uFlags & PVRSRV_MEM_INTERLEAVED)
 
 		pMapping->uSize *= 2;
-	}
 #ifdef PDUMP
-	if (uFlags & PVRSRV_MEM_DUMMY) {
+	if (uFlags & PVRSRV_MEM_DUMMY)
 
 		ui32PDumpSize = HOST_PAGESIZE();
-	}
 #endif
 
 	if (!psDeviceNode->pfnMMUAlloc(pMapping->pBMHeap->pMMUHeap,
-				       pMapping->uSize,
-				       pActualSize,
-				       0,
-				       dev_vaddr_alignment,
+				       pMapping->uSize, pActualSize,
+				       0, dev_vaddr_alignment,
 				       &(pMapping->DevVAddr))) {
-		PVR_DPF((PVR_DBG_ERROR, "DevMemoryAlloc ERROR MMU_Alloc"));
+		PVR_DPF(PVR_DBG_ERROR, "DevMemoryAlloc ERROR MMU_Alloc");
 		return IMG_FALSE;
 	}
 
 	PDUMPMALLOCPAGES(psDeviceNode->sDevId.eDeviceType,
 			 pMapping->DevVAddr.uiAddr, pMapping->CpuVAddr,
 			 pMapping->hOSMemHandle, ui32PDumpSize,
-			 (IMG_HANDLE) pMapping);
+			 (void *)pMapping);
 
 	switch (pMapping->eCpuMemoryOrigin) {
 	case hm_wrapped:
@@ -1271,7 +1190,7 @@
 						     SysCpuPAddrToSysPAddr
 						     (pMapping->CpuPAddr),
 						     pMapping->uSize, uFlags,
-						     (IMG_HANDLE) pMapping);
+						     (void *)pMapping);
 
 			*pDevVAddr = pMapping->DevVAddr;
 			break;
@@ -1285,7 +1204,7 @@
 						      pMapping->CpuVAddr,
 						      pMapping->hOSMemHandle,
 						      pDevVAddr, uFlags,
-						      (IMG_HANDLE) pMapping);
+						      (void *)pMapping);
 			break;
 		}
 	case hm_wrapped_scatter:
@@ -1296,15 +1215,15 @@
 						       pMapping->DevVAddr,
 						       pMapping->psSysAddr,
 						       pMapping->uSize, uFlags,
-						       (IMG_HANDLE) pMapping);
+						       (void *)pMapping);
 
 			*pDevVAddr = pMapping->DevVAddr;
 			break;
 		}
 	default:
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "Illegal value %d for pMapping->eCpuMemoryOrigin",
-			 pMapping->eCpuMemoryOrigin));
+			 pMapping->eCpuMemoryOrigin);
 		return IMG_FALSE;
 	}
 
@@ -1312,24 +1231,23 @@
 	return IMG_TRUE;
 }
 
-static void DevMemoryFree(BM_MAPPING * pMapping)
+static void DevMemoryFree(struct BM_MAPPING *pMapping)
 {
-	PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
 #ifdef PDUMP
-	IMG_UINT32 ui32PSize;
+	u32 ui32PSize;
 #endif
 
 #ifdef PDUMP
 
-	if (pMapping->ui32Flags & PVRSRV_MEM_DUMMY) {
+	if (pMapping->ui32Flags & PVRSRV_MEM_DUMMY)
 
 		ui32PSize = HOST_PAGESIZE();
-	} else {
+	else
 		ui32PSize = pMapping->uSize;
-	}
 
 	PDUMPFREEPAGES(pMapping->pBMHeap, pMapping->DevVAddr,
-		       ui32PSize, (IMG_HANDLE) pMapping,
+		       ui32PSize, (void *) pMapping,
 		       (IMG_BOOL) (pMapping->
 				   ui32Flags & PVRSRV_MEM_INTERLEAVED));
 #endif
@@ -1340,85 +1258,80 @@
 				 pMapping->DevVAddr, pMapping->uSize);
 }
 
-static IMG_BOOL
-BM_ImportMemory(void *pH,
-		IMG_SIZE_T uRequestSize,
-		IMG_SIZE_T * pActualSize,
-		BM_MAPPING ** ppsMapping,
-		IMG_UINT32 uFlags, IMG_UINTPTR_T * pBase)
-{
-	BM_MAPPING *pMapping;
-	BM_HEAP *pBMHeap = pH;
-	BM_CONTEXT *pBMContext = pBMHeap->pBMContext;
+static IMG_BOOL BM_ImportMemory(void *pH, size_t uRequestSize,
+		size_t *pActualSize, struct BM_MAPPING **ppsMapping,
+		u32 uFlags, u32 *pBase)
+{
+	struct BM_MAPPING *pMapping;
+	struct BM_HEAP *pBMHeap = pH;
+	struct BM_CONTEXT *pBMContext = pBMHeap->pBMContext;
 	IMG_BOOL bResult;
-	IMG_SIZE_T uSize;
-	IMG_SIZE_T uPSize;
-	IMG_UINT32 uDevVAddrAlignment = 0;
-
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "BM_ImportMemory (pBMContext=%08X, uRequestSize=0x%x, uFlags=0x%x, uAlign=0x%x)",
-		 pBMContext, uRequestSize, uFlags, uDevVAddrAlignment));
+	size_t uSize;
+	size_t uPSize;
+	u32 uDevVAddrAlignment = 0;
+
+	PVR_DPF(PVR_DBG_MESSAGE, "BM_ImportMemory (pBMContext=%08X, "
+				"uRequestSize=0x%x, uFlags=0x%x, uAlign=0x%x)",
+		 pBMContext, uRequestSize, uFlags, uDevVAddrAlignment);
 
-	PVR_ASSERT(ppsMapping != IMG_NULL);
-	PVR_ASSERT(pBMContext != IMG_NULL);
+	PVR_ASSERT(ppsMapping != NULL);
+	PVR_ASSERT(pBMContext != NULL);
 
 	uSize = HOST_PAGEALIGN(uRequestSize);
 	PVR_ASSERT(uSize >= uRequestSize);
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(BM_MAPPING),
-		       (IMG_PVOID *) & pMapping, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "BM_ImportMemory: failed BM_MAPPING alloc"));
+		       sizeof(struct BM_MAPPING),
+		       (void **) &pMapping, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "BM_ImportMemory: failed to alloc mapping object");
 		goto fail_exit;
 	}
 
-	pMapping->hOSMemHandle = 0;
-	pMapping->CpuVAddr = 0;
+	pMapping->hOSMemHandle = NULL;
+	pMapping->CpuVAddr = NULL;
 	pMapping->DevVAddr.uiAddr = 0;
 	pMapping->CpuPAddr.uiAddr = 0;
 	pMapping->uSize = uSize;
 	pMapping->pBMHeap = pBMHeap;
 	pMapping->ui32Flags = uFlags;
 
-	if (pActualSize) {
+	if (pActualSize)
 		*pActualSize = uSize;
-	}
 
-	if (pMapping->ui32Flags & PVRSRV_MEM_DUMMY) {
+	if (pMapping->ui32Flags & PVRSRV_MEM_DUMMY)
 		uPSize = HOST_PAGESIZE();
-	} else {
+	else
 		uPSize = pMapping->uSize;
-	}
 
 	if (pBMHeap->ui32Attribs & PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG) {
 
 		if (OSAllocPages(pBMHeap->ui32Attribs,
 				 uPSize,
-				 (IMG_VOID **) & pMapping->CpuVAddr,
+				 (void **) &pMapping->CpuVAddr,
 				 &pMapping->hOSMemHandle) != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
+			PVR_DPF(PVR_DBG_ERROR,
 				 "BM_ImportMemory: OSAllocPages(0x%x) failed",
-				 uPSize));
+				 uPSize);
 			goto fail_mapping_alloc;
 		}
 
 		pMapping->eCpuMemoryOrigin = hm_env;
 	} else if (pBMHeap->ui32Attribs & PVRSRV_BACKINGSTORE_LOCALMEM_CONTIG) {
-		IMG_SYS_PHYADDR sSysPAddr;
+		struct IMG_SYS_PHYADDR sSysPAddr;
 
-		PVR_ASSERT(pBMHeap->pLocalDevMemArena != IMG_NULL);
+		PVR_ASSERT(pBMHeap->pLocalDevMemArena != NULL);
 
 		if (!RA_Alloc(pBMHeap->pLocalDevMemArena,
 			      uPSize,
-			      IMG_NULL,
-			      IMG_NULL,
+			      NULL,
+			      NULL,
 			      0,
 			      HOST_PAGESIZE(),
-			      0, (IMG_UINTPTR_T *) & sSysPAddr.uiAddr)) {
-			PVR_DPF((PVR_DBG_ERROR,
+			      0, (u32 *) &sSysPAddr.uiAddr)) {
+			PVR_DPF(PVR_DBG_ERROR,
 				 "BM_ImportMemory: RA_Alloc(0x%x) FAILED",
-				 uPSize));
+				 uPSize);
 			goto fail_mapping_alloc;
 		}
 
@@ -1428,24 +1341,24 @@
 				  pBMHeap->ui32Attribs,
 				  &pMapping->CpuVAddr,
 				  &pMapping->hOSMemHandle) != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "BM_ImportMemory: OSReservePhys failed"));
+			PVR_DPF(PVR_DBG_ERROR,
+				 "BM_ImportMemory: OSReservePhys failed");
 			goto fail_dev_mem_alloc;
 		}
 
 		pMapping->eCpuMemoryOrigin = hm_contiguous;
 	} else {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "BM_ImportMemory: Invalid backing store type"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "BM_ImportMemory: Invalid backing store type");
 		goto fail_mapping_alloc;
 	}
 
-	bResult = DevMemoryAlloc(pBMContext, pMapping, IMG_NULL, uFlags,
+	bResult = DevMemoryAlloc(pBMContext, pMapping, NULL, uFlags,
 				 uDevVAddrAlignment, &pMapping->DevVAddr);
 	if (!bResult) {
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "BM_ImportMemory: DevMemoryAlloc(0x%x) failed",
-			 pMapping->uSize));
+			 pMapping->uSize);
 		goto fail_dev_mem_alloc;
 	}
 
@@ -1456,71 +1369,67 @@
 	*pBase = pMapping->DevVAddr.uiAddr;
 	*ppsMapping = pMapping;
 
-	PVR_DPF((PVR_DBG_MESSAGE, "BM_ImportMemory: IMG_TRUE"));
+	PVR_DPF(PVR_DBG_MESSAGE, "BM_ImportMemory: success");
 	return IMG_TRUE;
 
 fail_dev_mem_alloc:
 	if (pMapping && (pMapping->CpuVAddr || pMapping->hOSMemHandle)) {
 
-		if (pMapping->ui32Flags & PVRSRV_MEM_INTERLEAVED) {
+		if (pMapping->ui32Flags & PVRSRV_MEM_INTERLEAVED)
 			pMapping->uSize /= 2;
-		}
 
-		if (pMapping->ui32Flags & PVRSRV_MEM_DUMMY) {
+		if (pMapping->ui32Flags & PVRSRV_MEM_DUMMY)
 			uPSize = HOST_PAGESIZE();
-		} else {
+		else
 			uPSize = pMapping->uSize;
-		}
 
-		if (pBMHeap->ui32Attribs & PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG) {
+		if (pBMHeap->ui32Attribs &
+			PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG) {
 			OSFreePages(pBMHeap->ui32Attribs,
 				    uPSize,
 				    (void *)pMapping->CpuVAddr,
 				    pMapping->hOSMemHandle);
 		} else {
-			IMG_SYS_PHYADDR sSysPAddr;
+			struct IMG_SYS_PHYADDR sSysPAddr;
 
-			if (pMapping->CpuVAddr) {
+			if (pMapping->CpuVAddr)
 				OSUnReservePhys(pMapping->CpuVAddr, uPSize,
 						pBMHeap->ui32Attribs,
 						pMapping->hOSMemHandle);
-			}
 			sSysPAddr = SysCpuPAddrToSysPAddr(pMapping->CpuPAddr);
 			RA_Free(pBMHeap->pLocalDevMemArena, sSysPAddr.uiAddr,
 				IMG_FALSE);
 		}
 	}
 fail_mapping_alloc:
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_MAPPING), pMapping,
-		  IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct BM_MAPPING), pMapping,
+		  NULL);
 fail_exit:
 	return IMG_FALSE;
 }
 
-static void BM_FreeMemory(void *h, IMG_UINTPTR_T _base, BM_MAPPING * psMapping)
+static void BM_FreeMemory(void *h, u32 _base, struct BM_MAPPING *psMapping)
 {
-	BM_HEAP *pBMHeap = h;
-	IMG_SIZE_T uPSize;
+	struct BM_HEAP *pBMHeap = h;
+	size_t uPSize;
 
 	PVR_UNREFERENCED_PARAMETER(_base);
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "BM_FreeMemory (h=%08X, base=0x%x, psMapping=0x%x)", h, _base,
-		 psMapping));
+		 psMapping);
 
-	PVR_ASSERT(psMapping != IMG_NULL);
+	PVR_ASSERT(psMapping != NULL);
 
 	DevMemoryFree(psMapping);
 
-	if ((psMapping->ui32Flags & PVRSRV_MEM_INTERLEAVED) != 0) {
+	if ((psMapping->ui32Flags & PVRSRV_MEM_INTERLEAVED) != 0)
 		psMapping->uSize /= 2;
-	}
 
-	if (psMapping->ui32Flags & PVRSRV_MEM_DUMMY) {
+	if (psMapping->ui32Flags & PVRSRV_MEM_DUMMY)
 		uPSize = HOST_PAGESIZE();
-	} else {
+	else
 		uPSize = psMapping->uSize;
-	}
 
 	if (pBMHeap->ui32Attribs & PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG) {
 		OSFreePages(pBMHeap->ui32Attribs,
@@ -1528,7 +1437,7 @@
 			    (void *)psMapping->CpuVAddr,
 			    psMapping->hOSMemHandle);
 	} else if (pBMHeap->ui32Attribs & PVRSRV_BACKINGSTORE_LOCALMEM_CONTIG) {
-		IMG_SYS_PHYADDR sSysPAddr;
+		struct IMG_SYS_PHYADDR sSysPAddr;
 
 		OSUnReservePhys(psMapping->CpuVAddr, uPSize,
 				pBMHeap->ui32Attribs, psMapping->hOSMemHandle);
@@ -1538,51 +1447,50 @@
 		RA_Free(pBMHeap->pLocalDevMemArena, sSysPAddr.uiAddr,
 			IMG_FALSE);
 	} else {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "BM_FreeMemory: Invalid backing store type"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "BM_FreeMemory: Invalid backing store type");
 	}
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_MAPPING), psMapping,
-		  IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct BM_MAPPING), psMapping,
+		  NULL);
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "..BM_FreeMemory (h=%08X, base=0x%x, psMapping=0x%x)",
-		 h, _base, psMapping));
+		 h, _base, psMapping);
 }
 
-PVRSRV_ERROR BM_GetPhysPageAddr(PVRSRV_KERNEL_MEM_INFO * psMemInfo,
-				IMG_DEV_VIRTADDR sDevVPageAddr,
-				IMG_DEV_PHYADDR * psDevPAddr)
+enum PVRSRV_ERROR BM_GetPhysPageAddr(struct PVRSRV_KERNEL_MEM_INFO *psMemInfo,
+				struct IMG_DEV_VIRTADDR sDevVPageAddr,
+				struct IMG_DEV_PHYADDR *psDevPAddr)
 {
-	PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
 
-	PVR_DPF((PVR_DBG_MESSAGE, "BM_GetPhysPageAddr"));
+	PVR_DPF(PVR_DBG_MESSAGE, "BM_GetPhysPageAddr");
 
 	if (!psMemInfo || !psDevPAddr) {
-		PVR_DPF((PVR_DBG_ERROR, "BM_GetPhysPageAddr: Invalid params"));
+		PVR_DPF(PVR_DBG_ERROR, "BM_GetPhysPageAddr: Invalid params");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	PVR_ASSERT((sDevVPageAddr.uiAddr & 0xFFF) == 0);
 
 	psDeviceNode =
-	    ((BM_BUF *) psMemInfo->sMemBlk.hBuffer)->pMapping->pBMHeap->
+	    ((struct BM_BUF *)psMemInfo->sMemBlk.hBuffer)->pMapping->pBMHeap->
 	    pBMContext->psDeviceNode;
 
-	*psDevPAddr =
-	    psDeviceNode->
-	    pfnMMUGetPhysPageAddr(((BM_BUF *) psMemInfo->sMemBlk.hBuffer)->
-				  pMapping->pBMHeap->pMMUHeap, sDevVPageAddr);
+	*psDevPAddr = psDeviceNode->pfnMMUGetPhysPageAddr(((struct BM_BUF *)
+				psMemInfo->sMemBlk.hBuffer)->
+				pMapping->pBMHeap->pMMUHeap, sDevVPageAddr);
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR BM_GetHeapInfo(IMG_HANDLE hDevMemHeap,
-			    PVRSRV_HEAP_INFO * psHeapInfo)
+enum PVRSRV_ERROR BM_GetHeapInfo(void *hDevMemHeap,
+			    struct PVRSRV_HEAP_INFO *psHeapInfo)
 {
-	BM_HEAP *psBMHeap = (BM_HEAP *) hDevMemHeap;
+	struct BM_HEAP *psBMHeap = (struct BM_HEAP *)hDevMemHeap;
 
-	PVR_DPF((PVR_DBG_VERBOSE, "BM_GetHeapInfo"));
+	PVR_DPF(PVR_DBG_VERBOSE, "BM_GetHeapInfo");
 
 	psHeapInfo->hDevMemHeap = hDevMemHeap;
 	psHeapInfo->sDevVAddrBase = psBMHeap->sDevArena.BaseDevVAddr;
@@ -1592,41 +1500,42 @@
 	return PVRSRV_OK;
 }
 
-MMU_CONTEXT *BM_GetMMUContext(IMG_HANDLE hDevMemHeap)
+struct MMU_CONTEXT *BM_GetMMUContext(void *hDevMemHeap)
 {
-	BM_HEAP *pBMHeap = (BM_HEAP *) hDevMemHeap;
+	struct BM_HEAP *pBMHeap = (struct BM_HEAP *)hDevMemHeap;
 
-	PVR_DPF((PVR_DBG_VERBOSE, "BM_GetMMUContext"));
+	PVR_DPF(PVR_DBG_VERBOSE, "BM_GetMMUContext");
 
 	return pBMHeap->pBMContext->psMMUContext;
 }
 
-MMU_CONTEXT *BM_GetMMUContextFromMemContext(IMG_HANDLE hDevMemContext)
+struct MMU_CONTEXT *BM_GetMMUContextFromMemContext(void *hDevMemContext)
 {
-	BM_CONTEXT *pBMContext = (BM_CONTEXT *) hDevMemContext;
+	struct BM_CONTEXT *pBMContext = (struct BM_CONTEXT *)hDevMemContext;
 
-	PVR_DPF((PVR_DBG_VERBOSE, "BM_GetMMUContextFromMemContext"));
+	PVR_DPF(PVR_DBG_VERBOSE, "BM_GetMMUContextFromMemContext");
 
 	return pBMContext->psMMUContext;
 }
 
-IMG_HANDLE BM_GetMMUHeap(IMG_HANDLE hDevMemHeap)
+void *BM_GetMMUHeap(void *hDevMemHeap)
 {
-	PVR_DPF((PVR_DBG_VERBOSE, "BM_GetMMUHeap"));
+	PVR_DPF(PVR_DBG_VERBOSE, "BM_GetMMUHeap");
 
-	return (IMG_HANDLE) ((BM_HEAP *) hDevMemHeap)->pMMUHeap;
+	return (void *)((struct BM_HEAP *)hDevMemHeap)->pMMUHeap;
 }
 
-PVRSRV_DEVICE_NODE *BM_GetDeviceNode(IMG_HANDLE hDevMemContext)
+struct PVRSRV_DEVICE_NODE *BM_GetDeviceNode(void *hDevMemContext)
 {
-	PVR_DPF((PVR_DBG_VERBOSE, "BM_GetDeviceNode"));
+	PVR_DPF(PVR_DBG_VERBOSE, "BM_GetDeviceNode");
 
-	return ((BM_CONTEXT *) hDevMemContext)->psDeviceNode;
+	return ((struct BM_CONTEXT *)hDevMemContext)->psDeviceNode;
 }
 
-IMG_HANDLE BM_GetMappingHandle(PVRSRV_KERNEL_MEM_INFO * psMemInfo)
+void *BM_GetMappingHandle(struct PVRSRV_KERNEL_MEM_INFO *psMemInfo)
 {
-	PVR_DPF((PVR_DBG_VERBOSE, "BM_GetMappingHandle"));
+	PVR_DPF(PVR_DBG_VERBOSE, "BM_GetMappingHandle");
 
-	return ((BM_BUF *) psMemInfo->sMemBlk.hBuffer)->pMapping->hOSMemHandle;
+	return ((struct BM_BUF *)
+			psMemInfo->sMemBlk.hBuffer)->pMapping->hOSMemHandle;
 }
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/buffer_manager.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/buffer_manager.h
@@ -1,189 +1,181 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef _BUFFER_MANAGER_H_
 #define _BUFFER_MANAGER_H_
 
+#include <linux/kernel.h>
 #include "img_types.h"
 #include "ra.h"
 #include "perproc.h"
 
 
-	typedef struct _BM_HEAP_ BM_HEAP;
-
-	struct _BM_MAPPING_ {
-		enum {
-			hm_wrapped = 1,
-			hm_wrapped_scatter,
-			hm_wrapped_virtaddr,
-			hm_wrapped_scatter_virtaddr,
-			hm_env,
-			hm_contiguous
-		} eCpuMemoryOrigin;
-
-		BM_HEAP *pBMHeap;
-		RA_ARENA *pArena;
-
-		IMG_CPU_VIRTADDR CpuVAddr;
-		IMG_CPU_PHYADDR CpuPAddr;
-		IMG_DEV_VIRTADDR DevVAddr;
-		IMG_SYS_PHYADDR *psSysAddr;
-		IMG_SIZE_T uSize;
-		IMG_HANDLE hOSMemHandle;
-		IMG_UINT32 ui32Flags;
-	};
-
-	typedef struct _BM_BUF_ {
-		IMG_CPU_VIRTADDR *CpuVAddr;
-		IMG_VOID *hOSMemHandle;
-		IMG_CPU_PHYADDR CpuPAddr;
-		IMG_DEV_VIRTADDR DevVAddr;
-
-		BM_MAPPING *pMapping;
-		IMG_UINT32 ui32RefCount;
-		IMG_UINTPTR_T uHashKey;
-		void *pvKernelSyncInfo;
-		void *pvPageList;
-		IMG_HANDLE hOSWrapMem;
-	} BM_BUF;
-
-	struct _BM_HEAP_ {
-		IMG_UINT32 ui32Attribs;
-		BM_CONTEXT *pBMContext;
-		RA_ARENA *pImportArena;
-		RA_ARENA *pLocalDevMemArena;
-		RA_ARENA *pVMArena;
-		DEV_ARENA_DESCRIPTOR sDevArena;
-		MMU_HEAP *pMMUHeap;
-
-		struct _BM_HEAP_ *psNext;
-	};
-
-	struct _BM_CONTEXT_ {
-		MMU_CONTEXT *psMMUContext;
-
-		BM_HEAP *psBMHeap;
-
-		BM_HEAP *psBMSharedHeap;
-
-		PVRSRV_DEVICE_NODE *psDeviceNode;
-
-		HASH_TABLE *pBufferHash;
-
-		IMG_HANDLE hResItem;
-
-		IMG_UINT32 ui32RefCount;
-
-		struct _BM_CONTEXT_ *psNext;
-	};
+struct BM_HEAP;
 
-	typedef void *BM_HANDLE;
+struct BM_MAPPING {
+	enum {
+		hm_wrapped = 1,
+		hm_wrapped_scatter,
+		hm_wrapped_virtaddr,
+		hm_wrapped_scatter_virtaddr,
+		hm_env,
+		hm_contiguous
+	} eCpuMemoryOrigin;
+
+	struct BM_HEAP *pBMHeap;
+	struct RA_ARENA *pArena;
+
+	void *CpuVAddr;
+	struct IMG_CPU_PHYADDR CpuPAddr;
+	struct IMG_DEV_VIRTADDR DevVAddr;
+	struct IMG_SYS_PHYADDR *psSysAddr;
+	size_t uSize;
+	void *hOSMemHandle;
+	u32 ui32Flags;
+};
+
+struct BM_BUF {
+	void **CpuVAddr;
+	void *hOSMemHandle;
+	struct IMG_CPU_PHYADDR CpuPAddr;
+	struct IMG_DEV_VIRTADDR DevVAddr;
+
+	struct BM_MAPPING *pMapping;
+	u32 ui32RefCount;
+	u32 uHashKey;
+	void *pvKernelSyncInfo;
+	void *pvPageList;
+	void *hOSWrapMem;
+};
+
+struct BM_HEAP {
+	u32 ui32Attribs;
+	struct BM_CONTEXT *pBMContext;
+	struct RA_ARENA *pImportArena;
+	struct RA_ARENA *pLocalDevMemArena;
+	struct RA_ARENA *pVMArena;
+	struct DEV_ARENA_DESCRIPTOR sDevArena;
+	struct MMU_HEAP *pMMUHeap;
+
+	struct BM_HEAP *psNext;
+};
+
+struct BM_CONTEXT {
+	struct MMU_CONTEXT *psMMUContext;
+	struct BM_HEAP *psBMHeap;
+	struct BM_HEAP *psBMSharedHeap;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct HASH_TABLE *pBufferHash;
+	void *hResItem;
+	u32 ui32RefCount;
+	struct BM_CONTEXT *psNext;
+};
 
-#define BP_POOL_MASK         0x7
+#define BP_POOL_MASK	 0x7
 
 #define BP_CONTIGUOUS			(1 << 3)
 #define BP_PARAMBUFFER			(1 << 4)
 
 #define BM_MAX_DEVMEM_ARENAS  2
 
-	 IMG_HANDLE
-	    BM_CreateContext(PVRSRV_DEVICE_NODE * psDeviceNode,
-			     IMG_DEV_PHYADDR * psPDDevPAddr,
-			     PVRSRV_PER_PROCESS_DATA * psPerProc,
-			     IMG_BOOL * pbCreated);
+void *BM_CreateContext(struct PVRSRV_DEVICE_NODE *psDeviceNode,
+		struct IMG_DEV_PHYADDR *psPDDevPAddr,
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+		IMG_BOOL *pbCreated);
 
-	 PVRSRV_ERROR
-	    BM_DestroyContext(IMG_HANDLE hBMContext, IMG_BOOL * pbCreated);
+struct BM_BUF *bm_get_buf_virt(void *heap_handle, void *virt_start);
+IMG_BOOL BM_IsWrapped(void *hDevMemHeap, u32 ui32Offset,
+		      struct IMG_SYS_PHYADDR sSysAddr);
 
-	 IMG_HANDLE
-	    BM_CreateHeap(IMG_HANDLE hBMContext,
-			  DEVICE_MEMORY_HEAP_INFO * psDevMemHeapInfo);
+void BM_DestroyContext(void *hBMContext);
 
-	 IMG_VOID BM_DestroyHeap(IMG_HANDLE hDevMemHeap);
+static inline void pvr_get_ctx(struct BM_CONTEXT *ctx)
+{
+	WARN_ON(!ctx->ui32RefCount);
+	ctx->ui32RefCount++;
+}
 
-	 IMG_BOOL BM_Reinitialise(PVRSRV_DEVICE_NODE * psDeviceNode);
+static inline bool pvr_put_ctx(struct BM_CONTEXT *ctx)
+{
+	BUG_ON(!ctx->ui32RefCount);
+	ctx->ui32RefCount--;
+	if (!ctx->ui32RefCount) {
+		BM_DestroyContext(ctx);
 
-	 IMG_BOOL
-	    BM_Alloc(IMG_HANDLE hDevMemHeap,
-		     IMG_DEV_VIRTADDR * psDevVAddr,
-		     IMG_SIZE_T uSize,
-		     IMG_UINT32 * pui32Flags,
-		     IMG_UINT32 uDevVAddrAlignment, BM_HANDLE * phBuf);
+		return true;
+	}
 
-	 IMG_BOOL
-	    BM_IsWrapped(IMG_HANDLE hDevMemHeap,
-			 IMG_UINT32 ui32Offset, IMG_SYS_PHYADDR sSysAddr);
+	return false;
+}
 
-	 IMG_BOOL
-	    BM_IsWrappedCheckSize(IMG_HANDLE hDevMemHeap,
-			 IMG_UINT32 ui32Offset,
-			 IMG_SYS_PHYADDR sSysAddr,
-			 IMG_UINT32 ui32ByteSize);
 
-	 IMG_BOOL
-	    BM_Wrap(IMG_HANDLE hDevMemHeap,
-		    IMG_UINT32 ui32Size,
-		    IMG_UINT32 ui32Offset,
-		    IMG_BOOL bPhysContig,
-		    IMG_SYS_PHYADDR * psSysAddr,
-		    IMG_BOOL bFreePageList,
-		    IMG_VOID * pvCPUVAddr,
-		    IMG_UINT32 * pui32Flags, BM_HANDLE * phBuf);
+void *BM_CreateHeap(void *hBMContext,
+		    struct DEVICE_MEMORY_HEAP_INFO *psDevMemHeapInfo);
+void BM_DestroyHeap(void *hDevMemHeap);
+IMG_BOOL BM_Reinitialise(struct PVRSRV_DEVICE_NODE *psDeviceNode);
+IMG_BOOL BM_Alloc(void *hDevMemHeap, struct IMG_DEV_VIRTADDR *psDevVAddr,
+		size_t uSize, u32 *pui32Flags, u32 uDevVAddrAlignment,
+		void **phBuf);
+IMG_BOOL BM_IsWrapped(void *hDevMemHeap, u32 ui32Offset,
+		struct IMG_SYS_PHYADDR sSysAddr);
 
-	void
-	 BM_Free(BM_HANDLE hBuf, IMG_UINT32 ui32Flags);
+IMG_BOOL BM_IsWrappedCheckSize(void *hDevMemHeap, u32 ui32Offset,
+		struct IMG_SYS_PHYADDR sSysAddr, u32 ui32ByteSize);
 
-	 IMG_CPU_VIRTADDR BM_HandleToCpuVaddr(BM_HANDLE hBuf);
+IMG_BOOL BM_Wrap(void *hDevMemHeap, u32 ui32Size, u32 ui32Offset,
+		IMG_BOOL bPhysContig, struct IMG_SYS_PHYADDR *psSysAddr,
+		IMG_BOOL bFreePageList, void *pvCPUVAddr, u32 *pui32Flags,
+		void **phBuf);
 
-	 IMG_DEV_VIRTADDR BM_HandleToDevVaddr(BM_HANDLE hBuf);
+void BM_Free(void *hBuf, u32 ui32Flags);
+void *BM_HandleToCpuVaddr(void *hBuf);
+struct IMG_DEV_VIRTADDR BM_HandleToDevVaddr(void *hBuf);
 
-	 IMG_SYS_PHYADDR BM_HandleToSysPaddr(BM_HANDLE hBuf);
+struct IMG_SYS_PHYADDR BM_HandleToSysPaddr(void *hBuf);
 
-	 IMG_HANDLE BM_HandleToOSMemHandle(BM_HANDLE hBuf);
+void *BM_HandleToOSMemHandle(void *hBuf);
 
-	 IMG_BOOL
-	    BM_ContiguousStatistics(IMG_UINT32 uFlags,
-				    IMG_UINT32 * pTotalBytes,
-				    IMG_UINT32 * pAvailableBytes);
+IMG_BOOL BM_ContiguousStatistics(u32 uFlags, u32 *pTotalBytes,
+		u32 *pAvailableBytes);
 
-	PVRSRV_ERROR BM_GetPhysPageAddr(PVRSRV_KERNEL_MEM_INFO * psMemInfo,
-					IMG_DEV_VIRTADDR sDevVPageAddr,
-					IMG_DEV_PHYADDR * psDevPAddr);
+enum PVRSRV_ERROR BM_GetPhysPageAddr(struct PVRSRV_KERNEL_MEM_INFO *psMemInfo,
+		struct IMG_DEV_VIRTADDR sDevVPageAddr,
+		struct IMG_DEV_PHYADDR *psDevPAddr);
 
-	PVRSRV_ERROR BM_GetHeapInfo(IMG_HANDLE hDevMemHeap,
-				    PVRSRV_HEAP_INFO * psHeapInfo);
+enum PVRSRV_ERROR BM_GetHeapInfo(void *hDevMemHeap,
+			    struct PVRSRV_HEAP_INFO *psHeapInfo);
 
-	MMU_CONTEXT *BM_GetMMUContext(IMG_HANDLE hDevMemHeap);
+struct MMU_CONTEXT *BM_GetMMUContext(void *hDevMemHeap);
 
-	MMU_CONTEXT *BM_GetMMUContextFromMemContext(IMG_HANDLE hDevMemContext);
+struct MMU_CONTEXT *BM_GetMMUContextFromMemContext(void *hDevMemContext);
 
-	IMG_HANDLE BM_GetMMUHeap(IMG_HANDLE hDevMemHeap);
+void *BM_GetMMUHeap(void *hDevMemHeap);
 
-	PVRSRV_DEVICE_NODE *BM_GetDeviceNode(IMG_HANDLE hDevMemContext);
+struct PVRSRV_DEVICE_NODE *BM_GetDeviceNode(void *hDevMemContext);
 
-	IMG_HANDLE BM_GetMappingHandle(PVRSRV_KERNEL_MEM_INFO * psMemInfo);
+void *BM_GetMappingHandle(struct PVRSRV_KERNEL_MEM_INFO *psMemInfo);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/bufferclass_example.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/bufferclass_example.c
@@ -1,80 +1,79 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #include "bufferclass_example.h"
 
-static IMG_VOID *gpvAnchor = IMG_NULL;
-static PFN_BC_GET_PVRJTABLE pfnGetPVRJTable = IMG_NULL;
+static void *gpvAnchor;
+static IMG_BOOL (*pfnGetPVRJTable)(struct PVRSRV_BC_BUFFER2SRV_KMJTABLE *);
 
-BC_EXAMPLE_DEVINFO *GetAnchorPtr(IMG_VOID)
+struct BC_EXAMPLE_DEVINFO *GetAnchorPtr(void)
 {
-	return (BC_EXAMPLE_DEVINFO *) gpvAnchor;
+	return (struct BC_EXAMPLE_DEVINFO *)gpvAnchor;
 }
 
-static IMG_VOID SetAnchorPtr(BC_EXAMPLE_DEVINFO * psDevInfo)
+static void SetAnchorPtr(struct BC_EXAMPLE_DEVINFO *psDevInfo)
 {
-	gpvAnchor = (IMG_VOID *) psDevInfo;
+	gpvAnchor = (void *) psDevInfo;
 }
 
-static PVRSRV_ERROR OpenBCDevice(IMG_HANDLE * phDevice)
+static enum PVRSRV_ERROR OpenBCDevice(void **phDevice)
 {
-	BC_EXAMPLE_DEVINFO *psDevInfo;
+	struct BC_EXAMPLE_DEVINFO *psDevInfo;
 
 	psDevInfo = GetAnchorPtr();
 
-	*phDevice = (IMG_HANDLE) psDevInfo;
+	*phDevice = (void *) psDevInfo;
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR CloseBCDevice(IMG_HANDLE hDevice)
+static enum PVRSRV_ERROR CloseBCDevice(void *hDevice)
 {
 	PVR_UNREFERENCED_PARAMETER(hDevice);
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR GetBCBuffer(IMG_HANDLE hDevice,
-				IMG_UINT32 ui32BufferNumber,
-				PVRSRV_SYNC_DATA * psSyncData,
-				IMG_HANDLE * phBuffer)
+static enum PVRSRV_ERROR GetBCBuffer(void *hDevice,
+				u32 ui32BufferNumber,
+				struct PVRSRV_SYNC_DATA *psSyncData,
+				void **phBuffer)
 {
-	BC_EXAMPLE_DEVINFO *psDevInfo;
+	struct BC_EXAMPLE_DEVINFO *psDevInfo;
 
-	if (!hDevice || !phBuffer) {
+	if (!hDevice || !phBuffer)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
-	psDevInfo = (BC_EXAMPLE_DEVINFO *) hDevice;
+	psDevInfo = (struct BC_EXAMPLE_DEVINFO *)hDevice;
 
 	if (ui32BufferNumber < psDevInfo->sBufferInfo.ui32BufferCount) {
 		psDevInfo->psSystemBuffer[ui32BufferNumber].psSyncData =
 		    psSyncData;
 		*phBuffer =
-		    (IMG_HANDLE) & psDevInfo->psSystemBuffer[ui32BufferNumber];
+		    (void *) &psDevInfo->psSystemBuffer[ui32BufferNumber];
 	} else {
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
@@ -82,92 +81,84 @@
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR GetBCInfo(IMG_HANDLE hDevice, BUFFER_INFO * psBCInfo)
+static enum PVRSRV_ERROR GetBCInfo(void *hDevice, struct BUFFER_INFO *psBCInfo)
 {
-	BC_EXAMPLE_DEVINFO *psDevInfo;
+	struct BC_EXAMPLE_DEVINFO *psDevInfo;
 
-	if (!hDevice || !psBCInfo) {
+	if (!hDevice || !psBCInfo)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
-	psDevInfo = (BC_EXAMPLE_DEVINFO *) hDevice;
+	psDevInfo = (struct BC_EXAMPLE_DEVINFO *)hDevice;
 
 	*psBCInfo = psDevInfo->sBufferInfo;
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR GetBCBufferAddr(IMG_HANDLE hDevice,
-				    IMG_HANDLE hBuffer,
-				    IMG_SYS_PHYADDR ** ppsSysAddr,
-				    IMG_UINT32 * pui32ByteSize,
-				    IMG_VOID ** ppvCpuVAddr,
-				    IMG_HANDLE * phOSMapInfo,
-				    IMG_BOOL * pbIsContiguous)
+static enum PVRSRV_ERROR GetBCBufferAddr(void *hDevice,
+				    void *hBuffer,
+				    struct IMG_SYS_PHYADDR **ppsSysAddr,
+				    u32 *pui32ByteSize,
+				    void **ppvCpuVAddr,
+				    void **phOSMapInfo,
+				    IMG_BOOL *pbIsContiguous)
 {
-	BC_EXAMPLE_BUFFER *psBuffer;
+	struct BC_EXAMPLE_BUFFER *psBuffer;
 
-	if (!hDevice || !hBuffer || !ppsSysAddr || !pui32ByteSize) {
+	if (!hDevice || !hBuffer || !ppsSysAddr || !pui32ByteSize)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
-	psBuffer = (BC_EXAMPLE_BUFFER *) hBuffer;
+	psBuffer = (struct BC_EXAMPLE_BUFFER *)hBuffer;
 
 	*ppsSysAddr = &psBuffer->sPageAlignSysAddr;
 	*ppvCpuVAddr = psBuffer->sCPUVAddr;
 
 	*pui32ByteSize = psBuffer->ui32Size;
 
-	*phOSMapInfo = IMG_NULL;
+	*phOSMapInfo = NULL;
 	*pbIsContiguous = IMG_TRUE;
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR BC_Example_Init(IMG_VOID)
+enum PVRSRV_ERROR BC_Example_Init(void)
 {
-	BC_EXAMPLE_DEVINFO *psDevInfo;
-	IMG_CPU_PHYADDR sSystemBufferCPUPAddr;
-	IMG_UINT32 i;
+	struct BC_EXAMPLE_DEVINFO *psDevInfo;
+	struct IMG_CPU_PHYADDR sSystemBufferCPUPAddr;
+	u32 i;
 
 	psDevInfo = GetAnchorPtr();
 
-	if (psDevInfo == IMG_NULL) {
+	if (psDevInfo == NULL) {
 
-		psDevInfo =
-		    (BC_EXAMPLE_DEVINFO *)
-		    BCAllocKernelMem(sizeof(BC_EXAMPLE_DEVINFO));
+		psDevInfo = (struct BC_EXAMPLE_DEVINFO *)
+			BCAllocKernelMem(sizeof(struct BC_EXAMPLE_DEVINFO));
 
-		if (!psDevInfo) {
+		if (!psDevInfo)
 			return PVRSRV_ERROR_OUT_OF_MEMORY;
-		}
 
-		SetAnchorPtr((IMG_VOID *) psDevInfo);
+		SetAnchorPtr((void *) psDevInfo);
 
 		psDevInfo->ui32RefCount = 0;
 
-		if (BCOpenPVRServices(&psDevInfo->hPVRServices) != PVRSRV_OK) {
+		if (BCOpenPVRServices(&psDevInfo->hPVRServices) != PVRSRV_OK)
 			return PVRSRV_ERROR_INIT_FAILURE;
-		}
 		if (BCGetLibFuncAddr
 		    (psDevInfo->hPVRServices, "PVRGetBufferClassJTable",
-		     &pfnGetPVRJTable) != PVRSRV_OK) {
+		     &pfnGetPVRJTable) != PVRSRV_OK)
 			return PVRSRV_ERROR_INIT_FAILURE;
-		}
 
-		if (!(*pfnGetPVRJTable) (&psDevInfo->sPVRJTable)) {
+		if (!(*pfnGetPVRJTable) (&psDevInfo->sPVRJTable))
 			return PVRSRV_ERROR_INIT_FAILURE;
-		}
 
 		psDevInfo->ui32NumBuffers = 0;
 
 		psDevInfo->psSystemBuffer =
-		    BCAllocKernelMem(sizeof(BC_EXAMPLE_BUFFER) *
+		    BCAllocKernelMem(sizeof(struct BC_EXAMPLE_BUFFER) *
 				     BC_EXAMPLE_NUM_BUFFERS);
 
-		if (!psDevInfo->psSystemBuffer) {
+		if (!psDevInfo->psSystemBuffer)
 			return PVRSRV_ERROR_OUT_OF_MEMORY;
-		}
 
 		psDevInfo->sBufferInfo.pixelformat = BC_EXAMPLE_PIXELFORMAT;
 		psDevInfo->sBufferInfo.ui32Width = BC_EXAMPLE_WIDTH;
@@ -179,16 +170,15 @@
 		    PVRSRV_BC_FLAGS_YUVCSC_BT601;
 
 		for (i = 0; i < BC_EXAMPLE_NUM_BUFFERS; i++) {
-			IMG_UINT32 ui32Size =
+			u32 ui32Size =
 			    BC_EXAMPLE_HEIGHT * BC_EXAMPLE_STRIDE;
 
 			if (psDevInfo->sBufferInfo.pixelformat ==
-			    PVRSRV_PIXEL_FORMAT_NV12) {
+			    PVRSRV_PIXEL_FORMAT_NV12)
 
 				ui32Size +=
 				    ((BC_EXAMPLE_STRIDE >> 1) *
 				     (BC_EXAMPLE_HEIGHT >> 1) << 1);
-			}
 
 			if (BCAllocContigMemory(ui32Size,
 						&psDevInfo->psSystemBuffer[i].
@@ -196,9 +186,8 @@
 						&psDevInfo->psSystemBuffer[i].
 						sCPUVAddr,
 						&sSystemBufferCPUPAddr) !=
-			    PVRSRV_OK) {
+			    PVRSRV_OK)
 				break;
-			}
 
 			psDevInfo->ui32NumBuffers++;
 
@@ -208,14 +197,14 @@
 			psDevInfo->psSystemBuffer[i].sPageAlignSysAddr.uiAddr =
 			    (psDevInfo->psSystemBuffer[i].sSysAddr.
 			     uiAddr & 0xFFFFF000);
-			psDevInfo->psSystemBuffer[i].psSyncData = IMG_NULL;
+			psDevInfo->psSystemBuffer[i].psSyncData = NULL;
 		}
 
 		psDevInfo->sBufferInfo.ui32BufferCount =
 		    psDevInfo->ui32NumBuffers;
 
 		psDevInfo->sBCJTable.ui32TableSize =
-		    sizeof(PVRSRV_BC_SRV2BUFFER_KMJTABLE);
+		    sizeof(struct PVRSRV_BC_SRV2BUFFER_KMJTABLE);
 		psDevInfo->sBCJTable.pfnOpenBCDevice = OpenBCDevice;
 		psDevInfo->sBCJTable.pfnCloseBCDevice = CloseBCDevice;
 		psDevInfo->sBCJTable.pfnGetBCBuffer = GetBCBuffer;
@@ -225,9 +214,8 @@
 		if (psDevInfo->sPVRJTable.
 		    pfnPVRSRVRegisterBCDevice(&psDevInfo->sBCJTable,
 					      &psDevInfo->ui32DeviceID) !=
-		    PVRSRV_OK) {
+		    PVRSRV_OK)
 			return PVRSRV_ERROR_DEVICE_REGISTER_FAILED;
-		}
 	}
 
 	psDevInfo->ui32RefCount++;
@@ -235,35 +223,33 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR BC_Example_Deinit(IMG_VOID)
+enum PVRSRV_ERROR BC_Example_Deinit(void)
 {
-	BC_EXAMPLE_DEVINFO *psDevInfo;
-	IMG_UINT32 i;
+	struct BC_EXAMPLE_DEVINFO *psDevInfo;
+	u32 i;
 	psDevInfo = GetAnchorPtr();
 
-	if (psDevInfo == IMG_NULL) {
+	if (psDevInfo == NULL)
 		return PVRSRV_ERROR_GENERIC;
-	}
 
 	psDevInfo->ui32RefCount--;
 
 	if (psDevInfo->ui32RefCount == 0) {
 
-		PVRSRV_BC_BUFFER2SRV_KMJTABLE *psJTable =
+		struct PVRSRV_BC_BUFFER2SRV_KMJTABLE *psJTable =
 		    &psDevInfo->sPVRJTable;
 
 		if (psJTable->
 		    pfnPVRSRVRemoveBCDevice(psDevInfo->ui32DeviceID) !=
-		    PVRSRV_OK) {
+		    PVRSRV_OK)
 			return PVRSRV_ERROR_GENERIC;
-		}
 
 		if (BCClosePVRServices(psDevInfo->hPVRServices) != PVRSRV_OK) {
-			psDevInfo->hPVRServices = IMG_NULL;
+			psDevInfo->hPVRServices = NULL;
 			return PVRSRV_ERROR_GENERIC;
 		}
 
-		for (i = 0; i < psDevInfo->ui32NumBuffers; i++) {
+		for (i = 0; i < psDevInfo->ui32NumBuffers; i++)
 			BCFreeContigMemory(psDevInfo->psSystemBuffer[i].
 					   ui32Size,
 					   psDevInfo->psSystemBuffer[i].
@@ -273,11 +259,10 @@
 					   SysPAddrToCpuPAddrBC(psDevInfo->
 								psSystemBuffer
 								[i].sSysAddr));
-		}
 
 		BCFreeKernelMem(psDevInfo);
 
-		SetAnchorPtr(IMG_NULL);
+		SetAnchorPtr(NULL);
 	}
 
 	return PVRSRV_OK;
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/bufferclass_example.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/bufferclass_example.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -32,9 +32,6 @@
 #include "kernelbuffer.h"
 
 
-	extern IMG_IMPORT IMG_BOOL
-	    PVRGetBufferClassJTable(PVRSRV_BC_BUFFER2SRV_KMJTABLE * psJTable);
-
 #define BC_EXAMPLE_NUM_BUFFERS	3
 
 #define YUV420 1
@@ -56,62 +53,50 @@
 
 #define BC_EXAMPLE_DEVICEID		 0
 
-	typedef struct BC_EXAMPLE_BUFFER_TAG {
-		IMG_UINT32 ui32Size;
-		IMG_HANDLE hMemHandle;
-		IMG_SYS_PHYADDR sSysAddr;
-		IMG_SYS_PHYADDR sPageAlignSysAddr;
-		IMG_CPU_VIRTADDR sCPUVAddr;
-		PVRSRV_SYNC_DATA *psSyncData;
-		struct BC_EXAMPLE_BUFFER_TAG *psNext;
-	} BC_EXAMPLE_BUFFER;
-
-	typedef struct BC_EXAMPLE_DEVINFO_TAG {
-		IMG_UINT32 ui32DeviceID;
-
-		BC_EXAMPLE_BUFFER *psSystemBuffer;
-
-		BUFFER_INFO sBufferInfo;
-
-		IMG_UINT32 ui32NumBuffers;
-
-		PVRSRV_BC_BUFFER2SRV_KMJTABLE sPVRJTable;
-
-		PVRSRV_BC_SRV2BUFFER_KMJTABLE sBCJTable;
-
-		IMG_HANDLE hPVRServices;
-
-		IMG_UINT32 ui32RefCount;
-
-	} BC_EXAMPLE_DEVINFO;
-
-	PVRSRV_ERROR BC_Example_Init(IMG_VOID);
-	PVRSRV_ERROR BC_Example_Deinit(IMG_VOID);
-
-	PVRSRV_ERROR BCOpenPVRServices(IMG_HANDLE * phPVRServices);
-	PVRSRV_ERROR BCClosePVRServices(IMG_HANDLE hPVRServices);
-
-	IMG_VOID *BCAllocKernelMem(IMG_UINT32 ui32Size);
-	IMG_VOID BCFreeKernelMem(IMG_VOID * pvMem);
-
-	PVRSRV_ERROR BCAllocContigMemory(IMG_UINT32 ui32Size,
-					 IMG_HANDLE * phMemHandle,
-					 IMG_CPU_VIRTADDR * pLinAddr,
-					 IMG_CPU_PHYADDR * pPhysAddr);
-	IMG_VOID BCFreeContigMemory(IMG_UINT32 ui32Size,
-				    IMG_HANDLE hMemHandle,
-				    IMG_CPU_VIRTADDR LinAddr,
-				    IMG_CPU_PHYADDR PhysAddr);
-
-	IMG_SYS_PHYADDR CpuPAddrToSysPAddrBC(IMG_CPU_PHYADDR cpu_paddr);
-	IMG_CPU_PHYADDR SysPAddrToCpuPAddrBC(IMG_SYS_PHYADDR sys_paddr);
-
-	IMG_VOID *MapPhysAddr(IMG_SYS_PHYADDR sSysAddr, IMG_UINT32 ui32Size);
-	IMG_VOID UnMapPhysAddr(IMG_VOID * pvAddr, IMG_UINT32 ui32Size);
-
-	PVRSRV_ERROR BCGetLibFuncAddr(IMG_HANDLE hExtDrv,
-				      IMG_CHAR * szFunctionName,
-				      PFN_BC_GET_PVRJTABLE * ppfnFuncTable);
-	BC_EXAMPLE_DEVINFO *GetAnchorPtr(IMG_VOID);
+struct BC_EXAMPLE_BUFFER {
+	u32 ui32Size;
+	void *hMemHandle;
+	struct IMG_SYS_PHYADDR sSysAddr;
+	struct IMG_SYS_PHYADDR sPageAlignSysAddr;
+	void *sCPUVAddr;
+	struct PVRSRV_SYNC_DATA *psSyncData;
+	struct BC_EXAMPLE_BUFFER *psNext;
+};
+
+struct BC_EXAMPLE_DEVINFO {
+	u32 ui32DeviceID;
+	struct BC_EXAMPLE_BUFFER *psSystemBuffer;
+	struct BUFFER_INFO sBufferInfo;
+	u32 ui32NumBuffers;
+	struct PVRSRV_BC_BUFFER2SRV_KMJTABLE sPVRJTable;
+	struct PVRSRV_BC_SRV2BUFFER_KMJTABLE sBCJTable;
+	void *hPVRServices;
+	u32 ui32RefCount;
+};
+
+enum PVRSRV_ERROR BC_Example_Init(void);
+enum PVRSRV_ERROR BC_Example_Deinit(void);
+
+enum PVRSRV_ERROR BCOpenPVRServices(void **phPVRServices);
+enum PVRSRV_ERROR BCClosePVRServices(void *hPVRServices);
+
+void *BCAllocKernelMem(u32 ui32Size);
+void BCFreeKernelMem(void *pvMem);
+
+enum PVRSRV_ERROR BCAllocContigMemory(u32 ui32Size, void **phMemHandle,
+				 void **pLinAddr,
+				 struct IMG_CPU_PHYADDR *pPhysAddr);
+void BCFreeContigMemory(u32 ui32Size, void *hMemHandle, void *LinAddr,
+			struct IMG_CPU_PHYADDR PhysAddr);
+
+struct IMG_SYS_PHYADDR CpuPAddrToSysPAddrBC(struct IMG_CPU_PHYADDR cpu_paddr);
+struct IMG_CPU_PHYADDR SysPAddrToCpuPAddrBC(struct IMG_SYS_PHYADDR sys_paddr);
+
+void *MapPhysAddr(struct IMG_SYS_PHYADDR sSysAddr, u32 ui32Size);
+void UnMapPhysAddr(void *pvAddr, u32 ui32Size);
+
+enum PVRSRV_ERROR BCGetLibFuncAddr(void *hExtDrv, char *szFunctionName,
+	 IMG_BOOL (**ppfnFuncTable)(struct PVRSRV_BC_BUFFER2SRV_KMJTABLE *));
+struct BC_EXAMPLE_DEVINFO *GetAnchorPtr(void);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/bufferclass_example_linux.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/bufferclass_example_linux.c
@@ -1,39 +1,41 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/fs.h>
-#include <asm/uaccess.h>
-#include <asm/io.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
 
 #include <linux/dma-mapping.h>
 
+#include "pvr_bridge_km.h"
 #include "bufferclass_example.h"
 #include "bufferclass_example_linux.h"
+#include "bufferclass_example_private.h"
 #include "pvrmodule.h"
 
 #define DEVNAME	"bc_example"
@@ -41,87 +43,33 @@
 
 MODULE_SUPPORTED_DEVICE(DEVNAME);
 
-int BC_Example_Bridge(struct inode *inode, struct file *file, unsigned int cmd,
-		      unsigned long arg);
-int FillBuffer(unsigned int ui32BufferIndex);
-int GetBufferCount(unsigned int *pui32BufferCount);
-
 static int AssignedMajorNumber;
 
-static struct file_operations bufferclass_example_fops = {
-ioctl:	BC_Example_Bridge,
-};
-
 #define unref__ __attribute__ ((unused))
 
 
-static int __init BC_Example_ModInit(void)
-{
-
-
-	AssignedMajorNumber =
-	    register_chrdev(0, DEVNAME, &bufferclass_example_fops);
-
-	if (AssignedMajorNumber <= 0) {
-		printk(KERN_ERR DRVNAME
-		       ": BC_Example_ModInit: unable to get major number\n");
-
-		goto ExitDisable;
-	}
-#if defined(DEBUG)
-	printk(KERN_ERR DRVNAME ": BC_Example_ModInit: major device %d\n",
-	       AssignedMajorNumber);
-#endif
-
-
-	if (BC_Example_Init() != PVRSRV_OK) {
-		printk(KERN_ERR DRVNAME
-		       ": BC_Example_ModInit: can't init device\n");
-		goto ExitUnregister;
-	}
-
-	return 0;
-
-ExitUnregister:
-	unregister_chrdev(AssignedMajorNumber, DEVNAME);
-ExitDisable:
-	return -EBUSY;
-}
-
-static void __exit BC_Example_ModCleanup(void)
-{
-	unregister_chrdev(AssignedMajorNumber, DEVNAME);
-
-	if (BC_Example_Deinit() != PVRSRV_OK) {
-		printk(KERN_ERR DRVNAME
-		       ": BC_Example_ModCleanup: can't deinit device\n");
-	}
-
-}
 
-IMG_VOID *BCAllocKernelMem(IMG_UINT32 ui32Size)
+void *BCAllocKernelMem(u32 ui32Size)
 {
 	return kmalloc(ui32Size, GFP_KERNEL);
 }
 
-IMG_VOID BCFreeKernelMem(IMG_VOID * pvMem)
+void BCFreeKernelMem(void *pvMem)
 {
 	kfree(pvMem);
 }
 
-PVRSRV_ERROR BCAllocContigMemory(IMG_UINT32 ui32Size,
-				 IMG_HANDLE unref__ * phMemHandle,
-				 IMG_CPU_VIRTADDR * pLinAddr,
-				 IMG_CPU_PHYADDR * pPhysAddr)
+enum PVRSRV_ERROR BCAllocContigMemory(u32 ui32Size, void **unref__ phMemHandle,
+				 void **pLinAddr,
+				 struct IMG_CPU_PHYADDR *pPhysAddr)
 {
 	dma_addr_t dma;
-	IMG_VOID *pvLinAddr;
+	void *pvLinAddr;
 
 	pvLinAddr = dma_alloc_coherent(NULL, ui32Size, &dma, GFP_KERNEL);
 
-	if (pvLinAddr == IMG_NULL) {
+	if (pvLinAddr == NULL)
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
-	}
 
 	pPhysAddr->uiAddr = dma;
 	*pLinAddr = pvLinAddr;
@@ -129,47 +77,44 @@
 	return PVRSRV_OK;
 }
 
-void BCFreeContigMemory(IMG_UINT32 ui32Size,
-			IMG_HANDLE unref__ hMemHandle,
-			IMG_CPU_VIRTADDR LinAddr, IMG_CPU_PHYADDR PhysAddr)
+void BCFreeContigMemory(u32 ui32Size, void *unref__ hMemHandle,
+			void *LinAddr, struct IMG_CPU_PHYADDR PhysAddr)
 {
 	dma_free_coherent(NULL, ui32Size, LinAddr,
 			  (dma_addr_t) PhysAddr.uiAddr);
 }
 
-IMG_SYS_PHYADDR CpuPAddrToSysPAddrBC(IMG_CPU_PHYADDR cpu_paddr)
+struct IMG_SYS_PHYADDR CpuPAddrToSysPAddrBC(struct IMG_CPU_PHYADDR cpu_paddr)
 {
-	IMG_SYS_PHYADDR sys_paddr;
+	struct IMG_SYS_PHYADDR sys_paddr;
 
 	sys_paddr.uiAddr = cpu_paddr.uiAddr;
 	return sys_paddr;
 }
 
-IMG_CPU_PHYADDR SysPAddrToCpuPAddrBC(IMG_SYS_PHYADDR sys_paddr)
+struct IMG_CPU_PHYADDR SysPAddrToCpuPAddrBC(struct IMG_SYS_PHYADDR sys_paddr)
 {
 
-	IMG_CPU_PHYADDR cpu_paddr;
+	struct IMG_CPU_PHYADDR cpu_paddr;
 
 	cpu_paddr.uiAddr = sys_paddr.uiAddr;
 	return cpu_paddr;
 }
 
-PVRSRV_ERROR BCOpenPVRServices(IMG_HANDLE * phPVRServices)
+enum PVRSRV_ERROR BCOpenPVRServices(void **phPVRServices)
 {
-
-	*phPVRServices = 0;
+	*phPVRServices = NULL;
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR BCClosePVRServices(IMG_HANDLE unref__ hPVRServices)
+enum PVRSRV_ERROR BCClosePVRServices(void *unref__ hPVRServices)
 {
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR BCGetLibFuncAddr(IMG_HANDLE unref__ hExtDrv,
-			      IMG_CHAR * szFunctionName,
-			      PFN_BC_GET_PVRJTABLE * ppfnFuncTable)
+enum PVRSRV_ERROR BCGetLibFuncAddr(void *unref__ hExtDrv, char *szFunctionName,
+	  IMG_BOOL (**ppfnFuncTable)(struct PVRSRV_BC_BUFFER2SRV_KMJTABLE *))
 {
 	if (strcmp("PVRGetBufferClassJTable", szFunctionName) != 0)
 		return PVRSRV_ERROR_INVALID_PARAMS;
@@ -184,10 +129,11 @@
 {
 	int err = -EFAULT;
 	int command = _IOC_NR(cmd);
-	BC_Example_ioctl_package *psBridge = (BC_Example_ioctl_package *) arg;
+	struct BC_Example_ioctl_package *psBridge =
+					(struct BC_Example_ioctl_package *)arg;
 
 	if (!access_ok
-	    (VERIFY_WRITE, psBridge, sizeof(BC_Example_ioctl_package)))
+	    (VERIFY_WRITE, psBridge, sizeof(struct BC_Example_ioctl_package)))
 		return err;
 
 	switch (command) {
@@ -211,5 +157,52 @@
 	return 0;
 }
 
+const static struct file_operations bufferclass_example_fops = {
+	.ioctl	= BC_Example_Bridge,
+};
+
+static int __init BC_Example_ModInit(void)
+{
+
+
+	AssignedMajorNumber =
+	    register_chrdev(0, DEVNAME, &bufferclass_example_fops);
+
+	if (AssignedMajorNumber <= 0) {
+		printk(KERN_ERR DRVNAME
+		       ": BC_Example_ModInit: unable to get major number\n");
+
+		goto ExitDisable;
+	}
+#if defined(DEBUG)
+	printk(KERN_ERR DRVNAME ": BC_Example_ModInit: major device %d\n",
+	       AssignedMajorNumber);
+#endif
+
+
+	if (BC_Example_Init() != PVRSRV_OK) {
+		printk(KERN_ERR DRVNAME
+		       ": BC_Example_ModInit: can't init device\n");
+		goto ExitUnregister;
+	}
+
+	return 0;
+
+ExitUnregister:
+	unregister_chrdev(AssignedMajorNumber, DEVNAME);
+ExitDisable:
+	return -EBUSY;
+}
+
+static void __exit BC_Example_ModCleanup(void)
+{
+	unregister_chrdev(AssignedMajorNumber, DEVNAME);
+
+	if (BC_Example_Deinit() != PVRSRV_OK)
+		printk(KERN_ERR DRVNAME
+		       ": BC_Example_ModCleanup: can't deinit device\n");
+
+}
+
 module_init(BC_Example_ModInit);
 module_exit(BC_Example_ModCleanup);
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/bufferclass_example_linux.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/bufferclass_example_linux.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -29,15 +29,16 @@
 
 #include <linux/ioctl.h>
 
-typedef struct BC_Example_ioctl_package_TAG {
+struct BC_Example_ioctl_package {
 	int inputparam;
 	int outputparam;
 
-} BC_Example_ioctl_package;
+};
 
-#define BC_EXAMPLE_IOC_GID      'g'
+#define BC_EXAMPLE_IOC_GID			'g'
 
-#define BC_EXAMPLE_IOWR(INDEX)  _IOWR(BC_EXAMPLE_IOC_GID, INDEX, BC_Example_ioctl_package)
+#define BC_EXAMPLE_IOWR(INDEX)  \
+	_IOWR(BC_EXAMPLE_IOC_GID, INDEX, struct BC_Example_ioctl_package)
 
 #define BC_Example_ioctl_fill_buffer		BC_EXAMPLE_IOWR(0)
 #define BC_Example_ioctl_get_buffer_count	BC_EXAMPLE_IOWR(1)
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/bufferclass_example_private.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/bufferclass_example_private.c
@@ -1,55 +1,55 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #include "bufferclass_example.h"
+#include "bufferclass_example_private.h"
 
-#define MIN(a,b) ((a)<(b)?(a):(b))
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
 
-void FillYUV420Image(void *pvDest, int width, int height, int bytestride)
+static void FillYUV420Image(void *pvDest, int width, int height, int bytestride)
 {
-	static int iPhase = 0;
+	static int iPhase;
 	int i, j;
 	unsigned char u, v, y;
 	unsigned char *pui8y = (unsigned char *)pvDest;
 	unsigned short *pui16uv;
 	unsigned int count = 0;
 
-	for (j = 0; j < height; j++) {
+	for (j = 0; j < height; j++)
 		for (i = 0; i < width; i++) {
 			y = (((i + iPhase) >> 6) % (2) == 0) ? 0x7f : 0x00;
 
 			pui8y[count++] = y;
 		}
-	}
 
 	pui16uv =
 	    (unsigned short *)((unsigned char *)pvDest + (width * height));
 	count = 0;
 
-	for (j = 0; j < height; j += 2) {
+	for (j = 0; j < height; j += 2)
 		for (i = 0; i < width; i += 2) {
 			u = (j <
 			     (height / 2)) ? ((i <
@@ -71,20 +71,19 @@
 			pui16uv[count++] = (v << 8) | u;
 
 		}
-	}
 
 	iPhase++;
 }
 
-void FillYUV422Image(void *pvDest, int width, int height, int bytestride)
+static void FillYUV422Image(void *pvDest, int width, int height, int bytestride)
 {
-	static int iPhase = 0;
+	static int iPhase;
 	int x, y;
 	unsigned char u, v, y0, y1;
 	unsigned int *pui32yuv = (unsigned int *)pvDest;
 	unsigned int count = 0;
 
-	for (y = 0; y < height; y++) {
+	for (y = 0; y < height; y++)
 		for (x = 0; x < width; x += 2) {
 			u = (y <
 			     (height / 2)) ? ((x <
@@ -110,19 +109,18 @@
 			    (y1 << 24) | (v << 16) | (y0 << 8) | u;
 
 		}
-	}
 
 	iPhase++;
 }
 
-void FillRGB565Image(void *pvDest, int width, int height, int bytestride)
+static void FillRGB565Image(void *pvDest, int width, int height, int bytestride)
 {
 	int i, Count;
 	unsigned long *pui32Addr = (unsigned long *)pvDest;
 	unsigned short *pui16Addr = (unsigned short *)pvDest;
 	unsigned long Colour32;
 	unsigned short Colour16;
-	static unsigned char Colour8 = 0;
+	static unsigned char Colour8;
 
 	Colour16 =
 	    (Colour8 >> 3) | ((Colour8 >> 2) << 5) | ((Colour8 >> 3) << 11);
@@ -130,9 +128,8 @@
 
 	Count = (height * bytestride) >> 2;
 
-	for (i = 0; i < Count; i++) {
+	for (i = 0; i < Count; i++)
 		pui32Addr[i] = Colour32;
-	}
 
 	Count = height;
 
@@ -150,23 +147,21 @@
 	    (unsigned long *)((unsigned char *)pvDest +
 			      (bytestride * (MIN(height - 1, 0xFF) - Colour8)));
 
-	for (i = 0; i < Count; i++) {
+	for (i = 0; i < Count; i++)
 		pui32Addr[i] = 0x001F001F;
-	}
 
 	Colour8 = (Colour8 + 1) % MIN(height - 1, 0xFF);
 }
 
 int FillBuffer(unsigned int ui32BufferIndex)
 {
-	BC_EXAMPLE_DEVINFO *psDevInfo = GetAnchorPtr();
-	BC_EXAMPLE_BUFFER *psBuffer;
-	BUFFER_INFO *psBufferInfo;
-	PVRSRV_SYNC_DATA *psSyncData;
+	struct BC_EXAMPLE_DEVINFO *psDevInfo = GetAnchorPtr();
+	struct BC_EXAMPLE_BUFFER *psBuffer;
+	struct BUFFER_INFO *psBufferInfo;
+	struct PVRSRV_SYNC_DATA *psSyncData;
 
-	if (psDevInfo == IMG_NULL) {
+	if (psDevInfo == NULL)
 		return -1;
-	}
 
 	psBuffer = &psDevInfo->psSystemBuffer[ui32BufferIndex];
 	psBufferInfo = &psDevInfo->sBufferInfo;
@@ -176,9 +171,8 @@
 	if (psSyncData) {
 
 		if (psSyncData->ui32ReadOpsPending !=
-		    psSyncData->ui32ReadOpsComplete) {
+		    psSyncData->ui32ReadOpsComplete)
 			return -1;
-		}
 
 		psSyncData->ui32WriteOpsPending++;
 	}
@@ -205,20 +199,18 @@
 		}
 	}
 
-	if (psSyncData) {
+	if (psSyncData)
 		psSyncData->ui32WriteOpsComplete++;
-	}
 
 	return 0;
 }
 
 int GetBufferCount(unsigned int *pui32BufferCount)
 {
-	BC_EXAMPLE_DEVINFO *psDevInfo = GetAnchorPtr();
+	struct BC_EXAMPLE_DEVINFO *psDevInfo = GetAnchorPtr();
 
-	if (psDevInfo == IMG_NULL) {
+	if (psDevInfo == NULL)
 		return -1;
-	}
 
 	*pui32BufferCount = psDevInfo->sBufferInfo.ui32BufferCount;
 
--- /dev/null
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/bufferclass_example_private.h
@@ -0,0 +1,33 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
+ *
+ ******************************************************************************/
+
+#ifndef __BC_EXAMPLE_PRIVATE_H__
+#define __BC_EXAMPLE_PRIVATE_H__
+
+int FillBuffer(unsigned int ui32BufferIndex);
+int GetBufferCount(unsigned int *pui32BufferCount);
+
+#endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/dbgdrvif.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/dbgdrvif.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -34,250 +34,276 @@
 #define DEBUG_CAPMODE_HOTKEY			0x00000004
 
 #define DEBUG_OUTMODE_STANDARDDBG		0x00000001
-#define DEBUG_OUTMODE_MONO				0x00000002
+#define DEBUG_OUTMODE_MONO			0x00000002
 #define DEBUG_OUTMODE_STREAMENABLE		0x00000004
-#define DEBUG_OUTMODE_ASYNC				0x00000008
-#define DEBUG_OUTMODE_SGXVGA            0x00000010
+#define DEBUG_OUTMODE_ASYNC			0x00000008
+#define DEBUG_OUTMODE_SGXVGA			0x00000010
 
-#define DEBUG_FLAGS_USE_NONPAGED_MEM	0x00000001
-#define DEBUG_FLAGS_NO_BUF_EXPANDSION	0x00000002
+#define DEBUG_FLAGS_USE_NONPAGED_MEM		0x00000001
+#define DEBUG_FLAGS_NO_BUF_EXPANDSION		0x00000002
 #define DEBUG_FLAGS_ENABLESAMPLE		0x00000004
 
 #define DEBUG_FLAGS_TEXTSTREAM			0x80000000
 
-#define DEBUG_LEVEL_0					0x00000001
-#define DEBUG_LEVEL_1					0x00000003
-#define DEBUG_LEVEL_2					0x00000007
-#define DEBUG_LEVEL_3					0x0000000F
-#define DEBUG_LEVEL_4					0x0000001F
-#define DEBUG_LEVEL_5					0x0000003F
-#define DEBUG_LEVEL_6					0x0000007F
-#define DEBUG_LEVEL_7					0x000000FF
-#define DEBUG_LEVEL_8					0x000001FF
-#define DEBUG_LEVEL_9					0x000003FF
-#define DEBUG_LEVEL_10					0x000007FF
-#define DEBUG_LEVEL_11					0x00000FFF
-
-#define DEBUG_LEVEL_SEL0				0x00000001
-#define DEBUG_LEVEL_SEL1				0x00000002
-#define DEBUG_LEVEL_SEL2				0x00000004
-#define DEBUG_LEVEL_SEL3				0x00000008
-#define DEBUG_LEVEL_SEL4				0x00000010
-#define DEBUG_LEVEL_SEL5				0x00000020
-#define DEBUG_LEVEL_SEL6				0x00000040
-#define DEBUG_LEVEL_SEL7				0x00000080
-#define DEBUG_LEVEL_SEL8				0x00000100
-#define DEBUG_LEVEL_SEL9				0x00000200
-#define DEBUG_LEVEL_SEL10				0x00000400
-#define DEBUG_LEVEL_SEL11				0x00000800
+#define DEBUG_LEVEL_0				0x00000001
+#define DEBUG_LEVEL_1				0x00000003
+#define DEBUG_LEVEL_2				0x00000007
+#define DEBUG_LEVEL_3				0x0000000F
+#define DEBUG_LEVEL_4				0x0000001F
+#define DEBUG_LEVEL_5				0x0000003F
+#define DEBUG_LEVEL_6				0x0000007F
+#define DEBUG_LEVEL_7				0x000000FF
+#define DEBUG_LEVEL_8				0x000001FF
+#define DEBUG_LEVEL_9				0x000003FF
+#define DEBUG_LEVEL_10				0x000007FF
+#define DEBUG_LEVEL_11				0x00000FFF
+
+#define DEBUG_LEVEL_SEL0			0x00000001
+#define DEBUG_LEVEL_SEL1			0x00000002
+#define DEBUG_LEVEL_SEL2			0x00000004
+#define DEBUG_LEVEL_SEL3			0x00000008
+#define DEBUG_LEVEL_SEL4			0x00000010
+#define DEBUG_LEVEL_SEL5			0x00000020
+#define DEBUG_LEVEL_SEL6			0x00000040
+#define DEBUG_LEVEL_SEL7			0x00000080
+#define DEBUG_LEVEL_SEL8			0x00000100
+#define DEBUG_LEVEL_SEL9			0x00000200
+#define DEBUG_LEVEL_SEL10			0x00000400
+#define DEBUG_LEVEL_SEL11			0x00000800
 
 #define DEBUG_SERVICE_IOCTL_BASE		0x800
-#define DEBUG_SERVICE_CREATESTREAM		CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x01, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_DESTROYSTREAM		CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x02, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_GETSTREAM			CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x03, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_WRITESTRING		CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x04, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_READSTRING		CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x05, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_WRITE				CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x06, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_READ				CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x07, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_SETDEBUGMODE		CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x08, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_SETDEBUGOUTMODE	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x09, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_SETDEBUGLEVEL		CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x0A, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_SETFRAME			CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x0B, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_GETFRAME			CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x0C, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_OVERRIDEMODE		CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x0D, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_DEFAULTMODE		CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x0E, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_GETSERVICETABLE	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x0F, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_WRITE2			CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x10, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_WRITESTRINGCM		CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x11, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_WRITECM			CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x12, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_SETMARKER			CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x13, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_GETMARKER			CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x14, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_ISCAPTUREFRAME	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x15, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_WRITELF			CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x16, METHOD_BUFFERED, FILE_ANY_ACCESS)
-#define DEBUG_SERVICE_READLF			CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x17, METHOD_BUFFERED, FILE_ANY_ACCESS)
-
-typedef struct _DBG_IN_CREATESTREAM_ {
-	IMG_UINT32 ui32Pages;
-	IMG_UINT32 ui32CapMode;
-	IMG_UINT32 ui32OutMode;
-	IMG_CHAR *pszName;
-} DBG_IN_CREATESTREAM, *PDBG_IN_CREATESTREAM;
+#define DEBUG_SERVICE_CREATESTREAM					\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x01,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_DESTROYSTREAM					\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x02,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_GETSTREAM						\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x03,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_WRITESTRING					\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x04,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_READSTRING					\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x05,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_WRITE						\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x06,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_READ						\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x07,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_SETDEBUGMODE					\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x08,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_SETDEBUGOUTMODE					\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x09,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_SETDEBUGLEVEL					\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x0A,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_SETFRAME						\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x0B,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_GETFRAME						\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x0C,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_OVERRIDEMODE					\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x0D,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_DEFAULTMODE					\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x0E,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_GETSERVICETABLE					\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x0F,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_WRITE2						\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x10,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_WRITESTRINGCM					\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x11,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_WRITECM						\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x12,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_SETMARKER						\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x13,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_GETMARKER						\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x14,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_ISCAPTUREFRAME					\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x15,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_WRITELF						\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x16,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+#define DEBUG_SERVICE_READLF						\
+	CTL_CODE(FILE_DEVICE_UNKNOWN, DEBUG_SERVICE_IOCTL_BASE + 0x17,	\
+					METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+struct DBG_IN_CREATESTREAM {
+	u32 ui32Pages;
+	u32 ui32CapMode;
+	u32 ui32OutMode;
+	char *pszName;
+};
 
-typedef struct _DBG_IN_FINDSTREAM_ {
+struct DBG_IN_FINDSTREAM {
 	IMG_BOOL bResetStream;
-	IMG_CHAR *pszName;
-} DBG_IN_FINDSTREAM, *PDBG_IN_FINDSTREAM;
+	char *pszName;
+};
 
-typedef struct _DBG_IN_WRITESTRING_ {
-	IMG_VOID *pvStream;
-	IMG_UINT32 ui32Level;
-	IMG_CHAR *pszString;
-} DBG_IN_WRITESTRING, *PDBG_IN_WRITESTRING;
-
-typedef struct _DBG_IN_READSTRING_ {
-	IMG_VOID *pvStream;
-	IMG_UINT32 ui32StringLen;
-	IMG_CHAR *pszString;
-} DBG_IN_READSTRING, *PDBG_IN_READSTRING;
-
-typedef struct _DBG_IN_SETDEBUGMODE_ {
-	IMG_VOID *pvStream;
-	IMG_UINT32 ui32Mode;
-	IMG_UINT32 ui32Start;
-	IMG_UINT32 ui32End;
-	IMG_UINT32 ui32SampleRate;
-} DBG_IN_SETDEBUGMODE, *PDBG_IN_SETDEBUGMODE;
-
-typedef struct _DBG_IN_SETDEBUGOUTMODE_ {
-	IMG_VOID *pvStream;
-	IMG_UINT32 ui32Mode;
-} DBG_IN_SETDEBUGOUTMODE, *PDBG_IN_SETDEBUGOUTMODE;
-
-typedef struct _DBG_IN_SETDEBUGLEVEL_ {
-	IMG_VOID *pvStream;
-	IMG_UINT32 ui32Level;
-} DBG_IN_SETDEBUGLEVEL, *PDBG_IN_SETDEBUGLEVEL;
-
-typedef struct _DBG_IN_SETFRAME_ {
-	IMG_VOID *pvStream;
-	IMG_UINT32 ui32Frame;
-} DBG_IN_SETFRAME, *PDBG_IN_SETFRAME;
-
-typedef struct _DBG_IN_WRITE_ {
-	IMG_VOID *pvStream;
-	IMG_UINT32 ui32Level;
-	IMG_UINT32 ui32TransferSize;
-	IMG_UINT8 *pui8InBuffer;
-} DBG_IN_WRITE, *PDBG_IN_WRITE;
+struct DBG_IN_WRITESTRING {
+	void *pvStream;
+	u32 ui32Level;
+	char *pszString;
+};
+
+struct DBG_IN_READSTRING {
+	void *pvStream;
+	u32 ui32StringLen;
+	char *pszString;
+};
+
+struct DBG_IN_SETDEBUGMODE {
+	void *pvStream;
+	u32 ui32Mode;
+	u32 ui32Start;
+	u32 ui32End;
+	u32 ui32SampleRate;
+};
+
+struct DBG_IN_SETDEBUGOUTMODE {
+	void *pvStream;
+	u32 ui32Mode;
+};
+
+struct DBG_IN_SETDEBUGLEVEL {
+	void *pvStream;
+	u32 ui32Level;
+};
+
+struct DBG_IN_SETFRAME {
+	void *pvStream;
+	u32 ui32Frame;
+};
+
+struct DBG_IN_WRITE {
+	void *pvStream;
+	u32 ui32Level;
+	u32 ui32TransferSize;
+	u8 *pui8InBuffer;
+};
 
-typedef struct _DBG_IN_READ_ {
-	IMG_VOID *pvStream;
+struct DBG_IN_READ {
+	void *pvStream;
 	IMG_BOOL bReadInitBuffer;
-	IMG_UINT32 ui32OutBufferSize;
-	IMG_UINT8 *pui8OutBuffer;
-} DBG_IN_READ, *PDBG_IN_READ;
-
-typedef struct _DBG_IN_OVERRIDEMODE_ {
-	IMG_VOID *pvStream;
-	IMG_UINT32 ui32Mode;
-} DBG_IN_OVERRIDEMODE, *PDBG_IN_OVERRIDEMODE;
+	u32 ui32OutBufferSize;
+	u8 *pui8OutBuffer;
+};
+
+struct DBG_IN_OVERRIDEMODE {
+	void *pvStream;
+	u32 ui32Mode;
+};
 
-typedef struct _DBG_IN_ISCAPTUREFRAME_ {
-	IMG_VOID *pvStream;
+struct DBG_IN_ISCAPTUREFRAME {
+	void *pvStream;
 	IMG_BOOL bCheckPreviousFrame;
-} DBG_IN_ISCAPTUREFRAME, *PDBG_IN_ISCAPTUREFRAME;
+};
 
-typedef struct _DBG_IN_SETMARKER_ {
-	IMG_VOID *pvStream;
-	IMG_UINT32 ui32Marker;
-} DBG_IN_SETMARKER, *PDBG_IN_SETMARKER;
-
-typedef struct _DBG_IN_WRITE_LF_ {
-	IMG_UINT32 ui32Flags;
-	IMG_VOID *pvStream;
-	IMG_UINT32 ui32Level;
-	IMG_UINT32 ui32BufferSize;
-	IMG_UINT8 *pui8InBuffer;
-} DBG_IN_WRITE_LF, *PDBG_IN_WRITE_LF;
+struct DBG_IN_SETMARKER {
+	void *pvStream;
+	u32 ui32Marker;
+};
+
+struct DBG_IN_WRITE_LF {
+	u32 ui32Flags;
+	void *pvStream;
+	u32 ui32Level;
+	u32 ui32BufferSize;
+	u8 *pui8InBuffer;
+};
 
 #define WRITELF_FLAGS_RESETBUF		0x00000001
 
-typedef struct _DBG_STREAM_ {
-	struct _DBG_STREAM_ *psNext;
-	struct _DBG_STREAM_ *psInitStream;
+struct DBG_STREAM {
+	struct DBG_STREAM *psNext;
+	struct DBG_STREAM *psInitStream;
 	IMG_BOOL bInitPhaseComplete;
-	IMG_UINT32 ui32Flags;
-	IMG_UINT32 ui32Base;
-	IMG_UINT32 ui32Size;
-	IMG_UINT32 ui32RPtr;
-	IMG_UINT32 ui32WPtr;
-	IMG_UINT32 ui32DataWritten;
-	IMG_UINT32 ui32CapMode;
-	IMG_UINT32 ui32OutMode;
-	IMG_UINT32 ui32DebugLevel;
-	IMG_UINT32 ui32DefaultMode;
-	IMG_UINT32 ui32Start;
-	IMG_UINT32 ui32End;
-	IMG_UINT32 ui32Current;
-	IMG_UINT32 ui32Access;
-	IMG_UINT32 ui32SampleRate;
-	IMG_UINT32 ui32Reserved;
-	IMG_UINT32 ui32Timeout;
-	IMG_UINT32 ui32Marker;
-	IMG_CHAR szName[30];
-} DBG_STREAM, *PDBG_STREAM;
-
-typedef struct _DBGKM_SERVICE_TABLE_ {
-	IMG_UINT32 ui32Size;
-	IMG_VOID *(IMG_CALLCONV * pfnCreateStream) (IMG_CHAR * pszName,
-						    IMG_UINT32 ui32CapMode,
-						    IMG_UINT32 ui32OutMode,
-						    IMG_UINT32 ui32Flags,
-						    IMG_UINT32 ui32Pages);
-	 IMG_VOID(IMG_CALLCONV * pfnDestroyStream) (PDBG_STREAM psStream);
-	IMG_VOID *(IMG_CALLCONV * pfnFindStream) (IMG_CHAR * pszName,
-						  IMG_BOOL bResetInitBuffer);
-	 IMG_UINT32(IMG_CALLCONV * pfnWriteString) (PDBG_STREAM psStream,
-						    IMG_CHAR * pszString,
-						    IMG_UINT32 ui32Level);
-	 IMG_UINT32(IMG_CALLCONV * pfnReadString) (PDBG_STREAM psStream,
-						   IMG_CHAR * pszString,
-						   IMG_UINT32 ui32Limit);
-	 IMG_UINT32(IMG_CALLCONV * pfnWriteBIN) (PDBG_STREAM psStream,
-						 IMG_UINT8 * pui8InBuf,
-						 IMG_UINT32 ui32InBuffSize,
-						 IMG_UINT32 ui32Level);
-	 IMG_UINT32(IMG_CALLCONV * pfnReadBIN) (PDBG_STREAM psStream,
-						IMG_BOOL bReadInitBuffer,
-						IMG_UINT32 ui32OutBufferSize,
-						IMG_UINT8 * pui8OutBuf);
-	 IMG_VOID(IMG_CALLCONV * pfnSetCaptureMode) (PDBG_STREAM psStream,
-						     IMG_UINT32 ui32CapMode,
-						     IMG_UINT32 ui32Start,
-						     IMG_UINT32 ui32Stop,
-						     IMG_UINT32 ui32SampleRate);
-	 IMG_VOID(IMG_CALLCONV * pfnSetOutputMode) (PDBG_STREAM psStream,
-						    IMG_UINT32 ui32OutMode);
-	 IMG_VOID(IMG_CALLCONV * pfnSetDebugLevel) (PDBG_STREAM psStream,
-						    IMG_UINT32 ui32DebugLevel);
-	 IMG_VOID(IMG_CALLCONV * pfnSetFrame) (PDBG_STREAM psStream,
-					       IMG_UINT32 ui32Frame);
-	 IMG_UINT32(IMG_CALLCONV * pfnGetFrame) (PDBG_STREAM psStream);
-	 IMG_VOID(IMG_CALLCONV * pfnOverrideMode) (PDBG_STREAM psStream,
-						   IMG_UINT32 ui32Mode);
-	 IMG_VOID(IMG_CALLCONV * pfnDefaultMode) (PDBG_STREAM psStream);
-	 IMG_UINT32(IMG_CALLCONV * pfnDBGDrivWrite2) (PDBG_STREAM psStream,
-						      IMG_UINT8 * pui8InBuf,
-						      IMG_UINT32 ui32InBuffSize,
-						      IMG_UINT32 ui32Level);
-	 IMG_UINT32(IMG_CALLCONV * pfnWriteStringCM) (PDBG_STREAM psStream,
-						      IMG_CHAR * pszString,
-						      IMG_UINT32 ui32Level);
-	 IMG_UINT32(IMG_CALLCONV * pfnWriteBINCM) (PDBG_STREAM psStream,
-						   IMG_UINT8 * pui8InBuf,
-						   IMG_UINT32 ui32InBuffSize,
-						   IMG_UINT32 ui32Level);
-	 IMG_VOID(IMG_CALLCONV * pfnSetMarker) (PDBG_STREAM psStream,
-						IMG_UINT32 ui32Marker);
-	 IMG_UINT32(IMG_CALLCONV * pfnGetMarker) (PDBG_STREAM psStream);
-	 IMG_VOID(IMG_CALLCONV * pfnEndInitPhase) (PDBG_STREAM psStream);
-	 IMG_UINT32(IMG_CALLCONV * pfnIsCaptureFrame) (PDBG_STREAM psStream,
-						       IMG_BOOL
-						       bCheckPreviousFrame);
-	 IMG_UINT32(IMG_CALLCONV * pfnWriteLF) (PDBG_STREAM psStream,
-						IMG_UINT8 * pui8InBuf,
-						IMG_UINT32 ui32InBuffSize,
-						IMG_UINT32 ui32Level,
-						IMG_UINT32 ui32Flags);
-	 IMG_UINT32(IMG_CALLCONV * pfnReadLF) (PDBG_STREAM psStream,
-					       IMG_UINT32 ui32OutBuffSize,
-					       IMG_UINT8 * pui8OutBuf);
-	 IMG_UINT32(IMG_CALLCONV * pfnGetStreamOffset) (PDBG_STREAM psStream);
-	 IMG_VOID(IMG_CALLCONV * pfnSetStreamOffset) (PDBG_STREAM psStream,
-						      IMG_UINT32
-						      ui32StreamOffset);
-	 IMG_UINT32(IMG_CALLCONV *
-		    pfnIsLastCaptureFrame) (PDBG_STREAM psStream);
-} DBGKM_SERVICE_TABLE, *PDBGKM_SERVICE_TABLE;
+	u32 ui32Flags;
+	u32 ui32Base;
+	u32 ui32Size;
+	u32 ui32RPtr;
+	u32 ui32WPtr;
+	u32 ui32DataWritten;
+	u32 ui32CapMode;
+	u32 ui32OutMode;
+	u32 ui32DebugLevel;
+	u32 ui32DefaultMode;
+	u32 ui32Start;
+	u32 ui32End;
+	u32 ui32Current;
+	u32 ui32Access;
+	u32 ui32SampleRate;
+	u32 ui32Reserved;
+	u32 ui32Timeout;
+	u32 ui32Marker;
+	char szName[30];
+};
+
+struct DBGKM_SERVICE_TABLE {
+	u32 ui32Size;
+	void *(*pfnCreateStream)(char *pszName, u32 ui32CapMode,
+			u32 ui32OutMode, u32 ui32Flags, u32 ui32Pages);
+	void  (*pfnDestroyStream)(struct DBG_STREAM *psStream);
+	void *(*pfnFindStream)(char *pszName, IMG_BOOL bResetInitBuffer);
+	u32   (*pfnWriteString)(struct DBG_STREAM *psStream, char *pszString,
+			u32 ui32Level);
+	u32   (*pfnReadString)(struct DBG_STREAM *psStream, char *pszString,
+			u32 ui32Limit);
+	u32   (*pfnWriteBIN)(struct DBG_STREAM *psStream, u8 *pui8InBuf,
+			u32 ui32InBuffSize, u32 ui32Level);
+	u32   (*pfnReadBIN)(struct DBG_STREAM *psStream,
+			IMG_BOOL bReadInitBuffer, u32 ui32OutBufferSize,
+			u8 *pui8OutBuf);
+	void  (*pfnSetCaptureMode)(struct DBG_STREAM *psStream,
+			u32 ui32CapMode, u32 ui32Start, u32 ui32Stop,
+			u32 ui32SampleRate);
+	void  (*pfnSetOutputMode)(struct DBG_STREAM *psStream,
+			u32 ui32OutMode);
+	void  (*pfnSetDebugLevel)(struct DBG_STREAM *psStream,
+			u32 ui32DebugLevel);
+	void  (*pfnSetFrame)(struct DBG_STREAM *psStream,
+			u32 ui32Frame);
+	u32   (*pfnGetFrame)(struct DBG_STREAM *psStream);
+	void  (*pfnOverrideMode)(struct DBG_STREAM *psStream,
+			u32 ui32Mode);
+	void  (*pfnDefaultMode)(struct DBG_STREAM *psStream);
+	u32   (*pfnDBGDrivWrite2)(struct DBG_STREAM *psStream,
+			u8 *pui8InBuf, u32 ui32InBuffSize, u32 ui32Level);
+	u32   (*pfnWriteStringCM)(struct DBG_STREAM *psStream, char *pszString,
+			u32 ui32Level);
+	u32   (*pfnWriteBINCM)(struct DBG_STREAM *psStream, u8 *pui8InBuf,
+			u32 ui32InBuffSize, u32 ui32Level);
+	void  (*pfnSetMarker)(struct DBG_STREAM *psStream, u32 ui32Marker);
+	u32   (*pfnGetMarker)(struct DBG_STREAM *psStream);
+	void  (*pfnEndInitPhase)(struct DBG_STREAM *psStream);
+	u32   (*pfnIsCaptureFrame)(struct DBG_STREAM *psStream,
+			IMG_BOOL bCheckPreviousFrame);
+	u32   (*pfnWriteLF)(struct DBG_STREAM *psStream, u8 *pui8InBuf,
+			u32 ui32InBuffSize, u32 ui32Level, u32 ui32Flags);
+	u32   (*pfnReadLF)(struct DBG_STREAM *psStream, u32 ui32OutBuffSize,
+			u8 *pui8OutBuf);
+	u32   (*pfnGetStreamOffset)(struct DBG_STREAM *psStream);
+	void  (*pfnSetStreamOffset)(struct DBG_STREAM *psStream,
+			u32 ui32StreamOffset);
+	u32   (*pfnIsLastCaptureFrame)(struct DBG_STREAM *psStream);
+};
+
+extern struct DBGKM_SERVICE_TABLE g_sDBGKMServices;
+
+void DBGDrvGetServiceTable(void **fn_table);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/device.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/device.h
@@ -1,237 +1,176 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef __DEVICE_H__
 #define __DEVICE_H__
 
-
 #include "ra.h"
 #include "resman.h"
 
-	typedef struct _BM_CONTEXT_ BM_CONTEXT;
+struct BM_CONTEXT;
 
-	typedef struct _MMU_HEAP_ MMU_HEAP;
-	typedef struct _MMU_CONTEXT_ MMU_CONTEXT;
+struct MMU_HEAP;
+struct MMU_CONTEXT;
 
-#define PVRSRV_BACKINGSTORE_SYSMEM_CONTIG		(1<<(PVRSRV_MEM_BACKINGSTORE_FIELD_SHIFT+0))
-#define PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG	(1<<(PVRSRV_MEM_BACKINGSTORE_FIELD_SHIFT+1))
-#define PVRSRV_BACKINGSTORE_LOCALMEM_CONTIG		(1<<(PVRSRV_MEM_BACKINGSTORE_FIELD_SHIFT+2))
-#define PVRSRV_BACKINGSTORE_LOCALMEM_NONCONTIG	(1<<(PVRSRV_MEM_BACKINGSTORE_FIELD_SHIFT+3))
+#define PVRSRV_BACKINGSTORE_SYSMEM_CONTIG		\
+		(1<<(PVRSRV_MEM_BACKINGSTORE_FIELD_SHIFT+0))
+#define PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG		\
+		(1<<(PVRSRV_MEM_BACKINGSTORE_FIELD_SHIFT+1))
+#define PVRSRV_BACKINGSTORE_LOCALMEM_CONTIG		\
+		(1<<(PVRSRV_MEM_BACKINGSTORE_FIELD_SHIFT+2))
+#define PVRSRV_BACKINGSTORE_LOCALMEM_NONCONTIG		\
+		(1<<(PVRSRV_MEM_BACKINGSTORE_FIELD_SHIFT+3))
 
-	typedef IMG_UINT32 DEVICE_MEMORY_HEAP_TYPE;
-#define DEVICE_MEMORY_HEAP_PERCONTEXT		0
+typedef u32 DEVICE_MEMORY_HEAP_TYPE;
+#define DEVICE_MEMORY_HEAP_PERCONTEXT			0
 #define DEVICE_MEMORY_HEAP_KERNEL			1
 #define DEVICE_MEMORY_HEAP_SHARED			2
-#define DEVICE_MEMORY_HEAP_SHARED_EXPORTED	3
-
-#define PVRSRV_DEVICE_NODE_FLAGS_PORT80DISPLAY	1
-#define PVRSRV_DEVICE_NODE_FLAGS_MMU_OPT_INV	2
-
-	typedef struct _DEVICE_MEMORY_HEAP_INFO_ {
-
-		IMG_UINT32 ui32HeapID;
-
-		IMG_CHAR *pszName;
-
-		IMG_CHAR *pszBSName;
-
-		IMG_DEV_VIRTADDR sDevVAddrBase;
-
-		IMG_UINT32 ui32HeapSize;
-
-		IMG_UINT32 ui32Attribs;
-
-		DEVICE_MEMORY_HEAP_TYPE DevMemHeapType;
-
-		IMG_HANDLE hDevMemHeap;
-
-		RA_ARENA *psLocalDevMemArena;
-
-	} DEVICE_MEMORY_HEAP_INFO;
-
-	typedef struct _DEVICE_MEMORY_INFO_ {
-
-		IMG_UINT32 ui32AddressSpaceSizeLog2;
-
-		IMG_UINT32 ui32Flags;
-
-		IMG_UINT32 ui32HeapCount;
-
-		IMG_UINT32 ui32SyncHeapID;
-
-		IMG_UINT32 ui32MappingHeapID;
-
-		DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
-
-		BM_CONTEXT *pBMKernelContext;
-
-		BM_CONTEXT *pBMContext;
-
-	} DEVICE_MEMORY_INFO;
-
-	typedef struct DEV_ARENA_DESCRIPTOR_TAG {
-		IMG_UINT32 ui32HeapID;
-
-		IMG_CHAR *pszName;
-
-		IMG_DEV_VIRTADDR BaseDevVAddr;
-
-		IMG_UINT32 ui32Size;
-
-		DEVICE_MEMORY_HEAP_TYPE DevMemHeapType;
-
-		DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeapInfo;
-
-	} DEV_ARENA_DESCRIPTOR;
-
-	typedef struct _SYS_DATA_TAG_ *PSYS_DATA;
-
-	typedef struct _PVRSRV_DEVICE_NODE_ {
-		PVRSRV_DEVICE_IDENTIFIER sDevId;
-		IMG_UINT32 ui32RefCount;
-
-		 PVRSRV_ERROR(*pfnInitDevice) (IMG_VOID *);
-
-		 PVRSRV_ERROR(*pfnDeInitDevice) (IMG_VOID *);
-
-		 PVRSRV_ERROR(*pfnMMUInitialise) (struct _PVRSRV_DEVICE_NODE_ *,
-						  MMU_CONTEXT **,
-						  IMG_DEV_PHYADDR *);
-		 IMG_VOID(*pfnMMUFinalise) (MMU_CONTEXT *);
-		 IMG_VOID(*pfnMMUInsertHeap) (MMU_CONTEXT *, MMU_HEAP *);
-		MMU_HEAP *(*pfnMMUCreate) (MMU_CONTEXT *,
-					   DEV_ARENA_DESCRIPTOR *, RA_ARENA **);
-		 IMG_VOID(*pfnMMUDelete) (MMU_HEAP *);
-		 IMG_BOOL(*pfnMMUAlloc) (MMU_HEAP * pMMU,
-					 IMG_SIZE_T uSize,
-					 IMG_SIZE_T * pActualSize,
-					 IMG_UINT32 uFlags,
-					 IMG_UINT32 uDevVAddrAlignment,
-					 IMG_DEV_VIRTADDR * pDevVAddr);
-		 IMG_VOID(*pfnMMUFree) (MMU_HEAP *, IMG_DEV_VIRTADDR,
-					IMG_UINT32);
-		 IMG_VOID(*pfnMMUEnable) (MMU_HEAP *);
-		 IMG_VOID(*pfnMMUDisable) (MMU_HEAP *);
-		 IMG_VOID(*pfnMMUMapPages) (MMU_HEAP * pMMU,
-					    IMG_DEV_VIRTADDR devVAddr,
-					    IMG_SYS_PHYADDR SysPAddr,
-					    IMG_SIZE_T uSize,
-					    IMG_UINT32 ui32MemFlags,
-					    IMG_HANDLE hUniqueTag);
-		 IMG_VOID(*pfnMMUMapShadow) (MMU_HEAP * pMMU,
-					     IMG_DEV_VIRTADDR MapBaseDevVAddr,
-					     IMG_SIZE_T uSize,
-					     IMG_CPU_VIRTADDR CpuVAddr,
-					     IMG_HANDLE hOSMemHandle,
-					     IMG_DEV_VIRTADDR * pDevVAddr,
-					     IMG_UINT32 ui32MemFlags,
-					     IMG_HANDLE hUniqueTag);
-		 IMG_VOID(*pfnMMUUnmapPages) (MMU_HEAP * pMMU,
-					      IMG_DEV_VIRTADDR dev_vaddr,
-					      IMG_UINT32 ui32PageCount,
-					      IMG_HANDLE hUniqueTag);
-
-		 IMG_VOID(*pfnMMUMapScatter) (MMU_HEAP * pMMU,
-					      IMG_DEV_VIRTADDR DevVAddr,
-					      IMG_SYS_PHYADDR * psSysAddr,
-					      IMG_SIZE_T uSize,
-					      IMG_UINT32 ui32MemFlags,
-					      IMG_HANDLE hUniqueTag);
-
-		 IMG_DEV_PHYADDR(*pfnMMUGetPhysPageAddr) (MMU_HEAP * pMMUHeap,
-							  IMG_DEV_VIRTADDR
-							  sDevVPageAddr);
-		 IMG_DEV_PHYADDR(*pfnMMUGetPDDevPAddr) (MMU_CONTEXT *
-							pMMUContext);
-
-		 IMG_BOOL(*pfnDeviceISR) (IMG_VOID *);
-
-		IMG_VOID *pvISRData;
-
-		IMG_UINT32 ui32SOCInterruptBit;
-
-		 IMG_VOID(*pfnDeviceMISR) (IMG_VOID *);
-
-		 IMG_VOID(*pfnDeviceCommandComplete) (struct
-						      _PVRSRV_DEVICE_NODE_ *
-						      psDeviceNode);
-
-		IMG_BOOL bReProcessDeviceCommandComplete;
-
-		DEVICE_MEMORY_INFO sDevMemoryInfo;
-
-		IMG_VOID *pvDevice;
-		IMG_UINT32 ui32pvDeviceSize;
-		IMG_VOID *hDeviceOSMemHandle;
-
-		PRESMAN_CONTEXT hResManContext;
-
-		PSYS_DATA psSysData;
-
-		RA_ARENA *psLocalDevMemArena;
-
-		IMG_UINT32 ui32Flags;
-
-		struct _PVRSRV_DEVICE_NODE_ *psNext;
-	} PVRSRV_DEVICE_NODE;
-
-	PVRSRV_ERROR IMG_CALLCONV PVRSRVRegisterDevice(PSYS_DATA psSysData,
-						       PVRSRV_ERROR
-						       (*pfnRegisterDevice)
-						       (PVRSRV_DEVICE_NODE *),
-						       IMG_UINT32
-						       ui32SOCInterruptBit,
-						       IMG_UINT32 *
-						       pui32DeviceIndex);
-
-	PVRSRV_ERROR IMG_CALLCONV PVRSRVInitialiseDevice(IMG_UINT32
-							 ui32DevIndex);
-	PVRSRV_ERROR IMG_CALLCONV PVRSRVFinaliseSystem(IMG_BOOL bInitSuccesful);
-
-	PVRSRV_ERROR IMG_CALLCONV PVRSRVDeinitialiseDevice(IMG_UINT32
-							   ui32DevIndex);
-
-
-	IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV PollForValueKM(volatile IMG_UINT32
-							    * pui32LinMemAddr,
-							    IMG_UINT32
-							    ui32Value,
-							    IMG_UINT32 ui32Mask,
-							    IMG_UINT32
-							    ui32Waitus,
-							    IMG_UINT32
-							    ui32Tries);
-
+#define DEVICE_MEMORY_HEAP_SHARED_EXPORTED		3
 
+#define PVRSRV_DEVICE_NODE_FLAGS_PORT80DISPLAY		1
+#define PVRSRV_DEVICE_NODE_FLAGS_MMU_OPT_INV		2
 
-	PVRSRV_ERROR IMG_CALLCONV PVRSRVInit(PSYS_DATA psSysData);
-	IMG_VOID IMG_CALLCONV PVRSRVDeInit(PSYS_DATA psSysData);
-	IMG_BOOL IMG_CALLCONV PVRSRVDeviceLISR(PVRSRV_DEVICE_NODE *
-					       psDeviceNode);
-	IMG_BOOL IMG_CALLCONV PVRSRVSystemLISR(IMG_VOID * pvSysData);
-	IMG_VOID IMG_CALLCONV PVRSRVMISR(IMG_VOID * pvSysData);
+struct DEVICE_MEMORY_HEAP_INFO {
+	u32 ui32HeapID;
+	char *pszName;
+	char *pszBSName;
+	struct IMG_DEV_VIRTADDR sDevVAddrBase;
+	u32 ui32HeapSize;
+	u32 ui32Attribs;
+	DEVICE_MEMORY_HEAP_TYPE DevMemHeapType;
+	void *hDevMemHeap;
+	struct RA_ARENA *psLocalDevMemArena;
+};
+
+struct DEVICE_MEMORY_INFO {
+	u32 ui32AddressSpaceSizeLog2;
+	u32 ui32Flags;
+	u32 ui32HeapCount;
+	u32 ui32SyncHeapID;
+	u32 ui32MappingHeapID;
+	struct DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
+	struct BM_CONTEXT *pBMKernelContext;
+	struct BM_CONTEXT *pBMContext;
+};
+
+struct DEV_ARENA_DESCRIPTOR {
+	u32 ui32HeapID;
+	char *pszName;
+	struct IMG_DEV_VIRTADDR BaseDevVAddr;
+	u32 ui32Size;
+	DEVICE_MEMORY_HEAP_TYPE DevMemHeapType;
+	struct DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeapInfo;
+};
+
+struct SYS_DATA;
+
+struct PVRSRV_DEVICE_NODE {
+	struct PVRSRV_DEVICE_IDENTIFIER sDevId;
+	u32 ui32RefCount;
+
+	enum PVRSRV_ERROR (*pfnInitDevice)(void *);
+	enum PVRSRV_ERROR (*pfnDeInitDevice)(void *);
+
+	enum PVRSRV_ERROR (*pfnMMUInitialise)(struct PVRSRV_DEVICE_NODE *,
+			struct MMU_CONTEXT **,
+			struct IMG_DEV_PHYADDR *);
+	void (*pfnMMUFinalise)(struct MMU_CONTEXT *);
+	void (*pfnMMUInsertHeap)(struct MMU_CONTEXT *, struct MMU_HEAP *);
+	struct MMU_HEAP *(*pfnMMUCreate)(struct MMU_CONTEXT *,
+			struct DEV_ARENA_DESCRIPTOR *, struct RA_ARENA **);
+	void (*pfnMMUDelete)(struct MMU_HEAP *);
+	IMG_BOOL (*pfnMMUAlloc)(struct MMU_HEAP *pMMU,
+			size_t uSize, size_t *pActualSize, u32 uFlags,
+			u32 uDevVAddrAlignment,
+			struct IMG_DEV_VIRTADDR *pDevVAddr);
+	void (*pfnMMUFree)(struct MMU_HEAP *, struct IMG_DEV_VIRTADDR, u32);
+	void (*pfnMMUEnable)(struct MMU_HEAP *);
+	void (*pfnMMUDisable)(struct MMU_HEAP *);
+	void (*pfnMMUMapPages)(struct MMU_HEAP *pMMU,
+			struct IMG_DEV_VIRTADDR devVAddr,
+			struct IMG_SYS_PHYADDR SysPAddr,
+			size_t uSize, u32 ui32MemFlags, void *hUniqueTag);
+	void (*pfnMMUMapShadow)(struct MMU_HEAP *pMMU,
+			struct IMG_DEV_VIRTADDR MapBaseDevVAddr,
+			size_t uSize, void *CpuVAddr, void *hOSMemHandle,
+			struct IMG_DEV_VIRTADDR *pDevVAddr, u32 ui32MemFlags,
+			void *hUniqueTag);
+	void (*pfnMMUUnmapPages)(struct MMU_HEAP *pMMU,
+			struct IMG_DEV_VIRTADDR dev_vaddr, u32 ui32PageCount,
+			void *hUniqueTag);
+
+	void (*pfnMMUMapScatter)(struct MMU_HEAP *pMMU,
+			struct IMG_DEV_VIRTADDR DevVAddr,
+			struct IMG_SYS_PHYADDR *psSysAddr,
+			size_t uSize, u32 ui32MemFlags, void *hUniqueTag);
+
+	struct IMG_DEV_PHYADDR(*pfnMMUGetPhysPageAddr)(
+			struct MMU_HEAP *pMMUHeap,
+			struct IMG_DEV_VIRTADDR sDevVPageAddr);
+	struct IMG_DEV_PHYADDR(*pfnMMUGetPDDevPAddr)(
+			struct MMU_CONTEXT *pMMUContext);
+
+	IMG_BOOL (*pfnDeviceISR)(void *);
+
+	void *pvISRData;
+	u32 ui32SOCInterruptBit;
+
+	void (*pfnDeviceMISR)(void *);
+	void (*pfnDeviceCommandComplete)(struct PVRSRV_DEVICE_NODE *
+			psDeviceNode);
+
+	IMG_BOOL bReProcessDeviceCommandComplete;
+	struct DEVICE_MEMORY_INFO sDevMemoryInfo;
+	void *pvDevice;
+	u32 ui32pvDeviceSize;
+	void *hDeviceOSMemHandle;
+	struct RESMAN_CONTEXT *hResManContext;
+	struct SYS_DATA *psSysData;
+	struct RA_ARENA *psLocalDevMemArena;
+	u32 ui32Flags;
+	struct PVRSRV_DEVICE_NODE *psNext;
+};
+
+enum PVRSRV_ERROR PVRSRVRegisterDevice(struct SYS_DATA *psSysData,
+	    enum PVRSRV_ERROR (*pfnRegisterDevice)(struct PVRSRV_DEVICE_NODE *),
+	    u32 ui32SOCInterruptBit, u32 *pui32DeviceIndex);
+
+enum PVRSRV_ERROR PVRSRVInitialiseDevice(u32 ui32DevIndex);
+enum PVRSRV_ERROR PVRSRVFinaliseSystem(IMG_BOOL bInitSuccesful);
+
+enum PVRSRV_ERROR PVRSRVDeinitialiseDevice(u32 ui32DevIndex);
+
+
+enum PVRSRV_ERROR PollForValueKM(volatile u32 *pui32LinMemAddr,
+	    u32 ui32Value, u32 ui32Mask, u32 ui32Waitus, u32 ui32Tries);
+
+enum PVRSRV_ERROR PVRSRVInit(struct SYS_DATA *psSysData);
+void PVRSRVDeInit(struct SYS_DATA *psSysData);
+IMG_BOOL PVRSRVDeviceLISR(struct PVRSRV_DEVICE_NODE *psDeviceNode);
+IMG_BOOL PVRSRVSystemLISR(void *pvSysData);
+void PVRSRVMISR(void *pvSysData);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/deviceclass.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/deviceclass.c
@@ -1,128 +1,124 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
+#include <linux/module.h>
 
 #include "services_headers.h"
 #include "buffer_manager.h"
 #include "kernelbuffer.h"
 #include "pvr_bridge_km.h"
+#include "kerneldisplay.h"
 
-PVRSRV_ERROR AllocateDeviceID(SYS_DATA * psSysData, IMG_UINT32 * pui32DevID);
-PVRSRV_ERROR FreeDeviceID(SYS_DATA * psSysData, IMG_UINT32 ui32DevID);
-
-typedef struct PVRSRV_DC_SRV2DISP_KMJTABLE_TAG *PPVRSRV_DC_SRV2DISP_KMJTABLE;
+struct PVRSRV_DC_BUFFER {
 
-typedef struct PVRSRV_DC_BUFFER_TAG {
+	struct PVRSRV_DEVICECLASS_BUFFER sDeviceClassBuffer;
 
-	PVRSRV_DEVICECLASS_BUFFER sDeviceClassBuffer;
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	struct PVRSRV_DC_SWAPCHAIN *psSwapChain;
+};
 
-	struct PVRSRV_DISPLAYCLASS_INFO_TAG *psDCInfo;
-	struct PVRSRV_DC_SWAPCHAIN_TAG *psSwapChain;
-} PVRSRV_DC_BUFFER;
+struct PVRSRV_DC_SWAPCHAIN {
+	void *hExtSwapChain;
+	struct PVRSRV_QUEUE_INFO *psQueue;
+	struct PVRSRV_DC_BUFFER asBuffer[PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS];
+	u32 ui32BufferCount;
+	struct PVRSRV_DC_BUFFER *psLastFlipBuffer;
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	void *hResItem;
+};
 
-typedef struct PVRSRV_DC_SWAPCHAIN_TAG {
-	IMG_HANDLE hExtSwapChain;
-	PVRSRV_QUEUE_INFO *psQueue;
-	PVRSRV_DC_BUFFER asBuffer[PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS];
-	IMG_UINT32 ui32BufferCount;
-	PVRSRV_DC_BUFFER *psLastFlipBuffer;
-	struct PVRSRV_DISPLAYCLASS_INFO_TAG *psDCInfo;
-	IMG_HANDLE hResItem;
-} PVRSRV_DC_SWAPCHAIN;
+struct PVRSRV_DISPLAYCLASS_INFO {
+	u32 ui32RefCount;
+	u32 ui32DeviceID;
+	void *hExtDevice;
+	struct PVRSRV_DC_SRV2DISP_KMJTABLE *psFuncTable;
+	void *hDevMemContext;
+	struct PVRSRV_DC_BUFFER sSystemBuffer;
+};
 
-typedef struct PVRSRV_DISPLAYCLASS_INFO_TAG {
-	IMG_UINT32 ui32RefCount;
-	IMG_UINT32 ui32DeviceID;
-	IMG_HANDLE hExtDevice;
-	PPVRSRV_DC_SRV2DISP_KMJTABLE psFuncTable;
-	IMG_HANDLE hDevMemContext;
-	PVRSRV_DC_BUFFER sSystemBuffer;
-} PVRSRV_DISPLAYCLASS_INFO;
+struct PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO {
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	struct RESMAN_ITEM *hResItem;
+};
 
-typedef struct PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO_TAG {
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
-	PRESMAN_ITEM hResItem;
-} PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO;
+struct PVRSRV_BC_SRV2BUFFER_KMJTABLE;
 
-typedef struct PVRSRV_BC_SRV2BUFFER_KMJTABLE_TAG
-    *PPVRSRV_BC_SRV2BUFFER_KMJTABLE;
+struct PVRSRV_BC_BUFFER {
 
-typedef struct PVRSRV_BC_BUFFER_TAG {
+	struct PVRSRV_DEVICECLASS_BUFFER sDeviceClassBuffer;
 
-	PVRSRV_DEVICECLASS_BUFFER sDeviceClassBuffer;
+	struct PVRSRV_BUFFERCLASS_INFO *psBCInfo;
+};
 
-	struct PVRSRV_BUFFERCLASS_INFO_TAG *psBCInfo;
-} PVRSRV_BC_BUFFER;
+struct PVRSRV_BUFFERCLASS_INFO {
+	u32 ui32RefCount;
+	u32 ui32DeviceID;
+	void *hExtDevice;
+	struct PVRSRV_BC_SRV2BUFFER_KMJTABLE *psFuncTable;
+	void *hDevMemContext;
 
-typedef struct PVRSRV_BUFFERCLASS_INFO_TAG {
-	IMG_UINT32 ui32RefCount;
-	IMG_UINT32 ui32DeviceID;
-	IMG_HANDLE hExtDevice;
-	PPVRSRV_BC_SRV2BUFFER_KMJTABLE psFuncTable;
-	IMG_HANDLE hDevMemContext;
+	u32 ui32BufferCount;
+	struct PVRSRV_BC_BUFFER *psBuffer;
 
-	IMG_UINT32 ui32BufferCount;
-	PVRSRV_BC_BUFFER *psBuffer;
+};
 
-} PVRSRV_BUFFERCLASS_INFO;
+struct PVRSRV_BUFFERCLASS_PERCONTEXT_INFO {
+	struct PVRSRV_BUFFERCLASS_INFO *psBCInfo;
+	void *hResItem;
+};
 
-typedef struct PVRSRV_BUFFERCLASS_PERCONTEXT_INFO_TAG {
-	PVRSRV_BUFFERCLASS_INFO *psBCInfo;
-	IMG_HANDLE hResItem;
-} PVRSRV_BUFFERCLASS_PERCONTEXT_INFO;
-
-static PVRSRV_DISPLAYCLASS_INFO *DCDeviceHandleToDCInfo(IMG_HANDLE hDeviceKM)
+static struct PVRSRV_DISPLAYCLASS_INFO *DCDeviceHandleToDCInfo(void *hDeviceKM)
 {
-	PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO *psDCPerContextInfo;
+	struct PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO *psDCPerContextInfo;
 
-	psDCPerContextInfo = (PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO *) hDeviceKM;
+	psDCPerContextInfo = (struct PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO *)
+				hDeviceKM;
 
 	return psDCPerContextInfo->psDCInfo;
 }
 
-static PVRSRV_BUFFERCLASS_INFO *BCDeviceHandleToBCInfo(IMG_HANDLE hDeviceKM)
+static struct PVRSRV_BUFFERCLASS_INFO *BCDeviceHandleToBCInfo(void *hDeviceKM)
 {
-	PVRSRV_BUFFERCLASS_PERCONTEXT_INFO *psBCPerContextInfo;
+	struct PVRSRV_BUFFERCLASS_PERCONTEXT_INFO *psBCPerContextInfo;
 
-	psBCPerContextInfo = (PVRSRV_BUFFERCLASS_PERCONTEXT_INFO *) hDeviceKM;
+	psBCPerContextInfo = (struct PVRSRV_BUFFERCLASS_PERCONTEXT_INFO *)
+				hDeviceKM;
 
 	return psBCPerContextInfo->psBCInfo;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVEnumerateDCKM(PVRSRV_DEVICE_CLASS DeviceClass,
-				     IMG_UINT32 * pui32DevCount,
-				     IMG_UINT32 * pui32DevID)
-{
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	IMG_UINT ui32DevCount = 0;
-	SYS_DATA *psSysData;
+enum PVRSRV_ERROR PVRSRVEnumerateDCKM(enum PVRSRV_DEVICE_CLASS DeviceClass,
+				     u32 *pui32DevCount, u32 *pui32DevID)
+{
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	unsigned ui32DevCount = 0;
+	struct SYS_DATA *psSysData;
 
 	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVEnumerateDCKM: Failed to get SysData"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVEnumerateDCKM: Failed to get SysData");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
@@ -132,69 +128,70 @@
 		    && (psDeviceNode->sDevId.eDeviceType ==
 			PVRSRV_DEVICE_TYPE_EXT)) {
 			ui32DevCount++;
-			if (pui32DevID) {
+			if (pui32DevID)
 				*pui32DevID++ =
 				    psDeviceNode->sDevId.ui32DeviceIndex;
-			}
 		}
 		psDeviceNode = psDeviceNode->psNext;
 	}
 
 	if (pui32DevCount) {
 		*pui32DevCount = ui32DevCount;
-	} else if (pui32DevID == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVEnumerateDCKM: Invalid parameters"));
-		return (PVRSRV_ERROR_INVALID_PARAMS);
+	} else if (pui32DevID == NULL) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVEnumerateDCKM: Invalid parameters");
+		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PVRSRVRegisterDCDeviceKM(PVRSRV_DC_SRV2DISP_KMJTABLE * psFuncTable,
-				      IMG_UINT32 * pui32DeviceID)
-{
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo = IMG_NULL;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	SYS_DATA *psSysData;
+static enum PVRSRV_ERROR PVRSRVRegisterDCDeviceKM(
+				struct PVRSRV_DC_SRV2DISP_KMJTABLE *psFuncTable,
+				u32 *pui32DeviceID)
+{
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo = NULL;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct SYS_DATA *psSysData;
 
 	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRegisterDCDeviceKM: Failed to get SysData"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVRegisterDCDeviceKM: Failed to get SysData");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 		       sizeof(*psDCInfo),
-		       (IMG_VOID **) & psDCInfo, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRegisterDCDeviceKM: Failed psDCInfo alloc"));
+		       (void **) &psDCInfo, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVRegisterDCDeviceKM: Failed psDCInfo alloc");
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 	OSMemSet(psDCInfo, 0, sizeof(*psDCInfo));
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE),
-		       (IMG_VOID **) & psDCInfo->psFuncTable,
-		       IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRegisterDCDeviceKM: Failed psFuncTable alloc"));
+		       sizeof(struct PVRSRV_DC_SRV2DISP_KMJTABLE),
+		       (void **) &psDCInfo->psFuncTable,
+		       NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVRegisterDCDeviceKM: Failed psFuncTable alloc");
 		goto ErrorExit;
 	}
-	OSMemSet(psDCInfo->psFuncTable, 0, sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE));
+	OSMemSet(psDCInfo->psFuncTable, 0,
+		 sizeof(struct PVRSRV_DC_SRV2DISP_KMJTABLE));
 
 	*psDCInfo->psFuncTable = *psFuncTable;
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(PVRSRV_DEVICE_NODE),
-		       (IMG_VOID **) & psDeviceNode, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRegisterDCDeviceKM: Failed psDeviceNode alloc"));
+		       sizeof(struct PVRSRV_DEVICE_NODE),
+		       (void **) &psDeviceNode, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR,
+			"PVRSRVRegisterDCDeviceKM: Failed psDeviceNode alloc");
 		goto ErrorExit;
 	}
-	OSMemSet(psDeviceNode, 0, sizeof(PVRSRV_DEVICE_NODE));
+	OSMemSet(psDeviceNode, 0, sizeof(struct PVRSRV_DEVICE_NODE));
 
-	psDeviceNode->pvDevice = (IMG_VOID *) psDCInfo;
+	psDeviceNode->pvDevice = (void *) psDCInfo;
 	psDeviceNode->ui32pvDeviceSize = sizeof(*psDCInfo);
 	psDeviceNode->ui32RefCount = 1;
 	psDeviceNode->sDevId.eDeviceType = PVRSRV_DEVICE_TYPE_EXT;
@@ -203,9 +200,8 @@
 
 	AllocateDeviceID(psSysData, &psDeviceNode->sDevId.ui32DeviceIndex);
 	psDCInfo->ui32DeviceID = psDeviceNode->sDevId.ui32DeviceIndex;
-	if (pui32DeviceID) {
+	if (pui32DeviceID)
 		*pui32DeviceID = psDeviceNode->sDevId.ui32DeviceIndex;
-	}
 
 	SysRegisterExternalDevice(psDeviceNode);
 
@@ -216,27 +212,27 @@
 
 ErrorExit:
 
-	if (psDCInfo->psFuncTable) {
+	if (psDCInfo->psFuncTable)
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE),
-			  psDCInfo->psFuncTable, IMG_NULL);
-	}
+			  sizeof(struct PVRSRV_DC_SRV2DISP_KMJTABLE),
+			  psDCInfo->psFuncTable, NULL);
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DISPLAYCLASS_INFO),
-		  psDCInfo, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+		  sizeof(struct PVRSRV_DISPLAYCLASS_INFO),
+		  psDCInfo, NULL);
 
 	return PVRSRV_ERROR_OUT_OF_MEMORY;
 }
 
-PVRSRV_ERROR PVRSRVRemoveDCDeviceKM(IMG_UINT32 ui32DevIndex)
+static enum PVRSRV_ERROR PVRSRVRemoveDCDeviceKM(u32 ui32DevIndex)
 {
-	SYS_DATA *psSysData;
-	PVRSRV_DEVICE_NODE **ppsDeviceNode, *psDeviceNode;
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	struct SYS_DATA *psSysData;
+	struct PVRSRV_DEVICE_NODE **ppsDeviceNode, *psDeviceNode;
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
 
 	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRemoveDCDeviceKM: Failed to get SysData"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVRemoveDCDeviceKM: Failed to get SysData");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
@@ -246,9 +242,8 @@
 		case PVRSRV_DEVICE_CLASS_DISPLAY:
 			{
 				if ((*ppsDeviceNode)->sDevId.ui32DeviceIndex ==
-				    ui32DevIndex) {
+				    ui32DevIndex)
 					goto FoundDevice;
-				}
 				break;
 			}
 		default:
@@ -259,9 +254,9 @@
 		ppsDeviceNode = &((*ppsDeviceNode)->psNext);
 	}
 
-	PVR_DPF((PVR_DBG_ERROR,
+	PVR_DPF(PVR_DBG_ERROR,
 		 "PVRSRVRemoveDCDeviceKM: requested device %d not present",
-		 ui32DevIndex));
+		 ui32DevIndex);
 
 	return PVRSRV_ERROR_GENERIC;
 
@@ -272,63 +267,66 @@
 
 	SysRemoveExternalDevice(psDeviceNode);
 
-	psDCInfo = (PVRSRV_DISPLAYCLASS_INFO *) psDeviceNode->pvDevice;
+	psDCInfo = (struct PVRSRV_DISPLAYCLASS_INFO *)psDeviceNode->pvDevice;
 	PVR_ASSERT(psDCInfo->ui32RefCount == 0);
 	FreeDeviceID(psSysData, ui32DevIndex);
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE),
-		  psDCInfo->psFuncTable, IMG_NULL);
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DISPLAYCLASS_INFO),
-		  psDCInfo, IMG_NULL);
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DEVICE_NODE),
-		  psDeviceNode, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+		  sizeof(struct PVRSRV_DC_SRV2DISP_KMJTABLE),
+		  psDCInfo->psFuncTable, NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+		  sizeof(struct PVRSRV_DISPLAYCLASS_INFO),
+		  psDCInfo, NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct PVRSRV_DEVICE_NODE),
+		  psDeviceNode, NULL);
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PVRSRVRegisterBCDeviceKM(PVRSRV_BC_SRV2BUFFER_KMJTABLE *
-				      psFuncTable, IMG_UINT32 * pui32DeviceID)
-{
-	PVRSRV_BUFFERCLASS_INFO *psBCInfo = IMG_NULL;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	SYS_DATA *psSysData;
+static enum PVRSRV_ERROR PVRSRVRegisterBCDeviceKM(
+		struct PVRSRV_BC_SRV2BUFFER_KMJTABLE *psFuncTable,
+		u32 *pui32DeviceID)
+{
+	struct PVRSRV_BUFFERCLASS_INFO *psBCInfo = NULL;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct SYS_DATA *psSysData;
 
 	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRegisterBCDeviceKM: Failed to get SysData"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVRegisterBCDeviceKM: Failed to get SysData");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 		       sizeof(*psBCInfo),
-		       (IMG_VOID **) & psBCInfo, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRegisterBCDeviceKM: Failed psBCInfo alloc"));
+		       (void **) &psBCInfo, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVRegisterBCDeviceKM: Failed psBCInfo alloc");
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 	OSMemSet(psBCInfo, 0, sizeof(*psBCInfo));
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(PVRSRV_BC_SRV2BUFFER_KMJTABLE),
-		       (IMG_VOID **) & psBCInfo->psFuncTable,
-		       IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRegisterBCDeviceKM: Failed psFuncTable alloc"));
+		       sizeof(struct PVRSRV_BC_SRV2BUFFER_KMJTABLE),
+		       (void **) &psBCInfo->psFuncTable,
+		       NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVRegisterBCDeviceKM: Failed psFuncTable alloc");
 		goto ErrorExit;
 	}
 	OSMemSet(psBCInfo->psFuncTable, 0,
-		 sizeof(PVRSRV_BC_SRV2BUFFER_KMJTABLE));
+		 sizeof(struct PVRSRV_BC_SRV2BUFFER_KMJTABLE));
 
 	*psBCInfo->psFuncTable = *psFuncTable;
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(PVRSRV_DEVICE_NODE),
-		       (IMG_VOID **) & psDeviceNode, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRegisterBCDeviceKM: Failed psDeviceNode alloc"));
+		       sizeof(struct PVRSRV_DEVICE_NODE),
+		       (void **) &psDeviceNode, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR,
+			"PVRSRVRegisterBCDeviceKM: Failed psDeviceNode alloc");
 		goto ErrorExit;
 	}
-	OSMemSet(psDeviceNode, 0, sizeof(PVRSRV_DEVICE_NODE));
+	OSMemSet(psDeviceNode, 0, sizeof(struct PVRSRV_DEVICE_NODE));
 
-	psDeviceNode->pvDevice = (IMG_VOID *) psBCInfo;
+	psDeviceNode->pvDevice = (void *) psBCInfo;
 	psDeviceNode->ui32pvDeviceSize = sizeof(*psBCInfo);
 	psDeviceNode->ui32RefCount = 1;
 	psDeviceNode->sDevId.eDeviceType = PVRSRV_DEVICE_TYPE_EXT;
@@ -337,9 +335,8 @@
 
 	AllocateDeviceID(psSysData, &psDeviceNode->sDevId.ui32DeviceIndex);
 	psBCInfo->ui32DeviceID = psDeviceNode->sDevId.ui32DeviceIndex;
-	if (pui32DeviceID) {
+	if (pui32DeviceID)
 		*pui32DeviceID = psDeviceNode->sDevId.ui32DeviceIndex;
-	}
 
 	psDeviceNode->psNext = psSysData->psDeviceNodeList;
 	psSysData->psDeviceNodeList = psDeviceNode;
@@ -348,27 +345,26 @@
 
 ErrorExit:
 
-	if (psBCInfo->psFuncTable) {
+	if (psBCInfo->psFuncTable)
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  sizeof(PVRSRV_BC_SRV2BUFFER_KMJTABLE),
-			  psBCInfo->psFuncTable, IMG_NULL);
-	}
+			  sizeof(struct PVRSRV_BC_SRV2BUFFER_KMJTABLE),
+			  psBCInfo->psFuncTable, NULL);
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_BUFFERCLASS_INFO),
-		  psBCInfo, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+		  sizeof(struct PVRSRV_BUFFERCLASS_INFO), psBCInfo, NULL);
 
 	return PVRSRV_ERROR_OUT_OF_MEMORY;
 }
 
-PVRSRV_ERROR PVRSRVRemoveBCDeviceKM(IMG_UINT32 ui32DevIndex)
+static enum PVRSRV_ERROR PVRSRVRemoveBCDeviceKM(u32 ui32DevIndex)
 {
-	SYS_DATA *psSysData;
-	PVRSRV_DEVICE_NODE **ppsDevNode, *psDevNode;
-	PVRSRV_BUFFERCLASS_INFO *psBCInfo;
+	struct SYS_DATA *psSysData;
+	struct PVRSRV_DEVICE_NODE **ppsDevNode, *psDevNode;
+	struct PVRSRV_BUFFERCLASS_INFO *psBCInfo;
 
 	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRemoveBCDeviceKM: Failed to get SysData"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVRemoveBCDeviceKM: Failed to get SysData");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
@@ -378,9 +374,8 @@
 		case PVRSRV_DEVICE_CLASS_BUFFER:
 			{
 				if ((*ppsDevNode)->sDevId.ui32DeviceIndex ==
-				    ui32DevIndex) {
+				    ui32DevIndex)
 					goto FoundDevice;
-				}
 				break;
 			}
 		default:
@@ -391,9 +386,9 @@
 		ppsDevNode = &(*ppsDevNode)->psNext;
 	}
 
-	PVR_DPF((PVR_DBG_ERROR,
+	PVR_DPF(PVR_DBG_ERROR,
 		 "PVRSRVRemoveBCDeviceKM: requested device %d not present",
-		 ui32DevIndex));
+		 ui32DevIndex);
 
 	return PVRSRV_ERROR_GENERIC;
 
@@ -403,42 +398,43 @@
 	*ppsDevNode = psDevNode->psNext;
 
 	FreeDeviceID(psSysData, ui32DevIndex);
-	psBCInfo = (PVRSRV_BUFFERCLASS_INFO *) psDevNode->pvDevice;
+	psBCInfo = (struct PVRSRV_BUFFERCLASS_INFO *)psDevNode->pvDevice;
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-		  sizeof(PVRSRV_BC_SRV2BUFFER_KMJTABLE), psBCInfo->psFuncTable,
-		  IMG_NULL);
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_BUFFERCLASS_INFO),
-		  psBCInfo, IMG_NULL);
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DEVICE_NODE),
-		  psDevNode, IMG_NULL);
+		  sizeof(struct PVRSRV_BC_SRV2BUFFER_KMJTABLE),
+		  psBCInfo->psFuncTable,
+		  NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+		  sizeof(struct PVRSRV_BUFFERCLASS_INFO), psBCInfo, NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct PVRSRV_DEVICE_NODE),
+		  psDevNode, NULL);
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVCloseDCDeviceKM(IMG_HANDLE hDeviceKM,
+enum PVRSRV_ERROR PVRSRVCloseDCDeviceKM(void *hDeviceKM,
 				       IMG_BOOL bResManCallback)
 {
-	PVRSRV_ERROR eError;
-	PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO *psDCPerContextInfo;
+	struct PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO *psDCPerContextInfo;
 
 	PVR_UNREFERENCED_PARAMETER(bResManCallback);
 
-	psDCPerContextInfo = (PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO *) hDeviceKM;
+	psDCPerContextInfo = (struct PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO *)
+								hDeviceKM;
 
-	eError = ResManFreeResByPtr(psDCPerContextInfo->hResItem);
+	ResManFreeResByPtr(psDCPerContextInfo->hResItem);
 
-	return eError;
+	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR CloseDCDeviceCallBack(IMG_PVOID pvParam,
-					  IMG_UINT32 ui32Param)
+static enum PVRSRV_ERROR CloseDCDeviceCallBack(void *pvParam,
+					  u32 ui32Param)
 {
-	PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO *psDCPerContextInfo;
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	struct PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO *psDCPerContextInfo;
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
-	psDCPerContextInfo = (PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO *) pvParam;
+	psDCPerContextInfo = (struct PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO *)
+									pvParam;
 	psDCInfo = psDCPerContextInfo->psDCInfo;
 
 	psDCInfo->ui32RefCount--;
@@ -449,56 +445,55 @@
 		PVRSRVFreeSyncInfoKM(psDCInfo->sSystemBuffer.sDeviceClassBuffer.
 				     psKernelSyncInfo);
 
-		psDCInfo->hDevMemContext = IMG_NULL;
-		psDCInfo->hExtDevice = IMG_NULL;
+		psDCInfo->hDevMemContext = NULL;
+		psDCInfo->hExtDevice = NULL;
 	}
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-		  sizeof(PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO),
-		  psDCPerContextInfo, IMG_NULL);
+		  sizeof(struct PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO),
+		  psDCPerContextInfo, NULL);
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVOpenDCDeviceKM(PVRSRV_PER_PROCESS_DATA * psPerProc,
-				      IMG_UINT32 ui32DeviceID,
-				      IMG_HANDLE hDevCookie,
-				      IMG_HANDLE * phDeviceKM)
-{
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
-	PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO *psDCPerContextInfo;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	SYS_DATA *psSysData;
+enum PVRSRV_ERROR PVRSRVOpenDCDeviceKM(
+				struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+				u32 ui32DeviceID, void *hDevCookie,
+				void **phDeviceKM)
+{
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	struct PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO *psDCPerContextInfo;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct SYS_DATA *psSysData;
 
 	if (!phDeviceKM) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVOpenDCDeviceKM: Invalid params"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVOpenDCDeviceKM: Invalid params");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
 	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVOpenDCDeviceKM: Failed to get SysData"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVOpenDCDeviceKM: Failed to get SysData");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
 	psDeviceNode = psSysData->psDeviceNodeList;
 	while (psDeviceNode) {
 		if ((psDeviceNode->sDevId.eDeviceClass ==
-		     PVRSRV_DEVICE_CLASS_DISPLAY)
-		    && (psDeviceNode->sDevId.ui32DeviceIndex == ui32DeviceID)) {
+		     PVRSRV_DEVICE_CLASS_DISPLAY) &&
+		     (psDeviceNode->sDevId.ui32DeviceIndex == ui32DeviceID)) {
 
-			psDCInfo =
-			    (PVRSRV_DISPLAYCLASS_INFO *) psDeviceNode->pvDevice;
+			psDCInfo = (struct PVRSRV_DISPLAYCLASS_INFO *)
+							psDeviceNode->pvDevice;
 			goto FoundDevice;
 		}
 		psDeviceNode = psDeviceNode->psNext;
 	}
 
-	PVR_DPF((PVR_DBG_ERROR,
+	PVR_DPF(PVR_DBG_ERROR,
 		 "PVRSRVOpenDCDeviceKM: no devnode matching index %d",
-		 ui32DeviceID));
+		 ui32DeviceID);
 
 	return PVRSRV_ERROR_GENERIC;
 
@@ -506,53 +501,47 @@
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 		       sizeof(*psDCPerContextInfo),
-		       (IMG_VOID **) & psDCPerContextInfo,
-		       IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVOpenDCDeviceKM: Failed psDCPerContextInfo alloc"));
+		       (void **) &psDCPerContextInfo,
+		       NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVOpenDCDeviceKM: "
+			"Failed psDCPerContextInfo alloc");
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 	OSMemSet(psDCPerContextInfo, 0, sizeof(*psDCPerContextInfo));
 
 	if (psDCInfo->ui32RefCount++ == 0) {
-		PVRSRV_ERROR eError;
+		enum PVRSRV_ERROR eError;
 
-		psDeviceNode = (PVRSRV_DEVICE_NODE *) hDevCookie;
-		PVR_ASSERT(psDeviceNode != IMG_NULL);
+		psDeviceNode = (struct PVRSRV_DEVICE_NODE *)hDevCookie;
+		PVR_ASSERT(psDeviceNode != NULL);
 
 		psDCInfo->hDevMemContext =
-		    (IMG_HANDLE) psDeviceNode->sDevMemoryInfo.pBMKernelContext;
+		    (void *) psDeviceNode->sDevMemoryInfo.pBMKernelContext;
 
-		eError = PVRSRVAllocSyncInfoKM(IMG_NULL,
-					       (IMG_HANDLE) psDeviceNode->
+		eError = PVRSRVAllocSyncInfoKM(NULL,
+					       (void *) psDeviceNode->
 					       sDevMemoryInfo.pBMKernelContext,
 					       &psDCInfo->sSystemBuffer.
 					       sDeviceClassBuffer.
 					       psKernelSyncInfo);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVOpenDCDeviceKM: Failed sync info alloc"));
+			PVR_DPF(PVR_DBG_ERROR,
+			       "PVRSRVOpenDCDeviceKM: Failed sync info alloc");
 			psDCInfo->ui32RefCount--;
 			return eError;
 		}
 
 		eError = psDCInfo->psFuncTable->pfnOpenDCDevice(ui32DeviceID,
-								&psDCInfo->
-								hExtDevice,
-								(PVRSRV_SYNC_DATA
-								 *) psDCInfo->
-								sSystemBuffer.
-								sDeviceClassBuffer.
-								psKernelSyncInfo->
-								psSyncDataMemInfoKM->
-								pvLinAddrKM);
+			&psDCInfo->hExtDevice,
+			(struct PVRSRV_SYNC_DATA *)psDCInfo->sSystemBuffer.
+				sDeviceClassBuffer.psKernelSyncInfo->
+					psSyncDataMemInfoKM->pvLinAddrKM);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVOpenDCDeviceKM: Failed to open external DC device"));
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVOpenDCDeviceKM: "
+					"Failed to open external DC device");
 			psDCInfo->ui32RefCount--;
 			PVRSRVFreeSyncInfoKM(psDCInfo->sSystemBuffer.
-					     sDeviceClassBuffer.
-					     psKernelSyncInfo);
+					   sDeviceClassBuffer.psKernelSyncInfo);
 			return eError;
 		}
 	}
@@ -563,21 +552,20 @@
 			      RESMAN_TYPE_DISPLAYCLASS_DEVICE,
 			      psDCPerContextInfo, 0, CloseDCDeviceCallBack);
 
-	*phDeviceKM = (IMG_HANDLE) psDCPerContextInfo;
+	*phDeviceKM = (void *) psDCPerContextInfo;
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVEnumDCFormatsKM(IMG_HANDLE hDeviceKM,
-				       IMG_UINT32 * pui32Count,
-				       DISPLAY_FORMAT * psFormat)
+enum PVRSRV_ERROR PVRSRVEnumDCFormatsKM(void *hDeviceKM,
+				       u32 *pui32Count,
+				       struct DISPLAY_FORMAT *psFormat)
 {
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
 
 	if (!hDeviceKM || !pui32Count || !psFormat) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVEnumDCFormatsKM: Invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVEnumDCFormatsKM: Invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
@@ -587,38 +575,33 @@
 						       pui32Count, psFormat);
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVEnumDCDimsKM(IMG_HANDLE hDeviceKM,
-				    DISPLAY_FORMAT * psFormat,
-				    IMG_UINT32 * pui32Count,
-				    DISPLAY_DIMS * psDim)
+enum PVRSRV_ERROR PVRSRVEnumDCDimsKM(void *hDeviceKM,
+				    struct DISPLAY_FORMAT *psFormat,
+				    u32 *pui32Count, struct DISPLAY_DIMS *psDim)
 {
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
 
 	if (!hDeviceKM || !pui32Count || !psFormat) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVEnumDCDimsKM: Invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVEnumDCDimsKM: Invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
 
 	return psDCInfo->psFuncTable->pfnEnumDCDims(psDCInfo->hExtDevice,
-						    psFormat, pui32Count,
-						    psDim);
+						  psFormat, pui32Count, psDim);
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVGetDCSystemBufferKM(IMG_HANDLE hDeviceKM,
-					   IMG_HANDLE * phBuffer)
+enum PVRSRV_ERROR PVRSRVGetDCSystemBufferKM(void *hDeviceKM, void **phBuffer)
 {
-	PVRSRV_ERROR eError;
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
-	IMG_HANDLE hExtBuffer;
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	void *hExtBuffer;
 
 	if (!hDeviceKM || !phBuffer) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVGetDCSystemBufferKM: Invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVGetDCSystemBufferKM: "
+					"Invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
@@ -628,8 +611,8 @@
 	    psDCInfo->psFuncTable->pfnGetDCSystemBuffer(psDCInfo->hExtDevice,
 							&hExtBuffer);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVGetDCSystemBufferKM: Failed to get valid buffer handle from external driver"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVGetDCSystemBufferKM: "
+		     "Failed to get valid buffer handle from external driver");
 		return eError;
 	}
 
@@ -643,21 +626,20 @@
 
 	psDCInfo->sSystemBuffer.psDCInfo = psDCInfo;
 
-	*phBuffer = (IMG_HANDLE) & (psDCInfo->sSystemBuffer);
+	*phBuffer = (void *) &(psDCInfo->sSystemBuffer);
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVGetDCInfoKM(IMG_HANDLE hDeviceKM,
-				   DISPLAY_INFO * psDisplayInfo)
+enum PVRSRV_ERROR PVRSRVGetDCInfoKM(void *hDeviceKM,
+				struct DISPLAY_INFO *psDisplayInfo)
 {
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
-	PVRSRV_ERROR eError;
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	enum PVRSRV_ERROR eError;
 
 	if (!hDeviceKM || !psDisplayInfo) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVGetDCInfoKM: Invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVGetDCInfoKM: Invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
@@ -666,44 +648,41 @@
 	eError =
 	    psDCInfo->psFuncTable->pfnGetDCInfo(psDCInfo->hExtDevice,
 						psDisplayInfo);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	if (psDisplayInfo->ui32MaxSwapChainBuffers >
-	    PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS) {
+	    PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS)
 		psDisplayInfo->ui32MaxSwapChainBuffers =
 		    PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS;
-	}
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT PVRSRV_ERROR PVRSRVDestroyDCSwapChainKM(IMG_HANDLE hSwapChain)
+enum PVRSRV_ERROR PVRSRVDestroyDCSwapChainKM(void *hSwapChain)
 {
-	PVRSRV_ERROR eError;
-	PVRSRV_DC_SWAPCHAIN *psSwapChain;
+	struct PVRSRV_DC_SWAPCHAIN *psSwapChain;
 
 	if (!hSwapChain) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVDestroyDCSwapChainKM: Invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVDestroyDCSwapChainKM: Invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psSwapChain = hSwapChain;
 
-	eError = ResManFreeResByPtr(psSwapChain->hResItem);
+	ResManFreeResByPtr(psSwapChain->hResItem);
 
-	return eError;
+	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR DestroyDCSwapChainCallBack(IMG_PVOID pvParam,
-					       IMG_UINT32 ui32Param)
+static enum PVRSRV_ERROR DestroyDCSwapChainCallBack(void *pvParam,
+					       u32 ui32Param)
 {
-	PVRSRV_ERROR eError;
-	PVRSRV_DC_SWAPCHAIN *psSwapChain = pvParam;
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo = psSwapChain->psDCInfo;
-	IMG_UINT32 i;
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_DC_SWAPCHAIN *psSwapChain = pvParam;
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo = psSwapChain->psDCInfo;
+	u32 i;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
@@ -715,96 +694,94 @@
 							 hExtSwapChain);
 
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "DestroyDCSwapChainCallBack: Failed to destroy DC swap chain"));
+		PVR_DPF(PVR_DBG_ERROR, "DestroyDCSwapChainCallBack: "
+			 "Failed to destroy DC swap chain");
 		return eError;
 	}
 
 	for (i = 0; i < psSwapChain->ui32BufferCount; i++) {
 		if (psSwapChain->asBuffer[i].sDeviceClassBuffer.
-		    psKernelSyncInfo) {
+		    psKernelSyncInfo)
 			PVRSRVFreeSyncInfoKM(psSwapChain->asBuffer[i].
 					     sDeviceClassBuffer.
 					     psKernelSyncInfo);
-		}
+
 	}
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DC_SWAPCHAIN),
-		  psSwapChain, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct PVRSRV_DC_SWAPCHAIN),
+		  psSwapChain, NULL);
 
 	return eError;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVCreateDCSwapChainKM(PVRSRV_PER_PROCESS_DATA * psPerProc,
-					   IMG_HANDLE hDeviceKM,
-					   IMG_UINT32 ui32Flags,
-					   DISPLAY_SURF_ATTRIBUTES *
-					   psDstSurfAttrib,
-					   DISPLAY_SURF_ATTRIBUTES *
-					   psSrcSurfAttrib,
-					   IMG_UINT32 ui32BufferCount,
-					   IMG_UINT32 ui32OEMFlags,
-					   IMG_HANDLE * phSwapChain,
-					   IMG_UINT32 * pui32SwapChainID)
-{
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
-	PVRSRV_DC_SWAPCHAIN *psSwapChain = IMG_NULL;
-	PVRSRV_SYNC_DATA *apsSyncData[PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS];
-	PVRSRV_QUEUE_INFO *psQueue = IMG_NULL;
-	PVRSRV_ERROR eError;
-	IMG_UINT32 i;
+enum PVRSRV_ERROR PVRSRVCreateDCSwapChainKM(struct PVRSRV_PER_PROCESS_DATA
+								   *psPerProc,
+			   void *hDeviceKM,
+			   u32 ui32Flags,
+			   struct DISPLAY_SURF_ATTRIBUTES *psDstSurfAttrib,
+			   struct DISPLAY_SURF_ATTRIBUTES *psSrcSurfAttrib,
+			   u32 ui32BufferCount,
+			   u32 ui32OEMFlags,
+			   void **phSwapChain,
+			   u32 *pui32SwapChainID)
+{
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	struct PVRSRV_DC_SWAPCHAIN *psSwapChain = NULL;
+	struct PVRSRV_SYNC_DATA *apsSyncData[PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS];
+	struct PVRSRV_QUEUE_INFO *psQueue = NULL;
+	enum PVRSRV_ERROR eError;
+	u32 i;
 
 	if (!hDeviceKM
 	    || !psDstSurfAttrib
 	    || !psSrcSurfAttrib || !phSwapChain || !pui32SwapChainID) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVCreateDCSwapChainKM: Invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVCreateDCSwapChainKM: Invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	if (ui32BufferCount > PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVCreateDCSwapChainKM: Too many buffers"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVCreateDCSwapChainKM: Too many buffers");
 		return PVRSRV_ERROR_TOOMANYBUFFERS;
 	}
 
 	if (ui32BufferCount < 2) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVCreateDCSwapChainKM: Too few buffers"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVCreateDCSwapChainKM: Too few buffers");
 		return PVRSRV_ERROR_TOO_FEW_BUFFERS;
 	}
 
 	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(PVRSRV_DC_SWAPCHAIN),
-		       (IMG_VOID **) & psSwapChain, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVCreateDCSwapChainKM: Failed psSwapChain alloc"));
+		       sizeof(struct PVRSRV_DC_SWAPCHAIN),
+		       (void **) &psSwapChain, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVCreateDCSwapChainKM: "
+					"Failed psSwapChain alloc");
 		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
 		goto ErrorExit;
 	}
-	OSMemSet(psSwapChain, 0, sizeof(PVRSRV_DC_SWAPCHAIN));
+	OSMemSet(psSwapChain, 0, sizeof(struct PVRSRV_DC_SWAPCHAIN));
 
 	eError = PVRSRVCreateCommandQueueKM(1024, &psQueue);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVCreateDCSwapChainKM: Failed to create CmdQueue"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVCreateDCSwapChainKM: "
+					"Failed to create CmdQueue");
 		goto ErrorExit;
 	}
 
 	psSwapChain->psQueue = psQueue;
 
 	for (i = 0; i < ui32BufferCount; i++) {
-		eError = PVRSRVAllocSyncInfoKM(IMG_NULL,
+		eError = PVRSRVAllocSyncInfoKM(NULL,
 					       psDCInfo->hDevMemContext,
 					       &psSwapChain->asBuffer[i].
 					       sDeviceClassBuffer.
 					       psKernelSyncInfo);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVCreateDCSwapChainKM: Failed to alloc syninfo for psSwapChain"));
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVCreateDCSwapChainKM: "
+				"Failed to alloc syninfo for psSwapChain");
 			goto ErrorExit;
 		}
 
@@ -819,7 +796,7 @@
 		psSwapChain->asBuffer[i].psSwapChain = psSwapChain;
 
 		apsSyncData[i] =
-		    (PVRSRV_SYNC_DATA *) psSwapChain->asBuffer[i].
+		    (struct PVRSRV_SYNC_DATA *)psSwapChain->asBuffer[i].
 		    sDeviceClassBuffer.psKernelSyncInfo->psSyncDataMemInfoKM->
 		    pvLinAddrKM;
 	}
@@ -839,18 +816,17 @@
 							hExtSwapChain,
 							pui32SwapChainID);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVCreateDCSwapChainKM: Failed to create 3rd party SwapChain"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVCreateDCSwapChainKM: "
+			"Failed to create 3rd party SwapChain");
 		goto ErrorExit;
 	}
 
-	*phSwapChain = (IMG_HANDLE) psSwapChain;
+	*phSwapChain = (void *) psSwapChain;
 
 	psSwapChain->hResItem = ResManRegisterRes(psPerProc->hResManContext,
-						  RESMAN_TYPE_DISPLAYCLASS_SWAPCHAIN,
-						  psSwapChain,
-						  0,
-						  DestroyDCSwapChainCallBack);
+					  RESMAN_TYPE_DISPLAYCLASS_SWAPCHAIN,
+					  psSwapChain, 0,
+					  DestroyDCSwapChainCallBack);
 
 	return eError;
 
@@ -858,133 +834,119 @@
 
 	for (i = 0; i < ui32BufferCount; i++) {
 		if (psSwapChain->asBuffer[i].sDeviceClassBuffer.
-		    psKernelSyncInfo) {
+		    psKernelSyncInfo)
 			PVRSRVFreeSyncInfoKM(psSwapChain->asBuffer[i].
 					     sDeviceClassBuffer.
 					     psKernelSyncInfo);
-		}
+
 	}
 
-	if (psQueue) {
+	if (psQueue)
 		PVRSRVDestroyCommandQueueKM(psQueue);
-	}
 
-	if (psSwapChain) {
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DC_SWAPCHAIN),
-			  psSwapChain, IMG_NULL);
-	}
+	if (psSwapChain)
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+			  sizeof(struct PVRSRV_DC_SWAPCHAIN),
+			  psSwapChain, NULL);
 
 	return eError;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVSetDCDstRectKM(IMG_HANDLE hDeviceKM,
-				      IMG_HANDLE hSwapChain, IMG_RECT * psRect)
+enum PVRSRV_ERROR PVRSRVSetDCDstRectKM(void *hDeviceKM,
+				      void *hSwapChain, struct IMG_RECT *psRect)
 {
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
-	PVRSRV_DC_SWAPCHAIN *psSwapChain;
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	struct PVRSRV_DC_SWAPCHAIN *psSwapChain;
 
 	if (!hDeviceKM || !hSwapChain) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVSetDCDstRectKM: Invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVSetDCDstRectKM: Invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
-	psSwapChain = (PVRSRV_DC_SWAPCHAIN *) hSwapChain;
+	psSwapChain = (struct PVRSRV_DC_SWAPCHAIN *)hSwapChain;
 
 	return psDCInfo->psFuncTable->pfnSetDCDstRect(psDCInfo->hExtDevice,
-						      psSwapChain->
-						      hExtSwapChain, psRect);
+					psSwapChain->hExtSwapChain, psRect);
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVSetDCSrcRectKM(IMG_HANDLE hDeviceKM,
-				      IMG_HANDLE hSwapChain, IMG_RECT * psRect)
+enum PVRSRV_ERROR PVRSRVSetDCSrcRectKM(void *hDeviceKM,
+				  void *hSwapChain, struct IMG_RECT *psRect)
 {
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
-	PVRSRV_DC_SWAPCHAIN *psSwapChain;
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	struct PVRSRV_DC_SWAPCHAIN *psSwapChain;
 
 	if (!hDeviceKM || !hSwapChain) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVSetDCSrcRectKM: Invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVSetDCSrcRectKM: Invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
-	psSwapChain = (PVRSRV_DC_SWAPCHAIN *) hSwapChain;
+	psSwapChain = (struct PVRSRV_DC_SWAPCHAIN *)hSwapChain;
 
 	return psDCInfo->psFuncTable->pfnSetDCSrcRect(psDCInfo->hExtDevice,
-						      psSwapChain->
-						      hExtSwapChain, psRect);
+					psSwapChain->hExtSwapChain, psRect);
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVSetDCDstColourKeyKM(IMG_HANDLE hDeviceKM,
-					   IMG_HANDLE hSwapChain,
-					   IMG_UINT32 ui32CKColour)
+enum PVRSRV_ERROR PVRSRVSetDCDstColourKeyKM(void *hDeviceKM, void *hSwapChain,
+				       u32 ui32CKColour)
 {
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
-	PVRSRV_DC_SWAPCHAIN *psSwapChain;
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	struct PVRSRV_DC_SWAPCHAIN *psSwapChain;
 
 	if (!hDeviceKM || !hSwapChain) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVSetDCDstColourKeyKM: Invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVSetDCDstColourKeyKM: Invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
-	psSwapChain = (PVRSRV_DC_SWAPCHAIN *) hSwapChain;
+	psSwapChain = (struct PVRSRV_DC_SWAPCHAIN *)hSwapChain;
 
 	return psDCInfo->psFuncTable->pfnSetDCDstColourKey(psDCInfo->hExtDevice,
-							   psSwapChain->
-							   hExtSwapChain,
-							   ui32CKColour);
+				     psSwapChain->hExtSwapChain, ui32CKColour);
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVSetDCSrcColourKeyKM(IMG_HANDLE hDeviceKM,
-					   IMG_HANDLE hSwapChain,
-					   IMG_UINT32 ui32CKColour)
+enum PVRSRV_ERROR PVRSRVSetDCSrcColourKeyKM(void *hDeviceKM, void *hSwapChain,
+					   u32 ui32CKColour)
 {
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
-	PVRSRV_DC_SWAPCHAIN *psSwapChain;
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	struct PVRSRV_DC_SWAPCHAIN *psSwapChain;
 
 	if (!hDeviceKM || !hSwapChain) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVSetDCSrcColourKeyKM: Invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVSetDCSrcColourKeyKM: Invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
-	psSwapChain = (PVRSRV_DC_SWAPCHAIN *) hSwapChain;
+	psSwapChain = (struct PVRSRV_DC_SWAPCHAIN *)hSwapChain;
 
 	return psDCInfo->psFuncTable->pfnSetDCSrcColourKey(psDCInfo->hExtDevice,
-							   psSwapChain->
-							   hExtSwapChain,
-							   ui32CKColour);
-}
-
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVGetDCBuffersKM(IMG_HANDLE hDeviceKM,
-				      IMG_HANDLE hSwapChain,
-				      IMG_UINT32 * pui32BufferCount,
-				      IMG_HANDLE * phBuffer)
-{
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
-	PVRSRV_DC_SWAPCHAIN *psSwapChain;
-	IMG_HANDLE ahExtBuffer[PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS];
-	PVRSRV_ERROR eError;
-	IMG_UINT32 i;
+				     psSwapChain->hExtSwapChain, ui32CKColour);
+}
+
+enum PVRSRV_ERROR PVRSRVGetDCBuffersKM(void *hDeviceKM,
+				      void *hSwapChain,
+				      u32 *pui32BufferCount,
+				      void **phBuffer)
+{
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	struct PVRSRV_DC_SWAPCHAIN *psSwapChain;
+	void *ahExtBuffer[PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS];
+	enum PVRSRV_ERROR eError;
+	u32 i;
 
 	if (!hDeviceKM || !hSwapChain || !phBuffer) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVGetDCBuffersKM: Invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVGetDCBuffersKM: Invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
-	psSwapChain = (PVRSRV_DC_SWAPCHAIN *) hSwapChain;
+	psSwapChain = (struct PVRSRV_DC_SWAPCHAIN *)hSwapChain;
 
 	eError = psDCInfo->psFuncTable->pfnGetDCBuffers(psDCInfo->hExtDevice,
 							psSwapChain->
@@ -997,40 +959,39 @@
 	for (i = 0; i < *pui32BufferCount; i++) {
 		psSwapChain->asBuffer[i].sDeviceClassBuffer.hExtBuffer =
 		    ahExtBuffer[i];
-		phBuffer[i] = (IMG_HANDLE) & psSwapChain->asBuffer[i];
+		phBuffer[i] = (void *) &psSwapChain->asBuffer[i];
 	}
 
 	return eError;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVSwapToDCBufferKM(IMG_HANDLE hDeviceKM,
-					IMG_HANDLE hBuffer,
-					IMG_UINT32 ui32SwapInterval,
-					IMG_HANDLE hPrivateTag,
-					IMG_UINT32 ui32ClipRectCount,
-					IMG_RECT * psClipRect)
-{
-	PVRSRV_ERROR eError;
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
-	PVRSRV_DC_BUFFER *psBuffer;
-	PVRSRV_QUEUE_INFO *psQueue;
-	DISPLAYCLASS_FLIP_COMMAND *psFlipCmd;
-	IMG_UINT32 i;
+enum PVRSRV_ERROR PVRSRVSwapToDCBufferKM(void *hDeviceKM,
+					void *hBuffer,
+					u32 ui32SwapInterval,
+					void *hPrivateTag,
+					u32 ui32ClipRectCount,
+					struct IMG_RECT *psClipRect)
+{
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	struct PVRSRV_DC_BUFFER *psBuffer;
+	struct PVRSRV_QUEUE_INFO *psQueue;
+	struct DISPLAYCLASS_FLIP_COMMAND *psFlipCmd;
+	u32 i;
 	IMG_BOOL bStart = IMG_FALSE;
-	IMG_UINT32 uiStart = 0;
-	IMG_UINT32 ui32NumSrcSyncs = 1;
-	PVRSRV_KERNEL_SYNC_INFO *apsSrcSync[2];
-	PVRSRV_COMMAND *psCommand;
+	u32 uiStart = 0;
+	u32 ui32NumSrcSyncs = 1;
+	struct PVRSRV_KERNEL_SYNC_INFO *apsSrcSync[2];
+	struct PVRSRV_COMMAND *psCommand;
 
 	if (!hDeviceKM || !hBuffer || !psClipRect) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVSwapToDCBufferKM: Invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVSwapToDCBufferKM: Invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
-	psBuffer = (PVRSRV_DC_BUFFER *) hBuffer;
+	psBuffer = (struct PVRSRV_DC_BUFFER *)hBuffer;
 
 	psQueue = psBuffer->psSwapChain->psQueue;
 
@@ -1043,56 +1004,44 @@
 		ui32NumSrcSyncs++;
 	}
 
-	eError = PVRSRVInsertCommandKM(psQueue,
-				       &psCommand,
-				       psDCInfo->ui32DeviceID,
-				       DC_FLIP_COMMAND,
-				       0,
-				       IMG_NULL,
-				       ui32NumSrcSyncs,
-				       apsSrcSync,
-				       sizeof(DISPLAYCLASS_FLIP_COMMAND) +
-				       (sizeof(IMG_RECT) * ui32ClipRectCount));
+	eError = PVRSRVInsertCommandKM(psQueue, &psCommand,
+				      psDCInfo->ui32DeviceID, DC_FLIP_COMMAND,
+				      0, NULL, ui32NumSrcSyncs, apsSrcSync,
+				      sizeof(struct DISPLAYCLASS_FLIP_COMMAND) +
+				      (sizeof(struct IMG_RECT) *
+							   ui32ClipRectCount));
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVSwapToDCBufferKM: Failed to get space in queue"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVSwapToDCBufferKM: "
+					"Failed to get space in queue");
 		goto Exit;
 	}
 
-	psFlipCmd = (DISPLAYCLASS_FLIP_COMMAND *) psCommand->pvData;
-
+	psFlipCmd = (struct DISPLAYCLASS_FLIP_COMMAND *)psCommand->pvData;
 	psFlipCmd->hExtDevice = psDCInfo->hExtDevice;
-
 	psFlipCmd->hExtSwapChain = psBuffer->psSwapChain->hExtSwapChain;
-
 	psFlipCmd->hExtBuffer = psBuffer->sDeviceClassBuffer.hExtBuffer;
-
 	psFlipCmd->hPrivateTag = hPrivateTag;
-
 	psFlipCmd->ui32ClipRectCount = ui32ClipRectCount;
-
 	psFlipCmd->psClipRect =
-	    (IMG_RECT *) ((IMG_UINT8 *) psFlipCmd +
-			  sizeof(DISPLAYCLASS_FLIP_COMMAND));
+	    (struct IMG_RECT *)((u8 *) psFlipCmd +
+			  sizeof(struct DISPLAYCLASS_FLIP_COMMAND));
 
-	for (i = 0; i < ui32ClipRectCount; i++) {
+	for (i = 0; i < ui32ClipRectCount; i++)
 		psFlipCmd->psClipRect[i] = psClipRect[i];
-	}
 
 	psFlipCmd->ui32SwapInterval = ui32SwapInterval;
 
 	eError = PVRSRVSubmitCommandKM(psQueue, psCommand);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVSwapToDCBufferKM: Failed to submit command"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVSwapToDCBufferKM: Failed to submit command");
 		goto Exit;
 	}
 
 	do {
 		if (PVRSRVProcessQueues(KERNEL_ID, IMG_FALSE) !=
-		    PVRSRV_ERROR_PROCESSING_BLOCKED) {
+		    PVRSRV_ERROR_PROCESSING_BLOCKED)
 			goto ProcessedQueues;
-		}
 
 		if (bStart == IMG_FALSE) {
 			uiStart = OSClockus();
@@ -1101,8 +1050,8 @@
 		OSWaitus(MAX_HW_TIME_US / WAIT_TRY_COUNT);
 	} while ((OSClockus() - uiStart) < MAX_HW_TIME_US);
 
-	PVR_DPF((PVR_DBG_ERROR,
-		 "PVRSRVSwapToDCBufferKM: Failed to process queues"));
+	PVR_DPF(PVR_DBG_ERROR,
+		 "PVRSRVSwapToDCBufferKM: Failed to process queues");
 
 	eError = PVRSRV_ERROR_GENERIC;
 	goto Exit;
@@ -1115,29 +1064,27 @@
 	return eError;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVSwapToDCSystemKM(IMG_HANDLE hDeviceKM,
-					IMG_HANDLE hSwapChain)
-{
-	PVRSRV_ERROR eError;
-	PVRSRV_QUEUE_INFO *psQueue;
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
-	PVRSRV_DC_SWAPCHAIN *psSwapChain;
-	DISPLAYCLASS_FLIP_COMMAND *psFlipCmd;
+enum PVRSRV_ERROR PVRSRVSwapToDCSystemKM(void *hDeviceKM, void *hSwapChain)
+{
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_QUEUE_INFO *psQueue;
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	struct PVRSRV_DC_SWAPCHAIN *psSwapChain;
+	struct DISPLAYCLASS_FLIP_COMMAND *psFlipCmd;
 	IMG_BOOL bStart = IMG_FALSE;
-	IMG_UINT32 uiStart = 0;
-	IMG_UINT32 ui32NumSrcSyncs = 1;
-	PVRSRV_KERNEL_SYNC_INFO *apsSrcSync[2];
-	PVRSRV_COMMAND *psCommand;
+	u32 uiStart = 0;
+	u32 ui32NumSrcSyncs = 1;
+	struct PVRSRV_KERNEL_SYNC_INFO *apsSrcSync[2];
+	struct PVRSRV_COMMAND *psCommand;
 
 	if (!hDeviceKM || !hSwapChain) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVSwapToDCSystemKM: Invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVSwapToDCSystemKM: Invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psDCInfo = DCDeviceHandleToDCInfo(hDeviceKM);
-	psSwapChain = (PVRSRV_DC_SWAPCHAIN *) hSwapChain;
+	psSwapChain = (struct PVRSRV_DC_SWAPCHAIN *)hSwapChain;
 
 	psQueue = psSwapChain->psQueue;
 
@@ -1150,48 +1097,36 @@
 		ui32NumSrcSyncs++;
 	}
 
-	eError = PVRSRVInsertCommandKM(psQueue,
-				       &psCommand,
-				       psDCInfo->ui32DeviceID,
-				       DC_FLIP_COMMAND,
-				       0,
-				       IMG_NULL,
-				       ui32NumSrcSyncs,
-				       apsSrcSync,
-				       sizeof(DISPLAYCLASS_FLIP_COMMAND));
+	eError = PVRSRVInsertCommandKM(psQueue, &psCommand,
+				      psDCInfo->ui32DeviceID, DC_FLIP_COMMAND,
+				      0, NULL, ui32NumSrcSyncs, apsSrcSync,
+				      sizeof(struct DISPLAYCLASS_FLIP_COMMAND));
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVSwapToDCSystemKM: Failed to get space in queue"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVSwapToDCSystemKM: "
+			"Failed to get space in queue");
 		goto Exit;
 	}
 
-	psFlipCmd = (DISPLAYCLASS_FLIP_COMMAND *) psCommand->pvData;
-
+	psFlipCmd = (struct DISPLAYCLASS_FLIP_COMMAND *)psCommand->pvData;
 	psFlipCmd->hExtDevice = psDCInfo->hExtDevice;
-
 	psFlipCmd->hExtSwapChain = psSwapChain->hExtSwapChain;
-
 	psFlipCmd->hExtBuffer =
 	    psDCInfo->sSystemBuffer.sDeviceClassBuffer.hExtBuffer;
-
-	psFlipCmd->hPrivateTag = IMG_NULL;
-
+	psFlipCmd->hPrivateTag = NULL;
 	psFlipCmd->ui32ClipRectCount = 0;
-
 	psFlipCmd->ui32SwapInterval = 1;
 
 	eError = PVRSRVSubmitCommandKM(psQueue, psCommand);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVSwapToDCSystemKM: Failed to submit command"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVSwapToDCSystemKM: Failed to submit command");
 		goto Exit;
 	}
 
 	do {
 		if (PVRSRVProcessQueues(KERNEL_ID, IMG_FALSE) !=
-		    PVRSRV_ERROR_PROCESSING_BLOCKED) {
+		    PVRSRV_ERROR_PROCESSING_BLOCKED)
 			goto ProcessedQueues;
-		}
 
 		if (bStart == IMG_FALSE) {
 			uiStart = OSClockus();
@@ -1200,8 +1135,8 @@
 		OSWaitus(MAX_HW_TIME_US / WAIT_TRY_COUNT);
 	} while ((OSClockus() - uiStart) < MAX_HW_TIME_US);
 
-	PVR_DPF((PVR_DBG_ERROR,
-		 "PVRSRVSwapToDCSystemKM: Failed to process queues"));
+	PVR_DPF(PVR_DBG_ERROR,
+		 "PVRSRVSwapToDCSystemKM: Failed to process queues");
 	eError = PVRSRV_ERROR_GENERIC;
 	goto Exit;
 
@@ -1215,70 +1150,69 @@
 	return eError;
 }
 
-PVRSRV_ERROR PVRSRVRegisterSystemISRHandler(PFN_ISR_HANDLER pfnISRHandler,
-					    IMG_VOID * pvISRHandlerData,
-					    IMG_UINT32 ui32ISRSourceMask,
-					    IMG_UINT32 ui32DeviceID)
+static enum PVRSRV_ERROR PVRSRVRegisterSystemISRHandler(
+					IMG_BOOL (*pfnISRHandler)(void *),
+					void *pvISRHandlerData,
+					u32 ui32ISRSourceMask,
+					u32 ui32DeviceID)
 {
-	SYS_DATA *psSysData;
-	PVRSRV_DEVICE_NODE *psDevNode;
+	struct SYS_DATA *psSysData;
+	struct PVRSRV_DEVICE_NODE *psDevNode;
 
 	PVR_UNREFERENCED_PARAMETER(ui32ISRSourceMask);
 
 	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRegisterSystemISRHandler: Failed to get SysData"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVRegisterSystemISRHandler: "
+			"Failed to get SysData");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
 	psDevNode = psSysData->psDeviceNodeList;
 	while (psDevNode) {
-		if (psDevNode->sDevId.ui32DeviceIndex == ui32DeviceID) {
+		if (psDevNode->sDevId.ui32DeviceIndex == ui32DeviceID)
 			break;
-		}
 		psDevNode = psDevNode->psNext;
 	}
 
-	psDevNode->pvISRData = (IMG_VOID *) pvISRHandlerData;
+	psDevNode->pvISRData = (void *) pvISRHandlerData;
 
 	psDevNode->pfnDeviceISR = pfnISRHandler;
 
 	return PVRSRV_OK;
 }
 
-IMG_VOID IMG_CALLCONV PVRSRVSetDCState(IMG_UINT32 ui32State)
+void PVRSRVSetDCState(u32 ui32State)
 {
-	PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	SYS_DATA *psSysData;
+	struct PVRSRV_DISPLAYCLASS_INFO *psDCInfo;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct SYS_DATA *psSysData;
 
 	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVSetDCState: Failed to get SysData"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVSetDCState: Failed to get SysData");
 		return;
 	}
 
 	psDeviceNode = psSysData->psDeviceNodeList;
-	while (psDeviceNode != IMG_NULL) {
+	while (psDeviceNode != NULL) {
 		if (psDeviceNode->sDevId.eDeviceClass ==
 		    PVRSRV_DEVICE_CLASS_DISPLAY) {
-			psDCInfo =
-			    (PVRSRV_DISPLAYCLASS_INFO *) psDeviceNode->pvDevice;
-			if (psDCInfo->psFuncTable->pfnSetDCState
-			    && psDCInfo->hExtDevice) {
-				psDCInfo->psFuncTable->pfnSetDCState(psDCInfo->
-								     hExtDevice,
-								     ui32State);
-			}
+			psDCInfo = (struct PVRSRV_DISPLAYCLASS_INFO *)
+							psDeviceNode->pvDevice;
+			if (psDCInfo->psFuncTable->pfnSetDCState &&
+			    psDCInfo->hExtDevice)
+				psDCInfo->psFuncTable->pfnSetDCState(
+							psDCInfo->hExtDevice,
+							ui32State);
 		}
 		psDeviceNode = psDeviceNode->psNext;
 	}
 }
 
-IMG_EXPORT
-    IMG_BOOL PVRGetDisplayClassJTable(PVRSRV_DC_DISP2SRV_KMJTABLE * psJTable)
+static IMG_BOOL PVRGetDisplayClassJTable(
+				struct PVRSRV_DC_DISP2SRV_KMJTABLE *psJTable)
 {
-	psJTable->ui32TableSize = sizeof(PVRSRV_DC_DISP2SRV_KMJTABLE);
+	psJTable->ui32TableSize = sizeof(struct PVRSRV_DC_DISP2SRV_KMJTABLE);
 	psJTable->pfnPVRSRVRegisterDCDevice = PVRSRVRegisterDCDeviceKM;
 	psJTable->pfnPVRSRVRemoveDCDevice = PVRSRVRemoveDCDeviceKM;
 	psJTable->pfnPVRSRVOEMFunction = SysOEMFunction;
@@ -1291,106 +1225,104 @@
 
 	return IMG_TRUE;
 }
+EXPORT_SYMBOL(PVRGetDisplayClassJTable);
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVCloseBCDeviceKM(IMG_HANDLE hDeviceKM,
+enum PVRSRV_ERROR PVRSRVCloseBCDeviceKM(void *hDeviceKM,
 				       IMG_BOOL bResManCallback)
 {
-	PVRSRV_ERROR eError;
-	PVRSRV_BUFFERCLASS_PERCONTEXT_INFO *psBCPerContextInfo;
+	struct PVRSRV_BUFFERCLASS_PERCONTEXT_INFO *psBCPerContextInfo;
 
 	PVR_UNREFERENCED_PARAMETER(bResManCallback);
 
-	psBCPerContextInfo = (PVRSRV_BUFFERCLASS_PERCONTEXT_INFO *) hDeviceKM;
+	psBCPerContextInfo = (struct PVRSRV_BUFFERCLASS_PERCONTEXT_INFO *)
+				hDeviceKM;
 
-	eError = ResManFreeResByPtr(psBCPerContextInfo->hResItem);
+	ResManFreeResByPtr(psBCPerContextInfo->hResItem);
 
-	return eError;
+	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR CloseBCDeviceCallBack(IMG_PVOID pvParam,
-					  IMG_UINT32 ui32Param)
+static enum PVRSRV_ERROR CloseBCDeviceCallBack(void *pvParam, u32 ui32Param)
 {
-	PVRSRV_BUFFERCLASS_PERCONTEXT_INFO *psBCPerContextInfo;
-	PVRSRV_BUFFERCLASS_INFO *psBCInfo;
+	struct PVRSRV_BUFFERCLASS_PERCONTEXT_INFO *psBCPerContextInfo;
+	struct PVRSRV_BUFFERCLASS_INFO *psBCInfo;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
-	psBCPerContextInfo = (PVRSRV_BUFFERCLASS_PERCONTEXT_INFO *) pvParam;
+	psBCPerContextInfo = (struct PVRSRV_BUFFERCLASS_PERCONTEXT_INFO *)
+				pvParam;
 	psBCInfo = psBCPerContextInfo->psBCInfo;
 
 	psBCInfo->ui32RefCount--;
 	if (psBCInfo->ui32RefCount == 0) {
-		IMG_UINT32 i;
+		u32 i;
 
 		psBCInfo->psFuncTable->pfnCloseBCDevice(psBCInfo->hExtDevice);
 
 		for (i = 0; i < psBCInfo->ui32BufferCount; i++) {
 			if (psBCInfo->psBuffer[i].sDeviceClassBuffer.
-			    psKernelSyncInfo) {
+			    psKernelSyncInfo)
 				PVRSRVFreeSyncInfoKM(psBCInfo->psBuffer[i].
 						     sDeviceClassBuffer.
 						     psKernelSyncInfo);
-			}
+
 		}
 
-		if (psBCInfo->psBuffer) {
+		if (psBCInfo->psBuffer)
 			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-				  sizeof(PVRSRV_BC_BUFFER) *
+				  sizeof(struct PVRSRV_BC_BUFFER) *
 				  psBCInfo->ui32BufferCount, psBCInfo->psBuffer,
-				  IMG_NULL);
-		}
+				  NULL);
 	}
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-		  sizeof(PVRSRV_BUFFERCLASS_PERCONTEXT_INFO),
-		  psBCPerContextInfo, IMG_NULL);
+		  sizeof(struct PVRSRV_BUFFERCLASS_PERCONTEXT_INFO),
+		  psBCPerContextInfo, NULL);
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVOpenBCDeviceKM(PVRSRV_PER_PROCESS_DATA * psPerProc,
-				      IMG_UINT32 ui32DeviceID,
-				      IMG_HANDLE hDevCookie,
-				      IMG_HANDLE * phDeviceKM)
-{
-	PVRSRV_BUFFERCLASS_INFO *psBCInfo;
-	PVRSRV_BUFFERCLASS_PERCONTEXT_INFO *psBCPerContextInfo;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	SYS_DATA *psSysData;
-	IMG_UINT32 i;
-	PVRSRV_ERROR eError;
-	BUFFER_INFO sBufferInfo;
+enum PVRSRV_ERROR PVRSRVOpenBCDeviceKM(
+				struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+				u32 ui32DeviceID, void *hDevCookie,
+				void **phDeviceKM)
+{
+	struct PVRSRV_BUFFERCLASS_INFO *psBCInfo;
+	struct PVRSRV_BUFFERCLASS_PERCONTEXT_INFO *psBCPerContextInfo;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct SYS_DATA *psSysData;
+	u32 i;
+	enum PVRSRV_ERROR eError;
+	struct BUFFER_INFO sBufferInfo;
 
 	if (!phDeviceKM) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVOpenBCDeviceKM: Invalid params"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVOpenBCDeviceKM: Invalid params");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
 	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVOpenBCDeviceKM: Failed to get SysData"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVOpenBCDeviceKM: Failed to get SysData");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
 	psDeviceNode = psSysData->psDeviceNodeList;
 	while (psDeviceNode) {
 		if ((psDeviceNode->sDevId.eDeviceClass ==
-		     PVRSRV_DEVICE_CLASS_BUFFER)
-		    && (psDeviceNode->sDevId.ui32DeviceIndex == ui32DeviceID)) {
+		     PVRSRV_DEVICE_CLASS_BUFFER) &&
+		      (psDeviceNode->sDevId.ui32DeviceIndex == ui32DeviceID)) {
 
-			psBCInfo =
-			    (PVRSRV_BUFFERCLASS_INFO *) psDeviceNode->pvDevice;
+			psBCInfo = (struct PVRSRV_BUFFERCLASS_INFO *)
+							psDeviceNode->pvDevice;
 			goto FoundDevice;
 		}
 		psDeviceNode = psDeviceNode->psNext;
 	}
 
-	PVR_DPF((PVR_DBG_ERROR,
+	PVR_DPF(PVR_DBG_ERROR,
 		 "PVRSRVOpenBCDeviceKM: No devnode matching index %d",
-		 ui32DeviceID));
+		 ui32DeviceID);
 
 	return PVRSRV_ERROR_GENERIC;
 
@@ -1398,27 +1330,27 @@
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 		       sizeof(*psBCPerContextInfo),
-		       (IMG_VOID **) & psBCPerContextInfo,
-		       IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVOpenBCDeviceKM: Failed psBCPerContextInfo alloc"));
+		       (void **) &psBCPerContextInfo,
+		       NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVOpenBCDeviceKM: "
+			"Failed psBCPerContextInfo alloc");
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 	OSMemSet(psBCPerContextInfo, 0, sizeof(*psBCPerContextInfo));
 
 	if (psBCInfo->ui32RefCount++ == 0) {
-		psDeviceNode = (PVRSRV_DEVICE_NODE *) hDevCookie;
-		PVR_ASSERT(psDeviceNode != IMG_NULL);
+		psDeviceNode = (struct PVRSRV_DEVICE_NODE *)hDevCookie;
+		PVR_ASSERT(psDeviceNode != NULL);
 
 		psBCInfo->hDevMemContext =
-		    (IMG_HANDLE) psDeviceNode->sDevMemoryInfo.pBMKernelContext;
+		    (void *) psDeviceNode->sDevMemoryInfo.pBMKernelContext;
 
 		eError =
 		    psBCInfo->psFuncTable->pfnOpenBCDevice(&psBCInfo->
 							   hExtDevice);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVOpenBCDeviceKM: Failed to open external BC device"));
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVOpenBCDeviceKM: "
+					"Failed to open external BC device");
 			return eError;
 		}
 
@@ -1426,61 +1358,59 @@
 		    psBCInfo->psFuncTable->pfnGetBCInfo(psBCInfo->hExtDevice,
 							&sBufferInfo);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVOpenBCDeviceKM : Failed to get BC Info"));
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVOpenBCDeviceKM : "
+				"Failed to get BC Info");
 			return eError;
 		}
 
 		psBCInfo->ui32BufferCount = sBufferInfo.ui32BufferCount;
 
 		eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-				    sizeof(PVRSRV_BC_BUFFER) *
+				    sizeof(struct PVRSRV_BC_BUFFER) *
 				    sBufferInfo.ui32BufferCount,
-				    (IMG_VOID **) & psBCInfo->psBuffer,
-				    IMG_NULL);
+				    (void **) &psBCInfo->psBuffer,
+				    NULL);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVOpenBCDeviceKM: Failed to allocate BC buffers"));
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVOpenBCDeviceKM: "
+				"Failed to allocate BC buffers");
 			return eError;
 		}
 		OSMemSet(psBCInfo->psBuffer,
 			 0,
-			 sizeof(PVRSRV_BC_BUFFER) *
+			 sizeof(struct PVRSRV_BC_BUFFER) *
 			 sBufferInfo.ui32BufferCount);
 
 		for (i = 0; i < psBCInfo->ui32BufferCount; i++) {
 
-			eError = PVRSRVAllocSyncInfoKM(IMG_NULL,
+			eError = PVRSRVAllocSyncInfoKM(NULL,
 						       psBCInfo->hDevMemContext,
 						       &psBCInfo->psBuffer[i].
 						       sDeviceClassBuffer.
 						       psKernelSyncInfo);
 			if (eError != PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "PVRSRVOpenBCDeviceKM: Failed sync info alloc"));
+				PVR_DPF(PVR_DBG_ERROR, "PVRSRVOpenBCDeviceKM: "
+						"Failed sync info alloc");
 				goto ErrorExit;
 			}
 
-			eError =
-			    psBCInfo->psFuncTable->pfnGetBCBuffer(psBCInfo->
-								  hExtDevice, i,
-								  psBCInfo->
-								  psBuffer[i].
-								  sDeviceClassBuffer.
-								  psKernelSyncInfo->
-								  psSyncData,
-								  &psBCInfo->
-								  psBuffer[i].
-								  sDeviceClassBuffer.
-								  hExtBuffer);
+			eError = psBCInfo->psFuncTable->pfnGetBCBuffer(
+				    psBCInfo->hExtDevice, i,
+				    psBCInfo->psBuffer[i].sDeviceClassBuffer.
+							  psKernelSyncInfo->
+								     psSyncData,
+				    &psBCInfo->psBuffer[i].sDeviceClassBuffer.
+							  hExtBuffer);
 			if (eError != PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "PVRSRVOpenBCDeviceKM: Failed to get BC buffers"));
+				PVR_DPF(PVR_DBG_ERROR, "PVRSRVOpenBCDeviceKM: "
+						"Failed to get BC buffers");
 				goto ErrorExit;
 			}
 
 			psBCInfo->psBuffer[i].sDeviceClassBuffer.
-			    pfnGetBufferAddr =
+			    pfnGetBufferAddr = (enum PVRSRV_ERROR(*)
+					(void *, void *,
+					 struct IMG_SYS_PHYADDR **, u32 *,
+					 void __iomem **, void **, IMG_BOOL *))
 			    psBCInfo->psFuncTable->pfnGetBufferAddr;
 			psBCInfo->psBuffer[i].sDeviceClassBuffer.
 			    hDevMemContext = psBCInfo->hDevMemContext;
@@ -1495,40 +1425,38 @@
 			      RESMAN_TYPE_BUFFERCLASS_DEVICE,
 			      psBCPerContextInfo, 0, CloseBCDeviceCallBack);
 
-	*phDeviceKM = (IMG_HANDLE) psBCPerContextInfo;
+	*phDeviceKM = (void *) psBCPerContextInfo;
 
 	return PVRSRV_OK;
 
 ErrorExit:
 
 	for (i = 0; i < psBCInfo->ui32BufferCount; i++) {
-		if (psBCInfo->psBuffer[i].sDeviceClassBuffer.psKernelSyncInfo) {
+		if (psBCInfo->psBuffer[i].sDeviceClassBuffer.psKernelSyncInfo)
 			PVRSRVFreeSyncInfoKM(psBCInfo->psBuffer[i].
 					     sDeviceClassBuffer.
 					     psKernelSyncInfo);
-		}
+
 	}
 
-	if (psBCInfo->psBuffer) {
+	if (psBCInfo->psBuffer)
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  sizeof(PVRSRV_BC_BUFFER) *
+			  sizeof(struct PVRSRV_BC_BUFFER) *
 			  sBufferInfo.ui32BufferCount, psBCInfo->psBuffer,
-			  IMG_NULL);
-	}
+			  NULL);
 
 	return eError;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVGetBCInfoKM(IMG_HANDLE hDeviceKM,
-				   BUFFER_INFO * psBufferInfo)
+enum PVRSRV_ERROR PVRSRVGetBCInfoKM(void *hDeviceKM,
+			       struct BUFFER_INFO *psBufferInfo)
 {
-	PVRSRV_BUFFERCLASS_INFO *psBCInfo;
-	PVRSRV_ERROR eError;
+	struct PVRSRV_BUFFERCLASS_INFO *psBCInfo;
+	enum PVRSRV_ERROR eError;
 
 	if (!hDeviceKM || !psBufferInfo) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVGetBCInfoKM: Invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVGetBCInfoKM: Invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
@@ -1539,48 +1467,47 @@
 						psBufferInfo);
 
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVGetBCInfoKM : Failed to get BC Info"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVGetBCInfoKM : Failed to get BC Info");
 		return eError;
 	}
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVGetBCBufferKM(IMG_HANDLE hDeviceKM,
-				     IMG_UINT32 ui32BufferIndex,
-				     IMG_HANDLE * phBuffer)
+enum PVRSRV_ERROR PVRSRVGetBCBufferKM(void *hDeviceKM, u32 ui32BufferIndex,
+				 void **phBuffer)
 {
-	PVRSRV_BUFFERCLASS_INFO *psBCInfo;
+	struct PVRSRV_BUFFERCLASS_INFO *psBCInfo;
 
 	if (!hDeviceKM || !phBuffer) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVGetBCBufferKM: Invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVGetBCBufferKM: Invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psBCInfo = BCDeviceHandleToBCInfo(hDeviceKM);
 
 	if (ui32BufferIndex < psBCInfo->ui32BufferCount) {
-		*phBuffer = (IMG_HANDLE) & psBCInfo->psBuffer[ui32BufferIndex];
+		*phBuffer = (void *) &psBCInfo->psBuffer[ui32BufferIndex];
 	} else {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVGetBCBufferKM: Buffer index %d out of range (%d)",
-			 ui32BufferIndex, psBCInfo->ui32BufferCount));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVGetBCBufferKM: "
+			"Buffer index %d out of range (%d)",
+			 ui32BufferIndex, psBCInfo->ui32BufferCount);
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    IMG_BOOL PVRGetBufferClassJTable(PVRSRV_BC_BUFFER2SRV_KMJTABLE * psJTable)
+IMG_BOOL PVRGetBufferClassJTable(struct PVRSRV_BC_BUFFER2SRV_KMJTABLE *psJTable)
 {
-	psJTable->ui32TableSize = sizeof(PVRSRV_BC_BUFFER2SRV_KMJTABLE);
+	psJTable->ui32TableSize = sizeof(struct PVRSRV_BC_BUFFER2SRV_KMJTABLE);
 
 	psJTable->pfnPVRSRVRegisterBCDevice = PVRSRVRegisterBCDeviceKM;
 	psJTable->pfnPVRSRVRemoveBCDevice = PVRSRVRemoveBCDeviceKM;
 
 	return IMG_TRUE;
 }
+EXPORT_SYMBOL(PVRGetBufferClassJTable);
+
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/devicemem.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/devicemem.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -36,25 +36,21 @@
 #include "linux/kernel.h"
 #include "linux/pagemap.h"
 
-static PVRSRV_ERROR AllocDeviceMem(IMG_HANDLE hDevCookie,
-				   IMG_HANDLE hDevMemHeap,
-				   IMG_UINT32 ui32Flags,
-				   IMG_UINT32 ui32Size,
-				   IMG_UINT32 ui32Alignment,
-				   PVRSRV_KERNEL_MEM_INFO ** ppsMemInfo);
-
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVGetDeviceMemHeapsKM(IMG_HANDLE hDevCookie,
-							PVRSRV_HEAP_INFO *
-							psHeapInfo)
-{
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	IMG_UINT32 ui32HeapCount;
-	DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
-	IMG_UINT32 i;
+static enum PVRSRV_ERROR AllocDeviceMem(void *hDevCookie, void *hDevMemHeap,
+				   u32 ui32Flags, u32 ui32Size,
+				   u32 ui32Alignment,
+				   struct PVRSRV_KERNEL_MEM_INFO **ppsMemInfo);
+
+enum PVRSRV_ERROR PVRSRVGetDeviceMemHeapsKM(void *hDevCookie,
+					struct PVRSRV_HEAP_INFO *psHeapInfo)
+{
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	u32 ui32HeapCount;
+	struct DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
+	u32 i;
 
-	psDeviceNode = (PVRSRV_DEVICE_NODE *) hDevCookie;
-	PVR_ASSERT(psDeviceNode != IMG_NULL);
+	psDeviceNode = (struct PVRSRV_DEVICE_NODE *)hDevCookie;
+	PVR_ASSERT(psDeviceNode != NULL);
 
 	ui32HeapCount = psDeviceNode->sDevMemoryInfo.ui32HeapCount;
 	psDeviceMemoryHeap = psDeviceNode->sDevMemoryInfo.psDeviceMemoryHeap;
@@ -74,39 +70,29 @@
 
 	for (; i < PVRSRV_MAX_CLIENT_HEAPS; i++) {
 		OSMemSet(psHeapInfo + i, 0, sizeof(*psHeapInfo));
-		psHeapInfo[i].ui32HeapID = (IMG_UINT32) SGX_UNDEFINED_HEAP_ID;
+		psHeapInfo[i].ui32HeapID = (u32) SGX_UNDEFINED_HEAP_ID;
 	}
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateDeviceMemContextKM(IMG_HANDLE
-							     hDevCookie,
-							     PVRSRV_PER_PROCESS_DATA
-							     * psPerProc,
-							     IMG_HANDLE *
-							     phDevMemContext,
-							     IMG_UINT32 *
-							     pui32ClientHeapCount,
-							     PVRSRV_HEAP_INFO *
-							     psHeapInfo,
-							     IMG_BOOL *
-							     pbCreated
-							     ,
-							     IMG_BOOL * pbShared
-    )
-{
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	IMG_UINT32 ui32HeapCount, ui32ClientHeapCount = 0;
-	DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
-	IMG_HANDLE hDevMemContext;
-	IMG_HANDLE hDevMemHeap;
-	IMG_DEV_PHYADDR sPDDevPAddr;
-	IMG_UINT32 i;
+enum PVRSRV_ERROR PVRSRVCreateDeviceMemContextKM(void *hDevCookie,
+			     struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+			     void **phDevMemContext,
+			     u32 *pui32ClientHeapCount,
+			     struct PVRSRV_HEAP_INFO *psHeapInfo,
+			     IMG_BOOL *pbCreated, IMG_BOOL *pbShared)
+{
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	u32 ui32HeapCount, ui32ClientHeapCount = 0;
+	struct DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
+	void *hDevMemContext;
+	void *hDevMemHeap;
+	struct IMG_DEV_PHYADDR sPDDevPAddr;
+	u32 i;
 
-	psDeviceNode = (PVRSRV_DEVICE_NODE *) hDevCookie;
-	PVR_ASSERT(psDeviceNode != IMG_NULL);
+	psDeviceNode = (struct PVRSRV_DEVICE_NODE *)hDevCookie;
+	PVR_ASSERT(psDeviceNode != NULL);
 
 	ui32HeapCount = psDeviceNode->sDevMemoryInfo.ui32HeapCount;
 	psDeviceMemoryHeap = psDeviceNode->sDevMemoryInfo.psDeviceMemoryHeap;
@@ -115,13 +101,13 @@
 
 	hDevMemContext = BM_CreateContext(psDeviceNode,
 					  &sPDDevPAddr, psPerProc, pbCreated);
-	if (hDevMemContext == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVCreateDeviceMemContextKM: Failed BM_CreateContext"));
+	if (hDevMemContext == NULL) {
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVCreateDeviceMemContextKM: "
+			  "Failed BM_CreateContext");
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
-	for (i = 0; i < ui32HeapCount; i++) {
+	for (i = 0; i < ui32HeapCount; i++)
 		switch (psDeviceMemoryHeap[i].DevMemHeapType) {
 		case DEVICE_MEMORY_HEAP_SHARED_EXPORTED:
 			{
@@ -164,7 +150,6 @@
 				break;
 			}
 		}
-	}
 
 	*pui32ClientHeapCount = ui32ClientHeapCount;
 	*phDevMemContext = hDevMemContext;
@@ -172,46 +157,42 @@
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroyDeviceMemContextKM(IMG_HANDLE
-							      hDevCookie,
-							      IMG_HANDLE
-							      hDevMemContext,
-							      IMG_BOOL *
-							      pbDestroyed)
+enum PVRSRV_ERROR PVRSRVDestroyDeviceMemContextKM(void *hDevCookie,
+					     void *hDevMemContext,
+					     IMG_BOOL *pbDestroyed)
 {
+	int destroyed;
+
 	PVR_UNREFERENCED_PARAMETER(hDevCookie);
 
-	return BM_DestroyContext(hDevMemContext, pbDestroyed);
+	destroyed = pvr_put_ctx(hDevMemContext);
+	if (pbDestroyed)
+		*pbDestroyed = destroyed ? IMG_TRUE : IMG_FALSE;
+
+	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVGetDeviceMemHeapInfoKM(IMG_HANDLE
-							   hDevCookie,
-							   IMG_HANDLE
-							   hDevMemContext,
-							   IMG_UINT32 *
-							   pui32ClientHeapCount,
-							   PVRSRV_HEAP_INFO *
-							   psHeapInfo
-							   , IMG_BOOL * pbShared
-    )
-{
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	IMG_UINT32 ui32HeapCount, ui32ClientHeapCount = 0;
-	DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
-	IMG_HANDLE hDevMemHeap;
-	IMG_UINT32 i;
+enum PVRSRV_ERROR PVRSRVGetDeviceMemHeapInfoKM(void *hDevCookie,
+					  void *hDevMemContext,
+					  u32 *pui32ClientHeapCount,
+					  struct PVRSRV_HEAP_INFO *psHeapInfo,
+					  IMG_BOOL *pbShared)
+{
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	u32 ui32HeapCount, ui32ClientHeapCount = 0;
+	struct DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
+	void *hDevMemHeap;
+	u32 i;
 
-	psDeviceNode = (PVRSRV_DEVICE_NODE *) hDevCookie;
-	PVR_ASSERT(psDeviceNode != IMG_NULL);
+	psDeviceNode = (struct PVRSRV_DEVICE_NODE *)hDevCookie;
+	PVR_ASSERT(psDeviceNode != NULL);
 
 	ui32HeapCount = psDeviceNode->sDevMemoryInfo.ui32HeapCount;
 	psDeviceMemoryHeap = psDeviceNode->sDevMemoryInfo.psDeviceMemoryHeap;
 
 	PVR_ASSERT(ui32HeapCount <= PVRSRV_MAX_CLIENT_HEAPS);
 
-	for (i = 0; i < ui32HeapCount; i++) {
+	for (i = 0; i < ui32HeapCount; i++)
 		switch (psDeviceMemoryHeap[i].DevMemHeapType) {
 		case DEVICE_MEMORY_HEAP_SHARED_EXPORTED:
 			{
@@ -254,131 +235,115 @@
 				break;
 			}
 		}
-	}
 
 	*pui32ClientHeapCount = ui32ClientHeapCount;
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR AllocDeviceMem(IMG_HANDLE hDevCookie,
-				   IMG_HANDLE hDevMemHeap,
-				   IMG_UINT32 ui32Flags,
-				   IMG_UINT32 ui32Size,
-				   IMG_UINT32 ui32Alignment,
-				   PVRSRV_KERNEL_MEM_INFO ** ppsMemInfo)
+static enum PVRSRV_ERROR AllocDeviceMem(void *hDevCookie, void *hDevMemHeap,
+				   u32 ui32Flags, u32 ui32Size,
+				   u32 ui32Alignment,
+				   struct PVRSRV_KERNEL_MEM_INFO **ppsMemInfo)
 {
-	PVRSRV_KERNEL_MEM_INFO *psMemInfo;
-	BM_HANDLE hBuffer;
+	struct PVRSRV_KERNEL_MEM_INFO *psMemInfo;
+	void *hBuffer;
 
-	PVRSRV_MEMBLK *psMemBlock;
+	struct PVRSRV_MEMBLK *psMemBlock;
 	IMG_BOOL bBMError;
 
 	PVR_UNREFERENCED_PARAMETER(hDevCookie);
 
-	*ppsMemInfo = IMG_NULL;
+	*ppsMemInfo = NULL;
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(PVRSRV_KERNEL_MEM_INFO),
-		       (IMG_VOID **) & psMemInfo, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "AllocDeviceMem: Failed to alloc memory for block"));
-		return (PVRSRV_ERROR_OUT_OF_MEMORY);
+		       sizeof(struct PVRSRV_KERNEL_MEM_INFO),
+		       (void **) &psMemInfo, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "AllocDeviceMem: Failed to alloc memory for block");
+		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
 	psMemBlock = &(psMemInfo->sMemBlk);
 
 	psMemInfo->ui32Flags = ui32Flags | PVRSRV_MEM_RAM_BACKED_ALLOCATION;
 
-	bBMError = BM_Alloc(hDevMemHeap,
-			    IMG_NULL,
-			    ui32Size,
+	bBMError = BM_Alloc(hDevMemHeap, NULL, ui32Size,
 			    &psMemInfo->ui32Flags, ui32Alignment, &hBuffer);
 
 	if (!bBMError) {
-		PVR_DPF((PVR_DBG_ERROR, "AllocDeviceMem: BM_Alloc Failed"));
+		PVR_DPF(PVR_DBG_ERROR, "AllocDeviceMem: BM_Alloc Failed");
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  sizeof(PVRSRV_KERNEL_MEM_INFO), psMemInfo, IMG_NULL);
+			  sizeof(struct PVRSRV_KERNEL_MEM_INFO), psMemInfo,
+			  NULL);
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
 	psMemBlock->sDevVirtAddr = BM_HandleToDevVaddr(hBuffer);
 	psMemBlock->hOSMemHandle = BM_HandleToOSMemHandle(hBuffer);
 
-	psMemBlock->hBuffer = (IMG_HANDLE) hBuffer;
-
+	psMemBlock->hBuffer = (void *) hBuffer;
 	psMemInfo->pvLinAddrKM = BM_HandleToCpuVaddr(hBuffer);
-
 	psMemInfo->sDevVAddr = psMemBlock->sDevVirtAddr;
-
 	psMemInfo->ui32AllocSize = ui32Size;
-
 	*ppsMemInfo = psMemInfo;
 
-	return (PVRSRV_OK);
+	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR FreeDeviceMem(PVRSRV_KERNEL_MEM_INFO * psMemInfo)
+static enum PVRSRV_ERROR FreeDeviceMem(struct PVRSRV_KERNEL_MEM_INFO *psMemInfo)
 {
-	BM_HANDLE hBuffer;
+	void *hBuffer;
 
-	if (!psMemInfo) {
+	if (!psMemInfo)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
 	hBuffer = psMemInfo->sMemBlk.hBuffer;
-
 	BM_Free(hBuffer, psMemInfo->ui32Flags);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+		  sizeof(struct PVRSRV_KERNEL_MEM_INFO),
+		  psMemInfo, NULL);
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_KERNEL_MEM_INFO),
-		  psMemInfo, IMG_NULL);
-
-	return (PVRSRV_OK);
+	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocSyncInfoKM(IMG_HANDLE hDevCookie,
-						    IMG_HANDLE hDevMemContext,
-						    PVRSRV_KERNEL_SYNC_INFO **
-						    ppsKernelSyncInfo)
-{
-	IMG_HANDLE hSyncDevMemHeap;
-	DEVICE_MEMORY_INFO *psDevMemoryInfo;
-	BM_CONTEXT *pBMContext;
-	PVRSRV_ERROR eError;
-	PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
-	PVRSRV_SYNC_DATA *psSyncData;
+enum PVRSRV_ERROR PVRSRVAllocSyncInfoKM(void *hDevCookie, void *hDevMemContext,
+		    struct PVRSRV_KERNEL_SYNC_INFO **ppsKernelSyncInfo)
+{
+	void *hSyncDevMemHeap;
+	struct DEVICE_MEMORY_INFO *psDevMemoryInfo;
+	struct BM_CONTEXT *pBMContext;
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
+	struct PVRSRV_SYNC_DATA *psSyncData;
 
 	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-			    sizeof(PVRSRV_KERNEL_SYNC_INFO),
-			    (IMG_VOID **) & psKernelSyncInfo, IMG_NULL);
+			    sizeof(struct PVRSRV_KERNEL_SYNC_INFO),
+			    (void **) &psKernelSyncInfo, NULL);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVAllocSyncInfoKM: Failed to alloc memory"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVAllocSyncInfoKM: Failed to alloc memory");
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
-	pBMContext = (BM_CONTEXT *) hDevMemContext;
+	pBMContext = (struct BM_CONTEXT *)hDevMemContext;
 	psDevMemoryInfo = &pBMContext->psDeviceNode->sDevMemoryInfo;
 
-	hSyncDevMemHeap =
-	    psDevMemoryInfo->psDeviceMemoryHeap[psDevMemoryInfo->
+	hSyncDevMemHeap = psDevMemoryInfo->psDeviceMemoryHeap[psDevMemoryInfo->
 						ui32SyncHeapID].hDevMemHeap;
 
-	eError = AllocDeviceMem(hDevCookie,
-				hSyncDevMemHeap,
-				0,
-				sizeof(PVRSRV_SYNC_DATA),
-				sizeof(IMG_UINT32),
+	eError = AllocDeviceMem(hDevCookie, hSyncDevMemHeap, 0,
+				sizeof(struct PVRSRV_SYNC_DATA),
+				sizeof(u32),
 				&psKernelSyncInfo->psSyncDataMemInfoKM);
 
 	if (eError != PVRSRV_OK) {
 
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVAllocSyncInfoKM: Failed to alloc memory"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVAllocSyncInfoKM: Failed to alloc memory");
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  sizeof(PVRSRV_KERNEL_SYNC_INFO), psKernelSyncInfo,
-			  IMG_NULL);
+			  sizeof(struct PVRSRV_KERNEL_SYNC_INFO),
+			  psKernelSyncInfo, NULL);
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
@@ -395,131 +360,111 @@
 
 	psKernelSyncInfo->sWriteOpsCompleteDevVAddr.uiAddr =
 	    psKernelSyncInfo->psSyncDataMemInfoKM->sDevVAddr.uiAddr +
-	    offsetof(PVRSRV_SYNC_DATA, ui32WriteOpsComplete);
+	    offsetof(struct PVRSRV_SYNC_DATA, ui32WriteOpsComplete);
 	psKernelSyncInfo->sReadOpsCompleteDevVAddr.uiAddr =
 	    psKernelSyncInfo->psSyncDataMemInfoKM->sDevVAddr.uiAddr +
-	    offsetof(PVRSRV_SYNC_DATA, ui32ReadOpsComplete);
+	    offsetof(struct PVRSRV_SYNC_DATA, ui32ReadOpsComplete);
 
-	psKernelSyncInfo->psSyncDataMemInfoKM->psKernelSyncInfo = IMG_NULL;
+	psKernelSyncInfo->psSyncDataMemInfoKM->psKernelSyncInfo = NULL;
 
 	*ppsKernelSyncInfo = psKernelSyncInfo;
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVFreeSyncInfoKM(PVRSRV_KERNEL_SYNC_INFO *
-						   psKernelSyncInfo)
+enum PVRSRV_ERROR PVRSRVFreeSyncInfoKM(
+			struct PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo)
 {
 	FreeDeviceMem(psKernelSyncInfo->psSyncDataMemInfoKM);
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_KERNEL_SYNC_INFO),
-		  psKernelSyncInfo, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+		sizeof(struct PVRSRV_KERNEL_SYNC_INFO), psKernelSyncInfo, NULL);
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR FreeDeviceMemCallBack(IMG_PVOID pvParam,
-					  IMG_UINT32 ui32Param)
+static enum PVRSRV_ERROR FreeDeviceMemCallBack(void *pvParam, u32 ui32Param)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	PVRSRV_KERNEL_MEM_INFO *psMemInfo = pvParam;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
+	struct PVRSRV_KERNEL_MEM_INFO *psMemInfo = pvParam;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
-	if (psMemInfo->psKernelSyncInfo) {
+	if (psMemInfo->psKernelSyncInfo)
 		eError = PVRSRVFreeSyncInfoKM(psMemInfo->psKernelSyncInfo);
-	}
 
-	if (eError == PVRSRV_OK) {
+	if (eError == PVRSRV_OK)
 		eError = FreeDeviceMem(psMemInfo);
-	}
 
 	return eError;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVFreeDeviceMemKM(IMG_HANDLE hDevCookie,
-						    PVRSRV_KERNEL_MEM_INFO *
-						    psMemInfo)
+enum PVRSRV_ERROR PVRSRVFreeDeviceMemKM(void *hDevCookie,
+				   struct PVRSRV_KERNEL_MEM_INFO *psMemInfo)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
-
 	PVR_UNREFERENCED_PARAMETER(hDevCookie);
 
-	if (!psMemInfo) {
+	if (!psMemInfo)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
-
-	if (psMemInfo->sMemBlk.hResItem != IMG_NULL) {
-		eError = ResManFreeResByPtr(psMemInfo->sMemBlk.hResItem);
-	} else {
 
+	if (psMemInfo->sMemBlk.hResItem != NULL)
+		ResManFreeResByPtr(psMemInfo->sMemBlk.hResItem);
+	else
 		FreeDeviceMemCallBack(psMemInfo, 0);
-	}
 
-	return eError;
+	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocDeviceMemKM(IMG_HANDLE hDevCookie,
-						     PVRSRV_PER_PROCESS_DATA *
-						     psPerProc,
-						     IMG_HANDLE hDevMemHeap,
-						     IMG_UINT32 ui32Flags,
-						     IMG_UINT32 ui32Size,
-						     IMG_UINT32 ui32Alignment,
-						     PVRSRV_KERNEL_MEM_INFO **
-						     ppsMemInfo)
-{
-	PVRSRV_KERNEL_MEM_INFO *psMemInfo;
-	PVRSRV_ERROR eError;
-	BM_HEAP *psBMHeap;
-	IMG_HANDLE hDevMemContext;
+enum PVRSRV_ERROR PVRSRVAllocDeviceMemKM(void *hDevCookie,
+				     struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+				     void *hDevMemHeap, u32 ui32Flags,
+				     u32 ui32Size, u32 ui32Alignment,
+				     struct PVRSRV_KERNEL_MEM_INFO **ppsMemInfo)
+{
+	struct PVRSRV_KERNEL_MEM_INFO *psMemInfo;
+	enum PVRSRV_ERROR eError;
+	struct BM_HEAP *psBMHeap;
+	void *hDevMemContext;
 
-	if (!hDevMemHeap || (ui32Size == 0)) {
+	if (!hDevMemHeap || (ui32Size == 0))
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
-	eError = AllocDeviceMem(hDevCookie,
-				hDevMemHeap,
-				ui32Flags, ui32Size, ui32Alignment, &psMemInfo);
+	eError = AllocDeviceMem(hDevCookie, hDevMemHeap, ui32Flags, ui32Size,
+				ui32Alignment, &psMemInfo);
 
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	if (ui32Flags & PVRSRV_MEM_NO_SYNCOBJ) {
-		psMemInfo->psKernelSyncInfo = IMG_NULL;
+		psMemInfo->psKernelSyncInfo = NULL;
 	} else {
 
-		psBMHeap = (BM_HEAP *) hDevMemHeap;
-		hDevMemContext = (IMG_HANDLE) psBMHeap->pBMContext;
+		psBMHeap = (struct BM_HEAP *)hDevMemHeap;
+		hDevMemContext = (void *) psBMHeap->pBMContext;
 		eError = PVRSRVAllocSyncInfoKM(hDevCookie,
 					       hDevMemContext,
 					       &psMemInfo->psKernelSyncInfo);
-		if (eError != PVRSRV_OK) {
+		if (eError != PVRSRV_OK)
 			goto free_mainalloc;
-		}
 	}
 
 	*ppsMemInfo = psMemInfo;
 
 	if (ui32Flags & PVRSRV_MEM_NO_RESMAN) {
-		psMemInfo->sMemBlk.hResItem = IMG_NULL;
+		psMemInfo->sMemBlk.hResItem = NULL;
 	} else {
 
 		psMemInfo->sMemBlk.hResItem =
 		    ResManRegisterRes(psPerProc->hResManContext,
 				      RESMAN_TYPE_DEVICEMEM_ALLOCATION,
 				      psMemInfo, 0, FreeDeviceMemCallBack);
-		if (psMemInfo->sMemBlk.hResItem == IMG_NULL) {
+		if (psMemInfo->sMemBlk.hResItem == NULL) {
 
 			eError = PVRSRV_ERROR_OUT_OF_MEMORY;
 			goto free_mainalloc;
 		}
 	}
 
-	return (PVRSRV_OK);
+	return PVRSRV_OK;
 
 free_mainalloc:
 	FreeDeviceMem(psMemInfo);
@@ -527,19 +472,16 @@
 	return eError;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVDissociateDeviceMemKM(IMG_HANDLE hDevCookie,
-							  PVRSRV_KERNEL_MEM_INFO
-							  * psMemInfo)
+enum PVRSRV_ERROR PVRSRVDissociateDeviceMemKM(void *hDevCookie,
+				  struct PVRSRV_KERNEL_MEM_INFO *psMemInfo)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	PVRSRV_DEVICE_NODE *psDeviceNode = hDevCookie;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode = hDevCookie;
 
 	PVR_UNREFERENCED_PARAMETER(hDevCookie);
 
-	if (!psMemInfo) {
+	if (!psMemInfo)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
 	ResManDissociateRes(psMemInfo->sMemBlk.hResItem,
 			    psDeviceNode->hResManContext);
@@ -547,12 +489,8 @@
 	return eError;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVGetFreeDeviceMemKM(IMG_UINT32 ui32Flags,
-						       IMG_UINT32 * pui32Total,
-						       IMG_UINT32 * pui32Free,
-						       IMG_UINT32 *
-						       pui32LargestBlock)
+enum PVRSRV_ERROR PVRSRVGetFreeDeviceMemKM(u32 ui32Flags, u32 *pui32Total,
+				      u32 *pui32Free, u32 *pui32LargestBlock)
 {
 
 	PVR_UNREFERENCED_PARAMETER(ui32Flags);
@@ -563,163 +501,75 @@
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVUnwrapExtMemoryKM(PVRSRV_KERNEL_MEM_INFO *
-						      psMemInfo)
+enum PVRSRV_ERROR PVRSRVUnwrapExtMemoryKM(
+		struct PVRSRV_KERNEL_MEM_INFO *psMemInfo)
 {
-	if (!psMemInfo) {
+	if (!psMemInfo)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
-	return ResManFreeResByPtr(psMemInfo->sMemBlk.hResItem);
+	ResManFreeResByPtr(psMemInfo->sMemBlk.hResItem);
+	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR UnwrapExtMemoryCallBack(IMG_PVOID pvParam,
-					    IMG_UINT32 ui32Param)
+static enum PVRSRV_ERROR UnwrapExtMemoryCallBack(void *pvParam, u32 ui32Param)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	PVRSRV_KERNEL_MEM_INFO *psMemInfo = pvParam;
-	IMG_HANDLE hOSWrapMem = IMG_NULL;
-	BM_BUF *psBMBuf;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
+	struct PVRSRV_KERNEL_MEM_INFO *psMemInfo = pvParam;
+	void *hOSWrapMem = NULL;
+	struct BM_BUF *psBMBuf;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
-	psBMBuf = (BM_BUF *) psMemInfo->sMemBlk.hBuffer;
+	psBMBuf = (struct BM_BUF *)psMemInfo->sMemBlk.hBuffer;
 
 	if ((psBMBuf->ui32RefCount == 1) && (psMemInfo->psKernelSyncInfo)) {
 		eError = PVRSRVFreeSyncInfoKM(psMemInfo->psKernelSyncInfo);
 		hOSWrapMem = psBMBuf->hOSWrapMem;
 	}
 
-	if (eError == PVRSRV_OK) {
+	if (eError == PVRSRV_OK)
 		eError = FreeDeviceMem(psMemInfo);
-	}
 
-	if (hOSWrapMem) {
+	if (hOSWrapMem)
 		OSReleasePhysPageAddr(hOSWrapMem, IMG_TRUE);
-	}
-
-	return eError;
-}
-
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVIsWrappedExtMemoryKM(IMG_HANDLE hDevCookie,
-							   PVRSRV_PER_PROCESS_DATA
-							   *psPerProc,
-							   IMG_UINT32
-							   *pui32ByteSize,
-							   IMG_VOID
-							   **pvLinAddr)
-{
-	DEVICE_MEMORY_INFO *psDevMemoryInfo;
-	IMG_UINT32 ui32HostPageSize = HOST_PAGESIZE();
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	PVRSRV_ERROR eError;
-	IMG_SYS_PHYADDR sIntSysPAddr;
-	IMG_HANDLE hOSWrapMem = IMG_NULL;
-	IMG_HANDLE hDevMemHeap;
-	IMG_UINT32 ui32PageOffset = 0;
-
-	IMG_UINT32 ui32ReturnedByteSize = *pui32ByteSize;
-
-	eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-
-	psDeviceNode = (PVRSRV_DEVICE_NODE *)hDevCookie;
-	PVR_ASSERT(psDeviceNode != IMG_NULL);
-	psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
-
-	hDevMemHeap = psDevMemoryInfo->psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].hDevMemHeap;
-
-	if (pvLinAddr) {
-		ui32PageOffset = ((IMG_UINT32)*pvLinAddr) & ~PAGE_MASK;
-		*pvLinAddr = (IMG_VOID *)((IMG_UINT32)*pvLinAddr & PAGE_MASK);
-		ui32ReturnedByteSize += ui32PageOffset;
-
-		/* let's start by getting the address of the first page */
-		eError = OSAcquirePhysPageAddr(*pvLinAddr,
-										ui32HostPageSize,
-										&sIntSysPAddr,
-										&hOSWrapMem,
-										IMG_FALSE);
-		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR, "PVRSRVIsWrappedExtMemoryKM: Failed to alloc memory for block"));
-			eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-			goto ErrorExitPhase1;
-		}
-
-		OSReleasePhysPageAddr(hOSWrapMem, IMG_FALSE);
-		hOSWrapMem = IMG_NULL;
-
-		/* now check if this memory address is already wrapped */
-		if (BM_IsWrappedCheckSize(hDevMemHeap,
-							ui32PageOffset,
-							sIntSysPAddr,
-							*pui32ByteSize)) {
-			/* already wrapped */
-			eError = PVRSRV_OK;
-		} else {
-			/* not mapped in this heap */
-			/* try the alternative heap */
-			hDevMemHeap = psDevMemoryInfo->psDeviceMemoryHeap[SGX_ALT_MAPPING_HEAP_ID].hDevMemHeap;
-
-			if (BM_IsWrappedCheckSize(hDevMemHeap,
-								ui32PageOffset,
-								sIntSysPAddr,
-								*pui32ByteSize)) {
-				/* already wrapped */
-				eError = PVRSRV_OK;
-			} else {
-				eError = PVRSRV_ERROR_BAD_MAPPING;
-			}
-		}
-	}
-
-ErrorExitPhase1:
-
-	*pui32ByteSize = ui32ReturnedByteSize;
 
 	return eError;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtMemoryKM(IMG_HANDLE hDevCookie,
-						    PVRSRV_PER_PROCESS_DATA *
-						    psPerProc,
-						    IMG_UINT32 ui32ByteSize,
-						    IMG_UINT32 ui32PageOffset,
-						    IMG_BOOL bPhysContig,
-						    IMG_SYS_PHYADDR *
-						    psExtSysPAddr,
-						    IMG_VOID * pvLinAddr,
-						    PVRSRV_KERNEL_MEM_INFO **
-						    ppsMemInfo)
-{
-	PVRSRV_KERNEL_MEM_INFO *psMemInfo = IMG_NULL;
-	DEVICE_MEMORY_INFO *psDevMemoryInfo;
-	IMG_UINT32 ui32HostPageSize = HOST_PAGESIZE();
-	IMG_HANDLE hDevMemHeap, hDevMemContext;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	BM_HANDLE hBuffer;
-	PVRSRV_MEMBLK *psMemBlock;
+enum PVRSRV_ERROR PVRSRVWrapExtMemoryKM(void *hDevCookie,
+				   struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+				   u32 ui32ByteSize, u32 ui32PageOffset,
+				   IMG_BOOL bPhysContig,
+				   struct IMG_SYS_PHYADDR *psExtSysPAddr,
+				   void *pvLinAddr,
+				   struct PVRSRV_KERNEL_MEM_INFO **ppsMemInfo)
+{
+	struct PVRSRV_KERNEL_MEM_INFO *psMemInfo = NULL;
+	struct DEVICE_MEMORY_INFO *psDevMemoryInfo;
+	u32 ui32HostPageSize = HOST_PAGESIZE();
+	void *hDevMemHeap, *hDevMemContext;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	void *hBuffer;
+	struct PVRSRV_MEMBLK *psMemBlock;
 	IMG_BOOL bBMError;
-	BM_HEAP *psBMHeap;
-	PVRSRV_ERROR eError;
-	IMG_VOID *pvPageAlignedCPUVAddr;
-	IMG_SYS_PHYADDR *psIntSysPAddr = IMG_NULL;
-	IMG_HANDLE hOSWrapMem = IMG_NULL;
-	BM_BUF *psBMBuf;
-	IMG_SYS_PHYADDR *pPageList = psExtSysPAddr;
-	IMG_UINT32 ui32PageCount;
+	struct BM_HEAP *psBMHeap;
+	enum PVRSRV_ERROR eError;
+	void *pvPageAlignedCPUVAddr;
+	struct IMG_SYS_PHYADDR *psIntSysPAddr = NULL;
+	void *hOSWrapMem = NULL;
+	struct BM_BUF *psBMBuf;
+	struct IMG_SYS_PHYADDR *pPageList = psExtSysPAddr;
+	u32 ui32PageCount;
 
-	IMG_UINT32 ui32CalculatedPageOffset = ((IMG_UINT32)pvLinAddr) & ~PAGE_MASK;
+	u32 ui32CalculatedPageOffset = ((u32)pvLinAddr) & ~PAGE_MASK;
 	if (ui32CalculatedPageOffset != ui32PageOffset)	{
-		PVR_DPF((PVR_DBG_ERROR,
-			"PVRSRVWrapExtMemoryKM: offset from address not match offset param"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVWrapExtMemoryKM: "
+			"offset from address not match offset param");
 		return PVRSRV_ERROR_BAD_MAPPING;
 	}
 
-	psDeviceNode = (PVRSRV_DEVICE_NODE *) hDevCookie;
-	PVR_ASSERT(psDeviceNode != IMG_NULL);
+	psDeviceNode = (struct PVRSRV_DEVICE_NODE *)hDevCookie;
+	PVR_ASSERT(psDeviceNode != NULL);
 	psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
 	hDevMemHeap =
 	    psDevMemoryInfo->psDeviceMemoryHeap[psDevMemoryInfo->
@@ -730,35 +580,37 @@
 
 	if (pvLinAddr) {
 		pvPageAlignedCPUVAddr =
-		    (IMG_VOID *) ((IMG_UINT8 *) pvLinAddr - ui32PageOffset);
+		    (void *) ((u8 *) pvLinAddr - ui32PageOffset);
 
 		if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-			       ui32PageCount * sizeof(IMG_SYS_PHYADDR),
-			       (IMG_VOID **) & psIntSysPAddr,
-			       IMG_NULL) != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVWrapExtMemoryKM: Failed to alloc memory for block"));
+			       ui32PageCount * sizeof(struct IMG_SYS_PHYADDR),
+			       (void **) &psIntSysPAddr,
+			       NULL) != PVRSRV_OK) {
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVWrapExtMemoryKM: "
+					"Failed to alloc memory for block");
 			return PVRSRV_ERROR_OUT_OF_MEMORY;
 		}
 
 		/* let's start by getting the address of the first page */
 		eError = OSAcquirePhysPageAddr(pvPageAlignedCPUVAddr,
 					       ui32HostPageSize,
-					       psIntSysPAddr, &hOSWrapMem, IMG_TRUE);
+					       psIntSysPAddr, &hOSWrapMem,
+					       IMG_TRUE);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVWrapExtMemoryKM: Failed to alloc memory for block"));
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVWrapExtMemoryKM: "
+					"Failed to alloc memory for block");
 			eError = PVRSRV_ERROR_OUT_OF_MEMORY;
 			goto ErrorExitPhase1;
 		}
 		/* now check if this memory address is already wrapped */
-		if (BM_IsWrapped(hDevMemHeap, ui32PageOffset, psIntSysPAddr[0])) {
+		if (BM_IsWrapped(hDevMemHeap, ui32PageOffset,
+				 psIntSysPAddr[0])) {
 			/* already wrapped */
 			OSReleasePhysPageAddr(hOSWrapMem, IMG_TRUE);
-			hOSWrapMem = IMG_NULL;
+			hOSWrapMem = NULL;
 		} else if (ui32PageCount > 1) {
 			OSReleasePhysPageAddr(hOSWrapMem, IMG_TRUE);
-			hOSWrapMem = IMG_NULL;
+			hOSWrapMem = NULL;
 			/* the memory is going to wrapped for the first time,
 			 * so we need full page list */
 			eError = OSAcquirePhysPageAddr(pvPageAlignedCPUVAddr,
@@ -768,8 +620,8 @@
 						       &hOSWrapMem,
 						       IMG_TRUE);
 			if (eError != PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "PVRSRVWrapExtMemoryKM: Failed to alloc memory for block"));
+				PVR_DPF(PVR_DBG_ERROR, "PVRSRVWrapExtMemoryKM:"
+					  " Failed to alloc memory for block");
 				eError = PVRSRV_ERROR_OUT_OF_MEMORY;
 				goto ErrorExitPhase1;
 			}
@@ -781,24 +633,19 @@
 	}
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(PVRSRV_KERNEL_MEM_INFO),
-		       (IMG_VOID **) & psMemInfo, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVWrapExtMemoryKM: Failed to alloc memory for block"));
+		       sizeof(struct PVRSRV_KERNEL_MEM_INFO),
+		       (void **) &psMemInfo, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVWrapExtMemoryKM: "
+					"Failed to alloc memory for block");
 		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
 		goto ErrorExitPhase2;
 	}
 
 	OSMemSet(psMemInfo, 0, sizeof(*psMemInfo));
-
 	psMemBlock = &(psMemInfo->sMemBlk);
-
-	bBMError = BM_Wrap(hDevMemHeap,
-			   ui32ByteSize,
-			   ui32PageOffset,
-			   bPhysContig,
-			   psExtSysPAddr,
-			   IMG_TRUE, IMG_NULL, &psMemInfo->ui32Flags, &hBuffer);
+	bBMError = BM_Wrap(hDevMemHeap, ui32ByteSize, ui32PageOffset,
+			   bPhysContig, psExtSysPAddr,
+			   IMG_TRUE, NULL, &psMemInfo->ui32Flags, &hBuffer);
 	if (!bBMError) {
 		/* Alloc failed from current mapping heap, try the other one */
 		psDevMemoryInfo->ui32MappingHeapID =
@@ -807,42 +654,39 @@
 		    SGX_GENERAL_MAPPING_HEAP_ID;
 		hDevMemHeap =
 		    psDevMemoryInfo->psDeviceMemoryHeap[psDevMemoryInfo->
-							ui32MappingHeapID].
-		    hDevMemHeap;
+						ui32MappingHeapID]. hDevMemHeap;
 		bBMError =
 		    BM_Wrap(hDevMemHeap, ui32ByteSize, ui32PageOffset,
-			    bPhysContig, psExtSysPAddr, IMG_TRUE, IMG_NULL,
+			    bPhysContig, psExtSysPAddr, IMG_TRUE, NULL,
 			    &psMemInfo->ui32Flags, &hBuffer);
 		if (!bBMError) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVWrapExtMemoryKM: BM_Wrap Failed"));
+			PVR_DPF(PVR_DBG_ERROR,
+				 "PVRSRVWrapExtMemoryKM: BM_Wrap Failed");
 			eError = PVRSRV_ERROR_BAD_MAPPING;
 			goto ErrorExitPhase2;
 		}
 	}
 	/* wrap was successful and BM_Wrap has taken ownership of the page list,
 	 * clear psIntSysPAddr here, so we don't double free the memory */
-	psIntSysPAddr = IMG_NULL;
+	psIntSysPAddr = NULL;
 
 	psMemBlock->sDevVirtAddr = BM_HandleToDevVaddr(hBuffer);
 	psMemBlock->hOSMemHandle = BM_HandleToOSMemHandle(hBuffer);
 
-	psMemBlock->hBuffer = (IMG_HANDLE) hBuffer;
+	psMemBlock->hBuffer = (void *) hBuffer;
 
 	psMemInfo->pvLinAddrKM = BM_HandleToCpuVaddr(hBuffer);
 	psMemInfo->sDevVAddr = psMemBlock->sDevVirtAddr;
 	psMemInfo->ui32AllocSize = ui32ByteSize;
 
-	psBMHeap = (BM_HEAP *) hDevMemHeap;
-	hDevMemContext = (IMG_HANDLE) psBMHeap->pBMContext;
-	psBMBuf = (BM_BUF *) hBuffer;
+	psBMHeap = (struct BM_HEAP *)hDevMemHeap;
+	hDevMemContext = (void *) psBMHeap->pBMContext;
+	psBMBuf = (struct BM_BUF *)hBuffer;
 	if (psBMBuf->ui32RefCount == 1) {
-		eError = PVRSRVAllocSyncInfoKM(hDevCookie,
-					       hDevMemContext,
+		eError = PVRSRVAllocSyncInfoKM(hDevCookie, hDevMemContext,
 					       &psMemInfo->psKernelSyncInfo);
-		if (eError != PVRSRV_OK) {
+		if (eError != PVRSRV_OK)
 			goto ErrorExitPhase2;
-		}
 		psBMBuf->pvKernelSyncInfo = psMemInfo->psKernelSyncInfo;
 		psBMBuf->hOSWrapMem = hOSWrapMem;
 	} else {
@@ -855,85 +699,77 @@
 			      UnwrapExtMemoryCallBack);
 	/* check if we were passed a page list
 	 * but we didn't use use it */
-	if (pPageList && (pPageList != psExtSysPAddr)) {
+	if (pPageList && (pPageList != psExtSysPAddr))
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  ui32PageCount * sizeof(IMG_SYS_PHYADDR),
-			  (IMG_VOID *) pPageList, 0);
-	}
+			  ui32PageCount * sizeof(struct IMG_SYS_PHYADDR),
+			  (void *)pPageList, NULL);
 
 	*ppsMemInfo = psMemInfo;
 
 	return PVRSRV_OK;
 
 ErrorExitPhase2:
-	if (psMemInfo) {
+	if (psMemInfo)
 		FreeDeviceMem(psMemInfo);
-	}
 
 	if (hOSWrapMem)
 		OSReleasePhysPageAddr(hOSWrapMem, IMG_TRUE);
 ErrorExitPhase1:
-	if (psIntSysPAddr) {
+	if (psIntSysPAddr)
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  ui32PageCount * sizeof(IMG_SYS_PHYADDR),
-			  psIntSysPAddr, IMG_NULL);
-	}
+			  ui32PageCount * sizeof(struct IMG_SYS_PHYADDR),
+			  psIntSysPAddr, NULL);
 
 	return eError;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVUnmapDeviceMemoryKM(PVRSRV_KERNEL_MEM_INFO *
-							psMemInfo)
+enum PVRSRV_ERROR PVRSRVUnmapDeviceMemoryKM(
+		struct PVRSRV_KERNEL_MEM_INFO *psMemInfo)
 {
-	if (!psMemInfo) {
+	if (!psMemInfo)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
-	return ResManFreeResByPtr(psMemInfo->sMemBlk.hResItem);
+	ResManFreeResByPtr(psMemInfo->sMemBlk.hResItem);
+	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR UnmapDeviceMemoryCallBack(IMG_PVOID pvParam,
-					      IMG_UINT32 ui32Param)
+static enum PVRSRV_ERROR UnmapDeviceMemoryCallBack(void *pvParam, u32 ui32Param)
 {
-	PVRSRV_KERNEL_MEM_INFO *psMemInfo = pvParam;
+	struct PVRSRV_KERNEL_MEM_INFO *psMemInfo = pvParam;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
 	return FreeDeviceMem(psMemInfo);
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceMemoryKM(PVRSRV_PER_PROCESS_DATA *
-						      psPerProc,
-						      PVRSRV_KERNEL_MEM_INFO *
-						      psSrcMemInfo,
-						      IMG_HANDLE hDstDevMemHeap,
-						      PVRSRV_KERNEL_MEM_INFO **
-						      ppsDstMemInfo)
-{
-	PVRSRV_ERROR eError;
-	IMG_UINT32 i;
-	IMG_UINT32 ui32PageCount, ui32PageOffset;
-	IMG_UINT32 ui32HostPageSize = HOST_PAGESIZE();
-	IMG_SYS_PHYADDR *psSysPAddr = IMG_NULL;
-	IMG_DEV_PHYADDR sDevPAddr;
-	BM_BUF *psBuf;
-	IMG_DEV_VIRTADDR sDevVAddr;
-	PVRSRV_KERNEL_MEM_INFO *psMemInfo = IMG_NULL;
-	BM_HANDLE hBuffer;
-	PVRSRV_MEMBLK *psMemBlock;
+enum PVRSRV_ERROR PVRSRVMapDeviceMemoryKM(
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+			      struct PVRSRV_KERNEL_MEM_INFO *psSrcMemInfo,
+			      void *hDstDevMemHeap,
+			      struct PVRSRV_KERNEL_MEM_INFO **ppsDstMemInfo)
+{
+	enum PVRSRV_ERROR eError;
+	u32 i;
+	u32 ui32PageCount, ui32PageOffset;
+	u32 ui32HostPageSize = HOST_PAGESIZE();
+	struct IMG_SYS_PHYADDR *psSysPAddr = NULL;
+	struct IMG_DEV_PHYADDR sDevPAddr;
+	struct BM_BUF *psBuf;
+	struct IMG_DEV_VIRTADDR sDevVAddr;
+	struct PVRSRV_KERNEL_MEM_INFO *psMemInfo = NULL;
+	void *hBuffer;
+	struct PVRSRV_MEMBLK *psMemBlock;
 	IMG_BOOL bBMError;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	IMG_VOID *pvPageAlignedCPUVAddr;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	void *pvPageAlignedCPUVAddr;
 
 	if (!psSrcMemInfo || !hDstDevMemHeap || !ppsDstMemInfo) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVMapDeviceMemoryKM: invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVMapDeviceMemoryKM: invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	*ppsDstMemInfo = IMG_NULL;
+	*ppsDstMemInfo = NULL;
 
 	ui32PageOffset =
 	    psSrcMemInfo->sDevVAddr.uiAddr & (ui32HostPageSize - 1);
@@ -941,14 +777,14 @@
 	    HOST_PAGEALIGN(psSrcMemInfo->ui32AllocSize +
 			   ui32PageOffset) / ui32HostPageSize;
 	pvPageAlignedCPUVAddr =
-	    (IMG_VOID *) ((IMG_UINT8 *) psSrcMemInfo->pvLinAddrKM -
+	    (void *) ((u8 *) psSrcMemInfo->pvLinAddrKM -
 			  ui32PageOffset);
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       ui32PageCount * sizeof(IMG_SYS_PHYADDR),
-		       (IMG_VOID **) & psSysPAddr, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVMapDeviceMemoryKM: Failed to alloc memory for block"));
+		       ui32PageCount * sizeof(struct IMG_SYS_PHYADDR),
+		       (void **) &psSysPAddr, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVMapDeviceMemoryKM: "
+					"Failed to alloc memory for block");
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
@@ -961,8 +797,8 @@
 		eError =
 		    BM_GetPhysPageAddr(psSrcMemInfo, sDevVAddr, &sDevPAddr);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVMapDeviceMemoryKM: Failed to retrieve page list from device"));
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVMapDeviceMemoryKM: "
+				"Failed to retrieve page list from device");
 			goto ErrorExit;
 		}
 
@@ -974,10 +810,10 @@
 	}
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(PVRSRV_KERNEL_MEM_INFO),
-		       (IMG_VOID **) & psMemInfo, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVMapDeviceMemoryKM: Failed to alloc memory for block"));
+		       sizeof(struct PVRSRV_KERNEL_MEM_INFO),
+		       (void **) &psMemInfo, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVMapDeviceMemoryKM: "
+					"Failed to alloc memory for block");
 		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
 		goto ErrorExit;
 	}
@@ -988,16 +824,13 @@
 
 	bBMError = BM_Wrap(psBuf->pMapping->pBMHeap,
 			   psSrcMemInfo->ui32AllocSize,
-			   ui32PageOffset,
-			   IMG_FALSE,
-			   psSysPAddr,
-			   IMG_TRUE,
-			   pvPageAlignedCPUVAddr,
+			   ui32PageOffset, IMG_FALSE, psSysPAddr,
+			   IMG_TRUE, pvPageAlignedCPUVAddr,
 			   &psMemInfo->ui32Flags, &hBuffer);
 
 	if (!bBMError) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVMapDeviceMemoryKM: BM_Wrap Failed"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVMapDeviceMemoryKM: BM_Wrap Failed");
 		eError = PVRSRV_ERROR_BAD_MAPPING;
 		goto ErrorExit;
 	}
@@ -1005,7 +838,7 @@
 	psMemBlock->sDevVirtAddr = BM_HandleToDevVaddr(hBuffer);
 	psMemBlock->hOSMemHandle = BM_HandleToOSMemHandle(hBuffer);
 
-	psMemBlock->hBuffer = (IMG_HANDLE) hBuffer;
+	psMemBlock->hBuffer = (void *) hBuffer;
 
 	psMemInfo->pvLinAddrKM = psSrcMemInfo->pvLinAddrKM;
 
@@ -1024,103 +857,99 @@
 
 ErrorExit:
 
-	if (psSysPAddr) {
-
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  ui32PageCount * sizeof(IMG_SYS_PHYADDR), psSysPAddr,
-			  IMG_NULL);
-	}
-
-	if (psMemInfo) {
+	if (psSysPAddr)
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32PageCount *
+			    sizeof(struct IMG_SYS_PHYADDR), psSysPAddr, NULL);
 
+	if (psMemInfo)
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  sizeof(PVRSRV_KERNEL_MEM_INFO), psMemInfo, IMG_NULL);
-	}
+			  sizeof(struct PVRSRV_KERNEL_MEM_INFO), psMemInfo,
+			  NULL);
 
 	return eError;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV
-PVRSRVUnmapDeviceClassMemoryKM(PVRSRV_KERNEL_MEM_INFO * psMemInfo)
+enum PVRSRV_ERROR PVRSRVUnmapDeviceClassMemoryKM(
+				struct PVRSRV_KERNEL_MEM_INFO *psMemInfo)
 {
-	if (!psMemInfo) {
+	if (!psMemInfo)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
-	return ResManFreeResByPtr(psMemInfo->sMemBlk.hResItem);
+	ResManFreeResByPtr(psMemInfo->sMemBlk.hResItem);
+	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR UnmapDeviceClassMemoryCallBack(IMG_PVOID pvParam,
-						   IMG_UINT32 ui32Param)
+static enum PVRSRV_ERROR UnmapDeviceClassMemoryCallBack(void *pvParam,
+							u32 ui32Param)
 {
-	PVRSRV_KERNEL_MEM_INFO *psMemInfo = pvParam;
+	struct PVRSRV_KERNEL_MEM_INFO *psMemInfo = pvParam;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
 	return FreeDeviceMem(psMemInfo);
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV
-PVRSRVMapDeviceClassMemoryKM(PVRSRV_PER_PROCESS_DATA * psPerProc,
-			     IMG_HANDLE hDeviceClassBuffer,
-			     PVRSRV_KERNEL_MEM_INFO ** ppsMemInfo,
-			     IMG_HANDLE * phOSMapInfo)
-{
-	PVRSRV_ERROR eError;
-	PVRSRV_KERNEL_MEM_INFO *psMemInfo;
-	PVRSRV_DEVICECLASS_BUFFER *psDeviceClassBuffer;
-	IMG_SYS_PHYADDR *psSysPAddr;
-	IMG_VOID *pvCPUVAddr, *pvPageAlignedCPUVAddr;
+enum PVRSRV_ERROR PVRSRVMapDeviceClassMemoryKM(
+				struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+				void *hDeviceClassBuffer,
+				struct PVRSRV_KERNEL_MEM_INFO **ppsMemInfo,
+				void **phOSMapInfo)
+{
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_KERNEL_MEM_INFO *psMemInfo;
+	struct PVRSRV_DEVICECLASS_BUFFER *psDeviceClassBuffer;
+	struct IMG_SYS_PHYADDR *psSysPAddr;
+	void *pvCPUVAddr, *pvPageAlignedCPUVAddr;
 	IMG_BOOL bPhysContig;
-	BM_CONTEXT *psBMContext;
-	DEVICE_MEMORY_INFO *psDevMemoryInfo;
-	IMG_HANDLE hDevMemHeap;
-	IMG_UINT32 ui32ByteSize;
-	IMG_UINT32 ui32Offset;
-	IMG_UINT32 ui32PageSize = HOST_PAGESIZE();
-	BM_HANDLE hBuffer;
-	PVRSRV_MEMBLK *psMemBlock;
+	struct BM_CONTEXT *psBMContext;
+	struct DEVICE_MEMORY_INFO *psDevMemoryInfo;
+	void *hDevMemHeap;
+	u32 ui32ByteSize;
+	u32 ui32Offset;
+	u32 ui32PageSize = HOST_PAGESIZE();
+	void *hBuffer;
+	struct PVRSRV_MEMBLK *psMemBlock;
 	IMG_BOOL bBMError;
 
 	if (!hDeviceClassBuffer || !ppsMemInfo || !phOSMapInfo) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVMapDeviceClassMemoryKM: invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVMapDeviceClassMemoryKM: invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	psDeviceClassBuffer = (PVRSRV_DEVICECLASS_BUFFER *) hDeviceClassBuffer;
+	psDeviceClassBuffer = (struct PVRSRV_DEVICECLASS_BUFFER *)
+							hDeviceClassBuffer;
 
 	eError =
 	    psDeviceClassBuffer->pfnGetBufferAddr(psDeviceClassBuffer->
 						  hExtDevice,
 						  psDeviceClassBuffer->
 						  hExtBuffer, &psSysPAddr,
-						  &ui32ByteSize, &pvCPUVAddr,
+						  &ui32ByteSize,
+						  (void __iomem **)&pvCPUVAddr,
 						  phOSMapInfo, &bPhysContig);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVMapDeviceClassMemoryKM: unable to get buffer address"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVMapDeviceClassMemoryKM: "
+				"unable to get buffer address");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
-	psBMContext = (BM_CONTEXT *) psDeviceClassBuffer->hDevMemContext;
+	psBMContext = (struct BM_CONTEXT *)psDeviceClassBuffer->hDevMemContext;
 	psDevMemoryInfo = &psBMContext->psDeviceNode->sDevMemoryInfo;
 	hDevMemHeap =
 	    psDevMemoryInfo->psDeviceMemoryHeap[SGX_FB_MAPPING_HEAP_ID].
 	    hDevMemHeap;
 
-	ui32Offset = ((IMG_UINT32) pvCPUVAddr) & (ui32PageSize - 1);
+	ui32Offset = ((u32) pvCPUVAddr) & (ui32PageSize - 1);
 	pvPageAlignedCPUVAddr =
-	    (IMG_VOID *) ((IMG_UINT8 *) pvCPUVAddr - ui32Offset);
+	    (void *) ((u8 *) pvCPUVAddr - ui32Offset);
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(PVRSRV_KERNEL_MEM_INFO),
-		       (IMG_VOID **) & psMemInfo, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVMapDeviceClassMemoryKM: Failed to alloc memory for block"));
-		return (PVRSRV_ERROR_OUT_OF_MEMORY);
+		       sizeof(struct PVRSRV_KERNEL_MEM_INFO),
+		       (void **) &psMemInfo, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVMapDeviceClassMemoryKM: "
+			 "Failed to alloc memory for block");
+		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
 	OSMemSet(psMemInfo, 0, sizeof(*psMemInfo));
@@ -1137,17 +966,18 @@
 			   &psMemInfo->ui32Flags, &hBuffer);
 
 	if (!bBMError) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVMapDeviceClassMemoryKM: BM_Wrap Failed"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVMapDeviceClassMemoryKM: BM_Wrap Failed");
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  sizeof(PVRSRV_KERNEL_MEM_INFO), psMemInfo, IMG_NULL);
+			  sizeof(struct PVRSRV_KERNEL_MEM_INFO),
+			  psMemInfo, NULL);
 		return PVRSRV_ERROR_BAD_MAPPING;
 	}
 
 	psMemBlock->sDevVirtAddr = BM_HandleToDevVaddr(hBuffer);
 	psMemBlock->hOSMemHandle = BM_HandleToOSMemHandle(hBuffer);
 
-	psMemBlock->hBuffer = (IMG_HANDLE) hBuffer;
+	psMemBlock->hBuffer = (void *) hBuffer;
 
 	psMemInfo->pvLinAddrKM = BM_HandleToCpuVaddr(hBuffer);
 
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/env_data.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/env_data.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -34,24 +34,18 @@
 #define PVRSRV_MAX_BRIDGE_IN_SIZE	0x1000
 #define PVRSRV_MAX_BRIDGE_OUT_SIZE	0x1000
 
-typedef struct _PVR_PCI_DEV_TAG {
-	struct pci_dev *psPCIDev;
-	HOST_PCI_INIT_FLAGS ePCIFlags;
-	IMG_BOOL abPCIResourceInUse[DEVICE_COUNT_RESOURCE];
-} PVR_PCI_DEV;
-
-typedef struct _ENV_DATA_TAG {
-	IMG_VOID *pvBridgeData;
+struct ENV_DATA {
+	void *pvBridgeData;
 	struct pm_dev *psPowerDevice;
 	IMG_BOOL bLISRInstalled;
 	IMG_BOOL bMISRInstalled;
-	IMG_UINT32 ui32IRQ;
-	IMG_VOID *pvISRCookie;
+	u32 ui32IRQ;
+	void *pvISRCookie;
 	struct workqueue_struct *psMISRWorkqueue;
 	struct work_struct sMISRWork;
 	struct workqueue_struct *psPerfWorkqueue;
 	struct delayed_work sPerfWork;
-	IMG_VOID *pvSysData;	/*for MISR work */
-} ENV_DATA;
+	void *pvSysData;	/*for MISR work */
+};
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/event.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/event.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -29,7 +29,7 @@
 #endif
 
 #include <linux/version.h>
-#include <asm/io.h>
+#include <linux/io.h>
 #include <asm/page.h>
 #include <asm/system.h>
 #include <linux/mm.h>
@@ -41,11 +41,11 @@
 #include <linux/string.h>
 #include <linux/sched.h>
 #include <linux/interrupt.h>
-#include <asm/hardirq.h>
+#include <linux/hardirq.h>
 #include <linux/timer.h>
 #include <linux/capability.h>
 #include <linux/sched.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #include "img_types.h"
 #include "services_headers.h"
@@ -55,37 +55,36 @@
 #include "env_data.h"
 #include "proc.h"
 #include "mutex.h"
+#include "event.h"
 
-extern PVRSRV_LINUX_MUTEX gPVRSRVLock;
-
-typedef struct PVRSRV_LINUX_EVENT_OBJECT_LIST_TAG {
+struct PVRSRV_LINUX_EVENT_OBJECT_LIST {
 	rwlock_t sLock;
 	struct list_head sList;
 
-} PVRSRV_LINUX_EVENT_OBJECT_LIST;
+};
 
-typedef struct PVRSRV_LINUX_EVENT_OBJECT_TAG {
+struct PVRSRV_LINUX_EVENT_OBJECT {
 	atomic_t sTimeStamp;
-	IMG_UINT32 ui32TimeStampPrevious;
+	u32 ui32TimeStampPrevious;
 #ifdef DEBUG
 	unsigned int ui32Stats;
 #endif
 	wait_queue_head_t sWait;
 	struct list_head sList;
-	IMG_HANDLE hResItem;
-	PVRSRV_LINUX_EVENT_OBJECT_LIST *psLinuxEventObjectList;
-} PVRSRV_LINUX_EVENT_OBJECT;
+	void *hResItem;
+	struct PVRSRV_LINUX_EVENT_OBJECT_LIST *psLinuxEventObjectList;
+};
 
-PVRSRV_ERROR LinuxEventObjectListCreate(IMG_HANDLE * phEventObjectList)
+enum PVRSRV_ERROR LinuxEventObjectListCreate(void **phEventObjectList)
 {
-	PVRSRV_LINUX_EVENT_OBJECT_LIST *psEvenObjectList;
+	struct PVRSRV_LINUX_EVENT_OBJECT_LIST *psEvenObjectList;
 
 	if (OSAllocMem
 	    (PVRSRV_OS_NON_PAGEABLE_HEAP,
-	     sizeof(PVRSRV_LINUX_EVENT_OBJECT_LIST),
-	     (IMG_VOID **) & psEvenObjectList, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "LinuxEventObjectCreate: failed to allocate memory for event list"));
+	     sizeof(struct PVRSRV_LINUX_EVENT_OBJECT_LIST),
+	     (void **) &psEvenObjectList, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "LinuxEventObjectCreate: "
+			"failed to allocate memory for event list");
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
@@ -93,59 +92,54 @@
 
 	rwlock_init(&psEvenObjectList->sLock);
 
-	*phEventObjectList = (IMG_HANDLE *) psEvenObjectList;
+	*phEventObjectList = (void **) psEvenObjectList;
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR LinuxEventObjectListDestroy(IMG_HANDLE hEventObjectList)
+enum PVRSRV_ERROR LinuxEventObjectListDestroy(void *hEventObjectList)
 {
 
-	PVRSRV_LINUX_EVENT_OBJECT_LIST *psEvenObjectList =
-	    (PVRSRV_LINUX_EVENT_OBJECT_LIST *) hEventObjectList;
+	struct PVRSRV_LINUX_EVENT_OBJECT_LIST *psEvenObjectList =
+	    (struct PVRSRV_LINUX_EVENT_OBJECT_LIST *)hEventObjectList;
 
 	if (psEvenObjectList) {
 		if (!list_empty(&psEvenObjectList->sList)) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "LinuxEventObjectListDestroy: Event List is not empty"));
+			PVR_DPF(PVR_DBG_ERROR, "LinuxEventObjectListDestroy: "
+				"Event List is not empty");
 			return PVRSRV_ERROR_GENERIC;
 		}
 		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-			  sizeof(PVRSRV_LINUX_EVENT_OBJECT_LIST),
-			  psEvenObjectList, IMG_NULL);
+			  sizeof(struct PVRSRV_LINUX_EVENT_OBJECT_LIST),
+			  psEvenObjectList, NULL);
 	}
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR LinuxEventObjectDelete(IMG_HANDLE hOSEventObjectList,
-				    IMG_HANDLE hOSEventObject)
+enum PVRSRV_ERROR LinuxEventObjectDelete(void *hOSEventObjectList,
+				    void *hOSEventObject)
 {
-	if (hOSEventObjectList) {
+	if (hOSEventObjectList)
 		if (hOSEventObject) {
-			PVRSRV_LINUX_EVENT_OBJECT *psLinuxEventObject =
-			    (PVRSRV_LINUX_EVENT_OBJECT *) hOSEventObject;
+			struct PVRSRV_LINUX_EVENT_OBJECT *psLinuxEventObject =
+			    (struct PVRSRV_LINUX_EVENT_OBJECT *)hOSEventObject;
 #ifdef DEBUG
-			PVR_DPF((PVR_DBG_MESSAGE,
-				 "LinuxEventObjectListDelete: Event object waits: %lu",
-				 psLinuxEventObject->ui32Stats));
+			PVR_DPF(PVR_DBG_MESSAGE, "LinuxEventObjectListDelete: "
+				 "Event object waits: %lu",
+				 psLinuxEventObject->ui32Stats);
 #endif
-			if (ResManFreeResByPtr(psLinuxEventObject->hResItem) !=
-			    PVRSRV_OK) {
-				return PVRSRV_ERROR_GENERIC;
-			}
-
+			ResManFreeResByPtr(psLinuxEventObject->hResItem);
 			return PVRSRV_OK;
 		}
-	}
 	return PVRSRV_ERROR_GENERIC;
 
 }
 
-static PVRSRV_ERROR LinuxEventObjectDeleteCallback(IMG_PVOID pvParam,
-						   IMG_UINT32 ui32Param)
+static enum PVRSRV_ERROR LinuxEventObjectDeleteCallback(void *pvParam,
+							u32 ui32Param)
 {
-	PVRSRV_LINUX_EVENT_OBJECT *psLinuxEventObject = pvParam;
-	PVRSRV_LINUX_EVENT_OBJECT_LIST *psLinuxEventObjectList =
+	struct PVRSRV_LINUX_EVENT_OBJECT *psLinuxEventObject = pvParam;
+	struct PVRSRV_LINUX_EVENT_OBJECT_LIST *psLinuxEventObjectList =
 	    psLinuxEventObject->psLinuxEventObjectList;
 
 	write_lock_bh(&psLinuxEventObjectList->sLock);
@@ -153,39 +147,39 @@
 	write_unlock_bh(&psLinuxEventObjectList->sLock);
 
 #ifdef DEBUG
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "LinuxEventObjectDeleteCallback: Event object waits: %lu",
-		 psLinuxEventObject->ui32Stats));
+		 psLinuxEventObject->ui32Stats);
 #endif
 
 	OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-		  sizeof(PVRSRV_LINUX_EVENT_OBJECT), psLinuxEventObject,
-		  IMG_NULL);
+		  sizeof(struct PVRSRV_LINUX_EVENT_OBJECT), psLinuxEventObject,
+		  NULL);
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR LinuxEventObjectAdd(IMG_HANDLE hOSEventObjectList,
-				 IMG_HANDLE * phOSEventObject)
+enum PVRSRV_ERROR LinuxEventObjectAdd(void *hOSEventObjectList,
+				 void **phOSEventObject)
 {
-	PVRSRV_LINUX_EVENT_OBJECT *psLinuxEventObject;
-	PVRSRV_LINUX_EVENT_OBJECT_LIST *psLinuxEventObjectList =
-	    (PVRSRV_LINUX_EVENT_OBJECT_LIST *) hOSEventObjectList;
-	IMG_UINT32 ui32PID = OSGetCurrentProcessIDKM();
-	PVRSRV_PER_PROCESS_DATA *psPerProc;
+	struct PVRSRV_LINUX_EVENT_OBJECT *psLinuxEventObject;
+	struct PVRSRV_LINUX_EVENT_OBJECT_LIST *psLinuxEventObjectList =
+	    (struct PVRSRV_LINUX_EVENT_OBJECT_LIST *)hOSEventObjectList;
+	u32 ui32PID = OSGetCurrentProcessIDKM();
+	struct PVRSRV_PER_PROCESS_DATA *psPerProc;
 
 	psPerProc = PVRSRVPerProcessData(ui32PID);
-	if (psPerProc == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "LinuxEventObjectAdd: Couldn't find per-process data"));
+	if (psPerProc == NULL) {
+		PVR_DPF(PVR_DBG_ERROR, "LinuxEventObjectAdd: "
+				"Couldn't find per-process data");
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
-	if (OSAllocMem
-	    (PVRSRV_OS_NON_PAGEABLE_HEAP, sizeof(PVRSRV_LINUX_EVENT_OBJECT),
-	     (IMG_VOID **) & psLinuxEventObject, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "LinuxEventObjectAdd: failed to allocate memory "));
+	if (OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+	     sizeof(struct PVRSRV_LINUX_EVENT_OBJECT),
+	     (void **) &psLinuxEventObject, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "LinuxEventObjectAdd: failed to allocate memory ");
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
@@ -215,18 +209,19 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR LinuxEventObjectSignal(IMG_HANDLE hOSEventObjectList)
+enum PVRSRV_ERROR LinuxEventObjectSignal(void *hOSEventObjectList)
 {
-	PVRSRV_LINUX_EVENT_OBJECT *psLinuxEventObject;
-	PVRSRV_LINUX_EVENT_OBJECT_LIST *psLinuxEventObjectList =
-	    (PVRSRV_LINUX_EVENT_OBJECT_LIST *) hOSEventObjectList;
+	struct PVRSRV_LINUX_EVENT_OBJECT *psLinuxEventObject;
+	struct PVRSRV_LINUX_EVENT_OBJECT_LIST *psLinuxEventObjectList =
+	    (struct PVRSRV_LINUX_EVENT_OBJECT_LIST *)hOSEventObjectList;
 	struct list_head *psListEntry, *psListEntryTemp, *psList;
 	psList = &psLinuxEventObjectList->sList;
 
 	list_for_each_safe(psListEntry, psListEntryTemp, psList) {
 
-		psLinuxEventObject =
-		    list_entry(psListEntry, PVRSRV_LINUX_EVENT_OBJECT, sList);
+		psLinuxEventObject = list_entry(psListEntry,
+					struct PVRSRV_LINUX_EVENT_OBJECT,
+					sList);
 
 		atomic_inc(&psLinuxEventObject->sTimeStamp);
 		wake_up_interruptible(&psLinuxEventObject->sWait);
@@ -236,34 +231,29 @@
 
 }
 
-PVRSRV_ERROR LinuxEventObjectWait(IMG_HANDLE hOSEventObject,
-				  IMG_UINT32 ui32MSTimeout)
+enum PVRSRV_ERROR LinuxEventObjectWait(void *hOSEventObject, u32 ui32MSTimeout)
 {
 	DEFINE_WAIT(sWait);
 
-	PVRSRV_LINUX_EVENT_OBJECT *psLinuxEventObject =
-	    (PVRSRV_LINUX_EVENT_OBJECT *) hOSEventObject;
+	struct PVRSRV_LINUX_EVENT_OBJECT *psLinuxEventObject =
+	    (struct PVRSRV_LINUX_EVENT_OBJECT *)hOSEventObject;
 
-	IMG_UINT32 ui32TimeOutJiffies = msecs_to_jiffies(ui32MSTimeout);
+	u32 ui32TimeOutJiffies = msecs_to_jiffies(ui32MSTimeout);
 
 	do {
 		prepare_to_wait(&psLinuxEventObject->sWait, &sWait,
 				TASK_INTERRUPTIBLE);
 
 		if (psLinuxEventObject->ui32TimeStampPrevious !=
-		    atomic_read(&psLinuxEventObject->sTimeStamp)) {
+		    atomic_read(&psLinuxEventObject->sTimeStamp))
 			break;
-		}
 
 		LinuxUnLockMutex(&gPVRSRVLock);
-
 		ui32TimeOutJiffies = schedule_timeout(ui32TimeOutJiffies);
-
 #ifdef DEBUG
 		psLinuxEventObject->ui32Stats++;
 #endif
 		LinuxLockMutex(&gPVRSRVLock);
-
 	} while (ui32TimeOutJiffies);
 
 	finish_wait(&psLinuxEventObject->sWait, &sWait);
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/event.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/event.h
@@ -1,35 +1,35 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
-PVRSRV_ERROR LinuxEventObjectListCreate(IMG_HANDLE * phEventObjectList);
-PVRSRV_ERROR LinuxEventObjectListDestroy(IMG_HANDLE hEventObjectList);
-PVRSRV_ERROR LinuxEventObjectAdd(IMG_HANDLE hOSEventObjectList,
-				 IMG_HANDLE * phOSEventObject);
-PVRSRV_ERROR LinuxEventObjectDelete(IMG_HANDLE hOSEventObjectList,
-				    IMG_HANDLE hOSEventObject);
-PVRSRV_ERROR LinuxEventObjectSignal(IMG_HANDLE hOSEventObjectList);
-PVRSRV_ERROR LinuxEventObjectWait(IMG_HANDLE hOSEventObject,
-				  IMG_UINT32 ui32MSTimeout);
+enum PVRSRV_ERROR LinuxEventObjectListCreate(void **phEventObjectList);
+enum PVRSRV_ERROR LinuxEventObjectListDestroy(void *hEventObjectList);
+enum PVRSRV_ERROR LinuxEventObjectAdd(void *hOSEventObjectList,
+				 void **phOSEventObject);
+enum PVRSRV_ERROR LinuxEventObjectDelete(void *hOSEventObjectList,
+				    void *hOSEventObject);
+enum PVRSRV_ERROR LinuxEventObjectSignal(void *hOSEventObjectList);
+enum PVRSRV_ERROR LinuxEventObjectWait(void *hOSEventObject, u32 ui32MSTimeout);
+
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/handle.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/handle.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -39,44 +39,58 @@
 
 #define	INDEX_IS_VALID(psBase, i) ((i) < (psBase)->ui32TotalHandCount)
 
-#define	INDEX_TO_HANDLE(psBase, idx) ((IMG_HANDLE)((idx) + 1))
-#define	HANDLE_TO_INDEX(psBase, hand) ((IMG_UINT32)(hand) - 1)
+#define	INDEX_TO_HANDLE(psBase, idx) ((void *)((idx) + 1))
+#define	HANDLE_TO_INDEX(psBase, hand) ((u32)(hand) - 1)
 
 #define INDEX_TO_HANDLE_PTR(psBase, i) (((psBase)->psHandleArray) + (i))
-#define	HANDLE_TO_HANDLE_PTR(psBase, h) (INDEX_TO_HANDLE_PTR(psBase, HANDLE_TO_INDEX(psBase, h)))
 
-#define	HANDLE_PTR_TO_INDEX(psBase, psHandle) ((psHandle) - ((psBase)->psHandleArray))
-#define	HANDLE_PTR_TO_HANDLE(psBase, psHandle) \
+#define	HANDLE_TO_HANDLE_PTR(psBase, h)					\
+	(INDEX_TO_HANDLE_PTR(psBase, HANDLE_TO_INDEX(psBase, h)))
+
+#define	HANDLE_PTR_TO_INDEX(psBase, psHandle)				\
+	((psHandle) - ((psBase)->psHandleArray))
+
+#define	HANDLE_PTR_TO_HANDLE(psBase, psHandle)				\
 	INDEX_TO_HANDLE(psBase, HANDLE_PTR_TO_INDEX(psBase, psHandle))
 
 #define	ROUND_UP_TO_MULTIPLE(a, b) ((((a) + (b) - 1) / (b)) * (b))
 
 #define	HANDLES_BATCHED(psBase) ((psBase)->ui32HandBatchSize != 0)
 
-#define	SET_FLAG(v, f) ((void)((v) |= (f)))
-#define	CLEAR_FLAG(v, f) ((void)((v) &= ~(f)))
-#define	TEST_FLAG(v, f) ((IMG_BOOL)(((v) & (f)) != 0))
+#define	SET_FLAG(v, f)		((void)((v) |= (f)))
+#define	CLEAR_FLAG(v, f)	((void)((v) &= ~(f)))
+#define	TEST_FLAG(v, f)		((IMG_BOOL)(((v) & (f)) != 0))
 
 #define	TEST_ALLOC_FLAG(psHandle, f) TEST_FLAG((psHandle)->eFlag, f)
 
-#define	SET_INTERNAL_FLAG(psHandle, f) SET_FLAG((psHandle)->eInternalFlag, f)
-#define	CLEAR_INTERNAL_FLAG(psHandle, f) CLEAR_FLAG((psHandle)->eInternalFlag, f)
-#define	TEST_INTERNAL_FLAG(psHandle, f) TEST_FLAG((psHandle)->eInternalFlag, f)
-
-#define	BATCHED_HANDLE(psHandle) TEST_INTERNAL_FLAG(psHandle, INTERNAL_HANDLE_FLAG_BATCHED)
-
-#define	SET_BATCHED_HANDLE(psHandle) SET_INTERNAL_FLAG(psHandle, INTERNAL_HANDLE_FLAG_BATCHED)
-
-#define	SET_UNBATCHED_HANDLE(psHandle) CLEAR_INTERNAL_FLAG(psHandle, INTERNAL_HANDLE_FLAG_BATCHED)
-
-#define	BATCHED_HANDLE_PARTIALLY_FREE(psHandle) TEST_INTERNAL_FLAG(psHandle, INTERNAL_HANDLE_FLAG_BATCHED_PARTIALLY_FREE)
-
-#define SET_BATCHED_HANDLE_PARTIALLY_FREE(psHandle) SET_INTERNAL_FLAG(psHandle, INTERNAL_HANDLE_FLAG_BATCHED_PARTIALLY_FREE)
+#define	SET_INTERNAL_FLAG(psHandle, f)				\
+		 SET_FLAG((psHandle)->eInternalFlag, f)
+#define	CLEAR_INTERNAL_FLAG(psHandle, f)			\
+		 CLEAR_FLAG((psHandle)->eInternalFlag, f)
+#define	TEST_INTERNAL_FLAG(psHandle, f)				\
+		 TEST_FLAG((psHandle)->eInternalFlag, f)
+
+#define	BATCHED_HANDLE(psHandle)				\
+		 TEST_INTERNAL_FLAG(psHandle, INTERNAL_HANDLE_FLAG_BATCHED)
+
+#define	SET_BATCHED_HANDLE(psHandle)				\
+		 SET_INTERNAL_FLAG(psHandle, INTERNAL_HANDLE_FLAG_BATCHED)
+
+#define	SET_UNBATCHED_HANDLE(psHandle)				\
+		 CLEAR_INTERNAL_FLAG(psHandle, INTERNAL_HANDLE_FLAG_BATCHED)
+
+#define	BATCHED_HANDLE_PARTIALLY_FREE(psHandle)			\
+		 TEST_INTERNAL_FLAG(psHandle,			\
+				INTERNAL_HANDLE_FLAG_BATCHED_PARTIALLY_FREE)
+
+#define SET_BATCHED_HANDLE_PARTIALLY_FREE(psHandle)		\
+		 SET_INTERNAL_FLAG(psHandle,			\
+				INTERNAL_HANDLE_FLAG_BATCHED_PARTIALLY_FREE)
 
 struct sHandleList {
-	IMG_UINT32 ui32Prev;
-	IMG_UINT32 ui32Next;
-	IMG_HANDLE hParent;
+	u32 ui32Prev;
+	u32 ui32Next;
+	void *hParent;
 };
 
 enum ePVRSRVInternalHandleFlag {
@@ -85,55 +99,32 @@
 };
 
 struct sHandle {
-
-	PVRSRV_HANDLE_TYPE eType;
-
-	IMG_VOID *pvData;
-
-	IMG_UINT32 ui32NextIndexPlusOne;
-
+	enum PVRSRV_HANDLE_TYPE eType;
+	void *pvData;
+	u32 ui32NextIndexPlusOne;
 	enum ePVRSRVInternalHandleFlag eInternalFlag;
-
-	PVRSRV_HANDLE_ALLOC_FLAG eFlag;
-
-	IMG_UINT32 ui32PID;
-
-	IMG_UINT32 ui32Index;
-
+	enum PVRSRV_HANDLE_ALLOC_FLAG eFlag;
+	u32 ui32PID;
+	u32 ui32Index;
 	struct sHandleList sChildren;
-
 	struct sHandleList sSiblings;
 };
 
-struct _PVRSRV_HANDLE_BASE_ {
-
-	IMG_HANDLE hBaseBlockAlloc;
-
-	IMG_UINT32 ui32PID;
-
-	IMG_HANDLE hHandBlockAlloc;
-
-	PRESMAN_ITEM psResManItem;
-
+struct PVRSRV_HANDLE_BASE {
+	void *hBaseBlockAlloc;
+	u32 ui32PID;
+	void *hHandBlockAlloc;
+	struct RESMAN_ITEM *psResManItem;
 	struct sHandle *psHandleArray;
-
-	HASH_TABLE *psHashTab;
-
-	IMG_UINT32 ui32FreeHandCount;
-
-	IMG_UINT32 ui32FirstFreeIndex;
-
-	IMG_UINT32 ui32TotalHandCount;
-
-	IMG_UINT32 ui32LastFreeIndexPlusOne;
-
-	IMG_UINT32 ui32HandBatchSize;
-
-	IMG_UINT32 ui32TotalHandCountPreBatch;
-
-	IMG_UINT32 ui32FirstBatchIndexPlusOne;
-
-	IMG_UINT32 ui32BatchHandAllocFailures;
+	struct HASH_TABLE *psHashTab;
+	u32 ui32FreeHandCount;
+	u32 ui32FirstFreeIndex;
+	u32 ui32TotalHandCount;
+	u32 ui32LastFreeIndexPlusOne;
+	u32 ui32HandBatchSize;
+	u32 ui32TotalHandCountPreBatch;
+	u32 ui32FirstBatchIndexPlusOne;
+	u32 ui32BatchHandAllocFailures;
 };
 
 enum eHandKey {
@@ -143,39 +134,36 @@
 	HAND_KEY_LEN
 };
 
-PVRSRV_HANDLE_BASE *gpsKernelHandleBase;
+struct PVRSRV_HANDLE_BASE *gpsKernelHandleBase;
 
-typedef IMG_UINTPTR_T HAND_KEY[HAND_KEY_LEN];
+typedef u32 HAND_KEY[HAND_KEY_LEN];
 
-static INLINE
-    IMG_VOID HandleListInit(IMG_UINT32 ui32Index, struct sHandleList *psList,
-			    IMG_HANDLE hParent)
+static inline void HandleListInit(u32 ui32Index, struct sHandleList *psList,
+			    void *hParent)
 {
 	psList->ui32Next = ui32Index;
 	psList->ui32Prev = ui32Index;
 	psList->hParent = hParent;
 }
 
-static INLINE
-    IMG_VOID InitParentList(PVRSRV_HANDLE_BASE * psBase,
+static inline void InitParentList(struct PVRSRV_HANDLE_BASE *psBase,
 			    struct sHandle *psHandle)
 {
-	IMG_UINT32 ui32Parent = HANDLE_PTR_TO_INDEX(psBase, psHandle);
+	u32 ui32Parent = HANDLE_PTR_TO_INDEX(psBase, psHandle);
 
 	HandleListInit(ui32Parent, &psHandle->sChildren,
 		       INDEX_TO_HANDLE(psBase, ui32Parent));
 }
 
-static INLINE
-    IMG_VOID InitChildEntry(PVRSRV_HANDLE_BASE * psBase,
+static inline void InitChildEntry(struct PVRSRV_HANDLE_BASE *psBase,
 			    struct sHandle *psHandle)
 {
 	HandleListInit(HANDLE_PTR_TO_INDEX(psBase, psHandle),
-		       &psHandle->sSiblings, IMG_NULL);
+		       &psHandle->sSiblings, NULL);
 }
 
-static INLINE
-    IMG_BOOL HandleListIsEmpty(IMG_UINT32 ui32Index, struct sHandleList *psList)
+static inline IMG_BOOL HandleListIsEmpty(u32 ui32Index,
+					 struct sHandleList *psList)
 {
 	IMG_BOOL bIsEmpty;
 
@@ -194,8 +182,8 @@
 }
 
 #ifdef DEBUG
-static INLINE
-    IMG_BOOL NoChildren(PVRSRV_HANDLE_BASE * psBase, struct sHandle *psHandle)
+static inline IMG_BOOL NoChildren(struct PVRSRV_HANDLE_BASE *psBase,
+				  struct sHandle *psHandle)
 {
 	PVR_ASSERT(psHandle->sChildren.hParent ==
 		   HANDLE_PTR_TO_HANDLE(psBase, psHandle));
@@ -204,49 +192,50 @@
 				 &psHandle->sChildren);
 }
 
-static INLINE
-    IMG_BOOL NoParent(PVRSRV_HANDLE_BASE * psBase, struct sHandle *psHandle)
+static inline IMG_BOOL NoParent(struct PVRSRV_HANDLE_BASE *psBase,
+				struct sHandle *psHandle)
 {
 	if (HandleListIsEmpty
 	    (HANDLE_PTR_TO_INDEX(psBase, psHandle), &psHandle->sSiblings)) {
-		PVR_ASSERT(psHandle->sSiblings.hParent == IMG_NULL);
+		PVR_ASSERT(psHandle->sSiblings.hParent == NULL);
 
 		return IMG_TRUE;
 	} else {
-		PVR_ASSERT(psHandle->sSiblings.hParent != IMG_NULL);
+		PVR_ASSERT(psHandle->sSiblings.hParent != NULL);
 	}
 	return IMG_FALSE;
 }
 #endif
-static INLINE IMG_HANDLE ParentHandle(struct sHandle *psHandle)
+static inline void *ParentHandle(struct sHandle *psHandle)
 {
 	return psHandle->sSiblings.hParent;
 }
 
-#define	LIST_PTR_FROM_INDEX_AND_OFFSET(psBase, i, p, po, eo) \
-		((struct sHandleList *)((char *)(INDEX_TO_HANDLE_PTR(psBase, i)) + (((i) == (p)) ? (po) : (eo))))
+#define	LIST_PTR_FROM_INDEX_AND_OFFSET(psBase, i, p, po, eo)	\
+		((struct sHandleList *)				\
+		((char *)(INDEX_TO_HANDLE_PTR(psBase, i)) +	\
+			 (((i) == (p)) ? (po) : (eo))))
 
-static INLINE
-    IMG_VOID HandleListInsertBefore(PVRSRV_HANDLE_BASE * psBase,
-				    IMG_UINT32 ui32InsIndex,
+static inline void HandleListInsertBefore(struct PVRSRV_HANDLE_BASE *psBase,
+				    u32 ui32InsIndex,
 				    struct sHandleList *psIns,
-				    IMG_SIZE_T uiParentOffset,
-				    IMG_UINT32 ui32EntryIndex,
+				    size_t uiParentOffset,
+				    u32 ui32EntryIndex,
 				    struct sHandleList *psEntry,
-				    IMG_SIZE_T uiEntryOffset,
-				    IMG_UINT32 ui32ParentIndex)
+				    size_t uiEntryOffset,
+				    u32 ui32ParentIndex)
 {
 	struct sHandleList *psPrevIns =
 	    LIST_PTR_FROM_INDEX_AND_OFFSET(psBase, psIns->ui32Prev,
 					   ui32ParentIndex, uiParentOffset,
 					   uiEntryOffset);
 
-	PVR_ASSERT(psEntry->hParent == IMG_NULL);
+	PVR_ASSERT(psEntry->hParent == NULL);
 	PVR_ASSERT(ui32InsIndex == psPrevIns->ui32Next);
 	PVR_ASSERT(LIST_PTR_FROM_INDEX_AND_OFFSET
 		   (psBase, ui32ParentIndex, ui32ParentIndex, uiParentOffset,
 		    uiParentOffset)->hParent == INDEX_TO_HANDLE(psBase,
-								ui32ParentIndex));
+							ui32ParentIndex));
 
 	psEntry->ui32Prev = psIns->ui32Prev;
 	psIns->ui32Prev = ui32EntryIndex;
@@ -256,15 +245,14 @@
 	psEntry->hParent = INDEX_TO_HANDLE(psBase, ui32ParentIndex);
 }
 
-static INLINE
-    IMG_VOID AdoptChild(PVRSRV_HANDLE_BASE * psBase, struct sHandle *psParent,
-			struct sHandle *psChild)
+static inline void AdoptChild(struct PVRSRV_HANDLE_BASE *psBase,
+			      struct sHandle *psParent, struct sHandle *psChild)
 {
-	IMG_UINT32 ui32Parent =
+	u32 ui32Parent =
 	    HANDLE_TO_INDEX(psBase, psParent->sChildren.hParent);
 
 	PVR_ASSERT(ui32Parent ==
-		   (IMG_UINT32) HANDLE_PTR_TO_INDEX(psBase, psParent));
+		   (u32) HANDLE_PTR_TO_INDEX(psBase, psParent));
 
 	HandleListInsertBefore(psBase, ui32Parent, &psParent->sChildren,
 			       offsetof(struct sHandle, sChildren),
@@ -275,12 +263,9 @@
 
 }
 
-static INLINE
-    IMG_VOID HandleListRemove(PVRSRV_HANDLE_BASE * psBase,
-			      IMG_UINT32 ui32EntryIndex,
-			      struct sHandleList *psEntry,
-			      IMG_SIZE_T uiEntryOffset,
-			      IMG_SIZE_T uiParentOffset)
+static inline void HandleListRemove(struct PVRSRV_HANDLE_BASE *psBase,
+			      u32 ui32EntryIndex, struct sHandleList *psEntry,
+			      size_t uiEntryOffset, size_t uiParentOffset)
 {
 	if (!HandleListIsEmpty(ui32EntryIndex, psEntry)) {
 		struct sHandleList *psPrev =
@@ -298,17 +283,16 @@
 						   uiParentOffset,
 						   uiEntryOffset);
 
-		PVR_ASSERT(psEntry->hParent != IMG_NULL);
+		PVR_ASSERT(psEntry->hParent != NULL);
 
 		psPrev->ui32Next = psEntry->ui32Next;
 		psNext->ui32Prev = psEntry->ui32Prev;
 
-		HandleListInit(ui32EntryIndex, psEntry, IMG_NULL);
+		HandleListInit(ui32EntryIndex, psEntry, NULL);
 	}
 }
 
-static INLINE
-    IMG_VOID UnlinkFromParent(PVRSRV_HANDLE_BASE * psBase,
+static inline void UnlinkFromParent(struct PVRSRV_HANDLE_BASE *psBase,
 			      struct sHandle *psHandle)
 {
 	HandleListRemove(psBase, HANDLE_PTR_TO_INDEX(psBase, psHandle),
@@ -317,18 +301,19 @@
 			 offsetof(struct sHandle, sChildren));
 }
 
-static INLINE
-    PVRSRV_ERROR HandleListIterate(PVRSRV_HANDLE_BASE * psBase,
+static inline enum PVRSRV_ERROR HandleListIterate(
+				   struct PVRSRV_HANDLE_BASE *psBase,
 				   struct sHandleList *psHead,
-				   IMG_SIZE_T uiParentOffset,
-				   IMG_SIZE_T uiEntryOffset,
-				   PVRSRV_ERROR(*pfnIterFunc)
-				   (PVRSRV_HANDLE_BASE *, struct sHandle *))
+				   size_t uiParentOffset,
+				   size_t uiEntryOffset,
+				   enum PVRSRV_ERROR(*pfnIterFunc)
+						(struct PVRSRV_HANDLE_BASE *,
+						 struct sHandle *))
 {
-	IMG_UINT32 ui32Index;
-	IMG_UINT32 ui32Parent = HANDLE_TO_INDEX(psBase, psHead->hParent);
+	u32 ui32Index;
+	u32 ui32Parent = HANDLE_TO_INDEX(psBase, psHead->hParent);
 
-	PVR_ASSERT(psHead->hParent != IMG_NULL);
+	PVR_ASSERT(psHead->hParent != NULL);
 
 	for (ui32Index = psHead->ui32Next; ui32Index != ui32Parent;) {
 		struct sHandle *psHandle =
@@ -337,26 +322,25 @@
 		    LIST_PTR_FROM_INDEX_AND_OFFSET(psBase, ui32Index,
 						   ui32Parent, uiParentOffset,
 						   uiEntryOffset);
-		PVRSRV_ERROR eError;
+		enum PVRSRV_ERROR eError;
 
 		PVR_ASSERT(psEntry->hParent == psHead->hParent);
 
 		ui32Index = psEntry->ui32Next;
 
 		eError = (*pfnIterFunc) (psBase, psHandle);
-		if (eError != PVRSRV_OK) {
+		if (eError != PVRSRV_OK)
 			return eError;
-		}
 	}
 
 	return PVRSRV_OK;
 }
 
-static INLINE
-    PVRSRV_ERROR IterateOverChildren(PVRSRV_HANDLE_BASE * psBase,
-				     struct sHandle *psParent,
-				     PVRSRV_ERROR(*pfnIterFunc)
-				     (PVRSRV_HANDLE_BASE *, struct sHandle *))
+static inline enum PVRSRV_ERROR IterateOverChildren(
+				struct PVRSRV_HANDLE_BASE *psBase,
+				struct sHandle *psParent,
+				enum PVRSRV_ERROR(*pfnIterFunc)
+				(struct PVRSRV_HANDLE_BASE *, struct sHandle *))
 {
 	return HandleListIterate(psBase, &psParent->sChildren,
 				 offsetof(struct sHandle, sChildren),
@@ -364,34 +348,33 @@
 				 pfnIterFunc);
 }
 
-static INLINE
-    PVRSRV_ERROR GetHandleStructure(PVRSRV_HANDLE_BASE * psBase,
+static inline enum PVRSRV_ERROR GetHandleStructure(
+				    struct PVRSRV_HANDLE_BASE *psBase,
 				    struct sHandle **ppsHandle,
-				    IMG_HANDLE hHandle,
-				    PVRSRV_HANDLE_TYPE eType)
+				    void *hHandle,
+				    enum PVRSRV_HANDLE_TYPE eType)
 {
-	IMG_UINT32 ui32Index = HANDLE_TO_INDEX(psBase, hHandle);
+	u32 ui32Index = HANDLE_TO_INDEX(psBase, hHandle);
 	struct sHandle *psHandle;
 
 	if (!INDEX_IS_VALID(psBase, ui32Index)) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "GetHandleStructure: Handle index out of range (%u >= %u)",
-			 ui32Index, psBase->ui32TotalHandCount));
+		PVR_DPF(PVR_DBG_ERROR, "GetHandleStructure: "
+			 "Handle index out of range (%u >= %u)",
+			 ui32Index, psBase->ui32TotalHandCount);
 		return PVRSRV_ERROR_GENERIC;
 	}
 
 	psHandle = INDEX_TO_HANDLE_PTR(psBase, ui32Index);
 	if (psHandle->eType == PVRSRV_HANDLE_TYPE_NONE) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "GetHandleStructure: Handle not allocated (index: %u)",
-			 ui32Index));
+		PVR_DPF(PVR_DBG_ERROR, "GetHandleStructure: "
+			 "Handle not allocated (index: %u)", ui32Index);
 		return PVRSRV_ERROR_GENERIC;
 	}
 
 	if (eType != PVRSRV_HANDLE_TYPE_NONE && eType != psHandle->eType) {
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "GetHandleStructure: Handle type mismatch (%d != %d)",
-			 eType, psHandle->eType));
+			 eType, psHandle->eType);
 		return PVRSRV_ERROR_GENERIC;
 	}
 
@@ -402,53 +385,44 @@
 	return PVRSRV_OK;
 }
 
-static INLINE IMG_HANDLE ParentIfPrivate(struct sHandle *psHandle)
+static inline void *ParentIfPrivate(struct sHandle *psHandle)
 {
 	return TEST_ALLOC_FLAG(psHandle, PVRSRV_HANDLE_ALLOC_FLAG_PRIVATE) ?
-	    ParentHandle(psHandle) : IMG_NULL;
+		ParentHandle(psHandle) : NULL;
 }
 
-static INLINE
-    IMG_VOID InitKey(HAND_KEY aKey, PVRSRV_HANDLE_BASE * psBase,
-		     IMG_VOID * pvData, PVRSRV_HANDLE_TYPE eType,
-		     IMG_HANDLE hParent)
+static inline void InitKey(HAND_KEY aKey, struct PVRSRV_HANDLE_BASE *psBase,
+		     void *pvData, enum PVRSRV_HANDLE_TYPE eType,
+		     void *hParent)
 {
 	PVR_UNREFERENCED_PARAMETER(psBase);
 
-	aKey[HAND_KEY_DATA] = (IMG_UINTPTR_T) pvData;
-	aKey[HAND_KEY_TYPE] = (IMG_UINTPTR_T) eType;
-	aKey[HAND_KEY_PARENT] = (IMG_UINTPTR_T) hParent;
+	aKey[HAND_KEY_DATA] = (u32) pvData;
+	aKey[HAND_KEY_TYPE] = (u32) eType;
+	aKey[HAND_KEY_PARENT] = (u32) hParent;
 }
 
-static PVRSRV_ERROR FreeHandleArray(PVRSRV_HANDLE_BASE * psBase)
+static void FreeHandleArray(struct PVRSRV_HANDLE_BASE *psBase)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
-	if (psBase->psHandleArray != IMG_NULL) {
-		eError = OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-				   psBase->ui32TotalHandCount *
-				   sizeof(struct sHandle),
-				   psBase->psHandleArray,
-				   psBase->hHandBlockAlloc);
+	if (psBase->psHandleArray != NULL) {
+		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+			   psBase->ui32TotalHandCount *
+			   sizeof(struct sHandle),
+			   psBase->psHandleArray,
+			   psBase->hHandBlockAlloc);
 
-		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "FreeHandleArray: Error freeing memory (%d)",
-				 eError));
-		} else {
-			psBase->psHandleArray = IMG_NULL;
-		}
+		psBase->psHandleArray = NULL;
 	}
-
-	return eError;
 }
 
-static PVRSRV_ERROR FreeHandle(PVRSRV_HANDLE_BASE * psBase,
+static enum PVRSRV_ERROR FreeHandle(struct PVRSRV_HANDLE_BASE *psBase,
 			       struct sHandle *psHandle)
 {
 	HAND_KEY aKey;
-	IMG_UINT32 ui32Index = HANDLE_PTR_TO_INDEX(psBase, psHandle);
-	PVRSRV_ERROR eError;
+	u32 ui32Index = HANDLE_PTR_TO_INDEX(psBase, psHandle);
+	enum PVRSRV_ERROR eError;
 
 	PVR_ASSERT(psBase->ui32PID == psHandle->ui32PID);
 
@@ -457,11 +431,11 @@
 
 	if (!TEST_ALLOC_FLAG(psHandle, PVRSRV_HANDLE_ALLOC_FLAG_MULTI)
 	    && !BATCHED_HANDLE_PARTIALLY_FREE(psHandle)) {
-		IMG_HANDLE hHandle;
+		void *hHandle;
 		hHandle =
-		    (IMG_HANDLE) HASH_Remove_Extended(psBase->psHashTab, aKey);
+		    (void *) HASH_Remove_Extended(psBase->psHashTab, aKey);
 
-		PVR_ASSERT(hHandle != IMG_NULL);
+		PVR_ASSERT(hHandle != NULL);
 		PVR_ASSERT(hHandle == INDEX_TO_HANDLE(psBase, ui32Index));
 		PVR_UNREFERENCED_PARAMETER(hHandle);
 	}
@@ -470,9 +444,9 @@
 
 	eError = IterateOverChildren(psBase, psHandle, FreeHandle);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "FreeHandle: Error whilst freeing subhandles (%d)",
-			 eError));
+			 eError);
 		return eError;
 	}
 
@@ -512,14 +486,13 @@
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR FreeAllHandles(PVRSRV_HANDLE_BASE * psBase)
+static enum PVRSRV_ERROR FreeAllHandles(struct PVRSRV_HANDLE_BASE *psBase)
 {
-	IMG_UINT32 i;
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	u32 i;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
-	if (psBase->ui32FreeHandCount == psBase->ui32TotalHandCount) {
+	if (psBase->ui32FreeHandCount == psBase->ui32TotalHandCount)
 		return eError;
-	}
 
 	for (i = 0; i < psBase->ui32TotalHandCount; i++) {
 		struct sHandle *psHandle;
@@ -529,67 +502,52 @@
 		if (psHandle->eType != PVRSRV_HANDLE_TYPE_NONE) {
 			eError = FreeHandle(psBase, psHandle);
 			if (eError != PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "FreeAllHandles: FreeHandle failed (%d)",
-					 eError));
+				PVR_DPF(PVR_DBG_ERROR,
+				       "FreeAllHandles: FreeHandle failed (%d)",
+					eError);
 				break;
 			}
 
 			if (psBase->ui32FreeHandCount ==
-			    psBase->ui32TotalHandCount) {
+			    psBase->ui32TotalHandCount)
 				break;
-			}
 		}
 	}
 
 	return eError;
 }
 
-static PVRSRV_ERROR FreeHandleBase(PVRSRV_HANDLE_BASE * psBase)
+static enum PVRSRV_ERROR FreeHandleBase(struct PVRSRV_HANDLE_BASE *psBase)
 {
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
 	if (HANDLES_BATCHED(psBase)) {
-		PVR_DPF((PVR_DBG_WARNING,
-			 "FreeHandleBase: Uncommitted/Unreleased handle batch"));
+		PVR_DPF(PVR_DBG_WARNING,
+			"FreeHandleBase: Uncommitted/Unreleased handle batch");
 		PVRSRVReleaseHandleBatch(psBase);
 	}
 
 	eError = FreeAllHandles(psBase);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "FreeHandleBase: Couldn't free handles (%d)", eError));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "FreeHandleBase: Couldn't free handles (%d)", eError);
 		return eError;
 	}
 
-	eError = FreeHandleArray(psBase);
-	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "FreeHandleBase: Couldn't free handle array (%d)",
-			 eError));
-		return eError;
-	}
+	FreeHandleArray(psBase);
 
-	if (psBase->psHashTab != IMG_NULL) {
+	if (psBase->psHashTab != NULL)
 
 		HASH_Delete(psBase->psHashTab);
-	}
 
-	eError = OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+	OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 			   sizeof(*psBase), psBase, psBase->hBaseBlockAlloc);
-	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "FreeHandleBase: Couldn't free handle base (%d)",
-			 eError));
-		return eError;
-	}
 
 	return PVRSRV_OK;
 }
 
-static INLINE
-    IMG_HANDLE FindHandle(PVRSRV_HANDLE_BASE * psBase, IMG_VOID * pvData,
-			  PVRSRV_HANDLE_TYPE eType, IMG_HANDLE hParent)
+static inline void *FindHandle(struct PVRSRV_HANDLE_BASE *psBase, void *pvData,
+			  enum PVRSRV_HANDLE_TYPE eType, void *hParent)
 {
 	HAND_KEY aKey;
 
@@ -597,34 +555,35 @@
 
 	InitKey(aKey, psBase, pvData, eType, hParent);
 
-	return (IMG_HANDLE) HASH_Retrieve_Extended(psBase->psHashTab, aKey);
+	return (void *)HASH_Retrieve_Extended(psBase->psHashTab, aKey);
 }
 
-static PVRSRV_ERROR IncreaseHandleArraySize(PVRSRV_HANDLE_BASE * psBase,
-					    IMG_UINT32 ui32Delta)
+static enum PVRSRV_ERROR IncreaseHandleArraySize(
+					    struct PVRSRV_HANDLE_BASE *psBase,
+					    u32 ui32Delta)
 {
 	struct sHandle *psNewHandleArray;
-	IMG_HANDLE hNewHandBlockAlloc;
-	PVRSRV_ERROR eError;
+	void *hNewHandBlockAlloc;
+	enum PVRSRV_ERROR eError;
 	struct sHandle *psHandle;
-	IMG_UINT32 ui32DeltaRounded =
+	u32 ui32DeltaRounded =
 	    ROUND_UP_TO_MULTIPLE(ui32Delta, HANDLE_BLOCK_SIZE);
-	IMG_UINT32 ui32NewTotalHandCount =
+	u32 ui32NewTotalHandCount =
 	    psBase->ui32TotalHandCount + ui32DeltaRounded;
 	;
 
 	eError = OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 			    ui32NewTotalHandCount * sizeof(struct sHandle),
-			    (IMG_PVOID *) & psNewHandleArray,
+			    (void **) &psNewHandleArray,
 			    &hNewHandBlockAlloc);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "IncreaseHandleArraySize: Couldn't allocate new handle array (%d)",
-			 eError));
+		PVR_DPF(PVR_DBG_ERROR, "IncreaseHandleArraySize: "
+				"Couldn't allocate new handle array (%d)",
+			 eError);
 		return eError;
 	}
 
-	if (psBase->psHandleArray != IMG_NULL)
+	if (psBase->psHandleArray != NULL)
 		OSMemCopy(psNewHandleArray,
 			  psBase->psHandleArray,
 			  psBase->ui32TotalHandCount * sizeof(struct sHandle));
@@ -635,10 +594,7 @@
 		psHandle->ui32NextIndexPlusOne = 0;
 	}
 
-	eError = FreeHandleArray(psBase);
-	if (eError != PVRSRV_OK) {
-		return eError;
-	}
+	FreeHandleArray(psBase);
 
 	psBase->psHandleArray = psNewHandleArray;
 	psBase->hHandBlockAlloc = hNewHandBlockAlloc;
@@ -650,7 +606,7 @@
 
 		psBase->ui32FirstFreeIndex = psBase->ui32TotalHandCount;
 	} else {
-		PVR_ASSERT(psBase->ui32LastFreeIndexPlusOne != 0)
+		PVR_ASSERT(psBase->ui32LastFreeIndexPlusOne != 0);
 		    PVR_ASSERT(INDEX_TO_HANDLE_PTR
 			       (psBase,
 				psBase->ui32LastFreeIndexPlusOne -
@@ -669,19 +625,21 @@
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR EnsureFreeHandles(PVRSRV_HANDLE_BASE * psBase,
-				      IMG_UINT32 ui32Free)
+static enum PVRSRV_ERROR EnsureFreeHandles(struct PVRSRV_HANDLE_BASE *psBase,
+				      u32 ui32Free)
 {
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
 	if (ui32Free > psBase->ui32FreeHandCount) {
-		IMG_UINT32 ui32FreeHandDelta =
+		u32 ui32FreeHandDelta =
 		    ui32Free - psBase->ui32FreeHandCount;
 		eError = IncreaseHandleArraySize(psBase, ui32FreeHandDelta);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "EnsureFreeHandles: Couldn't allocate %u handles to ensure %u free handles (IncreaseHandleArraySize failed with error %d)",
-				 ui32FreeHandDelta, ui32Free, eError));
+			PVR_DPF(PVR_DBG_ERROR, "EnsureFreeHandles: "
+			       "Couldn't allocate %u handles "
+			       "to ensure %u free handles "
+			       "(IncreaseHandleArraySize failed with error %d)",
+				ui32FreeHandDelta, ui32Free, eError);
 
 			return eError;
 		}
@@ -690,41 +648,42 @@
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR AllocHandle(PVRSRV_HANDLE_BASE * psBase,
-				IMG_HANDLE * phHandle, IMG_VOID * pvData,
-				PVRSRV_HANDLE_TYPE eType,
-				PVRSRV_HANDLE_ALLOC_FLAG eFlag,
-				IMG_HANDLE hParent)
+static enum PVRSRV_ERROR AllocHandle(struct PVRSRV_HANDLE_BASE *psBase,
+				void **phHandle, void *pvData,
+				enum PVRSRV_HANDLE_TYPE eType,
+				enum PVRSRV_HANDLE_ALLOC_FLAG eFlag,
+				void *hParent)
 {
-	IMG_UINT32 ui32NewIndex;
+	u32 ui32NewIndex;
 	struct sHandle *psNewHandle;
-	IMG_HANDLE hHandle;
+	void *hHandle;
 	HAND_KEY aKey;
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
 	PVR_ASSERT(eType != PVRSRV_HANDLE_TYPE_NONE);
 
-	PVR_ASSERT(psBase->psHashTab != IMG_NULL);
+	PVR_ASSERT(psBase->psHashTab != NULL);
 
 	if (!TEST_FLAG(eFlag, PVRSRV_HANDLE_ALLOC_FLAG_MULTI)) {
 
 		PVR_ASSERT(FindHandle(psBase, pvData, eType, hParent) ==
-			   IMG_NULL);
+			   NULL);
 	}
 
 	if (psBase->ui32FreeHandCount == 0 && HANDLES_BATCHED(psBase)) {
-		PVR_DPF((PVR_DBG_WARNING,
-			 "AllocHandle: Handle batch size (%u) was too small, allocating additional space",
-			 psBase->ui32HandBatchSize));
+		PVR_DPF(PVR_DBG_WARNING, "AllocHandle: "
+			"Handle batch size (%u) was too small, "
+			"allocating additional space",
+			 psBase->ui32HandBatchSize);
 	}
 
 	eError = EnsureFreeHandles(psBase, 1);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "AllocHandle: EnsureFreeHandles failed (%d)", eError));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "AllocHandle: EnsureFreeHandles failed (%d)", eError);
 		return eError;
 	}
-	PVR_ASSERT(psBase->ui32FreeHandCount != 0)
+	PVR_ASSERT(psBase->ui32FreeHandCount != 0);
 
 	    ui32NewIndex = psBase->ui32FirstFreeIndex;
 
@@ -737,9 +696,9 @@
 		InitKey(aKey, psBase, pvData, eType, hParent);
 
 		if (!HASH_Insert_Extended
-		    (psBase->psHashTab, aKey, (IMG_UINTPTR_T) hHandle)) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "AllocHandle: Couldn't add handle to hash table"));
+		    (psBase->psHashTab, aKey, (u32) hHandle)) {
+			PVR_DPF(PVR_DBG_ERROR, "AllocHandle: "
+				"Couldn't add handle to hash table");
 
 			return PVRSRV_ERROR_GENERIC;
 		}
@@ -792,35 +751,34 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PVRSRVAllocHandle(PVRSRV_HANDLE_BASE * psBase,
-			       IMG_HANDLE * phHandle, IMG_VOID * pvData,
-			       PVRSRV_HANDLE_TYPE eType,
-			       PVRSRV_HANDLE_ALLOC_FLAG eFlag)
+enum PVRSRV_ERROR PVRSRVAllocHandle(struct PVRSRV_HANDLE_BASE *psBase,
+			       void **phHandle, void *pvData,
+			       enum PVRSRV_HANDLE_TYPE eType,
+			       enum PVRSRV_HANDLE_ALLOC_FLAG eFlag)
 {
-	IMG_HANDLE hHandle;
-	PVRSRV_ERROR eError;
+	void *hHandle;
+	enum PVRSRV_ERROR eError;
 
-	*phHandle = IMG_NULL;
+	*phHandle = NULL;
 
-	if (HANDLES_BATCHED(psBase)) {
+	if (HANDLES_BATCHED(psBase))
 
 		psBase->ui32BatchHandAllocFailures++;
-	}
 
 	PVR_ASSERT(eType != PVRSRV_HANDLE_TYPE_NONE);
 
 	if (!TEST_FLAG(eFlag, PVRSRV_HANDLE_ALLOC_FLAG_MULTI)) {
 
-		hHandle = FindHandle(psBase, pvData, eType, IMG_NULL);
-		if (hHandle != IMG_NULL) {
+		hHandle = FindHandle(psBase, pvData, eType, NULL);
+		if (hHandle != NULL) {
 			struct sHandle *psHandle;
 
 			eError =
 			    GetHandleStructure(psBase, &psHandle, hHandle,
 					       eType);
 			if (eError != PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "PVRSRVAllocHandle: Lookup of existing handle failed"));
+				PVR_DPF(PVR_DBG_ERROR, "PVRSRVAllocHandle: "
+					  "Lookup of existing handle failed");
 				return eError;
 			}
 
@@ -835,64 +793,61 @@
 		}
 	}
 
-	eError = AllocHandle(psBase, phHandle, pvData, eType, eFlag, IMG_NULL);
+	eError = AllocHandle(psBase, phHandle, pvData, eType, eFlag, NULL);
 
 exit_ok:
-	if (HANDLES_BATCHED(psBase) && (eError == PVRSRV_OK)) {
+	if (HANDLES_BATCHED(psBase) && (eError == PVRSRV_OK))
 		psBase->ui32BatchHandAllocFailures--;
-	}
 
 	return eError;
 }
 
-PVRSRV_ERROR PVRSRVAllocSubHandle(PVRSRV_HANDLE_BASE * psBase,
-				  IMG_HANDLE * phHandle, IMG_VOID * pvData,
-				  PVRSRV_HANDLE_TYPE eType,
-				  PVRSRV_HANDLE_ALLOC_FLAG eFlag,
-				  IMG_HANDLE hParent)
+enum PVRSRV_ERROR PVRSRVAllocSubHandle(struct PVRSRV_HANDLE_BASE *psBase,
+				  void **phHandle, void *pvData,
+				  enum PVRSRV_HANDLE_TYPE eType,
+				  enum PVRSRV_HANDLE_ALLOC_FLAG eFlag,
+				  void *hParent)
 {
 	struct sHandle *psPHand;
 	struct sHandle *psCHand;
-	PVRSRV_ERROR eError;
-	IMG_HANDLE hParentKey;
-	IMG_HANDLE hHandle;
+	enum PVRSRV_ERROR eError;
+	void *hParentKey;
+	void *hHandle;
 
-	*phHandle = IMG_NULL;
+	*phHandle = NULL;
 
-	if (HANDLES_BATCHED(psBase)) {
+	if (HANDLES_BATCHED(psBase))
 
 		psBase->ui32BatchHandAllocFailures++;
-	}
 
 	PVR_ASSERT(eType != PVRSRV_HANDLE_TYPE_NONE);
 
 	hParentKey = TEST_FLAG(eFlag, PVRSRV_HANDLE_ALLOC_FLAG_PRIVATE) ?
-	    hParent : IMG_NULL;
+	    hParent : NULL;
 
 	eError =
 	    GetHandleStructure(psBase, &psPHand, hParent,
 			       PVRSRV_HANDLE_TYPE_NONE);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return PVRSRV_ERROR_GENERIC;
-	}
 
 	if (!TEST_FLAG(eFlag, PVRSRV_HANDLE_ALLOC_FLAG_MULTI)) {
 
 		hHandle = FindHandle(psBase, pvData, eType, hParentKey);
-		if (hHandle != IMG_NULL) {
+		if (hHandle != NULL) {
 			struct sHandle *psCHandle;
-			PVRSRV_ERROR eErr;
+			enum PVRSRV_ERROR eErr;
 
 			eErr =
 			    GetHandleStructure(psBase, &psCHandle, hHandle,
 					       eType);
 			if (eErr != PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "PVRSRVAllocSubHandle: Lookup of existing handle failed"));
+				PVR_DPF(PVR_DBG_ERROR, "PVRSRVAllocSubHandle: "
+					"Lookup of existing handle failed");
 				return eErr;
 			}
 
-			PVR_ASSERT(hParentKey != IMG_NULL
+			PVR_ASSERT(hParentKey != NULL
 				   &&
 				   ParentHandle(HANDLE_TO_HANDLE_PTR
 						(psBase, hHandle)) == hParent);
@@ -912,9 +867,8 @@
 
 	eError =
 	    AllocHandle(psBase, &hHandle, pvData, eType, eFlag, hParentKey);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	psPHand = HANDLE_TO_HANDLE_PTR(psBase, hParent);
 
@@ -925,25 +879,24 @@
 	*phHandle = hHandle;
 
 exit_ok:
-	if (HANDLES_BATCHED(psBase)) {
+	if (HANDLES_BATCHED(psBase))
 		psBase->ui32BatchHandAllocFailures--;
-	}
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PVRSRVFindHandle(PVRSRV_HANDLE_BASE * psBase,
-			      IMG_HANDLE * phHandle, IMG_VOID * pvData,
-			      PVRSRV_HANDLE_TYPE eType)
+enum PVRSRV_ERROR PVRSRVFindHandle(struct PVRSRV_HANDLE_BASE *psBase,
+			      void **phHandle, void *pvData,
+			      enum PVRSRV_HANDLE_TYPE eType)
 {
-	IMG_HANDLE hHandle;
+	void *hHandle;
 
 	PVR_ASSERT(eType != PVRSRV_HANDLE_TYPE_NONE);
 
-	hHandle = (IMG_HANDLE) FindHandle(psBase, pvData, eType, IMG_NULL);
-	if (hHandle == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVFindHandle: couldn't find handle"));
+	hHandle = (void *) FindHandle(psBase, pvData, eType, NULL);
+	if (hHandle == NULL) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVFindHandle: couldn't find handle");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
@@ -952,21 +905,21 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PVRSRVLookupHandleAnyType(PVRSRV_HANDLE_BASE * psBase,
-				       IMG_PVOID * ppvData,
-				       PVRSRV_HANDLE_TYPE * peType,
-				       IMG_HANDLE hHandle)
+enum PVRSRV_ERROR PVRSRVLookupHandleAnyType(struct PVRSRV_HANDLE_BASE *psBase,
+				       void **ppvData,
+				       enum PVRSRV_HANDLE_TYPE *peType,
+				       void *hHandle)
 {
 	struct sHandle *psHandle;
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
 	eError =
 	    GetHandleStructure(psBase, &psHandle, hHandle,
 			       PVRSRV_HANDLE_TYPE_NONE);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVLookupHandleAnyType: Error looking up handle (%d)",
-			 eError));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVLookupHandleAnyType: "
+					"Error looking up handle (%d)",
+					eError);
 		return eError;
 	}
 
@@ -976,20 +929,20 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PVRSRVLookupHandle(PVRSRV_HANDLE_BASE * psBase,
-				IMG_PVOID * ppvData, IMG_HANDLE hHandle,
-				PVRSRV_HANDLE_TYPE eType)
+enum PVRSRV_ERROR PVRSRVLookupHandle(struct PVRSRV_HANDLE_BASE *psBase,
+				void **ppvData, void *hHandle,
+				enum PVRSRV_HANDLE_TYPE eType)
 {
 	struct sHandle *psHandle;
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
 	PVR_ASSERT(eType != PVRSRV_HANDLE_TYPE_NONE);
 
 	eError = GetHandleStructure(psBase, &psHandle, hHandle, eType);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "PVRSRVLookupHandle: Error looking up handle (%d)",
-			 eError));
+			 eError);
 		return eError;
 	}
 
@@ -998,22 +951,22 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PVRSRVLookupSubHandle(PVRSRV_HANDLE_BASE * psBase,
-				   IMG_PVOID * ppvData, IMG_HANDLE hHandle,
-				   PVRSRV_HANDLE_TYPE eType,
-				   IMG_HANDLE hAncestor)
+enum PVRSRV_ERROR PVRSRVLookupSubHandle(struct PVRSRV_HANDLE_BASE *psBase,
+				   void **ppvData, void *hHandle,
+				   enum PVRSRV_HANDLE_TYPE eType,
+				   void *hAncestor)
 {
 	struct sHandle *psPHand;
 	struct sHandle *psCHand;
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
 	PVR_ASSERT(eType != PVRSRV_HANDLE_TYPE_NONE);
 
 	eError = GetHandleStructure(psBase, &psCHand, hHandle, eType);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVLookupSubHandle: Error looking up subhandle (%d)",
-			 eError));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVLookupSubHandle: "
+			"Error looking up subhandle (%d)",
+			 eError);
 		return eError;
 	}
 
@@ -1022,8 +975,8 @@
 		    GetHandleStructure(psBase, &psPHand, ParentHandle(psPHand),
 				       PVRSRV_HANDLE_TYPE_NONE);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVLookupSubHandle: Subhandle doesn't belong to given ancestor"));
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVLookupSubHandle: "
+				"Subhandle doesn't belong to given ancestor");
 			return PVRSRV_ERROR_GENERIC;
 		}
 	}
@@ -1033,20 +986,20 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PVRSRVGetParentHandle(PVRSRV_HANDLE_BASE * psBase,
-				   IMG_PVOID * phParent, IMG_HANDLE hHandle,
-				   PVRSRV_HANDLE_TYPE eType)
+enum PVRSRV_ERROR PVRSRVGetParentHandle(struct PVRSRV_HANDLE_BASE *psBase,
+				   void **phParent, void *hHandle,
+				   enum PVRSRV_HANDLE_TYPE eType)
 {
 	struct sHandle *psHandle;
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
 	PVR_ASSERT(eType != PVRSRV_HANDLE_TYPE_NONE);
 
 	eError = GetHandleStructure(psBase, &psHandle, hHandle, eType);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVGetParentHandle: Error looking up subhandle (%d)",
-			 eError));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVGetParentHandle: "
+					"Error looking up subhandle (%d)",
+			 eError);
 		return eError;
 	}
 
@@ -1055,21 +1008,21 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PVRSRVLookupAndReleaseHandle(PVRSRV_HANDLE_BASE * psBase,
-					  IMG_PVOID * ppvData,
-					  IMG_HANDLE hHandle,
-					  PVRSRV_HANDLE_TYPE eType)
+enum PVRSRV_ERROR PVRSRVLookupAndReleaseHandle(
+				struct PVRSRV_HANDLE_BASE *psBase,
+				void **ppvData, void *hHandle,
+				enum PVRSRV_HANDLE_TYPE eType)
 {
 	struct sHandle *psHandle;
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
 	PVR_ASSERT(eType != PVRSRV_HANDLE_TYPE_NONE);
 
 	eError = GetHandleStructure(psBase, &psHandle, hHandle, eType);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVLookupAndReleaseHandle: Error looking up handle (%d)",
-			 eError));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVLookupAndReleaseHandle: "
+			"Error looking up handle (%d)",
+			 eError);
 		return eError;
 	}
 
@@ -1080,19 +1033,19 @@
 	return eError;
 }
 
-PVRSRV_ERROR PVRSRVReleaseHandle(PVRSRV_HANDLE_BASE * psBase,
-				 IMG_HANDLE hHandle, PVRSRV_HANDLE_TYPE eType)
+enum PVRSRV_ERROR PVRSRVReleaseHandle(struct PVRSRV_HANDLE_BASE *psBase,
+				 void *hHandle, enum PVRSRV_HANDLE_TYPE eType)
 {
 	struct sHandle *psHandle;
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
 	PVR_ASSERT(eType != PVRSRV_HANDLE_TYPE_NONE);
 
 	eError = GetHandleStructure(psBase, &psHandle, hHandle, eType);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "PVRSRVReleaseHandle: Error looking up handle (%d)",
-			 eError));
+			 eError);
 		return eError;
 	}
 
@@ -1101,65 +1054,60 @@
 	return eError;
 }
 
-PVRSRV_ERROR PVRSRVNewHandleBatch(PVRSRV_HANDLE_BASE * psBase,
-				  IMG_UINT32 ui32BatchSize)
+enum PVRSRV_ERROR PVRSRVNewHandleBatch(struct PVRSRV_HANDLE_BASE *psBase,
+				  u32 ui32BatchSize)
 {
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
 	if (HANDLES_BATCHED(psBase)) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVNewHandleBatch: There is a handle batch already in use (size %u)",
-			 psBase->ui32HandBatchSize));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVNewHandleBatch: "
+			"There is a handle batch already in use (size %u)",
+			 psBase->ui32HandBatchSize);
 		return PVRSRV_ERROR_GENERIC;
 	}
 
 	if (ui32BatchSize == 0) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVNewHandleBatch: Invalid batch size (%u)",
-			 ui32BatchSize));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVNewHandleBatch: "
+			"Invalid batch size (%u)", ui32BatchSize);
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	eError = EnsureFreeHandles(psBase, ui32BatchSize);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVNewHandleBatch: EnsureFreeHandles failed (error %d)",
-			 eError));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVNewHandleBatch: "
+			 "EnsureFreeHandles failed (error %d)", eError);
 		return eError;
 	}
 
 	psBase->ui32HandBatchSize = ui32BatchSize;
-
 	psBase->ui32TotalHandCountPreBatch = psBase->ui32TotalHandCount;
 
 	PVR_ASSERT(psBase->ui32BatchHandAllocFailures == 0);
-
 	PVR_ASSERT(psBase->ui32FirstBatchIndexPlusOne == 0);
-
 	PVR_ASSERT(HANDLES_BATCHED(psBase));
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR PVRSRVHandleBatchCommitOrRelease(PVRSRV_HANDLE_BASE *
-						     psBase, IMG_BOOL bCommit)
+static enum PVRSRV_ERROR PVRSRVHandleBatchCommitOrRelease(
+			struct PVRSRV_HANDLE_BASE *psBase, IMG_BOOL bCommit)
 {
-
-	IMG_UINT32 ui32IndexPlusOne;
+	u32 ui32IndexPlusOne;
 	IMG_BOOL bCommitBatch = bCommit;
 
 	if (!HANDLES_BATCHED(psBase)) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVHandleBatchCommitOrRelease: There is no handle batch"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVHandleBatchCommitOrRelease: "
+					"There is no handle batch");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 
 	}
 
 	if (psBase->ui32BatchHandAllocFailures != 0) {
-		if (bCommit) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVHandleBatchCommitOrRelease: Attempting to commit batch with handle allocation failures."));
-		}
+		if (bCommit)
+			PVR_DPF(PVR_DBG_ERROR,
+				"PVRSRVHandleBatchCommitOrRelease: "
+				"Attempting to commit batch "
+				"with handle allocation failures.");
 		bCommitBatch = IMG_FALSE;
 	}
 
@@ -1169,25 +1117,23 @@
 	while (ui32IndexPlusOne != 0) {
 		struct sHandle *psHandle =
 		    INDEX_TO_HANDLE_PTR(psBase, ui32IndexPlusOne - 1);
-		IMG_UINT32 ui32NextIndexPlusOne =
+		u32 ui32NextIndexPlusOne =
 		    psHandle->ui32NextIndexPlusOne;
 		PVR_ASSERT(BATCHED_HANDLE(psHandle));
 
 		psHandle->ui32NextIndexPlusOne = 0;
 
 		if (!bCommitBatch || BATCHED_HANDLE_PARTIALLY_FREE(psHandle)) {
-			PVRSRV_ERROR eError;
+			enum PVRSRV_ERROR eError;
 
-			if (!BATCHED_HANDLE_PARTIALLY_FREE(psHandle)) {
+			if (!BATCHED_HANDLE_PARTIALLY_FREE(psHandle))
 				SET_UNBATCHED_HANDLE(psHandle);
-			}
 
 			eError = FreeHandle(psBase, psHandle);
-			if (eError != PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "PVRSRVHandleBatchCommitOrRelease: Error freeing handle (%d)",
-					 eError));
-			}
+			if (eError != PVRSRV_OK)
+				PVR_DPF(PVR_DBG_ERROR,
+					 "PVRSRVHandleBatchCommitOrRelease: "
+					 "Error freeing handle (%d)", eError);
 			PVR_ASSERT(eError == PVRSRV_OK);
 		} else {
 			SET_UNBATCHED_HANDLE(psHandle);
@@ -1198,17 +1144,19 @@
 
 #ifdef DEBUG
 	if (psBase->ui32TotalHandCountPreBatch != psBase->ui32TotalHandCount) {
-		IMG_UINT32 ui32Delta =
+		u32 ui32Delta =
 		    psBase->ui32TotalHandCount -
 		    psBase->ui32TotalHandCountPreBatch;
 
 		PVR_ASSERT(psBase->ui32TotalHandCount >
 			   psBase->ui32TotalHandCountPreBatch);
 
-		PVR_DPF((PVR_DBG_WARNING,
-			 "PVRSRVHandleBatchCommitOrRelease: The batch size was too small.  Batch size was %u, but needs to be %u",
+		PVR_DPF(PVR_DBG_WARNING,
+			 "PVRSRVHandleBatchCommitOrRelease: "
+			 "The batch size was too small.  "
+			 "Batch size was %u, but needs to be %u",
 			 psBase->ui32HandBatchSize,
-			 psBase->ui32HandBatchSize + ui32Delta));
+			 psBase->ui32HandBatchSize + ui32Delta);
 
 	}
 #endif
@@ -1227,30 +1175,30 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PVRSRVCommitHandleBatch(PVRSRV_HANDLE_BASE * psBase)
+enum PVRSRV_ERROR PVRSRVCommitHandleBatch(struct PVRSRV_HANDLE_BASE *psBase)
 {
 	return PVRSRVHandleBatchCommitOrRelease(psBase, IMG_TRUE);
 }
 
-void PVRSRVReleaseHandleBatch(PVRSRV_HANDLE_BASE * psBase)
+void PVRSRVReleaseHandleBatch(struct PVRSRV_HANDLE_BASE *psBase)
 {
 	(void)PVRSRVHandleBatchCommitOrRelease(psBase, IMG_FALSE);
 }
 
-PVRSRV_ERROR PVRSRVAllocHandleBase(PVRSRV_HANDLE_BASE ** ppsBase,
-				   IMG_UINT32 ui32PID)
+enum PVRSRV_ERROR PVRSRVAllocHandleBase(struct PVRSRV_HANDLE_BASE **ppsBase,
+				   u32 ui32PID)
 {
-	PVRSRV_HANDLE_BASE *psBase;
-	IMG_HANDLE hBlockAlloc;
-	PVRSRV_ERROR eError;
+	struct PVRSRV_HANDLE_BASE *psBase;
+	void *hBlockAlloc;
+	enum PVRSRV_ERROR eError;
 
 	eError = OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 			    sizeof(*psBase),
-			    (IMG_PVOID *) & psBase, &hBlockAlloc);
+			    (void **) &psBase, &hBlockAlloc);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVAllocHandleBase: Couldn't allocate handle base (%d)",
-			 eError));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVAllocHandleBase: "
+			 "Couldn't allocate handle base (%d)",
+			 eError);
 		return eError;
 	}
 	OSMemSet(psBase, 0, sizeof(*psBase));
@@ -1258,9 +1206,9 @@
 	psBase->psHashTab =
 	    HASH_Create_Extended(HANDLE_HASH_TAB_INIT_SIZE, sizeof(HAND_KEY),
 				 HASH_Func_Default, HASH_Key_Comp_Default);
-	if (psBase->psHashTab == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVAllocHandleBase: Couldn't create data pointer hash table\n"));
+	if (psBase->psHashTab == NULL) {
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVAllocHandleBase: "
+			 "Couldn't create data pointer hash table\n");
 		goto failure;
 	}
 
@@ -1275,9 +1223,9 @@
 	return PVRSRV_ERROR_GENERIC;
 }
 
-PVRSRV_ERROR PVRSRVFreeHandleBase(PVRSRV_HANDLE_BASE * psBase)
+enum PVRSRV_ERROR PVRSRVFreeHandleBase(struct PVRSRV_HANDLE_BASE *psBase)
 {
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
 	PVR_ASSERT(psBase != gpsKernelHandleBase);
 
@@ -1286,26 +1234,25 @@
 	return eError;
 }
 
-PVRSRV_ERROR PVRSRVHandleInit(IMG_VOID)
+enum PVRSRV_ERROR PVRSRVHandleInit(void)
 {
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
-	PVR_ASSERT(gpsKernelHandleBase == IMG_NULL);
+	PVR_ASSERT(gpsKernelHandleBase == NULL);
 
 	eError = PVRSRVAllocHandleBase(&gpsKernelHandleBase, KERNEL_ID);
 
 	return eError;
 }
 
-PVRSRV_ERROR PVRSRVHandleDeInit(IMG_VOID)
+enum PVRSRV_ERROR PVRSRVHandleDeInit(void)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
-	if (gpsKernelHandleBase != IMG_NULL) {
+	if (gpsKernelHandleBase != NULL) {
 		eError = FreeHandleBase(gpsKernelHandleBase);
-		if (eError == PVRSRV_OK) {
-			gpsKernelHandleBase = IMG_NULL;
-		}
+		if (eError == PVRSRV_OK)
+			gpsKernelHandleBase = NULL;
 	}
 
 	return eError;
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/handle.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/handle.h
@@ -1,145 +1,137 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef __HANDLE_H__
 #define __HANDLE_H__
 
-
 #include "img_types.h"
 #include "hash.h"
 #include "resman.h"
 
-	typedef enum {
-		PVRSRV_HANDLE_TYPE_NONE = 0,
-		PVRSRV_HANDLE_TYPE_PERPROC_DATA,
-		PVRSRV_HANDLE_TYPE_DEV_NODE,
-		PVRSRV_HANDLE_TYPE_DEV_MEM_CONTEXT,
-		PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP,
-		PVRSRV_HANDLE_TYPE_MEM_INFO,
-		PVRSRV_HANDLE_TYPE_SYNC_INFO,
-		PVRSRV_HANDLE_TYPE_DISP_INFO,
-		PVRSRV_HANDLE_TYPE_DISP_SWAP_CHAIN,
-		PVRSRV_HANDLE_TYPE_BUF_INFO,
-		PVRSRV_HANDLE_TYPE_DISP_BUFFER,
-		PVRSRV_HANDLE_TYPE_BUF_BUFFER,
-		PVRSRV_HANDLE_TYPE_SGX_HW_RENDER_CONTEXT,
-		PVRSRV_HANDLE_TYPE_SGX_HW_TRANSFER_CONTEXT,
-		PVRSRV_HANDLE_TYPE_SGX_HW_2D_CONTEXT,
-		PVRSRV_HANDLE_TYPE_SHARED_PB_DESC,
-		PVRSRV_HANDLE_TYPE_MEM_INFO_REF,
-		PVRSRV_HANDLE_TYPE_SHARED_SYS_MEM_INFO,
-		PVRSRV_HANDLE_TYPE_SHARED_EVENT_OBJECT,
-		PVRSRV_HANDLE_TYPE_EVENT_OBJECT_CONNECT,
-	} PVRSRV_HANDLE_TYPE;
-
-	typedef enum {
-
-		PVRSRV_HANDLE_ALLOC_FLAG_NONE = 0,
-
-		PVRSRV_HANDLE_ALLOC_FLAG_SHARED = 1,
-
-		PVRSRV_HANDLE_ALLOC_FLAG_MULTI = 2,
+enum PVRSRV_HANDLE_TYPE {
+	PVRSRV_HANDLE_TYPE_NONE = 0,
+	PVRSRV_HANDLE_TYPE_PERPROC_DATA,
+	PVRSRV_HANDLE_TYPE_DEV_NODE,
+	PVRSRV_HANDLE_TYPE_DEV_MEM_CONTEXT,
+	PVRSRV_HANDLE_TYPE_DEV_MEM_HEAP,
+	PVRSRV_HANDLE_TYPE_MEM_INFO,
+	PVRSRV_HANDLE_TYPE_SYNC_INFO,
+	PVRSRV_HANDLE_TYPE_DISP_INFO,
+	PVRSRV_HANDLE_TYPE_DISP_SWAP_CHAIN,
+	PVRSRV_HANDLE_TYPE_BUF_INFO,
+	PVRSRV_HANDLE_TYPE_DISP_BUFFER,
+	PVRSRV_HANDLE_TYPE_BUF_BUFFER,
+	PVRSRV_HANDLE_TYPE_SGX_HW_RENDER_CONTEXT,
+	PVRSRV_HANDLE_TYPE_SGX_HW_TRANSFER_CONTEXT,
+	PVRSRV_HANDLE_TYPE_SGX_HW_2D_CONTEXT,
+	PVRSRV_HANDLE_TYPE_SHARED_PB_DESC,
+	PVRSRV_HANDLE_TYPE_MEM_INFO_REF,
+	PVRSRV_HANDLE_TYPE_SHARED_SYS_MEM_INFO,
+	PVRSRV_HANDLE_TYPE_SHARED_EVENT_OBJECT,
+	PVRSRV_HANDLE_TYPE_EVENT_OBJECT_CONNECT,
+};
+
+enum PVRSRV_HANDLE_ALLOC_FLAG {
+	PVRSRV_HANDLE_ALLOC_FLAG_NONE = 0,
+	PVRSRV_HANDLE_ALLOC_FLAG_SHARED = 1,
+	PVRSRV_HANDLE_ALLOC_FLAG_MULTI = 2,
+	PVRSRV_HANDLE_ALLOC_FLAG_PRIVATE = 4
+};
 
-		PVRSRV_HANDLE_ALLOC_FLAG_PRIVATE = 4
-	} PVRSRV_HANDLE_ALLOC_FLAG;
+struct PVRSRV_HANDLE_BASE;
+struct PVRSRV_HANDLE_BASE;
 
-	struct _PVRSRV_HANDLE_BASE_;
-	typedef struct _PVRSRV_HANDLE_BASE_ PVRSRV_HANDLE_BASE;
-
-	extern PVRSRV_HANDLE_BASE *gpsKernelHandleBase;
+extern struct PVRSRV_HANDLE_BASE *gpsKernelHandleBase;
 
 #define	KERNEL_HANDLE_BASE (gpsKernelHandleBase)
 
-	PVRSRV_ERROR PVRSRVAllocHandle(PVRSRV_HANDLE_BASE * psBase,
-				       IMG_HANDLE * phHandle, IMG_VOID * pvData,
-				       PVRSRV_HANDLE_TYPE eType,
-				       PVRSRV_HANDLE_ALLOC_FLAG eFlag);
-
-	PVRSRV_ERROR PVRSRVAllocSubHandle(PVRSRV_HANDLE_BASE * psBase,
-					  IMG_HANDLE * phHandle,
-					  IMG_VOID * pvData,
-					  PVRSRV_HANDLE_TYPE eType,
-					  PVRSRV_HANDLE_ALLOC_FLAG eFlag,
-					  IMG_HANDLE hParent);
-
-	PVRSRV_ERROR PVRSRVFindHandle(PVRSRV_HANDLE_BASE * psBase,
-				      IMG_HANDLE * phHandle, IMG_VOID * pvData,
-				      PVRSRV_HANDLE_TYPE eType);
-
-	PVRSRV_ERROR PVRSRVLookupHandleAnyType(PVRSRV_HANDLE_BASE * psBase,
-					       IMG_PVOID * ppvData,
-					       PVRSRV_HANDLE_TYPE * peType,
-					       IMG_HANDLE hHandle);
-
-	PVRSRV_ERROR PVRSRVLookupHandle(PVRSRV_HANDLE_BASE * psBase,
-					IMG_PVOID * ppvData, IMG_HANDLE hHandle,
-					PVRSRV_HANDLE_TYPE eType);
-
-	PVRSRV_ERROR PVRSRVLookupSubHandle(PVRSRV_HANDLE_BASE * psBase,
-					   IMG_PVOID * ppvData,
-					   IMG_HANDLE hHandle,
-					   PVRSRV_HANDLE_TYPE eType,
-					   IMG_HANDLE hAncestor);
-
-	PVRSRV_ERROR PVRSRVGetParentHandle(PVRSRV_HANDLE_BASE * psBase,
-					   IMG_PVOID * phParent,
-					   IMG_HANDLE hHandle,
-					   PVRSRV_HANDLE_TYPE eType);
-
-	PVRSRV_ERROR PVRSRVLookupAndReleaseHandle(PVRSRV_HANDLE_BASE * psBase,
-						  IMG_PVOID * ppvData,
-						  IMG_HANDLE hHandle,
-						  PVRSRV_HANDLE_TYPE eType);
-
-	PVRSRV_ERROR PVRSRVReleaseHandle(PVRSRV_HANDLE_BASE * psBase,
-					 IMG_HANDLE hHandle,
-					 PVRSRV_HANDLE_TYPE eType);
-
-	PVRSRV_ERROR PVRSRVNewHandleBatch(PVRSRV_HANDLE_BASE * psBase,
-					  IMG_UINT32 ui32BatchSize);
-
-	PVRSRV_ERROR PVRSRVCommitHandleBatch(PVRSRV_HANDLE_BASE * psBase);
-
-	void PVRSRVReleaseHandleBatch(PVRSRV_HANDLE_BASE * psBase);
+enum PVRSRV_ERROR PVRSRVAllocHandle(struct PVRSRV_HANDLE_BASE *psBase,
+			       void **phHandle, void *pvData,
+			       enum PVRSRV_HANDLE_TYPE eType,
+			       enum PVRSRV_HANDLE_ALLOC_FLAG eFlag);
+
+enum PVRSRV_ERROR PVRSRVAllocSubHandle(struct PVRSRV_HANDLE_BASE *psBase,
+				  void **phHandle,
+				  void *pvData,
+				  enum PVRSRV_HANDLE_TYPE eType,
+				  enum PVRSRV_HANDLE_ALLOC_FLAG eFlag,
+				  void *hParent);
+
+enum PVRSRV_ERROR PVRSRVFindHandle(struct PVRSRV_HANDLE_BASE *psBase,
+			      void **phHandle, void *pvData,
+			      enum PVRSRV_HANDLE_TYPE eType);
+
+enum PVRSRV_ERROR PVRSRVLookupHandleAnyType(struct PVRSRV_HANDLE_BASE *psBase,
+				       void **ppvData,
+				       enum PVRSRV_HANDLE_TYPE *peType,
+				       void *hHandle);
+
+enum PVRSRV_ERROR PVRSRVLookupHandle(struct PVRSRV_HANDLE_BASE *psBase,
+				void **ppvData, void *hHandle,
+				enum PVRSRV_HANDLE_TYPE eType);
+
+enum PVRSRV_ERROR PVRSRVLookupSubHandle(struct PVRSRV_HANDLE_BASE *psBase,
+				void **ppvData, void *hHandle,
+				enum PVRSRV_HANDLE_TYPE eType, void *hAncestor);
+
+enum PVRSRV_ERROR PVRSRVGetParentHandle(struct PVRSRV_HANDLE_BASE *psBase,
+				void **phParent, void *hHandle,
+				enum PVRSRV_HANDLE_TYPE eType);
+
+enum PVRSRV_ERROR PVRSRVLookupAndReleaseHandle(
+				struct PVRSRV_HANDLE_BASE *psBase,
+				void **ppvData, void *hHandle,
+				enum PVRSRV_HANDLE_TYPE eType);
+
+enum PVRSRV_ERROR PVRSRVReleaseHandle(struct PVRSRV_HANDLE_BASE *psBase,
+				 void *hHandle,
+				 enum PVRSRV_HANDLE_TYPE eType);
+
+enum PVRSRV_ERROR PVRSRVNewHandleBatch(struct PVRSRV_HANDLE_BASE *psBase,
+				  u32 ui32BatchSize);
+
+enum PVRSRV_ERROR PVRSRVCommitHandleBatch(struct PVRSRV_HANDLE_BASE *psBase);
+
+void PVRSRVReleaseHandleBatch(struct PVRSRV_HANDLE_BASE *psBase);
 
-	PVRSRV_ERROR PVRSRVAllocHandleBase(PVRSRV_HANDLE_BASE ** ppsBase,
-					   IMG_UINT32 ui32PID);
+enum PVRSRV_ERROR PVRSRVAllocHandleBase(struct PVRSRV_HANDLE_BASE **ppsBase,
+				   u32 ui32PID);
 
-	PVRSRV_ERROR PVRSRVFreeHandleBase(PVRSRV_HANDLE_BASE * psBase);
+enum PVRSRV_ERROR PVRSRVFreeHandleBase(struct PVRSRV_HANDLE_BASE *psBase);
 
-	PVRSRV_ERROR PVRSRVHandleInit(IMG_VOID);
+enum PVRSRV_ERROR PVRSRVHandleInit(void);
 
-	PVRSRV_ERROR PVRSRVHandleDeInit(IMG_VOID);
+enum PVRSRV_ERROR PVRSRVHandleDeInit(void);
 
 
 #define PVRSRVAllocHandleNR(psBase, phHandle, pvData, eType, eFlag) \
-	(void)PVRSRVAllocHandle(psBase, phHandle, pvData, eType, eFlag)
+    (void)PVRSRVAllocHandle(psBase, phHandle, pvData, eType, eFlag)
 
-#define PVRSRVAllocSubHandleNR(psBase, phHandle, pvData, eType, eFlag, hParent) \
-	(void)PVRSRVAllocSubHandle(psBase, phHandle, pvData, eType, eFlag, hParent)
+#define PVRSRVAllocSubHandleNR(psBase, phHandle, pvData, eType, eFlag, hParent)\
+    (void)PVRSRVAllocSubHandle(psBase, phHandle, pvData, eType, eFlag, hParent)
 
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/hash.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/hash.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -31,7 +31,7 @@
 #include "hash.h"
 #include "osfunc.h"
 
-#define PRIVATE_MAX(a,b) ((a)>(b)?(a):(b))
+#define PRIVATE_MAX(a, b) ((a) > (b) ? (a) : (b))
 
 #define	KEY_TO_INDEX(pHash, key, uSize) \
 	((pHash)->pfnHashFunc((pHash)->uKeySize, key, uSize) % uSize)
@@ -39,47 +39,35 @@
 #define	KEY_COMPARE(pHash, pKey1, pKey2) \
 	((pHash)->pfnKeyComp((pHash)->uKeySize, pKey1, pKey2))
 
-struct _BUCKET_ {
-
-	struct _BUCKET_ *pNext;
-
-	IMG_UINTPTR_T v;
-
-	IMG_UINTPTR_T k[];
+struct BUCKET {
+	struct BUCKET *pNext;
+	u32 v;
+	u32 k[];
 };
-typedef struct _BUCKET_ BUCKET;
-
-struct _HASH_TABLE_ {
-
-	BUCKET **ppBucketTable;
-
-	IMG_UINT32 uSize;
-
-	IMG_UINT32 uCount;
-
-	IMG_UINT32 uMinimumSize;
-
-	IMG_UINT32 uKeySize;
 
+struct HASH_TABLE {
+	struct BUCKET **ppBucketTable;
+	u32 uSize;
+	u32 uCount;
+	u32 uMinimumSize;
+	u32 uKeySize;
 	HASH_FUNC *pfnHashFunc;
-
 	HASH_KEY_COMP *pfnKeyComp;
 };
 
-IMG_UINT32
-HASH_Func_Default(IMG_SIZE_T uKeySize, IMG_VOID * pKey, IMG_UINT32 uHashTabLen)
+u32 HASH_Func_Default(size_t uKeySize, void *pKey, u32 uHashTabLen)
 {
-	IMG_UINTPTR_T *p = (IMG_UINTPTR_T *) pKey;
-	IMG_UINT32 uKeyLen = uKeySize / sizeof(IMG_UINTPTR_T);
-	IMG_UINT32 ui;
-	IMG_UINT32 uHashKey = 0;
+	u32 *p = (u32 *) pKey;
+	u32 uKeyLen = uKeySize / sizeof(u32);
+	u32 ui;
+	u32 uHashKey = 0;
 
 	PVR_UNREFERENCED_PARAMETER(uHashTabLen);
 
-	PVR_ASSERT((uKeySize % sizeof(IMG_UINTPTR_T)) == 0);
+	PVR_ASSERT((uKeySize % sizeof(u32)) == 0);
 
 	for (ui = 0; ui < uKeyLen; ui++) {
-		IMG_UINT32 uHashPart = (IMG_UINT32) * p++;
+		u32 uHashPart = (u32) *p++;
 
 		uHashPart += (uHashPart << 12);
 		uHashPart ^= (uHashPart >> 22);
@@ -96,32 +84,29 @@
 	return uHashKey;
 }
 
-IMG_BOOL
-HASH_Key_Comp_Default(IMG_SIZE_T uKeySize, IMG_VOID * pKey1, IMG_VOID * pKey2)
+IMG_BOOL HASH_Key_Comp_Default(size_t uKeySize, void *pKey1, void *pKey2)
 {
-	IMG_UINTPTR_T *p1 = (IMG_UINTPTR_T *) pKey1;
-	IMG_UINTPTR_T *p2 = (IMG_UINTPTR_T *) pKey2;
-	IMG_UINT32 uKeyLen = uKeySize / sizeof(IMG_UINTPTR_T);
-	IMG_UINT32 ui;
+	u32 *p1 = (u32 *) pKey1;
+	u32 *p2 = (u32 *) pKey2;
+	u32 uKeyLen = uKeySize / sizeof(u32);
+	u32 ui;
 
-	PVR_ASSERT((uKeySize % sizeof(IMG_UINTPTR_T)) == 0);
+	PVR_ASSERT((uKeySize % sizeof(u32)) == 0);
 
-	for (ui = 0; ui < uKeyLen; ui++) {
+	for (ui = 0; ui < uKeyLen; ui++)
 		if (*p1++ != *p2++)
 			return IMG_FALSE;
-	}
 
 	return IMG_TRUE;
 }
 
-static void
-_ChainInsert(HASH_TABLE * pHash, BUCKET * pBucket, BUCKET ** ppBucketTable,
-	     IMG_UINT32 uSize)
+static void _ChainInsert(struct HASH_TABLE *pHash, struct BUCKET *pBucket,
+			 struct BUCKET **ppBucketTable, u32 uSize)
 {
-	IMG_UINT32 uIndex;
+	u32 uIndex;
 
-	PVR_ASSERT(pBucket != IMG_NULL);
-	PVR_ASSERT(ppBucketTable != IMG_NULL);
+	PVR_ASSERT(pBucket != NULL);
+	PVR_ASSERT(ppBucketTable != NULL);
 	PVR_ASSERT(uSize != 0);
 
 	uIndex = KEY_TO_INDEX(pHash, pBucket->k, uSize);
@@ -129,67 +114,64 @@
 	ppBucketTable[uIndex] = pBucket;
 }
 
-static void
-_Rehash(HASH_TABLE * pHash,
-	BUCKET ** ppOldTable, IMG_UINT32 uOldSize,
-	BUCKET ** ppNewTable, IMG_UINT32 uNewSize)
+static void _Rehash(struct HASH_TABLE *pHash, struct BUCKET **ppOldTable,
+		    u32 uOldSize, struct BUCKET **ppNewTable, u32 uNewSize)
 {
-	IMG_UINT32 uIndex;
+	u32 uIndex;
 	for (uIndex = 0; uIndex < uOldSize; uIndex++) {
-		BUCKET *pBucket;
+		struct BUCKET *pBucket;
 		pBucket = ppOldTable[uIndex];
-		while (pBucket != IMG_NULL) {
-			BUCKET *pNextBucket = pBucket->pNext;
+		while (pBucket != NULL) {
+			struct BUCKET *pNextBucket = pBucket->pNext;
 			_ChainInsert(pHash, pBucket, ppNewTable, uNewSize);
 			pBucket = pNextBucket;
 		}
 	}
 }
 
-static IMG_BOOL _Resize(HASH_TABLE * pHash, IMG_UINT32 uNewSize)
+static IMG_BOOL _Resize(struct HASH_TABLE *pHash, u32 uNewSize)
 {
 	if (uNewSize != pHash->uSize) {
-		BUCKET **ppNewTable;
-		IMG_UINT32 uIndex;
+		struct BUCKET **ppNewTable;
+		u32 uIndex;
 
-		PVR_DPF((PVR_DBG_MESSAGE,
+		PVR_DPF(PVR_DBG_MESSAGE,
 			 "HASH_Resize: oldsize=0x%x  newsize=0x%x  count=0x%x",
-			 pHash->uSize, uNewSize, pHash->uCount));
+			 pHash->uSize, uNewSize, pHash->uCount);
 
 		OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-			   sizeof(BUCKET *) * uNewSize,
-			   (IMG_PVOID *) & ppNewTable, IMG_NULL);
-		if (ppNewTable == IMG_NULL)
+			   sizeof(struct BUCKET *) * uNewSize,
+			   (void **) &ppNewTable, NULL);
+		if (ppNewTable == NULL)
 			return IMG_FALSE;
 
 		for (uIndex = 0; uIndex < uNewSize; uIndex++)
-			ppNewTable[uIndex] = IMG_NULL;
+			ppNewTable[uIndex] = NULL;
 		_Rehash(pHash, pHash->ppBucketTable, pHash->uSize, ppNewTable,
 			uNewSize);
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  sizeof(BUCKET *) * pHash->uSize, pHash->ppBucketTable,
-			  IMG_NULL);
+			  sizeof(struct BUCKET *) * pHash->uSize,
+			  pHash->ppBucketTable, NULL);
 		pHash->ppBucketTable = ppNewTable;
 		pHash->uSize = uNewSize;
 	}
 	return IMG_TRUE;
 }
 
-HASH_TABLE *HASH_Create_Extended(IMG_UINT32 uInitialLen, IMG_SIZE_T uKeySize,
-				 HASH_FUNC * pfnHashFunc,
-				 HASH_KEY_COMP * pfnKeyComp)
+struct HASH_TABLE *HASH_Create_Extended(u32 uInitialLen, size_t uKeySize,
+				 HASH_FUNC *pfnHashFunc,
+				 HASH_KEY_COMP *pfnKeyComp)
 {
-	HASH_TABLE *pHash;
-	IMG_UINT32 uIndex;
+	struct HASH_TABLE *pHash;
+	u32 uIndex;
 
-	PVR_DPF((PVR_DBG_MESSAGE, "HASH_Create_Extended: InitialSize=0x%x",
-		 uInitialLen));
+	PVR_DPF(PVR_DBG_MESSAGE, "HASH_Create_Extended: InitialSize=0x%x",
+		 uInitialLen);
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(HASH_TABLE),
-		       (IMG_VOID **) & pHash, IMG_NULL) != PVRSRV_OK) {
-		return IMG_NULL;
-	}
+		       sizeof(struct HASH_TABLE),
+		       (void **) &pHash, NULL) != PVRSRV_OK)
+		return NULL;
 
 	pHash->uCount = 0;
 	pHash->uSize = uInitialLen;
@@ -199,164 +181,157 @@
 	pHash->pfnKeyComp = pfnKeyComp;
 
 	OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		   sizeof(BUCKET *) * pHash->uSize,
-		   (IMG_PVOID *) & pHash->ppBucketTable, IMG_NULL);
+		   sizeof(struct BUCKET *) * pHash->uSize,
+		   (void **) &pHash->ppBucketTable, NULL);
 
-	if (pHash->ppBucketTable == IMG_NULL) {
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(HASH_TABLE), pHash,
-			  IMG_NULL);
-		return IMG_NULL;
+	if (pHash->ppBucketTable == NULL) {
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct HASH_TABLE),
+			  pHash, NULL);
+		return NULL;
 	}
 
 	for (uIndex = 0; uIndex < pHash->uSize; uIndex++)
-		pHash->ppBucketTable[uIndex] = IMG_NULL;
+		pHash->ppBucketTable[uIndex] = NULL;
 	return pHash;
 }
 
-HASH_TABLE *HASH_Create(IMG_UINT32 uInitialLen)
+struct HASH_TABLE *HASH_Create(u32 uInitialLen)
 {
-	return HASH_Create_Extended(uInitialLen, sizeof(IMG_UINTPTR_T),
+	return HASH_Create_Extended(uInitialLen, sizeof(u32),
 				    &HASH_Func_Default, &HASH_Key_Comp_Default);
 }
 
-IMG_VOID HASH_Delete(HASH_TABLE * pHash)
+void HASH_Delete(struct HASH_TABLE *pHash)
 {
-	if (pHash != IMG_NULL) {
-		PVR_DPF((PVR_DBG_MESSAGE, "HASH_Delete"));
+	if (pHash != NULL) {
+		PVR_DPF(PVR_DBG_MESSAGE, "HASH_Delete");
 
 		PVR_ASSERT(pHash->uCount == 0);
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  sizeof(BUCKET *) * pHash->uSize, pHash->ppBucketTable,
-			  IMG_NULL);
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(HASH_TABLE), pHash,
-			  IMG_NULL);
+			  sizeof(struct BUCKET *) * pHash->uSize,
+			  pHash->ppBucketTable, NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct HASH_TABLE),
+			  pHash, NULL);
 	}
 }
 
-IMG_BOOL
-HASH_Insert_Extended(HASH_TABLE * pHash, IMG_VOID * pKey, IMG_UINTPTR_T v)
+IMG_BOOL HASH_Insert_Extended(struct HASH_TABLE *pHash, void *pKey, u32 v)
 {
-	BUCKET *pBucket;
+	struct BUCKET *pBucket;
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "HASH_Insert_Extended: Hash=%08X, pKey=%08X, v=0x%x", pHash,
-		 pKey, v));
+		 pKey, v);
 
-	PVR_ASSERT(pHash != IMG_NULL);
+	PVR_ASSERT(pHash != NULL);
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(BUCKET) + pHash->uKeySize,
-		       (IMG_VOID **) & pBucket, IMG_NULL) != PVRSRV_OK) {
+		       sizeof(struct BUCKET) + pHash->uKeySize,
+		       (void **) &pBucket, NULL) != PVRSRV_OK)
 		return IMG_FALSE;
-	}
 
 	pBucket->v = v;
 	OSMemCopy(pBucket->k, pKey, pHash->uKeySize);
 	_ChainInsert(pHash, pBucket, pHash->ppBucketTable, pHash->uSize);
 	pHash->uCount++;
 
-	if (pHash->uCount << 1 > pHash->uSize) {
-
+	if (pHash->uCount << 1 > pHash->uSize)
 		_Resize(pHash, pHash->uSize << 1);
-	}
 
 	return IMG_TRUE;
 }
 
-IMG_BOOL HASH_Insert(HASH_TABLE * pHash, IMG_UINTPTR_T k, IMG_UINTPTR_T v)
+IMG_BOOL HASH_Insert(struct HASH_TABLE *pHash, u32 k, u32 v)
 {
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "HASH_Insert: Hash=%08X, k=0x%x, v=0x%x", pHash, k, v));
+	PVR_DPF(PVR_DBG_MESSAGE,
+		 "HASH_Insert: Hash=%08X, k=0x%x, v=0x%x", pHash, k, v);
 
 	return HASH_Insert_Extended(pHash, &k, v);
 }
 
-IMG_UINTPTR_T HASH_Remove_Extended(HASH_TABLE * pHash, IMG_VOID * pKey)
+u32 HASH_Remove_Extended(struct HASH_TABLE *pHash, void *pKey)
 {
-	BUCKET **ppBucket;
-	IMG_UINT32 uIndex;
+	struct BUCKET **ppBucket;
+	u32 uIndex;
 
-	PVR_DPF((PVR_DBG_MESSAGE, "HASH_Remove: Hash=%08X, pKey=%08X", pHash,
-		 pKey));
+	PVR_DPF(PVR_DBG_MESSAGE, "HASH_Remove: Hash=%08X, pKey=%08X", pHash,
+		 pKey);
 
-	PVR_ASSERT(pHash != IMG_NULL);
+	PVR_ASSERT(pHash != NULL);
 
 	uIndex = KEY_TO_INDEX(pHash, pKey, pHash->uSize);
 
-	for (ppBucket = &(pHash->ppBucketTable[uIndex]); *ppBucket != IMG_NULL;
-	     ppBucket = &((*ppBucket)->pNext)) {
+	for (ppBucket = &(pHash->ppBucketTable[uIndex]); *ppBucket != NULL;
+	     ppBucket = &((*ppBucket)->pNext))
 		if (KEY_COMPARE(pHash, (*ppBucket)->k, pKey)) {
-			BUCKET *pBucket = *ppBucket;
-			IMG_UINTPTR_T v = pBucket->v;
+			struct BUCKET *pBucket = *ppBucket;
+			u32 v = pBucket->v;
 			(*ppBucket) = pBucket->pNext;
 
 			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-				  sizeof(BUCKET) + pHash->uKeySize, pBucket,
-				  IMG_NULL);
+				  sizeof(struct BUCKET) + pHash->uKeySize,
+				  pBucket, NULL);
 
 			pHash->uCount--;
 
 			if (pHash->uSize > (pHash->uCount << 2) &&
-			    pHash->uSize > pHash->uMinimumSize) {
+			    pHash->uSize > pHash->uMinimumSize)
 
 				_Resize(pHash,
 					PRIVATE_MAX(pHash->uSize >> 1,
 						    pHash->uMinimumSize));
-			}
 
-			PVR_DPF((PVR_DBG_MESSAGE,
-				 "HASH_Remove_Extended: Hash=%08X, pKey=%08X = 0x%x",
-				 pHash, pKey, v));
+			PVR_DPF(PVR_DBG_MESSAGE, "HASH_Remove_Extended: "
+				 "Hash=%08X, pKey=%08X = 0x%x",
+				 pHash, pKey, v);
 			return v;
 		}
-	}
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "HASH_Remove_Extended: Hash=%08X, pKey=%08X = 0x0 !!!!", pHash,
-		 pKey));
+		 pKey);
 	return 0;
 }
 
-IMG_UINTPTR_T HASH_Remove(HASH_TABLE * pHash, IMG_UINTPTR_T k)
+u32 HASH_Remove(struct HASH_TABLE *pHash, u32 k)
 {
-	PVR_DPF((PVR_DBG_MESSAGE, "HASH_Remove: Hash=%08X, k=0x%x", pHash, k));
+	PVR_DPF(PVR_DBG_MESSAGE, "HASH_Remove: Hash=%08X, k=0x%x", pHash, k);
 
 	return HASH_Remove_Extended(pHash, &k);
 }
 
-IMG_UINTPTR_T HASH_Retrieve_Extended(HASH_TABLE * pHash, IMG_VOID * pKey)
+u32 HASH_Retrieve_Extended(struct HASH_TABLE *pHash, void *pKey)
 {
-	BUCKET **ppBucket;
-	IMG_UINT32 uIndex;
+	struct BUCKET **ppBucket;
+	u32 uIndex;
 
-	PVR_DPF((PVR_DBG_MESSAGE, "HASH_Retrieve: Hash=%08X, pKey=%08X", pHash,
-		 pKey));
+	PVR_DPF(PVR_DBG_MESSAGE, "HASH_Retrieve: Hash=%08X, pKey=%08X", pHash,
+		 pKey);
 
-	PVR_ASSERT(pHash != IMG_NULL);
+	PVR_ASSERT(pHash != NULL);
 
 	uIndex = KEY_TO_INDEX(pHash, pKey, pHash->uSize);
 
-	for (ppBucket = &(pHash->ppBucketTable[uIndex]); *ppBucket != IMG_NULL;
-	     ppBucket = &((*ppBucket)->pNext)) {
+	for (ppBucket = &(pHash->ppBucketTable[uIndex]); *ppBucket != NULL;
+	     ppBucket = &((*ppBucket)->pNext))
 		if (KEY_COMPARE(pHash, (*ppBucket)->k, pKey)) {
-			BUCKET *pBucket = *ppBucket;
-			IMG_UINTPTR_T v = pBucket->v;
+			struct BUCKET *pBucket = *ppBucket;
+			u32 v = pBucket->v;
 
-			PVR_DPF((PVR_DBG_MESSAGE,
+			PVR_DPF(PVR_DBG_MESSAGE,
 				 "HASH_Retrieve: Hash=%08X, pKey=%08X = 0x%x",
-				 pHash, pKey, v));
+				 pHash, pKey, v);
 			return v;
 		}
-	}
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "HASH_Retrieve: Hash=%08X, pKey=%08X = 0x0 !!!!", pHash,
-		 pKey));
+		 pKey);
 	return 0;
 }
 
-IMG_UINTPTR_T HASH_Retrieve(HASH_TABLE * pHash, IMG_UINTPTR_T k)
+u32 HASH_Retrieve(struct HASH_TABLE *pHash, u32 k)
 {
-	PVR_DPF((PVR_DBG_MESSAGE, "HASH_Retrieve: Hash=%08X, k=0x%x", pHash,
-		 k));
+	PVR_DPF(PVR_DBG_MESSAGE, "HASH_Retrieve: Hash=%08X, k=0x%x", pHash,
+		 k);
 	return HASH_Retrieve_Extended(pHash, &k);
 }
 
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/hash.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/hash.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -30,43 +30,22 @@
 #include "img_types.h"
 #include "osfunc.h"
 
+typedef u32 HASH_FUNC(size_t uKeySize, void *pKey, u32 uHashTabLen);
+typedef IMG_BOOL HASH_KEY_COMP(size_t uKeySize, void *pKey1, void *pKey2);
 
-	typedef IMG_UINT32 HASH_FUNC(IMG_SIZE_T uKeySize, IMG_VOID * pKey,
-				     IMG_UINT32 uHashTabLen);
-	typedef IMG_BOOL HASH_KEY_COMP(IMG_SIZE_T uKeySize, IMG_VOID * pKey1,
-				       IMG_VOID * pKey2);
-
-	typedef struct _HASH_TABLE_ HASH_TABLE;
-
-	IMG_UINT32 HASH_Func_Default(IMG_SIZE_T uKeySize, IMG_VOID * pKey,
-				     IMG_UINT32 uHashTabLen);
-
-	IMG_BOOL HASH_Key_Comp_Default(IMG_SIZE_T uKeySize, IMG_VOID * pKey1,
-				       IMG_VOID * pKey2);
-
-	HASH_TABLE *HASH_Create_Extended(IMG_UINT32 uInitialLen,
-					 IMG_SIZE_T uKeySize,
-					 HASH_FUNC * pfnHashFunc,
-					 HASH_KEY_COMP * pfnKeyComp);
-
-	HASH_TABLE *HASH_Create(IMG_UINT32 uInitialLen);
-
-	IMG_VOID HASH_Delete(HASH_TABLE * pHash);
-
-	IMG_BOOL HASH_Insert_Extended(HASH_TABLE * pHash, IMG_VOID * pKey,
-				      IMG_UINTPTR_T v);
-
-	IMG_BOOL HASH_Insert(HASH_TABLE * pHash, IMG_UINTPTR_T k,
-			     IMG_UINTPTR_T v);
-
-	IMG_UINTPTR_T HASH_Remove_Extended(HASH_TABLE * pHash, IMG_VOID * pKey);
-
-	IMG_UINTPTR_T HASH_Remove(HASH_TABLE * pHash, IMG_UINTPTR_T k);
-
-	IMG_UINTPTR_T HASH_Retrieve_Extended(HASH_TABLE * pHash,
-					     IMG_VOID * pKey);
-
-	IMG_UINTPTR_T HASH_Retrieve(HASH_TABLE * pHash, IMG_UINTPTR_T k);
-
+struct HASH_TABLE;
+u32 HASH_Func_Default(size_t uKeySize, void *pKey, u32 uHashTabLen);
+IMG_BOOL HASH_Key_Comp_Default(size_t uKeySize, void *pKey1, void *pKey2);
+struct HASH_TABLE *HASH_Create_Extended(u32 uInitialLen, size_t uKeySize,
+				 HASH_FUNC *pfnHashFunc,
+				 HASH_KEY_COMP *pfnKeyComp);
+struct HASH_TABLE *HASH_Create(u32 uInitialLen);
+void HASH_Delete(struct HASH_TABLE *pHash);
+IMG_BOOL HASH_Insert_Extended(struct HASH_TABLE *pHash, void *pKey, u32 v);
+IMG_BOOL HASH_Insert(struct HASH_TABLE *pHash, u32 k, u32 v);
+u32 HASH_Remove_Extended(struct HASH_TABLE *pHash, void *pKey);
+u32 HASH_Remove(struct HASH_TABLE *pHash, u32 k);
+u32 HASH_Retrieve_Extended(struct HASH_TABLE *pHash, void *pKey);
+u32 HASH_Retrieve(struct HASH_TABLE *pHash, u32 k);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/img_defs.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/img_defs.h
@@ -1,46 +1,37 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
-#if !defined (__IMG_DEFS_H__)
+#if !defined(__IMG_DEFS_H__)
 #define __IMG_DEFS_H__
 
 #include "img_types.h"
 
-typedef enum img_tag_TriStateSwitch {
-	IMG_ON = 0x00,
-	IMG_OFF,
-	IMG_IGNORE
-} img_TriStateSwitch, *img_pTriStateSwitch;
-
-#define		IMG_SUCCESS				0
-
-#define		IMG_NO_REG				1
+#define	IMG_SUCCESS				0
 
-#define	INLINE					__inline
-#define	FORCE_INLINE			static __inline
+#define	IMG_NO_REG				1
 
 #ifndef PVR_UNREFERENCED_PARAMETER
 #define	PVR_UNREFERENCED_PARAMETER(param) (param) = (param)
@@ -52,21 +43,6 @@
 #define unref__
 #endif
 
-typedef char TCHAR, *PTCHAR, *PTSTR;
-#define _TCHAR_DEFINED
-
-
-#define IMG_CALLCONV
-#define IMG_INTERNAL	__attribute__ ((visibility ("hidden")))
-#define IMG_EXPORT
-#define IMG_IMPORT
-#define IMG_RESTRICT	__restrict__
-
-
-#define IMG_ABORT()	abort()
-
-#define IMG_MALLOC(A)		malloc	(A)
-
-#define IMG_FREE(A)			free	(A)
+#define IMG_INTERNAL	__attribute__ ((visibility("hidden")))
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/img_types.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/img_types.h
@@ -1,52 +1,42 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef __IMG_TYPES_H__
 #define __IMG_TYPES_H__
 
-typedef unsigned int IMG_UINT, *IMG_PUINT;
-typedef signed int IMG_INT, *IMG_PINT;
-
-typedef unsigned char IMG_UINT8, *IMG_PUINT8;
-typedef unsigned char IMG_BYTE, *IMG_PBYTE;
-typedef signed char IMG_INT8, *IMG_PINT8;
-typedef char IMG_CHAR, *IMG_PCHAR;
-
-typedef unsigned short IMG_UINT16, *IMG_PUINT16;
-typedef signed short IMG_INT16, *IMG_PINT16;
-typedef unsigned long IMG_UINT32, *IMG_PUINT32;
-typedef signed long IMG_INT32, *IMG_PINT32;
-
-typedef unsigned long long IMG_UINT64, *IMG_PUINT64;
-typedef long long IMG_INT64, *IMG_PINT64;
-
-#ifndef __KERNEL__
-typedef float IMG_FLOAT, *IMG_PFLOAT;
-typedef double IMG_DOUBLE, *IMG_PDOUBLE;
-#endif
+#include <linux/types.h>
+/*
+   HACK: Without the include the PVR driver would have at this point __inline =
+   __inline, that lets the compiler decide about inlining. With the above
+   include this would change to __inline __atribute__((always_inline)). Keep
+   it the old way for now to avoid introducing changes related to this. See
+   also queue.h.
+ */
+#undef inline
+#define inline inline
 
 typedef enum tag_img_bool {
 	IMG_FALSE = 0,
@@ -54,48 +44,32 @@
 	IMG_FORCE_ALIGN = 0x7FFFFFFF
 } IMG_BOOL, *IMG_PBOOL;
 
-typedef void IMG_VOID, *IMG_PVOID;
-
-typedef IMG_INT32 IMG_RESULT;
-
-typedef IMG_UINT32 IMG_UINTPTR_T;
-
-typedef IMG_PVOID IMG_HANDLE;
-
-typedef void **IMG_HVOID, *IMG_PHVOID;
-
-typedef IMG_UINT32 IMG_SIZE_T;
-
-#define IMG_NULL        0
-
-typedef IMG_PVOID IMG_CPU_VIRTADDR;
-
-typedef struct {
-	IMG_UINT32 uiAddr;
-} IMG_CPU_PHYADDR;
+struct IMG_CPU_PHYADDR {
+	u32 uiAddr;
+};
 
-typedef struct {
-	IMG_UINT32 uiAddr;
-} IMG_DEV_VIRTADDR;
+struct IMG_DEV_VIRTADDR {
+	u32 uiAddr;
+};
 
-typedef struct {
-	IMG_UINT32 uiAddr;
-} IMG_DEV_PHYADDR;
+struct IMG_DEV_PHYADDR {
+	u32 uiAddr;
+};
 
-typedef struct {
-	IMG_UINT32 uiAddr;
-} IMG_SYS_PHYADDR;
+struct IMG_SYS_PHYADDR {
+	u32 uiAddr;
+};
 
-typedef struct _SYSTEM_ADDR_ {
+struct SYSTEM_ADDR {
 
-	IMG_UINT32 ui32PageCount;
+	u32 ui32PageCount;
 	union {
 
-		IMG_SYS_PHYADDR sContig;
+		struct IMG_SYS_PHYADDR sContig;
 
-		IMG_SYS_PHYADDR asNonContig[1];
+		struct IMG_SYS_PHYADDR asNonContig[1];
 	} u;
-} SYSTEM_ADDR;
+};
 
 #include "img_defs.h"
 
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/ioctldef.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/ioctldef.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -29,67 +29,65 @@
 
 #define MAKEIOCTLINDEX(i)	(((i) >> 2) & 0xFFF)
 
-
 #define DEVICE_TYPE ULONG
 
-#define FILE_DEVICE_BEEP                0x00000001
-#define FILE_DEVICE_CD_ROM              0x00000002
+#define FILE_DEVICE_BEEP		0x00000001
+#define FILE_DEVICE_CD_ROM	      0x00000002
 #define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
-#define FILE_DEVICE_CONTROLLER          0x00000004
-#define FILE_DEVICE_DATALINK            0x00000005
-#define FILE_DEVICE_DFS                 0x00000006
-#define FILE_DEVICE_DISK                0x00000007
+#define FILE_DEVICE_CONTROLLER	  0x00000004
+#define FILE_DEVICE_DATALINK	    0x00000005
+#define FILE_DEVICE_DFS		 0x00000006
+#define FILE_DEVICE_DISK		0x00000007
 #define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
-#define FILE_DEVICE_FILE_SYSTEM         0x00000009
-#define FILE_DEVICE_INPORT_PORT         0x0000000a
-#define FILE_DEVICE_KEYBOARD            0x0000000b
-#define FILE_DEVICE_MAILSLOT            0x0000000c
-#define FILE_DEVICE_MIDI_IN             0x0000000d
-#define FILE_DEVICE_MIDI_OUT            0x0000000e
-#define FILE_DEVICE_MOUSE               0x0000000f
+#define FILE_DEVICE_FILE_SYSTEM	 0x00000009
+#define FILE_DEVICE_INPORT_PORT	 0x0000000a
+#define FILE_DEVICE_KEYBOARD	    0x0000000b
+#define FILE_DEVICE_MAILSLOT	    0x0000000c
+#define FILE_DEVICE_MIDI_IN	     0x0000000d
+#define FILE_DEVICE_MIDI_OUT	    0x0000000e
+#define FILE_DEVICE_MOUSE	       0x0000000f
 #define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
-#define FILE_DEVICE_NAMED_PIPE          0x00000011
-#define FILE_DEVICE_NETWORK             0x00000012
+#define FILE_DEVICE_NAMED_PIPE	  0x00000011
+#define FILE_DEVICE_NETWORK	     0x00000012
 #define FILE_DEVICE_NETWORK_BROWSER     0x00000013
 #define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
-#define FILE_DEVICE_NULL                0x00000015
+#define FILE_DEVICE_NULL		0x00000015
 #define FILE_DEVICE_PARALLEL_PORT       0x00000016
 #define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
-#define FILE_DEVICE_PRINTER             0x00000018
-#define FILE_DEVICE_SCANNER             0x00000019
+#define FILE_DEVICE_PRINTER	     0x00000018
+#define FILE_DEVICE_SCANNER	     0x00000019
 #define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
-#define FILE_DEVICE_SERIAL_PORT         0x0000001b
-#define FILE_DEVICE_SCREEN              0x0000001c
-#define FILE_DEVICE_SOUND               0x0000001d
-#define FILE_DEVICE_STREAMS             0x0000001e
-#define FILE_DEVICE_TAPE                0x0000001f
+#define FILE_DEVICE_SERIAL_PORT	 0x0000001b
+#define FILE_DEVICE_SCREEN	      0x0000001c
+#define FILE_DEVICE_SOUND	       0x0000001d
+#define FILE_DEVICE_STREAMS	     0x0000001e
+#define FILE_DEVICE_TAPE		0x0000001f
 #define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
-#define FILE_DEVICE_TRANSPORT           0x00000021
-#define FILE_DEVICE_UNKNOWN             0x00000022
-#define FILE_DEVICE_VIDEO               0x00000023
-#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
-#define FILE_DEVICE_WAVE_IN             0x00000025
-#define FILE_DEVICE_WAVE_OUT            0x00000026
-#define FILE_DEVICE_8042_PORT           0x00000027
+#define FILE_DEVICE_TRANSPORT	   0x00000021
+#define FILE_DEVICE_UNKNOWN	     0x00000022
+#define FILE_DEVICE_VIDEO	       0x00000023
+#define FILE_DEVICE_VIRTUAL_DISK	0x00000024
+#define FILE_DEVICE_WAVE_IN	     0x00000025
+#define FILE_DEVICE_WAVE_OUT	    0x00000026
+#define FILE_DEVICE_8042_PORT	   0x00000027
 #define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
-#define FILE_DEVICE_BATTERY             0x00000029
-#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
-#define FILE_DEVICE_MODEM               0x0000002b
-#define FILE_DEVICE_VDM                 0x0000002c
-#define FILE_DEVICE_MASS_STORAGE        0x0000002d
+#define FILE_DEVICE_BATTERY	     0x00000029
+#define FILE_DEVICE_BUS_EXTENDER	0x0000002a
+#define FILE_DEVICE_MODEM	       0x0000002b
+#define FILE_DEVICE_VDM		 0x0000002c
+#define FILE_DEVICE_MASS_STORAGE	0x0000002d
 
-#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
+#define CTL_CODE( DeviceType, Function, Method, Access) (		 \
     ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
 )
 
-#define METHOD_BUFFERED                 0
-#define METHOD_IN_DIRECT                1
-#define METHOD_OUT_DIRECT               2
-#define METHOD_NEITHER                  3
-
-#define FILE_ANY_ACCESS                 0
-#define FILE_READ_ACCESS          ( 0x0001 )
-#define FILE_WRITE_ACCESS         ( 0x0002 )
-
+#define METHOD_BUFFERED		 0
+#define METHOD_IN_DIRECT		1
+#define METHOD_OUT_DIRECT	       2
+#define METHOD_NEITHER		  3
+
+#define FILE_ANY_ACCESS		 0
+#define FILE_READ_ACCESS	  (0x0001)
+#define FILE_WRITE_ACCESS	 (0x0002)
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/kernelbuffer.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/kernelbuffer.h
@@ -1,59 +1,51 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
-#if !defined (__KERNELBUFFER_H__)
+#if !defined(__KERNELBUFFER_H__)
 #define __KERNELBUFFER_H__
 
-typedef PVRSRV_ERROR(*PFN_OPEN_BC_DEVICE) (IMG_HANDLE *);
-typedef PVRSRV_ERROR(*PFN_CLOSE_BC_DEVICE) (IMG_HANDLE);
-typedef PVRSRV_ERROR(*PFN_GET_BC_INFO) (IMG_HANDLE, BUFFER_INFO *);
-typedef PVRSRV_ERROR(*PFN_GET_BC_BUFFER) (IMG_HANDLE, IMG_UINT32,
-					  PVRSRV_SYNC_DATA *, IMG_HANDLE *);
-
-typedef struct PVRSRV_BC_SRV2BUFFER_KMJTABLE_TAG {
-	IMG_UINT32 ui32TableSize;
-	PFN_OPEN_BC_DEVICE pfnOpenBCDevice;
-	PFN_CLOSE_BC_DEVICE pfnCloseBCDevice;
-	PFN_GET_BC_INFO pfnGetBCInfo;
-	PFN_GET_BC_BUFFER pfnGetBCBuffer;
-	PFN_GET_BUFFER_ADDR pfnGetBufferAddr;
-
-} PVRSRV_BC_SRV2BUFFER_KMJTABLE;
-
-typedef PVRSRV_ERROR(*PFN_BC_REGISTER_BUFFER_DEV) (PVRSRV_BC_SRV2BUFFER_KMJTABLE
-						   *, IMG_UINT32 *);
-typedef PVRSRV_ERROR(*PFN_BC_REMOVE_BUFFER_DEV) (IMG_UINT32);
-
-typedef struct PVRSRV_BC_BUFFER2SRV_KMJTABLE_TAG {
-	IMG_UINT32 ui32TableSize;
-	PFN_BC_REGISTER_BUFFER_DEV pfnPVRSRVRegisterBCDevice;
-	PFN_BC_REMOVE_BUFFER_DEV pfnPVRSRVRemoveBCDevice;
-
-} PVRSRV_BC_BUFFER2SRV_KMJTABLE, *PPVRSRV_BC_BUFFER2SRV_KMJTABLE;
+#include "servicesext.h"
 
-typedef IMG_BOOL(*PFN_BC_GET_PVRJTABLE) (PPVRSRV_BC_BUFFER2SRV_KMJTABLE);
+struct PVRSRV_BC_SRV2BUFFER_KMJTABLE {
+	u32 ui32TableSize;
+	enum PVRSRV_ERROR (*pfnOpenBCDevice)(void **);
+	enum PVRSRV_ERROR (*pfnCloseBCDevice)(void *);
+	enum PVRSRV_ERROR (*pfnGetBCInfo)(void *, struct BUFFER_INFO *);
+	enum PVRSRV_ERROR (*pfnGetBCBuffer)(void *, u32,
+				       struct PVRSRV_SYNC_DATA *, void **);
+	enum PVRSRV_ERROR (*pfnGetBufferAddr)(void *, void *,
+					 struct IMG_SYS_PHYADDR **, u32 *,
+					 void **, void **, IMG_BOOL *);
+};
+
+struct PVRSRV_BC_BUFFER2SRV_KMJTABLE {
+	u32 ui32TableSize;
+	enum PVRSRV_ERROR (*pfnPVRSRVRegisterBCDevice)(
+			struct PVRSRV_BC_SRV2BUFFER_KMJTABLE *, u32 *);
+	enum PVRSRV_ERROR (*pfnPVRSRVRemoveBCDevice)(u32);
+};
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/kerneldisplay.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/kerneldisplay.h
@@ -1,144 +1,103 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
-#if !defined (__KERNELDISPLAY_H__)
+#if !defined(__KERNELDISPLAY_H__)
 #define __KERNELDISPLAY_H__
 
-typedef PVRSRV_ERROR(*PFN_OPEN_DC_DEVICE) (IMG_UINT32, IMG_HANDLE *,
-					   PVRSRV_SYNC_DATA *);
-typedef PVRSRV_ERROR(*PFN_CLOSE_DC_DEVICE) (IMG_HANDLE);
-typedef PVRSRV_ERROR(*PFN_ENUM_DC_FORMATS) (IMG_HANDLE, IMG_UINT32 *,
-					    DISPLAY_FORMAT *);
-typedef PVRSRV_ERROR(*PFN_ENUM_DC_DIMS) (IMG_HANDLE, DISPLAY_FORMAT *,
-					 IMG_UINT32 *, DISPLAY_DIMS *);
-typedef PVRSRV_ERROR(*PFN_GET_DC_SYSTEMBUFFER) (IMG_HANDLE, IMG_HANDLE *);
-typedef PVRSRV_ERROR(*PFN_GET_DC_INFO) (IMG_HANDLE, DISPLAY_INFO *);
-typedef PVRSRV_ERROR(*PFN_CREATE_DC_SWAPCHAIN) (IMG_HANDLE,
-						IMG_UINT32,
-						DISPLAY_SURF_ATTRIBUTES *,
-						DISPLAY_SURF_ATTRIBUTES *,
-						IMG_UINT32,
-						PVRSRV_SYNC_DATA **,
-						IMG_UINT32,
-						IMG_HANDLE *, IMG_UINT32 *);
-typedef PVRSRV_ERROR(*PFN_DESTROY_DC_SWAPCHAIN) (IMG_HANDLE, IMG_HANDLE);
-typedef PVRSRV_ERROR(*PFN_SET_DC_DSTRECT) (IMG_HANDLE, IMG_HANDLE, IMG_RECT *);
-typedef PVRSRV_ERROR(*PFN_SET_DC_SRCRECT) (IMG_HANDLE, IMG_HANDLE, IMG_RECT *);
-typedef PVRSRV_ERROR(*PFN_SET_DC_DSTCK) (IMG_HANDLE, IMG_HANDLE, IMG_UINT32);
-typedef PVRSRV_ERROR(*PFN_SET_DC_SRCCK) (IMG_HANDLE, IMG_HANDLE, IMG_UINT32);
-typedef PVRSRV_ERROR(*PFN_GET_DC_BUFFERS) (IMG_HANDLE,
-					   IMG_HANDLE,
-					   IMG_UINT32 *, IMG_HANDLE *);
-typedef PVRSRV_ERROR(*PFN_SWAP_TO_DC_BUFFER) (IMG_HANDLE,
-					      IMG_HANDLE,
-					      IMG_UINT32,
-					      IMG_HANDLE,
-					      IMG_UINT32, IMG_RECT *);
-typedef PVRSRV_ERROR(*PFN_SWAP_TO_DC_SYSTEM) (IMG_HANDLE, IMG_HANDLE);
-typedef IMG_VOID(*PFN_SET_DC_STATE) (IMG_HANDLE, IMG_UINT32);
-
-typedef struct PVRSRV_DC_SRV2DISP_KMJTABLE_TAG {
-	IMG_UINT32 ui32TableSize;
-	PFN_OPEN_DC_DEVICE pfnOpenDCDevice;
-	PFN_CLOSE_DC_DEVICE pfnCloseDCDevice;
-	PFN_ENUM_DC_FORMATS pfnEnumDCFormats;
-	PFN_ENUM_DC_DIMS pfnEnumDCDims;
-	PFN_GET_DC_SYSTEMBUFFER pfnGetDCSystemBuffer;
-	PFN_GET_DC_INFO pfnGetDCInfo;
-	PFN_GET_BUFFER_ADDR pfnGetBufferAddr;
-	PFN_CREATE_DC_SWAPCHAIN pfnCreateDCSwapChain;
-	PFN_DESTROY_DC_SWAPCHAIN pfnDestroyDCSwapChain;
-	PFN_SET_DC_DSTRECT pfnSetDCDstRect;
-	PFN_SET_DC_SRCRECT pfnSetDCSrcRect;
-	PFN_SET_DC_DSTCK pfnSetDCDstColourKey;
-	PFN_SET_DC_SRCCK pfnSetDCSrcColourKey;
-	PFN_GET_DC_BUFFERS pfnGetDCBuffers;
-	PFN_SWAP_TO_DC_BUFFER pfnSwapToDCBuffer;
-	PFN_SWAP_TO_DC_SYSTEM pfnSwapToDCSystem;
-	PFN_SET_DC_STATE pfnSetDCState;
-
-} PVRSRV_DC_SRV2DISP_KMJTABLE;
-
-typedef IMG_BOOL(*PFN_ISR_HANDLER) (IMG_VOID *);
-
-typedef PVRSRV_ERROR(*PFN_DC_REGISTER_DISPLAY_DEV) (PVRSRV_DC_SRV2DISP_KMJTABLE
-						    *, IMG_UINT32 *);
-typedef PVRSRV_ERROR(*PFN_DC_REMOVE_DISPLAY_DEV) (IMG_UINT32);
-typedef PVRSRV_ERROR(*PFN_DC_OEM_FUNCTION) (IMG_UINT32, IMG_VOID *, IMG_UINT32,
-					    IMG_VOID *, IMG_UINT32);
-typedef PVRSRV_ERROR(*PFN_DC_REGISTER_COMMANDPROCLIST) (IMG_UINT32,
-							PPFN_CMD_PROC,
-							IMG_UINT32[][2],
-							IMG_UINT32);
-typedef PVRSRV_ERROR(*PFN_DC_REMOVE_COMMANDPROCLIST) (IMG_UINT32, IMG_UINT32);
-typedef IMG_VOID(*PFN_DC_CMD_COMPLETE) (IMG_HANDLE, IMG_BOOL);
-typedef PVRSRV_ERROR(*PFN_DC_REGISTER_SYS_ISR) (PFN_ISR_HANDLER, IMG_VOID *,
-						IMG_UINT32, IMG_UINT32);
-typedef PVRSRV_ERROR(*PFN_DC_REGISTER_POWER) (IMG_UINT32, PFN_PRE_POWER,
-					      PFN_POST_POWER,
-					      PFN_PRE_CLOCKSPEED_CHANGE,
-					      PFN_POST_CLOCKSPEED_CHANGE,
-					      IMG_HANDLE, PVR_POWER_STATE,
-					      PVR_POWER_STATE);
-
-typedef struct PVRSRV_DC_DISP2SRV_KMJTABLE_TAG {
-	IMG_UINT32 ui32TableSize;
-	PFN_DC_REGISTER_DISPLAY_DEV pfnPVRSRVRegisterDCDevice;
-	PFN_DC_REMOVE_DISPLAY_DEV pfnPVRSRVRemoveDCDevice;
-	PFN_DC_OEM_FUNCTION pfnPVRSRVOEMFunction;
-	PFN_DC_REGISTER_COMMANDPROCLIST pfnPVRSRVRegisterCmdProcList;
-	PFN_DC_REMOVE_COMMANDPROCLIST pfnPVRSRVRemoveCmdProcList;
-	PFN_DC_CMD_COMPLETE pfnPVRSRVCmdComplete;
-	PFN_DC_REGISTER_SYS_ISR pfnPVRSRVRegisterSystemISRHandler;
-	PFN_DC_REGISTER_POWER pfnPVRSRVRegisterPowerDevice;
-} PVRSRV_DC_DISP2SRV_KMJTABLE, *PPVRSRV_DC_DISP2SRV_KMJTABLE;
-
-typedef struct DISPLAYCLASS_FLIP_COMMAND_TAG {
-
-	IMG_HANDLE hExtDevice;
-
-	IMG_HANDLE hExtSwapChain;
-
-	IMG_HANDLE hExtBuffer;
-
-	IMG_HANDLE hPrivateTag;
-
-	IMG_UINT32 ui32ClipRectCount;
 
-	IMG_RECT *psClipRect;
+struct PVRSRV_DC_SRV2DISP_KMJTABLE {
+	u32 ui32TableSize;
+	enum PVRSRV_ERROR (*pfnOpenDCDevice)(u32, void **,
+					struct PVRSRV_SYNC_DATA *);
+	enum PVRSRV_ERROR (*pfnCloseDCDevice)(void *);
+	enum PVRSRV_ERROR (*pfnEnumDCFormats)(void *, u32 *,
+					 struct DISPLAY_FORMAT *);
+	enum PVRSRV_ERROR (*pfnEnumDCDims)(void *, struct DISPLAY_FORMAT *,
+				      u32 *, struct DISPLAY_DIMS *);
+	enum PVRSRV_ERROR (*pfnGetDCSystemBuffer)(void *, void **);
+	enum PVRSRV_ERROR (*pfnGetDCInfo)(void *, struct DISPLAY_INFO *);
+	enum PVRSRV_ERROR (*pfnGetBufferAddr)(void *, void *,
+					 struct IMG_SYS_PHYADDR **, u32 *,
+					 void __iomem **, void **, IMG_BOOL *);
+	enum PVRSRV_ERROR (*pfnCreateDCSwapChain)(void *, u32,
+					     struct DISPLAY_SURF_ATTRIBUTES *,
+					     struct DISPLAY_SURF_ATTRIBUTES *,
+					     u32, struct PVRSRV_SYNC_DATA **,
+					     u32, void **, u32 *);
+	enum PVRSRV_ERROR (*pfnDestroyDCSwapChain)(void *, void *);
+	enum PVRSRV_ERROR (*pfnSetDCDstRect)(void *, void *, struct IMG_RECT *);
+	enum PVRSRV_ERROR (*pfnSetDCSrcRect)(void *, void *, struct IMG_RECT *);
+	enum PVRSRV_ERROR (*pfnSetDCDstColourKey)(void *, void *, u32);
+	enum PVRSRV_ERROR (*pfnSetDCSrcColourKey)(void *, void *, u32);
+	enum PVRSRV_ERROR (*pfnGetDCBuffers)(void *, void *, u32 *, void **);
+	enum PVRSRV_ERROR (*pfnSwapToDCBuffer)(void *, void *, u32, void *, u32,
+					  struct IMG_RECT *);
+	enum PVRSRV_ERROR (*pfnSwapToDCSystem)(void *, void *);
+	void (*pfnSetDCState)(void *, u32);
+};
+
+struct PVRSRV_DC_DISP2SRV_KMJTABLE {
+	u32 ui32TableSize;
+	enum PVRSRV_ERROR (*pfnPVRSRVRegisterDCDevice)(
+				struct PVRSRV_DC_SRV2DISP_KMJTABLE*, u32 *);
+	enum PVRSRV_ERROR (*pfnPVRSRVRemoveDCDevice)(u32);
+	enum PVRSRV_ERROR (*pfnPVRSRVOEMFunction)(u32, void *, u32, void *,
+				u32);
+	enum PVRSRV_ERROR (*pfnPVRSRVRegisterCmdProcList)(u32,
+				IMG_BOOL (**)(void *, u32, void *), u32[][2],
+				u32);
+	enum PVRSRV_ERROR (*pfnPVRSRVRemoveCmdProcList)(u32, u32);
+	void (*pfnPVRSRVCmdComplete)(void *, IMG_BOOL);
+	enum PVRSRV_ERROR (*pfnPVRSRVRegisterSystemISRHandler)(
+				IMG_BOOL (*)(void *), void *, u32, u32);
+	enum PVRSRV_ERROR (*pfnPVRSRVRegisterPowerDevice)(u32,
+			enum PVRSRV_ERROR (*)(void *, enum PVR_POWER_STATE,
+					 enum PVR_POWER_STATE),
+			enum PVRSRV_ERROR (*)(void *, enum PVR_POWER_STATE,
+					 enum PVR_POWER_STATE),
+			enum PVRSRV_ERROR (*)(void *, IMG_BOOL,
+					 enum PVR_POWER_STATE),
+			enum PVRSRV_ERROR (*)(void *, IMG_BOOL,
+					 enum PVR_POWER_STATE),
+			void *, enum PVR_POWER_STATE, enum PVR_POWER_STATE);
+};
+
+struct DISPLAYCLASS_FLIP_COMMAND {
+	void *hExtDevice;
+	void *hExtSwapChain;
+	void *hExtBuffer;
+	void *hPrivateTag;
+	u32 ui32ClipRectCount;
+	struct IMG_RECT *psClipRect;
+	u32 ui32SwapInterval;
+};
 
-	IMG_UINT32 ui32SwapInterval;
-
-} DISPLAYCLASS_FLIP_COMMAND;
-
-#define DC_FLIP_COMMAND		0
+#define DC_FLIP_COMMAND				0
 
 #define DC_STATE_NO_FLUSH_COMMANDS		0
 #define DC_STATE_FLUSH_COMMANDS			1
 
-typedef IMG_BOOL(*PFN_DC_GET_PVRJTABLE) (PPVRSRV_DC_DISP2SRV_KMJTABLE);
-
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/mem.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/mem.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -28,10 +28,9 @@
 #include "sgxapi_km.h"
 #include "pvr_bridge_km.h"
 
-static PVRSRV_ERROR
-FreeSharedSysMemCallBack(IMG_PVOID pvParam, IMG_UINT32 ui32Param)
+static enum PVRSRV_ERROR FreeSharedSysMemCallBack(void *pvParam, u32 ui32Param)
 {
-	PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo = pvParam;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo = pvParam;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
@@ -41,25 +40,23 @@
 		    psKernelMemInfo->sMemBlk.hOSMemHandle);
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-		  sizeof(PVRSRV_KERNEL_MEM_INFO), psKernelMemInfo, IMG_NULL);
+		  sizeof(struct PVRSRV_KERNEL_MEM_INFO), psKernelMemInfo, NULL);
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT PVRSRV_ERROR
-PVRSRVAllocSharedSysMemoryKM(PVRSRV_PER_PROCESS_DATA * psPerProc,
-			     IMG_UINT32 ui32Flags,
-			     IMG_UINT32 ui32Size,
-			     PVRSRV_KERNEL_MEM_INFO ** ppsKernelMemInfo)
+enum PVRSRV_ERROR PVRSRVAllocSharedSysMemoryKM(
+			struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+			u32 ui32Flags, u32 ui32Size,
+			struct PVRSRV_KERNEL_MEM_INFO **ppsKernelMemInfo)
 {
-	PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(PVRSRV_KERNEL_MEM_INFO),
-		       (IMG_VOID **) & psKernelMemInfo, IMG_NULL) != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVAllocSharedSysMemoryKM: Failed to alloc memory for meminfo"));
+		       sizeof(struct PVRSRV_KERNEL_MEM_INFO),
+		       (void **) &psKernelMemInfo, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVAllocSharedSysMemoryKM: "
+			 "Failed to alloc memory for meminfo");
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
@@ -71,50 +68,49 @@
 	if (OSAllocPages(psKernelMemInfo->ui32Flags,
 			 psKernelMemInfo->ui32AllocSize,
 			 &psKernelMemInfo->pvLinAddrKM,
-			 &psKernelMemInfo->sMemBlk.hOSMemHandle)
-	    != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVAllocSharedSysMemoryKM: Failed to alloc memory for block"));
+			 &psKernelMemInfo->sMemBlk.hOSMemHandle) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVAllocSharedSysMemoryKM: "
+			 "Failed to alloc memory for block");
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  sizeof(PVRSRV_KERNEL_MEM_INFO), psKernelMemInfo, 0);
+			  sizeof(struct PVRSRV_KERNEL_MEM_INFO),
+			  psKernelMemInfo, NULL);
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
-	psKernelMemInfo->sMemBlk.hResItem =
-	    ResManRegisterRes(psPerProc->hResManContext,
-			      RESMAN_TYPE_SHARED_MEM_INFO,
-			      psKernelMemInfo, 0, FreeSharedSysMemCallBack);
+	psKernelMemInfo->sMemBlk.hResItem = ResManRegisterRes(
+					psPerProc->hResManContext,
+					RESMAN_TYPE_SHARED_MEM_INFO,
+					psKernelMemInfo, 0,
+					FreeSharedSysMemCallBack);
 
 	*ppsKernelMemInfo = psKernelMemInfo;
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT PVRSRV_ERROR
-PVRSRVFreeSharedSysMemoryKM(PVRSRV_KERNEL_MEM_INFO * psKernelMemInfo)
+enum PVRSRV_ERROR PVRSRVFreeSharedSysMemoryKM(
+			struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo)
 {
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
-	if (psKernelMemInfo->sMemBlk.hResItem) {
-		eError = ResManFreeResByPtr(psKernelMemInfo->sMemBlk.hResItem);
-	} else {
+	if (psKernelMemInfo->sMemBlk.hResItem)
+		ResManFreeResByPtr(psKernelMemInfo->sMemBlk.hResItem);
+	else
 		eError = FreeSharedSysMemCallBack(psKernelMemInfo, 0);
-	}
 
 	return eError;
 }
 
-IMG_EXPORT PVRSRV_ERROR
-PVRSRVDissociateMemFromResmanKM(PVRSRV_KERNEL_MEM_INFO * psKernelMemInfo)
+enum PVRSRV_ERROR PVRSRVDissociateMemFromResmanKM(
+				struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo)
 {
-	if (!psKernelMemInfo) {
+	if (!psKernelMemInfo)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
 	if (psKernelMemInfo->sMemBlk.hResItem) {
 		ResManDissociateRes(psKernelMemInfo->sMemBlk.hResItem,
-				    IMG_NULL);
-		psKernelMemInfo->sMemBlk.hResItem = IMG_NULL;
+				    NULL);
+		psKernelMemInfo->sMemBlk.hResItem = NULL;
 	}
 
 	return PVRSRV_OK;
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/metrics.c
+++ /dev/null
@@ -1,114 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#include "services_headers.h"
-#include "sgxapi_km.h"
-#include "metrics.h"
-
-#if defined(DEBUG) || defined(TIMING)
-
-static volatile IMG_UINT32 *pui32TimerRegister = 0;
-
-#define PVRSRV_TIMER_TOTAL_IN_TICKS(X)	asTimers[X].ui32Total
-#define PVRSRV_TIMER_TOTAL_IN_MS(X)		((1000*asTimers[X].ui32Total)/ui32TicksPerMS)
-#define PVRSRV_TIMER_COUNT(X)			asTimers[X].ui32Count
-
-Temporal_Data asTimers[PVRSRV_NUM_TIMERS];
-
-IMG_UINT32 PVRSRVTimeNow(IMG_VOID)
-{
-	if (!pui32TimerRegister) {
-		static IMG_BOOL bFirstTime = IMG_TRUE;
-
-		if (bFirstTime) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVTimeNow: No timer register set up"));
-
-			bFirstTime = IMG_FALSE;
-		}
-
-		return 0;
-	}
-
-	return 0;
-
-}
-
-static IMG_UINT32 PVRSRVGetCPUFreq(IMG_VOID)
-{
-	IMG_UINT32 ui32Time1, ui32Time2;
-
-	ui32Time1 = PVRSRVTimeNow();
-
-	OSWaitus(1000000);
-
-	ui32Time2 = PVRSRVTimeNow();
-
-	PVR_DPF((PVR_DBG_WARNING, "PVRSRVGetCPUFreq: timer frequency = %d Hz",
-		 ui32Time2 - ui32Time1));
-
-	return (ui32Time2 - ui32Time1);
-}
-
-IMG_VOID PVRSRVSetupMetricTimers(IMG_VOID * pvDevInfo)
-{
-	IMG_UINT32 ui32Loop;
-
-	PVR_UNREFERENCED_PARAMETER(pvDevInfo);
-
-	for (ui32Loop = 0; ui32Loop < (PVRSRV_NUM_TIMERS); ui32Loop++) {
-		asTimers[ui32Loop].ui32Total = 0;
-		asTimers[ui32Loop].ui32Count = 0;
-	}
-
-
-	pui32TimerRegister = 0;
-
-
-}
-
-IMG_VOID PVRSRVOutputMetricTotals(IMG_VOID)
-{
-	IMG_UINT32 ui32TicksPerMS, ui32Loop;
-
-	ui32TicksPerMS = PVRSRVGetCPUFreq();
-
-	if (!ui32TicksPerMS) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVOutputMetricTotals: Failed to get CPU Freq"));
-		return;
-	}
-
-	for (ui32Loop = 0; ui32Loop < (PVRSRV_NUM_TIMERS); ui32Loop++) {
-		if (asTimers[ui32Loop].ui32Count & 0x80000000L) {
-			PVR_DPF((PVR_DBG_WARNING,
-				 "PVRSRVOutputMetricTotals: Timer %u is still ON",
-				 ui32Loop));
-		}
-	}
-}
-
-#endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/metrics.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#ifndef _METRICS_
-#define _METRICS_
-
-
-#if defined(DEBUG) || defined(TIMING)
-
-	typedef struct {
-		IMG_UINT32 ui32Start;
-		IMG_UINT32 ui32Stop;
-		IMG_UINT32 ui32Total;
-		IMG_UINT32 ui32Count;
-	} Temporal_Data;
-
-	extern Temporal_Data asTimers[];
-
-	extern IMG_UINT32 PVRSRVTimeNow(IMG_VOID);
-	extern IMG_VOID PVRSRVSetupMetricTimers(IMG_VOID * pvDevInfo);
-	extern IMG_VOID PVRSRVOutputMetricTotals(IMG_VOID);
-
-#define PVRSRV_TIMER_DUMMY				0
-
-#define PVRSRV_TIMER_EXAMPLE_1			1
-#define PVRSRV_TIMER_EXAMPLE_2			2
-
-#define PVRSRV_NUM_TIMERS		(PVRSRV_TIMER_EXAMPLE_2 + 1)
-
-#define PVRSRV_TIME_START(X)	{ \
-									asTimers[X].ui32Count += 1; \
-									asTimers[X].ui32Count |= 0x80000000L; \
-									asTimers[X].ui32Start = PVRSRVTimeNow(); \
-									asTimers[X].ui32Stop  = 0; \
-								}
-
-#define PVRSRV_TIME_SUSPEND(X)	{ \
-									asTimers[X].ui32Stop += PVRSRVTimeNow() - asTimers[X].ui32Start; \
-								}
-
-#define PVRSRV_TIME_RESUME(X)	{ \
-									asTimers[X].ui32Start = PVRSRVTimeNow(); \
-								}
-
-#define PVRSRV_TIME_STOP(X)		{ \
-									asTimers[X].ui32Stop  += PVRSRVTimeNow() - asTimers[X].ui32Start; \
-									asTimers[X].ui32Total += asTimers[X].ui32Stop; \
-									asTimers[X].ui32Count &= 0x7FFFFFFFL; \
-								}
-
-#define PVRSRV_TIME_RESET(X)	{ \
-									asTimers[X].ui32Start = 0; \
-									asTimers[X].ui32Stop  = 0; \
-									asTimers[X].ui32Total = 0; \
-									asTimers[X].ui32Count = 0; \
-								}
-
-
-#else
-
-#define PVRSRV_TIME_START(X)
-#define PVRSRV_TIME_SUSPEND(X)
-#define PVRSRV_TIME_RESUME(X)
-#define PVRSRV_TIME_STOP(X)
-#define PVRSRV_TIME_RESET(X)
-
-#define PVRSRVSetupMetricTimers(X)
-#define PVRSRVOutputMetricTotals()
-
-#endif
-
-#endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/mm.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/mm.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -31,7 +31,7 @@
 #include <linux/version.h>
 #include <linux/mm.h>
 #include <linux/vmalloc.h>
-#include <asm/io.h>
+#include <linux/io.h>
 #include <linux/slab.h>
 #include <linux/highmem.h>
 #include <linux/sched.h>
@@ -52,10 +52,8 @@
 
 #include <asm/cacheflush.h>
 
-extern PVRSRV_LINUX_MUTEX gPVRSRVLock;
-
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-typedef enum {
+enum DEBUG_MEM_ALLOC_TYPE {
 	DEBUG_MEM_ALLOC_TYPE_KMALLOC,
 	DEBUG_MEM_ALLOC_TYPE_VMALLOC,
 	DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES,
@@ -64,94 +62,92 @@
 	DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE,
 	DEBUG_MEM_ALLOC_TYPE_KMAP,
 	DEBUG_MEM_ALLOC_TYPE_COUNT
-} DEBUG_MEM_ALLOC_TYPE;
+};
 
-typedef struct _DEBUG_MEM_ALLOC_REC {
-	DEBUG_MEM_ALLOC_TYPE eAllocType;
-	IMG_VOID *pvKey;
-	IMG_VOID *pvCpuVAddr;
+struct DEBUG_MEM_ALLOC_REC {
+	enum DEBUG_MEM_ALLOC_TYPE eAllocType;
+	void *pvKey;
+	void *pvCpuVAddr;
 	unsigned long ulCpuPAddr;
-	IMG_VOID *pvPrivateData;
-	IMG_UINT32 ui32Bytes;
+	void *pvPrivateData;
+	u32 ui32Bytes;
 	pid_t pid;
-	IMG_CHAR *pszFileName;
-	IMG_UINT32 ui32Line;
+	char *pszFileName;
+	u32 ui32Line;
 
-	struct _DEBUG_MEM_ALLOC_REC *psNext;
-} DEBUG_MEM_ALLOC_REC;
+	struct DEBUG_MEM_ALLOC_REC *psNext;
+};
 
-static DEBUG_MEM_ALLOC_REC *g_MemoryRecords;
+static struct DEBUG_MEM_ALLOC_REC *g_MemoryRecords;
 
-static IMG_UINT32 g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_COUNT];
-static IMG_UINT32 g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_COUNT];
+static u32 g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_COUNT];
+static u32 g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_COUNT];
 
-static IMG_UINT32 g_SysRAMWaterMark;
-static IMG_UINT32 g_SysRAMHighWaterMark;
+static u32 g_SysRAMWaterMark;
+static u32 g_SysRAMHighWaterMark;
 
-static IMG_UINT32 g_IOMemWaterMark;
-static IMG_UINT32 g_IOMemHighWaterMark;
+static u32 g_IOMemWaterMark;
+static u32 g_IOMemHighWaterMark;
 
-static IMG_VOID DebugMemAllocRecordAdd(DEBUG_MEM_ALLOC_TYPE eAllocType,
-				       IMG_VOID * pvKey,
-				       IMG_VOID * pvCpuVAddr,
+static void DebugMemAllocRecordAdd(enum DEBUG_MEM_ALLOC_TYPE eAllocType,
+				       void *pvKey,
+				       void *pvCpuVAddr,
 				       unsigned long ulCpuPAddr,
-				       IMG_VOID * pvPrivateData,
-				       IMG_UINT32 ui32Bytes,
-				       IMG_CHAR * pszFileName,
-				       IMG_UINT32 ui32Line);
-
-static IMG_VOID DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE eAllocType,
-					  IMG_VOID * pvKey,
-					  IMG_CHAR * pszFileName,
-					  IMG_UINT32 ui32Line);
+				       void *pvPrivateData,
+				       u32 ui32Bytes,
+				       char *pszFileName,
+				       u32 ui32Line);
+
+static void DebugMemAllocRecordRemove(enum DEBUG_MEM_ALLOC_TYPE eAllocType,
+					  void *pvKey,
+					  char *pszFileName,
+					  u32 ui32Line);
 
-static IMG_CHAR *DebugMemAllocRecordTypeToString(DEBUG_MEM_ALLOC_TYPE
-						 eAllocType);
+static char *DebugMemAllocRecordTypeToString(
+					enum DEBUG_MEM_ALLOC_TYPE eAllocType);
 
 static off_t printMemoryRecords(char *buffer, size_t size, off_t off);
 #endif
 
 #if defined(DEBUG_LINUX_MEM_AREAS)
-typedef struct _DEBUG_LINUX_MEM_AREA_REC {
-	LinuxMemArea *psLinuxMemArea;
-	IMG_UINT32 ui32Flags;
+struct DEBUG_LINUX_MEM_AREA_REC {
+	struct LinuxMemArea *psLinuxMemArea;
+	u32 ui32Flags;
 	pid_t pid;
 
-	struct _DEBUG_LINUX_MEM_AREA_REC *psNext;
-} DEBUG_LINUX_MEM_AREA_REC;
+	struct DEBUG_LINUX_MEM_AREA_REC *psNext;
+};
 
-static DEBUG_LINUX_MEM_AREA_REC *g_LinuxMemAreaRecords;
-static IMG_UINT32 g_LinuxMemAreaCount;
-static IMG_UINT32 g_LinuxMemAreaWaterMark;
-static IMG_UINT32 g_LinuxMemAreaHighWaterMark;
+static struct DEBUG_LINUX_MEM_AREA_REC *g_LinuxMemAreaRecords;
+static u32 g_LinuxMemAreaCount;
+static u32 g_LinuxMemAreaWaterMark;
+static u32 g_LinuxMemAreaHighWaterMark;
 
 static off_t printLinuxMemAreaRecords(char *buffer, size_t size, off_t off);
 #endif
 
-static LinuxKMemCache *psLinuxMemAreaCache;
+static struct kmem_cache *psLinuxMemAreaCache;
 
 
-static LinuxMemArea *LinuxMemAreaStructAlloc(IMG_VOID);
-static IMG_VOID LinuxMemAreaStructFree(LinuxMemArea * psLinuxMemArea);
+static struct LinuxMemArea *LinuxMemAreaStructAlloc(void);
+static void LinuxMemAreaStructFree(struct LinuxMemArea *psLinuxMemArea);
 #if defined(DEBUG_LINUX_MEM_AREAS)
-static IMG_VOID DebugLinuxMemAreaRecordAdd(LinuxMemArea * psLinuxMemArea,
-					   IMG_UINT32 ui32Flags);
-static DEBUG_LINUX_MEM_AREA_REC *DebugLinuxMemAreaRecordFind(LinuxMemArea *
-							     psLinuxMemArea);
-static IMG_VOID DebugLinuxMemAreaRecordRemove(LinuxMemArea * psLinuxMemArea);
+static void DebugLinuxMemAreaRecordAdd(struct LinuxMemArea *psLinuxMemArea,
+					   u32 ui32Flags);
+static struct DEBUG_LINUX_MEM_AREA_REC *DebugLinuxMemAreaRecordFind(
+					struct LinuxMemArea *psLinuxMemArea);
+static void DebugLinuxMemAreaRecordRemove(struct LinuxMemArea *psLinuxMemArea);
 #endif
 
-PVRSRV_ERROR LinuxMMInit(IMG_VOID)
+enum PVRSRV_ERROR LinuxMMInit(void)
 {
-
 #if defined(DEBUG_LINUX_MEM_AREAS)
 	{
 		int iStatus;
 		iStatus =
 		    CreateProcReadEntry("mem_areas", printLinuxMemAreaRecords);
-		if (iStatus != 0) {
+		if (iStatus != 0)
 			return PVRSRV_ERROR_OUT_OF_MEMORY;
-		}
 	}
 #endif
 
@@ -159,51 +155,49 @@
 	{
 		int iStatus;
 		iStatus = CreateProcReadEntry("meminfo", printMemoryRecords);
-		if (iStatus != 0) {
+		if (iStatus != 0)
 			return PVRSRV_ERROR_OUT_OF_MEMORY;
-		}
 	}
 #endif
-
 	psLinuxMemAreaCache =
-	    KMemCacheCreateWrapper("img-mm", sizeof(LinuxMemArea), 0, 0);
+	    KMemCacheCreateWrapper("img-mm", sizeof(struct LinuxMemArea), 0, 0);
 	if (!psLinuxMemAreaCache) {
-		PVR_DPF((PVR_DBG_ERROR, "%s: failed to allocate kmem_cache",
-			 __FUNCTION__));
+		PVR_DPF(PVR_DBG_ERROR, "%s: failed to allocate kmem_cache",
+			 __func__);
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
 	return PVRSRV_OK;
 }
 
-IMG_VOID LinuxMMCleanup(IMG_VOID)
+void LinuxMMCleanup(void)
 {
-
 #if defined(DEBUG_LINUX_MEM_AREAS)
 	{
-		DEBUG_LINUX_MEM_AREA_REC *psCurrentRecord =
+		struct DEBUG_LINUX_MEM_AREA_REC *psCurrentRecord =
 		    g_LinuxMemAreaRecords, *psNextRecord;
 
-		if (g_LinuxMemAreaCount) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "%s: BUG!: There are %d LinuxMemArea allocation unfreed (%ld bytes)",
-				 __FUNCTION__, g_LinuxMemAreaCount,
-				 g_LinuxMemAreaWaterMark));
-		}
+		if (g_LinuxMemAreaCount)
+			PVR_DPF(PVR_DBG_ERROR, "%s: BUG!: "
+				"There are %d Linux memory area allocation "
+				"unfreed (%ld bytes)",
+				 __func__, g_LinuxMemAreaCount,
+				 g_LinuxMemAreaWaterMark);
 
 		while (psCurrentRecord) {
-			LinuxMemArea *psLinuxMemArea;
+			struct LinuxMemArea *psLinuxMemArea;
 
 			psNextRecord = psCurrentRecord->psNext;
 			psLinuxMemArea = psCurrentRecord->psLinuxMemArea;
-			PVR_DPF((PVR_DBG_ERROR,
-				 "%s: BUG!: Cleaning up Linux memory area (%p), type=%s, size=%ld bytes",
-				 __FUNCTION__, psCurrentRecord->psLinuxMemArea,
+			PVR_DPF(PVR_DBG_ERROR, "%s: BUG!: "
+				"Cleaning up Linux memory area (%p), "
+				"type=%s, size=%ld bytes",
+				 __func__, psCurrentRecord->psLinuxMemArea,
 				 LinuxMemAreaTypeToString(psCurrentRecord->
 							  psLinuxMemArea->
 							  eAreaType),
 				 psCurrentRecord->psLinuxMemArea->
-				 ui32ByteSize));
+				 ui32ByteSize);
 
 			LinuxMemAreaDeepFree(psLinuxMemArea);
 
@@ -215,29 +209,30 @@
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
 	{
-		DEBUG_MEM_ALLOC_REC *psCurrentRecord =
+		struct DEBUG_MEM_ALLOC_REC *psCurrentRecord =
 		    g_MemoryRecords, *psNextRecord;
 
 		while (psCurrentRecord) {
 			psNextRecord = psCurrentRecord->psNext;
-			PVR_DPF((PVR_DBG_ERROR, "%s: BUG!: Cleaning up memory: "
+			PVR_DPF(PVR_DBG_ERROR, "%s: BUG!: Cleaning up memory: "
 				 "type=%s "
 				 "CpuVAddr=%p "
 				 "CpuPAddr=0x%08lx, "
 				 "allocated @ file=%s,line=%d",
-				 __FUNCTION__,
+				 __func__,
 				 DebugMemAllocRecordTypeToString
 				 (psCurrentRecord->eAllocType),
 				 psCurrentRecord->pvCpuVAddr,
 				 psCurrentRecord->ulCpuPAddr,
 				 psCurrentRecord->pszFileName,
-				 psCurrentRecord->ui32Line));
+				 psCurrentRecord->ui32Line);
 			switch (psCurrentRecord->eAllocType) {
 			case DEBUG_MEM_ALLOC_TYPE_KMALLOC:
 				KFreeWrapper(psCurrentRecord->pvCpuVAddr);
 				break;
 			case DEBUG_MEM_ALLOC_TYPE_IOREMAP:
-				IOUnmapWrapper(psCurrentRecord->pvCpuVAddr);
+				IOUnmapWrapper((void __iomem __force *)
+						psCurrentRecord->pvCpuVAddr);
 				break;
 			case DEBUG_MEM_ALLOC_TYPE_IO:
 
@@ -280,27 +275,22 @@
 	}
 }
 
-IMG_VOID *_KMallocWrapper(IMG_UINT32 ui32ByteSize, IMG_CHAR * pszFileName,
-			  IMG_UINT32 ui32Line)
+void *_KMallocWrapper(u32 ui32ByteSize, char *pszFileName,
+			  u32 ui32Line)
 {
-	IMG_VOID *pvRet;
+	void *pvRet;
 	pvRet = kmalloc(ui32ByteSize, GFP_KERNEL);
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-	if (pvRet) {
+	if (pvRet)
 		DebugMemAllocRecordAdd(DEBUG_MEM_ALLOC_TYPE_KMALLOC,
-				       pvRet,
-				       pvRet,
-				       0,
-				       NULL,
-				       ui32ByteSize, pszFileName, ui32Line);
-	}
+				       pvRet, pvRet, 0, NULL, ui32ByteSize,
+				       pszFileName, ui32Line);
 #endif
 	return pvRet;
 }
 
-IMG_VOID
-_KFreeWrapper(IMG_VOID * pvCpuVAddr, IMG_CHAR * pszFileName,
-	      IMG_UINT32 ui32Line)
+void _KFreeWrapper(void *pvCpuVAddr, char *pszFileName,
+	      u32 ui32Line)
 {
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
 	DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_KMALLOC, pvCpuVAddr,
@@ -310,18 +300,14 @@
 }
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-static IMG_VOID
-DebugMemAllocRecordAdd(DEBUG_MEM_ALLOC_TYPE eAllocType,
-		       IMG_VOID * pvKey,
-		       IMG_VOID * pvCpuVAddr,
-		       unsigned long ulCpuPAddr,
-		       IMG_VOID * pvPrivateData,
-		       IMG_UINT32 ui32Bytes,
-		       IMG_CHAR * pszFileName, IMG_UINT32 ui32Line)
+static void DebugMemAllocRecordAdd(enum DEBUG_MEM_ALLOC_TYPE eAllocType,
+		       void *pvKey, void *pvCpuVAddr, unsigned long ulCpuPAddr,
+		       void *pvPrivateData, u32 ui32Bytes, char *pszFileName,
+		       u32 ui32Line)
 {
-	DEBUG_MEM_ALLOC_REC *psRecord;
+	struct DEBUG_MEM_ALLOC_REC *psRecord;
 
-	psRecord = kmalloc(sizeof(DEBUG_MEM_ALLOC_REC), GFP_KERNEL);
+	psRecord = kmalloc(sizeof(struct DEBUG_MEM_ALLOC_REC), GFP_KERNEL);
 
 	psRecord->eAllocType = eAllocType;
 	psRecord->pvKey = pvKey;
@@ -337,40 +323,37 @@
 	g_MemoryRecords = psRecord;
 
 	g_WaterMarkData[eAllocType] += ui32Bytes;
-	if (g_WaterMarkData[eAllocType] > g_HighWaterMarkData[eAllocType]) {
+	if (g_WaterMarkData[eAllocType] > g_HighWaterMarkData[eAllocType])
 		g_HighWaterMarkData[eAllocType] = g_WaterMarkData[eAllocType];
-	}
 
 	if (eAllocType == DEBUG_MEM_ALLOC_TYPE_KMALLOC
 	    || eAllocType == DEBUG_MEM_ALLOC_TYPE_VMALLOC
 	    || eAllocType == DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES
 	    || eAllocType == DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE) {
 		g_SysRAMWaterMark += ui32Bytes;
-		if (g_SysRAMWaterMark > g_SysRAMHighWaterMark) {
+		if (g_SysRAMWaterMark > g_SysRAMHighWaterMark)
 			g_SysRAMHighWaterMark = g_SysRAMWaterMark;
-		}
 	} else if (eAllocType == DEBUG_MEM_ALLOC_TYPE_IOREMAP
 		   || eAllocType == DEBUG_MEM_ALLOC_TYPE_IO) {
 		g_IOMemWaterMark += ui32Bytes;
-		if (g_IOMemWaterMark > g_IOMemHighWaterMark) {
+		if (g_IOMemWaterMark > g_IOMemHighWaterMark)
 			g_IOMemHighWaterMark = g_IOMemWaterMark;
-		}
 	}
 }
 
-static IMG_VOID
-DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE eAllocType, IMG_VOID * pvKey,
-			  IMG_CHAR * pszFileName, IMG_UINT32 ui32Line)
+static void DebugMemAllocRecordRemove(enum DEBUG_MEM_ALLOC_TYPE eAllocType_in,
+				      void *pvKey, char *pszFileName,
+				      u32 ui32Line)
 {
-	DEBUG_MEM_ALLOC_REC **ppsCurrentRecord;
+	struct DEBUG_MEM_ALLOC_REC **ppsCurrentRecord;
 
 	for (ppsCurrentRecord = &g_MemoryRecords;
 	     *ppsCurrentRecord;
-	     ppsCurrentRecord = &((*ppsCurrentRecord)->psNext)) {
-		if ((*ppsCurrentRecord)->eAllocType == eAllocType
+	     ppsCurrentRecord = &((*ppsCurrentRecord)->psNext))
+		if ((*ppsCurrentRecord)->eAllocType == eAllocType_in
 		    && (*ppsCurrentRecord)->pvKey == pvKey) {
-			DEBUG_MEM_ALLOC_REC *psNextRecord;
-			DEBUG_MEM_ALLOC_TYPE eAllocType;
+			struct DEBUG_MEM_ALLOC_REC *psNextRecord;
+			enum DEBUG_MEM_ALLOC_TYPE eAllocType;
 
 			psNextRecord = (*ppsCurrentRecord)->psNext;
 			eAllocType = (*ppsCurrentRecord)->eAllocType;
@@ -380,29 +363,27 @@
 			if (eAllocType == DEBUG_MEM_ALLOC_TYPE_KMALLOC
 			    || eAllocType == DEBUG_MEM_ALLOC_TYPE_VMALLOC
 			    || eAllocType == DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES
-			    || eAllocType == DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE) {
+			    || eAllocType == DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE)
 				g_SysRAMWaterMark -=
 				    (*ppsCurrentRecord)->ui32Bytes;
-			} else if (eAllocType == DEBUG_MEM_ALLOC_TYPE_IOREMAP
-				   || eAllocType == DEBUG_MEM_ALLOC_TYPE_IO) {
+			else if (eAllocType == DEBUG_MEM_ALLOC_TYPE_IOREMAP
+				   || eAllocType == DEBUG_MEM_ALLOC_TYPE_IO)
 				g_IOMemWaterMark -=
 				    (*ppsCurrentRecord)->ui32Bytes;
-			}
 
 			kfree(*ppsCurrentRecord);
 			*ppsCurrentRecord = psNextRecord;
 			return;
 		}
-	}
 
-	PVR_DPF((PVR_DBG_ERROR,
-		 "%s: couldn't find an entry for type=%s with pvKey=%p (called from %s, line %d\n",
-		 __FUNCTION__, DebugMemAllocRecordTypeToString(eAllocType),
-		 pvKey, pszFileName, ui32Line));
+	PVR_DPF(PVR_DBG_ERROR, "%s: couldn't find an entry for type=%s "
+				"with pvKey=%p (called from %s, line %d\n",
+		 __func__, DebugMemAllocRecordTypeToString(eAllocType_in),
+		 pvKey, pszFileName, ui32Line);
 }
 
-static IMG_CHAR *DebugMemAllocRecordTypeToString(DEBUG_MEM_ALLOC_TYPE
-						 eAllocType)
+static char *DebugMemAllocRecordTypeToString(
+		enum DEBUG_MEM_ALLOC_TYPE eAllocType)
 {
 	char *apszDebugMemoryRecordTypes[] = {
 		"KMALLOC",
@@ -417,12 +398,11 @@
 }
 #endif
 
-IMG_VOID *_VMallocWrapper(IMG_UINT32 ui32Bytes,
-			  IMG_UINT32 ui32AllocFlags,
-			  IMG_CHAR * pszFileName, IMG_UINT32 ui32Line)
+void *_VMallocWrapper(u32 ui32Bytes, u32 ui32AllocFlags, char *pszFileName,
+		      u32 ui32Line)
 {
 	pgprot_t PGProtFlags;
-	IMG_VOID *pvRet;
+	void *pvRet;
 
 	switch (ui32AllocFlags & PVRSRV_HAP_CACHETYPE_MASK) {
 	case PVRSRV_HAP_CACHED:
@@ -435,9 +415,9 @@
 		PGProtFlags = pgprot_noncached(PAGE_KERNEL);
 		break;
 	default:
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "VMAllocWrapper: unknown mapping flags=0x%08lx",
-			 ui32AllocFlags));
+			 ui32AllocFlags);
 		dump_stack();
 		return NULL;
 	}
@@ -445,23 +425,18 @@
 	pvRet = __vmalloc(ui32Bytes, GFP_KERNEL | __GFP_HIGHMEM, PGProtFlags);
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-	if (pvRet) {
+	if (pvRet)
 		DebugMemAllocRecordAdd(DEBUG_MEM_ALLOC_TYPE_VMALLOC,
-				       pvRet,
-				       pvRet,
-				       0,
-				       NULL,
+				       pvRet, pvRet, 0, NULL,
 				       PAGE_ALIGN(ui32Bytes),
 				       pszFileName, ui32Line);
-	}
 #endif
 
 	return pvRet;
 }
 
-IMG_VOID
-_VFreeWrapper(IMG_VOID * pvCpuVAddr, IMG_CHAR * pszFileName,
-	      IMG_UINT32 ui32Line)
+void _VFreeWrapper(void *pvCpuVAddr, char *pszFileName,
+	      u32 ui32Line)
 {
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
 	DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_VMALLOC, pvCpuVAddr,
@@ -470,21 +445,19 @@
 	vfree(pvCpuVAddr);
 }
 
-LinuxMemArea *NewVMallocLinuxMemArea(IMG_UINT32 ui32Bytes,
-				     IMG_UINT32 ui32AreaFlags)
+struct LinuxMemArea *NewVMallocLinuxMemArea(u32 ui32Bytes,
+				     u32 ui32AreaFlags)
 {
-	LinuxMemArea *psLinuxMemArea;
-	IMG_VOID *pvCpuVAddr;
+	struct LinuxMemArea *psLinuxMemArea;
+	void *pvCpuVAddr;
 
 	psLinuxMemArea = LinuxMemAreaStructAlloc();
-	if (!psLinuxMemArea) {
+	if (!psLinuxMemArea)
 		goto failed;
-	}
 
 	pvCpuVAddr = VMallocWrapper(ui32Bytes, ui32AreaFlags);
-	if (!pvCpuVAddr) {
+	if (!pvCpuVAddr)
 		goto failed;
-	}
 
 	psLinuxMemArea->eAreaType = LINUX_MEM_AREA_VMALLOC;
 	psLinuxMemArea->uData.sVmalloc.pvVmallocAddress = pvCpuVAddr;
@@ -497,13 +470,13 @@
 	return psLinuxMemArea;
 
 failed:
-	PVR_DPF((PVR_DBG_ERROR, "%s: failed!", __FUNCTION__));
+	PVR_DPF(PVR_DBG_ERROR, "%s: failed!", __func__);
 	if (psLinuxMemArea)
 		LinuxMemAreaStructFree(psLinuxMemArea);
 	return NULL;
 }
 
-IMG_VOID FreeVMallocLinuxMemArea(LinuxMemArea * psLinuxMemArea)
+void FreeVMallocLinuxMemArea(struct LinuxMemArea *psLinuxMemArea)
 {
 	PVR_ASSERT(psLinuxMemArea);
 	PVR_ASSERT(psLinuxMemArea->eAreaType == LINUX_MEM_AREA_VMALLOC);
@@ -514,86 +487,77 @@
 #endif
 
 
-	PVR_DPF((PVR_DBG_MESSAGE, "%s: pvCpuVAddr: %p",
-		 __FUNCTION__,
-		 psLinuxMemArea->uData.sVmalloc.pvVmallocAddress));
+	PVR_DPF(PVR_DBG_MESSAGE, "%s: pvCpuVAddr: %p",
+		 __func__,
+		 psLinuxMemArea->uData.sVmalloc.pvVmallocAddress);
 	VFreeWrapper(psLinuxMemArea->uData.sVmalloc.pvVmallocAddress);
 
 	LinuxMemAreaStructFree(psLinuxMemArea);
 }
 
-
-IMG_VOID *_IORemapWrapper(IMG_CPU_PHYADDR BasePAddr,
-			  IMG_UINT32 ui32Bytes,
-			  IMG_UINT32 ui32MappingFlags,
-			  IMG_CHAR * pszFileName, IMG_UINT32 ui32Line)
+void __iomem *_IORemapWrapper(struct IMG_CPU_PHYADDR BasePAddr,
+			  u32 ui32Bytes, u32 ui32MappingFlags,
+			  char *pszFileName, u32 ui32Line)
 {
-	IMG_VOID *pvIORemapCookie = IMG_NULL;
+	void __iomem *pvIORemapCookie = NULL;
 
 	switch (ui32MappingFlags & PVRSRV_HAP_CACHETYPE_MASK) {
 	case PVRSRV_HAP_CACHED:
 #if defined(__arm__)
-		pvIORemapCookie =
-		    (IMG_VOID *) ioremap_cached(BasePAddr.uiAddr, ui32Bytes);
+		pvIORemapCookie = ioremap_cached(BasePAddr.uiAddr, ui32Bytes);
 #else
-		pvIORemapCookie =
-		    (IMG_VOID *) ioremap(BasePAddr.uiAddr, ui32Bytes);
+		pvIORemapCookie = ioremap(BasePAddr.uiAddr, ui32Bytes);
 #endif
 		break;
 	case PVRSRV_HAP_WRITECOMBINE:
 #if defined(__arm__)
-		pvIORemapCookie =
-		    (IMG_VOID *) ioremap_nocache(BasePAddr.uiAddr, ui32Bytes);
+		pvIORemapCookie = ioremap_nocache(BasePAddr.uiAddr, ui32Bytes);
 #else
-		pvIORemapCookie =
-		    (IMG_VOID *) ioremap_nocache(BasePAddr.uiAddr, ui32Bytes);
+		pvIORemapCookie = ioremap_nocache(BasePAddr.uiAddr, ui32Bytes);
 #endif
 		break;
 	case PVRSRV_HAP_UNCACHED:
-		pvIORemapCookie =
-		    (IMG_VOID *) ioremap_nocache(BasePAddr.uiAddr, ui32Bytes);
+		pvIORemapCookie = ioremap_nocache(BasePAddr.uiAddr, ui32Bytes);
 		break;
 	default:
-		PVR_DPF((PVR_DBG_ERROR,
-			 "IORemapWrapper: unknown mapping flags"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "IORemapWrapper: unknown mapping flags");
 		return NULL;
 	}
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-	if (pvIORemapCookie) {
+	if (pvIORemapCookie)
 		DebugMemAllocRecordAdd(DEBUG_MEM_ALLOC_TYPE_IOREMAP,
-				       pvIORemapCookie,
-				       pvIORemapCookie,
-				       BasePAddr.uiAddr,
-				       NULL, ui32Bytes, pszFileName, ui32Line);
-	}
+				       (void __force *)pvIORemapCookie,
+				       (void __force *)pvIORemapCookie,
+				       BasePAddr.uiAddr, NULL, ui32Bytes,
+				       pszFileName, ui32Line);
 #endif
 
 	return pvIORemapCookie;
 }
 
-IMG_VOID
-_IOUnmapWrapper(IMG_VOID * pvIORemapCookie, IMG_CHAR * pszFileName,
-		IMG_UINT32 ui32Line)
+void _IOUnmapWrapper(void __iomem *pvIORemapCookie, char *pszFileName,
+		u32 ui32Line)
 {
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-	DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_IOREMAP, pvIORemapCookie,
+	DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_IOREMAP,
+				  (void __force *)pvIORemapCookie,
 				  pszFileName, ui32Line);
 #endif
 	iounmap(pvIORemapCookie);
 }
 
-LinuxMemArea *NewIORemapLinuxMemArea(IMG_CPU_PHYADDR BasePAddr,
-				     IMG_UINT32 ui32Bytes,
-				     IMG_UINT32 ui32AreaFlags)
+struct LinuxMemArea *NewIORemapLinuxMemArea(struct IMG_CPU_PHYADDR BasePAddr,
+				     u32 ui32Bytes,
+				     u32 ui32AreaFlags)
 {
-	LinuxMemArea *psLinuxMemArea;
-	IMG_VOID *pvIORemapCookie;
+	struct LinuxMemArea *psLinuxMemArea;
+	void __iomem *pvIORemapCookie;
 
 	psLinuxMemArea = LinuxMemAreaStructAlloc();
-	if (!psLinuxMemArea) {
+	if (!psLinuxMemArea)
 		return NULL;
-	}
 
 	pvIORemapCookie = IORemapWrapper(BasePAddr, ui32Bytes, ui32AreaFlags);
 	if (!pvIORemapCookie) {
@@ -613,7 +577,7 @@
 	return psLinuxMemArea;
 }
 
-IMG_VOID FreeIORemapLinuxMemArea(LinuxMemArea * psLinuxMemArea)
+void FreeIORemapLinuxMemArea(struct LinuxMemArea *psLinuxMemArea)
 {
 	PVR_ASSERT(psLinuxMemArea->eAreaType == LINUX_MEM_AREA_IOREMAP);
 
@@ -626,29 +590,25 @@
 	LinuxMemAreaStructFree(psLinuxMemArea);
 }
 
-LinuxMemArea *NewExternalKVLinuxMemArea(IMG_SYS_PHYADDR * pBasePAddr,
-					IMG_VOID * pvCPUVAddr,
-					IMG_UINT32 ui32Bytes,
-					IMG_BOOL bPhysContig,
-					IMG_UINT32 ui32AreaFlags)
+struct LinuxMemArea *NewExternalKVLinuxMemArea(
+			struct IMG_SYS_PHYADDR *pBasePAddr, void *pvCPUVAddr,
+			u32 ui32Bytes, IMG_BOOL bPhysContig, u32 ui32AreaFlags)
 {
-	LinuxMemArea *psLinuxMemArea;
+	struct LinuxMemArea *psLinuxMemArea;
 
 	psLinuxMemArea = LinuxMemAreaStructAlloc();
-	if (!psLinuxMemArea) {
+	if (!psLinuxMemArea)
 		return NULL;
-	}
 
 	psLinuxMemArea->eAreaType = LINUX_MEM_AREA_EXTERNAL_KV;
 	psLinuxMemArea->uData.sExternalKV.pvExternalKV = pvCPUVAddr;
 	psLinuxMemArea->uData.sExternalKV.bPhysContig = bPhysContig;
-	if (bPhysContig) {
+	if (bPhysContig)
 		psLinuxMemArea->uData.sExternalKV.uPhysAddr.SysPhysAddr =
 		    *pBasePAddr;
-	} else {
+	else
 		psLinuxMemArea->uData.sExternalKV.uPhysAddr.pSysPhysAddr =
 		    pBasePAddr;
-	}
 	psLinuxMemArea->ui32ByteSize = ui32Bytes;
 
 #if defined(DEBUG_LINUX_MEM_AREAS)
@@ -658,7 +618,7 @@
 	return psLinuxMemArea;
 }
 
-IMG_VOID FreeExternalKVLinuxMemArea(LinuxMemArea * psLinuxMemArea)
+void FreeExternalKVLinuxMemArea(struct LinuxMemArea *psLinuxMemArea)
 {
 	PVR_ASSERT(psLinuxMemArea->eAreaType == LINUX_MEM_AREA_EXTERNAL_KV);
 
@@ -669,13 +629,12 @@
 	LinuxMemAreaStructFree(psLinuxMemArea);
 }
 
-LinuxMemArea *NewIOLinuxMemArea(IMG_CPU_PHYADDR BasePAddr,
-				IMG_UINT32 ui32Bytes, IMG_UINT32 ui32AreaFlags)
+struct LinuxMemArea *NewIOLinuxMemArea(struct IMG_CPU_PHYADDR BasePAddr,
+				u32 ui32Bytes, u32 ui32AreaFlags)
 {
-	LinuxMemArea *psLinuxMemArea = LinuxMemAreaStructAlloc();
-	if (!psLinuxMemArea) {
+	struct LinuxMemArea *psLinuxMemArea = LinuxMemAreaStructAlloc();
+	if (!psLinuxMemArea)
 		return NULL;
-	}
 
 	psLinuxMemArea->eAreaType = LINUX_MEM_AREA_IO;
 	psLinuxMemArea->uData.sIO.CPUPhysAddr.uiAddr = BasePAddr.uiAddr;
@@ -683,9 +642,8 @@
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
 	DebugMemAllocRecordAdd(DEBUG_MEM_ALLOC_TYPE_IO,
-			       (IMG_VOID *) BasePAddr.uiAddr,
-			       0,
-			       BasePAddr.uiAddr, NULL, ui32Bytes, "unknown", 0);
+			       (void *)BasePAddr.uiAddr, NULL, BasePAddr.uiAddr,
+			       NULL, ui32Bytes, "unknown", 0);
 #endif
 
 #if defined(DEBUG_LINUX_MEM_AREAS)
@@ -695,7 +653,7 @@
 	return psLinuxMemArea;
 }
 
-IMG_VOID FreeIOLinuxMemArea(LinuxMemArea * psLinuxMemArea)
+void FreeIOLinuxMemArea(struct LinuxMemArea *psLinuxMemArea)
 {
 	PVR_ASSERT(psLinuxMemArea->eAreaType == LINUX_MEM_AREA_IO);
 
@@ -705,45 +663,42 @@
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
 	DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_IO,
-				  (IMG_VOID *) psLinuxMemArea->uData.sIO.
+				  (void *)psLinuxMemArea->uData.sIO.
 				  CPUPhysAddr.uiAddr, __FILE__, __LINE__);
 #endif
 
 	LinuxMemAreaStructFree(psLinuxMemArea);
 }
 
-LinuxMemArea *NewAllocPagesLinuxMemArea(IMG_UINT32 ui32Bytes,
-					IMG_UINT32 ui32AreaFlags)
+struct LinuxMemArea *NewAllocPagesLinuxMemArea(u32 ui32Bytes,
+					u32 ui32AreaFlags)
 {
-	LinuxMemArea *psLinuxMemArea;
-	IMG_UINT32 ui32PageCount;
+	struct LinuxMemArea *psLinuxMemArea;
+	u32 ui32PageCount;
 	struct page **pvPageList;
-	IMG_UINT32 i;
+	u32 i;
 
 	psLinuxMemArea = LinuxMemAreaStructAlloc();
-	if (!psLinuxMemArea) {
+	if (!psLinuxMemArea)
 		goto failed_area_alloc;
-	}
 
 	ui32PageCount = RANGE_TO_PAGES(ui32Bytes);
 	pvPageList =
 	    VMallocWrapper(sizeof(void *) * ui32PageCount, PVRSRV_HAP_CACHED);
-	if (!pvPageList) {
+	if (!pvPageList)
 		goto failed_vmalloc;
-	}
 
 	for (i = 0; i < ui32PageCount; i++) {
 		pvPageList[i] = alloc_pages(GFP_KERNEL, 0);
-		if (!pvPageList[i]) {
+		if (!pvPageList[i])
 			goto failed_alloc_pages;
-		}
 
 	}
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
 	DebugMemAllocRecordAdd(DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES,
-			       pvPageList,
-			       0, 0, NULL, PAGE_ALIGN(ui32Bytes), "unknown", 0);
+			       pvPageList, NULL, 0, NULL, PAGE_ALIGN(ui32Bytes),
+			       "unknown", 0);
 #endif
 
 	psLinuxMemArea->eAreaType = LINUX_MEM_AREA_ALLOC_PAGES;
@@ -757,23 +712,22 @@
 	return psLinuxMemArea;
 
 failed_alloc_pages:
-	for (i--; i >= 0; i--) {
+	for (i--; i >= 0; i--)
 		__free_pages(pvPageList[i], 0);
-	}
 	VFreeWrapper(pvPageList);
 failed_vmalloc:
 	LinuxMemAreaStructFree(psLinuxMemArea);
 failed_area_alloc:
-	PVR_DPF((PVR_DBG_ERROR, "%s: failed", __FUNCTION__));
+	PVR_DPF(PVR_DBG_ERROR, "%s: failed", __func__);
 
 	return NULL;
 }
 
-IMG_VOID FreeAllocPagesLinuxMemArea(LinuxMemArea * psLinuxMemArea)
+void FreeAllocPagesLinuxMemArea(struct LinuxMemArea *psLinuxMemArea)
 {
-	IMG_UINT32 ui32PageCount;
+	u32 ui32PageCount;
 	struct page **pvPageList;
-	IMG_UINT32 i;
+	u32 i;
 
 	PVR_ASSERT(psLinuxMemArea);
 	PVR_ASSERT(psLinuxMemArea->eAreaType == LINUX_MEM_AREA_ALLOC_PAGES);
@@ -790,25 +744,24 @@
 				  __FILE__, __LINE__);
 #endif
 
-	for (i = 0; i < ui32PageCount; i++) {
+	for (i = 0; i < ui32PageCount; i++)
 		__free_pages(pvPageList[i], 0);
-	}
 	VFreeWrapper(psLinuxMemArea->uData.sPageList.pvPageList);
 
 	LinuxMemAreaStructFree(psLinuxMemArea);
 }
 
-struct page *LinuxMemAreaOffsetToPage(LinuxMemArea * psLinuxMemArea,
-				      IMG_UINT32 ui32ByteOffset)
+struct page *LinuxMemAreaOffsetToPage(struct LinuxMemArea *psLinuxMemArea,
+				      u32 ui32ByteOffset)
 {
-	IMG_UINT32 ui32PageIndex;
-	IMG_CHAR *pui8Addr;
+	u32 ui32PageIndex;
+	char *pui8Addr;
 
 	switch (psLinuxMemArea->eAreaType) {
 	case LINUX_MEM_AREA_ALLOC_PAGES:
 		ui32PageIndex = PHYS_TO_PFN(ui32ByteOffset);
-		return psLinuxMemArea->uData.sPageList.
-		    pvPageList[ui32PageIndex];
+		return
+		     psLinuxMemArea->uData.sPageList.pvPageList[ui32PageIndex];
 		break;
 	case LINUX_MEM_AREA_VMALLOC:
 		pui8Addr = psLinuxMemArea->uData.sVmalloc.pvVmallocAddress;
@@ -816,23 +769,24 @@
 		return vmalloc_to_page(pui8Addr);
 		break;
 	case LINUX_MEM_AREA_SUB_ALLOC:
-		return LinuxMemAreaOffsetToPage(psLinuxMemArea->uData.sSubAlloc.
-						psParentLinuxMemArea,
-						psLinuxMemArea->uData.sSubAlloc.
-						ui32ByteOffset +
+		return LinuxMemAreaOffsetToPage(psLinuxMemArea->
+				     uData.sSubAlloc.psParentLinuxMemArea,
+				     psLinuxMemArea->
+						uData.sSubAlloc.ui32ByteOffset +
 						ui32ByteOffset);
 	default:
-		PVR_DPF((PVR_DBG_ERROR,
-			 "%s: Unsupported request for struct page from LinuxMemArea with type=%s",
-			 LinuxMemAreaTypeToString(psLinuxMemArea->eAreaType)));
+		PVR_DPF(PVR_DBG_ERROR, "%s: Unsupported request for "
+					"struct page from Linux memory "
+					"area with type=%s",
+			 LinuxMemAreaTypeToString(psLinuxMemArea->eAreaType));
 		return NULL;
 	}
 }
 
-IMG_VOID *_KMapWrapper(struct page * psPage, IMG_CHAR * pszFileName,
-		       IMG_UINT32 ui32Line)
+void *_KMapWrapper(struct page *psPage, char *pszFileName,
+		       u32 ui32Line)
 {
-	IMG_VOID *pvRet;
+	void *pvRet;
 
 
 	flush_cache_all();
@@ -840,19 +794,17 @@
 	pvRet = kmap(psPage);
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-	if (pvRet) {
+	if (pvRet)
 		DebugMemAllocRecordAdd(DEBUG_MEM_ALLOC_TYPE_KMAP,
 				       psPage,
 				       pvRet, 0, NULL, PAGE_SIZE, "unknown", 0);
-	}
 #endif
 
 	return pvRet;
 }
 
-IMG_VOID
-_KUnMapWrapper(struct page * psPage, IMG_CHAR * pszFileName,
-	       IMG_UINT32 ui32Line)
+void _KUnMapWrapper(struct page *psPage, char *pszFileName,
+	       u32 ui32Line)
 {
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
 	DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_KMAP, psPage,
@@ -862,24 +814,23 @@
 	kunmap(psPage);
 }
 
-LinuxKMemCache *KMemCacheCreateWrapper(IMG_CHAR * pszName,
+struct kmem_cache *KMemCacheCreateWrapper(char *pszName,
 				       size_t Size,
-				       size_t Align, IMG_UINT32 ui32Flags)
+				       size_t Align, u32 ui32Flags)
 {
-	return kmem_cache_create(pszName, Size, Align, ui32Flags, NULL
-	    );
+	return kmem_cache_create(pszName, Size, Align, ui32Flags, NULL);
 }
 
-IMG_VOID KMemCacheDestroyWrapper(LinuxKMemCache * psCache)
+void KMemCacheDestroyWrapper(struct kmem_cache *psCache)
 {
 	kmem_cache_destroy(psCache);
 }
 
-IMG_VOID *_KMemCacheAllocWrapper(LinuxKMemCache * psCache,
+void *_KMemCacheAllocWrapper(struct kmem_cache *psCache,
 				 gfp_t Flags,
-				 IMG_CHAR * pszFileName, IMG_UINT32 ui32Line)
+				 char *pszFileName, u32 ui32Line)
 {
-	IMG_VOID *pvRet;
+	void *pvRet;
 
 	pvRet = kmem_cache_alloc(psCache, Flags);
 
@@ -895,9 +846,8 @@
 	return pvRet;
 }
 
-IMG_VOID
-_KMemCacheFreeWrapper(LinuxKMemCache * psCache, IMG_VOID * pvObject,
-		      IMG_CHAR * pszFileName, IMG_UINT32 ui32Line)
+void _KMemCacheFreeWrapper(struct kmem_cache *psCache, void *pvObject,
+		      char *pszFileName, u32 ui32Line)
 {
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
 	DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE, pvObject,
@@ -907,25 +857,24 @@
 	kmem_cache_free(psCache, pvObject);
 }
 
-const IMG_CHAR *KMemCacheNameWrapper(LinuxKMemCache * psCache)
+const char *KMemCacheNameWrapper(struct kmem_cache *psCache)
 {
 
 	return "";
 }
 
-LinuxMemArea *NewSubLinuxMemArea(LinuxMemArea * psParentLinuxMemArea,
-				 IMG_UINT32 ui32ByteOffset,
-				 IMG_UINT32 ui32Bytes)
+struct LinuxMemArea *NewSubLinuxMemArea(struct LinuxMemArea
+				*psParentLinuxMemArea, u32 ui32ByteOffset,
+				u32 ui32Bytes)
 {
-	LinuxMemArea *psLinuxMemArea;
+	struct LinuxMemArea *psLinuxMemArea;
 
 	PVR_ASSERT((ui32ByteOffset + ui32Bytes) <=
 		   psParentLinuxMemArea->ui32ByteSize);
 
 	psLinuxMemArea = LinuxMemAreaStructAlloc();
-	if (!psLinuxMemArea) {
+	if (!psLinuxMemArea)
 		return NULL;
-	}
 
 	psLinuxMemArea->eAreaType = LINUX_MEM_AREA_SUB_ALLOC;
 	psLinuxMemArea->uData.sSubAlloc.psParentLinuxMemArea =
@@ -935,7 +884,7 @@
 
 #if defined(DEBUG_LINUX_MEM_AREAS)
 	{
-		DEBUG_LINUX_MEM_AREA_REC *psParentRecord;
+		struct DEBUG_LINUX_MEM_AREA_REC *psParentRecord;
 		psParentRecord =
 		    DebugLinuxMemAreaRecordFind(psParentLinuxMemArea);
 		DebugLinuxMemAreaRecordAdd(psLinuxMemArea,
@@ -946,7 +895,7 @@
 	return psLinuxMemArea;
 }
 
-IMG_VOID FreeSubLinuxMemArea(LinuxMemArea * psLinuxMemArea)
+static void FreeSubLinuxMemArea(struct LinuxMemArea *psLinuxMemArea)
 {
 	PVR_ASSERT(psLinuxMemArea->eAreaType == LINUX_MEM_AREA_SUB_ALLOC);
 
@@ -957,18 +906,18 @@
 	LinuxMemAreaStructFree(psLinuxMemArea);
 }
 
-static LinuxMemArea *LinuxMemAreaStructAlloc(IMG_VOID)
+static struct LinuxMemArea *LinuxMemAreaStructAlloc(void)
 {
 	return KMemCacheAllocWrapper(psLinuxMemAreaCache, GFP_KERNEL);
 }
 
-static IMG_VOID LinuxMemAreaStructFree(LinuxMemArea * psLinuxMemArea)
+static void LinuxMemAreaStructFree(struct LinuxMemArea *psLinuxMemArea)
 {
 	KMemCacheFreeWrapper(psLinuxMemAreaCache, psLinuxMemArea);
 
 }
 
-IMG_VOID LinuxMemAreaDeepFree(LinuxMemArea * psLinuxMemArea)
+void LinuxMemAreaDeepFree(struct LinuxMemArea *psLinuxMemArea)
 {
 	switch (psLinuxMemArea->eAreaType) {
 	case LINUX_MEM_AREA_VMALLOC:
@@ -990,27 +939,27 @@
 		FreeSubLinuxMemArea(psLinuxMemArea);
 		break;
 	default:
-		PVR_DPF((PVR_DBG_ERROR, "%s: Unknown are type (%d)\n",
-			 __FUNCTION__, psLinuxMemArea->eAreaType));
+		PVR_DPF(PVR_DBG_ERROR, "%s: Unknown are type (%d)\n",
+			 __func__, psLinuxMemArea->eAreaType);
 	}
 }
 
 #if defined(DEBUG_LINUX_MEM_AREAS)
-static IMG_VOID
-DebugLinuxMemAreaRecordAdd(LinuxMemArea * psLinuxMemArea, IMG_UINT32 ui32Flags)
+static void DebugLinuxMemAreaRecordAdd(struct LinuxMemArea *psLinuxMemArea,
+				       u32 ui32Flags)
 {
-	DEBUG_LINUX_MEM_AREA_REC *psNewRecord;
+	struct DEBUG_LINUX_MEM_AREA_REC *psNewRecord;
 	const char *pi8FlagsString;
 
 	if (psLinuxMemArea->eAreaType != LINUX_MEM_AREA_SUB_ALLOC) {
 		g_LinuxMemAreaWaterMark += psLinuxMemArea->ui32ByteSize;
-		if (g_LinuxMemAreaWaterMark > g_LinuxMemAreaHighWaterMark) {
+		if (g_LinuxMemAreaWaterMark > g_LinuxMemAreaHighWaterMark)
 			g_LinuxMemAreaHighWaterMark = g_LinuxMemAreaWaterMark;
-		}
 	}
 	g_LinuxMemAreaCount++;
 
-	psNewRecord = kmalloc(sizeof(DEBUG_LINUX_MEM_AREA_REC), GFP_KERNEL);
+	psNewRecord = kmalloc(sizeof(struct DEBUG_LINUX_MEM_AREA_REC),
+			      GFP_KERNEL);
 	if (psNewRecord) {
 
 		psNewRecord->psLinuxMemArea = psLinuxMemArea;
@@ -1019,92 +968,88 @@
 		psNewRecord->psNext = g_LinuxMemAreaRecords;
 		g_LinuxMemAreaRecords = psNewRecord;
 	} else {
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "%s: failed to allocate linux memory area record.",
-			 __FUNCTION__));
+			 __func__);
 	}
 
 	pi8FlagsString = HAPFlagsToString(ui32Flags);
-	if (strstr(pi8FlagsString, "UNKNOWN")) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "%s: Unexpected flags (0x%08lx) associated with psLinuxMemArea @ 0x%08lx",
-			 __FUNCTION__, ui32Flags, psLinuxMemArea));
-
-	}
+	if (strstr(pi8FlagsString, "UNKNOWN"))
+		PVR_DPF(PVR_DBG_ERROR, "%s: Unexpected flags (0x%08lx) "
+			"associated with psLinuxMemArea @ 0x%08lx",
+			 __func__, ui32Flags, psLinuxMemArea);
 }
 
-static DEBUG_LINUX_MEM_AREA_REC *DebugLinuxMemAreaRecordFind(LinuxMemArea *
-							     psLinuxMemArea)
+static struct DEBUG_LINUX_MEM_AREA_REC *DebugLinuxMemAreaRecordFind(
+					   struct LinuxMemArea *psLinuxMemArea)
 {
-	DEBUG_LINUX_MEM_AREA_REC *psCurrentRecord;
+	struct DEBUG_LINUX_MEM_AREA_REC *psCurrentRecord;
 
 	for (psCurrentRecord = g_LinuxMemAreaRecords;
 	     psCurrentRecord; psCurrentRecord = psCurrentRecord->psNext) {
-		if (psCurrentRecord->psLinuxMemArea == psLinuxMemArea) {
+		if (psCurrentRecord->psLinuxMemArea == psLinuxMemArea)
 			return psCurrentRecord;
-		}
+
 	}
 	return NULL;
 }
 
-static IMG_VOID DebugLinuxMemAreaRecordRemove(LinuxMemArea * psLinuxMemArea)
+static void DebugLinuxMemAreaRecordRemove(struct LinuxMemArea *psLinuxMemArea)
 {
-	DEBUG_LINUX_MEM_AREA_REC **ppsCurrentRecord;
+	struct DEBUG_LINUX_MEM_AREA_REC **ppsCurrentRecord;
 
-	if (psLinuxMemArea->eAreaType != LINUX_MEM_AREA_SUB_ALLOC) {
+	if (psLinuxMemArea->eAreaType != LINUX_MEM_AREA_SUB_ALLOC)
 		g_LinuxMemAreaWaterMark -= psLinuxMemArea->ui32ByteSize;
-	}
 	g_LinuxMemAreaCount--;
 
 	for (ppsCurrentRecord = &g_LinuxMemAreaRecords;
 	     *ppsCurrentRecord;
-	     ppsCurrentRecord = &((*ppsCurrentRecord)->psNext)) {
+	     ppsCurrentRecord = &((*ppsCurrentRecord)->psNext))
 		if ((*ppsCurrentRecord)->psLinuxMemArea == psLinuxMemArea) {
-			DEBUG_LINUX_MEM_AREA_REC *psNextRecord;
+			struct DEBUG_LINUX_MEM_AREA_REC *psNextRecord;
 
 			psNextRecord = (*ppsCurrentRecord)->psNext;
 			kfree(*ppsCurrentRecord);
 			*ppsCurrentRecord = psNextRecord;
 			return;
 		}
-	}
 
-	PVR_DPF((PVR_DBG_ERROR,
+	PVR_DPF(PVR_DBG_ERROR,
 		 "%s: couldn't find an entry for psLinuxMemArea=%p\n",
-		 __FUNCTION__, psLinuxMemArea));
+		 __func__, psLinuxMemArea);
 }
 #endif
 
-IMG_VOID *LinuxMemAreaToCpuVAddr(LinuxMemArea * psLinuxMemArea)
+void *LinuxMemAreaToCpuVAddr(struct LinuxMemArea *psLinuxMemArea)
 {
 	switch (psLinuxMemArea->eAreaType) {
 	case LINUX_MEM_AREA_VMALLOC:
 		return psLinuxMemArea->uData.sVmalloc.pvVmallocAddress;
 	case LINUX_MEM_AREA_IOREMAP:
-		return psLinuxMemArea->uData.sIORemap.pvIORemapCookie;
+		return (void __force *)
+			psLinuxMemArea->uData.sIORemap.pvIORemapCookie;
 	case LINUX_MEM_AREA_EXTERNAL_KV:
 		return psLinuxMemArea->uData.sExternalKV.pvExternalKV;
 	case LINUX_MEM_AREA_SUB_ALLOC:
 		{
-			IMG_CHAR *pAddr =
+			char *pAddr =
 			    LinuxMemAreaToCpuVAddr(psLinuxMemArea->uData.
 						   sSubAlloc.
 						   psParentLinuxMemArea);
-			if (!pAddr) {
+			if (!pAddr)
 				return NULL;
-			}
 			return pAddr +
-			    psLinuxMemArea->uData.sSubAlloc.ui32ByteOffset;
+			       psLinuxMemArea->uData.sSubAlloc.ui32ByteOffset;
 		}
 	default:
 		return NULL;
 	}
 }
 
-IMG_CPU_PHYADDR
-LinuxMemAreaToCpuPAddr(LinuxMemArea * psLinuxMemArea, IMG_UINT32 ui32ByteOffset)
+struct IMG_CPU_PHYADDR LinuxMemAreaToCpuPAddr(struct LinuxMemArea
+					   *psLinuxMemArea, u32 ui32ByteOffset)
 {
-	IMG_CPU_PHYADDR CpuPAddr;
+	struct IMG_CPU_PHYADDR CpuPAddr;
 
 	CpuPAddr.uiAddr = 0;
 
@@ -1124,9 +1069,9 @@
 							  SysPhysAddr);
 				CpuPAddr.uiAddr += ui32ByteOffset;
 			} else {
-				IMG_UINT32 ui32PageIndex =
+				u32 ui32PageIndex =
 				    PHYS_TO_PFN(ui32ByteOffset);
-				IMG_SYS_PHYADDR SysPAddr =
+				struct IMG_SYS_PHYADDR SysPAddr =
 				    psLinuxMemArea->uData.sExternalKV.uPhysAddr.
 				    pSysPhysAddr[ui32PageIndex];
 
@@ -1144,9 +1089,9 @@
 		}
 	case LINUX_MEM_AREA_VMALLOC:
 		{
-			IMG_CHAR *pCpuVAddr;
+			char *pCpuVAddr;
 			pCpuVAddr =
-			    (IMG_CHAR *) psLinuxMemArea->uData.sVmalloc.
+			    (char *) psLinuxMemArea->uData.sVmalloc.
 			    pvVmallocAddress;
 			pCpuVAddr += ui32ByteOffset;
 			CpuPAddr.uiAddr = VMallocToPhys(pCpuVAddr);
@@ -1155,7 +1100,7 @@
 	case LINUX_MEM_AREA_ALLOC_PAGES:
 		{
 			struct page *page;
-			IMG_UINT32 ui32PageIndex = PHYS_TO_PFN(ui32ByteOffset);
+			u32 ui32PageIndex = PHYS_TO_PFN(ui32ByteOffset);
 			page =
 			    psLinuxMemArea->uData.sPageList.
 			    pvPageList[ui32PageIndex];
@@ -1175,15 +1120,16 @@
 			break;
 		}
 	default:
-		PVR_DPF((PVR_DBG_ERROR, "%s: Unknown LinuxMemArea type (%d)\n",
-			 __FUNCTION__, psLinuxMemArea->eAreaType));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "%s: Unknown Linux memory area type (%d)\n",
+			 __func__, psLinuxMemArea->eAreaType);
 	}
 
 	PVR_ASSERT(CpuPAddr.uiAddr);
 	return CpuPAddr;
 }
 
-IMG_BOOL LinuxMemAreaPhysIsContig(LinuxMemArea * psLinuxMemArea)
+IMG_BOOL LinuxMemAreaPhysIsContig(struct LinuxMemArea *psLinuxMemArea)
 {
 	switch (psLinuxMemArea->eAreaType) {
 	case LINUX_MEM_AREA_IOREMAP:
@@ -1198,30 +1144,31 @@
 		return IMG_FALSE;
 
 	case LINUX_MEM_AREA_SUB_ALLOC:
-		PVR_DPF((PVR_DBG_WARNING,
-			 "%s is meaningless for LinuxMemArea type (%d)",
-			 __FUNCTION__, psLinuxMemArea->eAreaType));
+		PVR_DPF(PVR_DBG_WARNING,
+			 "%s is meaningless for Linux memory area type (%d)",
+			 __func__, psLinuxMemArea->eAreaType);
 		break;
 
 	default:
-		PVR_DPF((PVR_DBG_ERROR, "%s: Unknown LinuxMemArea type (%d)\n",
-			 __FUNCTION__, psLinuxMemArea->eAreaType));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "%s: Unknown Linux memory area type (%d)\n",
+			 __func__, psLinuxMemArea->eAreaType);
 		break;
 	}
 	return IMG_FALSE;
 }
 
-LINUX_MEM_AREA_TYPE LinuxMemAreaRootType(LinuxMemArea * psLinuxMemArea)
+enum LINUX_MEM_AREA_TYPE LinuxMemAreaRootType(struct LinuxMemArea
+							    *psLinuxMemArea)
 {
-	if (psLinuxMemArea->eAreaType == LINUX_MEM_AREA_SUB_ALLOC) {
-		return LinuxMemAreaRootType(psLinuxMemArea->uData.sSubAlloc.
-					    psParentLinuxMemArea);
-	} else {
+	if (psLinuxMemArea->eAreaType == LINUX_MEM_AREA_SUB_ALLOC)
+		return LinuxMemAreaRootType(
+			psLinuxMemArea->uData.sSubAlloc.psParentLinuxMemArea);
+	else
 		return psLinuxMemArea->eAreaType;
-	}
 }
 
-const IMG_CHAR *LinuxMemAreaTypeToString(LINUX_MEM_AREA_TYPE eMemAreaType)
+const char *LinuxMemAreaTypeToString(enum LINUX_MEM_AREA_TYPE eMemAreaType)
 {
 
 	switch (eMemAreaType) {
@@ -1247,7 +1194,7 @@
 #if defined(DEBUG_LINUX_MEM_AREAS)
 static off_t printLinuxMemAreaRecords(char *buffer, size_t count, off_t off)
 {
-	DEBUG_LINUX_MEM_AREA_REC *psRecord;
+	struct DEBUG_LINUX_MEM_AREA_REC *psRecord;
 	off_t Ret;
 
 	LinuxLockMutex(&gPVRSRVLock);
@@ -1258,23 +1205,26 @@
 			goto unlock_and_return;
 		}
 		Ret = printAppend(buffer, count, 0,
-				  "Number of Linux Memory Areas: %lu\n"
-				  "At the current water mark these areas correspond to %lu bytes (excluding SUB areas)\n"
-				  "At the highest water mark these areas corresponded to %lu bytes (excluding SUB areas)\n"
-				  "\nDetails for all Linux Memory Areas:\n"
-				  "%s %-24s %s %s %-8s %-5s %s\n",
-				  g_LinuxMemAreaCount,
-				  g_LinuxMemAreaWaterMark,
-				  g_LinuxMemAreaHighWaterMark,
-				  "psLinuxMemArea",
-				  "LinuxMemType",
-				  "CpuVAddr",
-				  "CpuPAddr", "Bytes", "Pid", "Flags");
+			  "Number of Linux Memory Areas: %u\n"
+			  "At the current water mark these areas "
+			  "correspond to %u bytes (excluding SUB areas)\n"
+			  "At the highest water mark these areas "
+			  "corresponded to %u bytes (excluding SUB areas)\n"
+			  "\nDetails for all Linux Memory Areas:\n"
+			  "%s %-24s %s %s %-8s %-5s %s\n",
+			  g_LinuxMemAreaCount,
+			  g_LinuxMemAreaWaterMark,
+			  g_LinuxMemAreaHighWaterMark,
+			  "psLinuxMemArea",
+			  "LinuxMemType",
+			  "CpuVAddr",
+			  "CpuPAddr", "Bytes", "Pid", "Flags");
 		goto unlock_and_return;
 	}
 
 	for (psRecord = g_LinuxMemAreaRecords; --off && psRecord;
-	     psRecord = psRecord->psNext) ;
+	     psRecord = psRecord->psNext)
+		;
 	if (!psRecord) {
 		Ret = END_OF_FILE;
 		goto unlock_and_return;
@@ -1286,7 +1236,7 @@
 	}
 
 	Ret = printAppend(buffer, count, 0,
-			  "%8p       %-24s %8p %08lx %-8ld %-5u %08lx=(%s)\n",
+			  "%8p       %-24s %8p %08x %-8d %-5u %08x=(%s)\n",
 			  psRecord->psLinuxMemArea,
 			  LinuxMemAreaTypeToString(psRecord->psLinuxMemArea->
 						   eAreaType),
@@ -1308,7 +1258,7 @@
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
 static off_t printMemoryRecords(char *buffer, size_t count, off_t off)
 {
-	DEBUG_MEM_ALLOC_REC *psRecord;
+	struct DEBUG_MEM_ALLOC_REC *psRecord;
 	off_t Ret;
 
 	LinuxLockMutex(&gPVRSRVLock);
@@ -1319,89 +1269,67 @@
 			goto unlock_and_return;
 		}
 
-		Ret = printAppend(buffer, count, 0, "%-60s: %ld bytes\n",
-				  "Current Water Mark of bytes allocated via kmalloc",
-				  g_WaterMarkData
-				  [DEBUG_MEM_ALLOC_TYPE_KMALLOC]);
-		Ret =
-		    printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
-				"Highest Water Mark of bytes allocated via kmalloc",
-				g_HighWaterMarkData
-				[DEBUG_MEM_ALLOC_TYPE_KMALLOC]);
-		Ret =
-		    printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
-				"Current Water Mark of bytes allocated via vmalloc",
-				g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_VMALLOC]);
-		Ret =
-		    printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
-				"Highest Water Mark of bytes allocated via vmalloc",
-				g_HighWaterMarkData
-				[DEBUG_MEM_ALLOC_TYPE_VMALLOC]);
-		Ret =
-		    printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
-				"Current Water Mark of bytes allocated via alloc_pages",
-				g_WaterMarkData
-				[DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES]);
-		Ret =
-		    printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
-				"Highest Water Mark of bytes allocated via alloc_pages",
-				g_HighWaterMarkData
-				[DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES]);
-		Ret =
-		    printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
-				"Current Water Mark of bytes allocated via ioremap",
-				g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_IOREMAP]);
-		Ret =
-		    printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
-				"Highest Water Mark of bytes allocated via ioremap",
-				g_HighWaterMarkData
-				[DEBUG_MEM_ALLOC_TYPE_IOREMAP]);
-		Ret =
-		    printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
-				"Current Water Mark of bytes reserved for \"IO\" memory areas",
-				g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_IO]);
-		Ret =
-		    printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
-				"Highest Water Mark of bytes allocated for \"IO\" memory areas",
-				g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_IO]);
-		Ret =
-		    printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
-				"Current Water Mark of bytes allocated via kmem_cache_alloc",
-				g_WaterMarkData
-				[DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE]);
-		Ret =
-		    printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
-				"Highest Water Mark of bytes allocated via kmem_cache_alloc",
-				g_HighWaterMarkData
-				[DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE]);
-		Ret =
-		    printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
-				"Current Water Mark of bytes mapped via kmap",
-				g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_KMAP]);
-		Ret =
-		    printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
-				"Highest Water Mark of bytes mapped via kmap",
-				g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_KMAP]);
-
-		Ret = printAppend(buffer, count, Ret, "\n");
-
-		Ret = printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
-				  "The Current Water Mark for memory allocated from system RAM",
-				  g_SysRAMWaterMark);
-		Ret = printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
-				  "The Highest Water Mark for memory allocated from system RAM",
-				  g_SysRAMHighWaterMark);
-		Ret = printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
-				  "The Current Water Mark for memory allocated from IO memory",
-				  g_IOMemWaterMark);
-		Ret = printAppend(buffer, count, Ret, "%-60s: %ld bytes\n",
-				  "The Highest Water Mark for memory allocated from IO memory",
-				  g_IOMemHighWaterMark);
+		Ret = printAppend(buffer, count, 0, "%-60s: %d bytes\n",
+			  "Current Water Mark of bytes allocated via kmalloc",
+			  g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_KMALLOC]);
+		Ret = printAppend(buffer, count, Ret, "%-60s: %d bytes\n",
+			"Highest Water Mark of bytes allocated via kmalloc",
+			g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_KMALLOC]);
+		Ret = printAppend(buffer, count, Ret, "%-60s: %d bytes\n",
+			"Current Water Mark of bytes allocated via vmalloc",
+			g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_VMALLOC]);
+		Ret = printAppend(buffer, count, Ret, "%-60s: %d bytes\n",
+			"Highest Water Mark of bytes allocated via vmalloc",
+			g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_VMALLOC]);
+		Ret = printAppend(buffer, count, Ret, "%-60s: %d bytes\n",
+		"Current Water Mark of bytes allocated via alloc_pages",
+		g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES]);
+	Ret = printAppend(buffer, count, Ret, "%-60s: %d bytes\n",
+		"Highest Water Mark of bytes allocated via alloc_pages",
+		g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES]);
+	Ret = printAppend(buffer, count, Ret, "%-60s: %d bytes\n",
+		"Current Water Mark of bytes allocated via ioremap",
+		g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_IOREMAP]);
+	Ret = printAppend(buffer, count, Ret, "%-60s: %d bytes\n",
+		"Highest Water Mark of bytes allocated via ioremap",
+		g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_IOREMAP]);
+	Ret = printAppend(buffer, count, Ret, "%-60s: %d bytes\n",
+		"Current Water Mark of bytes reserved for \"IO\" memory areas",
+		g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_IO]);
+	Ret = printAppend(buffer, count, Ret, "%-60s: %d bytes\n",
+		"Highest Water Mark of bytes allocated for \"IO\" memory areas",
+		g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_IO]);
+	Ret = printAppend(buffer, count, Ret, "%-60s: %d bytes\n",
+		"Current Water Mark of bytes allocated via kmem_cache_alloc",
+		g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE]);
+	Ret = printAppend(buffer, count, Ret, "%-60s: %d bytes\n",
+		"Highest Water Mark of bytes allocated via kmem_cache_alloc",
+		g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE]);
+	Ret = printAppend(buffer, count, Ret, "%-60s: %d bytes\n",
+		"Current Water Mark of bytes mapped via kmap",
+		g_WaterMarkData[DEBUG_MEM_ALLOC_TYPE_KMAP]);
+	Ret = printAppend(buffer, count, Ret, "%-60s: %d bytes\n",
+		"Highest Water Mark of bytes mapped via kmap",
+		g_HighWaterMarkData[DEBUG_MEM_ALLOC_TYPE_KMAP]);
+
+	Ret = printAppend(buffer, count, Ret, "\n");
+
+	Ret = printAppend(buffer, count, Ret, "%-60s: %d bytes\n",
+		  "The Current Water Mark for memory allocated from system RAM",
+		  g_SysRAMWaterMark);
+	Ret = printAppend(buffer, count, Ret, "%-60s: %d bytes\n",
+		  "The Highest Water Mark for memory allocated from system RAM",
+		  g_SysRAMHighWaterMark);
+	Ret = printAppend(buffer, count, Ret, "%-60s: %d bytes\n",
+		  "The Current Water Mark for memory allocated from IO memory",
+		  g_IOMemWaterMark);
+	Ret = printAppend(buffer, count, Ret, "%-60s: %d bytes\n",
+		  "The Highest Water Mark for memory allocated from IO memory",
+		  g_IOMemHighWaterMark);
 
 		Ret = printAppend(buffer, count, Ret, "\n");
 
-		Ret =
-		    printAppend(buffer, count, Ret,
+		Ret = printAppend(buffer, count, Ret,
 				"Details for all known allocations:\n"
 				"%-16s %-8s %-8s %-10s %-5s %-10s %s\n", "Type",
 				"CpuVAddr", "CpuPAddr", "Bytes", "PID",
@@ -1417,30 +1345,28 @@
 	}
 
 	for (psRecord = g_MemoryRecords; --off && psRecord;
-	     psRecord = psRecord->psNext) ;
+	     psRecord = psRecord->psNext)
+		;
 	if (!psRecord) {
 		Ret = END_OF_FILE;
 		goto unlock_and_return;
 	}
 
-	if (psRecord->eAllocType != DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE) {
+	if (psRecord->eAllocType != DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE)
 		Ret = printAppend(buffer, count, 0,
-				  "%-16s %-8p %08lx %-10ld %-5d %-10s %s:%ld\n",
-				  DebugMemAllocRecordTypeToString(psRecord->
-								  eAllocType),
-				  psRecord->pvCpuVAddr, psRecord->ulCpuPAddr,
-				  psRecord->ui32Bytes, psRecord->pid, "NULL",
-				  psRecord->pszFileName, psRecord->ui32Line);
-	} else {
+				  "%-16s %-8p %08lx %-10d %-5d %-10s %s:%d\n",
+			 DebugMemAllocRecordTypeToString(psRecord->eAllocType),
+			 psRecord->pvCpuVAddr, psRecord->ulCpuPAddr,
+			 psRecord->ui32Bytes, psRecord->pid, "NULL",
+			 psRecord->pszFileName, psRecord->ui32Line);
+	else
 		Ret = printAppend(buffer, count, 0,
-				  "%-16s %-8p %08lx %-10ld %-5d %-10s %s:%ld\n",
-				  DebugMemAllocRecordTypeToString(psRecord->
-								  eAllocType),
-				  psRecord->pvCpuVAddr, psRecord->ulCpuPAddr,
-				  psRecord->ui32Bytes, psRecord->pid,
-				  KMemCacheNameWrapper(psRecord->pvPrivateData),
-				  psRecord->pszFileName, psRecord->ui32Line);
-	}
+			  "%-16s %-8p %08lx %-10d %-5d %-10s %s:%d\n",
+			  DebugMemAllocRecordTypeToString(psRecord->eAllocType),
+			  psRecord->pvCpuVAddr, psRecord->ulCpuPAddr,
+			  psRecord->ui32Bytes, psRecord->pid,
+			  KMemCacheNameWrapper(psRecord->pvPrivateData),
+			  psRecord->pszFileName, psRecord->ui32Line);
 
 unlock_and_return:
 
@@ -1450,18 +1376,18 @@
 #endif
 
 #if defined(DEBUG_LINUX_MEM_AREAS) || defined(DEBUG_LINUX_MMAP_AREAS)
-const IMG_CHAR *HAPFlagsToString(IMG_UINT32 ui32Flags)
+const char *HAPFlagsToString(u32 ui32Flags)
 {
-	static IMG_CHAR szFlags[50];
-	IMG_UINT32 ui32Pos = 0;
-	IMG_UINT32 ui32CacheTypeIndex, ui32MapTypeIndex;
-	IMG_CHAR *apszCacheTypes[] = {
+	static char szFlags[50];
+	u32 ui32Pos = 0;
+	u32 ui32CacheTypeIndex, ui32MapTypeIndex;
+	char *apszCacheTypes[] = {
 		"UNCACHED",
 		"CACHED",
 		"WRITECOMBINE",
 		"UNKNOWN"
 	};
-	IMG_CHAR *apszMapType[] = {
+	char *apszMapType[] = {
 		"KERNEL_ONLY",
 		"SINGLE_PROCESS",
 		"MULTI_PROCESS",
@@ -1478,9 +1404,9 @@
 		ui32CacheTypeIndex = 2;
 	} else {
 		ui32CacheTypeIndex = 3;
-		PVR_DPF((PVR_DBG_ERROR, "%s: unknown cache type (%d)",
-			 __FUNCTION__,
-			 (ui32Flags & PVRSRV_HAP_CACHETYPE_MASK)));
+		PVR_DPF(PVR_DBG_ERROR, "%s: unknown cache type (%d)",
+			 __func__,
+			 (ui32Flags & PVRSRV_HAP_CACHETYPE_MASK));
 	}
 
 	if (ui32Flags & PVRSRV_HAP_KERNEL_ONLY) {
@@ -1495,8 +1421,8 @@
 		ui32MapTypeIndex = 4;
 	} else {
 		ui32MapTypeIndex = 5;
-		PVR_DPF((PVR_DBG_ERROR, "%s: unknown map type (%d)",
-			 __FUNCTION__, (ui32Flags & PVRSRV_HAP_MAPTYPE_MASK)));
+		PVR_DPF(PVR_DBG_ERROR, "%s: unknown map type (%d)",
+			 __func__, (ui32Flags & PVRSRV_HAP_MAPTYPE_MASK));
 	}
 
 	ui32Pos = sprintf(szFlags, "%s|", apszCacheTypes[ui32CacheTypeIndex]);
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/mm.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/mm.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -35,7 +35,7 @@
 #include <linux/slab.h>
 #include <linux/mm.h>
 
-#include <asm/io.h>
+#include <linux/io.h>
 
 #define	PHYS_TO_PFN(phys) ((phys) >> PAGE_SHIFT)
 #define PFN_TO_PHYS(pfn) ((pfn) << PAGE_SHIFT)
@@ -44,18 +44,20 @@
 
 #define	ADDR_TO_PAGE_OFFSET(addr) (((unsigned long)(addr)) & (PAGE_SIZE - 1))
 
-#define	REMAP_PFN_RANGE(vma, addr, pfn, size, prot) remap_pfn_range(vma, addr, pfn, size, prot)
+#define	REMAP_PFN_RANGE(vma, addr, pfn, size, prot)	\
+	remap_pfn_range(vma, addr, pfn, size, prot)
 
-#define	IO_REMAP_PFN_RANGE(vma, addr, pfn, size, prot) io_remap_pfn_range(vma, addr, pfn, size, prot)
+#define	IO_REMAP_PFN_RANGE(vma, addr, pfn, size, prot)	\
+	io_remap_pfn_range(vma, addr, pfn, size, prot)
 
-static inline IMG_UINT32 VMallocToPhys(IMG_VOID * pCpuVAddr)
+static inline u32 VMallocToPhys(void *pCpuVAddr)
 {
-	return (page_to_phys(vmalloc_to_page(pCpuVAddr)) +
-		ADDR_TO_PAGE_OFFSET(pCpuVAddr));
+	return page_to_phys(vmalloc_to_page(pCpuVAddr)) +
+		ADDR_TO_PAGE_OFFSET(pCpuVAddr);
 
 }
 
-typedef enum {
+enum LINUX_MEM_AREA_TYPE {
 	LINUX_MEM_AREA_IOREMAP,
 	LINUX_MEM_AREA_EXTERNAL_KV,
 	LINUX_MEM_AREA_IO,
@@ -63,92 +65,84 @@
 	LINUX_MEM_AREA_ALLOC_PAGES,
 	LINUX_MEM_AREA_SUB_ALLOC,
 	LINUX_MEM_AREA_TYPE_COUNT
-} LINUX_MEM_AREA_TYPE;
+};
 
-typedef struct _LinuxMemArea LinuxMemArea;
+struct LinuxMemArea;
 
-struct _LinuxMemArea {
-	LINUX_MEM_AREA_TYPE eAreaType;
+struct LinuxMemArea {
+	enum LINUX_MEM_AREA_TYPE eAreaType;
 	union _uData {
 		struct _sIORemap {
-
-			IMG_CPU_PHYADDR CPUPhysAddr;
-			IMG_VOID *pvIORemapCookie;
+			struct IMG_CPU_PHYADDR CPUPhysAddr;
+			void __iomem *pvIORemapCookie;
 		} sIORemap;
 		struct _sExternalKV {
-
 			IMG_BOOL bPhysContig;
 			union {
-
-				IMG_SYS_PHYADDR SysPhysAddr;
-				IMG_SYS_PHYADDR *pSysPhysAddr;
+				struct IMG_SYS_PHYADDR SysPhysAddr;
+				struct IMG_SYS_PHYADDR *pSysPhysAddr;
 			} uPhysAddr;
-			IMG_VOID *pvExternalKV;
+			void *pvExternalKV;
 		} sExternalKV;
 		struct _sIO {
-
-			IMG_CPU_PHYADDR CPUPhysAddr;
+			struct IMG_CPU_PHYADDR CPUPhysAddr;
 		} sIO;
 		struct _sVmalloc {
-
-			IMG_VOID *pvVmallocAddress;
+			void *pvVmallocAddress;
 		} sVmalloc;
 		struct _sPageList {
-
 			struct page **pvPageList;
 		} sPageList;
 		struct _sSubAlloc {
-
-			LinuxMemArea *psParentLinuxMemArea;
-			IMG_UINT32 ui32ByteOffset;
+			struct LinuxMemArea *psParentLinuxMemArea;
+			u32 ui32ByteOffset;
 		} sSubAlloc;
 	} uData;
-
-	IMG_UINT32 ui32ByteSize;
+	u32 ui32ByteSize;
 };
 
-typedef struct kmem_cache LinuxKMemCache;
+struct kmem_cache;
 
-PVRSRV_ERROR LinuxMMInit(IMG_VOID);
+enum PVRSRV_ERROR LinuxMMInit(void);
 
-IMG_VOID LinuxMMCleanup(IMG_VOID);
+void LinuxMMCleanup(void);
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-#define KMallocWrapper(ui32ByteSize) _KMallocWrapper(ui32ByteSize, __FILE__, __LINE__)
+#define KMallocWrapper(ui32ByteSize)	\
+		_KMallocWrapper(ui32ByteSize, __FILE__, __LINE__)
 #else
-#define KMallocWrapper(ui32ByteSize) _KMallocWrapper(ui32ByteSize, NULL, 0)
+#define KMallocWrapper(ui32ByteSize)	\
+		_KMallocWrapper(ui32ByteSize, NULL, 0)
 #endif
-IMG_VOID *_KMallocWrapper(IMG_UINT32 ui32ByteSize, IMG_CHAR * szFileName,
-			  IMG_UINT32 ui32Line);
+void *_KMallocWrapper(u32 ui32ByteSize, char *szFileName, u32 ui32Line);
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
 #define KFreeWrapper(pvCpuVAddr) _KFreeWrapper(pvCpuVAddr, __FILE__, __LINE__)
 #else
 #define KFreeWrapper(pvCpuVAddr) _KFreeWrapper(pvCpuVAddr, NULL, 0)
 #endif
-IMG_VOID _KFreeWrapper(IMG_VOID * pvCpuVAddr, IMG_CHAR * pszFileName,
-		       IMG_UINT32 ui32Line);
+void _KFreeWrapper(void *pvCpuVAddr, char *pszFileName, u32 ui32Line);
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-#define VMallocWrapper(ui32Bytes, ui32AllocFlags) _VMallocWrapper(ui32Bytes, ui32AllocFlags, __FILE__, __LINE__)
+#define VMallocWrapper(ui32Bytes, ui32AllocFlags)	\
+		_VMallocWrapper(ui32Bytes, ui32AllocFlags, __FILE__, __LINE__)
 #else
-#define VMallocWrapper(ui32Bytes, ui32AllocFlags) _VMallocWrapper(ui32Bytes, ui32AllocFlags, NULL, 0)
+#define VMallocWrapper(ui32Bytes, ui32AllocFlags)	\
+		_VMallocWrapper(ui32Bytes, ui32AllocFlags, NULL, 0)
 #endif
-IMG_VOID *_VMallocWrapper(IMG_UINT32 ui32Bytes, IMG_UINT32 ui32AllocFlags,
-			  IMG_CHAR * pszFileName, IMG_UINT32 ui32Line);
+void *_VMallocWrapper(u32 ui32Bytes, u32 ui32AllocFlags, char *pszFileName,
+		      u32 ui32Line);
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
 #define VFreeWrapper(pvCpuVAddr) _VFreeWrapper(pvCpuVAddr, __FILE__, __LINE__)
 #else
 #define VFreeWrapper(pvCpuVAddr) _VFreeWrapper(pvCpuVAddr, NULL, 0)
 #endif
-IMG_VOID _VFreeWrapper(IMG_VOID * pvCpuVAddr, IMG_CHAR * pszFileName,
-		       IMG_UINT32 ui32Line);
+void _VFreeWrapper(void *pvCpuVAddr, char *pszFileName, u32 ui32Line);
 
-LinuxMemArea *NewVMallocLinuxMemArea(IMG_UINT32 ui32Bytes,
-				     IMG_UINT32 ui32AreaFlags);
+struct LinuxMemArea *NewVMallocLinuxMemArea(u32 ui32Bytes, u32 ui32AreaFlags);
 
-IMG_VOID FreeVMallocLinuxMemArea(LinuxMemArea * psLinuxMemArea);
+void FreeVMallocLinuxMemArea(struct LinuxMemArea *psLinuxMemArea);
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
 #define IORemapWrapper(BasePAddr, ui32Bytes, ui32MappingFlags) \
@@ -157,24 +151,20 @@
 #define IORemapWrapper(BasePAddr, ui32Bytes, ui32MappingFlags) \
     _IORemapWrapper(BasePAddr, ui32Bytes, ui32MappingFlags, NULL, 0)
 #endif
-IMG_VOID *_IORemapWrapper(IMG_CPU_PHYADDR BasePAddr,
-			  IMG_UINT32 ui32Bytes,
-			  IMG_UINT32 ui32MappingFlags,
-			  IMG_CHAR * pszFileName, IMG_UINT32 ui32Line);
-
-LinuxMemArea *NewIORemapLinuxMemArea(IMG_CPU_PHYADDR BasePAddr,
-				     IMG_UINT32 ui32Bytes,
-				     IMG_UINT32 ui32AreaFlags);
-
-IMG_VOID FreeIORemapLinuxMemArea(LinuxMemArea * psLinuxMemArea);
-
-LinuxMemArea *NewExternalKVLinuxMemArea(IMG_SYS_PHYADDR * pBasePAddr,
-					IMG_VOID * pvCPUVAddr,
-					IMG_UINT32 ui32Bytes,
-					IMG_BOOL bPhysContig,
-					IMG_UINT32 ui32AreaFlags);
+void __iomem *_IORemapWrapper(struct IMG_CPU_PHYADDR BasePAddr, u32 ui32Bytes,
+		u32 ui32MappingFlags, char *pszFileName,
+		u32 ui32Line);
+
+struct LinuxMemArea *NewIORemapLinuxMemArea(struct IMG_CPU_PHYADDR BasePAddr,
+		u32 ui32Bytes, u32 ui32AreaFlags);
+
+void FreeIORemapLinuxMemArea(struct LinuxMemArea *psLinuxMemArea);
+
+struct LinuxMemArea *NewExternalKVLinuxMemArea(
+		struct IMG_SYS_PHYADDR *pBasePAddr, void *pvCPUVAddr,
+		u32 ui32Bytes, IMG_BOOL bPhysContig, u32 ui32AreaFlags);
 
-IMG_VOID FreeExternalKVLinuxMemArea(LinuxMemArea * psLinuxMemArea);
+void FreeExternalKVLinuxMemArea(struct LinuxMemArea *psLinuxMemArea);
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
 #define IOUnmapWrapper(pvIORemapCookie) \
@@ -183,89 +173,96 @@
 #define IOUnmapWrapper(pvIORemapCookie) \
     _IOUnmapWrapper(pvIORemapCookie, NULL, 0)
 #endif
-IMG_VOID _IOUnmapWrapper(IMG_VOID * pvIORemapCookie, IMG_CHAR * pszFileName,
-			 IMG_UINT32 ui32Line);
+void _IOUnmapWrapper(void __iomem *pvIORemapCookie, char *pszFileName,
+			 u32 ui32Line);
 
-struct page *LinuxMemAreaOffsetToPage(LinuxMemArea * psLinuxMemArea,
-				      IMG_UINT32 ui32ByteOffset);
+struct page *LinuxMemAreaOffsetToPage(struct LinuxMemArea *psLinuxMemArea,
+				      u32 ui32ByteOffset);
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
 #define KMapWrapper(psPage) _KMapWrapper(psPage, __FILE__, __LINE__)
 #else
 #define KMapWrapper(psPage) _KMapWrapper(psPage, NULL, 0)
 #endif
-IMG_VOID *_KMapWrapper(struct page *psPage, IMG_CHAR * pszFileName,
-		       IMG_UINT32 ui32Line);
+void *_KMapWrapper(struct page *psPage, char *pszFileName, u32 ui32Line);
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
 #define KUnMapWrapper(psPage) _KUnMapWrapper(psPage, __FILE__, __LINE__)
 #else
 #define KUnMapWrapper(psPage) _KUnMapWrapper(psPage, NULL, 0)
 #endif
-IMG_VOID _KUnMapWrapper(struct page *psPage, IMG_CHAR * pszFileName,
-			IMG_UINT32 ui32Line);
+void _KUnMapWrapper(struct page *psPage, char *pszFileName,
+			u32 ui32Line);
 
-LinuxKMemCache *KMemCacheCreateWrapper(IMG_CHAR * pszName, size_t Size,
-				       size_t Align, IMG_UINT32 ui32Flags);
+struct kmem_cache *KMemCacheCreateWrapper(char *pszName, size_t Size,
+				       size_t Align, u32 ui32Flags);
 
-IMG_VOID KMemCacheDestroyWrapper(LinuxKMemCache * psCache);
+void KMemCacheDestroyWrapper(struct kmem_cache *psCache);
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-#define KMemCacheAllocWrapper(psCache, Flags) _KMemCacheAllocWrapper(psCache, Flags, __FILE__, __LINE__)
+#define KMemCacheAllocWrapper(psCache, Flags)	\
+		_KMemCacheAllocWrapper(psCache, Flags, __FILE__, __LINE__)
 #else
-#define KMemCacheAllocWrapper(psCache, Flags) _KMemCacheAllocWrapper(psCache, Flags, NULL, 0)
+#define KMemCacheAllocWrapper(psCache, Flags)	\
+		_KMemCacheAllocWrapper(psCache, Flags, NULL, 0)
 #endif
 
-IMG_VOID *_KMemCacheAllocWrapper(LinuxKMemCache * psCache, gfp_t Flags,
-				 IMG_CHAR * pszFileName, IMG_UINT32 ui32Line);
+void *_KMemCacheAllocWrapper(struct kmem_cache *psCache, gfp_t Flags,
+				 char *pszFileName, u32 ui32Line);
 
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-#define KMemCacheFreeWrapper(psCache, pvObject) _KMemCacheFreeWrapper(psCache, pvObject, __FILE__, __LINE__)
+#define KMemCacheFreeWrapper(psCache, pvObject)	\
+		_KMemCacheFreeWrapper(psCache, pvObject, __FILE__, __LINE__)
 #else
-#define KMemCacheFreeWrapper(psCache, pvObject) _KMemCacheFreeWrapper(psCache, pvObject, NULL, 0)
+#define KMemCacheFreeWrapper(psCache, pvObject)	\
+		_KMemCacheFreeWrapper(psCache, pvObject, NULL, 0)
 #endif
-IMG_VOID _KMemCacheFreeWrapper(LinuxKMemCache * psCache, IMG_VOID * pvObject,
-			       IMG_CHAR * pszFileName, IMG_UINT32 ui32Line);
+void _KMemCacheFreeWrapper(struct kmem_cache *psCache, void *pvObject,
+				char *pszFileName, u32 ui32Line);
 
-const IMG_CHAR *KMemCacheNameWrapper(LinuxKMemCache * psCache);
+const char *KMemCacheNameWrapper(struct kmem_cache *psCache);
 
-LinuxMemArea *NewIOLinuxMemArea(IMG_CPU_PHYADDR BasePAddr, IMG_UINT32 ui32Bytes,
-				IMG_UINT32 ui32AreaFlags);
+struct LinuxMemArea *NewIOLinuxMemArea(struct IMG_CPU_PHYADDR BasePAddr,
+				u32 ui32Bytes, u32 ui32AreaFlags);
 
-IMG_VOID FreeIOLinuxMemArea(LinuxMemArea * psLinuxMemArea);
+void FreeIOLinuxMemArea(struct LinuxMemArea *psLinuxMemArea);
 
-LinuxMemArea *NewAllocPagesLinuxMemArea(IMG_UINT32 ui32Bytes,
-					IMG_UINT32 ui32AreaFlags);
+struct LinuxMemArea *NewAllocPagesLinuxMemArea(u32 ui32Bytes,
+				u32 ui32AreaFlags);
 
-IMG_VOID FreeAllocPagesLinuxMemArea(LinuxMemArea * psLinuxMemArea);
+void FreeAllocPagesLinuxMemArea(struct LinuxMemArea *psLinuxMemArea);
 
-LinuxMemArea *NewSubLinuxMemArea(LinuxMemArea * psParentLinuxMemArea,
-				 IMG_UINT32 ui32ByteOffset,
-				 IMG_UINT32 ui32Bytes);
+struct LinuxMemArea *NewSubLinuxMemArea(
+				struct LinuxMemArea *psParentLinuxMemArea,
+				u32 ui32ByteOffset, u32 ui32Bytes);
 
-IMG_VOID LinuxMemAreaDeepFree(LinuxMemArea * psLinuxMemArea);
+void LinuxMemAreaDeepFree(struct LinuxMemArea *psLinuxMemArea);
 
 #if defined(LINUX_MEM_AREAS_DEBUG)
-IMG_VOID LinuxMemAreaRegister(LinuxMemArea * psLinuxMemArea);
+void LinuxMemAreaRegister(struct LinuxMemArea *psLinuxMemArea);
 #else
 #define LinuxMemAreaRegister(X)
 #endif
 
-IMG_VOID *LinuxMemAreaToCpuVAddr(LinuxMemArea * psLinuxMemArea);
+void *LinuxMemAreaToCpuVAddr(struct LinuxMemArea *psLinuxMemArea);
 
-IMG_CPU_PHYADDR LinuxMemAreaToCpuPAddr(LinuxMemArea * psLinuxMemArea,
-				       IMG_UINT32 ui32ByteOffset);
+struct IMG_CPU_PHYADDR LinuxMemAreaToCpuPAddr(
+				struct LinuxMemArea *psLinuxMemArea,
+				u32 ui32ByteOffset);
 
-#define	 LinuxMemAreaToCpuPFN(psLinuxMemArea, ui32ByteOffset) PHYS_TO_PFN(LinuxMemAreaToCpuPAddr(psLinuxMemArea, ui32ByteOffset).uiAddr)
+#define	 LinuxMemAreaToCpuPFN(psLinuxMemArea, ui32ByteOffset)		\
+	PHYS_TO_PFN(LinuxMemAreaToCpuPAddr(psLinuxMemArea,		\
+					   ui32ByteOffset).uiAddr)
 
-IMG_BOOL LinuxMemAreaPhysIsContig(LinuxMemArea * psLinuxMemArea);
+IMG_BOOL LinuxMemAreaPhysIsContig(struct LinuxMemArea *psLinuxMemArea);
 
-LINUX_MEM_AREA_TYPE LinuxMemAreaRootType(LinuxMemArea * psLinuxMemArea);
+enum LINUX_MEM_AREA_TYPE LinuxMemAreaRootType(
+				struct LinuxMemArea *psLinuxMemArea);
 
-const IMG_CHAR *LinuxMemAreaTypeToString(LINUX_MEM_AREA_TYPE eMemAreaType);
+const char *LinuxMemAreaTypeToString(enum LINUX_MEM_AREA_TYPE eMemAreaType);
 
 #if defined(DEBUG) || defined(DEBUG_LINUX_MEM_AREAS)
-const IMG_CHAR *HAPFlagsToString(IMG_UINT32 ui32Flags);
+const char *HAPFlagsToString(u32 ui32Flags);
 #endif
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/mmap.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/mmap.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -33,7 +33,7 @@
 #include <linux/module.h>
 #include <linux/vmalloc.h>
 #include <linux/slab.h>
-#include <asm/io.h>
+#include <linux/io.h>
 #include <asm/page.h>
 #include <asm/shmparam.h>
 #include <asm/pgtable.h>
@@ -49,22 +49,19 @@
 #include "osfunc.h"
 #include "proc.h"
 
-static PKV_OFFSET_STRUCT FindOffsetStructFromLinuxMemArea(LinuxMemArea *
-							  psLinuxMemArea);
-static IMG_UINT32 GetFirstFreePageAlignedNumber(void);
-static PKV_OFFSET_STRUCT FindOffsetStructByKVIndexAddress(IMG_VOID *
-							  pvVirtAddress,
-							  IMG_UINT32
-							  ui32ByteSize);
-static void DeterminUsersSizeAndByteOffset(IMG_VOID * pvKVIndexAddress,
-					   LinuxMemArea * psLinuxMemArea,
-					   IMG_UINT32 * pui32RealByteSize,
-					   IMG_UINT32 * pui32ByteOffset);
-static PKV_OFFSET_STRUCT FindOffsetStructByMMapOffset(IMG_UINT32 ui32Offset);
-static IMG_BOOL DoMapToUser(LinuxMemArea * psLinuxMemArea,
-			    struct vm_area_struct *ps_vma,
-			    IMG_UINT32 ui32ByteOffset, IMG_UINT32 ui32Size);
-static IMG_BOOL CheckSize(LinuxMemArea * psLinuxMemArea, IMG_UINT32 ui32Size);
+static struct KV_OFFSET_STRUCT *FindOffsetStructFromLinuxMemArea(
+		struct LinuxMemArea *psLinuxMemArea);
+static u32 GetFirstFreePageAlignedNumber(void);
+static struct KV_OFFSET_STRUCT *FindOffsetStructByKVIndexAddress(
+		void *pvVirtAddress, u32 ui32ByteSize);
+static void DeterminUsersSizeAndByteOffset(void *pvKVIndexAddress,
+		struct LinuxMemArea *psLinuxMemArea, u32 *pui32RealByteSize,
+		u32 *pui32ByteOffset);
+static struct KV_OFFSET_STRUCT *FindOffsetStructByMMapOffset(u32 ui32Offset);
+static IMG_BOOL DoMapToUser(struct LinuxMemArea *psLinuxMemArea,
+		struct vm_area_struct *ps_vma, u32 ui32ByteOffset,
+		u32 ui32Size);
+static IMG_BOOL CheckSize(struct LinuxMemArea *psLinuxMemArea, u32 ui32Size);
 
 #if defined(DEBUG_LINUX_MMAP_AREAS)
 static off_t PrintMMapRegistrations(char *buffer, size_t size, off_t off);
@@ -74,55 +71,56 @@
 static void MMapVClose(struct vm_area_struct *ps_vma);
 
 static struct vm_operations_struct MMapIOOps = {
-open:	MMapVOpen,
-close:	MMapVClose
+	.open	=	MMapVOpen,
+	.close	=	MMapVClose,
 };
 
-static PKV_OFFSET_STRUCT g_psKVOffsetTable = 0;
-static LinuxKMemCache *g_psMemmapCache = 0;
+static struct KV_OFFSET_STRUCT *g_psKVOffsetTable;
+static struct kmem_cache *g_psMemmapCache;
 #if defined(DEBUG_LINUX_MMAP_AREAS)
-static IMG_UINT32 g_ui32RegisteredAreas = 0;
-static IMG_UINT32 g_ui32TotalByteSize = 0;
+static u32 g_ui32RegisteredAreas;
+static u32 g_ui32TotalByteSize;
 #endif
 
 static struct rw_semaphore g_mmap_sem;
 
-IMG_VOID PVRMMapInit(IMG_VOID)
+void PVRMMapInit(void)
 {
-	g_psKVOffsetTable = 0;
+	g_psKVOffsetTable = NULL;
 
-	g_psMemmapCache =
-	    KMemCacheCreateWrapper("img-mmap", sizeof(KV_OFFSET_STRUCT), 0, 0);
+	g_psMemmapCache = KMemCacheCreateWrapper("img-mmap",
+					sizeof(struct KV_OFFSET_STRUCT), 0, 0);
 	if (g_psMemmapCache) {
 #if defined(DEBUG_LINUX_MMAP_AREAS)
 		CreateProcReadEntry("mmap", PrintMMapRegistrations);
 #endif
 	} else {
-		PVR_DPF((PVR_DBG_ERROR, "%s: failed to allocate kmem_cache",
-			 __FUNCTION__));
+		PVR_DPF(PVR_DBG_ERROR, "%s: failed to allocate kmem_cache",
+			 __func__);
 	}
 	init_rwsem(&g_mmap_sem);
 }
 
-IMG_VOID PVRMMapCleanup(void)
+void PVRMMapCleanup(void)
 {
-	PKV_OFFSET_STRUCT psOffsetStruct;
+	struct KV_OFFSET_STRUCT *psOffsetStruct;
 
 	if (!g_psMemmapCache)
 		return;
 
 	if (g_psKVOffsetTable) {
-		PVR_DPF((PVR_DBG_ERROR, "%s: BUG! g_psMemmapCache isn't empty!",
-			 __FUNCTION__));
+		PVR_DPF(PVR_DBG_ERROR, "%s: BUG! g_psMemmapCache isn't empty!",
+			 __func__);
 
 		for (psOffsetStruct = g_psKVOffsetTable; psOffsetStruct;
 		     psOffsetStruct = psOffsetStruct->psNext) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "%s: BUG!: Un-registering mmapable area: psLinuxMemArea=0x%p, CpuPAddr=0x%08lx\n",
-				 __FUNCTION__, psOffsetStruct->psLinuxMemArea,
+			PVR_DPF(PVR_DBG_ERROR, "%s: BUG!: "
+				"Un-registering mmapable area: "
+				"psLinuxMemArea=0x%p, CpuPAddr=0x%08lx\n",
+				 __func__, psOffsetStruct->psLinuxMemArea,
 				 LinuxMemAreaToCpuPAddr(psOffsetStruct->
 							psLinuxMemArea,
-							0).uiAddr));
+							0).uiAddr);
 			PVRMMapRemoveRegisteredArea(psOffsetStruct->
 						    psLinuxMemArea);
 		}
@@ -131,33 +129,33 @@
 	RemoveProcEntry("mmap");
 	KMemCacheDestroyWrapper(g_psMemmapCache);
 	g_psMemmapCache = NULL;
-	PVR_DPF((PVR_DBG_MESSAGE, "PVRMMapCleanup: KVOffsetTable deallocated"));
+	PVR_DPF(PVR_DBG_MESSAGE, "PVRMMapCleanup: KVOffsetTable deallocated");
 }
 
-PVRSRV_ERROR
-PVRMMapRegisterArea(const IMG_CHAR * pszName,
-		    LinuxMemArea * psLinuxMemArea, IMG_UINT32 ui32AllocFlags)
+enum PVRSRV_ERROR
+PVRMMapRegisterArea(const char *pszName,
+		    struct LinuxMemArea *psLinuxMemArea, u32 ui32AllocFlags)
 {
-	PKV_OFFSET_STRUCT psOffsetStruct;
-	PVRSRV_ERROR iError = PVRSRV_OK;
-	PVR_DPF((PVR_DBG_MESSAGE,
+	struct KV_OFFSET_STRUCT *psOffsetStruct;
+	enum PVRSRV_ERROR iError = PVRSRV_OK;
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "%s(%s, psLinuxMemArea=%p, ui32AllocFlags=0x%8lx)",
-		 __FUNCTION__, pszName, psLinuxMemArea, ui32AllocFlags));
+		 __func__, pszName, psLinuxMemArea, ui32AllocFlags);
 
 	down_write(&g_mmap_sem);
 	psOffsetStruct = FindOffsetStructFromLinuxMemArea(psLinuxMemArea);
 	if (psOffsetStruct) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRMMapRegisterArea: psLinuxMemArea=%p is already registered",
-			 psOffsetStruct->psLinuxMemArea));
+		PVR_DPF(PVR_DBG_ERROR, "PVRMMapRegisterArea: "
+				"psLinuxMemArea=%p is already registered",
+			 psOffsetStruct->psLinuxMemArea);
 		iError = PVRSRV_ERROR_INVALID_PARAMS;
 		goto register_exit;
 	}
 
 	psOffsetStruct = KMemCacheAllocWrapper(g_psMemmapCache, GFP_KERNEL);
 	if (!psOffsetStruct) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRMMapRegisterArea: Couldn't alloc another mapping record from cache"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRMMapRegisterArea: "
+			"Couldn't alloc another mapping record from cache");
 		iError = PVRSRV_ERROR_OUT_OF_MEMORY;
 		goto register_exit;
 	}
@@ -168,7 +166,7 @@
 	if (psLinuxMemArea->eAreaType != LINUX_MEM_AREA_SUB_ALLOC) {
 		psOffsetStruct->ui32AllocFlags = ui32AllocFlags;
 	} else {
-		PKV_OFFSET_STRUCT psParentOffsetStruct;
+		struct KV_OFFSET_STRUCT *psParentOffsetStruct;
 		psParentOffsetStruct =
 		    FindOffsetStructFromLinuxMemArea(psLinuxMemArea->uData.
 						     sSubAlloc.
@@ -186,9 +184,8 @@
 	psOffsetStruct->ui16Faults = 0;
 
 	g_ui32RegisteredAreas++;
-	if (psLinuxMemArea->eAreaType != LINUX_MEM_AREA_SUB_ALLOC) {
+	if (psLinuxMemArea->eAreaType != LINUX_MEM_AREA_SUB_ALLOC)
 		g_ui32TotalByteSize += psLinuxMemArea->ui32ByteSize;
-	}
 #endif
 
 	psOffsetStruct->psNext = g_psKVOffsetTable;
@@ -199,49 +196,50 @@
 	return iError;
 }
 
-PVRSRV_ERROR PVRMMapRemoveRegisteredArea(LinuxMemArea * psLinuxMemArea)
+enum PVRSRV_ERROR PVRMMapRemoveRegisteredArea(
+					struct LinuxMemArea *psLinuxMemArea)
 {
-	PKV_OFFSET_STRUCT *ppsOffsetStruct, psOffsetStruct;
-	PVRSRV_ERROR iError = PVRSRV_OK;
+	struct KV_OFFSET_STRUCT **ppsOffsetStruct, *psOffsetStruct;
+	enum PVRSRV_ERROR iError = PVRSRV_OK;
 
 	down_write(&g_mmap_sem);
 	for (ppsOffsetStruct = &g_psKVOffsetTable;
 	     (psOffsetStruct = *ppsOffsetStruct);
 	     ppsOffsetStruct = &(*ppsOffsetStruct)->psNext) {
-		if (psOffsetStruct->psLinuxMemArea == psLinuxMemArea) {
+		if (psOffsetStruct->psLinuxMemArea == psLinuxMemArea)
 			break;
-		}
+
 	}
 
 	if (!psOffsetStruct) {
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "%s: Registration for psLinuxMemArea = 0x%p not found",
-			 __FUNCTION__, psLinuxMemArea));
+			 __func__, psLinuxMemArea);
 		iError = PVRSRV_ERROR_BAD_MAPPING;
 		goto unregister_exit;
 	}
 #if defined(DEBUG_LINUX_MMAP_AREAS)
 
 	if (psOffsetStruct->ui16Mapped) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "%s: Unregistering still-mapped area! (psLinuxMemArea=0x%p)\n",
-			 __FUNCTION__, psOffsetStruct->psLinuxMemArea));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "%s: Unregistering still-mapped area! "
+			 "(psLinuxMemArea=0x%p)\n",
+			 __func__, psOffsetStruct->psLinuxMemArea);
 		iError = PVRSRV_ERROR_BAD_MAPPING;
 		goto unregister_exit;
 	}
 
 	g_ui32RegisteredAreas--;
 
-	if (psLinuxMemArea->eAreaType != LINUX_MEM_AREA_SUB_ALLOC) {
+	if (psLinuxMemArea->eAreaType != LINUX_MEM_AREA_SUB_ALLOC)
 		g_ui32TotalByteSize -=
 		    psOffsetStruct->psLinuxMemArea->ui32ByteSize;
-	}
 #endif
 
-	PVR_DPF((PVR_DBG_MESSAGE, "%s: Table entry: "
-		 "psLinuxMemArea=0x%08lX, CpuPAddr=0x%08lX", __FUNCTION__,
+	PVR_DPF(PVR_DBG_MESSAGE, "%s: Table entry: "
+		 "psLinuxMemArea=0x%08lX, CpuPAddr=0x%08lX", __func__,
 		 psOffsetStruct->psLinuxMemArea,
-		 LinuxMemAreaToCpuPAddr(psOffsetStruct->psLinuxMemArea, 0)));
+		 LinuxMemAreaToCpuPAddr(psOffsetStruct->psLinuxMemArea, 0));
 
 	*ppsOffsetStruct = psOffsetStruct->psNext;
 
@@ -252,36 +250,34 @@
 	return iError;
 }
 
-static PKV_OFFSET_STRUCT
-FindOffsetStructFromLinuxMemArea(LinuxMemArea * psLinuxMemArea)
+static struct KV_OFFSET_STRUCT *FindOffsetStructFromLinuxMemArea(
+					struct LinuxMemArea *psLinuxMemArea)
 {
-	PKV_OFFSET_STRUCT psOffsetStruct = NULL;
+	struct KV_OFFSET_STRUCT *psOffsetStruct = NULL;
 
 	for (psOffsetStruct = g_psKVOffsetTable; psOffsetStruct;
 	     psOffsetStruct = psOffsetStruct->psNext) {
-		if (psOffsetStruct->psLinuxMemArea == psLinuxMemArea) {
+		if (psOffsetStruct->psLinuxMemArea == psLinuxMemArea)
 			return psOffsetStruct;
-		}
+
 	}
 	return NULL;
 }
 
-static IMG_UINT32 GetFirstFreePageAlignedNumber(void)
+static u32 GetFirstFreePageAlignedNumber(void)
 {
-	PKV_OFFSET_STRUCT psCurrentRec;
-	IMG_UINT32 ui32CurrentPageOffset;
+	struct KV_OFFSET_STRUCT *psCurrentRec;
+	u32 ui32CurrentPageOffset;
 
-	if (!g_psKVOffsetTable) {
+	if (!g_psKVOffsetTable)
 		return 0;
-	}
 
 	psCurrentRec = g_psKVOffsetTable;
 	ui32CurrentPageOffset = (g_psKVOffsetTable->ui32MMapOffset);
 
 	while (psCurrentRec) {
-		if (ui32CurrentPageOffset != (psCurrentRec->ui32MMapOffset)) {
+		if (ui32CurrentPageOffset != (psCurrentRec->ui32MMapOffset))
 			return ui32CurrentPageOffset;
-		}
 		psCurrentRec = psCurrentRec->psNext;
 		ui32CurrentPageOffset += PAGE_SIZE;
 	}
@@ -289,15 +285,15 @@
 	return g_psKVOffsetTable->ui32MMapOffset + PAGE_SIZE;
 }
 
-PVRSRV_ERROR
-PVRMMapKVIndexAddressToMMapData(IMG_VOID * pvKVIndexAddress,
-				IMG_UINT32 ui32Size,
-				IMG_UINT32 * pui32MMapOffset,
-				IMG_UINT32 * pui32ByteOffset,
-				IMG_UINT32 * pui32RealByteSize)
+enum PVRSRV_ERROR
+PVRMMapKVIndexAddressToMMapData(void *pvKVIndexAddress,
+				u32 ui32Size,
+				u32 *pui32MMapOffset,
+				u32 *pui32ByteOffset,
+				u32 *pui32RealByteSize)
 {
-	PKV_OFFSET_STRUCT psOffsetStruct;
-	PVRSRV_ERROR iError = PVRSRV_OK;
+	struct KV_OFFSET_STRUCT *psOffsetStruct;
+	enum PVRSRV_ERROR iError = PVRSRV_OK;
 
 	down_read(&g_mmap_sem);
 	psOffsetStruct =
@@ -318,17 +314,17 @@
 	return iError;
 }
 
-static PKV_OFFSET_STRUCT
-FindOffsetStructByKVIndexAddress(IMG_VOID * pvKVIndexAddress,
-				 IMG_UINT32 ui32ByteSize)
-{
-	PKV_OFFSET_STRUCT psOffsetStruct;
-	IMG_UINT8 *pui8CpuVAddr;
-	IMG_UINT8 *pui8IndexCpuVAddr = (IMG_UINT8 *) pvKVIndexAddress;
+static struct KV_OFFSET_STRUCT *FindOffsetStructByKVIndexAddress(
+		void *pvKVIndexAddress, u32 ui32ByteSize)
+{
+	struct KV_OFFSET_STRUCT *psOffsetStruct;
+	u8 *pui8CpuVAddr;
+	u8 *pui8IndexCpuVAddr = (u8 *)pvKVIndexAddress;
 
 	for (psOffsetStruct = g_psKVOffsetTable; psOffsetStruct;
 	     psOffsetStruct = psOffsetStruct->psNext) {
-		LinuxMemArea *psLinuxMemArea = psOffsetStruct->psLinuxMemArea;
+		struct LinuxMemArea *psLinuxMemArea =
+						psOffsetStruct->psLinuxMemArea;
 
 		switch (psLinuxMemArea->eAreaType) {
 		case LINUX_MEM_AREA_IOREMAP:
@@ -344,45 +340,42 @@
 			    psLinuxMemArea->uData.sExternalKV.pvExternalKV;
 			break;
 		default:
-			pui8CpuVAddr = IMG_NULL;
+			pui8CpuVAddr = NULL;
 			break;
 		}
 
 		if (pui8CpuVAddr) {
-			if (pui8IndexCpuVAddr >= pui8CpuVAddr
-			    && (pui8IndexCpuVAddr + ui32ByteSize) <=
-			    (pui8CpuVAddr + psLinuxMemArea->ui32ByteSize)) {
+			if (pui8IndexCpuVAddr >= pui8CpuVAddr &&
+			    (pui8IndexCpuVAddr + ui32ByteSize) <=
+			    (pui8CpuVAddr + psLinuxMemArea->ui32ByteSize))
 				return psOffsetStruct;
-			} else {
+			else
 				pui8CpuVAddr = NULL;
-			}
 		}
 
 		if (pvKVIndexAddress == psOffsetStruct->psLinuxMemArea) {
 			if (psLinuxMemArea->eAreaType ==
-			    LINUX_MEM_AREA_SUB_ALLOC) {
+			    LINUX_MEM_AREA_SUB_ALLOC)
 				PVR_ASSERT(psLinuxMemArea->uData.sSubAlloc.
 					   psParentLinuxMemArea->eAreaType !=
 					   LINUX_MEM_AREA_SUB_ALLOC);
-			}
 			return psOffsetStruct;
 		}
 	}
 	printk(KERN_ERR "%s: Failed to find offset struct (KVAddress=%p)\n",
-	       __FUNCTION__, pvKVIndexAddress);
+	       __func__, pvKVIndexAddress);
 	return NULL;
 }
 
-static void
-DeterminUsersSizeAndByteOffset(IMG_VOID * pvKVIndexAddress,
-			       LinuxMemArea * psLinuxMemArea,
-			       IMG_UINT32 * pui32RealByteSize,
-			       IMG_UINT32 * pui32ByteOffset)
-{
-	IMG_UINT8 *pui8StartVAddr = NULL;
-	IMG_UINT8 *pui8IndexCpuVAddr = (IMG_UINT8 *) pvKVIndexAddress;
-	IMG_UINT32 ui32PageAlignmentOffset = 0;
-	IMG_CPU_PHYADDR CpuPAddr;
+static void DeterminUsersSizeAndByteOffset(void *pvKVIndexAddress,
+			       struct LinuxMemArea *psLinuxMemArea,
+			       u32 *pui32RealByteSize,
+			       u32 *pui32ByteOffset)
+{
+	u8 *pui8StartVAddr = NULL;
+	u8 *pui8IndexCpuVAddr = (u8 *) pvKVIndexAddress;
+	u32 ui32PageAlignmentOffset = 0;
+	struct IMG_CPU_PHYADDR CpuPAddr;
 
 	CpuPAddr = LinuxMemAreaToCpuPAddr(psLinuxMemArea, 0);
 	ui32PageAlignmentOffset = ADDR_TO_PAGE_OFFSET(CpuPAddr.uiAddr);
@@ -406,20 +399,20 @@
 int PVRMMap(struct file *pFile, struct vm_area_struct *ps_vma)
 {
 	unsigned long ulBytes;
-	PKV_OFFSET_STRUCT psCurrentRec = NULL;
+	struct KV_OFFSET_STRUCT *psCurrentRec = NULL;
 	int iRetVal = 0;
 
 	ulBytes = ps_vma->vm_end - ps_vma->vm_start;
 	down_read(&g_mmap_sem);
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "%s: Recieved mmap(2) request with a ui32MMapOffset=0x%08lx,"
-		 " and ui32ByteSize=%ld(0x%08lx)\n", __FUNCTION__,
-		 PFN_TO_PHYS(ps_vma->vm_pgoff), ulBytes, ulBytes));
+		 " and ui32ByteSize=%ld(0x%08lx)\n", __func__,
+		 PFN_TO_PHYS(ps_vma->vm_pgoff), ulBytes, ulBytes);
 
 	if ((ps_vma->vm_flags & VM_WRITE) && !(ps_vma->vm_flags & VM_SHARED)
 	    ) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRMMap: Error - Cannot mmap non-shareable writable areas."));
+		PVR_DPF(PVR_DBG_ERROR, "PVRMMap: "
+			"Error - Cannot mmap non-shareable writable areas.");
 		iRetVal = -EINVAL;
 		goto pvrmmap_exit;
 	}
@@ -427,14 +420,14 @@
 	psCurrentRec =
 	    FindOffsetStructByMMapOffset(PFN_TO_PHYS(ps_vma->vm_pgoff));
 	if (!psCurrentRec) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRMMap: Error - Attempted to mmap unregistered area at vm_pgoff=%ld",
-			 ps_vma->vm_pgoff));
+		PVR_DPF(PVR_DBG_ERROR, "PVRMMap: "
+		  "Error - Attempted to mmap unregistered area at vm_pgoff=%ld",
+			 ps_vma->vm_pgoff);
 		iRetVal = -EINVAL;
 		goto pvrmmap_exit;
 	}
-	PVR_DPF((PVR_DBG_MESSAGE, "%s: > psCurrentRec->psLinuxMemArea=%p\n",
-		 __FUNCTION__, psCurrentRec->psLinuxMemArea));
+	PVR_DPF(PVR_DBG_MESSAGE, "%s: > psCurrentRec->psLinuxMemArea=%p\n",
+		 __func__, psCurrentRec->psLinuxMemArea);
 	if (!CheckSize(psCurrentRec->psLinuxMemArea, ulBytes)) {
 		iRetVal = -EINVAL;
 		goto pvrmmap_exit;
@@ -459,8 +452,8 @@
 		ps_vma->vm_page_prot = pgprot_noncached(ps_vma->vm_page_prot);
 		break;
 	default:
-		PVR_DPF((PVR_DBG_ERROR, "%s: unknown cache type",
-			 __FUNCTION__));
+		PVR_DPF(PVR_DBG_ERROR, "%s: unknown cache type",
+			 __func__);
 	}
 
 	ps_vma->vm_ops = &MMapIOOps;
@@ -472,39 +465,37 @@
 
 	MMapVOpen(ps_vma);
 
-	PVR_DPF((PVR_DBG_MESSAGE, "%s: Mapped area at offset 0x%08lx\n",
-		 __FUNCTION__, ps_vma->vm_pgoff));
+	PVR_DPF(PVR_DBG_MESSAGE, "%s: Mapped area at offset 0x%08lx\n",
+		 __func__, ps_vma->vm_pgoff);
 
 pvrmmap_exit:
 	up_read(&g_mmap_sem);
 	return iRetVal;
 }
 
-static PKV_OFFSET_STRUCT FindOffsetStructByMMapOffset(IMG_UINT32 ui32MMapOffset)
+static struct KV_OFFSET_STRUCT *FindOffsetStructByMMapOffset(u32 ui32MMapOffset)
 {
-	PKV_OFFSET_STRUCT psOffsetStruct;
+	struct KV_OFFSET_STRUCT *psOffsetStruct;
 
 	for (psOffsetStruct = g_psKVOffsetTable; psOffsetStruct;
 	     psOffsetStruct = psOffsetStruct->psNext) {
-		if (psOffsetStruct->ui32MMapOffset == ui32MMapOffset) {
+		if (psOffsetStruct->ui32MMapOffset == ui32MMapOffset)
 			return psOffsetStruct;
-		}
+
 	}
 	return NULL;
 }
 
-static IMG_BOOL
-DoMapToUser(LinuxMemArea * psLinuxMemArea,
+static IMG_BOOL DoMapToUser(struct LinuxMemArea *psLinuxMemArea,
 	    struct vm_area_struct *ps_vma,
-	    IMG_UINT32 ui32ByteOffset, IMG_UINT32 ui32ByteSize)
+	    u32 ui32ByteOffset, u32 ui32ByteSize)
 {
-	if (psLinuxMemArea->eAreaType == LINUX_MEM_AREA_SUB_ALLOC) {
-		return DoMapToUser(psLinuxMemArea->uData.sSubAlloc.
-				   psParentLinuxMemArea, ps_vma,
-				   psLinuxMemArea->uData.sSubAlloc.
-				   ui32ByteOffset + ui32ByteOffset,
-				   ui32ByteSize);
-	}
+	if (psLinuxMemArea->eAreaType == LINUX_MEM_AREA_SUB_ALLOC)
+		return DoMapToUser(psLinuxMemArea->
+				uData.sSubAlloc.psParentLinuxMemArea,
+				ps_vma,
+				psLinuxMemArea->uData.sSubAlloc.ui32ByteOffset +
+				ui32ByteOffset, ui32ByteSize);
 
 	PVR_ASSERT(ADDR_TO_PAGE_OFFSET(ui32ByteSize) == 0);
 
@@ -518,16 +509,17 @@
 		    IO_REMAP_PFN_RANGE(ps_vma, ps_vma->vm_start, pfn,
 				       ui32ByteSize, ps_vma->vm_page_prot);
 		if (result != 0) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "%s: Error - Failed to map contiguous physical address range (%d)",
-				 __FUNCTION__, result));
+			PVR_DPF(PVR_DBG_ERROR, "%s: Error - "
+					"Failed to map contiguous physical "
+					"address range (%d)",
+				 __func__, result);
 			return IMG_FALSE;
 		}
 	} else {
 
 		unsigned long ulVMAPos = ps_vma->vm_start;
-		IMG_UINT32 ui32ByteEnd = ui32ByteOffset + ui32ByteSize;
-		IMG_UINT32 ui32PA;
+		u32 ui32ByteEnd = ui32ByteOffset + ui32ByteSize;
+		u32 ui32PA;
 
 		for (ui32PA = ui32ByteOffset; ui32PA < ui32ByteEnd;
 		     ui32PA += PAGE_SIZE) {
@@ -538,9 +530,10 @@
 			    REMAP_PFN_RANGE(ps_vma, ulVMAPos, pfn, PAGE_SIZE,
 					    ps_vma->vm_page_prot);
 			if (result != 0) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "%s: Error - Failed to map discontiguous physical address range (%d)",
-					 __FUNCTION__, result));
+				PVR_DPF(PVR_DBG_ERROR, "%s: Error - "
+					"Failed to map discontiguous "
+					"physical address range (%d)",
+					 __func__, result);
 				return IMG_FALSE;
 			}
 			ulVMAPos += PAGE_SIZE;
@@ -551,24 +544,25 @@
 }
 
 static IMG_BOOL
-CheckSize(LinuxMemArea * psLinuxMemArea, IMG_UINT32 ui32ByteSize)
+CheckSize(struct LinuxMemArea *psLinuxMemArea, u32 ui32ByteSize)
 {
-	IMG_CPU_PHYADDR CpuPAddr;
-	IMG_UINT32 ui32PageAlignmentOffset;
-	IMG_UINT32 ui32RealByteSize;
+	struct IMG_CPU_PHYADDR CpuPAddr;
+	u32 ui32PageAlignmentOffset;
+	u32 ui32RealByteSize;
 	CpuPAddr = LinuxMemAreaToCpuPAddr(psLinuxMemArea, 0);
 	ui32PageAlignmentOffset = ADDR_TO_PAGE_OFFSET(CpuPAddr.uiAddr);
 	ui32RealByteSize =
 	    PAGE_ALIGN(psLinuxMemArea->ui32ByteSize + ui32PageAlignmentOffset);
 	if (ui32RealByteSize < ui32ByteSize) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "Cannot mmap %ld bytes from: %-8p %-8p %08lx %-8ld %-24s\n",
+		PVR_DPF(PVR_DBG_ERROR,
+			 "Cannot mmap %ld bytes from: "
+			 "%-8p %-8p %08lx %-8ld %-24s\n",
 			 ui32ByteSize,
 			 psLinuxMemArea,
 			 LinuxMemAreaToCpuVAddr(psLinuxMemArea),
 			 LinuxMemAreaToCpuPAddr(psLinuxMemArea, 0).uiAddr,
 			 psLinuxMemArea->ui32ByteSize,
-			 LinuxMemAreaTypeToString(psLinuxMemArea->eAreaType)));
+			 LinuxMemAreaTypeToString(psLinuxMemArea->eAreaType));
 		return IMG_FALSE;
 	}
 	return IMG_TRUE;
@@ -577,17 +571,18 @@
 static void MMapVOpen(struct vm_area_struct *ps_vma)
 {
 #if defined(DEBUG_LINUX_MMAP_AREAS)
-	PKV_OFFSET_STRUCT psOffsetStruct =
-	    (PKV_OFFSET_STRUCT) ps_vma->vm_private_data;
-	PVR_ASSERT(psOffsetStruct != IMG_NULL)
-	    psOffsetStruct->ui16Mapped++;
-
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "%s: psLinuxMemArea=%p, KVAddress=%p MMapOffset=%ld, ui16Mapped=%d",
-		 __FUNCTION__,
+	struct KV_OFFSET_STRUCT *psOffsetStruct =
+	    (struct KV_OFFSET_STRUCT *)ps_vma->vm_private_data;
+	PVR_ASSERT(psOffsetStruct != NULL);
+	psOffsetStruct->ui16Mapped++;
+
+	PVR_DPF(PVR_DBG_MESSAGE,
+		 "%s: psLinuxMemArea=%p, KVAddress=%p "
+		 "MMapOffset=%ld, ui16Mapped=%d",
+		 __func__,
 		 psOffsetStruct->psLinuxMemArea,
 		 LinuxMemAreaToCpuVAddr(psOffsetStruct->psLinuxMemArea),
-		 psOffsetStruct->ui32MMapOffset, psOffsetStruct->ui16Mapped));
+		 psOffsetStruct->ui32MMapOffset, psOffsetStruct->ui16Mapped);
 #endif
 
 }
@@ -595,17 +590,18 @@
 static void MMapVClose(struct vm_area_struct *ps_vma)
 {
 #if defined(DEBUG_LINUX_MMAP_AREAS)
-	PKV_OFFSET_STRUCT psOffsetStruct =
-	    (PKV_OFFSET_STRUCT) ps_vma->vm_private_data;
-	PVR_ASSERT(psOffsetStruct != IMG_NULL)
-	    psOffsetStruct->ui16Mapped--;
-
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "%s: psLinuxMemArea=%p, CpuVAddr=%p ui32MMapOffset=%ld, ui16Mapped=%d",
-		 __FUNCTION__,
+	struct KV_OFFSET_STRUCT *psOffsetStruct =
+	    (struct KV_OFFSET_STRUCT *)ps_vma->vm_private_data;
+	PVR_ASSERT(psOffsetStruct != NULL);
+	psOffsetStruct->ui16Mapped--;
+
+	PVR_DPF(PVR_DBG_MESSAGE,
+		 "%s: psLinuxMemArea=%p, CpuVAddr=%p "
+		 "ui32MMapOffset=%ld, ui16Mapped=%d",
+		 __func__,
 		 psOffsetStruct->psLinuxMemArea,
 		 LinuxMemAreaToCpuVAddr(psOffsetStruct->psLinuxMemArea),
-		 psOffsetStruct->ui32MMapOffset, psOffsetStruct->ui16Mapped));
+		 psOffsetStruct->ui32MMapOffset, psOffsetStruct->ui16Mapped);
 #endif
 
 }
@@ -613,14 +609,15 @@
 #if defined(DEBUG_LINUX_MMAP_AREAS)
 static off_t PrintMMapRegistrations(char *buffer, size_t size, off_t off)
 {
-	PKV_OFFSET_STRUCT psOffsetStruct;
+	struct KV_OFFSET_STRUCT *psOffsetStruct;
 	off_t Ret;
 
 	down_read(&g_mmap_sem);
 	if (!off) {
 		Ret = printAppend(buffer, size, 0,
-				  "Allocations registered for mmap: %lu\n"
-				  "In total these areas correspond to %lu bytes (excluding SUB areas)\n"
+				  "Allocations registered for mmap: %u\n"
+				  "In total these areas correspond to %u "
+				  "bytes (excluding SUB areas)\n"
 				  "psLinuxMemArea "
 				  "CpuVAddr "
 				  "CpuPAddr "
@@ -639,27 +636,24 @@
 	}
 
 	for (psOffsetStruct = g_psKVOffsetTable; --off && psOffsetStruct;
-	     psOffsetStruct = psOffsetStruct->psNext) ;
+	     psOffsetStruct = psOffsetStruct->psNext)
+		;
 	if (!psOffsetStruct) {
 		Ret = END_OF_FILE;
 		goto unlock_and_return;
 	}
 
 	Ret = printAppend(buffer, size, 0,
-			  "%-8p       %-8p %08lx %08lx   %-8ld   %-24s %-5d %-8s %-5u  %08lx(%s)\n",
-			  psOffsetStruct->psLinuxMemArea,
-			  LinuxMemAreaToCpuVAddr(psOffsetStruct->
-						 psLinuxMemArea),
-			  LinuxMemAreaToCpuPAddr(psOffsetStruct->psLinuxMemArea,
-						 0).uiAddr,
-			  psOffsetStruct->ui32MMapOffset,
-			  psOffsetStruct->psLinuxMemArea->ui32ByteSize,
-			  LinuxMemAreaTypeToString(psOffsetStruct->
-						   psLinuxMemArea->eAreaType),
-			  psOffsetStruct->pid, psOffsetStruct->pszName,
-			  psOffsetStruct->ui16Mapped,
-			  psOffsetStruct->ui32AllocFlags,
-			  HAPFlagsToString(psOffsetStruct->ui32AllocFlags));
+	  "%-8p       %-8p %08x %08x   %-8d   %-24s %-5d %-8s %-5u  %08x(%s)\n",
+	  psOffsetStruct->psLinuxMemArea,
+	  LinuxMemAreaToCpuVAddr(psOffsetStruct->psLinuxMemArea),
+	  LinuxMemAreaToCpuPAddr(psOffsetStruct->psLinuxMemArea, 0).uiAddr,
+	  psOffsetStruct->ui32MMapOffset,
+	  psOffsetStruct->psLinuxMemArea->ui32ByteSize,
+	  LinuxMemAreaTypeToString(psOffsetStruct->psLinuxMemArea->eAreaType),
+	  psOffsetStruct->pid, psOffsetStruct->pszName,
+	  psOffsetStruct->ui16Mapped, psOffsetStruct->ui32AllocFlags,
+	  HAPFlagsToString(psOffsetStruct->ui32AllocFlags));
 
 unlock_and_return:
 	up_read(&g_mmap_sem);
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/mmap.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/mmap.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -31,40 +31,29 @@
 
 #include "mm.h"
 
-typedef struct KV_OFFSET_STRUCT_TAG {
-
-	IMG_UINT32 ui32MMapOffset;
-
-	LinuxMemArea *psLinuxMemArea;
-
-	IMG_UINT32 ui32AllocFlags;
-
+struct KV_OFFSET_STRUCT {
+	u32 ui32MMapOffset;
+	struct LinuxMemArea *psLinuxMemArea;
+	u32 ui32AllocFlags;
 #if defined(DEBUG_LINUX_MMAP_AREAS)
 	pid_t pid;
-	const IMG_CHAR *pszName;
-	IMG_UINT16 ui16Mapped;
-	IMG_UINT16 ui16Faults;
+	const char *pszName;
+	u16 ui16Mapped;
+	u16 ui16Faults;
 #endif
+	struct KV_OFFSET_STRUCT *psNext;
+};
 
-	struct KV_OFFSET_STRUCT_TAG *psNext;
-} KV_OFFSET_STRUCT, *PKV_OFFSET_STRUCT;
-
-IMG_VOID PVRMMapInit(void);
-
-IMG_VOID PVRMMapCleanup(void);
-
-PVRSRV_ERROR PVRMMapRegisterArea(const IMG_CHAR * pszName,
-				 LinuxMemArea * psLinuxMemArea,
-				 IMG_UINT32 ui32AllocFlags);
-
-PVRSRV_ERROR PVRMMapRemoveRegisteredArea(LinuxMemArea * psLinuxMemArea);
-
-PVRSRV_ERROR PVRMMapKVIndexAddressToMMapData(IMG_VOID * pvKVIndexAddress,
-					     IMG_UINT32 ui32Size,
-					     IMG_UINT32 * pui32MMapOffset,
-					     IMG_UINT32 * pui32ByteOffset,
-					     IMG_UINT32 * pui32RealByteSize);
-
+void PVRMMapInit(void);
+void PVRMMapCleanup(void);
+enum PVRSRV_ERROR PVRMMapRegisterArea(const char *pszName,
+				struct LinuxMemArea *psLinuxMemArea,
+				u32 ui32AllocFlags);
+enum PVRSRV_ERROR PVRMMapRemoveRegisteredArea(
+				struct LinuxMemArea *psLinuxMemArea);
+enum PVRSRV_ERROR PVRMMapKVIndexAddressToMMapData(void *pvKVIndexAddress,
+				u32 ui32Size, u32 *pui32MMapOffset,
+				u32 *pui32ByteOffset, u32 *pui32RealByteSize);
 int PVRMMap(struct file *pFile, struct vm_area_struct *ps_vma);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/mmu.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/mmu.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -35,73 +35,73 @@
 #include "sgxinfo.h"
 #include "sgxinfokm.h"
 #include "mmu.h"
+#include "sgx_bridge_km.h"
 
-typedef struct _MMU_PT_INFO_ {
+struct MMU_PT_INFO {
 
-	IMG_VOID *hPTPageOSMemHandle;
-	IMG_CPU_VIRTADDR PTPageCpuVAddr;
-	IMG_UINT32 ui32ValidPTECount;
-} MMU_PT_INFO;
+	void *hPTPageOSMemHandle;
+	void *PTPageCpuVAddr;
+	u32 ui32ValidPTECount;
+};
 
-struct _MMU_CONTEXT_ {
+struct MMU_CONTEXT {
 
-	PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
 
-	IMG_CPU_VIRTADDR pvPDCpuVAddr;
-	IMG_DEV_PHYADDR sPDDevPAddr;
+	void *pvPDCpuVAddr;
+	struct IMG_DEV_PHYADDR sPDDevPAddr;
 
-	IMG_VOID *hPDOSMemHandle;
+	void *hPDOSMemHandle;
 
-	MMU_PT_INFO *apsPTInfoList[1024];
+	struct MMU_PT_INFO *apsPTInfoList[1024];
 
-	PVRSRV_SGXDEV_INFO *psDevInfo;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo;
 
-	struct _MMU_CONTEXT_ *psNext;
+	struct MMU_CONTEXT *psNext;
 };
 
-struct _MMU_HEAP_ {
-	MMU_CONTEXT *psMMUContext;
+struct MMU_HEAP {
+	struct MMU_CONTEXT *psMMUContext;
 
-	IMG_UINT32 ui32PTBaseIndex;
-	IMG_UINT32 ui32PTPageCount;
-	IMG_UINT32 ui32PTEntryCount;
+	u32 ui32PTBaseIndex;
+	u32 ui32PTPageCount;
+	u32 ui32PTEntryCount;
 
-	RA_ARENA *psVMArena;
+	struct RA_ARENA *psVMArena;
 
-	DEV_ARENA_DESCRIPTOR *psDevArena;
+	struct DEV_ARENA_DESCRIPTOR *psDevArena;
 };
 
 
 #if defined(PDUMP)
-static IMG_VOID
-MMU_PDumpPageTables(MMU_HEAP * pMMUHeap,
-		    IMG_DEV_VIRTADDR DevVAddr,
-		    IMG_SIZE_T uSize,
-		    IMG_BOOL bForUnmap, IMG_HANDLE hUniqueTag);
+static void MMU_PDumpPageTables(struct MMU_HEAP *pMMUHeap,
+		    struct IMG_DEV_VIRTADDR DevVAddr,
+		    size_t uSize,
+		    IMG_BOOL bForUnmap, void *hUniqueTag);
 #endif
 
 #define PAGE_TEST					0
 
 
-IMG_VOID MMU_InvalidateDirectoryCache(PVRSRV_SGXDEV_INFO * psDevInfo)
+void MMU_InvalidateDirectoryCache(struct PVRSRV_SGXDEV_INFO *psDevInfo)
 {
 	psDevInfo->ui32CacheControl |= SGX_BIF_INVALIDATE_PDCACHE;
 }
 
-IMG_VOID MMU_InvalidatePageTableCache(PVRSRV_SGXDEV_INFO * psDevInfo)
+static void MMU_InvalidatePageTableCache(struct PVRSRV_SGXDEV_INFO *psDevInfo)
 {
 	psDevInfo->ui32CacheControl |= SGX_BIF_INVALIDATE_PTCACHE;
 }
 
-static IMG_BOOL _AllocPageTables(MMU_HEAP * pMMUHeap)
+static IMG_BOOL _AllocPageTables(struct MMU_HEAP *pMMUHeap)
 {
-	PVR_DPF((PVR_DBG_MESSAGE, "_AllocPageTables()"));
+	PVR_DPF(PVR_DBG_MESSAGE, "_AllocPageTables()");
 
-	PVR_ASSERT(pMMUHeap != IMG_NULL);
+	PVR_ASSERT(pMMUHeap != NULL);
 	PVR_ASSERT(HOST_PAGESIZE() == SGX_MMU_PAGE_SIZE);
 
-	if (pMMUHeap == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR, "_AllocPageTables: invalid parameter"));
+	if (pMMUHeap == NULL) {
+		PVR_DPF(PVR_DBG_ERROR, "_AllocPageTables: invalid parameter");
 		return IMG_FALSE;
 	}
 
@@ -120,18 +120,17 @@
 	return IMG_TRUE;
 }
 
-static IMG_VOID
-_DeferredFreePageTable(MMU_HEAP * pMMUHeap, IMG_UINT32 ui32PTIndex)
+static void _DeferredFreePageTable(struct MMU_HEAP *pMMUHeap, u32 ui32PTIndex)
 {
-	IMG_UINT32 *pui32PDEntry;
-	IMG_UINT32 i;
-	IMG_UINT32 ui32PDIndex;
-	SYS_DATA *psSysData;
-	MMU_PT_INFO **ppsPTInfoList;
+	u32 *pui32PDEntry;
+	u32 i;
+	u32 ui32PDIndex;
+	struct SYS_DATA *psSysData;
+	struct MMU_PT_INFO **ppsPTInfoList;
 
 	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "_DeferredFreePageTables: ERROR call to SysAcquireData failed"));
+		PVR_DPF(PVR_DBG_ERROR, "_DeferredFreePageTables: "
+				"ERROR call to SysAcquireData failed");
 		return;
 	}
 
@@ -143,7 +142,7 @@
 
 	{
 
-		PVR_ASSERT(ppsPTInfoList[ui32PTIndex] == IMG_NULL
+		PVR_ASSERT(ppsPTInfoList[ui32PTIndex] == NULL
 			   || ppsPTInfoList[ui32PTIndex]->ui32ValidPTECount ==
 			   0);
 	}
@@ -151,34 +150,32 @@
 	PDUMPCOMMENT("Free page table (page count == %08X)",
 		     pMMUHeap->ui32PTPageCount);
 	if (ppsPTInfoList[ui32PTIndex]
-	    && ppsPTInfoList[ui32PTIndex]->PTPageCpuVAddr) {
+	    && ppsPTInfoList[ui32PTIndex]->PTPageCpuVAddr)
 		PDUMPFREEPAGETABLE(PVRSRV_DEVICE_TYPE_SGX,
 				   ppsPTInfoList[ui32PTIndex]->PTPageCpuVAddr,
 				   SGX_MMU_PAGE_SIZE, PDUMP_PT_UNIQUETAG);
-	}
 
 	switch (pMMUHeap->psDevArena->DevMemHeapType) {
 	case DEVICE_MEMORY_HEAP_SHARED:
 	case DEVICE_MEMORY_HEAP_SHARED_EXPORTED:
 		{
 
-			MMU_CONTEXT *psMMUContext =
-			    (MMU_CONTEXT *) pMMUHeap->psMMUContext->psDevInfo->
-			    pvMMUContextList;
+			struct MMU_CONTEXT *psMMUContext =
+			    (struct MMU_CONTEXT *)
+			    pMMUHeap->psMMUContext->psDevInfo->pvMMUContextList;
 
 			while (psMMUContext) {
 
 				pui32PDEntry =
-				    (IMG_UINT32 *) psMMUContext->pvPDCpuVAddr;
+				    (u32 *) psMMUContext->pvPDCpuVAddr;
 				pui32PDEntry += ui32PDIndex;
 
-
 				pui32PDEntry[ui32PTIndex] = 0;
 
 				PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX,
-					  (IMG_VOID *) &
+					  (void *) &
 					  pui32PDEntry[ui32PTIndex],
-					  sizeof(IMG_UINT32), 0, IMG_FALSE,
+					  sizeof(u32), 0, IMG_FALSE,
 					  PDUMP_PT_UNIQUETAG,
 					  PDUMP_PT_UNIQUETAG);
 
@@ -191,42 +188,41 @@
 		{
 
 			pui32PDEntry =
-			    (IMG_UINT32 *) pMMUHeap->psMMUContext->pvPDCpuVAddr;
+			    (u32 *) pMMUHeap->psMMUContext->pvPDCpuVAddr;
 			pui32PDEntry += ui32PDIndex;
 
 
 			pui32PDEntry[ui32PTIndex] = 0;
 
 			PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX,
-				  (IMG_VOID *) & pui32PDEntry[ui32PTIndex],
-				  sizeof(IMG_UINT32), 0, IMG_FALSE,
+				  (void *) &pui32PDEntry[ui32PTIndex],
+				  sizeof(u32), 0, IMG_FALSE,
 				  PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
 			break;
 		}
 	default:
 		{
-			PVR_DPF((PVR_DBG_ERROR,
-				 "_DeferredFreePagetable: ERROR invalid heap type"));
+			PVR_DPF(PVR_DBG_ERROR, "_DeferredFreePagetable: "
+						"ERROR invalid heap type");
 			return;
 		}
 	}
 
-	if (ppsPTInfoList[ui32PTIndex] != IMG_NULL) {
-		if (ppsPTInfoList[ui32PTIndex]->PTPageCpuVAddr != IMG_NULL) {
-			IMG_PUINT32 pui32Tmp;
+	if (ppsPTInfoList[ui32PTIndex] != NULL) {
+		if (ppsPTInfoList[ui32PTIndex]->PTPageCpuVAddr != NULL) {
+			u32 *pui32Tmp;
 
 			pui32Tmp =
-			    (IMG_UINT32 *) ppsPTInfoList[ui32PTIndex]->
+			    (u32 *) ppsPTInfoList[ui32PTIndex]->
 			    PTPageCpuVAddr;
 
 			for (i = 0;
 			     (i < pMMUHeap->ui32PTEntryCount) && (i < 1024);
-			     i++) {
+			     i++)
 				pui32Tmp[i] = 0;
-			}
 
 			if (pMMUHeap->psDevArena->psDeviceMemoryHeapInfo->
-			    psLocalDevMemArena == IMG_NULL) {
+			    psLocalDevMemArena == NULL) {
 				OSFreePages(PVRSRV_HAP_WRITECOMBINE |
 					    PVRSRV_HAP_KERNEL_ONLY,
 					    SGX_MMU_PAGE_SIZE,
@@ -235,8 +231,8 @@
 					    ppsPTInfoList[ui32PTIndex]->
 					    hPTPageOSMemHandle);
 			} else {
-				IMG_SYS_PHYADDR sSysPAddr;
-				IMG_CPU_PHYADDR sCpuPAddr;
+				struct IMG_SYS_PHYADDR sSysPAddr;
+				struct IMG_CPU_PHYADDR sCpuPAddr;
 
 				sCpuPAddr =
 				    OSMapLinToCPUPhys(ppsPTInfoList
@@ -244,8 +240,9 @@
 						      PTPageCpuVAddr);
 				sSysPAddr = SysCpuPAddrToSysPAddr(sCpuPAddr);
 
-				OSUnMapPhysToLin(ppsPTInfoList[ui32PTIndex]->
-						 PTPageCpuVAddr,
+				OSUnMapPhysToLin((void __force __iomem *)
+						   ppsPTInfoList[ui32PTIndex]->
+							PTPageCpuVAddr,
 						 SGX_MMU_PAGE_SIZE,
 						 PVRSRV_HAP_WRITECOMBINE |
 						 PVRSRV_HAP_KERNEL_ONLY,
@@ -265,9 +262,9 @@
 		}
 
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  sizeof(MMU_PT_INFO),
-			  ppsPTInfoList[ui32PTIndex], IMG_NULL);
-		ppsPTInfoList[ui32PTIndex] = IMG_NULL;
+			  sizeof(struct MMU_PT_INFO),
+			  ppsPTInfoList[ui32PTIndex], NULL);
+		ppsPTInfoList[ui32PTIndex] = NULL;
 	} else {
 
 		pMMUHeap->ui32PTEntryCount -= 1024;
@@ -277,32 +274,29 @@
 		     pMMUHeap->ui32PTPageCount);
 }
 
-static IMG_VOID _DeferredFreePageTables(MMU_HEAP * pMMUHeap)
+static void _DeferredFreePageTables(struct MMU_HEAP *pMMUHeap)
 {
-	IMG_UINT32 i;
+	u32 i;
 
-	for (i = 0; i < pMMUHeap->ui32PTPageCount; i++) {
+	for (i = 0; i < pMMUHeap->ui32PTPageCount; i++)
 		_DeferredFreePageTable(pMMUHeap, i);
-	}
 	MMU_InvalidateDirectoryCache(pMMUHeap->psMMUContext->psDevInfo);
 }
 
-static IMG_BOOL
-_DeferredAllocPagetables(MMU_HEAP * pMMUHeap, IMG_DEV_VIRTADDR DevVAddr,
-			 IMG_UINT32 ui32Size)
-{
-	IMG_UINT32 ui32PTPageCount;
-	IMG_UINT32 ui32PDIndex;
-	IMG_UINT32 i;
-	IMG_UINT32 *pui32PDEntry;
-	MMU_PT_INFO **ppsPTInfoList;
-	SYS_DATA *psSysData;
+static IMG_BOOL _DeferredAllocPagetables(struct MMU_HEAP *pMMUHeap,
+				struct IMG_DEV_VIRTADDR DevVAddr, u32 ui32Size)
+{
+	u32 ui32PTPageCount;
+	u32 ui32PDIndex;
+	u32 i;
+	u32 *pui32PDEntry;
+	struct MMU_PT_INFO **ppsPTInfoList;
+	struct SYS_DATA *psSysData;
 
 	PVR_ASSERT(DevVAddr.uiAddr < (1 << SGX_FEATURE_ADDRESS_SPACE_SIZE));
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
+	if (SysAcquireData(&psSysData) != PVRSRV_OK)
 		return IMG_FALSE;
-	}
 
 	ui32PDIndex =
 	    DevVAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);
@@ -313,7 +307,7 @@
 	    >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);
 	ui32PTPageCount -= ui32PDIndex;
 
-	pui32PDEntry = (IMG_UINT32 *) pMMUHeap->psMMUContext->pvPDCpuVAddr;
+	pui32PDEntry = (u32 *) pMMUHeap->psMMUContext->pvPDCpuVAddr;
 	pui32PDEntry += ui32PDIndex;
 
 	ppsPTInfoList = &pMMUHeap->psMMUContext->apsPTInfoList[ui32PDIndex];
@@ -323,78 +317,78 @@
 		     ui32PTPageCount);
 
 	for (i = 0; i < ui32PTPageCount; i++) {
-		if (ppsPTInfoList[i] == IMG_NULL) {
+		if (ppsPTInfoList[i] == NULL) {
 			OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-				   sizeof(MMU_PT_INFO),
-				   (IMG_VOID **) & ppsPTInfoList[i], IMG_NULL);
-			if (ppsPTInfoList[i] == IMG_NULL) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "_DeferredAllocPagetables: ERROR call to OSAllocMem failed"));
+				   sizeof(struct MMU_PT_INFO),
+				   (void **) &ppsPTInfoList[i], NULL);
+			if (ppsPTInfoList[i] == NULL) {
+				PVR_DPF(PVR_DBG_ERROR,
+					 "_DeferredAllocPagetables: "
+					 "ERROR call to OSAllocMem failed");
 				return IMG_FALSE;
 			}
-			OSMemSet(ppsPTInfoList[i], 0, sizeof(MMU_PT_INFO));
+			OSMemSet(ppsPTInfoList[i], 0,
+				 sizeof(struct MMU_PT_INFO));
 		}
 
-		if (ppsPTInfoList[i]->hPTPageOSMemHandle == IMG_NULL
-		    && ppsPTInfoList[i]->PTPageCpuVAddr == IMG_NULL) {
-			IMG_CPU_PHYADDR sCpuPAddr;
-			IMG_DEV_PHYADDR sDevPAddr;
+		if (ppsPTInfoList[i]->hPTPageOSMemHandle == NULL
+		    && ppsPTInfoList[i]->PTPageCpuVAddr == NULL) {
+			struct IMG_CPU_PHYADDR sCpuPAddr;
+			struct IMG_DEV_PHYADDR sDevPAddr;
 
 			PVR_ASSERT(pui32PDEntry[i] == 0);
 
 			if (pMMUHeap->psDevArena->psDeviceMemoryHeapInfo->
-			    psLocalDevMemArena == IMG_NULL) {
+			    psLocalDevMemArena == NULL) {
 				if (OSAllocPages
 				    (PVRSRV_HAP_WRITECOMBINE |
 				     PVRSRV_HAP_KERNEL_ONLY, SGX_MMU_PAGE_SIZE,
-				     (IMG_VOID **) & ppsPTInfoList[i]->
+				     (void **) &ppsPTInfoList[i]->
 				     PTPageCpuVAddr,
 				     &ppsPTInfoList[i]->hPTPageOSMemHandle) !=
 				    PVRSRV_OK) {
-					PVR_DPF((PVR_DBG_ERROR,
-						 "_DeferredAllocPagetables: ERROR call to OSAllocPages failed"));
+					PVR_DPF(PVR_DBG_ERROR,
+					  "_DeferredAllocPagetables: "
+					  "ERROR call to OSAllocPages failed");
 					return IMG_FALSE;
 				}
 
-				if (ppsPTInfoList[i]->PTPageCpuVAddr) {
-					sCpuPAddr =
-					    OSMapLinToCPUPhys(ppsPTInfoList[i]->
-							      PTPageCpuVAddr);
-				} else {
-
-					sCpuPAddr =
-					    OSMemHandleToCpuPAddr(ppsPTInfoList
-								  [i]->
-								  hPTPageOSMemHandle,
-								  0);
-				}
-				sDevPAddr =
-				    SysCpuPAddrToDevPAddr
+				if (ppsPTInfoList[i]->PTPageCpuVAddr)
+					sCpuPAddr = OSMapLinToCPUPhys(
+					     ppsPTInfoList[i]->PTPageCpuVAddr);
+				else
+
+					sCpuPAddr = OSMemHandleToCpuPAddr(
+					     ppsPTInfoList[i]->
+						  hPTPageOSMemHandle, 0);
+				sDevPAddr = SysCpuPAddrToDevPAddr
 				    (PVRSRV_DEVICE_TYPE_SGX, sCpuPAddr);
 			} else {
-				IMG_SYS_PHYADDR sSysPAddr;
+				struct IMG_SYS_PHYADDR sSysPAddr;
 
-				if (RA_Alloc
-				    (pMMUHeap->psDevArena->
+				if (RA_Alloc(pMMUHeap->psDevArena->
 				     psDeviceMemoryHeapInfo->psLocalDevMemArena,
-				     SGX_MMU_PAGE_SIZE, IMG_NULL, IMG_NULL, 0,
+				     SGX_MMU_PAGE_SIZE, NULL, NULL, 0,
 				     SGX_MMU_PAGE_SIZE, 0,
 				     &(sSysPAddr.uiAddr)) != IMG_TRUE) {
-					PVR_DPF((PVR_DBG_ERROR,
-						 "_DeferredAllocPagetables: ERROR call to RA_Alloc failed"));
+					PVR_DPF(PVR_DBG_ERROR,
+					      "_DeferredAllocPagetables: "
+					      "ERROR call to RA_Alloc failed");
 					return IMG_FALSE;
 				}
 
 				sCpuPAddr = SysSysPAddrToCpuPAddr(sSysPAddr);
 				ppsPTInfoList[i]->PTPageCpuVAddr =
+				    (void __force *)
 				    OSMapPhysToLin(sCpuPAddr, SGX_MMU_PAGE_SIZE,
 						   PVRSRV_HAP_WRITECOMBINE |
 						   PVRSRV_HAP_KERNEL_ONLY,
 						   &ppsPTInfoList[i]->
 						   hPTPageOSMemHandle);
 				if (!ppsPTInfoList[i]->PTPageCpuVAddr) {
-					PVR_DPF((PVR_DBG_ERROR,
-						 "_DeferredAllocPagetables: ERROR failed to map page tables"));
+					PVR_DPF(PVR_DBG_ERROR,
+					    "_DeferredAllocPagetables: "
+					    "ERROR failed to map page tables");
 					return IMG_FALSE;
 				}
 
@@ -423,15 +417,15 @@
 			case DEVICE_MEMORY_HEAP_SHARED_EXPORTED:
 				{
 
-					MMU_CONTEXT *psMMUContext =
-					    (MMU_CONTEXT *) pMMUHeap->
+					struct MMU_CONTEXT *psMMUContext =
+					    (struct MMU_CONTEXT *)pMMUHeap->
 					    psMMUContext->psDevInfo->
 					    pvMMUContextList;
 
 					while (psMMUContext) {
 
 						pui32PDEntry =
-						    (IMG_UINT32 *)
+						    (u32 *)
 						    psMMUContext->pvPDCpuVAddr;
 						pui32PDEntry += ui32PDIndex;
 
@@ -441,9 +435,9 @@
 
 						PDUMPMEM2
 						    (PVRSRV_DEVICE_TYPE_SGX,
-						     (IMG_VOID *) &
+						     (void *) &
 						     pui32PDEntry[i],
-						     sizeof(IMG_UINT32), 0,
+						     sizeof(u32), 0,
 						     IMG_FALSE,
 						     PDUMP_PD_UNIQUETAG,
 						     PDUMP_PT_UNIQUETAG);
@@ -462,9 +456,9 @@
 					    uiAddr | SGX_MMU_PDE_VALID;
 
 					PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX,
-						  (IMG_VOID *) &
+						  (void *) &
 						  pui32PDEntry[i],
-						  sizeof(IMG_UINT32), 0,
+						  sizeof(u32), 0,
 						  IMG_FALSE, PDUMP_PD_UNIQUETAG,
 						  PDUMP_PT_UNIQUETAG);
 
@@ -472,8 +466,9 @@
 				}
 			default:
 				{
-					PVR_DPF((PVR_DBG_ERROR,
-						 "_DeferredAllocPagetables: ERROR invalid heap type"));
+					PVR_DPF(PVR_DBG_ERROR,
+						"_DeferredAllocPagetables: "
+						"ERROR invalid heap type");
 					return IMG_FALSE;
 				}
 			}
@@ -490,90 +485,85 @@
 	return IMG_TRUE;
 }
 
-PVRSRV_ERROR
-MMU_Initialise(PVRSRV_DEVICE_NODE * psDeviceNode, MMU_CONTEXT ** ppsMMUContext,
-	       IMG_DEV_PHYADDR * psPDDevPAddr)
-{
-	IMG_UINT32 *pui32Tmp;
-	IMG_UINT32 i;
-	IMG_CPU_VIRTADDR pvPDCpuVAddr;
-	IMG_DEV_PHYADDR sPDDevPAddr;
-	IMG_CPU_PHYADDR sCpuPAddr;
-	MMU_CONTEXT *psMMUContext;
-	IMG_HANDLE hPDOSMemHandle;
-	SYS_DATA *psSysData;
-	PVRSRV_SGXDEV_INFO *psDevInfo;
+enum PVRSRV_ERROR MMU_Initialise(struct PVRSRV_DEVICE_NODE *psDeviceNode,
+			    struct MMU_CONTEXT **ppsMMUContext,
+			    struct IMG_DEV_PHYADDR *psPDDevPAddr)
+{
+	u32 *pui32Tmp;
+	u32 i;
+	void *pvPDCpuVAddr;
+	struct IMG_DEV_PHYADDR sPDDevPAddr;
+	struct IMG_CPU_PHYADDR sCpuPAddr;
+	struct MMU_CONTEXT *psMMUContext;
+	void *hPDOSMemHandle;
+	struct SYS_DATA *psSysData;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo;
 
-	PVR_DPF((PVR_DBG_MESSAGE, "MMU_Initialise"));
+	PVR_DPF(PVR_DBG_MESSAGE, "MMU_Initialise");
 
 	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "MMU_Initialise: ERROR call to SysAcquireData failed"));
+		PVR_DPF(PVR_DBG_ERROR, "MMU_Initialise: "
+					"ERROR call to SysAcquireData failed");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
 	OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		   sizeof(MMU_CONTEXT), (IMG_VOID **) & psMMUContext, IMG_NULL);
-	if (psMMUContext == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "MMU_Initialise: ERROR call to OSAllocMem failed"));
+		   sizeof(struct MMU_CONTEXT), (void **) &psMMUContext, NULL);
+	if (psMMUContext == NULL) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "MMU_Initialise: ERROR call to OSAllocMem failed");
 		return PVRSRV_ERROR_GENERIC;
 	}
-	OSMemSet(psMMUContext, 0, sizeof(MMU_CONTEXT));
+	OSMemSet(psMMUContext, 0, sizeof(struct MMU_CONTEXT));
 
-	psDevInfo = (PVRSRV_SGXDEV_INFO *) psDeviceNode->pvDevice;
+	psDevInfo = (struct PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
 	psMMUContext->psDevInfo = psDevInfo;
 
 	psMMUContext->psDeviceNode = psDeviceNode;
 
-	if (psDeviceNode->psLocalDevMemArena == IMG_NULL) {
+	if (psDeviceNode->psLocalDevMemArena == NULL) {
 		if (OSAllocPages
 		    (PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_KERNEL_ONLY,
 		     SGX_MMU_PAGE_SIZE, &pvPDCpuVAddr,
 		     &hPDOSMemHandle) != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "MMU_Initialise: ERROR call to OSAllocPages failed"));
+			PVR_DPF(PVR_DBG_ERROR, "MMU_Initialise: "
+				"ERROR call to OSAllocPages failed");
 			return PVRSRV_ERROR_GENERIC;
 		}
 
-		if (pvPDCpuVAddr) {
+		if (pvPDCpuVAddr)
 			sCpuPAddr = OSMapLinToCPUPhys(pvPDCpuVAddr);
-		} else {
+		else
 
 			sCpuPAddr = OSMemHandleToCpuPAddr(hPDOSMemHandle, 0);
-		}
 		sPDDevPAddr =
 		    SysCpuPAddrToDevPAddr(PVRSRV_DEVICE_TYPE_SGX, sCpuPAddr);
 
 
 	} else {
-		IMG_SYS_PHYADDR sSysPAddr;
+		struct IMG_SYS_PHYADDR sSysPAddr;
 
 		if (RA_Alloc(psDeviceNode->psLocalDevMemArena,
-			     SGX_MMU_PAGE_SIZE,
-			     IMG_NULL,
-			     IMG_NULL,
-			     0,
+			     SGX_MMU_PAGE_SIZE, NULL, NULL, 0,
 			     SGX_MMU_PAGE_SIZE,
 			     0, &(sSysPAddr.uiAddr)) != IMG_TRUE) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "MMU_Initialise: ERROR call to RA_Alloc failed"));
+			PVR_DPF(PVR_DBG_ERROR, "MMU_Initialise: "
+					"ERROR call to RA_Alloc failed");
 			return PVRSRV_ERROR_GENERIC;
 		}
 
 		sCpuPAddr = SysSysPAddrToCpuPAddr(sSysPAddr);
 		sPDDevPAddr =
 		    SysSysPAddrToDevPAddr(PVRSRV_DEVICE_TYPE_SGX, sSysPAddr);
-		pvPDCpuVAddr =
+		pvPDCpuVAddr = (void __force *)
 		    OSMapPhysToLin(sCpuPAddr, SGX_MMU_PAGE_SIZE,
 				   PVRSRV_HAP_WRITECOMBINE |
 				   PVRSRV_HAP_KERNEL_ONLY, &hPDOSMemHandle);
 		if (!pvPDCpuVAddr) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "MMU_Initialise: ERROR failed to map page tables"));
+			PVR_DPF(PVR_DBG_ERROR, "MMU_Initialise: "
+					"ERROR failed to map page tables");
 			return PVRSRV_ERROR_GENERIC;
 		}
-
 	}
 
 	PDUMPCOMMENT("Alloc page directory");
@@ -582,18 +572,15 @@
 			     SGX_MMU_PAGE_SIZE, PDUMP_PD_UNIQUETAG);
 
 	if (pvPDCpuVAddr) {
-		pui32Tmp = (IMG_UINT32 *) pvPDCpuVAddr;
+		pui32Tmp = (u32 *) pvPDCpuVAddr;
 	} else {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "MMU_Initialise: pvPDCpuVAddr invalid"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "MMU_Initialise: pvPDCpuVAddr invalid");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
-
-	for (i = 0; i < SGX_MMU_PD_SIZE; i++) {
-
+	for (i = 0; i < SGX_MMU_PD_SIZE; i++)
 		pui32Tmp[i] = 0;
-	}
 
 	PDUMPCOMMENT("Page directory contents");
 	PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX, pvPDCpuVAddr, SGX_MMU_PAGE_SIZE, 0,
@@ -607,22 +594,23 @@
 
 	*psPDDevPAddr = sPDDevPAddr;
 
-	psMMUContext->psNext = (MMU_CONTEXT *) psDevInfo->pvMMUContextList;
-	psDevInfo->pvMMUContextList = (IMG_VOID *) psMMUContext;
+	psMMUContext->psNext = (struct MMU_CONTEXT *)
+						psDevInfo->pvMMUContextList;
+	psDevInfo->pvMMUContextList = (void *) psMMUContext;
 
 
 	return PVRSRV_OK;
 }
 
-IMG_VOID MMU_Finalise(MMU_CONTEXT * psMMUContext)
+void MMU_Finalise(struct MMU_CONTEXT *psMMUContext)
 {
-	IMG_UINT32 *pui32Tmp, i;
-	SYS_DATA *psSysData;
-	MMU_CONTEXT **ppsMMUContext;
+	u32 *pui32Tmp, i;
+	struct SYS_DATA *psSysData;
+	struct MMU_CONTEXT **ppsMMUContext;
 
 	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "MMU_Finalise: ERROR call to SysAcquireData failed"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "MMU_Finalise: ERROR call to SysAcquireData failed");
 		return;
 	}
 
@@ -630,30 +618,29 @@
 	PDUMPFREEPAGETABLE(PVRSRV_DEVICE_TYPE_SGX, psMMUContext->pvPDCpuVAddr,
 			   SGX_MMU_PAGE_SIZE, PDUMP_PT_UNIQUETAG);
 
-	pui32Tmp = (IMG_UINT32 *) psMMUContext->pvPDCpuVAddr;
-
-	for (i = 0; i < SGX_MMU_PD_SIZE; i++) {
+	pui32Tmp = (u32 *) psMMUContext->pvPDCpuVAddr;
 
+	for (i = 0; i < SGX_MMU_PD_SIZE; i++)
 		pui32Tmp[i] = 0;
-	}
 
-	if (psMMUContext->psDeviceNode->psLocalDevMemArena == IMG_NULL) {
+	if (psMMUContext->psDeviceNode->psLocalDevMemArena == NULL) {
 		OSFreePages(PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_KERNEL_ONLY,
 			    SGX_MMU_PAGE_SIZE,
 			    psMMUContext->pvPDCpuVAddr,
 			    psMMUContext->hPDOSMemHandle);
 
 	} else {
-		IMG_SYS_PHYADDR sSysPAddr;
-		IMG_CPU_PHYADDR sCpuPAddr;
+		struct IMG_SYS_PHYADDR sSysPAddr;
+		struct IMG_CPU_PHYADDR sCpuPAddr;
 
 		sCpuPAddr = OSMapLinToCPUPhys(psMMUContext->pvPDCpuVAddr);
 		sSysPAddr = SysCpuPAddrToSysPAddr(sCpuPAddr);
 
-		OSUnMapPhysToLin(psMMUContext->pvPDCpuVAddr,
+		OSUnMapPhysToLin((void __iomem __force *)
+					psMMUContext->pvPDCpuVAddr,
 				 SGX_MMU_PAGE_SIZE,
 				 PVRSRV_HAP_WRITECOMBINE |
-				 PVRSRV_HAP_KERNEL_ONLY,
+						PVRSRV_HAP_KERNEL_ONLY,
 				 psMMUContext->hPDOSMemHandle);
 
 		RA_Free(psMMUContext->psDeviceNode->psLocalDevMemArena,
@@ -661,10 +648,10 @@
 
 	}
 
-	PVR_DPF((PVR_DBG_MESSAGE, "MMU_Finalise"));
+	PVR_DPF(PVR_DBG_MESSAGE, "MMU_Finalise");
 
 	ppsMMUContext =
-	    (MMU_CONTEXT **) & psMMUContext->psDevInfo->pvMMUContextList;
+	    (struct MMU_CONTEXT **) &psMMUContext->psDevInfo->pvMMUContextList;
 	while (*ppsMMUContext) {
 		if (*ppsMMUContext == psMMUContext) {
 
@@ -675,16 +662,17 @@
 		ppsMMUContext = &((*ppsMMUContext)->psNext);
 	}
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(MMU_CONTEXT), psMMUContext,
-		  IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct MMU_CONTEXT),
+		  psMMUContext, NULL);
 }
 
-IMG_VOID MMU_InsertHeap(MMU_CONTEXT * psMMUContext, MMU_HEAP * psMMUHeap)
+void MMU_InsertHeap(struct MMU_CONTEXT *psMMUContext,
+		    struct MMU_HEAP *psMMUHeap)
 {
-	IMG_UINT32 *pui32PDCpuVAddr = (IMG_UINT32 *) psMMUContext->pvPDCpuVAddr;
-	IMG_UINT32 *pui32KernelPDCpuVAddr =
-	    (IMG_UINT32 *) psMMUHeap->psMMUContext->pvPDCpuVAddr;
-	IMG_UINT32 ui32PDEntry;
+	u32 *pui32PDCpuVAddr = (u32 *)psMMUContext->pvPDCpuVAddr;
+	u32 *pui32KernelPDCpuVAddr = (u32 *)
+					psMMUHeap->psMMUContext->pvPDCpuVAddr;
+	u32 ui32PDEntry;
 	IMG_BOOL bInvalidateDirectoryCache = IMG_FALSE;
 
 	pui32PDCpuVAddr +=
@@ -705,8 +693,8 @@
 		    pui32KernelPDCpuVAddr[ui32PDEntry];
 		if (pui32PDCpuVAddr[ui32PDEntry]) {
 			PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX,
-				  (IMG_VOID *) & pui32PDCpuVAddr[ui32PDEntry],
-				  sizeof(IMG_UINT32), 0, IMG_FALSE,
+				  (void *) &pui32PDCpuVAddr[ui32PDEntry],
+				  sizeof(u32), 0, IMG_FALSE,
 				  PDUMP_PD_UNIQUETAG, PDUMP_PT_UNIQUETAG);
 
 			bInvalidateDirectoryCache = IMG_TRUE;
@@ -714,33 +702,31 @@
 	}
 
 
-	if (bInvalidateDirectoryCache) {
+	if (bInvalidateDirectoryCache)
 
 		MMU_InvalidateDirectoryCache(psMMUContext->psDevInfo);
-	}
 }
 
-static IMG_VOID
-MMU_UnmapPagesAndFreePTs(MMU_HEAP * psMMUHeap,
-			 IMG_DEV_VIRTADDR sDevVAddr,
-			 IMG_UINT32 ui32PageCount, IMG_HANDLE hUniqueTag)
-{
-	IMG_UINT32 uPageSize = HOST_PAGESIZE();
-	IMG_DEV_VIRTADDR sTmpDevVAddr;
-	IMG_UINT32 i;
-	IMG_UINT32 ui32PDIndex;
-	IMG_UINT32 ui32PTIndex;
-	IMG_UINT32 *pui32Tmp;
+static void MMU_UnmapPagesAndFreePTs(struct MMU_HEAP *psMMUHeap,
+			 struct IMG_DEV_VIRTADDR sDevVAddr,
+			 u32 ui32PageCount, void *hUniqueTag)
+{
+	u32 uPageSize = HOST_PAGESIZE();
+	struct IMG_DEV_VIRTADDR sTmpDevVAddr;
+	u32 i;
+	u32 ui32PDIndex;
+	u32 ui32PTIndex;
+	u32 *pui32Tmp;
 	IMG_BOOL bInvalidateDirectoryCache = IMG_FALSE;
 
-#if !defined (PDUMP)
+#if !defined(PDUMP)
 	PVR_UNREFERENCED_PARAMETER(hUniqueTag);
 #endif
 
 	sTmpDevVAddr = sDevVAddr;
 
 	for (i = 0; i < ui32PageCount; i++) {
-		MMU_PT_INFO **ppsPTInfoList;
+		struct MMU_PT_INFO **ppsPTInfoList;
 
 		ui32PDIndex =
 		    sTmpDevVAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT +
@@ -750,16 +736,17 @@
 		    &psMMUHeap->psMMUContext->apsPTInfoList[ui32PDIndex];
 
 		{
-
-			ui32PTIndex =
-			    (sTmpDevVAddr.
-			     uiAddr & SGX_MMU_PT_MASK) >> SGX_MMU_PAGE_SHIFT;
+			ui32PTIndex = (sTmpDevVAddr.uiAddr & SGX_MMU_PT_MASK)
+						>> SGX_MMU_PAGE_SHIFT;
 
 			if (!ppsPTInfoList[0]) {
-				PVR_DPF((PVR_DBG_MESSAGE,
-					 "MMU_UnmapPagesAndFreePTs: Invalid PT for alloc at VAddr:0x%08lX (VaddrIni:0x%08lX AllocPage:%u) PDIdx:%u PTIdx:%u",
+				PVR_DPF(PVR_DBG_MESSAGE,
+					"MMU_UnmapPagesAndFreePTs: "
+					"Invalid PT for alloc at VAddr:0x%08lX "
+					"(VaddrIni:0x%08lX AllocPage:%u) "
+					"PDIdx:%u PTIdx:%u",
 					 sTmpDevVAddr.uiAddr, sDevVAddr.uiAddr,
-					 i, ui32PDIndex, ui32PTIndex));
+					 i, ui32PDIndex, ui32PTIndex);
 
 				sTmpDevVAddr.uiAddr += uPageSize;
 
@@ -767,23 +754,24 @@
 			}
 
 			pui32Tmp =
-			    (IMG_UINT32 *) ppsPTInfoList[0]->PTPageCpuVAddr;
+			    (u32 *) ppsPTInfoList[0]->PTPageCpuVAddr;
 
-			if (!pui32Tmp) {
+			if (!pui32Tmp)
 				continue;
-			}
 
-			if (pui32Tmp[ui32PTIndex] & SGX_MMU_PTE_VALID) {
+			if (pui32Tmp[ui32PTIndex] & SGX_MMU_PTE_VALID)
 				ppsPTInfoList[0]->ui32ValidPTECount--;
-			} else {
-				PVR_DPF((PVR_DBG_MESSAGE,
-					 "MMU_UnmapPagesAndFreePTs: Page is already invalid for alloc at VAddr:0x%08lX (VAddrIni:0x%08lX AllocPage:%u) PDIdx:%u PTIdx:%u",
+			else
+				PVR_DPF(PVR_DBG_MESSAGE,
+					 "MMU_UnmapPagesAndFreePTs: "
+					 "Page is already invalid for alloc at "
+					 "VAddr:0x%08lX (VAddrIni:0x%08lX "
+					 "AllocPage:%u) PDIdx:%u PTIdx:%u",
 					 sTmpDevVAddr.uiAddr, sDevVAddr.uiAddr,
-					 i, ui32PDIndex, ui32PTIndex));
-			}
+					 i, ui32PDIndex, ui32PTIndex);
 
-			PVR_ASSERT((IMG_INT32) ppsPTInfoList[0]->
-				   ui32ValidPTECount >= 0);
+			PVR_ASSERT((s32) ppsPTInfoList[0]->ui32ValidPTECount >=
+									0);
 
 
 			pui32Tmp[ui32PTIndex] = 0;
@@ -802,13 +790,12 @@
 		sTmpDevVAddr.uiAddr += uPageSize;
 	}
 
-	if (bInvalidateDirectoryCache) {
+	if (bInvalidateDirectoryCache)
 		MMU_InvalidateDirectoryCache(psMMUHeap->psMMUContext->
 					     psDevInfo);
-	} else {
+	else
 		MMU_InvalidatePageTableCache(psMMUHeap->psMMUContext->
 					     psDevInfo);
-	}
 
 #if defined(PDUMP)
 	MMU_PDumpPageTables(psMMUHeap, sDevVAddr, uPageSize * ui32PageCount,
@@ -816,12 +803,12 @@
 #endif
 }
 
-IMG_VOID MMU_FreePageTables(IMG_PVOID pvMMUHeap,
-			    IMG_UINT32 ui32Start,
-			    IMG_UINT32 ui32End, IMG_HANDLE hUniqueTag)
+static void MMU_FreePageTables(void *pvMMUHeap,
+			    u32 ui32Start,
+			    u32 ui32End, void *hUniqueTag)
 {
-	MMU_HEAP *pMMUHeap = (MMU_HEAP *) pvMMUHeap;
-	IMG_DEV_VIRTADDR Start;
+	struct MMU_HEAP *pMMUHeap = (struct MMU_HEAP *)pvMMUHeap;
+	struct IMG_DEV_VIRTADDR Start;
 
 	Start.uiAddr = ui32Start;
 
@@ -830,25 +817,26 @@
 				 hUniqueTag);
 }
 
-MMU_HEAP *MMU_Create(MMU_CONTEXT * psMMUContext,
-		     DEV_ARENA_DESCRIPTOR * psDevArena, RA_ARENA ** ppsVMArena)
+struct MMU_HEAP *MMU_Create(struct MMU_CONTEXT *psMMUContext,
+			    struct DEV_ARENA_DESCRIPTOR *psDevArena,
+			    struct RA_ARENA **ppsVMArena)
 {
-	MMU_HEAP *pMMUHeap;
+	struct MMU_HEAP *pMMUHeap;
 	IMG_BOOL bRes;
 
-	PVR_ASSERT(psDevArena != IMG_NULL);
+	PVR_ASSERT(psDevArena != NULL);
 
-	if (psDevArena == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR, "MMU_Create: invalid parameter"));
-		return IMG_NULL;
+	if (psDevArena == NULL) {
+		PVR_DPF(PVR_DBG_ERROR, "MMU_Create: invalid parameter");
+		return NULL;
 	}
 
 	OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		   sizeof(MMU_HEAP), (IMG_VOID **) & pMMUHeap, IMG_NULL);
-	if (pMMUHeap == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "MMU_Create: ERROR call to OSAllocMem failed"));
-		return IMG_NULL;
+		   sizeof(struct MMU_HEAP), (void **) &pMMUHeap, NULL);
+	if (pMMUHeap == NULL) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "MMU_Create: ERROR call to OSAllocMem failed");
+		return NULL;
 	}
 
 	pMMUHeap->psMMUContext = psMMUContext;
@@ -856,28 +844,28 @@
 
 	bRes = _AllocPageTables(pMMUHeap);
 	if (!bRes) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "MMU_Create: ERROR call to _AllocPageTables failed"));
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(MMU_HEAP), pMMUHeap,
-			  IMG_NULL);
-		return IMG_NULL;
+		PVR_DPF(PVR_DBG_ERROR,
+			 "MMU_Create: ERROR call to _AllocPageTables failed");
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct MMU_HEAP),
+			  pMMUHeap, NULL);
+		return NULL;
 	}
 
 	pMMUHeap->psVMArena = RA_Create(psDevArena->pszName,
 					psDevArena->BaseDevVAddr.uiAddr,
 					psDevArena->ui32Size,
-					IMG_NULL,
+					NULL,
 					SGX_MMU_PAGE_SIZE,
-					IMG_NULL,
-					IMG_NULL, MMU_FreePageTables, pMMUHeap);
+					NULL,
+					NULL, MMU_FreePageTables, pMMUHeap);
 
-	if (pMMUHeap->psVMArena == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "MMU_Create: ERROR call to RA_Create failed"));
+	if (pMMUHeap->psVMArena == NULL) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "MMU_Create: ERROR call to RA_Create failed");
 		_DeferredFreePageTables(pMMUHeap);
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(MMU_HEAP),
-			  pMMUHeap, IMG_NULL);
-		return IMG_NULL;
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct MMU_HEAP),
+			  pMMUHeap, NULL);
+		return NULL;
 	}
 
 	*ppsVMArena = pMMUHeap->psVMArena;
@@ -885,45 +873,44 @@
 	return pMMUHeap;
 }
 
-IMG_VOID MMU_Delete(MMU_HEAP * pMMUHeap)
+void MMU_Delete(struct MMU_HEAP *pMMUHeap)
 {
-	if (pMMUHeap != IMG_NULL) {
-		PVR_DPF((PVR_DBG_MESSAGE, "MMU_Delete"));
+	if (pMMUHeap != NULL) {
+		PVR_DPF(PVR_DBG_MESSAGE, "MMU_Delete");
 
-		if (pMMUHeap->psVMArena) {
+		if (pMMUHeap->psVMArena)
 			RA_Delete(pMMUHeap->psVMArena);
-		}
 		_DeferredFreePageTables(pMMUHeap);
 
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(MMU_HEAP),
-			  pMMUHeap, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct MMU_HEAP),
+			  pMMUHeap, NULL);
 	}
 }
 
 IMG_BOOL
-MMU_Alloc(MMU_HEAP * pMMUHeap,
-	  IMG_SIZE_T uSize,
-	  IMG_SIZE_T * pActualSize,
-	  IMG_UINT32 uFlags,
-	  IMG_UINT32 uDevVAddrAlignment, IMG_DEV_VIRTADDR * psDevVAddr)
+MMU_Alloc(struct MMU_HEAP *pMMUHeap,
+	  size_t uSize,
+	  size_t *pActualSize,
+	  u32 uFlags,
+	  u32 uDevVAddrAlignment, struct IMG_DEV_VIRTADDR *psDevVAddr)
 {
 	IMG_BOOL bStatus;
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "MMU_Alloc: uSize=0x%x, flags=0x%x, align=0x%x",
-		 uSize, uFlags, uDevVAddrAlignment));
+		 uSize, uFlags, uDevVAddrAlignment);
 
 	if ((uFlags & PVRSRV_MEM_USER_SUPPLIED_DEVVADDR) == 0) {
 		bStatus = RA_Alloc(pMMUHeap->psVMArena,
 				   uSize,
 				   pActualSize,
-				   IMG_NULL,
+				   NULL,
 				   0,
 				   uDevVAddrAlignment,
 				   0, &(psDevVAddr->uiAddr));
 		if (!bStatus) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "MMU_Alloc: RA_Alloc of VMArena failed"));
+			PVR_DPF(PVR_DBG_ERROR,
+				 "MMU_Alloc: RA_Alloc of VMArena failed");
 			return bStatus;
 		}
 	}
@@ -932,31 +919,30 @@
 
 
 	if (!bStatus) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "MMU_Alloc: _DeferredAllocPagetables failed"));
-		if ((uFlags & PVRSRV_MEM_USER_SUPPLIED_DEVVADDR) == 0) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "MMU_Alloc: _DeferredAllocPagetables failed");
+		if ((uFlags & PVRSRV_MEM_USER_SUPPLIED_DEVVADDR) == 0)
 
 			RA_Free(pMMUHeap->psVMArena, psDevVAddr->uiAddr,
 				IMG_FALSE);
-		}
 	}
 
 	return bStatus;
 }
 
-IMG_VOID
-MMU_Free(MMU_HEAP * pMMUHeap, IMG_DEV_VIRTADDR DevVAddr, IMG_UINT32 ui32Size)
+void MMU_Free(struct MMU_HEAP *pMMUHeap, struct IMG_DEV_VIRTADDR DevVAddr,
+	      u32 ui32Size)
 {
-	PVR_ASSERT(pMMUHeap != IMG_NULL);
+	PVR_ASSERT(pMMUHeap != NULL);
 
-	if (pMMUHeap == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR, "MMU_Free: invalid parameter"));
+	if (pMMUHeap == NULL) {
+		PVR_DPF(PVR_DBG_ERROR, "MMU_Free: invalid parameter");
 		return;
 	}
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "MMU_Free: mmu=%08X, dev_vaddr=%08X", pMMUHeap,
-		 DevVAddr.uiAddr));
+		 DevVAddr.uiAddr);
 
 	if ((DevVAddr.uiAddr >= pMMUHeap->psDevArena->BaseDevVAddr.uiAddr) &&
 	    (DevVAddr.uiAddr + ui32Size <=
@@ -966,36 +952,35 @@
 		return;
 	}
 
-	PVR_DPF((PVR_DBG_ERROR,
+	PVR_DPF(PVR_DBG_ERROR,
 		 "MMU_Free: Couldn't find DevVAddr %08X in a DevArena",
-		 DevVAddr.uiAddr));
+		 DevVAddr.uiAddr);
 }
 
-IMG_VOID MMU_Enable(MMU_HEAP * pMMUHeap)
+void MMU_Enable(struct MMU_HEAP *pMMUHeap)
 {
 	PVR_UNREFERENCED_PARAMETER(pMMUHeap);
 
 }
 
-IMG_VOID MMU_Disable(MMU_HEAP * pMMUHeap)
+void MMU_Disable(struct MMU_HEAP *pMMUHeap)
 {
 	PVR_UNREFERENCED_PARAMETER(pMMUHeap);
 
 }
 
 #if defined(PDUMP)
-static IMG_VOID
-MMU_PDumpPageTables(MMU_HEAP * pMMUHeap,
-		    IMG_DEV_VIRTADDR DevVAddr,
-		    IMG_SIZE_T uSize, IMG_BOOL bForUnmap, IMG_HANDLE hUniqueTag)
-{
-	IMG_UINT32 ui32NumPTEntries;
-	IMG_UINT32 ui32PTIndex;
-	IMG_UINT32 *pui32PTEntry;
-
-	MMU_PT_INFO **ppsPTInfoList;
-	IMG_UINT32 ui32PDIndex;
-	IMG_UINT32 ui32PTDumpCount;
+static void MMU_PDumpPageTables(struct MMU_HEAP *pMMUHeap,
+		    struct IMG_DEV_VIRTADDR DevVAddr,
+		    size_t uSize, IMG_BOOL bForUnmap, void *hUniqueTag)
+{
+	u32 ui32NumPTEntries;
+	u32 ui32PTIndex;
+	u32 *pui32PTEntry;
+
+	struct MMU_PT_INFO **ppsPTInfoList;
+	u32 ui32PDIndex;
+	u32 ui32PTDumpCount;
 
 	ui32NumPTEntries =
 	    (uSize + SGX_MMU_PAGE_SIZE - 1) >> SGX_MMU_PAGE_SHIFT;
@@ -1011,19 +996,18 @@
 		     ui32NumPTEntries, bForUnmap ? "(for unmap)" : "");
 
 	while (ui32NumPTEntries > 0) {
-		MMU_PT_INFO *psPTInfo = *ppsPTInfoList++;
+		struct MMU_PT_INFO *psPTInfo = *ppsPTInfoList++;
 
-		if (ui32NumPTEntries <= 1024 - ui32PTIndex) {
+		if (ui32NumPTEntries <= 1024 - ui32PTIndex)
 			ui32PTDumpCount = ui32NumPTEntries;
-		} else {
+		else
 			ui32PTDumpCount = 1024 - ui32PTIndex;
-		}
 
 		if (psPTInfo) {
-			pui32PTEntry = (IMG_UINT32 *) psPTInfo->PTPageCpuVAddr;
+			pui32PTEntry = (u32 *) psPTInfo->PTPageCpuVAddr;
 			PDUMPMEM2(PVRSRV_DEVICE_TYPE_SGX,
-				  (IMG_VOID *) & pui32PTEntry[ui32PTIndex],
-				  ui32PTDumpCount * sizeof(IMG_UINT32), 0,
+				  (void *) &pui32PTEntry[ui32PTIndex],
+				  ui32PTDumpCount * sizeof(u32), 0,
 				  IMG_FALSE, PDUMP_PT_UNIQUETAG, hUniqueTag);
 		}
 
@@ -1037,36 +1021,33 @@
 }
 #endif
 
-static IMG_VOID
-MMU_MapPage(MMU_HEAP * pMMUHeap,
-	    IMG_DEV_VIRTADDR DevVAddr,
-	    IMG_DEV_PHYADDR DevPAddr, IMG_UINT32 ui32MemFlags)
-{
-	IMG_UINT32 ui32Index;
-	IMG_UINT32 *pui32Tmp;
-	IMG_UINT32 ui32MMUFlags = 0;
-	MMU_PT_INFO **ppsPTInfoList;
+static void MMU_MapPage(struct MMU_HEAP *pMMUHeap,
+	    struct IMG_DEV_VIRTADDR DevVAddr,
+	    struct IMG_DEV_PHYADDR DevPAddr, u32 ui32MemFlags)
+{
+	u32 ui32Index;
+	u32 *pui32Tmp;
+	u32 ui32MMUFlags = 0;
+	struct MMU_PT_INFO **ppsPTInfoList;
 
 	if (((PVRSRV_MEM_READ | PVRSRV_MEM_WRITE) & ui32MemFlags) ==
-	    (PVRSRV_MEM_READ | PVRSRV_MEM_WRITE)) {
+	    (PVRSRV_MEM_READ | PVRSRV_MEM_WRITE))
 
 		ui32MMUFlags = 0;
-	} else if (PVRSRV_MEM_READ & ui32MemFlags) {
+	else if (PVRSRV_MEM_READ & ui32MemFlags)
 
 		ui32MMUFlags |= SGX_MMU_PTE_READONLY;
-	} else if (PVRSRV_MEM_WRITE & ui32MemFlags) {
+	else
+	if (PVRSRV_MEM_WRITE & ui32MemFlags)
 
 		ui32MMUFlags |= SGX_MMU_PTE_WRITEONLY;
-	}
 
-	if (PVRSRV_MEM_CACHE_CONSISTENT & ui32MemFlags) {
+	if (PVRSRV_MEM_CACHE_CONSISTENT & ui32MemFlags)
 		ui32MMUFlags |= SGX_MMU_PTE_CACHECONSISTENT;
-	}
 #if !defined(FIX_HW_BRN_25503)
 
-	if (PVRSRV_MEM_EDM_PROTECT & ui32MemFlags) {
+	if (PVRSRV_MEM_EDM_PROTECT & ui32MemFlags)
 		ui32MMUFlags |= SGX_MMU_PTE_EDMPROTECT;
-	}
 #endif
 
 	ui32Index = DevVAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);
@@ -1075,16 +1056,15 @@
 
 	ui32Index = (DevVAddr.uiAddr & SGX_MMU_PT_MASK) >> SGX_MMU_PAGE_SHIFT;
 
-	pui32Tmp = (IMG_UINT32 *) ppsPTInfoList[0]->PTPageCpuVAddr;
+	pui32Tmp = (u32 *) ppsPTInfoList[0]->PTPageCpuVAddr;
 
 
-	if (pui32Tmp[ui32Index] & SGX_MMU_PTE_VALID) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "MMU_MapPage: Page is already valid for alloc at VAddr:0x%08lX PDIdx:%u PTIdx:%u",
-			 DevVAddr.uiAddr,
-			 DevVAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT +
-					     SGX_MMU_PT_SHIFT), ui32Index));
-	}
+	if (pui32Tmp[ui32Index] & SGX_MMU_PTE_VALID)
+		PVR_DPF(PVR_DBG_ERROR, "MMU_MapPage: "
+	   "Page is already valid for alloc at VAddr:0x%08lX PDIdx:%u PTIdx:%u",
+			 DevVAddr.uiAddr, DevVAddr.uiAddr >>
+				(SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT),
+			 ui32Index);
 
 	PVR_ASSERT((pui32Tmp[ui32Index] & SGX_MMU_PTE_VALID) == 0);
 
@@ -1094,19 +1074,18 @@
 	    | SGX_MMU_PTE_VALID | ui32MMUFlags;
 }
 
-IMG_VOID
-MMU_MapScatter(MMU_HEAP * pMMUHeap,
-	       IMG_DEV_VIRTADDR DevVAddr,
-	       IMG_SYS_PHYADDR * psSysAddr,
-	       IMG_SIZE_T uSize, IMG_UINT32 ui32MemFlags, IMG_HANDLE hUniqueTag)
+void MMU_MapScatter(struct MMU_HEAP *pMMUHeap,
+	       struct IMG_DEV_VIRTADDR DevVAddr,
+	       struct IMG_SYS_PHYADDR *psSysAddr,
+	       size_t uSize, u32 ui32MemFlags, void *hUniqueTag)
 {
 #if defined(PDUMP)
-	IMG_DEV_VIRTADDR MapBaseDevVAddr;
+	struct IMG_DEV_VIRTADDR MapBaseDevVAddr;
 #endif
-	IMG_UINT32 uCount, i;
-	IMG_DEV_PHYADDR DevPAddr;
+	u32 uCount, i;
+	struct IMG_DEV_PHYADDR DevPAddr;
 
-	PVR_ASSERT(pMMUHeap != IMG_NULL);
+	PVR_ASSERT(pMMUHeap != NULL);
 
 #if defined(PDUMP)
 	MapBaseDevVAddr = DevVAddr;
@@ -1116,7 +1095,7 @@
 
 	for (i = 0, uCount = 0; uCount < uSize;
 	     i++, uCount += SGX_MMU_PAGE_SIZE) {
-		IMG_SYS_PHYADDR sSysAddr;
+		struct IMG_SYS_PHYADDR sSysAddr;
 
 		sSysAddr = psSysAddr[i];
 
@@ -1126,9 +1105,9 @@
 		MMU_MapPage(pMMUHeap, DevVAddr, DevPAddr, ui32MemFlags);
 		DevVAddr.uiAddr += SGX_MMU_PAGE_SIZE;
 
-		PVR_DPF((PVR_DBG_MESSAGE,
-			 "MMU_MapScatter: devVAddr=%08X, SysAddr=%08X, size=0x%x/0x%x",
-			 DevVAddr.uiAddr, sSysAddr.uiAddr, uCount, uSize));
+		PVR_DPF(PVR_DBG_MESSAGE, "MMU_MapScatter: "
+			 "devVAddr=%08X, SysAddr=%08X, size=0x%x/0x%x",
+			 DevVAddr.uiAddr, sSysAddr.uiAddr, uCount, uSize);
 	}
 
 #if defined(PDUMP)
@@ -1137,25 +1116,24 @@
 #endif
 }
 
-IMG_VOID
-MMU_MapPages(MMU_HEAP * pMMUHeap,
-	     IMG_DEV_VIRTADDR DevVAddr,
-	     IMG_SYS_PHYADDR SysPAddr,
-	     IMG_SIZE_T uSize, IMG_UINT32 ui32MemFlags, IMG_HANDLE hUniqueTag)
+void MMU_MapPages(struct MMU_HEAP *pMMUHeap,
+	     struct IMG_DEV_VIRTADDR DevVAddr,
+	     struct IMG_SYS_PHYADDR SysPAddr,
+	     size_t uSize, u32 ui32MemFlags, void *hUniqueTag)
 {
-	IMG_DEV_PHYADDR DevPAddr;
+	struct IMG_DEV_PHYADDR DevPAddr;
 #if defined(PDUMP)
-	IMG_DEV_VIRTADDR MapBaseDevVAddr;
+	struct IMG_DEV_VIRTADDR MapBaseDevVAddr;
 #endif
-	IMG_UINT32 uCount;
-	IMG_UINT32 ui32VAdvance = SGX_MMU_PAGE_SIZE;
-	IMG_UINT32 ui32PAdvance = SGX_MMU_PAGE_SIZE;
-
-	PVR_ASSERT(pMMUHeap != IMG_NULL);
-
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "MMU_MapPages: mmu=%08X, devVAddr=%08X, SysPAddr=%08X, size=0x%x",
-		 pMMUHeap, DevVAddr.uiAddr, SysPAddr.uiAddr, uSize));
+	u32 uCount;
+	u32 ui32VAdvance = SGX_MMU_PAGE_SIZE;
+	u32 ui32PAdvance = SGX_MMU_PAGE_SIZE;
+
+	PVR_ASSERT(pMMUHeap != NULL);
+
+	PVR_DPF(PVR_DBG_MESSAGE, "MMU_MapPages: "
+		 "mmu=%08X, devVAddr=%08X, SysPAddr=%08X, size=0x%x",
+		 pMMUHeap, DevVAddr.uiAddr, SysPAddr.uiAddr, uSize);
 
 #if defined(PDUMP)
 	MapBaseDevVAddr = DevVAddr;
@@ -1166,14 +1144,12 @@
 	DevPAddr = SysSysPAddrToDevPAddr(PVRSRV_DEVICE_TYPE_SGX, SysPAddr);
 
 #if defined(FIX_HW_BRN_23281)
-	if (ui32MemFlags & PVRSRV_MEM_INTERLEAVED) {
+	if (ui32MemFlags & PVRSRV_MEM_INTERLEAVED)
 		ui32VAdvance *= 2;
-	}
 #endif
 
-	if (ui32MemFlags & PVRSRV_MEM_DUMMY) {
+	if (ui32MemFlags & PVRSRV_MEM_DUMMY)
 		ui32PAdvance = 0;
-	}
 
 	for (uCount = 0; uCount < uSize; uCount += ui32VAdvance) {
 		MMU_MapPage(pMMUHeap, DevVAddr, DevPAddr, ui32MemFlags);
@@ -1187,51 +1163,46 @@
 #endif
 }
 
-IMG_VOID
-MMU_MapShadow(MMU_HEAP * pMMUHeap,
-	      IMG_DEV_VIRTADDR MapBaseDevVAddr,
-	      IMG_SIZE_T uByteSize,
-	      IMG_CPU_VIRTADDR CpuVAddr,
-	      IMG_HANDLE hOSMemHandle,
-	      IMG_DEV_VIRTADDR * pDevVAddr,
-	      IMG_UINT32 ui32MemFlags, IMG_HANDLE hUniqueTag)
-{
-	IMG_UINT32 i;
-	IMG_UINT32 uOffset = 0;
-	IMG_DEV_VIRTADDR MapDevVAddr;
-	IMG_UINT32 ui32VAdvance = SGX_MMU_PAGE_SIZE;
-	IMG_UINT32 ui32PAdvance = SGX_MMU_PAGE_SIZE;
+void MMU_MapShadow(struct MMU_HEAP *pMMUHeap,
+	      struct IMG_DEV_VIRTADDR MapBaseDevVAddr,
+	      size_t uByteSize, void *CpuVAddr, void *hOSMemHandle,
+	      struct IMG_DEV_VIRTADDR *pDevVAddr, u32 ui32MemFlags,
+	      void *hUniqueTag)
+{
+	u32 i;
+	u32 uOffset = 0;
+	struct IMG_DEV_VIRTADDR MapDevVAddr;
+	u32 ui32VAdvance = SGX_MMU_PAGE_SIZE;
+	u32 ui32PAdvance = SGX_MMU_PAGE_SIZE;
 
-#if !defined (PDUMP)
+#if !defined(PDUMP)
 	PVR_UNREFERENCED_PARAMETER(hUniqueTag);
 #endif
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "MMU_MapShadow: %08X, 0x%x, %08X",
-		 MapBaseDevVAddr.uiAddr, uByteSize, CpuVAddr));
+		 MapBaseDevVAddr.uiAddr, uByteSize, CpuVAddr);
 
-	PVR_ASSERT(((IMG_UINT32) CpuVAddr & (SGX_MMU_PAGE_SIZE - 1)) == 0);
-	PVR_ASSERT(((IMG_UINT32) uByteSize & (SGX_MMU_PAGE_SIZE - 1)) == 0);
+	PVR_ASSERT(((u32) CpuVAddr & (SGX_MMU_PAGE_SIZE - 1)) == 0);
+	PVR_ASSERT(((u32) uByteSize & (SGX_MMU_PAGE_SIZE - 1)) == 0);
 	pDevVAddr->uiAddr = MapBaseDevVAddr.uiAddr;
 
 #if defined(FIX_HW_BRN_23281)
-	if (ui32MemFlags & PVRSRV_MEM_INTERLEAVED) {
+	if (ui32MemFlags & PVRSRV_MEM_INTERLEAVED)
 		ui32VAdvance *= 2;
-	}
 #endif
 
-	if (ui32MemFlags & PVRSRV_MEM_DUMMY) {
+	if (ui32MemFlags & PVRSRV_MEM_DUMMY)
 		ui32PAdvance = 0;
-	}
 
 	MapDevVAddr = MapBaseDevVAddr;
 	for (i = 0; i < uByteSize; i += ui32VAdvance) {
-		IMG_CPU_PHYADDR CpuPAddr;
-		IMG_DEV_PHYADDR DevPAddr;
+		struct IMG_CPU_PHYADDR CpuPAddr;
+		struct IMG_DEV_PHYADDR DevPAddr;
 
 		if (CpuVAddr) {
 			CpuPAddr =
-			    OSMapLinToCPUPhys((IMG_VOID *) ((IMG_UINT32)
+			    OSMapLinToCPUPhys((void *) ((u32)
 							    CpuVAddr +
 							    uOffset));
 		} else {
@@ -1240,11 +1211,10 @@
 		DevPAddr =
 		    SysCpuPAddrToDevPAddr(PVRSRV_DEVICE_TYPE_SGX, CpuPAddr);
 
-		PVR_DPF((PVR_DBG_MESSAGE,
-			 "0x%x: CpuVAddr=%08X, CpuPAddr=%08X, DevVAddr=%08X, DevPAddr=%08X",
-			 uOffset,
-			 (IMG_UINTPTR_T) CpuVAddr + uOffset,
-			 CpuPAddr.uiAddr, MapDevVAddr.uiAddr, DevPAddr.uiAddr));
+		PVR_DPF(PVR_DBG_MESSAGE, "0x%x: "
+		   "CpuVAddr=%08X, CpuPAddr=%08X, DevVAddr=%08X, DevPAddr=%08X",
+			 uOffset, (u32) CpuVAddr + uOffset,
+			 CpuPAddr.uiAddr, MapDevVAddr.uiAddr, DevPAddr.uiAddr);
 
 		MMU_MapPage(pMMUHeap, MapDevVAddr, DevPAddr, ui32MemFlags);
 
@@ -1258,62 +1228,62 @@
 #endif
 }
 
-IMG_VOID
-MMU_UnmapPages(MMU_HEAP * psMMUHeap,
-	       IMG_DEV_VIRTADDR sDevVAddr,
-	       IMG_UINT32 ui32PageCount, IMG_HANDLE hUniqueTag)
-{
-	IMG_UINT32 uPageSize = HOST_PAGESIZE();
-	IMG_DEV_VIRTADDR sTmpDevVAddr;
-	IMG_UINT32 i;
-	IMG_UINT32 ui32PDIndex;
-	IMG_UINT32 ui32PTIndex;
-	IMG_UINT32 *pui32Tmp;
+void MMU_UnmapPages(struct MMU_HEAP *psMMUHeap,
+	       struct IMG_DEV_VIRTADDR sDevVAddr, u32 ui32PageCount,
+	       void *hUniqueTag)
+{
+	u32 uPageSize = HOST_PAGESIZE();
+	struct IMG_DEV_VIRTADDR sTmpDevVAddr;
+	u32 i;
+	u32 ui32PDIndex;
+	u32 ui32PTIndex;
+	u32 *pui32Tmp;
 
-#if !defined (PDUMP)
+#if !defined(PDUMP)
 	PVR_UNREFERENCED_PARAMETER(hUniqueTag);
 #endif
 
 	sTmpDevVAddr = sDevVAddr;
 
 	for (i = 0; i < ui32PageCount; i++) {
-		MMU_PT_INFO **ppsPTInfoList;
+		struct MMU_PT_INFO **ppsPTInfoList;
 
-		ui32PDIndex =
-		    sTmpDevVAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT +
-					    SGX_MMU_PT_SHIFT);
+		ui32PDIndex = sTmpDevVAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT +
+						      SGX_MMU_PT_SHIFT);
 
-		ppsPTInfoList =
-		    &psMMUHeap->psMMUContext->apsPTInfoList[ui32PDIndex];
+		ppsPTInfoList = &psMMUHeap->psMMUContext->
+						apsPTInfoList[ui32PDIndex];
 
-		ui32PTIndex =
-		    (sTmpDevVAddr.
-		     uiAddr & SGX_MMU_PT_MASK) >> SGX_MMU_PAGE_SHIFT;
+		ui32PTIndex = (sTmpDevVAddr.uiAddr & SGX_MMU_PT_MASK) >>
+							SGX_MMU_PAGE_SHIFT;
 
 		if (!ppsPTInfoList[0]) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "MMU_UnmapPages: ERROR Invalid PT for alloc at VAddr:0x%08lX (VaddrIni:0x%08lX AllocPage:%u) PDIdx:%u PTIdx:%u",
+			PVR_DPF(PVR_DBG_ERROR, "MMU_UnmapPages: "
+				"ERROR Invalid PT for alloc at "
+				"VAddr:0x%08lX (VaddrIni:0x%08lX "
+				"AllocPage:%u) PDIdx:%u PTIdx:%u",
 				 sTmpDevVAddr.uiAddr, sDevVAddr.uiAddr, i,
-				 ui32PDIndex, ui32PTIndex));
+				 ui32PDIndex, ui32PTIndex);
 
 			sTmpDevVAddr.uiAddr += uPageSize;
 
 			continue;
 		}
 
-		pui32Tmp = (IMG_UINT32 *) ppsPTInfoList[0]->PTPageCpuVAddr;
+		pui32Tmp = (u32 *) ppsPTInfoList[0]->PTPageCpuVAddr;
 
-		if (pui32Tmp[ui32PTIndex] & SGX_MMU_PTE_VALID) {
+		if (pui32Tmp[ui32PTIndex] & SGX_MMU_PTE_VALID)
 			ppsPTInfoList[0]->ui32ValidPTECount--;
-		} else {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "MMU_UnmapPages: Page is already invalid for alloc at VAddr:0x%08lX (VAddrIni:0x%08lX AllocPage:%u) PDIdx:%u PTIdx:%u",
+		else
+			PVR_DPF(PVR_DBG_ERROR, "MMU_UnmapPages: "
+				"Page is already invalid for "
+				"alloc at VAddr:0x%08lX "
+				"(VAddrIni:0x%08lX AllocPage:%u) "
+				"PDIdx:%u PTIdx:%u",
 				 sTmpDevVAddr.uiAddr, sDevVAddr.uiAddr, i,
-				 ui32PDIndex, ui32PTIndex));
-		}
+				 ui32PDIndex, ui32PTIndex);
 
-		PVR_ASSERT((IMG_INT32) ppsPTInfoList[0]->ui32ValidPTECount >=
-			   0);
+		PVR_ASSERT((s32) ppsPTInfoList[0]->ui32ValidPTECount >= 0);
 
 
 		pui32Tmp[ui32PTIndex] = 0;
@@ -1329,22 +1299,22 @@
 #endif
 }
 
-IMG_DEV_PHYADDR
-MMU_GetPhysPageAddr(MMU_HEAP * pMMUHeap, IMG_DEV_VIRTADDR sDevVPageAddr)
+struct IMG_DEV_PHYADDR MMU_GetPhysPageAddr(struct MMU_HEAP *pMMUHeap,
+					struct IMG_DEV_VIRTADDR sDevVPageAddr)
 {
-	IMG_UINT32 *pui32PageTable;
-	IMG_UINT32 ui32Index;
-	IMG_DEV_PHYADDR sDevPAddr;
-	MMU_PT_INFO **ppsPTInfoList;
+	u32 *pui32PageTable;
+	u32 ui32Index;
+	struct IMG_DEV_PHYADDR sDevPAddr;
+	struct MMU_PT_INFO **ppsPTInfoList;
 
-	ui32Index =
-	    sDevVPageAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);
+	ui32Index = sDevVPageAddr.uiAddr >> (SGX_MMU_PAGE_SHIFT +
+					     SGX_MMU_PT_SHIFT);
 
 	ppsPTInfoList = &pMMUHeap->psMMUContext->apsPTInfoList[ui32Index];
 	if (!ppsPTInfoList[0]) {
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "MMU_GetPhysPageAddr: Not mapped in at 0x%08x",
-			 sDevVPageAddr.uiAddr));
+			 sDevVPageAddr.uiAddr);
 		sDevPAddr.uiAddr = 0;
 		return sDevPAddr;
 	}
@@ -1352,7 +1322,7 @@
 	ui32Index =
 	    (sDevVPageAddr.uiAddr & SGX_MMU_PT_MASK) >> SGX_MMU_PAGE_SHIFT;
 
-	pui32PageTable = (IMG_UINT32 *) ppsPTInfoList[0]->PTPageCpuVAddr;
+	pui32PageTable = (u32 *) ppsPTInfoList[0]->PTPageCpuVAddr;
 
 	sDevPAddr.uiAddr = pui32PageTable[ui32Index];
 
@@ -1361,107 +1331,100 @@
 	return sDevPAddr;
 }
 
-IMG_DEV_PHYADDR MMU_GetPDDevPAddr(MMU_CONTEXT * pMMUContext)
+struct IMG_DEV_PHYADDR MMU_GetPDDevPAddr(struct MMU_CONTEXT *pMMUContext)
 {
-	return (pMMUContext->sPDDevPAddr);
+	return pMMUContext->sPDDevPAddr;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR SGXGetPhysPageAddrKM(IMG_HANDLE hDevMemHeap,
-				      IMG_DEV_VIRTADDR sDevVAddr,
-				      IMG_DEV_PHYADDR * pDevPAddr,
-				      IMG_CPU_PHYADDR * pCpuPAddr)
+enum PVRSRV_ERROR SGXGetPhysPageAddrKM(void *hDevMemHeap,
+				      struct IMG_DEV_VIRTADDR sDevVAddr,
+				      struct IMG_DEV_PHYADDR *pDevPAddr,
+				      struct IMG_CPU_PHYADDR *pCpuPAddr)
 {
-	MMU_HEAP *pMMUHeap;
-	IMG_DEV_PHYADDR DevPAddr;
+	struct MMU_HEAP *pMMUHeap;
+	struct IMG_DEV_PHYADDR DevPAddr;
 
-	pMMUHeap = (MMU_HEAP *) BM_GetMMUHeap(hDevMemHeap);
+	pMMUHeap = (struct MMU_HEAP *)BM_GetMMUHeap(hDevMemHeap);
 
 	DevPAddr = MMU_GetPhysPageAddr(pMMUHeap, sDevVAddr);
 	pCpuPAddr->uiAddr = DevPAddr.uiAddr;
 	pDevPAddr->uiAddr = DevPAddr.uiAddr;
 
-	return (pDevPAddr->uiAddr !=
-		0) ? PVRSRV_OK : PVRSRV_ERROR_INVALID_PARAMS;
+	return (pDevPAddr->uiAddr != 0) ?
+		PVRSRV_OK : PVRSRV_ERROR_INVALID_PARAMS;
 }
 
-PVRSRV_ERROR SGXGetMMUPDAddrKM(IMG_HANDLE hDevCookie,
-			       IMG_HANDLE hDevMemContext,
-			       IMG_DEV_PHYADDR * psPDDevPAddr)
+enum PVRSRV_ERROR SGXGetMMUPDAddrKM(void *hDevCookie,
+			       void *hDevMemContext,
+			       struct IMG_DEV_PHYADDR *psPDDevPAddr)
 {
-	if (!hDevCookie || !hDevMemContext || !psPDDevPAddr) {
+	if (!hDevCookie || !hDevMemContext || !psPDDevPAddr)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
 	PVR_UNREFERENCED_PARAMETER(hDevCookie);
 
 	*psPDDevPAddr =
-	    ((BM_CONTEXT *) hDevMemContext)->psMMUContext->sPDDevPAddr;
+	    ((struct BM_CONTEXT *)hDevMemContext)->psMMUContext->sPDDevPAddr;
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR MMU_BIFResetPDAlloc(PVRSRV_SGXDEV_INFO * psDevInfo)
+enum PVRSRV_ERROR MMU_BIFResetPDAlloc(struct PVRSRV_SGXDEV_INFO *psDevInfo)
 {
-	PVRSRV_ERROR eError;
-	SYS_DATA *psSysData;
-	RA_ARENA *psLocalDevMemArena;
-	IMG_HANDLE hOSMemHandle = IMG_NULL;
-	IMG_BYTE *pui8MemBlock = IMG_NULL;
-	IMG_SYS_PHYADDR sMemBlockSysPAddr;
-	IMG_CPU_PHYADDR sMemBlockCpuPAddr;
+	enum PVRSRV_ERROR eError;
+	struct SYS_DATA *psSysData;
+	struct RA_ARENA *psLocalDevMemArena;
+	void *hOSMemHandle = NULL;
+	u8 *pui8MemBlock = NULL;
+	struct IMG_SYS_PHYADDR sMemBlockSysPAddr;
+	struct IMG_CPU_PHYADDR sMemBlockCpuPAddr;
 
 	eError = SysAcquireData(&psSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "MMU_BIFResetPDAlloc: ERROR call to SysAcquireData failed"));
+		PVR_DPF(PVR_DBG_ERROR,
+		   "MMU_BIFResetPDAlloc: ERROR call to SysAcquireData failed");
 		return eError;
 	}
 
 	psLocalDevMemArena = psSysData->apsLocalDevMemArena[0];
 
-	if (psLocalDevMemArena == IMG_NULL) {
+	if (psLocalDevMemArena == NULL) {
 
 		eError =
 		    OSAllocPages(PVRSRV_HAP_WRITECOMBINE |
 				 PVRSRV_HAP_KERNEL_ONLY, 3 * SGX_MMU_PAGE_SIZE,
-				 (IMG_VOID **) & pui8MemBlock, &hOSMemHandle);
+				 (void **) &pui8MemBlock, &hOSMemHandle);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "MMU_BIFResetPDAlloc: ERROR call to OSAllocPages failed"));
+			PVR_DPF(PVR_DBG_ERROR, "MMU_BIFResetPDAlloc: "
+					"ERROR call to OSAllocPages failed");
 			return eError;
 		}
 
-		if (pui8MemBlock) {
+		if (pui8MemBlock)
 			sMemBlockCpuPAddr = OSMapLinToCPUPhys(pui8MemBlock);
-		} else {
+		else
 
 			sMemBlockCpuPAddr =
 			    OSMemHandleToCpuPAddr(hOSMemHandle, 0);
-		}
 	} else {
 
-		if (RA_Alloc(psLocalDevMemArena,
-			     3 * SGX_MMU_PAGE_SIZE,
-			     IMG_NULL,
-			     IMG_NULL,
-			     0,
-			     SGX_MMU_PAGE_SIZE,
-			     0, &(sMemBlockSysPAddr.uiAddr)) != IMG_TRUE) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "MMU_BIFResetPDAlloc: ERROR call to RA_Alloc failed"));
+		if (RA_Alloc(psLocalDevMemArena, 3 * SGX_MMU_PAGE_SIZE, NULL,
+			     NULL, 0, SGX_MMU_PAGE_SIZE, 0,
+			     &(sMemBlockSysPAddr.uiAddr)) != IMG_TRUE) {
+			PVR_DPF(PVR_DBG_ERROR, "MMU_BIFResetPDAlloc: "
+				"ERROR call to RA_Alloc failed");
 			return PVRSRV_ERROR_OUT_OF_MEMORY;
 		}
 
 		sMemBlockCpuPAddr = SysSysPAddrToCpuPAddr(sMemBlockSysPAddr);
-		pui8MemBlock = OSMapPhysToLin(sMemBlockCpuPAddr,
+		pui8MemBlock = (void __force *)OSMapPhysToLin(sMemBlockCpuPAddr,
 					      SGX_MMU_PAGE_SIZE * 3,
 					      PVRSRV_HAP_WRITECOMBINE |
 					      PVRSRV_HAP_KERNEL_ONLY,
 					      &hOSMemHandle);
 		if (!pui8MemBlock) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "MMU_BIFResetPDAlloc: ERROR failed to map page tables"));
+			PVR_DPF(PVR_DBG_ERROR, "MMU_BIFResetPDAlloc: "
+				"ERROR failed to map page tables");
 			return PVRSRV_ERROR_BAD_MAPPING;
 		}
 	}
@@ -1473,9 +1436,9 @@
 	    psDevInfo->sBIFResetPDDevPAddr.uiAddr + SGX_MMU_PAGE_SIZE;
 	psDevInfo->sBIFResetPageDevPAddr.uiAddr =
 	    psDevInfo->sBIFResetPTDevPAddr.uiAddr + SGX_MMU_PAGE_SIZE;
-	psDevInfo->pui32BIFResetPD = (IMG_UINT32 *) pui8MemBlock;
+	psDevInfo->pui32BIFResetPD = (u32 *) pui8MemBlock;
 	psDevInfo->pui32BIFResetPT =
-	    (IMG_UINT32 *) (pui8MemBlock + SGX_MMU_PAGE_SIZE);
+	    (u32 *) (pui8MemBlock + SGX_MMU_PAGE_SIZE);
 
 	OSMemSet(psDevInfo->pui32BIFResetPD, 0, SGX_MMU_PAGE_SIZE);
 	OSMemSet(psDevInfo->pui32BIFResetPT, 0, SGX_MMU_PAGE_SIZE);
@@ -1486,32 +1449,33 @@
 	return PVRSRV_OK;
 }
 
-IMG_VOID MMU_BIFResetPDFree(PVRSRV_SGXDEV_INFO * psDevInfo)
+void MMU_BIFResetPDFree(struct PVRSRV_SGXDEV_INFO *psDevInfo)
 {
-	PVRSRV_ERROR eError;
-	SYS_DATA *psSysData;
-	RA_ARENA *psLocalDevMemArena;
-	IMG_SYS_PHYADDR sPDSysPAddr;
+	enum PVRSRV_ERROR eError;
+	struct SYS_DATA *psSysData;
+	struct RA_ARENA *psLocalDevMemArena;
+	struct IMG_SYS_PHYADDR sPDSysPAddr;
 
 	eError = SysAcquireData(&psSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "MMU_BIFResetPDFree: ERROR call to SysAcquireData failed"));
+		PVR_DPF(PVR_DBG_ERROR, "MMU_BIFResetPDFree: "
+				"ERROR call to SysAcquireData failed");
 		return;
 	}
 
 	psLocalDevMemArena = psSysData->apsLocalDevMemArena[0];
 
-	if (psLocalDevMemArena == IMG_NULL) {
+	if (psLocalDevMemArena == NULL) {
 		OSFreePages(PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_KERNEL_ONLY,
 			    3 * SGX_MMU_PAGE_SIZE,
 			    psDevInfo->pui32BIFResetPD,
 			    psDevInfo->hBIFResetPDOSMemHandle);
 	} else {
-		OSUnMapPhysToLin(psDevInfo->pui32BIFResetPD,
+		OSUnMapPhysToLin((void __force __iomem *)
+					psDevInfo->pui32BIFResetPD,
 				 3 * SGX_MMU_PAGE_SIZE,
 				 PVRSRV_HAP_WRITECOMBINE |
-				 PVRSRV_HAP_KERNEL_ONLY,
+					PVRSRV_HAP_KERNEL_ONLY,
 				 psDevInfo->hBIFResetPDOSMemHandle);
 
 		sPDSysPAddr =
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/mmu.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/mmu.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -29,70 +29,58 @@
 
 #include "sgxinfokm.h"
 
-PVRSRV_ERROR
-MMU_Initialise(PVRSRV_DEVICE_NODE * psDeviceNode, MMU_CONTEXT ** ppsMMUContext,
-	       IMG_DEV_PHYADDR * psPDDevPAddr);
-
-IMG_VOID MMU_Finalise(MMU_CONTEXT * psMMUContext);
+enum PVRSRV_ERROR MMU_Initialise(struct PVRSRV_DEVICE_NODE *psDeviceNode,
+		struct MMU_CONTEXT **ppsMMUContext,
+		struct IMG_DEV_PHYADDR *psPDDevPAddr);
 
-IMG_VOID MMU_InsertHeap(MMU_CONTEXT * psMMUContext, MMU_HEAP * psMMUHeap);
+void MMU_Finalise(struct MMU_CONTEXT *psMMUContext);
 
-MMU_HEAP *MMU_Create(MMU_CONTEXT * psMMUContext,
-		     DEV_ARENA_DESCRIPTOR * psDevArena, RA_ARENA ** ppsVMArena);
+void MMU_InsertHeap(struct MMU_CONTEXT *psMMUContext,
+		struct MMU_HEAP *psMMUHeap);
 
-IMG_VOID MMU_Delete(MMU_HEAP * pMMU);
+struct MMU_HEAP *MMU_Create(struct MMU_CONTEXT *psMMUContext,
+		struct DEV_ARENA_DESCRIPTOR *psDevArena,
+		struct RA_ARENA **ppsVMArena);
 
-IMG_BOOL
-MMU_Alloc(MMU_HEAP * pMMU,
-	  IMG_SIZE_T uSize,
-	  IMG_SIZE_T * pActualSize,
-	  IMG_UINT32 uFlags,
-	  IMG_UINT32 uDevVAddrAlignment, IMG_DEV_VIRTADDR * pDevVAddr);
+void MMU_Delete(struct MMU_HEAP *pMMU);
 
-IMG_VOID
-MMU_Free(MMU_HEAP * pMMU, IMG_DEV_VIRTADDR DevVAddr, IMG_UINT32 ui32Size);
+IMG_BOOL MMU_Alloc(struct MMU_HEAP *pMMU, size_t uSize, size_t *pActualSize,
+		u32 uFlags, u32 uDevVAddrAlignment,
+		struct IMG_DEV_VIRTADDR *pDevVAddr);
 
-IMG_VOID MMU_Enable(MMU_HEAP * pMMU);
+void MMU_Free(struct MMU_HEAP *pMMU, struct IMG_DEV_VIRTADDR DevVAddr,
+	      u32 ui32Size);
 
-IMG_VOID MMU_Disable(MMU_HEAP * pMMU);
+void MMU_Enable(struct MMU_HEAP *pMMU);
 
-IMG_VOID
-MMU_MapPages(MMU_HEAP * pMMU,
-	     IMG_DEV_VIRTADDR devVAddr,
-	     IMG_SYS_PHYADDR SysPAddr,
-	     IMG_SIZE_T uSize, IMG_UINT32 ui32MemFlags, IMG_HANDLE hUniqueTag);
+void MMU_Disable(struct MMU_HEAP *pMMU);
 
-IMG_VOID
-MMU_MapShadow(MMU_HEAP * pMMU,
-	      IMG_DEV_VIRTADDR MapBaseDevVAddr,
-	      IMG_SIZE_T uSize,
-	      IMG_CPU_VIRTADDR CpuVAddr,
-	      IMG_HANDLE hOSMemHandle,
-	      IMG_DEV_VIRTADDR * pDevVAddr,
-	      IMG_UINT32 ui32MemFlags, IMG_HANDLE hUniqueTag);
+void MMU_MapPages(struct MMU_HEAP *pMMU, struct IMG_DEV_VIRTADDR devVAddr,
+		struct IMG_SYS_PHYADDR SysPAddr, size_t uSize, u32 ui32MemFlags,
+		void *hUniqueTag);
 
-IMG_VOID
-MMU_UnmapPages(MMU_HEAP * pMMU,
-	       IMG_DEV_VIRTADDR dev_vaddr,
-	       IMG_UINT32 ui32PageCount, IMG_HANDLE hUniqueTag);
+void MMU_MapShadow(struct MMU_HEAP *pMMU,
+		struct IMG_DEV_VIRTADDR MapBaseDevVAddr, size_t uSize,
+		void *CpuVAddr, void *hOSMemHandle,
+		struct IMG_DEV_VIRTADDR *pDevVAddr, u32 ui32MemFlags,
+		void *hUniqueTag);
 
-IMG_VOID
-MMU_MapScatter(MMU_HEAP * pMMU,
-	       IMG_DEV_VIRTADDR DevVAddr,
-	       IMG_SYS_PHYADDR * psSysAddr,
-	       IMG_SIZE_T uSize,
-	       IMG_UINT32 ui32MemFlags, IMG_HANDLE hUniqueTag);
+void MMU_UnmapPages(struct MMU_HEAP *pMMU, struct IMG_DEV_VIRTADDR dev_vaddr,
+		u32 ui32PageCount, void *hUniqueTag);
 
-IMG_DEV_PHYADDR
-MMU_GetPhysPageAddr(MMU_HEAP * pMMUHeap, IMG_DEV_VIRTADDR sDevVPageAddr);
+void MMU_MapScatter(struct MMU_HEAP *pMMU, struct IMG_DEV_VIRTADDR DevVAddr,
+		struct IMG_SYS_PHYADDR *psSysAddr, size_t uSize,
+		u32 ui32MemFlags, void *hUniqueTag);
 
-IMG_DEV_PHYADDR MMU_GetPDDevPAddr(MMU_CONTEXT * pMMUContext);
+struct IMG_DEV_PHYADDR MMU_GetPhysPageAddr(struct MMU_HEAP *pMMUHeap,
+					struct IMG_DEV_VIRTADDR sDevVPageAddr);
 
+struct IMG_DEV_PHYADDR MMU_GetPDDevPAddr(struct MMU_CONTEXT *pMMUContext);
 
-IMG_VOID MMU_InvalidateDirectoryCache(PVRSRV_SGXDEV_INFO * psDevInfo);
+void MMU_InvalidateDirectoryCache(struct PVRSRV_SGXDEV_INFO *psDevInfo);
 
-PVRSRV_ERROR MMU_BIFResetPDAlloc(PVRSRV_SGXDEV_INFO * psDevInfo);
+enum PVRSRV_ERROR MMU_BIFResetPDAlloc(struct PVRSRV_SGXDEV_INFO *psDevInfo);
 
-IMG_VOID MMU_BIFResetPDFree(PVRSRV_SGXDEV_INFO * psDevInfo);
+void MMU_BIFResetPDFree(struct PVRSRV_SGXDEV_INFO *psDevInfo);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/module.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/module.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -37,7 +37,6 @@
 
 #include <linux/platform_device.h>
 
-
 #include "img_defs.h"
 #include "services.h"
 #include "kerneldisplay.h"
@@ -54,6 +53,11 @@
 #include "pvr_bridge_km.h"
 #include "proc.h"
 #include "pvrmodule.h"
+#include "omaplfb.h"
+
+/* omaplfb.h defines these, but we use our own */
+#undef DRVNAME
+#undef DEVNAME
 
 #define DRVNAME		"pvrsrvkm"
 #define DEVNAME		"pvrsrvkm"
@@ -65,55 +69,43 @@
 module_param(debug, int, 0);
 #endif
 
-void PVRDebugSetLevel(IMG_UINT32 uDebugLevel);
-
-extern IMG_BOOL PVRGetDisplayClassJTable(PVRSRV_DC_DISP2SRV_KMJTABLE *
-					 psJTable);
-extern IMG_BOOL PVRGetBufferClassJTable(PVRSRV_BC_BUFFER2SRV_KMJTABLE *
-					psJTable);
-EXPORT_SYMBOL(PVRGetDisplayClassJTable);
-EXPORT_SYMBOL(PVRGetBufferClassJTable);
-
 static int AssignedMajorNumber;
 
-extern long PVRSRV_BridgeDispatchKM(struct file *file, unsigned int cmd,
-				    unsigned long arg);
 static int PVRSRVOpen(struct inode *pInode, struct file *pFile);
 static int PVRSRVRelease(struct inode *pInode, struct file *pFile);
 
-PVRSRV_LINUX_MUTEX gPVRSRVLock;
+struct mutex gPVRSRVLock;
 
-static struct file_operations pvrsrv_fops = {
-owner:	THIS_MODULE,
-unlocked_ioctl:PVRSRV_BridgeDispatchKM,
-open:	PVRSRVOpen,
-release:PVRSRVRelease,
-mmap:	PVRMMap,
+const static struct file_operations pvrsrv_fops = {
+	.owner		= THIS_MODULE,
+	.unlocked_ioctl	= PVRSRV_BridgeDispatchKM,
+	.open		= PVRSRVOpen,
+	.release	= PVRSRVRelease,
+	.mmap		= PVRMMap,
 };
 
 #define	LDM_DEV	struct platform_device
 #define	LDM_DRV	struct platform_driver
 
-
-static int PVRSRVDriverRemove(LDM_DEV * device);
-static int PVRSRVDriverProbe(LDM_DEV * device);
-static int PVRSRVDriverSuspend(LDM_DEV * device, pm_message_t state);
-static void PVRSRVDriverShutdown(LDM_DEV * device);
-static int PVRSRVDriverResume(LDM_DEV * device);
+static int PVRSRVDriverRemove(LDM_DEV *device);
+static int PVRSRVDriverProbe(LDM_DEV *device);
+static int PVRSRVDriverSuspend(LDM_DEV *device, pm_message_t state);
+static void PVRSRVDriverShutdown(LDM_DEV *device);
+static int PVRSRVDriverResume(LDM_DEV *device);
 
 
 static LDM_DRV powervr_driver = {
 	.driver = {
 		   .name = DRVNAME,
 		   },
-	.probe = PVRSRVDriverProbe,
-	.remove = PVRSRVDriverRemove,
-	.suspend = PVRSRVDriverSuspend,
-	.resume = PVRSRVDriverResume,
-	.shutdown = PVRSRVDriverShutdown,
+	.probe		= PVRSRVDriverProbe,
+	.remove		= PVRSRVDriverRemove,
+	.suspend	= PVRSRVDriverSuspend,
+	.resume		= PVRSRVDriverResume,
+	.shutdown	= PVRSRVDriverShutdown,
 };
 
-LDM_DEV *gpsPVRLDMDev;
+static LDM_DEV *gpsPVRLDMDev;
 
 static void PVRSRVDeviceRelease(struct device *device);
 
@@ -124,11 +116,11 @@
 		.release = PVRSRVDeviceRelease}
 };
 
-static int PVRSRVDriverProbe(LDM_DEV * pDevice)
+static int PVRSRVDriverProbe(LDM_DEV *pDevice)
 {
-	SYS_DATA *psSysData;
+	struct SYS_DATA *psSysData;
 
-	PVR_TRACE(("PVRSRVDriverProbe(pDevice=%p)", pDevice));
+	PVR_TRACE("PVRSRVDriverProbe(pDevice=%p)", pDevice);
 
 	pDevice->dev.driver_data = NULL;
 
@@ -136,59 +128,56 @@
 	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
 		gpsPVRLDMDev = pDevice;
 
-		if (SysInitialise() != PVRSRV_OK) {
+		if (SysInitialise() != PVRSRV_OK)
 			return -ENODEV;
-		}
 	}
 
 	return 0;
 }
 
-static int PVRSRVDriverRemove(LDM_DEV * pDevice)
+static int PVRSRVDriverRemove(LDM_DEV *pDevice)
 {
-	SYS_DATA *psSysData;
+	struct SYS_DATA *psSysData;
 
-	PVR_TRACE(("PVRSRVDriverRemove(pDevice=%p)", pDevice));
+	PVR_TRACE("PVRSRVDriverRemove(pDevice=%p)", pDevice);
 
 	if (SysAcquireData(&psSysData) == PVRSRV_OK) {
 		SysDeinitialise(psSysData);
 
-		gpsPVRLDMDev = IMG_NULL;
+		gpsPVRLDMDev = NULL;
 	}
 
 	return 0;
 }
 
-static void PVRSRVDriverShutdown(LDM_DEV * pDevice)
+static void PVRSRVDriverShutdown(LDM_DEV *pDevice)
 {
-	PVR_TRACE(("PVRSRVDriverShutdown(pDevice=%p)", pDevice));
+	PVR_TRACE("PVRSRVDriverShutdown(pDevice=%p)", pDevice);
 
 	(void)PVRSRVSetPowerStateKM(PVRSRV_POWER_STATE_D3);
 }
 
-static int PVRSRVDriverSuspend(LDM_DEV * pDevice, pm_message_t state)
+static int PVRSRVDriverSuspend(LDM_DEV *pDevice, pm_message_t state)
 {
-	PVR_TRACE(("PVRSRVDriverSuspend(pDevice=%p)", pDevice));
+	PVR_TRACE("PVRSRVDriverSuspend(pDevice=%p)", pDevice);
 
-	if (PVRSRVSetPowerStateKM(PVRSRV_POWER_STATE_D3) != PVRSRV_OK) {
+	if (PVRSRVSetPowerStateKM(PVRSRV_POWER_STATE_D3) != PVRSRV_OK)
 		return -EINVAL;
-	}
 	return 0;
 }
 
-static int PVRSRVDriverResume(LDM_DEV * pDevice)
+static int PVRSRVDriverResume(LDM_DEV *pDevice)
 {
-	PVR_TRACE(("PVRSRVDriverResume(pDevice=%p)", pDevice));
+	PVR_TRACE("PVRSRVDriverResume(pDevice=%p)", pDevice);
 
-	if (PVRSRVSetPowerStateKM(PVRSRV_POWER_STATE_D0) != PVRSRV_OK) {
+	if (PVRSRVSetPowerStateKM(PVRSRV_POWER_STATE_D0) != PVRSRV_OK)
 		return -EINVAL;
-	}
 	return 0;
 }
 
 static void PVRSRVDeviceRelease(struct device *pDevice)
 {
-	PVR_DPF((PVR_DBG_WARNING, "PVRSRVDeviceRelease(pDevice=%p)", pDevice));
+	PVR_DPF(PVR_DBG_WARNING, "PVRSRVDeviceRelease(pDevice=%p)", pDevice);
 }
 
 static int PVRSRVOpen(struct inode unref__ * pInode,
@@ -198,9 +187,8 @@
 
 	LinuxLockMutex(&gPVRSRVLock);
 
-	if (PVRSRVProcessConnect(OSGetCurrentProcessIDKM()) != PVRSRV_OK) {
+	if (PVRSRVProcessConnect(OSGetCurrentProcessIDKM()) != PVRSRV_OK)
 		Ret = -ENOMEM;
-	}
 
 	LinuxUnLockMutex(&gPVRSRVLock);
 
@@ -225,18 +213,18 @@
 {
 	int error;
 
-	PVR_TRACE(("PVRCore_Init"));
+	PVR_TRACE("PVRCore_Init");
 
 	AssignedMajorNumber = register_chrdev(0, DEVNAME, &pvrsrv_fops);
 
 	if (AssignedMajorNumber <= 0) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRCore_Init: unable to get major number"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRCore_Init: unable to get major number");
 
 		return -EBUSY;
 	}
 
-	PVR_TRACE(("PVRCore_Init: major device %d", AssignedMajorNumber));
+	PVR_TRACE("PVRCore_Init: major device %d", AssignedMajorNumber);
 
 	if (CreateProcEntries()) {
 		unregister_chrdev(AssignedMajorNumber, DRVNAME);
@@ -259,22 +247,22 @@
 
 	PVRMMapInit();
 
-	if ((error = platform_driver_register(&powervr_driver)) != 0) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRCore_Init: unable to register platform driver (%d)",
-			 error));
+	error = platform_driver_register(&powervr_driver);
+	if (error != 0) {
+		PVR_DPF(PVR_DBG_ERROR, "PVRCore_Init: "
+			"unable to register platform driver (%d)", error);
 
 		goto init_failed;
 	}
 
 	powervr_device.dev.devt = MKDEV(AssignedMajorNumber, 0);
 
-	if ((error = platform_device_register(&powervr_device)) != 0) {
+	error = platform_device_register(&powervr_device);
+	if (error != 0) {
 		platform_driver_unregister(&powervr_driver);
 
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRCore_Init: unable to register platform device (%d)",
-			 error));
+		PVR_DPF(PVR_DBG_ERROR, "PVRCore_Init: "
+			"unable to register platform device (%d)", error);
 
 		goto init_failed;
 	}
@@ -295,28 +283,23 @@
 
 static void __exit PVRCore_Cleanup(void)
 {
-	SYS_DATA *psSysData;
+	struct SYS_DATA *psSysData;
 
-	PVR_TRACE(("PVRCore_Cleanup"));
+	PVR_TRACE("PVRCore_Cleanup");
 
 	SysAcquireData(&psSysData);
 
-		   unregister_chrdev(AssignedMajorNumber, DRVNAME)
-		   ;
-
+	unregister_chrdev(AssignedMajorNumber, DRVNAME);
 
 	platform_device_unregister(&powervr_device);
 	platform_driver_unregister(&powervr_driver);
 
 	PVRMMapCleanup();
-
 	LinuxMMCleanup();
-
 	LinuxBridgeDeInit();
-
 	RemoveProcEntries();
 
-	PVR_TRACE(("PVRCore_Cleanup: unloading"));
+	PVR_TRACE("PVRCore_Cleanup: unloading");
 }
 
 module_init(PVRCore_Init);
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/mutex.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/mutex.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -34,37 +34,35 @@
 
 #include "mutex.h"
 
-
-IMG_VOID LinuxInitMutex(PVRSRV_LINUX_MUTEX * psPVRSRVMutex)
+void LinuxInitMutex(struct mutex *psPVRSRVMutex)
 {
 	mutex_init(psPVRSRVMutex);
 }
 
-IMG_VOID LinuxLockMutex(PVRSRV_LINUX_MUTEX * psPVRSRVMutex)
+void LinuxLockMutex(struct mutex *psPVRSRVMutex)
 {
 	mutex_lock(psPVRSRVMutex);
 }
 
-PVRSRV_ERROR LinuxLockMutexInterruptible(PVRSRV_LINUX_MUTEX * psPVRSRVMutex)
+enum PVRSRV_ERROR LinuxLockMutexInterruptible(struct mutex *psPVRSRVMutex)
 {
-	if (mutex_lock_interruptible(psPVRSRVMutex) == -EINTR) {
+	if (mutex_lock_interruptible(psPVRSRVMutex) == -EINTR)
 		return PVRSRV_ERROR_GENERIC;
-	} else {
+	else
 		return PVRSRV_OK;
-	}
 }
 
-IMG_INT32 LinuxTryLockMutex(PVRSRV_LINUX_MUTEX * psPVRSRVMutex)
+s32 LinuxTryLockMutex(struct mutex *psPVRSRVMutex)
 {
 	return mutex_trylock(psPVRSRVMutex);
 }
 
-IMG_VOID LinuxUnLockMutex(PVRSRV_LINUX_MUTEX * psPVRSRVMutex)
+void LinuxUnLockMutex(struct mutex *psPVRSRVMutex)
 {
 	mutex_unlock(psPVRSRVMutex);
 }
 
-IMG_BOOL LinuxIsLockedMutex(PVRSRV_LINUX_MUTEX * psPVRSRVMutex)
+IMG_BOOL LinuxIsLockedMutex(struct mutex *psPVRSRVMutex)
 {
 	return mutex_is_locked(psPVRSRVMutex);
 }
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/mutex.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/mutex.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -31,21 +31,19 @@
 
 #include <linux/mutex.h>
 
+extern struct mutex gPVRSRVLock;
 
-typedef struct mutex PVRSRV_LINUX_MUTEX;
-
-
-extern IMG_VOID LinuxInitMutex(PVRSRV_LINUX_MUTEX * psPVRSRVMutex);
+extern void LinuxInitMutex(struct mutex *psPVRSRVMutex);
 
-extern IMG_VOID LinuxLockMutex(PVRSRV_LINUX_MUTEX * psPVRSRVMutex);
+extern void LinuxLockMutex(struct mutex *psPVRSRVMutex);
 
-extern PVRSRV_ERROR LinuxLockMutexInterruptible(PVRSRV_LINUX_MUTEX *
-						psPVRSRVMutex);
+extern enum PVRSRV_ERROR LinuxLockMutexInterruptible(
+					struct mutex *psPVRSRVMutex);
 
-extern IMG_INT32 LinuxTryLockMutex(PVRSRV_LINUX_MUTEX * psPVRSRVMutex);
+extern s32 LinuxTryLockMutex(struct mutex *psPVRSRVMutex);
 
-extern IMG_VOID LinuxUnLockMutex(PVRSRV_LINUX_MUTEX * psPVRSRVMutex);
+extern void LinuxUnLockMutex(struct mutex *psPVRSRVMutex);
 
-extern IMG_BOOL LinuxIsLockedMutex(PVRSRV_LINUX_MUTEX * psPVRSRVMutex);
+extern IMG_BOOL LinuxIsLockedMutex(struct mutex *psPVRSRVMutex);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/oemfuncs.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/oemfuncs.h
@@ -1,47 +1,41 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #if !defined(__OEMFUNCS_H__)
 #define __OEMFUNCS_H__
 
+#include <linux/file.h>
 
-	typedef IMG_UINT32(*PFN_SRV_BRIDGEDISPATCH) (IMG_UINT32 Ioctl,
-						     IMG_BYTE * pInBuf,
-						     IMG_UINT32 InBufLen,
-						     IMG_BYTE * pOutBuf,
-						     IMG_UINT32 OutBufLen,
-						     IMG_UINT32 *
-						     pdwBytesTransferred);
-	typedef struct PVRSRV_DC_OEM_JTABLE_TAG {
-		PFN_SRV_BRIDGEDISPATCH pfnOEMBridgeDispatch;
-		IMG_PVOID pvDummy1;
-		IMG_PVOID pvDummy2;
-		IMG_PVOID pvDummy3;
-
-	} PVRSRV_DC_OEM_JTABLE;
+struct PVRSRV_DC_OEM_JTABLE {
+	long (*pfnOEMBridgeDispatch)(struct file *file, unsigned int cmd,
+				     unsigned long arg);
+	void *pvDummy1;
+	void *pvDummy2;
+	void *pvDummy3;
+};
 
 #define OEM_GET_EXT_FUNCS			(1<<1)
 
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/omaplfb.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/omaplfb.h
@@ -1,34 +1,34 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef __OMAPLFB_H__
 #define __OMAPLFB_H__
 
-extern IMG_BOOL PVRGetDisplayClassJTable(PVRSRV_DC_DISP2SRV_KMJTABLE *
-					 psJTable);
+extern IMG_BOOL PVRGetDisplayClassJTable(
+			struct PVRSRV_DC_DISP2SRV_KMJTABLE *psJTable);
 
 #define OMAPLCD_IRQ			25
 
@@ -67,106 +67,76 @@
 #define OMAPLCD_INTMASK_VSYNC		(1 << 1)
 #define OMAPLCD_INTMASK_OFF		0
 
-typedef struct OMAPLFB_BUFFER_TAG {
-	IMG_SYS_PHYADDR sSysAddr;
-	IMG_CPU_VIRTADDR sCPUVAddr;
-	IMG_UINT32 ui32BufferSize;
-	PVRSRV_SYNC_DATA *psSyncData;
-	struct OMAPLFB_BUFFER_TAG *psNext;
-} OMAPLFB_BUFFER;
-
-typedef struct OMAPLFB_VSYNC_FLIP_ITEM_TAG {
-
-	IMG_HANDLE hCmdComplete;
-
-	IMG_SYS_PHYADDR *sSysAddr;
-
-	IMG_UINT32 ui32SwapInterval;
-
+struct OMAPLFB_BUFFER {
+	struct IMG_SYS_PHYADDR sSysAddr;
+	void __iomem *sCPUVAddr;
+	u32 ui32BufferSize;
+	struct PVRSRV_SYNC_DATA *psSyncData;
+	struct OMAPLFB_BUFFER *psNext;
+};
+
+struct OMAPLFB_VSYNC_FLIP_ITEM {
+	void *hCmdComplete;
+	struct IMG_SYS_PHYADDR *sSysAddr;
+	u32 ui32SwapInterval;
 	IMG_BOOL bValid;
-
 	IMG_BOOL bFlipped;
-
 	IMG_BOOL bCmdCompleted;
+};
 
-} OMAPLFB_VSYNC_FLIP_ITEM;
-
-typedef struct PVRPDP_SWAPCHAIN_TAG {
-
-	IMG_UINT32 ui32BufferCount;
-
-	OMAPLFB_BUFFER *psBuffer;
-
-	OMAPLFB_VSYNC_FLIP_ITEM *psVSyncFlips;
-
-	IMG_UINT32 ui32InsertIndex;
-
-	IMG_UINT32 ui32RemoveIndex;
-
-	IMG_VOID *pvRegs;
-
-	PVRSRV_DC_DISP2SRV_KMJTABLE *psPVRJTable;
+struct OMAPLFB_SWAPCHAIN {
 
+	u32 ui32BufferCount;
+	struct OMAPLFB_BUFFER *psBuffer;
+	struct OMAPLFB_VSYNC_FLIP_ITEM *psVSyncFlips;
+	u32 ui32InsertIndex;
+	u32 ui32RemoveIndex;
+	void __iomem *pvRegs;
+	struct PVRSRV_DC_DISP2SRV_KMJTABLE *psPVRJTable;
 	IMG_BOOL bFlushCommands;
-
-	IMG_UINT32 ui32SetFlushStateRefCount;
-
+	u32 ui32SetFlushStateRefCount;
 	IMG_BOOL bBlanked;
-
 	spinlock_t *psSwapChainLock;
-} OMAPLFB_SWAPCHAIN;
-
-typedef struct OMAPLFB_FBINFO_TAG {
-	IMG_SYS_PHYADDR sSysAddr;
-	IMG_CPU_VIRTADDR sCPUVAddr;
-	IMG_UINT32 ui32FBSize;
-	IMG_UINT32 ui32BufferSize;
-	IMG_UINT32 ui32RoundedBufferSize;
-	IMG_UINT32 ui32Width;
-	IMG_UINT32 ui32Height;
-	IMG_UINT32 ui32ByteStride;
-
-	PVRSRV_PIXEL_FORMAT ePixelFormat;
-} OMAPLFB_FBINFO;
-
-typedef struct OMAPLFB_DEVINFO_TAG {
-	IMG_UINT32 ui32DeviceID;
-	DISPLAY_INFO sDisplayInfo;
-
-	OMAPLFB_BUFFER sSystemBuffer;
-
-	DISPLAY_FORMAT sDisplayFormat;
-
-	DISPLAY_DIMS sDisplayDim;
-
-	PVRSRV_DC_DISP2SRV_KMJTABLE sPVRJTable;
-
-	PVRSRV_DC_SRV2DISP_KMJTABLE sDCJTable;
-
-	OMAPLFB_FBINFO sFBInfo;
-
-	IMG_UINT32 ui32RefCount;
-
-	OMAPLFB_SWAPCHAIN *psSwapChain;
+};
 
+struct OMAPLFB_FBINFO {
+	struct IMG_SYS_PHYADDR sSysAddr;
+	void __iomem *sCPUVAddr;
+	u32 ui32FBSize;
+	u32 ui32BufferSize;
+	u32 ui32RoundedBufferSize;
+	u32 ui32Width;
+	u32 ui32Height;
+	u32 ui32ByteStride;
+
+	enum PVRSRV_PIXEL_FORMAT ePixelFormat;
+};
+
+struct OMAPLFB_DEVINFO {
+	u32 ui32DeviceID;
+	struct DISPLAY_INFO sDisplayInfo;
+	struct OMAPLFB_BUFFER sSystemBuffer;
+	struct DISPLAY_FORMAT sDisplayFormat;
+	struct DISPLAY_DIMS sDisplayDim;
+	struct PVRSRV_DC_DISP2SRV_KMJTABLE sPVRJTable;
+	struct PVRSRV_DC_SRV2DISP_KMJTABLE sDCJTable;
+	struct OMAPLFB_FBINFO sFBInfo;
+	u32 ui32RefCount;
+	struct OMAPLFB_SWAPCHAIN *psSwapChain;
 	IMG_BOOL bFlushCommands;
-
-	IMG_DEV_VIRTADDR sDisplayDevVAddr;
-
+	struct IMG_DEV_VIRTADDR sDisplayDevVAddr;
 	struct fb_info *psLINFBInfo;
-
 	struct notifier_block sLINNotifBlock;
-
 	IMG_BOOL bDeviceSuspended;
-
 	spinlock_t SwapChainLock;
-} OMAPLFB_DEVINFO;
+};
 
 #define	OMAPLFB_PAGE_SIZE 4096
 #define	OMAPLFB_PAGE_MASK (OMAPLFB_PAGE_SIZE - 1)
 #define	OMAPLFB_PAGE_TRUNC (~OMAPLFB_PAGE_MASK)
 
-#define	OMAPLFB_PAGE_ROUNDUP(x) (((x) + OMAPLFB_PAGE_MASK) & OMAPLFB_PAGE_TRUNC)
+#define	OMAPLFB_PAGE_ROUNDUP(x)		\
+	(((x) + OMAPLFB_PAGE_MASK) & OMAPLFB_PAGE_TRUNC)
 
 #ifdef	DEBUG
 #define	DEBUG_PRINTK(x) printk x
@@ -179,23 +149,24 @@
 #define	DEVNAME	DRVNAME
 #define	DRIVER_PREFIX DRVNAME
 
-PVRSRV_ERROR OMAPLFBInit(IMG_VOID);
-PVRSRV_ERROR OMAPLFBDeinit(IMG_VOID);
+enum PVRSRV_ERROR OMAPLFBInit(void);
+enum PVRSRV_ERROR OMAPLFBDeinit(void);
 
-IMG_VOID OMAPLFBDriverSuspend(IMG_VOID);
-IMG_VOID OMAPLFBDriverResume(IMG_VOID);
+void OMAPLFBDriverSuspend(void);
+void OMAPLFBDriverResume(void);
 
-IMG_VOID *OMAPLFBAllocKernelMem(IMG_UINT32 ui32Size);
-IMG_VOID OMAPLFBFreeKernelMem(IMG_VOID * pvMem);
-PVRSRV_ERROR OMAPLFBGetLibFuncAddr(IMG_CHAR * szFunctionName,
-				   PFN_DC_GET_PVRJTABLE * ppfnFuncTable);
-PVRSRV_ERROR OMAPLFBInstallVSyncISR(OMAPLFB_SWAPCHAIN * psSwapChain);
-PVRSRV_ERROR OMAPLFBUninstallVSyncISR(OMAPLFB_SWAPCHAIN * psSwapChain);
-IMG_BOOL OMAPLFBVSyncIHandler(OMAPLFB_SWAPCHAIN * psSwapChain);
-IMG_VOID OMAPLFBEnableVSyncInterrupt(OMAPLFB_SWAPCHAIN * psSwapChain);
-IMG_VOID OMAPLFBDisableVSyncInterrupt(OMAPLFB_SWAPCHAIN * psSwapChain);
-IMG_VOID OMAPLFBEnableDisplayRegisterAccess(IMG_VOID);
-IMG_VOID OMAPLFBDisableDisplayRegisterAccess(IMG_VOID);
-IMG_VOID OMAPLFBFlip(OMAPLFB_SWAPCHAIN * psSwapChain, IMG_UINT32 aPhyAddr);
+void *OMAPLFBAllocKernelMem(u32 ui32Size);
+void OMAPLFBFreeKernelMem(void *pvMem);
+enum PVRSRV_ERROR OMAPLFBGetLibFuncAddr(char *szFunctionName,
+	IMG_BOOL (**ppfnFuncTable)(struct PVRSRV_DC_DISP2SRV_KMJTABLE *));
+enum PVRSRV_ERROR OMAPLFBInstallVSyncISR(struct OMAPLFB_SWAPCHAIN *psSwapChain);
+enum PVRSRV_ERROR OMAPLFBUninstallVSyncISR(
+	struct OMAPLFB_SWAPCHAIN *psSwapChain);
+IMG_BOOL OMAPLFBVSyncIHandler(struct OMAPLFB_SWAPCHAIN *psSwapChain);
+void OMAPLFBEnableVSyncInterrupt(struct OMAPLFB_SWAPCHAIN *psSwapChain);
+void OMAPLFBDisableVSyncInterrupt(struct OMAPLFB_SWAPCHAIN *psSwapChain);
+void OMAPLFBEnableDisplayRegisterAccess(void);
+void OMAPLFBDisableDisplayRegisterAccess(void);
+void OMAPLFBFlip(struct OMAPLFB_SWAPCHAIN *psSwapChain, u32 aPhyAddr);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/omaplfb_displayclass.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/omaplfb_displayclass.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -38,52 +38,50 @@
 #include "kerneldisplay.h"
 #include "omaplfb.h"
 
-static IMG_VOID *gpvAnchor;
+static void *gpvAnchor;
 
-static int fb_idx = 0;
+static int fb_idx;
 
 #define OMAPLFB_COMMAND_COUNT		1
 
-static PFN_DC_GET_PVRJTABLE pfnGetPVRJTable = IMG_NULL;
+static IMG_BOOL (*pfnGetPVRJTable)(struct PVRSRV_DC_DISP2SRV_KMJTABLE *);
 
-static OMAPLFB_DEVINFO *GetAnchorPtr(IMG_VOID)
+static struct OMAPLFB_DEVINFO *GetAnchorPtr(void)
 {
-	return (OMAPLFB_DEVINFO *) gpvAnchor;
+	return (struct OMAPLFB_DEVINFO *)gpvAnchor;
 }
 
-static IMG_VOID SetAnchorPtr(OMAPLFB_DEVINFO * psDevInfo)
+static void SetAnchorPtr(struct OMAPLFB_DEVINFO *psDevInfo)
 {
-	gpvAnchor = (IMG_VOID *) psDevInfo;
+	gpvAnchor = (void *) psDevInfo;
 }
 
-static IMG_VOID FlushInternalVSyncQueue(OMAPLFB_SWAPCHAIN * psSwapChain)
+static void FlushInternalVSyncQueue(struct OMAPLFB_SWAPCHAIN *psSwapChain)
 {
-	OMAPLFB_VSYNC_FLIP_ITEM *psFlipItem;
-	IMG_UINT32 ui32MaxIndex;
-	IMG_UINT32 i;
+	struct OMAPLFB_VSYNC_FLIP_ITEM *psFlipItem;
+	u32 ui32MaxIndex;
+	u32 i;
 
 	psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ui32RemoveIndex];
 	ui32MaxIndex = psSwapChain->ui32BufferCount - 1;
 
 	for (i = 0; i < psSwapChain->ui32BufferCount; i++) {
-		if (!psFlipItem->bValid) {
+		if (!psFlipItem->bValid)
 			continue;
-		}
 
 		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			      ": FlushInternalVSyncQueue: Flushing swap buffer (index %lu)\n",
-			      psSwapChain->ui32RemoveIndex));
+			      ": %s: Flushing swap buffer (index %u)\n",
+			      __func__, psSwapChain->ui32RemoveIndex));
 
-		if (psFlipItem->bFlipped == IMG_FALSE) {
+		if (psFlipItem->bFlipped == IMG_FALSE)
 
 			OMAPLFBFlip(psSwapChain,
-				    (IMG_UINT32) psFlipItem->sSysAddr);
-		}
+				    (u32) psFlipItem->sSysAddr);
 
 		if (psFlipItem->bCmdCompleted == IMG_FALSE) {
 			DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-				      ": FlushInternalVSyncQueue: Calling command complete for swap buffer (index %lu)\n",
-				      psSwapChain->ui32RemoveIndex));
+		  ": %s: Calling command complete for swap buffer (index %u)\n",
+			  __func__, psSwapChain->ui32RemoveIndex));
 
 			psSwapChain->psPVRJTable->
 			    pfnPVRSRVCmdComplete(psFlipItem->hCmdComplete,
@@ -92,9 +90,8 @@
 
 		psSwapChain->ui32RemoveIndex++;
 
-		if (psSwapChain->ui32RemoveIndex > ui32MaxIndex) {
+		if (psSwapChain->ui32RemoveIndex > ui32MaxIndex)
 			psSwapChain->ui32RemoveIndex = 0;
-		}
 
 		psFlipItem->bFlipped = IMG_FALSE;
 		psFlipItem->bCmdCompleted = IMG_FALSE;
@@ -108,14 +105,13 @@
 	psSwapChain->ui32RemoveIndex = 0;
 }
 
-static IMG_VOID SetFlushStateInternalNoLock(OMAPLFB_DEVINFO * psDevInfo,
+static void SetFlushStateInternalNoLock(struct OMAPLFB_DEVINFO *psDevInfo,
 					    IMG_BOOL bFlushState)
 {
-	OMAPLFB_SWAPCHAIN *psSwapChain = psDevInfo->psSwapChain;
+	struct OMAPLFB_SWAPCHAIN *psSwapChain = psDevInfo->psSwapChain;
 
-	if (psSwapChain == IMG_NULL) {
+	if (psSwapChain == NULL)
 		return;
-	}
 
 	if (bFlushState) {
 		if (psSwapChain->ui32SetFlushStateRefCount == 0) {
@@ -135,19 +131,17 @@
 	}
 }
 
-static IMG_VOID SetFlushStateInternal(OMAPLFB_DEVINFO * psDevInfo,
+static void SetFlushStateInternal(struct OMAPLFB_DEVINFO *psDevInfo,
 				      IMG_BOOL bFlushState)
 {
 	unsigned long ulLockFlags;
 
 	spin_lock_irqsave(&psDevInfo->SwapChainLock, ulLockFlags);
-
 	SetFlushStateInternalNoLock(psDevInfo, bFlushState);
-
 	spin_unlock_irqrestore(&psDevInfo->SwapChainLock, ulLockFlags);
 }
 
-static IMG_VOID SetFlushStateExternal(OMAPLFB_DEVINFO * psDevInfo,
+static void SetFlushStateExternal(struct OMAPLFB_DEVINFO *psDevInfo,
 				      IMG_BOOL bFlushState)
 {
 	unsigned long ulLockFlags;
@@ -162,9 +156,9 @@
 	spin_unlock_irqrestore(&psDevInfo->SwapChainLock, ulLockFlags);
 }
 
-static IMG_VOID SetDCState(IMG_HANDLE hDevice, IMG_UINT32 ui32State)
+static void SetDCState(void *hDevice, u32 ui32State)
 {
-	OMAPLFB_DEVINFO *psDevInfo = (OMAPLFB_DEVINFO *) hDevice;
+	struct OMAPLFB_DEVINFO *psDevInfo = (struct OMAPLFB_DEVINFO *)hDevice;
 
 	switch (ui32State) {
 	case DC_STATE_FLUSH_COMMANDS:
@@ -183,14 +177,13 @@
 static int FrameBufferEvents(struct notifier_block *psNotif,
 			     unsigned long event, void *data)
 {
-	OMAPLFB_DEVINFO *psDevInfo;
-	OMAPLFB_SWAPCHAIN *psSwapChain;
+	struct OMAPLFB_DEVINFO *psDevInfo;
+	struct OMAPLFB_SWAPCHAIN *psSwapChain;
 	struct fb_event *psFBEvent = (struct fb_event *)data;
 	IMG_BOOL bBlanked;;
 
-	if (event != FB_EVENT_BLANK) {
+	if (event != FB_EVENT_BLANK)
 		return 0;
-	}
 
 	psDevInfo = GetAnchorPtr();
 	psSwapChain = psDevInfo->psSwapChain;
@@ -200,19 +193,18 @@
 	if (bBlanked != psSwapChain->bBlanked) {
 		psSwapChain->bBlanked = bBlanked;
 
-		if (bBlanked) {
+		if (bBlanked)
 
 			SetFlushStateInternal(psDevInfo, IMG_TRUE);
-		} else {
+		else
 
 			SetFlushStateInternal(psDevInfo, IMG_FALSE);
-		}
 	}
 
 	return 0;
 }
 
-static PVRSRV_ERROR UnblankDisplay(OMAPLFB_DEVINFO * psDevInfo)
+static enum PVRSRV_ERROR UnblankDisplay(struct OMAPLFB_DEVINFO *psDevInfo)
 {
 	int res;
 
@@ -228,11 +220,12 @@
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR EnableLFBEventNotification(OMAPLFB_DEVINFO * psDevInfo)
+static enum PVRSRV_ERROR EnableLFBEventNotification(struct OMAPLFB_DEVINFO
+								   *psDevInfo)
 {
 	int res;
-	OMAPLFB_SWAPCHAIN *psSwapChain = psDevInfo->psSwapChain;
-	PVRSRV_ERROR eError;
+	struct OMAPLFB_SWAPCHAIN *psSwapChain = psDevInfo->psSwapChain;
+	enum PVRSRV_ERROR eError;
 
 	memset(&psDevInfo->sLINNotifBlock, 0,
 	       sizeof(psDevInfo->sLINNotifBlock));
@@ -259,7 +252,8 @@
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR DisableLFBEventNotification(OMAPLFB_DEVINFO * psDevInfo)
+static enum PVRSRV_ERROR DisableLFBEventNotification(struct OMAPLFB_DEVINFO
+								   *psDevInfo)
 {
 	int res;
 
@@ -273,12 +267,11 @@
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR OpenDCDevice(IMG_UINT32 ui32DeviceID,
-				 IMG_HANDLE * phDevice,
-				 PVRSRV_SYNC_DATA * psSystemBufferSyncData)
+static enum PVRSRV_ERROR OpenDCDevice(u32 ui32DeviceID, void **phDevice,
+				struct PVRSRV_SYNC_DATA *psSystemBufferSyncData)
 {
-	OMAPLFB_DEVINFO *psDevInfo;
-	PVRSRV_ERROR eError;
+	struct OMAPLFB_DEVINFO *psDevInfo;
+	enum PVRSRV_ERROR eError;
 
 	PVR_UNREFERENCED_PARAMETER(ui32DeviceID);
 
@@ -293,184 +286,162 @@
 		return eError;
 	}
 
-	*phDevice = (IMG_HANDLE) psDevInfo;
+	*phDevice = (void *) psDevInfo;
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR CloseDCDevice(IMG_HANDLE hDevice)
+static enum PVRSRV_ERROR CloseDCDevice(void *hDevice)
 {
 	PVR_UNREFERENCED_PARAMETER(hDevice);
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR EnumDCFormats(IMG_HANDLE hDevice,
-				  IMG_UINT32 * pui32NumFormats,
-				  DISPLAY_FORMAT * psFormat)
+static enum PVRSRV_ERROR EnumDCFormats(void *hDevice, u32 *pui32NumFormats,
+				  struct DISPLAY_FORMAT *psFormat)
 {
-	OMAPLFB_DEVINFO *psDevInfo;
+	struct OMAPLFB_DEVINFO *psDevInfo;
 
-	if (!hDevice || !pui32NumFormats) {
+	if (!hDevice || !pui32NumFormats)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
-	psDevInfo = (OMAPLFB_DEVINFO *) hDevice;
+	psDevInfo = (struct OMAPLFB_DEVINFO *)hDevice;
 
 	*pui32NumFormats = 1;
 
-	if (psFormat) {
+	if (psFormat)
 		psFormat[0] = psDevInfo->sDisplayFormat;
-	}
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR EnumDCDims(IMG_HANDLE hDevice,
-			       DISPLAY_FORMAT * psFormat,
-			       IMG_UINT32 * pui32NumDims, DISPLAY_DIMS * psDim)
+static enum PVRSRV_ERROR EnumDCDims(void *hDevice,
+			       struct DISPLAY_FORMAT *psFormat,
+			       u32 *pui32NumDims, struct DISPLAY_DIMS *psDim)
 {
-	OMAPLFB_DEVINFO *psDevInfo;
+	struct OMAPLFB_DEVINFO *psDevInfo;
 
-	if (!hDevice || !psFormat || !pui32NumDims) {
+	if (!hDevice || !psFormat || !pui32NumDims)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
-	psDevInfo = (OMAPLFB_DEVINFO *) hDevice;
+	psDevInfo = (struct OMAPLFB_DEVINFO *)hDevice;
 
 	*pui32NumDims = 1;
 
-	if (psDim) {
+	if (psDim)
 		psDim[0] = psDevInfo->sDisplayDim;
-	}
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR GetDCSystemBuffer(IMG_HANDLE hDevice, IMG_HANDLE * phBuffer)
+static enum PVRSRV_ERROR GetDCSystemBuffer(void *hDevice, void **phBuffer)
 {
-	OMAPLFB_DEVINFO *psDevInfo;
+	struct OMAPLFB_DEVINFO *psDevInfo;
 
-	if (!hDevice || !phBuffer) {
+	if (!hDevice || !phBuffer)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
-	psDevInfo = (OMAPLFB_DEVINFO *) hDevice;
+	psDevInfo = (struct OMAPLFB_DEVINFO *)hDevice;
 
-	*phBuffer = (IMG_HANDLE) & psDevInfo->sSystemBuffer;
+	*phBuffer = (void *) &psDevInfo->sSystemBuffer;
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR GetDCInfo(IMG_HANDLE hDevice, DISPLAY_INFO * psDCInfo)
+static enum PVRSRV_ERROR GetDCInfo(void *hDevice, struct DISPLAY_INFO *psDCInfo)
 {
-	OMAPLFB_DEVINFO *psDevInfo;
+	struct OMAPLFB_DEVINFO *psDevInfo;
 
-	if (!hDevice || !psDCInfo) {
+	if (!hDevice || !psDCInfo)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
-	psDevInfo = (OMAPLFB_DEVINFO *) hDevice;
+	psDevInfo = (struct OMAPLFB_DEVINFO *)hDevice;
 
 	*psDCInfo = psDevInfo->sDisplayInfo;
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR GetDCBufferAddr(IMG_HANDLE hDevice,
-				    IMG_HANDLE hBuffer,
-				    IMG_SYS_PHYADDR ** ppsSysAddr,
-				    IMG_UINT32 * pui32ByteSize,
-				    IMG_VOID ** ppvCpuVAddr,
-				    IMG_HANDLE * phOSMapInfo,
-				    IMG_BOOL * pbIsContiguous)
+static enum PVRSRV_ERROR GetDCBufferAddr(void *hDevice, void *hBuffer,
+				    struct IMG_SYS_PHYADDR **ppsSysAddr,
+				    u32 *pui32ByteSize,
+				    void __iomem **ppvCpuVAddr,
+				    void **phOSMapInfo,
+				    IMG_BOOL *pbIsContiguous)
 {
-	OMAPLFB_DEVINFO *psDevInfo;
-	OMAPLFB_BUFFER *psSystemBuffer;
+	struct OMAPLFB_DEVINFO *psDevInfo;
+	struct OMAPLFB_BUFFER *psSystemBuffer;
 
-	if (!hDevice) {
+	if (!hDevice)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
-	psDevInfo = (OMAPLFB_DEVINFO *) hDevice;
+	psDevInfo = (struct OMAPLFB_DEVINFO *)hDevice;
 
-	if (!hBuffer) {
+	if (!hBuffer)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
-	psSystemBuffer = (OMAPLFB_BUFFER *) hBuffer;
+	psSystemBuffer = (struct OMAPLFB_BUFFER *)hBuffer;
 
-	if (!ppsSysAddr) {
+	if (!ppsSysAddr)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
 	*ppsSysAddr = &psSystemBuffer->sSysAddr;
 
-	if (!pui32ByteSize) {
+	if (!pui32ByteSize)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
 	*pui32ByteSize = psDevInfo->sFBInfo.ui32BufferSize;
 
-	if (ppvCpuVAddr) {
+	if (ppvCpuVAddr)
 		*ppvCpuVAddr = psSystemBuffer->sCPUVAddr;
-	}
 
-	if (phOSMapInfo) {
-		*phOSMapInfo = (IMG_HANDLE) 0;
-	}
+	if (phOSMapInfo)
+		*phOSMapInfo = (void *) 0;
 
-	if (pbIsContiguous) {
+	if (pbIsContiguous)
 		*pbIsContiguous = IMG_TRUE;
-	}
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE hDevice,
-				      IMG_UINT32 ui32Flags,
-				      DISPLAY_SURF_ATTRIBUTES * psDstSurfAttrib,
-				      DISPLAY_SURF_ATTRIBUTES * psSrcSurfAttrib,
-				      IMG_UINT32 ui32BufferCount,
-				      PVRSRV_SYNC_DATA ** ppsSyncData,
-				      IMG_UINT32 ui32OEMFlags,
-				      IMG_HANDLE * phSwapChain,
-				      IMG_UINT32 * pui32SwapChainID)
-{
-	OMAPLFB_DEVINFO *psDevInfo;
-	OMAPLFB_SWAPCHAIN *psSwapChain;
-	OMAPLFB_BUFFER *psBuffer;
-	OMAPLFB_VSYNC_FLIP_ITEM *psVSyncFlips;
-	IMG_UINT32 i;
-	PVRSRV_ERROR eError = PVRSRV_ERROR_GENERIC;
+static enum PVRSRV_ERROR CreateDCSwapChain(void *hDevice, u32 ui32Flags,
+			      struct DISPLAY_SURF_ATTRIBUTES *psDstSurfAttrib,
+			      struct DISPLAY_SURF_ATTRIBUTES *psSrcSurfAttrib,
+			      u32 ui32BufferCount,
+			      struct PVRSRV_SYNC_DATA **ppsSyncData,
+			      u32 ui32OEMFlags, void **phSwapChain,
+			      u32 *pui32SwapChainID)
+{
+	struct OMAPLFB_DEVINFO *psDevInfo;
+	struct OMAPLFB_SWAPCHAIN *psSwapChain;
+	struct OMAPLFB_BUFFER *psBuffer;
+	struct OMAPLFB_VSYNC_FLIP_ITEM *psVSyncFlips;
+	u32 i;
+	enum PVRSRV_ERROR eError = PVRSRV_ERROR_GENERIC;
 	unsigned long ulLockFlags;
-	IMG_UINT32 ui32BuffersToSkip;
+	u32 ui32BuffersToSkip;
 
 	PVR_UNREFERENCED_PARAMETER(ui32OEMFlags);
 	PVR_UNREFERENCED_PARAMETER(pui32SwapChainID);
 
 	if (!hDevice
 	    || !psDstSurfAttrib
-	    || !psSrcSurfAttrib || !ppsSyncData || !phSwapChain) {
+	    || !psSrcSurfAttrib || !ppsSyncData || !phSwapChain)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
-	psDevInfo = (OMAPLFB_DEVINFO *) hDevice;
+	psDevInfo = (struct OMAPLFB_DEVINFO *)hDevice;
 
-	if (psDevInfo->sDisplayInfo.ui32MaxSwapChains == 0) {
+	if (psDevInfo->sDisplayInfo.ui32MaxSwapChains == 0)
 		return PVRSRV_ERROR_NOT_SUPPORTED;
-	}
 
-	if (psDevInfo->psSwapChain != IMG_NULL) {
+	if (psDevInfo->psSwapChain != NULL)
 		return PVRSRV_ERROR_FLIP_CHAIN_EXISTS;
-	}
 
-	if (ui32BufferCount > psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers) {
+	if (ui32BufferCount > psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers)
 		return PVRSRV_ERROR_TOOMANYBUFFERS;
-	}
 
 	if ((psDevInfo->sFBInfo.ui32RoundedBufferSize * ui32BufferCount) >
-	    psDevInfo->sFBInfo.ui32FBSize) {
+	    psDevInfo->sFBInfo.ui32FBSize)
 		return PVRSRV_ERROR_TOOMANYBUFFERS;
-	}
 
 	ui32BuffersToSkip =
 	    psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers - ui32BufferCount;
@@ -482,10 +453,9 @@
 	    || psDstSurfAttrib->sDims.ui32Width !=
 	    psDevInfo->sDisplayDim.ui32Width
 	    || psDstSurfAttrib->sDims.ui32Height !=
-	    psDevInfo->sDisplayDim.ui32Height) {
+	    psDevInfo->sDisplayDim.ui32Height)
 
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
 	if (psDstSurfAttrib->pixelformat != psSrcSurfAttrib->pixelformat
 	    || psDstSurfAttrib->sDims.ui32ByteStride !=
@@ -493,31 +463,27 @@
 	    || psDstSurfAttrib->sDims.ui32Width !=
 	    psSrcSurfAttrib->sDims.ui32Width
 	    || psDstSurfAttrib->sDims.ui32Height !=
-	    psSrcSurfAttrib->sDims.ui32Height) {
+	    psSrcSurfAttrib->sDims.ui32Height)
 
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
 	PVR_UNREFERENCED_PARAMETER(ui32Flags);
 
-	psSwapChain =
-	    (OMAPLFB_SWAPCHAIN *)
-	    OMAPLFBAllocKernelMem(sizeof(OMAPLFB_SWAPCHAIN));
-	if (!psSwapChain) {
+	psSwapChain = (struct OMAPLFB_SWAPCHAIN *)
+			OMAPLFBAllocKernelMem(sizeof(struct OMAPLFB_SWAPCHAIN));
+	if (!psSwapChain)
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
-	}
 
-	psBuffer =
-	    (OMAPLFB_BUFFER *) OMAPLFBAllocKernelMem(sizeof(OMAPLFB_BUFFER) *
+	psBuffer = (struct OMAPLFB_BUFFER *)
+	     OMAPLFBAllocKernelMem(sizeof(struct OMAPLFB_BUFFER) *
 						     ui32BufferCount);
 	if (!psBuffer) {
 		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
 		goto ErrorFreeSwapChain;
 	}
 
-	psVSyncFlips =
-	    (OMAPLFB_VSYNC_FLIP_ITEM *)
-	    OMAPLFBAllocKernelMem(sizeof(OMAPLFB_VSYNC_FLIP_ITEM) *
+	psVSyncFlips = (struct OMAPLFB_VSYNC_FLIP_ITEM *)
+		OMAPLFBAllocKernelMem(sizeof(struct OMAPLFB_VSYNC_FLIP_ITEM) *
 				  ui32BufferCount);
 	if (!psVSyncFlips) {
 		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
@@ -532,15 +498,14 @@
 	psSwapChain->psPVRJTable = &psDevInfo->sPVRJTable;
 	psSwapChain->psSwapChainLock = &psDevInfo->SwapChainLock;
 
-	for (i = 0; i < ui32BufferCount - 1; i++) {
+	for (i = 0; i < ui32BufferCount - 1; i++)
 		psBuffer[i].psNext = &psBuffer[i + 1];
-	}
 
 	psBuffer[i].psNext = &psBuffer[0];
 
 	for (i = 0; i < ui32BufferCount; i++) {
-		IMG_UINT32 ui32SwapBuffer = i + ui32BuffersToSkip;
-		IMG_UINT32 ui32BufferOffset =
+		u32 ui32SwapBuffer = i + ui32BuffersToSkip;
+		u32 ui32BufferOffset =
 		    ui32SwapBuffer * psDevInfo->sFBInfo.ui32RoundedBufferSize;
 
 		psBuffer[i].psSyncData = ppsSyncData[i];
@@ -562,7 +527,7 @@
 	psSwapChain->pvRegs =
 	    ioremap(psDevInfo->psLINFBInfo->fix.mmio_start,
 		    psDevInfo->psLINFBInfo->fix.mmio_len);
-	if (psSwapChain->pvRegs == IMG_NULL) {
+	if (psSwapChain->pvRegs == NULL) {
 		printk(KERN_WARNING DRIVER_PREFIX
 		       ": Couldn't map registers needed for flipping\n");
 		goto ErrorDisableDisplayRegisters;
@@ -596,15 +561,14 @@
 		goto ErrorUninstallVSyncInterrupt;
 	}
 
-	*phSwapChain = (IMG_HANDLE) psSwapChain;
+	*phSwapChain = (void *) psSwapChain;
 
 	return PVRSRV_OK;
 
 ErrorUninstallVSyncInterrupt:
-	if (OMAPLFBUninstallVSyncISR(psSwapChain) != PVRSRV_OK) {
+	if (OMAPLFBUninstallVSyncISR(psSwapChain) != PVRSRV_OK)
 		printk(KERN_WARNING DRIVER_PREFIX
 		       ": Couldn't uninstall VSync ISR\n");
-	}
 ErrorUnmapRegisters:
 	iounmap(psSwapChain->pvRegs);
 ErrorDisableDisplayRegisters:
@@ -618,29 +582,25 @@
 	return eError;
 }
 
-static PVRSRV_ERROR DestroyDCSwapChain(IMG_HANDLE hDevice,
-				       IMG_HANDLE hSwapChain)
+static enum PVRSRV_ERROR DestroyDCSwapChain(void *hDevice, void *hSwapChain)
 {
-	OMAPLFB_DEVINFO *psDevInfo;
-	OMAPLFB_SWAPCHAIN *psSwapChain;
+	struct OMAPLFB_DEVINFO *psDevInfo;
+	struct OMAPLFB_SWAPCHAIN *psSwapChain;
 	unsigned long ulLockFlags;
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
-	if (!hDevice || !hSwapChain) {
+	if (!hDevice || !hSwapChain)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
-	psDevInfo = (OMAPLFB_DEVINFO *) hDevice;
-	psSwapChain = (OMAPLFB_SWAPCHAIN *) hSwapChain;
-	if (psSwapChain != psDevInfo->psSwapChain) {
+	psDevInfo = (struct OMAPLFB_DEVINFO *)hDevice;
+	psSwapChain = (struct OMAPLFB_SWAPCHAIN *)hSwapChain;
+	if (psSwapChain != psDevInfo->psSwapChain)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
 	eError = DisableLFBEventNotification(psDevInfo);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		printk(KERN_WARNING DRIVER_PREFIX
 		       ": Couldn't disable framebuffer event notification\n");
-	}
 
 	spin_lock_irqsave(&psDevInfo->SwapChainLock, ulLockFlags);
 
@@ -650,7 +610,7 @@
 
 	OMAPLFBFlip(psSwapChain, psDevInfo->sFBInfo.sSysAddr.uiAddr);
 
-	psDevInfo->psSwapChain = IMG_NULL;
+	psDevInfo->psSwapChain = NULL;
 
 	spin_unlock_irqrestore(&psDevInfo->SwapChainLock, ulLockFlags);
 
@@ -671,8 +631,8 @@
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR SetDCDstRect(IMG_HANDLE hDevice,
-				 IMG_HANDLE hSwapChain, IMG_RECT * psRect)
+static enum PVRSRV_ERROR SetDCDstRect(void *hDevice,
+				 void *hSwapChain, struct IMG_RECT *psRect)
 {
 	PVR_UNREFERENCED_PARAMETER(hDevice);
 	PVR_UNREFERENCED_PARAMETER(hSwapChain);
@@ -681,8 +641,8 @@
 	return PVRSRV_ERROR_NOT_SUPPORTED;
 }
 
-static PVRSRV_ERROR SetDCSrcRect(IMG_HANDLE hDevice,
-				 IMG_HANDLE hSwapChain, IMG_RECT * psRect)
+static enum PVRSRV_ERROR SetDCSrcRect(void *hDevice,
+				 void *hSwapChain, struct IMG_RECT *psRect)
 {
 	PVR_UNREFERENCED_PARAMETER(hDevice);
 	PVR_UNREFERENCED_PARAMETER(hSwapChain);
@@ -691,9 +651,8 @@
 	return PVRSRV_ERROR_NOT_SUPPORTED;
 }
 
-static PVRSRV_ERROR SetDCDstColourKey(IMG_HANDLE hDevice,
-				      IMG_HANDLE hSwapChain,
-				      IMG_UINT32 ui32CKColour)
+static enum PVRSRV_ERROR SetDCDstColourKey(void *hDevice, void *hSwapChain,
+				      u32 ui32CKColour)
 {
 	PVR_UNREFERENCED_PARAMETER(hDevice);
 	PVR_UNREFERENCED_PARAMETER(hSwapChain);
@@ -702,9 +661,8 @@
 	return PVRSRV_ERROR_NOT_SUPPORTED;
 }
 
-static PVRSRV_ERROR SetDCSrcColourKey(IMG_HANDLE hDevice,
-				      IMG_HANDLE hSwapChain,
-				      IMG_UINT32 ui32CKColour)
+static enum PVRSRV_ERROR SetDCSrcColourKey(void *hDevice, void *hSwapChain,
+				      u32 ui32CKColour)
 {
 	PVR_UNREFERENCED_PARAMETER(hDevice);
 	PVR_UNREFERENCED_PARAMETER(hSwapChain);
@@ -713,73 +671,63 @@
 	return PVRSRV_ERROR_NOT_SUPPORTED;
 }
 
-static PVRSRV_ERROR GetDCBuffers(IMG_HANDLE hDevice,
-				 IMG_HANDLE hSwapChain,
-				 IMG_UINT32 * pui32BufferCount,
-				 IMG_HANDLE * phBuffer)
-{
-	OMAPLFB_DEVINFO *psDevInfo;
-	OMAPLFB_SWAPCHAIN *psSwapChain;
-	IMG_UINT32 i;
+static enum PVRSRV_ERROR GetDCBuffers(void *hDevice, void *hSwapChain,
+				 u32 *pui32BufferCount, void **phBuffer)
+{
+	struct OMAPLFB_DEVINFO *psDevInfo;
+	struct OMAPLFB_SWAPCHAIN *psSwapChain;
+	u32 i;
 
-	if (!hDevice || !hSwapChain || !pui32BufferCount || !phBuffer) {
+	if (!hDevice || !hSwapChain || !pui32BufferCount || !phBuffer)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
-	psDevInfo = (OMAPLFB_DEVINFO *) hDevice;
-	psSwapChain = (OMAPLFB_SWAPCHAIN *) hSwapChain;
-	if (psSwapChain != psDevInfo->psSwapChain) {
+	psDevInfo = (struct OMAPLFB_DEVINFO *)hDevice;
+	psSwapChain = (struct OMAPLFB_SWAPCHAIN *)hSwapChain;
+	if (psSwapChain != psDevInfo->psSwapChain)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
 	*pui32BufferCount = psSwapChain->ui32BufferCount;
 
-	for (i = 0; i < psSwapChain->ui32BufferCount; i++) {
-		phBuffer[i] = (IMG_HANDLE) & psSwapChain->psBuffer[i];
-	}
+	for (i = 0; i < psSwapChain->ui32BufferCount; i++)
+		phBuffer[i] = (void *) &psSwapChain->psBuffer[i];
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR SwapToDCBuffer(IMG_HANDLE hDevice,
-				   IMG_HANDLE hBuffer,
-				   IMG_UINT32 ui32SwapInterval,
-				   IMG_HANDLE hPrivateTag,
-				   IMG_UINT32 ui32ClipRectCount,
-				   IMG_RECT * psClipRect)
+static enum PVRSRV_ERROR SwapToDCBuffer(void *hDevice, void *hBuffer,
+				   u32 ui32SwapInterval, void *hPrivateTag,
+				   u32 ui32ClipRectCount,
+				   struct IMG_RECT *psClipRect)
 {
-	OMAPLFB_DEVINFO *psDevInfo;
+	struct OMAPLFB_DEVINFO *psDevInfo;
 
 	PVR_UNREFERENCED_PARAMETER(ui32SwapInterval);
 	PVR_UNREFERENCED_PARAMETER(hPrivateTag);
 	PVR_UNREFERENCED_PARAMETER(psClipRect);
 
-	if (!hDevice || !hBuffer || (ui32ClipRectCount != 0)) {
+	if (!hDevice || !hBuffer || (ui32ClipRectCount != 0))
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
-	psDevInfo = (OMAPLFB_DEVINFO *) hDevice;
+	psDevInfo = (struct OMAPLFB_DEVINFO *)hDevice;
 
 	PVR_UNREFERENCED_PARAMETER(hBuffer);
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR SwapToDCSystem(IMG_HANDLE hDevice, IMG_HANDLE hSwapChain)
+static enum PVRSRV_ERROR SwapToDCSystem(void *hDevice, void *hSwapChain)
 {
-	OMAPLFB_DEVINFO *psDevInfo;
-	OMAPLFB_SWAPCHAIN *psSwapChain;
+	struct OMAPLFB_DEVINFO *psDevInfo;
+	struct OMAPLFB_SWAPCHAIN *psSwapChain;
 	unsigned long ulLockFlags;
 
-	if (!hDevice || !hSwapChain) {
+	if (!hDevice || !hSwapChain)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
-	psDevInfo = (OMAPLFB_DEVINFO *) hDevice;
-	psSwapChain = (OMAPLFB_SWAPCHAIN *) hSwapChain;
-	if (psSwapChain != psDevInfo->psSwapChain) {
+	psDevInfo = (struct OMAPLFB_DEVINFO *)hDevice;
+	psSwapChain = (struct OMAPLFB_SWAPCHAIN *)hSwapChain;
+	if (psSwapChain != psDevInfo->psSwapChain)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
 	spin_lock_irqsave(&psDevInfo->SwapChainLock, ulLockFlags);
 
@@ -792,11 +740,11 @@
 	return PVRSRV_OK;
 }
 
-IMG_BOOL OMAPLFBVSyncIHandler(OMAPLFB_SWAPCHAIN * psSwapChain)
+IMG_BOOL OMAPLFBVSyncIHandler(struct OMAPLFB_SWAPCHAIN *psSwapChain)
 {
 	IMG_BOOL bStatus = IMG_FALSE;
-	OMAPLFB_VSYNC_FLIP_ITEM *psFlipItem;
-	IMG_UINT32 ui32MaxIndex;
+	struct OMAPLFB_VSYNC_FLIP_ITEM *psFlipItem;
+	u32 ui32MaxIndex;
 	unsigned long ulLockFlags;
 
 	psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ui32RemoveIndex];
@@ -804,9 +752,8 @@
 
 	spin_lock_irqsave(psSwapChain->psSwapChainLock, ulLockFlags);
 
-	if (psSwapChain->bFlushCommands) {
+	if (psSwapChain->bFlushCommands)
 		goto ExitUnlock;
-	}
 
 	while (psFlipItem->bValid) {
 
@@ -828,9 +775,9 @@
 
 				psSwapChain->ui32RemoveIndex++;
 
-				if (psSwapChain->ui32RemoveIndex > ui32MaxIndex) {
+				if (psSwapChain->ui32RemoveIndex >
+								ui32MaxIndex)
 					psSwapChain->ui32RemoveIndex = 0;
-				}
 
 				psFlipItem->bCmdCompleted = IMG_FALSE;
 				psFlipItem->bFlipped = IMG_FALSE;
@@ -843,7 +790,7 @@
 		} else {
 
 			OMAPLFBFlip(psSwapChain,
-				    (IMG_UINT32) psFlipItem->sSysAddr);
+				    (u32) psFlipItem->sSysAddr);
 
 			psFlipItem->bFlipped = IMG_TRUE;
 
@@ -860,31 +807,28 @@
 	return bStatus;
 }
 
-static IMG_BOOL ProcessFlip(IMG_HANDLE hCmdCookie,
-			    IMG_UINT32 ui32DataSize, IMG_VOID * pvData)
+static IMG_BOOL ProcessFlip(void *hCmdCookie, u32 ui32DataSize, void *pvData)
 {
-	DISPLAYCLASS_FLIP_COMMAND *psFlipCmd;
-	OMAPLFB_DEVINFO *psDevInfo;
-	OMAPLFB_BUFFER *psBuffer;
-	OMAPLFB_SWAPCHAIN *psSwapChain;
-	OMAPLFB_VSYNC_FLIP_ITEM *psFlipItem;
+	struct DISPLAYCLASS_FLIP_COMMAND *psFlipCmd;
+	struct OMAPLFB_DEVINFO *psDevInfo;
+	struct OMAPLFB_BUFFER *psBuffer;
+	struct OMAPLFB_SWAPCHAIN *psSwapChain;
+	struct OMAPLFB_VSYNC_FLIP_ITEM *psFlipItem;
 	unsigned long ulLockFlags;
 
-	if (!hCmdCookie || !pvData) {
+	if (!hCmdCookie || !pvData)
 		return IMG_FALSE;
-	}
 
-	psFlipCmd = (DISPLAYCLASS_FLIP_COMMAND *) pvData;
+	psFlipCmd = (struct DISPLAYCLASS_FLIP_COMMAND *)pvData;
 
-	if (psFlipCmd == IMG_NULL
-	    || sizeof(DISPLAYCLASS_FLIP_COMMAND) != ui32DataSize) {
+	if (psFlipCmd == NULL
+	    || sizeof(struct DISPLAYCLASS_FLIP_COMMAND) != ui32DataSize)
 		return IMG_FALSE;
-	}
 
-	psDevInfo = (OMAPLFB_DEVINFO *) psFlipCmd->hExtDevice;
+	psDevInfo = (struct OMAPLFB_DEVINFO *)psFlipCmd->hExtDevice;
 
-	psBuffer = (OMAPLFB_BUFFER *) psFlipCmd->hExtBuffer;
-	psSwapChain = (OMAPLFB_SWAPCHAIN *) psFlipCmd->hExtSwapChain;
+	psBuffer = (struct OMAPLFB_BUFFER *)psFlipCmd->hExtBuffer;
+	psSwapChain = (struct OMAPLFB_SWAPCHAIN *)psFlipCmd->hExtSwapChain;
 
 	spin_lock_irqsave(&psDevInfo->SwapChainLock, ulLockFlags);
 
@@ -907,7 +851,7 @@
 	psFlipItem = &psSwapChain->psVSyncFlips[psSwapChain->ui32InsertIndex];
 
 	if (!psFlipItem->bValid) {
-		IMG_UINT32 ui32MaxIndex = psSwapChain->ui32BufferCount - 1;
+		u32 ui32MaxIndex = psSwapChain->ui32BufferCount - 1;
 
 		if (psSwapChain->ui32InsertIndex ==
 		    psSwapChain->ui32RemoveIndex) {
@@ -925,9 +869,8 @@
 		psFlipItem->bValid = IMG_TRUE;
 
 		psSwapChain->ui32InsertIndex++;
-		if (psSwapChain->ui32InsertIndex > ui32MaxIndex) {
+		if (psSwapChain->ui32InsertIndex > ui32MaxIndex)
 			psSwapChain->ui32InsertIndex = 0;
-		}
 
 		goto ExitTrueUnlock;
 	}
@@ -940,9 +883,9 @@
 	return IMG_TRUE;
 }
 
-static void SetDevinfo(OMAPLFB_DEVINFO * psDevInfo)
+static void SetDevinfo(struct OMAPLFB_DEVINFO *psDevInfo)
 {
-	OMAPLFB_FBINFO *psPVRFBInfo = &psDevInfo->sFBInfo;
+	struct OMAPLFB_FBINFO *psPVRFBInfo = &psDevInfo->sFBInfo;
 	struct fb_info *psLINFBInfo = psDevInfo->psLINFBInfo;
 	unsigned long FBSize;
 
@@ -983,19 +926,19 @@
 	psPVRFBInfo->ui32RoundedBufferSize =
 	    OMAPLFB_PAGE_ROUNDUP(psPVRFBInfo->ui32BufferSize);
 
-	if (psLINFBInfo->var.bits_per_pixel == 16) {
+	if (psLINFBInfo->var.bits_per_pixel == 16)
 		if ((psLINFBInfo->var.red.length == 5) &&
 		    (psLINFBInfo->var.green.length == 6) &&
 		    (psLINFBInfo->var.blue.length == 5) &&
 		    (psLINFBInfo->var.red.offset == 11) &&
 		    (psLINFBInfo->var.green.offset == 5) &&
 		    (psLINFBInfo->var.blue.offset == 0) &&
-		    (psLINFBInfo->var.red.msb_right == 0)) {
+		    (psLINFBInfo->var.red.msb_right == 0))
 			psPVRFBInfo->ePixelFormat = PVRSRV_PIXEL_FORMAT_RGB565;
-		} else {
+		else
 			printk("Unknown FB format\n");
-		}
-	} else if (psLINFBInfo->var.bits_per_pixel == 32) {
+	else
+	if (psLINFBInfo->var.bits_per_pixel == 32)
 		if ((psLINFBInfo->var.red.length == 8) &&
 		    (psLINFBInfo->var.green.length == 8) &&
 		    (psLINFBInfo->var.blue.length == 8) &&
@@ -1006,11 +949,11 @@
 			psPVRFBInfo->ePixelFormat =
 			    PVRSRV_PIXEL_FORMAT_ARGB8888;
 		} else {
-			printk("Unknown FB format\n");
+			printk(KERN_ERR "Unknown FB format\n");
 		}
-	} else {
-		printk("Unknown FB format\n");
-	}
+	else
+		printk(KERN_ERR "Unknown FB format\n");
+
 	psDevInfo->sDisplayFormat.pixelformat = psDevInfo->sFBInfo.ePixelFormat;
 	psDevInfo->sDisplayDim.ui32Width = psDevInfo->sFBInfo.ui32Width;
 	psDevInfo->sDisplayDim.ui32Height = psDevInfo->sFBInfo.ui32Height;
@@ -1024,7 +967,7 @@
 
 static struct FB_EVENTS {
 	struct notifier_block notif;
-	OMAPLFB_DEVINFO *psDevInfo;
+	struct OMAPLFB_DEVINFO *psDevInfo;
 } gFBEventsData;
 
 static int FBEvents(struct notifier_block *psNotif,
@@ -1038,12 +981,12 @@
 	return 0;
 }
 
-static PVRSRV_ERROR InitDev(OMAPLFB_DEVINFO * psDevInfo)
+static enum PVRSRV_ERROR InitDev(struct OMAPLFB_DEVINFO *psDevInfo)
 {
 	struct fb_info *psLINFBInfo;
 	struct module *psLINFBOwner;
-	OMAPLFB_FBINFO *psPVRFBInfo = &psDevInfo->sFBInfo;
-	PVRSRV_ERROR eError = PVRSRV_ERROR_GENERIC;
+	struct OMAPLFB_FBINFO *psPVRFBInfo = &psDevInfo->sFBInfo;
+	enum PVRSRV_ERROR eError = PVRSRV_ERROR_GENERIC;
 
 	acquire_console_sem();
 
@@ -1095,7 +1038,7 @@
 	return eError;
 }
 
-static IMG_VOID DeInitDev(OMAPLFB_DEVINFO * psDevInfo)
+static void DeInitDev(struct OMAPLFB_DEVINFO *psDevInfo)
 {
 	struct fb_info *psLINFBInfo = psDevInfo->psLINFBInfo;
 	struct module *psLINFBOwner;
@@ -1104,56 +1047,51 @@
 
 	psLINFBOwner = psLINFBInfo->fbops->owner;
 
-	if (psLINFBInfo->fbops->fb_release != NULL) {
+	if (psLINFBInfo->fbops->fb_release != NULL)
 		(void)psLINFBInfo->fbops->fb_release(psLINFBInfo, 0);
-	}
 
 	module_put(psLINFBOwner);
 
 	release_console_sem();
 }
 
-PVRSRV_ERROR OMAPLFBInit(IMG_VOID)
+enum PVRSRV_ERROR OMAPLFBInit(void)
 {
-	OMAPLFB_DEVINFO *psDevInfo;
+	struct OMAPLFB_DEVINFO *psDevInfo;
 
 	psDevInfo = GetAnchorPtr();
 
-	if (psDevInfo == IMG_NULL) {
-		PFN_CMD_PROC pfnCmdProcList[OMAPLFB_COMMAND_COUNT];
-		IMG_UINT32 aui32SyncCountList[OMAPLFB_COMMAND_COUNT][2];
-
-		psDevInfo =
-		    (OMAPLFB_DEVINFO *)
-		    OMAPLFBAllocKernelMem(sizeof(OMAPLFB_DEVINFO));
+	if (psDevInfo == NULL) {
+		IMG_BOOL (*pfnCmdProcList[OMAPLFB_COMMAND_COUNT])
+							(void *, u32, void *);
+		u32 aui32SyncCountList[OMAPLFB_COMMAND_COUNT][2];
+
+		psDevInfo = (struct OMAPLFB_DEVINFO *)
+			  OMAPLFBAllocKernelMem(sizeof(struct OMAPLFB_DEVINFO));
 
-		if (!psDevInfo) {
+		if (!psDevInfo)
 			return PVRSRV_ERROR_OUT_OF_MEMORY;
-		}
 
-		memset(psDevInfo, 0, sizeof(OMAPLFB_DEVINFO));
+		memset(psDevInfo, 0, sizeof(struct OMAPLFB_DEVINFO));
 
-		SetAnchorPtr((IMG_VOID *) psDevInfo);
+		SetAnchorPtr((void *) psDevInfo);
 
 		psDevInfo->ui32RefCount = 0;
 
-		if (InitDev(psDevInfo) != PVRSRV_OK) {
+		if (InitDev(psDevInfo) != PVRSRV_OK)
 			return PVRSRV_ERROR_INIT_FAILURE;
-		}
 
 		if (OMAPLFBGetLibFuncAddr
 		    ("PVRGetDisplayClassJTable",
-		     &pfnGetPVRJTable) != PVRSRV_OK) {
+		     &pfnGetPVRJTable) != PVRSRV_OK)
 			return PVRSRV_ERROR_INIT_FAILURE;
-		}
 
-		if (!(*pfnGetPVRJTable) (&psDevInfo->sPVRJTable)) {
+		if (!(*pfnGetPVRJTable) (&psDevInfo->sPVRJTable))
 			return PVRSRV_ERROR_INIT_FAILURE;
-		}
 
 		spin_lock_init(&psDevInfo->SwapChainLock);
 
-		psDevInfo->psSwapChain = IMG_NULL;
+		psDevInfo->psSwapChain = NULL;
 		psDevInfo->bFlushCommands = IMG_FALSE;
 		psDevInfo->bDeviceSuspended = IMG_FALSE;
 
@@ -1173,11 +1111,11 @@
 			DISPLAY_DEVICE_NAME, MAX_DISPLAY_NAME_SIZE);
 
 		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-			      ": Maximum number of swap chain buffers: %lu\n",
+			      ": Maximum number of swap chain buffers: %u\n",
 			      psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers));
 
 		psDevInfo->sDCJTable.ui32TableSize =
-		    sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE);
+		    sizeof(struct PVRSRV_DC_SRV2DISP_KMJTABLE);
 		psDevInfo->sDCJTable.pfnOpenDCDevice = OpenDCDevice;
 		psDevInfo->sDCJTable.pfnCloseDCDevice = CloseDCDevice;
 		psDevInfo->sDCJTable.pfnEnumDCFormats = EnumDCFormats;
@@ -1199,9 +1137,8 @@
 		if (psDevInfo->sPVRJTable.
 		    pfnPVRSRVRegisterDCDevice(&psDevInfo->sDCJTable,
 					      &psDevInfo->ui32DeviceID) !=
-		    PVRSRV_OK) {
+		    PVRSRV_OK)
 			return PVRSRV_ERROR_DEVICE_REGISTER_FAILED;
-		}
 
 		pfnCmdProcList[DC_FLIP_COMMAND] = ProcessFlip;
 
@@ -1227,65 +1164,59 @@
 
 }
 
-PVRSRV_ERROR OMAPLFBDeinit(IMG_VOID)
+enum PVRSRV_ERROR OMAPLFBDeinit(void)
 {
-	OMAPLFB_DEVINFO *psDevInfo, *psDevFirst;
+	struct OMAPLFB_DEVINFO *psDevInfo, *psDevFirst;
 
 	psDevFirst = GetAnchorPtr();
 	psDevInfo = psDevFirst;
 
-	if (psDevInfo == IMG_NULL) {
+	if (psDevInfo == NULL)
 		return PVRSRV_ERROR_GENERIC;
-	}
 
 	psDevInfo->ui32RefCount--;
 
 	if (psDevInfo->ui32RefCount == 0) {
-
-		PVRSRV_DC_DISP2SRV_KMJTABLE *psJTable = &psDevInfo->sPVRJTable;
-
+		struct PVRSRV_DC_DISP2SRV_KMJTABLE *psJTable =
+							&psDevInfo->sPVRJTable;
 		if (psDevInfo->sPVRJTable.
 		    pfnPVRSRVRemoveCmdProcList(psDevInfo->ui32DeviceID,
 					       OMAPLFB_COMMAND_COUNT) !=
-		    PVRSRV_OK) {
+		    PVRSRV_OK)
 			return PVRSRV_ERROR_GENERIC;
-		}
 
 		if (psJTable->
 		    pfnPVRSRVRemoveDCDevice(psDevInfo->ui32DeviceID) !=
-		    PVRSRV_OK) {
+		    PVRSRV_OK)
 			return PVRSRV_ERROR_GENERIC;
-		}
 
 		DeInitDev(psDevInfo);
 
 		OMAPLFBFreeKernelMem(psDevInfo);
 	}
 
-	SetAnchorPtr(IMG_NULL);
+	SetAnchorPtr(NULL);
 
 	return PVRSRV_OK;
 }
 
-IMG_VOID OMAPLFBDriverSuspend(IMG_VOID)
+void OMAPLFBDriverSuspend(void)
 {
-	OMAPLFB_DEVINFO *psDevInfo = GetAnchorPtr();
+	struct OMAPLFB_DEVINFO *psDevInfo = GetAnchorPtr();
 	unsigned long ulLockFlags;
 
 	spin_lock_irqsave(&psDevInfo->SwapChainLock, ulLockFlags);
 
-	if (psDevInfo->bDeviceSuspended) {
+	if (psDevInfo->bDeviceSuspended)
 		goto ExitUnlock;
-	}
 	psDevInfo->bDeviceSuspended = IMG_TRUE;
 
 	SetFlushStateInternalNoLock(psDevInfo, IMG_TRUE);
 
 	spin_unlock_irqrestore(&psDevInfo->SwapChainLock, ulLockFlags);
 
-	if (psDevInfo->psSwapChain != IMG_NULL) {
+	if (psDevInfo->psSwapChain != NULL)
 		OMAPLFBDisableDisplayRegisterAccess();
-	}
 
 	return;
 
@@ -1293,18 +1224,16 @@
 	spin_unlock_irqrestore(&psDevInfo->SwapChainLock, ulLockFlags);
 }
 
-IMG_VOID OMAPLFBDriverResume(IMG_VOID)
+void OMAPLFBDriverResume(void)
 {
-	OMAPLFB_DEVINFO *psDevInfo = GetAnchorPtr();
+	struct OMAPLFB_DEVINFO *psDevInfo = GetAnchorPtr();
 	unsigned long ulLockFlags;
 
-	if (!psDevInfo->bDeviceSuspended) {
+	if (!psDevInfo->bDeviceSuspended)
 		return;
-	}
 
-	if (psDevInfo->psSwapChain != IMG_NULL) {
+	if (psDevInfo->psSwapChain != NULL)
 		OMAPLFBEnableDisplayRegisterAccess();
-	}
 
 	spin_lock_irqsave(&psDevInfo->SwapChainLock, ulLockFlags);
 
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/omaplfb_linux.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/omaplfb_linux.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -32,14 +32,14 @@
 #include <linux/module.h>
 
 #include <linux/pci.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <linux/slab.h>
 #include <linux/errno.h>
 #include <linux/interrupt.h>
 
 #include <linux/platform_device.h>
 
-#include <asm/io.h>
+#include <linux/io.h>
 
 /*#include <asm/arch-omap/display.h>*/
 
@@ -53,23 +53,20 @@
 
 MODULE_SUPPORTED_DEVICE(DEVNAME);
 
-extern int omap_dispc_request_irq(unsigned long, void (*)(void *), void *);
-extern void omap_dispc_free_irq(unsigned long, void (*)(void *), void *);
-
 #define unref__ __attribute__ ((unused))
 
-IMG_VOID *OMAPLFBAllocKernelMem(IMG_UINT32 ui32Size)
+void *OMAPLFBAllocKernelMem(u32 ui32Size)
 {
 	return kmalloc(ui32Size, GFP_KERNEL);
 }
 
-IMG_VOID OMAPLFBFreeKernelMem(IMG_VOID * pvMem)
+void OMAPLFBFreeKernelMem(void *pvMem)
 {
 	kfree(pvMem);
 }
 
-PVRSRV_ERROR OMAPLFBGetLibFuncAddr(IMG_CHAR * szFunctionName,
-				   PFN_DC_GET_PVRJTABLE * ppfnFuncTable)
+enum PVRSRV_ERROR OMAPLFBGetLibFuncAddr(char *szFunctionName,
+	       IMG_BOOL (**ppfnFuncTable)(struct PVRSRV_DC_DISP2SRV_KMJTABLE *))
 {
 	if (strcmp("PVRGetDisplayClassJTable", szFunctionName) != 0)
 		return PVRSRV_ERROR_INVALID_PARAMS;
@@ -79,21 +76,21 @@
 	return PVRSRV_OK;
 }
 
-IMG_VOID OMAPLFBEnableVSyncInterrupt(OMAPLFB_SWAPCHAIN * psSwapChain)
+void OMAPLFBEnableVSyncInterrupt(struct OMAPLFB_SWAPCHAIN *psSwapChain)
 {
 }
 
-IMG_VOID OMAPLFBDisableVSyncInterrupt(OMAPLFB_SWAPCHAIN * psSwapChain)
+void OMAPLFBDisableVSyncInterrupt(struct OMAPLFB_SWAPCHAIN *psSwapChain)
 {
 }
 
 static void OMAPLFBVSyncISR(void *arg, u32 mask)
 {
-	(void)OMAPLFBVSyncIHandler((OMAPLFB_SWAPCHAIN *) arg);
+	(void)OMAPLFBVSyncIHandler((struct OMAPLFB_SWAPCHAIN *)arg);
 }
 
 
-PVRSRV_ERROR OMAPLFBInstallVSyncISR(OMAPLFB_SWAPCHAIN * psSwapChain)
+enum PVRSRV_ERROR OMAPLFBInstallVSyncISR(struct OMAPLFB_SWAPCHAIN *psSwapChain)
 {
 	if (omap_dispc_register_isr
 	    (OMAPLFBVSyncISR, psSwapChain, DISPC_IRQ_VSYNC) != 0)
@@ -102,28 +99,29 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR OMAPLFBUninstallVSyncISR(OMAPLFB_SWAPCHAIN * psSwapChain)
+enum PVRSRV_ERROR OMAPLFBUninstallVSyncISR(
+					struct OMAPLFB_SWAPCHAIN *psSwapChain)
 {
 	omap_dispc_unregister_isr(OMAPLFBVSyncISR, psSwapChain,
 				  DISPC_IRQ_VSYNC);
 	return PVRSRV_OK;
 }
 
-IMG_VOID OMAPLFBEnableDisplayRegisterAccess(IMG_VOID)
+void OMAPLFBEnableDisplayRegisterAccess(void)
 {
 	printk(KERN_WARNING DRIVER_PREFIX
 	       ": Attempting to call OMAPLFBEnableDisplayRegisterAccess\n");
 	/*omap2_disp_get_dss(); */
 }
 
-IMG_VOID OMAPLFBDisableDisplayRegisterAccess(IMG_VOID)
+void OMAPLFBDisableDisplayRegisterAccess(void)
 {
 	printk(KERN_WARNING DRIVER_PREFIX
 	       ": Attempting to call OMAPLFBDisableDisplayRegisterAccess\n");
 	/*omap2_disp_put_dss(); */
 }
 
-IMG_VOID OMAPLFBFlip(OMAPLFB_SWAPCHAIN * psSwapChain, IMG_UINT32 aPhyAddr)
+void OMAPLFBFlip(struct OMAPLFB_SWAPCHAIN *psSwapChain, u32 aPhyAddr)
 {
 	omap_dispc_set_plane_ba0(OMAP_DSS_CHANNEL_LCD, OMAP_DSS_GFX, aPhyAddr);
 }
@@ -133,17 +131,16 @@
 
 static void OMAPLFBCommonSuspend(void)
 {
-	if (bDeviceSuspended) {
+	if (bDeviceSuspended)
 		return;
-	}
 
 	OMAPLFBDriverSuspend();
 
 	bDeviceSuspended = IMG_TRUE;
 }
 
-static int OMAPLFBDriverSuspend_Entry(struct platform_device unref__ * pDevice,
-				      pm_message_t unref__ state)
+static int OMAPLFBDriverSuspend_Entry(struct platform_device *unref__ pDevice,
+				      pm_message_t state unref__)
 {
 	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
 		      ": OMAPLFBDriverSuspend_Entry\n"));
@@ -153,7 +150,7 @@
 	return 0;
 }
 
-static int OMAPLFBDriverResume_Entry(struct platform_device unref__ * pDevice)
+static int OMAPLFBDriverResume_Entry(struct platform_device *unref__ pDevice)
 {
 	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX ": OMAPLFBDriverResume_Entry\n"));
 
@@ -164,8 +161,7 @@
 	return 0;
 }
 
-static void OMAPLFBDriverShutdown_Entry(struct platform_device unref__ *
-					pDevice)
+static void OMAPLFBDriverShutdown_Entry(struct platform_device *unref__ pDevice)
 {
 	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
 		      ": OMAPLFBDriverShutdown_Entry\n"));
@@ -173,7 +169,7 @@
 	OMAPLFBCommonSuspend();
 }
 
-static void OMAPLFBDeviceRelease_Entry(struct device unref__ * pDevice)
+static void OMAPLFBDeviceRelease_Entry(struct device *unref__ pDevice)
 {
 	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
 		      ": OMAPLFBDriverRelease_Entry\n"));
@@ -206,17 +202,19 @@
 		       ": OMAPLFB_Init: OMAPLFBInit failed\n");
 		return -ENODEV;
 	}
-	if ((error = platform_driver_register(&omaplfb_driver)) != 0) {
-		printk(KERN_WARNING DRIVER_PREFIX
-		       ": OMAPLFB_Init: Unable to register platform driver (%d)\n",
+	error = platform_driver_register(&omaplfb_driver);
+	if (error != 0) {
+		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Init: "
+				"Unable to register platform driver (%d)\n",
 		       error);
 
 		goto ExitDeinit;
 	}
 
-	if ((error = platform_device_register(&omaplfb_device)) != 0) {
-		printk(KERN_WARNING DRIVER_PREFIX
-		       ": OMAPLFB_Init:  Unable to register platform device (%d)\n",
+	error = platform_device_register(&omaplfb_device);
+	if (error != 0) {
+		printk(KERN_WARNING DRIVER_PREFIX ": OMAPLFB_Init:  "
+				"Unable to register platform device (%d)\n",
 		       error);
 
 		goto ExitDriverUnregister;
@@ -228,10 +226,9 @@
 	platform_driver_unregister(&omaplfb_driver);
 
 ExitDeinit:
-	if (OMAPLFBDeinit() != PVRSRV_OK) {
+	if (OMAPLFBDeinit() != PVRSRV_OK)
 		printk(KERN_WARNING DRIVER_PREFIX
 		       ": OMAPLFB_Init: OMAPLFBDeinit failed\n");
-	}
 
 	return -ENODEV;
 }
@@ -241,10 +238,9 @@
 	platform_device_unregister(&omaplfb_device);
 	platform_driver_unregister(&omaplfb_driver);
 
-	if (OMAPLFBDeinit() != PVRSRV_OK) {
+	if (OMAPLFBDeinit() != PVRSRV_OK)
 		printk(KERN_WARNING DRIVER_PREFIX
 		       ": OMAPLFB_Cleanup: OMAPLFBDeinit failed\n");
-	}
 }
 
 module_init(OMAPLFB_Init);
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/osfunc.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/osfunc.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -29,7 +29,7 @@
 #endif
 
 #include <linux/version.h>
-#include <asm/io.h>
+#include <linux/io.h>
 #include <asm/page.h>
 #include <asm/system.h>
 #include <linux/mm.h>
@@ -43,10 +43,10 @@
 #include <linux/string.h>
 #include <linux/sched.h>
 #include <linux/interrupt.h>
-#include <asm/hardirq.h>
+#include <linux/hardirq.h>
 #include <linux/timer.h>
 #include <linux/capability.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #include "img_types.h"
 #include "services_headers.h"
@@ -60,23 +60,21 @@
 
 #define EVENT_OBJECT_TIMEOUT_MS		(100)
 
-extern PVRSRV_LINUX_MUTEX gPVRSRVLock;
-
-#define HOST_ALLOC_MEM_USING_KMALLOC ((IMG_HANDLE)0)
-#define HOST_ALLOC_MEM_USING_VMALLOC ((IMG_HANDLE)1)
+#define HOST_ALLOC_MEM_USING_KMALLOC ((void *)0)
+#define HOST_ALLOC_MEM_USING_VMALLOC ((void *)1)
 
 #define LINUX_KMALLOC_LIMIT	PAGE_SIZE	/* 4k */
 
 #if !defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-PVRSRV_ERROR OSAllocMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size,
-			IMG_PVOID * ppvCpuVAddr, IMG_HANDLE * phBlockAlloc)
+enum PVRSRV_ERROR OSAllocMem(u32 ui32Flags, u32 ui32Size,
+			void **ppvCpuVAddr, void **phBlockAlloc)
 #else
-PVRSRV_ERROR _OSAllocMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size,
-			 IMG_PVOID * ppvCpuVAddr, IMG_HANDLE * phBlockAlloc,
-			 IMG_CHAR * pszFilename, IMG_UINT32 ui32Line)
+enum PVRSRV_ERROR _OSAllocMem(u32 ui32Flags, u32 ui32Size,
+			 void **ppvCpuVAddr, void **phBlockAlloc,
+			 char *pszFilename, u32 ui32Line)
 #endif
 {
-	IMG_UINT32 ui32Threshold;
+	u32 ui32Threshold;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Flags);
 
@@ -116,12 +114,12 @@
 }
 
 #if !defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-PVRSRV_ERROR OSFreeMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size,
-		       IMG_PVOID pvCpuVAddr, IMG_HANDLE hBlockAlloc)
+void OSFreeMem(u32 ui32Flags, u32 ui32Size,
+		       void *pvCpuVAddr, void *hBlockAlloc)
 #else
-PVRSRV_ERROR _OSFreeMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size,
-			IMG_PVOID pvCpuVAddr, IMG_HANDLE hBlockAlloc,
-			IMG_CHAR * pszFilename, IMG_UINT32 ui32Line)
+void _OSFreeMem(u32 ui32Flags, u32 ui32Size,
+			void *pvCpuVAddr, void *hBlockAlloc,
+			char *pszFilename, u32 ui32Line)
 #endif
 {
 	PVR_UNREFERENCED_PARAMETER(ui32Flags);
@@ -139,16 +137,13 @@
 		KFreeWrapper(pvCpuVAddr);
 #endif
 	}
-
-	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR
-OSAllocPages(IMG_UINT32 ui32AllocFlags,
-	     IMG_UINT32 ui32Size,
-	     IMG_VOID ** ppvCpuVAddr, IMG_HANDLE * phOSMemHandle)
+enum PVRSRV_ERROR OSAllocPages(u32 ui32AllocFlags,
+	     u32 ui32Size,
+	     void **ppvCpuVAddr, void **phOSMemHandle)
 {
-	LinuxMemArea *psLinuxMemArea;
+	struct LinuxMemArea *psLinuxMemArea;
 
 
 	switch (ui32AllocFlags & PVRSRV_HAP_MAPTYPE_MASK) {
@@ -156,9 +151,8 @@
 		{
 			psLinuxMemArea =
 			    NewVMallocLinuxMemArea(ui32Size, ui32AllocFlags);
-			if (!psLinuxMemArea) {
+			if (!psLinuxMemArea)
 				return PVRSRV_ERROR_OUT_OF_MEMORY;
-			}
 			break;
 		}
 	case PVRSRV_HAP_SINGLE_PROCESS:
@@ -166,9 +160,8 @@
 
 			psLinuxMemArea =
 			    NewAllocPagesLinuxMemArea(ui32Size, ui32AllocFlags);
-			if (!psLinuxMemArea) {
+			if (!psLinuxMemArea)
 				return PVRSRV_ERROR_OUT_OF_MEMORY;
-			}
 			PVRMMapRegisterArea("Import Arena", psLinuxMemArea,
 					    ui32AllocFlags);
 			break;
@@ -178,18 +171,17 @@
 		{
 			psLinuxMemArea =
 			    NewVMallocLinuxMemArea(ui32Size, ui32AllocFlags);
-			if (!psLinuxMemArea) {
+			if (!psLinuxMemArea)
 				return PVRSRV_ERROR_OUT_OF_MEMORY;
-			}
 			PVRMMapRegisterArea("Import Arena", psLinuxMemArea,
 					    ui32AllocFlags);
 			break;
 		}
 	default:
-		PVR_DPF((PVR_DBG_ERROR, "OSAllocPages: invalid flags 0x%x\n",
-			 ui32AllocFlags));
+		PVR_DPF(PVR_DBG_ERROR, "OSAllocPages: invalid flags 0x%x\n",
+			 ui32AllocFlags);
 		*ppvCpuVAddr = NULL;
-		*phOSMemHandle = (IMG_HANDLE) 0;
+		*phOSMemHandle = (void *) 0;
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
@@ -201,14 +193,13 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR
-OSFreePages(IMG_UINT32 ui32AllocFlags, IMG_UINT32 ui32Bytes,
-	    IMG_VOID * pvCpuVAddr, IMG_HANDLE hOSMemHandle)
+enum PVRSRV_ERROR OSFreePages(u32 ui32AllocFlags, u32 ui32Bytes,
+	    void *pvCpuVAddr, void *hOSMemHandle)
 {
-	LinuxMemArea *psLinuxMemArea;
+	struct LinuxMemArea *psLinuxMemArea;
 	PVR_UNREFERENCED_PARAMETER(pvCpuVAddr);
 
-	psLinuxMemArea = (LinuxMemArea *) hOSMemHandle;
+	psLinuxMemArea = (struct LinuxMemArea *)hOSMemHandle;
 
 	switch (ui32AllocFlags & PVRSRV_HAP_MAPTYPE_MASK) {
 	case PVRSRV_HAP_KERNEL_ONLY:
@@ -216,17 +207,18 @@
 	case PVRSRV_HAP_SINGLE_PROCESS:
 	case PVRSRV_HAP_MULTI_PROCESS:
 		if (PVRMMapRemoveRegisteredArea(psLinuxMemArea) != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "OSFreePages(ui32AllocFlags=0x%08X, ui32Bytes=%ld, "
+			PVR_DPF(PVR_DBG_ERROR,
+				 "OSFreePages(ui32AllocFlags=0x%08X, "
+				 "ui32Bytes=%ld, "
 				 "pvCpuVAddr=%p, hOSMemHandle=%p) FAILED!",
 				 ui32AllocFlags, ui32Bytes, pvCpuVAddr,
-				 hOSMemHandle));
+				 hOSMemHandle);
 			return PVRSRV_ERROR_GENERIC;
 		}
 		break;
 	default:
-		PVR_DPF((PVR_DBG_ERROR, "%s: invalid flags 0x%x\n",
-			 __FUNCTION__, ui32AllocFlags));
+		PVR_DPF(PVR_DBG_ERROR, "%s: invalid flags 0x%x\n",
+			 __func__, ui32AllocFlags);
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
@@ -235,16 +227,15 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR
-OSGetSubMemHandle(IMG_HANDLE hOSMemHandle,
-		  IMG_UINT32 ui32ByteOffset,
-		  IMG_UINT32 ui32Bytes,
-		  IMG_UINT32 ui32Flags, IMG_HANDLE * phOSMemHandleRet)
+enum PVRSRV_ERROR OSGetSubMemHandle(void *hOSMemHandle,
+		  u32 ui32ByteOffset,
+		  u32 ui32Bytes,
+		  u32 ui32Flags, void **phOSMemHandleRet)
 {
-	LinuxMemArea *psParentLinuxMemArea, *psLinuxMemArea;
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	struct LinuxMemArea *psParentLinuxMemArea, *psLinuxMemArea;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
-	psParentLinuxMemArea = (LinuxMemArea *) hOSMemHandle;
+	psParentLinuxMemArea = (struct LinuxMemArea *)hOSMemHandle;
 
 	psLinuxMemArea =
 	    NewSubLinuxMemArea(psParentLinuxMemArea, ui32ByteOffset, ui32Bytes);
@@ -254,21 +245,18 @@
 	}
 	*phOSMemHandleRet = psLinuxMemArea;
 
-	if (ui32Flags & PVRSRV_HAP_KERNEL_ONLY) {
+	if (ui32Flags & PVRSRV_HAP_KERNEL_ONLY)
 		return PVRSRV_OK;
-	}
 
 	if (psParentLinuxMemArea->eAreaType == LINUX_MEM_AREA_IO) {
 		eError = PVRMMapRegisterArea("Physical", psLinuxMemArea, 0);
-		if (eError != PVRSRV_OK) {
+		if (eError != PVRSRV_OK)
 			goto failed_register_area;
-		}
 	} else if (psParentLinuxMemArea->eAreaType ==
 		   LINUX_MEM_AREA_ALLOC_PAGES) {
 		eError = PVRMMapRegisterArea("Import Arena", psLinuxMemArea, 0);
-		if (eError != PVRSRV_OK) {
+		if (eError != PVRSRV_OK)
 			goto failed_register_area;
-		}
 	}
 
 	return PVRSRV_OK;
@@ -279,13 +267,12 @@
 	return eError;
 }
 
-PVRSRV_ERROR
-OSReleaseSubMemHandle(IMG_VOID * hOSMemHandle, IMG_UINT32 ui32Flags)
+enum PVRSRV_ERROR OSReleaseSubMemHandle(void *hOSMemHandle, u32 ui32Flags)
 {
-	LinuxMemArea *psParentLinuxMemArea, *psLinuxMemArea;
-	PVRSRV_ERROR eError;
+	struct LinuxMemArea *psParentLinuxMemArea, *psLinuxMemArea;
+	enum PVRSRV_ERROR eError;
 
-	psLinuxMemArea = (LinuxMemArea *) hOSMemHandle;
+	psLinuxMemArea = (struct LinuxMemArea *)hOSMemHandle;
 	PVR_ASSERT(psLinuxMemArea->eAreaType == LINUX_MEM_AREA_SUB_ALLOC);
 
 	psParentLinuxMemArea =
@@ -297,43 +284,41 @@
 		LINUX_MEM_AREA_ALLOC_PAGES)
 	    ) {
 		eError = PVRMMapRemoveRegisteredArea(psLinuxMemArea);
-		if (eError != PVRSRV_OK) {
+		if (eError != PVRSRV_OK)
 			return eError;
-		}
 	}
 	LinuxMemAreaDeepFree(psLinuxMemArea);
 
 	return PVRSRV_OK;
 }
 
-IMG_CPU_PHYADDR
-OSMemHandleToCpuPAddr(IMG_VOID * hOSMemHandle, IMG_UINT32 ui32ByteOffset)
+struct IMG_CPU_PHYADDR OSMemHandleToCpuPAddr(void *hOSMemHandle,
+					     u32 ui32ByteOffset)
 {
 	PVR_ASSERT(hOSMemHandle);
 
 	return LinuxMemAreaToCpuPAddr(hOSMemHandle, ui32ByteOffset);
 }
 
-IMG_VOID OSMemCopy(IMG_VOID * pvDst, IMG_VOID * pvSrc, IMG_UINT32 ui32Size)
+void OSMemCopy(void *pvDst, void *pvSrc, u32 ui32Size)
 {
 	memcpy(pvDst, pvSrc, ui32Size);
 }
 
-IMG_VOID OSMemSet(IMG_VOID * pvDest, IMG_UINT8 ui8Value, IMG_UINT32 ui32Size)
+void OSMemSet(void *pvDest, u8 ui8Value, u32 ui32Size)
 {
 	memset(pvDest, (int)ui8Value, (size_t) ui32Size);
 }
 
-IMG_CHAR *OSStringCopy(IMG_CHAR * pszDest, const IMG_CHAR * pszSrc)
+char *OSStringCopy(char *pszDest, const char *pszSrc)
 {
-	return (strcpy(pszDest, pszSrc));
+	return strcpy(pszDest, pszSrc);
 }
 
-IMG_INT32 OSSNPrintf(IMG_CHAR * pStr, IMG_UINT32 ui32Size,
-		     const IMG_CHAR * pszFormat, ...)
+s32 OSSNPrintf(char *pStr, u32 ui32Size, const char *pszFormat, ...)
 {
 	va_list argList;
-	IMG_INT32 iCount;
+	s32 iCount;
 
 	va_start(argList, pszFormat);
 	iCount = vsnprintf(pStr, (size_t) ui32Size, pszFormat, argList);
@@ -342,26 +327,24 @@
 	return iCount;
 }
 
-IMG_VOID OSBreakResourceLock(PVRSRV_RESOURCE * psResource, IMG_UINT32 ui32ID)
+void OSBreakResourceLock(struct PVRSRV_RESOURCE *psResource, u32 ui32ID)
 {
-	volatile IMG_UINT32 *pui32Access =
-	    (volatile IMG_UINT32 *)&psResource->ui32Lock;
+	volatile u32 *pui32Access = (volatile u32 *)&psResource->ui32Lock;
 
-	if (*pui32Access) {
+	if (*pui32Access)
 		if (psResource->ui32ID == ui32ID) {
 			psResource->ui32ID = 0;
 			*pui32Access = 0;
 		} else {
-			PVR_DPF((PVR_DBG_MESSAGE,
-				 "OSBreakResourceLock: Resource is not locked for this process."));
+			PVR_DPF(PVR_DBG_MESSAGE, "OSBreakResourceLock: "
+				"Resource is not locked for this process.");
 		}
-	} else {
-		PVR_DPF((PVR_DBG_MESSAGE,
-			 "OSBreakResourceLock: Resource is not locked"));
-	}
+	else
+		PVR_DPF(PVR_DBG_MESSAGE,
+			 "OSBreakResourceLock: Resource is not locked");
 }
 
-PVRSRV_ERROR OSCreateResource(PVRSRV_RESOURCE * psResource)
+enum PVRSRV_ERROR OSCreateResource(struct PVRSRV_RESOURCE *psResource)
 {
 	psResource->ui32ID = 0;
 	psResource->ui32Lock = 0;
@@ -369,31 +352,28 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR OSDestroyResource(PVRSRV_RESOURCE * psResource)
+enum PVRSRV_ERROR OSDestroyResource(struct PVRSRV_RESOURCE *psResource)
 {
 	OSBreakResourceLock(psResource, psResource->ui32ID);
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR OSInitEnvData(IMG_PVOID * ppvEnvSpecificData)
+enum PVRSRV_ERROR OSInitEnvData(void **ppvEnvSpecificData)
 {
-	ENV_DATA *psEnvData;
+	struct ENV_DATA *psEnvData;
 
-	if (OSAllocMem
-	    (PVRSRV_OS_PAGEABLE_HEAP, sizeof(ENV_DATA),
-	     (IMG_VOID *) & psEnvData, IMG_NULL) != PVRSRV_OK) {
+	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct ENV_DATA),
+	     (void *)&psEnvData, NULL) != PVRSRV_OK)
 		return PVRSRV_ERROR_GENERIC;
-	}
 
 	memset(psEnvData, 0, sizeof(*psEnvData));
 
-	if (OSAllocMem
-	    (PVRSRV_OS_PAGEABLE_HEAP,
+	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 	     PVRSRV_MAX_BRIDGE_IN_SIZE + PVRSRV_MAX_BRIDGE_OUT_SIZE,
-	     &psEnvData->pvBridgeData, IMG_NULL) != PVRSRV_OK) {
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(ENV_DATA), psEnvData,
-			  IMG_NULL);
+	     &psEnvData->pvBridgeData, NULL) != PVRSRV_OK) {
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct ENV_DATA),
+			  psEnvData, NULL);
 		return PVRSRV_ERROR_GENERIC;
 	}
 
@@ -405,29 +385,29 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR OSDeInitEnvData(IMG_PVOID pvEnvSpecificData)
+enum PVRSRV_ERROR OSDeInitEnvData(void *pvEnvSpecificData)
 {
-	ENV_DATA *psEnvData = (ENV_DATA *) pvEnvSpecificData;
+	struct ENV_DATA *psEnvData = (struct ENV_DATA *)pvEnvSpecificData;
 
 	PVR_ASSERT(!psEnvData->bMISRInstalled);
 	PVR_ASSERT(!psEnvData->bLISRInstalled);
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
 		  PVRSRV_MAX_BRIDGE_IN_SIZE + PVRSRV_MAX_BRIDGE_OUT_SIZE,
-		  psEnvData->pvBridgeData, IMG_NULL);
+		  psEnvData->pvBridgeData, NULL);
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(ENV_DATA), pvEnvSpecificData,
-		  IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct ENV_DATA),
+		  pvEnvSpecificData, NULL);
 
 	return PVRSRV_OK;
 }
 
-IMG_VOID OSReleaseThreadQuanta(IMG_VOID)
+void OSReleaseThreadQuanta(void)
 {
 	schedule();
 }
 
-IMG_UINT32 OSClockus(IMG_VOID)
+u32 OSClockus(void)
 {
 	unsigned long time, j = jiffies;
 
@@ -436,41 +416,40 @@
 	return time;
 }
 
-IMG_VOID OSWaitus(IMG_UINT32 ui32Timeus)
+void OSWaitus(u32 ui32Timeus)
 {
 	udelay(ui32Timeus);
 }
 
-IMG_UINT32 OSGetCurrentProcessIDKM(IMG_VOID)
+u32 OSGetCurrentProcessIDKM(void)
 {
-	if (in_interrupt()) {
+	if (in_interrupt())
 		return KERNEL_ID;
-	}
 	return task_tgid_nr(current);
 }
 
-IMG_UINT32 OSGetPageSize(IMG_VOID)
+u32 OSGetPageSize(void)
 {
 	return PAGE_SIZE;
 }
 
-static irqreturn_t DeviceISRWrapper(int irq, void *dev_id
-    )
+static irqreturn_t DeviceISRWrapper(int irq, void *dev_id)
 {
-	PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
 	IMG_BOOL bStatus = IMG_FALSE;
 
-	psDeviceNode = (PVRSRV_DEVICE_NODE *) dev_id;
+	psDeviceNode = (struct PVRSRV_DEVICE_NODE *)dev_id;
 	if (!psDeviceNode) {
-		PVR_DPF((PVR_DBG_ERROR, "DeviceISRWrapper: invalid params\n"));
+		PVR_DPF(PVR_DBG_ERROR, "DeviceISRWrapper: invalid params\n");
 		goto out;
 	}
 
 	bStatus = PVRSRVDeviceLISR(psDeviceNode);
 
 	if (bStatus) {
-		SYS_DATA *psSysData = psDeviceNode->psSysData;
-		ENV_DATA *psEnvData = (ENV_DATA *) psSysData->pvEnvSpecificData;
+		struct SYS_DATA *psSysData = psDeviceNode->psSysData;
+		struct ENV_DATA *psEnvData =
+				(struct ENV_DATA *)psSysData->pvEnvSpecificData;
 
 		queue_work(psEnvData->psMISRWorkqueue, &psEnvData->sMISRWork);
 	}
@@ -479,53 +458,29 @@
 	return bStatus ? IRQ_HANDLED : IRQ_NONE;
 }
 
-static irqreturn_t SystemISRWrapper(int irq, void *dev_id
-    )
-{
-	SYS_DATA *psSysData;
-	IMG_BOOL bStatus = IMG_FALSE;
-
-	psSysData = (SYS_DATA *) dev_id;
-	if (!psSysData) {
-		PVR_DPF((PVR_DBG_ERROR, "SystemISRWrapper: invalid params\n"));
-		goto out;
-	}
-
-	bStatus = PVRSRVSystemLISR(psSysData);
-
-	if (bStatus) {
-		ENV_DATA *psEnvData = (ENV_DATA *) psSysData->pvEnvSpecificData;
-
-		queue_work(psEnvData->psMISRWorkqueue, &psEnvData->sMISRWork);
-	}
-
-out:
-	return bStatus ? IRQ_HANDLED : IRQ_NONE;
-}
-
-PVRSRV_ERROR OSInstallDeviceLISR(IMG_VOID * pvSysData,
-				 IMG_UINT32 ui32Irq,
-				 IMG_CHAR * pszISRName, IMG_VOID * pvDeviceNode)
-{
-	SYS_DATA *psSysData = (SYS_DATA *) pvSysData;
-	ENV_DATA *psEnvData = (ENV_DATA *) psSysData->pvEnvSpecificData;
+enum PVRSRV_ERROR OSInstallDeviceLISR(void *pvSysData,
+				 u32 ui32Irq,
+				 char *pszISRName, void *pvDeviceNode)
+{
+	struct SYS_DATA *psSysData = (struct SYS_DATA *)pvSysData;
+	struct ENV_DATA *psEnvData =
+			(struct ENV_DATA *)psSysData->pvEnvSpecificData;
 
 	if (psEnvData->bLISRInstalled) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "OSInstallDeviceLISR: An ISR has already been installed: IRQ %d cookie %x",
-			 psEnvData->ui32IRQ, psEnvData->pvISRCookie));
+		PVR_DPF(PVR_DBG_ERROR, "OSInstallDeviceLISR: "
+			"An ISR has already been installed: IRQ %d cookie %x",
+			psEnvData->ui32IRQ, psEnvData->pvISRCookie);
 		return PVRSRV_ERROR_GENERIC;
 	}
 
-	PVR_TRACE(("Installing device LISR %s on IRQ %d with cookie %x",
-		   pszISRName, ui32Irq, pvDeviceNode));
+	PVR_TRACE("Installing device LISR %s on IRQ %d with cookie %x",
+		   pszISRName, ui32Irq, pvDeviceNode);
 
-	if (request_irq(ui32Irq, DeviceISRWrapper,
-			IRQF_SHARED
-			, pszISRName, pvDeviceNode)) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "OSInstallDeviceLISR: Couldn't install device LISR on IRQ %d",
-			 ui32Irq));
+	if (request_irq(ui32Irq, DeviceISRWrapper, IRQF_SHARED, pszISRName,
+			pvDeviceNode)) {
+		PVR_DPF(PVR_DBG_ERROR, "OSInstallDeviceLISR: "
+				    "Couldn't install device LISR on IRQ %d",
+			 ui32Irq);
 
 		return PVRSRV_ERROR_GENERIC;
 	}
@@ -537,72 +492,20 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR OSUninstallDeviceLISR(IMG_VOID * pvSysData)
-{
-	SYS_DATA *psSysData = (SYS_DATA *) pvSysData;
-	ENV_DATA *psEnvData = (ENV_DATA *) psSysData->pvEnvSpecificData;
-
-	if (!psEnvData->bLISRInstalled) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "OSUninstallDeviceLISR: No LISR has been installed"));
-		return PVRSRV_ERROR_GENERIC;
-	}
-
-	PVR_TRACE(("Uninstalling device LISR on IRQ %d with cookie %x",
-		   psEnvData->ui32IRQ, psEnvData->pvISRCookie));
-
-	free_irq(psEnvData->ui32IRQ, psEnvData->pvISRCookie);
-
-	psEnvData->bLISRInstalled = IMG_FALSE;
-
-	return PVRSRV_OK;
-}
-
-PVRSRV_ERROR OSInstallSystemLISR(IMG_VOID * pvSysData, IMG_UINT32 ui32Irq)
-{
-	SYS_DATA *psSysData = (SYS_DATA *) pvSysData;
-	ENV_DATA *psEnvData = (ENV_DATA *) psSysData->pvEnvSpecificData;
-
-	if (psEnvData->bLISRInstalled) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "OSInstallSystemLISR: An LISR has already been installed: IRQ %d cookie %x",
-			 psEnvData->ui32IRQ, psEnvData->pvISRCookie));
-		return PVRSRV_ERROR_GENERIC;
-	}
-
-	PVR_TRACE(("Installing system LISR on IRQ %d with cookie %x", ui32Irq,
-		   pvSysData));
-
-	if (request_irq(ui32Irq, SystemISRWrapper,
-			IRQF_SHARED
-			, "PowerVR", pvSysData)) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "OSInstallSystemLISR: Couldn't install system LISR on IRQ %d",
-			 ui32Irq));
-
-		return PVRSRV_ERROR_GENERIC;
-	}
-
-	psEnvData->ui32IRQ = ui32Irq;
-	psEnvData->pvISRCookie = pvSysData;
-	psEnvData->bLISRInstalled = IMG_TRUE;
-
-	return PVRSRV_OK;
-}
-
-PVRSRV_ERROR OSUninstallSystemLISR(IMG_VOID * pvSysData)
+enum PVRSRV_ERROR OSUninstallDeviceLISR(void *pvSysData)
 {
-	SYS_DATA *psSysData = (SYS_DATA *) pvSysData;
-	ENV_DATA *psEnvData = (ENV_DATA *) psSysData->pvEnvSpecificData;
+	struct SYS_DATA *psSysData = (struct SYS_DATA *)pvSysData;
+	struct ENV_DATA *psEnvData =
+				(struct ENV_DATA *)psSysData->pvEnvSpecificData;
 
 	if (!psEnvData->bLISRInstalled) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "OSUninstallSystemLISR: No LISR has been installed"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "OSUninstallDeviceLISR: No LISR has been installed");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
-	PVR_TRACE(("Uninstalling system LISR on IRQ %d with cookie %x",
-		   psEnvData->ui32IRQ, psEnvData->pvISRCookie));
+	PVR_TRACE("Uninstalling device LISR on IRQ %d with cookie %x",
+		   psEnvData->ui32IRQ, psEnvData->pvISRCookie);
 
 	free_irq(psEnvData->ui32IRQ, psEnvData->pvISRCookie);
 
@@ -613,23 +516,25 @@
 
 static void MISRWrapper(struct work_struct *work)
 {
-	ENV_DATA *psEnvData = container_of(work, ENV_DATA, sMISRWork);
-	SYS_DATA *psSysData = (SYS_DATA *) psEnvData->pvSysData;
+	struct ENV_DATA *psEnvData = container_of(work, struct ENV_DATA,
+						  sMISRWork);
+	struct SYS_DATA *psSysData = (struct SYS_DATA *)psEnvData->pvSysData;
 	PVRSRVMISR(psSysData);
 }
 
-PVRSRV_ERROR OSInstallMISR(IMG_VOID * pvSysData)
+enum PVRSRV_ERROR OSInstallMISR(void *pvSysData)
 {
-	SYS_DATA *psSysData = (SYS_DATA *) pvSysData;
-	ENV_DATA *psEnvData = (ENV_DATA *) psSysData->pvEnvSpecificData;
+	struct SYS_DATA *psSysData = (struct SYS_DATA *)pvSysData;
+	struct ENV_DATA *psEnvData =
+				(struct ENV_DATA *)psSysData->pvEnvSpecificData;
 
 	if (psEnvData->bMISRInstalled) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "OSInstallMISR: An MISR has already been installed"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "OSInstallMISR: An MISR has already been installed");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
-	PVR_TRACE(("Installing MISR with cookie %x", pvSysData));
+	PVR_TRACE("Installing MISR with cookie %x", pvSysData);
 
 	psEnvData->pvSysData = pvSysData;
 	psEnvData->psMISRWorkqueue = create_singlethread_workqueue("sgx_misr");
@@ -640,18 +545,19 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR OSUninstallMISR(IMG_VOID * pvSysData)
+enum PVRSRV_ERROR OSUninstallMISR(void *pvSysData)
 {
-	SYS_DATA *psSysData = (SYS_DATA *) pvSysData;
-	ENV_DATA *psEnvData = (ENV_DATA *) psSysData->pvEnvSpecificData;
+	struct SYS_DATA *psSysData = (struct SYS_DATA *)pvSysData;
+	struct ENV_DATA *psEnvData =
+				(struct ENV_DATA *)psSysData->pvEnvSpecificData;
 
 	if (!psEnvData->bMISRInstalled) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "OSUninstallMISR: No MISR has been installed"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "OSUninstallMISR: No MISR has been installed");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
-	PVR_TRACE(("Uninstalling MISR"));
+	PVR_TRACE("Uninstalling MISR");
 
 	flush_workqueue(psEnvData->psMISRWorkqueue);
 	destroy_workqueue(psEnvData->psMISRWorkqueue);
@@ -661,23 +567,23 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR OSScheduleMISR(IMG_VOID * pvSysData)
+enum PVRSRV_ERROR OSScheduleMISR(void *pvSysData)
 {
-	SYS_DATA *psSysData = (SYS_DATA *) pvSysData;
-	ENV_DATA *psEnvData = (ENV_DATA *) psSysData->pvEnvSpecificData;
+	struct SYS_DATA *psSysData = (struct SYS_DATA *)pvSysData;
+	struct ENV_DATA *psEnvData =
+				(struct ENV_DATA *)psSysData->pvEnvSpecificData;
 
-	if (psEnvData->bMISRInstalled) {
+	if (psEnvData->bMISRInstalled)
 		queue_work(psEnvData->psMISRWorkqueue, &psEnvData->sMISRWork);
-	}
 
 	return PVRSRV_OK;
 }
 
 
 #define	OS_TAS(p)	xchg((p), 1)
-PVRSRV_ERROR OSLockResource(PVRSRV_RESOURCE * psResource, IMG_UINT32 ui32ID)
+enum PVRSRV_ERROR OSLockResource(struct PVRSRV_RESOURCE *psResource, u32 ui32ID)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
 	if (!OS_TAS(&psResource->ui32Lock))
 		psResource->ui32ID = ui32ID;
@@ -687,75 +593,62 @@
 	return eError;
 }
 
-PVRSRV_ERROR OSUnlockResource(PVRSRV_RESOURCE * psResource, IMG_UINT32 ui32ID)
+enum PVRSRV_ERROR OSUnlockResource(struct PVRSRV_RESOURCE *psResource,
+				   u32 ui32ID)
 {
-	volatile IMG_UINT32 *pui32Access =
-	    (volatile IMG_UINT32 *)&psResource->ui32Lock;
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	volatile u32 *pui32Access = (volatile u32 *)&psResource->ui32Lock;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
 	if (*pui32Access) {
 		if (psResource->ui32ID == ui32ID) {
 			psResource->ui32ID = 0;
 			*pui32Access = 0;
 		} else {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "OSUnlockResource: Resource %p is not locked with expected value.",
-				 psResource));
-			PVR_DPF((PVR_DBG_MESSAGE, "Should be %x is actually %x",
-				 ui32ID, psResource->ui32ID));
+			PVR_DPF(PVR_DBG_ERROR, "OSUnlockResource: "
+			       "Resource %p is not locked with expected value.",
+				psResource);
+			PVR_DPF(PVR_DBG_MESSAGE, "Should be %x is actually %x",
+				 ui32ID, psResource->ui32ID);
 			eError = PVRSRV_ERROR_GENERIC;
 		}
 	} else {
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "OSUnlockResource: Resource %p is not locked",
-			 psResource));
+			 psResource);
 		eError = PVRSRV_ERROR_GENERIC;
 	}
 
 	return eError;
 }
 
-IMG_BOOL OSIsResourceLocked(PVRSRV_RESOURCE * psResource, IMG_UINT32 ui32ID)
+struct IMG_CPU_PHYADDR OSMapLinToCPUPhys(void *pvLinAddr)
 {
-	volatile IMG_UINT32 *pui32Access =
-	    (volatile IMG_UINT32 *)&psResource->ui32Lock;
-
-	return (*(volatile IMG_UINT32 *)pui32Access == 1)
-	    && (psResource->ui32ID == ui32ID)
-	    ? IMG_TRUE : IMG_FALSE;
-}
+	struct IMG_CPU_PHYADDR CpuPAddr;
 
-IMG_CPU_PHYADDR OSMapLinToCPUPhys(IMG_VOID * pvLinAddr)
-{
-	IMG_CPU_PHYADDR CpuPAddr;
-
-	CpuPAddr.uiAddr = (IMG_UINTPTR_T) VMallocToPhys(pvLinAddr);
+	CpuPAddr.uiAddr = (u32) VMallocToPhys(pvLinAddr);
 
 	return CpuPAddr;
 }
 
-IMG_VOID *OSMapPhysToLin(IMG_CPU_PHYADDR BasePAddr,
-			 IMG_UINT32 ui32Bytes,
-			 IMG_UINT32 ui32MappingFlags,
-			 IMG_HANDLE * phOSMemHandle)
+void __iomem *OSMapPhysToLin(struct IMG_CPU_PHYADDR BasePAddr, u32 ui32Bytes,
+			 u32 ui32MappingFlags, void **phOSMemHandle)
 {
-	if (phOSMemHandle) {
-		*phOSMemHandle = (IMG_HANDLE) 0;
-	}
+	if (phOSMemHandle)
+		*phOSMemHandle = (void *) 0;
 
 	if (ui32MappingFlags & PVRSRV_HAP_KERNEL_ONLY) {
-		IMG_VOID *pvIORemapCookie;
+		void __iomem *pvIORemapCookie;
 		pvIORemapCookie =
 		    IORemapWrapper(BasePAddr, ui32Bytes, ui32MappingFlags);
-		if (pvIORemapCookie == IMG_NULL) {
+		if (pvIORemapCookie == NULL)
 			return NULL;
-		}
 		return pvIORemapCookie;
 	} else {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "OSMapPhysToLin should only be used with PVRSRV_HAP_KERNEL_ONLY "
-			 " (Use OSReservePhys otherwise)"));
-		*phOSMemHandle = (IMG_HANDLE) 0;
+		PVR_DPF(PVR_DBG_ERROR,
+			 "OSMapPhysToLin should only be used with "
+			 "PVRSRV_HAP_KERNEL_ONLY  "
+			 "(Use OSReservePhys otherwise)");
+		*phOSMemHandle = (void *) 0;
 		return NULL;
 	}
 
@@ -764,11 +657,11 @@
 }
 
 IMG_BOOL
-OSUnMapPhysToLin(IMG_VOID * pvLinAddr, IMG_UINT32 ui32Bytes,
-		 IMG_UINT32 ui32MappingFlags, IMG_HANDLE hPageAlloc)
+OSUnMapPhysToLin(void __iomem *pvLinAddr, u32 ui32Bytes,
+		 u32 ui32MappingFlags, void *hPageAlloc)
 {
-	PVR_TRACE(("%s: unmapping %d bytes from 0x%08x", __FUNCTION__,
-		   ui32Bytes, pvLinAddr));
+	PVR_TRACE("%s: unmapping %d bytes from 0x%08x", __func__,
+		   ui32Bytes, pvLinAddr);
 
 	PVR_UNREFERENCED_PARAMETER(hPageAlloc);
 
@@ -776,9 +669,10 @@
 		IOUnmapWrapper(pvLinAddr);
 		return IMG_TRUE;
 	} else {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "OSUnMapPhysToLin should only be used with PVRSRV_HAP_KERNEL_ONLY "
-			 " (Use OSUnReservePhys otherwise)"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "OSUnMapPhysToLin should only be used with "
+			 "PVRSRV_HAP_KERNEL_ONLY "
+			 " (Use OSUnReservePhys otherwise)");
 		return IMG_FALSE;
 	}
 
@@ -786,14 +680,12 @@
 	return IMG_FALSE;
 }
 
-static PVRSRV_ERROR
-RegisterExternalMem(IMG_SYS_PHYADDR * pBasePAddr,
-		    IMG_VOID * pvCPUVAddr,
-		    IMG_UINT32 ui32Bytes,
-		    IMG_BOOL bPhysContig,
-		    IMG_UINT32 ui32MappingFlags, IMG_HANDLE * phOSMemHandle)
+static enum PVRSRV_ERROR RegisterExternalMem(struct IMG_SYS_PHYADDR *pBasePAddr,
+		    void *pvCPUVAddr, u32 ui32Bytes,
+		    IMG_BOOL bPhysContig, u32 ui32MappingFlags,
+		    void **phOSMemHandle)
 {
-	LinuxMemArea *psLinuxMemArea;
+	struct LinuxMemArea *psLinuxMemArea;
 
 	switch (ui32MappingFlags & PVRSRV_HAP_MAPTYPE_MASK) {
 	case PVRSRV_HAP_KERNEL_ONLY:
@@ -803,9 +695,8 @@
 						      ui32Bytes, bPhysContig,
 						      ui32MappingFlags);
 
-			if (!psLinuxMemArea) {
+			if (!psLinuxMemArea)
 				return PVRSRV_ERROR_GENERIC;
-			}
 			break;
 		}
 	case PVRSRV_HAP_SINGLE_PROCESS:
@@ -815,9 +706,8 @@
 						      ui32Bytes, bPhysContig,
 						      ui32MappingFlags);
 
-			if (!psLinuxMemArea) {
+			if (!psLinuxMemArea)
 				return PVRSRV_ERROR_GENERIC;
-			}
 			PVRMMapRegisterArea("Physical", psLinuxMemArea,
 					    ui32MappingFlags);
 			break;
@@ -829,54 +719,52 @@
 						      ui32Bytes, bPhysContig,
 						      ui32MappingFlags);
 
-			if (!psLinuxMemArea) {
+			if (!psLinuxMemArea)
 				return PVRSRV_ERROR_GENERIC;
-			}
 			PVRMMapRegisterArea("Physical", psLinuxMemArea,
 					    ui32MappingFlags);
 			break;
 		}
 	default:
-		PVR_DPF((PVR_DBG_ERROR, "OSRegisterMem : invalid flags 0x%x\n",
-			 ui32MappingFlags));
-		*phOSMemHandle = (IMG_HANDLE) 0;
+		PVR_DPF(PVR_DBG_ERROR, "OSRegisterMem : invalid flags 0x%x\n",
+			 ui32MappingFlags);
+		*phOSMemHandle = (void *) 0;
 		return PVRSRV_ERROR_GENERIC;
 	}
 
-	*phOSMemHandle = (IMG_HANDLE) psLinuxMemArea;
+	*phOSMemHandle = (void *) psLinuxMemArea;
 
 	LinuxMemAreaRegister(psLinuxMemArea);
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR
-OSRegisterMem(IMG_CPU_PHYADDR BasePAddr,
-	      IMG_VOID * pvCPUVAddr,
-	      IMG_UINT32 ui32Bytes,
-	      IMG_UINT32 ui32MappingFlags, IMG_HANDLE * phOSMemHandle)
+enum PVRSRV_ERROR OSRegisterMem(struct IMG_CPU_PHYADDR BasePAddr,
+	      void *pvCPUVAddr,
+	      u32 ui32Bytes,
+	      u32 ui32MappingFlags, void **phOSMemHandle)
 {
-	IMG_SYS_PHYADDR SysPAddr = SysCpuPAddrToSysPAddr(BasePAddr);
+	struct IMG_SYS_PHYADDR SysPAddr = SysCpuPAddrToSysPAddr(BasePAddr);
 
 	return RegisterExternalMem(&SysPAddr, pvCPUVAddr, ui32Bytes, IMG_TRUE,
 				   ui32MappingFlags, phOSMemHandle);
 }
 
-PVRSRV_ERROR OSRegisterDiscontigMem(IMG_SYS_PHYADDR * pBasePAddr,
-				    IMG_VOID * pvCPUVAddr, IMG_UINT32 ui32Bytes,
-				    IMG_UINT32 ui32MappingFlags,
-				    IMG_HANDLE * phOSMemHandle)
+enum PVRSRV_ERROR OSRegisterDiscontigMem(struct IMG_SYS_PHYADDR *pBasePAddr,
+				    void *pvCPUVAddr, u32 ui32Bytes,
+				    u32 ui32MappingFlags,
+				    void **phOSMemHandle)
 {
-	return RegisterExternalMem(pBasePAddr, pvCPUVAddr, ui32Bytes, IMG_FALSE,
-				   ui32MappingFlags, phOSMemHandle);
+	return RegisterExternalMem(pBasePAddr, pvCPUVAddr, ui32Bytes,
+				   IMG_FALSE, ui32MappingFlags, phOSMemHandle);
 }
 
-PVRSRV_ERROR
-OSUnRegisterMem(IMG_VOID * pvCpuVAddr,
-		IMG_UINT32 ui32Bytes,
-		IMG_UINT32 ui32MappingFlags, IMG_HANDLE hOSMemHandle)
+enum PVRSRV_ERROR OSUnRegisterMem(void *pvCpuVAddr,
+		u32 ui32Bytes,
+		u32 ui32MappingFlags, void *hOSMemHandle)
 {
-	LinuxMemArea *psLinuxMemArea = (LinuxMemArea *) hOSMemHandle;
+	struct LinuxMemArea *psLinuxMemArea = (struct LinuxMemArea *)
+								hOSMemHandle;
 
 	PVR_UNREFERENCED_PARAMETER(pvCpuVAddr);
 
@@ -888,19 +776,19 @@
 		{
 			if (PVRMMapRemoveRegisteredArea(psLinuxMemArea) !=
 			    PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
+				PVR_DPF(PVR_DBG_ERROR,
 					 "%s(%p, %d, 0x%08X, %p) FAILED!",
-					 __FUNCTION__, pvCpuVAddr, ui32Bytes,
-					 ui32MappingFlags, hOSMemHandle));
+					 __func__, pvCpuVAddr, ui32Bytes,
+					 ui32MappingFlags, hOSMemHandle);
 				return PVRSRV_ERROR_GENERIC;
 			}
 			break;
 		}
 	default:
 		{
-			PVR_DPF((PVR_DBG_ERROR,
+			PVR_DPF(PVR_DBG_ERROR,
 				 "OSUnRegisterMem : invalid flags 0x%x",
-				 ui32MappingFlags));
+				 ui32MappingFlags);
 			return PVRSRV_ERROR_INVALID_PARAMS;
 		}
 	}
@@ -910,22 +798,17 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR OSUnRegisterDiscontigMem(IMG_VOID * pvCpuVAddr,
-				      IMG_UINT32 ui32Bytes,
-				      IMG_UINT32 ui32Flags,
-				      IMG_HANDLE hOSMemHandle)
+enum PVRSRV_ERROR OSUnRegisterDiscontigMem(void *pvCpuVAddr, u32 ui32Bytes,
+				      u32 ui32Flags, void *hOSMemHandle)
 {
 	return OSUnRegisterMem(pvCpuVAddr, ui32Bytes, ui32Flags, hOSMemHandle);
 }
 
-PVRSRV_ERROR
-OSReservePhys(IMG_CPU_PHYADDR BasePAddr,
-	      IMG_UINT32 ui32Bytes,
-	      IMG_UINT32 ui32MappingFlags,
-	      IMG_VOID ** ppvCpuVAddr, IMG_HANDLE * phOSMemHandle)
+enum PVRSRV_ERROR OSReservePhys(struct IMG_CPU_PHYADDR BasePAddr,
+	      u32 ui32Bytes, u32 ui32MappingFlags, void **ppvCpuVAddr,
+	      void **phOSMemHandle)
 {
-	LinuxMemArea *psLinuxMemArea;
-
+	struct LinuxMemArea *psLinuxMemArea;
 
 	switch (ui32MappingFlags & PVRSRV_HAP_MAPTYPE_MASK) {
 	case PVRSRV_HAP_KERNEL_ONLY:
@@ -934,20 +817,17 @@
 			psLinuxMemArea =
 			    NewIORemapLinuxMemArea(BasePAddr, ui32Bytes,
 						   ui32MappingFlags);
-			if (!psLinuxMemArea) {
+			if (!psLinuxMemArea)
 				return PVRSRV_ERROR_GENERIC;
-			}
 			break;
 		}
 	case PVRSRV_HAP_SINGLE_PROCESS:
 		{
-
 			psLinuxMemArea =
 			    NewIOLinuxMemArea(BasePAddr, ui32Bytes,
 					      ui32MappingFlags);
-			if (!psLinuxMemArea) {
+			if (!psLinuxMemArea)
 				return PVRSRV_ERROR_GENERIC;
-			}
 			PVRMMapRegisterArea("Physical", psLinuxMemArea,
 					    ui32MappingFlags);
 			break;
@@ -957,22 +837,21 @@
 			psLinuxMemArea =
 			    NewIORemapLinuxMemArea(BasePAddr, ui32Bytes,
 						   ui32MappingFlags);
-			if (!psLinuxMemArea) {
+			if (!psLinuxMemArea)
 				return PVRSRV_ERROR_GENERIC;
-			}
 			PVRMMapRegisterArea("Physical", psLinuxMemArea,
 					    ui32MappingFlags);
 			break;
 		}
 	default:
-		PVR_DPF((PVR_DBG_ERROR, "OSMapPhysToLin : invalid flags 0x%x\n",
-			 ui32MappingFlags));
+		PVR_DPF(PVR_DBG_ERROR, "OSMapPhysToLin : invalid flags 0x%x\n",
+			 ui32MappingFlags);
 		*ppvCpuVAddr = NULL;
-		*phOSMemHandle = (IMG_HANDLE) 0;
+		*phOSMemHandle = (void *) 0;
 		return PVRSRV_ERROR_GENERIC;
 	}
 
-	*phOSMemHandle = (IMG_HANDLE) psLinuxMemArea;
+	*phOSMemHandle = (void *) psLinuxMemArea;
 	*ppvCpuVAddr = LinuxMemAreaToCpuVAddr(psLinuxMemArea);
 
 	LinuxMemAreaRegister(psLinuxMemArea);
@@ -980,15 +859,13 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR
-OSUnReservePhys(IMG_VOID * pvCpuVAddr,
-		IMG_UINT32 ui32Bytes,
-		IMG_UINT32 ui32MappingFlags, IMG_HANDLE hOSMemHandle)
+enum PVRSRV_ERROR OSUnReservePhys(void *pvCpuVAddr,
+		u32 ui32Bytes, u32 ui32MappingFlags, void *hOSMemHandle)
 {
-	LinuxMemArea *psLinuxMemArea;
+	struct LinuxMemArea *psLinuxMemArea;
 	PVR_UNREFERENCED_PARAMETER(pvCpuVAddr);
 
-	psLinuxMemArea = (LinuxMemArea *) hOSMemHandle;
+	psLinuxMemArea = (struct LinuxMemArea *)hOSMemHandle;
 
 	switch (ui32MappingFlags & PVRSRV_HAP_MAPTYPE_MASK) {
 	case PVRSRV_HAP_KERNEL_ONLY:
@@ -998,19 +875,19 @@
 		{
 			if (PVRMMapRemoveRegisteredArea(psLinuxMemArea) !=
 			    PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
+				PVR_DPF(PVR_DBG_ERROR,
 					 "%s(%p, %d, 0x%08X, %p) FAILED!",
-					 __FUNCTION__, pvCpuVAddr, ui32Bytes,
-					 ui32MappingFlags, hOSMemHandle));
+					 __func__, pvCpuVAddr, ui32Bytes,
+					 ui32MappingFlags, hOSMemHandle);
 				return PVRSRV_ERROR_GENERIC;
 			}
 			break;
 		}
 	default:
 		{
-			PVR_DPF((PVR_DBG_ERROR,
+			PVR_DPF(PVR_DBG_ERROR,
 				 "OSUnMapPhysToLin : invalid flags 0x%x",
-				 ui32MappingFlags));
+				 ui32MappingFlags);
 			return PVRSRV_ERROR_INVALID_PARAMS;
 		}
 	}
@@ -1020,53 +897,50 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR OSBaseAllocContigMemory(IMG_UINT32 ui32Size,
-				     IMG_CPU_VIRTADDR * pvLinAddr,
-				     IMG_CPU_PHYADDR * psPhysAddr)
+enum PVRSRV_ERROR OSBaseAllocContigMemory(u32 ui32Size, void **pvLinAddr,
+				     struct IMG_CPU_PHYADDR *psPhysAddr)
 {
 	PVR_UNREFERENCED_PARAMETER(ui32Size);
 	PVR_UNREFERENCED_PARAMETER(pvLinAddr);
 	PVR_UNREFERENCED_PARAMETER(psPhysAddr);
-	PVR_DPF((PVR_DBG_ERROR, "%s: Not available", __FUNCTION__));
+	PVR_DPF(PVR_DBG_ERROR, "%s: Not available", __func__);
 
 	return PVRSRV_ERROR_OUT_OF_MEMORY;
 }
 
-PVRSRV_ERROR OSBaseFreeContigMemory(IMG_UINT32 ui32Size,
-				    IMG_CPU_VIRTADDR pvLinAddr,
-				    IMG_CPU_PHYADDR psPhysAddr)
+enum PVRSRV_ERROR OSBaseFreeContigMemory(u32 ui32Size, void *pvLinAddr,
+				    struct IMG_CPU_PHYADDR psPhysAddr)
 {
 	PVR_UNREFERENCED_PARAMETER(ui32Size);
 	PVR_UNREFERENCED_PARAMETER(pvLinAddr);
 	PVR_UNREFERENCED_PARAMETER(psPhysAddr);
 
-	PVR_DPF((PVR_DBG_WARNING, "%s: Not available", __FUNCTION__));
+	PVR_DPF(PVR_DBG_WARNING, "%s: Not available", __func__);
 	return PVRSRV_OK;
 }
 
-IMG_UINT32 OSReadHWReg(IMG_PVOID pvLinRegBaseAddr, IMG_UINT32 ui32Offset)
+u32 OSReadHWReg(void __iomem *pvLinRegBaseAddr, u32 ui32Offset)
 {
-	return (IMG_UINT32) readl(pvLinRegBaseAddr + ui32Offset);
+	return (u32)readl(pvLinRegBaseAddr + ui32Offset);
 }
 
-IMG_VOID OSWriteHWReg(IMG_PVOID pvLinRegBaseAddr, IMG_UINT32 ui32Offset,
-		      IMG_UINT32 ui32Value)
+void OSWriteHWReg(void __iomem *pvLinRegBaseAddr, u32 ui32Offset, u32 ui32Value)
 {
 	writel(ui32Value, pvLinRegBaseAddr + ui32Offset);
 }
 
-
-typedef struct TIMER_CALLBACK_DATA_TAG {
-	PFN_TIMER_FUNC pfnTimerFunc;
-	IMG_VOID *pvData;
+struct TIMER_CALLBACK_DATA {
+	void (*pfnTimerFunc)(void *);
+	void *pvData;
 	struct timer_list sTimer;
-	IMG_UINT32 ui32Delay;
+	u32 ui32Delay;
 	IMG_BOOL bActive;
-} TIMER_CALLBACK_DATA;
+};
 
-static IMG_VOID OSTimerCallbackWrapper(IMG_UINT32 ui32Data)
+static void OSTimerCallbackWrapper(unsigned long ui32Data)
 {
-	TIMER_CALLBACK_DATA *psTimerCBData = (TIMER_CALLBACK_DATA *) ui32Data;
+	struct TIMER_CALLBACK_DATA *psTimerCBData =
+					(struct TIMER_CALLBACK_DATA *)ui32Data;
 
 	if (!psTimerCBData->bActive)
 		return;
@@ -1076,22 +950,21 @@
 	mod_timer(&psTimerCBData->sTimer, psTimerCBData->ui32Delay + jiffies);
 }
 
-IMG_HANDLE OSAddTimer(PFN_TIMER_FUNC pfnTimerFunc, IMG_VOID * pvData,
-		      IMG_UINT32 ui32MsTimeout)
+void *OSAddTimer(void (*pfnTimerFunc)(void *), void *pvData, u32 ui32MsTimeout)
 {
-	TIMER_CALLBACK_DATA *psTimerCBData;
+	struct TIMER_CALLBACK_DATA *psTimerCBData;
 
 	if (!pfnTimerFunc) {
-		PVR_DPF((PVR_DBG_ERROR, "OSAddTimer: passed invalid callback"));
-		return IMG_NULL;
+		PVR_DPF(PVR_DBG_ERROR, "OSAddTimer: passed invalid callback");
+		return NULL;
 	}
 
 	if (OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-		       sizeof(TIMER_CALLBACK_DATA),
-		       (IMG_VOID **) & psTimerCBData, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "OSAddTimer: failed to allocate memory for TIMER_CALLBACK_DATA"));
-		return IMG_NULL;
+		       sizeof(struct TIMER_CALLBACK_DATA),
+		       (void **) &psTimerCBData, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "OSAddTimer: failed to allocate memory");
+		return NULL;
 	}
 
 	psTimerCBData->pfnTimerFunc = pfnTimerFunc;
@@ -1104,25 +977,28 @@
 	init_timer(&psTimerCBData->sTimer);
 
 	psTimerCBData->sTimer.function = OSTimerCallbackWrapper;
-	psTimerCBData->sTimer.data = (IMG_UINT32) psTimerCBData;
+	psTimerCBData->sTimer.data = (u32) psTimerCBData;
 	psTimerCBData->sTimer.expires = psTimerCBData->ui32Delay + jiffies;
 
-	return (IMG_HANDLE) psTimerCBData;
+	return (void *)psTimerCBData;
 }
 
-PVRSRV_ERROR OSRemoveTimer(IMG_HANDLE hTimer)
+enum PVRSRV_ERROR OSRemoveTimer(void *hTimer)
 {
-	TIMER_CALLBACK_DATA *psTimerCBData = (TIMER_CALLBACK_DATA *) hTimer;
+	struct TIMER_CALLBACK_DATA *psTimerCBData =
+					(struct TIMER_CALLBACK_DATA *)hTimer;
 
-	OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, sizeof(TIMER_CALLBACK_DATA),
-		  psTimerCBData, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+		  sizeof(struct TIMER_CALLBACK_DATA),
+		  psTimerCBData, NULL);
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR OSEnableTimer(IMG_HANDLE hTimer)
+enum PVRSRV_ERROR OSEnableTimer(void *hTimer)
 {
-	TIMER_CALLBACK_DATA *psTimerCBData = (TIMER_CALLBACK_DATA *) hTimer;
+	struct TIMER_CALLBACK_DATA *psTimerCBData =
+					(struct TIMER_CALLBACK_DATA *)hTimer;
 
 	psTimerCBData->bActive = IMG_TRUE;
 
@@ -1132,9 +1008,10 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR OSDisableTimer(IMG_HANDLE hTimer)
+enum PVRSRV_ERROR OSDisableTimer(void *hTimer)
 {
-	TIMER_CALLBACK_DATA *psTimerCBData = (TIMER_CALLBACK_DATA *) hTimer;
+	struct TIMER_CALLBACK_DATA *psTimerCBData =
+					(struct TIMER_CALLBACK_DATA *)hTimer;
 
 	psTimerCBData->bActive = IMG_FALSE;
 
@@ -1143,11 +1020,10 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR OSEventObjectCreate(const IMG_CHAR * pszName,
-				 PVRSRV_EVENTOBJECT * psEventObject)
+enum PVRSRV_ERROR OSEventObjectCreate(const char *pszName,
+				 struct PVRSRV_EVENTOBJECT *psEventObject)
 {
-
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
 	if (psEventObject) {
 		if (pszName) {
@@ -1156,19 +1032,18 @@
 				EVENTOBJNAME_MAXLENGTH);
 		} else {
 
-			static IMG_UINT16 ui16NameIndex = 0;
+			static u16 ui16NameIndex;
 			snprintf(psEventObject->szName, EVENTOBJNAME_MAXLENGTH,
 				 "PVRSRV_EVENTOBJECT_%d", ui16NameIndex++);
 		}
 
 		if (LinuxEventObjectListCreate(&psEventObject->hOSEventKM) !=
-		    PVRSRV_OK) {
+		    PVRSRV_OK)
 			eError = PVRSRV_ERROR_OUT_OF_MEMORY;
-		}
 
 	} else {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "OSEventObjectCreate: psEventObject is not a valid pointer"));
+		PVR_DPF(PVR_DBG_ERROR, "OSEventObjectCreate: "
+			"psEventObject is not a valid pointer");
 		eError = PVRSRV_ERROR_GENERIC;
 	}
 
@@ -1176,80 +1051,80 @@
 
 }
 
-PVRSRV_ERROR OSEventObjectDestroy(PVRSRV_EVENTOBJECT * psEventObject)
+enum PVRSRV_ERROR OSEventObjectDestroy(struct PVRSRV_EVENTOBJECT *psEventObject)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
 	if (psEventObject) {
 		if (psEventObject->hOSEventKM) {
 			LinuxEventObjectListDestroy(psEventObject->hOSEventKM);
 		} else {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "OSEventObjectDestroy: hOSEventKM is not a valid pointer"));
+			PVR_DPF(PVR_DBG_ERROR, "OSEventObjectDestroy: "
+				"hOSEventKM is not a valid pointer");
 			eError = PVRSRV_ERROR_INVALID_PARAMS;
 		}
 	} else {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "OSEventObjectDestroy: psEventObject is not a valid pointer"));
+		PVR_DPF(PVR_DBG_ERROR, "OSEventObjectDestroy: "
+				"psEventObject is not a valid pointer");
 		eError = PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	return eError;
 }
 
-PVRSRV_ERROR OSEventObjectWait(IMG_HANDLE hOSEventKM)
+enum PVRSRV_ERROR OSEventObjectWait(void *hOSEventKM)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
 	if (hOSEventKM) {
 		eError =
 		    LinuxEventObjectWait(hOSEventKM, EVENT_OBJECT_TIMEOUT_MS);
 	} else {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "OSEventObjectWait: hOSEventKM is not a valid handle"));
+		PVR_DPF(PVR_DBG_ERROR, "OSEventObjectWait: "
+			"hOSEventKM is not a valid handle");
 		eError = PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	return eError;
 }
 
-PVRSRV_ERROR OSEventObjectOpen(PVRSRV_EVENTOBJECT * psEventObject,
-			       IMG_HANDLE * phOSEvent)
+enum PVRSRV_ERROR OSEventObjectOpen(struct PVRSRV_EVENTOBJECT *psEventObject,
+			       void **phOSEvent)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
 	if (psEventObject) {
 		if (LinuxEventObjectAdd(psEventObject->hOSEventKM, phOSEvent) !=
 		    PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR, "LinuxEventObjectAdd: failed"));
+			PVR_DPF(PVR_DBG_ERROR, "LinuxEventObjectAdd: failed");
 			eError = PVRSRV_ERROR_INVALID_PARAMS;
 		}
 
 	} else {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "OSEventObjectCreate: psEventObject is not a valid pointer"));
+		PVR_DPF(PVR_DBG_ERROR, "OSEventObjectCreate: "
+			"psEventObject is not a valid pointer");
 		eError = PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	return eError;
 }
 
-PVRSRV_ERROR OSEventObjectClose(PVRSRV_EVENTOBJECT * psEventObject,
-				IMG_HANDLE hOSEventKM)
+enum PVRSRV_ERROR OSEventObjectClose(struct PVRSRV_EVENTOBJECT *psEventObject,
+				void *hOSEventKM)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
 	if (psEventObject) {
 		if (LinuxEventObjectDelete
 		    (psEventObject->hOSEventKM, hOSEventKM) != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "LinuxEventObjectDelete: failed"));
+			PVR_DPF(PVR_DBG_ERROR,
+				 "LinuxEventObjectDelete: failed");
 			eError = PVRSRV_ERROR_INVALID_PARAMS;
 		}
 
 	} else {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "OSEventObjectDestroy: psEventObject is not a valid pointer"));
+		PVR_DPF(PVR_DBG_ERROR, "OSEventObjectDestroy: "
+				"psEventObject is not a valid pointer");
 		eError = PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
@@ -1257,29 +1132,28 @@
 
 }
 
-PVRSRV_ERROR OSEventObjectSignal(IMG_HANDLE hOSEventKM)
+enum PVRSRV_ERROR OSEventObjectSignal(void *hOSEventKM)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
 	if (hOSEventKM) {
 		eError = LinuxEventObjectSignal(hOSEventKM);
 	} else {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "OSEventObjectSignal: hOSEventKM is not a valid handle"));
+		PVR_DPF(PVR_DBG_ERROR, "OSEventObjectSignal: "
+			"hOSEventKM is not a valid handle");
 		eError = PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	return eError;
 }
 
-IMG_BOOL OSProcHasPrivSrvInit(IMG_VOID)
+IMG_BOOL OSProcHasPrivSrvInit(void)
 {
 	return capable(CAP_SYS_MODULE) != 0;
 }
 
-PVRSRV_ERROR OSCopyToUser(IMG_PVOID pvProcess,
-			  IMG_VOID * pvDest,
-			  IMG_VOID * pvSrc, IMG_UINT32 ui32Bytes)
+enum PVRSRV_ERROR OSCopyToUser(void *pvProcess, void __user *pvDest,
+			       const void *pvSrc, u32 ui32Bytes)
 {
 	PVR_UNREFERENCED_PARAMETER(pvProcess);
 
@@ -1289,9 +1163,8 @@
 		return PVRSRV_ERROR_GENERIC;
 }
 
-PVRSRV_ERROR OSCopyFromUser(IMG_PVOID pvProcess,
-			    IMG_VOID * pvDest,
-			    IMG_VOID * pvSrc, IMG_UINT32 ui32Bytes)
+enum PVRSRV_ERROR OSCopyFromUser(void *pvProcess, void *pvDest,
+				 const void __user *pvSrc, u32 ui32Bytes)
 {
 	PVR_UNREFERENCED_PARAMETER(pvProcess);
 
@@ -1301,8 +1174,8 @@
 		return PVRSRV_ERROR_GENERIC;
 }
 
-IMG_BOOL OSAccessOK(IMG_VERIFY_TEST eVerification, IMG_VOID * pvUserPtr,
-		    IMG_UINT32 ui32Bytes)
+IMG_BOOL OSAccessOK(enum IMG_VERIFY_TEST eVerification,
+		    const void __user *pvUserPtr, u32 ui32Bytes)
 {
 	int linuxType;
 
@@ -1311,25 +1184,24 @@
 	else if (eVerification == PVR_VERIFY_WRITE)
 		linuxType = VERIFY_WRITE;
 	else {
-		PVR_DPF((PVR_DBG_ERROR, "%s: Unknown eVerification",
-			 __FUNCTION__));
+		PVR_DPF(PVR_DBG_ERROR, "%s: Unknown eVerification", __func__);
 		return PVRSRV_ERROR_GENERIC;
 	}
-	return (IMG_BOOL) access_ok(linuxType, pvUserPtr, ui32Bytes);
+	return (IMG_BOOL)access_ok(linuxType, pvUserPtr, ui32Bytes);
 }
 
-typedef enum _eWrapMemType_ {
+enum eWrapMemType {
 	WRAP_TYPE_CLEANUP,
 	WRAP_TYPE_GET_USER_PAGES,
 	WRAP_TYPE_FIND_VMA_PAGES,
 	WRAP_TYPE_FIND_VMA_PFN
-} eWrapMemType;
+};
 
-typedef struct _sWrapMemInfo_ {
-	eWrapMemType eType;
+struct sWrapMemInfo {
+	enum eWrapMemType eType;
 	int iNumPages;
 	struct page **ppsPages;
-	IMG_SYS_PHYADDR *psPhysAddr;
+	struct IMG_SYS_PHYADDR *psPhysAddr;
 	int iPageOffset;
 	int iContiguous;
 #if defined(DEBUG)
@@ -1337,24 +1209,23 @@
 	unsigned long ulBeyondEndAddr;
 	struct vm_area_struct *psVMArea;
 #endif
-} sWrapMemInfo;
+};
 
-static void CheckPagesContiguous(sWrapMemInfo * psInfo)
+static void CheckPagesContiguous(struct sWrapMemInfo *psInfo)
 {
 	unsigned ui;
-	IMG_UINT32 ui32AddrChk;
+	u32 ui32AddrChk;
 
-	BUG_ON(psInfo == IMG_NULL);
+	BUG_ON(psInfo == NULL);
 
 	psInfo->iContiguous = 1;
 
 	for (ui = 0, ui32AddrChk = psInfo->psPhysAddr[0].uiAddr;
-	     ui < psInfo->iNumPages; ui++, ui32AddrChk += PAGE_SIZE) {
+	     ui < psInfo->iNumPages; ui++, ui32AddrChk += PAGE_SIZE)
 		if (psInfo->psPhysAddr[ui].uiAddr != ui32AddrChk) {
 			psInfo->iContiguous = 0;
 			break;
 		}
-	}
 }
 
 static struct page *CPUVAddrToPage(struct vm_area_struct *psVMArea,
@@ -1401,13 +1272,12 @@
 	return psPage;
 }
 
-PVRSRV_ERROR OSReleasePhysPageAddr(IMG_HANDLE hOSWrapMem,
-							   IMG_BOOL bUseLock)
+enum PVRSRV_ERROR OSReleasePhysPageAddr(void *hOSWrapMem, IMG_BOOL bUseLock)
 {
-	sWrapMemInfo *psInfo = (sWrapMemInfo *) hOSWrapMem;
+	struct sWrapMemInfo *psInfo = (struct sWrapMemInfo *)hOSWrapMem;
 	unsigned ui;
 
-	BUG_ON(psInfo == IMG_NULL);
+	BUG_ON(psInfo == NULL);
 
 #if defined(DEBUG)
 	switch (psInfo->eType) {
@@ -1422,9 +1292,9 @@
 
 			psVMArea = find_vma(current->mm, psInfo->ulStartAddr);
 			if (psVMArea == NULL) {
-				printk(KERN_WARNING
-				       ": OSCpuVToPageListRelease: Couldn't find memory region containing start address %lx",
-				       psInfo->ulStartAddr);
+				printk(KERN_WARNING ": OSCpuVToPageListRelease:"
+		 " Couldn't find memory region containing start address %lx",
+		 psInfo->ulStartAddr);
 
 				if (bUseLock)
 					up_read(&current->mm->mmap_sem);
@@ -1432,37 +1302,39 @@
 				break;
 			}
 
-			if (psInfo->psVMArea != psVMArea) {
-				printk(KERN_WARNING
-				       ": OSCpuVToPageListRelease: vm_area_struct has a different address from the one used in ImportMem (%p != %p)",
+			if (psInfo->psVMArea != psVMArea)
+				printk(KERN_WARNING ": OSCpuVToPageListRelease:"
+					" vm_area_struct has a different "
+					"address from the one used in "
+					"ImportMem (%p != %p)",
 				       psVMArea, psInfo->psVMArea);
-			}
 
-			if (psInfo->ulStartAddr < psVMArea->vm_start) {
-				printk(KERN_WARNING
-				       ": OSCpuVToPageListRelease: Start address %lx is outside of the region returned by find_vma",
+			if (psInfo->ulStartAddr < psVMArea->vm_start)
+				printk(KERN_WARNING ": OSCpuVToPageListRelease:"
+					" Start address %lx is outside of "
+					"the region returned by find_vma",
 				       psInfo->ulStartAddr);
-			}
 
-			if (psInfo->ulBeyondEndAddr > psVMArea->vm_end) {
-				printk(KERN_WARNING
-				       ": OSCpuVToPageListRelease: End address %lx is outside of the region returned by find_vma",
+			if (psInfo->ulBeyondEndAddr > psVMArea->vm_end)
+				printk(KERN_WARNING ": OSCpuVToPageListRelease:"
+					" End address %lx is outside of the "
+					"region returned by find_vma",
 				       psInfo->ulBeyondEndAddr);
-			}
 
 			if ((psVMArea->vm_flags & (VM_IO | VM_RESERVED)) !=
-			    (VM_IO | VM_RESERVED)) {
-				printk(KERN_WARNING
-				       ": OSCpuVToPageListRelease: Memory region does not represent memory mapped I/O (VMA flags: 0x%lx)",
+			    (VM_IO | VM_RESERVED))
+				printk(KERN_WARNING ": OSCpuVToPageListRelease:"
+					" Memory region does not represent "
+					"memory mapped I/O (VMA flags: 0x%lx)",
 				       psVMArea->vm_flags);
-			}
 
 			if ((psVMArea->vm_flags & (VM_READ | VM_WRITE)) !=
-			    (VM_READ | VM_WRITE)) {
-				printk(KERN_WARNING
-				       ": OSCpuVToPageListRelease: OSWrapMemReleasePages: No read/write access to memory region (VMA flags: 0x%lx)",
+			    (VM_READ | VM_WRITE))
+				printk(KERN_WARNING ": OSCpuVToPageListRelease:"
+					" OSWrapMemReleasePages: "
+					"No read/write access to memory region "
+					"(VMA flags: 0x%lx)",
 				       psVMArea->vm_flags);
-			}
 
 			if (bUseLock)
 				up_read(&current->mm->mmap_sem);
@@ -1484,7 +1356,8 @@
 			for (ui = 0; ui < psInfo->iNumPages; ui++) {
 				struct page *psPage = psInfo->ppsPages[ui];
 
-				if (!PageReserved(psPage)) ;
+				if (!PageReserved(psPage))
+					;
 				{
 					SetPageDirty(psPage);
 				}
@@ -1494,37 +1367,33 @@
 		}
 	case WRAP_TYPE_FIND_VMA_PAGES:
 		{
-			for (ui = 0; ui < psInfo->iNumPages; ui++) {
+			for (ui = 0; ui < psInfo->iNumPages; ui++)
 				put_page_testzero(psInfo->ppsPages[ui]);
-			}
 			break;
 		}
 	default:
 		{
-			printk(KERN_WARNING
-			       ": OSCpuVToPageListRelease: Unknown wrap type (%d)",
-			       psInfo->eType);
+			printk(KERN_WARNING ": OSCpuVToPageListRelease: "
+			       "Unknown wrap type (%d)", psInfo->eType);
 			return PVRSRV_ERROR_GENERIC;
 		}
 	}
 
-	if (psInfo->ppsPages != IMG_NULL) {
+	if (psInfo->ppsPages != NULL)
 		kfree(psInfo->ppsPages);
-	}
 
-	if (psInfo->psPhysAddr != IMG_NULL) {
+	if (psInfo->psPhysAddr != NULL)
 		kfree(psInfo->psPhysAddr);
-	}
 
 	kfree(psInfo);
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_VOID *pvCPUVAddr,
-				   IMG_UINT32 ui32Bytes,
-				   IMG_SYS_PHYADDR *psSysPAddr,
-				   IMG_HANDLE *phOSWrapMem,
+enum PVRSRV_ERROR OSAcquirePhysPageAddr(void *pvCPUVAddr,
+				   u32 ui32Bytes,
+				   struct IMG_SYS_PHYADDR *psSysPAddr,
+				   void **phOSWrapMem,
 				   IMG_BOOL bUseLock)
 {
 	unsigned long ulStartAddrOrig = (unsigned long)pvCPUVAddr;
@@ -1537,7 +1406,7 @@
 	int iNumPagesMapped;
 	unsigned ui;
 	struct vm_area_struct *psVMArea;
-	sWrapMemInfo *psInfo;
+	struct sWrapMemInfo *psInfo;
 
 	ulStartAddr = ulStartAddrOrig & PAGE_MASK;
 	ulBeyondEndAddr = PAGE_ALIGN(ulBeyondEndAddrOrig);
@@ -1545,8 +1414,8 @@
 
 	psInfo = kmalloc(sizeof(*psInfo), GFP_KERNEL);
 	if (psInfo == NULL) {
-		printk(KERN_WARNING
-		       ": OSCpuVToPageList: Couldn't allocate information structure\n");
+		printk(KERN_WARNING ": OSCpuVToPageList: "
+				"Couldn't allocate information structure\n");
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 	memset(psInfo, 0, sizeof(*psInfo));
@@ -1590,19 +1459,19 @@
 	if (iNumPagesMapped >= 0) {
 
 		if (iNumPagesMapped != psInfo->iNumPages) {
-			printk(KERN_WARNING
-			       ": OSCpuVToPageList: Couldn't map all the pages needed (wanted: %d, got %d \n)",
+			printk(KERN_WARNING ": OSCpuVToPageList: Couldn't "
+				"map all the pages needed "
+				"(wanted: %d, got %d \n)",
 			       psInfo->iNumPages, iNumPagesMapped);
 
-			for (ui = 0; ui < iNumPagesMapped; ui++) {
+			for (ui = 0; ui < iNumPagesMapped; ui++)
 				page_cache_release(psInfo->ppsPages[ui]);
 
-			}
 			goto error_free;
 		}
 
 		for (ui = 0; ui < psInfo->iNumPages; ui++) {
-			IMG_CPU_PHYADDR CPUPhysAddr;
+			struct IMG_CPU_PHYADDR CPUPhysAddr;
 
 			CPUPhysAddr.uiAddr =
 			    page_to_pfn(psInfo->ppsPages[ui]) << PAGE_SHIFT;
@@ -1617,17 +1486,18 @@
 		goto exit_check;
 	}
 
-	printk(KERN_WARNING
-	       ": OSCpuVToPageList: get_user_pages failed (%d), trying something else \n",
-	       iNumPagesMapped);
+	printk(KERN_WARNING ": OSCpuVToPageList: get_user_pages failed (%d), "
+			    "trying something else \n",
+			    iNumPagesMapped);
 
 	if (bUseLock)
 		down_read(&current->mm->mmap_sem);
 
 	psVMArea = find_vma(current->mm, ulStartAddrOrig);
 	if (psVMArea == NULL) {
-		printk(KERN_WARNING
-		       ": OSCpuVToPageList: Couldn't find memory region containing start address %lx \n",
+		printk(KERN_WARNING ": OSCpuVToPageList: "
+				"Couldn't find memory region containing "
+				"start address %lx \n",
 		       ulStartAddrOrig);
 
 		goto error_release_mmap_sem;
@@ -1637,30 +1507,35 @@
 #endif
 
 	if (ulStartAddrOrig < psVMArea->vm_start) {
-		printk(KERN_WARNING
-		       ": OSCpuVToPageList: Start address %lx is outside of the region returned by find_vma\n",
+		printk(KERN_WARNING ": OSCpuVToPageList: "
+				"Start address %lx is outside of the "
+				"region returned by find_vma\n",
 		       ulStartAddrOrig);
 		goto error_release_mmap_sem;
 	}
 
 	if (ulBeyondEndAddrOrig > psVMArea->vm_end) {
-		printk(KERN_WARNING
-		       ": OSCpuVToPageList: End address %lx is outside of the region returned by find_vma\n",
+		printk(KERN_WARNING ": OSCpuVToPageList: "
+				"End address %lx is outside of the "
+				"region returned by find_vma\n",
 		       ulBeyondEndAddrOrig);
 		goto error_release_mmap_sem;
 	}
 
 	if ((psVMArea->vm_flags & (VM_IO | VM_RESERVED)) !=
 	    (VM_IO | VM_RESERVED)) {
-		printk(KERN_WARNING
-		       ": OSCpuVToPageList: Memory region does not represent memory mapped I/O (VMA flags: 0x%lx)\n",
+		printk(KERN_WARNING ": OSCpuVToPageList: "
+				"Memory region does not represent "
+				"memory mapped I/O (VMA flags: 0x%lx)\n",
 		       psVMArea->vm_flags);
 		goto error_release_mmap_sem;
 	}
 
-	if ((psVMArea->vm_flags & (VM_READ | VM_WRITE)) != (VM_READ | VM_WRITE)) {
-		printk(KERN_WARNING
-		       ": OSCpuVToPageList: No read/write access to memory region (VMA flags: 0x%lx)\n",
+	if ((psVMArea->vm_flags & (VM_READ | VM_WRITE)) !=
+	    (VM_READ | VM_WRITE)) {
+		printk(KERN_WARNING ": OSCpuVToPageList: "
+			"No read/write access to memory region "
+			"(VMA flags: 0x%lx)\n",
 		       psVMArea->vm_flags);
 		goto error_release_mmap_sem;
 	}
@@ -1675,13 +1550,13 @@
 		if (psPage == NULL) {
 			unsigned uj;
 
-			printk(KERN_WARNING
-			       ": OSCpuVToPageList: Couldn't lookup page structure for address 0x%lx, trying something else\n",
+			printk(KERN_WARNING ": OSCpuVToPageList: "
+				"Couldn't lookup page structure for "
+				"address 0x%lx, trying something else\n",
 			       ulAddr);
 
-			for (uj = 0; uj < ui; uj++) {
+			for (uj = 0; uj < ui; uj++)
 				put_page_testzero(psInfo->ppsPages[uj]);
-			}
 			break;
 		}
 
@@ -1693,7 +1568,7 @@
 
 		for (ui = 0; ui < psInfo->iNumPages; ui++) {
 			struct page *psPage = psInfo->ppsPages[ui];
-			IMG_CPU_PHYADDR CPUPhysAddr;
+			struct IMG_CPU_PHYADDR CPUPhysAddr;
 
 			CPUPhysAddr.uiAddr = page_to_pfn(psPage) << PAGE_SHIFT;
 
@@ -1706,14 +1581,14 @@
 	} else {
 
 		if ((psVMArea->vm_flags & VM_PFNMAP) == 0) {
-			printk(KERN_WARNING
-			       ": OSCpuVToPageList: Region isn't a raw PFN mapping.  Giving up.\n");
+			printk(KERN_WARNING ": OSCpuVToPageList: "
+			       "Region isn't a raw PFN mapping.  Giving up.\n");
 			goto error_release_mmap_sem;
 		}
 
 		for (ulAddr = ulStartAddrOrig, ui = 0;
 		     ulAddr < ulBeyondEndAddrOrig; ulAddr += PAGE_SIZE, ui++) {
-			IMG_CPU_PHYADDR CPUPhysAddr;
+			struct IMG_CPU_PHYADDR CPUPhysAddr;
 
 			CPUPhysAddr.uiAddr =
 			    ((ulAddr - psVMArea->vm_start) +
@@ -1737,7 +1612,7 @@
 exit_check:
 	CheckPagesContiguous(psInfo);
 
-	*phOSWrapMem = (IMG_HANDLE) psInfo;
+	*phOSWrapMem = (void *) psInfo;
 
 	return PVRSRV_OK;
 
@@ -1747,6 +1622,6 @@
 
 error_free:
 	psInfo->eType = WRAP_TYPE_CLEANUP;
-	OSReleasePhysPageAddr((IMG_HANDLE) psInfo, bUseLock);
+	OSReleasePhysPageAddr((void *) psInfo, bUseLock);
 	return PVRSRV_ERROR_GENERIC;
 }
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/osfunc.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/osfunc.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -33,268 +33,181 @@
 #include <linux/string.h>
 #endif
 
-#define KERNEL_ID			0xffffffffL
+#define KERNEL_ID		0xffffffffL
 #define POWER_MANAGER_ID	0xfffffffeL
-#define ISR_ID				0xfffffffdL
-#define TIMER_ID			0xfffffffcL
+#define ISR_ID			0xfffffffdL
+#define TIMER_ID		0xfffffffcL
 
-#define HOST_PAGESIZE			OSGetPageSize
-#define HOST_PAGEMASK			(~(HOST_PAGESIZE()-1))
+#define HOST_PAGESIZE		OSGetPageSize
+#define HOST_PAGEMASK		(~(HOST_PAGESIZE()-1))
 #define HOST_PAGEALIGN(addr)	(((addr)+HOST_PAGESIZE()-1)&HOST_PAGEMASK)
 
-#define PVRSRV_OS_HEAP_MASK			0xf
+#define PVRSRV_OS_HEAP_MASK		0xf
 #define PVRSRV_OS_PAGEABLE_HEAP		0x1
 #define PVRSRV_OS_NON_PAGEABLE_HEAP	0x2
 
-	IMG_UINT32 OSClockus(IMG_VOID);
-	IMG_UINT32 OSGetPageSize(IMG_VOID);
-	PVRSRV_ERROR OSInstallDeviceLISR(IMG_VOID * pvSysData,
-					 IMG_UINT32 ui32Irq,
-					 IMG_CHAR * pszISRName,
-					 IMG_VOID * pvDeviceNode);
-	PVRSRV_ERROR OSUninstallDeviceLISR(IMG_VOID * pvSysData);
-	PVRSRV_ERROR OSInstallSystemLISR(IMG_VOID * pvSysData,
-					 IMG_UINT32 ui32Irq);
-	PVRSRV_ERROR OSUninstallSystemLISR(IMG_VOID * pvSysData);
-	PVRSRV_ERROR OSInstallMISR(IMG_VOID * pvSysData);
-	PVRSRV_ERROR OSUninstallMISR(IMG_VOID * pvSysData);
-	PVRSRV_ERROR OSInitPerf(IMG_VOID * pvSysData);
-	PVRSRV_ERROR OSCleanupPerf(IMG_VOID * pvSysData);
-	IMG_CPU_PHYADDR OSMapLinToCPUPhys(IMG_VOID * pvLinAddr);
-	IMG_VOID OSMemCopy(IMG_VOID * pvDst, IMG_VOID * pvSrc,
-			   IMG_UINT32 ui32Size);
-	IMG_VOID *OSMapPhysToLin(IMG_CPU_PHYADDR BasePAddr,
-				 IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags,
-				 IMG_HANDLE * phOSMemHandle);
-	IMG_BOOL OSUnMapPhysToLin(IMG_VOID * pvLinAddr, IMG_UINT32 ui32Bytes,
-				  IMG_UINT32 ui32Flags,
-				  IMG_HANDLE hOSMemHandle);
-
-	PVRSRV_ERROR OSReservePhys(IMG_CPU_PHYADDR BasePAddr,
-				   IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags,
-				   IMG_VOID ** ppvCpuVAddr,
-				   IMG_HANDLE * phOSMemHandle);
-	PVRSRV_ERROR OSUnReservePhys(IMG_VOID * pvCpuVAddr,
-				     IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags,
-				     IMG_HANDLE hOSMemHandle);
-
-	PVRSRV_ERROR OSRegisterDiscontigMem(IMG_SYS_PHYADDR * pBasePAddr,
-					    IMG_VOID * pvCpuVAddr,
-					    IMG_UINT32 ui32Bytes,
-					    IMG_UINT32 ui32Flags,
-					    IMG_HANDLE * phOSMemHandle);
-	PVRSRV_ERROR OSUnRegisterDiscontigMem(IMG_VOID * pvCpuVAddr,
-					      IMG_UINT32 ui32Bytes,
-					      IMG_UINT32 ui32Flags,
-					      IMG_HANDLE hOSMemHandle);
-
-	static INLINE PVRSRV_ERROR OSReserveDiscontigPhys(IMG_SYS_PHYADDR *
-							  pBasePAddr,
-							  IMG_UINT32 ui32Bytes,
-							  IMG_UINT32 ui32Flags,
-							  IMG_VOID **
-							  ppvCpuVAddr,
-							  IMG_HANDLE *
-							  phOSMemHandle) {
-		*ppvCpuVAddr = IMG_NULL;
-		return OSRegisterDiscontigMem(pBasePAddr, *ppvCpuVAddr,
-					      ui32Bytes, ui32Flags,
-					      phOSMemHandle);
-	}
-
-	static INLINE PVRSRV_ERROR OSUnReserveDiscontigPhys(IMG_VOID *
-							    pvCpuVAddr,
-							    IMG_UINT32
-							    ui32Bytes,
-							    IMG_UINT32
-							    ui32Flags,
-							    IMG_HANDLE
-							    hOSMemHandle) {
-		OSUnRegisterDiscontigMem(pvCpuVAddr, ui32Bytes, ui32Flags,
-					 hOSMemHandle);
-
-		return PVRSRV_OK;
-	}
-
-	PVRSRV_ERROR OSRegisterMem(IMG_CPU_PHYADDR BasePAddr,
-				   IMG_VOID * pvCpuVAddr, IMG_UINT32 ui32Bytes,
-				   IMG_UINT32 ui32Flags,
-				   IMG_HANDLE * phOSMemHandle);
-	PVRSRV_ERROR OSUnRegisterMem(IMG_VOID * pvCpuVAddr,
-				     IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags,
-				     IMG_HANDLE hOSMemHandle);
-
-	PVRSRV_ERROR OSGetSubMemHandle(IMG_HANDLE hOSMemHandle,
-				       IMG_UINT32 ui32ByteOffset,
-				       IMG_UINT32 ui32Bytes,
-				       IMG_UINT32 ui32Flags,
-				       IMG_HANDLE * phOSMemHandleRet);
-	PVRSRV_ERROR OSReleaseSubMemHandle(IMG_HANDLE hOSMemHandle,
-					   IMG_UINT32 ui32Flags);
-
-	IMG_UINT32 OSGetCurrentProcessIDKM(IMG_VOID);
-	IMG_UINT32 OSGetCurrentThreadID(IMG_VOID);
-	IMG_VOID OSMemSet(IMG_VOID * pvDest, IMG_UINT8 ui8Value,
-			  IMG_UINT32 ui32Size);
+u32 OSClockus(void);
+u32 OSGetPageSize(void);
+enum PVRSRV_ERROR OSInstallDeviceLISR(void *pvSysData, u32 ui32Irq,
+				      char *pszISRName, void *pvDeviceNode);
+enum PVRSRV_ERROR OSUninstallDeviceLISR(void *pvSysData);
+enum PVRSRV_ERROR OSInstallSystemLISR(void *pvSysData, u32 ui32Irq);
+enum PVRSRV_ERROR OSUninstallSystemLISR(void *pvSysData);
+enum PVRSRV_ERROR OSInstallMISR(void *pvSysData);
+enum PVRSRV_ERROR OSUninstallMISR(void *pvSysData);
+enum PVRSRV_ERROR OSInitPerf(void *pvSysData);
+enum PVRSRV_ERROR OSCleanupPerf(void *pvSysData);
+struct IMG_CPU_PHYADDR OSMapLinToCPUPhys(void *pvLinAddr);
+void OSMemCopy(void *pvDst, void *pvSrc, u32 ui32Size);
+void __iomem *OSMapPhysToLin(struct IMG_CPU_PHYADDR BasePAddr, u32 ui32Bytes,
+		u32 ui32Flags, void **phOSMemHandle);
+IMG_BOOL OSUnMapPhysToLin(void __iomem *pvLinAddr, u32 ui32Bytes, u32 ui32Flags,
+		void *hOSMemHandle);
+
+enum PVRSRV_ERROR OSReservePhys(struct IMG_CPU_PHYADDR BasePAddr, u32 ui32Bytes,
+		u32 ui32Flags, void **ppvCpuVAddr, void **phOSMemHandle);
+enum PVRSRV_ERROR OSUnReservePhys(void *pvCpuVAddr, u32 ui32Bytes,
+		u32 ui32Flags, void *hOSMemHandle);
+
+enum PVRSRV_ERROR OSRegisterDiscontigMem(struct IMG_SYS_PHYADDR *pBasePAddr,
+		void *pvCpuVAddr, u32 ui32Bytes, u32 ui32Flags,
+		void **phOSMemHandle);
+enum PVRSRV_ERROR OSUnRegisterDiscontigMem(void *pvCpuVAddr, u32 ui32Bytes,
+		u32 ui32Flags, void *hOSMemHandle);
+
+static inline enum PVRSRV_ERROR OSReserveDiscontigPhys(
+		struct IMG_SYS_PHYADDR *pBasePAddr, u32 ui32Bytes,
+		u32 ui32Flags, void **ppvCpuVAddr, void **phOSMemHandle) {
+	*ppvCpuVAddr = NULL;
+	return OSRegisterDiscontigMem(pBasePAddr, *ppvCpuVAddr, ui32Bytes,
+				      ui32Flags, phOSMemHandle);
+}
+
+static inline enum PVRSRV_ERROR OSUnReserveDiscontigPhys(void *pvCpuVAddr,
+		u32 ui32Bytes, u32 ui32Flags, void *hOSMemHandle) {
+	OSUnRegisterDiscontigMem(pvCpuVAddr, ui32Bytes, ui32Flags,
+			hOSMemHandle);
+
+	return PVRSRV_OK;
+}
+
+enum PVRSRV_ERROR OSRegisterMem(struct IMG_CPU_PHYADDR BasePAddr,
+		void *pvCpuVAddr, u32 ui32Bytes, u32 ui32Flags,
+		void **phOSMemHandle);
+enum PVRSRV_ERROR OSUnRegisterMem(void *pvCpuVAddr, u32 ui32Bytes,
+		u32 ui32Flags, void *hOSMemHandle);
+
+enum PVRSRV_ERROR OSGetSubMemHandle(void *hOSMemHandle, u32 ui32ByteOffset,
+		u32 ui32Bytes, u32 ui32Flags, void **phOSMemHandleRet);
+enum PVRSRV_ERROR OSReleaseSubMemHandle(void *hOSMemHandle, u32 ui32Flags);
+
+u32 OSGetCurrentProcessIDKM(void);
+u32 OSGetCurrentThreadID(void);
+void OSMemSet(void *pvDest, u8 ui8Value, u32 ui32Size);
 
 #ifdef DEBUG_LINUX_MEMORY_ALLOCATIONS
-	PVRSRV_ERROR _OSAllocMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size,
-				 IMG_PVOID * ppvLinAddr,
-				 IMG_HANDLE * phBlockAlloc,
-				 IMG_CHAR * pszFilename, IMG_UINT32 ui32Line);
-#define OSAllocMem(ui32Flags, ui32Size, ppvLinAddr, phBlockAlloc) _OSAllocMem(ui32Flags, ui32Size, ppvLinAddr, phBlockAlloc, __FILE__, __LINE__)
-	PVRSRV_ERROR _OSFreeMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size,
-				IMG_PVOID pvLinAddr, IMG_HANDLE hBlockAlloc,
-				IMG_CHAR * pszFilename, IMG_UINT32 ui32Line);
-#define OSFreeMem(ui32Flags, ui32Size, pvLinAddr, phBlockAlloc) _OSFreeMem(ui32Flags, ui32Size, pvLinAddr, phBlockAlloc, __FILE__, __LINE__)
+enum PVRSRV_ERROR _OSAllocMem(u32 ui32Flags, u32 ui32Size, void **ppvLinAddr,
+		void **phBlockAlloc, char *pszFilename, u32 ui32Line);
+#define OSAllocMem(ui32Flags, ui32Size, ppvLinAddr, phBlockAlloc)	\
+	_OSAllocMem(ui32Flags, ui32Size, ppvLinAddr, phBlockAlloc,	\
+		    __FILE__, __LINE__)
+void _OSFreeMem(u32 ui32Flags, u32 ui32Size, void *pvLinAddr,
+		void *hBlockAlloc, char *pszFilename, u32 ui32Line);
+#define OSFreeMem(ui32Flags, ui32Size, pvLinAddr, phBlockAlloc)		\
+	_OSFreeMem(ui32Flags, ui32Size, pvLinAddr, phBlockAlloc,	\
+		   __FILE__, __LINE__)
 #else
-	PVRSRV_ERROR OSAllocMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size,
-				IMG_PVOID * ppvLinAddr,
-				IMG_HANDLE * phBlockAlloc);
-	PVRSRV_ERROR OSFreeMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size,
-			       IMG_PVOID pvLinAddr, IMG_HANDLE hBlockAlloc);
+enum PVRSRV_ERROR OSAllocMem(u32 ui32Flags, u32 ui32Size, void **ppvLinAddr,
+		void **phBlockAlloc);
+void OSFreeMem(u32 ui32Flags, u32 ui32Size, void *pvLinAddr,
+		void *hBlockAlloc);
 #endif
-	PVRSRV_ERROR OSAllocPages(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size,
-				  IMG_PVOID * ppvLinAddr,
-				  IMG_HANDLE * phPageAlloc);
-	PVRSRV_ERROR OSFreePages(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size,
-				 IMG_PVOID pvLinAddr, IMG_HANDLE hPageAlloc);
-	IMG_CPU_PHYADDR OSMemHandleToCpuPAddr(IMG_VOID * hOSMemHandle,
-					      IMG_UINT32 ui32ByteOffset);
-	PVRSRV_ERROR OSInitEnvData(IMG_PVOID * ppvEnvSpecificData);
-	PVRSRV_ERROR OSDeInitEnvData(IMG_PVOID pvEnvSpecificData);
-	IMG_CHAR *OSStringCopy(IMG_CHAR * pszDest, const IMG_CHAR * pszSrc);
-	IMG_INT32 OSSNPrintf(IMG_CHAR * pStr, IMG_UINT32 ui32Size,
-			     const IMG_CHAR * pszFormat, ...);
+enum PVRSRV_ERROR OSAllocPages(u32 ui32Flags, u32 ui32Size, void **ppvLinAddr,
+		void **phPageAlloc);
+enum PVRSRV_ERROR OSFreePages(u32 ui32Flags, u32 ui32Size, void *pvLinAddr,
+		void *hPageAlloc);
+struct IMG_CPU_PHYADDR OSMemHandleToCpuPAddr(void *hOSMemHandle,
+		u32 ui32ByteOffset);
+enum PVRSRV_ERROR OSInitEnvData(void **ppvEnvSpecificData);
+enum PVRSRV_ERROR OSDeInitEnvData(void *pvEnvSpecificData);
+char *OSStringCopy(char *pszDest, const char *pszSrc);
+s32 OSSNPrintf(char *pStr, u32 ui32Size, const char *pszFormat, ...);
 #define OSStringLength(pszString) strlen(pszString)
 
-	PVRSRV_ERROR OSEventObjectCreate(const IMG_CHAR * pszName,
-					 PVRSRV_EVENTOBJECT * psEventObject);
-	PVRSRV_ERROR OSEventObjectDestroy(PVRSRV_EVENTOBJECT * psEventObject);
-	PVRSRV_ERROR OSEventObjectSignal(IMG_HANDLE hOSEventKM);
-	PVRSRV_ERROR OSEventObjectWait(IMG_HANDLE hOSEventKM);
-	PVRSRV_ERROR OSEventObjectOpen(PVRSRV_EVENTOBJECT * psEventObject,
-				       IMG_HANDLE * phOSEvent);
-	PVRSRV_ERROR OSEventObjectClose(PVRSRV_EVENTOBJECT * psEventObject,
-					IMG_HANDLE hOSEventKM);
-
-	PVRSRV_ERROR OSBaseAllocContigMemory(IMG_UINT32 ui32Size,
-					     IMG_CPU_VIRTADDR * pLinAddr,
-					     IMG_CPU_PHYADDR * pPhysAddr);
-	PVRSRV_ERROR OSBaseFreeContigMemory(IMG_UINT32 ui32Size,
-					    IMG_CPU_VIRTADDR LinAddr,
-					    IMG_CPU_PHYADDR PhysAddr);
-
-	IMG_PVOID MapUserFromKernel(IMG_PVOID pvLinAddrKM, IMG_UINT32 ui32Size,
-				    IMG_HANDLE * phMemBlock);
-	IMG_PVOID OSMapHWRegsIntoUserSpace(IMG_HANDLE hDevCookie,
-					   IMG_SYS_PHYADDR sRegAddr,
-					   IMG_UINT32 ulSize,
-					   IMG_PVOID * ppvProcess);
-	IMG_VOID OSUnmapHWRegsFromUserSpace(IMG_HANDLE hDevCookie,
-					    IMG_PVOID pvUserAddr,
-					    IMG_PVOID pvProcess);
-
-	IMG_VOID UnmapUserFromKernel(IMG_PVOID pvLinAddrUM, IMG_UINT32 ui32Size,
-				     IMG_HANDLE hMemBlock);
-
-	PVRSRV_ERROR OSMapPhysToUserSpace(IMG_HANDLE hDevCookie,
-					  IMG_SYS_PHYADDR sCPUPhysAddr,
-					  IMG_UINT32 uiSizeInBytes,
-					  IMG_UINT32 ui32CacheFlags,
-					  IMG_PVOID * ppvUserAddr,
-					  IMG_UINT32 * puiActualSize,
-					  IMG_HANDLE hMappingHandle);
-
-	PVRSRV_ERROR OSUnmapPhysToUserSpace(IMG_HANDLE hDevCookie,
-					    IMG_PVOID pvUserAddr,
-					    IMG_PVOID pvProcess);
-
-	PVRSRV_ERROR OSLockResource(PVRSRV_RESOURCE * psResource,
-				    IMG_UINT32 ui32ID);
-	PVRSRV_ERROR OSUnlockResource(PVRSRV_RESOURCE * psResource,
-				      IMG_UINT32 ui32ID);
-	IMG_BOOL OSIsResourceLocked(PVRSRV_RESOURCE * psResource,
-				    IMG_UINT32 ui32ID);
-	PVRSRV_ERROR OSCreateResource(PVRSRV_RESOURCE * psResource);
-	PVRSRV_ERROR OSDestroyResource(PVRSRV_RESOURCE * psResource);
-	IMG_VOID OSBreakResourceLock(PVRSRV_RESOURCE * psResource,
-				     IMG_UINT32 ui32ID);
-	IMG_VOID OSWaitus(IMG_UINT32 ui32Timeus);
-	IMG_VOID OSReleaseThreadQuanta(IMG_VOID);
-	IMG_UINT32 OSPCIReadDword(IMG_UINT32 ui32Bus, IMG_UINT32 ui32Dev,
-				  IMG_UINT32 ui32Func, IMG_UINT32 ui32Reg);
-	IMG_VOID OSPCIWriteDword(IMG_UINT32 ui32Bus, IMG_UINT32 ui32Dev,
-				 IMG_UINT32 ui32Func, IMG_UINT32 ui32Reg,
-				 IMG_UINT32 ui32Value);
-
-	IMG_UINT32 OSReadHWReg(IMG_PVOID pvLinRegBaseAddr,
-			       IMG_UINT32 ui32Offset);
-	IMG_VOID OSWriteHWReg(IMG_PVOID pvLinRegBaseAddr, IMG_UINT32 ui32Offset,
-			      IMG_UINT32 ui32Value);
-
-	typedef IMG_VOID(*PFN_TIMER_FUNC) (IMG_VOID *);
-	IMG_HANDLE OSAddTimer(PFN_TIMER_FUNC pfnTimerFunc, IMG_VOID * pvData,
-			      IMG_UINT32 ui32MsTimeout);
-	PVRSRV_ERROR OSRemoveTimer(IMG_HANDLE hTimer);
-	PVRSRV_ERROR OSEnableTimer(IMG_HANDLE hTimer);
-	PVRSRV_ERROR OSDisableTimer(IMG_HANDLE hTimer);
-
-	PVRSRV_ERROR OSGetSysMemSize(IMG_UINT32 * pui32Bytes);
-
-	typedef enum _HOST_PCI_INIT_FLAGS_ {
-		HOST_PCI_INIT_FLAG_BUS_MASTER = 0x1,
-		HOST_PCI_INIT_FLAG_FORCE_I32 = 0x7fffffff
-	} HOST_PCI_INIT_FLAGS;
-
-	struct _PVRSRV_PCI_DEV_OPAQUE_STRUCT_;
-	typedef struct _PVRSRV_PCI_DEV_OPAQUE_STRUCT_ *PVRSRV_PCI_DEV_HANDLE;
-
-	PVRSRV_PCI_DEV_HANDLE OSPCIAcquireDev(IMG_UINT16 ui16VendorID,
-					      IMG_UINT16 ui16DeviceID,
-					      HOST_PCI_INIT_FLAGS eFlags);
-	PVRSRV_PCI_DEV_HANDLE OSPCISetDev(IMG_VOID * pvPCICookie,
-					  HOST_PCI_INIT_FLAGS eFlags);
-	PVRSRV_ERROR OSPCIReleaseDev(PVRSRV_PCI_DEV_HANDLE hPVRPCI);
-	PVRSRV_ERROR OSPCIIRQ(PVRSRV_PCI_DEV_HANDLE hPVRPCI,
-			      IMG_UINT32 * pui32IRQ);
-	IMG_UINT32 OSPCIAddrRangeLen(PVRSRV_PCI_DEV_HANDLE hPVRPCI,
-				     IMG_UINT32 ui32Index);
-	IMG_UINT32 OSPCIAddrRangeStart(PVRSRV_PCI_DEV_HANDLE hPVRPCI,
-				       IMG_UINT32 ui32Index);
-	IMG_UINT32 OSPCIAddrRangeEnd(PVRSRV_PCI_DEV_HANDLE hPVRPCI,
-				     IMG_UINT32 ui32Index);
-	PVRSRV_ERROR OSPCIRequestAddrRange(PVRSRV_PCI_DEV_HANDLE hPVRPCI,
-					   IMG_UINT32 ui32Index);
-	PVRSRV_ERROR OSPCIReleaseAddrRange(PVRSRV_PCI_DEV_HANDLE hPVRPCI,
-					   IMG_UINT32 ui32Index);
-	PVRSRV_ERROR OSPCISuspendDev(PVRSRV_PCI_DEV_HANDLE hPVRPCI);
-	PVRSRV_ERROR OSPCIResumeDev(PVRSRV_PCI_DEV_HANDLE hPVRPCI);
-
-	PVRSRV_ERROR OSScheduleMISR(IMG_VOID * pvSysData);
-
-	IMG_BOOL OSProcHasPrivSrvInit(IMG_VOID);
-
-	typedef enum _img_verify_test {
-		PVR_VERIFY_WRITE = 0,
-		PVR_VERIFY_READ
-	} IMG_VERIFY_TEST;
-
-	IMG_BOOL OSAccessOK(IMG_VERIFY_TEST eVerification, IMG_VOID * pvUserPtr,
-			    IMG_UINT32 ui32Bytes);
-
-	PVRSRV_ERROR OSCopyToUser(IMG_PVOID pvProcess, IMG_VOID * pvDest,
-				  IMG_VOID * pvSrc, IMG_UINT32 ui32Bytes);
-	PVRSRV_ERROR OSCopyFromUser(IMG_PVOID pvProcess, IMG_VOID * pvDest,
-				    IMG_VOID * pvSrc, IMG_UINT32 ui32Bytes);
-
-	PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_VOID * pvCPUVAddr,
-					   IMG_UINT32 ui32Bytes,
-					   IMG_SYS_PHYADDR * psSysPAddr,
-					   IMG_HANDLE * phOSWrapMem,
-					   IMG_BOOL bUseLock);
-	PVRSRV_ERROR OSReleasePhysPageAddr(IMG_HANDLE hOSWrapMem,
-					   IMG_BOOL bUseLock);
+enum PVRSRV_ERROR OSEventObjectCreate(const char *pszName,
+		struct PVRSRV_EVENTOBJECT *psEventObject);
+enum PVRSRV_ERROR OSEventObjectDestroy(
+		struct PVRSRV_EVENTOBJECT *psEventObject);
+enum PVRSRV_ERROR OSEventObjectSignal(void *hOSEventKM);
+enum PVRSRV_ERROR OSEventObjectWait(void *hOSEventKM);
+enum PVRSRV_ERROR OSEventObjectOpen(struct PVRSRV_EVENTOBJECT *psEventObject,
+		void **phOSEvent);
+enum PVRSRV_ERROR OSEventObjectClose(struct PVRSRV_EVENTOBJECT *psEventObject,
+		void *hOSEventKM);
+
+enum PVRSRV_ERROR OSBaseAllocContigMemory(u32 ui32Size, void **pLinAddr,
+		struct IMG_CPU_PHYADDR *pPhysAddr);
+enum PVRSRV_ERROR OSBaseFreeContigMemory(u32 ui32Size, void *LinAddr,
+		struct IMG_CPU_PHYADDR PhysAddr);
+
+void *MapUserFromKernel(void *pvLinAddrKM, u32 ui32Size, void **phMemBlock);
+void *OSMapHWRegsIntoUserSpace(void *hDevCookie,
+		struct IMG_SYS_PHYADDR sRegAddr, u32 ulSize, void **ppvProcess);
+void OSUnmapHWRegsFromUserSpace(void *hDevCookie, void *pvUserAddr,
+		void *pvProcess);
+
+void UnmapUserFromKernel(void *pvLinAddrUM, u32 ui32Size, void *hMemBlock);
+
+enum PVRSRV_ERROR OSMapPhysToUserSpace(void *hDevCookie,
+		struct IMG_SYS_PHYADDR sCPUPhysAddr, u32 uiSizeInBytes,
+		u32 ui32CacheFlags, void **ppvUserAddr, u32 *puiActualSize,
+		void *hMappingHandle);
+
+enum PVRSRV_ERROR OSUnmapPhysToUserSpace(void *hDevCookie, void *pvUserAddr,
+		void *pvProcess);
+
+enum PVRSRV_ERROR OSLockResource(struct PVRSRV_RESOURCE *psResource,
+		u32 ui32ID);
+enum PVRSRV_ERROR OSUnlockResource(struct PVRSRV_RESOURCE *psResource,
+		u32 ui32ID);
+enum PVRSRV_ERROR OSCreateResource(struct PVRSRV_RESOURCE *psResource);
+enum PVRSRV_ERROR OSDestroyResource(struct PVRSRV_RESOURCE *psResource);
+void OSBreakResourceLock(struct PVRSRV_RESOURCE *psResource, u32 ui32ID);
+void OSWaitus(u32 ui32Timeus);
+void OSReleaseThreadQuanta(void);
+
+u32 OSReadHWReg(void __iomem *pvLinRegBaseAddr, u32 ui32Offset);
+void OSWriteHWReg(void __iomem *pvLinRegBaseAddr, u32 ui32Offset,
+		  u32 ui32Value);
+
+void *OSAddTimer(void (*pfnTimerFunc)(void *), void *pvData, u32 ui32MsTimeout);
+enum PVRSRV_ERROR OSRemoveTimer(void *hTimer);
+enum PVRSRV_ERROR OSEnableTimer(void *hTimer);
+enum PVRSRV_ERROR OSDisableTimer(void *hTimer);
+
+enum PVRSRV_ERROR OSGetSysMemSize(u32 *pui32Bytes);
+
+enum PVRSRV_ERROR OSScheduleMISR(void *pvSysData);
+
+IMG_BOOL OSProcHasPrivSrvInit(void);
+
+enum IMG_VERIFY_TEST {
+	PVR_VERIFY_WRITE = 0,
+	PVR_VERIFY_READ
+};
+
+IMG_BOOL OSAccessOK(enum IMG_VERIFY_TEST eVerification,
+		    const void __user *pvUserPtr, u32 ui32Bytes);
+
+enum PVRSRV_ERROR OSCopyToUser(void *pvProcess, void __user *pvDest,
+			const void *pvSrc, u32 ui32Bytes);
+enum PVRSRV_ERROR OSCopyFromUser(void *pvProcess, void *pvDest,
+			const void __user *pvSrc, u32 ui32Bytes);
+
+enum PVRSRV_ERROR OSAcquirePhysPageAddr(void *pvCPUVAddr, u32 ui32Bytes,
+				   struct IMG_SYS_PHYADDR *psSysPAddr,
+				   void **phOSWrapMem, IMG_BOOL bUseLock);
+enum PVRSRV_ERROR OSReleasePhysPageAddr(void *hOSWrapMem, IMG_BOOL bUseLock);
 
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/pb.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/pb.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -31,80 +31,74 @@
 #include "sgxinfo.h"
 #include "sgxinfokm.h"
 #include "pvr_bridge_km.h"
+#include "sgx_bridge_km.h"
 #include "pdump_km.h"
 
 
-static PRESMAN_ITEM psResItemCreateSharedPB = IMG_NULL;
-static PVRSRV_PER_PROCESS_DATA *psPerProcCreateSharedPB = IMG_NULL;
+static struct RESMAN_ITEM *psResItemCreateSharedPB;
+static struct PVRSRV_PER_PROCESS_DATA *psPerProcCreateSharedPB;
 
-static PVRSRV_ERROR SGXCleanupSharedPBDescCallback(IMG_PVOID pvParam,
-						   IMG_UINT32 ui32Param);
-static PVRSRV_ERROR SGXCleanupSharedPBDescCreateLockCallback(IMG_PVOID pvParam,
-							     IMG_UINT32
-							     ui32Param);
-
-IMG_EXPORT PVRSRV_ERROR
-SGXFindSharedPBDescKM(PVRSRV_PER_PROCESS_DATA * psPerProc,
-		      IMG_HANDLE hDevCookie,
-		      IMG_BOOL bLockOnFailure,
-		      IMG_UINT32 ui32TotalPBSize,
-		      IMG_HANDLE * phSharedPBDesc,
-		      PVRSRV_KERNEL_MEM_INFO ** ppsSharedPBDescKernelMemInfo,
-		      PVRSRV_KERNEL_MEM_INFO ** ppsHWPBDescKernelMemInfo,
-		      PVRSRV_KERNEL_MEM_INFO ** ppsBlockKernelMemInfo,
-		      PVRSRV_KERNEL_MEM_INFO ***
-		      pppsSharedPBDescSubKernelMemInfos,
-		      IMG_UINT32 * ui32SharedPBDescSubKernelMemInfosCount)
+static enum PVRSRV_ERROR SGXCleanupSharedPBDescCallback(void *pvParam,
+						   u32 ui32Param);
+static enum PVRSRV_ERROR SGXCleanupSharedPBDescCreateLockCallback(void *pvParam,
+							     u32 ui32Param);
+
+enum PVRSRV_ERROR SGXFindSharedPBDescKM(
+	     struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+	     void *hDevCookie, IMG_BOOL bLockOnFailure,
+	     u32 ui32TotalPBSize, void **phSharedPBDesc,
+	     struct PVRSRV_KERNEL_MEM_INFO **ppsSharedPBDescKernelMemInfo,
+	     struct PVRSRV_KERNEL_MEM_INFO **ppsHWPBDescKernelMemInfo,
+	     struct PVRSRV_KERNEL_MEM_INFO **ppsBlockKernelMemInfo,
+	     struct PVRSRV_KERNEL_MEM_INFO ***pppsSharedPBDescSubKernelMemInfos,
+	     u32 *ui32SharedPBDescSubKernelMemInfosCount)
 {
-	PVRSRV_STUB_PBDESC *psStubPBDesc;
-	PVRSRV_KERNEL_MEM_INFO **ppsSharedPBDescSubKernelMemInfos = IMG_NULL;
-	PVRSRV_SGXDEV_INFO *psSGXDevInfo;
-	PVRSRV_ERROR eError = PVRSRV_ERROR_GENERIC;
+	struct PVRSRV_STUB_PBDESC *psStubPBDesc;
+	struct PVRSRV_KERNEL_MEM_INFO **ppsSharedPBDescSubKernelMemInfos = NULL;
+	struct PVRSRV_SGXDEV_INFO *psSGXDevInfo;
+	enum PVRSRV_ERROR eError = PVRSRV_ERROR_GENERIC;
 
-	psSGXDevInfo = ((PVRSRV_DEVICE_NODE *) hDevCookie)->pvDevice;
+	psSGXDevInfo = ((struct PVRSRV_DEVICE_NODE *)hDevCookie)->pvDevice;
 
 	psStubPBDesc = psSGXDevInfo->psStubPBDescListKM;
-	if (psStubPBDesc != IMG_NULL) {
-		if (psStubPBDesc->ui32TotalPBSize != ui32TotalPBSize) {
-			PVR_DPF((PVR_DBG_WARNING,
-				 "SGXFindSharedPBDescKM: Shared PB requested with different size (0x%x) from existing shared PB (0x%x) - requested size ignored",
+	if (psStubPBDesc != NULL) {
+		if (psStubPBDesc->ui32TotalPBSize != ui32TotalPBSize)
+			PVR_DPF(PVR_DBG_WARNING, "SGXFindSharedPBDescKM: "
+				"Shared PB requested with different size "
+				"(0x%x) from existing shared PB (0x%x) - "
+				"requested size ignored",
 				 ui32TotalPBSize,
-				 psStubPBDesc->ui32TotalPBSize));
-		}
+				 psStubPBDesc->ui32TotalPBSize);
 		{
-			IMG_UINT32 i;
-			PRESMAN_ITEM psResItem;
+			u32 i;
+			struct RESMAN_ITEM *psResItem;
 
 			if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-				       sizeof(PVRSRV_KERNEL_MEM_INFO *)
-				       *
+				       sizeof(struct PVRSRV_KERNEL_MEM_INFO *)*
 				       psStubPBDesc->ui32SubKernelMemInfosCount,
-				       (IMG_VOID **) &
+				       (void **) &
 				       ppsSharedPBDescSubKernelMemInfos,
-				       IMG_NULL) != PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "SGXFindSharedPBDescKM: OSAllocMem failed"));
-
+				       NULL) != PVRSRV_OK) {
+				PVR_DPF(PVR_DBG_ERROR, "SGXFindSharedPBDescKM:"
+						" OSAllocMem failed");
 				eError = PVRSRV_ERROR_OUT_OF_MEMORY;
 				goto ExitNotFound;
 			}
 
 			psResItem = ResManRegisterRes(psPerProc->hResManContext,
-						      RESMAN_TYPE_SHARED_PB_DESC,
-						      psStubPBDesc,
-						      0,
-						      &SGXCleanupSharedPBDescCallback);
+					      RESMAN_TYPE_SHARED_PB_DESC,
+					      psStubPBDesc,
+					      0,
+					      &SGXCleanupSharedPBDescCallback);
 
-			if (psResItem == IMG_NULL) {
+			if (psResItem == NULL) {
 				OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-					  sizeof(PVRSRV_KERNEL_MEM_INFO *)
-					  *
-					  psStubPBDesc->
-					  ui32SubKernelMemInfosCount,
-					  ppsSharedPBDescSubKernelMemInfos, 0);
+				  sizeof(struct PVRSRV_KERNEL_MEM_INFO *)*
+				  psStubPBDesc->ui32SubKernelMemInfosCount,
+				  ppsSharedPBDescSubKernelMemInfos, NULL);
 
-				PVR_DPF((PVR_DBG_ERROR,
-					 "SGXFindSharedPBDescKM: ResManRegisterRes failed"));
+				PVR_DPF(PVR_DBG_ERROR, "SGXFindSharedPBDescKM:"
+					" ResManRegisterRes failed");
 
 				eError = PVRSRV_ERROR_GENERIC;
 				goto ExitNotFound;
@@ -125,131 +119,120 @@
 
 			for (i = 0;
 			     i < psStubPBDesc->ui32SubKernelMemInfosCount;
-			     i++) {
+			     i++)
 				ppsSharedPBDescSubKernelMemInfos[i] =
 				    psStubPBDesc->ppsSubKernelMemInfos[i];
-			}
 
 			psStubPBDesc->ui32RefCount++;
-			*phSharedPBDesc = (IMG_HANDLE) psResItem;
+			*phSharedPBDesc = (void *) psResItem;
 			return PVRSRV_OK;
 		}
 	}
 
 	eError = PVRSRV_OK;
 	if (bLockOnFailure) {
-		if (psResItemCreateSharedPB == IMG_NULL) {
+		if (psResItemCreateSharedPB == NULL) {
 			psResItemCreateSharedPB =
 			    ResManRegisterRes(psPerProc->hResManContext,
-					      RESMAN_TYPE_SHARED_PB_DESC_CREATE_LOCK,
-					      psPerProc, 0,
-					      &SGXCleanupSharedPBDescCreateLockCallback);
-
-			if (psResItemCreateSharedPB == IMG_NULL) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "SGXFindSharedPBDescKM: ResManRegisterRes failed"));
+				     RESMAN_TYPE_SHARED_PB_DESC_CREATE_LOCK,
+				     psPerProc, 0,
+				     &SGXCleanupSharedPBDescCreateLockCallback);
+
+			if (psResItemCreateSharedPB == NULL) {
+				PVR_DPF(PVR_DBG_ERROR, "SGXFindSharedPBDescKM:"
+					" ResManRegisterRes failed");
 
 				eError = PVRSRV_ERROR_GENERIC;
 				goto ExitNotFound;
 			}
-			PVR_ASSERT(psPerProcCreateSharedPB == IMG_NULL);
+			PVR_ASSERT(psPerProcCreateSharedPB == NULL);
 			psPerProcCreateSharedPB = psPerProc;
 		} else {
 			eError = PVRSRV_ERROR_PROCESSING_BLOCKED;
 		}
 	}
 ExitNotFound:
-	*phSharedPBDesc = IMG_NULL;
+	*phSharedPBDesc = NULL;
 
 	return eError;
 }
 
-static PVRSRV_ERROR
-SGXCleanupSharedPBDescKM(PVRSRV_STUB_PBDESC * psStubPBDescIn)
+static enum PVRSRV_ERROR
+SGXCleanupSharedPBDescKM(struct PVRSRV_STUB_PBDESC *psStubPBDescIn)
 {
-	PVRSRV_STUB_PBDESC **ppsStubPBDesc;
-	IMG_UINT32 i;
-	PVRSRV_SGXDEV_INFO *psSGXDevInfo;
-
-	psSGXDevInfo =
-	    (PVRSRV_SGXDEV_INFO *) ((PVRSRV_DEVICE_NODE *) psStubPBDescIn->
-				    hDevCookie)->pvDevice;
-
-	for (ppsStubPBDesc =
-	     (PVRSRV_STUB_PBDESC **) & psSGXDevInfo->psStubPBDescListKM;
-	     *ppsStubPBDesc != IMG_NULL;
+	struct PVRSRV_STUB_PBDESC **ppsStubPBDesc;
+	u32 i;
+	struct PVRSRV_SGXDEV_INFO *psSGXDevInfo;
+
+	psSGXDevInfo = (struct PVRSRV_SGXDEV_INFO *)
+		((struct PVRSRV_DEVICE_NODE *)psStubPBDescIn->hDevCookie)->
+								pvDevice;
+
+	for (ppsStubPBDesc = (struct PVRSRV_STUB_PBDESC **)
+			&psSGXDevInfo->psStubPBDescListKM;
+	     *ppsStubPBDesc != NULL;
 	     ppsStubPBDesc = &(*ppsStubPBDesc)->psNext) {
-		PVRSRV_STUB_PBDESC *psStubPBDesc = *ppsStubPBDesc;
+		struct PVRSRV_STUB_PBDESC *psStubPBDesc = *ppsStubPBDesc;
 
 		if (psStubPBDesc == psStubPBDescIn) {
 			psStubPBDesc->ui32RefCount--;
-			PVR_ASSERT((IMG_INT32) psStubPBDesc->ui32RefCount >= 0);
+			PVR_ASSERT((s32) psStubPBDesc->ui32RefCount >= 0);
 
 			if (psStubPBDesc->ui32RefCount == 0) {
-				PVRSRV_SGX_HOST_CTL *psSGXHostCtl =
-				    (PVRSRV_SGX_HOST_CTL *) psSGXDevInfo->
-				    psSGXHostCtl;
-#if defined (PDUMP)
-				IMG_HANDLE hUniqueTag =
-				    MAKEUNIQUETAG(psSGXDevInfo->
-						  psKernelSGXHostCtlMemInfo);
+				struct PVRSRV_SGX_HOST_CTL *psSGXHostCtl =
+					(struct PVRSRV_SGX_HOST_CTL *)
+						psSGXDevInfo->psSGXHostCtl;
+#if defined(PDUMP)
+				void *hUniqueTag = MAKEUNIQUETAG(
+				       psSGXDevInfo->psKernelSGXHostCtlMemInfo);
 #endif
-
 				psSGXHostCtl->sTAHWPBDesc.uiAddr = 0;
 				psSGXHostCtl->s3DHWPBDesc.uiAddr = 0;
 
-				PDUMPCOMMENT
-				    ("TA/3D CCB Control - Reset HW PBDesc records");
-				PDUMPMEM(IMG_NULL,
-					 psSGXDevInfo->
-					 psKernelSGXHostCtlMemInfo,
-					 offsetof(PVRSRV_SGX_HOST_CTL,
-						  sTAHWPBDesc),
-					 sizeof(IMG_DEV_VIRTADDR),
-					 PDUMP_FLAGS_CONTINUOUS, hUniqueTag);
-				PDUMPMEM(IMG_NULL,
-					 psSGXDevInfo->
-					 psKernelSGXHostCtlMemInfo,
-					 offsetof(PVRSRV_SGX_HOST_CTL,
-						  s3DHWPBDesc),
-					 sizeof(IMG_DEV_VIRTADDR),
-					 PDUMP_FLAGS_CONTINUOUS, hUniqueTag);
+				PDUMPCOMMENT("TA/3D CCB Control - "
+					     "Reset HW PBDesc records");
+				PDUMPMEM(NULL,
+					psSGXDevInfo->psKernelSGXHostCtlMemInfo,
+					offsetof(struct PVRSRV_SGX_HOST_CTL,
+							sTAHWPBDesc),
+					sizeof(struct IMG_DEV_VIRTADDR),
+					PDUMP_FLAGS_CONTINUOUS, hUniqueTag);
+				PDUMPMEM(NULL,
+					psSGXDevInfo->psKernelSGXHostCtlMemInfo,
+					offsetof(struct PVRSRV_SGX_HOST_CTL,
+							s3DHWPBDesc),
+					sizeof(struct IMG_DEV_VIRTADDR),
+					PDUMP_FLAGS_CONTINUOUS, hUniqueTag);
 
 				*ppsStubPBDesc = psStubPBDesc->psNext;
 
 				for (i = 0;
-				     i <
-				     psStubPBDesc->ui32SubKernelMemInfosCount;
-				     i++) {
-
+				   i < psStubPBDesc->ui32SubKernelMemInfosCount;
+				   i++)
 					PVRSRVFreeDeviceMemKM(psStubPBDesc->
-							      hDevCookie,
-							      psStubPBDesc->
-							      ppsSubKernelMemInfos
-							      [i]);
-				}
+								   hDevCookie,
+					 psStubPBDesc->ppsSubKernelMemInfos[i]);
 
 				OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-					  sizeof(PVRSRV_KERNEL_MEM_INFO *)
-					  *
+					sizeof(struct PVRSRV_KERNEL_MEM_INFO *)*
 					  psStubPBDesc->
-					  ui32SubKernelMemInfosCount,
+						ui32SubKernelMemInfosCount,
 					  psStubPBDesc->ppsSubKernelMemInfos,
-					  0);
+					  NULL);
 
 				PVRSRVFreeSharedSysMemoryKM(psStubPBDesc->
-							    psBlockKernelMemInfo);
+						psBlockKernelMemInfo);
 
 				PVRSRVFreeDeviceMemKM(psStubPBDesc->hDevCookie,
-						      psStubPBDesc->
-						      psHWPBDescKernelMemInfo);
+						psStubPBDesc->
+						psHWPBDescKernelMemInfo);
 
 				PVRSRVFreeSharedSysMemoryKM(psStubPBDesc->
-							    psSharedPBDescKernelMemInfo);
+						psSharedPBDescKernelMemInfo);
 
 				OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-					  sizeof(PVRSRV_STUB_PBDESC),
-					  psStubPBDesc, 0);
+					     sizeof(struct PVRSRV_STUB_PBDESC),
+					     psStubPBDesc, NULL);
 
 			}
 			return PVRSRV_OK;
@@ -259,23 +242,23 @@
 	return PVRSRV_ERROR_INVALID_PARAMS;
 }
 
-static PVRSRV_ERROR SGXCleanupSharedPBDescCallback(IMG_PVOID pvParam,
-						   IMG_UINT32 ui32Param)
+static enum PVRSRV_ERROR SGXCleanupSharedPBDescCallback(void *pvParam,
+							u32 ui32Param)
 {
-	PVRSRV_STUB_PBDESC *psStubPBDesc = (PVRSRV_STUB_PBDESC *) pvParam;
+	struct PVRSRV_STUB_PBDESC *psStubPBDesc =
+					(struct PVRSRV_STUB_PBDESC *)pvParam;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
 	return SGXCleanupSharedPBDescKM(psStubPBDesc);
 }
 
-static PVRSRV_ERROR SGXCleanupSharedPBDescCreateLockCallback(IMG_PVOID pvParam,
-							     IMG_UINT32
-							     ui32Param)
+static enum PVRSRV_ERROR SGXCleanupSharedPBDescCreateLockCallback(void *pvParam,
+							     u32 ui32Param)
 {
 #ifdef DEBUG
-	PVRSRV_PER_PROCESS_DATA *psPerProc =
-	    (PVRSRV_PER_PROCESS_DATA *) pvParam;
+	struct PVRSRV_PER_PROCESS_DATA *psPerProc =
+	    (struct PVRSRV_PER_PROCESS_DATA *)pvParam;
 #else
 	PVR_UNREFERENCED_PARAMETER(pvParam);
 #endif
@@ -284,120 +267,116 @@
 
 	PVR_ASSERT(psPerProc == psPerProcCreateSharedPB);
 
-	psPerProcCreateSharedPB = IMG_NULL;
-	psResItemCreateSharedPB = IMG_NULL;
+	psPerProcCreateSharedPB = NULL;
+	psResItemCreateSharedPB = NULL;
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT PVRSRV_ERROR SGXUnrefSharedPBDescKM(IMG_HANDLE hSharedPBDesc)
+enum PVRSRV_ERROR SGXUnrefSharedPBDescKM(void *hSharedPBDesc)
 {
-	PVR_ASSERT(hSharedPBDesc != IMG_NULL);
+	PVR_ASSERT(hSharedPBDesc != NULL);
 
-	return ResManFreeResByPtr(hSharedPBDesc);
+	ResManFreeResByPtr(hSharedPBDesc);
+	return PVRSRV_OK;
 }
 
-IMG_EXPORT PVRSRV_ERROR
-SGXAddSharedPBDescKM(PVRSRV_PER_PROCESS_DATA * psPerProc,
-		     IMG_HANDLE hDevCookie,
-		     PVRSRV_KERNEL_MEM_INFO * psSharedPBDescKernelMemInfo,
-		     PVRSRV_KERNEL_MEM_INFO * psHWPBDescKernelMemInfo,
-		     PVRSRV_KERNEL_MEM_INFO * psBlockKernelMemInfo,
-		     IMG_UINT32 ui32TotalPBSize,
-		     IMG_HANDLE * phSharedPBDesc,
-		     PVRSRV_KERNEL_MEM_INFO ** ppsSharedPBDescSubKernelMemInfos,
-		     IMG_UINT32 ui32SharedPBDescSubKernelMemInfosCount)
+enum PVRSRV_ERROR SGXAddSharedPBDescKM(
+	struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+	void *hDevCookie,
+	struct PVRSRV_KERNEL_MEM_INFO *psSharedPBDescKernelMemInfo,
+	struct PVRSRV_KERNEL_MEM_INFO *psHWPBDescKernelMemInfo,
+	struct PVRSRV_KERNEL_MEM_INFO *psBlockKernelMemInfo,
+	u32 ui32TotalPBSize, void **phSharedPBDesc,
+	struct PVRSRV_KERNEL_MEM_INFO **ppsSharedPBDescSubKernelMemInfos,
+	u32 ui32SharedPBDescSubKernelMemInfosCount)
 {
-	PVRSRV_STUB_PBDESC *psStubPBDesc = IMG_NULL;
-	PVRSRV_ERROR eRet = PVRSRV_ERROR_GENERIC;
-	IMG_UINT32 i;
-	PVRSRV_SGXDEV_INFO *psSGXDevInfo;
-	PRESMAN_ITEM psResItem;
+	struct PVRSRV_STUB_PBDESC *psStubPBDesc = NULL;
+	enum PVRSRV_ERROR eRet = PVRSRV_ERROR_GENERIC;
+	u32 i;
+	struct PVRSRV_SGXDEV_INFO *psSGXDevInfo;
+	struct RESMAN_ITEM *psResItem;
 
 	if (psPerProcCreateSharedPB != psPerProc) {
 		goto NoAdd;
 	} else {
-		PVR_ASSERT(psResItemCreateSharedPB != IMG_NULL);
+		PVR_ASSERT(psResItemCreateSharedPB != NULL);
 
 		ResManFreeResByPtr(psResItemCreateSharedPB);
 
-		PVR_ASSERT(psResItemCreateSharedPB == IMG_NULL);
-		PVR_ASSERT(psPerProcCreateSharedPB == IMG_NULL);
+		PVR_ASSERT(psResItemCreateSharedPB == NULL);
+		PVR_ASSERT(psPerProcCreateSharedPB == NULL);
 	}
 
-	psSGXDevInfo =
-	    (PVRSRV_SGXDEV_INFO *) ((PVRSRV_DEVICE_NODE *) hDevCookie)->
-	    pvDevice;
+	psSGXDevInfo = (struct PVRSRV_SGXDEV_INFO *)
+		((struct PVRSRV_DEVICE_NODE *)hDevCookie)->pvDevice;
 
 	psStubPBDesc = psSGXDevInfo->psStubPBDescListKM;
-	if (psStubPBDesc != IMG_NULL) {
-		if (psStubPBDesc->ui32TotalPBSize != ui32TotalPBSize) {
-			PVR_DPF((PVR_DBG_WARNING,
-				 "SGXAddSharedPBDescKM: Shared PB requested with different size (0x%x) from existing shared PB (0x%x) - requested size ignored",
+	if (psStubPBDesc != NULL) {
+		if (psStubPBDesc->ui32TotalPBSize != ui32TotalPBSize)
+			PVR_DPF(PVR_DBG_WARNING, "SGXAddSharedPBDescKM: "
+				"Shared PB requested with different size "
+				"(0x%x) from existing shared PB (0x%x) - "
+				"requested size ignored",
 				 ui32TotalPBSize,
-				 psStubPBDesc->ui32TotalPBSize));
+				 psStubPBDesc->ui32TotalPBSize);
 
-		}
 		{
 
 			psResItem = ResManRegisterRes(psPerProc->hResManContext,
-						      RESMAN_TYPE_SHARED_PB_DESC,
-						      psStubPBDesc,
-						      0,
-						      &SGXCleanupSharedPBDescCallback);
-			if (psResItem == IMG_NULL) {
-				PVR_DPF((PVR_DBG_ERROR,
+					      RESMAN_TYPE_SHARED_PB_DESC,
+					      psStubPBDesc, 0,
+					      &SGXCleanupSharedPBDescCallback);
+			if (psResItem == NULL) {
+				PVR_DPF(PVR_DBG_ERROR,
 					 "SGXAddSharedPBDescKM: "
 					 "Failed to register existing shared "
-					 "PBDesc with the resource manager"));
+					 "PBDesc with the resource manager");
 				goto NoAddKeepPB;
 			}
 
 			psStubPBDesc->ui32RefCount++;
 
-			*phSharedPBDesc = (IMG_HANDLE) psResItem;
+			*phSharedPBDesc = (void *) psResItem;
 			eRet = PVRSRV_OK;
 			goto NoAddKeepPB;
 		}
 	}
 
 	if (OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-		       sizeof(PVRSRV_STUB_PBDESC),
-		       (IMG_VOID **) & psStubPBDesc, 0) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR, "SGXAddSharedPBDescKM: Failed to alloc "
-			 "StubPBDesc"));
+		       sizeof(struct PVRSRV_STUB_PBDESC),
+		       (void **)&psStubPBDesc, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "SGXAddSharedPBDescKM: Failed to alloc "
+			 "StubPBDesc");
 		eRet = PVRSRV_ERROR_OUT_OF_MEMORY;
 		goto NoAdd;
 	}
 
-	psStubPBDesc->ppsSubKernelMemInfos = IMG_NULL;
+	psStubPBDesc->ppsSubKernelMemInfos = NULL;
 
 	if (OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-		       sizeof(PVRSRV_KERNEL_MEM_INFO *)
-		       * ui32SharedPBDescSubKernelMemInfosCount,
-		       (IMG_VOID **) & psStubPBDesc->ppsSubKernelMemInfos,
-		       0) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR, "SGXAddSharedPBDescKM: "
+		       sizeof(struct PVRSRV_KERNEL_MEM_INFO *) *
+					ui32SharedPBDescSubKernelMemInfosCount,
+		       (void **)&psStubPBDesc->ppsSubKernelMemInfos, NULL) !=
+			PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "SGXAddSharedPBDescKM: "
 			 "Failed to alloc "
-			 "StubPBDesc->ppsSubKernelMemInfos"));
+			 "StubPBDesc->ppsSubKernelMemInfos");
 		eRet = PVRSRV_ERROR_OUT_OF_MEMORY;
 		goto NoAdd;
 	}
 
 	if (PVRSRVDissociateMemFromResmanKM(psSharedPBDescKernelMemInfo)
-	    != PVRSRV_OK) {
+	    != PVRSRV_OK)
 		goto NoAdd;
-	}
 
 	if (PVRSRVDissociateMemFromResmanKM(psHWPBDescKernelMemInfo)
-	    != PVRSRV_OK) {
+	    != PVRSRV_OK)
 		goto NoAdd;
-	}
 
 	if (PVRSRVDissociateMemFromResmanKM(psBlockKernelMemInfo)
-	    != PVRSRV_OK) {
+	    != PVRSRV_OK)
 		goto NoAdd;
-	}
 
 	psStubPBDesc->ui32RefCount = 1;
 	psStubPBDesc->ui32TotalPBSize = ui32TotalPBSize;
@@ -413,9 +392,9 @@
 		if (PVRSRVDissociateMemFromResmanKM
 		    (ppsSharedPBDescSubKernelMemInfos[i])
 		    != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR, "SGXAddSharedPBDescKM: "
+			PVR_DPF(PVR_DBG_ERROR, "SGXAddSharedPBDescKM: "
 				 "Failed to dissociate shared PBDesc "
-				 "from process"));
+				 "from process");
 			goto NoAdd;
 		}
 	}
@@ -424,10 +403,10 @@
 				      RESMAN_TYPE_SHARED_PB_DESC,
 				      psStubPBDesc,
 				      0, &SGXCleanupSharedPBDescCallback);
-	if (psResItem == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR, "SGXAddSharedPBDescKM: "
+	if (psResItem == NULL) {
+		PVR_DPF(PVR_DBG_ERROR, "SGXAddSharedPBDescKM: "
 			 "Failed to register shared PBDesc "
-			 " with the resource manager"));
+			 " with the resource manager");
 		goto NoAdd;
 	}
 	psStubPBDesc->hDevCookie = hDevCookie;
@@ -435,27 +414,26 @@
 	psStubPBDesc->psNext = psSGXDevInfo->psStubPBDescListKM;
 	psSGXDevInfo->psStubPBDescListKM = psStubPBDesc;
 
-	*phSharedPBDesc = (IMG_HANDLE) psResItem;
+	*phSharedPBDesc = (void *) psResItem;
 
 	return PVRSRV_OK;
 
 NoAdd:
 	if (psStubPBDesc) {
-		if (psStubPBDesc->ppsSubKernelMemInfos) {
+		if (psStubPBDesc->ppsSubKernelMemInfos)
 			OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-				  sizeof(PVRSRV_KERNEL_MEM_INFO *)
-				  * ui32SharedPBDescSubKernelMemInfosCount,
-				  psStubPBDesc->ppsSubKernelMemInfos, 0);
-		}
+				  sizeof(struct PVRSRV_KERNEL_MEM_INFO *) *
+					ui32SharedPBDescSubKernelMemInfosCount,
+				  psStubPBDesc->ppsSubKernelMemInfos, NULL);
 		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-			  sizeof(PVRSRV_STUB_PBDESC), psStubPBDesc, 0);
+			  sizeof(struct PVRSRV_STUB_PBDESC), psStubPBDesc,
+			  NULL);
 	}
 
 NoAddKeepPB:
-	for (i = 0; i < ui32SharedPBDescSubKernelMemInfosCount; i++) {
+	for (i = 0; i < ui32SharedPBDescSubKernelMemInfosCount; i++)
 		PVRSRVFreeDeviceMemKM(hDevCookie,
 				      ppsSharedPBDescSubKernelMemInfos[i]);
-	}
 
 	PVRSRVFreeSharedSysMemoryKM(psSharedPBDescKernelMemInfo);
 	PVRSRVFreeDeviceMemKM(hDevCookie, psHWPBDescKernelMemInfo);
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/pdump.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/pdump.c
@@ -1,30 +1,30 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
-#if defined (PDUMP)
+#if defined(PDUMP)
 #include "sgxdefs.h"
 #include "services_headers.h"
 
@@ -38,111 +38,106 @@
 
 #include <linux/tty.h>
 
-static IMG_BOOL PDumpWriteString2(IMG_CHAR * pszString, IMG_UINT32 ui32Flags);
-static IMG_BOOL PDumpWriteILock(PDBG_STREAM psStream, IMG_UINT8 * pui8Data,
-				IMG_UINT32 ui32Count, IMG_UINT32 ui32Flags);
-static IMG_VOID DbgSetFrame(PDBG_STREAM psStream, IMG_UINT32 ui32Frame);
-static IMG_UINT32 DbgGetFrame(PDBG_STREAM psStream);
-static IMG_VOID DbgSetMarker(PDBG_STREAM psStream, IMG_UINT32 ui32Marker);
-static IMG_UINT32 DbgWrite(PDBG_STREAM psStream, IMG_UINT8 * pui8Data,
-			   IMG_UINT32 ui32BCount, IMG_UINT32 ui32Flags);
+static IMG_BOOL PDumpWriteString2(char *pszString, u32 ui32Flags);
+static IMG_BOOL PDumpWriteILock(struct DBG_STREAM *psStream, u8 *pui8Data,
+				u32 ui32Count, u32 ui32Flags);
+static void DbgSetFrame(struct DBG_STREAM *psStream, u32 ui32Frame);
+static u32 DbgGetFrame(struct DBG_STREAM *psStream);
+static void DbgSetMarker(struct DBG_STREAM *psStream, u32 ui32Marker);
+static u32 DbgWrite(struct DBG_STREAM *psStream, u8 *pui8Data,
+			   u32 ui32BCount, u32 ui32Flags);
 
 #define PDUMP_DATAMASTER_PIXEL		(1)
 
-#define MIN(a,b)       (a > b ? b : a)
+#define MIN(a, b)       (a > b ? b : a)
 
 #define MAX_FILE_SIZE	0x40000000
 
-static IMG_UINT32 gui32PDumpSuspended = 0;
+static u32 gui32PDumpSuspended;
 
-static PDBGKM_SERVICE_TABLE gpfnDbgDrv = IMG_NULL;
+static struct DBGKM_SERVICE_TABLE *gpfnDbgDrv;
 
 #define PDUMP_STREAM_PARAM2			0
 #define PDUMP_STREAM_SCRIPT2		1
 #define PDUMP_STREAM_DRIVERINFO		2
 #define PDUMP_NUM_STREAMS			3
 
-IMG_CHAR *pszStreamName[PDUMP_NUM_STREAMS] = { "ParamStream2",
+char *pszStreamName[PDUMP_NUM_STREAMS] = { "ParamStream2",
 	"ScriptStream2",
 	"DriverInfoStream"
 };
 
-#define __PDBG_PDUMP_STATE_GET_MSG_STRING(ERROR) \
-    	IMG_CHAR *pszMsg = gsDBGPdumpState.pszMsg; \
-	if(!pszMsg) return ERROR
-
-#define __PDBG_PDUMP_STATE_GET_SCRIPT_STRING(ERROR) \
-    	IMG_CHAR *pszScript = gsDBGPdumpState.pszScript; \
-	if(!pszScript) return ERROR
-
-#define __PDBG_PDUMP_STATE_GET_SCRIPT_AND_FILE_STRING(ERROR) \
-    	IMG_CHAR *pszScript = gsDBGPdumpState.pszScript; \
-    	IMG_CHAR *pszFile = gsDBGPdumpState.pszFile; \
-	if(!pszScript || !pszFile) return ERROR
-
-typedef struct PDBG_PDUMP_STATE_TAG {
-	PDBG_STREAM psStream[PDUMP_NUM_STREAMS];
-	IMG_UINT32 ui32ParamFileNum;
-
-	IMG_CHAR *pszMsg;
-	IMG_CHAR *pszScript;
-	IMG_CHAR *pszFile;
-
-} PDBG_PDUMP_STATE;
+#define __PDBG_PDUMP_STATE_GET_MSG_STRING(ERROR)	\
+	char *pszMsg = gsDBGPdumpState.pszMsg;		\
+	if (!pszMsg)					\
+		return ERROR
+
+#define __PDBG_PDUMP_STATE_GET_SCRIPT_STRING(ERROR)	\
+	char *pszScript = gsDBGPdumpState.pszScript;	\
+	if (!pszScript)					\
+		return ERROR
+
+#define __PDBG_PDUMP_STATE_GET_SCRIPT_AND_FILE_STRING(ERROR)	\
+	char *pszScript = gsDBGPdumpState.pszScript;		\
+	char *pszFile = gsDBGPdumpState.pszFile;		\
+	if (!pszScript || !pszFile)				\
+		return ERROR
+
+struct PDBG_PDUMP_STATE {
+	struct DBG_STREAM *psStream[PDUMP_NUM_STREAMS];
+	u32 ui32ParamFileNum;
+
+	char *pszMsg;
+	char *pszScript;
+	char *pszFile;
 
-static PDBG_PDUMP_STATE gsDBGPdumpState =
-    { {IMG_NULL}, 0, IMG_NULL, IMG_NULL, IMG_NULL };
+};
 
-#define SZ_MSG_SIZE_MAX			PVRSRV_PDUMP_MAX_COMMENT_SIZE-1
-#define SZ_SCRIPT_SIZE_MAX		PVRSRV_PDUMP_MAX_COMMENT_SIZE-1
-#define SZ_FILENAME_SIZE_MAX	PVRSRV_PDUMP_MAX_COMMENT_SIZE-1
+static struct PDBG_PDUMP_STATE gsDBGPdumpState = {
+	{NULL}, 0, NULL, NULL, NULL
+};
 
-void DBGDrvGetServiceTable(IMG_VOID ** fn_table);
+#define SZ_MSG_SIZE_MAX			(PVRSRV_PDUMP_MAX_COMMENT_SIZE - 1)
+#define SZ_SCRIPT_SIZE_MAX		(PVRSRV_PDUMP_MAX_COMMENT_SIZE - 1)
+#define SZ_FILENAME_SIZE_MAX		(PVRSRV_PDUMP_MAX_COMMENT_SIZE - 1)
 
-IMG_VOID PDumpInit(IMG_VOID)
+void PDumpInit(void)
 {
-	IMG_UINT32 i = 0;
+	u32 i = 0;
 
 	if (!gpfnDbgDrv) {
-		DBGDrvGetServiceTable((IMG_VOID **) & gpfnDbgDrv);
+		DBGDrvGetServiceTable((void **) &gpfnDbgDrv);
 
-		if (gpfnDbgDrv == IMG_NULL) {
+		if (gpfnDbgDrv == NULL)
 			return;
-		}
 
-		if (!gsDBGPdumpState.pszFile) {
+		if (!gsDBGPdumpState.pszFile)
 			if (OSAllocMem
 			    (PVRSRV_OS_PAGEABLE_HEAP, SZ_FILENAME_SIZE_MAX,
-			     (IMG_PVOID *) & gsDBGPdumpState.pszFile,
-			     0) != PVRSRV_OK) {
+			     (void **) &gsDBGPdumpState.pszFile,
+			     0) != PVRSRV_OK)
 				goto init_failed;
-			}
-		}
 
-		if (!gsDBGPdumpState.pszMsg) {
+		if (!gsDBGPdumpState.pszMsg)
 			if (OSAllocMem
 			    (PVRSRV_OS_PAGEABLE_HEAP, SZ_MSG_SIZE_MAX,
-			     (IMG_PVOID *) & gsDBGPdumpState.pszMsg,
-			     0) != PVRSRV_OK) {
+			     (void **) &gsDBGPdumpState.pszMsg,
+			     0) != PVRSRV_OK)
 				goto init_failed;
-			}
-		}
 
-		if (!gsDBGPdumpState.pszScript) {
+		if (!gsDBGPdumpState.pszScript)
 			if (OSAllocMem
 			    (PVRSRV_OS_PAGEABLE_HEAP, SZ_SCRIPT_SIZE_MAX,
-			     (IMG_PVOID *) & gsDBGPdumpState.pszScript,
-			     0) != PVRSRV_OK) {
+			     (void **) &gsDBGPdumpState.pszScript,
+			     0) != PVRSRV_OK)
 				goto init_failed;
-			}
-		}
 
 		for (i = 0; i < PDUMP_NUM_STREAMS; i++) {
 			gsDBGPdumpState.psStream[i] =
 			    gpfnDbgDrv->pfnCreateStream(pszStreamName[i],
-							DEBUG_CAPMODE_FRAMED,
-							DEBUG_OUTMODE_STREAMENABLE,
-							0, 10);
+						DEBUG_CAPMODE_FRAMED,
+						DEBUG_OUTMODE_STREAMENABLE,
+						0, 10);
 
 			gpfnDbgDrv->pfnSetCaptureMode(gsDBGPdumpState.
 						      psStream[i],
@@ -164,101 +159,97 @@
 
 	if (gsDBGPdumpState.pszFile) {
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_FILENAME_SIZE_MAX,
-			  (IMG_PVOID) gsDBGPdumpState.pszFile, 0);
-		gsDBGPdumpState.pszFile = IMG_NULL;
+			  (void *) gsDBGPdumpState.pszFile, 0);
+		gsDBGPdumpState.pszFile = NULL;
 	}
 
 	if (gsDBGPdumpState.pszScript) {
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_SCRIPT_SIZE_MAX,
-			  (IMG_PVOID) gsDBGPdumpState.pszScript, 0);
-		gsDBGPdumpState.pszScript = IMG_NULL;
+			  (void *) gsDBGPdumpState.pszScript, 0);
+		gsDBGPdumpState.pszScript = NULL;
 	}
 
 	if (gsDBGPdumpState.pszMsg) {
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_MSG_SIZE_MAX,
-			  (IMG_PVOID) gsDBGPdumpState.pszMsg, 0);
-		gsDBGPdumpState.pszMsg = IMG_NULL;
+			  (void *) gsDBGPdumpState.pszMsg, 0);
+		gsDBGPdumpState.pszMsg = NULL;
 	}
 
-	gpfnDbgDrv = IMG_NULL;
+	gpfnDbgDrv = NULL;
 }
 
-IMG_VOID PDumpDeInit(IMG_VOID)
+void PDumpDeInit(void)
 {
-	IMG_UINT32 i = 0;
+	u32 i = 0;
 
-	for (i = 0; i < PDUMP_NUM_STREAMS; i++) {
+	for (i = 0; i < PDUMP_NUM_STREAMS; i++)
 		gpfnDbgDrv->pfnDestroyStream(gsDBGPdumpState.psStream[i]);
-	}
 
 	if (gsDBGPdumpState.pszFile) {
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_FILENAME_SIZE_MAX,
-			  (IMG_PVOID) gsDBGPdumpState.pszFile, 0);
-		gsDBGPdumpState.pszFile = IMG_NULL;
+			  (void *) gsDBGPdumpState.pszFile, 0);
+		gsDBGPdumpState.pszFile = NULL;
 	}
 
 	if (gsDBGPdumpState.pszScript) {
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_SCRIPT_SIZE_MAX,
-			  (IMG_PVOID) gsDBGPdumpState.pszScript, 0);
-		gsDBGPdumpState.pszScript = IMG_NULL;
+			  (void *) gsDBGPdumpState.pszScript, 0);
+		gsDBGPdumpState.pszScript = NULL;
 	}
 
 	if (gsDBGPdumpState.pszMsg) {
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, SZ_MSG_SIZE_MAX,
-			  (IMG_PVOID) gsDBGPdumpState.pszMsg, 0);
-		gsDBGPdumpState.pszMsg = IMG_NULL;
+			  (void *) gsDBGPdumpState.pszMsg, 0);
+		gsDBGPdumpState.pszMsg = NULL;
 	}
 
-	gpfnDbgDrv = IMG_NULL;
+	gpfnDbgDrv = NULL;
 }
 
-IMG_VOID PDumpEndInitPhase(IMG_VOID)
+void PDumpEndInitPhase(void)
 {
-	IMG_UINT32 i;
+	u32 i;
 
 	PDUMPCOMMENT("End of Init Phase");
 
-	for (i = 0; i < PDUMP_NUM_STREAMS; i++) {
+	for (i = 0; i < PDUMP_NUM_STREAMS; i++)
 		gpfnDbgDrv->pfnEndInitPhase(gsDBGPdumpState.psStream[i]);
-	}
 }
 
-void PDumpComment(IMG_CHAR * pszFormat, ...)
+void PDumpComment(char *pszFormat, ...)
 {
 	__PDBG_PDUMP_STATE_GET_MSG_STRING();
 
 	vsnprintf(pszMsg, SZ_MSG_SIZE_MAX, pszFormat,
-		  (IMG_CHAR *) (&pszFormat + 1));
+		  (char *) (&pszFormat + 1));
 
 	PDumpCommentKM(pszMsg, PDUMP_FLAGS_CONTINUOUS);
 }
 
-void PDumpCommentWithFlags(IMG_UINT32 ui32Flags, IMG_CHAR * pszFormat, ...)
+void PDumpCommentWithFlags(u32 ui32Flags, char *pszFormat, ...)
 {
 	__PDBG_PDUMP_STATE_GET_MSG_STRING();
 
 	vsnprintf(pszMsg, SZ_MSG_SIZE_MAX, pszFormat,
-		  (IMG_CHAR *) (&pszFormat + 1));
+		  (char *) (&pszFormat + 1));
 
 	PDumpCommentKM(pszMsg, ui32Flags);
 }
 
-IMG_BOOL PDumpIsLastCaptureFrameKM(IMG_VOID)
+IMG_BOOL PDumpIsLastCaptureFrameKM(void)
 {
-	return gpfnDbgDrv->pfnIsLastCaptureFrame(gsDBGPdumpState.
-						 psStream
-						 [PDUMP_STREAM_SCRIPT2]);
+	return gpfnDbgDrv->pfnIsLastCaptureFrame(
+				gsDBGPdumpState.psStream[PDUMP_STREAM_SCRIPT2]);
 }
 
-IMG_BOOL PDumpIsCaptureFrameKM(IMG_VOID)
+IMG_BOOL PDumpIsCaptureFrameKM(void)
 {
-	return gpfnDbgDrv->pfnIsCaptureFrame(gsDBGPdumpState.
-					     psStream[PDUMP_STREAM_SCRIPT2],
-					     IMG_FALSE);
+	return gpfnDbgDrv->pfnIsCaptureFrame(
+			gsDBGPdumpState.psStream[PDUMP_STREAM_SCRIPT2],
+			IMG_FALSE);
 }
 
-PVRSRV_ERROR PDumpRegWithFlagsKM(IMG_UINT32 ui32Reg, IMG_UINT32 ui32Data,
-				 IMG_UINT32 ui32Flags)
+enum PVRSRV_ERROR PDumpRegWithFlagsKM(u32 ui32Reg, u32 ui32Data, u32 ui32Flags)
 {
 	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING(PVRSRV_ERROR_GENERIC);
 
@@ -269,7 +260,7 @@
 	return PVRSRV_OK;
 }
 
-void PDumpReg(IMG_UINT32 ui32Reg, IMG_UINT32 ui32Data)
+void PDumpReg(u32 ui32Reg, u32 ui32Data)
 {
 	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
 
@@ -278,15 +269,14 @@
 	PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
 }
 
-PVRSRV_ERROR PDumpRegPolWithFlagsKM(IMG_UINT32 ui32RegAddr,
-				    IMG_UINT32 ui32RegValue,
-				    IMG_UINT32 ui32Mask, IMG_UINT32 ui32Flags)
+enum PVRSRV_ERROR PDumpRegPolWithFlagsKM(u32 ui32RegAddr, u32 ui32RegValue,
+				    u32 ui32Mask, u32 ui32Flags)
 {
 #define POLL_DELAY			1000
 #define POLL_COUNT_LONG		(2000000000 / POLL_DELAY)
 #define POLL_COUNT_SHORT	(1000000 / POLL_DELAY)
 
-	IMG_UINT32 ui32PollCount;
+	u32 ui32PollCount;
 	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING(PVRSRV_ERROR_GENERIC);
 
 	if (((ui32RegAddr == EUR_CR_EVENT_STATUS) &&
@@ -296,11 +286,10 @@
 		    EUR_CR_EVENT_STATUS_PIXELBE_END_RENDER_MASK))
 	    || ((ui32RegAddr == EUR_CR_EVENT_STATUS)
 		&& (ui32RegValue & ui32Mask &
-		    EUR_CR_EVENT_STATUS_DPM_3D_MEM_FREE_MASK))) {
+		    EUR_CR_EVENT_STATUS_DPM_3D_MEM_FREE_MASK)))
 		ui32PollCount = POLL_COUNT_LONG;
-	} else {
+	else
 		ui32PollCount = POLL_COUNT_SHORT;
-	}
 
 	snprintf(pszScript, SZ_SCRIPT_SIZE_MAX,
 		 "POL :SGXREG:0x%8.8lX 0x%8.8lX 0x%8.8lX %d %lu %d\r\n",
@@ -311,30 +300,27 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PDumpRegPolKM(IMG_UINT32 ui32RegAddr, IMG_UINT32 ui32RegValue,
-			   IMG_UINT32 ui32Mask)
+enum PVRSRV_ERROR PDumpRegPolKM(u32 ui32RegAddr, u32 ui32RegValue, u32 ui32Mask)
 {
 	return PDumpRegPolWithFlagsKM(ui32RegAddr, ui32RegValue, ui32Mask,
 				      PDUMP_FLAGS_CONTINUOUS);
 }
 
-IMG_VOID PDumpMallocPages(PVRSRV_DEVICE_TYPE eDeviceType,
-			  IMG_UINT32 ui32DevVAddr,
-			  IMG_CPU_VIRTADDR pvLinAddr,
-			  IMG_HANDLE hOSMemHandle,
-			  IMG_UINT32 ui32NumBytes, IMG_HANDLE hUniqueTag)
-{
-	IMG_UINT32 ui32Offset;
-	IMG_UINT32 ui32NumPages;
-	IMG_CPU_PHYADDR sCpuPAddr;
-	IMG_DEV_PHYADDR sDevPAddr;
-	IMG_UINT32 ui32Page;
+void PDumpMallocPages(enum PVRSRV_DEVICE_TYPE eDeviceType, u32 ui32DevVAddr,
+		      void *pvLinAddr, void *hOSMemHandle, u32 ui32NumBytes,
+		      void *hUniqueTag)
+{
+	u32 ui32Offset;
+	u32 ui32NumPages;
+	struct IMG_CPU_PHYADDR sCpuPAddr;
+	struct IMG_DEV_PHYADDR sDevPAddr;
+	u32 ui32Page;
 	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
 	PVR_UNREFERENCED_PARAMETER(pvLinAddr);
 
-	PVR_ASSERT(((IMG_UINT32) ui32DevVAddr & (SGX_MMU_PAGE_SIZE - 1)) == 0);
+	PVR_ASSERT(((u32) ui32DevVAddr & (SGX_MMU_PAGE_SIZE - 1)) == 0);
 	PVR_ASSERT(hOSMemHandle);
-	PVR_ASSERT(((IMG_UINT32) ui32NumBytes & (SGX_MMU_PAGE_SIZE - 1)) == 0);
+	PVR_ASSERT(((u32) ui32NumBytes & (SGX_MMU_PAGE_SIZE - 1)) == 0);
 
 	snprintf(pszScript, SZ_SCRIPT_SIZE_MAX,
 		 "-- MALLOC :SGXMEM:VA_%8.8lX 0x%8.8lX %lu\r\n", ui32DevVAddr,
@@ -359,26 +345,26 @@
 	}
 }
 
-IMG_VOID PDumpMallocPageTable(PVRSRV_DEVICE_TYPE eDeviceType,
-			      IMG_CPU_VIRTADDR pvLinAddr,
-			      IMG_UINT32 ui32NumBytes, IMG_HANDLE hUniqueTag)
-{
-	IMG_PUINT8 pui8LinAddr;
-	IMG_UINT32 ui32NumPages;
-	IMG_CPU_PHYADDR sCpuPAddr;
-	IMG_DEV_PHYADDR sDevPAddr;
-	IMG_UINT32 ui32Page;
+void PDumpMallocPageTable(enum PVRSRV_DEVICE_TYPE eDeviceType,
+			      void *pvLinAddr, u32 ui32NumBytes,
+			      void *hUniqueTag)
+{
+	u8 *pui8LinAddr;
+	u32 ui32NumPages;
+	struct IMG_CPU_PHYADDR sCpuPAddr;
+	struct IMG_DEV_PHYADDR sDevPAddr;
+	u32 ui32Page;
 	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
 
-	PVR_ASSERT(((IMG_UINT32) pvLinAddr & (SGX_MMU_PAGE_SIZE - 1)) == 0);
-	PVR_ASSERT(((IMG_UINT32) ui32NumBytes & (SGX_MMU_PAGE_SIZE - 1)) == 0);
+	PVR_ASSERT(((u32) pvLinAddr & (SGX_MMU_PAGE_SIZE - 1)) == 0);
+	PVR_ASSERT(((u32) ui32NumBytes & (SGX_MMU_PAGE_SIZE - 1)) == 0);
 
 	snprintf(pszScript, SZ_SCRIPT_SIZE_MAX,
 		 "-- MALLOC :SGXMEM:PAGE_TABLE 0x%8.8lX %lu\r\n", ui32NumBytes,
 		 SGX_MMU_PAGE_SIZE);
 	PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
 
-	pui8LinAddr = (IMG_PUINT8) pvLinAddr;
+	pui8LinAddr = (u8 *) pvLinAddr;
 	ui32NumPages = ui32NumBytes >> SGX_MMU_PAGE_SHIFT;
 	while (ui32NumPages--) {
 		sCpuPAddr = OSMapLinToCPUPhys(pui8LinAddr);
@@ -395,19 +381,17 @@
 	}
 }
 
-IMG_VOID PDumpFreePages(BM_HEAP * psBMHeap,
-			IMG_DEV_VIRTADDR sDevVAddr,
-			IMG_UINT32 ui32NumBytes,
-			IMG_HANDLE hUniqueTag, IMG_BOOL bInterleaved)
-{
-	IMG_UINT32 ui32NumPages, ui32PageCounter;
-	IMG_DEV_PHYADDR sDevPAddr;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
+void PDumpFreePages(struct BM_HEAP *psBMHeap, struct IMG_DEV_VIRTADDR sDevVAddr,
+		    u32 ui32NumBytes, void *hUniqueTag, IMG_BOOL bInterleaved)
+{
+	u32 ui32NumPages, ui32PageCounter;
+	struct IMG_DEV_PHYADDR sDevPAddr;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
 	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
 
-	PVR_ASSERT(((IMG_UINT32) sDevVAddr.uiAddr & (SGX_MMU_PAGE_SIZE - 1)) ==
+	PVR_ASSERT(((u32) sDevVAddr.uiAddr & (SGX_MMU_PAGE_SIZE - 1)) ==
 		   0);
-	PVR_ASSERT(((IMG_UINT32) ui32NumBytes & (SGX_MMU_PAGE_SIZE - 1)) == 0);
+	PVR_ASSERT(((u32) ui32NumBytes & (SGX_MMU_PAGE_SIZE - 1)) == 0);
 
 	snprintf(pszScript, SZ_SCRIPT_SIZE_MAX, "-- FREE :SGXMEM:VA_%8.8lX\r\n",
 		 sDevVAddr.uiAddr);
@@ -435,25 +419,24 @@
 	}
 }
 
-IMG_VOID PDumpFreePageTable(PVRSRV_DEVICE_TYPE eDeviceType,
-			    IMG_CPU_VIRTADDR pvLinAddr,
-			    IMG_UINT32 ui32NumBytes, IMG_HANDLE hUniqueTag)
-{
-	IMG_PUINT8 pui8LinAddr;
-	IMG_UINT32 ui32NumPages;
-	IMG_CPU_PHYADDR sCpuPAddr;
-	IMG_DEV_PHYADDR sDevPAddr;
-	IMG_UINT32 ui32Page;
+void PDumpFreePageTable(enum PVRSRV_DEVICE_TYPE eDeviceType, void *pvLinAddr,
+			u32 ui32NumBytes, void *hUniqueTag)
+{
+	u8 *pui8LinAddr;
+	u32 ui32NumPages;
+	struct IMG_CPU_PHYADDR sCpuPAddr;
+	struct IMG_DEV_PHYADDR sDevPAddr;
+	u32 ui32Page;
 	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
 
-	PVR_ASSERT(((IMG_UINT32) pvLinAddr & (SGX_MMU_PAGE_SIZE - 1)) == 0);
-	PVR_ASSERT(((IMG_UINT32) ui32NumBytes & (SGX_MMU_PAGE_SIZE - 1)) == 0);
+	PVR_ASSERT(((u32) pvLinAddr & (SGX_MMU_PAGE_SIZE - 1)) == 0);
+	PVR_ASSERT(((u32) ui32NumBytes & (SGX_MMU_PAGE_SIZE - 1)) == 0);
 
 	snprintf(pszScript, SZ_SCRIPT_SIZE_MAX,
 		 "-- FREE :SGXMEM:PAGE_TABLE\r\n");
 	PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
 
-	pui8LinAddr = (IMG_PUINT8) pvLinAddr;
+	pui8LinAddr = (u8 *) pvLinAddr;
 	ui32NumPages = ui32NumBytes >> SGX_MMU_PAGE_SHIFT;
 	while (ui32NumPages--) {
 		sCpuPAddr = OSMapLinToCPUPhys(pui8LinAddr);
@@ -468,8 +451,7 @@
 	}
 }
 
-IMG_VOID PDumpPDReg(IMG_UINT32 ui32Reg,
-		    IMG_UINT32 ui32Data, IMG_HANDLE hUniqueTag)
+void PDumpPDReg(u32 ui32Reg, u32 ui32Data, void *hUniqueTag)
 {
 	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
 
@@ -483,9 +465,8 @@
 	PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
 }
 
-IMG_VOID PDumpPDRegWithFlags(IMG_UINT32 ui32Reg,
-			     IMG_UINT32 ui32Data,
-			     IMG_UINT32 ui32Flags, IMG_HANDLE hUniqueTag)
+void PDumpPDRegWithFlags(u32 ui32Reg, u32 ui32Data, u32 ui32Flags,
+			 void *hUniqueTag)
 {
 	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
 
@@ -499,43 +480,38 @@
 	PDumpWriteString2(pszScript, ui32Flags);
 }
 
-PVRSRV_ERROR PDumpMemPolKM(PVRSRV_KERNEL_MEM_INFO * psMemInfo,
-			   IMG_UINT32 ui32Offset,
-			   IMG_UINT32 ui32Value,
-			   IMG_UINT32 ui32Mask,
-			   PDUMP_POLL_OPERATOR eOperator,
-			   IMG_BOOL bLastFrame,
-			   IMG_BOOL bOverwrite, IMG_HANDLE hUniqueTag)
+enum PVRSRV_ERROR PDumpMemPolKM(struct PVRSRV_KERNEL_MEM_INFO *psMemInfo,
+			   u32 ui32Offset, u32 ui32Value, u32 ui32Mask,
+			   enum PDUMP_POLL_OPERATOR eOperator,
+			   IMG_BOOL bLastFrame, IMG_BOOL bOverwrite,
+			   void *hUniqueTag)
 {
 #define MEMPOLL_DELAY		(1000)
 #define MEMPOLL_COUNT		(2000000000 / MEMPOLL_DELAY)
 
-	IMG_UINT32 ui32PageOffset;
-	IMG_DEV_PHYADDR sDevPAddr;
-	IMG_DEV_VIRTADDR sDevVPageAddr;
-	IMG_CPU_PHYADDR CpuPAddr;
-	IMG_UINT32 ui32Flags;
+	u32 ui32PageOffset;
+	struct IMG_DEV_PHYADDR sDevPAddr;
+	struct IMG_DEV_VIRTADDR sDevVPageAddr;
+	struct IMG_CPU_PHYADDR CpuPAddr;
+	u32 ui32Flags;
 	__PDBG_PDUMP_STATE_GET_SCRIPT_AND_FILE_STRING(PVRSRV_ERROR_GENERIC);
 
-	PVR_ASSERT((ui32Offset + sizeof(IMG_UINT32)) <=
+	PVR_ASSERT((ui32Offset + sizeof(u32)) <=
 		   psMemInfo->ui32AllocSize);
 
-	if (gsDBGPdumpState.ui32ParamFileNum == 0) {
+	if (gsDBGPdumpState.ui32ParamFileNum == 0)
 		snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "%%0%%.prm");
-	} else {
+	else
 		snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "%%0%%%lu.prm",
 			 gsDBGPdumpState.ui32ParamFileNum);
-	}
 
 	ui32Flags = 0;
 
-	if (bLastFrame) {
+	if (bLastFrame)
 		ui32Flags |= PDUMP_FLAGS_LASTFRAME;
-	}
 
-	if (bOverwrite) {
+	if (bOverwrite)
 		ui32Flags |= PDUMP_FLAGS_RESETLFBUFFER;
-	}
 
 	CpuPAddr =
 	    OSMemHandleToCpuPAddr(psMemInfo->sMemBlk.hOSMemHandle, ui32Offset);
@@ -550,7 +526,7 @@
 
 	snprintf(pszScript,
 		 SZ_SCRIPT_SIZE_MAX,
-		 "POL :SGXMEM:PA_%p%8.8lX:0x%8.8lX 0x%8.8lX 0x%8.8lX %d %d %d\r\n",
+	      "POL :SGXMEM:PA_%p%8.8lX:0x%8.8lX 0x%8.8lX 0x%8.8lX %d %d %d\r\n",
 		 hUniqueTag,
 		 sDevPAddr.uiAddr & ~(SGX_MMU_PAGE_SIZE - 1),
 		 sDevPAddr.uiAddr & (SGX_MMU_PAGE_SIZE - 1),
@@ -560,42 +536,40 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PDumpMemKM(IMG_PVOID pvAltLinAddr,
-			PVRSRV_KERNEL_MEM_INFO * psMemInfo,
-			IMG_UINT32 ui32Offset,
-			IMG_UINT32 ui32Bytes,
-			IMG_UINT32 ui32Flags, IMG_HANDLE hUniqueTag)
-{
-	IMG_UINT32 ui32PageByteOffset;
-	IMG_UINT8 *pui8DataLinAddr;
-	IMG_DEV_VIRTADDR sDevVPageAddr;
-	IMG_DEV_VIRTADDR sDevVAddr;
-	IMG_DEV_PHYADDR sDevPAddr;
-	IMG_CPU_PHYADDR CpuPAddr;
-	IMG_UINT32 ui32ParamOutPos;
-	IMG_UINT32 ui32CurrentOffset;
-	IMG_UINT32 ui32BytesRemaining;
-	LinuxMemArea *psLinuxMemArea;
-	LINUX_MEM_AREA_TYPE eRootAreaType;
-	IMG_CHAR *pui8TransientCpuVAddr;
+enum PVRSRV_ERROR PDumpMemKM(void *pvAltLinAddr,
+			struct PVRSRV_KERNEL_MEM_INFO *psMemInfo,
+			u32 ui32Offset, u32 ui32Bytes, u32 ui32Flags,
+			void *hUniqueTag)
+{
+	u32 ui32PageByteOffset;
+	u8 *pui8DataLinAddr;
+	struct IMG_DEV_VIRTADDR sDevVPageAddr;
+	struct IMG_DEV_VIRTADDR sDevVAddr;
+	struct IMG_DEV_PHYADDR sDevPAddr;
+	struct IMG_CPU_PHYADDR CpuPAddr;
+	u32 ui32ParamOutPos;
+	u32 ui32CurrentOffset;
+	u32 ui32BytesRemaining;
+	struct LinuxMemArea *psLinuxMemArea;
+	enum LINUX_MEM_AREA_TYPE eRootAreaType;
+	char *pui8TransientCpuVAddr;
 
 	__PDBG_PDUMP_STATE_GET_SCRIPT_AND_FILE_STRING(PVRSRV_ERROR_GENERIC);
 
 	PVR_ASSERT((ui32Offset + ui32Bytes) <= psMemInfo->ui32AllocSize);
 
-	if (ui32Bytes == 0 || gui32PDumpSuspended) {
+	if (ui32Bytes == 0 || gui32PDumpSuspended)
 		return PVRSRV_OK;
-	}
 
 	if (pvAltLinAddr) {
 		pui8DataLinAddr = pvAltLinAddr;
 	} else if (psMemInfo->pvLinAddrKM) {
 		pui8DataLinAddr =
-		    (IMG_UINT8 *) psMemInfo->pvLinAddrKM + ui32Offset;
+		    (u8 *) psMemInfo->pvLinAddrKM + ui32Offset;
 	} else {
 		pui8DataLinAddr = 0;
 		psLinuxMemArea =
-		    (LinuxMemArea *) psMemInfo->sMemBlk.hOSMemHandle;
+		    (struct LinuxMemArea *)psMemInfo->sMemBlk.hOSMemHandle;
 		eRootAreaType = LinuxMemAreaRootType(psLinuxMemArea);
 	}
 
@@ -606,12 +580,9 @@
 	if (pui8DataLinAddr) {
 		if (!PDumpWriteILock
 		    (gsDBGPdumpState.psStream[PDUMP_STREAM_PARAM2],
-		     pui8DataLinAddr, ui32Bytes, ui32Flags)) {
+		     pui8DataLinAddr, ui32Bytes, ui32Flags))
 			return PVRSRV_ERROR_GENERIC;
-		}
-	}
-
-	else if (eRootAreaType == LINUX_MEM_AREA_IO) {
+	} else if (eRootAreaType == LINUX_MEM_AREA_IO) {
 
 		CpuPAddr =
 		    OSMemHandleToCpuPAddr(psMemInfo->sMemBlk.hOSMemHandle,
@@ -633,7 +604,7 @@
 		ui32CurrentOffset = ui32Offset;
 
 		while (ui32BytesRemaining > 0) {
-			IMG_UINT32 ui32BlockBytes =
+			u32 ui32BlockBytes =
 			    MIN(ui32BytesRemaining, PAGE_SIZE);
 			struct page *psCurrentPage = NULL;
 
@@ -642,21 +613,19 @@
 						  hOSMemHandle,
 						  ui32CurrentOffset);
 
-			if (CpuPAddr.uiAddr & (PAGE_SIZE - 1)) {
+			if (CpuPAddr.uiAddr & (PAGE_SIZE - 1))
 				ui32BlockBytes =
 				    MIN(ui32BytesRemaining,
 					PAGE_ALIGN(CpuPAddr.uiAddr) -
 					CpuPAddr.uiAddr);
-			}
 
 			psCurrentPage =
 			    LinuxMemAreaOffsetToPage(psLinuxMemArea,
 						     ui32CurrentOffset);
 			pui8TransientCpuVAddr = KMapWrapper(psCurrentPage);
 			pui8TransientCpuVAddr += (CpuPAddr.uiAddr & ~PAGE_MASK);
-			if (!pui8TransientCpuVAddr) {
+			if (!pui8TransientCpuVAddr)
 				return PVRSRV_ERROR_GENERIC;
-			}
 
 			if (!PDumpWriteILock
 			    (gsDBGPdumpState.psStream[PDUMP_STREAM_PARAM2],
@@ -675,12 +644,11 @@
 
 	}
 
-	if (gsDBGPdumpState.ui32ParamFileNum == 0) {
+	if (gsDBGPdumpState.ui32ParamFileNum == 0)
 		snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "%%0%%.prm");
-	} else {
+	else
 		snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "%%0%%%lu.prm",
 			 gsDBGPdumpState.ui32ParamFileNum);
-	}
 
 	snprintf(pszScript,
 		 SZ_SCRIPT_SIZE_MAX,
@@ -700,7 +668,7 @@
 	ui32CurrentOffset = ui32Offset;
 
 	while (ui32BytesRemaining > 0) {
-		IMG_UINT32 ui32BlockBytes = MIN(ui32BytesRemaining, PAGE_SIZE);
+		u32 ui32BlockBytes = MIN(ui32BytesRemaining, PAGE_SIZE);
 		CpuPAddr =
 		    OSMemHandleToCpuPAddr(psMemInfo->sMemBlk.hOSMemHandle,
 					  ui32CurrentOffset);
@@ -723,7 +691,8 @@
 
 		snprintf(pszScript,
 			 SZ_SCRIPT_SIZE_MAX,
-			 "LDB :SGXMEM:PA_%p%8.8lX:0x%8.8lX 0x%8.8lX 0x%8.8lX %s\r\n",
+			 "LDB :SGXMEM:PA_%p%8.8lX:0x%8.8lX 0x%8.8lX "
+			 "0x%8.8lX %s\r\n",
 			 hUniqueTag,
 			 sDevPAddr.uiAddr & ~(SGX_MMU_PAGE_SIZE - 1),
 			 sDevPAddr.uiAddr & (SGX_MMU_PAGE_SIZE - 1),
@@ -739,33 +708,30 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PDumpMem2KM(PVRSRV_DEVICE_TYPE eDeviceType,
-			 IMG_CPU_VIRTADDR pvLinAddr,
-			 IMG_UINT32 ui32Bytes,
-			 IMG_UINT32 ui32Flags,
-			 IMG_BOOL bInitialisePages,
-			 IMG_HANDLE hUniqueTag1, IMG_HANDLE hUniqueTag2)
-{
-	IMG_UINT32 ui32NumPages;
-	IMG_UINT32 ui32PageOffset;
-	IMG_UINT32 ui32BlockBytes;
-	IMG_UINT8 *pui8LinAddr;
-	IMG_DEV_PHYADDR sDevPAddr;
-	IMG_CPU_PHYADDR sCpuPAddr;
-	IMG_UINT32 ui32Offset;
-	IMG_UINT32 ui32ParamOutPos;
+enum PVRSRV_ERROR PDumpMem2KM(enum PVRSRV_DEVICE_TYPE eDeviceType,
+			 void *pvLinAddr, u32 ui32Bytes, u32 ui32Flags,
+			 IMG_BOOL bInitialisePages, void *hUniqueTag1,
+			 void *hUniqueTag2)
+{
+	u32 ui32NumPages;
+	u32 ui32PageOffset;
+	u32 ui32BlockBytes;
+	u8 *pui8LinAddr;
+	struct IMG_DEV_PHYADDR sDevPAddr;
+	struct IMG_CPU_PHYADDR sCpuPAddr;
+	u32 ui32Offset;
+	u32 ui32ParamOutPos;
 
 	__PDBG_PDUMP_STATE_GET_SCRIPT_AND_FILE_STRING(PVRSRV_ERROR_GENERIC);
 
-	if (ui32Flags) ;
+	if (ui32Flags)
+		;
 
-	if (!pvLinAddr) {
+	if (!pvLinAddr)
 		return PVRSRV_ERROR_GENERIC;
-	}
 
-	if (gui32PDumpSuspended) {
+	if (gui32PDumpSuspended)
 		return PVRSRV_OK;
-	}
 
 	ui32ParamOutPos =
 	    gpfnDbgDrv->pfnGetStreamOffset(gsDBGPdumpState.
@@ -775,40 +741,38 @@
 
 		if (!PDumpWriteILock
 		    (gsDBGPdumpState.psStream[PDUMP_STREAM_PARAM2], pvLinAddr,
-		     ui32Bytes, PDUMP_FLAGS_CONTINUOUS)) {
+		     ui32Bytes, PDUMP_FLAGS_CONTINUOUS))
 			return PVRSRV_ERROR_GENERIC;
-		}
 
-		if (gsDBGPdumpState.ui32ParamFileNum == 0) {
+		if (gsDBGPdumpState.ui32ParamFileNum == 0)
 			snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "%%0%%.prm");
-		} else {
+		else
 			snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "%%0%%%lu.prm",
 				 gsDBGPdumpState.ui32ParamFileNum);
-		}
 	}
 
-	ui32PageOffset = (IMG_UINT32) pvLinAddr & (HOST_PAGESIZE() - 1);
+	ui32PageOffset = (u32) pvLinAddr & (HOST_PAGESIZE() - 1);
 	ui32NumPages =
 	    (ui32PageOffset + ui32Bytes + HOST_PAGESIZE() -
 	     1) / HOST_PAGESIZE();
-	pui8LinAddr = (IMG_UINT8 *) pvLinAddr;
+	pui8LinAddr = (u8 *) pvLinAddr;
 
 	while (ui32NumPages--) {
 		sCpuPAddr = OSMapLinToCPUPhys(pui8LinAddr);
 		sDevPAddr = SysCpuPAddrToDevPAddr(eDeviceType, sCpuPAddr);
 
-		if (ui32PageOffset + ui32Bytes > HOST_PAGESIZE()) {
+		if (ui32PageOffset + ui32Bytes > HOST_PAGESIZE())
 
 			ui32BlockBytes = HOST_PAGESIZE() - ui32PageOffset;
-		} else {
+		else
 
 			ui32BlockBytes = ui32Bytes;
-		}
 
 		if (bInitialisePages) {
 			snprintf(pszScript,
 				 SZ_SCRIPT_SIZE_MAX,
-				 "LDB :SGXMEM:PA_%p%8.8lX:0x%8.8lX 0x%8.8lX 0x%8.8lX %s\r\n",
+				 "LDB :SGXMEM:PA_%p%8.8lX:0x%8.8lX 0x%8.8lX "
+				 "0x%8.8lX %s\r\n",
 				 hUniqueTag1,
 				 sDevPAddr.uiAddr & ~(SGX_MMU_PAGE_SIZE - 1),
 				 sDevPAddr.uiAddr & (SGX_MMU_PAGE_SIZE - 1),
@@ -816,15 +780,17 @@
 			PDumpWriteString2(pszScript, PDUMP_FLAGS_CONTINUOUS);
 		} else {
 			for (ui32Offset = 0; ui32Offset < ui32BlockBytes;
-			     ui32Offset += sizeof(IMG_UINT32)) {
-				IMG_UINT32 ui32PTE =
-				    *((IMG_UINT32 *) (pui8LinAddr +
+			     ui32Offset += sizeof(u32)) {
+				u32 ui32PTE =
+				    *((u32 *) (pui8LinAddr +
 						      ui32Offset));
 
 				if ((ui32PTE & SGX_MMU_PDE_ADDR_MASK) != 0) {
 					snprintf(pszScript,
 						 SZ_SCRIPT_SIZE_MAX,
-						 "WRW :SGXMEM:PA_%p%8.8lX:0x%8.8lX :SGXMEM:PA_%p%8.8lX:0x%8.8lX\r\n",
+						 "WRW :SGXMEM:PA_%p%8.8lX:"
+						 "0x%8.8lX :SGXMEM:"
+						 "PA_%p%8.8lX:0x%8.8lX\r\n",
 						 hUniqueTag1,
 						 (sDevPAddr.uiAddr +
 						  ui32Offset) &
@@ -842,7 +808,8 @@
 						   (ui32PTE &
 						    SGX_MMU_PTE_VALID));
 					snprintf(pszScript, SZ_SCRIPT_SIZE_MAX,
-						 "WRW :SGXMEM:PA_%p%8.8lX:0x%8.8lX 0x%8.8lX%p\r\n",
+						 "WRW :SGXMEM:PA_%p%8.8lX:"
+						 "0x%8.8lX 0x%8.8lX%p\r\n",
 						 hUniqueTag1,
 						 (sDevPAddr.uiAddr +
 						  ui32Offset) &
@@ -858,28 +825,25 @@
 		}
 
 		ui32PageOffset = 0;
-
 		ui32Bytes -= ui32BlockBytes;
-
 		pui8LinAddr += ui32BlockBytes;
-
 		ui32ParamOutPos += ui32BlockBytes;
 	}
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PDumpPDDevPAddrKM(PVRSRV_KERNEL_MEM_INFO * psMemInfo,
-			       IMG_UINT32 ui32Offset,
-			       IMG_DEV_PHYADDR sPDDevPAddr,
-			       IMG_HANDLE hUniqueTag1, IMG_HANDLE hUniqueTag2)
-{
-	IMG_UINT32 ui32ParamOutPos;
-	IMG_CPU_PHYADDR CpuPAddr;
-	IMG_UINT32 ui32PageByteOffset;
-	IMG_DEV_VIRTADDR sDevVAddr;
-	IMG_DEV_VIRTADDR sDevVPageAddr;
-	IMG_DEV_PHYADDR sDevPAddr;
+enum PVRSRV_ERROR PDumpPDDevPAddrKM(struct PVRSRV_KERNEL_MEM_INFO *psMemInfo,
+			       u32 ui32Offset,
+			       struct IMG_DEV_PHYADDR sPDDevPAddr,
+			       void *hUniqueTag1, void *hUniqueTag2)
+{
+	u32 ui32ParamOutPos;
+	struct IMG_CPU_PHYADDR CpuPAddr;
+	u32 ui32PageByteOffset;
+	struct IMG_DEV_VIRTADDR sDevVAddr;
+	struct IMG_DEV_VIRTADDR sDevVPageAddr;
+	struct IMG_DEV_PHYADDR sDevPAddr;
 
 	__PDBG_PDUMP_STATE_GET_SCRIPT_AND_FILE_STRING(PVRSRV_ERROR_GENERIC);
 
@@ -888,17 +852,15 @@
 					   psStream[PDUMP_STREAM_PARAM2]);
 
 	if (!PDumpWriteILock(gsDBGPdumpState.psStream[PDUMP_STREAM_PARAM2],
-			     (IMG_UINT8 *) & sPDDevPAddr,
-			     sizeof(IMG_DEV_PHYADDR), PDUMP_FLAGS_CONTINUOUS)) {
+			     (u8 *)&sPDDevPAddr, sizeof(struct IMG_DEV_PHYADDR),
+			     PDUMP_FLAGS_CONTINUOUS))
 		return PVRSRV_ERROR_GENERIC;
-	}
 
-	if (gsDBGPdumpState.ui32ParamFileNum == 0) {
+	if (gsDBGPdumpState.ui32ParamFileNum == 0)
 		snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "%%0%%.prm");
-	} else {
+	else
 		snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "%%0%%%lu.prm",
 			 gsDBGPdumpState.ui32ParamFileNum);
-	}
 
 	CpuPAddr =
 	    OSMemHandleToCpuPAddr(psMemInfo->sMemBlk.hOSMemHandle, ui32Offset);
@@ -914,7 +876,8 @@
 	if ((sPDDevPAddr.uiAddr & SGX_MMU_PDE_ADDR_MASK) != 0) {
 		snprintf(pszScript,
 			 SZ_SCRIPT_SIZE_MAX,
-			 "WRW :SGXMEM:PA_%p%8.8lX:0x%8.8lX :SGXMEM:PA_%p%8.8lX:0x%8.8lX\r\n",
+			 "WRW :SGXMEM:PA_%p%8.8lX:0x%8.8lX :"
+			 "SGXMEM:PA_%p%8.8lX:0x%8.8lX\r\n",
 			 hUniqueTag1,
 			 sDevPAddr.uiAddr & ~(SGX_MMU_PAGE_SIZE - 1),
 			 sDevPAddr.uiAddr & (SGX_MMU_PAGE_SIZE - 1),
@@ -936,21 +899,21 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PDumpSetFrameKM(IMG_UINT32 ui32Frame)
+enum PVRSRV_ERROR PDumpSetFrameKM(u32 ui32Frame)
 {
-	IMG_UINT32 ui32Stream;
+	u32 ui32Stream;
 
 	for (ui32Stream = 0; ui32Stream < PDUMP_NUM_STREAMS; ui32Stream++) {
-		if (gsDBGPdumpState.psStream[ui32Stream]) {
+		if (gsDBGPdumpState.psStream[ui32Stream])
 			DbgSetFrame(gsDBGPdumpState.psStream[ui32Stream],
 				    ui32Frame);
-		}
+
 	}
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PDumpGetFrameKM(IMG_PUINT32 pui32Frame)
+enum PVRSRV_ERROR PDumpGetFrameKM(u32 *pui32Frame)
 {
 	*pui32Frame =
 	    DbgGetFrame(gsDBGPdumpState.psStream[PDUMP_STREAM_SCRIPT2]);
@@ -958,27 +921,24 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PDumpCommentKM(IMG_CHAR * pszComment, IMG_UINT32 ui32Flags)
+enum PVRSRV_ERROR PDumpCommentKM(char *pszComment, u32 ui32Flags)
 {
-	IMG_UINT32 ui32Count = 0;
-	PVRSRV_ERROR eError;
+	u32 ui32Count = 0;
+	enum PVRSRV_ERROR eError;
 	__PDBG_PDUMP_STATE_GET_MSG_STRING(PVRSRV_ERROR_GENERIC);
 
-	if (ui32Flags & PDUMP_FLAGS_CONTINUOUS) {
+	if (ui32Flags & PDUMP_FLAGS_CONTINUOUS)
 		eError = PVRSRV_ERROR_GENERIC;
-	} else {
+	else
 		eError = PVRSRV_ERROR_CMD_NOT_PROCESSED;
-	}
 
-	if (!PDumpWriteString2("-- ", ui32Flags)) {
+	if (!PDumpWriteString2("-- ", ui32Flags))
 		return eError;
-	}
 
 	snprintf(pszMsg, SZ_MSG_SIZE_MAX, "%s", pszComment);
 
-	while ((pszMsg[ui32Count] != 0) && (ui32Count < SZ_MSG_SIZE_MAX)) {
+	while ((pszMsg[ui32Count] != 0) && (ui32Count < SZ_MSG_SIZE_MAX))
 		ui32Count++;
-	}
 
 	if ((pszMsg[ui32Count - 1] != '\n') && (ui32Count < SZ_MSG_SIZE_MAX)) {
 		pszMsg[ui32Count] = '\n';
@@ -997,16 +957,15 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PDumpDriverInfoKM(IMG_CHAR * pszString, IMG_UINT32 ui32Flags)
+enum PVRSRV_ERROR PDumpDriverInfoKM(char *pszString, u32 ui32Flags)
 {
-	IMG_UINT32 ui32Count = 0;
+	u32 ui32Count = 0;
 	__PDBG_PDUMP_STATE_GET_MSG_STRING(PVRSRV_ERROR_GENERIC);
 
 	snprintf(pszMsg, SZ_MSG_SIZE_MAX, "%s", pszString);
 
-	while ((pszMsg[ui32Count] != 0) && (ui32Count < SZ_MSG_SIZE_MAX)) {
+	while ((pszMsg[ui32Count] != 0) && (ui32Count < SZ_MSG_SIZE_MAX))
 		ui32Count++;
-	}
 
 	if ((pszMsg[ui32Count - 1] != '\n') && (ui32Count < SZ_MSG_SIZE_MAX)) {
 		pszMsg[ui32Count] = '\n';
@@ -1021,51 +980,39 @@
 	}
 
 	if (!PDumpWriteILock(gsDBGPdumpState.psStream[PDUMP_STREAM_DRIVERINFO],
-			     (IMG_UINT8 *) pszMsg, ui32Count, ui32Flags)) {
-		if (ui32Flags & PDUMP_FLAGS_CONTINUOUS) {
+			     (u8 *) pszMsg, ui32Count, ui32Flags)) {
+		if (ui32Flags & PDUMP_FLAGS_CONTINUOUS)
 			return PVRSRV_ERROR_GENERIC;
-		} else {
+		else
 			return PVRSRV_ERROR_CMD_NOT_PROCESSED;
-		}
 	}
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PDumpBitmapKM(IMG_CHAR * pszFileName,
-			   IMG_UINT32 ui32FileOffset,
-			   IMG_UINT32 ui32Width,
-			   IMG_UINT32 ui32Height,
-			   IMG_UINT32 ui32StrideInBytes,
-			   IMG_DEV_VIRTADDR sDevBaseAddr,
-			   IMG_UINT32 ui32Size,
-			   PDUMP_PIXEL_FORMAT ePixelFormat,
-			   PDUMP_MEM_FORMAT eMemFormat,
-			   IMG_UINT32 ui32PDumpFlags)
+enum PVRSRV_ERROR PDumpBitmapKM(char *pszFileName, u32 ui32FileOffset,
+			   u32 ui32Width, u32 ui32Height, u32 ui32StrideInBytes,
+			   struct IMG_DEV_VIRTADDR sDevBaseAddr,
+			   u32 ui32Size, enum PDUMP_PIXEL_FORMAT ePixelFormat,
+			   enum PDUMP_MEM_FORMAT eMemFormat, u32 ui32PDumpFlags)
 {
 	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING(PVRSRV_ERROR_GENERIC);
 	PDUMPCOMMENTWITHFLAGS(ui32PDumpFlags,
 			      "\r\n-- Dump bitmap of render\r\n");
 
-	snprintf(pszScript,
-		 SZ_SCRIPT_SIZE_MAX,
-		 "SII %s %s.bin :SGXMEM:v:0x%08lX 0x%08lX 0x%08lX 0x%08X 0x%08lX 0x%08lX 0x%08lX 0x%08X\r\n",
-		 pszFileName,
-		 pszFileName,
-		 sDevBaseAddr.uiAddr,
-		 ui32Size,
-		 ui32FileOffset,
-		 ePixelFormat,
-		 ui32Width, ui32Height, ui32StrideInBytes, eMemFormat);
+	snprintf(pszScript, SZ_SCRIPT_SIZE_MAX,
+		 "SII %s %s.bin :SGXMEM:v:0x%08lX 0x%08lX 0x%08lX 0x%08X "
+		 "0x%08lX 0x%08lX 0x%08lX 0x%08X\r\n",
+		 pszFileName, pszFileName, sDevBaseAddr.uiAddr, ui32Size,
+		 ui32FileOffset, ePixelFormat, ui32Width, ui32Height,
+		 ui32StrideInBytes, eMemFormat);
 
 	PDumpWriteString2(pszScript, ui32PDumpFlags);
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PDumpReadRegKM(IMG_CHAR * pszFileName,
-			    IMG_UINT32 ui32FileOffset,
-			    IMG_UINT32 ui32Address,
-			    IMG_UINT32 ui32Size, IMG_UINT32 ui32PDumpFlags)
+enum PVRSRV_ERROR PDumpReadRegKM(char *pszFileName, u32 ui32FileOffset,
+			    u32 ui32Address, u32 ui32Size, u32 ui32PDumpFlags)
 {
 	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING(PVRSRV_ERROR_GENERIC);
 
@@ -1079,30 +1026,28 @@
 	return PVRSRV_OK;
 }
 
-static IMG_BOOL PDumpWriteString2(IMG_CHAR * pszString, IMG_UINT32 ui32Flags)
+static IMG_BOOL PDumpWriteString2(char *pszString, u32 ui32Flags)
 {
 	return PDumpWriteILock(gsDBGPdumpState.psStream[PDUMP_STREAM_SCRIPT2],
-			       (IMG_UINT8 *) pszString, strlen(pszString),
-			       ui32Flags);
+			      (u8 *)pszString, strlen(pszString), ui32Flags);
 }
 
-static IMG_BOOL PDumpWriteILock(PDBG_STREAM psStream, IMG_UINT8 * pui8Data,
-				IMG_UINT32 ui32Count, IMG_UINT32 ui32Flags)
+static IMG_BOOL PDumpWriteILock(struct DBG_STREAM *psStream, u8 *pui8Data,
+				u32 ui32Count, u32 ui32Flags)
 {
-	IMG_UINT32 ui32Written = 0;
-	IMG_UINT32 ui32Off = 0;
+	u32 ui32Written = 0;
+	u32 ui32Off = 0;
 
-	if (!psStream || gui32PDumpSuspended || (ui32Flags & PDUMP_FLAGS_NEVER)) {
+	if (!psStream || gui32PDumpSuspended || (ui32Flags & PDUMP_FLAGS_NEVER))
 		return IMG_TRUE;
-	}
 
 	if (psStream == gsDBGPdumpState.psStream[PDUMP_STREAM_PARAM2]) {
-		IMG_UINT32 ui32ParamOutPos =
+		u32 ui32ParamOutPos =
 		    gpfnDbgDrv->pfnGetStreamOffset(gsDBGPdumpState.
 						   psStream
 						   [PDUMP_STREAM_PARAM2]);
 
-		if (ui32ParamOutPos + ui32Count > MAX_FILE_SIZE) {
+		if (ui32ParamOutPos + ui32Count > MAX_FILE_SIZE)
 			if ((gsDBGPdumpState.psStream[PDUMP_STREAM_SCRIPT2]
 			     &&
 			     PDumpWriteString2
@@ -1113,17 +1058,15 @@
 					     ui32ParamOutPos);
 				gsDBGPdumpState.ui32ParamFileNum++;
 			}
-		}
 	}
 
-	while (((IMG_UINT32) ui32Count > 0) && (ui32Written != 0xFFFFFFFF)) {
+	while (((u32) ui32Count > 0) && (ui32Written != 0xFFFFFFFF)) {
 		ui32Written =
 		    DbgWrite(psStream, &pui8Data[ui32Off], ui32Count,
 			     ui32Flags);
 
-		if (ui32Written == 0) {
+		if (ui32Written == 0)
 			OSReleaseThreadQuanta();
-		}
 
 		if (ui32Written != 0xFFFFFFFF) {
 			ui32Off += ui32Written;
@@ -1131,34 +1074,33 @@
 		}
 	}
 
-	if (ui32Written == 0xFFFFFFFF) {
+	if (ui32Written == 0xFFFFFFFF)
 		return IMG_FALSE;
-	}
 
 	return IMG_TRUE;
 }
 
-static IMG_VOID DbgSetFrame(PDBG_STREAM psStream, IMG_UINT32 ui32Frame)
+static void DbgSetFrame(struct DBG_STREAM *psStream, u32 ui32Frame)
 {
 	gpfnDbgDrv->pfnSetFrame(psStream, ui32Frame);
 }
 
-static IMG_UINT32 DbgGetFrame(PDBG_STREAM psStream)
+static u32 DbgGetFrame(struct DBG_STREAM *psStream)
 {
 	return gpfnDbgDrv->pfnGetFrame(psStream);
 }
 
-static IMG_VOID DbgSetMarker(PDBG_STREAM psStream, IMG_UINT32 ui32Marker)
+static void DbgSetMarker(struct DBG_STREAM *psStream, u32 ui32Marker)
 {
 	gpfnDbgDrv->pfnSetMarker(psStream, ui32Marker);
 }
 
-static IMG_UINT32 DbgWrite(PDBG_STREAM psStream, IMG_UINT8 * pui8Data,
-			   IMG_UINT32 ui32BCount, IMG_UINT32 ui32Flags)
+static u32 DbgWrite(struct DBG_STREAM *psStream, u8 *pui8Data,
+			   u32 ui32BCount, u32 ui32Flags)
 {
-	IMG_UINT32 ui32BytesWritten;
+	u32 ui32BytesWritten;
 
-	if (ui32Flags & PDUMP_FLAGS_CONTINUOUS) {
+	if (ui32Flags & PDUMP_FLAGS_CONTINUOUS)
 
 		if ((psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED) &&
 		    (psStream->ui32Start == 0xFFFFFFFF) &&
@@ -1170,14 +1112,13 @@
 			    gpfnDbgDrv->pfnDBGDrivWrite2(psStream, pui8Data,
 							 ui32BCount, 1);
 		}
-	} else {
+	else
 		if (ui32Flags & PDUMP_FLAGS_LASTFRAME) {
-			IMG_UINT32 ui32DbgFlags;
+			u32 ui32DbgFlags;
 
 			ui32DbgFlags = 0;
-			if (ui32Flags & PDUMP_FLAGS_RESETLFBUFFER) {
+			if (ui32Flags & PDUMP_FLAGS_RESETLFBUFFER)
 				ui32DbgFlags |= WRITELF_FLAGS_RESETBUF;
-			}
 
 			ui32BytesWritten =
 			    gpfnDbgDrv->pfnWriteLF(psStream, pui8Data,
@@ -1187,12 +1128,11 @@
 			    gpfnDbgDrv->pfnWriteBINCM(psStream, pui8Data,
 						      ui32BCount, 1);
 		}
-	}
 
 	return ui32BytesWritten;
 }
 
-IMG_BOOL PDumpTestNextFrame(IMG_UINT32 ui32CurrentFrame)
+IMG_BOOL PDumpTestNextFrame(u32 ui32CurrentFrame)
 {
 	IMG_BOOL bFrameDumped;
 
@@ -1204,13 +1144,11 @@
 	return bFrameDumped;
 }
 
-IMG_VOID PDump3DSignatureRegisters(IMG_UINT32 ui32DumpFrameNum,
-				   IMG_BOOL bLastFrame,
-				   IMG_UINT32 * pui32Registers,
-				   IMG_UINT32 ui32NumRegisters)
+void PDump3DSignatureRegisters(u32 ui32DumpFrameNum, IMG_BOOL bLastFrame,
+				   u32 *pui32Registers, u32 ui32NumRegisters)
 {
-	IMG_UINT32 ui32FileOffset, ui32Flags;
-	IMG_UINT32 i;
+	u32 ui32FileOffset, ui32Flags;
+	u32 i;
 
 	__PDBG_PDUMP_STATE_GET_SCRIPT_AND_FILE_STRING();
 
@@ -1224,16 +1162,13 @@
 
 	for (i = 0; i < ui32NumRegisters; i++) {
 		PDumpReadRegKM(pszFile, ui32FileOffset, pui32Registers[i],
-			       sizeof(IMG_UINT32), ui32Flags);
-		ui32FileOffset += sizeof(IMG_UINT32);
+			       sizeof(u32), ui32Flags);
+		ui32FileOffset += sizeof(u32);
 	}
 }
 
-static IMG_VOID PDumpCountRead(IMG_CHAR * pszFileName,
-			       IMG_UINT32 ui32Address,
-			       IMG_UINT32 ui32Size,
-			       IMG_UINT32 * pui32FileOffset,
-			       IMG_BOOL bLastFrame)
+static void PDumpCountRead(char *pszFileName, u32 ui32Address, u32 ui32Size,
+			   u32 *pui32FileOffset, IMG_BOOL bLastFrame)
 {
 	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
 
@@ -1245,13 +1180,11 @@
 	*pui32FileOffset += ui32Size;
 }
 
-IMG_VOID PDumpCounterRegisters(IMG_UINT32 ui32DumpFrameNum,
-			       IMG_BOOL bLastFrame,
-			       IMG_UINT32 * pui32Registers,
-			       IMG_UINT32 ui32NumRegisters)
+void PDumpCounterRegisters(u32 ui32DumpFrameNum, IMG_BOOL bLastFrame,
+			       u32 *pui32Registers, u32 ui32NumRegisters)
 {
-	IMG_UINT32 ui32FileOffset;
-	IMG_UINT32 i;
+	u32 ui32FileOffset;
+	u32 i;
 
 	__PDBG_PDUMP_STATE_GET_SCRIPT_AND_FILE_STRING();
 
@@ -1261,20 +1194,19 @@
 		 ui32DumpFrameNum);
 	ui32FileOffset = 0;
 
-	for (i = 0; i < ui32NumRegisters; i++) {
-		PDumpCountRead(pszFile, pui32Registers[i], sizeof(IMG_UINT32),
+	for (i = 0; i < ui32NumRegisters; i++)
+		PDumpCountRead(pszFile, pui32Registers[i], sizeof(u32),
 			       &ui32FileOffset, bLastFrame);
-	}
 }
 
-IMG_VOID PDumpTASignatureRegisters(IMG_UINT32 ui32DumpFrameNum,
-				   IMG_UINT32 ui32TAKickCount,
+void PDumpTASignatureRegisters(u32 ui32DumpFrameNum,
+				   u32 ui32TAKickCount,
 				   IMG_BOOL bLastFrame,
-				   IMG_UINT32 * pui32Registers,
-				   IMG_UINT32 ui32NumRegisters)
+				   u32 *pui32Registers,
+				   u32 ui32NumRegisters)
 {
-	IMG_UINT32 ui32FileOffset, ui32Flags;
-	IMG_UINT32 i;
+	u32 ui32FileOffset, ui32Flags;
+	u32 i;
 
 	__PDBG_PDUMP_STATE_GET_SCRIPT_AND_FILE_STRING();
 
@@ -1284,17 +1216,16 @@
 	snprintf(pszFile, SZ_FILENAME_SIZE_MAX, "out%lu_ta.sig",
 		 ui32DumpFrameNum);
 
-	ui32FileOffset =
-	    ui32TAKickCount * ui32NumRegisters * sizeof(IMG_UINT32);
+	ui32FileOffset = ui32TAKickCount * ui32NumRegisters * sizeof(u32);
 
 	for (i = 0; i < ui32NumRegisters; i++) {
 		PDumpReadRegKM(pszFile, ui32FileOffset, pui32Registers[i],
-			       sizeof(IMG_UINT32), ui32Flags);
-		ui32FileOffset += sizeof(IMG_UINT32);
+			       sizeof(u32), ui32Flags);
+		ui32FileOffset += sizeof(u32);
 	}
 }
 
-IMG_VOID PDumpRegRead(const IMG_UINT32 ui32RegOffset, IMG_UINT32 ui32Flags)
+void PDumpRegRead(const u32 ui32RegOffset, u32 ui32Flags)
 {
 	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
 
@@ -1303,7 +1234,7 @@
 	PDumpWriteString2(pszScript, ui32Flags);
 }
 
-IMG_VOID PDumpCycleCountRegRead(const IMG_UINT32 ui32RegOffset,
+void PDumpCycleCountRegRead(const u32 ui32RegOffset,
 				IMG_BOOL bLastFrame)
 {
 	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
@@ -1313,22 +1244,19 @@
 	PDumpWriteString2(pszScript, bLastFrame ? PDUMP_FLAGS_LASTFRAME : 0);
 }
 
-void PDumpCBP(PPVRSRV_KERNEL_MEM_INFO psROffMemInfo,
-	      IMG_UINT32 ui32ROffOffset,
-	      IMG_UINT32 ui32WPosVal,
-	      IMG_UINT32 ui32PacketSize,
-	      IMG_UINT32 ui32BufferSize,
-	      IMG_UINT32 ui32Flags, IMG_HANDLE hUniqueTag)
-{
-	IMG_UINT32 ui32PageOffset;
-	IMG_DEV_VIRTADDR sDevVAddr;
-	IMG_DEV_PHYADDR sDevPAddr;
-	IMG_DEV_VIRTADDR sDevVPageAddr;
-	IMG_CPU_PHYADDR CpuPAddr;
+void PDumpCBP(struct PVRSRV_KERNEL_MEM_INFO *psROffMemInfo,
+	      u32 ui32ROffOffset, u32 ui32WPosVal, u32 ui32PacketSize,
+	      u32 ui32BufferSize, u32 ui32Flags, void *hUniqueTag)
+{
+	u32 ui32PageOffset;
+	struct IMG_DEV_VIRTADDR sDevVAddr;
+	struct IMG_DEV_PHYADDR sDevPAddr;
+	struct IMG_DEV_VIRTADDR sDevVPageAddr;
+	struct IMG_CPU_PHYADDR CpuPAddr;
 
 	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
 
-	PVR_ASSERT((ui32ROffOffset + sizeof(IMG_UINT32)) <=
+	PVR_ASSERT((ui32ROffOffset + sizeof(u32)) <=
 		   psROffMemInfo->ui32AllocSize);
 
 	sDevVAddr = psROffMemInfo->sDevVAddr;
@@ -1348,7 +1276,8 @@
 
 	snprintf(pszScript,
 		 SZ_SCRIPT_SIZE_MAX,
-		 "CBP :SGXMEM:PA_%p%8.8lX:0x%8.8lX 0x%8.8lX 0x%8.8lX 0x%8.8lX\r\n",
+		 "CBP :SGXMEM:PA_%p%8.8lX:0x%8.8lX 0x%8.8lX 0x%8.8lX "
+		 "0x%8.8lX\r\n",
 		 hUniqueTag,
 		 sDevPAddr.uiAddr & ~(SGX_MMU_PAGE_SIZE - 1),
 		 sDevPAddr.uiAddr & (SGX_MMU_PAGE_SIZE - 1),
@@ -1356,7 +1285,7 @@
 	PDumpWriteString2(pszScript, ui32Flags);
 }
 
-IMG_VOID PDumpIDLWithFlags(IMG_UINT32 ui32Clocks, IMG_UINT32 ui32Flags)
+void PDumpIDLWithFlags(u32 ui32Clocks, u32 ui32Flags)
 {
 	__PDBG_PDUMP_STATE_GET_SCRIPT_STRING();
 
@@ -1364,17 +1293,17 @@
 	PDumpWriteString2(pszScript, ui32Flags);
 }
 
-IMG_VOID PDumpIDL(IMG_UINT32 ui32Clocks)
+void PDumpIDL(u32 ui32Clocks)
 {
 	PDumpIDLWithFlags(ui32Clocks, PDUMP_FLAGS_CONTINUOUS);
 }
 
-IMG_VOID PDumpSuspendKM(IMG_VOID)
+void PDumpSuspendKM(void)
 {
 	gui32PDumpSuspended++;
 }
 
-IMG_VOID PDumpResumeKM(IMG_VOID)
+void PDumpResumeKM(void)
 {
 	gui32PDumpSuspended--;
 }
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/pdump_km.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/pdump_km.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -28,222 +28,170 @@
 #define _PDUMP_KM_H_
 
 
-#define PDUMP_FLAGS_NEVER			0x08000000
+#define PDUMP_FLAGS_NEVER		0x08000000
 #define PDUMP_FLAGS_TOOUT2MEM		0x10000000
 #define PDUMP_FLAGS_LASTFRAME		0x20000000
 #define PDUMP_FLAGS_RESETLFBUFFER	0x40000000
 #define PDUMP_FLAGS_CONTINUOUS		0x80000000
 
-#define PDUMP_PD_UNIQUETAG			(IMG_HANDLE)0
-#define PDUMP_PT_UNIQUETAG			(IMG_HANDLE)0
+#define PDUMP_PD_UNIQUETAG		((void *)0)
+#define PDUMP_PT_UNIQUETAG		((void *)0)
 
 #ifndef PDUMP
-#define MAKEUNIQUETAG(hMemInfo)	(0)
+#define MAKEUNIQUETAG(hMemInfo)		0
 #endif
 
 #ifdef PDUMP
 
-#define MAKEUNIQUETAG(hMemInfo)	(((BM_BUF *)(((PVRSRV_KERNEL_MEM_INFO *)hMemInfo)->sMemBlk.hBuffer))->pMapping)
+#define MAKEUNIQUETAG(hMemInfo)						\
+	(((struct BM_BUF *)(((struct PVRSRV_KERNEL_MEM_INFO *)		\
+			     hMemInfo)->sMemBlk.hBuffer))->pMapping)
 
 #define PDUMP_REG_FUNC_NAME PDumpReg
 
-	IMG_IMPORT PVRSRV_ERROR PDumpMemPolKM(PVRSRV_KERNEL_MEM_INFO *
-					      psMemInfo, IMG_UINT32 ui32Offset,
-					      IMG_UINT32 ui32Value,
-					      IMG_UINT32 ui32Mask,
-					      PDUMP_POLL_OPERATOR eOperator,
-					      IMG_BOOL bLastFrame,
-					      IMG_BOOL bOverwrite,
-					      IMG_HANDLE hUniqueTag);
-
-	IMG_IMPORT PVRSRV_ERROR PDumpMemKM(IMG_PVOID pvAltLinAddr,
-					   PVRSRV_KERNEL_MEM_INFO * psMemInfo,
-					   IMG_UINT32 ui32Offset,
-					   IMG_UINT32 ui32Bytes,
-					   IMG_UINT32 ui32Flags,
-					   IMG_HANDLE hUniqueTag);
-	PVRSRV_ERROR PDumpMemPagesKM(PVRSRV_DEVICE_TYPE eDeviceType,
-				     IMG_DEV_PHYADDR * pPages,
-				     IMG_UINT32 ui32NumPages,
-				     IMG_DEV_VIRTADDR sDevAddr,
-				     IMG_UINT32 ui32Start,
-				     IMG_UINT32 ui32Length,
-				     IMG_UINT32 ui32Flags,
-				     IMG_HANDLE hUniqueTag);
-
-	PVRSRV_ERROR PDumpMem2KM(PVRSRV_DEVICE_TYPE eDeviceType,
-				 IMG_CPU_VIRTADDR pvLinAddr,
-				 IMG_UINT32 ui32Bytes,
-				 IMG_UINT32 ui32Flags,
-				 IMG_BOOL bInitialisePages,
-				 IMG_HANDLE hUniqueTag1,
-				 IMG_HANDLE hUniqueTag2);
-	IMG_VOID PDumpInit(IMG_VOID);
-	IMG_VOID PDumpDeInit(IMG_VOID);
-	IMG_IMPORT PVRSRV_ERROR PDumpSetFrameKM(IMG_UINT32 ui32Frame);
-	IMG_IMPORT PVRSRV_ERROR PDumpCommentKM(IMG_CHAR * pszComment,
-					       IMG_UINT32 ui32Flags);
-	IMG_IMPORT PVRSRV_ERROR PDumpDriverInfoKM(IMG_CHAR * pszString,
-						  IMG_UINT32 ui32Flags);
-	PVRSRV_ERROR PDumpRegWithFlagsKM(IMG_UINT32 ui32RegAddr,
-					 IMG_UINT32 ui32RegValue,
-					 IMG_UINT32 ui32Flags);
-	IMG_IMPORT PVRSRV_ERROR PDumpBitmapKM(IMG_CHAR * pszFileName,
-					      IMG_UINT32 ui32FileOffset,
-					      IMG_UINT32 ui32Width,
-					      IMG_UINT32 ui32Height,
-					      IMG_UINT32 ui32StrideInBytes,
-					      IMG_DEV_VIRTADDR sDevBaseAddr,
-					      IMG_UINT32 ui32Size,
-					      PDUMP_PIXEL_FORMAT ePixelFormat,
-					      PDUMP_MEM_FORMAT eMemFormat,
-					      IMG_UINT32 ui32PDumpFlags);
-	IMG_IMPORT PVRSRV_ERROR PDumpReadRegKM(IMG_CHAR * pszFileName,
-					       IMG_UINT32 ui32FileOffset,
-					       IMG_UINT32 ui32Address,
-					       IMG_UINT32 ui32Size,
-					       IMG_UINT32 ui32PDumpFlags);
-	IMG_VOID PDUMP_REG_FUNC_NAME(IMG_UINT32 dwReg, IMG_UINT32 dwData);
-
-	IMG_VOID PDumpMsvdxRegRead(const IMG_CHAR * const pRegRegion,
-				   const IMG_UINT32 dwRegOffset);
-
-	IMG_VOID PDumpMsvdxRegWrite(const IMG_CHAR * const pRegRegion,
-				    const IMG_UINT32 dwRegOffset,
-				    const IMG_UINT32 dwData);
-
-	PVRSRV_ERROR PDumpMsvdxRegPol(const IMG_CHAR * const pRegRegion,
-				      const IMG_UINT32 ui32Offset,
-				      const IMG_UINT32 ui32CheckFuncIdExt,
-				      const IMG_UINT32 ui32RequValue,
-				      const IMG_UINT32 ui32Enable,
-				      const IMG_UINT32 ui32PollCount,
-				      const IMG_UINT32 ui32TimeOut);
-
-	PVRSRV_ERROR PDumpMsvdxWriteRef(const IMG_CHAR * const pRegRegion,
-					const IMG_UINT32 ui32VLROffset,
-					const IMG_UINT32 ui32Physical);
-
-	IMG_VOID PDumpComment(IMG_CHAR * pszFormat, ...);
-	IMG_VOID PDumpCommentWithFlags(IMG_UINT32 ui32Flags,
-				       IMG_CHAR * pszFormat, ...);
-	PVRSRV_ERROR PDumpRegPolKM(IMG_UINT32 ui32RegAddr,
-				   IMG_UINT32 ui32RegValue,
-				   IMG_UINT32 ui32Mask);
-	PVRSRV_ERROR PDumpRegPolWithFlagsKM(IMG_UINT32 ui32RegAddr,
-					    IMG_UINT32 ui32RegValue,
-					    IMG_UINT32 ui32Mask,
-					    IMG_UINT32 ui32Flags);
-	IMG_BOOL PDumpIsLastCaptureFrameKM(IMG_VOID);
-	IMG_IMPORT IMG_BOOL PDumpIsCaptureFrameKM(IMG_VOID);
-
-	IMG_VOID PDumpMallocPages(PVRSRV_DEVICE_TYPE eDeviceType,
-				  IMG_UINT32 ui32DevVAddr,
-				  IMG_CPU_VIRTADDR pvLinAddr,
-				  IMG_HANDLE hOSMemHandle,
-				  IMG_UINT32 ui32NumBytes,
-				  IMG_HANDLE hUniqueTag);
-	IMG_VOID PDumpMallocPagesPhys(PVRSRV_DEVICE_TYPE eDeviceType,
-				      IMG_UINT32 ui32DevVAddr,
-				      IMG_PUINT32 pui32PhysPages,
-				      IMG_UINT32 ui32NumPages,
-				      IMG_HANDLE hUniqueTag);
-	IMG_VOID PDumpMallocPageTable(PVRSRV_DEVICE_TYPE eDeviceType,
-				      IMG_CPU_VIRTADDR pvLinAddr,
-				      IMG_UINT32 ui32NumBytes,
-				      IMG_HANDLE hUniqueTag);
-	IMG_VOID PDumpFreePages(struct _BM_HEAP_ *psBMHeap,
-				IMG_DEV_VIRTADDR sDevVAddr,
-				IMG_UINT32 ui32NumBytes,
-				IMG_HANDLE hUniqueTag, IMG_BOOL bInterleaved);
-	IMG_VOID PDumpFreePageTable(PVRSRV_DEVICE_TYPE eDeviceType,
-				    IMG_CPU_VIRTADDR pvLinAddr,
-				    IMG_UINT32 ui32NumBytes,
-				    IMG_HANDLE hUniqueTag);
-	IMG_VOID PDumpPDReg(IMG_UINT32 ui32Reg,
-			    IMG_UINT32 ui32dwData, IMG_HANDLE hUniqueTag);
-	IMG_VOID PDumpPDRegWithFlags(IMG_UINT32 ui32Reg,
-				     IMG_UINT32 ui32Data,
-				     IMG_UINT32 ui32Flags,
-				     IMG_HANDLE hUniqueTag);
-
-	PVRSRV_ERROR PDumpPDDevPAddrKM(PVRSRV_KERNEL_MEM_INFO * psMemInfo,
-				       IMG_UINT32 ui32Offset,
-				       IMG_DEV_PHYADDR sPDDevPAddr,
-				       IMG_HANDLE hUniqueTag1,
-				       IMG_HANDLE hUniqueTag2);
-
-	IMG_BOOL PDumpTestNextFrame(IMG_UINT32 ui32CurrentFrame);
-
-	IMG_VOID PDumpTASignatureRegisters(IMG_UINT32 ui32DumpFrameNum,
-					   IMG_UINT32 ui32TAKickCount,
-					   IMG_BOOL bLastFrame,
-					   IMG_UINT32 * pui32Registers,
-					   IMG_UINT32 ui32NumRegisters);
-
-	IMG_VOID PDump3DSignatureRegisters(IMG_UINT32 ui32DumpFrameNum,
-					   IMG_BOOL bLastFrame,
-					   IMG_UINT32 * pui32Registers,
-					   IMG_UINT32 ui32NumRegisters);
-
-	IMG_VOID PDumpRegRead(const IMG_UINT32 dwRegOffset,
-			      IMG_UINT32 ui32Flags);
-
-	IMG_VOID PDumpCycleCountRegRead(const IMG_UINT32 dwRegOffset,
-					IMG_BOOL bLastFrame);
-
-	IMG_VOID PDumpCounterRegisters(IMG_UINT32 ui32DumpFrameNum,
-				       IMG_BOOL bLastFrame,
-				       IMG_UINT32 * pui32Registers,
-				       IMG_UINT32 ui32NumRegisters);
-
-	IMG_VOID PDumpEndInitPhase(IMG_VOID);
-
-	void PDumpCBP(PPVRSRV_KERNEL_MEM_INFO psROffMemInfo,
-		      IMG_UINT32 ui32ROffOffset,
-		      IMG_UINT32 ui32WPosVal,
-		      IMG_UINT32 ui32PacketSize,
-		      IMG_UINT32 ui32BufferSize,
-		      IMG_UINT32 ui32Flags, IMG_HANDLE hUniqueTag);
+enum PVRSRV_ERROR PDumpMemPolKM(struct PVRSRV_KERNEL_MEM_INFO *psMemInfo,
+		u32 ui32Offset, u32 ui32Value, u32 ui32Mask,
+		enum PDUMP_POLL_OPERATOR eOperator, IMG_BOOL bLastFrame,
+		IMG_BOOL bOverwrite, void *hUniqueTag);
+
+enum PVRSRV_ERROR PDumpMemKM(void *pvAltLinAddr,
+		struct PVRSRV_KERNEL_MEM_INFO *psMemInfo, u32 ui32Offset,
+		u32 ui32Bytes, u32 ui32Flags, void *hUniqueTag);
+
+enum PVRSRV_ERROR PDumpMemPagesKM(enum PVRSRV_DEVICE_TYPE eDeviceType,
+		struct IMG_DEV_PHYADDR *pPages, u32 ui32NumPages,
+		struct IMG_DEV_VIRTADDR sDevAddr, u32 ui32Start,
+		u32 ui32Length, u32 ui32Flags, void *hUniqueTag);
+
+enum PVRSRV_ERROR PDumpMem2KM(enum PVRSRV_DEVICE_TYPE eDeviceType,
+		void *pvLinAddr, u32 ui32Bytes, u32 ui32Flags,
+		IMG_BOOL bInitialisePages, void *hUniqueTag1,
+		void *hUniqueTag2);
+
+void PDumpInit(void);
+void PDumpDeInit(void);
+enum PVRSRV_ERROR PDumpSetFrameKM(u32 ui32Frame);
+enum PVRSRV_ERROR PDumpCommentKM(char *pszComment, u32 ui32Flags);
+enum PVRSRV_ERROR PDumpDriverInfoKM(char *pszString, u32 ui32Flags);
+enum PVRSRV_ERROR PDumpRegWithFlagsKM(u32 ui32RegAddr, u32 ui32RegValue,
+		u32 ui32Flags);
+
+enum PVRSRV_ERROR PDumpBitmapKM(char *pszFileName, u32 ui32FileOffset,
+		u32 ui32Width, u32 ui32Height, u32 ui32StrideInBytes,
+		struct IMG_DEV_VIRTADDR sDevBaseAddr, u32 ui32Size,
+		enum PDUMP_PIXEL_FORMAT ePixelFormat,
+		enum PDUMP_MEM_FORMAT eMemFormat, u32 ui32PDumpFlags);
+
+enum PVRSRV_ERROR PDumpReadRegKM(char *pszFileName, u32 ui32FileOffset,
+		u32 ui32Address, u32 ui32Size, u32 ui32PDumpFlags);
+
+void PDUMP_REG_FUNC_NAME(u32 dwReg, u32 dwData);
+
+void PDumpMsvdxRegRead(const char *const pRegRegion, const u32 dwRegOffset);
+
+void PDumpMsvdxRegWrite(const char *const pRegRegion, const u32 dwRegOffset,
+		const u32 dwData);
+
+enum PVRSRV_ERROR PDumpMsvdxRegPol(const char *const pRegRegion,
+		const u32 ui32Offset, const u32 ui32CheckFuncIdExt,
+		const u32 ui32RequValue, const u32 ui32Enable,
+		const u32 ui32PollCount, const u32 ui32TimeOut);
+
+enum PVRSRV_ERROR PDumpMsvdxWriteRef(const char *const pRegRegion,
+		const u32 ui32VLROffset, const u32 ui32Physical);
+
+void PDumpComment(char *pszFormat, ...);
+
+void PDumpCommentWithFlags(u32 ui32Flags, char *pszFormat, ...);
+enum PVRSRV_ERROR PDumpRegPolKM(u32 ui32RegAddr, u32 ui32RegValue,
+				u32 ui32Mask);
+enum PVRSRV_ERROR PDumpRegPolWithFlagsKM(u32 ui32RegAddr, u32 ui32RegValue,
+		u32 ui32Mask, u32 ui32Flags);
+
+IMG_BOOL PDumpIsLastCaptureFrameKM(void);
+IMG_BOOL PDumpIsCaptureFrameKM(void);
+
+void PDumpMallocPages(enum PVRSRV_DEVICE_TYPE eDeviceType, u32 ui32DevVAddr,
+		void *pvLinAddr, void *hOSMemHandle, u32 ui32NumBytes,
+		void *hUniqueTag);
+void PDumpMallocPagesPhys(enum PVRSRV_DEVICE_TYPE eDeviceType,
+		u32 ui32DevVAddr, u32 *pui32PhysPages, u32 ui32NumPages,
+		void *hUniqueTag);
+void PDumpMallocPageTable(enum PVRSRV_DEVICE_TYPE eDeviceType,
+		void *pvLinAddr, u32 ui32NumBytes, void *hUniqueTag);
+void PDumpFreePages(struct BM_HEAP *psBMHeap,
+		struct IMG_DEV_VIRTADDR sDevVAddr,
+		u32 ui32NumBytes, void *hUniqueTag, IMG_BOOL bInterleaved);
+void PDumpFreePageTable(enum PVRSRV_DEVICE_TYPE eDeviceType,
+		void *pvLinAddr, u32 ui32NumBytes, void *hUniqueTag);
+void PDumpPDReg(u32 ui32Reg, u32 ui32dwData, void *hUniqueTag);
+void PDumpPDRegWithFlags(u32 ui32Reg, u32 ui32Data, u32 ui32Flags,
+		void *hUniqueTag);
+
+enum PVRSRV_ERROR PDumpPDDevPAddrKM(struct PVRSRV_KERNEL_MEM_INFO *psMemInfo,
+		u32 ui32Offset, struct IMG_DEV_PHYADDR sPDDevPAddr,
+		void *hUniqueTag1, void *hUniqueTag2);
+
+IMG_BOOL PDumpTestNextFrame(u32 ui32CurrentFrame);
+
+void PDumpTASignatureRegisters(u32 ui32DumpFrameNum,
+		u32 ui32TAKickCount, IMG_BOOL bLastFrame,
+		u32 *pui32Registers, u32 ui32NumRegisters);
+
+void PDump3DSignatureRegisters(u32 ui32DumpFrameNum, IMG_BOOL bLastFrame,
+		u32 *pui32Registers, u32 ui32NumRegisters);
+
+void PDumpRegRead(const u32 dwRegOffset, u32 ui32Flags);
+
+void PDumpCycleCountRegRead(const u32 dwRegOffset, IMG_BOOL bLastFrame);
+
+void PDumpCounterRegisters(u32 ui32DumpFrameNum, IMG_BOOL bLastFrame,
+		u32 *pui32Registers, u32 ui32NumRegisters);
+
+void PDumpEndInitPhase(void);
+
+void PDumpCBP(struct PVRSRV_KERNEL_MEM_INFO *psROffMemInfo, u32 ui32ROffOffset,
+		u32 ui32WPosVal, u32 ui32PacketSize, u32 ui32BufferSize,
+		u32 ui32Flags, void *hUniqueTag);
 
-	IMG_VOID PDumpIDLWithFlags(IMG_UINT32 ui32Clocks, IMG_UINT32 ui32Flags);
-	IMG_VOID PDumpIDL(IMG_UINT32 ui32Clocks);
+void PDumpIDLWithFlags(u32 ui32Clocks, u32 ui32Flags);
+void PDumpIDL(u32 ui32Clocks);
 
-	IMG_VOID PDumpSuspendKM(IMG_VOID);
-	IMG_VOID PDumpResumeKM(IMG_VOID);
+void PDumpSuspendKM(void);
+void PDumpResumeKM(void);
 
 #define PDUMPMEMPOL				PDumpMemPolKM
 #define PDUMPMEM				PDumpMemKM
 #define PDUMPMEM2				PDumpMem2KM
 #define PDUMPINIT				PDumpInit
 #define PDUMPDEINIT				PDumpDeInit
-#define PDUMPISLASTFRAME		PDumpIsLastCaptureFrameKM
-#define PDUMPTESTFRAME			PDumpIsCaptureFrameKM
-#define PDUMPTESTNEXTFRAME		PDumpTestNextFrame
-#define PDUMPREGWITHFLAGS		PDumpRegWithFlagsKM
+#define PDUMPISLASTFRAME			PDumpIsLastCaptureFrameKM
+#define PDUMPTESTFRAME				PDumpIsCaptureFrameKM
+#define PDUMPTESTNEXTFRAME			PDumpTestNextFrame
+#define PDUMPREGWITHFLAGS			PDumpRegWithFlagsKM
 #define PDUMPREG				PDUMP_REG_FUNC_NAME
-#define PDUMPCOMMENT			PDumpComment
-#define PDUMPCOMMENTWITHFLAGS	PDumpCommentWithFlags
+#define PDUMPCOMMENT				PDumpComment
+#define PDUMPCOMMENTWITHFLAGS			PDumpCommentWithFlags
 #define PDUMPREGPOL				PDumpRegPolKM
-#define PDUMPREGPOLWITHFLAGS	PDumpRegPolWithFlagsKM
-#define PDUMPMALLOCPAGES		PDumpMallocPages
-#define PDUMPMALLOCPAGETABLE	PDumpMallocPageTable
-#define PDUMPFREEPAGES			PDumpFreePages
-#define PDUMPFREEPAGETABLE		PDumpFreePageTable
+#define PDUMPREGPOLWITHFLAGS			PDumpRegPolWithFlagsKM
+#define PDUMPMALLOCPAGES			PDumpMallocPages
+#define PDUMPMALLOCPAGETABLE			PDumpMallocPageTable
+#define PDUMPFREEPAGES				PDumpFreePages
+#define PDUMPFREEPAGETABLE			PDumpFreePageTable
 #define PDUMPPDREG				PDumpPDReg
-#define PDUMPPDREGWITHFLAGS		PDumpPDRegWithFlags
+#define PDUMPPDREGWITHFLAGS			PDumpPDRegWithFlags
 #define PDUMPCBP				PDumpCBP
-#define PDUMPMALLOCPAGESPHYS	PDumpMallocPagesPhys
-#define PDUMPENDINITPHASE		PDumpEndInitPhase
-#define PDUMPMSVDXREGWRITE		PDumpMsvdxRegWrite
-#define PDUMPMSVDXREGREAD		PDumpMsvdxRegRead
-#define PDUMPMSVDXPOL			PDumpMsvdxRegPol
-#define PDUMPMSVDXWRITEREF		PDumpMsvdxWriteRef
-#define PDUMPBITMAPKM			PDumpBitmapKM
-#define PDUMPDRIVERINFO			PDumpDriverInfoKM
-#define PDUMPIDLWITHFLAGS		PDumpIDLWithFlags
+#define PDUMPMALLOCPAGESPHYS			PDumpMallocPagesPhys
+#define PDUMPENDINITPHASE			PDumpEndInitPhase
+#define PDUMPMSVDXREGWRITE			PDumpMsvdxRegWrite
+#define PDUMPMSVDXREGREAD			PDumpMsvdxRegRead
+#define PDUMPMSVDXPOL				PDumpMsvdxRegPol
+#define PDUMPMSVDXWRITEREF			PDumpMsvdxWriteRef
+#define PDUMPBITMAPKM				PDumpBitmapKM
+#define PDUMPDRIVERINFO				PDumpDriverInfoKM
+#define PDUMPIDLWITHFLAGS			PDumpIDLWithFlags
 #define PDUMPIDL				PDumpIDL
-#define PDUMPSUSPEND			PDumpSuspendKM
+#define PDUMPSUSPEND				PDumpSuspendKM
 #define PDUMPRESUME				PDumpResumeKM
 
 #else
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/pdumpdefs.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/pdumpdefs.h
@@ -1,33 +1,33 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
-#if !defined (__PDUMPDEFS_H__)
+#if !defined(__PDUMPDEFS_H__)
 #define __PDUMPDEFS_H__
 
-typedef enum _PDUMP_PIXEL_FORMAT_ {
+enum PDUMP_PIXEL_FORMAT {
 	PVRSRV_PDUMP_PIXEL_FORMAT_RGB8 = 1,
 	PVRSRV_PDUMP_PIXEL_FORMAT_RGB332 = 2,
 	PVRSRV_PDUMP_PIXEL_FORMAT_KRGB555 = 3,
@@ -68,9 +68,9 @@
 	PVRSRV_PDUMP_PIXEL_FORMAT_L32 = 38,
 
 	PVRSRV_PDUMP_PIXEL_FORMAT_FORCE_I32 = 0x7fffffff
-} PDUMP_PIXEL_FORMAT;
+};
 
-typedef enum _PDUMP_MEM_FORMAT_ {
+enum PDUMP_MEM_FORMAT {
 	PVRSRV_PDUMP_MEM_FORMAT_STRIDE = 0,
 	PVRSRV_PDUMP_MEM_FORMAT_RESERVED = 1,
 	PVRSRV_PDUMP_MEM_FORMAT_TILED = 8,
@@ -78,15 +78,15 @@
 	PVRSRV_PDUMP_MEM_FORMAT_HYBRID = 10,
 
 	PVRSRV_PDUMP_MEM_FORMAT_FORCE_I32 = 0x7fffffff
-} PDUMP_MEM_FORMAT;
+};
 
-typedef enum _PDUMP_POLL_OPERATOR {
+enum PDUMP_POLL_OPERATOR {
 	PDUMP_POLL_OPERATOR_EQUAL = 0,
 	PDUMP_POLL_OPERATOR_LESS = 1,
 	PDUMP_POLL_OPERATOR_LESSEQUAL = 2,
 	PDUMP_POLL_OPERATOR_GREATER = 3,
 	PDUMP_POLL_OPERATOR_GREATEREQUAL = 4,
 	PDUMP_POLL_OPERATOR_NOTEQUAL = 5,
-} PDUMP_POLL_OPERATOR;
+};
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/perproc.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/perproc.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -31,107 +31,97 @@
 
 #define	HASH_TAB_INIT_SIZE 32
 
-static HASH_TABLE *psHashTab = IMG_NULL;
+static struct HASH_TABLE *psHashTab;
 
-static PVRSRV_ERROR FreePerProcessData(PVRSRV_PER_PROCESS_DATA * psPerProc)
+static enum PVRSRV_ERROR FreePerProcessData(
+				struct PVRSRV_PER_PROCESS_DATA *psPerProc)
 {
-	PVRSRV_ERROR eError;
-	IMG_UINTPTR_T uiPerProc;
+	enum PVRSRV_ERROR eError;
+	u32 uiPerProc;
 
-	PVR_ASSERT(psPerProc != IMG_NULL);
+	PVR_ASSERT(psPerProc != NULL);
 
-	uiPerProc = HASH_Remove(psHashTab, (IMG_UINTPTR_T) psPerProc->ui32PID);
+	uiPerProc = HASH_Remove(psHashTab, (u32)psPerProc->ui32PID);
 	if (uiPerProc == 0) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "FreePerProcessData: Couldn't find process in per-process data hash table"));
+		PVR_DPF(PVR_DBG_ERROR, "FreePerProcessData: "
+		       "Couldn't find process in per-process data hash table");
 
 		PVR_ASSERT(psPerProc->ui32PID == 0);
 	} else {
-		PVR_ASSERT((PVRSRV_PER_PROCESS_DATA *) uiPerProc == psPerProc);
-		PVR_ASSERT(((PVRSRV_PER_PROCESS_DATA *) uiPerProc)->ui32PID ==
-			   psPerProc->ui32PID);
+		PVR_ASSERT((struct PVRSRV_PER_PROCESS_DATA *)
+				uiPerProc == psPerProc);
+		PVR_ASSERT(((struct PVRSRV_PER_PROCESS_DATA *)uiPerProc)->
+				ui32PID == psPerProc->ui32PID);
 	}
 
-	if (psPerProc->psHandleBase != IMG_NULL) {
+	if (psPerProc->psHandleBase != NULL) {
 		eError = PVRSRVFreeHandleBase(psPerProc->psHandleBase);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "FreePerProcessData: Couldn't free handle base for process (%d)",
-				 eError));
+			PVR_DPF(PVR_DBG_ERROR, "FreePerProcessData: "
+				"Couldn't free handle base for process (%d)",
+				 eError);
 			return eError;
 		}
 	}
 
-	if (psPerProc->hPerProcData != IMG_NULL) {
+	if (psPerProc->hPerProcData != NULL) {
 		eError =
 		    PVRSRVReleaseHandle(KERNEL_HANDLE_BASE,
 					psPerProc->hPerProcData,
 					PVRSRV_HANDLE_TYPE_PERPROC_DATA);
 
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "FreePerProcessData: Couldn't release per-process data handle (%d)",
-				 eError));
+			PVR_DPF(PVR_DBG_ERROR, "FreePerProcessData: "
+				"Couldn't release per-process data handle (%d)",
+				 eError);
 			return eError;
 		}
 	}
 
-	eError = OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-			   sizeof(*psPerProc),
-			   psPerProc, psPerProc->hBlockAlloc);
-	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "FreePerProcessData: Couldn't free per-process data (%d)",
-			 eError));
-		return eError;
-	}
+	OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, sizeof(*psPerProc),
+			psPerProc, psPerProc->hBlockAlloc);
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_PER_PROCESS_DATA *PVRSRVPerProcessData(IMG_UINT32 ui32PID)
+struct PVRSRV_PER_PROCESS_DATA *PVRSRVPerProcessData(u32 ui32PID)
 {
-	PVRSRV_PER_PROCESS_DATA *psPerProc;
+	struct PVRSRV_PER_PROCESS_DATA *psPerProc;
 
-	PVR_ASSERT(psHashTab != IMG_NULL);
+	PVR_ASSERT(psHashTab != NULL);
 
 	psPerProc =
-	    (PVRSRV_PER_PROCESS_DATA *) HASH_Retrieve(psHashTab,
-						      (IMG_UINTPTR_T) ui32PID);
+	    (struct PVRSRV_PER_PROCESS_DATA *)HASH_Retrieve(psHashTab,
+						      (u32) ui32PID);
 	return psPerProc;
 }
 
-PVRSRV_ERROR PVRSRVPerProcessDataConnect(IMG_UINT32 ui32PID)
+enum PVRSRV_ERROR PVRSRVPerProcessDataConnect(u32 ui32PID)
 {
-	PVRSRV_PER_PROCESS_DATA *psPerProc;
-	IMG_HANDLE hBlockAlloc;
-	PVRSRV_ERROR eError = PVRSRV_OK;
-
-	PVR_ASSERT(psHashTab != IMG_NULL);
+	struct PVRSRV_PER_PROCESS_DATA *psPerProc;
+	void *hBlockAlloc;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
-	psPerProc =
-	    (PVRSRV_PER_PROCESS_DATA *) HASH_Retrieve(psHashTab,
-						      (IMG_UINTPTR_T) ui32PID);
-
-	if (psPerProc == IMG_NULL) {
+	PVR_ASSERT(psHashTab != NULL);
 
+	psPerProc = (struct PVRSRV_PER_PROCESS_DATA *)HASH_Retrieve(psHashTab,
+						      (u32)ui32PID);
+	if (psPerProc == NULL) {
 		eError = OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-				    sizeof(*psPerProc),
-				    (IMG_PVOID *) & psPerProc, &hBlockAlloc);
+				    sizeof(*psPerProc), (void **)&psPerProc,
+				    &hBlockAlloc);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVPerProcessDataConnect: Couldn't allocate per-process data (%d)",
-				 eError));
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVPerProcessDataConnect: "
+				 "Couldn't allocate per-process data (%d)",
+				 eError);
 			return eError;
 		}
 		OSMemSet(psPerProc, 0, sizeof(*psPerProc));
 		psPerProc->hBlockAlloc = hBlockAlloc;
 
-		if (!HASH_Insert
-		    (psHashTab, (IMG_UINTPTR_T) ui32PID,
-		     (IMG_UINTPTR_T) psPerProc)) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVPerProcessDataConnect: Couldn't insert per-process data into hash table"));
+		if (!HASH_Insert(psHashTab, (u32) ui32PID, (u32)psPerProc)) {
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVPerProcessDataConnect: "
+			   "Couldn't insert per-process data into hash table");
 			eError = PVRSRV_ERROR_GENERIC;
 			goto failure;
 		}
@@ -145,34 +135,34 @@
 					   PVRSRV_HANDLE_TYPE_PERPROC_DATA,
 					   PVRSRV_HANDLE_ALLOC_FLAG_NONE);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVPerProcessDataConnect: Couldn't allocate handle for per-process data (%d)",
-				 eError));
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVPerProcessDataConnect: "
+			   "Couldn't allocate handle for per-process data (%d)",
+			   eError);
 			goto failure;
 		}
 
-		eError =
-		    PVRSRVAllocHandleBase(&psPerProc->psHandleBase, ui32PID);
+		eError = PVRSRVAllocHandleBase(&psPerProc->psHandleBase,
+						ui32PID);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVPerProcessDataConnect: Couldn't allocate handle base for process (%d)",
-				 eError));
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVPerProcessDataConnect: "
+			       "Couldn't allocate handle base for process (%d)",
+			       eError);
 			goto failure;
 		}
 
-		eError =
-		    PVRSRVResManConnect(psPerProc, &psPerProc->hResManContext);
+		eError = PVRSRVResManConnect(psPerProc,
+					     &psPerProc->hResManContext);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVPerProcessDataConnect: Couldn't register with the resource manager"));
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVPerProcessDataConnect: "
+				"Couldn't register with the resource manager");
 			goto failure;
 		}
 	}
 
 	psPerProc->ui32RefCount++;
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "PVRSRVPerProcessDataConnect: Process 0x%x has ref-count %d",
-		 ui32PID, psPerProc->ui32RefCount));
+		 ui32PID, psPerProc->ui32RefCount);
 
 	return eError;
 
@@ -181,61 +171,58 @@
 	return eError;
 }
 
-IMG_VOID PVRSRVPerProcessDataDisconnect(IMG_UINT32 ui32PID)
+void PVRSRVPerProcessDataDisconnect(u32 ui32PID)
 {
-	PVRSRV_ERROR eError;
-	PVRSRV_PER_PROCESS_DATA *psPerProc;
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_PER_PROCESS_DATA *psPerProc;
 
-	PVR_ASSERT(psHashTab != IMG_NULL);
+	PVR_ASSERT(psHashTab != NULL);
 
-	psPerProc =
-	    (PVRSRV_PER_PROCESS_DATA *) HASH_Retrieve(psHashTab,
-						      (IMG_UINTPTR_T) ui32PID);
-	if (psPerProc == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVPerProcessDataDealloc: Couldn't locate per-process data for PID %u",
-			 ui32PID));
+	psPerProc = (struct PVRSRV_PER_PROCESS_DATA *)HASH_Retrieve(psHashTab,
+							      (u32)ui32PID);
+	if (psPerProc == NULL) {
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVPerProcessDataDealloc: "
+			 "Couldn't locate per-process data for PID %u",
+			 ui32PID);
 	} else {
 		psPerProc->ui32RefCount--;
 		if (psPerProc->ui32RefCount == 0) {
-			PVR_DPF((PVR_DBG_MESSAGE,
+			PVR_DPF(PVR_DBG_MESSAGE,
 				 "PVRSRVPerProcessDataDisconnect: "
 				 "Last close from process 0x%x received",
-				 ui32PID));
+				 ui32PID);
 
 			PVRSRVResManDisconnect(psPerProc->hResManContext,
 					       IMG_FALSE);
 
 			eError = FreePerProcessData(psPerProc);
-			if (eError != PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "PVRSRVPerProcessDataDisconnect: Error freeing per-process data"));
-			}
+			if (eError != PVRSRV_OK)
+				PVR_DPF(PVR_DBG_ERROR,
+					 "PVRSRVPerProcessDataDisconnect: "
+					 "Error freeing per-process data");
 		}
 	}
 }
 
-PVRSRV_ERROR PVRSRVPerProcessDataInit(IMG_VOID)
+enum PVRSRV_ERROR PVRSRVPerProcessDataInit(void)
 {
-	PVR_ASSERT(psHashTab == IMG_NULL);
+	PVR_ASSERT(psHashTab == NULL);
 
 	psHashTab = HASH_Create(HASH_TAB_INIT_SIZE);
-	if (psHashTab == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVPerProcessDataInit: Couldn't create per-process data hash table"));
+	if (psHashTab == NULL) {
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVPerProcessDataInit: "
+				"Couldn't create per-process data hash table");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PVRSRVPerProcessDataDeInit(IMG_VOID)
+enum PVRSRV_ERROR PVRSRVPerProcessDataDeInit(void)
 {
-
-	if (psHashTab != IMG_NULL) {
-
+	if (psHashTab != NULL) {
 		HASH_Delete(psHashTab);
-		psHashTab = IMG_NULL;
+		psHashTab = NULL;
 	}
 
 	return PVRSRV_OK;
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/perproc.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/perproc.h
@@ -1,60 +1,58 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef __PERPROC_H__
 #define __PERPROC_H__
 
-
 #include "img_types.h"
 #include "resman.h"
 
 #include "handle.h"
 
-	typedef struct _PVRSRV_PER_PROCESS_DATA_ {
-		IMG_UINT32 ui32PID;
-		IMG_HANDLE hBlockAlloc;
-		PRESMAN_CONTEXT hResManContext;
-		IMG_HANDLE hPerProcData;
-		PVRSRV_HANDLE_BASE *psHandleBase;
+struct PVRSRV_PER_PROCESS_DATA {
+	u32 ui32PID;
+	void *hBlockAlloc;
+	struct RESMAN_CONTEXT *hResManContext;
+	void *hPerProcData;
+	struct PVRSRV_HANDLE_BASE *psHandleBase;
 
-		IMG_BOOL bHandlesBatched;
-		IMG_UINT32 ui32RefCount;
+	IMG_BOOL bHandlesBatched;
+	u32 ui32RefCount;
 
-		IMG_BOOL bInitProcess;
+	IMG_BOOL bInitProcess;
 
-		IMG_HANDLE hOsPrivateData;
-	} PVRSRV_PER_PROCESS_DATA;
+	void *hOsPrivateData;
+};
 
-	IMG_IMPORT PVRSRV_PER_PROCESS_DATA *PVRSRVPerProcessData(IMG_UINT32
-								 ui32PID);
+struct PVRSRV_PER_PROCESS_DATA *PVRSRVPerProcessData(u32 ui32PID);
 
-	PVRSRV_ERROR PVRSRVPerProcessDataConnect(IMG_UINT32 ui32PID);
-	IMG_VOID PVRSRVPerProcessDataDisconnect(IMG_UINT32 ui32PID);
+enum PVRSRV_ERROR PVRSRVPerProcessDataConnect(u32 ui32PID);
+void PVRSRVPerProcessDataDisconnect(u32 ui32PID);
 
-	PVRSRV_ERROR PVRSRVPerProcessDataInit(IMG_VOID);
-	PVRSRV_ERROR PVRSRVPerProcessDataDeInit(IMG_VOID);
+enum PVRSRV_ERROR PVRSRVPerProcessDataInit(void);
+enum PVRSRV_ERROR PVRSRVPerProcessDataDeInit(void);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/power.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/power.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 #include "services_headers.h"
@@ -36,8 +36,7 @@
 static DECLARE_WAIT_QUEUE_HEAD(hDvfsWq);
 static IMG_BOOL gbDvfsActive;
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVSetInitServerState(PVRSRV_INIT_SERVER_STATE
+enum PVRSRV_ERROR PVRSRVSetInitServerState(enum PVRSRV_INIT_SERVER_STATE
 					  eInitServerState, IMG_BOOL bState)
 {
 
@@ -52,17 +51,17 @@
 		gbInitSuccessful = bState;
 		break;
 	default:
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "PVRSRVSetInitServerState : Unknown state %lx",
-			 eInitServerState));
+			 eInitServerState);
 		return PVRSRV_ERROR_GENERIC;
 	}
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    IMG_BOOL PVRSRVGetInitServerState(PVRSRV_INIT_SERVER_STATE eInitServerState)
+IMG_BOOL PVRSRVGetInitServerState(
+				enum PVRSRV_INIT_SERVER_STATE eInitServerState)
 {
 	IMG_BOOL bReturnVal;
 
@@ -77,28 +76,28 @@
 		bReturnVal = gbInitSuccessful;
 		break;
 	default:
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "PVRSRVGetInitServerState : Unknown state %lx",
-			 eInitServerState));
+			 eInitServerState);
 		bReturnVal = IMG_FALSE;
 	}
 
 	return bReturnVal;
 }
 
-static IMG_BOOL _IsSystemStatePowered(PVR_POWER_STATE eSystemPowerState)
+static IMG_BOOL _IsSystemStatePowered(enum PVR_POWER_STATE eSystemPowerState)
 {
-	return (IMG_BOOL) (eSystemPowerState < PVRSRV_POWER_STATE_D2);
+	return (IMG_BOOL)(eSystemPowerState < PVRSRV_POWER_STATE_D2);
 }
 
-IMG_EXPORT IMG_VOID PVRSRVDvfsLock(IMG_VOID)
+void PVRSRVDvfsLock(void)
 {
 	mutex_lock(&hPowerAndFreqLock);
 	gbDvfsActive = 1;
 	mutex_unlock(&hPowerAndFreqLock);
 }
 
-IMG_EXPORT IMG_VOID PVRSRVDvfsUnlock(IMG_VOID)
+void PVRSRVDvfsUnlock(void)
 {
 	mutex_lock(&hPowerAndFreqLock);
 	gbDvfsActive = 0;
@@ -106,18 +105,19 @@
 	mutex_unlock(&hPowerAndFreqLock);
 }
 
-static IMG_BOOL IsPowerLocked(void)
+enum PVRSRV_ERROR PVRSRVPowerLock(u32 ui32CallerID, IMG_BOOL bSystemPowerEvent)
 {
-	return mutex_is_locked(&hPowerAndFreqLock) || gbDvfsActive;
-}
+	if (ui32CallerID == TIMER_ID) {
+		if (!mutex_trylock(&hPowerAndFreqLock))
+			return PVRSRV_ERROR_RETRY;
+
+		if (gbDvfsActive) {
+			mutex_unlock(&hPowerAndFreqLock);
+			return PVRSRV_ERROR_RETRY;
+		}
+	} else
+		mutex_lock(&hPowerAndFreqLock);
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVPowerLock(IMG_UINT32 ui32CallerID,
-				 IMG_BOOL bSystemPowerEvent)
-{
-	if ((ui32CallerID == TIMER_ID) && IsPowerLocked())
-		return PVRSRV_ERROR_RETRY;
-	mutex_lock(&hPowerAndFreqLock);
 	while (gbDvfsActive) {
 		DEFINE_WAIT(__wait);
 		prepare_to_wait(&hDvfsWq, &__wait, TASK_UNINTERRUPTIBLE);
@@ -129,25 +129,23 @@
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT IMG_VOID PVRSRVPowerUnlock(IMG_UINT32 ui32CallerID)
+void PVRSRVPowerUnlock(u32 ui32CallerID)
 {
 	mutex_unlock(&hPowerAndFreqLock);
 }
 
-static
-PVRSRV_ERROR PVRSRVDevicePrePowerStateKM(IMG_BOOL bAllDevices,
-					 IMG_UINT32 ui32DeviceIndex,
-					 PVR_POWER_STATE eNewPowerState)
-{
-	PVRSRV_ERROR eError;
-	SYS_DATA *psSysData;
-	PVRSRV_POWER_DEV *psPowerDevice;
-	PVR_POWER_STATE eNewDevicePowerState;
+static enum PVRSRV_ERROR PVRSRVDevicePrePowerStateKM(IMG_BOOL bAllDevices,
+					 u32 ui32DeviceIndex,
+					 enum PVR_POWER_STATE eNewPowerState)
+{
+	enum PVRSRV_ERROR eError;
+	struct SYS_DATA *psSysData;
+	struct PVRSRV_POWER_DEV *psPowerDevice;
+	enum PVR_POWER_STATE eNewDevicePowerState;
 
 	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	psPowerDevice = psSysData->psPowerDeviceList;
 	while (psPowerDevice) {
@@ -160,7 +158,7 @@
 
 			if (psPowerDevice->eCurrentPowerState !=
 			    eNewDevicePowerState) {
-				if (psPowerDevice->pfnPrePower != IMG_NULL) {
+				if (psPowerDevice->pfnPrePower != NULL) {
 
 					eError =
 					    psPowerDevice->
@@ -170,9 +168,8 @@
 							psPowerDevice->
 							eCurrentPowerState);
 					if (eError != PVRSRV_OK) {
-						pr_err
-						    ("pfnPrePower failed (%u)\n",
-						     eError);
+						pr_err("pfnPrePower failed "
+							"(%u)\n", eError);
 						return eError;
 					}
 				}
@@ -184,9 +181,8 @@
 							   psPowerDevice->
 							   eCurrentPowerState);
 				if (eError != PVRSRV_OK) {
-					pr_err
-					    ("SysDevicePrePowerState failed (%u)\n",
-					     eError);
+					pr_err("SysDevicePrePowerState failed "
+						"(%u)\n", eError);
 					return eError;
 				}
 			}
@@ -198,48 +194,41 @@
 	return PVRSRV_OK;
 }
 
-static
-PVRSRV_ERROR PVRSRVDevicePostPowerStateKM(IMG_BOOL bAllDevices,
-					  IMG_UINT32 ui32DeviceIndex,
-					  PVR_POWER_STATE eNewPowerState)
-{
-	PVRSRV_ERROR eError;
-	SYS_DATA *psSysData;
-	PVRSRV_POWER_DEV *psPowerDevice;
-	PVR_POWER_STATE eNewDevicePowerState;
+static enum PVRSRV_ERROR PVRSRVDevicePostPowerStateKM(IMG_BOOL bAllDevices,
+					  u32 ui32DeviceIndex,
+					  enum PVR_POWER_STATE eNewPowerState)
+{
+	enum PVRSRV_ERROR eError;
+	struct SYS_DATA *psSysData;
+	struct PVRSRV_POWER_DEV *psPowerDevice;
+	enum PVR_POWER_STATE eNewDevicePowerState;
 
 	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	psPowerDevice = psSysData->psPowerDeviceList;
 	while (psPowerDevice) {
-		if (bAllDevices
-		    || (ui32DeviceIndex == psPowerDevice->ui32DeviceIndex)) {
-			eNewDevicePowerState =
-			    (eNewPowerState ==
+		if (bAllDevices ||
+		    (ui32DeviceIndex == psPowerDevice->ui32DeviceIndex)) {
+			eNewDevicePowerState = (eNewPowerState ==
 			     PVRSRV_POWER_Unspecified) ? psPowerDevice->
-			    eDefaultPowerState : eNewPowerState;
+			     eDefaultPowerState : eNewPowerState;
 
 			if (psPowerDevice->eCurrentPowerState !=
 			    eNewDevicePowerState) {
 
-				eError =
-				    SysDevicePostPowerState(psPowerDevice->
-							    ui32DeviceIndex,
-							    eNewDevicePowerState,
-							    psPowerDevice->
-							    eCurrentPowerState);
+				eError = SysDevicePostPowerState(
+					    psPowerDevice->ui32DeviceIndex,
+					    eNewDevicePowerState,
+					    psPowerDevice->eCurrentPowerState);
 				if (eError != PVRSRV_OK) {
-					pr_err
-					    ("SysDevicePostPowerState failed (%u)\n",
-					     eError);
+					pr_err("SysDevicePostPowerState failed "
+						"(%u)\n", eError);
 					return eError;
 				}
 
-				if (psPowerDevice->pfnPostPower != IMG_NULL) {
-
+				if (psPowerDevice->pfnPostPower != NULL) {
 					eError =
 					    psPowerDevice->
 					    pfnPostPower(psPowerDevice->
@@ -248,9 +237,9 @@
 							 psPowerDevice->
 							 eCurrentPowerState);
 					if (eError != PVRSRV_OK) {
-						pr_err
-						    ("pfnPostPower failed (%u)\n",
-						     eError);
+						pr_err(
+						   "pfnPostPower failed (%u)\n",
+						    eError);
 						return eError;
 					}
 				}
@@ -266,31 +255,26 @@
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVSetDevicePowerStateKM(IMG_UINT32 ui32DeviceIndex,
-					     PVR_POWER_STATE eNewPowerState,
-					     IMG_UINT32 ui32CallerID,
-					     IMG_BOOL bRetainMutex)
+enum PVRSRV_ERROR PVRSRVSetDevicePowerStateKM(u32 ui32DeviceIndex,
+				     enum PVR_POWER_STATE eNewPowerState,
+				     u32 ui32CallerID, IMG_BOOL bRetainMutex)
 {
-	PVRSRV_ERROR eError;
-	SYS_DATA *psSysData;
+	enum PVRSRV_ERROR eError;
+	struct SYS_DATA *psSysData;
 
 	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	eError = PVRSRVPowerLock(ui32CallerID, IMG_FALSE);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	eError =
 	    PVRSRVDevicePrePowerStateKM(IMG_FALSE, ui32DeviceIndex,
 					eNewPowerState);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		goto Exit;
-	}
 
 	eError =
 	    PVRSRVDevicePostPowerStateKM(IMG_FALSE, ui32DeviceIndex,
@@ -298,68 +282,61 @@
 
 Exit:
 
-	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVSetDevicePowerStateKM : Transition to %d FAILED 0x%x",
-			 eNewPowerState, eError));
-	}
+	if (eError != PVRSRV_OK)
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVSetDevicePowerStateKM : "
+			 "Transition to %d FAILED 0x%x",
+			 eNewPowerState, eError);
 
-	if (!bRetainMutex || (eError != PVRSRV_OK)) {
+	if (!bRetainMutex || (eError != PVRSRV_OK))
 		PVRSRVPowerUnlock(ui32CallerID);
-	}
 
 	return eError;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVSystemPrePowerStateKM(PVR_POWER_STATE eNewPowerState)
+enum PVRSRV_ERROR PVRSRVSystemPrePowerStateKM(
+		enum PVR_POWER_STATE eNewPowerState)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	SYS_DATA *psSysData;
-	PVR_POWER_STATE eNewDevicePowerState;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
+	struct SYS_DATA *psSysData;
+	enum PVR_POWER_STATE eNewDevicePowerState;
 
 	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	eError = PVRSRVPowerLock(KERNEL_ID, IMG_TRUE);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	if (_IsSystemStatePowered(eNewPowerState) !=
 	    _IsSystemStatePowered(psSysData->eCurrentPowerState)) {
-		if (_IsSystemStatePowered(eNewPowerState)) {
+		if (_IsSystemStatePowered(eNewPowerState))
 
 			eNewDevicePowerState = PVRSRV_POWER_Unspecified;
-		} else {
+		else
 			eNewDevicePowerState = PVRSRV_POWER_STATE_D3;
-		}
 
 		eError =
 		    PVRSRVDevicePrePowerStateKM(IMG_TRUE, 0,
 						eNewDevicePowerState);
-		if (eError != PVRSRV_OK) {
+		if (eError != PVRSRV_OK)
 			goto ErrorExit;
-		}
 	}
 
 	if (eNewPowerState != psSysData->eCurrentPowerState) {
 
 		eError = SysSystemPrePowerState(eNewPowerState);
-		if (eError != PVRSRV_OK) {
+		if (eError != PVRSRV_OK)
 			goto ErrorExit;
-		}
 	}
 
 	return eError;
 
 ErrorExit:
 
-	PVR_DPF((PVR_DBG_ERROR,
-		 "PVRSRVSystemPrePowerStateKM: Transition from %d to %d FAILED 0x%x",
-		 psSysData->eCurrentPowerState, eNewPowerState, eError));
+	PVR_DPF(PVR_DBG_ERROR, "PVRSRVSystemPrePowerStateKM: "
+		 "Transition from %d to %d FAILED 0x%x",
+		 psSysData->eCurrentPowerState, eNewPowerState, eError);
 
 	psSysData->eFailedPowerState = eNewPowerState;
 
@@ -368,46 +345,42 @@
 	return eError;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVSystemPostPowerStateKM(PVR_POWER_STATE eNewPowerState)
+enum PVRSRV_ERROR PVRSRVSystemPostPowerStateKM(
+		enum PVR_POWER_STATE eNewPowerState)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	SYS_DATA *psSysData;
-	PVR_POWER_STATE eNewDevicePowerState;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
+	struct SYS_DATA *psSysData;
+	enum PVR_POWER_STATE eNewDevicePowerState;
 
 	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		goto Exit;
-	}
 
 	if (eNewPowerState != psSysData->eCurrentPowerState) {
 
 		eError = SysSystemPostPowerState(eNewPowerState);
-		if (eError != PVRSRV_OK) {
+		if (eError != PVRSRV_OK)
 			goto Exit;
-		}
 	}
 
 	if (_IsSystemStatePowered(eNewPowerState) !=
 	    _IsSystemStatePowered(psSysData->eCurrentPowerState)) {
-		if (_IsSystemStatePowered(eNewPowerState)) {
+		if (_IsSystemStatePowered(eNewPowerState))
 
 			eNewDevicePowerState = PVRSRV_POWER_Unspecified;
-		} else {
+		else
 			eNewDevicePowerState = PVRSRV_POWER_STATE_D3;
-		}
 
 		eError =
 		    PVRSRVDevicePostPowerStateKM(IMG_TRUE, 0,
 						 eNewDevicePowerState);
-		if (eError != PVRSRV_OK) {
+		if (eError != PVRSRV_OK)
 			goto Exit;
-		}
 	}
 
-	PVR_DPF((PVR_DBG_WARNING,
-		 "PVRSRVSystemPostPowerStateKM: System Power Transition from %d to %d OK",
-		 psSysData->eCurrentPowerState, eNewPowerState));
+	PVR_DPF(PVR_DBG_WARNING, "PVRSRVSystemPostPowerStateKM: "
+		 "System Power Transition from %d to %d OK",
+		 psSysData->eCurrentPowerState, eNewPowerState);
 
 	psSysData->eCurrentPowerState = eNewPowerState;
 
@@ -416,33 +389,29 @@
 	PVRSRVPowerUnlock(KERNEL_ID);
 
 	if (_IsSystemStatePowered(eNewPowerState) &&
-	    PVRSRVGetInitServerState(PVRSRV_INIT_SERVER_SUCCESSFUL)) {
+	    PVRSRVGetInitServerState(PVRSRV_INIT_SERVER_SUCCESSFUL))
 
 		PVRSRVCommandCompleteCallbacks();
-	}
 
 	return eError;
 }
 
-IMG_EXPORT PVRSRV_ERROR PVRSRVSetPowerStateKM(PVR_POWER_STATE eNewPowerState)
+enum PVRSRV_ERROR PVRSRVSetPowerStateKM(enum PVR_POWER_STATE eNewPowerState)
 {
-	PVRSRV_ERROR eError;
-	SYS_DATA *psSysData;
+	enum PVRSRV_ERROR eError;
+	struct SYS_DATA *psSysData;
 
 	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	eError = PVRSRVSystemPrePowerStateKM(eNewPowerState);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		goto ErrorExit;
-	}
 
 	eError = PVRSRVSystemPostPowerStateKM(eNewPowerState);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		goto ErrorExit;
-	}
 
 	psSysData->eFailedPowerState = PVRSRV_POWER_Unspecified;
 
@@ -450,45 +419,44 @@
 
 ErrorExit:
 
-	PVR_DPF((PVR_DBG_ERROR,
+	PVR_DPF(PVR_DBG_ERROR,
 		 "PVRSRVSetPowerStateKM: Transition from %d to %d FAILED 0x%x",
-		 psSysData->eCurrentPowerState, eNewPowerState, eError));
+		 psSysData->eCurrentPowerState, eNewPowerState, eError);
 
 	psSysData->eFailedPowerState = eNewPowerState;
 
 	return eError;
 }
 
-PVRSRV_ERROR PVRSRVRegisterPowerDevice(IMG_UINT32 ui32DeviceIndex,
-				       PFN_PRE_POWER pfnPrePower,
-				       PFN_POST_POWER pfnPostPower,
-				       PFN_PRE_CLOCKSPEED_CHANGE
-				       pfnPreClockSpeedChange,
-				       PFN_POST_CLOCKSPEED_CHANGE
-				       pfnPostClockSpeedChange,
-				       IMG_HANDLE hDevCookie,
-				       PVR_POWER_STATE eCurrentPowerState,
-				       PVR_POWER_STATE eDefaultPowerState)
-{
-	PVRSRV_ERROR eError;
-	SYS_DATA *psSysData;
-	PVRSRV_POWER_DEV *psPowerDevice;
+enum PVRSRV_ERROR PVRSRVRegisterPowerDevice(u32 ui32DeviceIndex,
+       enum PVRSRV_ERROR (*pfnPrePower)(void *, enum PVR_POWER_STATE,
+				   enum PVR_POWER_STATE),
+       enum PVRSRV_ERROR (*pfnPostPower)(void *, enum PVR_POWER_STATE,
+				   enum PVR_POWER_STATE),
+       enum PVRSRV_ERROR (*pfnPreClockSpeedChange)(void *, IMG_BOOL,
+				   enum PVR_POWER_STATE),
+       enum PVRSRV_ERROR (*pfnPostClockSpeedChange)(void *, IMG_BOOL,
+				   enum PVR_POWER_STATE),
+       void *hDevCookie, enum PVR_POWER_STATE eCurrentPowerState,
+       enum PVR_POWER_STATE eDefaultPowerState)
+{
+	enum PVRSRV_ERROR eError;
+	struct SYS_DATA *psSysData;
+	struct PVRSRV_POWER_DEV *psPowerDevice;
 
-	if (pfnPrePower == IMG_NULL && pfnPostPower == IMG_NULL) {
+	if (pfnPrePower == NULL && pfnPostPower == NULL)
 		return PVRSRVRemovePowerDevice(ui32DeviceIndex);
-	}
 
 	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-			    sizeof(PVRSRV_POWER_DEV),
-			    (IMG_VOID **) & psPowerDevice, IMG_NULL);
+			    sizeof(struct PVRSRV_POWER_DEV),
+			    (void **) &psPowerDevice, NULL);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRegisterPowerDevice: Failed to alloc PVRSRV_POWER_DEV"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVRegisterPowerDevice: alloc failed");
 		return eError;
 	}
 
@@ -504,68 +472,61 @@
 	psPowerDevice->psNext = psSysData->psPowerDeviceList;
 	psSysData->psPowerDeviceList = psPowerDevice;
 
-	return (PVRSRV_OK);
+	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR PVRSRVRemovePowerDevice(IMG_UINT32 ui32DeviceIndex)
+enum PVRSRV_ERROR PVRSRVRemovePowerDevice(u32 ui32DeviceIndex)
 {
-	PVRSRV_ERROR eError;
-	SYS_DATA *psSysData;
-	PVRSRV_POWER_DEV *psCurrent, *psPrevious;
+	enum PVRSRV_ERROR eError;
+	struct SYS_DATA *psSysData;
+	struct PVRSRV_POWER_DEV *psCurrent, *psPrevious;
 
 	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	psCurrent = psSysData->psPowerDeviceList;
-	psPrevious = IMG_NULL;
+	psPrevious = NULL;
 
-	while (psCurrent) {
+	while (psCurrent)
 		if (psCurrent->ui32DeviceIndex == ui32DeviceIndex) {
 
-			if (psPrevious) {
+			if (psPrevious)
 				psPrevious->psNext = psCurrent->psNext;
-			} else {
+			else
 
 				psSysData->psPowerDeviceList =
 				    psCurrent->psNext;
-			}
 
 			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-				  sizeof(PVRSRV_POWER_DEV), psCurrent,
-				  IMG_NULL);
+				  sizeof(struct PVRSRV_POWER_DEV), psCurrent,
+				  NULL);
 
 			break;
 		} else {
 			psPrevious = psCurrent;
 			psCurrent = psCurrent->psNext;
 		}
-	}
 
-	return (PVRSRV_OK);
+	return PVRSRV_OK;
 }
 
-IMG_EXPORT IMG_BOOL PVRSRVIsDevicePowered(IMG_UINT32 ui32DeviceIndex)
+IMG_BOOL PVRSRVIsDevicePowered(u32 ui32DeviceIndex)
 {
-	PVRSRV_ERROR eError;
-	SYS_DATA *psSysData;
-	PVRSRV_POWER_DEV *psPowerDevice;
+	enum PVRSRV_ERROR eError;
+	struct SYS_DATA *psSysData;
+	struct PVRSRV_POWER_DEV *psPowerDevice;
 
 	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK) {
-		return IMG_FALSE;
-	}
-
-	if (IsPowerLocked())
+	if (eError != PVRSRV_OK)
 		return IMG_FALSE;
 
 	psPowerDevice = psSysData->psPowerDeviceList;
 	while (psPowerDevice) {
-		if (psPowerDevice->ui32DeviceIndex == ui32DeviceIndex) {
-			return (IMG_BOOL) (psPowerDevice->eCurrentPowerState ==
-					   PVRSRV_POWER_STATE_D0);
-		}
+		if (psPowerDevice->ui32DeviceIndex == ui32DeviceIndex)
+			return (IMG_BOOL)
+				(psPowerDevice->eCurrentPowerState ==
+						PVRSRV_POWER_STATE_D0);
 
 		psPowerDevice = psPowerDevice->psNext;
 	}
@@ -573,13 +534,13 @@
 	return IMG_FALSE;
 }
 
-PVRSRV_ERROR PVRSRVDevicePreClockSpeedChange(IMG_UINT32 ui32DeviceIndex,
+enum PVRSRV_ERROR PVRSRVDevicePreClockSpeedChange(u32 ui32DeviceIndex,
 					     IMG_BOOL bIdleDevice,
-					     IMG_VOID * pvInfo)
+					     void *pvInfo)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	SYS_DATA *psSysData;
-	PVRSRV_POWER_DEV *psPowerDevice;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
+	struct SYS_DATA *psSysData;
+	struct PVRSRV_POWER_DEV *psPowerDevice;
 
 	PVR_UNREFERENCED_PARAMETER(pvInfo);
 
@@ -587,7 +548,7 @@
 
 	psPowerDevice = psSysData->psPowerDeviceList;
 	while (psPowerDevice) {
-		if (ui32DeviceIndex == psPowerDevice->ui32DeviceIndex) {
+		if (ui32DeviceIndex == psPowerDevice->ui32DeviceIndex)
 			if (psPowerDevice->pfnPreClockSpeedChange) {
 				eError =
 				    psPowerDevice->
@@ -599,25 +560,25 @@
 				if (eError != PVRSRV_OK) {
 					pr_err
 					    ("pfnPreClockSpeedChange failed\n");
-					PVR_DPF((PVR_DBG_ERROR,
-						 "PVRSRVDevicePreClockSpeedChange : Device %lu failed, error:0x%lx",
-						 ui32DeviceIndex, eError));
+					PVR_DPF(PVR_DBG_ERROR,
+					    "PVRSRVDevicePreClockSpeedChange : "
+					    "Device %lu failed, error:0x%lx",
+						 ui32DeviceIndex, eError);
 				}
 			}
-		}
 
 		psPowerDevice = psPowerDevice->psNext;
 	}
 	return eError;
 }
 
-IMG_VOID PVRSRVDevicePostClockSpeedChange(IMG_UINT32 ui32DeviceIndex,
+void PVRSRVDevicePostClockSpeedChange(u32 ui32DeviceIndex,
 					  IMG_BOOL bIdleDevice,
-					  IMG_VOID * pvInfo)
+					  void *pvInfo)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	SYS_DATA *psSysData;
-	PVRSRV_POWER_DEV *psPowerDevice;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
+	struct SYS_DATA *psSysData;
+	struct PVRSRV_POWER_DEV *psPowerDevice;
 
 	PVR_UNREFERENCED_PARAMETER(pvInfo);
 
@@ -625,7 +586,7 @@
 
 	psPowerDevice = psSysData->psPowerDeviceList;
 	while (psPowerDevice) {
-		if (ui32DeviceIndex == psPowerDevice->ui32DeviceIndex) {
+		if (ui32DeviceIndex == psPowerDevice->ui32DeviceIndex)
 			if (psPowerDevice->pfnPostClockSpeedChange) {
 				eError =
 				    psPowerDevice->
@@ -636,13 +597,13 @@
 							    eCurrentPowerState);
 				if (eError != PVRSRV_OK) {
 					pr_err
-					    ("pfnPostClockSpeedChange failed\n");
-					PVR_DPF((PVR_DBG_ERROR,
-						 "PVRSRVDevicePostClockSpeedChange : Device %lu failed, error:0x%lx",
-						 ui32DeviceIndex, eError));
+					   ("pfnPostClockSpeedChange failed\n");
+					PVR_DPF(PVR_DBG_ERROR,
+					  "PVRSRVDevicePostClockSpeedChange : "
+					  "Device %lu failed, error:0x%lx",
+						 ui32DeviceIndex, eError);
 				}
 			}
-		}
 
 		psPowerDevice = psPowerDevice->psNext;
 	}
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/power.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/power.h
@@ -1,118 +1,104 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef POWER_H
 #define POWER_H
 
-
-	typedef struct _PVRSRV_POWER_DEV_TAG_ {
-		PFN_PRE_POWER pfnPrePower;
-		PFN_POST_POWER pfnPostPower;
-		PFN_PRE_CLOCKSPEED_CHANGE pfnPreClockSpeedChange;
-		PFN_POST_CLOCKSPEED_CHANGE pfnPostClockSpeedChange;
-		IMG_HANDLE hDevCookie;
-		IMG_UINT32 ui32DeviceIndex;
-		PVR_POWER_STATE eDefaultPowerState;
-		PVR_POWER_STATE eCurrentPowerState;
-		struct _PVRSRV_POWER_DEV_TAG_ *psNext;
-
-	} PVRSRV_POWER_DEV;
-
-	typedef enum _PVRSRV_INIT_SERVER_STATE_ {
-		PVRSRV_INIT_SERVER_Unspecified = -1,
-		PVRSRV_INIT_SERVER_RUNNING = 0,
-		PVRSRV_INIT_SERVER_RAN = 1,
-		PVRSRV_INIT_SERVER_SUCCESSFUL = 2,
-		PVRSRV_INIT_SERVER_NUM = 3,
-		PVRSRV_INIT_SERVER_FORCE_I32 = 0x7fffffff
-	} PVRSRV_INIT_SERVER_STATE, *PPVRSRV_INIT_SERVER_STATE;
-
-	 IMG_IMPORT
-	    IMG_BOOL PVRSRVGetInitServerState(PVRSRV_INIT_SERVER_STATE
-					      eInitServerState);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVSetInitServerState(PVRSRV_INIT_SERVER_STATE
-						  eInitServerState,
-						  IMG_BOOL bState);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVPowerLock(IMG_UINT32 ui32CallerID,
-					 IMG_BOOL bSystemPowerEvent);
-	 IMG_IMPORT IMG_VOID PVRSRVPowerUnlock(IMG_UINT32 ui32CallerID);
-
-	 IMG_IMPORT IMG_VOID PVRSRVDvfsLock(IMG_VOID);
-
-	 IMG_IMPORT IMG_VOID PVRSRVDvfsUnlock(IMG_VOID);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVSetDevicePowerStateKM(IMG_UINT32 ui32DeviceIndex,
-						     PVR_POWER_STATE
-						     eNewPowerState,
-						     IMG_UINT32 ui32CallerID,
-						     IMG_BOOL bRetainMutex);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVSystemPrePowerStateKM(PVR_POWER_STATE
-						     eNewPowerState);
-	 IMG_IMPORT PVRSRV_ERROR PVRSRVSystemPostPowerStateKM(PVR_POWER_STATE
-							      eNewPowerState);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVSetPowerStateKM(PVR_POWER_STATE ePVRState);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVRegisterPowerDevice(IMG_UINT32 ui32DeviceIndex,
-						   PFN_PRE_POWER pfnPrePower,
-						   PFN_POST_POWER pfnPostPower,
-						   PFN_PRE_CLOCKSPEED_CHANGE
-						   pfnPreClockSpeedChange,
-						   PFN_POST_CLOCKSPEED_CHANGE
-						   pfnPostClockSpeedChange,
-						   IMG_HANDLE hDevCookie,
-						   PVR_POWER_STATE
-						   eCurrentPowerState,
-						   PVR_POWER_STATE
-						   eDefaultPowerState);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVRemovePowerDevice(IMG_UINT32 ui32DeviceIndex);
-
-	 IMG_IMPORT IMG_BOOL PVRSRVIsDevicePowered(IMG_UINT32 ui32DeviceIndex);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVDevicePreClockSpeedChange(IMG_UINT32
-							 ui32DeviceIndex,
-							 IMG_BOOL bIdleDevice,
-							 IMG_VOID * pvInfo);
-
-	 IMG_IMPORT
-	    IMG_VOID PVRSRVDevicePostClockSpeedChange(IMG_UINT32
-						      ui32DeviceIndex,
-						      IMG_BOOL bIdleDevice,
-						      IMG_VOID * pvInfo);
+struct PVRSRV_POWER_DEV {
+	enum PVRSRV_ERROR (*pfnPrePower)(void *, enum PVR_POWER_STATE,
+			      enum PVR_POWER_STATE);
+	enum PVRSRV_ERROR (*pfnPostPower)(void *, enum PVR_POWER_STATE,
+			       enum PVR_POWER_STATE);
+	enum PVRSRV_ERROR (*pfnPreClockSpeedChange)(void *, IMG_BOOL,
+					  enum PVR_POWER_STATE);
+	enum PVRSRV_ERROR (*pfnPostClockSpeedChange)(void *, IMG_BOOL,
+					   enum PVR_POWER_STATE);
+	void *hDevCookie;
+	u32 ui32DeviceIndex;
+	enum PVR_POWER_STATE eDefaultPowerState;
+	enum PVR_POWER_STATE eCurrentPowerState;
+	struct PVRSRV_POWER_DEV *psNext;
+
+};
+
+enum PVRSRV_INIT_SERVER_STATE {
+	PVRSRV_INIT_SERVER_Unspecified = -1,
+	PVRSRV_INIT_SERVER_RUNNING = 0,
+	PVRSRV_INIT_SERVER_RAN = 1,
+	PVRSRV_INIT_SERVER_SUCCESSFUL = 2,
+	PVRSRV_INIT_SERVER_NUM = 3,
+	PVRSRV_INIT_SERVER_FORCE_I32 = 0x7fffffff
+};
+
+IMG_BOOL PVRSRVGetInitServerState(enum PVRSRV_INIT_SERVER_STATE
+		eInitServerState);
+
+enum PVRSRV_ERROR PVRSRVSetInitServerState(enum PVRSRV_INIT_SERVER_STATE
+		eInitServerState,
+		IMG_BOOL bState);
+
+enum PVRSRV_ERROR PVRSRVPowerLock(u32 ui32CallerID,
+		IMG_BOOL bSystemPowerEvent);
+void PVRSRVPowerUnlock(u32 ui32CallerID);
+void PVRSRVDvfsLock(void);
+void PVRSRVDvfsUnlock(void);
+
+enum PVRSRV_ERROR PVRSRVSetDevicePowerStateKM(u32 ui32DeviceIndex,
+		enum PVR_POWER_STATE eNewPowerState, u32 ui32CallerID,
+		IMG_BOOL bRetainMutex);
+
+enum PVRSRV_ERROR PVRSRVSystemPrePowerStateKM(
+		enum PVR_POWER_STATE eNewPowerState);
+enum PVRSRV_ERROR PVRSRVSystemPostPowerStateKM(
+		enum PVR_POWER_STATE eNewPowerState);
+
+enum PVRSRV_ERROR PVRSRVSetPowerStateKM(enum PVR_POWER_STATE ePVRState);
+
+enum PVRSRV_ERROR PVRSRVRegisterPowerDevice(u32 ui32DeviceIndex,
+		enum PVRSRV_ERROR (*pfnPrePower)(void *, enum PVR_POWER_STATE,
+					    enum PVR_POWER_STATE),
+		enum PVRSRV_ERROR (*pfnPostPower)(void *, enum PVR_POWER_STATE,
+					     enum PVR_POWER_STATE),
+		enum PVRSRV_ERROR (*pfnPreClockSpeedChange)(void *, IMG_BOOL,
+						       enum PVR_POWER_STATE),
+		enum PVRSRV_ERROR (*pfnPostClockSpeedChange)(void *, IMG_BOOL,
+							enum PVR_POWER_STATE),
+		void *hDevCookie, enum PVR_POWER_STATE eCurrentPowerState,
+		enum PVR_POWER_STATE eDefaultPowerState);
+
+enum PVRSRV_ERROR PVRSRVRemovePowerDevice(u32 ui32DeviceIndex);
+
+IMG_BOOL PVRSRVIsDevicePowered(u32 ui32DeviceIndex);
+
+enum PVRSRV_ERROR PVRSRVDevicePreClockSpeedChange(u32 ui32DeviceIndex,
+		IMG_BOOL bIdleDevice,
+		void *pvInfo);
+
+void PVRSRVDevicePostClockSpeedChange(u32 ui32DeviceIndex,
+		IMG_BOOL bIdleDevice,
+		void *pvInfo);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/proc.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/proc.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -43,14 +43,6 @@
 #include "pvrversion.h"
 #include "proc.h"
 
-#ifdef DEBUG
-int PVRDebugProcSetLevel(struct file *file, const char *buffer,
-			 unsigned long count, void *data);
-int PVRDebugProcGetLevel(char *page, char **start, off_t off, int count,
-			 int *eof, void *data);
-
-#endif
-
 static struct proc_dir_entry *dir;
 
 static off_t procDumpSysNodes(char *buf, size_t size, off_t off);
@@ -63,22 +55,19 @@
 	va_list ap;
 
 	va_start(ap, format);
-
 	n = vsnprintf(buffer + off, space, format, ap);
-
 	va_end(ap);
 
-	if (n > space || n < 0) {
+	if (n > space || n < 0)
 		return size;
-	} else {
+	else
 		return off + n;
-	}
 }
 
 static int pvr_read_proc(char *page, char **start, off_t off,
 			 int count, int *eof, void *data)
 {
-	pvr_read_proc_t *pprn = data;
+	off_t (*pprn)(char *, size_t, off_t) = data;
 
 	off_t len = pprn(page, count, off);
 
@@ -101,21 +90,19 @@
 	mode_t mode;
 
 	if (!dir) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "CreateProcEntry: cannot make proc entry /proc/pvr/%s: no parent",
-			 name));
+		PVR_DPF(PVR_DBG_ERROR, "CreateProcEntry: "
+			"cannot make proc entry /proc/pvr/%s: no parent",
+			 name);
 		return -ENOMEM;
 	}
 
 	mode = S_IFREG;
 
-	if (rhandler) {
+	if (rhandler)
 		mode |= S_IRUGO;
-	}
 
-	if (whandler) {
+	if (whandler)
 		mode |= S_IWUSR;
-	}
 
 	file = create_proc_entry(name, mode, dir);
 
@@ -125,26 +112,26 @@
 		file->write_proc = whandler;
 		file->data = data;
 
-		PVR_DPF((PVR_DBG_MESSAGE, "Created /proc/pvr/%s", name));
+		PVR_DPF(PVR_DBG_MESSAGE, "Created /proc/pvr/%s", name);
 
 		return 0;
 	}
 
-	PVR_DPF((PVR_DBG_ERROR,
-		 "CreateProcEntry: cannot make proc entry /proc/pvr/%s: no memory",
-		 name));
+	PVR_DPF(PVR_DBG_ERROR, "CreateProcEntry: "
+		 "cannot make proc entry /proc/pvr/%s: no memory", name);
 
 	return -ENOMEM;
 }
 
-int CreateProcReadEntry(const char *name, pvr_read_proc_t handler)
+int CreateProcReadEntry(const char *name,
+			off_t (handler)(char *, size_t, off_t))
 {
 	struct proc_dir_entry *file;
 
 	if (!dir) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "CreateProcReadEntry: cannot make proc entry /proc/pvr/%s: no parent",
-			 name));
+		PVR_DPF(PVR_DBG_ERROR, "CreateProcReadEntry: "
+			 "cannot make proc entry /proc/pvr/%s: no parent",
+			 name);
 
 		return -ENOMEM;
 	}
@@ -159,9 +146,9 @@
 		return 0;
 	}
 
-	PVR_DPF((PVR_DBG_ERROR,
-		 "CreateProcReadEntry: cannot make proc entry /proc/pvr/%s: no memory",
-		 name));
+	PVR_DPF(PVR_DBG_ERROR, "CreateProcReadEntry: "
+			"cannot make proc entry /proc/pvr/%s: no memory",
+		 name);
 
 	return -ENOMEM;
 }
@@ -171,8 +158,8 @@
 	dir = proc_mkdir("pvr", NULL);
 
 	if (!dir) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "CreateProcEntries: cannot make /proc/pvr directory"));
+		PVR_DPF(PVR_DBG_ERROR, "CreateProcEntries: "
+			"cannot make /proc/pvr directory");
 
 		return -ENOMEM;
 	}
@@ -180,16 +167,16 @@
 	if (CreateProcReadEntry("queue", QueuePrintQueues) ||
 	    CreateProcReadEntry("version", procDumpVersion) ||
 	    CreateProcReadEntry("nodes", procDumpSysNodes)) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "CreateProcEntries: couldn't make /proc/pvr files"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "CreateProcEntries: couldn't make /proc/pvr files");
 
 		return -ENOMEM;
 	}
 #ifdef DEBUG
 	if (CreateProcEntry
-	    ("debug_level", PVRDebugProcGetLevel, PVRDebugProcSetLevel, 0)) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "CreateProcEntries: couldn't make /proc/pvr/debug_level"));
+	    ("debug_level", PVRDebugProcGetLevel, PVRDebugProcSetLevel, NULL)) {
+		PVR_DPF(PVR_DBG_ERROR, "CreateProcEntries: "
+			"couldn't make /proc/pvr/debug_level");
 
 		return -ENOMEM;
 	}
@@ -200,11 +187,10 @@
 
 void RemoveProcEntry(const char *name)
 {
-	if (dir) {
+	if (dir)
 		remove_proc_entry(name, dir);
-	}
 
-	PVR_DPF((PVR_DBG_MESSAGE, "Removing /proc/pvr/%s", name));
+	PVR_DPF(PVR_DBG_MESSAGE, "Removing /proc/pvr/%s", name);
 }
 
 void RemoveProcEntries(void)
@@ -217,8 +203,8 @@
 	RemoveProcEntry("version");
 
 	while (dir->subdir) {
-		PVR_DPF((PVR_DBG_WARNING, "Belatedly removing /proc/pvr/%s",
-			 dir->subdir->name));
+		PVR_DPF(PVR_DBG_WARNING, "Belatedly removing /proc/pvr/%s",
+			 dir->subdir->name);
 
 		RemoveProcEntry(dir->subdir->name);
 	}
@@ -228,54 +214,45 @@
 
 static off_t procDumpVersion(char *buf, size_t size, off_t off)
 {
-	SYS_DATA *psSysData;
+	struct SYS_DATA *psSysData;
 
-	if (off == 0) {
-		return printAppend(buf, size, 0,
-				   "Version %s (%s) %s\n",
-				   PVRVERSION_STRING,
-				   PVR_BUILD_TYPE, PVR_BUILD_DIR);
-	}
+	if (off == 0)
+		return printAppend(buf, size, 0, "Version %s (%s) %s\n",
+				   PVRVERSION_STRING, PVR_BUILD_TYPE,
+				   PVR_BUILD_DIR);
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
+	if (SysAcquireData(&psSysData) != PVRSRV_OK)
 		return PVRSRV_ERROR_GENERIC;
-	}
 
 	if (off == 1) {
-		IMG_CHAR *pszSystemVersionString = "None";
+		char *pszSystemVersionString = "None";
 
-		if (psSysData->pszVersionString) {
+		if (psSysData->pszVersionString)
 			pszSystemVersionString = psSysData->pszVersionString;
-		}
 
-		if (strlen(pszSystemVersionString)
-		    + strlen("System Version String: \n")
-		    + 1 > size) {
+		if (strlen(pszSystemVersionString) +
+		    strlen("System Version String: \n") + 1 > size)
 			return 0;
-		}
-		return printAppend(buf, size, 0,
-				   "System Version String: %s\n",
+		return printAppend(buf, size, 0, "System Version String: %s\n",
 				   pszSystemVersionString);
 	}
 
 	return END_OF_FILE;
 }
 
-static const char *deviceTypeToString(PVRSRV_DEVICE_TYPE deviceType)
+static const char *deviceTypeToString(enum PVRSRV_DEVICE_TYPE deviceType)
 {
 	switch (deviceType) {
 	default:
 		{
 			static char text[10];
-
 			sprintf(text, "?%x", deviceType);
-
 			return text;
 		}
 	}
 }
 
-static const char *deviceClassToString(PVRSRV_DEVICE_CLASS deviceClass)
+static const char *deviceClassToString(enum PVRSRV_DEVICE_CLASS deviceClass)
 {
 	switch (deviceClass) {
 	case PVRSRV_DEVICE_CLASS_3D:
@@ -303,33 +280,30 @@
 static
 off_t procDumpSysNodes(char *buf, size_t size, off_t off)
 {
-	SYS_DATA *psSysData;
-	PVRSRV_DEVICE_NODE *psDevNode;
+	struct SYS_DATA *psSysData;
+	struct PVRSRV_DEVICE_NODE *psDevNode;
 	off_t len;
 
-	if (size < 80) {
+	if (size < 80)
 		return 0;
-	}
 
-	if (off == 0) {
-		return printAppend(buf, size, 0,
-				   "Registered nodes\n"
-				   "Addr     Type     Class    Index Ref pvDev     Size Res\n");
-	}
+	if (off == 0)
+		return printAppend(buf, size, 0, "Registered nodes\n"
+			"Addr     Type     Class    Index Ref pvDev     "
+			"Size Res\n");
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
+	if (SysAcquireData(&psSysData) != PVRSRV_OK)
 		return PVRSRV_ERROR_GENERIC;
-	}
 
 	for (psDevNode = psSysData->psDeviceNodeList;
-	     --off && psDevNode; psDevNode = psDevNode->psNext) ;
+	     --off && psDevNode; psDevNode = psDevNode->psNext)
+		;
 
-	if (!psDevNode) {
+	if (!psDevNode)
 		return END_OF_FILE;
-	}
 
 	len = printAppend(buf, size, 0,
-			  "%p %-8s %-8s %4d  %2lu  %p  %3lu  %p\n",
+			  "%p %-8s %-8s %4d  %2u  %p  %3u  %p\n",
 			  psDevNode,
 			  deviceTypeToString(psDevNode->sDevId.eDeviceType),
 			  deviceClassToString(psDevNode->sDevId.eDeviceClass),
@@ -338,5 +312,5 @@
 			  psDevNode->pvDevice,
 			  psDevNode->ui32pvDeviceSize,
 			  psDevNode->hResManContext);
-	return (len);
+	return len;
 }
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/proc.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/proc.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -30,22 +30,18 @@
 #include <asm/system.h>
 #include <linux/proc_fs.h>
 
-#define END_OF_FILE (off_t) -1
-
-typedef off_t(pvr_read_proc_t) (char *, size_t, off_t);
+#define END_OF_FILE ((off_t) -1)
 
-off_t printAppend(char *buffer, size_t size, off_t off, const char *format, ...)
-    __attribute__ ((format(printf, 4, 5)));
+off_t printAppend(char *buffer, size_t size, off_t off,
+		  const char *format, ...)
+		  __attribute__ ((format(printf, 4, 5)));
 
 int CreateProcEntries(void);
-
-int CreateProcReadEntry(const char *name, pvr_read_proc_t handler);
-
+int CreateProcReadEntry(const char *name,
+			off_t (handler)(char *, size_t, off_t));
 int CreateProcEntry(const char *name, read_proc_t rhandler,
 		    write_proc_t whandler, void *data);
-
 void RemoveProcEntry(const char *name);
-
 void RemoveProcEntries(void);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/pvr_bridge.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/pvr_bridge.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -34,980 +34,1021 @@
 #include <linux/ioctl.h>
 
 #define PVRSRV_IOC_GID      'g'
-#define PVRSRV_IO(INDEX)    _IO(PVRSRV_IOC_GID, INDEX, PVRSRV_BRIDGE_PACKAGE)
-#define PVRSRV_IOW(INDEX)   _IOW(PVRSRV_IOC_GID, INDEX, PVRSRV_BRIDGE_PACKAGE)
-#define PVRSRV_IOR(INDEX)   _IOR(PVRSRV_IOC_GID, INDEX, PVRSRV_BRIDGE_PACKAGE)
-#define PVRSRV_IOWR(INDEX)  _IOWR(PVRSRV_IOC_GID, INDEX, PVRSRV_BRIDGE_PACKAGE)
+#define PVRSRV_IO(INDEX) \
+	_IO(PVRSRV_IOC_GID, INDEX, struct PVRSRV_BRIDGE_PACKAGE)
+#define PVRSRV_IOW(INDEX) \
+	_IOW(PVRSRV_IOC_GID, INDEX, struct PVRSRV_BRIDGE_PACKAGE)
+#define PVRSRV_IOR(INDEX) \
+	_IOR(PVRSRV_IOC_GID, INDEX, struct PVRSRV_BRIDGE_PACKAGE)
+#define PVRSRV_IOWR(INDEX) \
+	_IOWR(PVRSRV_IOC_GID, INDEX, struct PVRSRV_BRIDGE_PACKAGE)
 
 
 #define PVRSRV_BRIDGE_CORE_CMD_FIRST			0
-#define PVRSRV_BRIDGE_ENUM_DEVICES				PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+0)
-#define PVRSRV_BRIDGE_ACQUIRE_DEVICEINFO		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+1)
-#define PVRSRV_BRIDGE_RELEASE_DEVICEINFO		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+2)
-#define PVRSRV_BRIDGE_CREATE_DEVMEMCONTEXT		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+3)
-#define PVRSRV_BRIDGE_DESTROY_DEVMEMCONTEXT		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+4)
-#define PVRSRV_BRIDGE_GET_DEVMEM_HEAPINFO		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+5)
-#define PVRSRV_BRIDGE_ALLOC_DEVICEMEM			PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+6)
-#define PVRSRV_BRIDGE_FREE_DEVICEMEM			PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+7)
-#define PVRSRV_BRIDGE_GETFREE_DEVICEMEM			PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+8)
-#define PVRSRV_BRIDGE_CREATE_COMMANDQUEUE		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+9)
-#define PVRSRV_BRIDGE_DESTROY_COMMANDQUEUE		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+10)
-#define	PVRSRV_BRIDGE_KV_TO_MMAP_DATA           PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+11)
-#define PVRSRV_BRIDGE_CONNECT_SERVICES			PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+12)
-#define PVRSRV_BRIDGE_DISCONNECT_SERVICES		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+13)
-#define PVRSRV_BRIDGE_WRAP_DEVICE_MEM			PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+14)
-#define PVRSRV_BRIDGE_GET_DEVICEMEMINFO			PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+15)
-#define PVRSRV_BRIDGE_RESERVE_DEV_VIRTMEM		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+16)
-#define PVRSRV_BRIDGE_FREE_DEV_VIRTMEM			PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+17)
-#define PVRSRV_BRIDGE_MAP_EXT_MEMORY			PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+18)
-#define PVRSRV_BRIDGE_UNMAP_EXT_MEMORY			PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+19)
-#define PVRSRV_BRIDGE_MAP_DEV_MEMORY			PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+20)
-#define PVRSRV_BRIDGE_UNMAP_DEV_MEMORY			PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+21)
-#define PVRSRV_BRIDGE_MAP_DEVICECLASS_MEMORY	PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+22)
-#define PVRSRV_BRIDGE_UNMAP_DEVICECLASS_MEMORY	PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+23)
-#define PVRSRV_BRIDGE_MAP_MEM_INFO_TO_USER		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+24)
-#define PVRSRV_BRIDGE_UNMAP_MEM_INFO_FROM_USER	PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+25)
-#define PVRSRV_BRIDGE_CACHE_FLUSH_DRM			PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+26)
-#define PVRSRV_BRIDGE_CORE_CMD_LAST				(PVRSRV_BRIDGE_CORE_CMD_FIRST+26)
-
-#define PVRSRV_BRIDGE_SIM_CMD_FIRST				(PVRSRV_BRIDGE_CORE_CMD_LAST+1)
-#define PVRSRV_BRIDGE_PROCESS_SIMISR_EVENT		PVRSRV_IOWR(PVRSRV_BRIDGE_SIM_CMD_FIRST+0)
-#define PVRSRV_BRIDGE_REGISTER_SIM_PROCESS		PVRSRV_IOWR(PVRSRV_BRIDGE_SIM_CMD_FIRST+1)
-#define PVRSRV_BRIDGE_UNREGISTER_SIM_PROCESS	PVRSRV_IOWR(PVRSRV_BRIDGE_SIM_CMD_FIRST+2)
-#define PVRSRV_BRIDGE_SIM_CMD_LAST				(PVRSRV_BRIDGE_SIM_CMD_FIRST+2)
-
-#define PVRSRV_BRIDGE_MAPPING_CMD_FIRST			(PVRSRV_BRIDGE_SIM_CMD_LAST+1)
-#define PVRSRV_BRIDGE_MAPPHYSTOUSERSPACE		PVRSRV_IOWR(PVRSRV_BRIDGE_MAPPING_CMD_FIRST+0)
-#define PVRSRV_BRIDGE_UNMAPPHYSTOUSERSPACE		PVRSRV_IOWR(PVRSRV_BRIDGE_MAPPING_CMD_FIRST+1)
-#define PVRSRV_BRIDGE_GETPHYSTOUSERSPACEMAP		PVRSRV_IOWR(PVRSRV_BRIDGE_MAPPING_CMD_FIRST+2)
-#define PVRSRV_BRIDGE_MAPPING_CMD_LAST			(PVRSRV_BRIDGE_MAPPING_CMD_FIRST+2)
-
-#define PVRSRV_BRIDGE_STATS_CMD_FIRST			(PVRSRV_BRIDGE_MAPPING_CMD_LAST+1)
-#define	PVRSRV_BRIDGE_GET_FB_STATS				PVRSRV_IOWR(PVRSRV_BRIDGE_STATS_CMD_FIRST+0)
-#define PVRSRV_BRIDGE_STATS_CMD_LAST			(PVRSRV_BRIDGE_STATS_CMD_FIRST+0)
-
-#define PVRSRV_BRIDGE_MISC_CMD_FIRST			(PVRSRV_BRIDGE_STATS_CMD_LAST+1)
-#define PVRSRV_BRIDGE_GET_MISC_INFO				PVRSRV_IOWR(PVRSRV_BRIDGE_MISC_CMD_FIRST+0)
-#define PVRSRV_BRIDGE_RELEASE_MISC_INFO			PVRSRV_IOWR(PVRSRV_BRIDGE_MISC_CMD_FIRST+1)
-#define PVRSRV_BRIDGE_MISC_CMD_LAST				(PVRSRV_BRIDGE_MISC_CMD_FIRST+1)
-
-#define PVRSRV_BRIDGE_OVERLAY_CMD_FIRST			(PVRSRV_BRIDGE_MISC_CMD_LAST+1)
-#define PVRSRV_BRIDGE_OVERLAY_CMD_LAST			(PVRSRV_BRIDGE_OVERLAY_CMD_FIRST+1)
+#define PVRSRV_BRIDGE_ENUM_DEVICES				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+0)
+#define PVRSRV_BRIDGE_ACQUIRE_DEVICEINFO			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+1)
+#define PVRSRV_BRIDGE_RELEASE_DEVICEINFO			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+2)
+#define PVRSRV_BRIDGE_CREATE_DEVMEMCONTEXT			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+3)
+#define PVRSRV_BRIDGE_DESTROY_DEVMEMCONTEXT			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+4)
+#define PVRSRV_BRIDGE_GET_DEVMEM_HEAPINFO			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+5)
+#define PVRSRV_BRIDGE_ALLOC_DEVICEMEM				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+6)
+#define PVRSRV_BRIDGE_FREE_DEVICEMEM				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+7)
+#define PVRSRV_BRIDGE_GETFREE_DEVICEMEM				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+8)
+#define PVRSRV_BRIDGE_CREATE_COMMANDQUEUE			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+9)
+#define PVRSRV_BRIDGE_DESTROY_COMMANDQUEUE			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+10)
+#define	PVRSRV_BRIDGE_KV_TO_MMAP_DATA				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+11)
+#define PVRSRV_BRIDGE_CONNECT_SERVICES				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+12)
+#define PVRSRV_BRIDGE_DISCONNECT_SERVICES			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+13)
+#define PVRSRV_BRIDGE_WRAP_DEVICE_MEM				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+14)
+#define PVRSRV_BRIDGE_GET_DEVICEMEMINFO				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+15)
+#define PVRSRV_BRIDGE_RESERVE_DEV_VIRTMEM			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+16)
+#define PVRSRV_BRIDGE_FREE_DEV_VIRTMEM				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+17)
+#define PVRSRV_BRIDGE_MAP_EXT_MEMORY				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+18)
+#define PVRSRV_BRIDGE_UNMAP_EXT_MEMORY				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+19)
+#define PVRSRV_BRIDGE_MAP_DEV_MEMORY				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+20)
+#define PVRSRV_BRIDGE_UNMAP_DEV_MEMORY				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+21)
+#define PVRSRV_BRIDGE_MAP_DEVICECLASS_MEMORY			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+22)
+#define PVRSRV_BRIDGE_UNMAP_DEVICECLASS_MEMORY			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+23)
+#define PVRSRV_BRIDGE_MAP_MEM_INFO_TO_USER			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+24)
+#define PVRSRV_BRIDGE_UNMAP_MEM_INFO_FROM_USER			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+25)
+#define PVRSRV_BRIDGE_CACHE_FLUSH_DRM				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+26)
+#define PVRSRV_BRIDGE_CORE_CMD_LAST				\
+		(PVRSRV_BRIDGE_CORE_CMD_FIRST+26)
+
+#define PVRSRV_BRIDGE_SIM_CMD_FIRST				\
+		(PVRSRV_BRIDGE_CORE_CMD_LAST+1)
+#define PVRSRV_BRIDGE_PROCESS_SIMISR_EVENT			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_SIM_CMD_FIRST+0)
+#define PVRSRV_BRIDGE_REGISTER_SIM_PROCESS			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_SIM_CMD_FIRST+1)
+#define PVRSRV_BRIDGE_UNREGISTER_SIM_PROCESS			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_SIM_CMD_FIRST+2)
+#define PVRSRV_BRIDGE_SIM_CMD_LAST				\
+		(PVRSRV_BRIDGE_SIM_CMD_FIRST+2)
+
+#define PVRSRV_BRIDGE_MAPPING_CMD_FIRST				\
+		(PVRSRV_BRIDGE_SIM_CMD_LAST+1)
+#define PVRSRV_BRIDGE_MAPPHYSTOUSERSPACE			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_MAPPING_CMD_FIRST+0)
+#define PVRSRV_BRIDGE_UNMAPPHYSTOUSERSPACE			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_MAPPING_CMD_FIRST+1)
+#define PVRSRV_BRIDGE_GETPHYSTOUSERSPACEMAP			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_MAPPING_CMD_FIRST+2)
+#define PVRSRV_BRIDGE_MAPPING_CMD_LAST				\
+		(PVRSRV_BRIDGE_MAPPING_CMD_FIRST+2)
+
+#define PVRSRV_BRIDGE_STATS_CMD_FIRST				\
+		(PVRSRV_BRIDGE_MAPPING_CMD_LAST+1)
+#define	PVRSRV_BRIDGE_GET_FB_STATS				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_STATS_CMD_FIRST+0)
+#define PVRSRV_BRIDGE_STATS_CMD_LAST				\
+		(PVRSRV_BRIDGE_STATS_CMD_FIRST+0)
+
+#define PVRSRV_BRIDGE_MISC_CMD_FIRST				\
+		(PVRSRV_BRIDGE_STATS_CMD_LAST+1)
+#define PVRSRV_BRIDGE_GET_MISC_INFO				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_MISC_CMD_FIRST+0)
+#define PVRSRV_BRIDGE_RELEASE_MISC_INFO				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_MISC_CMD_FIRST+1)
+#define PVRSRV_BRIDGE_MISC_CMD_LAST				\
+		(PVRSRV_BRIDGE_MISC_CMD_FIRST+1)
+
+#define PVRSRV_BRIDGE_OVERLAY_CMD_FIRST				\
+		(PVRSRV_BRIDGE_MISC_CMD_LAST+1)
+#define PVRSRV_BRIDGE_OVERLAY_CMD_LAST				\
+		(PVRSRV_BRIDGE_OVERLAY_CMD_FIRST+1)
 
 #if defined(PDUMP)
-#define PVRSRV_BRIDGE_PDUMP_CMD_FIRST			(PVRSRV_BRIDGE_OVERLAY_CMD_FIRST+1)
-#define PVRSRV_BRIDGE_PDUMP_INIT			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+0)
-#define PVRSRV_BRIDGE_PDUMP_MEMPOL			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+1)
-#define PVRSRV_BRIDGE_PDUMP_DUMPMEM			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+2)
-#define PVRSRV_BRIDGE_PDUMP_REG				PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+3)
-#define PVRSRV_BRIDGE_PDUMP_REGPOL			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+4)
-#define PVRSRV_BRIDGE_PDUMP_COMMENT			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+5)
-#define PVRSRV_BRIDGE_PDUMP_SETFRAME			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+6)
-#define PVRSRV_BRIDGE_PDUMP_ISCAPTURING			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+7)
-#define PVRSRV_BRIDGE_PDUMP_DUMPBITMAP			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+8)
-#define PVRSRV_BRIDGE_PDUMP_DUMPREADREG			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+9)
-#define PVRSRV_BRIDGE_PDUMP_SYNCPOL			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+10)
-#define PVRSRV_BRIDGE_PDUMP_DUMPSYNC			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+11)
-#define PVRSRV_BRIDGE_PDUMP_MEMPAGES			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+12)
-#define PVRSRV_BRIDGE_PDUMP_DRIVERINFO			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+13)
-#define PVRSRV_BRIDGE_PDUMP_PDREG			PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+14)
-#define PVRSRV_BRIDGE_PDUMP_DUMPPDDEVPADDR		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+15)
-#define PVRSRV_BRIDGE_PDUMP_BUFFER_ARRAY		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+16)
-#define PVRSRV_BRIDGE_PDUMP_CYCLE_COUNT_REG_READ	PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+17)
-#define PVRSRV_BRIDGE_PDUMP_3D_SIGNATURE_REGISTERS	PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+18)
-#define PVRSRV_BRIDGE_PDUMP_COUNTER_REGISTERS	PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+19)
-#define PVRSRV_BRIDGE_PDUMP_TA_SIGNATURE_REGISTERS	PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+20)
-#define PVRSRV_BRIDGE_PDUMP_CMD_LAST			(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+20)
+#define PVRSRV_BRIDGE_PDUMP_CMD_FIRST				\
+		(PVRSRV_BRIDGE_OVERLAY_CMD_FIRST+1)
+#define PVRSRV_BRIDGE_PDUMP_INIT				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+0)
+#define PVRSRV_BRIDGE_PDUMP_MEMPOL				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+1)
+#define PVRSRV_BRIDGE_PDUMP_DUMPMEM				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+2)
+#define PVRSRV_BRIDGE_PDUMP_REG					\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+3)
+#define PVRSRV_BRIDGE_PDUMP_REGPOL				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+4)
+#define PVRSRV_BRIDGE_PDUMP_COMMENT				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+5)
+#define PVRSRV_BRIDGE_PDUMP_SETFRAME				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+6)
+#define PVRSRV_BRIDGE_PDUMP_ISCAPTURING				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+7)
+#define PVRSRV_BRIDGE_PDUMP_DUMPBITMAP				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+8)
+#define PVRSRV_BRIDGE_PDUMP_DUMPREADREG				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+9)
+#define PVRSRV_BRIDGE_PDUMP_SYNCPOL				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+10)
+#define PVRSRV_BRIDGE_PDUMP_DUMPSYNC				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+11)
+#define PVRSRV_BRIDGE_PDUMP_MEMPAGES				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+12)
+#define PVRSRV_BRIDGE_PDUMP_DRIVERINFO				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+13)
+#define PVRSRV_BRIDGE_PDUMP_PDREG				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+14)
+#define PVRSRV_BRIDGE_PDUMP_DUMPPDDEVPADDR			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+15)
+#define PVRSRV_BRIDGE_PDUMP_BUFFER_ARRAY			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+16)
+#define PVRSRV_BRIDGE_PDUMP_CYCLE_COUNT_REG_READ		\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+17)
+#define PVRSRV_BRIDGE_PDUMP_3D_SIGNATURE_REGISTERS		\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+18)
+#define PVRSRV_BRIDGE_PDUMP_COUNTER_REGISTERS			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+19)
+#define PVRSRV_BRIDGE_PDUMP_TA_SIGNATURE_REGISTERS		\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+20)
+#define PVRSRV_BRIDGE_PDUMP_CMD_LAST				\
+		(PVRSRV_BRIDGE_PDUMP_CMD_FIRST+20)
 #else
-#define PVRSRV_BRIDGE_PDUMP_CMD_LAST			PVRSRV_BRIDGE_OVERLAY_CMD_LAST
+#define PVRSRV_BRIDGE_PDUMP_CMD_LAST				\
+		PVRSRV_BRIDGE_OVERLAY_CMD_LAST
 #endif
 
-#define PVRSRV_BRIDGE_OEM_CMD_FIRST				(PVRSRV_BRIDGE_PDUMP_CMD_LAST+1)
-#define PVRSRV_BRIDGE_GET_OEMJTABLE				PVRSRV_IOWR(PVRSRV_BRIDGE_OEM_CMD_FIRST+0)
-#define PVRSRV_BRIDGE_OEM_CMD_LAST				(PVRSRV_BRIDGE_OEM_CMD_FIRST+0)
-
-#define PVRSRV_BRIDGE_DEVCLASS_CMD_FIRST		(PVRSRV_BRIDGE_OEM_CMD_LAST+1)
-#define PVRSRV_BRIDGE_ENUM_CLASS				PVRSRV_IOWR(PVRSRV_BRIDGE_DEVCLASS_CMD_FIRST+0)
-#define PVRSRV_BRIDGE_DEVCLASS_CMD_LAST			(PVRSRV_BRIDGE_DEVCLASS_CMD_FIRST+0)
-
-#define PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST		(PVRSRV_BRIDGE_DEVCLASS_CMD_LAST+1)
-#define PVRSRV_BRIDGE_OPEN_DISPCLASS_DEVICE		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+0)
-#define PVRSRV_BRIDGE_CLOSE_DISPCLASS_DEVICE	PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+1)
-#define PVRSRV_BRIDGE_ENUM_DISPCLASS_FORMATS	PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+2)
-#define PVRSRV_BRIDGE_ENUM_DISPCLASS_DIMS		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+3)
-#define PVRSRV_BRIDGE_GET_DISPCLASS_SYSBUFFER	PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+4)
-#define PVRSRV_BRIDGE_GET_DISPCLASS_INFO		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+5)
-#define PVRSRV_BRIDGE_CREATE_DISPCLASS_SWAPCHAIN		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+6)
-#define PVRSRV_BRIDGE_DESTROY_DISPCLASS_SWAPCHAIN		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+7)
-#define PVRSRV_BRIDGE_SET_DISPCLASS_DSTRECT		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+8)
-#define PVRSRV_BRIDGE_SET_DISPCLASS_SRCRECT		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+9)
-#define PVRSRV_BRIDGE_SET_DISPCLASS_DSTCOLOURKEY		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+10)
-#define PVRSRV_BRIDGE_SET_DISPCLASS_SRCCOLOURKEY		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+11)
-#define PVRSRV_BRIDGE_GET_DISPCLASS_BUFFERS		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+12)
-#define PVRSRV_BRIDGE_SWAP_DISPCLASS_TO_BUFFER	PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+13)
-#define PVRSRV_BRIDGE_SWAP_DISPCLASS_TO_SYSTEM	PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+14)
-#define PVRSRV_BRIDGE_DISPCLASS_CMD_LAST		(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+14)
-
-#define PVRSRV_BRIDGE_BUFCLASS_CMD_FIRST		(PVRSRV_BRIDGE_DISPCLASS_CMD_LAST+1)
-#define PVRSRV_BRIDGE_OPEN_BUFFERCLASS_DEVICE	PVRSRV_IOWR(PVRSRV_BRIDGE_BUFCLASS_CMD_FIRST+0)
-#define PVRSRV_BRIDGE_CLOSE_BUFFERCLASS_DEVICE	PVRSRV_IOWR(PVRSRV_BRIDGE_BUFCLASS_CMD_FIRST+1)
-#define PVRSRV_BRIDGE_GET_BUFFERCLASS_INFO		PVRSRV_IOWR(PVRSRV_BRIDGE_BUFCLASS_CMD_FIRST+2)
-#define PVRSRV_BRIDGE_GET_BUFFERCLASS_BUFFER	PVRSRV_IOWR(PVRSRV_BRIDGE_BUFCLASS_CMD_FIRST+3)
-#define PVRSRV_BRIDGE_BUFCLASS_CMD_LAST			(PVRSRV_BRIDGE_BUFCLASS_CMD_FIRST+3)
-
-#define PVRSRV_BRIDGE_WRAP_CMD_FIRST			(PVRSRV_BRIDGE_BUFCLASS_CMD_LAST+1)
-#define PVRSRV_BRIDGE_WRAP_EXT_MEMORY			PVRSRV_IOWR(PVRSRV_BRIDGE_WRAP_CMD_FIRST+0)
-#define PVRSRV_BRIDGE_UNWRAP_EXT_MEMORY			PVRSRV_IOWR(PVRSRV_BRIDGE_WRAP_CMD_FIRST+1)
-#define PVRSRV_BRIDGE_WRAP_CMD_LAST				(PVRSRV_BRIDGE_WRAP_CMD_FIRST+1)
-
-#define PVRSRV_BRIDGE_SHAREDMEM_CMD_FIRST		(PVRSRV_BRIDGE_WRAP_CMD_LAST+1)
-#define PVRSRV_BRIDGE_ALLOC_SHARED_SYS_MEM		PVRSRV_IOWR(PVRSRV_BRIDGE_SHAREDMEM_CMD_FIRST+0)
-#define PVRSRV_BRIDGE_FREE_SHARED_SYS_MEM		PVRSRV_IOWR(PVRSRV_BRIDGE_SHAREDMEM_CMD_FIRST+1)
-#define PVRSRV_BRIDGE_MAP_MEMINFO_MEM			PVRSRV_IOWR(PVRSRV_BRIDGE_SHAREDMEM_CMD_FIRST+2)
-#define PVRSRV_BRIDGE_UNMAP_MEMINFO_MEM			PVRSRV_IOWR(PVRSRV_BRIDGE_SHAREDMEM_CMD_FIRST+3)
-#define PVRSRV_BRIDGE_SHAREDMEM_CMD_LAST		(PVRSRV_BRIDGE_SHAREDMEM_CMD_FIRST+3)
-
-#define PVRSRV_BRIDGE_SERVICES4_TMP_CMD_FIRST	(PVRSRV_BRIDGE_SHAREDMEM_CMD_LAST+1)
-#define PVRSRV_BRIDGE_GETMMU_PD_DEVPADDR        PVRSRV_IOWR(PVRSRV_BRIDGE_SERVICES4_TMP_CMD_FIRST+0)
-#define PVRSRV_BRIDGE_SERVICES4_TMP_CMD_LAST	(PVRSRV_BRIDGE_SERVICES4_TMP_CMD_FIRST+0)
-
-#define PVRSRV_BRIDGE_INITSRV_CMD_FIRST			(PVRSRV_BRIDGE_SERVICES4_TMP_CMD_LAST+1)
-#define PVRSRV_BRIDGE_INITSRV_CONNECT			PVRSRV_IOWR(PVRSRV_BRIDGE_INITSRV_CMD_FIRST+0)
-#define PVRSRV_BRIDGE_INITSRV_DISCONNECT		PVRSRV_IOWR(PVRSRV_BRIDGE_INITSRV_CMD_FIRST+1)
-#define PVRSRV_BRIDGE_INITSRV_CMD_LAST			(PVRSRV_BRIDGE_INITSRV_CMD_FIRST+1)
-
-#define PVRSRV_BRIDGE_EVENT_OBJECT_CMD_FIRST	(PVRSRV_BRIDGE_INITSRV_CMD_LAST+1)
-#define PVRSRV_BRIDGE_EVENT_OBJECT_WAIT			PVRSRV_IOWR(PVRSRV_BRIDGE_EVENT_OBJECT_CMD_FIRST+0)
-#define PVRSRV_BRIDGE_EVENT_OBJECT_OPEN			PVRSRV_IOWR(PVRSRV_BRIDGE_EVENT_OBJECT_CMD_FIRST+1)
-#define PVRSRV_BRIDGE_EVENT_OBJECT_CLOSE		PVRSRV_IOWR(PVRSRV_BRIDGE_EVENT_OBJECT_CMD_FIRST+2)
-#define PVRSRV_BRIDGE_EVENT_OBJECT_CMD_LAST		(PVRSRV_BRIDGE_EVENT_OBJECT_CMD_FIRST+2)
+#define PVRSRV_BRIDGE_OEM_CMD_FIRST				\
+		(PVRSRV_BRIDGE_PDUMP_CMD_LAST+1)
+#define PVRSRV_BRIDGE_GET_OEMJTABLE				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_OEM_CMD_FIRST+0)
+#define PVRSRV_BRIDGE_OEM_CMD_LAST				\
+		(PVRSRV_BRIDGE_OEM_CMD_FIRST+0)
+
+#define PVRSRV_BRIDGE_DEVCLASS_CMD_FIRST			\
+		(PVRSRV_BRIDGE_OEM_CMD_LAST+1)
+#define PVRSRV_BRIDGE_ENUM_CLASS				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_DEVCLASS_CMD_FIRST+0)
+#define PVRSRV_BRIDGE_DEVCLASS_CMD_LAST				\
+		(PVRSRV_BRIDGE_DEVCLASS_CMD_FIRST+0)
+
+#define PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST			\
+		(PVRSRV_BRIDGE_DEVCLASS_CMD_LAST+1)
+#define PVRSRV_BRIDGE_OPEN_DISPCLASS_DEVICE			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+0)
+#define PVRSRV_BRIDGE_CLOSE_DISPCLASS_DEVICE			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+1)
+#define PVRSRV_BRIDGE_ENUM_DISPCLASS_FORMATS			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+2)
+#define PVRSRV_BRIDGE_ENUM_DISPCLASS_DIMS			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+3)
+#define PVRSRV_BRIDGE_GET_DISPCLASS_SYSBUFFER			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+4)
+#define PVRSRV_BRIDGE_GET_DISPCLASS_INFO			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+5)
+#define PVRSRV_BRIDGE_CREATE_DISPCLASS_SWAPCHAIN		\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+6)
+#define PVRSRV_BRIDGE_DESTROY_DISPCLASS_SWAPCHAIN		\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+7)
+#define PVRSRV_BRIDGE_SET_DISPCLASS_DSTRECT			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+8)
+#define PVRSRV_BRIDGE_SET_DISPCLASS_SRCRECT			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+9)
+#define PVRSRV_BRIDGE_SET_DISPCLASS_DSTCOLOURKEY		\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+10)
+#define PVRSRV_BRIDGE_SET_DISPCLASS_SRCCOLOURKEY		\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+11)
+#define PVRSRV_BRIDGE_GET_DISPCLASS_BUFFERS			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+12)
+#define PVRSRV_BRIDGE_SWAP_DISPCLASS_TO_BUFFER			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+13)
+#define PVRSRV_BRIDGE_SWAP_DISPCLASS_TO_SYSTEM			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+14)
+#define PVRSRV_BRIDGE_DISPCLASS_CMD_LAST			\
+		(PVRSRV_BRIDGE_DISPCLASS_CMD_FIRST+14)
+
+#define PVRSRV_BRIDGE_BUFCLASS_CMD_FIRST			\
+		(PVRSRV_BRIDGE_DISPCLASS_CMD_LAST+1)
+#define PVRSRV_BRIDGE_OPEN_BUFFERCLASS_DEVICE			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_BUFCLASS_CMD_FIRST+0)
+#define PVRSRV_BRIDGE_CLOSE_BUFFERCLASS_DEVICE			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_BUFCLASS_CMD_FIRST+1)
+#define PVRSRV_BRIDGE_GET_BUFFERCLASS_INFO			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_BUFCLASS_CMD_FIRST+2)
+#define PVRSRV_BRIDGE_GET_BUFFERCLASS_BUFFER			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_BUFCLASS_CMD_FIRST+3)
+#define PVRSRV_BRIDGE_BUFCLASS_CMD_LAST				\
+		(PVRSRV_BRIDGE_BUFCLASS_CMD_FIRST+3)
+
+#define PVRSRV_BRIDGE_WRAP_CMD_FIRST				\
+		(PVRSRV_BRIDGE_BUFCLASS_CMD_LAST+1)
+#define PVRSRV_BRIDGE_WRAP_EXT_MEMORY				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_WRAP_CMD_FIRST+0)
+#define PVRSRV_BRIDGE_UNWRAP_EXT_MEMORY				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_WRAP_CMD_FIRST+1)
+#define PVRSRV_BRIDGE_WRAP_CMD_LAST				\
+		(PVRSRV_BRIDGE_WRAP_CMD_FIRST+1)
+
+#define PVRSRV_BRIDGE_SHAREDMEM_CMD_FIRST			\
+		(PVRSRV_BRIDGE_WRAP_CMD_LAST+1)
+#define PVRSRV_BRIDGE_ALLOC_SHARED_SYS_MEM			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_SHAREDMEM_CMD_FIRST+0)
+#define PVRSRV_BRIDGE_FREE_SHARED_SYS_MEM			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_SHAREDMEM_CMD_FIRST+1)
+#define PVRSRV_BRIDGE_MAP_MEMINFO_MEM				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_SHAREDMEM_CMD_FIRST+2)
+#define PVRSRV_BRIDGE_UNMAP_MEMINFO_MEM				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_SHAREDMEM_CMD_FIRST+3)
+#define PVRSRV_BRIDGE_SHAREDMEM_CMD_LAST			\
+		(PVRSRV_BRIDGE_SHAREDMEM_CMD_FIRST+3)
+
+#define PVRSRV_BRIDGE_SERVICES4_TMP_CMD_FIRST			\
+		(PVRSRV_BRIDGE_SHAREDMEM_CMD_LAST+1)
+#define PVRSRV_BRIDGE_GETMMU_PD_DEVPADDR			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_SERVICES4_TMP_CMD_FIRST+0)
+#define PVRSRV_BRIDGE_SERVICES4_TMP_CMD_LAST			\
+		(PVRSRV_BRIDGE_SERVICES4_TMP_CMD_FIRST+0)
+
+#define PVRSRV_BRIDGE_INITSRV_CMD_FIRST				\
+		(PVRSRV_BRIDGE_SERVICES4_TMP_CMD_LAST+1)
+#define PVRSRV_BRIDGE_INITSRV_CONNECT				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_INITSRV_CMD_FIRST+0)
+#define PVRSRV_BRIDGE_INITSRV_DISCONNECT			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_INITSRV_CMD_FIRST+1)
+#define PVRSRV_BRIDGE_INITSRV_CMD_LAST				\
+		(PVRSRV_BRIDGE_INITSRV_CMD_FIRST+1)
+
+#define PVRSRV_BRIDGE_EVENT_OBJECT_CMD_FIRST			\
+		(PVRSRV_BRIDGE_INITSRV_CMD_LAST+1)
+#define PVRSRV_BRIDGE_EVENT_OBJECT_WAIT				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_EVENT_OBJECT_CMD_FIRST+0)
+#define PVRSRV_BRIDGE_EVENT_OBJECT_OPEN				\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_EVENT_OBJECT_CMD_FIRST+1)
+#define PVRSRV_BRIDGE_EVENT_OBJECT_CLOSE			\
+		PVRSRV_IOWR(PVRSRV_BRIDGE_EVENT_OBJECT_CMD_FIRST+2)
+#define PVRSRV_BRIDGE_EVENT_OBJECT_CMD_LAST			\
+		(PVRSRV_BRIDGE_EVENT_OBJECT_CMD_FIRST+2)
 
-#define PVRSRV_BRIDGE_LAST_NON_DEVICE_CMD		(PVRSRV_BRIDGE_EVENT_OBJECT_CMD_LAST+1)
+#define PVRSRV_BRIDGE_LAST_NON_DEVICE_CMD			\
+		(PVRSRV_BRIDGE_EVENT_OBJECT_CMD_LAST+1)
 
 #define PVRSRV_KERNEL_MODE_CLIENT				1
 
-	typedef struct PVRSRV_BRIDGE_RETURN_TAG {
-		PVRSRV_ERROR eError;
-		IMG_VOID *pvData;
-
-	} PVRSRV_BRIDGE_RETURN;
-
-	typedef struct PVRSRV_BRIDGE_PACKAGE_TAG {
-		IMG_UINT32 ui32BridgeID;
-		IMG_UINT32 ui32Size;
-		IMG_VOID *pvParamIn;
-		IMG_UINT32 ui32InBufferSize;
-		IMG_VOID *pvParamOut;
-		IMG_UINT32 ui32OutBufferSize;
-
-		IMG_HANDLE hKernelServices;
-	} PVRSRV_BRIDGE_PACKAGE;
-
-	typedef struct PVRSRV_BRIDGE_IN_ACQUIRE_DEVICEINFO_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_UINT32 uiDevIndex;
-		PVRSRV_DEVICE_TYPE eDeviceType;
-
-	} PVRSRV_BRIDGE_IN_ACQUIRE_DEVICEINFO;
-
-	typedef struct PVRSRV_BRIDGE_IN_ENUMCLASS_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_DEVICE_CLASS sDeviceClass;
-	} PVRSRV_BRIDGE_IN_ENUMCLASS;
-
-	typedef struct PVRSRV_BRIDGE_IN_CLOSE_DISPCLASS_DEVICE_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDeviceKM;
-	} PVRSRV_BRIDGE_IN_CLOSE_DISPCLASS_DEVICE;
-
-	typedef struct PVRSRV_BRIDGE_IN_ENUM_DISPCLASS_FORMATS_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDeviceKM;
-	} PVRSRV_BRIDGE_IN_ENUM_DISPCLASS_FORMATS;
-
-	typedef struct PVRSRV_BRIDGE_IN_GET_DISPCLASS_SYSBUFFER_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDeviceKM;
-	} PVRSRV_BRIDGE_IN_GET_DISPCLASS_SYSBUFFER;
-
-	typedef struct PVRSRV_BRIDGE_IN_GET_DISPCLASS_INFO_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDeviceKM;
-	} PVRSRV_BRIDGE_IN_GET_DISPCLASS_INFO;
-
-	typedef struct PVRSRV_BRIDGE_IN_CLOSE_BUFFERCLASS_DEVICE_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDeviceKM;
-	} PVRSRV_BRIDGE_IN_CLOSE_BUFFERCLASS_DEVICE;
-
-	typedef struct PVRSRV_BRIDGE_IN_GET_BUFFERCLASS_INFO_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDeviceKM;
-	} PVRSRV_BRIDGE_IN_GET_BUFFERCLASS_INFO;
-
-	typedef struct PVRSRV_BRIDGE_IN_RELEASE_DEVICEINFO_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-
-	} PVRSRV_BRIDGE_IN_RELEASE_DEVICEINFO;
-
-	typedef struct PVRSRV_BRIDGE_IN_FREE_CLASSDEVICEINFO_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_DEVICE_CLASS DeviceClass;
-		IMG_VOID *pvDevInfo;
-
-	} PVRSRV_BRIDGE_IN_FREE_CLASSDEVICEINFO;
-
-	typedef struct PVRSRV_BRIDGE_IN_GET_DEVMEM_HEAPINFO_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_HANDLE hDevMemContext;
-
-	} PVRSRV_BRIDGE_IN_GET_DEVMEM_HEAPINFO;
-
-	typedef struct PVRSRV_BRIDGE_IN_CREATE_DEVMEMCONTEXT_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-
-	} PVRSRV_BRIDGE_IN_CREATE_DEVMEMCONTEXT;
-
-	typedef struct PVRSRV_BRIDGE_IN_DESTROY_DEVMEMCONTEXT_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_HANDLE hDevMemContext;
-
-	} PVRSRV_BRIDGE_IN_DESTROY_DEVMEMCONTEXT;
-
-	typedef struct PVRSRV_BRIDGE_IN_ALLOCDEVICEMEM_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_HANDLE hDevMemHeap;
-		IMG_UINT32 ui32Attribs;
-		IMG_UINT32 ui32Size;
-		IMG_UINT32 ui32Alignment;
-
-	} PVRSRV_BRIDGE_IN_ALLOCDEVICEMEM;
-
-	typedef struct PVRSRV_BRIDGE_IN_MAPMEMINFOTOUSER_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
-
-	} PVRSRV_BRIDGE_IN_MAPMEMINFOTOUSER;
-
-	typedef struct PVRSRV_BRIDGE_IN_UNMAPMEMINFOFROMUSER_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
-		IMG_PVOID pvLinAddr;
-		IMG_HANDLE hMappingInfo;
-
-	} PVRSRV_BRIDGE_IN_UNMAPMEMINFOFROMUSER;
+struct PVRSRV_BRIDGE_RETURN {
+	enum PVRSRV_ERROR eError;
+	void *pvData;
+};
+
+struct PVRSRV_BRIDGE_PACKAGE {
+	u32 ui32BridgeID;
+	u32 ui32Size;
+	void __user *pvParamIn;
+	u32 ui32InBufferSize;
+	void __user *pvParamOut;
+	u32 ui32OutBufferSize;
+
+	void *hKernelServices;
+};
+
+struct PVRSRV_BRIDGE_IN_ACQUIRE_DEVICEINFO {
+	u32 ui32BridgeFlags;
+	u32 uiDevIndex;
+	enum PVRSRV_DEVICE_TYPE eDeviceType;
+};
+
+struct PVRSRV_BRIDGE_IN_ENUMCLASS {
+	u32 ui32BridgeFlags;
+	enum PVRSRV_DEVICE_CLASS sDeviceClass;
+};
+
+struct PVRSRV_BRIDGE_IN_CLOSE_DISPCLASS_DEVICE {
+	u32 ui32BridgeFlags;
+	void *hDeviceKM;
+};
+
+struct PVRSRV_BRIDGE_IN_ENUM_DISPCLASS_FORMATS {
+	u32 ui32BridgeFlags;
+	void *hDeviceKM;
+};
+
+struct PVRSRV_BRIDGE_IN_GET_DISPCLASS_SYSBUFFER {
+	u32 ui32BridgeFlags;
+	void *hDeviceKM;
+};
+
+struct PVRSRV_BRIDGE_IN_GET_DISPCLASS_INFO {
+	u32 ui32BridgeFlags;
+	void *hDeviceKM;
+};
+
+struct PVRSRV_BRIDGE_IN_CLOSE_BUFFERCLASS_DEVICE {
+	u32 ui32BridgeFlags;
+	void *hDeviceKM;
+};
+
+struct PVRSRV_BRIDGE_IN_GET_BUFFERCLASS_INFO {
+	u32 ui32BridgeFlags;
+	void *hDeviceKM;
+};
+
+struct PVRSRV_BRIDGE_IN_RELEASE_DEVICEINFO {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+};
+
+struct PVRSRV_BRIDGE_IN_FREE_CLASSDEVICEINFO {
+	u32 ui32BridgeFlags;
+	enum PVRSRV_DEVICE_CLASS DeviceClass;
+	void *pvDevInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_GET_DEVMEM_HEAPINFO {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	void *hDevMemContext;
+};
+
+struct PVRSRV_BRIDGE_IN_CREATE_DEVMEMCONTEXT {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+};
+
+struct PVRSRV_BRIDGE_IN_DESTROY_DEVMEMCONTEXT {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	void *hDevMemContext;
+};
+
+struct PVRSRV_BRIDGE_IN_ALLOCDEVICEMEM {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	void *hDevMemHeap;
+	u32 ui32Attribs;
+	u32 ui32Size;
+	u32 ui32Alignment;
+};
+
+struct PVRSRV_BRIDGE_IN_MAPMEMINFOTOUSER {
+	u32 ui32BridgeFlags;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_UNMAPMEMINFOFROMUSER {
+	u32 ui32BridgeFlags;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	void *pvLinAddr;
+	void *hMappingInfo;
+};
 
 #define DRM_PVR2D_CFLUSH_FROM_GPU	1
 #define DRM_PVR2D_CFLUSH_TO_GPU		2
 
-	typedef struct PVRSRV_BRIDGE_IN_CACHEFLUSHDRMFROMUSER_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_UINT32 ui32Type;
-		IMG_VOID *pvVirt;
-		IMG_UINT32 ui32Length;
-
-	} PVRSRV_BRIDGE_IN_CACHEFLUSHDRMFROMUSER;
-
-	typedef struct PVRSRV_BRIDGE_IN_FREEDEVICEMEM_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
-		PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
-
-	} PVRSRV_BRIDGE_IN_FREEDEVICEMEM;
-
-	typedef struct PVRSRV_BRIDGE_IN_GETFREEDEVICEMEM_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_UINT32 ui32Flags;
-
-	} PVRSRV_BRIDGE_IN_GETFREEDEVICEMEM;
-
-	typedef struct PVRSRV_BRIDGE_IN_CREATECOMMANDQUEUE_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_UINT32 ui32QueueSize;
-
-	} PVRSRV_BRIDGE_IN_CREATECOMMANDQUEUE;
-
-	typedef struct PVRSRV_BRIDGE_IN_DESTROYCOMMANDQUEUE_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		PVRSRV_QUEUE_INFO *psQueueInfo;
-
-	} PVRSRV_BRIDGE_IN_DESTROYCOMMANDQUEUE;
-
-	typedef struct PVRSRV_BRIDGE_IN_KV_TO_MMAP_DATA_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_VOID *pvKVIndexAddress;
-		IMG_UINT32 ui32Bytes;
-	} PVRSRV_BRIDGE_IN_KV_TO_MMAP_DATA;
-
-	typedef struct PVRSRV_BRIDGE_IN_RESERVE_DEV_VIRTMEM_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevMemHeap;
-		IMG_DEV_VIRTADDR *psDevVAddr;
-		IMG_UINT32 ui32Size;
-		IMG_UINT32 ui32Alignment;
-
-	} PVRSRV_BRIDGE_IN_RESERVE_DEV_VIRTMEM;
-
-	typedef struct PVRSRV_BRIDGE_OUT_CONNECT_SERVICES_TAG {
-		PVRSRV_ERROR eError;
-		IMG_HANDLE hKernelServices;
-	} PVRSRV_BRIDGE_OUT_CONNECT_SERVICES;
-
-	typedef struct PVRSRV_BRIDGE_OUT_RESERVE_DEV_VIRTMEM_TAG {
-		PVRSRV_ERROR eError;
-		PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
-		PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
-		PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
-		PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
-
-	} PVRSRV_BRIDGE_OUT_RESERVE_DEV_VIRTMEM;
-
-	typedef struct PVRSRV_BRIDGE_IN_FREE_DEV_VIRTMEM_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
-		PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
-		PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
-
-	} PVRSRV_BRIDGE_IN_FREE_DEV_VIRTMEM;
-
-	typedef struct PVRSRV_BRIDGE_IN_MAP_DEV_MEMORY_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_KERNEL_MEM_INFO *psSrcKernelMemInfo;
-		IMG_HANDLE hDstDevMemHeap;
-
-	} PVRSRV_BRIDGE_IN_MAP_DEV_MEMORY;
-
-	typedef struct PVRSRV_BRIDGE_OUT_MAP_DEV_MEMORY_TAG {
-		PVRSRV_ERROR eError;
-		PVRSRV_KERNEL_MEM_INFO *psDstKernelMemInfo;
-		PVRSRV_KERNEL_SYNC_INFO *psDstKernelSyncInfo;
-		PVRSRV_CLIENT_MEM_INFO sDstClientMemInfo;
-		PVRSRV_CLIENT_SYNC_INFO sDstClientSyncInfo;
-
-	} PVRSRV_BRIDGE_OUT_MAP_DEV_MEMORY;
-
-	typedef struct PVRSRV_BRIDGE_IN_UNMAP_DEV_MEMORY_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
-		PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
-		PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
-
-	} PVRSRV_BRIDGE_IN_UNMAP_DEV_MEMORY;
-
-	typedef struct PVRSRV_BRIDGE_IN_MAP_EXT_MEMORY_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
-		IMG_SYS_PHYADDR *psSysPAddr;
-		IMG_UINT32 ui32Flags;
-
-	} PVRSRV_BRIDGE_IN_MAP_EXT_MEMORY;
-
-	typedef struct PVRSRV_BRIDGE_IN_UNMAP_EXT_MEMORY_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
-		PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
-		IMG_UINT32 ui32Flags;
-
-	} PVRSRV_BRIDGE_IN_UNMAP_EXT_MEMORY;
-
-	typedef struct PVRSRV_BRIDGE_IN_MAP_DEVICECLASS_MEMORY_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDeviceClassBuffer;
-
-	} PVRSRV_BRIDGE_IN_MAP_DEVICECLASS_MEMORY;
-
-	typedef struct PVRSRV_BRIDGE_OUT_MAP_DEVICECLASS_MEMORY_TAG {
-		PVRSRV_ERROR eError;
-		PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
-		PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
-		PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
-		PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
-		IMG_HANDLE hMappingInfo;
-
-	} PVRSRV_BRIDGE_OUT_MAP_DEVICECLASS_MEMORY;
-
-	typedef struct PVRSRV_BRIDGE_IN_UNMAP_DEVICECLASS_MEMORY_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
-		PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
-		PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
-
-	} PVRSRV_BRIDGE_IN_UNMAP_DEVICECLASS_MEMORY;
-
-	typedef struct PVRSRV_BRIDGE_IN_PDUMP_MEMPOL_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
-		IMG_UINT32 ui32Offset;
-		IMG_UINT32 ui32Value;
-		IMG_UINT32 ui32Mask;
-		IMG_BOOL bLastFrame;
-		IMG_BOOL bOverwrite;
-
-	} PVRSRV_BRIDGE_IN_PDUMP_MEMPOL;
-
-	typedef struct PVRSRV_BRIDGE_IN_PDUMP_SYNCPOL_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
-		IMG_BOOL bIsRead;
-		IMG_UINT32 ui32Value;
-		IMG_UINT32 ui32Mask;
-
-	} PVRSRV_BRIDGE_IN_PDUMP_SYNCPOL;
-
-	typedef struct PVRSRV_BRIDGE_IN_PDUMP_DUMPMEM_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_PVOID pvAltLinAddr;
-		PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
-		IMG_UINT32 ui32Offset;
-		IMG_UINT32 ui32Bytes;
-		IMG_UINT32 ui32Flags;
-
-	} PVRSRV_BRIDGE_IN_PDUMP_DUMPMEM;
-
-	typedef struct PVRSRV_BRIDGE_IN_PDUMP_DUMPSYNC_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_PVOID pvAltLinAddr;
-		PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
-		IMG_UINT32 ui32Offset;
-		IMG_UINT32 ui32Bytes;
-
-	} PVRSRV_BRIDGE_IN_PDUMP_DUMPSYNC;
-
-	typedef struct PVRSRV_BRIDGE_IN_PDUMP_DUMPREG_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_HWREG sHWReg;
-		IMG_UINT32 ui32Flags;
-
-	} PVRSRV_BRIDGE_IN_PDUMP_DUMPREG;
-
-	typedef struct PVRSRV_BRIDGE_IN_PDUMP_REGPOL_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_HWREG sHWReg;
-		IMG_UINT32 ui32Mask;
-		IMG_UINT32 ui32Flags;
-	} PVRSRV_BRIDGE_IN_PDUMP_REGPOL;
-
-	typedef struct PVRSRV_BRIDGE_IN_PDUMP_DUMPPDREG_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_HWREG sHWReg;
-		IMG_UINT32 ui32Flags;
-
-	} PVRSRV_BRIDGE_IN_PDUMP_DUMPPDREG;
-
-	typedef struct PVRSRV_BRIDGE_IN_PDUMP_MEMPAGES_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hKernelMemInfo;
-		IMG_DEV_PHYADDR *pPages;
-		IMG_UINT32 ui32NumPages;
-		IMG_DEV_VIRTADDR sDevAddr;
-		IMG_UINT32 ui32Start;
-		IMG_UINT32 ui32Length;
-		IMG_BOOL bContinuous;
-
-	} PVRSRV_BRIDGE_IN_PDUMP_MEMPAGES;
-
-	typedef struct PVRSRV_BRIDGE_IN_PDUMP_COMMENT_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_CHAR szComment[PVRSRV_PDUMP_MAX_COMMENT_SIZE];
-		IMG_UINT32 ui32Flags;
-
-	} PVRSRV_BRIDGE_IN_PDUMP_COMMENT;
-
-	typedef struct PVRSRV_BRIDGE_IN_PDUMP_SETFRAME_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_UINT32 ui32Frame;
-
-	} PVRSRV_BRIDGE_IN_PDUMP_SETFRAME;
-
-	typedef struct PVRSRV_BRIDGE_IN_PDUMP_BITMAP_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_CHAR szFileName[PVRSRV_PDUMP_MAX_FILENAME_SIZE];
-		IMG_UINT32 ui32FileOffset;
-		IMG_UINT32 ui32Width;
-		IMG_UINT32 ui32Height;
-		IMG_UINT32 ui32StrideInBytes;
-		IMG_DEV_VIRTADDR sDevBaseAddr;
-		IMG_UINT32 ui32Size;
-		PDUMP_PIXEL_FORMAT ePixelFormat;
-		PDUMP_MEM_FORMAT eMemFormat;
-		IMG_UINT32 ui32Flags;
-
-	} PVRSRV_BRIDGE_IN_PDUMP_BITMAP;
-
-	typedef struct PVRSRV_BRIDGE_IN_PDUMP_READREG_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_CHAR szFileName[PVRSRV_PDUMP_MAX_FILENAME_SIZE];
-		IMG_UINT32 ui32FileOffset;
-		IMG_UINT32 ui32Address;
-		IMG_UINT32 ui32Size;
-		IMG_UINT32 ui32Flags;
-
-	} PVRSRV_BRIDGE_IN_PDUMP_READREG;
-
-	typedef struct PVRSRV_BRIDGE_IN_PDUMP_DRIVERINFO_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_CHAR szString[PVRSRV_PDUMP_MAX_COMMENT_SIZE];
-		IMG_BOOL bContinuous;
-
-	} PVRSRV_BRIDGE_IN_PDUMP_DRIVERINFO;
-
-	typedef struct PVRSRV_BRIDGE_IN_PDUMP_DUMPPDDEVPADDR_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hKernelMemInfo;
-		IMG_UINT32 ui32Offset;
-		IMG_DEV_PHYADDR sPDDevPAddr;
-	} PVRSRV_BRIDGE_IN_PDUMP_DUMPPDDEVPADDR;
-
-	typedef struct PVRSRV_BRIDGE_PDUM_IN_CYCLE_COUNT_REG_READ_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_UINT32 ui32RegOffset;
-		IMG_BOOL bLastFrame;
-	} PVRSRV_BRIDGE_IN_PDUMP_CYCLE_COUNT_REG_READ;
-
-	typedef struct PVRSRV_BRIDGE_OUT_ENUMDEVICE_TAG {
-		PVRSRV_ERROR eError;
-		IMG_UINT32 ui32NumDevices;
-		PVRSRV_DEVICE_IDENTIFIER asDeviceIdentifier[PVRSRV_MAX_DEVICES];
-
-	} PVRSRV_BRIDGE_OUT_ENUMDEVICE;
-
-	typedef struct PVRSRV_BRIDGE_OUT_ACQUIRE_DEVICEINFO_TAG {
-
-		PVRSRV_ERROR eError;
-		IMG_HANDLE hDevCookie;
-
-	} PVRSRV_BRIDGE_OUT_ACQUIRE_DEVICEINFO;
-
-	typedef struct PVRSRV_BRIDGE_OUT_ENUMCLASS_TAG {
-		PVRSRV_ERROR eError;
-		IMG_UINT32 ui32NumDevices;
-		IMG_UINT32 ui32DevID[PVRSRV_MAX_DEVICES];
-
-	} PVRSRV_BRIDGE_OUT_ENUMCLASS;
-
-	typedef struct PVRSRV_BRIDGE_IN_OPEN_DISPCLASS_DEVICE_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_UINT32 ui32DeviceID;
-		IMG_HANDLE hDevCookie;
-
-	} PVRSRV_BRIDGE_IN_OPEN_DISPCLASS_DEVICE;
-
-	typedef struct PVRSRV_BRIDGE_OUT_OPEN_DISPCLASS_DEVICE_TAG {
-		PVRSRV_ERROR eError;
-		IMG_HANDLE hDeviceKM;
-
-	} PVRSRV_BRIDGE_OUT_OPEN_DISPCLASS_DEVICE;
-
-	typedef struct PVRSRV_BRIDGE_IN_WRAP_EXT_MEMORY_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_VOID *pvLinAddr;
-		IMG_UINT32 ui32ByteSize;
-		IMG_UINT32 ui32PageOffset;
-		IMG_BOOL bPhysContig;
-		IMG_UINT32 ui32NumPageTableEntries;
-		IMG_SYS_PHYADDR *psSysPAddr;
-
-	} PVRSRV_BRIDGE_IN_WRAP_EXT_MEMORY;
-
-	typedef struct PVRSRV_BRIDGE_OUT_WRAP_EXT_MEMORY_TAG {
-		PVRSRV_ERROR eError;
-		PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
-		PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
-
-	} PVRSRV_BRIDGE_OUT_WRAP_EXT_MEMORY;
-
-	typedef struct PVRSRV_BRIDGE_IN_UNWRAP_EXT_MEMORY_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hKernelMemInfo;
-		PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
-
-	} PVRSRV_BRIDGE_IN_UNWRAP_EXT_MEMORY;
+struct PVRSRV_BRIDGE_IN_CACHEFLUSHDRMFROMUSER {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	u32 ui32Type;
+	void *pvVirt;
+	u32 ui32Length;
+};
+
+struct PVRSRV_BRIDGE_IN_FREEDEVICEMEM {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	struct PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_GETFREEDEVICEMEM {
+	u32 ui32BridgeFlags;
+	u32 ui32Flags;
+};
+
+struct PVRSRV_BRIDGE_IN_CREATECOMMANDQUEUE {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	u32 ui32QueueSize;
+};
+
+struct PVRSRV_BRIDGE_IN_DESTROYCOMMANDQUEUE {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	struct PVRSRV_QUEUE_INFO *psQueueInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_KV_TO_MMAP_DATA {
+	u32 ui32BridgeFlags;
+	void *pvKVIndexAddress;
+	u32 ui32Bytes;
+};
+
+struct PVRSRV_BRIDGE_IN_RESERVE_DEV_VIRTMEM {
+	u32 ui32BridgeFlags;
+	void *hDevMemHeap;
+	struct IMG_DEV_VIRTADDR *psDevVAddr;
+	u32 ui32Size;
+	u32 ui32Alignment;
+};
+
+struct PVRSRV_BRIDGE_OUT_CONNECT_SERVICES {
+	enum PVRSRV_ERROR eError;
+	void *hKernelServices;
+};
+
+struct PVRSRV_BRIDGE_OUT_RESERVE_DEV_VIRTMEM {
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	struct PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
+	struct PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
+	struct PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_FREE_DEV_VIRTMEM {
+	u32 ui32BridgeFlags;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	struct PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
+	struct PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_MAP_DEV_MEMORY {
+	u32 ui32BridgeFlags;
+	struct PVRSRV_KERNEL_MEM_INFO *psSrcKernelMemInfo;
+	void *hDstDevMemHeap;
+};
+
+struct PVRSRV_BRIDGE_OUT_MAP_DEV_MEMORY {
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_KERNEL_MEM_INFO *psDstKernelMemInfo;
+	struct PVRSRV_KERNEL_SYNC_INFO *psDstKernelSyncInfo;
+	struct PVRSRV_CLIENT_MEM_INFO sDstClientMemInfo;
+	struct PVRSRV_CLIENT_SYNC_INFO sDstClientSyncInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_UNMAP_DEV_MEMORY {
+	u32 ui32BridgeFlags;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	struct PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
+	struct PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_MAP_EXT_MEMORY {
+	u32 ui32BridgeFlags;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	struct IMG_SYS_PHYADDR *psSysPAddr;
+	u32 ui32Flags;
+};
+
+struct PVRSRV_BRIDGE_IN_UNMAP_EXT_MEMORY {
+	u32 ui32BridgeFlags;
+	struct PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
+	struct PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
+	u32 ui32Flags;
+};
+
+struct PVRSRV_BRIDGE_IN_MAP_DEVICECLASS_MEMORY {
+	u32 ui32BridgeFlags;
+	void *hDeviceClassBuffer;
+};
+
+struct PVRSRV_BRIDGE_OUT_MAP_DEVICECLASS_MEMORY {
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
+	struct PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	struct PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
+	void *hMappingInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_UNMAP_DEVICECLASS_MEMORY {
+	u32 ui32BridgeFlags;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	struct PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
+	struct PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_MEMPOL {
+	u32 ui32BridgeFlags;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	u32 ui32Offset;
+	u32 ui32Value;
+	u32 ui32Mask;
+	IMG_BOOL bLastFrame;
+	IMG_BOOL bOverwrite;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_SYNCPOL {
+	u32 ui32BridgeFlags;
+	struct PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
+	IMG_BOOL bIsRead;
+	u32 ui32Value;
+	u32 ui32Mask;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_DUMPMEM {
+	u32 ui32BridgeFlags;
+	void *pvAltLinAddr;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	u32 ui32Offset;
+	u32 ui32Bytes;
+	u32 ui32Flags;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_DUMPSYNC {
+	u32 ui32BridgeFlags;
+	void *pvAltLinAddr;
+	struct PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
+	u32 ui32Offset;
+	u32 ui32Bytes;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_DUMPREG {
+	u32 ui32BridgeFlags;
+	struct PVRSRV_HWREG sHWReg;
+	u32 ui32Flags;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_REGPOL {
+	u32 ui32BridgeFlags;
+	struct PVRSRV_HWREG sHWReg;
+	u32 ui32Mask;
+	u32 ui32Flags;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_DUMPPDREG {
+	u32 ui32BridgeFlags;
+	struct PVRSRV_HWREG sHWReg;
+	u32 ui32Flags;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_MEMPAGES {
+	u32 ui32BridgeFlags;
+	void *hKernelMemInfo;
+	struct IMG_DEV_PHYADDR *pPages;
+	u32 ui32NumPages;
+	struct IMG_DEV_VIRTADDR sDevAddr;
+	u32 ui32Start;
+	u32 ui32Length;
+	IMG_BOOL bContinuous;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_COMMENT {
+	u32 ui32BridgeFlags;
+	char szComment[PVRSRV_PDUMP_MAX_COMMENT_SIZE];
+	u32 ui32Flags;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_SETFRAME {
+	u32 ui32BridgeFlags;
+	u32 ui32Frame;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_BITMAP {
+	u32 ui32BridgeFlags;
+	char szFileName[PVRSRV_PDUMP_MAX_FILENAME_SIZE];
+	u32 ui32FileOffset;
+	u32 ui32Width;
+	u32 ui32Height;
+	u32 ui32StrideInBytes;
+	struct IMG_DEV_VIRTADDR sDevBaseAddr;
+	u32 ui32Size;
+	enum PDUMP_PIXEL_FORMAT ePixelFormat;
+	enum PDUMP_MEM_FORMAT eMemFormat;
+	u32 ui32Flags;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_READREG {
+	u32 ui32BridgeFlags;
+	char szFileName[PVRSRV_PDUMP_MAX_FILENAME_SIZE];
+	u32 ui32FileOffset;
+	u32 ui32Address;
+	u32 ui32Size;
+	u32 ui32Flags;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_DRIVERINFO {
+	u32 ui32BridgeFlags;
+	char szString[PVRSRV_PDUMP_MAX_COMMENT_SIZE];
+	IMG_BOOL bContinuous;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_DUMPPDDEVPADDR {
+	u32 ui32BridgeFlags;
+	void *hKernelMemInfo;
+	u32 ui32Offset;
+	struct IMG_DEV_PHYADDR sPDDevPAddr;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_CYCLE_COUNT_REG_READ {
+	u32 ui32BridgeFlags;
+	u32 ui32RegOffset;
+	IMG_BOOL bLastFrame;
+};
+
+struct PVRSRV_BRIDGE_OUT_ENUMDEVICE {
+	enum PVRSRV_ERROR eError;
+	u32 ui32NumDevices;
+	struct PVRSRV_DEVICE_IDENTIFIER asDeviceIdentifier[PVRSRV_MAX_DEVICES];
+};
+
+struct PVRSRV_BRIDGE_OUT_ACQUIRE_DEVICEINFO {
+
+	enum PVRSRV_ERROR eError;
+	void *hDevCookie;
+};
+
+struct PVRSRV_BRIDGE_OUT_ENUMCLASS {
+	enum PVRSRV_ERROR eError;
+	u32 ui32NumDevices;
+	u32 ui32DevID[PVRSRV_MAX_DEVICES];
+};
+
+struct PVRSRV_BRIDGE_IN_OPEN_DISPCLASS_DEVICE {
+	u32 ui32BridgeFlags;
+	u32 ui32DeviceID;
+	void *hDevCookie;
+};
+
+struct PVRSRV_BRIDGE_OUT_OPEN_DISPCLASS_DEVICE {
+	enum PVRSRV_ERROR eError;
+	void *hDeviceKM;
+};
+
+struct PVRSRV_BRIDGE_IN_WRAP_EXT_MEMORY {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	void *pvLinAddr;
+	u32 ui32ByteSize;
+	u32 ui32PageOffset;
+	IMG_BOOL bPhysContig;
+	u32 ui32NumPageTableEntries;
+	struct IMG_SYS_PHYADDR __user *psSysPAddr;
+};
+
+struct PVRSRV_BRIDGE_OUT_WRAP_EXT_MEMORY {
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
+	struct PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_UNWRAP_EXT_MEMORY {
+	u32 ui32BridgeFlags;
+	void *hKernelMemInfo;
+	struct PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
+};
 
 #define PVRSRV_MAX_DC_DISPLAY_FORMATS			10
 #define PVRSRV_MAX_DC_DISPLAY_DIMENSIONS		10
 #define PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS			4
 #define PVRSRV_MAX_DC_CLIP_RECTS				32
 
-	typedef struct PVRSRV_BRIDGE_OUT_ENUM_DISPCLASS_FORMATS_TAG {
-		PVRSRV_ERROR eError;
-		IMG_UINT32 ui32Count;
-		DISPLAY_FORMAT asFormat[PVRSRV_MAX_DC_DISPLAY_FORMATS];
-
-	} PVRSRV_BRIDGE_OUT_ENUM_DISPCLASS_FORMATS;
-
-	typedef struct PVRSRV_BRIDGE_IN_ENUM_DISPCLASS_DIMS_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDeviceKM;
-		DISPLAY_FORMAT sFormat;
-
-	} PVRSRV_BRIDGE_IN_ENUM_DISPCLASS_DIMS;
-
-	typedef struct PVRSRV_BRIDGE_OUT_ENUM_DISPCLASS_DIMS_TAG {
-		PVRSRV_ERROR eError;
-		IMG_UINT32 ui32Count;
-		DISPLAY_DIMS asDim[PVRSRV_MAX_DC_DISPLAY_DIMENSIONS];
-
-	} PVRSRV_BRIDGE_OUT_ENUM_DISPCLASS_DIMS;
-
-	typedef struct PVRSRV_BRIDGE_OUT_GET_DISPCLASS_INFO_TAG {
-		PVRSRV_ERROR eError;
-		DISPLAY_INFO sDisplayInfo;
-
-	} PVRSRV_BRIDGE_OUT_GET_DISPCLASS_INFO;
-
-	typedef struct PVRSRV_BRIDGE_OUT_GET_DISPCLASS_SYSBUFFER_TAG {
-		PVRSRV_ERROR eError;
-		IMG_HANDLE hBuffer;
-
-	} PVRSRV_BRIDGE_OUT_GET_DISPCLASS_SYSBUFFER;
-
-	typedef struct PVRSRV_BRIDGE_IN_CREATE_DISPCLASS_SWAPCHAIN_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDeviceKM;
-		IMG_UINT32 ui32Flags;
-		DISPLAY_SURF_ATTRIBUTES sDstSurfAttrib;
-		DISPLAY_SURF_ATTRIBUTES sSrcSurfAttrib;
-		IMG_UINT32 ui32BufferCount;
-		IMG_UINT32 ui32OEMFlags;
-		IMG_UINT32 ui32SwapChainID;
-
-	} PVRSRV_BRIDGE_IN_CREATE_DISPCLASS_SWAPCHAIN;
-
-	typedef struct PVRSRV_BRIDGE_OUT_CREATE_DISPCLASS_SWAPCHAIN_TAG {
-		PVRSRV_ERROR eError;
-		IMG_HANDLE hSwapChain;
-		IMG_UINT32 ui32SwapChainID;
-
-	} PVRSRV_BRIDGE_OUT_CREATE_DISPCLASS_SWAPCHAIN;
-
-	typedef struct PVRSRV_BRIDGE_IN_DESTROY_DISPCLASS_SWAPCHAIN_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDeviceKM;
-		IMG_HANDLE hSwapChain;
-
-	} PVRSRV_BRIDGE_IN_DESTROY_DISPCLASS_SWAPCHAIN;
-
-	typedef struct PVRSRV_BRIDGE_IN_SET_DISPCLASS_RECT_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDeviceKM;
-		IMG_HANDLE hSwapChain;
-		IMG_RECT sRect;
-
-	} PVRSRV_BRIDGE_IN_SET_DISPCLASS_RECT;
-
-	typedef struct PVRSRV_BRIDGE_IN_SET_DISPCLASS_COLOURKEY_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDeviceKM;
-		IMG_HANDLE hSwapChain;
-		IMG_UINT32 ui32CKColour;
-
-	} PVRSRV_BRIDGE_IN_SET_DISPCLASS_COLOURKEY;
-
-	typedef struct PVRSRV_BRIDGE_IN_GET_DISPCLASS_BUFFERS_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDeviceKM;
-		IMG_HANDLE hSwapChain;
-
-	} PVRSRV_BRIDGE_IN_GET_DISPCLASS_BUFFERS;
-
-	typedef struct PVRSRV_BRIDGE_OUT_GET_DISPCLASS_BUFFERS_TAG {
-		PVRSRV_ERROR eError;
-		IMG_UINT32 ui32BufferCount;
-		IMG_HANDLE ahBuffer[PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS];
-
-	} PVRSRV_BRIDGE_OUT_GET_DISPCLASS_BUFFERS;
-
-	typedef struct PVRSRV_BRIDGE_IN_SWAP_DISPCLASS_TO_BUFFER_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDeviceKM;
-		IMG_HANDLE hBuffer;
-		IMG_UINT32 ui32SwapInterval;
-		IMG_HANDLE hPrivateTag;
-		IMG_UINT32 ui32ClipRectCount;
-		IMG_RECT sClipRect[PVRSRV_MAX_DC_CLIP_RECTS];
-
-	} PVRSRV_BRIDGE_IN_SWAP_DISPCLASS_TO_BUFFER;
-
-	typedef struct PVRSRV_BRIDGE_IN_SWAP_DISPCLASS_TO_SYSTEM_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDeviceKM;
-		IMG_HANDLE hSwapChain;
-
-	} PVRSRV_BRIDGE_IN_SWAP_DISPCLASS_TO_SYSTEM;
-
-	typedef struct PVRSRV_BRIDGE_IN_OPEN_BUFFERCLASS_DEVICE_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_UINT32 ui32DeviceID;
-		IMG_HANDLE hDevCookie;
-
-	} PVRSRV_BRIDGE_IN_OPEN_BUFFERCLASS_DEVICE;
-
-	typedef struct PVRSRV_BRIDGE_OUT_OPEN_BUFFERCLASS_DEVICE_TAG {
-		PVRSRV_ERROR eError;
-		IMG_HANDLE hDeviceKM;
-
-	} PVRSRV_BRIDGE_OUT_OPEN_BUFFERCLASS_DEVICE;
-
-	typedef struct PVRSRV_BRIDGE_OUT_GET_BUFFERCLASS_INFO_TAG {
-		PVRSRV_ERROR eError;
-		BUFFER_INFO sBufferInfo;
-
-	} PVRSRV_BRIDGE_OUT_GET_BUFFERCLASS_INFO;
-
-	typedef struct PVRSRV_BRIDGE_IN_GET_BUFFERCLASS_BUFFER_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDeviceKM;
-		IMG_UINT32 ui32BufferIndex;
-
-	} PVRSRV_BRIDGE_IN_GET_BUFFERCLASS_BUFFER;
-
-	typedef struct PVRSRV_BRIDGE_OUT_GET_BUFFERCLASS_BUFFER_TAG {
-		PVRSRV_ERROR eError;
-		IMG_HANDLE hBuffer;
-
-	} PVRSRV_BRIDGE_OUT_GET_BUFFERCLASS_BUFFER;
-
-	typedef struct PVRSRV_BRIDGE_OUT_GET_DEVMEM_HEAPINFO_TAG {
-		PVRSRV_ERROR eError;
-		IMG_UINT32 ui32ClientHeapCount;
-		PVRSRV_HEAP_INFO sHeapInfo[PVRSRV_MAX_CLIENT_HEAPS];
-
-	} PVRSRV_BRIDGE_OUT_GET_DEVMEM_HEAPINFO;
-
-	typedef struct PVRSRV_BRIDGE_OUT_CREATE_DEVMEMCONTEXT_TAG {
-		PVRSRV_ERROR eError;
-		IMG_HANDLE hDevMemContext;
-		IMG_UINT32 ui32ClientHeapCount;
-		PVRSRV_HEAP_INFO sHeapInfo[PVRSRV_MAX_CLIENT_HEAPS];
-
-	} PVRSRV_BRIDGE_OUT_CREATE_DEVMEMCONTEXT;
-
-	typedef struct PVRSRV_BRIDGE_OUT_CREATE_DEVMEMHEAP_TAG {
-		PVRSRV_ERROR eError;
-		IMG_HANDLE hDevMemHeap;
-
-	} PVRSRV_BRIDGE_OUT_CREATE_DEVMEMHEAP;
-
-	typedef struct PVRSRV_BRIDGE_OUT_ALLOCDEVICEMEM_TAG {
-		PVRSRV_ERROR eError;
-		PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
-		PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
-		PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
-		PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
-
-	} PVRSRV_BRIDGE_OUT_ALLOCDEVICEMEM;
-
-	typedef struct PVRSRV_BRIDGE_OUT_MAPMEMINFOTOUSER_TAG {
-		PVRSRV_ERROR eError;
-		IMG_PVOID pvLinAddr;
-		IMG_HANDLE hMappingInfo;
-
-	} PVRSRV_BRIDGE_OUT_MAPMEMINFOTOUSER;
-
-	typedef struct PVRSRV_BRIDGE_OUT_GETFREEDEVICEMEM_TAG {
-		PVRSRV_ERROR eError;
-		IMG_UINT32 ui32Total;
-		IMG_UINT32 ui32Free;
-		IMG_UINT32 ui32LargestBlock;
-
-	} PVRSRV_BRIDGE_OUT_GETFREEDEVICEMEM;
+struct PVRSRV_BRIDGE_OUT_ENUM_DISPCLASS_FORMATS {
+	enum PVRSRV_ERROR eError;
+	u32 ui32Count;
+	struct DISPLAY_FORMAT asFormat[PVRSRV_MAX_DC_DISPLAY_FORMATS];
+};
+
+struct PVRSRV_BRIDGE_IN_ENUM_DISPCLASS_DIMS {
+	u32 ui32BridgeFlags;
+	void *hDeviceKM;
+	struct DISPLAY_FORMAT sFormat;
+};
+
+struct PVRSRV_BRIDGE_OUT_ENUM_DISPCLASS_DIMS {
+	enum PVRSRV_ERROR eError;
+	u32 ui32Count;
+	struct DISPLAY_DIMS asDim[PVRSRV_MAX_DC_DISPLAY_DIMENSIONS];
+};
+
+struct PVRSRV_BRIDGE_OUT_GET_DISPCLASS_INFO {
+	enum PVRSRV_ERROR eError;
+	struct DISPLAY_INFO sDisplayInfo;
+};
+
+struct PVRSRV_BRIDGE_OUT_GET_DISPCLASS_SYSBUFFER {
+	enum PVRSRV_ERROR eError;
+	void *hBuffer;
+};
+
+struct PVRSRV_BRIDGE_IN_CREATE_DISPCLASS_SWAPCHAIN {
+	u32 ui32BridgeFlags;
+	void *hDeviceKM;
+	u32 ui32Flags;
+	struct DISPLAY_SURF_ATTRIBUTES sDstSurfAttrib;
+	struct DISPLAY_SURF_ATTRIBUTES sSrcSurfAttrib;
+	u32 ui32BufferCount;
+	u32 ui32OEMFlags;
+	u32 ui32SwapChainID;
+};
+
+struct PVRSRV_BRIDGE_OUT_CREATE_DISPCLASS_SWAPCHAIN {
+	enum PVRSRV_ERROR eError;
+	void *hSwapChain;
+	u32 ui32SwapChainID;
+};
+
+struct PVRSRV_BRIDGE_IN_DESTROY_DISPCLASS_SWAPCHAIN {
+	u32 ui32BridgeFlags;
+	void *hDeviceKM;
+	void *hSwapChain;
+};
+
+struct PVRSRV_BRIDGE_IN_SET_DISPCLASS_RECT {
+	u32 ui32BridgeFlags;
+	void *hDeviceKM;
+	void *hSwapChain;
+	struct IMG_RECT sRect;
+};
+
+struct PVRSRV_BRIDGE_IN_SET_DISPCLASS_COLOURKEY {
+	u32 ui32BridgeFlags;
+	void *hDeviceKM;
+	void *hSwapChain;
+	u32 ui32CKColour;
+};
+
+struct PVRSRV_BRIDGE_IN_GET_DISPCLASS_BUFFERS {
+	u32 ui32BridgeFlags;
+	void *hDeviceKM;
+	void *hSwapChain;
+};
+
+struct PVRSRV_BRIDGE_OUT_GET_DISPCLASS_BUFFERS {
+	enum PVRSRV_ERROR eError;
+	u32 ui32BufferCount;
+	void *ahBuffer[PVRSRV_MAX_DC_SWAPCHAIN_BUFFERS];
+};
+
+struct PVRSRV_BRIDGE_IN_SWAP_DISPCLASS_TO_BUFFER {
+	u32 ui32BridgeFlags;
+	void *hDeviceKM;
+	void *hBuffer;
+	u32 ui32SwapInterval;
+	void *hPrivateTag;
+	u32 ui32ClipRectCount;
+	struct IMG_RECT sClipRect[PVRSRV_MAX_DC_CLIP_RECTS];
+};
+
+struct PVRSRV_BRIDGE_IN_SWAP_DISPCLASS_TO_SYSTEM {
+	u32 ui32BridgeFlags;
+	void *hDeviceKM;
+	void *hSwapChain;
+};
+
+struct PVRSRV_BRIDGE_IN_OPEN_BUFFERCLASS_DEVICE {
+	u32 ui32BridgeFlags;
+	u32 ui32DeviceID;
+	void *hDevCookie;
+};
+
+struct PVRSRV_BRIDGE_OUT_OPEN_BUFFERCLASS_DEVICE {
+	enum PVRSRV_ERROR eError;
+	void *hDeviceKM;
+};
+
+struct PVRSRV_BRIDGE_OUT_GET_BUFFERCLASS_INFO {
+	enum PVRSRV_ERROR eError;
+	struct BUFFER_INFO sBufferInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_GET_BUFFERCLASS_BUFFER {
+	u32 ui32BridgeFlags;
+	void *hDeviceKM;
+	u32 ui32BufferIndex;
+};
+
+struct PVRSRV_BRIDGE_OUT_GET_BUFFERCLASS_BUFFER {
+	enum PVRSRV_ERROR eError;
+	void *hBuffer;
+};
+
+struct PVRSRV_BRIDGE_OUT_GET_DEVMEM_HEAPINFO {
+	enum PVRSRV_ERROR eError;
+	u32 ui32ClientHeapCount;
+	struct PVRSRV_HEAP_INFO sHeapInfo[PVRSRV_MAX_CLIENT_HEAPS];
+};
+
+struct PVRSRV_BRIDGE_OUT_CREATE_DEVMEMCONTEXT {
+	enum PVRSRV_ERROR eError;
+	void *hDevMemContext;
+	u32 ui32ClientHeapCount;
+	struct PVRSRV_HEAP_INFO sHeapInfo[PVRSRV_MAX_CLIENT_HEAPS];
+};
+
+struct PVRSRV_BRIDGE_OUT_CREATE_DEVMEMHEAP {
+	enum PVRSRV_ERROR eError;
+	void *hDevMemHeap;
+};
+
+struct PVRSRV_BRIDGE_OUT_ALLOCDEVICEMEM {
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	struct PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
+	struct PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
+	struct PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
+};
+
+struct PVRSRV_BRIDGE_OUT_MAPMEMINFOTOUSER {
+	enum PVRSRV_ERROR eError;
+	void *pvLinAddr;
+	void *hMappingInfo;
+};
+
+struct PVRSRV_BRIDGE_OUT_GETFREEDEVICEMEM {
+	enum PVRSRV_ERROR eError;
+	u32 ui32Total;
+	u32 ui32Free;
+	u32 ui32LargestBlock;
+};
 
 #include "pvrmmap.h"
-	typedef struct PVRSRV_BRIDGE_OUT_KV_TO_MMAP_DATA_TAG {
-		PVRSRV_ERROR eError;
-
-		IMG_UINT32 ui32MMapOffset;
-
-		IMG_UINT32 ui32ByteOffset;
-
-		IMG_UINT32 ui32RealByteSize;
-
-	} PVRSRV_BRIDGE_OUT_KV_TO_MMAP_DATA;
-
-	typedef struct PVRSRV_BRIDGE_IN_GET_MISC_INFO_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_MISC_INFO sMiscInfo;
-
-	} PVRSRV_BRIDGE_IN_GET_MISC_INFO;
-
-	typedef struct PVRSRV_BRIDGE_OUT_GET_MISC_INFO_TAG {
-		PVRSRV_ERROR eError;
-		PVRSRV_MISC_INFO sMiscInfo;
-
-	} PVRSRV_BRIDGE_OUT_GET_MISC_INFO;
-
-	typedef struct PVRSRV_BRIDGE_IN_RELEASE_MISC_INFO_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_MISC_INFO sMiscInfo;
-
-	} PVRSRV_BRIDGE_IN_RELEASE_MISC_INFO;
-
-	typedef struct PVRSRV_BRIDGE_OUT_RELEASE_MISC_INFO_TAG {
-		PVRSRV_ERROR eError;
-		PVRSRV_MISC_INFO sMiscInfo;
-
-	} PVRSRV_BRIDGE_OUT_RELEASE_MISC_INFO;
-
-	typedef struct PVRSRV_BRIDGE_OUT_PDUMP_ISCAPTURING_TAG {
-		PVRSRV_ERROR eError;
-		IMG_BOOL bIsCapturing;
-
-	} PVRSRV_BRIDGE_OUT_PDUMP_ISCAPTURING;
-
-	typedef struct PVRSRV_BRIDGE_IN_GET_FB_STATS_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_UINT32 ui32Total;
-		IMG_UINT32 ui32Available;
-
-	} PVRSRV_BRIDGE_IN_GET_FB_STATS;
-
-	typedef struct PVRSRV_BRIDGE_IN_MAPPHYSTOUSERSPACE_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_SYS_PHYADDR sSysPhysAddr;
-		IMG_UINT32 uiSizeInBytes;
-
-	} PVRSRV_BRIDGE_IN_MAPPHYSTOUSERSPACE;
-
-	typedef struct PVRSRV_BRIDGE_OUT_MAPPHYSTOUSERSPACE_TAG {
-		IMG_PVOID pvUserAddr;
-		IMG_UINT32 uiActualSize;
-		IMG_PVOID pvProcess;
-
-	} PVRSRV_BRIDGE_OUT_MAPPHYSTOUSERSPACE;
-
-	typedef struct PVRSRV_BRIDGE_IN_UNMAPPHYSTOUSERSPACE_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_PVOID pvUserAddr;
-		IMG_PVOID pvProcess;
-
-	} PVRSRV_BRIDGE_IN_UNMAPPHYSTOUSERSPACE;
-
-	typedef struct PVRSRV_BRIDGE_OUT_GETPHYSTOUSERSPACEMAP_TAG {
-		IMG_PVOID *ppvTbl;
-		IMG_UINT32 uiTblSize;
-
-	} PVRSRV_BRIDGE_OUT_GETPHYSTOUSERSPACEMAP;
-
-	typedef struct PVRSRV_BRIDGE_IN_REGISTER_SIM_PROCESS_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_PVOID pvProcess;
-
-	} PVRSRV_BRIDGE_IN_REGISTER_SIM_PROCESS;
-
-	typedef struct PVRSRV_BRIDGE_OUT_REGISTER_SIM_PROCESS_TAG {
-		IMG_SYS_PHYADDR sRegsPhysBase;
-		IMG_VOID *pvRegsBase;
-		IMG_PVOID pvProcess;
-		IMG_UINT32 ulNoOfEntries;
-		IMG_PVOID pvTblLinAddr;
-
-	} PVRSRV_BRIDGE_OUT_REGISTER_SIM_PROCESS;
-
-	typedef struct PVRSRV_BRIDGE_IN_UNREGISTER_SIM_PROCESS_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_PVOID pvProcess;
-		IMG_VOID *pvRegsBase;
-
-	} PVRSRV_BRIDGE_IN_UNREGISTER_SIM_PROCESS;
-
-	typedef struct PVRSRV_BRIDGE_IN_PROCESS_SIMISR_EVENT_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_UINT32 ui32StatusAndMask;
-		PVRSRV_ERROR eError;
-
-	} PVRSRV_BRIDGE_IN_PROCESS_SIMISR_EVENT;
-
-	typedef struct PVRSRV_BRIDGE_IN_INITSRV_DISCONNECT_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_BOOL bInitSuccesful;
-	} PVRSRV_BRIDGE_IN_INITSRV_DISCONNECT;
-
-	typedef struct PVRSRV_BRIDGE_IN_ALLOC_SHARED_SYS_MEM_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_UINT32 ui32Flags;
-		IMG_UINT32 ui32Size;
-	} PVRSRV_BRIDGE_IN_ALLOC_SHARED_SYS_MEM;
-
-	typedef struct PVRSRV_BRIDGE_OUT_ALLOC_SHARED_SYS_MEM_TAG {
-		PVRSRV_ERROR eError;
-		PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
-		PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
-	} PVRSRV_BRIDGE_OUT_ALLOC_SHARED_SYS_MEM;
-
-	typedef struct PVRSRV_BRIDGE_IN_FREE_SHARED_SYS_MEM_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
-		PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
-	} PVRSRV_BRIDGE_IN_FREE_SHARED_SYS_MEM;
-
-	typedef struct PVRSRV_BRIDGE_OUT_FREE_SHARED_SYS_MEM_TAG {
-		PVRSRV_ERROR eError;
-	} PVRSRV_BRIDGE_OUT_FREE_SHARED_SYS_MEM;
-
-	typedef struct PVRSRV_BRIDGE_IN_MAP_MEMINFO_MEM_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hKernelMemInfo;
-	} PVRSRV_BRIDGE_IN_MAP_MEMINFO_MEM;
-
-	typedef struct PVRSRV_BRIDGE_OUT_MAP_MEMINFO_MEM_TAG {
-		PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
-		PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
-		PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
-		PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
-		PVRSRV_ERROR eError;
-	} PVRSRV_BRIDGE_OUT_MAP_MEMINFO_MEM;
-
-	typedef struct PVRSRV_BRIDGE_IN_UNMAP_MEMINFO_MEM_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
-	} PVRSRV_BRIDGE_IN_UNMAP_MEMINFO_MEM;
-
-	typedef struct PVRSRV_BRIDGE_OUT_UNMAP_MEMINFO_MEM_TAG {
-		PVRSRV_ERROR eError;
-	} PVRSRV_BRIDGE_OUT_UNMAP_MEMINFO_MEM;
-
-	typedef struct PVRSRV_BRIDGE_IN_GETMMU_PD_DEVPADDR_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevMemContext;
-	} PVRSRV_BRIDGE_IN_GETMMU_PD_DEVPADDR;
-
-	typedef struct PVRSRV_BRIDGE_OUT_GETMMU_PD_DEVPADDR_TAG {
-		IMG_DEV_PHYADDR sPDDevPAddr;
-		PVRSRV_ERROR eError;
-	} PVRSRV_BRIDGE_OUT_GETMMU_PD_DEVPADDR;
-
-	typedef struct PVRSRV_BRIDGE_IN_EVENT_OBJECT_WAI_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hOSEventKM;
-	} PVRSRV_BRIDGE_IN_EVENT_OBJECT_WAIT;
+struct PVRSRV_BRIDGE_OUT_KV_TO_MMAP_DATA {
+	enum PVRSRV_ERROR eError;
 
-	typedef struct PVRSRV_BRIDGE_IN_EVENT_OBJECT_OPEN_TAG {
-		PVRSRV_EVENTOBJECT sEventObject;
-	} PVRSRV_BRIDGE_IN_EVENT_OBJECT_OPEN;
+	u32 ui32MMapOffset;
 
-	typedef struct PVRSRV_BRIDGE_OUT_EVENT_OBJECT_OPEN_TAG {
-		IMG_HANDLE hOSEvent;
-		PVRSRV_ERROR eError;
-	} PVRSRV_BRIDGE_OUT_EVENT_OBJECT_OPEN;
+	u32 ui32ByteOffset;
 
-	typedef struct PVRSRV_BRIDGE_IN_EVENT_OBJECT_CLOSE_TAG {
-		PVRSRV_EVENTOBJECT sEventObject;
-		IMG_HANDLE hOSEventKM;
-	} PVRSRV_BRIDGE_IN_EVENT_OBJECT_CLOSE;
+	u32 ui32RealByteSize;
+};
+
+struct PVRSRV_BRIDGE_IN_GET_MISC_INFO {
+	u32 ui32BridgeFlags;
+	struct PVRSRV_MISC_INFO sMiscInfo;
+};
+
+struct PVRSRV_BRIDGE_OUT_GET_MISC_INFO {
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_MISC_INFO sMiscInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_RELEASE_MISC_INFO {
+	u32 ui32BridgeFlags;
+	struct PVRSRV_MISC_INFO sMiscInfo;
+};
+
+struct PVRSRV_BRIDGE_OUT_RELEASE_MISC_INFO {
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_MISC_INFO sMiscInfo;
+};
+
+struct PVRSRV_BRIDGE_OUT_PDUMP_ISCAPTURING {
+	enum PVRSRV_ERROR eError;
+	IMG_BOOL bIsCapturing;
+};
+
+struct PVRSRV_BRIDGE_IN_GET_FB_STATS {
+	u32 ui32BridgeFlags;
+	u32 ui32Total;
+	u32 ui32Available;
+};
+
+struct PVRSRV_BRIDGE_IN_MAPPHYSTOUSERSPACE {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	struct IMG_SYS_PHYADDR sSysPhysAddr;
+	u32 uiSizeInBytes;
+};
+
+struct PVRSRV_BRIDGE_OUT_MAPPHYSTOUSERSPACE {
+	void *pvUserAddr;
+	u32 uiActualSize;
+	void *pvProcess;
+};
+
+struct PVRSRV_BRIDGE_IN_UNMAPPHYSTOUSERSPACE {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	void *pvUserAddr;
+	void *pvProcess;
+};
+
+struct PVRSRV_BRIDGE_OUT_GETPHYSTOUSERSPACEMAP {
+	void **ppvTbl;
+	u32 uiTblSize;
+};
+
+struct PVRSRV_BRIDGE_IN_REGISTER_SIM_PROCESS {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	void *pvProcess;
+};
+
+struct PVRSRV_BRIDGE_OUT_REGISTER_SIM_PROCESS {
+	struct IMG_SYS_PHYADDR sRegsPhysBase;
+	void *pvRegsBase;
+	void *pvProcess;
+	u32 ulNoOfEntries;
+	void *pvTblLinAddr;
+};
+
+struct PVRSRV_BRIDGE_IN_UNREGISTER_SIM_PROCESS {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	void *pvProcess;
+	void *pvRegsBase;
+};
+
+struct PVRSRV_BRIDGE_IN_PROCESS_SIMISR_EVENT {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	u32 ui32StatusAndMask;
+	enum PVRSRV_ERROR eError;
+};
+
+struct PVRSRV_BRIDGE_IN_INITSRV_DISCONNECT {
+	u32 ui32BridgeFlags;
+	IMG_BOOL bInitSuccesful;
+};
+
+struct PVRSRV_BRIDGE_IN_ALLOC_SHARED_SYS_MEM {
+	u32 ui32BridgeFlags;
+	u32 ui32Flags;
+	u32 ui32Size;
+};
+
+struct PVRSRV_BRIDGE_OUT_ALLOC_SHARED_SYS_MEM {
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	struct PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_FREE_SHARED_SYS_MEM {
+	u32 ui32BridgeFlags;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	struct PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
+};
+
+struct PVRSRV_BRIDGE_OUT_FREE_SHARED_SYS_MEM {
+	enum PVRSRV_ERROR eError;
+};
+
+struct PVRSRV_BRIDGE_IN_MAP_MEMINFO_MEM {
+	u32 ui32BridgeFlags;
+	void *hKernelMemInfo;
+};
+
+struct PVRSRV_BRIDGE_OUT_MAP_MEMINFO_MEM {
+	struct PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
+	struct PVRSRV_CLIENT_SYNC_INFO sClientSyncInfo;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo;
+	struct PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
+	enum PVRSRV_ERROR eError;
+};
+
+struct PVRSRV_BRIDGE_IN_UNMAP_MEMINFO_MEM {
+	u32 ui32BridgeFlags;
+	struct PVRSRV_CLIENT_MEM_INFO sClientMemInfo;
+};
+
+struct PVRSRV_BRIDGE_OUT_UNMAP_MEMINFO_MEM {
+	enum PVRSRV_ERROR eError;
+};
+
+struct PVRSRV_BRIDGE_IN_GETMMU_PD_DEVPADDR {
+	u32 ui32BridgeFlags;
+	void *hDevMemContext;
+};
+
+struct PVRSRV_BRIDGE_OUT_GETMMU_PD_DEVPADDR {
+	struct IMG_DEV_PHYADDR sPDDevPAddr;
+	enum PVRSRV_ERROR eError;
+};
+
+struct PVRSRV_BRIDGE_IN_EVENT_OBJECT_WAIT {
+	u32 ui32BridgeFlags;
+	void *hOSEventKM;
+};
+
+struct PVRSRV_BRIDGE_IN_EVENT_OBJECT_OPEN {
+	struct PVRSRV_EVENTOBJECT sEventObject;
+};
+
+struct PVRSRV_BRIDGE_OUT_EVENT_OBJECT_OPEN {
+	void *hOSEvent;
+	enum PVRSRV_ERROR eError;
+};
+
+struct PVRSRV_BRIDGE_IN_EVENT_OBJECT_CLOSE {
+	struct PVRSRV_EVENTOBJECT sEventObject;
+	void *hOSEventKM;
+};
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/pvr_bridge_k.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/pvr_bridge_k.c
@@ -1,32 +1,33 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #include "img_defs.h"
 #include "services.h"
 #include "pvr_bridge.h"
+#include "pvr_bridge_km.h"
 #include "perproc.h"
 #include "mutex.h"
 #include "syscommon.h"
@@ -42,24 +43,21 @@
 static off_t printLinuxBridgeStats(char *buffer, size_t size, off_t off);
 #endif
 
-extern PVRSRV_LINUX_MUTEX gPVRSRVLock;
-
-PVRSRV_ERROR LinuxBridgeInit(IMG_VOID)
+enum PVRSRV_ERROR LinuxBridgeInit(void)
 {
 #if defined(DEBUG_BRIDGE_KM)
 	{
 		int iStatus;
 		iStatus =
 		    CreateProcReadEntry("bridge_stats", printLinuxBridgeStats);
-		if (iStatus != 0) {
+		if (iStatus != 0)
 			return PVRSRV_ERROR_OUT_OF_MEMORY;
-		}
 	}
 #endif
 	return CommonBridgeInit();
 }
 
-IMG_VOID LinuxBridgeDeInit(IMG_VOID)
+void LinuxBridgeDeInit(void)
 {
 #if defined(DEBUG_BRIDGE_KM)
 	RemoveProcEntry("bridge_stats");
@@ -69,7 +67,7 @@
 #if defined(DEBUG_BRIDGE_KM)
 static off_t printLinuxBridgeStats(char *buffer, size_t count, off_t off)
 {
-	PVRSRV_BRIDGE_DISPATCH_TABLE_ENTRY *psEntry;
+	struct PVRSRV_BRIDGE_DISPATCH_TABLE_ENTRY *psEntry;
 	off_t Ret;
 
 	LinuxLockMutex(&gPVRSRVLock);
@@ -80,21 +78,22 @@
 			goto unlock_and_return;
 		}
 		Ret = printAppend(buffer, count, 0,
-				  "Total ioctl call count = %lu\n"
-				  "Total number of bytes copied via copy_from_user = %lu\n"
-				  "Total number of bytes copied via copy_to_user = %lu\n"
-				  "Total number of bytes copied via copy_*_user = %lu\n\n"
-				  "%-45s | %-40s | %10s | %20s | %10s\n",
-				  g_BridgeGlobalStats.ui32IOCTLCount,
-				  g_BridgeGlobalStats.
-				  ui32TotalCopyFromUserBytes,
-				  g_BridgeGlobalStats.ui32TotalCopyToUserBytes,
-				  g_BridgeGlobalStats.
-				  ui32TotalCopyFromUserBytes +
-				  g_BridgeGlobalStats.ui32TotalCopyToUserBytes,
-				  "Bridge Name", "Wrapper Function",
-				  "Call Count", "copy_from_user Bytes",
-				  "copy_to_user Bytes");
+		  "Total ioctl call count = %u\n"
+		  "Total number of bytes copied via copy_from_user = %u\n"
+		  "Total number of bytes copied via copy_to_user = %u\n"
+		  "Total number of bytes copied via copy_*_user = %u\n\n"
+		  "%-45s | %-40s | %10s | %20s | %10s\n",
+		  g_BridgeGlobalStats.ui32IOCTLCount,
+		  g_BridgeGlobalStats.
+		  ui32TotalCopyFromUserBytes,
+		  g_BridgeGlobalStats.ui32TotalCopyToUserBytes,
+		  g_BridgeGlobalStats.
+		  ui32TotalCopyFromUserBytes +
+		  g_BridgeGlobalStats.ui32TotalCopyToUserBytes,
+		  "Bridge Name", "Wrapper Function",
+		  "Call Count", "copy_from_user Bytes",
+		  "copy_to_user Bytes");
+
 		goto unlock_and_return;
 	}
 
@@ -110,7 +109,7 @@
 
 	psEntry = &g_BridgeDispatchTable[off - 1];
 	Ret = printAppend(buffer, count, 0,
-			  "%-45s   %-40s   %-10lu   %-20lu   %-10lu\n",
+			  "%-45s   %-40s   %-10u   %-20u   %-10u\n",
 			  psEntry->pszIOCName,
 			  psEntry->pszFunctionName,
 			  psEntry->ui32CallCount,
@@ -123,69 +122,65 @@
 }
 #endif
 
-long
-PVRSRV_BridgeDispatchKM(struct file *file, unsigned int cmd, unsigned long arg)
+long PVRSRV_BridgeDispatchKM(struct file *file, unsigned int cmd,
+			     unsigned long arg)
 {
-	IMG_UINT32 ui32BridgeID = PVRSRV_GET_BRIDGE_ID(cmd);
-	PVRSRV_BRIDGE_PACKAGE *psBridgePackageUM =
-	    (PVRSRV_BRIDGE_PACKAGE *) arg;
-	PVRSRV_BRIDGE_PACKAGE sBridgePackageKM;
-	IMG_UINT32 ui32PID = OSGetCurrentProcessIDKM();
-	PVRSRV_PER_PROCESS_DATA *psPerProc;
+	u32 ui32BridgeID = PVRSRV_GET_BRIDGE_ID(cmd);
+	struct PVRSRV_BRIDGE_PACKAGE __user *psBridgePackageUM =
+	    (struct PVRSRV_BRIDGE_PACKAGE __user *)arg;
+	struct PVRSRV_BRIDGE_PACKAGE sBridgePackageKM;
+	u32 ui32PID = OSGetCurrentProcessIDKM();
+	struct PVRSRV_PER_PROCESS_DATA *psPerProc;
 	int err = -EFAULT;
 
 	LinuxLockMutex(&gPVRSRVLock);
 
-	if (!OSAccessOK(PVR_VERIFY_WRITE,
-			psBridgePackageUM, sizeof(PVRSRV_BRIDGE_PACKAGE))) {
-		PVR_DPF((PVR_DBG_ERROR,
+	if (!OSAccessOK(PVR_VERIFY_WRITE, psBridgePackageUM,
+			sizeof(struct PVRSRV_BRIDGE_PACKAGE))) {
+		PVR_DPF(PVR_DBG_ERROR,
 			 "%s: Received invalid pointer to function arguments",
-			 __FUNCTION__));
+			 __func__);
 
 		goto unlock_and_return;
 	}
 
-	if (OSCopyFromUser(IMG_NULL,
-			   &sBridgePackageKM,
-			   psBridgePackageUM, sizeof(PVRSRV_BRIDGE_PACKAGE))
-	    != PVRSRV_OK) {
+	if (OSCopyFromUser(NULL, &sBridgePackageKM, psBridgePackageUM,
+			   sizeof(struct PVRSRV_BRIDGE_PACKAGE)) != PVRSRV_OK)
 		goto unlock_and_return;
-	}
 
 	if (ui32BridgeID !=
 	    PVRSRV_GET_BRIDGE_ID(PVRSRV_BRIDGE_CONNECT_SERVICES)) {
-		PVRSRV_ERROR eError;
+		enum PVRSRV_ERROR eError;
 
 		eError = PVRSRVLookupHandle(KERNEL_HANDLE_BASE,
-					    (IMG_PVOID *) & psPerProc,
+					    (void **)&psPerProc,
 					    sBridgePackageKM.hKernelServices,
 					    PVRSRV_HANDLE_TYPE_PERPROC_DATA);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
+			PVR_DPF(PVR_DBG_ERROR,
 				 "%s: Invalid kernel services handle (%d)",
-				 __FUNCTION__, eError));
+				 __func__, eError);
 			goto unlock_and_return;
 		}
 
 		if (psPerProc->ui32PID != ui32PID) {
-			PVR_DPF((PVR_DBG_ERROR,
+			PVR_DPF(PVR_DBG_ERROR,
 				 "%s: Process %d tried to access data "
-				 "belonging to process %d", __FUNCTION__,
-				 ui32PID, psPerProc->ui32PID));
+				 "belonging to process %d", __func__,
+				 ui32PID, psPerProc->ui32PID);
 			goto unlock_and_return;
 		}
 	} else {
-
 		psPerProc = PVRSRVPerProcessData(ui32PID);
-		if (psPerProc == IMG_NULL) {
-			PVR_DPF((PVR_DBG_ERROR, "PVRSRV_BridgeDispatchKM: "
-				 "Couldn't create per-process data area"));
+		if (psPerProc == NULL) {
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRV_BridgeDispatchKM: "
+				 "Couldn't create per-process data area");
 			goto unlock_and_return;
 		}
 	}
 
-	sBridgePackageKM.ui32BridgeID =
-	    PVRSRV_GET_BRIDGE_ID(sBridgePackageKM.ui32BridgeID);
+	sBridgePackageKM.ui32BridgeID = PVRSRV_GET_BRIDGE_ID(
+						sBridgePackageKM.ui32BridgeID);
 
 	err = BridgedDispatchKM(psPerProc, &sBridgePackageKM);
 
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/pvr_bridge_km.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/pvr_bridge_km.h
@@ -1,350 +1,198 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef __PVR_BRIDGE_KM_H_
 #define __PVR_BRIDGE_KM_H_
 
+#include <linux/file.h>
 
+#include "kernelbuffer.h"
 #include "pvr_bridge.h"
 #include "perproc.h"
 
-	PVRSRV_ERROR LinuxBridgeInit(IMG_VOID);
-	IMG_VOID LinuxBridgeDeInit(IMG_VOID);
+enum PVRSRV_ERROR LinuxBridgeInit(void);
+void LinuxBridgeDeInit(void);
+
+enum PVRSRV_ERROR PVRSRVEnumerateDevicesKM(u32 *pui32NumDevices,
+		struct PVRSRV_DEVICE_IDENTIFIER *psDevIdList);
+
+enum PVRSRV_ERROR PVRSRVAcquireDeviceDataKM(u32 uiDevIndex,
+		enum PVRSRV_DEVICE_TYPE eDeviceType,
+		void **phDevCookie);
+
+enum PVRSRV_ERROR PVRSRVCreateCommandQueueKM(u32 ui32QueueSize,
+		struct PVRSRV_QUEUE_INFO **ppsQueueInfo);
+
+enum PVRSRV_ERROR PVRSRVDestroyCommandQueueKM(
+					struct PVRSRV_QUEUE_INFO *psQueueInfo);
+
+enum PVRSRV_ERROR PVRSRVGetDeviceMemHeapsKM(void *hDevCookie,
+		struct PVRSRV_HEAP_INFO *psHeapInfo);
+
+enum PVRSRV_ERROR PVRSRVCreateDeviceMemContextKM(void *hDevCookie,
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+		void **phDevMemContext, u32 *pui32ClientHeapCount,
+		struct PVRSRV_HEAP_INFO *psHeapInfo, IMG_BOOL *pbCreated,
+		IMG_BOOL *pbShared);
+
+enum PVRSRV_ERROR PVRSRVDestroyDeviceMemContextKM(void *hDevCookie,
+		void *hDevMemContext, IMG_BOOL *pbCreated);
+
+enum PVRSRV_ERROR PVRSRVGetDeviceMemHeapInfoKM(void *hDevCookie,
+		void *hDevMemContext, u32 *pui32ClientHeapCount,
+		struct PVRSRV_HEAP_INFO *psHeapInfo, IMG_BOOL *pbShared);
+
+enum PVRSRV_ERROR PVRSRVAllocDeviceMemKM(void *hDevCookie,
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc, void *hDevMemHeap,
+		u32 ui32Flags, u32 ui32Size, u32 ui32Alignment,
+		struct PVRSRV_KERNEL_MEM_INFO **ppsMemInfo);
+
+enum PVRSRV_ERROR PVRSRVFreeDeviceMemKM(void *hDevCookie,
+		struct PVRSRV_KERNEL_MEM_INFO *psMemInfo);
+
+enum PVRSRV_ERROR PVRSRVDissociateDeviceMemKM(void *hDevCookie,
+		struct PVRSRV_KERNEL_MEM_INFO *psMemInfo);
+
+enum PVRSRV_ERROR PVRSRVReserveDeviceVirtualMemKM(void *hDevMemHeap,
+		struct IMG_DEV_VIRTADDR *psDevVAddr, u32 ui32Size,
+		u32 ui32Alignment, struct PVRSRV_KERNEL_MEM_INFO **ppsMemInfo);
+
+enum PVRSRV_ERROR PVRSRVFreeDeviceVirtualMemKM(
+		struct PVRSRV_KERNEL_MEM_INFO *psMemInfo);
+
+enum PVRSRV_ERROR PVRSRVMapDeviceMemoryKM(
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+		struct PVRSRV_KERNEL_MEM_INFO *psSrcMemInfo,
+		void *hDstDevMemHeap,
+		struct PVRSRV_KERNEL_MEM_INFO **ppsDstMemInfo);
+
+enum PVRSRV_ERROR PVRSRVUnmapDeviceMemoryKM(
+		struct PVRSRV_KERNEL_MEM_INFO *psMemInfo);
+
+enum PVRSRV_ERROR PVRSRVWrapExtMemoryKM(void *hDevCookie,
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc, u32 ui32ByteSize,
+		u32 ui32PageOffset, IMG_BOOL bPhysContig,
+		struct IMG_SYS_PHYADDR *psSysAddr, void *pvLinAddr,
+		struct PVRSRV_KERNEL_MEM_INFO **ppsMemInfo);
+
+enum PVRSRV_ERROR PVRSRVIsWrappedExtMemoryKM(void *hDevCookie,
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc, u32 *pui32ByteSize,
+		void **pvLinAddr);
+
+enum PVRSRV_ERROR PVRSRVUnwrapExtMemoryKM(
+		struct PVRSRV_KERNEL_MEM_INFO *psMemInfo);
+
+enum PVRSRV_ERROR PVRSRVEnumerateDCKM(enum PVRSRV_DEVICE_CLASS DeviceClass,
+		u32 *pui32DevCount, u32 *pui32DevID);
+
+enum PVRSRV_ERROR PVRSRVOpenDCDeviceKM(
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+		u32 ui32DeviceID, void *hDevCookie, void **phDeviceKM);
+
+enum PVRSRV_ERROR PVRSRVCloseDCDeviceKM(void *hDeviceKM,
+		IMG_BOOL bResManCallback);
+
+enum PVRSRV_ERROR PVRSRVEnumDCFormatsKM(void *hDeviceKM, u32 *pui32Count,
+		struct DISPLAY_FORMAT *psFormat);
+
+enum PVRSRV_ERROR PVRSRVEnumDCDimsKM(void *hDeviceKM,
+		struct DISPLAY_FORMAT *psFormat, u32 *pui32Count,
+		struct DISPLAY_DIMS *psDim);
+
+enum PVRSRV_ERROR PVRSRVGetDCSystemBufferKM(void *hDeviceKM, void **phBuffer);
+
+enum PVRSRV_ERROR PVRSRVGetDCInfoKM(void *hDeviceKM,
+		struct DISPLAY_INFO *psDisplayInfo);
+
+enum PVRSRV_ERROR PVRSRVCreateDCSwapChainKM(
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc, void *hDeviceKM,
+		u32 ui32Flags, struct DISPLAY_SURF_ATTRIBUTES *psDstSurfAttrib,
+		struct DISPLAY_SURF_ATTRIBUTES *psSrcSurfAttrib,
+		u32 ui32BufferCount, u32 ui32OEMFlags, void **phSwapChain,
+		u32 *pui32SwapChainID);
+
+enum PVRSRV_ERROR PVRSRVDestroyDCSwapChainKM(void *hSwapChain);
+enum PVRSRV_ERROR PVRSRVSetDCDstRectKM(void *hDeviceKM, void *hSwapChain,
+		struct IMG_RECT *psRect);
+enum PVRSRV_ERROR PVRSRVSetDCSrcRectKM(void *hDeviceKM, void *hSwapChain,
+		struct IMG_RECT *psRect);
+enum PVRSRV_ERROR PVRSRVSetDCDstColourKeyKM(void *hDeviceKM, void *hSwapChain,
+		u32 ui32CKColour);
+enum PVRSRV_ERROR PVRSRVSetDCSrcColourKeyKM(void *hDeviceKM, void *hSwapChain,
+		u32 ui32CKColour);
+enum PVRSRV_ERROR PVRSRVGetDCBuffersKM(void *hDeviceKM, void *hSwapChain,
+		u32 *pui32BufferCount, void **phBuffer);
+enum PVRSRV_ERROR PVRSRVSwapToDCBufferKM(void *hDeviceKM, void *hBuffer,
+		u32 ui32SwapInterval, void *hPrivateTag,
+		u32 ui32ClipRectCount, struct IMG_RECT *psClipRect);
+enum PVRSRV_ERROR PVRSRVSwapToDCSystemKM(void *hDeviceKM, void *hSwapChain);
+
+enum PVRSRV_ERROR PVRSRVOpenBCDeviceKM(
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+		u32 ui32DeviceID, void *hDevCookie, void **phDeviceKM);
+enum PVRSRV_ERROR PVRSRVCloseBCDeviceKM(void *hDeviceKM,
+		IMG_BOOL bResManCallback);
+
+enum PVRSRV_ERROR PVRSRVGetBCInfoKM(void *hDeviceKM,
+		struct BUFFER_INFO *psBufferInfo);
+enum PVRSRV_ERROR PVRSRVGetBCBufferKM(void *hDeviceKM, u32 ui32BufferIndex,
+		void **phBuffer);
+extern IMG_BOOL PVRGetBufferClassJTable(
+		struct PVRSRV_BC_BUFFER2SRV_KMJTABLE *psJTable);
+
+enum PVRSRV_ERROR PVRSRVMapDeviceClassMemoryKM(
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+		void *hDeviceClassBuffer,
+		struct PVRSRV_KERNEL_MEM_INFO **ppsMemInfo, void **phOSMapInfo);
+
+enum PVRSRV_ERROR PVRSRVUnmapDeviceClassMemoryKM(
+		struct PVRSRV_KERNEL_MEM_INFO *psMemInfo);
+
+enum PVRSRV_ERROR PVRSRVGetFreeDeviceMemKM(u32 ui32Flags, u32 *pui32Total,
+		u32 *pui32Free, u32 *pui32LargestBlock);
+enum PVRSRV_ERROR PVRSRVAllocSyncInfoKM(void *hDevCookie, void *hDevMemContext,
+		struct PVRSRV_KERNEL_SYNC_INFO **ppsKernelSyncInfo);
+enum PVRSRV_ERROR PVRSRVFreeSyncInfoKM(
+		struct PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo);
+
+enum PVRSRV_ERROR PVRSRVGetMiscInfoKM(struct PVRSRV_MISC_INFO *psMiscInfo);
+
+enum PVRSRV_ERROR PVRSRVGetFBStatsKM(u32 *pui32Total, u32 *pui32Available);
+
+enum PVRSRV_ERROR PVRSRVAllocSharedSysMemoryKM(
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc, u32 ui32Flags,
+		u32 ui32Size, struct PVRSRV_KERNEL_MEM_INFO **ppsKernelMemInfo);
+
+enum PVRSRV_ERROR PVRSRVFreeSharedSysMemoryKM(
+		struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo);
+
+enum PVRSRV_ERROR PVRSRVDissociateMemFromResmanKM(
+		struct PVRSRV_KERNEL_MEM_INFO *psKernelMemInfo);
 
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVEnumerateDevicesKM(IMG_UINT32 *
-							       pui32NumDevices,
-							       PVRSRV_DEVICE_IDENTIFIER
-							       * psDevIdList);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVAcquireDeviceDataKM(IMG_UINT32
-								uiDevIndex,
-								PVRSRV_DEVICE_TYPE
-								eDeviceType,
-								IMG_HANDLE *
-								phDevCookie);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateCommandQueueKM(IMG_UINT32
-								 ui32QueueSize,
-								 PVRSRV_QUEUE_INFO
-								 **
-								 ppsQueueInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVDestroyCommandQueueKM(PVRSRV_QUEUE_INFO * psQueueInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVGetDeviceMemHeapsKM(IMG_HANDLE
-								hDevCookie,
-								PVRSRV_HEAP_INFO
-								* psHeapInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateDeviceMemContextKM(IMG_HANDLE
-								     hDevCookie,
-								     PVRSRV_PER_PROCESS_DATA
-								     *
-								     psPerProc,
-								     IMG_HANDLE
-								     *
-								     phDevMemContext,
-								     IMG_UINT32
-								     *
-								     pui32ClientHeapCount,
-								     PVRSRV_HEAP_INFO
-								     *
-								     psHeapInfo,
-								     IMG_BOOL *
-								     pbCreated
-								     ,
-								     IMG_BOOL *
-								     pbShared
-	    );
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroyDeviceMemContextKM(IMG_HANDLE
-								      hDevCookie,
-								      IMG_HANDLE
-								      hDevMemContext,
-								      IMG_BOOL *
-								      pbCreated);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVGetDeviceMemHeapInfoKM(IMG_HANDLE
-								   hDevCookie,
-								   IMG_HANDLE
-								   hDevMemContext,
-								   IMG_UINT32 *
-								   pui32ClientHeapCount,
-								   PVRSRV_HEAP_INFO
-								   * psHeapInfo
-								   ,
-								   IMG_BOOL *
-								   pbShared
-	    );
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocDeviceMemKM(IMG_HANDLE
-							     hDevCookie,
-							     PVRSRV_PER_PROCESS_DATA
-							     * psPerProc,
-							     IMG_HANDLE
-							     hDevMemHeap,
-							     IMG_UINT32
-							     ui32Flags,
-							     IMG_UINT32
-							     ui32Size,
-							     IMG_UINT32
-							     ui32Alignment,
-							     PVRSRV_KERNEL_MEM_INFO
-							     ** ppsMemInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVFreeDeviceMemKM(IMG_HANDLE
-							    hDevCookie,
-							    PVRSRV_KERNEL_MEM_INFO
-							    * psMemInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVDissociateDeviceMemKM(IMG_HANDLE
-								  hDevCookie,
-								  PVRSRV_KERNEL_MEM_INFO
-								  * psMemInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVReserveDeviceVirtualMemKM(IMG_HANDLE
-								      hDevMemHeap,
-								      IMG_DEV_VIRTADDR
-								      *
-								      psDevVAddr,
-								      IMG_UINT32
-								      ui32Size,
-								      IMG_UINT32
-								      ui32Alignment,
-								      PVRSRV_KERNEL_MEM_INFO
-								      **
-								      ppsMemInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVFreeDeviceVirtualMemKM(PVRSRV_KERNEL_MEM_INFO * psMemInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVMapDeviceMemoryKM(PVRSRV_PER_PROCESS_DATA * psPerProc,
-				    PVRSRV_KERNEL_MEM_INFO * psSrcMemInfo,
-				    IMG_HANDLE hDstDevMemHeap,
-				    PVRSRV_KERNEL_MEM_INFO ** ppsDstMemInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVUnmapDeviceMemoryKM(PVRSRV_KERNEL_MEM_INFO * psMemInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtMemoryKM(IMG_HANDLE
-							    hDevCookie,
-							    PVRSRV_PER_PROCESS_DATA
-							    * psPerProc,
-							    IMG_UINT32
-							    ui32ByteSize,
-							    IMG_UINT32
-							    ui32PageOffset,
-							    IMG_BOOL
-							    bPhysContig,
-							    IMG_SYS_PHYADDR *
-							    psSysAddr,
-							    IMG_VOID *
-							    pvLinAddr,
-							    PVRSRV_KERNEL_MEM_INFO
-							    ** ppsMemInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVIsWrappedExtMemoryKM(IMG_HANDLE hDevCookie,
-						  PVRSRV_PER_PROCESS_DATA *psPerProc,
-						  IMG_UINT32 *pui32ByteSize,
-						  IMG_VOID **pvLinAddr);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVUnwrapExtMemoryKM(PVRSRV_KERNEL_MEM_INFO * psMemInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVEnumerateDCKM(PVRSRV_DEVICE_CLASS DeviceClass,
-					     IMG_UINT32 * pui32DevCount,
-					     IMG_UINT32 * pui32DevID);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVOpenDCDeviceKM(PVRSRV_PER_PROCESS_DATA *
-					      psPerProc,
-					      IMG_UINT32 ui32DeviceID,
-					      IMG_HANDLE hDevCookie,
-					      IMG_HANDLE * phDeviceKM);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVCloseDCDeviceKM(IMG_HANDLE hDeviceKM,
-					       IMG_BOOL bResManCallback);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVEnumDCFormatsKM(IMG_HANDLE hDeviceKM,
-					       IMG_UINT32 * pui32Count,
-					       DISPLAY_FORMAT * psFormat);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVEnumDCDimsKM(IMG_HANDLE hDeviceKM,
-					    DISPLAY_FORMAT * psFormat,
-					    IMG_UINT32 * pui32Count,
-					    DISPLAY_DIMS * psDim);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVGetDCSystemBufferKM(IMG_HANDLE hDeviceKM,
-						   IMG_HANDLE * phBuffer);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVGetDCInfoKM(IMG_HANDLE hDeviceKM,
-					   DISPLAY_INFO * psDisplayInfo);
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVCreateDCSwapChainKM(PVRSRV_PER_PROCESS_DATA *
-						   psPerProc,
-						   IMG_HANDLE hDeviceKM,
-						   IMG_UINT32 ui32Flags,
-						   DISPLAY_SURF_ATTRIBUTES *
-						   psDstSurfAttrib,
-						   DISPLAY_SURF_ATTRIBUTES *
-						   psSrcSurfAttrib,
-						   IMG_UINT32 ui32BufferCount,
-						   IMG_UINT32 ui32OEMFlags,
-						   IMG_HANDLE * phSwapChain,
-						   IMG_UINT32 *
-						   pui32SwapChainID);
-	 IMG_IMPORT PVRSRV_ERROR PVRSRVDestroyDCSwapChainKM(IMG_HANDLE
-							    hSwapChain);
-	 IMG_IMPORT PVRSRV_ERROR PVRSRVSetDCDstRectKM(IMG_HANDLE hDeviceKM,
-						      IMG_HANDLE hSwapChain,
-						      IMG_RECT * psRect);
-	 IMG_IMPORT PVRSRV_ERROR PVRSRVSetDCSrcRectKM(IMG_HANDLE hDeviceKM,
-						      IMG_HANDLE hSwapChain,
-						      IMG_RECT * psRect);
-	 IMG_IMPORT PVRSRV_ERROR PVRSRVSetDCDstColourKeyKM(IMG_HANDLE hDeviceKM,
-							   IMG_HANDLE
-							   hSwapChain,
-							   IMG_UINT32
-							   ui32CKColour);
-	 IMG_IMPORT PVRSRV_ERROR PVRSRVSetDCSrcColourKeyKM(IMG_HANDLE hDeviceKM,
-							   IMG_HANDLE
-							   hSwapChain,
-							   IMG_UINT32
-							   ui32CKColour);
-	 IMG_IMPORT PVRSRV_ERROR PVRSRVGetDCBuffersKM(IMG_HANDLE hDeviceKM,
-						      IMG_HANDLE hSwapChain,
-						      IMG_UINT32 *
-						      pui32BufferCount,
-						      IMG_HANDLE * phBuffer);
-	 IMG_IMPORT PVRSRV_ERROR PVRSRVSwapToDCBufferKM(IMG_HANDLE hDeviceKM,
-							IMG_HANDLE hBuffer,
-							IMG_UINT32
-							ui32SwapInterval,
-							IMG_HANDLE hPrivateTag,
-							IMG_UINT32
-							ui32ClipRectCount,
-							IMG_RECT * psClipRect);
-	 IMG_IMPORT PVRSRV_ERROR PVRSRVSwapToDCSystemKM(IMG_HANDLE hDeviceKM,
-							IMG_HANDLE hSwapChain);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVOpenBCDeviceKM(PVRSRV_PER_PROCESS_DATA *
-					      psPerProc,
-					      IMG_UINT32 ui32DeviceID,
-					      IMG_HANDLE hDevCookie,
-					      IMG_HANDLE * phDeviceKM);
-	 IMG_IMPORT PVRSRV_ERROR PVRSRVCloseBCDeviceKM(IMG_HANDLE hDeviceKM,
-						       IMG_BOOL
-						       bResManCallback);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVGetBCInfoKM(IMG_HANDLE hDeviceKM,
-					   BUFFER_INFO * psBufferInfo);
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVGetBCBufferKM(IMG_HANDLE hDeviceKM,
-					     IMG_UINT32 ui32BufferIndex,
-					     IMG_HANDLE * phBuffer);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVMapDeviceClassMemoryKM(PVRSRV_PER_PROCESS_DATA * psPerProc,
-					 IMG_HANDLE hDeviceClassBuffer,
-					 PVRSRV_KERNEL_MEM_INFO ** ppsMemInfo,
-					 IMG_HANDLE * phOSMapInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVUnmapDeviceClassMemoryKM(PVRSRV_KERNEL_MEM_INFO * psMemInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVGetFreeDeviceMemKM(IMG_UINT32
-							       ui32Flags,
-							       IMG_UINT32 *
-							       pui32Total,
-							       IMG_UINT32 *
-							       pui32Free,
-							       IMG_UINT32 *
-							       pui32LargestBlock);
-	 IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocSyncInfoKM(IMG_HANDLE
-								    hDevCookie,
-								    IMG_HANDLE
-								    hDevMemContext,
-								    PVRSRV_KERNEL_SYNC_INFO
-								    **
-								    ppsKernelSyncInfo);
-	 IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVFreeSyncInfoKM(PVRSRV_KERNEL_SYNC_INFO * psKernelSyncInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVGetMiscInfoKM(PVRSRV_MISC_INFO *
-							  psMiscInfo);
-
-	PVRSRV_ERROR PVRSRVGetFBStatsKM(IMG_UINT32 * pui32Total,
-					IMG_UINT32 * pui32Available);
-
-	IMG_IMPORT PVRSRV_ERROR
-	    PVRSRVAllocSharedSysMemoryKM(PVRSRV_PER_PROCESS_DATA * psPerProc,
-					 IMG_UINT32 ui32Flags,
-					 IMG_UINT32 ui32Size,
-					 PVRSRV_KERNEL_MEM_INFO **
-					 ppsKernelMemInfo);
-
-	IMG_IMPORT PVRSRV_ERROR
-	    PVRSRVFreeSharedSysMemoryKM(PVRSRV_KERNEL_MEM_INFO *
-					psKernelMemInfo);
-
-	IMG_IMPORT PVRSRV_ERROR
-	    PVRSRVDissociateMemFromResmanKM(PVRSRV_KERNEL_MEM_INFO *
-					    psKernelMemInfo);
+long PVRSRV_BridgeDispatchKM(struct file *file, unsigned int cmd,
+			     unsigned long arg);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/pvr_debug.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/pvr_debug.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -28,8 +28,8 @@
 #include <linux/config.h>
 #endif
 
-#include <asm/io.h>
-#include <asm/uaccess.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/tty.h>
@@ -40,24 +40,24 @@
 
 #if defined(DEBUG) || defined(TIMING)
 
-IMG_UINT32 gPVRDebugLevel = DBGPRIV_WARNING;
+u32 gPVRDebugLevel = DBGPRIV_WARNING;
 
 #define PVR_STRING_TERMINATOR		'\0'
-#define PVR_IS_FILE_SEPARATOR(character) ( ((character) == '\\') || ((character) == '/') )
+#define PVR_IS_FILE_SEPARATOR(character) \
+	(((character) == '\\') || ((character) == '/'))
 
-void PVRSRVDebugPrintf(IMG_UINT32 ui32DebugLevel,
-		       const IMG_CHAR * pszFileName,
-		       IMG_UINT32 ui32Line, const IMG_CHAR * pszFormat, ...
+void PVRSRVDebugPrintf(u32 ui32DebugLevel,
+		       const char *pszFileName,
+		       u32 ui32Line, const char *pszFormat, ...
     )
 {
 	IMG_BOOL bTrace, bDebug;
-	IMG_CHAR *pszLeafName;
+	char *pszLeafName;
 
 	pszLeafName = (char *)strrchr(pszFileName, '\\');
 
-	if (pszLeafName) {
+	if (pszLeafName)
 		pszFileName = pszLeafName;
-	}
 
 	bTrace = gPVRDebugLevel & ui32DebugLevel & DBGPRIV_CALLTRACE;
 	bDebug = ((gPVRDebugLevel & DBGPRIV_ALLLEVELS) >= ui32DebugLevel);
@@ -108,10 +108,9 @@
 
 		vsprintf(&szBuffer[strlen(szBuffer)], pszFormat, vaArgs);
 
-		if (!bTrace) {
+		if (!bTrace)
 			sprintf(&szBuffer[strlen(szBuffer)], " [%d, %s]",
 				(int)ui32Line, pszFileName);
-		}
 
 		printk(KERN_INFO "%s\n", szBuffer);
 
@@ -119,17 +118,17 @@
 	}
 }
 
-void PVRSRVDebugAssertFail(const IMG_CHAR * pszFile, IMG_UINT32 uLine)
+void PVRSRVDebugAssertFail(const char *pszFile, u32 uLine)
 {
 	PVRSRVDebugPrintf(DBGPRIV_FATAL, pszFile, uLine,
 			  "Debug assertion failed!");
 	BUG();
 }
 
-void PVRSRVTrace(const IMG_CHAR * pszFormat, ...)
+void PVRSRVTrace(const char *pszFormat, ...)
 {
-	static IMG_CHAR szMessage[PVR_MAX_DEBUG_MESSAGE_LEN + 1];
-	IMG_CHAR *pszEndOfMessage = IMG_NULL;
+	static char szMessage[PVR_MAX_DEBUG_MESSAGE_LEN + 1];
+	char *pszEndOfMessage = NULL;
 	va_list ArgList;
 
 	strncpy(szMessage, "PVR: ", PVR_MAX_DEBUG_MESSAGE_LEN);
@@ -145,7 +144,7 @@
 	printk(KERN_INFO "%s", szMessage);
 }
 
-void PVRDebugSetLevel(IMG_UINT32 uDebugLevel)
+void PVRDebugSetLevel(u32 uDebugLevel)
 {
 	printk(KERN_INFO "PVR: Setting Debug Level = 0x%x\n",
 	       (unsigned int)uDebugLevel);
@@ -153,7 +152,7 @@
 	gPVRDebugLevel = uDebugLevel;
 }
 
-int PVRDebugProcSetLevel(struct file *file, const char *buffer,
+int PVRDebugProcSetLevel(struct file *file, const char __user *buffer,
 			 unsigned long count, void *data)
 {
 #define	_PROC_SET_BUFFER_SZ		2
@@ -168,7 +167,7 @@
 			return -EINVAL;
 		PVRDebugSetLevel(data_buffer[0] - '0');
 	}
-	return (count);
+	return count;
 }
 
 int PVRDebugProcGetLevel(char *page, char **start, off_t off, int count,
@@ -176,7 +175,7 @@
 {
 	if (off == 0) {
 		*start = (char *)1;
-		return printAppend(page, count, 0, "%lu\n", gPVRDebugLevel);
+		return printAppend(page, count, 0, "%u\n", gPVRDebugLevel);
 	}
 	*eof = 1;
 	return 0;
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/pvr_debug.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/pvr_debug.h
@@ -1,36 +1,38 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef __PVR_DEBUG_H__
 #define __PVR_DEBUG_H__
 
+#include <linux/file.h>
+
 #include "img_types.h"
 
 
-#define PVR_MAX_DEBUG_MESSAGE_LEN	(512)
+#define PVR_MAX_DEBUG_MESSAGE_LEN	512
 
 #define DBGPRIV_FATAL		0x01
 #define DBGPRIV_ERROR		0x02
@@ -39,60 +41,60 @@
 #define DBGPRIV_VERBOSE		0x10
 #define DBGPRIV_CALLTRACE	0x20
 #define DBGPRIV_ALLOC		0x40
-#define DBGPRIV_ALLLEVELS	(DBGPRIV_FATAL | DBGPRIV_ERROR | DBGPRIV_WARNING | DBGPRIV_MESSAGE | DBGPRIV_VERBOSE)
-
-#define PVR_DBG_FATAL		DBGPRIV_FATAL,__FILE__, __LINE__
-#define PVR_DBG_ERROR		DBGPRIV_ERROR,__FILE__, __LINE__
-#define PVR_DBG_WARNING		DBGPRIV_WARNING,__FILE__, __LINE__
-#define PVR_DBG_MESSAGE		DBGPRIV_MESSAGE,__FILE__, __LINE__
-#define PVR_DBG_VERBOSE		DBGPRIV_VERBOSE,__FILE__, __LINE__
-#define PVR_DBG_CALLTRACE	DBGPRIV_CALLTRACE,__FILE__, __LINE__
-#define PVR_DBG_ALLOC		DBGPRIV_ALLOC,__FILE__, __LINE__
+#define DBGPRIV_ALLLEVELS	(DBGPRIV_FATAL | DBGPRIV_ERROR | \
+				 DBGPRIV_WARNING | DBGPRIV_MESSAGE | \
+				 DBGPRIV_VERBOSE)
+
+#define PVR_DBG_FATAL		DBGPRIV_FATAL
+#define PVR_DBG_ERROR		DBGPRIV_ERROR
+#define PVR_DBG_WARNING		DBGPRIV_WARNING
+#define PVR_DBG_MESSAGE		DBGPRIV_MESSAGE
+#define PVR_DBG_VERBOSE		DBGPRIV_VERBOSE
+#define PVR_DBG_CALLTRACE	DBGPRIV_CALLTRACE
+#define PVR_DBG_ALLOC		DBGPRIV_ALLOC
 
 #if defined(DEBUG)
-#define PVR_ASSERT(EXPR) if (!(EXPR)) PVRSRVDebugAssertFail(__FILE__, __LINE__);
-
-#define PVR_DPF(X)		PVRSRVDebugPrintf X
-#define PVR_TRACE(X)	PVRSRVTrace X
-
-	IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVDebugAssertFail(const IMG_CHAR *
-							       pszFile,
-							       IMG_UINT32
-							       ui32Line);
-
-	IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVDebugPrintf(IMG_UINT32
-							   ui32DebugLevel,
-							   const IMG_CHAR *
-							   pszFileName,
-							   IMG_UINT32 ui32Line,
-							   const IMG_CHAR *
-							   pszFormat, ...);
-
-	IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVTrace(const IMG_CHAR * pszFormat,
-						     ...);
-
-	IMG_VOID PVRSRVDebugSetLevel(IMG_UINT32 uDebugLevel);
+#define PVR_ASSERT(EXPR)						\
+	do {								\
+		if (!(EXPR))						\
+			PVRSRVDebugAssertFail(__FILE__, __LINE__);	\
+	} while (0)
+
+#define PVR_DPF(level, fmt, ...)				\
+	PVRSRVDebugPrintf(level, __FILE__, __LINE__, fmt, ## __VA_ARGS__)
+#define PVR_TRACE(fmt, ...)	PVRSRVTrace(fmt, ## __VA_ARGS__)
+
+extern u32 gPVRDebugLevel;
+
+void PVRSRVDebugAssertFail(const char *pszFile, u32 ui32Line);
+void PVRSRVDebugPrintf(u32 ui32DebugLevel, const char *pszFileName,
+		       u32 ui32Line, const char *pszFormat, ...);
+void PVRSRVTrace(const char *pszFormat, ...);
+void PVRDebugSetLevel(u32 uDebugLevel);
+int PVRDebugProcSetLevel(struct file *file, const char __user *buffer,
+			 unsigned long count, void *data);
+int PVRDebugProcGetLevel(char *page, char **start, off_t off, int count,
+			 int *eof, void *data);
 
-#define PVR_DBG_BREAK
+#define PVR_DBG_BREAK		do { } while (0)
 
 #else
 
 #if defined(TIMING)
 
-#define PVR_ASSERT(EXPR)
-#define PVR_DPF(X)
-#define PVR_TRACE(X)	PVRSRVTrace X
-#define PVR_DBG_BREAK
+#define PVR_ASSERT(EXPR)		do { } while (0)
+#define PVR_DPF(level, fmt, ...)	do { } while (0)
+#define PVR_TRACE(fmt, ...)		PVRSRVTrace(fmt, ## __VA_ARGS__)
+#define PVR_DBG_BREAK		do { } while (0)
 
-	IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVTrace(const IMG_CHAR * pszFormat,
-						     ...);
+void PVRSRVTrace(const char *pszFormat, ...);
 
 #else
 
-#define PVR_ASSERT(EXPR)
-#define PVR_DPF(X)
-#define PVR_TRACE(X)
-#define PVR_DBG_BREAK
+#define PVR_ASSERT(EXPR)		do { } while (0)
+#define PVR_DPF(level, fmt, ...)	do { } while (0)
+#define PVR_TRACE(fmt, ...)		do { } while (0)
+#define PVR_DBG_BREAK			do { } while (0)
 
 #endif
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/pvrconfig.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/pvrconfig.h
@@ -5,13 +5,13 @@
 #define SGX_CORE_REV			121
 
 #ifdef CONFIG_PVR_DEBUG
-# define PVR_BUILD_TYPE		"debug"
-# define DEBUG			1
+# define PVR_BUILD_TYPE			"debug"
+# define DEBUG				1
 #elif defined(CONFIG_PVR_TIMING)
-# define PVR_BUILD_TYPE		"timing"
-# define TIMING			1
+# define PVR_BUILD_TYPE			"timing"
+# define TIMING				1
 #elif defined(CONFIG_PVR_RELEASE)
-# define PVR_BUILD_TYPE		"release"
+# define PVR_BUILD_TYPE			"release"
 #endif
 
 #ifdef DEBUG
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/pvrmmap.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/pvrmmap.h
@@ -1,36 +1,34 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef __PVRMMAP_H__
 #define __PVRMMAP_H__
 
-PVRSRV_ERROR PVRMMAPMapKernelPtr(IMG_HANDLE hModule, IMG_VOID ** ppvLinAddr,
-				 IMG_VOID * pvKVIndexAddress,
-				 IMG_UINT32 ui32Bytes);
-
-IMG_BOOL PVRMMAPRemoveMapping(IMG_VOID * pvUserAddress, IMG_UINT32 ui32Bytes);
+enum PVRSRV_ERROR PVRMMAPMapKernelPtr(void *hModule, void **ppvLinAddr,
+				 void *pvKVIndexAddress, u32 ui32Bytes);
+IMG_BOOL PVRMMAPRemoveMapping(void *pvUserAddress, u32 ui32Bytes);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/pvrmodule.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/pvrmodule.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/pvrsrv.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/pvrsrv.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -30,11 +30,12 @@
 #include "perproc.h"
 #include "pdump_km.h"
 #include "ra.h"
+#include "pvr_bridge_km.h"
 
-PVRSRV_ERROR AllocateDeviceID(SYS_DATA * psSysData, IMG_UINT32 * pui32DevID)
+enum PVRSRV_ERROR AllocateDeviceID(struct SYS_DATA *psSysData, u32 *pui32DevID)
 {
-	SYS_DEVICE_ID *psDeviceWalker;
-	SYS_DEVICE_ID *psDeviceEnd;
+	struct SYS_DEVICE_ID *psDeviceWalker;
+	struct SYS_DEVICE_ID *psDeviceEnd;
 
 	psDeviceWalker = &psSysData->sDeviceID[0];
 	psDeviceEnd = psDeviceWalker + psSysData->ui32NumDevices;
@@ -48,18 +49,18 @@
 		psDeviceWalker++;
 	}
 
-	PVR_DPF((PVR_DBG_ERROR,
-		 "AllocateDeviceID: No free and valid device IDs available!"));
+	PVR_DPF(PVR_DBG_ERROR,
+		 "AllocateDeviceID: No free and valid device IDs available!");
 
 	PVR_ASSERT(psDeviceWalker < psDeviceEnd);
 
 	return PVRSRV_ERROR_GENERIC;
 }
 
-PVRSRV_ERROR FreeDeviceID(SYS_DATA * psSysData, IMG_UINT32 ui32DevID)
+enum PVRSRV_ERROR FreeDeviceID(struct SYS_DATA *psSysData, u32 ui32DevID)
 {
-	SYS_DEVICE_ID *psDeviceWalker;
-	SYS_DEVICE_ID *psDeviceEnd;
+	struct SYS_DEVICE_ID *psDeviceWalker;
+	struct SYS_DEVICE_ID *psDeviceEnd;
 
 	psDeviceWalker = &psSysData->sDeviceID[0];
 	psDeviceEnd = psDeviceWalker + psSysData->ui32NumDevices;
@@ -75,80 +76,45 @@
 		psDeviceWalker++;
 	}
 
-	PVR_DPF((PVR_DBG_ERROR,
-		 "FreeDeviceID: no matching dev ID that is in use!"));
+	PVR_DPF(PVR_DBG_ERROR,
+		 "FreeDeviceID: no matching dev ID that is in use!");
 
 	PVR_ASSERT(psDeviceWalker < psDeviceEnd);
 
 	return PVRSRV_ERROR_GENERIC;
 }
 
-IMG_EXPORT
-    IMG_UINT32 ReadHWReg(IMG_PVOID pvLinRegBaseAddr, IMG_UINT32 ui32Offset)
+enum PVRSRV_ERROR PVRSRVEnumerateDevicesKM(u32 *pui32NumDevices,
+			       struct PVRSRV_DEVICE_IDENTIFIER *psDevIdList)
 {
-	return *(volatile IMG_UINT32 *)((IMG_UINT32) pvLinRegBaseAddr +
-					ui32Offset);
-}
-
-IMG_EXPORT
-    IMG_VOID WriteHWReg(IMG_PVOID pvLinRegBaseAddr, IMG_UINT32 ui32Offset,
-			IMG_UINT32 ui32Value)
-{
-	PVR_DPF((PVR_DBG_MESSAGE, "WriteHWReg Base:%x, Offset: %x, Value %x",
-		 pvLinRegBaseAddr, ui32Offset, ui32Value));
-
-	*(IMG_UINT32 *) ((IMG_UINT32) pvLinRegBaseAddr + ui32Offset) =
-	    ui32Value;
-}
-
-IMG_EXPORT
-    IMG_VOID WriteHWRegs(IMG_PVOID pvLinRegBaseAddr, IMG_UINT32 ui32Count,
-			 PVRSRV_HWREG * psHWRegs)
-{
-	while (ui32Count--) {
-		WriteHWReg(pvLinRegBaseAddr, psHWRegs->ui32RegAddr,
-			   psHWRegs->ui32RegVal);
-		psHWRegs++;
-	}
-}
-
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVEnumerateDevicesKM(IMG_UINT32 *
-						       pui32NumDevices,
-						       PVRSRV_DEVICE_IDENTIFIER
-						       * psDevIdList)
-{
-	PVRSRV_ERROR eError;
-	SYS_DATA *psSysData;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	IMG_UINT32 i;
+	enum PVRSRV_ERROR eError;
+	struct SYS_DATA *psSysData;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	u32 i;
 
 	if (!pui32NumDevices || !psDevIdList) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVEnumerateDevicesKM: Invalid params"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVEnumerateDevicesKM: Invalid params");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	eError = SysAcquireData(&psSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVEnumerateDevicesKM: Failed to get SysData"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVEnumerateDevicesKM: Failed to get SysData");
 		return eError;
 	}
 
-	for (i = 0; i < PVRSRV_MAX_DEVICES; i++) {
+	for (i = 0; i < PVRSRV_MAX_DEVICES; i++)
 		psDevIdList[i].eDeviceType = PVRSRV_DEVICE_TYPE_UNKNOWN;
-	}
 
 	*pui32NumDevices = 0;
 
 	psDeviceNode = psSysData->psDeviceNodeList;
-	for (i = 0; psDeviceNode != IMG_NULL; i++) {
-
-		if (psDeviceNode->sDevId.eDeviceType != PVRSRV_DEVICE_TYPE_EXT) {
-
+	for (i = 0; psDeviceNode != NULL; i++) {
+		if (psDeviceNode->sDevId.eDeviceType !=
+		    PVRSRV_DEVICE_TYPE_EXT) {
 			*psDevIdList++ = psDeviceNode->sDevId;
-
 			(*pui32NumDevices)++;
 		}
 		psDeviceNode = psDeviceNode->psNext;
@@ -157,46 +123,40 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR IMG_CALLCONV PVRSRVInit(PSYS_DATA psSysData)
+enum PVRSRV_ERROR PVRSRVInit(struct SYS_DATA *psSysData)
 {
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
 	eError = ResManInit();
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		goto Error;
-	}
 
 	eError = PVRSRVPerProcessDataInit();
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		goto Error;
-	}
 
 	eError = PVRSRVHandleInit();
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		goto Error;
-	}
 
 	eError = OSCreateResource(&psSysData->sPowerStateChangeResource);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		goto Error;
-	}
 
 	gpsSysData->eCurrentPowerState = PVRSRV_POWER_STATE_D0;
 	gpsSysData->eFailedPowerState = PVRSRV_POWER_Unspecified;
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(PVRSRV_EVENTOBJECT),
-		       (IMG_VOID **) & psSysData->psGlobalEventObject,
-		       0) != PVRSRV_OK) {
+		       sizeof(struct PVRSRV_EVENTOBJECT),
+		       (void **) &psSysData->psGlobalEventObject,
+		       NULL) != PVRSRV_OK)
 
 		goto Error;
-	}
 
 	if (OSEventObjectCreate
 	    ("PVRSRV_GLOBAL_EVENTOBJECT",
-	     psSysData->psGlobalEventObject) != PVRSRV_OK) {
+	     psSysData->psGlobalEventObject) != PVRSRV_OK)
 		goto Error;
-	}
 
 	return eError;
 
@@ -205,59 +165,59 @@
 	return eError;
 }
 
-IMG_VOID IMG_CALLCONV PVRSRVDeInit(PSYS_DATA psSysData)
+void PVRSRVDeInit(struct SYS_DATA *psSysData)
 {
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
 	PVR_UNREFERENCED_PARAMETER(psSysData);
 
 	if (psSysData->psGlobalEventObject) {
 		OSEventObjectDestroy(psSysData->psGlobalEventObject);
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  sizeof(PVRSRV_EVENTOBJECT),
-			  psSysData->psGlobalEventObject, 0);
+			  sizeof(struct PVRSRV_EVENTOBJECT),
+			  psSysData->psGlobalEventObject, NULL);
 	}
 
 	eError = PVRSRVHandleDeInit();
-	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVDeInit: PVRSRVHandleDeInit failed"));
-	}
+	if (eError != PVRSRV_OK)
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVDeInit: PVRSRVHandleDeInit failed");
 
 	eError = PVRSRVPerProcessDataDeInit();
-	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVDeInit: PVRSRVPerProcessDataDeInit failed"));
-	}
+	if (eError != PVRSRV_OK)
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVDeInit: PVRSRVPerProcessDataDeInit failed");
 
 	ResManDeInit();
 }
 
-PVRSRV_ERROR IMG_CALLCONV PVRSRVRegisterDevice(PSYS_DATA psSysData,
-					       PVRSRV_ERROR(*pfnRegisterDevice)
-					       (PVRSRV_DEVICE_NODE *),
-					       IMG_UINT32 ui32SOCInterruptBit,
-					       IMG_UINT32 * pui32DeviceIndex)
+enum PVRSRV_ERROR PVRSRVRegisterDevice(struct SYS_DATA *psSysData,
+				  enum PVRSRV_ERROR(*pfnRegisterDevice)
+				  (struct PVRSRV_DEVICE_NODE *),
+				  u32 ui32SOCInterruptBit,
+				  u32 *pui32DeviceIndex)
 {
-	PVRSRV_ERROR eError;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
 
 	if (OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-		       sizeof(PVRSRV_DEVICE_NODE),
-		       (IMG_VOID **) & psDeviceNode, IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRegisterDevice : Failed to alloc memory for psDeviceNode"));
-		return (PVRSRV_ERROR_OUT_OF_MEMORY);
+		       sizeof(struct PVRSRV_DEVICE_NODE),
+		       (void **) &psDeviceNode, NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVRegisterDevice : "
+					"Failed to alloc memory for "
+					"psDeviceNode");
+		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
-	OSMemSet(psDeviceNode, 0, sizeof(PVRSRV_DEVICE_NODE));
+	OSMemSet(psDeviceNode, 0, sizeof(struct PVRSRV_DEVICE_NODE));
 
 	eError = pfnRegisterDevice(psDeviceNode);
 	if (eError != PVRSRV_OK) {
 		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-			  sizeof(PVRSRV_DEVICE_NODE), psDeviceNode, IMG_NULL);
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRegisterDevice : Failed to register device"));
-		return (PVRSRV_ERROR_DEVICE_REGISTER_FAILED);
+			  sizeof(struct PVRSRV_DEVICE_NODE), psDeviceNode,
+			  NULL);
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVRegisterDevice : Failed to register device");
+		return PVRSRV_ERROR_DEVICE_REGISTER_FAILED;
 	}
 
 	psDeviceNode->ui32RefCount = 1;
@@ -274,50 +234,49 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR IMG_CALLCONV PVRSRVInitialiseDevice(IMG_UINT32 ui32DevIndex)
+enum PVRSRV_ERROR PVRSRVInitialiseDevice(u32 ui32DevIndex)
 {
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	SYS_DATA *psSysData;
-	PVRSRV_ERROR eError;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct SYS_DATA *psSysData;
+	enum PVRSRV_ERROR eError;
 
-	PVR_DPF((PVR_DBG_MESSAGE, "PVRSRVInitialiseDevice"));
+	PVR_DPF(PVR_DBG_MESSAGE, "PVRSRVInitialiseDevice");
 
 	eError = SysAcquireData(&psSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVInitialiseDevice: Failed to get SysData"));
-		return (eError);
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVInitialiseDevice: Failed to get SysData");
+		return eError;
 	}
 
 	psDeviceNode = psSysData->psDeviceNodeList;
 
 	while (psDeviceNode) {
-		if (psDeviceNode->sDevId.ui32DeviceIndex == ui32DevIndex) {
+		if (psDeviceNode->sDevId.ui32DeviceIndex == ui32DevIndex)
 			goto FoundDevice;
-		}
 		psDeviceNode = psDeviceNode->psNext;
 	}
 
-	PVR_DPF((PVR_DBG_ERROR,
-		 "PVRSRVInitialiseDevice: requested device is not present"));
+	PVR_DPF(PVR_DBG_ERROR,
+		 "PVRSRVInitialiseDevice: requested device is not present");
 	return PVRSRV_ERROR_INIT_FAILURE;
 
 FoundDevice:
 
 	PVR_ASSERT(psDeviceNode->ui32RefCount > 0);
 
-	eError = PVRSRVResManConnect(IMG_NULL, &psDeviceNode->hResManContext);
+	eError = PVRSRVResManConnect(NULL, &psDeviceNode->hResManContext);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVInitialiseDevice: Failed PVRSRVResManConnect call"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVInitialiseDevice: "
+			 "Failed PVRSRVResManConnect call");
 		return eError;
 	}
 
-	if (psDeviceNode->pfnInitDevice != IMG_NULL) {
+	if (psDeviceNode->pfnInitDevice != NULL) {
 		eError = psDeviceNode->pfnInitDevice(psDeviceNode);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVInitialiseDevice: Failed InitDevice call"));
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVInitialiseDevice: "
+				"Failed InitDevice call");
 			return eError;
 		}
 	}
@@ -325,27 +284,26 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR IMG_CALLCONV PVRSRVFinaliseSystem(IMG_BOOL bInitSuccessful)
+enum PVRSRV_ERROR PVRSRVFinaliseSystem(IMG_BOOL bInitSuccessful)
 {
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	SYS_DATA *psSysData;
-	PVRSRV_ERROR eError;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct SYS_DATA *psSysData;
+	enum PVRSRV_ERROR eError;
 
-	PVR_DPF((PVR_DBG_MESSAGE, "PVRSRVFinaliseSystem"));
+	PVR_DPF(PVR_DBG_MESSAGE, "PVRSRVFinaliseSystem");
 
 	eError = SysAcquireData(&psSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVFinaliseSystem: Failed to get SysData"));
-		return (eError);
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVFinaliseSystem: "
+			"Failed to get SysData");
+		return eError;
 	}
 
 	if (bInitSuccessful) {
 		eError = SysFinalise();
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVFinaliseSystem: SysFinalise failed (%d)",
-				 eError));
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVFinaliseSystem: "
+				"SysFinalise failed (%d)", eError);
 			return eError;
 		}
 
@@ -353,14 +311,14 @@
 		while (psDeviceNode) {
 			eError =
 			    PVRSRVSetDevicePowerStateKM(psDeviceNode->sDevId.
-							ui32DeviceIndex,
-							PVRSRV_POWER_Unspecified,
-							KERNEL_ID, IMG_FALSE);
-			if (eError != PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "PVRSRVFinaliseSystem: Failed PVRSRVSetDevicePowerStateKM call (device index: %d)",
-					 psDeviceNode->sDevId.ui32DeviceIndex));
-			}
+						ui32DeviceIndex,
+						PVRSRV_POWER_Unspecified,
+						KERNEL_ID, IMG_FALSE);
+			if (eError != PVRSRV_OK)
+				PVR_DPF(PVR_DBG_ERROR, "PVRSRVFinaliseSystem: "
+				"Failed PVRSRVSetDevicePowerStateKM call "
+				"(device index: %d)",
+				 psDeviceNode->sDevId.ui32DeviceIndex);
 			psDeviceNode = psDeviceNode->psNext;
 		}
 	}
@@ -370,72 +328,65 @@
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVAcquireDeviceDataKM(IMG_UINT32 ui32DevIndex,
-							PVRSRV_DEVICE_TYPE
-							eDeviceType,
-							IMG_HANDLE *
-							phDevCookie)
-{
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	SYS_DATA *psSysData;
-	PVRSRV_ERROR eError;
+enum PVRSRV_ERROR PVRSRVAcquireDeviceDataKM(u32 ui32DevIndex,
+				enum PVRSRV_DEVICE_TYPE eDeviceType,
+				void **phDevCookie)
+{
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct SYS_DATA *psSysData;
+	enum PVRSRV_ERROR eError;
 
-	PVR_DPF((PVR_DBG_MESSAGE, "PVRSRVAcquireDeviceDataKM"));
+	PVR_DPF(PVR_DBG_MESSAGE, "PVRSRVAcquireDeviceDataKM");
 
 	eError = SysAcquireData(&psSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVAcquireDeviceDataKM: Failed to get SysData"));
-		return (eError);
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVAcquireDeviceDataKM: Failed to get SysData");
+		return eError;
 	}
 
 	psDeviceNode = psSysData->psDeviceNodeList;
 
-	if (eDeviceType != PVRSRV_DEVICE_TYPE_UNKNOWN) {
+	if (eDeviceType != PVRSRV_DEVICE_TYPE_UNKNOWN)
 		while (psDeviceNode) {
-			if (psDeviceNode->sDevId.eDeviceType == eDeviceType) {
+			if (psDeviceNode->sDevId.eDeviceType == eDeviceType)
 				goto FoundDevice;
-			}
 			psDeviceNode = psDeviceNode->psNext;
 		}
-	} else {
+	else
 		while (psDeviceNode) {
 			if (psDeviceNode->sDevId.ui32DeviceIndex ==
-			    ui32DevIndex) {
+			    ui32DevIndex)
 				goto FoundDevice;
-			}
 			psDeviceNode = psDeviceNode->psNext;
 		}
-	}
 
-	PVR_DPF((PVR_DBG_ERROR,
-		 "PVRSRVAcquireDeviceDataKM: requested device is not present"));
+	PVR_DPF(PVR_DBG_ERROR,
+		 "PVRSRVAcquireDeviceDataKM: requested device is not present");
 	return PVRSRV_ERROR_INIT_FAILURE;
 
 FoundDevice:
 
 	PVR_ASSERT(psDeviceNode->ui32RefCount > 0);
 
-	if (phDevCookie) {
-		*phDevCookie = (IMG_HANDLE) psDeviceNode;
-	}
+	if (phDevCookie)
+		*phDevCookie = (void *) psDeviceNode;
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR IMG_CALLCONV PVRSRVDeinitialiseDevice(IMG_UINT32 ui32DevIndex)
+enum PVRSRV_ERROR PVRSRVDeinitialiseDevice(u32 ui32DevIndex)
 {
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	PVRSRV_DEVICE_NODE **ppsDevNode;
-	SYS_DATA *psSysData;
-	PVRSRV_ERROR eError;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct PVRSRV_DEVICE_NODE **ppsDevNode;
+	struct SYS_DATA *psSysData;
+	enum PVRSRV_ERROR eError;
 
 	eError = SysAcquireData(&psSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVDeinitialiseDevice: Failed to get SysData"));
-		return (eError);
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVDeinitialiseDevice: Failed to get SysData");
+		return eError;
 	}
 
 	ppsDevNode = &psSysData->psDeviceNodeList;
@@ -447,9 +398,9 @@
 		ppsDevNode = &((*ppsDevNode)->psNext);
 	}
 
-	PVR_DPF((PVR_DBG_ERROR,
+	PVR_DPF(PVR_DBG_ERROR,
 		 "PVRSRVDeinitialiseDevice: requested device %d is not present",
-		 ui32DevIndex));
+		 ui32DevIndex);
 
 	return PVRSRV_ERROR_GENERIC;
 
@@ -459,59 +410,49 @@
 					     PVRSRV_POWER_STATE_D3,
 					     KERNEL_ID, IMG_FALSE);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVDeinitialiseDevice: Failed PVRSRVSetDevicePowerStateKM call"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVDeinitialiseDevice: "
+				"Failed PVRSRVSetDevicePowerStateKM call");
 		return eError;
 	}
 
-	eError = ResManFreeResByCriteria(psDeviceNode->hResManContext,
-					 RESMAN_CRITERIA_RESTYPE,
-					 RESMAN_TYPE_DEVICEMEM_ALLOCATION,
-					 IMG_NULL, 0);
-	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVDeinitialiseDevice: Failed ResManFreeResByCriteria call"));
-		return eError;
-	}
+	ResManFreeResByCriteria(psDeviceNode->hResManContext,
+			RESMAN_CRITERIA_RESTYPE,
+			RESMAN_TYPE_DEVICEMEM_ALLOCATION,
+			NULL, 0);
 
-	if (psDeviceNode->pfnDeInitDevice != IMG_NULL) {
+	if (psDeviceNode->pfnDeInitDevice != NULL) {
 		eError = psDeviceNode->pfnDeInitDevice(psDeviceNode);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVDeinitialiseDevice: Failed DeInitDevice call"));
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVDeinitialiseDevice: "
+				"Failed DeInitDevice call");
 			return eError;
 		}
 	}
 
 	PVRSRVResManDisconnect(psDeviceNode->hResManContext, IMG_TRUE);
-	psDeviceNode->hResManContext = IMG_NULL;
+	psDeviceNode->hResManContext = NULL;
 
 	*ppsDevNode = psDeviceNode->psNext;
 
 	FreeDeviceID(psSysData, ui32DevIndex);
-	OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, sizeof(PVRSRV_DEVICE_NODE),
-		  psDeviceNode, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+		  sizeof(struct PVRSRV_DEVICE_NODE), psDeviceNode, NULL);
 
-	return (PVRSRV_OK);
+	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PollForValueKM(volatile IMG_UINT32 *
-					     pui32LinMemAddr,
-					     IMG_UINT32 ui32Value,
-					     IMG_UINT32 ui32Mask,
-					     IMG_UINT32 ui32Waitus,
-					     IMG_UINT32 ui32Tries)
+enum PVRSRV_ERROR PollForValueKM(volatile u32 *pui32LinMemAddr,
+				 u32 ui32Value, u32 ui32Mask, u32 ui32Waitus,
+				 u32 ui32Tries)
 {
 	IMG_BOOL bStart = IMG_FALSE;
-	IMG_UINT32 uiStart = 0, uiCurrent = 0, uiMaxTime;
+	u32 uiStart = 0, uiCurrent = 0, uiMaxTime;
 
 	uiMaxTime = ui32Tries * ui32Waitus;
 
 	do {
-		if ((*pui32LinMemAddr & ui32Mask) == ui32Value) {
+		if ((*pui32LinMemAddr & ui32Mask) == ui32Value)
 			return PVRSRV_OK;
-		}
 
 		if (bStart == IMG_FALSE) {
 			bStart = IMG_TRUE;
@@ -521,10 +462,9 @@
 		OSWaitus(ui32Waitus);
 
 		uiCurrent = OSClockus();
-		if (uiCurrent < uiStart) {
+		if (uiCurrent < uiStart)
 
 			uiStart = 0;
-		}
 
 	} while ((uiCurrent - uiStart) < uiMaxTime);
 
@@ -532,34 +472,31 @@
 }
 
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVGetMiscInfoKM(PVRSRV_MISC_INFO * psMiscInfo)
+enum PVRSRV_ERROR PVRSRVGetMiscInfoKM(struct PVRSRV_MISC_INFO *psMiscInfo)
 {
-	SYS_DATA *psSysData;
-	PVRSRV_ERROR eError;
+	struct SYS_DATA *psSysData;
+	enum PVRSRV_ERROR eError;
 
 	if (!psMiscInfo) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVGetMiscInfoKM: invalid parameters"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVGetMiscInfoKM: invalid parameters");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
-	if (psMiscInfo->ui32StateRequest & ~(PVRSRV_MISC_INFO_TIMER_PRESENT
-					     |
-					     PVRSRV_MISC_INFO_CLOCKGATE_PRESENT
-					     | PVRSRV_MISC_INFO_MEMSTATS_PRESENT
-					     |
-					     PVRSRV_MISC_INFO_GLOBALEVENTOBJECT_PRESENT))
-	{
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVGetMiscInfoKM: invalid state request flags"));
+	if (psMiscInfo->ui32StateRequest &
+			~(PVRSRV_MISC_INFO_TIMER_PRESENT |
+			  PVRSRV_MISC_INFO_CLOCKGATE_PRESENT |
+			  PVRSRV_MISC_INFO_MEMSTATS_PRESENT |
+			  PVRSRV_MISC_INFO_GLOBALEVENTOBJECT_PRESENT)) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVGetMiscInfoKM: invalid state request flags");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	eError = SysAcquireData(&psSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVGetMiscInfoKM: Failed to get SysData"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVGetMiscInfoKM: Failed to get SysData");
 		return eError;
 	}
 
@@ -586,13 +523,13 @@
 
 	if ((psMiscInfo->ui32StateRequest & PVRSRV_MISC_INFO_MEMSTATS_PRESENT)
 	    && psMiscInfo->pszMemoryStr) {
-		RA_ARENA **ppArena;
-		BM_HEAP *psBMHeap;
-		BM_CONTEXT *psBMContext;
-		PVRSRV_DEVICE_NODE *psDeviceNode;
-		IMG_CHAR *pszStr;
-		IMG_UINT32 ui32StrLen;
-		IMG_INT32 i32Count;
+		struct RA_ARENA **ppArena;
+		struct BM_HEAP *psBMHeap;
+		struct BM_CONTEXT *psBMContext;
+		struct PVRSRV_DEVICE_NODE *psDeviceNode;
+		char *pszStr;
+		u32 ui32StrLen;
+		s32 i32Count;
 
 		pszStr = psMiscInfo->pszMemoryStr;
 		ui32StrLen = psMiscInfo->ui32MemoryStrLen;
@@ -631,18 +568,16 @@
 				    psDeviceNode->sDevMemoryInfo.
 				    pBMKernelContext->psBMHeap;
 				while (psBMHeap) {
-					if (psBMHeap->pImportArena) {
+					if (psBMHeap->pImportArena)
 						RA_GetStats(psBMHeap->
 							    pImportArena,
 							    &pszStr,
 							    &ui32StrLen);
-					}
 
-					if (psBMHeap->pVMArena) {
+					if (psBMHeap->pVMArena)
 						RA_GetStats(psBMHeap->pVMArena,
 							    &pszStr,
 							    &ui32StrLen);
-					}
 					psBMHeap = psBMHeap->psNext;
 				}
 			}
@@ -652,24 +587,23 @@
 				CHECK_SPACE(ui32StrLen);
 				i32Count =
 				    OSSNPrintf(pszStr, 100,
-					       "\nApplication Context (hDevMemContext) 0x%08X:\n",
-					       (IMG_HANDLE) psBMContext);
+						   "\nApplication Context "
+						   "(hDevMemContext) 0x%08X:\n",
+						   (void *)psBMContext);
 				UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 
 				psBMHeap = psBMContext->psBMHeap;
 				while (psBMHeap) {
-					if (psBMHeap->pImportArena) {
+					if (psBMHeap->pImportArena)
 						RA_GetStats(psBMHeap->
 							    pImportArena,
 							    &pszStr,
 							    &ui32StrLen);
-					}
 
-					if (psBMHeap->pVMArena) {
+					if (psBMHeap->pVMArena)
 						RA_GetStats(psBMHeap->pVMArena,
 							    &pszStr,
 							    &ui32StrLen);
-					}
 					psBMHeap = psBMHeap->psNext;
 				}
 				psBMContext = psBMContext->psNext;
@@ -681,9 +615,9 @@
 		UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 	}
 
-	if ((psMiscInfo->
-	     ui32StateRequest & PVRSRV_MISC_INFO_GLOBALEVENTOBJECT_PRESENT)
-	    && psSysData->psGlobalEventObject) {
+	if ((psMiscInfo->ui32StateRequest &
+		PVRSRV_MISC_INFO_GLOBALEVENTOBJECT_PRESENT) &&
+	    psSysData->psGlobalEventObject) {
 		psMiscInfo->ui32StatePresent |=
 		    PVRSRV_MISC_INFO_GLOBALEVENTOBJECT_PRESENT;
 		psMiscInfo->sGlobalEventObject =
@@ -693,11 +627,10 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR IMG_CALLCONV PVRSRVGetFBStatsKM(IMG_UINT32 * pui32Total,
-					     IMG_UINT32 * pui32Available)
+enum PVRSRV_ERROR PVRSRVGetFBStatsKM(u32 *pui32Total, u32 *pui32Available)
 {
-	IMG_UINT32 ui32Total = 0, i = 0;
-	IMG_UINT32 ui32Available = 0;
+	u32 ui32Total = 0, i = 0;
+	u32 ui32Available = 0;
 
 	*pui32Total = 0;
 	*pui32Available = 0;
@@ -713,25 +646,24 @@
 	return PVRSRV_OK;
 }
 
-IMG_BOOL IMG_CALLCONV PVRSRVDeviceLISR(PVRSRV_DEVICE_NODE * psDeviceNode)
+IMG_BOOL PVRSRVDeviceLISR(struct PVRSRV_DEVICE_NODE *psDeviceNode)
 {
-	SYS_DATA *psSysData;
+	struct SYS_DATA *psSysData;
 	IMG_BOOL bStatus = IMG_FALSE;
-	IMG_UINT32 ui32InterruptSource;
+	u32 ui32InterruptSource;
 
 	if (!psDeviceNode) {
-		PVR_DPF((PVR_DBG_ERROR, "PVRSRVDeviceLISR: Invalid params\n"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVDeviceLISR: Invalid params\n");
 		goto out;
 	}
 	psSysData = psDeviceNode->psSysData;
 
 	ui32InterruptSource = SysGetInterruptSource(psSysData, psDeviceNode);
 	if (ui32InterruptSource & psDeviceNode->ui32SOCInterruptBit) {
-		if (psDeviceNode->pfnDeviceISR != IMG_NULL) {
+		if (psDeviceNode->pfnDeviceISR != NULL)
 			bStatus =
 			    (*psDeviceNode->pfnDeviceISR) (psDeviceNode->
 							   pvISRData);
-		}
 
 		SysClearInterrupts(psSysData,
 				   psDeviceNode->ui32SOCInterruptBit);
@@ -741,40 +673,37 @@
 	return bStatus;
 }
 
-IMG_BOOL IMG_CALLCONV PVRSRVSystemLISR(IMG_VOID * pvSysData)
+IMG_BOOL PVRSRVSystemLISR(void *pvSysData)
 {
-	SYS_DATA *psSysData = pvSysData;
+	struct SYS_DATA *psSysData = pvSysData;
 	IMG_BOOL bStatus = IMG_FALSE;
-	IMG_UINT32 ui32InterruptSource;
-	IMG_UINT32 ui32ClearInterrupts = 0;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
+	u32 ui32InterruptSource;
+	u32 ui32ClearInterrupts = 0;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
 
 	if (!psSysData) {
-		PVR_DPF((PVR_DBG_ERROR, "PVRSRVSystemLISR: Invalid params\n"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVSystemLISR: Invalid params\n");
 		goto out;
 	}
 
-	ui32InterruptSource = SysGetInterruptSource(psSysData, IMG_NULL);
+	ui32InterruptSource = SysGetInterruptSource(psSysData, NULL);
 
-	if (ui32InterruptSource == 0) {
+	if (ui32InterruptSource == 0)
 		goto out;
-	}
 
 	psDeviceNode = psSysData->psDeviceNodeList;
-	while (psDeviceNode != IMG_NULL) {
-		if (psDeviceNode->pfnDeviceISR != IMG_NULL) {
+	while (psDeviceNode != NULL) {
+		if (psDeviceNode->pfnDeviceISR != NULL)
 			if (ui32InterruptSource & psDeviceNode->
 			    ui32SOCInterruptBit) {
 				if ((*psDeviceNode->
-				     pfnDeviceISR) (psDeviceNode->pvISRData)) {
+				     pfnDeviceISR) (psDeviceNode->pvISRData))
 
 					bStatus = IMG_TRUE;
-				}
 
 				ui32ClearInterrupts |=
 				    psDeviceNode->ui32SOCInterruptBit;
 			}
-		}
 		psDeviceNode = psDeviceNode->psNext;
 	}
 
@@ -784,95 +713,88 @@
 	return bStatus;
 }
 
-IMG_VOID IMG_CALLCONV PVRSRVMISR(IMG_VOID * pvSysData)
+void PVRSRVMISR(void *pvSysData)
 {
-	SYS_DATA *psSysData = pvSysData;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct SYS_DATA *psSysData = pvSysData;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
 
 	if (!psSysData) {
-		PVR_DPF((PVR_DBG_ERROR, "PVRSRVMISR: Invalid params\n"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVMISR: Invalid params\n");
 		return;
 	}
 
 	psDeviceNode = psSysData->psDeviceNodeList;
-	while (psDeviceNode != IMG_NULL) {
-		if (psDeviceNode->pfnDeviceMISR != IMG_NULL) {
+	while (psDeviceNode != NULL) {
+		if (psDeviceNode->pfnDeviceMISR != NULL)
 			(*psDeviceNode->pfnDeviceMISR) (psDeviceNode->
 							pvISRData);
-		}
 		psDeviceNode = psDeviceNode->psNext;
 	}
 
 	if (PVRSRVProcessQueues(ISR_ID, IMG_FALSE) ==
-	    PVRSRV_ERROR_PROCESSING_BLOCKED) {
+	    PVRSRV_ERROR_PROCESSING_BLOCKED)
 		PVRSRVProcessQueues(ISR_ID, IMG_FALSE);
-	}
 
 	if (psSysData->psGlobalEventObject) {
-		IMG_HANDLE hOSEventKM =
+		void *hOSEventKM =
 		    psSysData->psGlobalEventObject->hOSEventKM;
-		if (hOSEventKM) {
+		if (hOSEventKM)
 			OSEventObjectSignal(hOSEventKM);
-		}
 	}
 }
 
-IMG_EXPORT PVRSRV_ERROR IMG_CALLCONV PVRSRVProcessConnect(IMG_UINT32 ui32PID)
+enum PVRSRV_ERROR PVRSRVProcessConnect(u32 ui32PID)
 {
 	return PVRSRVPerProcessDataConnect(ui32PID);
 }
 
-IMG_EXPORT IMG_VOID IMG_CALLCONV PVRSRVProcessDisconnect(IMG_UINT32 ui32PID)
+void PVRSRVProcessDisconnect(u32 ui32PID)
 {
 	PVRSRVPerProcessDataDisconnect(ui32PID);
 }
 
-PVRSRV_ERROR IMG_CALLCONV PVRSRVSaveRestoreLiveSegments(IMG_HANDLE hArena,
-							IMG_PBYTE pbyBuffer,
-							IMG_UINT32 * puiBufSize,
-							IMG_BOOL bSave)
-{
-	IMG_UINT32 uiBytesSaved = 0;
-	IMG_PVOID pvLocalMemCPUVAddr;
-	RA_SEGMENT_DETAILS sSegDetails;
+enum PVRSRV_ERROR PVRSRVSaveRestoreLiveSegments(void *hArena, u8 *pbyBuffer,
+					   u32 *puiBufSize, IMG_BOOL bSave)
+{
+	u32 uiBytesSaved = 0;
+	void *pvLocalMemCPUVAddr;
+	struct RA_SEGMENT_DETAILS sSegDetails;
 
-	if (hArena == IMG_NULL) {
-		return (PVRSRV_ERROR_INVALID_PARAMS);
-	}
+	if (hArena == NULL)
+		return PVRSRV_ERROR_INVALID_PARAMS;
 
 	sSegDetails.uiSize = 0;
 	sSegDetails.sCpuPhyAddr.uiAddr = 0;
-	sSegDetails.hSegment = 0;
-
-	while (RA_GetNextLiveSegment(hArena, &sSegDetails)) {
-		if (pbyBuffer == IMG_NULL) {
+	sSegDetails.hSegment = NULL;
 
+	while (RA_GetNextLiveSegment(hArena, &sSegDetails))
+		if (pbyBuffer == NULL) {
 			uiBytesSaved +=
 			    sizeof(sSegDetails.uiSize) + sSegDetails.uiSize;
 		} else {
 			if ((uiBytesSaved + sizeof(sSegDetails.uiSize) +
-			     sSegDetails.uiSize) > *puiBufSize) {
-				return (PVRSRV_ERROR_OUT_OF_MEMORY);
-			}
+			     sSegDetails.uiSize) > *puiBufSize)
+				return PVRSRV_ERROR_OUT_OF_MEMORY;
 
-			PVR_DPF((PVR_DBG_MESSAGE,
-				 "PVRSRVSaveRestoreLiveSegments: Base %08x size %08x",
+			PVR_DPF(PVR_DBG_MESSAGE,
+				 "PVRSRVSaveRestoreLiveSegments: "
+				 "Base %08x size %08x",
 				 sSegDetails.sCpuPhyAddr.uiAddr,
-				 sSegDetails.uiSize));
+				 sSegDetails.uiSize);
 
-			pvLocalMemCPUVAddr =
+			pvLocalMemCPUVAddr = (void __force *)
 			    OSMapPhysToLin(sSegDetails.sCpuPhyAddr,
 					   sSegDetails.uiSize,
 					   PVRSRV_HAP_KERNEL_ONLY |
-					   PVRSRV_HAP_UNCACHED, IMG_NULL);
-			if (pvLocalMemCPUVAddr == IMG_NULL) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "PVRSRVSaveRestoreLiveSegments: Failed to map local memory to host"));
-				return (PVRSRV_ERROR_OUT_OF_MEMORY);
+					   PVRSRV_HAP_UNCACHED, NULL);
+			if (pvLocalMemCPUVAddr == NULL) {
+				PVR_DPF(PVR_DBG_ERROR,
+					 "PVRSRVSaveRestoreLiveSegments: "
+					 "Failed to map local memory to host");
+				return PVRSRV_ERROR_OUT_OF_MEMORY;
 			}
 
 			if (bSave) {
-
 				OSMemCopy(pbyBuffer, &sSegDetails.uiSize,
 					  sizeof(sSegDetails.uiSize));
 				pbyBuffer += sizeof(sSegDetails.uiSize);
@@ -881,14 +803,15 @@
 					  sSegDetails.uiSize);
 				pbyBuffer += sSegDetails.uiSize;
 			} else {
-				IMG_UINT32 uiSize;
+				u32 uiSize;
 
 				OSMemCopy(&uiSize, pbyBuffer,
 					  sizeof(sSegDetails.uiSize));
 
 				if (uiSize != sSegDetails.uiSize) {
-					PVR_DPF((PVR_DBG_ERROR,
-						 "PVRSRVSaveRestoreLiveSegments: Segment size error"));
+					PVR_DPF(PVR_DBG_ERROR,
+						"PVRSRVSaveRestoreLiveSegments:"
+						" Segment size error");
 				} else {
 					pbyBuffer += sizeof(sSegDetails.uiSize);
 
@@ -901,16 +824,15 @@
 			uiBytesSaved +=
 			    sizeof(sSegDetails.uiSize) + sSegDetails.uiSize;
 
-			OSUnMapPhysToLin(pvLocalMemCPUVAddr,
+			OSUnMapPhysToLin((void __force __iomem *)
+							pvLocalMemCPUVAddr,
 					 sSegDetails.uiSize,
 					 PVRSRV_HAP_KERNEL_ONLY |
-					 PVRSRV_HAP_UNCACHED, IMG_NULL);
+					 PVRSRV_HAP_UNCACHED, NULL);
 		}
-	}
 
-	if (pbyBuffer == IMG_NULL) {
+	if (pbyBuffer == NULL)
 		*puiBufSize = uiBytesSaved;
-	}
 
-	return (PVRSRV_OK);
+	return PVRSRV_OK;
 }
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/pvrversion.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/pvrversion.h
@@ -1,37 +1,37 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef _PVRVERSION_H_
 #define _PVRVERSION_H_
 
-#define PVRVERSION_MAJ 1
-#define PVRVERSION_MIN 3
-#define PVRVERSION_BRANCH 13
-#define PVRVERSION_BUILD 1607
-#define PVRVERSION_STRING "1.3.13.1607"
-#define PVRVERSION_FILE "eurasiacon.pj"
+#define	PVRVERSION_MAJ		1
+#define	PVRVERSION_MIN		3
+#define	PVRVERSION_BRANCH	13
+#define	PVRVERSION_BUILD	1607
+#define	PVRVERSION_STRING	"1.3.13.1607"
+#define	PVRVERSION_FILE		"eurasiacon.pj"
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/queue.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/queue.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -28,23 +28,23 @@
 
 #include "proc.h"
 
-static int
-QueuePrintCommands(PVRSRV_QUEUE_INFO * psQueue, char *buffer, size_t size)
+static int QueuePrintCommands(struct PVRSRV_QUEUE_INFO *psQueue, char *buffer,
+			      size_t size)
 {
 	off_t off = 0;
 	int cmds = 0;
-	IMG_UINT32 ui32ReadOffset = psQueue->ui32ReadOffset;
-	IMG_UINT32 ui32WriteOffset = psQueue->ui32WriteOffset;
-	PVRSRV_COMMAND *psCmd;
+	u32 ui32ReadOffset = psQueue->ui32ReadOffset;
+	u32 ui32WriteOffset = psQueue->ui32WriteOffset;
+	struct PVRSRV_COMMAND *psCmd;
 
 	while (ui32ReadOffset != ui32WriteOffset) {
 		psCmd =
-		    (PVRSRV_COMMAND *) ((IMG_UINT32) psQueue->pvLinQueueKM +
+		    (struct PVRSRV_COMMAND *)((u32) psQueue->pvLinQueueKM +
 					ui32ReadOffset);
 
 		off =
 		    printAppend(buffer, size, off,
-				"%p %p  %5lu  %6lu  %3lu  %5lu   %2lu   %2lu    %3lu  \n",
+			"%p %p  %5u  %6u  %3u  %5u   %2u   %2u    %3u  \n",
 				psQueue, psCmd, psCmd->ui32ProcessID,
 				psCmd->CommandType, psCmd->ui32CmdSize,
 				psCmd->ui32DevIndex, psCmd->ui32DstSyncCount,
@@ -61,38 +61,40 @@
 
 off_t QueuePrintQueues(char *buffer, size_t size, off_t off)
 {
-	SYS_DATA *psSysData;
-	PVRSRV_QUEUE_INFO *psQueue;
+	struct SYS_DATA *psSysData;
+	struct PVRSRV_QUEUE_INFO *psQueue;
 
 	if (SysAcquireData(&psSysData) != PVRSRV_OK)
 		return END_OF_FILE;
 
 	if (!off)
 		return printAppend(buffer, size, 0,
-				   "Command Queues\n"
-				   "Queue    CmdPtr      Pid Command Size DevInd  DSC  SSC  #Data ...\n");
+			"Command Queues\n"
+			"Queue    CmdPtr      Pid Command Size DevInd  "
+			"DSC  SSC  #Data ...\n");
 
 	for (psQueue = psSysData->psQueueList; --off && psQueue;
-	     psQueue = psQueue->psNextKM) ;
+	     psQueue = psQueue->psNextKM)
+		;
 
-	return psQueue ? QueuePrintCommands(psQueue, buffer,
-					    size) : END_OF_FILE;
+	return psQueue ?
+		QueuePrintCommands(psQueue, buffer, size) : END_OF_FILE;
 }
 
-#define GET_SPACE_IN_CMDQ(psQueue)										\
-	(((psQueue->ui32ReadOffset - psQueue->ui32WriteOffset)				\
-	+ (psQueue->ui32QueueSize - 1)) & (psQueue->ui32QueueSize - 1))
+#define GET_SPACE_IN_CMDQ(psQueue)					\
+	(((psQueue->ui32ReadOffset - psQueue->ui32WriteOffset) +	\
+	  (psQueue->ui32QueueSize - 1)) & (psQueue->ui32QueueSize - 1))
 
-#define UPDATE_QUEUE_WOFF(psQueue, ui32Size)							\
-	psQueue->ui32WriteOffset = (psQueue->ui32WriteOffset + ui32Size)	\
-	& (psQueue->ui32QueueSize - 1);
+#define UPDATE_QUEUE_WOFF(psQueue, ui32Size)				   \
+	psQueue->ui32WriteOffset = (psQueue->ui32WriteOffset + ui32Size) & \
+	(psQueue->ui32QueueSize - 1);
 
-#define SYNCOPS_STALE(ui32OpsComplete, ui32OpsPending)					\
+#define SYNCOPS_STALE(ui32OpsComplete, ui32OpsPending)			\
 	(ui32OpsComplete >= ui32OpsPending)
 
-IMG_UINT32 NearestPower2(IMG_UINT32 ui32Value)
+static u32 NearestPower2(u32 ui32Value)
 {
-	IMG_UINT32 ui32Temp, ui32Result = 1;
+	u32 ui32Temp, ui32Result = 1;
 
 	if (!ui32Value)
 		return 0;
@@ -106,31 +108,27 @@
 	return ui32Result;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateCommandQueueKM(IMG_UINT32
-							 ui32QueueSize,
-							 PVRSRV_QUEUE_INFO **
-							 ppsQueueInfo)
-{
-	PVRSRV_QUEUE_INFO *psQueueInfo;
-	IMG_UINT32 ui32Power2QueueSize = NearestPower2(ui32QueueSize);
-	SYS_DATA *psSysData;
-	PVRSRV_ERROR eError;
-	IMG_HANDLE hMemBlock;
+enum PVRSRV_ERROR PVRSRVCreateCommandQueueKM(u32 ui32QueueSize,
+				 struct PVRSRV_QUEUE_INFO **ppsQueueInfo)
+{
+	struct PVRSRV_QUEUE_INFO *psQueueInfo;
+	u32 ui32Power2QueueSize = NearestPower2(ui32QueueSize);
+	struct SYS_DATA *psSysData;
+	enum PVRSRV_ERROR eError;
+	void *hMemBlock;
 
 	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	if (OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-		       sizeof(PVRSRV_QUEUE_INFO),
-		       (IMG_VOID **) & psQueueInfo, &hMemBlock) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVCreateCommandQueueKM: Failed to alloc queue struct"));
+		       sizeof(struct PVRSRV_QUEUE_INFO),
+		       (void **) &psQueueInfo, &hMemBlock) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVCreateCommandQueueKM: "
+				"Failed to alloc queue struct");
 		goto ErrorExit;
 	}
-	OSMemSet(psQueueInfo, 0, sizeof(PVRSRV_QUEUE_INFO));
+	OSMemSet(psQueueInfo, 0, sizeof(struct PVRSRV_QUEUE_INFO));
 
 	psQueueInfo->hMemBlock[0] = hMemBlock;
 	psQueueInfo->ui32ProcessID = OSGetCurrentProcessIDKM();
@@ -138,8 +136,8 @@
 	if (OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 		       ui32Power2QueueSize + PVRSRV_MAX_CMD_SIZE,
 		       &psQueueInfo->pvLinQueueKM, &hMemBlock) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVCreateCommandQueueKM: Failed to alloc queue buffer"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVCreateCommandQueueKM: "
+				"Failed to alloc queue buffer");
 		goto ErrorExit;
 	}
 
@@ -151,25 +149,22 @@
 
 	psQueueInfo->ui32QueueSize = ui32Power2QueueSize;
 
-	if (psSysData->psQueueList == IMG_NULL) {
+	if (psSysData->psQueueList == NULL) {
 		eError = OSCreateResource(&psSysData->sQProcessResource);
-		if (eError != PVRSRV_OK) {
+		if (eError != PVRSRV_OK)
 			goto ErrorExit;
-		}
 	}
 
 	if (OSLockResource(&psSysData->sQProcessResource,
-			   KERNEL_ID) != PVRSRV_OK) {
+			   KERNEL_ID) != PVRSRV_OK)
 		goto ErrorExit;
-	}
 
 	psQueueInfo->psNextKM = psSysData->psQueueList;
 	psSysData->psQueueList = psQueueInfo;
 
 	if (OSUnlockResource(&psSysData->sQProcessResource, KERNEL_ID) !=
-	    PVRSRV_OK) {
+	    PVRSRV_OK)
 		goto ErrorExit;
-	}
 
 	*ppsQueueInfo = psQueueInfo;
 
@@ -178,41 +173,39 @@
 ErrorExit:
 
 	if (psQueueInfo) {
-		if (psQueueInfo->pvLinQueueKM) {
+		if (psQueueInfo->pvLinQueueKM)
 			OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 				  psQueueInfo->ui32QueueSize,
 				  psQueueInfo->pvLinQueueKM,
 				  psQueueInfo->hMemBlock[1]);
-		}
 
 		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-			  sizeof(PVRSRV_QUEUE_INFO),
+			  sizeof(struct PVRSRV_QUEUE_INFO),
 			  psQueueInfo, psQueueInfo->hMemBlock[0]);
 	}
 
 	return PVRSRV_ERROR_GENERIC;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroyCommandQueueKM(PVRSRV_QUEUE_INFO *
-							  psQueueInfo)
-{
-	PVRSRV_QUEUE_INFO *psQueue;
-	SYS_DATA *psSysData;
-	PVRSRV_ERROR eError;
+enum PVRSRV_ERROR PVRSRVDestroyCommandQueueKM(
+				struct PVRSRV_QUEUE_INFO *psQueueInfo)
+{
+	struct PVRSRV_QUEUE_INFO *psQueue;
+	struct SYS_DATA *psSysData;
+	enum PVRSRV_ERROR eError;
 	IMG_BOOL bTimeout = IMG_TRUE;
 	IMG_BOOL bStart = IMG_FALSE;
-	IMG_UINT32 uiStart = 0;
+	u32 uiStart = 0;
 
 	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	psQueue = psSysData->psQueueList;
 
 	do {
-		if (psQueueInfo->ui32ReadOffset == psQueueInfo->ui32WriteOffset) {
+		if (psQueueInfo->ui32ReadOffset ==
+		    psQueueInfo->ui32WriteOffset) {
 			bTimeout = IMG_FALSE;
 			break;
 		}
@@ -226,15 +219,14 @@
 
 	if (bTimeout) {
 
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVDestroyCommandQueueKM : Failed to empty queue"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVDestroyCommandQueueKM : "
+					"Failed to empty queue");
 		eError = PVRSRV_ERROR_CANNOT_FLUSH_QUEUE;
 	}
 
 	eError = OSLockResource(&psSysData->sQProcessResource, KERNEL_ID);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		goto ErrorExit;
-	}
 
 	if (psQueue == psQueueInfo) {
 		psSysData->psQueueList = psQueueInfo->psNextKM;
@@ -243,7 +235,7 @@
 			  psQueueInfo->ui32QueueSize,
 			  psQueueInfo->pvLinQueueKM, psQueueInfo->hMemBlock[1]);
 		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-			  sizeof(PVRSRV_QUEUE_INFO),
+			  sizeof(struct PVRSRV_QUEUE_INFO),
 			  psQueueInfo, psQueueInfo->hMemBlock[0]);
 	} else {
 		while (psQueue) {
@@ -255,7 +247,7 @@
 					  psQueueInfo->pvLinQueueKM,
 					  psQueueInfo->hMemBlock[1]);
 				OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-					  sizeof(PVRSRV_QUEUE_INFO),
+					  sizeof(struct PVRSRV_QUEUE_INFO),
 					  psQueueInfo,
 					  psQueueInfo->hMemBlock[0]);
 				break;
@@ -267,24 +259,21 @@
 			eError =
 			    OSUnlockResource(&psSysData->sQProcessResource,
 					     KERNEL_ID);
-			if (eError != PVRSRV_OK) {
+			if (eError != PVRSRV_OK)
 				goto ErrorExit;
-			}
 			eError = PVRSRV_ERROR_INVALID_PARAMS;
 			goto ErrorExit;
 		}
 	}
 
 	eError = OSUnlockResource(&psSysData->sQProcessResource, KERNEL_ID);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		goto ErrorExit;
-	}
 
-	if (psSysData->psQueueList == IMG_NULL) {
+	if (psSysData->psQueueList == NULL) {
 		eError = OSDestroyResource(&psSysData->sQProcessResource);
-		if (eError != PVRSRV_OK) {
+		if (eError != PVRSRV_OK)
 			goto ErrorExit;
-		}
 	}
 
 ErrorExit:
@@ -292,21 +281,19 @@
 	return eError;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVGetQueueSpaceKM(PVRSRV_QUEUE_INFO * psQueue,
-						    IMG_UINT32 ui32ParamSize,
-						    IMG_VOID ** ppvSpace)
+enum PVRSRV_ERROR PVRSRVGetQueueSpaceKM(struct PVRSRV_QUEUE_INFO *psQueue,
+				    u32 ui32ParamSize, void **ppvSpace)
 {
 	IMG_BOOL bTimeout = IMG_TRUE;
 	IMG_BOOL bStart = IMG_FALSE;
-	IMG_UINT32 uiStart = 0, uiCurrent = 0;
+	u32 uiStart = 0, uiCurrent = 0;
 
 	ui32ParamSize = (ui32ParamSize + 3) & 0xFFFFFFFC;
 
 	if (ui32ParamSize > PVRSRV_MAX_CMD_SIZE) {
-		PVR_DPF((PVR_DBG_WARNING,
+		PVR_DPF(PVR_DBG_WARNING,
 			 "PVRSRVGetQueueSpace: max command size is %d bytes",
-			 PVRSRV_MAX_CMD_SIZE));
+			 PVRSRV_MAX_CMD_SIZE);
 		return PVRSRV_ERROR_CMD_TOO_BIG;
 	}
 
@@ -323,57 +310,48 @@
 		OSWaitus(MAX_HW_TIME_US / WAIT_TRY_COUNT);
 
 		uiCurrent = OSClockus();
-		if (uiCurrent < uiStart) {
+		if (uiCurrent < uiStart)
 
 			uiStart = 0;
-		}
 	} while ((uiCurrent - uiStart) < MAX_HW_TIME_US);
 
 	if (bTimeout == IMG_TRUE) {
-		*ppvSpace = IMG_NULL;
+		*ppvSpace = NULL;
 
 		return PVRSRV_ERROR_CANNOT_GET_QUEUE_SPACE;
 	} else {
 		*ppvSpace =
-		    (IMG_VOID *) (psQueue->ui32WriteOffset +
-				  (IMG_UINT32) psQueue->pvLinQueueUM);
+		    (void *) (psQueue->ui32WriteOffset +
+				  (u32) psQueue->pvLinQueueUM);
 	}
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVInsertCommandKM(PVRSRV_QUEUE_INFO * psQueue,
-						    PVRSRV_COMMAND **
-						    ppsCommand,
-						    IMG_UINT32 ui32DevIndex,
-						    IMG_UINT16 CommandType,
-						    IMG_UINT32 ui32DstSyncCount,
-						    PVRSRV_KERNEL_SYNC_INFO *
-						    apsDstSync[],
-						    IMG_UINT32 ui32SrcSyncCount,
-						    PVRSRV_KERNEL_SYNC_INFO *
-						    apsSrcSync[],
-						    IMG_UINT32 ui32DataByteSize)
-{
-	PVRSRV_ERROR eError;
-	PVRSRV_COMMAND *psCommand;
-	IMG_UINT32 ui32CommandSize;
-	IMG_UINT32 i;
+enum PVRSRV_ERROR PVRSRVInsertCommandKM(struct PVRSRV_QUEUE_INFO *psQueue,
+				   struct PVRSRV_COMMAND **ppsCommand,
+				   u32 ui32DevIndex, u16 CommandType,
+				   u32 ui32DstSyncCount,
+				   struct PVRSRV_KERNEL_SYNC_INFO *apsDstSync[],
+				   u32 ui32SrcSyncCount,
+				   struct PVRSRV_KERNEL_SYNC_INFO *apsSrcSync[],
+				   u32 ui32DataByteSize)
+{
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_COMMAND *psCommand;
+	u32 ui32CommandSize;
+	u32 i;
 
 	ui32DataByteSize = (ui32DataByteSize + 3) & 0xFFFFFFFC;
 
-	ui32CommandSize = sizeof(PVRSRV_COMMAND)
-	    +
-	    ((ui32DstSyncCount + ui32SrcSyncCount) * sizeof(PVRSRV_SYNC_OBJECT))
-	    + ui32DataByteSize;
-
-	eError =
-	    PVRSRVGetQueueSpaceKM(psQueue, ui32CommandSize,
-				  (IMG_VOID **) & psCommand);
-	if (eError != PVRSRV_OK) {
+	ui32CommandSize = sizeof(struct PVRSRV_COMMAND) +
+	    ((ui32DstSyncCount + ui32SrcSyncCount) *
+	     sizeof(struct PVRSRV_SYNC_OBJECT)) + ui32DataByteSize;
+
+	eError = PVRSRVGetQueueSpaceKM(psQueue, ui32CommandSize,
+				  (void **) &psCommand);
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	psCommand->ui32ProcessID = OSGetCurrentProcessIDKM();
 
@@ -383,20 +361,18 @@
 	psCommand->ui32DstSyncCount = ui32DstSyncCount;
 	psCommand->ui32SrcSyncCount = ui32SrcSyncCount;
 	psCommand->psDstSync =
-	    (PVRSRV_SYNC_OBJECT *) (((IMG_UINT8 *) psCommand) +
-				    sizeof(PVRSRV_COMMAND));
+	    (struct PVRSRV_SYNC_OBJECT *)(((u8 *) psCommand) +
+				    sizeof(struct PVRSRV_COMMAND));
 
 	psCommand->psSrcSync =
-	    (PVRSRV_SYNC_OBJECT *) (((IMG_UINT8 *) psCommand->psDstSync)
-				    +
+	    (struct PVRSRV_SYNC_OBJECT *)(((u8 *) psCommand->psDstSync) +
 				    (ui32DstSyncCount *
-				     sizeof(PVRSRV_SYNC_OBJECT)));
+				     sizeof(struct PVRSRV_SYNC_OBJECT)));
 
 	psCommand->pvData =
-	    (PVRSRV_SYNC_OBJECT *) (((IMG_UINT8 *) psCommand->psSrcSync)
-				    +
+	    (struct PVRSRV_SYNC_OBJECT *)(((u8 *) psCommand->psSrcSync) +
 				    (ui32SrcSyncCount *
-				     sizeof(PVRSRV_SYNC_OBJECT)));
+				     sizeof(struct PVRSRV_SYNC_OBJECT)));
 
 	psCommand->ui32DataSize = ui32DataByteSize;
 
@@ -421,77 +397,67 @@
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR IMG_CALLCONV PVRSRVSubmitCommandKM(PVRSRV_QUEUE_INFO * psQueue,
-						    PVRSRV_COMMAND * psCommand)
-{
-
-	if (psCommand->ui32DstSyncCount > 0) {
-		psCommand->psDstSync =
-		    (PVRSRV_SYNC_OBJECT
-		     *) (((IMG_UINT8 *) psQueue->pvLinQueueKM)
-			 + psQueue->ui32WriteOffset + sizeof(PVRSRV_COMMAND));
-	}
-
-	if (psCommand->ui32SrcSyncCount > 0) {
-		psCommand->psSrcSync =
-		    (PVRSRV_SYNC_OBJECT
-		     *) (((IMG_UINT8 *) psQueue->pvLinQueueKM)
-			 + psQueue->ui32WriteOffset + sizeof(PVRSRV_COMMAND)
-			 +
+enum PVRSRV_ERROR PVRSRVSubmitCommandKM(struct PVRSRV_QUEUE_INFO *psQueue,
+				    struct PVRSRV_COMMAND *psCommand)
+{
+	if (psCommand->ui32DstSyncCount > 0)
+		psCommand->psDstSync = (struct PVRSRV_SYNC_OBJECT *)
+			(((u8 *) psQueue->pvLinQueueKM) +
+			 psQueue->ui32WriteOffset +
+			 sizeof(struct PVRSRV_COMMAND));
+
+	if (psCommand->ui32SrcSyncCount > 0)
+		psCommand->psSrcSync = (struct PVRSRV_SYNC_OBJECT *)
+			(((u8 *) psQueue->pvLinQueueKM) +
+			 psQueue->ui32WriteOffset +
+			 sizeof(struct PVRSRV_COMMAND) +
 			 (psCommand->ui32DstSyncCount *
-			  sizeof(PVRSRV_SYNC_OBJECT)));
-	}
+				sizeof(struct PVRSRV_SYNC_OBJECT)));
 
-	psCommand->pvData =
-	    (PVRSRV_SYNC_OBJECT *) (((IMG_UINT8 *) psQueue->pvLinQueueKM)
-				    + psQueue->ui32WriteOffset +
-				    sizeof(PVRSRV_COMMAND)
-				    +
-				    (psCommand->ui32DstSyncCount *
-				     sizeof(PVRSRV_SYNC_OBJECT))
-				    +
-				    (psCommand->ui32SrcSyncCount *
-				     sizeof(PVRSRV_SYNC_OBJECT)));
+	psCommand->pvData = (struct PVRSRV_SYNC_OBJECT *)
+			(((u8 *) psQueue->pvLinQueueKM) +
+			 psQueue->ui32WriteOffset +
+			 sizeof(struct PVRSRV_COMMAND) +
+			 (psCommand->ui32DstSyncCount *
+				sizeof(struct PVRSRV_SYNC_OBJECT)) +
+			 (psCommand->ui32SrcSyncCount *
+				sizeof(struct PVRSRV_SYNC_OBJECT)));
 
 	UPDATE_QUEUE_WOFF(psQueue, psCommand->ui32CmdSize);
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVProcessCommand(SYS_DATA * psSysData,
-				      PVRSRV_COMMAND * psCommand,
-				      IMG_BOOL bFlush)
-{
-	PVRSRV_SYNC_OBJECT *psWalkerObj;
-	PVRSRV_SYNC_OBJECT *psEndObj;
-	IMG_UINT32 i;
-	COMMAND_COMPLETE_DATA *psCmdCompleteData;
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	IMG_UINT32 ui32WriteOpsComplete;
-	IMG_UINT32 ui32ReadOpsComplete;
+static enum PVRSRV_ERROR PVRSRVProcessCommand(struct SYS_DATA *psSysData,
+					      struct PVRSRV_COMMAND *psCommand,
+					      IMG_BOOL bFlush)
+{
+	struct PVRSRV_SYNC_OBJECT *psWalkerObj;
+	struct PVRSRV_SYNC_OBJECT *psEndObj;
+	u32 i;
+	struct COMMAND_COMPLETE_DATA *psCmdCompleteData;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
+	u32 ui32WriteOpsComplete;
+	u32 ui32ReadOpsComplete;
 
 	psWalkerObj = psCommand->psDstSync;
 	psEndObj = psWalkerObj + psCommand->ui32DstSyncCount;
 	while (psWalkerObj < psEndObj) {
-		PVRSRV_SYNC_DATA *psSyncData =
+		struct PVRSRV_SYNC_DATA *psSyncData =
 		    psWalkerObj->psKernelSyncInfoKM->psSyncData;
 
 		ui32WriteOpsComplete = psSyncData->ui32WriteOpsComplete;
 		ui32ReadOpsComplete = psSyncData->ui32ReadOpsComplete;
 
 		if ((ui32WriteOpsComplete != psWalkerObj->ui32WriteOpsPending)
-		    || (ui32ReadOpsComplete != psWalkerObj->ui32ReadOpsPending)) {
+		    || (ui32ReadOpsComplete != psWalkerObj->ui32ReadOpsPending))
 			if (!bFlush ||
 			    !SYNCOPS_STALE(ui32WriteOpsComplete,
 					   psWalkerObj->ui32WriteOpsPending)
 			    || !SYNCOPS_STALE(ui32ReadOpsComplete,
 					      psWalkerObj->
-					      ui32ReadOpsPending)) {
+					      ui32ReadOpsPending))
 				return PVRSRV_ERROR_FAILED_DEPENDENCIES;
-			}
-		}
 
 		psWalkerObj++;
 	}
@@ -499,74 +465,65 @@
 	psWalkerObj = psCommand->psSrcSync;
 	psEndObj = psWalkerObj + psCommand->ui32SrcSyncCount;
 	while (psWalkerObj < psEndObj) {
-		PVRSRV_SYNC_DATA *psSyncData =
+		struct PVRSRV_SYNC_DATA *psSyncData =
 		    psWalkerObj->psKernelSyncInfoKM->psSyncData;
 
 		ui32ReadOpsComplete = psSyncData->ui32ReadOpsComplete;
 		ui32WriteOpsComplete = psSyncData->ui32WriteOpsComplete;
 
 		if ((ui32WriteOpsComplete != psWalkerObj->ui32WriteOpsPending)
-		    || (ui32ReadOpsComplete != psWalkerObj->ui32ReadOpsPending)) {
-			if (!bFlush &&
-			    SYNCOPS_STALE(ui32WriteOpsComplete,
-					  psWalkerObj->ui32WriteOpsPending)
-			    && SYNCOPS_STALE(ui32ReadOpsComplete,
-					     psWalkerObj->ui32ReadOpsPending)) {
-				PVR_DPF((PVR_DBG_WARNING,
-					 "PVRSRVProcessCommand: Stale syncops psSyncData:0x%x ui32WriteOpsComplete:0x%x ui32WriteOpsPending:0x%x",
+		    || (ui32ReadOpsComplete !=
+					psWalkerObj->ui32ReadOpsPending)) {
+			if (!bFlush && SYNCOPS_STALE(ui32WriteOpsComplete,
+			    psWalkerObj->ui32WriteOpsPending) &&
+			    SYNCOPS_STALE(ui32ReadOpsComplete,
+					     psWalkerObj->ui32ReadOpsPending))
+				PVR_DPF(PVR_DBG_WARNING,
+					 "PVRSRVProcessCommand: "
+					 "Stale syncops psSyncData:0x%x "
+					 "ui32WriteOpsComplete:0x%x "
+					 "ui32WriteOpsPending:0x%x",
 					 psSyncData, ui32WriteOpsComplete,
-					 psWalkerObj->ui32WriteOpsPending));
-			}
+					 psWalkerObj->ui32WriteOpsPending);
 
-			if (!bFlush ||
-			    !SYNCOPS_STALE(ui32WriteOpsComplete,
-					   psWalkerObj->ui32WriteOpsPending)
-			    || !SYNCOPS_STALE(ui32ReadOpsComplete,
-					      psWalkerObj->
-					      ui32ReadOpsPending)) {
+			if (!bFlush || !SYNCOPS_STALE(ui32WriteOpsComplete,
+			    psWalkerObj->ui32WriteOpsPending) ||
+			    !SYNCOPS_STALE(ui32ReadOpsComplete,
+					    psWalkerObj->ui32ReadOpsPending))
 				return PVRSRV_ERROR_FAILED_DEPENDENCIES;
-			}
 		}
 		psWalkerObj++;
 	}
 
 	if (psCommand->ui32DevIndex >= SYS_DEVICE_COUNT) {
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "PVRSRVProcessCommand: invalid DeviceType 0x%x",
-			 psCommand->ui32DevIndex));
+			 psCommand->ui32DevIndex);
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	psCmdCompleteData =
 	    psSysData->ppsCmdCompleteData[psCommand->ui32DevIndex][psCommand->
 								   CommandType];
-	if (psCmdCompleteData->bInUse) {
+	if (psCmdCompleteData->bInUse)
 
 		return PVRSRV_ERROR_FAILED_DEPENDENCIES;
-	}
 
 	psCmdCompleteData->bInUse = IMG_TRUE;
 
 	psCmdCompleteData->ui32DstSyncCount = psCommand->ui32DstSyncCount;
-	for (i = 0; i < psCommand->ui32DstSyncCount; i++) {
+	for (i = 0; i < psCommand->ui32DstSyncCount; i++)
 		psCmdCompleteData->psDstSync[i] = psCommand->psDstSync[i];
-	}
 
 	psCmdCompleteData->ui32SrcSyncCount = psCommand->ui32SrcSyncCount;
-	for (i = 0; i < psCommand->ui32SrcSyncCount; i++) {
+	for (i = 0; i < psCommand->ui32SrcSyncCount; i++)
 		psCmdCompleteData->psSrcSync[i] = psCommand->psSrcSync[i];
-	}
-
-	if (psSysData->
-	    ppfnCmdProcList[psCommand->ui32DevIndex][psCommand->
-						     CommandType] ((IMG_HANDLE)
-								   psCmdCompleteData,
-								   psCommand->
-								   ui32DataSize,
-								   psCommand->
-								   pvData) ==
-	    IMG_FALSE) {
 
+	if (psSysData->ppfnCmdProcList[psCommand->ui32DevIndex]
+				      [psCommand->CommandType]((void *)
+					   psCmdCompleteData,
+					   psCommand->ui32DataSize,
+					   psCommand->pvData) == IMG_FALSE) {
 		psCmdCompleteData->bInUse = IMG_FALSE;
 		eError = PVRSRV_ERROR_CMD_NOT_PROCESSED;
 	}
@@ -574,40 +531,40 @@
 	return eError;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVProcessQueues(IMG_UINT32 ui32CallerID, IMG_BOOL bFlush)
+enum PVRSRV_ERROR PVRSRVProcessQueues(u32 ui32CallerID, IMG_BOOL bFlush)
 {
-	PVRSRV_QUEUE_INFO *psQueue;
-	SYS_DATA *psSysData;
-	PVRSRV_COMMAND *psCommand;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	PVRSRV_ERROR eError;
+	struct PVRSRV_QUEUE_INFO *psQueue;
+	struct SYS_DATA *psSysData;
+	struct PVRSRV_COMMAND *psCommand;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	enum PVRSRV_ERROR eError;
 
 	eError = SysAcquireData(&psSysData);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	psSysData->bReProcessQueues = IMG_FALSE;
 
 	eError = OSLockResource(&psSysData->sQProcessResource, ui32CallerID);
 	if (eError != PVRSRV_OK) {
-
 		psSysData->bReProcessQueues = IMG_TRUE;
 
 		if (ui32CallerID == ISR_ID) {
 			if (bFlush) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "PVRSRVProcessQueues: Couldn't acquire queue processing lock for FLUSH"));
+				PVR_DPF(PVR_DBG_ERROR, "PVRSRVProcessQueues: "
+					"Couldn't acquire queue processing "
+					"lock for FLUSH");
 			} else {
-				PVR_DPF((PVR_DBG_MESSAGE,
-					 "PVRSRVProcessQueues: Couldn't acquire queue processing lock"));
+				PVR_DPF(PVR_DBG_MESSAGE, "PVRSRVProcessQueues:"
+				   " Couldn't acquire queue processing lock");
 			}
 		} else {
-			PVR_DPF((PVR_DBG_MESSAGE,
-				 "PVRSRVProcessQueues: Queue processing lock-acquire failed when called from the Services driver."));
-			PVR_DPF((PVR_DBG_MESSAGE,
-				 "                     This is due to MISR queue processing being interrupted by the Services driver."));
+			PVR_DPF(PVR_DBG_MESSAGE, "PVRSRVProcessQueues: "
+				"Queue processing lock-acquire failed when "
+				"called from the Services driver.");
+			PVR_DPF(PVR_DBG_MESSAGE, "                     "
+				"This is due to MISR queue processing being "
+				"interrupted by the Services driver.");
 		}
 
 		return PVRSRV_OK;
@@ -616,45 +573,37 @@
 	psQueue = psSysData->psQueueList;
 
 	if (!psQueue) {
-		PVR_DPF((PVR_DBG_MESSAGE,
-			 "No Queues installed - cannot process commands"));
+		PVR_DPF(PVR_DBG_MESSAGE,
+			 "No Queues installed - cannot process commands");
 	}
 
-	if (bFlush) {
+	if (bFlush)
 		PVRSRVSetDCState(DC_STATE_FLUSH_COMMANDS);
-	}
 
 	while (psQueue) {
 		while (psQueue->ui32ReadOffset != psQueue->ui32WriteOffset) {
-			psCommand =
-			    (PVRSRV_COMMAND *) ((IMG_UINT32) psQueue->
-						pvLinQueueKM +
-						psQueue->ui32ReadOffset);
+			psCommand = (struct PVRSRV_COMMAND *)((u32) psQueue->
+					pvLinQueueKM + psQueue->ui32ReadOffset);
 
 			if (PVRSRVProcessCommand(psSysData, psCommand, bFlush)
 			    == PVRSRV_OK) {
-
 				UPDATE_QUEUE_ROFF(psQueue,
 						  psCommand->ui32CmdSize)
-
-				    if (bFlush) {
+				if (bFlush)
 					continue;
-				}
 			}
-
 			break;
 		}
 		psQueue = psQueue->psNextKM;
 	}
 
-	if (bFlush) {
+	if (bFlush)
 		PVRSRVSetDCState(DC_STATE_NO_FLUSH_COMMANDS);
-	}
 
 	psDeviceNode = psSysData->psDeviceNodeList;
-	while (psDeviceNode != IMG_NULL) {
+	while (psDeviceNode != NULL) {
 		if (psDeviceNode->bReProcessDeviceCommandComplete &&
-		    psDeviceNode->pfnDeviceCommandComplete != IMG_NULL) {
+		    psDeviceNode->pfnDeviceCommandComplete != NULL) {
 			(*psDeviceNode->
 			 pfnDeviceCommandComplete) (psDeviceNode);
 		}
@@ -663,141 +612,129 @@
 
 	OSUnlockResource(&psSysData->sQProcessResource, ui32CallerID);
 
-	if (psSysData->bReProcessQueues) {
+	if (psSysData->bReProcessQueues)
 		return PVRSRV_ERROR_PROCESSING_BLOCKED;
-	}
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    IMG_VOID PVRSRVCommandCompleteKM(IMG_HANDLE hCmdCookie,
-				     IMG_BOOL bScheduleMISR)
-{
-	IMG_UINT32 i;
-	COMMAND_COMPLETE_DATA *psCmdCompleteData =
-	    (COMMAND_COMPLETE_DATA *) hCmdCookie;
-	SYS_DATA *psSysData;
+void PVRSRVCommandCompleteKM(void *hCmdCookie, IMG_BOOL bScheduleMISR)
+{
+	u32 i;
+	struct COMMAND_COMPLETE_DATA *psCmdCompleteData =
+	    (struct COMMAND_COMPLETE_DATA *)hCmdCookie;
+	struct SYS_DATA *psSysData;
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
+	if (SysAcquireData(&psSysData) != PVRSRV_OK)
 		return;
-	}
 
-	for (i = 0; i < psCmdCompleteData->ui32DstSyncCount; i++) {
+	for (i = 0; i < psCmdCompleteData->ui32DstSyncCount; i++)
 		psCmdCompleteData->psDstSync[i].psKernelSyncInfoKM->psSyncData->
 		    ui32WriteOpsComplete++;
-	}
 
-	for (i = 0; i < psCmdCompleteData->ui32SrcSyncCount; i++) {
+	for (i = 0; i < psCmdCompleteData->ui32SrcSyncCount; i++)
 		psCmdCompleteData->psSrcSync[i].psKernelSyncInfoKM->psSyncData->
 		    ui32ReadOpsComplete++;
-	}
 
 	psCmdCompleteData->bInUse = IMG_FALSE;
 
 	PVRSRVCommandCompleteCallbacks();
 
-	if (bScheduleMISR) {
+	if (bScheduleMISR)
 		OSScheduleMISR(psSysData);
-	}
 }
 
-IMG_VOID PVRSRVCommandCompleteCallbacks(IMG_VOID)
+void PVRSRVCommandCompleteCallbacks(void)
 {
-	SYS_DATA *psSysData;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct SYS_DATA *psSysData;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
 
 	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVCommandCompleteCallbacks: SysAcquireData failed"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVCommandCompleteCallbacks: "
+			 "SysAcquireData failed");
 		return;
 	}
 
 	psDeviceNode = psSysData->psDeviceNodeList;
-	while (psDeviceNode != IMG_NULL) {
-		if (psDeviceNode->pfnDeviceCommandComplete != IMG_NULL) {
+	while (psDeviceNode != NULL) {
+		if (psDeviceNode->pfnDeviceCommandComplete != NULL)
 
 			(*psDeviceNode->
 			 pfnDeviceCommandComplete) (psDeviceNode);
-		}
 		psDeviceNode = psDeviceNode->psNext;
 	}
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVRegisterCmdProcListKM(IMG_UINT32 ui32DevIndex,
-					     PFN_CMD_PROC * ppfnCmdProcList,
-					     IMG_UINT32 ui32MaxSyncsPerCmd[][2],
-					     IMG_UINT32 ui32CmdCount)
-{
-	SYS_DATA *psSysData;
-	PVRSRV_ERROR eError;
-	IMG_UINT32 i;
-	IMG_UINT32 ui32AllocSize;
-	PFN_CMD_PROC *ppfnCmdProc;
-	COMMAND_COMPLETE_DATA *psCmdCompleteData;
+enum PVRSRV_ERROR PVRSRVRegisterCmdProcListKM(u32 ui32DevIndex,
+			     IMG_BOOL (**ppfnCmdProcList)(void *, u32, void *),
+			     u32 ui32MaxSyncsPerCmd[][2], u32 ui32CmdCount)
+{
+	struct SYS_DATA *psSysData;
+	enum PVRSRV_ERROR eError;
+	u32 i;
+	u32 ui32AllocSize;
+	IMG_BOOL (**ppfnCmdProc)(void *, u32, void *);
+	struct COMMAND_COMPLETE_DATA *psCmdCompleteData;
 
 	if (ui32DevIndex >= SYS_DEVICE_COUNT) {
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "PVRSRVRegisterCmdProcListKM: invalid DeviceType 0x%x",
-			 ui32DevIndex));
+			 ui32DevIndex);
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	eError = SysAcquireData(&psSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRegisterCmdProcListKM: SysAcquireData failed"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVRegisterCmdProcListKM: SysAcquireData failed");
 		return eError;
 	}
 
-	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-			    ui32CmdCount * sizeof(PFN_CMD_PROC),
-			    (IMG_VOID **) & psSysData->
-			    ppfnCmdProcList[ui32DevIndex], IMG_NULL);
+	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, ui32CmdCount *
+				     sizeof(IMG_BOOL (*)(void *, u32, void *)),
+			    (void **) &psSysData->ppfnCmdProcList[ui32DevIndex],
+			    NULL);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRegisterCmdProcListKM: Failed to alloc queue"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVRegisterCmdProcListKM: Failed to alloc queue");
 		return eError;
 	}
 
 	ppfnCmdProc = psSysData->ppfnCmdProcList[ui32DevIndex];
 
-	for (i = 0; i < ui32CmdCount; i++) {
+	for (i = 0; i < ui32CmdCount; i++)
 		ppfnCmdProc[i] = ppfnCmdProcList[i];
-	}
 
-	ui32AllocSize = ui32CmdCount * sizeof(COMMAND_COMPLETE_DATA *);
+	ui32AllocSize = ui32CmdCount * sizeof(struct COMMAND_COMPLETE_DATA *);
 	eError = OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 			    ui32AllocSize,
-			    (IMG_VOID **) & psSysData->
-			    ppsCmdCompleteData[ui32DevIndex], IMG_NULL);
+			    (void **) &psSysData->
+			    ppsCmdCompleteData[ui32DevIndex], NULL);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRegisterCmdProcListKM: Failed to alloc CC data"));
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVRegisterCmdProcListKM: "
+			 "Failed to alloc CC data");
 		goto ErrorExit;
 	}
-	/* clear the list to ensure that we don't try to access uninitialised pointer
-	 * in the 'error' execution path */
+	/*
+	   clear the list to ensure that we don't try to access
+	   uninitialised pointer in the 'error' execution path
+	 */
 	OSMemSet(psSysData->ppsCmdCompleteData[ui32DevIndex], 0x00,
 		 ui32AllocSize);
 
 	for (i = 0; i < ui32CmdCount; i++) {
-
-		ui32AllocSize = sizeof(COMMAND_COMPLETE_DATA)
-		    + ((ui32MaxSyncsPerCmd[i][0]
-			+ ui32MaxSyncsPerCmd[i][1])
-		       * sizeof(PVRSRV_SYNC_OBJECT));
+		ui32AllocSize = sizeof(struct COMMAND_COMPLETE_DATA)
+		    + ((ui32MaxSyncsPerCmd[i][0] + ui32MaxSyncsPerCmd[i][1])
+		       * sizeof(struct PVRSRV_SYNC_OBJECT));
 
 		eError = OSAllocMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 				    ui32AllocSize,
-				    (IMG_VOID **) & psSysData->
+				    (void **)&psSysData->
 				    ppsCmdCompleteData[ui32DevIndex][i],
-				    IMG_NULL);
+				    NULL);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "PVRSRVRegisterCmdProcListKM: Failed to alloc cmd %d",
-				 i));
+			PVR_DPF(PVR_DBG_ERROR, "PVRSRVRegisterCmdProcListKM: "
+						"Failed to alloc cmd %d", i);
 			goto ErrorExit;
 		}
 
@@ -807,12 +744,13 @@
 		psCmdCompleteData =
 		    psSysData->ppsCmdCompleteData[ui32DevIndex][i];
 
-		psCmdCompleteData->psDstSync = (PVRSRV_SYNC_OBJECT *)
-		    (((IMG_UINT32) psCmdCompleteData)
-		     + sizeof(COMMAND_COMPLETE_DATA));
-		psCmdCompleteData->psSrcSync = (PVRSRV_SYNC_OBJECT *)
-		    (((IMG_UINT32) psCmdCompleteData->psDstSync)
-		     + (sizeof(PVRSRV_SYNC_OBJECT) * ui32MaxSyncsPerCmd[i][0]));
+		psCmdCompleteData->psDstSync = (struct PVRSRV_SYNC_OBJECT *)
+		     (((u32) psCmdCompleteData) +
+					sizeof(struct COMMAND_COMPLETE_DATA));
+		psCmdCompleteData->psSrcSync = (struct PVRSRV_SYNC_OBJECT *)
+		     (((u32) psCmdCompleteData->psDstSync) +
+					(sizeof(struct PVRSRV_SYNC_OBJECT) *
+					 ui32MaxSyncsPerCmd[i][0]));
 		psCmdCompleteData->ui32AllocSize = ui32AllocSize;
 	}
 
@@ -820,81 +758,76 @@
 
 ErrorExit:
 
-	if (psSysData->ppsCmdCompleteData[ui32DevIndex] != IMG_NULL) {
-		for (i = 0; i < ui32CmdCount; i++) {
+	if (psSysData->ppsCmdCompleteData[ui32DevIndex] != NULL) {
+		for (i = 0; i < ui32CmdCount; i++)
 			if (psSysData->ppsCmdCompleteData[ui32DevIndex][i] !=
-			    IMG_NULL) {
+			    NULL) {
 				psCmdCompleteData =
 				    psSysData->
 				    ppsCmdCompleteData[ui32DevIndex][i];
 				OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 					  psCmdCompleteData->ui32AllocSize,
-					  psCmdCompleteData, IMG_NULL);
+					  psCmdCompleteData, NULL);
 			}
-		}
 
 		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-			  ui32CmdCount * sizeof(COMMAND_COMPLETE_DATA *),
+			  ui32CmdCount * sizeof(struct COMMAND_COMPLETE_DATA *),
 			  psSysData->ppsCmdCompleteData[ui32DevIndex],
-			  IMG_NULL);
+			  NULL);
 	}
 
-	if (psSysData->ppfnCmdProcList[ui32DevIndex] != IMG_NULL) {
+	if (psSysData->ppfnCmdProcList[ui32DevIndex] != NULL)
 		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-			  ui32CmdCount * sizeof(PFN_CMD_PROC),
-			  psSysData->ppfnCmdProcList[ui32DevIndex], IMG_NULL);
-	}
+			  ui32CmdCount *
+				     sizeof(IMG_BOOL (*)(void *, u32, void *)),
+			  psSysData->ppfnCmdProcList[ui32DevIndex], NULL);
 
 	return eError;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR PVRSRVRemoveCmdProcListKM(IMG_UINT32 ui32DevIndex,
-					   IMG_UINT32 ui32CmdCount)
-{
-	SYS_DATA *psSysData;
-	PVRSRV_ERROR eError;
-	IMG_UINT32 i;
+enum PVRSRV_ERROR PVRSRVRemoveCmdProcListKM(u32 ui32DevIndex, u32 ui32CmdCount)
+{
+	struct SYS_DATA *psSysData;
+	enum PVRSRV_ERROR eError;
+	u32 i;
 
 	if (ui32DevIndex >= SYS_DEVICE_COUNT) {
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "PVRSRVRemoveCmdProcListKM: invalid DeviceType 0x%x",
-			 ui32DevIndex));
+			 ui32DevIndex);
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 
 	eError = SysAcquireData(&psSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVRemoveCmdProcListKM: SysAcquireData failed"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "PVRSRVRemoveCmdProcListKM: SysAcquireData failed");
 		return eError;
 	}
 
-	if (psSysData->ppsCmdCompleteData[ui32DevIndex] != IMG_NULL) {
-		for (i = 0; i < ui32CmdCount; i++) {
+	if (psSysData->ppsCmdCompleteData[ui32DevIndex] != NULL) {
+		for (i = 0; i < ui32CmdCount; i++)
 
 			if (psSysData->ppsCmdCompleteData[ui32DevIndex][i] !=
-			    IMG_NULL) {
-				COMMAND_COMPLETE_DATA *psCmdCompleteData =
-				    psSysData->
-				    ppsCmdCompleteData[ui32DevIndex][i];
+			    NULL) {
+				struct COMMAND_COMPLETE_DATA *
+					psCmdCompleteData = psSysData->
+					ppsCmdCompleteData[ui32DevIndex][i];
 				OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
 					  psCmdCompleteData->ui32AllocSize,
-					  psCmdCompleteData, IMG_NULL);
+					  psCmdCompleteData, NULL);
 			}
-		}
 
 		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-			  ui32CmdCount * sizeof(COMMAND_COMPLETE_DATA *),
-			  psSysData->ppsCmdCompleteData[ui32DevIndex],
-			  IMG_NULL);
+			  ui32CmdCount * sizeof(struct COMMAND_COMPLETE_DATA *),
+			  psSysData->ppsCmdCompleteData[ui32DevIndex], NULL);
 	}
 
-	if (psSysData->ppfnCmdProcList[ui32DevIndex] != IMG_NULL) {
+	if (psSysData->ppfnCmdProcList[ui32DevIndex] != NULL)
 		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-			  ui32CmdCount * sizeof(PFN_CMD_PROC),
-			  psSysData->ppfnCmdProcList[ui32DevIndex], IMG_NULL);
-	}
+			  ui32CmdCount *
+				sizeof(IMG_BOOL (*)(void *, u32, void *)),
+			  psSysData->ppfnCmdProcList[ui32DevIndex], NULL);
 
 	return PVRSRV_OK;
 }
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/queue.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/queue.h
@@ -1,117 +1,90 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef QUEUE_H
 #define QUEUE_H
 
-
-#define UPDATE_QUEUE_ROFF(psQueue, ui32Size)						\
+#define UPDATE_QUEUE_ROFF(psQueue, ui32Size)				\
 	psQueue->ui32ReadOffset = (psQueue->ui32ReadOffset + ui32Size)	\
-	& (psQueue->ui32QueueSize - 1);
+					& (psQueue->ui32QueueSize - 1);
+
+struct COMMAND_COMPLETE_DATA {
+	IMG_BOOL bInUse;
 
-	typedef struct _COMMAND_COMPLETE_DATA_ {
-		IMG_BOOL bInUse;
+	u32 ui32DstSyncCount;
+	u32 ui32SrcSyncCount;
+	struct PVRSRV_SYNC_OBJECT *psDstSync;
+	struct PVRSRV_SYNC_OBJECT *psSrcSync;
+	u32 ui32AllocSize;
+};
 
-		IMG_UINT32 ui32DstSyncCount;
-		IMG_UINT32 ui32SrcSyncCount;
-		PVRSRV_SYNC_OBJECT *psDstSync;
-		PVRSRV_SYNC_OBJECT *psSrcSync;
-		IMG_UINT32 ui32AllocSize;
-	} COMMAND_COMPLETE_DATA, *PCOMMAND_COMPLETE_DATA;
-
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVProcessQueues(IMG_UINT32 ui32CallerID,
-					     IMG_BOOL bFlush);
+enum PVRSRV_ERROR PVRSRVProcessQueues(u32 ui32CallerID, IMG_BOOL bFlush);
 
 #ifdef __KERNEL__
 #include <linux/types.h>
-	 off_t QueuePrintQueues(char *buffer, size_t size, off_t off);
+/*
+   HACK: The header was included already in img_types.h, but there we keep the
+   original value of __inline__. Without that include we'd  have at this point
+   __inline = __inline __attribute__((always_inline)). Keep it the old way for
+   now to avoid introducing changes related to this.
+ */
+#undef inline
+#define inline inline __attribute__((always_inline))
+
+off_t QueuePrintQueues(char *buffer, size_t size, off_t off);
 #endif
 
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateCommandQueueKM(IMG_UINT32
-								 ui32QueueSize,
-								 PVRSRV_QUEUE_INFO
-								 **
-								 ppsQueueInfo);
-	 IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVDestroyCommandQueueKM(PVRSRV_QUEUE_INFO * psQueueInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVInsertCommandKM(PVRSRV_QUEUE_INFO *
-							    psQueue,
-							    PVRSRV_COMMAND **
-							    ppsCommand,
-							    IMG_UINT32
-							    ui32DevIndex,
-							    IMG_UINT16
-							    CommandType,
-							    IMG_UINT32
-							    ui32DstSyncCount,
-							    PVRSRV_KERNEL_SYNC_INFO
-							    * apsDstSync[],
-							    IMG_UINT32
-							    ui32SrcSyncCount,
-							    PVRSRV_KERNEL_SYNC_INFO
-							    * apsSrcSync[],
-							    IMG_UINT32
-							    ui32DataByteSize);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVGetQueueSpaceKM(PVRSRV_QUEUE_INFO *
-							    psQueue,
-							    IMG_UINT32
-							    ui32ParamSize,
-							    IMG_VOID **
-							    ppvSpace);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVSubmitCommandKM(PVRSRV_QUEUE_INFO *
-							    psQueue,
-							    PVRSRV_COMMAND *
-							    psCommand);
-
-	 IMG_IMPORT
-	    IMG_VOID PVRSRVCommandCompleteKM(IMG_HANDLE hCmdCookie,
-					     IMG_BOOL bScheduleMISR);
-
-	IMG_VOID PVRSRVCommandCompleteCallbacks(IMG_VOID);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVRegisterCmdProcListKM(IMG_UINT32 ui32DevIndex,
-						     PFN_CMD_PROC *
-						     ppfnCmdProcList,
-						     IMG_UINT32
-						     ui32MaxSyncsPerCmd[][2],
-						     IMG_UINT32 ui32CmdCount);
-	 IMG_IMPORT PVRSRV_ERROR PVRSRVRemoveCmdProcListKM(IMG_UINT32
-							   ui32DevIndex,
-							   IMG_UINT32
-							   ui32CmdCount);
+enum PVRSRV_ERROR PVRSRVCreateCommandQueueKM(u32 ui32QueueSize,
+		struct PVRSRV_QUEUE_INFO **ppsQueueInfo);
+enum PVRSRV_ERROR PVRSRVDestroyCommandQueueKM(
+		struct PVRSRV_QUEUE_INFO *psQueueInfo);
+
+enum PVRSRV_ERROR PVRSRVInsertCommandKM(struct PVRSRV_QUEUE_INFO *psQueue,
+		struct PVRSRV_COMMAND **ppsCommand, u32 ui32DevIndex,
+		u16 CommandType, u32 ui32DstSyncCount,
+		struct PVRSRV_KERNEL_SYNC_INFO *apsDstSync[],
+		u32 ui32SrcSyncCount,
+		struct PVRSRV_KERNEL_SYNC_INFO *apsSrcSync[],
+		u32 ui32DataByteSize);
+
+enum PVRSRV_ERROR PVRSRVGetQueueSpaceKM(struct PVRSRV_QUEUE_INFO *psQueue,
+		u32 ui32ParamSize, void **ppvSpace);
+
+enum PVRSRV_ERROR PVRSRVSubmitCommandKM(struct PVRSRV_QUEUE_INFO *psQueue,
+		struct PVRSRV_COMMAND *psCommand);
+
+void PVRSRVCommandCompleteKM(void *hCmdCookie, IMG_BOOL bScheduleMISR);
+
+void PVRSRVCommandCompleteCallbacks(void);
+
+enum PVRSRV_ERROR PVRSRVRegisterCmdProcListKM(u32 ui32DevIndex,
+		IMG_BOOL (**ppfnCmdProcList)(void *, u32, void *),
+		u32 ui32MaxSyncsPerCmd[][2], u32 ui32CmdCount);
+enum PVRSRV_ERROR PVRSRVRemoveCmdProcListKM(u32 ui32DevIndex,
+		u32 ui32CmdCount);
 
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/ra.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/ra.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -36,55 +36,41 @@
 
 #define MINIMUM_HASH_SIZE (64)
 
-struct _BT_ {
+struct BT {
 	enum bt_type {
 		btt_span,
 		btt_free,
 		btt_live
 	} type;
 
-	IMG_UINTPTR_T base;
-	IMG_SIZE_T uSize;
+	u32 base;
+	size_t uSize;
 
-	struct _BT_ *pNextSegment;
-	struct _BT_ *pPrevSegment;
+	struct BT *pNextSegment;
+	struct BT *pPrevSegment;
 
-	struct _BT_ *pNextFree;
-	struct _BT_ *pPrevFree;
+	struct BT *pNextFree;
+	struct BT *pPrevFree;
 
-	BM_MAPPING *psMapping;
+	struct BM_MAPPING *psMapping;
 };
-typedef struct _BT_ BT;
-
-struct _RA_ARENA_ {
 
+struct RA_ARENA {
 	char *name;
-
-	IMG_UINT32 uQuantum;
-
-	 IMG_BOOL(*pImportAlloc) (void *,
-				  IMG_SIZE_T uSize,
-				  IMG_SIZE_T * pActualSize,
-				  BM_MAPPING ** ppsMapping,
-				  IMG_UINT32 uFlags, IMG_UINTPTR_T * pBase);
-	void (*pImportFree) (void *, IMG_UINTPTR_T, BM_MAPPING * psMapping);
-	void (*pBackingStoreFree) (void *, IMG_UINT32, IMG_UINT32, IMG_HANDLE);
-
+	u32 uQuantum;
+	IMG_BOOL(*pImportAlloc)(void *, size_t uSize, size_t *pActualSize,
+			struct BM_MAPPING **ppsMapping, u32 uFlags, u32 *pBase);
+	void (*pImportFree)(void *, u32, struct BM_MAPPING *psMapping);
+	void (*pBackingStoreFree)(void *, u32, u32, void *);
 	void *pImportHandle;
-
 #define FREE_TABLE_LIMIT 32
-
-	BT *aHeadFree[FREE_TABLE_LIMIT];
-
-	BT *pHeadSegment;
-	BT *pTailSegment;
-
-	HASH_TABLE *pSegmentHash;
-
+	struct BT *aHeadFree[FREE_TABLE_LIMIT];
+	struct BT *pHeadSegment;
+	struct BT *pTailSegment;
+	struct HASH_TABLE *pSegmentHash;
 #ifdef RA_STATS
-	RA_STATISTICS sStatistics;
+	struct RA_STATISTICS sStatistics;
 #endif
-
 #if defined(CONFIG_PROC_FS) && defined(DEBUG)
 #define PROC_NAME_SIZE		32
 	char szProcInfoName[PROC_NAME_SIZE];
@@ -92,23 +78,15 @@
 #endif
 };
 
-void RA_Dump(RA_ARENA * pArena);
-
 #if defined(CONFIG_PROC_FS) && defined(DEBUG)
-static int
-RA_DumpSegs(char *page, char **start, off_t off, int count, int *eof,
-	    void *data);
+static int RA_DumpSegs(char *page, char **start, off_t off, int count, int *eof,
+		       void *data);
 static int RA_DumpInfo(char *page, char **start, off_t off, int count, int *eof,
 		       void *data);
 #endif
 
-
-static IMG_BOOL
-_RequestAllocFail(void *_h,
-		  IMG_SIZE_T _uSize,
-		  IMG_SIZE_T * _pActualSize,
-		  BM_MAPPING ** _ppsMapping,
-		  IMG_UINT32 _uFlags, IMG_UINTPTR_T * _pBase)
+static IMG_BOOL _RequestAllocFail(void *_h, size_t _uSize, size_t *_pActualSize,
+		  struct BM_MAPPING **_ppsMapping, u32 _uFlags, u32 *_pBase)
 {
 	PVR_UNREFERENCED_PARAMETER(_h);
 	PVR_UNREFERENCED_PARAMETER(_uSize);
@@ -120,9 +98,9 @@
 	return IMG_FALSE;
 }
 
-static IMG_UINT32 pvr_log2(IMG_SIZE_T n)
+static u32 pvr_log2(size_t n)
 {
-	IMG_UINT32 l = 0;
+	u32 l = 0;
 	n >>= 1;
 	while (n > 0) {
 		n >>= 1;
@@ -131,65 +109,65 @@
 	return l;
 }
 
-static void
-_SegmentListInsertAfter(RA_ARENA * pArena, BT * pInsertionPoint, BT * pBT)
+static void _SegmentListInsertAfter(struct RA_ARENA *pArena,
+				    struct BT *pInsertionPoint, struct BT *pBT)
 {
-	PVR_ASSERT(pArena != IMG_NULL);
-	PVR_ASSERT(pInsertionPoint != IMG_NULL);
+	PVR_ASSERT(pArena != NULL);
+	PVR_ASSERT(pInsertionPoint != NULL);
 
 	pBT->pNextSegment = pInsertionPoint->pNextSegment;
 	pBT->pPrevSegment = pInsertionPoint;
-	if (pInsertionPoint->pNextSegment == IMG_NULL)
+	if (pInsertionPoint->pNextSegment == NULL)
 		pArena->pTailSegment = pBT;
 	else
 		pInsertionPoint->pNextSegment->pPrevSegment = pBT;
 	pInsertionPoint->pNextSegment = pBT;
 }
 
-static void _SegmentListInsert(RA_ARENA * pArena, BT * pBT)
+static void _SegmentListInsert(struct RA_ARENA *pArena, struct BT *pBT)
 {
 
-	if (pArena->pHeadSegment == IMG_NULL) {
+	if (pArena->pHeadSegment == NULL) {
 		pArena->pHeadSegment = pArena->pTailSegment = pBT;
-		pBT->pNextSegment = pBT->pPrevSegment = IMG_NULL;
+		pBT->pNextSegment = pBT->pPrevSegment = NULL;
 	} else {
-		BT *pBTScan;
+		struct BT *pBTScan;
 		pBTScan = pArena->pHeadSegment;
-		while (pBTScan->pNextSegment != IMG_NULL
+		while (pBTScan->pNextSegment != NULL
 		       && pBT->base >= pBTScan->pNextSegment->base)
 			pBTScan = pBTScan->pNextSegment;
 		_SegmentListInsertAfter(pArena, pBTScan, pBT);
 	}
 }
 
-static void _SegmentListRemove(RA_ARENA * pArena, BT * pBT)
+static void _SegmentListRemove(struct RA_ARENA *pArena, struct BT *pBT)
 {
-	if (pBT->pPrevSegment == IMG_NULL)
+	if (pBT->pPrevSegment == NULL)
 		pArena->pHeadSegment = pBT->pNextSegment;
 	else
 		pBT->pPrevSegment->pNextSegment = pBT->pNextSegment;
 
-	if (pBT->pNextSegment == IMG_NULL)
+	if (pBT->pNextSegment == NULL)
 		pArena->pTailSegment = pBT->pPrevSegment;
 	else
 		pBT->pNextSegment->pPrevSegment = pBT->pPrevSegment;
 }
 
-static BT *_SegmentSplit(RA_ARENA * pArena, BT * pBT, IMG_SIZE_T uSize)
+static struct BT *_SegmentSplit(struct RA_ARENA *pArena, struct BT *pBT,
+				size_t uSize)
 {
-	BT *pNeighbour;
+	struct BT *pNeighbour;
 
-	PVR_ASSERT(pArena != IMG_NULL);
+	PVR_ASSERT(pArena != NULL);
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(BT),
-		       (IMG_VOID **) & pNeighbour, IMG_NULL) != PVRSRV_OK) {
-		return IMG_NULL;
-	}
+		       sizeof(struct BT),
+		       (void **) &pNeighbour, NULL) != PVRSRV_OK)
+		return NULL;
 
 	pNeighbour->pPrevSegment = pBT;
 	pNeighbour->pNextSegment = pBT->pNextSegment;
-	if (pBT->pNextSegment == IMG_NULL)
+	if (pBT->pNextSegment == NULL)
 		pArena->pTailSegment = pNeighbour;
 	else
 		pBT->pNextSegment->pPrevSegment = pNeighbour;
@@ -203,57 +181,55 @@
 	return pNeighbour;
 }
 
-static void _FreeListInsert(RA_ARENA * pArena, BT * pBT)
+static void _FreeListInsert(struct RA_ARENA *pArena, struct BT *pBT)
 {
-	IMG_UINT32 uIndex;
+	u32 uIndex;
 	uIndex = pvr_log2(pBT->uSize);
 	pBT->type = btt_free;
 	pBT->pNextFree = pArena->aHeadFree[uIndex];
-	pBT->pPrevFree = IMG_NULL;
-	if (pArena->aHeadFree[uIndex] != IMG_NULL)
+	pBT->pPrevFree = NULL;
+	if (pArena->aHeadFree[uIndex] != NULL)
 		pArena->aHeadFree[uIndex]->pPrevFree = pBT;
 	pArena->aHeadFree[uIndex] = pBT;
 }
 
-static void _FreeListRemove(RA_ARENA * pArena, BT * pBT)
+static void _FreeListRemove(struct RA_ARENA *pArena, struct BT *pBT)
 {
-	IMG_UINT32 uIndex;
+	u32 uIndex;
 	uIndex = pvr_log2(pBT->uSize);
-	if (pBT->pNextFree != IMG_NULL)
+	if (pBT->pNextFree != NULL)
 		pBT->pNextFree->pPrevFree = pBT->pPrevFree;
-	if (pBT->pPrevFree == IMG_NULL)
+	if (pBT->pPrevFree == NULL)
 		pArena->aHeadFree[uIndex] = pBT->pNextFree;
 	else
 		pBT->pPrevFree->pNextFree = pBT->pNextFree;
 }
 
-static BT *_BuildSpanMarker(IMG_UINTPTR_T base, IMG_SIZE_T uSize)
+static struct BT *_BuildSpanMarker(u32 base, size_t uSize)
 {
-	BT *pBT;
+	struct BT *pBT;
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(BT),
-		       (IMG_VOID **) & pBT, IMG_NULL) != PVRSRV_OK) {
-		return IMG_NULL;
-	}
+		       sizeof(struct BT),
+		       (void **) &pBT, NULL) != PVRSRV_OK)
+		return NULL;
 
 	pBT->type = btt_span;
 	pBT->base = base;
 	pBT->uSize = uSize;
-	pBT->psMapping = IMG_NULL;
+	pBT->psMapping = NULL;
 
 	return pBT;
 }
 
-static BT *_BuildBT(IMG_UINTPTR_T base, IMG_SIZE_T uSize)
+static struct BT *_BuildBT(u32 base, size_t uSize)
 {
-	BT *pBT;
+	struct BT *pBT;
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(BT),
-		       (IMG_VOID **) & pBT, IMG_NULL) != PVRSRV_OK) {
-		return IMG_NULL;
-	}
+		       sizeof(struct BT),
+		       (void **) &pBT, NULL) != PVRSRV_OK)
+		return NULL;
 
 	pBT->type = btt_free;
 	pBT->base = base;
@@ -262,13 +238,13 @@
 	return pBT;
 }
 
-static BT *_InsertResource(RA_ARENA * pArena, IMG_UINTPTR_T base,
-			   IMG_SIZE_T uSize)
+static struct BT *_InsertResource(struct RA_ARENA *pArena, u32 base,
+			   size_t uSize)
 {
-	BT *pBT;
-	PVR_ASSERT(pArena != IMG_NULL);
+	struct BT *pBT;
+	PVR_ASSERT(pArena != NULL);
 	pBT = _BuildBT(base, uSize);
-	if (pBT != IMG_NULL) {
+	if (pBT != NULL) {
 		_SegmentListInsert(pArena, pBT);
 		_FreeListInsert(pArena, pBT);
 #ifdef RA_STATS
@@ -280,32 +256,29 @@
 	return pBT;
 }
 
-static BT *_InsertResourceSpan(RA_ARENA * pArena, IMG_UINTPTR_T base,
-			       IMG_SIZE_T uSize)
+static struct BT *_InsertResourceSpan(struct RA_ARENA *pArena, u32 base,
+			       size_t uSize)
 {
-	BT *pSpanStart;
-	BT *pSpanEnd;
-	BT *pBT;
+	struct BT *pSpanStart;
+	struct BT *pSpanEnd;
+	struct BT *pBT;
 
-	PVR_ASSERT(pArena != IMG_NULL);
+	PVR_ASSERT(pArena != NULL);
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "RA_InsertResourceSpan: arena='%s', base=0x%x, size=0x%x",
-		 pArena->name, base, uSize));
+		 pArena->name, base, uSize);
 
 	pSpanStart = _BuildSpanMarker(base, uSize);
-	if (pSpanStart == IMG_NULL) {
+	if (pSpanStart == NULL)
 		goto fail_start;
-	}
 	pSpanEnd = _BuildSpanMarker(base + uSize, 0);
-	if (pSpanEnd == IMG_NULL) {
+	if (pSpanEnd == NULL)
 		goto fail_end;
-	}
 
 	pBT = _BuildBT(base, uSize);
-	if (pBT == IMG_NULL) {
+	if (pBT == NULL)
 		goto fail_bt;
-	}
 
 	_SegmentListInsert(pArena, pSpanStart);
 	_SegmentListInsertAfter(pArena, pSpanStart, pBT);
@@ -317,21 +290,22 @@
 	return pBT;
 
 fail_bt:
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BT), pSpanEnd, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct BT), pSpanEnd, NULL);
 fail_end:
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BT), pSpanStart, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct BT), pSpanStart, NULL);
 fail_start:
-	return IMG_NULL;
+	return NULL;
 }
 
-static void _FreeBT(RA_ARENA * pArena, BT * pBT, IMG_BOOL bFreeBackingStore)
+static void _FreeBT(struct RA_ARENA *pArena, struct BT *pBT,
+		    IMG_BOOL bFreeBackingStore)
 {
-	BT *pNeighbour;
-	IMG_UINTPTR_T uOrigBase;
-	IMG_SIZE_T uOrigSize;
+	struct BT *pNeighbour;
+	u32 uOrigBase;
+	size_t uOrigSize;
 
-	PVR_ASSERT(pArena != IMG_NULL);
-	PVR_ASSERT(pBT != IMG_NULL);
+	PVR_ASSERT(pArena != NULL);
+	PVR_ASSERT(pBT != NULL);
 
 #ifdef RA_STATS
 	pArena->sStatistics.uLiveSegmentCount--;
@@ -343,64 +317,61 @@
 	uOrigSize = pBT->uSize;
 
 	pNeighbour = pBT->pPrevSegment;
-	if (pNeighbour != IMG_NULL
+	if (pNeighbour != NULL
 	    && pNeighbour->type == btt_free
 	    && pNeighbour->base + pNeighbour->uSize == pBT->base) {
 		_FreeListRemove(pArena, pNeighbour);
 		_SegmentListRemove(pArena, pNeighbour);
 		pBT->base = pNeighbour->base;
 		pBT->uSize += pNeighbour->uSize;
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BT), pNeighbour,
-			  IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct BT),
+			  pNeighbour, NULL);
 #ifdef RA_STATS
 		pArena->sStatistics.uFreeSegmentCount--;
 #endif
 	}
 
 	pNeighbour = pBT->pNextSegment;
-	if (pNeighbour != IMG_NULL
+	if (pNeighbour != NULL
 	    && pNeighbour->type == btt_free
 	    && pBT->base + pBT->uSize == pNeighbour->base) {
 		_FreeListRemove(pArena, pNeighbour);
 		_SegmentListRemove(pArena, pNeighbour);
 		pBT->uSize += pNeighbour->uSize;
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BT), pNeighbour,
-			  IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct BT),
+			  pNeighbour, NULL);
 #ifdef RA_STATS
 		pArena->sStatistics.uFreeSegmentCount--;
 #endif
 	}
 
-	if (pArena->pBackingStoreFree != IMG_NULL && bFreeBackingStore) {
-		IMG_UINTPTR_T uRoundedStart, uRoundedEnd;
+	if (pArena->pBackingStoreFree != NULL && bFreeBackingStore) {
+		u32 uRoundedStart, uRoundedEnd;
 
-		uRoundedStart =
-		    (uOrigBase / pArena->uQuantum) * pArena->uQuantum;
+		uRoundedStart = (uOrigBase / pArena->uQuantum) *
+							pArena->uQuantum;
 
-		if (uRoundedStart < pBT->base) {
+		if (uRoundedStart < pBT->base)
 			uRoundedStart += pArena->uQuantum;
-		}
 
 		uRoundedEnd =
 		    ((uOrigBase + uOrigSize + pArena->uQuantum -
 		      1) / pArena->uQuantum) * pArena->uQuantum;
 
-		if (uRoundedEnd > (pBT->base + pBT->uSize)) {
+		if (uRoundedEnd > (pBT->base + pBT->uSize))
 			uRoundedEnd -= pArena->uQuantum;
-		}
 
-		if (uRoundedStart < uRoundedEnd) {
+		if (uRoundedStart < uRoundedEnd)
 			pArena->pBackingStoreFree(pArena->pImportHandle,
 						  uRoundedStart, uRoundedEnd,
-						  (IMG_HANDLE) 0);
-		}
+						  (void *) 0);
 	}
 
-	if (pBT->pNextSegment != IMG_NULL && pBT->pNextSegment->type == btt_span
-	    && pBT->pPrevSegment != IMG_NULL
+	if (pBT->pNextSegment != NULL && pBT->pNextSegment->type == btt_span
+	    && pBT->pPrevSegment != NULL
 	    && pBT->pPrevSegment->type == btt_span) {
-		BT *next = pBT->pNextSegment;
-		BT *prev = pBT->pPrevSegment;
+		struct BT *next = pBT->pNextSegment;
+		struct BT *prev = pBT->pPrevSegment;
 		_SegmentListRemove(pArena, next);
 		_SegmentListRemove(pArena, prev);
 		_SegmentListRemove(pArena, pBT);
@@ -413,23 +384,22 @@
 		pArena->sStatistics.uFreeResourceCount -= pBT->uSize;
 		pArena->sStatistics.uTotalResourceCount -= pBT->uSize;
 #endif
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BT), next, IMG_NULL);
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BT), prev, IMG_NULL);
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BT), pBT, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct BT), next,
+			  NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct BT), prev,
+			  NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct BT), pBT,
+			  NULL);
 	} else
 		_FreeListInsert(pArena, pBT);
 }
 
-static IMG_BOOL
-_AttemptAllocAligned(RA_ARENA * pArena,
-		     IMG_SIZE_T uSize,
-		     BM_MAPPING ** ppsMapping,
-		     IMG_UINT32 uFlags,
-		     IMG_UINT32 uAlignment,
-		     IMG_UINT32 uAlignmentOffset, IMG_UINTPTR_T * base)
+static IMG_BOOL _AttemptAllocAligned(struct RA_ARENA *pArena, size_t uSize,
+		     struct BM_MAPPING **ppsMapping, u32 uFlags, u32 uAlignment,
+		     u32 uAlignmentOffset, u32 *base)
 {
-	IMG_UINT32 uIndex;
-	PVR_ASSERT(pArena != IMG_NULL);
+	u32 uIndex;
+	PVR_ASSERT(pArena != NULL);
 
 	PVR_UNREFERENCED_PARAMETER(uFlags);
 
@@ -438,72 +408,69 @@
 
 	uIndex = pvr_log2(uSize);
 
-
-	while (uIndex < FREE_TABLE_LIMIT
-	       && pArena->aHeadFree[uIndex] == IMG_NULL)
+	while (uIndex < FREE_TABLE_LIMIT && pArena->aHeadFree[uIndex] == NULL)
 		uIndex++;
 
 	while (uIndex < FREE_TABLE_LIMIT) {
-		if (pArena->aHeadFree[uIndex] != IMG_NULL) {
-
-			BT *pBT;
+		if (pArena->aHeadFree[uIndex] != NULL) {
+			struct BT *pBT;
 
 			pBT = pArena->aHeadFree[uIndex];
-			while (pBT != IMG_NULL) {
-				IMG_UINTPTR_T aligned_base;
+			while (pBT != NULL) {
+				u32 aligned_base;
 
 				if (uAlignment > 1)
 					aligned_base =
-					    (pBT->base + uAlignmentOffset +
-					     uAlignment -
-					     1) / uAlignment * uAlignment -
-					    uAlignmentOffset;
+					  (pBT->base + uAlignmentOffset +
+					    uAlignment - 1) / uAlignment *
+					    uAlignment - uAlignmentOffset;
 				else
 					aligned_base = pBT->base;
-				PVR_DPF((PVR_DBG_MESSAGE,
-					 "RA_AttemptAllocAligned: pBT-base=0x%x "
-					 "pBT-size=0x%x alignedbase=0x%x size=0x%x",
-					 pBT->base, pBT->uSize, aligned_base,
-					 uSize));
+				PVR_DPF(PVR_DBG_MESSAGE,
+				   "RA_AttemptAllocAligned: pBT-base=0x%x "
+				   "pBT-size=0x%x alignedbase=0x%x size=0x%x",
+				   pBT->base, pBT->uSize, aligned_base, uSize);
 
 				if (pBT->base + pBT->uSize >=
-				    aligned_base + uSize) {
-					if (!pBT->psMapping
-					    || pBT->psMapping->ui32Flags ==
-					    uFlags) {
+						aligned_base + uSize) {
+					if (!pBT->psMapping ||
+					    pBT->psMapping->ui32Flags ==
+								    uFlags) {
 						_FreeListRemove(pArena, pBT);
-
 						PVR_ASSERT(pBT->type ==
-							   btt_free);
-
+								btt_free);
 #ifdef RA_STATS
 						pArena->sStatistics.
-						    uLiveSegmentCount++;
+							uLiveSegmentCount++;
 						pArena->sStatistics.
-						    uFreeSegmentCount--;
+							uFreeSegmentCount--;
 						pArena->sStatistics.
-						    uFreeResourceCount -=
-						    pBT->uSize;
+							uFreeResourceCount -=
+							pBT->uSize;
 #endif
-
 						if (aligned_base > pBT->base) {
-							BT *pNeighbour;
+							struct BT *pNeighbour;
 
 							pNeighbour =
-							    _SegmentSplit
-							    (pArena, pBT,
-							     aligned_base -
-							     pBT->base);
+								_SegmentSplit
+								(pArena, pBT,
+								 aligned_base -
+								 pBT->base);
 
 							if (pNeighbour ==
-							    IMG_NULL) {
-								PVR_DPF((PVR_DBG_ERROR, "_AttemptAllocAligned: Front split failed"));
+									NULL) {
+								PVR_DPF(
+								PVR_DBG_ERROR,
+								"_AttemptAlloc"
+								"Aligned: "
+								"Front split "
+								"failed");
 
 								_FreeListInsert
-								    (pArena,
-								     pBT);
+									(pArena,
+									 pBT);
 								return
-								    IMG_FALSE;
+								     IMG_FALSE;
 							}
 
 							_FreeListInsert(pArena,
@@ -512,65 +479,71 @@
 							pArena->sStatistics.
 							    uFreeSegmentCount++;
 							pArena->sStatistics.
-							    uFreeResourceCount
-							    += pBT->uSize;
+							   uFreeResourceCount +=
+								    pBT->uSize;
 #endif
 							pBT = pNeighbour;
 						}
 
 						if (pBT->uSize > uSize) {
-							BT *pNeighbour;
+							struct BT *pNeighbour;
 							pNeighbour =
-							    _SegmentSplit
-							    (pArena, pBT,
-							     uSize);
+								_SegmentSplit
+								(pArena, pBT,
+								 uSize);
 
 							if (pNeighbour ==
-							    IMG_NULL) {
-								PVR_DPF((PVR_DBG_ERROR, "_AttemptAllocAligned: Back split failed"));
+									NULL) {
+								PVR_DPF(
+								PVR_DBG_ERROR,
+								"_AttemptAlloc"
+								"Aligned:"
+								" Back split "
+								"failed");
 
 								_FreeListInsert
-								    (pArena,
-								     pBT);
+									(pArena,
+									 pBT);
 								return
-								    IMG_FALSE;
+								     IMG_FALSE;
 							}
 
 							_FreeListInsert(pArena,
-									pNeighbour);
+								pNeighbour);
 #ifdef RA_STATS
 							pArena->sStatistics.
 							    uFreeSegmentCount++;
 							pArena->sStatistics.
-							    uFreeResourceCount
-							    +=
-							    pNeighbour->uSize;
+							   uFreeResourceCount +=
+							      pNeighbour->uSize;
 #endif
 						}
 
 						pBT->type = btt_live;
 
-						if (!HASH_Insert
-						    (pArena->pSegmentHash,
-						     pBT->base,
-						     (IMG_UINTPTR_T) pBT)) {
+						if (!HASH_Insert(
+							 pArena->pSegmentHash,
+							 pBT->base, (u32)pBT)) {
 							_FreeBT(pArena, pBT,
 								IMG_FALSE);
 							return IMG_FALSE;
 						}
 
-						if (ppsMapping != IMG_NULL)
+						if (ppsMapping != NULL)
 							*ppsMapping =
-							    pBT->psMapping;
+								pBT->psMapping;
 
 						*base = pBT->base;
 
 						return IMG_TRUE;
 					} else {
-						PVR_DPF((PVR_DBG_MESSAGE,
-							 "AttemptAllocAligned: mismatch in flags. Import has %x, request was %x",
-							 pBT->psMapping->
-							 ui32Flags, uFlags));
+						PVR_DPF(PVR_DBG_MESSAGE,
+						"AttemptAllocAligned: "
+						"mismatch in flags. "
+						"Import has %x, request "
+						"was %x",
+						pBT->psMapping->ui32Flags,
+						uFlags);
 
 					}
 				}
@@ -584,44 +557,38 @@
 	return IMG_FALSE;
 }
 
-RA_ARENA *RA_Create(IMG_CHAR * name,
-		    IMG_UINTPTR_T base,
-		    IMG_SIZE_T uSize,
-		    BM_MAPPING * psMapping,
-		    IMG_SIZE_T uQuantum,
-		    IMG_BOOL(*alloc) (IMG_VOID *, IMG_SIZE_T uSize,
-				      IMG_SIZE_T * pActualSize,
-				      BM_MAPPING ** ppsMapping,
-				      IMG_UINT32 _flags, IMG_UINTPTR_T * pBase),
-		    IMG_VOID(*free) (IMG_VOID *, IMG_UINTPTR_T,
-				     BM_MAPPING * psMapping),
-		    IMG_VOID(*backingstore_free) (IMG_VOID *, IMG_UINT32,
-						  IMG_UINT32, IMG_HANDLE),
-		    IMG_VOID * pImportHandle)
+struct RA_ARENA *RA_Create(char *name, u32 base, size_t uSize,
+		    struct BM_MAPPING *psMapping, size_t uQuantum,
+		    IMG_BOOL(*alloc) (void *, size_t uSize,
+				      size_t *pActualSize,
+				      struct BM_MAPPING **ppsMapping,
+				      u32 _flags, u32 *pBase),
+		    void(*free) (void *, u32, struct BM_MAPPING *psMapping),
+		    void(*backingstore_free) (void *, u32, u32, void *),
+		    void *pImportHandle)
 {
-	RA_ARENA *pArena;
-	BT *pBT;
+	struct RA_ARENA *pArena;
+	struct BT *pBT;
 	int i;
 
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "RA_Create: name='%s', base=0x%x, uSize=0x%x, alloc=0x%x, free=0x%x",
-		 name, base, uSize, alloc, free));
+	PVR_DPF(PVR_DBG_MESSAGE, "RA_Create: "
+		"name='%s', base=0x%x, uSize=0x%x, alloc=0x%x, free=0x%x",
+		name, base, uSize, alloc, free);
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 		       sizeof(*pArena),
-		       (IMG_VOID **) & pArena, IMG_NULL) != PVRSRV_OK) {
+		       (void **) &pArena, NULL) != PVRSRV_OK)
 		goto arena_fail;
-	}
 
 	pArena->name = name;
-	pArena->pImportAlloc = alloc != IMG_NULL ? alloc : _RequestAllocFail;
+	pArena->pImportAlloc = alloc != NULL ? alloc : _RequestAllocFail;
 	pArena->pImportFree = free;
 	pArena->pBackingStoreFree = backingstore_free;
 	pArena->pImportHandle = pImportHandle;
 	for (i = 0; i < FREE_TABLE_LIMIT; i++)
-		pArena->aHeadFree[i] = IMG_NULL;
-	pArena->pHeadSegment = IMG_NULL;
-	pArena->pTailSegment = IMG_NULL;
+		pArena->aHeadFree[i] = NULL;
+	pArena->pHeadSegment = NULL;
+	pArena->pTailSegment = NULL;
 	pArena->uQuantum = uQuantum;
 
 #ifdef RA_STATS
@@ -639,22 +606,22 @@
 #if defined(CONFIG_PROC_FS) && defined(DEBUG)
 	if (strcmp(pArena->name, "") != 0) {
 		sprintf(pArena->szProcInfoName, "ra_info_%s", pArena->name);
-		CreateProcEntry(pArena->szProcInfoName, RA_DumpInfo, 0, pArena);
+		CreateProcEntry(pArena->szProcInfoName, RA_DumpInfo, NULL,
+				pArena);
 		sprintf(pArena->szProcSegsName, "ra_segs_%s", pArena->name);
-		CreateProcEntry(pArena->szProcSegsName, RA_DumpSegs, 0, pArena);
+		CreateProcEntry(pArena->szProcSegsName, RA_DumpSegs, NULL,
+				pArena);
 	}
 #endif
 
 	pArena->pSegmentHash = HASH_Create(MINIMUM_HASH_SIZE);
-	if (pArena->pSegmentHash == IMG_NULL) {
+	if (pArena->pSegmentHash == NULL)
 		goto hash_fail;
-	}
 	if (uSize > 0) {
 		uSize = (uSize + uQuantum - 1) / uQuantum * uQuantum;
 		pBT = _InsertResource(pArena, base, uSize);
-		if (pBT == IMG_NULL) {
+		if (pBT == NULL)
 			goto insert_fail;
-		}
 		pBT->psMapping = psMapping;
 
 	}
@@ -663,26 +630,28 @@
 insert_fail:
 	HASH_Delete(pArena->pSegmentHash);
 hash_fail:
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(RA_ARENA), pArena, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct RA_ARENA), pArena,
+		  NULL);
 arena_fail:
-	return IMG_NULL;
+	return NULL;
 }
 
-void RA_Delete(RA_ARENA * pArena)
+void RA_Delete(struct RA_ARENA *pArena)
 {
-	IMG_UINT32 uIndex;
+	u32 uIndex;
 
-	PVR_ASSERT(pArena != IMG_NULL);
-	PVR_DPF((PVR_DBG_MESSAGE, "RA_Delete: name='%s'", pArena->name));
+	PVR_ASSERT(pArena != NULL);
+	PVR_DPF(PVR_DBG_MESSAGE, "RA_Delete: name='%s'", pArena->name);
 
 	for (uIndex = 0; uIndex < FREE_TABLE_LIMIT; uIndex++)
-		pArena->aHeadFree[uIndex] = IMG_NULL;
+		pArena->aHeadFree[uIndex] = NULL;
 
-	while (pArena->pHeadSegment != IMG_NULL) {
-		BT *pBT = pArena->pHeadSegment;
+	while (pArena->pHeadSegment != NULL) {
+		struct BT *pBT = pArena->pHeadSegment;
 		PVR_ASSERT(pBT->type == btt_free);
 		_SegmentListRemove(pArena, pBT);
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BT), pBT, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct BT), pBT,
+			  NULL);
 #ifdef RA_STATS
 		pArena->sStatistics.uSpanCount--;
 #endif
@@ -692,56 +661,51 @@
 	RemoveProcEntry(pArena->szProcSegsName);
 #endif
 	HASH_Delete(pArena->pSegmentHash);
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(RA_ARENA), pArena, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct RA_ARENA), pArena,
+		  NULL);
 }
 
-IMG_BOOL RA_Add(RA_ARENA * pArena, IMG_UINTPTR_T base, IMG_SIZE_T uSize)
+IMG_BOOL RA_Add(struct RA_ARENA *pArena, u32 base, size_t uSize)
 {
-	PVR_ASSERT(pArena != IMG_NULL);
+	PVR_ASSERT(pArena != NULL);
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "RA_Add: name='%s', base=0x%x, size=0x%x", pArena->name, base,
-		 uSize));
+		 uSize);
 
 	uSize =
 	    (uSize + pArena->uQuantum -
 	     1) / pArena->uQuantum * pArena->uQuantum;
-	return ((IMG_BOOL) (_InsertResource(pArena, base, uSize) != IMG_NULL));
+	return (IMG_BOOL)(_InsertResource(pArena, base, uSize) != NULL);
 }
 
-IMG_BOOL
-RA_Alloc(RA_ARENA * pArena,
-	 IMG_SIZE_T uRequestSize,
-	 IMG_SIZE_T * pActualSize,
-	 BM_MAPPING ** ppsMapping,
-	 IMG_UINT32 uFlags,
-	 IMG_UINT32 uAlignment,
-	 IMG_UINT32 uAlignmentOffset, IMG_UINTPTR_T * base)
+IMG_BOOL RA_Alloc(struct RA_ARENA *pArena, size_t uRequestSize,
+		  size_t *pActualSize, struct BM_MAPPING **ppsMapping,
+		  u32 uFlags, u32 uAlignment, u32 uAlignmentOffset, u32 *base)
 {
 	IMG_BOOL bResult = IMG_FALSE;
-	IMG_SIZE_T uSize = uRequestSize;
+	size_t uSize = uRequestSize;
 
-	PVR_ASSERT(pArena != IMG_NULL);
+	PVR_ASSERT(pArena != NULL);
 
 
-	if (pActualSize != IMG_NULL)
+	if (pActualSize != NULL)
 		*pActualSize = uSize;
 
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "RA_Alloc: arena='%s', size=0x%x(0x%x), alignment=0x%x, offset=0x%x",
+	PVR_DPF(PVR_DBG_MESSAGE, "RA_Alloc: "
+		 "arena='%s', size=0x%x(0x%x), alignment=0x%x, offset=0x%x",
 		 pArena->name, uSize, uRequestSize, uAlignment,
-		 uAlignmentOffset));
+		 uAlignmentOffset);
 
 	bResult = _AttemptAllocAligned(pArena, uSize, ppsMapping, uFlags,
 				       uAlignment, uAlignmentOffset, base);
 	if (!bResult) {
-		BM_MAPPING *psImportMapping;
-		IMG_UINTPTR_T import_base;
-		IMG_SIZE_T uImportSize = uSize;
+		struct BM_MAPPING *psImportMapping;
+		u32 import_base;
+		size_t uImportSize = uSize;
 
-		if (uAlignment > pArena->uQuantum) {
+		if (uAlignment > pArena->uQuantum)
 			uImportSize += (uAlignment - 1);
-		}
 
 		uImportSize =
 		    ((uImportSize + pArena->uQuantum -
@@ -752,19 +716,19 @@
 					 &uImportSize, &psImportMapping, uFlags,
 					 &import_base);
 		if (bResult) {
-			BT *pBT;
+			struct BT *pBT;
 			pBT =
 			    _InsertResourceSpan(pArena, import_base,
 						uImportSize);
 
-			if (pBT == IMG_NULL) {
+			if (pBT == NULL) {
 
 				pArena->pImportFree(pArena->pImportHandle,
 						    import_base,
 						    psImportMapping);
-				PVR_DPF((PVR_DBG_MESSAGE,
-					 "RA_Alloc: name='%s', size=0x%x failed!",
-					 pArena->name, uSize));
+				PVR_DPF(PVR_DBG_MESSAGE, "RA_Alloc: "
+					"name='%s', size=0x%x failed!",
+					 pArena->name, uSize);
 
 				return IMG_FALSE;
 			}
@@ -779,11 +743,10 @@
 			    _AttemptAllocAligned(pArena, uSize, ppsMapping,
 						 uFlags, uAlignment,
 						 uAlignmentOffset, base);
-			if (!bResult) {
-				PVR_DPF((PVR_DBG_MESSAGE,
-					 "RA_Alloc: name='%s' uAlignment failed!",
-					 pArena->name));
-			}
+			if (!bResult)
+				PVR_DPF(PVR_DBG_MESSAGE, "RA_Alloc: "
+					"name='%s' uAlignment failed!",
+					 pArena->name);
 		}
 	}
 #ifdef RA_STATS
@@ -791,25 +754,25 @@
 		pArena->sStatistics.uCumulativeAllocs++;
 #endif
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "RA_Alloc: name='%s', size=0x%x, *base=0x%x = %d",
-		 pArena->name, uSize, *base, bResult));
+		 pArena->name, uSize, *base, bResult);
 
 	return bResult;
 }
 
-void RA_Free(RA_ARENA * pArena, IMG_UINTPTR_T base, IMG_BOOL bFreeBackingStore)
+void RA_Free(struct RA_ARENA *pArena, u32 base, IMG_BOOL bFreeBackingStore)
 {
-	BT *pBT;
+	struct BT *pBT;
 
-	PVR_ASSERT(pArena != IMG_NULL);
+	PVR_ASSERT(pArena != NULL);
 
 
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "RA_Free: name='%s', base=0x%x", pArena->name, base));
+	PVR_DPF(PVR_DBG_MESSAGE,
+		 "RA_Free: name='%s', base=0x%x", pArena->name, base);
 
-	pBT = (BT *) HASH_Remove(pArena->pSegmentHash, base);
-	PVR_ASSERT(pBT != IMG_NULL);
+	pBT = (struct BT *)HASH_Remove(pArena->pSegmentHash, base);
+	PVR_ASSERT(pBT != NULL);
 
 	if (pBT) {
 		PVR_ASSERT(pBT->base == base);
@@ -822,24 +785,24 @@
 	}
 }
 
-IMG_BOOL RA_GetNextLiveSegment(IMG_HANDLE hArena,
-			       RA_SEGMENT_DETAILS * psSegDetails)
+IMG_BOOL RA_GetNextLiveSegment(void *hArena,
+			       struct RA_SEGMENT_DETAILS *psSegDetails)
 {
-	BT *pBT;
+	struct BT *pBT;
 
 	if (psSegDetails->hSegment) {
-		pBT = (BT *) psSegDetails->hSegment;
+		pBT = (struct BT *)psSegDetails->hSegment;
 	} else {
-		RA_ARENA *pArena = (RA_ARENA *) hArena;
+		struct RA_ARENA *pArena = (struct RA_ARENA *)hArena;
 
 		pBT = pArena->pHeadSegment;
 	}
 
-	while (pBT != IMG_NULL) {
+	while (pBT != NULL) {
 		if (pBT->type == btt_live) {
 			psSegDetails->uiSize = pBT->uSize;
 			psSegDetails->sCpuPhyAddr.uiAddr = pBT->base;
-			psSegDetails->hSegment = (IMG_HANDLE) pBT->pNextSegment;
+			psSegDetails->hSegment = (void *) pBT->pNextSegment;
 
 			return IMG_TRUE;
 		}
@@ -849,13 +812,12 @@
 
 	psSegDetails->uiSize = 0;
 	psSegDetails->sCpuPhyAddr.uiAddr = 0;
-	psSegDetails->hSegment = (IMG_HANDLE) - 1;
+	psSegDetails->hSegment = (void *) -1;
 
 	return IMG_FALSE;
 }
 
-
-#if (defined(CONFIG_PROC_FS) && defined(DEBUG)) || defined (RA_STATS)
+#if (defined(CONFIG_PROC_FS) && defined(DEBUG)) || defined(RA_STATS)
 static char *_BTType(int eType)
 {
 	switch (eType) {
@@ -871,55 +833,51 @@
 #endif
 
 #if defined(CONFIG_PROC_FS) && defined(DEBUG)
-static int
-RA_DumpSegs(char *page, char **start, off_t off, int count, int *eof,
-	    void *data)
+static int RA_DumpSegs(char *page, char **start, off_t off, int count, int *eof,
+		       void *data)
 {
-	BT *pBT = 0;
+	struct BT *pBT = NULL;
 	int len = 0;
-	RA_ARENA *pArena = (RA_ARENA *) data;
+	struct RA_ARENA *pArena = (struct RA_ARENA *)data;
 
 	if (count < 80) {
 		*start = (char *)0;
-		return (0);
+		return 0;
 	}
 	*eof = 0;
 	*start = (char *)1;
-	if (off == 0) {
+	if (off == 0)
 		return printAppend(page, count, 0,
-				   "Arena \"%s\"\nBase         Size Type Ref\n",
-				   pArena->name);
-	}
+			"Arena \"%s\"\nBase         Size Type Ref\n",
+			pArena->name);
 	for (pBT = pArena->pHeadSegment; --off && pBT;
-	     pBT = pBT->pNextSegment) ;
-	if (pBT) {
+	     pBT = pBT->pNextSegment)
+		;
+	if (pBT)
 		len = printAppend(page, count, 0, "%08x %8x %4s %08x\n",
 				  (unsigned int)pBT->base,
 				  (unsigned int)pBT->uSize, _BTType(pBT->type),
 				  (unsigned int)pBT->psMapping);
-	} else {
+	else
 		*eof = 1;
-	}
-	return (len);
+	return len;
 }
 
-static int
-RA_DumpInfo(char *page, char **start, off_t off, int count, int *eof,
+static int RA_DumpInfo(char *page, char **start, off_t off, int count, int *eof,
 	    void *data)
 {
 	int len = 0;
-	RA_ARENA *pArena = (RA_ARENA *) data;
+	struct RA_ARENA *pArena = (struct RA_ARENA *)data;
 
 	if (count < 80) {
 		*start = (char *)0;
-		return (0);
+		return 0;
 	}
 	*eof = 0;
 	switch (off) {
 	case 0:
-		len =
-		    printAppend(page, count, 0, "quantum\t\t\t%lu\n",
-				pArena->uQuantum);
+		len = printAppend(page, count, 0, "quantum\t\t\t%u\n",
+				  pArena->uQuantum);
 		break;
 	case 1:
 		len =
@@ -928,46 +886,38 @@
 		break;
 #ifdef RA_STATS
 	case 2:
-		len =
-		    printAppend(page, count, 0, "span count\t\t%lu\n",
+		len = printAppend(page, count, 0, "span count\t\t%u\n",
 				pArena->sStatistics.uSpanCount);
 		break;
 	case 3:
-		len =
-		    printAppend(page, count, 0, "live segment count\t%lu\n",
+		len = printAppend(page, count, 0, "live segment count\t%u\n",
 				pArena->sStatistics.uLiveSegmentCount);
 		break;
 	case 4:
-		len =
-		    printAppend(page, count, 0, "free segment count\t%lu\n",
+		len = printAppend(page, count, 0, "free segment count\t%u\n",
 				pArena->sStatistics.uFreeSegmentCount);
 		break;
 	case 5:
-		len =
-		    printAppend(page, count, 0,
-				"free resource count\t%lu (0x%x)\n",
+		len = printAppend(page, count, 0,
+				"free resource count\t%u (0x%x)\n",
 				pArena->sStatistics.uFreeResourceCount,
 				(unsigned int)pArena->sStatistics.
 				uFreeResourceCount);
 		break;
 	case 6:
-		len =
-		    printAppend(page, count, 0, "total allocs\t\t%lu\n",
+		len = printAppend(page, count, 0, "total allocs\t\t%u\n",
 				pArena->sStatistics.uCumulativeAllocs);
 		break;
 	case 7:
-		len =
-		    printAppend(page, count, 0, "total frees\t\t%lu\n",
+		len = printAppend(page, count, 0, "total frees\t\t%u\n",
 				pArena->sStatistics.uCumulativeFrees);
 		break;
 	case 8:
-		len =
-		    printAppend(page, count, 0, "import count\t\t%lu\n",
+		len = printAppend(page, count, 0, "import count\t\t%u\n",
 				pArena->sStatistics.uImportCount);
 		break;
 	case 9:
-		len =
-		    printAppend(page, count, 0, "export count\t\t%lu\n",
+		len = printAppend(page, count, 0, "export count\t\t%u\n",
 				pArena->sStatistics.uExportCount);
 		break;
 #endif
@@ -976,18 +926,18 @@
 		*eof = 1;
 	}
 	*start = (char *)1;
-	return (len);
+	return len;
 }
 #endif
 
 #ifdef RA_STATS
-PVRSRV_ERROR RA_GetStats(RA_ARENA * pArena,
-			 IMG_CHAR ** ppszStr, IMG_UINT32 * pui32StrLen)
+enum PVRSRV_ERROR RA_GetStats(struct RA_ARENA *pArena,
+			 char **ppszStr, u32 *pui32StrLen)
 {
-	IMG_CHAR *pszStr = *ppszStr;
-	IMG_UINT32 ui32StrLen = *pui32StrLen;
-	IMG_INT32 i32Count;
-	BT *pBT;
+	char *pszStr = *ppszStr;
+	u32 ui32StrLen = *pui32StrLen;
+	s32 i32Count;
+	struct BT *pBT;
 
 	CHECK_SPACE(ui32StrLen);
 	i32Count = OSSNPrintf(pszStr, 100, "\nArena '%s':\n", pArena->name);
@@ -1054,25 +1004,25 @@
 	i32Count = OSSNPrintf(pszStr, 100, "  segment Chain:\n");
 	UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 
-	if (pArena->pHeadSegment != IMG_NULL &&
-	    pArena->pHeadSegment->pPrevSegment != IMG_NULL) {
+	if (pArena->pHeadSegment != NULL &&
+	    pArena->pHeadSegment->pPrevSegment != NULL) {
 		CHECK_SPACE(ui32StrLen);
 		i32Count =
 		    OSSNPrintf(pszStr, 100,
-			       "  error: head boundary tag has invalid pPrevSegment\n");
+		       "  error: head boundary tag has invalid pPrevSegment\n");
 		UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 	}
 
-	if (pArena->pTailSegment != IMG_NULL &&
-	    pArena->pTailSegment->pNextSegment != IMG_NULL) {
+	if (pArena->pTailSegment != NULL &&
+	    pArena->pTailSegment->pNextSegment != NULL) {
 		CHECK_SPACE(ui32StrLen);
 		i32Count =
 		    OSSNPrintf(pszStr, 100,
-			       "  error: tail boundary tag has invalid pNextSegment\n");
+		       "  error: tail boundary tag has invalid pNextSegment\n");
 		UPDATE_SPACE(pszStr, i32Count, ui32StrLen);
 	}
 
-	for (pBT = pArena->pHeadSegment; pBT != IMG_NULL;
+	for (pBT = pArena->pHeadSegment; pBT != NULL;
 	     pBT = pBT->pNextSegment) {
 		CHECK_SPACE(ui32StrLen);
 		i32Count =
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/ra.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/ra.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -31,99 +31,72 @@
 #include "hash.h"
 #include "osfunc.h"
 
-typedef struct _RA_ARENA_ RA_ARENA;
-typedef struct _BM_MAPPING_ BM_MAPPING;
+struct RA_ARENA;
+struct BM_MAPPING;
 
 #define RA_STATS
 
-struct _RA_STATISTICS_ {
-
-	IMG_UINT32 uSpanCount;
-
-	IMG_UINT32 uLiveSegmentCount;
-
-	IMG_UINT32 uFreeSegmentCount;
-
-	IMG_UINT32 uTotalResourceCount;
-
-	IMG_UINT32 uFreeResourceCount;
-
-	IMG_UINT32 uCumulativeAllocs;
-
-	IMG_UINT32 uCumulativeFrees;
-
-	IMG_UINT32 uImportCount;
-
-	IMG_UINT32 uExportCount;
+struct RA_STATISTICS {
+	u32 uSpanCount;
+	u32 uLiveSegmentCount;
+	u32 uFreeSegmentCount;
+	u32 uTotalResourceCount;
+	u32 uFreeResourceCount;
+	u32 uCumulativeAllocs;
+	u32 uCumulativeFrees;
+	u32 uImportCount;
+	u32 uExportCount;
 };
-typedef struct _RA_STATISTICS_ RA_STATISTICS;
 
-struct _RA_SEGMENT_DETAILS_ {
-	IMG_UINT32 uiSize;
-	IMG_CPU_PHYADDR sCpuPhyAddr;
-	IMG_HANDLE hSegment;
+struct RA_SEGMENT_DETAILS {
+	u32 uiSize;
+	struct IMG_CPU_PHYADDR sCpuPhyAddr;
+	void *hSegment;
 };
-typedef struct _RA_SEGMENT_DETAILS_ RA_SEGMENT_DETAILS;
 
-RA_ARENA *RA_Create(IMG_CHAR * name,
-		    IMG_UINTPTR_T base,
-		    IMG_SIZE_T uSize,
-		    BM_MAPPING * psMapping,
-		    IMG_SIZE_T uQuantum,
-		    IMG_BOOL(*alloc) (IMG_VOID * _h,
-				      IMG_SIZE_T uSize,
-				      IMG_SIZE_T * pActualSize,
-				      BM_MAPPING ** ppsMapping,
-				      IMG_UINT32 uFlags,
-				      IMG_UINTPTR_T * pBase),
-		    IMG_VOID(*free) (IMG_VOID *,
-				     IMG_UINTPTR_T,
-				     BM_MAPPING * psMapping),
-		    IMG_VOID(*backingstore_free) (IMG_VOID *,
-						  IMG_UINT32,
-						  IMG_UINT32,
-						  IMG_HANDLE),
-		    IMG_VOID * import_handle);
-
-void RA_Delete(RA_ARENA * pArena);
-
-IMG_BOOL RA_Add(RA_ARENA * pArena, IMG_UINTPTR_T base, IMG_SIZE_T uSize);
-
-IMG_BOOL
-RA_Alloc(RA_ARENA * pArena,
-	 IMG_SIZE_T uSize,
-	 IMG_SIZE_T * pActualSize,
-	 BM_MAPPING ** ppsMapping,
-	 IMG_UINT32 uFlags,
-	 IMG_UINT32 uAlignment,
-	 IMG_UINT32 uAlignmentOffset, IMG_UINTPTR_T * pBase);
+struct RA_ARENA *RA_Create(char *name, u32 base, size_t uSize,
+		    struct BM_MAPPING *psMapping, size_t uQuantum,
+		    IMG_BOOL (*alloc)(void *_h, size_t uSize,
+				      size_t *pActualSize,
+				      struct BM_MAPPING **ppsMapping,
+				      u32 uFlags, u32 *pBase),
+		    void (*free)(void *, u32, struct BM_MAPPING *psMapping),
+		    void (*backingstore_free)(void *, u32, u32, void *),
+		    void *import_handle);
+
+void RA_Delete(struct RA_ARENA *pArena);
+
+IMG_BOOL RA_Add(struct RA_ARENA *pArena, u32 base, size_t uSize);
+
+IMG_BOOL RA_Alloc(struct RA_ARENA *pArena, size_t uSize, size_t *pActualSize,
+	 struct BM_MAPPING **ppsMapping, u32 uFlags, u32 uAlignment,
+	 u32 uAlignmentOffset, u32 *pBase);
 
-void RA_Free(RA_ARENA * pArena, IMG_UINTPTR_T base, IMG_BOOL bFreeBackingStore);
+void RA_Free(struct RA_ARENA *pArena, u32 base, IMG_BOOL bFreeBackingStore);
 
 #ifdef RA_STATS
 
-#define CHECK_SPACE(total)					\
-{											\
-	if(total<100) 							\
+#define CHECK_SPACE(total)				\
+{							\
+	if (total < 100)				\
 		return PVRSRV_ERROR_INVALID_PARAMS;	\
 }
 
-#define UPDATE_SPACE(str, count, total)		\
-{											\
-	if(count == -1)					 		\
+#define UPDATE_SPACE(str, count, total)			\
+{							\
+	if (count == -1)				\
 		return PVRSRV_ERROR_INVALID_PARAMS;	\
-	else									\
-	{										\
-		str += count;						\
-		total -= count;						\
-	}										\
+	else {						\
+		str += count;				\
+		total -= count;				\
+	}						\
 }
 
-IMG_BOOL RA_GetNextLiveSegment(IMG_HANDLE hArena,
-			       RA_SEGMENT_DETAILS * psSegDetails);
+IMG_BOOL RA_GetNextLiveSegment(void *hArena,
+			       struct RA_SEGMENT_DETAILS *psSegDetails);
 
-PVRSRV_ERROR RA_GetStats(RA_ARENA * pArena,
-			 IMG_CHAR ** ppszStr, IMG_UINT32 * pui32StrLen);
+enum PVRSRV_ERROR RA_GetStats(struct RA_ARENA *pArena,
+			 char **ppszStr, u32 *pui32StrLen);
 
 #endif
 
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/regpaths.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/**********************************************************************
- *
- * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
- * See the GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
- * The full GNU General Public License is included in this distribution in
- * the file called "COPYING".
- *
- * Contact Information:
- * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
- *
- ******************************************************************************/
-
-#ifndef __REGPATHS_H__
-#define __REGPATHS_H__
-
-#define POWERVR_REG_ROOT 	   			"Drivers\\Display\\PowerVR"
-#define POWERVR_CHIP_KEY				"\\SGX1\\"
-
-#define POWERVR_EURASIA_KEY				"PowerVREurasia\\"
-
-#define POWERVR_SERVICES_KEY			"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\PowerVR\\"
-
-#define PVRSRV_REGISTRY_ROOT			POWERVR_EURASIA_KEY "HWSettings\\PVRSRVKM"
-
-#define MAX_REG_STRING_SIZE 128
-
-#endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/resman.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/resman.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -39,85 +39,81 @@
 
 static DECLARE_MUTEX(lock);
 
-#define ACQUIRE_SYNC_OBJ  do {							\
-		if (in_interrupt()) { 							\
-			printk ("ISR cannot take RESMAN mutex\n"); 	\
-			BUG(); 										\
-		} 												\
-		else down (&lock); 								\
+#define ACQUIRE_SYNC_OBJ  do {						   \
+		if (in_interrupt()) {					   \
+			printk(KERN_ERR "ISR cannot take RESMAN mutex\n"); \
+			BUG();						   \
+		} else {						   \
+			down(&lock);					   \
+		}							   \
 } while (0)
-#define RELEASE_SYNC_OBJ up (&lock)
+#define RELEASE_SYNC_OBJ up(&lock)
 
 
 #define RESMAN_SIGNATURE 0x12345678
 
-typedef struct _RESMAN_ITEM_ {
+struct RESMAN_ITEM {
 #ifdef DEBUG
-	IMG_UINT32 ui32Signature;
+	u32 ui32Signature;
 #endif
-	struct _RESMAN_ITEM_ **ppsThis;
-	struct _RESMAN_ITEM_ *psNext;
+	struct RESMAN_ITEM **ppsThis;
+	struct RESMAN_ITEM *psNext;
 
-	IMG_UINT32 ui32Flags;
-	IMG_UINT32 ui32ResType;
+	u32 ui32Flags;
+	u32 ui32ResType;
 
-	IMG_PVOID pvParam;
-	IMG_UINT32 ui32Param;
+	void *pvParam;
+	u32 ui32Param;
 
-	RESMAN_FREE_FN pfnFreeResource;
-} RESMAN_ITEM;
+	enum PVRSRV_ERROR (*pfnFreeResource)(void *pvParam, u32 ui32Param);
+};
 
-typedef struct _RESMAN_CONTEXT_ {
+struct RESMAN_CONTEXT {
 #ifdef DEBUG
-	IMG_UINT32 ui32Signature;
+	u32 ui32Signature;
 #endif
-	struct _RESMAN_CONTEXT_ **ppsThis;
-	struct _RESMAN_CONTEXT_ *psNext;
-
-	PVRSRV_PER_PROCESS_DATA *psPerProc;
-
-	RESMAN_ITEM *psResItemList;
-
-} RESMAN_CONTEXT;
+	struct RESMAN_CONTEXT **ppsThis;
+	struct RESMAN_CONTEXT *psNext;
+	struct PVRSRV_PER_PROCESS_DATA *psPerProc;
+	struct RESMAN_ITEM *psResItemList;
+
+};
+
+struct RESMAN_LIST {
+	struct RESMAN_CONTEXT *psContextList;
+};
 
-typedef struct {
-	RESMAN_CONTEXT *psContextList;
-
-} RESMAN_LIST, *PRESMAN_LIST;
-
-PRESMAN_LIST gpsResList = IMG_NULL;
+static struct RESMAN_LIST *gpsResList;
 
 #define PRINT_RESLIST(x, y, z)
 
-static PVRSRV_ERROR FreeResourceByPtr(RESMAN_ITEM * psItem,
-				      IMG_BOOL bExecuteCallback);
-
-static PVRSRV_ERROR FreeResourceByCriteria(PRESMAN_CONTEXT psContext,
-					   IMG_UINT32 ui32SearchCriteria,
-					   IMG_UINT32 ui32ResType,
-					   IMG_PVOID pvParam,
-					   IMG_UINT32 ui32Param,
+static void FreeResourceByPtr(struct RESMAN_ITEM *psItem,
 					   IMG_BOOL bExecuteCallback);
 
+static int FreeResourceByCriteria(struct RESMAN_CONTEXT *psContext,
+		u32 ui32SearchCriteria,
+		u32 ui32ResType, void *pvParam,
+		u32 ui32Param,
+		IMG_BOOL bExecuteCallback);
+
 #ifdef DEBUG
-static IMG_VOID ValidateResList(PRESMAN_LIST psResList);
+static void ValidateResList(struct RESMAN_LIST *psResList);
 #define VALIDATERESLIST() ValidateResList(gpsResList)
 #else
 #define VALIDATERESLIST()
 #endif
 
-PVRSRV_ERROR ResManInit(IMG_VOID)
+enum PVRSRV_ERROR ResManInit(void)
 {
-	if (gpsResList == IMG_NULL) {
+	if (gpsResList == NULL) {
 
 		if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 			       sizeof(*gpsResList),
-			       (IMG_VOID **) & gpsResList,
-			       IMG_NULL) != PVRSRV_OK) {
+			       (void **) &gpsResList,
+			       NULL) != PVRSRV_OK)
 			return PVRSRV_ERROR_OUT_OF_MEMORY;
-		}
 
-		gpsResList->psContextList = IMG_NULL;
+		gpsResList->psContextList = NULL;
 
 		VALIDATERESLIST();
 	}
@@ -125,33 +121,30 @@
 	return PVRSRV_OK;
 }
 
-IMG_VOID ResManDeInit(IMG_VOID)
+void ResManDeInit(void)
 {
-	if (gpsResList != IMG_NULL) {
+	if (gpsResList != NULL)
 
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(*gpsResList),
-			  gpsResList, IMG_NULL);
-	}
+			  gpsResList, NULL);
 }
 
-PVRSRV_ERROR PVRSRVResManConnect(IMG_HANDLE hPerProc,
-				 PRESMAN_CONTEXT * phResManContext)
+enum PVRSRV_ERROR PVRSRVResManConnect(void *hPerProc,
+				 struct RESMAN_CONTEXT **phResManContext)
 {
-	PVRSRV_ERROR eError;
-	PRESMAN_CONTEXT psResManContext;
+	enum PVRSRV_ERROR eError;
+	struct RESMAN_CONTEXT *psResManContext;
 
 	ACQUIRE_SYNC_OBJ;
 
 	VALIDATERESLIST();
 
 	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(*psResManContext),
-			    (IMG_VOID **) & psResManContext, IMG_NULL);
+			    (void **) &psResManContext, NULL);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "PVRSRVResManConnect: ERROR allocating new RESMAN context struct"));
-
+		PVR_DPF(PVR_DBG_ERROR, "PVRSRVResManConnect: "
+			 "ERROR allocating new RESMAN context struct");
 		VALIDATERESLIST();
-
 		RELEASE_SYNC_OBJ;
 
 		return eError;
@@ -159,15 +152,14 @@
 #ifdef DEBUG
 	psResManContext->ui32Signature = RESMAN_SIGNATURE;
 #endif
-	psResManContext->psResItemList = IMG_NULL;
+	psResManContext->psResItemList = NULL;
 	psResManContext->psPerProc = hPerProc;
 
 	psResManContext->psNext = gpsResList->psContextList;
 	psResManContext->ppsThis = &gpsResList->psContextList;
 	gpsResList->psContextList = psResManContext;
-	if (psResManContext->psNext) {
+	if (psResManContext->psNext)
 		psResManContext->psNext->ppsThis = &(psResManContext->psNext);
-	}
 
 	VALIDATERESLIST();
 
@@ -178,123 +170,107 @@
 	return PVRSRV_OK;
 }
 
-IMG_VOID PVRSRVResManDisconnect(PRESMAN_CONTEXT psResManContext,
-				IMG_BOOL bKernelContext)
+static inline bool warn_unfreed_res(void)
+{
+	return !(current->flags & PF_SIGNALED);
+}
+
+static int free_one_res(struct RESMAN_CONTEXT *ctx, u32 restype)
+{
+	int freed;
+
+	freed = FreeResourceByCriteria(ctx, RESMAN_CRITERIA_RESTYPE, restype,
+			NULL, 0, IMG_TRUE);
+	if (freed && warn_unfreed_res())
+		PVR_DPF(PVR_DBG_WARNING, "pvr: %s: cleaning up %d "
+				"unfreed resource of type %d\n",
+				current->comm, freed, restype);
+
+	return freed;
+}
+
+
+void PVRSRVResManDisconnect(struct RESMAN_CONTEXT *ctx, IMG_BOOL bKernelContext)
 {
 
 	ACQUIRE_SYNC_OBJ;
 
 	VALIDATERESLIST();
 
-	PRINT_RESLIST(gpsResList, psResManContext, IMG_TRUE);
+	PRINT_RESLIST(gpsResList, ctx, IMG_TRUE);
 
 	if (!bKernelContext) {
+		int i = 0;
+		i += free_one_res(ctx, RESMAN_TYPE_OS_USERMODE_MAPPING);
+		i += free_one_res(ctx, RESMAN_TYPE_EVENT_OBJECT);
+		i += free_one_res(ctx, RESMAN_TYPE_HW_RENDER_CONTEXT);
+		i += free_one_res(ctx, RESMAN_TYPE_HW_TRANSFER_CONTEXT);
+		i += free_one_res(ctx, RESMAN_TYPE_HW_2D_CONTEXT);
+		i += free_one_res(ctx, RESMAN_TYPE_TRANSFER_CONTEXT);
+		i += free_one_res(ctx, RESMAN_TYPE_SHARED_PB_DESC_CREATE_LOCK);
+		i += free_one_res(ctx, RESMAN_TYPE_SHARED_PB_DESC);
+		i += free_one_res(ctx, RESMAN_TYPE_DISPLAYCLASS_SWAPCHAIN);
+		i += free_one_res(ctx, RESMAN_TYPE_DISPLAYCLASS_DEVICE);
+		i += free_one_res(ctx, RESMAN_TYPE_BUFFERCLASS_DEVICE);
+		i += free_one_res(ctx, RESMAN_TYPE_DEVICECLASSMEM_MAPPING);
+		i += free_one_res(ctx, RESMAN_TYPE_DEVICEMEM_WRAP);
+		i += free_one_res(ctx, RESMAN_TYPE_DEVICEMEM_MAPPING);
+		i += free_one_res(ctx, RESMAN_TYPE_KERNEL_DEVICEMEM_ALLOCATION);
+		i += free_one_res(ctx, RESMAN_TYPE_DEVICEMEM_ALLOCATION);
+		i += free_one_res(ctx, RESMAN_TYPE_DEVICEMEM_CONTEXT);
+
+		if (i && warn_unfreed_res())
+			printk(KERN_DEBUG "pvr: %s: cleaning up %d "
+					"unfreed resources\n",
+					current->comm, i);
 
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE,
-				       RESMAN_TYPE_OS_USERMODE_MAPPING, 0, 0,
-				       IMG_TRUE);
-
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE,
-				       RESMAN_TYPE_EVENT_OBJECT, 0, 0,
-				       IMG_TRUE);
-
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE,
-				       RESMAN_TYPE_HW_RENDER_CONTEXT, 0, 0,
-				       IMG_TRUE);
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE,
-				       RESMAN_TYPE_HW_TRANSFER_CONTEXT, 0, 0,
-				       IMG_TRUE);
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE,
-				       RESMAN_TYPE_HW_2D_CONTEXT, 0, 0,
-				       IMG_TRUE);
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE,
-				       RESMAN_TYPE_TRANSFER_CONTEXT, 0, 0,
-				       IMG_TRUE);
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE,
-				       RESMAN_TYPE_SHARED_PB_DESC_CREATE_LOCK,
-				       0, 0, IMG_TRUE);
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE,
-				       RESMAN_TYPE_SHARED_PB_DESC, 0, 0,
-				       IMG_TRUE);
-
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE,
-				       RESMAN_TYPE_DISPLAYCLASS_SWAPCHAIN, 0, 0,
-				       IMG_TRUE);
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE,
-				       RESMAN_TYPE_DISPLAYCLASS_DEVICE, 0, 0,
-				       IMG_TRUE);
-
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE,
-				       RESMAN_TYPE_BUFFERCLASS_DEVICE, 0, 0,
-				       IMG_TRUE);
-
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE,
-				       RESMAN_TYPE_DEVICECLASSMEM_MAPPING, 0, 0,
-				       IMG_TRUE);
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE,
-				       RESMAN_TYPE_DEVICEMEM_WRAP, 0, 0,
-				       IMG_TRUE);
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE,
-				       RESMAN_TYPE_DEVICEMEM_MAPPING, 0, 0,
-				       IMG_TRUE);
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE,
-				       RESMAN_TYPE_KERNEL_DEVICEMEM_ALLOCATION,
-				       0, 0, IMG_TRUE);
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE,
-				       RESMAN_TYPE_DEVICEMEM_ALLOCATION, 0, 0,
-				       IMG_TRUE);
-		FreeResourceByCriteria(psResManContext, RESMAN_CRITERIA_RESTYPE,
-				       RESMAN_TYPE_DEVICEMEM_CONTEXT, 0, 0,
-				       IMG_TRUE);
 	}
 
-	PVR_ASSERT(psResManContext->psResItemList == IMG_NULL);
+	PVR_ASSERT(ctx->psResItemList == NULL);
+
+	*(ctx->ppsThis) = ctx->psNext;
+	if (ctx->psNext)
+		ctx->psNext->ppsThis = ctx->ppsThis;
 
-	*(psResManContext->ppsThis) = psResManContext->psNext;
-	if (psResManContext->psNext) {
-		psResManContext->psNext->ppsThis = psResManContext->ppsThis;
-	}
-
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(RESMAN_CONTEXT),
-		  psResManContext, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct RESMAN_CONTEXT),
+		  ctx, NULL);
 
 	VALIDATERESLIST();
 
-	PRINT_RESLIST(gpsResList, psResManContext, IMG_FALSE);
+	PRINT_RESLIST(gpsResList, ctx, IMG_FALSE);
 
 	RELEASE_SYNC_OBJ;
 }
 
-PRESMAN_ITEM ResManRegisterRes(PRESMAN_CONTEXT psResManContext,
-			       IMG_UINT32 ui32ResType,
-			       IMG_PVOID pvParam,
-			       IMG_UINT32 ui32Param,
-			       RESMAN_FREE_FN pfnFreeResource)
+struct RESMAN_ITEM *ResManRegisterRes(struct RESMAN_CONTEXT *psResManContext,
+			   u32 ui32ResType, void *pvParam, u32 ui32Param,
+			   enum PVRSRV_ERROR (*pfnFreeResource)(void *pvParam,
+								u32 ui32Param))
 {
-	PRESMAN_ITEM psNewResItem;
+	struct RESMAN_ITEM *psNewResItem;
 
-	PVR_ASSERT(psResManContext != IMG_NULL);
+	PVR_ASSERT(psResManContext != NULL);
 	PVR_ASSERT(ui32ResType != 0);
 
 	ACQUIRE_SYNC_OBJ;
 
 	VALIDATERESLIST();
 
-	PVR_DPF((PVR_DBG_MESSAGE, "ResManRegisterRes: register resource "
+	PVR_DPF(PVR_DBG_MESSAGE, "ResManRegisterRes: register resource "
 		 "Context 0x%x, ResType 0x%x, pvParam 0x%x, ui32Param 0x%x, "
 		 "FreeFunc %08X",
-		 psResManContext, ui32ResType, (IMG_UINT32) pvParam,
-		 ui32Param, pfnFreeResource));
+		 psResManContext, ui32ResType, (u32) pvParam,
+		 ui32Param, pfnFreeResource);
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(RESMAN_ITEM), (IMG_VOID **) & psNewResItem,
-		       IMG_NULL) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR, "ResManRegisterRes: "
-			 "ERROR allocating new resource item"));
+		       sizeof(struct RESMAN_ITEM), (void **) &psNewResItem,
+		       NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "ResManRegisterRes: "
+			 "ERROR allocating new resource item");
 
 		RELEASE_SYNC_OBJ;
 
-		return ((PRESMAN_ITEM) IMG_NULL);
+		return (struct RESMAN_ITEM *)NULL;
 	}
 
 #ifdef DEBUG
@@ -309,125 +285,108 @@
 	psNewResItem->ppsThis = &psResManContext->psResItemList;
 	psNewResItem->psNext = psResManContext->psResItemList;
 	psResManContext->psResItemList = psNewResItem;
-	if (psNewResItem->psNext) {
+	if (psNewResItem->psNext)
 		psNewResItem->psNext->ppsThis = &psNewResItem->psNext;
-	}
 
 	VALIDATERESLIST();
 
 	RELEASE_SYNC_OBJ;
 
-	return (psNewResItem);
+	return psNewResItem;
 }
 
-PVRSRV_ERROR ResManFreeResByPtr(RESMAN_ITEM * psResItem)
+void ResManFreeResByPtr(struct RESMAN_ITEM *psResItem)
 {
-	PVRSRV_ERROR eError;
+	BUG_ON(!psResItem);
 
-	PVR_ASSERT(psResItem != IMG_NULL);
-
-	if (psResItem == IMG_NULL) {
-		PVR_DPF((PVR_DBG_MESSAGE,
-			 "ResManFreeResByPtr: NULL ptr - nothing to do"));
-		return PVRSRV_OK;
-	}
-
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "ResManFreeResByPtr: freeing resource at %08X", psResItem));
+	PVR_DPF(PVR_DBG_MESSAGE,
+		 "ResManFreeResByPtr: freeing resource at %08X", psResItem);
 
 	ACQUIRE_SYNC_OBJ;
 
 	VALIDATERESLIST();
 
-	eError = FreeResourceByPtr(psResItem, IMG_TRUE);
+	FreeResourceByPtr(psResItem, IMG_TRUE);
 
 	VALIDATERESLIST();
 
 	RELEASE_SYNC_OBJ;
-
-	return (eError);
 }
 
-PVRSRV_ERROR ResManFreeResByCriteria(PRESMAN_CONTEXT psResManContext,
-				     IMG_UINT32 ui32SearchCriteria,
-				     IMG_UINT32 ui32ResType,
-				     IMG_PVOID pvParam, IMG_UINT32 ui32Param)
+void ResManFreeResByCriteria(struct RESMAN_CONTEXT *psResManContext,
+		u32 ui32SearchCriteria,
+		u32 ui32ResType,
+		void *pvParam, u32 ui32Param)
 {
-	PVRSRV_ERROR eError;
-
-	PVR_ASSERT(psResManContext != IMG_NULL);
+	PVR_ASSERT(psResManContext != NULL);
 
 	ACQUIRE_SYNC_OBJ;
 
 	VALIDATERESLIST();
 
-	PVR_DPF((PVR_DBG_MESSAGE, "ResManFreeResByCriteria: "
-		 "Context 0x%x, Criteria 0x%x, Type 0x%x, Addr 0x%x, Param 0x%x",
+	PVR_DPF(PVR_DBG_MESSAGE, "ResManFreeResByCriteria: "
+		"Context 0x%x, Criteria 0x%x, Type 0x%x, Addr 0x%x, Param 0x%x",
 		 psResManContext, ui32SearchCriteria, ui32ResType,
-		 (IMG_UINT32) pvParam, ui32Param));
+		 (u32) pvParam, ui32Param);
 
-	eError = FreeResourceByCriteria(psResManContext, ui32SearchCriteria,
+	FreeResourceByCriteria(psResManContext, ui32SearchCriteria,
 					ui32ResType, pvParam, ui32Param,
 					IMG_TRUE);
 
 	VALIDATERESLIST();
 
 	RELEASE_SYNC_OBJ;
-
-	return eError;
 }
 
-IMG_VOID ResManDissociateRes(RESMAN_ITEM * psResItem,
-			     PRESMAN_CONTEXT psNewResManContext)
+void ResManDissociateRes(struct RESMAN_ITEM *psResItem,
+			     struct RESMAN_CONTEXT *psNewResManContext)
 {
-	PVR_ASSERT(psResItem != IMG_NULL);
+	PVR_ASSERT(psResItem != NULL);
 	PVR_ASSERT(psResItem->ui32Signature == RESMAN_SIGNATURE);
 
-	if (psNewResManContext != IMG_NULL) {
+	if (psNewResManContext != NULL) {
 
-		if (psResItem->psNext) {
+		if (psResItem->psNext)
 			psResItem->psNext->ppsThis = psResItem->ppsThis;
-		}
 		*psResItem->ppsThis = psResItem->psNext;
 
 		psResItem->ppsThis = &psNewResManContext->psResItemList;
 		psResItem->psNext = psNewResManContext->psResItemList;
 		psNewResManContext->psResItemList = psResItem;
-		if (psResItem->psNext) {
+		if (psResItem->psNext)
 			psResItem->psNext->ppsThis = &psResItem->psNext;
-		}
 	} else {
 		FreeResourceByPtr(psResItem, IMG_FALSE);
 	}
 }
 
-IMG_INTERNAL PVRSRV_ERROR ResManFindResourceByPtr(PRESMAN_CONTEXT
-						  psResManContext,
-						  RESMAN_ITEM * psItem)
+IMG_INTERNAL enum PVRSRV_ERROR ResManFindResourceByPtr(
+					struct RESMAN_CONTEXT *psResManContext,
+					struct RESMAN_ITEM *psItem)
 {
-	RESMAN_ITEM *psCurItem;
+	struct RESMAN_ITEM *psCurItem;
 
-	PVR_ASSERT(psResManContext != IMG_NULL);
-	PVR_ASSERT(psItem != IMG_NULL);
+	PVR_ASSERT(psResManContext != NULL);
+	PVR_ASSERT(psItem != NULL);
 	PVR_ASSERT(psItem->ui32Signature == RESMAN_SIGNATURE);
 
 	ACQUIRE_SYNC_OBJ;
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "FindResourceByPtr: psItem=%08X, psItem->psNext=%08X",
-		 psItem, psItem->psNext));
+		 psItem, psItem->psNext);
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "FindResourceByPtr: Resource Ctx 0x%x, Type 0x%x, Addr 0x%x, "
 		 "Param 0x%x, FnCall %08X, Flags 0x%x",
 		 psResManContext,
-		 psItem->ui32ResType, (IMG_UINT32) psItem->pvParam,
+		 psItem->ui32ResType, (u32) psItem->pvParam,
 		 psItem->ui32Param, psItem->pfnFreeResource,
-		 psItem->ui32Flags));
+		 psItem->ui32Flags);
 
 	psCurItem = psResManContext->psResItemList;
 
-	while (psCurItem != IMG_NULL) {
+	while (psCurItem != NULL) {
 
 		if (psCurItem != psItem) {
 
@@ -444,141 +403,122 @@
 	return PVRSRV_ERROR_NOT_OWNER;
 }
 
-static PVRSRV_ERROR FreeResourceByPtr(RESMAN_ITEM * psItem,
+static void FreeResourceByPtr(struct RESMAN_ITEM *psItem,
 				      IMG_BOOL bExecuteCallback)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
-
-	PVR_ASSERT(psItem != IMG_NULL);
+	PVR_ASSERT(psItem != NULL);
 	PVR_ASSERT(psItem->ui32Signature == RESMAN_SIGNATURE);
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "FreeResourceByPtr: psItem=%08X, psItem->psNext=%08X",
-		 psItem, psItem->psNext));
+		 psItem, psItem->psNext);
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "FreeResourceByPtr: Type 0x%x, Addr 0x%x, "
 		 "Param 0x%x, FnCall %08X, Flags 0x%x",
-		 psItem->ui32ResType, (IMG_UINT32) psItem->pvParam,
+		 psItem->ui32ResType, (u32) psItem->pvParam,
 		 psItem->ui32Param, psItem->pfnFreeResource,
-		 psItem->ui32Flags));
+		 psItem->ui32Flags);
 
-	if (psItem->psNext) {
+	if (psItem->psNext)
 		psItem->psNext->ppsThis = psItem->ppsThis;
-	}
 	*psItem->ppsThis = psItem->psNext;
 
 	RELEASE_SYNC_OBJ;
 
-	if (bExecuteCallback) {
-		eError =
-		    psItem->pfnFreeResource(psItem->pvParam, psItem->ui32Param);
-		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "FreeResourceByPtr: ERROR calling FreeResource function"));
-		}
-	}
+	if (bExecuteCallback &&
+		psItem->pfnFreeResource(psItem->pvParam, psItem->ui32Param) !=
+			PVRSRV_OK)
+		PVR_DPF(PVR_DBG_ERROR, "FreeResourceByPtr: "
+				"ERROR calling FreeResource function");
 
 	ACQUIRE_SYNC_OBJ;
 
-	if (OSFreeMem
-	    (PVRSRV_OS_PAGEABLE_HEAP, sizeof(RESMAN_ITEM), psItem, IMG_NULL)
-	    != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "FreeResourceByPtr: ERROR freeing resource list item memory"));
-		eError = PVRSRV_ERROR_GENERIC;
-	}
-
-	return (eError);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(struct RESMAN_ITEM),
+			psItem, NULL);
 }
 
-static PVRSRV_ERROR FreeResourceByCriteria(PRESMAN_CONTEXT psResManContext,
-					   IMG_UINT32 ui32SearchCriteria,
-					   IMG_UINT32 ui32ResType,
-					   IMG_PVOID pvParam,
-					   IMG_UINT32 ui32Param,
-					   IMG_BOOL bExecuteCallback)
-{
-	PRESMAN_ITEM psCurItem;
-	IMG_BOOL bMatch;
-	PVRSRV_ERROR eError = PVRSRV_OK;
+static int FreeResourceByCriteria(struct RESMAN_CONTEXT *psResManContext,
+				u32 ui32SearchCriteria, u32 ui32ResType,
+				void *pvParam, u32 ui32Param,
+				IMG_BOOL bExecuteCallback)
+{
+	struct RESMAN_ITEM *psCurItem;
+	bool bMatch;
+	int freed = 0;
 
 	psCurItem = psResManContext->psResItemList;
 
-	while (psCurItem != IMG_NULL) {
+	while (psCurItem != NULL) {
 
 		bMatch = IMG_TRUE;
 
 		if ((ui32SearchCriteria & RESMAN_CRITERIA_RESTYPE) &&
-		    psCurItem->ui32ResType != ui32ResType) {
+		    psCurItem->ui32ResType != ui32ResType)
 			bMatch = IMG_FALSE;
-		}
-
 		else if ((ui32SearchCriteria & RESMAN_CRITERIA_PVOID_PARAM) &&
-			 psCurItem->pvParam != pvParam) {
+			 psCurItem->pvParam != pvParam)
 			bMatch = IMG_FALSE;
-		}
 
-		else if ((ui32SearchCriteria & RESMAN_CRITERIA_UI32_PARAM) &&
-			 psCurItem->ui32Param != ui32Param) {
+		else
+		if ((ui32SearchCriteria & RESMAN_CRITERIA_UI32_PARAM) &&
+			 psCurItem->ui32Param != ui32Param)
 			bMatch = IMG_FALSE;
-		}
 
 		if (!bMatch) {
 
 			psCurItem = psCurItem->psNext;
 		} else {
 
-			eError = FreeResourceByPtr(psCurItem, bExecuteCallback);
-
-			if (eError != PVRSRV_OK) {
-				return eError;
-			}
-
+			FreeResourceByPtr(psCurItem, bExecuteCallback);
 			psCurItem = psResManContext->psResItemList;
+			freed++;
 		}
 	}
 
-	return eError;
+	return freed;
 }
 
 #ifdef DEBUG
-static IMG_VOID ValidateResList(PRESMAN_LIST psResList)
+static void ValidateResList(struct RESMAN_LIST *psResList)
 {
-	PRESMAN_ITEM psCurItem, *ppsThisItem;
-	PRESMAN_CONTEXT psCurContext, *ppsThisContext;
+	struct RESMAN_ITEM *psCurItem, **ppsThisItem;
+	struct RESMAN_CONTEXT *psCurContext, **ppsThisContext;
 
-	if (psResList == IMG_NULL) {
-		PVR_DPF((PVR_DBG_MESSAGE,
-			 "ValidateResList: resman not initialised yet"));
+	if (psResList == NULL) {
+		PVR_DPF(PVR_DBG_MESSAGE,
+			 "ValidateResList: resman not initialised yet");
 		return;
 	}
 
 	psCurContext = psResList->psContextList;
 	ppsThisContext = &psResList->psContextList;
 
-	while (psCurContext != IMG_NULL) {
+	while (psCurContext != NULL) {
 
 		PVR_ASSERT(psCurContext->ui32Signature == RESMAN_SIGNATURE);
 		if (psCurContext->ppsThis != ppsThisContext) {
-			PVR_DPF((PVR_DBG_WARNING,
-				 "psCC=%08X psCC->ppsThis=%08X psCC->psNext=%08X ppsTC=%08X",
+			PVR_DPF(PVR_DBG_WARNING,
+			 "psCC=%08X psCC->ppsThis=%08X "
+			 "psCC->psNext=%08X ppsTC=%08X",
 				 psCurContext, psCurContext->ppsThis,
-				 psCurContext->psNext, ppsThisContext));
+				 psCurContext->psNext, ppsThisContext);
 			PVR_ASSERT(psCurContext->ppsThis == ppsThisContext);
 		}
 
 		psCurItem = psCurContext->psResItemList;
 		ppsThisItem = &psCurContext->psResItemList;
-		while (psCurItem != IMG_NULL) {
-
+		while (psCurItem != NULL) {
 			PVR_ASSERT(psCurItem->ui32Signature ==
 				   RESMAN_SIGNATURE);
 			if (psCurItem->ppsThis != ppsThisItem) {
-				PVR_DPF((PVR_DBG_WARNING,
-					 "psCurItem=%08X psCurItem->ppsThis=%08X psCurItem->psNext=%08X ppsThisItem=%08X",
+				PVR_DPF(PVR_DBG_WARNING,
+					 "psCurItem=%08X "
+					 "psCurItem->ppsThis=%08X "
+					 "psCurItem->psNext=%08X "
+					 "ppsThisItem=%08X",
 					 psCurItem, psCurItem->ppsThis,
-					 psCurItem->psNext, ppsThisItem));
+					 psCurItem->psNext, ppsThisItem);
 				PVR_ASSERT(psCurItem->ppsThis == ppsThisItem);
 			}
 
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/resman.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/resman.h
@@ -1,97 +1,90 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef __RESMAN_H__
 #define __RESMAN_H__
 
+enum {
+	RESMAN_TYPE_SHARED_PB_DESC = 1,
+	RESMAN_TYPE_SHARED_PB_DESC_CREATE_LOCK,
+	RESMAN_TYPE_HW_RENDER_CONTEXT,
+	RESMAN_TYPE_HW_TRANSFER_CONTEXT,
+	RESMAN_TYPE_HW_2D_CONTEXT,
+	RESMAN_TYPE_TRANSFER_CONTEXT,
+
+	RESMAN_TYPE_DISPLAYCLASS_SWAPCHAIN,
+	RESMAN_TYPE_DISPLAYCLASS_DEVICE,
+
+	RESMAN_TYPE_BUFFERCLASS_DEVICE,
+
+	RESMAN_TYPE_OS_USERMODE_MAPPING,
+
+	RESMAN_TYPE_DEVICEMEM_CONTEXT,
+	RESMAN_TYPE_DEVICECLASSMEM_MAPPING,
+	RESMAN_TYPE_DEVICEMEM_MAPPING,
+	RESMAN_TYPE_DEVICEMEM_WRAP,
+	RESMAN_TYPE_DEVICEMEM_ALLOCATION,
+	RESMAN_TYPE_EVENT_OBJECT,
+	RESMAN_TYPE_SHARED_MEM_INFO,
 
-	enum {
-
-		RESMAN_TYPE_SHARED_PB_DESC = 1,
-		RESMAN_TYPE_SHARED_PB_DESC_CREATE_LOCK,
-		RESMAN_TYPE_HW_RENDER_CONTEXT,
-		RESMAN_TYPE_HW_TRANSFER_CONTEXT,
-		RESMAN_TYPE_HW_2D_CONTEXT,
-		RESMAN_TYPE_TRANSFER_CONTEXT,
-
-		RESMAN_TYPE_DISPLAYCLASS_SWAPCHAIN,
-		RESMAN_TYPE_DISPLAYCLASS_DEVICE,
-
-		RESMAN_TYPE_BUFFERCLASS_DEVICE,
-
-		RESMAN_TYPE_OS_USERMODE_MAPPING,
-
-		RESMAN_TYPE_DEVICEMEM_CONTEXT,
-		RESMAN_TYPE_DEVICECLASSMEM_MAPPING,
-		RESMAN_TYPE_DEVICEMEM_MAPPING,
-		RESMAN_TYPE_DEVICEMEM_WRAP,
-		RESMAN_TYPE_DEVICEMEM_ALLOCATION,
-		RESMAN_TYPE_EVENT_OBJECT,
-		RESMAN_TYPE_SHARED_MEM_INFO,
-
-		RESMAN_TYPE_KERNEL_DEVICEMEM_ALLOCATION
-	};
+	RESMAN_TYPE_KERNEL_DEVICEMEM_ALLOCATION
+};
 
 #define RESMAN_CRITERIA_ALL				0x00000000
 #define RESMAN_CRITERIA_RESTYPE			0x00000001
 #define RESMAN_CRITERIA_PVOID_PARAM		0x00000002
 #define RESMAN_CRITERIA_UI32_PARAM		0x00000004
 
-	typedef PVRSRV_ERROR(*RESMAN_FREE_FN) (IMG_PVOID pvParam,
-					       IMG_UINT32 ui32Param);
 
-	typedef struct _RESMAN_ITEM_ *PRESMAN_ITEM;
-	typedef struct _RESMAN_CONTEXT_ *PRESMAN_CONTEXT;
+struct RESMAN_ITEM;
+struct RESMAN_CONTEXT;
+
+enum PVRSRV_ERROR ResManInit(void);
+void ResManDeInit(void);
+
+struct RESMAN_ITEM *ResManRegisterRes(struct RESMAN_CONTEXT *hResManContext,
+	u32 ui32ResType, void *pvParam, u32 ui32Param,
+	enum PVRSRV_ERROR (*pfnFreeResource)(void *pvParam, u32 ui32Param));
+
+void ResManFreeResByPtr(struct RESMAN_ITEM *psResItem);
+
+void ResManFreeResByCriteria(struct RESMAN_CONTEXT *hResManContext,
+		u32 ui32SearchCriteria, u32 ui32ResType, void *pvParam,
+		u32 ui32Param);
+
+void ResManDissociateRes(struct RESMAN_ITEM *psResItem,
+		struct RESMAN_CONTEXT *psNewResManContext);
+
+enum PVRSRV_ERROR ResManFindResourceByPtr(struct RESMAN_CONTEXT *hResManContext,
+		struct RESMAN_ITEM *psItem);
 
-	PVRSRV_ERROR ResManInit(IMG_VOID);
-	IMG_VOID ResManDeInit(IMG_VOID);
+enum PVRSRV_ERROR PVRSRVResManConnect(void *hPerProc,
+		struct RESMAN_CONTEXT **phResManContext);
 
-	PRESMAN_ITEM ResManRegisterRes(PRESMAN_CONTEXT hResManContext,
-				       IMG_UINT32 ui32ResType,
-				       IMG_PVOID pvParam,
-				       IMG_UINT32 ui32Param,
-				       RESMAN_FREE_FN pfnFreeResource);
-
-	PVRSRV_ERROR ResManFreeResByPtr(PRESMAN_ITEM psResItem);
-
-	PVRSRV_ERROR ResManFreeResByCriteria(PRESMAN_CONTEXT hResManContext,
-					     IMG_UINT32 ui32SearchCriteria,
-					     IMG_UINT32 ui32ResType,
-					     IMG_PVOID pvParam,
-					     IMG_UINT32 ui32Param);
-
-	IMG_VOID ResManDissociateRes(PRESMAN_ITEM psResItem,
-				     PRESMAN_CONTEXT psNewResManContext);
-
-	PVRSRV_ERROR ResManFindResourceByPtr(PRESMAN_CONTEXT hResManContext,
-					     PRESMAN_ITEM psItem);
-
-	PVRSRV_ERROR PVRSRVResManConnect(IMG_HANDLE hPerProc,
-					 PRESMAN_CONTEXT * phResManContext);
-	IMG_VOID PVRSRVResManDisconnect(PRESMAN_CONTEXT hResManContext,
-					IMG_BOOL bKernelContext);
+void PVRSRVResManDisconnect(struct RESMAN_CONTEXT *hResManContext,
+		IMG_BOOL bKernelContext);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/services.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/services.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -32,937 +32,183 @@
 #include "servicesext.h"
 #include "pdumpdefs.h"
 
-#define IMG_CONST const
+struct SYS_DATA;
 
-#define PVRSRV_MAX_CMD_SIZE		1024
+#define PVRSRV_MAX_CMD_SIZE			1024
 
-#define PVRSRV_MAX_DEVICES		16
+#define PVRSRV_MAX_DEVICES			16
 
-#define EVENTOBJNAME_MAXLENGTH (50)
+#define EVENTOBJNAME_MAXLENGTH			50
 
-#define PVRSRV_MEM_READ						(1UL<<0)
-#define PVRSRV_MEM_WRITE					(1UL<<1)
-#define PVRSRV_MEM_CACHE_CONSISTENT			(1UL<<2)
-#define PVRSRV_MEM_NO_SYNCOBJ				(1UL<<3)
-#define PVRSRV_MEM_INTERLEAVED				(1UL<<4)
-#define PVRSRV_MEM_DUMMY					(1UL<<5)
-#define PVRSRV_MEM_EDM_PROTECT				(1UL<<6)
-#define PVRSRV_MEM_ZERO						(1UL<<7)
+#define PVRSRV_MEM_READ				(1UL<<0)
+#define PVRSRV_MEM_WRITE			(1UL<<1)
+#define PVRSRV_MEM_CACHE_CONSISTENT		(1UL<<2)
+#define PVRSRV_MEM_NO_SYNCOBJ			(1UL<<3)
+#define PVRSRV_MEM_INTERLEAVED			(1UL<<4)
+#define PVRSRV_MEM_DUMMY			(1UL<<5)
+#define PVRSRV_MEM_EDM_PROTECT			(1UL<<6)
+#define PVRSRV_MEM_ZERO				(1UL<<7)
 #define PVRSRV_MEM_USER_SUPPLIED_DEVVADDR	(1UL<<8)
 #define PVRSRV_MEM_RAM_BACKED_ALLOCATION	(1UL<<9)
-#define PVRSRV_MEM_NO_RESMAN				(1UL<<10)
+#define PVRSRV_MEM_NO_RESMAN			(1UL<<10)
 
-#define PVRSRV_HAP_CACHED					(1UL<<12)
-#define PVRSRV_HAP_UNCACHED					(1UL<<13)
-#define PVRSRV_HAP_WRITECOMBINE				(1UL<<14)
-#define PVRSRV_HAP_CACHETYPE_MASK			(PVRSRV_HAP_CACHED|PVRSRV_HAP_UNCACHED|PVRSRV_HAP_WRITECOMBINE)
-#define PVRSRV_HAP_KERNEL_ONLY				(1UL<<15)
-#define PVRSRV_HAP_SINGLE_PROCESS			(1UL<<16)
-#define PVRSRV_HAP_MULTI_PROCESS			(1UL<<17)
+#define PVRSRV_HAP_CACHED			(1UL<<12)
+#define PVRSRV_HAP_UNCACHED			(1UL<<13)
+#define PVRSRV_HAP_WRITECOMBINE			(1UL<<14)
+#define PVRSRV_HAP_CACHETYPE_MASK		\
+	(PVRSRV_HAP_CACHED|PVRSRV_HAP_UNCACHED|PVRSRV_HAP_WRITECOMBINE)
+#define PVRSRV_HAP_KERNEL_ONLY			(1UL<<15)
+#define PVRSRV_HAP_SINGLE_PROCESS		(1UL<<16)
+#define PVRSRV_HAP_MULTI_PROCESS		(1UL<<17)
 #define PVRSRV_HAP_FROM_EXISTING_PROCESS	(1UL<<18)
-#define PVRSRV_HAP_NO_CPU_VIRTUAL			(1UL<<19)
-#define PVRSRV_HAP_MAPTYPE_MASK				(PVRSRV_HAP_KERNEL_ONLY \
-                                            |PVRSRV_HAP_SINGLE_PROCESS \
-                                            |PVRSRV_HAP_MULTI_PROCESS \
-                                            |PVRSRV_HAP_FROM_EXISTING_PROCESS \
-                                            |PVRSRV_HAP_NO_CPU_VIRTUAL)
+#define PVRSRV_HAP_NO_CPU_VIRTUAL		(1UL<<19)
+#define PVRSRV_HAP_MAPTYPE_MASK			(PVRSRV_HAP_KERNEL_ONLY \
+					    |PVRSRV_HAP_SINGLE_PROCESS \
+					    |PVRSRV_HAP_MULTI_PROCESS \
+					    |PVRSRV_HAP_FROM_EXISTING_PROCESS \
+					    |PVRSRV_HAP_NO_CPU_VIRTUAL)
 #define PVRSRV_MEM_BACKINGSTORE_FIELD_SHIFT	(24)
 
-#define PVRSRV_MAP_NOUSERVIRTUAL            (1UL<<27)
+#define PVRSRV_MAP_NOUSERVIRTUAL		(1UL<<27)
 
-#define PVRSRV_NO_CONTEXT_LOSS					0
-#define PVRSRV_SEVERE_LOSS_OF_CONTEXT			1
-#define PVRSRV_PRE_STATE_CHANGE_MASK			0x80
+#define PVRSRV_NO_CONTEXT_LOSS			0
+#define PVRSRV_SEVERE_LOSS_OF_CONTEXT		1
+#define PVRSRV_PRE_STATE_CHANGE_MASK		0x80
 
-#define PVRSRV_DEFAULT_DEV_COOKIE			(1)
+#define PVRSRV_DEFAULT_DEV_COOKIE		(1)
 
-#define PVRSRV_MISC_INFO_TIMER_PRESENT				(1UL<<0)
-#define PVRSRV_MISC_INFO_CLOCKGATE_PRESENT			(1UL<<1)
-#define PVRSRV_MISC_INFO_MEMSTATS_PRESENT			(1UL<<2)
+#define PVRSRV_MISC_INFO_TIMER_PRESENT		(1UL<<0)
+#define PVRSRV_MISC_INFO_CLOCKGATE_PRESENT	(1UL<<1)
+#define PVRSRV_MISC_INFO_MEMSTATS_PRESENT	(1UL<<2)
 #define PVRSRV_MISC_INFO_GLOBALEVENTOBJECT_PRESENT	(1UL<<3)
 
 #define PVRSRV_PDUMP_MAX_FILENAME_SIZE			20
 #define PVRSRV_PDUMP_MAX_COMMENT_SIZE			200
 
-#define PVRSRV_CHANGEDEVMEM_ATTRIBS_CACHECOHERENT		0x00000001
-
-#define PVRSRV_MAPEXTMEMORY_FLAGS_ALTERNATEVA			0x00000001
-#define PVRSRV_MAPEXTMEMORY_FLAGS_PHYSCONTIG			0x00000002
-
-	typedef enum _PVRSRV_DEVICE_TYPE_ {
-		PVRSRV_DEVICE_TYPE_UNKNOWN = 0,
-		PVRSRV_DEVICE_TYPE_MBX1 = 1,
-		PVRSRV_DEVICE_TYPE_MBX1_LITE = 2,
-
-		PVRSRV_DEVICE_TYPE_M24VA = 3,
-		PVRSRV_DEVICE_TYPE_MVDA2 = 4,
-		PVRSRV_DEVICE_TYPE_MVED1 = 5,
-		PVRSRV_DEVICE_TYPE_MSVDX = 6,
-
-		PVRSRV_DEVICE_TYPE_SGX = 7,
-
-		PVRSRV_DEVICE_TYPE_EXT = 8,
-
-		PVRSRV_DEVICE_TYPE_LAST = 8,
-
-		PVRSRV_DEVICE_TYPE_FORCE_I32 = 0x7fffffff
-	} PVRSRV_DEVICE_TYPE;
-
-#define HEAP_ID( _dev_ , _dev_heap_idx_ )	(  ((_dev_)<<24) | ((_dev_heap_idx_)&((1<<24)-1))  )
-#define HEAP_IDX( _heap_id_ )				( (_heap_id_)&((1<<24) - 1 ) )
-#define HEAP_DEV( _heap_id_ )				( (_heap_id_)>>24 )
-
-	typedef enum {
-		IMG_EGL = 0x00000001,
-		IMG_OPENGLES1 = 0x00000002,
-		IMG_OPENGLES2 = 0x00000003,
-		IMG_D3DM = 0x00000004,
-		IMG_SRV_UM = 0x00000005,
-		IMG_OPENVG = 0x00000006,
-		IMG_SRVCLIENT = 0x00000007,
-		IMG_VISTAKMD = 0x00000008,
-		IMG_VISTA3DNODE = 0x00000009,
-		IMG_VISTAMVIDEONODE = 0x0000000A,
-		IMG_VISTAVPBNODE = 0x0000000B,
-		IMG_OPENGL = 0x0000000C,
-		IMG_D3D = 0x0000000D
-	} IMG_MODULE_ID;
-
-#define APPHINT_MAX_STRING_SIZE	256
-
-	typedef enum {
-		IMG_STRING_TYPE = 1,
-		IMG_FLOAT_TYPE,
-		IMG_UINT_TYPE,
-		IMG_INT_TYPE,
-		IMG_FLAG_TYPE
-	} IMG_DATA_TYPE;
-
-	typedef struct _PVRSRV_CONNECTION_ {
-		IMG_HANDLE hServices;
-		IMG_UINT32 ui32ProcessID;
-	} PVRSRV_CONNECTION;
-
-	typedef struct _PVRSRV_DEV_DATA_ {
-		PVRSRV_CONNECTION sConnection;
-		IMG_HANDLE hDevCookie;
-
-	} PVRSRV_DEV_DATA, *PPVRSRV_DEV_DATA;
-
-	typedef struct _PVRSRV_MEMUPDATE_ {
-		IMG_UINT32 ui32UpdateAddr;
-		IMG_UINT32 ui32UpdateVal;
-	} PVRSRV_MEMUPDATE;
+#define PVRSRV_CHANGEDEVMEM_ATTRIBS_CACHECOHERENT	0x00000001
 
-	typedef struct _PVRSRV_HWREG_ {
-		IMG_UINT32 ui32RegAddr;
-		IMG_UINT32 ui32RegVal;
-	} PVRSRV_HWREG;
-
-	typedef struct _PVRSRV_MEMBLK_ {
-		IMG_DEV_VIRTADDR sDevVirtAddr;
-		IMG_HANDLE hOSMemHandle;
-		IMG_HANDLE hBuffer;
-		IMG_HANDLE hResItem;
-	} PVRSRV_MEMBLK;
-
-	typedef struct _PVRSRV_KERNEL_MEM_INFO_ *PPVRSRV_KERNEL_MEM_INFO;
-
-	typedef struct _PVRSRV_CLIENT_MEM_INFO_ {
-
-		IMG_PVOID pvLinAddr;
-
-		IMG_PVOID pvLinAddrKM;
-
-		IMG_DEV_VIRTADDR sDevVAddr;
-
-		IMG_CPU_PHYADDR sCpuPAddr;
-
-		IMG_UINT32 ui32Flags;
-
-		IMG_UINT32 ui32ClientFlags;
-
-		IMG_UINT32 ui32AllocSize;
-
-		struct _PVRSRV_CLIENT_SYNC_INFO_ *psClientSyncInfo;
-
-		IMG_HANDLE hMappingInfo;
-
-		IMG_HANDLE hKernelMemInfo;
-
-		IMG_HANDLE hResItem;
-
-		struct _PVRSRV_CLIENT_MEM_INFO_ *psNext;
-
-	} PVRSRV_CLIENT_MEM_INFO, *PPVRSRV_CLIENT_MEM_INFO;
+#define PVRSRV_MAPEXTMEMORY_FLAGS_ALTERNATEVA		0x00000001
+#define PVRSRV_MAPEXTMEMORY_FLAGS_PHYSCONTIG		0x00000002
 
+enum PVRSRV_DEVICE_TYPE {
+	PVRSRV_DEVICE_TYPE_UNKNOWN = 0,
+	PVRSRV_DEVICE_TYPE_MBX1 = 1,
+	PVRSRV_DEVICE_TYPE_MBX1_LITE = 2,
+
+	PVRSRV_DEVICE_TYPE_M24VA = 3,
+	PVRSRV_DEVICE_TYPE_MVDA2 = 4,
+	PVRSRV_DEVICE_TYPE_MVED1 = 5,
+	PVRSRV_DEVICE_TYPE_MSVDX = 6,
+
+	PVRSRV_DEVICE_TYPE_SGX = 7,
+	PVRSRV_DEVICE_TYPE_EXT = 8,
+	PVRSRV_DEVICE_TYPE_LAST = 8,
+	PVRSRV_DEVICE_TYPE_FORCE_I32 = 0x7fffffff
+};
+
+#define HEAP_ID(_dev_ , _dev_heap_idx_)	\
+	(((_dev_) << 24) | ((_dev_heap_idx_) & ((1 << 24) - 1)))
+#define HEAP_IDX(_heap_id_)		\
+	((_heap_id_) & ((1 << 24) - 1))
+#define HEAP_DEV(_heap_id_)		\
+	((_heap_id_) >> 24)
+
+enum IMG_MODULE_ID {
+	IMG_EGL = 0x00000001,
+	IMG_OPENGLES1 = 0x00000002,
+	IMG_OPENGLES2 = 0x00000003,
+	IMG_D3DM = 0x00000004,
+	IMG_SRV_UM = 0x00000005,
+	IMG_OPENVG = 0x00000006,
+	IMG_SRVCLIENT = 0x00000007,
+	IMG_VISTAKMD = 0x00000008,
+	IMG_VISTA3DNODE = 0x00000009,
+	IMG_VISTAMVIDEONODE = 0x0000000A,
+	IMG_VISTAVPBNODE = 0x0000000B,
+	IMG_OPENGL = 0x0000000C,
+	IMG_D3D = 0x0000000D
+};
+
+struct PVRSRV_CONNECTION {
+	void *hServices;
+	u32 ui32ProcessID;
+};
+
+struct PVRSRV_DEV_DATA {
+	struct PVRSRV_CONNECTION sConnection;
+	void *hDevCookie;
+};
+
+struct PVRSRV_HWREG {
+	u32 ui32RegAddr;
+	u32 ui32RegVal;
+};
+
+struct PVRSRV_MEMBLK {
+	struct IMG_DEV_VIRTADDR sDevVirtAddr;
+	void *hOSMemHandle;
+	void *hBuffer;
+	void *hResItem;
+};
+
+struct PVRSRV_KERNEL_MEM_INFO;
+
+struct PVRSRV_CLIENT_MEM_INFO {
+	void *pvLinAddr;
+	void *pvLinAddrKM;
+	struct IMG_DEV_VIRTADDR sDevVAddr;
+	struct IMG_CPU_PHYADDR sCpuPAddr;
+	u32 ui32Flags;
+	u32 ui32ClientFlags;
+	u32 ui32AllocSize;
+	struct PVRSRV_CLIENT_SYNC_INFO *psClientSyncInfo;
+	void *hMappingInfo;
+	void *hKernelMemInfo;
+	void *hResItem;
+	struct PVRSRV_CLIENT_MEM_INFO *psNext;
+};
 
 #define PVRSRV_MAX_CLIENT_HEAPS (32)
-	typedef struct _PVRSRV_HEAP_INFO_ {
-		IMG_UINT32 ui32HeapID;
-		IMG_HANDLE hDevMemHeap;
-		IMG_DEV_VIRTADDR sDevVAddrBase;
-		IMG_UINT32 ui32HeapByteSize;
-		IMG_UINT32 ui32Attribs;
-	} PVRSRV_HEAP_INFO;
-
-	typedef struct _PVRSRV_DEVICE_IDENTIFIER_ {
-		PVRSRV_DEVICE_TYPE eDeviceType;
-		PVRSRV_DEVICE_CLASS eDeviceClass;
-		IMG_UINT32 ui32DeviceIndex;
-
-	} PVRSRV_DEVICE_IDENTIFIER;
-
-	typedef struct _PVRSRV_EVENTOBJECT_ {
-
-		IMG_CHAR szName[EVENTOBJNAME_MAXLENGTH];
-
-		IMG_HANDLE hOSEventKM;
-
-	} PVRSRV_EVENTOBJECT;
-
-	typedef struct _PVRSRV_MISC_INFO_ {
-		IMG_UINT32 ui32StateRequest;
-		IMG_UINT32 ui32StatePresent;
-
-		IMG_VOID *pvSOCTimerRegisterKM;
-		IMG_VOID *pvSOCTimerRegisterUM;
-		IMG_HANDLE hSOCTimerRegisterOSMemHandle;
-
-		IMG_VOID *pvSOCClockGateRegs;
-		IMG_UINT32 ui32SOCClockGateRegsSize;
-
-		IMG_CHAR *pszMemoryStr;
-		IMG_UINT32 ui32MemoryStrLen;
-
-		PVRSRV_EVENTOBJECT sGlobalEventObject;
-		IMG_HANDLE hOSGlobalEvent;
-
-	} PVRSRV_MISC_INFO;
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVConnect(PVRSRV_CONNECTION *
-						    psConnection);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVDisconnect(PVRSRV_CONNECTION *
-						       psConnection);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVEnumerateDevices(IMG_CONST
-							     PVRSRV_CONNECTION *
-							     psConnection,
-							     IMG_UINT32 *
-							     puiNumDevices,
-							     PVRSRV_DEVICE_IDENTIFIER
-							     * puiDevIDs);
-	 IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV PVRSRVAcquireDeviceData(IMG_CONST
-								      PVRSRV_CONNECTION
-								      *
-								      psConnection,
-								      IMG_UINT32
-								      uiDevIndex,
-								      PVRSRV_DEV_DATA
-								      *
-								      psDevData,
-								      PVRSRV_DEVICE_TYPE
-								      eDeviceType);
-	 IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV PVRSRVGetMiscInfo(IMG_CONST
-								PVRSRV_CONNECTION
-								* psConnection,
-								PVRSRV_MISC_INFO
-								* psMiscInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVReleaseMiscInfo(IMG_CONST
-							    PVRSRV_CONNECTION *
-							    psConnection,
-							    PVRSRV_MISC_INFO *
-							    psMiscInfo);
-
-	 IMG_IMPORT
-	    IMG_UINT32 ReadHWReg(IMG_PVOID pvLinRegBaseAddr,
-				 IMG_UINT32 ui32Offset);
-
-	 IMG_IMPORT
-	    IMG_VOID WriteHWReg(IMG_PVOID pvLinRegBaseAddr,
-				IMG_UINT32 ui32Offset, IMG_UINT32 ui32Value);
-
-	IMG_IMPORT IMG_VOID WriteHWRegs(IMG_PVOID pvLinRegBaseAddr,
-					IMG_UINT32 ui32Count,
-					PVRSRV_HWREG * psHWRegs);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVPollForValue(PVRSRV_CONNECTION * psConnection,
-					    IMG_HANDLE hOSEvent,
-					    volatile IMG_UINT32 *
-					    pui32LinMemAddr,
-					    IMG_UINT32 ui32Value,
-					    IMG_UINT32 ui32Mask,
-					    IMG_UINT32 ui32Waitus,
-					    IMG_UINT32 ui32Tries);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateDeviceMemContext(IMG_CONST
-								   PVRSRV_DEV_DATA
-								   * psDevData,
-								   IMG_HANDLE *
-								   phDevMemContext,
-								   IMG_UINT32 *
-								   pui32SharedHeapCount,
-								   PVRSRV_HEAP_INFO
-								   *
-								   psHeapInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroyDeviceMemContext(IMG_CONST
-								    PVRSRV_DEV_DATA
-								    * psDevData,
-								    IMG_HANDLE
-								    hDevMemContext);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVGetDeviceMemHeapInfo(IMG_CONST
-								 PVRSRV_DEV_DATA
-								 * psDevData,
-								 IMG_HANDLE
-								 hDevMemContext,
-								 IMG_UINT32 *
-								 pui32SharedHeapCount,
-								 PVRSRV_HEAP_INFO
-								 * psHeapInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVMapMemInfoToUser(IMG_CONST
-							     PVRSRV_DEV_DATA *
-							     psDevData,
-							     PVRSRV_CLIENT_MEM_INFO
-							     * psMemInfo,
-							     IMG_VOID *
-							     ppvUserLinAddr,
-							     IMG_HANDLE *
-							     phUserMappingInfo);
-
-	PVRSRV_ERROR IMG_CALLCONV PVRSRVUnmapMemInfoFromUser(IMG_CONST
-							     PVRSRV_DEV_DATA *
-							     psDevData,
-							     PVRSRV_CLIENT_MEM_INFO
-							     * psMemInfo,
-							     IMG_PVOID
-							     pvUserLinAddr,
-							     IMG_HANDLE
-							     hUserMappingInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocDeviceMem(IMG_CONST
-							   PVRSRV_DEV_DATA *
-							   psDevData,
-							   IMG_HANDLE
-							   hDevMemHeap,
-							   IMG_UINT32
-							   ui32Attribs,
-							   IMG_UINT32 ui32Size,
-							   IMG_UINT32
-							   ui32Alignment,
-							   PVRSRV_CLIENT_MEM_INFO
-							   ** ppsMemInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVFreeDeviceMem(IMG_CONST
-							  PVRSRV_DEV_DATA *
-							  psDevData,
-							  PVRSRV_CLIENT_MEM_INFO
-							  * psMemInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVReserveDeviceVirtualMem(IMG_CONST
-								    PVRSRV_DEV_DATA
-								    * psDevData,
-								    IMG_HANDLE
-								    hDevMemHeap,
-								    IMG_DEV_VIRTADDR
-								    *
-								    psDevVAddr,
-								    IMG_UINT32
-								    ui32Size,
-								    IMG_UINT32
-								    ui32Alignment,
-								    PVRSRV_CLIENT_MEM_INFO
-								    **
-								    ppsMemInfo);
-	 IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVFreeDeviceVirtualMem(IMG_CONST PVRSRV_DEV_DATA * psDevData,
-				       PVRSRV_CLIENT_MEM_INFO * psMemInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceMemory(IMG_CONST
-							    PVRSRV_DEV_DATA *
-							    psDevData,
-							    PVRSRV_CLIENT_MEM_INFO
-							    * psSrcMemInfo,
-							    IMG_HANDLE
-							    hDstDevMemHeap,
-							    PVRSRV_CLIENT_MEM_INFO
-							    ** ppsDstMemInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVUnmapDeviceMemory(IMG_CONST
-							      PVRSRV_DEV_DATA *
-							      psDevData,
-							      PVRSRV_CLIENT_MEM_INFO
-							      * psMemInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVMapExtMemory(IMG_CONST
-							 PVRSRV_DEV_DATA *
-							 psDevData,
-							 PVRSRV_CLIENT_MEM_INFO
-							 * psMemInfo,
-							 IMG_SYS_PHYADDR *
-							 psSysPAddr,
-							 IMG_UINT32 ui32Flags);
-	 IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV PVRSRVUnmapExtMemory(IMG_CONST
-								   PVRSRV_DEV_DATA
-								   * psDevData,
-								   PVRSRV_CLIENT_MEM_INFO
-								   * psMemInfo,
-								   IMG_UINT32
-								   ui32Flags);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtMemory(IMG_CONST
-							  PVRSRV_DEV_DATA *
-							  psDevData,
-							  IMG_UINT32
-							  ui32ByteSize,
-							  IMG_UINT32
-							  ui32PageOffset,
-							  IMG_BOOL bPhysContig,
-							  IMG_SYS_PHYADDR *
-							  psSysPAddr,
-							  IMG_VOID * pvLinAddr,
-							  PVRSRV_CLIENT_MEM_INFO
-							  ** ppsMemInfo);
-	 IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV PVRSRVUnwrapExtMemory(IMG_CONST
-								    PVRSRV_DEV_DATA
-								    * psDevData,
-								    PVRSRV_CLIENT_MEM_INFO
-								    *
-								    psMemInfo);
-
-	PVRSRV_ERROR PVRSRVChangeDeviceMemoryAttributes(IMG_CONST
-							PVRSRV_DEV_DATA *
-							psDevData,
-							PVRSRV_CLIENT_MEM_INFO *
-							psClientMemInfo,
-							IMG_UINT32 ui32Attribs);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDeviceClassMemory(IMG_CONST
-								 PVRSRV_DEV_DATA
-								 * psDevData,
-								 IMG_HANDLE
-								 hDeviceClassBuffer,
-								 PVRSRV_CLIENT_MEM_INFO
-								 ** ppsMemInfo);
-	 IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVUnmapDeviceClassMemory(IMG_CONST PVRSRV_DEV_DATA * psDevData,
-					 PVRSRV_CLIENT_MEM_INFO * psMemInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVMapPhysToUserSpace(IMG_CONST
-							       PVRSRV_DEV_DATA *
-							       psDevData,
-							       IMG_SYS_PHYADDR
-							       sSysPhysAddr,
-							       IMG_UINT32
-							       uiSizeInBytes,
-							       IMG_PVOID *
-							       ppvUserAddr,
-							       IMG_UINT32 *
-							       puiActualSize,
-							       IMG_PVOID *
-							       ppvProcess);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVUnmapPhysToUserSpace(IMG_CONST
-								 PVRSRV_DEV_DATA
-								 * psDevData,
-								 IMG_PVOID
-								 pvUserAddr,
-								 IMG_PVOID
-								 pvProcess);
-
-	typedef enum _PVRSRV_SYNCVAL_MODE_ {
-		PVRSRV_SYNCVAL_READ = IMG_TRUE,
-		PVRSRV_SYNCVAL_WRITE = IMG_FALSE,
-
-	} PVRSRV_SYNCVAL_MODE, *PPVRSRV_SYNCVAL_MODE;
-
-	typedef IMG_UINT32 PVRSRV_SYNCVAL;
-
-	IMG_IMPORT PVRSRV_ERROR PVRSRVWaitForOpsComplete(PPVRSRV_CLIENT_MEM_INFO
-							 psMemInfo,
-							 PVRSRV_SYNCVAL_MODE
-							 eMode,
-							 PVRSRV_SYNCVAL
-							 OpRequired);
-
-	IMG_IMPORT PVRSRV_ERROR
-	    PVRSRVWaitForAllOpsComplete(PPVRSRV_CLIENT_MEM_INFO psMemInfo,
-					PVRSRV_SYNCVAL_MODE eMode);
-
-	IMG_IMPORT IMG_BOOL PVRSRVTestOpsComplete(PPVRSRV_CLIENT_MEM_INFO
-						  psMemInfo,
-						  PVRSRV_SYNCVAL_MODE eMode,
-						  PVRSRV_SYNCVAL OpRequired);
-
-	IMG_IMPORT IMG_BOOL PVRSRVTestAllOpsComplete(PPVRSRV_CLIENT_MEM_INFO
-						     psMemInfo,
-						     PVRSRV_SYNCVAL_MODE eMode);
-
-	IMG_IMPORT IMG_BOOL PVRSRVTestOpsNotComplete(PPVRSRV_CLIENT_MEM_INFO
-						     psMemInfo,
-						     PVRSRV_SYNCVAL_MODE eMode,
-						     PVRSRV_SYNCVAL OpRequired);
-
-	IMG_IMPORT IMG_BOOL PVRSRVTestAllOpsNotComplete(PPVRSRV_CLIENT_MEM_INFO
-							psMemInfo,
-							PVRSRV_SYNCVAL_MODE
-							eMode);
-
-	IMG_IMPORT PVRSRV_SYNCVAL
-	    PVRSRVGetPendingOpSyncVal(PPVRSRV_CLIENT_MEM_INFO psMemInfo,
-				      PVRSRV_SYNCVAL_MODE eMode);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVEnumerateDeviceClass(IMG_CONST
-								 PVRSRV_CONNECTION
-								 * psConnection,
-								 PVRSRV_DEVICE_CLASS
-								 DeviceClass,
-								 IMG_UINT32 *
-								 pui32DevCount,
-								 IMG_UINT32 *
-								 pui32DevID);
-
-	 IMG_IMPORT
-	    IMG_HANDLE IMG_CALLCONV PVRSRVOpenDCDevice(IMG_CONST PVRSRV_DEV_DATA
-						       * psDevData,
-						       IMG_UINT32 ui32DeviceID);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVCloseDCDevice(IMG_CONST
-							  PVRSRV_CONNECTION *
-							  psConnection,
-							  IMG_HANDLE hDevice);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVEnumDCFormats(IMG_HANDLE hDevice,
-							  IMG_UINT32 *
-							  pui32Count,
-							  DISPLAY_FORMAT *
-							  psFormat);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVEnumDCDims(IMG_HANDLE hDevice,
-						       IMG_UINT32 * pui32Count,
-						       DISPLAY_FORMAT *
-						       psFormat,
-						       DISPLAY_DIMS * psDims);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVGetDCSystemBuffer(IMG_HANDLE
-							      hDevice,
-							      IMG_HANDLE *
-							      phBuffer);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVGetDCInfo(IMG_HANDLE hDevice,
-						      DISPLAY_INFO *
-						      psDisplayInfo);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVCreateDCSwapChain(IMG_HANDLE
-							      hDevice,
-							      IMG_UINT32
-							      ui32Flags,
-							      DISPLAY_SURF_ATTRIBUTES
-							      * psDstSurfAttrib,
-							      DISPLAY_SURF_ATTRIBUTES
-							      * psSrcSurfAttrib,
-							      IMG_UINT32
-							      ui32BufferCount,
-							      IMG_UINT32
-							      ui32OEMFlags,
-							      IMG_UINT32 *
-							      pui32SwapChainID,
-							      IMG_HANDLE *
-							      phSwapChain);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVDestroyDCSwapChain(IMG_HANDLE
-							       hDevice,
-							       IMG_HANDLE
-							       hSwapChain);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVSetDCDstRect(IMG_HANDLE hDevice,
-							 IMG_HANDLE hSwapChain,
-							 IMG_RECT * psDstRect);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVSetDCSrcRect(IMG_HANDLE hDevice,
-							 IMG_HANDLE hSwapChain,
-							 IMG_RECT * psSrcRect);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVSetDCDstColourKey(IMG_HANDLE
-							      hDevice,
-							      IMG_HANDLE
-							      hSwapChain,
-							      IMG_UINT32
-							      ui32CKColour);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVSetDCSrcColourKey(IMG_HANDLE
-							      hDevice,
-							      IMG_HANDLE
-							      hSwapChain,
-							      IMG_UINT32
-							      ui32CKColour);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVGetDCBuffers(IMG_HANDLE hDevice,
-							 IMG_HANDLE hSwapChain,
-							 IMG_HANDLE * phBuffer);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVSwapToDCBuffer(IMG_HANDLE hDevice,
-							   IMG_HANDLE hBuffer,
-							   IMG_UINT32
-							   ui32ClipRectCount,
-							   IMG_RECT *
-							   psClipRect,
-							   IMG_UINT32
-							   ui32SwapInterval,
-							   IMG_HANDLE
-							   hPrivateTag);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVSwapToDCSystem(IMG_HANDLE hDevice,
-							   IMG_HANDLE
-							   hSwapChain);
-
-	 IMG_IMPORT
-	    IMG_HANDLE IMG_CALLCONV PVRSRVOpenBCDevice(IMG_CONST PVRSRV_DEV_DATA
-						       * psDevData,
-						       IMG_UINT32 ui32DeviceID);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVCloseBCDevice(IMG_CONST
-							  PVRSRV_CONNECTION *
-							  psConnection,
-							  IMG_HANDLE hDevice);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVGetBCBufferInfo(IMG_HANDLE hDevice,
-							    BUFFER_INFO *
-							    psBuffer);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVGetBCBuffer(IMG_HANDLE hDevice,
-							IMG_UINT32
-							ui32BufferIndex,
-							IMG_HANDLE * phBuffer);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpInit(IMG_CONST
-						      PVRSRV_CONNECTION *
-						      psConnection);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpMemPol(IMG_CONST
-							PVRSRV_CONNECTION *
-							psConnection,
-							PVRSRV_CLIENT_MEM_INFO *
-							psMemInfo,
-							IMG_UINT32 ui32Offset,
-							IMG_UINT32 ui32Value,
-							IMG_UINT32 ui32Mask,
-							IMG_BOOL bLastFrame,
-							IMG_BOOL bOverwrite);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpSyncPol(IMG_CONST
-							 PVRSRV_CONNECTION *
-							 psConnection,
-							 PVRSRV_CLIENT_SYNC_INFO
-							 * psClientSyncInfo,
-							 IMG_BOOL bIsRead,
-							 IMG_UINT32 ui32Value,
-							 IMG_UINT32 ui32Mask);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpMem(IMG_CONST PVRSRV_CONNECTION
-						     * psConnection,
-						     IMG_PVOID pvAltLinAddr,
-						     PVRSRV_CLIENT_MEM_INFO *
-						     psMemInfo,
-						     IMG_UINT32 ui32Offset,
-						     IMG_UINT32 ui32Bytes,
-						     IMG_UINT32 ui32Flags);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpSync(IMG_CONST
-						      PVRSRV_CONNECTION *
-						      psConnection,
-						      IMG_PVOID pvAltLinAddr,
-						      PVRSRV_CLIENT_SYNC_INFO *
-						      psClientSyncInfo,
-						      IMG_UINT32 ui32Offset,
-						      IMG_UINT32 ui32Bytes);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpReg(IMG_CONST PVRSRV_CONNECTION
-						     * psConnection,
-						     IMG_UINT32 ui32RegAddr,
-						     IMG_UINT32 ui32RegValue,
-						     IMG_UINT32 ui32Flags);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpRegPolWithFlags(IMG_CONST
-								 PVRSRV_CONNECTION
-								 * psConnection,
-								 IMG_UINT32
-								 ui32RegAddr,
-								 IMG_UINT32
-								 ui32RegValue,
-								 IMG_UINT32
-								 ui32Mask,
-								 IMG_UINT32
-								 ui32Flags);
-	 IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpRegPol(IMG_CONST
-								PVRSRV_CONNECTION
-								* psConnection,
-								IMG_UINT32
-								ui32RegAddr,
-								IMG_UINT32
-								ui32RegValue,
-								IMG_UINT32
-								ui32Mask);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpPDReg(IMG_CONST
-						       PVRSRV_CONNECTION *
-						       psConnection,
-						       IMG_UINT32 ui32RegAddr,
-						       IMG_UINT32 ui32RegValue);
-	 IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpPDDevPAddr(IMG_CONST
-								    PVRSRV_CONNECTION
-								    *
-								    psConnection,
-								    PVRSRV_CLIENT_MEM_INFO
-								    * psMemInfo,
-								    IMG_UINT32
-								    ui32Offset,
-								    IMG_DEV_PHYADDR
-								    sPDDevPAddr);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpMemPages(IMG_CONST
-							  PVRSRV_CONNECTION *
-							  psConnection,
-							  IMG_HANDLE
-							  hKernelMemInfo,
-							  IMG_DEV_PHYADDR *
-							  pPages,
-							  IMG_UINT32
-							  ui32NumPages,
-							  IMG_DEV_VIRTADDR
-							  sDevAddr,
-							  IMG_UINT32 ui32Start,
-							  IMG_UINT32 ui32Length,
-							  IMG_BOOL bContinuous);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpSetFrame(IMG_CONST
-							  PVRSRV_CONNECTION *
-							  psConnection,
-							  IMG_UINT32 ui32Frame);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpComment(IMG_CONST
-							 PVRSRV_CONNECTION *
-							 psConnection,
-							 IMG_CONST IMG_CHAR *
-							 pszComment,
-							 IMG_BOOL bContinuous);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpCommentf(IMG_CONST
-							  PVRSRV_CONNECTION *
-							  psConnection,
-							  IMG_BOOL bContinuous,
-							  IMG_CONST IMG_CHAR *
-							  pszFormat, ...);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpCommentWithFlagsf(IMG_CONST
-								   PVRSRV_CONNECTION
-								   *
-								   psConnection,
-								   IMG_UINT32
-								   ui32Flags,
-								   IMG_CONST
-								   IMG_CHAR *
-								   pszFormat,
-								   ...);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpDriverInfo(IMG_CONST
-							    PVRSRV_CONNECTION *
-							    psConnection,
-							    IMG_CHAR *
-							    pszString,
-							    IMG_BOOL
-							    bContinuous);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpIsCapturing(IMG_CONST
-							     PVRSRV_CONNECTION *
-							     psConnection,
-							     IMG_BOOL *
-							     pbIsCapturing);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpBitmap(IMG_CONST
-							PVRSRV_CONNECTION *
-							psConnection,
-							IMG_CHAR * pszFileName,
-							IMG_UINT32
-							ui32FileOffset,
-							IMG_UINT32 ui32Width,
-							IMG_UINT32 ui32Height,
-							IMG_UINT32
-							ui32StrideInBytes,
-							IMG_DEV_VIRTADDR
-							sDevBaseAddr,
-							IMG_UINT32 ui32Size,
-							PDUMP_PIXEL_FORMAT
-							ePixelFormat,
-							PDUMP_MEM_FORMAT
-							eMemFormat,
-							IMG_UINT32
-							ui32PDumpFlags);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpRegRead(IMG_CONST
-							 PVRSRV_CONNECTION *
-							 psConnection,
-							 IMG_CONST IMG_CHAR *
-							 pszFileName,
-							 IMG_UINT32
-							 ui32FileOffset,
-							 IMG_UINT32 ui32Address,
-							 IMG_UINT32 ui32Size,
-							 IMG_UINT32
-							 ui32PDumpFlags);
-
-	 IMG_IMPORT
-	    IMG_BOOL IMG_CALLCONV PVRSRVPDumpIsCapturingTest(IMG_CONST
-							     PVRSRV_CONNECTION *
-							     psConnection);
-
-	 IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV PVRSRVPDumpCycleCountRegRead(IMG_CONST
-								   PVRSRV_CONNECTION
-								   *
-								   psConnection,
-								   IMG_UINT32
-								   ui32RegOffset,
-								   IMG_BOOL
-								   bLastFrame);
-
-	IMG_IMPORT IMG_HANDLE PVRSRVLoadLibrary(const IMG_CHAR *
-						pszLibraryName);
-	IMG_IMPORT PVRSRV_ERROR PVRSRVUnloadLibrary(IMG_HANDLE hExtDrv);
-	IMG_IMPORT PVRSRV_ERROR PVRSRVGetLibFuncAddr(IMG_HANDLE hExtDrv,
-						     const IMG_CHAR *
-						     pszFunctionName,
-						     IMG_VOID ** ppvFuncAddr);
-
-	IMG_IMPORT IMG_UINT32 PVRSRVClockus(void);
-	IMG_IMPORT IMG_VOID PVRSRVWaitus(IMG_UINT32 ui32Timeus);
-	IMG_IMPORT IMG_VOID PVRSRVReleaseThreadQuanta(void);
-	IMG_IMPORT IMG_UINT32 IMG_CALLCONV PVRSRVGetCurrentProcessID(void);
-
-	IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVCreateAppHintState(IMG_MODULE_ID
-								  eModuleID,
-								  const IMG_CHAR
-								  * pszAppName,
-								  IMG_VOID **
-								  ppvState);
-	IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVFreeAppHintState(IMG_MODULE_ID
-								eModuleID,
-								IMG_VOID *
-								pvHintState);
-
-	IMG_IMPORT IMG_BOOL IMG_CALLCONV PVRSRVGetAppHint(IMG_VOID *
-							  pvHintState,
-							  const IMG_CHAR *
-							  pszHintName,
-							  IMG_DATA_TYPE
-							  eDataType,
-							  const IMG_VOID *
-							  pvDefault,
-							  IMG_VOID * pvReturn);
-
-	IMG_IMPORT IMG_PVOID IMG_CALLCONV PVRSRVAllocUserModeMem(IMG_UINT32
-								 ui32Size);
-	IMG_IMPORT IMG_PVOID IMG_CALLCONV PVRSRVCallocUserModeMem(IMG_UINT32
-								  ui32Size);
-	IMG_IMPORT IMG_PVOID IMG_CALLCONV PVRSRVReallocUserModeMem(IMG_PVOID
-								   pvBase,
-								   IMG_SIZE_T
-								   uNewSize);
-	IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVFreeUserModeMem(IMG_PVOID pvMem);
-	IMG_IMPORT IMG_VOID PVRSRVMemCopy(IMG_VOID * pvDst,
-					  const IMG_VOID * pvSrc,
-					  IMG_UINT32 ui32Size);
-	IMG_IMPORT IMG_VOID PVRSRVMemSet(IMG_VOID * pvDest, IMG_UINT8 ui8Value,
-					 IMG_UINT32 ui32Size);
-
-	struct _PVRSRV_MUTEX_OPAQUE_STRUCT_;
-	typedef struct _PVRSRV_MUTEX_OPAQUE_STRUCT_ *PVRSRV_MUTEX_HANDLE;
-
-	IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVCreateMutex(PVRSRV_MUTEX_HANDLE * phMutex);
-	IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVDestroyMutex(PVRSRV_MUTEX_HANDLE hMutex);
-	IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVLockMutex(PVRSRV_MUTEX_HANDLE
-							 hMutex);
-	IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVUnlockMutex(PVRSRV_MUTEX_HANDLE
-							   hMutex);
-
-#ifdef DEBUG
-	IMG_PVOID PVRSRVAllocUserModeMemTracking(IMG_UINT32 ui32Size,
-						 IMG_CHAR * pszFileName,
-						 IMG_UINT32 ui32LineNumber);
-	IMG_PVOID PVRSRVCallocUserModeMemTracking(IMG_UINT32 ui32Size,
-						  IMG_CHAR * pszFileName,
-						  IMG_UINT32 ui32LineNumber);
-	IMG_VOID PVRSRVFreeUserModeMemTracking(IMG_VOID * pvMem);
-	IMG_PVOID PVRSRVReallocUserModeMemTracking(IMG_VOID * pvMem,
-						   IMG_UINT32 ui32NewSize,
-						   IMG_CHAR * pszFileName,
-						   IMG_UINT32 ui32LineNumber);
-#endif
+struct PVRSRV_HEAP_INFO {
+	u32 ui32HeapID;
+	void *hDevMemHeap;
+	struct IMG_DEV_VIRTADDR sDevVAddrBase;
+	u32 ui32HeapByteSize;
+	u32 ui32Attribs;
+};
+
+struct PVRSRV_DEVICE_IDENTIFIER {
+	enum PVRSRV_DEVICE_TYPE eDeviceType;
+	enum PVRSRV_DEVICE_CLASS eDeviceClass;
+	u32 ui32DeviceIndex;
+
+};
+
+struct PVRSRV_EVENTOBJECT {
+	char szName[EVENTOBJNAME_MAXLENGTH];
+	void *hOSEventKM;
+};
+
+struct PVRSRV_MISC_INFO {
+	u32 ui32StateRequest;
+	u32 ui32StatePresent;
+
+	void *pvSOCTimerRegisterKM;
+	void *pvSOCTimerRegisterUM;
+	void *hSOCTimerRegisterOSMemHandle;
+
+	void *pvSOCClockGateRegs;
+	u32 ui32SOCClockGateRegsSize;
+
+	char *pszMemoryStr;
+	u32 ui32MemoryStrLen;
+
+	struct PVRSRV_EVENTOBJECT sGlobalEventObject;
+	void *hOSGlobalEvent;
 
-	IMG_IMPORT PVRSRV_ERROR PVRSRVEventObjectWait(PVRSRV_CONNECTION *
-						      psConnection,
-						      IMG_HANDLE hOSEvent);
+};
 
-#define TIME_NOT_PASSED_UINT32(a,b,c)		((a - b) < c)
+enum PVRSRV_ERROR AllocateDeviceID(struct SYS_DATA *psSysData, u32 *pui32DevID);
+enum PVRSRV_ERROR FreeDeviceID(struct SYS_DATA *psSysData, u32 ui32DevID);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/services_headers.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/services_headers.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -38,7 +38,6 @@
 #include "kerneldisplay.h"
 #include "syscommon.h"
 #include "pvr_debug.h"
-#include "metrics.h"
 #include "osfunc.h"
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/servicesext.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/servicesext.h
@@ -1,35 +1,37 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
-#if !defined (__SERVICESEXT_H__)
+#if !defined(__SERVICESEXT_H__)
 #define __SERVICESEXT_H__
 
+#include "img_types.h"
+
 #define PVRSRV_LOCKFLG_READONLY     	(1)
 
-typedef enum _PVRSRV_ERROR_ {
+enum PVRSRV_ERROR {
 	PVRSRV_OK = 0,
 	PVRSRV_ERROR_GENERIC = 1,
 	PVRSRV_ERROR_OUT_OF_MEMORY = 2,
@@ -67,18 +69,18 @@
 	PVRSRV_ERROR_RETRY = 34,
 
 	PVRSRV_ERROR_FORCE_I32 = 0x7fffffff
-} PVRSRV_ERROR;
+};
 
-typedef enum _PVRSRV_DEVICE_CLASS_ {
+enum PVRSRV_DEVICE_CLASS {
 	PVRSRV_DEVICE_CLASS_3D = 0,
 	PVRSRV_DEVICE_CLASS_DISPLAY = 1,
 	PVRSRV_DEVICE_CLASS_BUFFER = 2,
 	PVRSRV_DEVICE_CLASS_VIDEO = 3,
 
 	PVRSRV_DEVICE_CLASS_FORCE_I32 = 0x7fffffff
-} PVRSRV_DEVICE_CLASS;
+};
 
-typedef enum _PVRSRV_POWER_STATE_ {
+enum PVR_POWER_STATE {
 	PVRSRV_POWER_Unspecified = -1,
 	PVRSRV_POWER_STATE_D0 = 0,
 	PVRSRV_POWER_STATE_D1 = 1,
@@ -87,19 +89,11 @@
 	PVRSRV_POWER_STATE_D4 = 4,
 
 	PVRSRV_POWER_STATE_FORCE_I32 = 0x7fffffff
-} PVR_POWER_STATE, *PPVR_POWER_STATE;
+};
+
 
-typedef PVRSRV_ERROR(*PFN_PRE_POWER) (IMG_HANDLE, PVR_POWER_STATE,
-				      PVR_POWER_STATE);
-typedef PVRSRV_ERROR(*PFN_POST_POWER) (IMG_HANDLE, PVR_POWER_STATE,
-				       PVR_POWER_STATE);
-
-typedef PVRSRV_ERROR(*PFN_PRE_CLOCKSPEED_CHANGE) (IMG_HANDLE, IMG_BOOL,
-						  PVR_POWER_STATE);
-typedef PVRSRV_ERROR(*PFN_POST_CLOCKSPEED_CHANGE) (IMG_HANDLE, IMG_BOOL,
-						   PVR_POWER_STATE);
 
-typedef enum _PVRSRV_PIXEL_FORMAT_ {
+enum PVRSRV_PIXEL_FORMAT {
 	PVRSRV_PIXEL_FORMAT_UNKNOWN = 0,
 	PVRSRV_PIXEL_FORMAT_RGB565 = 1,
 	PVRSRV_PIXEL_FORMAT_RGB555 = 2,
@@ -190,185 +184,174 @@
 	PVRSRV_PIXEL_FORMAT_FOURCC_ORG_VYUY,
 
 	PVRSRV_PIXEL_FORMAT_FORCE_I32 = 0x7fffffff,
-} PVRSRV_PIXEL_FORMAT;
+};
 
-typedef enum _PVRSRV_ALPHA_FORMAT_ {
+enum PVRSRV_ALPHA_FORMAT {
 	PVRSRV_ALPHA_FORMAT_UNKNOWN = 0x00000000,
 	PVRSRV_ALPHA_FORMAT_PRE = 0x00000001,
 	PVRSRV_ALPHA_FORMAT_NONPRE = 0x00000002,
 	PVRSRV_ALPHA_FORMAT_MASK = 0x0000000F,
-} PVRSRV_ALPHA_FORMAT;
+};
 
-typedef enum _PVRSRV_COLOURSPACE_FORMAT_ {
+enum PVRSRV_COLOURSPACE_FORMAT {
 	PVRSRV_COLOURSPACE_FORMAT_UNKNOWN = 0x00000000,
 	PVRSRV_COLOURSPACE_FORMAT_LINEAR = 0x00010000,
 	PVRSRV_COLOURSPACE_FORMAT_NONLINEAR = 0x00020000,
 	PVRSRV_COLOURSPACE_FORMAT_MASK = 0x000F0000,
-} PVRSRV_COLOURSPACE_FORMAT;
+};
 
 #define PVRSRV_CREATE_SWAPCHAIN_SHARED		(1<<0)
 #define PVRSRV_CREATE_SWAPCHAIN_QUERY		(1<<1)
 
-typedef struct _PVRSRV_SYNC_DATA_ {
+struct PVRSRV_SYNC_DATA {
 
-	IMG_UINT32 ui32WriteOpsPending;
-	volatile IMG_UINT32 ui32WriteOpsComplete;
+	u32 ui32WriteOpsPending;
+	volatile u32 ui32WriteOpsComplete;
 
-	IMG_UINT32 ui32ReadOpsPending;
-	volatile IMG_UINT32 ui32ReadOpsComplete;
+	u32 ui32ReadOpsPending;
+	volatile u32 ui32ReadOpsComplete;
 
-	IMG_UINT32 ui32LastOpDumpVal;
-	IMG_UINT32 ui32LastReadOpDumpVal;
+	u32 ui32LastOpDumpVal;
+	u32 ui32LastReadOpDumpVal;
 
-} PVRSRV_SYNC_DATA;
+};
 
-typedef struct _PVRSRV_CLIENT_SYNC_INFO_ {
+struct PVRSRV_CLIENT_SYNC_INFO {
 
-	PVRSRV_SYNC_DATA *psSyncData;
+	struct PVRSRV_SYNC_DATA *psSyncData;
 
-	IMG_DEV_VIRTADDR sWriteOpsCompleteDevVAddr;
+	struct IMG_DEV_VIRTADDR sWriteOpsCompleteDevVAddr;
 
-	IMG_DEV_VIRTADDR sReadOpsCompleteDevVAddr;
+	struct IMG_DEV_VIRTADDR sReadOpsCompleteDevVAddr;
 
-	IMG_HANDLE hMappingInfo;
+	void *hMappingInfo;
 
-	IMG_HANDLE hKernelSyncInfo;
+	void *hKernelSyncInfo;
 
-} PVRSRV_CLIENT_SYNC_INFO, *PPVRSRV_CLIENT_SYNC_INFO;
+};
 
-typedef struct PVRSRV_RESOURCE_TAG {
-	volatile IMG_UINT32 ui32Lock;
-	IMG_UINT32 ui32ID;
-} PVRSRV_RESOURCE;
-typedef PVRSRV_RESOURCE PVRSRV_RES_HANDLE;
+struct PVRSRV_RESOURCE {
+	volatile u32 ui32Lock;
+	u32 ui32ID;
+};
 
-typedef IMG_VOID(*PFN_CMD_COMPLETE) (IMG_HANDLE);
-typedef IMG_VOID(**PPFN_CMD_COMPLETE) (IMG_HANDLE);
 
-typedef IMG_BOOL(*PFN_CMD_PROC) (IMG_HANDLE, IMG_UINT32, IMG_VOID *);
-typedef IMG_BOOL(**PPFN_CMD_PROC) (IMG_HANDLE, IMG_UINT32, IMG_VOID *);
 
-typedef struct _IMG_RECT_ {
-	IMG_INT32 x0;
-	IMG_INT32 y0;
-	IMG_INT32 x1;
-	IMG_INT32 y1;
-} IMG_RECT;
+struct IMG_RECT {
+	s32 x0;
+	s32 y0;
+	s32 x1;
+	s32 y1;
+};
 
-typedef struct _IMG_RECT_16_ {
-	IMG_INT16 x0;
-	IMG_INT16 y0;
-	IMG_INT16 x1;
-	IMG_INT16 y1;
-} IMG_RECT_16;
+struct IMG_RECT_16 {
+	s16 x0;
+	s16 y0;
+	s16 x1;
+	s16 y1;
+};
 
-typedef PVRSRV_ERROR(*PFN_GET_BUFFER_ADDR) (IMG_HANDLE,
-					    IMG_HANDLE,
-					    IMG_SYS_PHYADDR **,
-					    IMG_UINT32 *,
-					    IMG_VOID **,
-					    IMG_HANDLE *, IMG_BOOL *);
 
-typedef struct DISPLAY_DIMS_TAG {
-	IMG_UINT32 ui32ByteStride;
-	IMG_UINT32 ui32Width;
-	IMG_UINT32 ui32Height;
-} DISPLAY_DIMS;
+struct DISPLAY_DIMS {
+	u32 ui32ByteStride;
+	u32 ui32Width;
+	u32 ui32Height;
+};
 
-typedef struct DISPLAY_FORMAT_TAG {
+struct DISPLAY_FORMAT {
 
-	PVRSRV_PIXEL_FORMAT pixelformat;
-} DISPLAY_FORMAT;
+	enum PVRSRV_PIXEL_FORMAT pixelformat;
+};
 
-typedef struct DISPLAY_SURF_ATTRIBUTES_TAG {
+struct DISPLAY_SURF_ATTRIBUTES {
 
-	PVRSRV_PIXEL_FORMAT pixelformat;
+	enum PVRSRV_PIXEL_FORMAT pixelformat;
 
-	DISPLAY_DIMS sDims;
-} DISPLAY_SURF_ATTRIBUTES;
+	struct DISPLAY_DIMS sDims;
+};
 
-typedef struct DISPLAY_MODE_INFO_TAG {
+struct DISPLAY_MODE_INFO {
 
-	PVRSRV_PIXEL_FORMAT pixelformat;
+	enum PVRSRV_PIXEL_FORMAT pixelformat;
 
-	DISPLAY_DIMS sDims;
+	struct DISPLAY_DIMS sDims;
 
-	IMG_UINT32 ui32RefreshHZ;
+	u32 ui32RefreshHZ;
 
-	IMG_UINT32 ui32OEMFlags;
-} DISPLAY_MODE_INFO;
+	u32 ui32OEMFlags;
+};
 
 #define MAX_DISPLAY_NAME_SIZE	(50)
 
-typedef struct DISPLAY_INFO_TAG {
-	IMG_UINT32 ui32MaxSwapChains;
+struct DISPLAY_INFO {
+	u32 ui32MaxSwapChains;
 
-	IMG_UINT32 ui32MaxSwapChainBuffers;
+	u32 ui32MaxSwapChainBuffers;
 
-	IMG_UINT32 ui32MinSwapInterval;
+	u32 ui32MinSwapInterval;
 
-	IMG_UINT32 ui32MaxSwapInterval;
+	u32 ui32MaxSwapInterval;
 
-	IMG_CHAR szDisplayName[MAX_DISPLAY_NAME_SIZE];
+	char szDisplayName[MAX_DISPLAY_NAME_SIZE];
 
 
-} DISPLAY_INFO;
+};
 
-typedef struct ACCESS_INFO_TAG {
-	IMG_UINT32 ui32Size;
-	IMG_UINT32 ui32FBPhysBaseAddress;
-	IMG_UINT32 ui32FBMemAvailable;
-	IMG_UINT32 ui32SysPhysBaseAddress;
-	IMG_UINT32 ui32SysSize;
-	IMG_UINT32 ui32DevIRQ;
-} ACCESS_INFO;
+struct ACCESS_INFO {
+	u32 ui32Size;
+	u32 ui32FBPhysBaseAddress;
+	u32 ui32FBMemAvailable;
+	u32 ui32SysPhysBaseAddress;
+	u32 ui32SysSize;
+	u32 ui32DevIRQ;
+};
 
-typedef struct PVRSRV_CURSOR_SHAPE_TAG {
-	IMG_UINT16 ui16Width;
-	IMG_UINT16 ui16Height;
-	IMG_INT16 i16XHot;
-	IMG_INT16 i16YHot;
+struct PVRSRV_CURSOR_SHAPE {
+	u16 ui16Width;
+	u16 ui16Height;
+	s16 i16XHot;
+	s16 i16YHot;
 
-	IMG_VOID *pvMask;
-	IMG_INT16 i16MaskByteStride;
+	void *pvMask;
+	s16 i16MaskByteStride;
 
-	IMG_VOID *pvColour;
-	IMG_INT16 i16ColourByteStride;
-	PVRSRV_PIXEL_FORMAT eColourPixelFormat;
-} PVRSRV_CURSOR_SHAPE;
+	void *pvColour;
+	s16 i16ColourByteStride;
+	enum PVRSRV_PIXEL_FORMAT eColourPixelFormat;
+};
 
 #define PVRSRV_SET_CURSOR_VISIBILITY	(1<<0)
 #define PVRSRV_SET_CURSOR_POSITION		(1<<1)
 #define PVRSRV_SET_CURSOR_SHAPE			(1<<2)
 #define PVRSRV_SET_CURSOR_ROTATION		(1<<3)
 
-typedef struct PVRSRV_CURSOR_INFO_TAG {
+struct PVRSRV_CURSOR_INFO {
 
-	IMG_UINT32 ui32Flags;
+	u32 ui32Flags;
 
 	IMG_BOOL bVisible;
 
-	IMG_INT16 i16XPos;
-	IMG_INT16 i16YPos;
+	s16 i16XPos;
+	s16 i16YPos;
 
-	PVRSRV_CURSOR_SHAPE sCursorShape;
+	struct PVRSRV_CURSOR_SHAPE sCursorShape;
 
-	IMG_UINT32 ui32Rotation;
+	u32 ui32Rotation;
 
-} PVRSRV_CURSOR_INFO;
+};
 
-typedef struct _PVRSRV_REGISTRY_INFO_ {
-	IMG_UINT32 ui32DevCookie;
-	IMG_PCHAR pszKey;
-	IMG_PCHAR pszValue;
-	IMG_PCHAR pszBuf;
-	IMG_UINT32 ui32BufSize;
-} PVRSRV_REGISTRY_INFO, *PPVRSRV_REGISTRY_INFO;
-
-PVRSRV_ERROR IMG_CALLCONV PVRSRVReadRegistryString(PPVRSRV_REGISTRY_INFO
-						   psRegInfo);
-PVRSRV_ERROR IMG_CALLCONV PVRSRVWriteRegistryString(PPVRSRV_REGISTRY_INFO
-						    psRegInfo);
+struct PVRSRV_REGISTRY_INFO {
+	u32 ui32DevCookie;
+	char *pszKey;
+	char *pszValue;
+	char *pszBuf;
+	u32 ui32BufSize;
+};
+
+enum PVRSRV_ERROR PVRSRVReadRegistryString(
+				struct PVRSRV_REGISTRY_INFO *psRegInfo);
+enum PVRSRV_ERROR PVRSRVWriteRegistryString(
+				struct PVRSRV_REGISTRY_INFO *psRegInfo);
 
 #define PVRSRV_BC_FLAGS_YUVCSC_CONFORMANT_RANGE	(0 << 0)
 #define PVRSRV_BC_FLAGS_YUVCSC_FULL_RANGE		(1 << 0)
@@ -376,21 +359,21 @@
 #define PVRSRV_BC_FLAGS_YUVCSC_BT601			(0 << 1)
 #define PVRSRV_BC_FLAGS_YUVCSC_BT709			(1 << 1)
 
-typedef struct BUFFER_INFO_TAG {
-	IMG_UINT32 ui32BufferCount;
-	IMG_UINT32 ui32BufferDeviceID;
-	PVRSRV_PIXEL_FORMAT pixelformat;
-	IMG_UINT32 ui32ByteStride;
-	IMG_UINT32 ui32Width;
-	IMG_UINT32 ui32Height;
-	IMG_UINT32 ui32Flags;
-} BUFFER_INFO;
+struct BUFFER_INFO {
+	u32 ui32BufferCount;
+	u32 ui32BufferDeviceID;
+	enum PVRSRV_PIXEL_FORMAT pixelformat;
+	u32 ui32ByteStride;
+	u32 ui32Width;
+	u32 ui32Height;
+	u32 ui32Flags;
+};
 
-typedef enum _OVERLAY_DEINTERLACE_MODE_ {
+enum OVERLAY_DEINTERLACE_MODE {
 	WEAVE = 0x0,
 	BOB_ODD,
 	BOB_EVEN,
 	BOB_EVEN_NONINTERLEAVED
-} OVERLAY_DEINTERLACE_MODE;
+};
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/servicesint.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/servicesint.h
@@ -1,30 +1,30 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
-#if !defined (__SERVICESINT_H__)
+#if !defined(__SERVICESINT_H__)
 #define __SERVICESINT_H__
 
 
@@ -35,164 +35,136 @@
 
 #define DRIVERNAME_MAXLENGTH	(100)
 
-	typedef struct _PVRSRV_KERNEL_MEM_INFO_ {
-
-		IMG_PVOID pvLinAddrKM;
-
-		IMG_DEV_VIRTADDR sDevVAddr;
-
-		IMG_UINT32 ui32Flags;
+struct PVRSRV_KERNEL_MEM_INFO {
 
-		IMG_UINT32 ui32AllocSize;
-
-		PVRSRV_MEMBLK sMemBlk;
-
-		struct _PVRSRV_KERNEL_SYNC_INFO_ *psKernelSyncInfo;
-
-	} PVRSRV_KERNEL_MEM_INFO;
-
-	typedef struct _PVRSRV_KERNEL_SYNC_INFO_ {
-
-		PVRSRV_SYNC_DATA *psSyncData;
-
-		IMG_DEV_VIRTADDR sWriteOpsCompleteDevVAddr;
-
-		IMG_DEV_VIRTADDR sReadOpsCompleteDevVAddr;
-
-		PVRSRV_KERNEL_MEM_INFO *psSyncDataMemInfoKM;
-
-	} PVRSRV_KERNEL_SYNC_INFO;
-
-	typedef struct _PVRSRV_DEVICE_SYNC_OBJECT_ {
-		IMG_UINT32 ui32ReadOpPendingVal;
-		IMG_DEV_VIRTADDR sReadOpsCompleteDevVAddr;
-		IMG_UINT32 ui32WriteOpPendingVal;
-		IMG_DEV_VIRTADDR sWriteOpsCompleteDevVAddr;
-	} PVRSRV_DEVICE_SYNC_OBJECT;
-
-	typedef struct _PVRSRV_SYNC_OBJECT {
-		PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfoKM;
-		IMG_UINT32 ui32WriteOpsPending;
-		IMG_UINT32 ui32ReadOpsPending;
-
-	} PVRSRV_SYNC_OBJECT, *PPVRSRV_SYNC_OBJECT;
-
-	typedef struct _PVRSRV_COMMAND {
-		IMG_UINT32 ui32CmdSize;
-		IMG_UINT32 ui32DevIndex;
-		IMG_UINT32 CommandType;
-		IMG_UINT32 ui32DstSyncCount;
-		IMG_UINT32 ui32SrcSyncCount;
-		PVRSRV_SYNC_OBJECT *psDstSync;
-		PVRSRV_SYNC_OBJECT *psSrcSync;
-		IMG_UINT32 ui32DataSize;
-		IMG_UINT32 ui32ProcessID;
-		IMG_VOID *pvData;
-	} PVRSRV_COMMAND, *PPVRSRV_COMMAND;
-
-	typedef struct _PVRSRV_QUEUE_INFO_ {
-		IMG_VOID *pvLinQueueKM;
-		IMG_VOID *pvLinQueueUM;
-		volatile IMG_UINT32 ui32ReadOffset;
-		volatile IMG_UINT32 ui32WriteOffset;
-		IMG_UINT32 *pui32KickerAddrKM;
-		IMG_UINT32 *pui32KickerAddrUM;
-		IMG_UINT32 ui32QueueSize;
-
-		IMG_UINT32 ui32ProcessID;
-
-		IMG_HANDLE hMemBlock[2];
-
-		struct _PVRSRV_QUEUE_INFO_ *psNextKM;
-	} PVRSRV_QUEUE_INFO;
-
-	typedef PVRSRV_ERROR(*PFN_INSERT_CMD) (PVRSRV_QUEUE_INFO *,
-					       PVRSRV_COMMAND **,
-					       IMG_UINT32,
-					       IMG_UINT16,
-					       IMG_UINT32,
-					       PVRSRV_KERNEL_SYNC_INFO *[],
-					       IMG_UINT32,
-					       PVRSRV_KERNEL_SYNC_INFO *[],
-					       IMG_UINT32);
-	typedef PVRSRV_ERROR(*PFN_SUBMIT_CMD) (PVRSRV_QUEUE_INFO *,
-					       PVRSRV_COMMAND *, IMG_BOOL);
-
-	typedef struct PVRSRV_DEVICECLASS_BUFFER_TAG {
-		PFN_GET_BUFFER_ADDR pfnGetBufferAddr;
-		IMG_HANDLE hDevMemContext;
-		IMG_HANDLE hExtDevice;
-		IMG_HANDLE hExtBuffer;
-		PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
-
-	} PVRSRV_DEVICECLASS_BUFFER;
-
-	typedef struct PVRSRV_CLIENT_DEVICECLASS_INFO_TAG {
-		IMG_HANDLE hDeviceKM;
-		IMG_HANDLE hServices;
-	} PVRSRV_CLIENT_DEVICECLASS_INFO;
-
-	static INLINE
-	    IMG_UINT32 PVRSRVGetWriteOpsPending(PVRSRV_KERNEL_SYNC_INFO *
-						psSyncInfo,
-						IMG_BOOL bIsReadOp) {
-		IMG_UINT32 ui32WriteOpsPending;
-
-		if (bIsReadOp) {
-			ui32WriteOpsPending =
-			    psSyncInfo->psSyncData->ui32WriteOpsPending;
-		} else {
-
-			ui32WriteOpsPending =
-			    psSyncInfo->psSyncData->ui32WriteOpsPending++;
-		}
-
-		return ui32WriteOpsPending;
-	}
-
-	static INLINE
-	    IMG_UINT32 PVRSRVGetReadOpsPending(PVRSRV_KERNEL_SYNC_INFO *
-					       psSyncInfo, IMG_BOOL bIsReadOp) {
-		IMG_UINT32 ui32ReadOpsPending;
-
-		if (bIsReadOp) {
-			ui32ReadOpsPending =
-			    psSyncInfo->psSyncData->ui32ReadOpsPending++;
-		} else {
-			ui32ReadOpsPending =
-			    psSyncInfo->psSyncData->ui32ReadOpsPending;
-		}
-
-		return ui32ReadOpsPending;
-	}
-
-	IMG_IMPORT
-	    PVRSRV_ERROR PVRSRVQueueCommand(IMG_HANDLE hQueueInfo,
-					    PVRSRV_COMMAND * psCommand);
-
-	IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVGetMMUContextPDDevPAddr(const PVRSRV_CONNECTION *
-					  psConnection,
-					  IMG_HANDLE hDevMemContext,
-					  IMG_DEV_PHYADDR * sPDDevPAddr);
-
-	IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVAllocSharedSysMem(const PVRSRV_CONNECTION * psConnection,
-				    IMG_UINT32 ui32Flags,
-				    IMG_UINT32 ui32Size,
-				    PVRSRV_CLIENT_MEM_INFO ** ppsClientMemInfo);
-
-	IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVFreeSharedSysMem(const PVRSRV_CONNECTION * psConnection,
-				   PVRSRV_CLIENT_MEM_INFO * psClientMemInfo);
-
-	IMG_IMPORT PVRSRV_ERROR
-	    PVRSRVUnrefSharedSysMem(const PVRSRV_CONNECTION * psConnection,
-				    PVRSRV_CLIENT_MEM_INFO * psClientMemInfo);
-
-	IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV
-	    PVRSRVMapMemInfoMem(const PVRSRV_CONNECTION * psConnection,
-				IMG_HANDLE hKernelMemInfo,
-				PVRSRV_CLIENT_MEM_INFO ** ppsClientMemInfo);
+	void *pvLinAddrKM;
+	struct IMG_DEV_VIRTADDR sDevVAddr;
+	u32 ui32Flags;
+	u32 ui32AllocSize;
+	struct PVRSRV_MEMBLK sMemBlk;
+	struct PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
+};
+
+struct PVRSRV_KERNEL_SYNC_INFO {
+	struct PVRSRV_SYNC_DATA *psSyncData;
+	struct IMG_DEV_VIRTADDR sWriteOpsCompleteDevVAddr;
+	struct IMG_DEV_VIRTADDR sReadOpsCompleteDevVAddr;
+	struct PVRSRV_KERNEL_MEM_INFO *psSyncDataMemInfoKM;
+};
+
+struct PVRSRV_DEVICE_SYNC_OBJECT {
+	u32 ui32ReadOpPendingVal;
+	struct IMG_DEV_VIRTADDR sReadOpsCompleteDevVAddr;
+	u32 ui32WriteOpPendingVal;
+	struct IMG_DEV_VIRTADDR sWriteOpsCompleteDevVAddr;
+};
+
+struct PVRSRV_SYNC_OBJECT {
+	struct PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfoKM;
+	u32 ui32WriteOpsPending;
+	u32 ui32ReadOpsPending;
+};
+
+struct PVRSRV_COMMAND {
+	u32 ui32CmdSize;
+	u32 ui32DevIndex;
+	u32 CommandType;
+	u32 ui32DstSyncCount;
+	u32 ui32SrcSyncCount;
+	struct PVRSRV_SYNC_OBJECT *psDstSync;
+	struct PVRSRV_SYNC_OBJECT *psSrcSync;
+	u32 ui32DataSize;
+	u32 ui32ProcessID;
+	void *pvData;
+};
+
+struct PVRSRV_QUEUE_INFO {
+	void *pvLinQueueKM;
+	void *pvLinQueueUM;
+	volatile u32 ui32ReadOffset;
+	volatile u32 ui32WriteOffset;
+	u32 *pui32KickerAddrKM;
+	u32 *pui32KickerAddrUM;
+	u32 ui32QueueSize;
+
+	u32 ui32ProcessID;
+
+	void *hMemBlock[2];
+
+	struct PVRSRV_QUEUE_INFO *psNextKM;
+};
+
+
+struct PVRSRV_DEVICECLASS_BUFFER {
+	enum PVRSRV_ERROR (*pfnGetBufferAddr)(void *, void *,
+				    struct IMG_SYS_PHYADDR **, u32 *,
+				    void __iomem **, void **, IMG_BOOL *);
+	void *hDevMemContext;
+	void *hExtDevice;
+	void *hExtBuffer;
+	struct PVRSRV_KERNEL_SYNC_INFO *psKernelSyncInfo;
+};
+
+struct PVRSRV_CLIENT_DEVICECLASS_INFO {
+	void *hDeviceKM;
+	void *hServices;
+};
+
+static inline u32 PVRSRVGetWriteOpsPending(
+		struct PVRSRV_KERNEL_SYNC_INFO *psSyncInfo, IMG_BOOL bIsReadOp)
+{
+	u32 ui32WriteOpsPending;
+
+	if (bIsReadOp)
+		ui32WriteOpsPending =
+		    psSyncInfo->psSyncData->ui32WriteOpsPending;
+	else
+
+		ui32WriteOpsPending =
+		    psSyncInfo->psSyncData->ui32WriteOpsPending++;
+
+	return ui32WriteOpsPending;
+}
+
+static inline u32 PVRSRVGetReadOpsPending(
+		struct PVRSRV_KERNEL_SYNC_INFO *psSyncInfo, IMG_BOOL bIsReadOp)
+{
+	u32 ui32ReadOpsPending;
+
+	if (bIsReadOp)
+		ui32ReadOpsPending =
+		    psSyncInfo->psSyncData->ui32ReadOpsPending++;
+	else
+		ui32ReadOpsPending =
+		    psSyncInfo->psSyncData->ui32ReadOpsPending;
+
+	return ui32ReadOpsPending;
+}
+
+enum PVRSRV_ERROR PVRSRVQueueCommand(void *hQueueInfo,
+				    struct PVRSRV_COMMAND *psCommand);
+
+enum PVRSRV_ERROR PVRSRVGetMMUContextPDDevPAddr(
+			const struct PVRSRV_CONNECTION *psConnection,
+			void *hDevMemContext,
+			struct IMG_DEV_PHYADDR *sPDDevPAddr);
+
+enum PVRSRV_ERROR PVRSRVAllocSharedSysMem(
+			const struct PVRSRV_CONNECTION *psConnection,
+			u32 ui32Flags, u32 ui32Size,
+			struct PVRSRV_CLIENT_MEM_INFO **ppsClientMemInfo);
+
+enum PVRSRV_ERROR PVRSRVFreeSharedSysMem(
+			const struct PVRSRV_CONNECTION *psConnection,
+			struct PVRSRV_CLIENT_MEM_INFO *psClientMemInfo);
+
+enum PVRSRV_ERROR PVRSRVUnrefSharedSysMem(
+			const struct PVRSRV_CONNECTION *psConnection,
+			struct PVRSRV_CLIENT_MEM_INFO *psClientMemInfo);
+
+enum PVRSRV_ERROR PVRSRVMapMemInfoMem(
+			const struct PVRSRV_CONNECTION *psConnection,
+			void *hKernelMemInfo,
+			struct PVRSRV_CLIENT_MEM_INFO **ppsClientMemInfo);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgx530defs.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgx530defs.h
@@ -1,33 +1,33 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef _SGX530DEFS_KM_H_
 #define _SGX530DEFS_KM_H_
 
-#define EUR_CR_CLKGATECTL                   0x0000
+#define EUR_CR_CLKGATECTL		   0x0000
 #define EUR_CR_CLKGATECTL_2D_CLKG_MASK      0x00000003
 #define EUR_CR_CLKGATECTL_2D_CLKG_SHIFT     0
 #define EUR_CR_CLKGATECTL_ISP_CLKG_MASK     0x00000030
@@ -42,7 +42,7 @@
 #define EUR_CR_CLKGATECTL_USE_CLKG_SHIFT    20
 #define EUR_CR_CLKGATECTL_AUTO_MAN_REG_MASK 0x01000000
 #define EUR_CR_CLKGATECTL_AUTO_MAN_REG_SHIFT 24
-#define EUR_CR_CLKGATESTATUS                0x0004
+#define EUR_CR_CLKGATESTATUS		0x0004
 #define EUR_CR_CLKGATESTATUS_2D_CLKS_MASK   0x00000001
 #define EUR_CR_CLKGATESTATUS_2D_CLKS_SHIFT  0
 #define EUR_CR_CLKGATESTATUS_ISP_CLKS_MASK  0x00000010
@@ -55,7 +55,7 @@
 #define EUR_CR_CLKGATESTATUS_DPM_CLKS_SHIFT 16
 #define EUR_CR_CLKGATESTATUS_USE_CLKS_MASK  0x00100000
 #define EUR_CR_CLKGATESTATUS_USE_CLKS_SHIFT 20
-#define EUR_CR_CLKGATECTLOVR                0x0008
+#define EUR_CR_CLKGATECTLOVR		0x0008
 #define EUR_CR_CLKGATECTLOVR_2D_CLKO_MASK   0x00000003
 #define EUR_CR_CLKGATECTLOVR_2D_CLKO_SHIFT  0
 #define EUR_CR_CLKGATECTLOVR_ISP_CLKO_MASK  0x00000030
@@ -68,12 +68,12 @@
 #define EUR_CR_CLKGATECTLOVR_DPM_CLKO_SHIFT 16
 #define EUR_CR_CLKGATECTLOVR_USE_CLKO_MASK  0x00300000
 #define EUR_CR_CLKGATECTLOVR_USE_CLKO_SHIFT 20
-#define EUR_CR_CORE_ID                      0x0010
-#define EUR_CR_CORE_ID_CONFIG_MASK          0x0000FFFF
-#define EUR_CR_CORE_ID_CONFIG_SHIFT         0
-#define EUR_CR_CORE_ID_ID_MASK              0xFFFF0000
-#define EUR_CR_CORE_ID_ID_SHIFT             16
-#define EUR_CR_CORE_REVISION                0x0014
+#define EUR_CR_CORE_ID		      0x0010
+#define EUR_CR_CORE_ID_CONFIG_MASK	  0x0000FFFF
+#define EUR_CR_CORE_ID_CONFIG_SHIFT	 0
+#define EUR_CR_CORE_ID_ID_MASK	      0xFFFF0000
+#define EUR_CR_CORE_ID_ID_SHIFT	     16
+#define EUR_CR_CORE_REVISION		0x0014
 #define EUR_CR_CORE_REVISION_MAINTENANCE_MASK 0x000000FF
 #define EUR_CR_CORE_REVISION_MAINTENANCE_SHIFT 0
 #define EUR_CR_CORE_REVISION_MINOR_MASK     0x0000FF00
@@ -82,13 +82,13 @@
 #define EUR_CR_CORE_REVISION_MAJOR_SHIFT    16
 #define EUR_CR_CORE_REVISION_DESIGNER_MASK  0xFF000000
 #define EUR_CR_CORE_REVISION_DESIGNER_SHIFT 24
-#define EUR_CR_DESIGNER_REV_FIELD1          0x0018
+#define EUR_CR_DESIGNER_REV_FIELD1	  0x0018
 #define EUR_CR_DESIGNER_REV_FIELD1_DESIGNER_REV_FIELD1_MASK 0xFFFFFFFF
 #define EUR_CR_DESIGNER_REV_FIELD1_DESIGNER_REV_FIELD1_SHIFT 0
-#define EUR_CR_DESIGNER_REV_FIELD2          0x001C
+#define EUR_CR_DESIGNER_REV_FIELD2	  0x001C
 #define EUR_CR_DESIGNER_REV_FIELD2_DESIGNER_REV_FIELD2_MASK 0xFFFFFFFF
 #define EUR_CR_DESIGNER_REV_FIELD2_DESIGNER_REV_FIELD2_SHIFT 0
-#define EUR_CR_SOFT_RESET                   0x0080
+#define EUR_CR_SOFT_RESET		   0x0080
 #define EUR_CR_SOFT_RESET_BIF_RESET_MASK    0x00000001
 #define EUR_CR_SOFT_RESET_BIF_RESET_SHIFT   0
 #define EUR_CR_SOFT_RESET_TWOD_RESET_MASK   0x00000002
@@ -103,22 +103,22 @@
 #define EUR_CR_SOFT_RESET_ISP_RESET_SHIFT   5
 #define EUR_CR_SOFT_RESET_TSP_RESET_MASK    0x00000040
 #define EUR_CR_SOFT_RESET_TSP_RESET_SHIFT   6
-#define EUR_CR_EVENT_HOST_ENABLE2           0x0110
+#define EUR_CR_EVENT_HOST_ENABLE2	   0x0110
 #define EUR_CR_EVENT_HOST_ENABLE2_DPM_3D_FREE_LOAD_MASK 0x00000002
 #define EUR_CR_EVENT_HOST_ENABLE2_DPM_3D_FREE_LOAD_SHIFT 1
 #define EUR_CR_EVENT_HOST_ENABLE2_DPM_TA_FREE_LOAD_MASK 0x00000001
 #define EUR_CR_EVENT_HOST_ENABLE2_DPM_TA_FREE_LOAD_SHIFT 0
-#define EUR_CR_EVENT_HOST_CLEAR2            0x0114
+#define EUR_CR_EVENT_HOST_CLEAR2	    0x0114
 #define EUR_CR_EVENT_HOST_CLEAR2_DPM_3D_FREE_LOAD_MASK 0x00000002
 #define EUR_CR_EVENT_HOST_CLEAR2_DPM_3D_FREE_LOAD_SHIFT 1
 #define EUR_CR_EVENT_HOST_CLEAR2_DPM_TA_FREE_LOAD_MASK 0x00000001
 #define EUR_CR_EVENT_HOST_CLEAR2_DPM_TA_FREE_LOAD_SHIFT 0
-#define EUR_CR_EVENT_STATUS2                0x0118
+#define EUR_CR_EVENT_STATUS2		0x0118
 #define EUR_CR_EVENT_STATUS2_DPM_3D_FREE_LOAD_MASK 0x00000002
 #define EUR_CR_EVENT_STATUS2_DPM_3D_FREE_LOAD_SHIFT 1
 #define EUR_CR_EVENT_STATUS2_DPM_TA_FREE_LOAD_MASK 0x00000001
 #define EUR_CR_EVENT_STATUS2_DPM_TA_FREE_LOAD_SHIFT 0
-#define EUR_CR_EVENT_STATUS                 0x012C
+#define EUR_CR_EVENT_STATUS		 0x012C
 #define EUR_CR_EVENT_STATUS_MASTER_INTERRUPT_MASK 0x80000000
 #define EUR_CR_EVENT_STATUS_MASTER_INTERRUPT_SHIFT 31
 #define EUR_CR_EVENT_STATUS_TIMER_MASK      0x20000000
@@ -181,7 +181,7 @@
 #define EUR_CR_EVENT_STATUS_DPM_OUT_OF_MEMORY_MT_SHIFT 1
 #define EUR_CR_EVENT_STATUS_DPM_3D_MEM_FREE_MASK 0x00000001
 #define EUR_CR_EVENT_STATUS_DPM_3D_MEM_FREE_SHIFT 0
-#define EUR_CR_EVENT_HOST_ENABLE            0x0130
+#define EUR_CR_EVENT_HOST_ENABLE	    0x0130
 #define EUR_CR_EVENT_HOST_ENABLE_MASTER_INTERRUPT_MASK 0x80000000
 #define EUR_CR_EVENT_HOST_ENABLE_MASTER_INTERRUPT_SHIFT 31
 #define EUR_CR_EVENT_HOST_ENABLE_TIMER_MASK 0x20000000
@@ -244,7 +244,7 @@
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_OUT_OF_MEMORY_MT_SHIFT 1
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_3D_MEM_FREE_MASK 0x00000001
 #define EUR_CR_EVENT_HOST_ENABLE_DPM_3D_MEM_FREE_SHIFT 0
-#define EUR_CR_EVENT_HOST_CLEAR             0x0134
+#define EUR_CR_EVENT_HOST_CLEAR	     0x0134
 #define EUR_CR_EVENT_HOST_CLEAR_MASTER_INTERRUPT_MASK 0x80000000
 #define EUR_CR_EVENT_HOST_CLEAR_MASTER_INTERRUPT_SHIFT 31
 #define EUR_CR_EVENT_HOST_CLEAR_TIMER_MASK  0x20000000
@@ -307,49 +307,49 @@
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_OUT_OF_MEMORY_MT_SHIFT 1
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_3D_MEM_FREE_MASK 0x00000001
 #define EUR_CR_EVENT_HOST_CLEAR_DPM_3D_MEM_FREE_SHIFT 0
-#define EUR_CR_PDS                          0x0ABC
+#define EUR_CR_PDS			  0x0ABC
 #define EUR_CR_PDS_DOUT_TIMEOUT_DISABLE_MASK 0x00000040
 #define EUR_CR_PDS_DOUT_TIMEOUT_DISABLE_SHIFT 6
-#define EUR_CR_PDS_EXEC_BASE                0x0AB8
+#define EUR_CR_PDS_EXEC_BASE		0x0AB8
 #define EUR_CR_PDS_EXEC_BASE_ADDR_MASK      0x0FF00000
 #define EUR_CR_PDS_EXEC_BASE_ADDR_SHIFT     20
-#define EUR_CR_EVENT_KICKER                 0x0AC4
+#define EUR_CR_EVENT_KICKER		 0x0AC4
 #define EUR_CR_EVENT_KICKER_ADDRESS_MASK    0x0FFFFFF0
 #define EUR_CR_EVENT_KICKER_ADDRESS_SHIFT   4
-#define EUR_CR_EVENT_KICK                   0x0AC8
-#define EUR_CR_EVENT_KICK_NOW_MASK          0x00000001
-#define EUR_CR_EVENT_KICK_NOW_SHIFT         0
-#define EUR_CR_EVENT_TIMER                  0x0ACC
+#define EUR_CR_EVENT_KICK		   0x0AC8
+#define EUR_CR_EVENT_KICK_NOW_MASK	  0x00000001
+#define EUR_CR_EVENT_KICK_NOW_SHIFT	 0
+#define EUR_CR_EVENT_TIMER		  0x0ACC
 #define EUR_CR_EVENT_TIMER_ENABLE_MASK      0x01000000
 #define EUR_CR_EVENT_TIMER_ENABLE_SHIFT     24
 #define EUR_CR_EVENT_TIMER_VALUE_MASK       0x00FFFFFF
 #define EUR_CR_EVENT_TIMER_VALUE_SHIFT      0
-#define EUR_CR_PDS_INV0                     0x0AD0
-#define EUR_CR_PDS_INV0_DSC_MASK            0x00000001
-#define EUR_CR_PDS_INV0_DSC_SHIFT           0
-#define EUR_CR_PDS_INV1                     0x0AD4
-#define EUR_CR_PDS_INV1_DSC_MASK            0x00000001
-#define EUR_CR_PDS_INV1_DSC_SHIFT           0
-#define EUR_CR_PDS_INV2                     0x0AD8
-#define EUR_CR_PDS_INV2_DSC_MASK            0x00000001
-#define EUR_CR_PDS_INV2_DSC_SHIFT           0
-#define EUR_CR_PDS_INV3                     0x0ADC
-#define EUR_CR_PDS_INV3_DSC_MASK            0x00000001
-#define EUR_CR_PDS_INV3_DSC_SHIFT           0
-#define EUR_CR_PDS_INV_CSC                  0x0AE0
-#define EUR_CR_PDS_INV_CSC_KICK_MASK        0x00000001
+#define EUR_CR_PDS_INV0		     0x0AD0
+#define EUR_CR_PDS_INV0_DSC_MASK	    0x00000001
+#define EUR_CR_PDS_INV0_DSC_SHIFT	   0
+#define EUR_CR_PDS_INV1		     0x0AD4
+#define EUR_CR_PDS_INV1_DSC_MASK	    0x00000001
+#define EUR_CR_PDS_INV1_DSC_SHIFT	   0
+#define EUR_CR_PDS_INV2		     0x0AD8
+#define EUR_CR_PDS_INV2_DSC_MASK	    0x00000001
+#define EUR_CR_PDS_INV2_DSC_SHIFT	   0
+#define EUR_CR_PDS_INV3		     0x0ADC
+#define EUR_CR_PDS_INV3_DSC_MASK	    0x00000001
+#define EUR_CR_PDS_INV3_DSC_SHIFT	   0
+#define EUR_CR_PDS_INV_CSC		  0x0AE0
+#define EUR_CR_PDS_INV_CSC_KICK_MASK	0x00000001
 #define EUR_CR_PDS_INV_CSC_KICK_SHIFT       0
-#define EUR_CR_PDS_PC_BASE                  0x0B2C
+#define EUR_CR_PDS_PC_BASE		  0x0B2C
 #define EUR_CR_PDS_PC_BASE_ADDRESS_MASK     0x3FFFFFFF
 #define EUR_CR_PDS_PC_BASE_ADDRESS_SHIFT    0
-#define EUR_CR_BIF_CTRL                     0x0C00
+#define EUR_CR_BIF_CTRL		     0x0C00
 #define EUR_CR_BIF_CTRL_NOREORDER_MASK      0x00000001
 #define EUR_CR_BIF_CTRL_NOREORDER_SHIFT     0
-#define EUR_CR_BIF_CTRL_PAUSE_MASK          0x00000002
-#define EUR_CR_BIF_CTRL_PAUSE_SHIFT         1
-#define EUR_CR_BIF_CTRL_FLUSH_MASK          0x00000004
-#define EUR_CR_BIF_CTRL_FLUSH_SHIFT         2
-#define EUR_CR_BIF_CTRL_INVALDC_MASK        0x00000008
+#define EUR_CR_BIF_CTRL_PAUSE_MASK	  0x00000002
+#define EUR_CR_BIF_CTRL_PAUSE_SHIFT	 1
+#define EUR_CR_BIF_CTRL_FLUSH_MASK	  0x00000004
+#define EUR_CR_BIF_CTRL_FLUSH_SHIFT	 2
+#define EUR_CR_BIF_CTRL_INVALDC_MASK	0x00000008
 #define EUR_CR_BIF_CTRL_INVALDC_SHIFT       3
 #define EUR_CR_BIF_CTRL_CLEAR_FAULT_MASK    0x00000010
 #define EUR_CR_BIF_CTRL_CLEAR_FAULT_SHIFT   4
@@ -369,38 +369,38 @@
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_ISP_SHIFT 14
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_USE_MASK 0x00008000
 #define EUR_CR_BIF_CTRL_MMU_BYPASS_USE_SHIFT 15
-#define EUR_CR_BIF_INT_STAT                 0x0C04
+#define EUR_CR_BIF_INT_STAT		 0x0C04
 #define EUR_CR_BIF_INT_STAT_FAULT_MASK      0x00003FFF
 #define EUR_CR_BIF_INT_STAT_FAULT_SHIFT     0
 #define EUR_CR_BIF_INT_STAT_PF_N_RW_MASK    0x00004000
 #define EUR_CR_BIF_INT_STAT_PF_N_RW_SHIFT   14
-#define EUR_CR_BIF_FAULT                    0x0C08
-#define EUR_CR_BIF_FAULT_ADDR_MASK          0x0FFFF000
-#define EUR_CR_BIF_FAULT_ADDR_SHIFT         12
-#define EUR_CR_BIF_DIR_LIST_BASE0           0x0C84
+#define EUR_CR_BIF_FAULT		    0x0C08
+#define EUR_CR_BIF_FAULT_ADDR_MASK	  0x0FFFF000
+#define EUR_CR_BIF_FAULT_ADDR_SHIFT	 12
+#define EUR_CR_BIF_DIR_LIST_BASE0	   0x0C84
 #define EUR_CR_BIF_DIR_LIST_BASE0_ADDR_MASK 0xFFFFF000
 #define EUR_CR_BIF_DIR_LIST_BASE0_ADDR_SHIFT 12
-#define EUR_CR_BIF_TWOD_REQ_BASE            0x0C88
+#define EUR_CR_BIF_TWOD_REQ_BASE	    0x0C88
 #define EUR_CR_BIF_TWOD_REQ_BASE_ADDR_MASK  0x0FF00000
 #define EUR_CR_BIF_TWOD_REQ_BASE_ADDR_SHIFT 20
-#define EUR_CR_BIF_TA_REQ_BASE              0x0C90
+#define EUR_CR_BIF_TA_REQ_BASE	      0x0C90
 #define EUR_CR_BIF_TA_REQ_BASE_ADDR_MASK    0x0FF00000
 #define EUR_CR_BIF_TA_REQ_BASE_ADDR_SHIFT   20
-#define EUR_CR_BIF_MEM_REQ_STAT             0x0CA8
+#define EUR_CR_BIF_MEM_REQ_STAT	     0x0CA8
 #define EUR_CR_BIF_MEM_REQ_STAT_READS_MASK  0x000000FF
 #define EUR_CR_BIF_MEM_REQ_STAT_READS_SHIFT 0
-#define EUR_CR_BIF_3D_REQ_BASE              0x0CAC
+#define EUR_CR_BIF_3D_REQ_BASE	      0x0CAC
 #define EUR_CR_BIF_3D_REQ_BASE_ADDR_MASK    0x0FF00000
 #define EUR_CR_BIF_3D_REQ_BASE_ADDR_SHIFT   20
-#define EUR_CR_BIF_ZLS_REQ_BASE             0x0CB0
+#define EUR_CR_BIF_ZLS_REQ_BASE	     0x0CB0
 #define EUR_CR_BIF_ZLS_REQ_BASE_ADDR_MASK   0x0FF00000
 #define EUR_CR_BIF_ZLS_REQ_BASE_ADDR_SHIFT  20
-#define EUR_CR_2D_BLIT_STATUS               0x0E04
+#define EUR_CR_2D_BLIT_STATUS	       0x0E04
 #define EUR_CR_2D_BLIT_STATUS_COMPLETE_MASK 0x00FFFFFF
 #define EUR_CR_2D_BLIT_STATUS_COMPLETE_SHIFT 0
 #define EUR_CR_2D_BLIT_STATUS_BUSY_MASK     0x01000000
 #define EUR_CR_2D_BLIT_STATUS_BUSY_SHIFT    24
-#define EUR_CR_2D_VIRTUAL_FIFO_0            0x0E10
+#define EUR_CR_2D_VIRTUAL_FIFO_0	    0x0E10
 #define EUR_CR_2D_VIRTUAL_FIFO_0_ENABLE_MASK 0x00000001
 #define EUR_CR_2D_VIRTUAL_FIFO_0_ENABLE_SHIFT 0
 #define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_MASK 0x0000000E
@@ -409,7 +409,7 @@
 #define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_DIV_SHIFT 4
 #define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_MUL_MASK 0x0000F000
 #define EUR_CR_2D_VIRTUAL_FIFO_0_FLOWRATE_MUL_SHIFT 12
-#define EUR_CR_2D_VIRTUAL_FIFO_1            0x0E14
+#define EUR_CR_2D_VIRTUAL_FIFO_1	    0x0E14
 #define EUR_CR_2D_VIRTUAL_FIFO_1_MIN_ACC_MASK 0x00000FFF
 #define EUR_CR_2D_VIRTUAL_FIFO_1_MIN_ACC_SHIFT 0
 #define EUR_CR_2D_VIRTUAL_FIFO_1_MAX_ACC_MASK 0x00FFF000
@@ -419,7 +419,7 @@
 #define EUR_CR_USE_CODE_BASE(X)     (0x0A0C + (4 * (X)))
 #define EUR_CR_USE_CODE_BASE_ADDR_MASK      0x00FFFFFF
 #define EUR_CR_USE_CODE_BASE_ADDR_SHIFT     0
-#define EUR_CR_USE_CODE_BASE_DM_MASK        0x03000000
+#define EUR_CR_USE_CODE_BASE_DM_MASK	0x03000000
 #define EUR_CR_USE_CODE_BASE_DM_SHIFT       24
 #define EUR_CR_USE_CODE_BASE_SIZE_UINT32 16
 #define EUR_CR_USE_CODE_BASE_NUM_ENTRIES 16
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgx_bridge.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgx_bridge.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -32,292 +32,315 @@
 #include "pvr_bridge.h"
 
 
-#define PVRSRV_BRIDGE_SGX_CMD_BASE (PVRSRV_BRIDGE_LAST_NON_DEVICE_CMD+1)
-#define PVRSRV_BRIDGE_SGX_GETCLIENTINFO			PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+0)
-#define PVRSRV_BRIDGE_SGX_RELEASECLIENTINFO		PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+1)
-#define PVRSRV_BRIDGE_SGX_GETINTERNALDEVINFO	PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+2)
-#define PVRSRV_BRIDGE_SGX_DOKICK				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+3)
-#define PVRSRV_BRIDGE_SGX_GETPHYSPAGEADDR		PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+4)
-#define PVRSRV_BRIDGE_SGX_READREGISTRYDWORD		PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+5)
-#define PVRSRV_BRIDGE_SGX_SCHEDULECOMMAND		PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+6)
-
-#define PVRSRV_BRIDGE_SGX_2DQUERYBLTSCOMPLETE   PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+9)
-
-#define PVRSRV_BRIDGE_SGX_GETMMUPDADDR  		PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+10)
-
-#define PVRSRV_BRIDGE_SGX_SUBMITTRANSFER			PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+13)
-#define PVRSRV_BRIDGE_SGX_GETMISCINFO				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+14)
-#define PVRSRV_BRIDGE_SGXINFO_FOR_SRVINIT			PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+15)
-#define PVRSRV_BRIDGE_SGX_DEVINITPART2				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+16)
-
-#define PVRSRV_BRIDGE_SGX_FINDSHAREDPBDESC			PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+17)
-#define PVRSRV_BRIDGE_SGX_UNREFSHAREDPBDESC			PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+18)
-#define PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC			PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+19)
-#define PVRSRV_BRIDGE_SGX_REGISTER_HW_RENDER_CONTEXT	PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+20)
-#define PVRSRV_BRIDGE_SGX_FLUSH_HW_RENDER_TARGET	PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+21)
-#define PVRSRV_BRIDGE_SGX_UNREGISTER_HW_RENDER_CONTEXT	PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+22)
-#define PVRSRV_BRIDGE_SGX_REGISTER_HW_TRANSFER_CONTEXT	PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+26)
-#define PVRSRV_BRIDGE_SGX_UNREGISTER_HW_TRANSFER_CONTEXT	PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+27)
-#define PVRSRV_BRIDGE_SGX_READ_DIFF_COUNTERS		PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+28)
-
-#define PVRSRV_BRIDGE_LAST_SGX_CMD (PVRSRV_BRIDGE_SGX_CMD_BASE+28)
-
-	typedef struct PVRSRV_BRIDGE_IN_GETPHYSPAGEADDR {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevMemHeap;
-		IMG_DEV_VIRTADDR sDevVAddr;
-	} PVRSRV_BRIDGE_IN_GETPHYSPAGEADDR;
-
-	typedef struct PVRSRV_BRIDGE_OUT_GETPHYSPAGEADDR {
-		PVRSRV_ERROR eError;
-		IMG_DEV_PHYADDR DevPAddr;
-		IMG_CPU_PHYADDR CpuPAddr;
-	} PVRSRV_BRIDGE_OUT_GETPHYSPAGEADDR;
-
-	typedef struct PVRSRV_BRIDGE_IN_SGX_GETMMU_PDADDR_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_HANDLE hDevMemContext;
-	} PVRSRV_BRIDGE_IN_SGX_GETMMU_PDADDR;
-
-	typedef struct PVRSRV_BRIDGE_OUT_SGX_GETMMU_PDADDR_TAG {
-		IMG_DEV_PHYADDR sPDDevPAddr;
-		PVRSRV_ERROR eError;
-	} PVRSRV_BRIDGE_OUT_SGX_GETMMU_PDADDR;
-
-	typedef struct PVRSRV_BRIDGE_IN_GETCLIENTINFO_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-	} PVRSRV_BRIDGE_IN_GETCLIENTINFO;
-
-	typedef struct PVRSRV_BRIDGE_OUT_GETINTERNALDEVINFO_TAG {
-		PVR3DIF4_INTERNAL_DEVINFO sSGXInternalDevInfo;
-		PVRSRV_ERROR eError;
-	} PVRSRV_BRIDGE_OUT_GETINTERNALDEVINFO;
-
-	typedef struct PVRSRV_BRIDGE_IN_GETINTERNALDEVINFO_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-	} PVRSRV_BRIDGE_IN_GETINTERNALDEVINFO;
-
-	typedef struct PVRSRV_BRIDGE_OUT_GETCLIENTINFO_TAG {
-		PVR3DIF4_CLIENT_INFO sClientInfo;
-		PVRSRV_ERROR eError;
-	} PVRSRV_BRIDGE_OUT_GETCLIENTINFO;
-
-	typedef struct PVRSRV_BRIDGE_IN_RELEASECLIENTINFO_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		PVR3DIF4_CLIENT_INFO sClientInfo;
-	} PVRSRV_BRIDGE_IN_RELEASECLIENTINFO;
-
-	typedef struct PVRSRV_BRIDGE_IN_ISPBREAKPOLL_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-	} PVRSRV_BRIDGE_IN_ISPBREAKPOLL;
-
-	typedef struct PVRSRV_BRIDGE_IN_DOKICK_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		PVR3DIF4_CCB_KICK sCCBKick;
-	} PVRSRV_BRIDGE_IN_DOKICK;
-
-
-	typedef struct PVRSRV_BRIDGE_IN_SUBMITTRANSFER_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		PVRSRV_TRANSFER_SGX_KICK sKick;
-	} PVRSRV_BRIDGE_IN_SUBMITTRANSFER;
-
-
-	typedef struct PVRSRV_BRIDGE_IN_READREGDWORD_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_PCHAR pszKey;
-		IMG_PCHAR pszValue;
-	} PVRSRV_BRIDGE_IN_READREGDWORD;
-
-	typedef struct PVRSRV_BRIDGE_OUT_READREGDWORD_TAG {
-		PVRSRV_ERROR eError;
-		IMG_UINT32 ui32Data;
-	} PVRSRV_BRIDGE_OUT_READREGDWORD;
-
-	typedef struct PVRSRV_BRIDGE_IN_SCHEDULECOMMAND_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		PVRSRV_SGX_COMMAND_TYPE eCommandType;
-		PVRSRV_SGX_COMMAND *psCommandData;
-
-	} PVRSRV_BRIDGE_IN_SCHEDULECOMMAND;
-
-	typedef struct PVRSRV_BRIDGE_IN_SGXGETMISCINFO_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		SGX_MISC_INFO *psMiscInfo;
-	} PVRSRV_BRIDGE_IN_SGXGETMISCINFO;
-
-	typedef struct PVRSRV_BRIDGE_IN_SGXINFO_FOR_SRVINIT_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-	} PVRSRV_BRIDGE_IN_SGXINFO_FOR_SRVINIT;
-
-	typedef struct PVRSRV_BRIDGE_OUT_SGXINFO_FOR_SRVINIT_TAG {
-		PVRSRV_ERROR eError;
-		SGX_BRIDGE_INFO_FOR_SRVINIT sInitInfo;
-	} PVRSRV_BRIDGE_OUT_SGXINFO_FOR_SRVINIT;
-
-	typedef struct PVRSRV_BRIDGE_IN_SGXDEVINITPART2_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		SGX_BRIDGE_INIT_INFO sInitInfo;
-	} PVRSRV_BRIDGE_IN_SGXDEVINITPART2;
-
-	typedef struct PVRSRV_BRIDGE_IN_2DQUERYBLTSCOMPLETE_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_HANDLE hKernSyncInfo;
-		IMG_BOOL bWaitForComplete;
-	} PVRSRV_BRIDGE_IN_2DQUERYBLTSCOMPLETE;
+#define PVRSRV_BRIDGE_SGX_CMD_BASE					\
+				(PVRSRV_BRIDGE_LAST_NON_DEVICE_CMD+1)
+#define PVRSRV_BRIDGE_SGX_GETCLIENTINFO					\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+0)
+#define PVRSRV_BRIDGE_SGX_RELEASECLIENTINFO				\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+1)
+#define PVRSRV_BRIDGE_SGX_GETINTERNALDEVINFO				\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+2)
+#define PVRSRV_BRIDGE_SGX_DOKICK					\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+3)
+#define PVRSRV_BRIDGE_SGX_GETPHYSPAGEADDR				\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+4)
+#define PVRSRV_BRIDGE_SGX_READREGISTRYDWORD				\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+5)
+#define PVRSRV_BRIDGE_SGX_SCHEDULECOMMAND				\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+6)
+
+#define PVRSRV_BRIDGE_SGX_2DQUERYBLTSCOMPLETE				\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+9)
+
+#define PVRSRV_BRIDGE_SGX_GETMMUPDADDR					\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+10)
+
+#define PVRSRV_BRIDGE_SGX_SUBMITTRANSFER				\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+13)
+#define PVRSRV_BRIDGE_SGX_GETMISCINFO					\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+14)
+#define PVRSRV_BRIDGE_SGXINFO_FOR_SRVINIT				\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+15)
+#define PVRSRV_BRIDGE_SGX_DEVINITPART2					\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+16)
+
+#define PVRSRV_BRIDGE_SGX_FINDSHAREDPBDESC				\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+17)
+#define PVRSRV_BRIDGE_SGX_UNREFSHAREDPBDESC				\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+18)
+#define PVRSRV_BRIDGE_SGX_ADDSHAREDPBDESC				\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+19)
+#define PVRSRV_BRIDGE_SGX_REGISTER_HW_RENDER_CONTEXT			\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+20)
+#define PVRSRV_BRIDGE_SGX_FLUSH_HW_RENDER_TARGET			\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+21)
+#define PVRSRV_BRIDGE_SGX_UNREGISTER_HW_RENDER_CONTEXT			\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+22)
+#define PVRSRV_BRIDGE_SGX_REGISTER_HW_TRANSFER_CONTEXT			\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+26)
+#define PVRSRV_BRIDGE_SGX_UNREGISTER_HW_TRANSFER_CONTEXT		\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+27)
+#define PVRSRV_BRIDGE_SGX_READ_DIFF_COUNTERS				\
+				PVRSRV_IOWR(PVRSRV_BRIDGE_SGX_CMD_BASE+28)
+
+#define PVRSRV_BRIDGE_LAST_SGX_CMD					\
+				(PVRSRV_BRIDGE_SGX_CMD_BASE+28)
+
+struct PVRSRV_BRIDGE_IN_GETPHYSPAGEADDR {
+	u32 ui32BridgeFlags;
+	void *hDevMemHeap;
+	struct IMG_DEV_VIRTADDR sDevVAddr;
+};
+
+struct PVRSRV_BRIDGE_OUT_GETPHYSPAGEADDR {
+	enum PVRSRV_ERROR eError;
+	struct IMG_DEV_PHYADDR DevPAddr;
+	struct IMG_CPU_PHYADDR CpuPAddr;
+};
+
+struct PVRSRV_BRIDGE_IN_SGX_GETMMU_PDADDR {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	void *hDevMemContext;
+};
+
+struct PVRSRV_BRIDGE_OUT_SGX_GETMMU_PDADDR {
+	struct IMG_DEV_PHYADDR sPDDevPAddr;
+	enum PVRSRV_ERROR eError;
+};
+
+struct PVRSRV_BRIDGE_IN_GETCLIENTINFO {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+};
+
+struct PVRSRV_BRIDGE_OUT_GETINTERNALDEVINFO {
+	struct PVR3DIF4_INTERNAL_DEVINFO sSGXInternalDevInfo;
+	enum PVRSRV_ERROR eError;
+};
+
+struct PVRSRV_BRIDGE_IN_GETINTERNALDEVINFO {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+};
+
+struct PVRSRV_BRIDGE_OUT_GETCLIENTINFO {
+	struct PVR3DIF4_CLIENT_INFO sClientInfo;
+	enum PVRSRV_ERROR eError;
+};
+
+struct PVRSRV_BRIDGE_IN_RELEASECLIENTINFO {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	struct PVR3DIF4_CLIENT_INFO sClientInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_ISPBREAKPOLL {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+};
+
+struct PVRSRV_BRIDGE_IN_DOKICK {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	struct PVR3DIF4_CCB_KICK sCCBKick;
+};
+
+
+struct PVRSRV_BRIDGE_IN_SUBMITTRANSFER {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	struct PVRSRV_TRANSFER_SGX_KICK sKick;
+};
+
+
+struct PVRSRV_BRIDGE_IN_READREGDWORD {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	char *pszKey;
+	char *pszValue;
+};
+
+struct PVRSRV_BRIDGE_OUT_READREGDWORD {
+	enum PVRSRV_ERROR eError;
+	u32 ui32Data;
+};
+
+struct PVRSRV_BRIDGE_IN_SCHEDULECOMMAND {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	enum PVRSRV_SGX_COMMAND_TYPE eCommandType;
+	struct PVRSRV_SGX_COMMAND *psCommandData;
+
+};
+
+struct PVRSRV_BRIDGE_IN_SGXGETMISCINFO {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	struct SGX_MISC_INFO __user *psMiscInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_SGXINFO_FOR_SRVINIT {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+};
+
+struct PVRSRV_BRIDGE_OUT_SGXINFO_FOR_SRVINIT {
+	enum PVRSRV_ERROR eError;
+	struct SGX_BRIDGE_INFO_FOR_SRVINIT sInitInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_SGXDEVINITPART2 {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	struct SGX_BRIDGE_INIT_INFO sInitInfo;
+};
+
+struct PVRSRV_BRIDGE_IN_2DQUERYBLTSCOMPLETE {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	void *hKernSyncInfo;
+	IMG_BOOL bWaitForComplete;
+};
 
 #define PVRSRV_BRIDGE_SGX_SHAREDPBDESC_MAX_SUBMEMINFOS 10
 
-	typedef struct PVRSRV_BRIDGE_IN_SGXFINDSHAREDPBDESC_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_BOOL bLockOnFailure;
-		IMG_UINT32 ui32TotalPBSize;
-	} PVRSRV_BRIDGE_IN_SGXFINDSHAREDPBDESC;
-
-	typedef struct PVRSRV_BRIDGE_OUT_SGXFINDSHAREDPBDESC_TAG {
-		IMG_HANDLE hKernelMemInfo;
-		IMG_HANDLE hSharedPBDesc;
-		IMG_HANDLE hSharedPBDescKernelMemInfoHandle;
-		IMG_HANDLE hHWPBDescKernelMemInfoHandle;
-		IMG_HANDLE hBlockKernelMemInfoHandle;
-		IMG_HANDLE
-		    ahSharedPBDescSubKernelMemInfoHandles
-		    [PVRSRV_BRIDGE_SGX_SHAREDPBDESC_MAX_SUBMEMINFOS];
-		IMG_UINT32 ui32SharedPBDescSubKernelMemInfoHandlesCount;
-		PVRSRV_ERROR eError;
-	} PVRSRV_BRIDGE_OUT_SGXFINDSHAREDPBDESC;
-
-	typedef struct PVRSRV_BRIDGE_IN_SGXUNREFSHAREDPBDESC_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hSharedPBDesc;
-	} PVRSRV_BRIDGE_IN_SGXUNREFSHAREDPBDESC;
-
-	typedef struct PVRSRV_BRIDGE_OUT_SGXUNREFSHAREDPBDESC_TAG {
-		PVRSRV_ERROR eError;
-	} PVRSRV_BRIDGE_OUT_SGXUNREFSHAREDPBDESC;
-
-	typedef struct PVRSRV_BRIDGE_IN_SGXADDSHAREDPBDESC_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_HANDLE hSharedPBDescKernelMemInfo;
-		IMG_HANDLE hHWPBDescKernelMemInfo;
-		IMG_HANDLE hBlockKernelMemInfo;
-		IMG_UINT32 ui32TotalPBSize;
-		IMG_HANDLE *phKernelMemInfoHandles;
-		IMG_UINT32 ui32KernelMemInfoHandlesCount;
-	} PVRSRV_BRIDGE_IN_SGXADDSHAREDPBDESC;
-
-	typedef struct PVRSRV_BRIDGE_OUT_SGXADDSHAREDPBDESC_TAG {
-		PVRSRV_ERROR eError;
-		IMG_HANDLE hSharedPBDesc;
-	} PVRSRV_BRIDGE_OUT_SGXADDSHAREDPBDESC;
+struct PVRSRV_BRIDGE_IN_SGXFINDSHAREDPBDESC {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	IMG_BOOL bLockOnFailure;
+	u32 ui32TotalPBSize;
+};
+
+struct PVRSRV_BRIDGE_OUT_SGXFINDSHAREDPBDESC {
+	void *hKernelMemInfo;
+	void *hSharedPBDesc;
+	void *hSharedPBDescKernelMemInfoHandle;
+	void *hHWPBDescKernelMemInfoHandle;
+	void *hBlockKernelMemInfoHandle;
+	void *ahSharedPBDescSubKernelMemInfoHandles
+	    [PVRSRV_BRIDGE_SGX_SHAREDPBDESC_MAX_SUBMEMINFOS];
+	u32 ui32SharedPBDescSubKernelMemInfoHandlesCount;
+	enum PVRSRV_ERROR eError;
+};
+
+struct PVRSRV_BRIDGE_IN_SGXUNREFSHAREDPBDESC {
+	u32 ui32BridgeFlags;
+	void *hSharedPBDesc;
+};
+
+struct PVRSRV_BRIDGE_OUT_SGXUNREFSHAREDPBDESC {
+	enum PVRSRV_ERROR eError;
+};
+
+struct PVRSRV_BRIDGE_IN_SGXADDSHAREDPBDESC {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	void *hSharedPBDescKernelMemInfo;
+	void *hHWPBDescKernelMemInfo;
+	void *hBlockKernelMemInfo;
+	u32 ui32TotalPBSize;
+	void * __user *phKernelMemInfoHandles;
+	u32 ui32KernelMemInfoHandlesCount;
+};
+
+struct PVRSRV_BRIDGE_OUT_SGXADDSHAREDPBDESC {
+	enum PVRSRV_ERROR eError;
+	void *hSharedPBDesc;
+};
 
 #ifdef	PDUMP
-	typedef struct PVRSRV_BRIDGE_IN_PDUMP_BUFFER_ARRAY_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		PVR3DIF4_KICKTA_DUMP_BUFFER *psBufferArray;
-		IMG_UINT32 ui32BufferArrayLength;
-		IMG_BOOL bDumpPolls;
-	} PVRSRV_BRIDGE_IN_PDUMP_BUFFER_ARRAY;
-
-	typedef struct PVRSRV_BRIDGE_IN_PDUMP_3D_SIGNATURE_REGISTERS_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_UINT32 ui32DumpFrameNum;
-		IMG_BOOL bLastFrame;
-		IMG_UINT32 *pui32Registers;
-		IMG_UINT32 ui32NumRegisters;
-	} PVRSRV_BRIDGE_IN_PDUMP_3D_SIGNATURE_REGISTERS;
-
-	typedef struct PVRSRV_BRIDGE_IN_PDUMPCOUNTER_REGISTERS_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_UINT32 ui32DumpFrameNum;
-		IMG_BOOL bLastFrame;
-		IMG_UINT32 *pui32Registers;
-		IMG_UINT32 ui32NumRegisters;
-	} PVRSRV_BRIDGE_IN_PDUMP_COUNTER_REGISTERS;
-
-	typedef struct PVRSRV_BRIDGE_IN_PDUMP_TA_SIGNATURE_REGISTERS_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_UINT32 ui32DumpFrameNum;
-		IMG_UINT32 ui32TAKickCount;
-		IMG_BOOL bLastFrame;
-		IMG_UINT32 *pui32Registers;
-		IMG_UINT32 ui32NumRegisters;
-	} PVRSRV_BRIDGE_IN_PDUMP_TA_SIGNATURE_REGISTERS;
+struct PVRSRV_BRIDGE_IN_PDUMP_BUFFER_ARRAY {
+	u32 ui32BridgeFlags;
+	struct PVR3DIF4_KICKTA_DUMP_BUFFER *psBufferArray;
+	u32 ui32BufferArrayLength;
+	IMG_BOOL bDumpPolls;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_3D_SIGNATURE_REGISTERS {
+	u32 ui32BridgeFlags;
+	u32 ui32DumpFrameNum;
+	IMG_BOOL bLastFrame;
+	u32 *pui32Registers;
+	u32 ui32NumRegisters;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_COUNTER_REGISTERS {
+	u32 ui32BridgeFlags;
+	u32 ui32DumpFrameNum;
+	IMG_BOOL bLastFrame;
+	u32 *pui32Registers;
+	u32 ui32NumRegisters;
+};
+
+struct PVRSRV_BRIDGE_IN_PDUMP_TA_SIGNATURE_REGISTERS {
+	u32 ui32BridgeFlags;
+	u32 ui32DumpFrameNum;
+	u32 ui32TAKickCount;
+	IMG_BOOL bLastFrame;
+	u32 *pui32Registers;
+	u32 ui32NumRegisters;
+};
 
 #endif
 
-	typedef struct PVRSRV_BRIDGE_IN_SGX_REGISTER_HW_RENDER_CONTEXT_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_DEV_VIRTADDR sHWRenderContextDevVAddr;
-	} PVRSRV_BRIDGE_IN_SGX_REGISTER_HW_RENDER_CONTEXT;
-
-	typedef struct PVRSRV_BRIDGE_OUT_SGX_REGISTER_HW_RENDER_CONTEXT_TAG {
-		PVRSRV_ERROR eError;
-		IMG_HANDLE hHWRenderContext;
-	} PVRSRV_BRIDGE_OUT_SGX_REGISTER_HW_RENDER_CONTEXT;
-
-	typedef struct PVRSRV_BRIDGE_IN_SGX_UNREGISTER_HW_RENDER_CONTEXT_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_HANDLE hHWRenderContext;
-	} PVRSRV_BRIDGE_IN_SGX_UNREGISTER_HW_RENDER_CONTEXT;
-
-	typedef struct PVRSRV_BRIDGE_IN_SGX_REGISTER_HW_TRANSFER_CONTEXT_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_DEV_VIRTADDR sHWTransferContextDevVAddr;
-	} PVRSRV_BRIDGE_IN_SGX_REGISTER_HW_TRANSFER_CONTEXT;
-
-	typedef struct PVRSRV_BRIDGE_OUT_SGX_REGISTER_HW_TRANSFER_CONTEXT_TAG {
-		PVRSRV_ERROR eError;
-		IMG_HANDLE hHWTransferContext;
-	} PVRSRV_BRIDGE_OUT_SGX_REGISTER_HW_TRANSFER_CONTEXT;
-
-	typedef struct PVRSRV_BRIDGE_IN_SGX_UNREGISTER_HW_TRANSFER_CONTEXT_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_HANDLE hHWTransferContext;
-	} PVRSRV_BRIDGE_IN_SGX_UNREGISTER_HW_TRANSFER_CONTEXT;
-
-	typedef struct PVRSRV_BRIDGE_IN_SGX_FLUSH_HW_RENDER_TARGET_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_DEV_VIRTADDR sHWRTDataSetDevVAddr;
-	} PVRSRV_BRIDGE_IN_SGX_FLUSH_HW_RENDER_TARGET;
-
-
-	typedef struct PVRSRV_BRIDGE_IN_SGX_READ_DIFF_COUNTERS_TAG {
-		IMG_UINT32 ui32BridgeFlags;
-		IMG_HANDLE hDevCookie;
-		IMG_UINT32 ui32Reg;
-		IMG_BOOL bNew;
-		IMG_UINT32 ui32New;
-		IMG_UINT32 ui32NewReset;
-		IMG_UINT32 ui32CountersReg;
-	} PVRSRV_BRIDGE_IN_SGX_READ_DIFF_COUNTERS;
-
-	typedef struct PVRSRV_BRIDGE_OUT_SGX_READ_DIFF_COUNTERS_TAG {
-		PVRSRV_ERROR eError;
-		IMG_UINT32 ui32Old;
-		IMG_UINT32 ui32Time;
-		IMG_BOOL bActive;
-		PVRSRV_SGXDEV_DIFF_INFO sDiffs;
-	} PVRSRV_BRIDGE_OUT_SGX_READ_DIFF_COUNTERS;
+struct PVRSRV_BRIDGE_IN_SGX_REGISTER_HW_RENDER_CONTEXT {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	struct IMG_DEV_VIRTADDR sHWRenderContextDevVAddr;
+};
+
+struct PVRSRV_BRIDGE_OUT_SGX_REGISTER_HW_RENDER_CONTEXT {
+	enum PVRSRV_ERROR eError;
+	void *hHWRenderContext;
+};
+
+struct PVRSRV_BRIDGE_IN_SGX_UNREGISTER_HW_RENDER_CONTEXT {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	void *hHWRenderContext;
+};
+
+struct PVRSRV_BRIDGE_IN_SGX_REGISTER_HW_TRANSFER_CONTEXT {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	struct IMG_DEV_VIRTADDR sHWTransferContextDevVAddr;
+};
+
+struct PVRSRV_BRIDGE_OUT_SGX_REGISTER_HW_TRANSFER_CONTEXT {
+	enum PVRSRV_ERROR eError;
+	void *hHWTransferContext;
+};
+
+struct PVRSRV_BRIDGE_IN_SGX_UNREGISTER_HW_TRANSFER_CONTEXT {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	void *hHWTransferContext;
+};
+
+struct PVRSRV_BRIDGE_IN_SGX_FLUSH_HW_RENDER_TARGET {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	struct IMG_DEV_VIRTADDR sHWRTDataSetDevVAddr;
+};
+
+
+struct PVRSRV_BRIDGE_IN_SGX_READ_DIFF_COUNTERS {
+	u32 ui32BridgeFlags;
+	void *hDevCookie;
+	u32 ui32Reg;
+	IMG_BOOL bNew;
+	u32 ui32New;
+	u32 ui32NewReset;
+	u32 ui32CountersReg;
+};
+
+struct PVRSRV_BRIDGE_OUT_SGX_READ_DIFF_COUNTERS {
+	enum PVRSRV_ERROR eError;
+	u32 ui32Old;
+	u32 ui32Time;
+	IMG_BOOL bActive;
+	struct PVRSRV_SGXDEV_DIFF_INFO sDiffs;
+};
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgx_bridge_km.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgx_bridge_km.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -35,105 +35,66 @@
 #include "perproc.h"
 
 
-	IMG_IMPORT
-	    PVRSRV_ERROR SGXSubmitTransferKM(IMG_HANDLE hDevHandle,
-					     PVRSRV_TRANSFER_SGX_KICK * psKick);
-
-
-	IMG_IMPORT
-	    PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle,
-				     PVR3DIF4_CCB_KICK * psCCBKick);
-
-	IMG_IMPORT
-	    PVRSRV_ERROR SGXGetPhysPageAddrKM(IMG_HANDLE hDevMemHeap,
-					      IMG_DEV_VIRTADDR sDevVAddr,
-					      IMG_DEV_PHYADDR * pDevPAddr,
-					      IMG_CPU_PHYADDR * pCpuPAddr);
-
-	IMG_IMPORT
-	    PVRSRV_ERROR IMG_CALLCONV SGXGetMMUPDAddrKM(IMG_HANDLE hDevCookie,
-							IMG_HANDLE
-							hDevMemContext,
-							IMG_DEV_PHYADDR *
-							psPDDevPAddr);
-
-	IMG_IMPORT
-	    PVRSRV_ERROR SGXGetClientInfoKM(IMG_HANDLE hDevCookie,
-					    PVR3DIF4_CLIENT_INFO *
-					    psClientInfo);
-
-	IMG_IMPORT
-	    PVRSRV_ERROR SGXGetMiscInfoKM(PVRSRV_SGXDEV_INFO * psDevInfo,
-					  SGX_MISC_INFO * psMiscInfo);
-
-	IMG_IMPORT
-	    PVRSRV_ERROR SGXReadDiffCountersKM(IMG_HANDLE hDevHandle,
-					       IMG_UINT32 ui32Reg,
-					       IMG_UINT32 * pui32Old,
-					       IMG_BOOL bNew,
-					       IMG_UINT32 ui32New,
-					       IMG_UINT32 ui32NewReset,
-					       IMG_UINT32 ui32CountersReg,
-					       IMG_UINT32 * pui32Time,
-					       IMG_BOOL * pbActive,
-					       PVRSRV_SGXDEV_DIFF_INFO *
-					       psDiffs);
-
-	IMG_IMPORT
-	    PVRSRV_ERROR SGX2DQueryBlitsCompleteKM(PVRSRV_SGXDEV_INFO *
-						   psDevInfo,
-						   PVRSRV_KERNEL_SYNC_INFO *
-						   psSyncInfo,
-						   IMG_BOOL bWaitForComplete);
-
-	IMG_IMPORT
-	    PVRSRV_ERROR SGXGetInfoForSrvinitKM(IMG_HANDLE hDevHandle,
-						SGX_BRIDGE_INFO_FOR_SRVINIT *
-						psInitInfo);
-
-	IMG_IMPORT
-	    PVRSRV_ERROR DevInitSGXPart2KM(PVRSRV_PER_PROCESS_DATA * psPerProc,
-					   IMG_HANDLE hDevHandle,
-					   SGX_BRIDGE_INIT_INFO * psInitInfo);
-
-	IMG_IMPORT PVRSRV_ERROR
-	    SGXFindSharedPBDescKM(PVRSRV_PER_PROCESS_DATA * psPerProc,
-				  IMG_HANDLE hDevCookie,
-				  IMG_BOOL bLockOnFailure,
-				  IMG_UINT32 ui32TotalPBSize,
-				  IMG_HANDLE * phSharedPBDesc,
-				  PVRSRV_KERNEL_MEM_INFO **
-				  ppsSharedPBDescKernelMemInfo,
-				  PVRSRV_KERNEL_MEM_INFO **
-				  ppsHWPBDescKernelMemInfo,
-				  PVRSRV_KERNEL_MEM_INFO **
-				  ppsBlockKernelMemInfo,
-				  PVRSRV_KERNEL_MEM_INFO ***
-				  pppsSharedPBDescSubKernelMemInfos,
-				  IMG_UINT32 *
-				  ui32SharedPBDescSubKernelMemInfosCount);
-
-	IMG_IMPORT PVRSRV_ERROR
-	    SGXUnrefSharedPBDescKM(IMG_HANDLE hSharedPBDesc);
-
-	IMG_IMPORT PVRSRV_ERROR
-	    SGXAddSharedPBDescKM(PVRSRV_PER_PROCESS_DATA * psPerProc,
-				 IMG_HANDLE hDevCookie,
-				 PVRSRV_KERNEL_MEM_INFO *
-				 psSharedPBDescKernelMemInfo,
-				 PVRSRV_KERNEL_MEM_INFO *
-				 psHWPBDescKernelMemInfo,
-				 PVRSRV_KERNEL_MEM_INFO * psBlockKernelMemInfo,
-				 IMG_UINT32 ui32TotalPBSize,
-				 IMG_HANDLE * phSharedPBDesc,
-				 PVRSRV_KERNEL_MEM_INFO **
-				 psSharedPBDescSubKernelMemInfos,
-				 IMG_UINT32
-				 ui32SharedPBDescSubKernelMemInfosCount);
-
-	IMG_IMPORT PVRSRV_ERROR
-	    SGXGetInternalDevInfoKM(IMG_HANDLE hDevCookie,
-				    PVR3DIF4_INTERNAL_DEVINFO *
-				    psSGXInternalDevInfo);
+enum PVRSRV_ERROR SGXSubmitTransferKM(void *hDevHandle,
+		struct PVRSRV_TRANSFER_SGX_KICK *psKick);
+
+
+enum PVRSRV_ERROR SGXDoKickKM(void *hDevHandle,
+		struct PVR3DIF4_CCB_KICK *psCCBKick);
+
+enum PVRSRV_ERROR SGXGetPhysPageAddrKM(void *hDevMemHeap,
+		struct IMG_DEV_VIRTADDR sDevVAddr,
+		struct IMG_DEV_PHYADDR *pDevPAddr,
+		struct IMG_CPU_PHYADDR *pCpuPAddr);
+
+enum PVRSRV_ERROR SGXGetMMUPDAddrKM(void *hDevCookie,
+		void *hDevMemContext, struct IMG_DEV_PHYADDR *psPDDevPAddr);
+
+enum PVRSRV_ERROR SGXGetClientInfoKM(void *hDevCookie,
+		struct PVR3DIF4_CLIENT_INFO *psClientInfo);
+
+enum PVRSRV_ERROR SGXGetMiscInfoKM(struct PVRSRV_SGXDEV_INFO *psDevInfo,
+		struct SGX_MISC_INFO *psMiscInfo);
+
+enum PVRSRV_ERROR SGXReadDiffCountersKM(void *hDevHandle, u32 ui32Reg,
+		u32 *pui32Old, IMG_BOOL bNew, u32 ui32New, u32 ui32NewReset,
+		u32 ui32CountersReg, u32 *pui32Time, IMG_BOOL *pbActive,
+		struct PVRSRV_SGXDEV_DIFF_INFO *psDiffs);
+
+enum PVRSRV_ERROR SGX2DQueryBlitsCompleteKM(
+		struct PVRSRV_SGXDEV_INFO *psDevInfo,
+		struct PVRSRV_KERNEL_SYNC_INFO *psSyncInfo,
+		IMG_BOOL bWaitForComplete);
+
+enum PVRSRV_ERROR SGXGetInfoForSrvinitKM(void *hDevHandle,
+		struct SGX_BRIDGE_INFO_FOR_SRVINIT *psInitInfo);
+
+enum PVRSRV_ERROR DevInitSGXPart2KM(struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+		void *hDevHandle, struct SGX_BRIDGE_INIT_INFO *psInitInfo);
+
+enum PVRSRV_ERROR SGXFindSharedPBDescKM(
+	struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+	void *hDevCookie, IMG_BOOL bLockOnFailure, u32 ui32TotalPBSize,
+	void **phSharedPBDesc,
+	struct PVRSRV_KERNEL_MEM_INFO **ppsSharedPBDescKernelMemInfo,
+	struct PVRSRV_KERNEL_MEM_INFO **ppsHWPBDescKernelMemInfo,
+	struct PVRSRV_KERNEL_MEM_INFO **ppsBlockKernelMemInfo,
+	struct PVRSRV_KERNEL_MEM_INFO ***pppsSharedPBDescSubKernelMemInfos,
+	u32 *ui32SharedPBDescSubKernelMemInfosCount);
+
+enum PVRSRV_ERROR SGXUnrefSharedPBDescKM(void *hSharedPBDesc);
+
+enum PVRSRV_ERROR SGXAddSharedPBDescKM(
+		struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+		void *hDevCookie,
+		struct PVRSRV_KERNEL_MEM_INFO *psSharedPBDescKernelMemInfo,
+		struct PVRSRV_KERNEL_MEM_INFO *psHWPBDescKernelMemInfo,
+		struct PVRSRV_KERNEL_MEM_INFO *psBlockKernelMemInfo,
+		u32 ui32TotalPBSize, void **phSharedPBDesc,
+		struct PVRSRV_KERNEL_MEM_INFO **psSharedPBDescSubKernelMemInfos,
+		u32 ui32SharedPBDescSubKernelMemInfosCount);
+
+enum PVRSRV_ERROR SGXGetInternalDevInfoKM(void *hDevCookie,
+		struct PVR3DIF4_INTERNAL_DEVINFO *psSGXInternalDevInfo);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgxapi_km.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgxapi_km.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -31,142 +31,139 @@
 #include "sgxdefs.h"
 
 
-#define SGX_GENERAL_HEAP_ID					0
-#define SGX_TADATA_HEAP_ID					1
-#define SGX_KERNEL_CODE_HEAP_ID				2
-#define SGX_VIDEO_CODE_HEAP_ID				3
+#define SGX_GENERAL_HEAP_ID			0
+#define SGX_TADATA_HEAP_ID			1
+#define SGX_KERNEL_CODE_HEAP_ID			2
+#define SGX_VIDEO_CODE_HEAP_ID			3
 #define SGX_KERNEL_VIDEO_DATA_HEAP_ID		4
-#define SGX_PIXELSHADER_HEAP_ID				5
-#define SGX_VERTEXSHADER_HEAP_ID			6
+#define SGX_PIXELSHADER_HEAP_ID			5
+#define SGX_VERTEXSHADER_HEAP_ID		6
 #define SGX_PDSPIXEL_CODEDATA_HEAP_ID		7
 #define SGX_PDSVERTEX_CODEDATA_HEAP_ID		8
-#define SGX_SYNCINFO_HEAP_ID				9
-#define SGX_3DPARAMETERS_HEAP_ID			10
-#define SGX_GENERAL_MAPPING_HEAP_ID			11
-#define SGX_UNDEFINED_HEAP_ID				(~0LU)
-
-#define SGX_ALT_MAPPING_HEAP_ID                         12
-#define SGX_FB_MAPPING_HEAP_ID				13
-#define SGX_MAX_HEAP_ID					14
+#define SGX_SYNCINFO_HEAP_ID			9
+#define SGX_3DPARAMETERS_HEAP_ID		10
+#define SGX_GENERAL_MAPPING_HEAP_ID		11
+#define SGX_UNDEFINED_HEAP_ID			(~0LU)
+
+#define SGX_ALT_MAPPING_HEAP_ID			12
+#define SGX_FB_MAPPING_HEAP_ID			13
+#define SGX_MAX_HEAP_ID				14
 
-#define SGX_MAX_TA_STATUS_VALS	32
-#define SGX_MAX_3D_STATUS_VALS	2
+#define SGX_MAX_TA_STATUS_VALS			32
+#define SGX_MAX_3D_STATUS_VALS			2
 
 #define SGX_MAX_SRC_SYNCS			4
 
-	typedef struct _SGX_SLAVE_PORT_ {
-		IMG_PVOID pvData;
-		IMG_UINT32 ui32DataRange;
-		IMG_PUINT32 pui32Offset;
-		IMG_SYS_PHYADDR sPhysBase;
-	} SGX_SLAVE_PORT;
-
-
-#define PVRSRV_SGX_HWPERF_CBSIZE					0x100
-
-#define PVRSRV_SGX_HWPERF_INVALID					1
-#define PVRSRV_SGX_HWPERF_TRANSFER					2
-#define PVRSRV_SGX_HWPERF_TA						3
-#define PVRSRV_SGX_HWPERF_3D						4
-
-#define PVRSRV_SGX_HWPERF_ON						0x40
-
-	typedef struct _PVRSRV_SGX_HWPERF_CBDATA_ {
-		IMG_UINT32 ui32FrameNo;
-		IMG_UINT32 ui32Type;
-		IMG_UINT32 ui32StartTimeWraps;
-		IMG_UINT32 ui32StartTime;
-		IMG_UINT32 ui32EndTimeWraps;
-		IMG_UINT32 ui32EndTime;
-		IMG_UINT32 ui32ClockSpeed;
-		IMG_UINT32 ui32TimeMax;
-	} PVRSRV_SGX_HWPERF_CBDATA;
-
-	typedef struct _PVRSRV_SGX_HWPERF_CB_ {
-		IMG_UINT32 ui32Woff;
-		IMG_UINT32 ui32Roff;
-		PVRSRV_SGX_HWPERF_CBDATA
-		    psHWPerfCBData[PVRSRV_SGX_HWPERF_CBSIZE];
-	} PVRSRV_SGX_HWPERF_CB;
-
-	typedef struct _SGX_MISC_INFO_HWPERF_RETRIEVE_CB {
-		PVRSRV_SGX_HWPERF_CBDATA *psHWPerfData;
-		IMG_UINT32 ui32ArraySize;
-		IMG_UINT32 ui32DataCount;
-		IMG_UINT32 ui32Time;
-	} SGX_MISC_INFO_HWPERF_RETRIEVE_CB;
-
-	typedef enum _SGX_MISC_INFO_REQUEST_ {
-		SGX_MISC_INFO_REQUEST_CLOCKSPEED = 0,
-		SGX_MISC_INFO_REQUEST_HWPERF_CB_ON,
-		SGX_MISC_INFO_REQUEST_HWPERF_CB_OFF,
-		SGX_MISC_INFO_REQUEST_HWPERF_RETRIEVE_CB,
-		SGX_MISC_INFO_REQUEST_FORCE_I16 = 0x7fff
-	} SGX_MISC_INFO_REQUEST;
-
-	typedef struct _SGX_MISC_INFO_ {
-		SGX_MISC_INFO_REQUEST eRequest;
-
-		union {
-			IMG_UINT32 reserved;
-			IMG_UINT32 ui32SGXClockSpeed;
-			SGX_MISC_INFO_HWPERF_RETRIEVE_CB sRetrieveCB;
-		} uData;
-	} SGX_MISC_INFO;
+struct SGX_SLAVE_PORT {
+	void *pvData;
+	u32 ui32DataRange;
+	u32 *pui32Offset;
+	struct IMG_SYS_PHYADDR sPhysBase;
+};
+
+#define PVRSRV_SGX_HWPERF_CBSIZE		0x100
+
+#define PVRSRV_SGX_HWPERF_INVALID		1
+#define PVRSRV_SGX_HWPERF_TRANSFER		2
+#define PVRSRV_SGX_HWPERF_TA			3
+#define PVRSRV_SGX_HWPERF_3D			4
+
+#define PVRSRV_SGX_HWPERF_ON			0x40
+
+struct PVRSRV_SGX_HWPERF_CBDATA {
+	u32 ui32FrameNo;
+	u32 ui32Type;
+	u32 ui32StartTimeWraps;
+	u32 ui32StartTime;
+	u32 ui32EndTimeWraps;
+	u32 ui32EndTime;
+	u32 ui32ClockSpeed;
+	u32 ui32TimeMax;
+};
+
+struct PVRSRV_SGX_HWPERF_CB {
+	u32 ui32Woff;
+	u32 ui32Roff;
+	struct PVRSRV_SGX_HWPERF_CBDATA
+			    psHWPerfCBData[PVRSRV_SGX_HWPERF_CBSIZE];
+};
+
+struct SGX_MISC_INFO_HWPERF_RETRIEVE_CB {
+	struct PVRSRV_SGX_HWPERF_CBDATA *psHWPerfData;
+	u32 ui32ArraySize;
+	u32 ui32DataCount;
+	u32 ui32Time;
+};
+
+enum SGX_MISC_INFO_REQUEST {
+	SGX_MISC_INFO_REQUEST_CLOCKSPEED = 0,
+	SGX_MISC_INFO_REQUEST_HWPERF_CB_ON,
+	SGX_MISC_INFO_REQUEST_HWPERF_CB_OFF,
+	SGX_MISC_INFO_REQUEST_HWPERF_RETRIEVE_CB,
+	SGX_MISC_INFO_REQUEST_FORCE_I16 = 0x7fff
+};
+
+struct SGX_MISC_INFO {
+	enum SGX_MISC_INFO_REQUEST eRequest;
+
+	union {
+		u32 reserved;
+		u32 ui32SGXClockSpeed;
+		struct SGX_MISC_INFO_HWPERF_RETRIEVE_CB sRetrieveCB;
+	} uData;
+};
 
 
 #define PVR3DIF4_KICKTA_DUMPBITMAP_MAX_NAME_LENGTH		256
 
-	typedef struct _PVR3DIF4_KICKTA_DUMPBITMAP_ {
-		IMG_DEV_VIRTADDR sDevBaseAddr;
-		IMG_UINT32 ui32Flags;
-		IMG_UINT32 ui32Width;
-		IMG_UINT32 ui32Height;
-		IMG_UINT32 ui32Stride;
-		IMG_UINT32 ui32PDUMPFormat;
-		IMG_UINT32 ui32BytesPP;
-		IMG_CHAR pszName[PVR3DIF4_KICKTA_DUMPBITMAP_MAX_NAME_LENGTH];
-	} PVR3DIF4_KICKTA_DUMPBITMAP, *PPVR3DIF4_KICKTA_DUMPBITMAP;
+struct PVR3DIF4_KICKTA_DUMPBITMAP {
+	struct IMG_DEV_VIRTADDR sDevBaseAddr;
+	u32 ui32Flags;
+	u32 ui32Width;
+	u32 ui32Height;
+	u32 ui32Stride;
+	u32 ui32PDUMPFormat;
+	u32 ui32BytesPP;
+	char pszName[PVR3DIF4_KICKTA_DUMPBITMAP_MAX_NAME_LENGTH];
+};
 
 #define PVRSRV_SGX_PDUMP_CONTEXT_MAX_BITMAP_ARRAY_SIZE	(16)
 
-	typedef struct _PVRSRV_SGX_PDUMP_CONTEXT_ {
-
-		IMG_UINT32 ui32CacheControl;
-
-	} PVRSRV_SGX_PDUMP_CONTEXT;
-
-	typedef struct _PVR3DIF4_KICKTA_DUMP_ROFF_ {
-		IMG_HANDLE hKernelMemInfo;
-		IMG_UINT32 uiAllocIndex;
-		IMG_UINT32 ui32Offset;
-		IMG_UINT32 ui32Value;
-		IMG_PCHAR pszName;
-	} PVR3DIF4_KICKTA_DUMP_ROFF, *PPVR3DIF4_KICKTA_DUMP_ROFF;
-
-	typedef struct _PVR3DIF4_KICKTA_DUMP_BUFFER_ {
-		IMG_UINT32 ui32SpaceUsed;
-		IMG_UINT32 ui32Start;
-		IMG_UINT32 ui32End;
-		IMG_UINT32 ui32BufferSize;
-		IMG_UINT32 ui32BackEndLength;
-		IMG_UINT32 uiAllocIndex;
-		IMG_HANDLE hKernelMemInfo;
-		IMG_PCHAR pszName;
-	} PVR3DIF4_KICKTA_DUMP_BUFFER, *PPVR3DIF4_KICKTA_DUMP_BUFFER;
+struct PVRSRV_SGX_PDUMP_CONTEXT {
+	u32 ui32CacheControl;
+};
+
+struct PVR3DIF4_KICKTA_DUMP_ROFF {
+	void *hKernelMemInfo;
+	u32 uiAllocIndex;
+	u32 ui32Offset;
+	u32 ui32Value;
+	char *pszName;
+};
+
+struct PVR3DIF4_KICKTA_DUMP_BUFFER {
+	u32 ui32SpaceUsed;
+	u32 ui32Start;
+	u32 ui32End;
+	u32 ui32BufferSize;
+	u32 ui32BackEndLength;
+	u32 uiAllocIndex;
+	void *hKernelMemInfo;
+	char *pszName;
+};
 
 #ifdef PDUMP
-	typedef struct _PVR3DIF4_KICKTA_PDUMP_ {
+struct PVR3DIF4_KICKTA_PDUMP {
 
-		PPVR3DIF4_KICKTA_DUMPBITMAP psPDumpBitmapArray;
-		IMG_UINT32 ui32PDumpBitmapSize;
+	struct PVR3DIF4_KICKTA_DUMPBITMAP *psPDumpBitmapArray;
+	u32 ui32PDumpBitmapSize;
 
-		PPVR3DIF4_KICKTA_DUMP_BUFFER psBufferArray;
-		IMG_UINT32 ui32BufferArraySize;
+	struct PVR3DIF4_KICKTA_DUMP_BUFFER *psBufferArray;
+	u32 ui32BufferArraySize;
 
-		PPVR3DIF4_KICKTA_DUMP_ROFF psROffArray;
-		IMG_UINT32 ui32ROffArraySize;
-	} PVR3DIF4_KICKTA_PDUMP, *PPVR3DIF4_KICKTA_PDUMP;
+	struct PVR3DIF4_KICKTA_DUMP_ROFF *psROffArray;
+	u32 ui32ROffArraySize;
+};
 #endif
 
 #define SGX_MAX_TRANSFER_STATUS_VALS	2
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgxconfig.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgxconfig.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -38,31 +38,31 @@
 #define DEV_MINOR_VERSION		0
 
 
-#define SGX_ADDRESS_SPACE_SIZE				28
+#define SGX_ADDRESS_SPACE_SIZE			28
 
-#define SGX_GENERAL_HEAP_BASE		0x00400000
-#define SGX_GENERAL_HEAP_SIZE		(0x05000000-0x00401000)
+#define SGX_GENERAL_HEAP_BASE			0x00400000
+#define SGX_GENERAL_HEAP_SIZE			(0x05000000-0x00401000)
 
-#define SGX_GENERAL_MAPPING_HEAP_BASE	0x05000000
-#define SGX_GENERAL_MAPPING_HEAP_SIZE	(0x06800000-0x05001000)
+#define SGX_GENERAL_MAPPING_HEAP_BASE		0x05000000
+#define SGX_GENERAL_MAPPING_HEAP_SIZE		(0x06800000-0x05001000)
 
-#define SGX_FB_MAPPING_HEAP_BASE	0x06800000
-#define SGX_FB_MAPPING_HEAP_SIZE	(0x07000000-0x06801000)
+#define SGX_FB_MAPPING_HEAP_BASE		0x06800000
+#define SGX_FB_MAPPING_HEAP_SIZE		(0x07000000-0x06801000)
 
-#define SGX_TADATA_HEAP_BASE				0x07000000
-#define SGX_TADATA_HEAP_SIZE				(0x01000000-0x00001000)
+#define SGX_TADATA_HEAP_BASE			0x07000000
+#define SGX_TADATA_HEAP_SIZE			(0x01000000-0x00001000)
 
-#define SGX_3DPARAMETERS_HEAP_BASE			0x08000000
-#define SGX_3DPARAMETERS_HEAP_SIZE			(0x04000000-0x00001000)
+#define SGX_3DPARAMETERS_HEAP_BASE		0x08000000
+#define SGX_3DPARAMETERS_HEAP_SIZE		(0x04000000-0x00001000)
 
-#define SGX_ALT_MAPPING_HEAP_BASE	(0x0C000000)
-#define SGX_ALT_MAPPING_HEAP_SIZE	(0x0D000000 - 0x0C001000)
+#define SGX_ALT_MAPPING_HEAP_BASE		(0x0C000000)
+#define SGX_ALT_MAPPING_HEAP_SIZE		(0x0D000000 - 0x0C001000)
 
-#define SGX_PIXELSHADER_HEAP_BASE			0x0D000000
-#define SGX_PIXELSHADER_HEAP_SIZE			0x00500000
+#define SGX_PIXELSHADER_HEAP_BASE		0x0D000000
+#define SGX_PIXELSHADER_HEAP_SIZE		0x00500000
 
-#define SGX_VERTEXSHADER_HEAP_BASE			0x0D800000
-#define SGX_VERTEXSHADER_HEAP_SIZE			0x00200000
+#define SGX_VERTEXSHADER_HEAP_BASE		0x0D800000
+#define SGX_VERTEXSHADER_HEAP_SIZE		0x00200000
 
 #define SGX_PDSPIXEL_CODEDATA_HEAP_BASE		0x0E000000
 #define SGX_PDSPIXEL_CODEDATA_HEAP_SIZE		(0x00800000-0x00001000)
@@ -70,16 +70,16 @@
 #define SGX_PDSVERTEX_CODEDATA_HEAP_BASE	0x0E800000
 #define SGX_PDSVERTEX_CODEDATA_HEAP_SIZE	(0x00800000-0x00001000)
 
-#define SGX_KERNEL_CODE_HEAP_BASE			0x0F000000
-#define SGX_KERNEL_CODE_HEAP_SIZE			0x00080000
+#define SGX_KERNEL_CODE_HEAP_BASE		0x0F000000
+#define SGX_KERNEL_CODE_HEAP_SIZE		0x00080000
 
-#define SGX_VIDEO_CODE_HEAP_BASE			0x0F400000
-#define SGX_VIDEO_CODE_HEAP_SIZE			0x00080000
+#define SGX_VIDEO_CODE_HEAP_BASE		0x0F400000
+#define SGX_VIDEO_CODE_HEAP_SIZE		0x00080000
 
 #define SGX_KERNEL_VIDEO_DATA_HEAP_BASE		0x0F800000
 #define SGX_KERNEL_VIDEO_DATA_HEAP_SIZE		(0x00400000-0x00001000)
 
-#define SGX_SYNCINFO_HEAP_BASE				0x0FC00000
-#define SGX_SYNCINFO_HEAP_SIZE				(0x00400000-0x00001000)
+#define SGX_SYNCINFO_HEAP_BASE			0x0FC00000
+#define SGX_SYNCINFO_HEAP_SIZE			(0x00400000-0x00001000)
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgxcoretypes.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgxcoretypes.h
@@ -1,41 +1,41 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef _SGXCORETYPES_KM_H_
 #define _SGXCORETYPES_KM_H_
 
-typedef enum {
-	SGX_CORE_ID_INVALID = 0,
-	SGX_CORE_ID_530 = 2,
-	SGX_UNUSED = 3,
-} SGX_CORE_ID_TYPE;
+enum SGX_CORE_ID_TYPE {
+	SGX_CORE_ID_INVALID	= 0,
+	SGX_CORE_ID_530		= 2,
+	SGX_UNUSED		= 3,
+};
 
-typedef struct _SGX_CORE_INFO {
-	SGX_CORE_ID_TYPE eID;
-	IMG_UINT32 uiRev;
-} SGX_CORE_INFO, *PSGX_CORE_INFO;
+struct SGX_CORE_INFO {
+	enum SGX_CORE_ID_TYPE eID;
+	u32 uiRev;
+};
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgxdefs.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgxdefs.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgxerrata.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgxerrata.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgxfeaturedefs.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgxfeaturedefs.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgxinfo.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgxinfo.h
@@ -1,30 +1,30 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
-#if !defined (__SGXINFO_H__)
+#if !defined(__SGXINFO_H__)
 #define __SGXINFO_H__
 
 #include "sgxscript.h"
@@ -37,78 +37,78 @@
 #define SGX_MAX_DEV_DATA		24
 #define	SGX_MAX_INIT_MEM_HANDLES	16
 
-typedef struct _SGX_BRIDGE_INFO_FOR_SRVINIT {
-	IMG_DEV_PHYADDR sPDDevPAddr;
-	PVRSRV_HEAP_INFO asHeapInfo[PVRSRV_MAX_CLIENT_HEAPS];
-} SGX_BRIDGE_INFO_FOR_SRVINIT;
-
-typedef struct _SGX_BRIDGE_INIT_INFO_ {
-	IMG_HANDLE hKernelCCBMemInfo;
-	IMG_HANDLE hKernelCCBCtlMemInfo;
-	IMG_HANDLE hKernelCCBEventKickerMemInfo;
-	IMG_HANDLE hKernelSGXHostCtlMemInfo;
-	IMG_UINT32 ui32TAKickAddress;
-	IMG_UINT32 ui32VideoHandlerAddress;
-	IMG_HANDLE hKernelHWPerfCBMemInfo;
-
-	IMG_UINT32 ui32EDMTaskReg0;
-	IMG_UINT32 ui32EDMTaskReg1;
-
-	IMG_UINT32 ui32ClkGateCtl;
-	IMG_UINT32 ui32ClkGateCtl2;
-	IMG_UINT32 ui32ClkGateStatusMask;
-
-	IMG_UINT32 ui32CacheControl;
-
-	IMG_UINT32 asInitDevData[SGX_MAX_DEV_DATA];
-	IMG_HANDLE asInitMemHandles[SGX_MAX_INIT_MEM_HANDLES];
-
-	SGX_INIT_SCRIPTS sScripts;
-
-} SGX_BRIDGE_INIT_INFO;
-
-typedef struct _PVRSRV_SGX_COMMAND_ {
-	IMG_UINT32 ui32ServiceAddress;
-	IMG_UINT32 ui32Data[7];
-} PVRSRV_SGX_COMMAND;
-
-typedef struct _PVRSRV_SGX_KERNEL_CCB_ {
-	PVRSRV_SGX_COMMAND asCommands[256];
-} PVRSRV_SGX_KERNEL_CCB;
-
-typedef struct _PVRSRV_SGX_CCB_CTL_ {
-	IMG_UINT32 ui32WriteOffset;
-	IMG_UINT32 ui32ReadOffset;
-} PVRSRV_SGX_CCB_CTL;
+struct SGX_BRIDGE_INFO_FOR_SRVINIT {
+	struct IMG_DEV_PHYADDR sPDDevPAddr;
+	struct PVRSRV_HEAP_INFO asHeapInfo[PVRSRV_MAX_CLIENT_HEAPS];
+};
+
+struct SGX_BRIDGE_INIT_INFO {
+	void *hKernelCCBMemInfo;
+	void *hKernelCCBCtlMemInfo;
+	void *hKernelCCBEventKickerMemInfo;
+	void *hKernelSGXHostCtlMemInfo;
+	u32 ui32TAKickAddress;
+	u32 ui32VideoHandlerAddress;
+	void *hKernelHWPerfCBMemInfo;
+
+	u32 ui32EDMTaskReg0;
+	u32 ui32EDMTaskReg1;
+
+	u32 ui32ClkGateCtl;
+	u32 ui32ClkGateCtl2;
+	u32 ui32ClkGateStatusMask;
+
+	u32 ui32CacheControl;
+
+	u32 asInitDevData[SGX_MAX_DEV_DATA];
+	void *asInitMemHandles[SGX_MAX_INIT_MEM_HANDLES];
+
+	struct SGX_INIT_SCRIPTS sScripts;
+
+};
+
+struct PVRSRV_SGX_COMMAND {
+	u32 ui32ServiceAddress;
+	u32 ui32Data[7];
+};
+
+struct PVRSRV_SGX_KERNEL_CCB {
+	struct PVRSRV_SGX_COMMAND asCommands[256];
+};
+
+struct PVRSRV_SGX_CCB_CTL {
+	u32 ui32WriteOffset;
+	u32 ui32ReadOffset;
+};
 
 #define SGX_AUXCCBFLAGS_SHARED					0x00000001
 
-typedef enum _PVRSRV_SGX_COMMAND_TYPE_ {
+enum PVRSRV_SGX_COMMAND_TYPE {
 	PVRSRV_SGX_COMMAND_EDM_KICK = 0,
 	PVRSRV_SGX_COMMAND_VIDEO_KICK = 1,
 
 	PVRSRV_SGX_COMMAND_FORCE_I32 = 0xFFFFFFFF,
 
-} PVRSRV_SGX_COMMAND_TYPE;
+};
 
 #define PVRSRV_CCBFLAGS_RASTERCMD			0x1
 #define PVRSRV_CCBFLAGS_TRANSFERCMD			0x2
-#define PVRSRV_CCBFLAGS_PROCESS_QUEUESCMD	0x3
+#define PVRSRV_CCBFLAGS_PROCESS_QUEUESCMD		0x3
 
-#define	SGX_BIF_INVALIDATE_PTCACHE	0x1
-#define	SGX_BIF_INVALIDATE_PDCACHE	0x2
+#define	SGX_BIF_INVALIDATE_PTCACHE			0x1
+#define	SGX_BIF_INVALIDATE_PDCACHE			0x2
 
-typedef struct _PVR3DIF4_CCB_KICK_ {
-	PVRSRV_SGX_COMMAND_TYPE eCommand;
-	PVRSRV_SGX_COMMAND sCommand;
-	IMG_HANDLE hCCBKernelMemInfo;
-	IMG_HANDLE hRenderSurfSyncInfo;
+struct PVR3DIF4_CCB_KICK {
+	enum PVRSRV_SGX_COMMAND_TYPE eCommand;
+	struct PVRSRV_SGX_COMMAND sCommand;
+	void *hCCBKernelMemInfo;
+	void *hRenderSurfSyncInfo;
 
-	IMG_UINT32 ui32NumTAStatusVals;
-	IMG_HANDLE ahTAStatusSyncInfo[SGX_MAX_TA_STATUS_VALS];
+	u32 ui32NumTAStatusVals;
+	void *ahTAStatusSyncInfo[SGX_MAX_TA_STATUS_VALS];
 
-	IMG_UINT32 ui32Num3DStatusVals;
-	IMG_HANDLE ah3DStatusSyncInfo[SGX_MAX_3D_STATUS_VALS];
+	u32 ui32Num3DStatusVals;
+	void *ah3DStatusSyncInfo[SGX_MAX_3D_STATUS_VALS];
 
 	IMG_BOOL bFirstKickOrResume;
 #ifdef PDUMP
@@ -116,194 +116,193 @@
 #endif
 	IMG_BOOL bKickRender;
 
-	IMG_UINT32 ui32CCBOffset;
+	u32 ui32CCBOffset;
 
-	IMG_UINT32 ui32NumSrcSyncs;
-	IMG_HANDLE ahSrcKernelSyncInfo[SGX_MAX_SRC_SYNCS];
+	u32 ui32NumSrcSyncs;
+	void *ahSrcKernelSyncInfo[SGX_MAX_SRC_SYNCS];
 
 	IMG_BOOL bTADependency;
-	IMG_HANDLE hTA3DSyncInfo;
+	void *hTA3DSyncInfo;
 
-	IMG_HANDLE hTASyncInfo;
-	IMG_HANDLE h3DSyncInfo;
+	void *hTASyncInfo;
+	void *h3DSyncInfo;
 #if defined(PDUMP)
-	IMG_UINT32 ui32CCBDumpWOff;
+	u32 ui32CCBDumpWOff;
 #endif
-} PVR3DIF4_CCB_KICK;
+};
 
 #define SGX_VIDEO_USE_CODE_BASE_INDEX		14
 #define SGX_KERNEL_USE_CODE_BASE_INDEX		15
 
-typedef struct _PVRSRV_SGX_HOST_CTL_ {
+struct PVRSRV_SGX_HOST_CTL {
 
-	volatile IMG_UINT32 ui32PowManFlags;
-	IMG_UINT32 ui32uKernelDetectedLockups;
-	IMG_UINT32 ui32HostDetectedLockups;
-	IMG_UINT32 ui32HWRecoverySampleRate;
-	IMG_UINT32 ui32ActivePowManSampleRate;
-	IMG_UINT32 ui32InterruptFlags;
-	IMG_UINT32 ui32InterruptClearFlags;
+	volatile u32 ui32PowManFlags;
+	u32 ui32uKernelDetectedLockups;
+	u32 ui32HostDetectedLockups;
+	u32 ui32HWRecoverySampleRate;
+	u32 ui32ActivePowManSampleRate;
+	u32 ui32InterruptFlags;
+	u32 ui32InterruptClearFlags;
 
-	IMG_UINT32 ui32ResManFlags;
-	IMG_DEV_VIRTADDR sResManCleanupData;
+	u32 ui32ResManFlags;
+	struct IMG_DEV_VIRTADDR sResManCleanupData;
 
-	IMG_DEV_VIRTADDR sTAHWPBDesc;
-	IMG_DEV_VIRTADDR s3DHWPBDesc;
-	IMG_DEV_VIRTADDR sHostHWPBDesc;
+	struct IMG_DEV_VIRTADDR sTAHWPBDesc;
+	struct IMG_DEV_VIRTADDR s3DHWPBDesc;
+	struct IMG_DEV_VIRTADDR sHostHWPBDesc;
 
-	IMG_UINT32 ui32NumActivePowerEvents;
+	u32 ui32NumActivePowerEvents;
 
-	IMG_UINT32 ui32HWPerfFlags;
+	u32 ui32HWPerfFlags;
 
-	IMG_UINT32 ui32TimeWraps;
-} PVRSRV_SGX_HOST_CTL;
+	u32 ui32TimeWraps;
+};
 
-typedef struct _PVR3DIF4_CLIENT_INFO_ {
-	IMG_UINT32 ui32ProcessID;
-	IMG_VOID *pvProcess;
-	PVRSRV_MISC_INFO sMiscInfo;
+struct PVR3DIF4_CLIENT_INFO {
+	u32 ui32ProcessID;
+	void *pvProcess;
+	struct PVRSRV_MISC_INFO sMiscInfo;
 
-	IMG_UINT32 asDevData[SGX_MAX_DEV_DATA];
+	u32 asDevData[SGX_MAX_DEV_DATA];
 
-} PVR3DIF4_CLIENT_INFO;
+};
 
-typedef struct _PVR3DIF4_INTERNAL_DEVINFO_ {
-	IMG_UINT32 ui32Flags;
-	IMG_HANDLE hCtlKernelMemInfoHandle;
+struct PVR3DIF4_INTERNAL_DEVINFO {
+	u32 ui32Flags;
+	void *hCtlKernelMemInfoHandle;
 	IMG_BOOL bForcePTOff;
-} PVR3DIF4_INTERNAL_DEVINFO;
+};
 
-typedef struct _PVRSRV_SGX_SHARED_CCB_ {
-	PVRSRV_CLIENT_MEM_INFO *psCCBClientMemInfo;
-	PVRSRV_CLIENT_MEM_INFO *psCCBCtlClientMemInfo;
-	IMG_UINT32 *pui32CCBLinAddr;
-	IMG_DEV_VIRTADDR sCCBDevAddr;
-	IMG_UINT32 *pui32WriteOffset;
-	volatile IMG_UINT32 *pui32ReadOffset;
-	IMG_UINT32 ui32Size;
-	IMG_UINT32 ui32AllocGran;
+struct PVRSRV_SGX_SHARED_CCB {
+	struct PVRSRV_CLIENT_MEM_INFO *psCCBClientMemInfo;
+	struct PVRSRV_CLIENT_MEM_INFO *psCCBCtlClientMemInfo;
+	u32 *pui32CCBLinAddr;
+	struct IMG_DEV_VIRTADDR sCCBDevAddr;
+	u32 *pui32WriteOffset;
+	volatile u32 *pui32ReadOffset;
+	u32 ui32Size;
+	u32 ui32AllocGran;
 
 #ifdef PDUMP
-	IMG_UINT32 ui32CCBDumpWOff;
+	u32 ui32CCBDumpWOff;
 #endif
-} PVRSRV_SGX_SHARED_CCB;
+};
 
-typedef struct _PVRSRV_SGX_CCB_ {
-	PVRSRV_KERNEL_MEM_INFO *psCCBMemInfo;
-	PVRSRV_KERNEL_MEM_INFO *psCCBCtlMemInfo;
-	IMG_PUINT32 pui32CCBLinAddr;
-	IMG_DEV_VIRTADDR sCCBDevAddr;
-	IMG_UINT32 *pui32WriteOffset;
-	volatile IMG_UINT32 *pui32ReadOffset;
-	IMG_UINT32 ui32Size;
-	IMG_UINT32 ui32AllocGran;
+struct PVRSRV_SGX_CCB {
+	struct PVRSRV_KERNEL_MEM_INFO *psCCBMemInfo;
+	struct PVRSRV_KERNEL_MEM_INFO *psCCBCtlMemInfo;
+	u32 *pui32CCBLinAddr;
+	struct IMG_DEV_VIRTADDR sCCBDevAddr;
+	u32 *pui32WriteOffset;
+	volatile u32 *pui32ReadOffset;
+	u32 ui32Size;
+	u32 ui32AllocGran;
 
 #ifdef PDUMP
-	IMG_UINT32 ui32CCBDumpWOff;
+	u32 ui32CCBDumpWOff;
 #endif
-} PVRSRV_SGX_CCB;
+};
 
-typedef struct _CTL_STATUS_ {
-	IMG_DEV_VIRTADDR sStatusDevAddr;
-	IMG_UINT32 ui32StatusValue;
-} CTL_STATUS, *PCTL_STATUS;
+struct CTL_STATUS {
+	struct IMG_DEV_VIRTADDR sStatusDevAddr;
+	u32 ui32StatusValue;
+};
 
-#define SGXTQ_MAX_STATUS						SGX_MAX_TRANSFER_STATUS_VALS + 2
-typedef struct _PVR3DIF4_CMDTA_SHARED_ {
-	IMG_UINT32 ui32NumTAStatusVals;
-	IMG_UINT32 ui32Num3DStatusVals;
+#define SGXTQ_MAX_STATUS		(SGX_MAX_TRANSFER_STATUS_VALS + 2)
+struct PVR3DIF4_CMDTA_SHARED {
+	u32 ui32NumTAStatusVals;
+	u32 ui32Num3DStatusVals;
 
-	IMG_UINT32 ui32WriteOpsPendingVal;
-	IMG_DEV_VIRTADDR sWriteOpsCompleteDevVAddr;
-	IMG_UINT32 ui32ReadOpsPendingVal;
-	IMG_DEV_VIRTADDR sReadOpsCompleteDevVAddr;
+	u32 ui32WriteOpsPendingVal;
+	struct IMG_DEV_VIRTADDR sWriteOpsCompleteDevVAddr;
+	u32 ui32ReadOpsPendingVal;
+	struct IMG_DEV_VIRTADDR sReadOpsCompleteDevVAddr;
 
-	IMG_UINT32 ui32TQSyncWriteOpsPendingVal;
-	IMG_DEV_VIRTADDR sTQSyncWriteOpsCompleteDevVAddr;
-	IMG_UINT32 ui32TQSyncReadOpsPendingVal;
-	IMG_DEV_VIRTADDR sTQSyncReadOpsCompleteDevVAddr;
+	u32 ui32TQSyncWriteOpsPendingVal;
+	struct IMG_DEV_VIRTADDR sTQSyncWriteOpsCompleteDevVAddr;
+	u32 ui32TQSyncReadOpsPendingVal;
+	struct IMG_DEV_VIRTADDR sTQSyncReadOpsCompleteDevVAddr;
 
-	IMG_UINT32 ui323DTQSyncWriteOpsPendingVal;
-	IMG_DEV_VIRTADDR s3DTQSyncWriteOpsCompleteDevVAddr;
-	IMG_UINT32 ui323DTQSyncReadOpsPendingVal;
-	IMG_DEV_VIRTADDR s3DTQSyncReadOpsCompleteDevVAddr;
+	u32 ui323DTQSyncWriteOpsPendingVal;
+	struct IMG_DEV_VIRTADDR s3DTQSyncWriteOpsCompleteDevVAddr;
+	u32 ui323DTQSyncReadOpsPendingVal;
+	struct IMG_DEV_VIRTADDR s3DTQSyncReadOpsCompleteDevVAddr;
 
-	IMG_UINT32 ui32NumSrcSyncs;
-	PVRSRV_DEVICE_SYNC_OBJECT asSrcSyncs[SGX_MAX_SRC_SYNCS];
+	u32 ui32NumSrcSyncs;
+	struct PVRSRV_DEVICE_SYNC_OBJECT asSrcSyncs[SGX_MAX_SRC_SYNCS];
 
-	CTL_STATUS sCtlTAStatusInfo[SGX_MAX_TA_STATUS_VALS];
-	CTL_STATUS sCtl3DStatusInfo[SGX_MAX_3D_STATUS_VALS];
+	struct CTL_STATUS sCtlTAStatusInfo[SGX_MAX_TA_STATUS_VALS];
+	struct CTL_STATUS sCtl3DStatusInfo[SGX_MAX_3D_STATUS_VALS];
 
-	PVRSRV_DEVICE_SYNC_OBJECT sTA3DDependancy;
+	struct PVRSRV_DEVICE_SYNC_OBJECT sTA3DDependancy;
 
-} PVR3DIF4_CMDTA_SHARED;
+};
 
-typedef struct _PVR3DIF4_TRANSFERCMD_SHARED_ {
+struct PVR3DIF4_TRANSFERCMD_SHARED {
 
-	IMG_UINT32 ui32SrcReadOpPendingVal;
-	IMG_DEV_VIRTADDR sSrcReadOpsCompleteDevAddr;
+	u32 ui32SrcReadOpPendingVal;
+	struct IMG_DEV_VIRTADDR sSrcReadOpsCompleteDevAddr;
 
-	IMG_UINT32 ui32SrcWriteOpPendingVal;
-	IMG_DEV_VIRTADDR sSrcWriteOpsCompleteDevAddr;
+	u32 ui32SrcWriteOpPendingVal;
+	struct IMG_DEV_VIRTADDR sSrcWriteOpsCompleteDevAddr;
 
-	IMG_UINT32 ui32DstReadOpPendingVal;
-	IMG_DEV_VIRTADDR sDstReadOpsCompleteDevAddr;
+	u32 ui32DstReadOpPendingVal;
+	struct IMG_DEV_VIRTADDR sDstReadOpsCompleteDevAddr;
 
-	IMG_UINT32 ui32DstWriteOpPendingVal;
-	IMG_DEV_VIRTADDR sDstWriteOpsCompleteDevAddr;
+	u32 ui32DstWriteOpPendingVal;
+	struct IMG_DEV_VIRTADDR sDstWriteOpsCompleteDevAddr;
 
-	IMG_UINT32 ui32TASyncWriteOpsPendingVal;
-	IMG_DEV_VIRTADDR sTASyncWriteOpsCompleteDevVAddr;
-	IMG_UINT32 ui32TASyncReadOpsPendingVal;
-	IMG_DEV_VIRTADDR sTASyncReadOpsCompleteDevVAddr;
+	u32 ui32TASyncWriteOpsPendingVal;
+	struct IMG_DEV_VIRTADDR sTASyncWriteOpsCompleteDevVAddr;
+	u32 ui32TASyncReadOpsPendingVal;
+	struct IMG_DEV_VIRTADDR sTASyncReadOpsCompleteDevVAddr;
 
-	IMG_UINT32 ui323DSyncWriteOpsPendingVal;
-	IMG_DEV_VIRTADDR s3DSyncWriteOpsCompleteDevVAddr;
-	IMG_UINT32 ui323DSyncReadOpsPendingVal;
-	IMG_DEV_VIRTADDR s3DSyncReadOpsCompleteDevVAddr;
+	u32 ui323DSyncWriteOpsPendingVal;
+	struct IMG_DEV_VIRTADDR s3DSyncWriteOpsCompleteDevVAddr;
+	u32 ui323DSyncReadOpsPendingVal;
+	struct IMG_DEV_VIRTADDR s3DSyncReadOpsCompleteDevVAddr;
 
-	IMG_UINT32 ui32NumStatusVals;
-	CTL_STATUS sCtlStatusInfo[SGXTQ_MAX_STATUS];
+	u32 ui32NumStatusVals;
+	struct CTL_STATUS sCtlStatusInfo[SGXTQ_MAX_STATUS];
 
-	IMG_UINT32 ui32NumSrcSync;
-	IMG_UINT32 ui32NumDstSync;
+	u32 ui32NumSrcSync;
+	u32 ui32NumDstSync;
 
-	IMG_DEV_VIRTADDR sSrcWriteOpsDevVAddr[SGX_MAX_TRANSFER_SYNC_OPS];
-	IMG_DEV_VIRTADDR sSrcReadOpsDevVAddr[SGX_MAX_TRANSFER_SYNC_OPS];
+	struct IMG_DEV_VIRTADDR sSrcWriteOpsDevVAddr[SGX_MAX_TRANSFER_SYNC_OPS];
+	struct IMG_DEV_VIRTADDR sSrcReadOpsDevVAddr[SGX_MAX_TRANSFER_SYNC_OPS];
 
-	IMG_DEV_VIRTADDR sDstWriteOpsDevVAddr[SGX_MAX_TRANSFER_SYNC_OPS];
-	IMG_DEV_VIRTADDR sDstReadOpsDevVAddr[SGX_MAX_TRANSFER_SYNC_OPS];
-} PVR3DIF4_TRANSFERCMD_SHARED, *PPVR3DIF4_TRANSFERCMD_SHARED;
+	struct IMG_DEV_VIRTADDR sDstWriteOpsDevVAddr[SGX_MAX_TRANSFER_SYNC_OPS];
+	struct IMG_DEV_VIRTADDR sDstReadOpsDevVAddr[SGX_MAX_TRANSFER_SYNC_OPS];
+};
 
-typedef struct _PVRSRV_TRANSFER_SGX_KICK_ {
-	IMG_HANDLE hCCBMemInfo;
-	IMG_UINT32 ui32SharedCmdCCBOffset;
+struct PVRSRV_TRANSFER_SGX_KICK {
+	void *hCCBMemInfo;
+	u32 ui32SharedCmdCCBOffset;
 
-	IMG_DEV_VIRTADDR sHWTransferContextDevVAddr;
+	struct IMG_DEV_VIRTADDR sHWTransferContextDevVAddr;
 
-	IMG_HANDLE hTASyncInfo;
-	IMG_HANDLE h3DSyncInfo;
+	void *hTASyncInfo;
+	void *h3DSyncInfo;
 
-	IMG_UINT32 ui32NumSrcSync;
-	IMG_HANDLE ahSrcSyncInfo[SGX_MAX_TRANSFER_SYNC_OPS];
+	u32 ui32NumSrcSync;
+	void *ahSrcSyncInfo[SGX_MAX_TRANSFER_SYNC_OPS];
 
-	IMG_UINT32 ui32NumDstSync;
-	IMG_HANDLE ahDstSyncInfo[SGX_MAX_TRANSFER_SYNC_OPS];
+	u32 ui32NumDstSync;
+	void *ahDstSyncInfo[SGX_MAX_TRANSFER_SYNC_OPS];
 
-	IMG_UINT32 ui32StatusFirstSync;
+	u32 ui32StatusFirstSync;
 
 #if defined(PDUMP)
-	IMG_UINT32 ui32CCBDumpWOff;
+	u32 ui32CCBDumpWOff;
 #endif
-} PVRSRV_TRANSFER_SGX_KICK, *PPVRSRV_TRANSFER_SGX_KICK;
-
+};
 
 #define PVRSRV_SGX_DIFF_NUM_COUNTERS	9
 
-typedef struct _PVRSRV_SGXDEV_DIFF_INFO_ {
-	IMG_UINT32 aui32Counters[PVRSRV_SGX_DIFF_NUM_COUNTERS];
-	IMG_UINT32 ui32Time[2];
-	IMG_UINT32 ui32Marker[2];
-} PVRSRV_SGXDEV_DIFF_INFO, *PPVRSRV_SGXDEV_DIFF_INFO;
+struct PVRSRV_SGXDEV_DIFF_INFO {
+	u32 aui32Counters[PVRSRV_SGX_DIFF_NUM_COUNTERS];
+	u32 ui32Time[2];
+	u32 ui32Marker[2];
+};
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgxinfokm.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgxinfokm.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -34,173 +34,165 @@
 #include "sgxinfo.h"
 
 
-#define		SGX_HOSTPORT_PRESENT			0x00000001UL
+#define	SGX_HOSTPORT_PRESENT					0x00000001UL
 
-#define PVRSRV_USSE_EDM_POWMAN_IDLE_REQUEST					(1UL << 0)
-#define PVRSRV_USSE_EDM_POWMAN_POWEROFF_REQUEST				(1UL << 1)
-#define PVRSRV_USSE_EDM_POWMAN_IDLE_COMPLETE				(1UL << 2)
-#define PVRSRV_USSE_EDM_POWMAN_POWEROFF_COMPLETE			(1UL << 3)
+#define PVRSRV_USSE_EDM_POWMAN_IDLE_REQUEST			(1UL << 0)
+#define PVRSRV_USSE_EDM_POWMAN_POWEROFF_REQUEST			(1UL << 1)
+#define PVRSRV_USSE_EDM_POWMAN_IDLE_COMPLETE			(1UL << 2)
+#define PVRSRV_USSE_EDM_POWMAN_POWEROFF_COMPLETE		(1UL << 3)
 #define PVRSRV_USSE_EDM_POWMAN_POWEROFF_RESTART_IMMEDIATE	(1UL << 4)
-#define PVRSRV_USSE_EDM_POWMAN_NO_WORK						(1UL << 5)
+#define PVRSRV_USSE_EDM_POWMAN_NO_WORK				(1UL << 5)
 
-#define PVRSRV_USSE_EDM_INTERRUPT_HWR			(1UL << 0)
-#define PVRSRV_USSE_EDM_INTERRUPT_ACTIVE_POWER	(1UL << 1)
+#define PVRSRV_USSE_EDM_INTERRUPT_HWR				(1UL << 0)
+#define PVRSRV_USSE_EDM_INTERRUPT_ACTIVE_POWER			(1UL << 1)
 
-#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_RT_REQUEST 	0x01UL
-#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_RC_REQUEST 	0x02UL
-#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_TC_REQUEST 	0x04UL
-#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_2DC_REQUEST 	0x08UL
-#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_COMPLETE 	0x10UL
+#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_RT_REQUEST	0x01UL
+#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_RC_REQUEST	0x02UL
+#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_TC_REQUEST	0x04UL
+#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_2DC_REQUEST	0x08UL
+#define PVRSRV_USSE_EDM_RESMAN_CLEANUP_COMPLETE		0x10UL
 #define PVRSRV_USSE_EDM_RESMAN_CLEANUP_INVALPD		0x20UL
 #define PVRSRV_USSE_EDM_RESMAN_CLEANUP_INVALPT		0x40UL
 
-	typedef struct _PVRSRV_SGX_CCB_INFO_ *PPVRSRV_SGX_CCB_INFO;
-
-	typedef struct _PVRSRV_SGXDEV_INFO_ {
-		PVRSRV_DEVICE_TYPE eDeviceType;
-		PVRSRV_DEVICE_CLASS eDeviceClass;
+struct PVRSRV_SGX_CCB_INFO;
 
-		IMG_UINT8 ui8VersionMajor;
-		IMG_UINT8 ui8VersionMinor;
-		IMG_UINT32 ui32CoreConfig;
-		IMG_UINT32 ui32CoreFlags;
+struct PVRSRV_SGXDEV_INFO {
+	enum PVRSRV_DEVICE_TYPE eDeviceType;
+	enum PVRSRV_DEVICE_CLASS eDeviceClass;
 
-		IMG_PVOID pvRegsBaseKM;
+	u8 ui8VersionMajor;
+	u8 ui8VersionMinor;
+	u32 ui32CoreConfig;
+	u32 ui32CoreFlags;
 
-		IMG_HANDLE hRegMapping;
+	void __iomem *pvRegsBaseKM;
 
-		IMG_SYS_PHYADDR sRegsPhysBase;
+	void *hRegMapping;
 
-		IMG_UINT32 ui32RegSize;
+	struct IMG_SYS_PHYADDR sRegsPhysBase;
 
-		IMG_UINT32 ui32CoreClockSpeed;
-		IMG_UINT32 ui32uKernelTimerClock;
+	u32 ui32RegSize;
 
+	u32 ui32CoreClockSpeed;
+	u32 ui32uKernelTimerClock;
 
-		IMG_VOID *psStubPBDescListKM;
+	void *psStubPBDescListKM;
 
-		IMG_DEV_PHYADDR sKernelPDDevPAddr;
+	struct IMG_DEV_PHYADDR sKernelPDDevPAddr;
 
-		IMG_VOID *pvDeviceMemoryHeap;
-		PPVRSRV_KERNEL_MEM_INFO psKernelCCBMemInfo;
-		PVRSRV_SGX_KERNEL_CCB *psKernelCCB;
-		PPVRSRV_SGX_CCB_INFO psKernelCCBInfo;
-		PPVRSRV_KERNEL_MEM_INFO psKernelCCBCtlMemInfo;
-		PVRSRV_SGX_CCB_CTL *psKernelCCBCtl;
-		PPVRSRV_KERNEL_MEM_INFO psKernelCCBEventKickerMemInfo;
-		IMG_UINT32 *pui32KernelCCBEventKicker;
-		IMG_UINT32 ui32TAKickAddress;
-		IMG_UINT32 ui32TexLoadKickAddress;
-		IMG_UINT32 ui32VideoHandlerAddress;
-		IMG_UINT32 ui32KickTACounter;
-		IMG_UINT32 ui32KickTARenderCounter;
-		PPVRSRV_KERNEL_MEM_INFO psKernelHWPerfCBMemInfo;
-		PVRSRV_SGXDEV_DIFF_INFO sDiffInfo;
-		IMG_UINT32 ui32HWGroupRequested;
-		IMG_UINT32 ui32HWReset;
+	void *pvDeviceMemoryHeap;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelCCBMemInfo;
+	struct PVRSRV_SGX_KERNEL_CCB *psKernelCCB;
+	struct PVRSRV_SGX_CCB_INFO *psKernelCCBInfo;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelCCBCtlMemInfo;
+	struct PVRSRV_SGX_CCB_CTL *psKernelCCBCtl;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelCCBEventKickerMemInfo;
+	u32 *pui32KernelCCBEventKicker;
+	u32 ui32TAKickAddress;
+	u32 ui32TexLoadKickAddress;
+	u32 ui32VideoHandlerAddress;
+	u32 ui32KickTACounter;
+	u32 ui32KickTARenderCounter;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelHWPerfCBMemInfo;
+	struct PVRSRV_SGXDEV_DIFF_INFO sDiffInfo;
+	u32 ui32HWGroupRequested;
+	u32 ui32HWReset;
 
-		IMG_UINT32 ui32ClientRefCount;
+	u32 ui32ClientRefCount;
 
-		IMG_UINT32 ui32CacheControl;
+	u32 ui32CacheControl;
 
-		IMG_VOID *pvMMUContextList;
+	void *pvMMUContextList;
 
-		IMG_BOOL bForcePTOff;
+	IMG_BOOL bForcePTOff;
 
-		IMG_UINT32 ui32EDMTaskReg0;
-		IMG_UINT32 ui32EDMTaskReg1;
+	u32 ui32EDMTaskReg0;
+	u32 ui32EDMTaskReg1;
 
-		IMG_UINT32 ui32ClkGateCtl;
-		IMG_UINT32 ui32ClkGateCtl2;
-		IMG_UINT32 ui32ClkGateStatusMask;
-		SGX_INIT_SCRIPTS sScripts;
+	u32 ui32ClkGateCtl;
+	u32 ui32ClkGateCtl2;
+	u32 ui32ClkGateStatusMask;
+	struct SGX_INIT_SCRIPTS sScripts;
 
-		IMG_HANDLE hBIFResetPDOSMemHandle;
-		IMG_DEV_PHYADDR sBIFResetPDDevPAddr;
-		IMG_DEV_PHYADDR sBIFResetPTDevPAddr;
-		IMG_DEV_PHYADDR sBIFResetPageDevPAddr;
-		IMG_UINT32 *pui32BIFResetPD;
-		IMG_UINT32 *pui32BIFResetPT;
+	void *hBIFResetPDOSMemHandle;
+	struct IMG_DEV_PHYADDR sBIFResetPDDevPAddr;
+	struct IMG_DEV_PHYADDR sBIFResetPTDevPAddr;
+	struct IMG_DEV_PHYADDR sBIFResetPageDevPAddr;
+	u32 *pui32BIFResetPD;
+	u32 *pui32BIFResetPT;
 
+	void *hTimer;
+	u32 ui32TimeStamp;
+	u32 ui32NumResets;
 
-		IMG_HANDLE hTimer;
+	struct PVRSRV_KERNEL_MEM_INFO *psKernelSGXHostCtlMemInfo;
+	struct PVRSRV_SGX_HOST_CTL *psSGXHostCtl;
 
-		IMG_UINT32 ui32TimeStamp;
-
-		IMG_UINT32 ui32NumResets;
-
-		PVRSRV_KERNEL_MEM_INFO *psKernelSGXHostCtlMemInfo;
-		PVRSRV_SGX_HOST_CTL *psSGXHostCtl;
-
-		IMG_UINT32 ui32Flags;
+	u32 ui32Flags;
 
 #if defined(PDUMP)
-		PVRSRV_SGX_PDUMP_CONTEXT sPDContext;
+	struct PVRSRV_SGX_PDUMP_CONTEXT sPDContext;
 #endif
 
 
-		IMG_UINT32 asSGXDevData[SGX_MAX_DEV_DATA];
+	u32 asSGXDevData[SGX_MAX_DEV_DATA];
 
-	} PVRSRV_SGXDEV_INFO;
+};
 
-	typedef struct _SGX_TIMING_INFORMATION_ {
-		IMG_UINT32 ui32CoreClockSpeed;
-		IMG_UINT32 ui32HWRecoveryFreq;
-		IMG_UINT32 ui32ActivePowManLatencyms;
-		IMG_UINT32 ui32uKernelFreq;
-	} SGX_TIMING_INFORMATION;
-
-	typedef struct _SGX_DEVICE_MAP_ {
-		IMG_UINT32 ui32Flags;
-
-		IMG_SYS_PHYADDR sRegsSysPBase;
-		IMG_CPU_PHYADDR sRegsCpuPBase;
-		IMG_CPU_VIRTADDR pvRegsCpuVBase;
-		IMG_UINT32 ui32RegsSize;
-
-		IMG_SYS_PHYADDR sSPSysPBase;
-		IMG_CPU_PHYADDR sSPCpuPBase;
-		IMG_CPU_VIRTADDR pvSPCpuVBase;
-		IMG_UINT32 ui32SPSize;
-
-		IMG_SYS_PHYADDR sLocalMemSysPBase;
-		IMG_DEV_PHYADDR sLocalMemDevPBase;
-		IMG_CPU_PHYADDR sLocalMemCpuPBase;
-		IMG_UINT32 ui32LocalMemSize;
-
-		IMG_UINT32 ui32IRQ;
-
-	} SGX_DEVICE_MAP;
-
-	typedef struct _PVRSRV_STUB_PBDESC_ PVRSRV_STUB_PBDESC;
-	struct _PVRSRV_STUB_PBDESC_ {
-		IMG_UINT32 ui32RefCount;
-		IMG_UINT32 ui32TotalPBSize;
-		PVRSRV_KERNEL_MEM_INFO *psSharedPBDescKernelMemInfo;
-		PVRSRV_KERNEL_MEM_INFO *psHWPBDescKernelMemInfo;
-		PVRSRV_KERNEL_MEM_INFO **ppsSubKernelMemInfos;
-		IMG_UINT32 ui32SubKernelMemInfosCount;
-		IMG_HANDLE hDevCookie;
-		PVRSRV_KERNEL_MEM_INFO *psBlockKernelMemInfo;
-		PVRSRV_STUB_PBDESC *psNext;
-	};
-
-	typedef struct _PVRSRV_SGX_CCB_INFO_ {
-		PVRSRV_KERNEL_MEM_INFO *psCCBMemInfo;
-		PVRSRV_KERNEL_MEM_INFO *psCCBCtlMemInfo;
-		PVRSRV_SGX_COMMAND *psCommands;
-		IMG_UINT32 *pui32WriteOffset;
-		volatile IMG_UINT32 *pui32ReadOffset;
+struct SGX_TIMING_INFORMATION {
+	u32 ui32CoreClockSpeed;
+	u32 ui32HWRecoveryFreq;
+	u32 ui32ActivePowManLatencyms;
+	u32 ui32uKernelFreq;
+};
+
+struct SGX_DEVICE_MAP {
+	u32 ui32Flags;
+
+	struct IMG_SYS_PHYADDR sRegsSysPBase;
+	struct IMG_CPU_PHYADDR sRegsCpuPBase;
+	void __iomem *pvRegsCpuVBase;
+	u32 ui32RegsSize;
+
+	struct IMG_SYS_PHYADDR sSPSysPBase;
+	struct IMG_CPU_PHYADDR sSPCpuPBase;
+	void *pvSPCpuVBase;
+	u32 ui32SPSize;
+
+	struct IMG_SYS_PHYADDR sLocalMemSysPBase;
+	struct IMG_DEV_PHYADDR sLocalMemDevPBase;
+	struct IMG_CPU_PHYADDR sLocalMemCpuPBase;
+	u32 ui32LocalMemSize;
+
+	u32 ui32IRQ;
+};
+
+struct PVRSRV_STUB_PBDESC;
+struct PVRSRV_STUB_PBDESC {
+	u32 ui32RefCount;
+	u32 ui32TotalPBSize;
+	struct PVRSRV_KERNEL_MEM_INFO *psSharedPBDescKernelMemInfo;
+	struct PVRSRV_KERNEL_MEM_INFO *psHWPBDescKernelMemInfo;
+	struct PVRSRV_KERNEL_MEM_INFO **ppsSubKernelMemInfos;
+	u32 ui32SubKernelMemInfosCount;
+	void *hDevCookie;
+	struct PVRSRV_KERNEL_MEM_INFO *psBlockKernelMemInfo;
+	struct PVRSRV_STUB_PBDESC *psNext;
+};
+
+struct PVRSRV_SGX_CCB_INFO {
+	struct PVRSRV_KERNEL_MEM_INFO *psCCBMemInfo;
+	struct PVRSRV_KERNEL_MEM_INFO *psCCBCtlMemInfo;
+	struct PVRSRV_SGX_COMMAND *psCommands;
+	u32 *pui32WriteOffset;
+	volatile u32 *pui32ReadOffset;
 #if defined(PDUMP)
-		IMG_UINT32 ui32CCBDumpWOff;
+	u32 ui32CCBDumpWOff;
 #endif
-	} PVRSRV_SGX_CCB_INFO;
-
-	PVRSRV_ERROR SGXRegisterDevice(PVRSRV_DEVICE_NODE * psDeviceNode);
-
-	IMG_VOID SGXOSTimer(IMG_VOID * pvData);
+};
 
-	IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *
-					    psSGXTimingInfo);
+enum PVRSRV_ERROR SGXRegisterDevice(struct PVRSRV_DEVICE_NODE *psDeviceNode);
+void SysGetSGXTimingInformation(struct SGX_TIMING_INFORMATION *psSGXTimingInfo);
+void SGXReset(struct PVRSRV_SGXDEV_INFO *psDevInfo, u32 ui32PDUMPFlags);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgxinit.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgxinit.c
@@ -1,32 +1,33 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #include <stddef.h>
 #include <linux/spinlock.h>
 #include <linux/workqueue.h>
+#include <linux/slab.h>
 
 #include "sgxdefs.h"
 #include "sgxmmu.h"
@@ -38,6 +39,7 @@
 #include "sgxconfig.h"
 #include "sysconfig.h"
 #include "pvr_bridge_km.h"
+#include "sgx_bridge_km.h"
 
 #include "pdump_km.h"
 #include "ra.h"
@@ -47,28 +49,40 @@
 
 #include "sgxutils.h"
 
+static IMG_BOOL SGX_ISRHandler(void *pvData);
 
-IMG_BOOL SGX_ISRHandler(IMG_VOID * pvData);
+static u32 gui32EventStatusServicesByISR;
 
-IMG_UINT32 gui32EventStatusServicesByISR = 0;
-
-IMG_VOID SGXReset(PVRSRV_SGXDEV_INFO * psDevInfo, IMG_UINT32 ui32PDUMPFlags);
-
-static PVRSRV_ERROR SGXInitialise(PVRSRV_SGXDEV_INFO * psDevInfo,
+static enum PVRSRV_ERROR SGXInitialise(struct PVRSRV_SGXDEV_INFO *psDevInfo,
 				  IMG_BOOL bHardwareRecovery);
-PVRSRV_ERROR SGXDeinitialise(IMG_HANDLE hDevCookie);
+static enum PVRSRV_ERROR SGXDeinitialise(void *hDevCookie);
 
-typedef enum _PVR_DEVICE_POWER_STATE_ {
+struct timer_work_data {
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct delayed_work work;
+	struct workqueue_struct *work_queue;
+	unsigned int interval;
+	bool armed;
+};
+
+static enum PVRSRV_ERROR SGXOSTimerEnable(struct timer_work_data *data);
+static enum PVRSRV_ERROR SGXOSTimerCancel(struct timer_work_data *data);
+static struct timer_work_data *
+SGXOSTimerInit(struct PVRSRV_DEVICE_NODE *psDeviceNode);
+static void SGXOSTimerDeInit(struct timer_work_data *data);
+
+enum PVR_DEVICE_POWER_STATE {
 	PVR_DEVICE_POWER_STATE_ON = 0,
 	PVR_DEVICE_POWER_STATE_IDLE = 1,
 	PVR_DEVICE_POWER_STATE_OFF = 2,
 
 	PVR_DEVICE_POWER_STATE_FORCE_I32 = 0x7fffffff
-} PVR_DEVICE_POWER_STATE, *PPVR_DEVICE_POWER_STATE;
+};
 
-static PVR_DEVICE_POWER_STATE MapDevicePowerState(PVR_POWER_STATE ePowerState)
+static enum PVR_DEVICE_POWER_STATE MapDevicePowerState(enum PVR_POWER_STATE
+								ePowerState)
 {
-	PVR_DEVICE_POWER_STATE eDevicePowerState;
+	enum PVR_DEVICE_POWER_STATE eDevicePowerState;
 
 	switch (ePowerState) {
 	case PVRSRV_POWER_STATE_D0:
@@ -83,9 +97,9 @@
 		}
 	default:
 		{
-			PVR_DPF((PVR_DBG_ERROR,
+			PVR_DPF(PVR_DBG_ERROR,
 				 "MapDevicePowerState: Invalid state: %ld",
-				 ePowerState));
+				 ePowerState);
 			eDevicePowerState = PVR_DEVICE_POWER_STATE_FORCE_I32;
 			PVR_ASSERT(eDevicePowerState !=
 				   PVR_DEVICE_POWER_STATE_FORCE_I32);
@@ -95,71 +109,70 @@
 	return eDevicePowerState;
 }
 
-static IMG_VOID SGXCommandComplete(PVRSRV_DEVICE_NODE * psDeviceNode)
+static void SGXCommandComplete(struct PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 	SGXScheduleProcessQueues(psDeviceNode);
 }
 
-static IMG_UINT32 DeinitDevInfo(PVRSRV_SGXDEV_INFO * psDevInfo)
+static u32 DeinitDevInfo(struct PVRSRV_SGXDEV_INFO *psDevInfo)
 {
-	if (psDevInfo->psKernelCCBInfo != IMG_NULL) {
-
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_SGX_CCB_INFO),
-			  psDevInfo->psKernelCCBInfo, IMG_NULL);
-	}
+	if (psDevInfo->psKernelCCBInfo != NULL)
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+			  sizeof(struct PVRSRV_SGX_CCB_INFO),
+			  psDevInfo->psKernelCCBInfo, NULL);
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR InitDevInfo(PVRSRV_PER_PROCESS_DATA * psPerProc,
-				PVRSRV_DEVICE_NODE * psDeviceNode,
-				SGX_BRIDGE_INIT_INFO * psInitInfo)
-{
-	PVRSRV_SGXDEV_INFO *psDevInfo =
-	    (PVRSRV_SGXDEV_INFO *) psDeviceNode->pvDevice;
-	PVRSRV_ERROR eError;
+static enum PVRSRV_ERROR InitDevInfo(struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+				struct PVRSRV_DEVICE_NODE *psDeviceNode,
+				struct SGX_BRIDGE_INIT_INFO *psInitInfo)
+{
+	struct PVRSRV_SGXDEV_INFO *psDevInfo =
+	    (struct PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
+	enum PVRSRV_ERROR eError;
 
-	PVRSRV_SGX_CCB_INFO *psKernelCCBInfo = IMG_NULL;
+	struct PVRSRV_SGX_CCB_INFO *psKernelCCBInfo = NULL;
 
 	PVR_UNREFERENCED_PARAMETER(psPerProc);
 	psDevInfo->sScripts = psInitInfo->sScripts;
 
 	psDevInfo->psKernelCCBMemInfo =
-	    (PVRSRV_KERNEL_MEM_INFO *) psInitInfo->hKernelCCBMemInfo;
+	    (struct PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelCCBMemInfo;
 	psDevInfo->psKernelCCB =
-	    (PVRSRV_SGX_KERNEL_CCB *) psDevInfo->psKernelCCBMemInfo->
+	    (struct PVRSRV_SGX_KERNEL_CCB *)psDevInfo->psKernelCCBMemInfo->
 	    pvLinAddrKM;
 
 	psDevInfo->psKernelCCBCtlMemInfo =
-	    (PVRSRV_KERNEL_MEM_INFO *) psInitInfo->hKernelCCBCtlMemInfo;
+	    (struct PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelCCBCtlMemInfo;
 	psDevInfo->psKernelCCBCtl =
-	    (PVRSRV_SGX_CCB_CTL *) psDevInfo->psKernelCCBCtlMemInfo->
+	    (struct PVRSRV_SGX_CCB_CTL *)psDevInfo->psKernelCCBCtlMemInfo->
 	    pvLinAddrKM;
 
 	psDevInfo->psKernelCCBEventKickerMemInfo =
-	    (PVRSRV_KERNEL_MEM_INFO *) psInitInfo->hKernelCCBEventKickerMemInfo;
+	    (struct PVRSRV_KERNEL_MEM_INFO *)
+	    psInitInfo->hKernelCCBEventKickerMemInfo;
 	psDevInfo->pui32KernelCCBEventKicker =
-	    (IMG_UINT32 *) psDevInfo->psKernelCCBEventKickerMemInfo->
-	    pvLinAddrKM;
+	    (u32 *) psDevInfo->psKernelCCBEventKickerMemInfo->pvLinAddrKM;
 
 	psDevInfo->psKernelSGXHostCtlMemInfo =
-	    (PVRSRV_KERNEL_MEM_INFO *) psInitInfo->hKernelSGXHostCtlMemInfo;
+	  (struct PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelSGXHostCtlMemInfo;
 	psDevInfo->psSGXHostCtl =
-	    (PVRSRV_SGX_HOST_CTL *) psDevInfo->psKernelSGXHostCtlMemInfo->
+	    (struct PVRSRV_SGX_HOST_CTL *)psDevInfo->psKernelSGXHostCtlMemInfo->
 	    pvLinAddrKM;
 
 	psDevInfo->psKernelHWPerfCBMemInfo =
-	    (PVRSRV_KERNEL_MEM_INFO *) psInitInfo->hKernelHWPerfCBMemInfo;
+	    (struct PVRSRV_KERNEL_MEM_INFO *)psInitInfo->hKernelHWPerfCBMemInfo;
 
 	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-			    sizeof(PVRSRV_SGX_CCB_INFO),
-			    (IMG_VOID **) & psKernelCCBInfo, 0);
+			    sizeof(struct PVRSRV_SGX_CCB_INFO),
+			    (void **)&psKernelCCBInfo, NULL);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR, "InitDevInfo: Failed to alloc memory"));
+		PVR_DPF(PVR_DBG_ERROR, "InitDevInfo: Failed to alloc memory");
 		goto failed_allockernelccb;
 	}
 
-	OSMemSet(psKernelCCBInfo, 0, sizeof(PVRSRV_SGX_CCB_INFO));
+	OSMemSet(psKernelCCBInfo, 0, sizeof(struct PVRSRV_SGX_CCB_INFO));
 	psKernelCCBInfo->psCCBMemInfo = psDevInfo->psKernelCCBMemInfo;
 	psKernelCCBInfo->psCCBCtlMemInfo = psDevInfo->psKernelCCBCtlMemInfo;
 	psKernelCCBInfo->psCommands = psDevInfo->psKernelCCB->asCommands;
@@ -195,106 +208,85 @@
 	return eError;
 }
 
-static IMG_VOID SGXGetTimingInfo(PVRSRV_DEVICE_NODE * psDeviceNode)
+static void SGXGetTimingInfo(struct PVRSRV_DEVICE_NODE *psDeviceNode)
 {
-	PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-	SGX_TIMING_INFORMATION sSGXTimingInfo = { 0 };
-	IMG_UINT32 ui32ActivePowManSampleRate;
-	SGX_TIMING_INFORMATION *psSGXTimingInfo;
-
-	psSGXTimingInfo = &sSGXTimingInfo;
-	SysGetSGXTimingInformation(psSGXTimingInfo);
-
-	{
-		PVRSRV_ERROR eError;
-		IMG_UINT32 ui32OlduKernelFreq;
-
-		if (psDevInfo->hTimer != IMG_NULL) {
-			ui32OlduKernelFreq =
-			    psDevInfo->ui32CoreClockSpeed /
-			    psDevInfo->ui32uKernelTimerClock;
-			if (ui32OlduKernelFreq !=
-			    psSGXTimingInfo->ui32uKernelFreq) {
-				eError = OSRemoveTimer(psDevInfo->hTimer);
-				if (eError != PVRSRV_OK) {
-					PVR_DPF((PVR_DBG_ERROR,
-						 "SGXGetTimingInfo: Failed to remove timer"));
-				}
-				psDevInfo->hTimer = IMG_NULL;
-			}
-		}
-		if (psDevInfo->hTimer == IMG_NULL) {
+	struct PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+	struct SGX_TIMING_INFORMATION sSGXTimingInfo = { 0 };
+	u32 ui32ActivePowManSampleRate;
+	struct timer_work_data *data = psDevInfo->hTimer;
+	enum PVRSRV_ERROR eError;
 
-			/*
-			 * the magic calculation below sets the hardware lock-up
-			 * detection and recovery timer interval to ~150msecs
-			 */
-			psDevInfo->hTimer = OSAddTimer(SGXOSTimer, psDeviceNode,
-						       1000 * 150 /
-						       psSGXTimingInfo->
-						       ui32uKernelFreq);
-			if (psDevInfo->hTimer == IMG_NULL) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "SGXGetTimingInfo : Failed to register timer callback function"));
-			}
-		}
+	SysGetSGXTimingInformation(&sSGXTimingInfo);
 
-		psDevInfo->psSGXHostCtl->ui32HWRecoverySampleRate =
-		    psSGXTimingInfo->ui32uKernelFreq /
-		    psSGXTimingInfo->ui32HWRecoveryFreq;
+	if (data) {
+		BUG_ON(data->armed);
+		/*
+		 * The magic calculation below sets the hardware lock-up
+		 * detection and recovery timer interval to ~150msecs.
+		 * The interval length will be scaled based on the SGX
+		 * functional clock frequency. The higher the frequency
+		 * the shorter the interval and vice versa.
+		 */
+		data->interval = 150 * SYS_SGX_PDS_TIMER_FREQ /
+			sSGXTimingInfo.ui32uKernelFreq;
 	}
 
-	psDevInfo->ui32CoreClockSpeed = psSGXTimingInfo->ui32CoreClockSpeed;
+	psDevInfo->psSGXHostCtl->ui32HWRecoverySampleRate =
+		sSGXTimingInfo.ui32uKernelFreq /
+		sSGXTimingInfo.ui32HWRecoveryFreq;
+
+	psDevInfo->ui32CoreClockSpeed = sSGXTimingInfo.ui32CoreClockSpeed;
 	psDevInfo->ui32uKernelTimerClock =
-	    psSGXTimingInfo->ui32CoreClockSpeed /
-	    psSGXTimingInfo->ui32uKernelFreq;
+		sSGXTimingInfo.ui32CoreClockSpeed /
+		sSGXTimingInfo.ui32uKernelFreq;
 
 	ui32ActivePowManSampleRate =
-	    psSGXTimingInfo->ui32uKernelFreq *
-	    psSGXTimingInfo->ui32ActivePowManLatencyms / 1000;
+		sSGXTimingInfo.ui32uKernelFreq *
+		sSGXTimingInfo.ui32ActivePowManLatencyms / 1000;
 	ui32ActivePowManSampleRate += 1;
 	psDevInfo->psSGXHostCtl->ui32ActivePowManSampleRate =
 	    ui32ActivePowManSampleRate;
 }
 
-static IMG_VOID SGXStartTimer(PVRSRV_SGXDEV_INFO * psDevInfo,
+static void SGXStartTimer(struct PVRSRV_SGXDEV_INFO *psDevInfo,
 			      IMG_BOOL bStartOSTimer)
 {
-	IMG_UINT32 ui32RegVal;
+	u32 ui32RegVal;
 
 
 	ui32RegVal =
 	    EUR_CR_EVENT_TIMER_ENABLE_MASK | psDevInfo->ui32uKernelTimerClock;
-	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_TIMER, ui32RegVal);
+	OSWriteHWReg((void __iomem *)psDevInfo->pvRegsBaseKM,
+		     EUR_CR_EVENT_TIMER, ui32RegVal);
 	PDUMPREGWITHFLAGS(EUR_CR_EVENT_TIMER, ui32RegVal,
 			  PDUMP_FLAGS_CONTINUOUS);
 
 	if (bStartOSTimer) {
-		PVRSRV_ERROR eError;
-		eError = OSEnableTimer(psDevInfo->hTimer);
-		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "SGXStartTimer : Failed to enable host timer"));
-		}
+		enum PVRSRV_ERROR eError;
+		eError = SGXOSTimerEnable(psDevInfo->hTimer);
+		if (eError != PVRSRV_OK)
+			PVR_DPF(PVR_DBG_ERROR, "SGXStartTimer : "
+					"Failed to enable host timer");
 	}
 }
 
-static PVRSRV_ERROR SGXPrePowerState(IMG_HANDLE hDevHandle,
-				     PVR_DEVICE_POWER_STATE eNewPowerState,
-				     PVR_DEVICE_POWER_STATE eCurrentPowerState)
+static enum PVRSRV_ERROR SGXPrePowerState(void *hDevHandle,
+			 enum PVR_DEVICE_POWER_STATE eNewPowerState,
+			 enum PVR_DEVICE_POWER_STATE eCurrentPowerState)
 {
 	if ((eNewPowerState != eCurrentPowerState) &&
 	    (eNewPowerState != PVR_DEVICE_POWER_STATE_ON)) {
-		PVRSRV_ERROR eError;
-		PVRSRV_DEVICE_NODE *psDeviceNode = hDevHandle;
-		PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-		PVRSRV_SGX_HOST_CTL *psSGXHostCtl = psDevInfo->psSGXHostCtl;
-		IMG_UINT32 ui32PowManRequest, ui32PowManComplete;
+		enum PVRSRV_ERROR eError;
+		struct PVRSRV_DEVICE_NODE *psDeviceNode = hDevHandle;
+		struct PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+		struct PVRSRV_SGX_HOST_CTL *psSGXHostCtl =
+							psDevInfo->psSGXHostCtl;
+		u32 ui32PowManRequest, ui32PowManComplete;
 
-		eError = OSDisableTimer(psDevInfo->hTimer);
+		eError = SGXOSTimerCancel(psDevInfo->hTimer);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "SGXPrePowerState: Failed to disable timer"));
+			PVR_DPF(PVR_DBG_ERROR,
+				 "SGXPrePowerState: Failed to disable timer");
 			return eError;
 		}
 
@@ -314,9 +306,9 @@
 
 		psSGXHostCtl->ui32PowManFlags |= ui32PowManRequest;
 #if defined(PDUMP)
-		PDUMPMEM(IMG_NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
-			 offsetof(PVRSRV_SGX_HOST_CTL, ui32PowManFlags),
-			 sizeof(IMG_UINT32), PDUMP_FLAGS_CONTINUOUS,
+		PDUMPMEM(NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
+			 offsetof(struct PVRSRV_SGX_HOST_CTL, ui32PowManFlags),
+			 sizeof(u32), PDUMP_FLAGS_CONTINUOUS,
 			 MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
 #endif
 
@@ -324,33 +316,30 @@
 				   ui32PowManComplete,
 				   ui32PowManComplete,
 				   MAX_HW_TIME_US / WAIT_TRY_COUNT,
-				   WAIT_TRY_COUNT) != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "SGXPrePowerState: Wait for SGX ukernel power transition failed."));
-		}
+				   WAIT_TRY_COUNT) != PVRSRV_OK)
+			PVR_DPF(PVR_DBG_ERROR, "SGXPrePowerState: "
+			      "Wait for SGX ukernel power transition failed.");
 
 #if defined(PDUMP)
 		PDUMPCOMMENT
 		    ("TA/3D CCB Control - Wait for power event on uKernel.");
 		PDUMPMEMPOL(psDevInfo->psKernelSGXHostCtlMemInfo,
-			    offsetof(PVRSRV_SGX_HOST_CTL, ui32PowManFlags),
+			    offsetof(struct PVRSRV_SGX_HOST_CTL,
+				     ui32PowManFlags),
 			    ui32PowManComplete, ui32PowManComplete,
 			    PDUMP_POLL_OPERATOR_EQUAL, IMG_FALSE, IMG_FALSE,
 			    MAKEUNIQUETAG(psDevInfo->
 					  psKernelSGXHostCtlMemInfo));
 #endif
-
-
 		{
-			if (PollForValueKM
-			    ((IMG_UINT32 *) psDevInfo->pvRegsBaseKM +
-			     (EUR_CR_CLKGATESTATUS >> 2), 0,
+			if (PollForValueKM(
+					(u32 __force *)psDevInfo->pvRegsBaseKM +
+					(EUR_CR_CLKGATESTATUS >> 2), 0,
 			     psDevInfo->ui32ClkGateStatusMask,
 			     MAX_HW_TIME_US / WAIT_TRY_COUNT,
-			     WAIT_TRY_COUNT) != PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "SGXPrePowerState: Wait for SGX clock gating failed."));
-			}
+			     WAIT_TRY_COUNT) != PVRSRV_OK)
+				PVR_DPF(PVR_DBG_ERROR, "SGXPrePowerState: "
+					 "Wait for SGX clock gating failed.");
 
 			PDUMPCOMMENT("Wait for SGX clock gating.");
 			PDUMPREGPOL(EUR_CR_CLKGATESTATUS, 0,
@@ -360,9 +349,8 @@
 		if (eNewPowerState == PVR_DEVICE_POWER_STATE_OFF) {
 			eError = SGXDeinitialise(psDevInfo);
 			if (eError != PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "SGXPrePowerState: SGXDeinitialise failed: %lu",
-					 eError));
+				PVR_DPF(PVR_DBG_ERROR, "SGXPrePowerState: "
+					"SGXDeinitialise failed: %lu", eError);
 				return eError;
 			}
 		}
@@ -371,23 +359,24 @@
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR SGXPostPowerState(IMG_HANDLE hDevHandle,
-				      PVR_DEVICE_POWER_STATE eNewPowerState,
-				      PVR_DEVICE_POWER_STATE eCurrentPowerState)
+static enum PVRSRV_ERROR SGXPostPowerState(void *hDevHandle,
+				 enum PVR_DEVICE_POWER_STATE eNewPowerState,
+				 enum PVR_DEVICE_POWER_STATE eCurrentPowerState)
 {
 	if ((eNewPowerState != eCurrentPowerState) &&
 	    (eCurrentPowerState != PVR_DEVICE_POWER_STATE_ON)) {
-		PVRSRV_ERROR eError;
-		PVRSRV_DEVICE_NODE *psDeviceNode = hDevHandle;
-		PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-		PVRSRV_SGX_HOST_CTL *psSGXHostCtl = psDevInfo->psSGXHostCtl;
+		enum PVRSRV_ERROR eError;
+		struct PVRSRV_DEVICE_NODE *psDeviceNode = hDevHandle;
+		struct PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+		struct PVRSRV_SGX_HOST_CTL *psSGXHostCtl =
+							psDevInfo->psSGXHostCtl;
 
 		psSGXHostCtl->ui32PowManFlags = 0;
 		PDUMPCOMMENT("TA/3D CCB Control - Reset Power Manager flags");
 #if defined(PDUMP)
-		PDUMPMEM(IMG_NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
-			 offsetof(PVRSRV_SGX_HOST_CTL, ui32PowManFlags),
-			 sizeof(IMG_UINT32), PDUMP_FLAGS_CONTINUOUS,
+		PDUMPMEM(NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
+			 offsetof(struct PVRSRV_SGX_HOST_CTL, ui32PowManFlags),
+			 sizeof(u32), PDUMP_FLAGS_CONTINUOUS,
 			 MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
 #endif
 
@@ -397,8 +386,8 @@
 
 			eError = SGXInitialise(psDevInfo, IMG_FALSE);
 			if (eError != PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "SGXPostPowerState: SGXInitialise failed"));
+				PVR_DPF(PVR_DBG_ERROR, "SGXPostPowerState: "
+					"SGXInitialise failed");
 				return eError;
 			}
 		}
@@ -407,82 +396,78 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR SGXPrePowerStateExt(IMG_HANDLE hDevHandle,
-				 PVR_POWER_STATE eNewPowerState,
-				 PVR_POWER_STATE eCurrentPowerState)
+static enum PVRSRV_ERROR SGXPrePowerStateExt(void *hDevHandle,
+					enum PVR_POWER_STATE eNewPowerState,
+					enum PVR_POWER_STATE eCurrentPowerState)
 {
-	PVR_DEVICE_POWER_STATE eNewDevicePowerState =
+	enum PVR_DEVICE_POWER_STATE eNewDevicePowerState =
 	    MapDevicePowerState(eNewPowerState);
-	PVR_DEVICE_POWER_STATE eCurrentDevicePowerState =
+	enum PVR_DEVICE_POWER_STATE eCurrentDevicePowerState =
 	    MapDevicePowerState(eCurrentPowerState);
 
 	return SGXPrePowerState(hDevHandle, eNewDevicePowerState,
 				eCurrentDevicePowerState);
 }
 
-PVRSRV_ERROR SGXPostPowerStateExt(IMG_HANDLE hDevHandle,
-				  PVR_POWER_STATE eNewPowerState,
-				  PVR_POWER_STATE eCurrentPowerState)
+static enum PVRSRV_ERROR SGXPostPowerStateExt(void *hDevHandle,
+				  enum PVR_POWER_STATE eNewPowerState,
+				  enum PVR_POWER_STATE eCurrentPowerState)
 {
-	PVRSRV_ERROR eError;
-	PVR_DEVICE_POWER_STATE eNewDevicePowerState =
+	enum PVRSRV_ERROR eError;
+	enum PVR_DEVICE_POWER_STATE eNewDevicePowerState =
 	    MapDevicePowerState(eNewPowerState);
-	PVR_DEVICE_POWER_STATE eCurrentDevicePowerState =
+	enum PVR_DEVICE_POWER_STATE eCurrentDevicePowerState =
 	    MapDevicePowerState(eCurrentPowerState);
 
 	eError =
 	    SGXPostPowerState(hDevHandle, eNewDevicePowerState,
 			      eCurrentDevicePowerState);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
-	PVR_DPF((PVR_DBG_WARNING,
+	PVR_DPF(PVR_DBG_WARNING,
 		 "SGXPostPowerState : SGX Power Transition from %d to %d OK",
-		 eCurrentPowerState, eNewPowerState));
+		 eCurrentPowerState, eNewPowerState);
 
 	return eError;
 }
 
-static PVRSRV_ERROR SGXPreClockSpeedChange(IMG_HANDLE hDevHandle,
-					   IMG_BOOL bIdleDevice,
-					   PVR_POWER_STATE eCurrentPowerState)
-{
-	PVRSRV_ERROR eError;
-	PVRSRV_DEVICE_NODE *psDeviceNode = hDevHandle;
-	PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+static enum PVRSRV_ERROR SGXPreClockSpeedChange(void *hDevHandle,
+					IMG_BOOL bIdleDevice,
+					enum PVR_POWER_STATE eCurrentPowerState)
+{
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode = hDevHandle;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 
 	PVR_UNREFERENCED_PARAMETER(psDevInfo);
 
-	if (eCurrentPowerState == PVRSRV_POWER_STATE_D0) {
+	if (eCurrentPowerState == PVRSRV_POWER_STATE_D0)
 		if (bIdleDevice) {
-
 			eError =
 			    SGXPrePowerState(hDevHandle,
 					     PVR_DEVICE_POWER_STATE_IDLE,
 					     PVR_DEVICE_POWER_STATE_ON);
 
-			if (eError != PVRSRV_OK) {
+			if (eError != PVRSRV_OK)
 				return eError;
-			}
 		}
-	}
 
-	PVR_DPF((PVR_DBG_MESSAGE,
+	PVR_DPF(PVR_DBG_MESSAGE,
 		 "SGXPreClockSpeedChange: SGX clock speed was %luHz",
-		 psDevInfo->ui32CoreClockSpeed));
+		 psDevInfo->ui32CoreClockSpeed);
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR SGXPostClockSpeedChange(IMG_HANDLE hDevHandle,
-					    IMG_BOOL bIdleDevice,
-					    PVR_POWER_STATE eCurrentPowerState)
-{
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	PVRSRV_DEVICE_NODE *psDeviceNode = hDevHandle;
-	PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-	IMG_UINT32 ui32OldClockSpeed = psDevInfo->ui32CoreClockSpeed;
+static enum PVRSRV_ERROR SGXPostClockSpeedChange(void *hDevHandle,
+				    IMG_BOOL bIdleDevice,
+				    enum PVR_POWER_STATE eCurrentPowerState)
+{
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode = hDevHandle;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+	u32 ui32OldClockSpeed = psDevInfo->ui32CoreClockSpeed;
 
 	PVR_UNREFERENCED_PARAMETER(ui32OldClockSpeed);
 
@@ -494,33 +479,33 @@
 					      PVR_DEVICE_POWER_STATE_ON,
 					      PVR_DEVICE_POWER_STATE_IDLE);
 
-			if (eError != PVRSRV_OK) {
+			if (eError != PVRSRV_OK)
 				return eError;
-			}
 		}
 		SGXStartTimer(psDevInfo, IMG_TRUE);
 	}
 
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "SGXPostClockSpeedChange: SGX clock speed changed from %luHz to %luHz",
-		 ui32OldClockSpeed, psDevInfo->ui32CoreClockSpeed));
+	PVR_DPF(PVR_DBG_MESSAGE, "SGXPostClockSpeedChange: "
+		 "SGX clock speed changed from %luHz to %luHz",
+		 ui32OldClockSpeed, psDevInfo->ui32CoreClockSpeed);
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR SGXRunScript(PVRSRV_SGXDEV_INFO * psDevInfo,
-				 SGX_INIT_COMMAND * psScript,
-				 IMG_UINT32 ui32NumInitCommands)
+static enum PVRSRV_ERROR SGXRunScript(struct PVRSRV_SGXDEV_INFO *psDevInfo,
+				 union SGX_INIT_COMMAND *psScript,
+				 u32 ui32NumInitCommands)
 {
-	IMG_UINT32 ui32PC;
-	SGX_INIT_COMMAND *psComm;
+	u32 ui32PC;
+	union SGX_INIT_COMMAND *psComm;
 
 	for (ui32PC = 0, psComm = psScript;
 	     ui32PC < ui32NumInitCommands; ui32PC++, psComm++) {
 		switch (psComm->eOp) {
 		case SGX_INIT_OP_WRITE_HW_REG:
 			{
-				OSWriteHWReg(psDevInfo->pvRegsBaseKM,
+				OSWriteHWReg((void __iomem *)
+							psDevInfo->pvRegsBaseKM,
 					     psComm->sWriteHWReg.ui32Offset,
 					     psComm->sWriteHWReg.ui32Value);
 				PDUMPREG(psComm->sWriteHWReg.ui32Offset,
@@ -543,9 +528,9 @@
 
 		default:
 			{
-				PVR_DPF((PVR_DBG_ERROR,
-					 "SGXRunScript: PC %d: Illegal command: %d",
-					 ui32PC, psComm->eOp));
+				PVR_DPF(PVR_DBG_ERROR,
+				     "SGXRunScript: PC %d: Illegal command: %d",
+				      ui32PC, psComm->eOp);
 				return PVRSRV_ERROR_GENERIC;
 			}
 		}
@@ -555,11 +540,11 @@
 	return PVRSRV_ERROR_GENERIC;;
 }
 
-static PVRSRV_ERROR SGXInitialise(PVRSRV_SGXDEV_INFO * psDevInfo,
+static enum PVRSRV_ERROR SGXInitialise(struct PVRSRV_SGXDEV_INFO *psDevInfo,
 				  IMG_BOOL bHardwareRecovery)
 {
-	PVRSRV_ERROR eError;
-	IMG_UINT32 ui32ReadOffset, ui32WriteOffset;
+	enum PVRSRV_ERROR eError;
+	u32 ui32ReadOffset, ui32WriteOffset;
 
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_CLKGATECTL,
 		     psDevInfo->ui32ClkGateCtl);
@@ -572,7 +557,7 @@
 
 	*psDevInfo->pui32KernelCCBEventKicker = 0;
 #if defined(PDUMP)
-	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBEventKickerMemInfo, 0,
+	PDUMPMEM(NULL, psDevInfo->psKernelCCBEventKickerMemInfo, 0,
 		 sizeof(*psDevInfo->pui32KernelCCBEventKicker),
 		 PDUMP_FLAGS_CONTINUOUS,
 		 MAKEUNIQUETAG(psDevInfo->psKernelCCBEventKickerMemInfo));
@@ -582,13 +567,13 @@
 	psDevInfo->psSGXHostCtl->s3DHWPBDesc.uiAddr = 0;
 #if defined(PDUMP)
 	PDUMPCOMMENT(" CCB Control - Reset HW PBDesc records");
-	PDUMPMEM(IMG_NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
-		 offsetof(PVRSRV_SGX_HOST_CTL, sTAHWPBDesc),
-		 sizeof(IMG_DEV_VIRTADDR), PDUMP_FLAGS_CONTINUOUS,
+	PDUMPMEM(NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
+		 offsetof(struct PVRSRV_SGX_HOST_CTL, sTAHWPBDesc),
+		 sizeof(struct IMG_DEV_VIRTADDR), PDUMP_FLAGS_CONTINUOUS,
 		 MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
-	PDUMPMEM(IMG_NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
-		 offsetof(PVRSRV_SGX_HOST_CTL, s3DHWPBDesc),
-		 sizeof(IMG_DEV_VIRTADDR), PDUMP_FLAGS_CONTINUOUS,
+	PDUMPMEM(NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
+		 offsetof(struct PVRSRV_SGX_HOST_CTL, s3DHWPBDesc),
+		 sizeof(struct IMG_DEV_VIRTADDR), PDUMP_FLAGS_CONTINUOUS,
 		 MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
 #endif
 
@@ -596,24 +581,23 @@
 	    SGXRunScript(psDevInfo, psDevInfo->sScripts.asInitCommands,
 			 SGX_MAX_INIT_COMMANDS);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SGXInitialise: SGXRunScript failed (%d)", eError));
-		return (PVRSRV_ERROR_GENERIC);
+		PVR_DPF(PVR_DBG_ERROR,
+			 "SGXInitialise: SGXRunScript failed (%d)", eError);
+		return PVRSRV_ERROR_GENERIC;
 	}
 
 	SGXStartTimer(psDevInfo, !bHardwareRecovery);
 
 	if (bHardwareRecovery) {
-		PVRSRV_SGX_HOST_CTL *psSGXHostCtl =
-		    (PVRSRV_SGX_HOST_CTL *) psDevInfo->psSGXHostCtl;
+		struct PVRSRV_SGX_HOST_CTL *psSGXHostCtl =
+		    (struct PVRSRV_SGX_HOST_CTL *)psDevInfo->psSGXHostCtl;
 
-		if (PollForValueKM
-		    ((volatile IMG_UINT32 *)(&psSGXHostCtl->
-					     ui32InterruptClearFlags), 0,
+		if (PollForValueKM((volatile u32 *)
+		     (&psSGXHostCtl->ui32InterruptClearFlags), 0,
 		     PVRSRV_USSE_EDM_INTERRUPT_HWR,
 		     MAX_HW_TIME_US / WAIT_TRY_COUNT, 1000) != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "SGXInitialise: Wait for uKernel HW Recovery failed"));
+			PVR_DPF(PVR_DBG_ERROR, "SGXInitialise: "
+					"Wait for uKernel HW Recovery failed");
 			return PVRSRV_ERROR_RETRY;
 		}
 	}
@@ -631,38 +615,38 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR SGXDeinitialise(IMG_HANDLE hDevCookie)
+static enum PVRSRV_ERROR SGXDeinitialise(void *hDevCookie)
 {
-	PVRSRV_SGXDEV_INFO *psDevInfo = (PVRSRV_SGXDEV_INFO *) hDevCookie;
-	PVRSRV_ERROR eError;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo = (struct PVRSRV_SGXDEV_INFO *)
+								   hDevCookie;
+	enum PVRSRV_ERROR eError;
 
-	if (psDevInfo->pvRegsBaseKM == IMG_NULL) {
+	if (psDevInfo->pvRegsBaseKM == NULL)
 		return PVRSRV_OK;
-	}
 
-	eError =
-	    SGXRunScript(psDevInfo, psDevInfo->sScripts.asDeinitCommands,
+	eError = SGXRunScript(psDevInfo, psDevInfo->sScripts.asDeinitCommands,
 			 SGX_MAX_DEINIT_COMMANDS);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SGXDeinitialise: SGXRunScript failed (%d)", eError));
-		return (PVRSRV_ERROR_GENERIC);
+		PVR_DPF(PVR_DBG_ERROR,
+			 "SGXDeinitialise: SGXRunScript failed (%d)", eError);
+		return PVRSRV_ERROR_GENERIC;
 	}
 
 	return PVRSRV_OK;
 }
 
-static PVRSRV_ERROR DevInitSGXPart1(IMG_VOID * pvDeviceNode)
+static enum PVRSRV_ERROR DevInitSGXPart1(void *pvDeviceNode)
 {
-	PVRSRV_SGXDEV_INFO *psDevInfo;
-	IMG_HANDLE hKernelDevMemContext;
-	IMG_DEV_PHYADDR sPDDevPAddr;
-	IMG_UINT32 i;
-	PVRSRV_DEVICE_NODE *psDeviceNode = (PVRSRV_DEVICE_NODE *) pvDeviceNode;
-	DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap =
+	struct PVRSRV_SGXDEV_INFO *psDevInfo;
+	void *hKernelDevMemContext;
+	struct IMG_DEV_PHYADDR sPDDevPAddr;
+	u32 i;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode = (struct PVRSRV_DEVICE_NODE *)
+								   pvDeviceNode;
+	struct DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap =
 	    psDeviceNode->sDevMemoryInfo.psDeviceMemoryHeap;
-	IMG_HANDLE hDevInfoOSMemHandle = (IMG_HANDLE) IMG_NULL;
-	PVRSRV_ERROR eError;
+	void *hDevInfoOSMemHandle = (void *) NULL;
+	enum PVRSRV_ERROR eError;
 
 	PDUMPCOMMENT("SGX Initialisation Part 1");
 
@@ -676,30 +660,29 @@
 
 	if (OSAllocPages
 	    (PVRSRV_OS_PAGEABLE_HEAP | PVRSRV_HAP_MULTI_PROCESS |
-	     PVRSRV_HAP_CACHED, sizeof(PVRSRV_SGXDEV_INFO),
-	     (IMG_VOID **) & psDevInfo, &hDevInfoOSMemHandle) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "DevInitSGXPart1 : Failed to alloc memory for DevInfo"));
-		return (PVRSRV_ERROR_OUT_OF_MEMORY);
+	     PVRSRV_HAP_CACHED, sizeof(struct PVRSRV_SGXDEV_INFO),
+	     (void **) &psDevInfo, &hDevInfoOSMemHandle) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR, "DevInitSGXPart1 : "
+			"Failed to alloc memory for DevInfo");
+		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
-	OSMemSet(psDevInfo, 0, sizeof(PVRSRV_SGXDEV_INFO));
+	OSMemSet(psDevInfo, 0, sizeof(struct PVRSRV_SGXDEV_INFO));
 
 	psDevInfo->eDeviceType = DEV_DEVICE_TYPE;
 	psDevInfo->eDeviceClass = DEV_DEVICE_CLASS;
 
-	psDeviceNode->pvDevice = (IMG_PVOID) psDevInfo;
+	psDeviceNode->pvDevice = (void *) psDevInfo;
 	psDeviceNode->hDeviceOSMemHandle = hDevInfoOSMemHandle;
 
-	psDevInfo->pvDeviceMemoryHeap = (IMG_VOID *) psDeviceMemoryHeap;
+	psDevInfo->pvDeviceMemoryHeap = (void *) psDeviceMemoryHeap;
 
-	hKernelDevMemContext = BM_CreateContext(psDeviceNode,
-						&sPDDevPAddr,
-						IMG_NULL, IMG_NULL);
+	hKernelDevMemContext = BM_CreateContext(psDeviceNode, &sPDDevPAddr,
+						NULL, NULL);
 
 	psDevInfo->sKernelPDDevPAddr = sPDDevPAddr;
 
 	for (i = 0; i < psDeviceNode->sDevMemoryInfo.ui32HeapCount; i++) {
-		IMG_HANDLE hDevMemHeap;
+		void *hDevMemHeap;
 
 		switch (psDeviceMemoryHeap[i].DevMemHeapType) {
 		case DEVICE_MEMORY_HEAP_KERNEL:
@@ -718,71 +701,68 @@
 
 	eError = MMU_BIFResetPDAlloc(psDevInfo);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "DevInitSGX : Failed to alloc memory for BIF reset"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "DevInitSGX : Failed to alloc memory for BIF reset");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR SGXGetInfoForSrvinitKM(IMG_HANDLE hDevHandle,
-					SGX_BRIDGE_INFO_FOR_SRVINIT *
-					psInitInfo)
-{
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	PVRSRV_SGXDEV_INFO *psDevInfo;
-	PVRSRV_ERROR eError;
+enum PVRSRV_ERROR SGXGetInfoForSrvinitKM(void *hDevHandle,
+				struct SGX_BRIDGE_INFO_FOR_SRVINIT *psInitInfo)
+{
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo;
+	enum PVRSRV_ERROR eError;
 
 	PDUMPCOMMENT("SGXGetInfoForSrvinit");
 
-	psDeviceNode = (PVRSRV_DEVICE_NODE *) hDevHandle;
-	psDevInfo = (PVRSRV_SGXDEV_INFO *) psDeviceNode->pvDevice;
+	psDeviceNode = (struct PVRSRV_DEVICE_NODE *)hDevHandle;
+	psDevInfo = (struct PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
 
 	psInitInfo->sPDDevPAddr = psDevInfo->sKernelPDDevPAddr;
 
 	eError =
 	    PVRSRVGetDeviceMemHeapsKM(hDevHandle, &psInitInfo->asHeapInfo[0]);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SGXGetInfoForSrvinit: PVRSRVGetDeviceMemHeapsKM failed (%d)",
-			 eError));
+		PVR_DPF(PVR_DBG_ERROR, "SGXGetInfoForSrvinit: "
+				"PVRSRVGetDeviceMemHeapsKM failed (%d)",
+			 eError);
 		return PVRSRV_ERROR_GENERIC;
 	}
 
 	return eError;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR DevInitSGXPart2KM(PVRSRV_PER_PROCESS_DATA * psPerProc,
-				   IMG_HANDLE hDevHandle,
-				   SGX_BRIDGE_INIT_INFO * psInitInfo)
-{
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	PVRSRV_SGXDEV_INFO *psDevInfo;
-	PVRSRV_ERROR eError;
-	SGX_DEVICE_MAP *psSGXDeviceMap;
-	PVR_POWER_STATE eDefaultPowerState;
+enum PVRSRV_ERROR DevInitSGXPart2KM(struct PVRSRV_PER_PROCESS_DATA *psPerProc,
+				   void *hDevHandle,
+				   struct SGX_BRIDGE_INIT_INFO *psInitInfo)
+{
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo;
+	enum PVRSRV_ERROR eError;
+	struct SGX_DEVICE_MAP *psSGXDeviceMap;
+	enum PVR_POWER_STATE eDefaultPowerState;
 
 	PDUMPCOMMENT("SGX Initialisation Part 2");
 
-	psDeviceNode = (PVRSRV_DEVICE_NODE *) hDevHandle;
-	psDevInfo = (PVRSRV_SGXDEV_INFO *) psDeviceNode->pvDevice;
+	psDeviceNode = (struct PVRSRV_DEVICE_NODE *)hDevHandle;
+	psDevInfo = (struct PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
 
 	eError = InitDevInfo(psPerProc, psDeviceNode, psInitInfo);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "DevInitSGXPart2KM: Failed to load EDM program"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "DevInitSGXPart2KM: Failed to load EDM program");
 		goto failed_init_dev_info;
 	}
 
 
 	eError = SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE_SGX,
-				       (IMG_VOID **) & psSGXDeviceMap);
+				       (void **) &psSGXDeviceMap);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "DevInitSGXPart2KM: Failed to get device memory map!"));
+		PVR_DPF(PVR_DBG_ERROR, "DevInitSGXPart2KM: "
+					"Failed to get device memory map!");
 		return PVRSRV_ERROR_INIT_FAILURE;
 	}
 
@@ -794,10 +774,10 @@
 		    OSMapPhysToLin(psSGXDeviceMap->sRegsCpuPBase,
 				   psSGXDeviceMap->ui32RegsSize,
 				   PVRSRV_HAP_KERNEL_ONLY | PVRSRV_HAP_UNCACHED,
-				   IMG_NULL);
+				   NULL);
 		if (!psDevInfo->pvRegsBaseKM) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "DevInitSGXPart2KM: Failed to map in regs\n"));
+			PVR_DPF(PVR_DBG_ERROR,
+				 "DevInitSGXPart2KM: Failed to map in regs\n");
 			return PVRSRV_ERROR_BAD_MAPPING;
 		}
 	}
@@ -820,63 +800,66 @@
 					   SGXPostPowerStateExt,
 					   SGXPreClockSpeedChange,
 					   SGXPostClockSpeedChange,
-					   (IMG_HANDLE) psDeviceNode,
+					   (void *) psDeviceNode,
 					   PVRSRV_POWER_STATE_D3,
 					   eDefaultPowerState);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "DevInitSGXPart2KM: failed to register device with power manager"));
+		PVR_DPF(PVR_DBG_ERROR, "DevInitSGXPart2KM: "
+			 "failed to register device with power manager");
 		return eError;
 	}
 
-	OSMemSet(psDevInfo->psKernelCCB, 0, sizeof(PVRSRV_SGX_KERNEL_CCB));
-	OSMemSet(psDevInfo->psKernelCCBCtl, 0, sizeof(PVRSRV_SGX_CCB_CTL));
+	OSMemSet(psDevInfo->psKernelCCB, 0,
+		 sizeof(struct PVRSRV_SGX_KERNEL_CCB));
+	OSMemSet(psDevInfo->psKernelCCBCtl, 0,
+		 sizeof(struct PVRSRV_SGX_CCB_CTL));
 	OSMemSet(psDevInfo->pui32KernelCCBEventKicker, 0,
 		 sizeof(*psDevInfo->pui32KernelCCBEventKicker));
 	PDUMPCOMMENT("Kernel CCB");
-	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBMemInfo, 0,
-		 sizeof(PVRSRV_SGX_KERNEL_CCB), PDUMP_FLAGS_CONTINUOUS,
+	PDUMPMEM(NULL, psDevInfo->psKernelCCBMemInfo, 0,
+		 sizeof(struct PVRSRV_SGX_KERNEL_CCB), PDUMP_FLAGS_CONTINUOUS,
 		 MAKEUNIQUETAG(psDevInfo->psKernelCCBMemInfo));
 	PDUMPCOMMENT("Kernel CCB Control");
-	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBCtlMemInfo, 0,
-		 sizeof(PVRSRV_SGX_CCB_CTL), PDUMP_FLAGS_CONTINUOUS,
+	PDUMPMEM(NULL, psDevInfo->psKernelCCBCtlMemInfo, 0,
+		 sizeof(struct PVRSRV_SGX_CCB_CTL), PDUMP_FLAGS_CONTINUOUS,
 		 MAKEUNIQUETAG(psDevInfo->psKernelCCBCtlMemInfo));
 	PDUMPCOMMENT("Kernel CCB Event Kicker");
-	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBEventKickerMemInfo, 0,
+	PDUMPMEM(NULL, psDevInfo->psKernelCCBEventKickerMemInfo, 0,
 		 sizeof(*psDevInfo->pui32KernelCCBEventKicker),
 		 PDUMP_FLAGS_CONTINUOUS,
 		 MAKEUNIQUETAG(psDevInfo->psKernelCCBEventKickerMemInfo));
 
+	psDevInfo->hTimer = SGXOSTimerInit(psDeviceNode);
+	if (!psDevInfo->hTimer)
+		PVR_DPF(PVR_DBG_ERROR, "DevInitSGXPart2KM : "
+			"Failed to initialize HW recovery timer");
+
 	return PVRSRV_OK;
 
 failed_init_dev_info:
 	return eError;
 }
 
-static PVRSRV_ERROR DevDeInitSGX(IMG_VOID * pvDeviceNode)
+static enum PVRSRV_ERROR DevDeInitSGX(void *pvDeviceNode)
 {
-	PVRSRV_DEVICE_NODE *psDeviceNode = (PVRSRV_DEVICE_NODE *) pvDeviceNode;
-	PVRSRV_SGXDEV_INFO *psDevInfo =
-	    (PVRSRV_SGXDEV_INFO *) psDeviceNode->pvDevice;
-	IMG_HANDLE hDevInfoOSMemHandle = psDeviceNode->hDeviceOSMemHandle;
-	PVRSRV_ERROR eError = PVRSRV_ERROR_INVALID_PARAMS;
-	IMG_UINT32 ui32Heap;
-	DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
-	SGX_DEVICE_MAP *psSGXDeviceMap;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode =
+		(struct PVRSRV_DEVICE_NODE *)pvDeviceNode;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo =
+		(struct PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
+	void *hDevInfoOSMemHandle = psDeviceNode->hDeviceOSMemHandle;
+	enum PVRSRV_ERROR eError = PVRSRV_ERROR_INVALID_PARAMS;
+	u32 ui32Heap;
+	struct DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
+	struct SGX_DEVICE_MAP *psSGXDeviceMap;
 
 	if (!psDevInfo) {
-
-		PVR_DPF((PVR_DBG_ERROR, "DevDeInitSGX: Null DevInfo"));
+		PVR_DPF(PVR_DBG_ERROR, "DevDeInitSGX: Null DevInfo");
 		return PVRSRV_OK;
 	}
 	if (psDevInfo->hTimer) {
-		eError = OSRemoveTimer(psDevInfo->hTimer);
-		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "DevDeInitSGX: Failed to remove timer"));
-			return eError;
-		}
-		psDevInfo->hTimer = IMG_NULL;
+		SGXOSTimerCancel(psDevInfo->hTimer);
+		SGXOSTimerDeInit(psDevInfo->hTimer);
+		psDevInfo->hTimer = NULL;
 	}
 
 	MMU_BIFResetPDFree(psDevInfo);
@@ -885,7 +868,7 @@
 
 
 	psDeviceMemoryHeap =
-	    (DEVICE_MEMORY_HEAP_INFO *) psDevInfo->pvDeviceMemoryHeap;
+	    (struct DEVICE_MEMORY_HEAP_INFO *)psDevInfo->pvDeviceMemoryHeap;
 	for (ui32Heap = 0;
 	     ui32Heap < psDeviceNode->sDevMemoryInfo.ui32HeapCount;
 	     ui32Heap++) {
@@ -895,82 +878,74 @@
 		case DEVICE_MEMORY_HEAP_SHARED_EXPORTED:
 			{
 				if (psDeviceMemoryHeap[ui32Heap].hDevMemHeap !=
-				    IMG_NULL) {
+				    NULL)
 					BM_DestroyHeap(psDeviceMemoryHeap
 						       [ui32Heap].hDevMemHeap);
-				}
 				break;
 			}
 		}
 	}
 
-	eError =
-	    BM_DestroyContext(psDeviceNode->sDevMemoryInfo.pBMKernelContext,
-			      IMG_NULL);
-	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "DevDeInitSGX : Failed to destroy kernel context"));
-		return eError;
-	}
+	if (!pvr_put_ctx(psDeviceNode->sDevMemoryInfo.pBMKernelContext))
+		pr_err("%s: kernel context still in use, can't free it",
+				__func__);
 
-	eError =
-	    PVRSRVRemovePowerDevice(((PVRSRV_DEVICE_NODE *) pvDeviceNode)->
-				    sDevId.ui32DeviceIndex);
-	if (eError != PVRSRV_OK) {
+
+	eError = PVRSRVRemovePowerDevice(
+				((struct PVRSRV_DEVICE_NODE *)pvDeviceNode)->
+				  sDevId.ui32DeviceIndex);
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	eError = SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE_SGX,
-				       (IMG_VOID **) & psSGXDeviceMap);
+				       (void **) &psSGXDeviceMap);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "DevDeInitSGX: Failed to get device memory map!"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "DevDeInitSGX: Failed to get device memory map!");
 		return eError;
 	}
 
-	if (!psSGXDeviceMap->pvRegsCpuVBase) {
-
-		if (psDevInfo->pvRegsBaseKM != IMG_NULL) {
+	if (!psSGXDeviceMap->pvRegsCpuVBase)
+		if (psDevInfo->pvRegsBaseKM != NULL)
 			OSUnMapPhysToLin(psDevInfo->pvRegsBaseKM,
 					 psDevInfo->ui32RegSize,
 					 PVRSRV_HAP_KERNEL_ONLY |
-					 PVRSRV_HAP_UNCACHED, IMG_NULL);
-		}
-	}
+					 PVRSRV_HAP_UNCACHED, NULL);
 
 	OSFreePages(PVRSRV_OS_PAGEABLE_HEAP | PVRSRV_HAP_MULTI_PROCESS,
-		    sizeof(PVRSRV_SGXDEV_INFO), psDevInfo, hDevInfoOSMemHandle);
-	psDeviceNode->pvDevice = IMG_NULL;
-
-	if (psDeviceMemoryHeap != IMG_NULL) {
+		    sizeof(struct PVRSRV_SGXDEV_INFO), psDevInfo,
+		    hDevInfoOSMemHandle);
+	psDeviceNode->pvDevice = NULL;
 
+	if (psDeviceMemoryHeap != NULL)
 		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-			  sizeof(DEVICE_MEMORY_HEAP_INFO) *
+			  sizeof(struct DEVICE_MEMORY_HEAP_INFO) *
 			  psDeviceNode->sDevMemoryInfo.ui32HeapCount,
-			  psDeviceMemoryHeap, 0);
-	}
+			  psDeviceMemoryHeap, NULL);
 
 	return PVRSRV_OK;
 }
 
 static
-IMG_VOID HWRecoveryResetSGX(PVRSRV_DEVICE_NODE * psDeviceNode,
-			    IMG_UINT32 ui32Component, IMG_UINT32 ui32CallerID)
+void HWRecoveryResetSGX(struct PVRSRV_DEVICE_NODE *psDeviceNode,
+			    u32 ui32Component, u32 ui32CallerID)
 {
-	PVRSRV_ERROR eError;
-	PVRSRV_SGXDEV_INFO *psDevInfo =
-	    (PVRSRV_SGXDEV_INFO *) psDeviceNode->pvDevice;
-	PVRSRV_SGX_HOST_CTL *psSGXHostCtl =
-	    (PVRSRV_SGX_HOST_CTL *) psDevInfo->psSGXHostCtl;
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo =
+	    (struct PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
+	struct PVRSRV_SGX_HOST_CTL *psSGXHostCtl =
+	    (struct PVRSRV_SGX_HOST_CTL *)psDevInfo->psSGXHostCtl;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Component);
 
-	eError = PVRSRVPowerLock(ui32CallerID, IMG_FALSE);
-	if (eError != PVRSRV_OK) {
-
-		PVR_DPF((PVR_DBG_WARNING,
-			 "HWRecoveryResetSGX: Power transition in progress"));
-		return;
+	/* SGXOSTimer already has the lock as it needs to read SGX registers */
+	if (ui32CallerID != TIMER_ID) {
+		eError = PVRSRVPowerLock(ui32CallerID, IMG_FALSE);
+		if (eError != PVRSRV_OK) {
+			PVR_DPF(PVR_DBG_WARNING, "HWRecoveryResetSGX: "
+				"Power transition in progress");
+			return;
+		}
 	}
 
 	psSGXHostCtl->ui32InterruptClearFlags |= PVRSRV_USSE_EDM_INTERRUPT_HWR;
@@ -981,13 +956,11 @@
 
 	do {
 		eError = SGXInitialise(psDevInfo, IMG_TRUE);
-	}
-	while (eError == PVRSRV_ERROR_RETRY);
-	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
+	} while (eError == PVRSRV_ERROR_RETRY);
+	if (eError != PVRSRV_OK)
+		PVR_DPF(PVR_DBG_ERROR,
 			 "HWRecoveryResetSGX: SGXInitialise failed (%d)",
-			 eError));
-	}
+			 eError);
 
 	PDUMPRESUME();
 
@@ -998,35 +971,35 @@
 	PVRSRVProcessQueues(ui32CallerID, IMG_TRUE);
 }
 
-static struct workdata {
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	IMG_UINT32 ui32Component;
-	IMG_UINT32 ui32CallerID;
-} gHWRecoveryParams;
-
-static void HWRecoveryWrapper(struct work_struct *work)
-{
-	HWRecoveryResetSGX(gHWRecoveryParams.psDeviceNode,
-			   gHWRecoveryParams.ui32Component,
-			   gHWRecoveryParams.ui32CallerID);
-}
-
-DECLARE_WORK(gWork, HWRecoveryWrapper);
-
-IMG_VOID SGXOSTimer(IMG_VOID * pvData)
+static void SGXOSTimer(struct work_struct *work)
 {
-	PVRSRV_DEVICE_NODE *psDeviceNode = pvData;
-	PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-	static IMG_UINT32 ui32EDMTasks = 0;
-	static IMG_UINT32 ui32LockupCounter = 0;
-	static IMG_UINT32 ui32NumResets = 0;
-	IMG_UINT32 ui32CurrentEDMTasks;
+	struct timer_work_data *data = container_of(work,
+						    struct timer_work_data,
+						    work.work);
+	struct PVRSRV_DEVICE_NODE *psDeviceNode = data->psDeviceNode;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+	static u32 ui32EDMTasks;
+	static u32 ui32LockupCounter;
+	static u32 ui32NumResets;
+	u32 ui32CurrentEDMTasks;
 	IMG_BOOL bLockup = IMG_FALSE;
 	IMG_BOOL bPoweredDown;
+	enum PVRSRV_ERROR eError;
 
 	psDevInfo->ui32TimeStamp++;
 
-	bPoweredDown = (IMG_BOOL) ! SGXIsDevicePowered(psDeviceNode);
+	eError = PVRSRVPowerLock(TIMER_ID, IMG_FALSE);
+	if (eError != PVRSRV_OK) {
+		/*
+		 * If a power transition is in progress then we're not really
+		 * sure what the state of world is going to be after, so we
+		 * just "pause" HW recovery and hopefully next time around we
+		 * get the lock and can decide what to do
+		 */
+		goto rearm;
+	}
+
+	bPoweredDown = (IMG_BOOL) !SGXIsDevicePowered(psDeviceNode);
 
 	if (bPoweredDown) {
 		ui32LockupCounter = 0;
@@ -1035,19 +1008,18 @@
 		ui32CurrentEDMTasks =
 		    OSReadHWReg(psDevInfo->pvRegsBaseKM,
 				psDevInfo->ui32EDMTaskReg0);
-		if (psDevInfo->ui32EDMTaskReg1 != 0) {
+		if (psDevInfo->ui32EDMTaskReg1 != 0)
 			ui32CurrentEDMTasks ^=
 			    OSReadHWReg(psDevInfo->pvRegsBaseKM,
 					psDevInfo->ui32EDMTaskReg1);
-		}
 		if ((ui32CurrentEDMTasks == ui32EDMTasks) &&
 		    (psDevInfo->ui32NumResets == ui32NumResets)) {
 			ui32LockupCounter++;
 			if (ui32LockupCounter == 3) {
 				ui32LockupCounter = 0;
-				PVR_DPF((PVR_DBG_ERROR,
-					 "SGXOSTimer() detected SGX lockup (0x%x tasks)",
-					 ui32EDMTasks));
+				PVR_DPF(PVR_DBG_ERROR,
+				"SGXOSTimer() detected SGX lockup (0x%x tasks)",
+				 ui32EDMTasks);
 
 				bLockup = IMG_TRUE;
 			}
@@ -1059,41 +1031,92 @@
 	}
 
 	if (bLockup) {
-		PVRSRV_SGX_HOST_CTL *psSGXHostCtl =
-		    (PVRSRV_SGX_HOST_CTL *) psDevInfo->psSGXHostCtl;
+		struct PVRSRV_SGX_HOST_CTL *psSGXHostCtl =
+		    (struct PVRSRV_SGX_HOST_CTL *)psDevInfo->psSGXHostCtl;
 
 		psSGXHostCtl->ui32HostDetectedLockups++;
 
-		/*
-		 * schedule HWRecoveryResetSGX from a work
-		 * in the shared queue
-		 */
-		gHWRecoveryParams.psDeviceNode = psDeviceNode;
-		gHWRecoveryParams.ui32Component = 0;
-		gHWRecoveryParams.ui32CallerID = TIMER_ID;
-		schedule_work(&gWork);
+		/* Note: This will release the lock when done */
+		HWRecoveryResetSGX(psDeviceNode, 0, TIMER_ID);
+	} else
+		PVRSRVPowerUnlock(TIMER_ID);
+
+ rearm:
+	queue_delayed_work(data->work_queue, &data->work,
+			   msecs_to_jiffies(data->interval));
+}
+
+static struct timer_work_data *
+SGXOSTimerInit(struct PVRSRV_DEVICE_NODE *psDeviceNode)
+{
+	struct timer_work_data *data;
+
+	data = kzalloc(sizeof(struct timer_work_data), GFP_KERNEL);
+	if (!data)
+		return NULL;
+
+	data->work_queue = create_workqueue("SGXOSTimer");
+	if (!data->work_queue) {
+		kfree(data);
+		return NULL;
 	}
+
+	data->interval = 150;
+	data->psDeviceNode = psDeviceNode;
+	INIT_DELAYED_WORK(&data->work, SGXOSTimer);
+
+	return data;
 }
 
+static void SGXOSTimerDeInit(struct timer_work_data *data)
+{
+	destroy_workqueue(data->work_queue);
+	kfree(data);
+}
 
-IMG_BOOL SGX_ISRHandler(IMG_VOID * pvData)
+static enum PVRSRV_ERROR SGXOSTimerEnable(struct timer_work_data *data)
+{
+	if (!data)
+		return PVRSRV_ERROR_GENERIC;
+
+	if (queue_delayed_work(data->work_queue, &data->work,
+			       msecs_to_jiffies(data->interval))) {
+		data->armed = true;
+		return PVRSRV_OK;
+	}
+
+	return PVRSRV_ERROR_GENERIC;
+}
+
+static enum PVRSRV_ERROR SGXOSTimerCancel(struct timer_work_data *data)
+{
+	if (!data)
+		return PVRSRV_ERROR_GENERIC;
+
+	cancel_delayed_work_sync(&data->work);
+	data->armed = false;
+
+	return PVRSRV_OK;
+}
+
+static IMG_BOOL SGX_ISRHandler(void *pvData)
 {
 	IMG_BOOL bInterruptProcessed = IMG_FALSE;
 
 	{
-		IMG_UINT32 ui32EventStatus, ui32EventEnable;
-		IMG_UINT32 ui32EventClear = 0;
-		PVRSRV_DEVICE_NODE *psDeviceNode;
-		PVRSRV_SGXDEV_INFO *psDevInfo;
-
-		if (pvData == IMG_NULL) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "SGX_ISRHandler: Invalid params\n"));
+		u32 ui32EventStatus, ui32EventEnable;
+		u32 ui32EventClear = 0;
+		struct PVRSRV_DEVICE_NODE *psDeviceNode;
+		struct PVRSRV_SGXDEV_INFO *psDevInfo;
+
+		if (pvData == NULL) {
+			PVR_DPF(PVR_DBG_ERROR,
+				 "SGX_ISRHandler: Invalid params\n");
 			return bInterruptProcessed;
 		}
 
-		psDeviceNode = (PVRSRV_DEVICE_NODE *) pvData;
-		psDevInfo = (PVRSRV_SGXDEV_INFO *) psDeviceNode->pvDevice;
+		psDeviceNode = (struct PVRSRV_DEVICE_NODE *)pvData;
+		psDevInfo = (struct PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
 
 		ui32EventStatus =
 		    OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_STATUS);
@@ -1105,9 +1128,8 @@
 
 		ui32EventStatus &= ui32EventEnable;
 
-		if (ui32EventStatus & EUR_CR_EVENT_STATUS_SW_EVENT_MASK) {
+		if (ui32EventStatus & EUR_CR_EVENT_STATUS_SW_EVENT_MASK)
 			ui32EventClear |= EUR_CR_EVENT_HOST_CLEAR_SW_EVENT_MASK;
-		}
 
 		if (ui32EventClear) {
 			bInterruptProcessed = IMG_TRUE;
@@ -1123,26 +1145,26 @@
 	return bInterruptProcessed;
 }
 
-IMG_VOID SGX_MISRHandler(IMG_VOID * pvData)
+static void SGX_MISRHandler(void *pvData)
 {
-	PVRSRV_DEVICE_NODE *psDeviceNode = (PVRSRV_DEVICE_NODE *) pvData;
-	PVRSRV_SGXDEV_INFO *psDevInfo =
-	    (PVRSRV_SGXDEV_INFO *) psDeviceNode->pvDevice;
-	PVRSRV_SGX_HOST_CTL *psSGXHostCtl =
-	    (PVRSRV_SGX_HOST_CTL *) psDevInfo->psSGXHostCtl;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode =
+		(struct PVRSRV_DEVICE_NODE *)pvData;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo =
+	    (struct PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
+	struct PVRSRV_SGX_HOST_CTL *psSGXHostCtl =
+	    (struct PVRSRV_SGX_HOST_CTL *)psDevInfo->psSGXHostCtl;
 
 	if ((psSGXHostCtl->ui32InterruptFlags & PVRSRV_USSE_EDM_INTERRUPT_HWR)
 	    && !(psSGXHostCtl->
-		 ui32InterruptClearFlags & PVRSRV_USSE_EDM_INTERRUPT_HWR)) {
+		 ui32InterruptClearFlags & PVRSRV_USSE_EDM_INTERRUPT_HWR))
 		HWRecoveryResetSGX(psDeviceNode, 0, ISR_ID);
-	}
 	SGXTestActivePowerEvent(psDeviceNode, ISR_ID);
 }
 
-PVRSRV_ERROR SGXRegisterDevice(PVRSRV_DEVICE_NODE * psDeviceNode)
+enum PVRSRV_ERROR SGXRegisterDevice(struct PVRSRV_DEVICE_NODE *psDeviceNode)
 {
-	DEVICE_MEMORY_INFO *psDevMemoryInfo;
-	DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
+	struct DEVICE_MEMORY_INFO *psDevMemoryInfo;
+	struct DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
 
 	psDeviceNode->sDevId.eDeviceType = DEV_DEVICE_TYPE;
 	psDeviceNode->sDevId.eDeviceClass = DEV_DEVICE_CLASS;
@@ -1164,35 +1186,29 @@
 	psDeviceNode->pfnMMUGetPhysPageAddr = MMU_GetPhysPageAddr;
 	psDeviceNode->pfnMMUGetPDDevPAddr = MMU_GetPDDevPAddr;
 
-
 	psDeviceNode->pfnDeviceISR = SGX_ISRHandler;
 	psDeviceNode->pfnDeviceMISR = SGX_MISRHandler;
 
 	psDeviceNode->pfnDeviceCommandComplete = SGXCommandComplete;
 
 	psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
-
 	psDevMemoryInfo->ui32AddressSpaceSizeLog2 = SGX_ADDRESS_SPACE_SIZE;
-
 	psDevMemoryInfo->ui32Flags = 0;
-
 	psDevMemoryInfo->ui32HeapCount = SGX_MAX_HEAP_ID;
-
 	psDevMemoryInfo->ui32SyncHeapID = SGX_SYNCINFO_HEAP_ID;
-
 	psDevMemoryInfo->ui32MappingHeapID = SGX_GENERAL_MAPPING_HEAP_ID;
 
 	if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-		       sizeof(DEVICE_MEMORY_HEAP_INFO) *
+		       sizeof(struct DEVICE_MEMORY_HEAP_INFO) *
 		       psDevMemoryInfo->ui32HeapCount,
-		       (IMG_VOID **) & psDevMemoryInfo->psDeviceMemoryHeap,
-		       0) != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SGXRegisterDevice : Failed to alloc memory for DEVICE_MEMORY_HEAP_INFO"));
-		return (PVRSRV_ERROR_OUT_OF_MEMORY);
+		       (void **) &psDevMemoryInfo->psDeviceMemoryHeap,
+		       NULL) != PVRSRV_OK) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "SGXRegisterDevice : alloc failed for heap info");
+		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 	OSMemSet(psDevMemoryInfo->psDeviceMemoryHeap, 0,
-		 sizeof(DEVICE_MEMORY_HEAP_INFO) *
+		 sizeof(struct DEVICE_MEMORY_HEAP_INFO) *
 		 psDevMemoryInfo->ui32HeapCount);
 
 	psDeviceMemoryHeap = psDevMemoryInfo->psDeviceMemoryHeap;
@@ -1409,25 +1425,21 @@
 	psDeviceMemoryHeap[SGX_ALT_MAPPING_HEAP_ID].DevMemHeapType =
 	    DEVICE_MEMORY_HEAP_SHARED_EXPORTED;
 
-
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR SGXGetClientInfoKM(IMG_HANDLE hDevCookie,
-				    PVR3DIF4_CLIENT_INFO * psClientInfo)
-{
-	PVRSRV_SGXDEV_INFO *psDevInfo =
-	    (PVRSRV_SGXDEV_INFO *) ((PVRSRV_DEVICE_NODE *) hDevCookie)->
-	    pvDevice;
+enum PVRSRV_ERROR SGXGetClientInfoKM(void *hDevCookie,
+				    struct PVR3DIF4_CLIENT_INFO *psClientInfo)
+{
+	struct PVRSRV_SGXDEV_INFO *psDevInfo =
+	    (struct PVRSRV_SGXDEV_INFO *)
+			((struct PVRSRV_DEVICE_NODE *)hDevCookie)->pvDevice;
 
 	psDevInfo->ui32ClientRefCount++;
 #ifdef PDUMP
-	if (psDevInfo->ui32ClientRefCount == 1) {
+	if (psDevInfo->ui32ClientRefCount == 1)
 		psDevInfo->psKernelCCBInfo->ui32CCBDumpWOff = 0;
-	}
 #endif
-
 	psClientInfo->ui32ProcessID = OSGetCurrentProcessIDKM();
 
 	OSMemCopy(&psClientInfo->asDevData, &psDevInfo->asSGXDevData,
@@ -1436,9 +1448,8 @@
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR SGXGetMiscInfoKM(PVRSRV_SGXDEV_INFO * psDevInfo,
-				  SGX_MISC_INFO * psMiscInfo)
+enum PVRSRV_ERROR SGXGetMiscInfoKM(struct PVRSRV_SGXDEV_INFO *psDevInfo,
+				  struct SGX_MISC_INFO *psMiscInfo)
 {
 	switch (psMiscInfo->eRequest) {
 	case SGX_MISC_INFO_REQUEST_CLOCKSPEED:
@@ -1461,28 +1472,28 @@
 		}
 	case SGX_MISC_INFO_REQUEST_HWPERF_RETRIEVE_CB:
 		{
-			SGX_MISC_INFO_HWPERF_RETRIEVE_CB *psRetrieve =
+			struct SGX_MISC_INFO_HWPERF_RETRIEVE_CB *psRetrieve =
 			    &psMiscInfo->uData.sRetrieveCB;
-			PVRSRV_SGX_HWPERF_CB *psHWPerfCB =
-			    (PVRSRV_SGX_HWPERF_CB *) psDevInfo->
+			struct PVRSRV_SGX_HWPERF_CB *psHWPerfCB =
+			    (struct PVRSRV_SGX_HWPERF_CB *)psDevInfo->
 			    psKernelHWPerfCBMemInfo->pvLinAddrKM;
-			IMG_UINT i = 0;
+			unsigned i = 0;
 
 			for (;
 			     psHWPerfCB->ui32Woff != psHWPerfCB->ui32Roff
 			     && i < psRetrieve->ui32ArraySize; i++) {
-				PVRSRV_SGX_HWPERF_CBDATA *psData =
+				struct PVRSRV_SGX_HWPERF_CBDATA *psData =
 				    &psHWPerfCB->psHWPerfCBData[psHWPerfCB->
 								ui32Roff];
 				OSMemCopy(&psRetrieve->psHWPerfData[i], psData,
-					  sizeof(PVRSRV_SGX_HWPERF_CBDATA));
+				      sizeof(struct PVRSRV_SGX_HWPERF_CBDATA));
 				psRetrieve->psHWPerfData[i].ui32ClockSpeed =
 				    psDevInfo->ui32CoreClockSpeed;
 				psRetrieve->psHWPerfData[i].ui32TimeMax =
 				    psDevInfo->ui32uKernelTimerClock;
 				psHWPerfCB->ui32Roff =
-				    (psHWPerfCB->ui32Roff +
-				     1) & (PVRSRV_SGX_HWPERF_CBSIZE - 1);
+				    (psHWPerfCB->ui32Roff + 1) &
+				    (PVRSRV_SGX_HWPERF_CBSIZE - 1);
 			}
 			psRetrieve->ui32DataCount = i;
 			psRetrieve->ui32Time = OSClockus();
@@ -1496,34 +1507,26 @@
 	}
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR SGXReadDiffCountersKM(IMG_HANDLE hDevHandle,
-				       IMG_UINT32 ui32Reg,
-				       IMG_UINT32 * pui32Old,
-				       IMG_BOOL bNew,
-				       IMG_UINT32 ui32New,
-				       IMG_UINT32 ui32NewReset,
-				       IMG_UINT32 ui32CountersReg,
-				       IMG_UINT32 * pui32Time,
-				       IMG_BOOL * pbActive,
-				       PVRSRV_SGXDEV_DIFF_INFO * psDiffs)
-{
-	PVRSRV_ERROR eError;
-	SYS_DATA *psSysData;
-	PVRSRV_POWER_DEV *psPowerDevice;
+enum PVRSRV_ERROR SGXReadDiffCountersKM(void *hDevHandle, u32 ui32Reg,
+				   u32 *pui32Old, IMG_BOOL bNew, u32 ui32New,
+				   u32 ui32NewReset, u32 ui32CountersReg,
+				   u32 *pui32Time, IMG_BOOL *pbActive,
+				   struct PVRSRV_SGXDEV_DIFF_INFO *psDiffs)
+{
+	enum PVRSRV_ERROR eError;
+	struct SYS_DATA *psSysData;
+	struct PVRSRV_POWER_DEV *psPowerDevice;
 	IMG_BOOL bPowered = IMG_FALSE;
-	PVRSRV_DEVICE_NODE *psDeviceNode = hDevHandle;
-	PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode = hDevHandle;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
 
-	if (bNew) {
+	if (bNew)
 		psDevInfo->ui32HWGroupRequested = ui32New;
-	}
 	psDevInfo->ui32HWReset |= ui32NewReset;
 
 	eError = PVRSRVPowerLock(KERNEL_ID, IMG_FALSE);
-	if (eError != PVRSRV_OK) {
+	if (eError != PVRSRV_OK)
 		return eError;
-	}
 
 	SysAcquireData(&psSysData);
 
@@ -1543,13 +1546,12 @@
 	*pbActive = bPowered;
 
 	{
-		PVRSRV_SGXDEV_DIFF_INFO sNew, *psPrev = &psDevInfo->sDiffInfo;
-		IMG_UINT32 i;
+		struct PVRSRV_SGXDEV_DIFF_INFO sNew,
+					       *psPrev = &psDevInfo->sDiffInfo;
+		u32 i;
 
 		sNew.ui32Time[0] = OSClockus();
-
 		*pui32Time = sNew.ui32Time[0];
-
 		if (sNew.ui32Time[0] != psPrev->ui32Time[0] && bPowered) {
 
 			*pui32Old =
@@ -1600,10 +1602,8 @@
 
 			*psPrev = sNew;
 		} else {
-
-			for (i = 0; i < PVRSRV_SGX_DIFF_NUM_COUNTERS; ++i) {
+			for (i = 0; i < PVRSRV_SGX_DIFF_NUM_COUNTERS; ++i)
 				psDiffs->aui32Counters[i] = 0;
-			}
 
 			psDiffs->ui32Marker[0] = 0;
 			psDiffs->ui32Marker[1] = 0;
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgxkick.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgxkick.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -28,7 +28,7 @@
 #include "services_headers.h"
 #include "sgxinfo.h"
 #include "sgxinfokm.h"
-#if defined (PDUMP)
+#if defined(PDUMP)
 #include "sgxapi_km.h"
 #include "pdump_km.h"
 #endif
@@ -37,52 +37,51 @@
 #include "pvr_debug.h"
 #include "sgxutils.h"
 
-IMG_EXPORT
-    PVRSRV_ERROR SGXDoKickKM(IMG_HANDLE hDevHandle,
-			     PVR3DIF4_CCB_KICK * psCCBKick)
+enum PVRSRV_ERROR SGXDoKickKM(void *hDevHandle,
+			     struct PVR3DIF4_CCB_KICK *psCCBKick)
 {
-	PVRSRV_ERROR eError;
-	PVRSRV_KERNEL_SYNC_INFO *psSyncInfo;
-	PVRSRV_KERNEL_MEM_INFO *psCCBMemInfo =
-	    (PVRSRV_KERNEL_MEM_INFO *) psCCBKick->hCCBKernelMemInfo;
-	PVR3DIF4_CMDTA_SHARED *psTACmd;
-	IMG_UINT32 i;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	PVRSRV_SGXDEV_INFO *psDevInfo;
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_KERNEL_SYNC_INFO *psSyncInfo;
+	struct PVRSRV_KERNEL_MEM_INFO *psCCBMemInfo =
+	    (struct PVRSRV_KERNEL_MEM_INFO *)psCCBKick->hCCBKernelMemInfo;
+	struct PVR3DIF4_CMDTA_SHARED *psTACmd;
+	u32 i;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo;
 
-	psDeviceNode = (PVRSRV_DEVICE_NODE *) hDevHandle;
-	psDevInfo = (PVRSRV_SGXDEV_INFO *) psDeviceNode->pvDevice;
+	psDeviceNode = (struct PVRSRV_DEVICE_NODE *)hDevHandle;
+	psDevInfo = (struct PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
 
-	if (psCCBKick->bKickRender) {
+	if (psCCBKick->bKickRender)
 		++psDevInfo->ui32KickTARenderCounter;
-	}
 	++psDevInfo->ui32KickTACounter;
 
 	if (!CCB_OFFSET_IS_VALID
-	    (PVR3DIF4_CMDTA_SHARED, psCCBMemInfo, psCCBKick, ui32CCBOffset)) {
-		PVR_DPF((PVR_DBG_ERROR, "SGXDoKickKM: Invalid CCB offset"));
+	    (struct PVR3DIF4_CMDTA_SHARED, psCCBMemInfo, psCCBKick,
+	     ui32CCBOffset)) {
+		PVR_DPF(PVR_DBG_ERROR, "SGXDoKickKM: Invalid CCB offset");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
 	psTACmd =
-	    CCB_DATA_FROM_OFFSET(PVR3DIF4_CMDTA_SHARED, psCCBMemInfo, psCCBKick,
-				 ui32CCBOffset);
+	    CCB_DATA_FROM_OFFSET(struct PVR3DIF4_CMDTA_SHARED, psCCBMemInfo,
+				 psCCBKick, ui32CCBOffset);
 
 	if (psCCBKick->hTA3DSyncInfo) {
 		psSyncInfo =
-		    (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->hTA3DSyncInfo;
+		    (struct PVRSRV_KERNEL_SYNC_INFO *)psCCBKick->hTA3DSyncInfo;
 		psTACmd->sTA3DDependancy.sWriteOpsCompleteDevVAddr =
 		    psSyncInfo->sWriteOpsCompleteDevVAddr;
 
 		psTACmd->sTA3DDependancy.ui32WriteOpPendingVal =
 		    psSyncInfo->psSyncData->ui32WriteOpsPending;
 
-		if (psCCBKick->bTADependency) {
+		if (psCCBKick->bTADependency)
 			psSyncInfo->psSyncData->ui32WriteOpsPending++;
-		}
 	}
 
-	if (psCCBKick->hTASyncInfo != IMG_NULL) {
-		psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->hTASyncInfo;
+	if (psCCBKick->hTASyncInfo != NULL) {
+		psSyncInfo = (struct PVRSRV_KERNEL_SYNC_INFO *)
+						psCCBKick->hTASyncInfo;
 
 		psTACmd->sTQSyncReadOpsCompleteDevVAddr =
 		    psSyncInfo->sReadOpsCompleteDevVAddr;
@@ -95,8 +94,9 @@
 		    psSyncInfo->psSyncData->ui32WriteOpsPending;
 	}
 
-	if (psCCBKick->h3DSyncInfo != IMG_NULL) {
-		psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->h3DSyncInfo;
+	if (psCCBKick->h3DSyncInfo != NULL) {
+		psSyncInfo = (struct PVRSRV_KERNEL_SYNC_INFO *)
+							psCCBKick->h3DSyncInfo;
 
 		psTACmd->s3DTQSyncReadOpsCompleteDevVAddr =
 		    psSyncInfo->sReadOpsCompleteDevVAddr;
@@ -110,27 +110,25 @@
 	}
 
 	psTACmd->ui32NumTAStatusVals = psCCBKick->ui32NumTAStatusVals;
-	if (psCCBKick->ui32NumTAStatusVals != 0) {
+	if (psCCBKick->ui32NumTAStatusVals != 0)
 
 		for (i = 0; i < psCCBKick->ui32NumTAStatusVals; i++) {
-			psSyncInfo =
-			    (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->
-			    ahTAStatusSyncInfo[i];
+			psSyncInfo = (struct PVRSRV_KERNEL_SYNC_INFO *)
+				psCCBKick->ahTAStatusSyncInfo[i];
 
 			psTACmd->sCtlTAStatusInfo[i].sStatusDevAddr =
-			    psSyncInfo->sReadOpsCompleteDevVAddr;
+				psSyncInfo->sReadOpsCompleteDevVAddr;
 
 			psTACmd->sCtlTAStatusInfo[i].ui32StatusValue =
-			    psSyncInfo->psSyncData->ui32ReadOpsPending;
+				psSyncInfo->psSyncData->ui32ReadOpsPending;
 		}
-	}
 
 	psTACmd->ui32Num3DStatusVals = psCCBKick->ui32Num3DStatusVals;
-	if (psCCBKick->ui32Num3DStatusVals != 0) {
+	if (psCCBKick->ui32Num3DStatusVals != 0)
 
 		for (i = 0; i < psCCBKick->ui32Num3DStatusVals; i++) {
 			psSyncInfo =
-			    (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->
+			    (struct PVRSRV_KERNEL_SYNC_INFO *)psCCBKick->
 			    ah3DStatusSyncInfo[i];
 
 			psTACmd->sCtl3DStatusInfo[i].sStatusDevAddr =
@@ -139,40 +137,39 @@
 			psTACmd->sCtl3DStatusInfo[i].ui32StatusValue =
 			    psSyncInfo->psSyncData->ui32ReadOpsPending;
 		}
-	}
 
 	psTACmd->ui32NumSrcSyncs = psCCBKick->ui32NumSrcSyncs;
 	for (i = 0; i < psCCBKick->ui32NumSrcSyncs; i++) {
 		psSyncInfo =
-		    (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->
+		    (struct PVRSRV_KERNEL_SYNC_INFO *)psCCBKick->
 		    ahSrcKernelSyncInfo[i];
 
 		psTACmd->asSrcSyncs[i].sWriteOpsCompleteDevVAddr =
-		    psSyncInfo->sWriteOpsCompleteDevVAddr;
+			psSyncInfo->sWriteOpsCompleteDevVAddr;
 		psTACmd->asSrcSyncs[i].sReadOpsCompleteDevVAddr =
-		    psSyncInfo->sReadOpsCompleteDevVAddr;
+			psSyncInfo->sReadOpsCompleteDevVAddr;
 
 		psTACmd->asSrcSyncs[i].ui32ReadOpPendingVal =
-		    psSyncInfo->psSyncData->ui32ReadOpsPending++;
+			psSyncInfo->psSyncData->ui32ReadOpsPending++;
 
 		psTACmd->asSrcSyncs[i].ui32WriteOpPendingVal =
-		    psSyncInfo->psSyncData->ui32WriteOpsPending;
+			psSyncInfo->psSyncData->ui32WriteOpsPending;
 
 	}
 
-	if (psCCBKick->bFirstKickOrResume
-	    && psCCBKick->hRenderSurfSyncInfo != IMG_NULL) {
-		psSyncInfo =
-		    (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->hRenderSurfSyncInfo;
+	if (psCCBKick->bFirstKickOrResume &&
+	    psCCBKick->hRenderSurfSyncInfo != NULL) {
+		psSyncInfo = (struct PVRSRV_KERNEL_SYNC_INFO *)
+						psCCBKick->hRenderSurfSyncInfo;
 		psTACmd->sWriteOpsCompleteDevVAddr =
-		    psSyncInfo->sWriteOpsCompleteDevVAddr;
+			psSyncInfo->sWriteOpsCompleteDevVAddr;
 		psTACmd->sReadOpsCompleteDevVAddr =
-		    psSyncInfo->sReadOpsCompleteDevVAddr;
+			psSyncInfo->sReadOpsCompleteDevVAddr;
 
 		psTACmd->ui32ReadOpsPendingVal =
-		    psSyncInfo->psSyncData->ui32ReadOpsPending;
+			psSyncInfo->psSyncData->ui32ReadOpsPending;
 		psTACmd->ui32WriteOpsPendingVal =
-		    psSyncInfo->psSyncData->ui32WriteOpsPending++;
+			psSyncInfo->psSyncData->ui32WriteOpsPending++;
 
 #if defined(PDUMP)
 		if (PDumpIsCaptureFrameKM()) {
@@ -180,18 +177,15 @@
 
 				PDUMPCOMMENT("Init render surface last op\r\n");
 
-				PDUMPMEM(IMG_NULL,
-					 psSyncInfo->psSyncDataMemInfoKM,
-					 0,
-					 sizeof(PVRSRV_SYNC_DATA),
-					 0,
-					 MAKEUNIQUETAG(psSyncInfo->
+				PDUMPMEM(NULL, psSyncInfo->psSyncDataMemInfoKM,
+					 0, sizeof(struct PVRSRV_SYNC_DATA),
+					 0, MAKEUNIQUETAG(psSyncInfo->
 						       psSyncDataMemInfoKM));
 
 				PDUMPMEM(&psSyncInfo->psSyncData->
 					 ui32LastOpDumpVal,
 					 psSyncInfo->psSyncDataMemInfoKM,
-					 offsetof(PVRSRV_SYNC_DATA,
+					 offsetof(struct PVRSRV_SYNC_DATA,
 						  ui32WriteOpsComplete),
 					 sizeof(psSyncInfo->psSyncData->
 						ui32WriteOpsComplete), 0,
@@ -207,75 +201,62 @@
 	if (PDumpIsCaptureFrameKM()) {
 		PDUMPCOMMENT("Shared part of TA command\r\n");
 
-		PDUMPMEM(psTACmd,
-			 psCCBMemInfo,
-			 psCCBKick->ui32CCBDumpWOff,
-			 sizeof(PVR3DIF4_CMDTA_SHARED),
-			 0, MAKEUNIQUETAG(psCCBMemInfo));
+		PDUMPMEM(psTACmd, psCCBMemInfo, psCCBKick->ui32CCBDumpWOff,
+			 sizeof(struct PVR3DIF4_CMDTA_SHARED), 0,
+			 MAKEUNIQUETAG(psCCBMemInfo));
 
-		if (psCCBKick->hRenderSurfSyncInfo != IMG_NULL) {
-			IMG_UINT32 ui32HackValue;
+		if (psCCBKick->hRenderSurfSyncInfo != NULL) {
+			u32 ui32HackValue;
 
-			psSyncInfo =
-			    (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->
-			    hRenderSurfSyncInfo;
+			psSyncInfo = (struct PVRSRV_KERNEL_SYNC_INFO *)
+				psCCBKick->hRenderSurfSyncInfo;
 			ui32HackValue =
-			    psSyncInfo->psSyncData->ui32LastOpDumpVal - 1;
+				psSyncInfo->psSyncData->ui32LastOpDumpVal - 1;
 
-			PDUMPCOMMENT
-			    ("Hack render surface last op in TA cmd\r\n");
+			PDUMPCOMMENT(
+				"Hack render surface last op in TA cmd\r\n");
 
-			PDUMPMEM(&ui32HackValue,
-				 psCCBMemInfo,
+			PDUMPMEM(&ui32HackValue, psCCBMemInfo,
 				 psCCBKick->ui32CCBDumpWOff +
-				 offsetof(PVR3DIF4_CMDTA_SHARED,
+				 offsetof(struct PVR3DIF4_CMDTA_SHARED,
 					  ui32WriteOpsPendingVal),
-				 sizeof(IMG_UINT32), 0,
-				 MAKEUNIQUETAG(psCCBMemInfo));
+				 sizeof(u32), 0, MAKEUNIQUETAG(psCCBMemInfo));
 
 			ui32HackValue = 0;
-			PDUMPCOMMENT
-			    ("Hack render surface read op in TA cmd\r\n");
+			PDUMPCOMMENT(
+				"Hack render surface read op in TA cmd\r\n");
 
-			PDUMPMEM(&ui32HackValue,
-				 psCCBMemInfo,
+			PDUMPMEM(&ui32HackValue, psCCBMemInfo,
 				 psCCBKick->ui32CCBDumpWOff +
-				 offsetof(PVR3DIF4_CMDTA_SHARED,
+				 offsetof(struct PVR3DIF4_CMDTA_SHARED,
 					  sReadOpsCompleteDevVAddr),
-				 sizeof(IMG_UINT32), 0,
-				 MAKEUNIQUETAG(psCCBMemInfo));
+				 sizeof(u32), 0, MAKEUNIQUETAG(psCCBMemInfo));
 		}
 
 		for (i = 0; i < psCCBKick->ui32NumTAStatusVals; i++) {
-			psSyncInfo =
-			    (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->
-			    ahTAStatusSyncInfo[i];
+			psSyncInfo = (struct PVRSRV_KERNEL_SYNC_INFO *)
+				psCCBKick->ahTAStatusSyncInfo[i];
 
 			PDUMPCOMMENT("Hack TA status value in TA cmd\r\n");
 
 			PDUMPMEM(&psSyncInfo->psSyncData->ui32LastOpDumpVal,
-				 psCCBMemInfo,
-				 psCCBKick->ui32CCBDumpWOff +
-				 offsetof(PVR3DIF4_CMDTA_SHARED,
+				 psCCBMemInfo, psCCBKick->ui32CCBDumpWOff +
+				 offsetof(struct PVR3DIF4_CMDTA_SHARED,
 					  sCtlTAStatusInfo[i].ui32StatusValue),
-				 sizeof(IMG_UINT32), 0,
-				 MAKEUNIQUETAG(psCCBMemInfo));
+				 sizeof(u32), 0, MAKEUNIQUETAG(psCCBMemInfo));
 		}
 
 		for (i = 0; i < psCCBKick->ui32Num3DStatusVals; i++) {
-			psSyncInfo =
-			    (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->
-			    ah3DStatusSyncInfo[i];
+			psSyncInfo = (struct PVRSRV_KERNEL_SYNC_INFO *)
+				psCCBKick->ah3DStatusSyncInfo[i];
 
 			PDUMPCOMMENT("Hack 3D status value in TA cmd\r\n");
 
 			PDUMPMEM(&psSyncInfo->psSyncData->ui32LastOpDumpVal,
-				 psCCBMemInfo,
-				 psCCBKick->ui32CCBDumpWOff +
-				 offsetof(PVR3DIF4_CMDTA_SHARED,
+				 psCCBMemInfo, psCCBKick->ui32CCBDumpWOff +
+				 offsetof(struct PVR3DIF4_CMDTA_SHARED,
 					  sCtl3DStatusInfo[i].ui32StatusValue),
-				 sizeof(IMG_UINT32), 0,
-				 MAKEUNIQUETAG(psCCBMemInfo));
+				 sizeof(u32), 0, MAKEUNIQUETAG(psCCBMemInfo));
 		}
 	}
 #endif
@@ -284,41 +265,35 @@
 	    SGXScheduleCCBCommandKM(hDevHandle, psCCBKick->eCommand,
 				    &psCCBKick->sCommand, KERNEL_ID);
 	if (eError == PVRSRV_ERROR_RETRY) {
-		if (psCCBKick->bFirstKickOrResume
-		    && psCCBKick->hRenderSurfSyncInfo != IMG_NULL) {
-
-			psSyncInfo =
-			    (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->
-			    hRenderSurfSyncInfo;
+		if (psCCBKick->bFirstKickOrResume &&
+		    psCCBKick->hRenderSurfSyncInfo != NULL) {
+			psSyncInfo = (struct PVRSRV_KERNEL_SYNC_INFO *)
+				psCCBKick->hRenderSurfSyncInfo;
 			psSyncInfo->psSyncData->ui32WriteOpsPending--;
 		}
 
 		for (i = 0; i < psCCBKick->ui32NumSrcSyncs; i++) {
-			psSyncInfo =
-			    (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->
-			    ahSrcKernelSyncInfo[i];
+			psSyncInfo = (struct PVRSRV_KERNEL_SYNC_INFO *)
+				psCCBKick->ahSrcKernelSyncInfo[i];
 			psSyncInfo->psSyncData->ui32ReadOpsPending--;
 		}
 
 #if defined(PDUMP)
-		if (psCCBKick->bFirstKickOrResume
-		    && psCCBKick->hRenderSurfSyncInfo != IMG_NULL) {
+		if (psCCBKick->bFirstKickOrResume &&
+		    psCCBKick->hRenderSurfSyncInfo != NULL)
 			if (PDumpIsCaptureFrameKM()) {
-				psSyncInfo =
-				    (PVRSRV_KERNEL_SYNC_INFO *) psCCBKick->
-				    hRenderSurfSyncInfo;
+				psSyncInfo = (struct PVRSRV_KERNEL_SYNC_INFO *)
+					psCCBKick->hRenderSurfSyncInfo;
 				psSyncInfo->psSyncData->ui32LastOpDumpVal--;
 			}
-		}
 #endif
 
 		return eError;
 	} else if (PVRSRV_OK != eError) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SGXDoKickKM: SGXScheduleCCBCommandKM failed."));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "SGXDoKickKM: SGXScheduleCCBCommandKM failed.");
 		return eError;
 	}
 
-
 	return eError;
 }
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgxmmu.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgxmmu.h
@@ -1,53 +1,53 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #if !defined(__SGXMMU_KM_H__)
 #define __SGXMMU_KM_H__
 
-#define SGX_MMU_PAGE_SHIFT				(12)
-#define SGX_MMU_PAGE_SIZE				(1UL<<SGX_MMU_PAGE_SHIFT)
-#define SGX_MMU_PAGE_MASK				(SGX_MMU_PAGE_SIZE - 1UL)
-
-#define SGX_MMU_PD_SHIFT				(10)
-#define SGX_MMU_PD_SIZE					(1UL<<SGX_MMU_PD_SHIFT)
-#define SGX_MMU_PD_MASK					(0xFFC00000UL)
+#define SGX_MMU_PAGE_SHIFT			(12)
+#define SGX_MMU_PAGE_SIZE			(1UL << SGX_MMU_PAGE_SHIFT)
+#define SGX_MMU_PAGE_MASK			(SGX_MMU_PAGE_SIZE - 1UL)
+
+#define SGX_MMU_PD_SHIFT			(10)
+#define SGX_MMU_PD_SIZE				(1UL << SGX_MMU_PD_SHIFT)
+#define SGX_MMU_PD_MASK				(0xFFC00000UL)
 
 #define SGX_MMU_PDE_ADDR_MASK			(0xFFFFF000UL)
-#define SGX_MMU_PDE_VALID				(0x00000001UL)
+#define SGX_MMU_PDE_VALID			(0x00000001UL)
 #define SGX_MMU_PDE_WRITEONLY			(0x00000002UL)
 #define SGX_MMU_PDE_READONLY			(0x00000004UL)
 #define SGX_MMU_PDE_CACHECONSISTENT		(0x00000008UL)
 #define SGX_MMU_PDE_EDMPROTECT			(0x00000010UL)
 
-#define SGX_MMU_PT_SHIFT				(10)
-#define SGX_MMU_PT_SIZE					(1UL<<SGX_MMU_PT_SHIFT)
-#define SGX_MMU_PT_MASK					(0x003FF000UL)
+#define SGX_MMU_PT_SHIFT			(10)
+#define SGX_MMU_PT_SIZE				(1UL << SGX_MMU_PT_SHIFT)
+#define SGX_MMU_PT_MASK				(0x003FF000UL)
 
 #define SGX_MMU_PTE_ADDR_MASK			(0xFFFFF000UL)
-#define SGX_MMU_PTE_VALID				(0x00000001UL)
+#define SGX_MMU_PTE_VALID			(0x00000001UL)
 #define SGX_MMU_PTE_WRITEONLY			(0x00000002UL)
 #define SGX_MMU_PTE_READONLY			(0x00000004UL)
 #define SGX_MMU_PTE_CACHECONSISTENT		(0x00000008UL)
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgxreset.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgxreset.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -34,11 +34,11 @@
 
 #define SGX_BIF_DIR_LIST_REG_EDM	EUR_CR_BIF_DIR_LIST_BASE0
 
-static IMG_VOID SGXResetSoftReset(PVRSRV_SGXDEV_INFO * psDevInfo,
-				  IMG_BOOL bResetBIF,
-				  IMG_UINT32 ui32PDUMPFlags, IMG_BOOL bPDump)
+static void SGXResetSoftReset(struct PVRSRV_SGXDEV_INFO *psDevInfo,
+				  IMG_BOOL bResetBIF, u32 ui32PDUMPFlags,
+				  IMG_BOOL bPDump)
 {
-	IMG_UINT32 ui32SoftResetRegVal =
+	u32 ui32SoftResetRegVal =
 #ifdef EUR_CR_SOFT_RESET_TWOD_RESET_MASK
 	    EUR_CR_SOFT_RESET_TWOD_RESET_MASK |
 #endif
@@ -51,20 +51,18 @@
 	PVR_UNREFERENCED_PARAMETER(ui32PDUMPFlags);
 #endif
 
-	if (bResetBIF) {
+	if (bResetBIF)
 		ui32SoftResetRegVal |= EUR_CR_SOFT_RESET_BIF_RESET_MASK;
-	}
 
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_SOFT_RESET,
 		     ui32SoftResetRegVal);
-	if (bPDump) {
+	if (bPDump)
 		PDUMPREGWITHFLAGS(EUR_CR_SOFT_RESET, ui32SoftResetRegVal,
 				  ui32PDUMPFlags);
-	}
 }
 
-static IMG_VOID SGXResetSleep(PVRSRV_SGXDEV_INFO * psDevInfo,
-			      IMG_UINT32 ui32PDUMPFlags, IMG_BOOL bPDump)
+static void SGXResetSleep(struct PVRSRV_SGXDEV_INFO *psDevInfo,
+			      u32 ui32PDUMPFlags, IMG_BOOL bPDump)
 {
 #if !defined(PDUMP)
 	PVR_UNREFERENCED_PARAMETER(ui32PDUMPFlags);
@@ -80,50 +78,46 @@
 
 }
 
-static IMG_VOID SGXResetInvalDC(PVRSRV_SGXDEV_INFO * psDevInfo,
-				IMG_UINT32 ui32PDUMPFlags, IMG_BOOL bPDump)
+static void SGXResetInvalDC(struct PVRSRV_SGXDEV_INFO *psDevInfo,
+				u32 ui32PDUMPFlags, IMG_BOOL bPDump)
 {
-	IMG_UINT32 ui32RegVal;
+	u32 ui32RegVal;
 
 	ui32RegVal = EUR_CR_BIF_CTRL_INVALDC_MASK;
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL, ui32RegVal);
-	if (bPDump) {
+	if (bPDump)
 		PDUMPREGWITHFLAGS(EUR_CR_BIF_CTRL, ui32RegVal, ui32PDUMPFlags);
-	}
 	SGXResetSleep(psDevInfo, ui32PDUMPFlags, bPDump);
 
 	ui32RegVal = 0;
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_CTRL, ui32RegVal);
-	if (bPDump) {
+	if (bPDump)
 		PDUMPREGWITHFLAGS(EUR_CR_BIF_CTRL, ui32RegVal, ui32PDUMPFlags);
-	}
 	SGXResetSleep(psDevInfo, ui32PDUMPFlags, bPDump);
 
 	{
 
 		if (PollForValueKM
-		    ((IMG_UINT32 *) ((IMG_UINT8 *) psDevInfo->pvRegsBaseKM +
-				     EUR_CR_BIF_MEM_REQ_STAT), 0,
+		    ((u32 *)((u8 __force *)psDevInfo->pvRegsBaseKM +
+				   EUR_CR_BIF_MEM_REQ_STAT), 0,
 		     EUR_CR_BIF_MEM_REQ_STAT_READS_MASK,
 		     MAX_HW_TIME_US / WAIT_TRY_COUNT,
-		     WAIT_TRY_COUNT) != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "Wait for DC invalidate failed."));
-		}
+		     WAIT_TRY_COUNT) != PVRSRV_OK)
+			PVR_DPF(PVR_DBG_ERROR,
+				 "Wait for DC invalidate failed.");
 
-		if (bPDump) {
+		if (bPDump)
 			PDUMPREGPOLWITHFLAGS(EUR_CR_BIF_MEM_REQ_STAT, 0,
 					     EUR_CR_BIF_MEM_REQ_STAT_READS_MASK,
 					     ui32PDUMPFlags);
-		}
 	}
 }
 
-IMG_VOID SGXReset(PVRSRV_SGXDEV_INFO * psDevInfo, IMG_UINT32 ui32PDUMPFlags)
+void SGXReset(struct PVRSRV_SGXDEV_INFO *psDevInfo, u32 ui32PDUMPFlags)
 {
-	IMG_UINT32 ui32RegVal;
+	u32 ui32RegVal;
 
-	const IMG_UINT32 ui32BifFaultMask = EUR_CR_BIF_INT_STAT_FAULT_MASK;
+	const u32 ui32BifFaultMask = EUR_CR_BIF_INT_STAT_FAULT_MASK;
 
 
 #ifndef PDUMP
@@ -181,19 +175,18 @@
 	SGXResetInvalDC(psDevInfo, ui32PDUMPFlags, IMG_FALSE);
 
 	for (;;) {
-		IMG_UINT32 ui32BifIntStat =
+		u32 ui32BifIntStat =
 		    OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_INT_STAT);
-		IMG_DEV_VIRTADDR sBifFault;
-		IMG_UINT32 ui32PDIndex, ui32PTIndex;
+		struct IMG_DEV_VIRTADDR sBifFault;
+		u32 ui32PDIndex, ui32PTIndex;
 
-		if ((ui32BifIntStat & ui32BifFaultMask) == 0) {
+		if ((ui32BifIntStat & ui32BifFaultMask) == 0)
 			break;
-		}
 
 		sBifFault.uiAddr =
 		    OSReadHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_BIF_FAULT);
-		PVR_DPF((PVR_DBG_WARNING, "SGXReset: Page fault 0x%x/0x%x",
-			 ui32BifIntStat, sBifFault.uiAddr));
+		PVR_DPF(PVR_DBG_WARNING, "SGXReset: Page fault 0x%x/0x%x",
+			 ui32BifIntStat, sBifFault.uiAddr);
 		ui32PDIndex =
 		    sBifFault.uiAddr >> (SGX_MMU_PAGE_SHIFT + SGX_MMU_PT_SHIFT);
 		ui32PTIndex =
@@ -238,7 +231,7 @@
 
 	SGXResetInvalDC(psDevInfo, ui32PDUMPFlags, IMG_TRUE);
 
-	PVR_DPF((PVR_DBG_WARNING, "Soft Reset of SGX"));
+	PVR_DPF(PVR_DBG_WARNING, "Soft Reset of SGX");
 	SGXResetSleep(psDevInfo, ui32PDUMPFlags, IMG_TRUE);
 
 	ui32RegVal = 0;
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgxscript.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgxscript.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -31,34 +31,34 @@
 #define	SGX_MAX_INIT_COMMANDS	64
 #define	SGX_MAX_DEINIT_COMMANDS	16
 
-	typedef enum _SGX_INIT_OPERATION {
-		SGX_INIT_OP_ILLEGAL = 0,
-		SGX_INIT_OP_WRITE_HW_REG,
+enum SGX_INIT_OPERATION {
+	SGX_INIT_OP_ILLEGAL = 0,
+	SGX_INIT_OP_WRITE_HW_REG,
 #if defined(PDUMP)
-		SGX_INIT_OP_PDUMP_HW_REG,
+	SGX_INIT_OP_PDUMP_HW_REG,
 #endif
-		SGX_INIT_OP_HALT
-	} SGX_INIT_OPERATION;
+	SGX_INIT_OP_HALT
+};
 
-	typedef union _SGX_INIT_COMMAND {
-		SGX_INIT_OPERATION eOp;
-		struct {
-			SGX_INIT_OPERATION eOp;
-			IMG_UINT32 ui32Offset;
-			IMG_UINT32 ui32Value;
-		} sWriteHWReg;
+union SGX_INIT_COMMAND {
+	enum SGX_INIT_OPERATION eOp;
+	struct {
+		enum SGX_INIT_OPERATION eOp;
+		u32 ui32Offset;
+		u32 ui32Value;
+	} sWriteHWReg;
 #if defined(PDUMP)
-		struct {
-			SGX_INIT_OPERATION eOp;
-			IMG_UINT32 ui32Offset;
-			IMG_UINT32 ui32Value;
-		} sPDumpHWReg;
+	struct {
+		enum SGX_INIT_OPERATION eOp;
+		u32 ui32Offset;
+		u32 ui32Value;
+	} sPDumpHWReg;
 #endif
-	} SGX_INIT_COMMAND;
+};
 
-	typedef struct _SGX_INIT_SCRIPTS_ {
-		SGX_INIT_COMMAND asInitCommands[SGX_MAX_INIT_COMMANDS];
-		SGX_INIT_COMMAND asDeinitCommands[SGX_MAX_DEINIT_COMMANDS];
-	} SGX_INIT_SCRIPTS;
+struct SGX_INIT_SCRIPTS {
+	union SGX_INIT_COMMAND asInitCommands[SGX_MAX_INIT_COMMANDS];
+	union SGX_INIT_COMMAND asDeinitCommands[SGX_MAX_DEINIT_COMMANDS];
+};
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgxtransfer.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgxtransfer.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -32,7 +32,6 @@
 #include "buffer_manager.h"
 #include "sgxinfo.h"
 #include "sysconfig.h"
-#include "regpaths.h"
 #include "pdump_km.h"
 #include "mmu.h"
 #include "pvr_bridge.h"
@@ -42,41 +41,40 @@
 #include "pvr_debug.h"
 #include "sgxutils.h"
 
-IMG_EXPORT PVRSRV_ERROR SGXSubmitTransferKM(IMG_HANDLE hDevHandle,
-					    PVRSRV_TRANSFER_SGX_KICK * psKick)
+enum PVRSRV_ERROR SGXSubmitTransferKM(void *hDevHandle,
+				struct PVRSRV_TRANSFER_SGX_KICK *psKick)
 {
-	PVRSRV_KERNEL_MEM_INFO *psCCBMemInfo =
-	    (PVRSRV_KERNEL_MEM_INFO *) psKick->hCCBMemInfo;
-	PVRSRV_SGX_COMMAND sCommand = { 0 };
-	PVR3DIF4_TRANSFERCMD_SHARED *psTransferCmd;
-	PVRSRV_KERNEL_SYNC_INFO *psSyncInfo;
-	IMG_UINT32 i;
-	PVRSRV_ERROR eError;
+	struct PVRSRV_KERNEL_MEM_INFO *psCCBMemInfo =
+	    (struct PVRSRV_KERNEL_MEM_INFO *)psKick->hCCBMemInfo;
+	struct PVRSRV_SGX_COMMAND sCommand = { 0 };
+	struct PVR3DIF4_TRANSFERCMD_SHARED *psTransferCmd;
+	struct PVRSRV_KERNEL_SYNC_INFO *psSyncInfo;
+	u32 i;
+	enum PVRSRV_ERROR eError;
 
 	if (!CCB_OFFSET_IS_VALID
-	    (PVR3DIF4_TRANSFERCMD_SHARED, psCCBMemInfo, psKick,
+	    (struct PVR3DIF4_TRANSFERCMD_SHARED, psCCBMemInfo, psKick,
 	     ui32SharedCmdCCBOffset)) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SGXSubmitTransferKM: Invalid CCB offset"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "SGXSubmitTransferKM: Invalid CCB offset");
 		return PVRSRV_ERROR_INVALID_PARAMS;
 	}
-	psTransferCmd =
-	    CCB_DATA_FROM_OFFSET(PVR3DIF4_TRANSFERCMD_SHARED, psCCBMemInfo,
-				 psKick, ui32SharedCmdCCBOffset);
+	psTransferCmd = CCB_DATA_FROM_OFFSET(struct PVR3DIF4_TRANSFERCMD_SHARED,
+					     psCCBMemInfo, psKick,
+					     ui32SharedCmdCCBOffset);
 
-	if (psTransferCmd->ui32NumStatusVals > SGXTQ_MAX_STATUS) {
+	if (psTransferCmd->ui32NumStatusVals > SGXTQ_MAX_STATUS)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
 	if (psKick->ui32StatusFirstSync +
 	    (psKick->ui32NumSrcSync ? (psKick->ui32NumSrcSync - 1) : 0) +
 	    (psKick->ui32NumDstSync ? (psKick->ui32NumDstSync - 1) : 0) >
-	    psTransferCmd->ui32NumStatusVals) {
+	    psTransferCmd->ui32NumStatusVals)
 		return PVRSRV_ERROR_INVALID_PARAMS;
-	}
 
-	if (psKick->hTASyncInfo != IMG_NULL) {
-		psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psKick->hTASyncInfo;
+	if (psKick->hTASyncInfo != NULL) {
+		psSyncInfo = (struct PVRSRV_KERNEL_SYNC_INFO *)
+			psKick->hTASyncInfo;
 
 		psTransferCmd->ui32TASyncWriteOpsPendingVal =
 		    psSyncInfo->psSyncData->ui32WriteOpsPending++;
@@ -92,8 +90,9 @@
 		psTransferCmd->sTASyncReadOpsCompleteDevVAddr.uiAddr = 0;
 	}
 
-	if (psKick->h3DSyncInfo != IMG_NULL) {
-		psSyncInfo = (PVRSRV_KERNEL_SYNC_INFO *) psKick->h3DSyncInfo;
+	if (psKick->h3DSyncInfo != NULL) {
+		psSyncInfo = (struct PVRSRV_KERNEL_SYNC_INFO *)
+							psKick->h3DSyncInfo;
 
 		psTransferCmd->ui323DSyncWriteOpsPendingVal =
 		    psSyncInfo->psSyncData->ui32WriteOpsPending++;
@@ -114,7 +113,7 @@
 
 	if (psKick->ui32NumSrcSync > 0) {
 		psSyncInfo =
-		    (PVRSRV_KERNEL_SYNC_INFO *) psKick->ahSrcSyncInfo[0];
+		    (struct PVRSRV_KERNEL_SYNC_INFO *)psKick->ahSrcSyncInfo[0];
 
 		psTransferCmd->ui32SrcWriteOpPendingVal =
 		    psSyncInfo->psSyncData->ui32WriteOpsPending;
@@ -128,7 +127,7 @@
 	}
 	if (psKick->ui32NumDstSync > 0) {
 		psSyncInfo =
-		    (PVRSRV_KERNEL_SYNC_INFO *) psKick->ahDstSyncInfo[0];
+		    (struct PVRSRV_KERNEL_SYNC_INFO *)psKick->ahDstSyncInfo[0];
 
 		psTransferCmd->ui32DstWriteOpPendingVal =
 		    psSyncInfo->psSyncData->ui32WriteOpsPending;
@@ -142,64 +141,55 @@
 	}
 
 	if (psKick->ui32NumSrcSync > 0) {
-		psSyncInfo =
-		    (PVRSRV_KERNEL_SYNC_INFO *) psKick->ahSrcSyncInfo[0];
+		psSyncInfo = (struct PVRSRV_KERNEL_SYNC_INFO *)
+						psKick->ahSrcSyncInfo[0];
 		psSyncInfo->psSyncData->ui32ReadOpsPending++;
 
 	}
 	if (psKick->ui32NumDstSync > 0) {
-		psSyncInfo =
-		    (PVRSRV_KERNEL_SYNC_INFO *) psKick->ahDstSyncInfo[0];
+		psSyncInfo = (struct PVRSRV_KERNEL_SYNC_INFO *)
+						psKick->ahDstSyncInfo[0];
 		psSyncInfo->psSyncData->ui32WriteOpsPending++;
 	}
 
-	if (psKick->ui32NumSrcSync > 1) {
+	if (psKick->ui32NumSrcSync > 1)
 		for (i = 1; i < psKick->ui32NumSrcSync; i++) {
 			psSyncInfo =
-			    (PVRSRV_KERNEL_SYNC_INFO *) psKick->
+			    (struct PVRSRV_KERNEL_SYNC_INFO *)psKick->
 			    ahSrcSyncInfo[i];
 
 			psTransferCmd->sCtlStatusInfo[psKick->
-						      ui32StatusFirstSync].
-			    ui32StatusValue =
-			    psSyncInfo->psSyncData->ui32ReadOpsPending++;
+			      ui32StatusFirstSync].ui32StatusValue =
+				  psSyncInfo->psSyncData->ui32ReadOpsPending++;
 
 			psTransferCmd->sCtlStatusInfo[psKick->
-						      ui32StatusFirstSync].
-			    sStatusDevAddr =
-			    psSyncInfo->sReadOpsCompleteDevVAddr;
+			      ui32StatusFirstSync].sStatusDevAddr =
+				  psSyncInfo->sReadOpsCompleteDevVAddr;
 
 			psKick->ui32StatusFirstSync++;
 		}
-	}
 
-	if (psKick->ui32NumDstSync > 1) {
+	if (psKick->ui32NumDstSync > 1)
 		for (i = 1; i < psKick->ui32NumDstSync; i++) {
-			psSyncInfo =
-			    (PVRSRV_KERNEL_SYNC_INFO *) psKick->
-			    ahDstSyncInfo[i];
+			psSyncInfo = (struct PVRSRV_KERNEL_SYNC_INFO *)
+				psKick->ahDstSyncInfo[i];
 
 			psTransferCmd->sCtlStatusInfo[psKick->
-						      ui32StatusFirstSync].
-			    ui32StatusValue =
-			    psSyncInfo->psSyncData->ui32WriteOpsPending++;
+			    ui32StatusFirstSync].ui32StatusValue =
+				 psSyncInfo->psSyncData->ui32WriteOpsPending++;
 
 			psTransferCmd->sCtlStatusInfo[psKick->
-						      ui32StatusFirstSync].
-			    sStatusDevAddr =
-			    psSyncInfo->sWriteOpsCompleteDevVAddr;
+			    ui32StatusFirstSync].sStatusDevAddr =
+				 psSyncInfo->sWriteOpsCompleteDevVAddr;
 
 			psKick->ui32StatusFirstSync++;
 		}
-	}
 #if defined(PDUMP)
 	if (PDumpIsCaptureFrameKM()) {
 		PDUMPCOMMENT("Shared part of transfer command\r\n");
-		PDUMPMEM(psTransferCmd,
-			 psCCBMemInfo,
-			 psKick->ui32CCBDumpWOff,
-			 sizeof(PVR3DIF4_TRANSFERCMD_SHARED),
-			 0, MAKEUNIQUETAG(psCCBMemInfo));
+		PDUMPMEM(psTransferCmd, psCCBMemInfo, psKick->ui32CCBDumpWOff,
+			 sizeof(struct PVR3DIF4_TRANSFERCMD_SHARED), 0,
+			 MAKEUNIQUETAG(psCCBMemInfo));
 
 		if (psKick->ui32NumSrcSync > 0) {
 			psSyncInfo = psKick->ahSrcSyncInfo[0];
@@ -207,10 +197,9 @@
 			PDUMPCOMMENT
 			    ("Hack src surface write op in transfer cmd\r\n");
 			PDUMPMEM(&psSyncInfo->psSyncData->ui32LastOpDumpVal,
-				 psCCBMemInfo,
-				 psKick->ui32CCBDumpWOff +
-				 offsetof(PVR3DIF4_TRANSFERCMD_SHARED,
-					  ui32SrcWriteOpPendingVal),
+				 psCCBMemInfo, psKick->ui32CCBDumpWOff +
+				    offsetof(struct PVR3DIF4_TRANSFERCMD_SHARED,
+					    ui32SrcWriteOpPendingVal),
 				 sizeof(psSyncInfo->psSyncData->
 					ui32LastOpDumpVal), 0,
 				 MAKEUNIQUETAG(psCCBMemInfo));
@@ -218,9 +207,8 @@
 			PDUMPCOMMENT
 			    ("Hack src surface read op in transfer cmd\r\n");
 			PDUMPMEM(&psSyncInfo->psSyncData->ui32LastReadOpDumpVal,
-				 psCCBMemInfo,
-				 psKick->ui32CCBDumpWOff +
-				 offsetof(PVR3DIF4_TRANSFERCMD_SHARED,
+				 psCCBMemInfo, psKick->ui32CCBDumpWOff +
+				    offsetof(struct PVR3DIF4_TRANSFERCMD_SHARED,
 					  ui32SrcReadOpPendingVal),
 				 sizeof(psSyncInfo->psSyncData->
 					ui32LastReadOpDumpVal), 0,
@@ -232,9 +220,8 @@
 			PDUMPCOMMENT
 			    ("Hack dest surface write op in transfer cmd\r\n");
 			PDUMPMEM(&psSyncInfo->psSyncData->ui32LastOpDumpVal,
-				 psCCBMemInfo,
-				 psKick->ui32CCBDumpWOff +
-				 offsetof(PVR3DIF4_TRANSFERCMD_SHARED,
+				 psCCBMemInfo, psKick->ui32CCBDumpWOff +
+				    offsetof(struct PVR3DIF4_TRANSFERCMD_SHARED,
 					  ui32DstWriteOpPendingVal),
 				 sizeof(psSyncInfo->psSyncData->
 					ui32LastOpDumpVal), 0,
@@ -243,9 +230,8 @@
 			PDUMPCOMMENT
 			    ("Hack dest surface read op in transfer cmd\r\n");
 			PDUMPMEM(&psSyncInfo->psSyncData->ui32LastReadOpDumpVal,
-				 psCCBMemInfo,
-				 psKick->ui32CCBDumpWOff +
-				 offsetof(PVR3DIF4_TRANSFERCMD_SHARED,
+				 psCCBMemInfo, psKick->ui32CCBDumpWOff +
+				    offsetof(struct PVR3DIF4_TRANSFERCMD_SHARED,
 					  ui32DstReadOpPendingVal),
 				 sizeof(psSyncInfo->psSyncData->
 					ui32LastReadOpDumpVal), 0,
@@ -253,16 +239,14 @@
 		}
 
 		if (psKick->ui32NumSrcSync > 0) {
-			psSyncInfo =
-			    (PVRSRV_KERNEL_SYNC_INFO *) psKick->
-			    ahSrcSyncInfo[0];
+			psSyncInfo = (struct PVRSRV_KERNEL_SYNC_INFO *)
+				psKick->ahSrcSyncInfo[0];
 			psSyncInfo->psSyncData->ui32LastReadOpDumpVal++;
 
 		}
 		if (psKick->ui32NumDstSync > 0) {
-			psSyncInfo =
-			    (PVRSRV_KERNEL_SYNC_INFO *) psKick->
-			    ahDstSyncInfo[0];
+			psSyncInfo = (struct PVRSRV_KERNEL_SYNC_INFO *)
+				psKick->ahDstSyncInfo[0];
 			psSyncInfo->psSyncData->ui32LastOpDumpVal++;
 		}
 	}
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgxutils.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgxutils.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -36,6 +36,7 @@
 #include "pdump_km.h"
 #include "mmu.h"
 #include "pvr_bridge_km.h"
+#include "sgx_bridge_km.h"
 #include "osfunc.h"
 #include "pvr_debug.h"
 #include "sgxutils.h"
@@ -43,76 +44,58 @@
 #include <linux/tty.h>
 
 
-IMG_BOOL gbPowerUpPDumped = IMG_FALSE;
+static IMG_BOOL gbPowerUpPDumped = IMG_FALSE;
 
-IMG_VOID SGXTestActivePowerEvent(PVRSRV_DEVICE_NODE * psDeviceNode,
-				 IMG_UINT32 ui32CallerID)
+void SGXTestActivePowerEvent(struct PVRSRV_DEVICE_NODE *psDeviceNode,
+				 u32 ui32CallerID)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-	PVRSRV_SGX_HOST_CTL *psSGXHostCtl = psDevInfo->psSGXHostCtl;
-
-	if ((psSGXHostCtl->
-	     ui32InterruptFlags & PVRSRV_USSE_EDM_INTERRUPT_ACTIVE_POWER)
-	    && !(psSGXHostCtl->
-		 ui32PowManFlags & PVRSRV_USSE_EDM_POWMAN_POWEROFF_REQUEST)) {
-
-		{
-
-			PDUMPSUSPEND();
-
-			eError =
-			    PVRSRVSetDevicePowerStateKM(psDeviceNode->sDevId.
-							ui32DeviceIndex,
-							PVRSRV_POWER_STATE_D3,
-							ui32CallerID,
-							IMG_FALSE);
-			if (eError == PVRSRV_OK) {
-
-				psSGXHostCtl->ui32NumActivePowerEvents++;
-
-				if ((*(volatile IMG_UINT32 *)
-				     (&psSGXHostCtl->ui32PowManFlags)
-				     &
-				     PVRSRV_USSE_EDM_POWMAN_POWEROFF_RESTART_IMMEDIATE)
-				    != 0) {
-
-					if (ui32CallerID == ISR_ID) {
-						psDeviceNode->
-						    bReProcessDeviceCommandComplete
-						    = IMG_TRUE;
-					} else {
-						SGXScheduleProcessQueues
-						    (psDeviceNode);
-					}
-				}
-			}
-			if (eError == PVRSRV_ERROR_RETRY) {
-
-				eError = PVRSRV_OK;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+	struct PVRSRV_SGX_HOST_CTL *psSGXHostCtl = psDevInfo->psSGXHostCtl;
+
+	if ((psSGXHostCtl->ui32InterruptFlags &
+			PVRSRV_USSE_EDM_INTERRUPT_ACTIVE_POWER) &&
+	    !(psSGXHostCtl->ui32PowManFlags &
+			PVRSRV_USSE_EDM_POWMAN_POWEROFF_REQUEST)) {
+		PDUMPSUSPEND();
+		eError = PVRSRVSetDevicePowerStateKM(psDeviceNode->sDevId.
+					ui32DeviceIndex, PVRSRV_POWER_STATE_D3,
+					ui32CallerID, IMG_FALSE);
+		if (eError == PVRSRV_OK) {
+			psSGXHostCtl->ui32NumActivePowerEvents++;
+			if ((*(volatile u32 *)(&psSGXHostCtl->ui32PowManFlags) &
+			     PVRSRV_USSE_EDM_POWMAN_POWEROFF_RESTART_IMMEDIATE)
+			     != 0) {
+				if (ui32CallerID == ISR_ID)
+					psDeviceNode->
+					bReProcessDeviceCommandComplete =
+								     IMG_TRUE;
+				else
+					SGXScheduleProcessQueues
+						(psDeviceNode);
 			}
-
-			PDUMPRESUME();
 		}
-	}
+		if (eError == PVRSRV_ERROR_RETRY)
+			eError = PVRSRV_OK;
 
-	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR, "SGXTestActivePowerEvent error:%lu",
-			 eError));
+		PDUMPRESUME();
 	}
+
+	if (eError != PVRSRV_OK)
+		PVR_DPF(PVR_DBG_ERROR, "SGXTestActivePowerEvent error:%lu",
+					eError);
 }
 
-static INLINE PVRSRV_SGX_COMMAND *SGXAcquireKernelCCBSlot(PVRSRV_SGX_CCB_INFO *
-							  psCCB)
+static inline struct PVRSRV_SGX_COMMAND *SGXAcquireKernelCCBSlot(
+					struct PVRSRV_SGX_CCB_INFO *psCCB)
 {
 	IMG_BOOL bStart = IMG_FALSE;
-	IMG_UINT32 uiStart = 0;
+	u32 uiStart = 0;
 
 	do {
 		if (((*psCCB->pui32WriteOffset + 1) & 255) !=
-		    *psCCB->pui32ReadOffset) {
+		    *psCCB->pui32ReadOffset)
 			return &psCCB->psCommands[*psCCB->pui32WriteOffset];
-		}
 
 		if (bStart == IMG_FALSE) {
 			bStart = IMG_TRUE;
@@ -121,29 +104,29 @@
 		OSWaitus(MAX_HW_TIME_US / WAIT_TRY_COUNT);
 	} while ((OSClockus() - uiStart) < MAX_HW_TIME_US);
 
-	return IMG_NULL;
+	return NULL;
 }
 
-PVRSRV_ERROR SGXScheduleCCBCommandKM(PVRSRV_DEVICE_NODE * psDeviceNode,
-				     PVRSRV_SGX_COMMAND_TYPE eCommandType,
-				     PVRSRV_SGX_COMMAND * psCommandData,
-				     IMG_UINT32 ui32CallerID)
-{
-	PVRSRV_SGX_CCB_INFO *psKernelCCB;
-	PVRSRV_ERROR eError = PVRSRV_OK;
-	PVRSRV_SGXDEV_INFO *psDevInfo;
-	PVRSRV_SGX_COMMAND *psSGXCommand;
+enum PVRSRV_ERROR SGXScheduleCCBCommandKM(
+				     struct PVRSRV_DEVICE_NODE *psDeviceNode,
+				     enum PVRSRV_SGX_COMMAND_TYPE eCommandType,
+				     struct PVRSRV_SGX_COMMAND *psCommandData,
+				     u32 ui32CallerID)
+{
+	struct PVRSRV_SGX_CCB_INFO *psKernelCCB;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo;
+	struct PVRSRV_SGX_COMMAND *psSGXCommand;
 #if defined(PDUMP)
-	IMG_VOID *pvDumpCommand;
+	void *pvDumpCommand;
 #endif
 
-	psDevInfo = (PVRSRV_SGXDEV_INFO *) psDeviceNode->pvDevice;
+	psDevInfo = (struct PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
 	psKernelCCB = psDevInfo->psKernelCCBInfo;
 
 	{
-		if (ui32CallerID == ISR_ID || gbPowerUpPDumped) {
+		if (ui32CallerID == ISR_ID || gbPowerUpPDumped)
 			PDUMPSUSPEND();
-		}
 
 		eError =
 		    PVRSRVSetDevicePowerStateKM(psDeviceNode->sDevId.
@@ -151,17 +134,16 @@
 						PVRSRV_POWER_STATE_D0,
 						ui32CallerID, IMG_TRUE);
 
-		if (ui32CallerID == ISR_ID || gbPowerUpPDumped) {
+		if (ui32CallerID == ISR_ID || gbPowerUpPDumped)
 			PDUMPRESUME();
-		} else if (eError == PVRSRV_OK) {
+		else if (eError == PVRSRV_OK)
 			gbPowerUpPDumped = IMG_TRUE;
-		}
 	}
 
 	if (eError == PVRSRV_OK) {
 		psDeviceNode->bReProcessDeviceCommandComplete = IMG_FALSE;
 	} else {
-		if (eError == PVRSRV_ERROR_RETRY) {
+		if (eError == PVRSRV_ERROR_RETRY)
 			if (ui32CallerID == ISR_ID) {
 
 				psDeviceNode->bReProcessDeviceCommandComplete =
@@ -170,12 +152,11 @@
 			} else {
 
 			}
-		} else {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "SGXScheduleCCBCommandKM failed to acquire lock - "
-				 "ui32CallerID:%ld eError:%lu", ui32CallerID,
-				 eError));
-		}
+		else
+			PVR_DPF(PVR_DBG_ERROR,
+			     "SGXScheduleCCBCommandKM failed to acquire lock - "
+			     "ui32CallerID:%ld eError:%lu", ui32CallerID,
+			     eError);
 
 		return eError;
 	}
@@ -207,9 +188,9 @@
 		    psDevInfo->ui32VideoHandlerAddress;
 		break;
 	default:
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "SGXScheduleCCBCommandKM: Unknown command type: %d",
-			 eCommandType));
+			 eCommandType);
 		eError = PVRSRV_ERROR_GENERIC;
 		goto Exit;
 	}
@@ -220,60 +201,57 @@
 		PDUMPCOMMENTWITHFLAGS(0,
 				      "Poll for space in the Kernel CCB\r\n");
 		PDUMPMEMPOL(psKernelCCB->psCCBCtlMemInfo,
-			    offsetof(PVRSRV_SGX_CCB_CTL, ui32ReadOffset),
+			    offsetof(struct PVRSRV_SGX_CCB_CTL, ui32ReadOffset),
 			    (psKernelCCB->ui32CCBDumpWOff + 1) & 0xff, 0xff,
 			    PDUMP_POLL_OPERATOR_NOTEQUAL, IMG_FALSE, IMG_FALSE,
 			    MAKEUNIQUETAG(psKernelCCB->psCCBCtlMemInfo));
 
 		PDUMPCOMMENTWITHFLAGS(0, "Kernel CCB command\r\n");
 		pvDumpCommand =
-		    (IMG_VOID *) ((IMG_UINT8 *) psKernelCCB->psCCBMemInfo->
+		    (void *) ((u8 *) psKernelCCB->psCCBMemInfo->
 				  pvLinAddrKM +
 				  (*psKernelCCB->pui32WriteOffset *
-				   sizeof(PVRSRV_SGX_COMMAND)));
+				   sizeof(struct PVRSRV_SGX_COMMAND)));
 
 		PDUMPMEM(pvDumpCommand,
 			 psKernelCCB->psCCBMemInfo,
 			 psKernelCCB->ui32CCBDumpWOff *
-			 sizeof(PVRSRV_SGX_COMMAND), sizeof(PVRSRV_SGX_COMMAND),
+			 sizeof(struct PVRSRV_SGX_COMMAND),
+			 sizeof(struct PVRSRV_SGX_COMMAND),
 			 0, MAKEUNIQUETAG(psKernelCCB->psCCBMemInfo));
 
 		PDUMPMEM(&psDevInfo->sPDContext.ui32CacheControl,
 			 psKernelCCB->psCCBMemInfo,
 			 psKernelCCB->ui32CCBDumpWOff *
-			 sizeof(PVRSRV_SGX_COMMAND) +
-			 offsetof(PVRSRV_SGX_COMMAND, ui32Data[2]),
-			 sizeof(IMG_UINT32), 0,
+			 sizeof(struct PVRSRV_SGX_COMMAND) +
+			 offsetof(struct PVRSRV_SGX_COMMAND, ui32Data[2]),
+			 sizeof(u32), 0,
 			 MAKEUNIQUETAG(psKernelCCB->psCCBMemInfo));
 
-		if (PDumpIsCaptureFrameKM()) {
-
+		if (PDumpIsCaptureFrameKM())
 			psDevInfo->sPDContext.ui32CacheControl = 0;
-		}
 	}
 #endif
-
 	*psKernelCCB->pui32WriteOffset =
 	    (*psKernelCCB->pui32WriteOffset + 1) & 255;
 
 #if defined(PDUMP)
 	if (ui32CallerID != ISR_ID) {
-		if (PDumpIsCaptureFrameKM()) {
+		if (PDumpIsCaptureFrameKM())
 			psKernelCCB->ui32CCBDumpWOff =
 			    (psKernelCCB->ui32CCBDumpWOff + 1) & 0xFF;
-		}
 
 		PDUMPCOMMENTWITHFLAGS(0, "Kernel CCB write offset\r\n");
 		PDUMPMEM(&psKernelCCB->ui32CCBDumpWOff,
 			 psKernelCCB->psCCBCtlMemInfo,
-			 offsetof(PVRSRV_SGX_CCB_CTL, ui32WriteOffset),
-			 sizeof(IMG_UINT32),
+			 offsetof(struct PVRSRV_SGX_CCB_CTL, ui32WriteOffset),
+			 sizeof(u32),
 			 0, MAKEUNIQUETAG(psKernelCCB->psCCBCtlMemInfo));
 		PDUMPCOMMENTWITHFLAGS(0, "Kernel CCB event kicker\r\n");
 		PDUMPMEM(&psKernelCCB->ui32CCBDumpWOff,
 			 psDevInfo->psKernelCCBEventKickerMemInfo,
 			 0,
-			 sizeof(IMG_UINT32),
+			 sizeof(u32),
 			 0,
 			 MAKEUNIQUETAG(psDevInfo->
 				       psKernelCCBEventKickerMemInfo));
@@ -282,74 +260,66 @@
 				  0);
 	}
 #endif
-
 	*psDevInfo->pui32KernelCCBEventKicker =
 	    (*psDevInfo->pui32KernelCCBEventKicker + 1) & 0xFF;
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_KICK,
 		     EUR_CR_EVENT_KICK_NOW_MASK);
 
-
 Exit:
 	PVRSRVPowerUnlock(ui32CallerID);
 
-	if (ui32CallerID != ISR_ID) {
+	if (ui32CallerID != ISR_ID)
 
 		SGXTestActivePowerEvent(psDeviceNode, ui32CallerID);
-	}
 
 	return eError;
 }
 
-IMG_VOID SGXScheduleProcessQueues(PVRSRV_DEVICE_NODE * psDeviceNode)
+void SGXScheduleProcessQueues(struct PVRSRV_DEVICE_NODE *psDeviceNode)
 {
-	PVRSRV_ERROR eError;
-	PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
-	PVRSRV_SGX_HOST_CTL *psHostCtl =
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+	struct PVRSRV_SGX_HOST_CTL *psHostCtl =
 	    psDevInfo->psKernelSGXHostCtlMemInfo->pvLinAddrKM;
-	IMG_UINT32 ui32PowManFlags;
-	PVRSRV_SGX_COMMAND sCommand = { 0 };
+	u32 ui32PowManFlags;
+	struct PVRSRV_SGX_COMMAND sCommand = { 0 };
 
 	ui32PowManFlags = psHostCtl->ui32PowManFlags;
-	if ((ui32PowManFlags & PVRSRV_USSE_EDM_POWMAN_NO_WORK) != 0) {
-
+	if ((ui32PowManFlags & PVRSRV_USSE_EDM_POWMAN_NO_WORK) != 0)
 		return;
-	}
 
 	sCommand.ui32Data[0] = PVRSRV_CCBFLAGS_PROCESS_QUEUESCMD;
 	eError =
 	    SGXScheduleCCBCommandKM(psDeviceNode, PVRSRV_SGX_COMMAND_EDM_KICK,
 				    &sCommand, ISR_ID);
-	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SGXScheduleProcessQueues failed to schedule CCB command: %lu",
-			 eError));
-	}
+	if (eError != PVRSRV_OK)
+		PVR_DPF(PVR_DBG_ERROR, "SGXScheduleProcessQueues failed to "
+					"schedule CCB command: %lu",
+			 eError);
 }
 
-#if defined (PDUMP)
-IMG_VOID DumpBufferArray(PPVR3DIF4_KICKTA_DUMP_BUFFER psBufferArray,
-			 IMG_UINT32 ui32BufferArrayLength, IMG_BOOL bDumpPolls)
+#if defined(PDUMP)
+void DumpBufferArray(struct PVR3DIF4_KICKTA_DUMP_BUFFER *psBufferArray,
+			 u32 ui32BufferArrayLength, IMG_BOOL bDumpPolls)
 {
-	IMG_UINT32 i;
+	u32 i;
 
 	for (i = 0; i < ui32BufferArrayLength; i++) {
-		PPVR3DIF4_KICKTA_DUMP_BUFFER psBuffer;
-		PVRSRV_KERNEL_SYNC_INFO *psSyncInfo;
-		IMG_CHAR *pszName;
-		IMG_HANDLE hUniqueTag;
+		struct PVR3DIF4_KICKTA_DUMP_BUFFER *psBuffer;
+		struct PVRSRV_KERNEL_SYNC_INFO *psSyncInfo;
+		char *pszName;
+		void *hUniqueTag;
 
 		psBuffer = &psBufferArray[i];
 		pszName = psBuffer->pszName;
-		if (!pszName) {
+		if (!pszName)
 			pszName = "Nameless buffer";
-		}
 
 		hUniqueTag =
-		    MAKEUNIQUETAG((PVRSRV_KERNEL_MEM_INFO *) psBuffer->
+		    MAKEUNIQUETAG((struct PVRSRV_KERNEL_MEM_INFO *)psBuffer->
 				  hKernelMemInfo);
-		psSyncInfo =
-		    ((PVRSRV_KERNEL_MEM_INFO *) psBuffer->hKernelMemInfo)->
-		    psKernelSyncInfo;
+		psSyncInfo = ((struct PVRSRV_KERNEL_MEM_INFO *)
+				psBuffer->hKernelMemInfo)->psKernelSyncInfo;
 
 		if (psBuffer->ui32Start <= psBuffer->ui32End) {
 			if (bDumpPolls) {
@@ -357,7 +327,7 @@
 						      "Wait for %s space\r\n",
 						      pszName);
 				PDUMPCBP(psSyncInfo->psSyncDataMemInfoKM,
-					 offsetof(PVRSRV_SYNC_DATA,
+					 offsetof(struct PVRSRV_SYNC_DATA,
 						  ui32ReadOpsComplete),
 					 psBuffer->ui32Start,
 					 psBuffer->ui32SpaceUsed,
@@ -368,18 +338,17 @@
 
 			PDUMPCOMMENTWITHFLAGS(0, "%s\r\n", pszName);
 			PDUMPMEM(NULL,
-				 (PVRSRV_KERNEL_MEM_INFO *) psBuffer->
+				 (struct PVRSRV_KERNEL_MEM_INFO *)psBuffer->
 				 hKernelMemInfo, psBuffer->ui32Start,
 				 psBuffer->ui32End - psBuffer->ui32Start, 0,
 				 hUniqueTag);
 		} else {
-
 			if (bDumpPolls) {
 				PDUMPCOMMENTWITHFLAGS(0,
 						      "Wait for %s space\r\n",
 						      pszName);
 				PDUMPCBP(psSyncInfo->psSyncDataMemInfoKM,
-					 offsetof(PVRSRV_SYNC_DATA,
+					 offsetof(struct PVRSRV_SYNC_DATA,
 						  ui32ReadOpsComplete),
 					 psBuffer->ui32Start,
 					 psBuffer->ui32BackEndLength,
@@ -389,13 +358,13 @@
 			}
 			PDUMPCOMMENTWITHFLAGS(0, "%s (part 1)\r\n", pszName);
 			PDUMPMEM(NULL,
-				 (PVRSRV_KERNEL_MEM_INFO *) psBuffer->
+				 (struct PVRSRV_KERNEL_MEM_INFO *)psBuffer->
 				 hKernelMemInfo, psBuffer->ui32Start,
 				 psBuffer->ui32BackEndLength, 0, hUniqueTag);
 
 			if (bDumpPolls) {
 				PDUMPMEMPOL(psSyncInfo->psSyncDataMemInfoKM,
-					    offsetof(PVRSRV_SYNC_DATA,
+					    offsetof(struct PVRSRV_SYNC_DATA,
 						     ui32ReadOpsComplete), 0,
 					    0xFFFFFFFF,
 					    PDUMP_POLL_OPERATOR_NOTEQUAL,
@@ -407,7 +376,7 @@
 						      "Wait for %s space\r\n",
 						      pszName);
 				PDUMPCBP(psSyncInfo->psSyncDataMemInfoKM,
-					 offsetof(PVRSRV_SYNC_DATA,
+					 offsetof(struct PVRSRV_SYNC_DATA,
 						  ui32ReadOpsComplete), 0,
 					 psBuffer->ui32End,
 					 psBuffer->ui32BufferSize, 0,
@@ -416,7 +385,7 @@
 			}
 			PDUMPCOMMENTWITHFLAGS(0, "%s (part 2)\r\n", pszName);
 			PDUMPMEM(NULL,
-				 (PVRSRV_KERNEL_MEM_INFO *) psBuffer->
+				 (struct PVRSRV_KERNEL_MEM_INFO *)psBuffer->
 				 hKernelMemInfo, 0, psBuffer->ui32End, 0,
 				 hUniqueTag);
 		}
@@ -424,56 +393,54 @@
 }
 #endif
 
-IMG_BOOL SGXIsDevicePowered(PVRSRV_DEVICE_NODE * psDeviceNode)
+IMG_BOOL SGXIsDevicePowered(struct PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 	return PVRSRVIsDevicePowered(psDeviceNode->sDevId.ui32DeviceIndex);
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR SGXGetInternalDevInfoKM(IMG_HANDLE hDevCookie,
-					 PVR3DIF4_INTERNAL_DEVINFO *
-					 psSGXInternalDevInfo)
-{
-	PVRSRV_SGXDEV_INFO *psDevInfo =
-	    (PVRSRV_SGXDEV_INFO *) ((PVRSRV_DEVICE_NODE *) hDevCookie)->
-	    pvDevice;
+enum PVRSRV_ERROR SGXGetInternalDevInfoKM(void *hDevCookie,
+			 struct PVR3DIF4_INTERNAL_DEVINFO *psSGXInternalDevInfo)
+{
+	struct PVRSRV_SGXDEV_INFO *psDevInfo = (struct PVRSRV_SGXDEV_INFO *)
+			((struct PVRSRV_DEVICE_NODE *)hDevCookie)->pvDevice;
 
 	psSGXInternalDevInfo->ui32Flags = psDevInfo->ui32Flags;
-	psSGXInternalDevInfo->bForcePTOff = (IMG_BOOL) psDevInfo->bForcePTOff;
+	psSGXInternalDevInfo->bForcePTOff = (IMG_BOOL)psDevInfo->bForcePTOff;
 
-	psSGXInternalDevInfo->hCtlKernelMemInfoHandle =
-	    (IMG_HANDLE) psDevInfo->psKernelSGXHostCtlMemInfo;
+	psSGXInternalDevInfo->hCtlKernelMemInfoHandle = (void *)
+			psDevInfo->psKernelSGXHostCtlMemInfo;
 
 	return PVRSRV_OK;
 }
 
-static IMG_VOID SGXCleanupRequest(PVRSRV_DEVICE_NODE * psDeviceNode,
-				  IMG_DEV_VIRTADDR * psHWDataDevVAddr,
-				  IMG_UINT32 ui32ResManRequestFlag)
-{
-	PVRSRV_SGXDEV_INFO *psSGXDevInfo =
-	    (PVRSRV_SGXDEV_INFO *) psDeviceNode->pvDevice;
-	PVRSRV_KERNEL_MEM_INFO *psSGXHostCtlMemInfo =
+static void SGXCleanupRequest(struct PVRSRV_DEVICE_NODE *psDeviceNode,
+				  struct IMG_DEV_VIRTADDR *psHWDataDevVAddr,
+				  u32 ui32ResManRequestFlag)
+{
+	struct PVRSRV_SGXDEV_INFO *psSGXDevInfo =
+	    (struct PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
+	struct PVRSRV_KERNEL_MEM_INFO *psSGXHostCtlMemInfo =
 	    psSGXDevInfo->psKernelSGXHostCtlMemInfo;
-	PVRSRV_SGX_HOST_CTL *psSGXHostCtl =
-	    (PVRSRV_SGX_HOST_CTL *) psSGXHostCtlMemInfo->pvLinAddrKM;
-	IMG_UINT32 ui32PowManFlags;
-#if defined (PDUMP)
-	IMG_HANDLE hUniqueTag = MAKEUNIQUETAG(psSGXHostCtlMemInfo);
+	struct PVRSRV_SGX_HOST_CTL *psSGXHostCtl =
+	    (struct PVRSRV_SGX_HOST_CTL *)psSGXHostCtlMemInfo->pvLinAddrKM;
+	u32 ui32PowManFlags;
+#if defined(PDUMP)
+	void *hUniqueTag = MAKEUNIQUETAG(psSGXHostCtlMemInfo);
 #endif
 
 	ui32PowManFlags = psSGXHostCtl->ui32PowManFlags;
 	if ((ui32PowManFlags & PVRSRV_USSE_EDM_POWMAN_NO_WORK) != 0) {
-
+		;
 	} else {
-
-		if (psSGXDevInfo->ui32CacheControl & SGX_BIF_INVALIDATE_PDCACHE) {
+		if (psSGXDevInfo->ui32CacheControl &
+					SGX_BIF_INVALIDATE_PDCACHE) {
 			psSGXHostCtl->ui32ResManFlags |=
 			    PVRSRV_USSE_EDM_RESMAN_CLEANUP_INVALPD;
 			psSGXDevInfo->ui32CacheControl ^=
 			    SGX_BIF_INVALIDATE_PDCACHE;
 		}
-		if (psSGXDevInfo->ui32CacheControl & SGX_BIF_INVALIDATE_PTCACHE) {
+		if (psSGXDevInfo->ui32CacheControl &
+					SGX_BIF_INVALIDATE_PTCACHE) {
 			psSGXHostCtl->ui32ResManFlags |=
 			    PVRSRV_USSE_EDM_RESMAN_CLEANUP_INVALPT;
 			psSGXDevInfo->ui32CacheControl ^=
@@ -486,35 +453,35 @@
 		psSGXHostCtl->ui32ResManFlags |= ui32ResManRequestFlag;
 
 		PDUMPCOMMENT
-		    ("TA/3D CCB Control - Request clean-up event on uKernel...");
-		PDUMPMEM(IMG_NULL, psSGXHostCtlMemInfo,
-			 offsetof(PVRSRV_SGX_HOST_CTL,
+		   ("TA/3D CCB Control - Request clean-up event on uKernel...");
+		PDUMPMEM(NULL, psSGXHostCtlMemInfo,
+			 offsetof(struct PVRSRV_SGX_HOST_CTL,
 				  sResManCleanupData.uiAddr),
-			 sizeof(IMG_UINT32), PDUMP_FLAGS_CONTINUOUS,
+			 sizeof(u32), PDUMP_FLAGS_CONTINUOUS,
 			 hUniqueTag);
-		PDUMPMEM(IMG_NULL, psSGXHostCtlMemInfo,
-			 offsetof(PVRSRV_SGX_HOST_CTL, ui32ResManFlags),
-			 sizeof(IMG_UINT32), PDUMP_FLAGS_CONTINUOUS,
+		PDUMPMEM(NULL, psSGXHostCtlMemInfo,
+			 offsetof(struct PVRSRV_SGX_HOST_CTL, ui32ResManFlags),
+			 sizeof(u32), PDUMP_FLAGS_CONTINUOUS,
 			 hUniqueTag);
 
 		SGXScheduleProcessQueues(psDeviceNode);
 
 		if (PollForValueKM
-		    ((volatile IMG_UINT32 *)(&psSGXHostCtl->ui32ResManFlags),
+		    ((volatile u32 *)(&psSGXHostCtl->ui32ResManFlags),
 		     PVRSRV_USSE_EDM_RESMAN_CLEANUP_COMPLETE,
 		     PVRSRV_USSE_EDM_RESMAN_CLEANUP_COMPLETE,
 		     MAX_HW_TIME_US / WAIT_TRY_COUNT,
-		     WAIT_TRY_COUNT) != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "SGXCleanupRequest: Wait for uKernel to clean up render context failed"));
-		}
+		     WAIT_TRY_COUNT) != PVRSRV_OK)
+			PVR_DPF(PVR_DBG_ERROR, "SGXCleanupRequest: "
+			 "Wait for uKernel to clean up render context failed");
 
 #ifdef PDUMP
 
 		PDUMPCOMMENT
-		    ("TA/3D CCB Control - Wait for clean-up request to complete...");
+	       ("TA/3D CCB Control - Wait for clean-up request to complete...");
 		PDUMPMEMPOL(psSGXHostCtlMemInfo,
-			    offsetof(PVRSRV_SGX_HOST_CTL, ui32ResManFlags),
+			    offsetof(struct PVRSRV_SGX_HOST_CTL,
+			    ui32ResManFlags),
 			    PVRSRV_USSE_EDM_RESMAN_CLEANUP_COMPLETE,
 			    PVRSRV_USSE_EDM_RESMAN_CLEANUP_COMPLETE,
 			    PDUMP_POLL_OPERATOR_EQUAL, IMG_FALSE, IMG_FALSE,
@@ -524,24 +491,24 @@
 		psSGXHostCtl->ui32ResManFlags &= ~(ui32ResManRequestFlag);
 		psSGXHostCtl->ui32ResManFlags &=
 		    ~(PVRSRV_USSE_EDM_RESMAN_CLEANUP_COMPLETE);
-		PDUMPMEM(IMG_NULL, psSGXHostCtlMemInfo,
-			 offsetof(PVRSRV_SGX_HOST_CTL, ui32ResManFlags),
-			 sizeof(IMG_UINT32), PDUMP_FLAGS_CONTINUOUS,
+		PDUMPMEM(NULL, psSGXHostCtlMemInfo,
+			 offsetof(struct PVRSRV_SGX_HOST_CTL, ui32ResManFlags),
+			 sizeof(u32), PDUMP_FLAGS_CONTINUOUS,
 			 hUniqueTag);
 	}
 }
 
-typedef struct _SGX_HW_RENDER_CONTEXT_CLEANUP_ {
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	IMG_DEV_VIRTADDR sHWRenderContextDevVAddr;
-	IMG_HANDLE hBlockAlloc;
-	PRESMAN_ITEM psResItem;
-} SGX_HW_RENDER_CONTEXT_CLEANUP;
+struct SGX_HW_RENDER_CONTEXT_CLEANUP {
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct IMG_DEV_VIRTADDR sHWRenderContextDevVAddr;
+	void *hBlockAlloc;
+	struct RESMAN_ITEM *psResItem;
+};
 
-static PVRSRV_ERROR SGXCleanupHWRenderContextCallback(IMG_PVOID pvParam,
-						      IMG_UINT32 ui32Param)
+static enum PVRSRV_ERROR SGXCleanupHWRenderContextCallback(void *pvParam,
+						      u32 ui32Param)
 {
-	SGX_HW_RENDER_CONTEXT_CLEANUP *psCleanup = pvParam;
+	struct SGX_HW_RENDER_CONTEXT_CLEANUP *psCleanup = pvParam;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
@@ -550,24 +517,24 @@
 			  PVRSRV_USSE_EDM_RESMAN_CLEANUP_RC_REQUEST);
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-		  sizeof(SGX_HW_RENDER_CONTEXT_CLEANUP),
+		  sizeof(struct SGX_HW_RENDER_CONTEXT_CLEANUP),
 		  psCleanup, psCleanup->hBlockAlloc);
 
 	return PVRSRV_OK;
 }
 
-typedef struct _SGX_HW_TRANSFER_CONTEXT_CLEANUP_ {
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	IMG_DEV_VIRTADDR sHWTransferContextDevVAddr;
-	IMG_HANDLE hBlockAlloc;
-	PRESMAN_ITEM psResItem;
-} SGX_HW_TRANSFER_CONTEXT_CLEANUP;
+struct SGX_HW_TRANSFER_CONTEXT_CLEANUP {
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct IMG_DEV_VIRTADDR sHWTransferContextDevVAddr;
+	void *hBlockAlloc;
+	struct RESMAN_ITEM *psResItem;
+};
 
-static PVRSRV_ERROR SGXCleanupHWTransferContextCallback(IMG_PVOID pvParam,
-							IMG_UINT32 ui32Param)
+static enum PVRSRV_ERROR SGXCleanupHWTransferContextCallback(void *pvParam,
+							u32 ui32Param)
 {
-	SGX_HW_TRANSFER_CONTEXT_CLEANUP *psCleanup =
-	    (SGX_HW_TRANSFER_CONTEXT_CLEANUP *) pvParam;
+	struct SGX_HW_TRANSFER_CONTEXT_CLEANUP *psCleanup =
+	    (struct SGX_HW_TRANSFER_CONTEXT_CLEANUP *)pvParam;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
@@ -576,31 +543,28 @@
 			  PVRSRV_USSE_EDM_RESMAN_CLEANUP_TC_REQUEST);
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-		  sizeof(SGX_HW_TRANSFER_CONTEXT_CLEANUP),
+		  sizeof(struct SGX_HW_TRANSFER_CONTEXT_CLEANUP),
 		  psCleanup, psCleanup->hBlockAlloc);
 
 	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    IMG_HANDLE SGXRegisterHWRenderContextKM(IMG_HANDLE psDeviceNode,
-					    IMG_DEV_VIRTADDR *
-					    psHWRenderContextDevVAddr,
-					    PVRSRV_PER_PROCESS_DATA * psPerProc)
-{
-	PVRSRV_ERROR eError;
-	IMG_HANDLE hBlockAlloc;
-	SGX_HW_RENDER_CONTEXT_CLEANUP *psCleanup;
-	PRESMAN_ITEM psResItem;
+void *SGXRegisterHWRenderContextKM(void *psDeviceNode,
+			    struct IMG_DEV_VIRTADDR *psHWRenderContextDevVAddr,
+			    struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	enum PVRSRV_ERROR eError;
+	void *hBlockAlloc;
+	struct SGX_HW_RENDER_CONTEXT_CLEANUP *psCleanup;
+	struct RESMAN_ITEM *psResItem;
 
 	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-			    sizeof(SGX_HW_RENDER_CONTEXT_CLEANUP),
-			    (IMG_VOID **) & psCleanup, &hBlockAlloc);
+			    sizeof(struct SGX_HW_RENDER_CONTEXT_CLEANUP),
+			    (void **) &psCleanup, &hBlockAlloc);
 
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SGXRegisterHWRenderContextKM: Couldn't allocate memory for SGX_HW_RENDER_CONTEXT_CLEANUP structure"));
-		return IMG_NULL;
+		PVR_DPF(PVR_DBG_ERROR, "%s: alloc failed", __func__);
+		return NULL;
 	}
 
 	psCleanup->hBlockAlloc = hBlockAlloc;
@@ -609,59 +573,53 @@
 
 	psResItem = ResManRegisterRes(psPerProc->hResManContext,
 				      RESMAN_TYPE_HW_RENDER_CONTEXT,
-				      (IMG_VOID *) psCleanup,
+				      (void *) psCleanup,
 				      0, &SGXCleanupHWRenderContextCallback);
 
-	if (psResItem == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SGXRegisterHWRenderContextKM: ResManRegisterRes failed"));
+	if (psResItem == NULL) {
+		PVR_DPF(PVR_DBG_ERROR,
+			 "%s: can't register resource", __func__);
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  sizeof(SGX_HW_RENDER_CONTEXT_CLEANUP), psCleanup,
-			  psCleanup->hBlockAlloc);
+			  sizeof(struct SGX_HW_RENDER_CONTEXT_CLEANUP),
+			  psCleanup, psCleanup->hBlockAlloc);
 
-		return IMG_NULL;
+		return NULL;
 	}
 
 	psCleanup->psResItem = psResItem;
 
-	return (IMG_HANDLE) psCleanup;
+	return (void *)psCleanup;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR SGXUnregisterHWRenderContextKM(IMG_HANDLE hHWRenderContext)
+enum PVRSRV_ERROR SGXUnregisterHWRenderContextKM(void *hHWRenderContext)
 {
-	PVRSRV_ERROR eError;
-	SGX_HW_RENDER_CONTEXT_CLEANUP *psCleanup;
+	struct SGX_HW_RENDER_CONTEXT_CLEANUP *psCleanup;
 
-	PVR_ASSERT(hHWRenderContext != IMG_NULL);
+	PVR_ASSERT(hHWRenderContext != NULL);
 
-	psCleanup = (SGX_HW_RENDER_CONTEXT_CLEANUP *) hHWRenderContext;
+	psCleanup = (struct SGX_HW_RENDER_CONTEXT_CLEANUP *)hHWRenderContext;
 
-	eError = ResManFreeResByPtr(psCleanup->psResItem);
+	ResManFreeResByPtr(psCleanup->psResItem);
 
-	return eError;
+	return PVRSRV_OK;
 }
 
-IMG_EXPORT
-    IMG_HANDLE SGXRegisterHWTransferContextKM(IMG_HANDLE psDeviceNode,
-					      IMG_DEV_VIRTADDR *
-					      psHWTransferContextDevVAddr,
-					      PVRSRV_PER_PROCESS_DATA *
-					      psPerProc)
-{
-	PVRSRV_ERROR eError;
-	IMG_HANDLE hBlockAlloc;
-	SGX_HW_TRANSFER_CONTEXT_CLEANUP *psCleanup;
-	PRESMAN_ITEM psResItem;
+void *SGXRegisterHWTransferContextKM(void *psDeviceNode,
+		      struct IMG_DEV_VIRTADDR *psHWTransferContextDevVAddr,
+		      struct PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	enum PVRSRV_ERROR eError;
+	void *hBlockAlloc;
+	struct SGX_HW_TRANSFER_CONTEXT_CLEANUP *psCleanup;
+	struct RESMAN_ITEM *psResItem;
 
 	eError = OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
-			    sizeof(SGX_HW_TRANSFER_CONTEXT_CLEANUP),
-			    (IMG_VOID **) & psCleanup, &hBlockAlloc);
+			    sizeof(struct SGX_HW_TRANSFER_CONTEXT_CLEANUP),
+			    (void **) &psCleanup, &hBlockAlloc);
 
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SGXRegisterHWTransferContextKM: Couldn't allocate memory for SGX_HW_TRANSFER_CONTEXT_CLEANUP structure"));
-		return IMG_NULL;
+		PVR_DPF(PVR_DBG_ERROR, "%s: alloc failed", __func__);
+		return NULL;
 	}
 
 	psCleanup->hBlockAlloc = hBlockAlloc;
@@ -673,84 +631,83 @@
 				      psCleanup,
 				      0, &SGXCleanupHWTransferContextCallback);
 
-	if (psResItem == IMG_NULL) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SGXRegisterHWTransferContextKM: ResManRegisterRes failed"));
+	if (psResItem == NULL) {
+		PVR_DPF(PVR_DBG_ERROR,
+			"%s: can't register resource", __func__);
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  sizeof(SGX_HW_TRANSFER_CONTEXT_CLEANUP), psCleanup,
-			  psCleanup->hBlockAlloc);
+			  sizeof(struct SGX_HW_TRANSFER_CONTEXT_CLEANUP),
+			  psCleanup, psCleanup->hBlockAlloc);
 
-		return IMG_NULL;
+		return NULL;
 	}
 
 	psCleanup->psResItem = psResItem;
 
-	return (IMG_HANDLE) psCleanup;
+	return (void *)psCleanup;
 }
 
-IMG_EXPORT
-    PVRSRV_ERROR SGXUnregisterHWTransferContextKM(IMG_HANDLE hHWTransferContext)
+enum PVRSRV_ERROR SGXUnregisterHWTransferContextKM(void *hHWTransferContext)
 {
-	PVRSRV_ERROR eError;
-	SGX_HW_TRANSFER_CONTEXT_CLEANUP *psCleanup;
+	struct SGX_HW_TRANSFER_CONTEXT_CLEANUP *psCleanup;
 
-	PVR_ASSERT(hHWTransferContext != IMG_NULL);
+	PVR_ASSERT(hHWTransferContext != NULL);
 
-	psCleanup = (SGX_HW_TRANSFER_CONTEXT_CLEANUP *) hHWTransferContext;
+	psCleanup = (struct SGX_HW_TRANSFER_CONTEXT_CLEANUP *)
+							hHWTransferContext;
 
-	eError = ResManFreeResByPtr(psCleanup->psResItem);
+	ResManFreeResByPtr(psCleanup->psResItem);
 
-	return eError;
+	return PVRSRV_OK;
 }
 
 
-static INLINE
-    IMG_BOOL SGX2DQuerySyncOpsComplete(PVRSRV_KERNEL_SYNC_INFO * psSyncInfo)
+static inline IMG_BOOL SGX2DQuerySyncOpsComplete(
+				struct PVRSRV_KERNEL_SYNC_INFO *psSyncInfo)
 {
-	PVRSRV_SYNC_DATA *psSyncData = psSyncInfo->psSyncData;
+	struct PVRSRV_SYNC_DATA *psSyncData = psSyncInfo->psSyncData;
+
+	return (IMG_BOOL)((psSyncData->ui32ReadOpsComplete ==
+			  psSyncData->ui32ReadOpsPending) &&
+			  (psSyncData->ui32WriteOpsComplete ==
+			  psSyncData->ui32WriteOpsPending));
+}
 
-	return (IMG_BOOL) ((psSyncData->ui32ReadOpsComplete ==
-			    psSyncData->ui32ReadOpsPending)
-			   && (psSyncData->ui32WriteOpsComplete ==
-			       psSyncData->ui32WriteOpsPending)
-	    );
-}
-
-IMG_EXPORT
-    PVRSRV_ERROR SGX2DQueryBlitsCompleteKM(PVRSRV_SGXDEV_INFO * psDevInfo,
-					   PVRSRV_KERNEL_SYNC_INFO * psSyncInfo,
-					   IMG_BOOL bWaitForComplete)
+enum PVRSRV_ERROR SGX2DQueryBlitsCompleteKM(
+				    struct PVRSRV_SGXDEV_INFO *psDevInfo,
+				    struct PVRSRV_KERNEL_SYNC_INFO *psSyncInfo,
+				    IMG_BOOL bWaitForComplete)
 {
 	IMG_BOOL bStart = IMG_FALSE;
-	IMG_UINT32 uiStart = 0;
+	u32 uiStart = 0;
 
 	PVR_UNREFERENCED_PARAMETER(psDevInfo);
 
-	PVR_DPF((PVR_DBG_CALLTRACE, "SGX2DQueryBlitsCompleteKM: Start"));
+	PVR_DPF(PVR_DBG_CALLTRACE, "SGX2DQueryBlitsCompleteKM: Start");
 
 	if (SGX2DQuerySyncOpsComplete(psSyncInfo)) {
 
-		PVR_DPF((PVR_DBG_CALLTRACE,
-			 "SGX2DQueryBlitsCompleteKM: No wait. Blits complete."));
+		PVR_DPF(PVR_DBG_CALLTRACE, "SGX2DQueryBlitsCompleteKM: "
+					"No wait. Blits complete.");
 		return PVRSRV_OK;
 	}
 
 	if (!bWaitForComplete) {
 
-		PVR_DPF((PVR_DBG_CALLTRACE,
-			 "SGX2DQueryBlitsCompleteKM: No wait. Ops pending."));
+		PVR_DPF(PVR_DBG_CALLTRACE,
+			 "SGX2DQueryBlitsCompleteKM: No wait. Ops pending.");
 		return PVRSRV_ERROR_CMD_NOT_PROCESSED;
 	}
 
-	PVR_DPF((PVR_DBG_MESSAGE,
-		 "SGX2DQueryBlitsCompleteKM: Ops pending. Start polling."));
+	PVR_DPF(PVR_DBG_MESSAGE,
+		 "SGX2DQueryBlitsCompleteKM: Ops pending. Start polling.");
 	do {
 		OSWaitus(MAX_HW_TIME_US / WAIT_TRY_COUNT);
 
 		if (SGX2DQuerySyncOpsComplete(psSyncInfo)) {
 
-			PVR_DPF((PVR_DBG_CALLTRACE,
-				 "SGX2DQueryBlitsCompleteKM: Wait over.  Blits complete."));
+			PVR_DPF(PVR_DBG_CALLTRACE,
+				 "SGX2DQueryBlitsCompleteKM: "
+				 "Wait over.  Blits complete.");
 			return PVRSRV_OK;
 		}
 
@@ -762,31 +719,37 @@
 		OSWaitus(MAX_HW_TIME_US / WAIT_TRY_COUNT);
 	} while ((OSClockus() - uiStart) < MAX_HW_TIME_US);
 
-	PVR_DPF((PVR_DBG_ERROR,
-		 "SGX2DQueryBlitsCompleteKM: Timed out. Ops pending."));
+	PVR_DPF(PVR_DBG_ERROR,
+		 "SGX2DQueryBlitsCompleteKM: Timed out. Ops pending.");
 
 #if defined(DEBUG)
 	{
-		PVRSRV_SYNC_DATA *psSyncData = psSyncInfo->psSyncData;
-
-		PVR_TRACE(("SGX2DQueryBlitsCompleteKM: Syncinfo: %p, Syncdata: %p", psSyncInfo, psSyncData));
+		struct PVRSRV_SYNC_DATA *psSyncData = psSyncInfo->psSyncData;
 
-		PVR_TRACE(("SGX2DQueryBlitsCompleteKM: Read ops complete: %d, Read ops pending: %d", psSyncData->ui32ReadOpsComplete, psSyncData->ui32ReadOpsPending));
-		PVR_TRACE(("SGX2DQueryBlitsCompleteKM: Write ops complete: %d, Write ops pending: %d", psSyncData->ui32WriteOpsComplete, psSyncData->ui32WriteOpsPending));
+		PVR_TRACE("SGX2DQueryBlitsCompleteKM: "
+			   "Syncinfo: %p, Syncdata: %p",
+			   psSyncInfo, psSyncData);
+
+		PVR_TRACE("SGX2DQueryBlitsCompleteKM: "
+			   "Read ops complete: %d, Read ops pending: %d",
+			   psSyncData->ui32ReadOpsComplete,
+			   psSyncData->ui32ReadOpsPending);
+		PVR_TRACE("SGX2DQueryBlitsCompleteKM: "
+			  "Write ops complete: %d, Write ops pending: %d",
+			  psSyncData->ui32WriteOpsComplete,
+			  psSyncData->ui32WriteOpsPending);
 
 	}
 #endif
-
 	return PVRSRV_ERROR_TIMEOUT;
 }
 
-IMG_EXPORT
-    IMG_VOID SGXFlushHWRenderTargetKM(IMG_HANDLE psDeviceNode,
-				      IMG_DEV_VIRTADDR sHWRTDataSetDevVAddr)
+void SGXFlushHWRenderTargetKM(void *psDeviceNode,
+			      struct IMG_DEV_VIRTADDR sHWRTDataSetDevVAddr)
 {
-	PVR_ASSERT(sHWRTDataSetDevVAddr.uiAddr != IMG_NULL);
+	PVR_ASSERT(sHWRTDataSetDevVAddr.uiAddr != 0);
 
-	SGXCleanupRequest((PVRSRV_DEVICE_NODE *) psDeviceNode,
+	SGXCleanupRequest((struct PVRSRV_DEVICE_NODE *)psDeviceNode,
 			  &sHWRTDataSetDevVAddr,
 			  PVRSRV_USSE_EDM_RESMAN_CLEANUP_RT_REQUEST);
 }
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sgxutils.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sgxutils.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -40,26 +40,23 @@
 	((type *)(((char *)(psCCBMemInfo)->pvLinAddrKM) + \
 		(psCCBKick)->offset))
 
-static INLINE IMG_UINT32 SGXCalcContextCCBParamSize(IMG_UINT32 ui32ParamSize,
-						    IMG_UINT32 ui32AllocGran)
+static inline u32 SGXCalcContextCCBParamSize(u32 ui32ParamSize,
+						    u32 ui32AllocGran)
 {
 	return (ui32ParamSize + (ui32AllocGran - 1)) & ~(ui32AllocGran - 1);
 }
 
-static INLINE IMG_PVOID SGXAcquireCCB(PVRSRV_SGX_CCB * psCCB,
-				      IMG_UINT32 ui32CmdSize)
+static inline void *SGXAcquireCCB(struct PVRSRV_SGX_CCB *psCCB, u32 ui32CmdSize)
 {
 	IMG_BOOL bStart = IMG_FALSE;
-	IMG_UINT32 uiStart = 0;
+	u32 uiStart = 0;
 
 	do {
-		if (GET_CCB_SPACE
-		    (*psCCB->pui32WriteOffset, *psCCB->pui32ReadOffset,
-		     psCCB->ui32Size) > ui32CmdSize) {
-			return (IMG_PVOID) ((IMG_UINT32) psCCB->psCCBMemInfo->
-					    pvLinAddrKM +
-					    *psCCB->pui32WriteOffset);
-		}
+		if (GET_CCB_SPACE(*psCCB->pui32WriteOffset,
+				  *psCCB->pui32ReadOffset,
+				  psCCB->ui32Size) > ui32CmdSize)
+			return (void *)((u32)psCCB->psCCBMemInfo->pvLinAddrKM +
+					*psCCB->pui32WriteOffset);
 
 		if (bStart == IMG_FALSE) {
 			bStart = IMG_TRUE;
@@ -68,50 +65,39 @@
 		OSWaitus(MAX_HW_TIME_US / WAIT_TRY_COUNT);
 	} while ((OSClockus() - uiStart) < MAX_HW_TIME_US);
 
-	return IMG_NULL;
+	return NULL;
 }
 
-#if defined (PDUMP)
-IMG_VOID DumpBufferArray(PPVR3DIF4_KICKTA_DUMP_BUFFER psBufferArray,
-			 IMG_UINT32 ui32BufferArrayLength, IMG_BOOL bDumpPolls);
+#if defined(PDUMP)
+void DumpBufferArray(struct PVR3DIF4_KICKTA_DUMP_BUFFER *psBufferArray,
+			 u32 ui32BufferArrayLength, IMG_BOOL bDumpPolls);
 #endif
 
-IMG_IMPORT
-    IMG_VOID SGXTestActivePowerEvent(PVRSRV_DEVICE_NODE * psDeviceNode,
-				     IMG_UINT32 ui32CallerID);
-
-IMG_IMPORT
-    PVRSRV_ERROR SGXScheduleCCBCommandKM(PVRSRV_DEVICE_NODE * psDeviceNode,
-					 PVRSRV_SGX_COMMAND_TYPE eCommandType,
-					 PVRSRV_SGX_COMMAND * psCommandData,
-					 IMG_UINT32 ui32CallerID);
-
-IMG_IMPORT IMG_VOID SGXScheduleProcessQueues(PVRSRV_DEVICE_NODE * psDeviceNode);
-
-IMG_IMPORT IMG_BOOL SGXIsDevicePowered(PVRSRV_DEVICE_NODE * psDeviceNode);
-
-IMG_IMPORT
-    IMG_HANDLE SGXRegisterHWRenderContextKM(IMG_HANDLE psDeviceNode,
-					    IMG_DEV_VIRTADDR *
-					    psHWRenderContextDevVAddr,
-					    PVRSRV_PER_PROCESS_DATA *
-					    psPerProc);
-
-IMG_IMPORT
-    IMG_HANDLE SGXRegisterHWTransferContextKM(IMG_HANDLE psDeviceNode,
-					      IMG_DEV_VIRTADDR *
-					      psHWTransferContextDevVAddr,
-					      PVRSRV_PER_PROCESS_DATA *
-					      psPerProc);
-
-IMG_IMPORT
-    IMG_VOID SGXFlushHWRenderTargetKM(IMG_HANDLE psSGXDevInfo,
-				      IMG_DEV_VIRTADDR psHWRTDataSetDevVAddr);
-
-IMG_IMPORT
-    PVRSRV_ERROR SGXUnregisterHWRenderContextKM(IMG_HANDLE hHWRenderContext);
-
-IMG_IMPORT
-    PVRSRV_ERROR SGXUnregisterHWTransferContextKM(IMG_HANDLE
-						  hHWTransferContext);
+void SGXTestActivePowerEvent(struct PVRSRV_DEVICE_NODE *psDeviceNode,
+				     u32 ui32CallerID);
+
+enum PVRSRV_ERROR SGXScheduleCCBCommandKM(
+				struct PVRSRV_DEVICE_NODE *psDeviceNode,
+				     enum PVRSRV_SGX_COMMAND_TYPE eCommandType,
+				     struct PVRSRV_SGX_COMMAND *psCommandData,
+				     u32 ui32CallerID);
+
+void SGXScheduleProcessQueues(struct PVRSRV_DEVICE_NODE *psDeviceNode);
+
+IMG_BOOL SGXIsDevicePowered(struct PVRSRV_DEVICE_NODE *psDeviceNode);
+
+void *SGXRegisterHWRenderContextKM(void *psDeviceNode,
+			 struct IMG_DEV_VIRTADDR *psHWRenderContextDevVAddr,
+			 struct PVRSRV_PER_PROCESS_DATA *psPerProc);
+
+void *SGXRegisterHWTransferContextKM(void *psDeviceNode,
+			 struct IMG_DEV_VIRTADDR *psHWTransferContextDevVAddr,
+			 struct PVRSRV_PER_PROCESS_DATA *psPerProc);
+
+void SGXFlushHWRenderTargetKM(void *psSGXDevInfo,
+			 struct IMG_DEV_VIRTADDR psHWRTDataSetDevVAddr);
+
+enum PVRSRV_ERROR SGXUnregisterHWRenderContextKM(void *hHWRenderContext);
+
+enum PVRSRV_ERROR SGXUnregisterHWTransferContextKM(void *hHWTransferContext);
 
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/srvkm.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/srvkm.h
@@ -1,46 +1,38 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef SRVKM_H
 #define SRVKM_H
 
-
-	IMG_IMPORT PVRSRV_ERROR IMG_CALLCONV PVRSRVProcessConnect(IMG_UINT32
-								  ui32PID);
-	IMG_IMPORT IMG_VOID IMG_CALLCONV PVRSRVProcessDisconnect(IMG_UINT32
-								 ui32PID);
-
-	IMG_VOID IMG_CALLCONV PVRSRVSetDCState(IMG_UINT32 ui32State);
-
-	PVRSRV_ERROR IMG_CALLCONV PVRSRVSaveRestoreLiveSegments(IMG_HANDLE
-								hArena,
-								IMG_PBYTE
-								pbyBuffer,
-								IMG_UINT32 *
-								puiBufSize,
-								IMG_BOOL bSave);
+enum PVRSRV_ERROR PVRSRVProcessConnect(u32 ui32PID);
+void PVRSRVProcessDisconnect(u32 ui32PID);
+	void PVRSRVSetDCState(u32 ui32State);
+	enum PVRSRV_ERROR PVRSRVSaveRestoreLiveSegments(void *hArena,
+						   u8 *pbyBuffer,
+						   u32 *puiBufSize,
+						   IMG_BOOL bSave);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/syscommon.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/syscommon.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -38,118 +38,118 @@
 #include "buffer_manager.h"
 
 
-	typedef struct _SYS_DEVICE_ID_TAG {
-		IMG_UINT32 uiID;
-		IMG_BOOL bInUse;
+struct SYS_DEVICE_ID {
+	u32 uiID;
+	IMG_BOOL bInUse;
 
-	} SYS_DEVICE_ID;
+};
 
 #define SYS_MAX_LOCAL_DEVMEM_ARENAS	4
 
-	typedef struct _SYS_DATA_TAG_ {
-		IMG_UINT32 ui32NumDevices;
-		SYS_DEVICE_ID sDeviceID[SYS_DEVICE_COUNT];
-		PVRSRV_DEVICE_NODE *psDeviceNodeList;
-		PVRSRV_POWER_DEV *psPowerDeviceList;
-		PVRSRV_RESOURCE sPowerStateChangeResource;
-		PVR_POWER_STATE eCurrentPowerState;
-		PVR_POWER_STATE eFailedPowerState;
-		IMG_UINT32 ui32CurrentOSPowerState;
-		PVRSRV_QUEUE_INFO *psQueueList;
-		PVRSRV_KERNEL_SYNC_INFO *psSharedSyncInfoList;
-		IMG_PVOID pvEnvSpecificData;
-		IMG_PVOID pvSysSpecificData;
-		PVRSRV_RESOURCE sQProcessResource;
-		IMG_VOID *pvSOCRegsBase;
-		IMG_HANDLE hSOCTimerRegisterOSMemHandle;
-		IMG_UINT32 *pvSOCTimerRegisterKM;
-		IMG_VOID *pvSOCClockGateRegsBase;
-		IMG_UINT32 ui32SOCClockGateRegsSize;
-		PFN_CMD_PROC *ppfnCmdProcList[SYS_DEVICE_COUNT];
-
-		PCOMMAND_COMPLETE_DATA *ppsCmdCompleteData[SYS_DEVICE_COUNT];
-
-		IMG_BOOL bReProcessQueues;
-
-		RA_ARENA *apsLocalDevMemArena[SYS_MAX_LOCAL_DEVMEM_ARENAS];
-
-		IMG_CHAR *pszVersionString;
-		PVRSRV_EVENTOBJECT *psGlobalEventObject;
-	} SYS_DATA;
-
-	PVRSRV_ERROR SysInitialise(IMG_VOID);
-	PVRSRV_ERROR SysFinalise(IMG_VOID);
-
-	IMG_UINT32 GetCPUTranslatedAddress(IMG_VOID);
-
-	PVRSRV_ERROR SysDeinitialise(SYS_DATA * psSysData);
-
-	PVRSRV_ERROR SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE eDeviceType,
-					   IMG_VOID ** ppvDeviceMap);
-
-	IMG_VOID SysRegisterExternalDevice(PVRSRV_DEVICE_NODE * psDeviceNode);
-	IMG_VOID SysRemoveExternalDevice(PVRSRV_DEVICE_NODE * psDeviceNode);
-
-	IMG_UINT32 SysGetInterruptSource(SYS_DATA * psSysData,
-					 PVRSRV_DEVICE_NODE * psDeviceNode);
-
-	IMG_VOID SysClearInterrupts(SYS_DATA * psSysData,
-				    IMG_UINT32 ui32ClearBits);
-
-	PVRSRV_ERROR SysResetDevice(IMG_UINT32 ui32DeviceIndex);
-
-	PVRSRV_ERROR SysSystemPrePowerState(PVR_POWER_STATE eNewPowerState);
-	PVRSRV_ERROR SysSystemPostPowerState(PVR_POWER_STATE eNewPowerState);
-	PVRSRV_ERROR SysDevicePrePowerState(IMG_UINT32 ui32DeviceIndex,
-					    PVR_POWER_STATE eNewPowerState,
-					    PVR_POWER_STATE eCurrentPowerState);
-	PVRSRV_ERROR SysDevicePostPowerState(IMG_UINT32 ui32DeviceIndex,
-					     PVR_POWER_STATE eNewPowerState,
-					     PVR_POWER_STATE
-					     eCurrentPowerState);
-
-	PVRSRV_ERROR SysOEMFunction(IMG_UINT32 ui32ID,
-				    IMG_VOID * pvIn,
-				    IMG_UINT32 ulInSize,
-				    IMG_VOID * pvOut, IMG_UINT32 ulOutSize);
-
-	IMG_DEV_PHYADDR SysCpuPAddrToDevPAddr(PVRSRV_DEVICE_TYPE eDeviceType,
-					      IMG_CPU_PHYADDR cpu_paddr);
-	IMG_DEV_PHYADDR SysSysPAddrToDevPAddr(PVRSRV_DEVICE_TYPE eDeviceType,
-					      IMG_SYS_PHYADDR SysPAddr);
-	IMG_SYS_PHYADDR SysDevPAddrToSysPAddr(PVRSRV_DEVICE_TYPE eDeviceType,
-					      IMG_DEV_PHYADDR SysPAddr);
-	IMG_CPU_PHYADDR SysSysPAddrToCpuPAddr(IMG_SYS_PHYADDR SysPAddr);
-	IMG_SYS_PHYADDR SysCpuPAddrToSysPAddr(IMG_CPU_PHYADDR cpu_paddr);
-
-	extern SYS_DATA *gpsSysData;
-
-
-	static INLINE PVRSRV_ERROR SysAcquireData(SYS_DATA ** ppsSysData) {
-
-		*ppsSysData = gpsSysData;
-
-		if (!gpsSysData) {
-			return PVRSRV_ERROR_GENERIC;
-		}
-
-		return PVRSRV_OK;
-	}
-
-	static INLINE PVRSRV_ERROR SysInitialiseCommon(SYS_DATA * psSysData) {
-		PVRSRV_ERROR eError;
-
-		eError = PVRSRVInit(psSysData);
-
-		return eError;
-	}
-
-	static INLINE IMG_VOID SysDeinitialiseCommon(SYS_DATA * psSysData) {
-
-		PVRSRVDeInit(psSysData);
-
-		OSDestroyResource(&psSysData->sPowerStateChangeResource);
-	}
+struct SYS_DATA {
+	u32 ui32NumDevices;
+	struct SYS_DEVICE_ID sDeviceID[SYS_DEVICE_COUNT];
+	struct PVRSRV_DEVICE_NODE *psDeviceNodeList;
+	struct PVRSRV_POWER_DEV *psPowerDeviceList;
+	struct PVRSRV_RESOURCE sPowerStateChangeResource;
+	enum PVR_POWER_STATE eCurrentPowerState;
+	enum PVR_POWER_STATE eFailedPowerState;
+	u32 ui32CurrentOSPowerState;
+	struct PVRSRV_QUEUE_INFO *psQueueList;
+	struct PVRSRV_KERNEL_SYNC_INFO *psSharedSyncInfoList;
+	void *pvEnvSpecificData;
+	void *pvSysSpecificData;
+	struct PVRSRV_RESOURCE sQProcessResource;
+	void *pvSOCRegsBase;
+	void *hSOCTimerRegisterOSMemHandle;
+	u32 *pvSOCTimerRegisterKM;
+	void *pvSOCClockGateRegsBase;
+	u32 ui32SOCClockGateRegsSize;
+	IMG_BOOL (**ppfnCmdProcList[SYS_DEVICE_COUNT])(void *, u32, void *);
+
+	struct COMMAND_COMPLETE_DATA **ppsCmdCompleteData[SYS_DEVICE_COUNT];
+
+	IMG_BOOL bReProcessQueues;
+
+	struct RA_ARENA *apsLocalDevMemArena[SYS_MAX_LOCAL_DEVMEM_ARENAS];
+
+	char *pszVersionString;
+	struct PVRSRV_EVENTOBJECT *psGlobalEventObject;
+};
+
+enum PVRSRV_ERROR SysInitialise(void);
+enum PVRSRV_ERROR SysFinalise(void);
+
+u32 GetCPUTranslatedAddress(void);
+
+enum PVRSRV_ERROR SysDeinitialise(struct SYS_DATA *psSysData);
+
+enum PVRSRV_ERROR SysGetDeviceMemoryMap(enum PVRSRV_DEVICE_TYPE eDeviceType,
+				   void **ppvDeviceMap);
+
+void SysRegisterExternalDevice(struct PVRSRV_DEVICE_NODE *psDeviceNode);
+void SysRemoveExternalDevice(struct PVRSRV_DEVICE_NODE *psDeviceNode);
+
+u32 SysGetInterruptSource(struct SYS_DATA *psSysData,
+				 struct PVRSRV_DEVICE_NODE *psDeviceNode);
+
+void SysClearInterrupts(struct SYS_DATA *psSysData,
+			    u32 ui32ClearBits);
+
+enum PVRSRV_ERROR SysResetDevice(u32 ui32DeviceIndex);
+
+enum PVRSRV_ERROR SysSystemPrePowerState(enum PVR_POWER_STATE eNewPowerState);
+enum PVRSRV_ERROR SysSystemPostPowerState(enum PVR_POWER_STATE eNewPowerState);
+enum PVRSRV_ERROR SysDevicePrePowerState(u32 ui32DeviceIndex,
+				    enum PVR_POWER_STATE eNewPowerState,
+				    enum PVR_POWER_STATE eCurrentPowerState);
+enum PVRSRV_ERROR SysDevicePostPowerState(u32 ui32DeviceIndex,
+				     enum PVR_POWER_STATE eNewPowerState,
+				     enum PVR_POWER_STATE
+				     eCurrentPowerState);
+
+enum PVRSRV_ERROR SysOEMFunction(u32 ui32ID,
+			    void *pvIn,
+			    u32 ulInSize,
+			    void *pvOut, u32 ulOutSize);
+
+struct IMG_DEV_PHYADDR SysCpuPAddrToDevPAddr(
+			enum PVRSRV_DEVICE_TYPE eDeviceType,
+			struct IMG_CPU_PHYADDR cpu_paddr);
+struct IMG_DEV_PHYADDR SysSysPAddrToDevPAddr(
+			enum PVRSRV_DEVICE_TYPE eDeviceType,
+			struct IMG_SYS_PHYADDR SysPAddr);
+struct IMG_SYS_PHYADDR SysDevPAddrToSysPAddr(
+			enum PVRSRV_DEVICE_TYPE eDeviceType,
+			struct IMG_DEV_PHYADDR SysPAddr);
+struct IMG_CPU_PHYADDR SysSysPAddrToCpuPAddr(struct IMG_SYS_PHYADDR SysPAddr);
+struct IMG_SYS_PHYADDR SysCpuPAddrToSysPAddr(struct IMG_CPU_PHYADDR cpu_paddr);
+
+extern struct SYS_DATA *gpsSysData;
+
+
+static inline enum PVRSRV_ERROR SysAcquireData(struct SYS_DATA **ppsSysData)
+{
+	*ppsSysData = gpsSysData;
+
+	if (!gpsSysData)
+		return PVRSRV_ERROR_GENERIC;
+
+	return PVRSRV_OK;
+}
+
+static inline enum PVRSRV_ERROR SysInitialiseCommon(struct SYS_DATA *psSysData)
+{
+	enum PVRSRV_ERROR eError;
+	eError = PVRSRVInit(psSysData);
+	return eError;
+}
+
+static inline void SysDeinitialiseCommon(struct SYS_DATA *psSysData)
+{
+	PVRSRVDeInit(psSysData);
+	OSDestroyResource(&psSysData->sPowerStateChangeResource);
+}
 
 #define	SysReadHWReg(p, o) OSReadHWReg(p, o)
 #define SysWriteHWReg(p, o, v) OSWriteHWReg(p, o, v)
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sysconfig.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sysconfig.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -32,35 +32,26 @@
 #include "sgxinfokm.h"
 #include "syslocal.h"
 #include "sysconfig.h"
+#include "pvr_bridge_km.h"
 
-SYS_DATA *gpsSysData = (SYS_DATA *) IMG_NULL;
-SYS_DATA gsSysData;
+struct SYS_DATA *gpsSysData;
+static struct SYS_DATA gsSysData;
 
-static SYS_SPECIFIC_DATA gsSysSpecificData;
-SYS_SPECIFIC_DATA *gpsSysSpecificData;
+static struct SYS_SPECIFIC_DATA gsSysSpecificData;
+struct SYS_SPECIFIC_DATA *gpsSysSpecificData;
 
-static IMG_UINT32 gui32SGXDeviceID;
-static SGX_DEVICE_MAP gsSGXDeviceMap;
-static PVRSRV_DEVICE_NODE *gpsSGXDevNode;
+static u32 gui32SGXDeviceID;
+static struct SGX_DEVICE_MAP gsSGXDeviceMap;
+static struct PVRSRV_DEVICE_NODE *gpsSGXDevNode;
 
 #define DEVICE_SGX_INTERRUPT (1 << 0)
 
-
-IMG_UINT32 PVRSRV_BridgeDispatchKM(IMG_UINT32 Ioctl,
-				   IMG_BYTE * pInBuf,
-				   IMG_UINT32 InBufLen,
-				   IMG_BYTE * pOutBuf,
-				   IMG_UINT32 OutBufLen,
-				   IMG_UINT32 * pdwBytesTransferred);
-
-static PVRSRV_ERROR SysLocateDevices(SYS_DATA * psSysData)
+static enum PVRSRV_ERROR SysLocateDevices(struct SYS_DATA *psSysData)
 {
-
 	PVR_UNREFERENCED_PARAMETER(psSysData);
 
 	gsSGXDeviceMap.ui32Flags = 0x0;
 
-
 	gsSGXDeviceMap.sRegsSysPBase.uiAddr =
 	    SYS_OMAP3430_SGX_REGS_SYS_PHYS_BASE;
 	gsSGXDeviceMap.sRegsCpuPBase =
@@ -69,32 +60,28 @@
 
 	gsSGXDeviceMap.ui32IRQ = SYS_OMAP3430_SGX_IRQ;
 
-
 	return PVRSRV_OK;
 }
 
-IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion)
+char *SysCreateVersionString(struct IMG_CPU_PHYADDR sRegRegion)
 {
-	static IMG_CHAR aszVersionString[100];
-	SYS_DATA *psSysData;
-	IMG_UINT32 ui32SGXRevision;
-	IMG_INT32 i32Count;
-	IMG_VOID *pvRegsLinAddr;
+	static char aszVersionString[100];
+	struct SYS_DATA *psSysData;
+	u32 ui32SGXRevision;
+	s32 i32Count;
+	void __iomem *pvRegsLinAddr;
 
 	pvRegsLinAddr = OSMapPhysToLin(sRegRegion,
 				       SYS_OMAP3430_SGX_REGS_SIZE,
 				       PVRSRV_HAP_UNCACHED |
-				       PVRSRV_HAP_KERNEL_ONLY, IMG_NULL);
-	if (!pvRegsLinAddr) {
-		return IMG_NULL;
-	}
+				       PVRSRV_HAP_KERNEL_ONLY, NULL);
+	if (!pvRegsLinAddr)
+		return NULL;
 
-	ui32SGXRevision = OSReadHWReg((IMG_PVOID) ((IMG_PBYTE) pvRegsLinAddr),
-				      EUR_CR_CORE_REVISION);
+	ui32SGXRevision = OSReadHWReg(pvRegsLinAddr, EUR_CR_CORE_REVISION);
 
-	if (SysAcquireData(&psSysData) != PVRSRV_OK) {
-		return IMG_NULL;
-	}
+	if (SysAcquireData(&psSysData) != PVRSRV_OK)
+		return NULL;
 
 	i32Count = OSSNPrintf(aszVersionString, 100,
 			      "SGX revision = %u.%u.%u",
@@ -112,39 +99,38 @@
 				    >> EUR_CR_CORE_REVISION_MAINTENANCE_SHIFT)
 	    );
 
-	OSUnMapPhysToLin(pvRegsLinAddr,
+	OSUnMapPhysToLin((void __iomem *)pvRegsLinAddr,
 			 SYS_OMAP3430_SGX_REGS_SIZE,
 			 PVRSRV_HAP_UNCACHED | PVRSRV_HAP_KERNEL_ONLY,
-			 IMG_NULL);
+			 NULL);
 
-	if (i32Count == -1) {
-		return IMG_NULL;
-	}
+	if (i32Count == -1)
+		return NULL;
 
 	return aszVersionString;
 }
 
-PVRSRV_ERROR SysInitialise(IMG_VOID)
+enum PVRSRV_ERROR SysInitialise(void)
 {
-	IMG_UINT32 i;
-	PVRSRV_ERROR eError;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
-	IMG_CPU_PHYADDR TimerRegPhysBase;
+	u32 i;
+	enum PVRSRV_ERROR eError;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
+	struct IMG_CPU_PHYADDR TimerRegPhysBase;
 
 	gpsSysData = &gsSysData;
-	OSMemSet(gpsSysData, 0, sizeof(SYS_DATA));
+	OSMemSet(gpsSysData, 0, sizeof(struct SYS_DATA));
 
 	gpsSysSpecificData = &gsSysSpecificData;
-	OSMemSet(gpsSysSpecificData, 0, sizeof(SYS_SPECIFIC_DATA));
+	OSMemSet(gpsSysSpecificData, 0, sizeof(struct SYS_SPECIFIC_DATA));
 
 	gpsSysData->pvSysSpecificData = gpsSysSpecificData;
 
 	eError = OSInitEnvData(&gpsSysData->pvEnvSpecificData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SysInitialise: Failed to setup env structure"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "SysInitialise: Failed to setup env structure");
 		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
+		gpsSysData = NULL;
 		return eError;
 	}
 	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData,
@@ -157,35 +143,34 @@
 		gpsSysData->sDeviceID[i].bInUse = IMG_FALSE;
 	}
 
-	gpsSysData->psDeviceNodeList = IMG_NULL;
-	gpsSysData->psQueueList = IMG_NULL;
+	gpsSysData->psDeviceNodeList = NULL;
+	gpsSysData->psQueueList = NULL;
 
 	eError = SysInitialiseCommon(gpsSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SysInitialise: Failed in SysInitialiseCommon"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "SysInitialise: Failed in SysInitialiseCommon");
 		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
+		gpsSysData = NULL;
 		return eError;
 	}
 
 	TimerRegPhysBase.uiAddr =
 	    SYS_OMAP3430_GP11TIMER_PHYS_BASE + SYS_OMAP3430_GPTIMER_REGS;
-	gpsSysData->pvSOCTimerRegisterKM = IMG_NULL;
-	gpsSysData->hSOCTimerRegisterOSMemHandle = 0;
-	OSReservePhys(TimerRegPhysBase,
-		      4,
+	gpsSysData->pvSOCTimerRegisterKM = NULL;
+	gpsSysData->hSOCTimerRegisterOSMemHandle = NULL;
+	OSReservePhys(TimerRegPhysBase, 4,
 		      PVRSRV_HAP_MULTI_PROCESS | PVRSRV_HAP_UNCACHED,
-		      (IMG_VOID **) & gpsSysData->pvSOCTimerRegisterKM,
+		      (void **) &gpsSysData->pvSOCTimerRegisterKM,
 		      &gpsSysData->hSOCTimerRegisterOSMemHandle);
 
 
 	eError = SysLocateDevices(gpsSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SysInitialise: Failed to locate devices"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "SysInitialise: Failed to locate devices");
 		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
+		gpsSysData = NULL;
 		return eError;
 	}
 	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData,
@@ -194,10 +179,10 @@
 	eError = PVRSRVRegisterDevice(gpsSysData, SGXRegisterDevice,
 				      DEVICE_SGX_INTERRUPT, &gui32SGXDeviceID);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SysInitialise: Failed to register device!"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "SysInitialise: Failed to register device!");
 		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
+		gpsSysData = NULL;
 		return eError;
 	}
 	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData,
@@ -209,20 +194,20 @@
 		switch (psDeviceNode->sDevId.eDeviceType) {
 		case PVRSRV_DEVICE_TYPE_SGX:
 			{
-				DEVICE_MEMORY_INFO *psDevMemoryInfo;
-				DEVICE_MEMORY_HEAP_INFO *psDeviceMemoryHeap;
+				struct DEVICE_MEMORY_INFO *psDevMemoryInfo;
+				struct DEVICE_MEMORY_HEAP_INFO
+							*psDeviceMemoryHeap;
 
-				psDeviceNode->psLocalDevMemArena = IMG_NULL;
+				psDeviceNode->psLocalDevMemArena = NULL;
 
 				psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
 				psDeviceMemoryHeap =
 				    psDevMemoryInfo->psDeviceMemoryHeap;
 
 				for (i = 0; i < psDevMemoryInfo->ui32HeapCount;
-				     i++) {
+				     i++)
 					psDeviceMemoryHeap[i].ui32Attribs |=
-					    PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG;
-				}
+					   PVRSRV_BACKINGSTORE_SYSMEM_NONCONTIG;
 
 				gpsSGXDevNode = psDeviceNode;
 				gsSysSpecificData.psSGXDevNode = psDeviceNode;
@@ -230,8 +215,8 @@
 				break;
 			}
 		default:
-			PVR_DPF((PVR_DBG_ERROR,
-				 "SysInitialise: Failed to find SGX device node!"));
+			PVR_DPF(PVR_DBG_ERROR, "SysInitialise: "
+					"Failed to find SGX device node!");
 			return PVRSRV_ERROR_INIT_FAILURE;
 		}
 
@@ -244,21 +229,21 @@
 
 	eError = InitSystemClocks(gpsSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "SysInitialise: Failed to init system clocks (%d)",
-			 eError));
+			 eError);
 		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
+		gpsSysData = NULL;
 		return eError;
 	}
 
 	eError = EnableSystemClocks(gpsSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "SysInitialise: Failed to Enable system clocks (%d)",
-			 eError));
+			 eError);
 		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
+		gpsSysData = NULL;
 		return eError;
 	}
 	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData,
@@ -266,28 +251,28 @@
 
 	eError = OSInitPerf(gpsSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SysInitialise: Failed to init DVFS (%d)", eError));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "SysInitialise: Failed to init DVFS (%d)", eError);
 		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
+		gpsSysData = NULL;
 		return eError;
 	}
 	eError = EnableSGXClocks(gpsSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "SysInitialise: Failed to Enable SGX clocks (%d)",
-			 eError));
+			 eError);
 		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
+		gpsSysData = NULL;
 		return eError;
 	}
 
 	eError = PVRSRVInitialiseDevice(gui32SGXDeviceID);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SysInitialise: Failed to initialise device!"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "SysInitialise: Failed to initialise device!");
 		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
+		gpsSysData = NULL;
 		return eError;
 	}
 	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData,
@@ -299,26 +284,26 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR SysFinalise(IMG_VOID)
+enum PVRSRV_ERROR SysFinalise(void)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
 	eError = EnableSGXClocks(gpsSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
+		PVR_DPF(PVR_DBG_ERROR,
 			 "SysInitialise: Failed to Enable SGX clocks (%d)",
-			 eError));
+			 eError);
 		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
+		gpsSysData = NULL;
 		return eError;
 	}
 
 
 	eError = OSInstallMISR(gpsSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR, "SysFinalise: Failed to install MISR"));
+		PVR_DPF(PVR_DBG_ERROR, "SysFinalise: Failed to install MISR");
 		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
+		gpsSysData = NULL;
 		return eError;
 	}
 	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData,
@@ -328,9 +313,9 @@
 	    OSInstallDeviceLISR(gpsSysData, gsSGXDeviceMap.ui32IRQ, "SGX ISR",
 				gpsSGXDevNode);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR, "SysFinalise: Failed to install ISR"));
+		PVR_DPF(PVR_DBG_ERROR, "SysFinalise: Failed to install ISR");
 		SysDeinitialise(gpsSysData);
-		gpsSysData = IMG_NULL;
+		gpsSysData = NULL;
 		return eError;
 	}
 	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData,
@@ -338,13 +323,12 @@
 
 	gpsSysData->pszVersionString =
 	    SysCreateVersionString(gsSGXDeviceMap.sRegsCpuPBase);
-	if (!gpsSysData->pszVersionString) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SysFinalise: Failed to create a system version string"));
-	} else {
-		PVR_DPF((PVR_DBG_WARNING, "SysFinalise: Version string: %s",
-			 gpsSysData->pszVersionString));
-	}
+	if (!gpsSysData->pszVersionString)
+		PVR_DPF(PVR_DBG_ERROR, "SysFinalise: "
+				"Failed to create a system version string");
+	else
+		PVR_DPF(PVR_DBG_WARNING, "SysFinalise: Version string: %s",
+			 gpsSysData->pszVersionString);
 
 
 	DisableSGXClocks(gpsSysData);
@@ -354,9 +338,9 @@
 	return eError;
 }
 
-PVRSRV_ERROR SysDeinitialise(SYS_DATA * psSysData)
+enum PVRSRV_ERROR SysDeinitialise(struct SYS_DATA *psSysData)
 {
-	PVRSRV_ERROR eError;
+	enum PVRSRV_ERROR eError;
 
 	PVR_UNREFERENCED_PARAMETER(psSysData);
 
@@ -364,8 +348,8 @@
 	    (gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR)) {
 		eError = OSUninstallDeviceLISR(psSysData);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "SysDeinitialise: OSUninstallDeviceLISR failed"));
+			PVR_DPF(PVR_DBG_ERROR, "SysDeinitialise: "
+					"OSUninstallDeviceLISR failed");
 			return eError;
 		}
 	}
@@ -374,16 +358,16 @@
 	    (gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR)) {
 		eError = OSUninstallMISR(psSysData);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "SysDeinitialise: OSUninstallMISR failed"));
+			PVR_DPF(PVR_DBG_ERROR,
+				 "SysDeinitialise: OSUninstallMISR failed");
 			return eError;
 		}
 	}
 
 	eError = OSCleanupPerf(psSysData);
 	if (eError != PVRSRV_OK) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "SysDeinitialise: OSCleanupDvfs failed"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "SysDeinitialise: OSCleanupDvfs failed");
 		return eError;
 	}
 
@@ -395,23 +379,22 @@
 
 		eError = EnableSGXClocks(gpsSysData);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "SysDeinitialise: EnableSGXClocks failed"));
+			PVR_DPF(PVR_DBG_ERROR,
+				 "SysDeinitialise: EnableSGXClocks failed");
 			return eError;
 		}
 
 		eError = PVRSRVDeinitialiseDevice(gui32SGXDeviceID);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "SysDeinitialise: failed to de-init the device"));
+			PVR_DPF(PVR_DBG_ERROR, "SysDeinitialise: "
+				"failed to de-init the device");
 			return eError;
 		}
 	}
 
 	if (SYS_SPECIFIC_DATA_TEST
-	    (gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS)) {
+	    (gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
 		DisableSystemClocks(gpsSysData);
-	}
 
 	CleanupSystemClocks(gpsSysData);
 
@@ -419,60 +402,58 @@
 	    (gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA)) {
 		eError = OSDeInitEnvData(gpsSysData->pvEnvSpecificData);
 		if (eError != PVRSRV_OK) {
-			PVR_DPF((PVR_DBG_ERROR,
-				 "SysDeinitialise: failed to de-init env structure"));
+			PVR_DPF(PVR_DBG_ERROR, "SysDeinitialise: "
+				"failed to de-init env structure");
 			return eError;
 		}
 	}
 
-	if (gpsSysData->pvSOCTimerRegisterKM) {
-		OSUnReservePhys(gpsSysData->pvSOCTimerRegisterKM,
-				4,
+	if (gpsSysData->pvSOCTimerRegisterKM)
+		OSUnReservePhys(gpsSysData->pvSOCTimerRegisterKM, 4,
 				PVRSRV_HAP_MULTI_PROCESS | PVRSRV_HAP_UNCACHED,
 				gpsSysData->hSOCTimerRegisterOSMemHandle);
-	}
 
 	SysDeinitialiseCommon(gpsSysData);
 
 
 	if (SYS_SPECIFIC_DATA_TEST
-	    (gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT)) {
+	    (gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT))
 		PDUMPDEINIT();
-	}
 
 	gpsSysSpecificData->ui32SysSpecificData = 0;
 	gpsSysSpecificData->bSGXInitComplete = IMG_FALSE;
 
-	gpsSysData = IMG_NULL;
+	gpsSysData = NULL;
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE eDeviceType,
-				   IMG_VOID ** ppvDeviceMap)
+enum PVRSRV_ERROR SysGetDeviceMemoryMap(enum PVRSRV_DEVICE_TYPE eDeviceType,
+				   void **ppvDeviceMap)
 {
 
 	switch (eDeviceType) {
 	case PVRSRV_DEVICE_TYPE_SGX:
 		{
 
-			*ppvDeviceMap = (IMG_VOID *) & gsSGXDeviceMap;
+			*ppvDeviceMap = (void *) &gsSGXDeviceMap;
 
 			break;
 		}
 	default:
 		{
-			PVR_DPF((PVR_DBG_ERROR,
-				 "SysGetDeviceMemoryMap: unsupported device type"));
+			PVR_DPF(PVR_DBG_ERROR, "SysGetDeviceMemoryMap: "
+					"unsupported device type");
 		}
 	}
 	return PVRSRV_OK;
 }
 
-IMG_DEV_PHYADDR SysCpuPAddrToDevPAddr(PVRSRV_DEVICE_TYPE eDeviceType,
-				      IMG_CPU_PHYADDR CpuPAddr)
+struct IMG_DEV_PHYADDR SysCpuPAddrToDevPAddr(
+				enum PVRSRV_DEVICE_TYPE eDeviceType,
+				struct IMG_CPU_PHYADDR CpuPAddr)
 {
-	IMG_DEV_PHYADDR DevPAddr;
+	struct IMG_DEV_PHYADDR DevPAddr;
 
 	PVR_UNREFERENCED_PARAMETER(eDeviceType);
 
@@ -481,26 +462,27 @@
 	return DevPAddr;
 }
 
-IMG_CPU_PHYADDR SysSysPAddrToCpuPAddr(IMG_SYS_PHYADDR sys_paddr)
+struct IMG_CPU_PHYADDR SysSysPAddrToCpuPAddr(struct IMG_SYS_PHYADDR sys_paddr)
 {
-	IMG_CPU_PHYADDR cpu_paddr;
+	struct IMG_CPU_PHYADDR cpu_paddr;
 
 	cpu_paddr.uiAddr = sys_paddr.uiAddr;
 	return cpu_paddr;
 }
 
-IMG_SYS_PHYADDR SysCpuPAddrToSysPAddr(IMG_CPU_PHYADDR cpu_paddr)
+struct IMG_SYS_PHYADDR SysCpuPAddrToSysPAddr(struct IMG_CPU_PHYADDR cpu_paddr)
 {
-	IMG_SYS_PHYADDR sys_paddr;
+	struct IMG_SYS_PHYADDR sys_paddr;
 
 	sys_paddr.uiAddr = cpu_paddr.uiAddr;
 	return sys_paddr;
 }
 
-IMG_DEV_PHYADDR SysSysPAddrToDevPAddr(PVRSRV_DEVICE_TYPE eDeviceType,
-				      IMG_SYS_PHYADDR SysPAddr)
+struct IMG_DEV_PHYADDR SysSysPAddrToDevPAddr(
+				enum PVRSRV_DEVICE_TYPE eDeviceType,
+				struct IMG_SYS_PHYADDR SysPAddr)
 {
-	IMG_DEV_PHYADDR DevPAddr;
+	struct IMG_DEV_PHYADDR DevPAddr;
 
 	PVR_UNREFERENCED_PARAMETER(eDeviceType);
 
@@ -509,10 +491,11 @@
 	return DevPAddr;
 }
 
-IMG_SYS_PHYADDR SysDevPAddrToSysPAddr(PVRSRV_DEVICE_TYPE eDeviceType,
-				      IMG_DEV_PHYADDR DevPAddr)
+struct IMG_SYS_PHYADDR SysDevPAddrToSysPAddr(
+				      enum PVRSRV_DEVICE_TYPE eDeviceType,
+				      struct IMG_DEV_PHYADDR DevPAddr)
 {
-	IMG_SYS_PHYADDR SysPAddr;
+	struct IMG_SYS_PHYADDR SysPAddr;
 
 	PVR_UNREFERENCED_PARAMETER(eDeviceType);
 
@@ -521,54 +504,55 @@
 	return SysPAddr;
 }
 
-IMG_VOID SysRegisterExternalDevice(PVRSRV_DEVICE_NODE * psDeviceNode)
+void SysRegisterExternalDevice(struct PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
 }
 
-IMG_VOID SysRemoveExternalDevice(PVRSRV_DEVICE_NODE * psDeviceNode)
+void SysRemoveExternalDevice(struct PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 	PVR_UNREFERENCED_PARAMETER(psDeviceNode);
 }
 
-IMG_UINT32 SysGetInterruptSource(SYS_DATA * psSysData,
-				 PVRSRV_DEVICE_NODE * psDeviceNode)
+u32 SysGetInterruptSource(struct SYS_DATA *psSysData,
+				 struct PVRSRV_DEVICE_NODE *psDeviceNode)
 {
 	PVR_UNREFERENCED_PARAMETER(psSysData);
 
 	return psDeviceNode->ui32SOCInterruptBit;
 }
 
-IMG_VOID SysClearInterrupts(SYS_DATA * psSysData, IMG_UINT32 ui32ClearBits)
+void SysClearInterrupts(struct SYS_DATA *psSysData, u32 ui32ClearBits)
 {
 	PVR_UNREFERENCED_PARAMETER(psSysData);
 	PVR_UNREFERENCED_PARAMETER(ui32ClearBits);
 
 	/* Flush posted write for the irq status to avoid spurious interrupts */
-	OSReadHWReg(((PVRSRV_SGXDEV_INFO *) gpsSGXDevNode->pvDevice)->
+	OSReadHWReg(((struct PVRSRV_SGXDEV_INFO *)gpsSGXDevNode->pvDevice)->
 		    pvRegsBaseKM, EUR_CR_EVENT_HOST_CLEAR);
 }
 
-PVRSRV_ERROR SysSystemPrePowerState(PVR_POWER_STATE eNewPowerState)
+enum PVRSRV_ERROR SysSystemPrePowerState(enum PVR_POWER_STATE eNewPowerState)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
 	if (eNewPowerState == PVRSRV_POWER_STATE_D3) {
-		PVR_TRACE(("SysSystemPrePowerState: Entering state D3"));
+		PVR_TRACE("SysSystemPrePowerState: Entering state D3");
 
 		if (SYS_SPECIFIC_DATA_TEST
 		    (&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR)) {
 			eError = OSUninstallDeviceLISR(gpsSysData);
 			if (eError != PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "SysSystemPrePowerState: OSUninstallDeviceLISR failed (%d)",
-					 eError));
+				PVR_DPF(PVR_DBG_ERROR,
+					"SysSystemPrePowerState: "
+					"OSUninstallDeviceLISR failed (%d)",
+					 eError);
 				return eError;
 			}
 			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData,
-					      SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
+					SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
 			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData,
-						SYS_SPECIFIC_DATA_ENABLE_LISR);
+					SYS_SPECIFIC_DATA_ENABLE_LISR);
 		}
 
 		if (SYS_SPECIFIC_DATA_TEST
@@ -576,36 +560,37 @@
 			DisableSystemClocks(gpsSysData);
 
 			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData,
-					      SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
+				SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
 			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData,
-						SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+				SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
 		}
 	}
 
 	return eError;
 }
 
-PVRSRV_ERROR SysSystemPostPowerState(PVR_POWER_STATE eNewPowerState)
+enum PVRSRV_ERROR SysSystemPostPowerState(enum PVR_POWER_STATE eNewPowerState)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
 	if (eNewPowerState == PVRSRV_POWER_STATE_D0) {
-		PVR_TRACE(("SysSystemPostPowerState: Entering state D0"));
+		PVR_TRACE("SysSystemPostPowerState: Entering state D0");
 
 		if (SYS_SPECIFIC_DATA_TEST
 		    (&gsSysSpecificData,
 		     SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS)) {
 			eError = EnableSystemClocks(gpsSysData);
 			if (eError != PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "SysSystemPostPowerState: EnableSystemClocks failed (%d)",
-					 eError));
+				PVR_DPF(PVR_DBG_ERROR,
+					 "SysSystemPostPowerState: "
+					 "EnableSystemClocks failed (%d)",
+					 eError);
 				return eError;
 			}
 			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData,
-					      SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+					SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
 			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData,
-						SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
+					SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS);
 		}
 		if (SYS_SPECIFIC_DATA_TEST
 		    (&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR)) {
@@ -614,59 +599,58 @@
 						gsSGXDeviceMap.ui32IRQ,
 						"SGX ISR", gpsSGXDevNode);
 			if (eError != PVRSRV_OK) {
-				PVR_DPF((PVR_DBG_ERROR,
-					 "SysSystemPostPowerState: OSInstallDeviceLISR failed to install ISR (%d)",
-					 eError));
+				PVR_DPF(PVR_DBG_ERROR,
+				"SysSystemPostPowerState: "
+				 "OSInstallDeviceLISR failed to "
+				 "install ISR (%d)", eError);
 				return eError;
 			}
 			SYS_SPECIFIC_DATA_SET(&gsSysSpecificData,
-					      SYS_SPECIFIC_DATA_ENABLE_LISR);
+				SYS_SPECIFIC_DATA_ENABLE_LISR);
 			SYS_SPECIFIC_DATA_CLEAR(&gsSysSpecificData,
-						SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
+				SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR);
 		}
 	}
 	return eError;
 }
 
-PVRSRV_ERROR SysDevicePrePowerState(IMG_UINT32 ui32DeviceIndex,
-				    PVR_POWER_STATE eNewPowerState,
-				    PVR_POWER_STATE eCurrentPowerState)
+enum PVRSRV_ERROR SysDevicePrePowerState(u32 ui32DeviceIndex,
+				    enum PVR_POWER_STATE eNewPowerState,
+				    enum PVR_POWER_STATE eCurrentPowerState)
 {
 	PVR_UNREFERENCED_PARAMETER(eCurrentPowerState);
 
-	if (ui32DeviceIndex != gui32SGXDeviceID) {
+	if (ui32DeviceIndex != gui32SGXDeviceID)
 		return PVRSRV_OK;
-	}
 	if (eNewPowerState == PVRSRV_POWER_STATE_D3) {
-		PVR_TRACE(("SysDevicePrePowerState: SGX Entering state D3"));
+		PVR_TRACE("SysDevicePrePowerState: SGX Entering state D3");
 		DisableSGXClocks(gpsSysData);
 	}
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR SysDevicePostPowerState(IMG_UINT32 ui32DeviceIndex,
-				     PVR_POWER_STATE eNewPowerState,
-				     PVR_POWER_STATE eCurrentPowerState)
+enum PVRSRV_ERROR SysDevicePostPowerState(u32 ui32DeviceIndex,
+				     enum PVR_POWER_STATE eNewPowerState,
+				     enum PVR_POWER_STATE eCurrentPowerState)
 {
-	PVRSRV_ERROR eError = PVRSRV_OK;
+	enum PVRSRV_ERROR eError = PVRSRV_OK;
 
 	PVR_UNREFERENCED_PARAMETER(eNewPowerState);
 
-	if (ui32DeviceIndex != gui32SGXDeviceID) {
+	if (ui32DeviceIndex != gui32SGXDeviceID)
 		return eError;
-	}
 	if (eCurrentPowerState == PVRSRV_POWER_STATE_D3) {
-		PVR_TRACE(("SysDevicePostPowerState: SGX Leaving state D3"));
+		PVR_TRACE("SysDevicePostPowerState: SGX Leaving state D3");
 		eError = EnableSGXClocks(gpsSysData);
 	}
 
 	return eError;
 }
 
-PVRSRV_ERROR SysOEMFunction(IMG_UINT32 ui32ID,
-			    IMG_VOID * pvIn,
-			    IMG_UINT32 ulInSize,
-			    IMG_VOID * pvOut, IMG_UINT32 ulOutSize)
+enum PVRSRV_ERROR SysOEMFunction(u32 ui32ID,
+			    void *pvIn,
+			    u32 ulInSize,
+			    void *pvOut, u32 ulOutSize)
 {
 	PVR_UNREFERENCED_PARAMETER(ui32ID);
 	PVR_UNREFERENCED_PARAMETER(pvIn);
@@ -675,10 +659,10 @@
 	PVR_UNREFERENCED_PARAMETER(ulOutSize);
 
 	if ((ui32ID == OEM_GET_EXT_FUNCS) &&
-	    (ulOutSize == sizeof(PVRSRV_DC_OEM_JTABLE))) {
+	    (ulOutSize == sizeof(struct PVRSRV_DC_OEM_JTABLE))) {
 
-		PVRSRV_DC_OEM_JTABLE *psOEMJTable =
-		    (PVRSRV_DC_OEM_JTABLE *) pvOut;
+		struct PVRSRV_DC_OEM_JTABLE *psOEMJTable =
+		    (struct PVRSRV_DC_OEM_JTABLE *)pvOut;
 		psOEMJTable->pfnOEMBridgeDispatch = &PVRSRV_BridgeDispatchKM;
 		return PVRSRV_OK;
 	}
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sysconfig.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sysconfig.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -29,25 +29,25 @@
 
 #include "syscommon.h"
 
-#define VS_PRODUCT_NAME	"OMAP3430"
+#define VS_PRODUCT_NAME				"OMAP3430"
 
-#define SYS_SGX_CLOCK_SPEED	110666666
+#define SYS_SGX_CLOCK_SPEED			110666666
 #define SYS_SGX_HWRECOVERY_TIMEOUT_FREQ		(100)
 #define SYS_SGX_PDS_TIMER_FREQ			(1000)
 #define SYS_SGX_ACTIVE_POWER_LATENCY_MS		(100)
 
-#define	SYS_OMAP3430_VDD2_OPP3_SGX_CLOCK_SPEED SYS_SGX_CLOCK_SPEED
-#define SYS_OMAP3430_VDD2_OPP2_SGX_CLOCK_SPEED (SYS_SGX_CLOCK_SPEED / 2)
+#define	SYS_OMAP3430_VDD2_OPP3_SGX_CLOCK_SPEED	SYS_SGX_CLOCK_SPEED
+#define SYS_OMAP3430_VDD2_OPP2_SGX_CLOCK_SPEED	(SYS_SGX_CLOCK_SPEED / 2)
 
-#define SYS_OMAP3430_SGX_REGS_SYS_PHYS_BASE  0x50000000
-#define SYS_OMAP3430_SGX_REGS_SIZE           0x4000
+#define SYS_OMAP3430_SGX_REGS_SYS_PHYS_BASE	0x50000000
+#define SYS_OMAP3430_SGX_REGS_SIZE		0x4000
 
-#define SYS_OMAP3430_SGX_IRQ				 21
+#define SYS_OMAP3430_SGX_IRQ			 21
 
-#define SYS_OMAP3430_GP11TIMER_PHYS_BASE		0x48088000
-#define SYS_OMAP3430_GPTIMER_ENABLE			0x24
-#define SYS_OMAP3430_GPTIMER_REGS			0x28
-#define SYS_OMAP3430_GPTIMER_TSICR			0x40
-#define SYS_OMAP3430_GPTIMER_SIZE			1024
+#define SYS_OMAP3430_GP11TIMER_PHYS_BASE	0x48088000
+#define SYS_OMAP3430_GPTIMER_ENABLE		0x24
+#define SYS_OMAP3430_GPTIMER_REGS		0x28
+#define SYS_OMAP3430_GPTIMER_TSICR		0x40
+#define SYS_OMAP3430_GPTIMER_SIZE		1024
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sysinfo.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sysinfo.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -30,66 +30,66 @@
 #define MAX_HW_TIME_US				(500000)
 #define WAIT_TRY_COUNT				(10000)
 
-typedef enum _SYS_DEVICE_TYPE_ {
+enum SYS_DEVICE_TYPE {
 	SYS_DEVICE_SGX = 0,
 
 	SYS_DEVICE_FORCE_I16 = 0x7fff
-} SYS_DEVICE_TYPE;
+};
 
 #define SYS_DEVICE_COUNT 3
 
-#define PRM_REG32(offset)	  (offset)
-#define CM_REG32(offset)	  (offset)
+#define PRM_REG32(offset)			(offset)
+#define CM_REG32(offset)			(offset)
 
-#define CM_FCLKEN_SGX		CM_REG32(0xB00)
-#define		CM_FCLKEN_SGX_EN_3D					0x00000002
+#define CM_FCLKEN_SGX				CM_REG32(0xB00)
+#define	CM_FCLKEN_SGX_EN_3D			0x00000002
 
-#define CM_ICLKEN_SGX		CM_REG32(0xB10)
-#define		CM_ICLKEN_SGX_EN_SGX				0x00000001
+#define CM_ICLKEN_SGX				CM_REG32(0xB10)
+#define	CM_ICLKEN_SGX_EN_SGX			0x00000001
 
-#define CM_IDLEST_SGX		CM_REG32(0xB20)
-#define		CM_IDLEST_SGX_ST_SGX				0x00000001
-
-#define CM_CLKSEL_SGX		CM_REG32(0xB40)
-#define		CM_CLKSEL_SGX_MASK					0x0000000f
-#define		CM_CLKSEL_SGX_L3DIV3				0x00000000
-#define		CM_CLKSEL_SGX_L3DIV4				0x00000001
-#define		CM_CLKSEL_SGX_L3DIV6				0x00000002
-#define		CM_CLKSEL_SGX_96M					0x00000003
-
-#define CM_SLEEPDEP_SGX		CM_REG32(0xB44)
-#define CM_CLKSTCTRL_SGX	CM_REG32(0xB48)
-#define 	CM_CLKSTCTRL_SGX_AUTOSTATE			0x00008001
-
-#define CM_CLKSTST_SGX		CM_REG32(0xB4C)
-#define 	CM_CLKSTST_SGX_STATUS_VALID			0x00000001
-
-#define RM_RSTST_SGX		PRM_REG32(0xB58)
-#define 	RM_RSTST_SGX_RST_MASK				0x0000000F
-#define 	RM_RSTST_SGX_COREDOMAINWKUP_RST		0x00000008
-#define 	RM_RSTST_SGX_DOMAINWKUP_RST			0x00000004
-#define 	RM_RSTST_SGX_GLOBALWARM_RST			0x00000002
-#define 	RM_RSTST_SGX_GLOBALCOLD_RST			0x00000001
-
-#define PM_WKDEP_SGX		PRM_REG32(0xBC8)
-#define 	PM_WKDEP_SGX_EN_WAKEUP				0x00000010
-#define 	PM_WKDEP_SGX_EN_MPU					0x00000002
-#define 	PM_WKDEP_SGX_EN_CORE				0x00000001
-
-#define PM_PWSTCTRL_SGX		PRM_REG32(0xBE0)
-#define		PM_PWSTCTRL_SGX_POWERSTATE_MASK		0x00000003
-#define			PM_PWSTCTRL_SGX_OFF				0x00000000
-#define			PM_PWSTCTRL_SGX_RETENTION		0x00000001
-#define			PM_PWSTCTRL_SGX_ON				0x00000003
-
-#define PM_PWSTST_SGX		PRM_REG32(0xBE4)
-#define		PM_PWSTST_SGX_INTRANSITION			0x00100000
-#define		PM_PWSTST_SGX_CLKACTIVITY			0x00080000
-#define		PM_PWSTST_SGX_POWERSTATE_MASK		0x00000003
-#define			PM_PWSTST_SGX_OFF				0x00000003
-#define			PM_PWSTST_SGX_RETENTION			0x00000001
-#define			PM_PWSTST_SGX_ON				0x00000000
+#define CM_IDLEST_SGX				CM_REG32(0xB20)
+#define	CM_IDLEST_SGX_ST_SGX			0x00000001
+
+#define CM_CLKSEL_SGX				CM_REG32(0xB40)
+#define	CM_CLKSEL_SGX_MASK			0x0000000f
+#define	CM_CLKSEL_SGX_L3DIV3			0x00000000
+#define	CM_CLKSEL_SGX_L3DIV4			0x00000001
+#define	CM_CLKSEL_SGX_L3DIV6			0x00000002
+#define	CM_CLKSEL_SGX_96M			0x00000003
+
+#define CM_SLEEPDEP_SGX				CM_REG32(0xB44)
+#define CM_CLKSTCTRL_SGX			CM_REG32(0xB48)
+#define CM_CLKSTCTRL_SGX_AUTOSTATE		0x00008001
+
+#define CM_CLKSTST_SGX				CM_REG32(0xB4C)
+#define CM_CLKSTST_SGX_STATUS_VALID		0x00000001
+
+#define RM_RSTST_SGX				PRM_REG32(0xB58)
+#define RM_RSTST_SGX_RST_MASK			0x0000000F
+#define RM_RSTST_SGX_COREDOMAINWKUP_RST		0x00000008
+#define RM_RSTST_SGX_DOMAINWKUP_RST		0x00000004
+#define RM_RSTST_SGX_GLOBALWARM_RST		0x00000002
+#define RM_RSTST_SGX_GLOBALCOLD_RST		0x00000001
+
+#define PM_WKDEP_SGX				PRM_REG32(0xBC8)
+#define PM_WKDEP_SGX_EN_WAKEUP			0x00000010
+#define PM_WKDEP_SGX_EN_MPU			0x00000002
+#define PM_WKDEP_SGX_EN_CORE			0x00000001
+
+#define PM_PWSTCTRL_SGX				PRM_REG32(0xBE0)
+#define	PM_PWSTCTRL_SGX_POWERSTATE_MASK		0x00000003
+#define	PM_PWSTCTRL_SGX_OFF			0x00000000
+#define	PM_PWSTCTRL_SGX_RETENTION		0x00000001
+#define	PM_PWSTCTRL_SGX_ON			0x00000003
+
+#define PM_PWSTST_SGX				PRM_REG32(0xBE4)
+#define	PM_PWSTST_SGX_INTRANSITION		0x00100000
+#define	PM_PWSTST_SGX_CLKACTIVITY		0x00080000
+#define	PM_PWSTST_SGX_POWERSTATE_MASK		0x00000003
+#define	PM_PWSTST_SGX_OFF			0x00000003
+#define	PM_PWSTST_SGX_RETENTION			0x00000001
+#define	PM_PWSTST_SGX_ON			0x00000000
 
-#define PM_PREPWSTST_SGX	PRM_REG32(0xBE8)
+#define PM_PREPWSTST_SGX			PRM_REG32(0xBE8)
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/syslocal.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/syslocal.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -30,18 +30,17 @@
 #include <linux/version.h>
 #include <linux/clk.h>
 #include <linux/semaphore.h>
-/*#include <asm/arch/resource.h>*/
 
 
-	IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion);
+char *SysCreateVersionString(struct IMG_CPU_PHYADDR sRegRegion);
 
-	PVRSRV_ERROR InitSystemClocks(SYS_DATA * psSysData);
-	IMG_VOID CleanupSystemClocks(SYS_DATA * psSysData);
-	IMG_VOID DisableSystemClocks(SYS_DATA * psSysData);
-	PVRSRV_ERROR EnableSystemClocks(SYS_DATA * psSysData);
+enum PVRSRV_ERROR InitSystemClocks(struct SYS_DATA *psSysData);
+void CleanupSystemClocks(struct SYS_DATA *psSysData);
+void DisableSystemClocks(struct SYS_DATA *psSysData);
+enum PVRSRV_ERROR EnableSystemClocks(struct SYS_DATA *psSysData);
 
-	IMG_VOID DisableSGXClocks(SYS_DATA * psSysData);
-	PVRSRV_ERROR EnableSGXClocks(SYS_DATA * psSysData);
+void DisableSGXClocks(struct SYS_DATA *psSysData);
+enum PVRSRV_ERROR EnableSGXClocks(struct SYS_DATA *psSysData);
 
 #define SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS	0x00000001
 #define SYS_SPECIFIC_DATA_ENABLE_LISR		0x00000002
@@ -56,29 +55,32 @@
 #define	SYS_SPECIFIC_DATA_PM_UNINSTALL_LISR	0x00000200
 #define	SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS	0x00000400
 
-#define	SYS_SPECIFIC_DATA_SET(psSysSpecData, flag) ((void)((psSysSpecData)->ui32SysSpecificData |= (flag)))
+#define	SYS_SPECIFIC_DATA_SET(psSysSpecData, flag) \
+		((void)((psSysSpecData)->ui32SysSpecificData |= (flag)))
 
-#define	SYS_SPECIFIC_DATA_CLEAR(psSysSpecData, flag) ((void)((psSysSpecData)->ui32SysSpecificData &= ~(flag)))
+#define	SYS_SPECIFIC_DATA_CLEAR(psSysSpecData, flag) \
+		((void)((psSysSpecData)->ui32SysSpecificData &= ~(flag)))
 
-#define	SYS_SPECIFIC_DATA_TEST(psSysSpecData, flag) (((psSysSpecData)->ui32SysSpecificData & (flag)) != 0)
+#define	SYS_SPECIFIC_DATA_TEST(psSysSpecData, flag) \
+		(((psSysSpecData)->ui32SysSpecificData & (flag)) != 0)
 
-	typedef struct _SYS_SPECIFIC_DATA_TAG_ {
-		IMG_UINT32 ui32SysSpecificData;
-		PVRSRV_DEVICE_NODE *psSGXDevNode;
-		IMG_BOOL bSGXInitComplete;
-		IMG_BOOL bSGXClocksEnabled;
-		struct clk *psCORE_CK;
-		struct clk *psSGX_FCK;
-		struct clk *psSGX_ICK;
-		struct clk *psMPU_CK;
+struct SYS_SPECIFIC_DATA {
+	u32 ui32SysSpecificData;
+	struct PVRSRV_DEVICE_NODE *psSGXDevNode;
+	IMG_BOOL bSGXInitComplete;
+	IMG_BOOL bSGXClocksEnabled;
+	struct clk *psCORE_CK;
+	struct clk *psSGX_FCK;
+	struct clk *psSGX_ICK;
+	struct clk *psMPU_CK;
 #if defined(DEBUG) || defined(TIMING)
-		struct clk *psGPT11_FCK;
-		struct clk *psGPT11_ICK;
-		void __iomem *gpt_base;
+	struct clk *psGPT11_FCK;
+	struct clk *psGPT11_ICK;
+	void __iomem *gpt_base;
 #endif
-		struct constraint_handle *pVdd2Handle;
-	} SYS_SPECIFIC_DATA;
+	struct constraint_handle *pVdd2Handle;
+};
 
-	extern SYS_SPECIFIC_DATA *gpsSysSpecificData;
+extern struct SYS_SPECIFIC_DATA *gpsSysSpecificData;
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/sysutils_linux.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/sysutils_linux.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -29,7 +29,7 @@
 #include <linux/err.h>
 #include <linux/hardirq.h>
 #include <mach/omap-pm.h>
-#include <asm/bug.h>
+#include <linux/bug.h>
 #include <mach/clock.h>
 
 #include "sgxdefs.h"
@@ -47,9 +47,8 @@
 					  unsigned long rate1,
 					  unsigned long rate2)
 {
-	if (rate1 >= rate2) {
+	if (rate1 >= rate2)
 		return val * (rate1 / rate2);
-	}
 
 	return val / (rate2 / rate1);
 }
@@ -66,7 +65,7 @@
 	return scale_by_rate(val, SYS_SGX_CLOCK_SPEED, rate);
 }
 
-IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION * psTimingInfo)
+void SysGetSGXTimingInformation(struct SGX_TIMING_INFORMATION *psTimingInfo)
 {
 	unsigned long rate;
 
@@ -91,8 +90,8 @@
 	PVR_UNREFERENCED_PARAMETER(event);
 	PVR_UNREFERENCED_PARAMETER(ptr);
 
-	if (gpsSysSpecificData->bSGXClocksEnabled
-	    && gpsSysSpecificData->bSGXInitComplete) {
+	if (gpsSysSpecificData->bSGXClocksEnabled &&
+	    gpsSysSpecificData->bSGXInitComplete) {
 #if defined(DEBUG)
 		unsigned long rate;
 
@@ -100,13 +99,13 @@
 
 		PVR_ASSERT(rate != 0);
 
-		PVR_TRACE(("%s: SGX clock rate: %dMHz", __FUNCTION__,
-			   HZ_TO_MHZ(rate)));
+		PVR_TRACE("%s: SGX clock rate: %dMHz", __func__,
+			   HZ_TO_MHZ(rate));
 #endif
 		PVRSRVDevicePostClockSpeedChange(gpsSysSpecificData->
 						 psSGXDevNode->sDevId.
 						 ui32DeviceIndex, IMG_TRUE,
-						 IMG_NULL);
+						 NULL);
 	}
 	return 0;
 }
@@ -124,7 +123,7 @@
 		PVRSRVDevicePreClockSpeedChange(gpsSysSpecificData->
 						psSGXDevNode->sDevId.
 						ui32DeviceIndex, IMG_TRUE,
-						IMG_NULL);
+						NULL);
 	}
 
 	return 0;
@@ -139,26 +138,27 @@
 
 	cnd = (struct clk_notifier_data *)ptr;
 
-	PVR_TRACE(("vdd2_pre_post_func: old clock rate = %lu", cnd->old_rate));
-	PVR_TRACE(("vdd2_pre_post_func: new clock rate = %lu", cnd->new_rate));
+	PVR_TRACE("vdd2_pre_post_func: old clock rate = %lu", cnd->old_rate);
+	PVR_TRACE("vdd2_pre_post_func: new clock rate = %lu", cnd->new_rate);
 
 	if (CLK_PRE_RATE_CHANGE == event) {
 		PVRSRVDvfsLock();
-		PVR_TRACE(("vdd2_pre_post_func: CLK_PRE_RATE_CHANGE event"));
+		PVR_TRACE("vdd2_pre_post_func: CLK_PRE_RATE_CHANGE event");
 		vdd2_pre_func(n, event, ptr);
 	} else if (CLK_POST_RATE_CHANGE == event) {
-		PVR_TRACE(("vdd2_pre_post_func: CLK_POST_RATE_CHANGE event"));
+		PVR_TRACE("vdd2_pre_post_func: CLK_POST_RATE_CHANGE event");
 		vdd2_post_func(n, event, ptr);
 		PVRSRVDvfsUnlock();
 	} else if (CLK_ABORT_RATE_CHANGE == event) {
-		PVR_TRACE(("vdd2_pre_post_func: CLK_ABORT_RATE_CHANGE event"));
+		PVR_TRACE("vdd2_pre_post_func: CLK_ABORT_RATE_CHANGE event");
 		PVRSRVDvfsUnlock();
 	} else {
-		printk("vdd2_pre_post_func: unexpected event (%lu)\n", event);
-		PVR_DPF((PVR_DBG_ERROR,
-			 "vdd2_pre_post_func: unexpected event (%lu)", event));
+		printk(KERN_ERR "vdd2_pre_post_func: unexpected event (%lu)\n",
+			event);
+		PVR_DPF(PVR_DBG_ERROR,
+			 "vdd2_pre_post_func: unexpected event (%lu)", event);
 	}
-	PVR_TRACE(("vdd2_pre_post_func end."));
+	PVR_TRACE("vdd2_pre_post_func end.");
 	return 0;
 }
 
@@ -167,19 +167,19 @@
 	NULL
 };
 
-static IMG_VOID RegisterConstraintNotifications(SYS_SPECIFIC_DATA *
-						psSysSpecData)
+static void RegisterConstraintNotifications(
+					struct SYS_SPECIFIC_DATA *psSysSpecData)
 {
-	PVR_TRACE(("Registering constraint notifications"));
+	PVR_TRACE("Registering constraint notifications");
 
 	clk_notifier_register(psSysSpecData->psSGX_FCK, &vdd2_pre_post);
-	PVR_TRACE(("VDD2 constraint notifications registered"));
+	PVR_TRACE("VDD2 constraint notifications registered");
 }
 
-static IMG_VOID UnRegisterConstraintNotifications(SYS_SPECIFIC_DATA *
-						  psSysSpecData)
+static void UnRegisterConstraintNotifications(
+					struct SYS_SPECIFIC_DATA *psSysSpecData)
 {
-	PVR_TRACE(("Unregistering constraint notifications"));
+	PVR_TRACE("Unregistering constraint notifications");
 
 	clk_notifier_unregister(psSysSpecData->psSGX_FCK, &vdd2_pre_post);
 }
@@ -193,25 +193,26 @@
  */
 static unsigned int sgx_current_load(void)
 {
-	PVRSRV_ERROR eError;
-	SYS_DATA *psSysData;
-	SYS_SPECIFIC_DATA *psSysSpecData;
-	PVRSRV_DEVICE_NODE *psDeviceNode;
+	enum PVRSRV_ERROR eError;
+	struct SYS_DATA *psSysData;
+	struct SYS_SPECIFIC_DATA *psSysSpecData;
+	struct PVRSRV_DEVICE_NODE *psDeviceNode;
 	static unsigned int kicks_prev;
 	static long time_prev;
 
 	eError = SysAcquireData(&psSysData);
 	if (eError != PVRSRV_OK)
 		return 0;
-	psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	psSysSpecData = (struct SYS_SPECIFIC_DATA *)
+						psSysData->pvSysSpecificData;
 	if ((!psSysSpecData) || (!psSysSpecData->bSGXClocksEnabled))
 		return 0;
 	psDeviceNode = psSysData->psDeviceNodeList;
 	while (psDeviceNode) {
 		if ((psDeviceNode->sDevId.eDeviceType == PVRSRV_DEVICE_TYPE_SGX)
 		    && (psDeviceNode->pvDevice)) {
-			PVRSRV_SGXDEV_INFO *psDevInfo =
-			    (PVRSRV_SGXDEV_INFO *) psDeviceNode->pvDevice;
+			struct PVRSRV_SGXDEV_INFO *psDevInfo =
+			    (struct PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
 			unsigned int kicks = psDevInfo->ui32KickTACounter;
 			unsigned int load;
 			long time_elapsed;
@@ -224,17 +225,20 @@
 				load = 0;
 			kicks_prev = kicks;
 			time_prev += time_elapsed;
-			/* if the period between calls to this function was too long,
-			 * then load stats are invalid
+			/*
+			 * if the period between calls to this function was
+			 * too long then load stats are invalid.
 			 */
 			if (time_elapsed > 5 * HZ)
 				return 0;
 			/*pr_err("SGX load %u\n", load); */
 
-			/* 'load' shows how many times sgx was kicked per 1000 jiffies
-			 * 150 is arbitrarily chosen threshold.
-			 * If the number of kicks is below threshold then sgx is doing
-			 * some small jobs and we can keep the clock freq low.
+			/*
+			 * 'load' shows how many times sgx was kicked per
+			 * 1000 jiffies 150 is arbitrarily chosen threshold.
+			 * If the number of kicks is below threshold then sgx
+			 * is doing some small jobs and we can keep the clocki
+			 * freq low.
 			 */
 			if (load < 150)
 				return 0;
@@ -253,8 +257,9 @@
 	int high;
 	unsigned int load;
 	struct delayed_work *d_work =
-	    container_of(work, struct delayed_work, work);
-	ENV_DATA *psEnvData = container_of(d_work, ENV_DATA, sPerfWork);
+			container_of(work, struct delayed_work, work);
+	struct ENV_DATA *psEnvData =
+			container_of(d_work, struct ENV_DATA, sPerfWork);
 
 	load = sgx_current_load();
 	if (load) {
@@ -276,9 +281,10 @@
 				   &psEnvData->sPerfWork, HZ / 5);
 }
 
-static void sgx_need_perf(SYS_DATA * psSysData, int ena)
+static void sgx_need_perf(struct SYS_DATA *psSysData, int ena)
 {
-	ENV_DATA *psEnvData = (ENV_DATA *) psSysData->pvEnvSpecificData;
+	struct ENV_DATA *psEnvData = (struct ENV_DATA *)
+					psSysData->pvEnvSpecificData;
 
 	sgx_clock_enabled = ena;
 	cancel_delayed_work(&psEnvData->sPerfWork);
@@ -286,17 +292,18 @@
 			   0);
 }
 
-PVRSRV_ERROR OSInitPerf(IMG_VOID * pvSysData)
+enum PVRSRV_ERROR OSInitPerf(void *pvSysData)
 {
-	SYS_DATA *psSysData = (SYS_DATA *) pvSysData;
-	ENV_DATA *psEnvData = (ENV_DATA *) psSysData->pvEnvSpecificData;
+	struct SYS_DATA *psSysData = (struct SYS_DATA *)pvSysData;
+	struct ENV_DATA *psEnvData = (struct ENV_DATA *)
+						psSysData->pvEnvSpecificData;
 
 	if (psEnvData->psPerfWorkqueue) {
-		PVR_DPF((PVR_DBG_ERROR, "OSInitPerf: already inited"));
+		PVR_DPF(PVR_DBG_ERROR, "OSInitPerf: already inited");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
-	PVR_TRACE(("Initing DVFS %x", pvSysData));
+	PVR_TRACE("Initing DVFS %x", pvSysData);
 
 	psEnvData->psPerfWorkqueue = create_singlethread_workqueue("sgx_perf");
 	INIT_DELAYED_WORK(&psEnvData->sPerfWork, sgx_lock_perf);
@@ -304,17 +311,18 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR OSCleanupPerf(IMG_VOID * pvSysData)
+enum PVRSRV_ERROR OSCleanupPerf(void *pvSysData)
 {
-	SYS_DATA *psSysData = (SYS_DATA *) pvSysData;
-	ENV_DATA *psEnvData = (ENV_DATA *) psSysData->pvEnvSpecificData;
+	struct SYS_DATA *psSysData = (struct SYS_DATA *)pvSysData;
+	struct ENV_DATA *psEnvData = (struct ENV_DATA *)
+						psSysData->pvEnvSpecificData;
 
 	if (!psEnvData->psPerfWorkqueue) {
-		PVR_DPF((PVR_DBG_ERROR, "OSCleanupPerf: not inited"));
+		PVR_DPF(PVR_DBG_ERROR, "OSCleanupPerf: not inited");
 		return PVRSRV_ERROR_GENERIC;
 	}
 
-	PVR_TRACE(("Cleaning up DVFS"));
+	PVR_TRACE("Cleaning up DVFS");
 
 	flush_workqueue(psEnvData->psPerfWorkqueue);
 	destroy_workqueue(psEnvData->psPerfWorkqueue);
@@ -322,39 +330,36 @@
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR EnableSGXClocks(SYS_DATA * psSysData)
+enum PVRSRV_ERROR EnableSGXClocks(struct SYS_DATA *psSysData)
 {
-	SYS_SPECIFIC_DATA *psSysSpecData =
-	    (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	struct SYS_SPECIFIC_DATA *psSysSpecData =
+	    (struct SYS_SPECIFIC_DATA *)psSysData->pvSysSpecificData;
 #if defined(DEBUG)
 	unsigned long rate;
 #endif
 	int res;
 
-	if (psSysSpecData->bSGXClocksEnabled) {
+	if (psSysSpecData->bSGXClocksEnabled)
 		return PVRSRV_OK;
-	}
 
-	PVR_TRACE(("EnableSGXClocks: Enabling SGX Clocks"));
+	PVR_TRACE("EnableSGXClocks: Enabling SGX Clocks");
 
 #if defined(DEBUG)
 	rate = clk_get_rate(psSysSpecData->psMPU_CK);
-	PVR_TRACE(("CPU Clock is %dMhz", HZ_TO_MHZ(rate)));
+	PVR_TRACE("CPU Clock is %dMhz", HZ_TO_MHZ(rate));
 #endif
 
 	res = clk_enable(psSysSpecData->psSGX_FCK);
 	if (res < 0) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "EnableSGXClocks: Couldn't enable SGX functional clock (%d)",
-			 res));
+		PVR_DPF(PVR_DBG_ERROR, "EnableSGXClocks: "
+			"Couldn't enable SGX functional clock (%d)", res);
 		return PVRSRV_ERROR_GENERIC;
 	}
 
 	res = clk_enable(psSysSpecData->psSGX_ICK);
 	if (res < 0) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "EnableSGXClocks: Couldn't enable SGX interface clock (%d)",
-			 res));
+		PVR_DPF(PVR_DBG_ERROR, "EnableSGXClocks: "
+			"Couldn't enable SGX interface clock (%d)", res);
 
 		clk_disable(psSysSpecData->psSGX_FCK);
 		return PVRSRV_ERROR_GENERIC;
@@ -365,32 +370,29 @@
 	return PVRSRV_OK;
 }
 
-IMG_VOID DisableSGXClocks(SYS_DATA * psSysData)
+void DisableSGXClocks(struct SYS_DATA *psSysData)
 {
-	SYS_SPECIFIC_DATA *psSysSpecData =
-	    (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	struct SYS_SPECIFIC_DATA *psSysSpecData =
+	    (struct SYS_SPECIFIC_DATA *)psSysData->pvSysSpecificData;
 
-	if (!psSysSpecData->bSGXClocksEnabled) {
+	if (!psSysSpecData->bSGXClocksEnabled)
 		return;
-	}
 
-	PVR_TRACE(("DisableSGXClocks: Disabling SGX Clocks"));
+	PVR_TRACE("DisableSGXClocks: Disabling SGX Clocks");
 
-	if (psSysSpecData->psSGX_ICK) {
+	if (psSysSpecData->psSGX_ICK)
 		clk_disable(psSysSpecData->psSGX_ICK);
-	}
 
-	if (psSysSpecData->psSGX_FCK) {
+	if (psSysSpecData->psSGX_FCK)
 		clk_disable(psSysSpecData->psSGX_FCK);
-	}
 
 	psSysSpecData->bSGXClocksEnabled = IMG_FALSE;
 	sgx_need_perf(psSysData, 0);
 }
 
-static PVRSRV_ERROR InitSgxClocks(SYS_DATA * psSysData)
+static enum PVRSRV_ERROR InitSgxClocks(struct SYS_DATA *psSysData)
 {
-	SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
+	struct SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
 	struct clk *psCLK;
 	struct clk *core_ck = NULL;
 
@@ -422,18 +424,18 @@
 err1:
 	clk_put(psSysSpecData->psSGX_FCK);
 err0:
-	PVR_DPF((PVR_DBG_ERROR,
+	PVR_DPF(PVR_DBG_ERROR,
 		 "%s: couldn't init clocks fck %p ick %p core %p", __func__,
-		 psSysSpecData->psSGX_FCK, psSysSpecData->psSGX_ICK, core_ck));
+		 psSysSpecData->psSGX_FCK, psSysSpecData->psSGX_ICK, core_ck);
 	psSysSpecData->psSGX_FCK = NULL;
 	psSysSpecData->psSGX_ICK = NULL;
 
 	return PVRSRV_ERROR_GENERIC;
 }
 
-static void CleanupSgxClocks(SYS_DATA * psSysData)
+static void CleanupSgxClocks(struct SYS_DATA *psSysData)
 {
-	SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
+	struct SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
 
 	UnRegisterConstraintNotifications(psSysSpecData);
 
@@ -449,23 +451,23 @@
 }
 
 #if defined(DEBUG) || defined(TIMING)
-static u32 inline gpt_read_reg(SYS_DATA * psSysData, u32 reg)
+static inline u32 gpt_read_reg(struct SYS_DATA *psSysData, u32 reg)
 {
-	SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
+	struct SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
 
 	return __raw_readl(psSysSpecData->gpt_base + reg);
 }
 
-static void inline gpt_write_reg(SYS_DATA * psSysData, u32 reg, u32 val)
+static inline void gpt_write_reg(struct SYS_DATA *psSysData, u32 reg, u32 val)
 {
-	SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
+	struct SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
 
 	__raw_writel(val, psSysSpecData->gpt_base + reg);
 }
 
-static PVRSRV_ERROR InitDebugClocks(SYS_DATA * psSysData)
+static enum PVRSRV_ERROR InitDebugClocks(struct SYS_DATA *psSysData)
 {
-	SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
+	struct SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
 	struct clk *psCLK;
 	struct clk *sys_ck = NULL;
 	u32 rate;
@@ -488,16 +490,15 @@
 	sys_ck = clk_get(NULL, "sys_ck");
 	if (IS_ERR(sys_ck))
 		goto err3;
-	if (clk_get_parent(psSysSpecData->psGPT11_FCK) != sys_ck) {
+	if (clk_get_parent(psSysSpecData->psGPT11_FCK) != sys_ck)
 		if (clk_set_parent(psSysSpecData->psGPT11_FCK, sys_ck) < 0) {
 			clk_put(sys_ck);
 			goto err3;
 		}
-	}
 	clk_put(sys_ck);
 
-	PVR_TRACE(("GPTIMER11 clock is %dMHz",
-		   HZ_TO_MHZ(clk_get_rate(psSysSpecData->psGPT11_FCK))));
+	PVR_TRACE("GPTIMER11 clock is %dMHz",
+		   HZ_TO_MHZ(clk_get_rate(psSysSpecData->psGPT11_FCK)));
 
 	psSysSpecData->gpt_base = ioremap(SYS_OMAP3430_GP11TIMER_PHYS_BASE,
 					  SYS_OMAP3430_GPTIMER_SIZE);
@@ -509,7 +510,8 @@
 
 	rate = gpt_read_reg(psSysData, SYS_OMAP3430_GPTIMER_TSICR);
 	if (!(rate & 4)) {
-		PVR_TRACE(("Setting GPTIMER11 mode to posted (currently is non-posted)"));
+		PVR_TRACE(
+		 "Setting GPTIMER11 mode to posted (currently is non-posted)");
 		gpt_write_reg(psSysData, SYS_OMAP3430_GPTIMER_TSICR, rate | 4);
 	}
 
@@ -525,10 +527,10 @@
 err1:
 	clk_put(psSysSpecData->psMPU_CK);
 err0:
-	PVR_DPF((PVR_DBG_ERROR,
+	PVR_DPF(PVR_DBG_ERROR,
 		 "%s: couldn't init clocks: mpu %p sys %p fck %p ick %p",
 		 __func__, psSysSpecData->psMPU_CK, sys_ck,
-		 psSysSpecData->psGPT11_FCK, psSysSpecData->psGPT11_ICK));
+		 psSysSpecData->psGPT11_FCK, psSysSpecData->psGPT11_ICK);
 
 	psSysSpecData->psMPU_CK = NULL;
 	psSysSpecData->psGPT11_FCK = NULL;
@@ -537,9 +539,9 @@
 	return PVRSRV_ERROR_GENERIC;
 }
 
-static void CleanupDebugClocks(SYS_DATA * psSysData)
+static void CleanupDebugClocks(struct SYS_DATA *psSysData)
 {
-	SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
+	struct SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
 
 	if (psSysSpecData->psMPU_CK) {
 		clk_put(psSysSpecData->psMPU_CK);
@@ -555,9 +557,9 @@
 	}
 }
 
-static PVRSRV_ERROR EnableDebugClocks(SYS_DATA * psSysData)
+static enum PVRSRV_ERROR EnableDebugClocks(struct SYS_DATA *psSysData)
 {
-	SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
+	struct SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
 
 	if (clk_enable(psSysSpecData->psGPT11_FCK) < 0)
 		goto err0;
@@ -572,14 +574,14 @@
 err1:
 	clk_disable(psSysSpecData->psGPT11_FCK);
 err0:
-	PVR_DPF((PVR_DBG_ERROR, "%s: can't enable clocks", __func__));
+	PVR_DPF(PVR_DBG_ERROR, "%s: can't enable clocks", __func__);
 
 	return PVRSRV_ERROR_GENERIC;
 }
 
-static inline void DisableDebugClocks(SYS_DATA * psSysData)
+static inline void DisableDebugClocks(struct SYS_DATA *psSysData)
 {
-	SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
+	struct SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
 
 	gpt_write_reg(psSysData, SYS_OMAP3430_GPTIMER_ENABLE, 0);
 
@@ -589,26 +591,26 @@
 
 #else
 
-PVRSRV_ERROR inline InitDebugClocks(SYS_DATA * psSysData)
+inline enum PVRSRV_ERROR InitDebugClocks(struct SYS_DATA *psSysData)
 {
 	return PVRSRV_OK;
 }
 
-static void inline CleanupDebugClocks(SYS_DATA * psSysData)
+static inline void CleanupDebugClocks(struct SYS_DATA *psSysData)
 {
 }
 
-static inline PVRSRV_ERROR EnableDebugClocks(SYS_DATA * psSysData)
+static inline enum PVRSRV_ERROR EnableDebugClocks(struct SYS_DATA *psSysData)
 {
 	return PVRSRV_OK;
 }
 
-static inline void DisableDebugClocks(SYS_DATA * psSysData)
+static inline void DisableDebugClocks(struct SYS_DATA *psSysData)
 {
 }
 #endif
 
-PVRSRV_ERROR InitSystemClocks(SYS_DATA * psSysData)
+enum PVRSRV_ERROR InitSystemClocks(struct SYS_DATA *psSysData)
 {
 	if (InitSgxClocks(psSysData) != PVRSRV_OK)
 		goto err0;
@@ -624,15 +626,15 @@
 	return PVRSRV_ERROR_GENERIC;
 }
 
-void CleanupSystemClocks(SYS_DATA * psSysData)
+void CleanupSystemClocks(struct SYS_DATA *psSysData)
 {
 	CleanupDebugClocks(psSysData);
 	CleanupSgxClocks(psSysData);
 }
 
-PVRSRV_ERROR EnableSystemClocks(SYS_DATA * psSysData)
+enum PVRSRV_ERROR EnableSystemClocks(struct SYS_DATA *psSysData)
 {
-	PVR_TRACE(("EnableSystemClocks: Enabling System Clocks"));
+	PVR_TRACE("EnableSystemClocks: Enabling System Clocks");
 
 
 	if (EnableDebugClocks(psSysData) != PVRSRV_OK)
@@ -644,9 +646,9 @@
 	return PVRSRV_ERROR_GENERIC;
 }
 
-IMG_VOID DisableSystemClocks(SYS_DATA * psSysData)
+void DisableSystemClocks(struct SYS_DATA *psSysData)
 {
-	PVR_TRACE(("DisableSystemClocks: Disabling System Clocks"));
+	PVR_TRACE("DisableSystemClocks: Disabling System Clocks");
 
 	DisableSGXClocks(psSysData);
 	DisableDebugClocks(psSysData);
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/tools/Makefile
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/tools/Makefile
@@ -1,25 +1,25 @@
 #
 # Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
-# 
+#
 # This program is free software; you can redistribute it and/or modify it
 # under the terms and conditions of the GNU General Public License,
 # version 2, as published by the Free Software Foundation.
-# 
-# This program is distributed in the hope it will be useful but, except 
-# as otherwise stated in writing, without any warranty; without even the 
-# implied warranty of merchantability or fitness for a particular purpose. 
+#
+# This program is distributed in the hope it will be useful but, except
+# as otherwise stated in writing, without any warranty; without even the
+# implied warranty of merchantability or fitness for a particular purpose.
 # See the GNU General Public License for more details.
-# 
+#
 # You should have received a copy of the GNU General Public License along with
 # this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
-# 
+#
 # The full GNU General Public License is included in this distribution in
 # the file called "COPYING".
 #
 # Contact Information:
 # Imagination Technologies Ltd. <gpl-support@imgtec.com>
-# Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+# Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
 
 
 objs-$(CONFIG_PVR_TOOLS)	+= dbgdrv
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/tools/dbgdriv.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/tools/dbgdriv.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -35,38 +35,35 @@
 
 #define LAST_FRAME_BUF_SIZE	1024
 
-typedef struct _DBG_LASTFRAME_BUFFER_ {
-	PDBG_STREAM psStream;
-	IMG_UINT8 ui8Buffer[LAST_FRAME_BUF_SIZE];
-	IMG_UINT32 ui32BufLen;
-	struct _DBG_LASTFRAME_BUFFER_ *psNext;
-} DBG_LASTFRAME_BUFFER, *PDBG_LASTFRAME_BUFFER;
-
-static PDBG_STREAM g_psStreamList = 0;
-static PDBG_LASTFRAME_BUFFER g_psLFBufferList;
-
-static IMG_UINT32 g_ui32LOff = 0;
-static IMG_UINT32 g_ui32Line = 0;
-static IMG_UINT32 g_ui32MonoLines = 25;
+struct DBG_LASTFRAME_BUFFER {
+	struct DBG_STREAM *psStream;
+	u8 ui8Buffer[LAST_FRAME_BUF_SIZE];
+	u32 ui32BufLen;
+	struct DBG_LASTFRAME_BUFFER *psNext;
+};
+
+static struct DBG_STREAM *g_psStreamList;
+static struct DBG_LASTFRAME_BUFFER *g_psLFBufferList;
 
-static IMG_BOOL g_bHotkeyMiddump = IMG_FALSE;
-static IMG_UINT32 g_ui32HotkeyMiddumpStart = 0xffffffff;
-static IMG_UINT32 g_ui32HotkeyMiddumpEnd = 0xffffffff;
+static u32 g_ui32LOff;
+static u32 g_ui32Line;
+static u32 g_ui32MonoLines = 25;
 
-IMG_VOID *g_pvAPIMutex = IMG_NULL;
+static IMG_BOOL g_bHotkeyMiddump = IMG_FALSE;
+static u32 g_ui32HotkeyMiddumpStart = 0xffffffff;
+static u32 g_ui32HotkeyMiddumpEnd = 0xffffffff;
 
-extern IMG_UINT32 g_ui32HotKeyFrame;
-extern IMG_BOOL g_bHotKeyPressed;
-extern IMG_BOOL g_bHotKeyRegistered;
+void *g_pvAPIMutex;
 
 IMG_BOOL gbDumpThisFrame = IMG_FALSE;
 
-IMG_UINT32 SpaceInStream(PDBG_STREAM psStream);
-IMG_BOOL ExpandStreamBuffer(PDBG_STREAM psStream, IMG_UINT32 ui32NewSize);
-PDBG_LASTFRAME_BUFFER FindLFBuf(PDBG_STREAM psStream);
+static u32 SpaceInStream(struct DBG_STREAM *psStream);
+static IMG_BOOL ExpandStreamBuffer(struct DBG_STREAM *psStream,
+				   u32 ui32NewSize);
+struct DBG_LASTFRAME_BUFFER *FindLFBuf(struct DBG_STREAM *psStream);
 
-DBGKM_SERVICE_TABLE g_sDBGKMServices = {
-	sizeof(DBGKM_SERVICE_TABLE),
+struct DBGKM_SERVICE_TABLE g_sDBGKMServices = {
+	sizeof(struct DBGKM_SERVICE_TABLE),
 	ExtDBGDrivCreateStream,
 	ExtDBGDrivDestroyStream,
 	ExtDBGDrivFindStream,
@@ -95,13 +92,13 @@
 	ExtDBGDrivIsLastCaptureFrame,
 };
 
-IMG_VOID *IMG_CALLCONV ExtDBGDrivCreateStream(IMG_CHAR * pszName,
-					      IMG_UINT32 ui32CapMode,
-					      IMG_UINT32 ui32OutMode,
-					      IMG_UINT32 ui32Flags,
-					      IMG_UINT32 ui32Size)
+void *ExtDBGDrivCreateStream(char *pszName,
+					      u32 ui32CapMode,
+					      u32 ui32OutMode,
+					      u32 ui32Flags,
+					      u32 ui32Size)
 {
-	IMG_VOID *pvRet;
+	void *pvRet;
 
 	HostAquireMutex(g_pvAPIMutex);
 
@@ -114,7 +111,7 @@
 	return pvRet;
 }
 
-void IMG_CALLCONV ExtDBGDrivDestroyStream(PDBG_STREAM psStream)
+void ExtDBGDrivDestroyStream(struct DBG_STREAM *psStream)
 {
 
 	HostAquireMutex(g_pvAPIMutex);
@@ -126,10 +123,10 @@
 	return;
 }
 
-IMG_VOID *IMG_CALLCONV ExtDBGDrivFindStream(IMG_CHAR * pszName,
+void *ExtDBGDrivFindStream(char *pszName,
 					    IMG_BOOL bResetStream)
 {
-	IMG_VOID *pvRet;
+	void *pvRet;
 
 	HostAquireMutex(g_pvAPIMutex);
 
@@ -140,11 +137,11 @@
 	return pvRet;
 }
 
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivWriteString(PDBG_STREAM psStream,
-					      IMG_CHAR * pszString,
-					      IMG_UINT32 ui32Level)
+u32 ExtDBGDrivWriteString(struct DBG_STREAM *psStream,
+					      char *pszString,
+					      u32 ui32Level)
 {
-	IMG_UINT32 ui32Ret;
+	u32 ui32Ret;
 
 	HostAquireMutex(g_pvAPIMutex);
 
@@ -155,11 +152,11 @@
 	return ui32Ret;
 }
 
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivReadString(PDBG_STREAM psStream,
-					     IMG_CHAR * pszString,
-					     IMG_UINT32 ui32Limit)
+u32 ExtDBGDrivReadString(struct DBG_STREAM *psStream,
+					     char *pszString,
+					     u32 ui32Limit)
 {
-	IMG_UINT32 ui32Ret;
+	u32 ui32Ret;
 
 	HostAquireMutex(g_pvAPIMutex);
 
@@ -170,12 +167,12 @@
 	return ui32Ret;
 }
 
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivWrite(PDBG_STREAM psStream,
-					IMG_UINT8 * pui8InBuf,
-					IMG_UINT32 ui32InBuffSize,
-					IMG_UINT32 ui32Level)
+u32 ExtDBGDrivWrite(struct DBG_STREAM *psStream,
+					u8 *pui8InBuf,
+					u32 ui32InBuffSize,
+					u32 ui32Level)
 {
-	IMG_UINT32 ui32Ret;
+	u32 ui32Ret;
 
 	HostAquireMutex(g_pvAPIMutex);
 
@@ -186,12 +183,12 @@
 	return ui32Ret;
 }
 
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivRead(PDBG_STREAM psStream,
+u32 ExtDBGDrivRead(struct DBG_STREAM *psStream,
 				       IMG_BOOL bReadInitBuffer,
-				       IMG_UINT32 ui32OutBuffSize,
-				       IMG_UINT8 * pui8OutBuf)
+				       u32 ui32OutBuffSize,
+				       u8 *pui8OutBuf)
 {
-	IMG_UINT32 ui32Ret;
+	u32 ui32Ret;
 
 	HostAquireMutex(g_pvAPIMutex);
 
@@ -203,11 +200,11 @@
 	return ui32Ret;
 }
 
-void IMG_CALLCONV ExtDBGDrivSetCaptureMode(PDBG_STREAM psStream,
-					   IMG_UINT32 ui32Mode,
-					   IMG_UINT32 ui32Start,
-					   IMG_UINT32 ui32End,
-					   IMG_UINT32 ui32SampleRate)
+void ExtDBGDrivSetCaptureMode(struct DBG_STREAM *psStream,
+					   u32 ui32Mode,
+					   u32 ui32Start,
+					   u32 ui32End,
+					   u32 ui32SampleRate)
 {
 
 	HostAquireMutex(g_pvAPIMutex);
@@ -220,8 +217,8 @@
 	return;
 }
 
-void IMG_CALLCONV ExtDBGDrivSetOutputMode(PDBG_STREAM psStream,
-					  IMG_UINT32 ui32OutMode)
+void ExtDBGDrivSetOutputMode(struct DBG_STREAM *psStream,
+					  u32 ui32OutMode)
 {
 
 	HostAquireMutex(g_pvAPIMutex);
@@ -233,8 +230,8 @@
 	return;
 }
 
-void IMG_CALLCONV ExtDBGDrivSetDebugLevel(PDBG_STREAM psStream,
-					  IMG_UINT32 ui32DebugLevel)
+void ExtDBGDrivSetDebugLevel(struct DBG_STREAM *psStream,
+					  u32 ui32DebugLevel)
 {
 
 	HostAquireMutex(g_pvAPIMutex);
@@ -246,7 +243,7 @@
 	return;
 }
 
-void IMG_CALLCONV ExtDBGDrivSetFrame(PDBG_STREAM psStream, IMG_UINT32 ui32Frame)
+void ExtDBGDrivSetFrame(struct DBG_STREAM *psStream, u32 ui32Frame)
 {
 
 	HostAquireMutex(g_pvAPIMutex);
@@ -258,9 +255,9 @@
 	return;
 }
 
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivGetFrame(PDBG_STREAM psStream)
+u32 ExtDBGDrivGetFrame(struct DBG_STREAM *psStream)
 {
-	IMG_UINT32 ui32Ret;
+	u32 ui32Ret;
 
 	HostAquireMutex(g_pvAPIMutex);
 
@@ -271,9 +268,9 @@
 	return ui32Ret;
 }
 
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivIsLastCaptureFrame(PDBG_STREAM psStream)
+u32 ExtDBGDrivIsLastCaptureFrame(struct DBG_STREAM *psStream)
 {
-	IMG_UINT32 ui32Ret;
+	u32 ui32Ret;
 
 	HostAquireMutex(g_pvAPIMutex);
 
@@ -284,10 +281,10 @@
 	return ui32Ret;
 }
 
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivIsCaptureFrame(PDBG_STREAM psStream,
+u32 ExtDBGDrivIsCaptureFrame(struct DBG_STREAM *psStream,
 						 IMG_BOOL bCheckPreviousFrame)
 {
-	IMG_UINT32 ui32Ret;
+	u32 ui32Ret;
 
 	HostAquireMutex(g_pvAPIMutex);
 
@@ -298,8 +295,8 @@
 	return ui32Ret;
 }
 
-void IMG_CALLCONV ExtDBGDrivOverrideMode(PDBG_STREAM psStream,
-					 IMG_UINT32 ui32Mode)
+void ExtDBGDrivOverrideMode(struct DBG_STREAM *psStream,
+					 u32 ui32Mode)
 {
 
 	HostAquireMutex(g_pvAPIMutex);
@@ -311,7 +308,7 @@
 	return;
 }
 
-void IMG_CALLCONV ExtDBGDrivDefaultMode(PDBG_STREAM psStream)
+void ExtDBGDrivDefaultMode(struct DBG_STREAM *psStream)
 {
 
 	HostAquireMutex(g_pvAPIMutex);
@@ -323,12 +320,12 @@
 	return;
 }
 
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivWrite2(PDBG_STREAM psStream,
-					 IMG_UINT8 * pui8InBuf,
-					 IMG_UINT32 ui32InBuffSize,
-					 IMG_UINT32 ui32Level)
+u32 ExtDBGDrivWrite2(struct DBG_STREAM *psStream,
+					 u8 *pui8InBuf,
+					 u32 ui32InBuffSize,
+					 u32 ui32Level)
 {
-	IMG_UINT32 ui32Ret;
+	u32 ui32Ret;
 
 	HostAquireMutex(g_pvAPIMutex);
 
@@ -339,11 +336,11 @@
 	return ui32Ret;
 }
 
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivWriteStringCM(PDBG_STREAM psStream,
-						IMG_CHAR * pszString,
-						IMG_UINT32 ui32Level)
+u32 ExtDBGDrivWriteStringCM(struct DBG_STREAM *psStream,
+						char *pszString,
+						u32 ui32Level)
 {
-	IMG_UINT32 ui32Ret;
+	u32 ui32Ret;
 
 	HostAquireMutex(g_pvAPIMutex);
 
@@ -354,12 +351,12 @@
 	return ui32Ret;
 }
 
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivWriteCM(PDBG_STREAM psStream,
-					  IMG_UINT8 * pui8InBuf,
-					  IMG_UINT32 ui32InBuffSize,
-					  IMG_UINT32 ui32Level)
+u32 ExtDBGDrivWriteCM(struct DBG_STREAM *psStream,
+					  u8 *pui8InBuf,
+					  u32 ui32InBuffSize,
+					  u32 ui32Level)
 {
-	IMG_UINT32 ui32Ret;
+	u32 ui32Ret;
 
 	HostAquireMutex(g_pvAPIMutex);
 
@@ -371,8 +368,8 @@
 	return ui32Ret;
 }
 
-void IMG_CALLCONV ExtDBGDrivSetMarker(PDBG_STREAM psStream,
-				      IMG_UINT32 ui32Marker)
+void ExtDBGDrivSetMarker(struct DBG_STREAM *psStream,
+				      u32 ui32Marker)
 {
 
 	HostAquireMutex(g_pvAPIMutex);
@@ -384,9 +381,9 @@
 	return;
 }
 
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivGetMarker(PDBG_STREAM psStream)
+u32 ExtDBGDrivGetMarker(struct DBG_STREAM *psStream)
 {
-	IMG_UINT32 ui32Marker;
+	u32 ui32Marker;
 
 	HostAquireMutex(g_pvAPIMutex);
 
@@ -397,13 +394,13 @@
 	return ui32Marker;
 }
 
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivWriteLF(PDBG_STREAM psStream,
-					  IMG_UINT8 * pui8InBuf,
-					  IMG_UINT32 ui32InBuffSize,
-					  IMG_UINT32 ui32Level,
-					  IMG_UINT32 ui32Flags)
+u32 ExtDBGDrivWriteLF(struct DBG_STREAM *psStream,
+					  u8 *pui8InBuf,
+					  u32 ui32InBuffSize,
+					  u32 ui32Level,
+					  u32 ui32Flags)
 {
-	IMG_UINT32 ui32Ret;
+	u32 ui32Ret;
 
 	HostAquireMutex(g_pvAPIMutex);
 
@@ -416,11 +413,11 @@
 	return ui32Ret;
 }
 
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivReadLF(PDBG_STREAM psStream,
-					 IMG_UINT32 ui32OutBuffSize,
-					 IMG_UINT8 * pui8OutBuf)
+u32 ExtDBGDrivReadLF(struct DBG_STREAM *psStream,
+					 u32 ui32OutBuffSize,
+					 u8 *pui8OutBuf)
 {
-	IMG_UINT32 ui32Ret;
+	u32 ui32Ret;
 
 	HostAquireMutex(g_pvAPIMutex);
 
@@ -431,7 +428,7 @@
 	return ui32Ret;
 }
 
-IMG_VOID IMG_CALLCONV ExtDBGDrivEndInitPhase(PDBG_STREAM psStream)
+void ExtDBGDrivEndInitPhase(struct DBG_STREAM *psStream)
 {
 
 	HostAquireMutex(g_pvAPIMutex);
@@ -443,9 +440,9 @@
 	return;
 }
 
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivGetStreamOffset(PDBG_STREAM psStream)
+u32 ExtDBGDrivGetStreamOffset(struct DBG_STREAM *psStream)
 {
-	IMG_UINT32 ui32Ret;
+	u32 ui32Ret;
 
 	HostAquireMutex(g_pvAPIMutex);
 
@@ -456,8 +453,8 @@
 	return ui32Ret;
 }
 
-IMG_VOID IMG_CALLCONV ExtDBGDrivSetStreamOffset(PDBG_STREAM psStream,
-						IMG_UINT32 ui32StreamOffset)
+void ExtDBGDrivSetStreamOffset(struct DBG_STREAM *psStream,
+						u32 ui32StreamOffset)
 {
 
 	HostAquireMutex(g_pvAPIMutex);
@@ -467,30 +464,26 @@
 	HostReleaseMutex(g_pvAPIMutex);
 }
 
-IMG_UINT32 AtoI(char *szIn)
+u32 AtoI(char *szIn)
 {
-	IMG_UINT32 ui32Len = 0;
-	IMG_UINT32 ui32Value = 0;
-	IMG_UINT32 ui32Digit = 1;
-	IMG_UINT32 ui32Base = 10;
+	u32 ui32Len = 0;
+	u32 ui32Value = 0;
+	u32 ui32Digit = 1;
+	u32 ui32Base = 10;
 	int iPos;
 	char bc;
 
-	while (szIn[ui32Len] > 0) {
+	while (szIn[ui32Len] > 0)
 		ui32Len++;
-	}
 
-	if (ui32Len == 0) {
-		return (0);
-	}
+	if (ui32Len == 0)
+		return 0;
 
 	iPos = 0;
-	while (szIn[iPos] == '0') {
+	while (szIn[iPos] == '0')
 		iPos++;
-	}
-	if (szIn[iPos] == '\0') {
+	if (szIn[iPos] == '\0')
 		return 0;
-	}
 	if (szIn[iPos] == 'x' || szIn[iPos] == 'X') {
 		ui32Base = 16;
 		szIn[iPos] = '0';
@@ -499,74 +492,71 @@
 	for (iPos = ui32Len - 1; iPos >= 0; iPos--) {
 		bc = szIn[iPos];
 
-		if ((bc >= 'a') && (bc <= 'f') && ui32Base == 16) {
+		if ((bc >= 'a') && (bc <= 'f') && ui32Base == 16)
 			bc -= 'a' - 0xa;
-		} else if ((bc >= 'A') && (bc <= 'F') && ui32Base == 16) {
+		else if ((bc >= 'A') && (bc <= 'F') && ui32Base == 16)
 			bc -= 'A' - 0xa;
-		} else if ((bc >= '0') && (bc <= '9')) {
+		else if ((bc >= '0') && (bc <= '9'))
 			bc -= '0';
-		} else
-			return (0);
+		else
+			return 0;
 
 		ui32Value += bc * ui32Digit;
 
 		ui32Digit = ui32Digit * ui32Base;
 	}
-	return (ui32Value);
+	return ui32Value;
 }
 
-IMG_BOOL StreamValid(PDBG_STREAM psStream)
+IMG_BOOL StreamValid(struct DBG_STREAM *psStream)
 {
-	PDBG_STREAM psThis;
+	struct DBG_STREAM *psThis;
 
 	psThis = g_psStreamList;
 
-	while (psThis) {
-		if (psStream && (psThis == psStream)) {
-			return (IMG_TRUE);
-		} else {
+	while (psThis)
+		if (psStream && (psThis == psStream))
+			return IMG_TRUE;
+		else
 			psThis = psThis->psNext;
-		}
-	}
 
-	return (IMG_FALSE);
+	return IMG_FALSE;
 }
 
-void Write(PDBG_STREAM psStream, IMG_UINT8 * pui8Data,
-	   IMG_UINT32 ui32InBuffSize)
+void Write(struct DBG_STREAM *psStream, u8 *pui8Data,
+	   u32 ui32InBuffSize)
 {
 
 	if ((psStream->ui32WPtr + ui32InBuffSize) > psStream->ui32Size) {
-		IMG_UINT32 ui32B1 = psStream->ui32Size - psStream->ui32WPtr;
-		IMG_UINT32 ui32B2 = ui32InBuffSize - ui32B1;
+		u32 ui32B1 = psStream->ui32Size - psStream->ui32WPtr;
+		u32 ui32B2 = ui32InBuffSize - ui32B1;
 
-		HostMemCopy((IMG_VOID *) (psStream->ui32Base +
+		HostMemCopy((void *) (psStream->ui32Base +
 					  psStream->ui32WPtr),
-			    (IMG_VOID *) pui8Data, ui32B1);
+			    (void *) pui8Data, ui32B1);
 
-		HostMemCopy((IMG_VOID *) psStream->ui32Base,
-			    (IMG_VOID *) ((IMG_UINT32) pui8Data + ui32B1),
+		HostMemCopy((void *) psStream->ui32Base,
+			    (void *) ((u32) pui8Data + ui32B1),
 			    ui32B2);
 
 		psStream->ui32WPtr = ui32B2;
 	} else {
-		HostMemCopy((IMG_VOID *) (psStream->ui32Base +
+		HostMemCopy((void *) (psStream->ui32Base +
 					  psStream->ui32WPtr),
-			    (IMG_VOID *) pui8Data, ui32InBuffSize);
+			    (void *) pui8Data, ui32InBuffSize);
 
 		psStream->ui32WPtr += ui32InBuffSize;
 
-		if (psStream->ui32WPtr == psStream->ui32Size) {
+		if (psStream->ui32WPtr == psStream->ui32Size)
 			psStream->ui32WPtr = 0;
-		}
 	}
 	psStream->ui32DataWritten += ui32InBuffSize;
 }
 
-void MonoOut(IMG_CHAR * pszString, IMG_BOOL bNewLine)
+void MonoOut(char *pszString, IMG_BOOL bNewLine)
 {
-	IMG_UINT32 i;
-	IMG_CHAR *pScreen;
+	u32 i;
+	char *pScreen;
 
 	pScreen = (char *)DBGDRIV_MONOBASE;
 
@@ -577,8 +567,7 @@
 		pScreen[g_ui32LOff + (i * 2)] = pszString[i];
 		pScreen[g_ui32LOff + (i * 2) + 1] = 127;
 		i++;
-	}
-	while ((pszString[i] != 0) && (i < 4096));
+	} while ((pszString[i] != 0) && (i < 4096));
 
 	g_ui32LOff += i * 2;
 
@@ -590,20 +579,20 @@
 	if (g_ui32Line == g_ui32MonoLines) {
 		g_ui32Line = g_ui32MonoLines - 1;
 
-		HostMemCopy((IMG_VOID *) DBGDRIV_MONOBASE,
-			    (IMG_VOID *) (DBGDRIV_MONOBASE + 160),
+		HostMemCopy((void *) DBGDRIV_MONOBASE,
+			    (void *) (DBGDRIV_MONOBASE + 160),
 			    160 * (g_ui32MonoLines - 1));
 
-		HostMemSet((IMG_VOID *) (DBGDRIV_MONOBASE +
+		HostMemSet((void *) (DBGDRIV_MONOBASE +
 					 (160 * (g_ui32MonoLines - 1))), 0,
 			   160);
 	}
 }
 
-void AppendName(IMG_CHAR * pszOut, IMG_CHAR * pszBase, IMG_CHAR * pszName)
+void AppendName(char *pszOut, char *pszBase, char *pszName)
 {
-	IMG_UINT32 i;
-	IMG_UINT32 ui32Off;
+	u32 i;
+	u32 ui32Off;
 
 	i = 0;
 
@@ -623,50 +612,48 @@
 	pszOut[ui32Off + i] = pszName[i];
 }
 
-IMG_VOID *IMG_CALLCONV DBGDrivCreateStream(IMG_CHAR * pszName,
-					   IMG_UINT32 ui32CapMode,
-					   IMG_UINT32 ui32OutMode,
-					   IMG_UINT32 ui32Flags,
-					   IMG_UINT32 ui32Size)
-{
-	PDBG_STREAM psStream;
-	PDBG_STREAM psInitStream;
-	PDBG_LASTFRAME_BUFFER psLFBuffer;
-	IMG_UINT32 ui32Off;
-	IMG_VOID *pvBase;
+void *DBGDrivCreateStream(char *pszName,
+					   u32 ui32CapMode,
+					   u32 ui32OutMode,
+					   u32 ui32Flags,
+					   u32 ui32Size)
+{
+	struct DBG_STREAM *psStream;
+	struct DBG_STREAM *psInitStream;
+	struct DBG_LASTFRAME_BUFFER *psLFBuffer;
+	u32 ui32Off;
+	void *pvBase;
 
-	psStream = (PDBG_STREAM) DBGDrivFindStream(pszName, IMG_FALSE);
+	psStream = (struct DBG_STREAM *)DBGDrivFindStream(pszName, IMG_FALSE);
 
-	if (psStream) {
-		return ((IMG_VOID *) psStream);
-	}
+	if (psStream)
+		return (void *)psStream;
 
 	psStream = HostNonPageablePageAlloc(1);
 	psInitStream = HostNonPageablePageAlloc(1);
 	psLFBuffer = HostNonPageablePageAlloc(1);
 	if ((!psStream) || (!psInitStream) || (!psLFBuffer)
 	    ) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "DBGDriv: Couldn't create buffer !!!!!\n\r"));
-		return ((IMG_VOID *) 0);
+		PVR_DPF(PVR_DBG_ERROR,
+			 "DBGDriv: Couldn't create buffer !!!!!\n\r");
+		return NULL;
 	}
 
-	if ((ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0) {
+	if ((ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0)
 		pvBase = HostNonPageablePageAlloc(ui32Size);
-	} else {
+	else
 		pvBase = HostPageablePageAlloc(ui32Size);
-	}
 
 	if (!pvBase) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "DBGDriv: Couldn't create buffer !!!!!\n\r"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "DBGDriv: Couldn't create buffer !!!!!\n\r");
 		HostNonPageablePageFree(psStream);
-		return ((IMG_VOID *) 0);
+		return NULL;
 	}
 
 	psStream->psNext = 0;
 	psStream->ui32Flags = ui32Flags;
-	psStream->ui32Base = (IMG_UINT32) pvBase;
+	psStream->ui32Base = (u32) pvBase;
 	psStream->ui32Size = ui32Size * 4096;
 	psStream->ui32RPtr = 0;
 	psStream->ui32WPtr = 0;
@@ -684,29 +671,27 @@
 	psStream->ui32Marker = 0;
 	psStream->bInitPhaseComplete = IMG_FALSE;
 
-	if ((ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0) {
+	if ((ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0)
 		pvBase = HostNonPageablePageAlloc(ui32Size);
-	} else {
+	else
 		pvBase = HostPageablePageAlloc(ui32Size);
-	}
 
 	if (!pvBase) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "DBGDriv: Couldn't create buffer !!!!!\n\r"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "DBGDriv: Couldn't create buffer !!!!!\n\r");
 
-		if ((psStream->ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0) {
-			HostNonPageablePageFree((IMG_VOID *) psStream->
+		if ((psStream->ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0)
+			HostNonPageablePageFree((void *) psStream->
 						ui32Base);
-		} else {
-			HostPageablePageFree((IMG_VOID *) psStream->ui32Base);
-		}
+		else
+			HostPageablePageFree((void *) psStream->ui32Base);
 		HostNonPageablePageFree(psStream);
-		return ((IMG_VOID *) 0);
+		return NULL;
 	}
 
 	psInitStream->psNext = 0;
 	psInitStream->ui32Flags = ui32Flags;
-	psInitStream->ui32Base = (IMG_UINT32) pvBase;
+	psInitStream->ui32Base = (u32) pvBase;
 	psInitStream->ui32Size = ui32Size * 4096;
 	psInitStream->ui32RPtr = 0;
 	psInitStream->ui32WPtr = 0;
@@ -739,9 +724,8 @@
 		psStream->szName[ui32Off] = pszName[ui32Off];
 
 		ui32Off++;
-	}
-	while ((pszName[ui32Off] != 0)
-	       && (ui32Off < (4096 - sizeof(DBG_STREAM))));
+	} while ((pszName[ui32Off] != 0)
+		 && (ui32Off < (4096 - sizeof(struct DBG_STREAM))));
 
 	psStream->szName[ui32Off] = pszName[ui32Off];
 
@@ -751,73 +735,67 @@
 	psLFBuffer->psNext = g_psLFBufferList;
 	g_psLFBufferList = psLFBuffer;
 
-	return ((IMG_VOID *) psStream);
+	return (void *)psStream;
 }
 
-void IMG_CALLCONV DBGDrivDestroyStream(PDBG_STREAM psStream)
+void DBGDrivDestroyStream(struct DBG_STREAM *psStream)
 {
-	PDBG_STREAM psStreamThis;
-	PDBG_STREAM psStreamPrev;
-	PDBG_LASTFRAME_BUFFER psLFBuffer;
-	PDBG_LASTFRAME_BUFFER psLFThis;
-	PDBG_LASTFRAME_BUFFER psLFPrev;
+	struct DBG_STREAM *psStreamThis;
+	struct DBG_STREAM *psStreamPrev;
+	struct DBG_LASTFRAME_BUFFER *psLFBuffer;
+	struct DBG_LASTFRAME_BUFFER *psLFThis;
+	struct DBG_LASTFRAME_BUFFER *psLFPrev;
 
-	PVR_DPF((PVR_DBG_MESSAGE, "DBGDriv: Destroying stream %s\r\n",
-		 psStream->szName));
+	PVR_DPF(PVR_DBG_MESSAGE, "DBGDriv: Destroying stream %s\r\n",
+		 psStream->szName);
 
-	if (!StreamValid(psStream)) {
+	if (!StreamValid(psStream))
 		return;
-	}
 
 	psLFBuffer = FindLFBuf(psStream);
 
 	psStreamThis = g_psStreamList;
 	psStreamPrev = 0;
 
-	while (psStreamThis) {
+	while (psStreamThis)
 		if (psStreamThis == psStream) {
-			if (psStreamPrev) {
+			if (psStreamPrev)
 				psStreamPrev->psNext = psStreamThis->psNext;
-			} else {
+			else
 				g_psStreamList = psStreamThis->psNext;
-			}
 
 			psStreamThis = 0;
 		} else {
 			psStreamPrev = psStreamThis;
 			psStreamThis = psStreamThis->psNext;
 		}
-	}
 
 	psLFThis = g_psLFBufferList;
 	psLFPrev = 0;
 
-	while (psLFThis) {
+	while (psLFThis)
 		if (psLFThis == psLFBuffer) {
-			if (psLFPrev) {
+			if (psLFPrev)
 				psLFPrev->psNext = psLFThis->psNext;
-			} else {
+			else
 				g_psLFBufferList = psLFThis->psNext;
-			}
 
 			psLFThis = 0;
 		} else {
 			psLFPrev = psLFThis;
 			psLFThis = psLFThis->psNext;
 		}
-	}
 
-	if (psStream->ui32CapMode & DEBUG_CAPMODE_HOTKEY) {
+	if (psStream->ui32CapMode & DEBUG_CAPMODE_HOTKEY)
 		DeactivateHotKeys();
-	}
 
 	if ((psStream->ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0) {
-		HostNonPageablePageFree((IMG_VOID *) psStream->ui32Base);
-		HostNonPageablePageFree((IMG_VOID *) psStream->psInitStream->
+		HostNonPageablePageFree((void *) psStream->ui32Base);
+		HostNonPageablePageFree((void *) psStream->psInitStream->
 					ui32Base);
 	} else {
-		HostPageablePageFree((IMG_VOID *) psStream->ui32Base);
-		HostPageablePageFree((IMG_VOID *) psStream->psInitStream->
+		HostPageablePageFree((void *) psStream->ui32Base);
+		HostPageablePageFree((void *) psStream->psInitStream->
 				     ui32Base);
 	}
 
@@ -825,24 +803,23 @@
 	HostNonPageablePageFree(psStream);
 	HostNonPageablePageFree(psLFBuffer);
 
-	if (g_psStreamList == 0) {
-		PVR_DPF((PVR_DBG_MESSAGE, "DBGDriv: Stream list now empty"));
-	}
+	if (g_psStreamList == 0)
+		PVR_DPF(PVR_DBG_MESSAGE, "DBGDriv: Stream list now empty");
 
 	return;
 }
 
-IMG_VOID *IMG_CALLCONV DBGDrivFindStream(IMG_CHAR * pszName,
+void *DBGDrivFindStream(char *pszName,
 					 IMG_BOOL bResetStream)
 {
-	PDBG_STREAM psStream;
-	PDBG_STREAM psThis;
-	IMG_UINT32 ui32Off;
+	struct DBG_STREAM *psStream;
+	struct DBG_STREAM *psThis;
+	u32 ui32Off;
 	IMG_BOOL bAreSame;
 
 	psStream = 0;
 
-	for (psThis = g_psStreamList; psThis != IMG_NULL;
+	for (psThis = g_psStreamList; psThis != NULL;
 	     psThis = psThis->psNext) {
 		bAreSame = IMG_TRUE;
 		ui32Off = 0;
@@ -851,9 +828,8 @@
 			while ((psThis->szName[ui32Off] != 0)
 			       && (pszName[ui32Off] != 0) && (ui32Off < 128)
 			       && bAreSame) {
-				if (psThis->szName[ui32Off] != pszName[ui32Off]) {
+				if (psThis->szName[ui32Off] != pszName[ui32Off])
 					bAreSame = IMG_FALSE;
-				}
 
 				ui32Off++;
 			}
@@ -875,65 +851,56 @@
 		psStream->ui32DataWritten =
 		    psStream->psInitStream->ui32DataWritten;
 		if (psStream->bInitPhaseComplete == IMG_FALSE) {
-			if (psStream->ui32Flags & DEBUG_FLAGS_TEXTSTREAM) {
-				DBGDrivWrite2(psStream, (IMG_UINT8 *) szComment,
+			if (psStream->ui32Flags & DEBUG_FLAGS_TEXTSTREAM)
+				DBGDrivWrite2(psStream, (u8 *) szComment,
 					      sizeof(szComment) - 1, 0x01);
-			}
 			psStream->bInitPhaseComplete = IMG_TRUE;
 		}
 	}
 
-	return ((IMG_VOID *) psStream);
+	return (void *)psStream;
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivWriteStringCM(PDBG_STREAM psStream,
-					     IMG_CHAR * pszString,
-					     IMG_UINT32 ui32Level)
+u32 DBGDrivWriteStringCM(struct DBG_STREAM *psStream,
+					     char *pszString,
+					     u32 ui32Level)
 {
 
-	if (!StreamValid(psStream)) {
-		return (0xFFFFFFFF);
-	}
+	if (!StreamValid(psStream))
+		return 0xFFFFFFFF;
 
-	if (psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED) {
-		if (!(psStream->ui32Flags & DEBUG_FLAGS_ENABLESAMPLE)) {
-			return (0);
-		}
-	} else {
-		if (psStream->ui32CapMode == DEBUG_CAPMODE_HOTKEY) {
+	if (psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED)
+		if (!(psStream->ui32Flags & DEBUG_FLAGS_ENABLESAMPLE))
+			return 0;
+	else
+		if (psStream->ui32CapMode == DEBUG_CAPMODE_HOTKEY)
 			if ((psStream->ui32Current != g_ui32HotKeyFrame)
-			    || (g_bHotKeyPressed == IMG_FALSE)) {
-				return (0);
-			}
-		}
-	}
+			    || (g_bHotKeyPressed == IMG_FALSE))
+				return 0;
 
-	return (DBGDrivWriteString(psStream, pszString, ui32Level));
+	return DBGDrivWriteString(psStream, pszString, ui32Level);
 
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivWriteString(PDBG_STREAM psStream,
-					   IMG_CHAR * pszString,
-					   IMG_UINT32 ui32Level)
+u32 DBGDrivWriteString(struct DBG_STREAM *psStream,
+					   char *pszString,
+					   u32 ui32Level)
 {
-	IMG_UINT32 ui32Len;
-	IMG_UINT32 ui32Space;
-	IMG_UINT32 ui32WPtr;
-	IMG_UINT8 *pui8Buffer;
+	u32 ui32Len;
+	u32 ui32Space;
+	u32 ui32WPtr;
+	u8 *pui8Buffer;
 
-	if (!StreamValid(psStream)) {
-		return (0xFFFFFFFF);
-	}
+	if (!StreamValid(psStream))
+		return 0xFFFFFFFF;
 
-	if (!(psStream->ui32DebugLevel & ui32Level)) {
-		return (0xFFFFFFFF);
-	}
+	if (!(psStream->ui32DebugLevel & ui32Level))
+		return 0xFFFFFFFF;
 
 	if (!(psStream->ui32OutMode & DEBUG_OUTMODE_ASYNC)) {
-		if (psStream->ui32OutMode & DEBUG_OUTMODE_STANDARDDBG) {
-			PVR_DPF((PVR_DBG_MESSAGE, "%s: %s\r\n",
-				 psStream->szName, pszString));
-		}
+		if (psStream->ui32OutMode & DEBUG_OUTMODE_STANDARDDBG)
+			PVR_DPF(PVR_DBG_MESSAGE, "%s: %s\r\n",
+				 psStream->szName, pszString);
 
 		if (psStream->ui32OutMode & DEBUG_OUTMODE_MONO) {
 			MonoOut(psStream->szName, IMG_FALSE);
@@ -945,27 +912,24 @@
 	if (!((psStream->ui32OutMode & DEBUG_OUTMODE_STREAMENABLE) ||
 	      (psStream->ui32OutMode & DEBUG_OUTMODE_ASYNC)
 	    )
-	    ) {
-		return (0xFFFFFFFF);
-	}
+	    )
+		return 0xFFFFFFFF;
 
 	ui32Space = SpaceInStream(psStream);
 
-	if (ui32Space > 0) {
+	if (ui32Space > 0)
 		ui32Space--;
-	}
 
 	ui32Len = 0;
 	ui32WPtr = psStream->ui32WPtr;
-	pui8Buffer = (IMG_UINT8 *) psStream->ui32Base;
+	pui8Buffer = (u8 *) psStream->ui32Base;
 
 	while ((pszString[ui32Len] != 0) && (ui32Len < ui32Space)) {
 		pui8Buffer[ui32WPtr] = pszString[ui32Len];
 		ui32Len++;
 		ui32WPtr++;
-		if (ui32WPtr == psStream->ui32Size) {
+		if (ui32WPtr == psStream->ui32Size)
 			ui32WPtr = 0;
-		}
 	}
 
 	if (ui32Len < ui32Space) {
@@ -973,9 +937,8 @@
 		pui8Buffer[ui32WPtr] = pszString[ui32Len];
 		ui32Len++;
 		ui32WPtr++;
-		if (ui32WPtr == psStream->ui32Size) {
+		if (ui32WPtr == psStream->ui32Size)
 			ui32WPtr = 0;
-		}
 
 		psStream->ui32WPtr = ui32WPtr;
 		psStream->ui32DataWritten += ui32Len;
@@ -983,28 +946,26 @@
 		ui32Len = 0;
 	}
 
-	return (ui32Len);
+	return ui32Len;
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivReadString(PDBG_STREAM psStream,
-					  IMG_CHAR * pszString,
-					  IMG_UINT32 ui32Limit)
+u32 DBGDrivReadString(struct DBG_STREAM *psStream,
+					  char *pszString,
+					  u32 ui32Limit)
 {
-	IMG_UINT32 ui32OutLen;
-	IMG_UINT32 ui32Len;
-	IMG_UINT32 ui32Offset;
-	IMG_UINT8 *pui8Buff;
+	u32 ui32OutLen;
+	u32 ui32Len;
+	u32 ui32Offset;
+	u8 *pui8Buff;
 
-	if (!StreamValid(psStream)) {
-		return (0);
-	}
+	if (!StreamValid(psStream))
+		return 0;
 
-	pui8Buff = (IMG_UINT8 *) psStream->ui32Base;
+	pui8Buff = (u8 *) psStream->ui32Base;
 	ui32Offset = psStream->ui32RPtr;
 
-	if (psStream->ui32RPtr == psStream->ui32WPtr) {
-		return (0);
-	}
+	if (psStream->ui32RPtr == psStream->ui32WPtr)
+		return 0;
 
 	ui32Len = 0;
 	while ((pui8Buff[ui32Offset] != 0)
@@ -1012,16 +973,14 @@
 		ui32Offset++;
 		ui32Len++;
 
-		if (ui32Offset == psStream->ui32Size) {
+		if (ui32Offset == psStream->ui32Size)
 			ui32Offset = 0;
-		}
 	}
 
 	ui32OutLen = ui32Len + 1;
 
-	if (ui32Len > ui32Limit) {
-		return (0);
-	}
+	if (ui32Len > ui32Limit)
+		return 0;
 
 	ui32Offset = psStream->ui32RPtr;
 	ui32Len = 0;
@@ -1031,233 +990,202 @@
 		ui32Offset++;
 		ui32Len++;
 
-		if (ui32Offset == psStream->ui32Size) {
+		if (ui32Offset == psStream->ui32Size)
 			ui32Offset = 0;
-		}
 	}
 
 	pszString[ui32Len] = pui8Buff[ui32Offset];
 
 	psStream->ui32RPtr = ui32Offset + 1;
 
-	if (psStream->ui32RPtr == psStream->ui32Size) {
+	if (psStream->ui32RPtr == psStream->ui32Size)
 		psStream->ui32RPtr = 0;
-	}
 
-	return (ui32OutLen);
+	return ui32OutLen;
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivWrite(PDBG_STREAM psMainStream,
-				     IMG_UINT8 * pui8InBuf,
-				     IMG_UINT32 ui32InBuffSize,
-				     IMG_UINT32 ui32Level)
+u32 DBGDrivWrite(struct DBG_STREAM *psMainStream,
+				     u8 *pui8InBuf,
+				     u32 ui32InBuffSize,
+				     u32 ui32Level)
 {
-	IMG_UINT32 ui32Space;
-	DBG_STREAM *psStream;
+	u32 ui32Space;
+	struct DBG_STREAM *psStream;
 
-	if (!StreamValid(psMainStream)) {
-		return (0xFFFFFFFF);
-	}
+	if (!StreamValid(psMainStream))
+		return 0xFFFFFFFF;
 
-	if (!(psMainStream->ui32DebugLevel & ui32Level)) {
-		return (0xFFFFFFFF);
-	}
+	if (!(psMainStream->ui32DebugLevel & ui32Level))
+		return 0xFFFFFFFF;
 
-	if (psMainStream->ui32CapMode & DEBUG_CAPMODE_FRAMED) {
-		if (!(psMainStream->ui32Flags & DEBUG_FLAGS_ENABLESAMPLE)) {
-			return (0xFFFFFFFF);
-		}
-	} else if (psMainStream->ui32CapMode == DEBUG_CAPMODE_HOTKEY) {
+	if (psMainStream->ui32CapMode & DEBUG_CAPMODE_FRAMED)
+		if (!(psMainStream->ui32Flags & DEBUG_FLAGS_ENABLESAMPLE))
+			return 0xFFFFFFFF;
+	else
+	if (psMainStream->ui32CapMode == DEBUG_CAPMODE_HOTKEY)
 		if ((psMainStream->ui32Current != g_ui32HotKeyFrame)
 		    || (g_bHotKeyPressed == IMG_FALSE))
-			return (0xFFFFFFFF);
-	}
+			return 0xFFFFFFFF;
 
-	if (psMainStream->bInitPhaseComplete) {
+	if (psMainStream->bInitPhaseComplete)
 		psStream = psMainStream;
-	} else {
+	else
 		psStream = psMainStream->psInitStream;
-	}
 
 	ui32Space = SpaceInStream(psStream);
 
-	if (!(psStream->ui32OutMode & DEBUG_OUTMODE_STREAMENABLE)) {
-		return (0);
-	}
+	if (!(psStream->ui32OutMode & DEBUG_OUTMODE_STREAMENABLE))
+		return 0;
 
-	if (ui32Space < 8) {
-		return (0);
-	}
+	if (ui32Space < 8)
+		return 0;
 
-	if (ui32Space <= (ui32InBuffSize + 4)) {
+	if (ui32Space <= (ui32InBuffSize + 4))
 		ui32InBuffSize = ui32Space - 8;
-	}
 
-	Write(psStream, (IMG_UINT8 *) & ui32InBuffSize, 4);
+	Write(psStream, (u8 *) &ui32InBuffSize, 4);
 	Write(psStream, pui8InBuf, ui32InBuffSize);
 
-	return (ui32InBuffSize);
+	return ui32InBuffSize;
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivWriteCM(PDBG_STREAM psStream,
-				       IMG_UINT8 * pui8InBuf,
-				       IMG_UINT32 ui32InBuffSize,
-				       IMG_UINT32 ui32Level)
+u32 DBGDrivWriteCM(struct DBG_STREAM *psStream,
+				       u8 *pui8InBuf,
+				       u32 ui32InBuffSize,
+				       u32 ui32Level)
 {
 
-	if (!StreamValid(psStream)) {
-		return (0xFFFFFFFF);
-	}
+	if (!StreamValid(psStream))
+		return 0xFFFFFFFF;
 
-	if (psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED) {
-		if (!(psStream->ui32Flags & DEBUG_FLAGS_ENABLESAMPLE)) {
-			return (0xFFFFFFFF);
-		}
-	} else {
-		if (psStream->ui32CapMode == DEBUG_CAPMODE_HOTKEY) {
+	if (psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED)
+		if (!(psStream->ui32Flags & DEBUG_FLAGS_ENABLESAMPLE))
+			return 0xFFFFFFFF;
+	else
+		if (psStream->ui32CapMode == DEBUG_CAPMODE_HOTKEY)
 			if ((psStream->ui32Current != g_ui32HotKeyFrame)
-			    || (g_bHotKeyPressed == IMG_FALSE)) {
-				return (0xFFFFFFFF);
-			}
-		}
-	}
+			    || (g_bHotKeyPressed == IMG_FALSE))
+				return 0xFFFFFFFF;
 
-	return (DBGDrivWrite2(psStream, pui8InBuf, ui32InBuffSize, ui32Level));
+	return DBGDrivWrite2(psStream, pui8InBuf, ui32InBuffSize, ui32Level);
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivWrite2(PDBG_STREAM psMainStream,
-				      IMG_UINT8 * pui8InBuf,
-				      IMG_UINT32 ui32InBuffSize,
-				      IMG_UINT32 ui32Level)
+u32 DBGDrivWrite2(struct DBG_STREAM *psMainStream,
+				      u8 *pui8InBuf,
+				      u32 ui32InBuffSize,
+				      u32 ui32Level)
 {
-	IMG_UINT32 ui32Space;
-	DBG_STREAM *psStream;
+	u32 ui32Space;
+	struct DBG_STREAM *psStream;
 
-	if (!StreamValid(psMainStream)) {
-		return (0xFFFFFFFF);
-	}
+	if (!StreamValid(psMainStream))
+		return 0xFFFFFFFF;
 
-	if (!(psMainStream->ui32DebugLevel & ui32Level)) {
-		return (0xFFFFFFFF);
-	}
+	if (!(psMainStream->ui32DebugLevel & ui32Level))
+		return 0xFFFFFFFF;
 
-	if (psMainStream->bInitPhaseComplete) {
+	if (psMainStream->bInitPhaseComplete)
 		psStream = psMainStream;
-	} else {
+	else
 		psStream = psMainStream->psInitStream;
-	}
 
 	ui32Space = SpaceInStream(psStream);
 
-	if (!(psStream->ui32OutMode & DEBUG_OUTMODE_STREAMENABLE)) {
-		return (0);
-	}
+	if (!(psStream->ui32OutMode & DEBUG_OUTMODE_STREAMENABLE))
+		return 0;
 
-	if (psStream->ui32Flags & DEBUG_FLAGS_NO_BUF_EXPANDSION) {
+	if (psStream->ui32Flags & DEBUG_FLAGS_NO_BUF_EXPANDSION)
 
-		if (ui32Space < 32) {
-			return (0);
-		}
-	} else {
+		if (ui32Space < 32)
+			return 0;
+	else
 		if ((ui32Space < 32) || (ui32Space <= (ui32InBuffSize + 4))) {
-			IMG_UINT32 ui32NewBufSize;
+			u32 ui32NewBufSize;
 
 			ui32NewBufSize = 2 * psStream->ui32Size;
 
-			if (ui32InBuffSize > psStream->ui32Size) {
+			if (ui32InBuffSize > psStream->ui32Size)
 				ui32NewBufSize += ui32InBuffSize;
-			}
 
-			if (!ExpandStreamBuffer(psStream, ui32NewBufSize)) {
-				if (ui32Space < 32) {
-					return (0);
-				}
-			}
+			if (!ExpandStreamBuffer(psStream, ui32NewBufSize))
+				if (ui32Space < 32)
+					return 0;
 
 			ui32Space = SpaceInStream(psStream);
 		}
-	}
 
-	if (ui32Space <= (ui32InBuffSize + 4)) {
+	if (ui32Space <= (ui32InBuffSize + 4))
 		ui32InBuffSize = ui32Space - 4;
-	}
 
 	Write(psStream, pui8InBuf, ui32InBuffSize);
 
-	return (ui32InBuffSize);
+	return ui32InBuffSize;
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivRead(PDBG_STREAM psMainStream,
+u32 DBGDrivRead(struct DBG_STREAM *psMainStream,
 				    IMG_BOOL bReadInitBuffer,
-				    IMG_UINT32 ui32OutBuffSize,
-				    IMG_UINT8 * pui8OutBuf)
+				    u32 ui32OutBuffSize,
+				    u8 *pui8OutBuf)
 {
-	IMG_UINT32 ui32Data;
-	DBG_STREAM *psStream;
+	u32 ui32Data;
+	struct DBG_STREAM *psStream;
 
-	if (!StreamValid(psMainStream)) {
-		return (0);
-	}
+	if (!StreamValid(psMainStream))
+		return 0;
 
-	if (bReadInitBuffer) {
+	if (bReadInitBuffer)
 		psStream = psMainStream->psInitStream;
-	} else {
+	else
 		psStream = psMainStream;
-	}
 
-	if (psStream->ui32RPtr == psStream->ui32WPtr) {
-		return (0);
-	}
+	if (psStream->ui32RPtr == psStream->ui32WPtr)
+		return 0;
 
-	if (psStream->ui32RPtr <= psStream->ui32WPtr) {
+	if (psStream->ui32RPtr <= psStream->ui32WPtr)
 		ui32Data = psStream->ui32WPtr - psStream->ui32RPtr;
-	} else {
+	else
 		ui32Data =
 		    psStream->ui32WPtr + (psStream->ui32Size -
 					  psStream->ui32RPtr);
-	}
 
-	if (ui32Data > ui32OutBuffSize) {
+	if (ui32Data > ui32OutBuffSize)
 		ui32Data = ui32OutBuffSize;
-	}
 
 	if ((psStream->ui32RPtr + ui32Data) > psStream->ui32Size) {
-		IMG_UINT32 ui32B1 = psStream->ui32Size - psStream->ui32RPtr;
-		IMG_UINT32 ui32B2 = ui32Data - ui32B1;
+		u32 ui32B1 = psStream->ui32Size - psStream->ui32RPtr;
+		u32 ui32B2 = ui32Data - ui32B1;
 
-		HostMemCopy((IMG_VOID *) pui8OutBuf,
-			    (IMG_VOID *) (psStream->ui32Base +
+		HostMemCopy((void *) pui8OutBuf,
+			    (void *) (psStream->ui32Base +
 					  psStream->ui32RPtr), ui32B1);
 
-		HostMemCopy((IMG_VOID *) ((IMG_UINT32) pui8OutBuf + ui32B1),
-			    (IMG_VOID *) psStream->ui32Base, ui32B2);
+		HostMemCopy((void *) ((u32) pui8OutBuf + ui32B1),
+			    (void *) psStream->ui32Base, ui32B2);
 
 		psStream->ui32RPtr = ui32B2;
 	} else {
-		HostMemCopy((IMG_VOID *) pui8OutBuf,
-			    (IMG_VOID *) (psStream->ui32Base +
+		HostMemCopy((void *) pui8OutBuf,
+			    (void *) (psStream->ui32Base +
 					  psStream->ui32RPtr), ui32Data);
 
 		psStream->ui32RPtr += ui32Data;
 
-		if (psStream->ui32RPtr == psStream->ui32Size) {
+		if (psStream->ui32RPtr == psStream->ui32Size)
 			psStream->ui32RPtr = 0;
-		}
 	}
 
-	return (ui32Data);
+	return ui32Data;
 }
 
-void IMG_CALLCONV DBGDrivSetCaptureMode(PDBG_STREAM psStream,
-					IMG_UINT32 ui32Mode,
-					IMG_UINT32 ui32Start,
-					IMG_UINT32 ui32End,
-					IMG_UINT32 ui32SampleRate)
+void DBGDrivSetCaptureMode(struct DBG_STREAM *psStream,
+					u32 ui32Mode,
+					u32 ui32Start,
+					u32 ui32End,
+					u32 ui32SampleRate)
 {
 
-	if (!StreamValid(psStream)) {
+	if (!StreamValid(psStream))
 		return;
-	}
 
 	psStream->ui32CapMode = ui32Mode;
 	psStream->ui32DefaultMode = ui32Mode;
@@ -1265,52 +1193,47 @@
 	psStream->ui32End = ui32End;
 	psStream->ui32SampleRate = ui32SampleRate;
 
-	if (psStream->ui32CapMode & DEBUG_CAPMODE_HOTKEY) {
+	if (psStream->ui32CapMode & DEBUG_CAPMODE_HOTKEY)
 		ActivateHotKeys(psStream);
-	}
 }
 
-void IMG_CALLCONV DBGDrivSetOutputMode(PDBG_STREAM psStream,
-				       IMG_UINT32 ui32OutMode)
+void DBGDrivSetOutputMode(struct DBG_STREAM *psStream,
+				       u32 ui32OutMode)
 {
 
-	if (!StreamValid(psStream)) {
+	if (!StreamValid(psStream))
 		return;
-	}
 
 	psStream->ui32OutMode = ui32OutMode;
 }
 
-void IMG_CALLCONV DBGDrivSetDebugLevel(PDBG_STREAM psStream,
-				       IMG_UINT32 ui32DebugLevel)
+void DBGDrivSetDebugLevel(struct DBG_STREAM *psStream,
+				       u32 ui32DebugLevel)
 {
 
-	if (!StreamValid(psStream)) {
+	if (!StreamValid(psStream))
 		return;
-	}
 
 	psStream->ui32DebugLevel = ui32DebugLevel;
 }
 
-void IMG_CALLCONV DBGDrivSetFrame(PDBG_STREAM psStream, IMG_UINT32 ui32Frame)
+void DBGDrivSetFrame(struct DBG_STREAM *psStream, u32 ui32Frame)
 {
 
-	if (!StreamValid(psStream)) {
+	if (!StreamValid(psStream))
 		return;
-	}
 
 	psStream->ui32Current = ui32Frame;
 
 	if ((ui32Frame >= psStream->ui32Start) &&
 	    (ui32Frame <= psStream->ui32End) &&
 	    (((ui32Frame - psStream->ui32Start) % psStream->ui32SampleRate) ==
-	     0)) {
+	     0))
 		psStream->ui32Flags |= DEBUG_FLAGS_ENABLESAMPLE;
-	} else {
+	else
 		psStream->ui32Flags &= ~DEBUG_FLAGS_ENABLESAMPLE;
-	}
 
-	if (g_bHotkeyMiddump) {
+	if (g_bHotkeyMiddump)
 		if ((ui32Frame >= g_ui32HotkeyMiddumpStart) &&
 		    (ui32Frame <= g_ui32HotkeyMiddumpEnd) &&
 		    (((ui32Frame -
@@ -1319,17 +1242,15 @@
 			psStream->ui32Flags |= DEBUG_FLAGS_ENABLESAMPLE;
 		} else {
 			psStream->ui32Flags &= ~DEBUG_FLAGS_ENABLESAMPLE;
-			if (psStream->ui32Current > g_ui32HotkeyMiddumpEnd) {
+			if (psStream->ui32Current > g_ui32HotkeyMiddumpEnd)
 				g_bHotkeyMiddump = IMG_FALSE;
-			}
 		}
-	}
 
 	if (g_bHotKeyRegistered) {
 		g_bHotKeyRegistered = IMG_FALSE;
 
-		PVR_DPF((PVR_DBG_MESSAGE, "Hotkey pressed (%08x)!\n",
-			 psStream));
+		PVR_DPF(PVR_DBG_MESSAGE, "Hotkey pressed (%08x)!\n",
+			 psStream);
 
 		if (!g_bHotKeyPressed) {
 
@@ -1339,69 +1260,63 @@
 		}
 
 		if ((psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED)
-		    && (psStream->ui32CapMode & DEBUG_CAPMODE_HOTKEY)) {
+		    && (psStream->ui32CapMode & DEBUG_CAPMODE_HOTKEY))
 			if (!g_bHotkeyMiddump) {
 
 				g_ui32HotkeyMiddumpStart =
 				    g_ui32HotKeyFrame + 1;
 				g_ui32HotkeyMiddumpEnd = 0xffffffff;
 				g_bHotkeyMiddump = IMG_TRUE;
-				PVR_DPF((PVR_DBG_MESSAGE,
+				PVR_DPF(PVR_DBG_MESSAGE,
 					 "Sampling every %d frame(s)\n",
-					 psStream->ui32SampleRate));
+					 psStream->ui32SampleRate);
 			} else {
 
 				g_ui32HotkeyMiddumpEnd = g_ui32HotKeyFrame;
-				PVR_DPF((PVR_DBG_MESSAGE,
-					 "Turning off sampling\n"));
+				PVR_DPF(PVR_DBG_MESSAGE,
+					 "Turning off sampling\n");
 			}
-		}
 
 	}
 
-	if (psStream->ui32Current > g_ui32HotKeyFrame) {
+	if (psStream->ui32Current > g_ui32HotKeyFrame)
 		g_bHotKeyPressed = IMG_FALSE;
-	}
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivGetFrame(PDBG_STREAM psStream)
+u32 DBGDrivGetFrame(struct DBG_STREAM *psStream)
 {
 
-	if (!StreamValid(psStream)) {
-		return (0);
-	}
+	if (!StreamValid(psStream))
+		return 0;
 
-	return (psStream->ui32Current);
+	return psStream->ui32Current;
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivIsLastCaptureFrame(PDBG_STREAM psStream)
+u32 DBGDrivIsLastCaptureFrame(struct DBG_STREAM *psStream)
 {
-	IMG_UINT32 ui32NextFrame;
+	u32 ui32NextFrame;
 
-	if (!StreamValid(psStream)) {
+	if (!StreamValid(psStream))
 		return IMG_FALSE;
-	}
 
 	if (psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED) {
 		ui32NextFrame =
 		    psStream->ui32Current + psStream->ui32SampleRate;
-		if (ui32NextFrame > psStream->ui32End) {
+		if (ui32NextFrame > psStream->ui32End)
 			return IMG_TRUE;
-		}
 	}
 	return IMG_FALSE;
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivIsCaptureFrame(PDBG_STREAM psStream,
+u32 DBGDrivIsCaptureFrame(struct DBG_STREAM *psStream,
 					      IMG_BOOL bCheckPreviousFrame)
 {
-	IMG_UINT32 ui32FrameShift = bCheckPreviousFrame ? 1 : 0;
+	u32 ui32FrameShift = bCheckPreviousFrame ? 1 : 0;
 
-	if (!StreamValid(psStream)) {
+	if (!StreamValid(psStream))
 		return IMG_FALSE;
-	}
 
-	if (psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED) {
+	if (psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED)
 
 		if (g_bHotkeyMiddump) {
 			if ((psStream->ui32Current >=
@@ -1411,9 +1326,8 @@
 			    &&
 			    ((((psStream->ui32Current + ui32FrameShift) -
 			       g_ui32HotkeyMiddumpStart) %
-			      psStream->ui32SampleRate) == 0)) {
+			      psStream->ui32SampleRate) == 0))
 				return IMG_TRUE;
-			}
 		} else {
 			if ((psStream->ui32Current >=
 			     (psStream->ui32Start - ui32FrameShift))
@@ -1422,125 +1336,114 @@
 			    &&
 			    ((((psStream->ui32Current + ui32FrameShift) -
 			       psStream->ui32Start) %
-			      psStream->ui32SampleRate) == 0)) {
+			      psStream->ui32SampleRate) == 0))
 				return IMG_TRUE;
-			}
 		}
-	} else if (psStream->ui32CapMode == DEBUG_CAPMODE_HOTKEY) {
+	else
+	if (psStream->ui32CapMode == DEBUG_CAPMODE_HOTKEY)
 		if ((psStream->ui32Current ==
 		     (g_ui32HotKeyFrame - ui32FrameShift))
-		    && (g_bHotKeyPressed)) {
+		    && (g_bHotKeyPressed))
 			return IMG_TRUE;
-		}
-	}
+
+
 	return IMG_FALSE;
 }
 
-void IMG_CALLCONV DBGDrivOverrideMode(PDBG_STREAM psStream, IMG_UINT32 ui32Mode)
+void DBGDrivOverrideMode(struct DBG_STREAM *psStream, u32 ui32Mode)
 {
 
-	if (!StreamValid(psStream)) {
+	if (!StreamValid(psStream))
 		return;
-	}
 
 	psStream->ui32CapMode = ui32Mode;
 }
 
-void IMG_CALLCONV DBGDrivDefaultMode(PDBG_STREAM psStream)
+void DBGDrivDefaultMode(struct DBG_STREAM *psStream)
 {
 
-	if (!StreamValid(psStream)) {
+	if (!StreamValid(psStream))
 		return;
-	}
 
 	psStream->ui32CapMode = psStream->ui32DefaultMode;
 }
 
-void IMG_CALLCONV DBGDrivSetMarker(PDBG_STREAM psStream, IMG_UINT32 ui32Marker)
+void DBGDrivSetMarker(struct DBG_STREAM *psStream, u32 ui32Marker)
 {
 
-	if (!StreamValid(psStream)) {
+	if (!StreamValid(psStream))
 		return;
-	}
 
 	psStream->ui32Marker = ui32Marker;
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivGetMarker(PDBG_STREAM psStream)
+u32 DBGDrivGetMarker(struct DBG_STREAM *psStream)
 {
 
-	if (!StreamValid(psStream)) {
+	if (!StreamValid(psStream))
 		return 0;
-	}
 
 	return psStream->ui32Marker;
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivGetStreamOffset(PDBG_STREAM psMainStream)
+u32 DBGDrivGetStreamOffset(struct DBG_STREAM *psMainStream)
 {
-	PDBG_STREAM psStream;
+	struct DBG_STREAM *psStream;
 
-	if (!StreamValid(psMainStream)) {
+	if (!StreamValid(psMainStream))
 		return 0;
-	}
 
-	if (psMainStream->bInitPhaseComplete) {
+	if (psMainStream->bInitPhaseComplete)
 		psStream = psMainStream;
-	} else {
+	else
 		psStream = psMainStream->psInitStream;
-	}
 
 	return psStream->ui32DataWritten;
 }
 
-IMG_VOID IMG_CALLCONV DBGDrivSetStreamOffset(PDBG_STREAM psMainStream,
-					     IMG_UINT32 ui32StreamOffset)
+void DBGDrivSetStreamOffset(struct DBG_STREAM *psMainStream,
+					     u32 ui32StreamOffset)
 {
-	PDBG_STREAM psStream;
+	struct DBG_STREAM *psStream;
 
-	if (!StreamValid(psMainStream)) {
+	if (!StreamValid(psMainStream))
 		return;
-	}
 
-	if (psMainStream->bInitPhaseComplete) {
+	if (psMainStream->bInitPhaseComplete)
 		psStream = psMainStream;
-	} else {
+	else
 		psStream = psMainStream->psInitStream;
-	}
 
 	psStream->ui32DataWritten = ui32StreamOffset;
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivGetServiceTable(void)
+u32 DBGDrivGetServiceTable(void)
 {
-	return ((IMG_UINT32) & g_sDBGKMServices);
+	return (u32)&g_sDBGKMServices;
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivWriteLF(PDBG_STREAM psStream,
-				       IMG_UINT8 * pui8InBuf,
-				       IMG_UINT32 ui32InBuffSize,
-				       IMG_UINT32 ui32Level,
-				       IMG_UINT32 ui32Flags)
+u32 DBGDrivWriteLF(struct DBG_STREAM *psStream,
+				       u8 *pui8InBuf,
+				       u32 ui32InBuffSize,
+				       u32 ui32Level,
+				       u32 ui32Flags)
 {
-	PDBG_LASTFRAME_BUFFER psLFBuffer;
+	struct DBG_LASTFRAME_BUFFER *psLFBuffer;
 
-	if (!StreamValid(psStream)) {
-		return (0xFFFFFFFF);
-	}
+	if (!StreamValid(psStream))
+		return 0xFFFFFFFF;
 
-	if (!(psStream->ui32DebugLevel & ui32Level)) {
-		return (0xFFFFFFFF);
-	}
+	if (!(psStream->ui32DebugLevel & ui32Level))
+		return 0xFFFFFFFF;
 
-	if (psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED) {
-		if (!(psStream->ui32Flags & DEBUG_FLAGS_ENABLESAMPLE)) {
-			return (0xFFFFFFFF);
-		}
-	} else if (psStream->ui32CapMode == DEBUG_CAPMODE_HOTKEY) {
+	if (psStream->ui32CapMode & DEBUG_CAPMODE_FRAMED)
+		if (!(psStream->ui32Flags & DEBUG_FLAGS_ENABLESAMPLE))
+			return 0xFFFFFFFF;
+	else
+	if (psStream->ui32CapMode == DEBUG_CAPMODE_HOTKEY)
 		if ((psStream->ui32Current != g_ui32HotKeyFrame)
 		    || (g_bHotKeyPressed == IMG_FALSE))
-			return (0xFFFFFFFF);
-	}
+			return 0xFFFFFFFF;
 
 	psLFBuffer = FindLFBuf(psStream);
 
@@ -1550,8 +1453,8 @@
 		    (ui32InBuffSize >
 		     LAST_FRAME_BUF_SIZE) ? LAST_FRAME_BUF_SIZE :
 		    ui32InBuffSize;
-		HostMemCopy((IMG_VOID *) psLFBuffer->ui8Buffer,
-			    (IMG_VOID *) pui8InBuf, ui32InBuffSize);
+		HostMemCopy((void *) psLFBuffer->ui8Buffer,
+			    (void *) pui8InBuf, ui32InBuffSize);
 		psLFBuffer->ui32BufLen = ui32InBuffSize;
 	} else {
 
@@ -1560,25 +1463,24 @@
 		     LAST_FRAME_BUF_SIZE) ? (LAST_FRAME_BUF_SIZE -
 					     psLFBuffer->
 					     ui32BufLen) : ui32InBuffSize;
-		HostMemCopy((IMG_VOID *) (&psLFBuffer->
+		HostMemCopy((void *) (&psLFBuffer->
 					  ui8Buffer[psLFBuffer->ui32BufLen]),
-			    (IMG_VOID *) pui8InBuf, ui32InBuffSize);
+			    (void *) pui8InBuf, ui32InBuffSize);
 		psLFBuffer->ui32BufLen += ui32InBuffSize;
 	}
 
-	return (ui32InBuffSize);
+	return ui32InBuffSize;
 }
 
-IMG_UINT32 IMG_CALLCONV DBGDrivReadLF(PDBG_STREAM psStream,
-				      IMG_UINT32 ui32OutBuffSize,
-				      IMG_UINT8 * pui8OutBuf)
+u32 DBGDrivReadLF(struct DBG_STREAM *psStream,
+				      u32 ui32OutBuffSize,
+				      u8 *pui8OutBuf)
 {
-	PDBG_LASTFRAME_BUFFER psLFBuffer;
-	IMG_UINT32 ui32Data;
+	struct DBG_LASTFRAME_BUFFER *psLFBuffer;
+	u32 ui32Data;
 
-	if (!StreamValid(psStream)) {
-		return (0);
-	}
+	if (!StreamValid(psStream))
+		return 0;
 
 	psLFBuffer = FindLFBuf(psStream);
 
@@ -1586,73 +1488,69 @@
 	    (ui32OutBuffSize <
 	     psLFBuffer->ui32BufLen) ? ui32OutBuffSize : psLFBuffer->ui32BufLen;
 
-	HostMemCopy((IMG_VOID *) pui8OutBuf, (IMG_VOID *) psLFBuffer->ui8Buffer,
+	HostMemCopy((void *) pui8OutBuf, (void *) psLFBuffer->ui8Buffer,
 		    ui32Data);
 
 	return ui32Data;
 }
 
-IMG_VOID IMG_CALLCONV DBGDrivEndInitPhase(PDBG_STREAM psStream)
+void DBGDrivEndInitPhase(struct DBG_STREAM *psStream)
 {
 	psStream->bInitPhaseComplete = IMG_TRUE;
 }
 
-IMG_BOOL ExpandStreamBuffer(PDBG_STREAM psStream, IMG_UINT32 ui32NewSize)
+static IMG_BOOL ExpandStreamBuffer(struct DBG_STREAM *psStream, u32 ui32NewSize)
 {
-	IMG_VOID *pvNewBuf;
-	IMG_UINT32 ui32NewSizeInPages;
-	IMG_UINT32 ui32NewWOffset;
-	IMG_UINT32 ui32SpaceInOldBuf;
+	void *pvNewBuf;
+	u32 ui32NewSizeInPages;
+	u32 ui32NewWOffset;
+	u32 ui32SpaceInOldBuf;
 
-	if (psStream->ui32Size >= ui32NewSize) {
+	if (psStream->ui32Size >= ui32NewSize)
 		return IMG_FALSE;
-	}
 
 	ui32SpaceInOldBuf = SpaceInStream(psStream);
 
 	ui32NewSizeInPages = ((ui32NewSize + 0xfff) & ~0xfff) / 4096;
 
-	if ((psStream->ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0) {
+	if ((psStream->ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0)
 		pvNewBuf = HostNonPageablePageAlloc(ui32NewSizeInPages);
-	} else {
+	else
 		pvNewBuf = HostPageablePageAlloc(ui32NewSizeInPages);
-	}
 
-	if (pvNewBuf == IMG_NULL) {
+	if (pvNewBuf == NULL)
 		return IMG_FALSE;
-	}
 
 	if (psStream->ui32RPtr <= psStream->ui32WPtr) {
 
-		HostMemCopy((IMG_VOID *) pvNewBuf,
-			    (IMG_VOID *) (psStream->ui32Base +
+		HostMemCopy((void *) pvNewBuf,
+			    (void *) (psStream->ui32Base +
 					  psStream->ui32RPtr),
 			    psStream->ui32WPtr - psStream->ui32RPtr);
 	} else {
-		IMG_UINT32 ui32FirstCopySize;
+		u32 ui32FirstCopySize;
 
 		ui32FirstCopySize = psStream->ui32Size - psStream->ui32RPtr;
 
-		HostMemCopy((IMG_VOID *) pvNewBuf,
-			    (IMG_VOID *) (psStream->ui32Base +
+		HostMemCopy((void *) pvNewBuf,
+			    (void *) (psStream->ui32Base +
 					  psStream->ui32RPtr),
 			    ui32FirstCopySize);
 
-		HostMemCopy((IMG_VOID *) ((IMG_UINT32) pvNewBuf +
+		HostMemCopy((void *) ((u32) pvNewBuf +
 					  ui32FirstCopySize),
-			    (IMG_VOID *) psStream->ui32Base,
+			    (void *) psStream->ui32Base,
 			    psStream->ui32WPtr);
 	}
 
 	ui32NewWOffset = psStream->ui32Size - ui32SpaceInOldBuf;
 
-	if ((psStream->ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0) {
-		HostNonPageablePageFree((IMG_VOID *) psStream->ui32Base);
-	} else {
-		HostPageablePageFree((IMG_VOID *) psStream->ui32Base);
-	}
+	if ((psStream->ui32Flags & DEBUG_FLAGS_USE_NONPAGED_MEM) != 0)
+		HostNonPageablePageFree((void *) psStream->ui32Base);
+	else
+		HostPageablePageFree((void *) psStream->ui32Base);
 
-	psStream->ui32Base = (IMG_UINT32) pvNewBuf;
+	psStream->ui32Base = (u32) pvNewBuf;
 	psStream->ui32RPtr = 0;
 	psStream->ui32WPtr = ui32NewWOffset;
 	psStream->ui32Size = ui32NewSizeInPages * 4096;
@@ -1660,39 +1558,36 @@
 	return IMG_TRUE;
 }
 
-IMG_UINT32 SpaceInStream(PDBG_STREAM psStream)
+static u32 SpaceInStream(struct DBG_STREAM *psStream)
 {
-	IMG_UINT32 ui32Space;
+	u32 ui32Space;
 
-	if (psStream->ui32RPtr > psStream->ui32WPtr) {
+	if (psStream->ui32RPtr > psStream->ui32WPtr)
 		ui32Space = psStream->ui32RPtr - psStream->ui32WPtr;
-	} else {
+	else
 		ui32Space =
 		    psStream->ui32RPtr + (psStream->ui32Size -
 					  psStream->ui32WPtr);
-	}
 
 	return ui32Space;
 }
 
 void DestroyAllStreams(void)
 {
-	while (g_psStreamList != IMG_NULL) {
+	while (g_psStreamList != NULL)
 		DBGDrivDestroyStream(g_psStreamList);
-	}
 	return;
 }
 
-PDBG_LASTFRAME_BUFFER FindLFBuf(PDBG_STREAM psStream)
+struct DBG_LASTFRAME_BUFFER *FindLFBuf(struct DBG_STREAM *psStream)
 {
-	PDBG_LASTFRAME_BUFFER psLFBuffer;
+	struct DBG_LASTFRAME_BUFFER *psLFBuffer;
 
 	psLFBuffer = g_psLFBufferList;
 
 	while (psLFBuffer) {
-		if (psLFBuffer->psStream == psStream) {
+		if (psLFBuffer->psStream == psStream)
 			break;
-		}
 
 		psLFBuffer = psLFBuffer->psNext;
 	}
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/tools/dbgdriv.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/tools/dbgdriv.h
@@ -1,33 +1,33 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef _DBGDRIV_
 #define _DBGDRIV_
 
-#define BUFFER_SIZE 64*PAGESIZE
+#define BUFFER_SIZE (64 * PAGESIZE)
 
 #define DBGDRIV_VERSION 	0x100
 #define MAX_PROCESSES 		2
@@ -35,152 +35,152 @@
 #define BLOCK_LOCKED		0x02
 #define DBGDRIV_MONOBASE	0x000B0000
 
-extern IMG_VOID *g_pvAPIMutex;
+extern void *g_pvAPIMutex;
 
-IMG_VOID *IMG_CALLCONV DBGDrivCreateStream(IMG_CHAR * pszName,
-					   IMG_UINT32 ui32CapMode,
-					   IMG_UINT32 ui32OutMode,
-					   IMG_UINT32 ui32Flags,
-					   IMG_UINT32 ui32Pages);
-IMG_VOID IMG_CALLCONV DBGDrivDestroyStream(PDBG_STREAM psStream);
-IMG_VOID *IMG_CALLCONV DBGDrivFindStream(IMG_CHAR * pszName,
+void *DBGDrivCreateStream(char *pszName,
+					   u32 ui32CapMode,
+					   u32 ui32OutMode,
+					   u32 ui32Flags,
+					   u32 ui32Pages);
+void DBGDrivDestroyStream(struct DBG_STREAM *psStream);
+void *DBGDrivFindStream(char *pszName,
 					 IMG_BOOL bResetStream);
-IMG_UINT32 IMG_CALLCONV DBGDrivWriteString(PDBG_STREAM psStream,
-					   IMG_CHAR * pszString,
-					   IMG_UINT32 ui32Level);
-IMG_UINT32 IMG_CALLCONV DBGDrivReadString(PDBG_STREAM psStream,
-					  IMG_CHAR * pszString,
-					  IMG_UINT32 ui32Limit);
-IMG_UINT32 IMG_CALLCONV DBGDrivWrite(PDBG_STREAM psStream,
-				     IMG_UINT8 * pui8InBuf,
-				     IMG_UINT32 ui32InBuffSize,
-				     IMG_UINT32 ui32Level);
-IMG_UINT32 IMG_CALLCONV DBGDrivWrite2(PDBG_STREAM psStream,
-				      IMG_UINT8 * pui8InBuf,
-				      IMG_UINT32 ui32InBuffSize,
-				      IMG_UINT32 ui32Level);
-IMG_UINT32 IMG_CALLCONV DBGDrivRead(PDBG_STREAM psStream,
+u32 DBGDrivWriteString(struct DBG_STREAM *psStream,
+					   char *pszString,
+					   u32 ui32Level);
+u32 DBGDrivReadString(struct DBG_STREAM *psStream,
+					  char *pszString,
+					  u32 ui32Limit);
+u32 DBGDrivWrite(struct DBG_STREAM *psStream,
+				     u8 *pui8InBuf,
+				     u32 ui32InBuffSize,
+				     u32 ui32Level);
+u32 DBGDrivWrite2(struct DBG_STREAM *psStream,
+				      u8 *pui8InBuf,
+				      u32 ui32InBuffSize,
+				      u32 ui32Level);
+u32 DBGDrivRead(struct DBG_STREAM *psStream,
 				    IMG_BOOL bReadInitBuffer,
-				    IMG_UINT32 ui32OutBufferSize,
-				    IMG_UINT8 * pui8OutBuf);
-IMG_VOID IMG_CALLCONV DBGDrivSetCaptureMode(PDBG_STREAM psStream,
-					    IMG_UINT32 ui32Mode,
-					    IMG_UINT32 ui32Start,
-					    IMG_UINT32 ui32Stop,
-					    IMG_UINT32 ui32SampleRate);
-IMG_VOID IMG_CALLCONV DBGDrivSetOutputMode(PDBG_STREAM psStream,
-					   IMG_UINT32 ui32OutMode);
-IMG_VOID IMG_CALLCONV DBGDrivSetDebugLevel(PDBG_STREAM psStream,
-					   IMG_UINT32 ui32DebugLevel);
-IMG_VOID IMG_CALLCONV DBGDrivSetFrame(PDBG_STREAM psStream,
-				      IMG_UINT32 ui32Frame);
-IMG_UINT32 IMG_CALLCONV DBGDrivGetFrame(PDBG_STREAM psStream);
-IMG_VOID IMG_CALLCONV DBGDrivOverrideMode(PDBG_STREAM psStream,
-					  IMG_UINT32 ui32Mode);
-IMG_VOID IMG_CALLCONV DBGDrivDefaultMode(PDBG_STREAM psStream);
-IMG_UINT32 IMG_CALLCONV DBGDrivGetServiceTable(IMG_VOID);
-IMG_UINT32 IMG_CALLCONV DBGDrivWriteStringCM(PDBG_STREAM psStream,
-					     IMG_CHAR * pszString,
-					     IMG_UINT32 ui32Level);
-IMG_UINT32 IMG_CALLCONV DBGDrivWriteCM(PDBG_STREAM psStream,
-				       IMG_UINT8 * pui8InBuf,
-				       IMG_UINT32 ui32InBuffSize,
-				       IMG_UINT32 ui32Level);
-IMG_VOID IMG_CALLCONV DBGDrivSetMarker(PDBG_STREAM psStream,
-				       IMG_UINT32 ui32Marker);
-IMG_UINT32 IMG_CALLCONV DBGDrivGetMarker(PDBG_STREAM psStream);
-IMG_UINT32 IMG_CALLCONV DBGDrivIsLastCaptureFrame(PDBG_STREAM psStream);
-IMG_UINT32 IMG_CALLCONV DBGDrivIsCaptureFrame(PDBG_STREAM psStream,
+				    u32 ui32OutBufferSize,
+				    u8 *pui8OutBuf);
+void DBGDrivSetCaptureMode(struct DBG_STREAM *psStream,
+					    u32 ui32Mode,
+					    u32 ui32Start,
+					    u32 ui32Stop,
+					    u32 ui32SampleRate);
+void DBGDrivSetOutputMode(struct DBG_STREAM *psStream,
+					   u32 ui32OutMode);
+void DBGDrivSetDebugLevel(struct DBG_STREAM *psStream,
+					   u32 ui32DebugLevel);
+void DBGDrivSetFrame(struct DBG_STREAM *psStream,
+				      u32 ui32Frame);
+u32 DBGDrivGetFrame(struct DBG_STREAM *psStream);
+void DBGDrivOverrideMode(struct DBG_STREAM *psStream,
+					  u32 ui32Mode);
+void DBGDrivDefaultMode(struct DBG_STREAM *psStream);
+u32 DBGDrivGetServiceTable(void);
+u32 DBGDrivWriteStringCM(struct DBG_STREAM *psStream,
+					     char *pszString,
+					     u32 ui32Level);
+u32 DBGDrivWriteCM(struct DBG_STREAM *psStream,
+				       u8 *pui8InBuf,
+				       u32 ui32InBuffSize,
+				       u32 ui32Level);
+void DBGDrivSetMarker(struct DBG_STREAM *psStream,
+				       u32 ui32Marker);
+u32 DBGDrivGetMarker(struct DBG_STREAM *psStream);
+u32 DBGDrivIsLastCaptureFrame(struct DBG_STREAM *psStream);
+u32 DBGDrivIsCaptureFrame(struct DBG_STREAM *psStream,
 					      IMG_BOOL bCheckPreviousFrame);
-IMG_UINT32 IMG_CALLCONV DBGDrivWriteLF(PDBG_STREAM psStream,
-				       IMG_UINT8 * pui8InBuf,
-				       IMG_UINT32 ui32InBuffSize,
-				       IMG_UINT32 ui32Level,
-				       IMG_UINT32 ui32Flags);
-IMG_UINT32 IMG_CALLCONV DBGDrivReadLF(PDBG_STREAM psStream,
-				      IMG_UINT32 ui32OutBuffSize,
-				      IMG_UINT8 * pui8OutBuf);
-IMG_VOID IMG_CALLCONV DBGDrivEndInitPhase(PDBG_STREAM psStream);
-IMG_UINT32 IMG_CALLCONV DBGDrivGetStreamOffset(PDBG_STREAM psStream);
-IMG_VOID IMG_CALLCONV DBGDrivSetStreamOffset(PDBG_STREAM psStream,
-					     IMG_UINT32 ui32StreamOffset);
-
-IMG_VOID DestroyAllStreams(IMG_VOID);
-
-IMG_UINT32 AtoI(char *szIn);
-
-IMG_VOID HostMemSet(IMG_VOID * pvDest, IMG_UINT8 ui8Value, IMG_UINT32 ui32Size);
-IMG_VOID HostMemCopy(IMG_VOID * pvDest, IMG_VOID * pvSrc, IMG_UINT32 ui32Size);
-IMG_BOOL StreamValid(PDBG_STREAM psStream);
-IMG_VOID Write(PDBG_STREAM psStream, IMG_UINT8 * pui8Data,
-	       IMG_UINT32 ui32InBuffSize);
-IMG_VOID MonoOut(IMG_CHAR * pszString, IMG_BOOL bNewLine);
-
-IMG_VOID *IMG_CALLCONV ExtDBGDrivCreateStream(IMG_CHAR * pszName,
-					      IMG_UINT32 ui32CapMode,
-					      IMG_UINT32 ui32OutMode,
-					      IMG_UINT32 ui32Flags,
-					      IMG_UINT32 ui32Size);
-IMG_VOID IMG_CALLCONV ExtDBGDrivDestroyStream(PDBG_STREAM psStream);
-IMG_VOID *IMG_CALLCONV ExtDBGDrivFindStream(IMG_CHAR * pszName,
+u32 DBGDrivWriteLF(struct DBG_STREAM *psStream,
+				       u8 *pui8InBuf,
+				       u32 ui32InBuffSize,
+				       u32 ui32Level,
+				       u32 ui32Flags);
+u32 DBGDrivReadLF(struct DBG_STREAM *psStream,
+				      u32 ui32OutBuffSize,
+				      u8 *pui8OutBuf);
+void DBGDrivEndInitPhase(struct DBG_STREAM *psStream);
+u32 DBGDrivGetStreamOffset(struct DBG_STREAM *psStream);
+void DBGDrivSetStreamOffset(struct DBG_STREAM *psStream,
+					     u32 ui32StreamOffset);
+
+void DestroyAllStreams(void);
+
+u32 AtoI(char *szIn);
+
+void HostMemSet(void *pvDest, u8 ui8Value, u32 ui32Size);
+void HostMemCopy(void *pvDest, void *pvSrc, u32 ui32Size);
+IMG_BOOL StreamValid(struct DBG_STREAM *psStream);
+void Write(struct DBG_STREAM *psStream, u8 *pui8Data,
+	       u32 ui32InBuffSize);
+void MonoOut(char *pszString, IMG_BOOL bNewLine);
+
+void *ExtDBGDrivCreateStream(char *pszName,
+					      u32 ui32CapMode,
+					      u32 ui32OutMode,
+					      u32 ui32Flags,
+					      u32 ui32Size);
+void ExtDBGDrivDestroyStream(struct DBG_STREAM *psStream);
+void *ExtDBGDrivFindStream(char *pszName,
 					    IMG_BOOL bResetStream);
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivWriteString(PDBG_STREAM psStream,
-					      IMG_CHAR * pszString,
-					      IMG_UINT32 ui32Level);
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivReadString(PDBG_STREAM psStream,
-					     IMG_CHAR * pszString,
-					     IMG_UINT32 ui32Limit);
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivWrite(PDBG_STREAM psStream,
-					IMG_UINT8 * pui8InBuf,
-					IMG_UINT32 ui32InBuffSize,
-					IMG_UINT32 ui32Level);
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivRead(PDBG_STREAM psStream,
+u32 ExtDBGDrivWriteString(struct DBG_STREAM *psStream,
+					      char *pszString,
+					      u32 ui32Level);
+u32 ExtDBGDrivReadString(struct DBG_STREAM *psStream,
+					     char *pszString,
+					     u32 ui32Limit);
+u32 ExtDBGDrivWrite(struct DBG_STREAM *psStream,
+					u8 *pui8InBuf,
+					u32 ui32InBuffSize,
+					u32 ui32Level);
+u32 ExtDBGDrivRead(struct DBG_STREAM *psStream,
 				       IMG_BOOL bReadInitBuffer,
-				       IMG_UINT32 ui32OutBuffSize,
-				       IMG_UINT8 * pui8OutBuf);
-IMG_VOID IMG_CALLCONV ExtDBGDrivSetCaptureMode(PDBG_STREAM psStream,
-					       IMG_UINT32 ui32Mode,
-					       IMG_UINT32 ui32Start,
-					       IMG_UINT32 ui32End,
-					       IMG_UINT32 ui32SampleRate);
-IMG_VOID IMG_CALLCONV ExtDBGDrivSetOutputMode(PDBG_STREAM psStream,
-					      IMG_UINT32 ui32OutMode);
-IMG_VOID IMG_CALLCONV ExtDBGDrivSetDebugLevel(PDBG_STREAM psStream,
-					      IMG_UINT32 ui32DebugLevel);
-IMG_VOID IMG_CALLCONV ExtDBGDrivSetFrame(PDBG_STREAM psStream,
-					 IMG_UINT32 ui32Frame);
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivGetFrame(PDBG_STREAM psStream);
-IMG_VOID IMG_CALLCONV ExtDBGDrivOverrideMode(PDBG_STREAM psStream,
-					     IMG_UINT32 ui32Mode);
-IMG_VOID IMG_CALLCONV ExtDBGDrivDefaultMode(PDBG_STREAM psStream);
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivWrite2(PDBG_STREAM psStream,
-					 IMG_UINT8 * pui8InBuf,
-					 IMG_UINT32 ui32InBuffSize,
-					 IMG_UINT32 ui32Level);
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivWriteStringCM(PDBG_STREAM psStream,
-						IMG_CHAR * pszString,
-						IMG_UINT32 ui32Level);
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivWriteCM(PDBG_STREAM psStream,
-					  IMG_UINT8 * pui8InBuf,
-					  IMG_UINT32 ui32InBuffSize,
-					  IMG_UINT32 ui32Level);
-IMG_VOID IMG_CALLCONV ExtDBGDrivSetMarker(PDBG_STREAM psStream,
-					  IMG_UINT32 ui32Marker);
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivGetMarker(PDBG_STREAM psStream);
-IMG_VOID IMG_CALLCONV ExtDBGDrivEndInitPhase(PDBG_STREAM psStream);
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivIsLastCaptureFrame(PDBG_STREAM psStream);
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivIsCaptureFrame(PDBG_STREAM psStream,
+				       u32 ui32OutBuffSize,
+				       u8 *pui8OutBuf);
+void ExtDBGDrivSetCaptureMode(struct DBG_STREAM *psStream,
+					       u32 ui32Mode,
+					       u32 ui32Start,
+					       u32 ui32End,
+					       u32 ui32SampleRate);
+void ExtDBGDrivSetOutputMode(struct DBG_STREAM *psStream,
+					      u32 ui32OutMode);
+void ExtDBGDrivSetDebugLevel(struct DBG_STREAM *psStream,
+					      u32 ui32DebugLevel);
+void ExtDBGDrivSetFrame(struct DBG_STREAM *psStream,
+					 u32 ui32Frame);
+u32 ExtDBGDrivGetFrame(struct DBG_STREAM *psStream);
+void ExtDBGDrivOverrideMode(struct DBG_STREAM *psStream,
+					     u32 ui32Mode);
+void ExtDBGDrivDefaultMode(struct DBG_STREAM *psStream);
+u32 ExtDBGDrivWrite2(struct DBG_STREAM *psStream,
+					 u8 *pui8InBuf,
+					 u32 ui32InBuffSize,
+					 u32 ui32Level);
+u32 ExtDBGDrivWriteStringCM(struct DBG_STREAM *psStream,
+						char *pszString,
+						u32 ui32Level);
+u32 ExtDBGDrivWriteCM(struct DBG_STREAM *psStream,
+					  u8 *pui8InBuf,
+					  u32 ui32InBuffSize,
+					  u32 ui32Level);
+void ExtDBGDrivSetMarker(struct DBG_STREAM *psStream,
+					  u32 ui32Marker);
+u32 ExtDBGDrivGetMarker(struct DBG_STREAM *psStream);
+void ExtDBGDrivEndInitPhase(struct DBG_STREAM *psStream);
+u32 ExtDBGDrivIsLastCaptureFrame(struct DBG_STREAM *psStream);
+u32 ExtDBGDrivIsCaptureFrame(struct DBG_STREAM *psStream,
 						 IMG_BOOL bCheckPreviousFrame);
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivWriteLF(PDBG_STREAM psStream,
-					  IMG_UINT8 * pui8InBuf,
-					  IMG_UINT32 ui32InBuffSize,
-					  IMG_UINT32 ui32Level,
-					  IMG_UINT32 ui32Flags);
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivReadLF(PDBG_STREAM psStream,
-					 IMG_UINT32 ui32OutBuffSize,
-					 IMG_UINT8 * pui8OutBuf);
-IMG_UINT32 IMG_CALLCONV ExtDBGDrivGetStreamOffset(PDBG_STREAM psStream);
-IMG_VOID IMG_CALLCONV ExtDBGDrivSetStreamOffset(PDBG_STREAM psStream,
-						IMG_UINT32 ui32StreamOffset);
+u32 ExtDBGDrivWriteLF(struct DBG_STREAM *psStream,
+					  u8 *pui8InBuf,
+					  u32 ui32InBuffSize,
+					  u32 ui32Level,
+					  u32 ui32Flags);
+u32 ExtDBGDrivReadLF(struct DBG_STREAM *psStream,
+					 u32 ui32OutBuffSize,
+					 u8 *pui8OutBuf);
+u32 ExtDBGDrivGetStreamOffset(struct DBG_STREAM *psStream);
+void ExtDBGDrivSetStreamOffset(struct DBG_STREAM *psStream,
+						u32 ui32StreamOffset);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/tools/hostfunc.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/tools/hostfunc.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -36,24 +36,24 @@
 #include "img_types.h"
 #include "pvr_debug.h"
 
-IMG_UINT32 gPVRDebugLevel = DBGPRIV_WARNING;
+u32 gPVRDebugLevel = DBGPRIV_WARNING;
 
 #define PVR_STRING_TERMINATOR		'\0'
-#define PVR_IS_FILE_SEPARATOR(character) ( ((character) == '\\') || ((character) == '/') )
+#define PVR_IS_FILE_SEPARATOR(character) \
+	(((character) == '\\') || ((character) == '/'))
 
-void PVRSRVDebugPrintf(IMG_UINT32 ui32DebugLevel,
-		       const IMG_CHAR * pszFileName,
-		       IMG_UINT32 ui32Line, const IMG_CHAR * pszFormat, ...
+void PVRSRVDebugPrintf(u32 ui32DebugLevel,
+		       const char *pszFileName,
+		       u32 ui32Line, const char *pszFormat, ...
     )
 {
 	IMG_BOOL bTrace, bDebug;
-	IMG_CHAR *pszLeafName;
+	char *pszLeafName;
 
 	pszLeafName = (char *)strrchr(pszFileName, '\\');
 
-	if (pszLeafName) {
+	if (pszLeafName)
 		pszFileName = pszLeafName;
-	}
 
 	bTrace = gPVRDebugLevel & ui32DebugLevel & DBGPRIV_CALLTRACE;
 	bDebug = ((gPVRDebugLevel & DBGPRIV_ALLLEVELS) >= ui32DebugLevel);
@@ -104,10 +104,9 @@
 
 		vsprintf(&szBuffer[strlen(szBuffer)], pszFormat, vaArgs);
 
-		if (!bTrace) {
+		if (!bTrace)
 			sprintf(&szBuffer[strlen(szBuffer)], " [%d, %s]",
 				(int)ui32Line, pszFileName);
-		}
 
 		printk(KERN_INFO "%s\r\n", szBuffer);
 
@@ -115,78 +114,78 @@
 	}
 }
 
-IMG_VOID HostMemSet(IMG_VOID * pvDest, IMG_UINT8 ui8Value, IMG_UINT32 ui32Size)
+void HostMemSet(void *pvDest, u8 ui8Value, u32 ui32Size)
 {
 	memset(pvDest, (int)ui8Value, (size_t) ui32Size);
 }
 
-IMG_VOID HostMemCopy(IMG_VOID * pvDst, IMG_VOID * pvSrc, IMG_UINT32 ui32Size)
+void HostMemCopy(void *pvDst, void *pvSrc, u32 ui32Size)
 {
 	memcpy(pvDst, pvSrc, ui32Size);
 }
 
-IMG_UINT32 HostReadRegistryDWORDFromString(char *pcKey, char *pcValueName,
-					   IMG_UINT32 * pui32Data)
+u32 HostReadRegistryDWORDFromString(char *pcKey, char *pcValueName,
+					   u32 *pui32Data)
 {
 
 	return 0;
 }
 
-IMG_VOID *HostPageablePageAlloc(IMG_UINT32 ui32Pages)
+void *HostPageablePageAlloc(u32 ui32Pages)
 {
 	return (void *)vmalloc(ui32Pages * PAGE_SIZE);
 }
 
-IMG_VOID HostPageablePageFree(IMG_VOID * pvBase)
+void HostPageablePageFree(void *pvBase)
 {
 	vfree(pvBase);
 }
 
-IMG_VOID *HostNonPageablePageAlloc(IMG_UINT32 ui32Pages)
+void *HostNonPageablePageAlloc(u32 ui32Pages)
 {
 	return (void *)vmalloc(ui32Pages * PAGE_SIZE);
 }
 
-IMG_VOID HostNonPageablePageFree(IMG_VOID * pvBase)
+void HostNonPageablePageFree(void *pvBase)
 {
 	vfree(pvBase);
 }
 
-IMG_VOID *HostMapKrnBufIntoUser(IMG_VOID * pvKrnAddr, IMG_UINT32 ui32Size,
-				IMG_VOID ** ppvMdl)
+void *HostMapKrnBufIntoUser(void *pvKrnAddr, u32 ui32Size,
+				void **ppvMdl)
 {
 
-	return IMG_NULL;
+	return NULL;
 }
 
-IMG_VOID HostUnMapKrnBufFromUser(IMG_VOID * pvUserAddr, IMG_VOID * pvMdl,
-				 IMG_VOID * pvProcess)
+void HostUnMapKrnBufFromUser(void *pvUserAddr, void *pvMdl,
+				 void *pvProcess)
 {
 
 }
 
-IMG_VOID HostCreateRegDeclStreams(IMG_VOID)
+void HostCreateRegDeclStreams(void)
 {
 
 }
 
-IMG_VOID *HostCreateMutex(IMG_VOID)
+void *HostCreateMutex(void)
 {
 
-	return IMG_NULL;
+	return NULL;
 }
 
-IMG_VOID HostAquireMutex(IMG_VOID * pvMutex)
+void HostAquireMutex(void *pvMutex)
 {
 
 }
 
-IMG_VOID HostReleaseMutex(IMG_VOID * pvMutex)
+void HostReleaseMutex(void *pvMutex)
 {
 
 }
 
-IMG_VOID HostDestroyMutex(IMG_VOID * pvMutex)
+void HostDestroyMutex(void *pvMutex)
 {
 
 }
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/tools/hostfunc.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/tools/hostfunc.h
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -30,24 +30,22 @@
 #define HOST_PAGESIZE			(4096)
 #define DBG_MEMORY_INITIALIZER	(0xe2)
 
-IMG_UINT32 HostReadRegistryDWORDFromString(char *pcKey, char *pcValueName,
-					   IMG_UINT32 * pui32Data);
+u32 HostReadRegistryDWORDFromString(char *pcKey, char *pcValueName,
+					   u32 *pui32Data);
 
-IMG_VOID *HostPageablePageAlloc(IMG_UINT32 ui32Pages);
-IMG_VOID HostPageablePageFree(IMG_VOID * pvBase);
-IMG_VOID *HostNonPageablePageAlloc(IMG_UINT32 ui32Pages);
-IMG_VOID HostNonPageablePageFree(IMG_VOID * pvBase);
-
-IMG_VOID *HostMapKrnBufIntoUser(IMG_VOID * pvKrnAddr, IMG_UINT32 ui32Size,
-				IMG_VOID * *ppvMdl);
-IMG_VOID HostUnMapKrnBufFromUser(IMG_VOID * pvUserAddr, IMG_VOID * pvMdl,
-				 IMG_VOID * pvProcess);
-
-IMG_VOID HostCreateRegDeclStreams(IMG_VOID);
-
-IMG_VOID *HostCreateMutex(IMG_VOID);
-IMG_VOID HostAquireMutex(IMG_VOID * pvMutex);
-IMG_VOID HostReleaseMutex(IMG_VOID * pvMutex);
-IMG_VOID HostDestroyMutex(IMG_VOID * pvMutex);
+void *HostPageablePageAlloc(u32 ui32Pages);
+void HostPageablePageFree(void *pvBase);
+void *HostNonPageablePageAlloc(u32 ui32Pages);
+void HostNonPageablePageFree(void *pvBase);
+
+void *HostMapKrnBufIntoUser(void *pvKrnAddr, u32 ui32Size, void **ppvMdl);
+void HostUnMapKrnBufFromUser(void *pvUserAddr, void *pvMdl, void *pvProcess);
+
+void HostCreateRegDeclStreams(void);
+
+void *HostCreateMutex(void);
+void HostAquireMutex(void *pvMutex);
+void HostReleaseMutex(void *pvMutex);
+void HostDestroyMutex(void *pvMutex);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/tools/hotkey.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/tools/hotkey.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -31,13 +31,13 @@
 #include "hotkey.h"
 #include "hostfunc.h"
 
-IMG_UINT32 g_ui32HotKeyFrame = 0xFFFFFFFF;
+u32 g_ui32HotKeyFrame = 0xFFFFFFFF;
 IMG_BOOL g_bHotKeyPressed = IMG_FALSE;
 IMG_BOOL g_bHotKeyRegistered = IMG_FALSE;
 
-PRIVATEHOTKEYDATA g_PrivateHotKeyData;
+struct PRIVATEHOTKEYDATA g_PrivateHotKeyData;
 
-IMG_VOID ReadInHotKeys(IMG_VOID)
+void ReadInHotKeys(void)
 {
 	g_PrivateHotKeyData.ui32ScanCode = 0x58;
 	g_PrivateHotKeyData.ui32ShiftState = 0x0;
@@ -48,17 +48,17 @@
 					&g_PrivateHotKeyData.ui32ShiftState);
 }
 
-IMG_VOID RegisterKeyPressed(IMG_UINT32 dwui32ScanCode, PHOTKEYINFO pInfo)
+void RegisterKeyPressed(u32 dwui32ScanCode, struct HOTKEYINFO *pInfo)
 {
-	PDBG_STREAM psStream;
+	struct DBG_STREAM *psStream;
 
 	PVR_UNREFERENCED_PARAMETER(pInfo);
 
 	if (dwui32ScanCode == g_PrivateHotKeyData.ui32ScanCode) {
-		PVR_DPF((PVR_DBG_MESSAGE, "PDUMP Hotkey pressed !\n"));
+		PVR_DPF(PVR_DBG_MESSAGE, "PDUMP Hotkey pressed !\n");
 
-		psStream =
-		    (PDBG_STREAM) g_PrivateHotKeyData.sHotKeyInfo.pvStream;
+		psStream = (struct DBG_STREAM *)
+				g_PrivateHotKeyData.sHotKeyInfo.pvStream;
 
 		if (!g_bHotKeyPressed) {
 
@@ -69,15 +69,15 @@
 	}
 }
 
-IMG_VOID ActivateHotKeys(PDBG_STREAM psStream)
+void ActivateHotKeys(struct DBG_STREAM *psStream)
 {
 
 	ReadInHotKeys();
 
-	if (!g_PrivateHotKeyData.sHotKeyInfo.hHotKey) {
+	if (!g_PrivateHotKeyData.sHotKeyInfo.hHotKey)
 		if (g_PrivateHotKeyData.ui32ScanCode != 0) {
-			PVR_DPF((PVR_DBG_MESSAGE,
-				 "Activate HotKey for PDUMP.\n"));
+			PVR_DPF(PVR_DBG_MESSAGE,
+				 "Activate HotKey for PDUMP.\n");
 
 			g_PrivateHotKeyData.sHotKeyInfo.pvStream = psStream;
 
@@ -87,13 +87,12 @@
 		} else {
 			g_PrivateHotKeyData.sHotKeyInfo.hHotKey = 0;
 		}
-	}
 }
 
-IMG_VOID DeactivateHotKeys(IMG_VOID)
+void DeactivateHotKeys(void)
 {
 	if (g_PrivateHotKeyData.sHotKeyInfo.hHotKey != 0) {
-		PVR_DPF((PVR_DBG_MESSAGE, "Deactivate HotKey.\n"));
+		PVR_DPF(PVR_DBG_MESSAGE, "Deactivate HotKey.\n");
 
 		RemoveHotKey(g_PrivateHotKeyData.sHotKeyInfo.hHotKey);
 		g_PrivateHotKeyData.sHotKeyInfo.hHotKey = 0;
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/tools/hotkey.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/tools/hotkey.h
@@ -1,56 +1,60 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef _HOTKEY_
 #define _HOTKEY_
 
-typedef struct _hotkeyinfo {
-	IMG_UINT8 ui8ScanCode;
-	IMG_UINT8 ui8Type;
-	IMG_UINT8 ui8Flag;
-	IMG_UINT8 ui8Filler1;
-	IMG_UINT32 ui32ShiftState;
-	IMG_UINT32 ui32HotKeyProc;
-	IMG_VOID *pvStream;
-	IMG_UINT32 hHotKey;
-} HOTKEYINFO, *PHOTKEYINFO;
-
-typedef struct _privatehotkeydata {
-	IMG_UINT32 ui32ScanCode;
-	IMG_UINT32 ui32ShiftState;
-	HOTKEYINFO sHotKeyInfo;
-} PRIVATEHOTKEYDATA, *PPRIVATEHOTKEYDATA;
-
-IMG_VOID ReadInHotKeys(IMG_VOID);
-IMG_VOID ActivateHotKeys(PDBG_STREAM psStream);
-IMG_VOID DeactivateHotKeys(IMG_VOID);
-
-IMG_VOID RemoveHotKey(IMG_UINT32 hHotKey);
-IMG_VOID DefineHotKey(IMG_UINT32 ui32ScanCode, IMG_UINT32 ui32ShiftState,
-		      PHOTKEYINFO psInfo);
-IMG_VOID RegisterKeyPressed(IMG_UINT32 ui32ScanCode, PHOTKEYINFO psInfo);
+struct HOTKEYINFO {
+	u8 ui8ScanCode;
+	u8 ui8Type;
+	u8 ui8Flag;
+	u8 ui8Filler1;
+	u32 ui32ShiftState;
+	u32 ui32HotKeyProc;
+	void *pvStream;
+	u32 hHotKey;
+};
+
+struct PRIVATEHOTKEYDATA {
+	u32 ui32ScanCode;
+	u32 ui32ShiftState;
+	struct HOTKEYINFO sHotKeyInfo;
+};
+
+extern u32 g_ui32HotKeyFrame;
+extern IMG_BOOL g_bHotKeyPressed;
+extern IMG_BOOL g_bHotKeyRegistered;
+
+void ReadInHotKeys(void);
+void ActivateHotKeys(struct DBG_STREAM *psStream);
+void DeactivateHotKeys(void);
+
+void RemoveHotKey(u32 hHotKey);
+void DefineHotKey(u32 ui32ScanCode, u32 ui32ShiftState,
+		      struct HOTKEYINFO *psInfo);
+void RegisterKeyPressed(u32 ui32ScanCode, struct HOTKEYINFO *psInfo);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/tools/ioctl.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/tools/ioctl.c
@@ -1,45 +1,45 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #include "img_types.h"
 #include "dbgdrvif.h"
 #include "dbgdriv.h"
 #include "hotkey.h"
 
-IMG_UINT32 DBGDIOCDrivCreateStream(IMG_VOID * pvInBuffer,
-				   IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivCreateStream(void *pvInBuffer,
+				   void *pvOutBuffer)
 {
-	PDBG_IN_CREATESTREAM psIn;
-	IMG_VOID **ppvOut;
+	struct DBG_IN_CREATESTREAM *psIn;
+	void **ppvOut;
 	static char name[32];
 
-	psIn = (PDBG_IN_CREATESTREAM) pvInBuffer;
-	ppvOut = (IMG_VOID * *)pvOutBuffer;
+	psIn = (struct DBG_IN_CREATESTREAM *)pvInBuffer;
+	ppvOut = (void **)pvOutBuffer;
 
 
 	if (copy_from_user(name, psIn->pszName, 32) != 0)
@@ -49,318 +49,318 @@
 				   0, psIn->ui32Pages);
 
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivDestroyStream(IMG_VOID * pvInBuffer,
-				    IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivDestroyStream(void *pvInBuffer,
+				    void *pvOutBuffer)
 {
-	IMG_UINT32 *pStream;
-	PDBG_STREAM psStream;
+	u32 *pStream;
+	struct DBG_STREAM *psStream;
 
-	pStream = (IMG_UINT32 *) pvInBuffer;
-	psStream = (PDBG_STREAM) * pStream;
+	pStream = (u32 *) pvInBuffer;
+	psStream = (struct DBG_STREAM *)*pStream;
 
 	PVR_UNREFERENCED_PARAMETER(pvOutBuffer);
 
 	ExtDBGDrivDestroyStream(psStream);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivGetStream(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivGetStream(void *pvInBuffer, void *pvOutBuffer)
 {
-	PDBG_IN_FINDSTREAM psParams;
-	IMG_UINT32 *pui32Stream;
+	struct DBG_IN_FINDSTREAM *psParams;
+	u32 *pui32Stream;
 
-	psParams = (PDBG_IN_FINDSTREAM) pvInBuffer;
-	pui32Stream = (IMG_UINT32 *) pvOutBuffer;
+	psParams = (struct DBG_IN_FINDSTREAM *)pvInBuffer;
+	pui32Stream = (u32 *) pvOutBuffer;
 
 	*pui32Stream =
-	    (IMG_UINT32) ExtDBGDrivFindStream(psParams->pszName,
+	    (u32) ExtDBGDrivFindStream(psParams->pszName,
 					      psParams->bResetStream);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivWriteString(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivWriteString(void *pvInBuffer, void *pvOutBuffer)
 {
-	PDBG_IN_WRITESTRING psParams;
-	IMG_UINT32 *pui32OutLen;
+	struct DBG_IN_WRITESTRING *psParams;
+	u32 *pui32OutLen;
 
-	psParams = (PDBG_IN_WRITESTRING) pvInBuffer;
-	pui32OutLen = (IMG_UINT32 *) pvOutBuffer;
+	psParams = (struct DBG_IN_WRITESTRING *)pvInBuffer;
+	pui32OutLen = (u32 *) pvOutBuffer;
 
 	*pui32OutLen =
-	    ExtDBGDrivWriteString((PDBG_STREAM) psParams->pvStream,
+	    ExtDBGDrivWriteString((struct DBG_STREAM *)psParams->pvStream,
 				  psParams->pszString, psParams->ui32Level);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivWriteStringCM(IMG_VOID * pvInBuffer,
-				    IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivWriteStringCM(void *pvInBuffer,
+				    void *pvOutBuffer)
 {
-	PDBG_IN_WRITESTRING psParams;
-	IMG_UINT32 *pui32OutLen;
+	struct DBG_IN_WRITESTRING *psParams;
+	u32 *pui32OutLen;
 
-	psParams = (PDBG_IN_WRITESTRING) pvInBuffer;
-	pui32OutLen = (IMG_UINT32 *) pvOutBuffer;
+	psParams = (struct DBG_IN_WRITESTRING *)pvInBuffer;
+	pui32OutLen = (u32 *) pvOutBuffer;
 
 	*pui32OutLen =
-	    ExtDBGDrivWriteStringCM((PDBG_STREAM) psParams->pvStream,
+	    ExtDBGDrivWriteStringCM((struct DBG_STREAM *)psParams->pvStream,
 				    psParams->pszString, psParams->ui32Level);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivReadString(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivReadString(void *pvInBuffer, void *pvOutBuffer)
 {
-	IMG_UINT32 *pui32OutLen;
-	PDBG_IN_READSTRING psParams;
+	u32 *pui32OutLen;
+	struct DBG_IN_READSTRING *psParams;
 
-	psParams = (PDBG_IN_READSTRING) pvInBuffer;
-	pui32OutLen = (IMG_UINT32 *) pvOutBuffer;
+	psParams = (struct DBG_IN_READSTRING *)pvInBuffer;
+	pui32OutLen = (u32 *) pvOutBuffer;
 
 	*pui32OutLen =
 	    ExtDBGDrivReadString(psParams->pvStream, psParams->pszString,
 				 psParams->ui32StringLen);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivWrite(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivWrite(void *pvInBuffer, void *pvOutBuffer)
 {
-	IMG_UINT32 *pui32BytesCopied;
-	PDBG_IN_WRITE psInParams;
+	u32 *pui32BytesCopied;
+	struct DBG_IN_WRITE *psInParams;
 
-	psInParams = (PDBG_IN_WRITE) pvInBuffer;
-	pui32BytesCopied = (IMG_UINT32 *) pvOutBuffer;
+	psInParams = (struct DBG_IN_WRITE *)pvInBuffer;
+	pui32BytesCopied = (u32 *) pvOutBuffer;
 
 	*pui32BytesCopied =
-	    ExtDBGDrivWrite((PDBG_STREAM) psInParams->pvStream,
+	    ExtDBGDrivWrite((struct DBG_STREAM *)psInParams->pvStream,
 			    psInParams->pui8InBuffer,
 			    psInParams->ui32TransferSize,
 			    psInParams->ui32Level);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivWrite2(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivWrite2(void *pvInBuffer, void *pvOutBuffer)
 {
-	IMG_UINT32 *pui32BytesCopied;
-	PDBG_IN_WRITE psInParams;
+	u32 *pui32BytesCopied;
+	struct DBG_IN_WRITE *psInParams;
 
-	psInParams = (PDBG_IN_WRITE) pvInBuffer;
-	pui32BytesCopied = (IMG_UINT32 *) pvOutBuffer;
+	psInParams = (struct DBG_IN_WRITE *)pvInBuffer;
+	pui32BytesCopied = (u32 *) pvOutBuffer;
 
 	*pui32BytesCopied =
-	    ExtDBGDrivWrite2((PDBG_STREAM) psInParams->pvStream,
+	    ExtDBGDrivWrite2((struct DBG_STREAM *)psInParams->pvStream,
 			     psInParams->pui8InBuffer,
 			     psInParams->ui32TransferSize,
 			     psInParams->ui32Level);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivWriteCM(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivWriteCM(void *pvInBuffer, void *pvOutBuffer)
 {
-	IMG_UINT32 *pui32BytesCopied;
-	PDBG_IN_WRITE psInParams;
+	u32 *pui32BytesCopied;
+	struct DBG_IN_WRITE *psInParams;
 
-	psInParams = (PDBG_IN_WRITE) pvInBuffer;
-	pui32BytesCopied = (IMG_UINT32 *) pvOutBuffer;
+	psInParams = (struct DBG_IN_WRITE *)pvInBuffer;
+	pui32BytesCopied = (u32 *) pvOutBuffer;
 
 	*pui32BytesCopied =
-	    ExtDBGDrivWriteCM((PDBG_STREAM) psInParams->pvStream,
+	    ExtDBGDrivWriteCM((struct DBG_STREAM *)psInParams->pvStream,
 			      psInParams->pui8InBuffer,
 			      psInParams->ui32TransferSize,
 			      psInParams->ui32Level);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivRead(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivRead(void *pvInBuffer, void *pvOutBuffer)
 {
-	IMG_UINT32 *pui32BytesCopied;
-	PDBG_IN_READ psInParams;
+	u32 *pui32BytesCopied;
+	struct DBG_IN_READ *psInParams;
 
-	psInParams = (PDBG_IN_READ) pvInBuffer;
-	pui32BytesCopied = (IMG_UINT32 *) pvOutBuffer;
+	psInParams = (struct DBG_IN_READ *)pvInBuffer;
+	pui32BytesCopied = (u32 *) pvOutBuffer;
 
 	*pui32BytesCopied =
-	    ExtDBGDrivRead((PDBG_STREAM) psInParams->pvStream,
+	    ExtDBGDrivRead((struct DBG_STREAM *)psInParams->pvStream,
 			   psInParams->bReadInitBuffer,
 			   psInParams->ui32OutBufferSize,
 			   psInParams->pui8OutBuffer);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivSetCaptureMode(IMG_VOID * pvInBuffer,
-				     IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivSetCaptureMode(void *pvInBuffer,
+				     void *pvOutBuffer)
 {
-	PDBG_IN_SETDEBUGMODE psParams;
+	struct DBG_IN_SETDEBUGMODE *psParams;
 
-	psParams = (PDBG_IN_SETDEBUGMODE) pvInBuffer;
+	psParams = (struct DBG_IN_SETDEBUGMODE *)pvInBuffer;
 	PVR_UNREFERENCED_PARAMETER(pvOutBuffer);
 
-	ExtDBGDrivSetCaptureMode((PDBG_STREAM) psParams->pvStream,
+	ExtDBGDrivSetCaptureMode((struct DBG_STREAM *)psParams->pvStream,
 				 psParams->ui32Mode,
 				 psParams->ui32Start,
 				 psParams->ui32End, psParams->ui32SampleRate);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivSetOutMode(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivSetOutMode(void *pvInBuffer, void *pvOutBuffer)
 {
-	PDBG_IN_SETDEBUGOUTMODE psParams;
+	struct DBG_IN_SETDEBUGOUTMODE *psParams;
 
-	psParams = (PDBG_IN_SETDEBUGOUTMODE) pvInBuffer;
+	psParams = (struct DBG_IN_SETDEBUGOUTMODE *)pvInBuffer;
 	PVR_UNREFERENCED_PARAMETER(pvOutBuffer);
 
-	ExtDBGDrivSetOutputMode((PDBG_STREAM) psParams->pvStream,
+	ExtDBGDrivSetOutputMode((struct DBG_STREAM *)psParams->pvStream,
 				psParams->ui32Mode);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivSetDebugLevel(IMG_VOID * pvInBuffer,
-				    IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivSetDebugLevel(void *pvInBuffer,
+				    void *pvOutBuffer)
 {
-	PDBG_IN_SETDEBUGLEVEL psParams;
+	struct DBG_IN_SETDEBUGLEVEL *psParams;
 
-	psParams = (PDBG_IN_SETDEBUGLEVEL) pvInBuffer;
+	psParams = (struct DBG_IN_SETDEBUGLEVEL *)pvInBuffer;
 	PVR_UNREFERENCED_PARAMETER(pvOutBuffer);
 
-	ExtDBGDrivSetDebugLevel((PDBG_STREAM) psParams->pvStream,
+	ExtDBGDrivSetDebugLevel((struct DBG_STREAM *)psParams->pvStream,
 				psParams->ui32Level);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivSetFrame(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivSetFrame(void *pvInBuffer, void *pvOutBuffer)
 {
-	PDBG_IN_SETFRAME psParams;
+	struct DBG_IN_SETFRAME *psParams;
 
-	psParams = (PDBG_IN_SETFRAME) pvInBuffer;
+	psParams = (struct DBG_IN_SETFRAME *)pvInBuffer;
 	PVR_UNREFERENCED_PARAMETER(pvOutBuffer);
 
-	ExtDBGDrivSetFrame((PDBG_STREAM) psParams->pvStream,
+	ExtDBGDrivSetFrame((struct DBG_STREAM *)psParams->pvStream,
 			   psParams->ui32Frame);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivGetFrame(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivGetFrame(void *pvInBuffer, void *pvOutBuffer)
 {
-	IMG_UINT32 *pStream;
-	PDBG_STREAM psStream;
-	IMG_UINT32 *pui32Current;
-
-	pStream = (IMG_UINT32 *) pvInBuffer;
-	psStream = (PDBG_STREAM) * pStream;
-	pui32Current = (IMG_UINT32 *) pvOutBuffer;
+	u32 *pStream;
+	struct DBG_STREAM *psStream;
+	u32 *pui32Current;
+
+	pStream = (u32 *) pvInBuffer;
+	psStream = (struct DBG_STREAM *)*pStream;
+	pui32Current = (u32 *) pvOutBuffer;
 
 	*pui32Current = ExtDBGDrivGetFrame(psStream);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivIsCaptureFrame(IMG_VOID * pvInBuffer,
-				     IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivIsCaptureFrame(void *pvInBuffer,
+				     void *pvOutBuffer)
 {
-	PDBG_IN_ISCAPTUREFRAME psParams;
-	IMG_UINT32 *pui32Current;
+	struct DBG_IN_ISCAPTUREFRAME *psParams;
+	u32 *pui32Current;
 
-	psParams = (PDBG_IN_ISCAPTUREFRAME) pvInBuffer;
-	pui32Current = (IMG_UINT32 *) pvOutBuffer;
+	psParams = (struct DBG_IN_ISCAPTUREFRAME *)pvInBuffer;
+	pui32Current = (u32 *) pvOutBuffer;
 
 	*pui32Current =
-	    ExtDBGDrivIsCaptureFrame((PDBG_STREAM) psParams->pvStream,
+	    ExtDBGDrivIsCaptureFrame((struct DBG_STREAM *)psParams->pvStream,
 				     psParams->bCheckPreviousFrame);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivOverrideMode(IMG_VOID * pvInBuffer,
-				   IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivOverrideMode(void *pvInBuffer,
+				   void *pvOutBuffer)
 {
-	PDBG_IN_OVERRIDEMODE psParams;
+	struct DBG_IN_OVERRIDEMODE *psParams;
 
-	psParams = (PDBG_IN_OVERRIDEMODE) pvInBuffer;
+	psParams = (struct DBG_IN_OVERRIDEMODE *)pvInBuffer;
 	PVR_UNREFERENCED_PARAMETER(pvOutBuffer);
 
-	ExtDBGDrivOverrideMode((PDBG_STREAM) psParams->pvStream,
+	ExtDBGDrivOverrideMode((struct DBG_STREAM *)psParams->pvStream,
 			       psParams->ui32Mode);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivDefaultMode(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivDefaultMode(void *pvInBuffer, void *pvOutBuffer)
 {
-	IMG_UINT32 *pStream;
-	PDBG_STREAM psStream;
+	u32 *pStream;
+	struct DBG_STREAM *psStream;
 
-	pStream = (IMG_UINT32 *) pvInBuffer;
-	psStream = (PDBG_STREAM) * pStream;
+	pStream = (u32 *) pvInBuffer;
+	psStream = (struct DBG_STREAM *)*pStream;
 
 	PVR_UNREFERENCED_PARAMETER(pvOutBuffer);
 
 	ExtDBGDrivDefaultMode(psStream);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivSetMarker(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivSetMarker(void *pvInBuffer, void *pvOutBuffer)
 {
-	PDBG_IN_SETMARKER psParams;
+	struct DBG_IN_SETMARKER *psParams;
 
-	psParams = (PDBG_IN_SETMARKER) pvInBuffer;
+	psParams = (struct DBG_IN_SETMARKER *)pvInBuffer;
 	PVR_UNREFERENCED_PARAMETER(pvOutBuffer);
 
-	ExtDBGDrivSetMarker((PDBG_STREAM) psParams->pvStream,
+	ExtDBGDrivSetMarker((struct DBG_STREAM *)psParams->pvStream,
 			    psParams->ui32Marker);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivGetMarker(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivGetMarker(void *pvInBuffer, void *pvOutBuffer)
 {
-	IMG_UINT32 *pStream;
-	PDBG_STREAM psStream;
-	IMG_UINT32 *pui32Current;
-
-	pStream = (IMG_UINT32 *) pvInBuffer;
-	psStream = (PDBG_STREAM) * pStream;
-	pui32Current = (IMG_UINT32 *) pvOutBuffer;
+	u32 *pStream;
+	struct DBG_STREAM *psStream;
+	u32 *pui32Current;
+
+	pStream = (u32 *) pvInBuffer;
+	psStream = (struct DBG_STREAM *)*pStream;
+	pui32Current = (u32 *) pvOutBuffer;
 
 	*pui32Current = ExtDBGDrivGetMarker(psStream);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivGetServiceTable(IMG_VOID * pvInBuffer,
-				      IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivGetServiceTable(void *pvInBuffer,
+				      void *pvOutBuffer)
 {
-	IMG_UINT32 *pui32Out;
+	u32 *pui32Out;
 
 	PVR_UNREFERENCED_PARAMETER(pvInBuffer);
-	pui32Out = (IMG_UINT32 *) pvOutBuffer;
+	pui32Out = (u32 *) pvOutBuffer;
 
 	*pui32Out = DBGDrivGetServiceTable();
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivWriteLF(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivWriteLF(void *pvInBuffer, void *pvOutBuffer)
 {
-	PDBG_IN_WRITE_LF psInParams;
-	IMG_UINT32 *pui32BytesCopied;
+	struct DBG_IN_WRITE_LF *psInParams;
+	u32 *pui32BytesCopied;
 
-	psInParams = (PDBG_IN_WRITE_LF) pvInBuffer;
-	pui32BytesCopied = (IMG_UINT32 *) pvOutBuffer;
+	psInParams = (struct DBG_IN_WRITE_LF *)pvInBuffer;
+	pui32BytesCopied = (u32 *) pvOutBuffer;
 
 	*pui32BytesCopied = ExtDBGDrivWriteLF(psInParams->pvStream,
 					      psInParams->pui8InBuffer,
@@ -371,34 +371,34 @@
 	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivReadLF(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivReadLF(void *pvInBuffer, void *pvOutBuffer)
 {
-	IMG_UINT32 *pui32BytesCopied;
-	PDBG_IN_READ psInParams;
+	u32 *pui32BytesCopied;
+	struct DBG_IN_READ *psInParams;
 
-	psInParams = (PDBG_IN_READ) pvInBuffer;
-	pui32BytesCopied = (IMG_UINT32 *) pvOutBuffer;
+	psInParams = (struct DBG_IN_READ *)pvInBuffer;
+	pui32BytesCopied = (u32 *) pvOutBuffer;
 
 	*pui32BytesCopied =
-	    ExtDBGDrivReadLF((PDBG_STREAM) psInParams->pvStream,
+	    ExtDBGDrivReadLF((struct DBG_STREAM *)psInParams->pvStream,
 			     psInParams->ui32OutBufferSize,
 			     psInParams->pui8OutBuffer);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
 
-IMG_UINT32 DBGDIOCDrivResetStream(IMG_VOID * pvInBuffer, IMG_VOID * pvOutBuffer)
+u32 DBGDIOCDrivResetStream(void *pvInBuffer, void *pvOutBuffer)
 {
-	IMG_UINT32 *pui32BytesCopied;
-	PDBG_IN_READ psInParams;
+	u32 *pui32BytesCopied;
+	struct DBG_IN_READ *psInParams;
 
-	psInParams = (PDBG_IN_READ) pvInBuffer;
-	pui32BytesCopied = (IMG_UINT32 *) pvOutBuffer;
+	psInParams = (struct DBG_IN_READ *)pvInBuffer;
+	pui32BytesCopied = (u32 *) pvOutBuffer;
 
 	*pui32BytesCopied =
-	    ExtDBGDrivReadLF((PDBG_STREAM) psInParams->pvStream,
+	    ExtDBGDrivReadLF((struct DBG_STREAM *)psInParams->pvStream,
 			     psInParams->ui32OutBufferSize,
 			     psInParams->pui8OutBuffer);
 
-	return (IMG_TRUE);
+	return IMG_TRUE;
 }
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/tools/ioctl.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/tools/ioctl.h
@@ -1,58 +1,58 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef _IOCTL_
 #define _IOCTL_
 
-IMG_UINT32 DBGDIOCDrivCreateStream(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivDestroyStream(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivGetStream(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivWriteString(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivReadString(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivWrite(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivWrite2(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivRead(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivSetCaptureMode(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivSetOutMode(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivSetDebugLevel(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivSetFrame(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivGetFrame(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivOverrideMode(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivDefaultMode(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivGetServiceTable(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivWriteStringCM(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivWriteCM(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivSetMarker(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivGetMarker(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivIsCaptureFrame(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivWriteLF(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivReadLF(IMG_VOID *, IMG_VOID *);
-IMG_UINT32 DBGDIOCDrivResetStream(IMG_VOID *, IMG_VOID *);
+u32 DBGDIOCDrivCreateStream(void *, void *);
+u32 DBGDIOCDrivDestroyStream(void *, void *);
+u32 DBGDIOCDrivGetStream(void *, void *);
+u32 DBGDIOCDrivWriteString(void *, void *);
+u32 DBGDIOCDrivReadString(void *, void *);
+u32 DBGDIOCDrivWrite(void *, void *);
+u32 DBGDIOCDrivWrite2(void *, void *);
+u32 DBGDIOCDrivRead(void *, void *);
+u32 DBGDIOCDrivSetCaptureMode(void *, void *);
+u32 DBGDIOCDrivSetOutMode(void *, void *);
+u32 DBGDIOCDrivSetDebugLevel(void *, void *);
+u32 DBGDIOCDrivSetFrame(void *, void *);
+u32 DBGDIOCDrivGetFrame(void *, void *);
+u32 DBGDIOCDrivOverrideMode(void *, void *);
+u32 DBGDIOCDrivDefaultMode(void *, void *);
+u32 DBGDIOCDrivGetServiceTable(void *, void *);
+u32 DBGDIOCDrivWriteStringCM(void *, void *);
+u32 DBGDIOCDrivWriteCM(void *, void *);
+u32 DBGDIOCDrivSetMarker(void *, void *);
+u32 DBGDIOCDrivGetMarker(void *, void *);
+u32 DBGDIOCDrivIsCaptureFrame(void *, void *);
+u32 DBGDIOCDrivWriteLF(void *, void *);
+u32 DBGDIOCDrivReadLF(void *, void *);
+u32 DBGDIOCDrivResetStream(void *, void *);
 
-IMG_UINT32(*g_DBGDrivProc[])(IMG_VOID *, IMG_VOID *) = {
+u32(*g_DBGDrivProc[])(void *, void *) = {
 DBGDIOCDrivCreateStream,
 	    DBGDIOCDrivDestroyStream,
 	    DBGDIOCDrivGetStream,
@@ -76,6 +76,6 @@
 	    DBGDIOCDrivIsCaptureFrame,
 	    DBGDIOCDrivWriteLF, DBGDIOCDrivReadLF, DBGDIOCDrivResetStream,};
 
-#define MAX_DBGVXD_W32_API (sizeof(g_DBGDrivProc)/sizeof(IMG_UINT32))
+#define MAX_DBGVXD_W32_API (sizeof(g_DBGDrivProc)/sizeof(u32))
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/tools/linuxsrv.h
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/tools/linuxsrv.h
@@ -1,47 +1,47 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
 #ifndef _LINUXSRV_H__
 #define _LINUXSRV_H__
 
-typedef struct tagIOCTL_PACKAGE {
-	IMG_UINT32 ui32Cmd;
-	IMG_UINT32 ui32Size;
-	IMG_VOID *pInBuffer;
-	IMG_UINT32 ui32InBufferSize;
-	IMG_VOID *pOutBuffer;
-	IMG_UINT32 ui32OutBufferSize;
-} IOCTL_PACKAGE;
+struct IOCTL_PACKAGE {
+	u32 ui32Cmd;
+	u32 ui32Size;
+	void *pInBuffer;
+	u32 ui32InBufferSize;
+	void *pOutBuffer;
+	u32 ui32OutBufferSize;
+};
 
-IMG_UINT32 DeviceIoControl(IMG_UINT32 hDevice,
-			   IMG_UINT32 ui32ControlCode,
-			   IMG_VOID * pInBuffer,
-			   IMG_UINT32 ui32InBufferSize,
-			   IMG_VOID * pOutBuffer,
-			   IMG_UINT32 ui32OutBufferSize,
-			   IMG_UINT32 * pui32BytesReturned);
+u32 DeviceIoControl(u32 hDevice,
+			   u32 ui32ControlCode,
+			   void *pInBuffer,
+			   u32 ui32InBufferSize,
+			   void *pOutBuffer,
+			   u32 ui32OutBufferSize,
+			   u32 *pui32BytesReturned);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/drivers/gpu/pvr/tools/main.c
+++ kernel-maemo-2.6.28.old/drivers/gpu/pvr/tools/main.c
@@ -1,26 +1,26 @@
 /**********************************************************************
  *
  * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
- * 
- * This program is distributed in the hope it will be useful but, except 
- * as otherwise stated in writing, without any warranty; without even the 
- * implied warranty of merchantability or fitness for a particular purpose. 
+ *
+ * This program is distributed in the hope it will be useful but, except
+ * as otherwise stated in writing, without any warranty; without even the
+ * implied warranty of merchantability or fitness for a particular purpose.
  * See the GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License along with
  * this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution in
  * the file called "COPYING".
  *
  * Contact Information:
  * Imagination Technologies Ltd. <gpl-support@imgtec.com>
- * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK
  *
  ******************************************************************************/
 
@@ -33,7 +33,7 @@
 #include <linux/list.h>
 #include <linux/init.h>
 #include <linux/vmalloc.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #include "img_types.h"
 #include "linuxsrv.h"
@@ -49,11 +49,10 @@
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE(DRVNAME);
 
-static int AssignedMajorNumber = 0;
-
-extern DBGKM_SERVICE_TABLE g_sDBGKMServices;
+static int AssignedMajorNumber;
 
-int dbgdrv_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
+static int dbgdrv_ioctl(struct inode *, struct file *, unsigned int,
+			unsigned long);
 
 static int dbgdrv_open(struct inode unref__ * pInode,
 		       struct file unref__ * pFile)
@@ -72,12 +71,12 @@
 	return 0;
 }
 
-static struct file_operations dbgdrv_fops = {
-owner:	THIS_MODULE,
-ioctl:	dbgdrv_ioctl,
-open:	dbgdrv_open,
-release:dbgdrv_release,
-mmap:	dbgdrv_mmap,
+const static struct file_operations dbgdrv_fops = {
+	.owner		= THIS_MODULE,
+	.ioctl		= dbgdrv_ioctl,
+	.open		= dbgdrv_open,
+	.release	= dbgdrv_release,
+	.mmap		= dbgdrv_mmap,
 };
 
 void DBGDrvGetServiceTable(void **fn_table)
@@ -85,6 +84,7 @@
 	*fn_table = &g_sDBGKMServices;
 
 }
+EXPORT_SYMBOL(DBGDrvGetServiceTable);
 
 int init_module(void)
 {
@@ -92,7 +92,7 @@
 	    register_chrdev(AssignedMajorNumber, DRVNAME, &dbgdrv_fops);
 
 	if (AssignedMajorNumber <= 0) {
-		PVR_DPF((PVR_DBG_ERROR, " unable to get major\n"));
+		PVR_DPF(PVR_DBG_ERROR, " unable to get major\n");
 		return -EBUSY;
 	}
 
@@ -105,52 +105,50 @@
 	return;
 }
 
-int dbgdrv_ioctl(struct inode *inode, struct file *file,
+static int dbgdrv_ioctl(struct inode *inode, struct file *file,
 		 unsigned int cmd, unsigned long arg)
 {
-	IOCTL_PACKAGE *pIP = (IOCTL_PACKAGE *) arg;
+	struct IOCTL_PACKAGE *pIP = (struct IOCTL_PACKAGE *)arg;
 
 	char *buffer, *in, *out;
 
 	if ((pIP->ui32InBufferSize > (PAGE_SIZE >> 1))
 	    || (pIP->ui32OutBufferSize > (PAGE_SIZE >> 1))) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "Sizes of the buffers are too large, cannot do ioctl\n"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "Sizes of the buffers are too large, "
+			 "cannot do ioctl\n");
 		return -1;
 	}
 
 	buffer = (char *)HostPageablePageAlloc(1);
 	if (!buffer) {
-		PVR_DPF((PVR_DBG_ERROR,
-			 "Failed to allocate buffer, cannot do ioctl\n"));
+		PVR_DPF(PVR_DBG_ERROR,
+			 "Failed to allocate buffer, cannot do ioctl\n");
 		return -EFAULT;
 	}
 
 	in = buffer;
 	out = buffer + (PAGE_SIZE >> 1);
 
-	if (copy_from_user(in, pIP->pInBuffer, pIP->ui32InBufferSize) != 0) {
+	if (copy_from_user(in, pIP->pInBuffer, pIP->ui32InBufferSize) != 0)
 		goto init_failed;
-	}
 
 	cmd = ((pIP->ui32Cmd >> 2) & 0xFFF) - 0x801;
 
 	if (pIP->ui32Cmd == DEBUG_SERVICE_READ) {
-		IMG_CHAR *ui8Tmp;
-		IMG_UINT32 *pui32BytesCopied = (IMG_UINT32 *) out;
-		DBG_IN_READ *psReadInParams = (DBG_IN_READ *) in;
+		char *ui8Tmp;
+		u32 *pui32BytesCopied = (u32 *) out;
+		struct DBG_IN_READ *psReadInParams = (struct DBG_IN_READ *)in;
 
 		ui8Tmp = vmalloc(psReadInParams->ui32OutBufferSize);
-		if (!ui8Tmp) {
+		if (!ui8Tmp)
 			goto init_failed;
-		}
-		*pui32BytesCopied =
-		    ExtDBGDrivRead((DBG_STREAM *) psReadInParams->pvStream,
+		*pui32BytesCopied = ExtDBGDrivRead((struct DBG_STREAM *)
+				   psReadInParams->pvStream,
 				   psReadInParams->bReadInitBuffer,
 				   psReadInParams->ui32OutBufferSize, ui8Tmp);
-		if (copy_to_user
-		    (psReadInParams->pui8OutBuffer, ui8Tmp,
-		     *pui32BytesCopied) != 0) {
+		if (copy_to_user(psReadInParams->pui8OutBuffer, ui8Tmp,
+				 *pui32BytesCopied) != 0) {
 			vfree(ui8Tmp);
 			goto init_failed;
 		}
@@ -159,15 +157,14 @@
 		(g_DBGDrivProc[cmd]) (in, out);
 	}
 
-	if (copy_to_user(pIP->pOutBuffer, out, pIP->ui32OutBufferSize) != 0) {
+	if (copy_to_user(pIP->pOutBuffer, out, pIP->ui32OutBufferSize) != 0)
 		goto init_failed;
-	}
 
-	HostPageablePageFree((IMG_VOID *) buffer);
+	HostPageablePageFree((void *) buffer);
 	return 0;
 
 init_failed:
-	HostPageablePageFree((IMG_VOID *) buffer);
+	HostPageablePageFree((void *) buffer);
 	return -EFAULT;
 }
 
@@ -181,4 +178,3 @@
 
 }
 
-EXPORT_SYMBOL(DBGDrvGetServiceTable);
--- kernel-maemo-2.6.28.old.orig/drivers/i2c/chips/lis302dl.c
+++ kernel-maemo-2.6.28.old/drivers/i2c/chips/lis302dl.c
@@ -793,6 +793,11 @@
 	lis302dl_unregister_sysfs(client);
 	free_irq(gpio_to_irq(chip->irq1), chip);
 	gpio_free(chip->irq1);
+
+	cancel_delayed_work_sync(&chip->poweroff_work);
+	cancel_work_sync(&chip->work1);
+	lis302dl_power(chip, 0);
+
 	kfree(chip);
 
 	return 0;
--- kernel-maemo-2.6.28.old.orig/drivers/i2c/chips/twl4030-poweroff.c
+++ kernel-maemo-2.6.28.old/drivers/i2c/chips/twl4030-poweroff.c
@@ -33,6 +33,13 @@
 
 #define TWL4030_WATCHDOG_CFG_REG_OFFS   0x3
 
+static u8 twl4030_usb_suspended;
+
+void twl4030_upd_usb_suspended(u8 suspended)
+{
+	twl4030_usb_suspended = suspended;
+}
+
 static void twl4030_poweroff(void)
 {
 	u8 val;
@@ -44,7 +51,7 @@
 		printk(KERN_WARNING "I2C error %d while reading TWL4030"
 				    " PM_MASTER HW_CONDITIONS\n", err);
 
-	if (val & STS_VBUS) {
+	if ((val & STS_VBUS) && !twl4030_usb_suspended) {
 		printk(KERN_EMERG "twl4030-poweroff: VBUS on,"
 				  " forcing restart!\n");
 		/* Set watchdog, Triton goes to WAIT-ON state.
--- kernel-maemo-2.6.28.old.orig/drivers/media/video/isp/isp.c
+++ kernel-maemo-2.6.28.old/drivers/media/video/isp/isp.c
@@ -775,6 +775,10 @@
 		bufs->wait_hs_vs--;
 	if (irqstatus & HS_VS && bufs->wait_stats && !bufs->wait_hs_vs)
 		bufs->wait_stats = 0;
+
+	if (irqstatus & LSC_PRE_ERR)
+		ispccdc_lsc_error_handler(&isp->isp_ccdc);
+
 	/*
 	 * We need to wait for the first HS_VS interrupt from CCDC.
 	 * Otherwise our frame (and everything else) might be bad.
@@ -834,7 +838,6 @@
 	if (irqstatus & LSC_PRE_ERR) {
 		/* Mark buffer faulty. */
 		buf->vb_state = VIDEOBUF_ERROR;
-		ispccdc_lsc_error_handler(&isp->isp_ccdc);
 		dev_dbg(dev, "lsc prefetch error\n");
 	}
 
--- kernel-maemo-2.6.28.old.orig/drivers/media/video/isp/ispccdc.c
+++ kernel-maemo-2.6.28.old/drivers/media/video/isp/ispccdc.c
@@ -601,7 +601,17 @@
 
 void ispccdc_lsc_error_handler(struct isp_ccdc_device *isp_ccdc)
 {
+	/*
+	 * From OMAP3 TRM: When this event is pending, the module
+	 * goes into transparent mode (output =input). Normal
+	 * operation can be resumed at the start of the next frame
+	 * after:
+	 *  1) Clearing this event
+	 *  2) Disabling the LSC module
+	 *  3) Enabling it
+	 */
 	ispccdc_enable_lsc(isp_ccdc, 0);
+	ispccdc_enable_lsc(isp_ccdc, 1);
 }
 
 /**
--- kernel-maemo-2.6.28.old.orig/drivers/media/video/isp/ispresizer.c
+++ kernel-maemo-2.6.28.old/drivers/media/video/isp/ispresizer.c
@@ -287,6 +287,60 @@
 }
 
 /**
+ * ispresizer_adjust_bandwidth - Reduces read bandwidth when scaling up.
+ * Otherwise there will be SBL overflows.
+ *
+ * The ISP read speed is 256.0 / max(256, 1024 * ISPSBL_SDR_REQ_EXP). This
+ * formula is correct, no matter what the TRM says. Thus, the first
+ * step to use is 0.25 (REQ_EXP=1).
+ *
+ * Ratios:
+ * 0 = 1.0
+ * 1 = 0.25
+ * 2 = 0.125
+ * 3 = 0.083333...
+ * 4 = 0.0625
+ * 5 = 0.05 and so on...
+ *
+ * TRM says that read bandwidth should be no more than 83MB/s, half
+ * of the maximum of 166MB/s.
+ *
+ * HOWEVER, the read speed must be chosen so that the resizer always
+ * has time to process the frame before the next frame comes in.
+ * Failure to do so will result in a pile-up and endless "resizer busy!"
+ * messages.
+ *
+ * Zoom ratio must not exceed 4.0. This is checked in
+ * ispresizer_check_crop_boundaries().
+ **/
+static void ispresizer_adjust_bandwidth(struct isp_res_device *isp_res,
+					struct isp_pipeline *pipe)
+{
+	struct device *dev = to_device(isp_res);
+
+	/* Table for dividers. This allows hand tuning. */
+	static const unsigned char area_to_divider[] = {
+		0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 5, 5
+	     /* 1........2...........3.......................4 Zoom level */
+	};
+	unsigned int input_area = pipe->rsz_crop.width * pipe->rsz_crop.height;
+	unsigned int output_area = pipe->rsz_out_w * pipe->rsz_out_h;
+
+	if (input_area < output_area && input_area > 0) {
+		u32 val = area_to_divider[output_area / input_area - 1];
+		DPRINTK_ISPRESZ("%s: area factor = %i, val = %i\n",
+				__func__, output_area / input_area, val);
+		isp_reg_writel(dev, val << ISPSBL_SDR_REQ_RSZ_EXP_SHIFT,
+			       OMAP3_ISP_IOMEM_SBL, ISPSBL_SDR_REQ_EXP);
+	} else {
+		/* Required input bandwidth greater than output, no limit. */
+		DPRINTK_ISPRESZ("%s: resetting\n", __func__);
+		isp_reg_writel(dev, 0, OMAP3_ISP_IOMEM_SBL,
+			       ISPSBL_SDR_REQ_EXP);
+	}
+}
+
+/**
  * ispresizer_try_size - Validates input and output images size.
  * @input_w: input width for the resizer in number of pixels per line
  * @input_h: input height for the resizer in number of lines
@@ -472,6 +526,9 @@
 	if (rval)
 		return rval;
 
+	/* Set read bandwidth */
+	ispresizer_adjust_bandwidth(isp_res, pipe);
+
 	/* Set Resizer input address and offset adderss */
 	ispresizer_config_inlineoffset(isp_res,
 				       pipe->prv_out_w * ISP_BYTES_PER_PIXEL);
--- kernel-maemo-2.6.28.old.orig/drivers/media/video/isp/ispstat.c
+++ kernel-maemo-2.6.28.old/drivers/media/video/isp/ispstat.c
@@ -71,6 +71,7 @@
 	spin_lock_irqsave(&stat->lock, flags);
 
 	if (stat->active_buf) {
+		spin_unlock_irqrestore(&stat->lock, flags);
 		dev_dbg(stat->dev, "%s: new buffer requested without queuing "
 				   "active one.\n", stat->tag);
 		return stat->active_buf;
--- kernel-maemo-2.6.28.old.orig/drivers/media/video/isp/omap_previewer_hack.c
+++ kernel-maemo-2.6.28.old/drivers/media/video/isp/omap_previewer_hack.c
@@ -486,6 +486,21 @@
 	if (vb->memory == V4L2_MEMORY_MMAP)
 		return 0;
 
+	if (current->flags & PF_EXITING) {
+		/*
+		 * task is getting shutdown.
+		 * current->mm could have been released.
+		 *
+		 * For locking, we return error.
+		 * For unlocking, the subsequent release of
+		 * buffer should set things right
+		 */
+		if (lock)
+			return -EINVAL;
+		else
+			return 0;
+	}
+
 	end = vb->baddr + vb->bsize;
 
 	down_write(&current->mm->mmap_sem);
--- kernel-maemo-2.6.28.old.orig/drivers/media/video/omap34xxcam.c
+++ kernel-maemo-2.6.28.old/drivers/media/video/omap34xxcam.c
@@ -1384,7 +1384,8 @@
 	pix_out.height = frms->discrete.height;
 	pix_out.pixelformat = frms->pixel_format;
 
-	ival = vdev->want_timeperframe;
+	ival.numerator = 0;
+	ival.denominator = 0;
 	rval = try_pix_parm(vdev, &pix_in, &pix_out, &ival);
 	if (rval < 0)
 		goto done;
--- kernel-maemo-2.6.28.old.orig/drivers/mfd/twl4030-power.c
+++ kernel-maemo-2.6.28.old/drivers/mfd/twl4030-power.c
@@ -74,6 +74,18 @@
 #define R_VIO_OSC		0x52
 #define EXT_FS_CLK_EN		(0x1 << 6)
 
+#define R_WDT_CFG		0x03
+#define WDT_WRK_TIMEOUT		0x03
+
+#define R_UNLOCK_TEST_REG	0x12
+#define TWL_EEPROM_R_UNLOCK	0x49
+
+#define TWL_SIL_TYPE(rev)	((rev) & 0x00FFFFFF)
+#define TWL_SIL_REV(rev)	((rev) >> 24)
+#define TWL_SIL_5030		0x09002F
+#define TWL_REV_1_0		0x00
+#define TWL_REV_1_1		0x10
+
 /* resource configuration registers */
 
 #define DEVGROUP_OFFSET		0
@@ -486,13 +498,24 @@
 {
 	u8 val;
 	u8 reg[]={R_VDD1_OSC, R_VDD2_OSC, R_VIO_OSC};
+	u8 wdt_orig = 0;
 	int i;
-	int err = 0;
+	int err;
+	/* Setup the twl wdt to take care of borderline failure case */
+	err = twl4030_i2c_read_u8(TWL4030_MODULE_PM_RECEIVER, &wdt_orig,
+			R_WDT_CFG);
+	err |= twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, WDT_WRK_TIMEOUT,
+			R_WDT_CFG);
+
 	for (i = 0; i < sizeof(reg); i++) {
 		err |= twl4030_i2c_read_u8(TWL4030_MODULE_PM_RECEIVER, &val, reg[i]);
 		val |= EXT_FS_CLK_EN;
 		err |= twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, val, reg[i]);
 	}
+
+	/* restore the original value */
+	err |= twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, wdt_orig,
+			R_WDT_CFG);
 	if (err)
 		pr_warning("TWL4030: workaround setup failed!\n");
 }
@@ -502,14 +525,41 @@
 	int err = 0;
 	int i;
 	struct twl4030_resconfig *resconfig;
+	u32 twl4030_rev = 0;
+	bool apply_workaround = 0;
 
 	err = twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER, KEY_1,
 				R_PROTECT_KEY);
 	err |= twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER, KEY_2,
 				R_PROTECT_KEY);
 	if (err)
-		printk(KERN_ERR
-			"TWL4030 Unable to unlock registers\n");
+		pr_err("TWL4030 Unable to unlock registers\n");
+
+	err = twl4030_i2c_write_u8(TWL4030_MODULE_INTBR, TWL_EEPROM_R_UNLOCK,
+			R_UNLOCK_TEST_REG);
+	if (err)
+		pr_err("TWL4030 Unable to unlock IDCODE registers\n");
+
+	err = twl4030_i2c_read(TWL4030_MODULE_INTBR, (u8 *)(&twl4030_rev),
+			0x0, 4);
+	if (err)
+		pr_err("TWL4030: unable to read IDCODE-%d\n", err);
+
+	err = twl4030_i2c_write_u8(TWL4030_MODULE_INTBR, 0x0,
+			R_UNLOCK_TEST_REG);
+	if (err)
+		pr_err("TWL4030 Unable to relock IDCODE registers\n");
+
+	/* introduce workaround based on TWL4030 revision */
+	if ((TWL_SIL_TYPE(twl4030_rev) == TWL_SIL_5030) &&
+		(TWL_SIL_REV(twl4030_rev) <= TWL_REV_1_1))
+		apply_workaround = 1;
+
+	if (apply_workaround) {
+		pr_err("TWL5030: Enabling workaround for rev 0x%04X\n",
+				twl4030_rev);
+		twl_workaround();
+	}
 
 	for (i = 0; i < triton2_scripts->scripts_size; i++) {
 		err = load_triton_script(triton2_scripts->scripts[i]);
@@ -532,8 +582,6 @@
 		}
 	}
 
-	/* TODO: introduce workaround based on TWL4030 revision */
-	twl_workaround();
 	if (twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER, 0, R_PROTECT_KEY))
 		printk(KERN_ERR
 			"TWL4030 Unable to relock registers\n");
--- kernel-maemo-2.6.28.old.orig/drivers/misc/nokia-av.c
+++ kernel-maemo-2.6.28.old/drivers/misc/nokia-av.c
@@ -273,7 +273,7 @@
 
 #define THRESHOLD_GROUNDED	40
 #define THRESHOLD_VIDEO_HI	150
-#define THRESHOLD_HEADSET_HI	200
+#define THRESHOLD_HEADSET_HI	1000
 #define THRESHOLD_ECI_LO	1950
 #define THRESHOLD_ECI_HI	2200
 
--- kernel-maemo-2.6.28.old.orig/drivers/misc/ssi-char/ssi-char.c
+++ kernel-maemo-2.6.28.old/drivers/misc/ssi-char/ssi-char.c
@@ -171,10 +171,14 @@
 	ssize_t ret;
 
 	/* only 32bit data is supported for now */
-	if ((count < 4) || (count & 3))
+	if ((count < 4) || (count & 3) || (count > 0x10000))
 		return -EINVAL;
 
 	data = kmalloc(count, GFP_ATOMIC);
+	if (!data) {
+		pr_err("SSI-CHAR: memory allocation failed.\n");
+		return -ENOMEM;
+	}
 
 	ret = if_ssi_read(ch, data, count);
 	if (ret < 0) {
@@ -212,7 +216,7 @@
 			ret = -EAGAIN;
 			goto out;
 		} else if (signal_pending(current)) {
-			ret = -EAGAIN;
+			ret = -EINTR;
 			if_ssi_cancel_read(ch);
 			break;
 		}
@@ -247,10 +251,14 @@
 	ssize_t ret;
 
 	/* only 32bit data is supported for now */
-	if ((count < 4) || (count & 3))
+	if ((count < 4) || (count & 3) || (count > 0x10000))
 		return -EINVAL;
 
 	data = kmalloc(count, GFP_ATOMIC);
+	if (!data) {
+		pr_err("SSI-CHAR: memory allocation failed.\n");
+		return -ENOMEM;
+	}
 
 	if (copy_from_user(data, (void __user *)buf, count)) {
 		ret = -EFAULT;
@@ -295,8 +303,9 @@
 			ret = -EAGAIN;
 			goto out;
 		} else if (signal_pending(current)) {
-			ret = -ERESTARTSYS;
-			goto out;
+			ret = -EINTR;
+			if_ssi_cancel_write(ch);
+			break;
 		}
 
 		schedule();
--- kernel-maemo-2.6.28.old.orig/drivers/misc/ssi-char/ssi-if.c
+++ kernel-maemo-2.6.28.old/drivers/misc/ssi-char/ssi-if.c
@@ -96,7 +96,6 @@
 
 struct if_ssi_iface {
 	struct if_ssi_channel channels[SSI_MAX_CHAR_DEVS];
-	int bootstrap;
 	spinlock_t lock;
 };
 
@@ -168,9 +167,7 @@
 	struct if_ssi_channel *channel;
 	int ret = 0;
 	channel = &ssi_iface.channels[ch];
-	spin_lock_bh(&ssi_iface.lock);
 	ret = ssi_poll(channel->dev);
-	spin_unlock_bh(&ssi_iface.lock);
 	return ret;
 }
 
@@ -569,7 +566,6 @@
 	if (port >= SSI_MAX_PORTS)
 		return -EINVAL;
 
-	ssi_iface.bootstrap = 1;
 	spin_lock_init(&ssi_iface.lock);
 
 	for (i = 0; i < SSI_MAX_PORTS; i++)
--- kernel-maemo-2.6.28.old.orig/drivers/misc/ssi-char/ssi-if.h
+++ kernel-maemo-2.6.28.old/drivers/misc/ssi-char/ssi-if.h
@@ -52,7 +52,6 @@
 void if_ssi_send_break(int ch);
 void if_ssi_flush_rx(int ch);
 void if_ssi_flush_tx(int ch);
-void if_ssi_bootstrap(int ch);
 void if_ssi_set_wakeline(int ch, unsigned int state);
 void if_ssi_get_wakeline(int ch, unsigned int *state);
 int if_ssi_set_rx(int ch, struct ssi_rx_config *cfg);
--- kernel-maemo-2.6.28.old.orig/drivers/misc/ssi/ssi_driver_if.c
+++ kernel-maemo-2.6.28.old/drivers/misc/ssi/ssi_driver_if.c
@@ -47,6 +47,9 @@
 			(cfg->channels != NOT_SET)))
 		return -EINVAL;
 
+	if ((cfg->channels & (-cfg->channels)) ^ cfg->channels)
+		return -EINVAL;
+
 	if ((cfg->timeout > SSI_MAX_RX_TIMEOUT) && (cfg->timeout != NOT_SET))
 		return -EINVAL;
 
@@ -57,11 +60,7 @@
 		ssi_outl(cfg->frame_size, base, SSI_SSR_FRAMESIZE_REG(port));
 
 	if (cfg->channels != NOT_SET) {
-		if ((cfg->channels & (-cfg->channels)) ^ cfg->channels)
-			return -EINVAL;
-		else
-			ssi_outl(cfg->channels, base,
-					SSI_SSR_CHANNELS_REG(port));
+		ssi_outl(cfg->channels, base, SSI_SSR_CHANNELS_REG(port));
 	}
 
 	if (cfg->timeout != NOT_SET)
@@ -102,6 +101,9 @@
 			(cfg->channels != NOT_SET)))
 		return -EINVAL;
 
+	if ((cfg->channels & (-cfg->channels)) ^ cfg->channels)
+		return -EINVAL;
+
 	if ((cfg->divisor > SSI_MAX_TX_DIVISOR) && (cfg->divisor != NOT_SET))
 		return -EINVAL;
 
@@ -111,17 +113,14 @@
 		return -EINVAL;
 
 	if (cfg->mode != NOT_SET)
-		ssi_outl(cfg->channels, base, SSI_SST_CHANNELS_REG(port));
+		ssi_outl(cfg->mode, base, SSI_SST_MODE_REG(port));
 
 	if (cfg->frame_size != NOT_SET)
 		ssi_outl(cfg->frame_size, base, SSI_SST_FRAMESIZE_REG(port));
 
-	if (cfg->channels != NOT_SET) {
-		if ((cfg->channels & (-cfg->channels)) ^ cfg->channels)
-			return -EINVAL;
-		else
-			ssi_outl(cfg->mode, base, SSI_SST_MODE_REG(port));
-	}
+	if (cfg->channels != NOT_SET)
+		ssi_outl(cfg->channels, base, SSI_SST_CHANNELS_REG(port));
+
 
 	if (cfg->divisor != NOT_SET)
 		ssi_outl(cfg->divisor, base, SSI_SST_DIVISOR_REG(port));
@@ -485,6 +484,7 @@
 			goto out;
 		}
 		ssi_get_tx(dev->ch->ssi_port, (struct sst_ctx *)arg);
+		break;
 	case SSI_IOCTL_TX_CH_FULL:
 		if (!arg) {
 			err = -EINVAL;
--- kernel-maemo-2.6.28.old.orig/drivers/mtd/ubi/cdev.c
+++ kernel-maemo-2.6.28.old/drivers/mtd/ubi/cdev.c
@@ -790,7 +790,6 @@
 			break;
 		}
 
-		req.name[req.name_len] = '\0';
 		err = verify_mkvol_req(ubi, &req);
 		if (err)
 			break;
--- kernel-maemo-2.6.28.old.orig/drivers/net/wireless/wl12xx/wl1251.h
+++ kernel-maemo-2.6.28.old/drivers/net/wireless/wl12xx/wl1251.h
@@ -248,6 +248,7 @@
 	struct dentry *rxpipe_tx_xfr_host_int_trig_rx_data;
 
 	struct dentry *tx_queue_len;
+	struct dentry *tx_queue_status;
 
 	struct dentry *retry_count;
 	struct dentry *excessive_retries;
--- kernel-maemo-2.6.28.old.orig/drivers/net/wireless/wl12xx/wl1251_acx.c
+++ kernel-maemo-2.6.28.old/drivers/net/wireless/wl12xx/wl1251_acx.c
@@ -1104,3 +1104,72 @@
 	kfree(acx);
 	return ret;
 }
+
+int wl1251_acx_ac_cfg(struct wl1251 *wl, u8 ac, u8 cw_min, u16 cw_max,
+		      u8 aifs, u16 txop)
+{
+	struct wl1251_acx_ac_cfg *acx;
+	int ret = 0;
+
+	wl1251_debug(DEBUG_ACX, "acx ac cfg %d cw_ming %d cw_max %d "
+		     "aifs %d txop %d", ac, cw_min, cw_max, aifs, txop);
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx->ac = ac;
+	acx->cw_min = cw_min;
+	acx->cw_max = cw_max;
+	acx->aifsn = aifs;
+	acx->txop_limit = txop;
+
+	ret = wl1251_cmd_configure(wl, ACX_AC_CFG, acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1251_warning("acx ac cfg failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1251_acx_tid_cfg(struct wl1251 *wl, u8 queue,
+		       enum wl1251_acx_channel_type type,
+		       u8 tsid, enum wl1251_acx_ps_scheme ps_scheme,
+		       enum wl1251_acx_ack_policy ack_policy)
+{
+	struct wl1251_acx_tid_cfg *acx;
+	int ret = 0;
+
+	wl1251_debug(DEBUG_ACX, "acx tid cfg %d type %d tsid %d "
+		     "ps_scheme %d ack_policy %d", queue, type, tsid,
+		     ps_scheme, ack_policy);
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx->queue = queue;
+	acx->type = type;
+	acx->tsid = tsid;
+	acx->ps_scheme = ps_scheme;
+	acx->ack_policy = ack_policy;
+
+	ret = wl1251_cmd_configure(wl, ACX_TID_CFG, acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1251_warning("acx tid cfg failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
--- kernel-maemo-2.6.28.old.orig/drivers/net/wireless/wl12xx/wl1251_acx.h
+++ kernel-maemo-2.6.28.old/drivers/net/wireless/wl12xx/wl1251_acx.h
@@ -1246,6 +1246,87 @@
 	u8 padding[2];
 } __attribute__ ((packed));
 
+struct wl1251_acx_ac_cfg {
+	struct acx_header header;
+
+	/*
+	 * Access Category - The TX queue's access category
+	 * (refer to AccessCategory_enum)
+	 */
+	u8 ac;
+
+	/*
+	 * The contention window minimum size (in slots) for
+	 * the access class.
+	 */
+	u8 cw_min;
+
+	/*
+	 * The contention window maximum size (in slots) for
+	 * the access class.
+	 */
+	u16 cw_max;
+
+	/* The AIF value (in slots) for the access class. */
+	u8 aifsn;
+
+	u8 reserved;
+
+	/* The TX Op Limit (in microseconds) for the access class. */
+	u16 txop_limit;
+} __attribute__ ((packed));
+
+
+enum wl1251_acx_channel_type {
+	CHANNEL_TYPE_DCF	= 0,
+	CHANNEL_TYPE_EDCF	= 1,
+	CHANNEL_TYPE_HCCA	= 2,
+};
+
+enum wl1251_acx_ps_scheme {
+	/* regular ps: simple sending of packets */
+	WL1251_ACX_PS_SCHEME_LEGACY	= 0,
+
+	/* sending a packet triggers a unscheduled apsd downstream */
+	WL1251_ACX_PS_SCHEME_UPSD_TRIGGER	= 1,
+
+	/* a pspoll packet will be sent before every data packet */
+	WL1251_ACX_PS_SCHEME_LEGACY_PSPOLL	= 2,
+
+	/* scheduled apsd mode */
+	WL1251_ACX_PS_SCHEME_SAPSD		= 3,
+};
+
+enum wl1251_acx_ack_policy {
+	WL1251_ACX_ACK_POLICY_LEGACY	= 0,
+	WL1251_ACX_ACK_POLICY_NO_ACK	= 1,
+	WL1251_ACX_ACK_POLICY_BLOCK	= 2,
+};
+
+struct wl1251_acx_tid_cfg {
+	struct acx_header header;
+
+	/* tx queue id number (0-7) */
+	u8 queue;
+
+	/* channel access type for the queue, enum wl1251_acx_channel_type */
+	u8 type;
+
+	/* EDCA: ac index (0-3), HCCA: traffic stream id (8-15) */
+	u8 tsid;
+
+	/* ps scheme of the specified queue, enum wl1251_acx_ps_scheme */
+	u8 ps_scheme;
+
+	/* the tx queue ack policy, enum wl1251_acx_ack_policy */
+	u8 ack_policy;
+
+	u8 padding[3];
+
+	/* not supported */
+	u32 apsdconf[2];
+} __attribute__ ((packed));
+
 /*************************************************************************
 
     Host Interrupt Register (WiLink -> Host)
@@ -1410,5 +1491,11 @@
 			 u8 version);
 int wl1251_acx_bet_enable(struct wl1251 *wl, enum wl1251_acx_bet_mode mode,
 			  u8 max_consecutive);
+int wl1251_acx_ac_cfg(struct wl1251 *wl, u8 ac, u8 cw_min, u16 cw_max,
+		      u8 aifs, u16 txop);
+int wl1251_acx_tid_cfg(struct wl1251 *wl, u8 queue,
+		       enum wl1251_acx_channel_type type,
+		       u8 tsid, enum wl1251_acx_ps_scheme ps_scheme,
+		       enum wl1251_acx_ack_policy ack_policy);
 
 #endif /* __WL1251_ACX_H__ */
--- kernel-maemo-2.6.28.old.orig/drivers/net/wireless/wl12xx/wl1251_debugfs.c
+++ kernel-maemo-2.6.28.old/drivers/net/wireless/wl12xx/wl1251_debugfs.c
@@ -237,6 +237,27 @@
 	.open = wl1251_open_file_generic,
 };
 
+static ssize_t tx_queue_status_read(struct file *file, char __user *userbuf,
+				    size_t count, loff_t *ppos)
+{
+	struct wl1251 *wl = file->private_data;
+	char buf[3], status;
+	int len;
+
+	if (wl->tx_queue_stopped)
+		status = 's';
+	else
+		status = 'r';
+
+	len = scnprintf(buf, sizeof(buf), "%c\n", status);
+	return simple_read_from_buffer(userbuf, count, ppos, buf, len);
+}
+
+static const struct file_operations tx_queue_status_ops = {
+	.read = tx_queue_status_read,
+	.open = wl1251_open_file_generic,
+};
+
 static void wl1251_debugfs_delete_files(struct wl1251 *wl)
 {
 	DEBUGFS_FWSTATS_DEL(tx, internal_desc_overflow);
@@ -331,6 +352,7 @@
 	DEBUGFS_FWSTATS_DEL(rxpipe, tx_xfr_host_int_trig_rx_data);
 
 	DEBUGFS_DEL(tx_queue_len);
+	DEBUGFS_DEL(tx_queue_status);
 	DEBUGFS_DEL(retry_count);
 	DEBUGFS_DEL(excessive_retries);
 }
@@ -431,6 +453,7 @@
 	DEBUGFS_FWSTATS_ADD(rxpipe, tx_xfr_host_int_trig_rx_data);
 
 	DEBUGFS_ADD(tx_queue_len, wl->debugfs.rootdir);
+	DEBUGFS_ADD(tx_queue_status, wl->debugfs.rootdir);
 	DEBUGFS_ADD(retry_count, wl->debugfs.rootdir);
 	DEBUGFS_ADD(excessive_retries, wl->debugfs.rootdir);
 
--- kernel-maemo-2.6.28.old.orig/drivers/net/wireless/wl12xx/wl1251_init.c
+++ kernel-maemo-2.6.28.old/drivers/net/wireless/wl12xx/wl1251_init.c
@@ -298,6 +298,11 @@
 			goto out;
 	}
 
+	wl1251_acx_ac_cfg(wl, AC_BE, CWMIN_BE, CWMAX_BE, AIFS_DIFS, TXOP_BE);
+	wl1251_acx_ac_cfg(wl, AC_BK, CWMIN_BK, CWMAX_BK, AIFS_DIFS, TXOP_BK);
+	wl1251_acx_ac_cfg(wl, AC_VI, CWMIN_VI, CWMAX_VI, AIFS_DIFS, TXOP_VI);
+	wl1251_acx_ac_cfg(wl, AC_VO, CWMIN_VO, CWMAX_VO, AIFS_DIFS, TXOP_VO);
+
 out:
 	kfree(config);
 	return ret;
--- kernel-maemo-2.6.28.old.orig/drivers/net/wireless/wl12xx/wl1251_init.h
+++ kernel-maemo-2.6.28.old/drivers/net/wireless/wl12xx/wl1251_init.h
@@ -26,6 +26,53 @@
 
 #include "wl1251.h"
 
+enum {
+	/* best effort/legacy */
+	AC_BE = 0,
+
+	/* background */
+	AC_BK = 1,
+
+	/* video */
+	AC_VI = 2,
+
+	/* voice */
+	AC_VO = 3,
+
+	/* broadcast dummy access category */
+	AC_BCAST = 4,
+
+	NUM_ACCESS_CATEGORIES = 4
+};
+
+/* following are defult values for the IE fields*/
+#define CWMIN_BK  15
+#define CWMIN_BE  15
+#define CWMIN_VI  7
+#define CWMIN_VO  3
+#define CWMAX_BK  1023
+#define CWMAX_BE  63
+#define CWMAX_VI  15
+#define CWMAX_VO  7
+
+/* slot number setting to start transmission at PIFS interval */
+#define AIFS_PIFS 1
+
+/*
+ * slot number setting to start transmission at DIFS interval - normal DCF
+ * access
+ */
+#define AIFS_DIFS 2
+
+#define AIFSN_BK  7
+#define AIFSN_BE  3
+#define AIFSN_VI  AIFS_PIFS
+#define AIFSN_VO  AIFS_PIFS
+#define TXOP_BK   0
+#define TXOP_BE   0
+#define TXOP_VI   3008
+#define TXOP_VO   1504
+
 int wl1251_hw_init_hwenc_config(struct wl1251 *wl);
 int wl1251_hw_init_templates_config(struct wl1251 *wl);
 int wl1251_hw_init_rx_config(struct wl1251 *wl, u32 config, u32 filter);
--- kernel-maemo-2.6.28.old.orig/drivers/net/wireless/wl12xx/wl1251_main.c
+++ kernel-maemo-2.6.28.old/drivers/net/wireless/wl12xx/wl1251_main.c
@@ -756,6 +756,7 @@
 	 * the queue here, otherwise the queue will get too long.
 	 */
 	if (skb_queue_len(&wl->tx_queue) >= WL1251_TX_QUEUE_MAX_LENGTH) {
+		wl1251_debug(DEBUG_TX, "op_tx: tx_queue full, stop queues");
 		ieee80211_stop_queues(wl->hw);
 
 		/*
@@ -1577,8 +1578,10 @@
 	}
 
 	trigger = kzalloc(sizeof(*trigger), GFP_KERNEL);
-	if (!trigger)
+	if (!trigger) {
+		ret = -ENOMEM;
 		goto out;
+	}
 
 	trigger->timeout = 0;
 
@@ -1742,6 +1745,37 @@
 	mutex_unlock(&wl->mutex);
 }
 
+static int wl1251_op_conf_tx(struct ieee80211_hw *hw, u16 queue,
+			     const struct ieee80211_tx_queue_params *params)
+{
+	struct wl1251 *wl = hw->priv;
+	int ret;
+
+	mutex_lock(&wl->mutex);
+
+	wl1251_debug(DEBUG_MAC80211, "mac80211 conf tx %d", queue);
+
+	/* mac80211 txop unit is 32 usecs */
+	ret = wl1251_acx_ac_cfg(wl, wl1251_tx_get_queue(queue),
+				params->cw_min, params->cw_max,
+				params->aifs, params->txop * 32);
+	if (ret < 0)
+		goto out;
+
+	ret = wl1251_acx_tid_cfg(wl, wl1251_tx_get_queue(queue),
+				 CHANNEL_TYPE_EDCF,
+				 wl1251_tx_get_queue(queue),
+				 WL1251_ACX_PS_SCHEME_LEGACY,
+				 WL1251_ACX_ACK_POLICY_LEGACY);
+	if (ret < 0)
+		goto out;
+
+out:
+	mutex_unlock(&wl->mutex);
+
+	return ret;
+}
+
 /* can't be const, mac80211 writes to this */
 static struct ieee80211_rate wl1251_rates[] = {
 	{ .bitrate = 10,
@@ -1823,6 +1857,7 @@
 	.hw_scan = wl1251_op_hw_scan,
 	.bss_info_changed = wl1251_op_bss_info_changed,
 	.set_rts_threshold = wl1251_op_set_rts_threshold,
+	.conf_tx = wl1251_op_conf_tx,
 };
 
 static int wl1251_register_hw(struct wl1251 *wl)
@@ -1863,6 +1898,8 @@
 
 	wl->hw->wiphy->bands[IEEE80211_BAND_2GHZ] = &wl1251_band_2ghz;
 
+	wl->hw->queues = 4;
+
 	SET_IEEE80211_DEV(wl->hw, &wl->spi->dev);
 
 	return 0;
--- kernel-maemo-2.6.28.old.orig/drivers/net/wireless/wl12xx/wl1251_tx.c
+++ kernel-maemo-2.6.28.old/drivers/net/wireless/wl12xx/wl1251_tx.c
@@ -30,6 +30,7 @@
 #include "wl1251_spi.h"
 #include "wl1251_tx.h"
 #include "wl1251_ps.h"
+#include "wl12xx_80211.h"
 
 static bool wl1251_tx_double_buffer_busy(struct wl1251 *wl, u32 data_out_count)
 {
@@ -167,8 +168,7 @@
 	tx_hdr->expiry_time = cpu_to_le32(1 << 16);
 	tx_hdr->id = id;
 
-	/* FIXME: how to get the correct queue id? */
-	tx_hdr->xmit_queue = 0;
+	tx_hdr->xmit_queue = wl1251_tx_get_queue(skb_get_queue_mapping(skb));
 
 	wl1251_tx_control(tx_hdr, control, fc);
 	wl1251_tx_frag_block_num(tx_hdr);
@@ -220,6 +220,7 @@
 			/* align the buffer on a 4-byte boundary */
 			skb_reserve(skb, offset);
 			memmove(skb->data, src, skb->len);
+			tx_hdr = (struct tx_double_buffer_desc *) skb->data;
 		} else {
 			wl1251_info("No handler, fixme!");
 			return -EINVAL;
@@ -237,8 +238,9 @@
 
 	wl1251_spi_mem_write(wl, addr, skb->data, len);
 
-	wl1251_debug(DEBUG_TX, "tx id %u skb 0x%p payload %u rate 0x%x",
-		     tx_hdr->id, skb, tx_hdr->length, tx_hdr->rate);
+	wl1251_debug(DEBUG_TX, "tx id %u skb 0x%p payload %u rate 0x%x "
+		     "queue %d", tx_hdr->id, skb, tx_hdr->length,
+		     tx_hdr->rate, tx_hdr->xmit_queue);
 
 	return 0;
 }
@@ -297,6 +299,54 @@
 	return ret;
 }
 
+static int wl1251_tx_pspoll(struct wl1251 *wl)
+{
+	struct wl12xx_ps_poll_template *pspoll;
+	struct ieee80211_tx_info *info;
+	struct sk_buff *skb;
+	int ret;
+	u16 fc;
+
+	skb = dev_alloc_skb(wl->hw->extra_tx_headroom + sizeof(*pspoll));
+	if (!skb) {
+		wl1251_warning("failed to allocate buffer for pspoll frame");
+		return -ENOMEM;
+	}
+	skb_reserve(skb, wl->hw->extra_tx_headroom);
+
+	pspoll = (struct wl12xx_ps_poll_template *) skb_put(skb,
+							    sizeof(*pspoll));
+	memset(pspoll, 0, sizeof(*pspoll));
+	fc = IEEE80211_FTYPE_CTL | IEEE80211_STYPE_PSPOLL | IEEE80211_FCTL_PM;
+	pspoll->fc = cpu_to_le16(fc);
+	pspoll->aid = cpu_to_le16(wl->aid);
+
+	/* aid in PS-Poll has its two MSBs each set to 1 */
+	pspoll->aid |= cpu_to_le16(1 << 15 | 1 << 14);
+
+	memcpy(pspoll->bssid, wl->bssid, ETH_ALEN);
+	memcpy(pspoll->ta, wl->mac_addr, ETH_ALEN);
+
+	/* hack to inform that skb is not from mac80211 */
+	info = IEEE80211_SKB_CB(skb);
+	info->driver_data[0] = (void *) 1;
+
+	ret = wl1251_tx_frame(wl, skb);
+
+	if (ret == -EBUSY) {
+		/* firmware buffer is full, stop queues */
+		wl1251_debug(DEBUG_TX, "tx_pspoll: fw buffer full, "
+			     "stop queues");
+		ieee80211_stop_queues(wl->hw);
+		wl->tx_queue_stopped = true;
+	}
+
+	if (ret < 0)
+		dev_kfree_skb(skb);
+
+	return ret;
+}
+
 void wl1251_tx_work(struct work_struct *work)
 {
 	struct wl1251 *wl = container_of(work, struct wl1251, tx_work);
@@ -317,6 +367,16 @@
 			woken_up = true;
 		}
 
+		if (wl->psm) {
+			ret = wl1251_tx_pspoll(wl);
+
+			if (ret < 0) {
+				/* ps poll failed, put skb back to queue */
+				skb_queue_head(&wl->tx_queue, skb);
+				goto out;
+			}
+		}
+
 		ret = wl1251_tx_frame(wl, skb);
 		if (ret == -EBUSY) {
 			/* firmware buffer is full, stop queues */
@@ -372,7 +432,7 @@
 {
 	struct ieee80211_tx_info *info;
 	struct sk_buff *skb;
-	int hdrlen, ret;
+	int hdrlen, queue_len;
 	u8 *frame;
 
 	skb = wl->tx_frames[result->id];
@@ -381,8 +441,19 @@
 		return;
 	}
 
+	wl1251_debug(DEBUG_TX, "tx status id %u skb 0x%p failures %u rate 0x%x"
+		     " status 0x%x (%s)",
+		     result->id, skb, result->ack_failures, result->rate,
+		     result->status, wl1251_tx_parse_status(result->status));
+
 	info = IEEE80211_SKB_CB(skb);
 
+	/* hack: check if skb is not from mac80211 */
+	if ((unsigned long) info->driver_data[0] == 1) {
+		dev_kfree_skb(skb);
+		goto out;
+	}
+
 	if (!(info->flags & IEEE80211_TX_CTL_NO_ACK)) {
 		if (result->status == TX_SUCCESS)
 			info->flags |= IEEE80211_TX_STAT_ACK;
@@ -407,43 +478,21 @@
 		skb_pull(skb, WL1251_TKIP_IV_SPACE);
 	}
 
-	wl1251_debug(DEBUG_TX, "tx status id %u skb 0x%p failures %u rate 0x%x"
-		     " status 0x%x (%s)",
-		     result->id, skb, result->ack_failures, result->rate,
-		     result->status, wl1251_tx_parse_status(result->status));
-
-
 	ieee80211_tx_status(wl->hw, skb);
 
+out:
 	wl->tx_frames[result->id] = NULL;
 
-	if (wl->tx_queue_stopped) {
-		wl1251_debug(DEBUG_TX, "cb: queue was stopped");
-
-		skb = skb_dequeue(&wl->tx_queue);
-
-		/* The skb can be NULL because tx_work might have been
-		   scheduled before the queue was stopped making the
-		   queue empty */
-
-		if (skb) {
-			ret = wl1251_tx_frame(wl, skb);
-			if (ret == -EBUSY) {
-				/* firmware buffer is still full */
-				wl1251_debug(DEBUG_TX, "cb: fw buffer "
-					     "still full");
-				skb_queue_head(&wl->tx_queue, skb);
-				return;
-			} else if (ret < 0) {
-				dev_kfree_skb(skb);
-				return;
-			}
-		}
+	queue_len = skb_queue_len(&wl->tx_queue);
 
+	if (wl->tx_queue_stopped && queue_len < WL1251_TX_QUEUE_MAX_LENGTH) {
 		wl1251_debug(DEBUG_TX, "cb: waking queues");
 		ieee80211_wake_queues(wl->hw);
 		wl->tx_queue_stopped = false;
 	}
+
+	if (queue_len > 0)
+		queue_work(wl->hw->workqueue, &wl->tx_work);
 }
 
 /* Called upon reception of a TX complete interrupt */
--- kernel-maemo-2.6.28.old.orig/drivers/net/wireless/wl12xx/wl1251_tx.h
+++ kernel-maemo-2.6.28.old/drivers/net/wireless/wl12xx/wl1251_tx.h
@@ -26,6 +26,7 @@
 #define __WL1251_TX_H__
 
 #include <linux/bitops.h>
+#include "wl1251_acx.h"
 
 /*
  *
@@ -209,6 +210,22 @@
 	u8 done_2;
 } __attribute__ ((packed));
 
+static inline int wl1251_tx_get_queue(int queue)
+{
+	switch (queue) {
+	case 0:
+		return QOS_AC_VO;
+	case 1:
+		return QOS_AC_VI;
+	case 2:
+		return QOS_AC_BE;
+	case 3:
+		return QOS_AC_BK;
+	default:
+		return QOS_AC_BE;
+	}
+}
+
 void wl1251_tx_work(struct work_struct *work);
 void wl1251_tx_complete(struct wl1251 *wl);
 void wl1251_tx_flush(struct wl1251 *wl);
--- kernel-maemo-2.6.28.old.orig/drivers/spi/omap2_mcspi.c
+++ kernel-maemo-2.6.28.old/drivers/spi/omap2_mcspi.c
@@ -284,8 +284,10 @@
 {
 	if (clk_enable(mcspi->ick))
 		return -ENODEV;
-	if (clk_enable(mcspi->fck))
+	if (clk_enable(mcspi->fck)) {
+		clk_disable(mcspi->ick);
 		return -ENODEV;
+	}
 
 	omap2_mcspi_restore_ctx(mcspi);
 
--- kernel-maemo-2.6.28.old.orig/drivers/usb/musb/omap2430.c
+++ kernel-maemo-2.6.28.old/drivers/usb/musb/omap2430.c
@@ -38,6 +38,8 @@
 #include <mach/hardware.h>
 #include <mach/mux.h>
 
+#include <linux/i2c/twl4030.h>
+
 #include "musb_core.h"
 #include "omap2430.h"
 
@@ -155,9 +157,11 @@
 
 void musb_platform_enable(struct musb *musb)
 {
+	twl4030_upd_usb_suspended(0);
 }
 void musb_platform_disable(struct musb *musb)
 {
+	twl4030_upd_usb_suspended(musb->is_suspended);
 }
 static void omap_vbus_power(struct musb *musb, int is_on, int sleeping)
 {
--- kernel-maemo-2.6.28.old.orig/drivers/video/omap2/dss/core.c
+++ kernel-maemo-2.6.28.old/drivers/video/omap2/dss/core.c
@@ -53,10 +53,6 @@
 	struct delayed_work bus_tput_work;
 	unsigned int bus_tput;
 
-	bool reset_pending;
-	spinlock_t reset_lock;
-	struct work_struct reset_work;
-
 	struct mutex dss_lock;
 } core;
 
@@ -460,35 +456,10 @@
 
 /* RESET */
 
-void dss_schedule_reset(void)
-{
-	unsigned long flags;
-
-	DSSDBG("schduling a soft reset\n");
-
-	spin_lock_irqsave(&core.reset_lock, flags);
-	if (core.reset_pending) {
-		spin_unlock_irqrestore(&core.reset_lock, flags);
-		return;
-	}
-
-	core.reset_pending = true;
-	schedule_work(&core.reset_work);
-
-	spin_unlock_irqrestore(&core.reset_lock, flags);
-}
-
-static void reset_work_func(struct work_struct *work)
+void dss_soft_reset(void)
 {
 	DSSDBG("performing soft reset\n");
 
-	spin_lock_irq(&core.reset_lock);
-	if (!core.reset_pending) {
-		spin_unlock_irq(&core.reset_lock);
-		return;
-	}
-	spin_unlock_irq(&core.reset_lock);
-
 	omap_dss_lock();
 	dss_clk_enable_all();
 	dss_suspend_all_displays();
@@ -501,11 +472,7 @@
 	dss_clk_disable_all();
 	omap_dss_unlock();
 
-	spin_lock_irq(&core.reset_lock);
-	core.reset_pending = false;
-	spin_unlock_irq(&core.reset_lock);
-
-	DSSDBG("done with soft reset\n");
+	DSSERR("done with soft reset\n");
 }
 
 /* DVFS */
@@ -694,10 +661,6 @@
 
 	INIT_DELAYED_WORK(&core.bus_tput_work, bus_tput_work_func);
 
-	core.reset_pending = false;
-	spin_lock_init(&core.reset_lock);
-	INIT_WORK(&core.reset_work, reset_work_func);
-
 	mutex_init(&core.dss_lock);
 
 	return 0;
@@ -712,9 +675,6 @@
 	struct omap_dss_board_info *pdata = pdev->dev.platform_data;
 	int c;
 
-	cancel_work_sync(&core.reset_work);
-	core.reset_pending = false;
-
 	cancel_delayed_work_sync(&core.bus_tput_work);
 	if (pdata->set_min_bus_tput)
 		pdata->set_min_bus_tput(&core.pdev->dev, OCP_INITIATOR_AGENT, 0);
--- kernel-maemo-2.6.28.old.orig/drivers/video/omap2/dss/dispc.c
+++ kernel-maemo-2.6.28.old/drivers/video/omap2/dss/dispc.c
@@ -329,7 +329,7 @@
 void dispc_restore_context(void)
 {
 	RR(SYSCONFIG);
-	RR(IRQENABLE);
+	/*RR(IRQENABLE);*/
 	/*RR(CONTROL);*/
 	RR(CONFIG);
 	RR(DEFAULT_COLOR0);
@@ -466,6 +466,15 @@
 
 	/* enable last, because LCD & DIGIT enable are here */
 	RR(CONTROL);
+
+	/* clear spurious SYNC_LOST_DIGIT interrupts */
+	dispc_write_reg(DISPC_IRQSTATUS, DISPC_IRQ_SYNC_LOST_DIGIT);
+
+	/*
+	 * enable last so IRQs won't trigger before
+	 * the context is fully restored
+	 */
+	RR(IRQENABLE);
 }
 
 #undef SR
@@ -516,6 +525,40 @@
 	enable_clocks(0);
 }
 
+void dispc_wait_for_go(enum omap_channel channel)
+{
+	int bit;
+	unsigned long tmo;
+
+	enable_clocks(1);
+
+	if (channel == OMAP_DSS_CHANNEL_LCD)
+		bit = 0; /* LCDENABLE */
+	else
+		bit = 1; /* DIGITALENABLE */
+
+	/* if the channel is not enabled, we don't need GO */
+	if (REG_GET(DISPC_CONTROL, bit, bit) == 0)
+		goto end;
+
+	if (channel == OMAP_DSS_CHANNEL_LCD)
+		bit = 5; /* GOLCD */
+	else
+		bit = 6; /* GODIGIT */
+
+	tmo = jiffies + msecs_to_jiffies(200);
+	while (REG_GET(DISPC_CONTROL, bit, bit) == 1) {
+		if (time_after(jiffies, tmo)) {
+			DSSERR("timeout waiting GO flag\n");
+			goto end;
+		}
+		cpu_relax();
+	}
+
+end:
+	enable_clocks(0);
+}
+
 static void _dispc_write_firh_reg(enum omap_plane plane, int reg, u32 value)
 {
 	BUG_ON(plane == OMAP_DSS_GFX);
@@ -938,6 +981,26 @@
 	dispc_write_reg(dispc_reg_att[plane], val);
 }
 
+static enum omap_channel _dispc_get_channel_out(enum omap_plane plane)
+{
+	int shift;
+
+	switch (plane) {
+	case OMAP_DSS_GFX:
+		shift = 8;
+		break;
+	case OMAP_DSS_VIDEO1:
+	case OMAP_DSS_VIDEO2:
+		shift = 16;
+		break;
+	default:
+		BUG();
+		return OMAP_DSS_CHANNEL_LCD;
+	}
+
+	return REG_GET(dispc_reg_att[plane], shift, shift);
+}
+
 void dispc_set_burst_size(enum omap_plane plane,
 		enum omap_burst_size burst_size)
 {
@@ -1077,6 +1140,49 @@
 	enable_clocks(0);
 }
 
+bool dispc_fifomerge_enabled(void)
+{
+	bool enabled;
+
+	enable_clocks(1);
+
+	enabled = REG_GET(DISPC_CONFIG, 14, 14);
+
+	enable_clocks(0);
+
+	return enabled;
+}
+
+static bool _dispc_plane_enabled(enum omap_plane plane)
+{
+	return REG_GET(dispc_reg_att[plane], 0, 0);
+}
+
+enum omap_channel dispc_get_enabled_channel(void)
+{
+	enum omap_channel ch = OMAP_DSS_CHANNEL_LCD;
+
+	enable_clocks(1);
+
+	if (_dispc_plane_enabled(OMAP_DSS_GFX)) {
+		ch = _dispc_get_channel_out(OMAP_DSS_GFX);
+		goto out;
+	}
+	if (_dispc_plane_enabled(OMAP_DSS_VIDEO1)) {
+		ch = _dispc_get_channel_out(OMAP_DSS_VIDEO1);
+		goto out;
+	}
+	if (_dispc_plane_enabled(OMAP_DSS_VIDEO2)) {
+		ch = _dispc_get_channel_out(OMAP_DSS_VIDEO2);
+		goto out;
+	}
+
+ out:
+	enable_clocks(0);
+
+	return ch;
+}
+
 static void _dispc_set_fir(enum omap_plane plane, int hinc, int vinc)
 {
 	u32 val;
@@ -1361,6 +1467,19 @@
 	x = x1 - x0;
 	y = y1 - y0;
 
+	if (x >= gfxw - 1 && y >= gfxh - 1) {
+		/*
+		 * If the overlay optimization is enabled with this condition
+		 * being true, then disabling the overlay optimization results
+		 * in a short burst of visible corruption.
+		 *
+		 * FIXME Root cause of corruption is unknown,
+		 * only	seems to happen when GFX is using VRFB.
+		 */
+		DSSDBG("gfx_window_skip: Disabling overlay optimization to avoid corruption\n");
+		return 0;
+	}
+
 	DSSDBG("gfx_window_skip: GFX w=%u, VID1 w=%u, "
 	       "x=%u, y=%u, pix_inc=%u, row_inc=%u, ps=%u\n",
 	       gfxw, vid1w, x, y, pix_inc, row_inc, ps);
@@ -1650,9 +1769,9 @@
 
 	mgr->display->get_timings(mgr->display, &t);
 
-	DSSDBG("PCLK = %u\n", t.pixel_clock);
+	DSSDBG("PCLK = %u\n", t.pixel_clock * 1000);
 
-	return t.pixel_clock;
+	return t.pixel_clock * 1000;
 }
 
 static u32 get_display_width(enum omap_channel channel_out)
@@ -1707,6 +1826,56 @@
 	return 0;
 }
 
+static int check_horiz_timing(enum omap_channel channel_out, u16 pos_x,
+		u16 width, u16 height, u16 out_width, u16 out_height,
+		enum omap_color_mode color_mode, bool five_taps)
+{
+	unsigned int nonactive;
+	int lcd, pcd, ds = DIV_ROUND_UP(height, out_height);
+	struct omap_overlay_manager *mgr = manager_for_channel(channel_out);
+	struct omap_video_timings t;
+
+	/* FIXME add checks for 3-tap filter once the limitations are known */
+	if (!five_taps)
+		return 0;
+
+	/* Convert width to 4 byte units */
+	width = DIV_ROUND_UP(width * color_mode_to_bpp(color_mode), 32);
+
+	if (!mgr || !mgr->display || !mgr->display->get_timings)
+		return -ENODEV;
+
+	mgr->display->get_timings(mgr->display, &t);
+
+	nonactive = t.x_res + t.hfp + t.hsw + t.hbp - out_width;
+
+	enable_clocks(1);
+	dispc_get_lcd_divisor(&lcd, &pcd);
+	enable_clocks(0);
+
+	DSSDBG("(nonactive - pos_x) * pcd = %u, max(0, ds - 2) * width = %d\n",
+	       (nonactive - pos_x) * pcd, max(0, ds - 2) * width);
+	DSSDBG("nonactive * pcd = %u, max(0, ds - 1) * width = %d\n",
+	       nonactive * pcd, max(0, ds - 1) * width);
+
+	/*
+	 * At least ds-2 lines must have already been fetched
+	 * before the display active video period starts.
+	 */
+	if ((nonactive - pos_x) * pcd < max(0, ds - 2) * width)
+		return -EINVAL;
+
+	/*
+	 * Only one line can be fetched during the overlay active
+	 * period, the rest have to be fetched during the inactive
+	 * period.
+	 */
+	if (nonactive * pcd < max(0, ds - 1) * width)
+		return -EINVAL;
+
+	return 0;
+}
+
 static unsigned long calc_fclk_five_taps(u16 width, u16 height,
 		u16 out_width, u16 out_height, enum omap_color_mode color_mode,
 		enum omap_channel channel_out)
@@ -1726,7 +1895,10 @@
 		do_div(tmp, 2 * out_height * ppl);
 		fclk = tmp;
 
-		if (height > 2 * out_height && ppl != out_width) {
+		if (height > 2 * out_height) {
+			if (ppl == out_width)
+				return 0;
+
 			tmp = pclk * (height - 2 * out_height) * out_width;
 			do_div(tmp, 2 * out_height * (ppl - out_width));
 			fclk = max(fclk, (u32) tmp);
@@ -1895,6 +2067,12 @@
 		if (width > (2048 >> five_taps))
 			return -EINVAL;
 
+		if (check_horiz_timing(channel_out, pos_x, width, height,
+				out_width, out_height, color_mode, five_taps)) {
+			DSSDBG("horizontal timing too tight\n");
+			return -EINVAL;
+		}
+
 		if (five_taps)
 			fclk = calc_fclk_five_taps(width, height,
 					out_width, out_height,
@@ -1903,7 +2081,7 @@
 		DSSDBG("required fclk rate = %lu Hz\n", fclk);
 		DSSDBG("current fclk rate = %lu Hz\n", dispc_fclk_rate());
 
-		if (fclk > dispc_fclk_rate())
+		if (!fclk || fclk > dispc_fclk_rate())
 			return -EINVAL;
 	}
 
@@ -1953,7 +2131,10 @@
 
 	_dispc_set_plane_pos(plane, pos_x, pos_y);
 
-	_dispc_set_pic_size(plane, width, height);
+	if (field_offset && !fieldmode)
+		_dispc_set_pic_size(plane, width, height - field_offset);
+	else
+		_dispc_set_pic_size(plane, width, height);
 
 	if (plane != OMAP_DSS_GFX) {
 		_dispc_set_scaling(plane, width, height,
@@ -3094,12 +3275,12 @@
 
 	if (errors & DISPC_IRQ_SYNC_LOST) {
 		DSSERR("SYNC_LOST, going to perform a soft reset\n");
-		dss_schedule_reset();
+		dss_soft_reset();
 	}
 
 	if (errors & DISPC_IRQ_SYNC_LOST_DIGIT) {
 		DSSERR("SYNC_LOST_DIGIT, going to perform a soft reset\n");
-		dss_schedule_reset();
+		dss_soft_reset();
 	}
 
 	if (errors & DISPC_IRQ_OCP_ERR) {
--- kernel-maemo-2.6.28.old.orig/drivers/video/omap2/dss/dss.h
+++ kernel-maemo-2.6.28.old/drivers/video/omap2/dss/dss.h
@@ -169,7 +169,7 @@
 int dss_dsi_power_up(void);
 void dss_dsi_power_down(void);
 
-void dss_schedule_reset(void);
+void dss_soft_reset(void);
 
 /* display */
 void dss_init_displays(struct platform_device *pdev);
@@ -266,6 +266,7 @@
 void dispc_set_digit_size(u16 width, u16 height);
 u32 dispc_get_plane_fifo_size(enum omap_plane plane);
 void dispc_setup_plane_fifo(enum omap_plane plane, u32 low, u32 high);
+bool dispc_fifomerge_enabled(void);
 void dispc_enable_fifomerge(bool enable);
 void dispc_set_overlay_optimization(void);
 void dispc_set_burst_size(enum omap_plane plane,
@@ -287,7 +288,9 @@
 		      u8 rotation, bool mirror,
 		      u8 global_alpha);
 
+enum omap_channel dispc_get_enabled_channel(void);
 void dispc_go(enum omap_channel channel);
+void dispc_wait_for_go(enum omap_channel channel);
 void dispc_enable_lcd_out(bool enable);
 void dispc_enable_digit_out(bool enable);
 void dispc_enable_digit_errors(int enable);
--- kernel-maemo-2.6.28.old.orig/drivers/video/omap2/dss/manager.c
+++ kernel-maemo-2.6.28.old/drivers/video/omap2/dss/manager.c
@@ -307,7 +307,7 @@
 	if (enable != 0 && enable != 1)
 		return -EINVAL;
 
-	dss_schedule_reset();
+	dss_soft_reset();
 
 	return size;
 }
@@ -446,6 +446,59 @@
 	return ovl->info.enabled && ovl->manager && ovl->manager->display;
 }
 
+static void configure_fifomerge(bool enable)
+{
+	int i;
+	struct omap_overlay_manager *mgr;
+	struct omap_display *ch_display = NULL;
+	enum omap_channel ch = dispc_get_enabled_channel();
+
+	/* Make sure all pending updates have been finished. */
+	list_for_each_entry(mgr, &manager_list, list) {
+		struct omap_display *display;
+
+		if (!(mgr->caps & OMAP_DSS_OVL_MGR_CAP_DISPC))
+			continue;
+
+		display = mgr->display;
+
+		if (!display)
+			continue;
+
+		if (mgr->id == ch)
+			ch_display = display;
+
+		/* We don't need GO with manual update display. LCD iface will
+		 * always be turned off after frame, and new settings will
+		 * be taken in to use at next update */
+		if (display->caps & OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE)
+			continue;
+
+		dispc_wait_for_go(mgr->id);
+	}
+
+	/* Configure FIFO merge */
+	dispc_enable_fifomerge(enable);
+
+	/* Configure the FIFOs to proper size */
+	for (i = 0; i < omap_dss_get_num_overlays(); ++i) {
+		struct omap_overlay *ovl = omap_dss_get_overlay(i);
+
+		if (!(ovl->caps & OMAP_DSS_OVL_CAP_DISPC))
+			continue;
+
+		ovl->manager->display->configure_overlay(ovl);
+	}
+
+	if (!ch_display || ch_display->caps & OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE)
+		return;
+
+	/* Issue GO for manager */
+	dispc_go(ch);
+	/* Avoid mixing FIFO merge changes with any later updates. */
+	dispc_wait_for_go(ch);
+}
+
 /* We apply settings to both managers here so that we can use optimizations
  * like fifomerge. Shadow registers can be changed first and the non-shadowed
  * should be changed last, at the same time with GO */
@@ -465,6 +518,29 @@
 
 	dss_clk_enable(DSS_CLK_ICK | DSS_CLK_FCK1);
 
+	/* Count enabled overlays */
+	for (i = 0; i < omap_dss_get_num_overlays(); ++i) {
+		ovl = omap_dss_get_overlay(i);
+
+		if (!(ovl->caps & OMAP_DSS_OVL_CAP_DISPC))
+			continue;
+
+		if (!overlay_enabled(ovl))
+			continue;
+
+		display = ovl->manager->display;
+
+		if (dss_check_overlay(ovl, display))
+			continue;
+
+		++num_planes_enabled;
+	}
+
+	/* Disable FIFO merge? */
+	if (num_planes_enabled > 1 && dispc_fifomerge_enabled())
+		configure_fifomerge(false);
+
+	num_planes_enabled = 0;
 	/* Configure normal overlay parameters and disable unused overlays */
 	for (i = 0; i < omap_dss_get_num_overlays(); ++i) {
 		ovl = omap_dss_get_overlay(i);
@@ -541,25 +617,6 @@
 
 	dispc_set_overlay_optimization();
 
-	/* Enable fifo merge if possible */
-	dispc_enable_fifomerge(num_planes_enabled == 1);
-
-	/* Go through overlays again. This time we configure fifos.  We have to
-	 * do this after enabling/disabling fifomerge so that we have correct
-	 * knowledge of fifo sizes */
-	for (i = 0; i < omap_dss_get_num_overlays(); ++i) {
-		ovl = omap_dss_get_overlay(i);
-
-		if (!(ovl->caps & OMAP_DSS_OVL_CAP_DISPC))
-			continue;
-
-		if (!overlay_enabled(ovl)) {
-			continue;
-		}
-
-		ovl->manager->display->configure_overlay(ovl);
-	}
-
 	/* Try to prevent FIFO undeflows. */
 	omap_dss_update_min_bus_tput();
 
@@ -582,6 +639,10 @@
 		dispc_go(mgr->id);
 	}
 
+	/* Enable FIFO merge? */
+	if (num_planes_enabled <= 1 && !dispc_fifomerge_enabled())
+		configure_fifomerge(true);
+
 	dss_clk_disable(DSS_CLK_ICK | DSS_CLK_FCK1);
 
 	return ret;
--- kernel-maemo-2.6.28.old.orig/include/linux/i2c/twl4030.h
+++ kernel-maemo-2.6.28.old/include/linux/i2c/twl4030.h
@@ -83,6 +83,15 @@
 
 /*----------------------------------------------------------------------*/
 
+/* Update USB suspended state flag for twl4030-poweroff driver */
+#if defined(CONFIG_TWL4030_POWEROFF)
+extern void twl4030_upd_usb_suspended(u8 suspended);
+#else
+#define twl4030_upd_usb_suspended(susp) do { } while (0)
+#endif
+
+/*----------------------------------------------------------------------*/
+
 /*
  * NOTE:  at up to 1024 registers, this is a big chip.
  *
--- kernel-maemo-2.6.28.old.orig/include/net/bluetooth/hci_core.h
+++ kernel-maemo-2.6.28.old/include/net/bluetooth/hci_core.h
@@ -352,7 +352,7 @@
 			if (conn->state == BT_CONNECTED) {
 				timeo = msecs_to_jiffies(conn->disc_timeout);
 				if (!conn->out)
-					timeo *= 2;
+					timeo *= 4;
 			} else
 				timeo = msecs_to_jiffies(10);
 		} else
--- kernel-maemo-2.6.28.old.orig/net/bluetooth/rfcomm/core.c
+++ kernel-maemo-2.6.28.old/net/bluetooth/rfcomm/core.c
@@ -1148,7 +1148,8 @@
 			break;
 
 		case BT_DISCONN:
-			rfcomm_session_put(s);
+			if (s->sock->sk->sk_state != BT_CLOSED)
+				rfcomm_session_put(s);
 			break;
 		}
 	}
--- kernel-maemo-2.6.28.old.orig/net/mac80211/rc80211_minstrel.c
+++ kernel-maemo-2.6.28.old/net/mac80211/rc80211_minstrel.c
@@ -179,6 +179,8 @@
 
 	if (!mp->has_mrr || (ar[0].rate_idx < 0)) {
 		ndx = rix_to_ndx(mi, info->tx_rate_idx);
+		if (ndx < 0)
+			return;
 		tries = info->status.retry_count + 1;
 		mi->r[ndx].success += success;
 		mi->r[ndx].attempts += tries;
@@ -190,6 +192,8 @@
 			break;
 
 		ndx = rix_to_ndx(mi, ar[i].rate_idx);
+		if (ndx < 0)
+			continue;
 		mi->r[ndx].attempts += ar[i].limit + 1;
 
 		if ((i != 3) && (ar[i + 1].rate_idx < 0))
@@ -224,7 +228,7 @@
 	unsigned int sample_ndx;
 	sample_ndx = SAMPLE_TBL(mi, mi->sample_idx, mi->sample_column);
 	mi->sample_idx++;
-	if (mi->sample_idx > (mi->n_rates - 2)) {
+	if ((int) mi->sample_idx > (mi->n_rates - 2)) {
 		mi->sample_idx = 0;
 		mi->sample_column++;
 		if (mi->sample_column >= SAMPLE_COLUMNS)
--- kernel-maemo-2.6.28.old.orig/net/mac80211/wme.c
+++ kernel-maemo-2.6.28.old/net/mac80211/wme.c
@@ -28,7 +28,7 @@
 /* Given a data frame determine the 802.1p/1d tag to use.  */
 static unsigned int classify_1d(struct sk_buff *skb)
 {
-	unsigned int dscp;
+	unsigned int dscp, priority;
 
 	/* skb->priority values from 256->263 are magic values to
 	 * directly indicate a specific 802.1d priority.  This is used
@@ -47,7 +47,13 @@
 		return 0;
 	}
 
-	return dscp >> 5;
+	priority = dscp >> 5;
+
+	/* hack: compatibility with diablo SO_PRIORITY values */
+	if (priority == 0 && skb->priority >= 1 && skb->priority <= 7)
+		return skb->priority;
+
+	return priority;
 }
 
 
--- kernel-maemo-2.6.28.old.orig/sound/soc/omap/aic34b_dummy.c
+++ kernel-maemo-2.6.28.old/sound/soc/omap/aic34b_dummy.c
@@ -134,6 +134,12 @@
 }
 EXPORT_SYMBOL(aic34b_set_mic_bias);
 
+int aic34b_get_mic_bias(void)
+{
+	return aic34b_bias;
+}
+EXPORT_SYMBOL(aic34b_get_mic_bias);
+
 int aic34b_set_volume(u8 volume)
 {
 	u8 val;
--- kernel-maemo-2.6.28.old.orig/sound/soc/omap/aic34b_dummy.h
+++ kernel-maemo-2.6.28.old/sound/soc/omap/aic34b_dummy.h
@@ -26,6 +26,7 @@
 
 extern void aic34b_ear_enable(int enable);
 void aic34b_set_mic_bias(int bias);
+int aic34b_get_mic_bias(void);
 int aic34b_set_volume(u8 volume);
 
 #endif
--- kernel-maemo-2.6.28.old.orig/sound/soc/omap/rx51.c
+++ kernel-maemo-2.6.28.old/sound/soc/omap/rx51.c
@@ -633,6 +633,59 @@
 	return change;
 }
 
+#define SOC_RX51_SINGLE_JACK_BIAS(xname) \
+{ \
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \
+		  SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+	.info = rx51_info_jack_bias, \
+	.get = rx51_get_jack_bias, \
+	.put = rx51_put_jack_bias, \
+}
+
+static int rx51_info_jack_bias(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+
+	return 0;
+}
+
+static int rx51_get_jack_bias(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = (aic34b_get_mic_bias() != 0);
+
+	return 0;
+}
+
+static int rx51_put_jack_bias(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	int change, new_value;
+
+	new_value = ucontrol->value.integer.value[0];
+	change = (new_value != aic34b_get_mic_bias());
+
+	if (change) {
+		switch (rx51_jack_func) {
+		case RX51_JACK_ECI:
+		case RX51_JACK_HS:
+		case RX51_JACK_MIC:
+			aic34b_set_mic_bias(new_value * 2); /* 2.5 V */
+			break;
+		default:
+			change = 0;
+		}
+	}
+
+	return change;
+}
+
 static const struct snd_soc_dapm_widget aic34_dapm_widgets[] = {
 	SND_SOC_DAPM_POST("Post event", rx51_post_event),
 	SND_SOC_DAPM_SPK("Post spk", rx51_post_spk_event),
@@ -732,6 +785,7 @@
 	SOC_RX51_EXT_SINGLE_TLV("Earphone Playback Volume",
 				RX51_EXT_API_AIC34B, 118,
 				aic3x_output_stage_tlv),
+	SOC_RX51_SINGLE_JACK_BIAS("Jack Bias Switch"),
 };
 
 static int rx51_aic34_init(struct snd_soc_codec *codec)
