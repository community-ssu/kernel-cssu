diff -urN kernel-cssu-2.6.28/arch/arm/configs/rx51_defconfig kernel-power-2.6.28.new/arch/arm/configs/rx51_defconfig
--- kernel-cssu-2.6.28/arch/arm/configs/rx51_defconfig	2011-10-11 13:51:21.756718563 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/configs/rx51_defconfig	2011-10-11 20:32:27.976257000 +0100
@@ -1514,7 +1514,7 @@
 CONFIG_FB_OMAP_BOOTLOADER_INIT=y
 CONFIG_FB_OMAP_CONSISTENT_DMA_SIZE=14
 CONFIG_OMAP2_DSS=y
-CONFIG_OMAP2_DSS_VRAM_SIZE=0
+CONFIG_OMAP2_DSS_VRAM_SIZE=8
 # CONFIG_OMAP2_DSS_DEBUG_SUPPORT is not set
 # CONFIG_OMAP2_DSS_RFBI is not set
 CONFIG_OMAP2_DSS_VENC=y
@@ -1955,7 +1955,7 @@
 # CONFIG_CBUS is not set
 CONFIG_MPU_BRIDGE=m
 CONFIG_BRIDGE_DVFS=y
-CONFIG_BRIDGE_MEMPOOL_SIZE=0x412800
+CONFIG_BRIDGE_MEMPOOL_SIZE=0x600000
 # CONFIG_BRIDGE_DEBUG is not set
 
 #
diff -urN kernel-cssu-2.6.28/arch/arm/mach-omap2/dspbridge.c kernel-power-2.6.28.new/arch/arm/mach-omap2/dspbridge.c
--- kernel-cssu-2.6.28/arch/arm/mach-omap2/dspbridge.c	2011-10-11 13:50:56.340880660 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/mach-omap2/dspbridge.c	2011-10-29 20:29:54.187994000 +0100
@@ -15,17 +15,184 @@
 
 #include <mach/omap-pm.h>
 
+#include "omap3-opp.h"
+
 #include <dspbridge/host_os.h>
 
+#define BRIDGE_THRESH_HIGH_PERCENT	95
+#define BRIDGE_THRESH_LOW_PERCENT	88
+
 static struct platform_device *dspbridge_pdev;
+static int update_mpu_speeds(struct dspbridge_platform_data *pdata);
+static u8 dspbridge_get_opp_for_freq(unsigned long f);
 
 static struct dspbridge_platform_data dspbridge_pdata __initdata = {
-	.dsp_set_min_opp = omap_pm_dsp_set_min_opp,
-	.dsp_get_opp	 = omap_pm_dsp_get_opp,
-	.cpu_set_freq	 = omap_pm_cpu_set_freq,
-	.cpu_get_freq	 = omap_pm_cpu_get_freq,
+	.dsp_set_min_opp	= omap_pm_dsp_set_min_opp,
+	.dsp_get_opp		= omap_pm_dsp_get_opp,
+	.cpu_set_freq		= omap_pm_cpu_set_freq,
+	.cpu_get_freq		= omap_pm_cpu_get_freq,
+	.dsp_get_opp_for_freq	= dspbridge_get_opp_for_freq,
+};
+
+static int update_mpu_speeds(struct dspbridge_platform_data *pdata);
+
+static int dspbridge_policy_notification(struct notifier_block *op,
+		unsigned long val, void *ptr)
+{
+	if(CPUFREQ_ADJUST == val)
+		update_mpu_speeds(dspbridge_pdev->dev.platform_data);
+	return 0;
+}
+
+static struct notifier_block iva_clk_policy_notifier = {
+	.notifier_call = dspbridge_policy_notification,
+	NULL,
+};
+
+struct omap_opp dsp_rate_table[] = {
+	{0, 0, 0},
+	{90000,  VDD1_OPP1,   0},
+	{180000, VDD1_OPP2,   0},
+	{360000, VDD1_OPP3,   0},
+	{400000, VDD1_OPP4,   0},
+	{430000, VDD1_OPP5,   0},
+	{460000, VDD1_OPP6,   0},
+	{480000, VDD1_OPP7,   0},
+	{500000, VDD1_OPP8,   0},
+	{520000, VDD1_OPP9,   0},
+	{540000, VDD1_OPP10,  0},
+	{560000, VDD1_OPP11,  0},
+	{580000, VDD1_OPP12,  0},
+	{600000, VDD1_OPP13,  0},
 };
 
+static u8 dspbridge_get_opp_for_freq(unsigned long f)
+{
+	u8 opp;
+	struct dspbridge_platform_data * pdata=dspbridge_pdev->dev.platform_data;
+	unsigned long dsp_freq=0;
+
+	for(opp=1; opp<=pdata->mpu_num_speeds; opp++)
+		if(pdata->mpu_speeds[opp]/1000 >= f)
+		{
+			dsp_freq = omap3_dsp_rate_table[opp].rate / 1000;
+			break;
+		}
+	for(opp=1; opp<=pdata->dsp_num_speeds; opp++)
+		if(dsp_rate_table[opp].rate >= dsp_freq)
+			break;
+	return opp;
+}
+
+static int update_mpu_speeds(struct dspbridge_platform_data *pdata)
+{
+#ifdef CONFIG_BRIDGE_DVFS
+	int mpu_freqs;
+	int dsp_freqs;
+	int i;
+	unsigned long old_rate;
+	struct cpufreq_policy policy;
+	i = cpufreq_get_policy(&policy,0);
+	if(i)
+	{
+		pr_err("%s cpufreq_get_policy failed %d\n",__func__,i);
+		return i;
+	}
+
+	mpu_freqs = MAX_VDD1_OPP;
+	dsp_freqs = VDD1_OPP13;
+	if (mpu_freqs < 0 || dsp_freqs < 0 || mpu_freqs != dsp_freqs) {
+		pr_err("%s:mpu and dsp frequencies are inconsistent! "
+			"mpu_freqs=%d dsp_freqs=%d\n", __func__, mpu_freqs,
+			dsp_freqs);
+		return -EINVAL;
+	}
+	
+	kfree(pdata->mpu_speeds);
+	kfree(pdata->dsp_freq_table);
+	pdata->mpu_speeds = NULL;
+	pdata->dsp_freq_table = NULL;
+
+	/* allocate memory if we have opps initialized */
+	pdata->mpu_speeds = kzalloc(sizeof(u32) * mpu_freqs,
+			GFP_KERNEL);
+	if (!pdata->mpu_speeds) {
+		pr_err("%s:unable to allocate memory for the mpu"
+			"frequencies\n", __func__);
+		return -ENOMEM;
+	}
+	
+	/* Walk through allowed frequencies and buid table*/
+	pdata->mpu_max_opp = mpu_freqs;
+	for(i=1;i<=mpu_freqs;i++)
+	{
+		pdata->mpu_speeds[i] = omap3_mpu_rate_table[i].rate;
+		if((pdata->mpu_speeds[i] >= policy.max*1000) && (pdata->mpu_max_opp == mpu_freqs))
+			pdata->mpu_max_opp=i;
+	}
+	
+	pdata->mpu_num_speeds = mpu_freqs;
+	pdata->mpu_min_speed = policy.min*1000;
+	pdata->mpu_max_speed = policy.max*1000;
+	
+	/* need an initial terminator */
+	
+	pdata->dsp_freq_table = kzalloc(
+			sizeof(struct dsp_shm_freq_table) *
+			(dsp_freqs+1 ), GFP_KERNEL);
+	if (!pdata->dsp_freq_table) {
+		pr_err("%s: unable to allocate memory for the dsp"
+			"frequencies\n", __func__);
+		return -ENOMEM;
+	}
+	old_rate = 0;
+	
+	for(i=1;i<=dsp_freqs;i++) {
+		/* dsp frequencies are in khz */
+		u32 rate = dsp_rate_table[i].rate;
+    
+		/*
+		 * On certain 34xx silicons, certain OPPs are duplicated
+		 * for DSP - handle those by copying previous opp value
+		 */
+		if (rate == old_rate) {
+			memcpy(&pdata->dsp_freq_table[i],
+				&pdata->dsp_freq_table[i-1],
+				sizeof(struct dsp_shm_freq_table));
+		} else {
+			pdata->dsp_freq_table[i].dsp_freq = rate;
+			pdata->dsp_freq_table[i].u_volts =
+				dsp_rate_table[i].vsel;
+			/*
+			 * min threshold:
+			 * NOTE: index 1 needs a min of 0! else no
+			 * scaling happens at DSP!
+			 */
+			pdata->dsp_freq_table[i].thresh_min_freq =
+				((old_rate * BRIDGE_THRESH_LOW_PERCENT) / 100);
+    
+			/* max threshold */
+			pdata->dsp_freq_table[i].thresh_max_freq =
+				((rate * BRIDGE_THRESH_HIGH_PERCENT) / 100);
+		}
+		old_rate = rate;
+	}
+	/* the last entry should map with maximum rate */
+	pdata->dsp_freq_table[i - 1].thresh_max_freq = old_rate;
+	
+	pdata->dsp_num_speeds = dsp_freqs;
+#endif
+	return 0;
+}
+
+static int __init get_opp_table(struct dspbridge_platform_data *pdata)
+{
+#ifdef CONFIG_BRIDGE_DVFS
+	return update_mpu_speeds(pdata);
+#else
+	return 0;
+#endif
+}
 static int __init dspbridge_init(void)
 {
 	struct platform_device *pdev;
@@ -44,6 +211,10 @@
 	if (!pdev)
 		goto err_out;
 
+	err = get_opp_table(pdata);
+	if (err)
+		goto err_out;
+
 	err = platform_device_add_data(pdev, pdata, sizeof(*pdata));
 	if (err)
 		goto err_out;
@@ -53,6 +224,11 @@
 		goto err_out;
 
 	dspbridge_pdev = pdev;
+	if (cpufreq_register_notifier(&iva_clk_policy_notifier,
+					CPUFREQ_POLICY_NOTIFIER))
+		pr_err("%s: cpufreq_register_notifier failed for "
+		       "iva2_ck\n", __func__);
+	
 	return 0;
 
 err_out:
@@ -63,6 +239,15 @@
 
 static void __exit dspbridge_exit(void)
 {
+	struct dspbridge_platform_data *pdata = &dspbridge_pdata;
+	if (cpufreq_unregister_notifier(&iva_clk_policy_notifier,
+						CPUFREQ_POLICY_NOTIFIER))
+		pr_err("%s: cpufreq_unregister_notifier failed for iva2_ck\n",
+			__func__);
+	kfree(pdata->mpu_speeds);
+	kfree(pdata->dsp_freq_table);
+	pdata->mpu_speeds = NULL;
+	pdata->dsp_freq_table = NULL;
 	platform_device_unregister(dspbridge_pdev);
 }
 module_exit(dspbridge_exit);
diff -urN kernel-cssu-2.6.28/arch/arm/mach-omap2/mailbox.c kernel-power-2.6.28.new/arch/arm/mach-omap2/mailbox.c
--- kernel-cssu-2.6.28/arch/arm/mach-omap2/mailbox.c	2011-10-11 13:50:51.509840006 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/mach-omap2/mailbox.c	2011-10-13 20:52:53.670502000 +0100
@@ -1,7 +1,7 @@
 /*
  * Mailbox reservation modules for OMAP2/3
  *
- * Copyright (C) 2006-2008 Nokia Corporation
+ * Copyright (C) 2006-2009 Nokia Corporation
  * Written by: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
  *        and  Paul Mundt
  *
@@ -27,13 +27,30 @@
 #define MAILBOX_FIFOSTATUS(m)		(0x080 + 4 * (m))
 #define MAILBOX_MSGSTATUS(m)		(0x0c0 + 4 * (m))
 #define MAILBOX_IRQSTATUS(u)		(0x100 + 8 * (u))
-#define MAILBOX_IRQENABLE(u)		(0x108 + 8 * (u))
+#define MAILBOX_IRQENABLE(u)		(0x104 + 8 * (u))
 
-#define MAILBOX_IRQ_NEWMSG(u)		(1 << (2 * (u)))
-#define MAILBOX_IRQ_NOTFULL(u)		(1 << (2 * (u) + 1))
+#define OMAP4_MAILBOX_IRQSTATUS(u)	(0x104 + 10 * (u))
+#define OMAP4_MAILBOX_IRQENABLE(u)	(0x108 + 10 * (u))
+#define OMAP4_MAILBOX_IRQENABLE_CLR(u)	(0x10c + 10 * (u))
+
+#define MAILBOX_IRQ_NEWMSG(m)		(1 << (2 * (m)))
+#define MAILBOX_IRQ_NOTFULL(m)		(1 << (2 * (m) + 1))
+
+/* SYSCONFIG: register bit definition */
+#define AUTOIDLE	(1 << 0)
+#define SOFTRESET	(1 << 1)
+#define SMARTIDLE	(2 << 3)
+
+/* SYSSTATUS: register bit definition */
+#define RESETDONE	(1 << 0)
 
 #define MBOX_REG_SIZE			0x120
 
+#define OMAP4_MBOX_REG_SIZE		0x130
+
+#define MBOX_NR_REGS			(MBOX_REG_SIZE / sizeof(u32))
+#define OMAP4_MBOX_NR_REGS		(OMAP4_MBOX_REG_SIZE / sizeof(u32))
+
 static void __iomem *mbox_base;
 
 struct omap_mbox2_fifo {
@@ -49,13 +66,19 @@
 	unsigned long irqstatus;
 	u32 newmsg_bit;
 	u32 notfull_bit;
-	char ctx[MBOX_REG_SIZE];
+	u32 ctx[OMAP4_MBOX_NR_REGS];
+	unsigned long irqdisable;
 };
 
 static struct clk *mbox_ick_handle;
 
 static void omap2_mbox_enable_irq(struct omap_mbox *mbox,
 				  omap_mbox_type_t irq);
+static inline unsigned int cpu_is_omap44xx();
+static inline unsigned int cpu_is_omap44xx()
+{
+    return 0;
+}
 
 static inline unsigned int mbox_read_reg(size_t ofs)
 {
@@ -70,21 +93,34 @@
 /* Mailbox H/W preparations */
 static int omap2_mbox_startup(struct omap_mbox *mbox)
 {
-	unsigned int l;
+	u32 l;
+	unsigned long timeout;
 
 	mbox_ick_handle = clk_get(NULL, "mailboxes_ick");
 	if (IS_ERR(mbox_ick_handle)) {
-		printk("Could not get mailboxes_ick\n");
-		return -ENODEV;
+		printk(KERN_ERR "Could not get mailboxes_ick: %ld\n",
+			PTR_ERR(mbox_ick_handle));
+		return PTR_ERR(mbox_ick_handle);
 	}
 	clk_enable(mbox_ick_handle);
 
+	mbox_write_reg(SOFTRESET, MAILBOX_SYSCONFIG);
+	timeout = jiffies + msecs_to_jiffies(20);
+	do {
+		l = mbox_read_reg(MAILBOX_SYSSTATUS);
+		if (l & RESETDONE)
+			break;
+	} while (!time_after(jiffies, timeout));
+
+	if (!(l & RESETDONE)) {
+		pr_err("Can't take mmu out of reset\n");
+		return -ENODEV;
+	}
+
 	l = mbox_read_reg(MAILBOX_REVISION);
 	pr_info("omap mailbox rev %d.%d\n", (l & 0xf0) >> 4, (l & 0x0f));
 
-	/* set smart-idle & autoidle */
-	l = mbox_read_reg(MAILBOX_SYSCONFIG);
-	l |= 0x00000011;
+	l = SMARTIDLE | AUTOIDLE;
 	mbox_write_reg(l, MAILBOX_SYSCONFIG);
 
 	omap2_mbox_enable_irq(mbox, IRQ_RX);
@@ -96,6 +132,7 @@
 {
 	clk_disable(mbox_ick_handle);
 	clk_put(mbox_ick_handle);
+	mbox_ick_handle = NULL;
 }
 
 /* Mailbox FIFO handle functions */
@@ -124,7 +161,7 @@
 {
 	struct omap_mbox2_fifo *fifo =
 		&((struct omap_mbox2_priv *)mbox->priv)->tx_fifo;
-	return (mbox_read_reg(fifo->fifo_stat));
+	return mbox_read_reg(fifo->fifo_stat);
 }
 
 /* Mailbox IRQ handle functions */
@@ -144,10 +181,9 @@
 {
 	struct omap_mbox2_priv *p = (struct omap_mbox2_priv *)mbox->priv;
 	u32 l, bit = (irq == IRQ_TX) ? p->notfull_bit : p->newmsg_bit;
-
-	l = mbox_read_reg(p->irqenable);
+	l = mbox_read_reg(p->irqdisable);
 	l &= ~bit;
-	mbox_write_reg(l, p->irqenable);
+	mbox_write_reg(l, p->irqdisable);
 }
 
 static void omap2_mbox_ack_irq(struct omap_mbox *mbox,
@@ -157,6 +193,9 @@
 	u32 bit = (irq == IRQ_TX) ? p->notfull_bit : p->newmsg_bit;
 
 	mbox_write_reg(bit, p->irqstatus);
+
+	/* Flush posted write for irq status to avoid spurious interrupts */
+	mbox_read_reg(p->irqstatus);
 }
 
 static int omap2_mbox_is_irq(struct omap_mbox *mbox,
@@ -167,21 +206,23 @@
 	u32 enable = mbox_read_reg(p->irqenable);
 	u32 status = mbox_read_reg(p->irqstatus);
 
-	return (enable & status & bit);
+	return (int)(enable & status & bit);
 }
 
 static void omap2_mbox_save_ctx(struct omap_mbox *mbox)
 {
 	int i;
 	struct omap_mbox2_priv *p = mbox->priv;
+	int nr_regs;
+	if (cpu_is_omap44xx())
+		nr_regs = OMAP4_MBOX_NR_REGS;
+	else
+		nr_regs = MBOX_NR_REGS;
+	for (i = 0; i < nr_regs; i++) {
+		p->ctx[i] = mbox_read_reg(i * sizeof(u32));
 
-	for (i = 0; i < MBOX_REG_SIZE; i += sizeof(u32)) {
-		u32 val;
-
-		val = mbox_read_reg(i);
-		*(u32 *)(p->ctx + i) = val;
-
-		dev_dbg(mbox->dev, "%s\t[%02d] %08x\n", __func__, i, val);
+		dev_dbg(mbox->dev, "%s: [%02x] %08x\n", __func__,
+			i, p->ctx[i]);
 	}
 }
 
@@ -189,14 +230,16 @@
 {
 	int i;
 	struct omap_mbox2_priv *p = mbox->priv;
+	int nr_regs;
+	if (cpu_is_omap44xx())
+		nr_regs = OMAP4_MBOX_NR_REGS;
+	else
+		nr_regs = MBOX_NR_REGS;
+	for (i = 0; i < nr_regs; i++) {
+		mbox_write_reg(p->ctx[i], i * sizeof(u32));
 
-	for (i = 0; i < MBOX_REG_SIZE; i += sizeof(u32)) {
-		u32 val;
-
-		val = *(u32 *)(p->ctx + i);
-		mbox_write_reg(val, i);
-
-		dev_dbg(mbox->dev, "%s\t[%02d] %08x\n", __func__, i, val);
+		dev_dbg(mbox->dev, "%s: [%02x] %08x\n", __func__,
+			i, p->ctx[i]);
 	}
 }
 
@@ -224,7 +267,6 @@
  */
 
 /* FIXME: the following structs should be filled automatically by the user id */
-
 /* DSP */
 static struct omap_mbox2_priv omap2_mbox_dsp_priv = {
 	.tx_fifo = {
@@ -239,7 +281,35 @@
 	.irqstatus	= MAILBOX_IRQSTATUS(0),
 	.notfull_bit	= MAILBOX_IRQ_NOTFULL(0),
 	.newmsg_bit	= MAILBOX_IRQ_NEWMSG(1),
+	.irqdisable	= MAILBOX_IRQENABLE(0),
+};
+
+
+
+/* OMAP4 specific data structure. Use the cpu_is_omap4xxx()
+to use this*/
+static struct omap_mbox2_priv omap2_mbox_1_priv = {
+	.tx_fifo = {
+		.msg		= MAILBOX_MESSAGE(0),
+		.fifo_stat	= MAILBOX_FIFOSTATUS(0),
+	},
+	.rx_fifo = {
+		.msg		= MAILBOX_MESSAGE(1),
+		.msg_stat	= MAILBOX_MSGSTATUS(1),
+	},
+	.irqenable	= OMAP4_MAILBOX_IRQENABLE(0),
+	.irqstatus	= OMAP4_MAILBOX_IRQSTATUS(0),
+	.notfull_bit	= MAILBOX_IRQ_NOTFULL(0),
+	.newmsg_bit	= MAILBOX_IRQ_NEWMSG(1),
+	.irqdisable	= OMAP4_MAILBOX_IRQENABLE_CLR(0),
+};
+
+struct omap_mbox mbox_1_info = {
+	.name	= "mailbox-1",
+	.ops	= &omap2_mbox_ops,
+	.priv	= &omap2_mbox_1_priv,
 };
+EXPORT_SYMBOL(mbox_1_info);
 
 struct omap_mbox mbox_dsp_info = {
 	.name	= "dsp",
@@ -248,6 +318,30 @@
 };
 EXPORT_SYMBOL(mbox_dsp_info);
 
+static struct omap_mbox2_priv omap2_mbox_2_priv = {
+	.tx_fifo = {
+		.msg		= MAILBOX_MESSAGE(3),
+		.fifo_stat	= MAILBOX_FIFOSTATUS(3),
+	},
+	.rx_fifo = {
+		.msg		= MAILBOX_MESSAGE(2),
+		.msg_stat	= MAILBOX_MSGSTATUS(2),
+	},
+	.irqenable	= OMAP4_MAILBOX_IRQENABLE(0),
+	.irqstatus	= OMAP4_MAILBOX_IRQSTATUS(0),
+	.notfull_bit	= MAILBOX_IRQ_NOTFULL(3),
+	.newmsg_bit	= MAILBOX_IRQ_NEWMSG(2),
+	.irqdisable     = OMAP4_MAILBOX_IRQENABLE_CLR(0),
+};
+
+struct omap_mbox mbox_2_info = {
+	.name	= "mailbox-2",
+	.ops	= &omap2_mbox_ops,
+	.priv	= &omap2_mbox_2_priv,
+};
+EXPORT_SYMBOL(mbox_2_info);
+
+
 #if defined(CONFIG_ARCH_OMAP2420) /* IVA */
 static struct omap_mbox2_priv omap2_mbox_iva_priv = {
 	.tx_fifo = {
@@ -262,6 +356,7 @@
 	.irqstatus	= MAILBOX_IRQSTATUS(3),
 	.notfull_bit	= MAILBOX_IRQ_NOTFULL(2),
 	.newmsg_bit	= MAILBOX_IRQ_NEWMSG(3),
+	.irqdisable	= MAILBOX_IRQENABLE(3),
 };
 
 static struct omap_mbox mbox_iva_info = {
@@ -282,23 +377,36 @@
 		dev_err(&pdev->dev, "invalid mem resource\n");
 		return -ENODEV;
 	}
-	mbox_base = ioremap(res->start, res->end - res->start);
+	mbox_base = ioremap(res->start, resource_size(res));
 	if (!mbox_base)
 		return -ENOMEM;
 
 	/* DSP or IVA2 IRQ */
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+
 	if (unlikely(!res)) {
 		dev_err(&pdev->dev, "invalid irq resource\n");
 		ret = -ENODEV;
 		goto err_dsp;
 	}
-	mbox_dsp_info.irq = res->start;
-
-	ret = omap_mbox_register(&pdev->dev, &mbox_dsp_info);
+	if (cpu_is_omap44xx()) {
+		mbox_1_info.irq = res->start;
+		ret = omap_mbox_register(&pdev->dev, &mbox_1_info);
+	} else {
+		mbox_dsp_info.irq = res->start;
+		ret = omap_mbox_register(&pdev->dev, &mbox_dsp_info);
+	}
 	if (ret)
 		goto err_dsp;
 
+	if (cpu_is_omap44xx()) {
+		mbox_2_info.irq = res->start;
+		ret = omap_mbox_register(&pdev->dev, &mbox_2_info);
+		if (ret) {
+			omap_mbox_unregister(&mbox_1_info);
+			goto err_dsp;
+		}
+	}
 #if defined(CONFIG_ARCH_OMAP2420) /* IVA */
 	if (cpu_is_omap2420()) {
 		/* IVA IRQ */
@@ -318,6 +426,7 @@
 
 err_iva1:
 	omap_mbox_unregister(&mbox_dsp_info);
+
 err_dsp:
 	iounmap(mbox_base);
 	return ret;
@@ -328,7 +437,12 @@
 #if defined(CONFIG_ARCH_OMAP2420)
 	omap_mbox_unregister(&mbox_iva_info);
 #endif
-	omap_mbox_unregister(&mbox_dsp_info);
+
+	if (cpu_is_omap44xx()) {
+		omap_mbox_unregister(&mbox_2_info);
+		omap_mbox_unregister(&mbox_1_info);
+	} else
+		omap_mbox_unregister(&mbox_dsp_info);
 	iounmap(mbox_base);
 	return 0;
 }
@@ -355,6 +469,7 @@
 module_exit(omap2_mbox_exit);
 
 MODULE_LICENSE("GPL v2");
-MODULE_DESCRIPTION("omap mailbox: omap2/3 architecture specific functions");
-MODULE_AUTHOR("Hiroshi DOYU <Hiroshi.DOYU@nokia.com>, Paul Mundt");
+MODULE_DESCRIPTION("omap mailbox: omap2/3/4 architecture specific functions");
+MODULE_AUTHOR("Hiroshi DOYU <Hiroshi.DOYU@nokia.com>");
+MODULE_AUTHOR("Paul Mundt");
 MODULE_ALIAS("platform:"DRV_NAME);
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/brddefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/brddefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/brddefs.h	2011-10-11 13:50:57.349662913 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/brddefs.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global BRD constants and types, shared between WCD and WMD.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,41 +16,24 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== brddefs.h ========
- *  Description:
- *      Global BRD constants and types, shared between WSX, WCD, and WMD.
- *
- *! Revision History:
- *! ================
- *! 31-Jan-2000 rr: Comment Exec changed to Monitor
- *! 22-Jul-1999 jeh Added BRD_LOADED state.
- *! 26-Mar-1997 gp: Added BRD_SYNCINIT state.
- *! 11-Dec-1996 cr: Added BRD_LASTSTATE definition.
- *! 11-Jul-1996 gp: Added missing u32 callback argument to BRD_CALLBACK.
- *! 10-Jun-1996 gp: Created from board.h and brd.h.
- */
-
 #ifndef BRDDEFS_
 #define BRDDEFS_
 
 /* platform status values */
 #define BRD_STOPPED     0x0	/* No Monitor Loaded, Not running. */
-#define BRD_IDLE        0x1	/* Monitor Loaded, but suspended.  */
-#define BRD_RUNNING     0x2	/* Monitor loaded, and executing.  */
+#define BRD_IDLE        0x1	/* Monitor Loaded, but suspended. */
+#define BRD_RUNNING     0x2	/* Monitor loaded, and executing. */
 #define BRD_UNKNOWN     0x3	/* Board state is indeterminate. */
 #define BRD_SYNCINIT    0x4
 #define BRD_LOADED      0x5
 #define BRD_LASTSTATE   BRD_LOADED	/* Set to highest legal board state. */
-#define BRD_SLEEP_TRANSITION 0x6	/* Sleep transition in progress  */
-#define BRD_HIBERNATION 0x7		/* MPU initiated hibernation */
-#define BRD_RETENTION     0x8       /* Retention mode */
-#define BRD_DSP_HIBERNATION     0x9       /* DSP initiated hibernation */
-#define BRD_ERROR		0xA       /* Board state is Error */
-	typedef u32 BRD_STATUS;
+#define BRD_SLEEP_TRANSITION 0x6	/* Sleep transition in progress */
+#define BRD_HIBERNATION 0x7	/* MPU initiated hibernation */
+#define BRD_RETENTION     0x8	/* Retention mode */
+#define BRD_DSP_HIBERNATION     0x9	/* DSP initiated hibernation */
+#define BRD_ERROR		0xA	/* Board state is Error */
 
 /* BRD Object */
-	struct BRD_OBJECT;
+struct brd_object;
 
-#endif				/* BRDDEFS_ */
+#endif /* BRDDEFS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/cfgdefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/cfgdefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/cfgdefs.h	2011-10-11 13:50:57.349662913 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/cfgdefs.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global CFG constants and types, shared between class and mini driver.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,31 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== cfgdefs.h ========
- *  Purpose:
- *      Global CFG constants and types, shared between class and mini driver.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 kc  Removed wIOPort* in CFG_HOSTRES.
- *! 06-Sep-2000 jeh Added channel info to CFG_HOSTRES.
- *! 09-May-2000 rr: CFG_HOSTRES now support multiple windows for PCI support.
- *! 31-Jan-2000 rr: Comments changed after code review.
- *! 06-Jan-2000 rr: Bus Type included in CFG_HOSTRES.
- *! 12-Nov-1999 rr: CFG_HOSTRES member names changed.
- *! 25-Oct-1999 rr: Modified the CFG_HOSTRES Structure
- *!                 PCMCIA ISR Register/Unregister fxn removed..
- *!                 New flag PCCARD introduced during compile time.
- *! 10-Sep-1999 ww: Added PCMCIA ISR Register/Unregister fxn.
- *! 01-Sep-1999 ag: Removed NT/95 specific fields in CFG_HOSTRES
- *! 27-Oct-1997 cr: Updated CFG_HOSTRES struct to support 1+ IRQs per board.
- *! 17-Sep-1997 gp: Tacked some NT config info to end of CFG_HOSTRES structure.
- *! 12-Dec-1996 cr: Cleaned up after code review.
- *! 14-Nov-1996 gp: Renamed from wsxcfg.h
- *! 19-Jun-1996 cr: Created.
- */
-
 #ifndef CFGDEFS_
 #define CFGDEFS_
 
@@ -48,7 +25,7 @@
 /* Maximum length of general paths. */
 #define CFG_MAXPATH             255
 
-/* Host Resources:  */
+/* Host Resources: */
 #define CFG_MAXMEMREGISTERS     9
 #define CFG_MAXIOPORTS          20
 #define CFG_MAXIRQS             7
@@ -62,55 +39,54 @@
 #define CFG_DEFAULT_NUM_WINDOWS 1	/* We support only one window. */
 
 /* A platform-related device handle: */
-	struct CFG_DEVNODE;
+struct cfg_devnode;
 
 /*
  *  Host resource structure.
  */
-	struct CFG_HOSTRES {
-		u32 wNumMemWindows;	/* Set to default */
-		/* This is the base.memory */
-		u32 dwMemBase[CFG_MAXMEMREGISTERS];  /* SHM virtual address */
-		u32 dwMemLength[CFG_MAXMEMREGISTERS]; /* Length of the Base */
-		u32 dwMemPhys[CFG_MAXMEMREGISTERS]; /* SHM Physical address */
-		u8 bIRQRegisters;	/* IRQ Number */
-		u8 bIRQAttrib;	/* IRQ Attribute */
-		u32 dwOffsetForMonitor;	/* The Shared memory starts from
-					 * dwMemBase + this offset */
+struct cfg_hostres {
+	u32 num_mem_windows;	/* Set to default */
+	/* This is the base.memory */
+	u32 dw_mem_base[CFG_MAXMEMREGISTERS];	/* shm virtual address */
+	u32 dw_mem_length[CFG_MAXMEMREGISTERS];	/* Length of the Base */
+	u32 dw_mem_phys[CFG_MAXMEMREGISTERS];	/* shm Physical address */
+	u8 birq_registers;	/* IRQ Number */
+	u8 birq_attrib;		/* IRQ Attribute */
+	u32 dw_offset_for_monitor;	/* The Shared memory starts from
+					 * dw_mem_base + this offset */
 	/*
 	 *  Info needed by NODE for allocating channels to communicate with RMS:
-	 *      dwChnlOffset:       Offset of RMS channels. Lower channels are
+	 *      dw_chnl_offset:       Offset of RMS channels. Lower channels are
 	 *                          reserved.
-	 *      dwChnlBufSize:      Size of channel buffer to send to RMS
-	 *      dwNumChnls:       Total number of channels (including reserved).
+	 *      dw_chnl_buf_size:      Size of channel buffer to send to RMS
+	 *      dw_num_chnls:		Total number of channels
+	 *			(including reserved).
 	 */
-		u32 dwChnlOffset;
-		u32 dwChnlBufSize;
-		u32 dwNumChnls;
-		void __iomem *dwPrmBase;
-		void __iomem *dwCmBase;
-		void __iomem *dwPerBase;
-		u32 dwPerPmBase;
-		u32 dwCorePmBase;
-		void __iomem *dwWdTimerDspBase;
-		void __iomem *dwMboxBase;
-		void __iomem *dwDmmuBase;
-		void __iomem *dwSysCtrlBase;
-	} ;
-
-	struct CFG_DSPMEMDESC {
-		u32 uMemType;	/* Type of memory.                        */
-		u32 ulMin;	/* Minimum amount of memory of this type. */
-		u32 ulMax;	/* Maximum amount of memory of this type. */
-	} ;
-
-	struct CFG_DSPRES {
-		u32 uChipType;	/* DSP chip type.               */
-		u32 uWordSize;	/* Number of bytes in a word    */
-		u32 cChips;	/* Number of chips.             */
-		u32 cMemTypes;	/* Types of memory.             */
-		struct CFG_DSPMEMDESC aMemDesc[CFG_DSPMAXMEMTYPES];
-		/* DSP Memory types */
-	} ;
+	u32 dw_chnl_offset;
+	u32 dw_chnl_buf_size;
+	u32 dw_num_chnls;
+	void __iomem *dw_prm_base;
+	void __iomem *dw_cm_base;
+	void __iomem *dw_per_base;
+	u32 dw_per_pm_base;
+	u32 dw_core_pm_base;
+	void __iomem *dw_dmmu_base;
+	void __iomem *dw_sys_ctrl_base;
+};
+
+struct cfg_dspmemdesc {
+	u32 mem_type;		/* Type of memory. */
+	u32 ul_min;		/* Minimum amount of memory of this type. */
+	u32 ul_max;		/* Maximum amount of memory of this type. */
+};
+
+struct cfg_dspres {
+	u32 chip_type;		/* DSP chip type. */
+	u32 word_size;		/* Number of bytes in a word */
+	u32 chip_number;	/* Number of chips. */
+	u32 mem_types;		/* Types of memory. */
+	struct cfg_dspmemdesc mem_desc[CFG_DSPMAXMEMTYPES];
+	/* DSP Memory types */
+};
 
-#endif				/* CFGDEFS_ */
+#endif /* CFGDEFS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/cfg.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/cfg.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/cfg.h	2011-10-11 13:50:57.432894958 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/cfg.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * PM Configuration module.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,93 +16,45 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== cfg.h ========
- *  Purpose:
- *      PM Configuration module.
- *
- *  Private Functions:
- *      CFG_Exit
- *      CFG_GetAutoStart
- *      CFG_GetCDVersion
- *      CFG_GetDevObject
- *      CFG_GetDSPResources
- *      CFG_GetExecFile
- *      CFG_GetHostResources
- *      CFG_GetObject
- *      CFG_GetPerfValue
- *      CFG_GetWMDFileName
- *      CFG_GetZLFile
- *      CFG_Init
- *      CFG_SetDevObject
- *      CFG_SetObject
- *
- *! Revision History:
- *! =================
- *! 26-Feb-2003 kc  Removed unused CFG fxns.
- *! 28-Aug-2001 jeh  Added CFG_GetLoaderName.
- *! 26-Jul-2000 rr:  Added CFG_GetDCDName to retrieve the DCD Dll name.
- *! 13-Jul-2000 rr:  Added CFG_GetObject & CFG_SetObject.
- *! 13-Jan-2000 rr:  CFG_Get/SetPrivateDword renamed to CFG_Get/SetDevObject.
- *!                  CFG_GetWinBRIDGEDir/Directory,CFG_GetSearchPath removed.
- *! 15-Jan-1998 cr:  Code review cleanup.
- *! 16-Aug-1997 cr:  Added explicit cdecl identifiers.
- *! 12-Dec-1996 gp:  Moved CFG_FindInSearchPath to CSP module.
- *! 13-Sep-1996 gp:  Added CFG_GetBoardName().
- *! 22-Jul-1996 gp:  Added CFG_GetTraceStr, to retrieve an initial GT trace.
- *! 26-Jun-1996 cr:  Added CFG_FindInSearchPath.
- *! 25-Jun-1996 cr:  Added CFG_GetWinSPOXDir.
- *! 17-Jun-1996 cr:  Added CFG_GetDevNode.
- *! 11-Jun-1996 cr:  Cleaned up for code review.
- *! 07-Jun-1996 cr:  Added CFG_GetExecFile and CFG_GetZLFileName functions.
- *! 04-Jun-1996 gp:  Added AutoStart regkey and accessor function.  Placed
- *!                  OUT parameters in accessor function param. lists at end.
- *! 29-May-1996 gp:  Moved DEV_HDEVNODE to here and renamed CFG_HDEVNODE.
- *! 22-May-1996 cr:  Added GetHostResources, GetDSPResources, and
- *!                  GetWMDFileName services.
- *! 18-May-1996 gp:  Created.
- */
-
 #ifndef CFG_
 #define CFG_
 #include <dspbridge/host_os.h>
 #include <dspbridge/cfgdefs.h>
 
 /*
- *  ======== CFG_Exit ========
+ *  ======== cfg_exit ========
  *  Purpose:
  *      Discontinue usage of the CFG module.
  *  Parameters:
  *  Returns:
  *  Requires:
- *      CFG_Init(void) was previously called.
+ *      cfg_init(void) was previously called.
  *  Ensures:
- *      Resources acquired in CFG_Init(void) are freed.
+ *      Resources acquired in cfg_init(void) are freed.
  */
-	extern void CFG_Exit(void);
+extern void cfg_exit(void);
 
 /*
- *  ======== CFG_GetAutoStart ========
+ *  ======== cfg_get_auto_start ========
  *  Purpose:
  *      Retreive the autostart mask, if any, for this board.
  *  Parameters:
- *      hDevNode:       Handle to the DevNode who's WMD we are querying.
+ *      dev_node_obj:       Handle to the dev_node who's WMD we are querying.
  *      pdwAutoStart:   Ptr to location for 32 bit autostart mask.
  *  Returns:
  *      DSP_SOK:                Success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  dev_node_obj is invalid.
  *      CFG_E_RESOURCENOTAVAIL: Unable to retreive resource.
  *  Requires:
  *      CFG initialized.
  *  Ensures:
  *      DSP_SOK:        *pdwAutoStart contains autostart mask for this devnode.
  */
-	extern DSP_STATUS CFG_GetAutoStart(IN struct CFG_DEVNODE *hDevNode,
-					   OUT u32 *pdwAutoStart);
+extern dsp_status cfg_get_auto_start(IN struct cfg_devnode *dev_node_obj,
+				     OUT u32 *pdwAutoStart);
 
 /*
- *  ======== CFG_GetCDVersion ========
+ *  ======== cfg_get_cd_version ========
  *  Purpose:
  *      Retrieves the version of the PM Class Driver.
  *  Parameters:
@@ -116,18 +70,19 @@
  *      DSP_SOK:    Success.
  *      else:       *pdwVersion is NULL.
  */
-	extern DSP_STATUS CFG_GetCDVersion(OUT u32 *pdwVersion);
+extern dsp_status cfg_get_cd_version(OUT u32 *pdwVersion);
 
 /*
- *  ======== CFG_GetDevObject ========
+ *  ======== cfg_get_dev_object ========
  *  Purpose:
  *      Retrieve the Device Object handle for a given devnode.
  *  Parameters:
- *      hDevNode:       Platform's DevNode handle from which to retrieve value.
+ *      dev_node_obj:	Platform's dev_node handle from which to retrieve
+ *      		value.
  *      pdwValue:       Ptr to location to store the value.
  *  Returns:
  *      DSP_SOK:                Success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  dev_node_obj is invalid.
  *      CFG_E_INVALIDPOINTER:   phDevObject is invalid.
  *      CFG_E_RESOURCENOTAVAIL: The resource is not available.
  *  Requires:
@@ -136,19 +91,19 @@
  *      DSP_SOK:    *pdwValue is set to the retrieved u32.
  *      else:       *pdwValue is set to 0L.
  */
-	extern DSP_STATUS CFG_GetDevObject(IN struct CFG_DEVNODE *hDevNode,
-					   OUT u32 *pdwValue);
+extern dsp_status cfg_get_dev_object(IN struct cfg_devnode *dev_node_obj,
+				     OUT u32 *pdwValue);
 
 /*
- *  ======== CFG_GetDSPResources ========
+ *  ======== cfg_get_dsp_resources ========
  *  Purpose:
  *      Get the DSP resources available to a given device.
  *  Parameters:
- *      hDevNode:       Handle to the DEVNODE who's resources we are querying.
+ *      dev_node_obj:	Handle to the DEVNODE who's resources we are querying.
  *      pDSPResTable:   Ptr to a location to store the DSP resource table.
  *  Returns:
  *      DSP_SOK:                On success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  dev_node_obj is invalid.
  *      CFG_E_RESOURCENOTAVAIL: The DSP Resource information is not
  *                              available
  *  Requires:
@@ -157,45 +112,43 @@
  *      DSP_SOK:    pDSPResTable points to a filled table of resources allocated
  *                  for the specified WMD.
  */
-	extern DSP_STATUS CFG_GetDSPResources(IN struct CFG_DEVNODE *hDevNode,
-				      OUT struct CFG_DSPRES *pDSPResTable);
-
+extern dsp_status cfg_get_dsp_resources(IN struct cfg_devnode *dev_node_obj,
+					OUT struct cfg_dspres *pDSPResTable);
 
 /*
- *  ======== CFG_GetExecFile ========
+ *  ======== cfg_get_exec_file ========
  *  Purpose:
  *      Retreive the default executable, if any, for this board.
  *  Parameters:
- *      hDevNode:       Handle to the DevNode who's WMD we are querying.
- *      cBufSize:       Size of buffer.
+ *      dev_node_obj:       Handle to the dev_node who's WMD we are querying.
+ *      buf_size:       Size of buffer.
  *      pstrExecFile:   Ptr to character buf to hold ExecFile.
  *  Returns:
  *      DSP_SOK:                Success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  dev_node_obj is invalid.
  *      CFG_E_INVALIDPOINTER:   pstrExecFile is invalid.
  *      CFG_E_RESOURCENOTAVAIL: The resource is not available.
  *  Requires:
  *      CFG initialized.
  *  Ensures:
- *      DSP_SOK:    Not more than cBufSize bytes were copied into pstrExecFile,
+ *      DSP_SOK:    Not more than buf_size bytes were copied into pstrExecFile,
  *                  and *pstrExecFile contains default executable for this
  *                  devnode.
  */
-	extern DSP_STATUS CFG_GetExecFile(IN struct CFG_DEVNODE *hDevNode,
-					  IN u32 cBufSize,
-					  OUT char *pstrExecFile);
+extern dsp_status cfg_get_exec_file(IN struct cfg_devnode *dev_node_obj,
+				    IN u32 buf_size, OUT char *pstrExecFile);
 
 /*
- *  ======== CFG_GetHostResources ========
+ *  ======== cfg_get_host_resources ========
  *  Purpose:
  *      Get the Host PC allocated resources assigned to a given device.
  *  Parameters:
- *      hDevNode:       Handle to the DEVNODE who's resources we are querying.
+ *      dev_node_obj:	Handle to the DEVNODE who's resources we are querying.
  *      pHostResTable:  Ptr to a location to store the host resource table.
  *  Returns:
  *      DSP_SOK:                On success.
  *      CFG_E_INVALIDPOINTER:   pHostResTable is invalid.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  dev_node_obj is invalid.
  *      CFG_E_RESOURCENOTAVAIL: The resource is not available.
  *  Requires:
  *      CFG initialized.
@@ -204,16 +157,16 @@
  *                  allocated for the specified WMD.
  *
  */
-	extern DSP_STATUS CFG_GetHostResources(IN struct CFG_DEVNODE *hDevNode,
-				       OUT struct CFG_HOSTRES *pHostResTable);
+extern dsp_status cfg_get_host_resources(IN struct cfg_devnode *dev_node_obj,
+					 OUT struct cfg_hostres *pHostResTable);
 
 /*
- *  ======== CFG_GetObject ========
+ *  ======== cfg_get_object ========
  *  Purpose:
  *      Retrieve the Driver Object handle From the Registry
  *  Parameters:
  *      pdwValue:   Ptr to location to store the value.
- *      dwType      Type of Object to Get
+ *      dw_type      Type of Object to Get
  *  Returns:
  *      DSP_SOK:    Success.
  *  Requires:
@@ -222,10 +175,10 @@
  *      DSP_SOK:    *pdwValue is set to the retrieved u32(non-Zero).
  *      else:       *pdwValue is set to 0L.
  */
-	extern DSP_STATUS CFG_GetObject(OUT u32 *pdwValue, u32 dwType);
+extern dsp_status cfg_get_object(OUT u32 *pdwValue, u32 dw_type);
 
 /*
- *  ======== CFG_GetPerfValue ========
+ *  ======== cfg_get_perf_value ========
  *  Purpose:
  *      Retrieve a flag indicating whether PERF should log statistics for the
  *      PM class driver.
@@ -238,57 +191,56 @@
  *      pfEnablePerf != NULL;
  *  Ensures:
  */
-	extern void CFG_GetPerfValue(OUT bool *pfEnablePerf);
+extern void cfg_get_perf_value(OUT bool *pfEnablePerf);
 
 /*
- *  ======== CFG_GetWMDFileName ========
+ *  ======== cfg_get_wmd_file_name ========
  *  Purpose:
  *    Get the mini-driver file name for a given device.
  *  Parameters:
- *      hDevNode:       Handle to the DevNode who's WMD we are querying.
- *      cBufSize:       Size of buffer.
+ *      dev_node_obj:       Handle to the dev_node who's WMD we are querying.
+ *      buf_size:       Size of buffer.
  *      pWMDFileName:   Ptr to a character buffer to hold the WMD filename.
  *  Returns:
  *      DSP_SOK:                On success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  dev_node_obj is invalid.
  *      CFG_E_RESOURCENOTAVAIL: The filename is not available.
  *  Requires:
  *      CFG initialized.
  *  Ensures:
- *      DSP_SOK:        Not more than cBufSize bytes were copied
+ *      DSP_SOK:        Not more than buf_size bytes were copied
  *                      into pWMDFileName.
  *
  */
-	extern DSP_STATUS CFG_GetWMDFileName(IN struct CFG_DEVNODE *hDevNode,
-					     IN u32 cBufSize,
-					     OUT char *pWMDFileName);
+extern dsp_status cfg_get_wmd_file_name(IN struct cfg_devnode *dev_node_obj,
+					IN u32 buf_size,
+					OUT char *pWMDFileName);
 
 /*
- *  ======== CFG_GetZLFile ========
+ *  ======== cfg_get_zl_file ========
  *  Purpose:
  *      Retreive the ZLFile, if any, for this board.
  *  Parameters:
- *      hDevNode:       Handle to the DevNode who's WMD we are querying.
- *      cBufSize:       Size of buffer.
+ *      dev_node_obj:       Handle to the dev_node who's WMD we are querying.
+ *      buf_size:       Size of buffer.
  *      pstrZLFileName: Ptr to character buf to hold ZLFileName.
  *  Returns:
  *      DSP_SOK:                Success.
  *      CFG_E_INVALIDPOINTER:   pstrZLFileName is invalid.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  dev_node_obj is invalid.
  *      CFG_E_RESOURCENOTAVAIL: couldn't find the ZLFileName.
  *  Requires:
  *      CFG initialized.
  *  Ensures:
- *      DSP_SOK:    Not more than cBufSize bytes were copied into
+ *      DSP_SOK:    Not more than buf_size bytes were copied into
  *                  pstrZLFileName, and *pstrZLFileName contains ZLFileName
  *                  for this devnode.
  */
-	extern DSP_STATUS CFG_GetZLFile(IN struct CFG_DEVNODE *hDevNode,
-					IN u32 cBufSize,
-					OUT char *pstrZLFileName);
+extern dsp_status cfg_get_zl_file(IN struct cfg_devnode *dev_node_obj,
+				  IN u32 buf_size, OUT char *pstrZLFileName);
 
 /*
- *  ======== CFG_Init ========
+ *  ======== cfg_init ========
  *  Purpose:
  *      Initialize the CFG module's private state.
  *  Parameters:
@@ -298,26 +250,26 @@
  *  Ensures:
  *      A requirement for each of the other public CFG functions.
  */
-	extern bool CFG_Init(void);
+extern bool cfg_init(void);
 
 /*
- *  ======== CFG_SetDevObject ========
+ *  ======== cfg_set_dev_object ========
  *  Purpose:
  *      Store the Device Object handle for a given devnode.
  *  Parameters:
- *      hDevNode:   Platform's DevNode handle we are storing value with.
+ *      dev_node_obj:   Platform's dev_node handle we are storing value with.
  *      dwValue:    Arbitrary value to store.
  *  Returns:
  *      DSP_SOK:                Success.
- *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  dev_node_obj is invalid.
  *      DSP_EFAIL:              Internal Error.
  *  Requires:
  *      CFG initialized.
  *  Ensures:
  *      DSP_SOK:    The Private u32 was successfully set.
  */
-	extern DSP_STATUS CFG_SetDevObject(IN struct CFG_DEVNODE *hDevNode,
-					   IN u32 dwValue);
+extern dsp_status cfg_set_dev_object(IN struct cfg_devnode *dev_node_obj,
+				     IN u32 dwValue);
 
 /*
  *  ======== CFG_SetDrvObject ========
@@ -325,7 +277,7 @@
  *      Store the Driver Object handle.
  *  Parameters:
  *      dwValue:        Arbitrary value to store.
- *      dwType          Type of Object to Store
+ *      dw_type          Type of Object to Store
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Internal Error.
@@ -334,6 +286,6 @@
  *  Ensures:
  *      DSP_SOK:        The Private u32 was successfully set.
  */
-	extern DSP_STATUS CFG_SetObject(IN u32 dwValue, IN u32 dwType);
+extern dsp_status cfg_set_object(IN u32 dwValue, IN u32 dw_type);
 
-#endif				/* CFG_ */
+#endif /* CFG_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/chnldefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/chnldefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/chnldefs.h	2011-10-11 13:50:57.713203334 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/chnldefs.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * System-wide channel objects and constants.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,30 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== chnldefs.h ========
- *  Purpose:
- *      System-wide channel objects and constants.
- *
- *! Revision History:
- *! ================
- *! 19-Jan-2002 ag  Added cBufSize to IOC.
- *! 05-Jan-2000 ag: Text format cleanup.
- *! 02-Dec-1999 ag: Added new chnl attribute pstrEventName.
- *! 12-Nov-1999 kc: Enabled hEvent attribute for tests.
- *! 01-Nov-1999 ag: hEvent attribute not supported(yet).
- *! 16-Jan-1997 gp: Moved private stuff into chnlpriv.h
- *! 14-Jan-1997 gp: Updated based on code review feedback:
- *!                 Removed CHNL_MODENOWAIT, CHNL_MODEDIRECT,
- *! 03-Jan-1997 gp: Added channel class library types.
- *! 14-Dec-1996 gp: Moved uChnlId field from CHNL_ATTRS to CHNL_Open().
- *! 10-Dec-1996 gp: Added CHNL_IsTimedOut() macro.
- *! 14-Nov-1996 gp: Renamed from wsxchnl.h.
- *! 09-Sep-1996 gp: Added hReserved2 field to CHNL_ATTRS. Updated CHNL_INFO.
- *! 10-Jul-1996 gp: Created from channel.h.
- */
-
 #ifndef CHNLDEFS_
 #define CHNLDEFS_
 
@@ -45,48 +23,45 @@
 #define CHNL_PICKFREE       (~0UL)	/* Let manager pick a free channel. */
 
 /* Channel manager limits: */
-#define CHNL_INITIOREQS      4	/* Default # of I/O requests.       */
+#define CHNL_INITIOREQS      4	/* Default # of I/O requests. */
 
 /* Channel modes */
-#define CHNL_MODETODSP       0x0000	/* Data streaming to the DSP.      */
-#define CHNL_MODEFROMDSP     0x0001	/* Data streaming from the DSP.    */
+#define CHNL_MODETODSP       0x0000	/* Data streaming to the DSP. */
+#define CHNL_MODEFROMDSP     0x0001	/* Data streaming from the DSP. */
 
 /* GetIOCompletion flags */
 #define CHNL_IOCINFINITE     0xffffffff	/* Wait forever for IO completion. */
-#define CHNL_IOCNOWAIT       0x0	/* Dequeue an IOC, if available.   */
+#define CHNL_IOCNOWAIT       0x0	/* Dequeue an IOC, if available. */
 
 /* IO Completion Record status: */
-#define CHNL_IOCSTATCOMPLETE 0x0000	/* IO Completed.             */
-#define CHNL_IOCSTATCANCEL   0x0002	/* IO was cancelled          */
-#define CHNL_IOCSTATTIMEOUT  0x0008	/* Wait for IOC timed out.   */
-#define CHNL_IOCSTATEOS      0x8000	/* End Of Stream reached.    */
+#define CHNL_IOCSTATCOMPLETE 0x0000	/* IO Completed. */
+#define CHNL_IOCSTATCANCEL   0x0002	/* IO was cancelled */
+#define CHNL_IOCSTATTIMEOUT  0x0008	/* Wait for IOC timed out. */
+#define CHNL_IOCSTATEOS      0x8000	/* End Of Stream reached. */
 
 /* Macros for checking I/O Completion status: */
-#define CHNL_IsEOS(ioc)         (ioc.status & CHNL_IOCSTATEOS)
-#define CHNL_IsIOComplete(ioc)  (!(ioc.status & ~CHNL_IOCSTATEOS))
-#define CHNL_IsIOCancelled(ioc) (ioc.status & CHNL_IOCSTATCANCEL)
-#define CHNL_IsTimedOut(ioc)    (ioc.status & CHNL_IOCSTATTIMEOUT)
-
-/* CHNL types: */
-	typedef u32 CHNL_MODE;	/* Channel transfer mode.         */
+#define CHNL_IS_EOS(ioc)         (ioc.status & CHNL_IOCSTATEOS)
+#define CHNL_IS_IO_COMPLETE(ioc)  (!(ioc.status & ~CHNL_IOCSTATEOS))
+#define CHNL_IS_IO_CANCELLED(ioc) (ioc.status & CHNL_IOCSTATCANCEL)
+#define CHNL_IS_TIMED_OUT(ioc)    (ioc.status & CHNL_IOCSTATTIMEOUT)
 
 /* Channel attributes: */
-	struct CHNL_ATTRS {
-		u32 uIOReqs;	/* Max # of preallocated I/O requests.    */
-		HANDLE hEvent;	/* User supplied auto-reset event object. */
-		char *pstrEventName;	/* Ptr to name of user event object.  */
-		HANDLE hReserved1;	/* Reserved for future use.         */
-		u32 hReserved2;	/* Reserved for future use.        */
+struct chnl_attr {
+	u32 uio_reqs;		/* Max # of preallocated I/O requests. */
+	bhandle event_obj;	/* User supplied auto-reset event object. */
+	char *pstr_event_name;	/* Ptr to name of user event object. */
+	bhandle reserved1;	/* Reserved for future use. */
+	u32 reserved2;		/* Reserved for future use. */
 
-	};
+};
 
 /* I/O completion record: */
-	struct CHNL_IOC {
-		void *pBuf;	/* Buffer to be filled/emptied.           */
-		u32 cBytes;	/* Bytes transferred.                     */
-		u32 cBufSize;	/* Actual buffer size in bytes            */
-		u32 status;	/* Status of IO completion.               */
-		u32 dwArg;	/* User argument associated with pBuf.    */
-	} ;
+struct chnl_ioc {
+	void *pbuf;		/* Buffer to be filled/emptied. */
+	u32 byte_size;		/* Bytes transferred. */
+	u32 buf_size;		/* Actual buffer size in bytes */
+	u32 status;		/* Status of IO completion. */
+	u32 dw_arg;		/* User argument associated with pbuf. */
+};
 
-#endif				/* CHNLDEFS_ */
+#endif /* CHNLDEFS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/chnl.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/chnl.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/chnl.h	2011-10-11 13:50:57.729545532 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/chnl.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,11 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * WCD channel interface: multiplexes data streams through the single
+ * physical link managed by a mini-driver.
+ *
+ * See DSP API chnl.h for more details.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,146 +19,104 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== chnl.h ========
- *  Description:
- *      WCD channel interface: multiplexes data streams through the single
- *      physical link managed by a mini-driver.
- *
- *  Public Functions:
- *      CHNL_AddIOReq
- *      CHNL_AllocBuffer
- *      CHNL_CancelIO
- *      CHNL_Close
- *      CHNL_CloseOrphans
- *      CHNL_Create
- *      CHNL_Destroy
- *      CHNL_Exit
- *      CHNL_FlushIO
- *      CHNL_FreeBuffer
- *      CHNL_GetEventHandle
- *      CHNL_GetHandle
- *      CHNL_GetIOCompletion
- *      CHNL_GetId
- *      CHNL_GetMgr
- *      CHNL_GetMode
- *      CHNL_GetPosition
- *      CHNL_GetProcessHandle
- *      CHNL_Init
- *      CHNL_Open
- *
- *  Notes:
- *      See DSP API chnl.h for more details.
- *
- *! Revision History:
- *! ================
- *! 14-Jan-1997 gp: Updated based on code review feedback.
- *! 24-Oct-1996 gp: Move CloseOrphans into here from dspsys.
- *! 09-Sep-1996 gp: Added CHNL_GetProcessID() and CHNL_GetHandle().
- *! 10-Jul-1996 gp: Created.
- */
-
 #ifndef CHNL_
 #define CHNL_
 
 #include <dspbridge/chnlpriv.h>
 
 /*
- *  ======== CHNL_Close ========
+ *  ======== chnl_close ========
  *  Purpose:
  *      Ensures all pending I/O on this channel is cancelled, discards all
  *      queued I/O completion notifications, then frees the resources allocated
  *      for this channel, and makes the corresponding logical channel id
  *      available for subsequent use.
  *  Parameters:
- *      hChnl:          Channel object handle.
+ *      chnl_obj:          Channel object handle.
  *  Returns:
  *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EHANDLE:    Invalid chnl_obj.
  *  Requires:
- *      CHNL_Init(void) called.
+ *      chnl_init(void) called.
  *      No thread must be blocked on this channel's I/O completion event.
  *  Ensures:
  *      DSP_SOK:        The I/O completion event for this channel is freed.
- *                      hChnl is no longer valid.
+ *                      chnl_obj is no longer valid.
  */
-	extern DSP_STATUS CHNL_Close(struct CHNL_OBJECT *hChnl);
-
+extern dsp_status chnl_close(struct chnl_object *chnl_obj);
 
 /*
- *  ======== CHNL_Create ========
+ *  ======== chnl_create ========
  *  Purpose:
  *      Create a channel manager object, responsible for opening new channels
  *      and closing old ones for a given board.
  *  Parameters:
  *      phChnlMgr:      Location to store a channel manager object on output.
- *      hDevObject:     Handle to a device object.
+ *      hdev_obj:     Handle to a device object.
  *      pMgrAttrs:      Channel manager attributes.
- *      pMgrAttrs->cChannels:   Max channels
- *      pMgrAttrs->bIRQ:        Channel's I/O IRQ number.
- *      pMgrAttrs->fShared:     TRUE if the IRQ is shareable.
- *      pMgrAttrs->uWordSize:   DSP Word size in equivalent PC bytes..
+ *      pMgrAttrs->max_channels:   Max channels
+ *      pMgrAttrs->birq:        Channel's I/O IRQ number.
+ *      pMgrAttrs->irq_shared:     TRUE if the IRQ is shareable.
+ *      pMgrAttrs->word_size:   DSP Word size in equivalent PC bytes..
  *  Returns:
  *      DSP_SOK:                Success;
- *      DSP_EHANDLE:            hDevObject is invalid.
- *      DSP_EINVALIDARG:        cChannels is 0.
+ *      DSP_EHANDLE:            hdev_obj is invalid.
+ *      DSP_EINVALIDARG:        max_channels is 0.
  *      DSP_EMEMORY:            Insufficient memory for requested resources.
  *      CHNL_E_ISR:             Unable to plug channel ISR for configured IRQ.
  *      CHNL_E_MAXCHANNELS:     This manager cannot handle this many channels.
- *      CHNL_E_INVALIDIRQ:      Invalid IRQ number. Must be 0 <= bIRQ <= 15.
+ *      CHNL_E_INVALIDIRQ:      Invalid IRQ number. Must be 0 <= birq <= 15.
  *      CHNL_E_INVALIDWORDSIZE: Invalid DSP word size.  Must be > 0.
  *      CHNL_E_INVALIDMEMBASE:  Invalid base address for DSP communications.
  *      CHNL_E_MGREXISTS:       Channel manager already exists for this device.
  *  Requires:
- *      CHNL_Init(void) called.
+ *      chnl_init(void) called.
  *      phChnlMgr != NULL.
  *      pMgrAttrs != NULL.
  *  Ensures:
- *      DSP_SOK:                Subsequent calls to CHNL_Create() for the same
+ *      DSP_SOK:                Subsequent calls to chnl_create() for the same
  *                              board without an intervening call to
- *                              CHNL_Destroy() will fail.
+ *                              chnl_destroy() will fail.
  */
-	extern DSP_STATUS CHNL_Create(OUT struct CHNL_MGR **phChnlMgr,
-				      struct DEV_OBJECT *hDevObject,
-				      IN CONST struct CHNL_MGRATTRS *pMgrAttrs);
+extern dsp_status chnl_create(OUT struct chnl_mgr **phChnlMgr,
+			      struct dev_object *hdev_obj,
+			      IN CONST struct chnl_mgrattrs *pMgrAttrs);
 
 /*
- *  ======== CHNL_Destroy ========
+ *  ======== chnl_destroy ========
  *  Purpose:
  *      Close all open channels, and destroy the channel manager.
  *  Parameters:
- *      hChnlMgr:           Channel manager object.
+ *      hchnl_mgr:           Channel manager object.
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        hChnlMgr was invalid.
+ *      DSP_EHANDLE:        hchnl_mgr was invalid.
  *  Requires:
- *      CHNL_Init(void) called.
+ *      chnl_init(void) called.
  *  Ensures:
  *      DSP_SOK:            Cancels I/O on each open channel.
  *                          Closes each open channel.
- *                          CHNL_Create may subsequently be called for the
+ *                          chnl_create may subsequently be called for the
  *                          same board.
  */
-	extern DSP_STATUS CHNL_Destroy(struct CHNL_MGR *hChnlMgr);
+extern dsp_status chnl_destroy(struct chnl_mgr *hchnl_mgr);
 
 /*
- *  ======== CHNL_Exit ========
+ *  ======== chnl_exit ========
  *  Purpose:
  *      Discontinue usage of the CHNL module.
  *  Parameters:
  *  Returns:
  *  Requires:
- *      CHNL_Init(void) previously called.
+ *      chnl_init(void) previously called.
  *  Ensures:
- *      Resources, if any acquired in CHNL_Init(void), are freed when the last
- *      client of CHNL calls CHNL_Exit(void).
+ *      Resources, if any acquired in chnl_init(void), are freed when the last
+ *      client of CHNL calls chnl_exit(void).
  */
-	extern void CHNL_Exit(void);
-
+extern void chnl_exit(void);
 
 /*
- *  ======== CHNL_Init ========
+ *  ======== chnl_init ========
  *  Purpose:
  *      Initialize the CHNL module's private state.
  *  Parameters:
@@ -163,8 +126,6 @@
  *  Ensures:
  *      A requirement for each of the other public CHNL functions.
  */
-	extern bool CHNL_Init(void);
-
-
+extern bool chnl_init(void);
 
-#endif				/* CHNL_ */
+#endif /* CHNL_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/chnlpriv.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/chnlpriv.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/chnlpriv.h	2011-10-11 13:50:57.734440461 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/chnlpriv.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Private channel header shared between DSPSYS, WCD and WMD modules.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,35 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== chnlpriv.h ========
- *  Description:
- *      Private channel header shared between DSPSYS, WCD and WMD modules.
- *
- *  Public Functions:
- *      None.
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 05-Jan-2002 ag  Added cChannels(total # of chnls) to CHNL_MGRINFO struct.
- *!                 Added private CHNL_[PCPY][ZCPY][DDMA].
- *! 17-Nov-2000 jeh Removed IRQ, shared memory from CHNL_MGRATTRS, since these
- *!                 now belong to IO_ATTRS.
- *! 21-Jan-2000 ag: Code review comments added.
- *! 05-Jan-2000 ag: Text format cleanup.
- *! 11-Dec-1999 ag: Added CHNL_MAXLOCKPAGES for CHNL_PrepareBuffer().
- *! 04-Dec-1999 ag: Added CHNL_MAXEVTNAMELEN for i/o compl named event support.
- *! 01-Nov-1999 ag: CHNL_MAXCHANNELS set to 16 for 16-bit DSPs.
- *! 27-Oct-1997 cr: Expanded CHNL_MAXIRQ from 0x0f to 0xff.
- *! 16-Jan-1997 gp: Moved symbols into here from chnldefs.h.
- *! 03-Jan-1997 gp: Added CHNL_MAXIRQ define.
- *! 09-Dec-1996 gp: Removed CHNL_STATEIDLE.
- *! 15-Jul-1996 gp: Created.
- */
-
 #ifndef CHNLPRIV_
 #define CHNLPRIV_
 
@@ -57,7 +30,6 @@
 /* Channel manager limits: */
 #define CHNL_MAXCHANNELS    32	/* Max channels available per transport */
 
-
 /*
  *  Trans port channel Id definitions:(must match dsp-side).
  *
@@ -77,16 +49,16 @@
 #define CHNL_MODEMASK       0x1001
 
 /* Higher level channel states: */
-#define CHNL_STATEREADY     0x0000	/* Channel ready for I/O.    */
-#define CHNL_STATECANCEL    0x0001	/* I/O was cancelled.        */
-#define CHNL_STATEEOS       0x0002	/* End Of Stream reached.    */
+#define CHNL_STATEREADY     0x0000	/* Channel ready for I/O. */
+#define CHNL_STATECANCEL    0x0001	/* I/O was cancelled. */
+#define CHNL_STATEEOS       0x0002	/* End Of Stream reached. */
 
-/* Determine if user supplied an event for this channel:  */
-#define CHNL_IsUserEvent(mode)  (mode & CHNL_MODEUSEREVENT)
+/* Determine if user supplied an event for this channel: */
+#define CHNL_IS_USER_EVENT(mode)  (mode & CHNL_MODEUSEREVENT)
 
 /* Macros for checking mode: */
-#define CHNL_IsInput(mode)      (mode & CHNL_MODEFROMDSP)
-#define CHNL_IsOutput(mode)     (!CHNL_IsInput(mode))
+#define CHNL_IS_INPUT(mode)      (mode & CHNL_MODEFROMDSP)
+#define CHNL_IS_OUTPUT(mode)     (!CHNL_IS_INPUT(mode))
 
 /* Types of channel class libraries: */
 #define CHNL_TYPESM         1	/* Shared memory driver. */
@@ -98,39 +70,39 @@
 /* Max memory pages lockable in CHNL_PrepareBuffer() - change if needed */
 #define CHNL_MAXLOCKPAGES   64
 
-/* Channel info.  */
-	 struct CHNL_INFO {
-		struct CHNL_MGR *hChnlMgr;	/* Owning channel manager.   */
-		u32 dwID;	/* Channel ID.                            */
-		HANDLE hEvent;	/* Channel I/O completion event.          */
-		/*Abstraction of I/O completion event.*/
-		struct SYNC_OBJECT *hSyncEvent;
-		u32 dwMode;	/* Channel mode.                          */
-		u32 dwState;	/* Current channel state.                 */
-		u32 cPosition;	/* Total bytes transferred.        */
-		u32 cIOCs;	/* Number of IOCs in queue.               */
-		u32 cIOReqs;	/* Number of IO Requests in queue.        */
-               u32 hProcess;   /* Process owning this channel.     */
-		/*
-		 * Name of channel I/O completion event. Not required in Linux
-		 */
-		char szEventName[CHNL_MAXEVTNAMELEN + 1];
-	} ;
+/* Channel info. */
+struct chnl_info {
+	struct chnl_mgr *hchnl_mgr;	/* Owning channel manager. */
+	u32 cnhl_id;		/* Channel ID. */
+	bhandle event_obj;	/* Channel I/O completion event. */
+	/*Abstraction of I/O completion event. */
+	struct sync_object *sync_event;
+	u32 dw_mode;		/* Channel mode. */
+	u32 dw_state;		/* Current channel state. */
+	u32 bytes_tx;		/* Total bytes transferred. */
+	u32 cio_cs;		/* Number of IOCs in queue. */
+	u32 cio_reqs;		/* Number of IO Requests in queue. */
+	u32 process;		/* Process owning this channel. */
+	/*
+	 * Name of channel I/O completion event. Not required in Linux
+	 */
+	char sz_event_name[CHNL_MAXEVTNAMELEN + 1];
+};
 
 /* Channel manager info: */
-	struct CHNL_MGRINFO {
-		u32 dwType;	/* Type of channel class library.         */
-		/* Channel handle, given the channel id. */
-		struct CHNL_OBJECT *hChnl;
-		u32 cOpenChannels;	/* Number of open channels.     */
-		u32 cChannels;	/* total # of chnls supported */
-	} ;
+struct chnl_mgrinfo {
+	u32 dw_type;		/* Type of channel class library. */
+	/* Channel handle, given the channel id. */
+	struct chnl_object *chnl_obj;
+	u32 open_channels;	/* Number of open channels. */
+	u32 max_channels;	/* total # of chnls supported */
+};
 
 /* Channel Manager Attrs: */
-	struct CHNL_MGRATTRS {
-		/* Max number of channels this manager can use. */
-		u32 cChannels;
-		u32 uWordSize;	/* DSP Word size.                       */
-	} ;
+struct chnl_mgrattrs {
+	/* Max number of channels this manager can use. */
+	u32 max_channels;
+	u32 word_size;		/* DSP Word size. */
+};
 
-#endif				/* CHNLPRIV_ */
+#endif /* CHNLPRIV_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h	2011-10-11 13:50:57.756107040 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,12 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Private header file defining channel manager and channel objects for
+ * a shared memory channel driver.
+ *
+ * Shared between the modules implementing the shared memory channel class
+ * library.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,50 +20,11 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _chnl_sm.h ========
- *  Description:
- *      Private header file defining channel manager and channel objects for
- *      a shared memory channel driver.
- *
- *  Public Functions:
- *      None.
- *
- *  Notes:
- *      Shared between the modules implementing the shared memory channel class
- *      library.
- *
- *! Revision History:
- *! ================
- *! 15-Oct-2002 kc  Removed legacy PERF code.
- *! 12-Jan-2002 ag  Removed unused gppReqIO & ddmaChnlId DDMA fields.
- *!                 Added zero-copy chnl descriptor array: zchnldesc.
- *! 21-Dec-2001 ag  Moved descPaGpp to private chnl obj from chnl descriptor.
- *! 20-May-2001 ag/jeh Removed fShmSyms field from CHNL_MGR.
- *! 04-Feb-2001 ag  DSP-DMA support added.
- *! 26-Oct-2000 jeh Added arg and resvd to SHM control structure. Added dwArg
- *!                 to CHNL_IRP.
- *! 16-Oct-2000 jeh Removed #ifdef DEBUG from around channel object's cIOCs
- *!                 field, added cIOReqs.
- *! 20-Jan-2000 ag: Incorporated code review comments.
- *! 05-Jan-2000 ag: Text format cleanup.
- *! 03-Nov-1999 ag: Added szEventName[] to CHNL object for name event support.
- *! 02-Nov-1999 ag: _SHM_BEG & _END Syms from COFF now used for IO and SM CLASS.
- *! 27-Oct-1999 jeh Define SHM structure to work for 16-bit targets.
- *! 25-May-1999 jg: Added target side symbol names for share memory buffer
- *! 03-Jan-1997 gp: Added fSharedIRQ field.
- *! 22-Oct-1996 gp: Made dwProcessID a handle.
- *! 09-Sep-1996 gp: Added dwProcessID field to CHNL_OBJECT.
- *! 13-Aug-1996 gp: Created.
- */
-
 #ifndef _CHNL_SM_
 #define _CHNL_SM_
 
 #include <dspbridge/wcd.h>
 #include <dspbridge/wmd.h>
-#include <dspbridge/dpc.h>
 
 #include <dspbridge/list.h>
 #include <dspbridge/ntfy.h>
@@ -78,135 +45,141 @@
 
 #define MAXOPPS 16
 
-struct oppTableEntry {
-    u32 voltage;
-    u32 frequency;
-    u32 minFreq;
-    u32 maxFreq;
-} ;
-
-struct oppStruct {
-    u32 currOppPt;
-    u32 numOppPts;
-    struct oppTableEntry oppPoint[MAXOPPS];
-} ;
+/* Shared memory config options */
+#define SHM_CURROPP	0	/* Set current OPP in shm */
+#define SHM_OPPINFO	1	/* Set dsp voltage and freq table values */
+#define SHM_GETOPP	2	/* Get opp requested by DSP */
+
+struct opp_table_entry {
+	u32 voltage;
+	u32 frequency;
+	u32 min_freq;
+	u32 max_freq;
+};
+
+struct opp_struct {
+	u32 curr_opp_pt;
+	u32 num_opp_pts;
+	struct opp_table_entry opp_point[MAXOPPS];
+};
 
 /* Request to MPU */
-struct oppRqstStruct {
-    u32 rqstDspFreq;
-    u32 rqstOppPt;
+struct opp_rqst_struct {
+	u32 rqst_dsp_freq;
+	u32 rqst_opp_pt;
 };
 
 /* Info to MPU */
-struct loadMonStruct {
-    u32 currDspLoad;
-    u32 currDspFreq;
-    u32 predDspLoad;
-    u32 predDspFreq;
-};
-
-	enum SHM_DESCTYPE {
-		SHM_CURROPP = 0,
-		SHM_OPPINFO = 1,
-		SHM_GETOPP = 2,		/* Get DSP requested OPP info */
-	} ;
-
-/* Structure in shared between DSP and PC for communication.*/
-	struct SHM {
-		u32 dspFreeMask;	/* Written by DSP, read by PC. */
-		u32 hostFreeMask;	/* Written by PC, read by DSP */
-
-		u32 inputFull;	/* Input channel has unread data. */
-		u32 inputId;	/* Channel for which input is available. */
-		u32 inputSize;	/* Size of data block (in DSP words). */
-
-		u32 outputFull;	/* Output channel has unread data. */
-		u32 outputId;	/* Channel for which output is available. */
-		u32 outputSize;	/* Size of data block (in DSP words). */
-
-		u32 arg;	/* Arg for Issue/Reclaim (23 bits for 55x). */
-		u32 resvd;	/* Keep structure size even for 32-bit DSPs */
-
-		/* Operating Point structure */
-		struct oppStruct  oppTableStruct;
-		/* Operating Point Request structure */
-		struct oppRqstStruct oppRequest;
-		/* load monitor information structure*/
-		struct loadMonStruct loadMonInfo;
-		char dummy[184];             /* padding to 256 byte boundary */
-		u32 shm_dbg_var[64];         /* shared memory debug variables */
-	} ;
+struct load_mon_struct {
+	u32 curr_dsp_load;
+	u32 curr_dsp_freq;
+	u32 pred_dsp_load;
+	u32 pred_dsp_freq;
+};
+
+/* Structure in shared between DSP and PC for communication. */
+struct shm {
+	u32 dsp_free_mask;	/* Written by DSP, read by PC. */
+	u32 host_free_mask;	/* Written by PC, read by DSP */
+
+	u32 input_full;		/* Input channel has unread data. */
+	u32 input_id;		/* Channel for which input is available. */
+	u32 input_size;		/* Size of data block (in DSP words). */
+
+	u32 output_full;	/* Output channel has unread data. */
+	u32 output_id;		/* Channel for which output is available. */
+	u32 output_size;	/* Size of data block (in DSP words). */
+
+	u32 arg;		/* Arg for Issue/Reclaim (23 bits for 55x). */
+	u32 resvd;		/* Keep structure size even for 32-bit DSPs */
+
+	/* Operating Point structure */
+	struct opp_struct opp_table_struct;
+	/* Operating Point Request structure */
+	struct opp_rqst_struct opp_request;
+	/* load monitor information structure */
+	struct load_mon_struct load_mon_info;
+#ifdef CONFIG_BRIDGE_WDT3
+	/* Flag for WDT enable/disable F/I clocks */
+	u32 wdt_setclocks;
+	u32 wdt_overflow;	/* WDT overflow time */
+	char dummy[176];	/* padding to 256 byte boundary */
+#else
+	char dummy[184];	/* padding to 256 byte boundary */
+#endif
+	u32 shm_dbg_var[64];	/* shared memory debug variables */
+};
 
 	/* Channel Manager: only one created per board: */
-	struct CHNL_MGR {
-		u32 dwSignature;	/* Used for object validation */
-		/* Function interface to WMD */
-		struct WMD_DRV_INTERFACE *pIntfFxns;
-		struct IO_MGR *hIOMgr;	/* IO manager */
-		/* Device this board represents */
-		struct DEV_OBJECT *hDevObject;
-
-		/* These fields initialized in WMD_CHNL_Create():    */
-		u32 dwOutputMask; /* Host output channels w/ full buffers */
-		u32 dwLastOutput;	/* Last output channel fired from DPC */
-		/* Critical section object handle */
-		struct SYNC_CSOBJECT *hCSObj;
-		u32 uWordSize;	/* Size in bytes of DSP word */
-		u32 cChannels;	/* Total number of channels */
-		u32 cOpenChannels;	/* Total number of open channels */
-		struct CHNL_OBJECT **apChannel;	/* Array of channels */
-		u32 dwType;	/* Type of channel class library */
-		/* If no SHM syms, return for CHNL_Open */
-		DSP_STATUS chnlOpenStatus;
-	} ;
+struct chnl_mgr {
+	u32 dw_signature;	/* Used for object validation */
+	/* Function interface to WMD */
+	struct bridge_drv_interface *intf_fxns;
+	struct io_mgr *hio_mgr;	/* IO manager */
+	/* Device this board represents */
+	struct dev_object *hdev_obj;
+
+	/* These fields initialized in bridge_chnl_create(): */
+	u32 dw_output_mask;	/* Host output channels w/ full buffers */
+	u32 dw_last_output;	/* Last output channel fired from DPC */
+	/* Critical section object handle */
+	struct sync_csobject *hcs_obj;
+	u32 word_size;		/* Size in bytes of DSP word */
+	u32 max_channels;	/* Total number of channels */
+	u32 open_channels;	/* Total number of open channels */
+	struct chnl_object **ap_channel;	/* Array of channels */
+	u32 dw_type;		/* Type of channel class library */
+	/* If no shm syms, return for CHNL_Open */
+	dsp_status chnl_open_status;
+};
 
 /*
  *  Channel: up to CHNL_MAXCHANNELS per board or if DSP-DMA supported then
  *     up to CHNL_MAXCHANNELS + CHNL_MAXDDMACHNLS per board.
  */
-	struct CHNL_OBJECT {
-		u32 dwSignature;	/* Used for object validation */
-		/* Pointer back to channel manager */
-		struct CHNL_MGR *pChnlMgr;
-		u32 uId;	/* Channel id */
-		u32 dwState;	/* Current channel state */
-		u32 uMode;	/* Chnl mode and attributes */
-		/* Chnl I/O completion event (user mode) */
-		HANDLE hUserEvent;
-		/* Abstract syncronization object */
-		struct SYNC_OBJECT *hSyncEvent;
-		/* Name of Sync event */
-		char szEventName[SYNC_MAXNAMELENGTH + 1];
-               u32 hProcess;   /* Process which created this channel */
-		u32 pCBArg;	/* Argument to use with callback */
-		struct LST_LIST *pIORequests;	/* List of IOR's to driver */
-		s32 cIOCs;	/* Number of IOC's in queue */
-		s32 cIOReqs;	/* Number of IORequests in queue */
-		s32 cChirps;	/* Initial number of free Irps */
-		/* List of IOC's from driver */
-		struct LST_LIST *pIOCompletions;
-		struct LST_LIST *pFreeList;	/* List of free Irps */
-		struct NTFY_OBJECT *hNtfy;
-		u32 cBytesMoved;	/* Total number of bytes transfered */
-
-		/* For DSP-DMA */
-
-		/* Type of chnl transport:CHNL_[PCPY][DDMA] */
-		u32 uChnlType;
-	} ;
+struct chnl_object {
+	u32 dw_signature;	/* Used for object validation */
+	/* Pointer back to channel manager */
+	struct chnl_mgr *chnl_mgr_obj;
+	u32 chnl_id;		/* Channel id */
+	u32 dw_state;		/* Current channel state */
+	u32 chnl_mode;		/* Chnl mode and attributes */
+	/* Chnl I/O completion event (user mode) */
+	bhandle user_event;
+	/* Abstract syncronization object */
+	struct sync_object *sync_event;
+	/* Name of Sync event */
+	char sz_event_name[SYNC_MAXNAMELENGTH + 1];
+	u32 process;		/* Process which created this channel */
+	u32 pcb_arg;		/* Argument to use with callback */
+	struct lst_list *pio_requests;	/* List of IOR's to driver */
+	s32 cio_cs;		/* Number of IOC's in queue */
+	s32 cio_reqs;		/* Number of IORequests in queue */
+	s32 chnl_packets;	/* Initial number of free Irps */
+	/* List of IOC's from driver */
+	struct lst_list *pio_completions;
+	struct lst_list *free_packets_list;	/* List of free Irps */
+	struct ntfy_object *ntfy_obj;
+	u32 bytes_moved;	/* Total number of bytes transfered */
+
+	/* For DSP-DMA */
+
+	/* Type of chnl transport:CHNL_[PCPY][DDMA] */
+	u32 chnl_type;
+};
 
 /* I/O Request/completion packet: */
-	struct CHNL_IRP {
-		struct LST_ELEM link;	/* Link to next CHIRP in queue. */
-		/* Buffer to be filled/emptied. (User)   */
-		u8 *pHostUserBuf;
-		/* Buffer to be filled/emptied. (System) */
-		u8 *pHostSysBuf;
-		u32 dwArg;	/* Issue/Reclaim argument.               */
-		u32 uDspAddr;	/* Transfer address on DSP side.         */
-		u32 cBytes;	/* Bytes transferred.                    */
-		u32 cBufSize;	/* Actual buffer size when allocated.    */
-		u32 status;	/* Status of IO completion.              */
-	} ;
+struct chnl_irp {
+	struct list_head link;	/* Link to next CHIRP in queue. */
+	/* Buffer to be filled/emptied. (User) */
+	u8 *host_user_buf;
+	/* Buffer to be filled/emptied. (System) */
+	u8 *host_sys_buf;
+	u32 dw_arg;		/* Issue/Reclaim argument. */
+	u32 dsp_tx_addr;	/* Transfer address on DSP side. */
+	u32 byte_size;		/* Bytes transferred. */
+	u32 buf_size;		/* Actual buffer size when allocated. */
+	u32 status;		/* Status of IO completion. */
+};
 
-#endif				/* _CHNL_SM_ */
+#endif /* _CHNL_SM_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/chnl_sm.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/chnl_sm.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/chnl_sm.h	2011-10-11 13:50:57.743213909 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/chnl_sm.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,168 +0,0 @@
-/*
- * chnl_sm.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== chnl_sm.h ========
- *  Description:
- *      Prototypes for channel lower edge functions for a WinBRIDGE mini driver
- *      implementing data transfer via shared memory.
- *
- *  Public Functions:
- *      CHNLSM_DisableInterrupt;
- *      CHNLSM_EnableInterrupt;
- *      CHNLSM_ISR;
- *      CHNLSM_Read;
- *      CHNLSM_UpdateSHMLength;
- *      CHNLSM_Write;
- *
- *  Notes:
- *      These lower edge functions must be implemented by the WMD writer.
- *      Currently, CHNLSM_Read() and CHNLSM_Write() are not called, but must
- *      be defined to link.
- *
- */
-
-#ifndef CHNLSM_
-#define CHNLSM_
-
-#include <dspbridge/wmd.h>
-
-/*
- *  ======== CHNLSM_DisableInterrupt ========
- *  Purpose:
- *      Disable interrupts from the DSP board to the PC.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *  Returns:
- *  Requires:
- *  Ensures:
- */
-       extern DSP_STATUS CHNLSM_DisableInterrupt(struct WMD_DEV_CONTEXT*
-							hDevContext);
-
-/*
- *  ======== CHNLSM_EnableInterrupt ========
- *  Purpose:
- *      Enable interrupts from the DSP board to the PC.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *  Returns:
- *  Requires:
- *  Ensures:
- */
-       extern DSP_STATUS CHNLSM_EnableInterrupt(struct WMD_DEV_CONTEXT*
-						       hDevContext);
-
-/*
- *  ======== CHNLSM_InterruptDSP2 ========
- *  Purpose:
- *      Set interrupt value & send an interrupt to the DSP processor(s).
- *      This is typicaly used when mailbox interrupt mechanisms allow data
- *      to be associated with interrupt such as for OMAP's CMD/DATA regs.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      wMbVal:         Value associated with interrupt(e.g. mailbox value).
- *  Returns:
- *      DSP_SOK:        Interrupt sent;
- *      else:           Unable to send interrupt.
- *  Requires:
- *  Ensures:
- */
-       extern DSP_STATUS CHNLSM_InterruptDSP2(struct WMD_DEV_CONTEXT*
-						     hDevContext, u16 wMbVal);
-
-/*
- *  ======== CHNLSM_ISR ========
- *  Purpose:
- *      Mini-driver's ISR, called by WCD when the board interrupts the host.
- *  Parameters:
- *      hDevContext:    Handle to the mini-driver defined device info.
- *      pfSchedDPC:     Set to TRUE to schedule a deferred procedure call
- *                      to advance the channel protocol.  The channel class
- *                      library will call the WMD's CHNLSM_DPC routine during
- *                      its own DPC, before dispatching I/O.
- *                      The channel class library should ignore *pfSchedDPC when
- *                      CHNLSM_ISR returns FALSE.
- *      pwMBRegVal:     Value of mailbox register.
- *  Returns:
- *      TRUE if this interrupt is was generated by the DSP board.
- *      FALSE otherwise.
- *  Requires:
- *      Interrupts to the host processor are disabled on entry.
- *      Must only call functions which are in page locked memory.
- *      Must only call asynchronous OS services.
- *      The EOI for this interrupt has already been sent to the PIC.
- *  Ensures:
- *      If the interrupt is *not* shared, this routine must return TRUE.
- */
-       extern bool CHNLSM_ISR(struct WMD_DEV_CONTEXT *hDevContext,
-				     OUT bool *pfSchedDPC,
-				     OUT u16 *pwIntrVal);
-
-/*
- *  ======== CHNLSM_Read ========
- *  Purpose:
- *      Read data from DSP board memory into a Host buffer.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      pHostBuf:       Pointer to host buffer (Destination).
- *      dwDSPAddr:      Address on DSP board (Source).
- *      ulNumBytes:     Number of bytes to transfer.
- *  Returns:
- *  Requires:
- *  Ensures:
- */
-       extern DSP_STATUS CHNLSM_Read(struct WMD_DEV_CONTEXT *hDevContext,
-					    OUT u8 *pHostBuf,
-					    u32 dwDSPAddr, u32 ulNumBytes);
-
-/*
- *  ======== CHNLSM_UpdateSHMLength ========
- *  Purpose:
- *      Allow the minidriver a chance to override the SHM length as reported
- *      to the mini driver (chnl_sm.lib) by Windows Plug and Play.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      pSHMLength:     Pointer to size of SHM window (in DSP words).
- *  Returns:
- *      TRUE if pSHMLength updated; FALSE otherwise.
- *  Requires:
- *      pSHMLength != NULL.
- *  Ensures:
- *      No more than sizeof(u32) bytes written to *pSHMLength
- */
-	extern bool CHNLSM_UpdateSHMLength(struct WMD_DEV_CONTEXT *hDevContext,
-					   IN OUT u32 *pSHMLength);
-
-/*
- *  ======== CHNLSM_Write ========
- *  Purpose:
- *      Write data from a Host buffer to DSP board memory.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      pHostBuf:       Pointer to host buffer (Source).
- *      dwDSPAddr:      Address on DSP board (Destination).
- *      ulNumBytes:     Number of bytes to transfer.
- *  Returns:
- *  Requires:
- *  Ensures:
- */
-       extern DSP_STATUS CHNLSM_Write(struct WMD_DEV_CONTEXT *hDevContext,
-					    IN u8 *pHostBuf,
-					    u32 dwDSPAddr, u32 ulNumBytes);
-
-#endif				/* CHNLSM_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/clk.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/clk.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/clk.h	2011-10-11 13:50:57.432894958 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/clk.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provides Clock functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,52 +16,42 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== clk.h ========
- *  Purpose: Provides Clock functions.
- *
- *! Revision History:
- *! ================
- *! 08-May-2007 rg: Moved all clock functions from sync module.
- */
-
 #ifndef _CLK_H
 #define _CLK_H
 
 	/* Generic TIMER object: */
-	struct TIMER_OBJECT;
-	enum SERVICES_ClkId {
-		SERVICESCLK_iva2_ck = 0,
-		SERVICESCLK_mailbox_ick,
-		SERVICESCLK_gpt5_fck,
-		SERVICESCLK_gpt5_ick,
-		SERVICESCLK_gpt6_fck,
-		SERVICESCLK_gpt6_ick,
-		SERVICESCLK_gpt7_fck,
-		SERVICESCLK_gpt7_ick,
-		SERVICESCLK_gpt8_fck,
-		SERVICESCLK_gpt8_ick,
-		SERVICESCLK_wdt3_fck,
-		SERVICESCLK_wdt3_ick,
-		SERVICESCLK_mcbsp1_fck,
-		SERVICESCLK_mcbsp1_ick,
-		SERVICESCLK_mcbsp2_fck,
-		SERVICESCLK_mcbsp2_ick,
-		SERVICESCLK_mcbsp3_fck,
-		SERVICESCLK_mcbsp3_ick,
-		SERVICESCLK_mcbsp4_fck,
-		SERVICESCLK_mcbsp4_ick,
-		SERVICESCLK_mcbsp5_fck,
-		SERVICESCLK_mcbsp5_ick,
-		SERVICESCLK_ssi_fck,
-		SERVICESCLK_ssi_ick,
-		SERVICESCLK_sys_32k_ck,
-		SERVICESCLK_sys_ck,
-		SERVICESCLK_NOT_DEFINED
-	} ;
+struct timer_object;
+enum services_clk_id {
+	SERVICESCLK_IVA2_CK = 0,
+	SERVICESCLK_GPT5_FCK,
+	SERVICESCLK_GPT5_ICK,
+	SERVICESCLK_GPT6_FCK,
+	SERVICESCLK_GPT6_ICK,
+	SERVICESCLK_GPT7_FCK,
+	SERVICESCLK_GPT7_ICK,
+	SERVICESCLK_GPT8_FCK,
+	SERVICESCLK_GPT8_ICK,
+	SERVICESCLK_WDT3_FCK,
+	SERVICESCLK_WDT3_ICK,
+	SERVICESCLK_MCBSP1_FCK,
+	SERVICESCLK_MCBSP1_ICK,
+	SERVICESCLK_MCBSP2_FCK,
+	SERVICESCLK_MCBSP2_ICK,
+	SERVICESCLK_MCBSP3_FCK,
+	SERVICESCLK_MCBSP3_ICK,
+	SERVICESCLK_MCBSP4_FCK,
+	SERVICESCLK_MCBSP4_ICK,
+	SERVICESCLK_MCBSP5_FCK,
+	SERVICESCLK_MCBSP5_ICK,
+	SERVICESCLK_SSI_FCK,
+	SERVICESCLK_SSI_ICK,
+	SERVICESCLK_SYS32K_CK,
+	SERVICESCLK_SYS_CK,
+	SERVICESCLK_NOT_DEFINED
+};
 
 /*
- *  ======== CLK_Exit ========
+ *  ======== clk_exit ========
  *  Purpose:
  *      Discontinue usage of module; free resources when reference count
  *      reaches 0.
@@ -70,10 +62,10 @@
  *  Ensures:
  *      Resources used by module are freed when cRef reaches zero.
  */
-	extern void CLK_Exit(void);
+extern void clk_exit(void);
 
 /*
- *  ======== CLK_Init ========
+ *  ======== services_clk_init ========
  *  Purpose:
  *      Initializes private state of CLK module.
  *  Parameters:
@@ -83,11 +75,10 @@
  *  Ensures:
  *      CLK initialized.
  */
-	extern bool CLK_Init(void);
-
+extern bool services_clk_init(void);
 
 /*
- *  ======== CLK_Enable ========
+ *  ======== services_clk_enable ========
  *  Purpose:
  *      Enables the clock requested.
  *  Parameters:
@@ -97,10 +88,10 @@
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS CLK_Enable(IN enum SERVICES_ClkId clk_id);
+extern dsp_status services_clk_enable(IN enum services_clk_id clk_id);
 
 /*
- *  ======== CLK_Disable ========
+ *  ======== services_clk_disable ========
  *  Purpose:
  *      Disables the clock requested.
  *  Parameters:
@@ -110,10 +101,10 @@
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS CLK_Disable(IN enum SERVICES_ClkId clk_id);
+extern dsp_status services_clk_disable(IN enum services_clk_id clk_id);
 
 /*
- *  ======== CLK_GetRate ========
+ *  ======== services_clk_get_rate ========
  *  Purpose:
  *      Get the clock rate of requested clock.
  *  Parameters:
@@ -123,10 +114,10 @@
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS CLK_GetRate(IN enum SERVICES_ClkId clk_id,
-				     u32 *speedMhz);
+extern dsp_status services_clk_get_rate(IN enum services_clk_id clk_id,
+					u32 *speedMhz);
 /*
- *  ======== CLK_Set_32KHz ========
+ *  ======== clk_set32k_hz ========
  *  Purpose:
  *      Set the requested clock to 32KHz.
  *  Parameters:
@@ -136,8 +127,8 @@
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS CLK_Set_32KHz(IN enum SERVICES_ClkId clk_id);
-	extern void SSI_Clk_Prepare(bool FLAG);
+extern dsp_status clk_set32k_hz(IN enum services_clk_id clk_id);
+extern void ssi_clk_prepare(bool FLAG);
 
 /*
  *  ======== CLK_Get_RefCnt ========
@@ -150,6 +141,6 @@
  *  Requires:
  *  Ensures:
  */
-	extern s32 CLK_Get_UseCnt(IN enum SERVICES_ClkId clk_id);
+extern s32 clk_get_use_cnt(IN enum services_clk_id clk_id);
 
-#endif				/* _SYNC_H */
+#endif /* _SYNC_H */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/cmmdefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/cmmdefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/cmmdefs.h	2011-10-11 13:50:57.432894958 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/cmmdefs.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global MEM constants and types.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,56 +16,32 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== cmmdefs.h ========
- *  Purpose:
- *      Global MEM constants and types.
- *
- *! Revision History:
- *! ================
- *! 12-Nov-2001 ag  CMM_KERNMAPTYPE added for dsp<->device process addr map'n.
- *!                 This allows addr conversion from drvr process <-> DSP addr.
- *! 29-Aug-2001 ag  Added CMM_ALLSEGMENTS.
- *! 08-Dec-2000 ag  Added bus address conversion type CMM_POMAPEMIF2DSPBUS.
- *! 05-Dec-2000 ag  Added default CMM_DEFLTCONVFACTOR & CMM_DEFLTDSPADDROFFSET.
- *! 29-Oct-2000 ag  Added converstion factor for GPP DSP Pa translation.
- *! 15-Oct-2000 ag  Added address translator attributes and defaults.
- *! 12-Jul-2000 ag  Created.
- */
-
 #ifndef CMMDEFS_
 #define CMMDEFS_
 
 #include <dspbridge/list.h>
 
-/* Cmm attributes used in CMM_Create() */
-	struct CMM_MGRATTRS {
-		/* Minimum SM allocation; default 32 bytes.  */
-		u32 ulMinBlockSize;
-	} ;
+/* Cmm attributes used in cmm_create() */
+struct cmm_mgrattrs {
+	/* Minimum SM allocation; default 32 bytes. */
+	u32 ul_min_block_size;
+};
 
 /* Attributes for CMM_AllocBuf() & CMM_AllocDesc() */
-	struct CMM_ATTRS {
-		u32 ulSegId;	/*  1,2... are SM segments. 0 is not. */
-		u32 ulAlignment;	/*  0,1,2,4....ulMinBlockSize */
-	} ;
+struct cmm_attrs {
+	u32 ul_seg_id;		/*  1,2... are SM segments. 0 is not. */
+	u32 ul_alignment;	/*  0,1,2,4....ul_min_block_size */
+};
 
 /*
  *  DSPPa to GPPPa Conversion Factor.
  *
  *  For typical platforms:
- *      converted Address = PaDSP + ( cFactor * addressToConvert).
+ *      converted Address = PaDSP + ( c_factor * addressToConvert).
  */
-	enum CMM_CNVTTYPE {
-		CMM_SUBFROMDSPPA = -1,
-		/* PreOMAP is special case: not simple offset */
-		CMM_POMAPEMIF2DSPBUS = 0,
-		CMM_ADDTODSPPA = 1
-	} ;
+#define CMM_SUBFROMDSPPA	-1
+#define CMM_ADDTODSPPA		1
 
-#define CMM_DEFLTDSPADDROFFSET  0
-#define CMM_DEFLTCONVFACTOR     CMM_POMAPEMIF2DSPBUS /* PreOMAP DSPBUS<->EMIF */
 #define CMM_ALLSEGMENTS         0xFFFFFF	/* All SegIds */
 #define CMM_MAXGPPSEGS          1	/* Maximum # of SM segs */
 
@@ -73,63 +51,55 @@
  *  This info is used by the GPP to xlate DSP allocated PAs.
  */
 
-	struct CMM_SEGINFO {
-		u32 dwSegBasePa;	/* Start Phys address of SM segment */
-		/* Total size in bytes of segment: DSP+GPP */
-		u32 ulTotalSegSize;
-		u32 dwGPPBasePA;	/* Start Phys addr of Gpp SM seg */
-		u32 ulGPPSize;	/* Size of Gpp SM seg in bytes */
-		u32 dwDSPBaseVA;	/* DSP virt base byte address */
-		u32 ulDSPSize;	/* DSP seg size in bytes */
-		/* # of current GPP allocations from this segment */
-		u32 ulInUseCnt;
-		u32 dwSegBaseVa;	/* Start Virt address of SM seg */
+struct cmm_seginfo {
+	u32 dw_seg_base_pa;	/* Start Phys address of SM segment */
+	/* Total size in bytes of segment: DSP+GPP */
+	u32 ul_total_seg_size;
+	u32 dw_gpp_base_pa;	/* Start Phys addr of Gpp SM seg */
+	u32 ul_gpp_size;	/* Size of Gpp SM seg in bytes */
+	u32 dw_dsp_base_va;	/* DSP virt base byte address */
+	u32 ul_dsp_size;	/* DSP seg size in bytes */
+	/* # of current GPP allocations from this segment */
+	u32 ul_in_use_cnt;
+	u32 dw_seg_base_va;	/* Start Virt address of SM seg */
 
-	} ;
+};
 
 /* CMM useful information */
-	struct CMM_INFO {
-		/* # of SM segments registered with this Cmm. */
-		u32 ulNumGPPSMSegs;
-		/* Total # of allocations outstanding for CMM */
-		u32 ulTotalInUseCnt;
-		/* Min SM block size allocation from CMM_Create() */
-		u32 ulMinBlockSize;
-		/* Info per registered SM segment. */
-		struct CMM_SEGINFO segInfo[CMM_MAXGPPSEGS];
-	} ;
+struct cmm_info {
+	/* # of SM segments registered with this Cmm. */
+	u32 ul_num_gppsm_segs;
+	/* Total # of allocations outstanding for CMM */
+	u32 ul_total_in_use_cnt;
+	/* Min SM block size allocation from cmm_create() */
+	u32 ul_min_block_size;
+	/* Info per registered SM segment. */
+	struct cmm_seginfo seg_info[CMM_MAXGPPSEGS];
+};
 
 /* XlatorCreate attributes */
-	struct CMM_XLATORATTRS {
-		u32 ulSegId;	/* segment Id used for SM allocations */
-		u32 dwDSPBufs;	/* # of DSP-side bufs */
-		u32 dwDSPBufSize;	/* size of DSP-side bufs in GPP bytes */
-		/* Vm base address alloc'd in client process context */
-		void *pVmBase;
-		/* dwVmSize must be >= (dwMaxNumBufs * dwMaxSize) */
-		u32 dwVmSize;
-	} ;
+struct cmm_xlatorattrs {
+	u32 ul_seg_id;		/* segment Id used for SM allocations */
+	u32 dw_dsp_bufs;	/* # of DSP-side bufs */
+	u32 dw_dsp_buf_size;	/* size of DSP-side bufs in GPP bytes */
+	/* Vm base address alloc'd in client process context */
+	void *vm_base;
+	/* dw_vm_size must be >= (dwMaxNumBufs * dwMaxSize) */
+	u32 dw_vm_size;
+};
 
 /*
  * Cmm translation types. Use to map SM addresses to process context.
  */
-	enum CMM_XLATETYPE {
-		CMM_VA2PA = 0,	/* Virtual to GPP physical address xlation */
-		CMM_PA2VA = 1,	/* GPP Physical to virtual  */
-		CMM_VA2DSPPA = 2,	/* Va to DSP Pa  */
-		CMM_PA2DSPPA = 3,	/* GPP Pa to DSP Pa */
-		CMM_DSPPA2PA = 4,	/* DSP Pa to GPP Pa */
-	} ;
-
-/*
- *  Used to "map" between device process virt addr and dsp addr.
- */
-	enum CMM_KERNMAPTYPE {
-		CMM_KERNVA2DSP = 0, /* Device process context to dsp address. */
-		CMM_DSP2KERNVA = 1, /* Dsp address to device process context. */
-	} ;
+enum cmm_xlatetype {
+	CMM_VA2PA = 0,		/* Virtual to GPP physical address xlation */
+	CMM_PA2VA = 1,		/* GPP Physical to virtual */
+	CMM_VA2DSPPA = 2,	/* Va to DSP Pa */
+	CMM_PA2DSPPA = 3,	/* GPP Pa to DSP Pa */
+	CMM_DSPPA2PA = 4,	/* DSP Pa to GPP Pa */
+};
 
-	struct CMM_OBJECT;
-	struct CMM_XLATOROBJECT;
+struct cmm_object;
+struct cmm_xlatorobject;
 
-#endif				/* CMMDEFS_ */
+#endif /* CMMDEFS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/cmm.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/cmm.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/cmm.h	2011-10-11 13:50:57.437299197 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/cmm.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,22 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * The Communication Memory Management(CMM) module provides shared memory
+ * management services for DSP/BIOS Bridge data streaming and messaging.
+ * Multiple shared memory segments can be registered with CMM. Memory is
+ * coelesced back to the appropriate pool when a buffer is freed.
+ *
+ * The CMM_Xlator[xxx] functions are used for node messaging and data
+ * streaming address translation to perform zero-copy inter-processor
+ * data transfer(GPP<->DSP). A "translator" object is created for a node or
+ * stream object that contains per thread virtual address information. This
+ * translator info is used at runtime to perform SM address translation
+ * to/from the DSP address space.
+ *
+ * Notes:
+ *   cmm_xlator_alloc_buf - Used by Node and Stream modules for SM address
+ *			  translation.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,56 +30,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== cmm.h ========
- *  Purpose:
- *      The Communication Memory Management(CMM) module provides shared memory
- *      management services for DSP/BIOS Bridge data streaming and messaging.
- *      Multiple shared memory segments can be registered with CMM. Memory is
- *      coelesced back to the appropriate pool when a buffer is freed.
- *
- *      The CMM_Xlator[xxx] functions are used for node messaging and data
- *      streaming address translation to perform zero-copy inter-processor
- *      data transfer(GPP<->DSP). A "translator" object is created for a node or
- *      stream object that contains per thread virtual address information. This
- *      translator info is used at runtime to perform SM address translation
- *      to/from the DSP address space.
- *
- *
- *  Public Functions:
- *      CMM_CallocBuf
- *      CMM_Create
- *      CMM_Destroy
- *      CMM_Exit
- *      CMM_FreeBuf
- *      CMM_GetHandle
- *      CMM_GetInfo
- *      CMM_Init
- *      CMM_RegisterGPPSMSeg
- *      CMM_UnRegisterGPPSMSeg
- *      CMM_XlatorAllocBuf       (Note #1 below)
- *      CMM_XlatorCreate           "
- *      CMM_XlatorDelete           "
- *      CMM_XlatorFreeBuf          "
- *      CMM_XlatorTranslate        "
- *
- *
- *  Notes:
- *      #1: Used by Node and Stream modules for SM address translation.
- *
- *! Revision History:
- *! ================
- *! 30-Jan-2002 ag  Removed unused CMM_Alloc[Free]Desc & CMM_XlatorRegisterPa.
- *!                 Renamed CMM_AllocBuf() to CMM_CallocBuf().
- *! 29-Aug-2001 ag: Added dsp virt base and size to CMM_RegisterGPPSMSeg().
- *! 12-Aug-2001 ag: Added CMM_UnRegisterGPP[DSP}SMSeg[s]().
- *! 05-Dec-2000 ag: Added param to CMM_XlatorDelete() to force buf cleanup.
- *! 30-Oct-2000 ag: Added conversion factor to CMM_RegisterDSP[GPP]SMSeg().
- *! 12-Oct-2000 ag: Added CMM_Xlator[xxx] functions.
- *! 10-Aug-2000 ag: Created.
- *!
- */
-
 #ifndef CMM_
 #define CMM_
 
@@ -73,38 +39,39 @@
 #include <dspbridge/host_os.h>
 
 /*
- *  ======== CMM_CallocBuf ========
+ *  ======== cmm_calloc_buf ========
  *  Purpose:
  *      Allocate memory buffers that can be used for data streaming or
  *      messaging.
  *  Parameters:
- *      hCmmMgr:   Cmm Mgr handle.
- *      uSize:     Number of bytes to allocate.
- *      pAttr:     Attributes of memory to allocate.
- *      ppBufVA:   Address of where to place VA.
+ *      hcmm_mgr:   Cmm Mgr handle.
+ *      usize:     Number of bytes to allocate.
+ *      pattr:     Attributes of memory to allocate.
+ *      pp_buf_va:   Address of where to place VA.
  *  Returns:
  *      Pointer to a zero'd block of SM memory;
  *      NULL if memory couldn't be allocated,
- *      or if cBytes == 0,
+ *      or if byte_size == 0,
  *  Requires:
- *      Valid hCmmMgr.
+ *      Valid hcmm_mgr.
  *      CMM initialized.
  *  Ensures:
  *      The returned pointer, if not NULL, points to a valid memory block of
  *      the size requested.
  *
  */
-	extern void *CMM_CallocBuf(struct CMM_OBJECT *hCmmMgr,
-				   u32 uSize, struct CMM_ATTRS *pAttrs,
-				   OUT void **ppBufVA);
+extern void *cmm_calloc_buf(struct cmm_object *hcmm_mgr,
+			    u32 usize, struct cmm_attrs *pattrs,
+			    OUT void **pp_buf_va);
 
 /*
- *  ======== CMM_Create ========
+ *  ======== cmm_create ========
  *  Purpose:
  *      Create a communication memory manager object.
  *  Parameters:
- *      phCmmMgr:   Location to store a communication manager handle on output.
- *      hDevObject: Handle to a device object.
+ *      ph_cmm_mgr:	Location to store a communication manager handle on
+ *      		output.
+ *      hdev_obj: Handle to a device object.
  *      pMgrAttrs:  Comm mem manager attributes.
  *  Returns:
  *      DSP_SOK:        Success;
@@ -112,22 +79,22 @@
  *      DSP_EFAIL:      Failed to initialize critical sect sync object.
  *
  *  Requires:
- *      CMM_Init(void) called.
- *      phCmmMgr != NULL.
- *      pMgrAttrs->ulMinBlockSize >= 4 bytes.
+ *      cmm_init(void) called.
+ *      ph_cmm_mgr != NULL.
+ *      pMgrAttrs->ul_min_block_size >= 4 bytes.
  *  Ensures:
  *
  */
-	extern DSP_STATUS CMM_Create(OUT struct CMM_OBJECT **phCmmMgr,
-				     struct DEV_OBJECT *hDevObject,
-				     IN CONST struct CMM_MGRATTRS *pMgrAttrs);
+extern dsp_status cmm_create(OUT struct cmm_object **ph_cmm_mgr,
+			     struct dev_object *hdev_obj,
+			     IN CONST struct cmm_mgrattrs *pMgrAttrs);
 
 /*
- *  ======== CMM_Destroy ========
+ *  ======== cmm_destroy ========
  *  Purpose:
  *      Destroy the communication memory manager object.
  *  Parameters:
- *      hCmmMgr:   Cmm Mgr handle.
+ *      hcmm_mgr:   Cmm Mgr handle.
  *      bForce:    Force deallocation of all cmm memory immediately if set TRUE.
  *                 If FALSE, and outstanding allocations will return DSP_EFAIL
  *                 status.
@@ -137,14 +104,14 @@
  *      DSP_EHANDLE:    Unable to free CMM due to bad handle.
  *  Requires:
  *      CMM is initialized.
- *      hCmmMgr != NULL.
+ *      hcmm_mgr != NULL.
  *  Ensures:
  *      Memory resources used by Cmm Mgr are freed.
  */
-	extern DSP_STATUS CMM_Destroy(struct CMM_OBJECT *hCmmMgr, bool bForce);
+extern dsp_status cmm_destroy(struct cmm_object *hcmm_mgr, bool bForce);
 
 /*
- *  ======== CMM_Exit ========
+ *  ======== cmm_exit ========
  *  Purpose:
  *     Discontinue usage of module. Cleanup CMM module if CMM cRef reaches zero.
  *  Parameters:
@@ -155,55 +122,56 @@
  *     CMM is initialized.
  *  Ensures:
  */
-	extern void CMM_Exit(void);
+extern void cmm_exit(void);
 
 /*
- *  ======== CMM_FreeBuf ========
+ *  ======== cmm_free_buf ========
  *  Purpose:
  *      Free the given buffer.
  *  Parameters:
- *      hCmmMgr:    Cmm Mgr handle.
- *      pBuf:       Pointer to memory allocated by CMM_CallocBuf().
- *      ulSegId:    SM segment Id used in CMM_Calloc() attrs.
+ *      hcmm_mgr:    Cmm Mgr handle.
+ *      pbuf:       Pointer to memory allocated by cmm_calloc_buf().
+ *      ul_seg_id:    SM segment Id used in CMM_Calloc() attrs.
  *                  Set to 0 to use default segment.
  *  Returns:
  *      DSP_SOK
  *      DSP_EFAIL
  *  Requires:
  *      CMM initialized.
- *      pBufPA != NULL
+ *      buf_pa != NULL
  *  Ensures:
  *
  */
-	extern DSP_STATUS CMM_FreeBuf(struct CMM_OBJECT *hCmmMgr,
-				      void *pBufPA, u32 ulSegId);
+extern dsp_status cmm_free_buf(struct cmm_object *hcmm_mgr,
+			       void *buf_pa, u32 ul_seg_id);
 
 /*
- *  ======== CMM_GetHandle ========
+ *  ======== cmm_get_handle ========
  *  Purpose:
  *      Return the handle to the cmm mgr for the given device obj.
  *  Parameters:
- *      hProcessor:   Handle to a Processor.
- *      phCmmMgr:     Location to store the shared memory mgr handle on output.
+ *      hprocessor:   Handle to a Processor.
+ *      ph_cmm_mgr:	Location to store the shared memory mgr handle on
+ *      		output.
  *
  *  Returns:
  *      DSP_SOK:        Cmm Mgr opaque handle returned.
  *      DSP_EHANDLE:    Invalid handle.
  *  Requires:
- *      phCmmMgr != NULL
- *      hDevObject != NULL
+ *      ph_cmm_mgr != NULL
+ *      hdev_obj != NULL
  *  Ensures:
  */
-	extern DSP_STATUS CMM_GetHandle(DSP_HPROCESSOR hProcessor,
-					OUT struct CMM_OBJECT **phCmmMgr);
+extern dsp_status cmm_get_handle(void *hprocessor,
+				 OUT struct cmm_object **ph_cmm_mgr);
 
 /*
- *  ======== CMM_GetInfo ========
+ *  ======== cmm_get_info ========
  *  Purpose:
  *      Return the current SM and VM utilization information.
  *  Parameters:
- *      hCmmMgr:     Handle to a Cmm Mgr.
- *      pCmmInfo:    Location to store the Cmm information on output.
+ *      hcmm_mgr:     Handle to a Cmm Mgr.
+ *      cmm_info_obj:    Location to store the Cmm information on output.
  *
  *  Returns:
  *      DSP_SOK:        Success.
@@ -213,11 +181,11 @@
  *  Ensures:
  *
  */
-	extern DSP_STATUS CMM_GetInfo(struct CMM_OBJECT *hCmmMgr,
-				      OUT struct CMM_INFO *pCmmInfo);
+extern dsp_status cmm_get_info(struct cmm_object *hcmm_mgr,
+			       OUT struct cmm_info *cmm_info_obj);
 
 /*
- *  ======== CMM_Init ========
+ *  ======== cmm_init ========
  *  Purpose:
  *      Initializes private state of CMM module.
  *  Parameters:
@@ -227,73 +195,72 @@
  *  Ensures:
  *      CMM initialized.
  */
-	extern bool CMM_Init(void);
+extern bool cmm_init(void);
 
 /*
- *  ======== CMM_RegisterGPPSMSeg ========
+ *  ======== cmm_register_gppsm_seg ========
  *  Purpose:
  *      Register a block of SM with the CMM.
  *  Parameters:
- *      hCmmMgr:         Handle to a Cmm Mgr.
+ *      hcmm_mgr:         Handle to a Cmm Mgr.
  *      lpGPPBasePA:     GPP Base Physical address.
- *      ulSize:          Size in GPP bytes.
+ *      ul_size:          Size in GPP bytes.
  *      dwDSPAddrOffset  GPP PA to DSP PA Offset.
- *      cFactor:         Add offset if CMM_ADDTODSPPA, sub if CMM_SUBFROMDSPPA.
- *      dwDSPBase:       DSP virtual base byte address.
- *      ulDSPSize:       Size of DSP segment in bytes.
+ *      c_factor:         Add offset if CMM_ADDTODSPPA, sub if CMM_SUBFROMDSPPA.
+ *      dw_dsp_base:       DSP virtual base byte address.
+ *      ul_dsp_size:       Size of DSP segment in bytes.
  *      pulSegId:        Address to store segment Id.
  *
  *  Returns:
  *      DSP_SOK:         Success.
- *      DSP_EHANDLE:     Invalid hCmmMgr handle.
+ *      DSP_EHANDLE:     Invalid hcmm_mgr handle.
  *      DSP_EINVALIDARG: Invalid input argument.
  *      DSP_EFAIL:       Unable to register.
  *      - On success *pulSegId is a valid SM segment ID.
  *  Requires:
- *      ulSize > 0
+ *      ul_size > 0
  *      pulSegId != NULL
- *      dwGPPBasePA != 0
- *      cFactor = CMM_ADDTODSPPA || cFactor = CMM_SUBFROMDSPPA
+ *      dw_gpp_base_pa != 0
+ *      c_factor = CMM_ADDTODSPPA || c_factor = CMM_SUBFROMDSPPA
  *  Ensures:
  *
  */
-	extern DSP_STATUS CMM_RegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr,
-					       unsigned int dwGPPBasePA,
-					       u32 ulSize,
-					       u32 dwDSPAddrOffset,
-					       enum CMM_CNVTTYPE cFactor,
-					       unsigned int dwDSPBase,
-					       u32 ulDSPSize,
-					       u32 *pulSegId,
-					       u32 dwGPPBaseBA);
+extern dsp_status cmm_register_gppsm_seg(struct cmm_object *hcmm_mgr,
+					 unsigned int dw_gpp_base_pa,
+					 u32 ul_size,
+					 u32 dwDSPAddrOffset,
+					 s8 c_factor,
+					 unsigned int dw_dsp_base,
+					 u32 ul_dsp_size,
+					 u32 *pulSegId, u32 dwGPPBaseBA);
 
 /*
- *  ======== CMM_UnRegisterGPPSMSeg ========
+ *  ======== cmm_un_register_gppsm_seg ========
  *  Purpose:
  *      Unregister the given memory segment that was previously registered
- *      by CMM_RegisterGPPSMSeg.
+ *      by cmm_register_gppsm_seg.
  *  Parameters:
- *      hCmmMgr:    Handle to a Cmm Mgr.
- *      ulSegId     Segment identifier returned by CMM_RegisterGPPSMSeg.
+ *      hcmm_mgr:    Handle to a Cmm Mgr.
+ *      ul_seg_id     Segment identifier returned by cmm_register_gppsm_seg.
  *  Returns:
  *       DSP_SOK:         Success.
  *       DSP_EHANDLE:     Invalid handle.
- *       DSP_EINVALIDARG: Invalid ulSegId.
+ *       DSP_EINVALIDARG: Invalid ul_seg_id.
  *       DSP_EFAIL:       Unable to unregister for unknown reason.
  *  Requires:
  *  Ensures:
  *
  */
-	extern DSP_STATUS CMM_UnRegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr,
-						 u32 ulSegId);
+extern dsp_status cmm_un_register_gppsm_seg(struct cmm_object *hcmm_mgr,
+					    u32 ul_seg_id);
 
 /*
- *  ======== CMM_XlatorAllocBuf ========
+ *  ======== cmm_xlator_alloc_buf ========
  *  Purpose:
  *      Allocate the specified SM buffer and create a local memory descriptor.
  *      Place on the descriptor on the translator's HaQ (Host Alloc'd Queue).
  *  Parameters:
- *      hXlator:    Handle to a Xlator object.
+ *      xlator:    Handle to a Xlator object.
  *      pVaBuf:     Virtual address ptr(client context)
  *      uPaSize:    Size of SM memory to allocate.
  *  Returns:
@@ -304,18 +271,18 @@
  *  Ensures:
  *
  */
-	extern void *CMM_XlatorAllocBuf(struct CMM_XLATOROBJECT *hXlator,
-					void *pVaBuf, u32 uPaSize);
+extern void *cmm_xlator_alloc_buf(struct cmm_xlatorobject *xlator,
+				  void *pVaBuf, u32 uPaSize);
 
 /*
- *  ======== CMM_XlatorCreate ========
+ *  ======== cmm_xlator_create ========
  *  Purpose:
  *     Create a translator(xlator) object used for process specific Va<->Pa
  *     address translation. Node messaging and streams use this to perform
  *     inter-processor(GPP<->DSP) zero-copy data transfer.
  *  Parameters:
  *     phXlator:       Address to place handle to a new Xlator handle.
- *     hCmmMgr:        Handle to Cmm Mgr associated with this translator.
+ *     hcmm_mgr:        Handle to Cmm Mgr associated with this translator.
  *     pXlatorAttrs:   Translator attributes used for the client NODE or STREAM.
  *  Returns:
  *     DSP_SOK:            Success.
@@ -323,41 +290,41 @@
  *     DSP_EMEMORY:   Insufficient memory(local) for requested resources.
  *  Requires:
  *     phXlator != NULL
- *     hCmmMgr != NULL
+ *     hcmm_mgr != NULL
  *     pXlatorAttrs != NULL
  *  Ensures:
  *
  */
-      extern DSP_STATUS CMM_XlatorCreate(OUT struct CMM_XLATOROBJECT **phXlator,
-					 struct CMM_OBJECT *hCmmMgr,
-					 struct CMM_XLATORATTRS *pXlatorAttrs);
+extern dsp_status cmm_xlator_create(OUT struct cmm_xlatorobject **phXlator,
+				    struct cmm_object *hcmm_mgr,
+				    struct cmm_xlatorattrs *pXlatorAttrs);
 
 /*
- *  ======== CMM_XlatorDelete ========
+ *  ======== cmm_xlator_delete ========
  *  Purpose:
  *      Delete translator resources
  *  Parameters:
- *      hXlator:    handle to translator.
+ *      xlator:    handle to translator.
  *      bForce:     bForce = TRUE will free XLators SM buffers/dscriptrs.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Bad translator handle.
  *      DSP_EFAIL:      Unable to free translator resources.
  *  Requires:
- *      cRefs > 0
+ *      refs > 0
  *  Ensures:
  *
  */
-	extern DSP_STATUS CMM_XlatorDelete(struct CMM_XLATOROBJECT *hXlator,
-					   bool bForce);
+extern dsp_status cmm_xlator_delete(struct cmm_xlatorobject *xlator,
+				    bool bForce);
 
 /*
- *  ======== CMM_XlatorFreeBuf ========
+ *  ======== cmm_xlator_free_buf ========
  *  Purpose:
  *      Free SM buffer and descriptor.
  *      Does not free client process VM.
  *  Parameters:
- *      hXlator:    handle to translator.
+ *      xlator:    handle to translator.
  *      pBufVa      Virtual address of PA to free.
  *  Returns:
  *      DSP_SOK:        Success.
@@ -366,55 +333,54 @@
  *  Ensures:
  *
  */
-	extern DSP_STATUS CMM_XlatorFreeBuf(struct CMM_XLATOROBJECT *hXlator,
-					    void *pBufVa);
+extern dsp_status cmm_xlator_free_buf(struct cmm_xlatorobject *xlator,
+				      void *pBufVa);
 
 /*
- *  ======== CMM_XlatorInfo ========
+ *  ======== cmm_xlator_info ========
  *  Purpose:
  *      Set/Get process specific "translator" address info.
  *      This is used to perform fast virtaul address translation
  *      for shared memory buffers between the GPP and DSP.
  *  Parameters:
- *     hXlator:     handle to translator.
- *     pAddr:       Virtual base address of segment.
- *     ulSize:      Size in bytes.
+ *     xlator:     handle to translator.
+ *     paddr:       Virtual base address of segment.
+ *     ul_size:      Size in bytes.
  *     uSegId:      Segment identifier of SM segment(s)
- *     bSetInfo     Set xlator fields if TRUE, else return base addr
+ *     set_info     Set xlator fields if TRUE, else return base addr
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Bad translator handle.
  *  Requires:
- *      (cRefs > 0)
- *      (pAddr != NULL)
- *      (ulSize > 0)
+ *      (refs > 0)
+ *      (paddr != NULL)
+ *      (ul_size > 0)
  *  Ensures:
  *
  */
-	extern DSP_STATUS CMM_XlatorInfo(struct CMM_XLATOROBJECT *hXlator,
-					 IN OUT u8 **pAddr,
-					 u32 ulSize, u32 uSegId,
-					 bool bSetInfo);
+extern dsp_status cmm_xlator_info(struct cmm_xlatorobject *xlator,
+				  IN OUT u8 **paddr,
+				  u32 ul_size, u32 uSegId, bool set_info);
 
 /*
- *  ======== CMM_XlatorTranslate ========
+ *  ======== cmm_xlator_translate ========
  *  Purpose:
  *      Perform address translation VA<->PA for the specified stream or
  *      message shared memory buffer.
  *  Parameters:
- *     hXlator: handle to translator.
- *     pAddr    address of buffer to translate.
+ *     xlator: handle to translator.
+ *     paddr    address of buffer to translate.
  *     xType    Type of address xlation. CMM_PA2VA or CMM_VA2PA.
  *  Returns:
  *     Valid address on success, else NULL.
  *  Requires:
- *      cRefs > 0
- *      pAddr != NULL
+ *      refs > 0
+ *      paddr != NULL
  *      xType >= CMM_VA2PA) && (xType <= CMM_DSPPA2PA)
  *  Ensures:
  *
  */
-	extern void *CMM_XlatorTranslate(struct CMM_XLATOROBJECT *hXlator,
-					 void *pAddr, enum CMM_XLATETYPE xType);
+extern void *cmm_xlator_translate(struct cmm_xlatorobject *xlator,
+				  void *paddr, enum cmm_xlatetype xType);
 
-#endif				/* CMM_ */
+#endif /* CMM_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/cod.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/cod.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/cod.h	2011-10-11 13:50:57.437299197 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/cod.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,10 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Code management module for DSPs. This module provides an interface
+ * interface for loading both static and dynamic code objects onto DSP
+ * systems.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,60 +18,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== cod.h ========
- *  Description:
- *      Code management module for DSPs. This module provides an interface
- *      interface for loading both static and dynamic code objects onto DSP
- *      systems.
- *
- *  Public Functions:
- *      COD_Close
- *      COD_Create
- *      COD_Delete
- *      COD_Exit
- *      COD_GetBaseLib
- *      COD_GetBaseName
- *      COD_GetLoader
- *      COD_GetSection
- *      COD_GetSymValue
- *      COD_Init
- *      COD_LoadBase
- *      COD_Open
- *      COD_OpenBase
- *      COD_ReadSection
- *      COD_UnloadSection
- *
- *  Note:
- *      Currently, only static loading is supported.
- *
- *! Revision History
- *! ================
- *! 08-Apr-2003 map: Changed DBL to DBLL
- *! 07-Aug-2002 jeh: Added COD_GetBaseName().
- *! 17-Jul-2002 jeh: Added COD_Open(), COD_Close().
- *! 15-Mar-2002 jeh: Added DBL_Flags param to COD_OpenBase().
- *! 19-Oct-2001 jeh: Added COD_GetBaseLib, COD_GetLoader, (left in
- *!                  COD_LoadSection(), COD_UnloadSection(), since they
- *!                  may be needed for BridgeLite).
- *! 07-Sep-2001 jeh: Added COD_LoadSection(), COD_UnloadSection().
- *! 11-Jan-2001 jeh: Added COD_OpenBase.
- *! 29-Sep-2000 kc:  Added size param to COD_ReadSection for input buffer
- *!                  validation.
- *! 02-Aug-2000 kc:  Added COD_ReadSection.
- *! 04-Sep-1997 gp:  Added CDECL identifier to COD_WRITEFXN (for NT)..
- *! 18-Aug-1997 cr:  Added explicit CDECL identifier.
- *! 28-Oct-1996 gp:  Added COD_GetSection.
- *! 30-Jul-1996 gp:  Added envp[] argument to COD_LoadBase().
- *! 12-Jun-1996 gp:  Moved OUT param first in _Create().  Updated _Create()
- *!                  call to take a ZLFileName.  Moved COD_ processor types
- *!                  to CFG.
- *! 29-May-1996 gp:  Changed WCD_STATUS to DSP_STATUS.  Removed include's.
- *! 07-May-1996 mg:  Created.
- *
- */
-
 #ifndef COD_
 #define COD_
 
@@ -83,35 +33,33 @@
 #define COD_NOLOAD              DBLL_NOLOAD
 #define COD_SYMB                DBLL_SYMB
 
-/* Flags passed to COD_Open */
-	typedef DBLL_Flags COD_FLAGS;
+/* Flags passed to cod_open */
+typedef dbll_flags cod_flags;
 
 /* COD code manager handle */
-	struct COD_MANAGER;
+struct cod_manager;
 
 /* COD library handle */
-	struct COD_LIBRARYOBJ;
+struct cod_libraryobj;
 
 /* COD attributes */
-	 struct COD_ATTRS {
-		u32 ulReserved;
-	} ;
+struct cod_attrs {
+	u32 ul_reserved;
+};
 
 /*
  *  Function prototypes for writing memory to a DSP system, allocating
  *  and freeing DSP memory.
  */
-       typedef u32(*COD_WRITEFXN) (void *pPrivRef, u32 ulDspAddr,
-					     void *pBuf, u32 ulNumBytes,
-					     u32 nMemSpace);
-
+typedef u32(*cod_writefxn) (void *priv_ref, u32 ulDspAddr,
+			    void *pbuf, u32 ul_num_bytes, u32 nMemSpace);
 
 /*
- *  ======== COD_Close ========
+ *  ======== cod_close ========
  *  Purpose:
- *      Close a library opened with COD_Open().
+ *      Close a library opened with cod_open().
  *  Parameters:
- *      lib             - Library handle returned by COD_Open().
+ *      lib             - Library handle returned by cod_open().
  *  Returns:
  *      None.
  *  Requires:
@@ -120,16 +68,16 @@
  *  Ensures:
  *
  */
-       extern void COD_Close(struct COD_LIBRARYOBJ *lib);
+extern void cod_close(struct cod_libraryobj *lib);
 
 /*
- *  ======== COD_Create ========
+ *  ======== cod_create ========
  *  Purpose:
  *      Create an object to manage code on a DSP system. This object can be
  *      used to load an initial program image with arguments that can later
  *      be expanded with dynamically loaded object files.
  *      Symbol table information is managed by this object and can be retrieved
- *      using the COD_GetSymValue() function.
+ *      using the cod_get_sym_value() function.
  *  Parameters:
  *      phManager:      created manager object
  *      pstrZLFile:     ZL DLL filename, of length < COD_MAXPATHLENGTH.
@@ -146,27 +94,27 @@
  *      pstrZLFile != NULL
  *  Ensures:
  */
-       extern DSP_STATUS COD_Create(OUT struct COD_MANAGER **phManager,
-				    char *pstrZLFile,
-				    IN OPTIONAL CONST struct COD_ATTRS *attrs);
+extern dsp_status cod_create(OUT struct cod_manager **phManager,
+			     char *pstrZLFile,
+			     IN OPTIONAL CONST struct cod_attrs *attrs);
 
 /*
- *  ======== COD_Delete ========
+ *  ======== cod_delete ========
  *  Purpose:
  *      Delete a code manager object.
  *  Parameters:
- *      hManager:   handle of manager to be deleted
+ *      cod_mgr_obj:   handle of manager to be deleted
  *  Returns:
  *      None.
  *  Requires:
  *      COD module initialized.
- *      valid hManager.
+ *      valid cod_mgr_obj.
  *  Ensures:
  */
-       extern void COD_Delete(struct COD_MANAGER *hManager);
+extern void cod_delete(struct cod_manager *cod_mgr_obj);
 
 /*
- *  ======== COD_Exit ========
+ *  ======== cod_exit ========
  *  Purpose:
  *      Discontinue usage of the COD module.
  *  Parameters:
@@ -176,91 +124,91 @@
  *  Requires:
  *      COD initialized.
  *  Ensures:
- *      Resources acquired in COD_Init(void) are freed.
+ *      Resources acquired in cod_init(void) are freed.
  */
-       extern void COD_Exit(void);
+extern void cod_exit(void);
 
 /*
- *  ======== COD_GetBaseLib ========
+ *  ======== cod_get_base_lib ========
  *  Purpose:
  *      Get handle to the base image DBL library.
  *  Parameters:
- *      hManager:   handle of manager to be deleted
+ *      cod_mgr_obj:   handle of manager to be deleted
  *      plib:       location to store library handle on output.
  *  Returns:
  *      DSP_SOK:    Success.
  *  Requires:
  *      COD module initialized.
- *      valid hManager.
+ *      valid cod_mgr_obj.
  *      plib != NULL.
  *  Ensures:
  */
-       extern DSP_STATUS COD_GetBaseLib(struct COD_MANAGER *hManager,
-					       struct DBLL_LibraryObj **plib);
+extern dsp_status cod_get_base_lib(struct cod_manager *cod_mgr_obj,
+				   struct dbll_library_obj **plib);
 
 /*
- *  ======== COD_GetBaseName ========
+ *  ======== cod_get_base_name ========
  *  Purpose:
  *      Get the name of the base image DBL library.
  *  Parameters:
- *      hManager:   handle of manager to be deleted
+ *      cod_mgr_obj:   handle of manager to be deleted
  *      pszName:    location to store library name on output.
- *      uSize:       size of name buffer.
+ *      usize:       size of name buffer.
  *  Returns:
  *      DSP_SOK:    Success.
  *      DSP_EFAIL:  Buffer too small.
  *  Requires:
  *      COD module initialized.
- *      valid hManager.
+ *      valid cod_mgr_obj.
  *      pszName != NULL.
  *  Ensures:
  */
-       extern DSP_STATUS COD_GetBaseName(struct COD_MANAGER *hManager,
-						char *pszName, u32 uSize);
+extern dsp_status cod_get_base_name(struct cod_manager *cod_mgr_obj,
+				    char *pszName, u32 usize);
 
 /*
- *  ======== COD_GetEntry ========
+ *  ======== cod_get_entry ========
  *  Purpose:
  *      Retrieve the entry point of a loaded DSP program image
  *  Parameters:
- *      hManager:   handle of manager to be deleted
+ *      cod_mgr_obj:   handle of manager to be deleted
  *      pulEntry:   pointer to location for entry point
  *  Returns:
  *      DSP_SOK:       Success.
  *  Requires:
  *      COD module initialized.
- *      valid hManager.
+ *      valid cod_mgr_obj.
  *      pulEntry != NULL.
  *  Ensures:
  */
-       extern DSP_STATUS COD_GetEntry(struct COD_MANAGER *hManager,
-					     u32 *pulEntry);
+extern dsp_status cod_get_entry(struct cod_manager *cod_mgr_obj,
+				u32 *pulEntry);
 
 /*
- *  ======== COD_GetLoader ========
+ *  ======== cod_get_loader ========
  *  Purpose:
  *      Get handle to the DBL loader.
  *  Parameters:
- *      hManager:   handle of manager to be deleted
+ *      cod_mgr_obj:   handle of manager to be deleted
  *      phLoader:   location to store loader handle on output.
  *  Returns:
  *      DSP_SOK:    Success.
  *  Requires:
  *      COD module initialized.
- *      valid hManager.
+ *      valid cod_mgr_obj.
  *      phLoader != NULL.
  *  Ensures:
  */
-       extern DSP_STATUS COD_GetLoader(struct COD_MANAGER *hManager,
-					      struct DBLL_TarObj **phLoader);
+extern dsp_status cod_get_loader(struct cod_manager *cod_mgr_obj,
+				 struct dbll_tar_obj **phLoader);
 
 /*
- *  ======== COD_GetSection ========
+ *  ======== cod_get_section ========
  *  Purpose:
  *      Retrieve the starting address and length of a section in the COFF file
  *      given the section name.
  *  Parameters:
- *      lib         Library handle returned from COD_Open().
+ *      lib         Library handle returned from cod_open().
  *      pstrSect:   name of the section, with or without leading "."
  *      puAddr:     Location to store address.
  *      puLen:      Location to store length.
@@ -270,7 +218,7 @@
  *      COD_E_SYMBOLNOTFOUND:   The symbol could not be found.
  *  Requires:
  *      COD module initialized.
- *      valid hManager.
+ *      valid cod_mgr_obj.
  *      pstrSect != NULL;
  *      puAddr != NULL;
  *      puLen != NULL;
@@ -280,19 +228,18 @@
  *      else:  *puAddr == 0 and *puLen == 0;
  *
  */
-       extern DSP_STATUS COD_GetSection(struct COD_LIBRARYOBJ *lib,
-					       IN char *pstrSect,
-					       OUT u32 *puAddr,
-					       OUT u32 *puLen);
+extern dsp_status cod_get_section(struct cod_libraryobj *lib,
+				  IN char *pstrSect,
+				  OUT u32 *puAddr, OUT u32 *puLen);
 
 /*
- *  ======== COD_GetSymValue ========
+ *  ======== cod_get_sym_value ========
  *  Purpose:
  *      Retrieve the value for the specified symbol. The symbol is first
  *      searched for literally and then, if not found, searched for as a
  *      C symbol.
  *  Parameters:
- *      lib:        library handle returned from COD_Open().
+ *      lib:        library handle returned from cod_open().
  *      pstrSymbol: name of the symbol
  *      value:      value of the symbol
  *  Returns:
@@ -301,17 +248,16 @@
  *      COD_E_SYMBOLNOTFOUND:   The symbol could not be found.
  *  Requires:
  *      COD module initialized.
- *      Valid hManager.
+ *      Valid cod_mgr_obj.
  *      pstrSym != NULL.
- *      pulValue != NULL.
+ *      pul_value != NULL.
  *  Ensures:
  */
-       extern DSP_STATUS COD_GetSymValue(struct COD_MANAGER *hManager,
-						IN char *pstrSym,
-						OUT u32 *pulValue);
+extern dsp_status cod_get_sym_value(struct cod_manager *cod_mgr_obj,
+				    IN char *pstrSym, OUT u32 * pul_value);
 
 /*
- *  ======== COD_Init ========
+ *  ======== cod_init ========
  *  Purpose:
  *      Initialize the COD module's private state.
  *  Parameters:
@@ -322,21 +268,21 @@
  *  Ensures:
  *      A requirement for each of the other public COD functions.
  */
-       extern bool COD_Init(void);
+extern bool cod_init(void);
 
 /*
- *  ======== COD_LoadBase ========
+ *  ======== cod_load_base ========
  *  Purpose:
  *      Load the initial program image, optionally with command-line arguments,
  *      on the DSP system managed by the supplied handle. The program to be
  *      loaded must be the first element of the args array and must be a fully
  *      qualified pathname.
  *  Parameters:
- *      hMgr:       manager to load the code with
+ *      hmgr:       manager to load the code with
  *      nArgc:      number of arguments in the args array
  *      args:       array of strings for arguments to DSP program
- *      writeFxn:   board-specific function to write data to DSP system
- *      pArb:       arbitrary pointer to be passed as first arg to writeFxn
+ *      write_fxn:   board-specific function to write data to DSP system
+ *      pArb:       arbitrary pointer to be passed as first arg to write_fxn
  *      envp:       array of environment strings for DSP exec.
  *  Returns:
  *      DSP_SOK:                   Success.
@@ -344,51 +290,49 @@
  *      COD_E_LOADFAILED:       Failed to load code onto target.
  *  Requires:
  *      COD module initialized.
- *      hMgr is valid.
+ *      hmgr is valid.
  *      nArgc > 0.
  *      aArgs != NULL.
  *      aArgs[0] != NULL.
- *      pfnWrite != NULL.
+ *      pfn_write != NULL.
  *  Ensures:
  */
-       extern DSP_STATUS COD_LoadBase(struct COD_MANAGER *hManager,
-					     u32 nArgc, char *aArgs[],
-					     COD_WRITEFXN pfnWrite, void *pArb,
-					     char *envp[]);
-
+extern dsp_status cod_load_base(struct cod_manager *cod_mgr_obj,
+				u32 nArgc, char *aArgs[],
+				cod_writefxn pfn_write, void *pArb,
+				char *envp[]);
 
 /*
- *  ======== COD_Open ========
+ *  ======== cod_open ========
  *  Purpose:
  *      Open a library for reading sections. Does not load or set the base.
  *  Parameters:
- *      hMgr:           manager to load the code with
+ *      hmgr:           manager to load the code with
  *      pszCoffPath:    Coff file to open.
  *      flags:          COD_NOLOAD (don't load symbols) or COD_SYMB (load
  *                      symbols).
- *      pLib:           Handle returned that can be used in calls to COD_Close
- *                      and COD_GetSection.
+ *      pLib:           Handle returned that can be used in calls to cod_close
+ *                      and cod_get_section.
  *  Returns:
  *      S_OK:                   Success.
  *      COD_E_OPENFAILED:       Failed to open target code.
  *  Requires:
  *      COD module initialized.
- *      hMgr is valid.
+ *      hmgr is valid.
  *      flags == COD_NOLOAD || flags == COD_SYMB.
  *      pszCoffPath != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS COD_Open(struct COD_MANAGER *hMgr,
-				   IN char *pszCoffPath,
-				   COD_FLAGS flags,
-				   OUT struct COD_LIBRARYOBJ **pLib);
+extern dsp_status cod_open(struct cod_manager *hmgr,
+			   IN char *pszCoffPath,
+			   cod_flags flags, OUT struct cod_libraryobj **pLib);
 
 /*
- *  ======== COD_OpenBase ========
+ *  ======== cod_open_base ========
  *  Purpose:
  *      Open base image for reading sections. Does not load the base.
  *  Parameters:
- *      hMgr:           manager to load the code with
+ *      hmgr:           manager to load the code with
  *      pszCoffPath:    Coff file to open.
  *      flags:          Specifies whether to load symbols.
  *  Returns:
@@ -396,19 +340,19 @@
  *      COD_E_OPENFAILED:   Failed to open target code.
  *  Requires:
  *      COD module initialized.
- *      hMgr is valid.
+ *      hmgr is valid.
  *      pszCoffPath != NULL.
  *  Ensures:
  */
-extern DSP_STATUS COD_OpenBase(struct COD_MANAGER *hMgr, IN char *pszCoffPath,
-				       DBLL_Flags flags);
+extern dsp_status cod_open_base(struct cod_manager *hmgr, IN char *pszCoffPath,
+				dbll_flags flags);
 
 /*
- *  ======== COD_ReadSection ========
+ *  ======== cod_read_section ========
  *  Purpose:
  *      Retrieve the content of a code section given the section name.
  *  Parameters:
- *      hManager    - manager in which to search for the symbol
+ *      cod_mgr_obj    - manager in which to search for the symbol
  *      pstrSect    - name of the section, with or without leading "."
  *      pstrContent - buffer to store content of the section.
  *  Returns:
@@ -417,17 +361,14 @@
  *      COD_E_READFAILED: Failed to read content of code section.
  *  Requires:
  *      COD module initialized.
- *      valid hManager.
+ *      valid cod_mgr_obj.
  *      pstrSect != NULL;
  *      pstrContent != NULL;
  *  Ensures:
  *      DSP_SOK:  *pstrContent stores the content of the named section.
  */
-       extern DSP_STATUS COD_ReadSection(struct COD_LIBRARYOBJ *lib,
-						IN char *pstrSect,
-						OUT char *pstrContent,
-						IN u32 cContentSize);
-
-
+extern dsp_status cod_read_section(struct cod_libraryobj *lib,
+				   IN char *pstrSect,
+				   OUT char *pstrContent, IN u32 cContentSize);
 
-#endif				/* COD_ */
+#endif /* COD_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/csl.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/csl.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/csl.h	2011-10-11 13:50:57.437299197 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/csl.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,135 +0,0 @@
-/*
- * csl.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== csl.h ========
- *  Purpose:
- *      Platform independent C Standard library functions.
- *
- *  Public Functions:
- *      CSL_AnsiToWchar
- *      CSL_ByteSwap
- *      CSL_Exit
- *      CSL_Init
- *      CSL_NumToAscii
- *      CSL_Strtok
- *      CSL_Strtokr
- *      CSL_WcharToAnsi
- *
- *! Revision History:
- *! ================
- *! 07-Aug-2002 jeh: Added CSL_Strtokr().
- *! 21-Sep-2001 jeh: Added CSL_Strncmp.
- *! 22-Nov-2000 map: Added CSL_Atoi and CSL_Strtok
- *! 19-Nov-2000 kc:  Added CSL_ByteSwap().
- *! 09-Nov-2000 kc:  Added CSL_Strncat.
- *! 29-Oct-1999 kc:  Added CSL_Wstrlen().
- *! 20-Sep-1999 ag:  Added CSL_Wchar2Ansi().
- *! 19-Jan-1998 cr:  Code review cleanup (mostly documentation fixes).
- *! 29-Dec-1997 cr:  Changed CSL_lowercase to CSL_Uppercase, added
- *!                  CSL_AnsiToWchar.
- *! 30-Sep-1997 cr:  Added explicit cdecl descriptors to fxn definitions.
- *! 25-Jun-1997 cr:  Added CSL_strcmp.
- *! 12-Jun-1996 gp:  Created.
- */
-
-#ifndef CSL_
-#define CSL_
-
-#include <dspbridge/host_os.h>
-
-/*
- *  ======== CSL_Exit ========
- *  Purpose:
- *      Discontinue usage of the CSL module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      CSL initialized.
- *  Ensures:
- *      Resources acquired in CSL_Init(void) are freed.
- */
-	extern void CSL_Exit(void);
-
-/*
- *  ======== CSL_Init ========
- *  Purpose:
- *      Initialize the CSL module's private state.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- *      A requirement for each of the other public CSL functions.
- */
-	extern bool CSL_Init(void);
-
-/*
- *  ======== CSL_NumToAscii ========
- *  Purpose:
- *      Convert a 1 or 2 digit number to a 2 digit string.
- *  Parameters:
- *      pstrNumber: Buffer to store converted string.
- *      dwNum:      Number to convert.
- *  Returns:
- *  Requires:
- *      pstrNumber must be able to hold at least three characters.
- *  Ensures:
- *      pstrNumber will be null terminated.
- */
-	extern void CSL_NumToAscii(OUT char *pstrNumber, IN u32 dwNum);
-
-
-/*
- *  ======== CSL_Strtok ========
- *  Purpose:
- *      Tokenize a NULL terminated string
- *  Parameters:
- *      ptstrSrc:       pointer to string.
- *      szSeparators:   pointer to a string of seperators
- *  Returns:
- *      char *
- *  Requires:
- *      CSL initialized.
- *      ptstrSrc is a valid string pointer.
- *      szSeparators is a valid string pointer.
- *  Ensures:
- */
-	extern char *CSL_Strtok(IN char *ptstrSrc,
-				IN CONST char *szSeparators);
-
-/*
- *  ======== CSL_Strtokr ========
- *  Purpose:
- *      Re-entrant version of strtok.
- *  Parameters:
- *      pstrSrc:        Pointer to string. May be NULL on subsequent calls.
- *      szSeparators:   Pointer to a string of seperators
- *      ppstrCur:       Location to store start of string for next call to
- *                      to CSL_Strtokr.
- *  Returns:
- *      char * (the token)
- *  Requires:
- *      CSL initialized.
- *      szSeparators != NULL
- *      ppstrCur != NULL
- *  Ensures:
- */
-	extern char *CSL_Strtokr(IN char *pstrSrc,
-				 IN CONST char *szSeparators,
-				 OUT char **ppstrCur);
-
-#endif				/* CSL_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbc.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbc.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbc.h	2011-10-11 13:50:57.437299197 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbc.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,14 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * "Design by Contract" programming macros.
+ *
+ * Notes:
+ *   Requires that the GT->ERROR function has been defaulted to a valid
+ *   error handler for the given execution environment.
+ *
+ *   Does not require that GT_init() be called.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,53 +22,25 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== dbc.h ========
- *  Purpose:
- *      "Design by Contract" programming macros.
- *
- *  Public Functions:
- *      DBC_Assert
- *      DBC_Require
- *      DBC_Ensure
- *
- *  Notes:
- *      Requires that the GT->ERROR function has been defaulted to a valid
- *      error handler for the given execution environment.
- *
- *      Does not require that GT_init() be called.
- *
- *! Revision History:
- *! ================
- *! 11-Aug-2000 ag: Removed include <dspbridge/std.h>
- *! 22-Apr-1996 gp: Created.
- */
-
 #ifndef DBC_
 #define DBC_
 
-#ifndef GT_TRACE
-#define GT_TRACE 0	    /* 0 = "trace compiled out"; 1 = "trace active" */
-#endif
-
 /* Assertion Macros: */
-#if GT_TRACE
-
-#include <dspbridge/gt.h>
+#ifdef CONFIG_BRIDGE_DEBUG
 
-#define DBC_Assert(exp) \
+#define DBC_ASSERT(exp) \
     if (!(exp)) \
-	printk("%s, line %d: Assertion (" #exp ") failed.\n", \
+	pr_err("%s, line %d: Assertion (" #exp ") failed.\n", \
 	__FILE__, __LINE__)
-#define DBC_Require DBC_Assert	/* Function Precondition.  */
-#define DBC_Ensure  DBC_Assert	/* Function Postcondition. */
+#define DBC_REQUIRE DBC_ASSERT	/* Function Precondition. */
+#define DBC_ENSURE  DBC_ASSERT	/* Function Postcondition. */
 
 #else
 
-#define DBC_Assert(exp) {}
-#define DBC_Require(exp) {}
-#define DBC_Ensure(exp) {}
+#define DBC_ASSERT(exp) {}
+#define DBC_REQUIRE(exp) {}
+#define DBC_ENSURE(exp) {}
 
-#endif				/* DEBUG */
+#endif /* DEBUG */
 
-#endif				/* DBC_ */
+#endif /* DBC_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbdcddef.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbdcddef.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbdcddef.h	2011-10-11 13:50:57.437299197 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbdcddef.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DCD (DSP/BIOS Bridge Configuration Database) constants and types.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,36 +16,11 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dbdcddef.h ========
- *  Description:
- *      DCD (DSP/BIOS Bridge Configuration Database) constants and types.
- *
- *! Revision History:
- *! ================
- *! 03-Dec-2003 map Moved and renamed DCD_OBJTYPE to DSP_DCDOBJTYPE in dbdefs.h
- *! 05-Dec-2002 map Added DCD_CREATELIBTYPE, DCD_EXECUTELIBTYPE,
- *                        DCD_DELETELIBTYPE
- *! 24-Feb-2003 kc  Updated REG entry names to DspBridge.
- *! 22-Nov-2002 gp  Cleaned up comments, formatting.
- *! 05-Aug-2002 jeh Added DCD_REGISTERFXN.
- *! 19-Apr-2002 jeh Added DCD_LIBRARYTYPE to DCD_OBJTYPE, dynamic load
- *!                 properties to DCD_NODEPROPS.
- *! 29-Jul-2001 ag  Added extended procObj.
- *! 13-Feb-2001 kc: Named changed from dcdbsdef.h dbdcddef.h.
- *! 12-Dec-2000 jeh Added DAIS iAlg name to DCD_NODEPROPS.
- *! 30-Oct-2000 kc: Added #defines for DCD_AutoRegister function.
- *! 05-Sep-2000 jeh Added DCD_NODEPROPS.
- *! 12-Aug-2000 kc: Incoroporated the use of types defined in <dspdefs.h>.
- *! 29-Jul-2000 kc: Created.
- */
-
 #ifndef DBDCDDEF_
 #define DBDCDDEF_
 
 #include <dspbridge/dbdefs.h>
-#include <dspbridge/mgrpriv.h>		/* for MGR_PROCESSOREXTINFO */
+#include <dspbridge/mgrpriv.h>	/* for mgr_processorextinfo */
 
 /*
  *  The following defines are critical elements for the DCD module:
@@ -56,39 +33,38 @@
 #define DCD_REGISTER_SECTION    ".dcd_register"
 
 /* DCD Manager Object */
-	struct DCD_MANAGER;
+struct dcd_manager;
 
 /* DCD Node Properties */
-	struct DCD_NODEPROPS {
-		struct DSP_NDBPROPS ndbProps;
-		u32 uMsgSegid;
-		u32 uMsgNotifyType;
-		char *pstrCreatePhaseFxn;
-		char *pstrDeletePhaseFxn;
-		char *pstrExecutePhaseFxn;
-		char *pstrIAlgName;
-
-		/* Dynamic load properties */
-		u16 usLoadType;	/* Static, dynamic, overlay */
-		u32 ulDataMemSegMask;	/* Data memory requirements */
-		u32 ulCodeMemSegMask;	/* Code memory requirements */
-	} ;
+struct dcd_nodeprops {
+	struct dsp_ndbprops ndb_props;
+	u32 msg_segid;
+	u32 msg_notify_type;
+	char *pstr_create_phase_fxn;
+	char *pstr_delete_phase_fxn;
+	char *pstr_execute_phase_fxn;
+	char *pstr_i_alg_name;
+
+	/* Dynamic load properties */
+	u16 us_load_type;	/* Static, dynamic, overlay */
+	u32 ul_data_mem_seg_mask;	/* Data memory requirements */
+	u32 ul_code_mem_seg_mask;	/* Code memory requirements */
+};
 
 /* DCD Generic Object Type */
-	struct DCD_GENERICOBJ {
-		union dcdObjUnion {
-			struct DCD_NODEPROPS nodeObj;	/* node object. */
-			/* processor object. */
-			struct DSP_PROCESSORINFO procObj;
-			/* extended proc object (private) */
-			struct MGR_PROCESSOREXTINFO extProcObj;
-		} objData;
-	} ;
+struct dcd_genericobj {
+	union dcdObjUnion {
+		struct dcd_nodeprops node_obj;	/* node object. */
+		/* processor object. */
+		struct dsp_processorinfo proc_info;
+		/* extended proc object (private) */
+		struct mgr_processorextinfo ext_proc_obj;
+	} obj_data;
+};
 
 /* DCD Internal Callback Type */
-       typedef DSP_STATUS(*DCD_REGISTERFXN) (IN struct DSP_UUID *pUuid,
-						IN enum DSP_DCDOBJTYPE objType,
-						IN void *handle);
-
-#endif				/* DBDCDDEF_ */
+typedef dsp_status(*dcd_registerfxn) (IN struct dsp_uuid *uuid_obj,
+				      IN enum dsp_dcdobjtype obj_type,
+				      IN void *handle);
 
+#endif /* DBDCDDEF_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbdcd.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbdcd.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbdcd.h	2011-10-11 13:50:57.463926177 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbdcd.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Defines the DSP/BIOS Bridge Configuration Database (DCD) API.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,30 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== dbdcd.h ========
- *  Description:
- *      Defines the DSP/BIOS Bridge Configuration Database (DCD) API.
- *
- *! Revision History
- *! ================
- *! 03-Dec-2003 map Changed DCD_OBJTYPE to DSP_DCDOBJTYPE
- *! 24-Feb-2003 kc  Updated DCD_AutoUnregister and DCD_GetObjects to simplify
- *!                 DCD implementation.
- *! 05-Aug-2002 jeh Added DCD_GetObjects().
- *! 11-Jul-2002 jeh Added DCD_GetDepLibs(), DCD_GetNumDepLibs().
- *! 22-Apr-2002 jeh Added DCD_GetLibraryName().
- *! 03-Apr-2001 sg  Changed error names to have DCD_E* format.
- *! 13-Feb-2001 kc  Name changed from dcdbs.h to dbdcd.h.
- *! 12-Dec-2000 kc  Added DCD_AutoUnregister.
- *! 09-Nov-2000 kc  Updated usage of DCD_EnumerateObject.
- *! 30-Oct-2000 kc  Added DCD_AutoRegister. Updated error DCD error codes.
- *! 29-Sep-2000 kc  Incorporated code review comments. See
- *!                 /src/reviews/dcd_review.txt.
- *! 26-Jul-2000 kc  Created.
- *!
- */
-
 #ifndef DBDCD_
 #define DBDCD_
 
@@ -46,12 +24,12 @@
 #include <dspbridge/nldrdefs.h>
 
 /*
- *  ======== DCD_AutoRegister ========
+ *  ======== dcd_auto_register ========
  *  Purpose:
  *      This function automatically registers DCD objects specified in a
  *      special COFF section called ".dcd_register"
  *  Parameters:
- *      hDcdMgr:                A DCD manager handle.
+ *      hdcd_mgr:                A DCD manager handle.
  *      pszCoffPath:            Pointer to name of COFF file containing DCD
  *                              objects to be registered.
  *  Returns:
@@ -68,16 +46,16 @@
  *      COFF file to contain the right COFF sections, especially
  *      ".dcd_register", which is used for auto registration.
  */
-	extern DSP_STATUS DCD_AutoRegister(IN struct DCD_MANAGER *hDcdMgr,
-					   IN char *pszCoffPath);
+extern dsp_status dcd_auto_register(IN struct dcd_manager *hdcd_mgr,
+				    IN char *pszCoffPath);
 
 /*
- *  ======== DCD_AutoUnregister ========
+ *  ======== dcd_auto_unregister ========
  *  Purpose:
  *      This function automatically unregisters DCD objects specified in a
  *      special COFF section called ".dcd_register"
  *  Parameters:
- *      hDcdMgr:                A DCD manager handle.
+ *      hdcd_mgr:                A DCD manager handle.
  *      pszCoffPath:            Pointer to name of COFF file containing
  *                              DCD objects to be unregistered.
  *  Returns:
@@ -94,11 +72,11 @@
  *      COFF file to contain the right COFF sections, especially
  *      ".dcd_register", which is used for auto unregistration.
  */
-	extern DSP_STATUS DCD_AutoUnregister(IN struct DCD_MANAGER *hDcdMgr,
-					     IN char *pszCoffPath);
+extern dsp_status dcd_auto_unregister(IN struct dcd_manager *hdcd_mgr,
+				      IN char *pszCoffPath);
 
 /*
- *  ======== DCD_CreateManager ========
+ *  ======== dcd_create_manager ========
  *  Purpose:
  *      This function creates a DCD module manager.
  *  Parameters:
@@ -115,15 +93,15 @@
  *  Ensures:
  *      A DCD manager handle is created.
  */
-	extern DSP_STATUS DCD_CreateManager(IN char *pszZlDllName,
-					    OUT struct DCD_MANAGER **phDcdMgr);
+extern dsp_status dcd_create_manager(IN char *pszZlDllName,
+				     OUT struct dcd_manager **phDcdMgr);
 
 /*
- *  ======== DCD_DestroyManager ========
+ *  ======== dcd_destroy_manager ========
  *  Purpose:
  *      This function destroys a DCD module manager.
  *  Parameters:
- *      hDcdMgr:        A DCD manager handle.
+ *      hdcd_mgr:        A DCD manager handle.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid DCD manager handle.
@@ -131,35 +109,35 @@
  *      DCD initialized.
  *  Ensures:
  */
-	extern DSP_STATUS DCD_DestroyManager(IN struct DCD_MANAGER *hDcdMgr);
+extern dsp_status dcd_destroy_manager(IN struct dcd_manager *hdcd_mgr);
 
 /*
- *  ======== DCD_EnumerateObject ========
+ *  ======== dcd_enumerate_object ========
  *  Purpose:
  *      This function enumerates currently visible DSP/BIOS Bridge objects
  *      and returns the UUID and type of each enumerated object.
  *  Parameters:
  *      cIndex:             The object enumeration index.
- *      objType:            Type of object to enumerate.
- *      pUuid:              Pointer to a DSP_UUID object.
+ *      obj_type:            Type of object to enumerate.
+ *      uuid_obj:              Pointer to a dsp_uuid object.
  *  Returns:
  *      DSP_SOK:            Success.
  *      DSP_EFAIL:          Unable to enumerate through the DCD database.
  *      DSP_SENUMCOMPLETE:  Enumeration completed. This is not an error code.
  *  Requires:
  *      DCD initialized.
- *      pUuid is a valid pointer.
+ *      uuid_obj is a valid pointer.
  *  Ensures:
  *  Details:
- *      This function can be used in conjunction with DCD_GetObjectDef to
+ *      This function can be used in conjunction with dcd_get_object_def to
  *      retrieve object properties.
  */
-	extern DSP_STATUS DCD_EnumerateObject(IN s32 cIndex,
-					      IN enum DSP_DCDOBJTYPE objType,
-					      OUT struct DSP_UUID *pUuid);
+extern dsp_status dcd_enumerate_object(IN s32 cIndex,
+				       IN enum dsp_dcdobjtype obj_type,
+				       OUT struct dsp_uuid *uuid_obj);
 
 /*
- *  ======== DCD_Exit ========
+ *  ======== dcd_exit ========
  *  Purpose:
  *      This function cleans up the DCD module.
  *  Parameters:
@@ -168,17 +146,17 @@
  *      DCD initialized.
  *  Ensures:
  */
-	extern void DCD_Exit(void);
+extern void dcd_exit(void);
 
 /*
- *  ======== DCD_GetDepLibs ========
+ *  ======== dcd_get_dep_libs ========
  *  Purpose:
  *      Given the uuid of a library and size of array of uuids, this function
  *      fills the array with the uuids of all dependent libraries of the input
  *      library.
  *  Parameters:
- *      hDcdMgr: A DCD manager handle.
- *      pUuid: Pointer to a DSP_UUID for a library.
+ *      hdcd_mgr: A DCD manager handle.
+ *      uuid_obj: Pointer to a dsp_uuid for a library.
  *      numLibs: Size of uuid array (number of library uuids).
  *      pDepLibUuids: Array of dependent library uuids to be filled in.
  *      pPersistentDepLibs: Array indicating if corresponding lib is persistent.
@@ -190,26 +168,26 @@
  *      DSP_EFAIL: General failure.
  *  Requires:
  *      DCD initialized.
- *      Valid hDcdMgr.
- *      pUuid != NULL
+ *      Valid hdcd_mgr.
+ *      uuid_obj != NULL
  *      pDepLibUuids != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS DCD_GetDepLibs(IN struct DCD_MANAGER *hDcdMgr,
-					 IN struct DSP_UUID *pUuid,
-					 u16 numLibs,
-					 OUT struct DSP_UUID *pDepLibUuids,
-					 OUT bool *pPersistentDepLibs,
-					 IN enum NLDR_PHASE phase);
+extern dsp_status dcd_get_dep_libs(IN struct dcd_manager *hdcd_mgr,
+				   IN struct dsp_uuid *uuid_obj,
+				   u16 numLibs,
+				   OUT struct dsp_uuid *pDepLibUuids,
+				   OUT bool *pPersistentDepLibs,
+				   IN enum nldr_phase phase);
 
 /*
- *  ======== DCD_GetNumDepLibs ========
+ *  ======== dcd_get_num_dep_libs ========
  *  Purpose:
  *      Given the uuid of a library, determine its number of dependent
  *      libraries.
  *  Parameters:
- *      hDcdMgr:        A DCD manager handle.
- *      pUuid:          Pointer to a DSP_UUID for a library.
+ *      hdcd_mgr:        A DCD manager handle.
+ *      uuid_obj:          Pointer to a dsp_uuid for a library.
  *      pNumLibs:       Size of uuid array (number of library uuids).
  *      pNumPersLibs:   number of persistent dependent library.
  *      phase:          Phase to obtain correct input library
@@ -220,58 +198,58 @@
  *      DSP_EFAIL: General failure.
  *  Requires:
  *      DCD initialized.
- *      Valid hDcdMgr.
- *      pUuid != NULL
+ *      Valid hdcd_mgr.
+ *      uuid_obj != NULL
  *      pNumLibs != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS DCD_GetNumDepLibs(IN struct DCD_MANAGER *hDcdMgr,
-					    IN struct DSP_UUID *pUuid,
-					    OUT u16 *pNumLibs,
-					    OUT u16 *pNumPersLibs,
-					    IN enum NLDR_PHASE phase);
+extern dsp_status dcd_get_num_dep_libs(IN struct dcd_manager *hdcd_mgr,
+				       IN struct dsp_uuid *uuid_obj,
+				       OUT u16 *pNumLibs,
+				       OUT u16 *pNumPersLibs,
+				       IN enum nldr_phase phase);
 
 /*
- *  ======== DCD_GetLibraryName ========
+ *  ======== dcd_get_library_name ========
  *  Purpose:
  *      This function returns the name of a (dynamic) library for a given
  *      UUID.
  *  Parameters:
- *      hDcdMgr: A DCD manager handle.
- *      pUuid:          Pointer to a DSP_UUID that represents a unique DSP/BIOS
+ *      hdcd_mgr: A DCD manager handle.
+ *      uuid_obj:	Pointer to a dsp_uuid that represents a unique DSP/BIOS
  *                      Bridge object.
  *      pstrLibName: Buffer to hold library name.
  *      pdwSize: Contains buffer size. Set to string size on output.
  *      phase:          Which phase to load
- *      fPhaseSplit:    Are phases in multiple libraries
+ *      phase_split:    Are phases in multiple libraries
  *  Returns:
  *      DSP_SOK: Success.
  *      DSP_EFAIL: General failure.
  *  Requires:
  *      DCD initialized.
- *      Valid hDcdMgr.
+ *      Valid hdcd_mgr.
  *      pstrLibName != NULL.
- *      pUuid != NULL
+ *      uuid_obj != NULL
  *      pdwSize != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS DCD_GetLibraryName(IN struct DCD_MANAGER *hDcdMgr,
-					     IN struct DSP_UUID *pUuid,
-					     IN OUT char *pstrLibName,
-					     IN OUT u32 *pdwSize,
-					     IN enum NLDR_PHASE phase,
-					     OUT bool *fPhaseSplit);
+extern dsp_status dcd_get_library_name(IN struct dcd_manager *hdcd_mgr,
+				       IN struct dsp_uuid *uuid_obj,
+				       IN OUT char *pstrLibName,
+				       IN OUT u32 *pdwSize,
+				       IN enum nldr_phase phase,
+				       OUT bool *phase_split);
 
 /*
- *  ======== DCD_GetObjectDef ========
+ *  ======== dcd_get_object_def ========
  *  Purpose:
  *      This function returns the properties/attributes of a DSP/BIOS Bridge
  *      object.
  *  Parameters:
- *      hDcdMgr:            A DCD manager handle.
- *      pUuid:              Pointer to a DSP_UUID that represents a unique
+ *      hdcd_mgr:            A DCD manager handle.
+ *      uuid_obj:              Pointer to a dsp_uuid that represents a unique
  *                          DSP/BIOS Bridge object.
- *      objType:            The type of DSP/BIOS Bridge object to be
+ *      obj_type:            The type of DSP/BIOS Bridge object to be
  *                          referenced (node, processor, etc).
  *      pObjDef:            Pointer to an object definition structure. A
  *                          union of various possible DCD object types.
@@ -289,13 +267,13 @@
  *      pObjDef is non-NULL.
  *  Ensures:
  */
-	extern DSP_STATUS DCD_GetObjectDef(IN struct DCD_MANAGER *hDcdMgr,
-					   IN struct DSP_UUID *pObjUuid,
-					   IN enum DSP_DCDOBJTYPE objType,
-					   OUT struct DCD_GENERICOBJ *pObjDef);
+extern dsp_status dcd_get_object_def(IN struct dcd_manager *hdcd_mgr,
+				     IN struct dsp_uuid *pObjUuid,
+				     IN enum dsp_dcdobjtype obj_type,
+				     OUT struct dcd_genericobj *pObjDef);
 
 /*
- *  ======== DCD_GetObjects ========
+ *  ======== dcd_get_objects ========
  *  Purpose:
  *      This function finds all DCD objects specified in a special
  *      COFF section called ".dcd_register", and for each object,
@@ -303,7 +281,7 @@
  *      various actions, such as 1) register nodes in the node database, 2)
  *      unregister nodes from the node database, and 3) add overlay nodes.
  *  Parameters:
- *      hDcdMgr:                A DCD manager handle.
+ *      hdcd_mgr:                A DCD manager handle.
  *      pszCoffPath:            Pointer to name of COFF file containing DCD
  *                              objects.
  *      registerFxn:            Callback fxn to be applied on each located
@@ -323,13 +301,12 @@
  *      COFF file to contain the right COFF sections, especially
  *      ".dcd_register", which is used for auto registration.
  */
-	extern DSP_STATUS DCD_GetObjects(IN struct DCD_MANAGER *hDcdMgr,
-					 IN char *pszCoffPath,
-					 DCD_REGISTERFXN registerFxn,
-					 void *handle);
+extern dsp_status dcd_get_objects(IN struct dcd_manager *hdcd_mgr,
+				  IN char *pszCoffPath,
+				  dcd_registerfxn registerFxn, void *handle);
 
 /*
- *  ======== DCD_Init ========
+ *  ======== dcd_init ========
  *  Purpose:
  *      This function initializes DCD.
  *  Parameters:
@@ -340,49 +317,49 @@
  *  Ensures:
  *      DCD initialized.
  */
-	extern bool DCD_Init(void);
+extern bool dcd_init(void);
 
 /*
- *  ======== DCD_RegisterObject ========
+ *  ======== dcd_register_object ========
  *  Purpose:
  *      This function registers a DSP/BIOS Bridge object in the DCD database.
  *  Parameters:
- *      pUuid:          Pointer to a DSP_UUID that identifies a DSP/BIOS
+ *      uuid_obj:          Pointer to a dsp_uuid that identifies a DSP/BIOS
  *                      Bridge object.
- *      objType:        Type of object.
- *      pszPathName:    Path to the object's COFF file.
+ *      obj_type:        Type of object.
+ *      psz_path_name:    Path to the object's COFF file.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Failed to register object.
  *  Requires:
  *      DCD initialized.
- *      pUuid and szPathName are non-NULL values.
- *      objType is a valid type value.
+ *      uuid_obj and szPathName are non-NULL values.
+ *      obj_type is a valid type value.
  *  Ensures:
  */
-	extern DSP_STATUS DCD_RegisterObject(IN struct DSP_UUID *pUuid,
-					     IN enum DSP_DCDOBJTYPE objType,
-					     IN char *pszPathName);
+extern dsp_status dcd_register_object(IN struct dsp_uuid *uuid_obj,
+				      IN enum dsp_dcdobjtype obj_type,
+				      IN char *psz_path_name);
 
 /*
- *  ======== DCD_UnregisterObject ========
+ *  ======== dcd_unregister_object ========
  *  Purpose:
  *      This function de-registers a valid DSP/BIOS Bridge object from the DCD
  *      database.
  *  Parameters:
- *      pUuid:      Pointer to a DSP_UUID that identifies a DSP/BIOS Bridge
+ *      uuid_obj:      Pointer to a dsp_uuid that identifies a DSP/BIOS Bridge
  *                  object.
- *      objType:    Type of object.
+ *      obj_type:    Type of object.
  *  Returns:
  *      DSP_SOK:    Success.
  *      DSP_EFAIL:  Unable to de-register the specified object.
  *  Requires:
  *      DCD initialized.
- *      pUuid is a non-NULL value.
- *      objType is a valid type value.
+ *      uuid_obj is a non-NULL value.
+ *      obj_type is a valid type value.
  *  Ensures:
  */
-	extern DSP_STATUS DCD_UnregisterObject(IN struct DSP_UUID *pUuid,
-					       IN enum DSP_DCDOBJTYPE objType);
+extern dsp_status dcd_unregister_object(IN struct dsp_uuid *uuid_obj,
+					IN enum dsp_dcdobjtype obj_type);
 
-#endif				/* _DBDCD_H */
+#endif /* _DBDCD_H */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbdefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbdefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbdefs.h	2011-10-11 13:50:57.483457853 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbdefs.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global definitions and constants for DSP/BIOS Bridge.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,81 +16,30 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== dbdefs.h ========
- *  Description:
- *      Global definitions and constants for DSP/BIOS Bridge.
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *! 08-Mar-2004 sb  Added MAPATTR & ELEM_SIZE for Dynamic Memory Mapping feature
- *! 09-Feb-2004 vp  Added processor ID numbers for DSP and IVA
- *! 06-Feb-2003 kc  Removed DSP_POSTMESSAGE. Updated IsValid*Event macros.
- *! 22-Nov-2002 gp  Cleaned up comments, formatting.
- *!                 Removed unused DSP_ENUMLASTNODE define.
- *! 13-Feb-2002 jeh Added uSysStackSize to DSP_NDBPROPS.
- *! 23-Jan-2002 ag  Added #define DSP_SHMSEG0.
- *! 12-Dec-2001 ag  Added DSP_ESTRMMODE error code.
- *! 04-Dec-2001 jeh Added DSP_ENOTCONNECTED error code.
- *! 10-Dec-2001 kc: Modified macros and definitions to disable DSP_POSTMESSAGE.
- *! 01-Nov-2001 jeh Added DSP_EOVERLAYMEMORY.
- *! 18-Oct-2001 ag  Added DSP_STRMMODE type.
- *!                 Added DSP_ENOTSHAREDMEM.
- *! 21-Sep-2001 ag  Added additional error codes.
- *! 07-Jun-2001 sg  Made DSPStream_AllocateBuffer fxn name plural.
- *! 11-May-2001 jeh Changed DSP_NODE_MIN_PRIORITY from 0 to 1. Removed hNode
- *!                 from DSP_NODEINFO.
- *! 02-Apr-2001 sg  Added missing error codes, rearranged codes, switched to
- *!             hex offsets, renamed some codes to match API spec.
- *! 16-Jan-2001 jeh Added DSP_ESYMBOL, DSP_EUUID.
- *! 13-Feb-2001 kc: DSP/BIOS Bridge name updates.
- *! 05-Dec-2000 ag: Added DSP_RMSxxx user available message command codes.
- *! 09-Nov-2000 rr: Added DSP_PROCEESORRESTART define; Removed DSP_PBUFFER.
- *!                 Added DSP_DCD_ENOAUTOREGISTER, DSP_EUSER1-16, DSP_ESTRMFUL
- *!                 Removed DSP_EDONE. Macros's modified.
- *! 23-Oct-2000 jeh Replaced DSP_STREAMSTATECHANGE with DSP_STREAMDONE.
- *! 09-Oct-2000 jeh Updated to version 0.9 DSP Bridge API spec.
- *! 29-Sep-2000 kc  Added error codes for DCD and REG to simplify use of
- *!                 these codes within the RM module.
- *! 27-Sep-2000 jeh Added segid, alignment, uNumBufs to DSP_STREAMATTRIN.
- *! 29-Aug-2000 jeh Added DSP_NODETYPE enum, changed DSP_EALREADYATTACHED to
- *!                 DSP_EALREADYCONNECTED. Changed scStreamConnection[1]
- *!                 to scStreamConnection[16] in DSP_NODEINFO structure.
- *!                 Added DSP_NOTIFICATION, DSP_STRMATTR. PSTRING changed
- *!                 back to TCHAR * and moved to dbtype.h.
- *! 11-Aug-2000 rr: Macros to check valid events and notify masks added.
- *! 09-Aug-2000 rr: Changed PSTRING to *s8
- *! 07-Aug-2000 rr: PROC_IDLE/SYNCINIT/UNKNOWN state removed.
- *! 20-Jul-2000 rr: Updated to version 0.8
- *! 17-Jul-2000 rr: New PROC states added to the DSP_PROCSTATE.
- *! 27-Jun-2000 rr: Created from dspapi.h
- */
-
 #ifndef DBDEFS_
 #define DBDEFS_
 
 #include <linux/types.h>
 
-#include <dspbridge/dbtype.h>		/* GPP side type definitions           */
-#include <dspbridge/std.h>		/* DSP/BIOS type definitions           */
-#include <dspbridge/rms_sh.h>		/* Types shared between GPP and DSP    */
+#include <dspbridge/dbtype.h>	/* GPP side type definitions */
+#include <dspbridge/std.h>	/* DSP/BIOS type definitions */
+#include <dspbridge/rms_sh.h>	/* Types shared between GPP and DSP */
 
-#define PG_SIZE_4K 4096
+#define PG_SIZE4K 4096
 #define PG_MASK(pg_size) (~((pg_size)-1))
 #define PG_ALIGN_LOW(addr, pg_size) ((addr) & PG_MASK(pg_size))
 #define PG_ALIGN_HIGH(addr, pg_size) (((addr)+(pg_size)-1) & PG_MASK(pg_size))
 
 /* API return value and calling convention */
-#define DBAPI                       DSP_STATUS
+#define DBAPI                       dsp_status
 
-/* Infinite time value for the uTimeout parameter to DSPStream_Select() */
+/* Infinite time value for the utimeout parameter to DSPStream_Select() */
 #define DSP_FOREVER                 (-1)
 
-/* Maximum length of node name, used in DSP_NDBPROPS */
+/* Maximum length of node name, used in dsp_ndbprops */
 #define DSP_MAXNAMELEN              32
 
-/* uNotifyType values for the RegisterNotify() functions. */
+/* notify_type values for the RegisterNotify() functions. */
 #define DSP_SIGNALEVENT             0x00000001
 
 /* Types of events for processors */
@@ -102,6 +53,7 @@
 #define DSP_SYSERROR                0x00000020
 #define DSP_EXCEPTIONABORT          0x00000300
 #define DSP_PWRERROR                0x00000080
+#define DSP_WDTOVERFLOW		0x00000040
 
 /* IVA exception events (IVA MMU fault) */
 #define IVA_MMUFAULT                0x00000040
@@ -128,7 +80,8 @@
 #define DSP_RMSUSERCODESTART RMS_USER	/* Start of RMS user cmd codes */
 /* end of user codes */
 #define DSP_RMSUSERCODEEND (RMS_USER + RMS_MAXUSERCODES);
-#define DSP_RMSBUFDESC RMS_BUFDESC	/* MSG contains SM buffer description */
+/* msg_ctrl contains SM buffer description */
+#define DSP_RMSBUFDESC RMS_BUFDESC
 
 /* Shared memory identifier for MEM segment named "SHMSEG0" */
 #define DSP_SHMSEG0     (u32)(-1)
@@ -140,7 +93,7 @@
 #define DSPWORD       unsigned char
 #define DSPWORDSIZE     sizeof(DSPWORD)
 
-/* Success & Failure macros  */
+/* Success & Failure macros */
 #define DSP_SUCCEEDED(Status)      likely((s32)(Status) >= 0)
 #define DSP_FAILED(Status)         unlikely((s32)(Status) < 0)
 
@@ -155,19 +108,15 @@
 
 #define    MAX_PROFILES     16
 
-/* Types defined for 'Bridge API */
-	typedef u32 DSP_STATUS;	/* API return code type         */
+/* DSP chip type */
+#define DSPTYPE64	0x99
 
-	typedef HANDLE DSP_HNODE;	/* Handle to a DSP Node object  */
-	typedef HANDLE DSP_HPROCESSOR;	/* Handle to a Processor object */
-	typedef HANDLE DSP_HSTREAM;	/* Handle to a Stream object    */
-
-	typedef u32 DSP_PROCFAMILY;	/* Processor family             */
-	typedef u32 DSP_PROCTYPE;	/* Processor type (w/in family) */
-	typedef u32 DSP_RTOSTYPE;	/* Type of DSP RTOS             */
+/* Types defined for 'Bridge API */
+typedef u32 dsp_status;		/* API return code type */
 
 /* Handy Macros */
-#define IsValidProcEvent(x) (((x) == 0) || (((x) & (DSP_PROCESSORSTATECHANGE | \
+#define IS_VALID_PROC_EVENT(x) (((x) == 0) || (((x) & \
+				(DSP_PROCESSORSTATECHANGE | \
 				    DSP_PROCESSORATTACH | \
 				    DSP_PROCESSORDETACH | \
 				    DSP_PROCESSORRESTART | \
@@ -176,6 +125,7 @@
 				    DSP_STREAMIOCOMPLETION | \
 				    DSP_MMUFAULT | \
 				    DSP_SYSERROR | \
+				    DSP_WDTOVERFLOW | \
 				    DSP_PWRERROR)) && \
 				!((x) & ~(DSP_PROCESSORSTATECHANGE | \
 				    DSP_PROCESSORATTACH | \
@@ -186,47 +136,49 @@
 				    DSP_STREAMIOCOMPLETION | \
 				    DSP_MMUFAULT | \
 				    DSP_SYSERROR | \
+				    DSP_WDTOVERFLOW | \
 				    DSP_PWRERROR))))
 
-#define IsValidNodeEvent(x)    (((x) == 0) || (((x) & (DSP_NODESTATECHANGE | \
-				DSP_NODEMESSAGEREADY)) && \
-				!((x) & ~(DSP_NODESTATECHANGE | \
-				DSP_NODEMESSAGEREADY))))
+#define IS_VALID_NODE_EVENT(x)    (((x) == 0) || \
+	(((x) & (DSP_NODESTATECHANGE | DSP_NODEMESSAGEREADY)) && \
+	!((x) & ~(DSP_NODESTATECHANGE | DSP_NODEMESSAGEREADY))))
 
-#define IsValidStrmEvent(x)     (((x) == 0) || (((x) & (DSP_STREAMDONE | \
+#define IS_VALID_STRM_EVENT(x)     (((x) == 0) || (((x) & (DSP_STREAMDONE | \
 				DSP_STREAMIOCOMPLETION)) && \
 				!((x) & ~(DSP_STREAMDONE | \
 				DSP_STREAMIOCOMPLETION))))
 
-#define IsValidNotifyMask(x)   ((x) & DSP_SIGNALEVENT)
+#define IS_VALID_NOTIFY_MASK(x)   ((x) & DSP_SIGNALEVENT)
 
 /* The Node UUID structure */
-	struct DSP_UUID {
-		u32 ulData1;
-		u16 usData2;
-		u16 usData3;
-		u8 ucData4;
-		u8 ucData5;
-		u8 ucData6[6];
-	};
+struct dsp_uuid {
+	u32 ul_data1;
+	u16 us_data2;
+	u16 us_data3;
+	u8 uc_data4;
+	u8 uc_data5;
+	u8 uc_data6[6];
+};
 
 /* DCD types */
-	enum DSP_DCDOBJTYPE {
-		DSP_DCDNODETYPE,
-		DSP_DCDPROCESSORTYPE,
-		DSP_DCDLIBRARYTYPE,
-		DSP_DCDCREATELIBTYPE,
-		DSP_DCDEXECUTELIBTYPE,
-		DSP_DCDDELETELIBTYPE
-	} ;
+enum dsp_dcdobjtype {
+	DSP_DCDNODETYPE,
+	DSP_DCDPROCESSORTYPE,
+	DSP_DCDLIBRARYTYPE,
+	DSP_DCDCREATELIBTYPE,
+	DSP_DCDEXECUTELIBTYPE,
+	DSP_DCDDELETELIBTYPE,
+	/* DSP_DCDMAXOBJTYPE is meant to be the last DCD object type */
+	DSP_DCDMAXOBJTYPE
+};
 
 /* Processor states */
-	enum DSP_PROCSTATE {
-		PROC_STOPPED,
-		PROC_LOADED,
-		PROC_RUNNING,
-		PROC_ERROR
-	} ;
+enum dsp_procstate {
+	PROC_STOPPED,
+	PROC_LOADED,
+	PROC_RUNNING,
+	PROC_ERROR
+};
 
 /*
  *  Node types: Message node, task node, xDAIS socket node, and
@@ -234,310 +186,303 @@
  *  between a task or socket node and the GPP.
  *
  */
-	enum NODE_TYPE {
-		NODE_DEVICE,
-		NODE_TASK,
-		NODE_DAISSOCKET,
-		NODE_MESSAGE,
-		NODE_GPP
-	} ;
+enum node_type {
+	NODE_DEVICE,
+	NODE_TASK,
+	NODE_DAISSOCKET,
+	NODE_MESSAGE,
+	NODE_GPP
+};
 
 /*
- *  ======== NODE_STATE ========
+ *  ======== node_state ========
  *  Internal node states.
  */
-	enum NODE_STATE {
-		NODE_ALLOCATED,
-		NODE_CREATED,
-		NODE_RUNNING,
-		NODE_PAUSED,
-		NODE_DONE,
-		NODE_CREATING,
-		NODE_STARTING,
-		NODE_PAUSING,
-		NODE_TERMINATING,
-		NODE_DELETING,
-	} ;
+enum node_state {
+	NODE_ALLOCATED,
+	NODE_CREATED,
+	NODE_RUNNING,
+	NODE_PAUSED,
+	NODE_DONE,
+	NODE_CREATING,
+	NODE_STARTING,
+	NODE_PAUSING,
+	NODE_TERMINATING,
+	NODE_DELETING,
+};
 
 /* Stream states */
-	enum DSP_STREAMSTATE {
-		STREAM_IDLE,
-		STREAM_READY,
-		STREAM_PENDING,
-		STREAM_DONE
-	} ;
+enum dsp_streamstate {
+	STREAM_IDLE,
+	STREAM_READY,
+	STREAM_PENDING,
+	STREAM_DONE
+};
 
 /* Stream connect types */
-	enum DSP_CONNECTTYPE {
-		CONNECTTYPE_NODEOUTPUT,
-		CONNECTTYPE_GPPOUTPUT,
-		CONNECTTYPE_NODEINPUT,
-		CONNECTTYPE_GPPINPUT
-	} ;
+enum dsp_connecttype {
+	CONNECTTYPE_NODEOUTPUT,
+	CONNECTTYPE_GPPOUTPUT,
+	CONNECTTYPE_NODEINPUT,
+	CONNECTTYPE_GPPINPUT
+};
 
 /* Stream mode types */
-	enum DSP_STRMMODE {
-		STRMMODE_PROCCOPY, /* Processor(s) copy stream data payloads */
-		STRMMODE_ZEROCOPY, /* Strm buffer ptrs swapped no data copied */
-		STRMMODE_LDMA,	/* Local DMA : OMAP's System-DMA device */
-		STRMMODE_RDMA	/* Remote DMA: OMAP's DSP-DMA device */
-	} ;
+enum dsp_strmmode {
+	STRMMODE_PROCCOPY,	/* Processor(s) copy stream data payloads */
+	STRMMODE_ZEROCOPY,	/* Strm buffer ptrs swapped no data copied */
+	STRMMODE_LDMA,		/* Local DMA : OMAP's System-DMA device */
+	STRMMODE_RDMA		/* Remote DMA: OMAP's DSP-DMA device */
+};
 
 /* Resource Types */
-	enum DSP_RESOURCEINFOTYPE {
-		DSP_RESOURCE_DYNDARAM = 0,
-		DSP_RESOURCE_DYNSARAM,
-		DSP_RESOURCE_DYNEXTERNAL,
-		DSP_RESOURCE_DYNSRAM,
-		DSP_RESOURCE_PROCLOAD
-	} ;
+enum dsp_resourceinfotype {
+	DSP_RESOURCE_DYNDARAM = 0,
+	DSP_RESOURCE_DYNSARAM,
+	DSP_RESOURCE_DYNEXTERNAL,
+	DSP_RESOURCE_DYNSRAM,
+	DSP_RESOURCE_PROCLOAD
+};
 
 /* Memory Segment Types */
-	enum DSP_MEMTYPE {
-		DSP_DYNDARAM = 0,
-		DSP_DYNSARAM,
-		DSP_DYNEXTERNAL,
-		DSP_DYNSRAM
-	} ;
+enum dsp_memtype {
+	DSP_DYNDARAM = 0,
+	DSP_DYNSARAM,
+	DSP_DYNEXTERNAL,
+	DSP_DYNSRAM
+};
 
 /* Memory Flush Types */
-       enum DSP_FLUSHTYPE {
-		PROC_INVALIDATE_MEM = 0,
-		PROC_WRITEBACK_MEM,
-		PROC_WRITEBACK_INVALIDATE_MEM,
-	} ;
+enum dsp_flushtype {
+	PROC_INVALIDATE_MEM = 0,
+	PROC_WRITEBACK_MEM,
+	PROC_WRITEBACK_INVALIDATE_MEM,
+};
 
 /* Memory Segment Status Values */
-	struct DSP_MEMSTAT {
-		u32 ulSize;
-		u32 ulTotalFreeSize;
-		u32 ulLenMaxFreeBlock;
-		u32 ulNumFreeBlocks;
-		u32 ulNumAllocBlocks;
-	} ;
+struct dsp_memstat {
+	u32 ul_size;
+	u32 ul_total_free_size;
+	u32 ul_len_max_free_block;
+	u32 ul_num_free_blocks;
+	u32 ul_num_alloc_blocks;
+};
 
 /* Processor Load information Values */
-	 struct DSP_PROCLOADSTAT {
-		u32 uCurrLoad;
-		u32 uPredictedLoad;
-		u32 uCurrDspFreq;
-		u32 uPredictedFreq;
-	} ;
+struct dsp_procloadstat {
+	u32 curr_load;
+	u32 predicted_load;
+	u32 curr_dsp_freq;
+	u32 predicted_freq;
+};
 
 /* Attributes for STRM connections between nodes */
-	struct DSP_STRMATTR {
-		u32 uSegid;	/* Memory segment on DSP to allocate buffers */
-		u32 uBufsize;	/* Buffer size (DSP words) */
-		u32 uNumBufs;	/* Number of buffers */
-		u32 uAlignment;	/* Buffer alignment */
-		u32 uTimeout;	/* Timeout for blocking STRM calls */
-		enum DSP_STRMMODE lMode;	/* mode of stream when opened */
-		/* DMA chnl id if DSP_STRMMODE is LDMA or RDMA */
-		u32 uDMAChnlId;
-		u32 uDMAPriority;  /* DMA channel priority 0=lowest, >0=high */
-	} ;
-
-/* The DSP_CBDATA structure */
-	struct DSP_CBDATA {
-		u32 cbData;
-		u8 cData[1];
-	} ;
-
-/* The DSP_MSG structure */
-	struct DSP_MSG {
-		u32 dwCmd;
-		u32 dwArg1;
-		u32 dwArg2;
-	} ;
-
-/* The DSP_RESOURCEREQMTS structure for node's resource requirements  */
-	struct DSP_RESOURCEREQMTS {
-		u32 cbStruct;
-		u32 uStaticDataSize;
-		u32 uGlobalDataSize;
-		u32 uProgramMemSize;
-		u32 uWCExecutionTime;
-		u32 uWCPeriod;
-		u32 uWCDeadline;
-		u32 uAvgExectionTime;
-		u32 uMinimumPeriod;
-	} ;
+struct dsp_strmattr {
+	u32 seg_id;		/* Memory segment on DSP to allocate buffers */
+	u32 buf_size;		/* Buffer size (DSP words) */
+	u32 num_bufs;		/* Number of buffers */
+	u32 buf_alignment;	/* Buffer alignment */
+	u32 utimeout;		/* Timeout for blocking STRM calls */
+	enum dsp_strmmode strm_mode;	/* mode of stream when opened */
+	/* DMA chnl id if dsp_strmmode is LDMA or RDMA */
+	u32 udma_chnl_id;
+	u32 udma_priority;	/* DMA channel priority 0=lowest, >0=high */
+};
+
+/* The dsp_cbdata structure */
+struct dsp_cbdata {
+	u32 cb_data;
+	u8 node_data[1];
+};
+
+/* The dsp_msg structure */
+struct dsp_msg {
+	u32 dw_cmd;
+	u32 dw_arg1;
+	u32 dw_arg2;
+};
+
+/* The dsp_resourcereqmts structure for node's resource requirements */
+struct dsp_resourcereqmts {
+	u32 cb_struct;
+	u32 static_data_size;
+	u32 global_data_size;
+	u32 program_mem_size;
+	u32 uwc_execution_time;
+	u32 uwc_period;
+	u32 uwc_deadline;
+	u32 avg_exection_time;
+	u32 minimum_period;
+};
 
 /*
- * The DSP_STREAMCONNECT structure describes a stream connection
+ * The dsp_streamconnect structure describes a stream connection
  * between two nodes, or between a node and the GPP
  */
-	struct DSP_STREAMCONNECT {
-		u32 cbStruct;
-		enum DSP_CONNECTTYPE lType;
-		u32 uThisNodeStreamIndex;
-		DSP_HNODE hConnectedNode;
-		struct DSP_UUID uiConnectedNodeID;
-		u32 uConnectedNodeStreamIndex;
-	} ;
-
-	struct DSP_NODEPROFS {
-		u32 ulHeapSize;
-	} ;
-
-/* The DSP_NDBPROPS structure reports the attributes of a node */
-	struct DSP_NDBPROPS {
-		u32 cbStruct;
-		struct DSP_UUID uiNodeID;
-		char acName[DSP_MAXNAMELEN];
-		enum NODE_TYPE uNodeType;
-		u32 bCacheOnGPP;
-		struct DSP_RESOURCEREQMTS dspResourceReqmts;
-		s32 iPriority;
-		u32 uStackSize;
-		u32 uSysStackSize;
-		u32 uStackSeg;
-		u32 uMessageDepth;
-		u32 uNumInputStreams;
-		u32 uNumOutputStreams;
-		u32 uTimeout;
-		u32 uCountProfiles;	/* Number of supported profiles */
-		/* Array of profiles */
-		struct DSP_NODEPROFS aProfiles[MAX_PROFILES];
-		u32 uStackSegName; /* Stack Segment Name */
-	} ;
+struct dsp_streamconnect {
+	u32 cb_struct;
+	enum dsp_connecttype connect_type;
+	u32 this_node_stream_index;
+	void *connected_node;
+	struct dsp_uuid ui_connected_node_id;
+	u32 connected_node_stream_index;
+};
+
+struct dsp_nodeprofs {
+	u32 ul_heap_size;
+};
+
+/* The dsp_ndbprops structure reports the attributes of a node */
+struct dsp_ndbprops {
+	u32 cb_struct;
+	struct dsp_uuid ui_node_id;
+	char ac_name[DSP_MAXNAMELEN];
+	enum node_type ntype;
+	u32 cache_on_gpp;
+	struct dsp_resourcereqmts dsp_resource_reqmts;
+	s32 prio;
+	u32 stack_size;
+	u32 sys_stack_size;
+	u32 stack_seg;
+	u32 message_depth;
+	u32 num_input_streams;
+	u32 num_output_streams;
+	u32 utimeout;
+	u32 count_profiles;	/* Number of supported profiles */
+	/* Array of profiles */
+	struct dsp_nodeprofs node_profiles[MAX_PROFILES];
+	u32 stack_seg_name;	/* Stack Segment Name */
+};
 
-	/* The DSP_NODEATTRIN structure describes the attributes of a
+	/* The dsp_nodeattrin structure describes the attributes of a
 	 * node client */
-	struct DSP_NODEATTRIN {
-		u32 cbStruct;
-		s32 iPriority;
-		u32 uTimeout;
-		u32    uProfileID;
-		/* Reserved, for Bridge Internal use only */
-		u32    uHeapSize;
-		void *pGPPVirtAddr; /* Reserved, for Bridge Internal use only */
-	} ;
+struct dsp_nodeattrin {
+	u32 cb_struct;
+	s32 prio;
+	u32 utimeout;
+	u32 profile_id;
+	/* Reserved, for Bridge Internal use only */
+	u32 heap_size;
+	void *pgpp_virt_addr;	/* Reserved, for Bridge Internal use only */
+};
 
-	/* The DSP_NODEINFO structure is used to retrieve information
+	/* The dsp_nodeinfo structure is used to retrieve information
 	 * about a node */
-	struct DSP_NODEINFO {
-		u32 cbStruct;
-		struct DSP_NDBPROPS nbNodeDatabaseProps;
-		u32 uExecutionPriority;
-		enum NODE_STATE nsExecutionState;
-		DSP_HNODE hDeviceOwner;
-		u32 uNumberStreams;
-		struct DSP_STREAMCONNECT scStreamConnection[16];
-		u32 uNodeEnv;
-	} ;
-
-	/* The DSP_NODEATTR structure describes the attributes of a node */
-	struct DSP_NODEATTR {
-		u32 cbStruct;
-		struct DSP_NODEATTRIN inNodeAttrIn;
-		u32 uInputs;
-		u32 uOutputs;
-		struct DSP_NODEINFO iNodeInfo;
-	} ;
+struct dsp_nodeinfo {
+	u32 cb_struct;
+	struct dsp_ndbprops nb_node_database_props;
+	u32 execution_priority;
+	enum node_state ns_execution_state;
+	void *device_owner;
+	u32 number_streams;
+	struct dsp_streamconnect sc_stream_connection[16];
+	u32 node_env;
+};
+
+	/* The dsp_nodeattr structure describes the attributes of a node */
+struct dsp_nodeattr {
+	u32 cb_struct;
+	struct dsp_nodeattrin in_node_attr_in;
+	u32 node_attr_inputs;
+	u32 node_attr_outputs;
+	struct dsp_nodeinfo node_info;
+};
 
 /*
  *  Notification type: either the name of an opened event, or an event or
  *  window handle.
  */
-	struct DSP_NOTIFICATION {
-		char *psName;
-		HANDLE handle;
-	} ;
-
-/* The DSP_PROCESSORATTRIN structure describes the attributes of a processor */
-	struct DSP_PROCESSORATTRIN{
-		u32 cbStruct;
-		u32 uTimeout;
-	} ;
-
-	enum chipTypes {
-		DSPTYPE_55 = 6,
-		IVA_ARM7 = 0x97,
-		DSPTYPE_64 = 0x99
-	};
-
+struct dsp_notification {
+	char *ps_name;
+	bhandle handle;
+};
+
+/* The dsp_processorattrin structure describes the attributes of a processor */
+struct dsp_processorattrin {
+	u32 cb_struct;
+	u32 utimeout;
+};
 /*
- * The DSP_PROCESSORINFO structure describes basic capabilities of a
+ * The dsp_processorinfo structure describes basic capabilities of a
  * DSP processor
  */
-	struct DSP_PROCESSORINFO {
-		u32 cbStruct;
-		DSP_PROCFAMILY uProcessorFamily;
-		DSP_PROCTYPE uProcessorType;
-		u32 uClockRate;
-		u32 ulInternalMemSize;
-		u32 ulExternalMemSize;
-		u32 uProcessorID;
-		DSP_RTOSTYPE tyRunningRTOS;
-		s32 nNodeMinPriority;
-		s32 nNodeMaxPriority;
-	} ;
+struct dsp_processorinfo {
+	u32 cb_struct;
+	int processor_family;
+	int processor_type;
+	u32 clock_rate;
+	u32 ul_internal_mem_size;
+	u32 ul_external_mem_size;
+	u32 processor_id;
+	int ty_running_rtos;
+	s32 node_min_priority;
+	s32 node_max_priority;
+};
 
 /* Error information of last DSP exception signalled to the GPP */
-	struct DSP_ERRORINFO {
-		u32 dwErrMask;
-		u32 dwVal1;
-		u32 dwVal2;
-		u32 dwVal3;
-	} ;
-
-/* The DSP_PROCESSORSTATE structure describes the state of a DSP processor */
-	struct DSP_PROCESSORSTATE {
-		u32 cbStruct;
-		enum DSP_PROCSTATE iState;
-		struct DSP_ERRORINFO errInfo;
-	} ;
+struct dsp_errorinfo {
+	u32 dw_err_mask;
+	u32 dw_val1;
+	u32 dw_val2;
+	u32 dw_val3;
+};
+
+/* The dsp_processorstate structure describes the state of a DSP processor */
+struct dsp_processorstate {
+	u32 cb_struct;
+	enum dsp_procstate proc_state;
+	struct dsp_errorinfo err_info;
+};
 
 /*
- * The DSP_RESOURCEINFO structure is used to retrieve information about a
+ * The dsp_resourceinfo structure is used to retrieve information about a
  * processor's resources
  */
-	struct DSP_RESOURCEINFO {
-		u32 cbStruct;
-		enum DSP_RESOURCEINFOTYPE uResourceType;
-		union {
-			u32 ulResource;
-			struct DSP_MEMSTAT memStat;
-			struct DSP_PROCLOADSTAT procLoadStat;
-		} result;
-	} ;
+struct dsp_resourceinfo {
+	u32 cb_struct;
+	enum dsp_resourceinfotype resource_type;
+	union {
+		u32 ul_resource;
+		struct dsp_memstat mem_stat;
+		struct dsp_procloadstat proc_load_stat;
+	} result;
+};
 
 /*
- * The DSP_STREAMATTRIN structure describes the attributes of a stream,
+ * The dsp_streamattrin structure describes the attributes of a stream,
  * including segment and alignment of data buffers allocated with
  * DSPStream_AllocateBuffers(), if applicable
  */
-	struct DSP_STREAMATTRIN {
-		u32 cbStruct;
-		u32 uTimeout;
-		u32 uSegment;
-		u32 uAlignment;
-		u32 uNumBufs;
-		enum DSP_STRMMODE lMode;
-		u32 uDMAChnlId;
-		u32 uDMAPriority;
-	} ;
-
-/* The DSP_BUFFERATTR structure describes the attributes of a data buffer */
-	struct DSP_BUFFERATTR {
-		u32 cbStruct;
-		u32 uSegment;
-		u32 uAlignment;
-	} ;
+struct dsp_streamattrin {
+	u32 cb_struct;
+	u32 utimeout;
+	u32 segment_id;
+	u32 buf_alignment;
+	u32 num_bufs;
+	enum dsp_strmmode strm_mode;
+	u32 udma_chnl_id;
+	u32 udma_priority;
+};
+
+/* The dsp_bufferattr structure describes the attributes of a data buffer */
+struct dsp_bufferattr {
+	u32 cb_struct;
+	u32 segment_id;
+	u32 buf_alignment;
+};
 
 /*
- *  The DSP_STREAMINFO structure is used to retrieve information
+ *  The dsp_streaminfo structure is used to retrieve information
  *  about a stream.
  */
-	struct DSP_STREAMINFO {
-		u32 cbStruct;
-		u32 uNumberBufsAllowed;
-		u32 uNumberBufsInStream;
-		u32 ulNumberBytes;
-		HANDLE hSyncObjectHandle;
-		enum DSP_STREAMSTATE ssStreamState;
-	} ;
+struct dsp_streaminfo {
+	u32 cb_struct;
+	u32 number_bufs_allowed;
+	u32 number_bufs_in_stream;
+	u32 ul_number_bytes;
+	bhandle sync_object_handle;
+	enum dsp_streamstate ss_stream_state;
+};
 
 /* DMM MAP attributes
 It is a bit mask with each bit value indicating a specific attribute
@@ -548,6 +493,9 @@
 bit 4 - MMU element size = 16bit (valid only for non mixed page entries)
 bit 5 - MMU element size = 32bit (valid only for non mixed page entries)
 bit 6 - MMU element size = 64bit (valid only for non mixed page entries)
+
+bit 14 - Input (read only) buffer
+bit 15 - Output (writeable) buffer
 */
 
 /* Types of mapping attributes */
@@ -576,8 +524,34 @@
 
 #define DSP_MAPDONOTLOCK	   0x00000100
 
+#define DSP_MAP_DIR_MASK		0x3FFF
 
 #define GEM_CACHE_LINE_SIZE     128
 #define GEM_L1P_PREFETCH_SIZE   128
 
-#endif				/* DBDEFS_ */
+/*
+ * Definitions from dbreg.h
+ */
+
+#define DSPPROCTYPE_C64		6410
+#define IVAPROCTYPE_ARM7	470
+
+#define REG_MGR_OBJECT	1
+#define REG_DRV_OBJECT	2
+
+/* registry */
+#define DRVOBJECT	"DrvObject"
+#define MGROBJECT	"MgrObject"
+
+/* Max registry path length. Also the max registry value length. */
+#define MAXREGPATHLENGTH	255
+
+/* MiniDriver related definitions */
+#define DEFEXEC		"DefaultExecutable"	/* Default executable */
+#define AUTOSTART	"AutoStart"	/* Statically load flag */
+#define CURRENTCONFIG	"CurrentConfig"	/* Current resources */
+#define SHMSIZE		"SHMSize"	/* Size of shm reservd on MPU */
+#define TCWORDSWAP	"TCWordSwap"	/* Traffic Controller WordSwp */
+#define DSPRESOURCES	"DspTMSResources"	/* C55 DSP resurces on OMAP */
+
+#endif /* DBDEFS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbg.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbg.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbg.h	2011-10-11 13:50:57.495200500 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbg.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,110 +0,0 @@
-/*
- * dbg.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== dbg.h ========
- *  Purpose:
- *      Provide debugging services for 'Bridge Mini Drivers.
- *
- *  Public Functions:
- *      DBG_Exit
- *      DBG_Init
- *      DBG_Printf
- *      DBG_Trace
- *
- *  Notes:
- *      WMD's must not call DBG_Init or DBG_Exit.
- *
- *! Revision History:
- *! ================
- *! 03-Feb-2000 rr: DBG Levels redefined.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 10-Oct-1997 cr: Added DBG_Printf service.
- *! 29-May-1996 gp: Removed WCD_ prefix.
- *! 15-May-1996 gp: Created.
- */
-
-#ifndef DBG_
-#define DBG_
-#include <dspbridge/host_os.h>
-#include <linux/types.h>
-
-/* Levels of trace debug messages: */
-#define DBG_ENTER   (u8)(0x01)	/* Function entry point. */
-#define DBG_LEVEL1  (u8)(0x02)	/* Display debugging state/varibles */
-#define DBG_LEVEL2  (u8)(0x04)	/* Display debugging state/varibles */
-#define DBG_LEVEL3  (u8)(0x08)	/* Display debugging state/varibles */
-#define DBG_LEVEL4  (u8)(0x10)	/* Display debugging state/varibles */
-#define DBG_LEVEL5  (u8)(0x20)	/* Module Init, Exit */
-#define DBG_LEVEL6  (u8)(0x40)	/* Warn SERVICES Failures */
-#define DBG_LEVEL7  (u8)(0x80)	/* Warn Critical Errors */
-
-#if (defined(DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE
-
-/*
- *  ======== DBG_Exit ========
- *  Purpose:
- *      Discontinue usage of module; free resources when reference count
- *      reaches 0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      DBG initialized.
- *  Ensures:
- *      Resources used by module are freed when cRef reaches zero.
- */
-	extern void DBG_Exit(void);
-
-/*
- *  ======== DBG_Init ========
- *  Purpose:
- *      Initializes private state of DBG module.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- */
-	extern bool DBG_Init(void);
-
-/*
- *  ======== DBG_Trace ========
- *  Purpose:
- *      Output a trace message to the debugger, if the given trace level
- *      is unmasked.
- *  Parameters:
- *      bLevel:         Trace level.
- *      pstrFormat:     sprintf-style format string.
- *      ...:            Arguments for format string.
- *  Returns:
- *      DSP_SOK:        Success, or trace level masked.
- *      DSP_EFAIL:      On Error.
- *  Requires:
- *      DBG initialized.
- *  Ensures:
- *      Debug message is printed to debugger output window, if trace level
- *      is unmasked.
- */
-	extern DSP_STATUS DBG_Trace(IN u8 bLevel, IN char *pstrFormat, ...);
-#else
-
-#define DBG_Exit(void) do {} while (0)
-#define DBG_Init(void) true
-#define DBG_Trace(bLevel, pstrFormat, args...) do {} while (0)
-
-#endif	     /* (defined(DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE */
-
-#endif				/* DBG_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbldefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbldefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbldefs.h	2011-10-11 13:50:57.495200500 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbldefs.h	2011-08-19 18:42:45.000000000 +0100
@@ -14,21 +14,11 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dbldefs.h ========
- *
- *! Revision History
- *! ================
- *! 19-Mar-2002 jeh     Added DBL_Fxns type (to make it easier to switch
- *!                     between different loaders).
- *! 28-Sep-2001 jeh     Created from zl.h.
- */
 #ifndef DBLDEFS_
 #define DBLDEFS_
 
 /*
- *  Bit masks for DBL_Flags.
+ *  Bit masks for dbl_flags.
  */
 #define DBL_NOLOAD   0x0	/* Don't load symbols, code, or data */
 #define DBL_SYMB     0x1	/* load symbols */
@@ -39,70 +29,66 @@
 
 #define DBL_MAXPATHLENGTH       255
 
-
-
 /*
- *  ======== DBL_Flags ========
+ *  ======== dbl_flags ========
  *  Specifies whether to load code, data, or symbols
  */
-typedef s32 DBL_Flags;
+typedef s32 dbl_flags;
 
 /*
- *  ======== DBL_SectInfo ========
+ *  ======== dbl_sect_info ========
  *  For collecting info on overlay sections
  */
-struct DBL_SectInfo {
+struct dbl_sect_info {
 	const char *name;	/* name of section */
-	u32 runAddr;		/* run address of section */
-	u32 loadAddr;		/* load address of section */
+	u32 sect_run_addr;	/* run address of section */
+	u32 sect_load_addr;	/* load address of section */
 	u32 size;		/* size of section (target MAUs) */
-	DBL_Flags type;		/* Code, data, or BSS */
-} ;
+	dbl_flags type;		/* Code, data, or BSS */
+};
 
 /*
- *  ======== DBL_Symbol ========
+ *  ======== dbl_symbol ========
  *  (Needed for dynamic load library)
  */
-struct DBL_Symbol {
+struct dbl_symbol {
 	u32 value;
 };
 
 /*
- *  ======== DBL_AllocFxn ========
+ *  ======== dbl_alloc_fxn ========
  *  Allocate memory function.  Allocate or reserve (if reserved == TRUE)
  *  "size" bytes of memory from segment "space" and return the address in
  *  *dspAddr (or starting at *dspAddr if reserve == TRUE). Returns 0 on
  *  success, or an error code on failure.
  */
-typedef s32(*DBL_AllocFxn) (void *hdl, s32 space, u32 size, u32 align,
-			u32 *dspAddr, s32 segId, s32 req, bool reserved);
-
-
+typedef s32(*dbl_alloc_fxn) (void *hdl, s32 space, u32 size, u32 align,
+			     u32 *dspAddr, s32 seg_id, s32 req, bool reserved);
 
 /*
- *  ======== DBL_FreeFxn ========
+ *  ======== dbl_free_fxn ========
  *  Free memory function.  Free, or unreserve (if reserved == TRUE) "size"
  *  bytes of memory from segment "space"
  */
-typedef bool(*DBL_FreeFxn) (void *hdl, u32 addr, s32 space, u32 size,
-			    bool reserved);
+typedef bool(*dbl_free_fxn) (void *hdl, u32 addr, s32 space, u32 size,
+			     bool reserved);
 
 /*
- *  ======== DBL_LogWriteFxn ========
+ *  ======== dbl_log_write_fxn ========
  *  Function to call when writing data from a section, to log the info.
  *  Can be NULL if no logging is required.
  */
-typedef DSP_STATUS(*DBL_LogWriteFxn) (void *handle, struct DBL_SectInfo *sect,
-				      u32 addr, u32 nBytes);
-
+typedef dsp_status(*dbl_log_write_fxn) (void *handle,
+					struct dbl_sect_info *sect, u32 addr,
+					u32 bytes);
 
 /*
- *  ======== DBL_SymLookup ========
+ *  ======== dbl_sym_lookup ========
  *  Symbol lookup function - Find the symbol name and return its value.
  *
  *  Parameters:
  *      handle          - Opaque handle
- *      pArg            - Opaque argument.
+ *      parg            - Opaque argument.
  *      name            - Name of symbol to lookup.
  *      sym             - Location to store address of symbol structure.
  *
@@ -110,46 +96,45 @@
  *      TRUE:           Success (symbol was found).
  *      FALSE:          Failed to find symbol.
  */
-typedef bool(*DBL_SymLookup) (void *handle, void *pArg, void *rmmHandle,
-			      const char *name, struct DBL_Symbol **sym);
-
+typedef bool(*dbl_sym_lookup) (void *handle, void *parg, void *rmm_handle,
+			       const char *name, struct dbl_symbol ** sym);
 
 /*
- *  ======== DBL_WriteFxn ========
+ *  ======== dbl_write_fxn ========
  *  Write memory function.  Write "n" HOST bytes of memory to segment "mtype"
  *  starting at address "dspAddr" from the buffer "buf".  The buffer is
  *  formatted as an array of words appropriate for the DSP.
  */
-typedef s32(*DBL_WriteFxn) (void *hdl, u32 dspAddr, void *buf,
-			    u32 n, s32 mtype);
+typedef s32(*dbl_write_fxn) (void *hdl, u32 dspAddr, void *buf,
+			     u32 n, s32 mtype);
 
 /*
- *  ======== DBL_Attrs ========
+ *  ======== dbl_attrs ========
  */
-struct DBL_Attrs {
-	DBL_AllocFxn alloc;
-	DBL_FreeFxn free;
-	void *rmmHandle;	/* Handle to pass to alloc, free functions */
-	DBL_WriteFxn write;
-	void *wHandle;		/* Handle to pass to write, cinit function */
+struct dbl_attrs {
+	dbl_alloc_fxn alloc;
+	dbl_free_fxn free;
+	void *rmm_handle;	/* Handle to pass to alloc, free functions */
+	dbl_write_fxn write;
+	void *input_params;	/* Handle to pass to write, cinit function */
 
-	DBL_LogWriteFxn logWrite;
-	void *logWriteHandle;
+	dbl_log_write_fxn log_write;
+	void *log_write_handle;
 
 	/* Symbol matching function and handle to pass to it */
-	DBL_SymLookup symLookup;
-	void *symHandle;
-	void *symArg;
+	dbl_sym_lookup sym_lookup;
+	void *sym_handle;
+	void *sym_arg;
 
 	/*
 	 *  These file manipulation functions should be compatible with the
 	 *  "C" run time library functions of the same name.
 	 */
-	s32(*fread) (void *, size_t, size_t, void *);
-	s32(*fseek) (void *, long, int);
-	s32(*ftell) (void *);
-	s32(*fclose) (void *);
+	 s32(*fread) (void *, size_t, size_t, void *);
+	 s32(*fseek) (void *, long, int);
+	 s32(*ftell) (void *);
+	 s32(*fclose) (void *);
 	void *(*fopen) (const char *, const char *);
-} ;
+};
 
-#endif				/* DBLDEFS_ */
+#endif /* DBLDEFS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbl.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbl.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbl.h	2011-10-11 13:50:57.505213641 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbl.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,354 +0,0 @@
-/*
- * dbl.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dbl.h ========
- *
- *! Revision History
- *! ================
- *! 19-Mar-2002 jeh     Pass DBL_Symbol pointer to DBL_getAddr, DBL_getCAddr
- *!                     to accomodate dynamic loader library.
- *! 20-Nov-2001 jeh     Removed DBL_loadArgs().
- *! 24-Sep-2001 jeh     Code review changes.
- *! 07-Sep-2001 jeh     Added DBL_LoadSect(), DBL_UnloadSect().
- *! 05-Jun-2001 jeh     Created based on zl.h.
- */
-
-#ifndef DBL_
-#define DBL_
-
-#include <dspbridge/dbdefs.h>
-#include <dspbridge/dbldefs.h>
-
-/*
- *  ======== DBL_close ========
- *  Close library opened with DBL_open.
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *  Ensures:
- */
-	extern void DBL_close(struct DBL_LibraryObj *lib);
-
-/*
- *  ======== DBL_create ========
- *  Create a target object by specifying the alloc, free, and write
- *  functions for the target.
- *  Parameters:
- *      pTarget         - Location to store target handle on output.
- *      pAttrs          - Attributes.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Memory allocation failed.
- *  Requires:
- *      DBL initialized.
- *      pAttrs != NULL.
- *      pTarget != NULL;
- *  Ensures:
- *      Success:        *pTarget != NULL.
- *      Failure:        *pTarget == NULL.
- */
-	extern DSP_STATUS DBL_create(struct DBL_TargetObj **pTarget,
-				     struct DBL_Attrs *pAttrs);
-
-/*
- *  ======== DBL_delete ========
- *  Delete target object and free resources for any loaded libraries.
- *  Parameters:
- *      target          - Handle returned from DBL_Create().
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *  Ensures:
- */
-	extern void DBL_delete(struct DBL_TargetObj *target);
-
-/*
- *  ======== DBL_exit ========
- *  Discontinue use of DBL module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      cRefs > 0.
- *  Ensures:
- *      cRefs >= 0.
- */
-	extern void DBL_exit(void);
-
-/*
- *  ======== DBL_getAddr ========
- *  Get address of name in the specified library.
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      name            - Name of symbol
- *      ppSym           - Location to store symbol address on output.
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Symbol not found.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      name != NULL.
- *      pAddr != NULL.
- *  Ensures:
- */
-	extern bool DBL_getAddr(struct DBL_LibraryObj *lib, char *name,
-				struct DBL_Symbol **ppSym);
-
-/*
- *  ======== DBL_getAttrs ========
- *  Retrieve the attributes of the target.
- *  Parameters:
- *      target          - Handle returned from DBL_Create().
- *      pAttrs          - Location to store attributes on output.
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *      pAttrs != NULL.
- *  Ensures:
- */
-	extern void DBL_getAttrs(struct DBL_TargetObj *target,
-				 struct DBL_Attrs *pAttrs);
-
-/*
- *  ======== DBL_getCAddr ========
- *  Get address of "C" name in the specified library.
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      name            - Name of symbol
- *      ppSym           - Location to store symbol address on output.
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Symbol not found.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      name != NULL.
- *      pAddr != NULL.
- *  Ensures:
- */
-	extern bool DBL_getCAddr(struct DBL_LibraryObj *lib, char *name,
-				 struct DBL_Symbol **ppSym);
-
-/*
- *  ======== DBL_getEntry ========
- *  Get program entry point.
- *
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      pEntry          - Location to store entry address on output.
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Failure.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      pEntry != NULL.
- *  Ensures:
- */
-	extern bool DBL_getEntry(struct DBL_LibraryObj *lib, u32 *pEntry);
-
-/*
- *  ======== DBL_getSect ========
- *  Get address and size of a named section.
- *  Parameters:
- *      lib             - Library handle returned from DBL_open().
- *      name            - Name of section.
- *      pAddr           - Location to store section address on output.
- *      pSize           - Location to store section size on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Section not found.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      name != NULL.
- *      pAddr != NULL;
- *      pSize != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DBL_getSect(struct DBL_LibraryObj *lib, char *name,
-				      u32 *pAddr, u32 *pSize);
-
-/*
- *  ======== DBL_init ========
- *  Initialize DBL module.
- *  Parameters:
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Failure.
- *  Requires:
- *      cRefs >= 0.
- *  Ensures:
- *      Success:        cRefs > 0.
- *      Failure:        cRefs >= 0.
- */
-	extern bool DBL_init(void);
-
-/*
- *  ======== DBL_load ========
- *  Add symbols/code/data defined in file to that already present on
- *  the target.
- *
- *  Parameters:
- *      lib             - Library handle returned from DBL_open().
- *      flags           - Specifies whether loading code, data, and/or symbols.
- *      attrs           - May contain write, alloc, and free functions.
- *      pulEntry        - Location to store program entry on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFREAD:     File read failed.
- *      DSP_EFWRITE:    Write to target failed.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      pEntry != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DBL_load(struct DBL_LibraryObj *lib, DBL_Flags flags,
-				   struct DBL_Attrs *attrs, u32 *pEntry);
-
-/*
- *  ======== DBL_loadSect ========
- *  Load a named section from an library (for overlay support).
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      sectName        - Name of section to load.
- *      attrs           - Contains write function and handle to pass to it.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Section not found.
- *      DSP_EFWRITE:    Write function failed.
- *  Requires:
- *      Valid lib.
- *      sectName != NULL.
- *      attrs != NULL.
- *      attrs->write != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DBL_loadSect(struct DBL_LibraryObj *lib,
-				       char *sectName,
-				       struct DBL_Attrs *attrs);
-
-/*
- *  ======== DBL_open ========
- *  DBL_open() returns a library handle that can be used to load/unload
- *  the symbols/code/data via DBL_load()/DBL_unload().
- *  Parameters:
- *      target          - Handle returned from DBL_create().
- *      file            - Name of file to open.
- *      flags           - Specifies whether to load symbols now.
- *      pLib            - Location to store library handle on output.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EMEMORY:        Memory allocation failure.
- *      DSP_EFOPEN:         File open failure.
- *      DSP_EFREAD:         File read failure.
- *      DSP_ECORRUPTFILE:   Unable to determine target type.
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *      file != NULL.
- *      pLib != NULL.
- *      struct DBL_Attrs fopen function non-NULL.
- *  Ensures:
- *      Success:        Valid *pLib.
- *      Failure:        *pLib == NULL.
- */
-	extern DSP_STATUS DBL_open(struct DBL_TargetObj *target, char *file,
-				   DBL_Flags flags,
-				   struct DBL_LibraryObj **pLib);
-
-/*
- *  ======== DBL_readSect ========
- *  Read COFF section into a character buffer.
- *  Parameters:
- *      lib             - Library handle returned from DBL_open().
- *      name            - Name of section.
- *      pBuf            - Buffer to write section contents into.
- *      size            - Buffer size
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Named section does not exists.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      name != NULL.
- *      pBuf != NULL.
- *      size != 0.
- *  Ensures:
- */
-	extern DSP_STATUS DBL_readSect(struct DBL_LibraryObj *lib, char *name,
-				       char *pBuf, u32 size);
-
-/*
- *  ======== DBL_setAttrs ========
- *  Set the attributes of the target.
- *  Parameters:
- *      target          - Handle returned from DBL_create().
- *      pAttrs          - New attributes.
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *      pAttrs != NULL.
- *  Ensures:
- */
-	extern void DBL_setAttrs(struct DBL_TargetObj *target,
-				 struct DBL_Attrs *pAttrs);
-
-/*
- *  ======== DBL_unload ========
- *  Remove the symbols/code/data corresponding to the library lib.
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      attrs           - Contains free() function and handle to pass to it.
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *  Ensures:
- */
-	extern void DBL_unload(struct DBL_LibraryObj *lib,
-			       struct DBL_Attrs *attrs);
-
-/*
- *  ======== DBL_unloadSect ========
- *  Unload a named section from an library (for overlay support).
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      sectName        - Name of section to load.
- *      attrs           - Contains free() function and handle to pass to it.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Named section not found.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      sectName != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DBL_unloadSect(struct DBL_LibraryObj *lib,
-					 char *sectName,
-					 struct DBL_Attrs *attrs);
-
-#endif				/* DBL_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dblldefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dblldefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dblldefs.h	2011-10-11 13:50:57.513715541 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dblldefs.h	2011-08-19 18:42:45.000000000 +0100
@@ -14,22 +14,11 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dblldefs.h ========
- *
- *! Revision History
- *! ================
- *! 08-Apr-2003 map	    Consolidated DBL into DBLL name
- *! 19-Mar-2002 jeh     Added DBL_Fxns type (to make it easier to switch
- *!                     between different loaders).
- *! 28-Sep-2001 jeh     Created from zl.h.
- */
 #ifndef DBLLDEFS_
 #define DBLLDEFS_
 
 /*
- *  Bit masks for DBL_Flags.
+ *  Bit masks for dbl_flags.
  */
 #define DBLL_NOLOAD   0x0	/* Don't load symbols, code, or data */
 #define DBLL_SYMB     0x1	/* load symbols */
@@ -40,99 +29,99 @@
 
 #define DBLL_MAXPATHLENGTH       255
 
-
 /*
  *  ======== DBLL_Target ========
  *
  */
-struct DBLL_TarObj;
+struct dbll_tar_obj;
 
 /*
- *  ======== DBLL_Flags ========
+ *  ======== dbll_flags ========
  *  Specifies whether to load code, data, or symbols
  */
-typedef s32 DBLL_Flags;
+typedef s32 dbll_flags;
 
 /*
  *  ======== DBLL_Library ========
  *
  */
-struct DBLL_LibraryObj;
+struct dbll_library_obj;
 
 /*
- *  ======== DBLL_SectInfo ========
+ *  ======== dbll_sect_info ========
  *  For collecting info on overlay sections
  */
-struct DBLL_SectInfo {
+struct dbll_sect_info {
 	const char *name;	/* name of section */
-	u32 runAddr;		/* run address of section */
-	u32 loadAddr;		/* load address of section */
+	u32 sect_run_addr;	/* run address of section */
+	u32 sect_load_addr;	/* load address of section */
 	u32 size;		/* size of section (target MAUs) */
-	DBLL_Flags type;	/* Code, data, or BSS */
-} ;
+	dbll_flags type;	/* Code, data, or BSS */
+};
 
 /*
- *  ======== DBLL_Symbol ========
+ *  ======== dbll_sym_val ========
  *  (Needed for dynamic load library)
  */
-struct DBLL_Symbol {
+struct dbll_sym_val {
 	u32 value;
 };
 
 /*
- *  ======== DBLL_AllocFxn ========
+ *  ======== dbll_alloc_fxn ========
  *  Allocate memory function.  Allocate or reserve (if reserved == TRUE)
  *  "size" bytes of memory from segment "space" and return the address in
  *  *dspAddr (or starting at *dspAddr if reserve == TRUE). Returns 0 on
  *  success, or an error code on failure.
  */
-typedef s32(*DBLL_AllocFxn) (void *hdl, s32 space, u32 size, u32 align,
-			     u32 *dspAddr, s32 segId, s32 req,
-			     bool reserved);
+typedef s32(*dbll_alloc_fxn) (void *hdl, s32 space, u32 size, u32 align,
+			      u32 *dspAddr, s32 seg_id, s32 req,
+			      bool reserved);
 
 /*
- *  ======== DBLL_CloseFxn ========
+ *  ======== dbll_close_fxn ========
  */
-typedef s32(*DBLL_FCloseFxn) (void *);
+typedef s32(*dbll_f_close_fxn) (void *);
 
 /*
- *  ======== DBLL_FreeFxn ========
+ *  ======== dbll_free_fxn ========
  *  Free memory function.  Free, or unreserve (if reserved == TRUE) "size"
  *  bytes of memory from segment "space"
  */
-typedef bool(*DBLL_FreeFxn) (void *hdl, u32 addr, s32 space, u32 size,
-			     bool reserved);
+typedef bool(*dbll_free_fxn) (void *hdl, u32 addr, s32 space, u32 size,
+			      bool reserved);
 
 /*
- *  ======== DBLL_FOpenFxn ========
+ *  ======== dbll_f_open_fxn ========
  */
-typedef void *(*DBLL_FOpenFxn) (const char *, const char *);
+typedef void *(*dbll_f_open_fxn) (const char *, const char *);
 
 /*
- *  ======== DBLL_LogWriteFxn ========
+ *  ======== dbll_log_write_fxn ========
  *  Function to call when writing data from a section, to log the info.
  *  Can be NULL if no logging is required.
  */
-typedef DSP_STATUS(*DBLL_LogWriteFxn)(void *handle, struct DBLL_SectInfo *sect,
-				       u32 addr, u32 nBytes);
+typedef dsp_status(*dbll_log_write_fxn) (void *handle,
+					 struct dbll_sect_info *sect, u32 addr,
+					 u32 bytes);
 
 /*
- *  ======== DBLL_ReadFxn ========
+ *  ======== dbll_read_fxn ========
  */
-typedef s32(*DBLL_ReadFxn) (void *, size_t, size_t, void *);
+typedef s32(*dbll_read_fxn) (void *, size_t, size_t, void *);
 
 /*
- *  ======== DBLL_SeekFxn ========
+ *  ======== dbll_seek_fxn ========
  */
-typedef s32(*DBLL_SeekFxn) (void *, long, int);
+typedef s32(*dbll_seek_fxn) (void *, long, int);
 
 /*
- *  ======== DBLL_SymLookup ========
+ *  ======== dbll_sym_lookup ========
  *  Symbol lookup function - Find the symbol name and return its value.
  *
  *  Parameters:
  *      handle          - Opaque handle
- *      pArg            - Opaque argument.
+ *      parg            - Opaque argument.
  *      name            - Name of symbol to lookup.
  *      sym             - Location to store address of symbol structure.
  *
@@ -140,40 +129,40 @@
  *      TRUE:           Success (symbol was found).
  *      FALSE:          Failed to find symbol.
  */
-typedef bool(*DBLL_SymLookup) (void *handle, void *pArg, void *rmmHandle,
-			       const char *name, struct DBLL_Symbol **sym);
+typedef bool(*dbll_sym_lookup) (void *handle, void *parg, void *rmm_handle,
+				const char *name, struct dbll_sym_val ** sym);
 
 /*
- *  ======== DBLL_TellFxn ========
+ *  ======== dbll_tell_fxn ========
  */
-typedef s32(*DBLL_TellFxn) (void *);
+typedef s32(*dbll_tell_fxn) (void *);
 
 /*
- *  ======== DBLL_WriteFxn ========
+ *  ======== dbll_write_fxn ========
  *  Write memory function.  Write "n" HOST bytes of memory to segment "mtype"
  *  starting at address "dspAddr" from the buffer "buf".  The buffer is
  *  formatted as an array of words appropriate for the DSP.
  */
-typedef s32(*DBLL_WriteFxn) (void *hdl, u32 dspAddr, void *buf,
-			     u32 n, s32 mtype);
+typedef s32(*dbll_write_fxn) (void *hdl, u32 dspAddr, void *buf,
+			      u32 n, s32 mtype);
 
 /*
- *  ======== DBLL_Attrs ========
+ *  ======== dbll_attrs ========
  */
-struct DBLL_Attrs {
-	DBLL_AllocFxn alloc;
-	DBLL_FreeFxn free;
-	void *rmmHandle;	/* Handle to pass to alloc, free functions */
-	DBLL_WriteFxn write;
-	void *wHandle;		/* Handle to pass to write, cinit function */
-	bool baseImage;
-	DBLL_LogWriteFxn logWrite;
-	void *logWriteHandle;
+struct dbll_attrs {
+	dbll_alloc_fxn alloc;
+	dbll_free_fxn free;
+	void *rmm_handle;	/* Handle to pass to alloc, free functions */
+	dbll_write_fxn write;
+	void *input_params;	/* Handle to pass to write, cinit function */
+	bool base_image;
+	dbll_log_write_fxn log_write;
+	void *log_write_handle;
 
 	/* Symbol matching function and handle to pass to it */
-	DBLL_SymLookup symLookup;
-	void *symHandle;
-	void *symArg;
+	dbll_sym_lookup sym_lookup;
+	void *sym_handle;
+	void *sym_arg;
 
 	/*
 	 *  These file manipulation functions should be compatible with the
@@ -184,43 +173,43 @@
 	 s32(*ftell) (void *);
 	 s32(*fclose) (void *);
 	void *(*fopen) (const char *, const char *);
-} ;
+};
 
 /*
- *  ======== DBLL_close ========
- *  Close library opened with DBLL_open.
+ *  ======== dbll_close ========
+ *  Close library opened with dbll_open.
  *  Parameters:
- *      lib             - Handle returned from DBLL_open().
+ *      lib             - Handle returned from dbll_open().
  *  Returns:
  *  Requires:
  *      DBL initialized.
  *      Valid lib.
  *  Ensures:
  */
-typedef void(*DBLL_CloseFxn) (struct DBLL_LibraryObj *library);
+typedef void (*dbll_close_fxn) (struct dbll_library_obj *library);
 
 /*
- *  ======== DBLL_create ========
+ *  ======== dbll_create ========
  *  Create a target object, specifying the alloc, free, and write functions.
  *  Parameters:
- *      pTarget         - Location to store target handle on output.
- *      pAttrs          - Attributes.
+ *      target_obj         - Location to store target handle on output.
+ *      pattrs          - Attributes.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Memory allocation failed.
  *  Requires:
  *      DBL initialized.
- *      pAttrs != NULL.
- *      pTarget != NULL;
+ *      pattrs != NULL.
+ *      target_obj != NULL;
  *  Ensures:
- *      Success:        *pTarget != NULL.
- *      Failure:        *pTarget == NULL.
+ *      Success:        *target_obj != NULL.
+ *      Failure:        *target_obj == NULL.
  */
-typedef DSP_STATUS(*DBLL_CreateFxn)(struct DBLL_TarObj **pTarget,
-				    struct DBLL_Attrs *attrs);
+typedef dsp_status(*dbll_create_fxn) (struct dbll_tar_obj **target_obj,
+				      struct dbll_attrs *attrs);
 
 /*
- *  ======== DBLL_delete ========
+ *  ======== dbll_delete ========
  *  Delete target object and free resources for any loaded libraries.
  *  Parameters:
  *      target          - Handle returned from DBLL_Create().
@@ -230,25 +219,25 @@
  *      Valid target.
  *  Ensures:
  */
-typedef void(*DBLL_DeleteFxn) (struct DBLL_TarObj *target);
+typedef void (*dbll_delete_fxn) (struct dbll_tar_obj *target);
 
 /*
- *  ======== DBLL_exit ========
+ *  ======== dbll_exit ========
  *  Discontinue use of DBL module.
  *  Parameters:
  *  Returns:
  *  Requires:
- *      cRefs > 0.
+ *      refs > 0.
  *  Ensures:
- *      cRefs >= 0.
+ *      refs >= 0.
  */
-typedef void(*DBLL_ExitFxn) (void);
+typedef void (*dbll_exit_fxn) (void);
 
 /*
- *  ======== DBLL_getAddr ========
+ *  ======== dbll_get_addr ========
  *  Get address of name in the specified library.
  *  Parameters:
- *      lib             - Handle returned from DBLL_open().
+ *      lib             - Handle returned from dbll_open().
  *      name            - Name of symbol
  *      ppSym           - Location to store symbol address on output.
  *  Returns:
@@ -261,30 +250,30 @@
  *      ppSym != NULL.
  *  Ensures:
  */
-typedef bool(*DBLL_GetAddrFxn) (struct DBLL_LibraryObj *lib, char *name,
-				struct DBLL_Symbol **ppSym);
+typedef bool(*dbll_get_addr_fxn) (struct dbll_library_obj *lib, char *name,
+				  struct dbll_sym_val **ppSym);
 
 /*
- *  ======== DBLL_getAttrs ========
+ *  ======== dbll_get_attrs ========
  *  Retrieve the attributes of the target.
  *  Parameters:
  *      target          - Handle returned from DBLL_Create().
- *      pAttrs          - Location to store attributes on output.
+ *      pattrs          - Location to store attributes on output.
  *  Returns:
  *  Requires:
  *      DBL initialized.
  *      Valid target.
- *      pAttrs != NULL.
+ *      pattrs != NULL.
  *  Ensures:
  */
-typedef void(*DBLL_GetAttrsFxn) (struct DBLL_TarObj *target,
-				 struct DBLL_Attrs *attrs);
+typedef void (*dbll_get_attrs_fxn) (struct dbll_tar_obj *target,
+				    struct dbll_attrs *attrs);
 
 /*
- *  ======== DBLL_getCAddr ========
+ *  ======== dbll_get_c_addr ========
  *  Get address of "C" name on the specified library.
  *  Parameters:
- *      lib             - Handle returned from DBLL_open().
+ *      lib             - Handle returned from dbll_open().
  *      name            - Name of symbol
  *      ppSym           - Location to store symbol address on output.
  *  Returns:
@@ -297,17 +286,17 @@
  *      ppSym != NULL.
  *  Ensures:
  */
-typedef bool(*DBLL_GetCAddrFxn) (struct DBLL_LibraryObj *lib, char *name,
-				 struct DBLL_Symbol **ppSym);
+typedef bool(*dbll_get_c_addr_fxn) (struct dbll_library_obj *lib, char *name,
+				    struct dbll_sym_val **ppSym);
 
 /*
- *  ======== DBLL_getSect ========
+ *  ======== dbll_get_sect ========
  *  Get address and size of a named section.
  *  Parameters:
- *      lib             - Library handle returned from DBLL_open().
+ *      lib             - Library handle returned from dbll_open().
  *      name            - Name of section.
- *      pAddr           - Location to store section address on output.
- *      pSize           - Location to store section size on output.
+ *      paddr           - Location to store section address on output.
+ *      psize           - Location to store section size on output.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_ENOSECT:    Section not found.
@@ -315,34 +304,34 @@
  *      DBL initialized.
  *      Valid lib.
  *      name != NULL.
- *      pAddr != NULL;
- *      pSize != NULL.
+ *      paddr != NULL;
+ *      psize != NULL.
  *  Ensures:
  */
-typedef DSP_STATUS(*DBLL_GetSectFxn) (struct DBLL_LibraryObj *lib, char *name,
-				      u32 *addr, u32 *size);
+typedef dsp_status(*dbll_get_sect_fxn) (struct dbll_library_obj *lib,
+					char *name, u32 * addr, u32 * size);
 
 /*
- *  ======== DBLL_init ========
+ *  ======== dbll_init ========
  *  Initialize DBL module.
  *  Parameters:
  *  Returns:
  *      TRUE:           Success.
  *      FALSE:          Failure.
  *  Requires:
- *      cRefs >= 0.
+ *      refs >= 0.
  *  Ensures:
- *      Success:        cRefs > 0.
- *      Failure:        cRefs >= 0.
+ *      Success:        refs > 0.
+ *      Failure:        refs >= 0.
  */
-typedef bool(*DBLL_InitFxn) (void);
+typedef bool(*dbll_init_fxn) (void);
 
 /*
- *  ======== DBLL_load ========
+ *  ======== dbll_load ========
  *  Load library onto the target.
  *
  *  Parameters:
- *      lib             - Library handle returned from DBLL_open().
+ *      lib             - Library handle returned from dbll_open().
  *      flags           - Load code, data and/or symbols.
  *      attrs           - May contain alloc, free, and write function.
  *      pulEntry        - Location to store program entry on output.
@@ -357,15 +346,15 @@
  *      pEntry != NULL.
  *  Ensures:
  */
-typedef DSP_STATUS(*DBLL_LoadFxn) (struct DBLL_LibraryObj *lib,
-				   DBLL_Flags flags,
-				   struct DBLL_Attrs *attrs, u32 *entry);
+typedef dsp_status(*dbll_load_fxn) (struct dbll_library_obj *lib,
+				    dbll_flags flags,
+				    struct dbll_attrs *attrs, u32 *entry);
 
 /*
- *  ======== DBLL_loadSect ========
+ *  ======== dbll_load_sect ========
  *  Load a named section from an library (for overlay support).
  *  Parameters:
- *      lib             - Handle returned from DBLL_open().
+ *      lib             - Handle returned from dbll_open().
  *      sectName        - Name of section to load.
  *      attrs           - Contains write function and handle to pass to it.
  *  Returns:
@@ -380,16 +369,16 @@
  *      attrs->write != NULL.
  *  Ensures:
  */
-typedef DSP_STATUS(*DBLL_LoadSectFxn) (struct DBLL_LibraryObj *lib,
-				       char *pszSectName,
-				       struct DBLL_Attrs *attrs);
+typedef dsp_status(*dbll_load_sect_fxn) (struct dbll_library_obj *lib,
+					 char *pszSectName,
+					 struct dbll_attrs *attrs);
 
 /*
- *  ======== DBLL_open ========
- *  DBLL_open() returns a library handle that can be used to load/unload
- *  the symbols/code/data via DBLL_load()/DBLL_unload().
+ *  ======== dbll_open ========
+ *  dbll_open() returns a library handle that can be used to load/unload
+ *  the symbols/code/data via dbll_load()/dbll_unload().
  *  Parameters:
- *      target          - Handle returned from DBLL_create().
+ *      target          - Handle returned from dbll_create().
  *      file            - Name of file to open.
  *      flags           - If flags & DBLL_SYMB, load symbols.
  *      pLib            - Location to store library handle on output.
@@ -404,22 +393,22 @@
  *      Valid target.
  *      file != NULL.
  *      pLib != NULL.
- *      DBLL_Attrs fopen function non-NULL.
+ *      dbll_attrs fopen function non-NULL.
  *  Ensures:
  *      Success:        Valid *pLib.
  *      Failure:        *pLib == NULL.
  */
-typedef DSP_STATUS(*DBLL_OpenFxn) (struct DBLL_TarObj *target, char *file,
-				   DBLL_Flags flags,
-				   struct DBLL_LibraryObj **pLib);
+typedef dsp_status(*dbll_open_fxn) (struct dbll_tar_obj *target, char *file,
+				    dbll_flags flags,
+				    struct dbll_library_obj **pLib);
 
 /*
- *  ======== DBLL_readSect ========
+ *  ======== dbll_read_sect ========
  *  Read COFF section into a character buffer.
  *  Parameters:
- *      lib             - Library handle returned from DBLL_open().
+ *      lib             - Library handle returned from dbll_open().
  *      name            - Name of section.
- *      pBuf            - Buffer to write section contents into.
+ *      pbuf            - Buffer to write section contents into.
  *      size            - Buffer size
  *  Returns:
  *      DSP_SOK:        Success.
@@ -428,34 +417,35 @@
  *      DBL initialized.
  *      Valid lib.
  *      name != NULL.
- *      pBuf != NULL.
+ *      pbuf != NULL.
  *      size != 0.
  *  Ensures:
  */
-typedef DSP_STATUS(*DBLL_ReadSectFxn) (struct DBLL_LibraryObj *lib, char *name,
-				       char *content, u32 uContentSize);
+typedef dsp_status(*dbll_read_sect_fxn) (struct dbll_library_obj *lib,
+					 char *name, char *content,
+					 u32 uContentSize);
 
 /*
- *  ======== DBLL_setAttrs ========
+ *  ======== dbll_set_attrs ========
  *  Set the attributes of the target.
  *  Parameters:
- *      target          - Handle returned from DBLL_create().
- *      pAttrs          - New attributes.
+ *      target          - Handle returned from dbll_create().
+ *      pattrs          - New attributes.
  *  Returns:
  *  Requires:
  *      DBL initialized.
  *      Valid target.
- *      pAttrs != NULL.
+ *      pattrs != NULL.
  *  Ensures:
  */
-typedef void(*DBLL_SetAttrsFxn)(struct DBLL_TarObj *target,
-				struct DBLL_Attrs *attrs);
+typedef void (*dbll_set_attrs_fxn) (struct dbll_tar_obj *target,
+				    struct dbll_attrs *attrs);
 
 /*
- *  ======== DBLL_unload ========
- *  Unload library loaded with DBLL_load().
+ *  ======== dbll_unload ========
+ *  Unload library loaded with dbll_load().
  *  Parameters:
- *      lib             - Handle returned from DBLL_open().
+ *      lib             - Handle returned from dbll_open().
  *      attrs           - Contains free() function and handle to pass to it.
  *  Returns:
  *  Requires:
@@ -463,14 +453,14 @@
  *      Valid lib.
  *  Ensures:
  */
-typedef void(*DBLL_UnloadFxn) (struct DBLL_LibraryObj *library,
-			       struct DBLL_Attrs *attrs);
+typedef void (*dbll_unload_fxn) (struct dbll_library_obj *library,
+				 struct dbll_attrs *attrs);
 
 /*
- *  ======== DBLL_unloadSect ========
+ *  ======== dbll_unload_sect ========
  *  Unload a named section from an library (for overlay support).
  *  Parameters:
- *      lib             - Handle returned from DBLL_open().
+ *      lib             - Handle returned from dbll_open().
  *      sectName        - Name of section to load.
  *      attrs           - Contains free() function and handle to pass to it.
  *  Returns:
@@ -483,27 +473,27 @@
  *      sectName != NULL.
  *  Ensures:
  */
-typedef DSP_STATUS(*DBLL_UnloadSectFxn) (struct DBLL_LibraryObj *lib,
-					 char *pszSectName,
-					 struct DBLL_Attrs *attrs);
-
-struct DBLL_Fxns {
-	DBLL_CloseFxn closeFxn;
-	DBLL_CreateFxn createFxn;
-	DBLL_DeleteFxn deleteFxn;
-	DBLL_ExitFxn exitFxn;
-	DBLL_GetAttrsFxn getAttrsFxn;
-	DBLL_GetAddrFxn getAddrFxn;
-	DBLL_GetCAddrFxn getCAddrFxn;
-	DBLL_GetSectFxn getSectFxn;
-	DBLL_InitFxn initFxn;
-	DBLL_LoadFxn loadFxn;
-	DBLL_LoadSectFxn loadSectFxn;
-	DBLL_OpenFxn openFxn;
-	DBLL_ReadSectFxn readSectFxn;
-	DBLL_SetAttrsFxn setAttrsFxn;
-	DBLL_UnloadFxn unloadFxn;
-	DBLL_UnloadSectFxn unloadSectFxn;
-} ;
+typedef dsp_status(*dbll_unload_sect_fxn) (struct dbll_library_obj *lib,
+					   char *pszSectName,
+					   struct dbll_attrs *attrs);
+
+struct dbll_fxns {
+	dbll_close_fxn close_fxn;
+	dbll_create_fxn create_fxn;
+	dbll_delete_fxn delete_fxn;
+	dbll_exit_fxn exit_fxn;
+	dbll_get_attrs_fxn get_attrs_fxn;
+	dbll_get_addr_fxn get_addr_fxn;
+	dbll_get_c_addr_fxn get_c_addr_fxn;
+	dbll_get_sect_fxn get_sect_fxn;
+	dbll_init_fxn init_fxn;
+	dbll_load_fxn load_fxn;
+	dbll_load_sect_fxn load_sect_fxn;
+	dbll_open_fxn open_fxn;
+	dbll_read_sect_fxn read_sect_fxn;
+	dbll_set_attrs_fxn set_attrs_fxn;
+	dbll_unload_fxn unload_fxn;
+	dbll_unload_sect_fxn unload_sect_fxn;
+};
 
-#endif				/* DBLDEFS_ */
+#endif /* DBLDEFS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbll.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbll.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbll.h	2011-10-11 13:50:57.517621153 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbll.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ *  DSP/BIOS Bridge Dynamic load library module interface. Function header
+ *  comments are in the file dblldefs.h.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,57 +17,39 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dbll.h ========
- *  DSP/BIOS Bridge Dynamic load library module interface. Function header
- *  comments are in the file dblldefs.h.
- *
- *! Revision History
- *! ================
- *! 31-Jul-2002 jeh     Removed function comments (now in dblldefs.h).
- *! 17-Apr-2002 jeh     Created based on zl.h.
- */
-
 #ifndef DBLL_
 #define DBLL_
 
 #include <dspbridge/dbdefs.h>
 #include <dspbridge/dblldefs.h>
 
-	extern void DBLL_close(struct DBLL_LibraryObj *lib);
-	extern DSP_STATUS DBLL_create(struct DBLL_TarObj **pTarget,
-				      struct DBLL_Attrs *pAttrs);
-	extern void DBLL_delete(struct DBLL_TarObj *target);
-	extern void DBLL_exit(void);
-	extern bool DBLL_getAddr(struct DBLL_LibraryObj *lib, char *name,
-				 struct DBLL_Symbol **ppSym);
-	extern void DBLL_getAttrs(struct DBLL_TarObj *target,
-				  struct DBLL_Attrs *pAttrs);
-	extern bool DBLL_getCAddr(struct DBLL_LibraryObj *lib, char *name,
-				  struct DBLL_Symbol **ppSym);
-	extern DSP_STATUS DBLL_getSect(struct DBLL_LibraryObj *lib, char *name,
-				       u32 *pAddr, u32 *pSize);
-	extern bool DBLL_init(void);
-	extern DSP_STATUS DBLL_load(struct DBLL_LibraryObj *lib,
-				    DBLL_Flags flags,
-				    struct DBLL_Attrs *attrs, u32 *pEntry);
-	extern DSP_STATUS DBLL_loadSect(struct DBLL_LibraryObj *lib,
-					char *sectName,
-					struct DBLL_Attrs *attrs);
-	extern DSP_STATUS DBLL_open(struct DBLL_TarObj *target, char *file,
-				    DBLL_Flags flags,
-				    struct DBLL_LibraryObj **pLib);
-	extern DSP_STATUS DBLL_readSect(struct DBLL_LibraryObj *lib,
-					char *name,
-					char *pBuf, u32 size);
-	extern void DBLL_setAttrs(struct DBLL_TarObj *target,
-				  struct DBLL_Attrs *pAttrs);
-	extern void DBLL_unload(struct DBLL_LibraryObj *lib,
-				struct DBLL_Attrs *attrs);
-	extern DSP_STATUS DBLL_unloadSect(struct DBLL_LibraryObj *lib,
-					  char *sectName,
-					  struct DBLL_Attrs *attrs);
-
-#endif				/* DBLL_ */
+extern void dbll_close(struct dbll_library_obj *lib);
+extern dsp_status dbll_create(struct dbll_tar_obj **target_obj,
+			      struct dbll_attrs *pattrs);
+extern void dbll_delete(struct dbll_tar_obj *target);
+extern void dbll_exit(void);
+extern bool dbll_get_addr(struct dbll_library_obj *lib, char *name,
+			  struct dbll_sym_val **ppSym);
+extern void dbll_get_attrs(struct dbll_tar_obj *target,
+			   struct dbll_attrs *pattrs);
+extern bool dbll_get_c_addr(struct dbll_library_obj *lib, char *name,
+			    struct dbll_sym_val **ppSym);
+extern dsp_status dbll_get_sect(struct dbll_library_obj *lib, char *name,
+				u32 *paddr, u32 *psize);
+extern bool dbll_init(void);
+extern dsp_status dbll_load(struct dbll_library_obj *lib,
+			    dbll_flags flags,
+			    struct dbll_attrs *attrs, u32 * pEntry);
+extern dsp_status dbll_load_sect(struct dbll_library_obj *lib,
+				 char *sectName, struct dbll_attrs *attrs);
+extern dsp_status dbll_open(struct dbll_tar_obj *target, char *file,
+			    dbll_flags flags, struct dbll_library_obj **pLib);
+extern dsp_status dbll_read_sect(struct dbll_library_obj *lib,
+				 char *name, char *pbuf, u32 size);
+extern void dbll_set_attrs(struct dbll_tar_obj *target,
+			   struct dbll_attrs *pattrs);
+extern void dbll_unload(struct dbll_library_obj *lib, struct dbll_attrs *attrs);
+extern dsp_status dbll_unload_sect(struct dbll_library_obj *lib,
+				   char *sectName, struct dbll_attrs *attrs);
 
+#endif /* DBLL_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbof.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbof.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbof.h	2011-10-11 13:50:57.566986998 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbof.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,117 +0,0 @@
-/*
- * dbof.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dbof.h ========
- *  Description:
- *      Defines and typedefs for DSP/BIOS Bridge Object File Format (DBOF).
- *
- *! Revision History
- *! ================
- *! 12-Jul-2002 jeh     Added defines for DBOF_SectHdr page.
- *! 12-Oct-2001 jeh     Converted to std.h format.
- *! 07-Sep-2001 jeh     Added overlay support.
- *! 06-Jul-2001 jeh     Created.
- */
-
-#ifndef DBOF_
-#define DBOF_
-
-/* Enough to hold DCD section names: 32 digit ID + underscores */
-#define DBOF_DCDSECTNAMELEN     40
-
-/* Values for DBOF_SectHdr page field. */
-#define         DBOF_PROGRAM    0
-#define         DBOF_DATA       1
-#define         DBOF_CINIT      2
-
-/*
- *  ======== DBOF_FileHdr ========
- */
-	struct DBOF_FileHdr {
-		u32 magic;	/* COFF magic number */
-		u32 entry;	/* Program entry point */
-		u16 numSymbols;	/* Number of bridge symbols */
-		u16 numDCDSects;	/* Number of DCD sections */
-		u16 numSects;	/* Number of sections to load */
-		u16 numOvlySects;	/* Number of overlay sections */
-		u32 symOffset;	/* Offset in file to symbols */
-		u32 dcdSectOffset;	/* Offset to DCD sections */
-		u32 loadSectOffset;	/* Offset to loadable sections */
-		u32 ovlySectOffset;	/* Offset to overlay data */
-		u16 version;	/* DBOF version number */
-		u16 resvd;	/* Reserved for future use */
-	} ;
-
-/*
- *  ======== DBOF_DCDSectHdr ========
- */
-	struct DBOF_DCDSectHdr {
-		u32 size;	/* Sect size (target MAUs) */
-		char name[DBOF_DCDSECTNAMELEN];	/* DCD section name */
-	} ;
-
-/*
- *  ======== DBOF_OvlySectHdr ========
- */
-	struct DBOF_OvlySectHdr {
-		u16 nameLen;	/* Length of section name */
-		u16 numCreateSects;	/* # of sects loaded for create phase */
-		u16 numDeleteSects;	/* # of sects loaded for delete phase */
-		u16 numExecuteSects; /* # of sects loaded for execute phase */
-
-		/*
-		 *  Number of sections where load/unload phase is not specified.
-		 *  These sections will be loaded when create phase sects are
-		 *  loaded, and unloaded when the delete phase is unloaded.
-		 */
-		u16 numOtherSects;
-		u16 resvd;	/* Reserved for future use */
-	};
-
-/*
- *  ======== DBOF_OvlySectData ========
- */
-	struct DBOF_OvlySectData {
-		u32 loadAddr;	/* Section load address */
-		u32 runAddr;	/* Section run address */
-		u32 size;	/* Section size (target MAUs) */
-		u16 page;	/* Memory page number */
-		u16 resvd;	/* Reserved */
-	} ;
-
-/*
- *  ======== DBOF_SectHdr ========
- */
-	struct DBOF_SectHdr {
-		u32 addr;	/* Section address */
-		u32 size;	/* Section size (target MAUs) */
-		u16 page;	/* Page number */
-		u16 resvd;	/* Reserved for future use */
-	} ;
-
-/*
- *  ======== DBOF_SymbolHdr ========
- */
-	struct DBOF_SymbolHdr {
-		u32 value;	/* Symbol value */
-		u16 nameLen;	/* Length of symbol name */
-		u16 resvd;	/* Reserved for future use */
-	} ;
-
-#endif				/* DBOF_ */
-
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbreg.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbreg.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbreg.h	2011-10-11 13:50:57.566986998 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbreg.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,113 +0,0 @@
-/*
- * dbreg.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dbreg.h ========
- *  Purpose:
- *      Registry keys for use in Linux.  This is the clearinghouse for
- *      registry definitions, hopefully eliminating overlapping between
- *      modules.
- *
- *! Revision History:
- *! ================
- *! 10-Apr-2003 vp:  Added macro for subkey TCWORDSWAP.
- *! 21-Mar-2003 sb:  Added macro for subkey SHMSize
- *! 27-Aug-2001 jeh  Added WSXREG_LOADERFILENAME.
- *! 13-Feb-2001 kc:  DSP/BIOS Bridge name updates.
- *! 29-Nov-2000 rr:  Added WSXREG_DSPTYPE_55 as 6.
- *! 06-Sep-2000 jeh: Added WSXREG_CHNLOFFSET, WSXREG_NUMCHNLS,
- *!                  WSXREG_CHNLBUFSIZE.
- *! 26-Aug-2000 rr:  MEMBASE expanded to 9 entries.
- *! 26-Jul-2000 rr:  Added WSXREG_DCDNAME for the DCD Dll name. It will
- *!                  live under WSXREG_WINSPOXCONFIG.
- *! 17-Jul-2000 rr:  REG_MGR_OBJECT and REG_DRV_OBJECT defined. They
- *!                  are stored in the Registrty under WSXREG_WINSPOXCONFIG
- *!                  when they are created in DSP_Init. WSXREG_DEVOBJECT
- *!                  and WSXREG_MGROBJECT defined.
- *! 11-Dec-1999 ag:  Renamed Isa to IsaBus due to conflict with ceddk.h.
- *! 12-Nov-1999 rr:  New Registry Defnitions.
- *! 15-Oct-1999 rr:  New entry for DevObject created. WSXREG_DEVOBJECT
- *!                  under WSXREG_DDSPDRIVERPATH
- *! 10-Nov-1997 cr:  Added WSXREG_INFPATH, WSXREG_WINDEVICEPATH,
- *!                  WSXREG_WINCURVERSION
- *! 21-Oct-1997 cr:  Added WSXREG_BUSTYPE.
- *! 08-Sep-1997 cr:  Added WSXREG_SERVICES, WSXREG_SERVICENAME and
- *!                  WSXREG_CLASSINDEX.
- *! 30-Aug-1997 cr:  Added WSXREG_SOFTWAREPATHNT & WSXREG_WBCLASSGUID.
- *! 24-Mar-1997 gp:  Added MAXCHIPINFOSUBKEY def.
- *! 18-Feb-1997 cr:  Changed Version1.1 -> Version1.0
- *! 12-Feb-1997 cr:  Changed WinSPOX -> WinBRIDGE.
- *! 11-Dec-1996 gp:  Added Perf key name in WinSPOX Config.
- *! 22-Jul-1996 gp:  Added Trace key name.
- *! 30-May-1996 cr:  Created.
- */
-
-#ifndef DBREG_
-#define DBREG_ 1	/* Defined as "1" so InstallShield programs compile. */
-
-#define REG_MGR_OBJECT      1
-#define REG_DRV_OBJECT      2
-/* general registry definitions */
-#define MAXREGPATHLENGTH    255	/* Max registry path length. Also the
-				   max registry value length. */
-#define DSPTYPE_55          6	/* This is the DSP Chip type for 55 */
-#define DSPTYPE_64          0x99
-#define IVA_ARM7            0x97    /* This is the DSP Chip type for IVA/ARM7 */
-
-#define DSPPROCTYPE_C55		5510
-#define DSPPROCTYPE_C64		6410
-#define IVAPROCTYPE_ARM7	470
-/* registry */
-#define DEVNODESTRING    "DevNode"	/* u32 devnode */
-#define CONFIG           "Software\\TexasInstruments\\DirectDSP\\Config"
-#define DRVOBJECT        "DrvObject"
-#define MGROBJECT        "MgrObject"
-#define CLASS            "Device"	/*  device class */
-#define TRACE            "Trace"	/* GT Trace settings.  */
-#define PERFR            "Perf"	/* Enable perf bool.  */
-#define ROOT             "Root"	/*  root dir */
-
-/* MiniDriver related definitions */
-/* The following definitions are under "Drivers\\DirectDSP\\Device\\XXX "
- * Where XXX is the device or board name */
-
-#define WMDFILENAME      "MiniDriver"	/* WMD entry name */
-#define CHIPTYPE         "ChipType"	/* Chip type */
-#define CHIPNUM          "NumChips"	/* Number of chips */
-#define NUMPROCS         "NumOfProcessors"	/* Number of processors */
-#define DEFEXEC          "DefaultExecutable"	/* Default executable */
-#define AUTOSTART        "AutoStart"	/* Statically load flag */
-#define IVAAUTOSTART     "IvaAutoStart"	/* Statically load flag */
-#define BOARDNAME        "BoardName"	/* Name of the Board */
-#define UNITNUMBER       "UnitNumber"	/* Unit # of the Board */
-#define BUSTYPE          "BusType"	/* Bus type board is on */
-#define BUSNUMBER        "BusNumber"	/* Bus number board is on */
-#define CURRENTCONFIG    "CurrentConfig"	/* Current resources */
-#define PCIVENDEVID      "VendorDeviceId"	/* The board's id */
-#define INFPATH          "InfPath"	/* wmd's inf filename */
-#define DEVOBJECT        "DevObject"
-#define ZLFILENAME       "ZLFileName"	/* Name of ZL file */
-#define WORDSIZE         "WordSize"	/* NumBytes in DSP Word */
-#define SHMSIZE          "SHMSize"	/* Size of SHM reservd on MPU */
-#define IVAEXTMEMSIZE    "IVAEXTMEMSize"	/* IVA External Memeory size  */
-#define TCWORDSWAP       "TCWordSwap"	/* Traffic Contoller Word Swap */
-#define DSPRESOURCES     "DspTMSResources"	/* C55 DSP resurces on OMAP */
-#define IVA1RESOURCES    "ARM7IvaResources"	/* ARM7 IVA resurces on OMAP */
-#define PHYSMEMPOOLBASE  "PhysicalMemBase"   /* Physical mem passed to driver */
-#define PHYSMEMPOOLSIZE  "PhysicalMemSize"   /* Physical mem passed to driver */
-
-#endif				/* DBREG_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbtype.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbtype.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dbtype.h	2011-10-11 13:50:57.566986998 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dbtype.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,10 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This header defines data types for DSP/BIOS Bridge APIs and device
+ * driver modules. It also defines the Hungarian prefix to use for each
+ * base type.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,29 +18,12 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== dbtype.h ========
- *  Description:
- *      This header defines data types for DSP/BIOS Bridge APIs and device
- *      driver modules. It also defines the Hungarian
- *      prefix to use for each base type.
- *
- *
- *! Revision History:
- *! =================
- *! 23-Nov-2002 gp: Purpose -> Description in file header.
- *! 13-Feb-2001 kc: Name changed from ddsptype.h dbtype.h.
- *! 09-Oct-2000 jeh Added CHARACTER.
- *! 11-Aug-2000 ag: Added 'typedef void void'.
- *! 08-Apr-2000 ww: Cloned.
- */
-
 #ifndef DBTYPE_
 #define DBTYPE_
 
-/*============================================================================*/
-/*  Argument specification syntax                                             */
-/*============================================================================*/
+/*===========================================================================*/
+/*  Argument specification syntax */
+/*===========================================================================*/
 
 #ifndef IN
 #define IN			/* Following parameter is for input. */
@@ -47,16 +34,16 @@
 #endif
 
 #ifndef OPTIONAL
-#define OPTIONAL	  /* Function may optionally use previous parameter. */
+#define OPTIONAL	/* Function may optionally use previous parameter. */
 #endif
 
 #ifndef CONST
 #define CONST   const
 #endif
 
-/*============================================================================*/
-/*  Boolean constants                                                         */
-/*============================================================================*/
+/*===========================================================================*/
+/*  Boolean constants */
+/*===========================================================================*/
 
 #ifndef FALSE
 #define FALSE   0
@@ -65,32 +52,32 @@
 #define TRUE    1
 #endif
 
-/*============================================================================*/
-/*  NULL    (Definition is language specific)                                 */
-/*============================================================================*/
+/*===========================================================================*/
+/*  NULL    (Definition is language specific) */
+/*===========================================================================*/
 
 #ifndef NULL
 #define NULL    ((void *)0)	/* Null pointer. */
 #endif
 
-/*============================================================================*/
-/*  NULL character   (normally used for string termination)                   */
-/*============================================================================*/
+/*===========================================================================*/
+/*  NULL character   (normally used for string termination) */
+/*===========================================================================*/
 
 #ifndef NULL_CHAR
 #define NULL_CHAR    '\0'	/* Null character. */
 #endif
 
-/*============================================================================*/
-/*  Basic Type definitions (with Prefixes for Hungarian notation)             */
-/*============================================================================*/
+/*===========================================================================*/
+/*  Basic Type definitions (with Prefixes for Hungarian notation) */
+/*===========================================================================*/
 
 #ifndef OMAPBRIDGE_TYPES
 #define OMAPBRIDGE_TYPES
-typedef volatile unsigned short REG_UWORD16;
+typedef volatile unsigned short reg_uword16;
 #endif
 
-typedef void *HANDLE;		/* h    */
+typedef void *bhandle;		/* h */
 
 #define TEXT(x) x
 
@@ -100,4 +87,4 @@
 /* Define DSPAPIDLL correctly in dspapi.h */
 #define _DSPSYSDLL32_
 
-#endif				/* DBTYPE_ */
+#endif /* DBTYPE_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/_dcd.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/_dcd.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/_dcd.h	2011-10-11 13:50:57.566986998 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/_dcd.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Includes the wrapper functions called directly by the
+ * DeviceIOControl interface.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,50 +17,13 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _dcd.h ========
- *  Description:
- *      Includes the wrapper functions called directly by the
- *      DeviceIOControl interface.
- *
- *  Public Functions:
- *      WCD_CallDevIOCtl
- *      WCD_Init
- *      WCD_InitComplete2
- *      WCD_Exit
- *      <MOD>WRAP_*
- *
- *  Notes:
- *      Compiled with CDECL calling convention.
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping feature
- *! 30-Jan-2002 ag  Renamed CMMWRAP_AllocBuf to CMMWRAP_CallocBuf.
- *! 22-Nov-2000 kc: Added MGRWRAP_GetPerf_Data to acquire PERF stats.
- *! 27-Oct-2000 jeh Added NODEWRAP_AllocMsgBuf, NODEWRAP_FreeMsgBuf. Removed
- *!                 NODEWRAP_GetMessageStream.
- *! 10-Oct-2000 ag: Added user CMM wrappers.
- *! 04-Aug-2000 rr: MEMWRAP and UTIL_Wrap added.
- *! 27-Jul-2000 rr: NODEWRAP, STRMWRAP added.
- *! 27-Jun-2000 rr: MGRWRAP fxns added.IFDEF to build for PM or DSP/BIOS Bridge
- *! 03-Dec-1999 rr: WCD_InitComplete2 enabled for BRD_AutoStart.
- *! 09-Nov-1999 kc: Added MEMRY.
- *! 02-Nov-1999 ag: Added CHNL.
- *! 08-Oct-1999 rr: Utilwrap_Testdll fxn added
- *! 24-Sep-1999 rr: header changed from _wcd.h to _dcd.h
- *! 09-Sep-1997 gp: Created.
- */
-
 #ifndef _WCD_
 #define _WCD_
 
 #include <dspbridge/wcdioctl.h>
 
 /*
- *  ======== WCD_CallDevIOCtl ========
+ *  ======== wcd_call_dev_io_ctl ========
  *  Purpose:
  *      Call the (wrapper) function for the corresponding WCD IOCTL.
  *  Parameters:
@@ -70,12 +36,12 @@
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS WCD_CallDevIOCtl(unsigned int cmd,
-					   union Trapped_Args *args,
-					   u32 *pResult, void *pr_ctxt);
+extern dsp_status wcd_call_dev_io_ctl(unsigned int cmd,
+				      union Trapped_Args *args,
+				      u32 *pResult, void *pr_ctxt);
 
 /*
- *  ======== WCD_Init ========
+ *  ======== wcd_init ========
  *  Purpose:
  *      Initialize WCD modules, and export WCD services to WMD's.
  *      This procedure is called when the class driver is loaded.
@@ -85,13 +51,13 @@
  *  Requires:
  *  Ensures:
  */
-	extern bool WCD_Init(void);
+extern bool wcd_init(void);
 
 /*
- *  ======== WCD_InitComplete2 ========
+ *  ======== wcd_init_complete2 ========
  *  Purpose:
  *      Perform any required WCD, and WMD initialization which
- *      cannot not be performed in WCD_Init(void) or DEV_StartDevice() due
+ *      cannot not be performed in wcd_init(void) or dev_start_device() due
  *      to the fact that some services are not yet
  *      completely initialized.
  *  Parameters:
@@ -102,111 +68,85 @@
  *      WCD initialized.
  *  Ensures:
  */
-	extern DSP_STATUS WCD_InitComplete2(void);
+extern dsp_status wcd_init_complete2(void);
 
 /*
- *  ======== WCD_Exit ========
+ *  ======== wcd_exit ========
  *  Purpose:
- *      Exit all modules initialized in WCD_Init(void).
+ *      Exit all modules initialized in wcd_init(void).
  *      This procedure is called when the class driver is unloaded.
  *  Parameters:
  *  Returns:
  *  Requires:
- *      WCD_Init(void) was previously called.
+ *      wcd_init(void) was previously called.
  *  Ensures:
- *      Resources acquired in WCD_Init(void) are freed.
+ *      Resources acquired in wcd_init(void) are freed.
  */
-	extern void WCD_Exit(void);
+extern void wcd_exit(void);
 
 /* MGR wrapper functions */
-	extern u32 MGRWRAP_EnumNode_Info(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 MGRWRAP_EnumProc_Info(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 MGRWRAP_RegisterObject(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 MGRWRAP_UnregisterObject(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 MGRWRAP_WaitForBridgeEvents(union Trapped_Args *args,
-			void *pr_ctxt);
-
-#ifndef RES_CLEANUP_DISABLE
-	extern u32 MGRWRAP_GetProcessResourcesInfo(union Trapped_Args *args,
-			void *pr_ctxt);
-#endif
+extern u32 mgrwrap_enum_node_info(union Trapped_Args *args, void *pr_ctxt);
+extern u32 mgrwrap_enum_proc_info(union Trapped_Args *args, void *pr_ctxt);
+extern u32 mgrwrap_register_object(union Trapped_Args *args, void *pr_ctxt);
+extern u32 mgrwrap_unregister_object(union Trapped_Args *args, void *pr_ctxt);
+extern u32 mgrwrap_wait_for_bridge_events(union Trapped_Args *args,
+					  void *pr_ctxt);
 
+extern u32 mgrwrap_get_process_resources_info(union Trapped_Args *args,
+					      void *pr_ctxt);
 
 /* CPRC (Processor) wrapper Functions */
-	extern u32 PROCWRAP_Attach(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_Ctrl(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_Detach(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_EnumNode_Info(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 PROCWRAP_EnumResources(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 PROCWRAP_GetState(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_GetTrace(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_Load(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_RegisterNotify(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 PROCWRAP_Start(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_ReserveMemory(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 PROCWRAP_UnReserveMemory(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 PROCWRAP_Map(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_UnMap(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_FlushMemory(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 PROCWRAP_Stop(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 PROCWRAP_InvalidateMemory(union Trapped_Args *args,
-			void *pr_ctxt);
+extern u32 procwrap_attach(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_ctrl(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_detach(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_enum_node_info(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_enum_resources(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_get_state(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_get_trace(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_load(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_register_notify(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_start(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_reserve_memory(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_un_reserve_memory(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_map(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_un_map(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_flush_memory(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_stop(union Trapped_Args *args, void *pr_ctxt);
+extern u32 procwrap_invalidate_memory(union Trapped_Args *args, void *pr_ctxt);
 
 /* NODE wrapper functions */
-	extern u32 NODEWRAP_Allocate(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 NODEWRAP_AllocMsgBuf(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 NODEWRAP_ChangePriority(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 NODEWRAP_Connect(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 NODEWRAP_Create(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 NODEWRAP_Delete(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 NODEWRAP_FreeMsgBuf(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 NODEWRAP_GetAttr(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 NODEWRAP_GetMessage(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 NODEWRAP_Pause(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 NODEWRAP_PutMessage(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 NODEWRAP_RegisterNotify(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 NODEWRAP_Run(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 NODEWRAP_Terminate(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 NODEWRAP_GetUUIDProps(union Trapped_Args *args,
-			void *pr_ctxt);
+extern u32 nodewrap_allocate(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_alloc_msg_buf(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_change_priority(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_connect(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_create(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_delete(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_free_msg_buf(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_get_attr(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_get_message(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_pause(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_put_message(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_register_notify(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_run(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_terminate(union Trapped_Args *args, void *pr_ctxt);
+extern u32 nodewrap_get_uuid_props(union Trapped_Args *args, void *pr_ctxt);
 
 /* STRM wrapper functions */
-	extern u32 STRMWRAP_AllocateBuffer(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 STRMWRAP_Close(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 STRMWRAP_FreeBuffer(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 STRMWRAP_GetEventHandle(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 STRMWRAP_GetInfo(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 STRMWRAP_Idle(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 STRMWRAP_Issue(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 STRMWRAP_Open(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 STRMWRAP_Reclaim(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 STRMWRAP_RegisterNotify(union Trapped_Args *args,
-			void *pr_ctxt);
-	extern u32 STRMWRAP_Select(union Trapped_Args *args, void *pr_ctxt);
-
-	extern u32 CMMWRAP_CallocBuf(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 CMMWRAP_FreeBuf(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 CMMWRAP_GetHandle(union Trapped_Args *args, void *pr_ctxt);
-	extern u32 CMMWRAP_GetInfo(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_allocate_buffer(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_close(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_free_buffer(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_get_event_handle(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_get_info(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_idle(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_issue(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_open(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_reclaim(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_register_notify(union Trapped_Args *args, void *pr_ctxt);
+extern u32 strmwrap_select(union Trapped_Args *args, void *pr_ctxt);
+
+extern u32 cmmwrap_calloc_buf(union Trapped_Args *args, void *pr_ctxt);
+extern u32 cmmwrap_free_buf(union Trapped_Args *args, void *pr_ctxt);
+extern u32 cmmwrap_get_handle(union Trapped_Args *args, void *pr_ctxt);
+extern u32 cmmwrap_get_info(union Trapped_Args *args, void *pr_ctxt);
 
-#endif				/* _WCD_ */
+#endif /* _WCD_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dehdefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dehdefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dehdefs.h	2011-10-11 13:50:57.566986998 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dehdefs.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definition for mini-driver module DEH.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,29 +16,17 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== dehdefs.h ========
- *  Purpose:
- *      Definition for mini-driver module DEH.
- *
- *! Revision History:
- *! ================
- *! 17-Dec-2001 ag: added #include <dspbridge/mbx_sh.h> for shared mailbox codes.
- *! 10-Dec-2001 kc: added DEH error base value and error max value.
- *! 11-Sep-2001 kc: created.
- */
-
 #ifndef DEHDEFS_
 #define DEHDEFS_
 
-#include <dspbridge/mbx_sh.h>		/* shared mailbox codes */
+#include <dspbridge/mbx_sh.h>	/* shared mailbox codes */
 
 /* DEH object manager */
-	struct DEH_MGR;
+struct deh_mgr;
 
 /* Magic code used to determine if DSP signaled exception. */
 #define DEH_BASE        MBX_DEH_BASE
 #define DEH_USERS_BASE  MBX_DEH_USERS_BASE
 #define DEH_LIMIT       MBX_DEH_LIMIT
 
-#endif				/* _DEHDEFS_H */
+#endif /* _DEHDEFS_H */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/devdefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/devdefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/devdefs.h	2011-10-11 13:50:57.577198228 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/devdefs.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definition of common include typedef between wmd.h and dev.h. Required
+ * to break circular dependency between WMD and DEV include files.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,22 +17,10 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== devdefs.h ========
- *  Purpose:
- *      Definition of common include typedef between wmd.h and dev.h. Required
- *      to break circular dependency between WMD and DEV include files.
- *
- *! Revision History:
- *! ================
- *! 12-Nov-1996 gp: Renamed from dev1.h.
- *! 30-May-1996 gp: Broke out from dev.h
- */
-
 #ifndef DEVDEFS_
 #define DEVDEFS_
 
 /* WCD Device Object */
-	struct DEV_OBJECT;
+struct dev_object;
 
-#endif				/* DEVDEFS_ */
+#endif /* DEVDEFS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dev.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dev.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dev.h	2011-10-11 13:50:57.602589316 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dev.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Bridge Mini-driver device operations.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,68 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dev.h ========
- *  Description:
- *      'Bridge Mini-driver device operations.
- *
- *  Public Functions:
- *      DEV_BrdWriteFxn
- *      DEV_CreateDevice
- *      DEV_Create2
- *      DEV_Destroy2
- *      DEV_DestroyDevice
- *      DEV_GetChnlMgr
- *      DEV_GetCmmMgr
- *      DEV_GetCodMgr
- *      DEV_GetDehMgr
- *      DEV_GetDevNode
- *      DEV_GetDSPWordSize
- *      DEV_GetFirst
- *      DEV_GetIntfFxns
- *      DEV_GetIOMgr
- *      DEV_GetMsgMgr
- *      DEV_GetNext
- *      DEV_GetNodeManager
- *      DEV_GetSymbol
- *      DEV_GetWMDContext
- *      DEV_Exit
- *      DEV_Init
- *      DEV_InsertProcObject
- *      DEV_IsLocked
- *      DEV_NotifyClient
- *      DEV_RegisterNotify
- *      DEV_ReleaseCodMgr
- *      DEV_RemoveDevice
- *      DEV_RemoveProcObject
- *      DEV_SetChnlMgr
- *      DEV_SetMsgMgr
- *      DEV_SetLockOwner
- *      DEV_StartDevice
- *
- *! Revision History:
- *! ================
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping feature - Dev_GetDmmMgr
- *! 09-Feb-2004 vp  Added functions required for IVA
- *! 25-Feb-2003 swa PMGR Code Review changes incorporated
- *! 05-Nov-2001 kc: Added DEV_GetDehMgr.
- *! 05-Dec-2000 jeh Added DEV_SetMsgMgr.
- *! 29-Nov-2000 rr: Incorporated code review changes.
- *! 17-Nov-2000 jeh Added DEV_GetMsgMgr.
- *! 05-Oct-2000 rr: DEV_Create2 & DEV_Destroy2 Added.
- *! 02-Oct-2000 rr: Added DEV_GetNodeManager.
- *! 11-Aug-2000 ag: Added DEV_GetCmmMgr() for shared memory management.
- *! 10-Aug-2000 rr: DEV_InsertProcObject/RemoveProcObject added.
- *! 06-Jun-2000 jeh Added DEV_GetSymbol().
- *! 05-Nov-1999 kc: Updated function prototypes.
- *! 08-Oct-1997 cr: Added explicit CDECL function identifiers.
- *! 07-Nov-1996 gp: Updated for code review.
- *! 22-Oct-1996 gp: Added DEV_CleanupProcessState().
- *! 29-May-1996 gp: Changed DEV_HDEVNODE --> CFG_HDEVNODE.
- *! 18-May-1996 gp: Created.
- */
-
 #ifndef DEV_
 #define DEV_
 
@@ -93,19 +33,18 @@
 /*  ----------------------------------- This */
 #include <dspbridge/devdefs.h>
 
-
 /*
- *  ======== DEV_BrdWriteFxn ========
+ *  ======== dev_brd_write_fxn ========
  *  Purpose:
  *      Exported function to be used as the COD write function.  This function
  *      is passed a handle to a DEV_hObject by ZL in pArb, then calls the
- *      device's WMD_BRD_Write() function.
+ *      device's bridge_brd_write() function.
  *  Parameters:
  *      pArb:           Handle to a Device Object.
  *      hDevContext:    Handle to mini-driver defined device info.
  *      dwDSPAddr:      Address on DSP board (Destination).
  *      pHostBuf:       Pointer to host buffer (Source).
- *      ulNumBytes:     Number of bytes to transfer.
+ *      ul_num_bytes:     Number of bytes to transfer.
  *      ulMemType:      Memory space on DSP to which to transfer.
  *  Returns:
  *      Number of bytes written.  Returns 0 if the DEV_hObject passed in via
@@ -115,13 +54,12 @@
  *      pHostBuf != NULL
  *  Ensures:
  */
-       extern u32 DEV_BrdWriteFxn(void *pArb,
-					   u32 ulDspAddr,
-					   void *pHostBuf,
-					   u32 ulNumBytes, u32 nMemSpace);
+extern u32 dev_brd_write_fxn(void *pArb,
+			     u32 ulDspAddr,
+			     void *pHostBuf, u32 ul_num_bytes, u32 nMemSpace);
 
 /*
- *  ======== DEV_CreateDevice ========
+ *  ======== dev_create_device ========
  *  Purpose:
  *      Called by the operating system to load the 'Bridge Mini Driver for a
  *      'Bridge device.
@@ -131,17 +69,17 @@
  *                      path is not provided, the file is loaded through
  *                      'Bridge's module search path.
  *      pHostConfig:    Host configuration information, to be passed down
- *                      to the WMD when WMD_DEV_Create() is called.
+ *                      to the WMD when bridge_dev_create() is called.
  *      pDspConfig:     DSP resources, to be passed down to the WMD when
- *                      WMD_DEV_Create() is called.
- *      hDevNode:       Platform (Windows) specific device node.
+ *                      bridge_dev_create() is called.
+ *      dev_node_obj:       Platform (Windows) specific device node.
  *  Returns:
  *      DSP_SOK:            Module is loaded, device object has been created
  *      DSP_EMEMORY:        Insufficient memory to create needed resources.
  *      DEV_E_NEWWMD:       The WMD was compiled for a newer version of WCD.
- *      DEV_E_NULLWMDINTF:  WMD passed back a NULL Fxn Interface Struct Ptr
+ *      DEV_E_NULLWMDINTF:  WMD passed back a NULL fxn Interface Struct Ptr
  *      DEV_E_NOCODMODULE:  No ZL file name was specified in the registry
- *                          for this hDevNode.
+ *                          for this dev_node_obj.
  *      LDR_E_FILEUNABLETOOPEN: Unable to open the specified WMD.
  *      LDR_E_NOMEMORY:         PELDR is out of resources.
  *      DSP_EFAIL:              Unable to find WMD entry point function.
@@ -158,17 +96,16 @@
  *      Otherwise, does not create the device object, ensures the WMD module is
  *      unloaded, and sets *phDevObject to NULL.
  */
-       extern DSP_STATUS DEV_CreateDevice(OUT struct DEV_OBJECT
-						 **phDevObject,
-						 IN CONST char *pstrWMDFileName,
-						 IN CONST struct CFG_HOSTRES
-						 *pHostConfig,
-						 IN CONST struct CFG_DSPRES
-						 *pDspConfig,
-						 struct CFG_DEVNODE *hDevNode);
+extern dsp_status dev_create_device(OUT struct dev_object
+				    **phDevObject,
+				    IN CONST char *pstrWMDFileName,
+				    IN CONST struct cfg_hostres
+				    *pHostConfig, IN CONST struct cfg_dspres
+				    *pDspConfig,
+				    struct cfg_devnode *dev_node_obj);
 
 /*
- *  ======== DEV_CreateIVADevice ========
+ *  ======== dev_create_iva_device ========
  *  Purpose:
  *      Called by the operating system to load the 'Bridge Mini Driver for IVA.
  *  Parameters:
@@ -177,17 +114,17 @@
  *                      path is not provided, the file is loaded through
  *                      'Bridge's module search path.
  *      pHostConfig:    Host configuration information, to be passed down
- *                      to the WMD when WMD_DEV_Create() is called.
+ *                      to the WMD when bridge_dev_create() is called.
  *      pDspConfig:     DSP resources, to be passed down to the WMD when
- *                      WMD_DEV_Create() is called.
- *      hDevNode:       Platform (Windows) specific device node.
+ *                      bridge_dev_create() is called.
+ *      dev_node_obj:       Platform (Windows) specific device node.
  *  Returns:
  *      DSP_SOK:            Module is loaded, device object has been created
  *      DSP_EMEMORY:        Insufficient memory to create needed resources.
  *      DEV_E_NEWWMD:       The WMD was compiled for a newer version of WCD.
- *      DEV_E_NULLWMDINTF:  WMD passed back a NULL Fxn Interface Struct Ptr
+ *      DEV_E_NULLWMDINTF:  WMD passed back a NULL fxn Interface Struct Ptr
  *      DEV_E_NOCODMODULE:  No ZL file name was specified in the registry
- *                          for this hDevNode.
+ *                          for this dev_node_obj.
  *      LDR_E_FILEUNABLETOOPEN: Unable to open the specified WMD.
  *      LDR_E_NOMEMORY:         PELDR is out of resources.
  *      DSP_EFAIL:              Unable to find WMD entry point function.
@@ -204,81 +141,82 @@
  *      Otherwise, does not create the device object, ensures the WMD module is
  *      unloaded, and sets *phDevObject to NULL.
  */
-       extern DSP_STATUS DEV_CreateIVADevice(OUT struct DEV_OBJECT
-				**phDevObject,
-				IN CONST char *pstrWMDFileName,
-				IN CONST struct CFG_HOSTRES *pHostConfig,
-				IN CONST struct CFG_DSPRES *pDspConfig,
-				struct CFG_DEVNODE *hDevNode);
+extern dsp_status dev_create_iva_device(OUT struct dev_object
+					**phDevObject,
+					IN CONST char *pstrWMDFileName,
+					IN CONST struct cfg_hostres
+					*pHostConfig,
+					IN CONST struct cfg_dspres *pDspConfig,
+					struct cfg_devnode *dev_node_obj);
 
 /*
- *  ======== DEV_Create2 ========
+ *  ======== dev_create2 ========
  *  Purpose:
- *      After successful loading of the image from WCD_InitComplete2
- *      (PROC Auto_Start) or PROC_Load this fxn is called. This creates
+ *      After successful loading of the image from wcd_init_complete2
+ *      (PROC Auto_Start) or proc_load this fxn is called. This creates
  *      the Node Manager and updates the DEV Object.
  *  Parameters:
- *      hDevObject: Handle to device object created with DEV_CreateDevice().
+ *      hdev_obj: Handle to device object created with dev_create_device().
  *  Returns:
  *      DSP_SOK:    Successful Creation of Node Manager
  *      DSP_EFAIL:  Some Error Occurred.
  *  Requires:
  *      DEV Initialized
- *      Valid hDevObject
+ *      Valid hdev_obj
  *  Ensures:
- *      DSP_SOK and hDevObject->hNodeMgr != NULL
- *      else    hDevObject->hNodeMgr == NULL
+ *      DSP_SOK and hdev_obj->hnode_mgr != NULL
+ *      else    hdev_obj->hnode_mgr == NULL
  */
-       extern DSP_STATUS DEV_Create2(IN struct DEV_OBJECT *hDevObject);
+extern dsp_status dev_create2(IN struct dev_object *hdev_obj);
 
 /*
- *  ======== DEV_Destroy2 ========
+ *  ======== dev_destroy2 ========
  *  Purpose:
  *      Destroys the Node manager for this device.
  *  Parameters:
- *      hDevObject: Handle to device object created with DEV_CreateDevice().
+ *      hdev_obj: Handle to device object created with dev_create_device().
  *  Returns:
  *      DSP_SOK:    Successful Creation of Node Manager
  *      DSP_EFAIL:  Some Error Occurred.
  *  Requires:
  *      DEV Initialized
- *      Valid hDevObject
+ *      Valid hdev_obj
  *  Ensures:
- *      DSP_SOK and hDevObject->hNodeMgr == NULL
+ *      DSP_SOK and hdev_obj->hnode_mgr == NULL
  *      else    DSP_EFAIL.
  */
-       extern DSP_STATUS DEV_Destroy2(IN struct DEV_OBJECT *hDevObject);
+extern dsp_status dev_destroy2(IN struct dev_object *hdev_obj);
 
 /*
- *  ======== DEV_DestroyDevice ========
+ *  ======== dev_destroy_device ========
  *  Purpose:
  *      Destroys the channel manager for this device, if any, calls
- *      WMD_DEV_Destroy(), and then attempts to unload the WMD module.
+ *      bridge_dev_destroy(), and then attempts to unload the WMD module.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
- *      DSP_EFAIL:      The WMD failed it's WMD_DEV_Destroy() function.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
+ *      DSP_EFAIL:      The WMD failed it's bridge_dev_destroy() function.
  *  Requires:
  *      DEV Initialized.
  *  Ensures:
  */
-       extern DSP_STATUS DEV_DestroyDevice(struct DEV_OBJECT
-						  *hDevObject);
+extern dsp_status dev_destroy_device(struct dev_object
+				     *hdev_obj);
 
 /*
- *  ======== DEV_GetChnlMgr ========
+ *  ======== dev_get_chnl_mgr ========
  *  Purpose:
  *      Retrieve the handle to the channel manager created for this device.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      *phMgr:         Ptr to location to store handle.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      phMgr != NULL.
  *      DEV Initialized.
@@ -287,21 +225,21 @@
  *                      or NULL.
  *      else:           *phMgr is NULL.
  */
-       extern DSP_STATUS DEV_GetChnlMgr(struct DEV_OBJECT *hDevObject,
-					       OUT struct CHNL_MGR **phMgr);
+extern dsp_status dev_get_chnl_mgr(struct dev_object *hdev_obj,
+				   OUT struct chnl_mgr **phMgr);
 
 /*
- *  ======== DEV_GetCmmMgr ========
+ *  ======== dev_get_cmm_mgr ========
  *  Purpose:
  *      Retrieve the handle to the shared memory manager created for this
  *      device.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      *phMgr:         Ptr to location to store handle.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      phMgr != NULL.
  *      DEV Initialized.
@@ -310,21 +248,21 @@
  *                      or NULL.
  *      else:           *phMgr is NULL.
  */
-       extern DSP_STATUS DEV_GetCmmMgr(struct DEV_OBJECT *hDevObject,
-					      OUT struct CMM_OBJECT **phMgr);
+extern dsp_status dev_get_cmm_mgr(struct dev_object *hdev_obj,
+				  OUT struct cmm_object **phMgr);
 
 /*
- *  ======== DEV_GetDmmMgr ========
+ *  ======== dev_get_dmm_mgr ========
  *  Purpose:
  *      Retrieve the handle to the dynamic memory manager created for this
  *      device.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      *phMgr:         Ptr to location to store handle.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      phMgr != NULL.
  *      DEV Initialized.
@@ -333,20 +271,20 @@
  *                      or NULL.
  *      else:           *phMgr is NULL.
  */
-       extern DSP_STATUS DEV_GetDmmMgr(struct DEV_OBJECT *hDevObject,
-					      OUT struct DMM_OBJECT **phMgr);
+extern dsp_status dev_get_dmm_mgr(struct dev_object *hdev_obj,
+				  OUT struct dmm_object **phMgr);
 
 /*
- *  ======== DEV_GetCodMgr ========
+ *  ======== dev_get_cod_mgr ========
  *  Purpose:
  *      Retrieve the COD manager create for this device.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      *phCodMgr:      Ptr to location to store handle.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      phCodMgr != NULL.
  *      DEV Initialized.
@@ -354,19 +292,19 @@
  *      DSP_SOK:        *phCodMgr contains a handle to a COD manager object.
  *      else:           *phCodMgr is NULL.
  */
-       extern DSP_STATUS DEV_GetCodMgr(struct DEV_OBJECT *hDevObject,
-					     OUT struct COD_MANAGER **phCodMgr);
+extern dsp_status dev_get_cod_mgr(struct dev_object *hdev_obj,
+				  OUT struct cod_manager **phCodMgr);
 
 /*
- *  ======== DEV_GetDehMgr ========
+ *  ======== dev_get_deh_mgr ========
  *  Purpose:
  *      Retrieve the DEH manager created for this device.
  *  Parameters:
- *      hDevObject: Handle to device object created with DEV_CreateDevice().
+ *      hdev_obj: Handle to device object created with dev_create_device().
  *      *phDehMgr:  Ptr to location to store handle.
  *  Returns:
  *      DSP_SOK:    Success.
- *      DSP_EHANDLE:   Invalid hDevObject.
+ *      DSP_EHANDLE:   Invalid hdev_obj.
  *  Requires:
  *      phDehMgr != NULL.
  *      DEH Initialized.
@@ -374,20 +312,20 @@
  *      DSP_SOK:    *phDehMgr contains a handle to a DEH manager object.
  *      else:       *phDehMgr is NULL.
  */
-       extern DSP_STATUS DEV_GetDehMgr(struct DEV_OBJECT *hDevObject,
-					      OUT struct DEH_MGR **phDehMgr);
+extern dsp_status dev_get_deh_mgr(struct dev_object *hdev_obj,
+				  OUT struct deh_mgr **phDehMgr);
 
 /*
- *  ======== DEV_GetDevNode ========
+ *  ======== dev_get_dev_node ========
  *  Purpose:
  *      Retrieve the platform specific device ID for this device.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      phDevNode:      Ptr to location to get the device node handle.
  *  Returns:
- *      DSP_SOK:        In Win95, returns a DEVNODE in *hDevNode; In NT, ???
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_SOK:        In Win95, returns a DEVNODE in *dev_node_obj; In NT, ???
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      phDevNode != NULL.
  *      DEV Initialized.
@@ -395,20 +333,20 @@
  *      DSP_SOK:        *phDevNode contains a platform specific device ID;
  *      else:           *phDevNode is NULL.
  */
-       extern DSP_STATUS DEV_GetDevNode(struct DEV_OBJECT *hDevObject,
-					OUT struct CFG_DEVNODE **phDevNode);
+extern dsp_status dev_get_dev_node(struct dev_object *hdev_obj,
+				   OUT struct cfg_devnode **phDevNode);
 
 /*
- *  ======== DEV_GetDevType ========
+ *  ======== dev_get_dev_type ========
  *  Purpose:
  *      Retrieve the platform specific device ID for this device.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      phDevNode:      Ptr to location to get the device node handle.
  *  Returns:
  *      DSP_SOK:        Success
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      phDevNode != NULL.
  *      DEV Initialized.
@@ -416,11 +354,11 @@
  *      DSP_SOK:        *phDevNode contains a platform specific device ID;
  *      else:           *phDevNode is NULL.
  */
-       extern DSP_STATUS DEV_GetDevType(struct DEV_OBJECT *hdevObject,
-					       u32 *devType);
+extern dsp_status dev_get_dev_type(struct dev_object *hdevObject,
+				   u32 *dev_type);
 
 /*
- *  ======== DEV_GetFirst ========
+ *  ======== dev_get_first ========
  *  Purpose:
  *      Retrieve the first Device Object handle from an internal linked list of
  *      of DEV_OBJECTs maintained by DEV.
@@ -429,27 +367,27 @@
  *      NULL if there are no device objects stored; else
  *      a valid DEV_HOBJECT.
  *  Requires:
- *      No calls to DEV_CreateDevice or DEV_DestroyDevice (which my modify the
- *      internal device object list) may occur between calls to DEV_GetFirst
- *      and DEV_GetNext.
+ *      No calls to dev_create_device or dev_destroy_device (which my modify the
+ *      internal device object list) may occur between calls to dev_get_first
+ *      and dev_get_next.
  *  Ensures:
  *      The DEV_HOBJECT returned is valid.
- *      A subsequent call to DEV_GetNext will return the next device object in
+ *      A subsequent call to dev_get_next will return the next device object in
  *      the list.
  */
-       extern struct DEV_OBJECT *DEV_GetFirst(void);
+extern struct dev_object *dev_get_first(void);
 
 /*
- *  ======== DEV_GetIntfFxns ========
+ *  ======== dev_get_intf_fxns ========
  *  Purpose:
  *      Retrieve the WMD interface function structure for the loaded WMD.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      *ppIntfFxns:    Ptr to location to store fxn interface.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      ppIntfFxns != NULL.
  *      DEV Initialized.
@@ -457,20 +395,20 @@
  *      DSP_SOK:        *ppIntfFxns contains a pointer to the WMD interface;
  *      else:           *ppIntfFxns is NULL.
  */
-       extern DSP_STATUS DEV_GetIntfFxns(struct DEV_OBJECT *hDevObject,
-				OUT struct WMD_DRV_INTERFACE **ppIntfFxns);
+extern dsp_status dev_get_intf_fxns(struct dev_object *hdev_obj,
+				    OUT struct bridge_drv_interface **ppIntfFxns);
 
 /*
- *  ======== DEV_GetIOMgr ========
+ *  ======== dev_get_io_mgr ========
  *  Purpose:
  *      Retrieve the handle to the IO manager created for this device.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      *phMgr:         Ptr to location to store handle.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      phMgr != NULL.
  *      DEV Initialized.
@@ -478,58 +416,58 @@
  *      DSP_SOK:        *phMgr contains a handle to an IO manager object.
  *      else:           *phMgr is NULL.
  */
-       extern DSP_STATUS DEV_GetIOMgr(struct DEV_OBJECT *hDevObject,
-					     OUT struct IO_MGR **phMgr);
+extern dsp_status dev_get_io_mgr(struct dev_object *hdev_obj,
+				 OUT struct io_mgr **phMgr);
 
 /*
- *  ======== DEV_GetNext ========
+ *  ======== dev_get_next ========
  *  Purpose:
  *      Retrieve the next Device Object handle from an internal linked list of
  *      of DEV_OBJECTs maintained by DEV, after having previously called
- *      DEV_GetFirst() and zero or more DEV_GetNext
+ *      dev_get_first() and zero or more dev_get_next
  *  Parameters:
- *      hDevObject: Handle to the device object returned from a previous
- *                  call to DEV_GetFirst() or DEV_GetNext().
+ *      hdev_obj: Handle to the device object returned from a previous
+ *                  call to dev_get_first() or dev_get_next().
  *  Returns:
- *      NULL if there are no further device objects on the list or hDevObject
+ *      NULL if there are no further device objects on the list or hdev_obj
  *      was invalid;
  *      else the next valid DEV_HOBJECT in the list.
  *  Requires:
- *      No calls to DEV_CreateDevice or DEV_DestroyDevice (which my modify the
- *      internal device object list) may occur between calls to DEV_GetFirst
- *      and DEV_GetNext.
+ *      No calls to dev_create_device or dev_destroy_device (which my modify the
+ *      internal device object list) may occur between calls to dev_get_first
+ *      and dev_get_next.
  *  Ensures:
  *      The DEV_HOBJECT returned is valid.
- *      A subsequent call to DEV_GetNext will return the next device object in
+ *      A subsequent call to dev_get_next will return the next device object in
  *      the list.
  */
-       extern struct DEV_OBJECT *DEV_GetNext(struct DEV_OBJECT
-						    *hDevObject);
+extern struct dev_object *dev_get_next(struct dev_object
+				       *hdev_obj);
 
 /*
- *  ========= DEV_GetMsgMgr ========
+ *  ========= dev_get_msg_mgr ========
  *  Purpose:
- *      Retrieve the MSG Manager Handle from the DevObject.
+ *      Retrieve the msg_ctrl Manager Handle from the DevObject.
  *  Parameters:
- *      hDevObject: Handle to the Dev Object
- *      phMsgMgr:   Location where MSG Manager handle will be returned.
+ *      hdev_obj: Handle to the Dev Object
+ *      phMsgMgr:   Location where msg_ctrl Manager handle will be returned.
  *  Returns:
  *  Requires:
  *      DEV Initialized.
- *      Valid hDevObject.
+ *      Valid hdev_obj.
  *      phNodeMgr != NULL.
  *  Ensures:
  */
-       extern void DEV_GetMsgMgr(struct DEV_OBJECT *hDevObject,
-					OUT struct MSG_MGR **phMsgMgr);
+extern void dev_get_msg_mgr(struct dev_object *hdev_obj,
+			    OUT struct msg_mgr **phMsgMgr);
 
 /*
- *  ========= DEV_GetNodeManager ========
+ *  ========= dev_get_node_manager ========
  *  Purpose:
  *      Retrieve the Node Manager Handle from the DevObject. It is an
  *      accessor function
  *  Parameters:
- *      hDevObject:     Handle to the Dev Object
+ *      hdev_obj:     Handle to the Dev Object
  *      phNodeMgr:      Location where Handle to the Node Manager will be
  *                      returned..
  *  Returns:
@@ -542,45 +480,44 @@
  *      DSP_SOK:        *phNodeMgr contains a handle to a Node manager object.
  *      else:           *phNodeMgr is NULL.
  */
-       extern DSP_STATUS DEV_GetNodeManager(struct DEV_OBJECT
-					*hDevObject,
-					OUT struct NODE_MGR **phNodeMgr);
+extern dsp_status dev_get_node_manager(struct dev_object
+				       *hdev_obj,
+				       OUT struct node_mgr **phNodeMgr);
 
 /*
- *  ======== DEV_GetSymbol ========
+ *  ======== dev_get_symbol ========
  *  Purpose:
  *      Get the value of a symbol in the currently loaded program.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *      pstrSym:        Name of symbol to look up.
- *      pulValue:       Ptr to symbol value.
+ *      pul_value:       Ptr to symbol value.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *      COD_E_NOSYMBOLSLOADED:  Symbols have not been loaded onto the board.
  *      COD_E_SYMBOLNOTFOUND:   The symbol could not be found.
  *  Requires:
  *      pstrSym != NULL.
- *      pulValue != NULL.
+ *      pul_value != NULL.
  *      DEV Initialized.
  *  Ensures:
- *      DSP_SOK:        *pulValue contains the symbol value;
+ *      DSP_SOK:        *pul_value contains the symbol value;
  */
-       extern DSP_STATUS DEV_GetSymbol(struct DEV_OBJECT *hDevObject,
-					      IN CONST char *pstrSym,
-					      OUT u32 *pulValue);
+extern dsp_status dev_get_symbol(struct dev_object *hdev_obj,
+				 IN CONST char *pstrSym, OUT u32 * pul_value);
 
 /*
- *  ======== DEV_GetWMDContext ========
+ *  ======== dev_get_wmd_context ========
  *  Purpose:
  *      Retrieve the WMD Context handle, as returned by the WMD_Create fxn.
  *  Parameters:
- *      hDevObject:     Handle to device object created with DEV_CreateDevice()
+ *      hdev_obj:     Handle to device object created with dev_create_device()
  *      *phWmdContext:  Ptr to location to store context handle.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      phWmdContext != NULL.
  *      DEV Initialized.
@@ -588,11 +525,12 @@
  *      DSP_SOK:        *phWmdContext contains context handle;
  *      else:           *phWmdContext is NULL;
  */
-       extern DSP_STATUS DEV_GetWMDContext(struct DEV_OBJECT *hDevObject,
-				OUT struct WMD_DEV_CONTEXT **phWmdContext);
+extern dsp_status dev_get_wmd_context(struct dev_object *hdev_obj,
+				      OUT struct wmd_dev_context
+				      **phWmdContext);
 
 /*
- *  ======== DEV_Exit ========
+ *  ======== dev_exit ========
  *  Purpose:
  *      Decrement reference count, and free resources when reference count is
  *      0.
@@ -603,10 +541,10 @@
  *  Ensures:
  *      When reference count == 0, DEV's private resources are freed.
  */
-       extern void DEV_Exit(void);
+extern void dev_exit(void);
 
 /*
- *  ======== DEV_Init ========
+ *  ======== dev_init ========
  *  Purpose:
  *      Initialize DEV's private state, keeping a reference count on each call.
  *  Parameters:
@@ -616,40 +554,40 @@
  *  Ensures:
  *      TRUE: A requirement for the other public DEV functions.
  */
-       extern bool DEV_Init(void);
+extern bool dev_init(void);
 
 /*
- *  ======== DEV_IsLocked ========
+ *  ======== dev_is_locked ========
  *  Purpose:
  *      Predicate function to determine if the device has been
  *      locked by a client for exclusive access.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *  Returns:
  *      DSP_SOK:        TRUE: device has been locked.
  *      DSP_SFALSE:     FALSE: device not locked.
- *      DSP_EHANDLE:    hDevObject was invalid.
+ *      DSP_EHANDLE:    hdev_obj was invalid.
  *  Requires:
  *      DEV Initialized.
  *  Ensures:
  */
-       extern DSP_STATUS DEV_IsLocked(IN struct DEV_OBJECT *hDevObject);
+extern dsp_status dev_is_locked(IN struct dev_object *hdev_obj);
 
 /*
- *  ======== DEV_InsertProcObject ========
+ *  ======== dev_insert_proc_object ========
  *  Purpose:
  *      Inserts the Processor Object into the List of PROC Objects
  *      kept in the DEV Object
  *  Parameters:
- *      hProcObject:    Handle to the Proc Object
- *      hDevObject      Handle to the Dev Object
+ *      proc_obj:    Handle to the Proc Object
+ *      hdev_obj      Handle to the Dev Object
  *      bAttachedNew    Specifies if there are already processors attached
  *  Returns:
  *      DSP_SOK:        Successfully inserted into the list
  *  Requires:
- *      hProcObject is not NULL
- *      hDevObject is a valid handle to the DEV.
+ *      proc_obj is not NULL
+ *      hdev_obj is a valid handle to the DEV.
  *      DEV Initialized.
  *      List(of Proc object in Dev) Exists.
  *  Ensures:
@@ -659,52 +597,50 @@
  *      this is the first Processor attaching.
  *      If it is False, there are already processors attached.
  */
-       extern DSP_STATUS DEV_InsertProcObject(IN struct DEV_OBJECT
-						     *hDevObject,
-						     IN u32 hProcObject,
-						     OUT bool *
-						     pbAlreadyAttached);
+extern dsp_status dev_insert_proc_object(IN struct dev_object
+					 *hdev_obj,
+					 IN u32 proc_obj,
+					 OUT bool *pbAlreadyAttached);
 
 /*
- *  ======== DEV_RemoveProcObject ========
+ *  ======== dev_remove_proc_object ========
  *  Purpose:
  *      Search for and remove a Proc object from the given list maintained
  *      by the DEV
  *  Parameters:
- *      pProcObject:        Ptr to ProcObject to insert.
- *      pDevObject:         Ptr to Dev Object where the list is.
+ *      p_proc_object:        Ptr to ProcObject to insert.
+ *      dev_obj:         Ptr to Dev Object where the list is.
  *      pbAlreadyAttached:  Ptr to return the bool
  *  Returns:
  *      DSP_SOK:            If successful.
  *      DSP_EFAIL           Failure to Remove the PROC Object from the list
  *  Requires:
  *      DevObject is Valid
- *      hProcObject != 0
- *      pDevObject->procList != NULL
- *      !LST_IsEmpty(pDevObject->procList)
+ *      proc_obj != 0
+ *      dev_obj->proc_list != NULL
+ *      !LST_IS_EMPTY(dev_obj->proc_list)
  *      pbAlreadyAttached !=NULL
  *  Ensures:
  *  Details:
  *      List will be deleted when the DEV is destroyed.
  *
  */
-       extern DSP_STATUS DEV_RemoveProcObject(struct DEV_OBJECT
-						     *hDevObject,
-						     u32 hProcObject);
+extern dsp_status dev_remove_proc_object(struct dev_object
+					 *hdev_obj, u32 proc_obj);
 
 /*
- *  ======== DEV_NotifyClients ========
+ *  ======== dev_notify_clients ========
  *  Purpose:
  *      Notify all clients of this device of a change in device status.
  *      Clients may include multiple users of BRD, as well as CHNL.
  *      This function is asychronous, and may be called by a timer event
  *      set up by a watchdog timer.
  *  Parameters:
- *      hDevObject:  Handle to device object created with DEV_CreateDevice().
+ *      hdev_obj:  Handle to device object created with dev_create_device().
  *      ulStatus:    A status word, most likely a BRD_STATUS.
  *  Returns:
  *      DSP_SOK:     All registered clients were asynchronously notified.
- *      DSP_EINVALIDARG:   Invalid hDevObject.
+ *      DSP_EINVALIDARG:   Invalid hdev_obj.
  *  Requires:
  *      DEV Initialized.
  *  Ensures:
@@ -712,67 +648,63 @@
  *      delivered to clients.  This function does not ensure that
  *      the notifications will ever be delivered.
  */
-       extern DSP_STATUS DEV_NotifyClients(struct DEV_OBJECT *hDevObject,
-						  u32 ulStatus);
-
-
+extern dsp_status dev_notify_clients(struct dev_object *hdev_obj, u32 ulStatus);
 
 /*
- *  ======== DEV_RemoveDevice ========
+ *  ======== dev_remove_device ========
  *  Purpose:
- *      Destroys the Device Object created by DEV_StartDevice.
+ *      Destroys the Device Object created by dev_start_device.
  *  Parameters:
- *      hDevNode:       Device node as it is know to OS.
+ *      dev_node_obj:       Device node as it is know to OS.
  *  Returns:
  *      DSP_SOK:        If success;
  *      <error code>    Otherwise.
  *  Requires:
  *  Ensures:
  */
-       extern DSP_STATUS DEV_RemoveDevice(struct CFG_DEVNODE *hDevNode);
+extern dsp_status dev_remove_device(struct cfg_devnode *dev_node_obj);
 
 /*
- *  ======== DEV_SetChnlMgr ========
+ *  ======== dev_set_chnl_mgr ========
  *  Purpose:
  *      Set the channel manager for this device.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
- *      hMgr:           Handle to a channel manager, or NULL.
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
+ *      hmgr:           Handle to a channel manager, or NULL.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EHANDLE:    Invalid hdev_obj.
  *  Requires:
  *      DEV Initialized.
  *  Ensures:
  */
-       extern DSP_STATUS DEV_SetChnlMgr(struct DEV_OBJECT *hDevObject,
-					       struct CHNL_MGR *hMgr);
+extern dsp_status dev_set_chnl_mgr(struct dev_object *hdev_obj,
+				   struct chnl_mgr *hmgr);
 
 /*
- *  ======== DEV_SetMsgMgr ========
+ *  ======== dev_set_msg_mgr ========
  *  Purpose:
  *      Set the Message manager for this device.
  *  Parameters:
- *      hDevObject: Handle to device object created with DEV_CreateDevice().
- *      hMgr:       Handle to a message manager, or NULL.
+ *      hdev_obj: Handle to device object created with dev_create_device().
+ *      hmgr:       Handle to a message manager, or NULL.
  *  Returns:
  *  Requires:
  *      DEV Initialized.
  *  Ensures:
  */
-       extern void DEV_SetMsgMgr(struct DEV_OBJECT *hDevObject,
-					struct MSG_MGR *hMgr);
+extern void dev_set_msg_mgr(struct dev_object *hdev_obj, struct msg_mgr *hmgr);
 
 /*
- *  ======== DEV_StartDevice ========
+ *  ======== dev_start_device ========
  *  Purpose:
  *      Initializes the new device with the WinBRIDGE environment.  This
  *      involves querying CM for allocated resources, querying the registry
  *      for necessary dsp resources (requested in the INF file), and using
  *      this information to create a WinBRIDGE device object.
  *  Parameters:
- *      hDevNode:       Device node as it is know to OS.
+ *      dev_node_obj:       Device node as it is know to OS.
  *  Returns:
  *      DSP_SOK:        If success;
  *      <error code>    Otherwise.
@@ -780,6 +712,6 @@
  *      DEV initialized.
  *  Ensures:
  */
-       extern DSP_STATUS DEV_StartDevice(struct CFG_DEVNODE *hDevNode);
+extern dsp_status dev_start_device(struct cfg_devnode *dev_node_obj);
 
-#endif				/* DEV_ */
+#endif /* DEV_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dispdefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dispdefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dispdefs.h	2011-10-11 13:50:57.602589316 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dispdefs.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global DISP constants and types, shared by PROCESSOR, NODE, and DISP.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,32 +16,20 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dispdefs.h ========
- *  Description:
- *      Global DISP constants and types, shared by PROCESSOR, NODE, and DISP.
- *
- *! Revision History
- *! ================
- *! 08-Aug-2000 jeh     Added fields to DISP_ATTRS.
- *! 06-Jul-2000 jeh     Created.
- */
-
 #ifndef DISPDEFS_
 #define DISPDEFS_
 
-	struct DISP_OBJECT;
+struct disp_object;
 
 /* Node Dispatcher attributes */
-	struct DISP_ATTRS {
-		u32 ulChnlOffset; /* Offset of channel ids reserved for RMS */
-		/* Size of buffer for sending data to RMS */
-		u32 ulChnlBufSize;
-		DSP_PROCFAMILY procFamily;	/* eg, 5000 */
-		DSP_PROCTYPE procType;	/* eg, 5510 */
-		HANDLE hReserved1;	/* Reserved for future use. */
-		u32 hReserved2;	/* Reserved for future use. */
-	} ;
+struct disp_attr {
+	u32 ul_chnl_offset;	/* Offset of channel ids reserved for RMS */
+	/* Size of buffer for sending data to RMS */
+	u32 ul_chnl_buf_size;
+	int proc_family;	/* eg, 5000 */
+	int proc_type;		/* eg, 5510 */
+	bhandle reserved1;	/* Reserved for future use. */
+	u32 reserved2;		/* Reserved for future use. */
+};
 
-#endif				/* DISPDEFS_ */
+#endif /* DISPDEFS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/disp.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/disp.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/disp.h	2011-10-11 13:50:57.609424499 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/disp.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge Node Dispatcher.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,35 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== disp.h ========
- *
- *  Description:
- *      DSP/BIOS Bridge Node Dispatcher.
- *
- *  Public Functions:
- *      DISP_Create
- *      DISP_Delete
- *      DISP_Exit
- *      DISP_Init
- *      DISP_NodeChangePriority
- *      DISP_NodeCreate
- *      DISP_NodeDelete
- *      DISP_NodeRun
- *
- *! Revision History:
- *! =================
- *! 28-Jan-2003 map     Removed DISP_DoCinit().
- *! 15-May-2002 jeh     Added DISP_DoCinit().
- *! 24-Apr-2002 jeh     Added DISP_MemWrite().
- *! 07-Sep-2001 jeh     Added DISP_MemCopy().
- *! 10-May-2001 jeh     Code review cleanup.
- *! 08-Aug-2000 jeh     Removed DISP_NodeTerminate since it no longer uses RMS.
- *! 17-Jul-2000 jeh     Updates to function headers.
- *! 19-Jun-2000 jeh     Created.
- */
-
 #ifndef DISP_
 #define DISP_
 
@@ -52,7 +25,7 @@
 #include <dspbridge/dispdefs.h>
 
 /*
- *  ======== DISP_Create ========
+ *  ======== disp_create ========
  *  Create a NODE Dispatcher object. This object handles the creation,
  *  deletion, and execution of nodes on the DSP target, through communication
  *  with the Resource Manager Server running on the target. Each NODE
@@ -60,56 +33,56 @@
  *
  *  Parameters:
  *      phDispObject:   Location to store node dispatcher object on output.
- *      hDevObject:     Device for this processor.
+ *      hdev_obj:     Device for this processor.
  *      pDispAttrs:     Node dispatcher attributes.
  *  Returns:
  *      DSP_SOK:                Success;
  *      DSP_EMEMORY:            Insufficient memory for requested resources.
  *      DSP_EFAIL:              Unable to create dispatcher.
  *  Requires:
- *      DISP_Init(void) called.
+ *      disp_init(void) called.
  *      pDispAttrs != NULL.
- *      hDevObject != NULL.
+ *      hdev_obj != NULL.
  *      phDispObject != NULL.
  *  Ensures:
- *      DSP_SOK:        IsValid(*phDispObject).
+ *      DSP_SOK:        IS_VALID(*phDispObject).
  *      error:          *phDispObject == NULL.
  */
-	extern DSP_STATUS DISP_Create(OUT struct DISP_OBJECT **phDispObject,
-				      struct DEV_OBJECT *hDevObject,
-				      IN CONST struct DISP_ATTRS *pDispAttrs);
+extern dsp_status disp_create(OUT struct disp_object **phDispObject,
+			      struct dev_object *hdev_obj,
+			      IN CONST struct disp_attr *pDispAttrs);
 
 /*
- *  ======== DISP_Delete ========
+ *  ======== disp_delete ========
  *  Delete the NODE Dispatcher.
  *
  *  Parameters:
  *      hDispObject:  Node Dispatcher object.
  *  Returns:
  *  Requires:
- *      DISP_Init(void) called.
+ *      disp_init(void) called.
  *      Valid hDispObject.
  *  Ensures:
  *      hDispObject is invalid.
  */
-	extern void DISP_Delete(struct DISP_OBJECT *hDispObject);
+extern void disp_delete(struct disp_object *hDispObject);
 
 /*
- *  ======== DISP_Exit ========
+ *  ======== disp_exit ========
  *  Discontinue usage of DISP module.
  *
  *  Parameters:
  *  Returns:
  *  Requires:
- *      DISP_Init(void) previously called.
+ *      disp_init(void) previously called.
  *  Ensures:
- *      Any resources acquired in DISP_Init(void) will be freed when last DISP
- *      client calls DISP_Exit(void).
+ *      Any resources acquired in disp_init(void) will be freed when last DISP
+ *      client calls disp_exit(void).
  */
-	extern void DISP_Exit(void);
+extern void disp_exit(void);
 
 /*
- *  ======== DISP_Init ========
+ *  ======== disp_init ========
  *  Initialize the DISP module.
  *
  *  Parameters:
@@ -117,45 +90,44 @@
  *      TRUE if initialization succeeded, FALSE otherwise.
  *  Ensures:
  */
-	extern bool DISP_Init(void);
+extern bool disp_init(void);
 
 /*
- *  ======== DISP_NodeChangePriority ========
+ *  ======== disp_node_change_priority ========
  *  Change the priority of a node currently running on the target.
  *
  *  Parameters:
  *      hDispObject:            Node Dispatcher object.
- *      hNode:                  Node object representing a node currently
+ *      hnode:                  Node object representing a node currently
  *                              allocated or running on the DSP.
  *      ulFxnAddress:           Address of RMS function for changing priority.
- *      nodeEnv:                Address of node's environment structure.
- *      nPriority:              New priority level to set node's priority to.
+ *      node_env:                Address of node's environment structure.
+ *      prio:              New priority level to set node's priority to.
  *  Returns:
  *      DSP_SOK:                Success.
  *      DSP_ETIMEOUT:           A timeout occurred before the DSP responded.
  *  Requires:
- *      DISP_Init(void) called.
+ *      disp_init(void) called.
  *      Valid hDispObject.
- *      hNode != NULL.
+ *      hnode != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS DISP_NodeChangePriority(struct DISP_OBJECT
-						  *hDispObject,
-						  struct NODE_OBJECT *hNode,
-						  u32 ulFxnAddr,
-						  NODE_ENV nodeEnv,
-						  s32 nPriority);
+extern dsp_status disp_node_change_priority(struct disp_object
+					    *hDispObject,
+					    struct node_object *hnode,
+					    u32 ul_fxn_addr,
+					    nodeenv node_env, s32 prio);
 
 /*
- *  ======== DISP_NodeCreate ========
+ *  ======== disp_node_create ========
  *  Create a node on the DSP by remotely calling the node's create function.
  *
  *  Parameters:
  *      hDispObject:    Node Dispatcher object.
- *      hNode:          Node handle obtained from NODE_Allocate().
- *      ulFxnAddr:      Address or RMS create node function.
- *      ulCreateFxn:    Address of node's create function.
- *      pArgs:          Arguments to pass to RMS node create function.
+ *      hnode:          Node handle obtained from node_allocate().
+ *      ul_fxn_addr:      Address or RMS create node function.
+ *      ul_create_fxn:    Address of node's create function.
+ *      pargs:          Arguments to pass to RMS node create function.
  *      pNodeEnv:       Location to store node environment pointer on
  *                      output.
  *  Returns:
@@ -166,71 +138,70 @@
  *      DSP_EUSER:      A user-defined failure occurred.
  *      DSP_EFAIL:      A failure occurred, unable to create node.
  *  Requires:
- *      DISP_Init(void) called.
+ *      disp_init(void) called.
  *      Valid hDispObject.
- *      pArgs != NULL.
- *      hNode != NULL.
+ *      pargs != NULL.
+ *      hnode != NULL.
  *      pNodeEnv != NULL.
- *      NODE_GetType(hNode) != NODE_DEVICE.
+ *      node_get_type(hnode) != NODE_DEVICE.
  *  Ensures:
  */
-	extern DSP_STATUS DISP_NodeCreate(struct DISP_OBJECT *hDispObject,
-					  struct NODE_OBJECT *hNode,
-					  u32 ulFxnAddr,
-					  u32 ulCreateFxn,
-					  IN CONST struct NODE_CREATEARGS
-					  *pArgs,
-					  OUT NODE_ENV *pNodeEnv);
+extern dsp_status disp_node_create(struct disp_object *hDispObject,
+				   struct node_object *hnode,
+				   u32 ul_fxn_addr,
+				   u32 ul_create_fxn,
+				   IN CONST struct node_createargs
+				   *pargs, OUT nodeenv *pNodeEnv);
 
 /*
- *  ======== DISP_NodeDelete ========
+ *  ======== disp_node_delete ========
  *  Delete a node on the DSP by remotely calling the node's delete function.
  *
  *  Parameters:
  *      hDispObject:    Node Dispatcher object.
- *      hNode:          Node object representing a node currently
+ *      hnode:          Node object representing a node currently
  *                      loaded on the DSP.
- *      ulFxnAddr:      Address or RMS delete node function.
- *      ulDeleteFxn:    Address of node's delete function.
- *      nodeEnv:        Address of node's environment structure.
+ *      ul_fxn_addr:      Address or RMS delete node function.
+ *      ul_delete_fxn:    Address of node's delete function.
+ *      node_env:        Address of node's environment structure.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_ETIMEOUT:   A timeout occurred before the DSP responded.
  *  Requires:
- *      DISP_Init(void) called.
+ *      disp_init(void) called.
  *      Valid hDispObject.
- *      hNode != NULL.
+ *      hnode != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS DISP_NodeDelete(struct DISP_OBJECT *hDispObject,
-					  struct NODE_OBJECT *hNode,
-					  u32 ulFxnAddr,
-					  u32 ulDeleteFxn, NODE_ENV nodeEnv);
+extern dsp_status disp_node_delete(struct disp_object *hDispObject,
+				   struct node_object *hnode,
+				   u32 ul_fxn_addr,
+				   u32 ul_delete_fxn, nodeenv node_env);
 
 /*
- *  ======== DISP_NodeRun ========
+ *  ======== disp_node_run ========
  *  Start execution of a node's execute phase, or resume execution of a node
  *  that has been suspended (via DISP_NodePause()) on the DSP.
  *
  *  Parameters:
  *      hDispObject:    Node Dispatcher object.
- *      hNode:          Node object representing a node to be executed
+ *      hnode:          Node object representing a node to be executed
  *                      on the DSP.
- *      ulFxnAddr:      Address or RMS node execute function.
- *      ulExecuteFxn:   Address of node's execute function.
- *      nodeEnv:        Address of node's environment structure.
+ *      ul_fxn_addr:      Address or RMS node execute function.
+ *      ul_execute_fxn:   Address of node's execute function.
+ *      node_env:        Address of node's environment structure.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_ETIMEOUT:   A timeout occurred before the DSP responded.
  *  Requires:
- *      DISP_Init(void) called.
+ *      disp_init(void) called.
  *      Valid hDispObject.
- *      hNode != NULL.
+ *      hnode != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS DISP_NodeRun(struct DISP_OBJECT *hDispObject,
-				       struct NODE_OBJECT *hNode,
-				       u32 ulFxnAddr,
-				       u32 ulExecuteFxn, NODE_ENV nodeEnv);
+extern dsp_status disp_node_run(struct disp_object *hDispObject,
+				struct node_object *hnode,
+				u32 ul_fxn_addr,
+				u32 ul_execute_fxn, nodeenv node_env);
 
-#endif				/* DISP_ */
+#endif /* DISP_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dmm.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dmm.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dmm.h	2011-10-11 13:50:57.609424499 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dmm.h	2011-08-19 18:42:45.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * The Dynamic Memory Mapping(DMM) module manages the DSP Virtual address
+ * space that can be directly mapped to any MPU buffer or memory region.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,71 +17,54 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dmm.h ========
- *  Purpose:
- *      The Dynamic Memory Mapping(DMM) module manages the DSP Virtual address
- *      space that can be directly mapped to any MPU buffer or memory region
- *
- *  Public Functions:
- *
- *! Revision History:
- *! ================
- *! 20-Feb-2004 sb: Created.
- *!
- */
-
 #ifndef DMM_
 #define DMM_
 
 #include <dspbridge/dbdefs.h>
 
-	struct DMM_OBJECT;
+struct dmm_object;
 
-/* DMM attributes used in DMM_Create() */
-	struct DMM_MGRATTRS {
-		u32 reserved;
-	} ;
+/* DMM attributes used in dmm_create() */
+struct dmm_mgrattrs {
+	u32 reserved;
+};
 
-#define DMMPOOLSIZE      0x4000000
+#define DMMPOOLSIZE      0x10000000
 
 /*
- *  ======== DMM_GetHandle ========
+ *  ======== dmm_get_handle ========
  *  Purpose:
  *      Return the dynamic memory manager object for this device.
  *      This is typically called from the client process.
  */
 
-	extern DSP_STATUS DMM_GetHandle(DSP_HPROCESSOR hProcessor,
-					OUT struct DMM_OBJECT **phDmmMgr);
+extern dsp_status dmm_get_handle(void *hprocessor,
+				 OUT struct dmm_object **phDmmMgr);
 
-	extern DSP_STATUS DMM_ReserveMemory(struct DMM_OBJECT *hDmmMgr,
-					    u32 size,
-					    u32 *pRsvAddr);
+extern dsp_status dmm_reserve_memory(struct dmm_object *dmm_mgr,
+				     u32 size, u32 *prsv_addr);
 
-	extern DSP_STATUS DMM_UnReserveMemory(struct DMM_OBJECT *hDmmMgr,
-					      u32 rsvAddr);
+extern dsp_status dmm_un_reserve_memory(struct dmm_object *dmm_mgr,
+					u32 rsv_addr);
 
-	extern DSP_STATUS DMM_MapMemory(struct DMM_OBJECT *hDmmMgr, u32 addr,
-					u32 size);
+extern dsp_status dmm_map_memory(struct dmm_object *dmm_mgr, u32 addr,
+				 u32 size);
 
-	extern DSP_STATUS DMM_UnMapMemory(struct DMM_OBJECT *hDmmMgr,
-					  u32 addr,
-					  u32 *pSize);
+extern dsp_status dmm_un_map_memory(struct dmm_object *dmm_mgr,
+				    u32 addr, u32 *psize);
 
-	extern DSP_STATUS DMM_Destroy(struct DMM_OBJECT *hDmmMgr);
+extern dsp_status dmm_destroy(struct dmm_object *dmm_mgr);
 
-	extern DSP_STATUS DMM_DeleteTables(struct DMM_OBJECT *hDmmMgr);
+extern dsp_status dmm_delete_tables(struct dmm_object *dmm_mgr);
 
-	extern DSP_STATUS DMM_Create(OUT struct DMM_OBJECT **phDmmMgr,
-				     struct DEV_OBJECT *hDevObject,
-				     IN CONST struct DMM_MGRATTRS *pMgrAttrs);
+extern dsp_status dmm_create(OUT struct dmm_object **phDmmMgr,
+			     struct dev_object *hdev_obj,
+			     IN CONST struct dmm_mgrattrs *pMgrAttrs);
 
-	extern bool DMM_Init(void);
+extern bool dmm_init(void);
 
-	extern void DMM_Exit(void);
+extern void dmm_exit(void);
 
-	extern DSP_STATUS DMM_CreateTables(struct DMM_OBJECT *hDmmMgr,
-						u32 addr, u32 size);
-#endif				/* DMM_ */
+extern dsp_status dmm_create_tables(struct dmm_object *dmm_mgr,
+				    u32 addr, u32 size);
+#endif /* DMM_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dpc.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dpc.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dpc.h	2011-10-11 13:50:57.609424499 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dpc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,167 +0,0 @@
-/*
- * dpc.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dpc.h ========
- *  Purpose:
- *      Deferred Procedure Call(DPC) Services.
- *
- *  Public Functions:
- *      DPC_Cancel
- *      DPC_Create
- *      DPC_Destroy
- *      DPC_Exit
- *      DPC_Init
- *      DPC_Schedule
- *
- *! Revision History:
- *! ================
- *! 31-Jan-2000 rr:  DPC_Destroy ensures Suceess and DPC Object is NULL.
- *! 21-Jan-2000 ag:  Updated comments per code review.
- *! 06-Jan-2000 ag:  Removed DPC_[Lower|Raise]IRQL[From|To]DispatchLevel.
- *! 14-Jan-1998 gp:  Added DPC_[Lower|Raise]IRQL[From|To]DispatchLevel.
- *! 18-Aug-1997 cr:  Added explicit CDECL identifiers.
- *! 28-Jul-1996 gp:  Created.
- */
-
-#ifndef DPC_
-#define DPC_
-
-	struct DPC_OBJECT;
-
-/*
- *  ======== DPC_PROC ========
- *  Purpose:
- *      Deferred processing routine.  Typically scheduled from an ISR to
- *      complete I/O processing.
- *  Parameters:
- *      pRefData:   Ptr to user data: passed in via ISR_ScheduleDPC.
- *  Returns:
- *  Requires:
- *      The DPC should not block, or otherwise acquire resources.
- *      Interrupts to the processor are enabled.
- *      DPC_PROC executes in a critical section.
- *  Ensures:
- *      This DPC will not be reenterred on the same thread.
- *      However, the DPC may take hardware interrupts during execution.
- *      Interrupts to the processor are enabled.
- */
-       typedef void(*DPC_PROC) (void *pRefData);
-
-/*
- *  ======== DPC_Cancel ========
- *  Purpose:
- *      Cancel a DPC previously scheduled by DPC_Schedule.
- *  Parameters:
- *      hDPC:           A DPC object handle created in DPC_Create().
- *  Returns:
- *      DSP_SOK:        Scheduled DPC, if any, is cancelled.
- *      DSP_SFALSE:     No DPC is currently scheduled for execution.
- *      DSP_EHANDLE:    Invalid hDPC.
- *  Requires:
- *  Ensures:
- *      If the DPC has already executed, is executing, or was not yet
- *      scheduled, this function will have no effect.
- */
-       extern DSP_STATUS DPC_Cancel(IN struct DPC_OBJECT *hDPC);
-
-/*
- *  ======== DPC_Create ========
- *  Purpose:
- *      Create a DPC object, allowing a client's own DPC procedure to be
- *      scheduled for a call with client reference data.
- *  Parameters:
- *      phDPC:          Pointer to location to store DPC object.
- *      pfnDPC:         Client's DPC procedure.
- *      pRefData:       Pointer to user-defined reference data.
- *  Returns:
- *      DSP_SOK:        DPC object created.
- *      DSP_EPOINTER:   phDPC == NULL or pfnDPC == NULL.
- *      DSP_EMEMORY:    Insufficient memory.
- *  Requires:
- *      Must not be called at interrupt time.
- *  Ensures:
- *      DSP_SOK: DPC object is created;
- *      else: *phDPC is set to NULL.
- */
-       extern DSP_STATUS DPC_Create(OUT struct DPC_OBJECT **phDPC,
-					   IN DPC_PROC pfnDPC,
-					   IN void *pRefData);
-
-/*
- *  ======== DPC_Destroy ========
- *  Purpose:
- *      Cancel the last scheduled DPC, and deallocate a DPC object previously
- *      allocated with DPC_Create().Frees the Object only if the thread and
- *      the events are terminated successfuly.
- *  Parameters:
- *      hDPC:           A DPC object handle created in DPC_Create().
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDPC.
- *  Requires:
- *      All DPC's scheduled for the DPC object must have completed their
- *      processing.
- *  Ensures:
- *      (SUCCESS && hDPC is NULL) or DSP_EFAILED status
- */
-       extern DSP_STATUS DPC_Destroy(IN struct DPC_OBJECT *hDPC);
-
-/*
- *  ======== DPC_Exit ========
- *  Purpose:
- *      Discontinue usage of the DPC module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      DPC_Init(void) was previously called.
- *  Ensures:
- *      Resources acquired in DPC_Init(void) are freed.
- */
-       extern void DPC_Exit(void);
-
-/*
- *  ======== DPC_Init ========
- *  Purpose:
- *      Initialize the DPC module's private state.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- *      A requirement for each of the other public DPC functions.
- */
-       extern bool DPC_Init(void);
-
-/*
- *  ======== DPC_Schedule ========
- *  Purpose:
- *      Schedule a deferred procedure call to be executed at a later time.
- *      Latency and order of DPC execution is platform specific.
- *  Parameters:
- *      hDPC:           A DPC object handle created in DPC_Create().
- *  Returns:
- *      DSP_SOK:        An event is scheduled for deferred processing.
- *      DSP_EHANDLE:    Invalid hDPC.
- *  Requires:
- *      See requirements for DPC_PROC.
- *  Ensures:
- *      DSP_SOK:        The DPC will not be called before this function returns.
- */
-       extern DSP_STATUS DPC_Schedule(IN struct DPC_OBJECT *hDPC);
-
-#endif				/* DPC_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/drvdefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/drvdefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/drvdefs.h	2011-10-11 13:50:57.609424499 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/drvdefs.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definition of common struct between wmd.h and drv.h.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,21 +16,10 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== drvdefs.h ========
- *  Purpose:
- *      Definition of common include typedef between wmd.h and drv.h.
- *
- *! Revision History:
- *! ================
- *! 17-Jul-2000 rr: Created
- */
-
 #ifndef DRVDEFS_
 #define DRVDEFS_
 
 /* WCD Driver Object */
-	struct DRV_OBJECT;
+struct drv_object;
 
-#endif				/* DRVDEFS_ */
+#endif /* DRVDEFS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/drv.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/drv.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/drv.h	2011-10-11 13:51:19.272405381 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/drv.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,10 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DRV Resource allocation module. Driver Object gets Created
+ * at the time of Loading. It holds the List of Device Objects
+ * in the system.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,55 +18,11 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== drv.h ========
- *  Purpose:
- *      DRV Resource allocation module. Driver Object gets Created
- *      at the time of Loading. It holds the List of Device Objects
- *      in the Syste,
- *
- *  Public Functions:
- *      DRV_Create
- *      DRV_Destroy
- *      DRV_Exit
- *      DRV_GetDevObject
- *      DRV_GetDevExtension
- *      DRV_GetFirstDevObject
- *      DRV_GetNextDevObject
- *      DRV_GetNextDevExtension
- *      DRV_Init
- *      DRV_InsertDevObject
- *      DRV_RemoveDevObject
- *      DRV_RequestResources
- *      DRV_ReleaseResources
- *
- *! Revision History
- *! ================
- *! 10-Feb-2004 vp:  Added OMAP24xx specific definitions.
- *! 14-Aug-2000 rr:  Cleaned up.
- *! 27-Jul-2000 rr:  DRV_RequestResources split into two(Request and Release)
- *!                  Device extension created to hold the DevNodeString.
- *! 17-Jul-2000 rr:  Driver Object holds the list of Device Objects.
- *!                  Added DRV_Create, DRV_Destroy, DRV_GetDevObject,
- *!                  DRV_GetFirst/NextDevObject, DRV_Insert/RemoveDevObject.
- *! 12-Nov-1999 rr:  New Flag defines for DRV_ASSIGN and DRV_RELEASE
- *! 25-Oct-1999 rr:  Resource Structure removed.
- *! 15-Oct-1999 rr:  New Resource structure created.
- *! 05-Oct-1999 rr:  Added DRV_RequestResources
- *!                  Removed fxn'sDRV_RegisterMiniDriver(),
- *!		     DRV_UnRegisterMiniDriver()
- *!                  Removed Structures DSP_DRIVER & DRV_EXTENSION.
- *!
- *! 24-Sep-1999 rr:  Added DRV_EXTENSION and DSP_DRIVER structures.
- *!
- */
-
 #ifndef DRV_
 #define DRV_
 
+#include <dspbridge/dbdefs.h>
 #include <dspbridge/devdefs.h>
-
 #include <dspbridge/drvdefs.h>
 
 #define DRV_ASSIGN     1
@@ -79,7 +39,6 @@
 #define OMAP_DSP_MEM1_SIZE 0x18000
 #define OMAP_DSP_GEM1_BASE 0x107F8000
 
-
 /* MEM2 is L1P RAM/CACHE space */
 #define OMAP_DSP_MEM2_BASE 0x5CE00000
 #define OMAP_DSP_MEM2_SIZE 0x8000
@@ -90,7 +49,6 @@
 #define OMAP_DSP_MEM3_SIZE 0x14000
 #define OMAP_DSP_GEM3_BASE 0x10F04000
 
-
 #define OMAP_IVA2_PRM_BASE 0x48306000
 #define OMAP_IVA2_PRM_SIZE 0x1000
 
@@ -109,98 +67,94 @@
 #define OMAP_SYSC_BASE 0x48002000
 #define OMAP_SYSC_SIZE 0x1000
 
-#define OMAP_MBOX_BASE 0x48094000
-#define OMAP_MBOX_SIZE 0x1000
-
 #define OMAP_DMMU_BASE 0x5D000000
 #define OMAP_DMMU_SIZE 0x1000
 
 #define OMAP_PRCM_VDD1_DOMAIN 1
 #define OMAP_PRCM_VDD2_DOMAIN 2
 
-#ifndef RES_CLEANUP_DISABLE
-
 /* GPP PROCESS CLEANUP Data structures */
 
 /* New structure (member of process context) abstracts NODE resource info */
-struct NODE_RES_OBJECT {
-	DSP_HNODE       hNode;
-	s32            nodeAllocated; /* Node status */
-	s32            heapAllocated; /* Heap status */
-	s32            streamsAllocated; /* Streams status */
-	struct NODE_RES_OBJECT         *next;
-} ;
+struct node_res_object {
+	void *hnode;
+	s32 node_allocated;	/* Node status */
+	s32 heap_allocated;	/* Heap status */
+	s32 streams_allocated;	/* Streams status */
+	struct node_res_object *next;
+};
+
+/* Used for DMM mapped memory accounting */
+struct dmm_map_object {
+	struct list_head link;
+	u32 dsp_addr;
+};
+
+/* Used for DMM reserved memory accounting */
+struct dmm_rsv_object {
+	struct list_head link;
+	u32 dsp_reserved_addr;
+};
 
 /* New structure (member of process context) abstracts DMM resource info */
-struct DMM_RES_OBJECT {
-	s32            dmmAllocated; /* DMM status */
-	u32           ulMpuAddr;
-	u32           ulDSPAddr;
-	u32           ulDSPResAddr;
-	u32           dmmSize;
-	HANDLE          hProcessor;
-	struct DMM_RES_OBJECT  *next;
-} ;
-
-/* New structure (member of process context) abstracts DMM resource info */
-struct DSPHEAP_RES_OBJECT {
-	s32            heapAllocated; /* DMM status */
-	u32           ulMpuAddr;
-	u32           ulDSPAddr;
-	u32           ulDSPResAddr;
-	u32           heapSize;
-	HANDLE          hProcessor;
-	struct DSPHEAP_RES_OBJECT  *next;
-} ;
+struct dspheap_res_object {
+	s32 heap_allocated;	/* DMM status */
+	u32 ul_mpu_addr;
+	u32 ul_dsp_addr;
+	u32 ul_dsp_res_addr;
+	u32 heap_size;
+	bhandle hprocessor;
+	struct dspheap_res_object *next;
+};
 
 /* New structure (member of process context) abstracts stream resource info */
-struct STRM_RES_OBJECT {
-	s32                    streamAllocated; /* Stream status */
-	DSP_HSTREAM             hStream;
-	u32                    uNumBufs;
-	u32                    uDir;
-	struct STRM_RES_OBJECT         *next;
-} ;
+struct strm_res_object {
+	s32 stream_allocated;	/* Stream status */
+	void *hstream;
+	u32 num_bufs;
+	u32 dir;
+	struct strm_res_object *next;
+};
 
 /* Overall Bridge process resource usage state */
-enum GPP_PROC_RES_STATE {
+enum gpp_proc_res_state {
 	PROC_RES_ALLOCATED,
 	PROC_RES_FREED
-} ;
+};
 
 /* Process Context */
-struct PROCESS_CONTEXT{
+struct process_context {
 	/* Process State */
-	enum GPP_PROC_RES_STATE resState;
-
-	/* Process ID (Same as UNIX process ID) */
-	u32 pid;
+	enum gpp_proc_res_state res_state;
 
-	/* Pointer to next process context
-	* (To maintain a linked list of process contexts) */
-	struct PROCESS_CONTEXT *next;
-
-	/* List of Processors */
-	struct list_head processor_list;
-	spinlock_t proc_list_lock;
+	/* Handle to Processor */
+	void *hprocessor;
 
 	/* DSP Node resources */
-	struct NODE_RES_OBJECT *pNodeList;
+	struct node_res_object *node_list;
+	struct mutex node_mutex;
 
-	/* DMM resources */
-	struct DMM_RES_OBJECT *pDMMList;
-	spinlock_t dmm_list_lock;
+	/* DMM mapped memory resources */
+	struct list_head dmm_map_list;
+	spinlock_t dmm_map_lock;
+
+	/* DMM reserved memory resources */
+	struct list_head dmm_rsv_list;
+	spinlock_t dmm_rsv_lock;
 
 	/* DSP Heap resources */
-	struct DSPHEAP_RES_OBJECT *pDSPHEAPList;
+	struct dspheap_res_object *pdspheap_list;
 
 	/* Stream resources */
-	struct STRM_RES_OBJECT *pSTRMList;
-} ;
-#endif
+	struct strm_res_object *pstrm_list;
+	struct mutex strm_mutex;
+
+	/* Policy handle */
+	void *policy;
+};
 
 /*
- *  ======== DRV_Create ========
+ *  ======== drv_create ========
  *  Purpose:
  *      Creates the Driver Object. This is done during the driver loading.
  *      There is only one Driver Object in the DSP/BIOS Bridge.
@@ -211,12 +165,12 @@
  *      DSP_EMEMORY:    Failed in Memory allocation
  *      DSP_EFAIL:      General Failure
  *  Requires:
- *      DRV Initialized (cRefs > 0 )
+ *      DRV Initialized (refs > 0 )
  *      phDrvObject != NULL.
  *  Ensures:
  *      DSP_SOK:        - *phDrvObject is a valid DRV interface to the device.
  *                      - List of DevObject Created and Initialized.
- *                      - List of DevNode String created and intialized.
+ *                      - List of dev_node String created and intialized.
  *                      - Registry is updated with the DRV Object.
  *      !DSP_SOK:       DRV Object not created
  *  Details:
@@ -226,81 +180,81 @@
  *      Also it can hold other neccessary
  *      information in its storage area.
  */
-	extern DSP_STATUS DRV_Create(struct DRV_OBJECT **phDrvObject);
+extern dsp_status drv_create(struct drv_object **phDrvObject);
 
 /*
- *  ======== DRV_Destroy ========
+ *  ======== drv_destroy ========
  *  Purpose:
  *      destroys the Dev Object list, DrvExt list
  *      and destroy the DRV object
  *      Called upon driver unLoading.or unsuccesful loading of the driver.
  *  Parameters:
- *      hDrvObject:     Handle to Driver object .
+ *      hdrv_obj:     Handle to Driver object .
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Failed to destroy DRV Object
  *  Requires:
  *      DRV Initialized (cRegs > 0 )
- *      hDrvObject is not NULL and a valid DRV handle .
+ *      hdrv_obj is not NULL and a valid DRV handle .
  *      List of DevObject is Empty.
  *      List of DrvExt is Empty
  *  Ensures:
- *      DSP_SOK:        - DRV Object destroyed and hDrvObject is not a valid
+ *      DSP_SOK:        - DRV Object destroyed and hdrv_obj is not a valid
  *                        DRV handle.
  *                      - Registry is updated with "0" as the DRV Object.
  */
-	extern DSP_STATUS DRV_Destroy(struct DRV_OBJECT *hDrvObject);
+extern dsp_status drv_destroy(struct drv_object *hdrv_obj);
 
 /*
- *  ======== DRV_Exit ========
+ *  ======== drv_exit ========
  *  Purpose:
- *      Exit the DRV module, freeing any modules initialized in DRV_Init.
+ *      Exit the DRV module, freeing any modules initialized in drv_init.
  *  Parameters:
  *  Returns:
  *  Requires:
  *  Ensures:
  */
-	extern void DRV_Exit(void);
+extern void drv_exit(void);
 
 /*
- *  ======== DRV_GetFirstDevObject ========
+ *  ======== drv_get_first_dev_object ========
  *  Purpose:
  *      Returns the Ptr to the FirstDev Object in the List
  *  Parameters:
  *  Requires:
  *      DRV Initialized
  *  Returns:
- *      dwDevObject:  Ptr to the First Dev Object as a u32
+ *      dw_dev_object:  Ptr to the First Dev Object as a u32
  *      0 if it fails to retrieve the First Dev Object
  *  Ensures:
  */
-	extern u32 DRV_GetFirstDevObject(void);
+extern u32 drv_get_first_dev_object(void);
 
 /*
- *  ======== DRV_GetFirstDevExtension ========
+ *  ======== drv_get_first_dev_extension ========
  *  Purpose:
  *      Returns the Ptr to the First Device Extension in the List
  *  Parameters:
  *  Requires:
  *      DRV Initialized
  *  Returns:
- *      dwDevExtension:     Ptr to the First Device Extension as a u32
+ *      dw_dev_extension:     Ptr to the First Device Extension as a u32
  *      0:                  Failed to Get the Device Extension
  *  Ensures:
  */
-	extern u32 DRV_GetFirstDevExtension(void);
+extern u32 drv_get_first_dev_extension(void);
 
 /*
- *  ======== DRV_GetDevObject ========
+ *  ======== drv_get_dev_object ========
  *  Purpose:
  *      Given a index, returns a handle to DevObject from the list
  *  Parameters:
- *      hDrvObject:     Handle to the Manager
+ *      hdrv_obj:     Handle to the Manager
  *      phDevObject:    Location to store the Dev Handle
  *  Requires:
  *      DRV Initialized
- *      uIndex >= 0
- *      hDrvObject is not NULL and Valid DRV Object
+ *      index >= 0
+ *      hdrv_obj is not NULL and Valid DRV Object
  *      phDevObject is not NULL
  *      Device Object List not Empty
  *  Returns:
@@ -310,28 +264,28 @@
  *      DSP_SOK:        *phDevObject != NULL
  *      DSP_EFAIL:      *phDevObject = NULL
  */
-	extern DSP_STATUS DRV_GetDevObject(u32 uIndex,
-					   struct DRV_OBJECT *hDrvObject,
-					   struct DEV_OBJECT **phDevObject);
+extern dsp_status drv_get_dev_object(u32 index,
+				     struct drv_object *hdrv_obj,
+				     struct dev_object **phDevObject);
 
 /*
- *  ======== DRV_GetNextDevObject ========
+ *  ======== drv_get_next_dev_object ========
  *  Purpose:
  *      Returns the Ptr to the Next Device Object from the the List
  *  Parameters:
- *      hDevObject:     Handle to the Device Object
+ *      hdev_obj:     Handle to the Device Object
  *  Requires:
  *      DRV Initialized
- *      hDevObject != 0
+ *      hdev_obj != 0
  *  Returns:
- *      dwDevObject:    Ptr to the Next Dev Object as a u32
+ *      dw_dev_object:    Ptr to the Next Dev Object as a u32
  *      0:              If it fail to get the next Dev Object.
  *  Ensures:
  */
-	extern u32 DRV_GetNextDevObject(u32 hDevObject);
+extern u32 drv_get_next_dev_object(u32 hdev_obj);
 
 /*
- *  ======== DRV_GetNextDevExtension ========
+ *  ======== drv_get_next_dev_extension ========
  *  Purpose:
  *      Returns the Ptr to the Next Device Extension from the the List
  *  Parameters:
@@ -340,14 +294,14 @@
  *      DRV Initialized
  *      hDevExtension != 0.
  *  Returns:
- *      dwDevExtension:     Ptr to the Next Dev Extension
+ *      dw_dev_extension:     Ptr to the Next Dev Extension
  *      0:                  If it fail to Get the next Dev Extension
  *  Ensures:
  */
-	extern u32 DRV_GetNextDevExtension(u32 hDevExtension);
+extern u32 drv_get_next_dev_extension(u32 hDevExtension);
 
 /*
- *  ======== DRV_Init ========
+ *  ======== drv_init ========
  *  Purpose:
  *      Initialize the DRV module.
  *  Parameters:
@@ -356,55 +310,55 @@
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS DRV_Init(void);
+extern dsp_status drv_init(void);
 
 /*
- *  ======== DRV_InsertDevObject ========
+ *  ======== drv_insert_dev_object ========
  *  Purpose:
  *      Insert a DeviceObject into the list of Driver object.
  *  Parameters:
- *      hDrvObject:     Handle to DrvObject
- *      hDevObject:     Handle to DeviceObject to insert.
+ *      hdrv_obj:     Handle to DrvObject
+ *      hdev_obj:     Handle to DeviceObject to insert.
  *  Returns:
  *      DSP_SOK:        If successful.
  *      DSP_EFAIL:      General Failure:
  *  Requires:
- *      hDrvObject != NULL and Valid DRV Handle.
- *      hDevObject != NULL.
+ *      hdrv_obj != NULL and Valid DRV Handle.
+ *      hdev_obj != NULL.
  *  Ensures:
  *      DSP_SOK:        Device Object is inserted and the List is not empty.
  */
-	extern DSP_STATUS DRV_InsertDevObject(struct DRV_OBJECT *hDrvObject,
-					      struct DEV_OBJECT *hDevObject);
+extern dsp_status drv_insert_dev_object(struct drv_object *hdrv_obj,
+					struct dev_object *hdev_obj);
 
 /*
- *  ======== DRV_RemoveDevObject ========
+ *  ======== drv_remove_dev_object ========
  *  Purpose:
  *      Search for and remove a Device object from the given list of Device Obj
  *      objects.
  *  Parameters:
- *      hDrvObject:     Handle to DrvObject
- *      hDevObject:     Handle to DevObject to Remove
+ *      hdrv_obj:     Handle to DrvObject
+ *      hdev_obj:     Handle to DevObject to Remove
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Unable to find pDevObject.
+ *      DSP_EFAIL:      Unable to find dev_obj.
  *  Requires:
- *      hDrvObject != NULL and a Valid DRV Handle.
- *      hDevObject != NULL.
+ *      hdrv_obj != NULL and a Valid DRV Handle.
+ *      hdev_obj != NULL.
  *      List exists and is not empty.
  *  Ensures:
  *      List either does not exist (NULL), or is not empty if it does exist.
-*/
-	extern DSP_STATUS DRV_RemoveDevObject(struct DRV_OBJECT *hDrvObject,
-					      struct DEV_OBJECT *hDevObject);
+ */
+extern dsp_status drv_remove_dev_object(struct drv_object *hdrv_obj,
+					struct dev_object *hdev_obj);
 
 /*
- *  ======== DRV_RequestResources ========
+ *  ======== drv_request_resources ========
  *  Purpose:
  *      Assigns the Resources or Releases them.
  *  Parameters:
- *      dwContext:          Path to the driver Registry Key.
- *      pDevNodeString:     Ptr to DevNode String stored in the Device Ext.
+ *      dw_context:          Path to the driver Registry Key.
+ *      pDevNodeString:     Ptr to dev_node String stored in the Device Ext.
  *  Returns:
  *      TRUE if success; FALSE otherwise.
  *  Requires:
@@ -415,16 +369,16 @@
  *      Resource structure is stored in the registry which will be
  *      later used by the CFG module.
  */
-	extern DSP_STATUS DRV_RequestResources(IN u32 dwContext,
-					       OUT u32 *pDevNodeString);
+extern dsp_status drv_request_resources(IN u32 dw_context,
+					OUT u32 *pDevNodeString);
 
 /*
- *  ======== DRV_ReleaseResources ========
+ *  ======== drv_release_resources ========
  *  Purpose:
  *      Assigns the Resources or Releases them.
  *  Parameters:
- *      dwContext:      Path to the driver Registry Key.
- *      hDrvObject:     Handle to the Driver Object.
+ *      dw_context:      Path to the driver Registry Key.
+ *      hdrv_obj:     Handle to the Driver Object.
  *  Returns:
  *      TRUE if success; FALSE otherwise.
  *  Requires:
@@ -432,20 +386,11 @@
  *      The Resources are released based on Bus type.
  *      Resource structure is deleted from the registry
  */
-	extern DSP_STATUS DRV_ReleaseResources(IN u32 dwContext,
-					       struct DRV_OBJECT *hDrvObject);
+extern dsp_status drv_release_resources(IN u32 dw_context,
+					struct drv_object *hdrv_obj);
 
-/*
- *  ======== DRV_ProcFreeDMMRes ========
- *  Purpose:
- *       Actual DMM De-Allocation.
- *  Parameters:
- *      hPCtxt:      Path to the driver Registry Key.
- *  Returns:
- *      DSP_SOK if success;
- */
-
-
-	extern DSP_STATUS  DRV_ProcFreeDMMRes(HANDLE hPCtxt);
+#ifdef CONFIG_BRIDGE_RECOVERY
+void bridge_recover_schedule(void);
+#endif
 
-#endif				/* DRV_ */
+#endif /* DRV_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dspdrv.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dspdrv.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dspdrv.h	2011-10-11 13:50:57.622110502 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dspdrv.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This is the Stream Interface for the DDSP Class driver.
+ * All Device operations are performed via DeviceIOControl.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,43 +17,13 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dspdrv.h ========
- *  Purpose:
- *      This is the Stream Interface for the DDSP Class driver.
- *      All Device operations are performed via DeviceIOControl.
- *      Read, Seek and Write not used.
- *
- *  Public Functions
- *      DSP_Close
- *      DSP_Deinit
- *      DSP_Init
- *      DSP_IOControl
- *      DSP_Open
- *      DSP_PowerUp
- *      DSP_PowerDown
- *
- *! Revision History
- *! ================
- *! 28-Jan-2000 rr: Type void changed to Void.
- *! 02-Dec-1999 rr: MAX_DEV define moved from wcdce.c file.Code cleaned up.
- *! 12-Nov-1999 rr: "#include<wncnxerr.h> removed.
- *! 05-Oct-1999 rr  Renamed the file name to wcdce.h Removed Bus Specific
- *!                 code and #defines to PCCARD.h.
- *! 24-Sep-1999 rr  Changed the DSP_COMMON_WINDOW_SIZE to 0x4000(16k) for the
- *!                 Memory windows.
- *! 16-Jul-1999 ag  Adapted from rkw's CAC Bullet driver.
- *!
- */
-
-#if !defined __DSPDRV_h__
-#define __DSPDRV_h__
+#if !defined _DSPDRV_H_
+#define _DSPDRV_H_
 
 #define MAX_DEV     10		/* Max support of 10 devices */
 
 /*
- *  ======== DSP_Deinit ========
+ *  ======== dsp_deinit ========
  *  Purpose:
  *      This function is called by Device Manager to de-initialize a device.
  *      This function is not called by applications.
@@ -65,15 +38,15 @@
  *      get called.
  *  Ensures:
  */
-extern bool DSP_Deinit(u32 dwDeviceContext);
+extern bool dsp_deinit(u32 dwDeviceContext);
 
 /*
- *  ======== DSP_Init ========
+ *  ======== dsp_init ========
  *  Purpose:
  *      This function is called by Device Manager to initialize a device.
  *      This function is not called by applications
  *  Parameters:
- *      dwContext:  Specifies a pointer to a string containing the registry
+ *      dw_context:  Specifies a pointer to a string containing the registry
  *                  path to the active key for the stream interface driver.
  *                  HKEY_LOCAL_MACHINE\Drivers\Active
  *  Returns:
@@ -84,6 +57,6 @@
  *      Succeeded:  device context > 0
  *      Failed:     device Context = 0
  */
-extern u32 DSP_Init(OUT u32 *initStatus);
+extern u32 dsp_init(OUT u32 *init_status);
 
 #endif
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dynamic_loader.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dynamic_loader.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/dynamic_loader.h	2011-10-11 13:50:57.634864592 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/dynamic_loader.h	2011-08-19 18:42:46.000000000 +0100
@@ -14,8 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-
 #ifndef _DYNAMIC_LOADER_H_
 #define _DYNAMIC_LOADER_H_
 #include <linux/kernel.h>
@@ -33,16 +31,16 @@
  * that supply the module and system specific functions it requires
  */
 	/* The read functions for the module image to be loaded */
-	struct Dynamic_Loader_Stream;
+struct dynamic_loader_stream;
 
 	/* This class defines "host" symbol and support functions */
-	struct Dynamic_Loader_Sym;
+struct dynamic_loader_sym;
 
 	/* This class defines the allocator for "target" memory */
-	struct Dynamic_Loader_Allocate;
+struct dynamic_loader_allocate;
 
 	/* This class defines the copy-into-target-memory functions */
-	struct Dynamic_Loader_Initialize;
+struct dynamic_loader_initialize;
 
 /*
  * Option flags to modify the behavior of module loading
@@ -51,10 +49,10 @@
 #define DLOAD_BIGEND 0x2	/* require big-endian load module */
 #define DLOAD_LITTLE 0x4	/* require little-endian load module */
 
-	typedef void *DLOAD_mhandle;	/* module handle for loaded modules */
+typedef void *dload_mhandle;	/* module handle for loaded modules */
 
 /*****************************************************************************
- * Procedure Dynamic_Load_Module
+ * Procedure dynamic_load_module
  *
  * Parameters:
  *  module  The input stream that supplies the module image
@@ -74,24 +72,23 @@
  * Returns:
  *  On a successful load, a module handle is placed in *mhandle, and zero is
  * returned.  On error, the number of errors detected is returned.  Individual
- * errors are reported during the load process using syms->Error_Report().
- *****************************************************************************/
-	extern int Dynamic_Load_Module(
-				       /* the source for the module image*/
-				       struct Dynamic_Loader_Stream *module,
-				       /* host support for symbols and storage*/
-				       struct Dynamic_Loader_Sym *syms,
-				       /* the target memory allocator*/
-				       struct Dynamic_Loader_Allocate *alloc,
-				       /* the target memory initializer*/
-				       struct Dynamic_Loader_Initialize *init,
-				       unsigned options,       /* option flags*/
-				       /* the returned module handle*/
-				       DLOAD_mhandle *mhandle
-	    );
+ * errors are reported during the load process using syms->error_report().
+ **************************************************************************** */
+extern int dynamic_load_module(
+				      /* the source for the module image */
+				      struct dynamic_loader_stream *module,
+				      /* host support for symbols and storage */
+				      struct dynamic_loader_sym *syms,
+				      /* the target memory allocator */
+				      struct dynamic_loader_allocate *alloc,
+				      /* the target memory initializer */
+				      struct dynamic_loader_initialize *init,
+				      unsigned options,	/* option flags */
+				      /* the returned module handle */
+				      dload_mhandle * mhandle);
 
 /*****************************************************************************
- * Procedure Dynamic_Open_Module
+ * Procedure dynamic_open_module
  *
  * Parameters:
  *  module  The input stream that supplies the module image
@@ -111,27 +108,26 @@
  * Returns:
  *  On a successful load, a module handle is placed in *mhandle, and zero is
  * returned.  On error, the number of errors detected is returned.  Individual
- * errors are reported during the load process using syms->Error_Report().
- *****************************************************************************/
-	extern int Dynamic_Open_Module(
+ * errors are reported during the load process using syms->error_report().
+ **************************************************************************** */
+extern int dynamic_open_module(
 				      /* the source for the module image */
-				      struct Dynamic_Loader_Stream *module,
+				      struct dynamic_loader_stream *module,
 				      /* host support for symbols and storage */
-				      struct Dynamic_Loader_Sym *syms,
+				      struct dynamic_loader_sym *syms,
 				      /* the target memory allocator */
-				      struct Dynamic_Loader_Allocate *alloc,
+				      struct dynamic_loader_allocate *alloc,
 				      /* the target memory initializer */
-				      struct Dynamic_Loader_Initialize *init,
-				      unsigned options, /* option flags */
+				      struct dynamic_loader_initialize *init,
+				      unsigned options,	/* option flags */
 				      /* the returned module handle */
-				      DLOAD_mhandle *mhandle
-	);
+				      dload_mhandle * mhandle);
 
 /*****************************************************************************
- * Procedure Dynamic_Unload_Module
+ * Procedure dynamic_unload_module
  *
  * Parameters:
- *  mhandle A module handle from Dynamic_Load_Module
+ *  mhandle A module handle from dynamic_load_module
  *  syms    Host-side symbol table and malloc/free functions
  *  alloc   Target-side memory allocation
  *
@@ -143,25 +139,24 @@
  *
  * Returns:
  *  Zero for success. On error, the number of errors detected is returned.
- * Individual errors are reported using syms->Error_Report().
- *****************************************************************************/
-	extern int Dynamic_Unload_Module(DLOAD_mhandle mhandle,	/* the module
-								 * handle*/
-					 /* host support for symbols and
-					  * storage */
-					 struct Dynamic_Loader_Sym *syms,
-					 /* the target memory allocator*/
-					 struct Dynamic_Loader_Allocate *alloc,
-					 /* the target memory initializer*/
-					 struct Dynamic_Loader_Initialize *init
-	    );
+ * Individual errors are reported using syms->error_report().
+ **************************************************************************** */
+extern int dynamic_unload_module(dload_mhandle mhandle,	/* the module
+							 * handle */
+				 /* host support for symbols and
+				  * storage */
+				 struct dynamic_loader_sym *syms,
+				 /* the target memory allocator */
+				 struct dynamic_loader_allocate *alloc,
+				 /* the target memory initializer */
+				 struct dynamic_loader_initialize *init);
 
 /*****************************************************************************
  *****************************************************************************
  * A class used by the dynamic loader for input of the module image
  *****************************************************************************
- *****************************************************************************/
-	struct Dynamic_Loader_Stream {
+ **************************************************************************** */
+struct dynamic_loader_stream {
 /* public: */
     /*************************************************************************
      * read_buffer
@@ -178,9 +173,9 @@
      * NOTES:
      *  In release 1 increments the file position by the number of bytes read
      *
-     *************************************************************************/
-		int (*read_buffer) (struct Dynamic_Loader_Stream *thisptr,
-				    void *buffer, unsigned bufsiz);
+     ************************************************************************ */
+	int (*read_buffer) (struct dynamic_loader_stream *thisptr,
+			    void *buffer, unsigned bufsiz);
 
     /*************************************************************************
      * set_file_posn (release 1 only)
@@ -194,33 +189,33 @@
      * the beginning of the input module.  Returns 0 for success, non-zero
      * for failure.
      *
-     *************************************************************************/
-		int (*set_file_posn) (struct Dynamic_Loader_Stream *thisptr,
-					/* to be eliminated in release 2*/
-					unsigned int posn);
+     ************************************************************************ */
+	int (*set_file_posn) (struct dynamic_loader_stream *thisptr,
+			      /* to be eliminated in release 2 */
+			      unsigned int posn);
 
-	};
+};
 
 /*****************************************************************************
  *****************************************************************************
  * A class used by the dynamic loader for symbol table support and
  * miscellaneous host-side functions
  *****************************************************************************
- *****************************************************************************/
+ **************************************************************************** */
 
-	typedef u32 LDR_ADDR;
+typedef u32 ldr_addr;
 
 /*
  * the structure of a symbol known to the dynamic loader
  */
-	struct dynload_symbol {
-		LDR_ADDR value;
-	} ;
+struct dynload_symbol {
+	ldr_addr value;
+};
 
-	struct Dynamic_Loader_Sym {
+struct dynamic_loader_sym {
 /* public: */
     /*************************************************************************
-     * Find_Matching_Symbol
+     * find_matching_symbol
      *
      * PARAMETERS :
      *  name    The name of the desired symbol
@@ -230,14 +225,12 @@
      * symbol is returned if it exists; 0 is returned if no such symbol is
      * found.
      *
-     *************************************************************************/
-		struct dynload_symbol *(*Find_Matching_Symbol)
-			(struct Dynamic_Loader_Sym *
-							 thisptr,
-							 const char *name);
+     ************************************************************************ */
+	struct dynload_symbol *(*find_matching_symbol)
+	 (struct dynamic_loader_sym *thisptr, const char *name);
 
     /*************************************************************************
-     * Add_To_Symbol_Table
+     * add_to_symbol_table
      *
      * PARAMETERS :
      *  nname       Pointer to the name of the new symbol
@@ -252,15 +245,13 @@
      * the named symbol will not be available to resolve references in
      * subsequent loads.  Returning NULL will not cause the current load
      * to fail.
-     *************************************************************************/
-		struct dynload_symbol *(*Add_To_Symbol_Table)
-						(struct Dynamic_Loader_Sym *
-							thisptr,
-							const char *nname,
-							unsigned moduleid);
+     ************************************************************************ */
+	struct dynload_symbol *(*add_to_symbol_table)
+	 (struct dynamic_loader_sym *
+	  thisptr, const char *nname, unsigned moduleid);
 
     /*************************************************************************
-     * Purge_Symbol_Table
+     * purge_symbol_table
      *
      * PARAMETERS :
      *  moduleid    An opaque module id assigned by the dynamic loader
@@ -268,12 +259,12 @@
      * EFFECT :
      *  Each symbol in the symbol table whose moduleid matches the argument
      * is removed from the table.
-     *************************************************************************/
-		void (*Purge_Symbol_Table) (struct Dynamic_Loader_Sym *thisptr,
-					    unsigned moduleid);
+     ************************************************************************ */
+	void (*purge_symbol_table) (struct dynamic_loader_sym *thisptr,
+				    unsigned moduleid);
 
     /*************************************************************************
-     * Allocate
+     * dload_allocate
      *
      * PARAMETERS :
      *  memsiz  size of desired memory in sizeof() units
@@ -283,24 +274,24 @@
      * loader, or NULL for failure.
      * This function is serves as a replaceable form of "malloc" to
      * allow the user to configure the memory usage of the dynamic loader.
-     *************************************************************************/
-		void *(*Allocate) (struct Dynamic_Loader_Sym *thisptr,
-				   unsigned memsiz);
+     ************************************************************************ */
+	void *(*dload_allocate) (struct dynamic_loader_sym *thisptr,
+				 unsigned memsiz);
 
     /*************************************************************************
-     * Deallocate
+     * dload_deallocate
      *
      * PARAMETERS :
      *  memptr  pointer to previously allocated memory
      *
      * EFFECT :
      *  Releases the previously allocated "host" memory.
-     *************************************************************************/
-		void (*Deallocate) (struct Dynamic_Loader_Sym *thisptr,
-				    void *memptr);
+     ************************************************************************ */
+	void (*dload_deallocate) (struct dynamic_loader_sym *thisptr,
+				  void *memptr);
 
     /*************************************************************************
-     * Error_Report
+     * error_report
      *
      * PARAMETERS :
      *  errstr  pointer to an error string
@@ -310,37 +301,37 @@
      *  This function provides an error reporting interface for the dynamic
      * loader.  The error string and arguments are designed as for the
      * library function vprintf.
-     *************************************************************************/
-		void (*Error_Report) (struct Dynamic_Loader_Sym *thisptr,
-				      const char *errstr, va_list args);
+     ************************************************************************ */
+	void (*error_report) (struct dynamic_loader_sym *thisptr,
+			      const char *errstr, va_list args);
 
-	};			/* class Dynamic_Loader_Sym */
+};				/* class dynamic_loader_sym */
 
 /*****************************************************************************
  *****************************************************************************
  * A class used by the dynamic loader to allocate and deallocate target memory.
  *****************************************************************************
- *****************************************************************************/
+ **************************************************************************** */
 
-	struct LDR_SECTION_INFO {
-		/* Name of the memory section assigned at build time */
-		const char *name;
-		LDR_ADDR run_addr;	/* execution address of the section */
-		LDR_ADDR load_addr;	/* load address of the section */
-		LDR_ADDR size;	/* size of the section in addressable units */
+struct ldr_section_info {
+	/* Name of the memory section assigned at build time */
+	const char *name;
+	ldr_addr run_addr;	/* execution address of the section */
+	ldr_addr load_addr;	/* load address of the section */
+	ldr_addr size;		/* size of the section in addressable units */
 #ifndef _BIG_ENDIAN
-		u16 page;	/* memory page or view */
-		u16 type;	/* one of the section types below */
+	u16 page;		/* memory page or view */
+	u16 type;		/* one of the section types below */
 #else
-		u16 type;	/* one of the section types below */
-		u16 page;	/* memory page or view */
+	u16 type;		/* one of the section types below */
+	u16 page;		/* memory page or view */
 #endif
-		/* a context field for use by Dynamic_Loader_Allocate;
-		 *   ignored but maintained by the dynamic loader */
-		u32 context;
-	} ;
+	/* a context field for use by dynamic_loader_allocate;
+	 *   ignored but maintained by the dynamic loader */
+	u32 context;
+};
 
-/* use this macro to extract type of section from LDR_SECTION_INFO.type field */
+/* use this macro to extract type of section from ldr_section_info.type field */
 #define DLOAD_SECTION_TYPE(typeinfo) (typeinfo & 0xF)
 
 /* type of section to be allocated */
@@ -350,7 +341,7 @@
 	/* internal use only, run-time cinit will be of type DLOAD_DATA */
 #define DLOAD_CINIT 3
 
-	struct Dynamic_Loader_Allocate {
+struct dynamic_loader_allocate {
 /* public: */
 
     /*************************************************************************
@@ -367,12 +358,12 @@
     *
     * Notes:
     *   Frequently load_addr and run_addr are the same, but if they are not
-    * load_addr is used with Dynamic_Loader_Initialize, and run_addr is
+    * load_addr is used with dynamic_loader_initialize, and run_addr is
     * used for almost all relocations.  This function should always initialize
     * both fields.
-    *************************************************************************/
-		int (*Allocate) (struct Dynamic_Loader_Allocate *thisptr,
-				 struct LDR_SECTION_INFO *info, unsigned align);
+    ************************************************************************ */
+	int (*dload_allocate) (struct dynamic_loader_allocate *thisptr,
+			       struct ldr_section_info *info, unsigned align);
 
     /*************************************************************************
     * Function deallocate
@@ -385,20 +376,20 @@
     *
     * Notes:
     * The content of the info->name field is undefined on call to this function.
-    *************************************************************************/
-		void (*Deallocate) (struct Dynamic_Loader_Allocate *thisptr,
-				    struct LDR_SECTION_INFO *info);
+    ************************************************************************ */
+	void (*dload_deallocate) (struct dynamic_loader_allocate *thisptr,
+				  struct ldr_section_info *info);
 
-	};			/* class Dynamic_Loader_Allocate */
+};				/* class dynamic_loader_allocate */
 
 /*****************************************************************************
  *****************************************************************************
  * A class used by the dynamic loader to load data into a target.  This class
  * provides the interface-specific functions needed to load data.
  *****************************************************************************
- *****************************************************************************/
+ **************************************************************************** */
 
-	struct Dynamic_Loader_Initialize {
+struct dynamic_loader_initialize {
 /* public: */
     /*************************************************************************
     * Function connect
@@ -413,8 +404,8 @@
     * Notes:
     *   This function is called prior to use of any other functions in
     * this interface.
-    *************************************************************************/
-		int (*connect) (struct Dynamic_Loader_Initialize *thisptr);
+    ************************************************************************ */
+	int (*connect) (struct dynamic_loader_initialize *thisptr);
 
     /*************************************************************************
     * Function readmem
@@ -428,12 +419,11 @@
     * Effect:
     *   Fills the specified buffer with data from the target.  Returns TRUE for
     * success, FALSE for failure.
-    *************************************************************************/
-		int (*readmem) (struct Dynamic_Loader_Initialize *thisptr,
-				void *bufr,
-				LDR_ADDR locn,
-				struct LDR_SECTION_INFO *info,
-				unsigned bytsiz);
+    ************************************************************************ */
+	int (*readmem) (struct dynamic_loader_initialize *thisptr,
+			void *bufr,
+			ldr_addr locn,
+			struct ldr_section_info *info, unsigned bytsiz);
 
     /*************************************************************************
     * Function writemem
@@ -447,12 +437,11 @@
     * Effect:
     *   Writes the specified buffer to the target.  Returns TRUE for success,
     * FALSE for failure.
-    *************************************************************************/
-		int (*writemem) (struct Dynamic_Loader_Initialize *thisptr,
-				 void *bufr,
-				 LDR_ADDR locn,
-				 struct LDR_SECTION_INFO *info,
-				 unsigned bytsiz);
+    ************************************************************************ */
+	int (*writemem) (struct dynamic_loader_initialize *thisptr,
+			 void *bufr,
+			 ldr_addr locn,
+			 struct ldr_section_info *info, unsigned bytsiz);
 
     /*************************************************************************
     * Function fillmem
@@ -465,10 +454,10 @@
     * Effect:
     *   Fills the specified area of target memory.  Returns TRUE for success,
     * FALSE for failure.
-    *************************************************************************/
-		int (*fillmem) (struct Dynamic_Loader_Initialize *thisptr,
-				LDR_ADDR locn, struct LDR_SECTION_INFO *info,
-				unsigned bytsiz, unsigned val);
+    ************************************************************************ */
+	int (*fillmem) (struct dynamic_loader_initialize *thisptr,
+			ldr_addr locn, struct ldr_section_info *info,
+			unsigned bytsiz, unsigned val);
 
     /*************************************************************************
     * Function execute
@@ -482,9 +471,9 @@
     * Notes:
     *   This function is called at the end of the dynamic load process
     * if the input module has specified a starting address.
-    *************************************************************************/
-		int (*execute) (struct Dynamic_Loader_Initialize *thisptr,
-				LDR_ADDR start);
+    ************************************************************************ */
+	int (*execute) (struct dynamic_loader_initialize *thisptr,
+			ldr_addr start);
 
     /*************************************************************************
     * Function release
@@ -497,9 +486,9 @@
     *
     * Notes:
     *   This function is called at the end of the dynamic load process.
-    *************************************************************************/
-		void (*release) (struct Dynamic_Loader_Initialize *thisptr);
+    ************************************************************************ */
+	void (*release) (struct dynamic_loader_initialize *thisptr);
 
-	};			/* class Dynamic_Loader_Initialize */
+};				/* class dynamic_loader_initialize */
 
-#endif				/* _DYNAMIC_LOADER_H_ */
+#endif /* _DYNAMIC_LOADER_H_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/errbase.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/errbase.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/errbase.h	2011-10-11 13:50:57.663130211 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/errbase.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,14 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Central repository for DSP/BIOS Bridge error and status code.
+ *
+ * Error codes are of the form:
+ *     [<MODULE>]_E<ERRORCODE>
+ *
+ * Success codes are of the form:
+ *     [<MODULE>]_S<SUCCESSCODE>
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,44 +22,15 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== errbase.h ========
- *  Description:
- *      Central repository for DSP/BIOS Bridge error and status code.
- *
- *  Error codes are of the form:
- *      [<MODULE>]_E<ERRORCODE>
- *
- *  Success codes are of the form:
- *      [<MODULE>]_S<SUCCESSCODE>
- *
- *! Revision History:
- *! ================
- *! 24-Jan-2003 map Added DSP_SALREADYLOADED for persistent library checking
- *! 23-Nov-2002 gp: Minor comment cleanup.
- *! 13-May-2002 sg  Added DSP_SALREADYASLEEP and DSP_SALREADYWAKE.
- *! 18-Feb-2002 mk: Added DSP_EOVERLAYMEMORY, EFWRITE, ENOSECT.
- *! 31-Jan-2002 mk: Added definitions of DSP_STRUE and DSP_SFALSE.
- *! 29-Jan-2002 mk: Added definition of CFG_E_INSUFFICIENTBUFSIZE.
- *! 24-Oct-2001 sp: Consolidated all the error codes into this file.
- *! 24-Jul-2001 mk: Type-casted all definitions of WSX_STATUS types for
- *!                 removal of compile warnings.
- *! 22-Nov-1999 kc: Changes from code review.
- *! 18-Aug-1999 rr: Ported From WSX.
- *! 29-May-1996 gp: Removed WCD_ and WMD_ error ranges. Redefined format of
- *!                 error codes.
- *! 10-May-1996 gp: Created.
- */
-
 #ifndef ERRBASE_
 #define ERRBASE_
 
 /* Base of generic errors and component errors */
-#define DSP_SBASE               (DSP_STATUS)0x00008000
-#define DSP_EBASE               (DSP_STATUS)0x80008000
+#define DSP_SBASE               (dsp_status)0x00008000
+#define DSP_EBASE               (dsp_status)0x80008000
 
-#define DSP_COMP_EBASE          (DSP_STATUS)0x80040200
-#define DSP_COMP_ELAST          (DSP_STATUS)0x80047fff
+#define DSP_COMP_EBASE          (dsp_status)0x80040200
+#define DSP_COMP_ELAST          (dsp_status)0x80047fff
 
 /* SUCCESS Codes */
 
@@ -183,7 +162,7 @@
  * found in the COFF file. */
 #define DSP_ESYMBOL                 (DSP_EBASE + 0x1c)
 
-/* UUID not found in registry.  */
+/* UUID not found in registry. */
 #define DSP_EUUID                   (DSP_EBASE + 0x1d)
 
 /* Unable to read content of DCD data section ; this is typically caused by
@@ -221,7 +200,7 @@
 /* Multiple instances are not allowed. */
 #define DSP_EMULINST                (DSP_EBASE + 0x2c)
 
-/* A specified entity was not found.  */
+/* A specified entity was not found. */
 #define DSP_ENOTFOUND               (DSP_EBASE + 0x2d)
 
 /* A DSP I/O resource is not available. */
@@ -291,7 +270,7 @@
 /* The mini-driver expected a newer version of the class driver. */
 #define DEV_E_NEWWMD                (DEV_EBASE + 0x00)
 
-/* WMD_DRV_Entry function returned a NULL function interface table. */
+/* bridge_drv_entry function returned a NULL function interface table. */
 #define DEV_E_NULLWMDINTF           (DEV_EBASE + 0x01)
 
 /* FAILURE Codes : LDR */
@@ -324,21 +303,6 @@
 /* Insufficient buffer size */
 #define CFG_E_INSUFFICIENTBUFSIZE   (CFG_EBASE + 0x05)
 
-/* FAILURE Codes : BRD */
-#define BRD_EBASE                   (DSP_COMP_EBASE + 0x300)
-
-/* Board client does not have sufficient access rights for this operation. */
-#define BRD_E_ACCESSDENIED          (BRD_EBASE + 0x00)
-
-/* Unable to find trace buffer symbols in the DSP executable COFF file. */
-#define BRD_E_NOTRACEBUFFER         (BRD_EBASE + 0x01)
-
-/* Attempted to auto-start board, but no default DSP executable configured. */
-#define BRD_E_NOEXEC                (BRD_EBASE + 0x02)
-
-/* The operation failed because it was started from a wrong state */
-#define BRD_E_WRONGSTATE            (BRD_EBASE + 0x03)
-
 /* FAILURE Codes : COD */
 #define COD_EBASE                   (DSP_COMP_EBASE + 0x400)
 
@@ -431,7 +395,7 @@
 /* Wait for flush operation on an output channel timed out. */
 #define CHNL_E_WAITTIMEOUT          (CHNL_EBASE + 0x15)
 
-/* User supplied hEvent must be specified with pstrEventName attribute */
+/* User supplied event_obj must be specified with pstr_event_name attribute */
 #define CHNL_E_BADUSEREVENT         (CHNL_EBASE + 0x16)
 
 /* Illegal user event name specified */
@@ -479,31 +443,4 @@
 /* Insufficient space to hold data in registry value. */
 #define REG_E_MOREDATA              (REG_EBASE + 0x03)
 
-/* FAILURE Codes : KFILE */
-#define KFILE_EBASE                 (DSP_COMP_EBASE + 0x900)
-
-/* Invalid file handle. */
-#define E_KFILE_INVALIDHANDLE       (KFILE_EBASE + 0x01)
-
-/* Bad file name. */
-#define E_KFILE_BADFILENAME         (KFILE_EBASE + 0x02)
-
-/* Invalid file mode. */
-#define E_KFILE_INVALIDMODE         (KFILE_EBASE + 0x03)
-
-/* No resources available. */
-#define E_KFILE_NORESOURCES         (KFILE_EBASE + 0x04)
-
-/* Invalid file buffer        . */
-#define E_KFILE_INVALIDBUFFER       (KFILE_EBASE + 0x05)
-
-/* Bad origin argument. */
-#define E_KFILE_BADORIGINFLAG       (KFILE_EBASE + 0x06)
-
-/* Invalid file offset value. */
-#define E_KFILE_INVALIDOFFSET       (KFILE_EBASE + 0x07)
-
-/* General KFILE error condition */
-#define E_KFILE_ERROR               (KFILE_EBASE + 0x08)
-
-#endif				/* ERRBASE_ */
+#endif /* ERRBASE_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/gb.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/gb.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/gb.h	2011-10-11 13:50:57.663130211 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/gb.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Generic bitmap manager.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,72 +16,64 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== gb.h ========
- *  Generic bitmap manager.
- *
- *! Revision History
- *! ================
- */
-
 #ifndef GB_
 #define GB_
 
 #define GB_NOBITS (~0)
 #include <dspbridge/host_os.h>
-typedef s32 GB_BitNum;
-struct GB_TMap;
+typedef s32 gb_bit_num;
+struct gb_t_map;
 
 /*
- *  ======== GB_clear ========
+ *  ======== gb_clear ========
  *  Clear the bit in position bitn in the bitmap map.  Bit positions are
  *  zero based.
  */
 
-extern void GB_clear(struct GB_TMap *map, GB_BitNum bitn);
+extern void gb_clear(struct gb_t_map *map, gb_bit_num bitn);
 
 /*
- *  ======== GB_create ========
+ *  ======== gb_create ========
  *  Create a bit map with len bits.  Initially all bits are cleared.
  */
 
-extern struct GB_TMap *GB_create(GB_BitNum len);
+extern struct gb_t_map *gb_create(gb_bit_num len);
 
 /*
- *  ======== GB_delete ========
+ *  ======== gb_delete ========
  *  Delete previously created bit map
  */
 
-extern void GB_delete(struct GB_TMap *map);
+extern void gb_delete(struct gb_t_map *map);
 
 /*
- *  ======== GB_findandset ========
+ *  ======== gb_findandset ========
  *  Finds a clear bit, sets it, and returns the position
  */
 
-extern GB_BitNum GB_findandset(struct GB_TMap *map);
+extern gb_bit_num gb_findandset(struct gb_t_map *map);
 
 /*
- *  ======== GB_minclear ========
- *  GB_minclear returns the minimum clear bit position.  If no bit is
- *  clear, GB_minclear returns -1.
+ *  ======== gb_minclear ========
+ *  gb_minclear returns the minimum clear bit position.  If no bit is
+ *  clear, gb_minclear returns -1.
  */
-extern GB_BitNum GB_minclear(struct GB_TMap *map);
+extern gb_bit_num gb_minclear(struct gb_t_map *map);
 
 /*
- *  ======== GB_set ========
+ *  ======== gb_set ========
  *  Set the bit in position bitn in the bitmap map.  Bit positions are
  *  zero based.
  */
 
-extern void GB_set(struct GB_TMap *map, GB_BitNum bitn);
+extern void gb_set(struct gb_t_map *map, gb_bit_num bitn);
 
 /*
- *  ======== GB_test ========
+ *  ======== gb_test ========
  *  Returns TRUE if the bit in position bitn is set in map; otherwise
- *  GB_test returns FALSE.  Bit positions are zero based.
+ *  gb_test returns FALSE.  Bit positions are zero based.
  */
 
-extern bool GB_test(struct GB_TMap *map, GB_BitNum bitn);
+extern bool gb_test(struct gb_t_map *map, gb_bit_num bitn);
 
-#endif				/*GB_ */
+#endif /*GB_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/getsection.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/getsection.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/getsection.h	2011-10-11 13:50:57.699261250 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/getsection.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,14 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This file provides an API add-on to the dynamic loader that allows the user
+ * to query section information and extract section data from dynamic load
+ * modules.
+ *
+ * Notes:
+ *   Functions in this API assume that the supplied dynamic_loader_stream
+ *   object supports the set_file_posn method.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,30 +22,16 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
 #ifndef _GETSECTION_H_
 #define _GETSECTION_H_
 
-
 #include "dynamic_loader.h"
 
-/*
- * Get Section Information
- *
- * This file provides an API add-on to the dynamic loader that allows the user
- * to query section information and extract section data from dynamic load
- * modules.
- *
- * NOTE:
- * Functions in this API assume that the supplied Dynamic_Loader_Stream object
- * supports the set_file_posn method.
- */
-
 	/* opaque handle for module information */
-	typedef void *DLOAD_module_info;
+typedef void *dload_module_info;
 
 /*
- * Procedure DLOAD_module_open
+ * Procedure dload_module_open
  *
  * Parameters:
  *  module  The input stream that supplies the module image
@@ -54,36 +48,35 @@
  *  NULL if an error is encountered, otherwise a module handle for use
  * in subsequent operations.
  */
-	extern DLOAD_module_info DLOAD_module_open(struct Dynamic_Loader_Stream
-						   *module,
-						   struct Dynamic_Loader_Sym
-						   *syms);
+extern dload_module_info dload_module_open(struct dynamic_loader_stream
+					   *module, struct dynamic_loader_sym
+					   *syms);
 
 /*
- * Procedure DLOAD_GetSectionInfo
+ * Procedure dload_get_section_info
  *
  * Parameters:
- *  minfo       Handle from DLOAD_module_open for this module
+ *  minfo       Handle from dload_module_open for this module
  *  sectionName Pointer to the string name of the section desired
  *  sectionInfo Address of a section info structure pointer to be initialized
  *
  * Effect:
  *  Finds the specified section in the module information, and fills in
- * the provided LDR_SECTION_INFO structure.
+ * the provided ldr_section_info structure.
  *
  * Returns:
  *  TRUE for success, FALSE for section not found
  */
-	extern int DLOAD_GetSectionInfo(DLOAD_module_info minfo,
-					const char *sectionName,
-					const struct LDR_SECTION_INFO
-					** const sectionInfo);
+extern int dload_get_section_info(dload_module_info minfo,
+				  const char *sectionName,
+				  const struct ldr_section_info
+				  **const sectionInfo);
 
 /*
- * Procedure DLOAD_GetSection
+ * Procedure dload_get_section
  *
  * Parameters:
- *  minfo       Handle from DLOAD_module_open for this module
+ *  minfo       Handle from dload_module_open for this module
  *  sectionInfo Pointer to a section info structure for the desired section
  *  sectionData Buffer to contain the section initialized data
  *
@@ -94,15 +87,15 @@
  * Returns:
  *  TRUE for success, FALSE for section not found
  */
-	extern int DLOAD_GetSection(DLOAD_module_info minfo,
-				    const struct LDR_SECTION_INFO *sectionInfo,
-				    void *sectionData);
+extern int dload_get_section(dload_module_info minfo,
+			     const struct ldr_section_info *sectionInfo,
+			     void *sectionData);
 
 /*
- * Procedure DLOAD_module_close
+ * Procedure dload_module_close
  *
  * Parameters:
- *  minfo       Handle from DLOAD_module_open for this module
+ *  minfo       Handle from dload_module_open for this module
  *
  * Effect:
  *  Releases any storage associated with the module handle.  On return,
@@ -110,9 +103,9 @@
  *
  * Returns:
  *  Zero for success. On error, the number of errors detected is returned.
- * Individual errors are reported using syms->Error_Report(), where syms was
- * an argument to DLOAD_module_open
+ * Individual errors are reported using syms->error_report(), where syms was
+ * an argument to dload_module_open
  */
-	extern void DLOAD_module_close(DLOAD_module_info minfo);
+extern void dload_module_close(dload_module_info minfo);
 
-#endif				/* _GETSECTION_H_ */
+#endif /* _GETSECTION_H_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/gh.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/gh.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/gh.h	2011-10-11 13:50:57.699261250 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/gh.h	2011-08-19 18:42:46.000000000 +0100
@@ -14,24 +14,17 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== gh.h ========
- *
- *! Revision History
- *! ================
- */
-
 #ifndef GH_
 #define GH_
 #include <dspbridge/host_os.h>
 
-extern struct GH_THashTab *GH_create(u16 maxBucket, u16 valSize,
-		u16(*hash) (void *, u16), bool(*match) (void *, void *),
-		void(*delete) (void *));
-extern void GH_delete(struct GH_THashTab *hashTab);
-extern void GH_exit(void);
-extern void *GH_find(struct GH_THashTab *hashTab, void *key);
-extern void GH_init(void);
-extern void *GH_insert(struct GH_THashTab *hashTab, void *key, void *value);
-#endif				/* GH_ */
+extern struct gh_t_hash_tab *gh_create(u16 max_bucket, u16 val_size,
+				       u16(*hash) (void *, u16),
+				       bool(*match) (void *, void *),
+				       void (*delete) (void *));
+extern void gh_delete(struct gh_t_hash_tab *hash_tab);
+extern void gh_exit(void);
+extern void *gh_find(struct gh_t_hash_tab *hash_tab, void *key);
+extern void gh_init(void);
+extern void *gh_insert(struct gh_t_hash_tab *hash_tab, void *key, void *value);
+#endif /* GH_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/gs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/gs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/gs.h	2011-10-11 13:50:57.703175692 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/gs.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,11 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Memory allocation/release wrappers.  This module allows clients to
+ * avoid OS spacific issues related to memory allocation.  It also provides
+ * simple diagnostic capabilities to assist in the detection of memory
+ * leaks.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,51 +19,41 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== gs.h ========
- *  Memory allocation/release wrappers.  This module allows clients to
- *  avoid OS spacific issues related to memory allocation.  It also provides
- *  simple diagnostic capabilities to assist in the detection of memory
- *  leaks.
- *! Revision History
- *! ================
- */
-
 #ifndef GS_
 #define GS_
 
 /*
- *  ======== GS_alloc ========
+ *  ======== gs_alloc ========
  *  Alloc size bytes of space.  Returns pointer to space
  *  allocated, otherwise NULL.
  */
-extern void *GS_alloc(u32 size);
+extern void *gs_alloc(u32 size);
 
 /*
- *  ======== GS_exit ========
- *  Module exit.  Do not change to "#define GS_init()"; in
+ *  ======== gs_exit ========
+ *  Module exit.  Do not change to "#define gs_init()"; in
  *  some environments this operation must actually do some work!
  */
-extern void GS_exit(void);
+extern void gs_exit(void);
 
 /*
- *  ======== GS_free ========
- *  Free space allocated by GS_alloc() or GS_calloc().
+ *  ======== gs_free ========
+ *  Free space allocated by gs_alloc() or GS_calloc().
  */
-extern void GS_free(void *ptr);
+extern void gs_free(void *ptr);
 
 /*
- *  ======== GS_frees ========
- *  Free space allocated by GS_alloc() or GS_calloc() and assert that
+ *  ======== gs_frees ========
+ *  Free space allocated by gs_alloc() or GS_calloc() and assert that
  *  the size of the allocation is size bytes.
  */
-extern void GS_frees(void *ptr, u32 size);
+extern void gs_frees(void *ptr, u32 size);
 
 /*
- *  ======== GS_init ========
- *  Module initialization.  Do not change to "#define GS_init()"; in
+ *  ======== gs_init ========
+ *  Module initialization.  Do not change to "#define gs_init()"; in
  *  some environments this operation must actually do some work!
  */
-extern void GS_init(void);
+extern void gs_init(void);
 
-#endif				/*GS_ */
+#endif /*GS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/gt.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/gt.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/gt.h	2011-10-11 13:50:57.703175692 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/gt.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,317 +0,0 @@
-/*
- * gt.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== gt.h ========
- *  Purpose:
- *      There are two definitions that affect which portions of trace
- *      are acutally compiled into the client: GT_TRACE and GT_ASSERT. If
- *      GT_TRACE is set to 0 then all trace statements (except for assertions)
- *      will be compiled out of the client. If GT_ASSERT is set to 0 then
- *      assertions will be compiled out of the client. GT_ASSERT can not be
- *      set to 0 unless GT_TRACE is also set to 0 (i.e. GT_TRACE == 1 implies
- *      GT_ASSERT == 1).
- *
- *! Revision History
- *! ================
- *! 02-Feb-2000 rr: Renamed this file to gtce.h. GT CLASS and trace definitions
- *!                 are WinCE Specific.
- *! 03-Jan-1997	ge	Replaced "GT_" prefix to GT_Config structure members
- *!                 to eliminate preprocessor confusion with other macros.
- */
-#include <linux/types.h>
-#ifndef GT_
-#define GT_
-
-#ifndef GT_TRACE
-#define GT_TRACE 0	    /* 0 = "trace compiled out"; 1 = "trace active" */
-#endif
-
-#include <dspbridge/host_os.h>
-
-#if !defined(GT_ASSERT) || GT_TRACE
-#define GT_ASSERT 1
-#endif
-
-struct GT_Config {
-	Fxn PRINTFXN;
-	Fxn PIDFXN;
-	Fxn TIDFXN;
-	Fxn ERRORFXN;
-};
-
-extern struct GT_Config *GT;
-
-struct GT_Mask {
-	char *modName;
-	u8 *flags;
-} ;
-
-/*
- *  New GT Class defenitions.
- *
- *  The following are the explanations and how it could be used in the code
- *
- *  -   GT_ENTER    On Entry to Functions
- *
- *  -   GT_1CLASS   Display level of debugging status- Object/Automatic
- *                  variables
- *  -   GT_2CLASS   ---- do ----
- *
- *  -   GT_3CLASS   ---- do ---- + It can be used(recommended) for debug
- *		    status in the ISR, IST
- *  -   GT_4CLASS   ---- do ----
- *
- *  -   GT_5CLASS   Display entry for module init/exit functions
- *
- *  -   GT_6CLASS   Warn whenever SERVICES function fails
- *
- *  -   GT_7CLASS   Warn failure of Critical failures
- *
- */
-
-#define GT_ENTER	((u8)0x01)
-#define GT_1CLASS	((u8)0x02)
-#define GT_2CLASS	((u8)0x04)
-#define GT_3CLASS	((u8)0x08)
-#define GT_4CLASS	((u8)0x10)
-#define GT_5CLASS	((u8)0x20)
-#define GT_6CLASS	((u8)0x40)
-#define GT_7CLASS	((u8)0x80)
-
-#ifdef _LINT_
-
-/* LINTLIBRARY */
-
-/*
- *  ======== GT_assert ========
- */
-/* ARGSUSED */
-void GT_assert(struct GT_Mask mask, s32 expr)
-{
-}
-
-/*
- *  ======== GT_config ========
- */
-/* ARGSUSED */
-void GT_config(struct GT_Config config)
-{
-}
-
-/*
- *  ======== GT_create ========
- */
-/* ARGSUSED */
-void GT_create(struct GT_Mask *mask, char *modName)
-{
-}
-
-/*
- *  ======== GT_curLine ========
- *  Purpose:
- *      Returns the current source code line number. Is useful for performing
- *      branch testing using trace.  For example,
- *
- *      GT_1trace(curTrace, GT_1CLASS,
- *          "in module XX_mod, executing line %u\n", GT_curLine());
- */
-/* ARGSUSED */
-u16 GT_curLine(void)
-{
-	return (u16)NULL;
-}
-
-/*
- *  ======== GT_exit ========
- */
-/* ARGSUSED */
-void GT_exit(void)
-{
-}
-
-/*
- *  ======== GT_init ========
- */
-/* ARGSUSED */
-void GT_init(void)
-{
-}
-
-/*
- *  ======== GT_query ========
- */
-/* ARGSUSED */
-bool GT_query(struct GT_Mask mask, u8 class)
-{
-	return false;
-}
-
-/*
- *  ======== GT_set ========
- *  sets trace mask according to settings
- */
-
-/* ARGSUSED */
-void GT_set(char *settings)
-{
-}
-
-/*
- *  ======== GT_setprintf ========
- *  sets printf function
- */
-
-/* ARGSUSED */
-void GT_setprintf(Fxn fxn)
-{
-}
-
-/* ARGSUSED */
-void GT_0trace(struct GT_Mask mask, u8 class, char *format)
-{
-}
-
-/* ARGSUSED */
-void GT_1trace(struct GT_Mask mask, u8 class, char *format, ...)
-{
-}
-
-/* ARGSUSED */
-void GT_2trace(struct GT_Mask mask, u8 class, char *format, ...)
-{
-}
-
-/* ARGSUSED */
-void GT_3trace(struct GT_Mask mask, u8 class, char *format, ...)
-{
-}
-
-/* ARGSUSED */
-void GT_4trace(struct GT_Mask mask, u8 class, char *format, ...)
-{
-}
-
-/* ARGSUSED */
-void GT_5trace(struct GT_Mask mask, u8 class, char *format, ...)
-{
-}
-
-/* ARGSUSED */
-void GT_6trace(struct GT_Mask mask, u8 class, char *format, ...)
-{
-}
-
-#else
-
-#define	GT_BOUND    26		/* 26 letters in alphabet */
-
-extern void _GT_create(struct GT_Mask *mask, char *modName);
-
-#define GT_exit()
-
-extern void GT_init(void);
-extern void _GT_set(char *str);
-extern s32 _GT_trace(struct GT_Mask *mask, char *format, ...);
-
-#if GT_ASSERT == 0
-
-#define GT_assert(mask, expr)
-#define GT_config(config)
-#define GT_configInit(config)
-#define GT_seterror(fxn)
-
-#else
-
-extern struct GT_Config _GT_params;
-
-#define GT_assert(mask, expr) \
-	(!(expr) ? \
-	    printk("assertion violation: %s, line %d\n", \
-			    __FILE__, __LINE__), NULL : NULL)
-
-#define GT_config(config)     (_GT_params = *(config))
-#define GT_configInit(config) (*(config) = _GT_params)
-#define GT_seterror(fxn)      (_GT_params.ERRORFXN = (Fxn)(fxn))
-
-#endif
-
-#if GT_TRACE == 0
-
-#define GT_curLine()                ((u16)__LINE__)
-#define GT_create(mask, modName)
-#define GT_exit()
-#define GT_init()
-#define GT_set(settings)
-#define GT_setprintf(fxn)
-
-#define GT_query(mask, class)     false
-
-#define GT_0trace(mask, class, format) do {} while (0)
-#define GT_1trace(mask, class, format, arg1) do {} while (0)
-#define GT_2trace(mask, class, format, arg1, arg2) do {} while (0)
-#define GT_3trace(mask, class, format, arg1, arg2, arg3) do {} while (0)
-#define GT_4trace(mask, class, format, arg1, arg2, arg3, arg4) do {} while (0)
-#define GT_5trace(mask, class, format, arg1, arg2, arg3, arg4, arg5) \
-	do {} while (0)
-#define GT_6trace(mask, class, format, arg1, arg2, arg3, arg4, arg5, arg6) \
-	do {} while (0)
-
-#else				/* GT_TRACE == 1 */
-
-
-#define GT_create(mask, modName)    _GT_create((mask), (modName))
-#define GT_curLine()                ((u16)__LINE__)
-#define GT_set(settings)          _GT_set(settings)
-#define GT_setprintf(fxn)         (_GT_params.PRINTFXN = (Fxn)(fxn))
-
-#define GT_query(mask, class) ((*(mask).flags & (class)))
-
-#define GT_0trace(mask, class, format) \
-    ((*(mask).flags & (class)) ? \
-    _GT_trace(&(mask), (format)) : 0)
-
-#define GT_1trace(mask, class, format, arg1) \
-    ((*(mask).flags & (class)) ? \
-    _GT_trace(&(mask), (format), (arg1)) : 0)
-
-#define GT_2trace(mask, class, format, arg1, arg2) \
-    ((*(mask).flags & (class)) ? \
-    _GT_trace(&(mask), (format), (arg1), (arg2)) : 0)
-
-#define GT_3trace(mask, class, format, arg1, arg2, arg3) \
-    ((*(mask).flags & (class)) ? \
-    _GT_trace(&(mask), (format), (arg1), (arg2), (arg3)) : 0)
-
-#define GT_4trace(mask, class, format, arg1, arg2, arg3, arg4) \
-    ((*(mask).flags & (class)) ? \
-    _GT_trace(&(mask), (format), (arg1), (arg2), (arg3), (arg4)) : 0)
-
-#define GT_5trace(mask, class, format, arg1, arg2, arg3, arg4, arg5) \
-    ((*(mask).flags & (class)) ? \
-    _GT_trace(&(mask), (format), (arg1), (arg2), (arg3), (arg4), (arg5)) : 0)
-
-#define GT_6trace(mask, class, format, arg1, arg2, arg3, arg4, arg5, arg6) \
-    ((*(mask).flags & (class)) ? \
-    _GT_trace(&(mask), (format), (arg1), (arg2), (arg3), (arg4), (arg5), \
-	(arg6)) : 0)
-
-#endif				/* GT_TRACE */
-
-#endif				/* _LINT_ */
-
-#endif				/* GTCE_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/host_os.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/host_os.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/host_os.h	2011-10-11 13:50:57.713203334 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/host_os.h	2011-10-29 20:21:28.831718000 +0100
@@ -14,20 +14,9 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== windows.h ========
- *
- *! Revision History
- *! ================
- *! 08-Mar-2004 sb Added cacheflush.h to support Dynamic Memory Mapping feature
- *! 16-Feb-2004 sb Added headers required for consistent_alloc
- */
-
 #ifndef _HOST_OS_H_
 #define _HOST_OS_H_
 
-#include <linux/autoconf.h>
 #include <asm/system.h>
 #include <asm/atomic.h>
 #include <linux/semaphore.h>
@@ -56,20 +45,38 @@
 #include <dspbridge/dbtype.h>
 #include <mach/clock.h>
 #include <linux/clk.h>
+#include <mach/mailbox.h>
 #include <linux/pagemap.h>
 #include <asm/cacheflush.h>
 #include <linux/dma-mapping.h>
 
 /* TODO -- Remove, once BP defines them */
-#define INT_MAIL_MPU_IRQ        26
 #define INT_DSP_MMU_IRQ        28
 
+struct dsp_shm_freq_table {
+	unsigned long u_volts;
+	unsigned long dsp_freq;
+	unsigned long thresh_min_freq;
+	unsigned long thresh_max_freq;
+};
+
 struct dspbridge_platform_data {
-	void 	(*dsp_set_min_opp)(u8 opp_id);
-	u8 	(*dsp_get_opp)(void);
-	void 	(*cpu_set_freq)(unsigned long f);
-	unsigned long (*cpu_get_freq)(void);
-	unsigned long mpu_speed[6];
+	void (*dsp_set_min_opp) (u8 opp_id);
+	
+	u8(*dsp_get_opp_for_freq) (unsigned long f);
+	u8(*dsp_get_opp) (void);
+	
+	void (*cpu_set_freq) (unsigned long f);
+	unsigned long (*cpu_get_freq) (void);
+	
+	unsigned long *mpu_speeds;
+	u8 mpu_num_speeds;
+	unsigned long mpu_min_speed;
+	unsigned long mpu_max_speed;
+	u8 mpu_max_opp;
+	
+	struct dsp_shm_freq_table *dsp_freq_table;
+	u8 dsp_num_speeds;
 
 	u32 phys_mempool_base;
 	u32 phys_mempool_size;
@@ -78,13 +85,15 @@
 #define PRCM_VDD1 1
 
 extern struct platform_device *omap_dspbridge_dev;
+extern struct device *bridge;
 
 #if defined(CONFIG_MPU_BRIDGE) || defined(CONFIG_MPU_BRIDGE_MODULE)
 extern void dspbridge_reserve_sdram(void);
 #else
-static inline void dspbridge_reserve_sdram(void) {}
+static inline void dspbridge_reserve_sdram(void)
+{
+}
 #endif
 
 extern unsigned long dspbridge_get_mempool_base(void);
 #endif
-
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/iodefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/iodefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/iodefs.h	2011-10-11 13:50:57.756107040 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/iodefs.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * System-wide channel objects and constants.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,32 +16,21 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== iodefs.h ========
- *  Description:
- *      System-wide channel objects and constants.
- *
- *! Revision History:
- *! ================
- *! 07-Nov-2000 jeh     Created.
- */
-
 #ifndef IODEFS_
 #define IODEFS_
 
 #define IO_MAXIRQ   0xff	/* Arbitrarily large number. */
 
 /* IO Objects: */
-	struct IO_MGR;
+struct io_mgr;
 
 /* IO manager attributes: */
-	struct IO_ATTRS {
-		u8 bIRQ;	/* Channel's I/O IRQ number. */
-		bool fShared;	/* TRUE if the IRQ is shareable. */
-		u32 uWordSize;	/* DSP Word size. */
-		u32 dwSMBase;	/* Physical base address of shared memory. */
-		u32 uSMLength;	/* Size (in bytes) of shared memory. */
-	} ;
+struct io_attrs {
+	u8 birq;		/* Channel's I/O IRQ number. */
+	bool irq_shared;	/* TRUE if the IRQ is shareable. */
+	u32 word_size;		/* DSP Word size. */
+	u32 shm_base;		/* Physical base address of shared memory. */
+	u32 usm_length;		/* Size (in bytes) of shared memory. */
+};
 
-#endif				/* IODEFS_ */
+#endif /* IODEFS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/io.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/io.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/io.h	2011-10-11 13:50:57.756107040 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/io.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * The io module manages IO between CHNL and msg_ctrl.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,25 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== io.h ========
- *  Description:
- *      The io module manages IO between CHNL and MSG.
- *
- *  Public Functions:
- *      IO_Create
- *      IO_Destroy
- *      IO_Exit
- *      IO_Init
- *      IO_OnLoaded
- *
- *
- *! Revision History:
- *! ================
- *! 07-Nov-2000 jeh     Created.
- */
-
 #ifndef IO_
 #define IO_
 
@@ -42,66 +25,66 @@
 #include <dspbridge/iodefs.h>
 
 /*
- *  ======== IO_Create ========
+ *  ======== io_create ========
  *  Purpose:
  *      Create an IO manager object, responsible for managing IO between
- *      CHNL and MSG.
+ *      CHNL and msg_ctrl.
  *  Parameters:
  *      phChnlMgr:              Location to store a channel manager object on
  *                              output.
- *      hDevObject:             Handle to a device object.
+ *      hdev_obj:             Handle to a device object.
  *      pMgrAttrs:              IO manager attributes.
- *      pMgrAttrs->bIRQ:        I/O IRQ number.
- *      pMgrAttrs->fShared:     TRUE if the IRQ is shareable.
- *      pMgrAttrs->uWordSize:   DSP Word size in equivalent PC bytes..
+ *      pMgrAttrs->birq:        I/O IRQ number.
+ *      pMgrAttrs->irq_shared:     TRUE if the IRQ is shareable.
+ *      pMgrAttrs->word_size:   DSP Word size in equivalent PC bytes..
  *  Returns:
  *      DSP_SOK:                Success;
  *      DSP_EMEMORY:            Insufficient memory for requested resources.
  *      CHNL_E_ISR:             Unable to plug channel ISR for configured IRQ.
- *      CHNL_E_INVALIDIRQ:      Invalid IRQ number. Must be 0 <= bIRQ <= 15.
+ *      CHNL_E_INVALIDIRQ:      Invalid IRQ number. Must be 0 <= birq <= 15.
  *      CHNL_E_INVALIDWORDSIZE: Invalid DSP word size.  Must be > 0.
  *      CHNL_E_INVALIDMEMBASE:  Invalid base address for DSP communications.
  *  Requires:
- *      IO_Init(void) called.
+ *      io_init(void) called.
  *      phIOMgr != NULL.
  *      pMgrAttrs != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS IO_Create(OUT struct IO_MGR **phIOMgr,
-				    struct DEV_OBJECT *hDevObject,
-				    IN CONST struct IO_ATTRS *pMgrAttrs);
+extern dsp_status io_create(OUT struct io_mgr **phIOMgr,
+			    struct dev_object *hdev_obj,
+			    IN CONST struct io_attrs *pMgrAttrs);
 
 /*
- *  ======== IO_Destroy ========
+ *  ======== io_destroy ========
  *  Purpose:
  *      Destroy the IO manager.
  *  Parameters:
- *      hIOMgr:         IOmanager object.
+ *      hio_mgr:         IOmanager object.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    hIOMgr was invalid.
+ *      DSP_EHANDLE:    hio_mgr was invalid.
  *  Requires:
- *      IO_Init(void) called.
+ *      io_init(void) called.
  *  Ensures:
  */
-	extern DSP_STATUS IO_Destroy(struct IO_MGR *hIOMgr);
+extern dsp_status io_destroy(struct io_mgr *hio_mgr);
 
 /*
- *  ======== IO_Exit ========
+ *  ======== io_exit ========
  *  Purpose:
  *      Discontinue usage of the IO module.
  *  Parameters:
  *  Returns:
  *  Requires:
- *      IO_Init(void) previously called.
+ *      io_init(void) previously called.
  *  Ensures:
- *      Resources, if any acquired in IO_Init(void), are freed when the last
- *      client of IO calls IO_Exit(void).
+ *      Resources, if any acquired in io_init(void), are freed when the last
+ *      client of IO calls io_exit(void).
  */
-	extern void IO_Exit(void);
+extern void io_exit(void);
 
 /*
- *  ======== IO_Init ========
+ *  ======== io_init ========
  *  Purpose:
  *      Initialize the IO module's private state.
  *  Parameters:
@@ -111,22 +94,22 @@
  *  Ensures:
  *      A requirement for each of the other public CHNL functions.
  */
-	extern bool IO_Init(void);
+extern bool io_init(void);
 
 /*
- *  ======== IO_OnLoaded ========
+ *  ======== io_on_loaded ========
  *  Purpose:
  *      Called when a program is loaded so IO manager can update its
  *      internal state.
  *  Parameters:
- *      hIOMgr:         IOmanager object.
+ *      hio_mgr:         IOmanager object.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    hIOMgr was invalid.
+ *      DSP_EHANDLE:    hio_mgr was invalid.
  *  Requires:
- *      IO_Init(void) called.
+ *      io_init(void) called.
  *  Ensures:
  */
-	extern DSP_STATUS IO_OnLoaded(struct IO_MGR *hIOMgr);
+extern dsp_status io_on_loaded(struct io_mgr *hio_mgr);
 
-#endif				/* CHNL_ */
+#endif /* CHNL_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/io_sm.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/io_sm.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/io_sm.h	2011-10-11 13:50:57.762750774 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/io_sm.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * IO dispatcher for a shared memory channel driver.
+ * Also, includes macros to simulate shm via port io calls.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,41 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== io_sm.h ========
- *  Description:
- *      IO dispatcher for a shared memory channel driver.
- *      Also, includes macros to simulate SHM via port io calls.
- *
- *  Public Functions:
- *      IO_Dispatch
- *      IO_DPC
- *      IO_ISR
- *      IO_RequestChnl
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 01-Mar-2004 vp: Added IVA releated functions.
- *! 23-Apr-2003 sb: Fixed mailbox deadlock
- *! 06-Feb-2003 kc  Added IO_DDMAClearChnlDesc and IO_DDZCClearChnlDesc.
- *! 21-Dec-2001 ag  Removed unused param in IO_DDMAInitChnlDesc().
- *                  Updated comments. Removed #ifdef CHNL_NOIPCINTR.
- *! 05-Nov-2001 kc  Updated IO_CALLISR macro.
- *! 01-May-2001 jeh Removed IO_RequestMsg.
- *! 29-Mar-2001 ag  Added #ifdef CHNL_NOIPCINTR.
- *! 04-Dec-2000 jeh Added IO_RequestMsg.
- *! 26-Oct-2000 jeh Added IO_GetLong, IO_SetLong, IO_ReadValueLong, and
- *!                 IO_WriteValueLong, for passing arg in SHM structure.
- *! 20-Jan-2000 ag: Updated header comments per code review.
- *! 05-Jan-2000 ag: Text format clean-up.
- *! 02-Nov-1999 ag: Updated header descriptions.
- *! 25-May-1999 jg: Removed assumption of 4 bytes / word.
- *! 12-Aug-1996 gp: Created.
- */
-
 #ifndef IOSM_
 #define IOSM_
 
@@ -64,37 +32,33 @@
 
 #define IO_MGRSIGNATURE     0x494f4D43	/* "IOGR" */
 
-#define DSPFieldAddr(type, field, base, wordsize) \
+#define DSP_FIELD_ADDR(type, field, base, wordsize) \
     ((((s32)&(((type *)0)->field)) / wordsize) + (u32)base)
 
 /* Access can be different SM access word size (e.g. 16/32 bit words) */
-#define IO_SetValue(pContext, type, base, field, value) (base->field = value)
-#define IO_GetValue(pContext, type, base, field)	(base->field)
-#define IO_OrValue(pContext, type, base, field, value)  (base->field |= value)
-#define IO_AndValue(pContext, type, base, field, value) (base->field &= value)
-#define IO_SetLong(pContext, type, base, field, value)  (base->field = value)
-#define IO_GetLong(pContext, type, base, field)         (base->field)
-
-#define IO_DisableInterrupt(h)  CHNLSM_DisableInterrupt(h)
-#define IO_EnableInterrupt(h)   CHNLSM_EnableInterrupt(h)
-#define IO_CALLISR(h, pFlag, pwMBRegVal)   CHNLSM_ISR(h, pFlag, pwMBRegVal)
+#define IO_SET_VALUE(pContext, type, base, field, value) (base->field = value)
+#define IO_GET_VALUE(pContext, type, base, field)	(base->field)
+#define IO_OR_VALUE(pContext, type, base, field, value)  (base->field |= value)
+#define IO_AND_VALUE(pContext, type, base, field, value) (base->field &= value)
+#define IO_SET_LONG(pContext, type, base, field, value)  (base->field = value)
+#define IO_GET_LONG(pContext, type, base, field)         (base->field)
 
 /*
- *  ======== IO_CancelChnl ========
+ *  ======== io_cancel_chnl ========
  *  Purpose:
  *      Cancel IO on a given channel.
  *  Parameters:
- *      hIOMgr:     IO Manager.
+ *      hio_mgr:     IO Manager.
  *      ulChnl:     Index of channel to cancel IO on.
  *  Returns:
  *  Requires:
- *      Valid hIOMgr.
+ *      Valid hio_mgr.
  *  Ensures:
  */
-	extern void IO_CancelChnl(struct IO_MGR *hIOMgr, u32 ulChnl);
+extern void io_cancel_chnl(struct io_mgr *hio_mgr, u32 ulChnl);
 
 /*
- *  ======== IO_DPC ========
+ *  ======== io_dpc ========
  *  Purpose:
  *      Deferred procedure call for shared memory channel driver ISR.  Carries
  *      out the dispatch of I/O.
@@ -109,13 +73,13 @@
  *  Ensures:
  *      Non-preemptible (but interruptible).
  */
-	extern void IO_DPC(IN OUT void *pRefData);
+extern void io_dpc(IN OUT unsigned long pRefData);
 
 /*
- *  ======== IO_ISR ========
+ *  ======== io_mbox_msg ========
  *  Purpose:
  *      Main interrupt handler for the shared memory WMD channel manager.
- *      Calls the WMD's CHNLSM_ISR to determine if this interrupt is ours, then
+ *      Calls the WMD's chnlsm_isr to determine if this interrupt is ours, then
  *      schedules a DPC to dispatch I/O..
  *  Parameters:
  *      pRefData:   Pointer to the channel manager object for this board.
@@ -129,48 +93,49 @@
  *      Interrupts are disabled and EOI for this interrupt has been sent.
  *  Ensures:
  */
-       irqreturn_t IO_ISR(int irq, IN void *pRefData);
+void io_mbox_msg(u32 msg);
+
 /*
- *  ======== IO_RequestChnl ========
+ *  ======== io_request_chnl ========
  *  Purpose:
  *      Request I/O from the DSP. Sets flags in shared memory, then interrupts
  *      the DSP.
  *  Parameters:
- *      hIOMgr:     IO manager handle.
- *      pChnl:      Ptr to the channel requesting I/O.
+ *      hio_mgr:     IO manager handle.
+ *      pchnl:      Ptr to the channel requesting I/O.
  *      iMode:      Mode of channel: {IO_INPUT | IO_OUTPUT}.
  *  Returns:
  *  Requires:
- *      pChnl != NULL
+ *      pchnl != NULL
  *  Ensures:
  */
-	extern void IO_RequestChnl(struct IO_MGR *hIOMgr,
-				   struct CHNL_OBJECT *pChnl,
-				   u32 iMode, OUT u16 *pwMbVal);
+extern void io_request_chnl(struct io_mgr *hio_mgr,
+			    struct chnl_object *pchnl,
+			    u32 iMode, OUT u16 *pwMbVal);
 
 /*
- *  ======== IO_Schedule ========
+ *  ======== iosm_schedule ========
  *  Purpose:
  *      Schedule DPC for IO.
  *  Parameters:
- *      pIOMgr:     Ptr to a I/O manager.
+ *      pio_mgr:     Ptr to a I/O manager.
  *  Returns:
  *  Requires:
- *      pChnl != NULL
+ *      pchnl != NULL
  *  Ensures:
  */
-	extern void IO_Schedule(struct IO_MGR *hIOMgr);
+extern void iosm_schedule(struct io_mgr *hio_mgr);
 
 /*
  * DSP-DMA IO functions
  */
 
 /*
- *  ======== IO_DDMAInitChnlDesc ========
+ *  ======== io_ddma_init_chnl_desc ========
  *  Purpose:
  *      Initialize DSP DMA channel descriptor.
  *  Parameters:
- *      hIOMgr:         Handle to a I/O manager.
+ *      hio_mgr:         Handle to a I/O manager.
  *      uDDMAChnlId:    DDMA channel identifier.
  *      uNumDesc:       Number of buffer descriptors(equals # of IOReqs &
  *                      Chirps)
@@ -184,152 +149,148 @@
  *
  *  Ensures:
  */
-	extern void IO_DDMAInitChnlDesc(struct IO_MGR *hIOMgr, u32 uDDMAChnlId,
-					u32 uNumDesc, void *pDsp);
+extern void io_ddma_init_chnl_desc(struct io_mgr *hio_mgr, u32 uDDMAChnlId,
+				   u32 uNumDesc, void *pDsp);
 
 /*
- *  ======== IO_DDMAClearChnlDesc ========
+ *  ======== io_ddma_clear_chnl_desc ========
  *  Purpose:
  *      Clear DSP DMA channel descriptor.
  *  Parameters:
- *      hIOMgr:         Handle to a I/O manager.
+ *      hio_mgr:         Handle to a I/O manager.
  *      uDDMAChnlId:    DDMA channel identifier.
  *  Returns:
  *  Requires:
  *     uDDMAChnlId < DDMA_MAXDDMACHNLS
  *  Ensures:
  */
-	extern void IO_DDMAClearChnlDesc(struct IO_MGR *hIOMgr,
-					 u32 uDDMAChnlId);
+extern void io_ddma_clear_chnl_desc(struct io_mgr *hio_mgr, u32 uDDMAChnlId);
 
 /*
- *  ======== IO_DDMARequestChnl ========
+ *  ======== io_ddma_request_chnl ========
  *  Purpose:
  *      Request channel DSP-DMA from the DSP. Sets up SM descriptors and
  *      control fields in shared memory.
  *  Parameters:
- *      hIOMgr:     Handle to a I/O manager.
- *      pChnl:      Ptr to channel object
- *      pChirp:     Ptr to channel i/o request packet.
+ *      hio_mgr:     Handle to a I/O manager.
+ *      pchnl:      Ptr to channel object
+ *      chnl_packet_obj:     Ptr to channel i/o request packet.
  *  Returns:
  *  Requires:
- *      pChnl != NULL
- *      pChnl->cIOReqs > 0
- *      pChirp != NULL
+ *      pchnl != NULL
+ *      pchnl->cio_reqs > 0
+ *      chnl_packet_obj != NULL
  *  Ensures:
  */
-	extern void IO_DDMARequestChnl(struct IO_MGR *hIOMgr,
-				       struct CHNL_OBJECT *pChnl,
-				       struct CHNL_IRP *pChirp,
-				       OUT u16 *pwMbVal);
+extern void io_ddma_request_chnl(struct io_mgr *hio_mgr,
+				 struct chnl_object *pchnl,
+				 struct chnl_irp *chnl_packet_obj,
+				 OUT u16 *pwMbVal);
 
 /*
  * Zero-copy IO functions
  */
 
 /*
- *  ======== IO_DDZCInitChnlDesc ========
+ *  ======== io_ddzc_init_chnl_desc ========
  *  Purpose:
  *      Initialize ZCPY channel descriptor.
  *  Parameters:
- *      hIOMgr:     Handle to a I/O manager.
+ *      hio_mgr:     Handle to a I/O manager.
  *      uZId:       zero-copy channel identifier.
  *  Returns:
  *  Requires:
  *     uDDMAChnlId < DDMA_MAXZCPYCHNLS
- *     hIOMgr != Null
+ *     hio_mgr != Null
  *  Ensures:
  */
-	extern void IO_DDZCInitChnlDesc(struct IO_MGR *hIOMgr, u32 uZId);
+extern void io_ddzc_init_chnl_desc(struct io_mgr *hio_mgr, u32 uZId);
 
 /*
- *  ======== IO_DDZCClearChnlDesc ========
+ *  ======== io_ddzc_clear_chnl_desc ========
  *  Purpose:
  *      Clear DSP ZC channel descriptor.
  *  Parameters:
- *      hIOMgr:         Handle to a I/O manager.
+ *      hio_mgr:         Handle to a I/O manager.
  *      uChnlId:        ZC channel identifier.
  *  Returns:
  *  Requires:
- *      hIOMgr is valid
+ *      hio_mgr is valid
  *      uChnlId < DDMA_MAXZCPYCHNLS
  *  Ensures:
  */
-	extern void IO_DDZCClearChnlDesc(struct IO_MGR *hIOMgr, u32 uChnlId);
+extern void io_ddzc_clear_chnl_desc(struct io_mgr *hio_mgr, u32 uChnlId);
 
 /*
- *  ======== IO_DDZCRequestChnl ========
+ *  ======== io_ddzc_request_chnl ========
  *  Purpose:
  *      Request zero-copy channel transfer. Sets up SM descriptors and
  *      control fields in shared memory.
  *  Parameters:
- *      hIOMgr:         Handle to a I/O manager.
- *      pChnl:          Ptr to channel object
- *      pChirp:         Ptr to channel i/o request packet.
+ *      hio_mgr:         Handle to a I/O manager.
+ *      pchnl:          Ptr to channel object
+ *      chnl_packet_obj:         Ptr to channel i/o request packet.
  *  Returns:
  *  Requires:
- *      pChnl != NULL
- *      pChnl->cIOReqs > 0
- *      pChirp != NULL
+ *      pchnl != NULL
+ *      pchnl->cio_reqs > 0
+ *      chnl_packet_obj != NULL
  *  Ensures:
  */
-	extern void IO_DDZCRequestChnl(struct IO_MGR *hIOMgr,
-				       struct CHNL_OBJECT *pChnl,
-				       struct CHNL_IRP *pChirp,
-				       OUT u16 *pwMbVal);
+extern void io_ddzc_request_chnl(struct io_mgr *hio_mgr,
+				 struct chnl_object *pchnl,
+				 struct chnl_irp *chnl_packet_obj,
+				 OUT u16 *pwMbVal);
 
 /*
- *  ======== IO_SHMsetting ========
+ *  ======== io_sh_msetting ========
  *  Purpose:
  *      Sets the shared memory setting
  *  Parameters:
- *      hIOMgr:         Handle to a I/O manager.
+ *      hio_mgr:         Handle to a I/O manager.
  *      desc:             Shared memory type
- *      pArgs:          Ptr to SHM setting
+ *      pargs:          Ptr to shm setting
  *  Returns:
  *  Requires:
- *      hIOMgr != NULL
- *      pArgs != NULL
+ *      hio_mgr != NULL
+ *      pargs != NULL
  *  Ensures:
  */
-	extern DSP_STATUS IO_SHMsetting(IN struct IO_MGR *hIOMgr,
-					IN enum SHM_DESCTYPE desc,
-					IN void *pArgs);
+extern dsp_status io_sh_msetting(struct io_mgr *hio_mgr, u8 desc, void *pargs);
 
 /*
  *  Misc functions for the CHNL_IO shared memory library:
  */
 
 /* Maximum channel bufsize that can be used. */
-	extern u32 IO_BufSize(struct IO_MGR *hIOMgr);
+extern u32 io_buf_size(struct io_mgr *hio_mgr);
 
-	extern u32 IO_ReadValue(struct WMD_DEV_CONTEXT *hDevContext,
-				  u32 dwDSPAddr);
+extern u32 io_read_value(struct wmd_dev_context *hDevContext, u32 dwDSPAddr);
 
-	extern void IO_WriteValue(struct WMD_DEV_CONTEXT *hDevContext,
-				  u32 dwDSPAddr, u32 dwValue);
+extern void io_write_value(struct wmd_dev_context *hDevContext,
+			   u32 dwDSPAddr, u32 dwValue);
 
-	extern u32 IO_ReadValueLong(struct WMD_DEV_CONTEXT *hDevContext,
-				      u32 dwDSPAddr);
+extern u32 io_read_value_long(struct wmd_dev_context *hDevContext,
+			      u32 dwDSPAddr);
 
-	extern void IO_WriteValueLong(struct WMD_DEV_CONTEXT *hDevContext,
-				      u32 dwDSPAddr, u32 dwValue);
+extern void io_write_value_long(struct wmd_dev_context *hDevContext,
+				u32 dwDSPAddr, u32 dwValue);
 
-	extern void IO_OrSetValue(struct WMD_DEV_CONTEXT *hDevContext,
-				  u32 dwDSPAddr, u32 dwValue);
+extern void io_or_set_value(struct wmd_dev_context *hDevContext,
+			    u32 dwDSPAddr, u32 dwValue);
 
-	extern void IO_AndSetValue(struct WMD_DEV_CONTEXT *hDevContext,
-				   u32 dwDSPAddr, u32 dwValue);
+extern void io_and_set_value(struct wmd_dev_context *hDevContext,
+			     u32 dwDSPAddr, u32 dwValue);
 
-	extern void IO_IntrDSP2(IN struct IO_MGR *pIOMgr, IN u16 wMbVal);
+extern void io_intr_dsp2(IN struct io_mgr *pio_mgr, IN u16 mb_val);
 
-       extern void IO_SM_init(void);
+extern void io_sm_init(void);
 
 /*
- *  ========PrintDspTraceBuffer ========
+ *  ========print_dsp_trace_buffer ========
  *      Print DSP tracebuffer.
  */
-       extern DSP_STATUS PrintDspTraceBuffer(struct WMD_DEV_CONTEXT
-                                               *hWmdContext);
+extern dsp_status print_dsp_trace_buffer(struct wmd_dev_context
+					 *hwmd_context);
 
-#endif				/* IOSM_ */
+#endif /* IOSM_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/kfile.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/kfile.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/kfile.h	2011-10-11 13:50:57.762750774 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/kfile.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,216 +0,0 @@
-/*
- * kfile.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== kfile.h ========
- *  Purpose:
- *      Provide file I/O management capabilities.
- *
- *  Public Functions:
- *      KFILE_Close
- *      KFILE_Exit
- *      KFILE_Init
- *      KFILE_Open
- *      KFILE_Read
- *      KFILE_Seek
- *      KFILE_Tell
- *      KFILE_Write
- *
- *  Notes:
- *      The KFILE module is not like most of the other DSP/BIOS Bridge modules
- *      in that it doesn't return WSX_STATUS type values.  Rather, it's
- *      prototypes are meant to match the stdio file prototypes
- *      (ie, fopen, fclose, etc.).
- *
- *! Revision History
- *! ================
- *! 29-Oct-1999 kc:  Clean up for code review.
- *! 07-Jan-1998 cr:  Clean up for code review.
- *! 15-Aug-1997 cr:  Added E_KFILE_ERROR for general error condition.
- *! 04-Aug-1997 cr:  Added explicit CDECL descriptions.
- *! 11-Nov-1996 cr:  Implemented changes based on code review.
- *! 05-Nov-1996 cr:  Cleaned up for code review.
- *! 29-May-1996 gp:  Added requirement that size != 0 in _Write() and _Read().
- *! 28-May-1996 mg:  Changed return values for Read/Write.
- *! 14-Dec-1995 cr:  Created.
- */
-
-#ifndef KFILE_
-#define KFILE_
-
-/*
- *  Constants for KFILE_Seek.  Note that these MUST be the same definitions as
- *  those defined for fseek.
- */
-#define KFILE_SEEK_SET          0x00	/* seek from beginning of file */
-#define KFILE_SEEK_CUR          0x01	/* seek from current position */
-#define KFILE_SEEK_END          0x02	/* seek from end of file */
-
-	struct KFILE_FileObj;
-
-/*
- *  ======== KFILE_Close ========
- *  Purpose:
- *      This function closes a file's stream.
- *  Parameters:
- *      hFile:      Handle of the file stream returned by KFILE_Open.
- *  Returns:
- *      E_KFILE_INVALIDHANDLE:  bad handle.
- *      0:                      success.
- *      E_KFILE_ERROR:          unable to close specified handle.
- *  Requires:
- *      KFILE initialized.
- *  Ensures:
- */
-	extern s32 KFILE_Close(IN struct KFILE_FileObj *hFile);
-
-/*
- *  ======== KFILE_Exit ========
- *  Purpose:
- *      Discontinue usage of module; free resources when reference count
- *      reaches 0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      KFILE initialized.
- *  Ensures:
- *      Resources used by module are freed when cRef reaches zero.
- */
-	extern void KFILE_Exit(void);
-
-/*
- *  ======== KFILE_Init ========
- *  Purpose:
- *      Initializes private state of KFILE module.
- *  Parameters:
- *  Returns:
- *      TRUE if success, else FALSE.
- *  Requires:
- *  Ensures:
- *      KFILE initialized.
- */
-	extern bool KFILE_Init(void);
-
-/*
- *  ======== KFILE_Open ========
- *  Purpose:
- *      Opens a file for use.
- *  Parameters:
- *      pszFileName:    Full path to name of the file to open.
- *      pszMode:        String containing open status.  Only the first
- *                      character of the string is examined, for either
- *                      "r" (read) or "w" (write) mode.
- *  Returns:
- *      A valid file handle if success, else NULL.
- *  Requires:
- *      - KFILE initialized.
- *      - pszMode != NULL.
- *      - pszFileName != NULL.
- *  Ensures:
- */
-	extern struct KFILE_FileObj *KFILE_Open(IN CONST char *filename,
-				       IN CONST char *mode);
-
-/*
- *  ======== KFILE_Read ========
- *  Purpose:
- *      This function reads a specified number of bytes into a buffer.
- *  Parameters:
- *      pBuffer:    Array to which the file data is copied.
- *      cSize:      Number of characters in each object.
- *      cCount:     Number of objects to read in.
- *      hFile:      Handle of the file stream returned by KFILE_Open.
- *  Returns:
- *      E_KFILE_INVALIDHANDLE:  bad file handle.
- *      E_KFILE_ERROR:          general failure.
- *      > 0:                    success; # of objects read from file.
- *  Requires:
- *      KFILE initialized.
- *      pBuffer is a valid pointer.
- *  Ensures:
- */
-	extern s32 KFILE_Read(OUT void __user*buffer,
-			      IN s32 size, IN s32 count,
-			      IN struct KFILE_FileObj *hFile);
-
-/*
- *  ======== KFILE_Seek ========
- *  Purpose:
- *      This function sets the file position indicator.  NOTE:  we don't
- *      support seeking beyond the boundaries of a file.
- *  Parameters:
- *      hFile:      Handle of the file stream returned by KFILE_Open.
- *      offset:     Number of bytes from the origin to move.
- *      origin:     File reference point, one of the following values:
- *                  KFILE_SEEK_SET:  Seek from beginning of file.
- *                  KFILE_SEEK_CUR:  Seek from current position.
- *                  KFILE_SEEK_END:  Seek from end of file.
- *  Returns:
- *      0: success.
- *      E_KFILE_INVALIDHANDLE:  bad handle.
- *      E_KFILE_BADORIGIN:      invalid origin paramater.
- *      E_KFILE_ERROR:          general failure.
- *  Requires:
- *      KFILE initialized.
- *  Ensures:
- */
-	extern s32 KFILE_Seek(IN struct KFILE_FileObj *hFile,
-			      IN s32 offset, IN s32 origin);
-
-/*
- *  ======== KFILE_Tell ========
- *  Purpose:
- *      This function reports the current value of the position indicator.
- *  Parameters:
- *      hFile:          Handle of the file stream returned by KFILE_Open.
- *  Return value:
- *      > 0: success; returns # of bytes the position indicator is from
- *           beginning of file.
- *      E_KFILE_ERROR:          general failure.
- *      E_KFILE_INVALIDHANDLE:  bad file handle.
- *  Requires:
- *      KFILE initialized.
- *  Ensures:
- */
-	extern s32 KFILE_Tell(IN struct KFILE_FileObj *hFile);
-
-/*
- *  ======== KFILE_Write ========
- *  Purpose:
- *      This function writes a number of objects to the stream.
- *  Parameters:
- *      pBuffer:    Array from which the file data is written.
- *      cSize:      Number of characters in each object.
- *      cCount:     Number of objects to write out.
- *      hFile:      Handle of the file stream returned by KFILE_Open.
- *  Returns:
- *      E_KFILE_INVALIDHANDLE:  bad file handle.
- *      E_KFILE_ERROR:          general failure.
- *      > 0:                    success; # of objects written to file.
- *  Requires:
- *      KFILE initialized.
- *      pBuffer != NULL.
- *  Postcondition:
- *      The file position indicator is advanced by the number of
- *      characters written.
- */
-	extern s32 KFILE_Write(OUT void *buffer,
-			       IN s32 size,
-			       IN s32 count,
-			       IN struct KFILE_FileObj *hFile);
-
-#endif				/* KFILE_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/ldr.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/ldr.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/ldr.h	2011-10-11 13:50:57.770552532 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/ldr.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,12 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provide module loading services and symbol export services.
+ *
+ * Notes:
+ *   This service is meant to be used by modules of the DSP/BIOS Bridge
+ *   class driver.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,38 +20,10 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== ldr.h ========
- *  Purpose:
- *      Provide module loading services and symbol export services.
- *
- *  Public Functions:
- *      LDR_Exit
- *      LDR_FreeModule
- *      LDR_GetProcAddress
- *      LDR_Init
- *      LDR_LoadModule
- *
- *  Notes:
- *      This service is meant to be used by modules of the DSP/BIOS Bridge
- *       class driver.
- *
- *! Revision History:
- *! ================
- *! 22-Nov-1999 kc: Changes from code review.
- *! 12-Nov-1999 kc: Removed declaration of unused loader object.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 12-Jan-1998 cr: Cleaned up for code review.
- *! 04-Aug-1997 cr: Added explicit CDECL identifiers.
- *! 11-Nov-1996 cr: Cleaned up for code review.
- *! 16-May-1996 gp: Created.
- */
-
 #ifndef LDR_
 #define LDR_
 
 /* Loader objects: */
-	struct LDR_MODULE;
+struct ldr_module;
 
-#endif				/* LDR_ */
+#endif /* LDR_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/list.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/list.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/list.h	2011-10-11 13:50:57.776426124 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/list.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Declarations of list management control structures and definitions
+ * of inline list management functions.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,118 +17,20 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== list.h ========
- *  Purpose:
- *      Declarations of list management control structures and definitions
- *      of inline list management functions.
- *
- *  Public Functions:
- *      LST_Create
- *      LST_Delete
- *      LST_Exit
- *      LST_First
- *      LST_GetHead
- *      LST_InitElem
- *      LST_Init
- *      LST_InsertBefore
- *      LST_IsEmpty
- *      LST_Next
- *      LST_PutTail
- *      LST_RemoveElem
- *
- *  Notes:
- *
- *! Revision History
- *! ================
- *! 10-Aug-2000 ag:  Added LST_InsertBefore().
- *! 29-Oct-1999 kc:  Cleaned up for code review.
- *! 16-Aug-1997 cr:  added explicit identifiers.
- *! 10-Aug-1996 gp:  Acquired from SMM for WinSPOX v.1.1; renamed identifiers.
- *! 21-Oct-1994 dh4: Cleaned / commented for code review.
- *! 08-Jun-1994 dh4: Converted to SPM (added extern "C").
- */
-
 #ifndef LIST_
 #define LIST_
 
 #include <dspbridge/host_os.h>
+#include <linux/list.h>
 
-#define LST_IsEmpty(l)      (((l)->head.next == &(l)->head))
+#define LST_IS_EMPTY(l)      list_empty(&(l)->head)
 
-	struct LST_ELEM {
-		struct LST_ELEM *next;
-		struct LST_ELEM *prev;
-		struct LST_ELEM *self;
-	} ;
-
-	struct LST_LIST {
-		struct LST_ELEM head;
-	} ;
+struct lst_list {
+	struct list_head head;
+};
 
 /*
- *  ======== LST_Create ========
- *  Purpose:
- *      Allocates and initializes a circular list.
- *  Details:
- *      Uses portable MEM_Calloc() function to allocate a list containing
- *      a single element and initializes that element to indicate that it
- *      is the "end of the list" (i.e., the list is empty).
- *      An empty list is indicated by the "next" pointer in the element
- *      at the head of the list pointing to the head of the list, itself.
- *  Parameters:
- *  Returns:
- *      Pointer to beginning of created list (success)
- *      NULL --> Allocation failed
- *  Requires:
- *      LST initialized.
- *  Ensures:
- *  Notes:
- *      The created list contains a single element.  This element is the
- *      "empty" element, because its "next" and "prev" pointers point at
- *      the same location (the element itself).
- */
-	extern struct LST_LIST *LST_Create(void);
-
-/*
- *  ======== LST_Delete ========
- *  Purpose:
- *      Removes a list by freeing its control structure's memory space.
- *  Details:
- *      Uses portable MEM_Free() function to deallocate the memory
- *      block pointed at by the input parameter.
- *  Parameters:
- *      pList:  Pointer to list control structure of list to be deleted
- *  Returns:
- *      Void
- *  Requires:
- *      - LST initialized.
- *      - pList != NULL.
- *  Ensures:
- *  Notes:
- *      Must ONLY be used for empty lists, because it does not walk the
- *      chain of list elements.  Calling this function on a non-empty list
- *      will cause a memory leak.
- */
-	extern void LST_Delete(IN struct LST_LIST *pList);
-
-/*
- *  ======== LST_Exit ========
- *  Purpose:
- *      Discontinue usage of module; free resources when reference count
- *      reaches 0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      LST initialized.
- *  Ensures:
- *      Resources used by module are freed when cRef reaches zero.
- */
-	extern void LST_Exit(void);
-
-/*
- *  ======== LST_First ========
+ *  ======== lst_first ========
  *  Purpose:
  *      Returns a pointer to the first element of the list, or NULL if the list
  *      is empty.
@@ -138,10 +43,15 @@
  *      - pList != NULL.
  *  Ensures:
  */
-	extern struct LST_ELEM *LST_First(IN struct LST_LIST *pList);
+static inline struct list_head *lst_first(struct lst_list *pList)
+{
+	if (pList && !list_empty(&pList->head))
+		return pList->head.next;
+	return NULL;
+}
 
 /*
- *  ======== LST_GetHead ========
+ *  ======== lst_get_head ========
  *  Purpose:
  *      Pops the head off the list and returns a pointer to it.
  *  Details:
@@ -160,7 +70,6 @@
  *      Pointer to element that was at the head of the list (success)
  *      NULL          No elements in list
  *  Requires:
- *      - head.self must be correctly set to &head.
  *      - LST initialized.
  *      - pList != NULL.
  *  Ensures:
@@ -169,28 +78,27 @@
  *      the head of the list, and the head of the list points backward (its
  *      "prev" pointer) to the tail of the list, this list is circular.
  */
-	extern struct LST_ELEM *LST_GetHead(IN struct LST_LIST *pList);
+static inline struct list_head *lst_get_head(struct lst_list *pList)
+{
+	struct list_head *elem_list;
 
-/*
- *  ======== LST_Init ========
- *  Purpose:
- *      Initializes private state of LST module.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE otherwise.
- *  Requires:
- *  Ensures:
- *      LST initialized.
- */
-	extern bool LST_Init(void);
+	if (!pList || list_empty(&pList->head))
+		return NULL;
+
+	elem_list = pList->head.next;
+	pList->head.next = elem_list->next;
+	elem_list->next->prev = &pList->head;
+
+	return elem_list;
+}
 
 /*
- *  ======== LST_InitElem ========
+ *  ======== lst_init_elem ========
  *  Purpose:
  *      Initializes a list element to default (cleared) values
  *  Details:
  *  Parameters:
- *      pElem:  Pointer to list element to be reset
+ *      elem_list:  Pointer to list element to be reset
  *  Returns:
  *  Requires:
  *      LST initialized.
@@ -200,49 +108,65 @@
  *      of a list chain -- that would break the chain.
  *
  */
-	extern void LST_InitElem(IN struct LST_ELEM *pListElem);
+static inline void lst_init_elem(struct list_head *elem_list)
+{
+	if (elem_list) {
+		elem_list->next = NULL;
+		elem_list->prev = NULL;
+	}
+}
 
 /*
- *  ======== LST_InsertBefore ========
+ *  ======== lst_insert_before ========
  *  Purpose:
  *     Insert the element before the existing element.
  *  Parameters:
  *      pList:          Pointer to list control structure.
- *      pElem:          Pointer to element in list to insert.
+ *      elem_list:          Pointer to element in list to insert.
  *      pElemExisting:  Pointer to existing list element.
  *  Returns:
  *  Requires:
  *      - LST initialized.
  *      - pList != NULL.
- *      - pElem != NULL.
+ *      - elem_list != NULL.
  *      - pElemExisting != NULL.
  *  Ensures:
  */
-	extern void LST_InsertBefore(IN struct LST_LIST *pList,
-				     IN struct LST_ELEM *pElem,
-				     IN struct LST_ELEM *pElemExisting);
+static inline void lst_insert_before(struct lst_list *pList,
+				     struct list_head *elem_list,
+				     struct list_head *pElemExisting)
+{
+	if (pList && elem_list && pElemExisting)
+		list_add_tail(elem_list, pElemExisting);
+}
 
 /*
- *  ======== LST_Next ========
+ *  ======== lst_next ========
  *  Purpose:
  *      Returns a pointer to the next element of the list, or NULL if the next
  *      element is the head of the list or the list is empty.
  *  Parameters:
  *      pList:      Pointer to list control structure.
- *      pCurElem:   Pointer to element in list to remove.
+ *      cur_elem:   Pointer to element in list to remove.
  *  Returns:
  *      Pointer to list element, or NULL.
  *  Requires:
  *      - LST initialized.
  *      - pList != NULL.
- *      - pCurElem != NULL.
+ *      - cur_elem != NULL.
  *  Ensures:
  */
-	extern struct LST_ELEM *LST_Next(IN struct LST_LIST *pList,
-					 IN struct LST_ELEM *pCurElem);
+static inline struct list_head *lst_next(struct lst_list *pList,
+					 struct list_head *cur_elem)
+{
+	if (pList && !list_empty(&pList->head) && cur_elem &&
+	    (cur_elem->next != &pList->head))
+		return cur_elem->next;
+	return NULL;
+}
 
 /*
- *  ======== LST_PutTail ========
+ *  ======== lst_put_tail ========
  *  Purpose:
  *      Adds the specified element to the tail of the list
  *  Details:
@@ -255,42 +179,47 @@
  *      Sets new element's next pointer to the address of the head element.
  *      Sets head's prev pointer to the address of the new element.
  *  Parameters:
- *      pList:  Pointer to list control structure to which *pElem will be
+ *      pList:  Pointer to list control structure to which *elem_list will be
  *              added
- *      pElem:  Pointer to list element to be added
+ *      elem_list:  Pointer to list element to be added
  *  Returns:
  *      Void
  *  Requires:
- *      *pElem and *pList must both exist.
- *      pElem->self = pElem before pElem is passed to this function.
+ *      *elem_list and *pList must both exist.
  *      LST initialized.
  *  Ensures:
  *  Notes:
  *      Because the tail is always "just before" the head of the list (the
  *      tail's "next" pointer points at the head of the list, and the head's
  *      "prev" pointer points at the tail of the list), the list is circular.
- *  Warning: if pElem->self is not set beforehand, LST_GetHead() will
- *      return an erroneous pointer when it is called for this element.
  */
-	extern void LST_PutTail(IN struct LST_LIST *pList,
-				IN struct LST_ELEM *pListElem);
+static inline void lst_put_tail(struct lst_list *pList,
+				struct list_head *elem_list)
+{
+	if (pList && elem_list)
+		list_add_tail(elem_list, &pList->head);
+}
 
 /*
- *  ======== LST_RemoveElem ========
+ *  ======== lst_remove_elem ========
  *  Purpose:
  *      Removes (unlinks) the given element from the list, if the list is not
  *      empty.  Does not free the list element.
  *  Parameters:
  *      pList:      Pointer to list control structure.
- *      pCurElem:   Pointer to element in list to remove.
+ *      cur_elem:   Pointer to element in list to remove.
  *  Returns:
  *  Requires:
  *      - LST initialized.
  *      - pList != NULL.
- *      - pCurElem != NULL.
+ *      - cur_elem != NULL.
  *  Ensures:
  */
-extern void LST_RemoveElem(IN struct LST_LIST *pList,
-			   IN struct LST_ELEM *pCurElem);
+static inline void lst_remove_elem(struct lst_list *pList,
+				   struct list_head *cur_elem)
+{
+	if (pList && !list_empty(&pList->head) && cur_elem)
+		list_del_init(cur_elem);
+}
 
-#endif				/* LIST_ */
+#endif /* LIST_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/mbx_sh.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/mbx_sh.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/mbx_sh.h	2011-10-11 13:50:57.782273787 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/mbx_sh.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definitions for shared mailbox cmd/data values.(used on both
+ * the GPP and DSP sides).
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,15 +17,10 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
 /*
- *  ======== mbx_sh.h ========
- *  Definitions for shared mailbox cmd/data values.(used on both
- *     the GPP and DSP sides).
- *
  *  Bridge usage of OMAP mailbox 1 is determined by the "class" of the
- *     mailbox interrupt's cmd value received. The class value are defined
- *     as a bit (10 thru 15) being set.
+ *  mailbox interrupt's cmd value received. The class value are defined
+ *  as a bit (10 thru 15) being set.
  *
  *  Note: Only 16 bits of each  is used. Other 16 bit data reg available.
  *
@@ -37,7 +35,6 @@
  *   |  (class)  | (module specific) |
  *
  *
- *
  * B: DSP-DMA link driver channels (DDMA) : class = 1.
  *
  *    15         10                  0
@@ -50,8 +47,6 @@
  *         c -> channel Id    (32 DDMA chnls max)
  *
  *
- *
- *
  * C: Proc-copy link driver channels (PCPY) : class = 2.
  *
  *    15         10                  0
@@ -110,16 +105,6 @@
  *   where x -> not used
  *         c -> Power management command
  *
- *
- *
- *! Revision History:
- *! ================
- *! 19-Sep-2002 mr  Added DEH reset const
- *! 24-Apr-2002 sg  Added more PM commands.
- *! 04-Mar-2002 gv  Added MBX_PM_CLASS
- *! 22-Jan-2002 ag  Bug fix in MBX_SETZCPYVAL(x) macro.
- *! 21-Dec-2001 ag  Added bit masks defns.
- *! 17-Dec-2001 ag: created.
  */
 
 #ifndef _MBX_SH_H
@@ -143,7 +128,7 @@
 #define MBX_DEH_USERS_BASE  0x100	/* 256 */
 #define MBX_DEH_LIMIT       0x3FF	/* 1023 */
 #define MBX_DEH_RESET       0x101	/* DSP RESET (DEH) */
-#define MBX_DEH_EMMU        0X103 /*DSP MMU FAULT RECOVERY*/
+#define MBX_DEH_EMMU        0X103	/*DSP MMU FAULT RECOVERY */
 
 /*
  *  Link driver command/status codes.
@@ -188,10 +173,10 @@
 #define MBX_PM_OPP_CHNG(OPP) (MBX_PM_CLASS | MBX_PM_TYPE_OPP_PRECHNG | (OPP))
 #define MBX_PM_RET (MBX_PM_CLASS | MBX_PM_TYPE_PWR_CHNG | 0x0006)
 #define MBX_PM_HIB (MBX_PM_CLASS | MBX_PM_TYPE_PWR_CHNG | 0x0002)
-#define MBX_PM_OPP_1 0
-#define MBX_PM_OPP_2 1
-#define MBX_PM_OPP_3 2
-#define MBX_PM_OPP_4 3
+#define MBX_PM_OPP1 0
+#define MBX_PM_OPP2 1
+#define MBX_PM_OPP3 2
+#define MBX_PM_OPP4 3
 #define MBX_OLDOPP_EXTRACT(OPPMSG) ((0x00F0 & (OPPMSG)) >> 4)
 #define MBX_NEWOPP_EXTRACT(OPPMSG) (0x000F & (OPPMSG))
 #define MBX_PREVOPP_EXTRACT(OPPMSG) ((0x00F0 & (OPPMSG)) >> 4)
@@ -210,4 +195,4 @@
 /* Zero-Copy channel */
 #define MBX_SETZCPYVAL(x)  (MBX_ZCPY_CLASS | (x << MBX_ZCPY_CHNLSHIFT))
 
-#endif				/* _MBX_SH_H */
+#endif /* _MBX_SH_H */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/memdefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/memdefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/memdefs.h	2011-10-11 13:50:57.782273787 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/memdefs.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global MEM constants and types, shared between WCD and WMD.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,29 +16,15 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== memdefs.h ========
- *  Purpose:
- *      Global MEM constants and types, shared between WSX, WCD, and WMD.
- *
- *! Revision History:
- *! ================
- *! 28-Aug-2001 ag:  Added MEM_[SET][GET]VIRTUALSEGID.
- *! 10-Aug-1999 kc:  Based on wsx-c18.
- *! 15-Nov-1996 gp:  Renamed from wsxmem.h and moved to kwinos.
- *! 21-Aug-1996 cr:  Created from mem.h.
- */
-
 #ifndef MEMDEFS_
 #define MEMDEFS_
 
 /* Memory Pool Attributes: */
-	enum MEM_POOLATTRS {
-		MEM_PAGED = 0,
-		MEM_NONPAGED = 1,
-		MEM_LARGEVIRTMEM = 2
-	} ;
+enum mem_poolattrs {
+	MEM_PAGED = 0,
+	MEM_NONPAGED = 1,
+	MEM_LARGEVIRTMEM = 2
+};
 
 /*
  *  MEM_VIRTUALSEGID is used by Node & Strm to access virtual address space in
@@ -46,7 +34,4 @@
 #define MEM_GETVIRTUALSEGID     0x20000000
 #define MEM_MASKVIRTUALSEGID    (MEM_SETVIRTUALSEGID | MEM_GETVIRTUALSEGID)
 
-#define TO_VIRTUAL_UNCACHED(x) x
-#define INTREG_TO_VIRTUAL_UNCACHED(x) x
-
-#endif				/* MEMDEFS_ */
+#endif /* MEMDEFS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/mem.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/mem.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/mem.h	2011-10-11 13:50:57.797537381 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/mem.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Memory management and address mapping services for the DSP/BIOS Bridge
+ * class driver and mini-driver.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,57 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== mem.h ========
- *  Purpose:
- *      Memory management and address mapping services for the DSP/BIOS Bridge
- *      class driver and mini-driver.
- *
- *  Public Functions:
- *      MEM_Alloc
- *      MEM_AllocObject
- *      MEM_AllocPhysMem
- *      MEM_Calloc
- *      MEM_Exit
- *      MEM_FlushCache
- *      MEM_Free
- *      MEM_FreeObject
- *      MEM_FreePhysMem
- *      MEM_GetNumPages
- *      MEM_Init
- *      MEM_IsValidHandle
- *      MEM_LinearAddress
- *      MEM_PageLock
- *      MEM_PageUnlock
- *      MEM_UnMapLinearAddress
- *      MEM_VirtualToPhysical
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb: Added Alloc/Free PhysMem, FlushCache, VirtualToPhysical
- *! 01-Sep-2001 ag: Cleaned up notes for MEM_LinearAddress() does not
- *!                   require phys address to be page aligned!
- *! 02-Dec-1999 rr: stdwin.h included for retail build
- *! 12-Nov-1999 kc: Added warning about use of MEM_LinearAddress.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 10-Aug-1999 kc: Based on wsx-c18.
- *! 07-Jan-1998 gp: Added MEM_AllocUMB and MEM_UMBFree for User Mapped Buffers
- *!                 used by WMD_CHNL.
- *! 23-Dec-1997 cr: Code review cleanup, removed dead Ring 3 code.
- *! 04-Aug-1997 cr: Added explicit CDECL identifiers.
- *! 01-Nov-1996 gp: Updated based on code review.
- *! 04-Sep-1996 gp: Added MEM_PageLock() and MEM_PageUnlock() services.
- *! 14-Aug-1996 mg: Added MEM_GetPhysAddr() and MEM_GetNumPages()
- *! 25-Jul-1996 gp: Added MEM_IsValidHandle() macro.
- *! 10-May-1996 gp: Added MEM_Calloc().
- *! 25-Apr-1996 gp: Added MEM_PhysicalAddress()
- *! 17-Apr-1996 gp: Added MEM_Exit function; updated to latest naming standard.
- *! 08-Apr-1996 gp: Created.
- */
-
 #ifndef MEM_
 #define MEM_
 
@@ -72,17 +24,17 @@
 #include <dspbridge/memdefs.h>
 
 /*
- *  ======== MEM_Alloc ========
+ *  ======== mem_alloc ========
  *  Purpose:
  *      Allocate memory from the paged or non-paged pools.
  *  Parameters:
- *      cBytes: Number of bytes to allocate.
+ *      byte_size: Number of bytes to allocate.
  *      type:   Type of memory to allocate; one of:
  *              MEM_PAGED: Allocate from pageable memory.
  *              MEM_NONPAGED: Allocate from page locked memory.
  *  Returns:
  *      Pointer to a block of memory;
- *      NULL if memory couldn't be allocated, if cBytes == 0, or if type is
+ *      NULL if memory couldn't be allocated, if byte_size == 0, or if type is
  *      not one of MEM_PAGED or MEM_NONPAGED.
  *  Requires:
  *      MEM initialized.
@@ -90,10 +42,10 @@
  *      The returned pointer, if not NULL, points to a valid memory block of
  *      the size requested.
  */
-	extern void *MEM_Alloc(IN u32 cBytes, IN enum MEM_POOLATTRS type);
+extern void *mem_alloc(IN u32 byte_size, IN enum mem_poolattrs type);
 
 /*
- *  ======== MEM_AllocObject ========
+ *  ======== MEM_ALLOC_OBJECT ========
  *  Purpose:
  *      Allocate an object, and set it's signature.
  *  Parameters:
@@ -102,30 +54,30 @@
  *      Signature:  Magic field value.  Must be non-zero.
  *  Returns:
  *  Requires:
- *      Same requirements as MEM_Calloc(); and
- *      The object structure has a dwSignature field.  The compiler ensures
+ *      Same requirements as mem_calloc(); and
+ *      The object structure has a dw_signature field.  The compiler ensures
  *      this requirement.
  *  Ensures:
- *      A subsequent call to MEM_IsValidHandle() will succeed for this object.
+ *      A subsequent call to MEM_IS_VALID_HANDLE() will succeed for this object.
  */
-#define MEM_AllocObject(pObj, Obj, Signature)           \
+#define MEM_ALLOC_OBJECT(pObj, Obj, Signature)           \
 {                                                       \
-    pObj = MEM_Calloc(sizeof(Obj), MEM_NONPAGED);       \
+    pObj = mem_calloc(sizeof(Obj), MEM_NONPAGED);       \
     if (pObj) {                                         \
-	pObj->dwSignature = Signature;                  \
+	pObj->dw_signature = Signature;                  \
     }                                                   \
 }
 
-/*  ======== MEM_AllocPhysMem ========
+/*  ======== mem_alloc_phys_mem ========
  *  Purpose:
  *      Allocate physically contiguous, uncached memory
  *  Parameters:
- *      cBytes:     Number of bytes to allocate.
+ *      byte_size:     Number of bytes to allocate.
  *      ulAlign:    Alignment Mask.
  *      pPhysicalAddress: Physical address of allocated memory.
  *  Returns:
  *      Pointer to a block of memory;
- *      NULL if memory couldn't be allocated, or if cBytes == 0.
+ *      NULL if memory couldn't be allocated, or if byte_size == 0.
  *  Requires:
  *      MEM initialized.
  *  Ensures:
@@ -133,22 +85,21 @@
  *      the size requested.  Returned physical address refers to physical
  *      location of memory.
  */
-	extern void *MEM_AllocPhysMem(IN u32 cBytes,
-				      IN u32 ulAlign,
-				      OUT u32 *pPhysicalAddress);
+extern void *mem_alloc_phys_mem(IN u32 byte_size,
+				IN u32 ulAlign, OUT u32 *pPhysicalAddress);
 
 /*
- *  ======== MEM_Calloc ========
+ *  ======== mem_calloc ========
  *  Purpose:
  *      Allocate zero-initialized memory from the paged or non-paged pools.
  *  Parameters:
- *      cBytes: Number of bytes to allocate.
+ *      byte_size: Number of bytes to allocate.
  *      type:   Type of memory to allocate; one of:
  *              MEM_PAGED:   Allocate from pageable memory.
  *              MEM_NONPAGED: Allocate from page locked memory.
  *  Returns:
  *      Pointer to a block of zeroed memory;
- *      NULL if memory couldn't be allocated, if cBytes == 0, or if type is
+ *      NULL if memory couldn't be allocated, if byte_size == 0, or if type is
  *      not one of MEM_PAGED or MEM_NONPAGED.
  *  Requires:
  *      MEM initialized.
@@ -156,10 +107,10 @@
  *      The returned pointer, if not NULL, points to a valid memory block
  *      of the size requested.
  */
-	extern void *MEM_Calloc(IN u32 cBytes, IN enum MEM_POOLATTRS type);
+extern void *mem_calloc(IN u32 byte_size, IN enum mem_poolattrs type);
 
 /*
- *  ======== MEM_Exit ========
+ *  ======== mem_exit ========
  *  Purpose:
  *      Discontinue usage of module; free resources when reference count
  *      reaches 0.
@@ -170,10 +121,10 @@
  *  Ensures:
  *      Resources used by module are freed when cRef reaches zero.
  */
-	extern void MEM_Exit(void);
+extern void mem_exit(void);
 
 /*
- *  ======== MEM_FlushCache ========
+ *  ======== mem_flush_cache ========
  *  Purpose:
  *      Performs system cache sync with discard
  *  Parameters:
@@ -185,97 +136,65 @@
  *  Ensures:
  *      Cache is synchronized
  */
-	extern void MEM_FlushCache(void *pMemBuf, u32 cBytes, s32 FlushType);
+extern void mem_flush_cache(void *pMemBuf, u32 byte_size, s32 FlushType);
 
 /*
- *  ======== MEM_Free ========
- *  Purpose:
- *      Free the given block of system memory.
- *  Parameters:
- *      pMemBuf:    Pointer to memory allocated by MEM_Calloc/Alloc().
- *  Returns:
- *  Requires:
- *      MEM initialized.
- *      pMemBuf is a valid memory address returned by MEM_Calloc/Alloc().
- *  Ensures:
- *      pMemBuf is no longer a valid pointer to memory.
- */
-	extern void MEM_Free(IN void *pMemBuf);
-
-/*
- *  ======== MEM_VFree ========
- *  Purpose:
- *      Free the given block of system memory in virtual space.
- *  Parameters:
- *      pMemBuf:    Pointer to memory allocated by MEM_Calloc/Alloc()
- *		    using vmalloc.
- *  Returns:
- *  Requires:
- *      MEM initialized.
- *      pMemBuf is a valid memory address returned by MEM_Calloc/Alloc()
- *	using vmalloc.
- *  Ensures:
- *      pMemBuf is no longer a valid pointer to memory.
- */
-	extern void MEM_VFree(IN void *pMemBuf);
-
-/*
- *  ======== MEM_FreePhysMem ========
+ *  ======== mem_free_phys_mem ========
  *  Purpose:
  *      Free the given block of physically contiguous memory.
  *  Parameters:
  *      pVirtualAddress:  Pointer to virtual memory region allocated
- *      by MEM_AllocPhysMem().
+ *      by mem_alloc_phys_mem().
  *      pPhysicalAddress:  Pointer to physical memory region  allocated
- *      by MEM_AllocPhysMem().
- *      cBytes:  Size of the memory region allocated by MEM_AllocPhysMem().
+ *      by mem_alloc_phys_mem().
+ *      byte_size:  Size of the memory region allocated by mem_alloc_phys_mem().
  *  Returns:
  *  Requires:
  *      MEM initialized.
  *      pVirtualAddress is a valid memory address returned by
- *          MEM_AllocPhysMem()
+ *          mem_alloc_phys_mem()
  *  Ensures:
  *      pVirtualAddress is no longer a valid pointer to memory.
  */
-	extern void MEM_FreePhysMem(void *pVirtualAddress,
-				    u32 pPhysicalAddress, u32 cBytes);
+extern void mem_free_phys_mem(void *pVirtualAddress,
+			      u32 pPhysicalAddress, u32 byte_size);
 
 /*
- *  ======== MEM_FreeObject ========
+ *  ======== MEM_FREE_OBJECT ========
  *  Purpose:
  *      Utility macro to invalidate an object's signature, and deallocate it.
  *  Parameters:
  *      pObj:   Pointer to the object to free.
  *  Returns:
  *  Requires:
- *      Same requirements as MEM_Free().
+ *      Same requirements as kfree().
  *  Ensures:
- *      A subsequent call to MEM_IsValidHandle() will fail for this object.
+ *      A subsequent call to MEM_IS_VALID_HANDLE() will fail for this object.
  */
-#define MEM_FreeObject(pObj)    \
+#define MEM_FREE_OBJECT(pObj)    \
 {                               \
-    pObj->dwSignature = 0x00;   \
-    MEM_Free(pObj);             \
+    pObj->dw_signature = 0x00;   \
+    kfree(pObj);                \
 }
 
 /*
- *  ======== MEM_GetNumPages ========
+ *  ======== mem_get_num_pages ========
  *  Purpose:
  *      Calculate the number of pages corresponding to the supplied buffer.
  *  Parameters:
- *      pAddr:  Linear (virtual) address of the buffer.
- *      cBytes: Number of bytes in the buffer.
+ *      paddr:  Linear (virtual) address of the buffer.
+ *      byte_size: Number of bytes in the buffer.
  *  Returns:
  *      Number of pages.
  *  Requires:
  *      MEM initialized.
  *  Ensures:
- *      If cBytes > 0, number of pages returned > 0.
+ *      If byte_size > 0, number of pages returned > 0.
  */
-	extern s32 MEM_GetNumPages(IN void *pAddr, IN u32 cBytes);
+extern s32 mem_get_num_pages(IN void *paddr, IN u32 byte_size);
 
 /*
- *  ======== MEM_Init ========
+ *  ======== services_mem_init ========
  *  Purpose:
  *      Initializes private state of MEM module.
  *  Parameters:
@@ -285,31 +204,31 @@
  *  Ensures:
  *      MEM initialized.
  */
-	extern bool MEM_Init(void);
+extern bool services_mem_init(void);
 
 /*
- *  ======== MEM_IsValidHandle ========
+ *  ======== MEM_IS_VALID_HANDLE ========
  *  Purpose:
  *      Validate the object handle.
  *  Parameters:
- *      hObj:   Handle to object created with MEM_AllocObject().
+ *      hObj:   Handle to object created with MEM_ALLOC_OBJECT().
  *      Sig:    Expected signature u32.
  *  Returns:
  *      TRUE if handle is valid; FALSE otherwise.
  *  Requires:
- *      The object structure has a dwSignature field. Ensured by compiler.
+ *      The object structure has a dw_signature field. Ensured by compiler.
  *  Ensures:
  */
-#define MEM_IsValidHandle(hObj, Sig)                \
-     ((hObj != NULL) && (hObj->dwSignature == Sig))
+#define MEM_IS_VALID_HANDLE(hObj, Sig)                \
+     ((hObj != NULL) && (hObj->dw_signature == Sig))
 
 /*
- *  ======== MEM_LinearAddress ========
+ *  ======== MEM_LINEAR_ADDRESS ========
  *  Purpose:
  *      Get the linear address corresponding to the given physical address.
  *  Parameters:
  *      pPhysAddr:  Physical address to be mapped.
- *      cBytes:     Number of bytes in physical range to map.
+ *      byte_size:     Number of bytes in physical range to map.
  *  Returns:
  *      The corresponding linear address, or NULL if unsuccessful.
  *  Requires:
@@ -317,27 +236,27 @@
  *  Ensures:
  *  Notes:
  *      If valid linear address is returned, be sure to call
- *      MEM_UnmapLinearAddress().
+ *      MEM_UNMAP_LINEAR_ADDRESS().
  */
-#define MEM_LinearAddress(pPhyAddr, cBytes) pPhyAddr
+#define MEM_LINEAR_ADDRESS(pPhyAddr, byte_size) pPhyAddr
 
 /*
- *  ======== MEM_UnmapLinearAddress ========
+ *  ======== MEM_UNMAP_LINEAR_ADDRESS ========
  *  Purpose:
- *      Unmap the linear address mapped in MEM_LinearAddress.
+ *      Unmap the linear address mapped in MEM_LINEAR_ADDRESS.
  *  Parameters:
- *      pBaseAddr: Ptr to mapped memory (as returned by MEM_LinearAddress()).
+ *      pBaseAddr: Ptr to mapped memory (as returned by MEM_LINEAR_ADDRESS()).
  *  Returns:
  *  Requires:
  *      - MEM initialized.
- *      - pBaseAddr is a valid linear address mapped in MEM_LinearAddress.
+ *      - pBaseAddr is a valid linear address mapped in MEM_LINEAR_ADDRESS.
  *  Ensures:
  *      - pBaseAddr no longer points to a valid linear address.
  */
-#define MEM_UnmapLinearAddress(pBaseAddr) {}
+#define MEM_UNMAP_LINEAR_ADDRESS(pBaseAddr) {}
 
 /*
- *  ======== MEM_ExtPhysPoolInit ========
+ *  ======== mem_ext_phys_pool_init ========
  *  Purpose:
  *      Uses the physical memory chunk passed for internal consitent memory
  *      allocations.
@@ -351,7 +270,11 @@
  *      - MEM initialized.
  *      - valid physical address for the base and size > 0
  */
-	extern void MEM_ExtPhysPoolInit(IN u32 poolPhysBase,
-					IN u32 poolSize);
+extern void mem_ext_phys_pool_init(IN u32 poolPhysBase, IN u32 poolSize);
+
+/*
+ *  ======== mem_ext_phys_pool_release ========
+ */
+extern void mem_ext_phys_pool_release(void);
 
-#endif				/* MEM_ */
+#endif /* MEM_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/mgr.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/mgr.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/mgr.h	2011-10-11 13:50:57.797537381 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/mgr.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This is the Class driver RM module interface.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,36 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== mgr.h ========
- *  Description:
- *      This is the Class driver RM module interface.
- *
- *  Public Functions:
- *      MGR_Create
- *      MGR_Destroy
- *      MGR_EnumNodeInfo
- *      MGR_EnumProcessorInfo
- *      MGR_Exit
- *      MGR_GetDCDHandle
- *      MGR_Init
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 15-Oct-2002 kc: Removed legacy PERF definitions.
- *! 11-Jul-2001 jeh Added CFG_HDEVNODE parameter to MGR_Create().
- *! 22-Nov-2000 kc: Added MGR_GetPerfData for acquiring PERF stats.
- *! 03-Nov-2000 rr: Added MGR_GetDCDHandle. Modified after code review.
- *! 25-Sep-2000 rr: Updated to Version 0.9
- *! 14-Aug-2000 rr: Cleaned up.
- *! 07-Aug-2000 rr: MGR_Create does the job of Loading DCD Dll.
- *! 27-Jul-2000 rr: Updated to ver 0.8 of DSPAPI(types).
- *! 20-Jun-2000 rr: Created.
- */
-
 #ifndef MGR_
 #define MGR_
 
@@ -52,39 +24,39 @@
 #define MAX_EVENTS 32
 
 /*
- *  ======== MGR_WaitForBridgeEvents ========
+ *  ======== mgr_wait_for_bridge_events ========
  *  Purpose:
  *      Block on any Bridge event(s)
  *  Parameters:
- *      aNotifications  : array of pointers to notification objects.
- *      uCount          : number of elements in above array
- *      puIndex         : index of signaled event object
- *      uTimeout        : timeout interval in milliseocnds
+ *      anotifications  : array of pointers to notification objects.
+ *      count          : number of elements in above array
+ *      pu_index         : index of signaled event object
+ *      utimeout        : timeout interval in milliseocnds
  *  Returns:
  *      DSP_SOK         : Success.
- *      DSP_ETIMEOUT    : Wait timed out. *puIndex is undetermined.
+ *      DSP_ETIMEOUT    : Wait timed out. *pu_index is undetermined.
  *  Details:
  */
 
-	DSP_STATUS MGR_WaitForBridgeEvents(struct DSP_NOTIFICATION
-					   **aNotifications,
-					   u32 uCount, OUT u32 *puIndex,
-					   u32 uTimeout);
+dsp_status mgr_wait_for_bridge_events(struct dsp_notification
+				      **anotifications,
+				      u32 count, OUT u32 *pu_index,
+				      u32 utimeout);
 
 /*
- *  ======== MGR_Create ========
+ *  ======== mgr_create ========
  *  Purpose:
  *      Creates the Manager Object. This is done during the driver loading.
  *      There is only one Manager Object in the DSP/BIOS Bridge.
  *  Parameters:
  *      phMgrObject:    Location to store created MGR Object handle.
- *      hDevNode:       Device object as known to Windows system.
+ *      dev_node_obj:       Device object as known to Windows system.
  *  Returns:
  *      DSP_SOK:        Success
  *      DSP_EMEMORY:    Failed to Create the Object
  *      DSP_EFAIL:      General Failure
  *  Requires:
- *      MGR Initialized (cRefs > 0 )
+ *      MGR Initialized (refs > 0 )
  *      phMgrObject != NULL.
  *  Ensures:
  *      DSP_SOK:        *phMgrObject is a valid MGR interface to the device.
@@ -94,43 +66,43 @@
  *  Details:
  *      DCD Dll is loaded and MGR Object stores the handle of the DLL.
  */
-	extern DSP_STATUS MGR_Create(OUT struct MGR_OBJECT **hMgrObject,
-				     struct CFG_DEVNODE *hDevNode);
+extern dsp_status mgr_create(OUT struct mgr_object **hmgr_obj,
+			     struct cfg_devnode *dev_node_obj);
 
 /*
- *  ======== MGR_Destroy ========
+ *  ======== mgr_destroy ========
  *  Purpose:
  *      Destroys the MGR object. Called upon driver unloading.
  *  Parameters:
- *      hMgrObject:     Handle to Manager object .
+ *      hmgr_obj:     Handle to Manager object .
  *  Returns:
  *      DSP_SOK:        Success.
  *                      DCD Manager freed; MGR Object destroyed;
  *                      MGR Object deleted from the Registry.
  *      DSP_EFAIL:      Failed to destroy MGR Object
  *  Requires:
- *      MGR Initialized (cRefs > 0 )
- *      hMgrObject is a valid MGR handle .
+ *      MGR Initialized (refs > 0 )
+ *      hmgr_obj is a valid MGR handle .
  *  Ensures:
- *      DSP_SOK:        MGR Object destroyed and hMgrObject is Invalid MGR
+ *      DSP_SOK:        MGR Object destroyed and hmgr_obj is Invalid MGR
  *                      Handle.
  */
-	extern DSP_STATUS MGR_Destroy(struct MGR_OBJECT *hMgrObject);
+extern dsp_status mgr_destroy(struct mgr_object *hmgr_obj);
 
 /*
- *  ======== MGR_EnumNodeInfo ========
+ *  ======== mgr_enum_node_info ========
  *  Purpose:
  *      Enumerate and get configuration information about nodes configured
  *      in the node database.
  *  Parameters:
- *      uNode:              The node index (base 0).
- *      pNDBProps:          Ptr to the DSP_NDBPROPS structure for output.
- *      uNDBPropsSize:      Size of the DSP_NDBPROPS structure.
- *      puNumNodes:         Location where the number of nodes configured
+ *      node_id:              The node index (base 0).
+ *      pndb_props:          Ptr to the dsp_ndbprops structure for output.
+ *      undb_props_size:      Size of the dsp_ndbprops structure.
+ *      pu_num_nodes:         Location where the number of nodes configured
  *                          in the database will be returned.
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EINVALIDARG:    Parameter uNode is > than the number of nodes.
+ *      DSP_EINVALIDARG:    Parameter node_id is > than the number of nodes.
  *                          configutred in the system
  *      DSP_ECHANGEDURINGENUM:  During Enumeration there has been a change in
  *                              the number of nodes configured or in the
@@ -138,52 +110,52 @@
  *      DSP_EFAIL:          Failed to querry the Node Data Base
  *  Requires:
  *      pNDBPROPS is not null
- *      uNDBPropsSize >= sizeof(DSP_NDBPROPS)
- *      puNumNodes is not null
- *      MGR Initialized (cRefs > 0 )
+ *      undb_props_size >= sizeof(dsp_ndbprops)
+ *      pu_num_nodes is not null
+ *      MGR Initialized (refs > 0 )
  *  Ensures:
- *      SUCCESS on successful retreival of data and *puNumNodes > 0 OR
- *      DSP_FAILED  && *puNumNodes == 0.
+ *      SUCCESS on successful retreival of data and *pu_num_nodes > 0 OR
+ *      DSP_FAILED  && *pu_num_nodes == 0.
  *  Details:
  */
-	extern DSP_STATUS MGR_EnumNodeInfo(u32 uNode,
-					   OUT struct DSP_NDBPROPS *pNDBProps,
-					   u32 uNDBPropsSize,
-					   OUT u32 *puNumNodes);
+extern dsp_status mgr_enum_node_info(u32 node_id,
+				     OUT struct dsp_ndbprops *pndb_props,
+				     u32 undb_props_size,
+				     OUT u32 *pu_num_nodes);
 
 /*
- *  ======== MGR_EnumProcessorInfo ========
+ *  ======== mgr_enum_processor_info ========
  *  Purpose:
  *      Enumerate and get configuration information about available DSP
  *      processors
  *  Parameters:
- *      uProcessor:         The processor index (zero-based).
- *      pProcessorInfo:     Ptr to the DSP_PROCESSORINFO structure .
- *      uProcessorInfoSize: Size of DSP_PROCESSORINFO structure.
- *      puNumProcs:         Location where the number of DSPs configured
+ *      processor_id:         The processor index (zero-based).
+ *      processor_info:     Ptr to the dsp_processorinfo structure .
+ *      processor_info_size: Size of dsp_processorinfo structure.
+ *      pu_num_procs:         Location where the number of DSPs configured
  *                          in the database will be returned
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EINVALIDARG:    Parameter uProcessor is > than the number of
+ *      DSP_EINVALIDARG:    Parameter processor_id is > than the number of
  *                          DSP Processors in the system.
  *      DSP_EFAIL:          Failed to querry the Node Data Base
  *  Requires:
- *      pProcessorInfo is not null
- *      puNumProcs is not null
- *      uProcessorInfoSize >= sizeof(DSP_PROCESSORINFO)
- *      MGR Initialized (cRefs > 0 )
+ *      processor_info is not null
+ *      pu_num_procs is not null
+ *      processor_info_size >= sizeof(dsp_processorinfo)
+ *      MGR Initialized (refs > 0 )
  *  Ensures:
- *      SUCCESS on successful retreival of data and *puNumProcs > 0 OR
- *      DSP_FAILED && *puNumProcs == 0.
+ *      SUCCESS on successful retreival of data and *pu_num_procs > 0 OR
+ *      DSP_FAILED && *pu_num_procs == 0.
  *  Details:
  */
-	extern DSP_STATUS MGR_EnumProcessorInfo(u32 uProcessor,
-						OUT struct DSP_PROCESSORINFO *
-						pProcessorInfo,
-						u32 uProcessorInfoSize,
-						OUT u32 *puNumProcs);
+extern dsp_status mgr_enum_processor_info(u32 processor_id,
+					  OUT struct dsp_processorinfo
+					  *processor_info,
+					  u32 processor_info_size,
+					  OUT u32 *pu_num_procs);
 /*
- *  ======== MGR_Exit ========
+ *  ======== mgr_exit ========
  *  Purpose:
  *      Decrement reference count, and free resources when reference count is
  *      0.
@@ -194,10 +166,10 @@
  *  Ensures:
  *      When reference count == 0, MGR's private resources are freed.
  */
-       extern void MGR_Exit(void);
+extern void mgr_exit(void);
 
 /*
- *  ======== MGR_GetDCDHandle ========
+ *  ======== mgr_get_dcd_handle ========
  *  Purpose:
  *      Retrieves the MGR handle. Accessor Function
  *  Parameters:
@@ -213,12 +185,11 @@
  *      DSP_SOK and *phDCDHandle != NULL ||
  *      DSP_EFAIL and *phDCDHandle == NULL
  */
-       extern DSP_STATUS MGR_GetDCDHandle(IN struct MGR_OBJECT
-						 *hMGRHandle,
-						 OUT u32 *phDCDHandle);
+extern dsp_status mgr_get_dcd_handle(IN struct mgr_object
+				     *hMGRHandle, OUT u32 *phDCDHandle);
 
 /*
- *  ======== MGR_Init ========
+ *  ======== mgr_init ========
  *  Purpose:
  *      Initialize MGR's private state, keeping a reference count on each
  *      call. Intializes the DCD.
@@ -229,6 +200,6 @@
  *  Ensures:
  *      TRUE: A requirement for the other public MGR functions.
  */
-       extern bool MGR_Init(void);
+extern bool mgr_init(void);
 
-#endif				/* MGR_ */
+#endif /* MGR_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/mgrpriv.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/mgrpriv.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/mgrpriv.h	2011-10-11 13:50:57.797537381 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/mgrpriv.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global MGR constants and types, shared by PROC, MGR, and WCD.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,18 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== mgrpriv.h ========
- *  Description:
- *      Global MGR constants and types, shared by PROC, MGR, and WCD.
- *
- *! Revision History:
- *! ================
- *! 29-July-2001 ag: added MGR_PROCESSOREXTINFO.
- *! 05-July-2000 rr: Created
- */
-
 #ifndef MGRPRIV_
 #define MGRPRIV_
 
@@ -35,21 +25,21 @@
 #define MGR_MAXTLBENTRIES  32
 
 /* RM MGR Object */
-	struct MGR_OBJECT;
+struct mgr_object;
 
-	struct MGR_TLBENTRY {
-		u32 ulDspVirt;	/* DSP virtual address */
-		u32 ulGppPhys;	/* GPP physical address */
-	} ;
+struct mgr_tlbentry {
+	u32 ul_dsp_virt;	/* DSP virtual address */
+	u32 ul_gpp_phys;	/* GPP physical address */
+};
 
 /*
  *  The DSP_PROCESSOREXTINFO structure describes additional extended
  *  capabilities of a DSP processor not exposed to user.
  */
-	struct MGR_PROCESSOREXTINFO {
-		struct DSP_PROCESSORINFO tyBasic;    /* user processor info */
-		/* private dsp mmu entries */
-		struct MGR_TLBENTRY tyTlb[MGR_MAXTLBENTRIES];
-	} ;
+struct mgr_processorextinfo {
+	struct dsp_processorinfo ty_basic;	/* user processor info */
+	/* private dsp mmu entries */
+	struct mgr_tlbentry ty_tlb[MGR_MAXTLBENTRIES];
+};
 
-#endif				/* MGRPRIV_ */
+#endif /* MGRPRIV_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/msgdefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/msgdefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/msgdefs.h	2011-10-11 13:50:57.797537381 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/msgdefs.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global msg_ctrl constants and types.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,30 +16,16 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== msgdefs.h ========
- *  Description:
- *      Global MSG constants and types.
- *
- *! Revision History
- *! ================
- *! 09-May-2001 jeh Removed MSG_TODSP, MSG_FROMDSP.
- *! 17-Nov-2000 jeh Added MSGMGR_SIGNATURE.
- *! 12-Sep-2000 jeh Created.
- */
-
 #ifndef MSGDEFS_
 #define MSGDEFS_
 
 #define MSGMGR_SIGNATURE    0x4d47534d	/* "MGSM" */
 
-/* MSG Objects: */
-	struct MSG_MGR;
-	struct MSG_QUEUE;
+/* msg_ctrl Objects: */
+struct msg_mgr;
+struct msg_queue;
 
 /* Function prototype for callback to be called on RMS_EXIT message received */
-       typedef void(*MSG_ONEXIT) (HANDLE h, s32 nStatus);
-
-#endif				/* MSGDEFS_ */
+typedef void (*msg_onexit) (bhandle h, s32 nStatus);
 
+#endif /* MSGDEFS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/msg.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/msg.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/msg.h	2011-10-11 13:50:57.812604009 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/msg.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge msg_ctrl Module.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,28 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== msg.h ========
- *  Description:
- *      DSP/BIOS Bridge MSG Module.
- *
- *  Public Functions:
- *      MSG_Create
- *      MSG_Delete
- *      MSG_Exit
- *      MSG_Init
- *
- *  Notes:
- *
- *! Revision History:
- *! =================
- *! 17-Nov-2000 jeh     Removed MSG_Get, MSG_Put, MSG_CreateQueue,
- *!                     MSG_DeleteQueue, and MSG_RegisterNotify, since these
- *!                     are now part of mini-driver.
- *! 12-Sep-2000 jeh     Created.
- */
-
 #ifndef MSG_
 #define MSG_
 
@@ -43,64 +23,64 @@
 #include <dspbridge/msgdefs.h>
 
 /*
- *  ======== MSG_Create ========
+ *  ======== msg_create ========
  *  Purpose:
  *      Create an object to manage message queues. Only one of these objects
- *      can exist per device object. The MSG manager must be created before
+ *      can exist per device object. The msg_ctrl manager must be created before
  *      the IO Manager.
  *  Parameters:
- *      phMsgMgr:           Location to store MSG manager handle on output.
- *      hDevObject:         The device object.
+ *      phMsgMgr:           Location to store msg_ctrl manager handle on output.
+ *      hdev_obj:         The device object.
  *      msgCallback:        Called whenever an RMS_EXIT message is received.
  *  Returns:
  *  Requires:
- *      MSG_Init(void) called.
+ *      msg_mod_init(void) called.
  *      phMsgMgr != NULL.
- *      hDevObject != NULL.
+ *      hdev_obj != NULL.
  *      msgCallback != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS MSG_Create(OUT struct MSG_MGR **phMsgMgr,
-				     struct DEV_OBJECT *hDevObject,
-				     MSG_ONEXIT msgCallback);
+extern dsp_status msg_create(OUT struct msg_mgr **phMsgMgr,
+			     struct dev_object *hdev_obj,
+			     msg_onexit msgCallback);
 
 /*
- *  ======== MSG_Delete ========
+ *  ======== msg_delete ========
  *  Purpose:
- *      Delete a MSG manager allocated in MSG_Create().
+ *      Delete a msg_ctrl manager allocated in msg_create().
  *  Parameters:
- *      hMsgMgr:            Handle returned from MSG_Create().
+ *      hmsg_mgr:            Handle returned from msg_create().
  *  Returns:
  *  Requires:
- *      MSG_Init(void) called.
- *      Valid hMsgMgr.
+ *      msg_mod_init(void) called.
+ *      Valid hmsg_mgr.
  *  Ensures:
  */
-	extern void MSG_Delete(struct MSG_MGR *hMsgMgr);
+extern void msg_delete(struct msg_mgr *hmsg_mgr);
 
 /*
- *  ======== MSG_Exit ========
+ *  ======== msg_exit ========
  *  Purpose:
- *      Discontinue usage of MSG module.
+ *      Discontinue usage of msg_ctrl module.
  *  Parameters:
  *  Returns:
  *  Requires:
- *      MSG_Init(void) successfully called before.
+ *      msg_mod_init(void) successfully called before.
  *  Ensures:
- *      Any resources acquired in MSG_Init(void) will be freed when last MSG
- *      client calls MSG_Exit(void).
+ *      Any resources acquired in msg_mod_init(void) will be freed when last
+ *      msg_ctrl client calls msg_exit(void).
  */
-	extern void MSG_Exit(void);
+extern void msg_exit(void);
 
 /*
- *  ======== MSG_Init ========
+ *  ======== msg_mod_init ========
  *  Purpose:
- *      Initialize the MSG module.
+ *      Initialize the msg_ctrl module.
  *  Parameters:
  *  Returns:
  *      TRUE if initialization succeeded, FALSE otherwise.
  *  Ensures:
  */
-	extern bool MSG_Init(void);
+extern bool msg_mod_init(void);
 
-#endif				/* MSG_ */
+#endif /* MSG_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/nldrdefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/nldrdefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/nldrdefs.h	2011-10-11 13:50:57.819402194 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/nldrdefs.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global Dynamic + static/overlay Node loader (NLDR) constants and types.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,18 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== nldrdefs.h ========
- *  Description:
- *      Global Dynamic + static/overlay Node loader (NLDR) constants and types.
- *
- *! Revision History
- *! ================
- *! 07-Apr-2003 map     Consolidated dldrdefs.h into nldrdefs.h
- *! 05-Aug-2002 jeh     Created.
- */
-
 #ifndef NLDRDEFS_
 #define NLDRDEFS_
 
@@ -34,81 +24,80 @@
 
 #define NLDR_MAXPATHLENGTH       255
 /* NLDR Objects: */
-	struct  NLDR_OBJECT;
-	struct NLDR_NODEOBJECT;
+struct nldr_object;
+struct nldr_nodeobject;
 
 /*
- *  ======== NLDR_LOADTYPE ========
+ *  ======== nldr_loadtype ========
  *  Load types for a node. Must match values in node.h55.
  */
-	enum NLDR_LOADTYPE {
-		NLDR_STATICLOAD,	/* Linked in base image, not overlay */
-		NLDR_DYNAMICLOAD,	/* Dynamically loaded node */
-		NLDR_OVLYLOAD	/* Linked in base image, overlay node */
-	} ;
+enum nldr_loadtype {
+	NLDR_STATICLOAD,	/* Linked in base image, not overlay */
+	NLDR_DYNAMICLOAD,	/* Dynamically loaded node */
+	NLDR_OVLYLOAD		/* Linked in base image, overlay node */
+};
 
 /*
- *  ======== NLDR_OVLYFXN ========
+ *  ======== nldr_ovlyfxn ========
  *  Causes code or data to be copied from load address to run address. This
- *  is the "COD_WRITEFXN" that gets passed to the DBLL_Library and is used as
+ *  is the "cod_writefxn" that gets passed to the DBLL_Library and is used as
  *  the ZL write function.
  *
  *  Parameters:
- *      pPrivRef:       Handle to identify the node.
+ *      priv_ref:       Handle to identify the node.
  *      ulDspRunAddr:   Run address of code or data.
  *      ulDspLoadAddr:  Load address of code or data.
- *      ulNumBytes:     Number of (GPP) bytes to copy.
+ *      ul_num_bytes:     Number of (GPP) bytes to copy.
  *      nMemSpace:      RMS_CODE or RMS_DATA.
  *  Returns:
- *      ulNumBytes:     Success.
+ *      ul_num_bytes:     Success.
  *      0:              Failure.
  *  Requires:
  *  Ensures:
  */
-       typedef u32(*NLDR_OVLYFXN) (void *pPrivRef, u32 ulDspRunAddr,
-					     u32 ulDspLoadAddr,
-					     u32 ulNumBytes, u32 nMemSpace);
+typedef u32(*nldr_ovlyfxn) (void *priv_ref, u32 ulDspRunAddr,
+			    u32 ulDspLoadAddr, u32 ul_num_bytes, u32 nMemSpace);
 
 /*
- *  ======== NLDR_WRITEFXN ========
+ *  ======== nldr_writefxn ========
  *  Write memory function. Used for dynamic load writes.
  *  Parameters:
- *      pPrivRef:       Handle to identify the node.
+ *      priv_ref:       Handle to identify the node.
  *      ulDspAddr:      Address of code or data.
- *      pBuf:           Code or data to be written
- *      ulNumBytes:     Number of (GPP) bytes to write.
+ *      pbuf:           Code or data to be written
+ *      ul_num_bytes:     Number of (GPP) bytes to write.
  *      nMemSpace:      DBLL_DATA or DBLL_CODE.
  *  Returns:
- *      ulNumBytes:     Success.
+ *      ul_num_bytes:     Success.
  *      0:              Failure.
  *  Requires:
  *  Ensures:
  */
-       typedef u32(*NLDR_WRITEFXN) (void *pPrivRef,
-					      u32 ulDspAddr, void *pBuf,
-					      u32 ulNumBytes, u32 nMemSpace);
+typedef u32(*nldr_writefxn) (void *priv_ref,
+			     u32 ulDspAddr, void *pbuf,
+			     u32 ul_num_bytes, u32 nMemSpace);
 
 /*
- *  ======== NLDR_ATTRS ========
- *  Attributes passed to NLDR_Create function.
+ *  ======== nldr_attrs ========
+ *  Attributes passed to nldr_create function.
  */
-	struct NLDR_ATTRS {
-		NLDR_OVLYFXN pfnOvly;
-		NLDR_WRITEFXN pfnWrite;
-		u16 usDSPWordSize;
-		u16 usDSPMauSize;
-	} ;
+struct nldr_attrs {
+	nldr_ovlyfxn pfn_ovly;
+	nldr_writefxn pfn_write;
+	u16 us_dsp_word_size;
+	u16 us_dsp_mau_size;
+};
 
 /*
- *  ======== NLDR_PHASE ========
+ *  ======== nldr_phase ========
  *  Indicates node create, delete, or execute phase function.
  */
-	enum NLDR_PHASE {
-		NLDR_CREATE,
-		NLDR_DELETE,
-		NLDR_EXECUTE,
-		NLDR_NOPHASE
-	} ;
+enum nldr_phase {
+	NLDR_CREATE,
+	NLDR_DELETE,
+	NLDR_EXECUTE,
+	NLDR_NOPHASE
+};
 
 /*
  *  Typedefs of loader functions imported from a DLL, or defined in a
@@ -116,130 +105,129 @@
  */
 
 /*
- *  ======== NLDR_Allocate ========
+ *  ======== nldr_allocate ========
  *  Allocate resources to manage the loading of a node on the DSP.
  *
  *  Parameters:
- *      hNldr:          Handle of loader that will load the node.
- *      pPrivRef:       Handle to identify the node.
- *      pNodeProps:     Pointer to a DCD_NODEPROPS for the node.
+ *      nldr_obj:          Handle of loader that will load the node.
+ *      priv_ref:       Handle to identify the node.
+ *      node_props:     Pointer to a dcd_nodeprops for the node.
  *      phNldrNode:     Location to store node handle on output. This handle
- *                      will be passed to NLDR_Load/NLDR_Unload.
- *      pfPhaseSplit:   pointer to boolean variable referenced in node.c
+ *                      will be passed to nldr_load/nldr_unload.
+ *      pf_phase_split:   pointer to boolean variable referenced in node.c
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Insufficient memory on GPP.
  *  Requires:
- *      NLDR_Init(void) called.
- *      Valid hNldr.
- *      pNodeProps != NULL.
+ *      nldr_init(void) called.
+ *      Valid nldr_obj.
+ *      node_props != NULL.
  *      phNldrNode != NULL.
  *  Ensures:
  *      DSP_SOK:        IsValidNode(*phNldrNode).
  *      error:          *phNldrNode == NULL.
  */
-	typedef DSP_STATUS(*NLDR_ALLOCATEFXN) (struct NLDR_OBJECT *hNldr,
-					       void *pPrivRef,
-					       IN CONST struct DCD_NODEPROPS
-					       *pNodeProps,
-					       OUT struct NLDR_NODEOBJECT
-					       **phNldrNode,
-					       OUT bool *pfPhaseSplit);
+typedef dsp_status(*nldr_allocatefxn) (struct nldr_object *nldr_obj,
+				       void *priv_ref,
+				       IN CONST struct dcd_nodeprops
+				       * node_props,
+				       OUT struct nldr_nodeobject
+				       **phNldrNode,
+				       OUT bool *pf_phase_split);
 
 /*
- *  ======== NLDR_Create ========
+ *  ======== nldr_create ========
  *  Create a loader object. This object handles the loading and unloading of
  *  create, delete, and execute phase functions of nodes on the DSP target.
  *
  *  Parameters:
  *      phNldr:         Location to store loader handle on output.
- *      hDevObject:     Device for this processor.
- *      pAttrs:         Loader attributes.
+ *      hdev_obj:     Device for this processor.
+ *      pattrs:         Loader attributes.
  *  Returns:
  *      DSP_SOK:        Success;
  *      DSP_EMEMORY:    Insufficient memory for requested resources.
  *  Requires:
- *      NLDR_Init(void) called.
+ *      nldr_init(void) called.
  *      phNldr != NULL.
- *      hDevObject != NULL.
- *	pAttrs != NULL.
+ *      hdev_obj != NULL.
+ *	pattrs != NULL.
  *  Ensures:
  *      DSP_SOK:        Valid *phNldr.
  *      error:          *phNldr == NULL.
  */
-	typedef DSP_STATUS(*NLDR_CREATEFXN) (OUT struct NLDR_OBJECT **phNldr,
-					     struct DEV_OBJECT *hDevObject,
-					     IN CONST struct NLDR_ATTRS
-					     *pAttrs);
+typedef dsp_status(*nldr_createfxn) (OUT struct nldr_object **phNldr,
+				     struct dev_object *hdev_obj,
+				     IN CONST struct nldr_attrs *pattrs);
 
 /*
- *  ======== NLDR_Delete ========
+ *  ======== nldr_delete ========
  *  Delete the NLDR loader.
  *
  *  Parameters:
- *      hNldr:          Node manager object.
+ *      nldr_obj:          Node manager object.
  *  Returns:
  *  Requires:
- *      NLDR_Init(void) called.
- *      Valid hNldr.
+ *      nldr_init(void) called.
+ *      Valid nldr_obj.
  *  Ensures:
- *	hNldr invalid
+ *	nldr_obj invalid
  */
-	typedef void(*NLDR_DELETEFXN) (struct NLDR_OBJECT *hNldr);
+typedef void (*nldr_deletefxn) (struct nldr_object *nldr_obj);
 
 /*
- *  ======== NLDR_Exit ========
+ *  ======== nldr_exit ========
  *  Discontinue usage of NLDR module.
  *
  *  Parameters:
  *  Returns:
  *  Requires:
- *      NLDR_Init(void) successfully called before.
+ *      nldr_init(void) successfully called before.
  *  Ensures:
- *      Any resources acquired in NLDR_Init(void) will be freed when last NLDR
- *      client calls NLDR_Exit(void).
+ *      Any resources acquired in nldr_init(void) will be freed when last NLDR
+ *      client calls nldr_exit(void).
  */
-	typedef void(*NLDR_EXITFXN) (void);
+typedef void (*nldr_exitfxn) (void);
 
 /*
  *  ======== NLDR_Free ========
- *  Free resources allocated in NLDR_Allocate.
+ *  Free resources allocated in nldr_allocate.
  *
  *  Parameters:
- *      hNldrNode:      Handle returned from NLDR_Allocate().
+ *      nldr_node_obj:      Handle returned from nldr_allocate().
  *  Returns:
  *  Requires:
- *      NLDR_Init(void) called.
- *      Valid hNldrNode.
+ *      nldr_init(void) called.
+ *      Valid nldr_node_obj.
  *  Ensures:
  */
-	typedef void(*NLDR_FREEFXN) (struct NLDR_NODEOBJECT *hNldrNode);
+typedef void (*nldr_freefxn) (struct nldr_nodeobject *nldr_node_obj);
 
 /*
- *  ======== NLDR_GetFxnAddr ========
+ *  ======== nldr_get_fxn_addr ========
  *  Get address of create, delete, or execute phase function of a node on
  *  the DSP.
  *
  *  Parameters:
- *      hNldrNode:      Handle returned from NLDR_Allocate().
+ *      nldr_node_obj:      Handle returned from nldr_allocate().
  *      pstrFxn:        Name of function.
  *      pulAddr:        Location to store function address.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_ESYMBOL:    Address of function not found.
  *  Requires:
- *      NLDR_Init(void) called.
- *      Valid hNldrNode.
+ *      nldr_init(void) called.
+ *      Valid nldr_node_obj.
  *      pulAddr != NULL;
  *      pstrFxn != NULL;
  *  Ensures:
  */
-	typedef DSP_STATUS(*NLDR_GETFXNADDRFXN) (struct NLDR_NODEOBJECT
-						 *hNldrNode,
-						 char *pstrFxn, u32 *pulAddr);
+typedef dsp_status(*nldr_getfxnaddrfxn) (struct nldr_nodeobject
+					 * nldr_node_obj,
+					 char *pstrFxn, u32 * pulAddr);
 
 /*
- *  ======== NLDR_Init ========
+ *  ======== nldr_init ========
  *  Initialize the NLDR module.
  *
  *  Parameters:
@@ -247,14 +235,14 @@
  *      TRUE if initialization succeeded, FALSE otherwise.
  *  Ensures:
  */
-	typedef bool(*NLDR_INITFXN) (void);
+typedef bool(*nldr_initfxn) (void);
 
 /*
- *  ======== NLDR_Load ========
+ *  ======== nldr_load ========
  *  Load create, delete, or execute phase function of a node on the DSP.
  *
  *  Parameters:
- *      hNldrNode:      Handle returned from NLDR_Allocate().
+ *      nldr_node_obj:      Handle returned from nldr_allocate().
  *      phase:          Type of function to load (create, delete, or execute).
  *  Returns:
  *      DSP_SOK:                Success.
@@ -264,44 +252,43 @@
  *      DSP_EDYNLOAD:           Failure in dynamic loader library.
  *      DSP_EFWRITE:            Failed to write phase's code or date to target.
  *  Requires:
- *      NLDR_Init(void) called.
- *      Valid hNldrNode.
+ *      nldr_init(void) called.
+ *      Valid nldr_node_obj.
  *  Ensures:
  */
-	typedef DSP_STATUS(*NLDR_LOADFXN) (struct NLDR_NODEOBJECT *hNldrNode,
-					   enum NLDR_PHASE phase);
+typedef dsp_status(*nldr_loadfxn) (struct nldr_nodeobject *nldr_node_obj,
+				   enum nldr_phase phase);
 
 /*
- *  ======== NLDR_Unload ========
+ *  ======== nldr_unload ========
  *  Unload create, delete, or execute phase function of a node on the DSP.
  *
  *  Parameters:
- *      hNldrNode:      Handle returned from NLDR_Allocate().
+ *      nldr_node_obj:      Handle returned from nldr_allocate().
  *      phase:          Node function to unload (create, delete, or execute).
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Insufficient memory on GPP.
  *  Requires:
- *      NLDR_Init(void) called.
- *      Valid hNldrNode.
+ *      nldr_init(void) called.
+ *      Valid nldr_node_obj.
  *  Ensures:
  */
-	typedef DSP_STATUS(*NLDR_UNLOADFXN) (struct NLDR_NODEOBJECT *hNldrNode,
-					     enum NLDR_PHASE phase);
+typedef dsp_status(*nldr_unloadfxn) (struct nldr_nodeobject *nldr_node_obj,
+				     enum nldr_phase phase);
 
 /*
- *  ======== NLDR_FXNS ========
+ *  ======== node_ldr_fxns ========
  */
-	struct NLDR_FXNS {
-		NLDR_ALLOCATEFXN pfnAllocate;
-		NLDR_CREATEFXN pfnCreate;
-		NLDR_DELETEFXN pfnDelete;
-		NLDR_EXITFXN pfnExit;
-		NLDR_FREEFXN pfnFree;
-		NLDR_GETFXNADDRFXN pfnGetFxnAddr;
-		NLDR_INITFXN pfnInit;
-		NLDR_LOADFXN pfnLoad;
-		NLDR_UNLOADFXN pfnUnload;
-	} ;
+struct node_ldr_fxns {
+	nldr_allocatefxn pfn_allocate;
+	nldr_createfxn pfn_create;
+	nldr_deletefxn pfn_delete;
+	nldr_exitfxn pfn_exit;
+	nldr_getfxnaddrfxn pfn_get_fxn_addr;
+	nldr_initfxn pfn_init;
+	nldr_loadfxn pfn_load;
+	nldr_unloadfxn pfn_unload;
+};
 
-#endif				/* NLDRDEFS_ */
+#endif /* NLDRDEFS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/nldr.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/nldr.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/nldr.h	2011-10-11 13:50:57.819402194 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/nldr.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge dynamic loader interface.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,33 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== nldr.h ========
- *
- *  Description:
- *      DSP/BIOS Bridge dynamic loader interface. See the file dldrdefs.h
- *  for a description of these functions.
- *
- *  Public Functions:
- *      NLDR_Allocate
- *      NLDR_Create
- *      NLDR_Delete
- *      NLDR_Exit
- *      NLDR_Free
- *      NLDR_GetFxnAddr
- *      NLDR_Init
- *      NLDR_Load
- *      NLDR_Unload
- *
- *  Notes:
- *
- *! Revision History
- *! ================
- *! 31-Jul-2002 jeh     Removed function header comments.
- *! 17-Apr-2002 jeh     Created.
- */
-
 #include <dspbridge/dbdefs.h>
 #include <dspbridge/dbdcddef.h>
 #include <dspbridge/dev.h>
@@ -50,32 +25,29 @@
 #ifndef NLDR_
 #define NLDR_
 
-	extern DSP_STATUS NLDR_Allocate(struct NLDR_OBJECT *hNldr,
-					void *pPrivRef,
-					IN CONST struct DCD_NODEPROPS
-					*pNodeProps,
-					OUT struct NLDR_NODEOBJECT **phNldrNode,
-					IN bool *pfPhaseSplit);
-
-	extern DSP_STATUS NLDR_Create(OUT struct NLDR_OBJECT **phNldr,
-				      struct DEV_OBJECT *hDevObject,
-				      IN CONST struct NLDR_ATTRS *pAttrs);
-
-	extern void NLDR_Delete(struct NLDR_OBJECT *hNldr);
-	extern void NLDR_Exit(void);
-	extern void NLDR_Free(struct NLDR_NODEOBJECT *hNldrNode);
-
-	extern DSP_STATUS NLDR_GetFxnAddr(struct NLDR_NODEOBJECT *hNldrNode,
-					  char *pstrFxn, u32 *pulAddr);
-
-	extern DSP_STATUS NLDR_GetRmmManager(struct NLDR_OBJECT *hNldrObject,
-					     OUT struct RMM_TargetObj
-					     **phRmmMgr);
-
-	extern bool NLDR_Init(void);
-	extern DSP_STATUS NLDR_Load(struct NLDR_NODEOBJECT *hNldrNode,
-				    enum NLDR_PHASE phase);
-	extern DSP_STATUS NLDR_Unload(struct NLDR_NODEOBJECT *hNldrNode,
-				    enum NLDR_PHASE phase);
+extern dsp_status nldr_allocate(struct nldr_object *nldr_obj,
+				void *priv_ref, IN CONST struct dcd_nodeprops
+				*node_props,
+				OUT struct nldr_nodeobject **phNldrNode,
+				IN bool *pf_phase_split);
+
+extern dsp_status nldr_create(OUT struct nldr_object **phNldr,
+			      struct dev_object *hdev_obj,
+			      IN CONST struct nldr_attrs *pattrs);
+
+extern void nldr_delete(struct nldr_object *nldr_obj);
+extern void nldr_exit(void);
+
+extern dsp_status nldr_get_fxn_addr(struct nldr_nodeobject *nldr_node_obj,
+				    char *pstrFxn, u32 * pulAddr);
+
+extern dsp_status nldr_get_rmm_manager(struct nldr_object *hNldrObject,
+				       OUT struct rmm_target_obj **phRmmMgr);
+
+extern bool nldr_init(void);
+extern dsp_status nldr_load(struct nldr_nodeobject *nldr_node_obj,
+			    enum nldr_phase phase);
+extern dsp_status nldr_unload(struct nldr_nodeobject *nldr_node_obj,
+			      enum nldr_phase phase);
 
-#endif				/* NLDR_ */
+#endif /* NLDR_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/nodedefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/nodedefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/nodedefs.h	2011-10-11 13:50:57.819402194 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/nodedefs.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global NODE constants and types, shared by PROCESSOR, NODE, and DISP.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,27 +16,13 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== nodedefs.h ========
- *  Description:
- *      Global NODE constants and types, shared by PROCESSOR, NODE, and DISP.
- *
- *! Revision History
- *! ================
- *! 23-Apr-2001 jeh     Removed NODE_MGRATTRS.
- *! 21-Sep-2000 jeh     Removed NODE_TYPE enum.
- *! 17-Jul-2000 jeh     Changed order of node types to match rms_sh.h.
- *! 20-Jun-2000 jeh     Created.
- */
-
 #ifndef NODEDEFS_
 #define NODEDEFS_
 
 #define NODE_SUSPENDEDPRI -1
 
 /* NODE Objects: */
-	struct NODE_MGR;
-	struct NODE_OBJECT;
+struct node_mgr;
+struct node_object;
 
-#endif				/* NODEDEFS_ */
+#endif /* NODEDEFS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/node.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/node.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/node.h	2011-10-11 13:50:58.006365304 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/node.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge Node Manager.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,52 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== node.h ========
- *  Description:
- *      DSP/BIOS Bridge Node Manager.
- *
- *  Public Functions:
- *      NODE_Allocate
- *      NODE_AllocMsgBuf
- *      NODE_ChangePriority
- *      NODE_Connect
- *      NODE_Create
- *      NODE_CreateMgr
- *      NODE_Delete
- *      NODE_DeleteMgr
- *      NODE_EnumNodes
- *      NODE_Exit
- *      NODE_FreeMsgBuf
- *      NODE_GetAttr
- *      NODE_GetMessage
- *      NODE_GetProcessor
- *      NODE_Init
- *      NODE_OnExit
- *      NODE_Pause
- *      NODE_PutMessage
- *      NODE_RegisterNotify
- *      NODE_Run
- *      NODE_Terminate
- *
- *  Notes:
- *
- *! Revision History:
- *! =================
- *! 23-Apr-2001 jeh     Updated with code review changes.
- *! 16-Jan-2001 jeh     Added DSP_ESYMBOL, DSP_EUUID to return codes.
- *! 17-Nov-2000 jeh     Added NODE_OnExit().
- *! 27-Oct-2000 jeh     Added timeouts to NODE_GetMessage, NODE_PutMessage.
- *! 12-Oct-2000 jeh     Changed NODE_EnumNodeInfo to NODE_EnumNodes. Removed
- *!                     NODE_RegisterAllNodes().
- *! 07-Sep-2000 jeh     Changed type HANDLE in NODE_RegisterNotify to
- *!                     DSP_HNOTIFICATION. Added DSP_STRMATTR param to
- *!                     NODE_Connect(). Removed NODE_GetMessageStream().
- *! 17-Jul-2000 jeh     Updated function header descriptions.
- *! 19-Jun-2000 jeh     Created.
- */
-
 #ifndef NODE_
 #define NODE_
 
@@ -71,53 +27,52 @@
 #include <dspbridge/drv.h>
 
 /*
- *  ======== NODE_Allocate ========
+ *  ======== node_allocate ========
  *  Purpose:
  *      Allocate GPP resources to manage a node on the DSP.
  *  Parameters:
- *      hProcessor:         Handle of processor that is allocating the node.
- *      pNodeId:            Pointer to a DSP_UUID for the node.
- *      pArgs:              Optional arguments to be passed to the node.
- *      pAttrIn:            Optional pointer to node attributes (priority,
+ *      hprocessor:         Handle of processor that is allocating the node.
+ *      pNodeId:            Pointer to a dsp_uuid for the node.
+ *      pargs:              Optional arguments to be passed to the node.
+ *      attr_in:            Optional pointer to node attributes (priority,
  *                          timeout...)
- *      phNode:             Location to store node handle on output.
+ *      ph_node:             Location to store node handle on output.
  *  Returns:
  *      DSP_SOK:            Success.
  *      DSP_EMEMORY:        Insufficient memory on GPP.
  *      DSP_EUUID:          Node UUID has not been registered.
  *      DSP_ESYMBOL:        iAlg functions not found for a DAIS node.
- *      DSP_ERANGE:         pAttrIn != NULL and pAttrIn->iPriority out of
+ *      DSP_ERANGE:         attr_in != NULL and attr_in->prio out of
  *                          range.
  *      DSP_EFAIL:          A failure occured, unable to allocate node.
  *      DSP_EWRONGSTATE:    Proccessor is not in the running state.
  *  Requires:
- *      NODE_Init(void) called.
- *      hProcessor != NULL.
+ *      node_init(void) called.
+ *      hprocessor != NULL.
  *      pNodeId != NULL.
- *      phNode != NULL.
+ *      ph_node != NULL.
  *  Ensures:
- *      DSP_SOK:            IsValidNode(*phNode).
- *      error:              *phNode == NULL.
+ *      DSP_SOK:            IsValidNode(*ph_node).
+ *      error:              *ph_node == NULL.
  */
-	extern DSP_STATUS NODE_Allocate(struct PROC_OBJECT *hProcessor,
-					IN CONST struct DSP_UUID *pNodeId,
-					OPTIONAL IN CONST struct DSP_CBDATA
-					*pArgs,
-					OPTIONAL IN CONST struct DSP_NODEATTRIN
-					*pAttrIn,
-					OUT struct NODE_OBJECT **phNode,
-					struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status node_allocate(struct proc_object *hprocessor,
+				IN CONST struct dsp_uuid *pNodeId,
+				OPTIONAL IN CONST struct dsp_cbdata
+				*pargs, OPTIONAL IN CONST struct dsp_nodeattrin
+				*attr_in,
+				OUT struct node_object **ph_node,
+				struct process_context *pr_ctxt);
 
 /*
- *  ======== NODE_AllocMsgBuf ========
+ *  ======== node_alloc_msg_buf ========
  *  Purpose:
  *      Allocate and Prepare a buffer whose descriptor will be passed to a
- *      Node within a (DSP_MSG)message
+ *      Node within a (dsp_msg)message
  *  Parameters:
- *      hNode:          The node handle.
- *      uSize:          The size of the buffer to be allocated.
- *      pAttr:          Pointer to a DSP_BUFFERATTR structure.
- *      pBuffer:        Location to store the address of the allocated
+ *      hnode:          The node handle.
+ *      usize:          The size of the buffer to be allocated.
+ *      pattr:          Pointer to a dsp_bufferattr structure.
+ *      pbuffer:        Location to store the address of the allocated
  *                      buffer on output.
  *  Returns:
  *      DSP_SOK:        Success.
@@ -126,27 +81,25 @@
  *      DSP_EFAIL:      General Failure.
  *      DSP_ESIZE:      Invalid Size.
  *  Requires:
- *      NODE_Init(void) called.
- *      pBuffer != NULL.
+ *      node_init(void) called.
+ *      pbuffer != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_AllocMsgBuf(struct NODE_OBJECT *hNode,
-					   u32 uSize,
-					   OPTIONAL struct DSP_BUFFERATTR
-					   *pAttr,
-					   OUT u8 **pBuffer);
+extern dsp_status node_alloc_msg_buf(struct node_object *hnode,
+				     u32 usize, OPTIONAL struct dsp_bufferattr
+				     *pattr, OUT u8 **pbuffer);
 
 /*
- *  ======== NODE_ChangePriority ========
+ *  ======== node_change_priority ========
  *  Purpose:
  *      Change the priority of an allocated node.
  *  Parameters:
- *      hNode:              Node handle returned from NODE_Allocate.
- *      nPriority:          New priority level to set node's priority to.
+ *      hnode:              Node handle returned from node_allocate.
+ *      prio:          New priority level to set node's priority to.
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
- *      DSP_ERANGE:         nPriority is out of range.
+ *      DSP_EHANDLE:        Invalid hnode.
+ *      DSP_ERANGE:         prio is out of range.
  *      DSP_ENODETYPE:      The specified node is not a task node.
  *      DSP_EWRONGSTATE:    Node is not in the NODE_ALLOCATED, NODE_PAUSED,
  *                          or NODE_RUNNING state.
@@ -155,33 +108,32 @@
  *                          being restarted.
  *      DSP_EFAIL:          Unable to change node's runtime priority level.
  *  Requires:
- *      NODE_Init(void) called.
+ *      node_init(void) called.
  *  Ensures:
- *      DSP_SOK && (Node's current priority == nPriority)
+ *      DSP_SOK && (Node's current priority == prio)
  */
-	extern DSP_STATUS NODE_ChangePriority(struct NODE_OBJECT *hNode,
-					      s32 nPriority);
+extern dsp_status node_change_priority(struct node_object *hnode, s32 prio);
 
 /*
- *  ======== NODE_CloseOrphans ========
+ *  ======== node_close_orphans ========
  *  Purpose:
  *      Delete all nodes whose owning processor is being destroyed.
  *  Parameters:
- *      hNodeMgr:       Node manager object.
+ *      hnode_mgr:       Node manager object.
  *      hProc:          Handle to processor object being destroyed.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Unable to delete all nodes belonging to hProc.
  *  Requires:
- *      Valid hNodeMgr.
+ *      Valid hnode_mgr.
  *      hProc != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_CloseOrphans(struct NODE_MGR *hNodeMgr,
-					    struct PROC_OBJECT *hProc);
+extern dsp_status node_close_orphans(struct node_mgr *hnode_mgr,
+				     struct proc_object *hProc);
 
 /*
- *  ======== NODE_Connect ========
+ *  ======== node_connect ========
  *  Purpose:
  *      Connect two nodes on the DSP, or a node on the DSP to the GPP. In the
  *      case that the connnection is being made between a node on the DSP and
@@ -196,20 +148,20 @@
  *      hNode2:         Handle of second node. Must be either NODE_HGPPNODE
  *                      if this is a connection from DSP node to GPP, or a
  *                      node handle returned from a successful call to
- *                      NODE_Allocate().
+ *                      node_allocate().
  *      uStream1:       Output stream index on first node, to be connected
  *                      to second node's input stream. Value must range from
  *                      0 <= uStream1 < number of output streams.
  *      uStream2:       Input stream index on second node. Value must range
  *                      from 0 <= uStream2 < number of input streams.
- *      pAttrs:         Stream attributes (NULL ==> use defaults).
- *      pConnParam:     A pointer to a DSP_CBDATA structure that defines
+ *      pattrs:         Stream attributes (NULL ==> use defaults).
+ *      conn_param:     A pointer to a dsp_cbdata structure that defines
  *                      connection parameter for device nodes to pass to DSP
  *                      side.
  *                      If the value of this parameter is NULL, then this API
  *                      behaves like DSPNode_Connect. This parameter will have
  *                      length of the string and the null terminated string in
- *                      DSP_CBDATA struct. This can be extended in future tp
+ *                      dsp_cbdata struct. This can be extended in future tp
  *                      pass binary data.
  *  Returns:
  *      DSP_SOK:                Success.
@@ -225,28 +177,28 @@
  *                              Device node to device node, or device node to
  *                              GPP), the two nodes are on different DSPs.
  *  Requires:
- *      NODE_Init(void) called.
+ *      node_init(void) called.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_Connect(struct NODE_OBJECT *hNode1,
-				       u32 uStream1,
-				       struct NODE_OBJECT *hNode2,
-				       u32 uStream2,
-				       OPTIONAL IN struct DSP_STRMATTR *pAttrs,
-				       OPTIONAL IN struct DSP_CBDATA
-				       *pConnParam);
+extern dsp_status node_connect(struct node_object *hNode1,
+			       u32 uStream1,
+			       struct node_object *hNode2,
+			       u32 uStream2,
+			       OPTIONAL IN struct dsp_strmattr *pattrs,
+			       OPTIONAL IN struct dsp_cbdata
+			       *conn_param);
 
 /*
- *  ======== NODE_Create ========
+ *  ======== node_create ========
  *  Purpose:
  *      Create a node on the DSP by remotely calling the node's create
  *      function. If necessary, load code that contains the node's create
  *      function.
  *  Parameters:
- *      hNode:              Node handle returned from NODE_Allocate().
+ *      hnode:              Node handle returned from node_allocate().
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_EHANDLE:        Invalid hnode.
  *      DSP_ESYMBOL:        Create function not found in the COFF file.
  *      DSP_EWRONGSTATE:    Node is not in the NODE_ALLOCATED state.
  *      DSP_EMEMORY:        Memory allocation failure on the DSP.
@@ -256,13 +208,13 @@
  *      DSP_EUSER1-16:      A user-defined failure occurred on the DSP.
  *      DSP_EFAIL:          A failure occurred, unable to create node.
  *  Requires:
- *      NODE_Init(void) called.
+ *      node_init(void) called.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_Create(struct NODE_OBJECT *hNode);
+extern dsp_status node_create(struct node_object *hnode);
 
 /*
- *  ======== NODE_CreateMgr ========
+ *  ======== node_create_mgr ========
  *  Purpose:
  *      Create a NODE Manager object. This object handles the creation,
  *      deletion, and execution of nodes on the DSP target. The NODE Manager
@@ -271,195 +223,193 @@
  *
  *  Parameters:
  *      phNodeMgr:      Location to store node manager handle on output.
- *      hDevObject:     Device for this processor.
+ *      hdev_obj:     Device for this processor.
  *  Returns:
  *      DSP_SOK:        Success;
  *      DSP_EMEMORY:    Insufficient memory for requested resources.
  *      DSP_EFAIL:      General failure.
  *  Requires:
- *      NODE_Init(void) called.
+ *      node_init(void) called.
  *      phNodeMgr != NULL.
- *      hDevObject != NULL.
+ *      hdev_obj != NULL.
  *  Ensures:
  *      DSP_SOK:        Valide *phNodeMgr.
  *      error:          *phNodeMgr == NULL.
  */
-	extern DSP_STATUS NODE_CreateMgr(OUT struct NODE_MGR **phNodeMgr,
-					 struct DEV_OBJECT *hDevObject);
+extern dsp_status node_create_mgr(OUT struct node_mgr **phNodeMgr,
+				  struct dev_object *hdev_obj);
 
 /*
- *  ======== NODE_Delete ========
+ *  ======== node_delete ========
  *  Purpose:
- *      Delete resources allocated in NODE_Allocate(). If the node was
+ *      Delete resources allocated in node_allocate(). If the node was
  *      created, delete the node on the DSP by remotely calling the node's
  *      delete function. Loads the node's delete function if necessary.
  *      GPP side resources are freed after node's delete function returns.
  *  Parameters:
- *      hNode:              Node handle returned from NODE_Allocate().
+ *      hnode:              Node handle returned from node_allocate().
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_EHANDLE:        Invalid hnode.
  *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
  *      DSP_EDELETE:        A deletion failure occurred.
  *      DSP_EUSER1-16:      Node specific failure occurred on the DSP.
  *      DSP_EFAIL:          A failure occurred in deleting the node.
  *      DSP_ESYMBOL:        Delete function not found in the COFF file.
  *  Requires:
- *      NODE_Init(void) called.
+ *      node_init(void) called.
  *  Ensures:
- *      DSP_SOK:            hNode is invalid.
+ *      DSP_SOK:            hnode is invalid.
  */
-	extern DSP_STATUS NODE_Delete(struct NODE_OBJECT *hNode,
-			struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status node_delete(struct node_object *hnode,
+			      struct process_context *pr_ctxt);
 
 /*
- *  ======== NODE_DeleteMgr ========
+ *  ======== node_delete_mgr ========
  *  Purpose:
  *      Delete the NODE Manager.
  *  Parameters:
- *      hNodeMgr:       Node manager object.
+ *      hnode_mgr:       Node manager object.
  *  Returns:
  *      DSP_SOK:        Success.
  *  Requires:
- *      NODE_Init(void) called.
- *      Valid hNodeMgr.
+ *      node_init(void) called.
+ *      Valid hnode_mgr.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_DeleteMgr(struct NODE_MGR *hNodeMgr);
+extern dsp_status node_delete_mgr(struct node_mgr *hnode_mgr);
 
 /*
- *  ======== NODE_EnumNodes ========
+ *  ======== node_enum_nodes ========
  *  Purpose:
  *      Enumerate the nodes currently allocated for the DSP.
  *  Parameters:
- *      hNodeMgr:       Node manager returned from NODE_CreateMgr().
- *      aNodeTab:       Array to copy node handles into.
- *      uNodeTabSize:   Number of handles that can be written to aNodeTab.
- *      puNumNodes:     Location where number of node handles written to
- *                      aNodeTab will be written.
- *      puAllocated:    Location to write total number of allocated nodes.
+ *      hnode_mgr:       Node manager returned from node_create_mgr().
+ *      node_tab:       Array to copy node handles into.
+ *      node_tab_size:   Number of handles that can be written to node_tab.
+ *      pu_num_nodes:     Location where number of node handles written to
+ *                      node_tab will be written.
+ *      pu_allocated:    Location to write total number of allocated nodes.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_ESIZE:      aNodeTab is too small to hold all node handles.
+ *      DSP_ESIZE:      node_tab is too small to hold all node handles.
  *  Requires:
- *      Valid hNodeMgr.
- *      aNodeTab != NULL || uNodeTabSize == 0.
- *      puNumNodes != NULL.
- *      puAllocated != NULL.
+ *      Valid hnode_mgr.
+ *      node_tab != NULL || node_tab_size == 0.
+ *      pu_num_nodes != NULL.
+ *      pu_allocated != NULL.
  *  Ensures:
- *      - (DSP_ESIZE && *puNumNodes == 0)
- *      - || (DSP_SOK && *puNumNodes <= uNodeTabSize)  &&
- *        (*puAllocated == *puNumNodes)
+ *      - (DSP_ESIZE && *pu_num_nodes == 0)
+ *      - || (DSP_SOK && *pu_num_nodes <= node_tab_size)  &&
+ *        (*pu_allocated == *pu_num_nodes)
  */
-	extern DSP_STATUS NODE_EnumNodes(struct NODE_MGR *hNodeMgr,
-					 IN DSP_HNODE *aNodeTab,
-					 u32 uNodeTabSize,
-					 OUT u32 *puNumNodes,
-					 OUT u32 *puAllocated);
+extern dsp_status node_enum_nodes(struct node_mgr *hnode_mgr,
+				  void **node_tab,
+				  u32 node_tab_size,
+				  OUT u32 *pu_num_nodes,
+				  OUT u32 *pu_allocated);
 
 /*
- *  ======== NODE_Exit ========
+ *  ======== node_exit ========
  *  Purpose:
  *      Discontinue usage of NODE module.
  *  Parameters:
  *  Returns:
  *  Requires:
- *      NODE_Init(void) successfully called before.
+ *      node_init(void) successfully called before.
  *  Ensures:
- *      Any resources acquired in NODE_Init(void) will be freed when last NODE
- *      client calls NODE_Exit(void).
+ *      Any resources acquired in node_init(void) will be freed when last NODE
+ *      client calls node_exit(void).
  */
-	extern void NODE_Exit(void);
+extern void node_exit(void);
 
 /*
- *  ======== NODE_FreeMsgBuf ========
+ *  ======== node_free_msg_buf ========
  *  Purpose:
- *      Free a message buffer previously allocated with NODE_AllocMsgBuf.
+ *      Free a message buffer previously allocated with node_alloc_msg_buf.
  *  Parameters:
- *      hNode:          The node handle.
- *      pBuffer:        (Address) Buffer allocated by NODE_AllocMsgBuf.
- *      pAttr:          Same buffer attributes passed to NODE_AllocMsgBuf.
+ *      hnode:          The node handle.
+ *      pbuffer:        (Address) Buffer allocated by node_alloc_msg_buf.
+ *      pattr:          Same buffer attributes passed to node_alloc_msg_buf.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid node handle.
  *      DSP_EFAIL:      Failure to free the buffer.
  *  Requires:
- *      NODE_Init(void) called.
- *      pBuffer != NULL.
+ *      node_init(void) called.
+ *      pbuffer != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_FreeMsgBuf(struct NODE_OBJECT *hNode,
-					  IN u8 *pBuffer,
-					  OPTIONAL struct DSP_BUFFERATTR
-					  *pAttr);
+extern dsp_status node_free_msg_buf(struct node_object *hnode,
+				    IN u8 *pbuffer,
+				    OPTIONAL struct dsp_bufferattr
+				    *pattr);
 
 /*
- *  ======== NODE_GetAttr ========
+ *  ======== node_get_attr ========
  *  Purpose:
- *      Copy the current attributes of the specified node into a DSP_NODEATTR
+ *      Copy the current attributes of the specified node into a dsp_nodeattr
  *      structure.
  *  Parameters:
- *      hNode:          Node object allocated from NODE_Allocate().
- *      pAttr:          Pointer to DSP_NODEATTR structure to copy node's
+ *      hnode:          Node object allocated from node_allocate().
+ *      pattr:          Pointer to dsp_nodeattr structure to copy node's
  *                      attributes.
- *      uAttrSize:      Size of pAttr.
+ *      attr_size:      Size of pattr.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_EHANDLE:    Invalid hnode.
  *  Requires:
- *      NODE_Init(void) called.
- *      pAttr != NULL.
+ *      node_init(void) called.
+ *      pattr != NULL.
  *  Ensures:
- *      DSP_SOK:        *pAttrs contains the node's current attributes.
+ *      DSP_SOK:        *pattrs contains the node's current attributes.
  */
-	extern DSP_STATUS NODE_GetAttr(struct NODE_OBJECT *hNode,
-				       OUT struct DSP_NODEATTR *pAttr,
-				       u32 uAttrSize);
+extern dsp_status node_get_attr(struct node_object *hnode,
+				OUT struct dsp_nodeattr *pattr, u32 attr_size);
 
 /*
- *  ======== NODE_GetMessage ========
+ *  ======== node_get_message ========
  *  Purpose:
  *      Retrieve a message from a node on the DSP. The node must be either a
  *      message node, task node, or XDAIS socket node.
  *      If a message is not available, this function will block until a
  *      message is available, or the node's timeout value is reached.
  *  Parameters:
- *      hNode:          Node handle returned from NODE_Allocate().
- *      pMessage:       Pointer to DSP_MSG structure to copy the
+ *      hnode:          Node handle returned from node_allocate().
+ *      message:       Pointer to dsp_msg structure to copy the
  *                      message into.
- *      uTimeout:       Timeout in milliseconds to wait for message.
+ *      utimeout:       Timeout in milliseconds to wait for message.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_EHANDLE:    Invalid hnode.
  *      DSP_ENODETYPE:  Cannot retrieve messages from this type of node.
  *      DSP_ETIMEOUT:   Timeout occurred and no message is available.
  *      DSP_EFAIL:      Error occurred while trying to retrieve a message.
  *  Requires:
- *      NODE_Init(void) called.
- *      pMessage != NULL.
+ *      node_init(void) called.
+ *      message != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_GetMessage(struct NODE_OBJECT *hNode,
-					  OUT struct DSP_MSG *pMessage,
-					  u32 uTimeout);
+extern dsp_status node_get_message(struct node_object *hnode,
+				   OUT struct dsp_msg *message, u32 utimeout);
 
 /*
- *  ======== NODE_GetNldrObj ========
+ *  ======== node_get_nldr_obj ========
  *  Purpose:
  *      Retrieve the Nldr manager
  *  Parameters:
- *      hNodeMgr:       Node Manager
+ *      hnode_mgr:       Node Manager
  *      phNldrObj:      Pointer to a Nldr manager handle
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_EHANDLE:    Invalid hnode.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_GetNldrObj(struct NODE_MGR *hNodeMgr,
-					  OUT struct NLDR_OBJECT **phNldrObj);
+extern dsp_status node_get_nldr_obj(struct node_mgr *hnode_mgr,
+				    OUT struct nldr_object **phNldrObj);
 
 /*
- *  ======== NODE_Init ========
+ *  ======== node_init ========
  *  Purpose:
  *      Initialize the NODE module.
  *  Parameters:
@@ -467,156 +417,153 @@
  *      TRUE if initialization succeeded, FALSE otherwise.
  *  Ensures:
  */
-	extern bool NODE_Init(void);
+extern bool node_init(void);
 
 /*
- *  ======== NODE_OnExit ========
+ *  ======== node_on_exit ========
  *  Purpose:
  *      Gets called when RMS_EXIT is received for a node. PROC needs to pass
- *      this function as a parameter to MSG_Create(). This function then gets
+ *      this function as a parameter to msg_create(). This function then gets
  *      called by the mini-driver when an exit message for a node is received.
  *  Parameters:
- *      hNode:      Handle of the node that the exit message is for.
+ *      hnode:      Handle of the node that the exit message is for.
  *      nStatus:    Return status of the node's execute phase.
  *  Returns:
  *  Ensures:
  */
-	void NODE_OnExit(struct NODE_OBJECT *hNode, s32 nStatus);
+void node_on_exit(struct node_object *hnode, s32 nStatus);
 
 /*
- *  ======== NODE_Pause ========
+ *  ======== node_pause ========
  *  Purpose:
  *      Suspend execution of a node currently running on the DSP.
  *  Parameters:
- *      hNode:              Node object representing a node currently
+ *      hnode:              Node object representing a node currently
  *                          running on the DSP.
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_EHANDLE:        Invalid hnode.
  *      DSP_ENODETYPE:      Node is not a task or socket node.
  *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
  *      DSP_EWRONGSTSATE:   Node is not in NODE_RUNNING state.
  *      DSP_EFAIL:          Failed to pause node.
  *  Requires:
- *      NODE_Init(void) called.
+ *      node_init(void) called.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_Pause(struct NODE_OBJECT *hNode);
+extern dsp_status node_pause(struct node_object *hnode);
 
 /*
- *  ======== NODE_PutMessage ========
+ *  ======== node_put_message ========
  *  Purpose:
  *      Send a message to a message node, task node, or XDAIS socket node.
  *      This function will block until the message stream can accommodate
  *      the message, or a timeout occurs. The message will be copied, so Msg
  *      can be re-used immediately after return.
  *  Parameters:
- *      hNode:              Node handle returned by NODE_Allocate().
- *      pMsg:               Location of message to be sent to the node.
- *      uTimeout:           Timeout in msecs to wait.
+ *      hnode:              Node handle returned by node_allocate().
+ *      pmsg:               Location of message to be sent to the node.
+ *      utimeout:           Timeout in msecs to wait.
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_EHANDLE:        Invalid hnode.
  *      DSP_ENODETYPE:      Messages can't be sent to this type of node.
  *      DSP_ETIMEOUT:       Timeout occurred before message could be set.
  *      DSP_EWRONGSTATE:    Node is in invalid state for sending messages.
  *      DSP_EFAIL:          Unable to send message.
  *  Requires:
- *      NODE_Init(void) called.
- *      pMsg != NULL.
+ *      node_init(void) called.
+ *      pmsg != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_PutMessage(struct NODE_OBJECT *hNode,
-					  IN CONST struct DSP_MSG *pMsg,
-					  u32 uTimeout);
+extern dsp_status node_put_message(struct node_object *hnode,
+				   IN CONST struct dsp_msg *pmsg, u32 utimeout);
 
 /*
- *  ======== NODE_RegisterNotify ========
+ *  ======== node_register_notify ========
  *  Purpose:
  *      Register to be notified on specific events for this node.
  *  Parameters:
- *      hNode:          Node handle returned by NODE_Allocate().
- *      uEventMask:     Mask of types of events to be notified about.
- *      uNotifyType:    Type of notification to be sent.
- *      hNotification:  Handle to be used for notification.
+ *      hnode:          Node handle returned by node_allocate().
+ *      event_mask:     Mask of types of events to be notified about.
+ *      notify_type:    Type of notification to be sent.
+ *      hnotification:  Handle to be used for notification.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_EHANDLE:    Invalid hnode.
  *      DSP_EMEMORY:    Insufficient memory on GPP.
- *      DSP_EVALUE:     uEventMask is invalid.
- *      DSP_ENOTIMPL:   Notification type specified by uNotifyType is not
+ *      DSP_EVALUE:     event_mask is invalid.
+ *      DSP_ENOTIMPL:   Notification type specified by notify_type is not
  *                      supported.
  *  Requires:
- *      NODE_Init(void) called.
- *      hNotification != NULL.
+ *      node_init(void) called.
+ *      hnotification != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_RegisterNotify(struct NODE_OBJECT *hNode,
-					      u32 uEventMask, u32 uNotifyType,
-					      struct DSP_NOTIFICATION
-					      *hNotification);
+extern dsp_status node_register_notify(struct node_object *hnode,
+				       u32 event_mask, u32 notify_type,
+				       struct dsp_notification
+				       *hnotification);
 
 /*
- *  ======== NODE_Run ========
+ *  ======== node_run ========
  *  Purpose:
  *      Start execution of a node's execute phase, or resume execution of
- *      a node that has been suspended (via NODE_Pause()) on the DSP. Load
+ *      a node that has been suspended (via node_pause()) on the DSP. Load
  *      the node's execute function if necessary.
  *  Parameters:
- *      hNode:              Node object representing a node currently
+ *      hnode:              Node object representing a node currently
  *                          running on the DSP.
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
- *      DSP_ENODETYPE:      hNode doesn't represent a message, task or dais
+ *      DSP_EHANDLE:        Invalid hnode.
+ *      DSP_ENODETYPE:      hnode doesn't represent a message, task or dais
  *                          socket node.
  *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
  *      DSP_EWRONGSTSATE:   Node is not in NODE_PAUSED or NODE_CREATED state.
  *      DSP_EFAIL:          Unable to start or resume execution.
  *      DSP_ESYMBOL:        Execute function not found in the COFF file.
  *  Requires:
- *      NODE_Init(void) called.
+ *      node_init(void) called.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_Run(struct NODE_OBJECT *hNode);
+extern dsp_status node_run(struct node_object *hnode);
 
 /*
- *  ======== NODE_Terminate ========
+ *  ======== node_terminate ========
  *  Purpose:
  *      Signal a node running on the DSP that it should exit its execute
  *      phase function.
  *  Parameters:
- *      hNode:              Node object representing a node currently
+ *      hnode:              Node object representing a node currently
  *                          running on the DSP.
- *      pStatus:            Location to store execute-phase function return
+ *      pstatus:            Location to store execute-phase function return
  *                          value (DSP_EUSER1-16).
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_EHANDLE:        Invalid hnode.
  *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
  *      DSP_ENODETYPE:      Type of node specified cannot be terminated.
  *      DSP_EWRONGSTATE:    Operation not valid for the current node state.
  *      DSP_EFAIL:          Unable to terminate the node.
  *  Requires:
- *      NODE_Init(void) called.
- *      pStatus != NULL.
+ *      node_init(void) called.
+ *      pstatus != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_Terminate(struct NODE_OBJECT *hNode,
-					 OUT DSP_STATUS *pStatus);
-
-
+extern dsp_status node_terminate(struct node_object *hnode,
+				 OUT dsp_status *pstatus);
 
 /*
- *  ======== NODE_GetUUIDProps ========
+ *  ======== node_get_uuid_props ========
  *  Purpose:
  *      Fetch Node properties given the UUID
  *  Parameters:
  *
  */
-	extern DSP_STATUS NODE_GetUUIDProps(DSP_HPROCESSOR hProcessor,
-					    IN CONST struct DSP_UUID *pNodeId,
-					    OUT struct DSP_NDBPROPS
-					    *pNodeProps);
+extern dsp_status node_get_uuid_props(void *hprocessor,
+				      IN CONST struct dsp_uuid *pNodeId,
+				      OUT struct dsp_ndbprops
+				      *node_props);
 
-#endif				/* NODE_ */
+#endif /* NODE_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/nodepriv.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/nodepriv.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/nodepriv.h	2011-10-11 13:50:58.016663133 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/nodepriv.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Private node header shared by NODE and DISP.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,27 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== nodepriv.h ========
- *  Description:
- *      Private node header shared by NODE and DISP.
- *
- *  Public Functions:
- *      NODE_GetChannelId
- *      NODE_GetStrmMgr
- *      NODE_GetTimeout
- *      NODE_GetType
- *      NODE_GetLoadType
- *
- *! Revision History
- *! ================
- *! 19-Nov-2002 map     Added NODE_GetLoadType
- *! 13-Feb-2002 jeh     Added uSysStackSize to NODE_TASKARGS.
- *! 23-Apr-2001 jeh     Removed unused typedefs, defines.
- *! 10-Oct-2000 jeh     Added alignment to NODE_STRMDEF.
- *! 20-Jun-2000 jeh     Created.
- */
-
 #ifndef NODEPRIV_
 #define NODEPRIV_
 
@@ -43,160 +24,159 @@
 #include <dspbridge/nldrdefs.h>
 
 /* DSP address of node environment structure */
-	typedef u32 NODE_ENV;
+typedef u32 nodeenv;
 
 /*
  *  Node create structures
  */
 
 /* Message node */
-	struct NODE_MSGARGS {
-		u32 uMaxMessages; /* Max # of simultaneous messages for node */
-		u32 uSegid;	/* Segment for allocating message buffers */
-		u32 uNotifyType;  /* Notify type (SEM_post, SWI_post, etc.) */
-		u32 uArgLength;  /* Length in 32-bit words of arg data block */
-		u8 *pData;	/* Argument data for node */
-	} ;
-
-	struct NODE_STRMDEF {
-		u32 uBufsize;	/* Size of buffers for SIO stream */
-		u32 uNumBufs;	/* max # of buffers in SIO stream at once */
-		u32 uSegid;	/* Memory segment id to allocate buffers */
-		u32 uTimeout;	/* Timeout for blocking SIO calls */
-		u32 uAlignment;	/* Buffer alignment */
-		char *szDevice;	/* Device name for stream */
-	} ;
+struct node_msgargs {
+	u32 max_msgs;		/* Max # of simultaneous messages for node */
+	u32 seg_id;		/* Segment for allocating message buffers */
+	u32 notify_type;	/* Notify type (SEM_post, SWI_post, etc.) */
+	u32 arg_length;		/* Length in 32-bit words of arg data block */
+	u8 *pdata;		/* Argument data for node */
+};
+
+struct node_strmdef {
+	u32 buf_size;		/* Size of buffers for SIO stream */
+	u32 num_bufs;		/* max # of buffers in SIO stream at once */
+	u32 seg_id;		/* Memory segment id to allocate buffers */
+	u32 utimeout;		/* Timeout for blocking SIO calls */
+	u32 buf_alignment;	/* Buffer alignment */
+	char *sz_device;	/* Device name for stream */
+};
 
 /* Task node */
-	struct NODE_TASKARGS {
-		struct NODE_MSGARGS msgArgs;
-		s32 nPriority;
-		u32 uStackSize;
-		u32 uSysStackSize;
-		u32 uStackSeg;
-		u32 uDSPHeapResAddr;	/* DSP virtual heap address */
-		u32 uDSPHeapAddr;	/* DSP virtual heap address */
-		u32 uHeapSize;	/* Heap size */
-		u32 uGPPHeapAddr;	/* GPP virtual heap address */
-		u32 uProfileID;	/* Profile ID */
-		u32 uNumInputs;
-		u32 uNumOutputs;
-		u32 ulDaisArg;	/* Address of iAlg object */
-		struct NODE_STRMDEF *strmInDef;
-		struct NODE_STRMDEF *strmOutDef;
-	} ;
-
-/*
- *  ======== NODE_CREATEARGS ========
- */
-	struct NODE_CREATEARGS {
-		union {
-			struct NODE_MSGARGS msgArgs;
-			struct NODE_TASKARGS taskArgs;
-		} asa;
-	} ;
+struct node_taskargs {
+	struct node_msgargs node_msg_args;
+	s32 prio;
+	u32 stack_size;
+	u32 sys_stack_size;
+	u32 stack_seg;
+	u32 udsp_heap_res_addr;	/* DSP virtual heap address */
+	u32 udsp_heap_addr;	/* DSP virtual heap address */
+	u32 heap_size;		/* Heap size */
+	u32 ugpp_heap_addr;	/* GPP virtual heap address */
+	u32 profile_id;		/* Profile ID */
+	u32 num_inputs;
+	u32 num_outputs;
+	u32 ul_dais_arg;	/* Address of iAlg object */
+	struct node_strmdef *strm_in_def;
+	struct node_strmdef *strm_out_def;
+};
+
+/*
+ *  ======== node_createargs ========
+ */
+struct node_createargs {
+	union {
+		struct node_msgargs node_msg_args;
+		struct node_taskargs task_arg_obj;
+	} asa;
+};
 
 /*
- *  ======== NODE_GetChannelId ========
+ *  ======== node_get_channel_id ========
  *  Purpose:
  *      Get the channel index reserved for a stream connection between the
- *      host and a node. This index is reserved when NODE_Connect() is called
+ *      host and a node. This index is reserved when node_connect() is called
  *      to connect the node with the host. This index should be passed to
  *      the CHNL_Open function when the stream is actually opened.
  *  Parameters:
- *      hNode:          Node object allocated from NODE_Allocate().
- *      uDir:           Input (DSP_TONODE) or output (DSP_FROMNODE).
- *      uIndex:         Stream index.
+ *      hnode:          Node object allocated from node_allocate().
+ *      dir:           Input (DSP_TONODE) or output (DSP_FROMNODE).
+ *      index:         Stream index.
  *      pulId:          Location to store channel index.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_EHANDLE:    Invalid hnode.
  *      DSP_ENODETYPE:  Not a task or DAIS socket node.
- *      DSP_EVALUE:     The node's stream corresponding to uIndex and uDir
+ *      DSP_EVALUE:     The node's stream corresponding to index and dir
  *                      is not a stream to or from the host.
  *  Requires:
- *      NODE_Init(void) called.
- *      Valid uDir.
+ *      node_init(void) called.
+ *      Valid dir.
  *      pulId != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_GetChannelId(struct NODE_OBJECT *hNode,
-					    u32 uDir,
-					    u32 uIndex, OUT u32 *pulId);
+extern dsp_status node_get_channel_id(struct node_object *hnode,
+				      u32 dir, u32 index, OUT u32 *pulId);
 
 /*
- *  ======== NODE_GetStrmMgr ========
+ *  ======== node_get_strm_mgr ========
  *  Purpose:
  *      Get the STRM manager for a node.
  *  Parameters:
- *      hNode:          Node allocated with NODE_Allocate().
+ *      hnode:          Node allocated with node_allocate().
  *      phStrmMgr:      Location to store STRM manager on output.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_EHANDLE:    Invalid hnode.
  *  Requires:
  *      phStrmMgr != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS NODE_GetStrmMgr(struct NODE_OBJECT *hNode,
-					  struct STRM_MGR **phStrmMgr);
+extern dsp_status node_get_strm_mgr(struct node_object *hnode,
+				    struct strm_mgr **phStrmMgr);
 
 /*
- *  ======== NODE_GetTimeout ========
+ *  ======== node_get_timeout ========
  *  Purpose:
  *      Get the timeout value of a node.
  *  Parameters:
- *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
+ *      hnode:      Node allocated with node_allocate(), or DSP_HGPPNODE.
  *  Returns:
  *      Node's timeout value.
  *  Requires:
- *      Valid hNode.
+ *      Valid hnode.
  *  Ensures:
  */
-	extern u32 NODE_GetTimeout(struct NODE_OBJECT *hNode);
+extern u32 node_get_timeout(struct node_object *hnode);
 
 /*
- *  ======== NODE_GetType ========
+ *  ======== node_get_type ========
  *  Purpose:
  *      Get the type (device, message, task, or XDAIS socket) of a node.
  *  Parameters:
- *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
+ *      hnode:      Node allocated with node_allocate(), or DSP_HGPPNODE.
  *  Returns:
  *      Node type:  NODE_DEVICE, NODE_TASK, NODE_XDAIS, or NODE_GPP.
  *  Requires:
- *      Valid hNode.
+ *      Valid hnode.
  *  Ensures:
  */
-	extern enum NODE_TYPE NODE_GetType(struct NODE_OBJECT *hNode);
+extern enum node_type node_get_type(struct node_object *hnode);
 
 /*
- *  ======== GetNodeInfo ========
+ *  ======== get_node_info ========
  *  Purpose:
  *      Get node information without holding semaphore.
  *  Parameters:
- *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
+ *      hnode:      Node allocated with node_allocate(), or DSP_HGPPNODE.
  *  Returns:
  *      Node info:  priority, device owner, no. of streams, execution state
  *                  NDB properties.
  *  Requires:
- *      Valid hNode.
+ *      Valid hnode.
  *  Ensures:
  */
-	extern void GetNodeInfo(struct NODE_OBJECT *hNode,
-				struct DSP_NODEINFO *pNodeInfo);
+extern void get_node_info(struct node_object *hnode,
+			  struct dsp_nodeinfo *pNodeInfo);
 
 /*
- *  ======== NODE_GetLoadType ========
+ *  ======== node_get_load_type ========
  *  Purpose:
  *      Get the load type (dynamic, overlay, static) of a node.
  *  Parameters:
- *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
+ *      hnode:      Node allocated with node_allocate(), or DSP_HGPPNODE.
  *  Returns:
  *      Node type:  NLDR_DYNAMICLOAD, NLDR_OVLYLOAD, NLDR_STATICLOAD
  *  Requires:
- *      Valid hNode.
+ *      Valid hnode.
  *  Ensures:
  */
-	extern enum NLDR_LOADTYPE NODE_GetLoadType(struct NODE_OBJECT *hNode);
+extern enum nldr_loadtype node_get_load_type(struct node_object *hnode);
 
-#endif				/* NODEPRIV_ */
+#endif /* NODEPRIV_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/ntfy.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/ntfy.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/ntfy.h	2011-10-11 13:50:58.016663133 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/ntfy.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Manage lists of notification events.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,33 +16,13 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== ntfy.h ========
- *  Purpose:
- *      Manage lists of notification events.
- *
- *  Public Functions:
- *      NTFY_Create
- *      NTFY_Delete
- *      NTFY_Exit
- *      NTFY_Init
- *      NTFY_Notify
- *      NTFY_Register
- *
- *! Revision History:
- *! =================
- *! 05-Nov-2001 kc: Updated NTFY_Register.
- *! 07-Sep-2000 jeh Created.
- */
-
 #ifndef NTFY_
 #define NTFY_
 
-	struct NTFY_OBJECT;
+struct ntfy_object;
 
 /*
- *  ======== NTFY_Create ========
+ *  ======== ntfy_create ========
  *  Purpose:
  *      Create an empty list of notifications.
  *  Parameters:
@@ -49,41 +31,41 @@
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Memory allocation failure.
  *  Requires:
- *      NTFY_Init(void) called.
+ *      ntfy_init(void) called.
  *      phNtfy != NULL.
  *  Ensures:
- *      DSP_SUCCEEDED(status) <==>  IsValid(*phNtfy).
+ *      DSP_SUCCEEDED(status) <==>  IS_VALID(*phNtfy).
  */
-	extern DSP_STATUS NTFY_Create(OUT struct NTFY_OBJECT **phNtfy);
+extern dsp_status ntfy_create(OUT struct ntfy_object **phNtfy);
 
 /*
- *  ======== NTFY_Delete ========
+ *  ======== ntfy_delete ========
  *  Purpose:
- *      Free resources allocated in NTFY_Create.
+ *      Free resources allocated in ntfy_create.
  *  Parameters:
- *      hNtfy:  Handle returned from NTFY_Create().
+ *      ntfy_obj:  Handle returned from ntfy_create().
  *  Returns:
  *  Requires:
- *      NTFY_Init(void) called.
- *      IsValid(hNtfy).
+ *      ntfy_init(void) called.
+ *      IS_VALID(ntfy_obj).
  *  Ensures:
  */
-	extern void NTFY_Delete(IN struct NTFY_OBJECT *hNtfy);
+extern void ntfy_delete(IN struct ntfy_object *ntfy_obj);
 
 /*
- *  ======== NTFY_Exit ========
+ *  ======== ntfy_exit ========
  *  Purpose:
  *      Discontinue usage of NTFY module.
  *  Parameters:
  *  Returns:
  *  Requires:
- *      NTFY_Init(void) successfully called before.
+ *      ntfy_init(void) successfully called before.
  *  Ensures:
  */
-	extern void NTFY_Exit(void);
+extern void ntfy_exit(void);
 
 /*
- *  ======== NTFY_Init ========
+ *  ======== ntfy_init ========
  *  Purpose:
  *      Initialize the NTFY module.
  *  Parameters:
@@ -91,56 +73,53 @@
  *      TRUE if initialization succeeded, FALSE otherwise.
  *  Ensures:
  */
-	extern bool NTFY_Init(void);
+extern bool ntfy_init(void);
 
 /*
- *  ======== NTFY_Notify ========
+ *  ======== ntfy_notify ========
  *  Purpose:
  *      Execute notify function (signal event or post message) for every
  *      element in the notification list that is to be notified about the
- *      event specified in uEventMask.
+ *      event specified in event_mask.
  *  Parameters:
- *      hNtfy:      Handle returned from NTFY_Create().
- *      uEventMask: The type of event that has occurred.
+ *      ntfy_obj:      Handle returned from ntfy_create().
+ *      event_mask: The type of event that has occurred.
  *  Returns:
  *  Requires:
- *      NTFY_Init(void) called.
- *      IsValid(hNtfy).
+ *      ntfy_init(void) called.
+ *      IS_VALID(ntfy_obj).
  *  Ensures:
  */
-	extern void NTFY_Notify(IN struct NTFY_OBJECT *hNtfy,
-				IN u32 uEventMask);
+extern void ntfy_notify(IN struct ntfy_object *ntfy_obj, IN u32 event_mask);
 
 /*
- *  ======== NTFY_Register ========
+ *  ======== ntfy_register ========
  *  Purpose:
  *      Add a notification element to the list. If the notification is already
- *      registered, and uEventMask != 0, the notification will get posted for
+ *      registered, and event_mask != 0, the notification will get posted for
  *      events specified in the new event mask. If the notification is already
- *      registered and uEventMask == 0, the notification will be unregistered.
+ *      registered and event_mask == 0, the notification will be unregistered.
  *  Parameters:
- *      hNtfy:              Handle returned from NTFY_Create().
- *      hNotification:      Handle to a DSP_NOTIFICATION object.
- *      uEventMask:         Events to be notified about.
- *      uNotifyType:        Type of notification: DSP_SIGNALEVENT.
+ *      ntfy_obj:              Handle returned from ntfy_create().
+ *      hnotification:      Handle to a dsp_notification object.
+ *      event_mask:         Events to be notified about.
+ *      notify_type:        Type of notification: DSP_SIGNALEVENT.
  *  Returns:
  *      DSP_SOK:            Success.
  *      DSP_EMEMORY:        Insufficient memory.
- *      DSP_EVALUE:         uEventMask is 0 and hNotification was not
+ *      DSP_EVALUE:         event_mask is 0 and hnotification was not
  *                          previously registered.
- *      DSP_EHANDLE:        NULL hNotification, hNotification event name
- *                          too long, or hNotification event name NULL.
+ *      DSP_EHANDLE:        NULL hnotification, hnotification event name
+ *                          too long, or hnotification event name NULL.
  *  Requires:
- *      NTFY_Init(void) called.
- *      IsValid(hNtfy).
- *      hNotification != NULL.
- *      uNotifyType is DSP_SIGNALEVENT
+ *      ntfy_init(void) called.
+ *      IS_VALID(ntfy_obj).
+ *      hnotification != NULL.
+ *      notify_type is DSP_SIGNALEVENT
  *  Ensures:
  */
-	extern DSP_STATUS NTFY_Register(IN struct NTFY_OBJECT *hNtfy,
-					IN struct DSP_NOTIFICATION
-					*hNotification,
-					IN u32 uEventMask,
-					IN u32 uNotifyType);
+extern dsp_status ntfy_register(IN struct ntfy_object *ntfy_obj,
+				IN struct dsp_notification *hnotification,
+				IN u32 event_mask, IN u32 notify_type);
 
-#endif				/* NTFY_ */
+#endif /* NTFY_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/proc.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/proc.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/proc.h	2011-10-11 13:50:58.104784372 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/proc.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This is the Class driver RM module interface.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,51 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== proc.h ========
- *  Description:
- *	This is the Class driver RM module interface.
- *
- *  Public Functions:
- *      PROC_Attach
- *      PROC_Create
- *      PROC_Ctrl	       (OEM-function)
- *      PROC_Destroy
- *      PROC_Detach
- *      PROC_EnumNodes
- *      PROC_Exit
- *      PROC_FlushMemory
- *      PROC_GetDevObject       (OEM-function)
- *      PROC_GetResourceInfo
- *      PROC_GetState
- *      PROC_GetProcessorId
- *      PROC_GetTrace	   (OEM-function)
- *      PROC_Init
- *      PROC_Load	       (OEM-function)
- *      PROC_Map
- *      PROC_NotifyAllclients
- *      PROC_NotifyClients      (OEM-function)
- *      PROC_RegisterNotify
- *      PROC_ReserveMemory
- *      PROC_Start	      (OEM-function)
- *      PROC_UnMap
- *      PROC_UnReserveMemory
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping APIs
- *! 09-Feb-2003 vp: Added PROC_GetProcessorID function
- *! 29-Nov-2000 rr: Incorporated code review changes.
- *! 28-Sep-2000 rr: Updated to Version 0.9.
- *! 10-Aug-2000 rr: PROC_NotifyClients, PROC_GetProcessorHandle Added
- *! 27-Jul-2000 rr: Updated to ver 0.8 of DSPAPI(types). GetTrace added.
- *! 27-Jun-2000 rr: Created from dspapi.h
- */
-
 #ifndef PROC_
 #define PROC_
 
@@ -66,91 +23,67 @@
 #include <dspbridge/devdefs.h>
 #include <dspbridge/drv.h>
 
-/* The PROC_OBJECT structure.   */
-struct PROC_OBJECT {
-	struct LST_ELEM link;		/* Link to next PROC_OBJECT */
-	u32 dwSignature;		/* Used for object validation */
-	struct DEV_OBJECT *hDevObject;	/* Device this PROC represents */
-	u32 hProcess;			/* Process owning this Processor */
-	struct MGR_OBJECT *hMgrObject;	/* Manager Object Handle */
-	u32 uAttachCount;		/* Processor attach count */
-	u32 uProcessor;			/* Processor number */
-	u32 uTimeout;			/* Time out count */
-	enum DSP_PROCSTATE sState;	/* Processor state */
-	u32 ulUnit;			/* DDSP unit number */
-	bool bIsAlreadyAttached;	/*
-					 * True if the Device below has
-					 * GPP Client attached
-					 */
-	struct NTFY_OBJECT *hNtfy;	/* Manages  notifications */
-	struct WMD_DEV_CONTEXT *hWmdContext;	/* WMD Context Handle */
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
-	char *g_pszLastCoff;
-	struct list_head proc_object;
-};
-
 /*
- *  ======== PROC_Attach ========
+ *  ======== proc_attach ========
  *  Purpose:
  *      Prepare for communication with a particular DSP processor, and return
  *      a handle to the processor object. The PROC Object gets created
  *  Parameters:
- *      uProcessor  :	   The processor index (zero-based).
- *      hMgrObject  :	   Handle to the Manager Object
- *      pAttrIn     :	   Ptr to the DSP_PROCESSORATTRIN structure.
+ *      processor_id  :	   The processor index (zero-based).
+ *      hmgr_obj  :	   Handle to the Manager Object
+ *      attr_in     :	   Ptr to the dsp_processorattrin structure.
  *			      A NULL value means use default values.
- *      phProcessor :	   Ptr to location to store processor handle.
+ *      ph_processor :	   Ptr to location to store processor handle.
  *  Returns:
  *      DSP_SOK     :	   Success.
  *      DSP_EFAIL   :	   General failure.
  *      DSP_EHANDLE :	   Invalid processor handle.
  *      DSP_SALREADYATTACHED:   Success; Processor already attached.
  *  Requires:
- *      phProcessor != NULL.
+ *      ph_processor != NULL.
  *      PROC Initialized.
  *  Ensures:
- *      DSP_EFAIL, and *phProcessor == NULL, OR
- *      Success and *phProcessor is a Valid Processor handle OR
- *      DSP_SALREADYATTACHED and *phProcessor is a Valid Processor.
+ *      DSP_EFAIL, and *ph_processor == NULL, OR
+ *      Success and *ph_processor is a Valid Processor handle OR
+ *      DSP_SALREADYATTACHED and *ph_processor is a Valid Processor.
  *  Details:
- *      When pAttrIn is NULL, the default timeout value is 10 seconds.
+ *      When attr_in is NULL, the default timeout value is 10 seconds.
  */
-	extern DSP_STATUS PROC_Attach(u32 uProcessor,
-				      OPTIONAL CONST struct DSP_PROCESSORATTRIN
-				      *pAttrIn,
-				      OUT DSP_HPROCESSOR *phProcessor,
-				      struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status proc_attach(u32 processor_id,
+			      OPTIONAL CONST struct dsp_processorattrin
+			      *attr_in, void **ph_processor,
+			      struct process_context *pr_ctxt);
 
 /*
- *  ======== PROC_AutoStart =========
+ *  ======== proc_auto_start =========
  *  Purpose:
  *      A Particular device gets loaded with the default image
  *      if the AutoStart flag is set.
  *  Parameters:
- *      hDevObject  :   Handle to the Device
+ *      hdev_obj  :   Handle to the Device
  *  Returns:
  *      DSP_SOK     :   On Successful Loading
  *      DSP_EFILE   :   No DSP exec file found.
  *      DSP_EFAIL   :   General Failure
  *  Requires:
- *      hDevObject != NULL.
- *      hDevNode != NULL.
+ *      hdev_obj != NULL.
+ *      dev_node_obj != NULL.
  *      PROC Initialized.
  *  Ensures:
  */
-	extern DSP_STATUS PROC_AutoStart(struct CFG_DEVNODE *hDevNode,
-					 struct DEV_OBJECT *hDevObject);
+extern dsp_status proc_auto_start(struct cfg_devnode *dev_node_obj,
+				  struct dev_object *hdev_obj);
 
 /*
- *  ======== PROC_Ctrl ========
+ *  ======== proc_ctrl ========
  *  Purpose:
  *      Pass control information to the GPP device driver managing the DSP
  *      processor. This will be an OEM-only function, and not part of the
  *      'Bridge application developer's API.
  *  Parameters:
- *      hProcessor  :       The processor handle.
- *      dwCmd       :       Private driver IOCTL cmd ID.
- *      pArgs       :       Ptr to an driver defined argument structure.
+ *      hprocessor  :       The processor handle.
+ *      dw_cmd       :       Private driver IOCTL cmd ID.
+ *      pargs       :       Ptr to an driver defined argument structure.
  *  Returns:
  *      DSP_SOK     :       SUCCESS
  *      DSP_EHANDLE :       Invalid processor handle.
@@ -167,16 +100,16 @@
  *  Details:
  *      This function Calls WMD_BRD_Ioctl.
  */
-	extern DSP_STATUS PROC_Ctrl(DSP_HPROCESSOR hProcessor,
-				    u32 dwCmd, IN struct DSP_CBDATA *pArgs);
+extern dsp_status proc_ctrl(void *hprocessor,
+			    u32 dw_cmd, IN struct dsp_cbdata *pargs);
 
 /*
- *  ======== PROC_Detach ========
+ *  ======== proc_detach ========
  *  Purpose:
  *      Close a DSP processor and de-allocate all (GPP) resources reserved
  *      for it. The Processor Object is deleted.
  *  Parameters:
- *      hProcessor  :   The processor handle.
+ *      pr_ctxt     :   The processor handle.
  *  Returns:
  *      DSP_SOK     :   Success.
  *      DSP_EHANDLE :   InValid Handle.
@@ -186,55 +119,54 @@
  *  Ensures:
  *      PROC Object is destroyed.
  */
-	extern DSP_STATUS PROC_Detach(DSP_HPROCESSOR hProcessor,
-			struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status proc_detach(struct process_context *pr_ctxt);
 
 /*
- *  ======== PROC_EnumNodes ========
+ *  ======== proc_enum_nodes ========
  *  Purpose:
  *      Enumerate the nodes currently allocated on a processor.
  *  Parameters:
- *      hProcessor  :   The processor handle.
- *      aNodeTab    :   The first Location of an array allocated for node
+ *      hprocessor  :   The processor handle.
+ *      node_tab    :   The first Location of an array allocated for node
  *		      handles.
- *      uNodeTabSize:   The number of (DSP_HNODE) handles that can be held
- *		      to the memory the client has allocated for aNodeTab
- *      puNumNodes  :   Location where DSPProcessor_EnumNodes will return
- *		      the number of valid handles written to aNodeTab
- *      puAllocated :   Location where DSPProcessor_EnumNodes will return
+ *      node_tab_size:   The number of (DSP_HNODE) handles that can be held
+ *		      to the memory the client has allocated for node_tab
+ *      pu_num_nodes  :   Location where DSPProcessor_EnumNodes will return
+ *		      the number of valid handles written to node_tab
+ *      pu_allocated :   Location where DSPProcessor_EnumNodes will return
  *		      the number of nodes that are allocated on the DSP.
  *  Returns:
  *      DSP_SOK     :   Success.
  *      DSP_EHANDLE :   Invalid processor handle.
- *      DSP_ESIZE   :   The amount of memory allocated for aNodeTab is
+ *      DSP_ESIZE   :   The amount of memory allocated for node_tab is
  *		      insufficent. That is the number of nodes actually
  *		      allocated on the DSP is greater than the value
- *		      specified for uNodeTabSize.
+ *		      specified for node_tab_size.
  *      DSP_EFAIL   :   Unable to get Resource Information.
  *  Details:
  *  Requires
- *      puNumNodes is not NULL.
- *      puAllocated is not NULL.
- *      aNodeTab is not NULL.
+ *      pu_num_nodes is not NULL.
+ *      pu_allocated is not NULL.
+ *      node_tab is not NULL.
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_EnumNodes(DSP_HPROCESSOR hProcessor,
-					 IN DSP_HNODE *aNodeTab,
-					 IN u32 uNodeTabSize,
-					 OUT u32 *puNumNodes,
-					 OUT u32 *puAllocated);
+extern dsp_status proc_enum_nodes(void *hprocessor,
+				  void **node_tab,
+				  IN u32 node_tab_size,
+				  OUT u32 *pu_num_nodes,
+				  OUT u32 *pu_allocated);
 
 /*
- *  ======== PROC_GetResourceInfo ========
+ *  ======== proc_get_resource_info ========
  *  Purpose:
  *      Enumerate the resources currently available on a processor.
  *  Parameters:
- *      hProcessor  :       The processor handle.
- *      uResourceType:      Type of resource .
- *      pResourceInfo:      Ptr to the DSP_RESOURCEINFO structure.
- *      uResourceInfoSize:  Size of the structure.
+ *      hprocessor  :       The processor handle.
+ *      resource_type:      Type of resource .
+ *      resource_info:      Ptr to the dsp_resourceinfo structure.
+ *      resource_info_size:  Size of the structure.
  *  Returns:
  *      DSP_SOK     :       Success.
  *      DSP_EHANDLE :       Invalid processor handle.
@@ -245,23 +177,23 @@
  *			  restarted.
  *      DSP_EFAIL   :       Unable to get Resource Information
  *  Requires:
- *      pResourceInfo is not NULL.
- *      Parameter uResourceType is Valid.[TBD]
- *      uResourceInfoSize is >= sizeof DSP_RESOURCEINFO struct.
+ *      resource_info is not NULL.
+ *      Parameter resource_type is Valid.[TBD]
+ *      resource_info_size is >= sizeof dsp_resourceinfo struct.
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  *      This function currently returns
- *      DSP_ENOTIMPL, and does not write any data to the pResourceInfo struct.
+ *      DSP_ENOTIMPL, and does not write any data to the resource_info struct.
  */
-	extern DSP_STATUS PROC_GetResourceInfo(DSP_HPROCESSOR hProcessor,
-					       u32 uResourceType,
-					       OUT struct DSP_RESOURCEINFO *
-					       pResourceInfo,
-					       u32 uResourceInfoSize);
+extern dsp_status proc_get_resource_info(void *hprocessor,
+					 u32 resource_type,
+					 OUT struct dsp_resourceinfo
+					 *resource_info,
+					 u32 resource_info_size);
 
 /*
- *  ======== PROC_Exit ========
+ *  ======== proc_exit ========
  *  Purpose:
  *      Decrement reference count, and free resources when reference count is
  *      0.
@@ -272,14 +204,14 @@
  *  Ensures:
  *      When reference count == 0, PROC's private resources are freed.
  */
-       extern void PROC_Exit(void);
+extern void proc_exit(void);
 
 /*
- * ======== PROC_GetDevObject =========
+ * ======== proc_get_dev_object =========
  *  Purpose:
  *      Returns the DEV Hanlde for a given Processor handle
  *  Parameters:
- *      hProcessor  :   Processor Handle
+ *      hprocessor  :   Processor Handle
  *      phDevObject :   Location to store the DEV Handle.
  *  Returns:
  *      DSP_SOK     :   Success; *phDevObject has Dev handle
@@ -291,11 +223,11 @@
  *      DSP_SOK     :   *phDevObject is not NULL
  *      DSP_EFAIL   :   *phDevObject is NULL.
  */
-	extern DSP_STATUS PROC_GetDevObject(DSP_HPROCESSOR hProcessor,
-					    struct DEV_OBJECT **phDevObject);
+extern dsp_status proc_get_dev_object(void *hprocessor,
+				      struct dev_object **phDevObject);
 
 /*
- *  ======== PROC_Init ========
+ *  ======== proc_init ========
  *  Purpose:
  *      Initialize PROC's private state, keeping a reference count on each
  *      call.
@@ -306,39 +238,37 @@
  *  Ensures:
  *      TRUE: A requirement for the other public PROC functions.
  */
-       extern bool PROC_Init(void);
+extern bool proc_init(void);
 
 /*
- *  ======== PROC_GetState ========
+ *  ======== proc_get_state ========
  *  Purpose:
  *      Report the state of the specified DSP processor.
  *  Parameters:
- *      hProcessor  :   The processor handle.
- *      pProcStatus :   Ptr to location to store the DSP_PROCESSORSTATE
+ *      hprocessor  :   The processor handle.
+ *      proc_state_obj :   Ptr to location to store the dsp_processorstate
  *		      structure.
- *      uStateInfoSize: Size of DSP_PROCESSORSTATE.
+ *      state_info_size: Size of dsp_processorstate.
  *  Returns:
  *      DSP_SOK     :   Success.
  *      DSP_EHANDLE :   Invalid processor handle.
  *      DSP_EFAIL   :   General failure while querying processor state.
  *  Requires:
- *      pProcStatus is not NULL
- *      uStateInfoSize is >= than the size of DSP_PROCESSORSTATE structure.
+ *      proc_state_obj is not NULL
+ *      state_info_size is >= than the size of dsp_processorstate structure.
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_GetState(DSP_HPROCESSOR hProcessor,
-					OUT struct DSP_PROCESSORSTATE
-					*pProcStatus,
-					u32 uStateInfoSize);
+extern dsp_status proc_get_state(void *hprocessor, OUT struct dsp_processorstate
+				 *proc_state_obj, u32 state_info_size);
 
 /*
  *  ======== PROC_GetProcessorID ========
  *  Purpose:
  *      Report the state of the specified DSP processor.
  *  Parameters:
- *      hProcessor  :   The processor handle.
+ *      hprocessor  :   The processor handle.
  *      procID      :   Processor ID
  *
  *  Returns:
@@ -346,52 +276,50 @@
  *      DSP_EHANDLE :   Invalid processor handle.
  *      DSP_EFAIL   :   General failure while querying processor state.
  *  Requires:
- *      pProcStatus is not NULL
- *      uStateInfoSize is >= than the size of DSP_PROCESSORSTATE structure.
+ *      proc_state_obj is not NULL
+ *      state_info_size is >= than the size of dsp_processorstate structure.
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_GetProcessorId(DSP_HPROCESSOR hProcessor,
-					      u32 *procID);
+extern dsp_status proc_get_processor_id(void *hprocessor, u32 * procID);
 
 /*
- *  ======== PROC_GetTrace ========
+ *  ======== proc_get_trace ========
  *  Purpose:
  *      Retrieve the trace buffer from the specified DSP processor.
  *  Parameters:
- *      hProcessor  :   The processor handle.
- *      pBuf	:   Ptr to buffer to hold trace output.
- *      uMaxSize    :   Maximum size of the output buffer.
+ *      hprocessor  :   The processor handle.
+ *      pbuf	:   Ptr to buffer to hold trace output.
+ *      max_size    :   Maximum size of the output buffer.
  *  Returns:
  *      DSP_SOK     :   Success.
  *      DSP_EHANDLE :   Invalid processor handle.
  *      DSP_EFAIL   :   General failure while retireving processor trace
  *		      Buffer.
  *  Requires:
- *      pBuf is not NULL
- *      uMaxSize is > 0.
+ *      pbuf is not NULL
+ *      max_size is > 0.
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_GetTrace(DSP_HPROCESSOR hProcessor, u8 *pBuf,
-					u32 uMaxSize);
+extern dsp_status proc_get_trace(void *hprocessor, u8 * pbuf, u32 max_size);
 
 /*
- *  ======== PROC_Load ========
+ *  ======== proc_load ========
  *  Purpose:
  *      Reset a processor and load a new base program image.
  *      This will be an OEM-only function.
  *  Parameters:
- *      hProcessor  :       The processor handle.
- *      iArgc       :       The number of Arguments(strings)in the aArgV[]
- *      aArgv       :       An Array of Arguments(Unicode Strings)
- *      aEnvp       :       An Array of Environment settings(Unicode Strings)
- *  Returns:
- *      DSP_SOK     :       Success.
- *      DSP_EFILE   :       The DSP Execuetable was not found.
- *      DSP_EHANDLE :       Invalid processor handle.
+ *      hprocessor:       The processor handle.
+ *      argc_index:       The number of Arguments(strings)in the aArgV[]
+ *      user_args:       An Array of Arguments(Unicode Strings)
+ *      user_envp:       An Array of Environment settings(Unicode Strings)
+ *  Returns:
+ *      DSP_SOK:       Success.
+ *      DSP_EFILE:       The DSP Execuetable was not found.
+ *      DSP_EHANDLE:       Invalid processor handle.
  *      DSP_ECORRUTFILE:    Unable to Parse the DSP Execuetable
  *      DSP_EATTACHED:      Abort because a GPP Client is attached to the
  *			  specified Processor
@@ -399,8 +327,8 @@
  *			  to reset and load the Processor
  *      DSP_EFAIL   :       Unable to Load the Processor
  *  Requires:
- *      aArgv is not NULL
- *      iArgc is > 0
+ *      user_args is not NULL
+ *      argc_index is > 0
  *      PROC Initialized.
  *  Ensures:
  *      Success and ProcState == PROC_LOADED
@@ -409,39 +337,39 @@
  *      Does not implement access rights to control which GPP application
  *      can load the processor.
  */
-	extern DSP_STATUS PROC_Load(DSP_HPROCESSOR hProcessor,
-				    IN CONST s32 iArgc, IN CONST char **aArgv,
-				    IN CONST char **aEnvp);
+extern dsp_status proc_load(void *hprocessor,
+			    IN CONST s32 argc_index, IN CONST char **user_args,
+			    IN CONST char **user_envp);
 
 /*
- *  ======== PROC_RegisterNotify ========
+ *  ======== proc_register_notify ========
  *  Purpose:
  *      Register to be notified of specific processor events
  *  Parameters:
- *      hProcessor  :   The processor handle.
- *      uEventMask  :   Mask of types of events to be notified about.
- *      uNotifyType :   Type of notification to be sent.
- *      hNotification:  Handle to be used for notification.
+ *      hprocessor  :   The processor handle.
+ *      event_mask  :   Mask of types of events to be notified about.
+ *      notify_type :   Type of notification to be sent.
+ *      hnotification:  Handle to be used for notification.
  *  Returns:
  *      DSP_SOK     :   Success.
- *      DSP_EHANDLE :   Invalid processor handle or hNotification.
- *      DSP_EVALUE  :   Parameter uEventMask is Invalid
+ *      DSP_EHANDLE :   Invalid processor handle or hnotification.
+ *      DSP_EVALUE  :   Parameter event_mask is Invalid
  *      DSP_ENOTIMP :   The notification type specified in uNotifyMask
  *		      is not supported.
  *      DSP_EFAIL   :   Unable to register for notification.
  *  Requires:
- *      hNotification is not NULL
+ *      hnotification is not NULL
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_RegisterNotify(DSP_HPROCESSOR hProcessor,
-					      u32 uEventMask, u32 uNotifyType,
-					      struct DSP_NOTIFICATION
-					      *hNotification);
+extern dsp_status proc_register_notify(void *hprocessor,
+				       u32 event_mask, u32 notify_type,
+				       struct dsp_notification
+				       *hnotification);
 
 /*
- *  ======== PROC_NotifyClients ========
+ *  ======== proc_notify_clients ========
  *  Purpose:
  *      Notify the Processor Clients
  *  Parameters:
@@ -457,11 +385,10 @@
  *      PROC Initialized.
  *  Ensures:
  */
-	extern DSP_STATUS PROC_NotifyClients(DSP_HPROCESSOR hProc,
-					     u32 uEvents);
+extern dsp_status proc_notify_clients(void *hProc, u32 uEvents);
 
 /*
- *  ======== PROC_NotifyAllClients ========
+ *  ======== proc_notify_all_clients ========
  *  Purpose:
  *      Notify the Processor Clients
  *  Parameters:
@@ -480,18 +407,17 @@
  *      NODE And STRM would use this function to notify their clients
  *      about the state changes in NODE or STRM.
  */
-	extern DSP_STATUS PROC_NotifyAllClients(DSP_HPROCESSOR hProc,
-						u32 uEvents);
+extern dsp_status proc_notify_all_clients(void *hProc, u32 uEvents);
 
 /*
- *  ======== PROC_Start ========
+ *  ======== proc_start ========
  *  Purpose:
  *      Start a processor running.
  *      Processor must be in PROC_LOADED state.
  *      This will be an OEM-only function, and not part of the 'Bridge
  *      application developer's API.
  *  Parameters:
- *      hProcessor  :       The processor handle.
+ *      hprocessor  :       The processor handle.
  *  Returns:
  *      DSP_SOK     :       Success.
  *      DSP_EHANDLE :       Invalid processor handle.
@@ -503,17 +429,17 @@
  *      Success and ProcState == PROC_RUNNING or DSP_FAILED status.
  *  Details:
  */
-	extern DSP_STATUS PROC_Start(DSP_HPROCESSOR hProcessor);
+extern dsp_status proc_start(void *hprocessor);
 
 /*
- *  ======== PROC_Stop ========
+ *  ======== proc_stop ========
  *  Purpose:
  *      Start a processor running.
  *      Processor must be in PROC_LOADED state.
  *      This will be an OEM-only function, and not part of the 'Bridge
  *      application developer's API.
  *  Parameters:
- *      hProcessor  :       The processor handle.
+ *      hprocessor  :       The processor handle.
  *  Returns:
  *      DSP_SOK     :       Success.
  *      DSP_EHANDLE :       Invalid processor handle.
@@ -525,17 +451,17 @@
  *      Success and ProcState == PROC_RUNNING or DSP_FAILED status.
  *  Details:
  */
-	extern DSP_STATUS PROC_Stop(DSP_HPROCESSOR hProcessor);
+extern dsp_status proc_stop(void *hprocessor);
 
 /*
- *  ======== PROC_FlushMemory ========
+ *  ======== proc_flush_memory ========
  *  Purpose:
  *      Flushes a buffer from the MPU data cache.
  *  Parameters:
- *      hProcessor      :   The processor handle.
- *      pMpuAddr	:   Buffer start address
- *      ulSize	  :   Buffer size
- *      ulFlags	 :   Reserved.
+ *      hprocessor      :   The processor handle.
+ *      pmpu_addr	:   Buffer start address
+ *      ul_size	  :   Buffer size
+ *      ul_flags	 :   Reserved.
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
@@ -546,19 +472,17 @@
  *  Details:
  *      All the arguments are currently ignored.
  */
-	extern DSP_STATUS PROC_FlushMemory(DSP_HPROCESSOR hProcessor,
-					   void *pMpuAddr,
-					   u32 ulSize, u32 ulFlags);
-
+extern dsp_status proc_flush_memory(void *hprocessor,
+				    void *pmpu_addr, u32 ul_size, u32 ul_flags);
 
 /*
- *  ======== PROC_InvalidateMemory ========
+ *  ======== proc_invalidate_memory ========
  *  Purpose:
  *      Invalidates a buffer from the MPU data cache.
  *  Parameters:
- *      hProcessor      :   The processor handle.
- *      pMpuAddr	:   Buffer start address
- *      ulSize	  :   Buffer size
+ *      hprocessor      :   The processor handle.
+ *      pmpu_addr	:   Buffer start address
+ *      ul_size	  :   Buffer size
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
@@ -569,22 +493,21 @@
  *  Details:
  *      All the arguments are currently ignored.
  */
-	extern DSP_STATUS PROC_InvalidateMemory(DSP_HPROCESSOR hProcessor,
-					   void *pMpuAddr,
-					   u32 ulSize);
+extern dsp_status proc_invalidate_memory(void *hprocessor,
+					 void *pmpu_addr, u32 ul_size);
 
 /*
- *  ======== PROC_Map ========
+ *  ======== proc_map ========
  *  Purpose:
  *      Maps a MPU buffer to DSP address space.
  *  Parameters:
- *      hProcessor      :   The processor handle.
- *      pMpuAddr	:   Starting address of the memory region to map.
- *      ulSize	  :   Size of the memory region to map.
- *      pReqAddr	:   Requested DSP start address. Offset-adjusted actual
+ *      hprocessor      :   The processor handle.
+ *      pmpu_addr	:   Starting address of the memory region to map.
+ *      ul_size	  :   Size of the memory region to map.
+ *      req_addr	:   Requested DSP start address. Offset-adjusted actual
  *			  mapped address is in the last argument.
- *      ppMapAddr       :   Ptr to DSP side mapped u8 address.
- *      ulMapAttr       :   Optional endianness attributes, virt to phys flag.
+ *      pp_map_addr       :   Ptr to DSP side mapped u8 address.
+ *      ul_map_attr       :   Optional endianness attributes, virt to phys flag.
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
@@ -593,49 +516,50 @@
  *      DSP_ENOTFOUND   :   Cannot find a reserved region starting with this
  *		      :   address.
  *  Requires:
- *      pMpuAddr is not NULL
- *      ulSize is not zero
- *      ppMapAddr is not NULL
+ *      pmpu_addr is not NULL
+ *      ul_size is not zero
+ *      pp_map_addr is not NULL
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_Map(DSP_HPROCESSOR hProcessor,
-				   void *pMpuAddr,
-				   u32 ulSize,
-				   void *pReqAddr,
-				   void **ppMapAddr, u32 ulMapAttr,
-				   struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status proc_map(void *hprocessor,
+			   void *pmpu_addr,
+			   u32 ul_size,
+			   void *req_addr,
+			   void **pp_map_addr, u32 ul_map_attr,
+			   struct process_context *pr_ctxt);
 
 /*
- *  ======== PROC_ReserveMemory ========
+ *  ======== proc_reserve_memory ========
  *  Purpose:
  *      Reserve a virtually contiguous region of DSP address space.
  *  Parameters:
- *      hProcessor      :   The processor handle.
- *      ulSize	  :   Size of the address space to reserve.
- *      ppRsvAddr       :   Ptr to DSP side reserved u8 address.
+ *      hprocessor      :   The processor handle.
+ *      ul_size	  :   Size of the address space to reserve.
+ *      pp_rsv_addr       :   Ptr to DSP side reserved u8 address.
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
  *      DSP_EFAIL       :   General failure.
  *      DSP_EMEMORY     :   Cannot reserve chunk of this size.
  *  Requires:
- *      ppRsvAddr is not NULL
+ *      pp_rsv_addr is not NULL
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_ReserveMemory(DSP_HPROCESSOR hProcessor,
-					     u32 ulSize, void **ppRsvAddr);
+extern dsp_status proc_reserve_memory(void *hprocessor,
+				      u32 ul_size, void **pp_rsv_addr,
+				      struct process_context *pr_ctxt);
 
 /*
- *  ======== PROC_UnMap ========
+ *  ======== proc_un_map ========
  *  Purpose:
  *      Removes a MPU buffer mapping from the DSP address space.
  *  Parameters:
- *      hProcessor      :   The processor handle.
- *      pMapAddr	:   Starting address of the mapped memory region.
+ *      hprocessor      :   The processor handle.
+ *      map_addr	:   Starting address of the mapped memory region.
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
@@ -643,21 +567,21 @@
  *      DSP_ENOTFOUND   :   Cannot find a mapped region starting with this
  *		      :   address.
  *  Requires:
- *      pMapAddr is not NULL
+ *      map_addr is not NULL
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_UnMap(DSP_HPROCESSOR hProcessor, void *pMapAddr,
-			struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status proc_un_map(void *hprocessor, void *map_addr,
+			      struct process_context *pr_ctxt);
 
 /*
- *  ======== PROC_UnReserveMemory ========
+ *  ======== proc_un_reserve_memory ========
  *  Purpose:
  *      Frees a previously reserved region of DSP address space.
  *  Parameters:
- *      hProcessor      :   The processor handle.
- *      pRsvAddr	:   Ptr to DSP side reservedBYTE address.
+ *      hprocessor      :   The processor handle.
+ *      prsv_addr	:   Ptr to DSP side reservedBYTE address.
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
@@ -665,12 +589,13 @@
  *      DSP_ENOTFOUND   :   Cannot find a reserved region starting with this
  *		      :   address.
  *  Requires:
- *      pRsvAddr is not NULL
+ *      prsv_addr is not NULL
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_UnReserveMemory(DSP_HPROCESSOR hProcessor,
-					       void *pRsvAddr);
+extern dsp_status proc_un_reserve_memory(void *hprocessor,
+					 void *prsv_addr,
+					 struct process_context *pr_ctxt);
 
-#endif				/* PROC_ */
+#endif /* PROC_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/procpriv.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/procpriv.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/procpriv.h	2011-10-11 13:50:58.104784372 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/procpriv.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global PROC constants and types, shared by PROC, MGR and WCD.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,22 +16,10 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== procpriv.h ========
- *  Description:
- *      Global PROC constants and types, shared by PROC, MGR, and WCD.
- *
- *! Revision History:
- *! ================
- *! 05-July-2000 rr: Created
- */
-
 #ifndef PROCPRIV_
 #define PROCPRIV_
 
 /* RM PROC Object */
-	struct PROC_OBJECT;
-
-#endif				/* PROCPRIV_ */
+struct proc_object;
 
+#endif /* PROCPRIV_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/pwr.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/pwr.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/pwr.h	2011-10-11 13:50:58.104784372 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/pwr.h	2011-10-29 20:57:30.675979558 +0100
@@ -14,25 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== pwr.h ========
- *
- *  Public Functions:
- *
- *      PWR_SleepDSP
- *      PWR_WakeDSP
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 06-Jun-2002 sg  Replaced dspdefs.h with includes of dbdefs.h and errbase.h.
- *! 13-May-2002 sg  Added DSP_SAREADYASLEEP and DSP_SALREADYAWAKE.
- *! 09-May-2002 sg  Updated, added timeouts.
- *! 02-May-2002 sg  Initial.
- */
-
 #ifndef PWR_
 #define PWR_
 
@@ -41,7 +22,7 @@
 #include <dspbridge/pwr_sh.h>
 
 /*
- *  ======== PWR_SleepDSP ========
+ *  ======== pwr_sleep_dsp ========
  *      Signal the DSP to go to sleep.
  *
  *  Parameters:
@@ -65,11 +46,10 @@
  *      DSP_EFAIL:          General failure, unable to send sleep command to
  *                          the DSP.
  */
-	extern DSP_STATUS PWR_SleepDSP(IN CONST u32 sleepCode,
-				       IN CONST u32 timeout);
+extern dsp_status pwr_sleep_dsp(IN CONST u32 sleepCode, IN CONST u32 timeout);
 
 /*
- *  ======== PWR_WakeDSP ========
+ *  ======== pwr_wake_dsp ========
  *    Signal the DSP to wake from sleep.
  *
  *  Parameters:
@@ -87,10 +67,10 @@
  *      DSP_EFAIL:          General failure, unable to send wake command to
  *                          the DSP.
  */
-	extern DSP_STATUS PWR_WakeDSP(IN CONST u32 timeout);
+extern dsp_status pwr_wake_dsp(IN CONST u32 timeout);
 
 /*
- *  ======== PWR_PM_PreScale ========
+ *  ======== pwr_pm_pre_scale ========
  *    Prescale notification to DSP.
  *
  *  Parameters:
@@ -105,10 +85,10 @@
  *      DSP_EFAIL:          General failure, unable to send wake command to
  *                          the DSP.
  */
-	extern DSP_STATUS PWR_PM_PreScale(IN u16 voltage_domain, u32 level);
+extern dsp_status pwr_pm_pre_scale(IN u16 voltage_domain, u32 level);
 
 /*
- *  ======== PWR_PM_PostScale ========
+ *  ======== pwr_pm_post_scale ========
  *    PostScale notification to DSP.
  *
  *  Parameters:
@@ -123,7 +103,6 @@
  *      DSP_EFAIL:          General failure, unable to send wake command to
  *                          the DSP.
  */
-	extern DSP_STATUS PWR_PM_PostScale(IN u16 voltage_domain,
-					   u32 level);
-
-#endif				/* PWR_ */
+extern dsp_status pwr_pm_post_scale(IN u16 voltage_domain, u32 level);
+
+#endif /* PWR_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/pwr_sh.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/pwr_sh.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/pwr_sh.h	2011-10-11 13:50:58.119185685 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/pwr_sh.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Power Manager shared definitions (used on both GPP and DSP sides).
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,16 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== pwr_sh.h ========
- *
- *  Power Manager shared definitions (used on both GPP and DSP sides).
- *
- *! Revision History
- *! ================
- *! 17-Apr-2002 sg: Initial.
- */
-
 #ifndef PWR_SH_
 #define PWR_SH_
 
@@ -38,4 +30,4 @@
 #define PWR_AUTODISABLE         MBX_PM_PWRDISABLE
 #define PWR_RETENTION             MBX_PM_DSPRETN
 
-#endif				/* PWR_SH_ */
+#endif /* PWR_SH_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/reg.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/reg.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/reg.h	2011-10-11 13:50:58.119185685 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/reg.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provides registry functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,130 +16,39 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== reg.h ========
- *  Purpose:
- *      Provide registry functions.
- *
- *  Public Functions:
- *      REG_DeleteValue
- *      REG_EnumKey
- *      REG_EnumValue
- *      REG_Exit
- *      REG_GetValue
- *      REG_Init
- *      REG_SetValue
- *
- *! Revision History:
- *! =================
- *! 30-Oct-2000 kc: Updated REG_SetValue & REG_GetValue; renamed
- *!                 REG_DeleteEntry to REG_DeleteValue.
- *! 29-Sep-2000 kc: Updated a REG functions for code review.
- *! 12-Aug-2000 kc: Renamed REG_EnumValue to REG_EnumKey. Re-implemented
- *!                 REG_EnumValue.
- *! 03-Feb-2000 rr: REG_EnumValue Fxn Added
- *! 13-Dec-1999 rr: windows.h removed
- *! 02-Dec-1999 rr: windows.h included for retail build
- *! 22-Nov-1999 kc: Changes from code review.
- *! 29-Dec-1997 cr: Changes from code review.
- *! 27-Oct-1997 cr: Added REG_DeleteValue.
- *! 20-Oct-1997 cr: Added ability to pass bValue = NULL to REG_GetValue
- *!                 and return size of reg entry in pdwValueSize.
- *! 29-Sep-1997 cr: Added REG_SetValue
- *! 29-Aug-1997 cr: Created.
- */
-
 #ifndef _REG_H
 #define _REG_H
 
 #include <linux/types.h>
 
-/*  ------------------------- Defines, Data Structures, Typedefs for Linux */
-#ifndef UNDER_CE
-
-#ifndef REG_SZ
-#define REG_SZ          1
-#endif
-
-#ifndef REG_BINARY
-#define REG_BINARY      3
-#endif
-
-#ifndef REG_DWORD
-#define REG_DWORD       4
-#endif
-
-#endif				/* UNDER_CE */
-
 #define REG_MAXREGPATHLENGTH    255
 
 /*
- *  ======== REG_DeleteValue ========
+ *  ======== reg_delete_value ========
  *  Purpose:
  *      Deletes a registry entry. NOTE: A registry entry is not the same as
  *      a registry key.
  *  Parameters:
- *      phKey:      Currently reserved; must be NULL.
- *      pstrSubkey: Path to key to open.
  *      pstrValue:  Name of entry to delete.
  *  Returns:
  *      DSP_SOK:    Success.
  *      DSP_EFAIL:  General failure.
  *  Requires:
  *      - REG initialized.
- *      - pstrSubkey & pstrValue are non-NULL values.
- *      - phKey is NULL.
- *      - length of pstrSubkey < REG_MAXREGPATHLENGTH.
+ *      - pstrValue is non-NULL value.
  *      - length of pstrValue < REG_MAXREGPATHLENGTH.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS REG_DeleteValue(OPTIONAL IN HANDLE *phKey,
-					  IN CONST char *pstrSubkey,
-					  IN CONST char *pstrValue);
-
-/*
- *  ======== REG_EnumKey ========
- *  Purpose:
- *      Enumerates subkeys of the specified path to the  registry key
- *      Retrieves the  name of the subkey(given the index) and
- *      appends with the orignal path to form the full path.
- *  Parameters:
- *      phKey:      Currently reserved; must be NULL.
- *      pstrKey     The name of the registry key to be enumerated.
- *      dwIndex     Specifies the index of the subkey to retrieve.
- *      pstrSubkey: Pointer to buffer that receives full path name of the
- *                  specified key + the sub-key
- *      pdwValueSize:   Specifies bytes of memory pstrSubkey points to on input,
- *                      on output, specifies actual memory bytes written into.
- *                      If there is no sub key,pdwValueSize returns NULL.
- *  Returns:
- *      DSP_SOK:    Success.
- *      DSP_EFAIL:  General failure.
- *  Requires:
- *      - REG initialized.
- *      - pstrKey is non-NULL value.
- *      - pdwValueSize is a valid pointer.
- *      - phKey is NULL.
- *      - length of pstrKey < REG_MAXREGPATHLENGTH.
- *  Ensures:
- *      - strlen(pstrSubkey) is > strlen(pstrKey) &&
- *      - strlen(pstrSubkey) is < REG_MAXREGPATHLENGTH
- */
-	extern DSP_STATUS REG_EnumKey(OPTIONAL IN HANDLE *phKey,
-				      IN u32 dwIndex, IN CONST char *pstrKey,
-				      IN OUT char *pstrSubkey,
-				      IN OUT u32 *pdwValueSize);
+extern dsp_status reg_delete_value(IN CONST char *pstrValue);
 
 /*
- *  ======== REG_EnumValue ========
+ *  ======== reg_enum_value ========
  *  Purpose:
  *      Enumerates values of a specified key. Retrieves each value name and
  *      the data associated with the value.
  *  Parameters:
- *      phKey:          Currently reserved; must be NULL.
- *      dwIndex:        Specifies the index of the value to retrieve.
+ *      dw_index:        Specifies the index of the value to retrieve.
  *      pstrKey:        The name of the registry key to be enumerated.
  *      pstrValue:      Pointer to buffer that receives the name of the value.
  *      pdwValueSize:   Specifies bytes of memory pstrValue points to on input,
@@ -152,22 +63,19 @@
  *      DSP_EFAIL:      General failure.
  *  Requires:
  *      REG initialized.
- *      phKey is NULL.
  *      pstrKey is a non-NULL value.
  *      pstrValue, pstrData, pdwValueSize and pdwDataSize are valid pointers.
  *      Length of pstrKey is less than REG_MAXREGPATHLENGTH.
  *  Ensures:
  */
-	extern DSP_STATUS REG_EnumValue(IN HANDLE *phKey,
-					IN u32 dwIndex,
-					IN CONST char *pstrKey,
-					IN OUT char *pstrValue,
-					IN OUT u32 *pdwValueSize,
-					IN OUT char *pstrData,
-					IN OUT u32 *pdwDataSize);
+extern dsp_status reg_enum_value(IN u32 dw_index, IN CONST char *pstrKey,
+				 IN OUT char *pstrValue,
+				 IN OUT u32 *pdwValueSize,
+				 IN OUT char *pstrData,
+				 IN OUT u32 *pdwDataSize);
 
 /*
- *  ======== REG_Exit ========
+ *  ======== reg_exit ========
  *  Purpose:
  *      Discontinue usage of module; free resources when reference count
  *      reaches 0.
@@ -178,15 +86,13 @@
  *  Ensures:
  *      Resources used by module are freed when cRef reaches zero.
  */
-	extern void REG_Exit(void);
+extern void reg_exit(void);
 
 /*
- *  ======== REG_GetValue ========
+ *  ======== reg_get_value ========
  *  Purpose:
  *      Retrieve a value from the registry.
  *  Parameters:
- *      phKey:          Currently reserved; must be NULL.
- *      pstrSubkey:     Path to key to open.
  *      pstrEntry:      Name of entry to retrieve.
  *      pbValue:        Upon return, points to retrieved value.
  *      pdwValueSize:   Specifies bytes of memory pbValue points to on input,
@@ -198,21 +104,16 @@
  *      DSP_EFAIL:      General failure.
  *  Requires:
  *      - REG initialized.
- *      - pstrSubkey & pstrEntry are non-NULL values.
+ *      - pstrEntry is non-NULL value.
  *      - pbValue is a valid pointer.
- *      - phKey is NULL.
- *      - length of pstrSubkey < REG_MAXREGPATHLENGTH.
  *      - length of pstrEntry < REG_MAXREGPATHLENGTH.
  *  Ensures:
  */
-	extern DSP_STATUS REG_GetValue(OPTIONAL IN HANDLE *phKey,
-				       IN CONST char *pstrSubkey,
-				       IN CONST char *pstrEntry,
-				       OUT u8 *pbValue,
-				       IN OUT u32 *pdwValueSize);
+extern dsp_status reg_get_value(IN CONST char *pstrEntry, OUT u8 * pbValue,
+				IN OUT u32 *pdwValueSize);
 
 /*
- *  ======== REG_Init ========
+ *  ======== reg_init ========
  *  Purpose:
  *      Initializes private state of REG module.
  *  Parameters:
@@ -222,36 +123,28 @@
  *  Ensures:
  *      REG initialized.
  */
-	extern bool REG_Init(void);
+extern bool reg_init(void);
 
 /*
- *  ======== REG_SetValue ========
+ *  ======== reg_set_value ========
  *  Purpose:
  *      Set a value in the registry.
  *  Parameters:
- *      phKey:          Handle to open reg key, or NULL if pSubkey is full path.
- *      pstrSubkey:     Path to key to open, could be based on phKey.
  *      pstrEntry:      Name of entry to set.
- *      dwType:         Data type of new registry value.
  *      pbValue:        Points to buffer containing new data.
- *      dwValueSize:    Specifies bytes of memory bValue points to.
+ *      dw_value_size:    Specifies bytes of memory bValue points to.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      General failure.
  *  Requires:
  *      - REG initialized.
- *      - pstrSubkey & pstrEntry are non-NULL values.
+ *      - pstrEntry is non-NULL value.
  *      - pbValue is a valid pointer.
- *      - phKey is NULL.
  *      - dwValuSize > 0.
- *      - length of pstrSubkey < REG_MAXREGPATHLENGTH.
  *      - length of pstrEntry < REG_MAXREGPATHLENGTH.
  *  Ensures:
  */
-	extern DSP_STATUS REG_SetValue(OPTIONAL IN HANDLE *phKey,
-				       IN CONST char *pstrSubKey,
-				       IN CONST char *pstrEntry,
-				       IN CONST u32 dwType,
-				       IN u8 *pbValue, IN u32 dwValueSize);
+extern dsp_status reg_set_value(IN CONST char *pstrEntry, IN u8 * pbValue,
+				IN u32 dw_value_size);
 
-#endif				/* _REG_H */
+#endif /* _REG_H */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h	2011-10-11 13:50:58.119185685 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h	2011-08-19 18:42:46.000000000 +0100
@@ -14,70 +14,50 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifndef RES_CLEANUP_DISABLE
-
 #include <dspbridge/nodepriv.h>
 #include <dspbridge/drv.h>
 
+extern dsp_status drv_get_proc_ctxt_list(struct process_context **pPctxt,
+					 struct drv_object *hdrv_obj);
 
-extern DSP_STATUS DRV_GetProcCtxtList(struct PROCESS_CONTEXT **pPctxt,
-				struct DRV_OBJECT *hDrvObject);
-
-extern DSP_STATUS DRV_InsertProcContext(struct DRV_OBJECT *hDrVObject,
-					HANDLE hPCtxt);
-
-extern DSP_STATUS DRV_RemoveAllDMMResElements(HANDLE pCtxt);
-
-extern DSP_STATUS DRV_RemoveAllNodeResElements(HANDLE pCtxt);
-
-extern DSP_STATUS DRV_ProcUpdatestate(HANDLE pCtxt,
-				      enum GPP_PROC_RES_STATE resState);
-
-extern DSP_STATUS DRV_ProcSetPID(HANDLE pCtxt, s32 hProcess);
-
-extern DSP_STATUS DRV_RemoveAllResources(HANDLE pPctxt);
-
-extern DSP_STATUS DRV_RemoveProcContext(struct DRV_OBJECT *hDRVObject,
-				     HANDLE hPCtxt);
-
-extern DSP_STATUS DRV_GetNodeResElement(HANDLE hNode, HANDLE nodeRes,
-					HANDLE pCtxt);
+extern dsp_status drv_insert_proc_context(struct drv_object *hDrVObject,
+					  bhandle hPCtxt);
 
-extern DSP_STATUS DRV_InsertNodeResElement(HANDLE hNode, HANDLE nodeRes,
-					    HANDLE pCtxt);
+extern dsp_status drv_remove_all_dmm_res_elements(bhandle ctxt);
 
-extern void DRV_ProcNodeUpdateHeapStatus(HANDLE hNodeRes, s32 status);
+extern dsp_status drv_remove_all_node_res_elements(bhandle ctxt);
 
-extern DSP_STATUS DRV_RemoveNodeResElement(HANDLE nodeRes, HANDLE status);
+extern dsp_status drv_proc_set_pid(bhandle ctxt, s32 process);
 
-extern void DRV_ProcNodeUpdateStatus(HANDLE hNodeRes, s32 status);
+extern dsp_status drv_remove_all_resources(bhandle pPctxt);
 
-extern DSP_STATUS DRV_UpdateDMMResElement(HANDLE dmmRes, u32 pMpuAddr,
-					  u32 ulSize, u32 pReqAddr,
-					  u32 ppMapAddr, HANDLE hProcesso);
+extern dsp_status drv_remove_proc_context(struct drv_object *hDRVObject,
+					  bhandle pr_ctxt);
 
-extern DSP_STATUS DRV_InsertDMMResElement(HANDLE dmmRes, HANDLE pCtxt);
+extern dsp_status drv_get_node_res_element(bhandle hnode, bhandle node_res,
+					   bhandle ctxt);
 
-extern DSP_STATUS DRV_GetDMMResElement(u32 pMapAddr, HANDLE dmmRes,
-				       HANDLE pCtxt);
+extern dsp_status drv_insert_node_res_element(bhandle hnode, bhandle node_res,
+					      bhandle ctxt);
 
-extern DSP_STATUS DRV_RemoveDMMResElement(HANDLE dmmRes, HANDLE pCtxt);
+extern void drv_proc_node_update_heap_status(bhandle hNodeRes, s32 status);
 
-extern DSP_STATUS DRV_ProcUpdateSTRMRes(u32 uNumBufs, HANDLE STRMRes,
-					HANDLE pCtxt);
+extern dsp_status drv_remove_node_res_element(bhandle node_res, bhandle status);
 
-extern DSP_STATUS DRV_ProcInsertSTRMResElement(HANDLE hStrm, HANDLE STRMRes,
-						HANDLE pPctxt);
+extern void drv_proc_node_update_status(bhandle hNodeRes, s32 status);
 
-extern DSP_STATUS DRV_GetSTRMResElement(HANDLE hStrm, HANDLE STRMRes,
-					HANDLE pCtxt);
+extern dsp_status drv_proc_update_strm_res(u32 num_bufs, bhandle strm_res);
 
-extern DSP_STATUS DRV_ProcRemoveSTRMResElement(HANDLE STRMRes, HANDLE pCtxt);
+extern dsp_status drv_proc_insert_strm_res_element(bhandle hStrm,
+						   bhandle strm_res,
+						   bhandle pPctxt);
 
-extern DSP_STATUS DRV_RemoveAllSTRMResElements(HANDLE pCtxt);
+extern dsp_status drv_get_strm_res_element(bhandle hStrm, bhandle strm_res,
+					   bhandle ctxt);
 
-extern DSP_STATUS DRV_ProcDisplayResInfo(u8 *pBuf, u32 *pSize);
+extern dsp_status drv_proc_remove_strm_res_element(bhandle strm_res,
+						   bhandle ctxt);
 
-extern enum NODE_STATE NODE_GetState(HANDLE hNode);
+extern dsp_status drv_remove_all_strm_res_elements(bhandle ctxt);
 
-#endif
+extern enum node_state node_get_state(bhandle hnode);
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/rmm.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/rmm.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/rmm.h	2011-10-11 13:50:58.134819624 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/rmm.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,10 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This memory manager provides general heap management and arbitrary
+ * alignment for any number of memory segments, and management of overlay
+ * memory.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,63 +18,41 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== rmm.h ========
- *
- *  This memory manager provides general heap management and arbitrary
- *  alignment for any number of memory segments, and management of overlay
- *  memory.
- *
- *  Public functions:
- *      RMM_alloc
- *      RMM_create
- *      RMM_delete
- *      RMM_exit
- *      RMM_free
- *      RMM_init
- *
- *! Revision History
- *! ================
- *! 25-Jun-2002 jeh     Added RMM_Addr. Removed RMM_reserve, RMM_stat.
- *! 15-Oct-2001 jeh     Based on rm.h in gen tree.
- */
-
 #ifndef RMM_
 #define RMM_
 
 /*
- *  ======== RMM_Addr ========
+ *  ======== rmm_addr ========
  *  DSP address + segid
  */
-struct RMM_Addr {
+struct rmm_addr {
 	u32 addr;
 	s32 segid;
-} ;
+};
 
 /*
- *  ======== RMM_Segment ========
+ *  ======== rmm_segment ========
  *  Memory segment on the DSP available for remote allocations.
  */
-struct RMM_Segment {
+struct rmm_segment {
 	u32 base;		/* Base of the segment */
 	u32 length;		/* Size of the segment (target MAUs) */
 	s32 space;		/* Code or data */
 	u32 number;		/* Number of Allocated Blocks */
-} ;
+};
 
 /*
  *  ======== RMM_Target ========
  */
-struct RMM_TargetObj;
+struct rmm_target_obj;
 
 /*
- *  ======== RMM_alloc ========
+ *  ======== rmm_alloc ========
  *
- *  RMM_alloc is used to remotely allocate or reserve memory on the DSP.
+ *  rmm_alloc is used to remotely allocate or reserve memory on the DSP.
  *
  *  Parameters:
- *      target          - Target returned from RMM_create().
+ *      target          - Target returned from rmm_create().
  *      segid           - Memory segment to allocate from.
  *      size            - Size (target MAUS) to allocate.
  *      align           - alignment.
@@ -88,68 +70,68 @@
  *      Valid target.
  *      dspAddr != NULL.
  *      size > 0
- *      reserve || target->numSegs > 0.
+ *      reserve || target->num_segs > 0.
  *  Ensures:
  */
-extern DSP_STATUS RMM_alloc(struct RMM_TargetObj *target, u32 segid, u32 size,
+extern dsp_status rmm_alloc(struct rmm_target_obj *target, u32 segid, u32 size,
 			    u32 align, u32 *dspAdr, bool reserve);
 
 /*
- *  ======== RMM_create ========
+ *  ======== rmm_create ========
  *  Create a target object with memory segments for remote allocation. If
- *  segTab == NULL or numSegs == 0, memory can only be reserved through
- *  RMM_alloc().
+ *  seg_tab == NULL or num_segs == 0, memory can only be reserved through
+ *  rmm_alloc().
  *
  *  Parameters:
- *      pTarget:        - Location to store target on output.
- *      segTab:         - Table of memory segments.
- *      numSegs:        - Number of memory segments.
+ *      target_obj:        - Location to store target on output.
+ *      seg_tab:         - Table of memory segments.
+ *      num_segs:        - Number of memory segments.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Memory allocation failed.
  *  Requires:
  *      RMM initialized.
- *      pTarget != NULL.
- *      numSegs == 0 || segTab != NULL.
+ *      target_obj != NULL.
+ *      num_segs == 0 || seg_tab != NULL.
  *  Ensures:
- *      Success:        Valid *pTarget.
- *      Failure:        *pTarget == NULL.
+ *      Success:        Valid *target_obj.
+ *      Failure:        *target_obj == NULL.
  */
-extern DSP_STATUS RMM_create(struct RMM_TargetObj **pTarget,
-			     struct RMM_Segment segTab[], u32 numSegs);
+extern dsp_status rmm_create(struct rmm_target_obj **target_obj,
+			     struct rmm_segment seg_tab[], u32 num_segs);
 
 /*
- *  ======== RMM_delete ========
- *  Delete target allocated in RMM_create().
+ *  ======== rmm_delete ========
+ *  Delete target allocated in rmm_create().
  *
  *  Parameters:
- *      target          - Target returned from RMM_create().
+ *      target          - Target returned from rmm_create().
  *  Returns:
  *  Requires:
  *      RMM initialized.
  *      Valid target.
  *  Ensures:
  */
-extern void RMM_delete(struct RMM_TargetObj *target);
+extern void rmm_delete(struct rmm_target_obj *target);
 
 /*
- *  ======== RMM_exit ========
+ *  ======== rmm_exit ========
  *  Exit the RMM module
  *
  *  Parameters:
  *  Returns:
  *  Requires:
- *      RMM_init successfully called.
+ *      rmm_init successfully called.
  *  Ensures:
  */
-extern void RMM_exit(void);
+extern void rmm_exit(void);
 
 /*
- *  ======== RMM_free ========
- *  Free or unreserve memory allocated through RMM_alloc().
+ *  ======== rmm_free ========
+ *  Free or unreserve memory allocated through rmm_alloc().
  *
  *  Parameters:
- *      target:         - Target returned from RMM_create().
+ *      target:         - Target returned from rmm_create().
  *      segid:          - Segment of memory to free.
  *      dspAddr:        - Address to free or unreserve.
  *      size:           - Size of memory to free or unreserve.
@@ -158,15 +140,15 @@
  *  Requires:
  *      RMM initialized.
  *      Valid target.
- *      reserved || segid < target->numSegs.
+ *      reserved || segid < target->num_segs.
  *      reserve || [dspAddr, dspAddr + size] is a valid memory range.
  *  Ensures:
  */
-extern bool RMM_free(struct RMM_TargetObj *target, u32 segid, u32 dspAddr,
+extern bool rmm_free(struct rmm_target_obj *target, u32 segid, u32 dspAddr,
 		     u32 size, bool reserved);
 
 /*
- *  ======== RMM_init ========
+ *  ======== rmm_init ========
  *  Initialize the RMM module
  *
  *  Parameters:
@@ -176,10 +158,10 @@
  *  Requires:
  *  Ensures:
  */
-extern bool RMM_init(void);
+extern bool rmm_init(void);
 
 /*
- *  ======== RMM_stat ========
+ *  ======== rmm_stat ========
  *  Obtain  memory segment status
  *
  *  Parameters:
@@ -190,10 +172,10 @@
  *      TRUE:   Success.
  *      FALSE:  Failure.
  *  Requires:
- *      segid < target->numSegs
+ *      segid < target->num_segs
  *  Ensures:
  */
-extern bool RMM_stat(struct RMM_TargetObj *target, enum DSP_MEMTYPE segid,
-		     struct DSP_MEMSTAT *pMemStatBuf);
+extern bool rmm_stat(struct rmm_target_obj *target, enum dsp_memtype segid,
+		     struct dsp_memstat *pMemStatBuf);
 
-#endif				/* RMM_ */
+#endif /* RMM_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/rms_sh.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/rms_sh.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/rms_sh.h	2011-10-11 13:50:58.134819624 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/rms_sh.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge Resource Manager Server shared definitions (used on both
+ * GPP and DSP sides).
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,37 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== rms_sh.h ========
- *
- *  DSP/BIOS Bridge Resource Manager Server shared definitions (used on both
- *  GPP and DSP sides).
- *
- *! Revision History
- *! ================
- *! 24-Mar-2003 vp  Merged updates required for CCS2.2 transition.
- *! 24-Feb-2003 kc  Rearranged order of node types to temporarily support
- *!		    legacy message node code
- *! 23-Nov-2002 gp  Converted tabs -> spaces, to fix formatting.
- *! 13-Feb-2002 jeh Added sysstacksize element to RMS_MoreTaskArgs.
- *! 11-Dec-2000 sg  Added 'misc' element to RMS_MoreTaskArgs.
- *! 04-Dec-2000 ag  Added RMS_BUFDESC command code.
- *!                 C/R code value changed to allow ORing of system/user codes.
- *! 10-Oct-2000 sg  Added 'align' field to RMS_StrmDef.
- *! 09-Oct-2000 sg  Moved pre-defined message codes here from rmsdefs.h.
- *! 02-Oct-2000 sg  Changed ticks to msec.
- *! 24-Aug-2000 sg  Moved definitions that will be exposed to app developers
- *!  		    to a separate file, rmsdefs.h.
- *! 10-Aug-2000 sg  Added RMS_COMMANDBUFSIZE and RMS_RESPONSEBUFSIZE; added
- *!		    pre-defined command/response codes; more comments.
- *! 09-Aug-2000 sg  Added RMS_ETASK.
- *! 08-Aug-2000 jeh Define RMS_WORD for GPP, rename DSP_MSG to RMS_DSPMSG.
- *!                 Added RMS_MsgArgs, RMS_MoreTaskArgs.
- *! 25-Jul-2000 sg: Changed SIO to STRM.
- *! 30-Jun-2000 sg: Initial.
- */
-
 #ifndef RMS_SH_
 #define RMS_SH_
 
@@ -65,61 +37,59 @@
 #define RMS_RESPONSEBUFSIZE    16	/* Size of response buffer */
 
 /* Pre-Defined Command/Response Codes: */
-#define RMS_EXIT                0x80000000   /* GPP->Node: shutdown */
-#define RMS_EXITACK             0x40000000   /* Node->GPP: ack shutdown */
-#define RMS_BUFDESC             0x20000000   /* Arg1 SM buf, Arg2 is SM size */
-#define RMS_KILLTASK            0x10000000  /* GPP->Node: Kill Task */
+#define RMS_EXIT                0x80000000	/* GPP->Node: shutdown */
+#define RMS_EXITACK             0x40000000	/* Node->GPP: ack shutdown */
+#define RMS_BUFDESC             0x20000000	/* Arg1 SM buf, Arg2 SM size */
+#define RMS_KILLTASK            0x10000000	/* GPP->Node: Kill Task */
 #define RMS_USER                0x0	/* Start of user-defined msg codes */
 #define RMS_MAXUSERCODES        0xfff	/* Maximum user defined C/R Codes */
 
-
 /* RM Server RPC Command Structure: */
-	struct RMS_Command {
-		RMS_WORD fxn;	/* Server function address */
-		RMS_WORD arg1;	/* First argument */
-		RMS_WORD arg2;	/* Second argument */
-		RMS_WORD data;	/* Function-specific data array */
-	} ;
+struct rms_command {
+	rms_word fxn;		/* Server function address */
+	rms_word arg1;		/* First argument */
+	rms_word arg2;		/* Second argument */
+	rms_word data;		/* Function-specific data array */
+};
 
 /*
- *  The RMS_StrmDef structure defines the parameters for both input and output
+ *  The rms_strm_def structure defines the parameters for both input and output
  *  streams, and is passed to a node's create function.
  */
-	struct RMS_StrmDef {
-		RMS_WORD bufsize;	/* Buffer size (in DSP words) */
-		RMS_WORD nbufs;	/* Max number of bufs in stream */
-		RMS_WORD segid;	/* Segment to allocate buffers */
-		RMS_WORD align;	/* Alignment for allocated buffers */
-		RMS_WORD timeout;	/* Timeout (msec) for blocking calls */
-		RMS_CHAR name[1];	/* Device Name (terminated by '\0') */
-	} ;
+struct rms_strm_def {
+	rms_word bufsize;	/* Buffer size (in DSP words) */
+	rms_word nbufs;		/* Max number of bufs in stream */
+	rms_word segid;		/* Segment to allocate buffers */
+	rms_word align;		/* Alignment for allocated buffers */
+	rms_word timeout;	/* Timeout (msec) for blocking calls */
+	rms_char name[1];	/* Device Name (terminated by '\0') */
+};
 
 /* Message node create args structure: */
-	struct RMS_MsgArgs {
-		RMS_WORD maxMessages;	/* Max # simultaneous msgs to node */
-		RMS_WORD segid;	/* Mem segment for NODE_allocMsgBuf */
-		RMS_WORD notifyType;	/* Type of message notification */
-		RMS_WORD argLength;	/* Length (in DSP chars) of arg data */
-		RMS_WORD argData;	/* Arg data for node */
-	} ;
+struct rms_msg_args {
+	rms_word max_msgs;	/* Max # simultaneous msgs to node */
+	rms_word segid;		/* Mem segment for NODE_allocMsgBuf */
+	rms_word notify_type;	/* Type of message notification */
+	rms_word arg_length;	/* Length (in DSP chars) of arg data */
+	rms_word arg_data;	/* Arg data for node */
+};
 
 /* Partial task create args structure */
-	struct RMS_MoreTaskArgs {
-		RMS_WORD priority;	/* Task's runtime priority level */
-		RMS_WORD stackSize;	/* Task's stack size */
-		RMS_WORD sysstackSize;	/* Task's system stack size (55x) */
-		RMS_WORD stackSeg;	/* Memory segment for task's stack */
-		RMS_WORD heapAddr;   /* base address of the node memory heap in
-				      * external memory (DSP virtual address) */
-		RMS_WORD heapSize;   /* size in MAUs of the node memory heap in
-				      * external memory */
-		RMS_WORD misc;	/* Misc field.  Not used for 'normal'
+struct rms_more_task_args {
+	rms_word priority;	/* Task's runtime priority level */
+	rms_word stack_size;	/* Task's stack size */
+	rms_word sysstack_size;	/* Task's system stack size (55x) */
+	rms_word stack_seg;	/* Memory segment for task's stack */
+	rms_word heap_addr;	/* base address of the node memory heap in
+				 * external memory (DSP virtual address) */
+	rms_word heap_size;	/* size in MAUs of the node memory heap in
+				 * external memory */
+	rms_word misc;		/* Misc field.  Not used for 'normal'
 				 * task nodes; for xDAIS socket nodes
 				 * specifies the IALG_Fxn pointer.
 				 */
-		/* # input STRM definition structures */
-		RMS_WORD numInputStreams;
-	} ;
-
-#endif				/* RMS_SH_ */
+	/* # input STRM definition structures */
+	rms_word num_input_streams;
+};
 
+#endif /* RMS_SH_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/rmstypes.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/rmstypes.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/rmstypes.h	2011-10-11 13:50:58.147546941 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/rmstypes.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge Resource Manager Server shared data type definitions.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,19 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== rmstypes.h ========
- *
- *  DSP/BIOS Bridge Resource Manager Server shared data type definitions.
- *
- *! Revision History
- *! ================
- *! 06-Oct-2000 sg  Added LgFxn type.
- *! 05-Oct-2000 sg  Changed RMS_STATUS to LgUns.
- *! 31-Aug-2000 sg  Added RMS_DSPMSG.
- *! 25-Aug-2000 sg  Initial.
- */
-
 #ifndef RMSTYPES_
 #define RMSTYPES_
 #include <linux/types.h>
@@ -34,7 +23,7 @@
  *  DSP-side definitions.
  */
 #include <dspbridge/std.h>
-typedef u32 RMS_WORD;
-typedef char RMS_CHAR;
+typedef u32 rms_word;
+typedef char rms_char;
 
-#endif				/* RMSTYPES_ */
+#endif /* RMSTYPES_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/services.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/services.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/services.h	2011-10-11 13:50:58.147546941 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/services.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provide loading and unloading of SERVICES modules.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,27 +16,12 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== services.h ========
- *  Purpose:
- *      Provide loading and unloading of SERVICES modules.
- *
- *  Public Functions:
- *      SERVICES_Exit(void)
- *      SERVICES_Init(void)
- *
- *! Revision History:
- *! ================
- *! 01-Feb-2000 kc: Created.
- */
-
 #ifndef SERVICES_
 #define SERVICES_
 
 #include <dspbridge/host_os.h>
 /*
- *  ======== SERVICES_Exit ========
+ *  ======== services_exit ========
  *  Purpose:
  *      Discontinue usage of module; free resources when reference count
  *      reaches 0.
@@ -45,10 +32,10 @@
  *  Ensures:
  *      Resources used by module are freed when cRef reaches zero.
  */
-	extern void SERVICES_Exit(void);
+extern void services_exit(void);
 
 /*
- *  ======== SERVICES_Init ========
+ *  ======== services_init ========
  *  Purpose:
  *      Initializes SERVICES modules.
  *  Parameters:
@@ -58,6 +45,6 @@
  *  Ensures:
  *      SERVICES modules initialized.
  */
-	extern bool SERVICES_Init(void);
+extern bool services_init(void);
 
-#endif				/* SERVICES_ */
+#endif /* SERVICES_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/std.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/std.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/std.h	2011-10-11 13:50:58.147546941 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/std.h	2011-08-19 18:42:46.000000000 +0100
@@ -14,54 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== std.h ========
- *
- *! Revision History
- *! ================
- *! 16-Feb-2004 vp	GNU compiler 3.x defines inline keyword. Added
- *!			appropriate macros not to redefine inline keyword in
- *!			this file.
- *! 24-Oct-2002	ashu	defined _TI_ and _FIXED_ symbols for 28x.
- *! 24-Oct-2002	ashu	defined _TI_ for 24x.
- *! 01-Mar-2002 kln	changed LARGE_MODEL and Arg definition for 28x
- *! 01-Feb-2002 kln	added definitions for 28x
- *! 08-Dec-2000 kw:	added 'ArgToInt' and 'ArgToPtr' macros
- *! 30-Nov-2000 mf:	Added _64_, _6x_; removed _7d_
- *! 30-May-2000 srid:	Added   __TMS320C55X__ for 55x; Arg is void * for 55 .
- *! 18-Jun-1999 dr:	Added '_TI_', fixed __inline for SUN4, added inline
- *! 10-Feb-1999 rt:	Added '55' support, changed 54's symbol to _TMS320C5XX
- *! 29-Aug-1998 mf: 	fixed typo, removed obsolete targets
- *! 08-Jun-1998 mf: 	_67_ is synonym for _7d_
- *! 10-Oct-1997 rt;	added _7d_ for Raytheon C7DSP triggered by _TMS320C6700
- *! 04-Aug-1997 cc:	added _29_ for _TMS320C2XX
- *! 11-Jul-1997 dlr:	_5t_, and STD_SPOXTASK keyword for Tasking
- *! 12-Jun-1997 mf: 	_TMS320C60 -> _TMS320C6200
- *! 13-Feb-1997 mf:	_62_, with 32-bit LgInt
- *! 26-Nov-1996 kw: 	merged bios-c00's and wsx-a27's <dspbridge/std.h> changes
- *!			*and* revision history
- *! 12-Sep-1996 kw: 	added C54x #ifdef's
- *! 21-Aug-1996 mf: 	removed #define main smain for _21_
- *! 14-May-1996 gp:     def'd out INT, FLOAT, and COMPLEX defines for WSX.
- *! 11-Apr-1996 kw:     define _W32_ based on _WIN32 (defined by MS compiler)
- *! 07-Mar-1996 mg:     added Win32 support
- *! 06-Sep-1995 dh:	added _77_ dynamic stack support via fxns77.h
- *! 27-Jun-1995 dh:	added _77_ support
- *! 16-Mar-1995 mf: 	for _21_: #define main smain
- *! 01-Mar-1995 mf: 	set _20_ and _60_ (as well as _21_ for both)
- *! 22-Feb-1995 mf: 	Float is float for _SUN_ and _80_
- *! 22-Dec-1994 mf: 	Added _80_ definition, for PP or MP.
- *! 09-Dec-1994 mf: 	Added _53_ definition.
- *!			Added definitions of _30_, etc.
- *! 23-Aug-1994 dh	removed _21_ special case (kw)
- *! 17-Aug-1994 dh	added _51_ support
- *! 03-Aug-1994 kw	updated _80_ support
- *! 30-Jun-1994 kw	added _80_ support
- *! 05-Apr-1994 kw:	Added _SUN_ to _FLOAT_ definition
- *! 01-Mar-1994 kw: 	Made Bool an int (was u16) for _56_ (more efficient).
- *!			Added _53_ support.
- */
-
 #ifndef STD_
 #define STD_
 
@@ -120,24 +72,23 @@
  *  Aliases for standard C types
  */
 
-typedef s32(*Fxn) (void);		/* generic function type */
+typedef s32(*fxn) (void);	/* generic function type */
 
 #ifndef NULL
 #define NULL 0
 #endif
 
-
 /*
  * These macros are used to cast 'Arg' types to 's32' or 'Ptr'.
  * These macros were added for the 55x since Arg is not the same
  * size as s32 and Ptr in 55x large model.
  */
 #if defined(_28l_) || defined(_55l_)
-#define ArgToInt(A)	((s32)((long)(A) & 0xffff))
-#define ArgToPtr(A)	((Ptr)(A))
+#define ARG_TO_INT(A)	((s32)((long)(A) & 0xffff))
+#define ARG_TO_PTR(A)	((Ptr)(A))
 #else
-#define ArgToInt(A)	((s32)(A))
-#define ArgToPtr(A)	((Ptr)(A))
+#define ARG_TO_INT(A)	((s32)(A))
+#define ARG_TO_PTR(A)	((Ptr)(A))
 #endif
 
-#endif				/* STD_ */
+#endif /* STD_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/strmdefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/strmdefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/strmdefs.h	2011-10-11 13:50:58.156294492 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/strmdefs.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global STRM constants and types.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,44 +16,31 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== strmdefs.h ========
- *  Purpose:
- *      Global STRM constants and types.
- *
- *! Revision History
- *! ================
- *! 19-Nov-2001 ag      Added STRM_INFO..
- *! 25-Sep-2000 jeh     Created.
- */
-
 #ifndef STRMDEFS_
 #define STRMDEFS_
 
 #define STRM_MAXEVTNAMELEN      32
 
-	struct STRM_MGR;
+struct strm_mgr;
 
-	struct STRM_OBJECT;
+struct strm_object;
 
-	struct STRM_ATTR {
-		HANDLE hUserEvent;
-		char *pstrEventName;
-		void *pVirtBase;	/* Process virtual base address of
-					 * mapped SM */
-		u32 ulVirtSize;	/* Size of virtual space in bytes */
-		struct DSP_STREAMATTRIN *pStreamAttrIn;
-	} ;
+struct strm_attr {
+	bhandle user_event;
+	char *pstr_event_name;
+	void *virt_base;	/* Process virtual base address of
+				 * mapped SM */
+	u32 ul_virt_size;	/* Size of virtual space in bytes */
+	struct dsp_streamattrin *stream_attr_in;
+};
 
-	struct STRM_INFO {
-		enum DSP_STRMMODE lMode;	/* transport mode of
+struct stream_info {
+	enum dsp_strmmode strm_mode;	/* transport mode of
 					 * stream(DMA, ZEROCOPY..) */
-		u32 uSegment;	/* Segment strm allocs from. 0 is local mem */
-		void *pVirtBase;	/* "      " Stream'process virt base */
-		struct DSP_STREAMINFO *pUser;	/* User's stream information
+	u32 segment_id;		/* Segment strm allocs from. 0 is local mem */
+	void *virt_base;	/* "      " Stream'process virt base */
+	struct dsp_streaminfo *user_strm;	/* User's stream information
 						 * returned */
-	} ;
-
-#endif				/* STRMDEFS_ */
+};
 
+#endif /* STRMDEFS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/strm.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/strm.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/strm.h	2011-10-11 13:50:58.156294492 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/strm.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSPBridge Stream Manager.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,45 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== strm.h ========
- *  Description:
- *      DSPBridge Stream Manager.
- *
- *  Public Functions:
- *      STRM_AllocateBuffer
- *      STRM_Close
- *      STRM_Create
- *      STRM_Delete
- *      STRM_Exit
- *      STRM_FreeBuffer
- *      STRM_GetEventHandle
- *      STRM_GetInfo
- *      STRM_Idle
- *      STRM_Init
- *      STRM_Issue
- *      STRM_Open
- *      STRM_PrepareBuffer
- *      STRM_Reclaim
- *      STRM_RegisterNotify
- *      STRM_Select
- *      STRM_UnprepareBuffer
- *
- *  Notes:
- *
- *! Revision History:
- *! =================
- *! 15-Nov-2001 ag  Changed DSP_STREAMINFO to STRM_INFO in STRM_GetInfo().
- *!                 Added DSP_ESIZE error to STRM_AllocateBuffer().
- *! 07-Jun-2001 sg  Made DSPStream_AllocateBuffer fxn name plural.
- *! 10-May-2001 jeh Code review cleanup.
- *! 13-Feb-2001 kc  DSP/BIOS Bridge name updates.
- *! 06-Feb-2001 kc  Updated DBC_Ensure for STRM_Select().
- *! 23-Oct-2000 jeh Allow NULL STRM_ATTRS passed to STRM_Open().
- *! 25-Sep-2000 jeh Created.
- */
-
 #ifndef STRM_
 #define STRM_
 
@@ -62,37 +25,37 @@
 #include <dspbridge/proc.h>
 
 /*
- *  ======== STRM_AllocateBuffer ========
+ *  ======== strm_allocate_buffer ========
  *  Purpose:
  *      Allocate data buffer(s) for use with a stream.
  *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      uSize:          Size (GPP bytes) of the buffer(s).
- *      uNumBufs:       Number of buffers to allocate.
- *      apBuffer:       Array to hold buffer addresses.
+ *      hStrm:          Stream handle returned from strm_open().
+ *      usize:          Size (GPP bytes) of the buffer(s).
+ *      num_bufs:       Number of buffers to allocate.
+ *      ap_buffer:       Array to hold buffer addresses.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hStrm.
  *      DSP_EMEMORY:    Insufficient memory.
  *      DSP_EFAIL:      Failure occurred, unable to allocate buffers.
- *      DSP_ESIZE:      uSize must be > 0 bytes.
+ *      DSP_ESIZE:      usize must be > 0 bytes.
  *  Requires:
- *      STRM_Init(void) called.
- *      apBuffer != NULL.
+ *      strm_init(void) called.
+ *      ap_buffer != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_AllocateBuffer(struct STRM_OBJECT *hStrm,
-					      u32 uSize,
-					      OUT u8 **apBuffer,
-					      u32 uNumBufs,
-					      struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status strm_allocate_buffer(struct strm_object *hStrm,
+				       u32 usize,
+				       OUT u8 **ap_buffer,
+				       u32 num_bufs,
+				       struct process_context *pr_ctxt);
 
 /*
- *  ======== STRM_Close ========
+ *  ======== strm_close ========
  *  Purpose:
- *      Close a stream opened with STRM_Open().
+ *      Close a stream opened with strm_open().
  *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
+ *      hStrm:          Stream handle returned from strm_open().
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hStrm.
@@ -100,128 +63,128 @@
  *                      been reclaimed.
  *      DSP_EFAIL:      Failure to close stream.
  *  Requires:
- *      STRM_Init(void) called.
+ *      strm_init(void) called.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_Close(struct STRM_OBJECT *hStrm,
-			struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status strm_close(struct strm_object *hStrm,
+			     struct process_context *pr_ctxt);
 
 /*
- *  ======== STRM_Create ========
+ *  ======== strm_create ========
  *  Purpose:
  *      Create a STRM manager object. This object holds information about the
  *      device needed to open streams.
  *  Parameters:
  *      phStrmMgr:      Location to store handle to STRM manager object on
  *                      output.
- *      hDev:           Device for this processor.
+ *      dev_obj:           Device for this processor.
  *  Returns:
  *      DSP_SOK:        Success;
  *      DSP_EMEMORY:    Insufficient memory for requested resources.
  *      DSP_EFAIL:      General failure.
  *  Requires:
- *      STRM_Init(void) called.
+ *      strm_init(void) called.
  *      phStrmMgr != NULL.
- *      hDev != NULL.
+ *      dev_obj != NULL.
  *  Ensures:
  *      DSP_SOK:        Valid *phStrmMgr.
  *      error:          *phStrmMgr == NULL.
  */
-	extern DSP_STATUS STRM_Create(OUT struct STRM_MGR **phStrmMgr,
-				      struct DEV_OBJECT *hDev);
+extern dsp_status strm_create(OUT struct strm_mgr **phStrmMgr,
+			      struct dev_object *dev_obj);
 
 /*
- *  ======== STRM_Delete ========
+ *  ======== strm_delete ========
  *  Purpose:
  *      Delete the STRM Object.
  *  Parameters:
- *      hStrmMgr:       Handle to STRM manager object from STRM_Create.
+ *      strm_mgr_obj:       Handle to STRM manager object from strm_create.
  *  Returns:
  *  Requires:
- *      STRM_Init(void) called.
- *      Valid hStrmMgr.
+ *      strm_init(void) called.
+ *      Valid strm_mgr_obj.
  *  Ensures:
- *      hStrmMgr is not valid.
+ *      strm_mgr_obj is not valid.
  */
-	extern void STRM_Delete(struct STRM_MGR *hStrmMgr);
+extern void strm_delete(struct strm_mgr *strm_mgr_obj);
 
 /*
- *  ======== STRM_Exit ========
+ *  ======== strm_exit ========
  *  Purpose:
  *      Discontinue usage of STRM module.
  *  Parameters:
  *  Returns:
  *  Requires:
- *      STRM_Init(void) successfully called before.
+ *      strm_init(void) successfully called before.
  *  Ensures:
  */
-	extern void STRM_Exit(void);
+extern void strm_exit(void);
 
 /*
- *  ======== STRM_FreeBuffer ========
+ *  ======== strm_free_buffer ========
  *  Purpose:
- *      Free buffer(s) allocated with STRM_AllocateBuffer.
+ *      Free buffer(s) allocated with strm_allocate_buffer.
  *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      apBuffer:       Array containing buffer addresses.
- *      uNumBufs:       Number of buffers to be freed.
+ *      hStrm:          Stream handle returned from strm_open().
+ *      ap_buffer:       Array containing buffer addresses.
+ *      num_bufs:       Number of buffers to be freed.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid stream handle.
  *      DSP_EFAIL:      Failure occurred, unable to free buffers.
  *  Requires:
- *      STRM_Init(void) called.
- *      apBuffer != NULL.
+ *      strm_init(void) called.
+ *      ap_buffer != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_FreeBuffer(struct STRM_OBJECT *hStrm,
-					  u8 **apBuffer, u32 uNumBufs,
-					  struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status strm_free_buffer(struct strm_object *hStrm,
+				   u8 **ap_buffer, u32 num_bufs,
+				   struct process_context *pr_ctxt);
 
 /*
- *  ======== STRM_GetEventHandle ========
+ *  ======== strm_get_event_handle ========
  *  Purpose:
  *      Get stream's user event handle. This function is used when closing
  *      a stream, so the event can be closed.
  *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      phEvent:        Location to store event handle on output.
+ *      hStrm:          Stream handle returned from strm_open().
+ *      ph_event:        Location to store event handle on output.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hStrm.
  *  Requires:
- *      STRM_Init(void) called.
- *      phEvent != NULL.
+ *      strm_init(void) called.
+ *      ph_event != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_GetEventHandle(struct STRM_OBJECT *hStrm,
-					      OUT HANDLE *phEvent);
+extern dsp_status strm_get_event_handle(struct strm_object *hStrm,
+					OUT bhandle *ph_event);
 
 /*
- *  ======== STRM_GetInfo ========
+ *  ======== strm_get_info ========
  *  Purpose:
- *      Get information about a stream. User's DSP_STREAMINFO is contained
- *      in STRM_INFO struct. STRM_INFO also contains Bridge private info.
+ *      Get information about a stream. User's dsp_streaminfo is contained
+ *      in stream_info struct. stream_info also contains Bridge private info.
  *  Parameters:
- *      hStrm:              Stream handle returned from STRM_Open().
- *      pStreamInfo:        Location to store stream info on output.
- *      uSteamInfoSize:     Size of user's DSP_STREAMINFO structure.
+ *      hStrm:              Stream handle returned from strm_open().
+ *      stream_info:        Location to store stream info on output.
+ *      uSteamInfoSize:     Size of user's dsp_streaminfo structure.
  *  Returns:
  *      DSP_SOK:            Success.
  *      DSP_EHANDLE:        Invalid hStrm.
- *      DSP_ESIZE:          uStreamInfoSize < sizeof(DSP_STREAMINFO).
+ *      DSP_ESIZE:          stream_info_size < sizeof(dsp_streaminfo).
  *      DSP_EFAIL:          Unable to get stream info.
  *  Requires:
- *      STRM_Init(void) called.
- *      pStreamInfo != NULL.
+ *      strm_init(void) called.
+ *      stream_info != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_GetInfo(struct STRM_OBJECT *hStrm,
-				       OUT struct STRM_INFO *pStreamInfo,
-				       u32 uStreamInfoSize);
+extern dsp_status strm_get_info(struct strm_object *hStrm,
+				OUT struct stream_info *stream_info,
+				u32 stream_info_size);
 
 /*
- *  ======== STRM_Idle ========
+ *  ======== strm_idle ========
  *  Purpose:
  *      Idle a stream and optionally flush output data buffers.
  *      If this is an output stream and fFlush is TRUE, all data currently
@@ -229,10 +192,10 @@
  *      If this is an output stream and fFlush is FALSE, this function
  *      will block until all currently buffered data is output, or the timeout
  *      specified has been reached.
- *      After a successful call to STRM_Idle(), all buffers can immediately
+ *      After a successful call to strm_idle(), all buffers can immediately
  *      be reclaimed.
  *  Parameters:
- *      hStrm:          Stream handle returned from STRM_Open().
+ *      hStrm:          Stream handle returned from strm_open().
  *      fFlush:         If TRUE, discard output buffers.
  *  Returns:
  *      DSP_SOK:        Success.
@@ -241,13 +204,13 @@
  *      DSP_ERESTART:   A critical error occurred, DSP is being restarted.
  *      DSP_EFAIL:      Unable to idle stream.
  *  Requires:
- *      STRM_Init(void) called.
+ *      strm_init(void) called.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_Idle(struct STRM_OBJECT *hStrm, bool fFlush);
+extern dsp_status strm_idle(struct strm_object *hStrm, bool fFlush);
 
 /*
- *  ======== STRM_Init ========
+ *  ======== strm_init ========
  *  Purpose:
  *      Initialize the STRM module.
  *  Parameters:
@@ -256,97 +219,95 @@
  *  Requires:
  *  Ensures:
  */
-	extern bool STRM_Init(void);
+extern bool strm_init(void);
 
 /*
- *  ======== STRM_Issue ========
+ *  ======== strm_issue ========
  *  Purpose:
  *      Send a buffer of data to a stream.
  *  Parameters:
- *      hStrm:              Stream handle returned from STRM_Open().
- *      pBuf:               Pointer to buffer of data to be sent to the stream.
- *      ulBytes:            Number of bytes of data in the buffer.
- *      ulBufSize:          Actual buffer size in bytes.
- *      dwArg:              A user argument that travels with the buffer.
+ *      hStrm:              Stream handle returned from strm_open().
+ *      pbuf:               Pointer to buffer of data to be sent to the stream.
+ *      ul_bytes:            Number of bytes of data in the buffer.
+ *      ul_buf_size:          Actual buffer size in bytes.
+ *      dw_arg:              A user argument that travels with the buffer.
  *  Returns:
  *      DSP_SOK:            Success.
  *      DSP_EHANDLE:        Invalid hStrm.
  *      DSP_ESTREAMFULL:    The stream is full.
  *      DSP_EFAIL:          Failure occurred, unable to issue buffer.
  *  Requires:
- *      STRM_Init(void) called.
- *      pBuf != NULL.
+ *      strm_init(void) called.
+ *      pbuf != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_Issue(struct STRM_OBJECT *hStrm, IN u8 *pBuf,
-				     u32 ulBytes, u32 ulBufSize,
-				     IN u32 dwArg);
+extern dsp_status strm_issue(struct strm_object *hStrm, IN u8 * pbuf,
+			     u32 ul_bytes, u32 ul_buf_size, IN u32 dw_arg);
 
 /*
- *  ======== STRM_Open ========
+ *  ======== strm_open ========
  *  Purpose:
  *      Open a stream for sending/receiving data buffers to/from a task of
  *      DAIS socket node on the DSP.
  *  Parameters:
- *      hNode:          Node handle returned from NODE_Allocate().
- *      uDir:           DSP_TONODE or DSP_FROMNODE.
- *      uIndex:         Stream index.
- *      pAttr:          Pointer to structure containing attributes to be
+ *      hnode:          Node handle returned from node_allocate().
+ *      dir:           DSP_TONODE or DSP_FROMNODE.
+ *      index:         Stream index.
+ *      pattr:          Pointer to structure containing attributes to be
  *                      applied to stream. Cannot be NULL.
  *      phStrm:         Location to store stream handle on output.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hNode.
- *      DSP_EDIRECTION: Invalid uDir.
- *      DSP_EVALUE:     Invalid uIndex.
- *      DSP_ENODETYPE:  hNode is not a task or DAIS socket node.
+ *      DSP_EHANDLE:    Invalid hnode.
+ *      DSP_EDIRECTION: Invalid dir.
+ *      DSP_EVALUE:     Invalid index.
+ *      DSP_ENODETYPE:  hnode is not a task or DAIS socket node.
  *      DSP_EFAIL:      Unable to open stream.
  *  Requires:
- *      STRM_Init(void) called.
+ *      strm_init(void) called.
  *      phStrm != NULL.
- *      pAttr != NULL.
+ *      pattr != NULL.
  *  Ensures:
  *      DSP_SOK:        *phStrm is valid.
  *      error:          *phStrm == NULL.
  */
-	extern DSP_STATUS STRM_Open(struct NODE_OBJECT *hNode, u32 uDir,
-				    u32 uIndex, IN struct STRM_ATTR *pAttr,
-				    OUT struct STRM_OBJECT **phStrm,
-				    struct PROCESS_CONTEXT *pr_ctxt);
+extern dsp_status strm_open(struct node_object *hnode, u32 dir,
+			    u32 index, IN struct strm_attr *pattr,
+			    OUT struct strm_object **phStrm,
+			    struct process_context *pr_ctxt);
 
 /*
- *  ======== STRM_PrepareBuffer ========
+ *  ======== strm_prepare_buffer ========
  *  Purpose:
  *      Prepare a data buffer not allocated by DSPStream_AllocateBuffers()
  *      for use with a stream.
  *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      uSize:          Size (GPP bytes) of the buffer.
- *      pBuffer:        Buffer address.
+ *      hStrm:          Stream handle returned from strm_open().
+ *      usize:          Size (GPP bytes) of the buffer.
+ *      pbuffer:        Buffer address.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hStrm.
  *      DSP_EFAIL:      Failure occurred, unable to prepare buffer.
  *  Requires:
- *      STRM_Init(void) called.
- *      pBuffer != NULL.
+ *      strm_init(void) called.
+ *      pbuffer != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_PrepareBuffer(struct STRM_OBJECT *hStrm,
-					     u32 uSize,
-					     u8 *pBuffer);
+extern dsp_status strm_prepare_buffer(struct strm_object *hStrm,
+				      u32 usize, u8 *pbuffer);
 
 /*
- *  ======== STRM_Reclaim ========
+ *  ======== strm_reclaim ========
  *  Purpose:
  *      Request a buffer back from a stream.
  *  Parameters:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      pBufPtr:        Location to store pointer to reclaimed buffer.
+ *      hStrm:          Stream handle returned from strm_open().
+ *      buf_ptr:        Location to store pointer to reclaimed buffer.
  *      pulBytes:       Location where number of bytes of data in the
  *                      buffer will be written.
  *      pulBufSize:     Location where actual buffer size will be written.
- *      pdwArg:         Location where user argument that travels with
+ *      pdw_arg:         Location where user argument that travels with
  *                      the buffer will be written.
  *  Returns:
  *      DSP_SOK:        Success.
@@ -355,51 +316,51 @@
  *                      retrieved.
  *      DSP_EFAIL:      Failure occurred, unable to reclaim buffer.
  *  Requires:
- *      STRM_Init(void) called.
- *      pBufPtr != NULL.
+ *      strm_init(void) called.
+ *      buf_ptr != NULL.
  *      pulBytes != NULL.
- *      pdwArg != NULL.
+ *      pdw_arg != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_Reclaim(struct STRM_OBJECT *hStrm,
-				       OUT u8 **pBufPtr, u32 *pulBytes,
-				       u32 *pulBufSize, u32 *pdwArg);
+extern dsp_status strm_reclaim(struct strm_object *hStrm,
+			       OUT u8 **buf_ptr, u32 * pulBytes,
+			       u32 *pulBufSize, u32 *pdw_arg);
 
 /*
- *  ======== STRM_RegisterNotify ========
+ *  ======== strm_register_notify ========
  *  Purpose:
  *      Register to be notified on specific events for this stream.
  *  Parameters:
- *      hStrm:          Stream handle returned by STRM_Open().
- *      uEventMask:     Mask of types of events to be notified about.
- *      uNotifyType:    Type of notification to be sent.
- *      hNotification:  Handle to be used for notification.
+ *      hStrm:          Stream handle returned by strm_open().
+ *      event_mask:     Mask of types of events to be notified about.
+ *      notify_type:    Type of notification to be sent.
+ *      hnotification:  Handle to be used for notification.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hStrm.
  *      DSP_EMEMORY:    Insufficient memory on GPP.
- *      DSP_EVALUE:     uEventMask is invalid.
- *      DSP_ENOTIMPL:   Notification type specified by uNotifyType is not
+ *      DSP_EVALUE:     event_mask is invalid.
+ *      DSP_ENOTIMPL:   Notification type specified by notify_type is not
  *                      supported.
  *  Requires:
- *      STRM_Init(void) called.
- *      hNotification != NULL.
+ *      strm_init(void) called.
+ *      hnotification != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_RegisterNotify(struct STRM_OBJECT *hStrm,
-					      u32 uEventMask, u32 uNotifyType,
-					      struct DSP_NOTIFICATION
-					      *hNotification);
+extern dsp_status strm_register_notify(struct strm_object *hStrm,
+				       u32 event_mask, u32 notify_type,
+				       struct dsp_notification
+				       *hnotification);
 
 /*
- *  ======== STRM_Select ========
+ *  ======== strm_select ========
  *  Purpose:
  *      Select a ready stream.
  *  Parameters:
- *      aStrmTab:       Array of stream handles returned from STRM_Open().
+ *      strm_tab:       Array of stream handles returned from strm_open().
  *      nStrms:         Number of stream handles in array.
- *      pMask:          Location to store mask of ready streams on output.
- *      uTimeout:       Timeout value (milliseconds).
+ *      pmask:          Location to store mask of ready streams on output.
+ *      utimeout:       Timeout value (milliseconds).
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_ERANGE:     nStrms out of range.
@@ -408,39 +369,37 @@
  *      DSP_ETIMEOUT:   A timeout occurred before a stream became ready.
  *      DSP_EFAIL:      Failure occurred, unable to select a stream.
  *  Requires:
- *      STRM_Init(void) called.
- *      aStrmTab != NULL.
+ *      strm_init(void) called.
+ *      strm_tab != NULL.
  *      nStrms > 0.
- *      pMask != NULL.
+ *      pmask != NULL.
  *  Ensures:
- *      DSP_SOK:        *pMask != 0 || uTimeout == 0.
- *      Error:          *pMask == 0.
+ *      DSP_SOK:        *pmask != 0 || utimeout == 0.
+ *      Error:          *pmask == 0.
  */
-	extern DSP_STATUS STRM_Select(IN struct STRM_OBJECT **aStrmTab,
-				      u32 nStrms,
-				      OUT u32 *pMask, u32 uTimeout);
+extern dsp_status strm_select(IN struct strm_object **strm_tab,
+			      u32 nStrms, OUT u32 *pmask, u32 utimeout);
 
 /*
- *  ======== STRM_UnprepareBuffer ========
+ *  ======== strm_unprepare_buffer ========
  *  Purpose:
  *      Unprepare a data buffer that was previously prepared for a stream
  *      with DSPStream_PrepareBuffer(), and that will no longer be used with
  *      the stream.
  *  Parameter:
- *      hStrm:          Stream handle returned from STRM_Open().
- *      uSize:          Size (GPP bytes) of the buffer.
- *      pBuffer:        Buffer address.
+ *      hStrm:          Stream handle returned from strm_open().
+ *      usize:          Size (GPP bytes) of the buffer.
+ *      pbuffer:        Buffer address.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hStrm.
  *      DSP_EFAIL:      Failure occurred, unable to unprepare buffer.
  *  Requires:
- *      STRM_Init(void) called.
- *      pBuffer != NULL.
+ *      strm_init(void) called.
+ *      pbuffer != NULL.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_UnprepareBuffer(struct STRM_OBJECT *hStrm,
-					       u32 uSize,
-					       u8 *pBuffer);
+extern dsp_status strm_unprepare_buffer(struct strm_object *hStrm,
+					u32 usize, u8 *pbuffer);
 
-#endif				/* STRM_ */
+#endif /* STRM_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/sync.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/sync.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/sync.h	2011-10-11 13:50:58.156294492 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/sync.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provide synchronization services.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,44 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== sync.h ========
- *  Purpose:
- *      Provide synchronization services.
- *
- *  Public Functions:
- *      SYNC_CloseEvent
- *      SYNC_DeleteCS
- *      SYNC_EnterCS
- *      SYNC_Exit
- *      SYNC_Init
- *      SYNC_InitializeCS
- *      SYNC_LeaveCS
- *      SYNC_OpenEvent
- *      SYNC_PostMessage
- *      SYNC_ResetEvent
- *      SYNC_SetEvent
- *      SYNC_WaitOnEvent
- *      SYNC_WaitOnMultipleEvents
- *
- *! Revision History:
- *! ================
- *! 05-Oct-2000 jeh Added SYNC_WaitOnMultipleEvents().
- *! 01-Dec-1999 ag: Added #define SYNC_MAXNAMELENGTH.
- *! 04-Nov-1999 kc: Added critical section functions and objects to SYNC.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 24-Sep-1999 kc: Added WinCE notes.
- *! 20-Oct-1997 gp: Removed unused SYNC_ critical section and must complete fxns
- *!                 Added SYNC_HOBJECT, SYNC_ATTRS, and object validation, and
- *!                 merged SYNC_DestroyEvent into SYNC_CloseEvent, and merged
- *!                 SYNC_CreateEvent into SYNC_OpenEvent.
- *! 07-Oct-1997 gp: Added SYNC_Create/DestroyEvent (for NT testing).
- *! 06-Oct-1997 gp: Added SYNC_OpenEvent.
- *! 03-Jun-1997 gp: Added SYNC_{Begin|End}CritSection() functions.
- *! 03-Jan-1997 gp: Added SYNC_INFINITE define.
- *! 05-Aug-1996 gp: Created.
- */
-
 #ifndef _SYNC_H
 #define _SYNC_H
 
@@ -65,30 +29,30 @@
 #define SYNC_MAXNAMELENGTH 32
 
 /* Generic SYNC object: */
-	struct SYNC_OBJECT;
+struct sync_object;
 
 /* Generic SYNC CS object: */
-struct SYNC_CSOBJECT {
-	u32 dwSignature;	/* used for object validation */
+struct sync_csobject {
+	u32 dw_signature;	/* used for object validation */
 	struct semaphore sem;
-} ;
+};
 
 /* SYNC object attributes: */
-	struct SYNC_ATTRS {
-		HANDLE hUserEvent;    /* Platform's User Mode synch. object. */
-		HANDLE hKernelEvent;  /* Platform's Kernel Mode sync. object. */
-		u32 dwReserved1;	/* For future expansion.   */
-		u32 dwReserved2;	/* For future expansion.   */
-	} ;
+struct sync_attrs {
+	bhandle user_event;	/* Platform's User Mode synch. object. */
+	bhandle kernel_event;	/* Platform's Kernel Mode sync. object. */
+	u32 dw_reserved1;	/* For future expansion. */
+	u32 dw_reserved2;	/* For future expansion. */
+};
 
 /*
- *  ======== SYNC_CloseEvent ========
+ *  ======== sync_close_event ========
  *  Purpose:
- *      Close this event handle, freeing resources allocated in SYNC_OpenEvent
+ *      Close this event handle, freeing resources allocated in sync_open_event
  *      if necessary.
  *  Parameters:
- *      hEvent: Handle to a synchronization event, created/opened in
- *              SYNC_OpenEvent.
+ *      event_obj: Handle to a synchronization event, created/opened in
+ *              sync_open_event.
  *  Returns:
  *      DSP_SOK:        Success;
  *      DSP_EFAIL:      Failed to close event handle.
@@ -96,40 +60,40 @@
  *  Requires:
  *      SYNC initialized.
  *  Ensures:
- *      Any subsequent usage of hEvent would be invalid.
+ *      Any subsequent usage of event_obj would be invalid.
  */
-	extern DSP_STATUS SYNC_CloseEvent(IN struct SYNC_OBJECT *hEvent);
+extern dsp_status sync_close_event(IN struct sync_object *event_obj);
 
 /*
- *  ======== SYNC_DeleteCS ========
+ *  ======== sync_delete_cs ========
  *  Purpose:
  *      Delete a critical section.
  *  Parameters:
- *      hCSObj: critical section handle.
+ *      hcs_obj: critical section handle.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid handle.
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS SYNC_DeleteCS(IN struct SYNC_CSOBJECT *hCSObj);
+extern dsp_status sync_delete_cs(IN struct sync_csobject *hcs_obj);
 
 /*
- *  ======== SYNC_EnterCS ========
+ *  ======== sync_enter_cs ========
  *  Purpose:
  *      Enter the critical section.
  *  Parameters:
- *      hCSObj: critical section handle.
+ *      hcs_obj: critical section handle.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid handle.
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS SYNC_EnterCS(IN struct SYNC_CSOBJECT *hCSObj);
+extern dsp_status sync_enter_cs(IN struct sync_csobject *hcs_obj);
 
 /*
- *  ======== SYNC_Exit ========
+ *  ======== sync_exit ========
  *  Purpose:
  *      Discontinue usage of module; free resources when reference count
  *      reaches 0.
@@ -140,10 +104,10 @@
  *  Ensures:
  *      Resources used by module are freed when cRef reaches zero.
  */
-	extern void SYNC_Exit(void);
+extern void sync_exit(void);
 
 /*
- *  ======== SYNC_Init ========
+ *  ======== sync_init ========
  *  Purpose:
  *      Initializes private state of SYNC module.
  *  Parameters:
@@ -153,88 +117,87 @@
  *  Ensures:
  *      SYNC initialized.
  */
-	extern bool SYNC_Init(void);
+extern bool sync_init(void);
 
 /*
- *  ======== SYNC_InitializeCS ========
+ *  ======== sync_initialize_cs ========
  *  Purpose:
  *      Initialize the critical section.
  *  Parameters:
- *      hCSObj: critical section handle.
+ *      hcs_obj: critical section handle.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Out of memory.
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS SYNC_InitializeCS(OUT struct SYNC_CSOBJECT **phCSObj);
+extern dsp_status sync_initialize_cs(OUT struct sync_csobject **phCSObj);
 
 /*
- *  ======== SYNC_InitializeDPCCS ========
+ *  ======== sync_initialize_dpccs ========
  *  Purpose:
  *      Initialize the critical section between process context and DPC.
  *  Parameters:
- *      hCSObj: critical section handle.
+ *      hcs_obj: critical section handle.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Out of memory.
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS SYNC_InitializeDPCCS(OUT struct SYNC_CSOBJECT
-					       **phCSObj);
+extern dsp_status sync_initialize_dpccs(OUT struct sync_csobject
+					**phCSObj);
 
 /*
- *  ======== SYNC_LeaveCS ========
+ *  ======== sync_leave_cs ========
  *  Purpose:
  *      Leave the critical section.
  *  Parameters:
- *      hCSObj: critical section handle.
+ *      hcs_obj: critical section handle.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid handle.
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS SYNC_LeaveCS(IN struct SYNC_CSOBJECT *hCSObj);
+extern dsp_status sync_leave_cs(IN struct sync_csobject *hcs_obj);
 
 /*
- *  ======== SYNC_OpenEvent ========
+ *  ======== sync_open_event ========
  *  Purpose:
  *      Create/open and initialize an event object for thread synchronization,
  *      which is initially in the non-signalled state.
  *  Parameters:
- *      phEvent:    Pointer to location to receive the event object handle.
- *      pAttrs:     Pointer to SYNC_ATTRS object containing initial SYNC
- *                  SYNC_OBJECT attributes.  If this pointer is NULL, then
- *                  SYNC_OpenEvent will create and manage an OS specific
+ *      ph_event:    Pointer to location to receive the event object handle.
+ *      pattrs:     Pointer to sync_attrs object containing initial SYNC
+ *                  sync_object attributes.  If this pointer is NULL, then
+ *                  sync_open_event will create and manage an OS specific
  *                  syncronization object.
- *          pAttrs->hUserEvent:  Platform's User Mode synchronization object.
+ *          pattrs->user_event:  Platform's User Mode synchronization object.
  *
  *      The behaviour of the SYNC methods depend on the value of
- *      the hUserEvent attr:
+ *      the user_event attr:
  *
- *      1. (hUserEvent == NULL):
+ *      1. (user_event == NULL):
  *          A user mode event is created.
- *      2. (hUserEvent != NULL):
- *          A user mode event is supplied by the caller of SYNC_OpenEvent().
+ *      2. (user_event != NULL):
+ *          A user mode event is supplied by the caller of sync_open_event().
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Unable to create user mode event.
  *      DSP_EMEMORY:    Insufficient memory.
- *      DSP_EINVALIDARG SYNC_ATTRS values are invalid.
+ *      DSP_EINVALIDARG sync_attrs values are invalid.
  *  Requires:
  *      - SYNC initialized.
- *      - phEvent != NULL.
+ *      - ph_event != NULL.
  *  Ensures:
- *      If function succeeded, pEvent->hEvent must be a valid event handle.
+ *      If function succeeded, event->event_obj must be a valid event handle.
  */
-	extern DSP_STATUS SYNC_OpenEvent(OUT struct SYNC_OBJECT **phEvent,
-					 IN OPTIONAL struct SYNC_ATTRS
-					 *pAttrs);
+extern dsp_status sync_open_event(OUT struct sync_object **ph_event,
+				  IN OPTIONAL struct sync_attrs *pattrs);
 
 /*
- * ========= SYNC_PostMessage ========
+ * ========= sync_post_message ========
  *  Purpose:
  *      To post a windows message
  *  Parameters:
@@ -248,14 +211,14 @@
  *      SYNC initialized
  *  Ensures
  */
-	extern DSP_STATUS SYNC_PostMessage(IN HANDLE hWindow, IN u32 uMsg);
+extern dsp_status sync_post_message(IN bhandle hWindow, IN u32 uMsg);
 
 /*
- *  ======== SYNC_ResetEvent ========
+ *  ======== sync_reset_event ========
  *  Purpose:
  *      Reset a syncronization event object state to non-signalled.
  *  Parameters:
- *      hEvent:         Handle to a sync event.
+ *      event_obj:         Handle to a sync event.
  *  Returns:
  *      DSP_SOK:        Success;
  *      DSP_EFAIL:      Failed to reset event.
@@ -264,14 +227,14 @@
  *      SYNC initialized.
  *  Ensures:
  */
-	extern DSP_STATUS SYNC_ResetEvent(IN struct SYNC_OBJECT *hEvent);
+extern dsp_status sync_reset_event(IN struct sync_object *event_obj);
 
 /*
- *  ======== SYNC_SetEvent ========
+ *  ======== sync_set_event ========
  *  Purpose:
  *      Signal the event.  Will unblock one waiting thread.
  *  Parameters:
- *      hEvent:         Handle to an event object.
+ *      event_obj:         Handle to an event object.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Failed to signal event.
@@ -280,14 +243,14 @@
  *      SYNC initialized.
  *  Ensures:
  */
-	extern DSP_STATUS SYNC_SetEvent(IN struct SYNC_OBJECT *hEvent);
+extern dsp_status sync_set_event(IN struct sync_object *event_obj);
 
 /*
- *  ======== SYNC_WaitOnEvent ========
+ *  ======== sync_wait_on_event ========
  *  Purpose:
  *      Wait for an event to be signalled, up to the specified timeout.
  *  Parameters:
- *      hEvent:         Handle to an event object.
+ *      event_obj:         Handle to an event object.
  *      dwTimeOut:      The time-out interval, in milliseconds.
  *                      The function returns if the interval elapses, even if
  *                      the object's state is nonsignaled.
@@ -303,18 +266,18 @@
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS SYNC_WaitOnEvent(IN struct SYNC_OBJECT *hEvent,
-					   IN u32 dwTimeOut);
+extern dsp_status sync_wait_on_event(IN struct sync_object *event_obj,
+				     IN u32 dwTimeOut);
 
 /*
- *  ======== SYNC_WaitOnMultipleEvents ========
+ *  ======== sync_wait_on_multiple_events ========
  *  Purpose:
  *      Wait for any of an array of events to be signalled, up to the
  *      specified timeout.
  *      Note: dwTimeOut must be SYNC_INFINITE to signal infinite wait.
  *  Parameters:
- *      hSyncEvents:    Array of handles to event objects.
- *      uCount:         Number of event handles.
+ *      sync_events:    Array of handles to event objects.
+ *      count:         Number of event handles.
  *      dwTimeOut:      The time-out interval, in milliseconds.
  *                      The function returns if the interval elapses, even if
  *                      no event is signalled.
@@ -322,7 +285,7 @@
  *                      returns immediately.
  *                      If SYNC_INFINITE, the function's time-out interval
  *                      never elapses.
- *      puIndex:        Location to store index of event that was signalled.
+ *      pu_index:        Location to store index of event that was signalled.
  *  Returns:
  *      DSP_SOK:        The object was signalled.
  *      SYNC_E_FAIL:    Wait failed, possibly because the process terminated.
@@ -331,10 +294,10 @@
  *  Requires:
  *  Ensures:
  */
-	extern DSP_STATUS SYNC_WaitOnMultipleEvents(IN struct SYNC_OBJECT
-						    **hSyncEvents,
-						    IN u32 uCount,
-						    IN u32 dwTimeout,
-						    OUT u32 *puIndex);
+extern dsp_status sync_wait_on_multiple_events(IN struct sync_object
+					       **sync_events,
+					       IN u32 count,
+					       IN u32 dwTimeout,
+					       OUT u32 *pu_index);
 
-#endif				/* _SYNC_H */
+#endif /* _SYNC_H */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/utildefs.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/utildefs.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/utildefs.h	2011-10-11 13:50:58.156294492 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/utildefs.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global UTIL constants and types, shared between WCD and DSPSYS.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,20 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== utildefs.h ========
- *  Purpose:
- *      Global UTIL constants and types, shared between WCD and DSPSYS.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 kc  Removed wIOPort* entries from UTIL_HOSTCONFIG.
- *! 12-Aug-2000 ag  Added UTIL_SYSINFO typedef.
- *! 08-Oct-1999 rr  Adopted for WinCE where test fxns will be added in util.h
- *! 26-Dec-1996 cr  Created.
- */
-
 #ifndef UTILDEFS_
 #define UTILDEFS_
 
@@ -41,11 +29,11 @@
 #define UTIL_MAXARGVS       10
 
 /* Platform specific important info */
-	struct UTIL_SYSINFO {
-		/* Granularity of page protection; usually 1k or 4k */
-		u32 dwPageSize;
-		u32 dwAllocationGranularity; /* VM granularity, usually 64K */
-		u32 dwNumberOfProcessors;	/* Used as sanity check */
-	} ;
+struct util_sysinfo {
+	/* Granularity of page protection; usually 1k or 4k */
+	u32 dw_page_size;
+	u32 dw_allocation_granularity;	/* VM granularity, usually 64K */
+	u32 dw_number_of_processors;	/* Used as sanity check */
+};
 
-#endif				/* UTILDEFS_ */
+#endif /* UTILDEFS_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/util.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/util.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/util.h	2011-10-11 13:50:58.261773218 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/util.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,122 +0,0 @@
-/*
- * util.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== util.h ========
- *  Purpose:
- *      Provide general purpose utility functions.
- *
- *  Public Functions:
- *      UTIL_CDTestDll
- *      UTIL_CmdLineToArgs
- *      UTIL_Exit
- *      UTIL_GetSysInfo
- *      UTIL_Init
- */
-
-#ifndef _UTIL_H
-#define _UTIL_H
-
-#include <linux/delay.h>
-#include <linux/sched.h>
-
-#include <dspbridge/utildefs.h>
-
-/*
- *  ======== UTIL_CDTestDll ========
- *  Purpose:
- *      Provides test entry point in class driver context.
- *  Parameters:
- *      cArgc:  test module command line input count.
- *      ppArgv: test module command line args.
- *  Returns:
- *      0 if successful, a negative value otherwise.
- *  Requires:
- *      UTIL initialized.
- *  Ensures:
- */
-	extern u32 UTIL_CDTestDll(IN s32 cArgc, IN char **ppArgv);
-
-/*
- *  ======== UTIL_CmdLineToArgs ========
- *  Purpose:
- *      This function re-creates C-style cmd line argc & argv from WinMain()
- *      cmd line args.
- *  Parameters:
- *      s8 *pszProgName   - The name of the program currently being executed.
- *      s8 *argv[]        - The argument vector.
- *      s8 *pCmdLine      - The pointer to the command line.
- *      bool fHasProgName   - Indicats whether a program name is supplied.
- *  Returns:
- *      Returns the number of arguments found.
- *  Requires:
- *      UTIL initialized.
- *  Ensures:
- */
-	extern s32 UTIL_CmdLineToArgs(IN char *pszProgName,
-				      IN char *argv[UTIL_MAXARGVS],
-				      IN char *pCmdLine, IN bool fHasProgName);
-
-/*
- *  ======== UTIL_Exit ========
- *  Purpose:
- *      Discontinue usage of module; free resources when reference count
- *      reaches 0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      UTIL initialized.
- *  Ensures:
- *      Resources used by module are freed when cRef reaches zero.
- */
-	extern inline void UTIL_Exit(void)
-	{
-	}
-/*
- *  ======== UTIL_GetSysInfo ========
- *  Purpose:
- *      This function return platform specific system information.
- *
- *  Parameters:
- *      pSysInfo  - address to store the system information.
- *  Returns:
- *      DSP_SOK
- *      S_FAIL
- *  Requires:
- *      UTIL initialized.
- *      pSysInfo != NULL
- *  Ensures:
- */
-	extern DSP_STATUS UTIL_GetSysInfo(OUT struct UTIL_SYSINFO *pSysInfo);
-
-/*
- *  ======== UTIL_Init ========
- *  Purpose:
- *      Initializes private state of UTIL module.
- *  Parameters:
- *  Returns:
- *      TRUE if success, else FALSE.
- *  Requires:
- *  Ensures:
- *      UTIL initialized.
- */
-	extern inline bool UTIL_Init(void)
-	{
-		return true;
-	}
-
-#endif				/* _UTIL_H */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/uuidutil.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/uuidutil.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/uuidutil.h	2011-10-11 13:50:58.271536879 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/uuidutil.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This file contains the specification of UUID helper functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,61 +16,47 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== uuidutil.h ========
- *  Description:
- *      This file contains the specification of UUID helper functions.
- *
- *! Revision History
- *! ================
- *! 09-Nov-2000 kc: Modified description of UUID utility functions.
- *! 29-Sep-2000 kc: Appended "UUID_" prefix to UUID helper functions.
- *! 10-Aug-2000 kc: Created.
- *!
- */
-
 #ifndef UUIDUTIL_
 #define UUIDUTIL_
 
 #define MAXUUIDLEN  37
 
 /*
- *  ======== UUID_UuidToString ========
+ *  ======== uuid_uuid_to_string ========
  *  Purpose:
- *      Converts a DSP_UUID to an ANSI string.
+ *      Converts a dsp_uuid to an ANSI string.
  *  Parameters:
- *      pUuid:      Pointer to a DSP_UUID object.
+ *      uuid_obj:      Pointer to a dsp_uuid object.
  *      pszUuid:    Pointer to a buffer to receive a NULL-terminated UUID
  *                  string.
  *      size:	    Maximum size of the pszUuid string.
  *  Returns:
  *  Requires:
- *      pUuid & pszUuid are non-NULL values.
+ *      uuid_obj & pszUuid are non-NULL values.
  *  Ensures:
  *      Lenghth of pszUuid is less than MAXUUIDLEN.
  *  Details:
  *      UUID string limit currently set at MAXUUIDLEN.
  */
-	void UUID_UuidToString(IN struct DSP_UUID *pUuid, OUT char *pszUuid,
-			       s32 size);
+void uuid_uuid_to_string(IN struct dsp_uuid *uuid_obj, OUT char *pszUuid,
+			 s32 size);
 
 /*
- *  ======== UUID_UuidFromString ========
+ *  ======== uuid_uuid_from_string ========
  *  Purpose:
- *      Converts an ANSI string to a DSP_UUID.
+ *      Converts an ANSI string to a dsp_uuid.
  *  Parameters:
- *      pszUuid:    Pointer to a string that represents a DSP_UUID object.
- *      pUuid:      Pointer to a DSP_UUID object.
+ *      pszUuid:    Pointer to a string that represents a dsp_uuid object.
+ *      uuid_obj:      Pointer to a dsp_uuid object.
  *  Returns:
  *  Requires:
- *      pUuid & pszUuid are non-NULL values.
+ *      uuid_obj & pszUuid are non-NULL values.
  *  Ensures:
  *  Details:
  *      We assume the string representation of a UUID has the following format:
  *      "12345678_1234_1234_1234_123456789abc".
  */
-	extern void UUID_UuidFromString(IN char *pszUuid,
-					OUT struct DSP_UUID *pUuid);
+extern void uuid_uuid_from_string(IN char *pszUuid,
+				  OUT struct dsp_uuid *uuid_obj);
 
-#endif				/* UUIDUTIL_ */
+#endif /* UUIDUTIL_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wcd.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wcd.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wcd.h	2011-10-11 13:50:58.271536879 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wcd.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,18 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Bridge class driver library functions, object definitions, and
+ * return error/status codes.  To be included by Bridge mini drivers.
+ *
+ * Notes:
+ *   Bridge Class Driver services exported to WMD's are initialized by the
+ *   WCD on behalf of the WMD.  WMD's must not call module Init/Exit
+ *   functions.
+ *
+ *   To ensure WMD binary compatibility across different platforms,
+ *   for the same processor, a WMD must restrict its usage of system
+ *   services to those exported by the 'Bridge class library.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,48 +26,11 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== wcd.h ========
- *  Description:
- *      'Bridge class driver library functions, object definitions, and
- *      return error/status codes.  To be included by 'Bridge mini drivers.
- *
- *  Public Functions:
- *      See mem.h and dbg.h.
- *
- *  Notes:
- *      'Bridge Class Driver services exported to WMD's are initialized by the
- *      WCD on behalf of the WMD.  WMD's must not call module Init/Exit
- *      functions.
- *
- *      To ensure WMD binary compatibility across different platforms,
- *      for the same processor, a WMD must restrict its usage of system
- *      services to those exported by the 'Bridge class library.
- *
- *! Revision History:
- *! ================
- *! 07-Jun-2000 jeh Added dev.h
- *! 01-Nov-1999 ag: #WINCE# WCD_MAJOR_VERSION=8 & WCD_MINOR_VERSION=0 to match
- *!		    dll stamps.
- *!                 0.80 - 0.89 Alpha, 0.90 - 0.99 Beta, 1.00 - 1.10 FCS.
- *! 17-Sep-1997 gp: Changed size of CFG_HOSTRES structure; and ISR_Install API;
- *!                 Changed WCD_MINOR_VERSION 3 -> 4.
- *! 15-Sep-1997 gp: Moved WCD_(Un)registerMinidriver to drv.
- *! 25-Jul-1997 cr: Added WCD_UnregisterMinidriver.
- *! 22-Jul-1997 cr: Added WCD_RegisterMinidriver, WCD_MINOR_VERSION 2 -> 3.
- *! 12-Nov-1996 gp: Defined port io macros.
- *! 07-Nov-1996 gp: Updated for code review.
- *! 16-Jul-1996 gp: Added CHNL fxns; updated WCD lib version to 2.
- *! 10-May-1996 gp: Separated WMD def.s' into wmd.h.
- *! 03-May-1996 gp: Created.
- */
-
 #ifndef WCD_
 #define WCD_
 
-/* This WCD Library Version:  */
+/* This WCD Library Version: */
 #define WCD_MAJOR_VERSION   (u32)8	/* .8x - Alpha, .9x - Beta, 1.x FCS */
 #define WCD_MINOR_VERSION   (u32)0
 
-#endif				/* WCD_ */
+#endif /* WCD_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wcdioctl.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wcdioctl.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wcdioctl.h	2011-10-11 13:50:58.289124764 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wcdioctl.h	2011-10-17 20:54:16.392039000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Contains structures and commands that are used for interaction
+ * between the DDSP API and class driver.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,55 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== wcdioctl.h ========
- *  Purpose:
- *      Contains structures and commands that are used for interaction
- *      between the DDSP API and class driver.
- *
- *! Revision History
- *! ================
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping structs & offsets
- *! 15-Oct-2002 kc  Updated definitions for private PERF module.
- *! 16-Aug-2002 map Added ARGS_MGR_REGISTEROBJECT & ARGS_MGR_UNREGISTEROBJECT
- *!		 Added CMD_MGR_REGISTEROBJECT_OFFSET &
- *!		 CMD_MGR_UNREGISTEROBJECT_OFFSET
- *! 15-Jan-2002 ag  Added actaul bufSize to ARGS_STRM_[RECLAIM][ISSUE].
- *! 15-Nov-2001 ag  change to STRMINFO in ARGS_STRM_GETINFO.
- *! 11-Sep-2001 ag  ARGS_CMM_GETHANDLE defn uses DSP_HPROCESSOR.
- *! 23-Apr-2001 jeh Added pStatus to NODE_TERMINATE args.
- *! 13-Feb-2001 kc  DSP/BIOS Bridge name updates.
- *! 22-Nov-2000 kc: Added CMD_MGR_GETPERF_DATA_OFFSET for acquiring PERF stats.
- *! 27-Oct-2000 jeh Added timeouts to NODE_GETMESSAGE, NODE_PUTMESSAGE args.
- *!		 Removed NODE_GETMESSAGESTRM args.
- *! 11-Oct-2000 ag: Added SM mgr(CMM) args.
- *! 27-Sep-2000 jeh Removed struct DSP_BUFFERATTR param from
- *!		    ARGS_STRM_ALLOCATEBUFFER.
- *! 25-Sep-2000 rr: Updated to Version 0.9
- *! 07-Sep-2000 jeh Changed HANDLE to DSP_HNOTIFICATION in RegisterNotify args.
- *!		 Added DSP_STRMATTR to DSPNode_Connect args.
- *! 04-Aug-2000 rr: MEM and UTIL added to RM.
- *! 27-Jul-2000 rr: NODE, MGR,STRM and PROC added
- *! 27-Jun-2000 rr: Modifed to Use either PM or DSP/BIOS Bridge
- *!		 IFDEF to build for PM or DSP/BIOS Bridge
- *! 28-Jan-2000 rr: NT_CMD_FROM_OFFSET moved out to dsptrap.h
- *! 24-Jan-2000 rr: Merged with Scott's code.
- *! 21-Jan-2000 sg: In ARGS_CHNL_GETMODE changed mode to be u32 to be
- *!		 consistent with chnldefs.h.
- *! 11-Jan-2000 rr: CMD_CFG_GETCDVERSION_OFFSET added.
- *! 12-Nov-1999 rr: CMD_BRD_MONITOR_OFFSET added
- *! 09-Nov-1999 kc: Added MEMRY and enabled CMD_BRD_IOCTL_OFFSET.
- *! 05-Nov-1999 ag: Added CHNL.
- *! 02-Nov-1999 kc: Removed field from ARGS_UTIL_TESTDLL.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 08-Oct-1999 rr: Util control offsets added.
- *! 13-Sep-1999 kc: Added ARGS_UTIL_TESTDLL for PM test infrastructure.
- *! 19-Aug-1999 rr: Created from WSX. Minimal Implementaion of BRD_Start and BRD
- *!		 and BRD_Stop. IOCTL Offsets and CTRL Code.
- */
-
 #ifndef WCDIOCTL_
 #define WCDIOCTL_
 
@@ -75,445 +29,494 @@
 
 	/* MGR Module */
 	struct {
-		u32 uNode;
-		struct DSP_NDBPROPS __user *pNDBProps;
-		u32 uNDBPropsSize;
-		u32 __user *puNumNodes;
-	} ARGS_MGR_ENUMNODE_INFO;
+		u32 node_id;
+		struct dsp_ndbprops __user *pndb_props;
+		u32 undb_props_size;
+		u32 __user *pu_num_nodes;
+	} args_mgr_enumnode_info;
 
 	struct {
-		u32 uProcessor;
-		struct DSP_PROCESSORINFO __user *pProcessorInfo;
-		u32 uProcessorInfoSize;
-		u32 __user *puNumProcs;
-	} ARGS_MGR_ENUMPROC_INFO;
+		u32 processor_id;
+		struct dsp_processorinfo __user *processor_info;
+		u32 processor_info_size;
+		u32 __user *pu_num_procs;
+	} args_mgr_enumproc_info;
 
 	struct {
-		struct DSP_UUID *pUuid;
-		enum DSP_DCDOBJTYPE objType;
-		char *pszPathName;
-	} ARGS_MGR_REGISTEROBJECT;
+		struct dsp_uuid *uuid_obj;
+		enum dsp_dcdobjtype obj_type;
+		char *psz_path_name;
+	} args_mgr_registerobject;
 
 	struct {
-		struct DSP_UUID *pUuid;
-		enum DSP_DCDOBJTYPE objType;
-	} ARGS_MGR_UNREGISTEROBJECT;
+		struct dsp_uuid *uuid_obj;
+		enum dsp_dcdobjtype obj_type;
+	} args_mgr_unregisterobject;
 
 	struct {
-		struct DSP_NOTIFICATION  __user*__user *aNotifications;
-		u32 uCount;
-		u32 __user *puIndex;
-		u32 uTimeout;
-	} ARGS_MGR_WAIT;
+		struct dsp_notification __user *__user *anotifications;
+		u32 count;
+		u32 __user *pu_index;
+		u32 utimeout;
+	} args_mgr_wait;
 
 	/* PROC Module */
 	struct {
-		u32 uProcessor;
-		struct DSP_PROCESSORATTRIN __user *pAttrIn;
-		DSP_HPROCESSOR __user *phProcessor;
-	} ARGS_PROC_ATTACH;
+		u32 processor_id;
+		struct dsp_processorattrin __user *attr_in;
+		void *__user *ph_processor;
+	} args_proc_attach;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-		u32 dwCmd;
-		struct DSP_CBDATA __user *pArgs;
-	} ARGS_PROC_CTRL;
+		void *hprocessor;
+		u32 dw_cmd;
+		struct dsp_cbdata __user *pargs;
+	} args_proc_ctrl;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-	} ARGS_PROC_DETACH;
+		void *hprocessor;
+	} args_proc_detach;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-		DSP_HNODE __user *aNodeTab;
-		u32 uNodeTabSize;
-		u32 __user *puNumNodes;
-		u32 __user *puAllocated;
-	} ARGS_PROC_ENUMNODE_INFO;
+		void *hprocessor;
+		void *__user *node_tab;
+		u32 node_tab_size;
+		u32 __user *pu_num_nodes;
+		u32 __user *pu_allocated;
+	} args_proc_enumnode_info;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-		u32 uResourceType;
-		struct DSP_RESOURCEINFO *pResourceInfo;
-		u32 uResourceInfoSize;
-	} ARGS_PROC_ENUMRESOURCES;
+		void *hprocessor;
+		u32 resource_type;
+		struct dsp_resourceinfo *resource_info;
+		u32 resource_info_size;
+	} args_proc_enumresources;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-		struct DSP_PROCESSORSTATE __user *pProcStatus;
-		u32 uStateInfoSize;
-	} ARGS_PROC_GETSTATE;
+		void *hprocessor;
+		struct dsp_processorstate __user *proc_state_obj;
+		u32 state_info_size;
+	} args_proc_getstate;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-		u8 __user *pBuf;
-
-	#ifndef RES_CLEANUP_DISABLE
-	    u8 __user *pSize;
-    #endif
-		u32 uMaxSize;
-	} ARGS_PROC_GETTRACE;
+		void *hprocessor;
+		u8 __user *pbuf;
+		u8 __user *psize;
+		u32 max_size;
+	} args_proc_gettrace;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-		s32 iArgc;
-		char __user*__user *aArgv;
-		char *__user *aEnvp;
-	} ARGS_PROC_LOAD;
+		void *hprocessor;
+		s32 argc_index;
+		char __user *__user *user_args;
+		char *__user *user_envp;
+	} args_proc_load;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-		u32 uEventMask;
-		u32 uNotifyType;
-		struct DSP_NOTIFICATION __user *hNotification;
-	} ARGS_PROC_REGISTER_NOTIFY;
+		void *hprocessor;
+		u32 event_mask;
+		u32 notify_type;
+		struct dsp_notification __user *hnotification;
+	} args_proc_register_notify;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-	} ARGS_PROC_START;
+		void *hprocessor;
+	} args_proc_start;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-		u32 ulSize;
-		void *__user *ppRsvAddr;
-	} ARGS_PROC_RSVMEM;
+		void *hprocessor;
+		u32 ul_size;
+		void *__user *pp_rsv_addr;
+	} args_proc_rsvmem;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-		u32 ulSize;
-		void *pRsvAddr;
-	} ARGS_PROC_UNRSVMEM;
+		void *hprocessor;
+		u32 ul_size;
+		void *prsv_addr;
+	} args_proc_unrsvmem;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-		void *pMpuAddr;
-		u32 ulSize;
-		void *pReqAddr;
-		void *__user *ppMapAddr;
-		u32 ulMapAttr;
-	} ARGS_PROC_MAPMEM;
+		void *hprocessor;
+		void *pmpu_addr;
+		u32 ul_size;
+		void *req_addr;
+		void *__user *pp_map_addr;
+		u32 ul_map_attr;
+	} args_proc_mapmem;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-		u32 ulSize;
-		void *pMapAddr;
-	} ARGS_PROC_UNMAPMEM;
+		void *hprocessor;
+		u32 ul_size;
+		void *map_addr;
+	} args_proc_unmapmem;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-		void *pMpuAddr;
-		u32 ulSize;
-		u32 ulFlags;
-	} ARGS_PROC_FLUSHMEMORY;
+		void *hprocessor;
+		void *pmpu_addr;
+		u32 ul_size;
+		u32 ul_flags;
+	} args_proc_flushmemory;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-	} ARGS_PROC_STOP;
+		void *hprocessor;
+	} args_proc_stop;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-		void *pMpuAddr;
-		u32 ulSize;
-	} ARGS_PROC_INVALIDATEMEMORY;
-
+		void *hprocessor;
+		void *pmpu_addr;
+		u32 ul_size;
+	} args_proc_invalidatememory;
 
 	/* NODE Module */
 	struct {
-		DSP_HPROCESSOR hProcessor;
-		struct DSP_UUID __user *pNodeID;
-		struct DSP_CBDATA __user *pArgs;
-		struct DSP_NODEATTRIN __user *pAttrIn;
-		DSP_HNODE __user *phNode;
-	} ARGS_NODE_ALLOCATE;
+		void *hprocessor;
+		struct dsp_uuid __user *node_id_ptr;
+		struct dsp_cbdata __user *pargs;
+		struct dsp_nodeattrin __user *attr_in;
+		void *__user *ph_node;
+	} args_node_allocate;
 
 	struct {
-		DSP_HNODE hNode;
-		u32 uSize;
-		struct DSP_BUFFERATTR __user *pAttr;
-		u8 *__user *pBuffer;
-	} ARGS_NODE_ALLOCMSGBUF;
+		void *hnode;
+		u32 usize;
+		struct dsp_bufferattr __user *pattr;
+		u8 *__user *pbuffer;
+	} args_node_allocmsgbuf;
 
 	struct {
-		DSP_HNODE hNode;
-		s32 iPriority;
-	} ARGS_NODE_CHANGEPRIORITY;
+		void *hnode;
+		s32 prio;
+	} args_node_changepriority;
 
 	struct {
-		DSP_HNODE hNode;
-		u32 uStream;
-		DSP_HNODE hOtherNode;
-		u32 uOtherStream;
-		struct DSP_STRMATTR __user *pAttrs;
-		struct DSP_CBDATA __user *pConnParam;
-	} ARGS_NODE_CONNECT;
+		void *hnode;
+		u32 stream_id;
+		void *other_node;
+		u32 other_stream;
+		struct dsp_strmattr __user *pattrs;
+		struct dsp_cbdata __user *conn_param;
+	} args_node_connect;
 
 	struct {
-		DSP_HNODE hNode;
-	} ARGS_NODE_CREATE;
+		void *hnode;
+	} args_node_create;
 
 	struct {
-		DSP_HNODE hNode;
-	} ARGS_NODE_DELETE;
+		void *hnode;
+	} args_node_delete;
 
 	struct {
-		DSP_HNODE hNode;
-		struct DSP_BUFFERATTR __user *pAttr;
-		u8 *pBuffer;
-	} ARGS_NODE_FREEMSGBUF;
+		void *hnode;
+		struct dsp_bufferattr __user *pattr;
+		u8 *pbuffer;
+	} args_node_freemsgbuf;
 
 	struct {
-		DSP_HNODE hNode;
-		struct DSP_NODEATTR __user *pAttr;
-		u32 uAttrSize;
-	} ARGS_NODE_GETATTR;
+		void *hnode;
+		struct dsp_nodeattr __user *pattr;
+		u32 attr_size;
+	} args_node_getattr;
 
 	struct {
-		DSP_HNODE hNode;
-		struct DSP_MSG __user *pMessage;
-		u32 uTimeout;
-	} ARGS_NODE_GETMESSAGE;
+		void *hnode;
+		struct dsp_msg __user *message;
+		u32 utimeout;
+	} args_node_getmessage;
 
 	struct {
-		DSP_HNODE hNode;
-	} ARGS_NODE_PAUSE;
+		void *hnode;
+	} args_node_pause;
 
 	struct {
-		DSP_HNODE hNode;
-		struct DSP_MSG __user *pMessage;
-		u32 uTimeout;
-	} ARGS_NODE_PUTMESSAGE;
+		void *hnode;
+		struct dsp_msg __user *message;
+		u32 utimeout;
+	} args_node_putmessage;
 
 	struct {
-		DSP_HNODE hNode;
-		u32 uEventMask;
-		u32 uNotifyType;
-		struct DSP_NOTIFICATION __user *hNotification;
-	} ARGS_NODE_REGISTERNOTIFY;
+		void *hnode;
+		u32 event_mask;
+		u32 notify_type;
+		struct dsp_notification __user *hnotification;
+	} args_node_registernotify;
 
 	struct {
-		DSP_HNODE hNode;
-	} ARGS_NODE_RUN;
+		void *hnode;
+	} args_node_run;
 
 	struct {
-		DSP_HNODE hNode;
-		DSP_STATUS __user *pStatus;
-	} ARGS_NODE_TERMINATE;
+		void *hnode;
+		dsp_status __user *pstatus;
+	} args_node_terminate;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-		struct DSP_UUID __user *pNodeID;
-		struct DSP_NDBPROPS __user *pNodeProps;
-	} ARGS_NODE_GETUUIDPROPS;
+		void *hprocessor;
+		struct dsp_uuid __user *node_id_ptr;
+		struct dsp_ndbprops __user *node_props;
+	} args_node_getuuidprops;
 
 	/* STRM module */
 
 	struct {
-		DSP_HSTREAM hStream;
-		u32 uSize;
-		u8 *__user *apBuffer;
-		u32 uNumBufs;
-	} ARGS_STRM_ALLOCATEBUFFER;
+		void *hstream;
+		u32 usize;
+		u8 *__user *ap_buffer;
+		u32 num_bufs;
+	} args_strm_allocatebuffer;
 
 	struct {
-		DSP_HSTREAM hStream;
-	} ARGS_STRM_CLOSE;
+		void *hstream;
+	} args_strm_close;
 
 	struct {
-		DSP_HSTREAM hStream;
-		u8 *__user *apBuffer;
-		u32 uNumBufs;
-	} ARGS_STRM_FREEBUFFER;
+		void *hstream;
+		u8 *__user *ap_buffer;
+		u32 num_bufs;
+	} args_strm_freebuffer;
 
 	struct {
-		DSP_HSTREAM hStream;
-		HANDLE *phEvent;
-	} ARGS_STRM_GETEVENTHANDLE;
+		void *hstream;
+		bhandle *ph_event;
+	} args_strm_geteventhandle;
 
 	struct {
-		DSP_HSTREAM hStream;
-		struct STRM_INFO __user *pStreamInfo;
-		u32 uStreamInfoSize;
-	} ARGS_STRM_GETINFO;
+		void *hstream;
+		struct stream_info __user *stream_info;
+		u32 stream_info_size;
+	} args_strm_getinfo;
 
 	struct {
-		DSP_HSTREAM hStream;
-		bool bFlush;
-	} ARGS_STRM_IDLE;
+		void *hstream;
+		bool flush_flag;
+	} args_strm_idle;
 
 	struct {
-		DSP_HSTREAM hStream;
-		u8 *pBuffer;
-		u32 dwBytes;
-		u32 dwBufSize;
-		u32 dwArg;
-	} ARGS_STRM_ISSUE;
+		void *hstream;
+		u8 *pbuffer;
+		u32 dw_bytes;
+		u32 dw_buf_size;
+		u32 dw_arg;
+	} args_strm_issue;
 
 	struct {
-		DSP_HNODE hNode;
-		u32 uDirection;
-		u32 uIndex;
-		struct STRM_ATTR __user *pAttrIn;
-		DSP_HSTREAM __user *phStream;
-	} ARGS_STRM_OPEN;
+		void *hnode;
+		u32 direction;
+		u32 index;
+		struct strm_attr __user *attr_in;
+		void *__user *ph_stream;
+	} args_strm_open;
 
 	struct {
-		DSP_HSTREAM hStream;
-		u8 *__user *pBufPtr;
-		u32 __user *pBytes;
-		u32 __user *pBufSize;
-		u32 __user *pdwArg;
-	} ARGS_STRM_RECLAIM;
+		void *hstream;
+		u8 *__user *buf_ptr;
+		u32 __user *bytes;
+		u32 __user *buf_size_ptr;
+		u32 __user *pdw_arg;
+	} args_strm_reclaim;
 
 	struct {
-		DSP_HSTREAM hStream;
-		u32 uEventMask;
-		u32 uNotifyType;
-		struct DSP_NOTIFICATION __user *hNotification;
-	} ARGS_STRM_REGISTERNOTIFY;
+		void *hstream;
+		u32 event_mask;
+		u32 notify_type;
+		struct dsp_notification __user *hnotification;
+	} args_strm_registernotify;
 
 	struct {
-		DSP_HSTREAM __user *aStreamTab;
-		u32 nStreams;
-		u32 __user *pMask;
-		u32 uTimeout;
-	} ARGS_STRM_SELECT;
+		void *__user *stream_tab;
+		u32 strm_num;
+		u32 __user *pmask;
+		u32 utimeout;
+	} args_strm_select;
 
 	/* CMM Module */
 	struct {
-		struct CMM_OBJECT *hCmmMgr;
-		u32 uSize;
-		struct CMM_ATTRS *pAttrs;
-		OUT void **ppBufVA;
-	} ARGS_CMM_ALLOCBUF;
+		struct cmm_object *hcmm_mgr;
+		u32 usize;
+		struct cmm_attrs *pattrs;
+		OUT void **pp_buf_va;
+	} args_cmm_allocbuf;
 
 	struct {
-		struct CMM_OBJECT *hCmmMgr;
-		void *pBufPA;
-		u32 ulSegId;
-	} ARGS_CMM_FREEBUF;
+		struct cmm_object *hcmm_mgr;
+		void *buf_pa;
+		u32 ul_seg_id;
+	} args_cmm_freebuf;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-		struct CMM_OBJECT *__user *phCmmMgr;
-	} ARGS_CMM_GETHANDLE;
+		void *hprocessor;
+		struct cmm_object *__user *ph_cmm_mgr;
+	} args_cmm_gethandle;
 
 	struct {
-		struct CMM_OBJECT *hCmmMgr;
-		struct CMM_INFO __user *pCmmInfo;
-	} ARGS_CMM_GETINFO;
+		struct cmm_object *hcmm_mgr;
+		struct cmm_info __user *cmm_info_obj;
+	} args_cmm_getinfo;
 
 	/* MEM Module */
 	struct {
-		u32 cBytes;
-		enum MEM_POOLATTRS type;
-		void *pMem;
-	} ARGS_MEM_ALLOC;
+		u32 byte_size;
+		enum mem_poolattrs type;
+		void *mem;
+	} args_mem_alloc;
 
 	struct {
-		u32 cBytes;
-		enum MEM_POOLATTRS type;
-		void *pMem;
-	} ARGS_MEM_CALLOC;
+		u32 byte_size;
+		enum mem_poolattrs type;
+		void *mem;
+	} args_mem_calloc;
 
 	struct {
-		void *pMem;
-	} ARGS_MEM_FREE;
+		void *mem;
+	} args_mem_free;
 
 	struct {
-		void *pBuffer;
-		u32 cSize;
-		void *pLockedBuffer;
-	} ARGS_MEM_PAGELOCK;
+		void *pbuffer;
+		u32 size;
+		void *locked_buffer;
+	} args_mem_pagelock;
 
 	struct {
-		void *pBuffer;
-		u32 cSize;
-	} ARGS_MEM_PAGEUNLOCK;
+		void *pbuffer;
+		u32 size;
+	} args_mem_pageunlock;
 
 	/* UTIL module */
 	struct {
-		s32 cArgc;
-		char **ppArgv;
-	} ARGS_UTIL_TESTDLL;
-} ;
-
-#define CMD_BASE		    1
-
-/* MGR module offsets */
-#define CMD_MGR_BASE_OFFSET	     CMD_BASE
-#define CMD_MGR_ENUMNODE_INFO_OFFSET    (CMD_MGR_BASE_OFFSET + 0)
-#define CMD_MGR_ENUMPROC_INFO_OFFSET    (CMD_MGR_BASE_OFFSET + 1)
-#define CMD_MGR_REGISTEROBJECT_OFFSET   (CMD_MGR_BASE_OFFSET + 2)
-#define CMD_MGR_UNREGISTEROBJECT_OFFSET (CMD_MGR_BASE_OFFSET + 3)
-#define CMD_MGR_WAIT_OFFSET	     (CMD_MGR_BASE_OFFSET + 4)
-
-#ifndef RES_CLEANUP_DISABLE
-#define CMD_MGR_RESOUCES_OFFSET	 (CMD_MGR_BASE_OFFSET + 5)
-#define CMD_MGR_END_OFFSET	      CMD_MGR_RESOUCES_OFFSET
-#else
-#define CMD_MGR_END_OFFSET	      CMD_MGR_WAIT_OFFSET
-#endif
-
-#define CMD_PROC_BASE_OFFSET	    (CMD_MGR_END_OFFSET + 1)
-#define CMD_PROC_ATTACH_OFFSET	  (CMD_PROC_BASE_OFFSET + 0)
-#define CMD_PROC_CTRL_OFFSET	    (CMD_PROC_BASE_OFFSET + 1)
-#define CMD_PROC_DETACH_OFFSET	  (CMD_PROC_BASE_OFFSET + 2)
-#define CMD_PROC_ENUMNODE_OFFSET	(CMD_PROC_BASE_OFFSET + 3)
-#define CMD_PROC_ENUMRESOURCES_OFFSET   (CMD_PROC_BASE_OFFSET + 4)
-#define CMD_PROC_GETSTATE_OFFSET	(CMD_PROC_BASE_OFFSET + 5)
-#define CMD_PROC_GETTRACE_OFFSET	(CMD_PROC_BASE_OFFSET + 6)
-#define CMD_PROC_LOAD_OFFSET	    (CMD_PROC_BASE_OFFSET + 7)
-#define CMD_PROC_REGISTERNOTIFY_OFFSET  (CMD_PROC_BASE_OFFSET + 8)
-#define CMD_PROC_START_OFFSET	   (CMD_PROC_BASE_OFFSET + 9)
-#define CMD_PROC_RSVMEM_OFFSET	  (CMD_PROC_BASE_OFFSET + 10)
-#define CMD_PROC_UNRSVMEM_OFFSET	(CMD_PROC_BASE_OFFSET + 11)
-#define CMD_PROC_MAPMEM_OFFSET	  (CMD_PROC_BASE_OFFSET + 12)
-#define CMD_PROC_UNMAPMEM_OFFSET	(CMD_PROC_BASE_OFFSET + 13)
-#define CMD_PROC_FLUSHMEMORY_OFFSET      (CMD_PROC_BASE_OFFSET + 14)
-#define CMD_PROC_STOP_OFFSET	    (CMD_PROC_BASE_OFFSET + 15)
-#define CMD_PROC_INVALIDATEMEMORY_OFFSET (CMD_PROC_BASE_OFFSET + 16)
-#define CMD_PROC_END_OFFSET	     CMD_PROC_INVALIDATEMEMORY_OFFSET
-
-
-#define CMD_NODE_BASE_OFFSET	    (CMD_PROC_END_OFFSET + 1)
-#define CMD_NODE_ALLOCATE_OFFSET	(CMD_NODE_BASE_OFFSET + 0)
-#define CMD_NODE_ALLOCMSGBUF_OFFSET     (CMD_NODE_BASE_OFFSET + 1)
-#define CMD_NODE_CHANGEPRIORITY_OFFSET  (CMD_NODE_BASE_OFFSET + 2)
-#define CMD_NODE_CONNECT_OFFSET	 (CMD_NODE_BASE_OFFSET + 3)
-#define CMD_NODE_CREATE_OFFSET	  (CMD_NODE_BASE_OFFSET + 4)
-#define CMD_NODE_DELETE_OFFSET	  (CMD_NODE_BASE_OFFSET + 5)
-#define CMD_NODE_FREEMSGBUF_OFFSET      (CMD_NODE_BASE_OFFSET + 6)
-#define CMD_NODE_GETATTR_OFFSET	 (CMD_NODE_BASE_OFFSET + 7)
-#define CMD_NODE_GETMESSAGE_OFFSET      (CMD_NODE_BASE_OFFSET + 8)
-#define CMD_NODE_PAUSE_OFFSET	   (CMD_NODE_BASE_OFFSET + 9)
-#define CMD_NODE_PUTMESSAGE_OFFSET      (CMD_NODE_BASE_OFFSET + 10)
-#define CMD_NODE_REGISTERNOTIFY_OFFSET  (CMD_NODE_BASE_OFFSET + 11)
-#define CMD_NODE_RUN_OFFSET	     (CMD_NODE_BASE_OFFSET + 12)
-#define CMD_NODE_TERMINATE_OFFSET       (CMD_NODE_BASE_OFFSET + 13)
-#define CMD_NODE_GETUUIDPROPS_OFFSET    (CMD_NODE_BASE_OFFSET + 14)
-#define CMD_NODE_END_OFFSET	     CMD_NODE_GETUUIDPROPS_OFFSET
-
-#define CMD_STRM_BASE_OFFSET	    (CMD_NODE_END_OFFSET + 1)
-#define CMD_STRM_ALLOCATEBUFFER_OFFSET  (CMD_STRM_BASE_OFFSET + 0)
-#define CMD_STRM_CLOSE_OFFSET	   (CMD_STRM_BASE_OFFSET + 1)
-#define CMD_STRM_FREEBUFFER_OFFSET      (CMD_STRM_BASE_OFFSET + 2)
-#define CMD_STRM_GETEVENTHANDLE_OFFSET  (CMD_STRM_BASE_OFFSET + 3)
-#define CMD_STRM_GETINFO_OFFSET	 (CMD_STRM_BASE_OFFSET + 4)
-#define CMD_STRM_IDLE_OFFSET	    (CMD_STRM_BASE_OFFSET + 5)
-#define CMD_STRM_ISSUE_OFFSET	   (CMD_STRM_BASE_OFFSET + 6)
-#define CMD_STRM_OPEN_OFFSET	    (CMD_STRM_BASE_OFFSET + 7)
-#define CMD_STRM_RECLAIM_OFFSET	 (CMD_STRM_BASE_OFFSET + 8)
-#define CMD_STRM_REGISTERNOTIFY_OFFSET  (CMD_STRM_BASE_OFFSET + 9)
-#define CMD_STRM_SELECT_OFFSET	  (CMD_STRM_BASE_OFFSET + 10)
-#define CMD_STRM_END_OFFSET	     CMD_STRM_SELECT_OFFSET
-
-/* Communication Memory Manager (UCMM) */
-#define CMD_CMM_BASE_OFFSET	     (CMD_STRM_END_OFFSET + 1)
-#define CMD_CMM_ALLOCBUF_OFFSET	 (CMD_CMM_BASE_OFFSET + 0)
-#define CMD_CMM_FREEBUF_OFFSET	  (CMD_CMM_BASE_OFFSET + 1)
-#define CMD_CMM_GETHANDLE_OFFSET	(CMD_CMM_BASE_OFFSET + 2)
-#define CMD_CMM_GETINFO_OFFSET	  (CMD_CMM_BASE_OFFSET + 3)
-#define CMD_CMM_END_OFFSET	      CMD_CMM_GETINFO_OFFSET
+		s32 util_argc;
+		char **pp_argv;
+	} args_util_testdll;
+};
+
+/*
+ * Dspbridge Ioctl numbering scheme
+ *
+ *    7                           0
+ *  ---------------------------------
+ *  |  Module   |   Ioctl Number    |
+ *  ---------------------------------
+ *  | x | x | x | 0 | 0 | 0 | 0 | 0 |
+ *  ---------------------------------
+ */
+
+/* Ioctl driver identifier */
+#define DB		0xDB
+/*
+ * Following are used to distinguish between module ioctls, this is needed
+ * in case new ioctls are introduced.
+ */
+#define DB_MODULE_MASK		0xE0
+#define DB_IOC_MASK		0x1F
+#define DB_MODULE_SHIFT		5
+
+#ifdef BRIDGE_NEW_API
+/* Ioctl module masks */
+#define DB_MGR		0x0
+#define DB_PROC		0x20
+#define DB_NODE		0x40
+#define DB_STRM		0x60
+#define DB_CMM		0x80
+
+
+/* Used to calculate the ioctl per dspbridge module */
+#define DB_IOC(module, num) \
+			(((module) & DB_MODULE_MASK) | ((num) & DB_IOC_MASK))
+/* Used to get dspbridge ioctl module */
+#define DB_GET_MODULE(cmd)	((cmd) & DB_MODULE_MASK)
+/* Used to get dspbridge ioctl number */
+#define DB_GET_IOC(cmd)		((cmd) & DB_IOC_MASK)
+
+#else /* NEW_API */
+/* Old api starts here */
+#define DB_MGR  1
+#define DB_PROC 7
+#define DB_NODE 24
+#define DB_STRM 39
+#define DB_CMM  50
+
+#define DB_MGR_NEW		0x0
+#define DB_PROC_NEW		0x20
+#define DB_NODE_NEW		0x40
+#define DB_STRM_NEW		0x60
+#define DB_CMM_NEW		0x80
+
+
+#define DB_IOC(module, num)	((module) + (num))
+
+#undef _IOR
+#undef _IOW
+#undef _IOWR
+
+#define _IOR(type, nr, size)	(nr)
+#define _IOW(type, nr, size)	(nr)
+#define _IOWR(type, nr, size)	(nr)
+/* End of IOCTL old API functions */
+#endif /* NEW_API */
+
+/* TODO: Remove deprecated and not implemented */
+
+/* MGR Module */
+#define MGR_ENUMNODE_INFO	_IOWR(DB, DB_IOC(DB_MGR, 0), unsigned long)
+#define MGR_ENUMPROC_INFO	_IOWR(DB, DB_IOC(DB_MGR, 1), unsigned long)
+#define MGR_REGISTEROBJECT	_IOWR(DB, DB_IOC(DB_MGR, 2), unsigned long)
+#define MGR_UNREGISTEROBJECT	_IOWR(DB, DB_IOC(DB_MGR, 3), unsigned long)
+#define MGR_WAIT		_IOWR(DB, DB_IOC(DB_MGR, 4), unsigned long)
+/* MGR_GET_PROC_RES Deprecated */
+#define MGR_GET_PROC_RES	_IOR(DB, DB_IOC(DB_MGR, 5), unsigned long)
+
+/* PROC Module */
+#define PROC_ATTACH		_IOWR(DB, DB_IOC(DB_PROC, 0), unsigned long)
+#define PROC_CTRL		_IOR(DB, DB_IOC(DB_PROC, 1), unsigned long)
+/* PROC_DETACH Deprecated */
+#define PROC_DETACH		_IOR(DB, DB_IOC(DB_PROC, 2), unsigned long)
+#define PROC_ENUMNODE		_IOWR(DB, DB_IOC(DB_PROC, 3), unsigned long)
+#define PROC_ENUMRESOURCES	_IOWR(DB, DB_IOC(DB_PROC, 4), unsigned long)
+#define PROC_GET_STATE		_IOWR(DB, DB_IOC(DB_PROC, 5), unsigned long)
+#define PROC_GET_TRACE		_IOWR(DB, DB_IOC(DB_PROC, 6), unsigned long)
+#define PROC_LOAD		_IOW(DB, DB_IOC(DB_PROC, 7), unsigned long)
+#define PROC_REGISTERNOTIFY	_IOWR(DB, DB_IOC(DB_PROC, 8), unsigned long)
+#define PROC_START		_IOW(DB, DB_IOC(DB_PROC, 9), unsigned long)
+#define PROC_RSVMEM		_IOWR(DB, DB_IOC(DB_PROC, 10), unsigned long)
+#define PROC_UNRSVMEM		_IOW(DB, DB_IOC(DB_PROC, 11), unsigned long)
+#define PROC_MAPMEM		_IOWR(DB, DB_IOC(DB_PROC, 12), unsigned long)
+#define PROC_UNMAPMEM		_IOR(DB, DB_IOC(DB_PROC, 13), unsigned long)
+#define PROC_FLUSHMEMORY	_IOW(DB, DB_IOC(DB_PROC, 14), unsigned long)
+#define PROC_STOP		_IOWR(DB, DB_IOC(DB_PROC, 15), unsigned long)
+#define PROC_INVALIDATEMEMORY	_IOW(DB, DB_IOC(DB_PROC, 16), unsigned long)
+
+/* NODE Module */
+#define NODE_ALLOCATE		_IOWR(DB, DB_IOC(DB_NODE, 0), unsigned long)
+#define NODE_ALLOCMSGBUF	_IOWR(DB, DB_IOC(DB_NODE, 1), unsigned long)
+#define NODE_CHANGEPRIORITY	_IOW(DB, DB_IOC(DB_NODE, 2), unsigned long)
+#define NODE_CONNECT		_IOW(DB, DB_IOC(DB_NODE, 3), unsigned long)
+#define NODE_CREATE		_IOW(DB, DB_IOC(DB_NODE, 4), unsigned long)
+#define NODE_DELETE		_IOW(DB, DB_IOC(DB_NODE, 5), unsigned long)
+#define NODE_FREEMSGBUF		_IOW(DB, DB_IOC(DB_NODE, 6), unsigned long)
+#define NODE_GETATTR		_IOWR(DB, DB_IOC(DB_NODE, 7), unsigned long)
+#define NODE_GETMESSAGE		_IOWR(DB, DB_IOC(DB_NODE, 8), unsigned long)
+#define NODE_PAUSE		_IOW(DB, DB_IOC(DB_NODE, 9), unsigned long)
+#define NODE_PUTMESSAGE		_IOW(DB, DB_IOC(DB_NODE, 10), unsigned long)
+#define NODE_REGISTERNOTIFY	_IOWR(DB, DB_IOC(DB_NODE, 11), unsigned long)
+#define NODE_RUN		_IOW(DB, DB_IOC(DB_NODE, 12), unsigned long)
+#define NODE_TERMINATE		_IOWR(DB, DB_IOC(DB_NODE, 13), unsigned long)
+#define NODE_GETUUIDPROPS	_IOWR(DB, DB_IOC(DB_NODE, 14), unsigned long)
+
+/* STRM Module */
+#define STRM_ALLOCATEBUFFER	_IOWR(DB, DB_IOC(DB_STRM, 0), unsigned long)
+#define STRM_CLOSE		_IOW(DB, DB_IOC(DB_STRM, 1), unsigned long)
+#define STRM_FREEBUFFER		_IOWR(DB, DB_IOC(DB_STRM, 2), unsigned long)
+#define STRM_GETEVENTHANDLE	_IO(DB, DB_IOC(DB_STRM, 3))	/* Not Impl'd */
+#define STRM_GETINFO		_IOWR(DB, DB_IOC(DB_STRM, 4), unsigned long)
+#define STRM_IDLE		_IOW(DB, DB_IOC(DB_STRM, 5), unsigned long)
+#define STRM_ISSUE		_IOW(DB, DB_IOC(DB_STRM, 6), unsigned long)
+#define STRM_OPEN		_IOWR(DB, DB_IOC(DB_STRM, 7), unsigned long)
+#define STRM_RECLAIM		_IOWR(DB, DB_IOC(DB_STRM, 8), unsigned long)
+#define STRM_REGISTERNOTIFY	_IOWR(DB, DB_IOC(DB_STRM, 9), unsigned long)
+#define STRM_SELECT		_IOWR(DB, DB_IOC(DB_STRM, 10), unsigned long)
+
+/* CMM Module */
+#define CMM_ALLOCBUF		_IO(DB, DB_IOC(DB_CMM, 0))	/* Not Impl'd */
+#define CMM_FREEBUF		_IO(DB, DB_IOC(DB_CMM, 1))	/* Not Impl'd */
+#define CMM_GETHANDLE		_IOR(DB, DB_IOC(DB_CMM, 2), unsigned long)
+#define CMM_GETINFO		_IOR(DB, DB_IOC(DB_CMM, 3), unsigned long)
 
-#define CMD_BASE_END_OFFSET	CMD_CMM_END_OFFSET
-#endif				/* WCDIOCTL_ */
+#endif /* WCDIOCTL_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wdt.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wdt.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wdt.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wdt.h	2011-08-19 18:42:46.000000000 +0100
@@ -0,0 +1,78 @@
+/*
+ * wdt.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * IO dispatcher for a shared memory channel driver.
+ *
+ * Copyright (C) 2010 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+#ifndef __DSP_WDT3_H_
+#define __DSP_WDT3_H_
+
+/* WDT defines */
+#define OMAP3_WDT3_ISR_OFFSET	0x0018
+
+
+/**
+ * struct dsp_wdt_setting - the basic dsp_wdt_setting structure
+ * @reg_base:	pointer to the base of the wdt registers
+ * @sm_wdt:	pointer to flags in shared memory
+ * @wdt3_tasklet	tasklet to manage wdt event
+ * @fclk		handle to wdt3 functional clock
+ * @iclk		handle to wdt3 interface clock
+ *
+ * This struct is used in the function to manage wdt3.
+ */
+
+struct dsp_wdt_setting {
+	void __iomem *reg_base;
+	struct shm *sm_wdt;
+	struct tasklet_struct wdt3_tasklet;
+	struct clk *fclk;
+	struct clk *iclk;
+};
+
+/**
+ * dsp_wdt_init() - initialize wdt3 module.
+ *
+ * This function initilize to wdt3 module, so that
+ * other wdt3 function can be used.
+ */
+int dsp_wdt_init(void);
+
+/**
+ * dsp_wdt_exit() - initialize wdt3 module.
+ *
+ * This function frees all resources allocated for wdt3 module.
+ */
+void dsp_wdt_exit(void);
+
+/**
+ * dsp_wdt_enable() - enable/disable wdt3
+ * @enable:	bool value to enable/disable wdt3
+ *
+ * This function enables or disables wdt3 base on @enable value.
+ *
+ */
+void dsp_wdt_enable(bool enable);
+
+/**
+ * dsp_wdt_sm_set() - store pointer to the share memory
+ * @data:		pointer to dspbridge share memory
+ *
+ * This function is used to pass a valid pointer to share memory,
+ * so that the flags can be set in order DSP side can read them.
+ *
+ */
+void dsp_wdt_sm_set(void *data);
+
+#endif
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wmdchnl.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wmdchnl.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wmdchnl.h	2011-10-11 13:50:58.970805887 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wmdchnl.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,13 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Declares the upper edge channel class library functions required by
+ * all WMD / WCD driver interface tables.  These functions are implemented
+ * by every class of WMD channel library.
+ *
+ * Notes:
+ *   The function comment headers reside in wmd.h.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,77 +21,52 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== wmdchnl.h ========
- *  Description:
- *      Declares the upper edge channel class library functions required by
- *      all WMD / WCD driver interface tables.  These functions are implemented
- *      by every class of WMD channel library.
- *
- *  Public Functions:
- *
- *  Notes:
- *      The function comment headers reside with the function typedefs in wmd.h.
- *
- *! Revision History:
- *! ================
- *! 07-Jan-2002 ag  Added cBufSize to WMD_CHNL_AddIOReq().
- *! 13-Oct-2000 jeh Added dwArg parameter to WMD_CHNL_AddIOReq(), added
- *!                 WMD_CHNL_Idle and WMD_CHNL_RegisterNotify for DSPStream
- *!                 support.
- *! 11-Jul-1996 gp: Created.
- */
-
 #ifndef WMDCHNL_
 #define WMDCHNL_
 
-	extern DSP_STATUS WMD_CHNL_Create(OUT struct CHNL_MGR **phChnlMgr,
-					  struct DEV_OBJECT *hDevObject,
-					  IN CONST struct CHNL_MGRATTRS
-					  *pMgrAttrs);
-
-	extern DSP_STATUS WMD_CHNL_Destroy(struct CHNL_MGR *hChnlMgr);
-
-	extern DSP_STATUS WMD_CHNL_Open(OUT struct CHNL_OBJECT **phChnl,
-					struct CHNL_MGR *hChnlMgr,
-					CHNL_MODE uMode,
-					u32 uChnlId,
-					CONST IN OPTIONAL struct CHNL_ATTRS
-					*pAttrs);
-
-	extern DSP_STATUS WMD_CHNL_Close(struct CHNL_OBJECT *hChnl);
-
-	extern DSP_STATUS WMD_CHNL_AddIOReq(struct CHNL_OBJECT *hChnl,
-					    void *pHostBuf,
-					    u32 cBytes, u32 cBufSize,
-					    OPTIONAL u32 dwDspAddr,
-					    u32 dwArg);
-
-	extern DSP_STATUS WMD_CHNL_GetIOC(struct CHNL_OBJECT *hChnl,
-					  u32 dwTimeOut,
-					  OUT struct CHNL_IOC *pIOC);
-
-	extern DSP_STATUS WMD_CHNL_CancelIO(struct CHNL_OBJECT *hChnl);
-
-	extern DSP_STATUS WMD_CHNL_FlushIO(struct CHNL_OBJECT *hChnl,
-					   u32 dwTimeOut);
-
-	extern DSP_STATUS WMD_CHNL_GetInfo(struct CHNL_OBJECT *hChnl,
-					   OUT struct CHNL_INFO *pInfo);
-
-	extern DSP_STATUS WMD_CHNL_GetMgrInfo(struct CHNL_MGR *hChnlMgr,
-					      u32 uChnlID,
-					      OUT struct CHNL_MGRINFO
-					      *pMgrInfo);
-
-	extern DSP_STATUS WMD_CHNL_Idle(struct CHNL_OBJECT *hChnl,
-					u32 dwTimeOut, bool fFlush);
-
-	extern DSP_STATUS WMD_CHNL_RegisterNotify(struct CHNL_OBJECT *hChnl,
-						  u32 uEventMask,
-						  u32 uNotifyType,
-						  struct DSP_NOTIFICATION
-						  *hNotification);
+extern dsp_status bridge_chnl_create(OUT struct chnl_mgr **phChnlMgr,
+				     struct dev_object *hdev_obj,
+				     IN CONST struct chnl_mgrattrs
+				     *pMgrAttrs);
+
+extern dsp_status bridge_chnl_destroy(struct chnl_mgr *hchnl_mgr);
+
+extern dsp_status bridge_chnl_open(OUT struct chnl_object **phChnl,
+				   struct chnl_mgr *hchnl_mgr,
+				   short int chnl_mode,
+				   u32 uChnlId,
+				   CONST IN OPTIONAL struct chnl_attr
+				   *pattrs);
+
+extern dsp_status bridge_chnl_close(struct chnl_object *chnl_obj);
+
+extern dsp_status bridge_chnl_add_io_req(struct chnl_object *chnl_obj,
+				      void *pHostBuf,
+				      u32 byte_size, u32 buf_size,
+				      OPTIONAL u32 dw_dsp_addr, u32 dw_arg);
+
+extern dsp_status bridge_chnl_get_ioc(struct chnl_object *chnl_obj,
+				   u32 dwTimeOut, OUT struct chnl_ioc *pIOC);
+
+extern dsp_status bridge_chnl_cancel_io(struct chnl_object *chnl_obj);
+
+extern dsp_status bridge_chnl_flush_io(struct chnl_object *chnl_obj,
+				    u32 dwTimeOut);
+
+extern dsp_status bridge_chnl_get_info(struct chnl_object *chnl_obj,
+				    OUT struct chnl_info *pInfo);
+
+extern dsp_status bridge_chnl_get_mgr_info(struct chnl_mgr *hchnl_mgr,
+					u32 uChnlID, OUT struct chnl_mgrinfo
+					*pMgrInfo);
+
+extern dsp_status bridge_chnl_idle(struct chnl_object *chnl_obj,
+				   u32 dwTimeOut, bool fFlush);
+
+extern dsp_status bridge_chnl_register_notify(struct chnl_object *chnl_obj,
+					   u32 event_mask,
+					   u32 notify_type,
+					   struct dsp_notification
+					   *hnotification);
 
-#endif				/* WMDCHNL_ */
+#endif /* WMDCHNL_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wmddeh.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wmddeh.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wmddeh.h	2011-10-11 13:50:58.289124764 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wmddeh.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,12 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Defines upper edge DEH functions required by all WMD/WCD driver
+ * interface tables.
+ *
+ * Notes:
+ *   Function comment headers reside with the function typedefs in wmd.h.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,30 +20,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== wmddeh.h ========
- *  Description:
- *      Defines upper edge DEH functions required by all WMD/WCD driver
- *      interface tables.
- *
- *  Public Functions:
- *      WMD_DEH_Create
- *      IVA_DEH_Create
- *      WMD_DEH_Destroy
- *      WMD_DEH_GetInfo
- *      WMD_DEH_RegisterNotify
- *      WMD_DEH_Notify
- *
- *  Notes:
- *      Function comment headers reside with the function typedefs in wmd.h.
- *
- *! Revision History:
- *! ================
- *! 26-Dec-2004 hn: added IVA_DEH_Create.
- *! 13-Sep-2001 kc: created.
- */
-
 #ifndef WMDDEH_
 #define WMDDEH_
 
@@ -45,22 +27,22 @@
 
 #include <dspbridge/dehdefs.h>
 
-	extern DSP_STATUS WMD_DEH_Create(OUT struct DEH_MGR **phDehMgr,
-					 struct DEV_OBJECT *hDevObject);
+extern dsp_status bridge_deh_create(OUT struct deh_mgr **phDehMgr,
+				    struct dev_object *hdev_obj);
 
-	extern DSP_STATUS WMD_DEH_Destroy(struct DEH_MGR *hDehMgr);
+extern dsp_status bridge_deh_destroy(struct deh_mgr *hdeh_mgr);
 
-	extern DSP_STATUS WMD_DEH_GetInfo(struct DEH_MGR *hDehMgr,
-					  struct DSP_ERRORINFO *pErrInfo);
+extern dsp_status bridge_deh_get_info(struct deh_mgr *hdeh_mgr,
+				   struct dsp_errorinfo *pErrInfo);
 
-	extern DSP_STATUS WMD_DEH_RegisterNotify(struct DEH_MGR *hDehMgr,
-						 u32 uEventMask,
-						 u32 uNotifyType,
-						 struct DSP_NOTIFICATION
-						 *hNotification);
+extern dsp_status bridge_deh_register_notify(struct deh_mgr *hdeh_mgr,
+					  u32 event_mask,
+					  u32 notify_type,
+					  struct dsp_notification
+					  *hnotification);
 
-	extern void WMD_DEH_Notify(struct DEH_MGR *hDehMgr,
-				   u32 ulEventMask, u32 dwErrInfo);
+extern void bridge_deh_notify(struct deh_mgr *hdeh_mgr,
+			      u32 ulEventMask, u32 dwErrInfo);
 
-	extern void WMD_DEH_ReleaseDummyMem(void);
-#endif				/* WMDDEH_ */
+extern void bridge_deh_release_dummy_mem(void);
+#endif /* WMDDEH_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wmd.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wmd.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wmd.h	2011-10-11 13:50:58.970805887 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wmd.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,18 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Bridge mini driver entry point and interface function declarations.
+ *
+ * Notes:
+ *   The Bridge class driver obtains it's function interface to
+ *   the Bridge mini driver via a call to bridge_drv_entry().
+ *
+ *   Bridge Class Driver services exported to WMD's are initialized by the
+ *   WCD on behalf of the WMD.
+ *
+ *   WMD function DBC Requires and Ensures are also made by the WCD on
+ *   behalf of the WMD, to simplify the WMD code.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,51 +26,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== wmd.h ========
- *  Purpose:
- *      'Bridge mini driver entry point and interface function declarations.
- *
- *  Public Functions:
- *      WMD_DRV_Entry
- *
- *  Notes:
- *      The 'Bridge class driver obtains it's function interface to
- *      the 'Bridge mini driver via a call to WMD_DRV_Entry().
- *
- *      'Bridge Class Driver services exported to WMD's are initialized by the
- *      WCD on behalf of the WMD.
- *
- *      WMD function DBC Requires and Ensures are also made by the WCD on
- *      behalf of the WMD, to simplify the WMD code.
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping APIs - WMD_BRD_MemMap/UnMap
- *! 01-Mar-2004 vp  Added filename argument to WMD_DRV_Entry function.
- *! 29-Aug-2002 map Added WMD_BRD_MemWrite()
- *! 26-Aug-2002 map Added WMD_BRD_MemCopy()
- *! 07-Jan-2002 ag  Added cBufSize to WMD_CHNL_AddIOReq().
- *! 05-Nov-2001 kc: Added error handling DEH functions.
- *! 06-Dec-2000 jeh Added uEventMask to WMD_MSG_RegisterNotify().
- *! 17-Nov-2000 jeh Added WMD_MSG and WMD_IO definitions.
- *! 01-Nov-2000 jeh Added more error codes to WMD_CHNL_RegisterNotify().
- *! 13-Oct-2000 jeh Added dwArg to WMD_CHNL_AddIOReq(), added WMD_CHNL_IDLE
- *!                 and WMD_CHNL_RegisterNotify for DSPStream support.
- *! 17-Jan-2000 rr: WMD_BRD_SETSTATE Added.
- *! 30-Jul-1997 gp: Split wmd IOCTL space into reserved and private.
- *! 07-Nov-1996 gp: Updated for code review.
- *! 18-Oct-1996 gp: Added WMD_E_HARDWARE return code from WMD_BRD_Monitor.
- *! 09-Sep-1996 gp: Subtly altered the semantics of WMD_CHNL_GetInfo().
- *! 02-Aug-1996 gp: Ensured on BRD_Start that interrupts to the PC are enabled.
- *! 11-Jul-1996 gp: Added CHNL interface. Note stronger DBC_Require conditions.
- *! 29-May-1996 gp: Removed WCD_ prefix from functions imported from WCD.LIB.
- *! 29-May-1996 gp: Made OUT param first in WMD_DEV_Create().
- *! 09-May-1996 gp: Created.
- */
-
 #ifndef WMD_
 #define WMD_
 
@@ -76,15 +43,15 @@
  */
 #define WMD_RESERVEDIOCTLBASE   0x8000
 
-/* Handle to mini-driver's private device context.  */
-	struct WMD_DEV_CONTEXT;
+/* Handle to mini-driver's private device context. */
+struct wmd_dev_context;
 
-/*---------------------------------------------------------------------------*/
-/* 'Bridge MINI DRIVER FUNCTION TYPES                                        */
-/*---------------------------------------------------------------------------*/
+/*--------------------------------------------------------------------------- */
+/* 'Bridge MINI DRIVER FUNCTION TYPES */
+/*--------------------------------------------------------------------------- */
 
 /*
- *  ======== WMD_BRD_Monitor ========
+ *  ======== bridge_brd_monitor ========
  *  Purpose:
  *      Bring the board to the BRD_IDLE (monitor) state.
  *  Parameters:
@@ -100,12 +67,10 @@
  *      DSP_SOK:        Board is in BRD_IDLE state;
  *      else:           Board state is indeterminate.
  */
-       typedef DSP_STATUS(
-			   *WMD_BRD_MONITOR) (struct WMD_DEV_CONTEXT
-			   *hDevContext);
+typedef dsp_status(*fxn_brd_monitor) (struct wmd_dev_context *hDevContext);
 
 /*
- *  ======== WMD_BRD_SETSTATE ========
+ *  ======== fxn_brd_setstate ========
  *  Purpose:
  *      Sets the Mini driver state
  *  Parameters:
@@ -121,12 +86,11 @@
  *      ulBrdState  <= BRD_LASTSTATE.
  *  Update the Board state to the specified state.
  */
-       typedef DSP_STATUS(
-			   *WMD_BRD_SETSTATE) (struct WMD_DEV_CONTEXT
-			   *hDevContext, u32 ulBrdState);
+typedef dsp_status(*fxn_brd_setstate) (struct wmd_dev_context
+				       * hDevContext, u32 ulBrdState);
 
 /*
- *  ======== WMD_BRD_Start ========
+ *  ======== bridge_brd_start ========
  *  Purpose:
  *      Bring board to the BRD_RUNNING (start) state.
  *  Parameters:
@@ -144,44 +108,44 @@
  *                      Interrupts to the PC are enabled.
  *      else:           Board state is indeterminate.
  */
-       typedef DSP_STATUS(*WMD_BRD_START) (struct WMD_DEV_CONTEXT
-						*hDevContext, u32 dwDSPAddr);
+typedef dsp_status(*fxn_brd_start) (struct wmd_dev_context
+				    * hDevContext, u32 dwDSPAddr);
 
 /*
- *  ======== WMD_BRD_MemCopy ========
+ *  ======== bridge_brd_mem_copy ========
  *  Purpose:
  *  Copy memory from one DSP address to another
  *  Parameters:
- *      pDevContext:    Pointer to context handle
+ *      dev_context:    Pointer to context handle
  *  ulDspDestAddr:  DSP address to copy to
  *  ulDspSrcAddr:   DSP address to copy from
- *  ulNumBytes: Number of bytes to copy
+ *  ul_num_bytes: Number of bytes to copy
  *  ulMemType:  What section of memory to copy to
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Other, unspecified error.
  *  Requires:
- *      pDevContext != NULL
+ *      dev_context != NULL
  *  Ensures:
  *      DSP_SOK:        Board is in BRD_RUNNING state.
  *                      Interrupts to the PC are enabled.
  *      else:           Board state is indeterminate.
  */
-       typedef DSP_STATUS(*WMD_BRD_MEMCOPY) (struct WMD_DEV_CONTEXT
-					     *hDevContext,
-					     u32 ulDspDestAddr,
-					     u32 ulDspSrcAddr,
-					     u32 ulNumBytes, u32 ulMemType);
+typedef dsp_status(*fxn_brd_memcopy) (struct wmd_dev_context
+				      * hDevContext,
+				      u32 ulDspDestAddr,
+				      u32 ulDspSrcAddr,
+				      u32 ul_num_bytes, u32 ulMemType);
 /*
- *  ======== WMD_BRD_MemWrite ========
+ *  ======== bridge_brd_mem_write ========
  *  Purpose:
  *      Write a block of host memory into a DSP address, into a given memory
- *      space.  Unlike WMD_BRD_Write, this API does reset the DSP
+ *      space.  Unlike bridge_brd_write, this API does reset the DSP
  *  Parameters:
  *      hDevContext:    Handle to mini-driver defined device info.
  *      dwDSPAddr:      Address on DSP board (Destination).
  *      pHostBuf:       Pointer to host buffer (Source).
- *      ulNumBytes:     Number of bytes to transfer.
+ *      ul_num_bytes:     Number of bytes to transfer.
  *      ulMemType:      Memory space on DSP to which to transfer.
  *  Returns:
  *      DSP_SOK:        Success.
@@ -192,22 +156,22 @@
  *      pHostBuf != NULL.
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_BRD_MEMWRITE) (struct WMD_DEV_CONTEXT
-					*hDevContext,
-					IN u8 *pHostBuf,
-					u32 dwDSPAddr, u32 ulNumBytes,
-					u32 ulMemType);
+typedef dsp_status(*fxn_brd_memwrite) (struct wmd_dev_context
+				       * hDevContext,
+				       IN u8 *pHostBuf,
+				       u32 dwDSPAddr, u32 ul_num_bytes,
+				       u32 ulMemType);
 
 /*
- *  ======== WMD_BRD_MemMap ========
+ *  ======== bridge_brd_mem_map ========
  *  Purpose:
  *      Map a MPU memory region to a DSP/IVA memory space
  *  Parameters:
  *      hDevContext:    Handle to mini-driver defined device info.
- *      ulMpuAddr:      MPU memory region start address.
+ *      ul_mpu_addr:      MPU memory region start address.
  *      ulVirtAddr:     DSP/IVA memory region u8 address.
- *      ulNumBytes:     Number of bytes to map.
- *      mapAttrs:       Mapping attributes (e.g. endianness).
+ *      ul_num_bytes:     Number of bytes to map.
+ *      map_attrs:       Mapping attributes (e.g. endianness).
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Other, unspecified error.
@@ -215,19 +179,19 @@
  *      hDevContext != NULL;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_BRD_MEMMAP) (struct WMD_DEV_CONTEXT
-					*hDevContext, u32 ulMpuAddr,
-					u32 ulVirtAddr, u32 ulNumBytes,
-					u32 ulMapAttrs);
+typedef dsp_status(*fxn_brd_memmap) (struct wmd_dev_context
+				     * hDevContext, u32 ul_mpu_addr,
+				     u32 ulVirtAddr, u32 ul_num_bytes,
+				     u32 ulMapAttrs);
 
 /*
- *  ======== WMD_BRD_MemUnMap ========
+ *  ======== bridge_brd_mem_un_map ========
  *  Purpose:
  *      UnMap an MPU memory region from DSP/IVA memory space
  *  Parameters:
  *      hDevContext:    Handle to mini-driver defined device info.
  *      ulVirtAddr:     DSP/IVA memory region u8 address.
- *      ulNumBytes:     Number of bytes to unmap.
+ *      ul_num_bytes:     Number of bytes to unmap.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Other, unspecified error.
@@ -235,13 +199,12 @@
  *      hDevContext != NULL;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_BRD_MEMUNMAP) (struct WMD_DEV_CONTEXT
-					*hDevContext,
-					u32 ulVirtAddr,
-					u32 ulNumBytes);
+typedef dsp_status(*fxn_brd_memunmap) (struct wmd_dev_context
+				       * hDevContext,
+				       u32 ulVirtAddr, u32 ul_num_bytes);
 
 /*
- *  ======== WMD_BRD_Stop ========
+ *  ======== bridge_brd_stop ========
  *  Purpose:
  *      Bring board to the BRD_STOPPED state.
  *  Parameters:
@@ -257,11 +220,10 @@
  *                      Interrupts to the PC are disabled.
  *      else:           Board state is indeterminate.
  */
-       typedef DSP_STATUS(*WMD_BRD_STOP) (struct WMD_DEV_CONTEXT
-					*hDevContext);
+typedef dsp_status(*fxn_brd_stop) (struct wmd_dev_context *hDevContext);
 
 /*
- *  ======== WMD_BRD_Status ========
+ *  ======== bridge_brd_status ========
  *  Purpose:
  *      Report the current state of the board.
  *  Parameters:
@@ -275,12 +237,11 @@
  *  Ensures:
  *      *pdwState is one of {BRD_STOPPED, BRD_IDLE, BRD_RUNNING, BRD_UNKNOWN};
  */
-       typedef DSP_STATUS(*
-			   WMD_BRD_STATUS) (struct WMD_DEV_CONTEXT *hDevContext,
-					    OUT BRD_STATUS * pdwState);
+typedef dsp_status(*fxn_brd_status) (struct wmd_dev_context *hDevContext,
+				     int *pdwState);
 
 /*
- *  ======== WMD_BRD_Read ========
+ *  ======== bridge_brd_read ========
  *  Purpose:
  *      Read a block of DSP memory, from a given memory space, into a host
  *      buffer.
@@ -288,7 +249,7 @@
  *      hDevContext:    Handle to mini-driver defined device info.
  *      pHostBuf:       Pointer to host buffer (Destination).
  *      dwDSPAddr:      Address on DSP board (Source).
- *      ulNumBytes:     Number of bytes to transfer.
+ *      ul_num_bytes:     Number of bytes to transfer.
  *      ulMemType:      Memory space on DSP from which to transfer.
  *  Returns:
  *      DSP_SOK:        Success.
@@ -298,16 +259,15 @@
  *      hDevContext != NULL;
  *      pHostBuf != NULL.
  *  Ensures:
- *  Will not write more than ulNumBytes bytes into pHostBuf.
+ *  Will not write more than ul_num_bytes bytes into pHostBuf.
  */
-typedef DSP_STATUS(*WMD_BRD_READ) (struct WMD_DEV_CONTEXT *hDevContext,
-						  OUT u8 *pHostBuf,
-						  u32 dwDSPAddr,
-						  u32 ulNumBytes,
-						  u32 ulMemType);
+typedef dsp_status(*fxn_brd_read) (struct wmd_dev_context *hDevContext,
+				   OUT u8 *pHostBuf,
+				   u32 dwDSPAddr,
+				   u32 ul_num_bytes, u32 ulMemType);
 
 /*
- *  ======== WMD_BRD_Write ========
+ *  ======== bridge_brd_write ========
  *  Purpose:
  *      Write a block of host memory into a DSP address, into a given memory
  *      space.
@@ -315,7 +275,7 @@
  *      hDevContext:    Handle to mini-driver defined device info.
  *      dwDSPAddr:      Address on DSP board (Destination).
  *      pHostBuf:       Pointer to host buffer (Source).
- *      ulNumBytes:     Number of bytes to transfer.
+ *      ul_num_bytes:     Number of bytes to transfer.
  *      ulMemType:      Memory space on DSP to which to transfer.
  *  Returns:
  *      DSP_SOK:        Success.
@@ -326,27 +286,26 @@
  *      pHostBuf != NULL.
  *  Ensures:
  */
-typedef DSP_STATUS(*WMD_BRD_WRITE)(struct WMD_DEV_CONTEXT *hDevContext,
-						   IN u8 *pHostBuf,
-						   u32 dwDSPAddr,
-						   u32 ulNumBytes,
-						   u32 ulMemType);
+typedef dsp_status(*fxn_brd_write) (struct wmd_dev_context *hDevContext,
+				    IN u8 *pHostBuf,
+				    u32 dwDSPAddr,
+				    u32 ul_num_bytes, u32 ulMemType);
 
 /*
- *  ======== WMD_CHNL_Create ========
+ *  ======== bridge_chnl_create ========
  *  Purpose:
  *      Create a channel manager object, responsible for opening new channels
  *      and closing old ones for a given 'Bridge board.
  *  Parameters:
  *      phChnlMgr:      Location to store a channel manager object on output.
- *      hDevObject:     Handle to a device object.
+ *      hdev_obj:     Handle to a device object.
  *      pMgrAttrs:      Channel manager attributes.
- *      pMgrAttrs->cChannels: Max channels
- *      pMgrAttrs->bIRQ:      Channel's I/O IRQ number.
- *      pMgrAttrs->fShared:   TRUE if the IRQ is shareable.
- *      pMgrAttrs->uWordSize: DSP Word size in equivalent PC bytes..
- *      pMgrAttrs->dwSMBase:  Base physical address of shared memory, if any.
- *      pMgrAttrs->uSMLength: Bytes of shared memory block.
+ *      pMgrAttrs->max_channels: Max channels
+ *      pMgrAttrs->birq:      Channel's I/O IRQ number.
+ *      pMgrAttrs->irq_shared:   TRUE if the IRQ is shareable.
+ *      pMgrAttrs->word_size: DSP Word size in equivalent PC bytes..
+ *      pMgrAttrs->shm_base:  Base physical address of shared memory, if any.
+ *      pMgrAttrs->usm_length: Bytes of shared memory block.
  *  Returns:
  *      DSP_SOK:            Success;
  *      DSP_EMEMORY:        Insufficient memory for requested resources.
@@ -356,82 +315,81 @@
  *      phChnlMgr != NULL.
  *      pMgrAttrs != NULL
  *      pMgrAttrs field are all valid:
- *          0 < cChannels <= CHNL_MAXCHANNELS.
- *          bIRQ <= 15.
- *          uWordSize > 0.
- *      IsValidHandle(hDevObject)
+ *          0 < max_channels <= CHNL_MAXCHANNELS.
+ *          birq <= 15.
+ *          word_size > 0.
+ *      IS_VALID_HANDLE(hdev_obj)
  *      No channel manager exists for this board.
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_CHNL_CREATE)(OUT struct CHNL_MGR
-						    **phChnlMgr,
-						    struct DEV_OBJECT
-						    *hDevObject,
-						    IN CONST struct
-						    CHNL_MGRATTRS *pMgrAttrs);
+typedef dsp_status(*fxn_chnl_create) (OUT struct chnl_mgr
+				      **phChnlMgr,
+				      struct dev_object
+				      * hdev_obj,
+				      IN CONST struct
+				      chnl_mgrattrs * pMgrAttrs);
 
 /*
- *  ======== WMD_CHNL_Destroy ========
+ *  ======== bridge_chnl_destroy ========
  *  Purpose:
  *      Close all open channels, and destroy the channel manager.
  *  Parameters:
- *      hChnlMgr:       Channel manager object.
+ *      hchnl_mgr:       Channel manager object.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    hChnlMgr was invalid.
+ *      DSP_EHANDLE:    hchnl_mgr was invalid.
  *  Requires:
  *  Ensures:
  *      DSP_SOK: Cancels I/O on each open channel. Closes each open channel.
- *          CHNL_Create may subsequently be called for the same device.
+ *          chnl_create may subsequently be called for the same device.
  */
-       typedef DSP_STATUS(*WMD_CHNL_DESTROY) (struct CHNL_MGR
-						      *hChnlMgr);
+typedef dsp_status(*fxn_chnl_destroy) (struct chnl_mgr *hchnl_mgr);
 /*
- *  ======== WMD_DEH_Notify ========
+ *  ======== bridge_deh_notify ========
  *  Purpose:
  *      When notified of DSP error, take appropriate action.
  *  Parameters:
- *      hDehMgr:        Handle to DEH manager object.
+ *      hdeh_mgr:        Handle to DEH manager object.
  *      ulEventMask:  Indicate the type of exception
  *      dwErrInfo:     Error information
  *  Returns:
  *
  *  Requires:
- *      hDehMgr != NULL;
+ *      hdeh_mgr != NULL;
  *     ulEventMask with a valid exception
  *  Ensures:
  */
-       typedef void (*WMD_DEH_NOTIFY)(struct DEH_MGR *hDehMgr,
-					u32 ulEventMask, u32 dwErrInfo);
-
+typedef void (*fxn_deh_notify) (struct deh_mgr *hdeh_mgr,
+				u32 ulEventMask, u32 dwErrInfo);
 
 /*
- *  ======== WMD_CHNL_Open ========
+ *  ======== bridge_chnl_open ========
  *  Purpose:
  *      Open a new half-duplex channel to the DSP board.
  *  Parameters:
  *      phChnl:         Location to store a channel object handle.
- *      hChnlMgr:       Handle to channel manager, as returned by CHNL_GetMgr().
- *      uMode:          One of {CHNL_MODETODSP, CHNL_MODEFROMDSP} specifies
+ *      hchnl_mgr:	Handle to channel manager, as returned by
+ *      		CHNL_GetMgr().
+ *      chnl_mode:          One of {CHNL_MODETODSP, CHNL_MODEFROMDSP} specifies
  *                      direction of data transfer.
  *      uChnlId:        If CHNL_PICKFREE is specified, the channel manager will
  *                      select a free channel id (default);
  *                      otherwise this field specifies the id of the channel.
- *      pAttrs:         Channel attributes.  Attribute fields are as follows:
- *      pAttrs->uIOReqs: Specifies the maximum number of I/O requests which can
+ *      pattrs:         Channel attributes.  Attribute fields are as follows:
+ *      pattrs->uio_reqs: Specifies the maximum number of I/O requests which can
  *                      be pending at any given time. All request packets are
  *                      preallocated when the channel is opened.
- *      pAttrs->hEvent: This field allows the user to supply an auto reset
+ *      pattrs->event_obj: This field allows the user to supply an auto reset
  *                      event object for channel I/O completion notifications.
  *                      It is the responsibility of the user to destroy this
  *                      object AFTER closing the channel.
  *                      This channel event object can be retrieved using
  *                      CHNL_GetEventHandle().
- *      pAttrs->hReserved: The kernel mode handle of this event object.
+ *      pattrs->hReserved: The kernel mode handle of this event object.
  *
  *  Returns:
  *      DSP_SOK:                Success.
- *      DSP_EHANDLE:            hChnlMgr is invalid.
+ *      DSP_EHANDLE:            hchnl_mgr is invalid.
  *      DSP_EMEMORY:            Insufficient memory for requested resources.
  *      DSP_EINVALIDARG:        Invalid number of IOReqs.
  *      CHNL_E_OUTOFSTREAMS:    No free channels available.
@@ -441,58 +399,58 @@
  *                              queuing.
  *  Requires:
  *      phChnl != NULL.
- *      pAttrs != NULL.
- *      pAttrs->hEvent is a valid event handle.
- *      pAttrs->hReserved is the kernel mode handle for pAttrs->hEvent.
+ *      pattrs != NULL.
+ *      pattrs->event_obj is a valid event handle.
+ *      pattrs->hReserved is the kernel mode handle for pattrs->event_obj.
  *  Ensures:
  *      DSP_SOK:                *phChnl is a valid channel.
  *      else:                   *phChnl is set to NULL if (phChnl != NULL);
  */
-       typedef DSP_STATUS(*WMD_CHNL_OPEN) (OUT struct CHNL_OBJECT
-						   **phChnl,
-						   struct CHNL_MGR *hChnlMgr,
-						   CHNL_MODE uMode,
-						   u32 uChnlId,
-						   CONST IN OPTIONAL struct
-						   CHNL_ATTRS *pAttrs);
+typedef dsp_status(*fxn_chnl_open) (OUT struct chnl_object
+				    **phChnl,
+				    struct chnl_mgr *hchnl_mgr,
+				    short int chnl_mode,
+				    u32 uChnlId,
+				    CONST IN OPTIONAL struct
+				    chnl_attr * pattrs);
 
 /*
- *  ======== WMD_CHNL_Close ========
+ *  ======== bridge_chnl_close ========
  *  Purpose:
  *      Ensures all pending I/O on this channel is cancelled, discards all
  *      queued I/O completion notifications, then frees the resources allocated
  *      for this channel, and makes the corresponding logical channel id
  *      available for subsequent use.
  *  Parameters:
- *      hChnl:          Handle to a channel object.
+ *      chnl_obj:          Handle to a channel object.
  *  Returns:
  *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EHANDLE:    Invalid chnl_obj.
  *  Requires:
  *      No thread must be blocked on this channel's I/O completion event.
  *  Ensures:
- *      DSP_SOK:        hChnl is no longer valid.
+ *      DSP_SOK:        chnl_obj is no longer valid.
  */
-       typedef DSP_STATUS(*WMD_CHNL_CLOSE) (struct CHNL_OBJECT *hChnl);
+typedef dsp_status(*fxn_chnl_close) (struct chnl_object *chnl_obj);
 
 /*
- *  ======== WMD_CHNL_AddIOReq ========
+ *  ======== bridge_chnl_add_io_req ========
  *  Purpose:
  *      Enqueue an I/O request for data transfer on a channel to the DSP.
  *      The direction (mode) is specified in the channel object. Note the DSP
  *      address is specified for channels opened in direct I/O mode.
  *  Parameters:
- *      hChnl:          Channel object handle.
+ *      chnl_obj:          Channel object handle.
  *      pHostBuf:       Host buffer address source.
- *      cBytes:         Number of PC bytes to transfer. A zero value indicates
+ *      byte_size:	Number of PC bytes to transfer. A zero value indicates
  *                      that this buffer is the last in the output channel.
  *                      A zero value is invalid for an input channel.
- *!     cBufSize:       Actual buffer size in host bytes.
- *      dwDspAddr:      DSP address for transfer.  (Currently ignored).
- *      dwArg:          A user argument that travels with the buffer.
+ *!     buf_size:       Actual buffer size in host bytes.
+ *      dw_dsp_addr:      DSP address for transfer.  (Currently ignored).
+ *      dw_arg:          A user argument that travels with the buffer.
  *  Returns:
  *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EHANDLE:    Invalid chnl_obj.
  *      DSP_EPOINTER:   pHostBuf is invalid.
  *      CHNL_E_NOEOS:   User cannot mark EOS on an input channel.
  *      CHNL_E_CANCELLED: I/O has been cancelled on this channel.  No further
@@ -507,26 +465,25 @@
  *          otherwise, will be queued for transfer when the channel becomes
  *          ready.  In any case, notifications of I/O completion are
  *          asynchronous.
- *          If cBytes is 0 for an output channel, subsequent CHNL_AddIOReq's
+ *          If byte_size is 0 for an output channel, subsequent CHNL_AddIOReq's
  *          on this channel will fail with error code CHNL_E_EOS.  The
  *          corresponding IOC for this I/O request will have its status flag
  *          set to CHNL_IOCSTATEOS.
  */
-       typedef DSP_STATUS(*WMD_CHNL_ADDIOREQ) (struct CHNL_OBJECT
-						       *hChnl,
-						       void *pHostBuf,
-						       u32 cBytes,
-						       u32 cBufSize,
-						       OPTIONAL u32 dwDspAddr,
-						       u32 dwArg);
+typedef dsp_status(*fxn_chnl_addioreq) (struct chnl_object
+					* chnl_obj,
+					void *pHostBuf,
+					u32 byte_size,
+					u32 buf_size,
+					OPTIONAL u32 dw_dsp_addr, u32 dw_arg);
 
 /*
- *  ======== WMD_CHNL_GetIOC ========
+ *  ======== bridge_chnl_get_ioc ========
  *  Purpose:
  *      Dequeue an I/O completion record, which contains information about the
  *      completed I/O request.
  *  Parameters:
- *      hChnl:          Channel object handle.
+ *      chnl_obj:          Channel object handle.
  *      dwTimeOut:      A value of CHNL_IOCNOWAIT will simply dequeue the
  *                      first available IOC.
  *      pIOC:           On output, contains host buffer address, bytes
@@ -534,7 +491,7 @@
  *      pIOC->status:   See chnldefs.h.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EHANDLE:    Invalid chnl_obj.
  *      DSP_EPOINTER:   pIOC is invalid.
  *      CHNL_E_NOIOC:   CHNL_IOCNOWAIT was specified as the dwTimeOut parameter
  *                      yet no I/O completions were queued.
@@ -545,97 +502,94 @@
  *          returns, the channel event object will be left in a signalled
  *          state.
  */
-       typedef DSP_STATUS(*WMD_CHNL_GETIOC) (struct CHNL_OBJECT *hChnl,
-						     u32 dwTimeOut,
-						     OUT struct CHNL_IOC *pIOC);
+typedef dsp_status(*fxn_chnl_getioc) (struct chnl_object *chnl_obj,
+				      u32 dwTimeOut,
+				      OUT struct chnl_ioc *pIOC);
 
 /*
- *  ======== WMD_CHNL_CancelIO ========
+ *  ======== bridge_chnl_cancel_io ========
  *  Purpose:
  *      Return all I/O requests to the client which have not yet been
  *      transferred.  The channel's I/O completion object is
  *      signalled, and all the I/O requests are queued as IOC's, with the
  *      status field set to CHNL_IOCSTATCANCEL.
  *      This call is typically used in abort situations, and is a prelude to
- *      CHNL_Close();
+ *      chnl_close();
  *  Parameters:
- *      hChnl:          Channel object handle.
+ *      chnl_obj:          Channel object handle.
  *  Returns:
  *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EHANDLE:    Invalid chnl_obj.
  *  Requires:
  *  Ensures:
  *      Subsequent I/O requests to this channel will not be accepted.
  */
-       typedef DSP_STATUS(*WMD_CHNL_CANCELIO) (struct CHNL_OBJECT
-						       *hChnl);
+typedef dsp_status(*fxn_chnl_cancelio) (struct chnl_object *chnl_obj);
 
 /*
- *  ======== WMD_CHNL_FlushIO ========
+ *  ======== bridge_chnl_flush_io ========
  *  Purpose:
  *      For an output stream (to the DSP), indicates if any IO requests are in
  *      the output request queue.  For input streams (from the DSP), will
  *      cancel all pending IO requests.
  *  Parameters:
- *      hChnl:              Channel object handle.
+ *      chnl_obj:              Channel object handle.
  *      dwTimeOut:          Timeout value for flush operation.
  *  Returns:
  *      DSP_SOK:            Success;
  *      S_CHNLIOREQUEST:    Returned if any IORequests are in the output queue.
- *      DSP_EHANDLE:        Invalid hChnl.
+ *      DSP_EHANDLE:        Invalid chnl_obj.
  *  Requires:
  *  Ensures:
  *      DSP_SOK:            No I/O requests will be pending on this channel.
  */
-       typedef DSP_STATUS(*WMD_CHNL_FLUSHIO) (struct CHNL_OBJECT *hChnl,
-						      u32 dwTimeOut);
+typedef dsp_status(*fxn_chnl_flushio) (struct chnl_object *chnl_obj,
+				       u32 dwTimeOut);
 
 /*
- *  ======== WMD_CHNL_GetInfo ========
+ *  ======== bridge_chnl_get_info ========
  *  Purpose:
  *      Retrieve information related to a channel.
  *  Parameters:
- *      hChnl:          Handle to a valid channel object, or NULL.
+ *      chnl_obj:          Handle to a valid channel object, or NULL.
  *      pInfo:          Location to store channel info.
  *  Returns:
  *      DSP_SOK:        Success;
- *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EHANDLE:    Invalid chnl_obj.
  *      DSP_EPOINTER:   pInfo == NULL.
  *  Requires:
  *  Ensures:
- *      DSP_SOK:        pInfo points to a filled in CHNL_INFO struct,
+ *      DSP_SOK:        pInfo points to a filled in chnl_info struct,
  *                      if (pInfo != NULL).
  */
-       typedef DSP_STATUS(*WMD_CHNL_GETINFO) (struct CHNL_OBJECT *hChnl,
-						      OUT struct CHNL_INFO
-						      *pChnlInfo);
+typedef dsp_status(*fxn_chnl_getinfo) (struct chnl_object *chnl_obj,
+				       OUT struct chnl_info *pChnlInfo);
 
 /*
- *  ======== WMD_CHNL_GetMgrInfo ========
+ *  ======== bridge_chnl_get_mgr_info ========
  *  Purpose:
  *      Retrieve information related to the channel manager.
  *  Parameters:
- *      hChnlMgr:           Handle to a valid channel manager, or NULL.
+ *      hchnl_mgr:           Handle to a valid channel manager, or NULL.
  *      uChnlID:            Channel ID.
  *      pMgrInfo:           Location to store channel manager info.
  *  Returns:
  *      DSP_SOK:            Success;
- *      DSP_EHANDLE:        Invalid hChnlMgr.
+ *      DSP_EHANDLE:        Invalid hchnl_mgr.
  *      DSP_EPOINTER:       pMgrInfo == NULL.
  *      CHNL_E_BADCHANID:   Invalid channel ID.
  *  Requires:
  *  Ensures:
- *      DSP_SOK:            pMgrInfo points to a filled in CHNL_MGRINFO
+ *      DSP_SOK:            pMgrInfo points to a filled in chnl_mgrinfo
  *                          struct, if (pMgrInfo != NULL).
  */
-       typedef DSP_STATUS(*WMD_CHNL_GETMGRINFO) (struct CHNL_MGR
-							 *hChnlMgr,
-							 u32 uChnlID,
-							 OUT struct CHNL_MGRINFO
-							 *pMgrInfo);
+typedef dsp_status(*fxn_chnl_getmgrinfo) (struct chnl_mgr
+					  * hchnl_mgr,
+					  u32 uChnlID,
+					  OUT struct chnl_mgrinfo *pMgrInfo);
 
 /*
- *  ======== WMD_CHNL_Idle ========
+ *  ======== bridge_chnl_idle ========
  *  Purpose:
  *      Idle a channel. If this is an input channel, or if this is an output
  *      channel and fFlush is TRUE, all currently enqueued buffers will be
@@ -645,7 +599,7 @@
  *      specified has been reached.
  *
  *  Parameters:
- *      hChnl:          Channel object handle.
+ *      chnl_obj:          Channel object handle.
  *      dwTimeOut:      If output channel and fFlush is FALSE, timeout value
  *                      to wait for buffers to be output. (Not used for
  *                      input channel).
@@ -655,53 +609,50 @@
  *                      occurs first. fFlush is ignored for input channel.
  *  Returns:
  *      DSP_SOK:            Success;
- *      DSP_EHANDLE:        Invalid hChnl.
+ *      DSP_EHANDLE:        Invalid chnl_obj.
  *      CHNL_E_WAITTIMEOUT: Timeout occured before channel could be idled.
  *  Requires:
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_CHNL_IDLE) (struct CHNL_OBJECT *hChnl,
-						   u32 dwTimeOut,
-						   bool fFlush);
+typedef dsp_status(*fxn_chnl_idle) (struct chnl_object *chnl_obj,
+				    u32 dwTimeOut, bool fFlush);
 
 /*
- *  ======== WMD_CHNL_RegisterNotify ========
+ *  ======== bridge_chnl_register_notify ========
  *  Purpose:
  *      Register for notification of events on a channel.
  *  Parameters:
- *      hChnl:          Channel object handle.
- *      uEventMask:     Type of events to be notified about: IO completion
+ *      chnl_obj:          Channel object handle.
+ *      event_mask:     Type of events to be notified about: IO completion
  *                      (DSP_STREAMIOCOMPLETION) or end of stream
  *                      (DSP_STREAMDONE).
- *      uNotifyType:    DSP_SIGNALEVENT.
- *      hNotification:  Handle of a DSP_NOTIFICATION object.
+ *      notify_type:    DSP_SIGNALEVENT.
+ *      hnotification:  Handle of a dsp_notification object.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Insufficient memory.
- *      DSP_EVALUE:     uEventMask is 0 and hNotification was not
+ *      DSP_EVALUE:     event_mask is 0 and hnotification was not
  *                      previously registered.
- *      DSP_EHANDLE:    NULL hNotification, hNotification event name
- *                      too long, or hNotification event name NULL.
+ *      DSP_EHANDLE:    NULL hnotification, hnotification event name
+ *                      too long, or hnotification event name NULL.
  *  Requires:
- *      Valid hChnl.
- *      hNotification != NULL.
- *      (uEventMask & ~(DSP_STREAMIOCOMPLETION | DSP_STREAMDONE)) == 0.
- *      uNotifyType == DSP_SIGNALEVENT.
+ *      Valid chnl_obj.
+ *      hnotification != NULL.
+ *      (event_mask & ~(DSP_STREAMIOCOMPLETION | DSP_STREAMDONE)) == 0.
+ *      notify_type == DSP_SIGNALEVENT.
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_CHNL_REGISTERNOTIFY)
-				(struct CHNL_OBJECT *hChnl,
-				u32 uEventMask,
-				u32 uNotifyType,
-				struct DSP_NOTIFICATION *hNotification);
+typedef dsp_status(*fxn_chnl_registernotify)
+ (struct chnl_object *chnl_obj,
+  u32 event_mask, u32 notify_type, struct dsp_notification *hnotification);
 
 /*
- *  ======== WMD_DEV_Create ========
+ *  ======== bridge_dev_create ========
  *  Purpose:
  *      Complete creation of the device object for this board.
  *  Parameters:
  *      phDevContext:   Ptr to location to store a WMD device context.
- *      hDevObject:     Handle to a Device Object, created and managed by WCD.
+ *      hdev_obj:     Handle to a Device Object, created and managed by WCD.
  *      pConfig:        Ptr to configuration parameters provided by the Windows
  *                      Configuration Manager during device loading.
  *      pDspConfig:     DSP resources, as specified in the registry key for this
@@ -714,7 +665,7 @@
  *                          made by this WMD.
  *  Requires:
  *      phDevContext != NULL;
- *      hDevObject != NULL;
+ *      hdev_obj != NULL;
  *      pConfig != NULL;
  *      pDspConfig != NULL;
  *      Fields in pConfig and pDspConfig contain valid values.
@@ -723,7 +674,8 @@
  *                      board context has been allocated.
  *      DSP_EMEMORY:    WMD failed to allocate resources.
  *                      Any acquired resources have been freed.  The WCD will
- *                      not call WMD_DEV_Destroy() if WMD_DEV_Create() fails.
+ *                      not call bridge_dev_destroy() if bridge_dev_create()
+ *                      fails.
  *  Details:
  *      Called during the CONFIGMG's Device_Init phase. Based on host and
  *      DSP configuration information, create a board context, a handle to
@@ -733,42 +685,40 @@
  *      function returns, they must not be stored into the device context
  *      structure.
  */
-       typedef DSP_STATUS(*WMD_DEV_CREATE) (OUT struct WMD_DEV_CONTEXT
-						    **phDevContext,
-						    struct DEV_OBJECT
-						    *hDevObject,
-						    IN CONST struct CFG_HOSTRES
-						    *pConfig,
-						    IN CONST struct CFG_DSPRES
-						    *pDspConfig);
+typedef dsp_status(*fxn_dev_create) (OUT struct wmd_dev_context
+				     **phDevContext,
+				     struct dev_object
+				     * hdev_obj,
+				     IN CONST struct cfg_hostres
+				     * pConfig,
+				     IN CONST struct cfg_dspres *pDspConfig);
 
 /*
- *  ======== WMD_DEV_Ctrl ========
+ *  ======== bridge_dev_ctrl ========
  *  Purpose:
  *      Mini-driver specific interface.
  *  Parameters:
  *      hDevContext:    Handle to mini-driver defined device info.
- *      dwCmd:          WMD defined command code.
- *      pArgs:          Pointer to an arbitrary argument structure.
+ *      dw_cmd:          WMD defined command code.
+ *      pargs:          Pointer to an arbitrary argument structure.
  *  Returns:
  *      DSP_SOK or DSP_EFAIL. Actual command error codes should be passed back
- *      in the pArgs structure, and are defined by the WMD implementor.
+ *      in the pargs structure, and are defined by the WMD implementor.
  *  Requires:
  *      All calls are currently assumed to be synchronous.  There are no
  *      IOCTL completion routines provided.
  *  Ensures:
  */
-typedef DSP_STATUS(*WMD_DEV_CTRL)(struct WMD_DEV_CONTEXT *hDevContext,
-					u32 dwCmd,
-					IN OUT void *pArgs);
+typedef dsp_status(*fxn_dev_ctrl) (struct wmd_dev_context *hDevContext,
+				   u32 dw_cmd, IN OUT void *pargs);
 
 /*
- *  ======== WMD_DEV_Destroy ========
+ *  ======== bridge_dev_destroy ========
  *  Purpose:
  *      Deallocate WMD device extension structures and all other resources
  *      acquired by the mini-driver.
  *      No calls to other mini driver functions may subsequently
- *      occur, except for WMD_DEV_Create().
+ *      occur, except for bridge_dev_create().
  *  Parameters:
  *      hDevContext:    Handle to mini-driver defined device information.
  *  Returns:
@@ -779,65 +729,61 @@
  *  Ensures:
  *      DSP_SOK: Device context is freed.
  */
-       typedef DSP_STATUS(*WMD_DEV_DESTROY) (struct WMD_DEV_CONTEXT
-					     *hDevContext);
+typedef dsp_status(*fxn_dev_destroy) (struct wmd_dev_context *hDevContext);
 
 /*
- *  ======== WMD_DEH_Create ========
+ *  ======== bridge_deh_create ========
  *  Purpose:
  *      Create an object that manages DSP exceptions from the GPP.
  *  Parameters:
  *      phDehMgr:       Location to store DEH manager on output.
- *      hDevObject:     Handle to DEV object.
+ *      hdev_obj:     Handle to DEV object.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Memory allocation failure.
  *      DSP_EFAIL:      Creation failed.
  *  Requires:
- *      hDevObject != NULL;
+ *      hdev_obj != NULL;
  *      phDehMgr != NULL;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_DEH_CREATE) (OUT struct DEH_MGR
-						    **phDehMgr,
-						    struct DEV_OBJECT
-						    *hDevObject);
+typedef dsp_status(*fxn_deh_create) (OUT struct deh_mgr
+				     **phDehMgr, struct dev_object *hdev_obj);
 
 /*
- *  ======== WMD_DEH_Destroy ========
+ *  ======== bridge_deh_destroy ========
  *  Purpose:
  *      Destroy the DEH object.
  *  Parameters:
- *      hDehMgr:        Handle to DEH manager object.
+ *      hdeh_mgr:        Handle to DEH manager object.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Destroy failed.
  *  Requires:
- *      hDehMgr != NULL;
+ *      hdeh_mgr != NULL;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_DEH_DESTROY) (struct DEH_MGR *hDehMgr);
+typedef dsp_status(*fxn_deh_destroy) (struct deh_mgr *hdeh_mgr);
 
 /*
- *  ======== WMD_DEH_RegisterNotify ========
+ *  ======== bridge_deh_register_notify ========
  *  Purpose:
  *      Register for DEH event notification.
  *  Parameters:
- *      hDehMgr:        Handle to DEH manager object.
+ *      hdeh_mgr:        Handle to DEH manager object.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EFAIL:      Destroy failed.
  *  Requires:
- *      hDehMgr != NULL;
+ *      hdeh_mgr != NULL;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_DEH_REGISTERNOTIFY)
-				(struct DEH_MGR *hDehMgr,
-				u32 uEventMask, u32 uNotifyType,
-				struct DSP_NOTIFICATION *hNotification);
+typedef dsp_status(*fxn_deh_registernotify)
+ (struct deh_mgr *hdeh_mgr,
+  u32 event_mask, u32 notify_type, struct dsp_notification *hnotification);
 
 /*
- *  ======== WMD_DEH_GetInfo ========
+ *  ======== bridge_deh_get_info ========
  *  Purpose:
  *      Get DSP exception info.
  *  Parameters:
@@ -851,91 +797,92 @@
  *      pErrorInfo != NULL;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_DEH_GETINFO) (struct DEH_MGR *phDehMgr,
-					struct DSP_ERRORINFO *pErrInfo);
+typedef dsp_status(*fxn_deh_getinfo) (struct deh_mgr *phDehMgr,
+				      struct dsp_errorinfo *pErrInfo);
 
 /*
- *  ======== WMD_IO_Create ========
+ *  ======== bridge_io_create ========
  *  Purpose:
- *      Create an object that manages I/O between CHNL and MSG.
+ *      Create an object that manages I/O between CHNL and msg_ctrl.
  *  Parameters:
  *      phIOMgr:        Location to store IO manager on output.
- *      hChnlMgr:       Handle to channel manager.
- *      hMsgMgr:        Handle to message manager.
+ *      hchnl_mgr:       Handle to channel manager.
+ *      hmsg_mgr:        Handle to message manager.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Memory allocation failure.
  *      DSP_EFAIL:      Creation failed.
  *  Requires:
- *      hDevObject != NULL;
+ *      hdev_obj != NULL;
  *      Channel manager already created;
  *      Message manager already created;
  *      pMgrAttrs != NULL;
  *      phIOMgr != NULL;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_IO_CREATE) (OUT struct IO_MGR **phIOMgr,
-					struct DEV_OBJECT *hDevObject,
-					IN CONST struct IO_ATTRS *pMgrAttrs);
+typedef dsp_status(*fxn_io_create) (OUT struct io_mgr **phIOMgr,
+				    struct dev_object *hdev_obj,
+				    IN CONST struct io_attrs *pMgrAttrs);
 
 /*
- *  ======== WMD_IO_Destroy ========
+ *  ======== bridge_io_destroy ========
  *  Purpose:
- *      Destroy object created in WMD_IO_Create.
+ *      Destroy object created in bridge_io_create.
  *  Parameters:
- *      hIOMgr:         IO Manager.
+ *      hio_mgr:         IO Manager.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Memory allocation failure.
  *      DSP_EFAIL:      Creation failed.
  *  Requires:
- *      Valid hIOMgr;
+ *      Valid hio_mgr;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_IO_DESTROY) (struct IO_MGR *hIOMgr);
+typedef dsp_status(*fxn_io_destroy) (struct io_mgr *hio_mgr);
 
 /*
- *  ======== WMD_IO_OnLoaded ========
+ *  ======== bridge_io_on_loaded ========
  *  Purpose:
  *      Called whenever a program is loaded to update internal data. For
  *      example, if shared memory is used, this function would update the
  *      shared memory location and address.
  *  Parameters:
- *      hIOMgr:     IO Manager.
+ *      hio_mgr:     IO Manager.
  *  Returns:
  *      DSP_SOK:    Success.
  *      DSP_EFAIL:  Internal failure occurred.
  *  Requires:
- *      Valid hIOMgr;
+ *      Valid hio_mgr;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_IO_ONLOADED) (struct IO_MGR *hIOMgr);
+typedef dsp_status(*fxn_io_onloaded) (struct io_mgr *hio_mgr);
 
 /*
- *  ======== WMD_IO_GETPROCLOAD ========
+ *  ======== fxn_io_getprocload ========
  *  Purpose:
  *      Called to get the Processor's current and predicted load
  *  Parameters:
- *      hIOMgr:     IO Manager.
+ *      hio_mgr:     IO Manager.
  *      pProcLoadStat   Processor Load statistics
  *  Returns:
  *      DSP_SOK:    Success.
  *      DSP_EFAIL:  Internal failure occurred.
  *  Requires:
- *      Valid hIOMgr;
+ *      Valid hio_mgr;
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_IO_GETPROCLOAD)(struct IO_MGR *hIOMgr,
-			   struct DSP_PROCLOADSTAT *pProcLoadStat);
+typedef dsp_status(*fxn_io_getprocload) (struct io_mgr *hio_mgr,
+					 struct dsp_procloadstat *
+					 pProcLoadStat);
 
 /*
- *  ======== WMD_MSG_Create ========
+ *  ======== bridge_msg_create ========
  *  Purpose:
  *      Create an object to manage message queues. Only one of these objects
  *      can exist per device object.
  *  Parameters:
- *      phMsgMgr:           Location to store MSG manager on output.
- *      hDevObject:         Handle to a device object.
+ *      phMsgMgr:           Location to store msg_ctrl manager on output.
+ *      hdev_obj:         Handle to a device object.
  *      msgCallback:        Called whenever an RMS_EXIT message is received.
  *  Returns:
  *      DSP_SOK:            Success.
@@ -943,157 +890,152 @@
  *  Requires:
  *      phMsgMgr != NULL.
  *      msgCallback != NULL.
- *      hDevObject != NULL.
+ *      hdev_obj != NULL.
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_MSG_CREATE)
-				(OUT struct MSG_MGR **phMsgMgr,
-				struct DEV_OBJECT *hDevObject,
-				MSG_ONEXIT msgCallback);
+typedef dsp_status(*fxn_msg_create)
+ (OUT struct msg_mgr **phMsgMgr,
+  struct dev_object *hdev_obj, msg_onexit msgCallback);
 
 /*
- *  ======== WMD_MSG_CreateQueue ========
+ *  ======== bridge_msg_create_queue ========
  *  Purpose:
- *      Create a MSG queue for sending or receiving messages from a Message
+ *      Create a msg_ctrl queue for sending or receiving messages from a Message
  *      node on the DSP.
  *  Parameters:
- *      hMsgMgr:            MSG queue manager handle returned from
- *                          WMD_MSG_Create.
- *      phMsgQueue:         Location to store MSG queue on output.
- *      dwId:               Identifier for messages (node environment pointer).
- *      uMaxMsgs:           Max number of simultaneous messages for the node.
- *      h:                  Handle passed to hMsgMgr->msgCallback().
+ *      hmsg_mgr:            msg_ctrl queue manager handle returned from
+ *                          bridge_msg_create.
+ *      phMsgQueue:         Location to store msg_ctrl queue on output.
+ *      msgq_id:	    Identifier for messages (node environment pointer).
+ *      max_msgs:           Max number of simultaneous messages for the node.
+ *      h:                  Handle passed to hmsg_mgr->msgCallback().
  *  Returns:
  *      DSP_SOK:            Success.
  *      DSP_EMEMORY:        Insufficient memory.
  *  Requires:
  *      phMsgQueue != NULL.
  *      h != NULL.
- *      uMaxMsgs > 0.
+ *      max_msgs > 0.
  *  Ensures:
  *      phMsgQueue !=NULL <==> DSP_SOK.
  */
-       typedef DSP_STATUS(*WMD_MSG_CREATEQUEUE)
-				(struct MSG_MGR *hMsgMgr,
-				OUT struct MSG_QUEUE **phMsgQueue,
-				u32 dwId, u32 uMaxMsgs, HANDLE h);
+typedef dsp_status(*fxn_msg_createqueue)
+ (struct msg_mgr *hmsg_mgr,
+  OUT struct msg_queue **phMsgQueue, u32 msgq_id, u32 max_msgs, bhandle h);
 
 /*
- *  ======== WMD_MSG_Delete ========
+ *  ======== bridge_msg_delete ========
  *  Purpose:
- *      Delete a MSG manager allocated in WMD_MSG_Create().
+ *      Delete a msg_ctrl manager allocated in bridge_msg_create().
  *  Parameters:
- *      hMsgMgr:    Handle returned from WMD_MSG_Create().
+ *      hmsg_mgr:    Handle returned from bridge_msg_create().
  *  Returns:
  *  Requires:
- *      Valid hMsgMgr.
+ *      Valid hmsg_mgr.
  *  Ensures:
  */
-       typedef void(*WMD_MSG_DELETE) (struct MSG_MGR *hMsgMgr);
+typedef void (*fxn_msg_delete) (struct msg_mgr *hmsg_mgr);
 
 /*
- *  ======== WMD_MSG_DeleteQueue ========
+ *  ======== bridge_msg_delete_queue ========
  *  Purpose:
- *      Delete a MSG queue allocated in WMD_MSG_CreateQueue.
+ *      Delete a msg_ctrl queue allocated in bridge_msg_create_queue.
  *  Parameters:
- *      hMsgQueue:  Handle to MSG queue returned from
- *                  WMD_MSG_CreateQueue.
+ *      msg_queue_obj:  Handle to msg_ctrl queue returned from
+ *                  bridge_msg_create_queue.
  *  Returns:
  *  Requires:
- *      Valid hMsgQueue.
+ *      Valid msg_queue_obj.
  *  Ensures:
  */
-       typedef void(*WMD_MSG_DELETEQUEUE) (struct MSG_QUEUE *hMsgQueue);
+typedef void (*fxn_msg_deletequeue) (struct msg_queue *msg_queue_obj);
 
 /*
- *  ======== WMD_MSG_Get ========
+ *  ======== bridge_msg_get ========
  *  Purpose:
- *      Get a message from a MSG queue.
+ *      Get a message from a msg_ctrl queue.
  *  Parameters:
- *      hMsgQueue:     Handle to MSG queue returned from
- *                     WMD_MSG_CreateQueue.
- *      pMsg:          Location to copy message into.
- *      uTimeout:      Timeout to wait for a message.
+ *      msg_queue_obj:     Handle to msg_ctrl queue returned from
+ *                     bridge_msg_create_queue.
+ *      pmsg:          Location to copy message into.
+ *      utimeout:      Timeout to wait for a message.
  *  Returns:
  *      DSP_SOK:       Success.
  *      DSP_ETIMEOUT:  Timeout occurred.
- *      DSP_EFAIL:     No frames available for message (uMaxMessages too
+ *      DSP_EFAIL:     No frames available for message (max_msgs too
  *                     small).
  *  Requires:
- *      Valid hMsgQueue.
- *      pMsg != NULL.
+ *      Valid msg_queue_obj.
+ *      pmsg != NULL.
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_MSG_GET) (struct MSG_QUEUE *hMsgQueue,
-						 struct DSP_MSG *pMsg,
-						 u32 uTimeout);
+typedef dsp_status(*fxn_msg_get) (struct msg_queue *msg_queue_obj,
+				  struct dsp_msg *pmsg, u32 utimeout);
 
 /*
- *  ======== WMD_MSG_Put ========
+ *  ======== bridge_msg_put ========
  *  Purpose:
- *      Put a message onto a MSG queue.
+ *      Put a message onto a msg_ctrl queue.
  *  Parameters:
- *      hMsgQueue:      Handle to MSG queue returned from
- *                      WMD_MSG_CreateQueue.
- *      pMsg:           Pointer to message.
- *      uTimeout:       Timeout to wait for a message.
+ *      msg_queue_obj:      Handle to msg_ctrl queue returned from
+ *                      bridge_msg_create_queue.
+ *      pmsg:           Pointer to message.
+ *      utimeout:       Timeout to wait for a message.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_ETIMEOUT:   Timeout occurred.
- *      DSP_EFAIL:      No frames available for message (uMaxMessages too
+ *      DSP_EFAIL:      No frames available for message (max_msgs too
  *                      small).
  *  Requires:
- *      Valid hMsgQueue.
- *      pMsg != NULL.
+ *      Valid msg_queue_obj.
+ *      pmsg != NULL.
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_MSG_PUT) (struct MSG_QUEUE *hMsgQueue,
-						 IN CONST struct DSP_MSG *pMsg,
-						 u32 uTimeout);
+typedef dsp_status(*fxn_msg_put) (struct msg_queue *msg_queue_obj,
+				  IN CONST struct dsp_msg *pmsg, u32 utimeout);
 
 /*
- *  ======== WMD_MSG_RegisterNotify ========
+ *  ======== bridge_msg_register_notify ========
  *  Purpose:
  *      Register notification for when a message is ready.
  *  Parameters:
- *      hMsgQueue:      Handle to MSG queue returned from
- *                      WMD_MSG_CreateQueue.
- *      uEventMask:     Type of events to be notified about: Must be
+ *      msg_queue_obj:      Handle to msg_ctrl queue returned from
+ *                      bridge_msg_create_queue.
+ *      event_mask:     Type of events to be notified about: Must be
  *                      DSP_NODEMESSAGEREADY, or 0 to unregister.
- *      uNotifyType:    DSP_SIGNALEVENT.
- *      hNotification:  Handle of notification object.
+ *      notify_type:    DSP_SIGNALEVENT.
+ *      hnotification:  Handle of notification object.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Insufficient memory.
  *  Requires:
- *      Valid hMsgQueue.
- *      hNotification != NULL.
- *      uNotifyType == DSP_SIGNALEVENT.
- *      uEventMask == DSP_NODEMESSAGEREADY || uEventMask == 0.
+ *      Valid msg_queue_obj.
+ *      hnotification != NULL.
+ *      notify_type == DSP_SIGNALEVENT.
+ *      event_mask == DSP_NODEMESSAGEREADY || event_mask == 0.
  *  Ensures:
  */
-       typedef DSP_STATUS(*WMD_MSG_REGISTERNOTIFY)
-				(struct MSG_QUEUE *hMsgQueue,
-				u32 uEventMask, u32 uNotifyType,
-				struct DSP_NOTIFICATION *hNotification);
+typedef dsp_status(*fxn_msg_registernotify)
+ (struct msg_queue *msg_queue_obj,
+  u32 event_mask, u32 notify_type, struct dsp_notification *hnotification);
 
 /*
- *  ======== WMD_MSG_SetQueueId ========
+ *  ======== bridge_msg_set_queue_id ========
  *  Purpose:
- *      Set message queue id to node environment. Allows WMD_MSG_CreateQueue
- *      to be called in NODE_Allocate, before the node environment is known.
+ *      Set message queue id to node environment. Allows bridge_msg_create_queue
+ *      to be called in node_allocate, before the node environment is known.
  *  Parameters:
- *      hMsgQueue:  Handle to MSG queue returned from
- *                  WMD_MSG_CreateQueue.
- *      dwId:       Node environment pointer.
+ *      msg_queue_obj:  Handle to msg_ctrl queue returned from
+ *                  bridge_msg_create_queue.
+ *      msgq_id:       Node environment pointer.
  *  Returns:
  *  Requires:
- *      Valid hMsgQueue.
- *      dwId != 0.
+ *      Valid msg_queue_obj.
+ *      msgq_id != 0.
  *  Ensures:
  */
-       typedef void(*WMD_MSG_SETQUEUEID) (struct MSG_QUEUE *hMsgQueue,
-						  u32 dwId);
+typedef void (*fxn_msg_setqueueid) (struct msg_queue *msg_queue_obj,
+				    u32 msgq_id);
 
 /*
  *  'Bridge Mini Driver (WMD) interface function table.
@@ -1112,64 +1054,64 @@
  *  A mini-driver need not export a CHNL interface.  In this case, *all* of
  *  the WMD_CHNL_* entries must be set to NULL.
  */
-	struct WMD_DRV_INTERFACE {
-		u32 dwWCDMajorVersion;	/* Set to WCD_MAJOR_VERSION. */
-		u32 dwWCDMinorVersion;	/* Set to WCD_MINOR_VERSION. */
-		WMD_DEV_CREATE pfnDevCreate;	/* Create device context     */
-		WMD_DEV_DESTROY pfnDevDestroy;	/* Destroy device context    */
-		WMD_DEV_CTRL pfnDevCntrl;	/* Optional vendor interface */
-		WMD_BRD_MONITOR pfnBrdMonitor;	/* Load and/or start monitor */
-		WMD_BRD_START pfnBrdStart;	/* Start DSP program.        */
-		WMD_BRD_STOP pfnBrdStop;	/* Stop/reset board.         */
-		WMD_BRD_STATUS pfnBrdStatus;	/* Get current board status. */
-		WMD_BRD_READ pfnBrdRead;	/* Read board memory         */
-		WMD_BRD_WRITE pfnBrdWrite;	/* Write board memory.       */
-		WMD_BRD_SETSTATE pfnBrdSetState;  /* Sets the Board State */
-		WMD_BRD_MEMCOPY pfnBrdMemCopy;	 /* Copies DSP Memory         */
-		WMD_BRD_MEMWRITE pfnBrdMemWrite; /* Write DSP Memory w/o halt */
-		WMD_BRD_MEMMAP pfnBrdMemMap;	 /* Maps MPU mem to DSP mem   */
-		WMD_BRD_MEMUNMAP pfnBrdMemUnMap; /* Unmaps MPU mem to DSP mem */
-		WMD_CHNL_CREATE pfnChnlCreate;	 /* Create channel manager.   */
-		WMD_CHNL_DESTROY pfnChnlDestroy; /* Destroy channel manager.  */
-		WMD_CHNL_OPEN pfnChnlOpen;	 /* Create a new channel.     */
-		WMD_CHNL_CLOSE pfnChnlClose;	 /* Close a channel.          */
-		WMD_CHNL_ADDIOREQ pfnChnlAddIOReq; /* Req I/O on a channel. */
-		WMD_CHNL_GETIOC pfnChnlGetIOC;	 /* Wait for I/O completion.  */
-		WMD_CHNL_CANCELIO pfnChnlCancelIO; /* Cancl I/O on a channel. */
-		WMD_CHNL_FLUSHIO pfnChnlFlushIO;	/* Flush I/O.         */
-		WMD_CHNL_GETINFO pfnChnlGetInfo; /* Get channel specific info */
-		/* Get channel manager info. */
-		WMD_CHNL_GETMGRINFO pfnChnlGetMgrInfo;
-		WMD_CHNL_IDLE pfnChnlIdle;	/* Idle the channel */
-		/* Register for notif. */
-		WMD_CHNL_REGISTERNOTIFY pfnChnlRegisterNotify;
-		WMD_DEH_CREATE pfnDehCreate;	/* Create DEH manager */
-		WMD_DEH_DESTROY pfnDehDestroy;	/* Destroy DEH manager */
-		WMD_DEH_NOTIFY pfnDehNotify;    /* Notify of DSP error */
-		/* register for deh notif. */
-		WMD_DEH_REGISTERNOTIFY pfnDehRegisterNotify;
-		WMD_DEH_GETINFO pfnDehGetInfo;	/* register for deh notif. */
-		WMD_IO_CREATE pfnIOCreate;	/* Create IO manager */
-		WMD_IO_DESTROY pfnIODestroy;	/* Destroy IO manager */
-		WMD_IO_ONLOADED pfnIOOnLoaded;	/* Notify of program loaded */
-		/* Get Processor's current and predicted load */
-		WMD_IO_GETPROCLOAD pfnIOGetProcLoad;
-		WMD_MSG_CREATE pfnMsgCreate;	/* Create message manager */
-		/* Create message queue */
-		WMD_MSG_CREATEQUEUE pfnMsgCreateQueue;
-		WMD_MSG_DELETE pfnMsgDelete;	/* Delete message manager */
-		/* Delete message queue */
-		WMD_MSG_DELETEQUEUE pfnMsgDeleteQueue;
-		WMD_MSG_GET pfnMsgGet;	/* Get a message */
-		WMD_MSG_PUT pfnMsgPut;	/* Send a message */
-		/* Register for notif. */
-		WMD_MSG_REGISTERNOTIFY pfnMsgRegisterNotify;
-		/* Set message queue id */
-		WMD_MSG_SETQUEUEID pfnMsgSetQueueId;
-	} ;
+struct bridge_drv_interface {
+	u32 dw_wcd_major_version;	/* Set to WCD_MAJOR_VERSION. */
+	u32 dw_wcd_minor_version;	/* Set to WCD_MINOR_VERSION. */
+	fxn_dev_create pfn_dev_create;	/* Create device context */
+	fxn_dev_destroy pfn_dev_destroy;	/* Destroy device context */
+	fxn_dev_ctrl pfn_dev_cntrl;	/* Optional vendor interface */
+	fxn_brd_monitor pfn_brd_monitor;	/* Load and/or start monitor */
+	fxn_brd_start pfn_brd_start;	/* Start DSP program. */
+	fxn_brd_stop pfn_brd_stop;	/* Stop/reset board. */
+	fxn_brd_status pfn_brd_status;	/* Get current board status. */
+	fxn_brd_read pfn_brd_read;	/* Read board memory */
+	fxn_brd_write pfn_brd_write;	/* Write board memory. */
+	fxn_brd_setstate pfn_brd_set_state;	/* Sets the Board State */
+	fxn_brd_memcopy pfn_brd_mem_copy;	/* Copies DSP Memory */
+	fxn_brd_memwrite pfn_brd_mem_write;	/* Write DSP Memory w/o halt */
+	fxn_brd_memmap pfn_brd_mem_map;	/* Maps MPU mem to DSP mem */
+	fxn_brd_memunmap pfn_brd_mem_un_map;	/* Unmaps MPU mem to DSP mem */
+	fxn_chnl_create pfn_chnl_create;	/* Create channel manager. */
+	fxn_chnl_destroy pfn_chnl_destroy;	/* Destroy channel manager. */
+	fxn_chnl_open pfn_chnl_open;	/* Create a new channel. */
+	fxn_chnl_close pfn_chnl_close;	/* Close a channel. */
+	fxn_chnl_addioreq pfn_chnl_add_io_req;	/* Req I/O on a channel. */
+	fxn_chnl_getioc pfn_chnl_get_ioc;	/* Wait for I/O completion. */
+	fxn_chnl_cancelio pfn_chnl_cancel_io;	/* Cancl I/O on a channel. */
+	fxn_chnl_flushio pfn_chnl_flush_io;	/* Flush I/O. */
+	fxn_chnl_getinfo pfn_chnl_get_info;	/* Get channel specific info */
+	/* Get channel manager info. */
+	fxn_chnl_getmgrinfo pfn_chnl_get_mgr_info;
+	fxn_chnl_idle pfn_chnl_idle;	/* Idle the channel */
+	/* Register for notif. */
+	fxn_chnl_registernotify pfn_chnl_register_notify;
+	fxn_deh_create pfn_deh_create;	/* Create DEH manager */
+	fxn_deh_destroy pfn_deh_destroy;	/* Destroy DEH manager */
+	fxn_deh_notify pfn_deh_notify;	/* Notify of DSP error */
+	/* register for deh notif. */
+	fxn_deh_registernotify pfn_deh_register_notify;
+	fxn_deh_getinfo pfn_deh_get_info;	/* register for deh notif. */
+	fxn_io_create pfn_io_create;	/* Create IO manager */
+	fxn_io_destroy pfn_io_destroy;	/* Destroy IO manager */
+	fxn_io_onloaded pfn_io_on_loaded;	/* Notify of program loaded */
+	/* Get Processor's current and predicted load */
+	fxn_io_getprocload pfn_io_get_proc_load;
+	fxn_msg_create pfn_msg_create;	/* Create message manager */
+	/* Create message queue */
+	fxn_msg_createqueue pfn_msg_create_queue;
+	fxn_msg_delete pfn_msg_delete;	/* Delete message manager */
+	/* Delete message queue */
+	fxn_msg_deletequeue pfn_msg_delete_queue;
+	fxn_msg_get pfn_msg_get;	/* Get a message */
+	fxn_msg_put pfn_msg_put;	/* Send a message */
+	/* Register for notif. */
+	fxn_msg_registernotify pfn_msg_register_notify;
+	/* Set message queue id */
+	fxn_msg_setqueueid pfn_msg_set_queue_id;
+};
 
 /*
- *  ======== WMD_DRV_Entry ========
+ *  ======== bridge_drv_entry ========
  *  Purpose:
  *      Registers WMD functions with the class driver. Called only once
  *      by the WCD.  The caller will first check WCD version compatibility, and
@@ -1187,7 +1129,7 @@
  *  Details:
  *      Win95: Called during the Device_Init phase.
  */
-       void WMD_DRV_Entry(OUT struct WMD_DRV_INTERFACE **ppDrvInterface,
-				 IN CONST char *pstrWMDFileName);
+void bridge_drv_entry(OUT struct bridge_drv_interface **ppDrvInterface,
+		   IN CONST char *pstrWMDFileName);
 
-#endif				/* WMD_ */
+#endif /* WMD_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wmdioctl.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wmdioctl.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wmdioctl.h	2011-10-11 13:50:58.983481606 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wmdioctl.h	2011-10-29 20:34:30.467753274 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * BRIDGE Minidriver BRD_IOCtl reserved command definitions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,30 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== wmdioctl.h ========
- *  Description:
- *    BRIDGE Minidriver BRD_IOCtl reserved command definitions.
- *
- *! Revision History
- *! ================
- *! 19-Apr-2004 sb   Updated HW typedefs
- *! 16-Feb-2004 vp   Added MMU endianness attributes to WMDIOCTL_EXTPROC
- *! 21-Mar-2003 sb   Changed WMDIOCTL_NUMOFMMUTLB from 7 to 32
- *! 14-May-2001 sg   Added codes for PWR.
- *! 10-Aug-2001 ag   Added _SETMMUCONFIG ioctl used for DSP-MMU init.
- *! 16-Nov-1999 rajesh ?
- *! 18-Jun-1998 ag   Moved EMIF, SDRAM_C, & CE space init to ENBLEXTMEM ioctl.
- *!                  Added ENBLEXTMEM, RESETDSP, UNRESETDSP & ASSERTSIG ioctls.
- *! 07-Jun-1998 ag   Added JTAG_SELECT, MAP_TBC, GET_CONFIGURATION ioctls.
- *! 26-Jan-1998 jeh: Added START, RECV, and SEND ioctls.
- *! 07-Nov-1997 nn:  Added command to interrupt DSP for interrupt test.
- *! 20-Oct-1997 nn:  Added commands for getting and resetting interrupt count.
- *! 17-Oct-1997 gp:  Moved to src/wmd. Standardized prefix.
- *! 08-Oct-1997 nn:  Created.
- */
-
 #ifndef WMDIOCTL_
 #define WMDIOCTL_
 
@@ -45,7 +23,10 @@
 #include <hw_defs.h>
 #include <hw_mmu.h>
 
-/* Any IOCTLS at or above this value are reserved for standard WMD interfaces.*/
+/*
+ * Any IOCTLS at or above this value are reserved for standard WMD
+ * interfaces.
+ */
 #define WMDIOCTL_RESERVEDBASE       0x8000
 
 #define WMDIOCTL_CHNLREAD           (WMDIOCTL_RESERVEDBASE + 0x10)
@@ -53,8 +34,10 @@
 #define WMDIOCTL_GETINTRCOUNT       (WMDIOCTL_RESERVEDBASE + 0x30)
 #define WMDIOCTL_RESETINTRCOUNT     (WMDIOCTL_RESERVEDBASE + 0x40)
 #define WMDIOCTL_INTERRUPTDSP       (WMDIOCTL_RESERVEDBASE + 0x50)
-#define WMDIOCTL_SETMMUCONFIG       (WMDIOCTL_RESERVEDBASE + 0x60)   /* DMMU */
-#define WMDIOCTL_PWRCONTROL         (WMDIOCTL_RESERVEDBASE + 0x70)   /* PWR */
+/* DMMU */
+#define WMDIOCTL_SETMMUCONFIG       (WMDIOCTL_RESERVEDBASE + 0x60)
+/* PWR */
+#define WMDIOCTL_PWRCONTROL         (WMDIOCTL_RESERVEDBASE + 0x70)
 
 /* attention, modifiers:
  * Some of these control enumerations are made visible to user for power
@@ -67,8 +50,8 @@
 #define WMDIOCTL_PWRENABLE          (WMDIOCTL_PWRCONTROL + 0x3)
 #define WMDIOCTL_PWRDISABLE         (WMDIOCTL_PWRCONTROL + 0x4)
 #define WMDIOCTL_CLK_CTRL		    (WMDIOCTL_PWRCONTROL + 0x7)
-#define WMDIOCTL_PWR_HIBERNATE (WMDIOCTL_PWRCONTROL + 0x8) /*DSP Initiated
-							    * Hibernate*/
+/* DSP Initiated Hibernate */
+#define WMDIOCTL_PWR_HIBERNATE	(WMDIOCTL_PWRCONTROL + 0x8)
 #define WMDIOCTL_PRESCALE_NOTIFY (WMDIOCTL_PWRCONTROL + 0x9)
 #define WMDIOCTL_POSTSCALE_NOTIFY (WMDIOCTL_PWRCONTROL + 0xA)
 #define WMDIOCTL_CONSTRAINT_REQUEST (WMDIOCTL_PWRCONTROL + 0xB)
@@ -76,16 +59,15 @@
 /* Number of actual DSP-MMU TLB entrries */
 #define WMDIOCTL_NUMOFMMUTLB        32
 
-struct WMDIOCTL_EXTPROC {
-	u32 ulDspVa;		/* DSP virtual address */
-	u32 ulGppPa;		/* GPP physical address */
+struct wmdioctl_extproc {
+	u32 ul_dsp_va;		/* DSP virtual address */
+	u32 ul_gpp_pa;		/* GPP physical address */
 	/* GPP virtual address. __va does not work for ioremapped addresses */
-	u32 ulGppVa;
-	u32 ulSize;		/* Size of the mapped memory in bytes */
-	enum HW_Endianism_t endianism;
-	enum HW_MMUMixedSize_t mixedMode;
-	enum HW_ElementSize_t elemSize;
+	u32 ul_gpp_va;
+	u32 ul_size;		/* Size of the mapped memory in bytes */
+	enum hw_endianism_t endianism;
+	enum hw_mmu_mixed_size_t mixed_mode;
+	enum hw_element_size_t elem_size;
 };
 
-#endif				/* WMDIOCTL_ */
-
+#endif /* WMDIOCTL_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wmdio.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wmdio.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wmdio.h	2011-10-11 13:50:58.983481606 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wmdio.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,12 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Declares the upper edge IO functions required by all WMD / WCD
+ * driver interface tables.
+ *
+ * Notes:
+ *   Function comment headers reside in wmd.h.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,40 +20,22 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== wmdio.h ========
- *  Description:
- *      Declares the upper edge IO  functions required by
- *      all WMD / WCD driver interface tables.
- *
- *  Public Functions:
- *
- *  Notes:
- *      Function comment headers reside with the function typedefs in wmd.h.
- *
- *! Revision History:
- *! ================
- *! 27-Feb-2004 vp		Added IVA releated function.
- *! 06-Nov-2000 jeh     Created.
- */
-
 #ifndef WMDIO_
 #define WMDIO_
 
 #include <dspbridge/devdefs.h>
 #include <dspbridge/iodefs.h>
 
-	extern DSP_STATUS WMD_IO_Create(OUT struct IO_MGR **phIOMgr,
-					struct DEV_OBJECT *hDevObject,
-					IN CONST struct IO_ATTRS *pMgrAttrs);
+extern dsp_status bridge_io_create(OUT struct io_mgr **phIOMgr,
+				   struct dev_object *hdev_obj,
+				   IN CONST struct io_attrs *pMgrAttrs);
 
-	extern DSP_STATUS WMD_IO_Destroy(struct IO_MGR *hIOMgr);
+extern dsp_status bridge_io_destroy(struct io_mgr *hio_mgr);
 
-	extern DSP_STATUS WMD_IO_OnLoaded(struct IO_MGR *hIOMgr);
+extern dsp_status bridge_io_on_loaded(struct io_mgr *hio_mgr);
 
-	extern DSP_STATUS IVA_IO_OnLoaded(struct IO_MGR *hIOMgr);
-	extern DSP_STATUS WMD_IO_GetProcLoad(IN struct IO_MGR *hIOMgr,
-				OUT struct DSP_PROCLOADSTAT *pProcStat);
+extern dsp_status iva_io_on_loaded(struct io_mgr *hio_mgr);
+extern dsp_status bridge_io_get_proc_load(IN struct io_mgr *hio_mgr,
+				       OUT struct dsp_procloadstat *pProcStat);
 
-#endif				/* WMDIO_ */
+#endif /* WMDIO_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wmdmsg.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wmdmsg.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/dspbridge/wmdmsg.h	2011-10-11 13:50:58.990498562 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/dspbridge/wmdmsg.h	2011-08-19 18:42:46.000000000 +0100
@@ -3,6 +3,13 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Declares the upper edge message class library functions required by
+ * all WMD / WCD driver interface tables.  These functions are
+ * implemented by every class of WMD channel library.
+ *
+ * Notes:
+ *   Function comment headers reside in wmd.h.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,57 +21,35 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== wmdmsg.h ========
- *  Description:
- *      Declares the upper edge message class library functions required by
- *      all WMD / WCD driver interface tables.  These functions are
- *      implemented by every class of WMD channel library.
- *
- *  Public Functions:
- *
- *  Notes:
- *      Function comment headers reside with the function typedefs in wmd.h.
- *
- *! Revision History:
- *! ================
- *! 06-Dec-2000 jeh     Added uEventMask to WMD_MSG_RegisterNotify(). Added
- *!                     WMD_MSG_SetQueueId().
- *! 17-Nov-2000 jeh     Created.
- */
-
 #ifndef WMDMSG_
 #define WMDMSG_
 
 #include <dspbridge/msgdefs.h>
 
-	extern DSP_STATUS WMD_MSG_Create(OUT struct MSG_MGR **phMsgMgr,
-					 struct DEV_OBJECT *hDevObject,
-					 MSG_ONEXIT msgCallback);
+extern dsp_status bridge_msg_create(OUT struct msg_mgr **phMsgMgr,
+				    struct dev_object *hdev_obj,
+				    msg_onexit msgCallback);
 
-	extern DSP_STATUS WMD_MSG_CreateQueue(struct MSG_MGR *hMsgMgr,
-					      OUT struct MSG_QUEUE **phMsgQueue,
-					      u32 dwId, u32 uMaxMsgs,
-					      HANDLE h);
+extern dsp_status bridge_msg_create_queue(struct msg_mgr *hmsg_mgr,
+				       OUT struct msg_queue **phMsgQueue,
+				       u32 msgq_id, u32 max_msgs, bhandle h);
 
-	extern void WMD_MSG_Delete(struct MSG_MGR *hMsgMgr);
+extern void bridge_msg_delete(struct msg_mgr *hmsg_mgr);
 
-	extern void WMD_MSG_DeleteQueue(struct MSG_QUEUE *hMsgQueue);
+extern void bridge_msg_delete_queue(struct msg_queue *msg_queue_obj);
 
-	extern DSP_STATUS WMD_MSG_Get(struct MSG_QUEUE *hMsgQueue,
-				      struct DSP_MSG *pMsg, u32 uTimeout);
+extern dsp_status bridge_msg_get(struct msg_queue *msg_queue_obj,
+				 struct dsp_msg *pmsg, u32 utimeout);
 
-	extern DSP_STATUS WMD_MSG_Put(struct MSG_QUEUE *hMsgQueue,
-				      IN CONST struct DSP_MSG *pMsg,
-				      u32 uTimeout);
+extern dsp_status bridge_msg_put(struct msg_queue *msg_queue_obj,
+				 IN CONST struct dsp_msg *pmsg, u32 utimeout);
 
-	extern DSP_STATUS WMD_MSG_RegisterNotify(struct MSG_QUEUE *hMsgQueue,
-						 u32 uEventMask,
-						 u32 uNotifyType,
-						 struct DSP_NOTIFICATION
-						 *hNotification);
+extern dsp_status bridge_msg_register_notify(struct msg_queue *msg_queue_obj,
+					  u32 event_mask,
+					  u32 notify_type,
+					  struct dsp_notification
+					  *hnotification);
 
-	extern void WMD_MSG_SetQueueId(struct MSG_QUEUE *hMsgQueue, u32 dwId);
+extern void bridge_msg_set_queue_id(struct msg_queue *msg_queue_obj, u32 msgq_id);
 
-#endif				/* WMDMSG_ */
+#endif /* WMDMSG_ */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/mach/mailbox.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/mach/mailbox.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/mach/mailbox.h	2011-10-11 13:50:52.228594642 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/mach/mailbox.h	2011-10-11 17:47:23.155624000 +0100
@@ -5,10 +5,10 @@
 
 #include <linux/wait.h>
 #include <linux/workqueue.h>
-#include <linux/blkdev.h>
+#include <linux/interrupt.h>
+#include <mach/mboxkfifo.h>
 
 typedef u32 mbox_msg_t;
-typedef void (mbox_receiver_t)(mbox_msg_t msg);
 struct omap_mbox;
 
 typedef int __bitwise omap_mbox_irq_t;
@@ -29,8 +29,10 @@
 	int		(*fifo_empty)(struct omap_mbox *mbox);
 	int		(*fifo_full)(struct omap_mbox *mbox);
 	/* irq */
-	void		(*enable_irq)(struct omap_mbox *mbox, omap_mbox_irq_t irq);
-	void		(*disable_irq)(struct omap_mbox *mbox, omap_mbox_irq_t irq);
+	void		(*enable_irq)(struct omap_mbox *mbox,
+						omap_mbox_irq_t irq);
+	void		(*disable_irq)(struct omap_mbox *mbox,
+						omap_mbox_irq_t irq);
 	void		(*ack_irq)(struct omap_mbox *mbox, omap_mbox_irq_t irq);
 	int		(*is_irq)(struct omap_mbox *mbox, omap_mbox_irq_t irq);
 	/* ctx */
@@ -40,8 +42,9 @@
 
 struct omap_mbox_queue {
 	spinlock_t		lock;
-	struct request_queue	*queue;
+	struct mbox_kfifo	fifo;
 	struct work_struct	work;
+	struct tasklet_struct	tasklet;
 	int	(*callback)(void *);
 	struct omap_mbox	*mbox;
 };
@@ -64,7 +67,7 @@
 	void			(*err_notify)(void);
 };
 
-int omap_mbox_msg_send(struct omap_mbox *, mbox_msg_t msg, void *);
+int omap_mbox_msg_send(struct omap_mbox *, mbox_msg_t msg);
 void omap_mbox_init_seq(struct omap_mbox *);
 
 struct omap_mbox *omap_mbox_get(const char *);
@@ -93,4 +96,16 @@
 	mbox->ops->restore_ctx(mbox);
 }
 
+static inline void omap_mbox_enable_irq(struct omap_mbox *mbox,
+					omap_mbox_irq_t irq)
+{
+	mbox->ops->enable_irq(mbox, irq);
+}
+
+static inline void omap_mbox_disable_irq(struct omap_mbox *mbox,
+					 omap_mbox_irq_t irq)
+{
+	mbox->ops->disable_irq(mbox, irq);
+}
+
 #endif /* MAILBOX_H */
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/include/mach/mboxkfifo.h kernel-power-2.6.28.new/arch/arm/plat-omap/include/mach/mboxkfifo.h
--- kernel-cssu-2.6.28/arch/arm/plat-omap/include/mach/mboxkfifo.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/include/mach/mboxkfifo.h	2011-10-11 17:40:03.093441000 +0100
@@ -0,0 +1,615 @@
+/*
+ * A generic kernel FIFO implementation.
+ *
+ * Copyright (C) 2009 Stefani Seibold <stefani@seibold.net>
+ * Copyright (C) 2004 Stelian Pop <stelian@popies.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+/*
+ * Howto porting drivers to the new generic fifo API:
+ *
+ * - Modify the declaration of the "struct mbox_kfifo *" object into a
+ *   in-place "struct mbox_kfifo" object
+ * - Init the in-place object with mbox_kfifo_alloc() or mbox_kfifo_init()
+ *   Note: The address of the in-place "struct mbox_kfifo" object must be
+ *   passed as the first argument to this functions
+ * - Replace the use of __mbox_kfifo_put into mbox_kfifo_in and __mbox_kfifo_get
+ *   into mbox_kfifo_out
+ * - Replace the use of mbox_kfifo_put into mbox_kfifo_in_locked and mbox_kfifo_get
+ *   into mbox_kfifo_out_locked
+ *   Note: the spinlock pointer formerly passed to mbox_kfifo_init/mbox_kfifo_alloc
+ *   must be passed now to the mbox_kfifo_in_locked and mbox_kfifo_out_locked
+ *   as the last parameter.
+ * - All formerly name __mbox_kfifo_* functions has been renamed into mbox_kfifo_*
+ */
+
+#ifndef _LINUX_MBOX_KFIFO_H
+#define _LINUX_MBOX_KFIFO_H
+
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+
+struct mbox_kfifo {
+        unsigned char *buffer;  /* the buffer holding the data */
+        unsigned int size;      /* the size of the allocated buffer */
+        unsigned int in;        /* data is added at offset (in % size) */
+        unsigned int out;       /* data is extracted from off. (out % size) */
+};
+
+/*
+ * Macros for declaration and initialization of the mbox_kfifo datatype
+ */
+
+/* helper macro */
+#define __mbox_kfifo_initializer(s, b) \
+        (struct mbox_kfifo) { \
+                .size   = s, \
+                .in     = 0, \
+                .out    = 0, \
+                .buffer = b \
+        }
+
+/**
+ * DECLARE_MBOX_KFIFO - macro to declare a mbox_kfifo and the associated buffer
+ * @name: name of the declared mbox_kfifo datatype
+ * @size: size of the fifo buffer. Must be a power of two.
+ *
+ * Note1: the macro can be used inside struct or union declaration
+ * Note2: the macro creates two objects:
+ *  A mbox_kfifo object with the given name and a buffer for the mbox_kfifo
+ *  object named name##mbox_kfifo_buffer
+ */
+#define DECLARE_MBOX_KFIFO(name, size) \
+union { \
+        struct mbox_kfifo name; \
+        unsigned char name##mbox_kfifo_buffer[size + sizeof(struct mbox_kfifo)]; \
+}
+
+/**
+ * INIT_MBOX_KFIFO - Initialize a mbox_kfifo declared by DECLARE_mbox_kfifo
+ * @name: name of the declared mbox_kfifo datatype
+ */
+#define INIT_MBOX_KFIFO(name) \
+        name = __mbox_kfifo_initializer(sizeof(name##mbox_kfifo_buffer) - \
+                                sizeof(struct mbox_kfifo), \
+                                name##mbox_kfifo_buffer + sizeof(struct mbox_kfifo))
+
+/**
+ * DEFINE_MBOX_KFIFO - macro to define and initialize a mbox_kfifo
+ * @name: name of the declared mbox_kfifo datatype
+ * @size: size of the fifo buffer. Must be a power of two.
+ *
+ * Note1: the macro can be used for global and local mbox_kfifo data type variables
+ * Note2: the macro creates two objects:
+ *  A mbox_kfifo object with the given name and a buffer for the mbox_kfifo
+ *  object named name##mbox_kfifo_buffer
+ */
+#define DEFINE_MBOX_KFIFO(name, size) \
+        unsigned char name##mbox_kfifo_buffer[size]; \
+        struct mbox_kfifo name = __mbox_kfifo_initializer(size, name##mbox_kfifo_buffer)
+
+extern void mbox_kfifo_init(struct mbox_kfifo *fifo, void *buffer,
+                        unsigned int size);
+extern __must_check int mbox_kfifo_alloc(struct mbox_kfifo *fifo, unsigned int size,
+                        gfp_t gfp_mask);
+extern void mbox_kfifo_free(struct mbox_kfifo *fifo);
+extern unsigned int mbox_kfifo_in(struct mbox_kfifo *fifo,
+                                const void *from, unsigned int len);
+extern __must_check unsigned int mbox_kfifo_out(struct mbox_kfifo *fifo,
+                                void *to, unsigned int len);
+extern __must_check unsigned int mbox_kfifo_out_peek(struct mbox_kfifo *fifo,
+                                void *to, unsigned int len, unsigned offset);
+
+/**
+ * mbox_kfifo_initialized - Check if mbox_kfifo is initialized.
+ * @fifo: fifo to check
+ * Return %true if FIFO is initialized, otherwise %false.
+ * Assumes the fifo was 0 before.
+ */
+static inline bool mbox_kfifo_initialized(struct mbox_kfifo *fifo)
+{
+        return fifo->buffer != NULL;
+}
+
+/**
+ * mbox_kfifo_reset - removes the entire FIFO contents
+ * @fifo: the fifo to be emptied.
+ */
+static inline void mbox_kfifo_reset(struct mbox_kfifo *fifo)
+{
+        fifo->in = fifo->out = 0;
+}
+
+/**
+ * mbox_kfifo_reset_out - skip FIFO contents
+ * @fifo: the fifo to be emptied.
+ */
+static inline void mbox_kfifo_reset_out(struct mbox_kfifo *fifo)
+{
+        smp_mb();
+        fifo->out = fifo->in;
+}
+
+/**
+ * mbox_kfifo_size - returns the size of the fifo in bytes
+ * @fifo: the fifo to be used.
+ */
+static inline __must_check unsigned int mbox_kfifo_size(struct mbox_kfifo *fifo)
+{
+        return fifo->size;
+}
+
+/**
+ * mbox_kfifo_len - returns the number of used bytes in the FIFO
+ * @fifo: the fifo to be used.
+ */
+static inline unsigned int mbox_kfifo_len(struct mbox_kfifo *fifo)
+{
+        register unsigned int   out;
+
+        out = fifo->out;
+        smp_rmb();
+        return fifo->in - out;
+}
+
+/**
+ * mbox_kfifo_is_empty - returns true if the fifo is empty
+ * @fifo: the fifo to be used.
+ */
+static inline __must_check int mbox_kfifo_is_empty(struct mbox_kfifo *fifo)
+{
+        return fifo->in == fifo->out;
+}
+
+/**
+ * mbox_kfifo_is_full - returns true if the fifo is full
+ * @fifo: the fifo to be used.
+ */
+static inline __must_check int mbox_kfifo_is_full(struct mbox_kfifo *fifo)
+{
+        return mbox_kfifo_len(fifo) == mbox_kfifo_size(fifo);
+}
+
+/**
+ * mbox_kfifo_avail - returns the number of bytes available in the FIFO
+ * @fifo: the fifo to be used.
+ */
+static inline __must_check unsigned int mbox_kfifo_avail(struct mbox_kfifo *fifo)
+{
+        return mbox_kfifo_size(fifo) - mbox_kfifo_len(fifo);
+}
+
+/**
+ * mbox_kfifo_in_locked - puts some data into the FIFO using a spinlock for locking
+ * @fifo: the fifo to be used.
+ * @from: the data to be added.
+ * @n: the length of the data to be added.
+ * @lock: pointer to the spinlock to use for locking.
+ *
+ * This function copies at most @len bytes from the @from buffer into
+ * the FIFO depending on the free space, and returns the number of
+ * bytes copied.
+ */
+static inline unsigned int mbox_kfifo_in_locked(struct mbox_kfifo *fifo,
+                const void *from, unsigned int n, spinlock_t *lock)
+{
+        unsigned long flags;
+        unsigned int ret;
+
+        spin_lock_irqsave(lock, flags);
+
+        ret = mbox_kfifo_in(fifo, from, n);
+
+        spin_unlock_irqrestore(lock, flags);
+
+        return ret;
+}
+
+/**
+ * mbox_kfifo_out_locked - gets some data from the FIFO using a spinlock for locking
+ * @fifo: the fifo to be used.
+ * @to: where the data must be copied.
+ * @n: the size of the destination buffer.
+ * @lock: pointer to the spinlock to use for locking.
+ *
+ * This function copies at most @len bytes from the FIFO into the
+ * @to buffer and returns the number of copied bytes.
+ */
+static inline __must_check unsigned int mbox_kfifo_out_locked(struct mbox_kfifo *fifo,
+        void *to, unsigned int n, spinlock_t *lock)
+{
+        unsigned long flags;
+        unsigned int ret;
+
+        spin_lock_irqsave(lock, flags);
+
+        ret = mbox_kfifo_out(fifo, to, n);
+
+        spin_unlock_irqrestore(lock, flags);
+
+        return ret;
+}
+
+extern void mbox_kfifo_skip(struct mbox_kfifo *fifo, unsigned int len);
+
+extern __must_check int mbox_kfifo_from_user(struct mbox_kfifo *fifo,
+        const void __user *from, unsigned int n, unsigned *lenout);
+
+extern __must_check int mbox_kfifo_to_user(struct mbox_kfifo *fifo,
+        void __user *to, unsigned int n, unsigned *lenout);
+
+/*
+ * __mbox_kfifo_add_out internal helper function for updating the out offset
+ */
+static inline void __mbox_kfifo_add_out(struct mbox_kfifo *fifo,
+                                unsigned int off)
+{
+        smp_mb();
+        fifo->out += off;
+}
+
+/*
+ * __mbox_kfifo_add_in internal helper function for updating the in offset
+ */
+static inline void __mbox_kfifo_add_in(struct mbox_kfifo *fifo,
+                                unsigned int off)
+{
+        smp_wmb();
+        fifo->in += off;
+}
+
+/*
+ * __mbox_kfifo_off internal helper function for calculating the index of a
+ * given offeset
+ */
+static inline unsigned int __mbox_kfifo_off(struct mbox_kfifo *fifo, unsigned int off)
+{
+        return off & (fifo->size - 1);
+}
+
+/*
+ * __mbox_kfifo_peek_n internal helper function for determinate the length of
+ * the next record in the fifo
+ */
+static inline unsigned int __mbox_kfifo_peek_n(struct mbox_kfifo *fifo,
+                                unsigned int recsize)
+{
+#define __mbox_kfifo_GET(fifo, off, shift) \
+        ((fifo)->buffer[__mbox_kfifo_off((fifo), (fifo)->out+(off))] << (shift))
+
+        unsigned int l;
+
+        l = __mbox_kfifo_GET(fifo, 0, 0);
+
+        if (--recsize)
+                l |= __mbox_kfifo_GET(fifo, 1, 8);
+
+        return l;
+#undef  __mbox_kfifo_GET
+}
+
+/*
+ * __mbox_kfifo_poke_n internal helper function for storing the length of
+ * the next record into the fifo
+ */
+static inline void __mbox_kfifo_poke_n(struct mbox_kfifo *fifo,
+                        unsigned int recsize, unsigned int n)
+{
+#define __mbox_kfifo_PUT(fifo, off, val, shift) \
+                ( \
+                (fifo)->buffer[__mbox_kfifo_off((fifo), (fifo)->in+(off))] = \
+                (unsigned char)((val) >> (shift)) \
+                )
+
+        __mbox_kfifo_PUT(fifo, 0, n, 0);
+
+        if (--recsize)
+                __mbox_kfifo_PUT(fifo, 1, n, 8);
+#undef  __mbox_kfifo_PUT
+}
+
+/*
+ * __mbox_kfifo_in_... internal functions for put date into the fifo
+ * do not call it directly, use mbox_kfifo_in_rec() instead
+ */
+extern unsigned int __mbox_kfifo_in_n(struct mbox_kfifo *fifo,
+        const void *from, unsigned int n, unsigned int recsize);
+
+extern unsigned int __mbox_kfifo_in_generic(struct mbox_kfifo *fifo,
+        const void *from, unsigned int n, unsigned int recsize);
+
+static inline unsigned int __mbox_kfifo_in_rec(struct mbox_kfifo *fifo,
+        const void *from, unsigned int n, unsigned int recsize)
+{
+        unsigned int ret;
+
+        ret = __mbox_kfifo_in_n(fifo, from, n, recsize);
+
+        if (likely(ret == 0)) {
+                if (recsize)
+                        __mbox_kfifo_poke_n(fifo, recsize, n);
+                __mbox_kfifo_add_in(fifo, n + recsize);
+        }
+        return ret;
+}
+
+/**
+ * mbox_kfifo_in_rec - puts some record data into the FIFO
+ * @fifo: the fifo to be used.
+ * @from: the data to be added.
+ * @n: the length of the data to be added.
+ * @recsize: size of record field
+ *
+ * This function copies @n bytes from the @from into the FIFO and returns
+ * the number of bytes which cannot be copied.
+ * A returned value greater than the @n value means that the record doesn't
+ * fit into the buffer.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these functions.
+ */
+static inline __must_check unsigned int mbox_kfifo_in_rec(struct mbox_kfifo *fifo,
+        void *from, unsigned int n, unsigned int recsize)
+{
+        if (!__builtin_constant_p(recsize))
+                return __mbox_kfifo_in_generic(fifo, from, n, recsize);
+        return __mbox_kfifo_in_rec(fifo, from, n, recsize);
+}
+
+/*
+ * __mbox_kfifo_out_... internal functions for get date from the fifo
+ * do not call it directly, use mbox_kfifo_out_rec() instead
+ */
+extern unsigned int __mbox_kfifo_out_n(struct mbox_kfifo *fifo,
+        void *to, unsigned int reclen, unsigned int recsize);
+
+extern unsigned int __mbox_kfifo_out_generic(struct mbox_kfifo *fifo,
+        void *to, unsigned int n,
+        unsigned int recsize, unsigned int *total);
+
+static inline unsigned int __mbox_kfifo_out_rec(struct mbox_kfifo *fifo,
+        void *to, unsigned int n, unsigned int recsize,
+        unsigned int *total)
+{
+        unsigned int l;
+
+        if (!recsize) {
+                l = n;
+                if (total)
+                        *total = l;
+        } else {
+                l = __mbox_kfifo_peek_n(fifo, recsize);
+                if (total)
+                        *total = l;
+                if (n < l)
+                        return l;
+        }
+
+        return __mbox_kfifo_out_n(fifo, to, l, recsize);
+}
+
+/**
+ * mbox_kfifo_out_rec - gets some record data from the FIFO
+ * @fifo: the fifo to be used.
+ * @to: where the data must be copied.
+ * @n: the size of the destination buffer.
+ * @recsize: size of record field
+ * @total: pointer where the total number of to copied bytes should stored
+ *
+ * This function copies at most @n bytes from the FIFO to @to and returns the
+ * number of bytes which cannot be copied.
+ * A returned value greater than the @n value means that the record doesn't
+ * fit into the @to buffer.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these functions.
+ */
+static inline __must_check unsigned int mbox_kfifo_out_rec(struct mbox_kfifo *fifo,
+        void *to, unsigned int n, unsigned int recsize,
+        unsigned int *total)
+
+{
+        if (!__builtin_constant_p(recsize))
+                return __mbox_kfifo_out_generic(fifo, to, n, recsize, total);
+        return __mbox_kfifo_out_rec(fifo, to, n, recsize, total);
+}
+
+/*
+ * __mbox_kfifo_from_user_... internal functions for transfer from user space into
+ * the fifo. do not call it directly, use mbox_kfifo_from_user_rec() instead
+ */
+extern unsigned int __mbox_kfifo_from_user_n(struct mbox_kfifo *fifo,
+        const void __user *from, unsigned int n, unsigned int recsize);
+
+extern unsigned int __mbox_kfifo_from_user_generic(struct mbox_kfifo *fifo,
+        const void __user *from, unsigned int n, unsigned int recsize);
+
+static inline unsigned int __mbox_kfifo_from_user_rec(struct mbox_kfifo *fifo,
+        const void __user *from, unsigned int n, unsigned int recsize)
+{
+        unsigned int ret;
+
+        ret = __mbox_kfifo_from_user_n(fifo, from, n, recsize);
+
+        if (likely(ret == 0)) {
+                if (recsize)
+                        __mbox_kfifo_poke_n(fifo, recsize, n);
+                __mbox_kfifo_add_in(fifo, n + recsize);
+        }
+        return ret;
+}
+
+/**
+ * mbox_kfifo_from_user_rec - puts some data from user space into the FIFO
+ * @fifo: the fifo to be used.
+ * @from: pointer to the data to be added.
+ * @n: the length of the data to be added.
+ * @recsize: size of record field
+ *
+ * This function copies @n bytes from the @from into the
+ * FIFO and returns the number of bytes which cannot be copied.
+ *
+ * If the returned value is equal or less the @n value, the copy_from_user()
+ * functions has failed. Otherwise the record doesn't fit into the buffer.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these functions.
+ */
+static inline __must_check unsigned int mbox_kfifo_from_user_rec(struct mbox_kfifo *fifo,
+        const void __user *from, unsigned int n, unsigned int recsize)
+{
+        if (!__builtin_constant_p(recsize))
+                return __mbox_kfifo_from_user_generic(fifo, from, n, recsize);
+        return __mbox_kfifo_from_user_rec(fifo, from, n, recsize);
+}
+
+/*
+ * __mbox_kfifo_to_user_... internal functions for transfer fifo data into user space
+ * do not call it directly, use mbox_kfifo_to_user_rec() instead
+ */
+extern unsigned int __mbox_kfifo_to_user_n(struct mbox_kfifo *fifo,
+        void __user *to, unsigned int n, unsigned int reclen,
+        unsigned int recsize);
+
+extern unsigned int __mbox_kfifo_to_user_generic(struct mbox_kfifo *fifo,
+        void __user *to, unsigned int n, unsigned int recsize,
+        unsigned int *total);
+
+static inline unsigned int __mbox_kfifo_to_user_rec(struct mbox_kfifo *fifo,
+        void __user *to, unsigned int n,
+        unsigned int recsize, unsigned int *total)
+{
+        unsigned int l;
+
+        if (!recsize) {
+                l = n;
+                if (total)
+                        *total = l;
+        } else {
+                l = __mbox_kfifo_peek_n(fifo, recsize);
+                if (total)
+                        *total = l;
+                if (n < l)
+                        return l;
+        }
+
+        return __mbox_kfifo_to_user_n(fifo, to, n, l, recsize);
+}
+
+/**
+ * mbox_kfifo_to_user_rec - gets data from the FIFO and write it to user space
+ * @fifo: the fifo to be used.
+ * @to: where the data must be copied.
+ * @n: the size of the destination buffer.
+ * @recsize: size of record field
+ * @total: pointer where the total number of to copied bytes should stored
+ *
+ * This function copies at most @n bytes from the FIFO to the @to.
+ * In case of an error, the function returns the number of bytes which cannot
+ * be copied.
+ * If the returned value is equal or less the @n value, the copy_to_user()
+ * functions has failed. Otherwise the record doesn't fit into the @to buffer.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these functions.
+ */
+static inline __must_check unsigned int mbox_kfifo_to_user_rec(struct mbox_kfifo *fifo,
+                void __user *to, unsigned int n, unsigned int recsize,
+                unsigned int *total)
+{
+        if (!__builtin_constant_p(recsize))
+                return __mbox_kfifo_to_user_generic(fifo, to, n, recsize, total);
+        return __mbox_kfifo_to_user_rec(fifo, to, n, recsize, total);
+}
+
+/*
+ * __mbox_kfifo_peek_... internal functions for peek into the next fifo record
+ * do not call it directly, use mbox_kfifo_peek_rec() instead
+ */
+extern unsigned int __mbox_kfifo_peek_generic(struct mbox_kfifo *fifo,
+                                unsigned int recsize);
+
+/**
+ * mbox_kfifo_peek_rec - gets the size of the next FIFO record data
+ * @fifo: the fifo to be used.
+ * @recsize: size of record field
+ *
+ * This function returns the size of the next FIFO record in number of bytes
+ */
+static inline __must_check unsigned int mbox_kfifo_peek_rec(struct mbox_kfifo *fifo,
+        unsigned int recsize)
+{
+        if (!__builtin_constant_p(recsize))
+                return __mbox_kfifo_peek_generic(fifo, recsize);
+        if (!recsize)
+                return mbox_kfifo_len(fifo);
+        return __mbox_kfifo_peek_n(fifo, recsize);
+}
+
+/*
+ * __mbox_kfifo_skip_... internal functions for skip the next fifo record
+ * do not call it directly, use mbox_kfifo_skip_rec() instead
+ */
+extern void __mbox_kfifo_skip_generic(struct mbox_kfifo *fifo, unsigned int recsize);
+
+static inline void __mbox_kfifo_skip_rec(struct mbox_kfifo *fifo,
+        unsigned int recsize)
+{
+        unsigned int l;
+
+        if (recsize) {
+                l = __mbox_kfifo_peek_n(fifo, recsize);
+
+                if (l + recsize <= mbox_kfifo_len(fifo)) {
+                        __mbox_kfifo_add_out(fifo, l + recsize);
+                        return;
+                }
+        }
+        mbox_kfifo_reset_out(fifo);
+}
+
+/**
+ * mbox_kfifo_skip_rec - skip the next fifo out record
+ * @fifo: the fifo to be used.
+ * @recsize: size of record field
+ *
+ * This function skips the next FIFO record
+ */
+static inline void mbox_kfifo_skip_rec(struct mbox_kfifo *fifo,
+        unsigned int recsize)
+{
+        if (!__builtin_constant_p(recsize))
+                __mbox_kfifo_skip_generic(fifo, recsize);
+        else
+                __mbox_kfifo_skip_rec(fifo, recsize);
+}
+
+/**
+ * mbox_kfifo_avail_rec - returns the number of bytes available in a record FIFO
+ * @fifo: the fifo to be used.
+ * @recsize: size of record field
+ */
+static inline __must_check unsigned int mbox_kfifo_avail_rec(struct mbox_kfifo *fifo,
+        unsigned int recsize)
+{
+        unsigned int l = mbox_kfifo_size(fifo) - mbox_kfifo_len(fifo);
+
+        return (l > recsize) ? l - recsize : 0;
+}
+
+#endif
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/Kconfig kernel-power-2.6.28.new/arch/arm/plat-omap/Kconfig
--- kernel-cssu-2.6.28/arch/arm/plat-omap/Kconfig	2011-10-11 13:50:59.306680562 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/Kconfig	2011-10-11 17:14:45.286048000 +0100
@@ -182,6 +182,15 @@
 	  Say Y here if you want to use OMAP Mailbox framework support for
 	  DSP, IVA1.0 and IVA2 in OMAP1/2/3.
 
+config OMAP_MBOX_KFIFO_SIZE
+	int "Mailbox kfifo default buffer size (bytes)"
+	depends on OMAP_MBOX_FWK
+	default 256
+	help
+	  Specify the default size of mailbox's kfifo buffers (bytes).
+	  This can also be changed at runtime (via the mbox_kfifo_size
+	  module parameter).
+
 config OMAP_IOMMU
 	tristate "IOMMU support"
 	depends on ARCH_OMAP
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/mailbox.c kernel-power-2.6.28.new/arch/arm/plat-omap/mailbox.c
--- kernel-cssu-2.6.28/arch/arm/plat-omap/mailbox.c	2011-10-11 13:50:52.386786914 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/mailbox.c	2011-10-17 20:21:52.241682000 +0100
@@ -1,7 +1,7 @@
 /*
  * OMAP mailbox driver
  *
- * Copyright (C) 2006-2008 Nokia Corporation. All rights reserved.
+ * Copyright (C) 2006-2009 Nokia Corporation. All rights reserved.
  *
  * Contact: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
  *
@@ -20,61 +20,28 @@
  * 02110-1301 USA
  *
  */
-
+#include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/device.h>
 #include <linux/delay.h>
+#include <linux/err.h>
 
 #include <mach/mailbox.h>
+#include <mach/mboxkfifo.h>
 
-static int enable_seq_bit;
-module_param(enable_seq_bit, bool, 0);
-MODULE_PARM_DESC(enable_seq_bit, "Enable sequence bit checking.");
-
+static struct workqueue_struct *mboxd;
 static struct omap_mbox *mboxes;
-static DEFINE_RWLOCK(mboxes_lock);
-
-/*
- * Mailbox sequence bit API
- */
-
-/* seq_rcv should be initialized with any value other than
- * 0 and 1 << 31, to allow either value for the first
- * message.  */
-static inline void mbox_seq_init(struct omap_mbox *mbox)
-{
-	if (!enable_seq_bit)
-		return;
-
-	/* any value other than 0 and 1 << 31 */
-	mbox->seq_rcv = 0xffffffff;
-}
-
-static inline void mbox_seq_toggle(struct omap_mbox *mbox, mbox_msg_t * msg)
-{
-	if (!enable_seq_bit)
-		return;
-
-	/* add seq_snd to msg */
-	*msg = (*msg & 0x7fffffff) | mbox->seq_snd;
-	/* flip seq_snd */
-	mbox->seq_snd ^= 1 << 31;
-}
+static DEFINE_SPINLOCK(mboxes_lock);
+static bool rq_full;
 
-static inline int mbox_seq_test(struct omap_mbox *mbox, mbox_msg_t msg)
-{
-	mbox_msg_t seq;
+static int mbox_configured;
 
-	if (!enable_seq_bit)
-		return 0;
+static unsigned int mailbox_kfifo_size = CONFIG_OMAP_MBOX_KFIFO_SIZE;
+module_param(mailbox_kfifo_size, uint, S_IRUGO);
+MODULE_PARM_DESC(mailbox_kfifo_size, "Size of omap's mailbox kfifo (bytes)");
 
-	seq = msg & (1 << 31);
-	if (seq == mbox->seq_rcv)
-		return -1;
-	mbox->seq_rcv = seq;
-	return 0;
-}
+static DEFINE_MUTEX(mbox_configured_lock);
 
 /* Mailbox FIFO handle functions */
 static inline mbox_msg_t mbox_fifo_read(struct omap_mbox *mbox)
@@ -95,14 +62,6 @@
 }
 
 /* Mailbox IRQ handle functions */
-static inline void enable_mbox_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)
-{
-	mbox->ops->enable_irq(mbox, irq);
-}
-static inline void disable_mbox_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)
-{
-	mbox->ops->disable_irq(mbox, irq);
-}
 static inline void ack_mbox_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)
 {
 	if (mbox->ops->ack_irq)
@@ -113,17 +72,10 @@
 	return mbox->ops->is_irq(mbox, irq);
 }
 
-/* Mailbox Sequence Bit function */
-void omap_mbox_init_seq(struct omap_mbox *mbox)
-{
-	mbox_seq_init(mbox);
-}
-EXPORT_SYMBOL(omap_mbox_init_seq);
-
 /*
  * message sender
  */
-static int __mbox_msg_send(struct omap_mbox *mbox, mbox_msg_t msg, void *arg)
+static int __mbox_poll_for_space(struct omap_mbox *mbox)
 {
 	int ret = 0, i = 1000;
 
@@ -134,67 +86,50 @@
 			return -1;
 		udelay(1);
 	}
-
-	if (arg && mbox->txq->callback) {
-		ret = mbox->txq->callback(arg);
-		if (ret)
-			goto out;
-	}
-
-	mbox_seq_toggle(mbox, &msg);
-	mbox_fifo_write(mbox, msg);
- out:
 	return ret;
 }
 
-int omap_mbox_msg_send(struct omap_mbox *mbox, mbox_msg_t msg, void* arg)
+int omap_mbox_msg_send(struct omap_mbox *mbox, mbox_msg_t msg)
 {
-	struct request *rq;
-	struct request_queue *q = mbox->txq->queue;
-	int ret = 0;
+	struct omap_mbox_queue *mq = mbox->txq;
+	int ret = 0, len;
+
+	spin_lock_bh(&mq->lock);
 
-	rq = blk_get_request(q, WRITE, GFP_ATOMIC);
-	if (unlikely(!rq)) {
+	if (mbox_kfifo_avail(&mq->fifo) < sizeof(msg)) {
 		ret = -ENOMEM;
-		goto fail;
+		goto out;
 	}
 
-	rq->data = (void *)msg;
-	blk_insert_request(q, rq, 0, arg);
+	len = mbox_kfifo_in(&mq->fifo, (unsigned char *)&msg, sizeof(msg));
+	WARN_ON(len != sizeof(msg));
 
-	schedule_work(&mbox->txq->work);
- fail:
+	tasklet_schedule(&mbox->txq->tasklet);
+
+out:
+	spin_unlock_bh(&mq->lock);
 	return ret;
 }
 EXPORT_SYMBOL(omap_mbox_msg_send);
 
-static void mbox_tx_work(struct work_struct *work)
+static void mbox_tx_tasklet(unsigned long tx_data)
 {
+	struct omap_mbox *mbox = (struct omap_mbox *)tx_data;
+	struct omap_mbox_queue *mq = mbox->txq;
+	mbox_msg_t msg;
 	int ret;
-	struct request *rq;
-	struct omap_mbox_queue *mq = container_of(work,
-				struct omap_mbox_queue, work);
-	struct omap_mbox *mbox = mq->queue->queuedata;
-	struct request_queue *q = mbox->txq->queue;
-
-	while (1) {
-		spin_lock(q->queue_lock);
-		rq = elv_next_request(q);
-		spin_unlock(q->queue_lock);
 
-		if (!rq)
+	while (mbox_kfifo_len(&mq->fifo)) {
+		if (__mbox_poll_for_space(mbox)) {
+			omap_mbox_enable_irq(mbox, IRQ_TX);
 			break;
-
-		ret = __mbox_msg_send(mbox, (mbox_msg_t) rq->data, rq->special);
-		if (ret) {
-			enable_mbox_irq(mbox, IRQ_TX);
-			return;
 		}
 
-		spin_lock(q->queue_lock);
-		if (__blk_end_request(rq, 0, 0))
-			BUG();
-		spin_unlock(q->queue_lock);
+		ret = mbox_kfifo_out(&mq->fifo, (unsigned char *)&msg,
+								sizeof(msg));
+		WARN_ON(ret != sizeof(msg));
+
+		mbox_fifo_write(mbox, msg);
 	}
 }
 
@@ -205,83 +140,54 @@
 {
 	struct omap_mbox_queue *mq =
 			container_of(work, struct omap_mbox_queue, work);
-	struct omap_mbox *mbox = mq->queue->queuedata;
-	struct request_queue *q = mbox->rxq->queue;
-	struct request *rq;
 	mbox_msg_t msg;
-	unsigned long flags;
+	int len;
 
-	if (mbox->rxq->callback == NULL) {
-		sysfs_notify(&mbox->dev->kobj, NULL, "mbox");
-		return;
-	}
-
-	while (1) {
-		spin_lock_irqsave(q->queue_lock, flags);
-		rq = elv_next_request(q);
-		spin_unlock_irqrestore(q->queue_lock, flags);
-		if (!rq)
-			break;
+	while (mbox_kfifo_len(&mq->fifo) >= sizeof(msg)) {
+		len = mbox_kfifo_out(&mq->fifo, (unsigned char *)&msg, sizeof(msg));
+		WARN_ON(len != sizeof(msg));
 
-		msg = (mbox_msg_t) rq->data;
-
-		if (blk_end_request(rq, 0, 0))
-			BUG();
-
-		mbox->rxq->callback((void *)msg);
+		if (mq->callback)
+			mq->callback((void *)msg);
 	}
 }
 
 /*
  * Mailbox interrupt handler
  */
-static void mbox_txq_fn(struct request_queue * q)
-{
-}
-
-static void mbox_rxq_fn(struct request_queue * q)
-{
-}
-
 static void __mbox_tx_interrupt(struct omap_mbox *mbox)
 {
-	disable_mbox_irq(mbox, IRQ_TX);
+	omap_mbox_disable_irq(mbox, IRQ_TX);
 	ack_mbox_irq(mbox, IRQ_TX);
-	schedule_work(&mbox->txq->work);
+	tasklet_schedule(&mbox->txq->tasklet);
 }
 
 static void __mbox_rx_interrupt(struct omap_mbox *mbox)
 {
-	struct request *rq;
+	struct omap_mbox_queue *mq = mbox->rxq;
 	mbox_msg_t msg;
-	struct request_queue *q = mbox->rxq->queue;
-
-	disable_mbox_irq(mbox, IRQ_RX);
+	int len;
 
 	while (!mbox_fifo_empty(mbox)) {
-		rq = blk_get_request(q, WRITE, GFP_ATOMIC);
-		if (unlikely(!rq))
+		if (unlikely(mbox_kfifo_avail(&mq->fifo) < sizeof(msg))) {
+			omap_mbox_disable_irq(mbox, IRQ_RX);
+			rq_full = true;
 			goto nomem;
+		}
 
 		msg = mbox_fifo_read(mbox);
-		rq->data = (void *)msg;
 
-		if (unlikely(mbox_seq_test(mbox, msg))) {
-			pr_info("mbox: Illegal seq bit!(%08x)\n", msg);
-			if (mbox->err_notify)
-				mbox->err_notify();
-		}
+		len = mbox_kfifo_in(&mq->fifo, (unsigned char *)&msg, sizeof(msg));
+		WARN_ON(len != sizeof(msg));
 
-		blk_insert_request(q, rq, 0, NULL);
 		if (mbox->ops->type == OMAP_MBOX_TYPE1)
 			break;
 	}
 
 	/* no more messages in the fifo. clear IRQ source. */
 	ack_mbox_irq(mbox, IRQ_RX);
-	enable_mbox_irq(mbox, IRQ_RX);
 nomem:
-	schedule_work(&mbox->rxq->work);
+	queue_work(mboxd, &mbox->rxq->work);
 }
 
 static irqreturn_t mbox_interrupt(int irq, void *p)
@@ -297,79 +203,10 @@
 	return IRQ_HANDLED;
 }
 
-/*
- * sysfs files
- */
-static ssize_t
-omap_mbox_write(struct device *dev, struct device_attribute *attr,
-		const char * buf, size_t count)
-{
-	int ret;
-	mbox_msg_t *p = (mbox_msg_t *)buf;
-	struct omap_mbox *mbox = dev_get_drvdata(dev);
-
-	for (; count >= sizeof(mbox_msg_t); count -= sizeof(mbox_msg_t)) {
-		ret = omap_mbox_msg_send(mbox, be32_to_cpu(*p), NULL);
-		if (ret)
-			return -EAGAIN;
-		p++;
-	}
-
-	return (size_t)((char *)p - buf);
-}
-
-static ssize_t
-omap_mbox_read(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	unsigned long flags;
-	struct request *rq;
-	mbox_msg_t *p = (mbox_msg_t *) buf;
-	struct omap_mbox *mbox = dev_get_drvdata(dev);
-	struct request_queue *q = mbox->rxq->queue;
-
-	while (1) {
-		spin_lock_irqsave(q->queue_lock, flags);
-		rq = elv_next_request(q);
-		spin_unlock_irqrestore(q->queue_lock, flags);
-
-		if (!rq)
-			break;
-
-		*p = (mbox_msg_t) rq->data;
-
-		if (blk_end_request(rq, 0, 0))
-			BUG();
-
-		if (unlikely(mbox_seq_test(mbox, *p))) {
-			pr_info("mbox: Illegal seq bit!(%08x) ignored\n", *p);
-			continue;
-		}
-		p++;
-	}
-
-	pr_debug("%02x %02x %02x %02x\n", buf[0], buf[1], buf[2], buf[3]);
-
-	return (size_t) ((char *)p - buf);
-}
-
-static DEVICE_ATTR(mbox, S_IRUGO | S_IWUSR, omap_mbox_read, omap_mbox_write);
-
-static ssize_t mbox_show(struct class *class, char *buf)
-{
-	return sprintf(buf, "mbox");
-}
-
-static CLASS_ATTR(mbox, S_IRUGO, mbox_show, NULL);
-
-static struct class omap_mbox_class = {
-	.name = "omap-mailbox",
-};
-
 static struct omap_mbox_queue *mbox_queue_alloc(struct omap_mbox *mbox,
-					request_fn_proc * proc,
-					void (*work) (struct work_struct *))
+					void (*work) (struct work_struct *),
+					void (*tasklet)(unsigned long))
 {
-	struct request_queue *q;
 	struct omap_mbox_queue *mq;
 
 	mq = kzalloc(sizeof(struct omap_mbox_queue), GFP_KERNEL);
@@ -378,14 +215,14 @@
 
 	spin_lock_init(&mq->lock);
 
-	q = blk_init_queue(proc, &mq->lock);
-	if (!q)
+	if (mbox_kfifo_alloc(&mq->fifo, mailbox_kfifo_size, GFP_KERNEL))
 		goto error;
-	q->queuedata = mbox;
-	mq->queue = q;
 
-	INIT_WORK(&mq->work, work);
+	if (work)
+		INIT_WORK(&mq->work, work);
 
+	if (tasklet)
+		tasklet_init(&mq->tasklet, tasklet, (unsigned long)mbox);
 	return mq;
 error:
 	kfree(mq);
@@ -394,51 +231,58 @@
 
 static void mbox_queue_free(struct omap_mbox_queue *q)
 {
-	blk_cleanup_queue(q->queue);
+	mbox_kfifo_free(&q->fifo);
 	kfree(q);
 }
 
-static int omap_mbox_init(struct omap_mbox *mbox)
+static int omap_mbox_startup(struct omap_mbox *mbox)
 {
-	int ret;
+	int ret = 0;
 	struct omap_mbox_queue *mq;
 
-	if (likely(mbox->ops->startup)) {
-		ret = mbox->ops->startup(mbox);
-		if (unlikely(ret))
-			return ret;
-	}
+	if (mbox->ops->startup) {
+		mutex_lock(&mbox_configured_lock);
+		if (!mbox_configured)
+			ret = mbox->ops->startup(mbox);
 
-	ret = request_irq(mbox->irq, mbox_interrupt, IRQF_DISABLED,
-				mbox->name, mbox);
-	if (unlikely(ret)) {
-		printk(KERN_ERR
-			"failed to register mailbox interrupt:%d\n", ret);
-		goto fail_request_irq;
+		if (ret) {
+			mutex_unlock(&mbox_configured_lock);
+			return ret;
+		}
+		mbox_configured++;
+		mutex_unlock(&mbox_configured_lock);
 	}
 
-	mq = mbox_queue_alloc(mbox, mbox_txq_fn, mbox_tx_work);
+	mq = mbox_queue_alloc(mbox, NULL, mbox_tx_tasklet);
 	if (!mq) {
 		ret = -ENOMEM;
 		goto fail_alloc_txq;
 	}
 	mbox->txq = mq;
 
-	mq = mbox_queue_alloc(mbox, mbox_rxq_fn, mbox_rx_work);
+	mq = mbox_queue_alloc(mbox, mbox_rx_work, NULL);
 	if (!mq) {
 		ret = -ENOMEM;
 		goto fail_alloc_rxq;
 	}
 	mbox->rxq = mq;
 
+	ret = request_irq(mbox->irq, mbox_interrupt, IRQF_SHARED,
+				mbox->name, mbox);
+	if (ret) {
+	    printk(KERN_ERR
+		    "failed to register mailbox interrupt:%d\n", ret);
+		goto fail_request_irq;
+	}
+
 	return 0;
 
+ fail_request_irq:
+	mbox_queue_free(mbox->rxq);
  fail_alloc_rxq:
 	mbox_queue_free(mbox->txq);
  fail_alloc_txq:
-	free_irq(mbox->irq, mbox);
- fail_request_irq:
-	if (unlikely(mbox->ops->shutdown))
+	if (mbox->ops->shutdown)
 		mbox->ops->shutdown(mbox);
 
 	return ret;
@@ -446,13 +290,20 @@
 
 static void omap_mbox_fini(struct omap_mbox *mbox)
 {
+	free_irq(mbox->irq, mbox);
+	tasklet_kill(&mbox->txq->tasklet);
+	flush_work(&mbox->rxq->work);
 	mbox_queue_free(mbox->txq);
 	mbox_queue_free(mbox->rxq);
 
-	free_irq(mbox->irq, mbox);
-
-	if (unlikely(mbox->ops->shutdown))
-		mbox->ops->shutdown(mbox);
+	if (mbox->ops->shutdown) {
+		mutex_lock(&mbox_configured_lock);
+		if (mbox_configured > 0)
+			mbox_configured--;
+		if (!mbox_configured)
+			mbox->ops->shutdown(mbox);
+		mutex_unlock(&mbox_configured_lock);
+	}
 }
 
 static struct omap_mbox **find_mboxes(const char *name)
@@ -472,16 +323,16 @@
 	struct omap_mbox *mbox;
 	int ret;
 
-	read_lock(&mboxes_lock);
+	spin_lock(&mboxes_lock);
 	mbox = *(find_mboxes(name));
 	if (mbox == NULL) {
-		read_unlock(&mboxes_lock);
+		spin_unlock(&mboxes_lock);
 		return ERR_PTR(-ENOENT);
 	}
 
-	read_unlock(&mboxes_lock);
+	spin_unlock(&mboxes_lock);
 
-	ret = omap_mbox_init(mbox);
+	ret = omap_mbox_startup(mbox);
 	if (ret)
 		return ERR_PTR(-ENODEV);
 
@@ -505,31 +356,19 @@
 	if (mbox->next)
 		return -EBUSY;
 
-	mbox->dev = device_create(&omap_mbox_class,
-				  parent, 0, mbox, "%s", mbox->name);
-	if (IS_ERR(mbox->dev))
-		return PTR_ERR(mbox->dev);
-
-	ret = device_create_file(mbox->dev, &dev_attr_mbox);
-	if (ret)
-		goto err_sysfs;
-
-	write_lock(&mboxes_lock);
+	spin_lock(&mboxes_lock);
 	tmp = find_mboxes(mbox->name);
 	if (*tmp) {
 		ret = -EBUSY;
-		write_unlock(&mboxes_lock);
+		spin_unlock(&mboxes_lock);
 		goto err_find;
 	}
 	*tmp = mbox;
-	write_unlock(&mboxes_lock);
+	spin_unlock(&mboxes_lock);
 
 	return 0;
 
 err_find:
-	device_remove_file(mbox->dev, &dev_attr_mbox);
-err_sysfs:
-	device_unregister(mbox->dev);
 	return ret;
 }
 EXPORT_SYMBOL(omap_mbox_register);
@@ -538,43 +377,46 @@
 {
 	struct omap_mbox **tmp;
 
-	write_lock(&mboxes_lock);
+	spin_lock(&mboxes_lock);
 	tmp = &mboxes;
 	while (*tmp) {
 		if (mbox == *tmp) {
 			*tmp = mbox->next;
 			mbox->next = NULL;
-			write_unlock(&mboxes_lock);
-			device_remove_file(mbox->dev, &dev_attr_mbox);
-			device_unregister(mbox->dev);
+			spin_unlock(&mboxes_lock);
 			return 0;
 		}
 		tmp = &(*tmp)->next;
 	}
-	write_unlock(&mboxes_lock);
+	spin_unlock(&mboxes_lock);
 
 	return -EINVAL;
 }
 EXPORT_SYMBOL(omap_mbox_unregister);
 
-static int __init omap_mbox_class_init(void)
+static int __init omap_mbox_init(void)
 {
-	int ret = class_register(&omap_mbox_class);
-	if (!ret)
-		ret = class_create_file(&omap_mbox_class, &class_attr_mbox);
-
-	return ret;
+	mboxd = create_workqueue("mboxd");
+	if (!mboxd)
+		return -ENOMEM;
+
+	/* kfifo size sanity check: alignment and minimal size */
+	mailbox_kfifo_size = ALIGN(mailbox_kfifo_size, sizeof(mbox_msg_t));
+	mailbox_kfifo_size = max_t(unsigned int, mailbox_kfifo_size,
+						sizeof(mbox_msg_t));
+	return 0;
 }
+module_init(omap_mbox_init);
 
-static void __exit omap_mbox_class_exit(void)
+static void __exit omap_mbox_exit(void)
 {
-	class_remove_file(&omap_mbox_class, &class_attr_mbox);
-	class_unregister(&omap_mbox_class);
+	destroy_workqueue(mboxd);
 }
+module_exit(omap_mbox_exit);
 
-subsys_initcall(omap_mbox_class_init);
-module_exit(omap_mbox_class_exit);
+#include "mboxkfifo.c"
 
 MODULE_LICENSE("GPL v2");
 MODULE_DESCRIPTION("omap mailbox: interrupt driven messaging");
-MODULE_AUTHOR("Toshihiro Kobayashi and Hiroshi DOYU");
+MODULE_AUTHOR("Toshihiro Kobayashi");
+MODULE_AUTHOR("Hiroshi DOYU");
diff -urN kernel-cssu-2.6.28/arch/arm/plat-omap/mboxkfifo.c kernel-power-2.6.28.new/arch/arm/plat-omap/mboxkfifo.c
--- kernel-cssu-2.6.28/arch/arm/plat-omap/mboxkfifo.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-cssu-2.6.28.new/arch/arm/plat-omap/mboxkfifo.c	2011-10-17 20:39:39.198215000 +0100
@@ -0,0 +1,419 @@
+/*
+ * A generic kernel FIFO implementation.
+ *
+ * Copyright (C) 2009 Stefani Seibold <stefani@seibold.net>
+ * Copyright (C) 2004 Stelian Pop <stelian@popies.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/uaccess.h>
+
+static void _mbox_kfifo_init(struct mbox_kfifo *fifo, void *buffer,
+                unsigned int size)
+{
+        fifo->buffer = buffer;
+        fifo->size = size;
+
+        mbox_kfifo_reset(fifo);
+}
+
+/**
+ * mbox_kfifo_init - initialize a FIFO using a preallocated buffer
+ * @fifo: the fifo to assign the buffer
+ * @buffer: the preallocated buffer to be used.
+ * @size: the size of the internal buffer, this has to be a power of 2.
+ *
+ */
+void mbox_kfifo_init(struct mbox_kfifo *fifo, void *buffer, unsigned int size)
+{
+        /* size must be a power of 2 */
+        BUG_ON(!is_power_of_2(size));
+
+        _mbox_kfifo_init(fifo, buffer, size);
+}
+
+/**
+ * mbox_kfifo_alloc - allocates a new FIFO internal buffer
+ * @fifo: the fifo to assign then new buffer
+ * @size: the size of the buffer to be allocated, this have to be a power of 2.
+ * @gfp_mask: get_free_pages mask, passed to kmalloc()
+ *
+ * This function dynamically allocates a new fifo internal buffer
+ *
+ * The size will be rounded-up to a power of 2.
+ * The buffer will be release with mbox_kfifo_free().
+ * Return 0 if no error, otherwise the an error code
+ */
+int mbox_kfifo_alloc(struct mbox_kfifo *fifo, unsigned int size, gfp_t gfp_mask)
+{
+        unsigned char *buffer;
+
+        /*
+         * round up to the next power of 2, since our 'let the indices
+         * wrap' technique works only in this case.
+         */
+        if (!is_power_of_2(size)) {
+                BUG_ON(size > 0x80000000);
+                size = roundup_pow_of_two(size);
+        }
+
+        buffer = kmalloc(size, gfp_mask);
+        if (!buffer) {
+                _mbox_kfifo_init(fifo, NULL, 0);
+                return -ENOMEM;
+        }
+
+        _mbox_kfifo_init(fifo, buffer, size);
+
+        return 0;
+}
+
+/**
+ * mbox_kfifo_free - frees the FIFO internal buffer
+ * @fifo: the fifo to be freed.
+ */
+void mbox_kfifo_free(struct mbox_kfifo *fifo)
+{
+        kfree(fifo->buffer);
+        _mbox_kfifo_init(fifo, NULL, 0);
+}
+
+/**
+ * mbox_kfifo_skip - skip output data
+ * @fifo: the fifo to be used.
+ * @len: number of bytes to skip
+ */
+void mbox_kfifo_skip(struct mbox_kfifo *fifo, unsigned int len)
+{
+        if (len < mbox_kfifo_len(fifo)) {
+                __mbox_kfifo_add_out(fifo, len);
+                return;
+        }
+        mbox_kfifo_reset_out(fifo);
+}
+
+static inline void __mbox_kfifo_in_data(struct mbox_kfifo *fifo,
+                const void *from, unsigned int len, unsigned int off)
+{
+        unsigned int l;
+
+        /*
+         * Ensure that we sample the fifo->out index -before- we
+         * start putting bytes into the mbox_kfifo.
+         */
+
+        smp_mb();
+
+        off = __mbox_kfifo_off(fifo, fifo->in + off);
+
+        /* first put the data starting from fifo->in to buffer end */
+        l = min(len, fifo->size - off);
+        memcpy(fifo->buffer + off, from, l);
+
+        /* then put the rest (if any) at the beginning of the buffer */
+        memcpy(fifo->buffer, from + l, len - l);
+}
+
+static inline void __mbox_kfifo_out_data(struct mbox_kfifo *fifo,
+                void *to, unsigned int len, unsigned int off)
+{
+        unsigned int l;
+
+        /*
+         * Ensure that we sample the fifo->in index -before- we
+         * start removing bytes from the mbox_kfifo.
+         */
+
+        smp_rmb();
+
+        off = __mbox_kfifo_off(fifo, fifo->out + off);
+
+        /* first get the data from fifo->out until the end of the buffer */
+        l = min(len, fifo->size - off);
+        memcpy(to, fifo->buffer + off, l);
+
+        /* then get the rest (if any) from the beginning of the buffer */
+        memcpy(to + l, fifo->buffer, len - l);
+}
+
+static inline int __mbox_kfifo_from_user_data(struct mbox_kfifo *fifo,
+         const void __user *from, unsigned int len, unsigned int off,
+         unsigned *lenout)
+{
+        unsigned int l;
+        int ret;
+
+        /*
+         * Ensure that we sample the fifo->out index -before- we
+         * start putting bytes into the mbox_kfifo.
+         */
+
+        smp_mb();
+
+        off = __mbox_kfifo_off(fifo, fifo->in + off);
+
+        /* first put the data starting from fifo->in to buffer end */
+        l = min(len, fifo->size - off);
+        ret = copy_from_user(fifo->buffer + off, from, l);
+        if (unlikely(ret)) {
+                *lenout = ret;
+                return -EFAULT;
+        }
+        *lenout = l;
+
+        /* then put the rest (if any) at the beginning of the buffer */
+        ret = copy_from_user(fifo->buffer, from + l, len - l);
+        *lenout += ret ? ret : len - l;
+        return ret ? -EFAULT : 0;
+}
+
+static inline int __mbox_kfifo_to_user_data(struct mbox_kfifo *fifo,
+                void __user *to, unsigned int len, unsigned int off, unsigned *lenout)
+{
+        unsigned int l;
+        int ret;
+
+        /*
+         * Ensure that we sample the fifo->in index -before- we
+         * start removing bytes from the mbox_kfifo.
+         */
+
+        smp_rmb();
+
+        off = __mbox_kfifo_off(fifo, fifo->out + off);
+
+        /* first get the data from fifo->out until the end of the buffer */
+        l = min(len, fifo->size - off);
+        ret = copy_to_user(to, fifo->buffer + off, l);
+        *lenout = l;
+        if (unlikely(ret)) {
+                *lenout -= ret;
+                return -EFAULT;
+        }
+
+        /* then get the rest (if any) from the beginning of the buffer */
+        len -= l;
+        ret = copy_to_user(to + l, fifo->buffer, len);
+        if (unlikely(ret)) {
+                *lenout += len - ret;
+                return -EFAULT;
+        }
+        *lenout += len;
+        return 0;
+}
+
+unsigned int __mbox_kfifo_in_n(struct mbox_kfifo *fifo,
+        const void *from, unsigned int len, unsigned int recsize)
+{
+        if (mbox_kfifo_avail(fifo) < len + recsize)
+                return len + 1;
+
+        __mbox_kfifo_in_data(fifo, from, len, recsize);
+        return 0;
+}
+
+/**
+ * mbox_kfifo_in - puts some data into the FIFO
+ * @fifo: the fifo to be used.
+ * @from: the data to be added.
+ * @len: the length of the data to be added.
+ *
+ * This function copies at most @len bytes from the @from buffer into
+ * the FIFO depending on the free space, and returns the number of
+ * bytes copied.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these functions.
+ */
+unsigned int mbox_kfifo_in(struct mbox_kfifo *fifo, const void *from,
+                                unsigned int len)
+{
+        len = min(mbox_kfifo_avail(fifo), len);
+
+        __mbox_kfifo_in_data(fifo, from, len, 0);
+        __mbox_kfifo_add_in(fifo, len);
+        return len;
+}
+
+unsigned int __mbox_kfifo_in_generic(struct mbox_kfifo *fifo,
+        const void *from, unsigned int len, unsigned int recsize)
+{
+        return __mbox_kfifo_in_rec(fifo, from, len, recsize);
+}
+
+unsigned int __mbox_kfifo_out_n(struct mbox_kfifo *fifo,
+        void *to, unsigned int len, unsigned int recsize)
+{
+        if (mbox_kfifo_len(fifo) < len + recsize)
+                return len;
+
+        __mbox_kfifo_out_data(fifo, to, len, recsize);
+        __mbox_kfifo_add_out(fifo, len + recsize);
+        return 0;
+}
+
+/**
+ * mbox_kfifo_out - gets some data from the FIFO
+ * @fifo: the fifo to be used.
+ * @to: where the data must be copied.
+ * @len: the size of the destination buffer.
+ *
+ * This function copies at most @len bytes from the FIFO into the
+ * @to buffer and returns the number of copied bytes.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these functions.
+ */
+unsigned int mbox_kfifo_out(struct mbox_kfifo *fifo, void *to, unsigned int len)
+{
+        len = min(mbox_kfifo_len(fifo), len);
+
+        __mbox_kfifo_out_data(fifo, to, len, 0);
+        __mbox_kfifo_add_out(fifo, len);
+
+        return len;
+}
+
+/**
+ * mbox_kfifo_out_peek - copy some data from the FIFO, but do not remove it
+ * @fifo: the fifo to be used.
+ * @to: where the data must be copied.
+ * @len: the size of the destination buffer.
+ * @offset: offset into the fifo
+ *
+ * This function copies at most @len bytes at @offset from the FIFO
+ * into the @to buffer and returns the number of copied bytes.
+ * The data is not removed from the FIFO.
+ */
+unsigned int mbox_kfifo_out_peek(struct mbox_kfifo *fifo, void *to, unsigned int len,
+                            unsigned offset)
+{
+        len = min(mbox_kfifo_len(fifo), len + offset);
+
+        __mbox_kfifo_out_data(fifo, to, len, offset);
+        return len;
+}
+
+unsigned int __mbox_kfifo_out_generic(struct mbox_kfifo *fifo,
+        void *to, unsigned int len, unsigned int recsize,
+        unsigned int *total)
+{
+        return __mbox_kfifo_out_rec(fifo, to, len, recsize, total);
+}
+
+unsigned int __mbox_kfifo_from_user_n(struct mbox_kfifo *fifo,
+        const void __user *from, unsigned int len, unsigned int recsize)
+{
+        unsigned total;
+
+        if (mbox_kfifo_avail(fifo) < len + recsize)
+                return len + 1;
+
+        __mbox_kfifo_from_user_data(fifo, from, len, recsize, &total);
+        return total;
+}
+
+/**
+ * mbox_kfifo_from_user - puts some data from user space into the FIFO
+ * @fifo: the fifo to be used.
+ * @from: pointer to the data to be added.
+ * @len: the length of the data to be added.
+ * @total: the actual returned data length.
+ *
+ * This function copies at most @len bytes from the @from into the
+ * FIFO depending and returns -EFAULT/0.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these functions.
+ */
+int mbox_kfifo_from_user(struct mbox_kfifo *fifo,
+        const void __user *from, unsigned int len, unsigned *total)
+{
+        int ret;
+        len = min(mbox_kfifo_avail(fifo), len);
+        ret = __mbox_kfifo_from_user_data(fifo, from, len, 0, total);
+        if (ret)
+                return ret;
+        __mbox_kfifo_add_in(fifo, len);
+        return 0;
+}
+
+unsigned int __mbox_kfifo_from_user_generic(struct mbox_kfifo *fifo,
+        const void __user *from, unsigned int len, unsigned int recsize)
+{
+        return __mbox_kfifo_from_user_rec(fifo, from, len, recsize);
+}
+
+unsigned int __mbox_kfifo_to_user_n(struct mbox_kfifo *fifo,
+        void __user *to, unsigned int len, unsigned int reclen,
+        unsigned int recsize)
+{
+        unsigned int ret, total;
+
+        if (mbox_kfifo_len(fifo) < reclen + recsize)
+                return len;
+
+        ret = __mbox_kfifo_to_user_data(fifo, to, reclen, recsize, &total);
+
+        if (likely(ret == 0))
+                __mbox_kfifo_add_out(fifo, reclen + recsize);
+
+        return total;
+}
+
+/**
+ * mbox_kfifo_to_user - gets data from the FIFO and write it to user space
+ * @fifo: the fifo to be used.
+ * @to: where the data must be copied.
+ * @len: the size of the destination buffer.
+ * @lenout: pointer to output variable with copied data
+ *
+ * This function copies at most @len bytes from the FIFO into the
+ * @to buffer and 0 or -EFAULT.
+ *
+ * Note that with only one concurrent reader and one concurrent
+ * writer, you don't need extra locking to use these functions.
+ */
+int mbox_kfifo_to_user(struct mbox_kfifo *fifo,
+        void __user *to, unsigned int len, unsigned *lenout)
+{
+        int ret;
+        len = min(mbox_kfifo_len(fifo), len);
+        ret = __mbox_kfifo_to_user_data(fifo, to, len, 0, lenout);
+        __mbox_kfifo_add_out(fifo, *lenout);
+        return ret;
+}
+
+unsigned int __mbox_kfifo_to_user_generic(struct mbox_kfifo *fifo,
+        void __user *to, unsigned int len, unsigned int recsize,
+        unsigned int *total)
+{
+        return __mbox_kfifo_to_user_rec(fifo, to, len, recsize, total);
+}
+
+unsigned int __mbox_kfifo_peek_generic(struct mbox_kfifo *fifo, unsigned int recsize)
+{
+        if (recsize == 0)
+                return mbox_kfifo_avail(fifo);
+
+        return __mbox_kfifo_peek_n(fifo, recsize);
+}
+
+void __mbox_kfifo_skip_generic(struct mbox_kfifo *fifo, unsigned int recsize)
+{
+        __mbox_kfifo_skip_rec(fifo, recsize);
+}
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/cload.c kernel-power-2.6.28.new/drivers/dsp/bridge/dynload/cload.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/cload.c	2011-10-11 13:51:00.023744307 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/dynload/cload.c	2011-10-23 08:22:37.606293000 +0100
@@ -21,10 +21,10 @@
 
 /*
  * we use the fact that DOFF section records are shaped just like
- * LDR_SECTION_INFO to reduce our section storage usage.  This macro marks
+ * ldr_section_info to reduce our section storage usage.  This macro marks
  * the places where that assumption is made
  */
-#define DOFFSEC_IS_LDRSEC(pdoffsec) ((struct LDR_SECTION_INFO *)(pdoffsec))
+#define DOFFSEC_IS_LDRSEC(pdoffsec) ((struct ldr_section_info *)(pdoffsec))
 
 /*
  * forward references
@@ -40,20 +40,20 @@
 static char *unpack_name(struct dload_state *dlthis, u32 soffset);
 #endif
 
-static const char CINITNAME[] = { ".cinit" };
-static const char LOADER_DLLVIEW_ROOT[] = { "?DLModules?" };
+static const char cinitname[] = { ".cinit" };
+static const char loader_dllview_root[] = { "?DLModules?" };
 
 /*
  * Error strings
  */
-static const char E_READSTRM[] = { "Error reading %s from input stream" };
-static const char E_ALLOC[] = { "Syms->Allocate( %d ) failed" };
-static const char E_TGTALLOC[] =
+static const char readstrm[] = { "Error reading %s from input stream" };
+static const char err_alloc[] = { "Syms->dload_allocate( %d ) failed" };
+static const char tgtalloc[] =
     { "Target memory allocate failed, section %s size " FMT_UI32 };
-static const char E_INITFAIL[] = { "%s to target address " FMT_UI32 " failed" };
-static const char E_DLVWRITE[] = { "Write to DLLview list failed" };
-static const char E_ICONNECT[] = { "Connect call to init interface failed" };
-static const char E_CHECKSUM[] = { "Checksum failed on %s" };
+static const char initfail[] = { "%s to target address " FMT_UI32 " failed" };
+static const char dlvwrite[] = { "Write to DLLview list failed" };
+static const char iconnect[] = { "Connect call to init interface failed" };
+static const char err_checksum[] = { "Checksum failed on %s" };
 
 /*************************************************************************
  * Procedure dload_error
@@ -64,13 +64,13 @@
  *
  * Effect:
  *	Reports or records the error as appropriate.
- ************************************************************************/
+ *********************************************************************** */
 void dload_error(struct dload_state *dlthis, const char *errtxt, ...)
 {
 	va_list args;
 
 	va_start(args, errtxt);
-	dlthis->mysym->Error_Report(dlthis->mysym, errtxt, args);
+	dlthis->mysym->error_report(dlthis->mysym, errtxt, args);
 	va_end(args);
 	dlthis->dload_errcount += 1;
 
@@ -87,18 +87,18 @@
  *
  * Effect:
  *	Reports or records the error as appropriate.
- ************************************************************************/
-void dload_syms_error(struct Dynamic_Loader_Sym *syms, const char *errtxt, ...)
+ *********************************************************************** */
+void dload_syms_error(struct dynamic_loader_sym *syms, const char *errtxt, ...)
 {
 	va_list args;
 
 	va_start(args, errtxt);
-	syms->Error_Report(syms, errtxt, args);
+	syms->error_report(syms, errtxt, args);
 	va_end(args);
 }
 
 /*************************************************************************
- * Procedure Dynamic_Load_Module
+ * Procedure dynamic_load_module
  *
  * Parameters:
  *	module	The input stream that supplies the module image
@@ -120,13 +120,13 @@
  *	On a successful load, a module handle is placed in *mhandle,
  *	and zero is returned.  On error, the number of errors detected is
  *	returned.  Individual errors are reported during the load process
- *	using syms->Error_Report().
- ***********************************************************************/
-int Dynamic_Load_Module(struct Dynamic_Loader_Stream *module,
-			struct Dynamic_Loader_Sym *syms ,
-			struct Dynamic_Loader_Allocate *alloc,
-			struct Dynamic_Loader_Initialize *init,
-			unsigned options, DLOAD_mhandle *mhandle)
+ *	using syms->error_report().
+ ********************************************************************** */
+int dynamic_load_module(struct dynamic_loader_stream *module,
+			struct dynamic_loader_sym *syms,
+			struct dynamic_loader_allocate *alloc,
+			struct dynamic_loader_initialize *init,
+			unsigned options, dload_mhandle *mhandle)
 {
 	register unsigned *dp, sz;
 	struct dload_state dl_state;	/* internal state for this call */
@@ -159,7 +159,7 @@
 				/* do now, before reducing symbols */
 				allocate_sections(&dl_state);
 			} else
-				dload_error(&dl_state, E_ICONNECT);
+				dload_error(&dl_state, iconnect);
 		}
 
 		if (!dl_state.dload_errcount) {
@@ -183,18 +183,18 @@
 			    (dl_state.dfile_hdr.df_entry_secn != DN_UNDEF) &&
 			    (!init->execute(init,
 					    dl_state.dfile_hdr.df_entrypt)))
-				dload_error(&dl_state,
-					    "Init->Execute Failed");
+				dload_error(&dl_state, "Init->Execute Failed");
 			init->release(init);
 		}
 
 		symbol_table_free(&dl_state);
 		section_table_free(&dl_state);
 		string_table_free(&dl_state);
+		dload_tramp_cleanup(&dl_state);
 
 		if (dl_state.dload_errcount) {
-			Dynamic_Unload_Module(dl_state.myhandle, syms, alloc,
-					     init);
+			dynamic_unload_module(dl_state.myhandle, syms, alloc,
+					      init);
 			dl_state.myhandle = NULL;
 		}
 	}
@@ -206,7 +206,7 @@
 }				/* DLOAD_File */
 
 /*************************************************************************
- * Procedure Dynamic_Open_Module
+ * Procedure dynamic_open_module
  *
  * Parameters:
  *      module  The input stream that supplies the module image
@@ -228,17 +228,17 @@
  *      On a successful load, a module handle is placed in *mhandle,
  *      and zero is returned.  On error, the number of errors detected is
  *      returned.  Individual errors are reported during the load process
- *      using syms->Error_Report().
- ***********************************************************************/
+ *      using syms->error_report().
+ ********************************************************************** */
 int
-Dynamic_Open_Module(struct Dynamic_Loader_Stream *module,
-		    struct Dynamic_Loader_Sym *syms,
-		    struct Dynamic_Loader_Allocate *alloc,
-		    struct Dynamic_Loader_Initialize *init,
-		    unsigned options, DLOAD_mhandle *mhandle)
+dynamic_open_module(struct dynamic_loader_stream *module,
+		    struct dynamic_loader_sym *syms,
+		    struct dynamic_loader_allocate *alloc,
+		    struct dynamic_loader_initialize *init,
+		    unsigned options, dload_mhandle *mhandle)
 {
 	register unsigned *dp, sz;
-	struct dload_state dl_state;   /* internal state for this call */
+	struct dload_state dl_state;	/* internal state for this call */
 
 	/* blast our internal state */
 	dp = (unsigned *)&dl_state;
@@ -268,7 +268,7 @@
 				/* do now, before reducing symbols */
 				allocate_sections(&dl_state);
 			} else
-				dload_error(&dl_state, E_ICONNECT);
+				dload_error(&dl_state, iconnect);
 		}
 
 		if (!dl_state.dload_errcount) {
@@ -289,8 +289,7 @@
 			    (dl_state.dfile_hdr.df_entry_secn != DN_UNDEF) &&
 			    (!init->execute(init,
 					    dl_state.dfile_hdr.df_entrypt)))
-				dload_error(&dl_state,
-					    "Init->Execute Failed");
+				dload_error(&dl_state, "Init->Execute Failed");
 			init->release(init);
 		}
 
@@ -299,17 +298,17 @@
 		string_table_free(&dl_state);
 
 		if (dl_state.dload_errcount) {
-			Dynamic_Unload_Module(dl_state.myhandle, syms, alloc,
+			dynamic_unload_module(dl_state.myhandle, syms, alloc,
 					      init);
 			dl_state.myhandle = NULL;
 		}
 	}
 
 	if (mhandle)
-		*mhandle = dl_state.myhandle;   /* give back the handle */
+		*mhandle = dl_state.myhandle;	/* give back the handle */
 
 	return dl_state.dload_errcount;
-}			       /* DLOAD_File */
+}				/* DLOAD_File */
 
 /*************************************************************************
  * Procedure dload_headers
@@ -320,7 +319,7 @@
  * Effect:
  *	Loads the DOFF header and verify record.  Deals with any byte-order
  * issues and checks them for validity.
- ************************************************************************/
+ *********************************************************************** */
 #define COMBINED_HEADER_SIZE (sizeof(struct doff_filehdr_t)+ \
 			     sizeof(struct doff_verify_rec_t))
 
@@ -331,8 +330,9 @@
 	/* Read the header and the verify record as one.  If we don't get it
 	   all, we're done */
 	if (dlthis->strm->read_buffer(dlthis->strm, &dlthis->dfile_hdr,
-	    COMBINED_HEADER_SIZE) != COMBINED_HEADER_SIZE) {
-		DL_ERROR(E_READSTRM, "File Headers");
+				      COMBINED_HEADER_SIZE) !=
+	    COMBINED_HEADER_SIZE) {
+		DL_ERROR(readstrm, "File Headers");
 		return;
 	}
 	/*
@@ -361,10 +361,10 @@
 	 * Verify checksum of header and verify record
 	 */
 	if (~dload_checksum(&dlthis->dfile_hdr,
-	    sizeof(struct doff_filehdr_t)) ||
+			    sizeof(struct doff_filehdr_t)) ||
 	    ~dload_checksum(&dlthis->verify,
-	    sizeof(struct doff_verify_rec_t))) {
-		DL_ERROR(E_CHECKSUM, "header or verify record");
+			    sizeof(struct doff_verify_rec_t))) {
+		DL_ERROR(err_checksum, "header or verify record");
 		return;
 	}
 #if HOST_ENDIANNESS
@@ -373,7 +373,7 @@
 
 	/* Check for valid target ID */
 	if ((dlthis->dfile_hdr.df_target_id != TARGET_ID) &&
-	  -(dlthis->dfile_hdr.df_target_id != TMS470_ID)) {
+	    -(dlthis->dfile_hdr.df_target_id != TMS470_ID)) {
 		dload_error(dlthis, "Bad target ID 0x%x and TARGET_ID 0x%x",
 			    dlthis->dfile_hdr.df_target_id, TARGET_ID);
 		return;
@@ -417,9 +417,9 @@
  *
  *	COFF sections are read in and retained intact.  Each record is embedded
  * 	in a new structure that records the updated load and
- * 	run addresses of the section  */
+ * 	run addresses of the section */
 
-static const char SECN_ERRID[] = { "section" };
+static const char secn_errid[] = { "section" };
 
 /*************************************************************************
  * Procedure dload_sections
@@ -429,9 +429,8 @@
  *
  * Effect:
  *	Loads the section records into an internal table.
- ************************************************************************/
-void
-dload_sections(struct dload_state *dlthis)
+ *********************************************************************** */
+void dload_sections(struct dload_state *dlthis)
 {
 	s16 siz;
 	struct doff_scnhdr_t *shp;
@@ -439,17 +438,18 @@
 
 	/* allocate space for the DOFF section records */
 	siz = nsecs * sizeof(struct doff_scnhdr_t);
-	shp = (struct doff_scnhdr_t *)dlthis->mysym->Allocate(dlthis->mysym,
-	       siz);
+	shp =
+	    (struct doff_scnhdr_t *)dlthis->mysym->dload_allocate(dlthis->mysym,
+								  siz);
 	if (!shp) {		/* not enough storage */
-		DL_ERROR(E_ALLOC, siz);
+		DL_ERROR(err_alloc, siz);
 		return;
 	}
 	dlthis->sect_hdrs = shp;
 
 	/* read in the section records */
 	if (dlthis->strm->read_buffer(dlthis->strm, shp, siz) != siz) {
-		DL_ERROR(E_READSTRM, SECN_ERRID);
+		DL_ERROR(readstrm, secn_errid);
 		return;
 	}
 
@@ -460,7 +460,7 @@
 	/* check for validity */
 	if (~dload_checksum(dlthis->sect_hdrs, siz) !=
 	    dlthis->verify.dv_scn_rec_checksum) {
-		DL_ERROR(E_CHECKSUM, SECN_ERRID);
+		DL_ERROR(err_checksum, secn_errid);
 		return;
 	}
 
@@ -474,28 +474,34 @@
  *
  * Effect:
  *	Assigns new (target) addresses for sections
- *****************************************************************************/
+ **************************************************************************** */
 static void allocate_sections(struct dload_state *dlthis)
 {
 	u16 curr_sect, nsecs, siz;
 	struct doff_scnhdr_t *shp;
-	struct LDR_SECTION_INFO *asecs;
+	struct ldr_section_info *asecs;
 	struct my_handle *hndl;
 	nsecs = dlthis->dfile_hdr.df_no_scns;
 	if (!nsecs)
 		return;
 	if ((dlthis->myalloc == NULL) &&
-	   (dlthis->dfile_hdr.df_target_scns > 0)) {
+	    (dlthis->dfile_hdr.df_target_scns > 0)) {
 		DL_ERROR("Arg 3 (alloc) required but NULL", 0);
 		return;
 	}
-	/* allocate space for the module handle, which we will
-	 *	keep for unload purposes */
-	siz = dlthis->dfile_hdr.df_target_scns *
-	      sizeof(struct LDR_SECTION_INFO) + MY_HANDLE_SIZE;
-	hndl = (struct my_handle *)dlthis->mysym->Allocate(dlthis->mysym, siz);
+	/*
+	 * allocate space for the module handle, which we will keep for unload
+	 * purposes include an additional section store for an auto-generated
+	 * trampoline section in case we need it.
+	 */
+	siz = (dlthis->dfile_hdr.df_target_scns + 1) *
+	    sizeof(struct ldr_section_info) + MY_HANDLE_SIZE;
+
+	hndl =
+	    (struct my_handle *)dlthis->mysym->dload_allocate(dlthis->mysym,
+							      siz);
 	if (!hndl) {		/* not enough storage */
-		DL_ERROR(E_ALLOC, siz);
+		DL_ERROR(err_alloc, siz);
 		return;
 	}
 	/* initialize the handle header */
@@ -514,7 +520,7 @@
 		/* attempt to insert the name of this section */
 		if (soffset < dlthis->dfile_hdr.df_strtab_size)
 			DOFFSEC_IS_LDRSEC(shp)->name = dlthis->str_head +
-							       soffset;
+			    soffset;
 		else {
 			dload_error(dlthis, "Bad name offset in section %d",
 				    curr_sect);
@@ -531,13 +537,14 @@
 #else
 			dlthis->debug_string_size = soffset;
 #endif
-		if (dlthis->myalloc != NULL) {
-			if (!dlthis->myalloc->Allocate(dlthis->myalloc, asecs,
-				     DS_ALIGNMENT(asecs->type))) {
-				dload_error(dlthis, E_TGTALLOC, asecs->name,
-					    asecs->size);
-				return;
-			}
+			if (dlthis->myalloc != NULL) {
+				if (!dlthis->myalloc->
+				    dload_allocate(dlthis->myalloc, asecs,
+						   DS_ALIGNMENT(asecs->type))) {
+					dload_error(dlthis, tgtalloc,
+						    asecs->name, asecs->size);
+					return;
+				}
 			}
 			/* keep address deltas in original section table */
 			shp->ds_vaddr = asecs->load_addr - shp->ds_vaddr;
@@ -564,14 +571,14 @@
  *
  * WARNING:
  *	This routine is not allowed to declare errors!
- ************************************************************************/
+ *********************************************************************** */
 static void section_table_free(struct dload_state *dlthis)
 {
 	struct doff_scnhdr_t *shp;
 
 	shp = dlthis->sect_hdrs;
 	if (shp)
-		dlthis->mysym->Deallocate(dlthis->mysym, shp);
+		dlthis->mysym->dload_deallocate(dlthis->mysym, shp);
 
 }				/* section_table_free */
 
@@ -585,32 +592,34 @@
  * Effect:
  *	Loads the DOFF string table into memory. DOFF keeps all strings in a
  * big unsorted array.  We just read that array into memory in bulk.
- ************************************************************************/
-static const char S_STRINGTBL[] = { "string table" };
-void dload_strings(struct dload_state *dlthis, boolean sec_names_only)
+ *********************************************************************** */
+static const char stringtbl[] = { "string table" };
+
+void dload_strings(struct dload_state *dlthis, bool sec_names_only)
 {
 	u32 ssiz;
 	char *strbuf;
 
 	if (sec_names_only) {
 		ssiz = BYTE_TO_HOST(DOFF_ALIGN
-				   (dlthis->dfile_hdr.df_scn_name_size));
+				    (dlthis->dfile_hdr.df_scn_name_size));
 	} else {
 		ssiz = BYTE_TO_HOST(DOFF_ALIGN
-				   (dlthis->dfile_hdr.df_strtab_size));
+				    (dlthis->dfile_hdr.df_strtab_size));
 	}
 	if (ssiz == 0)
 		return;
 
 	/* get some memory for the string table */
 #if BITS_PER_AU > BITS_PER_BYTE
-	strbuf = (char *)dlthis->mysym->Allocate(dlthis->mysym, ssiz +
-					     dlthis->dfile_hdr.df_max_str_len);
+	strbuf = (char *)dlthis->mysym->dload_allocate(dlthis->mysym, ssiz +
+						       dlthis->dfile_hdr.
+						       df_max_str_len);
 #else
-	strbuf = (char *)dlthis->mysym->Allocate(dlthis->mysym, ssiz);
+	strbuf = (char *)dlthis->mysym->dload_allocate(dlthis->mysym, ssiz);
 #endif
 	if (strbuf == NULL) {
-		DL_ERROR(E_ALLOC, ssiz);
+		DL_ERROR(err_alloc, ssiz);
 		return;
 	}
 	dlthis->str_head = strbuf;
@@ -619,8 +628,8 @@
 #endif
 	/* read in the strings and verify them */
 	if ((unsigned)(dlthis->strm->read_buffer(dlthis->strm, strbuf,
-	    ssiz)) != ssiz) {
-		DL_ERROR(E_READSTRM, S_STRINGTBL);
+						 ssiz)) != ssiz) {
+		DL_ERROR(readstrm, stringtbl);
 	}
 	/* if we need to fix up byte order, do it now */
 #ifndef _BIG_ENDIAN
@@ -628,19 +637,20 @@
 		dload_reorder(strbuf, ssiz, dlthis->reorder_map);
 
 	if ((!sec_names_only) && (~dload_checksum(strbuf, ssiz) !=
-	     dlthis->verify.dv_str_tab_checksum)) {
-		DL_ERROR(E_CHECKSUM, S_STRINGTBL);
+				  dlthis->verify.dv_str_tab_checksum)) {
+		DL_ERROR(err_checksum, stringtbl);
 	}
 #else
 	if (dlthis->dfile_hdr.df_byte_reshuffle !=
 	    HOST_BYTE_ORDER(REORDER_MAP(BYTE_RESHUFFLE_VALUE))) {
 		/* put strings in big-endian order, not in PC order */
-		dload_reorder(strbuf, ssiz, HOST_BYTE_ORDER(dlthis->dfile_hdr.
-					      df_byte_reshuffle));
+		dload_reorder(strbuf, ssiz,
+			      HOST_BYTE_ORDER(dlthis->
+					      dfile_hdr.df_byte_reshuffle));
 	}
 	if ((!sec_names_only) && (~dload_reverse_checksum(strbuf, ssiz) !=
-	     dlthis->verify.dv_str_tab_checksum)) {
-		DL_ERROR(E_CHECKSUM, S_STRINGTBL);
+				  dlthis->verify.dv_str_tab_checksum)) {
+		DL_ERROR(err_checksum, stringtbl);
 	}
 #endif
 }				/* dload_strings */
@@ -656,11 +666,12 @@
  *
  * WARNING:
  *	This routine is not allowed to declare errors!
- *************************************************************************/
+ ************************************************************************ */
 static void string_table_free(struct dload_state *dlthis)
 {
 	if (dlthis->str_head)
-		dlthis->mysym->Deallocate(dlthis->mysym, dlthis->str_head);
+		dlthis->mysym->dload_deallocate(dlthis->mysym,
+						dlthis->str_head);
 
 }				/* string_table_free */
 
@@ -670,7 +681,7 @@
  * COFF symbols are read by dload_symbols(), which is called after
  * sections have been allocated.  Symbols which might be used in
  * relocation (ie, not debug info) are retained in an internal temporary
- * compressed table (type Local_Symbol). A particular symbol is recovered
+ * compressed table (type local_symbol). A particular symbol is recovered
  * by index by calling dload_find_symbol().  dload_find_symbol
  * reconstructs a more explicit representation (type SLOTVEC) which is
  * used by reloc.c
@@ -678,7 +689,7 @@
 /* real size of debug header */
 #define DBG_HDR_SIZE (sizeof(struct dll_module) - sizeof(struct dll_sect))
 
-static const char SYM_ERRID[] = { "symbol" };
+static const char sym_errid[] = { "symbol" };
 
 /**************************************************************************
  * Procedure dload_symbols
@@ -689,46 +700,52 @@
  * Effect:
  *	Reads in symbols and retains ones that might be needed for relocation
  * purposes.
- ************************************************************************/
+ *********************************************************************** */
 /* size of symbol buffer no bigger than target data buffer, to limit stack
- * usage*/
+ * usage */
 #define MY_SYM_BUF_SIZ (BYTE_TO_HOST(IMAGE_PACKET_SIZE)/\
 			sizeof(struct doff_syment_t))
 
 static void dload_symbols(struct dload_state *dlthis)
 {
-	u32 s_count, siz, dsiz, symbols_left;
+	u32 sym_count, siz, dsiz, symbols_left;
 	u32 checks;
-	struct Local_Symbol *sp;
+	struct local_symbol *sp;
 	struct dynload_symbol *symp;
 	struct dynload_symbol *newsym;
 
-	s_count = dlthis->dfile_hdr.df_no_syms;
-	if (s_count == 0)
+	sym_count = dlthis->dfile_hdr.df_no_syms;
+	if (sym_count == 0)
 		return;
 
-	/* We keep a local symbol table for all of the symbols in the input.
+	/*
+	 * We keep a local symbol table for all of the symbols in the input.
 	 * This table contains only section & value info, as we do not have
 	 * to do any name processing for locals.  We reuse this storage
 	 * as a temporary for .dllview record construction.
-	 * Allocate storage for the whole table.*/
-	siz = s_count * sizeof(struct Local_Symbol);
+	 * Allocate storage for the whole table.  Add 1 to the section count
+	 * in case a trampoline section is auto-generated as well as the
+	 * size of the trampoline section name so DLLView doens't get lost.
+	 */
+
+	siz = sym_count * sizeof(struct local_symbol);
 	dsiz = DBG_HDR_SIZE +
-		(sizeof(struct dll_sect) * dlthis->allocated_secn_count) +
+	    (sizeof(struct dll_sect) * dlthis->allocated_secn_count) +
 	    BYTE_TO_HOST_ROUND(dlthis->debug_string_size + 1);
 	if (dsiz > siz)
 		siz = dsiz;	/* larger of symbols and .dllview temp */
-	sp = (struct Local_Symbol *)dlthis->mysym->Allocate(dlthis->mysym, siz);
+	sp = (struct local_symbol *)dlthis->mysym->dload_allocate(dlthis->mysym,
+								  siz);
 	if (!sp) {
-		DL_ERROR(E_ALLOC, siz);
+		DL_ERROR(err_alloc, siz);
 		return;
 	}
 	dlthis->local_symtab = sp;
 	/* Read the symbols in the input, store them in the table, and post any
 	 * globals to the global symbol table.  In the process, externals
-	   become defined from the global symbol table */
+	 become defined from the global symbol table */
 	checks = dlthis->verify.dv_sym_tab_checksum;
-	symbols_left = s_count;
+	symbols_left = sym_count;
 	do {			/* read all symbols */
 		char *sname;
 		u32 val;
@@ -738,11 +755,11 @@
 		struct doff_syment_t my_sym_buf[MY_SYM_BUF_SIZ];
 		input_sym = my_sym_buf;
 		syms_in_buf = symbols_left > MY_SYM_BUF_SIZ ?
-					     MY_SYM_BUF_SIZ : symbols_left;
+		    MY_SYM_BUF_SIZ : symbols_left;
 		siz = syms_in_buf * sizeof(struct doff_syment_t);
 		if (dlthis->strm->read_buffer(dlthis->strm, input_sym, siz) !=
-					      siz) {
-			DL_ERROR(E_READSTRM, SYM_ERRID);
+		    siz) {
+			DL_ERROR(readstrm, sym_errid);
 			return;
 		}
 		if (dlthis->reorder_map)
@@ -758,14 +775,14 @@
 				if ((u32) input_sym->dn_offset <
 				    dlthis->dfile_hdr.df_strtab_size)
 					sname = dlthis->str_head +
-					     BYTE_TO_HOST(input_sym->dn_offset);
+					    BYTE_TO_HOST(input_sym->dn_offset);
 				else
 					dload_error(dlthis,
-						 "Bad name offset in symbol %d",
-						 symbols_left);
+						    "Bad name offset in symbol "
+						    " %d", symbols_left);
 #else
 				sname = unpack_name(dlthis,
-						   input_sym->dn_offset);
+						    input_sym->dn_offset);
 #endif
 			}
 			val = input_sym->dn_value;
@@ -773,37 +790,43 @@
 			sp->sclass = input_sym->dn_sclass;
 			sp->secnn = input_sym->dn_scnum;
 			/* if this is an undefined symbol,
-			 * define it (or fail) now	  */
+			 * define it (or fail) now */
 			if (sp->secnn == DN_UNDEF) {
-					/* pointless for static undefined */
+				/* pointless for static undefined */
 				if (input_sym->dn_sclass != DN_EXT)
 					goto loop_cont;
 
 				/* try to define symbol from previously
-				 * loaded images			  */
-				symp = dlthis->mysym->Find_Matching_Symbol
-						      (dlthis->mysym, sname);
+				 * loaded images */
+				symp = dlthis->mysym->find_matching_symbol
+				    (dlthis->mysym, sname);
 				if (!symp) {
 					DL_ERROR
-						("Undefined external symbol %s",
-						 sname);
+					    ("Undefined external symbol %s",
+					     sname);
 					goto loop_cont;
 				}
 				val = delta = symp->value;
+#ifdef ENABLE_TRAMP_DEBUG
+				dload_syms_error(dlthis->mysym,
+						 "===> ext sym [%s] at %x",
+						 sname, val);
+#endif
+
 				goto loop_cont;
 			}
 			/* symbol defined by this module */
-			if (sp->secnn > 0) {   /* symbol references a section */
+			if (sp->secnn > 0) {
+				/* symbol references a section */
 				if ((unsigned)sp->secnn <=
 				    dlthis->allocated_secn_count) {
 					/* section was allocated */
 					struct doff_scnhdr_t *srefp =
-							     &dlthis->sect_hdrs
-							     [sp->secnn - 1];
+					    &dlthis->sect_hdrs[sp->secnn - 1];
 
 					if (input_sym->dn_sclass ==
 					    DN_STATLAB ||
-					    input_sym->dn_sclass == DN_EXTLAB){
+					    input_sym->dn_sclass == DN_EXTLAB) {
 						/* load */
 						delta = srefp->ds_vaddr;
 					} else {
@@ -816,16 +839,19 @@
 			}
 			/* This symbol is an absolute symbol */
 			if (sp->secnn == DN_ABS && ((sp->sclass == DN_EXT) ||
-						   (sp->sclass == DN_EXTLAB))) {
-				symp = dlthis->mysym->Find_Matching_Symbol
-						      (dlthis->mysym, sname);
+						    (sp->sclass ==
+						     DN_EXTLAB))) {
+				symp =
+				    dlthis->mysym->find_matching_symbol(dlthis->
+									mysym,
+									sname);
 				if (!symp)
 					goto loop_itr;
-				/* This absolute symbol is already defined.  */
+				/* This absolute symbol is already defined. */
 				if (symp->value == input_sym->dn_value) {
 					/* If symbol values are equal, continue
 					 * but don't add to the global symbol
-					 * table			     */
+					 * table */
 					sp->value = val;
 					sp->delta = delta;
 					sp += 1;
@@ -835,14 +861,14 @@
 					/* If symbol values are not equal,
 					 * return with redefinition error */
 					DL_ERROR("Absolute symbol %s is "
-					   "defined multiple times with "
-					   "different values", sname);
+						 "defined multiple times with "
+						 "different values", sname);
 					return;
 				}
 			}
 loop_itr:
 			/* if this is a global symbol, post it to the
-			 * global table			       */
+			 * global table */
 			if (input_sym->dn_sclass == DN_EXT ||
 			    input_sym->dn_sclass == DN_EXTLAB) {
 				/* Keep this global symbol for subsequent
@@ -851,9 +877,9 @@
 				if (!sname)
 					goto loop_cont;
 
-				newsym = dlthis->mysym->Add_To_Symbol_Table
-						    (dlthis->mysym, sname,
-						    (unsigned)dlthis->myhandle);
+				newsym = dlthis->mysym->add_to_symbol_table
+				    (dlthis->mysym, sname,
+				     (unsigned)dlthis->myhandle);
 				if (newsym)
 					newsym->value = val;
 
@@ -863,7 +889,7 @@
 			sp->delta = delta;
 			sp += 1;
 			input_sym += 1;
-		} while ((syms_in_buf -= 1) > 0); /* process sym in buffer */
+		} while ((syms_in_buf -= 1) > 0);	/* process sym in buf */
 	} while (symbols_left > 0);	/* read all symbols */
 	if (~checks)
 		dload_error(dlthis, "Checksum of symbols failed");
@@ -881,15 +907,17 @@
  *
  * WARNING:
  *	This routine is not allowed to declare errors!
- *****************************************************************************/
+ **************************************************************************** */
 static void symbol_table_free(struct dload_state *dlthis)
 {
 	if (dlthis->local_symtab) {
 		if (dlthis->dload_errcount) {	/* blow off our symbols */
-			dlthis->mysym->Purge_Symbol_Table(dlthis->mysym,
-						   (unsigned)dlthis->myhandle);
+			dlthis->mysym->purge_symbol_table(dlthis->mysym,
+							  (unsigned)
+							  dlthis->myhandle);
 		}
-		dlthis->mysym->Deallocate(dlthis->mysym, dlthis->local_symtab);
+		dlthis->mysym->dload_deallocate(dlthis->mysym,
+						dlthis->local_symtab);
 	}
 }				/* symbol_table_free */
 
@@ -905,8 +933,9 @@
  */
 
 /* The following are only for use by reloc.c and things it calls */
-static const struct LDR_SECTION_INFO CINIT_INFO_INIT = { CINITNAME, 0, 0,
-					(LDR_ADDR) -1, 0, DLOAD_BSS, 0 };
+static const struct ldr_section_info cinit_info_init = { cinitname, 0, 0,
+	(ldr_addr)-1, 0, DLOAD_BSS, 0
+};
 
 /*************************************************************************
  * Procedure cload_cinit
@@ -917,7 +946,7 @@
  * Effect:
  *	Interprets the data in the buffer as .cinit data, and performs the
  * appropriate initializations.
- ************************************************************************/
+ *********************************************************************** */
 static void cload_cinit(struct dload_state *dlthis,
 			struct image_packet_t *ipacket)
 {
@@ -926,92 +955,92 @@
 #else
 	s16 init_count, left;
 #endif
-	unsigned char *pktp = ipacket->i_bits;
-	unsigned char *pktend =	pktp +
-				BYTE_TO_HOST_ROUND(ipacket->i_packet_size);
+	unsigned char *pktp = ipacket->img_data;
+	unsigned char *pktend = pktp + BYTE_TO_HOST_ROUND(ipacket->packet_size);
 	int temp;
-	LDR_ADDR atmp;
-	struct LDR_SECTION_INFO cinit_info;
+	ldr_addr atmp;
+	struct ldr_section_info cinit_info;
 
-	/*  PROCESS ALL THE INITIALIZATION RECORDS IN THE BUFFER.  */
+	/*  PROCESS ALL THE INITIALIZATION RECORDS IN THE BUFFER. */
 	while (true) {
 		left = pktend - pktp;
 		switch (dlthis->cinit_state) {
-		case CI_count:	/* count field */
+		case CI_COUNT:	/* count field */
 			if (left < TDATA_TO_HOST(CINIT_COUNT))
 				goto loopexit;
-			temp = dload_unpack(dlthis, (TgtAU_t *)pktp,
-					CINIT_COUNT * TDATA_AU_BITS, 0,
-					ROP_SGN);
+			temp = dload_unpack(dlthis, (tgt_au_t *) pktp,
+					    CINIT_COUNT * TDATA_AU_BITS, 0,
+					    ROP_SGN);
 			pktp += TDATA_TO_HOST(CINIT_COUNT);
 			/* negative signifies BSS table, zero means done */
 			if (temp <= 0) {
-				dlthis->cinit_state = CI_done;
+				dlthis->cinit_state = CI_DONE;
 				break;
 			}
 			dlthis->cinit_count = temp;
-			dlthis->cinit_state = CI_address;
+			dlthis->cinit_state = CI_ADDRESS;
 			break;
 #if CINIT_ALIGN < CINIT_ADDRESS
-		case CI_partaddress:
+		case CI_PARTADDRESS:
 			pktp -= TDATA_TO_HOST(CINIT_ALIGN);
 			/* back up pointer into space courtesy of caller */
-			*(uint16_t *)pktp = dlthis->cinit_addr;
+			*(uint16_t *) pktp = dlthis->cinit_addr;
 			/* stuff in saved bits  !! FALL THRU !! */
 #endif
-		case CI_address:	/* Address field for a copy packet */
+		case CI_ADDRESS:	/* Address field for a copy packet */
 			if (left < TDATA_TO_HOST(CINIT_ADDRESS)) {
 #if CINIT_ALIGN < CINIT_ADDRESS
 				if (left == TDATA_TO_HOST(CINIT_ALIGN)) {
 					/* address broken into halves */
-					dlthis->cinit_addr = *(uint16_t *)pktp;
+					dlthis->cinit_addr = *(uint16_t *) pktp;
 					/* remember 1st half */
-					dlthis->cinit_state = CI_partaddress;
+					dlthis->cinit_state = CI_PARTADDRESS;
 					left = 0;
 				}
 #endif
 				goto loopexit;
 			}
-			atmp = dload_unpack(dlthis, (TgtAU_t *)pktp,
-					CINIT_ADDRESS * TDATA_AU_BITS, 0,
-					ROP_UNS);
+			atmp = dload_unpack(dlthis, (tgt_au_t *) pktp,
+					    CINIT_ADDRESS * TDATA_AU_BITS, 0,
+					    ROP_UNS);
 			pktp += TDATA_TO_HOST(CINIT_ADDRESS);
 #if CINIT_PAGE_BITS > 0
 			dlthis->cinit_page = atmp &
-					     ((1 << CINIT_PAGE_BITS) - 1);
+			    ((1 << CINIT_PAGE_BITS) - 1);
 			atmp >>= CINIT_PAGE_BITS;
 #else
 			dlthis->cinit_page = CINIT_DEFAULT_PAGE;
 #endif
 			dlthis->cinit_addr = atmp;
-			dlthis->cinit_state = CI_copy;
+			dlthis->cinit_state = CI_COPY;
 			break;
-		case CI_copy:	/* copy bits to the target */
+		case CI_COPY:	/* copy bits to the target */
 			init_count = HOST_TO_TDATA(left);
 			if (init_count > dlthis->cinit_count)
 				init_count = dlthis->cinit_count;
 			if (init_count == 0)
 				goto loopexit;	/* get more bits */
-			cinit_info = CINIT_INFO_INIT;
+			cinit_info = cinit_info_init;
 			cinit_info.page = dlthis->cinit_page;
 			if (!dlthis->myio->writemem(dlthis->myio, pktp,
-					TDATA_TO_TADDR(dlthis->cinit_addr),
-					&cinit_info,
-					TDATA_TO_HOST(init_count))) {
-				dload_error(dlthis, E_INITFAIL, "write",
+						   TDATA_TO_TADDR
+						   (dlthis->cinit_addr),
+						   &cinit_info,
+						   TDATA_TO_HOST(init_count))) {
+				dload_error(dlthis, initfail, "write",
 					    dlthis->cinit_addr);
 			}
 			dlthis->cinit_count -= init_count;
-			if (dlthis->cinit_count  <= 0) {
-				dlthis->cinit_state = CI_count;
+			if (dlthis->cinit_count <= 0) {
+				dlthis->cinit_state = CI_COUNT;
 				init_count = (init_count + CINIT_ALIGN - 1) &
-					     -CINIT_ALIGN;
+				    -CINIT_ALIGN;
 				/* align to next init */
 			}
 			pktp += TDATA_TO_HOST(init_count);
 			dlthis->cinit_addr += init_count;
 			break;
-		case CI_done:	/* no more .cinit to do */
+		case CI_DONE:	/* no more .cinit to do */
 			return;
 		}		/* switch (cinit_state) */
 	}			/* while */
@@ -1019,7 +1048,7 @@
 loopexit:
 	if (left > 0) {
 		dload_error(dlthis, "%d bytes left over in cinit packet", left);
-		dlthis->cinit_state = CI_done;	/* left over bytes are bad */
+		dlthis->cinit_state = CI_DONE;	/* left over bytes are bad */
 	}
 }				/* cload_cinit */
 
@@ -1041,15 +1070,17 @@
  * Effect:
  *	Performs the required relocations on the packet.  Returns a checksum
  * of the relocation operations.
- ************************************************************************/
+ *********************************************************************** */
 #define MY_RELOC_BUF_SIZ 8
-/* careful! exists at the same time as the image buffer*/
+/* careful! exists at the same time as the image buffer */
 static int relocate_packet(struct dload_state *dlthis,
-			   struct image_packet_t *ipacket, u32 *checks)
+			   struct image_packet_t *ipacket,
+			   u32 *checks, bool *tramps_generated)
 {
 	u32 rnum;
+	*tramps_generated = false;
 
-	rnum = ipacket->i_num_relocs;
+	rnum = ipacket->num_relocs;
 	do {			/* all relocs */
 		unsigned rinbuf;
 		int siz;
@@ -1058,7 +1089,7 @@
 		rinbuf = rnum > MY_RELOC_BUF_SIZ ? MY_RELOC_BUF_SIZ : rnum;
 		siz = rinbuf * sizeof(struct reloc_record_t);
 		if (dlthis->strm->read_buffer(dlthis->strm, rp, siz) != siz) {
-			DL_ERROR(E_READSTRM, "relocation");
+			DL_ERROR(readstrm, "relocation");
 			return 0;
 		}
 		/* reorder the bytes if need be */
@@ -1068,18 +1099,29 @@
 		*checks += dload_checksum(rp, siz);
 		do {
 			/* perform the relocation operation */
-			dload_relocate(dlthis, (TgtAU_t *) ipacket->i_bits, rp);
+			dload_relocate(dlthis, (tgt_au_t *) ipacket->img_data,
+				       rp, tramps_generated, false);
 			rp += 1;
 			rnum -= 1;
 		} while ((rinbuf -= 1) > 0);
 	} while (rnum > 0);	/* all relocs */
+	/* If trampoline(s) were generated, we need to do an update of the
+	 * trampoline copy of the packet since a 2nd phase relo will be done
+	 * later. */
+	if (*tramps_generated == true) {
+		dload_tramp_pkt_udpate(dlthis,
+				       (dlthis->image_secn -
+					dlthis->ldr_sections),
+				       dlthis->image_offset, ipacket);
+	}
+
 	return 1;
 }				/* dload_read_reloc */
 
 #define IPH_SIZE (sizeof(struct image_packet_t) - sizeof(u32))
 
 /* VERY dangerous */
-static const char IMAGEPAK[] = { "image packet" };
+static const char imagepak[] = { "image packet" };
 
 /*************************************************************************
  * Procedure dload_data
@@ -1090,16 +1132,16 @@
  * Effect:
  *	Read image data from input file, relocate it, and download it to the
  *	target.
- ************************************************************************/
+ *********************************************************************** */
 static void dload_data(struct dload_state *dlthis)
 {
 	u16 curr_sect;
 	struct doff_scnhdr_t *sptr = dlthis->sect_hdrs;
-	struct LDR_SECTION_INFO *lptr = dlthis->ldr_sections;
+	struct ldr_section_info *lptr = dlthis->ldr_sections;
 #ifdef OPT_ZERO_COPY_LOADER
-	boolean bZeroCopy = false;
+	bool zero_copy = false;
 #endif
-	u8 *pDest;
+	u8 *dest;
 
 	struct {
 		struct image_packet_t ipacket;
@@ -1107,7 +1149,7 @@
 	} ibuf;
 
 	/* Indicates whether CINIT processing has occurred */
-	boolean cinit_processed = false;
+	bool cinit_processed = false;
 
 	/* Loop through the sections and load them one at a time.
 	 */
@@ -1115,7 +1157,7 @@
 	     curr_sect += 1) {
 		if (DS_NEEDS_DOWNLOAD(sptr)) {
 			s32 nip;
-			LDR_ADDR image_offset = 0;
+			ldr_addr image_offset = 0;
 			/* set relocation info for this section */
 			if (curr_sect < dlthis->allocated_secn_count)
 				dlthis->delta_runaddr = sptr->ds_paddr;
@@ -1132,10 +1174,14 @@
 
 				s32 ipsize;
 				u32 checks;
+				bool tramp_generated = false;
+
 				/* get the fixed header bits */
 				if (dlthis->strm->read_buffer(dlthis->strm,
-				    &ibuf.ipacket, IPH_SIZE) != IPH_SIZE) {
-					DL_ERROR(E_READSTRM, IMAGEPAK);
+							      &ibuf.ipacket,
+							      IPH_SIZE) !=
+				    IPH_SIZE) {
+					DL_ERROR(readstrm, imagepak);
 					return;
 				}
 				/* reorder the header if need be */
@@ -1146,93 +1192,118 @@
 				/* now read the rest of the packet */
 				ipsize =
 				    BYTE_TO_HOST(DOFF_ALIGN
-						(ibuf.ipacket.i_packet_size));
+						 (ibuf.ipacket.packet_size));
 				if (ipsize > BYTE_TO_HOST(IMAGE_PACKET_SIZE)) {
 					DL_ERROR("Bad image packet size %d",
-						ipsize);
+						 ipsize);
 					return;
 				}
-				pDest = ibuf.bufr;
+				dest = ibuf.bufr;
 #ifdef OPT_ZERO_COPY_LOADER
-				bZeroCopy = false;
+				zero_copy = false;
 				if (DLOAD_SECT_TYPE(sptr) != DLOAD_CINIT) {
 					dlthis->myio->writemem(dlthis->myio,
-						&pDest, lptr->load_addr +
-						image_offset, lptr, 0);
-				bZeroCopy = (pDest != ibuf.bufr);
+							       &dest,
+							       lptr->load_addr +
+							       image_offset,
+							       lptr, 0);
+					zero_copy = (dest != ibuf.bufr);
 				}
 #endif
-		/* End of determination */
+				/* End of determination */
 
 				if (dlthis->strm->read_buffer(dlthis->strm,
-				    ibuf.bufr, ipsize) != ipsize) {
-					DL_ERROR(E_READSTRM, IMAGEPAK);
+							      ibuf.bufr,
+							      ipsize) !=
+				    ipsize) {
+					DL_ERROR(readstrm, imagepak);
 					return;
 				}
-				ibuf.ipacket.i_bits = pDest;
+				ibuf.ipacket.img_data = dest;
 
 				/* reorder the bytes if need be */
 #if !defined(_BIG_ENDIAN) || (TARGET_AU_BITS > 16)
 				if (dlthis->reorder_map) {
-					dload_reorder(pDest, ipsize,
-						     dlthis->reorder_map);
+					dload_reorder(dest, ipsize,
+						      dlthis->reorder_map);
 				}
-				checks = dload_checksum(pDest, ipsize);
+				checks = dload_checksum(dest, ipsize);
 #else
 				if (dlthis->dfile_hdr.df_byte_reshuffle !=
 				    TARGET_ORDER(REORDER_MAP
-				    (BYTE_RESHUFFLE_VALUE))) {
+						 (BYTE_RESHUFFLE_VALUE))) {
 					/* put image bytes in big-endian order,
 					 * not PC order */
-					dload_reorder(pDest, ipsize,
-					TARGET_ORDER
-					(dlthis->dfile_hdr.df_byte_reshuffle));
+					dload_reorder(dest, ipsize,
+						      TARGET_ORDER
+						      (dlthis->dfile_hdr.
+						       df_byte_reshuffle));
 				}
 #if TARGET_AU_BITS > 8
-				checks = dload_reverse_checksum_16(pDest,
-								   ipsize);
+				checks = dload_reverse_checksum16(dest, ipsize);
 #else
-				checks = dload_reverse_checksum(pDest,
-								ipsize);
+				checks = dload_reverse_checksum(dest, ipsize);
 #endif
 #endif
 
 				checks += dload_checksum(&ibuf.ipacket,
-							IPH_SIZE);
+							 IPH_SIZE);
 				/* relocate the image bits as needed */
-				if (ibuf.ipacket.i_num_relocs) {
+				if (ibuf.ipacket.num_relocs) {
 					dlthis->image_offset = image_offset;
 					if (!relocate_packet(dlthis,
-					    &ibuf.ipacket, &checks))
+							     &ibuf.ipacket,
+							     &checks,
+							     &tramp_generated))
 						return;	/* serious error */
 				}
 				if (~checks)
-					DL_ERROR(E_CHECKSUM, IMAGEPAK);
-				/* stuff the result into target memory */
-				if (DLOAD_SECT_TYPE(sptr) == DLOAD_CINIT) {
-					cload_cinit(dlthis, &ibuf.ipacket);
-					cinit_processed = true;
-				} else {
+					DL_ERROR(err_checksum, imagepak);
+				/* Only write the result to the target if no
+				 * trampoline was generated.  Otherwise it
+				 *will be done during trampoline finalize. */
+
+				if (tramp_generated == false) {
+
+					/* stuff the result into target
+					 * memory */
+					if (DLOAD_SECT_TYPE(sptr) ==
+					    DLOAD_CINIT) {
+						cload_cinit(dlthis,
+							    &ibuf.ipacket);
+						cinit_processed = true;
+					} else {
 #ifdef OPT_ZERO_COPY_LOADER
-				    if (!bZeroCopy) {
+						if (!zero_copy) {
 #endif
-
-					if (!dlthis->myio->writemem
-					   (dlthis->myio, ibuf.bufr,
-					   lptr->load_addr + image_offset, lptr,
-					   BYTE_TO_HOST
-					   (ibuf.ipacket.i_packet_size))) {
-						DL_ERROR(
-						"Write to " FMT_UI32 " failed",
-						lptr->load_addr + image_offset);
-					}
+							/* FIXME */
+							if (!dlthis->myio->
+							    writemem(dlthis->
+								myio,
+								ibuf.bufr,
+								lptr->
+								load_addr +
+								image_offset,
+								lptr,
+								BYTE_TO_HOST
+								(ibuf.
+								ipacket.
+								packet_size))) {
+								DL_ERROR
+								  ("Write to "
+								  FMT_UI32
+								  " failed",
+								  lptr->
+								  load_addr +
+								  image_offset);
+							}
 #ifdef OPT_ZERO_COPY_LOADER
-				}
+						}
 #endif
-
+					}
 				}
 				image_offset +=
-				      BYTE_TO_TADDR(ibuf.ipacket.i_packet_size);
+				    BYTE_TO_TADDR(ibuf.ipacket.packet_size);
 			}	/* process packets */
 			/* if this is a BSS section, we may want to fill it */
 			if (DLOAD_SECT_TYPE(sptr) != DLOAD_BSS)
@@ -1245,17 +1316,19 @@
 				/* Don't clear BSS after load-time
 				 * initialization */
 				DL_ERROR
-				  ("Zero-initialization at " FMT_UI32 " after "
-				  "load-time initialization!", lptr->load_addr);
+				    ("Zero-initialization at " FMT_UI32
+				     " after " "load-time initialization!",
+				     lptr->load_addr);
 				goto loop_cont;
 			}
 			/* fill the .bss area */
 			dlthis->myio->fillmem(dlthis->myio,
 					      TADDR_TO_HOST(lptr->load_addr),
 					      lptr, TADDR_TO_HOST(lptr->size),
-					      dload_fill_bss);
+					      DLOAD_FILL_BSS);
 			goto loop_cont;
-		} /* if DS_DOWNLOAD_MASK */
+		}
+		/* if DS_DOWNLOAD_MASK */
 		/* If not loading, but BSS, zero initialize */
 		if (DLOAD_SECT_TYPE(sptr) != DLOAD_BSS)
 			goto loop_cont;
@@ -1268,19 +1341,26 @@
 
 		if (cinit_processed) {
 			/*Don't clear BSS after load-time initialization */
-			DL_ERROR(
-			 "Zero-initialization at " FMT_UI32 " attempted after "
-			 "load-time initialization!", lptr->load_addr);
+			DL_ERROR("Zero-initialization at " FMT_UI32
+				 " attempted after "
+				 "load-time initialization!", lptr->load_addr);
 			goto loop_cont;
 		}
 		/* fill the .bss area */
 		dlthis->myio->fillmem(dlthis->myio,
-				     TADDR_TO_HOST(lptr->load_addr), lptr,
-				     TADDR_TO_HOST(lptr->size), dload_fill_bss);
+				      TADDR_TO_HOST(lptr->load_addr), lptr,
+				      TADDR_TO_HOST(lptr->size),
+				      DLOAD_FILL_BSS);
 loop_cont:
 		sptr += 1;
 		lptr += 1;
 	}			/* load sections */
+
+	/*  Finalize any trampolines that were created during the load */
+	if (dload_tramp_finalize(dlthis) == 0) {
+		DL_ERROR("Finalization of auto-trampolines (size = " FMT_UI32
+			 ") failed", dlthis->tramp.tramp_sect_next_addr);
+	}
 }				/* dload_data */
 
 /*************************************************************************
@@ -1296,14 +1376,14 @@
  * Effect:
  *	Re-arranges the bytes in each word according to the map specified.
  *
- ************************************************************************/
+ *********************************************************************** */
 /* mask for byte shift count */
 #define SHIFT_COUNT_MASK (3 << LOG_BITS_PER_BYTE)
 
 void dload_reorder(void *data, int dsiz, unsigned int map)
 {
 	register u32 tmp, tmap, datv;
-	u32 *dp = (u32 *)data;
+	u32 *dp = (u32 *) data;
 
 	map <<= LOG_BITS_PER_BYTE;	/* align map with SHIFT_COUNT_MASK */
 	do {
@@ -1328,7 +1408,7 @@
  * Effect:
  *	Returns a checksum of the specified block
  *
- ************************************************************************/
+ *********************************************************************** */
 u32 dload_checksum(void *data, unsigned siz)
 {
 	u32 sum;
@@ -1336,7 +1416,7 @@
 	int left;
 
 	sum = 0;
-	dp = (u32 *)data;
+	dp = (u32 *) data;
 	for (left = siz; left > 0; left -= sizeof(u32))
 		sum += *dp++;
 	return sum;
@@ -1359,7 +1439,7 @@
  * in host order. But dllcreate always checksums in little-endian order.
  * It is most efficient to just handle the difference a word at a time.
  *
- ***********************************************************************/
+ ********************************************************************** */
 u32 dload_reverse_checksum(void *data, unsigned siz)
 {
 	u32 sum, temp;
@@ -1367,7 +1447,7 @@
 	int left;
 
 	sum = 0;
-	dp = (u32 *)data;
+	dp = (u32 *) data;
 
 	for (left = siz; left > 0; left -= sizeof(u32)) {
 		temp = *dp++;
@@ -1381,14 +1461,14 @@
 }				/* dload_reverse_checksum */
 
 #if (TARGET_AU_BITS > 8) && (TARGET_AU_BITS < 32)
-u32 dload_reverse_checksum_16(void *data, unsigned siz)
+u32 dload_reverse_checksum16(void *data, unsigned siz)
 {
 	uint_fast32_t sum, temp;
 	u32 *dp;
 	int left;
 
 	sum = 0;
-	dp = (u32 *)data;
+	dp = (u32 *) data;
 
 	for (left = siz; left > 0; left -= sizeof(u32)) {
 		temp = *dp++;
@@ -1397,7 +1477,7 @@
 	}
 
 	return sum;
-}				/* dload_reverse_checksum_16 */
+}				/* dload_reverse_checksum16 */
 #endif
 #endif
 
@@ -1413,7 +1493,7 @@
  * Effect:
  *	Swaps the specified data according to the specified map
  *
- ************************************************************************/
+ *********************************************************************** */
 static void swap_words(void *data, unsigned siz, unsigned bitmap)
 {
 	register int i;
@@ -1465,31 +1545,26 @@
  * target addressable unit order).  Makes sure the last string in the
  * buffer is NULL terminated (for safety).
  * Returns the first unused destination address.
- ************************************************************************/
+ *********************************************************************** */
 static char *copy_tgt_strings(void *dstp, void *srcp, unsigned charcount)
 {
-	register TgtAU_t *src = (TgtAU_t *)srcp;
-	register TgtAU_t *dst = (TgtAU_t *)dstp;
+	register tgt_au_t *src = (tgt_au_t *) srcp;
+	register tgt_au_t *dst = (tgt_au_t *) dstp;
 	register int cnt = charcount;
 	do {
 #if TARGET_AU_BITS <= BITS_PER_AU
 		/* byte-swapping issues may exist for strings on target */
 		*dst++ = *src++;
-#elif TARGET_ENDIANNESS_DIFFERS(TARGET_BIG_ENDIAN)
-		register TgtAU_t tmp;
-		tmp = *src++;
-		*dst++ = SWAP16BY8(tmp);  /* right for TARGET_AU_BITS == 16 */
 #else
 		*dst++ = *src++;
 #endif
-	} while ((cnt -= (sizeof(TgtAU_t) * BITS_PER_AU / BITS_PER_BYTE)) > 0);
+	} while ((cnt -= (sizeof(tgt_au_t) * BITS_PER_AU / BITS_PER_BYTE)) > 0);
 	/*apply force to make sure that the string table has null terminator */
 #if (BITS_PER_AU == BITS_PER_BYTE) && (TARGET_AU_BITS == BITS_PER_BYTE)
 	dst[-1] = 0;
-#elif TARGET_BIG_ENDIAN
-	dst[-1] &= ~BYTE_MASK;	/*  big-endian */
 #else
-	dst[-1] &= (1 << (BITS_PER_AU - BITS_PER_BYTE)) - 1; /* little endian */
+	/* little endian */
+	dst[-1] &= (1 << (BITS_PER_AU - BITS_PER_BYTE)) - 1;
 #endif
 	return (char *)dst;
 }				/* copy_tgt_strings */
@@ -1505,33 +1580,45 @@
  * the debug information required by the target.
  *
  * Notes:
- * The handle returned from Dynamic_Load_Module needs to encapsulate all the
+ * The handle returned from dynamic_load_module needs to encapsulate all the
  * allocations done for the module, and enable them plus the modules symbols to
  * be deallocated.
  *
- ************************************************************************/
+ *********************************************************************** */
 #ifndef _BIG_ENDIAN
-static const struct LDR_SECTION_INFO DLLVIEW_INFO_INIT = { ".dllview", 0, 0,
-				(LDR_ADDR) -1, DBG_LIST_PAGE, DLOAD_DATA, 0 };
+static const struct ldr_section_info dllview_info_init = { ".dllview", 0, 0,
+	(ldr_addr)-1, DBG_LIST_PAGE, DLOAD_DATA, 0
+};
 #else
-static const struct LDR_SECTION_INFO DLLVIEW_INFO_INIT = { ".dllview", 0, 0,
-				(LDR_ADDR) -1, DLOAD_DATA, DBG_LIST_PAGE, 0 };
+static const struct ldr_section_info dllview_info_init = { ".dllview", 0, 0,
+	(ldr_addr)-1, DLOAD_DATA, DBG_LIST_PAGE, 0
+};
 #endif
 static void init_module_handle(struct dload_state *dlthis)
 {
 	struct my_handle *hndl;
 	u16 curr_sect;
-	struct LDR_SECTION_INFO *asecs;
+	struct ldr_section_info *asecs;
 	struct dll_module *dbmod;
 	struct dll_sect *dbsec;
 	struct dbg_mirror_root *mlist;
 	register char *cp;
 	struct modules_header mhdr;
-	struct LDR_SECTION_INFO dllview_info;
+	struct ldr_section_info dllview_info;
 	struct dynload_symbol *debug_mirror_sym;
 	hndl = dlthis->myhandle;
 	if (!hndl)
 		return;		/* must be errors detected, so forget it */
+
+	/*  Store the section count */
+	hndl->secn_count = dlthis->allocated_secn_count;
+
+	/*  If a trampoline section was created, add it in */
+	if (dlthis->tramp.tramp_sect_next_addr != 0)
+		hndl->secn_count += 1;
+
+	hndl->secn_count = hndl->secn_count << 1;
+
 	hndl->secn_count = dlthis->allocated_secn_count << 1;
 #ifndef TARGET_ENDIANNESS
 	if (dlthis->big_e_target)
@@ -1539,30 +1626,31 @@
 #endif
 	if (dlthis->dload_errcount)
 		return;		/* abandon if errors detected */
-	 /* Locate the symbol that names the header for the CCS debug list
-	 of modules. If not found, we just don't generate the debug record.
-	 If found, we create our modules list.  We make sure to create the
-	 LOADER_DLLVIEW_ROOT even if there is no relocation info to record,
-	 just to try to put both symbols in the same symbol table and
-	 module.*/
-	debug_mirror_sym = dlthis->mysym->Find_Matching_Symbol(dlthis->mysym,
-						LOADER_DLLVIEW_ROOT);
+	/* Locate the symbol that names the header for the CCS debug list
+	   of modules. If not found, we just don't generate the debug record.
+	   If found, we create our modules list.  We make sure to create the
+	   loader_dllview_root even if there is no relocation info to record,
+	   just to try to put both symbols in the same symbol table and
+	   module. */
+	debug_mirror_sym = dlthis->mysym->find_matching_symbol(dlthis->mysym,
+							loader_dllview_root);
 	if (!debug_mirror_sym) {
 		struct dynload_symbol *dlmodsym;
 		struct dbg_mirror_root *mlst;
 
 		/* our root symbol is not yet present;
 		   check if we have DLModules defined */
-		dlmodsym = dlthis->mysym->Find_Matching_Symbol(dlthis->mysym,
+		dlmodsym = dlthis->mysym->find_matching_symbol(dlthis->mysym,
 							LINKER_MODULES_HEADER);
 		if (!dlmodsym)
 			return;	/* no DLModules list so no debug info */
 		/* if we have DLModules defined, construct our header */
 		mlst = (struct dbg_mirror_root *)
-			dlthis->mysym->Allocate(dlthis->mysym,
-			sizeof(struct dbg_mirror_root));
+		    dlthis->mysym->dload_allocate(dlthis->mysym,
+						  sizeof(struct
+							 dbg_mirror_root));
 		if (!mlst) {
-			DL_ERROR(E_ALLOC, sizeof(struct dbg_mirror_root));
+			DL_ERROR(err_alloc, sizeof(struct dbg_mirror_root));
 			return;
 		}
 		mlst->hnext = NULL;
@@ -1570,19 +1658,19 @@
 		mlst->refcount = 0;
 		mlst->dbthis = TDATA_TO_TADDR(dlmodsym->value);
 		/* add our root symbol */
-		debug_mirror_sym = dlthis->mysym->Add_To_Symbol_Table
-			(dlthis->mysym, LOADER_DLLVIEW_ROOT,
-			(unsigned)dlthis->myhandle);
+		debug_mirror_sym = dlthis->mysym->add_to_symbol_table
+		    (dlthis->mysym, loader_dllview_root,
+		     (unsigned)dlthis->myhandle);
 		if (!debug_mirror_sym) {
 			/* failed, recover memory */
-			dlthis->mysym->Deallocate(dlthis->mysym, mlst);
+			dlthis->mysym->dload_deallocate(dlthis->mysym, mlst);
 			return;
 		}
-		debug_mirror_sym->value = (u32)mlst;
+		debug_mirror_sym->value = (u32) mlst;
 	}
-	 /* First create the DLLview record and stuff it into the buffer.
-	 Then write it to the DSP.  Record pertinent locations in our hndl,
-	  and add it to the per-processor list of handles with debug info.*/
+	/* First create the DLLview record and stuff it into the buffer.
+	   Then write it to the DSP.  Record pertinent locations in our hndl,
+	   and add it to the per-processor list of handles with debug info. */
 #ifndef DEBUG_HEADER_IN_LOADER
 	mlist = (struct dbg_mirror_root *)debug_mirror_sym->value;
 	if (!mlist)
@@ -1594,8 +1682,8 @@
 	if (!dlthis->allocated_secn_count)
 		return;		/* no load addresses to be recorded */
 	/* reuse temporary symbol storage */
-	dbmod = (struct dll_module *) dlthis->local_symtab;
-	 /* Create the DLLview record in the memory we retain for our handle*/
+	dbmod = (struct dll_module *)dlthis->local_symtab;
+	/* Create the DLLview record in the memory we retain for our handle */
 	dbmod->num_sects = dlthis->allocated_secn_count;
 	dbmod->timestamp = dlthis->verify.dv_timdat;
 	dbmod->version = INIT_VERSION;
@@ -1609,14 +1697,33 @@
 		dbsec += 1;
 		asecs += 1;
 	}
+
+	/*  If a trampoline section was created go ahead and add its info */
+	if (dlthis->tramp.tramp_sect_next_addr != 0) {
+		dbmod->num_sects++;
+		dbsec->sect_load_adr = asecs->load_addr;
+		dbsec->sect_run_adr = asecs->run_addr;
+		dbsec++;
+		asecs++;
+	}
+
 	/* now cram in the names */
 	cp = copy_tgt_strings(dbsec, dlthis->str_head,
 			      dlthis->debug_string_size);
 
+	/* If a trampoline section was created, add its name so DLLView
+	 * can show the user the section info. */
+	if (dlthis->tramp.tramp_sect_next_addr != 0) {
+		cp = copy_tgt_strings(cp,
+				      dlthis->tramp.final_string_table,
+				      strlen(dlthis->tramp.final_string_table) +
+				      1);
+	}
+
 	/* round off the size of the debug record, and remember same */
 	hndl->dm.dbsiz = HOST_TO_TDATA_ROUND(cp - (char *)dbmod);
 	*cp = 0;		/* strictly to make our test harness happy */
-	dllview_info = DLLVIEW_INFO_INIT;
+	dllview_info = dllview_info_init;
 	dllview_info.size = TDATA_TO_TADDR(hndl->dm.dbsiz);
 	/* Initialize memory context to default heap */
 	dllview_info.context = 0;
@@ -1632,8 +1739,8 @@
 	/* allocate memory for on-DSP DLLview debug record */
 	if (!dlthis->myalloc)
 		return;
-	if (!dlthis->myalloc->Allocate(dlthis->myalloc, &dllview_info,
-		     HOST_TO_TADDR(sizeof(u32)))) {
+	if (!dlthis->myalloc->dload_allocate(dlthis->myalloc, &dllview_info,
+					     HOST_TO_TADDR(sizeof(u32)))) {
 		return;
 	}
 	/* Store load address of .dllview section */
@@ -1647,10 +1754,10 @@
 		swap_words(dbmod, (char *)dbsec - (char *)dbmod,
 			   DLL_MODULE_BITMAP);
 	}
-	 /* Update the DLLview list on the DSP write new record */
+	/* Update the DLLview list on the DSP write new record */
 	if (!dlthis->myio->writemem(dlthis->myio, dbmod,
-		dllview_info.load_addr, &dllview_info,
-		TADDR_TO_HOST(dllview_info.size))) {
+				    dllview_info.load_addr, &dllview_info,
+				    TADDR_TO_HOST(dllview_info.size))) {
 		return;
 	}
 	/* write new header */
@@ -1661,26 +1768,27 @@
 		swap_words(&mhdr, sizeof(struct modules_header) - sizeof(u16),
 			   MODULES_HEADER_BITMAP);
 	}
-	dllview_info = DLLVIEW_INFO_INIT;
+	dllview_info = dllview_info_init;
 	if (!dlthis->myio->writemem(dlthis->myio, &mhdr, mlist->dbthis,
-			&dllview_info, sizeof(struct modules_header) -
-				       sizeof(u16))) {
+				    &dllview_info,
+				    sizeof(struct modules_header) -
+				    sizeof(u16))) {
 		return;
 	}
-	 /* Add the module handle to this processor's list
-		of handles with debug info */
+	/* Add the module handle to this processor's list
+	   of handles with debug info */
 	hndl->dm.hnext = mlist->hnext;
 	if (hndl->dm.hnext)
 		hndl->dm.hnext->dm.hprev = hndl;
-	hndl->dm.hprev = (struct my_handle *) mlist;
-	mlist->hnext = hndl;	/* insert after root*/
+	hndl->dm.hprev = (struct my_handle *)mlist;
+	mlist->hnext = hndl;	/* insert after root */
 }				/* init_module_handle */
 
 /*************************************************************************
- * Procedure Dynamic_Unload_Module
+ * Procedure dynamic_unload_module
  *
  * Parameters:
- *	mhandle	A module handle from Dynamic_Load_Module
+ *	mhandle	A module handle from dynamic_load_module
  *	syms	Host-side symbol table and malloc/free functions
  *	alloc	Target-side memory allocation
  *
@@ -1692,40 +1800,42 @@
  *
  * Returns:
  *	Zero for success. On error, the number of errors detected is returned.
- * Individual errors are reported using syms->Error_Report().
- ************************************************************************/
-int Dynamic_Unload_Module(DLOAD_mhandle mhandle,
-		struct Dynamic_Loader_Sym *syms,
-		struct Dynamic_Loader_Allocate *alloc,
-		struct Dynamic_Loader_Initialize *init)
+ * Individual errors are reported using syms->error_report().
+ *********************************************************************** */
+int dynamic_unload_module(dload_mhandle mhandle,
+			  struct dynamic_loader_sym *syms,
+			  struct dynamic_loader_allocate *alloc,
+			  struct dynamic_loader_initialize *init)
 {
 	s16 curr_sect;
-	struct LDR_SECTION_INFO *asecs;
+	struct ldr_section_info *asecs;
 	struct my_handle *hndl;
 	struct dbg_mirror_root *root;
 	unsigned errcount = 0;
-	struct LDR_SECTION_INFO dllview_info = DLLVIEW_INFO_INIT;
+	struct ldr_section_info dllview_info = dllview_info_init;
 	struct modules_header mhdr;
 
 	hndl = (struct my_handle *)mhandle;
 	if (!hndl)
 		return 0;	/* if handle is null, nothing to do */
-	 /* Clear out the module symbols
+	/* Clear out the module symbols
 	 * Note that if this is the module that defined MODULES_HEADER
-	  (the head of the target debug list)
+	 (the head of the target debug list)
 	 * then this operation will blow away that symbol.
 	 It will therefore be impossible for subsequent
-	 * operations to add entries to this un-referenceable list.*/
+	 * operations to add entries to this un-referenceable list. */
 	if (!syms)
 		return 1;
-	syms->Purge_Symbol_Table(syms, (unsigned) hndl);
-	 /* Deallocate target memory for sections */
+	syms->purge_symbol_table(syms, (unsigned)hndl);
+	/* Deallocate target memory for sections
+	 * NOTE: The trampoline section, if created, gets deleted here, too */
+
 	asecs = hndl->secns;
 	if (alloc)
 		for (curr_sect = (hndl->secn_count >> 1); curr_sect > 0;
 		     curr_sect -= 1) {
 			asecs->name = NULL;
-			alloc->Deallocate(alloc, asecs++);
+			alloc->dload_deallocate(alloc, asecs++);
 		}
 	root = hndl->dm.hroot;
 	if (!root) {
@@ -1745,9 +1855,9 @@
 	hndl->dm.hprev->dm.hnext = hndl->dm.hnext;
 	if (hndl->dm.hnext)
 		hndl->dm.hnext->dm.hprev = hndl->dm.hprev;
-	 /* Update next_module of previous entry in target list
+	/* Update next_module of previous entry in target list
 	 * We are using mhdr here as a surrogate for either a
-	 struct modules_header or a dll_module	 */
+	 struct modules_header or a dll_module */
 	if (hndl->dm.hnext) {
 		mhdr.first_module = TADDR_TO_TDATA(hndl->dm.hnext->dm.dbthis);
 		mhdr.first_module_size = hndl->dm.hnext->dm.dbsiz;
@@ -1759,7 +1869,7 @@
 		goto exitunltgt;
 
 	if (!init->connect(init)) {
-		dload_syms_error(syms, E_ICONNECT);
+		dload_syms_error(syms, iconnect);
 		errcount += 1;
 		goto exitunltgt;
 	}
@@ -1771,18 +1881,17 @@
 	if (!init->writemem(init, &mhdr, hndl->dm.hprev->dm.dbthis,
 			    &dllview_info, sizeof(struct modules_header) -
 			    sizeof(mhdr.update_flag))) {
-		dload_syms_error(syms, E_DLVWRITE);
+		dload_syms_error(syms, dlvwrite);
 		errcount += 1;
 	}
 	/* update change counter */
 	root->changes += 1;
 	if (!init->writemem(init, &(root->changes),
-				root->dbthis + HOST_TO_TADDR
-				      (sizeof(mhdr.first_module) +
-				      sizeof(mhdr.first_module_size)),
-				      &dllview_info,
-				      sizeof(mhdr.update_flag))) {
-		dload_syms_error(syms, E_DLVWRITE);
+			    root->dbthis + HOST_TO_TADDR
+			    (sizeof(mhdr.first_module) +
+			     sizeof(mhdr.first_module_size)),
+			    &dllview_info, sizeof(mhdr.update_flag))) {
+		dload_syms_error(syms, dlvwrite);
 		errcount += 1;
 	}
 	init->release(init);
@@ -1791,7 +1900,7 @@
 	dllview_info.size = TDATA_TO_TADDR(hndl->dm.dbsiz);
 	dllview_info.load_addr = hndl->dm.dbthis;
 	if (alloc)
-		alloc->Deallocate(alloc, &dllview_info);
+		alloc->dload_deallocate(alloc, &dllview_info);
 	root->refcount -= 1;
 	/* target-side dllview record exists */
 loop_end:
@@ -1800,16 +1909,16 @@
 		/* if all references gone, blow off the header */
 		/* our root symbol may be gone due to the Purge above,
 		   but if not, do not destroy the root */
-		if (syms->Find_Matching_Symbol
-			(syms, LOADER_DLLVIEW_ROOT) == NULL)
-			syms->Deallocate(syms, root);
+		if (syms->find_matching_symbol
+		    (syms, loader_dllview_root) == NULL)
+			syms->dload_deallocate(syms, root);
 	}
 #endif
 func_end:
 	/* there is a debug list containing this module */
-	syms->Deallocate(syms, mhandle);	/* release our storage */
+	syms->dload_deallocate(syms, mhandle);	/* release our storage */
 	return errcount;
-}				/* Dynamic_Unload_Module */
+}				/* dynamic_unload_module */
 
 #if BITS_PER_AU > BITS_PER_BYTE
 /*************************************************************************
@@ -1822,7 +1931,7 @@
  *	Returns a pointer to the string specified by the offset supplied, or
  * NULL for error.
  *
- ************************************************************************/
+ *********************************************************************** */
 static char *unpack_name(struct dload_state *dlthis, u32 soffset)
 {
 	u8 tmp, *src;
@@ -1833,7 +1942,7 @@
 			    soffset);
 		return NULL;
 	}
-	src = (uint_least8_t *)dlthis->str_head +
+	src = (uint_least8_t *) dlthis->str_head +
 	    (soffset >> (LOG_BITS_PER_AU - LOG_BITS_PER_BYTE));
 	dst = dlthis->str_temp;
 	if (soffset & 1)
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/dlclasses_hdr.h kernel-power-2.6.28.new/drivers/dsp/bridge/dynload/dlclasses_hdr.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/dlclasses_hdr.h	2011-10-11 13:51:00.030317934 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/dynload/dlclasses_hdr.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-/*
- * dlclasses_hdr.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-
-#ifndef _DLCLASSES_HDR_H
-#define _DLCLASSES_HDR_H
-
-/*****************************************************************************
- *****************************************************************************
- *
- *                          DLCLASSES_HDR.H
- *
- * Sample classes in support of the dynamic loader
- *
- * These are just concrete derivations of the virtual ones in dynamic_loader.h
- * with a few additional interfaces for init, etc.
- *****************************************************************************
- *****************************************************************************/
-
-#include <dspbridge/dynamic_loader.h>
-
-#include "DLstream.h"
-#include "DLsymtab.h"
-#include "DLalloc.h"
-#include "DLinit.h"
-
-#endif				/* _DLCLASSES_HDR_H */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/dload_internal.h kernel-power-2.6.28.new/drivers/dsp/bridge/dynload/dload_internal.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/dload_internal.h	2011-10-11 13:51:00.043007752 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/dynload/dload_internal.h	2011-10-23 08:22:37.609703000 +0100
@@ -14,10 +14,8 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-
-#ifndef __DLOAD_INTERNAL__
-#define __DLOAD_INTERNAL__
+#ifndef _DLOAD_INTERNAL_
+#define _DLOAD_INTERNAL_
 
 #include <linux/types.h>
 
@@ -29,12 +27,11 @@
 #define FALSE 0
 typedef int boolean;
 
-
 /* type used for relocation intermediate results */
-typedef s32 RVALUE;
+typedef s32 rvalue;
 
 /* unsigned version of same; must have at least as many bits */
-typedef u32 URVALUE;
+typedef u32 urvalue;
 
 /*
  * Dynamic loader configuration constants
@@ -43,7 +40,7 @@
 #define REASONABLE_SECTION_LIMIT 100
 
 /* (Addressable unit) value used to clear BSS section */
-#define dload_fill_bss 0
+#define DLOAD_FILL_BSS 0
 
 /*
  * Reorder maps explained (?)
@@ -86,9 +83,9 @@
 	/* must be same as dbg_mirror_list; __DLModules address on target */
 	u32 dbthis;
 	struct my_handle *hnext;	/* must be same as dbg_mirror_list */
-	u16 changes;	/* change counter */
-	u16 refcount;	/* number of modules referencing this root */
-} ;
+	u16 changes;		/* change counter */
+	u16 refcount;		/* number of modules referencing this root */
+};
 
 struct dbg_mirror_list {
 	u32 dbthis;
@@ -96,7 +93,7 @@
 	struct dbg_mirror_root *hroot;
 	u16 dbsiz;
 	u32 context;	/* Save context for .dllview memory allocation */
-} ;
+};
 
 #define VARIABLE_SIZE 1
 /*
@@ -106,33 +103,129 @@
 	struct dbg_mirror_list dm;	/* !!! must be first !!! */
 	/* sections following << 1, LSB is set for big-endian target */
 	u16 secn_count;
-	struct LDR_SECTION_INFO secns[VARIABLE_SIZE];
-} ;
+	struct ldr_section_info secns[VARIABLE_SIZE];
+};
 #define MY_HANDLE_SIZE (sizeof(struct my_handle) -\
-			sizeof(struct LDR_SECTION_INFO))
+			sizeof(struct ldr_section_info))
 /* real size of my_handle */
 
 /*
  * reduced symbol structure used for symbols during relocation
  */
-struct Local_Symbol {
-	s32 value;	/* Relocated symbol value */
-	s32 delta;	/* Original value in input file */
+struct local_symbol {
+	s32 value;		/* Relocated symbol value */
+	s32 delta;		/* Original value in input file */
 	s16 secnn;		/* section number */
 	s16 sclass;		/* symbol class */
-} ;
+};
+
+/*
+ * Trampoline data structures
+ */
+#define TRAMP_NO_GEN_AVAIL              65535
+#define TRAMP_SYM_PREFIX                "__$dbTR__"
+#define TRAMP_SECT_NAME                 ".dbTR"
+/* MUST MATCH THE LENGTH ABOVE!! */
+#define TRAMP_SYM_PREFIX_LEN            9
+/* Includes NULL termination */
+#define TRAMP_SYM_HEX_ASCII_LEN         9
+
+#define GET_CONTAINER(ptr, type, field) ((type *)((unsigned long)ptr -\
+				(unsigned long)(&((type *)0)->field)))
+#ifndef FIELD_OFFSET
+#define FIELD_OFFSET(type, field)       ((unsigned long)(&((type *)0)->field))
+#endif
+
+/*
+    The trampoline code for the target is located in a table called
+    "tramp_gen_info" with is indexed by looking up the index in the table
+    "tramp_map".  The tramp_map index is acquired using the target
+    HASH_FUNC on the relocation type that caused the trampoline.  Each
+    trampoline code table entry MUST follow this format:
+
+    |----------------------------------------------|
+    |  tramp_gen_code_hdr                          |
+    |----------------------------------------------|
+    |  Trampoline image code                       |
+    |  (the raw instruction code for the target)   |
+    |----------------------------------------------|
+    |  Relocation entries for the image code       |
+    |----------------------------------------------|
+
+    This is very similar to how image data is laid out in the DOFF file
+    itself.
+ */
+struct tramp_gen_code_hdr {
+	u32 tramp_code_size;	/*  in BYTES */
+	u32 num_relos;
+	u32 relo_offset;	/*  in BYTES */
+};
+
+struct tramp_img_pkt {
+	struct tramp_img_pkt *next;	/*  MUST BE FIRST */
+	u32 base;
+	struct tramp_gen_code_hdr hdr;
+	u8 payload[VARIABLE_SIZE];
+};
+
+struct tramp_img_dup_relo {
+	struct tramp_img_dup_relo *next;
+	struct reloc_record_t relo;
+};
+
+struct tramp_img_dup_pkt {
+	struct tramp_img_dup_pkt *next;	/*  MUST BE FIRST */
+	s16 secnn;
+	u32 offset;
+	struct image_packet_t img_pkt;
+	struct tramp_img_dup_relo *relo_chain;
+
+	/*  PAYLOAD OF IMG PKT FOLLOWS */
+};
+
+struct tramp_sym {
+	struct tramp_sym *next;	/*  MUST BE FIRST */
+	u32 index;
+	u32 str_index;
+	struct local_symbol sym_info;
+};
+
+struct tramp_string {
+	struct tramp_string *next;	/*  MUST BE FIRST */
+	u32 index;
+	char str[VARIABLE_SIZE];	/*  NULL terminated */
+};
+
+struct tramp_info {
+	u32 tramp_sect_next_addr;
+	struct ldr_section_info sect_info;
+
+	struct tramp_sym *symbol_head;
+	struct tramp_sym *symbol_tail;
+	u32 tramp_sym_next_index;
+	struct local_symbol *final_sym_table;
+
+	struct tramp_string *string_head;
+	struct tramp_string *string_tail;
+	u32 tramp_string_next_index;
+	u32 tramp_string_size;
+	char *final_string_table;
+
+	struct tramp_img_pkt *tramp_pkts;
+	struct tramp_img_dup_pkt *dup_pkts;
+};
 
 /*
  * States of the .cinit state machine
  */
 enum cinit_mode {
-	CI_count = 0,		/* expecting a count */
-	CI_address,		/* expecting an address */
+	CI_COUNT = 0,		/* expecting a count */
+	CI_ADDRESS,		/* expecting an address */
 #if CINIT_ALIGN < CINIT_ADDRESS	/* handle case of partial address field */
-	CI_partaddress,		/* have only part of the address */
+	CI_PARTADDRESS,		/* have only part of the address */
 #endif
-	CI_copy,		/* in the middle of copying data */
-	CI_done			/* end of .cinit table */
+	CI_COPY,		/* in the middle of copying data */
+	CI_DONE			/* end of .cinit table */
 };
 
 /*
@@ -140,11 +233,12 @@
  * an object
  */
 struct dload_state {
-	struct Dynamic_Loader_Stream *strm;	/* The module input stream */
-	struct Dynamic_Loader_Sym *mysym;	/* Symbols for this session */
-	struct Dynamic_Loader_Allocate *myalloc; /* target memory allocator */
-	struct Dynamic_Loader_Initialize *myio;	/* target memory initializer */
-	unsigned myoptions;	/* Options parameter Dynamic_Load_Module */
+	struct dynamic_loader_stream *strm;	/* The module input stream */
+	struct dynamic_loader_sym *mysym;	/* Symbols for this session */
+	/* target memory allocator */
+	struct dynamic_loader_allocate *myalloc;
+	struct dynamic_loader_initialize *myio;	/* target memory initializer */
+	unsigned myoptions;	/* Options parameter dynamic_load_module */
 
 	char *str_head;		/* Pointer to string table */
 #if BITS_PER_AU > BITS_PER_BYTE
@@ -158,23 +252,23 @@
 	unsigned debug_string_size;
 	/* Pointer to parallel section info for allocated sections only */
 	struct doff_scnhdr_t *sect_hdrs;	/* Pointer to section table */
-	struct LDR_SECTION_INFO *ldr_sections;
+	struct ldr_section_info *ldr_sections;
 #if TMS32060
 	/* The address of the start of the .bss section */
-	LDR_ADDR bss_run_base;
+	ldr_addr bss_run_base;
 #endif
-	struct Local_Symbol *local_symtab;	/* Relocation symbol table */
+	struct local_symbol *local_symtab;	/* Relocation symbol table */
 
 	/* pointer to DL section info for the section being relocated */
-	struct LDR_SECTION_INFO *image_secn;
+	struct ldr_section_info *image_secn;
 	/* change in run address for current section during relocation */
-	LDR_ADDR delta_runaddr;
-	LDR_ADDR image_offset;	/* offset of current packet in section */
+	ldr_addr delta_runaddr;
+	ldr_addr image_offset;	/* offset of current packet in section */
 	enum cinit_mode cinit_state;	/* current state of cload_cinit() */
 	int cinit_count;	/* the current count */
-	LDR_ADDR cinit_addr;	/* the current address */
-	s16 cinit_page;	/* the current page */
-	/* Handle to be returned by Dynamic_Load_Module */
+	ldr_addr cinit_addr;	/* the current address */
+	s16 cinit_page;		/* the current page */
+	/* Handle to be returned by dynamic_load_module */
 	struct my_handle *myhandle;
 	unsigned dload_errcount;	/* Total # of errors reported so far */
 	/* Number of target sections that require allocation and relocation */
@@ -187,11 +281,13 @@
 	struct doff_filehdr_t dfile_hdr;	/* DOFF file header structure */
 	struct doff_verify_rec_t verify;	/* Verify record */
 
+	struct tramp_info tramp;	/* Trampoline data, if needed */
+
 	int relstkidx;		/* index into relocation value stack */
 	/* relocation value stack used in relexp.c */
-	RVALUE relstk[STATIC_EXPR_STK_SIZE];
+	rvalue relstk[STATIC_EXPR_STK_SIZE];
 
-} ;
+};
 
 #ifdef TARGET_ENDIANNESS
 #define TARGET_BIG_ENDIAN TARGET_ENDIANNESS
@@ -203,10 +299,10 @@
  * Exports from cload.c to rest of the world
  */
 extern void dload_error(struct dload_state *dlthis, const char *errtxt, ...);
-extern void dload_syms_error(struct Dynamic_Loader_Sym *syms,
+extern void dload_syms_error(struct dynamic_loader_sym *syms,
 			     const char *errtxt, ...);
 extern void dload_headers(struct dload_state *dlthis);
-extern void dload_strings(struct dload_state *dlthis, boolean sec_names_only);
+extern void dload_strings(struct dload_state *dlthis, bool sec_names_only);
 extern void dload_sections(struct dload_state *dlthis);
 extern void dload_reorder(void *data, int dsiz, u32 map);
 extern u32 dload_checksum(void *data, unsigned siz);
@@ -214,24 +310,43 @@
 #if HOST_ENDIANNESS
 extern uint32_t dload_reverse_checksum(void *data, unsigned siz);
 #if (TARGET_AU_BITS > 8) && (TARGET_AU_BITS < 32)
-extern uint32_t dload_reverse_checksum_16(void *data, unsigned siz);
+extern uint32_t dload_reverse_checksum16(void *data, unsigned siz);
 #endif
 #endif
 
-#define is_data_scn(zzz) (DLOAD_SECTION_TYPE((zzz)->type) != DLOAD_TEXT)
-#define is_data_scn_num(zzz) \
+#define IS_DATA_SCN(zzz) (DLOAD_SECTION_TYPE((zzz)->type) != DLOAD_TEXT)
+#define IS_DATA_SCN_NUM(zzz) \
 		(DLOAD_SECT_TYPE(&dlthis->sect_hdrs[(zzz)-1]) != DLOAD_TEXT)
 
 /*
  * exported by reloc.c
  */
-extern void dload_relocate(struct dload_state *dlthis, TgtAU_t *data,
-			   struct reloc_record_t *rp);
+extern void dload_relocate(struct dload_state *dlthis, tgt_au_t * data,
+			   struct reloc_record_t *rp, bool * tramps_generated,
+			   bool second_pass);
 
-extern RVALUE dload_unpack(struct dload_state *dlthis, TgtAU_t *data,
+extern rvalue dload_unpack(struct dload_state *dlthis, tgt_au_t * data,
 			   int fieldsz, int offset, unsigned sgn);
 
-extern int dload_repack(struct dload_state *dlthis, RVALUE val, TgtAU_t *data,
+extern int dload_repack(struct dload_state *dlthis, rvalue val, tgt_au_t * data,
 			int fieldsz, int offset, unsigned sgn);
 
-#endif				/* __DLOAD_INTERNAL__ */
+/*
+ * exported by tramp.c
+ */
+extern bool dload_tramp_avail(struct dload_state *dlthis,
+			      struct reloc_record_t *rp);
+
+int dload_tramp_generate(struct dload_state *dlthis, s16 secnn,
+			 u32 image_offset, struct image_packet_t *ipacket,
+			 struct reloc_record_t *rp);
+
+extern int dload_tramp_pkt_udpate(struct dload_state *dlthis,
+				  s16 secnn, u32 image_offset,
+				  struct image_packet_t *ipacket);
+
+extern int dload_tramp_finalize(struct dload_state *dlthis);
+
+extern void dload_tramp_cleanup(struct dload_state *dlthis);
+
+#endif /* _DLOAD_INTERNAL_ */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/doff.h kernel-power-2.6.28.new/drivers/dsp/bridge/dynload/doff.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/doff.h	2011-10-11 13:51:00.054731309 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/dynload/doff.h	2011-10-23 08:22:37.609703000 +0100
@@ -3,6 +3,13 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Structures & definitions used for dynamically loaded modules file format.
+ * This format is a reformatted version of COFF. It optimizes the layout for
+ * the dynamic loader.
+ *
+ * .dof files, when viewed as a sequence of 32-bit integers, look the same
+ * on big-endian and little-endian machines.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,16 +21,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*****************************************************************************/
-/*  DOFF.H - Structures & definitions used for dynamically                   */
-/*           loaded modules file format.  This format is a reformatted       */
-/*           version of COFF.(see coff.h for details)  It optimizes the      */
-/*           layout for the dynamic loader.                                  */
-/*                                                                           */
-/*  .dof files, when viewed as a sequence of 32-bit integers, look the same  */
-/*  on big-endian and little-endian machines.                                */
-/*****************************************************************************/
 #ifndef _DOFF_H
 #define _DOFF_H
 
@@ -36,18 +33,18 @@
 /* DOFF file header containing fields categorizing the remainder of the file */
 struct doff_filehdr_t {
 
-	/* string table size, including filename, in bytes   */
+	/* string table size, including filename, in bytes */
 	u32 df_strtab_size;
 
 	/* entry point if one exists */
 	u32 df_entrypt;
 
 	/* identifies byte ordering of file;
-	 * always set to BYTE_RESHUFFLE_VALUE  */
+	 * always set to BYTE_RESHUFFLE_VALUE */
 	u32 df_byte_reshuffle;
 
 	/* Size of the string table up to and including the last section name */
-	/* Size includes the name of the COFF file also     */
+	/* Size includes the name of the COFF file also */
 	u32 df_scn_name_size;
 
 #ifndef _BIG_ENDIAN
@@ -55,16 +52,16 @@
 	u16 df_no_syms;
 
 	/* length in bytes of the longest string, including terminating NULL */
-	/* excludes the name of the file     */
+	/* excludes the name of the file */
 	u16 df_max_str_len;
 
-	/* total number of sections including no-load ones   */
+	/* total number of sections including no-load ones */
 	u16 df_no_scns;
 
 	/* number of sections containing target code allocated or downloaded */
 	u16 df_target_scns;
 
-	/* unique id for dll file format & version   */
+	/* unique id for dll file format & version */
 	u16 df_doff_version;
 
 	/* identifies ISA */
@@ -73,11 +70,11 @@
 	/* useful file flags */
 	u16 df_flags;
 
-	/* section reference for entry point, N_UNDEF for none,   */
+	/* section reference for entry point, N_UNDEF for none, */
 	/* N_ABS for absolute address */
 	s16 df_entry_secn;
 #else
-	/* length of the longest string, including terminating NULL  */
+	/* length of the longest string, including terminating NULL */
 	u16 df_max_str_len;
 
 	/* number of symbols */
@@ -95,7 +92,7 @@
 	/* unique id for dll file format & version */
 	u16 df_doff_version;
 
-	/* section reference for entry point, N_UNDEF for none,  */
+	/* section reference for entry point, N_UNDEF for none, */
 	/* N_ABS for absolute address */
 	s16 df_entry_secn;
 
@@ -105,7 +102,7 @@
 	/* checksum for file header record */
 	u32 df_checksum;
 
-} ;
+};
 
 /* flags in the df_flags field */
 #define  DF_LITTLE   0x100
@@ -141,7 +138,7 @@
 	/* checksum for verification record */
 	u32 dv_verify_rec_checksum;
 
-} ;
+};
 
 /* String table is an array of null-terminated strings.  The first entry is
  * the filename, which is added by DLLcreate.  No new structure definitions
@@ -152,49 +149,49 @@
 /*
  *      !!WARNING!!
  *
- * This structure is expected to match in form LDR_SECTION_INFO in
+ * This structure is expected to match in form ldr_section_info in
  * dynamic_loader.h
  */
 
 struct doff_scnhdr_t {
 
-	s32 ds_offset;	/* offset into string table of name    */
-	s32 ds_paddr;	/* RUN address, in target AU           */
-	s32 ds_vaddr;	/* LOAD address, in target AU          */
-	s32 ds_size;	/* section size, in target AU          */
+	s32 ds_offset;		/* offset into string table of name */
+	s32 ds_paddr;		/* RUN address, in target AU */
+	s32 ds_vaddr;		/* LOAD address, in target AU */
+	s32 ds_size;		/* section size, in target AU */
 #ifndef _BIG_ENDIAN
-	u16 ds_page;	/* memory page id                      */
-	u16 ds_flags;	/* section flags                       */
+	u16 ds_page;		/* memory page id */
+	u16 ds_flags;		/* section flags */
 #else
-	u16 ds_flags;	/* section flags                       */
-	u16 ds_page;	/* memory page id                      */
+	u16 ds_flags;		/* section flags */
+	u16 ds_page;		/* memory page id */
 #endif
 	u32 ds_first_pkt_offset;
-	/* Absolute byte offset into the file  */
+	/* Absolute byte offset into the file */
 	/* where the first image record resides */
 
-	s32 ds_nipacks;	/* number of image packets             */
+	s32 ds_nipacks;		/* number of image packets */
 
 };
 
 /* Symbol table entry */
 struct doff_syment_t {
 
-	s32 dn_offset;	/* offset into string table of name    */
-	s32 dn_value;	/* value of symbol                     */
+	s32 dn_offset;		/* offset into string table of name */
+	s32 dn_value;		/* value of symbol */
 #ifndef _BIG_ENDIAN
-	s16 dn_scnum;	/* section number                      */
-	s16 dn_sclass;	/* storage class                       */
+	s16 dn_scnum;		/* section number */
+	s16 dn_sclass;		/* storage class */
 #else
-	s16 dn_sclass;	/* storage class                       */
-	s16 dn_scnum;	/* section number, 1-based             */
+	s16 dn_sclass;		/* storage class */
+	s16 dn_scnum;		/* section number, 1-based */
 #endif
 
-} ;
+};
 
 /* special values for dn_scnum */
-#define  DN_UNDEF  0		/* undefined symbol               */
-#define  DN_ABS    (-1)		/* value of symbol is absolute    */
+#define  DN_UNDEF  0		/* undefined symbol */
+#define  DN_ABS    (-1)		/* value of symbol is absolute */
 /* special values for dn_sclass */
 #define DN_EXT     2
 #define DN_STATLAB 20
@@ -205,44 +202,44 @@
 #define IMAGE_PACKET_SIZE 1024
 
 /* An image packet contains a chunk of data from a section along with */
-/* information necessary for its processing.                          */
+/* information necessary for its processing. */
 struct image_packet_t {
 
-	s32 i_num_relocs;	/* number of relocations for   */
-	/* this packet                 */
+	s32 num_relocs;		/* number of relocations for */
+	/* this packet */
 
-	s32 i_packet_size;	/* number of bytes in array    */
-	/* "bits" occupied  by         */
-	/* valid data.  Could be       */
-	/* < IMAGE_PACKET_SIZE to      */
-	/* prevent splitting a         */
-	/* relocation across packets.  */
-	/* Last packet of a section    */
-	/* will most likely contain    */
-	/* < IMAGE_PACKET_SIZE bytes   */
-	/* of valid data               */
-
-	s32 i_checksum;	/* Checksum for image packet   */
-	/* and the corresponding       */
-	/* relocation records          */
+	s32 packet_size;	/* number of bytes in array */
+	/* "bits" occupied  by */
+	/* valid data.  Could be */
+	/* < IMAGE_PACKET_SIZE to */
+	/* prevent splitting a */
+	/* relocation across packets. */
+	/* Last packet of a section */
+	/* will most likely contain */
+	/* < IMAGE_PACKET_SIZE bytes */
+	/* of valid data */
+
+	s32 img_chksum;		/* Checksum for image packet */
+	/* and the corresponding */
+	/* relocation records */
 
-	u8 *i_bits;	/* Actual data in section      */
+	u8 *img_data;		/* Actual data in section */
 
 };
 
-/* The relocation structure definition matches the COFF version.  Offsets  */
-/* however are relative to the image packet base not the section base.     */
+/* The relocation structure definition matches the COFF version.  Offsets */
+/* however are relative to the image packet base not the section base. */
 struct reloc_record_t {
 
-	s32 r_vaddr;
+	s32 vaddr;
 
-	/* expressed in target AUs          */
+	/* expressed in target AUs */
 
 	union {
 		struct {
 #ifndef _BIG_ENDIAN
-			u8 _offset;	/* bit offset of rel fld      */
-			u8 _fieldsz;	/* size of rel fld            */
+			u8 _offset;	/* bit offset of rel fld */
+			u8 _fieldsz;	/* size of rel fld */
 			u8 _wordsz;	/* # bytes containing rel fld */
 			u8 _dum1;
 			u16 _dum2;
@@ -250,98 +247,98 @@
 #else
 			unsigned _dum1:8;
 			unsigned _wordsz:8;	/* # bytes containing rel fld */
-			unsigned _fieldsz:8;	/* size of rel fld            */
-			unsigned _offset:8;	/* bit offset of rel fld      */
+			unsigned _fieldsz:8;	/* size of rel fld */
+			unsigned _offset:8;	/* bit offset of rel fld */
 			u16 _type;
 			u16 _dum2;
 #endif
 		} _r_field;
 
 		struct {
-			u32 _spc;	/* image packet relative PC   */
+			u32 _spc;	/* image packet relative PC */
 #ifndef _BIG_ENDIAN
 			u16 _dum;
-			u16 _type;	/* relocation type            */
+			u16 _type;	/* relocation type */
 #else
-			u16 _type;	/* relocation type            */
+			u16 _type;	/* relocation type */
 			u16 _dum;
 #endif
 		} _r_spc;
 
 		struct {
-			u32 _uval;	/* constant value             */
+			u32 _uval;	/* constant value */
 #ifndef _BIG_ENDIAN
 			u16 _dum;
-			u16 _type;	/* relocation type            */
+			u16 _type;	/* relocation type */
 #else
-			u16 _type;	/* relocation type            */
+			u16 _type;	/* relocation type */
 			u16 _dum;
 #endif
 		} _r_uval;
 
 		struct {
-			s32 _symndx;	/* 32-bit sym tbl index       */
+			s32 _symndx;	/* 32-bit sym tbl index */
 #ifndef _BIG_ENDIAN
-			u16 _disp;	/* extra addr encode data     */
-			u16 _type;	/* relocation type            */
+			u16 _disp;	/* extra addr encode data */
+			u16 _type;	/* relocation type */
 #else
-			u16 _type;	/* relocation type            */
-			u16 _disp;	/* extra addr encode data     */
+			u16 _type;	/* relocation type */
+			u16 _disp;	/* extra addr encode data */
 #endif
 		} _r_sym;
 	} _u_reloc;
 
-} ;
+};
 
 /* abbreviations for convenience */
-#ifndef r_type
-#define r_type      _u_reloc._r_sym._type
-#define r_uval      _u_reloc._r_uval._uval
-#define r_symndx    _u_reloc._r_sym._symndx
-#define r_offset    _u_reloc._r_field._offset
-#define r_fieldsz   _u_reloc._r_field._fieldsz
-#define r_wordsz    _u_reloc._r_field._wordsz
-#define r_disp      _u_reloc._r_sym._disp
+#ifndef TYPE
+#define TYPE      _u_reloc._r_sym._type
+#define UVAL      _u_reloc._r_uval._uval
+#define SYMNDX    _u_reloc._r_sym._symndx
+#define OFFSET    _u_reloc._r_field._offset
+#define FIELDSZ   _u_reloc._r_field._fieldsz
+#define WORDSZ    _u_reloc._r_field._wordsz
+#define R_DISP      _u_reloc._r_sym._disp
 #endif
 
-/*****************************************************************************/
-/*                                                                           */
-/* Important DOFF macros used for file processing                            */
-/*                                                                           */
-/*****************************************************************************/
+/**************************************************************************** */
+/* */
+/* Important DOFF macros used for file processing */
+/* */
+/**************************************************************************** */
 
 /* DOFF Versions */
 #define         DOFF0                       0
 
-/* Return the address/size >= to addr that is at a 32-bit boundary           */
-/* This assumes that a byte is 8 bits                                        */
+/* Return the address/size >= to addr that is at a 32-bit boundary */
+/* This assumes that a byte is 8 bits */
 #define         DOFF_ALIGN(addr)            (((addr) + 3) & ~UINT32_C(3))
 
-/*****************************************************************************/
-/*                                                                           */
-/* The DOFF section header flags field is laid out as follows:               */
-/*                                                                           */
-/*  Bits 0-3 : Section Type                                                  */
+/**************************************************************************** */
+/* */
+/* The DOFF section header flags field is laid out as follows: */
+/* */
+/*  Bits 0-3 : Section Type */
 /*  Bit    4 : Set when section requires target memory to be allocated by DL */
-/*  Bit    5 : Set when section requires downloading                         */
-/*  Bits 8-11: Alignment, same as COFF                                       */
-/*                                                                           */
-/*****************************************************************************/
+/*  Bit    5 : Set when section requires downloading */
+/*  Bits 8-11: Alignment, same as COFF */
+/* */
+/**************************************************************************** */
 
-/* Enum for DOFF section types (bits 0-3 of flag): See dynamic_loader.h      */
+/* Enum for DOFF section types (bits 0-3 of flag): See dynamic_loader.h */
 
-/* Macros to help processing of sections                                     */
+/* Macros to help processing of sections */
 #define DLOAD_SECT_TYPE(s_hdr)      ((s_hdr)->ds_flags & 0xF)
 
-/* DS_ALLOCATE indicates whether a section needs space on the target         */
+/* DS_ALLOCATE indicates whether a section needs space on the target */
 #define DS_ALLOCATE_MASK            0x10
 #define DS_NEEDS_ALLOCATION(s_hdr)  ((s_hdr)->ds_flags & DS_ALLOCATE_MASK)
 
-/* DS_DOWNLOAD indicates that the loader needs to copy bits                  */
+/* DS_DOWNLOAD indicates that the loader needs to copy bits */
 #define DS_DOWNLOAD_MASK            0x20
 #define DS_NEEDS_DOWNLOAD(s_hdr)    ((s_hdr)->ds_flags & DS_DOWNLOAD_MASK)
 
 /* Section alignment requirement in AUs */
 #define DS_ALIGNMENT(ds_flags) (1 << (((ds_flags) >> 8) & 0xF))
 
-#endif				/* _DOFF_H */
+#endif /* _DOFF_H */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/getsection.c kernel-power-2.6.28.new/drivers/dsp/bridge/dynload/getsection.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/getsection.c	2011-10-11 13:51:00.060583055 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/dynload/getsection.c	2011-10-23 08:22:37.609703000 +0100
@@ -14,43 +14,44 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-
 #include <dspbridge/getsection.h>
 #include "header.h"
 
 /*
  * Error strings
  */
-static const char E_READSTRM[] = { "Error reading %s from input stream" };
-static const char E_SEEK[] = { "Set file position to %d failed" };
-static const char E_ISIZ[] = { "Bad image packet size %d" };
-static const char E_CHECKSUM[] = { "Checksum failed on %s" };
-static const char E_RELOC[] = { "DLOAD_GetSection unable to read"
-	"sections containing relocation entries"};
+static const char readstrm[] = { "Error reading %s from input stream" };
+static const char seek[] = { "Set file position to %d failed" };
+static const char isiz[] = { "Bad image packet size %d" };
+static const char err_checksum[] = { "Checksum failed on %s" };
+
+static const char err_reloc[] = { "dload_get_section unable to read"
+	    "sections containing relocation entries"
+};
+
 #if BITS_PER_AU > BITS_PER_BYTE
-static const char E_ALLOC[] = { "Syms->Allocate( %d ) failed" };
-static const char E_STBL[] = { "Bad string table offset " FMT_UI32 };
+static const char err_alloc[] = { "Syms->dload_allocate( %d ) failed" };
+static const char stbl[] = { "Bad string table offset " FMT_UI32 };
 #endif
 
 /*
  * we use the fact that DOFF section records are shaped just like
- * LDR_SECTION_INFO to reduce our section storage usage.  These macros
+ * ldr_section_info to reduce our section storage usage.  These macros
  * marks the places where that assumption is made
  */
-#define DOFFSEC_IS_LDRSEC(pdoffsec) ((struct LDR_SECTION_INFO *)(pdoffsec))
+#define DOFFSEC_IS_LDRSEC(pdoffsec) ((struct ldr_section_info *)(pdoffsec))
 #define LDRSEC_IS_DOFFSEC(ldrsec) ((struct doff_scnhdr_t *)(ldrsec))
 
-/***************************************************************/
-/********************* SUPPORT FUNCTIONS ***********************/
-/***************************************************************/
+/************************************************************** */
+/********************* SUPPORT FUNCTIONS ********************** */
+/************************************************************** */
 
 #if BITS_PER_AU > BITS_PER_BYTE
 /**************************************************************************
  * Procedure unpack_sec_name
  *
  * Parameters:
- *  dlthis		Handle from DLOAD_module_open for this module
+ *  dlthis		Handle from dload_module_open for this module
  *	soffset	    Byte offset into the string table
  *  dst         Place to store the expanded string
  *
@@ -59,24 +60,23 @@
  * it in the process.  Returns a pointer just past the end of the stored
  * string on success, or NULL on failure.
  *
- *************************************************************************/
-static char *unpack_sec_name(struct dload_state *dlthis,
-			     u32 soffset, char *dst)
+ ************************************************************************ */
+static char *unpack_sec_name(struct dload_state *dlthis, u32 soffset, char *dst)
 {
 	u8 tmp, *src;
 
 	if (soffset >= dlthis->dfile_hdr.df_scn_name_size) {
-		dload_error(dlthis, E_STBL, soffset);
+		dload_error(dlthis, stbl, soffset);
 		return NULL;
 	}
-	src = (u8 *)dlthis->str_head +
+	src = (u8 *) dlthis->str_head +
 	    (soffset >> (LOG_BITS_PER_AU - LOG_BITS_PER_BYTE));
 	if (soffset & 1)
 		*dst++ = *src++;	/* only 1 character in first word */
 	do {
 		tmp = *src++;
 		*dst = (tmp >> BITS_PER_BYTE)
-		if (!(*dst++))
+		    if (!(*dst++))
 			break;
 	} while ((*dst++ = tmp & BYTE_MASK));
 
@@ -87,23 +87,23 @@
  * Procedure expand_sec_names
  *
  * Parameters:
- *  dlthis		Handle from DLOAD_module_open for this module
+ *  dlthis		Handle from dload_module_open for this module
  *
  * Effect:
  *    Allocates a buffer, unpacks and copies strings from string table into it.
  * Stores a pointer to the buffer into a state variable.
- **************************************************************************/
+ ************************************************************************* */
 static void expand_sec_names(struct dload_state *dlthis)
 {
 	char *xstrings, *curr, *next;
 	u32 xsize;
 	u16 sec;
-	struct LDR_SECTION_INFO *shp;
+	struct ldr_section_info *shp;
 	/* assume worst-case size requirement */
 	xsize = dlthis->dfile_hdr.df_max_str_len * dlthis->dfile_hdr.df_no_scns;
-	xstrings = (char *)dlthis->mysym->Allocate(dlthis->mysym, xsize);
+	xstrings = (char *)dlthis->mysym->dload_allocate(dlthis->mysym, xsize);
 	if (xstrings == NULL) {
-		dload_error(dlthis, E_ALLOC, xsize);
+		dload_error(dlthis, err_alloc, xsize);
 		return;
 	}
 	dlthis->xstrings = xstrings;
@@ -121,12 +121,12 @@
 
 #endif
 
-/***************************************************************/
-/********************* EXPORTED FUNCTIONS **********************/
-/***************************************************************/
+/************************************************************** */
+/********************* EXPORTED FUNCTIONS ********************* */
+/************************************************************** */
 
 /**************************************************************************
- * Procedure DLOAD_module_open
+ * Procedure dload_module_open
  *
  * Parameters:
  *	module	The input stream that supplies the module image
@@ -143,9 +143,9 @@
  * Returns:
  *	NULL if an error is encountered, otherwise a module handle for use
  * in subsequent operations.
- **************************************************************************/
-DLOAD_module_info DLOAD_module_open(struct Dynamic_Loader_Stream *module,
-				    struct Dynamic_Loader_Sym *syms)
+ ************************************************************************* */
+dload_module_info dload_module_open(struct dynamic_loader_stream *module,
+				    struct dynamic_loader_sym *syms)
 {
 	struct dload_state *dlthis;	/* internal state for this call */
 	unsigned *dp, sz;
@@ -163,7 +163,7 @@
 	}
 
 	dlthis = (struct dload_state *)
-		 syms->Allocate(syms, sizeof(struct dload_state));
+	    syms->dload_allocate(syms, sizeof(struct dload_state));
 	if (!dlthis) {
 		/* not enough storage */
 		dload_syms_error(syms, "Can't allocate module info");
@@ -187,11 +187,11 @@
 
 	/* skip ahead past the unread portion of the string table */
 	sec_start = sizeof(struct doff_filehdr_t) +
-		    sizeof(struct doff_verify_rec_t) +
-		    BYTE_TO_HOST(DOFF_ALIGN(dlthis->dfile_hdr.df_strtab_size));
+	    sizeof(struct doff_verify_rec_t) +
+	    BYTE_TO_HOST(DOFF_ALIGN(dlthis->dfile_hdr.df_strtab_size));
 
 	if (dlthis->strm->set_file_posn(dlthis->strm, sec_start) != 0) {
-		dload_error(dlthis, E_SEEK, sec_start);
+		dload_error(dlthis, seek, sec_start);
 		return NULL;
 	}
 
@@ -199,22 +199,22 @@
 		dload_sections(dlthis);
 
 	if (dlthis->dload_errcount) {
-		DLOAD_module_close(dlthis);	/* errors, blow off our state */
+		dload_module_close(dlthis);	/* errors, blow off our state */
 		dlthis = NULL;
 		return NULL;
 	}
 #if BITS_PER_AU > BITS_PER_BYTE
-	/* Expand all section names from the string table into the   */
+	/* Expand all section names from the string table into the */
 	/* state variable, and convert section names from a relative */
 	/* string table offset to a pointers to the expanded string. */
 	expand_sec_names(dlthis);
 #else
 	/* Convert section names from a relative string table offset */
-	/* to a pointer into the string table.                       */
+	/* to a pointer into the string table. */
 	for (sec = 0; sec < dlthis->dfile_hdr.df_no_scns; sec++) {
-		struct LDR_SECTION_INFO *shp =
+		struct ldr_section_info *shp =
 		    DOFFSEC_IS_LDRSEC(&dlthis->sect_hdrs[sec]);
-		shp->name = dlthis->str_head + *(u32 *)&shp->name;
+		shp->name = dlthis->str_head + *(u32 *) &shp->name;
 	}
 #endif
 
@@ -222,26 +222,26 @@
 }
 
 /***************************************************************************
- * Procedure DLOAD_GetSectionInfo
+ * Procedure dload_get_section_info
  *
  * Parameters:
- *  minfo		Handle from DLOAD_module_open for this module
+ *  minfo		Handle from dload_module_open for this module
  *	sectionName	Pointer to the string name of the section desired
  *	sectionInfo	Address of a section info structure pointer to be
  *			initialized
  *
  * Effect:
  *	Finds the specified section in the module information, and initializes
- * the provided struct LDR_SECTION_INFO pointer.
+ * the provided struct ldr_section_info pointer.
  *
  * Returns:
  *	true for success, false for section not found
- **************************************************************************/
-int DLOAD_GetSectionInfo(DLOAD_module_info minfo, const char *sectionName,
-		     const struct LDR_SECTION_INFO **const sectionInfo)
+ ************************************************************************* */
+int dload_get_section_info(dload_module_info minfo, const char *sectionName,
+			   const struct ldr_section_info **const sectionInfo)
 {
 	struct dload_state *dlthis;
-	struct LDR_SECTION_INFO *shp;
+	struct ldr_section_info *shp;
 	u16 sec;
 
 	dlthis = (struct dload_state *)minfo;
@@ -263,10 +263,10 @@
 #define REVERSE_REORDER_MAP(rawmap) ((rawmap) ^ 0x3030303)
 
 /**************************************************************************
- * Procedure DLOAD_GetSection
+ * Procedure dload_get_section
  *
  * Parameters:
- *  minfo		Handle from DLOAD_module_open for this module
+ *  minfo		Handle from dload_module_open for this module
  *	sectionInfo	Pointer to a section info structure for the desired
  *			section
  *	sectionData	Buffer to contain the section initialized data
@@ -277,9 +277,10 @@
  *
  * Returns:
  *	true for success, false for section not found
- **************************************************************************/
-int DLOAD_GetSection(DLOAD_module_info minfo,
-		 const struct LDR_SECTION_INFO *sectionInfo, void *sectionData)
+ ************************************************************************* */
+int dload_get_section(dload_module_info minfo,
+		      const struct ldr_section_info *sectionInfo,
+		      void *sectionData)
 {
 	struct dload_state *dlthis;
 	u32 pos;
@@ -288,7 +289,7 @@
 	struct image_packet_t ipacket;
 	s32 ipsize;
 	u32 checks;
-	s8 *dest = (s8 *)sectionData;
+	s8 *dest = (s8 *) sectionData;
 
 	dlthis = (struct dload_state *)minfo;
 	if (!dlthis)
@@ -300,16 +301,16 @@
 	/* skip ahead to the start of the first packet */
 	pos = BYTE_TO_HOST(DOFF_ALIGN((u32) sptr->ds_first_pkt_offset));
 	if (dlthis->strm->set_file_posn(dlthis->strm, pos) != 0) {
-		dload_error(dlthis, E_SEEK, pos);
+		dload_error(dlthis, seek, pos);
 		return false;
 	}
 
 	nip = sptr->ds_nipacks;
 	while ((nip -= 1) >= 0) {	/* for each packet */
 		/* get the fixed header bits */
-		if (dlthis->strm->
-		    read_buffer(dlthis->strm, &ipacket, IPH_SIZE) != IPH_SIZE) {
-			dload_error(dlthis, E_READSTRM, "image packet");
+		if (dlthis->strm->read_buffer(dlthis->strm, &ipacket,
+					      IPH_SIZE) != IPH_SIZE) {
+			dload_error(dlthis, readstrm, "image packet");
 			return false;
 		}
 		/* reorder the header if need be */
@@ -319,14 +320,14 @@
 		/* Now read the packet image bits. Note: round the size up to
 		 * the next multiple of 4 bytes; this is what checksum
 		 * routines want. */
-		ipsize = BYTE_TO_HOST(DOFF_ALIGN(ipacket.i_packet_size));
+		ipsize = BYTE_TO_HOST(DOFF_ALIGN(ipacket.packet_size));
 		if (ipsize > BYTE_TO_HOST(IMAGE_PACKET_SIZE)) {
-			dload_error(dlthis, E_ISIZ, ipsize);
+			dload_error(dlthis, isiz, ipsize);
 			return false;
 		}
 		if (dlthis->strm->read_buffer
 		    (dlthis->strm, dest, ipsize) != ipsize) {
-			dload_error(dlthis, E_READSTRM, "image packet");
+			dload_error(dlthis, readstrm, "image packet");
 			return false;
 		}
 		/* reorder the bytes if need be */
@@ -340,11 +341,11 @@
 		    TARGET_ORDER(REORDER_MAP(BYTE_RESHUFFLE_VALUE))) {
 			/* put image bytes in big-endian order, not PC order */
 			dload_reorder(dest, ipsize,
-				      TARGET_ORDER(dlthis->dfile_hdr.
-				      df_byte_reshuffle));
+				      TARGET_ORDER(dlthis->
+						dfile_hdr.df_byte_reshuffle));
 		}
 #if TARGET_AU_BITS > 8
-		checks = dload_reverse_checksum_16(dest, ipsize);
+		checks = dload_reverse_checksum16(dest, ipsize);
 #else
 		checks = dload_reverse_checksum(dest, ipsize);
 #endif
@@ -355,18 +356,18 @@
 		 * entries referring to fields that span the packet boundaries
 		 * may result in packets of sizes that are not multiple of
 		 * 4 bytes. Our checksum implementation works on 32-bit words
-		 * only.     */
-		if (ipacket.i_num_relocs != 0) {
-			dload_error(dlthis, E_RELOC, ipsize);
+		 * only. */
+		if (ipacket.num_relocs != 0) {
+			dload_error(dlthis, err_reloc, ipsize);
 			return false;
 		}
 
 		if (~checks) {
-			dload_error(dlthis, E_CHECKSUM, "image packet");
+			dload_error(dlthis, err_checksum, "image packet");
 			return false;
 		}
 
-		/*Advance destination ptr by the size of the just-read packet*/
+		/*Advance destination ptr by the size of the just-read packet */
 		dest += ipsize;
 	}
 
@@ -374,10 +375,10 @@
 }
 
 /***************************************************************************
- * Procedure DLOAD_module_close
+ * Procedure dload_module_close
  *
  * Parameters:
- *  minfo		Handle from DLOAD_module_open for this module
+ *  minfo		Handle from dload_module_open for this module
  *
  * Effect:
  *	Releases any storage associated with the module handle.  On return,
@@ -385,10 +386,10 @@
  *
  * Returns:
  *	Zero for success. On error, the number of errors detected is returned.
- * Individual errors are reported using syms->Error_Report(), where syms was
- * an argument to DLOAD_module_open
- **************************************************************************/
-void DLOAD_module_close(DLOAD_module_info minfo)
+ * Individual errors are reported using syms->error_report(), where syms was
+ * an argument to dload_module_open
+ ************************************************************************* */
+void dload_module_close(dload_module_info minfo)
 {
 	struct dload_state *dlthis;
 
@@ -397,16 +398,19 @@
 		return;
 
 	if (dlthis->str_head)
-		dlthis->mysym->Deallocate(dlthis->mysym, dlthis->str_head);
+		dlthis->mysym->dload_deallocate(dlthis->mysym,
+						dlthis->str_head);
 
 	if (dlthis->sect_hdrs)
-		dlthis->mysym->Deallocate(dlthis->mysym, dlthis->sect_hdrs);
+		dlthis->mysym->dload_deallocate(dlthis->mysym,
+						dlthis->sect_hdrs);
 
 #if BITS_PER_AU > BITS_PER_BYTE
 	if (dlthis->xstrings)
-		dlthis->mysym->Deallocate(dlthis->mysym, dlthis->xstrings);
+		dlthis->mysym->dload_deallocate(dlthis->mysym,
+						dlthis->xstrings);
 
 #endif
 
-	dlthis->mysym->Deallocate(dlthis->mysym, dlthis);
+	dlthis->mysym->dload_deallocate(dlthis->mysym, dlthis);
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/header.h kernel-power-2.6.28.new/drivers/dsp/bridge/dynload/header.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/header.h	2011-10-11 13:51:00.060583055 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/dynload/header.h	2011-10-23 08:22:37.609703000 +0100
@@ -14,8 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-
 #define TRUE 1
 #define FALSE 0
 #ifndef NULL
@@ -29,8 +27,8 @@
 #define STATIC_EXPR_STK_SIZE 10
 
 #include <linux/types.h>
-typedef unsigned int            uint_least32_t;
-typedef unsigned short int	uint_least16_t;
+typedef unsigned int uint_least32_t;
+typedef unsigned short int uint_least16_t;
 
 #include "doff.h"
 #include <dspbridge/dynamic_loader.h>
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/module_list.h kernel-power-2.6.28.new/drivers/dsp/bridge/dynload/module_list.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/module_list.h	2011-10-11 13:51:00.060583055 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/dynload/module_list.h	2011-10-23 08:22:37.613570000 +0100
@@ -14,61 +14,55 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*============================================================================
- Filename:     module_list.h
-
- Copyright (C) 2002 Texas Instruments Incorporated
-
-
- This C header file gives the layout of the data structure created by the
- dynamic loader to describe the set of modules loaded into the DSP.
-
- Linked List Structure:
- ----------------------
- The data structure defined here is a singly-linked list.  The list
- represents the set of modules which are currently loaded in the DSP memory.
- The first entry in the list is a header record which contains a flag
- representing the state of the list.  The rest of the entries in the list
- are module records.
-
- Global symbol  _DLModules designates the first record in the list (i.e. the
- header record).  This symbol must be defined in any program that wishes to
- use DLLview plug-in.
-
- String Representation:
- ----------------------
- The string names of the module and its sections are stored in a block of
- memory which follows the module record itself.  The strings are ordered:
- module name first, followed by section names in order from the first
- section to the last.  String names are tightly packed arrays of 8-bit
- characters (two characters per 16-bit word on the C55x).  Strings are
- zero-byte-terminated.
-
- Creating and updating the list:
--------------------------------
- Upon loading a new module into the DSP memory the dynamic loader inserts a
-new module record as the first module record in the list.  The fields of
- this module record are initialized to reflect the properties of the module.
- The dynamic loader does NOT increment the flag/counter in the list's header
- record.
-
- Upon unloading a module from the DSP memory the dynamic loader removes the
-module's record from this list.  The dynamic loader also increments the
- flag/counter in the list's header record to indicate that the list has been
- changed.
-
-============================================================================*/
+/*
+ * This C header file gives the layout of the data structure created by the
+ * dynamic loader to describe the set of modules loaded into the DSP.
+ *
+ * Linked List Structure:
+ * ----------------------
+ * The data structure defined here is a singly-linked list.  The list
+ * represents the set of modules which are currently loaded in the DSP memory.
+ * The first entry in the list is a header record which contains a flag
+ * representing the state of the list.  The rest of the entries in the list
+ * are module records.
+ *
+ * Global symbol  _DLModules designates the first record in the list (i.e. the
+ * header record).  This symbol must be defined in any program that wishes to
+ * use DLLview plug-in.
+ *
+ * String Representation:
+ * ----------------------
+ * The string names of the module and its sections are stored in a block of
+ * memory which follows the module record itself.  The strings are ordered:
+ * module name first, followed by section names in order from the first
+ * section to the last.  String names are tightly packed arrays of 8-bit
+ * characters (two characters per 16-bit word on the C55x).  Strings are
+ * zero-byte-terminated.
+ *
+ * Creating and updating the list:
+ * -------------------------------
+ * Upon loading a new module into the DSP memory the dynamic loader inserts a
+ * new module record as the first module record in the list.  The fields of
+ * this module record are initialized to reflect the properties of the module.
+ * The dynamic loader does NOT increment the flag/counter in the list's header
+ * record.
+ *
+ * Upon unloading a module from the DSP memory the dynamic loader removes the
+ * module's record from this list.  The dynamic loader also increments the
+ * flag/counter in the list's header record to indicate that the list has been
+ * changed.
+ */
 
 #ifndef _MODULE_LIST_H_
 #define _MODULE_LIST_H_
 
 #include <linux/types.h>
 
-/* Global pointer to the modules_header structure*/
+/* Global pointer to the modules_header structure */
 #define MODULES_HEADER "_DLModules"
 #define MODULES_HEADER_NO_UNDERSCORE "DLModules"
 
-/* Initial version number*/
+/* Initial version number */
 #define INIT_VERSION 1
 
 /* Verification number -- to be recorded in each module record */
@@ -82,8 +76,11 @@
  * its address is contained in the global _DLModules pointer */
 struct modules_header {
 
-	/* Address of the first dll_module record in the list or NULL.
-	 Note: for C55x this is a word address (C55x data is word-addressable)*/
+	/*
+	 * Address of the first dll_module record in the list or NULL.
+	 * Note: for C55x this is a word address (C55x data is
+	 * word-addressable)
+	 */
 	u32 first_module;
 
 	/* Combined storage size (in target addressable units) of the
@@ -96,11 +93,12 @@
 	 * the list */
 	u16 update_flag;
 
-} ;
+};
 
 /* for each 32-bits in above structure, a bitmap, LSB first, whose bits are:
  * 0 => a 32-bit value, 1 => 2 16-bit values */
-#define MODULES_HEADER_BITMAP 0x2 /* swapping bitmap for type modules_header */
+/* swapping bitmap for type modules_header */
+#define MODULES_HEADER_BITMAP 0x2
 
 /* information recorded about each section in a module */
 struct dll_sect {
@@ -119,7 +117,7 @@
 	 * (C55 addresses are really only 24-bits wide). */
 	u32 sect_run_adr;
 
-} ;
+};
 
 /* the rest of the entries in the list are module records */
 struct dll_module {
@@ -152,10 +150,10 @@
 
 	/* Array of num_sects elements of the module's section records */
 	struct dll_sect sects[1];
-} ;
+};
 
 /* for each 32 bits in above structure, a bitmap, LSB first, whose bits are:
  * 0 => a 32-bit value, 1 => 2 16-bit values */
 #define DLL_MODULE_BITMAP 0x6	/* swapping bitmap for type dll_module */
 
-#endif				/* _MODULE_LIST_H_ */
+#endif /* _MODULE_LIST_H_ */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/params.h kernel-power-2.6.28.new/drivers/dsp/bridge/dynload/params.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/params.h	2011-10-11 13:51:00.060583055 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/dynload/params.h	2011-10-23 08:22:37.613570000 +0100
@@ -3,6 +3,15 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This file defines host and target properties for all machines
+ * supported by the dynamic loader.  To be tedious...
+ *
+ * host: the machine on which the dynamic loader runs
+ * target: the machine that the dynamic loader is loading
+ *
+ * Host and target may or may not be the same, depending upon the particular
+ * use.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,25 +23,11 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-
-/******************************************************************************
- *
- * This file defines host and target properties for all machines
- * supported by the dynamic loader.  To be tedious...
- *
- *		host == the machine on which the dynamic loader runs
- *		target == the machine that the dynamic loader is loading
- *
- * Host and target may or may not be the same, depending upon the particular
- * use.
- *****************************************************************************/
-
 /******************************************************************************
  *
  *							Host Properties
  *
- *****************************************************************************/
+ **************************************************************************** */
 
 #define BITS_PER_BYTE 8		/* bits in the standard PC/SUN byte */
 #define LOG_BITS_PER_BYTE 3	/* log base 2 of same */
@@ -45,8 +40,10 @@
 #define FMT_UI32 "0x%lx"
 #define FMT8_UI32 "%08lx"	/* same but no 0x, fixed width field */
 #else
-#define BITS_PER_AU 8	/* bits in the smallest addressable data storage unit */
-#define LOG_BITS_PER_AU 3  /* log base 2 of the same; useful for shift counts */
+/* bits in the smallest addressable data storage unit */
+#define BITS_PER_AU 8
+/* log base 2 of the same; useful for shift counts */
+#define LOG_BITS_PER_AU 3
 #define FMT_UI32 "0x%x"
 #define FMT8_UI32 "%08x"
 #endif
@@ -61,15 +58,14 @@
  *
  *							Target Properties
  *
- *****************************************************************************/
+ **************************************************************************** */
 
-
-/*--------------------------------------------------------------------------*/
-/* TMS320C6x Target Specific Parameters (byte-addressable)                  */
-/*--------------------------------------------------------------------------*/
+/*-------------------------------------------------------------------------- */
+/* TMS320C6x Target Specific Parameters (byte-addressable) */
+/*-------------------------------------------------------------------------- */
 #if TMS32060
-#define MEMORG          0x0L	/* Size of configured memory  */
-#define MEMSIZE         0x0L	/* (full address space)  */
+#define MEMORG          0x0L	/* Size of configured memory */
+#define MEMSIZE         0x0L	/* (full address space) */
 
 #define CINIT_ALIGN     8	/* alignment of cinit record in TDATA AUs */
 #define CINIT_COUNT	4	/* width of count field in TDATA AUs */
@@ -77,7 +73,7 @@
 #define CINIT_PAGE_BITS	0	/* Number of LSBs of address that
 				 * are page number */
 
-#define LENIENT_SIGNED_RELEXPS 0	/* DOES SIGNED ALLOW MAX UNSIGNED   */
+#define LENIENT_SIGNED_RELEXPS 0	/* DOES SIGNED ALLOW MAX UNSIGNED */
 
 #undef TARGET_ENDIANNESS	/* may be big or little endian */
 
@@ -85,13 +81,12 @@
 #define TARGET_WORD_ALIGN(zz) (((zz) + 0x3) & -0x4)
 #endif
 
-
 /*--------------------------------------------------------------------------
  *
  *			DEFAULT SETTINGS and DERIVED PROPERTIES
  *
  * This section establishes defaults for values not specified above
- *--------------------------------------------------------------------------*/
+ *-------------------------------------------------------------------------- */
 #ifndef TARGET_AU_BITS
 #define TARGET_AU_BITS 8	/* width of the target addressable unit */
 #define LOG_TARGET_AU_BITS 3	/* log2 of same */
@@ -214,11 +209,11 @@
 
 /* the unit in which we process target image data */
 #if TARGET_AU_BITS <= 8
-typedef u8 TgtAU_t;
+typedef u8 tgt_au_t;
 #elif TARGET_AU_BITS <= 16
-typedef u16 TgtAU_t;
+typedef u16 tgt_au_t;
 #else
-typedef u32 TgtAU_t;
+typedef u32 tgt_au_t;
 #endif
 
 /* size of that unit */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/reloc.c kernel-power-2.6.28.new/drivers/dsp/bridge/dynload/reloc.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/reloc.c	2011-10-11 13:51:00.060583055 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/dynload/reloc.c	2011-10-23 08:22:37.613570000 +0100
@@ -18,7 +18,7 @@
 
 #if TMS32060
 /* the magic symbol for the start of BSS */
-static const char BSSSYMBOL[] = {".bss"};
+static const char bsssymbol[] = { ".bss" };
 #endif
 
 #if TMS32060
@@ -27,9 +27,9 @@
 
 #if TMS32060
 /* From coff.h - ignore these relocation operations */
-#define R_C60ALIGN     0x76       /* C60: Alignment info for compressor   */
-#define R_C60FPHEAD    0x77       /* C60: Explicit assembly directive     */
-#define R_C60NOCMP    0x100       /* C60: Don't compress this code scn    */
+#define R_C60ALIGN     0x76	/* C60: Alignment info for compressor */
+#define R_C60FPHEAD    0x77	/* C60: Explicit assembly directive */
+#define R_C60NOCMP    0x100	/* C60: Don't compress this code scn */
 #endif
 
 /**************************************************************************
@@ -38,21 +38,21 @@
  * Parameters:
  *	data	pointer to storage unit containing lowest host address of
  *		image data
- *	fieldsz	Size of bit field, 0 < fieldsz <= sizeof(RVALUE)*BITS_PER_AU
+ *	fieldsz	Size of bit field, 0 < fieldsz <= sizeof(rvalue)*BITS_PER_AU
  *	offset	Offset from LSB, 0 <= offset < BITS_PER_AU
  *	sgn	Signedness of the field (ROP_SGN, ROP_UNS, ROP_MAX, ROP_ANY)
  *
  * Effect:
  *	Extracts the specified field and returns it.
- **************************************************************************/
-RVALUE dload_unpack(struct dload_state *dlthis, TgtAU_t *data, int fieldsz,
+ ************************************************************************* */
+rvalue dload_unpack(struct dload_state *dlthis, tgt_au_t * data, int fieldsz,
 		    int offset, unsigned sgn)
 {
-	register RVALUE objval;
+	register rvalue objval;
 	register int shift, direction;
-	register TgtAU_t *dp = data;
+	register tgt_au_t *dp = data;
 
-	fieldsz -= 1;	/* avoid nastiness with 32-bit shift of 32-bit value*/
+	fieldsz -= 1;	/* avoid nastiness with 32-bit shift of 32-bit value */
 	/* * collect up enough bits to contain the desired field */
 	if (TARGET_BIG_ENDIAN) {
 		dp += (fieldsz + offset) >> LOG_TGTAU_BITS;
@@ -63,7 +63,7 @@
 	shift = TGTAU_BITS - offset;
 	while (shift <= fieldsz) {
 		dp += direction;
-		objval += (RVALUE)*dp << shift;
+		objval += (rvalue) *dp << shift;
 		shift += TGTAU_BITS;
 	}
 
@@ -71,14 +71,13 @@
 	if (sgn == ROP_UNS)
 		objval &= (2 << fieldsz) - 1;
 	else {
-		shift = sizeof(RVALUE) * BITS_PER_AU-1 - fieldsz;
+		shift = sizeof(rvalue) * BITS_PER_AU - 1 - fieldsz;
 		objval = (objval << shift) >> shift;
 	}
 
 	return objval;
 
-} /* dload_unpack */
-
+}				/* dload_unpack */
 
 /**************************************************************************
  * Procedure dload_repack
@@ -87,7 +86,7 @@
  *	val		Value to insert
  *	data	Pointer to storage unit containing lowest host address of
  * 		image data
- *	fieldsz	Size of bit field, 0 < fieldsz <= sizeof(RVALUE)*BITS_PER_AU
+ *	fieldsz	Size of bit field, 0 < fieldsz <= sizeof(rvalue)*BITS_PER_AU
  *	offset	Offset from LSB, 0 <= offset < BITS_PER_AU
  *	sgn	Signedness of the field (ROP_SGN, ROP_UNS, ROP_MAX, ROP_ANY)
  *
@@ -96,15 +95,15 @@
  *	success
  * or 1 if the value will not fit in the specified field according to the
  * specified signedness rule.
- **************************************************************************/
-static const unsigned char ovf_limit[] = {1, 2, 2};
-int dload_repack(struct dload_state *dlthis, RVALUE val, TgtAU_t *data,
+ ************************************************************************* */
+static const unsigned char ovf_limit[] = { 1, 2, 2 };
+
+int dload_repack(struct dload_state *dlthis, rvalue val, tgt_au_t * data,
 		 int fieldsz, int offset, unsigned sgn)
 {
-	register URVALUE objval, mask;
+	register urvalue objval, mask;
 	register int shift, direction;
-	register TgtAU_t *dp = data;
-
+	register tgt_au_t *dp = data;
 
 	fieldsz -= 1;	/* avoid nastiness with 32-bit shift of 32-bit value */
 	/* clip the bits */
@@ -119,7 +118,7 @@
 
 	/* insert LSBs */
 	*dp = (*dp & ~(mask << offset)) + (objval << offset);
-	shift = TGTAU_BITS-offset;
+	shift = TGTAU_BITS - offset;
 	/* align mask and objval with AU boundary */
 	objval >>= shift;
 	mask >>= shift;
@@ -136,18 +135,18 @@
 	 */
 	if (sgn) {
 		unsigned tmp = (val >> fieldsz) + (sgn & 0x1);
-		if (tmp > ovf_limit[sgn-1])
+		if (tmp > ovf_limit[sgn - 1])
 			return 1;
 	}
 	return 0;
 
-} /* dload_repack */
+}				/* dload_repack */
 
 /* lookup table for the scaling amount in a C6x instruction */
 #if TMS32060
 #define SCALE_BITS 4		/* there are 4 bits in the scale field */
 #define SCALE_MASK 0x7		/* we really only use the bottom 3 bits */
-static const u8 C60_Scale[SCALE_MASK+1] = {
+static const u8 c60_scale[SCALE_MASK + 1] = {
 	1, 0, 0, 0, 1, 1, 2, 2
 };
 #endif
@@ -161,67 +160,88 @@
  *
  * Effect:
  *	Performs the specified relocation operation
- **************************************************************************/
-void dload_relocate(struct dload_state *dlthis, TgtAU_t *data,
-		    struct reloc_record_t *rp)
+ ************************************************************************* */
+void dload_relocate(struct dload_state *dlthis, tgt_au_t * data,
+		    struct reloc_record_t *rp, bool * tramps_genereted,
+		    bool second_pass)
 {
-	RVALUE val = 0;
-	RVALUE reloc_amt = 0;
+	rvalue val, reloc_amt, orig_val = 0;
 	unsigned int fieldsz = 0;
 	unsigned int offset = 0;
 	unsigned int reloc_info = 0;
 	unsigned int reloc_action = 0;
 	register int rx = 0;
-	RVALUE    *stackp = NULL;
+	rvalue *stackp = NULL;
 	int top;
-	struct Local_Symbol *svp = NULL;
+	struct local_symbol *svp = NULL;
 #ifdef RFV_SCALE
 	unsigned int scale = 0;
 #endif
+	struct image_packet_t *img_pkt = NULL;
+
+	/* The image packet data struct is only used during first pass
+	 * relocation in the event that a trampoline is needed.  2nd pass
+	 * relocation doesn't guarantee that data is coming from an
+	 * image_packet_t structure. See cload.c, dload_data for how img_data is
+	 * set. If that changes this needs to be updated!!! */
+	if (second_pass == false)
+		img_pkt = (struct image_packet_t *)((u8 *) data -
+						    sizeof(struct
+							   image_packet_t));
 
-	rx = HASH_FUNC(rp->r_type);
-	while (rop_map1[rx] != rp->r_type) {
+	rx = HASH_FUNC(rp->TYPE);
+	while (rop_map1[rx] != rp->TYPE) {
 		rx = HASH_L(rop_map2[rx]);
 		if (rx < 0) {
 #if TMS32060
-		switch (rp->r_type) {
-		case R_C60ALIGN:
-		case R_C60NOCMP:
-		case R_C60FPHEAD:
-		    /* Ignore these reloc types and return */
-		    break;
-		default:
-		    /* Unknown reloc type, print error and return */
-		    dload_error(dlthis, "Bad coff operator 0x%x", rp->r_type);
-	    }
+			switch (rp->TYPE) {
+			case R_C60ALIGN:
+			case R_C60NOCMP:
+			case R_C60FPHEAD:
+				/* Ignore these reloc types and return */
+				break;
+			default:
+				/* Unknown reloc type, print error and return */
+				dload_error(dlthis, "Bad coff operator 0x%x",
+					    rp->TYPE);
+			}
 #else
-	    dload_error(dlthis, "Bad coff operator 0x%x", rp->r_type);
+			dload_error(dlthis, "Bad coff operator 0x%x", rp->TYPE);
 #endif
-	    return;
+			return;
 		}
 	}
 	rx = HASH_I(rop_map2[rx]);
-	if ((rx < (sizeof(rop_action)/sizeof(uint_least16_t)))
-	   && (rx < (sizeof(rop_info)/sizeof(uint_least16_t))) && (rx > 0)) {
-		reloc_action = rop_action[rx]; reloc_info = rop_info[rx];
+	if ((rx < (sizeof(rop_action) / sizeof(uint_least16_t)))
+	    && (rx < (sizeof(rop_info) / sizeof(uint_least16_t))) && (rx > 0)) {
+		reloc_action = rop_action[rx];
+		reloc_info = rop_info[rx];
 	} else {
-	    dload_error(dlthis, "Buffer Overflow - Array Index Out of Bounds");
+		dload_error(dlthis, "Buffer Overflow - Array Index Out "
+			    "of Bounds");
 	}
 
 	/* Compute the relocation amount for the referenced symbol, if any */
-	reloc_amt = rp->r_uval;
+	reloc_amt = rp->UVAL;
 	if (RFV_SYM(reloc_info)) {	/* relocation uses a symbol reference */
-		if ((u32)rp->r_symndx < dlthis->dfile_hdr.df_no_syms) {
-			/* real symbol reference */
-			svp = &dlthis->local_symtab[rp->r_symndx];
-			reloc_amt = (RFV_SYM(reloc_info) == ROP_SYMD) ?
+		/* If this is first pass, use the module local symbol table,
+		 * else use the trampoline symbol table. */
+		if (second_pass == false) {
+			if ((u32) rp->SYMNDX < dlthis->dfile_hdr.df_no_syms) {
+				/* real symbol reference */
+				svp = &dlthis->local_symtab[rp->SYMNDX];
+				reloc_amt = (RFV_SYM(reloc_info) == ROP_SYMD) ?
 				    svp->delta : svp->value;
+			}
+			/* reloc references current section */
+			else if (rp->SYMNDX == -1) {
+				reloc_amt = (RFV_SYM(reloc_info) == ROP_SYMD) ?
+				    dlthis->delta_runaddr :
+				    dlthis->image_secn->run_addr;
+			}
 		}
-		/* reloc references current section */
-		else if (rp->r_symndx == -1)
-			reloc_amt = (RFV_SYM(reloc_info) == ROP_SYMD) ?
-			  dlthis->delta_runaddr : dlthis->image_secn->run_addr;
-	}	/* relocation uses a symbol reference */
+	}
+	/* relocation uses a symbol reference */
 	/* Handle stack adjustment */
 	val = 0;
 	top = RFV_STK(reloc_info);
@@ -229,9 +249,9 @@
 		top += dlthis->relstkidx - RSTK_UOP;
 		if (top >= STATIC_EXPR_STK_SIZE) {
 			dload_error(dlthis,
-			"Expression stack overflow in %s at offset "
-			FMT_UI32, dlthis->image_secn->name,
-			rp->r_vaddr + dlthis->image_offset);
+				    "Expression stack overflow in %s at offset "
+				    FMT_UI32, dlthis->image_secn->name,
+				    rp->vaddr + dlthis->image_offset);
 			return;
 		}
 		val = dlthis->relstk[dlthis->relstkidx];
@@ -244,29 +264,30 @@
 		if (fieldsz) {	/* field info from table */
 			offset = RFV_POSN(reloc_action);
 			if (TARGET_BIG_ENDIAN)
-				/* make sure r_vaddr is the lowest target
+				/* make sure vaddr is the lowest target
 				 * address containing bits */
-				rp->r_vaddr += RFV_BIGOFF(reloc_info);
+				rp->vaddr += RFV_BIGOFF(reloc_info);
 		} else {	/* field info from relocation op */
-			fieldsz = rp->r_fieldsz; offset = rp->r_offset;
+			fieldsz = rp->FIELDSZ;
+			offset = rp->OFFSET;
 			if (TARGET_BIG_ENDIAN)
-				/* make sure r_vaddr is the lowest target
+				/* make sure vaddr is the lowest target
 				   address containing bits */
-				rp->r_vaddr += (rp->r_wordsz - offset - fieldsz)
-						>> LOG_TARGET_AU_BITS;
+				rp->vaddr += (rp->WORDSZ - offset - fieldsz)
+				    >> LOG_TARGET_AU_BITS;
 		}
-		data = (TgtAU_t *)((char *)data + TADDR_TO_HOST(rp->r_vaddr));
+		data = (tgt_au_t *) ((char *)data + TADDR_TO_HOST(rp->vaddr));
 		/* compute lowest host location of referenced data */
 #if BITS_PER_AU > TARGET_AU_BITS
 		/* conversion from target address to host address may lose
 		   address bits; add loss to offset */
 		if (TARGET_BIG_ENDIAN) {
-			offset += -((rp->r_vaddr << LOG_TARGET_AU_BITS) +
-				  offset + fieldsz) &
-				  (BITS_PER_AU-TARGET_AU_BITS);
+			offset += -((rp->vaddr << LOG_TARGET_AU_BITS) +
+				    offset + fieldsz) &
+			    (BITS_PER_AU - TARGET_AU_BITS);
 		} else {
-			offset += (rp->r_vaddr << LOG_TARGET_AU_BITS) &
-				  (BITS_PER_AU-1);
+			offset += (rp->vaddr << LOG_TARGET_AU_BITS) &
+			    (BITS_PER_AU - 1);
 		}
 #endif
 #ifdef RFV_SCALE
@@ -274,9 +295,14 @@
 #endif
 	}
 	/* read the object value from the current image, if so ordered */
-	if (reloc_info & ROP_R) {    /* relocation reads current image value */
+	if (reloc_info & ROP_R) {
+		/* relocation reads current image value */
 		val = dload_unpack(dlthis, data, fieldsz, offset,
-		      RFV_SIGN(reloc_info));
+				   RFV_SIGN(reloc_info));
+		/* Save off the original value in case the relo overflows and
+		 * we can trampoline it. */
+		orig_val = val;
+
 #ifdef RFV_SCALE
 		val <<= scale;
 #endif
@@ -297,13 +323,13 @@
 		 * (special reloc type) or to absolute destination
 		 * (symndx == -1).  In either case, set the appropriate
 		 * relocation amount to 0.
-		 *-----------------------------------------------------------*/
-		if (rp->r_symndx == -1)
+		 *----------------------------------------------------------- */
+		if (rp->SYMNDX == -1)
 			reloc_amt = 0;
 		val += reloc_amt - dlthis->delta_runaddr;
 		break;
 	case RACT_ADDISP:
-		val += rp->r_disp + reloc_amt;
+		val += rp->R_DISP + reloc_amt;
 		break;
 	case RACT_ASGPC:
 		val = dlthis->image_secn->run_addr + reloc_amt;
@@ -332,19 +358,19 @@
 			val = *stackp % val;
 		break;
 	case RACT_SR:
-		if (val >= sizeof(RVALUE) * BITS_PER_AU)
+		if (val >= sizeof(rvalue) * BITS_PER_AU)
 			val = 0;
 		else if (stackp != NULL)
-			val = (URVALUE)*stackp >> val;
+			val = (urvalue) *stackp >> val;
 		break;
 	case RACT_ASR:
-		if (val >= sizeof(RVALUE)*BITS_PER_AU)
-			val = sizeof(RVALUE)*BITS_PER_AU - 1;
+		if (val >= sizeof(rvalue) * BITS_PER_AU)
+			val = sizeof(rvalue) * BITS_PER_AU - 1;
 		else if (stackp != NULL)
 			val = *stackp >> val;
 		break;
 	case RACT_SL:
-		if (val >= sizeof(RVALUE)*BITS_PER_AU)
+		if (val >= sizeof(rvalue) * BITS_PER_AU)
 			val = 0;
 		else if (stackp != NULL)
 			val = *stackp << val;
@@ -368,58 +394,91 @@
 	case RACT_C6SECT:
 		/* actually needed address of secn containing symbol */
 		if (svp != NULL) {
-			if (rp->r_symndx >= 0)
+			if (rp->SYMNDX >= 0)
 				if (svp->secnn > 0)
 					reloc_amt = dlthis->ldr_sections
-						[svp->secnn-1].run_addr;
+					    [svp->secnn - 1].run_addr;
 		}
-	/* !!! FALL THRU !!! */
+		/* !!! FALL THRU !!! */
 	case RACT_C6BASE:
 		if (dlthis->bss_run_base == 0) {
 			struct dynload_symbol *symp;
-			symp = dlthis->mysym->Find_Matching_Symbol
-				(dlthis->mysym, BSSSYMBOL);
+			symp = dlthis->mysym->find_matching_symbol
+			    (dlthis->mysym, bsssymbol);
 			/* lookup value of global BSS base */
 			if (symp)
 				dlthis->bss_run_base = symp->value;
 			else
 				dload_error(dlthis,
-				     "Global BSS base referenced in %s offset"\
-				     FMT_UI32 " but not defined",
-				     dlthis->image_secn->name,
-				     rp->r_vaddr + dlthis->image_offset);
+					    "Global BSS base referenced in %s "
+					    "offset" FMT_UI32 " but not "
+					    "defined",
+					    dlthis->image_secn->name,
+					    rp->vaddr + dlthis->image_offset);
 		}
 		reloc_amt -= dlthis->bss_run_base;
 		/* !!! FALL THRU !!! */
 	case RACT_C6DSPL:
 		/* scale factor determined by 3 LSBs of field */
-		scale = C60_Scale[val & SCALE_MASK];
+		scale = c60_scale[val & SCALE_MASK];
 		offset += SCALE_BITS;
 		fieldsz -= SCALE_BITS;
 		val >>= SCALE_BITS;	/* ignore the scale field hereafter */
 		val <<= scale;
-		val += reloc_amt;		/* do the usual relocation */
-		if (((1 << scale)-1) & val)
+		val += reloc_amt;	/* do the usual relocation */
+		if (((1 << scale) - 1) & val)
 			dload_error(dlthis,
-				"Unaligned reference in %s offset " FMT_UI32,
-				dlthis->image_secn->name,
-				rp->r_vaddr + dlthis->image_offset);
+				    "Unaligned reference in %s offset "
+				    FMT_UI32, dlthis->image_secn->name,
+				    rp->vaddr + dlthis->image_offset);
 		break;
 #endif
-	}	/* relocation actions */
+	}			/* relocation actions */
 	/* * Put back result as required */
 	if (reloc_info & ROP_W) {	/* relocation writes image value */
 #ifdef RFV_SCALE
 		val >>= scale;
 #endif
 		if (dload_repack(dlthis, val, data, fieldsz, offset,
-		   RFV_SIGN(reloc_info))) {
-			dload_error(dlthis, "Relocation value " FMT_UI32
-			    " overflows %d bits in %s offset " FMT_UI32, val,
-			    fieldsz, dlthis->image_secn->name,
-			    dlthis->image_offset + rp->r_vaddr);
+				 RFV_SIGN(reloc_info))) {
+			/* Check to see if this relo can be trampolined,
+			 * but only in first phase relocation.  2nd phase
+			 * relocation cannot trampoline. */
+			if ((second_pass == false) &&
+			    (dload_tramp_avail(dlthis, rp) == true)) {
+
+				/* Before generating the trampoline, restore
+				 * the value to its original so the 2nd pass
+				 *  relo will work. */
+				dload_repack(dlthis, orig_val, data, fieldsz,
+					     offset, RFV_SIGN(reloc_info));
+				if (!dload_tramp_generate(dlthis,
+							(dlthis->image_secn -
+							 dlthis->ldr_sections),
+							 dlthis->image_offset,
+							 img_pkt, rp)) {
+					dload_error(dlthis,
+						    "Failed to "
+						    "generate trampoline for "
+						    "bit overflow");
+					dload_error(dlthis,
+						    "Relocation val " FMT_UI32
+						    " overflows %d bits in %s "
+						    "offset " FMT_UI32, val,
+						    fieldsz,
+						    dlthis->image_secn->name,
+						    dlthis->image_offset +
+						    rp->vaddr);
+				} else
+					*tramps_genereted = true;
+			} else {
+				dload_error(dlthis, "Relocation value "
+					    FMT_UI32 " overflows %d bits in %s"
+					    " offset " FMT_UI32, val, fieldsz,
+					    dlthis->image_secn->name,
+					    dlthis->image_offset + rp->vaddr);
+			}
 		}
 	} else if (top)
 		*stackp = val;
-} /* reloc_value */
-
+}				/* reloc_value */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/reloc_table_c6000.c kernel-power-2.6.28.new/drivers/dsp/bridge/dynload/reloc_table_c6000.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/reloc_table_c6000.c	2011-10-11 13:51:00.060583055 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/dynload/reloc_table_c6000.c	2011-10-23 08:22:37.613570000 +0100
@@ -14,7 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
 /* Tables generated for c6000 */
 
 #define HASH_FUNC(zz) (((((zz) + 1) * UINT32_C(1845)) >> 11) & 63)
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/reloc_table.h kernel-power-2.6.28.new/drivers/dsp/bridge/dynload/reloc_table.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/reloc_table.h	2011-10-11 13:51:00.060583055 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/dynload/reloc_table.h	2011-10-23 08:22:37.613570000 +0100
@@ -14,10 +14,8 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-
-#ifndef __RELOC_TABLE_H__
-#define __RELOC_TABLE_H__
+#ifndef _RELOC_TABLE_H_
+#define _RELOC_TABLE_H_
 /*
  * Table of relocation operator properties
  */
@@ -34,11 +32,11 @@
 #define ROP_ANY	0		/* no overflow ever, just truncate the value */
 #define ROP_SGN	1		/* signed field */
 #define ROP_UNS	2		/* unsigned field */
-#define ROP_MAX 3	  /* allow maximum range of either signed or unsigned */
+#define ROP_MAX 3	/* allow maximum range of either signed or unsigned */
 
 /* How does the relocation operation use the symbol reference */
 #define ROP_IGN	0		/* no symbol is referenced */
-#define ROP_LIT 0		/* use rp->r_uval literal field */
+#define ROP_LIT 0		/* use rp->UVAL literal field */
 #define ROP_SYM	1		/* symbol value is used in relocation */
 #define ROP_SYMD 2		/* delta value vs last link is used */
 
@@ -51,13 +49,15 @@
 /*
  * Computational actions performed by the dynamic loader
  */
-enum Dload_Actions {
-	RACT_VAL,    /* don't alter the current val (from stack or mem fetch) */
-	RACT_ASGN,   /* set value to reference amount (from symbol reference) */
+enum dload_actions {
+	/* don't alter the current val (from stack or mem fetch) */
+	RACT_VAL,
+	/* set value to reference amount (from symbol reference) */
+	RACT_ASGN,
 	RACT_ADD,		/* add reference to value */
 	RACT_PCR,		/* add reference minus PC delta to value */
-	RACT_ADDISP,		/* add reference plus r_disp */
-	RACT_ASGPC,	/* set value to section address plus reference */
+	RACT_ADDISP,		/* add reference plus R_DISP */
+	RACT_ASGPC,		/* set value to section addr plus reference */
 
 	RACT_PLUS,		/* stack + */
 	RACT_SUB,		/* stack - */
@@ -99,4 +99,4 @@
 #define RFV_BIGOFF(iii) ((iii) >> 8)
 #endif
 
-#endif				/* __RELOC_TABLE_H__ */
+#endif /* _RELOC_TABLE_H_ */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/tramp.c kernel-power-2.6.28.new/drivers/dsp/bridge/dynload/tramp.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/tramp.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/dynload/tramp.c	2011-10-23 08:22:37.613570000 +0100
@@ -0,0 +1,1143 @@
+/*
+ * tramp.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include "header.h"
+
+#if TMS32060
+#include "tramp_table_c6000.c"
+#endif
+
+#define MAX_RELOS_PER_PASS	4
+
+/*
+ * Function:	priv_tramp_sect_tgt_alloc
+ * Description: Allocate target memory for the trampoline section.  The
+ *	  target mem size is easily obtained as the next available address.
+ */
+static int priv_tramp_sect_tgt_alloc(struct dload_state *dlthis)
+{
+	int ret_val = 0;
+	struct ldr_section_info *sect_info;
+
+	/*  Populate the trampoline loader section and allocate it on the
+	 * target.  The section name is ALWAYS the first string in the final
+	 * string table for trampolines.  The trampoline section is always
+	 * 1 beyond the total number of allocated sections. */
+	sect_info = &dlthis->ldr_sections[dlthis->allocated_secn_count];
+
+	sect_info->name = dlthis->tramp.final_string_table;
+	sect_info->size = dlthis->tramp.tramp_sect_next_addr;
+	sect_info->context = 0;
+	sect_info->type =
+	    (4 << 8) | DLOAD_TEXT | DS_ALLOCATE_MASK | DS_DOWNLOAD_MASK;
+	sect_info->page = 0;
+	sect_info->run_addr = 0;
+	sect_info->load_addr = 0;
+	ret_val = dlthis->myalloc->dload_allocate(dlthis->myalloc,
+						  sect_info,
+						  DS_ALIGNMENT
+						  (sect_info->type));
+
+	if (ret_val == 0)
+		dload_error(dlthis, "Failed to allocate target memory for"
+			    " trampoline");
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_h2a
+ * Description: Helper function to convert a hex value to its ASCII
+ *	  representation.  Used for trampoline symbol name generation.
+ */
+static u8 priv_h2a(u8 value)
+{
+	if (value > 0xF)
+		return 0xFF;
+
+	if (value <= 9)
+		value += 0x30;
+	else
+		value += 0x37;
+
+	return value;
+}
+
+/*
+ * Function:	priv_tramp_sym_gen_name
+ * Description: Generate a trampoline symbol name (ASCII) using the value
+ *	  of the symbol.  This places the new name into the user buffer.
+ *	  The name is fixed in length and of the form: __$dbTR__xxxxxxxx
+ *	  (where "xxxxxxxx" is the hex value.
+ */
+static void priv_tramp_sym_gen_name(u32 value, char *dst)
+{
+	u32 i;
+	volatile char *prefix = TRAMP_SYM_PREFIX;
+	volatile char *dst_local = dst;
+	u8 tmp;
+
+	/*  Clear out the destination, including the ending NULL */
+	for (i = 0; i < (TRAMP_SYM_PREFIX_LEN + TRAMP_SYM_HEX_ASCII_LEN); i++)
+		*(dst_local + i) = 0;
+
+	/*  Copy the prefix to start */
+	for (i = 0; i < strlen(TRAMP_SYM_PREFIX); i++) {
+		*dst_local = *(prefix + i);
+		dst_local++;
+	}
+
+	/*  Now convert the value passed in to a string equiv of the hex */
+	for (i = 0; i < sizeof(value); i++) {
+#ifndef _BIG_ENDIAN
+		tmp = *(((u8 *) &value) + (sizeof(value) - 1) - i);
+		*dst_local = priv_h2a((tmp & 0xF0) >> 4);
+		dst_local++;
+		*dst_local = priv_h2a(tmp & 0x0F);
+		dst_local++;
+#else
+		tmp = *(((u8 *) &value) + i);
+		*dst_local = priv_h2a((tmp & 0xF0) >> 4);
+		dst_local++;
+		*dst_local = priv_h2a(tmp & 0x0F);
+		dst_local++;
+#endif
+	}
+
+	/*  NULL terminate */
+	*dst_local = 0;
+}
+
+/*
+ * Function:	priv_tramp_string_create
+ * Description: Create a new string specific to the trampoline loading and add
+ *	  it to the trampoline string list.  This list contains the
+ *	  trampoline section name and trampoline point symbols.
+ */
+static struct tramp_string *priv_tramp_string_create(struct dload_state *dlthis,
+						     u32 str_len, char *str)
+{
+	struct tramp_string *new_string = NULL;
+	u32 i;
+
+	/*  Create a new string object with the specified size. */
+	new_string =
+	    (struct tramp_string *)dlthis->mysym->dload_allocate(dlthis->mysym,
+								 (sizeof
+								  (struct
+								   tramp_string)
+								  + str_len +
+								  1));
+	if (new_string != NULL) {
+		/*  Clear the string first.  This ensures the ending NULL is
+		 * present and the optimizer won't touch it. */
+		for (i = 0; i < (sizeof(struct tramp_string) + str_len + 1);
+		     i++)
+			*((u8 *) new_string + i) = 0;
+
+		/*  Add this string to our virtual table by assigning it the
+		 * next index and pushing it to the tail of the list. */
+		new_string->index = dlthis->tramp.tramp_string_next_index;
+		dlthis->tramp.tramp_string_next_index++;
+		dlthis->tramp.tramp_string_size += str_len + 1;
+
+		new_string->next = NULL;
+		if (dlthis->tramp.string_head == NULL)
+			dlthis->tramp.string_head = new_string;
+		else
+			dlthis->tramp.string_tail->next = new_string;
+
+		dlthis->tramp.string_tail = new_string;
+
+		/*  Copy the string over to the new object */
+		for (i = 0; i < str_len; i++)
+			new_string->str[i] = str[i];
+	}
+
+	return new_string;
+}
+
+/*
+ * Function:	priv_tramp_string_find
+ * Description: Walk the trampoline string list and find a match for the
+ *	  provided string.  If not match is found, NULL is returned.
+ */
+static struct tramp_string *priv_tramp_string_find(struct dload_state *dlthis,
+						   char *str)
+{
+	struct tramp_string *cur_str = NULL;
+	struct tramp_string *ret_val = NULL;
+	u32 i;
+	u32 str_len = strlen(str);
+
+	for (cur_str = dlthis->tramp.string_head;
+	     (ret_val == NULL) && (cur_str != NULL); cur_str = cur_str->next) {
+		/*  If the string lengths aren't equal, don't bother
+		 * comparing */
+		if (str_len != strlen(cur_str->str))
+			continue;
+
+		/*  Walk the strings until one of them ends */
+		for (i = 0; i < str_len; i++) {
+			/*  If they don't match in the current position then
+			 * break out now, no sense in continuing to look at
+			 * this string. */
+			if (str[i] != cur_str->str[i])
+				break;
+		}
+
+		if (i == str_len)
+			ret_val = cur_str;
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_string_tbl_finalize
+ * Description: Flatten the trampoline string list into a table of NULL
+ *	  terminated strings.  This is the same format of string table
+ *	  as used by the COFF/DOFF file.
+ */
+static int priv_string_tbl_finalize(struct dload_state *dlthis)
+{
+	int ret_val = 0;
+	struct tramp_string *cur_string;
+	char *cur_loc;
+	char *tmp;
+
+	/*  Allocate enough space for all strings that have been created.  The
+	 * table is simply all strings concatenated together will NULL
+	 * endings. */
+	dlthis->tramp.final_string_table =
+	    (char *)dlthis->mysym->dload_allocate(dlthis->mysym,
+						  dlthis->tramp.
+						  tramp_string_size);
+	if (dlthis->tramp.final_string_table != NULL) {
+		/*  We got our buffer, walk the list and release the nodes as*
+		 * we go */
+		cur_loc = dlthis->tramp.final_string_table;
+		cur_string = dlthis->tramp.string_head;
+		while (cur_string != NULL) {
+			/*  Move the head/tail pointers */
+			dlthis->tramp.string_head = cur_string->next;
+			if (dlthis->tramp.string_tail == cur_string)
+				dlthis->tramp.string_tail = NULL;
+
+			/*  Copy the string contents */
+			for (tmp = cur_string->str;
+			     *tmp != '\0'; tmp++, cur_loc++)
+				*cur_loc = *tmp;
+
+			/*  Pick up the NULL termination since it was missed by
+			 * breaking using it to end the above loop. */
+			*cur_loc = '\0';
+			cur_loc++;
+
+			/*  Free the string node, we don't need it any more. */
+			dlthis->mysym->dload_deallocate(dlthis->mysym,
+							cur_string);
+
+			/*  Move our pointer to the next one */
+			cur_string = dlthis->tramp.string_head;
+		}
+
+		/*  Update our return value to success */
+		ret_val = 1;
+	} else
+		dload_error(dlthis, "Failed to allocate trampoline "
+			    "string table");
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_tramp_sect_alloc
+ * Description: Virtually allocate space from the trampoline section.  This
+ *	  function returns the next offset within the trampoline section
+ *	  that is available and moved the next available offset by the
+ *	  requested size.  NO TARGET ALLOCATION IS DONE AT THIS TIME.
+ */
+static u32 priv_tramp_sect_alloc(struct dload_state *dlthis, u32 tramp_size)
+{
+	u32 ret_val;
+
+	/*  If the next available address is 0, this is our first allocation.
+	 * Create a section name string to go into the string table . */
+	if (dlthis->tramp.tramp_sect_next_addr == 0) {
+		dload_syms_error(dlthis->mysym, "*** WARNING ***  created "
+				 "dynamic TRAMPOLINE section for module %s",
+				 dlthis->str_head);
+	}
+
+	/*  Reserve space for the new trampoline */
+	ret_val = dlthis->tramp.tramp_sect_next_addr;
+	dlthis->tramp.tramp_sect_next_addr += tramp_size;
+	return ret_val;
+}
+
+/*
+ * Function:	priv_tramp_sym_create
+ * Description: Allocate and create a new trampoline specific symbol and add
+ *	  it to the trampoline symbol list.  These symbols will include
+ *	  trampoline points as well as the external symbols they
+ *	  reference.
+ */
+static struct tramp_sym *priv_tramp_sym_create(struct dload_state *dlthis,
+					       u32 str_index,
+					       struct local_symbol *tmp_sym)
+{
+	struct tramp_sym *new_sym = NULL;
+	u32 i;
+
+	/*  Allocate new space for the symbol in the symbol table. */
+	new_sym =
+	    (struct tramp_sym *)dlthis->mysym->dload_allocate(dlthis->mysym,
+					      sizeof(struct tramp_sym));
+	if (new_sym != NULL) {
+		for (i = 0; i != sizeof(struct tramp_sym); i++)
+			*((char *)new_sym + i) = 0;
+
+		/*  Assign this symbol the next symbol index for easier
+		 * reference later during relocation. */
+		new_sym->index = dlthis->tramp.tramp_sym_next_index;
+		dlthis->tramp.tramp_sym_next_index++;
+
+		/*  Populate the symbol information.  At this point any
+		 * trampoline symbols will be the offset location, not the
+		 * final.  Copy over the symbol info to start, then be sure to
+		 * get the string index from the trampoline string table. */
+		new_sym->sym_info = *tmp_sym;
+		new_sym->str_index = str_index;
+
+		/*  Push the new symbol to the tail of the symbol table list */
+		new_sym->next = NULL;
+		if (dlthis->tramp.symbol_head == NULL)
+			dlthis->tramp.symbol_head = new_sym;
+		else
+			dlthis->tramp.symbol_tail->next = new_sym;
+
+		dlthis->tramp.symbol_tail = new_sym;
+	}
+
+	return new_sym;
+}
+
+/*
+ * Function:	priv_tramp_sym_get
+ * Description: Search for the symbol with the matching string index (from
+ *	  the trampoline string table) and return the trampoline
+ *	  symbol object, if found.  Otherwise return NULL.
+ */
+static struct tramp_sym *priv_tramp_sym_get(struct dload_state *dlthis,
+					    u32 string_index)
+{
+	struct tramp_sym *sym_found = NULL;
+
+	/*  Walk the symbol table list and search vs. the string index */
+	for (sym_found = dlthis->tramp.symbol_head;
+	     sym_found != NULL; sym_found = sym_found->next) {
+		if (sym_found->str_index == string_index)
+			break;
+	}
+
+	return sym_found;
+}
+
+/*
+ * Function:	priv_tramp_sym_find
+ * Description: Search for a trampoline symbol based on the string name of
+ *	  the symbol.  Return the symbol object, if found, otherwise
+ *	  return NULL.
+ */
+static struct tramp_sym *priv_tramp_sym_find(struct dload_state *dlthis,
+					     char *string)
+{
+	struct tramp_sym *sym_found = NULL;
+	struct tramp_string *str_found = NULL;
+
+	/*  First, search for the string, then search for the sym based on the
+	   string index. */
+	str_found = priv_tramp_string_find(dlthis, string);
+	if (str_found != NULL)
+		sym_found = priv_tramp_sym_get(dlthis, str_found->index);
+
+	return sym_found;
+}
+
+/*
+ * Function:	priv_tramp_sym_finalize
+ * Description: Allocate a flat symbol table for the trampoline section,
+ *	  put each trampoline symbol into the table, adjust the
+ *	  symbol value based on the section address on the target and
+ *	  free the trampoline symbol list nodes.
+ */
+static int priv_tramp_sym_finalize(struct dload_state *dlthis)
+{
+	int ret_val = 0;
+	struct tramp_sym *cur_sym;
+	struct ldr_section_info *tramp_sect =
+	    &dlthis->ldr_sections[dlthis->allocated_secn_count];
+	struct local_symbol *new_sym;
+
+	/*  Allocate a table to hold a flattened version of all symbols
+	 * created. */
+	dlthis->tramp.final_sym_table =
+	    (struct local_symbol *)dlthis->mysym->dload_allocate(dlthis->mysym,
+				 (sizeof(struct local_symbol) * dlthis->tramp.
+						  tramp_sym_next_index));
+	if (dlthis->tramp.final_sym_table != NULL) {
+		/*  Walk the list of all symbols, copy it over to the flattened
+		 * table. After it has been copied, the node can be freed as
+		 * it is no longer needed. */
+		new_sym = dlthis->tramp.final_sym_table;
+		cur_sym = dlthis->tramp.symbol_head;
+		while (cur_sym != NULL) {
+			/*  Pop it off the list */
+			dlthis->tramp.symbol_head = cur_sym->next;
+			if (cur_sym == dlthis->tramp.symbol_tail)
+				dlthis->tramp.symbol_tail = NULL;
+
+			/*  Copy the symbol contents into the flat table */
+			*new_sym = cur_sym->sym_info;
+
+			/*  Now finaize the symbol.  If it is in the tramp
+			 * section, we need to adjust for the section start.
+			 * If it is external then we don't need to adjust at
+			 * all.
+			 * NOTE: THIS CODE ASSUMES THAT THE TRAMPOLINE IS
+			 * REFERENCED LIKE A CALL TO AN EXTERNAL SO VALUE AND
+			 * DELTA ARE THE SAME.  SEE THE FUNCTION dload_symbols
+			 * WHERE DN_UNDEF IS HANDLED FOR MORE REFERENCE. */
+			if (new_sym->secnn < 0) {
+				new_sym->value += tramp_sect->load_addr;
+				new_sym->delta = new_sym->value;
+			}
+
+			/*  Let go of the symbol node */
+			dlthis->mysym->dload_deallocate(dlthis->mysym, cur_sym);
+
+			/*  Move to the next node */
+			cur_sym = dlthis->tramp.symbol_head;
+			new_sym++;
+		}
+
+		ret_val = 1;
+	} else
+		dload_error(dlthis, "Failed to alloc trampoline sym table");
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_tgt_img_gen
+ * Description: Allocate storage for and copy the target specific image data
+ *	and fix up its relocations for the new external symbol.  If
+ *	a trampoline image packet was successfully created it is added
+ *	to the trampoline list.
+ */
+static int priv_tgt_img_gen(struct dload_state *dlthis, u32 base,
+			    u32 gen_index, struct tramp_sym *new_ext_sym)
+{
+	struct tramp_img_pkt *new_img_pkt = NULL;
+	u32 i;
+	u32 pkt_size = tramp_img_pkt_size_get();
+	u8 *gen_tbl_entry;
+	u8 *pkt_data;
+	struct reloc_record_t *cur_relo;
+	int ret_val = 0;
+
+	/*  Allocate a new image packet and set it up. */
+	new_img_pkt =
+	    (struct tramp_img_pkt *)dlthis->mysym->dload_allocate(dlthis->mysym,
+								  pkt_size);
+	if (new_img_pkt != NULL) {
+		/*  Save the base, this is where it goes in the section */
+		new_img_pkt->base = base;
+
+		/*  Copy over the image data and relos from the target table */
+		pkt_data = (u8 *) &new_img_pkt->hdr;
+		gen_tbl_entry = (u8 *) &tramp_gen_info[gen_index];
+		for (i = 0; i < pkt_size; i++) {
+			*pkt_data = *gen_tbl_entry;
+			pkt_data++;
+			gen_tbl_entry++;
+		}
+
+		/*  Update the relocations to point to the external symbol */
+		cur_relo =
+		    (struct reloc_record_t *)((u8 *) &new_img_pkt->hdr +
+					      new_img_pkt->hdr.relo_offset);
+		for (i = 0; i < new_img_pkt->hdr.num_relos; i++)
+			cur_relo[i].SYMNDX = new_ext_sym->index;
+
+		/*  Add it to the trampoline list. */
+		new_img_pkt->next = dlthis->tramp.tramp_pkts;
+		dlthis->tramp.tramp_pkts = new_img_pkt;
+
+		ret_val = 1;
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_pkt_relo
+ * Description: Take the provided image data and the collection of relocations
+ *	  for it and perform the relocations.  Note that all relocations
+ *	  at this stage are considered SECOND PASS since the original
+ *	  image has already been processed in the first pass.  This means
+ *	  TRAMPOLINES ARE TREATED AS 2ND PASS even though this is really
+ *	  the first (and only) relocation that will be performed on them.
+ */
+static int priv_pkt_relo(struct dload_state *dlthis, tgt_au_t * data,
+			 struct reloc_record_t *rp[], u32 relo_count)
+{
+	int ret_val = 1;
+	u32 i;
+	bool tmp;
+
+	/*  Walk through all of the relos and process them.  This function is
+	 * the equivalent of relocate_packet() from cload.c, but specialized
+	 * for trampolines and 2nd phase relocations. */
+	for (i = 0; i < relo_count; i++)
+		dload_relocate(dlthis, data, rp[i], &tmp, true);
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_tramp_pkt_finalize
+ * Description: Walk the list of all trampoline packets and finalize them.
+ *	  Each trampoline image packet will be relocated now that the
+ *	  trampoline section has been allocated on the target.  Once
+ *	  all of the relocations are done the trampoline image data
+ *	  is written into target memory and the trampoline packet
+ *	  is freed: it is no longer needed after this point.
+ */
+static int priv_tramp_pkt_finalize(struct dload_state *dlthis)
+{
+	int ret_val = 1;
+	struct tramp_img_pkt *cur_pkt = NULL;
+	struct reloc_record_t *relos[MAX_RELOS_PER_PASS];
+	u32 relos_done;
+	u32 i;
+	struct reloc_record_t *cur_relo;
+	struct ldr_section_info *sect_info =
+	    &dlthis->ldr_sections[dlthis->allocated_secn_count];
+
+	/*  Walk the list of trampoline packets and relocate each packet.  This
+	 * function is the trampoline equivalent of dload_data() from
+	 * cload.c. */
+	cur_pkt = dlthis->tramp.tramp_pkts;
+	while ((ret_val != 0) && (cur_pkt != NULL)) {
+		/*  Remove the pkt from the list */
+		dlthis->tramp.tramp_pkts = cur_pkt->next;
+
+		/*  Setup section and image offset information for the relo */
+		dlthis->image_secn = sect_info;
+		dlthis->image_offset = cur_pkt->base;
+		dlthis->delta_runaddr = sect_info->run_addr;
+
+		/*  Walk through all relos for the packet */
+		relos_done = 0;
+		cur_relo = (struct reloc_record_t *)((u8 *) &cur_pkt->hdr +
+						     cur_pkt->hdr.relo_offset);
+		while (relos_done < cur_pkt->hdr.num_relos) {
+#ifdef ENABLE_TRAMP_DEBUG
+			dload_syms_error(dlthis->mysym,
+					 "===> Trampoline %x branches to %x",
+					 sect_info->run_addr +
+					 dlthis->image_offset,
+					 dlthis->
+					 tramp.final_sym_table[cur_relo->
+							       SYMNDX].value);
+#endif
+
+			for (i = 0;
+			     ((i < MAX_RELOS_PER_PASS) &&
+			      ((i + relos_done) < cur_pkt->hdr.num_relos)); i++)
+				relos[i] = cur_relo + i;
+
+			/*  Do the actual relo */
+			ret_val = priv_pkt_relo(dlthis,
+						(tgt_au_t *) &cur_pkt->payload,
+						relos, i);
+			if (ret_val == 0) {
+				dload_error(dlthis,
+					    "Relocation of trampoline pkt at %x"
+					    " failed", cur_pkt->base +
+					    sect_info->run_addr);
+				break;
+			}
+
+			relos_done += i;
+			cur_relo += i;
+		}
+
+		/*  Make sure we didn't hit a problem */
+		if (ret_val != 0) {
+			/*  Relos are done for the packet, write it to the
+			 * target */
+			ret_val = dlthis->myio->writemem(dlthis->myio,
+							 &cur_pkt->payload,
+							 sect_info->load_addr +
+							 cur_pkt->base,
+							 sect_info,
+							 BYTE_TO_HOST
+							 (cur_pkt->hdr.
+							  tramp_code_size));
+			if (ret_val == 0) {
+				dload_error(dlthis,
+					    "Write to " FMT_UI32 " failed",
+					    sect_info->load_addr +
+					    cur_pkt->base);
+			}
+
+			/*  Done with the pkt, let it go */
+			dlthis->mysym->dload_deallocate(dlthis->mysym, cur_pkt);
+
+			/*  Get the next packet to process */
+			cur_pkt = dlthis->tramp.tramp_pkts;
+		}
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_dup_pkt_finalize
+ * Description: Walk the list of duplicate image packets and finalize them.
+ *	  Each duplicate packet will be relocated again for the
+ *	  relocations that previously failed and have been adjusted
+ *	  to point at a trampoline.  Once all relocations for a packet
+ *	  have been done, write the packet into target memory.  The
+ *	  duplicate packet and its relocation chain are all freed
+ *	  after use here as they are no longer needed after this.
+ */
+static int priv_dup_pkt_finalize(struct dload_state *dlthis)
+{
+	int ret_val = 1;
+	struct tramp_img_dup_pkt *cur_pkt;
+	struct tramp_img_dup_relo *cur_relo;
+	struct reloc_record_t *relos[MAX_RELOS_PER_PASS];
+	struct doff_scnhdr_t *sect_hdr = NULL;
+	s32 i;
+
+	/* Similar to the trampoline pkt finalize, this function walks each dup
+	 * pkt that was generated and performs all relocations that were
+	 * deferred to a 2nd pass.  This is the equivalent of dload_data() from
+	 * cload.c, but does not need the additional reorder and checksum
+	 * processing as it has already been done. */
+	cur_pkt = dlthis->tramp.dup_pkts;
+	while ((ret_val != 0) && (cur_pkt != NULL)) {
+		/*  Remove the node from the list, we'll be freeing it
+		 * shortly */
+		dlthis->tramp.dup_pkts = cur_pkt->next;
+
+		/*  Setup the section and image offset for relocation */
+		dlthis->image_secn = &dlthis->ldr_sections[cur_pkt->secnn];
+		dlthis->image_offset = cur_pkt->offset;
+
+		/*  In order to get the delta run address, we need to reference
+		 * the original section header.  It's a bit ugly, but needed
+		 * for relo. */
+		i = (s32) (dlthis->image_secn - dlthis->ldr_sections);
+		sect_hdr = dlthis->sect_hdrs + i;
+		dlthis->delta_runaddr = sect_hdr->ds_paddr;
+
+		/*  Walk all relos in the chain and process each. */
+		cur_relo = cur_pkt->relo_chain;
+		while (cur_relo != NULL) {
+			/*  Process them a chunk at a time to be efficient */
+			for (i = 0; (i < MAX_RELOS_PER_PASS)
+			     && (cur_relo != NULL);
+			     i++, cur_relo = cur_relo->next) {
+				relos[i] = &cur_relo->relo;
+				cur_pkt->relo_chain = cur_relo->next;
+			}
+
+			/*  Do the actual relo */
+			ret_val = priv_pkt_relo(dlthis,
+						cur_pkt->img_pkt.img_data,
+						relos, i);
+			if (ret_val == 0) {
+				dload_error(dlthis,
+					    "Relocation of dup pkt at %x"
+					    " failed", cur_pkt->offset +
+					    dlthis->image_secn->run_addr);
+				break;
+			}
+
+			/*  Release all of these relos, we're done with them */
+			while (i > 0) {
+				dlthis->mysym->dload_deallocate(dlthis->mysym,
+						GET_CONTAINER
+						(relos[i - 1],
+						 struct tramp_img_dup_relo,
+						 relo));
+				i--;
+			}
+
+			/*  DO NOT ADVANCE cur_relo, IT IS ALREADY READY TO
+			 * GO! */
+		}
+
+		/* Done with all relos.  Make sure we didn't have a problem and
+		 * write it out to the target */
+		if (ret_val != 0) {
+			ret_val = dlthis->myio->writemem(dlthis->myio,
+							 cur_pkt->img_pkt.
+							 img_data,
+							 dlthis->image_secn->
+							 load_addr +
+							 cur_pkt->offset,
+							 dlthis->image_secn,
+							 BYTE_TO_HOST
+							 (cur_pkt->img_pkt.
+							  packet_size));
+			if (ret_val == 0) {
+				dload_error(dlthis,
+					    "Write to " FMT_UI32 " failed",
+					    dlthis->image_secn->load_addr +
+					    cur_pkt->offset);
+			}
+
+			dlthis->mysym->dload_deallocate(dlthis->mysym, cur_pkt);
+
+			/*  Advance to the next packet */
+			cur_pkt = dlthis->tramp.dup_pkts;
+		}
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_dup_find
+ * Description: Walk the list of existing duplicate packets and find a
+ *	  match based on the section number and image offset.  Return
+ *	  the duplicate packet if found, otherwise NULL.
+ */
+static struct tramp_img_dup_pkt *priv_dup_find(struct dload_state *dlthis,
+					       s16 secnn, u32 image_offset)
+{
+	struct tramp_img_dup_pkt *cur_pkt = NULL;
+
+	for (cur_pkt = dlthis->tramp.dup_pkts;
+	     cur_pkt != NULL; cur_pkt = cur_pkt->next) {
+		if ((cur_pkt->secnn == secnn) &&
+		    (cur_pkt->offset == image_offset)) {
+			/*  Found a match, break out */
+			break;
+		}
+	}
+
+	return cur_pkt;
+}
+
+/*
+ * Function:	priv_img_pkt_dup
+ * Description: Duplicate the original image packet.  If this is the first
+ *	  time this image packet has been seen (based on section number
+ *	  and image offset), create a new duplicate packet and add it
+ *	  to the dup packet list.  If not, just get the existing one and
+ *	  update it with the current packet contents (since relocation
+ *	  on the packet is still ongoing in first pass.)  Create a
+ *	  duplicate of the provided relocation, but update it to point
+ *	  to the new trampoline symbol.  Add the new relocation dup to
+ *	  the dup packet's relo chain for 2nd pass relocation later.
+ */
+static int priv_img_pkt_dup(struct dload_state *dlthis,
+			    s16 secnn, u32 image_offset,
+			    struct image_packet_t *ipacket,
+			    struct reloc_record_t *rp,
+			    struct tramp_sym *new_tramp_sym)
+{
+	struct tramp_img_dup_pkt *dup_pkt = NULL;
+	u32 new_dup_size;
+	s32 i;
+	int ret_val = 0;
+	struct tramp_img_dup_relo *dup_relo = NULL;
+
+	/*  Determinne if this image packet is already being tracked in the
+	   dup list for other trampolines. */
+	dup_pkt = priv_dup_find(dlthis, secnn, image_offset);
+
+	if (dup_pkt == NULL) {
+		/*  This image packet does not exist in our tracking, so create
+		 * a new one and add it to the head of the list. */
+		new_dup_size = sizeof(struct tramp_img_dup_pkt) +
+		    ipacket->packet_size;
+
+		dup_pkt = (struct tramp_img_dup_pkt *)
+		    dlthis->mysym->dload_allocate(dlthis->mysym, new_dup_size);
+		if (dup_pkt != NULL) {
+			/*  Save off the section and offset information */
+			dup_pkt->secnn = secnn;
+			dup_pkt->offset = image_offset;
+			dup_pkt->relo_chain = NULL;
+
+			/*  Copy the original packet content */
+			dup_pkt->img_pkt = *ipacket;
+			dup_pkt->img_pkt.img_data = (u8 *) (dup_pkt + 1);
+			for (i = 0; i < ipacket->packet_size; i++)
+				*(dup_pkt->img_pkt.img_data + i) =
+				    *(ipacket->img_data + i);
+
+			/*  Add the packet to the dup list */
+			dup_pkt->next = dlthis->tramp.dup_pkts;
+			dlthis->tramp.dup_pkts = dup_pkt;
+		} else
+			dload_error(dlthis, "Failed to create dup packet!");
+	} else {
+		/*  The image packet contents could have changed since
+		 * trampoline detection happens during relocation of the image
+		 * packets.  So, we need to update the image packet contents
+		 * before adding relo information. */
+		for (i = 0; i < dup_pkt->img_pkt.packet_size; i++)
+			*(dup_pkt->img_pkt.img_data + i) =
+			    *(ipacket->img_data + i);
+	}
+
+	/*  Since the previous code may have allocated a new dup packet for us,
+	   double check that we actually have one. */
+	if (dup_pkt != NULL) {
+		/*  Allocate a new node for the relo chain.  Each image packet
+		 * can potentially have multiple relocations that cause a
+		 * trampoline to be generated.  So, we keep them in a chain,
+		 * order is not important. */
+		dup_relo = dlthis->mysym->dload_allocate(dlthis->mysym,
+					 sizeof(struct tramp_img_dup_relo));
+		if (dup_relo != NULL) {
+			/*  Copy the relo contents, adjust for the new
+			 * trampoline and add it to the list. */
+			dup_relo->relo = *rp;
+			dup_relo->relo.SYMNDX = new_tramp_sym->index;
+
+			dup_relo->next = dup_pkt->relo_chain;
+			dup_pkt->relo_chain = dup_relo;
+
+			/*  That's it, we're done.  Make sure we update our
+			 * return value to be success since everything finished
+			 * ok */
+			ret_val = 1;
+		} else
+			dload_error(dlthis, "Unable to alloc dup relo");
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	dload_tramp_avail
+ * Description: Check to see if the target supports a trampoline for this type
+ *	  of relocation.  Return true if it does, otherwise false.
+ */
+bool dload_tramp_avail(struct dload_state *dlthis, struct reloc_record_t *rp)
+{
+	bool ret_val = false;
+	u16 map_index;
+	u16 gen_index;
+
+	/*  Check type hash vs. target tramp table */
+	map_index = HASH_FUNC(rp->TYPE);
+	gen_index = tramp_map[map_index];
+	if (gen_index != TRAMP_NO_GEN_AVAIL)
+		ret_val = true;
+
+	return ret_val;
+}
+
+/*
+ * Function:	dload_tramp_generate
+ * Description: Create a new trampoline for the provided image packet and
+ *	  relocation causing problems.  This will create the trampoline
+ *	  as well as duplicate/update the image packet and relocation
+ *	  causing the problem, which will be relo'd again during
+ *	  finalization.
+ */
+int dload_tramp_generate(struct dload_state *dlthis, s16 secnn,
+			 u32 image_offset, struct image_packet_t *ipacket,
+			 struct reloc_record_t *rp)
+{
+	u16 map_index;
+	u16 gen_index;
+	int ret_val = 1;
+	char tramp_sym_str[TRAMP_SYM_PREFIX_LEN + TRAMP_SYM_HEX_ASCII_LEN];
+	struct local_symbol *ref_sym;
+	struct tramp_sym *new_tramp_sym;
+	struct tramp_sym *new_ext_sym;
+	struct tramp_string *new_tramp_str;
+	u32 new_tramp_base;
+	struct local_symbol tmp_sym;
+	struct local_symbol ext_tmp_sym;
+
+	/*  Hash the relo type to get our generator information */
+	map_index = HASH_FUNC(rp->TYPE);
+	gen_index = tramp_map[map_index];
+	if (gen_index != TRAMP_NO_GEN_AVAIL) {
+		/*  If this is the first trampoline, create the section name in
+		 * our string table for debug help later. */
+		if (dlthis->tramp.string_head == NULL) {
+			priv_tramp_string_create(dlthis,
+						 strlen(TRAMP_SECT_NAME),
+						 TRAMP_SECT_NAME);
+		}
+#ifdef ENABLE_TRAMP_DEBUG
+		dload_syms_error(dlthis->mysym,
+				 "Trampoline at img loc %x, references %x",
+				 dlthis->ldr_sections[secnn].run_addr +
+				 image_offset + rp->vaddr,
+				 dlthis->local_symtab[rp->SYMNDX].value);
+#endif
+
+		/*  Generate the trampoline string, check if already defined.
+		 * If the relo symbol index is -1, it means we need the section
+		 * info for relo later.  To do this we'll dummy up a symbol
+		 * with the section delta and run addresses. */
+		if (rp->SYMNDX == -1) {
+			ext_tmp_sym.value =
+			    dlthis->ldr_sections[secnn].run_addr;
+			ext_tmp_sym.delta = dlthis->sect_hdrs[secnn].ds_paddr;
+			ref_sym = &ext_tmp_sym;
+		} else
+			ref_sym = &(dlthis->local_symtab[rp->SYMNDX]);
+
+		priv_tramp_sym_gen_name(ref_sym->value, tramp_sym_str);
+		new_tramp_sym = priv_tramp_sym_find(dlthis, tramp_sym_str);
+		if (new_tramp_sym == NULL) {
+			/*  If tramp string not defined, create it and a new
+			 * string, and symbol for it as well as the original
+			 * symbol which caused the trampoline. */
+			new_tramp_str = priv_tramp_string_create(dlthis,
+								strlen
+								(tramp_sym_str),
+								 tramp_sym_str);
+			if (new_tramp_str == NULL) {
+				dload_error(dlthis, "Failed to create new "
+					    "trampoline string\n");
+				ret_val = 0;
+			} else {
+				/*  Allocate tramp section space for the new
+				 * tramp from the target */
+				new_tramp_base = priv_tramp_sect_alloc(dlthis,
+						       tramp_size_get());
+
+				/*  We have a string, create the new symbol and
+				 * duplicate the external. */
+				tmp_sym.value = new_tramp_base;
+				tmp_sym.delta = 0;
+				tmp_sym.secnn = -1;
+				tmp_sym.sclass = 0;
+				new_tramp_sym = priv_tramp_sym_create(dlthis,
+							      new_tramp_str->
+							      index,
+							      &tmp_sym);
+
+				new_ext_sym = priv_tramp_sym_create(dlthis, -1,
+								    ref_sym);
+
+				if ((new_tramp_sym != NULL) &&
+				    (new_ext_sym != NULL)) {
+					/*  Call the image generator to get the
+					 * new image data and fix up its
+					 * relocations for the external
+					 * symbol. */
+					ret_val = priv_tgt_img_gen(dlthis,
+								 new_tramp_base,
+								 gen_index,
+								 new_ext_sym);
+
+					/*  Add generated image data to tramp
+					 * image list */
+					if (ret_val != 1) {
+						dload_error(dlthis, "Failed to "
+							    "create img pkt for"
+							    " trampoline\n");
+					}
+				} else {
+					dload_error(dlthis, "Failed to create "
+						    "new tramp syms "
+						    "(%8.8X, %8.8X)\n",
+						    new_tramp_sym, new_ext_sym);
+					ret_val = 0;
+				}
+			}
+		}
+
+		/*  Duplicate the image data and relo record that caused the
+		 * tramp, including update the relo data to point to the tramp
+		 * symbol. */
+		if (ret_val == 1) {
+			ret_val = priv_img_pkt_dup(dlthis, secnn, image_offset,
+						   ipacket, rp, new_tramp_sym);
+			if (ret_val != 1) {
+				dload_error(dlthis, "Failed to create dup of "
+					    "original img pkt\n");
+			}
+		}
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	dload_tramp_pkt_update
+ * Description: Update the duplicate copy of this image packet, which the
+ *	  trampoline layer is already tracking.  This is call is critical
+ *	  to make if trampolines were generated anywhere within the
+ *	  packet and first pass relo continued on the remainder.  The
+ *	  trampoline layer needs the updates image data so when 2nd
+ *	  pass relo is done during finalize the image packet can be
+ *	  written to the target since all relo is done.
+ */
+int dload_tramp_pkt_udpate(struct dload_state *dlthis, s16 secnn,
+			   u32 image_offset, struct image_packet_t *ipacket)
+{
+	struct tramp_img_dup_pkt *dup_pkt = NULL;
+	s32 i;
+	int ret_val = 0;
+
+	/*  Find the image packet in question, the caller needs us to update it
+	   since a trampoline was previously generated. */
+	dup_pkt = priv_dup_find(dlthis, secnn, image_offset);
+	if (dup_pkt != NULL) {
+		for (i = 0; i < dup_pkt->img_pkt.packet_size; i++)
+			*(dup_pkt->img_pkt.img_data + i) =
+			    *(ipacket->img_data + i);
+
+		ret_val = 1;
+	} else {
+		dload_error(dlthis,
+			    "Unable to find existing DUP pkt for %x, offset %x",
+			    secnn, image_offset);
+
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	dload_tramp_finalize
+ * Description: If any trampolines were created, finalize everything on the
+ *	  target by allocating the trampoline section on the target,
+ *	  finalizing the trampoline symbols, finalizing the trampoline
+ *	  packets (write the new section to target memory) and finalize
+ *	  the duplicate packets by doing 2nd pass relo over them.
+ */
+int dload_tramp_finalize(struct dload_state *dlthis)
+{
+	int ret_val = 1;
+
+	if (dlthis->tramp.tramp_sect_next_addr != 0) {
+		/*  Finalize strings into a flat table.  This is needed so it
+		 * can be added to the debug string table later. */
+		ret_val = priv_string_tbl_finalize(dlthis);
+
+		/*  Do target allocation for section BEFORE finalizing
+		 * symbols. */
+		if (ret_val != 0)
+			ret_val = priv_tramp_sect_tgt_alloc(dlthis);
+
+		/*  Finalize symbols with their correct target information and
+		 * flatten */
+		if (ret_val != 0)
+			ret_val = priv_tramp_sym_finalize(dlthis);
+
+		/*  Finalize all trampoline packets.  This performs the
+		 * relocation on the packets as well as writing them to target
+		 * memory. */
+		if (ret_val != 0)
+			ret_val = priv_tramp_pkt_finalize(dlthis);
+
+		/*  Perform a 2nd pass relocation on the dup list. */
+		if (ret_val != 0)
+			ret_val = priv_dup_pkt_finalize(dlthis);
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	dload_tramp_cleanup
+ * Description: Release all temporary resources used in the trampoline layer.
+ *	  Note that the target memory which may have been allocated and
+ *	  written to store the trampolines is NOT RELEASED HERE since it
+ *	  is potentially still in use.  It is automatically released
+ *	  when the module is unloaded.
+ */
+void dload_tramp_cleanup(struct dload_state *dlthis)
+{
+	struct tramp_info *tramp = &dlthis->tramp;
+	struct tramp_sym *cur_sym;
+	struct tramp_string *cur_string;
+	struct tramp_img_pkt *cur_tramp_pkt;
+	struct tramp_img_dup_pkt *cur_dup_pkt;
+	struct tramp_img_dup_relo *cur_dup_relo;
+
+	/*  If there were no tramps generated, just return */
+	if (tramp->tramp_sect_next_addr == 0)
+		return;
+
+	/*  Destroy all tramp information */
+	for (cur_sym = tramp->symbol_head;
+	     cur_sym != NULL; cur_sym = tramp->symbol_head) {
+		tramp->symbol_head = cur_sym->next;
+		if (tramp->symbol_tail == cur_sym)
+			tramp->symbol_tail = NULL;
+
+		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_sym);
+	}
+
+	if (tramp->final_sym_table != NULL)
+		dlthis->mysym->dload_deallocate(dlthis->mysym,
+						tramp->final_sym_table);
+
+	for (cur_string = tramp->string_head;
+	     cur_string != NULL; cur_string = tramp->string_head) {
+		tramp->string_head = cur_string->next;
+		if (tramp->string_tail == cur_string)
+			tramp->string_tail = NULL;
+
+		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_string);
+	}
+
+	if (tramp->final_string_table != NULL)
+		dlthis->mysym->dload_deallocate(dlthis->mysym,
+						tramp->final_string_table);
+
+	for (cur_tramp_pkt = tramp->tramp_pkts;
+	     cur_tramp_pkt != NULL; cur_tramp_pkt = tramp->tramp_pkts) {
+		tramp->tramp_pkts = cur_tramp_pkt->next;
+		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_tramp_pkt);
+	}
+
+	for (cur_dup_pkt = tramp->dup_pkts;
+	     cur_dup_pkt != NULL; cur_dup_pkt = tramp->dup_pkts) {
+		tramp->dup_pkts = cur_dup_pkt->next;
+
+		for (cur_dup_relo = cur_dup_pkt->relo_chain;
+		     cur_dup_relo != NULL;
+		     cur_dup_relo = cur_dup_pkt->relo_chain) {
+			cur_dup_pkt->relo_chain = cur_dup_relo->next;
+			dlthis->mysym->dload_deallocate(dlthis->mysym,
+							cur_dup_relo);
+		}
+
+		dlthis->mysym->dload_deallocate(dlthis->mysym, cur_dup_pkt);
+	}
+}
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/tramp_table_c6000.c kernel-power-2.6.28.new/drivers/dsp/bridge/dynload/tramp_table_c6000.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/dynload/tramp_table_c6000.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/dynload/tramp_table_c6000.c	2011-10-23 08:22:37.613570000 +0100
@@ -0,0 +1,164 @@
+/*
+ * tramp_table_c6000.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include "dload_internal.h"
+
+/*  These are defined in coff.h, but may not be available on all platforms
+	so we'll go ahead and define them here. */
+#ifndef R_C60LO16
+#define R_C60LO16	  0x54	/* C60: MVK Low Half Register */
+#define R_C60HI16	  0x55	/* C60: MVKH/MVKLH High Half Register */
+#endif
+
+#define C6X_TRAMP_WORD_COUNT			8
+#define C6X_TRAMP_MAX_RELOS			 8
+
+/*  THIS HASH FUNCTION MUST MATCH THE ONE IN reloc_table_c6000.c */
+#define HASH_FUNC(zz) (((((zz) + 1) * UINT32_C(1845)) >> 11) & 63)
+
+/*  THIS MUST MATCH reloc_record_t FOR A SYMBOL BASED RELO */
+struct c6000_relo_record {
+	s32 vaddr;
+	s32 symndx;
+#ifndef _BIG_ENDIAN
+	u16 disp;
+	u16 type;
+#else
+	u16 type;
+	u16 disp;
+#endif
+};
+
+struct c6000_gen_code {
+	struct tramp_gen_code_hdr hdr;
+	u32 tramp_instrs[C6X_TRAMP_WORD_COUNT];
+	struct c6000_relo_record relos[C6X_TRAMP_MAX_RELOS];
+};
+
+/*  Hash mapping for relos that can cause trampolines. */
+static const u16 tramp_map[] = {
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	0,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535
+};
+
+static const struct c6000_gen_code tramp_gen_info[] = {
+	/*  Tramp caused by R_C60PCR21 */
+	{
+	 /*  Header - 8 instructions, 2 relos */
+	 {
+	  sizeof(u32) * C6X_TRAMP_WORD_COUNT,
+	  2,
+	  FIELD_OFFSET(struct c6000_gen_code, relos)
+	  },
+
+	 /*  Trampoline instructions */
+	 {
+	  0x053C54F7,		/*       STW.D2T2  B10, *sp--[2] */
+	  0x0500002A,		/*  || MVK.S2   <blank>, B10 */
+	  0x0500006A,		/*       MVKH.S2   <blank>, B10 */
+	  0x00280362,		/*       B.S2     B10 */
+	  0x053C52E6,		/*       LDW.D2T2  *++sp[2], B10 */
+	  0x00006000,		/*       NOP       4 */
+	  0x00000000,		/*       NOP */
+	  0x00000000		/*       NOP */
+	  },
+
+	 /*  Relocations */
+	 {
+	  {4, 0, 0, R_C60LO16},
+	  {8, 0, 0, R_C60HI16},
+	  {0, 0, 0, 0x0000},
+	  {0, 0, 0, 0x0000},
+	  {0, 0, 0, 0x0000},
+	  {0, 0, 0, 0x0000},
+	  {0, 0, 0, 0x0000},
+	  {0, 0, 0, 0x0000}
+	  }
+	 }
+};
+
+/*  TARGET SPECIFIC FUNCTIONS THAT MUST BE DEFINED */
+static u32 tramp_size_get(void)
+{
+	return sizeof(u32) * C6X_TRAMP_WORD_COUNT;
+}
+
+static u32 tramp_img_pkt_size_get(void)
+{
+	return sizeof(struct c6000_gen_code);
+}
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/gen/gb.c kernel-power-2.6.28.new/drivers/dsp/bridge/gen/gb.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/gen/gb.c	2011-10-11 13:51:00.068015094 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/gen/gb.c	2011-10-23 08:22:37.613570000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Generic bitmap operations.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,21 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== gb.c ========
- *  Description: Generic bitmap operations.
- *
- *! Revision History
- *! ================
- *! 24-Feb-2003 vp  Code review updates.
- *! 17-Dec-2002 map Fixed GB_minset(), GB_empty(), and GB_full(),
- *!                 to ensure only 'len' bits are considered in the map
- *! 18-Oct-2002 sb  Ported to Linux platform.
- *! 06-Dec-2001 jeh Fixed bug in GB_minclear().
- *!
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 #include <linux/types.h>
@@ -36,21 +23,21 @@
 #include <dspbridge/gs.h>
 #include <dspbridge/gb.h>
 
-typedef GB_BitNum GB_WordNum;
+typedef gb_bit_num gb_word_num;
 
-struct GB_TMap {
-	GB_BitNum len;
-	GB_WordNum wcnt;
+struct gb_t_map {
+	gb_bit_num len;
+	gb_word_num wcnt;
 	u32 *words;
 };
 
 /*
- *  ======== GB_clear ========
+ *  ======== gb_clear ========
  *  purpose:
  *      Clears a bit in the bit map.
  */
 
-void GB_clear(struct GB_TMap *map, GB_BitNum bitn)
+void gb_clear(struct gb_t_map *map, gb_bit_num bitn)
 {
 	u32 mask;
 
@@ -59,26 +46,26 @@
 }
 
 /*
- *  ======== GB_create ========
+ *  ======== gb_create ========
  *  purpose:
  *      Creates a bit map.
  */
 
-struct GB_TMap *GB_create(GB_BitNum len)
+struct gb_t_map *gb_create(gb_bit_num len)
 {
-	struct GB_TMap *map;
-	GB_WordNum i;
-	map = (struct GB_TMap *)GS_alloc(sizeof(struct GB_TMap));
+	struct gb_t_map *map;
+	gb_word_num i;
+	map = (struct gb_t_map *)gs_alloc(sizeof(struct gb_t_map));
 	if (map != NULL) {
 		map->len = len;
 		map->wcnt = len / BITS_PER_LONG + 1;
-		map->words = (u32 *)GS_alloc(map->wcnt * sizeof(u32));
+		map->words = (u32 *) gs_alloc(map->wcnt * sizeof(u32));
 		if (map->words != NULL) {
 			for (i = 0; i < map->wcnt; i++)
 				map->words[i] = 0L;
 
 		} else {
-			GS_frees(map, sizeof(struct GB_TMap));
+			gs_frees(map, sizeof(struct gb_t_map));
 			map = NULL;
 		}
 	}
@@ -87,51 +74,51 @@
 }
 
 /*
- *  ======== GB_delete ========
+ *  ======== gb_delete ========
  *  purpose:
  *      Frees a bit map.
  */
 
-void GB_delete(struct GB_TMap *map)
+void gb_delete(struct gb_t_map *map)
 {
-	GS_frees(map->words, map->wcnt * sizeof(u32));
-	GS_frees(map, sizeof(struct GB_TMap));
+	gs_frees(map->words, map->wcnt * sizeof(u32));
+	gs_frees(map, sizeof(struct gb_t_map));
 }
 
 /*
- *  ======== GB_findandset ========
+ *  ======== gb_findandset ========
  *  purpose:
  *      Finds a free bit and sets it.
  */
-GB_BitNum GB_findandset(struct GB_TMap *map)
+gb_bit_num gb_findandset(struct gb_t_map *map)
 {
-	GB_BitNum bitn;
+	gb_bit_num bitn;
 
-	bitn = GB_minclear(map);
+	bitn = gb_minclear(map);
 
 	if (bitn != GB_NOBITS)
-		GB_set(map, bitn);
+		gb_set(map, bitn);
 
 	return bitn;
 }
 
 /*
- *  ======== GB_minclear ========
+ *  ======== gb_minclear ========
  *  purpose:
  *      returns the location of the first unset bit in the bit map.
  */
-GB_BitNum GB_minclear(struct GB_TMap *map)
+gb_bit_num gb_minclear(struct gb_t_map *map)
 {
-	GB_BitNum bit_location = 0;
-	GB_BitNum bitAcc = 0;
-	GB_WordNum i;
-	GB_BitNum bit;
+	gb_bit_num bit_location = 0;
+	gb_bit_num bit_acc = 0;
+	gb_word_num i;
+	gb_bit_num bit;
 	u32 *word;
 
 	for (word = map->words, i = 0; i < map->wcnt; word++, i++) {
 		if (~*word) {
-			for (bit = 0; bit < BITS_PER_LONG; bit++, bitAcc++) {
-				if (bitAcc == map->len)
+			for (bit = 0; bit < BITS_PER_LONG; bit++, bit_acc++) {
+				if (bit_acc == map->len)
 					return GB_NOBITS;
 
 				if (~*word & (1L << bit)) {
@@ -141,7 +128,7 @@
 
 			}
 		} else {
-			bitAcc += BITS_PER_LONG;
+			bit_acc += BITS_PER_LONG;
 		}
 	}
 
@@ -149,12 +136,12 @@
 }
 
 /*
- *  ======== GB_set ========
+ *  ======== gb_set ========
  *  purpose:
  *      Sets a bit in the bit map.
  */
 
-void GB_set(struct GB_TMap *map, GB_BitNum bitn)
+void gb_set(struct gb_t_map *map, gb_bit_num bitn)
 {
 	u32 mask;
 
@@ -163,12 +150,12 @@
 }
 
 /*
- *  ======== GB_test ========
+ *  ======== gb_test ========
  *  purpose:
  *      Returns true if the bit is set in the specified location.
  */
 
-bool GB_test(struct GB_TMap *map, GB_BitNum bitn)
+bool gb_test(struct gb_t_map *map, gb_bit_num bitn)
 {
 	bool state;
 	u32 mask;
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/gen/gh.c kernel-power-2.6.28.new/drivers/dsp/bridge/gen/gh.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/gen/gh.c	2011-10-11 13:51:00.084021221 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/gen/gh.c	2011-10-23 08:22:37.613570000 +0100
@@ -14,11 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== gh.c ========
- */
-
 #include <dspbridge/std.h>
 
 #include <dspbridge/host_os.h>
@@ -27,107 +22,110 @@
 
 #include <dspbridge/gh.h>
 
-struct Elem {
-	struct Elem *next;
+struct element {
+	struct element *next;
 	u8 data[1];
 };
 
-struct GH_THashTab {
-	u16 maxBucket;
-	u16 valSize;
-	struct Elem **buckets;
+struct gh_t_hash_tab {
+	u16 max_bucket;
+	u16 val_size;
+	struct element **buckets;
 	 u16(*hash) (void *, u16);
 	 bool(*match) (void *, void *);
-	 void(*delete) (void *);
+	void (*delete) (void *);
 };
 
-static void Nop(void *p);
-static s32 curInit;
+static void noop(void *p);
+static s32 cur_init;
 static void myfree(void *ptr, s32 size);
 
 /*
- *  ======== GH_create ========
+ *  ======== gh_create ========
  */
 
-struct GH_THashTab *GH_create(u16 maxBucket, u16 valSize,
-		u16(*hash)(void *, u16), bool(*match)(void *, void *),
-		void(*delete)(void *))
+struct gh_t_hash_tab *gh_create(u16 max_bucket, u16 val_size,
+				u16(*hash) (void *, u16), bool(*match) (void *,
+									void *),
+				void (*delete) (void *))
 {
-	struct GH_THashTab *hashTab;
+	struct gh_t_hash_tab *hash_tab;
 	u16 i;
-	hashTab = (struct GH_THashTab *)GS_alloc(sizeof(struct GH_THashTab));
-	if (hashTab == NULL)
+	hash_tab =
+	    (struct gh_t_hash_tab *)gs_alloc(sizeof(struct gh_t_hash_tab));
+	if (hash_tab == NULL)
 		return NULL;
-	hashTab->maxBucket = maxBucket;
-	hashTab->valSize = valSize;
-	hashTab->hash = hash;
-	hashTab->match = match;
-	hashTab->delete = delete == NULL ? Nop : delete;
-
-	hashTab->buckets = (struct Elem **)
-			   GS_alloc(sizeof(struct Elem *) * maxBucket);
-	if (hashTab->buckets == NULL) {
-		GH_delete(hashTab);
+	hash_tab->max_bucket = max_bucket;
+	hash_tab->val_size = val_size;
+	hash_tab->hash = hash;
+	hash_tab->match = match;
+	hash_tab->delete = delete == NULL ? noop : delete;
+
+	hash_tab->buckets = (struct element **)
+	    gs_alloc(sizeof(struct element *) * max_bucket);
+	if (hash_tab->buckets == NULL) {
+		gh_delete(hash_tab);
 		return NULL;
 	}
 
-	for (i = 0; i < maxBucket; i++)
-		hashTab->buckets[i] = NULL;
+	for (i = 0; i < max_bucket; i++)
+		hash_tab->buckets[i] = NULL;
 
-	return hashTab;
+	return hash_tab;
 }
 
 /*
- *  ======== GH_delete ========
+ *  ======== gh_delete ========
  */
-void GH_delete(struct GH_THashTab *hashTab)
+void gh_delete(struct gh_t_hash_tab *hash_tab)
 {
-	struct Elem *elem, *next;
+	struct element *elem, *next;
 	u16 i;
 
-	if (hashTab != NULL) {
-		if (hashTab->buckets != NULL) {
-			for (i = 0; i < hashTab->maxBucket; i++) {
-				for (elem = hashTab->buckets[i]; elem != NULL;
-				    elem = next) {
+	if (hash_tab != NULL) {
+		if (hash_tab->buckets != NULL) {
+			for (i = 0; i < hash_tab->max_bucket; i++) {
+				for (elem = hash_tab->buckets[i]; elem != NULL;
+				     elem = next) {
 					next = elem->next;
-					(*hashTab->delete) (elem->data);
-					myfree(elem, sizeof(struct Elem) - 1 +
-					      hashTab->valSize);
+					(*hash_tab->delete) (elem->data);
+					myfree(elem,
+					       sizeof(struct element) - 1 +
+					       hash_tab->val_size);
 				}
 			}
 
-			myfree(hashTab->buckets, sizeof(struct Elem *)
-			      * hashTab->maxBucket);
+			myfree(hash_tab->buckets, sizeof(struct element *)
+			       * hash_tab->max_bucket);
 		}
 
-		myfree(hashTab, sizeof(struct GH_THashTab));
+		myfree(hash_tab, sizeof(struct gh_t_hash_tab));
 	}
 }
 
 /*
- *  ======== GH_exit ========
+ *  ======== gh_exit ========
  */
 
-void GH_exit(void)
+void gh_exit(void)
 {
-	if (curInit-- == 1)
-		GS_exit();
+	if (cur_init-- == 1)
+		gs_exit();
 
 }
 
 /*
- *  ======== GH_find ========
+ *  ======== gh_find ========
  */
 
-void *GH_find(struct GH_THashTab *hashTab, void *key)
+void *gh_find(struct gh_t_hash_tab *hash_tab, void *key)
 {
-	struct Elem *elem;
+	struct element *elem;
 
-	elem = hashTab->buckets[(*hashTab->hash)(key, hashTab->maxBucket)];
+	elem = hash_tab->buckets[(*hash_tab->hash) (key, hash_tab->max_bucket)];
 
 	for (; elem; elem = elem->next) {
-		if ((*hashTab->match)(key, elem->data))
+		if ((*hash_tab->match) (key, elem->data))
 			return elem->data;
 	}
 
@@ -135,37 +133,37 @@
 }
 
 /*
- *  ======== GH_init ========
+ *  ======== gh_init ========
  */
 
-void GH_init(void)
+void gh_init(void)
 {
-	if (curInit++ == 0)
-		GS_init();
+	if (cur_init++ == 0)
+		gs_init();
 }
 
 /*
- *  ======== GH_insert ========
+ *  ======== gh_insert ========
  */
 
-void *GH_insert(struct GH_THashTab *hashTab, void *key, void *value)
+void *gh_insert(struct gh_t_hash_tab *hash_tab, void *key, void *value)
 {
-	struct Elem *elem;
+	struct element *elem;
 	u16 i;
 	char *src, *dst;
 
-	elem = (struct Elem *)GS_alloc(sizeof(struct Elem) - 1 +
-		hashTab->valSize);
+	elem = (struct element *)gs_alloc(sizeof(struct element) - 1 +
+					  hash_tab->val_size);
 	if (elem != NULL) {
 
 		dst = (char *)elem->data;
 		src = (char *)value;
-		for (i = 0; i < hashTab->valSize; i++)
+		for (i = 0; i < hash_tab->val_size; i++)
 			*dst++ = *src++;
 
-		i = (*hashTab->hash)(key, hashTab->maxBucket);
-		elem->next = hashTab->buckets[i];
-		hashTab->buckets[i] = elem;
+		i = (*hash_tab->hash) (key, hash_tab->max_bucket);
+		elem->next = hash_tab->buckets[i];
+		hash_tab->buckets[i] = elem;
 
 		return elem->data;
 	}
@@ -174,10 +172,10 @@
 }
 
 /*
- *  ======== Nop ========
+ *  ======== noop ========
  */
 /* ARGSUSED */
-static void Nop(void *p)
+static void noop(void *p)
 {
 	p = p;			/* stifle compiler warning */
 }
@@ -187,5 +185,5 @@
  */
 static void myfree(void *ptr, s32 size)
 {
-	GS_free(ptr);
+	gs_free(ptr);
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/gen/gs.c kernel-power-2.6.28.new/drivers/dsp/bridge/gen/gs.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/gen/gs.c	2011-10-11 13:51:00.084021221 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/gen/gs.c	2011-10-23 08:22:37.613570000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * General storage memory allocator services.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,21 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== gs.c ========
- *  Description:
- *      General storage memory allocator services.
- *
- *! Revision History
- *! ================
- *! 29-Sep-1999 ag:  Un-commented MEM_Init in GS_init().
- *! 14-May-1997 mg:  Modified to use new GS API for GS_free() and GS_frees().
- *! 06-Nov-1996 gp:  Re-commented MEM_Init in GS_init(). GS needs GS_Exit().
- *! 21-Oct-1996 db:  Un-commented MEM_Init in GS_init().
- *! 21-May-1996 mg:  Created from original stdlib implementation.
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
@@ -43,15 +30,15 @@
 static u32 cumsize;
 
 /*
- *  ======== GS_alloc ========
+ *  ======== gs_alloc ========
  *  purpose:
  *      Allocates memory of the specified size.
  */
-void *GS_alloc(u32 size)
+void *gs_alloc(u32 size)
 {
 	void *p;
 
-	p = MEM_Calloc(size, MEM_PAGED);
+	p = mem_calloc(size, MEM_PAGED);
 	if (p == NULL)
 		return NULL;
 	cumsize += size;
@@ -59,48 +46,44 @@
 }
 
 /*
- *  ======== GS_exit ========
+ *  ======== gs_exit ========
  *  purpose:
  *      Discontinue the usage of the GS module.
  */
-void GS_exit(void)
+void gs_exit(void)
 {
-	MEM_Exit();
+	/* Do nothing */
 }
 
 /*
- *  ======== GS_free ========
+ *  ======== gs_free ========
  *  purpose:
  *      Frees the memory.
  */
-void GS_free(void *ptr)
+void gs_free(void *ptr)
 {
-	MEM_Free(ptr);
+	kfree(ptr);
 	/* ack! no size info */
 	/* cumsize -= size; */
 }
 
 /*
- *  ======== GS_frees ========
+ *  ======== gs_frees ========
  *  purpose:
  *      Frees the memory.
  */
-void GS_frees(void *ptr, u32 size)
+void gs_frees(void *ptr, u32 size)
 {
-	MEM_Free(ptr);
+	kfree(ptr);
 	cumsize -= size;
 }
 
 /*
- *  ======== GS_init ========
+ *  ======== gs_init ========
  *  purpose:
  *      Initializes the GS module.
  */
-void GS_init(void)
+void gs_init(void)
 {
-	static bool curInit;
-
-	if (curInit == false) {
-		curInit = MEM_Init(); /* which can't fail currently. */
-	}
+	/* Do nothing */
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/gen/gt.c kernel-power-2.6.28.new/drivers/dsp/bridge/gen/gt.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/gen/gt.c	2011-10-11 13:51:00.084021221 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/gen/gt.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,348 +0,0 @@
-/*
- * gt.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- * ======== gt.c ========
- * Description: This module implements the trace mechanism for bridge.
- *
- *! Revision History
- *! ================
- *! 16-May-1997 dr	Changed GT_Config member names to conform to coding
- *!			standards.
- *! 23-Apr-1997 ge	Check for GT->TIDFXN for NULL before calling it.
- *! 03-Jan-1997	ge	Changed GT_Config structure member names to eliminate
- *!			preprocessor confusion with other macros.
- */
-
-/*  ----------------------------------- DSP/BIOS Bridge */
-#include <dspbridge/std.h>
-
-/*  ----------------------------------- This */
-#include <dspbridge/gt.h>
-
-#define GT_WILD	'*'
-
-#define GT_CLEAR	'='
-#define GT_ON		'+'
-#define GT_OFF		'-'
-
-enum GT_State {
-	GT_SEP,
-	GT_FIRST,
-	GT_SECOND,
-	GT_OP,
-	GT_DIGITS
-} ;
-
-#ifdef CONFIG_BRIDGE_DEBUG
-static char *GT_1format = "%s - %d: ";
-static char *GT_2format = "%s - %d(%d): ";
-#endif /* CONFIG_BRIDGE_DEBUG */
-
-static unsigned char *GT_tMask[GT_BOUND];
-
-static bool curInit;
-static char *separator;
-static unsigned char tabMem[GT_BOUND][sizeof(unsigned char) * GT_BOUND];
-
-static void error(char *string);
-static void setMask(s16 index1, s16 index2, char op, unsigned char mask);
-
-/*
- *  ======== _GT_create ========
- *  purpose:
- *      Creates GT mask.
- */
-void _GT_create(struct GT_Mask *mask, char *modName)
-{
-	mask->modName = modName;
-	mask->flags = &(GT_tMask[modName[0] - 'A'][modName[1] - 'A']);
-}
-
-/*
- *  ======== GT_init ========
- *  purpose:
- *      Initializes GT module.
- */
-#ifdef GT_init
-#undef GT_init
-#endif
-void GT_init(void)
-{
-	register unsigned char index1;
-	register unsigned char index2;
-
-	if (!curInit) {
-		curInit = true;
-
-		separator = " ,;/";
-
-		for (index1 = 0; index1 < GT_BOUND; index1++) {
-			GT_tMask[index1] = tabMem[index1];
-			for (index2 = 0; index2 < GT_BOUND; index2++) {
-				/* no tracing */
-				GT_tMask[index1][index2] = 0x00;
-			}
-		}
-	}
-}
-
-/*
- *  ======== _GT_set ========
- *  purpose:
- *      Sets the trace string format.
- */
-
-void _GT_set(char *str)
-{
-	enum GT_State state;
-	char *sep;
-	s16 index1 = GT_BOUND;	/* indicates all values */
-	s16 index2 = GT_BOUND;	/* indicates all values */
-	char op = GT_CLEAR;
-	bool maskValid;
-	s16 digit;
-	register unsigned char mask = 0x0;	/* no tracing */
-
-	if (str == NULL)
-		return;
-
-	maskValid = false;
-	state = GT_SEP;
-	while (*str != '\0') {
-		switch ((s32) state) {
-		case (s32) GT_SEP:
-			maskValid = false;
-			sep = separator;
-			while (*sep != '\0') {
-				if (*str == *sep) {
-					str++;
-					break;
-				} else {
-					sep++;
-				}
-			}
-			if (*sep == '\0')
-				state = GT_FIRST;
-
-			break;
-		case (s32) GT_FIRST:
-			if (*str == GT_WILD) {
-				/* indicates all values */
-				index1 = GT_BOUND;
-				/* indicates all values */
-				index2 = GT_BOUND;
-				state = GT_OP;
-			} else {
-				if (*str >= 'a')
-					index1 = (s16) (*str - 'a');
-				else
-					index1 = (s16) (*str - 'A');
-				if ((index1 >= 0) && (index1 < GT_BOUND))
-					state = GT_SECOND;
-				else
-					state = GT_SEP;
-			}
-			str++;
-			break;
-		case (s32) GT_SECOND:
-			if (*str == GT_WILD) {
-				index2 = GT_BOUND;   /* indicates all values */
-				state = GT_OP;
-				str++;
-			} else {
-				if (*str >= 'a')
-					index2 = (s16) (*str - 'a');
-				else
-					index2 = (s16) (*str - 'A');
-				if ((index2 >= 0) && (index2 < GT_BOUND)) {
-					state = GT_OP;
-					str++;
-				} else {
-					state = GT_SEP;
-				}
-			}
-			break;
-		case (s32) GT_OP:
-			op = *str;
-			mask = 0x0;	/* no tracing */
-			switch (op) {
-			case (s32) GT_CLEAR:
-				maskValid = true;
-			case (s32) GT_ON:
-			case (s32) GT_OFF:
-				state = GT_DIGITS;
-				str++;
-				break;
-			default:
-				state = GT_SEP;
-				break;
-			}
-			break;
-		case (s32) GT_DIGITS:
-			digit = (s16) (*str - '0');
-			if ((digit >= 0) && (digit <= 7)) {
-				mask |= (0x01 << digit);
-				maskValid = true;
-				str++;
-			} else {
-				if (maskValid == true) {
-					setMask(index1, index2, op, mask);
-					maskValid = false;
-				}
-				state = GT_SEP;
-			}
-			break;
-		default:
-			error("illegal trace mask");
-			break;
-		}
-	}
-
-	if (maskValid)
-		setMask(index1, index2, op, mask);
-}
-
-/*
- *  ======== _GT_trace ========
- *  purpose:
- *      Prints the input string onto standard output
- */
-
-s32 _GT_trace(struct GT_Mask *mask, char *format, ...)
-{
-	s32 arg1, arg2, arg3, arg4, arg5, arg6;
-	va_list va;
-
-	va_start(va, format);
-
-	arg1 = va_arg(va, s32);
-	arg2 = va_arg(va, s32);
-	arg3 = va_arg(va, s32);
-	arg4 = va_arg(va, s32);
-	arg5 = va_arg(va, s32);
-	arg6 = va_arg(va, s32);
-
-	va_end(va);
-#ifdef DEBUG
-	if (GT->PIDFXN == NULL) {
-		printk(GT_1format, mask->modName, GT->TIDFXN ?
-		(*GT->TIDFXN)() : 0);
-	} else {
-		printk(GT_2format, mask->modName, (*GT->PIDFXN)(),
-		GT->TIDFXN ? (*GT->TIDFXN)() : 0);
-	}
-#endif
-	printk(format, arg1, arg2, arg3, arg4, arg5, arg6);
-
-	return 0;
-}
-
-/*
- *  ======== error ========
- *  purpose:
- *      Prints errors onto the standard output.
- */
-static void error(char *string)
-{
-	printk("GT: %s", string);
-}
-
-/*
- *  ======== setmask ========
- *  purpose:
- *      Sets mask for the GT module.
- */
-
-static void setMask(s16 index1, s16 index2, char op, u8 mask)
-{
-	register s16 index;
-
-	if (index1 < GT_BOUND) {
-		if (index2 < GT_BOUND) {
-			switch (op) {
-			case (s32) GT_CLEAR:
-				GT_tMask[index1][index2] = mask;
-				break;
-			case (s32) GT_ON:
-				GT_tMask[index1][index2] |= mask;
-				break;
-			case (s32) GT_OFF:
-				GT_tMask[index1][index2] &= ~mask;
-				break;
-			default:
-				error("illegal trace mask");
-				break;
-			}
-		} else {
-			for (index2--; index2 >= 0; index2--) {
-				switch (op) {
-				case (s32) GT_CLEAR:
-					GT_tMask[index1][index2] = mask;
-					break;
-				case (s32) GT_ON:
-					GT_tMask[index1][index2] |= mask;
-					break;
-				case (s32) GT_OFF:
-					GT_tMask[index1][index2] &= ~mask;
-					break;
-				default:
-					error("illegal trace mask");
-					break;
-				}
-			}
-		}
-	} else {
-		for (index1--; index1 >= 0; index1--) {
-			if (index2 < GT_BOUND) {
-				switch (op) {
-				case (s32) GT_CLEAR:
-					GT_tMask[index1][index2] = mask;
-					break;
-				case (s32) GT_ON:
-					GT_tMask[index1][index2] |= mask;
-					break;
-				case (s32) GT_OFF:
-					GT_tMask[index1][index2] &= ~mask;
-					break;
-				default:
-					error("illegal trace mask");
-					break;
-				}
-			} else {
-				index = GT_BOUND;
-				for (index--; index >= 0; index--) {
-					switch (op) {
-					case (s32) GT_CLEAR:
-						GT_tMask[index1][index] = mask;
-						break;
-					case (s32) GT_ON:
-						GT_tMask[index1][index] |= mask;
-						break;
-					case (s32) GT_OFF:
-						GT_tMask[index1][index] &=
-						    ~mask;
-						break;
-					default:
-						error("illegal trace mask");
-						break;
-					}
-				}
-			}
-		}
-	}
-}
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/gen/_gt_para.c kernel-power-2.6.28.new/drivers/dsp/bridge/gen/_gt_para.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/gen/_gt_para.c	2011-10-11 13:51:00.156767695 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/gen/_gt_para.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,107 +0,0 @@
-/*
- * _gt_para.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== _gt_para.c ========
- *  Description:
- *      Configuration parameters for GT.  This file is separated from
- *      gt.c so that GT_assert() can reference the error function without
- *      forcing the linker to include all the code for GT_set(), GT_init(),
- *      etc. into a fully bound image.  Thus, GT_assert() can be retained in
- *      a program for which GT_?trace() has been compiled out.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 vp: Code Review Updates.
- *! 18-Oct-2002 sb: Ported to Linux platform.
- *! 03-Jul-2001 rr: Removed kfuncs.h because of build errors.
- *! 07-Dec-1999 ag: Fxn error now causes a WinCE DebugBreak;
- *! 30-Aug-1999 ag: Now uses GP_printf for printf and error.
- *!
- */
-
-/*  ----------------------------------- Host OS */
-#include <dspbridge/host_os.h>
-
-/*  ----------------------------------- DSP/BIOS Bridge */
-#include <dspbridge/std.h>
-
-/*  ----------------------------------- Trace & Debug */
-#include <dspbridge/gt.h>
-
-/*  ----------------------------------- Function Prototypes */
-static void error(char *msg, ...);
-static s32 GT_nop(void);
-
-/*  ----------------------------------- Defines, Data Structures, Typedefs */
-
-struct GT_Config _GT_params = {
-	(Fxn) printk,		/* printf */
-	(Fxn) NULL,		/* procid */
-	(Fxn) GT_nop,		/* taskid */
-	(Fxn) error,		/* error */
-};
-
-/*  ----------------------------------- Globals */
-struct GT_Config *GT = &_GT_params;
-
-/*
- *  ======== GT_nop ========
- */
-static s32 GT_nop(void)
-{
-	return 0;
-}
-
-/*
- * ======== error ========
- *  purpose:
- *      Prints error onto the standard output.
- */
-static void error(char *fmt, ...)
-{
-	s32 arg1, arg2, arg3, arg4, arg5, arg6;
-
-	va_list va;
-
-	va_start(va, fmt);
-
-	arg1 = va_arg(va, s32);
-	arg2 = va_arg(va, s32);
-	arg3 = va_arg(va, s32);
-	arg4 = va_arg(va, s32);
-	arg5 = va_arg(va, s32);
-	arg6 = va_arg(va, s32);
-
-	va_end(va);
-
-	printk("ERROR: ");
-	printk(fmt, arg1, arg2, arg3, arg4, arg5, arg6);
-
-#if defined(DEBUG) || defined(DDSP_DEBUG_PRODUCT)
-	if (in_interrupt()) {
-		printk(KERN_INFO "Not stopping after error since ISR/DPC "
-			"are disabled\n");
-	} else {
-		set_current_state(TASK_INTERRUPTIBLE);
-		flush_signals(current);
-		schedule();
-		flush_signals(current);
-		printk(KERN_INFO "Signaled in error function\n");
-	}
-#endif
-}
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/gen/uuidutil.c kernel-power-2.6.28.new/drivers/dsp/bridge/gen/uuidutil.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/gen/uuidutil.c	2011-10-11 13:51:00.163164400 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/gen/uuidutil.c	2011-10-23 08:22:37.613570000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This file contains the implementation of UUID helper functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,25 +16,7 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== uuidutil.c ========
- *  Description:
- *  This file contains the implementation of UUID helper functions.
- *
- *! Revision History
- *! ================
- *! 23-Feb-2003 vp: Code review updates.
- *! 18-Oct-2003 vp: Ported to Linux platform.
- *! 31-Aug-2000 rr: UUID_UuidFromString bug fixed.
- *! 29-Aug-2000 rr: Modified UUID_UuidFromString.
- *! 09-Nov-2000 kc: Modified UUID_UuidFromString to simplify implementation.
- *! 30-Oct-2000 kc: Modified UUID utility module function prefix.
- *! 10-Aug-2000 kc: Created.
- *!
- */
-
-/*  ----------------------------------- Host OS  */
+/*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
 /*  ----------------------------------- DSP/BIOS Bridge */
@@ -46,27 +30,28 @@
 #include <dspbridge/uuidutil.h>
 
 /*
- *  ======== UUID_UuidToString ========
+ *  ======== uuid_uuid_to_string ========
  *  Purpose:
- *      Converts a struct DSP_UUID to a string.
+ *      Converts a struct dsp_uuid to a string.
  *      Note: snprintf format specifier is:
  *      %[flags] [width] [.precision] [{h | l | I64 | L}]type
  */
-void UUID_UuidToString(IN struct DSP_UUID *pUuid, OUT char *pszUuid,
-		       IN s32 size)
+void uuid_uuid_to_string(IN struct dsp_uuid *uuid_obj, OUT char *pszUuid,
+			 IN s32 size)
 {
 	s32 i;			/* return result from snprintf. */
 
-	DBC_Require(pUuid && pszUuid);
+	DBC_REQUIRE(uuid_obj && pszUuid);
 
 	i = snprintf(pszUuid, size,
 		     "%.8X_%.4X_%.4X_%.2X%.2X_%.2X%.2X%.2X%.2X%.2X%.2X",
-		     pUuid->ulData1, pUuid->usData2, pUuid->usData3,
-		     pUuid->ucData4, pUuid->ucData5, pUuid->ucData6[0],
-		     pUuid->ucData6[1], pUuid->ucData6[2], pUuid->ucData6[3],
-		     pUuid->ucData6[4], pUuid->ucData6[5]);
+		     uuid_obj->ul_data1, uuid_obj->us_data2, uuid_obj->us_data3,
+		     uuid_obj->uc_data4, uuid_obj->uc_data5,
+		     uuid_obj->uc_data6[0], uuid_obj->uc_data6[1],
+		     uuid_obj->uc_data6[2], uuid_obj->uc_data6[3],
+		     uuid_obj->uc_data6[4], uuid_obj->uc_data6[5]);
 
-	DBC_Ensure(i != -1);
+	DBC_ENSURE(i != -1);
 }
 
 /*
@@ -127,11 +112,11 @@
 }
 
 /*
- *  ======== UUID_UuidFromString ========
+ *  ======== uuid_uuid_from_string ========
  *  Purpose:
- *      Converts a string to a struct DSP_UUID.
+ *      Converts a string to a struct dsp_uuid.
  */
-void UUID_UuidFromString(IN char *pszUuid, OUT struct DSP_UUID *pUuid)
+void uuid_uuid_from_string(IN char *pszUuid, OUT struct dsp_uuid *uuid_obj)
 {
 	char c;
 	s32 i, j;
@@ -150,7 +135,7 @@
 		/* Go to next character in string */
 		temp++;
 	}
-	pUuid->ulData1 = result;
+	uuid_obj->ul_data1 = result;
 
 	/* Step over underscore */
 	temp++;
@@ -167,7 +152,7 @@
 		/* Go to next character in string */
 		temp++;
 	}
-	pUuid->usData2 = (u16)result;
+	uuid_obj->us_data2 = (u16) result;
 
 	/* Step over underscore */
 	temp++;
@@ -184,7 +169,7 @@
 		/* Go to next character in string */
 		temp++;
 	}
-	pUuid->usData3 = (u16)result;
+	uuid_obj->us_data3 = (u16) result;
 
 	/* Step over underscore */
 	temp++;
@@ -201,7 +186,7 @@
 		/* Go to next character in string */
 		temp++;
 	}
-	pUuid->ucData4 = (u8)result;
+	uuid_obj->uc_data4 = (u8) result;
 
 	result = 0;
 	for (i = 0; i < 2; i++) {
@@ -215,7 +200,7 @@
 		/* Go to next character in string */
 		temp++;
 	}
-	pUuid->ucData5 = (u8)result;
+	uuid_obj->uc_data5 = (u8) result;
 
 	/* Step over underscore */
 	temp++;
@@ -233,6 +218,6 @@
 			/* Go to next character in string */
 			temp++;
 		}
-		pUuid->ucData6[j] = (u8)result;
+		uuid_obj->uc_data6[j] = (u8) result;
 	}
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/EasiGlobal.h kernel-power-2.6.28.new/drivers/dsp/bridge/hw/EasiGlobal.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/EasiGlobal.h	2011-10-11 13:51:00.163164400 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/EasiGlobal.h	2011-10-23 08:22:37.613570000 +0100
@@ -14,8 +14,8 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifndef __EASIGLOBAL_H
-#define __EASIGLOBAL_H
+#ifndef _EASIGLOBAL_H
+#define _EASIGLOBAL_H
 #include <linux/types.h>
 
 /*
@@ -29,14 +29,13 @@
 #define READ_WRITE   3
 
 /*
- * MACRO:        _DEBUG_LEVEL_1_EASI
+ * MACRO:        _DEBUG_LEVEL1_EASI
  *
  * DESCRIPTION:  A MACRO which can be used to indicate that a particular beach
  *               register access function was called.
  *
  * NOTE:         We currently dont use this functionality.
  */
-#define _DEBUG_LEVEL_1_EASI(easiNum)     ((void)0)
-
-#endif	/* __EASIGLOBAL_H */
+#define _DEBUG_LEVEL1_EASI(easiNum)     ((void)0)
 
+#endif /* _EASIGLOBAL_H */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/GlobalTypes.h kernel-power-2.6.28.new/drivers/dsp/bridge/hw/GlobalTypes.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/GlobalTypes.h	2011-10-11 13:51:00.250113400 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/GlobalTypes.h	2011-10-23 08:22:37.613570000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global HW definitions
+ *
  * Copyright (C) 2007 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,18 +16,8 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== GlobalTypes.h ========
- *  Description:
- *      Global HW definitions
- *
- *! Revision History:
- *! ================
- *! 16 Feb 2003 sb: Initial version
- */
-#ifndef __GLOBALTYPES_H
-#define __GLOBALTYPES_H
+#ifndef _GLOBALTYPES_H
+#define _GLOBALTYPES_H
 
 /*
  * Definition: TRUE, FALSE
@@ -58,173 +50,166 @@
  *
  * DESCRIPTION:  offset in bytes from start of 32-bit word.
  */
-#define LOWER_16BIT_OFFSET	  0
-#define UPPER_16BIT_OFFSET	  2
+#define LOWER16BIT_OFFSET	  0
+#define UPPER16BIT_OFFSET	  2
 
-#define LOWER_8BIT_OFFSET	   0
-#define LOWER_MIDDLE_8BIT_OFFSET    1
-#define UPPER_MIDDLE_8BIT_OFFSET    2
-#define UPPER_8BIT_OFFSET	   3
+#define LOWER8BIT_OFFSET	   0
+#define LOWER_MIDDLE8BIT_OFFSET    1
+#define UPPER_MIDDLE8BIT_OFFSET    2
+#define UPPER8BIT_OFFSET	   3
 
-#define LOWER_8BIT_OF16_OFFSET      0
-#define UPPER_8BIT_OF16_OFFSET      1
+#define LOWER8BIT_OF16_OFFSET      0
+#define UPPER8BIT_OF16_OFFSET      1
 
 /*
  * Definition: *BIT_SHIFT
  *
  * DESCRIPTION:  offset in bits from start of 32-bit word.
  */
-#define LOWER_16BIT_SHIFT	  0
-#define UPPER_16BIT_SHIFT	  16
+#define LOWER16BIT_SHIFT	  0
+#define UPPER16BIT_SHIFT	  16
 
-#define LOWER_8BIT_SHIFT	   0
-#define LOWER_MIDDLE_8BIT_SHIFT    8
-#define UPPER_MIDDLE_8BIT_SHIFT    16
-#define UPPER_8BIT_SHIFT	   24
-
-#define LOWER_8BIT_OF16_SHIFT      0
-#define UPPER_8BIT_OF16_SHIFT      8
+#define LOWER8BIT_SHIFT	   0
+#define LOWER_MIDDLE8BIT_SHIFT    8
+#define UPPER_MIDDLE8BIT_SHIFT    16
+#define UPPER8BIT_SHIFT	   24
 
+#define LOWER8BIT_OF16_SHIFT      0
+#define UPPER8BIT_OF16_SHIFT      8
 
 /*
- * Definition: LOWER_16BIT_MASK
+ * Definition: LOWER16BIT_MASK
  *
  * DESCRIPTION: 16 bit mask used for inclusion of lower 16 bits i.e. mask out
  *		the upper 16 bits
  */
-#define LOWER_16BIT_MASK	0x0000FFFF
-
+#define LOWER16BIT_MASK	0x0000FFFF
 
 /*
- * Definition: LOWER_8BIT_MASK
+ * Definition: LOWER8BIT_MASK
  *
  * DESCRIPTION: 8 bit masks used for inclusion of 8 bits i.e. mask out
  *		the upper 16 bits
  */
-#define LOWER_8BIT_MASK	   0x000000FF
+#define LOWER8BIT_MASK	   0x000000FF
 
 /*
- * Definition: RETURN_32BITS_FROM_16LOWER_AND_16UPPER(lower16Bits, upper16Bits)
+ * Definition: RETURN32BITS_FROM16LOWER_AND16UPPER(lower16Bits, upper16Bits)
  *
  * DESCRIPTION: Returns a 32 bit value given a 16 bit lower value and a 16
  *		bit upper value
  */
-#define RETURN_32BITS_FROM_16LOWER_AND_16UPPER(lower16Bits,upper16Bits)\
-    (((((u32)lower16Bits)  & LOWER_16BIT_MASK)) | \
-     (((((u32)upper16Bits) & LOWER_16BIT_MASK) << UPPER_16BIT_SHIFT)))
+#define RETURN32BITS_FROM16LOWER_AND16UPPER(lower16Bits, upper16Bits)\
+    (((((u32)lower16Bits)  & LOWER16BIT_MASK)) | \
+     (((((u32)upper16Bits) & LOWER16BIT_MASK) << UPPER16BIT_SHIFT)))
 
 /*
- * Definition: RETURN_16BITS_FROM_8LOWER_AND_8UPPER(lower16Bits, upper16Bits)
+ * Definition: RETURN16BITS_FROM8LOWER_AND8UPPER(lower16Bits, upper16Bits)
  *
  * DESCRIPTION:  Returns a 16 bit value given a 8 bit lower value and a 8
  *	       bit upper value
  */
-#define RETURN_16BITS_FROM_8LOWER_AND_8UPPER(lower8Bits,upper8Bits)\
-    (((((u32)lower8Bits)  & LOWER_8BIT_MASK)) | \
-     (((((u32)upper8Bits) & LOWER_8BIT_MASK) << UPPER_8BIT_OF16_SHIFT)))
+#define RETURN16BITS_FROM8LOWER_AND8UPPER(lower8Bits, upper8Bits)\
+    (((((u32)lower8Bits)  & LOWER8BIT_MASK)) | \
+     (((((u32)upper8Bits) & LOWER8BIT_MASK) << UPPER8BIT_OF16_SHIFT)))
 
 /*
- * Definition: RETURN_32BITS_FROM_4_8BIT_VALUES(lower8Bits, lowerMiddle8Bits,
+ * Definition: RETURN32BITS_FROM48BIT_VALUES(lower8Bits, lowerMiddle8Bits,
  * 					lowerUpper8Bits, upper8Bits)
  *
  * DESCRIPTION:  Returns a 32 bit value given four 8 bit values
  */
-#define RETURN_32BITS_FROM_4_8BIT_VALUES(lower8Bits, lowerMiddle8Bits,\
+#define RETURN32BITS_FROM48BIT_VALUES(lower8Bits, lowerMiddle8Bits,\
 	lowerUpper8Bits, upper8Bits)\
-	(((((u32)lower8Bits) & LOWER_8BIT_MASK)) | \
-	(((((u32)lowerMiddle8Bits) & LOWER_8BIT_MASK) <<\
-		LOWER_MIDDLE_8BIT_SHIFT)) | \
-	(((((u32)lowerUpper8Bits) & LOWER_8BIT_MASK) <<\
-		UPPER_MIDDLE_8BIT_SHIFT)) | \
-	(((((u32)upper8Bits) & LOWER_8BIT_MASK) <<\
-		UPPER_8BIT_SHIFT)))
+	(((((u32)lower8Bits) & LOWER8BIT_MASK)) | \
+	(((((u32)lowerMiddle8Bits) & LOWER8BIT_MASK) <<\
+		LOWER_MIDDLE8BIT_SHIFT)) | \
+	(((((u32)lowerUpper8Bits) & LOWER8BIT_MASK) <<\
+		UPPER_MIDDLE8BIT_SHIFT)) | \
+	(((((u32)upper8Bits) & LOWER8BIT_MASK) <<\
+		UPPER8BIT_SHIFT)))
 
 /*
- * Definition: READ_LOWER_16BITS_OF_32(value32bits)
+ * Definition: READ_LOWER16BITS_OF32(value32bits)
  *
  * DESCRIPTION:  Returns a 16 lower bits of 32bit value
  */
-#define READ_LOWER_16BITS_OF_32(value32bits)\
-    ((u16)((u32)(value32bits) & LOWER_16BIT_MASK))
+#define READ_LOWER16BITS_OF32(value32bits)\
+    ((u16)((u32)(value32bits) & LOWER16BIT_MASK))
 
 /*
- * Definition: READ_UPPER_16BITS_OF_32(value32bits)
+ * Definition: READ_UPPER16BITS_OF32(value32bits)
  *
  * DESCRIPTION:  Returns a 16 lower bits of 32bit value
  */
-#define READ_UPPER_16BITS_OF_32(value32bits)\
-	(((u16)((u32)(value32bits) >> UPPER_16BIT_SHIFT)) &\
-	LOWER_16BIT_MASK)
-
+#define READ_UPPER16BITS_OF32(value32bits)\
+	(((u16)((u32)(value32bits) >> UPPER16BIT_SHIFT)) &\
+	LOWER16BIT_MASK)
 
 /*
- * Definition: READ_LOWER_8BITS_OF_32(value32bits)
+ * Definition: READ_LOWER8BITS_OF32(value32bits)
  *
  * DESCRIPTION:  Returns a 8 lower bits of 32bit value
  */
-#define READ_LOWER_8BITS_OF_32(value32bits)\
-    ((u8)((u32)(value32bits) & LOWER_8BIT_MASK))
+#define READ_LOWER8BITS_OF32(value32bits)\
+    ((u8)((u32)(value32bits) & LOWER8BIT_MASK))
 
 /*
- * Definition: READ_LOWER_MIDDLE_8BITS_OF_32(value32bits)
+ * Definition: READ_LOWER_MIDDLE8BITS_OF32(value32bits)
  *
  * DESCRIPTION:  Returns a 8 lower middle bits of 32bit value
  */
-#define READ_LOWER_MIDDLE_8BITS_OF_32(value32bits)\
-	(((u8)((u32)(value32bits) >> LOWER_MIDDLE_8BIT_SHIFT)) &\
-	LOWER_8BIT_MASK)
+#define READ_LOWER_MIDDLE8BITS_OF32(value32bits)\
+	(((u8)((u32)(value32bits) >> LOWER_MIDDLE8BIT_SHIFT)) &\
+	LOWER8BIT_MASK)
 
 /*
- * Definition: READ_LOWER_MIDDLE_8BITS_OF_32(value32bits)
+ * Definition: READ_LOWER_MIDDLE8BITS_OF32(value32bits)
  *
  * DESCRIPTION:  Returns a 8 lower middle bits of 32bit value
  */
-#define READ_UPPER_MIDDLE_8BITS_OF_32(value32bits)\
-	(((u8)((u32)(value32bits) >> LOWER_MIDDLE_8BIT_SHIFT)) &\
-	LOWER_8BIT_MASK)
+#define READ_UPPER_MIDDLE8BITS_OF32(value32bits)\
+	(((u8)((u32)(value32bits) >> LOWER_MIDDLE8BIT_SHIFT)) &\
+	LOWER8BIT_MASK)
 
 /*
- * Definition: READ_UPPER_8BITS_OF_32(value32bits)
+ * Definition: READ_UPPER8BITS_OF32(value32bits)
  *
  * DESCRIPTION:  Returns a 8 upper bits of 32bit value
  */
-#define READ_UPPER_8BITS_OF_32(value32bits)\
-    (((u8)((u32)(value32bits) >> UPPER_8BIT_SHIFT)) & LOWER_8BIT_MASK)
-
+#define READ_UPPER8BITS_OF32(value32bits)\
+    (((u8)((u32)(value32bits) >> UPPER8BIT_SHIFT)) & LOWER8BIT_MASK)
 
 /*
- * Definition: READ_LOWER_8BITS_OF_16(value16bits)
+ * Definition: READ_LOWER8BITS_OF16(value16bits)
  *
  * DESCRIPTION:  Returns a 8 lower bits of 16bit value
  */
-#define READ_LOWER_8BITS_OF_16(value16bits)\
-    ((u8)((u16)(value16bits) & LOWER_8BIT_MASK))
+#define READ_LOWER8BITS_OF16(value16bits)\
+    ((u8)((u16)(value16bits) & LOWER8BIT_MASK))
 
 /*
- * Definition: READ_UPPER_8BITS_OF_16(value32bits)
+ * Definition: READ_UPPER8BITS_OF16(value32bits)
  *
  * DESCRIPTION:  Returns a 8 upper bits of 16bit value
  */
-#define READ_UPPER_8BITS_OF_16(value16bits)\
-    (((u8)((u32)(value16bits) >> UPPER_8BIT_SHIFT)) & LOWER_8BIT_MASK)
-
-
+#define READ_UPPER8BITS_OF16(value16bits)\
+    (((u8)((u32)(value16bits) >> UPPER8BIT_SHIFT)) & LOWER8BIT_MASK)
 
 /* UWORD16:  16 bit tpyes */
 
+/* reg_uword8, reg_word8: 8 bit register types */
+typedef volatile unsigned char reg_uword8;
+typedef volatile signed char reg_word8;
 
-/* REG_UWORD8, REG_WORD8: 8 bit register types */
-typedef volatile unsigned char  REG_UWORD8;
-typedef volatile signed   char  REG_WORD8;
-
-/* REG_UWORD16, REG_WORD16: 16 bit register types */
+/* reg_uword16, reg_word16: 16 bit register types */
 #ifndef OMAPBRIDGE_TYPES
-typedef volatile unsigned short REG_UWORD16;
+typedef volatile unsigned short reg_uword16;
 #endif
-typedef volatile	  short REG_WORD16;
+typedef volatile short reg_word16;
 
-/* REG_UWORD32, REG_WORD32: 32 bit register types */
-typedef volatile unsigned long  REG_UWORD32;
+/* reg_uword32, REG_WORD32: 32 bit register types */
+typedef volatile unsigned long reg_uword32;
 
 /* FLOAT
  *
@@ -232,72 +217,70 @@
  * calculation is very CPU expensive, and you should only  use if you
  * absolutely need this. */
 
-
 /* boolean_t:  Boolean Type True, False */
-/* ReturnCode_t:  Return codes to be returned by all library functions */
-typedef enum ReturnCode_label {
-    RET_OK = 0,
-    RET_FAIL = -1,
-    RET_BAD_NULL_PARAM = -2,
-    RET_PARAM_OUT_OF_RANGE = -3,
-    RET_INVALID_ID = -4,
-    RET_EMPTY = -5,
-    RET_FULL = -6,
-    RET_TIMEOUT = -7,
-    RET_INVALID_OPERATION = -8,
+/* return_code_t:  Return codes to be returned by all library functions */
+typedef enum return_code_label {
+	RET_OK = 0,
+	RET_FAIL = -1,
+	RET_BAD_NULL_PARAM = -2,
+	RET_PARAM_OUT_OF_RANGE = -3,
+	RET_INVALID_ID = -4,
+	RET_EMPTY = -5,
+	RET_FULL = -6,
+	RET_TIMEOUT = -7,
+	RET_INVALID_OPERATION = -8,
 
-    /* Add new error codes at end of above list */
+	/* Add new error codes at end of above list */
 
-    RET_NUM_RET_CODES     /* this should ALWAYS be LAST entry */
-} ReturnCode_t, *pReturnCode_t;
+	RET_NUM_RET_CODES	/* this should ALWAYS be LAST entry */
+} return_code_t, *preturn_code_t;
 
-/* MACRO: RD_MEM_8, WR_MEM_8
+/* MACRO: RD_MEM8, WR_MEM8
  *
  * DESCRIPTION:  32 bit memory access macros
  */
-#define RD_MEM_8(addr)	((u8)(*((u8 *)(addr))))
-#define WR_MEM_8(addr, data)	(*((u8 *)(addr)) = (u8)(data))
+#define RD_MEM8(addr)	((u8)(*((u8 *)(addr))))
+#define WR_MEM8(addr, data)	(*((u8 *)(addr)) = (u8)(data))
 
-/* MACRO: RD_MEM_8_VOLATILE, WR_MEM_8_VOLATILE
+/* MACRO: RD_MEM8_VOLATILE, WR_MEM8_VOLATILE
  *
  * DESCRIPTION:  8 bit register access macros
  */
-#define RD_MEM_8_VOLATILE(addr)	((u8)(*((REG_UWORD8 *)(addr))))
-#define WR_MEM_8_VOLATILE(addr, data) (*((REG_UWORD8 *)(addr)) = (u8)(data))
-
+#define RD_MEM8_VOLATILE(addr)	((u8)(*((reg_uword8 *)(addr))))
+#define WR_MEM8_VOLATILE(addr, data) (*((reg_uword8 *)(addr)) = (u8)(data))
 
 /*
- * MACRO: RD_MEM_16, WR_MEM_16
+ * MACRO: RD_MEM16, WR_MEM16
  *
  * DESCRIPTION:  16 bit memory access macros
  */
-#define RD_MEM_16(addr)	((u16)(*((u16 *)(addr))))
-#define WR_MEM_16(addr, data)	(*((u16 *)(addr)) = (u16)(data))
+#define RD_MEM16(addr)	((u16)(*((u16 *)(addr))))
+#define WR_MEM16(addr, data)	(*((u16 *)(addr)) = (u16)(data))
 
 /*
- * MACRO: RD_MEM_16_VOLATILE, WR_MEM_16_VOLATILE
+ * MACRO: RD_MEM16_VOLATILE, WR_MEM16_VOLATILE
  *
  * DESCRIPTION:  16 bit register access macros
  */
-#define RD_MEM_16_VOLATILE(addr)	((u16)(*((REG_UWORD16 *)(addr))))
-#define WR_MEM_16_VOLATILE(addr, data)	(*((REG_UWORD16 *)(addr)) =\
+#define RD_MEM16_VOLATILE(addr)	((u16)(*((reg_uword16 *)(addr))))
+#define WR_MEM16_VOLATILE(addr, data)	(*((reg_uword16 *)(addr)) =\
 					(u16)(data))
 
 /*
- * MACRO: RD_MEM_32, WR_MEM_32
+ * MACRO: RD_MEM32, WR_MEM32
  *
  * DESCRIPTION:  32 bit memory access macros
  */
-#define RD_MEM_32(addr)	((u32)(*((u32 *)(addr))))
-#define WR_MEM_32(addr, data)	(*((u32 *)(addr)) = (u32)(data))
+#define RD_MEM32(addr)	((u32)(*((u32 *)(addr))))
+#define WR_MEM32(addr, data)	(*((u32 *)(addr)) = (u32)(data))
 
 /*
- * MACRO: RD_MEM_32_VOLATILE, WR_MEM_32_VOLATILE
+ * MACRO: RD_MEM32_VOLATILE, WR_MEM32_VOLATILE
  *
  * DESCRIPTION:  32 bit register access macros
  */
-#define RD_MEM_32_VOLATILE(addr)	((u32)(*((REG_UWORD32 *)(addr))))
-#define WR_MEM_32_VOLATILE(addr, data)	(*((REG_UWORD32 *)(addr)) =\
+#define RD_MEM32_VOLATILE(addr)	((u32)(*((reg_uword32 *)(addr))))
+#define WR_MEM32_VOLATILE(addr, data)	(*((reg_uword32 *)(addr)) =\
 					(u32)(data))
 
 /* Not sure if this all belongs here */
@@ -322,4 +305,4 @@
 #define CHECK_INPUT_RANGE_NO_SPY_MIN0(actualValue, maxValidValue,\
 	returnCodeIfMismatch)
 
-#endif	/* __GLOBALTYPES_H */
+#endif /* _GLOBALTYPES_H */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_defs.h kernel-power-2.6.28.new/drivers/dsp/bridge/hw/hw_defs.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_defs.h	2011-10-11 13:51:00.250113400 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/hw_defs.h	2011-10-23 08:22:37.613570000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global HW definitions
+ *
  * Copyright (C) 2007 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,60 +16,45 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== hw_defs.h ========
- *  Description:
- *      Global HW definitions
- *
- *! Revision History:
- *! ================
- *! 19 Apr 2004 sb: Added generic page size, endianness and element size defns
- *! 16 Feb 2003 sb: Initial version
- */
-#ifndef __HW_DEFS_H
-#define __HW_DEFS_H
+#ifndef _HW_DEFS_H
+#define _HW_DEFS_H
 
 #include <GlobalTypes.h>
 
 /* Page size */
-#define HW_PAGE_SIZE_4KB   0x1000
-#define HW_PAGE_SIZE_64KB  0x10000
-#define HW_PAGE_SIZE_1MB   0x100000
-#define HW_PAGE_SIZE_16MB  0x1000000
-
-/* HW_STATUS:  return type for HW API */
-typedef long HW_STATUS;
-
-/* HW_SetClear_t:  Enumerated Type used to set and clear any bit */
-enum HW_SetClear_t {
-    HW_CLEAR,
-    HW_SET
-} ;
+#define HW_PAGE_SIZE4KB   0x1000
+#define HW_PAGE_SIZE64KB  0x10000
+#define HW_PAGE_SIZE1MB   0x100000
+#define HW_PAGE_SIZE16MB  0x1000000
+
+/* hw_status:  return type for HW API */
+typedef long hw_status;
+
+/*  Macro used to set and clear any bit */
+#define HW_CLEAR	0
+#define HW_SET		1
 
-/* HW_Endianism_t:  Enumerated Type used to specify the endianism
+/* hw_endianism_t:  Enumerated Type used to specify the endianism
  *		Do NOT change these values. They are used as bit fields. */
-enum HW_Endianism_t {
-    HW_LITTLE_ENDIAN,
-    HW_BIG_ENDIAN
-
-} ;
+enum hw_endianism_t {
+	HW_LITTLE_ENDIAN,
+	HW_BIG_ENDIAN
+};
 
-/* HW_ElementSize_t:  Enumerated Type used to specify the element size
+/* hw_element_size_t:  Enumerated Type used to specify the element size
  *		Do NOT change these values. They are used as bit fields. */
-enum HW_ElementSize_t {
-    HW_ELEM_SIZE_8BIT,
-    HW_ELEM_SIZE_16BIT,
-    HW_ELEM_SIZE_32BIT,
-    HW_ELEM_SIZE_64BIT
-
-} ;
-
-/* HW_IdleMode_t:  Enumerated Type used to specify Idle modes */
-	enum HW_IdleMode_t {
-		HW_FORCE_IDLE,
-		HW_NO_IDLE,
-		HW_SMART_IDLE
-	} ;
+enum hw_element_size_t {
+	HW_ELEM_SIZE8BIT,
+	HW_ELEM_SIZE16BIT,
+	HW_ELEM_SIZE32BIT,
+	HW_ELEM_SIZE64BIT
+};
+
+/* hw_idle_mode_t:  Enumerated Type used to specify Idle modes */
+enum hw_idle_mode_t {
+	HW_FORCE_IDLE,
+	HW_NO_IDLE,
+	HW_SMART_IDLE
+};
 
-#endif  /* __HW_DEFS_H */
+#endif /* _HW_DEFS_H */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_dspssC64P.c kernel-power-2.6.28.new/drivers/dsp/bridge/hw/hw_dspssC64P.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_dspssC64P.c	2011-10-11 13:51:00.259840145 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/hw_dspssC64P.c	2011-10-23 08:22:37.613570000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * API definitions to configure DSP Subsystem modules like IPI
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,17 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== hw_dspss64P.c ========
- *  Description:
- *      API definitions to configure DSP Subsystem modules like IPI
- *
- *! Revision History:
- *! ================
- *! 19 Apr 2004 sb: Implemented HW_DSPSS_IPIEndianismSet
- *! 16 Feb 2003 sb: Initial version
- */
-
 /* PROJECT SPECIFIC INCLUDE FILES */
 #include <GlobalTypes.h>
 #include <linux/io.h>
@@ -34,13 +25,13 @@
 #include <IPIAccInt.h>
 
 /* HW FUNCTIONS */
-HW_STATUS HW_DSPSS_BootModeSet(const void __iomem *baseAddress,
-		      enum HW_DSPSYSC_BootMode_t bootMode,
-		      const u32 bootAddress)
+hw_status hw_dspss_boot_mode_set(const void __iomem *baseAddress,
+				 enum hw_dspsysc_boot_mode_t bootMode,
+				 const u32 bootAddress)
 {
-	HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 	u32 offset = SYSC_IVA2BOOTMOD_OFFSET;
-	u32 alignedBootAddr;
+	u32 aligned_boot_addr;
 
 	/* if Boot mode it DIRECT BOOT, check that the bootAddress is
 	 * aligned to atleast 1K :: TODO */
@@ -48,9 +39,9 @@
 
 	offset = SYSC_IVA2BOOTADDR_OFFSET;
 
-	alignedBootAddr = bootAddress & SYSC_IVA2BOOTADDR_MASK;
+	aligned_boot_addr = bootAddress & SYSC_IVA2BOOTADDR_MASK;
 
-	__raw_writel(alignedBootAddr, (baseAddress) + offset);
+	__raw_writel(aligned_boot_addr, (baseAddress) + offset);
 
 	return status;
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_dspssC64P.h kernel-power-2.6.28.new/drivers/dsp/bridge/hw/hw_dspssC64P.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_dspssC64P.h	2011-10-11 13:51:00.259840145 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/hw_dspssC64P.h	2011-10-23 08:22:37.613570000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP Subsystem API declarations
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,35 +16,22 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== hw_dspss.h ========
- *  Description:
- *      DSP Subsystem API declarations
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb: Removed redundant argument from HW_DSPSS_IPIEndianismSet
- *!		    Moved endianness and element size to generic hw_defs.h
- *! 16 Feb 2003 sb: Initial version
- */
-
-#ifndef __HW_DSPSS_H
-#define __HW_DSPSS_H
+#ifndef _HW_DSPSS_H
+#define _HW_DSPSS_H
 #include <linux/types.h>
 
-	enum HW_DSPSYSC_BootMode_t {
-		HW_DSPSYSC_DIRECTBOOT = 0x0,
-		HW_DSPSYSC_IDLEBOOT = 0x1,
-		HW_DSPSYSC_SELFLOOPBOOT = 0x2,
-		HW_DSPSYSC_USRBOOTSTRAP = 0x3,
-		HW_DSPSYSC_DEFAULTRESTORE = 0x4
-	} ;
+enum hw_dspsysc_boot_mode_t {
+	HW_DSPSYSC_DIRECTBOOT = 0x0,
+	HW_DSPSYSC_IDLEBOOT = 0x1,
+	HW_DSPSYSC_SELFLOOPBOOT = 0x2,
+	HW_DSPSYSC_USRBOOTSTRAP = 0x3,
+	HW_DSPSYSC_DEFAULTRESTORE = 0x4
+};
 
 #define HW_DSP_IDLEBOOT_ADDR   0x007E0000
 
-	extern HW_STATUS HW_DSPSS_BootModeSet(const void __iomem *baseAddress,
-					enum HW_DSPSYSC_BootMode_t bootMode,
+extern hw_status hw_dspss_boot_mode_set(const void __iomem *baseAddress,
+					enum hw_dspsysc_boot_mode_t bootMode,
 					const u32 bootAddress);
 
-#endif				/* __HW_DSPSS_H */
+#endif /* _HW_DSPSS_H */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_mbox.c kernel-power-2.6.28.new/drivers/dsp/bridge/hw/hw_mbox.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_mbox.c	2011-10-11 13:51:00.267967773 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/hw_mbox.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,247 +0,0 @@
-/*
- * hw_mbox.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2007 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== hw_mbox.c ========
- *  Description:
- *      Mailbox messaging & configuration API definitions
- *
- *! Revision History:
- *! ================
- *! 16 Feb 2003 sb: Initial version
- */
-
-#include <GlobalTypes.h>
-#include "MLBRegAcM.h"
-#include <hw_defs.h>
-#include <hw_mbox.h>
-
-/* width in bits of MBOX Id */
-#define HW_MBOX_ID_WIDTH	   2
-
-struct MAILBOX_CONTEXT mboxsetting = {
-	.sysconfig = 2 << 3 | 1, /* SMART/AUTO-IDLE */
-};
-
-/* Saves the mailbox context */
-HW_STATUS HW_MBOX_saveSettings(void __iomem *baseAddress)
-{
-	HW_STATUS status = RET_OK;
-
-	mboxsetting.sysconfig = MLBMAILBOX_SYSCONFIGReadRegister32(baseAddress);
-	/* Get current enable status */
-	mboxsetting.irqEnable0 = MLBMAILBOX_IRQENABLE___0_3ReadRegister32
-				 (baseAddress, HW_MBOX_U0_ARM);
-	mboxsetting.irqEnable1 = MLBMAILBOX_IRQENABLE___0_3ReadRegister32
-				 (baseAddress, HW_MBOX_U1_DSP1);
-	return status;
-}
-
-/* Restores the mailbox context */
-HW_STATUS HW_MBOX_restoreSettings(void __iomem *baseAddress)
-{
-	 HW_STATUS status = RET_OK;
-	/* Restor IRQ enable status */
-	MLBMAILBOX_IRQENABLE___0_3WriteRegister32(baseAddress, HW_MBOX_U0_ARM,
-						 mboxsetting.irqEnable0);
-	MLBMAILBOX_IRQENABLE___0_3WriteRegister32(baseAddress, HW_MBOX_U1_DSP1,
-						 mboxsetting.irqEnable1);
-	/* Restore Sysconfig register */
-	MLBMAILBOX_SYSCONFIGWriteRegister32(baseAddress, mboxsetting.sysconfig);
-	return status;
-}
-
-/* Reads a u32 from the sub module message box Specified. if there are no
- * messages in the mailbox then and error is returned. */
-HW_STATUS HW_MBOX_MsgRead(const void __iomem *baseAddress,
-	const HW_MBOX_Id_t mailBoxId, u32 *const pReadValue)
-{
-	HW_STATUS status = RET_OK;
-
-	/* Check input parameters */
-	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM, RES_MBOX_BASE +
-		      RES_INVALID_INPUT_PARAM);
-	CHECK_INPUT_PARAM(pReadValue, NULL, RET_BAD_NULL_PARAM, RES_MBOX_BASE +
-		      RES_INVALID_INPUT_PARAM);
-	CHECK_INPUT_RANGE_MIN0(mailBoxId, HW_MBOX_ID_MAX, RET_INVALID_ID,
-			   RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
-
-	/* Read 32-bit message in mail box */
-	*pReadValue = MLBMAILBOX_MESSAGE___0_15ReadRegister32(baseAddress,
-							 (u32)mailBoxId);
-
-	return status;
-}
-
-/* Writes a u32 from the sub module message box Specified. */
-HW_STATUS HW_MBOX_MsgWrite(const void __iomem *baseAddress,
-	const HW_MBOX_Id_t mailBoxId, const u32 writeValue)
-{
-	HW_STATUS status = RET_OK;
-
-	/* Check input parameters */
-	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM, RES_MBOX_BASE +
-			RES_INVALID_INPUT_PARAM);
-	CHECK_INPUT_RANGE_MIN0(mailBoxId, HW_MBOX_ID_MAX, RET_INVALID_ID,
-			RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
-
-	/* Write 32-bit value to mailbox */
-	MLBMAILBOX_MESSAGE___0_15WriteRegister32(baseAddress, (u32)mailBoxId,
-					    (u32)writeValue);
-
-	return status;
-}
-
-/* Gets number of messages in a specified mailbox. */
-HW_STATUS HW_MBOX_NumMsgGet(const void __iomem *baseAddress,
-	const HW_MBOX_Id_t mailBoxId, u32 *const pNumMsg)
-{
-	HW_STATUS status = RET_OK;
-
-	/* Check input parameters */
-	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM, RES_MBOX_BASE +
-		      RES_INVALID_INPUT_PARAM);
-	CHECK_INPUT_PARAM(pNumMsg,  NULL, RET_BAD_NULL_PARAM, RES_MBOX_BASE +
-		      RES_INVALID_INPUT_PARAM);
-
-	CHECK_INPUT_RANGE_MIN0(mailBoxId, HW_MBOX_ID_MAX, RET_INVALID_ID,
-			   RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
-
-	/* Get number of messages available for MailBox */
-	*pNumMsg = MLBMAILBOX_MSGSTATUS___0_15NbOfMsgMBmRead32(baseAddress,
-							  (u32)mailBoxId);
-
-	return status;
-}
-
-/* Enables the specified IRQ. */
-HW_STATUS HW_MBOX_EventEnable(const void __iomem *baseAddress,
-				const HW_MBOX_Id_t mailBoxId,
-				const HW_MBOX_UserId_t userId,
-				const u32 events)
-{
-	HW_STATUS status = RET_OK;
-	u32 irqEnableReg;
-
-	/* Check input parameters */
-	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM, RES_MBOX_BASE +
-			  RES_INVALID_INPUT_PARAM);
-	CHECK_INPUT_RANGE_MIN0(mailBoxId, HW_MBOX_ID_MAX, RET_INVALID_ID,
-			 RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
-	CHECK_INPUT_RANGE_MIN0(enableIrq, HW_MBOX_INT_MAX, RET_INVALID_ID,
-			 RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
-	CHECK_INPUT_RANGE_MIN0(userId, HW_MBOX_USER_MAX, RET_INVALID_ID,
-			 RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
-
-	/* Get current enable status */
-	irqEnableReg = MLBMAILBOX_IRQENABLE___0_3ReadRegister32(baseAddress,
-							     (u32)userId);
-
-	/* update enable value */
-	irqEnableReg |= ((u32)(events)) << (((u32)(mailBoxId)) *
-			HW_MBOX_ID_WIDTH);
-
-	/* write new enable status */
-	MLBMAILBOX_IRQENABLE___0_3WriteRegister32(baseAddress, (u32)userId,
-						 (u32)irqEnableReg);
-
-	mboxsetting.sysconfig = MLBMAILBOX_SYSCONFIGReadRegister32(baseAddress);
-	/* Get current enable status */
-	mboxsetting.irqEnable0 = MLBMAILBOX_IRQENABLE___0_3ReadRegister32
-				(baseAddress, HW_MBOX_U0_ARM);
-	mboxsetting.irqEnable1 = MLBMAILBOX_IRQENABLE___0_3ReadRegister32
-				(baseAddress, HW_MBOX_U1_DSP1);
-	return status;
-}
-
-/* Disables the specified IRQ. */
-HW_STATUS HW_MBOX_EventDisable(const void __iomem *baseAddress,
-				const HW_MBOX_Id_t mailBoxId,
-				const HW_MBOX_UserId_t userId,
-				const u32 events)
-{
-	HW_STATUS status = RET_OK;
-	u32 irqDisableReg;
-
-	/* Check input parameters */
-	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM, RES_MBOX_BASE +
-		      RES_INVALID_INPUT_PARAM);
-	CHECK_INPUT_RANGE_MIN0(mailBoxId, HW_MBOX_ID_MAX, RET_INVALID_ID,
-		     RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
-	CHECK_INPUT_RANGE_MIN0(disableIrq, HW_MBOX_INT_MAX, RET_INVALID_ID,
-		     RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
-	CHECK_INPUT_RANGE_MIN0(userId, HW_MBOX_USER_MAX, RET_INVALID_ID,
-		     RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
-
-	/* Get current enable status */
-	irqDisableReg = MLBMAILBOX_IRQENABLE___0_3ReadRegister32(baseAddress,
-		    (u32)userId);
-
-	/* update enable value */
-	irqDisableReg &= ~(((u32)(events)) << (((u32)(mailBoxId)) *
-		     HW_MBOX_ID_WIDTH));
-
-	/* write new enable status */
-	MLBMAILBOX_IRQENABLE___0_3WriteRegister32(baseAddress, (u32)userId,
-					     (u32)irqDisableReg);
-
-	return status;
-}
-
-/* Sets the status of the specified IRQ. */
-HW_STATUS HW_MBOX_EventAck(const void __iomem *baseAddress,
-	const HW_MBOX_Id_t mailBoxId, const HW_MBOX_UserId_t userId,
-	const u32 event)
-{
-	HW_STATUS status = RET_OK;
-	u32 irqStatusReg;
-
-	/* Check input parameters */
-	CHECK_INPUT_PARAM(baseAddress,   0, RET_BAD_NULL_PARAM, RES_MBOX_BASE +
-		      RES_INVALID_INPUT_PARAM);
-
-	CHECK_INPUT_RANGE_MIN0(irqStatus, HW_MBOX_INT_MAX, RET_INVALID_ID,
-		     RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
-	CHECK_INPUT_RANGE_MIN0(mailBoxId, HW_MBOX_ID_MAX, RET_INVALID_ID,
-		     RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
-	CHECK_INPUT_RANGE_MIN0(userId, HW_MBOX_USER_MAX, RET_INVALID_ID,
-		     RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
-
-	/* calculate status to write */
-	irqStatusReg = ((u32)event) << (((u32)(mailBoxId)) *
-		   HW_MBOX_ID_WIDTH);
-
-	/* clear Irq Status for specified mailbox/User Id */
-	MLBMAILBOX_IRQSTATUS___0_3WriteRegister32(baseAddress, (u32)userId,
-					     (u32)irqStatusReg);
-
-	/*
-	 * FIXME: Replace all this custom register access with standard
-	 * __raw_read/write().
-	 *
-	 * FIXME: Replace all interrupt handlers with standard linux style
-	 * interrupt handlers.
-	 *
-	 * FIXME: Replace direct access to PRCM registers with omap standard
-	 * PRCM register access.
-	 *
-	 * Flush posted write for the irq status to avoid spurious interrupts.
-	 */
-	MLBMAILBOX_IRQSTATUS___0_3ReadRegister32(baseAddress, (u32)userId);
-
-	return status;
-}
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_mbox.h kernel-power-2.6.28.new/drivers/dsp/bridge/hw/hw_mbox.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_mbox.h	2011-10-11 13:51:00.267967773 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/hw_mbox.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,328 +0,0 @@
-/*
- * hw_mbox.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2007 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== hw_mbox.h ========
- *  Description:
- *      HW Mailbox API and types definitions
- *
- *! Revision History:
- *! ================
- *! 16 Feb 2003 sb: Initial version
- */
-#ifndef __MBOX_H
-#define __MBOX_H
-
-/* Bitmasks for Mailbox interrupt sources */
-#define HW_MBOX_INT_NEW_MSG    0x1
-#define HW_MBOX_INT_NOT_FULL   0x2
-#define HW_MBOX_INT_ALL	0x3
-
-/* Maximum number of messages that mailbox can hald at a time. */
-#define HW_MBOX_MAX_NUM_MESSAGES   4
-
-/* HW_MBOX_Id_t: Enumerated Type used to specify Mailbox Sub Module Id Number */
-typedef enum HW_MBOX_Id_label {
-    HW_MBOX_ID_0,
-    HW_MBOX_ID_1,
-    HW_MBOX_ID_2,
-    HW_MBOX_ID_3,
-    HW_MBOX_ID_4,
-    HW_MBOX_ID_5
-
-} HW_MBOX_Id_t, *pHW_MBOX_Id_t;
-
-/* HW_MBOX_UserId_t:  Enumerated Type used to specify Mail box User Id */
-typedef enum HW_MBOX_UserId_label {
-    HW_MBOX_U0_ARM,
-    HW_MBOX_U1_DSP1,
-    HW_MBOX_U2_DSP2,
-    HW_MBOX_U3_ARM
-
-} HW_MBOX_UserId_t, *pHW_MBOX_UserId_t;
-
-/* Mailbox context settings */
-struct MAILBOX_CONTEXT {
-	u32 sysconfig;
-	u32 irqEnable0;
-	u32 irqEnable1;
-};
-
-/*
-* FUNCTION      : HW_MBOX_MsgRead
-*
-* INPUTS:
-*
-*   Identifier  : baseAddress
-*   Type	: const u32
-*   Description : Base Address of instance of Mailbox module
-*
-*   Identifier  : mailBoxId
-*   Type	: const HW_MBOX_Id_t
-*   Description : Mail Box Sub module Id to read
-*
-* OUTPUTS:
-*
-*   Identifier  : pReadValue
-*   Type	: u32 *const
-*   Description : Value read from MailBox
-*
-* RETURNS:
-*
-*   Type	: ReturnCode_t
-*   Description : RET_OK	      No errors occured
-*		 RET_BAD_NULL_PARAM  Address/ptr Paramater was set to 0/NULL
-*		 RET_INVALID_ID      Invalid Id used
-*		 RET_EMPTY	   Mailbox empty
-*
-* PURPOSE:      : this function reads a u32 from the sub module message
-*		 box Specified. if there are no messages in the mailbox
-*		 then and error is returned.
-*/
-extern HW_STATUS HW_MBOX_MsgRead(const void __iomem *baseAddress,
-				const HW_MBOX_Id_t mailBoxId,
-				u32 *const pReadValue);
-
-/*
-* FUNCTION      : HW_MBOX_MsgWrite
-*
-* INPUTS:
-*
-*   Identifier  : baseAddress
-*   Type	: const u32
-*   Description : Base Address of instance of Mailbox module
-*
-*   Identifier  : mailBoxId
-*   Type	: const HW_MBOX_Id_t
-*   Description : Mail Box Sub module Id to write
-*
-*   Identifier  : writeValue
-*   Type	: const u32
-*   Description : Value to write to MailBox
-*
-* RETURNS:
-*
-*   Type	: ReturnCode_t
-*   Description : RET_OK	      No errors occured
-*		 RET_BAD_NULL_PARAM  Address/pointer Paramater was set to 0/NULL
-*		 RET_INVALID_ID      Invalid Id used
-*
-* PURPOSE:      : this function writes a u32 from the sub module message
-*		 box Specified.
-*/
-extern HW_STATUS HW_MBOX_MsgWrite(
-		      const void __iomem *baseAddress,
-		      const HW_MBOX_Id_t   mailBoxId,
-		      const u32	 writeValue
-		  );
-
-/*
-* FUNCTION      : HW_MBOX_NumMsgGet
-*
-* INPUTS:
-*
-*   Identifier  : baseAddress
-*   Type	: const u32
-*   Description : Base Address of instance of Mailbox module
-*
-*   Identifier  : mailBoxId
-*   Type	: const HW_MBOX_Id_t
-*   Description : Mail Box Sub module Id to get num messages
-*
-* OUTPUTS:
-*
-*   Identifier  : pNumMsg
-*   Type	: u32 *const
-*   Description : Number of messages in mailbox
-*
-* RETURNS:
-*
-*   Type	: ReturnCode_t
-*   Description : RET_OK	      No errors occured
-*		 RET_BAD_NULL_PARAM  Address/pointer Paramater was set to 0/NULL
-*		 RET_INVALID_ID      Inavlid ID input at parameter
-*
-* PURPOSE:      : this function gets number of messages in a specified mailbox.
-*/
-extern HW_STATUS HW_MBOX_NumMsgGet(
-		      const void	 __iomem *baseAddress,
-		      const HW_MBOX_Id_t   mailBoxId,
-		      u32 *const	pNumMsg
-		  );
-
-/*
-* FUNCTION      : HW_MBOX_EventEnable
-*
-* INPUTS:
-*
-*   Identifier  : baseAddress
-*   Type	: const u32
-*		 RET_BAD_NULL_PARAM  Address/pointer Paramater was set to 0/NULL
-*
-*   Identifier  : mailBoxId
-*   Type	: const HW_MBOX_Id_t
-*   Description : Mail Box Sub module Id to enable
-*
-*   Identifier  : userId
-*   Type	: const HW_MBOX_UserId_t
-*   Description : Mail box User Id to enable
-*
-*   Identifier  : enableIrq
-*   Type	: const u32
-*   Description : Irq value to enable
-*
-* RETURNS:
-*
-*   Type	: ReturnCode_t
-*   Description : RET_OK	      No errors occured
-*		 RET_BAD_NULL_PARAM  A Pointer Paramater was set to NULL
-*		 RET_INVALID_ID      Invalid Id used
-*
-* PURPOSE:      : this function enables the specified IRQ.
-*/
-extern HW_STATUS HW_MBOX_EventEnable(
-		      const void __iomem *baseAddress,
-		      const HW_MBOX_Id_t       mailBoxId,
-		      const HW_MBOX_UserId_t   userId,
-		      const u32	     events
-		  );
-
-/*
-* FUNCTION      : HW_MBOX_EventDisable
-*
-* INPUTS:
-*
-*   Identifier  : baseAddress
-*   Type	: const u32
-*		 RET_BAD_NULL_PARAM  Address/pointer Paramater was set to 0/NULL
-*
-*   Identifier  : mailBoxId
-*   Type	: const HW_MBOX_Id_t
-*   Description : Mail Box Sub module Id to disable
-*
-*   Identifier  : userId
-*   Type	: const HW_MBOX_UserId_t
-*   Description : Mail box User Id to disable
-*
-*   Identifier  : enableIrq
-*   Type	: const u32
-*   Description : Irq value to disable
-*
-* RETURNS:
-*
-*   Type	: ReturnCode_t
-*   Description : RET_OK	      No errors occured
-*		 RET_BAD_NULL_PARAM  A Pointer Paramater was set to NULL
-*		 RET_INVALID_ID      Invalid Id used
-*
-* PURPOSE:      : this function disables the specified IRQ.
-*/
-extern HW_STATUS HW_MBOX_EventDisable(
-		      const void __iomem *baseAddress,
-		      const HW_MBOX_Id_t       mailBoxId,
-		      const HW_MBOX_UserId_t   userId,
-		      const u32	     events
-		  );
-
-/*
-* FUNCTION      : HW_MBOX_EventAck
-*
-* INPUTS:
-*
-*   Identifier  : baseAddress
-*   Type	: const u32
-*   Description : Base Address of instance of Mailbox module
-*
-*   Identifier  : mailBoxId
-*   Type	: const HW_MBOX_Id_t
-*   Description : Mail Box Sub module Id to set
-*
-*   Identifier  : userId
-*   Type	: const HW_MBOX_UserId_t
-*   Description : Mail box User Id to set
-*
-*   Identifier  : irqStatus
-*   Type	: const u32
-*   Description : The value to write IRQ status
-*
-* OUTPUTS:
-*
-* RETURNS:
-*
-*   Type	: ReturnCode_t
-*   Description : RET_OK	      No errors occured
-*		 RET_BAD_NULL_PARAM  Address Paramater was set to 0
-*		 RET_INVALID_ID      Invalid Id used
-*
-* PURPOSE:      : this function sets the status of the specified IRQ.
-*/
-extern HW_STATUS HW_MBOX_EventAck(
-		      const void	__iomem *baseAddress,
-		      const HW_MBOX_Id_t	mailBoxId,
-		      const HW_MBOX_UserId_t    userId,
-		      const u32	      event
-		  );
-
-/*
-* FUNCTION      : HW_MBOX_saveSettings
-*
-* INPUTS:
-*
-*   Identifier  : baseAddress
-*   Type	: const u32
-*   Description : Base Address of instance of Mailbox module
-*
-*
-* RETURNS:
-*
-*   Type	: ReturnCode_t
-*   Description : RET_OK	      No errors occured
-*		 RET_BAD_NULL_PARAM  Address/pointer Paramater was set to 0/NULL
-*		 RET_INVALID_ID      Invalid Id used
-*		 RET_EMPTY	   Mailbox empty
-*
-* PURPOSE:      : this function saves the context of mailbox
-*/
-extern HW_STATUS HW_MBOX_saveSettings(void __iomem *baseAddres);
-
-/*
-* FUNCTION      : HW_MBOX_restoreSettings
-*
-* INPUTS:
-*
-*   Identifier  : baseAddress
-*   Type	: const u32
-*   Description : Base Address of instance of Mailbox module
-*
-*
-* RETURNS:
-*
-*   Type	: ReturnCode_t
-*   Description : RET_OK	      No errors occured
-*		 RET_BAD_NULL_PARAM  Address/pointer Paramater was set to 0/NULL
-*		 RET_INVALID_ID      Invalid Id used
-*		 RET_EMPTY	   Mailbox empty
-*
-* PURPOSE:      : this function restores the context of mailbox
-*/
-extern HW_STATUS HW_MBOX_restoreSettings(void __iomem *baseAddres);
-
-static inline void HW_MBOX_initSettings(void __iomem *baseAddres)
-{
-	HW_MBOX_restoreSettings(baseAddres);
-}
-
-#endif  /* __MBOX_H */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_mmu.c kernel-power-2.6.28.new/drivers/dsp/bridge/hw/hw_mmu.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_mmu.c	2011-10-11 13:51:00.277597753 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/hw_mmu.c	2011-10-23 08:22:37.619928000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * API definitions to setup MMU TLB and PTE
+ *
  * Copyright (C) 2007 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,21 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== hw_mmu.c ========
- *  Description:
- *      API definitions to setup MMU TLB and PTE
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb  TLBAdd and TLBFlush input the page size in bytes instead
-		    of an enum. TLBAdd inputs mapping attributes struct instead
-		    of individual arguments.
-		    Removed MMU.h and other cosmetic updates.
- *! 08-Mar-2004 sb  Added the Page Table Management APIs
- *! 16 Feb 2003 sb: Initial version
- */
-
 #include <GlobalTypes.h>
 #include <linux/io.h>
 #include "MMURegAcM.h"
@@ -49,551 +36,552 @@
 
 #define MMU_LOAD_TLB	0x00000001
 
-/* HW_MMUPageSize_t:  Enumerated Type used to specify the MMU Page Size(SLSS) */
-enum HW_MMUPageSize_t {
-    HW_MMU_SECTION,
-    HW_MMU_LARGE_PAGE,
-    HW_MMU_SMALL_PAGE,
-    HW_MMU_SUPERSECTION
-} ;
+/*
+ * hw_mmu_page_size_t: Enumerated Type used to specify the MMU Page Size(SLSS)
+ */
+enum hw_mmu_page_size_t {
+	HW_MMU_SECTION,
+	HW_MMU_LARGE_PAGE,
+	HW_MMU_SMALL_PAGE,
+	HW_MMU_SUPERSECTION
+};
 
 /*
-* FUNCTION	      : MMU_FlushEntry
-*
-* INPUTS:
-*
-*       Identifier      : baseAddress
-*       Type		: const u32
-*       Description     : Base Address of instance of MMU module
-*
-* RETURNS:
-*
-*       Type		: HW_STATUS
-*       Description     : RET_OK		 -- No errors occured
-*			 RET_BAD_NULL_PARAM     -- A Pointer
-*						Paramater was set to NULL
-*
-* PURPOSE:	      : Flush the TLB entry pointed by the
-*			lock counter register
-*			even if this entry is set protected
-*
-* METHOD:	       : Check the Input parameter and Flush a
-*			 single entry in the TLB.
-*/
-static HW_STATUS MMU_FlushEntry(const void __iomem *baseAddress);
+ * FUNCTION	      : mmu_flush_entry
+ *
+ * INPUTS:
+ *
+ *       Identifier      : baseAddress
+ *       Type		: const u32
+ *       Description     : Base Address of instance of MMU module
+ *
+ * RETURNS:
+ *
+ *       Type		: hw_status
+ *       Description     : RET_OK		 -- No errors occured
+ *			 RET_BAD_NULL_PARAM     -- A Pointer
+ *						Paramater was set to NULL
+ *
+ * PURPOSE:	      : Flush the TLB entry pointed by the
+ *			lock counter register
+ *			even if this entry is set protected
+ *
+ * METHOD:	       : Check the Input parameter and Flush a
+ *			 single entry in the TLB.
+ */
+static hw_status mmu_flush_entry(const void __iomem *baseAddress);
 
 /*
-* FUNCTION	      : MMU_SetCAMEntry
-*
-* INPUTS:
-*
-*       Identifier      : baseAddress
-*       TypE		: const u32
-*       Description     : Base Address of instance of MMU module
-*
-*       Identifier      : pageSize
-*       TypE		: const u32
-*       Description     : It indicates the page size
-*
-*       Identifier      : preservedBit
-*       Type		: const u32
-*       Description     : It indicates the TLB entry is preserved entry
-*							or not
-*
-*       Identifier      : validBit
-*       Type		: const u32
-*       Description     : It indicates the TLB entry is valid entry or not
-*
-*
-*       Identifier      : virtualAddrTag
-*       Type	    	: const u32
-*       Description     : virtual Address
-*
-* RETURNS:
-*
-*       Type	    	: HW_STATUS
-*       Description     : RET_OK		 -- No errors occured
-*			 RET_BAD_NULL_PARAM     -- A Pointer Paramater
-*						   was set to NULL
-*			 RET_PARAM_OUT_OF_RANGE -- Input Parameter out
-*						   of Range
-*
-* PURPOSE:	      	: Set MMU_CAM reg
-*
-* METHOD:	       	: Check the Input parameters and set the CAM entry.
-*/
-static HW_STATUS MMU_SetCAMEntry(const void __iomem *baseAddress,
-				   const u32    pageSize,
-				   const u32    preservedBit,
-				   const u32    validBit,
-				   const u32    virtualAddrTag);
+ * FUNCTION	      : mmu_set_cam_entry
+ *
+ * INPUTS:
+ *
+ *       Identifier      : baseAddress
+ *       TypE		: const u32
+ *       Description     : Base Address of instance of MMU module
+ *
+ *       Identifier      : pageSize
+ *       TypE		: const u32
+ *       Description     : It indicates the page size
+ *
+ *       Identifier      : preservedBit
+ *       Type		: const u32
+ *       Description     : It indicates the TLB entry is preserved entry
+ *							or not
+ *
+ *       Identifier      : validBit
+ *       Type		: const u32
+ *       Description     : It indicates the TLB entry is valid entry or not
+ *
+ *
+ *       Identifier      : virtual_addr_tag
+ *       Type	    	: const u32
+ *       Description     : virtual Address
+ *
+ * RETURNS:
+ *
+ *       Type	    	: hw_status
+ *       Description     : RET_OK		 -- No errors occured
+ *			 RET_BAD_NULL_PARAM     -- A Pointer Paramater
+ *						   was set to NULL
+ *			 RET_PARAM_OUT_OF_RANGE -- Input Parameter out
+ *						   of Range
+ *
+ * PURPOSE:	      	: Set MMU_CAM reg
+ *
+ * METHOD:	       	: Check the Input parameters and set the CAM entry.
+ */
+static hw_status mmu_set_cam_entry(const void __iomem *baseAddress,
+				   const u32 pageSize,
+				   const u32 preservedBit,
+				   const u32 validBit,
+				   const u32 virtual_addr_tag);
 
 /*
-* FUNCTION	      : MMU_SetRAMEntry
-*
-* INPUTS:
-*
-*       Identifier      : baseAddress
-*       Type	    	: const u32
-*       Description     : Base Address of instance of MMU module
-*
-*       Identifier      : physicalAddr
-*       Type	    	: const u32
-*       Description     : Physical Address to which the corresponding
-*			 virtual   Address shouldpoint
-*
-*       Identifier      : endianism
-*       Type	    	: HW_Endianism_t
-*       Description     : endianism for the given page
-*
-*       Identifier      : elementSize
-*       Type	    	: HW_ElementSize_t
-*       Description     : The element size ( 8,16, 32 or 64 bit)
-*
-*       Identifier      : mixedSize
-*       Type	    	: HW_MMUMixedSize_t
-*       Description     : Element Size to follow CPU or TLB
-*
-* RETURNS:
-*
-*       Type	    	: HW_STATUS
-*       Description     : RET_OK		 -- No errors occured
-*			 RET_BAD_NULL_PARAM     -- A Pointer Paramater
-*							was set to NULL
-*			 RET_PARAM_OUT_OF_RANGE -- Input Parameter
-*							out of Range
-*
-* PURPOSE:	      : Set MMU_CAM reg
-*
-* METHOD:	       : Check the Input parameters and set the RAM entry.
-*/
-static HW_STATUS MMU_SetRAMEntry(const void __iomem *baseAddress,
-				   const u32	physicalAddr,
-				   enum HW_Endianism_t      endianism,
-				   enum HW_ElementSize_t    elementSize,
-				   enum HW_MMUMixedSize_t   mixedSize);
+ * FUNCTION	      : mmu_set_ram_entry
+ *
+ * INPUTS:
+ *
+ *       Identifier      : baseAddress
+ *       Type	    	: const u32
+ *       Description     : Base Address of instance of MMU module
+ *
+ *       Identifier      : physicalAddr
+ *       Type	    	: const u32
+ *       Description     : Physical Address to which the corresponding
+ *			 virtual   Address shouldpoint
+ *
+ *       Identifier      : endianism
+ *       Type	    	: hw_endianism_t
+ *       Description     : endianism for the given page
+ *
+ *       Identifier      : element_size
+ *       Type	    	: hw_element_size_t
+ *       Description     : The element size ( 8,16, 32 or 64 bit)
+ *
+ *       Identifier      : mixed_size
+ *       Type	    	: hw_mmu_mixed_size_t
+ *       Description     : Element Size to follow CPU or TLB
+ *
+ * RETURNS:
+ *
+ *       Type	    	: hw_status
+ *       Description     : RET_OK		 -- No errors occured
+ *			 RET_BAD_NULL_PARAM     -- A Pointer Paramater
+ *							was set to NULL
+ *			 RET_PARAM_OUT_OF_RANGE -- Input Parameter
+ *							out of Range
+ *
+ * PURPOSE:	      : Set MMU_CAM reg
+ *
+ * METHOD:	       : Check the Input parameters and set the RAM entry.
+ */
+static hw_status mmu_set_ram_entry(const void __iomem *baseAddress,
+				   const u32 physicalAddr,
+				   enum hw_endianism_t endianism,
+				   enum hw_element_size_t element_size,
+				   enum hw_mmu_mixed_size_t mixed_size);
 
 /* HW FUNCTIONS */
 
-HW_STATUS HW_MMU_Enable(const void __iomem *baseAddress)
+hw_status hw_mmu_enable(const void __iomem *baseAddress)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    MMUMMU_CNTLMMUEnableWrite32(baseAddress, HW_SET);
+	MMUMMU_CNTLMMU_ENABLE_WRITE32(baseAddress, HW_SET);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_Disable(const void __iomem *baseAddress)
+hw_status hw_mmu_disable(const void __iomem *baseAddress)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    MMUMMU_CNTLMMUEnableWrite32(baseAddress, HW_CLEAR);
+	MMUMMU_CNTLMMU_ENABLE_WRITE32(baseAddress, HW_CLEAR);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_NumLockedSet(const void __iomem *baseAddress,
+hw_status hw_mmu_num_locked_set(const void __iomem *baseAddress,
 				u32 numLockedEntries)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    MMUMMU_LOCKBaseValueWrite32(baseAddress, numLockedEntries);
+	MMUMMU_LOCK_BASE_VALUE_WRITE32(baseAddress, numLockedEntries);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_VictimNumSet(const void __iomem *baseAddress,
+hw_status hw_mmu_victim_num_set(const void __iomem *baseAddress,
 				u32 victimEntryNum)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    MMUMMU_LOCKCurrentVictimWrite32(baseAddress, victimEntryNum);
+	MMUMMU_LOCK_CURRENT_VICTIM_WRITE32(baseAddress, victimEntryNum);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_EventAck(const void __iomem *baseAddress, u32 irqMask)
+hw_status hw_mmu_event_ack(const void __iomem *baseAddress, u32 irqMask)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    MMUMMU_IRQSTATUSWriteRegister32(baseAddress, irqMask);
+	MMUMMU_IRQSTATUS_WRITE_REGISTER32(baseAddress, irqMask);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_EventDisable(const void __iomem *baseAddress,
-				u32 irqMask)
+hw_status hw_mmu_event_disable(const void __iomem *baseAddress, u32 irqMask)
 {
-    HW_STATUS status = RET_OK;
-    u32 irqReg;
+	hw_status status = RET_OK;
+	u32 irq_reg;
 
-    irqReg = MMUMMU_IRQENABLEReadRegister32(baseAddress);
+	irq_reg = MMUMMU_IRQENABLE_READ_REGISTER32(baseAddress);
 
-    MMUMMU_IRQENABLEWriteRegister32(baseAddress, irqReg & ~irqMask);
+	MMUMMU_IRQENABLE_WRITE_REGISTER32(baseAddress, irq_reg & ~irqMask);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_EventEnable(const void __iomem *baseAddress, u32 irqMask)
+hw_status hw_mmu_event_enable(const void __iomem *baseAddress, u32 irqMask)
 {
-    HW_STATUS status = RET_OK;
-    u32 irqReg;
+	hw_status status = RET_OK;
+	u32 irq_reg;
 
-    irqReg = MMUMMU_IRQENABLEReadRegister32(baseAddress);
+	irq_reg = MMUMMU_IRQENABLE_READ_REGISTER32(baseAddress);
 
-    MMUMMU_IRQENABLEWriteRegister32(baseAddress, irqReg | irqMask);
+	MMUMMU_IRQENABLE_WRITE_REGISTER32(baseAddress, irq_reg | irqMask);
 
-    return status;
+	return status;
 }
 
-
-HW_STATUS HW_MMU_EventStatus(const void __iomem *baseAddress, u32 *irqMask)
+hw_status hw_mmu_event_status(const void __iomem *baseAddress, u32 *irqMask)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    *irqMask = MMUMMU_IRQSTATUSReadRegister32(baseAddress);
+	*irqMask = MMUMMU_IRQSTATUS_READ_REGISTER32(baseAddress);
 
-    return status;
+	return status;
 }
 
-
-HW_STATUS HW_MMU_FaultAddrRead(const void __iomem *baseAddress, u32 *addr)
+hw_status hw_mmu_fault_addr_read(const void __iomem *baseAddress, u32 *addr)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    /*Check the input Parameters*/
-    CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
-		      RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+	/*Check the input Parameters */
+	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+			  RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
 
-    /* read values from register */
-    *addr = MMUMMU_FAULT_ADReadRegister32(baseAddress);
+	/* read values from register */
+	*addr = MMUMMU_FAULT_AD_READ_REGISTER32(baseAddress);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_TTBSet(const void __iomem *baseAddress, u32 TTBPhysAddr)
+hw_status hw_mmu_ttb_set(const void __iomem *baseAddress, u32 TTBPhysAddr)
 {
-    HW_STATUS status = RET_OK;
-    u32 loadTTB;
+	hw_status status = RET_OK;
+	u32 load_ttb;
 
-   /*Check the input Parameters*/
-   CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
-		     RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+	/*Check the input Parameters */
+	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+			  RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
 
-   loadTTB = TTBPhysAddr & ~0x7FUL;
-   /* write values to register */
-   MMUMMU_TTBWriteRegister32(baseAddress, loadTTB);
+	load_ttb = TTBPhysAddr & ~0x7FUL;
+	/* write values to register */
+	MMUMMU_TTB_WRITE_REGISTER32(baseAddress, load_ttb);
 
-   return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_TWLEnable(const void __iomem *baseAddress)
+hw_status hw_mmu_twl_enable(const void __iomem *baseAddress)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    MMUMMU_CNTLTWLEnableWrite32(baseAddress, HW_SET);
+	MMUMMU_CNTLTWL_ENABLE_WRITE32(baseAddress, HW_SET);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_TWLDisable(const void __iomem *baseAddress)
+hw_status hw_mmu_twl_disable(const void __iomem *baseAddress)
 {
-    HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-    MMUMMU_CNTLTWLEnableWrite32(baseAddress, HW_CLEAR);
+	MMUMMU_CNTLTWL_ENABLE_WRITE32(baseAddress, HW_CLEAR);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_TLBFlush(const void __iomem *baseAddress, u32 virtualAddr,
-			     u32 pageSize)
+hw_status hw_mmu_tlb_flush(const void __iomem *baseAddress, u32 virtualAddr,
+			   u32 pageSize)
 {
-    HW_STATUS status = RET_OK;
-    u32 virtualAddrTag;
-    enum HW_MMUPageSize_t pgSizeBits;
+	hw_status status = RET_OK;
+	u32 virtual_addr_tag;
+	enum hw_mmu_page_size_t pg_size_bits;
 
-    switch (pageSize) {
-    case HW_PAGE_SIZE_4KB:
-	pgSizeBits = HW_MMU_SMALL_PAGE;
-	break;
+	switch (pageSize) {
+	case HW_PAGE_SIZE4KB:
+		pg_size_bits = HW_MMU_SMALL_PAGE;
+		break;
 
-    case HW_PAGE_SIZE_64KB:
-	pgSizeBits = HW_MMU_LARGE_PAGE;
-	break;
+	case HW_PAGE_SIZE64KB:
+		pg_size_bits = HW_MMU_LARGE_PAGE;
+		break;
 
-    case HW_PAGE_SIZE_1MB:
-	pgSizeBits = HW_MMU_SECTION;
-	break;
+	case HW_PAGE_SIZE1MB:
+		pg_size_bits = HW_MMU_SECTION;
+		break;
 
-    case HW_PAGE_SIZE_16MB:
-	pgSizeBits = HW_MMU_SUPERSECTION;
-	break;
+	case HW_PAGE_SIZE16MB:
+		pg_size_bits = HW_MMU_SUPERSECTION;
+		break;
 
-    default:
-	return RET_FAIL;
-    }
+	default:
+		return RET_FAIL;
+	}
 
-    /* Generate the 20-bit tag from virtual address */
-    virtualAddrTag = ((virtualAddr & MMU_ADDR_MASK) >> 12);
+	/* Generate the 20-bit tag from virtual address */
+	virtual_addr_tag = ((virtualAddr & MMU_ADDR_MASK) >> 12);
 
-    MMU_SetCAMEntry(baseAddress, pgSizeBits, 0, 0, virtualAddrTag);
+	mmu_set_cam_entry(baseAddress, pg_size_bits, 0, 0, virtual_addr_tag);
 
-    MMU_FlushEntry(baseAddress);
+	mmu_flush_entry(baseAddress);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_TLBAdd(const void __iomem *baseAddress,
-			   u32	      physicalAddr,
-			   u32	      virtualAddr,
-			   u32	      pageSize,
-			   u32	      entryNum,
-			   struct HW_MMUMapAttrs_t    *mapAttrs,
-			   enum HW_SetClear_t       preservedBit,
-			   enum HW_SetClear_t       validBit)
+hw_status hw_mmu_tlb_add(const void __iomem *baseAddress,
+			 u32 physicalAddr,
+			 u32 virtualAddr,
+			 u32 pageSize,
+			 u32 entryNum,
+			 struct hw_mmu_map_attrs_t *map_attrs,
+			 s8 preservedBit, s8 validBit)
 {
-    HW_STATUS  status = RET_OK;
-    u32 lockReg;
-    u32 virtualAddrTag;
-    enum HW_MMUPageSize_t mmuPgSize;
+	hw_status status = RET_OK;
+	u32 lock_reg;
+	u32 virtual_addr_tag;
+	enum hw_mmu_page_size_t mmu_pg_size;
 
-    /*Check the input Parameters*/
-    CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
-		      RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
-    CHECK_INPUT_RANGE_MIN0(pageSize, MMU_PAGE_MAX, RET_PARAM_OUT_OF_RANGE,
-			   RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
-    CHECK_INPUT_RANGE_MIN0(mapAttrs->elementSize, MMU_ELEMENTSIZE_MAX,
-			RET_PARAM_OUT_OF_RANGE, RES_MMU_BASE +
-			RES_INVALID_INPUT_PARAM);
+	/*Check the input Parameters */
+	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+			  RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_RANGE_MIN0(pageSize, MMU_PAGE_MAX, RET_PARAM_OUT_OF_RANGE,
+			       RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_RANGE_MIN0(map_attrs->element_size, MMU_ELEMENTSIZE_MAX,
+			       RET_PARAM_OUT_OF_RANGE, RES_MMU_BASE +
+			       RES_INVALID_INPUT_PARAM);
 
-    switch (pageSize) {
-    case HW_PAGE_SIZE_4KB:
-	mmuPgSize = HW_MMU_SMALL_PAGE;
-	break;
+	switch (pageSize) {
+	case HW_PAGE_SIZE4KB:
+		mmu_pg_size = HW_MMU_SMALL_PAGE;
+		break;
 
-    case HW_PAGE_SIZE_64KB:
-	mmuPgSize = HW_MMU_LARGE_PAGE;
-	break;
+	case HW_PAGE_SIZE64KB:
+		mmu_pg_size = HW_MMU_LARGE_PAGE;
+		break;
 
-    case HW_PAGE_SIZE_1MB:
-	mmuPgSize = HW_MMU_SECTION;
-	break;
+	case HW_PAGE_SIZE1MB:
+		mmu_pg_size = HW_MMU_SECTION;
+		break;
 
-    case HW_PAGE_SIZE_16MB:
-	mmuPgSize = HW_MMU_SUPERSECTION;
-	break;
+	case HW_PAGE_SIZE16MB:
+		mmu_pg_size = HW_MMU_SUPERSECTION;
+		break;
 
-    default:
-	return RET_FAIL;
-    }
+	default:
+		return RET_FAIL;
+	}
 
-    lockReg = MMUMMU_LOCKReadRegister32(baseAddress);
+	lock_reg = MMUMMU_LOCK_READ_REGISTER32(baseAddress);
 
-    /* Generate the 20-bit tag from virtual address */
-    virtualAddrTag = ((virtualAddr & MMU_ADDR_MASK) >> 12);
+	/* Generate the 20-bit tag from virtual address */
+	virtual_addr_tag = ((virtualAddr & MMU_ADDR_MASK) >> 12);
 
-    /* Write the fields in the CAM Entry Register */
-    MMU_SetCAMEntry(baseAddress,  mmuPgSize, preservedBit, validBit,
-		    virtualAddrTag);
+	/* Write the fields in the CAM Entry Register */
+	mmu_set_cam_entry(baseAddress, mmu_pg_size, preservedBit, validBit,
+			  virtual_addr_tag);
 
-    /* Write the different fields of the RAM Entry Register */
-    /* endianism of the page,Element Size of the page (8, 16, 32, 64 bit)*/
-    MMU_SetRAMEntry(baseAddress, physicalAddr, mapAttrs->endianism,
-		    mapAttrs->elementSize, mapAttrs->mixedSize);
+	/* Write the different fields of the RAM Entry Register */
+	/* endianism of the page,Element Size of the page (8, 16, 32, 64 bit) */
+	mmu_set_ram_entry(baseAddress, physicalAddr, map_attrs->endianism,
+			  map_attrs->element_size, map_attrs->mixed_size);
 
-    /* Update the MMU Lock Register */
-    /* currentVictim between lockedBaseValue and (MMU_Entries_Number - 1)*/
-    MMUMMU_LOCKCurrentVictimWrite32(baseAddress, entryNum);
+	/* Update the MMU Lock Register */
+	/* currentVictim between lockedBaseValue and (MMU_Entries_Number - 1) */
+	MMUMMU_LOCK_CURRENT_VICTIM_WRITE32(baseAddress, entryNum);
 
-    /* Enable loading of an entry in TLB by writing 1
+	/* Enable loading of an entry in TLB by writing 1
 	   into LD_TLB_REG register */
-    MMUMMU_LD_TLBWriteRegister32(baseAddress, MMU_LOAD_TLB);
-
+	MMUMMU_LD_TLB_WRITE_REGISTER32(baseAddress, MMU_LOAD_TLB);
 
-    MMUMMU_LOCKWriteRegister32(baseAddress, lockReg);
+	MMUMMU_LOCK_WRITE_REGISTER32(baseAddress, lock_reg);
 
-    return status;
+	return status;
 }
 
-HW_STATUS HW_MMU_PteSet(const u32	pgTblVa,
-			   u32	      physicalAddr,
-			   u32	      virtualAddr,
-			   u32	      pageSize,
-			   struct HW_MMUMapAttrs_t    *mapAttrs)
-{
-    HW_STATUS status = RET_OK;
-    u32 pteAddr, pteVal;
-    s32 numEntries = 1;
-
-    switch (pageSize) {
-    case HW_PAGE_SIZE_4KB:
-	pteAddr = HW_MMU_PteAddrL2(pgTblVa,
-				    virtualAddr & MMU_SMALL_PAGE_MASK);
-	pteVal = ((physicalAddr & MMU_SMALL_PAGE_MASK) |
-		    (mapAttrs->endianism << 9) |
-		    (mapAttrs->elementSize << 4) |
-		    (mapAttrs->mixedSize << 11) | 2
-		  );
-	break;
-
-    case HW_PAGE_SIZE_64KB:
-	numEntries = 16;
-	pteAddr = HW_MMU_PteAddrL2(pgTblVa,
-				    virtualAddr & MMU_LARGE_PAGE_MASK);
-	pteVal = ((physicalAddr & MMU_LARGE_PAGE_MASK) |
-		    (mapAttrs->endianism << 9) |
-		    (mapAttrs->elementSize << 4) |
-		    (mapAttrs->mixedSize << 11) | 1
-		  );
-	break;
-
-    case HW_PAGE_SIZE_1MB:
-	pteAddr = HW_MMU_PteAddrL1(pgTblVa,
-				    virtualAddr & MMU_SECTION_ADDR_MASK);
-	pteVal = ((((physicalAddr & MMU_SECTION_ADDR_MASK) |
-		     (mapAttrs->endianism << 15) |
-		     (mapAttrs->elementSize << 10) |
-		     (mapAttrs->mixedSize << 17)) &
-		     ~0x40000) | 0x2
-		 );
-	break;
-
-    case HW_PAGE_SIZE_16MB:
-	numEntries = 16;
-	pteAddr = HW_MMU_PteAddrL1(pgTblVa,
-				    virtualAddr & MMU_SSECTION_ADDR_MASK);
-	pteVal = (((physicalAddr & MMU_SSECTION_ADDR_MASK) |
-		      (mapAttrs->endianism << 15) |
-		      (mapAttrs->elementSize << 10) |
-		      (mapAttrs->mixedSize << 17)
-		    ) | 0x40000 | 0x2
-		  );
-	break;
-
-    case HW_MMU_COARSE_PAGE_SIZE:
-	pteAddr = HW_MMU_PteAddrL1(pgTblVa,
-				    virtualAddr & MMU_SECTION_ADDR_MASK);
-	pteVal = (physicalAddr & MMU_PAGE_TABLE_MASK) | 1;
-	break;
-
-    default:
-	return RET_FAIL;
-    }
-
-    while (--numEntries >= 0)
-	((u32 *)pteAddr)[numEntries] = pteVal;
-
-    return status;
-}
-
-HW_STATUS HW_MMU_PteClear(const u32  pgTblVa,
-			     u32	virtualAddr,
-			     u32	pgSize)
-{
-    HW_STATUS status = RET_OK;
-    u32 pteAddr;
-    s32 numEntries = 1;
-
-    switch (pgSize) {
-    case HW_PAGE_SIZE_4KB:
-	pteAddr = HW_MMU_PteAddrL2(pgTblVa,
-				    virtualAddr & MMU_SMALL_PAGE_MASK);
-	break;
-
-    case HW_PAGE_SIZE_64KB:
-	numEntries = 16;
-	pteAddr = HW_MMU_PteAddrL2(pgTblVa,
-				    virtualAddr & MMU_LARGE_PAGE_MASK);
-	break;
-
-    case HW_PAGE_SIZE_1MB:
-    case HW_MMU_COARSE_PAGE_SIZE:
-	pteAddr = HW_MMU_PteAddrL1(pgTblVa,
-				    virtualAddr & MMU_SECTION_ADDR_MASK);
-	break;
-
-    case HW_PAGE_SIZE_16MB:
-	numEntries = 16;
-	pteAddr = HW_MMU_PteAddrL1(pgTblVa,
-				    virtualAddr & MMU_SSECTION_ADDR_MASK);
-	break;
-
-    default:
-	return RET_FAIL;
-    }
-
-    while (--numEntries >= 0)
-	((u32 *)pteAddr)[numEntries] = 0;
-
-    return status;
-}
-
-/* MMU_FlushEntry */
-static HW_STATUS MMU_FlushEntry(const void __iomem *baseAddress)
-{
-   HW_STATUS status = RET_OK;
-   u32 flushEntryData = 0x1;
-
-   /*Check the input Parameters*/
-   CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
-		     RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
-
-   /* write values to register */
-   MMUMMU_FLUSH_ENTRYWriteRegister32(baseAddress, flushEntryData);
-
-   return status;
-}
-
-/* MMU_SetCAMEntry */
-static HW_STATUS MMU_SetCAMEntry(const void __iomem *baseAddress,
-				   const u32    pageSize,
-				   const u32    preservedBit,
-				   const u32    validBit,
-				   const u32    virtualAddrTag)
-{
-   HW_STATUS status = RET_OK;
-   u32 mmuCamReg;
-
-   /*Check the input Parameters*/
-   CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
-		     RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
-
-   mmuCamReg = (virtualAddrTag << 12);
-   mmuCamReg = (mmuCamReg) | (pageSize) |  (validBit << 2) |
-	       (preservedBit << 3) ;
-
-   /* write values to register */
-   MMUMMU_CAMWriteRegister32(baseAddress, mmuCamReg);
-
-   return status;
-}
-
-/* MMU_SetRAMEntry */
-static HW_STATUS MMU_SetRAMEntry(const void __iomem *baseAddress,
-				   const u32       physicalAddr,
-				   enum HW_Endianism_t     endianism,
-				   enum HW_ElementSize_t   elementSize,
-				   enum HW_MMUMixedSize_t  mixedSize)
-{
-   HW_STATUS status = RET_OK;
-   u32 mmuRamReg;
-
-   /*Check the input Parameters*/
-   CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
-		     RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
-   CHECK_INPUT_RANGE_MIN0(elementSize, MMU_ELEMENTSIZE_MAX,
-		   RET_PARAM_OUT_OF_RANGE, RES_MMU_BASE +
-		   RES_INVALID_INPUT_PARAM);
-
-
-   mmuRamReg = (physicalAddr & MMU_ADDR_MASK);
-   mmuRamReg = (mmuRamReg) | ((endianism << 9) |  (elementSize << 7) |
-	       (mixedSize << 6));
+hw_status hw_mmu_pte_set(const u32 pg_tbl_va,
+			 u32 physicalAddr,
+			 u32 virtualAddr,
+			 u32 pageSize, struct hw_mmu_map_attrs_t *map_attrs)
+{
+	hw_status status = RET_OK;
+	u32 pte_addr, pte_val;
+	s32 num_entries = 1;
+
+	switch (pageSize) {
+	case HW_PAGE_SIZE4KB:
+		pte_addr = hw_mmu_pte_addr_l2(pg_tbl_va,
+					      virtualAddr &
+					      MMU_SMALL_PAGE_MASK);
+		pte_val =
+		    ((physicalAddr & MMU_SMALL_PAGE_MASK) |
+		     (map_attrs->endianism << 9) | (map_attrs->
+						    element_size << 4) |
+		     (map_attrs->mixed_size << 11) | 2);
+		break;
+
+	case HW_PAGE_SIZE64KB:
+		num_entries = 16;
+		pte_addr = hw_mmu_pte_addr_l2(pg_tbl_va,
+					      virtualAddr &
+					      MMU_LARGE_PAGE_MASK);
+		pte_val =
+		    ((physicalAddr & MMU_LARGE_PAGE_MASK) |
+		     (map_attrs->endianism << 9) | (map_attrs->
+						    element_size << 4) |
+		     (map_attrs->mixed_size << 11) | 1);
+		break;
+
+	case HW_PAGE_SIZE1MB:
+		pte_addr = hw_mmu_pte_addr_l1(pg_tbl_va,
+					      virtualAddr &
+					      MMU_SECTION_ADDR_MASK);
+		pte_val =
+		    ((((physicalAddr & MMU_SECTION_ADDR_MASK) |
+		       (map_attrs->endianism << 15) | (map_attrs->
+						       element_size << 10) |
+		       (map_attrs->mixed_size << 17)) & ~0x40000) | 0x2);
+		break;
+
+	case HW_PAGE_SIZE16MB:
+		num_entries = 16;
+		pte_addr = hw_mmu_pte_addr_l1(pg_tbl_va,
+					      virtualAddr &
+					      MMU_SSECTION_ADDR_MASK);
+		pte_val =
+		    (((physicalAddr & MMU_SSECTION_ADDR_MASK) |
+		      (map_attrs->endianism << 15) | (map_attrs->
+						      element_size << 10) |
+		      (map_attrs->mixed_size << 17)
+		     ) | 0x40000 | 0x2);
+		break;
+
+	case HW_MMU_COARSE_PAGE_SIZE:
+		pte_addr = hw_mmu_pte_addr_l1(pg_tbl_va,
+					      virtualAddr &
+					      MMU_SECTION_ADDR_MASK);
+		pte_val = (physicalAddr & MMU_PAGE_TABLE_MASK) | 1;
+		break;
+
+	default:
+		return RET_FAIL;
+	}
+
+	while (--num_entries >= 0)
+		((u32 *) pte_addr)[num_entries] = pte_val;
+
+	return status;
+}
+
+hw_status hw_mmu_pte_clear(const u32 pg_tbl_va, u32 virtualAddr, u32 page_size)
+{
+	hw_status status = RET_OK;
+	u32 pte_addr;
+	s32 num_entries = 1;
+
+	switch (page_size) {
+	case HW_PAGE_SIZE4KB:
+		pte_addr = hw_mmu_pte_addr_l2(pg_tbl_va,
+					      virtualAddr &
+					      MMU_SMALL_PAGE_MASK);
+		break;
+
+	case HW_PAGE_SIZE64KB:
+		num_entries = 16;
+		pte_addr = hw_mmu_pte_addr_l2(pg_tbl_va,
+					      virtualAddr &
+					      MMU_LARGE_PAGE_MASK);
+		break;
+
+	case HW_PAGE_SIZE1MB:
+	case HW_MMU_COARSE_PAGE_SIZE:
+		pte_addr = hw_mmu_pte_addr_l1(pg_tbl_va,
+					      virtualAddr &
+					      MMU_SECTION_ADDR_MASK);
+		break;
+
+	case HW_PAGE_SIZE16MB:
+		num_entries = 16;
+		pte_addr = hw_mmu_pte_addr_l1(pg_tbl_va,
+					      virtualAddr &
+					      MMU_SSECTION_ADDR_MASK);
+		break;
+
+	default:
+		return RET_FAIL;
+	}
+
+	while (--num_entries >= 0)
+		((u32 *) pte_addr)[num_entries] = 0;
+
+	return status;
+}
+
+/* mmu_flush_entry */
+static hw_status mmu_flush_entry(const void __iomem *baseAddress)
+{
+	hw_status status = RET_OK;
+	u32 flush_entry_data = 0x1;
+
+	/*Check the input Parameters */
+	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+			  RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+
+	/* write values to register */
+	MMUMMU_FLUSH_ENTRY_WRITE_REGISTER32(baseAddress, flush_entry_data);
+
+	return status;
+}
+
+/* mmu_set_cam_entry */
+static hw_status mmu_set_cam_entry(const void __iomem *baseAddress,
+				   const u32 pageSize,
+				   const u32 preservedBit,
+				   const u32 validBit,
+				   const u32 virtual_addr_tag)
+{
+	hw_status status = RET_OK;
+	u32 mmu_cam_reg;
+
+	/*Check the input Parameters */
+	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+			  RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+
+	mmu_cam_reg = (virtual_addr_tag << 12);
+	mmu_cam_reg = (mmu_cam_reg) | (pageSize) | (validBit << 2) |
+	    (preservedBit << 3);
+
+	/* write values to register */
+	MMUMMU_CAM_WRITE_REGISTER32(baseAddress, mmu_cam_reg);
+
+	return status;
+}
+
+/* mmu_set_ram_entry */
+static hw_status mmu_set_ram_entry(const void __iomem *baseAddress,
+				   const u32 physicalAddr,
+				   enum hw_endianism_t endianism,
+				   enum hw_element_size_t element_size,
+				   enum hw_mmu_mixed_size_t mixed_size)
+{
+	hw_status status = RET_OK;
+	u32 mmu_ram_reg;
+
+	/*Check the input Parameters */
+	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+			  RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_RANGE_MIN0(element_size, MMU_ELEMENTSIZE_MAX,
+			       RET_PARAM_OUT_OF_RANGE, RES_MMU_BASE +
+			       RES_INVALID_INPUT_PARAM);
+
+	mmu_ram_reg = (physicalAddr & MMU_ADDR_MASK);
+	mmu_ram_reg = (mmu_ram_reg) | ((endianism << 9) | (element_size << 7) |
+				       (mixed_size << 6));
 
-   /* write values to register */
-   MMUMMU_RAMWriteRegister32(baseAddress, mmuRamReg);
+	/* write values to register */
+	MMUMMU_RAM_WRITE_REGISTER32(baseAddress, mmu_ram_reg);
 
-   return status;
+	return status;
 
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_mmu.h kernel-power-2.6.28.new/drivers/dsp/bridge/hw/hw_mmu.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_mmu.h	2011-10-11 13:51:00.277597753 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/hw_mmu.h	2011-10-23 08:22:37.619928000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * MMU types and API declarations
+ *
  * Copyright (C) 2007 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,21 +16,8 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== hw_mmu.h ========
- *  Description:
- *      MMU types and API declarations
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb  Moved & renamed endianness, page size, element size
-		    TLBAdd takes in MMUMapAttrs instead of separate arguments
- *! 08-Mar-2004 sb  Added the Page Table management APIs
- *! 16 Feb 2003 sb: Initial version
- */
-#ifndef __HW_MMU_H
-#define __HW_MMU_H
+#ifndef _HW_MMU_H
+#define _HW_MMU_H
 
 #include <linux/types.h>
 
@@ -38,140 +27,135 @@
 
 #define HW_MMU_COARSE_PAGE_SIZE 0x400
 
-/* HW_MMUMixedSize_t:  Enumerated Type used to specify whether to follow
+/* hw_mmu_mixed_size_t:  Enumerated Type used to specify whether to follow
 			CPU/TLB Element size */
-enum HW_MMUMixedSize_t {
+enum hw_mmu_mixed_size_t {
 	HW_MMU_TLBES,
 	HW_MMU_CPUES
+};
 
-} ;
-
-/* HW_MMUMapAttrs_t:  Struct containing MMU mapping attributes */
-struct HW_MMUMapAttrs_t {
-	enum HW_Endianism_t     endianism;
-	enum HW_ElementSize_t   elementSize;
-	enum HW_MMUMixedSize_t  mixedSize;
+/* hw_mmu_map_attrs_t:  Struct containing MMU mapping attributes */
+struct hw_mmu_map_attrs_t {
+	enum hw_endianism_t endianism;
+	enum hw_element_size_t element_size;
+	enum hw_mmu_mixed_size_t mixed_size;
 	bool donotlockmpupage;
-} ;
+};
 
-extern HW_STATUS HW_MMU_Enable(const void __iomem *baseAddress);
+extern hw_status hw_mmu_enable(const void __iomem *baseAddress);
 
-extern HW_STATUS HW_MMU_Disable(const void __iomem *baseAddress);
+extern hw_status hw_mmu_disable(const void __iomem *baseAddress);
 
-extern HW_STATUS HW_MMU_NumLockedSet(const void __iomem *baseAddress,
-					u32 numLockedEntries);
+extern hw_status hw_mmu_num_locked_set(const void __iomem *baseAddress,
+				       u32 numLockedEntries);
 
-extern HW_STATUS HW_MMU_VictimNumSet(const void __iomem *baseAddress,
-					u32 victimEntryNum);
+extern hw_status hw_mmu_victim_num_set(const void __iomem *baseAddress,
+				       u32 victimEntryNum);
 
 /* For MMU faults */
-extern HW_STATUS HW_MMU_EventAck(const void __iomem *baseAddress,
-				    u32 irqMask);
+extern hw_status hw_mmu_event_ack(const void __iomem *baseAddress,
+				  u32 irqMask);
 
-extern HW_STATUS HW_MMU_EventDisable(const void __iomem *baseAddress,
-					u32 irqMask);
+extern hw_status hw_mmu_event_disable(const void __iomem *baseAddress,
+				      u32 irqMask);
 
-extern HW_STATUS HW_MMU_EventEnable(const void __iomem *baseAddress,
-				       u32 irqMask);
+extern hw_status hw_mmu_event_enable(const void __iomem *baseAddress,
+				     u32 irqMask);
 
-extern HW_STATUS HW_MMU_EventStatus(const void __iomem *baseAddress,
-				       u32 *irqMask);
+extern hw_status hw_mmu_event_status(const void __iomem *baseAddress,
+				     u32 *irqMask);
 
-extern HW_STATUS HW_MMU_FaultAddrRead(const void __iomem *baseAddress,
-					 u32 *addr);
+extern hw_status hw_mmu_fault_addr_read(const void __iomem *baseAddress,
+					u32 *addr);
 
 /* Set the TT base address */
-extern HW_STATUS HW_MMU_TTBSet(const void __iomem *baseAddress,
-				  u32 TTBPhysAddr);
-
-extern HW_STATUS HW_MMU_TWLEnable(const void __iomem *baseAddress);
+extern hw_status hw_mmu_ttb_set(const void __iomem *baseAddress,
+				u32 TTBPhysAddr);
 
-extern HW_STATUS HW_MMU_TWLDisable(const void __iomem *baseAddress);
+extern hw_status hw_mmu_twl_enable(const void __iomem *baseAddress);
 
-extern HW_STATUS HW_MMU_TLBFlush(const void __iomem *baseAddress,
-				    u32 virtualAddr,
-				    u32 pageSize);
-
-extern HW_STATUS HW_MMU_TLBAdd(const void __iomem *baseAddress,
-				  u32	   physicalAddr,
-				  u32	   virtualAddr,
-				  u32	   pageSize,
-				  u32	    entryNum,
-				  struct HW_MMUMapAttrs_t *mapAttrs,
-				  enum HW_SetClear_t    preservedBit,
-				  enum HW_SetClear_t    validBit);
+extern hw_status hw_mmu_twl_disable(const void __iomem *baseAddress);
 
+extern hw_status hw_mmu_tlb_flush(const void __iomem *baseAddress,
+				  u32 virtualAddr, u32 pageSize);
+
+extern hw_status hw_mmu_tlb_add(const void __iomem *baseAddress,
+				u32 physicalAddr,
+				u32 virtualAddr,
+				u32 pageSize,
+				u32 entryNum,
+				struct hw_mmu_map_attrs_t *map_attrs,
+				s8 preservedBit, s8 validBit);
 
 /* For PTEs */
-extern HW_STATUS HW_MMU_PteSet(const u32     pgTblVa,
-				  u32	   physicalAddr,
-				  u32	   virtualAddr,
-				  u32	   pageSize,
-				  struct HW_MMUMapAttrs_t *mapAttrs);
-
-extern HW_STATUS HW_MMU_PteClear(const u32   pgTblVa,
-				    u32	 pgSize,
-				    u32	 virtualAddr);
+extern hw_status hw_mmu_pte_set(const u32 pg_tbl_va,
+				u32 physicalAddr,
+				u32 virtualAddr,
+				u32 pageSize,
+				struct hw_mmu_map_attrs_t *map_attrs);
+
+extern hw_status hw_mmu_pte_clear(const u32 pg_tbl_va,
+				  u32 page_size, u32 virtualAddr);
 
-static inline u32 HW_MMU_PteAddrL1(u32 L1_base, u32 va)
+static inline u32 hw_mmu_pte_addr_l1(u32 L1_base, u32 va)
 {
-	u32 pteAddr;
-	u32 VA_31_to_20;
+	u32 pte_addr;
+	u32 va31_to20;
 
-	VA_31_to_20  = va >> (20 - 2); /* Left-shift by 2 here itself */
-	VA_31_to_20 &= 0xFFFFFFFCUL;
-	pteAddr = L1_base + VA_31_to_20;
+	va31_to20 = va >> (20 - 2);	/* Left-shift by 2 here itself */
+	va31_to20 &= 0xFFFFFFFCUL;
+	pte_addr = L1_base + va31_to20;
 
-	return pteAddr;
+	return pte_addr;
 }
 
-static inline u32 HW_MMU_PteAddrL2(u32 L2_base, u32 va)
+static inline u32 hw_mmu_pte_addr_l2(u32 L2_base, u32 va)
 {
-	u32 pteAddr;
+	u32 pte_addr;
 
-	pteAddr = (L2_base & 0xFFFFFC00) | ((va >> 10) & 0x3FC);
+	pte_addr = (L2_base & 0xFFFFFC00) | ((va >> 10) & 0x3FC);
 
-	return pteAddr;
+	return pte_addr;
 }
 
-static inline u32 HW_MMU_PteCoarseL1(u32 pteVal)
+static inline u32 hw_mmu_pte_coarse_l1(u32 pte_val)
 {
-	u32 pteCoarse;
+	u32 pte_coarse;
 
-	pteCoarse = pteVal & 0xFFFFFC00;
+	pte_coarse = pte_val & 0xFFFFFC00;
 
-	return pteCoarse;
+	return pte_coarse;
 }
 
-static inline u32 HW_MMU_PteSizeL1(u32 pteVal)
+static inline u32 hw_mmu_pte_size_l1(u32 pte_val)
 {
-	u32 pteSize = 0;
+	u32 pte_size = 0;
 
-	if ((pteVal & 0x3) == 0x1) {
+	if ((pte_val & 0x3) == 0x1) {
 		/* Points to L2 PT */
-		pteSize = HW_MMU_COARSE_PAGE_SIZE;
+		pte_size = HW_MMU_COARSE_PAGE_SIZE;
 	}
 
-	if ((pteVal & 0x3) == 0x2) {
-		if (pteVal & (1 << 18))
-			pteSize = HW_PAGE_SIZE_16MB;
+	if ((pte_val & 0x3) == 0x2) {
+		if (pte_val & (1 << 18))
+			pte_size = HW_PAGE_SIZE16MB;
 		else
-			pteSize = HW_PAGE_SIZE_1MB;
+			pte_size = HW_PAGE_SIZE1MB;
 	}
 
-	return pteSize;
+	return pte_size;
 }
 
-static inline u32 HW_MMU_PteSizeL2(u32 pteVal)
+static inline u32 hw_mmu_pte_size_l2(u32 pte_val)
 {
-    u32 pteSize = 0;
+	u32 pte_size = 0;
 
-    if (pteVal & 0x2)
-	pteSize = HW_PAGE_SIZE_4KB;
-    else if (pteVal & 0x1)
-	pteSize = HW_PAGE_SIZE_64KB;
+	if (pte_val & 0x2)
+		pte_size = HW_PAGE_SIZE4KB;
+	else if (pte_val & 0x1)
+		pte_size = HW_PAGE_SIZE64KB;
 
-    return pteSize;
+	return pte_size;
 }
 
-#endif  /* __HW_MMU_H */
+#endif /* _HW_MMU_H */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_prcm.c kernel-power-2.6.28.new/drivers/dsp/bridge/hw/hw_prcm.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_prcm.c	2011-10-11 13:51:00.277597753 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/hw_prcm.c	2011-10-23 08:22:37.619928000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * API definitions to configure PRCM (Power, Reset & Clocks Manager)
+ *
  * Copyright (C) 2007 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,62 +16,52 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== hw_prcm.c ========
- *  Description:
- *      API definitions to configure PRCM (Power, Reset & Clocks Manager)
- *
- *! Revision History:
- *! ================
- *! 16 Feb 2003 sb: Initial version
- */
-
 #include <GlobalTypes.h>
 #include "PRCMRegAcM.h"
 #include <hw_defs.h>
 #include <hw_prcm.h>
 
-static HW_STATUS HW_RST_WriteVal(const void __iomem *baseAddress,
-				    enum HW_RstModule_t r,
-				    enum HW_SetClear_t val);
+static hw_status hw_rst_write_val(const void __iomem *baseAddress,
+				  enum hw_rst_module_t r, s8 val);
 
-HW_STATUS HW_RST_Reset(const void __iomem *baseAddress, enum HW_RstModule_t r)
+hw_status hw_rst_reset(const void __iomem *baseAddress, enum hw_rst_module_t r)
 {
-	return HW_RST_WriteVal(baseAddress, r, HW_SET);
+	return hw_rst_write_val(baseAddress, r, HW_SET);
 }
 
-HW_STATUS HW_RST_UnReset(const void __iomem *baseAddress, enum HW_RstModule_t r)
+hw_status hw_rst_un_reset(const void __iomem *baseAddress,
+			  enum hw_rst_module_t r)
 {
-	return HW_RST_WriteVal(baseAddress, r, HW_CLEAR);
+	return hw_rst_write_val(baseAddress, r, HW_CLEAR);
 }
 
-static HW_STATUS HW_RST_WriteVal(const void __iomem *baseAddress,
-				    enum HW_RstModule_t r,
-				    enum HW_SetClear_t val)
+static hw_status hw_rst_write_val(const void __iomem *baseAddress,
+				  enum hw_rst_module_t r, s8 val)
 {
-	HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
 	switch (r) {
 	case HW_RST1_IVA2:
-	    PRM_RSTCTRL_IVA2RST1_DSPWrite32(baseAddress, val);
-	    break;
+		PRM_RSTCTRL_IVA2RST1_DSP_WRITE32(baseAddress, val);
+		break;
 	case HW_RST2_IVA2:
-	    PRM_RSTCTRL_IVA2RST2_DSPWrite32(baseAddress, val);
-	    break;
+		PRM_RSTCTRL_IVA2RST2_DSP_WRITE32(baseAddress, val);
+		break;
 	case HW_RST3_IVA2:
-	    PRM_RSTCTRL_IVA2RST3_DSPWrite32(baseAddress, val);
-	    break;
+		PRM_RSTCTRL_IVA2RST3_DSP_WRITE32(baseAddress, val);
+		break;
 	default:
-	    status = RET_FAIL;
-	    break;
+		status = RET_FAIL;
+		break;
 	}
 	return status;
 }
 
-HW_STATUS HW_PWR_IVA2StateGet(const void __iomem *baseAddress,
-		enum HW_PwrModule_t p, enum HW_PwrState_t *value)
+hw_status hw_pwr_iva2_state_get(const void __iomem *baseAddress,
+				enum hw_pwr_module_t p,
+				enum hw_pwr_state_t *value)
 {
-	HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 	u32 temp;
 
 	switch (p) {
@@ -77,13 +69,13 @@
 		/* wait until Transition is complete */
 		do {
 			/* mdelay(1); */
-			temp = PRCMPM_PWSTST_IVA2InTransitionRead32
-				(baseAddress);
+			temp = PRCMPM_PWSTST_IVA2_IN_TRANSITION_READ32
+			    (baseAddress);
 
 		} while (temp);
 
-		temp = PRCMPM_PWSTST_IVA2ReadRegister32(baseAddress);
-		*value = PRCMPM_PWSTST_IVA2PowerStateStGet32(temp);
+		temp = PRCMPM_PWSTST_IVA2_READ_REGISTER32(baseAddress);
+		*value = PRCMPM_PWSTST_IVA2_POWER_STATE_ST_GET32(temp);
 		break;
 
 	default:
@@ -93,33 +85,35 @@
 	return status;
 }
 
-HW_STATUS HW_PWRST_IVA2RegGet(const void __iomem *baseAddress, u32 *value)
+hw_status hw_pwrst_iva2_reg_get(const void __iomem *baseAddress, u32 *value)
 {
-	HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-	*value = PRCMPM_PWSTST_IVA2ReadRegister32(baseAddress);
+	*value = PRCMPM_PWSTST_IVA2_READ_REGISTER32(baseAddress);
 
 	return status;
 }
 
-
-HW_STATUS HW_PWR_IVA2PowerStateSet(const void __iomem *baseAddress,
-				     enum HW_PwrModule_t p,
-				     enum HW_PwrState_t value)
+hw_status hw_pwr_iva2_power_state_set(const void __iomem *baseAddress,
+				      enum hw_pwr_module_t p,
+				      enum hw_pwr_state_t value)
 {
-	HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
 	switch (p) {
 	case HW_PWR_DOMAIN_DSP:
 		switch (value) {
 		case HW_PWR_STATE_ON:
-			PRCMPM_PWSTCTRL_IVA2PowerStateWriteON32(baseAddress);
+			PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_ON32
+			    (baseAddress);
 			break;
 		case HW_PWR_STATE_RET:
-			PRCMPM_PWSTCTRL_DSPPowerStateWriteRET32(baseAddress);
+			PRCMPM_PWSTCTRL_DSP_POWER_STATE_WRITE_RET32
+			    (baseAddress);
 			break;
 		case HW_PWR_STATE_OFF:
-			PRCMPM_PWSTCTRL_IVA2PowerStateWriteOFF32(baseAddress);
+			PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_OFF32
+			    (baseAddress);
 			break;
 		default:
 			status = RET_FAIL;
@@ -135,33 +129,33 @@
 	return status;
 }
 
-HW_STATUS HW_PWR_CLKCTRL_IVA2RegSet(const void __iomem *baseAddress,
-				      enum HW_TransitionState_t val)
+hw_status hw_pwr_clkctrl_iva2_reg_set(const void __iomem *baseAddress,
+				      enum hw_transition_state_t val)
 {
-	HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-	PRCMCM_CLKSTCTRL_IVA2WriteRegister32(baseAddress, val);
+	PRCMCM_CLKSTCTRL_IVA2_WRITE_REGISTER32(baseAddress, val);
 
 	return status;
 
 }
 
-HW_STATUS HW_RSTST_RegGet(const void __iomem *baseAddress,
-		enum HW_RstModule_t m, u32 *value)
+hw_status hw_rstst_reg_get(const void __iomem *baseAddress,
+			   enum hw_rst_module_t m, u32 *value)
 {
-	HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-	*value = PRCMRM_RSTST_DSPReadRegister32(baseAddress);
+	*value = PRCMRM_RSTST_DSP_READ_REGISTER32(baseAddress);
 
 	return status;
 }
 
-HW_STATUS HW_RSTCTRL_RegGet(const void __iomem *baseAddress,
-		enum HW_RstModule_t m, u32 *value)
+hw_status hw_rstctrl_reg_get(const void __iomem *baseAddress,
+			     enum hw_rst_module_t m, u32 *value)
 {
-	HW_STATUS status = RET_OK;
+	hw_status status = RET_OK;
 
-	*value = PRCMRM_RSTCTRL_DSPReadRegister32(baseAddress);
+	*value = PRCMRM_RSTCTRL_DSP_READ_REGISTER32(baseAddress);
 
 	return status;
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_prcm.h kernel-power-2.6.28.new/drivers/dsp/bridge/hw/hw_prcm.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/hw_prcm.h	2011-10-11 13:51:00.277597753 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/hw_prcm.h	2011-10-23 08:22:37.619928000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * PRCM types and API declarations
+ *
  * Copyright (C) 2007 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,156 +16,141 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== hw_prcm.h ========
- *  Description:
- *      PRCM types and API declarations
- *
- *! Revision History:
- *! ================
- *! 16 Feb 2003 sb: Initial version
- */
-
-#ifndef __HW_PRCM_H
-#define __HW_PRCM_H
+#ifndef _HW_PRCM_H
+#define _HW_PRCM_H
 
 /* HW_ClkModule:  Enumerated Type used to specify the clock domain */
 
-enum HW_ClkModule_t {
+enum hw_clk_module_t {
 /* DSP Domain */
-    HW_CLK_DSP_CPU,
-    HW_CLK_DSP_IPI_MMU,
-    HW_CLK_IVA_ARM,
-    HW_CLK_IVA_COP,	/* IVA Coprocessor */
+	HW_CLK_DSP_CPU,
+	HW_CLK_DSP_IPI_MMU,
+	HW_CLK_IVA_ARM,
+	HW_CLK_IVA_COP,		/* IVA Coprocessor */
 
 /* Core Domain */
-    HW_CLK_FN_WDT4,	/* Functional Clock */
-    HW_CLK_FN_WDT3,
-    HW_CLK_FN_UART2,
-    HW_CLK_FN_UART1,
-    HW_CLK_GPT5,
-    HW_CLK_GPT6,
-    HW_CLK_GPT7,
-    HW_CLK_GPT8,
-
-    HW_CLK_IF_WDT4,	/* Interface Clock */
-    HW_CLK_IF_WDT3,
-    HW_CLK_IF_UART2,
-    HW_CLK_IF_UART1,
-    HW_CLK_IF_MBOX
-
-} ;
-
-enum HW_ClkSubsys_t {
-    HW_CLK_DSPSS,
-    HW_CLK_IVASS
-} ;
+	HW_CLK_FN_WDT4,		/* Functional Clock */
+	HW_CLK_FN_WDT3,
+	HW_CLK_FN_UART2,
+	HW_CLK_FN_UART1,
+	HW_CLK_GPT5,
+	HW_CLK_GPT6,
+	HW_CLK_GPT7,
+	HW_CLK_GPT8,
+
+	HW_CLK_IF_WDT4,		/* Interface Clock */
+	HW_CLK_IF_WDT3,
+	HW_CLK_IF_UART2,
+	HW_CLK_IF_UART1,
+	HW_CLK_IF_MBOX
+};
+
+enum hw_clk_subsys_t {
+	HW_CLK_DSPSS,
+	HW_CLK_IVASS
+};
 
 /* HW_GPtimers:  General purpose timers */
-enum HW_GPtimer_t {
-    HW_GPT5 = 5,
-    HW_GPT6 = 6,
-    HW_GPT7 = 7,
-    HW_GPT8 = 8
-} ;
-
+enum hw_g_ptimer_t {
+	HW_GPT5 = 5,
+	HW_GPT6 = 6,
+	HW_GPT7 = 7,
+	HW_GPT8 = 8
+};
 
 /* GP timers Input clock type:  General purpose timers */
-enum HW_Clocktype_t {
-    HW_CLK_32KHz = 0,
-    HW_CLK_SYS   = 1,
-    HW_CLK_EXT   = 2
-} ;
+enum hw_clocktype_t {
+	HW_CLK32K_HZ = 0,
+	HW_CLK_SYS = 1,
+	HW_CLK_EXT = 2
+};
 
 /* HW_ClkDiv:  Clock divisors */
-enum HW_ClkDiv_t {
-    HW_CLK_DIV_1 = 0x1,
-    HW_CLK_DIV_2 = 0x2,
-    HW_CLK_DIV_3 = 0x3,
-    HW_CLK_DIV_4 = 0x4,
-    HW_CLK_DIV_6 = 0x6,
-    HW_CLK_DIV_8 = 0x8,
-    HW_CLK_DIV_12 = 0xC
-} ;
+enum hw_clk_div_t {
+	HW_CLK_DIV1 = 0x1,
+	HW_CLK_DIV2 = 0x2,
+	HW_CLK_DIV3 = 0x3,
+	HW_CLK_DIV4 = 0x4,
+	HW_CLK_DIV6 = 0x6,
+	HW_CLK_DIV8 = 0x8,
+	HW_CLK_DIV12 = 0xC
+};
 
 /* HW_RstModule:  Enumerated Type used to specify the module to be reset */
-enum HW_RstModule_t {
-    HW_RST1_IVA2,  /* Reset the DSP */
-    HW_RST2_IVA2,  /* Reset MMU and LEON HWa */
-    HW_RST3_IVA2   /* Reset LEON sequencer */
-} ;
+enum hw_rst_module_t {
+	HW_RST1_IVA2,		/* Reset the DSP */
+	HW_RST2_IVA2,		/* Reset MMU and LEON HWa */
+	HW_RST3_IVA2		/* Reset LEON sequencer */
+};
 
 /* HW_PwrModule:  Enumerated Type used to specify the power domain */
-enum HW_PwrModule_t {
+enum hw_pwr_module_t {
 /* Domains */
-    HW_PWR_DOMAIN_CORE,
-    HW_PWR_DOMAIN_MPU,
-    HW_PWR_DOMAIN_WAKEUP,
-    HW_PWR_DOMAIN_DSP,
+	HW_PWR_DOMAIN_CORE,
+	HW_PWR_DOMAIN_MPU,
+	HW_PWR_DOMAIN_WAKEUP,
+	HW_PWR_DOMAIN_DSP,
 
 /* Sub-domains */
-    HW_PWR_DSP_IPI,	/* IPI = Intrusive Port Interface */
-    HW_PWR_IVA_ISP	 /* ISP = Intrusive Slave Port */
-} ;
-
-enum HW_PwrState_t {
-    HW_PWR_STATE_OFF,
-    HW_PWR_STATE_RET,
-    HW_PWR_STATE_INACT,
-    HW_PWR_STATE_ON = 3
-} ;
-
-enum HW_ForceState_t {
-    HW_FORCE_OFF,
-    HW_FORCE_ON
-} ;
-
-enum HW_IdleState_t {
-    HW_ACTIVE,
-    HW_STANDBY
-
-} ;
-
-enum HW_TransitionState_t {
-    HW_AUTOTRANS_DIS,
-    HW_SW_SUP_SLEEP,
-    HW_SW_SUP_WAKEUP,
-    HW_AUTOTRANS_EN
-} ;
-
-
-extern HW_STATUS HW_RST_Reset(const void __iomem *baseAddress,
-				 enum HW_RstModule_t r);
-
-extern HW_STATUS HW_RST_UnReset(const void __iomem *baseAddress,
-				   enum HW_RstModule_t r);
-
-extern HW_STATUS HW_RSTCTRL_RegGet(const void __iomem *baseAddress,
-					     enum HW_RstModule_t p,
-					     u32 *value);
-extern HW_STATUS HW_RSTST_RegGet(const void __iomem *baseAddress,
-					   enum HW_RstModule_t p, u32 *value);
-
-extern HW_STATUS HW_PWR_PowerStateSet(const u32 baseAddress,
-						enum HW_PwrModule_t p,
-						enum HW_PwrState_t value);
-
-extern HW_STATUS HW_CLK_SetInputClock(const u32 baseAddress,
-					enum HW_GPtimer_t gpt,
-					enum HW_Clocktype_t c);
-
-extern HW_STATUS HW_PWR_IVA2StateGet(const void __iomem *baseAddress,
-					enum HW_PwrModule_t p,
-					enum HW_PwrState_t *value);
-
-extern HW_STATUS HW_PWRST_IVA2RegGet(const void __iomem *baseAddress,
-						u32 *value);
-
-extern HW_STATUS HW_PWR_IVA2PowerStateSet(const void __iomem *baseAddress,
-					    enum HW_PwrModule_t p,
-					    enum HW_PwrState_t value);
+	HW_PWR_DSP_IPI,		/* IPI = Intrusive Port Interface */
+	HW_PWR_IVA_ISP		/* ISP = Intrusive Slave Port */
+};
+
+enum hw_pwr_state_t {
+	HW_PWR_STATE_OFF,
+	HW_PWR_STATE_RET,
+	HW_PWR_STATE_INACT,
+	HW_PWR_STATE_ON = 3
+};
+
+enum hw_force_state_t {
+	HW_FORCE_OFF,
+	HW_FORCE_ON
+};
+
+enum hw_idle_state_t {
+	HW_ACTIVE,
+	HW_STANDBY
+};
+
+enum hw_transition_state_t {
+	HW_AUTOTRANS_DIS,
+	HW_SW_SUP_SLEEP,
+	HW_SW_SUP_WAKEUP,
+	HW_AUTOTRANS_EN
+};
+
+extern hw_status hw_rst_reset(const void __iomem *baseAddress,
+			      enum hw_rst_module_t r);
+
+extern hw_status hw_rst_un_reset(const void __iomem *baseAddress,
+				 enum hw_rst_module_t r);
+
+extern hw_status hw_rstctrl_reg_get(const void __iomem *baseAddress,
+				    enum hw_rst_module_t p, u32 *value);
+extern hw_status hw_rstst_reg_get(const void __iomem *baseAddress,
+				  enum hw_rst_module_t p, u32 *value);
+
+extern hw_status hw_pwr_power_state_set(const u32 baseAddress,
+					enum hw_pwr_module_t p,
+					enum hw_pwr_state_t value);
+
+extern hw_status hw_clk_set_input_clock(const u32 baseAddress,
+					enum hw_g_ptimer_t gpt,
+					enum hw_clocktype_t c);
+
+extern hw_status hw_pwr_iva2_state_get(const void __iomem *baseAddress,
+				       enum hw_pwr_module_t p,
+				       enum hw_pwr_state_t *value);
+
+extern hw_status hw_pwrst_iva2_reg_get(const void __iomem *baseAddress,
+				       u32 *value);
+
+extern hw_status hw_pwr_iva2_power_state_set(const void __iomem *baseAddress,
+					     enum hw_pwr_module_t p,
+					     enum hw_pwr_state_t value);
 
-extern HW_STATUS HW_PWR_CLKCTRL_IVA2RegSet(const void __iomem *baseAddress,
-					     enum HW_TransitionState_t val);
+extern hw_status hw_pwr_clkctrl_iva2_reg_set(const void __iomem *baseAddress,
+					     enum hw_transition_state_t val);
 
-#endif  /* __HW_PRCM_H */
+#endif /* _HW_PRCM_H */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/IPIAccInt.h kernel-power-2.6.28.new/drivers/dsp/bridge/hw/IPIAccInt.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/IPIAccInt.h	2011-10-11 13:51:00.277597753 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/IPIAccInt.h	2011-10-23 08:22:37.619928000 +0100
@@ -22,20 +22,5 @@
 #define SYSC_IVA2BOOTADDR_OFFSET                0x400
 #define SYSC_IVA2BOOTADDR_MASK                 0xfffffc00
 
-
-/* The following represent the enumerated values for each bitfield */
-
-enum IPIIPI_SYSCONFIGAutoIdleE {
-	IPIIPI_SYSCONFIGAutoIdleclkfree = 0x0000,
-	IPIIPI_SYSCONFIGAutoIdleautoclkgate = 0x0001
-} ;
-
-enum IPIIPI_ENTRYElemSizeValueE {
-	IPIIPI_ENTRYElemSizeValueElemSz8b = 0x0000,
-	IPIIPI_ENTRYElemSizeValueElemSz16b = 0x0001,
-	IPIIPI_ENTRYElemSizeValueElemSz32b = 0x0002,
-	IPIIPI_ENTRYElemSizeValueReserved = 0x0003
-} ;
-
-#endif				/* _IPI_ACC_INT_H */
+#endif /* _IPI_ACC_INT_H */
 /* EOF */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/IVA2RegAcM.h kernel-power-2.6.28.new/drivers/dsp/bridge/hw/IVA2RegAcM.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/IVA2RegAcM.h	2011-10-11 13:51:00.293197355 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/IVA2RegAcM.h	2011-10-23 08:22:37.619928000 +0100
@@ -14,8 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-
 #ifndef _IVA2_REG_ACM_H
 #define _IVA2_REG_ACM_H
 
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/MLBAccInt.h kernel-power-2.6.28.new/drivers/dsp/bridge/hw/MLBAccInt.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/MLBAccInt.h	2011-10-11 13:51:00.298873588 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/MLBAccInt.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,132 +0,0 @@
-/*
- * MLBAccInt.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2007 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-#ifndef _MLB_ACC_INT_H
-#define _MLB_ACC_INT_H
-
-/* Mappings of level 1 EASI function numbers to function names */
-
-#define EASIL1_MLBMAILBOX_SYSCONFIGReadRegister32   (MLB_BASE_EASIL1 + 3)
-#define EASIL1_MLBMAILBOX_SYSCONFIGWriteRegister32  (MLB_BASE_EASIL1 + 4)
-#define EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeRead32   (MLB_BASE_EASIL1 + 7)
-#define EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeWrite32  (MLB_BASE_EASIL1 + 17)
-#define EASIL1_MLBMAILBOX_SYSCONFIGSoftResetWrite32 (MLB_BASE_EASIL1 + 29)
-#define EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleRead32 \
-						(MLB_BASE_EASIL1 + 33)
-#define EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleWrite32   (MLB_BASE_EASIL1 + 39)
-#define EASIL1_MLBMAILBOX_SYSSTATUSResetDoneRead32  (MLB_BASE_EASIL1 + 44)
-#define EASIL1_MLBMAILBOX_MESSAGE___0_15ReadRegister32 \
-						(MLB_BASE_EASIL1 + 50)
-#define EASIL1_MLBMAILBOX_MESSAGE___0_15WriteRegister32  \
-						(MLB_BASE_EASIL1 + 51)
-#define EASIL1_MLBMAILBOX_FIFOSTATUS___0_15ReadRegister32  \
-						(MLB_BASE_EASIL1 + 56)
-#define EASIL1_MLBMAILBOX_FIFOSTATUS___0_15FifoFullMBmRead32 \
-						(MLB_BASE_EASIL1 + 57)
-#define EASIL1_MLBMAILBOX_MSGSTATUS___0_15NbOfMsgMBmRead32  \
-						(MLB_BASE_EASIL1 + 60)
-#define EASIL1_MLBMAILBOX_IRQSTATUS___0_3ReadRegister32  \
-						(MLB_BASE_EASIL1 + 62)
-#define EASIL1_MLBMAILBOX_IRQSTATUS___0_3WriteRegister32 \
-						(MLB_BASE_EASIL1 + 63)
-#define EASIL1_MLBMAILBOX_IRQENABLE___0_3ReadRegister32    \
-						(MLB_BASE_EASIL1 + 192)
-#define EASIL1_MLBMAILBOX_IRQENABLE___0_3WriteRegister32   \
-						(MLB_BASE_EASIL1 + 193)
-
-/* Register set MAILBOX_MESSAGE___REGSET_0_15 address offset, bank address
- * increment and number of banks */
-
-#define MLB_MAILBOX_MESSAGE___REGSET_0_15_OFFSET    (u32)(0x0040)
-#define MLB_MAILBOX_MESSAGE___REGSET_0_15_STEP   (u32)(0x0004)
-
-/* Register offset address definitions relative to register set
- * MAILBOX_MESSAGE___REGSET_0_15 */
-
-#define MLB_MAILBOX_MESSAGE___0_15_OFFSET   (u32)(0x0)
-
-
-/* Register set MAILBOX_FIFOSTATUS___REGSET_0_15 address offset, bank address
- * increment and number of banks */
-
-#define MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_OFFSET  (u32)(0x0080)
-#define MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_STEP   (u32)(0x0004)
-
-/* Register offset address definitions relative to register set
- * MAILBOX_FIFOSTATUS___REGSET_0_15 */
-
-#define MLB_MAILBOX_FIFOSTATUS___0_15_OFFSET    (u32)(0x0)
-
-
-/* Register set MAILBOX_MSGSTATUS___REGSET_0_15 address offset, bank address
- * increment and number of banks */
-
-#define MLB_MAILBOX_MSGSTATUS___REGSET_0_15_OFFSET  (u32)(0x00c0)
-#define MLB_MAILBOX_MSGSTATUS___REGSET_0_15_STEP    (u32)(0x0004)
-
-/* Register offset address definitions relative to register set
- * MAILBOX_MSGSTATUS___REGSET_0_15 */
-
-#define MLB_MAILBOX_MSGSTATUS___0_15_OFFSET    (u32)(0x0)
-
-
-/* Register set MAILBOX_IRQSTATUS___REGSET_0_3 address offset, bank address
- * increment and number of banks */
-
-#define MLB_MAILBOX_IRQSTATUS___REGSET_0_3_OFFSET        (u32)(0x0100)
-#define MLB_MAILBOX_IRQSTATUS___REGSET_0_3_STEP          (u32)(0x0008)
-
-/* Register offset address definitions relative to register set
- * MAILBOX_IRQSTATUS___REGSET_0_3 */
-
-#define MLB_MAILBOX_IRQSTATUS___0_3_OFFSET        (u32)(0x0)
-
-
-/* Register set MAILBOX_IRQENABLE___REGSET_0_3 address offset, bank address
- * increment and number of banks */
-
-#define MLB_MAILBOX_IRQENABLE___REGSET_0_3_OFFSET     (u32)(0x0104)
-#define MLB_MAILBOX_IRQENABLE___REGSET_0_3_STEP     (u32)(0x0008)
-
-/* Register offset address definitions relative to register set
- * MAILBOX_IRQENABLE___REGSET_0_3 */
-
-#define MLB_MAILBOX_IRQENABLE___0_3_OFFSET          (u32)(0x0)
-
-
-/* Register offset address definitions */
-
-#define MLB_MAILBOX_SYSCONFIG_OFFSET            (u32)(0x10)
-#define MLB_MAILBOX_SYSSTATUS_OFFSET            (u32)(0x14)
-
-
-/* Bitfield mask and offset declarations */
-
-#define MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK        (u32)(0x18)
-#define MLB_MAILBOX_SYSCONFIG_SIdleMode_OFFSET      (u32)(3)
-#define MLB_MAILBOX_SYSCONFIG_SoftReset_MASK        (u32)(0x2)
-#define MLB_MAILBOX_SYSCONFIG_SoftReset_OFFSET      (u32)(1)
-#define MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK          (u32)(0x1)
-#define MLB_MAILBOX_SYSCONFIG_AutoIdle_OFFSET        (u32)(0)
-#define MLB_MAILBOX_SYSSTATUS_ResetDone_MASK         (u32)(0x1)
-#define MLB_MAILBOX_SYSSTATUS_ResetDone_OFFSET         (u32)(0)
-#define MLB_MAILBOX_FIFOSTATUS___0_15_FifoFullMBm_MASK   (u32)(0x1)
-#define MLB_MAILBOX_FIFOSTATUS___0_15_FifoFullMBm_OFFSET  (u32)(0)
-#define MLB_MAILBOX_MSGSTATUS___0_15_NbOfMsgMBm_MASK    (u32)(0x7f)
-#define MLB_MAILBOX_MSGSTATUS___0_15_NbOfMsgMBm_OFFSET    (u32)(0)
-
-#endif /* _MLB_ACC_INT_H */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/MLBRegAcM.h kernel-power-2.6.28.new/drivers/dsp/bridge/hw/MLBRegAcM.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/MLBRegAcM.h	2011-10-11 13:51:00.369223060 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/MLBRegAcM.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,201 +0,0 @@
-/*
- * MLBRegAcM.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2007 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#ifndef _MLB_REG_ACM_H
-#define _MLB_REG_ACM_H
-
-#include <GlobalTypes.h>
-#include <linux/io.h>
-#include <EasiGlobal.h>
-#include "MLBAccInt.h"
-
-#if defined(USE_LEVEL_1_MACROS)
-
-#define MLBMAILBOX_SYSCONFIGReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGReadRegister32),\
-      __raw_readl(((baseAddress))+ \
-      MLB_MAILBOX_SYSCONFIG_OFFSET))
-
-
-#define MLBMAILBOX_SYSCONFIGWriteRegister32(baseAddress, value)\
-{\
-    const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGWriteRegister32);\
-    __raw_writel(newValue, ((baseAddress))+offset);\
-}
-
-
-#define MLBMAILBOX_SYSCONFIGSIdleModeRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeRead32),\
-      (((__raw_readl((((u32)(baseAddress))+\
-      (MLB_MAILBOX_SYSCONFIG_OFFSET)))) &\
-      MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK) >>\
-      MLB_MAILBOX_SYSCONFIG_SIdleMode_OFFSET))
-
-
-#define MLBMAILBOX_SYSCONFIGSIdleModeWrite32(baseAddress, value)\
-{\
-    const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;\
-    register u32 data = __raw_readl(((u32)(baseAddress)) +\
-			    offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeWrite32);\
-    data &= ~(MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK);\
-    newValue <<= MLB_MAILBOX_SYSCONFIG_SIdleMode_OFFSET;\
-    newValue &= MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define MLBMAILBOX_SYSCONFIGSoftResetWrite32(baseAddress, value)\
-{\
-    const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;\
-    register u32 data =\
-    __raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSoftResetWrite32);\
-    data &= ~(MLB_MAILBOX_SYSCONFIG_SoftReset_MASK);\
-    newValue <<= MLB_MAILBOX_SYSCONFIG_SoftReset_OFFSET;\
-    newValue &= MLB_MAILBOX_SYSCONFIG_SoftReset_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define MLBMAILBOX_SYSCONFIGAutoIdleRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleRead32),\
-      (((__raw_readl((((u32)(baseAddress))+\
-      (MLB_MAILBOX_SYSCONFIG_OFFSET)))) &\
-      MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK) >>\
-      MLB_MAILBOX_SYSCONFIG_AutoIdle_OFFSET))
-
-
-#define MLBMAILBOX_SYSCONFIGAutoIdleWrite32(baseAddress, value)\
-{\
-    const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;\
-    register u32 data =\
-    __raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleWrite32);\
-    data &= ~(MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK);\
-    newValue <<= MLB_MAILBOX_SYSCONFIG_AutoIdle_OFFSET;\
-    newValue &= MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define MLBMAILBOX_SYSSTATUSResetDoneRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSSTATUSResetDoneRead32),\
-      (((__raw_readl((((u32)(baseAddress))+\
-      (MLB_MAILBOX_SYSSTATUS_OFFSET)))) &\
-      MLB_MAILBOX_SYSSTATUS_ResetDone_MASK) >>\
-      MLB_MAILBOX_SYSSTATUS_ResetDone_OFFSET))
-
-
-#define MLBMAILBOX_MESSAGE___0_15ReadRegister32(baseAddress, bank)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_MESSAGE___0_15ReadRegister32),\
-      __raw_readl(((baseAddress))+\
-      (MLB_MAILBOX_MESSAGE___REGSET_0_15_OFFSET +\
-      MLB_MAILBOX_MESSAGE___0_15_OFFSET+(\
-      (bank)*MLB_MAILBOX_MESSAGE___REGSET_0_15_STEP))))
-
-
-#define MLBMAILBOX_MESSAGE___0_15WriteRegister32(baseAddress, bank, value)\
-{\
-    const u32 offset = MLB_MAILBOX_MESSAGE___REGSET_0_15_OFFSET +\
-    MLB_MAILBOX_MESSAGE___0_15_OFFSET +\
-    ((bank)*MLB_MAILBOX_MESSAGE___REGSET_0_15_STEP);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_MESSAGE___0_15WriteRegister32);\
-    __raw_writel(newValue, ((baseAddress))+offset);\
-}
-
-
-#define MLBMAILBOX_FIFOSTATUS___0_15ReadRegister32(baseAddress, bank)\
-    (_DEBUG_LEVEL_1_EASI(\
-      EASIL1_MLBMAILBOX_FIFOSTATUS___0_15ReadRegister32),\
-      __raw_readl(((u32)(baseAddress))+\
-      (MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_OFFSET +\
-      MLB_MAILBOX_FIFOSTATUS___0_15_OFFSET+\
-      ((bank)*MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_STEP))))
-
-
-#define MLBMAILBOX_FIFOSTATUS___0_15FifoFullMBmRead32(baseAddress, bank)\
-    (_DEBUG_LEVEL_1_EASI(\
-      EASIL1_MLBMAILBOX_FIFOSTATUS___0_15FifoFullMBmRead32),\
-      (((__raw_readl(((baseAddress))+\
-      (MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_OFFSET +\
-      MLB_MAILBOX_FIFOSTATUS___0_15_OFFSET+\
-      ((bank)*MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_STEP)))) &\
-      MLB_MAILBOX_FIFOSTATUS___0_15_FifoFullMBm_MASK) >>\
-      MLB_MAILBOX_FIFOSTATUS___0_15_FifoFullMBm_OFFSET))
-
-
-#define MLBMAILBOX_MSGSTATUS___0_15NbOfMsgMBmRead32(baseAddress, bank)\
-    (_DEBUG_LEVEL_1_EASI(\
-      EASIL1_MLBMAILBOX_MSGSTATUS___0_15NbOfMsgMBmRead32),\
-      (((__raw_readl(((baseAddress))+\
-      (MLB_MAILBOX_MSGSTATUS___REGSET_0_15_OFFSET +\
-      MLB_MAILBOX_MSGSTATUS___0_15_OFFSET+\
-      ((bank)*MLB_MAILBOX_MSGSTATUS___REGSET_0_15_STEP)))) &\
-      MLB_MAILBOX_MSGSTATUS___0_15_NbOfMsgMBm_MASK) >>\
-      MLB_MAILBOX_MSGSTATUS___0_15_NbOfMsgMBm_OFFSET))
-
-
-#define MLBMAILBOX_IRQSTATUS___0_3ReadRegister32(baseAddress, bank)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQSTATUS___0_3ReadRegister32),\
-      __raw_readl(((baseAddress))+\
-      (MLB_MAILBOX_IRQSTATUS___REGSET_0_3_OFFSET +\
-      MLB_MAILBOX_IRQSTATUS___0_3_OFFSET+\
-      ((bank)*MLB_MAILBOX_IRQSTATUS___REGSET_0_3_STEP))))
-
-
-#define MLBMAILBOX_IRQSTATUS___0_3WriteRegister32(baseAddress, bank, value)\
-{\
-    const u32 offset = MLB_MAILBOX_IRQSTATUS___REGSET_0_3_OFFSET +\
-    MLB_MAILBOX_IRQSTATUS___0_3_OFFSET +\
-    ((bank)*MLB_MAILBOX_IRQSTATUS___REGSET_0_3_STEP);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQSTATUS___0_3WriteRegister32);\
-    __raw_writel(newValue, ((baseAddress))+offset);\
-}
-
-
-#define MLBMAILBOX_IRQENABLE___0_3ReadRegister32(baseAddress, bank)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQENABLE___0_3ReadRegister32),\
-      __raw_readl(((baseAddress))+\
-      (MLB_MAILBOX_IRQENABLE___REGSET_0_3_OFFSET +\
-      MLB_MAILBOX_IRQENABLE___0_3_OFFSET+\
-       ((bank)*MLB_MAILBOX_IRQENABLE___REGSET_0_3_STEP))))
-
-
-#define MLBMAILBOX_IRQENABLE___0_3WriteRegister32(baseAddress, bank, value)\
-{\
-    const u32 offset = MLB_MAILBOX_IRQENABLE___REGSET_0_3_OFFSET +\
-      MLB_MAILBOX_IRQENABLE___0_3_OFFSET +\
-      ((bank)*MLB_MAILBOX_IRQENABLE___REGSET_0_3_STEP);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQENABLE___0_3WriteRegister32);\
-    __raw_writel(newValue, ((baseAddress))+offset);\
-}
-
-
-#endif	/* USE_LEVEL_1_MACROS */
-
-#endif /* _MLB_REG_ACM_H */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/MMUAccInt.h kernel-power-2.6.28.new/drivers/dsp/bridge/hw/MMUAccInt.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/MMUAccInt.h	2011-10-11 13:51:00.369223060 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/MMUAccInt.h	2011-10-23 08:22:37.619928000 +0100
@@ -19,29 +19,29 @@
 
 /* Mappings of level 1 EASI function numbers to function names */
 
-#define EASIL1_MMUMMU_SYSCONFIGReadRegister32 (MMU_BASE_EASIL1 + 3)
-#define EASIL1_MMUMMU_SYSCONFIGIdleModeWrite32  (MMU_BASE_EASIL1 + 17)
-#define EASIL1_MMUMMU_SYSCONFIGAutoIdleWrite32    (MMU_BASE_EASIL1 + 39)
-#define EASIL1_MMUMMU_IRQSTATUSWriteRegister32   (MMU_BASE_EASIL1 + 51)
-#define EASIL1_MMUMMU_IRQENABLEReadRegister32 (MMU_BASE_EASIL1 + 102)
-#define EASIL1_MMUMMU_IRQENABLEWriteRegister32 (MMU_BASE_EASIL1 + 103)
-#define EASIL1_MMUMMU_WALKING_STTWLRunningRead32 (MMU_BASE_EASIL1 + 156)
-#define EASIL1_MMUMMU_CNTLTWLEnableRead32 (MMU_BASE_EASIL1 + 174)
-#define EASIL1_MMUMMU_CNTLTWLEnableWrite32   (MMU_BASE_EASIL1 + 180)
-#define EASIL1_MMUMMU_CNTLMMUEnableWrite32     (MMU_BASE_EASIL1 + 190)
-#define EASIL1_MMUMMU_FAULT_ADReadRegister32   (MMU_BASE_EASIL1 + 194)
-#define EASIL1_MMUMMU_TTBWriteRegister32  (MMU_BASE_EASIL1 + 198)
-#define EASIL1_MMUMMU_LOCKReadRegister32   (MMU_BASE_EASIL1 + 203)
-#define EASIL1_MMUMMU_LOCKWriteRegister32  (MMU_BASE_EASIL1 + 204)
-#define EASIL1_MMUMMU_LOCKBaseValueRead32  (MMU_BASE_EASIL1 + 205)
-#define EASIL1_MMUMMU_LOCKCurrentVictimRead32 (MMU_BASE_EASIL1 + 209)
-#define EASIL1_MMUMMU_LOCKCurrentVictimWrite32 (MMU_BASE_EASIL1 + 211)
-#define EASIL1_MMUMMU_LOCKCurrentVictimSet32  (MMU_BASE_EASIL1 + 212)
-#define EASIL1_MMUMMU_LD_TLBReadRegister32    (MMU_BASE_EASIL1 + 213)
-#define EASIL1_MMUMMU_LD_TLBWriteRegister32   (MMU_BASE_EASIL1 + 214)
-#define EASIL1_MMUMMU_CAMWriteRegister32   (MMU_BASE_EASIL1 + 226)
-#define EASIL1_MMUMMU_RAMWriteRegister32 (MMU_BASE_EASIL1 + 268)
-#define EASIL1_MMUMMU_FLUSH_ENTRYWriteRegister32  (MMU_BASE_EASIL1 + 322)
+#define EASIL1_MMUMMU_SYSCONFIG_READ_REGISTER32 (MMU_BASE_EASIL1 + 3)
+#define EASIL1_MMUMMU_SYSCONFIG_IDLE_MODE_WRITE32  (MMU_BASE_EASIL1 + 17)
+#define EASIL1_MMUMMU_SYSCONFIG_AUTO_IDLE_WRITE32    (MMU_BASE_EASIL1 + 39)
+#define EASIL1_MMUMMU_IRQSTATUS_WRITE_REGISTER32   (MMU_BASE_EASIL1 + 51)
+#define EASIL1_MMUMMU_IRQENABLE_READ_REGISTER32 (MMU_BASE_EASIL1 + 102)
+#define EASIL1_MMUMMU_IRQENABLE_WRITE_REGISTER32 (MMU_BASE_EASIL1 + 103)
+#define EASIL1_MMUMMU_WALKING_STTWL_RUNNING_READ32 (MMU_BASE_EASIL1 + 156)
+#define EASIL1_MMUMMU_CNTLTWL_ENABLE_READ32 (MMU_BASE_EASIL1 + 174)
+#define EASIL1_MMUMMU_CNTLTWL_ENABLE_WRITE32   (MMU_BASE_EASIL1 + 180)
+#define EASIL1_MMUMMU_CNTLMMU_ENABLE_WRITE32     (MMU_BASE_EASIL1 + 190)
+#define EASIL1_MMUMMU_FAULT_AD_READ_REGISTER32   (MMU_BASE_EASIL1 + 194)
+#define EASIL1_MMUMMU_TTB_WRITE_REGISTER32  (MMU_BASE_EASIL1 + 198)
+#define EASIL1_MMUMMU_LOCK_READ_REGISTER32   (MMU_BASE_EASIL1 + 203)
+#define EASIL1_MMUMMU_LOCK_WRITE_REGISTER32  (MMU_BASE_EASIL1 + 204)
+#define EASIL1_MMUMMU_LOCK_BASE_VALUE_READ32  (MMU_BASE_EASIL1 + 205)
+#define EASIL1_MMUMMU_LOCK_CURRENT_VICTIM_READ32 (MMU_BASE_EASIL1 + 209)
+#define EASIL1_MMUMMU_LOCK_CURRENT_VICTIM_WRITE32 (MMU_BASE_EASIL1 + 211)
+#define EASIL1_MMUMMU_LOCK_CURRENT_VICTIM_SET32  (MMU_BASE_EASIL1 + 212)
+#define EASIL1_MMUMMU_LD_TLB_READ_REGISTER32    (MMU_BASE_EASIL1 + 213)
+#define EASIL1_MMUMMU_LD_TLB_WRITE_REGISTER32   (MMU_BASE_EASIL1 + 214)
+#define EASIL1_MMUMMU_CAM_WRITE_REGISTER32   (MMU_BASE_EASIL1 + 226)
+#define EASIL1_MMUMMU_RAM_WRITE_REGISTER32 (MMU_BASE_EASIL1 + 268)
+#define EASIL1_MMUMMU_FLUSH_ENTRY_WRITE_REGISTER32  (MMU_BASE_EASIL1 + 322)
 
 /* Register offset address definitions */
 #define MMU_MMU_SYSCONFIG_OFFSET   0x10
@@ -58,19 +58,19 @@
 #define MMU_MMU_GFLUSH_OFFSET  0x60
 #define MMU_MMU_FLUSH_ENTRY_OFFSET  0x64
 /* Bitfield mask and offset declarations */
-#define MMU_MMU_SYSCONFIG_IdleMode_MASK  0x18
-#define MMU_MMU_SYSCONFIG_IdleMode_OFFSET  3
-#define MMU_MMU_SYSCONFIG_AutoIdle_MASK  0x1
-#define MMU_MMU_SYSCONFIG_AutoIdle_OFFSET   0
-#define MMU_MMU_WALKING_ST_TWLRunning_MASK 0x1
-#define MMU_MMU_WALKING_ST_TWLRunning_OFFSET  0
-#define MMU_MMU_CNTL_TWLEnable_MASK 0x4
-#define MMU_MMU_CNTL_TWLEnable_OFFSET 2
-#define MMU_MMU_CNTL_MMUEnable_MASK    0x2
-#define MMU_MMU_CNTL_MMUEnable_OFFSET   1
-#define MMU_MMU_LOCK_BaseValue_MASK 0xfc00
-#define MMU_MMU_LOCK_BaseValue_OFFSET   10
-#define MMU_MMU_LOCK_CurrentVictim_MASK   0x3f0
-#define MMU_MMU_LOCK_CurrentVictim_OFFSET    4
+#define MMU_MMU_SYSCONFIG_IDLE_MODE_MASK  0x18
+#define MMU_MMU_SYSCONFIG_IDLE_MODE_OFFSET  3
+#define MMU_MMU_SYSCONFIG_AUTO_IDLE_MASK  0x1
+#define MMU_MMU_SYSCONFIG_AUTO_IDLE_OFFSET   0
+#define MMU_MMU_WALKING_ST_TWL_RUNNING_MASK 0x1
+#define MMU_MMU_WALKING_ST_TWL_RUNNING_OFFSET  0
+#define MMU_MMU_CNTL_TWL_ENABLE_MASK 0x4
+#define MMU_MMU_CNTL_TWL_ENABLE_OFFSET 2
+#define MMU_MMU_CNTL_MMU_ENABLE_MASK    0x2
+#define MMU_MMU_CNTL_MMU_ENABLE_OFFSET   1
+#define MMU_MMU_LOCK_BASE_VALUE_MASK 0xfc00
+#define MMU_MMU_LOCK_BASE_VALUE_OFFSET   10
+#define MMU_MMU_LOCK_CURRENT_VICTIM_MASK   0x3f0
+#define MMU_MMU_LOCK_CURRENT_VICTIM_OFFSET    4
 
 #endif /* _MMU_ACC_INT_H */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/MMURegAcM.h kernel-power-2.6.28.new/drivers/dsp/bridge/hw/MMURegAcM.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/MMURegAcM.h	2011-10-11 13:51:00.385699277 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/MMURegAcM.h	2011-10-23 08:22:37.619928000 +0100
@@ -14,7 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
 #ifndef _MMU_REG_ACM_H
 #define _MMU_REG_ACM_H
 
@@ -26,228 +25,202 @@
 
 #if defined(USE_LEVEL_1_MACROS)
 
-
-#define MMUMMU_SYSCONFIGReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGReadRegister32),\
+#define MMUMMU_SYSCONFIG_READ_REGISTER32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_SYSCONFIG_READ_REGISTER32),\
       __raw_readl((baseAddress)+MMU_MMU_SYSCONFIG_OFFSET))
 
-
-#define MMUMMU_SYSCONFIGIdleModeWrite32(baseAddress, value)\
+#define MMUMMU_SYSCONFIG_IDLE_MODE_WRITE32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_SYSCONFIG_OFFSET;\
     register u32 data = __raw_readl((baseAddress)+offset);\
     register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGIdleModeWrite32);\
-    data &= ~(MMU_MMU_SYSCONFIG_IdleMode_MASK);\
-    newValue <<= MMU_MMU_SYSCONFIG_IdleMode_OFFSET;\
-    newValue &= MMU_MMU_SYSCONFIG_IdleMode_MASK;\
+    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_SYSCONFIG_IDLE_MODE_WRITE32);\
+    data &= ~(MMU_MMU_SYSCONFIG_IDLE_MODE_MASK);\
+    newValue <<= MMU_MMU_SYSCONFIG_IDLE_MODE_OFFSET;\
+    newValue &= MMU_MMU_SYSCONFIG_IDLE_MODE_MASK;\
     newValue |= data;\
     __raw_writel(newValue, baseAddress+offset);\
 }
 
-
-#define MMUMMU_SYSCONFIGAutoIdleWrite32(baseAddress, value)\
+#define MMUMMU_SYSCONFIG_AUTO_IDLE_WRITE32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_SYSCONFIG_OFFSET;\
     register u32 data = __raw_readl((baseAddress)+offset);\
     register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGAutoIdleWrite32);\
-    data &= ~(MMU_MMU_SYSCONFIG_AutoIdle_MASK);\
-    newValue <<= MMU_MMU_SYSCONFIG_AutoIdle_OFFSET;\
-    newValue &= MMU_MMU_SYSCONFIG_AutoIdle_MASK;\
+    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_SYSCONFIG_AUTO_IDLE_WRITE32);\
+    data &= ~(MMU_MMU_SYSCONFIG_AUTO_IDLE_MASK);\
+    newValue <<= MMU_MMU_SYSCONFIG_AUTO_IDLE_OFFSET;\
+    newValue &= MMU_MMU_SYSCONFIG_AUTO_IDLE_MASK;\
     newValue |= data;\
     __raw_writel(newValue, baseAddress+offset);\
 }
 
-
-#define MMUMMU_IRQSTATUSReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQSTATUSReadRegister32),\
+#define MMUMMU_IRQSTATUS_READ_REGISTER32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_IRQSTATUSReadRegister32),\
       __raw_readl((baseAddress)+MMU_MMU_IRQSTATUS_OFFSET))
 
-
-#define MMUMMU_IRQSTATUSWriteRegister32(baseAddress, value)\
+#define MMUMMU_IRQSTATUS_WRITE_REGISTER32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_IRQSTATUS_OFFSET;\
     register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQSTATUSWriteRegister32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_IRQSTATUS_WRITE_REGISTER32);\
     __raw_writel(newValue, (baseAddress)+offset);\
 }
 
-
-#define MMUMMU_IRQENABLEReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQENABLEReadRegister32),\
+#define MMUMMU_IRQENABLE_READ_REGISTER32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_IRQENABLE_READ_REGISTER32),\
       __raw_readl((baseAddress)+MMU_MMU_IRQENABLE_OFFSET))
 
-
-#define MMUMMU_IRQENABLEWriteRegister32(baseAddress, value)\
+#define MMUMMU_IRQENABLE_WRITE_REGISTER32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_IRQENABLE_OFFSET;\
     register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQENABLEWriteRegister32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_IRQENABLE_WRITE_REGISTER32);\
     __raw_writel(newValue, (baseAddress)+offset);\
 }
 
-
-#define MMUMMU_WALKING_STTWLRunningRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_WALKING_STTWLRunningRead32),\
+#define MMUMMU_WALKING_STTWL_RUNNING_READ32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_WALKING_STTWL_RUNNING_READ32),\
       (((__raw_readl(((baseAddress)+(MMU_MMU_WALKING_ST_OFFSET))))\
-      & MMU_MMU_WALKING_ST_TWLRunning_MASK) >>\
-      MMU_MMU_WALKING_ST_TWLRunning_OFFSET))
+      & MMU_MMU_WALKING_ST_TWL_RUNNING_MASK) >>\
+      MMU_MMU_WALKING_ST_TWL_RUNNING_OFFSET))
 
-
-#define MMUMMU_CNTLTWLEnableRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLTWLEnableRead32),\
+#define MMUMMU_CNTLTWL_ENABLE_READ32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_CNTLTWL_ENABLE_READ32),\
       (((__raw_readl(((baseAddress)+(MMU_MMU_CNTL_OFFSET)))) &\
-      MMU_MMU_CNTL_TWLEnable_MASK) >>\
-      MMU_MMU_CNTL_TWLEnable_OFFSET))
-
+      MMU_MMU_CNTL_TWL_ENABLE_MASK) >>\
+      MMU_MMU_CNTL_TWL_ENABLE_OFFSET))
 
-#define MMUMMU_CNTLTWLEnableWrite32(baseAddress, value)\
+#define MMUMMU_CNTLTWL_ENABLE_WRITE32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_CNTL_OFFSET;\
     register u32 data = __raw_readl((baseAddress)+offset);\
     register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLTWLEnableWrite32);\
-    data &= ~(MMU_MMU_CNTL_TWLEnable_MASK);\
-    newValue <<= MMU_MMU_CNTL_TWLEnable_OFFSET;\
-    newValue &= MMU_MMU_CNTL_TWLEnable_MASK;\
+    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_CNTLTWL_ENABLE_WRITE32);\
+    data &= ~(MMU_MMU_CNTL_TWL_ENABLE_MASK);\
+    newValue <<= MMU_MMU_CNTL_TWL_ENABLE_OFFSET;\
+    newValue &= MMU_MMU_CNTL_TWL_ENABLE_MASK;\
     newValue |= data;\
     __raw_writel(newValue, baseAddress+offset);\
 }
 
-
-#define MMUMMU_CNTLMMUEnableWrite32(baseAddress, value)\
+#define MMUMMU_CNTLMMU_ENABLE_WRITE32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_CNTL_OFFSET;\
     register u32 data = __raw_readl((baseAddress)+offset);\
     register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLMMUEnableWrite32);\
-    data &= ~(MMU_MMU_CNTL_MMUEnable_MASK);\
-    newValue <<= MMU_MMU_CNTL_MMUEnable_OFFSET;\
-    newValue &= MMU_MMU_CNTL_MMUEnable_MASK;\
+    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_CNTLMMU_ENABLE_WRITE32);\
+    data &= ~(MMU_MMU_CNTL_MMU_ENABLE_MASK);\
+    newValue <<= MMU_MMU_CNTL_MMU_ENABLE_OFFSET;\
+    newValue &= MMU_MMU_CNTL_MMU_ENABLE_MASK;\
     newValue |= data;\
     __raw_writel(newValue, baseAddress+offset);\
 }
 
-
-#define MMUMMU_FAULT_ADReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_FAULT_ADReadRegister32),\
+#define MMUMMU_FAULT_AD_READ_REGISTER32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_FAULT_AD_READ_REGISTER32),\
       __raw_readl((baseAddress)+MMU_MMU_FAULT_AD_OFFSET))
 
-
-#define MMUMMU_TTBWriteRegister32(baseAddress, value)\
+#define MMUMMU_TTB_WRITE_REGISTER32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_TTB_OFFSET;\
     register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_TTBWriteRegister32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_TTB_WRITE_REGISTER32);\
     __raw_writel(newValue, (baseAddress)+offset);\
 }
 
-
-#define MMUMMU_LOCKReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKReadRegister32),\
+#define MMUMMU_LOCK_READ_REGISTER32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_READ_REGISTER32),\
       __raw_readl((baseAddress)+MMU_MMU_LOCK_OFFSET))
 
-
-#define MMUMMU_LOCKWriteRegister32(baseAddress, value)\
+#define MMUMMU_LOCK_WRITE_REGISTER32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_LOCK_OFFSET;\
     register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKWriteRegister32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_WRITE_REGISTER32);\
     __raw_writel(newValue, (baseAddress)+offset);\
 }
 
-
-#define MMUMMU_LOCKBaseValueRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKBaseValueRead32),\
+#define MMUMMU_LOCK_BASE_VALUE_READ32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_BASE_VALUE_READ32),\
       (((__raw_readl(((baseAddress)+(MMU_MMU_LOCK_OFFSET)))) &\
-      MMU_MMU_LOCK_BaseValue_MASK) >>\
-      MMU_MMU_LOCK_BaseValue_OFFSET))
-
+      MMU_MMU_LOCK_BASE_VALUE_MASK) >>\
+      MMU_MMU_LOCK_BASE_VALUE_OFFSET))
 
-#define MMUMMU_LOCKBaseValueWrite32(baseAddress, value)\
+#define MMUMMU_LOCK_BASE_VALUE_WRITE32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_LOCK_OFFSET;\
     register u32 data = __raw_readl((baseAddress)+offset);\
     register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKBaseValueWrite32);\
-    data &= ~(MMU_MMU_LOCK_BaseValue_MASK);\
-    newValue <<= MMU_MMU_LOCK_BaseValue_OFFSET;\
-    newValue &= MMU_MMU_LOCK_BaseValue_MASK;\
+    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCKBaseValueWrite32);\
+    data &= ~(MMU_MMU_LOCK_BASE_VALUE_MASK);\
+    newValue <<= MMU_MMU_LOCK_BASE_VALUE_OFFSET;\
+    newValue &= MMU_MMU_LOCK_BASE_VALUE_MASK;\
     newValue |= data;\
     __raw_writel(newValue, baseAddress+offset);\
 }
 
-
-#define MMUMMU_LOCKCurrentVictimRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKCurrentVictimRead32),\
+#define MMUMMU_LOCK_CURRENT_VICTIM_READ32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_CURRENT_VICTIM_READ32),\
       (((__raw_readl(((baseAddress)+(MMU_MMU_LOCK_OFFSET)))) &\
-      MMU_MMU_LOCK_CurrentVictim_MASK) >>\
-      MMU_MMU_LOCK_CurrentVictim_OFFSET))
-
+      MMU_MMU_LOCK_CURRENT_VICTIM_MASK) >>\
+      MMU_MMU_LOCK_CURRENT_VICTIM_OFFSET))
 
-#define MMUMMU_LOCKCurrentVictimWrite32(baseAddress, value)\
+#define MMUMMU_LOCK_CURRENT_VICTIM_WRITE32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_LOCK_OFFSET;\
     register u32 data = __raw_readl((baseAddress)+offset);\
     register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKCurrentVictimWrite32);\
-    data &= ~(MMU_MMU_LOCK_CurrentVictim_MASK);\
-    newValue <<= MMU_MMU_LOCK_CurrentVictim_OFFSET;\
-    newValue &= MMU_MMU_LOCK_CurrentVictim_MASK;\
+    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_CURRENT_VICTIM_WRITE32);\
+    data &= ~(MMU_MMU_LOCK_CURRENT_VICTIM_MASK);\
+    newValue <<= MMU_MMU_LOCK_CURRENT_VICTIM_OFFSET;\
+    newValue &= MMU_MMU_LOCK_CURRENT_VICTIM_MASK;\
     newValue |= data;\
     __raw_writel(newValue, baseAddress+offset);\
 }
 
+#define MMUMMU_LOCK_CURRENT_VICTIM_SET32(var, value)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LOCK_CURRENT_VICTIM_SET32),\
+      (((var) & ~(MMU_MMU_LOCK_CURRENT_VICTIM_MASK)) |\
+      (((value) << MMU_MMU_LOCK_CURRENT_VICTIM_OFFSET) &\
+      MMU_MMU_LOCK_CURRENT_VICTIM_MASK)))
 
-#define MMUMMU_LOCKCurrentVictimSet32(var, value)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKCurrentVictimSet32),\
-      (((var) & ~(MMU_MMU_LOCK_CurrentVictim_MASK)) |\
-      (((value) << MMU_MMU_LOCK_CurrentVictim_OFFSET) &\
-      MMU_MMU_LOCK_CurrentVictim_MASK)))
-
-
-#define MMUMMU_LD_TLBReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LD_TLBReadRegister32),\
+#define MMUMMU_LD_TLB_READ_REGISTER32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LD_TLB_READ_REGISTER32),\
       __raw_readl((baseAddress)+MMU_MMU_LD_TLB_OFFSET))
 
-
-#define MMUMMU_LD_TLBWriteRegister32(baseAddress, value)\
+#define MMUMMU_LD_TLB_WRITE_REGISTER32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_LD_TLB_OFFSET;\
     register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LD_TLBWriteRegister32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_LD_TLB_WRITE_REGISTER32);\
     __raw_writel(newValue, (baseAddress)+offset);\
 }
 
-
-#define MMUMMU_CAMWriteRegister32(baseAddress, value)\
+#define MMUMMU_CAM_WRITE_REGISTER32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_CAM_OFFSET;\
     register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CAMWriteRegister32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_CAM_WRITE_REGISTER32);\
     __raw_writel(newValue, (baseAddress)+offset);\
 }
 
-
-#define MMUMMU_RAMWriteRegister32(baseAddress, value)\
+#define MMUMMU_RAM_WRITE_REGISTER32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_RAM_OFFSET;\
     register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_RAMWriteRegister32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_RAM_WRITE_REGISTER32);\
     __raw_writel(newValue, (baseAddress)+offset);\
 }
 
-
-#define MMUMMU_FLUSH_ENTRYWriteRegister32(baseAddress, value)\
+#define MMUMMU_FLUSH_ENTRY_WRITE_REGISTER32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_FLUSH_ENTRY_OFFSET;\
     register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_FLUSH_ENTRYWriteRegister32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_MMUMMU_FLUSH_ENTRY_WRITE_REGISTER32);\
     __raw_writel(newValue, (baseAddress)+offset);\
 }
 
-
-#endif	/* USE_LEVEL_1_MACROS */
+#endif /* USE_LEVEL_1_MACROS */
 
 #endif /* _MMU_REG_ACM_H */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/PRCMAccInt.h kernel-power-2.6.28.new/drivers/dsp/bridge/hw/PRCMAccInt.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/PRCMAccInt.h	2011-10-11 13:51:00.396535956 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/PRCMAccInt.h	2011-10-23 08:22:37.619928000 +0100
@@ -19,91 +19,97 @@
 
 /* Mappings of level 1 EASI function numbers to function names */
 
-#define EASIL1_PRCMPRCM_CLKCFG_CTRLValid_configWriteClk_valid32  \
+#define EASIL1_PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_WRITE_CLK_VALID32  \
 						(PRCM_BASE_EASIL1 + 349)
-#define EASIL1_PRCMCM_FCLKEN1_COREReadRegister32	(PRCM_BASE_EASIL1 + 743)
-#define EASIL1_PRCMCM_FCLKEN1_COREEN_GPT8Write32	(PRCM_BASE_EASIL1 + 951)
-#define EASIL1_PRCMCM_FCLKEN1_COREEN_GPT7Write32	(PRCM_BASE_EASIL1 + 961)
-#define EASIL1_PRCMCM_ICLKEN1_COREReadRegister32	\
+#define EASIL1_PRCMCM_FCLKEN1_CORE_READ_REGISTER32	(PRCM_BASE_EASIL1 + 743)
+#define EASIL1_PRCMCM_FCLKEN1_COREEN_GPT8_WRITE32	(PRCM_BASE_EASIL1 + 951)
+#define EASIL1_PRCMCM_FCLKEN1_COREEN_GPT7_WRITE32	(PRCM_BASE_EASIL1 + 961)
+#define EASIL1_PRCMCM_ICLKEN1_CORE_READ_REGISTER32	\
 						(PRCM_BASE_EASIL1 + 1087)
-#define EASIL1_PRCMCM_ICLKEN1_COREEN_MAILBOXESWrite32	\
+#define EASIL1_PRCMCM_ICLKEN1_COREEN_MAILBOXES_WRITE32	\
 						(PRCM_BASE_EASIL1 + 1105)
-#define EASIL1_PRCMCM_ICLKEN1_COREEN_GPT8Write32	\
+#define EASIL1_PRCMCM_ICLKEN1_COREEN_GPT8_WRITE32	\
 						(PRCM_BASE_EASIL1 + 1305)
-#define EASIL1_PRCMCM_ICLKEN1_COREEN_GPT7Write32	\
+#define EASIL1_PRCMCM_ICLKEN1_COREEN_GPT7_WRITE32	\
 						(PRCM_BASE_EASIL1 + 1315)
-#define EASIL1_PRCMCM_CLKSEL1_CORECLKSEL_L3ReadIssel132	\
+#define EASIL1_PRCMCM_CLKSEL1_CORECLKSEL_L3_READ_ISSEL132	\
 						(PRCM_BASE_EASIL1 + 2261)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8Write32k32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE32K32	\
 						(PRCM_BASE_EASIL1 + 2364)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteSys32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_SYS32	\
 						(PRCM_BASE_EASIL1 + 2365)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteExt32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_EXT32	\
 						(PRCM_BASE_EASIL1 + 2366)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7Write32k32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE32K32	\
 						(PRCM_BASE_EASIL1 + 2380)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteSys32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_SYS32	\
 						(PRCM_BASE_EASIL1 + 2381)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteExt32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_EXT32	\
 						(PRCM_BASE_EASIL1 + 2382)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteSys32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_SYS32	\
 						(PRCM_BASE_EASIL1 + 2397)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteExt32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_EXT32	\
 						(PRCM_BASE_EASIL1 + 2398)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteSys32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_SYS32	\
 						(PRCM_BASE_EASIL1 + 2413)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteExt32	\
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_EXT32	\
 						(PRCM_BASE_EASIL1 + 2414)
-#define EASIL1_PRCMCM_CLKSEL1_PLLAPLLs_ClkinRead32	\
+#define EASIL1_PRCMCM_CLKSEL1_PLLAPL_LS_CLKIN_READ32	\
 						(PRCM_BASE_EASIL1 + 3747)
-#define EASIL1_PRCMCM_FCLKEN_DSPEN_DSPWrite32	(PRCM_BASE_EASIL1 + 3834)
-#define EASIL1_PRCMCM_ICLKEN_DSPEN_DSP_IPIWrite32	\
+#define EASIL1_PRCMCM_FCLKEN_DSPEN_DSP_WRITE32	(PRCM_BASE_EASIL1 + 3834)
+#define EASIL1_PRCMCM_ICLKEN_DSPEN_DSP_IPI_WRITE32	\
 						(PRCM_BASE_EASIL1 + 3846)
-#define EASIL1_PRCMCM_IDLEST_DSPReadRegister32	(PRCM_BASE_EASIL1 + 3850)
-#define EASIL1_PRCMCM_IDLEST_DSPST_IPIRead32	(PRCM_BASE_EASIL1 + 3857)
-#define EASIL1_PRCMCM_IDLEST_DSPST_DSPRead32	(PRCM_BASE_EASIL1 + 3863)
-#define EASIL1_PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPIWrite32	\
+#define EASIL1_PRCMCM_IDLEST_DSP_READ_REGISTER32	\
+						(PRCM_BASE_EASIL1 + 3850)
+#define EASIL1_PRCMCM_IDLEST_DSPST_IPI_READ32	(PRCM_BASE_EASIL1 + 3857)
+#define EASIL1_PRCMCM_IDLEST_DSPST_DSP_READ32	(PRCM_BASE_EASIL1 + 3863)
+#define EASIL1_PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPI_WRITE32	\
 						(PRCM_BASE_EASIL1 + 3877)
-#define EASIL1_PRCMCM_CLKSEL_DSPSYNC_DSPWrite32	(PRCM_BASE_EASIL1 + 3927)
-#define EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_IFWrite32	\
+#define EASIL1_PRCMCM_CLKSEL_DSPSYNC_DSP_WRITE32	\
+						(PRCM_BASE_EASIL1 + 3927)
+#define EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_IF_WRITE32	\
 						(PRCM_BASE_EASIL1 + 3941)
-#define EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSPWrite32	\
+#define EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_WRITE32	\
 						(PRCM_BASE_EASIL1 + 3965)
-#define EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPRead32	\
+#define EASIL1_PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_READ32	\
 						(PRCM_BASE_EASIL1 + 3987)
-#define EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPWrite32	\
+#define EASIL1_PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_WRITE32	\
 						(PRCM_BASE_EASIL1 + 3993)
-#define EASIL1_PRCMRM_RSTCTRL_DSPReadRegister32	(PRCM_BASE_EASIL1 + 3997)
-#define EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32	\
+#define EASIL1_PRCMRM_RSTCTRL_DSP_READ_REGISTER32	\
+						(PRCM_BASE_EASIL1 + 3997)
+#define EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSP_WRITE32	\
 						(PRCM_BASE_EASIL1 + 4025)
-#define EASIL1_PRCMRM_RSTST_DSPReadRegister32	(PRCM_BASE_EASIL1 + 4029)
-#define EASIL1_PRCMRM_RSTST_DSPWriteRegister32	(PRCM_BASE_EASIL1 + 4030)
-#define EASIL1_PRCMPM_PWSTCTRL_DSPForceStateWrite32	\
+#define EASIL1_PRCMRM_RSTST_DSP_READ_REGISTER32	(PRCM_BASE_EASIL1 + 4029)
+#define EASIL1_PRCMRM_RSTST_DSP_WRITE_REGISTER32	\
+						(PRCM_BASE_EASIL1 + 4030)
+#define EASIL1_PRCMPM_PWSTCTRL_DSP_FORCE_STATE_WRITE32	\
 						(PRCM_BASE_EASIL1 + 4165)
-#define EASIL1_PRCMPM_PWSTCTRL_DSPPowerStateWriteRET32	\
+#define EASIL1_PRCMPM_PWSTCTRL_DSP_POWER_STATE_WRITE_RET32	\
 						(PRCM_BASE_EASIL1 + 4193)
-#define EASIL1_PRCMPM_PWSTST_DSPReadRegister32	(PRCM_BASE_EASIL1 + 4197)
-#define EASIL1_PRCMPM_PWSTST_DSPInTransitionRead32	\
+#define EASIL1_PRCMPM_PWSTST_DSP_READ_REGISTER32	\
+						(PRCM_BASE_EASIL1 + 4197)
+#define EASIL1_PRCMPM_PWSTST_DSP_IN_TRANSITION_READ32	\
 						(PRCM_BASE_EASIL1 + 4198)
-#define EASIL1_PRCMPM_PWSTST_DSPPowerStateStGet32	\
+#define EASIL1_PRCMPM_PWSTST_DSP_POWER_STATE_ST_GET32	\
 						(PRCM_BASE_EASIL1 + 4235)
-#define EASIL1_CM_FCLKEN_PER_GPT5WriteRegister32	\
+#define EASIL1_CM_FCLKEN_PER_GPT5_WRITE_REGISTER32	\
 						(PRCM_BASE_EASIL1 + 4368)
-#define EASIL1_CM_ICLKEN_PER_GPT5WriteRegister32	\
+#define EASIL1_CM_ICLKEN_PER_GPT5_WRITE_REGISTER32	\
 						(PRCM_BASE_EASIL1 + 4370)
-#define EASIL1_CM_CLKSEL_PER_GPT5Write32k32	(PRCM_BASE_EASIL1 + 4372)
-#define EASIL1_CM_CLKSEL_PER_GPT6Write32k32	(PRCM_BASE_EASIL1 + 4373)
-#define EASIL1_PRCMCM_CLKSTCTRL_IVA2WriteRegister32	\
+#define EASIL1_CM_CLKSEL_PER_GPT5_WRITE32K32	(PRCM_BASE_EASIL1 + 4372)
+#define EASIL1_CM_CLKSEL_PER_GPT6_WRITE32K32	(PRCM_BASE_EASIL1 + 4373)
+#define EASIL1_PRCMCM_CLKSTCTRL_IVA2_WRITE_REGISTER32	\
 						(PRCM_BASE_EASIL1 + 4374)
-#define EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteON32	\
+#define EASIL1_PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_ON32	\
 						(PRCM_BASE_EASIL1 + 4375)
-#define EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteOFF32	\
+#define EASIL1_PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_OFF32	\
 						(PRCM_BASE_EASIL1 + 4376)
-#define EASIL1_PRCMPM_PWSTST_IVA2InTransitionRead32	\
+#define EASIL1_PRCMPM_PWSTST_IVA2_IN_TRANSITION_READ32	\
 						(PRCM_BASE_EASIL1 + 4377)
-#define EASIL1_PRCMPM_PWSTST_IVA2PowerStateStGet32	\
+#define EASIL1_PRCMPM_PWSTST_IVA2_POWER_STATE_ST_GET32	\
 						(PRCM_BASE_EASIL1 + 4378)
-#define EASIL1_PRCMPM_PWSTST_IVA2ReadRegister32	(PRCM_BASE_EASIL1 + 4379)
+#define EASIL1_PRCMPM_PWSTST_IVA2_READ_REGISTER32	\
+						(PRCM_BASE_EASIL1 + 4379)
 
 /* Register offset address definitions */
 
@@ -128,8 +134,8 @@
 
 /* Bitfield mask and offset declarations */
 
-#define PRCM_PRCM_CLKCFG_CTRL_Valid_config_MASK         (u32)(0x1)
-#define PRCM_PRCM_CLKCFG_CTRL_Valid_config_OFFSET       (u32)(0)
+#define PRCM_PRCM_CLKCFG_CTRL_VALID_CONFIG_MASK         (u32)(0x1)
+#define PRCM_PRCM_CLKCFG_CTRL_VALID_CONFIG_OFFSET       (u32)(0)
 
 #define PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK               (u32)(0x400)
 #define PRCM_CM_FCLKEN1_CORE_EN_GPT8_OFFSET             (u32)(10)
@@ -155,8 +161,8 @@
 #define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK           (u32)(0x300)
 #define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET         (u32)(8)
 
-#define PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_MASK            (u32)(0x3800000)
-#define PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_OFFSET          (u32)(23)
+#define PRCM_CM_CLKSEL1_PLL_APL_LS_CLKIN_MASK            (u32)(0x3800000)
+#define PRCM_CM_CLKSEL1_PLL_APL_LS_CLKIN_OFFSET          (u32)(23)
 
 #define PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK              (u32)(0x2)
 #define PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_OFFSET            (u32)(1)
@@ -176,29 +182,29 @@
 #define PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK              (u32)(0x1f)
 #define PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_OFFSET            (u32)(0)
 
-#define PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK        (u32)(0x1)
-#define PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_OFFSET      (u32)(0)
+#define PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_MASK        (u32)(0x1)
+#define PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_OFFSET      (u32)(0)
 
-#define PRCM_PM_PWSTCTRL_DSP_ForceState_MASK            (u32)(0x40000)
-#define PRCM_PM_PWSTCTRL_DSP_ForceState_OFFSET          (u32)(18)
+#define PRCM_PM_PWSTCTRL_DSP_FORCE_STATE_MASK            (u32)(0x40000)
+#define PRCM_PM_PWSTCTRL_DSP_FORCE_STATE_OFFSET          (u32)(18)
 
-#define PRCM_PM_PWSTCTRL_DSP_PowerState_MASK            (u32)(0x3)
-#define PRCM_PM_PWSTCTRL_DSP_PowerState_OFFSET          (u32)(0)
+#define PRCM_PM_PWSTCTRL_DSP_POWER_STATE_MASK            (u32)(0x3)
+#define PRCM_PM_PWSTCTRL_DSP_POWER_STATE_OFFSET          (u32)(0)
 
-#define PRCM_PM_PWSTCTRL_IVA2_PowerState_MASK            (u32)(0x3)
-#define PRCM_PM_PWSTCTRL_IVA2_PowerState_OFFSET          (u32)(0)
+#define PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_MASK            (u32)(0x3)
+#define PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_OFFSET          (u32)(0)
 
-#define PRCM_PM_PWSTST_DSP_InTransition_MASK            (u32)(0x100000)
-#define PRCM_PM_PWSTST_DSP_InTransition_OFFSET          (u32)(20)
+#define PRCM_PM_PWSTST_DSP_IN_TRANSITION_MASK            (u32)(0x100000)
+#define PRCM_PM_PWSTST_DSP_IN_TRANSITION_OFFSET          (u32)(20)
 
-#define PRCM_PM_PWSTST_IVA2_InTransition_MASK            (u32)(0x100000)
-#define PRCM_PM_PWSTST_IVA2_InTransition_OFFSET          (u32)(20)
+#define PRCM_PM_PWSTST_IVA2_IN_TRANSITION_MASK            (u32)(0x100000)
+#define PRCM_PM_PWSTST_IVA2_IN_TRANSITION_OFFSET          (u32)(20)
 
-#define PRCM_PM_PWSTST_DSP_PowerStateSt_MASK            (u32)(0x3)
-#define PRCM_PM_PWSTST_DSP_PowerStateSt_OFFSET          (u32)(0)
+#define PRCM_PM_PWSTST_DSP_POWER_STATE_ST_MASK            (u32)(0x3)
+#define PRCM_PM_PWSTST_DSP_POWER_STATE_ST_OFFSET          (u32)(0)
 
-#define PRCM_PM_PWSTST_IVA2_PowerStateSt_MASK            (u32)(0x3)
-#define PRCM_PM_PWSTST_IVA2_PowerStateSt_OFFSET          (u32)(0)
+#define PRCM_PM_PWSTST_IVA2_POWER_STATE_ST_MASK            (u32)(0x3)
+#define PRCM_PM_PWSTST_IVA2_POWER_STATE_ST_OFFSET          (u32)(0)
 
 #define CM_FCLKEN_PER_OFFSET		(u32)(0x0)
 #define CM_FCLKEN_PER_GPT5_OFFSET         (u32)(6)
@@ -220,7 +226,6 @@
 #define CM_CLKSEL_PER_GPT6_OFFSET   (u32)(4)
 #define CM_CLKSEL_PER_GPT6_MASK       (u32)(0x10)
 
-
 #define CM_FCLKEN_IVA2_OFFSET		(u32)(0x0)
 #define CM_FCLKEN_IVA2_EN_MASK	(u32)(0x1)
 #define CM_FCLKEN_IVA2_EN_OFFSET	(u32)(0x0)
@@ -232,13 +237,12 @@
 #define CM_FCLKEN1_CORE_OFFSET 	(u32)(0xA00)
 
 #define CM_ICLKEN1_CORE_OFFSET  	(u32)(0xA10)
-#define CM_ICLKEN1_CORE_EN_MAILBOXES_MASK  (u32)(0x00000080)   /* bit 7 */
+#define CM_ICLKEN1_CORE_EN_MAILBOXES_MASK  (u32)(0x00000080)	/* bit 7 */
 #define CM_ICLKEN1_CORE_EN_MAILBOXES_OFFSET	(u32)(7)
 
 #define CM_CLKSTCTRL_IVA2_OFFSET (u32)(0x0)
 #define CM_CLKSTCTRL_IVA2_MASK    (u32)(0x3)
 
-
 #define PRM_RSTCTRL_IVA2_OFFSET  	(u32)(0x50)
 #define PRM_RSTCTRL_IVA2_RST1_MASK	(u32)(0x1)
 #define PRM_RSTCTRL_IVA2_RST1_OFFSET	(u32)(0x0)
@@ -247,54 +251,53 @@
 #define PRM_RSTCTRL_IVA2_RST3_MASK	(u32)(0x4)
 #define PRM_RSTCTRL_IVA2_RST3_OFFSET	(u32)(0x2)
 
-
 /* The following represent the enumerated values for each bitfield */
 
-enum PRCMPRCM_CLKCFG_CTRLValid_configE {
-    PRCMPRCM_CLKCFG_CTRLValid_configUpdated = 0x0000,
-    PRCMPRCM_CLKCFG_CTRLValid_configClk_valid = 0x0001
-} ;
-
-enum PRCMCM_CLKSEL2_CORECLKSEL_GPT8E {
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT832k = 0x0000,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT8Sys = 0x0001,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT8Ext = 0x0002,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT8Reserved = 0x0003
-} ;
-
-enum PRCMCM_CLKSEL2_CORECLKSEL_GPT7E {
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT732k = 0x0000,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT7Sys = 0x0001,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT7Ext = 0x0002,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT7Reserved = 0x0003
-} ;
-
-enum PRCMCM_CLKSEL2_CORECLKSEL_GPT6E {
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT632k = 0x0000,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT6Sys = 0x0001,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT6Ext = 0x0002,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT6Reserved = 0x0003
-} ;
-
-enum PRCMCM_CLKSEL2_CORECLKSEL_GPT5E {
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT532k = 0x0000,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT5Sys = 0x0001,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT5Ext = 0x0002,
-    PRCMCM_CLKSEL2_CORECLKSEL_GPT5Reserved = 0x0003
-} ;
-
-enum PRCMPM_PWSTCTRL_DSPPowerStateE {
-    PRCMPM_PWSTCTRL_DSPPowerStateON = 0x0000,
-    PRCMPM_PWSTCTRL_DSPPowerStateRET = 0x0001,
-    PRCMPM_PWSTCTRL_DSPPowerStateReserved = 0x0002,
-    PRCMPM_PWSTCTRL_DSPPowerStateOFF = 0x0003
-} ;
-
-enum PRCMPM_PWSTCTRL_IVA2PowerStateE {
-    PRCMPM_PWSTCTRL_IVA2PowerStateON = 0x0003,
-    PRCMPM_PWSTCTRL_IVA2PowerStateRET = 0x0001,
-    PRCMPM_PWSTCTRL_IVA2PowerStateReserved = 0x0002,
-    PRCMPM_PWSTCTRL_IVA2PowerStateOFF = 0x0000
-} ;
+enum prcmprcm_clkcfg_ctrl_valid_config_e {
+	PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_UPDATED = 0x0000,
+	PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_CLK_VALID = 0x0001
+};
+
+enum prcmcm_clksel2_coreclksel_gpt8e {
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT832K = 0x0000,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT8_SYS = 0x0001,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT8_EXT = 0x0002,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT8_RESERVED = 0x0003
+};
+
+enum prcmcm_clksel2_coreclksel_gpt7e {
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT732K = 0x0000,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT7_SYS = 0x0001,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT7_EXT = 0x0002,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT7_RESERVED = 0x0003
+};
+
+enum prcmcm_clksel2_coreclksel_gpt6e {
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT632K = 0x0000,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT6_SYS = 0x0001,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT6_EXT = 0x0002,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT6_RESERVED = 0x0003
+};
+
+enum prcmcm_clksel2_coreclksel_gpt5e {
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT532K = 0x0000,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT5_SYS = 0x0001,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT5_EXT = 0x0002,
+	PRCMCM_CLKSEL2_CORECLKSEL_GPT5_RESERVED = 0x0003
+};
+
+enum prcmpm_pwstctrl_dsp_power_state_e {
+	PRCMPM_PWSTCTRL_DSP_POWER_STATE_ON = 0x0000,
+	PRCMPM_PWSTCTRL_DSP_POWER_STATE_RET = 0x0001,
+	PRCMPM_PWSTCTRL_DSP_POWER_STATE_RESERVED = 0x0002,
+	PRCMPM_PWSTCTRL_DSP_POWER_STATE_OFF = 0x0003
+};
+
+enum prcmpm_pwstctrl_iva2_power_state_e {
+	PRCMPM_PWSTCTRL_IVA2_POWER_STATE_ON = 0x0003,
+	PRCMPM_PWSTCTRL_IVA2_POWER_STATE_RET = 0x0001,
+	PRCMPM_PWSTCTRL_IVA2_POWER_STATE_RESERVED = 0x0002,
+	PRCMPM_PWSTCTRL_IVA2_POWER_STATE_OFF = 0x0000
+};
 
 #endif /* _PRCM_ACC_INT_H */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/hw/PRCMRegAcM.h kernel-power-2.6.28.new/drivers/dsp/bridge/hw/PRCMRegAcM.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/hw/PRCMRegAcM.h	2011-10-11 13:51:00.408254520 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/hw/PRCMRegAcM.h	2011-10-23 08:22:37.625950000 +0100
@@ -26,38 +26,35 @@
 
 #if defined(USE_LEVEL_1_MACROS)
 
-#define PRCMPRCM_CLKCFG_CTRLValid_configWriteClk_valid32(baseAddress)\
+#define PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_WRITE_CLK_VALID32(baseAddress)\
 {\
     const u32 offset = PRCM_PRCM_CLKCFG_CTRL_OFFSET;\
     const u32 newValue = \
-	(u32)PRCMPRCM_CLKCFG_CTRLValid_configClk_valid <<\
-      PRCM_PRCM_CLKCFG_CTRL_Valid_config_OFFSET;\
+	(u32)PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_CLK_VALID <<\
+      PRCM_PRCM_CLKCFG_CTRL_VALID_CONFIG_OFFSET;\
     register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(\
-      EASIL1_PRCMPRCM_CLKCFG_CTRLValid_configWriteClk_valid32);\
-    data &= ~(PRCM_PRCM_CLKCFG_CTRL_Valid_config_MASK);\
+    _DEBUG_LEVEL1_EASI(\
+      EASIL1_PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_WRITE_CLK_VALID32);\
+    data &= ~(PRCM_PRCM_CLKCFG_CTRL_VALID_CONFIG_MASK);\
     data |= newValue;\
     __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
-
-#define CM_FCLKEN_PERReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),\
+#define CM_FCLKEN_PER_READ_REGISTER32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN1_CORE_READ_REGISTER32),\
       __raw_readl(((u32)(baseAddress))+CM_FCLKEN_PER_OFFSET))
 
-
-#define CM_ICLKEN_PERReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),\
+#define CM_ICLKEN_PER_READ_REGISTER32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN1_CORE_READ_REGISTER32),\
       __raw_readl(((u32)(baseAddress))+CM_ICLKEN_PER_OFFSET))
 
-
-#define CM_FCLKEN_PER_GPT5WriteRegister32(baseAddress,value)\
+#define CM_FCLKEN_PER_GPT5_WRITE_REGISTER32(baseAddress, value)\
 {\
     const u32 offset = CM_FCLKEN_PER_OFFSET;\
     register u32 data = \
 	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_CM_FCLKEN_PER_GPT5WriteRegister32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_CM_FCLKEN_PER_GPT5_WRITE_REGISTER32);\
    data &= ~(CM_FCLKEN_PER_GPT5_MASK);\
    newValue <<= CM_FCLKEN_PER_GPT5_OFFSET;\
    newValue &= CM_FCLKEN_PER_GPT5_MASK;\
@@ -65,14 +62,13 @@
     __raw_writel(newValue, ((u32)(baseAddress))+offset);\
 }
 
-
-#define CM_FCLKEN_PER_GPT6WriteRegister32(baseAddress,value)\
+#define CM_FCLKEN_PER_GPT6_WRITE_REGISTER32(baseAddress, value)\
 {\
     const u32 offset = CM_FCLKEN_PER_OFFSET;\
     register u32 data =\
 	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_CM_FCLKEN_PER_GPT5WriteRegister32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_CM_FCLKEN_PER_GPT5_WRITE_REGISTER32);\
    data &= ~(CM_FCLKEN_PER_GPT6_MASK);\
    newValue <<= CM_FCLKEN_PER_GPT6_OFFSET;\
    newValue &= CM_FCLKEN_PER_GPT6_MASK;\
@@ -80,14 +76,13 @@
     __raw_writel(newValue, ((u32)(baseAddress))+offset);\
 }
 
-
-#define CM_ICLKEN_PER_GPT5WriteRegister32(baseAddress,value)\
+#define CM_ICLKEN_PER_GPT5_WRITE_REGISTER32(baseAddress, value)\
 {\
     const u32 offset = CM_ICLKEN_PER_OFFSET;\
     register u32 data = \
 	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_CM_ICLKEN_PER_GPT5WriteRegister32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_CM_ICLKEN_PER_GPT5_WRITE_REGISTER32);\
    data &= ~(CM_ICLKEN_PER_GPT5_MASK);\
    newValue <<= CM_ICLKEN_PER_GPT5_OFFSET;\
    newValue &= CM_ICLKEN_PER_GPT5_MASK;\
@@ -95,14 +90,13 @@
     __raw_writel(newValue, ((u32)(baseAddress))+offset);\
 }
 
-
-#define CM_ICLKEN_PER_GPT6WriteRegister32(baseAddress,value)\
+#define CM_ICLKEN_PER_GPT6_WRITE_REGISTER32(baseAddress, value)\
 {\
     const u32 offset = CM_ICLKEN_PER_OFFSET;\
     register u32 data = \
 	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_CM_ICLKEN_PER_GPT5WriteRegister32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_CM_ICLKEN_PER_GPT5_WRITE_REGISTER32);\
    data &= ~(CM_ICLKEN_PER_GPT6_MASK);\
    newValue <<= CM_ICLKEN_PER_GPT6_OFFSET;\
    newValue &= CM_ICLKEN_PER_GPT6_MASK;\
@@ -110,19 +104,17 @@
     __raw_writel(newValue, ((u32)(baseAddress))+offset);\
 }
 
-
-#define CM_FCLKEN1_COREReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),\
+#define CM_FCLKEN1_CORE_READ_REGISTER32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN1_CORE_READ_REGISTER32),\
       __raw_readl(((u32)(baseAddress))+CM_FCLKEN1_CORE_OFFSET))
 
-
-#define PRCMCM_FCLKEN1_COREEN_GPT8Write32(baseAddress,value)\
+#define PRCMCM_FCLKEN1_COREEN_GPT8_WRITE32(baseAddress, value)\
 {\
     const u32 offset = PRCM_CM_FCLKEN1_CORE_OFFSET;\
     register u32 data = \
 	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT8Write32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT8_WRITE32);\
     data &= ~(PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK);\
     newValue <<= PRCM_CM_FCLKEN1_CORE_EN_GPT8_OFFSET;\
     newValue &= PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK;\
@@ -130,14 +122,13 @@
     __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_FCLKEN1_COREEN_GPT7Write32(baseAddress,value)\
+#define PRCMCM_FCLKEN1_COREEN_GPT7_WRITE32(baseAddress, value)\
 {\
     const u32 offset = PRCM_CM_FCLKEN1_CORE_OFFSET;\
     register u32 data = \
 	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT7Write32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT7_WRITE32);\
     data &= ~(PRCM_CM_FCLKEN1_CORE_EN_GPT7_MASK);\
     newValue <<= PRCM_CM_FCLKEN1_CORE_EN_GPT7_OFFSET;\
     newValue &= PRCM_CM_FCLKEN1_CORE_EN_GPT7_MASK;\
@@ -145,19 +136,17 @@
     __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
-
-#define CM_ICLKEN1_COREReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREReadRegister32),\
+#define CM_ICLKEN1_CORE_READ_REGISTER32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_ICLKEN1_CORE_READ_REGISTER32),\
       __raw_readl(((u32)(baseAddress))+CM_ICLKEN1_CORE_OFFSET))
 
-
-#define  CM_ICLKEN1_COREEN_MAILBOXESWrite32(baseAddress, value)\
+#define  CM_ICLKEN1_COREEN_MAILBOXES_WRITE32(baseAddress, value)\
 {\
     const u32 offset = CM_ICLKEN1_CORE_OFFSET;\
     register u32 data = \
 	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_MAILBOXESWrite32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_MAILBOXES_WRITE32);\
     data &= ~(CM_ICLKEN1_CORE_EN_MAILBOXES_MASK);\
     newValue <<= CM_ICLKEN1_CORE_EN_MAILBOXES_OFFSET;\
     newValue &= CM_ICLKEN1_CORE_EN_MAILBOXES_MASK;\
@@ -165,14 +154,13 @@
     __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_ICLKEN1_COREEN_GPT8Write32(baseAddress, value)\
+#define PRCMCM_ICLKEN1_COREEN_GPT8_WRITE32(baseAddress, value)\
 {\
     const u32 offset = PRCM_CM_ICLKEN1_CORE_OFFSET;\
     register u32 data = \
 	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT8Write32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT8_WRITE32);\
     data &= ~(PRCM_CM_ICLKEN1_CORE_EN_GPT8_MASK);\
     newValue <<= PRCM_CM_ICLKEN1_CORE_EN_GPT8_OFFSET;\
     newValue &= PRCM_CM_ICLKEN1_CORE_EN_GPT8_MASK;\
@@ -180,14 +168,13 @@
     __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_ICLKEN1_COREEN_GPT7Write32(baseAddress, value)\
+#define PRCMCM_ICLKEN1_COREEN_GPT7_WRITE32(baseAddress, value)\
 {\
     const u32 offset = PRCM_CM_ICLKEN1_CORE_OFFSET;\
     register u32 data =\
 	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT7Write32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT7_WRITE32);\
     data &= ~(PRCM_CM_ICLKEN1_CORE_EN_GPT7_MASK);\
     newValue <<= PRCM_CM_ICLKEN1_CORE_EN_GPT7_OFFSET;\
     newValue &= PRCM_CM_ICLKEN1_CORE_EN_GPT7_MASK;\
@@ -195,178 +182,164 @@
     __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8Write32k32(baseAddress)\
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE32K32(baseAddress)\
 {\
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT832k <<\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT832K <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;\
     register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8Write32k32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE32K32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);\
     data |= newValue;\
     __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteSys32(baseAddress)\
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_SYS32(baseAddress)\
 {\
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8Sys <<\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8_SYS <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;\
     register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteSys32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_SYS32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);\
     data |= newValue;\
     __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteExt32(baseAddress)\
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_EXT32(baseAddress)\
 {\
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8Ext <<\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8_EXT <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;\
     register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteExt32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_EXT32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);\
     data |= newValue;\
     __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7Write32k32(baseAddress)\
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE32K32(baseAddress)\
 {\
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT732k <<\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT732K <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;\
     register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7Write32k32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE32K32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);\
     data |= newValue;\
     __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteSys32(baseAddress)\
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_SYS32(baseAddress)\
 {\
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7Sys <<\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7_SYS <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;\
     register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteSys32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_SYS32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);\
     data |= newValue;\
     __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteExt32(baseAddress)\
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_EXT32(baseAddress)\
 {\
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7Ext <<\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7_EXT <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;\
     register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteExt32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_EXT32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);\
     data |= newValue;\
     __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteSys32(baseAddress)\
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_SYS32(baseAddress)\
 {\
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6Sys <<\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6_SYS <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_OFFSET;\
     register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteSys32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_SYS32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_MASK);\
     data |= newValue;\
     __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteExt32(baseAddress)\
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_EXT32(baseAddress)\
 {\
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6Ext <<\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6_EXT <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_OFFSET;\
     register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteExt32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_EXT32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_MASK);\
     data |= newValue;\
     __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
-
-#define CM_CLKSEL_PER_GPT5Write32k32(baseAddress)\
+#define CM_CLKSEL_PER_GPT5_WRITE32K32(baseAddress)\
 {\
     const u32 offset = CM_CLKSEL_PER_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532k <<\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532K <<\
       CM_CLKSEL_PER_GPT5_OFFSET;\
     register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_CM_CLKSEL_PER_GPT5Write32k32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_CM_CLKSEL_PER_GPT5_WRITE32K32);\
     data &= ~(CM_CLKSEL_PER_GPT5_MASK);\
     data |= newValue;\
     __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
-
-#define CM_CLKSEL_PER_GPT6Write32k32(baseAddress)\
+#define CM_CLKSEL_PER_GPT6_WRITE32K32(baseAddress)\
 {\
     const u32 offset = CM_CLKSEL_PER_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532k <<\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532K <<\
       CM_CLKSEL_PER_GPT6_OFFSET;\
     register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_CM_CLKSEL_PER_GPT6Write32k32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_CM_CLKSEL_PER_GPT6_WRITE32K32);\
     data &= ~(CM_CLKSEL_PER_GPT6_MASK);\
     data |= newValue;\
     __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteSys32(baseAddress)\
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_SYS32(baseAddress)\
 {\
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5Sys <<\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5_SYS <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET;\
     register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteSys32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_SYS32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK);\
     data |= newValue;\
     __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteExt32(baseAddress)\
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_EXT32(baseAddress)\
 {\
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5Ext <<\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5_EXT <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET;\
     register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteExt32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_EXT32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK);\
     data |= newValue;\
     __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_CLKSEL1_PLLAPLLs_ClkinRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL1_PLLAPLLs_ClkinRead32),\
+#define PRCMCM_CLKSEL1_PLLAPL_LS_CLKIN_READ32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL1_PLLAPL_LS_CLKIN_READ32),\
       (((__raw_readl((((u32)(baseAddress))+\
 	(PRCM_CM_CLKSEL1_PLL_OFFSET)))) &\
-      PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_MASK) >>\
-      PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_OFFSET))
-
+      PRCM_CM_CLKSEL1_PLL_APL_LS_CLKIN_MASK) >>\
+      PRCM_CM_CLKSEL1_PLL_APL_LS_CLKIN_OFFSET))
 
-#define CM_FCLKEN_IVA2EN_DSPWrite32(baseAddress,value)\
+#define CM_FCLKEN_IVA2EN_DSP_WRITE32(baseAddress, value)\
 {\
     const u32 offset = CM_FCLKEN_IVA2_OFFSET;\
     register u32 data = \
 	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN_DSPEN_DSPWrite32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN_DSPEN_DSP_WRITE32);\
     data &= ~(CM_FCLKEN_IVA2_EN_MASK);\
     newValue <<= CM_FCLKEN_IVA2_EN_OFFSET;\
     newValue &= CM_FCLKEN_IVA2_EN_MASK;\
@@ -374,14 +347,13 @@
     __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_ICLKEN_DSPEN_DSP_IPIWrite32(baseAddress, value)\
+#define PRCMCM_ICLKEN_DSPEN_DSP_IPI_WRITE32(baseAddress, value)\
 {\
     const u32 offset = PRCM_CM_ICLKEN_DSP_OFFSET;\
     register u32 data = \
       __raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN_DSPEN_DSP_IPIWrite32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_ICLKEN_DSPEN_DSP_IPI_WRITE32);\
     data &= ~(PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK);\
     newValue <<= PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_OFFSET;\
     newValue &= PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK;\
@@ -389,35 +361,31 @@
     __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_IDLEST_DSPReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPReadRegister32),\
+#define PRCMCM_IDLEST_DSP_READ_REGISTER32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_IDLEST_DSP_READ_REGISTER32),\
       __raw_readl(((u32)(baseAddress))+PRCM_CM_IDLEST_DSP_OFFSET))
 
-
-#define PRCMCM_IDLEST_DSPST_IPIRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_IPIRead32),\
+#define PRCMCM_IDLEST_DSPST_IPI_READ32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_IPI_READ32),\
       (((__raw_readl((((u32)(baseAddress))+\
 	(PRCM_CM_IDLEST_DSP_OFFSET)))) &\
       PRCM_CM_IDLEST_DSP_ST_IPI_MASK) >>\
       PRCM_CM_IDLEST_DSP_ST_IPI_OFFSET))
 
-
-#define PRM_IDLEST_IVA2ST_IVA2Read32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_DSPRead32),\
+#define PRM_IDLEST_IVA2ST_IVA2_READ32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_DSP_READ32),\
       (((__raw_readl((((u32)(baseAddress))+\
 	  (CM_IDLEST_IVA2_OFFSET)))) &\
       CM_IDLEST_IVA2_ST_IVA2_MASK) >>\
       CM_IDLEST_IVA2_ST_IVA2_OFFSET))
 
-
-#define PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPIWrite32(baseAddress, value)\
+#define PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPI_WRITE32(baseAddress, value)\
 {\
     const u32 offset = PRCM_CM_AUTOIDLE_DSP_OFFSET;\
     register u32 data =\
       __raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPIWrite32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPI_WRITE32);\
     data &= ~(PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_MASK);\
     newValue <<= PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_OFFSET;\
     newValue &= PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_MASK;\
@@ -425,14 +393,13 @@
     __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_CLKSEL_DSPSYNC_DSPWrite32(baseAddress,value)\
+#define PRCMCM_CLKSEL_DSPSYNC_DSP_WRITE32(baseAddress, value)\
 {\
     const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;\
     register u32 data = \
 	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPSYNC_DSPWrite32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL_DSPSYNC_DSP_WRITE32);\
     data &= ~(PRCM_CM_CLKSEL_DSP_SYNC_DSP_MASK);\
     newValue <<= PRCM_CM_CLKSEL_DSP_SYNC_DSP_OFFSET;\
     newValue &= PRCM_CM_CLKSEL_DSP_SYNC_DSP_MASK;\
@@ -440,14 +407,13 @@
     __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_CLKSEL_DSPCLKSEL_DSP_IFWrite32(baseAddress, value)\
+#define PRCMCM_CLKSEL_DSPCLKSEL_DSP_IF_WRITE32(baseAddress, value)\
 {\
     const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;\
     register u32 data = \
       __raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_IFWrite32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_IF_WRITE32);\
     data &= ~(PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_MASK);\
     newValue <<= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_OFFSET;\
     newValue &= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_MASK;\
@@ -455,14 +421,13 @@
     __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_CLKSEL_DSPCLKSEL_DSPWrite32(baseAddress, value)\
+#define PRCMCM_CLKSEL_DSPCLKSEL_DSP_WRITE32(baseAddress, value)\
 {\
     const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;\
     register u32 data = \
       __raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSPWrite32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_WRITE32);\
     data &= ~(PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK);\
     newValue <<= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_OFFSET;\
     newValue &= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK;\
@@ -470,14 +435,13 @@
     __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMCM_CLKSTCTRL_IVA2WriteRegister32(baseAddress, value)\
+#define PRCMCM_CLKSTCTRL_IVA2_WRITE_REGISTER32(baseAddress, value)\
 {\
     const u32 offset = PRCM_CM_CLKSTCTRL_IVA2_OFFSET;\
     register u32 data = \
       __raw_readl(((baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_IVA2WriteRegister32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSTCTRL_IVA2_WRITE_REGISTER32);\
     data &= ~(CM_CLKSTCTRL_IVA2_MASK);\
     newValue <<= CM_CLKSTCTRL_IVA2_OFFSET;\
     newValue &= CM_CLKSTCTRL_IVA2_MASK;\
@@ -485,42 +449,38 @@
     __raw_writel(newValue, (baseAddress)+offset);\
 }
 
-
-#define PRCMCM_CLKSTCTRL_DSPAutostate_DSPRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPRead32),\
+#define PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_READ32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_READ32),\
       (((__raw_readl((((u32)(baseAddress))+\
 	(PRCM_CM_CLKSTCTRL_DSP_OFFSET)))) &\
-      PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK) >>\
-      PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_OFFSET))
+      PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_MASK) >>\
+      PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_OFFSET))
 
-
-#define PRCMCM_CLKSTCTRL_DSPAutostate_DSPWrite32(baseAddress, value)\
+#define PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_WRITE32(baseAddress, value)\
 {\
     const u32 offset = PRCM_CM_CLKSTCTRL_DSP_OFFSET;\
     register u32 data = \
 	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPWrite32);\
-    data &= ~(PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK);\
-    newValue <<= PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_OFFSET;\
-    newValue &= PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK;\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_WRITE32);\
+    data &= ~(PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_MASK);\
+    newValue <<= PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_OFFSET;\
+    newValue &= PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_MASK;\
     newValue |= data;\
     __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMRM_RSTCTRL_DSPReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPReadRegister32),\
+#define PRCMRM_RSTCTRL_DSP_READ_REGISTER32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTCTRL_DSP_READ_REGISTER32),\
       __raw_readl(((baseAddress))+PRCM_RM_RSTCTRL_DSP_OFFSET))
 
-
-#define PRM_RSTCTRL_IVA2RST1_DSPWrite32(baseAddress,value)\
+#define PRM_RSTCTRL_IVA2RST1_DSP_WRITE32(baseAddress, value)\
 {\
     const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;\
     register u32 data =\
     __raw_readl(((baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSP_WRITE32);\
     data &= ~(PRM_RSTCTRL_IVA2_RST1_MASK);\
     newValue <<= PRM_RSTCTRL_IVA2_RST1_OFFSET;\
     newValue &= PRM_RSTCTRL_IVA2_RST1_MASK;\
@@ -528,14 +488,13 @@
     __raw_writel(newValue, (baseAddress)+offset);\
 }
 
-
-#define PRM_RSTCTRL_IVA2RST2_DSPWrite32(baseAddress,value)\
+#define PRM_RSTCTRL_IVA2RST2_DSP_WRITE32(baseAddress, value)\
 {\
     const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;\
     register u32 data =\
 	__raw_readl(((baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSP_WRITE32);\
     data &= ~(PRM_RSTCTRL_IVA2_RST2_MASK);\
     newValue <<= PRM_RSTCTRL_IVA2_RST2_OFFSET;\
     newValue &= PRM_RSTCTRL_IVA2_RST2_MASK;\
@@ -543,14 +502,13 @@
     __raw_writel(newValue, (baseAddress)+offset);\
 }
 
-
-#define PRM_RSTCTRL_IVA2RST3_DSPWrite32(baseAddress,value)\
+#define PRM_RSTCTRL_IVA2RST3_DSP_WRITE32(baseAddress, value)\
 {\
     const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;\
     register u32 data =\
       __raw_readl(((baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSP_WRITE32);\
     data &= ~(PRM_RSTCTRL_IVA2_RST3_MASK);\
     newValue <<= PRM_RSTCTRL_IVA2_RST3_OFFSET;\
     newValue &= PRM_RSTCTRL_IVA2_RST3_MASK;\
@@ -558,113 +516,100 @@
     __raw_writel(newValue, (baseAddress)+offset);\
 }
 
-
-#define PRCMRM_RSTST_DSPReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTST_DSPReadRegister32),\
+#define PRCMRM_RSTST_DSP_READ_REGISTER32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTST_DSP_READ_REGISTER32),\
       __raw_readl(((baseAddress))+PRCM_RM_RSTST_DSP_OFFSET))
 
-
-#define PRCMRM_RSTST_DSPWriteRegister32(baseAddress,value)\
+#define PRCMRM_RSTST_DSP_WRITE_REGISTER32(baseAddress, value)\
 {\
     const u32 offset = PRCM_RM_RSTST_DSP_OFFSET;\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTST_DSPWriteRegister32);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTST_DSP_WRITE_REGISTER32);\
     __raw_writel(newValue, ((u32)(baseAddress))+offset);\
 }
 
-
-#define PRCMPM_PWSTCTRL_DSPForceStateWrite32(baseAddress, value)\
+#define PRCMPM_PWSTCTRL_DSP_FORCE_STATE_WRITE32(baseAddress, value)\
 {\
     const u32 offset = PRCM_PM_PWSTCTRL_DSP_OFFSET;\
     register u32 data = \
 	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSPForceStateWrite32);\
-    data &= ~(PRCM_PM_PWSTCTRL_DSP_ForceState_MASK);\
-    newValue <<= PRCM_PM_PWSTCTRL_DSP_ForceState_OFFSET;\
-    newValue &= PRCM_PM_PWSTCTRL_DSP_ForceState_MASK;\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSP_FORCE_STATE_WRITE32);\
+    data &= ~(PRCM_PM_PWSTCTRL_DSP_FORCE_STATE_MASK);\
+    newValue <<= PRCM_PM_PWSTCTRL_DSP_FORCE_STATE_OFFSET;\
+    newValue &= PRCM_PM_PWSTCTRL_DSP_FORCE_STATE_MASK;\
     newValue |= data;\
     __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
-
-#define PRCMPM_PWSTCTRL_IVA2PowerStateWriteON32(baseAddress)\
+#define PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_ON32(baseAddress)\
 {\
     const u32 offset = PRCM_PM_PWSTCTRL_IVA2_OFFSET;\
-    const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2PowerStateON <<\
-      PRCM_PM_PWSTCTRL_IVA2_PowerState_OFFSET;\
+    const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2_POWER_STATE_ON <<\
+      PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_OFFSET;\
     register u32 data = __raw_readl((baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteON32);\
-    data &= ~(PRCM_PM_PWSTCTRL_IVA2_PowerState_MASK);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_ON32);\
+    data &= ~(PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_MASK);\
     data |= newValue;\
     __raw_writel(data, (baseAddress)+offset);\
 }
 
-
-#define PRCMPM_PWSTCTRL_IVA2PowerStateWriteOFF32(baseAddress)\
+#define PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_OFF32(baseAddress)\
 {\
     const u32 offset = PRCM_PM_PWSTCTRL_IVA2_OFFSET;\
-    const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2PowerStateOFF <<\
-      PRCM_PM_PWSTCTRL_IVA2_PowerState_OFFSET;\
+    const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2_POWER_STATE_OFF <<\
+      PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_OFFSET;\
     register u32 data = __raw_readl((baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteOFF32);\
-    data &= ~(PRCM_PM_PWSTCTRL_IVA2_PowerState_MASK);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_OFF32);\
+    data &= ~(PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_MASK);\
     data |= newValue;\
     __raw_writel(data, (baseAddress)+offset);\
 }
 
-
-#define PRCMPM_PWSTCTRL_DSPPowerStateWriteRET32(baseAddress)\
+#define PRCMPM_PWSTCTRL_DSP_POWER_STATE_WRITE_RET32(baseAddress)\
 {\
     const u32 offset = PRCM_PM_PWSTCTRL_DSP_OFFSET;\
-    const u32 newValue = (u32)PRCMPM_PWSTCTRL_DSPPowerStateRET <<\
-      PRCM_PM_PWSTCTRL_DSP_PowerState_OFFSET;\
+    const u32 newValue = (u32)PRCMPM_PWSTCTRL_DSP_POWER_STATE_RET <<\
+      PRCM_PM_PWSTCTRL_DSP_POWER_STATE_OFFSET;\
     register u32 data = __raw_readl((baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSPPowerStateWriteRET32);\
-    data &= ~(PRCM_PM_PWSTCTRL_DSP_PowerState_MASK);\
+    _DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSP_POWER_STATE_WRITE_RET32);\
+    data &= ~(PRCM_PM_PWSTCTRL_DSP_POWER_STATE_MASK);\
     data |= newValue;\
     __raw_writel(data, (baseAddress)+offset);\
 }
 
-
-#define PRCMPM_PWSTST_DSPReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_DSPReadRegister32),\
+#define PRCMPM_PWSTST_DSP_READ_REGISTER32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_DSP_READ_REGISTER32),\
       __raw_readl(((u32)(baseAddress))+PRCM_PM_PWSTST_DSP_OFFSET))
 
-
-#define PRCMPM_PWSTST_IVA2ReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_IVA2ReadRegister32),\
+#define PRCMPM_PWSTST_IVA2_READ_REGISTER32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_IVA2_READ_REGISTER32),\
       __raw_readl((baseAddress) + PRCM_PM_PWSTST_IVA2_OFFSET))
 
-
-#define PRCMPM_PWSTST_DSPInTransitionRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_DSPInTransitionRead32),\
+#define PRCMPM_PWSTST_DSP_IN_TRANSITION_READ32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_DSP_IN_TRANSITION_READ32),\
       (((__raw_readl((((u32)(baseAddress))+\
 	(PRCM_PM_PWSTST_DSP_OFFSET)))) &\
-      PRCM_PM_PWSTST_DSP_InTransition_MASK) >>\
-      PRCM_PM_PWSTST_DSP_InTransition_OFFSET))
+      PRCM_PM_PWSTST_DSP_IN_TRANSITION_MASK) >>\
+      PRCM_PM_PWSTST_DSP_IN_TRANSITION_OFFSET))
 
-
-#define PRCMPM_PWSTST_IVA2InTransitionRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_IVA2InTransitionRead32),\
+#define PRCMPM_PWSTST_IVA2_IN_TRANSITION_READ32(baseAddress)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_IVA2_IN_TRANSITION_READ32),\
       (((__raw_readl((((baseAddress))+\
 	(PRCM_PM_PWSTST_IVA2_OFFSET)))) &\
-      PRCM_PM_PWSTST_IVA2_InTransition_MASK) >>\
-      PRCM_PM_PWSTST_IVA2_InTransition_OFFSET))
-
-
-#define PRCMPM_PWSTST_DSPPowerStateStGet32(var)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_DSPPowerStateStGet32),\
-      (u32)((((u32)(var)) & PRCM_PM_PWSTST_DSP_PowerStateSt_MASK) >>\
-	PRCM_PM_PWSTST_DSP_PowerStateSt_OFFSET))
-
-
-#define PRCMPM_PWSTST_IVA2PowerStateStGet32(var)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_IVA2PowerStateStGet32),\
-      (u32)((((u32)(var)) & PRCM_PM_PWSTST_IVA2_PowerStateSt_MASK) >>\
-      PRCM_PM_PWSTST_IVA2_PowerStateSt_OFFSET))
+      PRCM_PM_PWSTST_IVA2_IN_TRANSITION_MASK) >>\
+      PRCM_PM_PWSTST_IVA2_IN_TRANSITION_OFFSET))
 
+#define PRCMPM_PWSTST_DSP_POWER_STATE_ST_GET32(var)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_DSP_POWER_STATE_ST_GET32),\
+      (u32)((((u32)(var)) & PRCM_PM_PWSTST_DSP_POWER_STATE_ST_MASK) >>\
+	PRCM_PM_PWSTST_DSP_POWER_STATE_ST_OFFSET))
+
+#define PRCMPM_PWSTST_IVA2_POWER_STATE_ST_GET32(var)\
+    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_IVA2_POWER_STATE_ST_GET32),\
+      (u32)((((u32)(var)) & PRCM_PM_PWSTST_IVA2_POWER_STATE_ST_MASK) >>\
+      PRCM_PM_PWSTST_IVA2_POWER_STATE_ST_OFFSET))
 
-#endif  /* USE_LEVEL_1_MACROS */
+#endif /* USE_LEVEL_1_MACROS */
 
 #endif /* _PRCM_REG_ACM_H */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/Kbuild kernel-power-2.6.28.new/drivers/dsp/bridge/Kbuild
--- kernel-cssu-2.6.28/drivers/dsp/bridge/Kbuild	2011-10-11 13:51:00.408254520 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/Kbuild	1970-01-01 01:00:00.000000000 +0100
@@ -1,39 +0,0 @@
-obj-$(CONFIG_MPU_BRIDGE)	+= bridgedriver.o
-
-libgen = gen/gb.o gen/gt.o gen/gs.o gen/gh.o gen/_gt_para.o gen/uuidutil.o
-libservices = services/csl.o services/mem.o services/list.o services/dpc.o \
-               services/kfile.o services/sync.o \
-		services/clk.o services/cfg.o services/reg.o \
-               services/regsup.o services/ntfy.o \
-		services/dbg.o services/services.o
-libwmd = wmd/chnl_sm.o wmd/msg_sm.o wmd/io_sm.o wmd/tiomap3430.o \
-		wmd/tiomap3430_pwr.o wmd/tiomap_sm.o wmd/tiomap_io.o \
-		wmd/mmu_fault.o wmd/ue_deh.o
-libpmgr = pmgr/chnl.o pmgr/io.o pmgr/msg.o pmgr/cod.o pmgr/dev.o pmgr/wcd.o \
-		pmgr/dmm.o pmgr/cmm.o pmgr/dbll.o
-librmgr = rmgr/dbdcd.o rmgr/disp.o rmgr/drv.o rmgr/mgr.o rmgr/node.o \
-		rmgr/proc.o rmgr/pwr.o rmgr/rmm.o rmgr/strm.o rmgr/dspdrv.o \
-		rmgr/nldr.o rmgr/drv_interface.o
-libdload = dynload/cload.o dynload/getsection.o dynload/reloc.o
-libhw = hw/hw_prcm.o hw/hw_dspssC64P.o hw/hw_mmu.o hw/hw_mbox.o
-
-bridgedriver-objs = $(libgen) $(libservices) $(libwmd) $(libpmgr) $(librmgr) \
-			$(libdload) $(libhw)
-
-# Debug
-ifeq ($(CONFIG_BRIDGE_DEBUG),y)
-ccflags-y += -DGT_TRACE -DDEBUG
-endif
-
-#Machine dependent
-ccflags-y += -D_TI_ -D_DB_TIOMAP -DTMS32060 \
-		-DTICFG_PROC_VER -DTICFG_EVM_TYPE -DCHNL_SMCLASS \
-		-DCHNL_MESSAGES -DUSE_LEVEL_1_MACROS
-
-#Header files
-ccflags-y += -Idrivers/dsp/bridge/services
-ccflags-y += -Idrivers/dsp/bridge/wmd
-ccflags-y += -Idrivers/dsp/bridge/pmgr
-ccflags-y += -Idrivers/dsp/bridge/rmgr
-ccflags-y += -Idrivers/dsp/bridge/hw
-ccflags-y += -Iarch/arm
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/Kconfig kernel-power-2.6.28.new/drivers/dsp/bridge/Kconfig
--- kernel-cssu-2.6.28/drivers/dsp/bridge/Kconfig	2011-10-11 13:51:00.408254520 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/Kconfig	2011-10-17 19:50:11.485124792 +0100
@@ -5,15 +5,17 @@
 menuconfig MPU_BRIDGE
 	tristate "DSP Bridge driver"
 	default n
+	select OMAP_MBOX_FWK
 	help
 	  DSP/BIOS Bridge is designed for platforms that contain a GPP and
 	  one or more attached DSPs.  The GPP is considered the master or
 	  "host" processor, and the attached DSPs are processing resources
 	  that can be utilized by applications and drivers running on the GPP.
+	  This driver depends on OMAP Mailbox (OMAP_MBOX_FWK).
 
 config BRIDGE_DVFS
 	bool "Enable Bridge Dynamic Voltage and Frequency Scaling (DVFS)"
-	depends on MPU_BRIDGE && OMAP_PM_SRF
+	depends on MPU_BRIDGE && OMAP_PM_SRF && CPU_FREQ
 	default n
 	help
 	  DVFS allows DSP Bridge to initiate the operating point change to
@@ -34,3 +36,58 @@
 	depends on MPU_BRIDGE
 	help
 	  Say Y to enable Bridge debugging capabilities
+
+config BRIDGE_RECOVERY
+	bool "DSP Recovery Support"
+	depends on MPU_BRIDGE
+	help
+	  In case of DSP fatal error, BRIDGE driver will try to
+	  recover itself.
+
+config BRIDGE_CACHE_LINE_CHECK
+	bool "Check buffers to be 128 byte aligned"
+	depends on MPU_BRIDGE
+	default n
+	help
+	  When the DSP processes data, the DSP cache controller loads 128-Byte
+	  chunks (lines) from SDRAM and writes the data back in 128-Byte chunks.
+	  If a DMM buffer does not start and end on a 128-Byte boundary, the data
+	  preceding the start address (SA) from the 128-Byte boundary to the SA
+	  and the data at addresses trailing the end address (EA) from the EA to
+	  the next 128-Byte boundary will be loaded and written back as well.
+	  This can lead to heap corruption. Say Y, to enforce the check for 128
+	  byte alignment, buffers failing this check will be rejected.
+
+config BRIDGE_WDT3
+	bool "Enable WDT3 interruptions"
+	depends on MPU_BRIDGE
+	default n
+	help
+	  WTD3 is managed by DSP and once it is enabled, DSP side bridge is in
+	  charge of refreshing the timer before overflow, if the DSP hangs MPU
+	  will caught the interrupt and try to recover DSP.
+
+config WDT_TIMEOUT
+	int "DSP watchdog timer timeout (in secs)"
+	depends on BRIDGE_WDT3
+	default 5
+	help
+	   Watchdog timer timeout value, after that time if the watchdog timer
+	   counter is not reset the wdt overflow interrupt will be triggered
+
+comment "Bridge Notifications"
+	depends on MPU_BRIDGE
+
+config BRIDGE_NTFY_PWRERR
+	bool "Notify DSP Power Error"
+	depends on MPU_BRIDGE
+	help
+	  Enable notifications to registered clients on the event of power errror
+	  trying to suspend bridge driver. Say Y, to signal this event as a fatal
+	  error, this will require a bridge restart to recover.
+
+config BRIDGE_NEW_API
+	bool "DSP Bridge new API"
+	depends on MPU_BRIDGE
+	help
+	  Say Y to allow only new DSP API(ioctl codes)
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/Makefile kernel-power-2.6.28.new/drivers/dsp/bridge/Makefile
--- kernel-cssu-2.6.28/drivers/dsp/bridge/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/Makefile	2011-10-17 19:52:37.640889272 +0100
@@ -0,0 +1,40 @@
+obj-$(CONFIG_MPU_BRIDGE)	+= bridgedriver.o
+
+libgen = gen/gb.o gen/gs.o gen/gh.o gen/uuidutil.o
+libservices = services/mem.o services/sync.o \
+		services/clk.o services/cfg.o services/reg.o \
+               services/regsup.o services/ntfy.o \
+		services/services.o
+libwmd = wmd/chnl_sm.o wmd/msg_sm.o wmd/io_sm.o wmd/tiomap3430.o \
+		wmd/tiomap3430_pwr.o wmd/tiomap_io.o \
+		wmd/mmu_fault.o wmd/ue_deh.o wmd/wdt.o
+libpmgr = pmgr/chnl.o pmgr/io.o pmgr/msg.o pmgr/cod.o pmgr/dev.o pmgr/wcd.o \
+		pmgr/dmm.o pmgr/cmm.o pmgr/dbll.o
+librmgr = rmgr/dbdcd.o rmgr/disp.o rmgr/drv.o rmgr/mgr.o rmgr/node.o \
+		rmgr/proc.o rmgr/pwr.o rmgr/rmm.o rmgr/strm.o rmgr/dspdrv.o \
+		rmgr/nldr.o rmgr/drv_interface.o
+librmgr += rmgr/policy.o
+libdload = dynload/cload.o dynload/getsection.o dynload/reloc.o \
+		 dynload/tramp.o
+libhw = hw/hw_prcm.o hw/hw_dspssC64P.o hw/hw_mmu.o
+
+bridgedriver-objs = $(libgen) $(libservices) $(libwmd) $(libpmgr) $(librmgr) \
+			$(libdload) $(libhw)
+
+#New DSP API only
+ifeq ($(CONFIG_BRIDGE_NEW_API),y)
+ccflags-y += -DBRIDGE_NEW_API
+endif
+
+#Machine dependent
+ccflags-y += -D_TI_ -D_DB_TIOMAP -DTMS32060 \
+		-DTICFG_PROC_VER -DTICFG_EVM_TYPE -DCHNL_SMCLASS \
+		-DCHNL_MESSAGES -DUSE_LEVEL_1_MACROS
+
+#Header files
+ccflags-y += -Idrivers/dsp/bridge/services
+ccflags-y += -Idrivers/dsp/bridge/wmd
+ccflags-y += -Idrivers/dsp/bridge/pmgr
+ccflags-y += -Idrivers/dsp/bridge/rmgr
+ccflags-y += -Idrivers/dsp/bridge/hw
+ccflags-y += -Iarch/arm
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/chnl.c kernel-power-2.6.28.new/drivers/dsp/bridge/pmgr/chnl.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/chnl.c	2011-10-11 13:51:00.877974626 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/pmgr/chnl.c	2011-10-23 08:22:37.625950000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * WCD channel interface: multiplexes data streams through the single
+ * physical link managed by a Bridge mini-driver.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,54 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== chnl.c ========
- *  Description:
- *      WCD channel interface: multiplexes data streams through the single
- *      physical link managed by a 'Bridge mini-driver.
- *
- *  Public Functions:
- *      CHNL_Close
- *      CHNL_CloseOrphans
- *      CHNL_Create
- *      CHNL_Destroy
- *      CHNL_Exit
- *      CHNL_GetHandle
- *      CHNL_GetProcessHandle
- *      CHNL_Init
- *      CHNL_Open
- *
- *  Notes:
- *      This interface is basically a pass through to the WMD CHNL functions,
- *      except for the CHNL_Get() accessor functions which call
- *      WMD_CHNL_GetInfo().
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 swa PMGR Code review comments incorporated.
- *! 07-Jan-2002 ag  CHNL_CloseOrphans() now closes supported # of channels.
- *! 17-Nov-2000 jeh Removed IRQ, shared memory stuff from CHNL_Create.
- *! 28-Feb-2000 rr: New GT USage Implementation
- *! 03-Feb-2000 rr: GT and Module init/exit Changes.(Done up front from
- *!		    SERVICES)
- *! 21-Jan-2000 ag: Added code review comments.
- *! 13-Jan-2000 rr: CFG_Get/SetPrivateDword renamed to CFG_Get/SetDevObject.
- *! 08-Dec-1999 ag: CHNL_[Alloc|Free]Buffer bufs taken from client process heap.
- *! 02-Dec-1999 ag: Implemented CHNL_GetEventHandle().
- *! 17-Nov-1999 ag: CHNL_AllocBuffer() allocs extra word for process mapping.
- *! 28-Oct-1999 ag: WinCE port. Search for "WinCE" for changes(TBR).
- *! 07-Jan-1998 gp: CHNL_[Alloc|Free]Buffer now call MEM_UMB functions.
- *! 22-Oct-1997 gp: Removed requirement in CHNL_Open that hReserved1 != NULL.
- *! 30-Aug-1997 cr: Renamed cfg.h wbwcd.h b/c of WINNT file name collision.
- *! 10-Mar-1997 gp: Added GT trace.
- *! 14-Jan-1997 gp: Updated based on code review feedback.
- *! 03-Jan-1997 gp: Moved CHNL_AllocBuffer/CHNL_FreeBuffer code from udspsys.
- *! 14-Dec-1996 gp: Added uChnlId parameter to CHNL_Open().
- *! 09-Sep-1996 gp: Added CHNL_GetProcessHandle().
- *! 15-Jul-1996 gp: Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -72,13 +27,9 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/cfg.h>
-#include <dspbridge/csl.h>
-#include <dspbridge/dpc.h>
-#include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/sync.h>
 
@@ -94,167 +45,123 @@
 #include <dspbridge/chnl.h>
 
 /*  ----------------------------------- Globals */
-static u32 cRefs;
-#if GT_TRACE
-static struct GT_Mask CHNL_DebugMask = { NULL, NULL };	/* WCD CHNL Mask */
-#endif
-
-
+static u32 refs;
 
 /*
- *  ======== CHNL_Create ========
+ *  ======== chnl_create ========
  *  Purpose:
  *      Create a channel manager object, responsible for opening new channels
  *      and closing old ones for a given 'Bridge board.
  */
-DSP_STATUS CHNL_Create(OUT struct CHNL_MGR **phChnlMgr,
-		       struct DEV_OBJECT *hDevObject,
-		       IN CONST struct CHNL_MGRATTRS *pMgrAttrs)
+dsp_status chnl_create(OUT struct chnl_mgr **phChnlMgr,
+		       struct dev_object *hdev_obj,
+		       IN CONST struct chnl_mgrattrs *pMgrAttrs)
 {
-	DSP_STATUS status;
-	struct CHNL_MGR *hChnlMgr;
-	struct CHNL_MGR_ *pChnlMgr = NULL;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(phChnlMgr != NULL);
-	DBC_Require(pMgrAttrs != NULL);
-
-	GT_3trace(CHNL_DebugMask, GT_ENTER,
-		  "Entered CHNL_Create: phChnlMgr: 0x%x\t"
-		  "hDevObject: 0x%x\tpMgrAttrs:0x%x\n",
-		  phChnlMgr, hDevObject, pMgrAttrs);
+	dsp_status status;
+	struct chnl_mgr *hchnl_mgr;
+	struct chnl_mgr_ *chnl_mgr_obj = NULL;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phChnlMgr != NULL);
+	DBC_REQUIRE(pMgrAttrs != NULL);
 
 	*phChnlMgr = NULL;
 
 	/* Validate args: */
-	if ((0 < pMgrAttrs->cChannels) &&
-	   (pMgrAttrs->cChannels <= CHNL_MAXCHANNELS)) {
+	if ((0 < pMgrAttrs->max_channels) &&
+	    (pMgrAttrs->max_channels <= CHNL_MAXCHANNELS))
 		status = DSP_SOK;
-	} else if (pMgrAttrs->cChannels == 0) {
+	else if (pMgrAttrs->max_channels == 0)
 		status = DSP_EINVALIDARG;
-		GT_0trace(CHNL_DebugMask, GT_7CLASS,
-			  "CHNL_Create:Invalid Args\n");
-	} else {
+	else
 		status = CHNL_E_MAXCHANNELS;
-		GT_0trace(CHNL_DebugMask, GT_7CLASS,
-			  "CHNL_Create:Error Max Channels\n");
-	}
-	if (pMgrAttrs->uWordSize == 0) {
+
+	if (pMgrAttrs->word_size == 0)
 		status = CHNL_E_INVALIDWORDSIZE;
-		GT_0trace(CHNL_DebugMask, GT_7CLASS,
-			  "CHNL_Create:Invalid Word size\n");
-	}
+
 	if (DSP_SUCCEEDED(status)) {
-		status = DEV_GetChnlMgr(hDevObject, &hChnlMgr);
-		if (DSP_SUCCEEDED(status) && hChnlMgr != NULL)
+		status = dev_get_chnl_mgr(hdev_obj, &hchnl_mgr);
+		if (DSP_SUCCEEDED(status) && hchnl_mgr != NULL)
 			status = CHNL_E_MGREXISTS;
 
 	}
 
 	if (DSP_SUCCEEDED(status)) {
-		struct WMD_DRV_INTERFACE *pIntfFxns;
-		DEV_GetIntfFxns(hDevObject, &pIntfFxns);
+		struct bridge_drv_interface *intf_fxns;
+		dev_get_intf_fxns(hdev_obj, &intf_fxns);
 		/* Let WMD channel module finish the create: */
-		status = (*pIntfFxns->pfnChnlCreate)(&hChnlMgr, hDevObject,
-			  pMgrAttrs);
+		status = (*intf_fxns->pfn_chnl_create) (&hchnl_mgr, hdev_obj,
+							pMgrAttrs);
 		if (DSP_SUCCEEDED(status)) {
 			/* Fill in WCD channel module's fields of the
-			 * CHNL_MGR structure */
-			pChnlMgr = (struct CHNL_MGR_ *)hChnlMgr;
-			pChnlMgr->pIntfFxns = pIntfFxns;
+			 * chnl_mgr structure */
+			chnl_mgr_obj = (struct chnl_mgr_ *)hchnl_mgr;
+			chnl_mgr_obj->intf_fxns = intf_fxns;
 			/* Finally, return the new channel manager handle: */
-			*phChnlMgr = hChnlMgr;
-			GT_1trace(CHNL_DebugMask, GT_1CLASS,
-				  "CHNL_Create: Success pChnlMgr:"
-				  "0x%x\n", pChnlMgr);
+			*phChnlMgr = hchnl_mgr;
 		}
 	}
 
-	GT_2trace(CHNL_DebugMask, GT_ENTER,
-		  "Exiting CHNL_Create: pChnlMgr: 0x%x,"
-		  "status: 0x%x\n", pChnlMgr, status);
-	DBC_Ensure(DSP_FAILED(status) || CHNL_IsValidMgr(pChnlMgr));
+	DBC_ENSURE(DSP_FAILED(status) || CHNL_IS_VALID_MGR(chnl_mgr_obj));
 
 	return status;
 }
 
 /*
- *  ======== CHNL_Destroy ========
+ *  ======== chnl_destroy ========
  *  Purpose:
  *      Close all open channels, and destroy the channel manager.
  */
-DSP_STATUS CHNL_Destroy(struct CHNL_MGR *hChnlMgr)
+dsp_status chnl_destroy(struct chnl_mgr *hchnl_mgr)
 {
-	struct CHNL_MGR_ *pChnlMgr = (struct CHNL_MGR_ *)hChnlMgr;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	DSP_STATUS status;
-
-	DBC_Require(cRefs > 0);
-
-	GT_1trace(CHNL_DebugMask, GT_ENTER,
-		  "Entered CHNL_Destroy: hChnlMgr: 0x%x\n", hChnlMgr);
-	if (CHNL_IsValidMgr(pChnlMgr)) {
-		pIntfFxns = pChnlMgr->pIntfFxns;
-		/* Let WMD channel module destroy the CHNL_MGR: */
-		status = (*pIntfFxns->pfnChnlDestroy)(hChnlMgr);
+	struct chnl_mgr_ *chnl_mgr_obj = (struct chnl_mgr_ *)hchnl_mgr;
+	struct bridge_drv_interface *intf_fxns;
+	dsp_status status;
+
+	DBC_REQUIRE(refs > 0);
+
+	if (CHNL_IS_VALID_MGR(chnl_mgr_obj)) {
+		intf_fxns = chnl_mgr_obj->intf_fxns;
+		/* Let WMD channel module destroy the chnl_mgr: */
+		status = (*intf_fxns->pfn_chnl_destroy) (hchnl_mgr);
 	} else {
-		GT_0trace(CHNL_DebugMask, GT_7CLASS,
-			  "CHNL_Destroy:Invalid Handle\n");
 		status = DSP_EHANDLE;
 	}
 
-	GT_2trace(CHNL_DebugMask, GT_ENTER,
-		  "Exiting CHNL_Destroy: pChnlMgr: 0x%x,"
-		  " status:0x%x\n", pChnlMgr, status);
-	DBC_Ensure(DSP_FAILED(status) || !CHNL_IsValidMgr(pChnlMgr));
+	DBC_ENSURE(DSP_FAILED(status) || !CHNL_IS_VALID_MGR(chnl_mgr_obj));
 
 	return status;
 }
 
 /*
- *  ======== CHNL_Exit ========
+ *  ======== chnl_exit ========
  *  Purpose:
  *      Discontinue usage of the CHNL module.
  */
-void CHNL_Exit(void)
+void chnl_exit(void)
 {
-	DBC_Require(cRefs > 0);
-
-	cRefs--;
+	DBC_REQUIRE(refs > 0);
 
-	GT_1trace(CHNL_DebugMask, GT_5CLASS,
-		  "Entered CHNL_Exit, ref count: 0x%x\n", cRefs);
+	refs--;
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
-
 /*
- *  ======== CHNL_Init ========
+ *  ======== chnl_init ========
  *  Purpose:
  *      Initialize the CHNL module's private state.
  */
-bool CHNL_Init(void)
+bool chnl_init(void)
 {
-	bool fRetval = true;
+	bool ret = true;
 
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (cRefs == 0) {
-		DBC_Assert(!CHNL_DebugMask.flags);
-		GT_create(&CHNL_DebugMask, "CH");   /* "CH" for CHannel */
-	}
-
-	if (fRetval)
-		cRefs++;
-
-	GT_1trace(CHNL_DebugMask, GT_5CLASS,
-		  "Entered CHNL_Init, ref count: 0x%x\n",
-		  cRefs);
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	return fRetval;
+	return ret;
 }
-
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/chnlobj.h kernel-power-2.6.28.new/drivers/dsp/bridge/pmgr/chnlobj.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/chnlobj.h	2011-10-11 13:51:00.887728995 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/pmgr/chnlobj.h	2011-10-23 08:22:37.625950000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Structure subcomponents of channel class library channel objects which
+ * are exposed to class driver from mini-driver.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,24 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== chnlobj.h ========
- *  Description:
- *      Structure subcomponents of channel class library channel objects which
- *      are exposed to class driver from mini-driver.
- *
- *  Public Functions:
- *      None.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 swa 	PMGR Code review comments incorporated.
- *! 17-Nov-2000 jeh     Removed some fields from CHNL_MGR_ to match CHNL_MGR
- *!                     structure defined in _chnl_sm.h.
- *! 16-Jan-1997 gp:     Created from chnlpriv.h
- */
-
 #ifndef CHNLOBJ_
 #define CHNLOBJ_
 
@@ -39,33 +24,32 @@
 #include <dspbridge/wmd.h>
 
 /* Object validateion macros: */
-#define CHNL_IsValidMgr(h) \
-		((h != NULL) && ((h)->dwSignature == CHNL_MGRSIGNATURE))
+#define CHNL_IS_VALID_MGR(h) \
+		((h != NULL) && ((h)->dw_signature == CHNL_MGRSIGNATURE))
 
-#define CHNL_IsValidChnl(h)\
-		((h != NULL) && ((h)->dwSignature == CHNL_SIGNATURE))
+#define CHNL_IS_VALID_CHNL(h)\
+		((h != NULL) && ((h)->dw_signature == CHNL_SIGNATURE))
 
 /*
- *  This struct is the first field in a CHNL_MGR struct, as implemented in
+ *  This struct is the first field in a chnl_mgr struct, as implemented in
  *  a WMD channel class library.  Other, implementation specific fields
  *  follow this structure in memory.
  */
-struct CHNL_MGR_ {
-	/* These must be the first fields in a CHNL_MGR struct: */
-	u32 dwSignature;	/* Used for object validation.   */
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD. */
-} ;
+struct chnl_mgr_ {
+	/* These must be the first fields in a chnl_mgr struct: */
+	u32 dw_signature;	/* Used for object validation. */
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD. */
+};
 
 /*
- *  This struct is the first field in a CHNL_OBJECT struct, as implemented in
+ *  This struct is the first field in a chnl_object struct, as implemented in
  *  a WMD channel class library.  Other, implementation specific fields
  *  follow this structure in memory.
  */
-struct CHNL_OBJECT_ {
-	/* These must be the first fields in a CHNL_OBJECT struct: */
-	u32 dwSignature;	/* Used for object validation.      */
-	struct CHNL_MGR_ *pChnlMgr;	/* Pointer back to channel manager. */
-} ;
-
-#endif				/* CHNLOBJ_ */
+struct chnl_object_ {
+	/* These must be the first fields in a chnl_object struct: */
+	u32 dw_signature;	/* Used for object validation. */
+	struct chnl_mgr_ *chnl_mgr_obj;	/* Pointer back to channel manager. */
+};
 
+#endif /* CHNLOBJ_ */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/cmm.c kernel-power-2.6.28.new/drivers/dsp/bridge/pmgr/cmm.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/cmm.c	2011-10-11 13:51:00.485384115 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/pmgr/cmm.c	2011-10-23 08:22:37.625950000 +0100
@@ -3,6 +3,22 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * The Communication(Shared) Memory Management(CMM) module provides
+ * shared memory management services for DSP/BIOS Bridge data streaming
+ * and messaging.
+ *
+ * Multiple shared memory segments can be registered with CMM.
+ * Each registered SM segment is represented by a SM "allocator" that
+ * describes a block of physically contiguous shared memory used for
+ * future allocations by CMM.
+ *
+ * Memory is coelesced back to the appropriate heap when a buffer is
+ * freed.
+ *
+ * Notes:
+ *   Va: Virtual address.
+ *   Pa: Physical or kernel system address.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,85 +30,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== cmm.c ========
- *  Purpose:
- *      The Communication(Shared) Memory Management(CMM) module provides
- *      shared memory management services for DSP/BIOS Bridge data streaming
- *      and messaging.
- *
- *      Multiple shared memory segments can be registered with CMM.
- *      Each registered SM segment is represented by a SM "allocator" that
- *      describes a block of physically contiguous shared memory used for
- *      future allocations by CMM.
- *
- *      Memory is coelesced back to the appropriate heap when a buffer is
- *      freed.
- *
- *  Public Functions:
- *      CMM_CallocBuf
- *      CMM_Create
- *      CMM_Destroy
- *      CMM_Exit
- *      CMM_FreeBuf
- *      CMM_GetHandle
- *      CMM_GetInfo
- *      CMM_Init
- *      CMM_RegisterGPPSMSeg
- *      CMM_UnRegisterGPPSMSeg
- *
- *      The CMM_Xlator[xxx] routines below are used by Node and Stream
- *      to perform SM address translation to the client process address space.
- *      A "translator" object is created by a node/stream for each SM seg used.
- *
- *  Translator Routines:
- *      CMM_XlatorAllocBuf
- *      CMM_XlatorCreate
- *      CMM_XlatorDelete
- *      CMM_XlatorFreeBuf
- *      CMM_XlatorInfo
- *      CMM_XlatorTranslate
- *
- *  Private Functions:
- *      AddToFreeList
- *      GetAllocator
- *      GetFreeBlock
- *      GetNode
- *      GetSlot
- *      UnRegisterGPPSMSeg
- *
- *  Notes:
- *      Va: Virtual address.
- *      Pa: Physical or kernel system address.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 swa PMGR Code review comments incorporated.
- *! 16-Feb-2002 ag  Code review cleanup.
- *!                 PreOMAP address translation no longner supported.
- *! 30-Jan-2002 ag  Updates to CMM_XlatorTranslate() per TII, ANSI C++
- *!                 warnings.
- *! 27-Jan-2002 ag  Removed unused CMM_[Alloc][Free]Desc() & #ifdef USELOOKUP,
- *!                 & unused VALIDATECMM and VaPaConvert().
- *!                 Removed bFastXlate from CMM_XLATOR. Always fast lookup.
- *! 03-Jan-2002 ag  Clear SM in CMM_AllocBuf(). Renamed to CMM_CallocBuf().
- *! 13-Nov-2001 ag  Now delete pNodeFreeListHead and nodes in CMM_Destroy().
- *! 28-Aug-2001 ag  CMM_GetHandle() returns CMM Mgr hndle given HPROCESSOR.
- *!                 Removed unused CMM_[Un]RegisterDSPSMSeg() &
- *                  CMM_[Un}ReserveVirtSpace fxns. Some cleanup.
- *! 12-Aug-2001 ag  Exposed CMM_UnRegisterGPP[DSP]SMSeg.
- *! 13-Feb-2001 kc  DSP/BIOS Bridge name update.
- *! 21-Dec-2000 rr  GetFreeBlock checks for pAllocator.
- *! 09-Dec-2000 ag  Added GPPPA2DSPPA, DSPPA2GPPPA macros.
- *! 05-Dec-2000 ag  CMM_XlatorDelete() optionally frees SM bufs and descriptors.
- *! 30-Oct-2000 ag  Buf size bug fixed in CMM_AllocBuf() causing leak.
- *!                 Revamped XlatorTranslate() routine.
- *! 10-Oct-2000 ag  Added CMM_Xlator[xxx] functions.
- *! 02-Aug-2000 ag  Created.
- *!
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
@@ -100,14 +37,13 @@
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
 #include <dspbridge/errbase.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/cfg.h>
 #include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/sync.h>
-#include <dspbridge/util.h>
+#include <dspbridge/utildefs.h>
 
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/dev.h>
@@ -119,10 +55,10 @@
 /*  ----------------------------------- Defines, Data Structures, Typedefs */
 /* Object signatures */
 #define CMMSIGNATURE       0x004d4d43	/* "CMM"   (in reverse) */
-#define SMEMSIGNATURE      0x4D454D53	/* "SMEM"  SM space     */
-#define CMMXLATESIGNATURE  0x584d4d43	/* "CMMX"  CMM Xlator   */
+#define SMEMSIGNATURE      0x4D454D53	/* "SMEM"  SM space */
+#define CMMXLATESIGNATURE  0x584d4d43	/* "CMMX"  CMM Xlator */
 
-#define NEXT_PA(pNode)   (pNode->dwPA + pNode->ulSize)
+#define NEXT_PA(pnode)   (pnode->dw_pa + pnode->ul_size)
 
 /* Other bus/platform translations */
 #define DSPPA2GPPPA(base, x, y)  ((x)+(y))
@@ -134,281 +70,270 @@
  *      sma - shared memory allocator.
  *      vma - virtual memory allocator.(not used).
  */
-struct CMM_ALLOCATOR {	/* sma */
-	u32 dwSignature;	/* SMA allocator signature SMEMSIGNATURE */
-	unsigned int dwSmBase;		/* Start of physical SM block */
-	u32 ulSmSize;		/* Size of SM block in bytes */
-	unsigned int dwVmBase;		/* Start of VM block. (Dev driver
-				 * context for 'sma') */
-	u32 dwDSPPhysAddrOffset;	/* DSP PA to GPP PA offset for this
+struct cmm_allocator {		/* sma */
+	u32 dw_signature;	/* SMA allocator signature SMEMSIGNATURE */
+	unsigned int shm_base;	/* Start of physical SM block */
+	u32 ul_sm_size;		/* Size of SM block in bytes */
+	unsigned int dw_vm_base;	/* Start of VM block. (Dev driver
+					 * context for 'sma') */
+	u32 dw_dsp_phys_addr_offset;	/* DSP PA to GPP PA offset for this
 					 * SM space */
-	/* CMM_ADDTO[SUBFROM]DSPPA, _POMAPEMIF2DSPBUS */
-	enum CMM_CNVTTYPE cFactor;
-	unsigned int dwDSPBase;	/* DSP virt base byte address */
-	u32 ulDSPSize;	/* DSP seg size in bytes */
-	struct CMM_OBJECT *hCmmMgr;	/* back ref to parent mgr */
-	struct LST_LIST *pFreeListHead;	/* node list of available memory */
-	struct LST_LIST *pInUseListHead;	/* node list of memory in use */
-} ;
-
-struct CMM_XLATOR {	/* Pa<->Va translator object */
-	u32 dwSignature;	/* "CMMX" */
-	struct CMM_OBJECT *hCmmMgr;  /* CMM object this translator associated */
+	s8 c_factor;		/* DSPPa to GPPPa Conversion Factor */
+	unsigned int dw_dsp_base;	/* DSP virt base byte address */
+	u32 ul_dsp_size;	/* DSP seg size in bytes */
+	struct cmm_object *hcmm_mgr;	/* back ref to parent mgr */
+	/* node list of available memory */
+	struct lst_list *free_list_head;
+	/* node list of memory in use */
+	struct lst_list *in_use_list_head;
+};
+
+struct cmm_xlator {		/* Pa<->Va translator object */
+	u32 dw_signature;	/* "CMMX" */
+	/* CMM object this translator associated */
+	struct cmm_object *hcmm_mgr;
 	/*
 	 *  Client process virtual base address that corresponds to phys SM
-	 *  base address for translator's ulSegId.
+	 *  base address for translator's ul_seg_id.
 	 *  Only 1 segment ID currently supported.
 	 */
-	unsigned int dwVirtBase;	/* virtual base address */
-	u32 ulVirtSize;	/* size of virt space in bytes */
-	u32 ulSegId;		/* Segment Id */
-} ;
+	unsigned int dw_virt_base;	/* virtual base address */
+	u32 ul_virt_size;	/* size of virt space in bytes */
+	u32 ul_seg_id;		/* Segment Id */
+};
 
 /* CMM Mgr */
-struct CMM_OBJECT {
-	u32 dwSignature;	/* Used for object validation */
+struct cmm_object {
+	u32 dw_signature;	/* Used for object validation */
 	/*
 	 * Cmm Lock is used to serialize access mem manager for multi-threads.
 	 */
-	struct SYNC_CSOBJECT *hCmmLock;	/* Lock to access cmm mgr */
-	struct LST_LIST *pNodeFreeListHead;	/* Free list of memory nodes */
-	u32 ulMinBlockSize;	/* Min SM block; default 16 bytes */
-	u32 dwPageSize;	/* Memory Page size (1k/4k) */
+	struct sync_csobject *cmm_lock;	/* Lock to access cmm mgr */
+	struct lst_list *node_free_list_head;	/* Free list of memory nodes */
+	u32 ul_min_block_size;	/* Min SM block; default 16 bytes */
+	u32 dw_page_size;	/* Memory Page size (1k/4k) */
 	/* GPP SM segment ptrs */
-	struct CMM_ALLOCATOR *paGPPSMSegTab[CMM_MAXGPPSEGS];
-} ;
+	struct cmm_allocator *pa_gppsm_seg_tab[CMM_MAXGPPSEGS];
+};
 
 /* Default CMM Mgr attributes */
-static struct CMM_MGRATTRS CMM_DFLTMGRATTRS = {
-	16	/* ulMinBlockSize, min block size(bytes) allocated by cmm mgr */
+static struct cmm_mgrattrs cmm_dfltmgrattrs = {
+	/* ul_min_block_size, min block size(bytes) allocated by cmm mgr */
+	16
 };
 
 /* Default allocation attributes */
-static struct CMM_ATTRS CMM_DFLTALCTATTRS = {
-	1			/* ulSegId, default segment Id for allocator */
+static struct cmm_attrs cmm_dfltalctattrs = {
+	1		/* ul_seg_id, default segment Id for allocator */
 };
 
 /* Address translator default attrs */
-static struct CMM_XLATORATTRS CMM_DFLTXLATORATTRS = {
-	1,	/* ulSegId, does not have to match CMM_DFLTALCTATTRS ulSegId */
-	0,			/* dwDSPBufs */
-	0,			/* dwDSPBufSize */
-	NULL,			/* pVmBase */
-	0,			/* dwVmSize */
+static struct cmm_xlatorattrs cmm_dfltxlatorattrs = {
+	/* ul_seg_id, does not have to match cmm_dfltalctattrs ul_seg_id */
+	1,
+	0,			/* dw_dsp_bufs */
+	0,			/* dw_dsp_buf_size */
+	NULL,			/* vm_base */
+	0,			/* dw_vm_size */
 };
 
 /* SM node representing a block of memory. */
-struct CMM_MNODE {
-	struct LST_ELEM link;		/* must be 1st element */
-	u32 dwPA;		/* Phys addr */
-	u32 dwVA;		/* Virtual address in device process context */
-	u32 ulSize;		/* SM block size in bytes */
-       u32 hClientProc;        /* Process that allocated this mem block */
-} ;
-
+struct cmm_mnode {
+	struct list_head link;	/* must be 1st element */
+	u32 dw_pa;		/* Phys addr */
+	u32 dw_va;		/* Virtual address in device process context */
+	u32 ul_size;		/* SM block size in bytes */
+	u32 client_proc;	/* Process that allocated this mem block */
+};
 
 /*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask CMM_debugMask = { NULL, NULL };	/* GT trace variable */
-#endif
-
-static u32 cRefs;		/* module reference count */
+static u32 refs;		/* module reference count */
 
 /*  ----------------------------------- Function Prototypes */
-static void AddToFreeList(struct CMM_ALLOCATOR *pAllocator,
-			  struct CMM_MNODE *pNode);
-static struct CMM_ALLOCATOR *GetAllocator(struct CMM_OBJECT *pCmmMgr,
-					  u32 ulSegId);
-static struct CMM_MNODE *GetFreeBlock(struct CMM_ALLOCATOR *pAllocator,
-				      u32 uSize);
-static struct CMM_MNODE *GetNode(struct CMM_OBJECT *pCmmMgr, u32 dwPA,
-				 u32 dwVA, u32 ulSize);
+static void add_to_free_list(struct cmm_allocator *allocator,
+			     struct cmm_mnode *pnode);
+static struct cmm_allocator *get_allocator(struct cmm_object *cmm_mgr_obj,
+					   u32 ul_seg_id);
+static struct cmm_mnode *get_free_block(struct cmm_allocator *allocator,
+					u32 usize);
+static struct cmm_mnode *get_node(struct cmm_object *cmm_mgr_obj, u32 dw_pa,
+				  u32 dw_va, u32 ul_size);
 /* get available slot for new allocator */
-static s32 GetSlot(struct CMM_OBJECT *hCmmMgr);
-static void UnRegisterGPPSMSeg(struct CMM_ALLOCATOR *pSMA);
+static s32 get_slot(struct cmm_object *hcmm_mgr);
+static void un_register_gppsm_seg(struct cmm_allocator *psma);
 
 /*
- *  ======== CMM_CallocBuf ========
+ *  ======== cmm_calloc_buf ========
  *  Purpose:
  *      Allocate a SM buffer, zero contents, and return the physical address
- *      and optional driver context virtual address(ppBufVA).
+ *      and optional driver context virtual address(pp_buf_va).
  *
  *      The freelist is sorted in increasing size order. Get the first
  *      block that satifies the request and sort the remaining back on
  *      the freelist; if large enough. The kept block is placed on the
  *      inUseList.
  */
-void *CMM_CallocBuf(struct CMM_OBJECT *hCmmMgr, u32 uSize,
-		    struct CMM_ATTRS *pAttrs, OUT void **ppBufVA)
+void *cmm_calloc_buf(struct cmm_object *hcmm_mgr, u32 usize,
+		     struct cmm_attrs *pattrs, OUT void **pp_buf_va)
 {
-	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
-	void *pBufPA = NULL;
-	struct CMM_MNODE *pNode = NULL;
-	struct CMM_MNODE *pNewNode = NULL;
-	struct CMM_ALLOCATOR *pAllocator = NULL;
-	u32 uDeltaSize;
-	u8 *pByte = NULL;
+	struct cmm_object *cmm_mgr_obj = (struct cmm_object *)hcmm_mgr;
+	void *buf_pa = NULL;
+	struct cmm_mnode *pnode = NULL;
+	struct cmm_mnode *new_node = NULL;
+	struct cmm_allocator *allocator = NULL;
+	u32 delta_size;
+	u8 *pbyte = NULL;
 	s32 cnt;
 
-	if (pAttrs == NULL)
-		pAttrs = &CMM_DFLTALCTATTRS;
+	if (pattrs == NULL)
+		pattrs = &cmm_dfltalctattrs;
 
-	if (ppBufVA != NULL)
-		*ppBufVA = NULL;
+	if (pp_buf_va != NULL)
+		*pp_buf_va = NULL;
 
-	if ((MEM_IsValidHandle(pCmmMgr, CMMSIGNATURE)) && (uSize != 0)) {
-		if (pAttrs->ulSegId > 0) {
-			/* SegId > 0 is SM  */
+	if ((MEM_IS_VALID_HANDLE(cmm_mgr_obj, CMMSIGNATURE)) && (usize != 0)) {
+		if (pattrs->ul_seg_id > 0) {
+			/* SegId > 0 is SM */
 			/* get the allocator object for this segment id */
-			pAllocator = GetAllocator(pCmmMgr, pAttrs->ulSegId);
-			/* keep block size a multiple of ulMinBlockSize */
-			uSize = ((uSize - 1) & ~(pCmmMgr->ulMinBlockSize - 1))
-				+ pCmmMgr->ulMinBlockSize;
-			SYNC_EnterCS(pCmmMgr->hCmmLock);
-			pNode = GetFreeBlock(pAllocator, uSize);
-		}
-		if (pNode) {
-			uDeltaSize = (pNode->ulSize - uSize);
-			if (uDeltaSize >= pCmmMgr->ulMinBlockSize) {
+			allocator =
+			    get_allocator(cmm_mgr_obj, pattrs->ul_seg_id);
+			/* keep block size a multiple of ul_min_block_size */
+			usize =
+			    ((usize - 1) & ~(cmm_mgr_obj->ul_min_block_size -
+					     1))
+			    + cmm_mgr_obj->ul_min_block_size;
+			sync_enter_cs(cmm_mgr_obj->cmm_lock);
+			pnode = get_free_block(allocator, usize);
+		}
+		if (pnode) {
+			delta_size = (pnode->ul_size - usize);
+			if (delta_size >= cmm_mgr_obj->ul_min_block_size) {
 				/* create a new block with the leftovers and
 				 * add to freelist */
-				pNewNode = GetNode(pCmmMgr, pNode->dwPA + uSize,
-					   pNode->dwVA + uSize,
-					   (u32)uDeltaSize);
+				new_node =
+				    get_node(cmm_mgr_obj, pnode->dw_pa + usize,
+					     pnode->dw_va + usize,
+					     (u32) delta_size);
 				/* leftovers go free */
-				AddToFreeList(pAllocator, pNewNode);
+				add_to_free_list(allocator, new_node);
 				/* adjust our node's size */
-				pNode->ulSize = uSize;
+				pnode->ul_size = usize;
 			}
 			/* Tag node with client process requesting allocation
 			 * We'll need to free up a process's alloc'd SM if the
 			 * client process goes away.
 			 */
 			/* Return TGID instead of process handle */
-			pNode->hClientProc = current->tgid;
+			pnode->client_proc = current->tgid;
 
 			/* put our node on InUse list */
-			LST_PutTail(pAllocator->pInUseListHead,
-				   (struct LST_ELEM *)pNode);
-			pBufPA = (void *)pNode->dwPA;	/* physical address */
+			lst_put_tail(allocator->in_use_list_head,
+				     (struct list_head *)pnode);
+			buf_pa = (void *)pnode->dw_pa;	/* physical address */
 			/* clear mem */
-			pByte = (u8 *)pNode->dwVA;
-			for (cnt = 0; cnt < (s32) uSize; cnt++, pByte++)
-				*pByte = 0;
+			pbyte = (u8 *) pnode->dw_va;
+			for (cnt = 0; cnt < (s32) usize; cnt++, pbyte++)
+				*pbyte = 0;
 
-			if (ppBufVA != NULL) {
+			if (pp_buf_va != NULL) {
 				/* Virtual address */
-				*ppBufVA = (void *)pNode->dwVA;
+				*pp_buf_va = (void *)pnode->dw_va;
 			}
 		}
-		GT_3trace(CMM_debugMask, GT_3CLASS,
-			  "CMM_CallocBuf dwPA %x, dwVA %x uSize"
-			  "%x\n", pNode->dwPA, pNode->dwVA, uSize);
-		SYNC_LeaveCS(pCmmMgr->hCmmLock);
+		sync_leave_cs(cmm_mgr_obj->cmm_lock);
 	}
-	return pBufPA;
+	return buf_pa;
 }
 
 /*
- *  ======== CMM_Create ========
+ *  ======== cmm_create ========
  *  Purpose:
  *      Create a communication memory manager object.
  */
-DSP_STATUS CMM_Create(OUT struct CMM_OBJECT **phCmmMgr,
-		      struct DEV_OBJECT *hDevObject,
-		      IN CONST struct CMM_MGRATTRS *pMgrAttrs)
-{
-	struct CMM_OBJECT *pCmmObject = NULL;
-	DSP_STATUS status = DSP_SOK;
-	struct UTIL_SYSINFO sysInfo;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(phCmmMgr != NULL);
-
-	GT_3trace(CMM_debugMask, GT_ENTER,
-		  "CMM_Create: phCmmMgr: 0x%x\thDevObject: "
-		  "0x%x\tpMgrAttrs: 0x%x\n", phCmmMgr, hDevObject, pMgrAttrs);
-	*phCmmMgr = NULL;
+dsp_status cmm_create(OUT struct cmm_object **ph_cmm_mgr,
+		      struct dev_object *hdev_obj,
+		      IN CONST struct cmm_mgrattrs *pMgrAttrs)
+{
+	struct cmm_object *cmm_obj = NULL;
+	dsp_status status = DSP_SOK;
+	struct util_sysinfo sys_info;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(ph_cmm_mgr != NULL);
+
+	*ph_cmm_mgr = NULL;
 	/* create, zero, and tag a cmm mgr object */
-	MEM_AllocObject(pCmmObject, struct CMM_OBJECT, CMMSIGNATURE);
-	if (pCmmObject != NULL) {
+	MEM_ALLOC_OBJECT(cmm_obj, struct cmm_object, CMMSIGNATURE);
+	if (cmm_obj != NULL) {
 		if (pMgrAttrs == NULL)
-			pMgrAttrs = &CMM_DFLTMGRATTRS;	/* set defaults */
+			pMgrAttrs = &cmm_dfltmgrattrs;	/* set defaults */
 
 		/* 4 bytes minimum */
-		DBC_Assert(pMgrAttrs->ulMinBlockSize >= 4);
+		DBC_ASSERT(pMgrAttrs->ul_min_block_size >= 4);
 		/* save away smallest block allocation for this cmm mgr */
-		pCmmObject->ulMinBlockSize = pMgrAttrs->ulMinBlockSize;
+		cmm_obj->ul_min_block_size = pMgrAttrs->ul_min_block_size;
 		/* save away the systems memory page size */
-		sysInfo.dwPageSize = PAGE_SIZE;
-		sysInfo.dwAllocationGranularity = PAGE_SIZE;
-		sysInfo.dwNumberOfProcessors = 1;
+		sys_info.dw_page_size = PAGE_SIZE;
+		sys_info.dw_allocation_granularity = PAGE_SIZE;
+		sys_info.dw_number_of_processors = 1;
 		if (DSP_SUCCEEDED(status)) {
-			GT_1trace(CMM_debugMask, GT_5CLASS,
-				  "CMM_Create: Got system page size"
-				  "= 0x%x\t\n", sysInfo.dwPageSize);
-			pCmmObject->dwPageSize = sysInfo.dwPageSize;
+			cmm_obj->dw_page_size = sys_info.dw_page_size;
 		} else {
-			GT_0trace(CMM_debugMask, GT_7CLASS,
-				  "CMM_Create: failed to get system"
-				  "page size\n");
-			pCmmObject->dwPageSize = 0;
+			cmm_obj->dw_page_size = 0;
 			status = DSP_EFAIL;
 		}
 		/* Note: DSP SM seg table(aDSPSMSegTab[]) zero'd by
-		 * MEM_AllocObject */
+		 * MEM_ALLOC_OBJECT */
 		if (DSP_SUCCEEDED(status)) {
 			/* create node free list */
-			pCmmObject->pNodeFreeListHead = LST_Create();
-			if (pCmmObject->pNodeFreeListHead == NULL) {
-				GT_0trace(CMM_debugMask, GT_7CLASS,
-					  "CMM_Create: LST_Create() "
-					  "failed \n");
+			cmm_obj->node_free_list_head =
+					mem_calloc(sizeof(struct lst_list),
+						   MEM_NONPAGED);
+			if (cmm_obj->node_free_list_head == NULL)
 				status = DSP_EMEMORY;
-			}
+			else
+				INIT_LIST_HEAD(&cmm_obj->
+					       node_free_list_head->head);
 		}
 		if (DSP_SUCCEEDED(status))
-			status = SYNC_InitializeCS(&pCmmObject->hCmmLock);
+			status = sync_initialize_cs(&cmm_obj->cmm_lock);
 
 		if (DSP_SUCCEEDED(status))
-			*phCmmMgr = pCmmObject;
+			*ph_cmm_mgr = cmm_obj;
 		else
-			CMM_Destroy(pCmmObject, true);
+			cmm_destroy(cmm_obj, true);
 
 	} else {
-		GT_0trace(CMM_debugMask, GT_6CLASS,
-			  "CMM_Create: Object Allocation "
-			  "Failure(CMM Object)\n");
 		status = DSP_EMEMORY;
 	}
 	return status;
 }
 
 /*
- *  ======== CMM_Destroy ========
+ *  ======== cmm_destroy ========
  *  Purpose:
  *      Release the communication memory manager resources.
  */
-DSP_STATUS CMM_Destroy(struct CMM_OBJECT *hCmmMgr, bool bForce)
+dsp_status cmm_destroy(struct cmm_object *hcmm_mgr, bool bForce)
 {
-	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
-	struct CMM_INFO tempInfo;
-	DSP_STATUS status = DSP_SOK;
-	s32 nSlot;
-	struct CMM_MNODE *pNode;
+	struct cmm_object *cmm_mgr_obj = (struct cmm_object *)hcmm_mgr;
+	struct cmm_info temp_info;
+	dsp_status status = DSP_SOK;
+	s32 slot_seg;
+	struct cmm_mnode *pnode;
 
-	DBC_Require(cRefs > 0);
-	if (!MEM_IsValidHandle(hCmmMgr, CMMSIGNATURE)) {
+	DBC_REQUIRE(refs > 0);
+	if (!MEM_IS_VALID_HANDLE(hcmm_mgr, CMMSIGNATURE)) {
 		status = DSP_EHANDLE;
 		return status;
 	}
-	SYNC_EnterCS(pCmmMgr->hCmmLock);
+	sync_enter_cs(cmm_mgr_obj->cmm_lock);
 	/* If not force then fail if outstanding allocations exist */
 	if (!bForce) {
 		/* Check for outstanding memory allocations */
-		status = CMM_GetInfo(hCmmMgr, &tempInfo);
+		status = cmm_get_info(hcmm_mgr, &temp_info);
 		if (DSP_SUCCEEDED(status)) {
-			if (tempInfo.ulTotalInUseCnt > 0) {
+			if (temp_info.ul_total_in_use_cnt > 0) {
 				/* outstanding allocations */
 				status = DSP_EFAIL;
 			}
@@ -416,317 +341,302 @@
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* UnRegister SM allocator */
-		for (nSlot = 0; nSlot < CMM_MAXGPPSEGS; nSlot++) {
-			if (pCmmMgr->paGPPSMSegTab[nSlot] != NULL) {
-				UnRegisterGPPSMSeg(pCmmMgr->
-						   paGPPSMSegTab[nSlot]);
+		for (slot_seg = 0; slot_seg < CMM_MAXGPPSEGS; slot_seg++) {
+			if (cmm_mgr_obj->pa_gppsm_seg_tab[slot_seg] != NULL) {
+				un_register_gppsm_seg
+				    (cmm_mgr_obj->pa_gppsm_seg_tab[slot_seg]);
 				/* Set slot to NULL for future reuse */
-				pCmmMgr->paGPPSMSegTab[nSlot] = NULL;
+				cmm_mgr_obj->pa_gppsm_seg_tab[slot_seg] = NULL;
 			}
 		}
 	}
-	if (pCmmMgr->pNodeFreeListHead != NULL) {
+	if (cmm_mgr_obj->node_free_list_head != NULL) {
 		/* Free the free nodes */
-		while (!LST_IsEmpty(pCmmMgr->pNodeFreeListHead)) {
-			/* (struct LST_ELEM*) pNode =
-			 * LST_GetHead(pCmmMgr->pNodeFreeListHead);*/
-			pNode = (struct CMM_MNODE *)LST_GetHead(pCmmMgr->
-				 pNodeFreeListHead);
-			MEM_Free(pNode);
+		while (!LST_IS_EMPTY(cmm_mgr_obj->node_free_list_head)) {
+			pnode = (struct cmm_mnode *)
+			    lst_get_head(cmm_mgr_obj->node_free_list_head);
+			kfree(pnode);
 		}
 		/* delete NodeFreeList list */
-		LST_Delete(pCmmMgr->pNodeFreeListHead);
+		kfree(cmm_mgr_obj->node_free_list_head);
 	}
-	SYNC_LeaveCS(pCmmMgr->hCmmLock);
+	sync_leave_cs(cmm_mgr_obj->cmm_lock);
 	if (DSP_SUCCEEDED(status)) {
 		/* delete CS & cmm mgr object */
-		SYNC_DeleteCS(pCmmMgr->hCmmLock);
-		MEM_FreeObject(pCmmMgr);
+		sync_delete_cs(cmm_mgr_obj->cmm_lock);
+		MEM_FREE_OBJECT(cmm_mgr_obj);
 	}
 	return status;
 }
 
 /*
- *  ======== CMM_Exit ========
+ *  ======== cmm_exit ========
  *  Purpose:
  *      Discontinue usage of module; free resources when reference count
  *      reaches 0.
  */
-void CMM_Exit(void)
+void cmm_exit(void)
 {
-	DBC_Require(cRefs > 0);
-
-	cRefs--;
+	DBC_REQUIRE(refs > 0);
 
-	GT_1trace(CMM_debugMask, GT_ENTER,
-		  "exiting CMM_Exit,ref count:0x%x\n", cRefs);
+	refs--;
 }
 
 /*
- *  ======== CMM_FreeBuf ========
+ *  ======== cmm_free_buf ========
  *  Purpose:
  *      Free the given buffer.
  */
-DSP_STATUS CMM_FreeBuf(struct CMM_OBJECT *hCmmMgr, void *pBufPA, u32 ulSegId)
+dsp_status cmm_free_buf(struct cmm_object *hcmm_mgr, void *buf_pa,
+			u32 ul_seg_id)
 {
-	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
-	DSP_STATUS status = DSP_EPOINTER;
-	struct CMM_MNODE *pCurNode = NULL;
-	struct CMM_ALLOCATOR *pAllocator = NULL;
-	struct CMM_ATTRS *pAttrs;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pBufPA != NULL);
-	GT_1trace(CMM_debugMask, GT_ENTER, "CMM_FreeBuf pBufPA %x\n", pBufPA);
-	if (ulSegId == 0) {
-		pAttrs = &CMM_DFLTALCTATTRS;
-		ulSegId = pAttrs->ulSegId;
+	struct cmm_object *cmm_mgr_obj = (struct cmm_object *)hcmm_mgr;
+	dsp_status status = DSP_EPOINTER;
+	struct cmm_mnode *mnode_obj = NULL;
+	struct cmm_allocator *allocator = NULL;
+	struct cmm_attrs *pattrs;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(buf_pa != NULL);
+
+	if (ul_seg_id == 0) {
+		pattrs = &cmm_dfltalctattrs;
+		ul_seg_id = pattrs->ul_seg_id;
 	}
-	if (!(MEM_IsValidHandle(hCmmMgr, CMMSIGNATURE)) || !(ulSegId > 0)) {
+	if (!(MEM_IS_VALID_HANDLE(hcmm_mgr, CMMSIGNATURE)) ||
+	    !(ul_seg_id > 0)) {
 		status = DSP_EHANDLE;
 		return status;
 	}
 	/* get the allocator for this segment id */
-	pAllocator = GetAllocator(pCmmMgr, ulSegId);
-	if (pAllocator != NULL) {
-		SYNC_EnterCS(pCmmMgr->hCmmLock);
-		pCurNode = (struct CMM_MNODE *)LST_First(pAllocator->
-			    pInUseListHead);
-		while (pCurNode) {
-			if ((u32)pBufPA == pCurNode->dwPA) {
+	allocator = get_allocator(cmm_mgr_obj, ul_seg_id);
+	if (allocator != NULL) {
+		sync_enter_cs(cmm_mgr_obj->cmm_lock);
+		mnode_obj =
+		    (struct cmm_mnode *)lst_first(allocator->in_use_list_head);
+		while (mnode_obj) {
+			if ((u32) buf_pa == mnode_obj->dw_pa) {
 				/* Found it */
-				LST_RemoveElem(pAllocator->pInUseListHead,
-					      (struct LST_ELEM *)pCurNode);
+				lst_remove_elem(allocator->in_use_list_head,
+						(struct list_head *)mnode_obj);
 				/* back to freelist */
-				AddToFreeList(pAllocator, pCurNode);
+				add_to_free_list(allocator, mnode_obj);
 				status = DSP_SOK;	/* all right! */
 				break;
 			}
 			/* next node. */
-			pCurNode = (struct CMM_MNODE *)LST_Next(pAllocator->
-				   pInUseListHead, (struct LST_ELEM *)pCurNode);
+			mnode_obj = (struct cmm_mnode *)
+			    lst_next(allocator->in_use_list_head,
+				     (struct list_head *)mnode_obj);
 		}
-		SYNC_LeaveCS(pCmmMgr->hCmmLock);
+		sync_leave_cs(cmm_mgr_obj->cmm_lock);
 	}
 	return status;
 }
 
 /*
- *  ======== CMM_GetHandle ========
+ *  ======== cmm_get_handle ========
  *  Purpose:
  *      Return the communication memory manager object for this device.
  *      This is typically called from the client process.
  */
-DSP_STATUS CMM_GetHandle(DSP_HPROCESSOR hProcessor,
-			OUT struct CMM_OBJECT **phCmmMgr)
+dsp_status cmm_get_handle(void *hprocessor, OUT struct cmm_object ** ph_cmm_mgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phCmmMgr != NULL);
-	if (hProcessor != NULL)
-		status = PROC_GetDevObject(hProcessor, &hDevObject);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(ph_cmm_mgr != NULL);
+	if (hprocessor != NULL)
+		status = proc_get_dev_object(hprocessor, &hdev_obj);
 	else
-		hDevObject = DEV_GetFirst();	/* default */
+		hdev_obj = dev_get_first();	/* default */
 
 	if (DSP_SUCCEEDED(status))
-		status = DEV_GetCmmMgr(hDevObject, phCmmMgr);
+		status = dev_get_cmm_mgr(hdev_obj, ph_cmm_mgr);
 
 	return status;
 }
 
 /*
- *  ======== CMM_GetInfo ========
+ *  ======== cmm_get_info ========
  *  Purpose:
  *      Return the current memory utilization information.
  */
-DSP_STATUS CMM_GetInfo(struct CMM_OBJECT *hCmmMgr,
-		       OUT struct CMM_INFO *pCmmInfo)
+dsp_status cmm_get_info(struct cmm_object *hcmm_mgr,
+			OUT struct cmm_info *cmm_info_obj)
 {
-	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
-	u32 ulSeg;
-	DSP_STATUS status = DSP_SOK;
-	struct CMM_ALLOCATOR *pAltr;
-	struct CMM_MNODE *pCurNode = NULL;
+	struct cmm_object *cmm_mgr_obj = (struct cmm_object *)hcmm_mgr;
+	u32 ul_seg;
+	dsp_status status = DSP_SOK;
+	struct cmm_allocator *altr;
+	struct cmm_mnode *mnode_obj = NULL;
 
-	DBC_Require(pCmmInfo != NULL);
+	DBC_REQUIRE(cmm_info_obj != NULL);
 
-	if (!MEM_IsValidHandle(hCmmMgr, CMMSIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hcmm_mgr, CMMSIGNATURE)) {
 		status = DSP_EHANDLE;
 		return status;
 	}
-	SYNC_EnterCS(pCmmMgr->hCmmLock);
-	pCmmInfo->ulNumGPPSMSegs = 0;	/* # of SM segments */
-	pCmmInfo->ulTotalInUseCnt = 0;	/* Total # of outstanding alloc */
-	pCmmInfo->ulMinBlockSize = pCmmMgr->ulMinBlockSize; /* min block size */
+	sync_enter_cs(cmm_mgr_obj->cmm_lock);
+	cmm_info_obj->ul_num_gppsm_segs = 0;	/* # of SM segments */
+	/* Total # of outstanding alloc */
+	cmm_info_obj->ul_total_in_use_cnt = 0;
+	/* min block size */
+	cmm_info_obj->ul_min_block_size = cmm_mgr_obj->ul_min_block_size;
 	/* check SM memory segments */
-	for (ulSeg = 1; ulSeg <= CMM_MAXGPPSEGS; ulSeg++) {
+	for (ul_seg = 1; ul_seg <= CMM_MAXGPPSEGS; ul_seg++) {
 		/* get the allocator object for this segment id */
-		pAltr = GetAllocator(pCmmMgr, ulSeg);
-		if (pAltr != NULL) {
-			pCmmInfo->ulNumGPPSMSegs++;
-			pCmmInfo->segInfo[ulSeg - 1].dwSegBasePa =
-				pAltr->dwSmBase - pAltr->ulDSPSize;
-			pCmmInfo->segInfo[ulSeg - 1].ulTotalSegSize =
-				pAltr->ulDSPSize + pAltr->ulSmSize;
-			pCmmInfo->segInfo[ulSeg - 1].dwGPPBasePA =
-				pAltr->dwSmBase;
-			pCmmInfo->segInfo[ulSeg - 1].ulGPPSize =
-				pAltr->ulSmSize;
-			pCmmInfo->segInfo[ulSeg - 1].dwDSPBaseVA =
-				pAltr->dwDSPBase;
-			pCmmInfo->segInfo[ulSeg - 1].ulDSPSize =
-				pAltr->ulDSPSize;
-			pCmmInfo->segInfo[ulSeg - 1].dwSegBaseVa =
-				pAltr->dwVmBase - pAltr->ulDSPSize;
-			pCmmInfo->segInfo[ulSeg - 1].ulInUseCnt = 0;
-			pCurNode = (struct CMM_MNODE *)LST_First(pAltr->
-				pInUseListHead);
+		altr = get_allocator(cmm_mgr_obj, ul_seg);
+		if (altr != NULL) {
+			cmm_info_obj->ul_num_gppsm_segs++;
+			cmm_info_obj->seg_info[ul_seg - 1].dw_seg_base_pa =
+			    altr->shm_base - altr->ul_dsp_size;
+			cmm_info_obj->seg_info[ul_seg - 1].ul_total_seg_size =
+			    altr->ul_dsp_size + altr->ul_sm_size;
+			cmm_info_obj->seg_info[ul_seg - 1].dw_gpp_base_pa =
+			    altr->shm_base;
+			cmm_info_obj->seg_info[ul_seg - 1].ul_gpp_size =
+			    altr->ul_sm_size;
+			cmm_info_obj->seg_info[ul_seg - 1].dw_dsp_base_va =
+			    altr->dw_dsp_base;
+			cmm_info_obj->seg_info[ul_seg - 1].ul_dsp_size =
+			    altr->ul_dsp_size;
+			cmm_info_obj->seg_info[ul_seg - 1].dw_seg_base_va =
+			    altr->dw_vm_base - altr->ul_dsp_size;
+			cmm_info_obj->seg_info[ul_seg - 1].ul_in_use_cnt = 0;
+			mnode_obj = (struct cmm_mnode *)
+			    lst_first(altr->in_use_list_head);
 			/* Count inUse blocks */
-			while (pCurNode) {
-				pCmmInfo->ulTotalInUseCnt++;
-				pCmmInfo->segInfo[ulSeg - 1].ulInUseCnt++;
+			while (mnode_obj) {
+				cmm_info_obj->ul_total_in_use_cnt++;
+				cmm_info_obj->seg_info[ul_seg -
+						       1].ul_in_use_cnt++;
 				/* next node. */
-				pCurNode = (struct CMM_MNODE *)LST_Next(pAltr->
-					pInUseListHead,
-					(struct LST_ELEM *)pCurNode);
+				mnode_obj = (struct cmm_mnode *)
+				    lst_next(altr->in_use_list_head,
+					     (struct list_head *)mnode_obj);
 			}
 		}
-	}		/* end for */
-	SYNC_LeaveCS(pCmmMgr->hCmmLock);
+	}			/* end for */
+	sync_leave_cs(cmm_mgr_obj->cmm_lock);
 	return status;
 }
 
 /*
- *  ======== CMM_Init ========
+ *  ======== cmm_init ========
  *  Purpose:
  *      Initializes private state of CMM module.
  */
-bool CMM_Init(void)
+bool cmm_init(void)
 {
-	bool fRetval = true;
-
-	DBC_Require(cRefs >= 0);
-	if (cRefs == 0) {
-		/* Set the Trace mask */
-		/* "CM" for Comm Memory manager */
-		GT_create(&CMM_debugMask, "CM");
-	}
-	if (fRetval)
-		cRefs++;
+	bool ret = true;
 
-	GT_1trace(CMM_debugMask, GT_ENTER,
-		  "Entered CMM_Init,ref count:0x%x\n", cRefs);
+	DBC_REQUIRE(refs >= 0);
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	return fRetval;
+	return ret;
 }
 
 /*
- *  ======== CMM_RegisterGPPSMSeg ========
+ *  ======== cmm_register_gppsm_seg ========
  *  Purpose:
  *      Register a block of SM with the CMM to be used for later GPP SM
  *      allocations.
  */
-DSP_STATUS CMM_RegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr, u32 dwGPPBasePA,
-				u32 ulSize, u32 dwDSPAddrOffset,
-				enum CMM_CNVTTYPE cFactor, u32 dwDSPBase,
-				u32 ulDSPSize, u32 *pulSegId,
-				u32 dwGPPBaseVA)
-{
-	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
-	struct CMM_ALLOCATOR *pSMA = NULL;
-	DSP_STATUS status = DSP_SOK;
-	struct CMM_MNODE *pNewNode;
-	s32 nSlot;
-
-	DBC_Require(ulSize > 0);
-	DBC_Require(pulSegId != NULL);
-	DBC_Require(dwGPPBasePA != 0);
-	DBC_Require(dwGPPBaseVA != 0);
-	DBC_Require((cFactor <= CMM_ADDTODSPPA) &&
-		   (cFactor >= CMM_SUBFROMDSPPA));
-	GT_6trace(CMM_debugMask, GT_ENTER,
-		  "CMM_RegisterGPPSMSeg dwGPPBasePA %x "
-		  "ulSize %x dwDSPAddrOffset %x dwDSPBase %x ulDSPSize %x "
-		  "dwGPPBaseVA %x\n", dwGPPBasePA, ulSize, dwDSPAddrOffset,
-		  dwDSPBase, ulDSPSize, dwGPPBaseVA);
-	if (!MEM_IsValidHandle(hCmmMgr, CMMSIGNATURE)) {
+dsp_status cmm_register_gppsm_seg(struct cmm_object *hcmm_mgr,
+				  u32 dw_gpp_base_pa, u32 ul_size,
+				  u32 dwDSPAddrOffset, s8 c_factor,
+				  u32 dw_dsp_base, u32 ul_dsp_size,
+				  u32 *pulSegId, u32 dw_gpp_base_va)
+{
+	struct cmm_object *cmm_mgr_obj = (struct cmm_object *)hcmm_mgr;
+	struct cmm_allocator *psma = NULL;
+	dsp_status status = DSP_SOK;
+	struct cmm_mnode *new_node;
+	s32 slot_seg;
+
+	DBC_REQUIRE(ul_size > 0);
+	DBC_REQUIRE(pulSegId != NULL);
+	DBC_REQUIRE(dw_gpp_base_pa != 0);
+	DBC_REQUIRE(dw_gpp_base_va != 0);
+	DBC_REQUIRE((c_factor <= CMM_ADDTODSPPA) &&
+		    (c_factor >= CMM_SUBFROMDSPPA));
+	dev_dbg(bridge, "%s: dw_gpp_base_pa %x ul_size %x dwDSPAddrOffset %x "
+		"dw_dsp_base %x ul_dsp_size %x dw_gpp_base_va %x\n", __func__,
+		dw_gpp_base_pa, ul_size, dwDSPAddrOffset, dw_dsp_base,
+		ul_dsp_size, dw_gpp_base_va);
+	if (!MEM_IS_VALID_HANDLE(hcmm_mgr, CMMSIGNATURE)) {
 		status = DSP_EHANDLE;
 		return status;
 	}
 	/* make sure we have room for another allocator */
-	SYNC_EnterCS(pCmmMgr->hCmmLock);
-	nSlot = GetSlot(pCmmMgr);
-	if (nSlot < 0) {
+	sync_enter_cs(cmm_mgr_obj->cmm_lock);
+	slot_seg = get_slot(cmm_mgr_obj);
+	if (slot_seg < 0) {
 		/* get a slot number */
 		status = DSP_EFAIL;
 		goto func_end;
 	}
-	/* Check if input ulSize is big enough to alloc at least one block */
+	/* Check if input ul_size is big enough to alloc at least one block */
 	if (DSP_SUCCEEDED(status)) {
-		if (ulSize < pCmmMgr->ulMinBlockSize) {
-			GT_0trace(CMM_debugMask, GT_7CLASS,
-				  "CMM_RegisterGPPSMSeg: "
-				  "ulSize too small\n");
+		if (ul_size < cmm_mgr_obj->ul_min_block_size) {
 			status = DSP_EINVALIDARG;
 			goto func_end;
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* create, zero, and tag an SM allocator object */
-		MEM_AllocObject(pSMA, struct CMM_ALLOCATOR, SMEMSIGNATURE);
+		MEM_ALLOC_OBJECT(psma, struct cmm_allocator, SMEMSIGNATURE);
 	}
-	if (pSMA != NULL) {
-		pSMA->hCmmMgr = hCmmMgr;	/* ref to parent */
-		pSMA->dwSmBase = dwGPPBasePA;	/* SM Base phys */
-		pSMA->ulSmSize = ulSize;	/* SM segment size in bytes */
-		pSMA->dwVmBase = dwGPPBaseVA;
-		pSMA->dwDSPPhysAddrOffset = dwDSPAddrOffset;
-		pSMA->cFactor = cFactor;
-		pSMA->dwDSPBase = dwDSPBase;
-		pSMA->ulDSPSize = ulDSPSize;
-		if (pSMA->dwVmBase == 0) {
-			GT_0trace(CMM_debugMask, GT_7CLASS,
-				  "CMM_RegisterGPPSMSeg: Error"
-				  "MEM_LinearAddress()\n");
+	if (psma != NULL) {
+		psma->hcmm_mgr = hcmm_mgr;	/* ref to parent */
+		psma->shm_base = dw_gpp_base_pa;	/* SM Base phys */
+		psma->ul_sm_size = ul_size;	/* SM segment size in bytes */
+		psma->dw_vm_base = dw_gpp_base_va;
+		psma->dw_dsp_phys_addr_offset = dwDSPAddrOffset;
+		psma->c_factor = c_factor;
+		psma->dw_dsp_base = dw_dsp_base;
+		psma->ul_dsp_size = ul_dsp_size;
+		if (psma->dw_vm_base == 0) {
 			status = DSP_EFAIL;
 			goto func_end;
 		}
 		if (DSP_SUCCEEDED(status)) {
 			/* return the actual segment identifier */
-			*pulSegId = (u32) nSlot + 1;
+			*pulSegId = (u32) slot_seg + 1;
 			/* create memory free list */
-			pSMA->pFreeListHead = LST_Create();
-			if (pSMA->pFreeListHead == NULL) {
-				GT_0trace(CMM_debugMask, GT_7CLASS,
-					  "CMM_RegisterGPPSMSeg: "
-					  "Out Of Memory \n");
+			psma->free_list_head = mem_calloc(sizeof(struct
+								 lst_list),
+							  MEM_NONPAGED);
+			if (psma->free_list_head == NULL) {
 				status = DSP_EMEMORY;
 				goto func_end;
 			}
+			INIT_LIST_HEAD(&psma->free_list_head->head);
 		}
 		if (DSP_SUCCEEDED(status)) {
 			/* create memory in-use list */
-			pSMA->pInUseListHead = LST_Create();
-			if (pSMA->pInUseListHead == NULL) {
-				GT_0trace(CMM_debugMask, GT_7CLASS,
-					  "CMM_RegisterGPPSMSeg: "
-					  "LST_Create failed\n");
+			psma->in_use_list_head = mem_calloc(sizeof(struct
+								   lst_list),
+							    MEM_NONPAGED);
+			if (psma->in_use_list_head == NULL) {
 				status = DSP_EMEMORY;
 				goto func_end;
 			}
+			INIT_LIST_HEAD(&psma->in_use_list_head->head);
 		}
 		if (DSP_SUCCEEDED(status)) {
 			/* Get a mem node for this hunk-o-memory */
-			pNewNode = GetNode(pCmmMgr, dwGPPBasePA,
-					   pSMA->dwVmBase, ulSize);
+			new_node = get_node(cmm_mgr_obj, dw_gpp_base_pa,
+					    psma->dw_vm_base, ul_size);
 			/* Place node on the SM allocator's free list */
-			if (pNewNode) {
-				LST_PutTail(pSMA->pFreeListHead,
-					   (struct LST_ELEM *)pNewNode);
+			if (new_node) {
+				lst_put_tail(psma->free_list_head,
+					     (struct list_head *)new_node);
 			} else {
 				status = DSP_EMEMORY;
 				goto func_end;
@@ -734,65 +644,61 @@
 		}
 		if (DSP_FAILED(status)) {
 			/* Cleanup allocator */
-			UnRegisterGPPSMSeg(pSMA);
+			un_register_gppsm_seg(psma);
 		}
 	} else {
-		GT_0trace(CMM_debugMask, GT_6CLASS,
-			  "CMM_RegisterGPPSMSeg: SMA Object "
-			  "Allocation Failure\n");
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
-	 /* make entry */
+	/* make entry */
 	if (DSP_SUCCEEDED(status))
-		pCmmMgr->paGPPSMSegTab[nSlot] = pSMA;
+		cmm_mgr_obj->pa_gppsm_seg_tab[slot_seg] = psma;
 
 func_end:
-	SYNC_LeaveCS(pCmmMgr->hCmmLock);
+	sync_leave_cs(cmm_mgr_obj->cmm_lock);
 	return status;
 }
 
 /*
- *  ======== CMM_UnRegisterGPPSMSeg ========
+ *  ======== cmm_un_register_gppsm_seg ========
  *  Purpose:
  *      UnRegister GPP SM segments with the CMM.
  */
-DSP_STATUS CMM_UnRegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr, u32 ulSegId)
+dsp_status cmm_un_register_gppsm_seg(struct cmm_object *hcmm_mgr,
+				     u32 ul_seg_id)
 {
-	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
-	DSP_STATUS status = DSP_SOK;
-	struct CMM_ALLOCATOR *pSMA;
-	u32 ulId = ulSegId;
-
-	DBC_Require(ulSegId > 0);
-	if (MEM_IsValidHandle(hCmmMgr, CMMSIGNATURE)) {
-		if (ulSegId == CMM_ALLSEGMENTS)
-			ulId = 1;
-
-		if ((ulId > 0) && (ulId <= CMM_MAXGPPSEGS)) {
-			while (ulId <= CMM_MAXGPPSEGS) {
-				SYNC_EnterCS(pCmmMgr->hCmmLock);
-				/* slot = segId-1 */
-				pSMA = pCmmMgr->paGPPSMSegTab[ulId - 1];
-				if (pSMA != NULL) {
-					UnRegisterGPPSMSeg(pSMA);
+	struct cmm_object *cmm_mgr_obj = (struct cmm_object *)hcmm_mgr;
+	dsp_status status = DSP_SOK;
+	struct cmm_allocator *psma;
+	u32 ul_id = ul_seg_id;
+
+	DBC_REQUIRE(ul_seg_id > 0);
+	if (MEM_IS_VALID_HANDLE(hcmm_mgr, CMMSIGNATURE)) {
+		if (ul_seg_id == CMM_ALLSEGMENTS)
+			ul_id = 1;
+
+		if ((ul_id > 0) && (ul_id <= CMM_MAXGPPSEGS)) {
+			while (ul_id <= CMM_MAXGPPSEGS) {
+				sync_enter_cs(cmm_mgr_obj->cmm_lock);
+				/* slot = seg_id-1 */
+				psma = cmm_mgr_obj->pa_gppsm_seg_tab[ul_id - 1];
+				if (psma != NULL) {
+					un_register_gppsm_seg(psma);
 					/* Set alctr ptr to NULL for future
 					 * reuse */
-					pCmmMgr->paGPPSMSegTab[ulId - 1] = NULL;
-				} else if (ulSegId != CMM_ALLSEGMENTS) {
+					cmm_mgr_obj->pa_gppsm_seg_tab[ul_id -
+								      1] = NULL;
+				} else if (ul_seg_id != CMM_ALLSEGMENTS) {
 					status = DSP_EFAIL;
 				}
-				SYNC_LeaveCS(pCmmMgr->hCmmLock);
-				if (ulSegId != CMM_ALLSEGMENTS)
+				sync_leave_cs(cmm_mgr_obj->cmm_lock);
+				if (ul_seg_id != CMM_ALLSEGMENTS)
 					break;
 
-				ulId++;
+				ul_id++;
 			}	/* end while */
 		} else {
 			status = DSP_EINVALIDARG;
-			GT_0trace(CMM_debugMask, GT_7CLASS,
-				  "CMM_UnRegisterGPPSMSeg: Bad "
-				  "segment Id\n");
 		}
 	} else {
 		status = DSP_EHANDLE;
@@ -801,308 +707,311 @@
 }
 
 /*
- *  ======== UnRegisterGPPSMSeg ========
+ *  ======== un_register_gppsm_seg ========
  *  Purpose:
  *      UnRegister the SM allocator by freeing all its resources and
  *      nulling cmm mgr table entry.
  *  Note:
  *      This routine is always called within cmm lock crit sect.
  */
-static void UnRegisterGPPSMSeg(struct CMM_ALLOCATOR *pSMA)
+static void un_register_gppsm_seg(struct cmm_allocator *psma)
 {
-	struct CMM_MNODE *pCurNode = NULL;
-	struct CMM_MNODE *pNextNode = NULL;
+	struct cmm_mnode *mnode_obj = NULL;
+	struct cmm_mnode *next_node = NULL;
 
-	DBC_Require(pSMA != NULL);
-	if (pSMA->pFreeListHead != NULL) {
+	DBC_REQUIRE(psma != NULL);
+	if (psma->free_list_head != NULL) {
 		/* free nodes on free list */
-		pCurNode = (struct CMM_MNODE *)LST_First(pSMA->pFreeListHead);
-		while (pCurNode) {
-			pNextNode = (struct CMM_MNODE *)LST_Next(pSMA->
-				     pFreeListHead,
-				    (struct LST_ELEM *)pCurNode);
-			LST_RemoveElem(pSMA->pFreeListHead,
-				      (struct LST_ELEM *)pCurNode);
-			MEM_Free((void *) pCurNode);
+		mnode_obj = (struct cmm_mnode *)lst_first(psma->free_list_head);
+		while (mnode_obj) {
+			next_node =
+			    (struct cmm_mnode *)lst_next(psma->free_list_head,
+							 (struct list_head *)
+							 mnode_obj);
+			lst_remove_elem(psma->free_list_head,
+					(struct list_head *)mnode_obj);
+			kfree((void *)mnode_obj);
 			/* next node. */
-			pCurNode = pNextNode;
+			mnode_obj = next_node;
 		}
-		LST_Delete(pSMA->pFreeListHead);	/* delete freelist */
+		kfree(psma->free_list_head);	/* delete freelist */
 		/* free nodes on InUse list */
-		pCurNode = (struct CMM_MNODE *)LST_First(pSMA->pInUseListHead);
-		while (pCurNode) {
-			pNextNode = (struct CMM_MNODE *)LST_Next(pSMA->
-				    pInUseListHead,
-				    (struct LST_ELEM *)pCurNode);
-			LST_RemoveElem(pSMA->pInUseListHead,
-				      (struct LST_ELEM *)pCurNode);
-			MEM_Free((void *) pCurNode);
+		mnode_obj =
+		    (struct cmm_mnode *)lst_first(psma->in_use_list_head);
+		while (mnode_obj) {
+			next_node =
+			    (struct cmm_mnode *)lst_next(psma->in_use_list_head,
+							 (struct list_head *)
+							 mnode_obj);
+			lst_remove_elem(psma->in_use_list_head,
+					(struct list_head *)mnode_obj);
+			kfree((void *)mnode_obj);
 			/* next node. */
-			pCurNode = pNextNode;
+			mnode_obj = next_node;
 		}
-		LST_Delete(pSMA->pInUseListHead);	/* delete InUse list */
+		kfree(psma->in_use_list_head);	/* delete InUse list */
 	}
-	if ((void *) pSMA->dwVmBase != NULL)
-		MEM_UnmapLinearAddress((void *) pSMA->dwVmBase);
+	if ((void *)psma->dw_vm_base != NULL)
+		MEM_UNMAP_LINEAR_ADDRESS((void *)psma->dw_vm_base);
 
 	/* Free allocator itself */
-	MEM_FreeObject(pSMA);
+	MEM_FREE_OBJECT(psma);
 }
 
 /*
- *  ======== GetSlot ========
+ *  ======== get_slot ========
  *  Purpose:
  *      An available slot # is returned. Returns negative on failure.
  */
-static s32 GetSlot(struct CMM_OBJECT *pCmmMgr)
+static s32 get_slot(struct cmm_object *cmm_mgr_obj)
 {
-	s32 nSlot = -1;		/* neg on failure */
-	DBC_Require(pCmmMgr != NULL);
+	s32 slot_seg = -1;	/* neg on failure */
+	DBC_REQUIRE(cmm_mgr_obj != NULL);
 	/* get first available slot in cmm mgr SMSegTab[] */
-	for (nSlot = 0; nSlot < CMM_MAXGPPSEGS; nSlot++) {
-		if (pCmmMgr->paGPPSMSegTab[nSlot] == NULL)
+	for (slot_seg = 0; slot_seg < CMM_MAXGPPSEGS; slot_seg++) {
+		if (cmm_mgr_obj->pa_gppsm_seg_tab[slot_seg] == NULL)
 			break;
 
 	}
-	if (nSlot == CMM_MAXGPPSEGS) {
-		GT_0trace(CMM_debugMask, GT_7CLASS,
-			  "CMM_RegisterGPPSMSeg: Allocator "
-			  "entry failure, max exceeded\n");
-		nSlot = -1;	/* failed */
-	}
-	return nSlot;
+	if (slot_seg == CMM_MAXGPPSEGS)
+		slot_seg = -1;	/* failed */
+
+	return slot_seg;
 }
 
 /*
- *  ======== GetNode ========
+ *  ======== get_node ========
  *  Purpose:
  *      Get a memory node from freelist or create a new one.
  */
-static struct CMM_MNODE *GetNode(struct CMM_OBJECT *pCmmMgr, u32 dwPA,
-				 u32 dwVA, u32 ulSize)
+static struct cmm_mnode *get_node(struct cmm_object *cmm_mgr_obj, u32 dw_pa,
+				  u32 dw_va, u32 ul_size)
 {
-	struct CMM_MNODE *pNode = NULL;
+	struct cmm_mnode *pnode = NULL;
 
-	DBC_Require(pCmmMgr != NULL);
-	DBC_Require(dwPA != 0);
-	DBC_Require(dwVA != 0);
-	DBC_Require(ulSize != 0);
+	DBC_REQUIRE(cmm_mgr_obj != NULL);
+	DBC_REQUIRE(dw_pa != 0);
+	DBC_REQUIRE(dw_va != 0);
+	DBC_REQUIRE(ul_size != 0);
 	/* Check cmm mgr's node freelist */
-	if (LST_IsEmpty(pCmmMgr->pNodeFreeListHead)) {
-		pNode = (struct CMM_MNODE *)MEM_Calloc(sizeof(struct CMM_MNODE),
-			MEM_PAGED);
+	if (LST_IS_EMPTY(cmm_mgr_obj->node_free_list_head)) {
+		pnode = (struct cmm_mnode *)mem_calloc(sizeof(struct cmm_mnode),
+						       MEM_PAGED);
 	} else {
 		/* surely a valid element */
-		/* (struct LST_ELEM*) pNode = LST_GetHead(pCmmMgr->
-		 * pNodeFreeListHead);*/
-		pNode = (struct CMM_MNODE *)LST_GetHead(pCmmMgr->
-			pNodeFreeListHead);
+		pnode = (struct cmm_mnode *)
+		    lst_get_head(cmm_mgr_obj->node_free_list_head);
 	}
-	if (pNode == NULL) {
-		GT_0trace(CMM_debugMask, GT_7CLASS, "GetNode: Out Of Memory\n");
-	} else {
-		LST_InitElem((struct LST_ELEM *) pNode);	/* set self */
-		pNode->dwPA = dwPA;	/* Physical addr of start of block */
-		pNode->dwVA = dwVA;	/* Virtual   "            "        */
-		pNode->ulSize = ulSize;	/* Size of block */
+	if (pnode) {
+		lst_init_elem((struct list_head *)pnode);	/* set self */
+		pnode->dw_pa = dw_pa;	/* Physical addr of start of block */
+		pnode->dw_va = dw_va;	/* Virtual   "            " */
+		pnode->ul_size = ul_size;	/* Size of block */
 	}
-	return pNode;
+	return pnode;
 }
 
 /*
- *  ======== DeleteNode ========
+ *  ======== delete_node ========
  *  Purpose:
  *      Put a memory node on the cmm nodelist for later use.
  *      Doesn't actually delete the node. Heap thrashing friendly.
  */
-static void DeleteNode(struct CMM_OBJECT *pCmmMgr, struct CMM_MNODE *pNode)
+static void delete_node(struct cmm_object *cmm_mgr_obj, struct cmm_mnode *pnode)
 {
-	DBC_Require(pNode != NULL);
-	LST_InitElem((struct LST_ELEM *) pNode);	/* init .self ptr */
-	LST_PutTail(pCmmMgr->pNodeFreeListHead, (struct LST_ELEM *) pNode);
+	DBC_REQUIRE(pnode != NULL);
+	lst_init_elem((struct list_head *)pnode);	/* init .self ptr */
+	lst_put_tail(cmm_mgr_obj->node_free_list_head,
+		     (struct list_head *)pnode);
 }
 
 /*
- * ====== GetFreeBlock ========
+ * ====== get_free_block ========
  *  Purpose:
  *      Scan the free block list and return the first block that satisfies
  *      the size.
  */
-static struct CMM_MNODE *GetFreeBlock(struct CMM_ALLOCATOR *pAllocator,
-				      u32 uSize)
+static struct cmm_mnode *get_free_block(struct cmm_allocator *allocator,
+					u32 usize)
 {
-	if (pAllocator) {
-		struct CMM_MNODE *pCurNode = (struct CMM_MNODE *)
-					LST_First(pAllocator->pFreeListHead);
-		while (pCurNode) {
-			if (uSize <= (u32) pCurNode->ulSize) {
-				LST_RemoveElem(pAllocator->pFreeListHead,
-					      (struct LST_ELEM *)pCurNode);
-				return pCurNode;
+	if (allocator) {
+		struct cmm_mnode *mnode_obj = (struct cmm_mnode *)
+		    lst_first(allocator->free_list_head);
+		while (mnode_obj) {
+			if (usize <= (u32) mnode_obj->ul_size) {
+				lst_remove_elem(allocator->free_list_head,
+						(struct list_head *)mnode_obj);
+				return mnode_obj;
 			}
 			/* next node. */
-			pCurNode = (struct CMM_MNODE *)LST_Next(pAllocator->
-				    pFreeListHead, (struct LST_ELEM *)pCurNode);
+			mnode_obj = (struct cmm_mnode *)
+			    lst_next(allocator->free_list_head,
+				     (struct list_head *)mnode_obj);
 		}
 	}
 	return NULL;
 }
 
 /*
- *  ======== AddToFreeList ========
+ *  ======== add_to_free_list ========
  *  Purpose:
  *      Coelesce node into the freelist in ascending size order.
  */
-static void AddToFreeList(struct CMM_ALLOCATOR *pAllocator,
-			  struct CMM_MNODE *pNode)
+static void add_to_free_list(struct cmm_allocator *allocator,
+			     struct cmm_mnode *pnode)
 {
-	struct CMM_MNODE *pNodePrev = NULL;
-	struct CMM_MNODE *pNodeNext = NULL;
-	struct CMM_MNODE *pCurNode;
-	u32 dwThisPA;
-	u32 dwNextPA;
-
-	DBC_Require(pNode != NULL);
-	DBC_Require(pAllocator != NULL);
-	dwThisPA = pNode->dwPA;
-	dwNextPA = NEXT_PA(pNode);
-	pCurNode = (struct CMM_MNODE *)LST_First(pAllocator->pFreeListHead);
-	while (pCurNode) {
-		if (dwThisPA == NEXT_PA(pCurNode)) {
+	struct cmm_mnode *node_prev = NULL;
+	struct cmm_mnode *node_next = NULL;
+	struct cmm_mnode *mnode_obj;
+	u32 dw_this_pa;
+	u32 dw_next_pa;
+
+	DBC_REQUIRE(pnode != NULL);
+	DBC_REQUIRE(allocator != NULL);
+	dw_this_pa = pnode->dw_pa;
+	dw_next_pa = NEXT_PA(pnode);
+	mnode_obj = (struct cmm_mnode *)lst_first(allocator->free_list_head);
+	while (mnode_obj) {
+		if (dw_this_pa == NEXT_PA(mnode_obj)) {
 			/* found the block ahead of this one */
-			pNodePrev = pCurNode;
-		} else if (dwNextPA == pCurNode->dwPA) {
-			pNodeNext = pCurNode;
+			node_prev = mnode_obj;
+		} else if (dw_next_pa == mnode_obj->dw_pa) {
+			node_next = mnode_obj;
 		}
-		if ((pNodePrev == NULL) || (pNodeNext == NULL)) {
+		if ((node_prev == NULL) || (node_next == NULL)) {
 			/* next node. */
-			pCurNode = (struct CMM_MNODE *)LST_Next(pAllocator->
-				    pFreeListHead, (struct LST_ELEM *)pCurNode);
+			mnode_obj = (struct cmm_mnode *)
+			    lst_next(allocator->free_list_head,
+				     (struct list_head *)mnode_obj);
 		} else {
 			/* got 'em */
 			break;
 		}
 	}			/* while */
-	if (pNodePrev != NULL) {
+	if (node_prev != NULL) {
 		/* combine with previous block */
-		LST_RemoveElem(pAllocator->pFreeListHead,
-			      (struct LST_ELEM *)pNodePrev);
+		lst_remove_elem(allocator->free_list_head,
+				(struct list_head *)node_prev);
 		/* grow node to hold both */
-		pNode->ulSize += pNodePrev->ulSize;
-		pNode->dwPA = pNodePrev->dwPA;
-		pNode->dwVA = pNodePrev->dwVA;
+		pnode->ul_size += node_prev->ul_size;
+		pnode->dw_pa = node_prev->dw_pa;
+		pnode->dw_va = node_prev->dw_va;
 		/* place node on mgr nodeFreeList */
-		DeleteNode((struct CMM_OBJECT *)pAllocator->hCmmMgr, pNodePrev);
+		delete_node((struct cmm_object *)allocator->hcmm_mgr,
+			    node_prev);
 	}
-	if (pNodeNext != NULL) {
+	if (node_next != NULL) {
 		/* combine with next block */
-		LST_RemoveElem(pAllocator->pFreeListHead,
-			      (struct LST_ELEM *)pNodeNext);
+		lst_remove_elem(allocator->free_list_head,
+				(struct list_head *)node_next);
 		/* grow da node */
-		pNode->ulSize += pNodeNext->ulSize;
+		pnode->ul_size += node_next->ul_size;
 		/* place node on mgr nodeFreeList */
-		DeleteNode((struct CMM_OBJECT *)pAllocator->hCmmMgr, pNodeNext);
+		delete_node((struct cmm_object *)allocator->hcmm_mgr,
+			    node_next);
 	}
 	/* Now, let's add to freelist in increasing size order */
-	pCurNode = (struct CMM_MNODE *)LST_First(pAllocator->pFreeListHead);
-	while (pCurNode) {
-		if (pNode->ulSize <= pCurNode->ulSize)
+	mnode_obj = (struct cmm_mnode *)lst_first(allocator->free_list_head);
+	while (mnode_obj) {
+		if (pnode->ul_size <= mnode_obj->ul_size)
 			break;
 
 		/* next node. */
-		pCurNode = (struct CMM_MNODE *)LST_Next(pAllocator->
-			   pFreeListHead, (struct LST_ELEM *)pCurNode);
-	}
-	/* if pCurNode is NULL then add our pNode to the end of the freelist */
-	if (pCurNode == NULL) {
-		LST_PutTail(pAllocator->pFreeListHead,
-			   (struct LST_ELEM *)pNode);
+		mnode_obj =
+		    (struct cmm_mnode *)lst_next(allocator->free_list_head,
+						 (struct list_head *)mnode_obj);
+	}
+	/* if mnode_obj is NULL then add our pnode to the end of the freelist */
+	if (mnode_obj == NULL) {
+		lst_put_tail(allocator->free_list_head,
+			     (struct list_head *)pnode);
 	} else {
 		/* insert our node before the current traversed node */
-		LST_InsertBefore(pAllocator->pFreeListHead,
-				(struct LST_ELEM *)pNode,
-				(struct LST_ELEM *)pCurNode);
+		lst_insert_before(allocator->free_list_head,
+				  (struct list_head *)pnode,
+				  (struct list_head *)mnode_obj);
 	}
 }
 
 /*
- * ======== GetAllocator ========
+ * ======== get_allocator ========
  *  Purpose:
  *      Return the allocator for the given SM Segid.
  *      SegIds:  1,2,3..max.
  */
-static struct CMM_ALLOCATOR *GetAllocator(struct CMM_OBJECT *pCmmMgr,
-					  u32 ulSegId)
+static struct cmm_allocator *get_allocator(struct cmm_object *cmm_mgr_obj,
+					   u32 ul_seg_id)
 {
-	struct CMM_ALLOCATOR *pAllocator = NULL;
+	struct cmm_allocator *allocator = NULL;
 
-	DBC_Require(pCmmMgr != NULL);
-	DBC_Require((ulSegId > 0) && (ulSegId <= CMM_MAXGPPSEGS));
-	pAllocator = pCmmMgr->paGPPSMSegTab[ulSegId - 1];
-	if (pAllocator != NULL) {
+	DBC_REQUIRE(cmm_mgr_obj != NULL);
+	DBC_REQUIRE((ul_seg_id > 0) && (ul_seg_id <= CMM_MAXGPPSEGS));
+	allocator = cmm_mgr_obj->pa_gppsm_seg_tab[ul_seg_id - 1];
+	if (allocator != NULL) {
 		/* make sure it's for real */
-		if (!MEM_IsValidHandle(pAllocator, SMEMSIGNATURE)) {
-			pAllocator = NULL;
-			DBC_Assert(false);
+		if (!MEM_IS_VALID_HANDLE(allocator, SMEMSIGNATURE)) {
+			allocator = NULL;
+			DBC_ASSERT(false);
 		}
 	}
-	return pAllocator;
+	return allocator;
 }
 
 /*
- *  ======== CMM_XlatorCreate ========
+ *  The CMM_Xlator[xxx] routines below are used by Node and Stream
+ *  to perform SM address translation to the client process address space.
+ *  A "translator" object is created by a node/stream for each SM seg used.
+ */
+
+/*
+ *  ======== cmm_xlator_create ========
  *  Purpose:
  *      Create an address translator object.
  */
-DSP_STATUS CMM_XlatorCreate(OUT struct CMM_XLATOROBJECT **phXlator,
-				struct CMM_OBJECT *hCmmMgr,
-				struct CMM_XLATORATTRS *pXlatorAttrs)
-{
-	struct CMM_XLATOR *pXlatorObject = NULL;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(phXlator != NULL);
-	DBC_Require(hCmmMgr != NULL);
-	GT_3trace(CMM_debugMask, GT_ENTER,
-		  "CMM_XlatorCreate: phXlator: 0x%x\t"
-		  "phCmmMgr: 0x%x\tpXlAttrs: 0x%x\n", phXlator,
-		  hCmmMgr, pXlatorAttrs);
+dsp_status cmm_xlator_create(OUT struct cmm_xlatorobject **phXlator,
+			     struct cmm_object *hcmm_mgr,
+			     struct cmm_xlatorattrs *pXlatorAttrs)
+{
+	struct cmm_xlator *xlator_object = NULL;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phXlator != NULL);
+	DBC_REQUIRE(hcmm_mgr != NULL);
+
 	*phXlator = NULL;
 	if (pXlatorAttrs == NULL)
-		pXlatorAttrs = &CMM_DFLTXLATORATTRS;	/* set defaults */
+		pXlatorAttrs = &cmm_dfltxlatorattrs;	/* set defaults */
 
-	MEM_AllocObject(pXlatorObject, struct CMM_XLATOR, CMMXLATESIGNATURE);
-	if (pXlatorObject != NULL) {
-		pXlatorObject->hCmmMgr = hCmmMgr;	/* ref back to CMM */
-		pXlatorObject->ulSegId = pXlatorAttrs->ulSegId;	/* SM segId */
+	MEM_ALLOC_OBJECT(xlator_object, struct cmm_xlator, CMMXLATESIGNATURE);
+	if (xlator_object != NULL) {
+		xlator_object->hcmm_mgr = hcmm_mgr;	/* ref back to CMM */
+		/* SM seg_id */
+		xlator_object->ul_seg_id = pXlatorAttrs->ul_seg_id;
 	} else {
-		GT_0trace(CMM_debugMask, GT_6CLASS,
-			  "CMM_XlatorCreate: Object Allocation"
-			  "Failure(CMM Xlator)\n");
 		status = DSP_EMEMORY;
 	}
 	if (DSP_SUCCEEDED(status))
-		*phXlator = (struct CMM_XLATOROBJECT *) pXlatorObject;
+		*phXlator = (struct cmm_xlatorobject *)xlator_object;
 
 	return status;
 }
 
 /*
- *  ======== CMM_XlatorDelete ========
+ *  ======== cmm_xlator_delete ========
  *  Purpose:
  *      Free the Xlator resources.
  *      VM gets freed later.
  */
-DSP_STATUS CMM_XlatorDelete(struct CMM_XLATOROBJECT *hXlator, bool bForce)
+dsp_status cmm_xlator_delete(struct cmm_xlatorobject *xlator, bool bForce)
 {
-	struct CMM_XLATOR *pXlator = (struct CMM_XLATOR *)hXlator;
-	DSP_STATUS status = DSP_SOK;
+	struct cmm_xlator *xlator_obj = (struct cmm_xlator *)xlator;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	if (MEM_IsValidHandle(pXlator, CMMXLATESIGNATURE)) {
-		MEM_FreeObject(pXlator);
+	if (MEM_IS_VALID_HANDLE(xlator_obj, CMMXLATESIGNATURE)) {
+		MEM_FREE_OBJECT(xlator_obj);
 	} else {
 		status = DSP_EHANDLE;
 	}
@@ -1111,68 +1020,65 @@
 }
 
 /*
- *  ======== CMM_XlatorAllocBuf ========
+ *  ======== cmm_xlator_alloc_buf ========
  */
-void *CMM_XlatorAllocBuf(struct CMM_XLATOROBJECT *hXlator, void *pVaBuf,
-			u32 uPaSize)
+void *cmm_xlator_alloc_buf(struct cmm_xlatorobject *xlator, void *pVaBuf,
+			   u32 uPaSize)
 {
-	struct CMM_XLATOR *pXlator = (struct CMM_XLATOR *)hXlator;
-	void *pBuf = NULL;
-	struct CMM_ATTRS attrs;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(hXlator != NULL);
-	DBC_Require(pXlator->hCmmMgr != NULL);
-	DBC_Require(pVaBuf != NULL);
-	DBC_Require(uPaSize > 0);
-	DBC_Require(pXlator->ulSegId > 0);
+	struct cmm_xlator *xlator_obj = (struct cmm_xlator *)xlator;
+	void *pbuf = NULL;
+	struct cmm_attrs attrs;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(xlator != NULL);
+	DBC_REQUIRE(xlator_obj->hcmm_mgr != NULL);
+	DBC_REQUIRE(pVaBuf != NULL);
+	DBC_REQUIRE(uPaSize > 0);
+	DBC_REQUIRE(xlator_obj->ul_seg_id > 0);
 
-	if (MEM_IsValidHandle(pXlator, CMMXLATESIGNATURE)) {
-		attrs.ulSegId = pXlator->ulSegId;
+	if (MEM_IS_VALID_HANDLE(xlator_obj, CMMXLATESIGNATURE)) {
+		attrs.ul_seg_id = xlator_obj->ul_seg_id;
 		*(volatile u32 *)pVaBuf = 0;
 		/* Alloc SM */
-		pBuf = CMM_CallocBuf(pXlator->hCmmMgr, uPaSize, &attrs,  NULL);
-		if (pBuf) {
+		pbuf =
+		    cmm_calloc_buf(xlator_obj->hcmm_mgr, uPaSize, &attrs, NULL);
+		if (pbuf) {
 			/* convert to translator(node/strm) process Virtual
 			 * address */
 			*(volatile u32 **)pVaBuf =
-				 (u32 *)CMM_XlatorTranslate(hXlator,
-							      pBuf, CMM_PA2VA);
+			    (u32 *) cmm_xlator_translate(xlator,
+							 pbuf, CMM_PA2VA);
 		}
 	}
-	return pBuf;
+	return pbuf;
 }
 
 /*
- *  ======== CMM_XlatorFreeBuf ========
+ *  ======== cmm_xlator_free_buf ========
  *  Purpose:
  *      Free the given SM buffer and descriptor.
  *      Does not free virtual memory.
  */
-DSP_STATUS CMM_XlatorFreeBuf(struct CMM_XLATOROBJECT *hXlator, void *pBufVa)
+dsp_status cmm_xlator_free_buf(struct cmm_xlatorobject *xlator, void *pBufVa)
 {
-	struct CMM_XLATOR *pXlator = (struct CMM_XLATOR *)hXlator;
-	DSP_STATUS status = DSP_EFAIL;
-	void *pBufPa = NULL;
+	struct cmm_xlator *xlator_obj = (struct cmm_xlator *)xlator;
+	dsp_status status = DSP_EFAIL;
+	void *buf_pa = NULL;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pBufVa != NULL);
-	DBC_Require(pXlator->ulSegId > 0);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pBufVa != NULL);
+	DBC_REQUIRE(xlator_obj->ul_seg_id > 0);
 
-	if (MEM_IsValidHandle(pXlator, CMMXLATESIGNATURE)) {
+	if (MEM_IS_VALID_HANDLE(xlator_obj, CMMXLATESIGNATURE)) {
 		/* convert Va to Pa so we can free it. */
-		pBufPa = CMM_XlatorTranslate(hXlator, pBufVa, CMM_VA2PA);
-		if (pBufPa) {
-			status = CMM_FreeBuf(pXlator->hCmmMgr, pBufPa,
-					     pXlator->ulSegId);
+		buf_pa = cmm_xlator_translate(xlator, pBufVa, CMM_VA2PA);
+		if (buf_pa) {
+			status = cmm_free_buf(xlator_obj->hcmm_mgr, buf_pa,
+					      xlator_obj->ul_seg_id);
 			if (DSP_FAILED(status)) {
 				/* Uh oh, this shouldn't happen. Descriptor
 				 * gone! */
-				GT_2trace(CMM_debugMask, GT_7CLASS,
-					"Cannot free DMA/ZCPY buffer"
-					"not allocated by MPU. PA %x, VA %x\n",
-					pBufPa, pBufVa);
-				DBC_Assert(false);   /* CMM is leaking mem! */
+				DBC_ASSERT(false);	/* CMM is leaking mem */
 			}
 		}
 	}
@@ -1180,31 +1086,27 @@
 }
 
 /*
- *  ======== CMM_XlatorInfo ========
+ *  ======== cmm_xlator_info ========
  *  Purpose:
  *      Set/Get translator info.
  */
-DSP_STATUS CMM_XlatorInfo(struct CMM_XLATOROBJECT *hXlator, IN OUT u8 **pAddr,
-			 u32 ulSize, u32 uSegId, bool bSetInfo)
+dsp_status cmm_xlator_info(struct cmm_xlatorobject *xlator, IN OUT u8 ** paddr,
+			   u32 ul_size, u32 uSegId, bool set_info)
 {
-	struct CMM_XLATOR *pXlator = (struct CMM_XLATOR *)hXlator;
-	DSP_STATUS status = DSP_SOK;
+	struct cmm_xlator *xlator_obj = (struct cmm_xlator *)xlator;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pAddr != NULL);
-	DBC_Require((uSegId > 0) && (uSegId <= CMM_MAXGPPSEGS));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(paddr != NULL);
+	DBC_REQUIRE((uSegId > 0) && (uSegId <= CMM_MAXGPPSEGS));
 
-	if (MEM_IsValidHandle(pXlator, CMMXLATESIGNATURE)) {
-		if (bSetInfo) {
+	if (MEM_IS_VALID_HANDLE(xlator_obj, CMMXLATESIGNATURE)) {
+		if (set_info) {
 			/* set translators virtual address range */
-			pXlator->dwVirtBase = (u32)*pAddr;
-			pXlator->ulVirtSize = ulSize;
-			GT_2trace(CMM_debugMask, GT_3CLASS,
-				  "pXlator->dwVirtBase %x, "
-				  "ulVirtSize %x\n", pXlator->dwVirtBase,
-				  pXlator->ulVirtSize);
+			xlator_obj->dw_virt_base = (u32) *paddr;
+			xlator_obj->ul_virt_size = ul_size;
 		} else {	/* return virt base address */
-			*pAddr = (u8 *)pXlator->dwVirtBase;
+			*paddr = (u8 *) xlator_obj->dw_virt_base;
 		}
 	} else {
 		status = DSP_EHANDLE;
@@ -1213,79 +1115,73 @@
 }
 
 /*
- *  ======== CMM_XlatorTranslate ========
+ *  ======== cmm_xlator_translate ========
  */
-void *CMM_XlatorTranslate(struct CMM_XLATOROBJECT *hXlator, void *pAddr,
-			  enum CMM_XLATETYPE xType)
+void *cmm_xlator_translate(struct cmm_xlatorobject *xlator, void *paddr,
+			   enum cmm_xlatetype xType)
 {
-	u32 dwAddrXlate = 0;
-	struct CMM_XLATOR *pXlator = (struct CMM_XLATOR *)hXlator;
-	struct CMM_OBJECT *pCmmMgr = NULL;
-	struct CMM_ALLOCATOR *pAlctr = NULL;
-	u32 dwOffset = 0;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pAddr != NULL);
-	DBC_Require((xType >= CMM_VA2PA) && (xType <= CMM_DSPPA2PA));
+	u32 dw_addr_xlate = 0;
+	struct cmm_xlator *xlator_obj = (struct cmm_xlator *)xlator;
+	struct cmm_object *cmm_mgr_obj = NULL;
+	struct cmm_allocator *allocator = NULL;
+	u32 dw_offset = 0;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(paddr != NULL);
+	DBC_REQUIRE((xType >= CMM_VA2PA) && (xType <= CMM_DSPPA2PA));
 
-	if (!MEM_IsValidHandle(pXlator, CMMXLATESIGNATURE))
+	if (!MEM_IS_VALID_HANDLE(xlator_obj, CMMXLATESIGNATURE))
 		goto loop_cont;
 
-	pCmmMgr = (struct CMM_OBJECT *)pXlator->hCmmMgr;
+	cmm_mgr_obj = (struct cmm_object *)xlator_obj->hcmm_mgr;
 	/* get this translator's default SM allocator */
-	DBC_Assert(pXlator->ulSegId > 0);
-	pAlctr = pCmmMgr->paGPPSMSegTab[pXlator->ulSegId - 1];
-	if (!MEM_IsValidHandle(pAlctr, SMEMSIGNATURE))
+	DBC_ASSERT(xlator_obj->ul_seg_id > 0);
+	allocator = cmm_mgr_obj->pa_gppsm_seg_tab[xlator_obj->ul_seg_id - 1];
+	if (!MEM_IS_VALID_HANDLE(allocator, SMEMSIGNATURE))
 		goto loop_cont;
 
 	if ((xType == CMM_VA2DSPPA) || (xType == CMM_VA2PA) ||
 	    (xType == CMM_PA2VA)) {
 		if (xType == CMM_PA2VA) {
 			/* Gpp Va = Va Base + offset */
-			dwOffset = (u8 *)pAddr - (u8 *)(pAlctr->dwSmBase -
-				    pAlctr->ulDSPSize);
-			dwAddrXlate = pXlator->dwVirtBase + dwOffset;
+			dw_offset = (u8 *) paddr - (u8 *) (allocator->shm_base -
+							   allocator->
+							   ul_dsp_size);
+			dw_addr_xlate = xlator_obj->dw_virt_base + dw_offset;
 			/* Check if translated Va base is in range */
-			if ((dwAddrXlate < pXlator->dwVirtBase) ||
-			   (dwAddrXlate >=
-			   (pXlator->dwVirtBase + pXlator->ulVirtSize))) {
-				dwAddrXlate = 0;	/* bad address */
-				GT_0trace(CMM_debugMask, GT_7CLASS,
-					  "CMM_XlatorTranslate: "
-					  "Virt addr out of range\n");
+			if ((dw_addr_xlate < xlator_obj->dw_virt_base) ||
+			    (dw_addr_xlate >=
+			     (xlator_obj->dw_virt_base +
+			      xlator_obj->ul_virt_size))) {
+				dw_addr_xlate = 0;	/* bad address */
 			}
 		} else {
 			/* Gpp PA =  Gpp Base + offset */
-			dwOffset = (u8 *)pAddr - (u8 *)pXlator->dwVirtBase;
-			dwAddrXlate = pAlctr->dwSmBase - pAlctr->ulDSPSize +
-				      dwOffset;
+			dw_offset =
+			    (u8 *) paddr - (u8 *) xlator_obj->dw_virt_base;
+			dw_addr_xlate =
+			    allocator->shm_base - allocator->ul_dsp_size +
+			    dw_offset;
 		}
 	} else {
-		dwAddrXlate = (u32)pAddr;
+		dw_addr_xlate = (u32) paddr;
 	}
-	 /*Now convert address to proper target physical address if needed*/
+	/*Now convert address to proper target physical address if needed */
 	if ((xType == CMM_VA2DSPPA) || (xType == CMM_PA2DSPPA)) {
 		/* Got Gpp Pa now, convert to DSP Pa */
-		dwAddrXlate = GPPPA2DSPPA((pAlctr->dwSmBase - pAlctr->
-					 ulDSPSize), dwAddrXlate,
-					 pAlctr->dwDSPPhysAddrOffset *
-					 pAlctr->cFactor);
+		dw_addr_xlate =
+		    GPPPA2DSPPA((allocator->shm_base - allocator->ul_dsp_size),
+				dw_addr_xlate,
+				allocator->dw_dsp_phys_addr_offset *
+				allocator->c_factor);
 	} else if (xType == CMM_DSPPA2PA) {
 		/* Got DSP Pa, convert to GPP Pa */
-		dwAddrXlate = DSPPA2GPPPA(pAlctr->dwSmBase - pAlctr->ulDSPSize,
-					  dwAddrXlate,
-					  pAlctr->dwDSPPhysAddrOffset *
-					  pAlctr->cFactor);
+		dw_addr_xlate =
+		    DSPPA2GPPPA(allocator->shm_base - allocator->ul_dsp_size,
+				dw_addr_xlate,
+				allocator->dw_dsp_phys_addr_offset *
+				allocator->c_factor);
 	}
 loop_cont:
-	if (!dwAddrXlate) {
-		GT_2trace(CMM_debugMask, GT_7CLASS,
-			  "CMM_XlatorTranslate: Can't translate"
-			  " address: 0x%x xType %x\n", pAddr, xType);
-	} else {
-		GT_3trace(CMM_debugMask, GT_3CLASS,
-			  "CMM_XlatorTranslate: pAddr %x, xType"
-			  " %x, dwAddrXlate %x\n", pAddr, xType, dwAddrXlate);
-	}
-	return (void *)dwAddrXlate;
+	return (void *)dw_addr_xlate;
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/cod.c kernel-power-2.6.28.new/drivers/dsp/bridge/pmgr/cod.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/cod.c	2011-10-11 13:51:00.517611696 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/pmgr/cod.c	2011-10-23 08:22:37.625950000 +0100
@@ -3,6 +3,12 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This module implements DSP code management for the DSP/BIOS Bridge
+ * environment. It is mostly a thin wrapper.
+ *
+ * This module provides an interface for loading both static and
+ * dynamic code objects onto DSP systems.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,49 +20,10 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== cod.c ========
- *  This module implements DSP code management for the DSP/BIOS Bridge
- *  environment. It is mostly a thin wrapper.
- *
- *  This module provides an interface for loading both static and
- *  dynamic code objects onto DSP systems.
- *
- *! Revision History
- *! ================
- *! 08-Apr-2003 map: Consolidated DBL to DBLL loader name
- *! 24-Feb-2003 swa: PMGR Code review comments incorporated.
- *! 18-Apr-2002 jeh: Added DBL function tables.
- *! 20-Nov-2001 jeh: Removed call to ZL_loadArgs function.
- *! 19-Oct-2001 jeh: Access DBL as a static library. Added COD_GetBaseLib,
- *!		  COD_GetLoader, removed COD_LoadSection, COD_UnloadSection.
- *! 07-Sep-2001 jeh: Added COD_LoadSection(), COD_UnloadSection().
- *! 07-Aug-2001 rr:  hMgr->baseLib is updated after zlopen in COD_LoadBase.
- *! 18-Apr-2001 jeh: Check for fLoaded flag before ZL_unload, to allow
- *!		  COD_OpenBase to be used.
- *! 11-Jan-2001 jeh: Added COD_OpenBase (not used yet, since there is an
- *!		  occasional crash).
- *! 02-Aug-2000 kc:  Added COD_ReadSection to COD module. Incorporates use
- *!		  of ZL_readSect (new function in ZL module).
- *! 28-Feb-2000 rr:  New GT Usage Implementation
- *! 08-Dec-1999 ag:  Removed x86 specific __asm int 3.
- *! 02-Oct-1999 ag:  Added #ifdef DEBUGINT3COD for debug.
- *! 20-Sep-1999 ag:  Removed call to GT_set().
- *! 04-Jun-1997 cr:  Added validation of argc/argv pair in COD_LoadBase, as it
- *!		     is a requirement to ZL_loadArgs.
- *! 31-May-1997 cr:  Changed COD_LoadBase argc value from u32 to int, added
- *!	       DSP_ENOTIMPL return value to COD_Create when attrs != NULL.
- *! 29-May-1997 cr:  Added debugging support.
- *! 24-Oct-1996 gp:  Added COD_GetSection().
- *! 18-Jun-1996 gp:  Updated GetSymValue() to check for lib; updated E_ codes.
- *! 12-Jun-1996 gp:  Imported CSL_ services for strcpyn(); Added ref counting.
- *! 20-May-1996 mg:  Adapted for new MEM and LDR modules.
- *! 08-May-1996 mg:  Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
 
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
@@ -65,11 +32,8 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
-#include <dspbridge/kfile.h>
 #include <dspbridge/ldr.h>
 #include <dspbridge/mem.h>
 
@@ -84,77 +48,168 @@
 #define MAGIC	 0xc001beef
 
 /* macro to validate COD manager handles */
-#define IsValid(h)    ((h) != NULL && (h)->ulMagic == MAGIC)
+#define IS_VALID(h)    ((h) != NULL && (h)->ul_magic == MAGIC)
+
+/*
+ *  ======== cod_manager ========
+ */
+struct cod_manager {
+	struct dbll_tar_obj *target;
+	struct dbll_library_obj *base_lib;
+	bool loaded;		/* Base library loaded? */
+	u32 ul_entry;
+	struct ldr_module *dll_obj;
+	struct dbll_fxns fxns;
+	struct dbll_attrs attrs;
+	char sz_zl_file[COD_MAXPATHLENGTH];
+	u32 ul_magic;
+};
 
 /*
- *  ======== COD_MANAGER ========
+ *  ======== cod_libraryobj ========
  */
-struct COD_MANAGER {
-	struct DBLL_TarObj *target;
-	struct DBLL_LibraryObj *baseLib;
-	bool fLoaded;		/* Base library loaded? */
-	u32 ulEntry;
-	struct LDR_MODULE *hDll;
-	struct DBLL_Fxns fxns;
-	struct DBLL_Attrs attrs;
-	char szZLFile[COD_MAXPATHLENGTH];
-	u32 ulMagic;
-} ;
-
-/*
- *  ======== COD_LIBRARYOBJ ========
- */
-struct COD_LIBRARYOBJ {
-	struct DBLL_LibraryObj *dbllLib;
-	struct COD_MANAGER *hCodMgr;
-} ;
-
-static u32 cRefs = 0L;
-
-#if GT_TRACE
-static struct GT_Mask COD_debugMask = { NULL, NULL };
-#endif
-
-static struct DBLL_Fxns dbllFxns = {
-	(DBLL_CloseFxn) DBLL_close,
-	(DBLL_CreateFxn) DBLL_create,
-	(DBLL_DeleteFxn) DBLL_delete,
-	(DBLL_ExitFxn) DBLL_exit,
-	(DBLL_GetAttrsFxn) DBLL_getAttrs,
-	(DBLL_GetAddrFxn) DBLL_getAddr,
-	(DBLL_GetCAddrFxn) DBLL_getCAddr,
-	(DBLL_GetSectFxn) DBLL_getSect,
-	(DBLL_InitFxn) DBLL_init,
-	(DBLL_LoadFxn) DBLL_load,
-	(DBLL_LoadSectFxn) DBLL_loadSect,
-	(DBLL_OpenFxn) DBLL_open,
-	(DBLL_ReadSectFxn) DBLL_readSect,
-	(DBLL_SetAttrsFxn) DBLL_setAttrs,
-	(DBLL_UnloadFxn) DBLL_unload,
-	(DBLL_UnloadSectFxn) DBLL_unloadSect,
+struct cod_libraryobj {
+	struct dbll_library_obj *dbll_lib;
+	struct cod_manager *cod_mgr;
 };
 
-static bool NoOp(void);
+static u32 refs = 0L;
+
+static struct dbll_fxns ldr_fxns = {
+	(dbll_close_fxn) dbll_close,
+	(dbll_create_fxn) dbll_create,
+	(dbll_delete_fxn) dbll_delete,
+	(dbll_exit_fxn) dbll_exit,
+	(dbll_get_attrs_fxn) dbll_get_attrs,
+	(dbll_get_addr_fxn) dbll_get_addr,
+	(dbll_get_c_addr_fxn) dbll_get_c_addr,
+	(dbll_get_sect_fxn) dbll_get_sect,
+	(dbll_init_fxn) dbll_init,
+	(dbll_load_fxn) dbll_load,
+	(dbll_load_sect_fxn) dbll_load_sect,
+	(dbll_open_fxn) dbll_open,
+	(dbll_read_sect_fxn) dbll_read_sect,
+	(dbll_set_attrs_fxn) dbll_set_attrs,
+	(dbll_unload_fxn) dbll_unload,
+	(dbll_unload_sect_fxn) dbll_unload_sect,
+};
+
+static bool no_op(void);
+
+/*
+ * File operations (originally were under kfile.c)
+ */
+static s32 cod_f_close(struct file *filp)
+{
+	/* Check for valid handle */
+	if (!filp)
+		return DSP_EHANDLE;
+
+	filp_close(filp, NULL);
+
+	/* we can't use DSP_SOK here */
+	return 0;
+}
+
+static struct file *cod_f_open(CONST char *psz_file_name, CONST char *pszMode)
+{
+	mm_segment_t fs;
+	struct file *filp;
+
+	fs = get_fs();
+	set_fs(get_ds());
+
+	/* ignore given mode and open file as read-only */
+	filp = filp_open(psz_file_name, O_RDONLY, 0);
+
+	if (IS_ERR(filp))
+		filp = NULL;
+
+	set_fs(fs);
+
+	return filp;
+}
+
+static s32 cod_f_read(void __user *pbuffer, s32 size, s32 cCount,
+		      struct file *filp)
+{
+	/* check for valid file handle */
+	if (!filp)
+		return DSP_EHANDLE;
+
+	if ((size > 0) && (cCount > 0) && pbuffer) {
+		u32 dw_bytes_read;
+		mm_segment_t fs;
+
+		/* read from file */
+		fs = get_fs();
+		set_fs(get_ds());
+		dw_bytes_read = filp->f_op->read(filp, pbuffer, size * cCount,
+						 &(filp->f_pos));
+		set_fs(fs);
+
+		if (!dw_bytes_read)
+			return DSP_EFREAD;
+
+		return dw_bytes_read / size;
+	}
+
+	return DSP_EINVALIDARG;
+}
+
+static s32 cod_f_seek(struct file *filp, s32 lOffset, s32 cOrigin)
+{
+	loff_t dw_cur_pos;
+
+	/* check for valid file handle */
+	if (!filp)
+		return DSP_EHANDLE;
+
+	/* based on the origin flag, move the internal pointer */
+	dw_cur_pos = filp->f_op->llseek(filp, lOffset, cOrigin);
+
+	if ((s32) dw_cur_pos < 0)
+		return DSP_EFAIL;
+
+	/* we can't use DSP_SOK here */
+	return 0;
+}
+
+static s32 cod_f_tell(struct file *filp)
+{
+	loff_t dw_cur_pos;
+
+	if (!filp)
+		return DSP_EHANDLE;
+
+	/* Get current position */
+	dw_cur_pos = filp->f_op->llseek(filp, 0, SEEK_CUR);
+
+	if ((s32) dw_cur_pos < 0)
+		return DSP_EFAIL;
+
+	return dw_cur_pos;
+}
 
 /*
- *  ======== COD_Close ========
+ *  ======== cod_close ========
  */
-void COD_Close(struct COD_LIBRARYOBJ *lib)
+void cod_close(struct cod_libraryobj *lib)
 {
-	struct COD_MANAGER *hMgr;
+	struct cod_manager *hmgr;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(lib != NULL);
-	DBC_Require(IsValid(((struct COD_LIBRARYOBJ *)lib)->hCodMgr));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(lib != NULL);
+	DBC_REQUIRE(IS_VALID(((struct cod_libraryobj *)lib)->cod_mgr));
 
-	hMgr = lib->hCodMgr;
-	hMgr->fxns.closeFxn(lib->dbllLib);
+	hmgr = lib->cod_mgr;
+	hmgr->fxns.close_fxn(lib->dbll_lib);
 
-	MEM_Free(lib);
+	kfree(lib);
 }
 
 /*
- *  ======== COD_Create ========
+ *  ======== cod_create ========
  *  Purpose:
  *      Create an object to manage code on a DSP system.
  *      This object can be used to load an initial program image with
@@ -162,20 +217,16 @@
  *      dynamically loaded object files.
  *
  */
-DSP_STATUS COD_Create(OUT struct COD_MANAGER **phMgr, char *pstrDummyFile,
-		     IN OPTIONAL CONST struct COD_ATTRS *attrs)
+dsp_status cod_create(OUT struct cod_manager **phMgr, char *pstrDummyFile,
+		      IN OPTIONAL CONST struct cod_attrs *attrs)
 {
-	struct COD_MANAGER *hMgrNew;
-	struct DBLL_Attrs zlAttrs;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(phMgr != NULL);
-
-	GT_3trace(COD_debugMask, GT_ENTER,
-		  "Entered COD_Create, Args: \t\nphMgr: "
-		  "0x%x\t\npstrDummyFile: 0x%x\t\nattr: 0x%x\n",
-		  phMgr, pstrDummyFile, attrs);
+	struct cod_manager *mgr_new;
+	struct dbll_attrs zl_attrs;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phMgr != NULL);
+
 	/* assume failure */
 	*phMgr = NULL;
 
@@ -183,132 +234,122 @@
 	if (attrs != NULL)
 		return DSP_ENOTIMPL;
 
-	hMgrNew = MEM_Calloc(sizeof(struct COD_MANAGER), MEM_NONPAGED);
-	if (hMgrNew == NULL) {
-		GT_0trace(COD_debugMask, GT_7CLASS,
-			  "COD_Create: Out Of Memory\n");
+	mgr_new = mem_calloc(sizeof(struct cod_manager), MEM_NONPAGED);
+	if (mgr_new == NULL)
 		return DSP_EMEMORY;
-	}
 
-	hMgrNew->ulMagic = MAGIC;
+	mgr_new->ul_magic = MAGIC;
 
 	/* Set up loader functions */
-	hMgrNew->fxns = dbllFxns;
+	mgr_new->fxns = ldr_fxns;
 
 	/* initialize the ZL module */
-	hMgrNew->fxns.initFxn();
+	mgr_new->fxns.init_fxn();
 
-	zlAttrs.alloc = (DBLL_AllocFxn)NoOp;
-	zlAttrs.free = (DBLL_FreeFxn)NoOp;
-	zlAttrs.fread = (DBLL_ReadFxn)KFILE_Read;
-	zlAttrs.fseek = (DBLL_SeekFxn)KFILE_Seek;
-	zlAttrs.ftell = (DBLL_TellFxn)KFILE_Tell;
-	zlAttrs.fclose = (DBLL_FCloseFxn)KFILE_Close;
-	zlAttrs.fopen = (DBLL_FOpenFxn)KFILE_Open;
-	zlAttrs.symLookup = NULL;
-	zlAttrs.baseImage = true;
-	zlAttrs.logWrite = NULL;
-	zlAttrs.logWriteHandle = NULL;
-	zlAttrs.write = NULL;
-	zlAttrs.rmmHandle = NULL;
-	zlAttrs.wHandle = NULL;
-	zlAttrs.symHandle = NULL;
-	zlAttrs.symArg = NULL;
+	zl_attrs.alloc = (dbll_alloc_fxn) no_op;
+	zl_attrs.free = (dbll_free_fxn) no_op;
+	zl_attrs.fread = (dbll_read_fxn) cod_f_read;
+	zl_attrs.fseek = (dbll_seek_fxn) cod_f_seek;
+	zl_attrs.ftell = (dbll_tell_fxn) cod_f_tell;
+	zl_attrs.fclose = (dbll_f_close_fxn) cod_f_close;
+	zl_attrs.fopen = (dbll_f_open_fxn) cod_f_open;
+	zl_attrs.sym_lookup = NULL;
+	zl_attrs.base_image = true;
+	zl_attrs.log_write = NULL;
+	zl_attrs.log_write_handle = NULL;
+	zl_attrs.write = NULL;
+	zl_attrs.rmm_handle = NULL;
+	zl_attrs.input_params = NULL;
+	zl_attrs.sym_handle = NULL;
+	zl_attrs.sym_arg = NULL;
 
-	hMgrNew->attrs = zlAttrs;
+	mgr_new->attrs = zl_attrs;
 
-	status = hMgrNew->fxns.createFxn(&hMgrNew->target, &zlAttrs);
+	status = mgr_new->fxns.create_fxn(&mgr_new->target, &zl_attrs);
 
 	if (DSP_FAILED(status)) {
-		COD_Delete(hMgrNew);
-		GT_1trace(COD_debugMask, GT_7CLASS,
-			  "COD_Create:ZL Create Failed: 0x%x\n", status);
+		cod_delete(mgr_new);
 		return COD_E_ZLCREATEFAILED;
 	}
 
 	/* return the new manager */
-	*phMgr = hMgrNew;
-	GT_1trace(COD_debugMask, GT_1CLASS,
-		  "COD_Create: Success CodMgr: 0x%x\n",	*phMgr);
+	*phMgr = mgr_new;
+
 	return DSP_SOK;
 }
 
 /*
- *  ======== COD_Delete ========
+ *  ======== cod_delete ========
  *  Purpose:
  *      Delete a code manager object.
  */
-void COD_Delete(struct COD_MANAGER *hMgr)
+void cod_delete(struct cod_manager *hmgr)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hMgr));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(hmgr));
 
-	GT_1trace(COD_debugMask, GT_ENTER, "COD_Delete:hMgr 0x%x\n", hMgr);
-	if (hMgr->baseLib) {
-		if (hMgr->fLoaded)
-			hMgr->fxns.unloadFxn(hMgr->baseLib, &hMgr->attrs);
+	if (hmgr->base_lib) {
+		if (hmgr->loaded)
+			hmgr->fxns.unload_fxn(hmgr->base_lib, &hmgr->attrs);
 
-		hMgr->fxns.closeFxn(hMgr->baseLib);
+		hmgr->fxns.close_fxn(hmgr->base_lib);
 	}
-	if (hMgr->target) {
-		hMgr->fxns.deleteFxn(hMgr->target);
-		hMgr->fxns.exitFxn();
+	if (hmgr->target) {
+		hmgr->fxns.delete_fxn(hmgr->target);
+		hmgr->fxns.exit_fxn();
 	}
-	hMgr->ulMagic = ~MAGIC;
-	MEM_Free(hMgr);
+	hmgr->ul_magic = ~MAGIC;
+	kfree(hmgr);
 }
 
 /*
- *  ======== COD_Exit ========
+ *  ======== cod_exit ========
  *  Purpose:
  *      Discontinue usage of the COD module.
  *
  */
-void COD_Exit(void)
+void cod_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	GT_1trace(COD_debugMask, GT_ENTER,
-		  "Entered COD_Exit, ref count:  0x%x\n", cRefs);
-
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== COD_GetBaseLib ========
+ *  ======== cod_get_base_lib ========
  *  Purpose:
  *      Get handle to the base image DBL library.
  */
-DSP_STATUS COD_GetBaseLib(struct COD_MANAGER *hManager,
-				struct DBLL_LibraryObj **plib)
+dsp_status cod_get_base_lib(struct cod_manager *cod_mgr_obj,
+			    struct dbll_library_obj **plib)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hManager));
-	DBC_Require(plib != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(cod_mgr_obj));
+	DBC_REQUIRE(plib != NULL);
 
-	*plib = (struct DBLL_LibraryObj *) hManager->baseLib;
+	*plib = (struct dbll_library_obj *)cod_mgr_obj->base_lib;
 
 	return status;
 }
 
 /*
- *  ======== COD_GetBaseName ========
+ *  ======== cod_get_base_name ========
  */
-DSP_STATUS COD_GetBaseName(struct COD_MANAGER *hManager, char *pszName,
-				u32 uSize)
+dsp_status cod_get_base_name(struct cod_manager *cod_mgr_obj, char *pszName,
+			     u32 usize)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hManager));
-	DBC_Require(pszName != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(cod_mgr_obj));
+	DBC_REQUIRE(pszName != NULL);
 
-	if (uSize <= COD_MAXPATHLENGTH)
-               strncpy(pszName, hManager->szZLFile, uSize);
+	if (usize <= COD_MAXPATHLENGTH)
+		strncpy(pszName, cod_mgr_obj->sz_zl_file, usize);
 	else
 		status = DSP_EFAIL;
 
@@ -316,160 +357,132 @@
 }
 
 /*
- *  ======== COD_GetEntry ========
+ *  ======== cod_get_entry ========
  *  Purpose:
  *      Retrieve the entry point of a loaded DSP program image
  *
  */
-DSP_STATUS COD_GetEntry(struct COD_MANAGER *hManager, u32 *pulEntry)
+dsp_status cod_get_entry(struct cod_manager *cod_mgr_obj, u32 *pulEntry)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hManager));
-	DBC_Require(pulEntry != NULL);
-
-	*pulEntry = hManager->ulEntry;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(cod_mgr_obj));
+	DBC_REQUIRE(pulEntry != NULL);
 
-	GT_1trace(COD_debugMask, GT_ENTER, "COD_GetEntry:ulEntr 0x%x\n",
-		  *pulEntry);
+	*pulEntry = cod_mgr_obj->ul_entry;
 
 	return DSP_SOK;
 }
 
 /*
- *  ======== COD_GetLoader ========
+ *  ======== cod_get_loader ========
  *  Purpose:
  *      Get handle to the DBLL loader.
  */
-DSP_STATUS COD_GetLoader(struct COD_MANAGER *hManager,
-			       struct DBLL_TarObj **phLoader)
+dsp_status cod_get_loader(struct cod_manager *cod_mgr_obj,
+			  struct dbll_tar_obj **phLoader)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hManager));
-	DBC_Require(phLoader != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(cod_mgr_obj));
+	DBC_REQUIRE(phLoader != NULL);
 
-	*phLoader = (struct DBLL_TarObj *)hManager->target;
+	*phLoader = (struct dbll_tar_obj *)cod_mgr_obj->target;
 
 	return status;
 }
 
 /*
- *  ======== COD_GetSection ========
+ *  ======== cod_get_section ========
  *  Purpose:
  *      Retrieve the starting address and length of a section in the COFF file
  *      given the section name.
  */
-DSP_STATUS COD_GetSection(struct COD_LIBRARYOBJ *lib, IN char *pstrSect,
-			  OUT u32 *puAddr, OUT u32 *puLen)
+dsp_status cod_get_section(struct cod_libraryobj *lib, IN char *pstrSect,
+			   OUT u32 *puAddr, OUT u32 *puLen)
 {
-	struct COD_MANAGER *hManager;
-	DSP_STATUS status = DSP_SOK;
+	struct cod_manager *cod_mgr_obj;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(lib != NULL);
+	DBC_REQUIRE(IS_VALID(lib->cod_mgr));
+	DBC_REQUIRE(pstrSect != NULL);
+	DBC_REQUIRE(puAddr != NULL);
+	DBC_REQUIRE(puLen != NULL);
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(lib != NULL);
-	DBC_Require(IsValid(lib->hCodMgr));
-	DBC_Require(pstrSect != NULL);
-	DBC_Require(puAddr != NULL);
-	DBC_Require(puLen != NULL);
-
-	GT_4trace(COD_debugMask, GT_ENTER,
-		  "Entered COD_GetSection Args \t\n lib: "
-		  "0x%x\t\npstrsect: 0x%x\t\npuAddr: 0x%x\t\npuLen: 0x%x\n",
-		  lib, pstrSect, puAddr, puLen);
 	*puAddr = 0;
 	*puLen = 0;
 	if (lib != NULL) {
-		hManager = lib->hCodMgr;
-		status = hManager->fxns.getSectFxn(lib->dbllLib, pstrSect,
-						   puAddr, puLen);
-		if (DSP_FAILED(status)) {
-			GT_1trace(COD_debugMask, GT_7CLASS,
-				 "COD_GetSection: Section %s not"
-				 "found\n", pstrSect);
-		}
+		cod_mgr_obj = lib->cod_mgr;
+		status = cod_mgr_obj->fxns.get_sect_fxn(lib->dbll_lib, pstrSect,
+							puAddr, puLen);
 	} else {
 		status = COD_E_NOSYMBOLSLOADED;
-		GT_0trace(COD_debugMask, GT_7CLASS,
-			  "COD_GetSection:No Symbols loaded\n");
 	}
 
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((*puAddr == 0) && (*puLen == 0)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((*puAddr == 0) && (*puLen == 0)));
 
 	return status;
 }
 
 /*
- *  ======== COD_GetSymValue ========
+ *  ======== cod_get_sym_value ========
  *  Purpose:
  *      Retrieve the value for the specified symbol. The symbol is first
  *      searched for literally and then, if not found, searched for as a
  *      C symbol.
  *
  */
-DSP_STATUS COD_GetSymValue(struct COD_MANAGER *hMgr, char *pstrSym,
-			   u32 *pulValue)
+dsp_status cod_get_sym_value(struct cod_manager *hmgr, char *pstrSym,
+			     u32 *pul_value)
 {
-	struct DBLL_Symbol *pSym;
+	struct dbll_sym_val *dbll_sym;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hMgr));
-	DBC_Require(pstrSym != NULL);
-	DBC_Require(pulValue != NULL);
-
-	GT_3trace(COD_debugMask, GT_ENTER, "Entered COD_GetSymValue Args \t\n"
-		  "hMgr: 0x%x\t\npstrSym: 0x%x\t\npulValue: 0x%x\n",
-		  hMgr, pstrSym, pulValue);
-	if (hMgr->baseLib) {
-		if (!hMgr->fxns.getAddrFxn(hMgr->baseLib, pstrSym, &pSym)) {
-			if (!hMgr->fxns.getCAddrFxn(hMgr->baseLib, pstrSym,
-			    &pSym)) {
-				GT_0trace(COD_debugMask, GT_7CLASS,
-					  "COD_GetSymValue: "
-					  "Symbols not found\n");
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(hmgr));
+	DBC_REQUIRE(pstrSym != NULL);
+	DBC_REQUIRE(pul_value != NULL);
+
+	dev_dbg(bridge, "%s: hmgr: %p pstrSym: %s pul_value: %p\n",
+		__func__, hmgr, pstrSym, pul_value);
+	if (hmgr->base_lib) {
+		if (!hmgr->fxns.
+		    get_addr_fxn(hmgr->base_lib, pstrSym, &dbll_sym)) {
+			if (!hmgr->fxns.
+			    get_c_addr_fxn(hmgr->base_lib, pstrSym, &dbll_sym))
 				return COD_E_SYMBOLNOTFOUND;
-			}
 		}
 	} else {
-		GT_0trace(COD_debugMask, GT_7CLASS, "COD_GetSymValue: "
-			 "No Symbols loaded\n");
 		return COD_E_NOSYMBOLSLOADED;
 	}
 
-	*pulValue = pSym->value;
+	*pul_value = dbll_sym->value;
 
 	return DSP_SOK;
 }
 
 /*
- *  ======== COD_Init ========
+ *  ======== cod_init ========
  *  Purpose:
  *      Initialize the COD module's private state.
  *
  */
-bool COD_Init(void)
+bool cod_init(void)
 {
-	bool fRetVal = true;
-
-	DBC_Require(cRefs >= 0);
+	bool ret = true;
 
-	if (cRefs == 0) {
-		DBC_Assert(!COD_debugMask.flags);
-		GT_create(&COD_debugMask, "CO");
-	}
-
-	if (fRetVal)
-		cRefs++;
+	DBC_REQUIRE(refs >= 0);
 
+	if (ret)
+		refs++;
 
-	GT_1trace(COD_debugMask, GT_1CLASS,
-		  "Entered COD_Init, ref count: 0x%x\n", cRefs);
-	DBC_Ensure((fRetVal && cRefs > 0) || (!fRetVal && cRefs >= 0));
-	return fRetVal;
+	DBC_ENSURE((ret && refs > 0) || (!ret && refs >= 0));
+	return ret;
 }
 
 /*
- *  ======== COD_LoadBase ========
+ *  ======== cod_load_base ========
  *  Purpose:
  *      Load the initial program image, optionally with command-line arguments,
  *      on the DSP system managed by the supplied handle. The program to be
@@ -481,28 +494,23 @@
  *      recalculated to reflect this.  In this way, we can support NULL
  *      terminating aArgs arrays, if nArgc is very large.
  */
-DSP_STATUS COD_LoadBase(struct COD_MANAGER *hMgr, u32 nArgc, char *aArgs[],
-			COD_WRITEFXN pfnWrite, void *pArb, char *envp[])
+dsp_status cod_load_base(struct cod_manager *hmgr, u32 nArgc, char *aArgs[],
+			 cod_writefxn pfn_write, void *pArb, char *envp[])
 {
-	DBLL_Flags flags;
-	struct DBLL_Attrs saveAttrs;
-	struct DBLL_Attrs newAttrs;
-	DSP_STATUS status;
+	dbll_flags flags;
+	struct dbll_attrs save_attrs;
+	struct dbll_attrs new_attrs;
+	dsp_status status;
 	u32 i;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hMgr));
-	DBC_Require(nArgc > 0);
-	DBC_Require(aArgs != NULL);
-	DBC_Require(aArgs[0] != NULL);
-	DBC_Require(pfnWrite != NULL);
-	DBC_Require(hMgr->baseLib != NULL);
-
-	GT_6trace(COD_debugMask, GT_ENTER,
-		 "Entered COD_LoadBase, hMgr:  0x%x\n \t"
-		 "nArgc:  0x%x\n\taArgs:  0x%x\n\tpfnWrite:  0x%x\n\tpArb:"
-		 " 0x%x\n \tenvp:  0x%x\n", hMgr, nArgc, aArgs, pfnWrite,
-		 pArb, envp);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(hmgr));
+	DBC_REQUIRE(nArgc > 0);
+	DBC_REQUIRE(aArgs != NULL);
+	DBC_REQUIRE(aArgs[0] != NULL);
+	DBC_REQUIRE(pfn_write != NULL);
+	DBC_REQUIRE(hmgr->base_lib != NULL);
+
 	/*
 	 *  Make sure every argv[] stated in argc has a value, or change argc to
 	 *  reflect true number in NULL terminated argv array.
@@ -515,170 +523,138 @@
 	}
 
 	/* set the write function for this operation */
-	hMgr->fxns.getAttrsFxn(hMgr->target, &saveAttrs);
+	hmgr->fxns.get_attrs_fxn(hmgr->target, &save_attrs);
 
-	newAttrs = saveAttrs;
-	newAttrs.write = (DBLL_WriteFxn)pfnWrite;
-	newAttrs.wHandle = pArb;
-	newAttrs.alloc = (DBLL_AllocFxn)NoOp;
-	newAttrs.free = (DBLL_FreeFxn)NoOp;
-	newAttrs.logWrite = NULL;
-	newAttrs.logWriteHandle = NULL;
+	new_attrs = save_attrs;
+	new_attrs.write = (dbll_write_fxn) pfn_write;
+	new_attrs.input_params = pArb;
+	new_attrs.alloc = (dbll_alloc_fxn) no_op;
+	new_attrs.free = (dbll_free_fxn) no_op;
+	new_attrs.log_write = NULL;
+	new_attrs.log_write_handle = NULL;
 
 	/* Load the image */
 	flags = DBLL_CODE | DBLL_DATA | DBLL_SYMB;
-	status = hMgr->fxns.loadFxn(hMgr->baseLib, flags, &newAttrs,
-		 &hMgr->ulEntry);
-	if (DSP_FAILED(status)) {
-		hMgr->fxns.closeFxn(hMgr->baseLib);
-		GT_1trace(COD_debugMask, GT_7CLASS,
-			  "COD_LoadBase: COD Load failed: "
-			  "0x%x\n", status);
-	}
+	status = hmgr->fxns.load_fxn(hmgr->base_lib, flags, &new_attrs,
+				     &hmgr->ul_entry);
+	if (DSP_FAILED(status))
+		hmgr->fxns.close_fxn(hmgr->base_lib);
+
 	if (DSP_SUCCEEDED(status))
-		hMgr->fLoaded = true;
+		hmgr->loaded = true;
 	else
-		hMgr->baseLib = NULL;
+		hmgr->base_lib = NULL;
 
 	return status;
 }
 
 /*
- *  ======== COD_Open ========
+ *  ======== cod_open ========
  *      Open library for reading sections.
  */
-DSP_STATUS COD_Open(struct COD_MANAGER *hMgr, IN char *pszCoffPath,
-		    COD_FLAGS flags, struct COD_LIBRARYOBJ **pLib)
+dsp_status cod_open(struct cod_manager *hmgr, IN char *pszCoffPath,
+		    cod_flags flags, struct cod_libraryobj **pLib)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct COD_LIBRARYOBJ *lib = NULL;
+	dsp_status status = DSP_SOK;
+	struct cod_libraryobj *lib = NULL;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hMgr));
-	DBC_Require(pszCoffPath != NULL);
-	DBC_Require(flags == COD_NOLOAD || flags == COD_SYMB);
-	DBC_Require(pLib != NULL);
-
-	GT_4trace(COD_debugMask, GT_ENTER, "Entered COD_Open, hMgr: 0x%x\n\t "
-		  "pszCoffPath:  0x%x\tflags: 0x%x\tlib: 0x%x\n", hMgr,
-		  pszCoffPath, flags, pLib);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(hmgr));
+	DBC_REQUIRE(pszCoffPath != NULL);
+	DBC_REQUIRE(flags == COD_NOLOAD || flags == COD_SYMB);
+	DBC_REQUIRE(pLib != NULL);
 
 	*pLib = NULL;
 
-	lib = MEM_Calloc(sizeof(struct COD_LIBRARYOBJ), MEM_NONPAGED);
-	if (lib == NULL) {
-		GT_0trace(COD_debugMask, GT_7CLASS,
-			 "COD_Open: Out Of Memory\n");
+	lib = mem_calloc(sizeof(struct cod_libraryobj), MEM_NONPAGED);
+	if (lib == NULL)
 		status = DSP_EMEMORY;
-	}
 
 	if (DSP_SUCCEEDED(status)) {
-		lib->hCodMgr = hMgr;
-		status = hMgr->fxns.openFxn(hMgr->target, pszCoffPath, flags,
-					   &lib->dbllLib);
-		if (DSP_FAILED(status)) {
-			GT_1trace(COD_debugMask, GT_7CLASS,
-				 "COD_Open failed: 0x%x\n", status);
-		} else {
+		lib->cod_mgr = hmgr;
+		status = hmgr->fxns.open_fxn(hmgr->target, pszCoffPath, flags,
+					     &lib->dbll_lib);
+		if (DSP_SUCCEEDED(status))
 			*pLib = lib;
-		}
 	}
 
+	if (DSP_FAILED(status))
+		pr_err("%s: error status 0x%x, pszCoffPath: %s flags: 0x%x\n",
+		       __func__, status, pszCoffPath, flags);
 	return status;
 }
 
 /*
- *  ======== COD_OpenBase ========
+ *  ======== cod_open_base ========
  *  Purpose:
  *      Open base image for reading sections.
  */
-DSP_STATUS COD_OpenBase(struct COD_MANAGER *hMgr, IN char *pszCoffPath,
-			DBLL_Flags flags)
+dsp_status cod_open_base(struct cod_manager *hmgr, IN char *pszCoffPath,
+			 dbll_flags flags)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DBLL_LibraryObj *lib;
+	dsp_status status = DSP_SOK;
+	struct dbll_library_obj *lib;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValid(hMgr));
-	DBC_Require(pszCoffPath != NULL);
-
-	GT_2trace(COD_debugMask, GT_ENTER,
-		  "Entered COD_OpenBase, hMgr:  0x%x\n\t"
-		  "pszCoffPath:  0x%x\n", hMgr, pszCoffPath);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID(hmgr));
+	DBC_REQUIRE(pszCoffPath != NULL);
 
 	/* if we previously opened a base image, close it now */
-	if (hMgr->baseLib) {
-		if (hMgr->fLoaded) {
-			GT_0trace(COD_debugMask, GT_7CLASS,
-				 "Base Image is already loaded. "
-				 "Unloading it...\n");
-			hMgr->fxns.unloadFxn(hMgr->baseLib, &hMgr->attrs);
-			hMgr->fLoaded = false;
+	if (hmgr->base_lib) {
+		if (hmgr->loaded) {
+			hmgr->fxns.unload_fxn(hmgr->base_lib, &hmgr->attrs);
+			hmgr->loaded = false;
 		}
-		hMgr->fxns.closeFxn(hMgr->baseLib);
-		hMgr->baseLib = NULL;
-	} else {
-		GT_0trace(COD_debugMask, GT_1CLASS,
-			 "COD_OpenBase: Opening the base image ...\n");
+		hmgr->fxns.close_fxn(hmgr->base_lib);
+		hmgr->base_lib = NULL;
 	}
-	status = hMgr->fxns.openFxn(hMgr->target, pszCoffPath, flags, &lib);
-	if (DSP_FAILED(status)) {
-		GT_0trace(COD_debugMask, GT_7CLASS,
-			 "COD_OpenBase: COD Open failed\n");
-	} else {
+	status = hmgr->fxns.open_fxn(hmgr->target, pszCoffPath, flags, &lib);
+	if (DSP_SUCCEEDED(status)) {
 		/* hang onto the library for subsequent sym table usage */
-		hMgr->baseLib = lib;
-		strncpy(hMgr->szZLFile, pszCoffPath, COD_MAXPATHLENGTH - 1);
-		hMgr->szZLFile[COD_MAXPATHLENGTH - 1] = '\0';
+		hmgr->base_lib = lib;
+		strncpy(hmgr->sz_zl_file, pszCoffPath, COD_MAXPATHLENGTH - 1);
+		hmgr->sz_zl_file[COD_MAXPATHLENGTH - 1] = '\0';
 	}
 
+	if (DSP_FAILED(status))
+		pr_err("%s: error status 0x%x pszCoffPath: %s\n", __func__,
+		       status, pszCoffPath);
 	return status;
 }
 
 /*
- *  ======== COD_ReadSection ========
+ *  ======== cod_read_section ========
  *  Purpose:
  *      Retrieve the content of a code section given the section name.
  */
-DSP_STATUS COD_ReadSection(struct COD_LIBRARYOBJ *lib, IN char *pstrSect,
-			   OUT char *pstrContent, IN u32 cContentSize)
+dsp_status cod_read_section(struct cod_libraryobj *lib, IN char *pstrSect,
+			    OUT char *pstrContent, IN u32 cContentSize)
 {
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(lib != NULL);
-	DBC_Require(IsValid(lib->hCodMgr));
-	DBC_Require(pstrSect != NULL);
-	DBC_Require(pstrContent != NULL);
-
-	GT_4trace(COD_debugMask, GT_ENTER, "Entered COD_ReadSection Args: 0x%x,"
-		 " 0x%x, 0x%x, 0x%x\n", lib, pstrSect, pstrContent,
-		 cContentSize);
+	dsp_status status = DSP_SOK;
 
-	if (lib != NULL) {
-		status = lib->hCodMgr->fxns.readSectFxn(lib->dbllLib, pstrSect,
-							pstrContent,
-							cContentSize);
-		if (DSP_FAILED(status)) {
-			GT_1trace(COD_debugMask, GT_7CLASS,
-				 "COD_ReadSection failed: 0x%lx\n", status);
-		}
-	} else {
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(lib != NULL);
+	DBC_REQUIRE(IS_VALID(lib->cod_mgr));
+	DBC_REQUIRE(pstrSect != NULL);
+	DBC_REQUIRE(pstrContent != NULL);
+
+	if (lib != NULL)
+		status =
+		    lib->cod_mgr->fxns.read_sect_fxn(lib->dbll_lib, pstrSect,
+						     pstrContent, cContentSize);
+	else
 		status = COD_E_NOSYMBOLSLOADED;
-		GT_0trace(COD_debugMask, GT_7CLASS,
-			  "COD_ReadSection: No Symbols loaded\n");
-	}
+
 	return status;
 }
 
 /*
- *  ======== NoOp ========
+ *  ======== no_op ========
  *  Purpose:
  *      No Operation.
  *
  */
-static bool NoOp(void)
+static bool no_op(void)
 {
 	return true;
 }
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/dbl.c kernel-power-2.6.28.new/drivers/dsp/bridge/pmgr/dbl.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/dbl.c	2011-10-11 13:51:00.541076215 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/pmgr/dbl.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1385 +0,0 @@
-/*
- * dbl.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dbl.c ========
- *  Dynamic BOF Loader library. Contains functions related to
- *  loading and unloading symbols/code/data on DSP.
- *  Also contains other support functions.
- *
- *! Revision History
- *! ================
- *! 24-Feb-2003 swa 	PMGR Code review comments incorporated.
- *! 24-May-2002 jeh     Free DCD sects in DBL_close().
- *! 19-Mar-2002 jeh     Changes made to match dynamic loader (dbll.c): Pass
- *!		     DBL_Library to DBL_getAddr() instead of DBL_Target,
- *!		     eliminate scope param, use DBL_Symbol. Pass attrs to
- *!		     DBL_load(), DBL_unload().
- *! 20-Nov-2001 jeh     Removed DBL_loadArgs().
- *! 07-Sep-2001 jeh     Added overlay support.
- *! 31-Jul-2001 jeh     Include windows.h.
- *! 06-Jun-2001 jeh     Created.
- */
-
-/*  ----------------------------------- Host OS */
-#include <dspbridge/host_os.h>
-
-/*  ----------------------------------- DSP/BIOS Bridge */
-#include <dspbridge/std.h>
-#include <dspbridge/dbdefs.h>
-#include <dspbridge/errbase.h>
-
-/*  ----------------------------------- Trace & Debug */
-#include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
-
-/*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
-#include <dspbridge/mem.h>
-#include <dspbridge/kfile.h>
-
-/*  ----------------------------------- This */
-#include <dspbridge/dbof.h>
-#include <dspbridge/dbl.h>
-
-#define DBL_TARGSIGNATURE      0x544c4244	/* "TLBD" */
-#define DBL_LIBSIGNATURE       0x4c4c4244	/* "LLBD" */
-
-#define C54TARG	 0
-#define C55TARG	 1
-#define NUMTARGS	2
-
-#define C54MAGIC	0x98	/* Magic number for TI C54 COF  */
-#define C55MAGIC	0x9c	/* Magic number for LEAD3 (C55) COF  */
-
-/* Three task phases */
-#define CREATEPHASE 0
-#define DELETEPHASE 1
-#define EXECUTEPHASE 2
-#define NONE 3		/* For overlay section with phase not specified */
-
-/* Default load buffer size */
-#define LOADBUFSIZE     0x800
-
-#define SWAPLONG(x) ((((x) << 24) & 0xFF000000) | (((x) << 8) & 0xFF0000L) | \
-		      (((x) >> 8) & 0xFF00L) | (((x) >> 24) & 0xFF))
-
-#define SWAPWORD(x) ((((x) << 8) & 0xFF00) | (((x) >> 8) & 0xFF))
-
-/*
- *  Macros for accessing the following types of overlay data within a
- *  structure of type OvlyData:
- *      - Overlay data not associated with a particular phase
- *      - Create phase overlay data
- *      - Delete phase overlay data
- *      - Execute phase overlay data
- */
-#define numOtherSects(pOvlyData)    ((pOvlyData)->hdr.dbofHdr.numOtherSects)
-#define numCreateSects(pOvlyData)   ((pOvlyData)->hdr.dbofHdr.numCreateSects)
-#define numDeleteSects(pOvlyData)   ((pOvlyData)->hdr.dbofHdr.numDeleteSects)
-#define numExecuteSects(pOvlyData)  ((pOvlyData)->hdr.dbofHdr.numExecuteSects)
-#define otherOffset(pOvlyData)      0
-#define createOffset(pOvlyData)     ((pOvlyData)->hdr.dbofHdr.numOtherSects)
-#define deleteOffset(pOvlyData)     (createOffset(pOvlyData) + \
-				     (pOvlyData->hdr.dbofHdr.numCreateSects))
-#define executeOffset(pOvlyData)    (deleteOffset(pOvlyData) + \
-				     (pOvlyData->hdr.dbofHdr.numDeleteSects))
-/*
- *  ======== OvlyHdr ========
- */
-struct OvlyHdr {
-	struct DBOF_OvlySectHdr dbofHdr;
-	char *pName; 		/* Name of overlay section */
-	u16 createRef; 	/* Reference count for create phase */
-	u16 deleteRef; 	/* Reference count for delete phase */
-	u16 executeRef; 	/* Execute phase ref count */
-	u16 otherRef; 		/* Unspecified phase ref count */
-} ;
-
-/*
- *  ======== OvlyData ========
- */
-struct OvlyData {
-	struct OvlyHdr hdr;
-	struct DBOF_OvlySectData data[1];
-} ;
-
-/*
- *  ======== Symbol ========
- */
-struct Symbol {
-	struct DBL_Symbol sym;
-	char *pSymName;
-};
-
-/*
- *  ======== DCDSect ========
- */
-struct DCDSect {
-	struct DBOF_DCDSectHdr sectHdr;
-	char *pData;
-} ;
-
-/*
- *  ======== DBL_TargetObj ========
- */
-struct DBL_TargetObj {
-	u32 dwSignature; 	/* For object validation */
-	struct DBL_Attrs dblAttrs; 	/* file read, write, etc. functions */
-	char *pBuf; 		/* Load buffer */
-};
-
-/*
- *  ======== TargetInfo ========
- */
-struct TargetInfo {
-	u16 dspType; 		/* eg, C54TARG, C55TARG */
-	u32 magic; 		/* COFF magic number, identifies target type */
-	u16 wordSize; 	/* Size of a DSP word */
-	u16 mauSize; 		/* Size of minimum addressable unit */
-	u16 charSize; 	/* For C55x, mausize = 1, but charsize = 2 */
-} ;
-
-/*
- *  ======== DBL_LibraryObj ========
- *  Represents a library loaded on a target.
- */
-struct DBL_LibraryObj {
-	u32 dwSignature; 	/* For object validation */
-	struct DBL_TargetObj *pTarget; 	/* Target for this library */
-	struct KFILE_FileObj *file; 	/* DBOF file handle */
-	bool byteSwapped; 	/* Are bytes swapped? */
-	struct DBOF_FileHdr fileHdr; 	/* Header of DBOF file */
-	u16 nSymbols; 		/* Number of DSP/Bridge symbols */
-	struct Symbol *symbols; 	/* Table of DSP/Bridge symbols */
-	u16 nDCDSects; 	/* Number of DCD sections */
-	u16 nOvlySects; 	/* Number of overlay nodes */
-	struct DCDSect *dcdSects; 	/* DCD section data */
-	struct OvlyData **ppOvlyData; 	/* Array of overlay section data */
-	struct TargetInfo *pTargetInfo; 	/* Entry in targetTab[] below */
-} ;
-
-#if GT_TRACE
-static struct GT_Mask DBL_debugMask = { NULL, NULL }; 	/* GT trace variable */
-#endif
-
-static u32 cRefs; 		/* module reference count */
-
-static u32 magicTab[NUMTARGS] = { C54MAGIC, C55MAGIC };
-
-static struct TargetInfo targetTab[] = {
-	/* targ     magic       wordsize    mausize    charsize */
-	{C54TARG, C54MAGIC, 2, 2, 2}, 	/* C54  */
-	{C55TARG, C55MAGIC, 2, 1, 2}, 	/* C55  */
-};
-
-static void freeSects(struct DBL_TargetObj *dbl, struct OvlyData *pOvlyData,
-		     s32 offset, s32 nSects);
-static DSP_STATUS loadSect(struct DBL_TargetObj *dbl,
-			  struct DBL_LibraryObj *pdblLib);
-static DSP_STATUS readDCDSects(struct DBL_TargetObj *dbl,
-			      struct DBL_LibraryObj *pdblLib);
-static DSP_STATUS readHeader(struct DBL_TargetObj *dbl,
-			    struct DBL_LibraryObj *pdblLib);
-static DSP_STATUS readOvlySects(struct DBL_TargetObj *dbl,
-				struct DBL_LibraryObj *pdblLib);
-static DSP_STATUS readSymbols(struct DBL_TargetObj *dbl,
-			     struct DBL_LibraryObj *pdblLib);
-
-/*
- *  ======== DBL_close ========
- *  Purpose:
- *  	Close library opened with DBL_open.
- */
-void DBL_close(struct DBL_LibraryObj *lib)
-{
-	struct DBL_LibraryObj *pdblLib = (struct DBL_LibraryObj *)lib;
-	u16 i;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(pdblLib, DBL_LIBSIGNATURE));
-
-	GT_1trace(DBL_debugMask, GT_ENTER, "DBL_close: lib: 0x%x\n", lib);
-
-	/* Free symbols */
-	if (pdblLib->symbols) {
-		for (i = 0; i < pdblLib->nSymbols; i++) {
-			if (pdblLib->symbols[i].pSymName)
-				MEM_Free(pdblLib->symbols[i].pSymName);
-
-		}
-		MEM_Free(pdblLib->symbols);
-	}
-
-	/* Free DCD sects */
-	if (pdblLib->dcdSects) {
-		for (i = 0; i < pdblLib->nDCDSects; i++) {
-			if (pdblLib->dcdSects[i].pData)
-				MEM_Free(pdblLib->dcdSects[i].pData);
-
-		}
-		MEM_Free(pdblLib->dcdSects);
-	}
-
-	/* Free overlay sects */
-	if (pdblLib->ppOvlyData) {
-		for (i = 0;  i < pdblLib->nOvlySects;  i++) {
-			if (pdblLib->ppOvlyData[i]) {
-				if (pdblLib->ppOvlyData[i]->hdr.pName) {
-					MEM_Free(pdblLib->ppOvlyData[i]->
-						hdr.pName);
-				}
-				MEM_Free(pdblLib->ppOvlyData[i]);
-			}
-		}
-		MEM_Free(pdblLib->ppOvlyData);
-	}
-
-	/* Close the file */
-	if (pdblLib->file)
-		(*pdblLib->pTarget->dblAttrs.fclose) (pdblLib->file);
-
-
-	MEM_FreeObject(pdblLib);
-}
-
-/*
- *  ======== DBL_create ========
- *  Purpose:
- *  	Create a target object by specifying the alloc, free, and
- *  	write functions for the target.
- */
-DSP_STATUS DBL_create(struct DBL_TargetObj **pTarget, struct DBL_Attrs *pAttrs)
-{
-	struct DBL_TargetObj *pdblTarget = NULL;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pAttrs != NULL);
-	DBC_Require(pTarget != NULL);
-
-	GT_2trace(DBL_debugMask, GT_ENTER,
-		 "DBL_create: pTarget: 0x%x pAttrs: 0x%x\n",
-		 pTarget, pAttrs);
-	/* Allocate DBL target object */
-	MEM_AllocObject(pdblTarget, struct DBL_TargetObj, DBL_TARGSIGNATURE);
-	if (pdblTarget == NULL) {
-		GT_0trace(DBL_debugMask, GT_6CLASS,
-			 "DBL_create: Memory allocation failed\n");
-		status = DSP_EMEMORY;
-	} else {
-		pdblTarget->dblAttrs = *pAttrs;
-		/* Allocate buffer for loading target */
-		pdblTarget->pBuf = MEM_Calloc(LOADBUFSIZE, MEM_PAGED);
-		if (pdblTarget->pBuf == NULL)
-			status = DSP_EMEMORY;
-
-	}
-	if (DSP_SUCCEEDED(status)) {
-		*pTarget = pdblTarget;
-	} else {
-		*pTarget = NULL;
-		if (pdblTarget)
-			DBL_delete(pdblTarget);
-
-	}
-	DBC_Ensure(DSP_SUCCEEDED(status) &&
-		  ((MEM_IsValidHandle((*pTarget), DBL_TARGSIGNATURE)) ||
-		  (DSP_FAILED(status) && *pTarget == NULL)));
-	return status;
-}
-
-/*
- *  ======== DBL_delete ========
- *  Purpose:
- *  	Delete target object and free resources for any loaded libraries.
- */
-void DBL_delete(struct DBL_TargetObj *target)
-{
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(target, DBL_TARGSIGNATURE));
-
-	GT_1trace(DBL_debugMask, GT_ENTER,
-		 "DBL_delete: target: 0x%x\n", target);
-
-	if (target->pBuf)
-		MEM_Free(target->pBuf);
-
-	MEM_FreeObject(target);
-}
-
-/*
- *  ======== DBL_exit ========
- *  Purpose
- *  	Discontinue usage of DBL module.
- */
-void DBL_exit()
-{
-	DBC_Require(cRefs > 0);
-	cRefs--;
-	GT_1trace(DBL_debugMask, GT_5CLASS,
-		 "DBL_exit() ref count: 0x%x\n", cRefs);
-	DBC_Ensure(cRefs >= 0);
-}
-
-/*
- *  ======== DBL_getAddr ========
- *  Purpose:
- *  	Get address of name in the specified library.
- */
-bool DBL_getAddr(struct DBL_LibraryObj *lib, char *name,
-		struct DBL_Symbol **ppSym)
-{
-	bool retVal = false;
-	struct Symbol *symbol;
-	u16 i;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(lib, DBL_LIBSIGNATURE));
-	DBC_Require(name != NULL);
-	DBC_Require(ppSym != NULL);
-
-	GT_3trace(DBL_debugMask, GT_ENTER,
-		 "DBL_getAddr: libt: 0x%x name: %s pAddr: "
-		 "0x%x\n", lib, name, ppSym);
-	for (i = 0; i < lib->nSymbols; i++) {
-		symbol = &lib->symbols[i];
-		if (CSL_Strcmp(name, symbol->pSymName) == 0) {
-			/* Found it */
-			*ppSym = &lib->symbols[i].sym;
-			retVal = true;
-			break;
-		}
-	}
-	return retVal;
-}
-
-/*
- *  ======== DBL_getAttrs ========
- *  Purpose:
- *  	Retrieve the attributes of the target.
- */
-void DBL_getAttrs(struct DBL_TargetObj *target, struct DBL_Attrs *pAttrs)
-{
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(target, DBL_TARGSIGNATURE));
-	DBC_Require(pAttrs != NULL);
-	GT_2trace(DBL_debugMask, GT_ENTER, "DBL_getAttrs: target: 0x%x pAttrs: "
-		  "0x%x\n", target, pAttrs);
-	*pAttrs = target->dblAttrs;
-}
-
-/*
- *  ======== DBL_getCAddr ========
- *  Purpose:
- *  	Get address of "C" name in the specified library.
- */
-bool DBL_getCAddr(struct DBL_LibraryObj *lib, char *name,
-		 struct DBL_Symbol **ppSym)
-{
-	bool retVal = false;
-	struct Symbol *symbol;
-	u16 i;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(lib, DBL_LIBSIGNATURE));
-	DBC_Require(name != NULL);
-	DBC_Require(ppSym != NULL);
-
-	GT_3trace(DBL_debugMask, GT_ENTER,
-		 "DBL_getCAddr: target: 0x%x name:%s pAddr:"
-		 " 0x%x\n", lib, name, ppSym);
-	for (i = 0;  i < lib->nSymbols;  i++) {
-		symbol = &lib->symbols[i];
-		if ((CSL_Strcmp(name, symbol->pSymName) == 0) ||
-		    (CSL_Strcmp(name, symbol->pSymName + 1) == 0 &&
-		     symbol->pSymName[0] == '_')) {
-			/* Found it */
-			*ppSym = &lib->symbols[i].sym;
-			retVal = true;
-			break;
-		}
-	}
-	return retVal;
-}
-
-/*
- *  ======== DBL_getEntry ========
- *  Purpose:
- *  	Get program entry point.
- *
- */
-bool DBL_getEntry(struct DBL_LibraryObj *lib, u32 *pEntry)
-{
-	struct DBL_LibraryObj *pdblLib = (struct DBL_LibraryObj *)lib;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(pdblLib, DBL_LIBSIGNATURE));
-	DBC_Require(pEntry != NULL);
-
-	GT_2trace(DBL_debugMask, GT_ENTER,
-		 "DBL_getEntry: lib: 0x%x pEntry: 0x%x\n", lib, pEntry);
-	*pEntry = pdblLib->fileHdr.entry;
-
-	return true;
-}
-
-/*
- *  ======== DBL_getSect ========
- *  Purpose:
- *  	Get address and size of a named section.
- */
-DSP_STATUS DBL_getSect(struct DBL_LibraryObj *lib, char *name, u32 *pAddr,
-		      u32 *pSize)
-{
-	struct DBL_LibraryObj *pdblLib = (struct DBL_LibraryObj *)lib;
-	u16 i;
-	DSP_STATUS status = DSP_ENOSECT;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(name != NULL);
-	DBC_Require(pAddr != NULL);
-	DBC_Require(pSize != NULL);
-	DBC_Require(MEM_IsValidHandle(pdblLib, DBL_LIBSIGNATURE));
-
-	GT_4trace(DBL_debugMask, GT_ENTER,
-		 "DBL_getSect: lib: 0x%x name: %s pAddr:"
-		 " 0x%x pSize: 0x%x\n", lib, name, pAddr, pSize);
-
-	/*
-	 *  Check for DCD and overlay sections. Overlay loader uses DBL_getSect
-	 *  to determine whether or not a node has overlay sections.
-	 *  DCD section names begin with '.'
-	 */
-	if (name[0] == '.') {
-		/* Get DCD section size (address is 0, since it's a NOLOAD). */
-		for (i = 0; i < pdblLib->nDCDSects; i++) {
-			if (CSL_Strcmp(pdblLib->dcdSects[i].sectHdr.name,
-			   name) == 0) {
-				*pAddr = 0;
-				*pSize = pdblLib->dcdSects[i].sectHdr.size *
-					 pdblLib->pTargetInfo->mauSize;
-				status = DSP_SOK;
-				break;
-			}
-		}
-	} else {
-		/* Check for overlay section */
-		for (i = 0;  i < pdblLib->nOvlySects;  i++) {
-			if (CSL_Strcmp(pdblLib->ppOvlyData[i]->hdr.pName,
-			   name) == 0) {
-				/* Address and size are meaningless */
-				*pAddr = 0;
-				*pSize = 0;
-				status = DSP_SOK;
-				break;
-			}
-		}
-	}
-
-	return status;
-}
-
-/*
- *  ======== DBL_init ========
- *  Purpose:
- *  	Initialize DBL module.
- */
-bool DBL_init(void)
-{
-	bool retVal = true;
-
-	DBC_Require(cRefs >= 0);
-
-	if (cRefs == 0) {
-		DBC_Assert(!DBL_debugMask.flags);
-		GT_create(&DBL_debugMask, "BL"); 	/* "BL" for dBL */
-
-	}
-
-	if (retVal)
-		cRefs++;
-
-
-	GT_1trace(DBL_debugMask, GT_5CLASS, "DBL_init(), ref count:  0x%x\n",
-		  cRefs);
-
-	DBC_Ensure((retVal && (cRefs > 0)) || (!retVal && (cRefs >= 0)));
-
-	return retVal;
-}
-
-/*
- *  ======== DBL_load ========
- *  Purpose:
- *  	Add symbols/code/data defined in file to that already present
- *  	on the target.
- */
-DSP_STATUS DBL_load(struct DBL_LibraryObj *lib, DBL_Flags flags,
-		   struct DBL_Attrs *attrs, u32 *pEntry)
-{
-	struct DBL_LibraryObj *pdblLib = (struct DBL_LibraryObj *)lib;
-	struct DBL_TargetObj *dbl;
-	u16 i;
-	u16 nSects;
-	DSP_STATUS status = DSP_EFAIL;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(pdblLib, DBL_LIBSIGNATURE));
-	DBC_Require(pEntry != NULL);
-	DBC_Require(attrs != NULL);
-
-	GT_4trace(DBL_debugMask, GT_ENTER, "DBL_load: lib: 0x%x flags: "
-		 "0x%x attrs: 0x%x pEntry: 0x%x\n", lib, flags, attrs, pEntry);
-
-	dbl = pdblLib->pTarget;
-	*pEntry = pdblLib->fileHdr.entry;
-	nSects = pdblLib->fileHdr.numSects;
-	dbl->dblAttrs = *attrs;
-
-	for (i = 0; i < nSects; i++) {
-		/* Load the section at the current file offset */
-		status = loadSect(dbl, lib);
-		if (DSP_FAILED(status))
-			break;
-
-	}
-
-	/* Done with file, we can close it */
-	if (pdblLib->file) {
-		(*pdblLib->pTarget->dblAttrs.fclose) (pdblLib->file);
-		pdblLib->file = NULL;
-	}
-	return status;
-}
-
-/*
- *  ======== DBL_loadSect ========
- *  Purpose:
- *  	Load a named section from an library (for overlay support).
- */
-DSP_STATUS DBL_loadSect(struct DBL_LibraryObj *lib, char *sectName,
-			struct DBL_Attrs *attrs)
-{
-	struct DBL_TargetObj *dbl;
-	s32 i;
-	s32 phase;
-	s32 offset = -1;
-	s32 nSects = -1;
-	s32 allocdSects = 0;
-	u32 loadAddr;
-	u32 runAddr;
-	u32 size;
-	u32 space;
-	u32 ulBytes;
-	u16 mauSize;
-	u16 wordSize;
-	u16 *phaseRef = NULL;
-	u16 *otherRef = NULL;
-	char *name = NULL;
-	struct OvlyData *pOvlyData;
-	DSP_STATUS status = DSP_ENOSECT;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(lib, DBL_LIBSIGNATURE));
-	DBC_Require(sectName != NULL);
-	DBC_Require(attrs != NULL);
-	DBC_Require(attrs->write != NULL);
-	GT_3trace(DBL_debugMask, GT_ENTER,
-		 "DBL_loadSect: lib: 0x%x sectName: %s "
-		 "attrs: 0x%x\n", lib, sectName, attrs);
-	dbl = lib->pTarget;
-	mauSize = lib->pTargetInfo->mauSize;
-	wordSize = lib->pTargetInfo->wordSize;
-	/* Check for match of sect name in overlay table */
-	for (i = 0; i < lib->nOvlySects; i++) {
-		name = lib->ppOvlyData[i]->hdr.pName;
-		if (!CSL_Strncmp(name, sectName, CSL_Strlen(name))) {
-			/* Match found */
-			status = DSP_SOK;
-			break;
-		}
-	}
-	if (DSP_SUCCEEDED(status)) {
-		DBC_Assert(i < lib->nOvlySects);
-		pOvlyData = lib->ppOvlyData[i];
-		/*
-		 *  If node overlay, phase will be encoded in name. If not node
-		 *  overlay, set phase to NONE.
-		 */
-		phase = (CSL_Strcmp(name, sectName)) ?
-			CSL_Atoi(sectName + CSL_Strlen(sectName) - 1) : NONE;
-		 /*  Get reference count of node phase to be loaded, offset into
-		 *  overlay data array, and number of sections to overlay.  */
-		switch (phase) {
-		case NONE:
-			/* Not a node overlay */
-			phaseRef = &pOvlyData->hdr.otherRef;
-			nSects = numOtherSects(pOvlyData);
-			offset = otherOffset(pOvlyData);
-			break;
-		case CREATEPHASE:
-			phaseRef = &pOvlyData->hdr.createRef;
-			otherRef = &pOvlyData->hdr.otherRef;
-			if (*otherRef) {
-				/* The overlay sections where node phase was
-				 * not specified, have already been loaded.  */
-				nSects = numCreateSects(pOvlyData);
-				offset = createOffset(pOvlyData);
-			} else {
-				/* Overlay sections where node phase was not
-				 * specified get loaded at create time, along
-				 * with create sects.  */
-				nSects = numCreateSects(pOvlyData) +
-					 numOtherSects(pOvlyData);
-				offset = otherOffset(pOvlyData);
-			}
-			break;
-		case DELETEPHASE:
-			phaseRef = &pOvlyData->hdr.deleteRef;
-			nSects = numDeleteSects(pOvlyData);
-			offset = deleteOffset(pOvlyData);
-			break;
-		case EXECUTEPHASE:
-			phaseRef = &pOvlyData->hdr.executeRef;
-			nSects = numExecuteSects(pOvlyData);
-			offset = executeOffset(pOvlyData);
-			break;
-		default:
-			/* ERROR */
-			DBC_Assert(false);
-			break;
-		}
-		/* Do overlay if reference count is 0 */
-		if (!(*phaseRef)) {
-			/* "Allocate" all sections */
-			for (i = 0; i < nSects; i++) {
-				runAddr = pOvlyData->data[offset + i].runAddr;
-				size = pOvlyData->data[offset + i].size;
-				space = pOvlyData->data[offset + i].page;
-				status = (dbl->dblAttrs.alloc)(dbl->dblAttrs.
-					 rmmHandle, space, size, 0,
-					 &runAddr, true);
-				if (DSP_FAILED(status))
-					break;
-
-				allocdSects++;
-			}
-			if (DSP_SUCCEEDED(status)) {
-				/* Load sections */
-				for (i = 0; i < nSects; i++) {
-					loadAddr = pOvlyData->data[offset + i].
-						   loadAddr;
-					runAddr = pOvlyData->data[offset + i].
-						  runAddr;
-					size = pOvlyData->data[offset + i].
-						size;
-					space = pOvlyData->data[offset + i].
-						page;
-					/* Convert to word address, call
-					 * write function */
-					loadAddr /= (wordSize / mauSize);
-					runAddr /= (wordSize / mauSize);
-					ulBytes = size * mauSize;
-					if ((*attrs->write)(attrs->wHandle,
-					   runAddr, (void *)loadAddr, ulBytes,
-					   space) != ulBytes) {
-						GT_0trace(DBL_debugMask,
-							GT_6CLASS,
-							"DBL_loadSect: write"
-							" failed\n");
-						status = DSP_EFWRITE;
-						break;
-					}
-				}
-			}
-			/* Free sections on failure */
-			if (DSP_FAILED(status))
-				freeSects(dbl, pOvlyData, offset, allocdSects);
-
-		}
-	}
-	if (DSP_SUCCEEDED(status)) {
-		/* Increment reference counts */
-		if (otherRef)
-			*otherRef = *otherRef + 1;
-
-		*phaseRef = *phaseRef + 1;
-	}
-	return status;
-}
-
-/*
- *  ======== DBL_open ========
- *  Purpose:
- *  	DBL_open() returns a library handle that can be used to
- *  	load/unload the symbols/code/data via DBL_load()/DBL_unload().
- */
-DSP_STATUS DBL_open(struct DBL_TargetObj *target, char *file, DBL_Flags flags,
-		   struct DBL_LibraryObj **pLib)
-{
-	struct DBL_LibraryObj *pdblLib = NULL;
-	u16 nSymbols;
-	u16 nDCDSects;
-	DSP_STATUS status = DSP_SOK;
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(target, DBL_TARGSIGNATURE));
-	DBC_Require(target->dblAttrs.fopen != NULL);
-	DBC_Require(file != NULL);
-	DBC_Require(pLib != NULL);
-
-	GT_3trace(DBL_debugMask, GT_ENTER, "DBL_open: target: 0x%x file: %s "
-		 "pLib: 0x%x\n", target, file, pLib);
-	/* Allocate DBL library object */
-	MEM_AllocObject(pdblLib, struct DBL_LibraryObj, DBL_LIBSIGNATURE);
-	if (pdblLib == NULL)
-		status = DSP_EMEMORY;
-
-	/* Open the file */
-	if (DSP_SUCCEEDED(status)) {
-		pdblLib->pTarget = target;
-		pdblLib->file = (*target->dblAttrs.fopen)(file, "rb");
-		if (pdblLib->file == NULL)
-			status = DSP_EFOPEN;
-
-	}
-	/* Read file header */
-	if (DSP_SUCCEEDED(status)) {
-		status = readHeader(target, pdblLib);
-		if (DSP_FAILED(status)) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "DBL_open(): Failed to read file header\n");
-		}
-	}
-	/* Allocate symbol table */
-	if (DSP_SUCCEEDED(status)) {
-		nSymbols = pdblLib->nSymbols = pdblLib->fileHdr.numSymbols;
-		pdblLib->symbols = MEM_Calloc(nSymbols * sizeof(struct Symbol),
-					     MEM_PAGED);
-		if (pdblLib->symbols == NULL)
-			status = DSP_EMEMORY;
-
-	}
-	/* Read all the symbols */
-	if (DSP_SUCCEEDED(status)) {
-		status = readSymbols(target, pdblLib);
-		if (DSP_FAILED(status)) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "DBL_open(): Failed to read symbols\n");
-		}
-	}
-	/* Allocate DCD sect table */
-	if (DSP_SUCCEEDED(status)) {
-		nDCDSects = pdblLib->nDCDSects = pdblLib->fileHdr.numDCDSects;
-		pdblLib->dcdSects = MEM_Calloc(nDCDSects *
-					 sizeof(struct DCDSect), MEM_PAGED);
-		if (pdblLib->dcdSects == NULL)
-			status = DSP_EMEMORY;
-
-	}
-	/* Read DCD sections */
-	if (DSP_SUCCEEDED(status)) {
-		status = readDCDSects(target, pdblLib);
-		if (DSP_FAILED(status)) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "DBL_open(): Failed to read DCD sections\n");
-		}
-	}
-	/* Read overlay sections */
-	if (DSP_SUCCEEDED(status)) {
-		status = readOvlySects(target, pdblLib);
-		if (DSP_FAILED(status)) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "DBL_open(): Failed to read "
-				 "overlay sections\n");
-		}
-	}
-	if (DSP_FAILED(status)) {
-		*pLib = NULL;
-		if (pdblLib != NULL)
-			DBL_close((struct DBL_LibraryObj *) pdblLib);
-
-	} else {
-		*pLib = pdblLib;
-	}
-	DBC_Ensure((DSP_SUCCEEDED(status) &&
-		  (MEM_IsValidHandle((*pLib), DBL_LIBSIGNATURE))) ||
-		  (DSP_FAILED(status) && *pLib == NULL));
-	return status;
-}
-
-/*
- *  ======== DBL_readSect ========
- *  Purpose:
- *  	Read COFF section into a character buffer.
- */
-DSP_STATUS DBL_readSect(struct DBL_LibraryObj *lib, char *name, char *pContent,
-			u32 size)
-{
-	struct DBL_LibraryObj *pdblLib = (struct DBL_LibraryObj *)lib;
-	u16 i;
-	u32 mauSize;
-	u32 max;
-	DSP_STATUS status = DSP_ENOSECT;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(pdblLib, DBL_LIBSIGNATURE));
-	DBC_Require(name != NULL);
-	DBC_Require(pContent != NULL);
-	DBC_Require(size != 0);
-	GT_4trace(DBL_debugMask, GT_ENTER, "DBL_readSect: lib: 0x%x name: %s "
-		 "pContent: 0x%x size: 0x%x\n", lib, name, pContent, size);
-
-	mauSize = pdblLib->pTargetInfo->mauSize;
-
-	/* Attempt to find match with DCD section names. */
-	for (i = 0; i < pdblLib->nDCDSects; i++) {
-		if (CSL_Strcmp(pdblLib->dcdSects[i].sectHdr.name, name) == 0) {
-			/* Match found */
-			max = pdblLib->dcdSects[i].sectHdr.size * mauSize;
-			max = (max > size) ? size : max;
-			memcpy(pContent, pdblLib->dcdSects[i].pData, max);
-			status = DSP_SOK;
-			break;
-		}
-	}
-
-	return status;
-}
-
-/*
- *  ======== DBL_setAttrs ========
- *  Purpose:
- *  	Set the attributes of the target.
- */
-void DBL_setAttrs(struct DBL_TargetObj *target, struct DBL_Attrs *pAttrs)
-{
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(target, DBL_TARGSIGNATURE));
-	DBC_Require(pAttrs != NULL);
-
-	GT_2trace(DBL_debugMask, GT_ENTER, "DBL_setAttrs: target: 0x%x pAttrs: "
-		 "0x%x\n", target, pAttrs);
-
-	target->dblAttrs = *pAttrs;
-}
-
-/*
- *  ======== DBL_unload ========
- *  Purpose:
- *  	Remove the symbols/code/data corresponding to the library lib.
- */
-void DBL_unload(struct DBL_LibraryObj *lib, struct DBL_Attrs *attrs)
-{
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(lib, DBL_LIBSIGNATURE));
-
-	GT_1trace(DBL_debugMask, GT_ENTER, "DBL_unload: lib: 0x%x\n", lib);
-
-	/* Nothing to do for static loading */
-}
-
-/*
- *  ======== DBL_unloadSect ========
- *  Purpose:
- *  	Unload a named section from an library (for overlay support).
- */
-DSP_STATUS DBL_unloadSect(struct DBL_LibraryObj *lib, char *sectName,
-			  struct DBL_Attrs *attrs)
-{
-	struct DBL_TargetObj *dbl;
-	s32 i;
-	s32 phase;
-	s32 offset = -1;
-	s32 nSects = -1;
-	u16 *phaseRef = NULL;
-	u16 *otherRef = NULL;
-	char *pName = NULL;
-	struct OvlyData *pOvlyData;
-	DSP_STATUS status = DSP_ENOSECT;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(lib, DBL_LIBSIGNATURE));
-	DBC_Require(sectName != NULL);
-
-	GT_2trace(DBL_debugMask, GT_ENTER,
-		 "DBL_unloadSect: lib: 0x%x sectName: %s\n", lib, sectName);
-	dbl = lib->pTarget;
-	/* Check for match of sect name in overlay table */
-	for (i = 0; i < lib->nOvlySects; i++) {
-		pName = lib->ppOvlyData[i]->hdr.pName;
-		if (!CSL_Strncmp(pName, sectName, CSL_Strlen(pName))) {
-			/* Match found */
-			status = DSP_SOK;
-			break;
-		}
-	}
-	if (DSP_SUCCEEDED(status)) {
-		DBC_Assert(i < lib->nOvlySects);
-		pOvlyData = lib->ppOvlyData[i];
-		/* If node overlay, phase will be encoded in name. */
-		phase = (CSL_Strcmp(pName, sectName)) ?
-			CSL_Atoi(sectName + CSL_Strlen(sectName) - 1) : NONE;
-		switch (phase) {
-		case NONE:
-			nSects = numOtherSects(pOvlyData);
-			phaseRef = &pOvlyData->hdr.otherRef;
-			offset = otherOffset(pOvlyData);
-			break;
-		case CREATEPHASE:
-			nSects = numCreateSects(pOvlyData);
-			offset = createOffset(pOvlyData);
-			phaseRef = &pOvlyData->hdr.createRef;
-			break;
-		case DELETEPHASE:
-			nSects = numDeleteSects(pOvlyData);
-			offset = deleteOffset(pOvlyData);
-			phaseRef = &pOvlyData->hdr.deleteRef;
-			otherRef = &pOvlyData->hdr.otherRef;
-			break;
-		case EXECUTEPHASE:
-			nSects = numExecuteSects(pOvlyData);
-			offset = executeOffset(pOvlyData);
-			phaseRef = &pOvlyData->hdr.executeRef;
-			break;
-		default:
-			/* ERROR */
-			DBC_Assert(false);
-			break;
-		}
-		if (*phaseRef) {
-			*phaseRef = *phaseRef - 1;
-			if (*phaseRef == 0) {
-				/* Unload overlay sections for phase */
-				freeSects(dbl, pOvlyData, offset, nSects);
-			}
-			if (phase == DELETEPHASE) {
-				DBC_Assert(*otherRef);
-				*otherRef = *otherRef - 1;
-				if (*otherRef == 0) {
-					/* Unload other overlay sections */
-					nSects = numOtherSects(pOvlyData);
-					offset = otherOffset(pOvlyData);
-					freeSects(dbl, pOvlyData, offset,
-						 nSects);
-				}
-			}
-		}
-	}
-
-	return status;
-}
-
-/*
- *  ======== freeSects ========
- *  Purpose:
- *  	Free section
- */
-static void freeSects(struct DBL_TargetObj *dbl, struct OvlyData *pOvlyData,
-		     s32 offset, s32 nSects)
-{
-	u32 runAddr;
-	u32 size;
-	u32 space;
-	s32 i;
-
-	for (i = 0; i < nSects; i++) {
-		runAddr = pOvlyData->data[offset + i].runAddr;
-		size = pOvlyData->data[offset + i].size;
-		space = pOvlyData->data[offset + i].page;
-		if (!(dbl->dblAttrs.free)
-		    (dbl->dblAttrs.rmmHandle, space, runAddr, size, true)) {
-			/*
-			 *  Free function will not fail for overlay, unless
-			 *  address passed in is bad.
-			 */
-			DBC_Assert(false);
-		}
-	}
-}
-
-/*
- *  ======== loadSect ========
- *  Purpose:
- *  	Load section to target
- */
-static DSP_STATUS loadSect(struct DBL_TargetObj *dbl,
-			  struct DBL_LibraryObj *pdblLib)
-{
-	struct DBOF_SectHdr sectHdr;
-	char *pBuf;
-	struct KFILE_FileObj *file;
-	u32 space;
-	u32 addr;
-	u32 total;
-	u32 nWords = 0;
-	u32 nBytes = 0;
-	u16 mauSize;
-	u32 bufSize;
-	DSP_STATUS status = DSP_SOK;
-
-	file = pdblLib->file;
-	mauSize = pdblLib->pTargetInfo->mauSize;
-	bufSize = LOADBUFSIZE / mauSize;
-	pBuf = dbl->pBuf;
-
-	/* Read the section header */
-	if ((*dbl->dblAttrs.fread)(&sectHdr, sizeof(struct DBOF_SectHdr),
-	   1, file) != 1) {
-		GT_0trace(DBL_debugMask, GT_6CLASS,
-			 "Failed to read DCD sect header\n");
-		status = DSP_EFREAD;
-	} else {
-		if (pdblLib->byteSwapped) {
-			sectHdr.size = SWAPLONG(sectHdr.size);
-			sectHdr.addr = SWAPLONG(sectHdr.addr);
-			sectHdr.page = SWAPWORD(sectHdr.page);
-		}
-	}
-	if (DSP_SUCCEEDED(status)) {
-		addr = sectHdr.addr;
-		space = sectHdr.page;
-		for (total = sectHdr.size; total > 0; total -= nWords) {
-			nWords = min(total, bufSize);
-			nBytes = nWords * mauSize;
-			/* Read section data */
-			if ((*dbl->dblAttrs.fread)(pBuf, nBytes, 1,
-			   file) != 1) {
-				GT_0trace(DBL_debugMask, GT_6CLASS,
-					 "Failed to read DCD sect header\n");
-				status = DSP_EFREAD;
-				break;
-			}
-			/* Write section to target */
-			if (!(*dbl->dblAttrs.write)(dbl->dblAttrs.wHandle,
-			   addr, pBuf, nBytes, space)) {
-				GT_0trace(DBL_debugMask, GT_6CLASS,
-					 "Failed to write section data\n");
-				status = DSP_EFWRITE;
-				break;
-			}
-			addr += nWords;
-		}
-	}
-	return status;
-}
-
-/*
- *  ======== readDCDSects ========
- *  Purpose:
- *  	Read DCD sections.
- */
-static DSP_STATUS readDCDSects(struct DBL_TargetObj *dbl,
-			      struct DBL_LibraryObj *pdblLib)
-{
-	struct DBOF_DCDSectHdr *pSectHdr;
-	struct DCDSect *pSect;
-	struct KFILE_FileObj *file;
-	u16 nSects;
-	u16 i;
-	u16 mauSize;
-	DSP_STATUS status = DSP_SOK;
-
-	file = pdblLib->file;
-	mauSize = pdblLib->pTargetInfo->mauSize;
-	nSects = pdblLib->fileHdr.numDCDSects;
-	for (i = 0; i < nSects; i++) {
-		pSect = &pdblLib->dcdSects[i];
-		pSectHdr = &pdblLib->dcdSects[i].sectHdr;
-		/* Read sect header */
-		if ((*dbl->dblAttrs.fread)(pSectHdr,
-		   sizeof(struct DBOF_DCDSectHdr), 1, file) != 1) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "Failed to read DCD sect header\n");
-			status = DSP_EFREAD;
-			break;
-		}
-		if (pdblLib->byteSwapped)
-			pSectHdr->size = SWAPLONG(pSectHdr->size);
-
-		pSect->pData = (char *)MEM_Calloc(pSectHdr->size *
-				mauSize, MEM_PAGED);
-		if (pSect->pData == NULL) {
-			GT_2trace(DBL_debugMask, GT_6CLASS,
-				 "Memory allocation for sect %s "
-				 "data failed: Size: 0x%lx\n", pSectHdr->name,
-				 pSectHdr->size);
-			status = DSP_EMEMORY;
-			break;
-		}
-		/* Read DCD sect data */
-		if ((*dbl->dblAttrs.fread)(pSect->pData, mauSize,
-		   pSectHdr->size, file) != pSectHdr->size) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				  "Failed to read DCD sect data\n");
-			status = DSP_EFREAD;
-			break;
-		}
-	}
-
-	return status;
-}
-
-/*
- *  ======== readHeader ========
- *  Purpose:
- *  	Read Header.
- */
-static DSP_STATUS readHeader(struct DBL_TargetObj *dbl,
-			    struct DBL_LibraryObj *pdblLib)
-{
-	struct KFILE_FileObj *file;
-	s32 i;
-	struct DBOF_FileHdr *pHdr;
-	u32 swapMagic;
-	DSP_STATUS status = DSP_SOK;
-
-	pdblLib->byteSwapped = false;
-	file = pdblLib->file;
-	pHdr = &pdblLib->fileHdr;
-	if ((*dbl->dblAttrs.fread)(pHdr, sizeof(struct DBOF_FileHdr), 1,
-	   file) != 1) {
-		GT_0trace(DBL_debugMask, GT_6CLASS,
-			 "readHeader: Failed to read file header\n");
-		status = DSP_EFREAD;
-	}
-
-	if (DSP_SUCCEEDED(status)) {
-		/* Determine if byte swapped */
-		for (i = 0; i < NUMTARGS; i++) {
-			swapMagic = SWAPLONG(pHdr->magic);
-			if (pHdr->magic == magicTab[i] || swapMagic ==
-			   magicTab[i]) {
-				if (swapMagic == magicTab[i]) {
-					pdblLib->byteSwapped = true;
-					pHdr->magic = SWAPLONG(pHdr->magic);
-					pHdr->entry = SWAPLONG(pHdr->entry);
-					pHdr->symOffset = SWAPLONG(pHdr->
-								symOffset);
-					pHdr->dcdSectOffset = SWAPLONG(pHdr->
-								dcdSectOffset);
-					pHdr->loadSectOffset = SWAPLONG(pHdr->
-								loadSectOffset);
-					pHdr->ovlySectOffset = SWAPLONG(pHdr->
-								ovlySectOffset);
-					pHdr->numSymbols = SWAPWORD(pHdr->
-								numSymbols);
-					pHdr->numDCDSects = SWAPWORD(pHdr->
-								numDCDSects);
-					pHdr->numSects = SWAPWORD(pHdr->
-								numSects);
-					pHdr->numOvlySects = SWAPWORD(pHdr->
-								numOvlySects);
-				}
-				break;
-			}
-		}
-		if (i == NUMTARGS) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "readHeader: Failed to determine"
-				 " target type\n");
-			status = DSP_ECORRUPTFILE;
-		} else {
-			pdblLib->pTargetInfo = &targetTab[i];
-			GT_1trace(DBL_debugMask, GT_ENTER,
-				 "COF type: 0x%lx\n", pHdr->magic);
-			GT_1trace(DBL_debugMask, GT_ENTER,
-				 "Entry point:0x%lx\n", pHdr->entry);
-		}
-	}
-	return status;
-}
-
-/*
- *  ======== readOvlySects ========
- *  Purpose:
- *  	Read Overlay Sections
- */
-static DSP_STATUS readOvlySects(struct DBL_TargetObj *dbl,
-				struct DBL_LibraryObj *pdblLib)
-{
-	struct DBOF_OvlySectHdr hdr;
-	struct DBOF_OvlySectData *pData;
-	struct OvlyData *pOvlyData;
-	char *pName;
-	struct KFILE_FileObj *file;
-	u16 i, j;
-	u16 nSects;
-	u16 n;
-	DSP_STATUS status = DSP_SOK;
-
-	pdblLib->nOvlySects = nSects = pdblLib->fileHdr.numOvlySects;
-	file = pdblLib->file;
-	if (nSects > 0) {
-		pdblLib->ppOvlyData = MEM_Calloc(nSects * sizeof(OvlyData *),
-						 MEM_PAGED);
-		if (pdblLib->ppOvlyData == NULL) {
-			GT_0trace(DBL_debugMask, GT_7CLASS,
-				 "Failed to allocatate overlay "
-				 "data memory\n");
-			status = DSP_EMEMORY;
-		}
-	}
-	if (DSP_SUCCEEDED(status)) {
-		/* Read overlay data for each node */
-		for (i = 0; i < nSects; i++) {
-			/* Read overlay section header */
-			if ((*dbl->dblAttrs.fread)(&hdr,
-			   sizeof(struct DBOF_OvlySectHdr), 1, file) != 1) {
-				GT_0trace(DBL_debugMask, GT_6CLASS,
-					 "Failed to read overlay sect"
-					 " header\n");
-				status = DSP_EFREAD;
-				break;
-			}
-			if (pdblLib->byteSwapped) {
-				hdr.nameLen = SWAPWORD(hdr.nameLen);
-				hdr.numCreateSects =
-						SWAPWORD(hdr.numCreateSects);
-				hdr.numDeleteSects =
-						SWAPWORD(hdr.numDeleteSects);
-				hdr.numExecuteSects =
-						SWAPWORD(hdr.numExecuteSects);
-				hdr.numOtherSects =
-						SWAPWORD(hdr.numOtherSects);
-				hdr.resvd = SWAPWORD(hdr.resvd);
-			}
-			n = hdr.numCreateSects + hdr.numDeleteSects +
-			    hdr.numExecuteSects + hdr.numOtherSects;
-
-			/* Allocate memory for node's overlay data */
-			pOvlyData = (struct OvlyData *)MEM_Calloc
-				    (sizeof(struct OvlyHdr) +
-				    n * sizeof(struct DBOF_OvlySectData),
-				    MEM_PAGED);
-			if (pOvlyData == NULL) {
-				GT_0trace(DBL_debugMask, GT_7CLASS,
-					 "Failed to allocatate ovlyay"
-					 " data memory\n");
-				status = DSP_EMEMORY;
-				break;
-			}
-			pOvlyData->hdr.dbofHdr = hdr;
-			pdblLib->ppOvlyData[i] = pOvlyData;
-			/* Allocate memory for section name */
-			pName = (char *)MEM_Calloc(hdr.nameLen + 1, MEM_PAGED);
-			if (pName == NULL) {
-				GT_0trace(DBL_debugMask, GT_7CLASS,
-					 "Failed to allocatate ovlyay"
-					 " section name\n");
-				status = DSP_EMEMORY;
-				break;
-			}
-			pOvlyData->hdr.pName = pName;
-			/* Read the overlay section name */
-			if ((*dbl->dblAttrs.fread)(pName, sizeof(char),
-			   hdr.nameLen, file) != hdr.nameLen) {
-				GT_0trace(DBL_debugMask, GT_7CLASS,
-					 "readOvlySects: Unable to "
-					 "read overlay name.\n");
-				status = DSP_EFREAD;
-				break;
-			}
-			/* Read the overlay section data */
-			pData = pOvlyData->data;
-			if ((*dbl->dblAttrs.fread)(pData,
-			   sizeof(struct DBOF_OvlySectData), n, file) != n) {
-				GT_0trace(DBL_debugMask, GT_7CLASS,
-					 "readOvlySects: Unable to "
-					 "read overlay data.\n");
-				status = DSP_EFREAD;
-				break;
-			}
-			/* Swap overlay data, if necessary */
-			if (pdblLib->byteSwapped) {
-				for (j = 0; j < n; j++) {
-					pData[j].loadAddr =
-						 SWAPLONG(pData[j].loadAddr);
-					pData[j].runAddr =
-						 SWAPLONG(pData[j].runAddr);
-					pData[j].size =
-						 SWAPLONG(pData[j].size);
-					pData[j].page =
-						 SWAPWORD(pData[j].page);
-				}
-			}
-		}
-	}
-	return status;
-}
-
-/*
- *  ======== readSymbols ========
- *  Purpose:
- *  	Read Symbols
- */
-static DSP_STATUS readSymbols(struct DBL_TargetObj *dbl,
-			     struct DBL_LibraryObj *pdblLib)
-{
-	struct DBOF_SymbolHdr symHdr;
-	struct KFILE_FileObj *file;
-	u16 i;
-	u16 nSymbols;
-	u16 len;
-	char *pName = NULL;
-	DSP_STATUS status = DSP_SOK;
-
-	file = pdblLib->file;
-
-	nSymbols = pdblLib->fileHdr.numSymbols;
-
-	for (i = 0; i < nSymbols; i++) {
-		/* Read symbol value */
-		if ((*dbl->dblAttrs.fread)(&symHdr,
-		   sizeof(struct DBOF_SymbolHdr), 1, file) != 1) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "Failed to read symbol value\n");
-			status = DSP_EFREAD;
-			break;
-		}
-		if (pdblLib->byteSwapped) {
-			symHdr.nameLen = SWAPWORD(symHdr.nameLen);
-			symHdr.value = SWAPLONG(symHdr.value);
-		}
-		/* Allocate buffer for symbol name */
-		len = symHdr.nameLen;
-		pName = (char *)MEM_Calloc(len + 1, MEM_PAGED);
-		if (pName == NULL) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "Memory allocation failed\n");
-			status = DSP_EMEMORY;
-			break;
-		}
-		pdblLib->symbols[i].pSymName = pName;
-		pdblLib->symbols[i].sym.value = symHdr.value;
-		/* Read symbol name */
-		if ((*dbl->dblAttrs.fread) (pName, sizeof(char), len, file) !=
-		   len) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "Failed to read symbol value\n");
-			status = DSP_EFREAD;
-			break;
-		} else {
-			pName[len] = '\0';
-			GT_2trace(DBL_debugMask, GT_ENTER,
-				 "Symbol: %s  Value: 0x%lx\n",
-				 pName, symHdr.value);
-		}
-	}
-	return status;
-}
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/dbll.c kernel-power-2.6.28.new/drivers/dsp/bridge/pmgr/dbll.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/dbll.c	2011-10-11 13:51:00.676156113 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/pmgr/dbll.c	2011-10-23 08:22:37.631615000 +0100
@@ -14,26 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== dbll.c ========
- *
- *! Revision History
- *! ================
- *! 25-Apr-2030 map:    Fixed symbol redefinition bug + unload and return error
- *! 08-Apr-2003 map: 	Consolidated DBL with DBLL loader name
- *! 24-Mar-2003 map:    Updated findSymbol to support dllview update
- *! 23-Jan-2003 map:    Updated rmmAlloc to support memory granularity
- *! 21-Nov-2002 map:    Combine fopen and DLOAD_module_open to increase
- *!         performance on start.
- *! 04-Oct-2002 map:    Integrated new TIP dynamic loader w/ DOF api.
- *! 27-Sep-2002 map:    Changed handle passed to RemoteFree, instead of
- *!         RMM_free;  added GT_trace to rmmDealloc
- *! 20-Sep-2002 map:    Updated from Code Review
- *! 08-Aug-2002 jeh:    Updated to support overlays.
- *! 25-Jun-2002 jeh:    Pass RMM_Addr object to alloc function in rmmAlloc().
- *! 20-Mar-2002 jeh:    Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -43,12 +23,10 @@
 #include <dspbridge/errbase.h>
 
 /*  ----------------------------------- Trace & Debug */
-#include <dspbridge/gt.h>
 #include <dspbridge/dbc.h>
 #include <dspbridge/gh.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/mem.h>
 
 /* Dynamic loader library interface */
@@ -74,349 +52,328 @@
 #define DOFF_ALIGN(x) (((x) + 3) & ~UINT32_C(3))
 
 /*
- *  ======== struct DBLL_TarObj* ========
+ *  ======== struct dbll_tar_obj* ========
  *  A target may have one or more libraries of symbols/code/data loaded
  *  onto it, where a library is simply the symbols/code/data contained
  *  in a DOFF file.
  */
 /*
- *  ======== DBLL_TarObj ========
+ *  ======== dbll_tar_obj ========
  */
-struct DBLL_TarObj {
-	u32 dwSignature; 	/* For object validation */
-	struct DBLL_Attrs attrs;
-	struct DBLL_LibraryObj *head; 	/* List of all opened libraries */
-} ;
+struct dbll_tar_obj {
+	u32 dw_signature;	/* For object validation */
+	struct dbll_attrs attrs;
+	struct dbll_library_obj *head;	/* List of all opened libraries */
+};
 
 /*
  *  The following 4 typedefs are "super classes" of the dynamic loader
  *  library types used in dynamic loader functions (dynamic_loader.h).
  */
 /*
- *  ======== DBLLStream ========
- *  Contains Dynamic_Loader_Stream
+ *  ======== dbll_stream ========
+ *  Contains dynamic_loader_stream
  */
-struct DBLLStream {
-	struct Dynamic_Loader_Stream dlStream;
-	struct DBLL_LibraryObj *lib;
-} ;
+struct dbll_stream {
+	struct dynamic_loader_stream dl_stream;
+	struct dbll_library_obj *lib;
+};
 
 /*
- *  ======== DBLLSymbol ========
+ *  ======== ldr_symbol ========
  */
-struct DBLLSymbol {
-	struct Dynamic_Loader_Sym dlSymbol;
-	struct DBLL_LibraryObj *lib;
-} ;
+struct ldr_symbol {
+	struct dynamic_loader_sym dl_symbol;
+	struct dbll_library_obj *lib;
+};
 
 /*
- *  ======== DBLLAlloc ========
+ *  ======== dbll_alloc ========
  */
- struct DBLLAlloc {
-	struct Dynamic_Loader_Allocate dlAlloc;
-	struct DBLL_LibraryObj *lib;
-} ;
+struct dbll_alloc {
+	struct dynamic_loader_allocate dl_alloc;
+	struct dbll_library_obj *lib;
+};
 
 /*
- *  ======== DBLLInit ========
+ *  ======== dbll_init_obj ========
  */
-struct DBLLInit {
-	struct Dynamic_Loader_Initialize dlInit;
-	struct DBLL_LibraryObj *lib;
+struct dbll_init_obj {
+	struct dynamic_loader_initialize dl_init;
+	struct dbll_library_obj *lib;
 };
 
 /*
  *  ======== DBLL_Library ========
- *  A library handle is returned by DBLL_Open() and is passed to DBLL_load()
- *  to load symbols/code/data, and to DBLL_unload(), to remove the
- *  symbols/code/data loaded by DBLL_load().
+ *  A library handle is returned by DBLL_Open() and is passed to dbll_load()
+ *  to load symbols/code/data, and to dbll_unload(), to remove the
+ *  symbols/code/data loaded by dbll_load().
  */
 
 /*
- *  ======== DBLL_LibraryObj ========
+ *  ======== dbll_library_obj ========
  */
- struct DBLL_LibraryObj {
-	u32 dwSignature; 	/* For object validation */
-	struct DBLL_LibraryObj *next; 	/* Next library in target's list */
-	struct DBLL_LibraryObj *prev; 	/* Previous in the list */
-	struct DBLL_TarObj *pTarget; 	/* target for this library */
+struct dbll_library_obj {
+	u32 dw_signature;	/* For object validation */
+	struct dbll_library_obj *next;	/* Next library in target's list */
+	struct dbll_library_obj *prev;	/* Previous in the list */
+	struct dbll_tar_obj *target_obj;	/* target for this library */
 
 	/* Objects needed by dynamic loader */
-	struct DBLLStream stream;
-	struct DBLLSymbol symbol;
-	struct DBLLAlloc allocate;
-	struct DBLLInit init;
-	DLOAD_mhandle mHandle;
-
-	char *fileName; 	/* COFF file name */
-	void *fp; 		/* Opaque file handle */
-	u32 entry; 		/* Entry point */
-	DLOAD_mhandle desc; 	/* desc of DOFF file loaded */
-	u32 openRef; 		/* Number of times opened */
-	u32 loadRef; 		/* Number of times loaded */
-	struct GH_THashTab *symTab; 	/* Hash table of symbols */
-	u32 ulPos;
-} ;
+	struct dbll_stream stream;
+	struct ldr_symbol symbol;
+	struct dbll_alloc allocate;
+	struct dbll_init_obj init;
+	dload_mhandle dload_mod_obj;
+
+	char *file_name;	/* COFF file name */
+	void *fp;		/* Opaque file handle */
+	u32 entry;		/* Entry point */
+	dload_mhandle desc;	/* desc of DOFF file loaded */
+	u32 open_ref;		/* Number of times opened */
+	u32 load_ref;		/* Number of times loaded */
+	struct gh_t_hash_tab *sym_tab;	/* Hash table of symbols */
+	u32 ul_pos;
+};
 
 /*
- *  ======== Symbol ========
+ *  ======== dbll_symbol ========
  */
-struct Symbol {
-	struct DBLL_Symbol value;
+struct dbll_symbol {
+	struct dbll_sym_val value;
 	char *name;
-} ;
-extern bool bSymbolsReloaded;
+};
+extern bool symbols_reloaded;
 
-static void dofClose(struct DBLL_LibraryObj *zlLib);
-static DSP_STATUS dofOpen(struct DBLL_LibraryObj *zlLib);
-static s32 NoOp(struct Dynamic_Loader_Initialize *thisptr, void *bufr,
-		LDR_ADDR locn, struct LDR_SECTION_INFO *info, unsigned bytsiz);
+static void dof_close(struct dbll_library_obj *zl_lib);
+static dsp_status dof_open(struct dbll_library_obj *zl_lib);
+static s32 no_op(struct dynamic_loader_initialize *thisptr, void *bufr,
+		 ldr_addr locn, struct ldr_section_info *info, unsigned bytsiz);
 
 /*
  *  Functions called by dynamic loader
  *
  */
-/* Dynamic_Loader_Stream */
-static int readBuffer(struct Dynamic_Loader_Stream *this, void *buffer,
-		     unsigned bufsize);
-static int setFilePosn(struct Dynamic_Loader_Stream *this, unsigned int pos);
-/* Dynamic_Loader_Sym */
-static struct dynload_symbol *findSymbol(struct Dynamic_Loader_Sym *this,
-					const char *name);
-static struct dynload_symbol *addToSymbolTable(struct Dynamic_Loader_Sym *this,
-					      const char *name,
-					      unsigned moduleId);
-static struct dynload_symbol *findInSymbolTable(struct Dynamic_Loader_Sym *this,
-						const char *name,
-						unsigned moduleid);
-static void purgeSymbolTable(struct Dynamic_Loader_Sym *this,
-			    unsigned moduleId);
-static void *allocate(struct Dynamic_Loader_Sym *this, unsigned memsize);
-static void deallocate(struct Dynamic_Loader_Sym *this, void *memPtr);
-static void errorReport(struct Dynamic_Loader_Sym *this, const char *errstr,
-			va_list args);
-/* Dynamic_Loader_Allocate */
-static int rmmAlloc(struct Dynamic_Loader_Allocate *this,
-		   struct LDR_SECTION_INFO *info, unsigned align);
-static void rmmDealloc(struct Dynamic_Loader_Allocate *this,
-		      struct LDR_SECTION_INFO *info);
-
-/* Dynamic_Loader_Initialize */
-static int connect(struct Dynamic_Loader_Initialize *this);
-static int readMem(struct Dynamic_Loader_Initialize *this, void *buf,
-		  LDR_ADDR addr, struct LDR_SECTION_INFO *info,
-		  unsigned nbytes);
-static int writeMem(struct Dynamic_Loader_Initialize *this, void *buf,
-		   LDR_ADDR addr, struct LDR_SECTION_INFO *info,
-		   unsigned nbytes);
-static int fillMem(struct Dynamic_Loader_Initialize *this, LDR_ADDR addr,
-		   struct LDR_SECTION_INFO *info, unsigned nbytes,
-		   unsigned val);
-static int execute(struct Dynamic_Loader_Initialize *this, LDR_ADDR start);
-static void release(struct Dynamic_Loader_Initialize *this);
+/* dynamic_loader_stream */
+static int dbll_read_buffer(struct dynamic_loader_stream *this, void *buffer,
+			    unsigned bufsize);
+static int dbll_set_file_posn(struct dynamic_loader_stream *this,
+			      unsigned int pos);
+/* dynamic_loader_sym */
+static struct dynload_symbol *dbll_find_symbol(struct dynamic_loader_sym *this,
+					       const char *name);
+static struct dynload_symbol *dbll_add_to_symbol_table(struct dynamic_loader_sym
+						       *this, const char *name,
+						       unsigned moduleId);
+static struct dynload_symbol *find_in_symbol_table(struct dynamic_loader_sym
+						   *this, const char *name,
+						   unsigned moduleid);
+static void dbll_purge_symbol_table(struct dynamic_loader_sym *this,
+				    unsigned moduleId);
+static void *allocate(struct dynamic_loader_sym *this, unsigned memsize);
+static void deallocate(struct dynamic_loader_sym *this, void *memPtr);
+static void dbll_err_report(struct dynamic_loader_sym *this, const char *errstr,
+			    va_list args);
+/* dynamic_loader_allocate */
+static int dbll_rmm_alloc(struct dynamic_loader_allocate *this,
+			  struct ldr_section_info *info, unsigned align);
+static void rmm_dealloc(struct dynamic_loader_allocate *this,
+			struct ldr_section_info *info);
+
+/* dynamic_loader_initialize */
+static int connect(struct dynamic_loader_initialize *this);
+static int read_mem(struct dynamic_loader_initialize *this, void *buf,
+		    ldr_addr addr, struct ldr_section_info *info,
+		    unsigned nbytes);
+static int write_mem(struct dynamic_loader_initialize *this, void *buf,
+		     ldr_addr addr, struct ldr_section_info *info,
+		     unsigned nbytes);
+static int fill_mem(struct dynamic_loader_initialize *this, ldr_addr addr,
+		    struct ldr_section_info *info, unsigned nbytes,
+		    unsigned val);
+static int execute(struct dynamic_loader_initialize *this, ldr_addr start);
+static void release(struct dynamic_loader_initialize *this);
 
 /* symbol table hash functions */
-static u16 nameHash(void *name, u16 maxBucket);
-static bool nameMatch(void *name, void *sp);
-static void symDelete(void *sp);
-
-#if GT_TRACE
-static struct GT_Mask DBLL_debugMask = { NULL, NULL };  /* GT trace variable */
-#endif
+static u16 name_hash(void *name, u16 max_bucket);
+static bool name_match(void *name, void *sp);
+static void sym_delete(void *sp);
 
-static u32 cRefs; 		/* module reference count */
+static u32 refs;		/* module reference count */
 
 /* Symbol Redefinition */
-static int bRedefinedSymbol;
-static int bGblSearch = 1;
+static int redefined_symbol;
+static int gbl_search = 1;
 
 /*
- *  ======== DBLL_close ========
+ *  ======== dbll_close ========
  */
-void DBLL_close(struct DBLL_LibraryObj *zlLib)
+void dbll_close(struct dbll_library_obj *zl_lib)
 {
-	struct DBLL_TarObj *zlTarget;
+	struct dbll_tar_obj *zl_target;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
-	DBC_Require(zlLib->openRef > 0);
-	zlTarget = zlLib->pTarget;
-	GT_1trace(DBLL_debugMask, GT_ENTER, "DBLL_close: lib: 0x%x\n", zlLib);
-	zlLib->openRef--;
-	if (zlLib->openRef == 0) {
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(zl_lib->open_ref > 0);
+	zl_target = zl_lib->target_obj;
+	zl_lib->open_ref--;
+	if (zl_lib->open_ref == 0) {
 		/* Remove library from list */
-		if (zlTarget->head == zlLib)
-			zlTarget->head = zlLib->next;
+		if (zl_target->head == zl_lib)
+			zl_target->head = zl_lib->next;
 
-		if (zlLib->prev)
-			(zlLib->prev)->next = zlLib->next;
+		if (zl_lib->prev)
+			(zl_lib->prev)->next = zl_lib->next;
 
-		if (zlLib->next)
-			(zlLib->next)->prev = zlLib->prev;
+		if (zl_lib->next)
+			(zl_lib->next)->prev = zl_lib->prev;
 
 		/* Free DOF resources */
-		dofClose(zlLib);
-		if (zlLib->fileName)
-			MEM_Free(zlLib->fileName);
+		dof_close(zl_lib);
+		kfree(zl_lib->file_name);
 
 		/* remove symbols from symbol table */
-		if (zlLib->symTab)
-			GH_delete(zlLib->symTab);
+		if (zl_lib->sym_tab)
+			gh_delete(zl_lib->sym_tab);
 
 		/* remove the library object itself */
-		MEM_FreeObject(zlLib);
-		zlLib = NULL;
+		MEM_FREE_OBJECT(zl_lib);
+		zl_lib = NULL;
 	}
 }
 
 /*
- *  ======== DBLL_create ========
+ *  ======== dbll_create ========
  */
-DSP_STATUS DBLL_create(struct DBLL_TarObj **pTarget, struct DBLL_Attrs *pAttrs)
+dsp_status dbll_create(struct dbll_tar_obj **target_obj,
+		       struct dbll_attrs *pattrs)
 {
-	struct DBLL_TarObj *pzlTarget;
-	DSP_STATUS status = DSP_SOK;
+	struct dbll_tar_obj *pzl_target;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pAttrs != NULL);
-	DBC_Require(pTarget != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pattrs != NULL);
+	DBC_REQUIRE(target_obj != NULL);
 
-	GT_2trace(DBLL_debugMask, GT_ENTER,
-		  "DBLL_create: pTarget: 0x%x pAttrs: "
-		  "0x%x\n", pTarget, pAttrs);
 	/* Allocate DBL target object */
-	MEM_AllocObject(pzlTarget, struct DBLL_TarObj, DBLL_TARGSIGNATURE);
-	if (pTarget != NULL) {
-		if (pzlTarget == NULL) {
-			GT_0trace(DBLL_debugMask, GT_6CLASS,
-				 "DBLL_create: Memory allocation"
-				 " failed\n");
-			*pTarget = NULL;
+	MEM_ALLOC_OBJECT(pzl_target, struct dbll_tar_obj, DBLL_TARGSIGNATURE);
+	if (target_obj != NULL) {
+		if (pzl_target == NULL) {
+			*target_obj = NULL;
 			status = DSP_EMEMORY;
 		} else {
-			pzlTarget->attrs = *pAttrs;
-			*pTarget = (struct DBLL_TarObj *)pzlTarget;
+			pzl_target->attrs = *pattrs;
+			*target_obj = (struct dbll_tar_obj *)pzl_target;
 		}
-		DBC_Ensure((DSP_SUCCEEDED(status) &&
-			  MEM_IsValidHandle(((struct DBLL_TarObj *)(*pTarget)),
-			  DBLL_TARGSIGNATURE)) || (DSP_FAILED(status) &&
-			  *pTarget == NULL));
+		DBC_ENSURE((DSP_SUCCEEDED(status) &&
+			    MEM_IS_VALID_HANDLE(((struct dbll_tar_obj
+						  *)(*target_obj)),
+						DBLL_TARGSIGNATURE))
+			   || (DSP_FAILED(status) && *target_obj == NULL));
 	}
 
 	return status;
 }
 
 /*
- *  ======== DBLL_delete ========
+ *  ======== dbll_delete ========
  */
-void DBLL_delete(struct DBLL_TarObj *target)
+void dbll_delete(struct dbll_tar_obj *target)
 {
-	struct DBLL_TarObj *zlTarget = (struct DBLL_TarObj *)target;
+	struct dbll_tar_obj *zl_target = (struct dbll_tar_obj *)target;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlTarget, DBLL_TARGSIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_target, DBLL_TARGSIGNATURE));
 
-	GT_1trace(DBLL_debugMask, GT_ENTER, "DBLL_delete: target: 0x%x\n",
-		 target);
-
-	if (zlTarget != NULL)
-		MEM_FreeObject(zlTarget);
+	if (zl_target != NULL)
+		MEM_FREE_OBJECT(zl_target);
 
 }
 
 /*
- *  ======== DBLL_exit ========
+ *  ======== dbll_exit ========
  *  Discontinue usage of DBL module.
  */
-void DBLL_exit(void)
+void dbll_exit(void)
 {
-	DBC_Require(cRefs > 0);
-
-	cRefs--;
+	DBC_REQUIRE(refs > 0);
 
-	GT_1trace(DBLL_debugMask, GT_5CLASS, "DBLL_exit() ref count: 0x%x\n",
-		  cRefs);
+	refs--;
 
-	if (cRefs == 0) {
-		MEM_Exit();
-		CSL_Exit();
-		GH_exit();
-#if GT_TRACE
-		DBLL_debugMask.flags = NULL;
-#endif
-	}
+	if (refs == 0)
+		gh_exit();
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== DBLL_getAddr ========
+ *  ======== dbll_get_addr ========
  *  Get address of name in the specified library.
  */
-bool DBLL_getAddr(struct DBLL_LibraryObj *zlLib, char *name,
-		  struct DBLL_Symbol **ppSym)
+bool dbll_get_addr(struct dbll_library_obj *zl_lib, char *name,
+		   struct dbll_sym_val **ppSym)
 {
-	struct Symbol *sym;
+	struct dbll_symbol *sym;
 	bool status = false;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
-	DBC_Require(name != NULL);
-	DBC_Require(ppSym != NULL);
-	DBC_Require(zlLib->symTab != NULL);
-
-	GT_3trace(DBLL_debugMask, GT_ENTER,
-		 "DBLL_getAddr: lib: 0x%x name: %s pAddr:"
-		 " 0x%x\n", zlLib, name, ppSym);
-	sym = (struct Symbol *)GH_find(zlLib->symTab, name);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(name != NULL);
+	DBC_REQUIRE(ppSym != NULL);
+	DBC_REQUIRE(zl_lib->sym_tab != NULL);
+
+	sym = (struct dbll_symbol *)gh_find(zl_lib->sym_tab, name);
 	if (sym != NULL) {
 		*ppSym = &sym->value;
 		status = true;
 	}
+
+	dev_dbg(bridge, "%s: lib: %p name: %s paddr: %p, status 0x%x\n",
+		__func__, zl_lib, name, ppSym, status);
 	return status;
 }
 
 /*
- *  ======== DBLL_getAttrs ========
+ *  ======== dbll_get_attrs ========
  *  Retrieve the attributes of the target.
  */
-void DBLL_getAttrs(struct DBLL_TarObj *target, struct DBLL_Attrs *pAttrs)
+void dbll_get_attrs(struct dbll_tar_obj *target, struct dbll_attrs *pattrs)
 {
-	struct DBLL_TarObj *zlTarget = (struct DBLL_TarObj *)target;
+	struct dbll_tar_obj *zl_target = (struct dbll_tar_obj *)target;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlTarget, DBLL_TARGSIGNATURE));
-	DBC_Require(pAttrs != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_target, DBLL_TARGSIGNATURE));
+	DBC_REQUIRE(pattrs != NULL);
 
-	if ((pAttrs != NULL) && (zlTarget != NULL))
-		*pAttrs = zlTarget->attrs;
+	if ((pattrs != NULL) && (zl_target != NULL))
+		*pattrs = zl_target->attrs;
 
 }
 
 /*
- *  ======== DBLL_getCAddr ========
+ *  ======== dbll_get_c_addr ========
  *  Get address of a "C" name in the specified library.
  */
-bool DBLL_getCAddr(struct DBLL_LibraryObj *zlLib, char *name,
-		   struct DBLL_Symbol **ppSym)
+bool dbll_get_c_addr(struct dbll_library_obj *zl_lib, char *name,
+		     struct dbll_sym_val **ppSym)
 {
-	struct Symbol *sym;
+	struct dbll_symbol *sym;
 	char cname[MAXEXPR + 1];
 	bool status = false;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
-	DBC_Require(ppSym != NULL);
-	DBC_Require(zlLib->symTab != NULL);
-	DBC_Require(name != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(ppSym != NULL);
+	DBC_REQUIRE(zl_lib->sym_tab != NULL);
+	DBC_REQUIRE(name != NULL);
 
 	cname[0] = '_';
 
-       strncpy(cname + 1, name, sizeof(cname) - 2);
-	cname[MAXEXPR] = '\0'; 	/* insure '\0' string termination */
+	strncpy(cname + 1, name, sizeof(cname) - 2);
+	cname[MAXEXPR] = '\0';	/* insure '\0' string termination */
 
 	/* Check for C name, if not found */
-	sym = (struct Symbol *)GH_find(zlLib->symTab, cname);
+	sym = (struct dbll_symbol *)gh_find(zl_lib->sym_tab, cname);
 
 	if (sym != NULL) {
 		*ppSym = &sym->value;
@@ -427,130 +384,111 @@
 }
 
 /*
- *  ======== DBLL_getSect ========
+ *  ======== dbll_get_sect ========
  *  Get the base address and size (in bytes) of a COFF section.
  */
-DSP_STATUS DBLL_getSect(struct DBLL_LibraryObj *lib, char *name, u32 *pAddr,
-			u32 *pSize)
+dsp_status dbll_get_sect(struct dbll_library_obj *lib, char *name, u32 *paddr,
+			 u32 *psize)
 {
-	u32 uByteSize;
-	bool fOpenedDoff = false;
-	const struct LDR_SECTION_INFO *sect = NULL;
-	struct DBLL_LibraryObj *zlLib = (struct DBLL_LibraryObj *)lib;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(name != NULL);
-	DBC_Require(pAddr != NULL);
-	DBC_Require(pSize != NULL);
-	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
-
-	GT_4trace(DBLL_debugMask, GT_ENTER,
-		 "DBLL_getSect: lib: 0x%x name: %s pAddr:"
-		 " 0x%x pSize: 0x%x\n", lib, name, pAddr, pSize);
+	u32 byte_size;
+	bool opened_doff = false;
+	const struct ldr_section_info *sect = NULL;
+	struct dbll_library_obj *zl_lib = (struct dbll_library_obj *)lib;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(name != NULL);
+	DBC_REQUIRE(paddr != NULL);
+	DBC_REQUIRE(psize != NULL);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_lib, DBLL_LIBSIGNATURE));
+
 	/* If DOFF file is not open, we open it. */
-	if (zlLib != NULL) {
-		if (zlLib->fp == NULL) {
-			status = dofOpen(zlLib);
+	if (zl_lib != NULL) {
+		if (zl_lib->fp == NULL) {
+			status = dof_open(zl_lib);
 			if (DSP_SUCCEEDED(status))
-				fOpenedDoff = true;
+				opened_doff = true;
 
 		} else {
-			(*(zlLib->pTarget->attrs.fseek))(zlLib->fp,
-			 zlLib->ulPos, SEEK_SET);
+			(*(zl_lib->target_obj->attrs.fseek)) (zl_lib->fp,
+							      zl_lib->ul_pos,
+							      SEEK_SET);
 		}
 	} else {
 		status = DSP_EHANDLE;
 	}
 	if (DSP_SUCCEEDED(status)) {
-		uByteSize = 1;
-		if (DLOAD_GetSectionInfo(zlLib->desc, name, &sect)) {
-			*pAddr = sect->load_addr;
-			*pSize = sect->size * uByteSize;
+		byte_size = 1;
+		if (dload_get_section_info(zl_lib->desc, name, &sect)) {
+			*paddr = sect->load_addr;
+			*psize = sect->size * byte_size;
 			/* Make sure size is even for good swap */
-			if (*pSize % 2)
-				(*pSize)++;
+			if (*psize % 2)
+				(*psize)++;
 
 			/* Align size */
-			*pSize = DOFF_ALIGN(*pSize);
+			*psize = DOFF_ALIGN(*psize);
 		} else {
 			status = DSP_ENOSECT;
 		}
 	}
-	if (fOpenedDoff) {
-		dofClose(zlLib);
-		fOpenedDoff = false;
+	if (opened_doff) {
+		dof_close(zl_lib);
+		opened_doff = false;
 	}
 
+	dev_dbg(bridge, "%s: lib: %p name: %s paddr: %p psize: %p, "
+		"status 0x%x\n", __func__, lib, name, paddr, psize, status);
+
 	return status;
 }
 
 /*
- *  ======== DBLL_init ========
+ *  ======== dbll_init ========
  */
-bool DBLL_init(void)
+bool dbll_init(void)
 {
-	bool retVal = true;
-
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (cRefs == 0) {
-		DBC_Assert(!DBLL_debugMask.flags);
-		GT_create(&DBLL_debugMask, "DL"); 	/* "DL" for dbDL */
-		GH_init();
-		CSL_Init();
-		retVal = MEM_Init();
-		if (!retVal)
-			MEM_Exit();
-
-	}
+	if (refs == 0)
+		gh_init();
 
-	if (retVal)
-		cRefs++;
+	refs++;
 
-
-	GT_1trace(DBLL_debugMask, GT_5CLASS, "DBLL_init(), ref count:  0x%x\n",
-		 cRefs);
-
-	DBC_Ensure((retVal && (cRefs > 0)) || (!retVal && (cRefs >= 0)));
-
-	return retVal;
+	return true;
 }
 
 /*
- *  ======== DBLL_load ========
+ *  ======== dbll_load ========
  */
-DSP_STATUS DBLL_load(struct DBLL_LibraryObj *lib, DBLL_Flags flags,
-		     struct DBLL_Attrs *attrs, u32 *pEntry)
+dsp_status dbll_load(struct dbll_library_obj *lib, dbll_flags flags,
+		     struct dbll_attrs *attrs, u32 *pEntry)
 {
-	struct DBLL_LibraryObj *zlLib = (struct DBLL_LibraryObj *)lib;
-	struct DBLL_TarObj *dbzl;
-	bool gotSymbols = true;
+	struct dbll_library_obj *zl_lib = (struct dbll_library_obj *)lib;
+	struct dbll_tar_obj *dbzl;
+	bool got_symbols = true;
 	s32 err;
-	DSP_STATUS status = DSP_SOK;
-	bool fOpenedDoff = false;
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
-	DBC_Require(pEntry != NULL);
-	DBC_Require(attrs != NULL);
-
-	GT_4trace(DBLL_debugMask, GT_ENTER,
-		 "DBLL_load: lib: 0x%x flags: 0x%x pEntry:"
-		 " 0x%x\n", lib, flags, attrs, pEntry);
+	dsp_status status = DSP_SOK;
+	bool opened_doff = false;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(pEntry != NULL);
+	DBC_REQUIRE(attrs != NULL);
+
 	/*
 	 *  Load if not already loaded.
 	 */
-	if (zlLib->loadRef == 0 || !(flags & DBLL_DYNAMIC)) {
-		dbzl = zlLib->pTarget;
+	if (zl_lib->load_ref == 0 || !(flags & DBLL_DYNAMIC)) {
+		dbzl = zl_lib->target_obj;
 		dbzl->attrs = *attrs;
 		/* Create a hash table for symbols if not already created */
-		if (zlLib->symTab == NULL) {
-			gotSymbols = false;
-			zlLib->symTab = GH_create(MAXBUCKETS,
-						 sizeof(struct Symbol),
-						 nameHash,
-						 nameMatch, symDelete);
-			if (zlLib->symTab == NULL)
+		if (zl_lib->sym_tab == NULL) {
+			got_symbols = false;
+			zl_lib->sym_tab = gh_create(MAXBUCKETS,
+						    sizeof(struct dbll_symbol),
+						    name_hash,
+						    name_match, sym_delete);
+			if (zl_lib->sym_tab == NULL)
 				status = DSP_EMEMORY;
 
 		}
@@ -558,153 +496,150 @@
 		 *  Set up objects needed by the dynamic loader
 		 */
 		/* Stream */
-		zlLib->stream.dlStream.read_buffer = readBuffer;
-		zlLib->stream.dlStream.set_file_posn = setFilePosn;
-		zlLib->stream.lib = zlLib;
+		zl_lib->stream.dl_stream.read_buffer = dbll_read_buffer;
+		zl_lib->stream.dl_stream.set_file_posn = dbll_set_file_posn;
+		zl_lib->stream.lib = zl_lib;
 		/* Symbol */
-		zlLib->symbol.dlSymbol.Find_Matching_Symbol = findSymbol;
-		if (gotSymbols) {
-			zlLib->symbol.dlSymbol.Add_To_Symbol_Table =
-							findInSymbolTable;
+		zl_lib->symbol.dl_symbol.find_matching_symbol =
+		    dbll_find_symbol;
+		if (got_symbols) {
+			zl_lib->symbol.dl_symbol.add_to_symbol_table =
+			    find_in_symbol_table;
 		} else {
-			zlLib->symbol.dlSymbol.Add_To_Symbol_Table =
-							addToSymbolTable;
+			zl_lib->symbol.dl_symbol.add_to_symbol_table =
+			    dbll_add_to_symbol_table;
 		}
-		zlLib->symbol.dlSymbol.Purge_Symbol_Table = purgeSymbolTable;
-		zlLib->symbol.dlSymbol.Allocate = allocate;
-		zlLib->symbol.dlSymbol.Deallocate = deallocate;
-		zlLib->symbol.dlSymbol.Error_Report = errorReport;
-		zlLib->symbol.lib = zlLib;
+		zl_lib->symbol.dl_symbol.purge_symbol_table =
+		    dbll_purge_symbol_table;
+		zl_lib->symbol.dl_symbol.dload_allocate = allocate;
+		zl_lib->symbol.dl_symbol.dload_deallocate = deallocate;
+		zl_lib->symbol.dl_symbol.error_report = dbll_err_report;
+		zl_lib->symbol.lib = zl_lib;
 		/* Allocate */
-		zlLib->allocate.dlAlloc.Allocate = rmmAlloc;
-		zlLib->allocate.dlAlloc.Deallocate = rmmDealloc;
-		zlLib->allocate.lib = zlLib;
+		zl_lib->allocate.dl_alloc.dload_allocate = dbll_rmm_alloc;
+		zl_lib->allocate.dl_alloc.dload_deallocate = rmm_dealloc;
+		zl_lib->allocate.lib = zl_lib;
 		/* Init */
-		zlLib->init.dlInit.connect = connect;
-		zlLib->init.dlInit.readmem = readMem;
-		zlLib->init.dlInit.writemem = writeMem;
-		zlLib->init.dlInit.fillmem = fillMem;
-		zlLib->init.dlInit.execute = execute;
-		zlLib->init.dlInit.release = release;
-		zlLib->init.lib = zlLib;
+		zl_lib->init.dl_init.connect = connect;
+		zl_lib->init.dl_init.readmem = read_mem;
+		zl_lib->init.dl_init.writemem = write_mem;
+		zl_lib->init.dl_init.fillmem = fill_mem;
+		zl_lib->init.dl_init.execute = execute;
+		zl_lib->init.dl_init.release = release;
+		zl_lib->init.lib = zl_lib;
 		/* If COFF file is not open, we open it. */
-		if (zlLib->fp == NULL) {
-			status = dofOpen(zlLib);
+		if (zl_lib->fp == NULL) {
+			status = dof_open(zl_lib);
 			if (DSP_SUCCEEDED(status))
-				fOpenedDoff = true;
+				opened_doff = true;
 
 		}
 		if (DSP_SUCCEEDED(status)) {
-			zlLib->ulPos = (*(zlLib->pTarget->attrs.ftell))
-					(zlLib->fp);
+			zl_lib->ul_pos = (*(zl_lib->target_obj->attrs.ftell))
+			    (zl_lib->fp);
 			/* Reset file cursor */
-			(*(zlLib->pTarget->attrs.fseek))(zlLib->fp, (long)0,
-				 SEEK_SET);
-			bSymbolsReloaded = true;
+			(*(zl_lib->target_obj->attrs.fseek)) (zl_lib->fp,
+							      (long)0,
+							      SEEK_SET);
+			symbols_reloaded = true;
 			/* The 5th argument, DLOAD_INITBSS, tells the DLL
 			 * module to zero-init all BSS sections.  In general,
 			 * this is not necessary and also increases load time.
 			 * We may want to make this configurable by the user */
-			err = Dynamic_Load_Module(&zlLib->stream.dlStream,
-			      &zlLib->symbol.dlSymbol, &zlLib->allocate.dlAlloc,
-			      &zlLib->init.dlInit, DLOAD_INITBSS,
-			      &zlLib->mHandle);
+			err = dynamic_load_module(&zl_lib->stream.dl_stream,
+						  &zl_lib->symbol.dl_symbol,
+						  &zl_lib->allocate.dl_alloc,
+						  &zl_lib->init.dl_init,
+						  DLOAD_INITBSS,
+						  &zl_lib->dload_mod_obj);
 
 			if (err != 0) {
-				GT_1trace(DBLL_debugMask, GT_6CLASS,
-					 "DBLL_load: "
-					 "Dynamic_Load_Module failed: 0x%lx\n",
-					 err);
 				status = DSP_EDYNLOAD;
-			} else if (bRedefinedSymbol) {
-				zlLib->loadRef++;
-				DBLL_unload(zlLib, (struct DBLL_Attrs *) attrs);
-				bRedefinedSymbol = false;
+			} else if (redefined_symbol) {
+				zl_lib->load_ref++;
+				dbll_unload(zl_lib, (struct dbll_attrs *)attrs);
+				redefined_symbol = false;
 				status = DSP_EDYNLOAD;
 			} else {
-				*pEntry = zlLib->entry;
+				*pEntry = zl_lib->entry;
 			}
 		}
 	}
 	if (DSP_SUCCEEDED(status))
-		zlLib->loadRef++;
+		zl_lib->load_ref++;
 
 	/* Clean up DOFF resources */
-	if (fOpenedDoff)
-		dofClose(zlLib);
+	if (opened_doff)
+		dof_close(zl_lib);
+
+	DBC_ENSURE(DSP_FAILED(status) || zl_lib->load_ref > 0);
+
+	dev_dbg(bridge, "%s: lib: %p flags: 0x%x pEntry: %p, status 0x%x\n",
+		__func__, lib, flags, pEntry, status);
 
-	DBC_Ensure(DSP_FAILED(status) || zlLib->loadRef > 0);
 	return status;
 }
 
 /*
- *  ======== DBLL_loadSect ========
+ *  ======== dbll_load_sect ========
  *  Not supported for COFF.
  */
-DSP_STATUS DBLL_loadSect(struct DBLL_LibraryObj *zlLib, char *sectName,
-			struct DBLL_Attrs *attrs)
+dsp_status dbll_load_sect(struct dbll_library_obj *zl_lib, char *sectName,
+			  struct dbll_attrs *attrs)
 {
-	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_lib, DBLL_LIBSIGNATURE));
 
 	return DSP_ENOTIMPL;
 }
 
 /*
- *  ======== DBLL_open ========
+ *  ======== dbll_open ========
  */
-DSP_STATUS DBLL_open(struct DBLL_TarObj *target, char *file, DBLL_Flags flags,
-		    struct DBLL_LibraryObj **pLib)
+dsp_status dbll_open(struct dbll_tar_obj *target, char *file, dbll_flags flags,
+		     struct dbll_library_obj **pLib)
 {
-	struct DBLL_TarObj *zlTarget = (struct DBLL_TarObj *)target;
-	struct DBLL_LibraryObj *zlLib = NULL;
+	struct dbll_tar_obj *zl_target = (struct dbll_tar_obj *)target;
+	struct dbll_library_obj *zl_lib = NULL;
 	s32 err;
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlTarget, DBLL_TARGSIGNATURE));
-	DBC_Require(zlTarget->attrs.fopen != NULL);
-	DBC_Require(file != NULL);
-	DBC_Require(pLib != NULL);
-
-	GT_3trace(DBLL_debugMask, GT_ENTER,
-		 "DBLL_open: target: 0x%x file: %s pLib:"
-		 " 0x%x\n", target, file, pLib);
-	zlLib = zlTarget->head;
-	while (zlLib != NULL) {
-               if (strcmp(zlLib->fileName, file) == 0) {
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_target, DBLL_TARGSIGNATURE));
+	DBC_REQUIRE(zl_target->attrs.fopen != NULL);
+	DBC_REQUIRE(file != NULL);
+	DBC_REQUIRE(pLib != NULL);
+
+	zl_lib = zl_target->head;
+	while (zl_lib != NULL) {
+		if (strcmp(zl_lib->file_name, file) == 0) {
 			/* Library is already opened */
-			zlLib->openRef++;
+			zl_lib->open_ref++;
 			break;
 		}
-		zlLib = zlLib->next;
+		zl_lib = zl_lib->next;
 	}
-	if (zlLib == NULL) {
+	if (zl_lib == NULL) {
 		/* Allocate DBL library object */
-		MEM_AllocObject(zlLib, struct DBLL_LibraryObj,
-				DBLL_LIBSIGNATURE);
-		if (zlLib == NULL) {
-			GT_0trace(DBLL_debugMask, GT_6CLASS,
-				 "DBLL_open: Memory allocation failed\n");
+		MEM_ALLOC_OBJECT(zl_lib, struct dbll_library_obj,
+				 DBLL_LIBSIGNATURE);
+		if (zl_lib == NULL) {
 			status = DSP_EMEMORY;
 		} else {
-			zlLib->ulPos = 0;
+			zl_lib->ul_pos = 0;
 			/* Increment ref count to allow close on failure
 			 * later on */
-			zlLib->openRef++;
-			zlLib->pTarget = zlTarget;
+			zl_lib->open_ref++;
+			zl_lib->target_obj = zl_target;
 			/* Keep a copy of the file name */
-                       zlLib->fileName = MEM_Calloc(strlen(file) + 1,
-							MEM_PAGED);
-			if (zlLib->fileName == NULL) {
-				GT_0trace(DBLL_debugMask, GT_6CLASS,
-					 "DBLL_open: Memory "
-					 "allocation failed\n");
+			zl_lib->file_name = mem_calloc(strlen(file) + 1,
+						       MEM_PAGED);
+			if (zl_lib->file_name == NULL) {
 				status = DSP_EMEMORY;
 			} else {
-                               strncpy(zlLib->fileName, file,
-                                          strlen(file) + 1);
+				strncpy(zl_lib->file_name, file,
+					strlen(file) + 1);
 			}
-			zlLib->symTab = NULL;
+			zl_lib->sym_tab = NULL;
 		}
 	}
 	/*
@@ -714,127 +649,125 @@
 		goto func_cont;
 
 	/* Stream */
-	zlLib->stream.dlStream.read_buffer = readBuffer;
-	zlLib->stream.dlStream.set_file_posn = setFilePosn;
-	zlLib->stream.lib = zlLib;
+	zl_lib->stream.dl_stream.read_buffer = dbll_read_buffer;
+	zl_lib->stream.dl_stream.set_file_posn = dbll_set_file_posn;
+	zl_lib->stream.lib = zl_lib;
 	/* Symbol */
-	zlLib->symbol.dlSymbol.Add_To_Symbol_Table = addToSymbolTable;
-	zlLib->symbol.dlSymbol.Find_Matching_Symbol = findSymbol;
-	zlLib->symbol.dlSymbol.Purge_Symbol_Table = purgeSymbolTable;
-	zlLib->symbol.dlSymbol.Allocate = allocate;
-	zlLib->symbol.dlSymbol.Deallocate = deallocate;
-	zlLib->symbol.dlSymbol.Error_Report = errorReport;
-	zlLib->symbol.lib = zlLib;
+	zl_lib->symbol.dl_symbol.add_to_symbol_table = dbll_add_to_symbol_table;
+	zl_lib->symbol.dl_symbol.find_matching_symbol = dbll_find_symbol;
+	zl_lib->symbol.dl_symbol.purge_symbol_table = dbll_purge_symbol_table;
+	zl_lib->symbol.dl_symbol.dload_allocate = allocate;
+	zl_lib->symbol.dl_symbol.dload_deallocate = deallocate;
+	zl_lib->symbol.dl_symbol.error_report = dbll_err_report;
+	zl_lib->symbol.lib = zl_lib;
 	/* Allocate */
-	zlLib->allocate.dlAlloc.Allocate = rmmAlloc;
-	zlLib->allocate.dlAlloc.Deallocate = rmmDealloc;
-	zlLib->allocate.lib = zlLib;
+	zl_lib->allocate.dl_alloc.dload_allocate = dbll_rmm_alloc;
+	zl_lib->allocate.dl_alloc.dload_deallocate = rmm_dealloc;
+	zl_lib->allocate.lib = zl_lib;
 	/* Init */
-	zlLib->init.dlInit.connect = connect;
-	zlLib->init.dlInit.readmem = readMem;
-	zlLib->init.dlInit.writemem = writeMem;
-	zlLib->init.dlInit.fillmem = fillMem;
-	zlLib->init.dlInit.execute = execute;
-	zlLib->init.dlInit.release = release;
-	zlLib->init.lib = zlLib;
-	if (DSP_SUCCEEDED(status) && zlLib->fp == NULL)
-		status = dofOpen(zlLib);
+	zl_lib->init.dl_init.connect = connect;
+	zl_lib->init.dl_init.readmem = read_mem;
+	zl_lib->init.dl_init.writemem = write_mem;
+	zl_lib->init.dl_init.fillmem = fill_mem;
+	zl_lib->init.dl_init.execute = execute;
+	zl_lib->init.dl_init.release = release;
+	zl_lib->init.lib = zl_lib;
+	if (DSP_SUCCEEDED(status) && zl_lib->fp == NULL)
+		status = dof_open(zl_lib);
 
-	zlLib->ulPos = (*(zlLib->pTarget->attrs.ftell)) (zlLib->fp);
-	(*(zlLib->pTarget->attrs.fseek))(zlLib->fp, (long) 0, SEEK_SET);
+	zl_lib->ul_pos = (*(zl_lib->target_obj->attrs.ftell)) (zl_lib->fp);
+	(*(zl_lib->target_obj->attrs.fseek)) (zl_lib->fp, (long)0, SEEK_SET);
 	/* Create a hash table for symbols if flag is set */
-	if (zlLib->symTab != NULL || !(flags & DBLL_SYMB))
+	if (zl_lib->sym_tab != NULL || !(flags & DBLL_SYMB))
 		goto func_cont;
 
-	zlLib->symTab = GH_create(MAXBUCKETS, sizeof(struct Symbol), nameHash,
-				 nameMatch, symDelete);
-	if (zlLib->symTab == NULL) {
+	zl_lib->sym_tab =
+	    gh_create(MAXBUCKETS, sizeof(struct dbll_symbol), name_hash,
+		      name_match, sym_delete);
+	if (zl_lib->sym_tab == NULL) {
 		status = DSP_EMEMORY;
 	} else {
-		/* Do a fake load to get symbols - set write function to NoOp */
-		zlLib->init.dlInit.writemem = NoOp;
-		err = Dynamic_Open_Module(&zlLib->stream.dlStream,
-					&zlLib->symbol.dlSymbol,
-					&zlLib->allocate.dlAlloc,
-					&zlLib->init.dlInit, 0,
-					&zlLib->mHandle);
+		/* Do a fake load to get symbols - set write func to no_op */
+		zl_lib->init.dl_init.writemem = no_op;
+		err = dynamic_open_module(&zl_lib->stream.dl_stream,
+					  &zl_lib->symbol.dl_symbol,
+					  &zl_lib->allocate.dl_alloc,
+					  &zl_lib->init.dl_init, 0,
+					  &zl_lib->dload_mod_obj);
 		if (err != 0) {
-			GT_1trace(DBLL_debugMask, GT_6CLASS, "DBLL_open: "
-				 "Dynamic_Load_Module failed: 0x%lx\n", err);
 			status = DSP_EDYNLOAD;
 		} else {
 			/* Now that we have the symbol table, we can unload */
-			err = Dynamic_Unload_Module(zlLib->mHandle,
-						   &zlLib->symbol.dlSymbol,
-						   &zlLib->allocate.dlAlloc,
-						   &zlLib->init.dlInit);
-			if (err != 0) {
-				GT_1trace(DBLL_debugMask, GT_6CLASS,
-					"DBLL_open: "
-					"Dynamic_Unload_Module failed: 0x%lx\n",
-					err);
+			err = dynamic_unload_module(zl_lib->dload_mod_obj,
+						    &zl_lib->symbol.dl_symbol,
+						    &zl_lib->allocate.dl_alloc,
+						    &zl_lib->init.dl_init);
+			if (err != 0)
 				status = DSP_EDYNLOAD;
-			}
-			zlLib->mHandle = NULL;
+
+			zl_lib->dload_mod_obj = NULL;
 		}
 	}
 func_cont:
 	if (DSP_SUCCEEDED(status)) {
-		if (zlLib->openRef == 1) {
+		if (zl_lib->open_ref == 1) {
 			/* First time opened - insert in list */
-			if (zlTarget->head)
-				(zlTarget->head)->prev = zlLib;
+			if (zl_target->head)
+				(zl_target->head)->prev = zl_lib;
 
-			zlLib->prev = NULL;
-			zlLib->next = zlTarget->head;
-			zlTarget->head = zlLib;
+			zl_lib->prev = NULL;
+			zl_lib->next = zl_target->head;
+			zl_target->head = zl_lib;
 		}
-		*pLib = (struct DBLL_LibraryObj *)zlLib;
+		*pLib = (struct dbll_library_obj *)zl_lib;
 	} else {
 		*pLib = NULL;
-		if (zlLib != NULL)
-			DBLL_close((struct DBLL_LibraryObj *)zlLib);
+		if (zl_lib != NULL)
+			dbll_close((struct dbll_library_obj *)zl_lib);
 
 	}
-	DBC_Ensure((DSP_SUCCEEDED(status) && (zlLib->openRef > 0) &&
-		  MEM_IsValidHandle(((struct DBLL_LibraryObj *)(*pLib)),
-		  DBLL_LIBSIGNATURE)) || (DSP_FAILED(status) && *pLib == NULL));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && (zl_lib->open_ref > 0) &&
+		    MEM_IS_VALID_HANDLE(((struct dbll_library_obj *)(*pLib)),
+					DBLL_LIBSIGNATURE))
+		   || (DSP_FAILED(status) && *pLib == NULL));
+
+	dev_dbg(bridge, "%s: target: %p file: %s pLib: %p, status 0x%x\n",
+		__func__, target, file, pLib, status);
+
 	return status;
 }
 
 /*
- *  ======== DBLL_readSect ========
+ *  ======== dbll_read_sect ========
  *  Get the content of a COFF section.
  */
-DSP_STATUS DBLL_readSect(struct DBLL_LibraryObj *lib, char *name,
-			 char *pContent, u32 size)
+dsp_status dbll_read_sect(struct dbll_library_obj *lib, char *name,
+			  char *pContent, u32 size)
 {
-	struct DBLL_LibraryObj *zlLib = (struct DBLL_LibraryObj *)lib;
-	bool fOpenedDoff = false;
-	u32 uByteSize; 		/* size of bytes */
-	u32 ulSectSize; 		/* size of section */
-	const struct LDR_SECTION_INFO *sect = NULL;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
-	DBC_Require(name != NULL);
-	DBC_Require(pContent != NULL);
-	DBC_Require(size != 0);
-
-	GT_4trace(DBLL_debugMask, GT_ENTER,
-		 "DBLL_readSect: lib: 0x%x name: %s "
-		 "pContent: 0x%x size: 0x%x\n", lib, name, pContent, size);
+	struct dbll_library_obj *zl_lib = (struct dbll_library_obj *)lib;
+	bool opened_doff = false;
+	u32 byte_size;		/* size of bytes */
+	u32 ul_sect_size;	/* size of section */
+	const struct ldr_section_info *sect = NULL;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(name != NULL);
+	DBC_REQUIRE(pContent != NULL);
+	DBC_REQUIRE(size != 0);
+
 	/* If DOFF file is not open, we open it. */
-	if (zlLib != NULL) {
-		if (zlLib->fp == NULL) {
-			status = dofOpen(zlLib);
+	if (zl_lib != NULL) {
+		if (zl_lib->fp == NULL) {
+			status = dof_open(zl_lib);
 			if (DSP_SUCCEEDED(status))
-				fOpenedDoff = true;
+				opened_doff = true;
 
 		} else {
-			(*(zlLib->pTarget->attrs.fseek))(zlLib->fp,
-				zlLib->ulPos, SEEK_SET);
+			(*(zl_lib->target_obj->attrs.fseek)) (zl_lib->fp,
+							      zl_lib->ul_pos,
+							      SEEK_SET);
 		}
 	} else {
 		status = DSP_EHANDLE;
@@ -842,8 +775,8 @@
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-	uByteSize = 1;
-	if (!DLOAD_GetSectionInfo(zlLib->desc, name, &sect)) {
+	byte_size = 1;
+	if (!dload_get_section_info(zl_lib->desc, name, &sect)) {
 		status = DSP_ENOSECT;
 		goto func_cont;
 	}
@@ -851,138 +784,137 @@
 	 * Ensure the supplied buffer size is sufficient to store
 	 * the section content to be read.
 	 */
-	ulSectSize = sect->size * uByteSize;
+	ul_sect_size = sect->size * byte_size;
 	/* Make sure size is even for good swap */
-	if (ulSectSize % 2)
-		ulSectSize++;
+	if (ul_sect_size % 2)
+		ul_sect_size++;
 
 	/* Align size */
-	ulSectSize = DOFF_ALIGN(ulSectSize);
-	if (ulSectSize > size) {
+	ul_sect_size = DOFF_ALIGN(ul_sect_size);
+	if (ul_sect_size > size) {
 		status = DSP_EFAIL;
 	} else {
-		if (!DLOAD_GetSection(zlLib->desc, sect, pContent))
+		if (!dload_get_section(zl_lib->desc, sect, pContent))
 			status = DSP_EFREAD;
 
 	}
 func_cont:
-	if (fOpenedDoff) {
-		dofClose(zlLib);
-		fOpenedDoff = false;
+	if (opened_doff) {
+		dof_close(zl_lib);
+		opened_doff = false;
 	}
+
+	dev_dbg(bridge, "%s: lib: %p name: %s pContent: %p size: 0x%x, "
+		"status 0x%x\n", __func__, lib, name, pContent, size, status);
 	return status;
 }
 
 /*
- *  ======== DBLL_setAttrs ========
+ *  ======== dbll_set_attrs ========
  *  Set the attributes of the target.
  */
-void DBLL_setAttrs(struct DBLL_TarObj *target, struct DBLL_Attrs *pAttrs)
+void dbll_set_attrs(struct dbll_tar_obj *target, struct dbll_attrs *pattrs)
 {
-	struct DBLL_TarObj *zlTarget = (struct DBLL_TarObj *)target;
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlTarget, DBLL_TARGSIGNATURE));
-	DBC_Require(pAttrs != NULL);
-	GT_2trace(DBLL_debugMask, GT_ENTER,
-		 "DBLL_setAttrs: target: 0x%x pAttrs: "
-		 "0x%x\n", target, pAttrs);
-	if ((pAttrs != NULL) && (zlTarget != NULL))
-		zlTarget->attrs = *pAttrs;
+	struct dbll_tar_obj *zl_target = (struct dbll_tar_obj *)target;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_target, DBLL_TARGSIGNATURE));
+	DBC_REQUIRE(pattrs != NULL);
+
+	if ((pattrs != NULL) && (zl_target != NULL))
+		zl_target->attrs = *pattrs;
 
 }
 
 /*
- *  ======== DBLL_unload ========
+ *  ======== dbll_unload ========
  */
-void DBLL_unload(struct DBLL_LibraryObj *lib, struct DBLL_Attrs *attrs)
+void dbll_unload(struct dbll_library_obj *lib, struct dbll_attrs *attrs)
 {
-	struct DBLL_LibraryObj *zlLib = (struct DBLL_LibraryObj *)lib;
+	struct dbll_library_obj *zl_lib = (struct dbll_library_obj *)lib;
 	s32 err = 0;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
-	DBC_Require(zlLib->loadRef > 0);
-	GT_1trace(DBLL_debugMask, GT_ENTER, "DBLL_unload: lib: 0x%x\n", lib);
-	zlLib->loadRef--;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(zl_lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(zl_lib->load_ref > 0);
+	dev_dbg(bridge, "%s: lib: %p\n", __func__, lib);
+	zl_lib->load_ref--;
 	/* Unload only if reference count is 0 */
-	if (zlLib->loadRef != 0)
+	if (zl_lib->load_ref != 0)
 		goto func_end;
 
-	zlLib->pTarget->attrs = *attrs;
-	if (zlLib != NULL) {
-		if (zlLib->mHandle) {
-			err = Dynamic_Unload_Module(zlLib->mHandle,
-				&zlLib->symbol.dlSymbol,
-				&zlLib->allocate.dlAlloc, &zlLib->init.dlInit);
-			if (err != 0) {
-				GT_1trace(DBLL_debugMask, GT_5CLASS,
-					 "Dynamic_Unload_Module "
-					 "failed: 0x%x\n", err);
-			}
-		}
-		/* remove symbols from symbol table */
-		if (zlLib->symTab != NULL) {
-			GH_delete(zlLib->symTab);
-			zlLib->symTab = NULL;
+	zl_lib->target_obj->attrs = *attrs;
+	if (zl_lib->dload_mod_obj) {
+		err = dynamic_unload_module(zl_lib->dload_mod_obj,
+					    &zl_lib->symbol.dl_symbol,
+					    &zl_lib->allocate.dl_alloc,
+					    &zl_lib->init.dl_init);
+		if (err != 0) {
+			dev_dbg(bridge, "%s: failed: 0x%x\n", __func__, err);
 		}
-		/* delete DOFF desc since it holds *lots* of host OS
-		 * resources */
-		dofClose(zlLib);
 	}
+	/* remove symbols from symbol table */
+	if (zl_lib->sym_tab != NULL) {
+		gh_delete(zl_lib->sym_tab);
+		zl_lib->sym_tab = NULL;
+	}
+	/* delete DOFF desc since it holds *lots* of host OS
+	 * resources */
+	dof_close(zl_lib);
 func_end:
-	DBC_Ensure(zlLib->loadRef >= 0);
+	DBC_ENSURE(zl_lib->load_ref >= 0);
 }
 
 /*
- *  ======== DBLL_unloadSect ========
+ *  ======== dbll_unload_sect ========
  *  Not supported for COFF.
  */
-DSP_STATUS DBLL_unloadSect(struct DBLL_LibraryObj *lib, char *sectName,
-			  struct DBLL_Attrs *attrs)
+dsp_status dbll_unload_sect(struct dbll_library_obj *lib, char *sectName,
+			    struct dbll_attrs *attrs)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(sectName != NULL);
-	GT_2trace(DBLL_debugMask, GT_ENTER,
-		 "DBLL_unloadSect: lib: 0x%x sectName: "
-		 "%s\n", lib, sectName);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(sectName != NULL);
+
 	return DSP_ENOTIMPL;
 }
 
 /*
- *  ======== dofClose ========
+ *  ======== dof_close ========
  */
-static void dofClose(struct DBLL_LibraryObj *zlLib)
+static void dof_close(struct dbll_library_obj *zl_lib)
 {
-	if (zlLib->desc) {
-		DLOAD_module_close(zlLib->desc);
-		zlLib->desc = NULL;
+	if (zl_lib->desc) {
+		dload_module_close(zl_lib->desc);
+		zl_lib->desc = NULL;
 	}
 	/* close file */
-	if (zlLib->fp) {
-		(zlLib->pTarget->attrs.fclose) (zlLib->fp);
-		zlLib->fp = NULL;
+	if (zl_lib->fp) {
+		(zl_lib->target_obj->attrs.fclose) (zl_lib->fp);
+		zl_lib->fp = NULL;
 	}
 }
 
 /*
- *  ======== dofOpen ========
+ *  ======== dof_open ========
  */
-static DSP_STATUS dofOpen(struct DBLL_LibraryObj *zlLib)
+static dsp_status dof_open(struct dbll_library_obj *zl_lib)
 {
-	void *open = *(zlLib->pTarget->attrs.fopen);
-	DSP_STATUS status = DSP_SOK;
+	void *open = *(zl_lib->target_obj->attrs.fopen);
+	dsp_status status = DSP_SOK;
 
 	/* First open the file for the dynamic loader, then open COF */
-	zlLib->fp = (void *)((DBLL_FOpenFxn)(open))(zlLib->fileName, "rb");
+	zl_lib->fp =
+	    (void *)((dbll_f_open_fxn) (open)) (zl_lib->file_name, "rb");
 
 	/* Open DOFF module */
-	if (zlLib->fp && zlLib->desc == NULL) {
-		(*(zlLib->pTarget->attrs.fseek))(zlLib->fp, (long)0, SEEK_SET);
-		zlLib->desc = DLOAD_module_open(&zlLib->stream.dlStream,
-						&zlLib->symbol.dlSymbol);
-		if (zlLib->desc == NULL) {
-			(zlLib->pTarget->attrs.fclose)(zlLib->fp);
-			zlLib->fp = NULL;
+	if (zl_lib->fp && zl_lib->desc == NULL) {
+		(*(zl_lib->target_obj->attrs.fseek)) (zl_lib->fp, (long)0,
+						      SEEK_SET);
+		zl_lib->desc =
+		    dload_module_open(&zl_lib->stream.dl_stream,
+				      &zl_lib->symbol.dl_symbol);
+		if (zl_lib->desc == NULL) {
+			(zl_lib->target_obj->attrs.fclose) (zl_lib->fp);
+			zl_lib->fp = NULL;
 			status = DSP_EFOPEN;
 		}
 	} else {
@@ -993,15 +925,15 @@
 }
 
 /*
- *  ======== nameHash ========
+ *  ======== name_hash ========
  */
-static u16 nameHash(void *key, u16 maxBucket)
+static u16 name_hash(void *key, u16 max_bucket)
 {
 	u16 ret;
 	u16 hash;
 	char *name = (char *)key;
 
-	DBC_Require(name != NULL);
+	DBC_REQUIRE(name != NULL);
 
 	hash = 0;
 
@@ -1010,233 +942,238 @@
 		hash ^= *name++;
 	}
 
-	ret = hash % maxBucket;
+	ret = hash % max_bucket;
 
 	return ret;
 }
 
 /*
- *  ======== nameMatch ========
+ *  ======== name_match ========
  */
-static bool nameMatch(void *key, void *value)
+static bool name_match(void *key, void *value)
 {
-	DBC_Require(key != NULL);
-	DBC_Require(value != NULL);
+	DBC_REQUIRE(key != NULL);
+	DBC_REQUIRE(value != NULL);
 
 	if ((key != NULL) && (value != NULL)) {
-               if (strcmp((char *)key, ((struct Symbol *)value)->name) == 0)
+		if (strcmp((char *)key, ((struct dbll_symbol *)value)->name) ==
+		    0)
 			return true;
 	}
 	return false;
 }
 
 /*
- *  ======== NoOp ========
+ *  ======== no_op ========
  */
-static int NoOp(struct Dynamic_Loader_Initialize *thisptr, void *bufr,
-		LDR_ADDR locn, struct LDR_SECTION_INFO *info, unsigned bytsize)
+static int no_op(struct dynamic_loader_initialize *thisptr, void *bufr,
+		 ldr_addr locn, struct ldr_section_info *info, unsigned bytsize)
 {
 	return 1;
 }
 
 /*
- *  ======== symDelete ========
+ *  ======== sym_delete ========
  */
-static void symDelete(void *value)
+static void sym_delete(void *value)
 {
-	struct Symbol *sp = (struct Symbol *)value;
+	struct dbll_symbol *sp = (struct dbll_symbol *)value;
 
-	MEM_Free(sp->name);
+	kfree(sp->name);
 }
 
 /*
  *  Dynamic Loader Functions
  */
 
-/* Dynamic_Loader_Stream */
+/* dynamic_loader_stream */
 /*
- *  ======== readBuffer ========
+ *  ======== dbll_read_buffer ========
  */
-static int readBuffer(struct Dynamic_Loader_Stream *this, void *buffer,
-		     unsigned bufsize)
+static int dbll_read_buffer(struct dynamic_loader_stream *this, void *buffer,
+			    unsigned bufsize)
 {
-	struct DBLLStream *pStream = (struct DBLLStream *)this;
-	struct DBLL_LibraryObj *lib;
-	int bytesRead = 0;
+	struct dbll_stream *pstream = (struct dbll_stream *)this;
+	struct dbll_library_obj *lib;
+	int bytes_read = 0;
 
-	DBC_Require(this != NULL);
-	lib = pStream->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(this != NULL);
+	lib = pstream->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 
 	if (lib != NULL) {
-		bytesRead = (*(lib->pTarget->attrs.fread))(buffer, 1, bufsize,
-			    lib->fp);
+		bytes_read =
+		    (*(lib->target_obj->attrs.fread)) (buffer, 1, bufsize,
+						       lib->fp);
 	}
-	return bytesRead;
+	return bytes_read;
 }
 
 /*
- *  ======== setFilePosn ========
+ *  ======== dbll_set_file_posn ========
  */
-static int setFilePosn(struct Dynamic_Loader_Stream *this, unsigned int pos)
+static int dbll_set_file_posn(struct dynamic_loader_stream *this,
+			      unsigned int pos)
 {
-	struct DBLLStream *pStream = (struct DBLLStream *)this;
-	struct DBLL_LibraryObj *lib;
-	int status = 0; 		/* Success */
+	struct dbll_stream *pstream = (struct dbll_stream *)this;
+	struct dbll_library_obj *lib;
+	int status = 0;		/* Success */
 
-	DBC_Require(this != NULL);
-	lib = pStream->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(this != NULL);
+	lib = pstream->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 
 	if (lib != NULL) {
-		status = (*(lib->pTarget->attrs.fseek))(lib->fp, (long)pos,
-			 SEEK_SET);
+		status = (*(lib->target_obj->attrs.fseek)) (lib->fp, (long)pos,
+							    SEEK_SET);
 	}
 
 	return status;
 }
 
-/* Dynamic_Loader_Sym */
+/* dynamic_loader_sym */
 
 /*
- *  ======== findSymbol ========
+ *  ======== dbll_find_symbol ========
  */
-static struct dynload_symbol *findSymbol(struct Dynamic_Loader_Sym *this,
-					const char *name)
+static struct dynload_symbol *dbll_find_symbol(struct dynamic_loader_sym *this,
+					       const char *name)
 {
-	struct dynload_symbol *retSym;
-	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
-	struct DBLL_LibraryObj *lib;
-	struct DBLL_Symbol *pSym = NULL;
-	bool status = false; 	/* Symbol not found yet */
+	struct dynload_symbol *ret_sym;
+	struct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;
+	struct dbll_library_obj *lib;
+	struct dbll_sym_val *dbll_sym = NULL;
+	bool status = false;	/* Symbol not found yet */
 
-	DBC_Require(this != NULL);
-	lib = pSymbol->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(this != NULL);
+	lib = ldr_sym->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 
 	if (lib != NULL) {
-		if (lib->pTarget->attrs.symLookup) {
+		if (lib->target_obj->attrs.sym_lookup) {
 			/* Check current lib + base lib + dep lib +
 			 * persistent lib */
-			status = (*(lib->pTarget->attrs.symLookup))
-				 (lib->pTarget->attrs.symHandle,
-				 lib->pTarget->attrs.symArg,
-				 lib->pTarget->attrs.rmmHandle, name, &pSym);
+			status = (*(lib->target_obj->attrs.sym_lookup))
+			    (lib->target_obj->attrs.sym_handle,
+			     lib->target_obj->attrs.sym_arg,
+			     lib->target_obj->attrs.rmm_handle, name,
+			     &dbll_sym);
 		} else {
 			/* Just check current lib for symbol */
-			status = DBLL_getAddr((struct DBLL_LibraryObj *)lib,
-				 (char *)name, &pSym);
+			status = dbll_get_addr((struct dbll_library_obj *)lib,
+					       (char *)name, &dbll_sym);
 			if (!status) {
 				status =
-				   DBLL_getCAddr((struct DBLL_LibraryObj *)lib,
-				   (char *)name, &pSym);
+				    dbll_get_c_addr((struct dbll_library_obj *)
+						    lib, (char *)name,
+						    &dbll_sym);
 			}
 		}
 	}
 
-	if (!status && bGblSearch) {
-		GT_1trace(DBLL_debugMask, GT_6CLASS,
-			 "findSymbol: Symbol not found: %s\n", name);
-	}
+	if (!status && gbl_search)
+		dev_dbg(bridge, "%s: Symbol not found: %s\n", __func__, name);
 
-	DBC_Assert((status && (pSym != NULL)) || (!status && (pSym == NULL)));
+	DBC_ASSERT((status && (dbll_sym != NULL))
+		   || (!status && (dbll_sym == NULL)));
 
-	retSym = (struct dynload_symbol *)pSym;
-	return retSym;
+	ret_sym = (struct dynload_symbol *)dbll_sym;
+	return ret_sym;
 }
 
 /*
- *  ======== findInSymbolTable ========
+ *  ======== find_in_symbol_table ========
  */
-static struct dynload_symbol *findInSymbolTable(struct Dynamic_Loader_Sym *this,
-						const char *name,
-						unsigned moduleid)
+static struct dynload_symbol *find_in_symbol_table(struct dynamic_loader_sym
+						   *this, const char *name,
+						   unsigned moduleid)
 {
-	struct dynload_symbol *retSym;
-	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
-	struct DBLL_LibraryObj *lib;
-	struct Symbol *sym;
+	struct dynload_symbol *ret_sym;
+	struct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;
+	struct dbll_library_obj *lib;
+	struct dbll_symbol *sym;
 
-	DBC_Require(this != NULL);
-	lib = pSymbol->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
-	DBC_Require(lib->symTab != NULL);
+	DBC_REQUIRE(this != NULL);
+	lib = ldr_sym->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(lib->sym_tab != NULL);
 
-	sym = (struct Symbol *)GH_find(lib->symTab, (char *) name);
+	sym = (struct dbll_symbol *)gh_find(lib->sym_tab, (char *)name);
 
-	retSym = (struct dynload_symbol *)&sym->value;
-	return retSym;
+	ret_sym = (struct dynload_symbol *)&sym->value;
+	return ret_sym;
 }
 
 /*
- *  ======== addToSymbolTable ========
+ *  ======== dbll_add_to_symbol_table ========
  */
-static struct dynload_symbol *addToSymbolTable(struct Dynamic_Loader_Sym *this,
-					      const char *name,
-					      unsigned moduleId)
+static struct dynload_symbol *dbll_add_to_symbol_table(struct dynamic_loader_sym
+						       *this, const char *name,
+						       unsigned moduleId)
 {
-	struct Symbol *symPtr = NULL;
-	struct Symbol symbol;
-	struct dynload_symbol *pSym = NULL;
-	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
-	struct DBLL_LibraryObj *lib;
-	struct dynload_symbol *retVal;
+	struct dbll_symbol *sym_ptr = NULL;
+	struct dbll_symbol symbol;
+	struct dynload_symbol *dbll_sym = NULL;
+	struct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;
+	struct dbll_library_obj *lib;
+	struct dynload_symbol *ret;
 
-	DBC_Require(this != NULL);
-       DBC_Require(name);
-	lib = pSymbol->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(this != NULL);
+	DBC_REQUIRE(name);
+	lib = ldr_sym->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 
 	/* Check to see if symbol is already defined in symbol table */
-	if (!(lib->pTarget->attrs.baseImage)) {
-		bGblSearch = false;
-		pSym = findSymbol(this, name);
-		bGblSearch = true;
-		if (pSym) {
-			bRedefinedSymbol = true;
-			GT_1trace(DBLL_debugMask, GT_6CLASS,
-				 "Symbol already defined in "
-				 "symbol table: %s\n", name);
+	if (!(lib->target_obj->attrs.base_image)) {
+		gbl_search = false;
+		dbll_sym = dbll_find_symbol(this, name);
+		gbl_search = true;
+		if (dbll_sym) {
+			redefined_symbol = true;
+			dev_dbg(bridge, "%s already defined in symbol table\n",
+				name);
 			return NULL;
 		}
 	}
 	/* Allocate string to copy symbol name */
-       symbol.name = (char *)MEM_Calloc(strlen((char *const)name) + 1,
-							MEM_PAGED);
+	symbol.name = (char *)mem_calloc(strlen((char *const)name) + 1,
+					 MEM_PAGED);
 	if (symbol.name == NULL)
 		return NULL;
 
 	if (symbol.name != NULL) {
 		/* Just copy name (value will be filled in by dynamic loader) */
-               strncpy(symbol.name, (char *const)name,
-                          strlen((char *const)name) + 1);
+		strncpy(symbol.name, (char *const)name,
+			strlen((char *const)name) + 1);
 
 		/* Add symbol to symbol table */
-		symPtr = (struct Symbol *)GH_insert(lib->symTab, (void *)name,
-			 (void *)&symbol);
-		if (symPtr == NULL)
-			MEM_Free(symbol.name);
+		sym_ptr =
+		    (struct dbll_symbol *)gh_insert(lib->sym_tab, (void *)name,
+						    (void *)&symbol);
+		if (sym_ptr == NULL)
+			kfree(symbol.name);
 
 	}
-	if (symPtr != NULL)
-		retVal = (struct dynload_symbol *)&symPtr->value;
+	if (sym_ptr != NULL)
+		ret = (struct dynload_symbol *)&sym_ptr->value;
 	else
-		retVal = NULL;
+		ret = NULL;
 
-	return retVal;
+	return ret;
 }
 
 /*
- *  ======== purgeSymbolTable ========
+ *  ======== dbll_purge_symbol_table ========
  */
-static void purgeSymbolTable(struct Dynamic_Loader_Sym *this, unsigned moduleId)
+static void dbll_purge_symbol_table(struct dynamic_loader_sym *this,
+				    unsigned moduleId)
 {
-	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
-	struct DBLL_LibraryObj *lib;
+	struct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;
+	struct dbll_library_obj *lib;
 
-	DBC_Require(this != NULL);
-	lib = pSymbol->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(this != NULL);
+	lib = ldr_sym->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 
 	/* May not need to do anything */
 }
@@ -1244,17 +1181,17 @@
 /*
  *  ======== allocate ========
  */
-static void *allocate(struct Dynamic_Loader_Sym *this, unsigned memsize)
+static void *allocate(struct dynamic_loader_sym *this, unsigned memsize)
 {
-	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
-	struct DBLL_LibraryObj *lib;
+	struct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;
+	struct dbll_library_obj *lib;
 	void *buf;
 
-	DBC_Require(this != NULL);
-	lib = pSymbol->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(this != NULL);
+	lib = ldr_sym->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 
-	buf = MEM_Calloc(memsize, MEM_PAGED);
+	buf = mem_calloc(memsize, MEM_PAGED);
 
 	return buf;
 }
@@ -1262,311 +1199,319 @@
 /*
  *  ======== deallocate ========
  */
-static void deallocate(struct Dynamic_Loader_Sym *this, void *memPtr)
+static void deallocate(struct dynamic_loader_sym *this, void *memPtr)
 {
-	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
-	struct DBLL_LibraryObj *lib;
+	struct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;
+	struct dbll_library_obj *lib;
 
-	DBC_Require(this != NULL);
-	lib = pSymbol->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	DBC_REQUIRE(this != NULL);
+	lib = ldr_sym->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 
-	MEM_Free(memPtr);
+	kfree(memPtr);
 }
 
 /*
- *  ======== errorReport ========
+ *  ======== dbll_err_report ========
  */
-static void errorReport(struct Dynamic_Loader_Sym *this, const char *errstr,
-			va_list args)
+static void dbll_err_report(struct dynamic_loader_sym *this, const char *errstr,
+			    va_list args)
 {
-	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
-	struct DBLL_LibraryObj *lib;
-	char tempBuf[MAXEXPR];
+	struct ldr_symbol *ldr_sym = (struct ldr_symbol *)this;
+	struct dbll_library_obj *lib;
+	char temp_buf[MAXEXPR];
 
-	DBC_Require(this != NULL);
-	lib = pSymbol->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
-	vsnprintf((char *)tempBuf, MAXEXPR, (char *)errstr, args);
-	GT_1trace(DBLL_debugMask, GT_5CLASS, "%s\n", tempBuf);
+	DBC_REQUIRE(this != NULL);
+	lib = ldr_sym->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
+	vsnprintf((char *)temp_buf, MAXEXPR, (char *)errstr, args);
+	dev_dbg(bridge, "%s\n", temp_buf);
 }
 
-/* Dynamic_Loader_Allocate */
+/* dynamic_loader_allocate */
 
 /*
- *  ======== rmmAlloc ========
+ *  ======== dbll_rmm_alloc ========
  */
-static int rmmAlloc(struct Dynamic_Loader_Allocate *this,
-		   struct LDR_SECTION_INFO *info, unsigned align)
+static int dbll_rmm_alloc(struct dynamic_loader_allocate *this,
+			  struct ldr_section_info *info, unsigned align)
 {
-	struct DBLLAlloc *pAlloc = (struct DBLLAlloc *)this;
-	struct DBLL_LibraryObj *lib;
-	DSP_STATUS status = DSP_SOK;
-	u32 memType;
-	struct RMM_Addr rmmAddr;
-	s32 retVal = TRUE;
+	struct dbll_alloc *dbll_alloc_obj = (struct dbll_alloc *)this;
+	struct dbll_library_obj *lib;
+	dsp_status status = DSP_SOK;
+	u32 mem_sect_type;
+	struct rmm_addr rmm_addr_obj;
+	s32 ret = TRUE;
 	unsigned stype = DLOAD_SECTION_TYPE(info->type);
-	char *pToken = NULL;
-	char *szSecLastToken = NULL;
-	char *szLastToken = NULL;
-	char *szSectName = NULL;
-	char *pszCur;
-	s32 tokenLen = 0;
-	s32 segId = -1;
+	char *token = NULL;
+	char *sz_sec_last_token = NULL;
+	char *sz_last_token = NULL;
+	char *sz_sect_name = NULL;
+	char *psz_cur;
+	s32 token_len = 0;
+	s32 seg_id = -1;
 	s32 req = -1;
 	s32 count = 0;
-	u32 allocSize = 0;
-
-	DBC_Require(this != NULL);
-	lib = pAlloc->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	u32 alloc_size = 0;
+	u32 run_addr_flag = 0;
 
-	memType = (stype == DLOAD_TEXT) ? DBLL_CODE : (stype == DLOAD_BSS) ?
-		   DBLL_BSS : DBLL_DATA;
+	DBC_REQUIRE(this != NULL);
+	lib = dbll_alloc_obj->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
+
+	mem_sect_type =
+	    (stype == DLOAD_TEXT) ? DBLL_CODE : (stype ==
+						 DLOAD_BSS) ? DBLL_BSS :
+	    DBLL_DATA;
 
 	/* Attempt to extract the segment ID and requirement information from
-	 the name of the section */
-       DBC_Require(info->name);
-       tokenLen = strlen((char *)(info->name)) + 1;
-
-	szSectName = MEM_Calloc(tokenLen, MEM_PAGED);
-	szLastToken = MEM_Calloc(tokenLen, MEM_PAGED);
-	szSecLastToken = MEM_Calloc(tokenLen, MEM_PAGED);
+	   the name of the section */
+	DBC_REQUIRE(info->name);
+	token_len = strlen((char *)(info->name)) + 1;
+
+	sz_sect_name = mem_calloc(token_len, MEM_PAGED);
+	sz_last_token = mem_calloc(token_len, MEM_PAGED);
+	sz_sec_last_token = mem_calloc(token_len, MEM_PAGED);
 
-	if (szSectName == NULL || szSecLastToken == NULL ||
-	   szLastToken == NULL) {
+	if (sz_sect_name == NULL || sz_sec_last_token == NULL ||
+	    sz_last_token == NULL) {
 		status = DSP_EMEMORY;
 		goto func_cont;
 	}
-       strncpy(szSectName, (char *)(info->name), tokenLen);
-	pszCur = szSectName;
-	while ((pToken = strsep(&pszCur, ":")) && *pToken != '\0') {
-               strncpy(szSecLastToken, szLastToken, strlen(szLastToken) + 1);
-               strncpy(szLastToken, pToken, strlen(pToken) + 1);
-		pToken = strsep(&pszCur, ":");
-		count++; 	/* optimizes processing*/
-	}
-	/* If pToken is 0 or 1, and szSecLastToken is DYN_DARAM or DYN_SARAM,
-	 or DYN_EXTERNAL, then mem granularity information is present
-	 within the section name - only process if there are at least three
-	 tokens within the section name (just a minor optimization)*/
+	strncpy(sz_sect_name, (char *)(info->name), token_len);
+	psz_cur = sz_sect_name;
+	while ((token = strsep(&psz_cur, ":")) && *token != '\0') {
+		strncpy(sz_sec_last_token, sz_last_token,
+			strlen(sz_last_token) + 1);
+		strncpy(sz_last_token, token, strlen(token) + 1);
+		token = strsep(&psz_cur, ":");
+		count++;	/* optimizes processing */
+	}
+	/* If token is 0 or 1, and sz_sec_last_token is DYN_DARAM or DYN_SARAM,
+	   or DYN_EXTERNAL, then mem granularity information is present
+	   within the section name - only process if there are at least three
+	   tokens within the section name (just a minor optimization) */
 	if (count >= 3)
-               strict_strtol(szLastToken, 10, (long *)&req);
+		strict_strtol(sz_last_token, 10, (long *)&req);
 
 	if ((req == 0) || (req == 1)) {
-               if (strcmp(szSecLastToken, "DYN_DARAM") == 0) {
-			segId = 0;
+		if (strcmp(sz_sec_last_token, "DYN_DARAM") == 0) {
+			seg_id = 0;
 		} else {
-                       if (strcmp(szSecLastToken, "DYN_SARAM") == 0) {
-				segId = 1;
+			if (strcmp(sz_sec_last_token, "DYN_SARAM") == 0) {
+				seg_id = 1;
 			} else {
-                               if (strcmp(szSecLastToken,
-				   "DYN_EXTERNAL") == 0) {
-					segId = 2;
-				}
+				if (strcmp(sz_sec_last_token,
+					   "DYN_EXTERNAL") == 0)
+					seg_id = 2;
 			}
 		}
-		if (segId != -1) {
-			GT_2trace(DBLL_debugMask, GT_5CLASS,
-				 "Extracted values for memory"
-				 " granularity req [%d] segId [%d]\n",
-				 req, segId);
-		}
 	}
-	MEM_Free(szSectName);
-	szSectName = NULL;
-	MEM_Free(szLastToken);
-	szLastToken = NULL;
-	MEM_Free(szSecLastToken);
-	szSecLastToken = NULL;
 func_cont:
-	if (memType == DBLL_CODE)
-		allocSize = info->size + GEM_L1P_PREFETCH_SIZE;
+	kfree(sz_sect_name);
+	sz_sect_name = NULL;
+	kfree(sz_last_token);
+	sz_last_token = NULL;
+	kfree(sz_sec_last_token);
+	sz_sec_last_token = NULL;
+
+	if (mem_sect_type == DBLL_CODE)
+		alloc_size = info->size + GEM_L1P_PREFETCH_SIZE;
 	else
-		allocSize = info->size;
+		alloc_size = info->size;
+
+	if (info->load_addr != info->run_addr)
+		run_addr_flag = 1;
 	/* TODO - ideally, we can pass the alignment requirement also
 	 * from here */
 	if (lib != NULL) {
-		status = (lib->pTarget->attrs.alloc)(lib->pTarget->
-			 attrs.rmmHandle, memType, allocSize, align,
-			 (u32 *)&rmmAddr, segId, req, FALSE);
+		status =
+		    (lib->target_obj->attrs.alloc) (lib->target_obj->attrs.
+						    rmm_handle, mem_sect_type,
+						    alloc_size, align,
+						    (u32 *) &rmm_addr_obj,
+						    seg_id, req, FALSE);
 	}
 	if (DSP_FAILED(status)) {
-		retVal = false;
+		ret = false;
 	} else {
 		/* RMM gives word address. Need to convert to byte address */
-		info->load_addr = rmmAddr.addr * DSPWORDSIZE;
-		info->run_addr = info->load_addr;
-		info->context = (u32)rmmAddr.segid;
-		GT_3trace(DBLL_debugMask, GT_5CLASS,
-			 "Remote alloc: %s  base = 0x%lx len"
-			 "= 0x%lx\n", info->name, info->load_addr / DSPWORDSIZE,
-			 info->size / DSPWORDSIZE);
+		info->load_addr = rmm_addr_obj.addr * DSPWORDSIZE;
+		if (!run_addr_flag)
+			info->run_addr = info->load_addr;
+		info->context = (u32) rmm_addr_obj.segid;
+		dev_dbg(bridge, "%s: %s base = 0x%x len = 0x%x, "
+			"info->run_addr 0x%x, info->load_addr 0x%x\n",
+			__func__, info->name, info->load_addr / DSPWORDSIZE,
+			info->size / DSPWORDSIZE, info->run_addr,
+			info->load_addr);
 	}
-	return retVal;
+	return ret;
 }
 
 /*
- *  ======== rmmDealloc ========
+ *  ======== rmm_dealloc ========
  */
-static void rmmDealloc(struct Dynamic_Loader_Allocate *this,
-		       struct LDR_SECTION_INFO *info)
+static void rmm_dealloc(struct dynamic_loader_allocate *this,
+			struct ldr_section_info *info)
 {
-	struct DBLLAlloc *pAlloc = (struct DBLLAlloc *)this;
-	struct DBLL_LibraryObj *lib;
+	struct dbll_alloc *dbll_alloc_obj = (struct dbll_alloc *)this;
+	struct dbll_library_obj *lib;
 	u32 segid;
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 	unsigned stype = DLOAD_SECTION_TYPE(info->type);
-	u32 memType;
-	u32 freeSize = 0;
+	u32 mem_sect_type;
+	u32 free_size = 0;
 
-	memType = (stype == DLOAD_TEXT) ? DBLL_CODE : (stype == DLOAD_BSS) ?
-		  DBLL_BSS : DBLL_DATA;
-	DBC_Require(this != NULL);
-	lib = pAlloc->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	mem_sect_type =
+	    (stype == DLOAD_TEXT) ? DBLL_CODE : (stype ==
+						 DLOAD_BSS) ? DBLL_BSS :
+	    DBLL_DATA;
+	DBC_REQUIRE(this != NULL);
+	lib = dbll_alloc_obj->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 	/* segid was set by alloc function */
-	segid = (u32)info->context;
-	if (memType == DBLL_CODE)
-		freeSize = info->size + GEM_L1P_PREFETCH_SIZE;
+	segid = (u32) info->context;
+	if (mem_sect_type == DBLL_CODE)
+		free_size = info->size + GEM_L1P_PREFETCH_SIZE;
 	else
-		freeSize = info->size;
+		free_size = info->size;
 	if (lib != NULL) {
-		status = (lib->pTarget->attrs.free)(lib->pTarget->
-			 attrs.symHandle, segid, info->load_addr / DSPWORDSIZE,
-			 freeSize, false);
-	}
-	if (DSP_SUCCEEDED(status)) {
-		GT_2trace(DBLL_debugMask, GT_5CLASS,
-			 "Remote dealloc: base = 0x%lx len ="
-			 "0x%lx\n", info->load_addr / DSPWORDSIZE,
-			 freeSize / DSPWORDSIZE);
+		status =
+		    (lib->target_obj->attrs.free) (lib->target_obj->attrs.
+						   sym_handle, segid,
+						   info->load_addr /
+						   DSPWORDSIZE, free_size,
+						   false);
 	}
 }
 
-/* Dynamic_Loader_Initialize */
+/* dynamic_loader_initialize */
 /*
  *  ======== connect ========
  */
-static int connect(struct Dynamic_Loader_Initialize *this)
+static int connect(struct dynamic_loader_initialize *this)
 {
 	return true;
 }
 
 /*
- *  ======== readMem ========
+ *  ======== read_mem ========
  *  This function does not need to be implemented.
  */
-static int readMem(struct Dynamic_Loader_Initialize *this, void *buf,
-		  LDR_ADDR addr, struct LDR_SECTION_INFO *info,
-		  unsigned nbytes)
-{
-	struct DBLLInit *pInit = (struct DBLLInit *)this;
-	struct DBLL_LibraryObj *lib;
-	int bytesRead = 0;
-
-	DBC_Require(this != NULL);
-	lib = pInit->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
-	/* Need WMD_BRD_Read function */
-	return bytesRead;
+static int read_mem(struct dynamic_loader_initialize *this, void *buf,
+		    ldr_addr addr, struct ldr_section_info *info,
+		    unsigned nbytes)
+{
+	struct dbll_init_obj *init_obj = (struct dbll_init_obj *)this;
+	struct dbll_library_obj *lib;
+	int bytes_read = 0;
+
+	DBC_REQUIRE(this != NULL);
+	lib = init_obj->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
+	/* Need bridge_brd_read function */
+	return bytes_read;
 }
 
 /*
- *  ======== writeMem ========
- */
-static int writeMem(struct Dynamic_Loader_Initialize *this, void *buf,
-		   LDR_ADDR addr, struct LDR_SECTION_INFO *info,
-		   unsigned nBytes)
-{
-	struct DBLLInit *pInit = (struct DBLLInit *)this;
-	struct DBLL_LibraryObj *lib;
-	struct DBLL_TarObj *pTarget;
-	struct DBLL_SectInfo sectInfo;
-	u32 memType;
-	bool retVal = true;
-
-	DBC_Require(this != NULL);
-	lib = pInit->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
-
-	memType = (DLOAD_SECTION_TYPE(info->type) == DLOAD_TEXT) ? DBLL_CODE :
-		  DBLL_DATA;
-	if ((lib != NULL) &&
-	    ((pTarget = lib->pTarget) != NULL) &&
-	    (pTarget->attrs.write != NULL)) {
-		retVal = (*pTarget->attrs.write)(pTarget->attrs.wHandle,
-						 addr, buf, nBytes, memType);
-
-		if (pTarget->attrs.logWrite) {
-			sectInfo.name = info->name;
-			sectInfo.runAddr = info->run_addr;
-			sectInfo.loadAddr = info->load_addr;
-			sectInfo.size = info->size;
-			sectInfo.type = memType;
+ *  ======== write_mem ========
+ */
+static int write_mem(struct dynamic_loader_initialize *this, void *buf,
+		     ldr_addr addr, struct ldr_section_info *info,
+		     unsigned bytes)
+{
+	struct dbll_init_obj *init_obj = (struct dbll_init_obj *)this;
+	struct dbll_library_obj *lib;
+	struct dbll_tar_obj *target_obj;
+	struct dbll_sect_info sect_info;
+	u32 mem_sect_type;
+	bool ret = true;
+
+	DBC_REQUIRE(this != NULL);
+	lib = init_obj->lib;
+	if (!MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE))
+		return false;
+
+	target_obj = lib->target_obj;
+
+	mem_sect_type =
+	    (DLOAD_SECTION_TYPE(info->type) ==
+	     DLOAD_TEXT) ? DBLL_CODE : DBLL_DATA;
+	if (target_obj && target_obj->attrs.write) {
+		ret =
+		    (*target_obj->attrs.write) (target_obj->attrs.input_params,
+						addr, buf, bytes,
+						mem_sect_type);
+
+		if (target_obj->attrs.log_write) {
+			sect_info.name = info->name;
+			sect_info.sect_run_addr = info->run_addr;
+			sect_info.sect_load_addr = info->load_addr;
+			sect_info.size = info->size;
+			sect_info.type = mem_sect_type;
 			/* Pass the information about what we've written to
 			 * another module */
-			(*pTarget->attrs.logWrite)(
-				pTarget->attrs.logWriteHandle,
-				&sectInfo, addr, nBytes);
+			(*target_obj->attrs.log_write) (target_obj->attrs.
+							log_write_handle,
+							&sect_info, addr,
+							bytes);
 		}
 	}
-	return retVal;
+	return ret;
 }
 
 /*
- *  ======== fillMem ========
- *  Fill nBytes of memory at a given address with a given value by
+ *  ======== fill_mem ========
+ *  Fill bytes of memory at a given address with a given value by
  *  writing from a buffer containing the given value.  Write in
  *  sets of MAXEXPR (128) bytes to avoid large stack buffer issues.
  */
-static int fillMem(struct Dynamic_Loader_Initialize *this, LDR_ADDR addr,
-		   struct LDR_SECTION_INFO *info, unsigned nBytes,
-		   unsigned val)
-{
-	bool retVal = true;
-	char *pBuf;
-	struct DBLL_LibraryObj *lib;
-	struct DBLLInit *pInit = (struct DBLLInit *)this;
-
-	DBC_Require(this != NULL);
-	lib = pInit->lib;
-	pBuf = NULL;
-	/* Pass the NULL pointer to writeMem to get the start address of Shared
-	    memory. This is a trick to just get the start address, there is no
-	    writing taking place with this Writemem
-	*/
-	if ((lib->pTarget->attrs.write) != (DBLL_WriteFxn)NoOp)
-		writeMem(this, &pBuf, addr, info, 0);
-	if (pBuf)
-		memset(pBuf, val, nBytes);
+static int fill_mem(struct dynamic_loader_initialize *this, ldr_addr addr,
+		    struct ldr_section_info *info, unsigned bytes, unsigned val)
+{
+	bool ret = true;
+	char *pbuf;
+	struct dbll_library_obj *lib;
+	struct dbll_init_obj *init_obj = (struct dbll_init_obj *)this;
+
+	DBC_REQUIRE(this != NULL);
+	lib = init_obj->lib;
+	pbuf = NULL;
+	/* Pass the NULL pointer to write_mem to get the start address of Shared
+	   memory. This is a trick to just get the start address, there is no
+	   writing taking place with this Writemem
+	 */
+	if ((lib->target_obj->attrs.write) != (dbll_write_fxn) no_op)
+		write_mem(this, &pbuf, addr, info, 0);
+	if (pbuf)
+		memset(pbuf, val, bytes);
 
-	return retVal;
+	return ret;
 }
 
 /*
  *  ======== execute ========
  */
-static int execute(struct Dynamic_Loader_Initialize *this, LDR_ADDR start)
+static int execute(struct dynamic_loader_initialize *this, ldr_addr start)
 {
-	struct DBLLInit *pInit = (struct DBLLInit *)this;
-	struct DBLL_LibraryObj *lib;
-	bool retVal = true;
-
-	DBC_Require(this != NULL);
-	lib = pInit->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	struct dbll_init_obj *init_obj = (struct dbll_init_obj *)this;
+	struct dbll_library_obj *lib;
+	bool ret = true;
+
+	DBC_REQUIRE(this != NULL);
+	lib = init_obj->lib;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(lib, DBLL_LIBSIGNATURE));
 	/* Save entry point */
 	if (lib != NULL)
-		lib->entry = (u32)start;
+		lib->entry = (u32) start;
 
-	return retVal;
+	return ret;
 }
 
 /*
  *  ======== release ========
  */
-static void release(struct Dynamic_Loader_Initialize *this)
+static void release(struct dynamic_loader_initialize *this)
 {
 }
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/dev.c kernel-power-2.6.28.new/drivers/dsp/bridge/pmgr/dev.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/dev.c	2011-10-11 13:51:00.787165527 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/pmgr/dev.c	2011-10-23 08:22:37.637567000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implementation of Bridge Mini-driver device operations.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,104 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dev.c ========
- *  Description:
- *      Implementation of 'Bridge Mini-driver device operations.
- *
- *  Public Functions:
- *      DEV_BrdWriteFxn
- *      DEV_CreateDevice
- *      DEV_Create2
- *      DEV_Destroy2
- *      DEV_DestroyDevice
- *      DEV_GetChnlMgr
- *      DEV_GetCmmMgr
- *      DEV_GetCodMgr
- *      DEV_GetDehMgr
- *      DEV_GetDevNode
- *      DEV_GetDSPWordSize
- *      DEV_GetFirst
- *      DEV_GetIntfFxns
- *      DEV_GetIOMgr
- *      DEV_GetNext
- *      DEV_GetNodeManager
- *      DEV_GetSymbol
- *      DEV_GetWMDContext
- *      DEV_Exit
- *      DEV_Init
- *      DEV_InsertProcObject
- *      DEV_IsLocked
- *      DEV_NotifyClient
- *      DEV_RegisterNotify
- *      DEV_ReleaseCodMgr
- *      DEV_RemoveDevice
- *      DEV_RemoveProcObject
- *      DEV_SetChnlMgr
- *      DEV_SetMsgMgr
- *      DEV_SetLockOwner
- *      DEV_StartDevice
- *
- *  Private Functions:
- *      FxnNotImplemented
- *      InitCodMgr
- *      InsertDevObject
- *      IsValidHandle
- *      RemoveDevObject
- *      StoreInterfaceFxns
- *
- *! Revision History:
- *! ================
- *! 03-Jan-2005 hn  Support for IVA DEH
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping feature
- *! 09-Feb-2004 vp	Updated to support IVA.
- *! 24-Feb-2003 swa PMGR Code review comments incorporated.
- *! 29-Nov-2001 jeh Check for DSP_ENOTIMPL status of DEH create function.
- *! 05-Nov-2001 kc  Added support for DEH module.
- *! 05-Aug-2001 ag  Shared memory registration moved to WMD_IO_OnLoaded().
- *! 11-Jul-2001 jeh Moved MGR_Create() from DSP_Init() to DEV_StartDevice().
- *! 11-Apr-2001 rr: Removed CMM_RegisterGPPSMSeg.
- *! 02-Apr-2001 rr: CHNL_Create failure is printed out.
- *! 15-Jan-2001 jeh Removed call to IO_OnLoaded() from DEV_Create2().
- *! 13-Feb-2001 kc: DSP/BIOS Bridge name update.
- *! 15-Dec-2000 rr: Dev_Create2 returns error if NODE_CreateMgr fails.
- *! 05-Dec-2000 jeh Moved IO_OnLoaded() to PROC_Load. Added DEV_SetMsgMgr.
- *! 05-Dev-2000 ag  SM Heap for messaging registered via CMM_RegisterGPPSMSeg().
- *!                 SM heap base and size currently taken from registry.
- *! 29-Nov-2000 rr: Incorporated code review changes.
- *! 17-Nov-2000 jeh Added calls to get IO manager (IO_Create), IO_OnLoaded().
- *! 06-Oct-2000 rr: DEV_Destroy2 and DEV_Create2 added.
- *! 02-Oct-2000 rr: DEV_GetNodeManager added.
- *! 11-Aug-2000 ag: Added DEV_GetCmmMgr(), CMM_Init() & CMM_Exit().
- *!                 Removed <dspbridge/std.h> & <stdwin.h>, added <dspbridge/dbtype.h>
- *! 10-Aug-2000 rr: DEV_InsertProcObject/RemoveProcObject added.
- *!                 DEV_Cleanup calls PROC_Detach if it is a matching process.
- *! 27-Jul-2000 rr: DEV is in new directoy DEV and produces devlib.lib
- *! 17-Jul-2000 rr: DRV Object holds the list of Dev Objects. DEV gets
- *!                 the List and Next devices through DRV.
- *!                 DEV object has a back pointer to DRV Object.
- *! 06-Jun-2000 jeh Added DEV_GetSymbol().
- *! 09-May-2000 rr: dwMemBase has index for multiple windows need.
- *! 28-Feb-2000 rr: New GT Usage implemented.
- *! 03-Feb-2000 rr: GT and Module init/exit Changes.(Done up front from
- *!		    SERVICES)
- *! 31-Jan-2000 rr: Comments changed after code review.
- *! 21-Jan-2000 rr: windows.h, tchar.h, HMODULE removed. FreeLibrary replaced
- *!                 with LDR_FreeModule
- *! 17-Jan-2000 rr: CFG_Get/SetPrivateDword renamed to CFG_Get/SetDevObject.
- *!                 StoreInterfaceFxns stores the new fxn WMD_BRD_SETSTATE.
- *! 20-Nov-1999 ag: Actual uSMLength =  total - monitor offset.
- *! 12-Nov-1999 rr: bIRQ and IRQAttrib taken from the struct CFG_HOSTRES.
- *!		    dMemBase is added with offset for monitor taken from
- *!		    registry.
- *! 31-Oct-1999 ag: Added CHNL support.
- *! 10-Sep-1999 rr: GT Enabled. DEV_Create will Load the Mini Driver and will
- *!                 find its fxn table. Right now lot of things are hardcoded
- *!                 as the REG is not ready.
- *! 10-Jun-1996 rr: Created from WSX
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -122,15 +26,12 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/dbg.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/cfg.h>
 #include <dspbridge/ldr.h>
 #include <dspbridge/list.h>
 #include <dspbridge/mem.h>
-#include <dspbridge/util.h>
 
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/cod.h>
@@ -143,8 +44,7 @@
 #include <dspbridge/node.h>
 
 /*  ----------------------------------- Others */
-#include <dspbridge/dbreg.h>
-#include <dspbridge/wcd.h>		/* WCD version info. */
+#include <dspbridge/wcd.h>	/* WCD version info. */
 
 #include <dspbridge/chnl.h>
 #include <dspbridge/io.h>
@@ -161,1027 +61,873 @@
 #define WCDVERSION          MAKEVERSION(WCD_MAJOR_VERSION, WCD_MINOR_VERSION)
 
 /* The WMD device object: */
-struct DEV_OBJECT {
-	/* LST requires "link" to be first field!                        */
-	struct LST_ELEM link;		/* Link to next DEV_OBJECT.      */
-	u32 devType;		/* Device Type */
-	u32 dwSignature;	/* Used for object validation.   */
-	struct CFG_DEVNODE *hDevNode;	/* Platform specific device id   */
-	struct WMD_DEV_CONTEXT *hWmdContext;	/* WMD Context Handle        */
-	struct WMD_DRV_INTERFACE intfFxns;	/* Function interface to WMD. */
-	struct BRD_OBJECT *lockOwner;	/* Client with exclusive access. */
-	struct COD_MANAGER *hCodMgr;	/* Code manager handle.          */
-	struct CHNL_MGR *hChnlMgr;	/* Channel manager.              */
-	struct DEH_MGR *hDehMgr;	/* DEH manager.                  */
-	struct MSG_MGR *hMsgMgr;	/* Message manager.              */
-	struct IO_MGR *hIOMgr;		/* IO manager (CHNL, MSG)        */
-	struct CMM_OBJECT *hCmmMgr;	/* SM memory manager.            */
-	struct DMM_OBJECT *hDmmMgr;	/* Dynamic memory manager.       */
-	struct LDR_MODULE *hModule;	/* WMD Module handle.            */
-	u32 uWordSize;	/* DSP word size: quick access.  */
-	struct DRV_OBJECT *hDrvObject;	/* Driver Object                 */
-	struct LST_LIST *procList;	/* List of Proceeosr attached to
-				 * this device  */
-	struct NODE_MGR *hNodeMgr;
-} ;
+struct dev_object {
+	/* LST requires "link" to be first field! */
+	struct list_head link;	/* Link to next dev_object. */
+	u32 dev_type;		/* Device Type */
+	u32 dw_signature;	/* Used for object validation. */
+	struct cfg_devnode *dev_node_obj;	/* Platform specific dev id */
+	struct wmd_dev_context *hwmd_context;	/* WMD Context Handle */
+	struct bridge_drv_interface wmd_interface;	/* Function interface to WMD. */
+	struct brd_object *lock_owner;	/* Client with exclusive access. */
+	struct cod_manager *cod_mgr;	/* Code manager handle. */
+	struct chnl_mgr *hchnl_mgr;	/* Channel manager. */
+	struct deh_mgr *hdeh_mgr;	/* DEH manager. */
+	struct msg_mgr *hmsg_mgr;	/* Message manager. */
+	struct io_mgr *hio_mgr;	/* IO manager (CHNL, msg_ctrl) */
+	struct cmm_object *hcmm_mgr;	/* SM memory manager. */
+	struct dmm_object *dmm_mgr;	/* Dynamic memory manager. */
+	struct ldr_module *module_obj;	/* WMD Module handle. */
+	u32 word_size;		/* DSP word size: quick access. */
+	struct drv_object *hdrv_obj;	/* Driver Object */
+	struct lst_list *proc_list;	/* List of Proceeosr attached to
+					 * this device */
+	struct node_mgr *hnode_mgr;
+};
 
 /*  ----------------------------------- Globals */
-static u32 cRefs;		/* Module reference count */
-#if GT_TRACE
-static struct GT_Mask debugMask = { NULL, NULL };	/* For debugging */
-#endif
+static u32 refs;		/* Module reference count */
 
 /*  ----------------------------------- Function Prototypes */
-static DSP_STATUS FxnNotImplemented(int arg, ...);
-static DSP_STATUS InitCodMgr(struct DEV_OBJECT *pDevObject);
-static bool IsValidHandle(struct DEV_OBJECT *hObj);
-static void StoreInterfaceFxns(struct WMD_DRV_INTERFACE *pDrvFxns,
-			       OUT struct WMD_DRV_INTERFACE *pIntfFxns);
+static dsp_status fxn_not_implemented(int arg, ...);
+static dsp_status init_cod_mgr(struct dev_object *dev_obj);
+static bool IS_VALID_HANDLE(struct dev_object *hObj);
+static void store_interface_fxns(struct bridge_drv_interface *drv_fxns,
+				 OUT struct bridge_drv_interface *intf_fxns);
 /*
- *  ======== DEV_BrdWriteFxn ========
+ *  ======== dev_brd_write_fxn ========
  *  Purpose:
  *      Exported function to be used as the COD write function.  This function
  *      is passed a handle to a DEV_hObject, then calls the
- *      device's WMD_BRD_Write() function.
+ *      device's bridge_brd_write() function.
  */
-u32 DEV_BrdWriteFxn(void *pArb, u32 ulDspAddr, void *pHostBuf,
-		      u32 ulNumBytes, u32 nMemSpace)
+u32 dev_brd_write_fxn(void *pArb, u32 ulDspAddr, void *pHostBuf,
+		      u32 ul_num_bytes, u32 nMemSpace)
 {
-	struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)pArb;
-	u32 ulWritten = 0;
-	DSP_STATUS status;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pHostBuf != NULL);	/* Required of BrdWrite(). */
-	GT_5trace(debugMask, GT_ENTER,
-		"Entered DEV_BrdWriteFxn, pArb: 0x%x\n\t\t"
-		"ulDspAddr: 0x%x\n\t\tpHostBuf: 0x%x\n \t\tulNumBytes:  0x%x\n"
-		"\t\tnMemSpace:  0x%x\n", pArb, ulDspAddr, pHostBuf,
-		ulNumBytes, nMemSpace);
-	if (IsValidHandle(pDevObject)) {
+	struct dev_object *dev_obj = (struct dev_object *)pArb;
+	u32 ul_written = 0;
+	dsp_status status;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pHostBuf != NULL);	/* Required of BrdWrite(). */
+	if (IS_VALID_HANDLE(dev_obj)) {
 		/* Require of BrdWrite() */
-		DBC_Assert(pDevObject->hWmdContext != NULL);
-		status = (*pDevObject->intfFxns.pfnBrdWrite)(pDevObject->
-			 hWmdContext, pHostBuf, ulDspAddr, ulNumBytes,
-			 nMemSpace);
-		 /* Special case of getting the address only */
-		if (ulNumBytes == 0)
-			ulNumBytes = 1;
+		DBC_ASSERT(dev_obj->hwmd_context != NULL);
+		status =
+		    (*dev_obj->wmd_interface.
+		     pfn_brd_write) (dev_obj->hwmd_context, pHostBuf, ulDspAddr,
+				     ul_num_bytes, nMemSpace);
+		/* Special case of getting the address only */
+		if (ul_num_bytes == 0)
+			ul_num_bytes = 1;
 		if (DSP_SUCCEEDED(status))
-			ulWritten = ulNumBytes;
+			ul_written = ul_num_bytes;
 
 	}
-	GT_1trace(debugMask, GT_ENTER, "Exit DEV_BrdWriteFxn ulWritten: 0x%x\n",
-		  ulWritten);
-	return ulWritten;
+	return ul_written;
 }
 
 /*
- *  ======== DEV_CreateDevice ========
+ *  ======== dev_create_device ========
  *  Purpose:
  *      Called by the operating system to load the PM Mini Driver for a
  *      PM board (device).
  */
-DSP_STATUS DEV_CreateDevice(OUT struct DEV_OBJECT **phDevObject,
-			    IN CONST char *pstrWMDFileName,
-			    IN CONST struct CFG_HOSTRES *pHostConfig,
-			    IN CONST struct CFG_DSPRES *pDspConfig,
-			    struct CFG_DEVNODE *hDevNode)
-{
-	struct LDR_MODULE *hModule = NULL;
-	struct WMD_DRV_INTERFACE *pDrvFxns = NULL;
-	struct DEV_OBJECT *pDevObject = NULL;
-	struct CHNL_MGRATTRS mgrAttrs;
-	struct IO_ATTRS ioMgrAttrs;
-	u32 uNumWindows;
-	struct DRV_OBJECT *hDrvObject = NULL;
-	DSP_STATUS status = DSP_SOK;
-	DBC_Require(cRefs > 0);
-	DBC_Require(phDevObject != NULL);
-	DBC_Require(pstrWMDFileName != NULL);
-	DBC_Require(pHostConfig != NULL);
-	DBC_Require(pDspConfig != NULL);
-
-	GT_5trace(debugMask, GT_ENTER,
-		  "Entered DEV_CreateDevice, phDevObject: 0x%x\n"
-		  "\t\tpstrWMDFileName:  0x%x\n\t\tpHostConfig:0x%x\n\t\t"
-		  "pDspConfig:  0x%x\n\t\tnhDevNode:  0x%x\n", phDevObject,
-		  pstrWMDFileName, pHostConfig, pDspConfig, hDevNode);
-	/*  Get the WMD interface functions*/
-	WMD_DRV_Entry(&pDrvFxns, pstrWMDFileName);
-	if (DSP_FAILED(CFG_GetObject((u32 *) &hDrvObject, REG_DRV_OBJECT))) {
+dsp_status dev_create_device(OUT struct dev_object **phDevObject,
+			     IN CONST char *pstrWMDFileName,
+			     IN CONST struct cfg_hostres *pHostConfig,
+			     IN CONST struct cfg_dspres *pDspConfig,
+			     struct cfg_devnode *dev_node_obj)
+{
+	struct ldr_module *module_obj = NULL;
+	struct bridge_drv_interface *drv_fxns = NULL;
+	struct dev_object *dev_obj = NULL;
+	struct chnl_mgrattrs mgr_attrs;
+	struct io_attrs io_mgr_attrs;
+	u32 num_windows;
+	struct drv_object *hdrv_obj = NULL;
+	dsp_status status = DSP_SOK;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phDevObject != NULL);
+	DBC_REQUIRE(pstrWMDFileName != NULL);
+	DBC_REQUIRE(pHostConfig != NULL);
+	DBC_REQUIRE(pDspConfig != NULL);
+
+	/*  Get the WMD interface functions */
+	bridge_drv_entry(&drv_fxns, pstrWMDFileName);
+	if (DSP_FAILED(cfg_get_object((u32 *) &hdrv_obj, REG_DRV_OBJECT))) {
 		/* don't propogate CFG errors from this PROC function */
-		GT_0trace(debugMask, GT_7CLASS,
-			  "Failed to get the DRV Object \n");
 		status = DSP_EFAIL;
 	}
 	/* Create the device object, and pass a handle to the WMD for
 	 * storage. */
 	if (DSP_SUCCEEDED(status)) {
-		DBC_Assert(pDrvFxns);
-		MEM_AllocObject(pDevObject, struct DEV_OBJECT, SIGNATURE);
-		if (pDevObject) {
+		DBC_ASSERT(drv_fxns);
+		MEM_ALLOC_OBJECT(dev_obj, struct dev_object, SIGNATURE);
+		if (dev_obj) {
 			/* Fill out the rest of the Dev Object structure: */
-			pDevObject->hDevNode = hDevNode;
-			pDevObject->hModule = hModule;
-			pDevObject->hCodMgr = NULL;
-			pDevObject->hChnlMgr = NULL;
-			pDevObject->hDehMgr = NULL;
-			pDevObject->lockOwner = NULL;
-			pDevObject->uWordSize = pDspConfig->uWordSize;
-			pDevObject->hDrvObject = hDrvObject;
-			pDevObject->devType = DSP_UNIT;
+			dev_obj->dev_node_obj = dev_node_obj;
+			dev_obj->module_obj = module_obj;
+			dev_obj->cod_mgr = NULL;
+			dev_obj->hchnl_mgr = NULL;
+			dev_obj->hdeh_mgr = NULL;
+			dev_obj->lock_owner = NULL;
+			dev_obj->word_size = pDspConfig->word_size;
+			dev_obj->hdrv_obj = hdrv_obj;
+			dev_obj->dev_type = DSP_UNIT;
 			/* Store this WMD's interface functions, based on its
 			 * version. */
-			StoreInterfaceFxns(pDrvFxns, &pDevObject->intfFxns);
-			/* Call WMD_DEV_CREATE() to get the WMD's device
+			store_interface_fxns(drv_fxns, &dev_obj->wmd_interface);
+			/* Call fxn_dev_create() to get the WMD's device
 			 * context handle. */
-			status = (pDevObject->intfFxns.pfnDevCreate)
-				 (&pDevObject->hWmdContext, pDevObject,
-				 pHostConfig, pDspConfig);
-			/* Assert WMD_DEV_Create()'s ensure clause: */
-			DBC_Assert(DSP_FAILED(status) || (pDevObject->
-				   hWmdContext != NULL));
+			status = (dev_obj->wmd_interface.pfn_dev_create)
+			    (&dev_obj->hwmd_context, dev_obj,
+			     pHostConfig, pDspConfig);
+			/* Assert bridge_dev_create()'s ensure clause: */
+			DBC_ASSERT(DSP_FAILED(status)
+				   || (dev_obj->hwmd_context != NULL));
 		} else {
-			GT_0trace(debugMask, GT_7CLASS,
-				  "DEV_Create: Out Of Memory");
 			status = DSP_EMEMORY;
 		}
 	}
 	/* Attempt to create the COD manager for this device: */
 	if (DSP_SUCCEEDED(status))
-		status = InitCodMgr(pDevObject);
+		status = init_cod_mgr(dev_obj);
 
 	/* Attempt to create the channel manager for this device: */
 	if (DSP_SUCCEEDED(status)) {
-		mgrAttrs.cChannels = CHNL_MAXCHANNELS;
-		ioMgrAttrs.bIRQ = pHostConfig->bIRQRegisters;
-		ioMgrAttrs.fShared = (pHostConfig->bIRQAttrib & CFG_IRQSHARED);
-		ioMgrAttrs.uWordSize = pDspConfig->uWordSize;
-		mgrAttrs.uWordSize = pDspConfig->uWordSize;
-		uNumWindows = pHostConfig->wNumMemWindows;
-		if (uNumWindows) {
+		mgr_attrs.max_channels = CHNL_MAXCHANNELS;
+		io_mgr_attrs.birq = pHostConfig->birq_registers;
+		io_mgr_attrs.irq_shared =
+		    (pHostConfig->birq_attrib & CFG_IRQSHARED);
+		io_mgr_attrs.word_size = pDspConfig->word_size;
+		mgr_attrs.word_size = pDspConfig->word_size;
+		num_windows = pHostConfig->num_mem_windows;
+		if (num_windows) {
 			/* Assume last memory window is for CHNL */
-			ioMgrAttrs.dwSMBase = pHostConfig->dwMemBase[1] +
-					      pHostConfig->dwOffsetForMonitor;
-			ioMgrAttrs.uSMLength = pHostConfig->dwMemLength[1] -
-					       pHostConfig->dwOffsetForMonitor;
+			io_mgr_attrs.shm_base = pHostConfig->dw_mem_base[1] +
+			    pHostConfig->dw_offset_for_monitor;
+			io_mgr_attrs.usm_length =
+			    pHostConfig->dw_mem_length[1] -
+			    pHostConfig->dw_offset_for_monitor;
 		} else {
-			ioMgrAttrs.dwSMBase = 0;
-			ioMgrAttrs.uSMLength = 0;
-			GT_0trace(debugMask, GT_7CLASS,
-				  "**There is no memory reserved for "
-				  "shared structures**\n");
+			io_mgr_attrs.shm_base = 0;
+			io_mgr_attrs.usm_length = 0;
+			pr_err("%s: No memory reserved for shared structures\n",
+			       __func__);
 		}
-		status = CHNL_Create(&pDevObject->hChnlMgr, pDevObject,
-				    &mgrAttrs);
+		status = chnl_create(&dev_obj->hchnl_mgr, dev_obj, &mgr_attrs);
 		if (status == DSP_ENOTIMPL) {
 			/* It's OK for a device not to have a channel
 			 * manager: */
 			status = DSP_SOK;
 		}
-		/* Create CMM mgr even if Msg Mgr not impl.  */
-		status = CMM_Create(&pDevObject->hCmmMgr,
-				   (struct DEV_OBJECT *)pDevObject, NULL);
-		if (DSP_FAILED(status)) {
-			GT_0trace(debugMask, GT_7CLASS,
-				  "DEV_Create: Failed to Create SM "
-				  "Manager\n");
-		}
+		/* Create CMM mgr even if Msg Mgr not impl. */
+		status = cmm_create(&dev_obj->hcmm_mgr,
+				    (struct dev_object *)dev_obj, NULL);
 		/* Only create IO manager if we have a channel manager */
-		if (DSP_SUCCEEDED(status) && pDevObject->hChnlMgr) {
-			status = IO_Create(&pDevObject->hIOMgr, pDevObject,
-					   &ioMgrAttrs);
+		if (DSP_SUCCEEDED(status) && dev_obj->hchnl_mgr) {
+			status = io_create(&dev_obj->hio_mgr, dev_obj,
+					   &io_mgr_attrs);
 		}
 		/* Only create DEH manager if we have an IO manager */
 		if (DSP_SUCCEEDED(status)) {
 			/* Instantiate the DEH module */
-			status = (*pDevObject->intfFxns.pfnDehCreate)
-				 (&pDevObject->hDehMgr, 	pDevObject);
-		}
-		/* Create DMM mgr .  */
-		status = DMM_Create(&pDevObject->hDmmMgr,
-				   (struct DEV_OBJECT *)pDevObject, NULL);
-		if (DSP_FAILED(status)) {
-			GT_0trace(debugMask, GT_7CLASS,
-				  "DEV_Create: Failed to Create DMM "
-				  "Manager\n");
+			status = (*dev_obj->wmd_interface.pfn_deh_create)
+			    (&dev_obj->hdeh_mgr, dev_obj);
 		}
+		/* Create DMM mgr . */
+		status = dmm_create(&dev_obj->dmm_mgr,
+				    (struct dev_object *)dev_obj, NULL);
 	}
 	/* Add the new DEV_Object to the global list: */
 	if (DSP_SUCCEEDED(status)) {
-		LST_InitElem(&pDevObject->link);
-		status = DRV_InsertDevObject(hDrvObject, pDevObject);
+		lst_init_elem(&dev_obj->link);
+		status = drv_insert_dev_object(hdrv_obj, dev_obj);
 	}
 	/* Create the Processor List */
 	if (DSP_SUCCEEDED(status)) {
-		pDevObject->procList = LST_Create();
-		if (!(pDevObject->procList)) {
+		dev_obj->proc_list = mem_calloc(sizeof(struct lst_list),
+						MEM_NONPAGED);
+		if (!(dev_obj->proc_list))
 			status = DSP_EFAIL;
-			GT_0trace(debugMask, GT_7CLASS, "DEV_Create: "
-				 "Failed to Create Proc List");
-		}
+		else
+			INIT_LIST_HEAD(&dev_obj->proc_list->head);
 	}
-	 /*  If all went well, return a handle to the dev object;
-	 *  else, cleanup and return NULL in the OUT parameter.  */
+	/*  If all went well, return a handle to the dev object;
+	 *  else, cleanup and return NULL in the OUT parameter. */
 	if (DSP_SUCCEEDED(status)) {
-		*phDevObject = pDevObject;
-		GT_1trace(debugMask, GT_1CLASS,
-			 "DEV_CreateDevice Succeeded \nDevObject "
-			 "0x%x\n", pDevObject);
+		*phDevObject = dev_obj;
 	} else {
-		if (pDevObject && pDevObject->procList)
-			LST_Delete(pDevObject->procList);
+		kfree(dev_obj->proc_list);
 
-		if (pDevObject && pDevObject->hCodMgr)
-			COD_Delete(pDevObject->hCodMgr);
+		if (dev_obj && dev_obj->cod_mgr)
+			cod_delete(dev_obj->cod_mgr);
 
-		if (pDevObject && pDevObject->hDmmMgr)
-			DMM_Destroy(pDevObject->hDmmMgr);
+		if (dev_obj && dev_obj->dmm_mgr)
+			dmm_destroy(dev_obj->dmm_mgr);
 
-		if (pDevObject)
-			MEM_FreeObject(pDevObject);
+		if (dev_obj)
+			MEM_FREE_OBJECT(dev_obj);
 
 		*phDevObject = NULL;
-		GT_0trace(debugMask, GT_7CLASS, "DEV_CreateDevice Failed\n");
 	}
-	GT_1trace(debugMask, GT_1CLASS, "Exiting DEV_Create: DevObject 0x%x\n",
-		 *phDevObject);
-	DBC_Ensure((DSP_SUCCEEDED(status) && IsValidHandle(*phDevObject)) ||
-		  (DSP_FAILED(status) && !*phDevObject));
+
+	DBC_ENSURE((DSP_SUCCEEDED(status) && IS_VALID_HANDLE(*phDevObject)) ||
+		   (DSP_FAILED(status) && !*phDevObject));
 	return status;
 }
 
 /*
- *  ======== DEV_Create2 ========
+ *  ======== dev_create2 ========
  *  Purpose:
- *      After successful loading of the image from WCD_InitComplete2
- *      (PROC Auto_Start) or PROC_Load this fxn is called. This creates
+ *      After successful loading of the image from wcd_init_complete2
+ *      (PROC Auto_Start) or proc_load this fxn is called. This creates
  *      the Node Manager and updates the DEV Object.
  */
-DSP_STATUS DEV_Create2(struct DEV_OBJECT *hDevObject)
+dsp_status dev_create2(struct dev_object *hdev_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValidHandle(hDevObject));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID_HANDLE(hdev_obj));
 
-	GT_1trace(debugMask, GT_ENTER,
-		 "Entered DEV_Create2, hDevObject: 0x%x\n", hDevObject);
 	/* There can be only one Node Manager per DEV object */
-	DBC_Assert(!pDevObject->hNodeMgr);
-	status = NODE_CreateMgr(&pDevObject->hNodeMgr, hDevObject);
-	if (DSP_FAILED(status)) {
-		GT_1trace(debugMask, GT_7CLASS,
-			 "DEV_Create2: NODE_CreateMgr failed, "
-			 "0x%x!\n", status);
-		pDevObject->hNodeMgr = NULL;
-		GT_0trace(debugMask, GT_7CLASS, "DEV_Create2: Failed!!\n");
-	}
-	DBC_Ensure((DSP_SUCCEEDED(status) && pDevObject->hNodeMgr != NULL)
-		   || (DSP_FAILED(status) && pDevObject->hNodeMgr == NULL));
-	GT_2trace(debugMask, GT_ENTER,
-		  "Exiting DEV_Create2, hNodeMgr:  0x%x, status:"
-		  " 0x%x\n", pDevObject->hNodeMgr, status);
+	DBC_ASSERT(!dev_obj->hnode_mgr);
+	status = node_create_mgr(&dev_obj->hnode_mgr, hdev_obj);
+	if (DSP_FAILED(status))
+		dev_obj->hnode_mgr = NULL;
+
+	DBC_ENSURE((DSP_SUCCEEDED(status) && dev_obj->hnode_mgr != NULL)
+		   || (DSP_FAILED(status) && dev_obj->hnode_mgr == NULL));
 	return status;
 }
 
 /*
- *  ======== DEV_Destroy2 ========
+ *  ======== dev_destroy2 ========
  *  Purpose:
  *      Destroys the Node manager for this device.
  */
-DSP_STATUS DEV_Destroy2(struct DEV_OBJECT *hDevObject)
+dsp_status dev_destroy2(struct dev_object *hdev_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValidHandle(hDevObject));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID_HANDLE(hdev_obj));
 
-	GT_1trace(debugMask, GT_ENTER,
-		 "Entered DEV_Destroy2, hDevObject: 0x%x\n",
-		 hDevObject);
-	if (pDevObject->hNodeMgr) {
-		if (DSP_FAILED(NODE_DeleteMgr(pDevObject->hNodeMgr)))
+	if (dev_obj->hnode_mgr) {
+		if (DSP_FAILED(node_delete_mgr(dev_obj->hnode_mgr)))
 			status = DSP_EFAIL;
 		else
-			pDevObject->hNodeMgr = NULL;
+			dev_obj->hnode_mgr = NULL;
 
 	}
-	if (DSP_FAILED(status))
-		GT_0trace(debugMask, GT_7CLASS, "DEV_Destroy2 failed!!\n");
 
-	DBC_Ensure((DSP_SUCCEEDED(status) && pDevObject->hNodeMgr == NULL) ||
-		  DSP_FAILED(status));
-	GT_2trace(debugMask, GT_ENTER,
-		 "Exiting DEV_Destroy2, hNodeMgr: 0x%x, status"
-		 " = 0x%x\n", pDevObject->hNodeMgr, status);
+	DBC_ENSURE((DSP_SUCCEEDED(status) && dev_obj->hnode_mgr == NULL) ||
+		   DSP_FAILED(status));
 	return status;
 }
 
 /*
- *  ======== DEV_DestroyDevice ========
+ *  ======== dev_destroy_device ========
  *  Purpose:
  *      Destroys the channel manager for this device, if any, calls
- *      WMD_DEV_Destroy(), and then attempts to unload the WMD module.
+ *      bridge_dev_destroy(), and then attempts to unload the WMD module.
  */
-DSP_STATUS DEV_DestroyDevice(struct DEV_OBJECT *hDevObject)
+dsp_status dev_destroy_device(struct dev_object *hdev_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	GT_1trace(debugMask, GT_ENTER, "Entered DEV_DestroyDevice, hDevObject: "
-		 "0x%x\n", hDevObject);
-	if (IsValidHandle(hDevObject)) {
-		if (pDevObject->hCodMgr)
-			COD_Delete(pDevObject->hCodMgr);
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		if (dev_obj->cod_mgr) {
+			cod_delete(dev_obj->cod_mgr);
+			dev_obj->cod_mgr = NULL;
+		}
 
-		if (pDevObject->hNodeMgr)
-			NODE_DeleteMgr(pDevObject->hNodeMgr);
+		if (dev_obj->hnode_mgr) {
+			node_delete_mgr(dev_obj->hnode_mgr);
+			dev_obj->hnode_mgr = NULL;
+		}
 
 		/* Free the io, channel, and message managers for this board: */
-		if (pDevObject->hIOMgr) {
-			IO_Destroy(pDevObject->hIOMgr);
-			pDevObject->hIOMgr = NULL;
+		if (dev_obj->hio_mgr) {
+			io_destroy(dev_obj->hio_mgr);
+			dev_obj->hio_mgr = NULL;
 		}
-		if (pDevObject->hChnlMgr) {
-			CHNL_Destroy(pDevObject->hChnlMgr);
-			pDevObject->hChnlMgr = NULL;
+		if (dev_obj->hchnl_mgr) {
+			chnl_destroy(dev_obj->hchnl_mgr);
+			dev_obj->hchnl_mgr = NULL;
+		}
+		if (dev_obj->hmsg_mgr) {
+			msg_delete(dev_obj->hmsg_mgr);
+			dev_obj->hmsg_mgr = NULL;
 		}
-		if (pDevObject->hMsgMgr)
-			MSG_Delete(pDevObject->hMsgMgr);
 
-		if (pDevObject->hDehMgr) {
+		if (dev_obj->hdeh_mgr) {
 			/* Uninitialize DEH module. */
-			(*pDevObject->intfFxns.pfnDehDestroy)
-			(pDevObject->hDehMgr);
+			(*dev_obj->wmd_interface.pfn_deh_destroy)
+			    (dev_obj->hdeh_mgr);
+			dev_obj->hdeh_mgr = NULL;
+		}
+		if (dev_obj->hcmm_mgr) {
+			cmm_destroy(dev_obj->hcmm_mgr, true);
+			dev_obj->hcmm_mgr = NULL;
 		}
-		if (pDevObject->hCmmMgr)
-			CMM_Destroy(pDevObject->hCmmMgr, true);
 
-		if (pDevObject->hDmmMgr)
-			DMM_Destroy(pDevObject->hDmmMgr);
+		if (dev_obj->dmm_mgr) {
+			dmm_destroy(dev_obj->dmm_mgr);
+			dev_obj->dmm_mgr = NULL;
+		}
 
-		/* Call the driver's WMD_DEV_Destroy() function: */
+		/* Call the driver's bridge_dev_destroy() function: */
 		/* Require of DevDestroy */
-		DBC_Assert(pDevObject->hWmdContext != NULL);
-		status = (*pDevObject->intfFxns.pfnDevDestroy)
-			 (pDevObject->hWmdContext);
+		if (dev_obj->hwmd_context) {
+			status = (*dev_obj->wmd_interface.pfn_dev_destroy)
+			    (dev_obj->hwmd_context);
+			dev_obj->hwmd_context = NULL;
+		} else
+			status = DSP_EFAIL;
 		if (DSP_SUCCEEDED(status)) {
-			if (pDevObject->procList)
-				LST_Delete(pDevObject->procList);
+			kfree(dev_obj->proc_list);
+			dev_obj->proc_list = NULL;
 
 			/* Remove this DEV_Object from the global list: */
-			DRV_RemoveDevObject(pDevObject->hDrvObject, pDevObject);
+			drv_remove_dev_object(dev_obj->hdrv_obj, dev_obj);
 			/* Free The library * LDR_FreeModule
-			 * (pDevObject->hModule);*/
+			 * (dev_obj->module_obj); */
 			/* Free this dev object: */
-			MEM_FreeObject(pDevObject);
+			MEM_FREE_OBJECT(dev_obj);
+			dev_obj = NULL;
 		}
 	} else {
-		GT_0trace(debugMask, GT_7CLASS, "DEV_Destroy: Invlaid handle");
 		status = DSP_EHANDLE;
 	}
-	GT_1trace(debugMask, GT_ENTER, "Exit DEV_destroy: status 0x%x\n",
-		 status);
+
 	return status;
 }
 
 /*
- *  ======== DEV_GetChnlMgr ========
+ *  ======== dev_get_chnl_mgr ========
  *  Purpose:
  *      Retrieve the handle to the channel manager handle created for this
  *      device.
  */
-DSP_STATUS DEV_GetChnlMgr(struct DEV_OBJECT *hDevObject,
-			 OUT struct CHNL_MGR **phMgr)
+dsp_status dev_get_chnl_mgr(struct dev_object *hdev_obj,
+			    OUT struct chnl_mgr **phMgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phMgr != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phMgr != NULL);
 
-	GT_2trace(debugMask, GT_ENTER,
-		 "Entered DEV_GetChnlMgr, hDevObject: 0x%x\n\t"
-		 "\tphMgr: 0x%x\n", hDevObject, phMgr);
-	if (IsValidHandle(hDevObject)) {
-		*phMgr = pDevObject->hChnlMgr;
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phMgr = dev_obj->hchnl_mgr;
 	} else {
 		*phMgr = NULL;
 		status = DSP_EHANDLE;
-		GT_0trace(debugMask, GT_7CLASS,
-			 "DEV_GetChnlMgr: Invalid handle");
 	}
-	GT_2trace(debugMask, GT_ENTER,
-		 "Exit DEV_GetChnlMgr: status 0x%x\t\n hMgr: "
-		 "0x%x\n", status, *phMgr);
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
-		  (*phMgr == NULL)));
+
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
+					     (*phMgr == NULL)));
 	return status;
 }
 
 /*
- *  ======== DEV_GetCmmMgr ========
+ *  ======== dev_get_cmm_mgr ========
  *  Purpose:
  *      Retrieve the handle to the shared memory manager created for this
  *      device.
  */
-DSP_STATUS DEV_GetCmmMgr(struct DEV_OBJECT *hDevObject,
-			OUT struct CMM_OBJECT **phMgr)
+dsp_status dev_get_cmm_mgr(struct dev_object *hdev_obj,
+			   OUT struct cmm_object **phMgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phMgr != NULL);
-	GT_2trace(debugMask, GT_ENTER,
-		 "Entered DEV_GetCmmMgr, hDevObject:  0x%x\n\t"
-		 "\tphMgr:  0x%x\n", hDevObject, phMgr);
-	if (IsValidHandle(hDevObject)) {
-		*phMgr = pDevObject->hCmmMgr;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phMgr != NULL);
+
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phMgr = dev_obj->hcmm_mgr;
 	} else {
 		*phMgr = NULL;
 		status = DSP_EHANDLE;
-		GT_0trace(debugMask, GT_7CLASS,
-			 "DEV_GetCmmMgr: Invalid handle");
 	}
-	GT_2trace(debugMask, GT_ENTER,
-		 "Exit DEV_GetCmmMgr: status 0x%x\t\nhMgr: "
-		 "0x%x\n", status, *phMgr);
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
-		  (*phMgr == NULL)));
+
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
+					     (*phMgr == NULL)));
 	return status;
 }
 
 /*
- *  ======== DEV_GetDmmMgr ========
+ *  ======== dev_get_dmm_mgr ========
  *  Purpose:
  *      Retrieve the handle to the dynamic memory manager created for this
  *      device.
  */
-DSP_STATUS DEV_GetDmmMgr(struct DEV_OBJECT *hDevObject,
-			OUT struct DMM_OBJECT **phMgr)
+dsp_status dev_get_dmm_mgr(struct dev_object *hdev_obj,
+			   OUT struct dmm_object **phMgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phMgr != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phMgr != NULL);
 
-	GT_2trace(debugMask, GT_ENTER, "Entered DEV_GetDmmMgr, hDevObject: "
-		 "0x%x\n\t\tphMgr: 0x%x\n", hDevObject, phMgr);
-	if (IsValidHandle(hDevObject)) {
-		*phMgr = pDevObject->hDmmMgr;
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phMgr = dev_obj->dmm_mgr;
 	} else {
 		*phMgr = NULL;
 		status = DSP_EHANDLE;
-		GT_0trace(debugMask, GT_7CLASS,
-			 "DEV_GetDmmMgr: Invalid handle");
 	}
-	GT_2trace(debugMask, GT_ENTER,
-		 "Exit DEV_GetDmmMgr: status 0x%x\t\n hMgr: "
-		 "0x%x\n", status, *phMgr);
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
-		  (*phMgr == NULL)));
+
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
+					     (*phMgr == NULL)));
 	return status;
 }
 
 /*
- *  ======== DEV_GetCodMgr ========
+ *  ======== dev_get_cod_mgr ========
  *  Purpose:
  *      Retrieve the COD manager create for this device.
  */
-DSP_STATUS DEV_GetCodMgr(struct DEV_OBJECT *hDevObject,
-			OUT struct COD_MANAGER **phCodMgr)
+dsp_status dev_get_cod_mgr(struct dev_object *hdev_obj,
+			   OUT struct cod_manager **phCodMgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phCodMgr != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phCodMgr != NULL);
 
-	GT_2trace(debugMask, GT_ENTER,
-		 "Entered DEV_GetCodMgr, hDevObject: 0x%x\n\t\t"
-		 "phCodMgr: 0x%x\n", hDevObject, phCodMgr);
-	if (IsValidHandle(hDevObject)) {
-		*phCodMgr = pDevObject->hCodMgr;
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phCodMgr = dev_obj->cod_mgr;
 	} else {
 		*phCodMgr = NULL;
 		status = DSP_EHANDLE;
-		GT_1trace(debugMask, GT_7CLASS,
-			 "DEV_GetCodMgr, invalid handle:  0x%x\n",
-			 hDevObject);
 	}
-	GT_2trace(debugMask, GT_ENTER,
-		 "Exit DEV_GetCodMgr: status 0x%x\t\n hCodMgr:"
-		 " 0x%x\n", status, *phCodMgr);
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phCodMgr != NULL) &&
-		  (*phCodMgr == NULL)));
+
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phCodMgr != NULL) &&
+					     (*phCodMgr == NULL)));
 	return status;
 }
 
 /*
- *  ========= DEV_GetDehMgr ========
+ *  ========= dev_get_deh_mgr ========
  */
-DSP_STATUS DEV_GetDehMgr(struct DEV_OBJECT *hDevObject,
-			OUT struct DEH_MGR **phDehMgr)
+dsp_status dev_get_deh_mgr(struct dev_object *hdev_obj,
+			   OUT struct deh_mgr **phDehMgr)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phDehMgr != NULL);
-	DBC_Require(MEM_IsValidHandle(hDevObject, SIGNATURE));
-	if (IsValidHandle(hDevObject)) {
-		*phDehMgr = hDevObject->hDehMgr;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phDehMgr != NULL);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hdev_obj, SIGNATURE));
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phDehMgr = hdev_obj->hdeh_mgr;
 	} else {
 		*phDehMgr = NULL;
 		status = DSP_EHANDLE;
-		GT_0trace(debugMask, GT_7CLASS,
-			 "DEV_GetDehMgr: Invalid handle");
 	}
 	return status;
 }
 
 /*
- *  ======== DEV_GetDevNode ========
+ *  ======== dev_get_dev_node ========
  *  Purpose:
  *      Retrieve the platform specific device ID for this device.
  */
-DSP_STATUS DEV_GetDevNode(struct DEV_OBJECT *hDevObject,
-			 OUT struct CFG_DEVNODE **phDevNode)
+dsp_status dev_get_dev_node(struct dev_object *hdev_obj,
+			    OUT struct cfg_devnode **phDevNode)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phDevNode != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phDevNode != NULL);
 
-	GT_2trace(debugMask, GT_ENTER,
-		 "Entered DEV_GetDevNode, hDevObject: 0x%x\n\t"
-		 "\tphDevNode: 0x%x\n", hDevObject, phDevNode);
-	if (IsValidHandle(hDevObject)) {
-		*phDevNode = pDevObject->hDevNode;
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phDevNode = dev_obj->dev_node_obj;
 	} else {
 		*phDevNode = NULL;
 		status = DSP_EHANDLE;
-		GT_0trace(debugMask, GT_7CLASS,
-			 "DEV_GetDevNode: Invalid handle");
 	}
-	GT_2trace(debugMask, GT_ENTER,
-		 "Exit DEV_GetDevNode: status 0x%x\t\nhDevNode:"
-		 "0x%x\n", status, *phDevNode);
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phDevNode != NULL) &&
-		  (*phDevNode == NULL)));
+
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phDevNode != NULL) &&
+					     (*phDevNode == NULL)));
 	return status;
 }
 
 /*
- *  ======== DEV_GetFirst ========
+ *  ======== dev_get_first ========
  *  Purpose:
  *      Retrieve the first Device Object handle from an internal linked list
  *      DEV_OBJECTs maintained by DEV.
  */
-struct DEV_OBJECT *DEV_GetFirst(void)
+struct dev_object *dev_get_first(void)
 {
-	struct DEV_OBJECT *pDevObject = NULL;
+	struct dev_object *dev_obj = NULL;
 
-	pDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
+	dev_obj = (struct dev_object *)drv_get_first_dev_object();
 
-	DBC_Ensure((pDevObject == NULL) || IsValidHandle(pDevObject));
+	DBC_ENSURE((dev_obj == NULL) || IS_VALID_HANDLE(dev_obj));
 
-	return pDevObject;
+	return dev_obj;
 }
 
 /*
- *  ======== DEV_GetIntfFxns ========
+ *  ======== dev_get_intf_fxns ========
  *  Purpose:
  *      Retrieve the WMD interface function structure for the loaded WMD.
  *      ppIntfFxns != NULL.
  */
-DSP_STATUS DEV_GetIntfFxns(struct DEV_OBJECT *hDevObject,
-			  OUT struct WMD_DRV_INTERFACE **ppIntfFxns)
+dsp_status dev_get_intf_fxns(struct dev_object *hdev_obj,
+			     OUT struct bridge_drv_interface **ppIntfFxns)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(ppIntfFxns != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(ppIntfFxns != NULL);
 
-	GT_2trace(debugMask, GT_ENTER,
-		 "Entered DEV_GetIntfFxns, hDevObject: 0x%x\n\t"
-		 "\tppIntfFxns: 0x%x\n", hDevObject, ppIntfFxns);
-	if (IsValidHandle(hDevObject)) {
-		*ppIntfFxns = &pDevObject->intfFxns;
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*ppIntfFxns = &dev_obj->wmd_interface;
 	} else {
 		*ppIntfFxns = NULL;
 		status = DSP_EHANDLE;
-		GT_0trace(debugMask, GT_7CLASS,
-			  "DEV_GetIntDxns: Invalid handle");
 	}
-	GT_2trace(debugMask, GT_ENTER, "Exit DEV_GetIntFxns: status 0x%x\t\n"
-		 "ppIntFxns: 0x%x\n", status, *ppIntfFxns);
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((ppIntfFxns != NULL) &&
-		  (*ppIntfFxns == NULL)));
+
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((ppIntfFxns != NULL) &&
+					     (*ppIntfFxns == NULL)));
 	return status;
 }
 
 /*
- *  ========= DEV_GetIOMgr ========
+ *  ========= dev_get_io_mgr ========
  */
-DSP_STATUS DEV_GetIOMgr(struct DEV_OBJECT *hDevObject,
-			OUT struct IO_MGR **phIOMgr)
+dsp_status dev_get_io_mgr(struct dev_object *hdev_obj,
+			  OUT struct io_mgr **phIOMgr)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phIOMgr != NULL);
-	DBC_Require(MEM_IsValidHandle(hDevObject, SIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phIOMgr != NULL);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hdev_obj, SIGNATURE));
 
-	if (IsValidHandle(hDevObject)) {
-		*phIOMgr = hDevObject->hIOMgr;
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phIOMgr = hdev_obj->hio_mgr;
 	} else {
 		*phIOMgr = NULL;
 		status = DSP_EHANDLE;
-		GT_0trace(debugMask, GT_7CLASS, "DEV_GetIOMgr: Invalid handle");
 	}
 
 	return status;
 }
 
 /*
- *  ======== DEV_GetNext ========
+ *  ======== dev_get_next ========
  *  Purpose:
  *      Retrieve the next Device Object handle from an internal linked list
  *      of DEV_OBJECTs maintained by DEV, after having previously called
- *      DEV_GetFirst() and zero or more DEV_GetNext
+ *      dev_get_first() and zero or more dev_get_next
  */
-struct DEV_OBJECT *DEV_GetNext(struct DEV_OBJECT *hDevObject)
+struct dev_object *dev_get_next(struct dev_object *hdev_obj)
 {
-	struct DEV_OBJECT *pNextDevObject = NULL;
+	struct dev_object *next_dev_object = NULL;
 
-	if (IsValidHandle(hDevObject)) {
-		pNextDevObject = (struct DEV_OBJECT *)
-				 DRV_GetNextDevObject((u32)hDevObject);
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		next_dev_object = (struct dev_object *)
+		    drv_get_next_dev_object((u32) hdev_obj);
 	}
-	DBC_Ensure((pNextDevObject == NULL) || IsValidHandle(pNextDevObject));
-	return pNextDevObject;
+	DBC_ENSURE((next_dev_object == NULL)
+		   || IS_VALID_HANDLE(next_dev_object));
+	return next_dev_object;
 }
 
 /*
- *  ========= DEV_GetMsgMgr ========
+ *  ========= dev_get_msg_mgr ========
  */
-void DEV_GetMsgMgr(struct DEV_OBJECT *hDevObject,
-			OUT struct MSG_MGR **phMsgMgr)
+void dev_get_msg_mgr(struct dev_object *hdev_obj, OUT struct msg_mgr **phMsgMgr)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(phMsgMgr != NULL);
-	DBC_Require(MEM_IsValidHandle(hDevObject, SIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phMsgMgr != NULL);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hdev_obj, SIGNATURE));
 
-	*phMsgMgr = hDevObject->hMsgMgr;
+	*phMsgMgr = hdev_obj->hmsg_mgr;
 }
 
 /*
- *  ======== DEV_GetNodeManager ========
+ *  ======== dev_get_node_manager ========
  *  Purpose:
  *      Retrieve the Node Manager Handle
  */
-DSP_STATUS DEV_GetNodeManager(struct DEV_OBJECT *hDevObject,
-				   OUT struct NODE_MGR **phNodeMgr)
+dsp_status dev_get_node_manager(struct dev_object *hdev_obj,
+				OUT struct node_mgr **phNodeMgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phNodeMgr != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phNodeMgr != NULL);
 
-	GT_2trace(debugMask, GT_ENTER,
-		 "Entered DEV_GetNodeManager, hDevObject: 0x%x"
-		 "\n\t\tphNodeMgr: 0x%x\n", hDevObject, phNodeMgr);
-	if (IsValidHandle(hDevObject)) {
-		*phNodeMgr = pDevObject->hNodeMgr;
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phNodeMgr = dev_obj->hnode_mgr;
 	} else {
 		*phNodeMgr = NULL;
 		status = DSP_EHANDLE;
-		GT_1trace(debugMask, GT_7CLASS,
-			 "DEV_GetNodeManager, invalid handle: 0x"
-			 "%x\n", hDevObject);
 	}
-	GT_2trace(debugMask, GT_ENTER,
-		 "Exit DEV_GetNodeManager: status 0x%x\t\nhMgr:"
-		 " 0x%x\n", status, *phNodeMgr);
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phNodeMgr != NULL) &&
-		  (*phNodeMgr == NULL)));
+
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phNodeMgr != NULL) &&
+					     (*phNodeMgr == NULL)));
 	return status;
 }
 
 /*
- *  ======== DEV_GetSymbol ========
+ *  ======== dev_get_symbol ========
  */
-DSP_STATUS DEV_GetSymbol(struct DEV_OBJECT *hDevObject,
-			      IN CONST char *pstrSym, OUT u32 *pulValue)
+dsp_status dev_get_symbol(struct dev_object *hdev_obj,
+			  IN CONST char *pstrSym, OUT u32 * pul_value)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct COD_MANAGER *hCodMgr;
+	dsp_status status = DSP_SOK;
+	struct cod_manager *cod_mgr;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pstrSym != NULL && pulValue != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pstrSym != NULL && pul_value != NULL);
 
-	GT_3trace(debugMask, GT_ENTER,
-		 "Entered DEV_GetSymbol, hDevObject: 0x%x\n\t\t"
-		 "pstrSym: 0x%x\n\t\tpulValue: 0x%x\n", hDevObject, pstrSym,
-		 pulValue);
-	if (IsValidHandle(hDevObject)) {
-		status = DEV_GetCodMgr(hDevObject, &hCodMgr);
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		status = dev_get_cod_mgr(hdev_obj, &cod_mgr);
 		if (DSP_SUCCEEDED(status)) {
-			DBC_Assert(hCodMgr != NULL);
-			status = COD_GetSymValue(hCodMgr, (char *)pstrSym,
-				 pulValue);
+			DBC_ASSERT(cod_mgr != NULL);
+			status = cod_get_sym_value(cod_mgr, (char *)pstrSym,
+						   pul_value);
 		}
 	} else {
 		status = DSP_EHANDLE;
-		GT_0trace(debugMask, GT_7CLASS,
-			 "DEV_GetSymbol: Invalid handle");
 	}
-	GT_2trace(debugMask, GT_ENTER, "Exit DEV_GetSymbol: status 0x%x\t\n"
-		 "hWmdContext: 0x%x\n", status, *pulValue);
+
 	return status;
 }
 
 /*
- *  ======== DEV_GetWMDContext ========
+ *  ======== dev_get_wmd_context ========
  *  Purpose:
  *      Retrieve the WMD Context handle, as returned by the WMD_Create fxn.
  */
-DSP_STATUS DEV_GetWMDContext(struct DEV_OBJECT *hDevObject,
-			    OUT struct WMD_DEV_CONTEXT **phWmdContext)
+dsp_status dev_get_wmd_context(struct dev_object *hdev_obj,
+			       OUT struct wmd_dev_context **phWmdContext)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phWmdContext != NULL);
-	GT_2trace(debugMask, GT_ENTER,
-		  "Entered DEV_GetWMDContext, hDevObject: 0x%x\n"
-		  "\t\tphWmdContext: 0x%x\n", hDevObject, phWmdContext);
-	if (IsValidHandle(hDevObject)) {
-		*phWmdContext = pDevObject->hWmdContext;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phWmdContext != NULL);
+
+	if (IS_VALID_HANDLE(hdev_obj)) {
+		*phWmdContext = dev_obj->hwmd_context;
 	} else {
 		*phWmdContext = NULL;
 		status = DSP_EHANDLE;
-		GT_0trace(debugMask, GT_7CLASS,
-			 "DEV_GetWMDContext: Invalid handle");
 	}
 
-	GT_2trace(debugMask, GT_ENTER,
-		 "Exit DEV_GetWMDContext: status 0x%x\t\n"
-		 "hWmdContext: 0x%x\n", status, *phWmdContext);
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phWmdContext != NULL) &&
-		  (*phWmdContext == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phWmdContext != NULL) &&
+					     (*phWmdContext == NULL)));
 	return status;
 }
 
 /*
- *  ======== DEV_Exit ========
+ *  ======== dev_exit ========
  *  Purpose:
  *      Decrement reference count, and free resources when reference count is
  *      0.
  */
-void DEV_Exit(void)
+void dev_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	if (cRefs == 0) {
-		CMM_Exit();
-		DMM_Exit();
+	if (refs == 0) {
+		cmm_exit();
+		dmm_exit();
 	}
 
-	GT_1trace(debugMask, GT_5CLASS, "Entered DEV_Exit, ref count: 0x%x\n",
-		 cRefs);
-
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== DEV_Init ========
+ *  ======== dev_init ========
  *  Purpose:
  *      Initialize DEV's private state, keeping a reference count on each call.
  */
-bool DEV_Init(void)
+bool dev_init(void)
 {
-	bool fCmm, fDmm, fRetval = true;
-
-	DBC_Require(cRefs >= 0);
+	bool cmm_ret, dmm_ret, ret = true;
 
-	if (cRefs == 0) {
-		/* Set the Trace mask */
-		DBC_Assert(!debugMask.flags);
-		GT_create(&debugMask, "DV");	/* "DV" for DeVice */
-		fCmm = CMM_Init();
-		fDmm = DMM_Init();
+	DBC_REQUIRE(refs >= 0);
 
-		fRetval = fCmm && fDmm;
+	if (refs == 0) {
+		cmm_ret = cmm_init();
+		dmm_ret = dmm_init();
 
-		if (!fRetval) {
-			if (fCmm)
-				CMM_Exit();
+		ret = cmm_ret && dmm_ret;
 
+		if (!ret) {
+			if (cmm_ret)
+				cmm_exit();
 
-			if (fDmm)
-				DMM_Exit();
+			if (dmm_ret)
+				dmm_exit();
 
 		}
 	}
 
-	if (fRetval)
-		cRefs++;
-
-
-	GT_1trace(debugMask, GT_5CLASS, "Entered DEV_Init, ref count: 0x%x\n",
-		 cRefs);
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	return fRetval;
+	return ret;
 }
 
 /*
- *  ======== DEV_NotifyClients ========
+ *  ======== dev_notify_clients ========
  *  Purpose:
  *      Notify all clients of this device of a change in device status.
  */
-DSP_STATUS DEV_NotifyClients(struct DEV_OBJECT *hDevObject, u32 ulStatus)
+dsp_status dev_notify_clients(struct dev_object *hdev_obj, u32 ulStatus)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	struct DEV_OBJECT *pDevObject = hDevObject;
-	DSP_HPROCESSOR hProcObject;
+	struct dev_object *dev_obj = hdev_obj;
+	void *proc_obj;
 
-	GT_2trace(debugMask, GT_ENTER,
-		 "Entered DEV_NotifyClients, hDevObject: 0x%x\n"
-		 "\t\tulStatus: 0x%x\n", hDevObject, ulStatus);
-	for (hProcObject = (DSP_HPROCESSOR)LST_First(pDevObject->procList);
-		hProcObject != NULL;
-		hProcObject = (DSP_HPROCESSOR)LST_Next(pDevObject->procList,
-						(struct LST_ELEM *)hProcObject))
-		PROC_NotifyClients(hProcObject, (u32) ulStatus);
+	for (proc_obj = (void *)lst_first(dev_obj->proc_list);
+	     proc_obj != NULL;
+	     proc_obj = (void *)lst_next(dev_obj->proc_list,
+					 (struct list_head *)proc_obj))
+		proc_notify_clients(proc_obj, (u32) ulStatus);
 
 	return status;
 }
 
 /*
- *  ======== DEV_RemoveDevice ========
+ *  ======== dev_remove_device ========
  */
-DSP_STATUS DEV_RemoveDevice(struct CFG_DEVNODE *hDevNode)
+dsp_status dev_remove_device(struct cfg_devnode *dev_node_obj)
 {
-	struct DEV_OBJECT *hDevObject;	/* handle to device object */
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject;
+	struct dev_object *hdev_obj;	/* handle to device object */
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj;
 
-	GT_1trace(debugMask, GT_ENTER,
-		 "Entered DEV_RemoveDevice, hDevNode:  0x%x\n", hDevNode);
 	/* Retrieve the device object handle originaly stored with
-	 * the DevNode: */
-	status = CFG_GetDevObject(hDevNode, (u32 *)&hDevObject);
+	 * the dev_node: */
+	status = cfg_get_dev_object(dev_node_obj, (u32 *) &hdev_obj);
 	if (DSP_SUCCEEDED(status)) {
 		/* Remove the Processor List */
-		pDevObject = (struct DEV_OBJECT *)hDevObject;
+		dev_obj = (struct dev_object *)hdev_obj;
 		/* Destroy the device object. */
-		status = DEV_DestroyDevice(hDevObject);
-		if (DSP_SUCCEEDED(status)) {
-			/* Null out the handle stored with the DevNode. */
-			GT_0trace(debugMask, GT_1CLASS,
-				 "DEV_RemoveDevice, success");
-		}
+		status = dev_destroy_device(hdev_obj);
 	}
-	GT_1trace(debugMask, GT_ENTER, "Exit DEV_RemoveDevice, status: 0x%x\n",
-		  status);
+
 	return status;
 }
 
 /*
- *  ======== DEV_SetChnlMgr ========
+ *  ======== dev_set_chnl_mgr ========
  *  Purpose:
  *      Set the channel manager for this device.
  */
-DSP_STATUS DEV_SetChnlMgr(struct DEV_OBJECT *hDevObject, struct CHNL_MGR *hMgr)
+dsp_status dev_set_chnl_mgr(struct dev_object *hdev_obj,
+			    struct chnl_mgr *hmgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = hdev_obj;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	GT_2trace(debugMask, GT_ENTER,
-		 "Entered DEV_SetChnlMgr, hDevObject: 0x%x\n\t"
-		 "\thMgr:0x%x\n", hDevObject, hMgr);
-	if (IsValidHandle(hDevObject)) {
-		pDevObject->hChnlMgr = hMgr;
-	} else {
+	if (IS_VALID_HANDLE(hdev_obj))
+		dev_obj->hchnl_mgr = hmgr;
+	else
 		status = DSP_EHANDLE;
-		GT_0trace(debugMask, GT_7CLASS,
-			 "DEV_SetChnlMgr, Invalid handle\n");
-	}
-	DBC_Ensure(DSP_FAILED(status) || (pDevObject->hChnlMgr == hMgr));
+
+	DBC_ENSURE(DSP_FAILED(status) || (dev_obj->hchnl_mgr == hmgr));
 	return status;
 }
 
 /*
- *  ======== DEV_SetMsgMgr ========
+ *  ======== dev_set_msg_mgr ========
  *  Purpose:
  *      Set the message manager for this device.
  */
-void DEV_SetMsgMgr(struct DEV_OBJECT *hDevObject, struct MSG_MGR *hMgr)
+void dev_set_msg_mgr(struct dev_object *hdev_obj, struct msg_mgr *hmgr)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValidHandle(hDevObject));
-	GT_2trace(debugMask, GT_ENTER,
-		 "Entered DEV_SetMsgMgr, hDevObject: 0x%x\n\t\t"
-		 "hMgr: 0x%x\n", hDevObject, hMgr);
-	hDevObject->hMsgMgr = hMgr;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID_HANDLE(hdev_obj));
+
+	hdev_obj->hmsg_mgr = hmgr;
 }
 
 /*
- *  ======== DEV_StartDevice ========
+ *  ======== dev_start_device ========
  *  Purpose:
  *      Initializes the new device with the BRIDGE environment.
  */
-DSP_STATUS DEV_StartDevice(struct CFG_DEVNODE *hDevNode)
+dsp_status dev_start_device(struct cfg_devnode *dev_node_obj)
 {
-	struct DEV_OBJECT *hDevObject = NULL;	/* handle to 'Bridge Device */
-	struct CFG_HOSTRES hostRes;	/* resources struct. */
-	struct CFG_DSPRES dspRes;	/* DSP resources struct */
-	char szWMDFileName[CFG_MAXSEARCHPATHLEN] = "UMA"; /* wmd filename */
-	DSP_STATUS status;
-	struct MGR_OBJECT *hMgrObject = NULL;
-
-	DBC_Require(cRefs > 0);
-
-	GT_1trace(debugMask, GT_ENTER,
-		 "Entered DEV_StartDevice, hDevObject: 0x%x\n", hDevNode);
-		status = CFG_GetHostResources(hDevNode, &hostRes);
-		if (DSP_SUCCEEDED(status)) {
-			/* Get DSP resources of device from Registry: */
-			status = CFG_GetDSPResources(hDevNode, &dspRes);
-			if (DSP_FAILED(status)) {
-				GT_1trace(debugMask, GT_7CLASS,
-					 "Failed to get WMD DSP resources"
-					 " from registry: 0x%x ", status);
-			}
-		} else {
-			GT_1trace(debugMask, GT_7CLASS,
-				 "Failed to get WMD Host resources "
-				 "from registry: 0x%x ", status);
-		}
+	struct dev_object *hdev_obj = NULL;	/* handle to 'Bridge Device */
+	struct cfg_hostres host_res;	/* resources struct. */
+	struct cfg_dspres dsp_res;	/* DSP resources struct */
+	/* wmd filename */
+	char sz_wmd_file_name[CFG_MAXSEARCHPATHLEN] = "UMA";
+	dsp_status status;
+	struct mgr_object *hmgr_obj = NULL;
+
+	DBC_REQUIRE(refs > 0);
+
+	status = cfg_get_host_resources(dev_node_obj, &host_res);
+	if (DSP_SUCCEEDED(status)) {
+		/* Get DSP resources of device from Registry: */
+		status = cfg_get_dsp_resources(dev_node_obj, &dsp_res);
+	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Given all resources, create a device object. */
-		status = DEV_CreateDevice(&hDevObject, szWMDFileName, &hostRes,
-					 &dspRes, hDevNode);
+		status =
+		    dev_create_device(&hdev_obj, sz_wmd_file_name, &host_res,
+				      &dsp_res, dev_node_obj);
 		if (DSP_SUCCEEDED(status)) {
-			/* Store away the hDevObject with the DEVNODE */
-			status = CFG_SetDevObject(hDevNode, (u32)hDevObject);
+			/* Store away the hdev_obj with the DEVNODE */
+			status =
+			    cfg_set_dev_object(dev_node_obj, (u32) hdev_obj);
 			if (DSP_FAILED(status)) {
 				/* Clean up */
-				GT_1trace(debugMask, GT_7CLASS,
-					 "Failed to set DevObject in the "
-					 "Registry: 0x%x", status);
-				DEV_DestroyDevice(hDevObject);
-				hDevObject = NULL;
+				dev_destroy_device(hdev_obj);
+				hdev_obj = NULL;
 			}
-		} else {
-			GT_1trace(debugMask, GT_7CLASS,
-				 "Failed to Create Device: 0x%x",
-				 status);
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Create the Manager Object */
-		status = MGR_Create(&hMgrObject, hDevNode);
-	}
-	if (DSP_FAILED(status)) {
-		GT_1trace(debugMask, GT_7CLASS, "Failed to MGR object: 0x%x",
-			 status);
-		status = DSP_EFAIL;
+		status = mgr_create(&hmgr_obj, dev_node_obj);
 	}
 	if (DSP_FAILED(status)) {
-		if (hDevObject)
-			DEV_DestroyDevice(hDevObject);
+		if (hdev_obj)
+			dev_destroy_device(hdev_obj);
 
 		/* Ensure the device extension is NULL */
-		CFG_SetDevObject(hDevNode, 0L);
+		cfg_set_dev_object(dev_node_obj, 0L);
 	}
-	GT_1trace(debugMask, GT_ENTER, "Exiting DEV_StartDevice status 0x%x\n",
-		 status);
+
 	return status;
 }
 
 /*
- *  ======== FxnNotImplemented ========
+ *  ======== fxn_not_implemented ========
  *  Purpose:
  *      Takes the place of a WMD Null Function.
  *  Parameters:
@@ -1189,288 +935,270 @@
  *  Returns:
  *      DSP_ENOTIMPL:   Always.
  */
-static DSP_STATUS FxnNotImplemented(int arg, ...)
+static dsp_status fxn_not_implemented(int arg, ...)
 {
-	DBG_Trace(DBG_LEVEL1,
-		 "WARNING: Calling a non-implemented WMD function.\n");
-
 	return DSP_ENOTIMPL;
 }
 
 /*
- *  ======== IsValidHandle ========
+ *  ======== IS_VALID_HANDLE ========
  *  Purpose:
  *      Validate the device object handle.
  *  Parameters:
- *      hDevObject:     Handle to device object created with
- *                      DEV_CreateDevice().
+ *      hdev_obj:     Handle to device object created with
+ *                      dev_create_device().
  *  Returns:
  *      true if handle is valid; false otherwise.
  *  Requires:
  *  Ensures:
  */
-static bool IsValidHandle(struct DEV_OBJECT *hObj)
+static bool IS_VALID_HANDLE(struct dev_object *hObj)
 {
-	bool retVal;
+	bool ret;
 
-	retVal = (hObj != NULL) && (hObj->dwSignature == SIGNATURE);
+	ret = (hObj != NULL) && (hObj->dw_signature == SIGNATURE);
 
-	return retVal;
+	return ret;
 }
 
 /*
- *  ======== InitCodMgr ========
+ *  ======== init_cod_mgr ========
  *  Purpose:
  *      Create a COD manager for this device.
  *  Parameters:
- *      pDevObject:             Pointer to device object created with
- *                              DEV_CreateDevice()
+ *      dev_obj:             Pointer to device object created with
+ *                              dev_create_device()
  *  Returns:
  *      DSP_SOK:                Success.
- *      DSP_EHANDLE:            Invalid hDevObject.
+ *      DSP_EHANDLE:            Invalid hdev_obj.
  *  Requires:
- *      Should only be called once by DEV_CreateDevice() for a given DevObject.
+ *      Should only be called once by dev_create_device() for a given DevObject.
  *  Ensures:
  */
-static DSP_STATUS InitCodMgr(struct DEV_OBJECT *pDevObject)
+static dsp_status init_cod_mgr(struct dev_object *dev_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	char *szDummyFile = "dummy";
+	dsp_status status = DSP_SOK;
+	char *sz_dummy_file = "dummy";
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(!IS_VALID_HANDLE(dev_obj) || (dev_obj->cod_mgr == NULL));
+
+	status = cod_create(&dev_obj->cod_mgr, sz_dummy_file, NULL);
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(!IsValidHandle(pDevObject) ||
-		   (pDevObject->hCodMgr == NULL));
-	GT_1trace(debugMask, GT_ENTER, "Entering InitCodMgr pDevObject: 0x%x",
-		 pDevObject);
-	status = COD_Create(&pDevObject->hCodMgr, szDummyFile, NULL);
-	GT_1trace(debugMask, GT_ENTER, "Exiting InitCodMgr status 0x%x\n ",
-		 status);
 	return status;
 }
 
 /*
- *  ======== DEV_InsertProcObject ========
+ *  ======== dev_insert_proc_object ========
  *  Purpose:
  *      Insert a ProcObject into the list maintained by DEV.
  *  Parameters:
- *      pProcObject:        Ptr to ProcObject to insert.
- *      pDevObject:         Ptr to Dev Object where the list is.
+ *      p_proc_object:        Ptr to ProcObject to insert.
+ *      dev_obj:         Ptr to Dev Object where the list is.
   *     pbAlreadyAttached:  Ptr to return the bool
  *  Returns:
  *      DSP_SOK:           If successful.
  *  Requires:
  *      List Exists
- *      hDevObject is Valid handle
+ *      hdev_obj is Valid handle
  *      DEV Initialized
  *      pbAlreadyAttached != NULL
- *      hProcObject != 0
+ *      proc_obj != 0
  *  Ensures:
  *      DSP_SOK and List is not Empty.
  */
-DSP_STATUS DEV_InsertProcObject(struct DEV_OBJECT *hDevObject,
-				     u32 hProcObject,
-				     OUT bool *pbAlreadyAttached)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)hDevObject;
-
-	GT_2trace(debugMask, GT_ENTER,
-		 "Entering DEV_InsetProcObject pProcObject 0x%x"
-		 "pDevObject 0x%x\n", hProcObject, hDevObject);
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValidHandle(pDevObject));
-	DBC_Require(hProcObject != 0);
-	DBC_Require(pDevObject->procList != NULL);
-	DBC_Require(pbAlreadyAttached != NULL);
-	if (!LST_IsEmpty(pDevObject->procList))
+dsp_status dev_insert_proc_object(struct dev_object *hdev_obj,
+				  u32 proc_obj, OUT bool *pbAlreadyAttached)
+{
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = (struct dev_object *)hdev_obj;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID_HANDLE(dev_obj));
+	DBC_REQUIRE(proc_obj != 0);
+	DBC_REQUIRE(dev_obj->proc_list != NULL);
+	DBC_REQUIRE(pbAlreadyAttached != NULL);
+	if (!LST_IS_EMPTY(dev_obj->proc_list))
 		*pbAlreadyAttached = true;
 
 	/* Add DevObject to tail. */
-	LST_PutTail(pDevObject->procList, (struct LST_ELEM *)hProcObject);
+	lst_put_tail(dev_obj->proc_list, (struct list_head *)proc_obj);
 
-	GT_1trace(debugMask, GT_ENTER,
-		 "Exiting DEV_InsetProcObject status 0x%x\n", status);
-	DBC_Ensure(DSP_SUCCEEDED(status) && !LST_IsEmpty(pDevObject->procList));
+	DBC_ENSURE(DSP_SUCCEEDED(status) && !LST_IS_EMPTY(dev_obj->proc_list));
 
 	return status;
 }
 
 /*
- *  ======== DEV_RemoveProcObject ========
+ *  ======== dev_remove_proc_object ========
  *  Purpose:
  *      Search for and remove a Proc object from the given list maintained
  *      by the DEV
  *  Parameters:
- *      pProcObject:        Ptr to ProcObject to insert.
- *      pDevObject          Ptr to Dev Object where the list is.
+ *      p_proc_object:        Ptr to ProcObject to insert.
+ *      dev_obj          Ptr to Dev Object where the list is.
  *  Returns:
  *      DSP_SOK:            If successful.
  *  Requires:
  *      List exists and is not empty
- *      hProcObject != 0
- *      hDevObject is a valid Dev handle.
+ *      proc_obj != 0
+ *      hdev_obj is a valid Dev handle.
  *  Ensures:
  *  Details:
  *      List will be deleted when the DEV is destroyed.
  */
-DSP_STATUS DEV_RemoveProcObject(struct DEV_OBJECT *hDevObject,
-				     u32 hProcObject)
+dsp_status dev_remove_proc_object(struct dev_object *hdev_obj, u32 proc_obj)
 {
-	DSP_STATUS status = DSP_EFAIL;
-	struct LST_ELEM *pCurElem;
-	struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)hDevObject;
-
-	DBC_Require(IsValidHandle(pDevObject));
-	DBC_Require(hProcObject != 0);
-	DBC_Require(pDevObject->procList != NULL);
-	DBC_Require(!LST_IsEmpty(pDevObject->procList));
-
-	GT_1trace(debugMask, GT_ENTER,
-		 "Entering DEV_RemoveProcObject hDevObject "
-		 "0x%x\n", hDevObject);
-	/* Search list for pDevObject: */
-	for (pCurElem = LST_First(pDevObject->procList); pCurElem != NULL;
-	    pCurElem = LST_Next(pDevObject->procList, pCurElem)) {
+	dsp_status status = DSP_EFAIL;
+	struct list_head *cur_elem;
+	struct dev_object *dev_obj = (struct dev_object *)hdev_obj;
+
+	DBC_REQUIRE(IS_VALID_HANDLE(dev_obj));
+	DBC_REQUIRE(proc_obj != 0);
+	DBC_REQUIRE(dev_obj->proc_list != NULL);
+	DBC_REQUIRE(!LST_IS_EMPTY(dev_obj->proc_list));
+
+	/* Search list for dev_obj: */
+	for (cur_elem = lst_first(dev_obj->proc_list); cur_elem != NULL;
+	     cur_elem = lst_next(dev_obj->proc_list, cur_elem)) {
 		/* If found, remove it. */
-		if ((u32)pCurElem == hProcObject) {
-			LST_RemoveElem(pDevObject->procList, pCurElem);
+		if ((u32) cur_elem == proc_obj) {
+			lst_remove_elem(dev_obj->proc_list, cur_elem);
 			status = DSP_SOK;
 			break;
 		}
 	}
-	GT_1trace(debugMask, GT_ENTER, "DEV_RemoveProcObject returning 0x%x\n",
-		 status);
+
 	return status;
 }
 
-DSP_STATUS DEV_GetDevType(struct DEV_OBJECT *hdevObject, u32 *devType)
+dsp_status dev_get_dev_type(struct dev_object *hdevObject, u32 *dev_type)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)hdevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *dev_obj = (struct dev_object *)hdevObject;
 
-	*devType = pDevObject->devType;
+	*dev_type = dev_obj->dev_type;
 
 	return status;
 }
 
 /*
- *  ======== StoreInterfaceFxns ========
+ *  ======== store_interface_fxns ========
  *  Purpose:
  *      Copy the WMD's interface functions into the device object,
- *      ensuring that FxnNotImplemented() is set for:
+ *      ensuring that fxn_not_implemented() is set for:
  *
  *      1. All WMD function pointers which are NULL; and
- *      2. All function slots in the struct DEV_OBJECT structure which have no
+ *      2. All function slots in the struct dev_object structure which have no
  *         corresponding slots in the the WMD's interface, because the WMD
  *         is of an *older* version.
  *  Parameters:
- *      pIntfFxns:      Interface Fxn Structure of the WCD's Dev Object.
- *      pDrvFxns:       Interface Fxns offered by the WMD during DEV_Create().
+ *      intf_fxns:      Interface fxn Structure of the WCD's Dev Object.
+ *      drv_fxns:       Interface Fxns offered by the WMD during DEV_Create().
  *  Returns:
  *  Requires:
  *      Input pointers are valid.
  *      WMD is *not* written for a newer WCD.
  *  Ensures:
- *      All function pointers in the dev object's Fxn interface are not NULL.
+ *      All function pointers in the dev object's fxn interface are not NULL.
  */
-static void StoreInterfaceFxns(struct WMD_DRV_INTERFACE *pDrvFxns,
-			      OUT struct WMD_DRV_INTERFACE *pIntfFxns)
+static void store_interface_fxns(struct bridge_drv_interface *drv_fxns,
+				 OUT struct bridge_drv_interface *intf_fxns)
 {
-	u32 dwWMDVersion;
+	u32 dw_wmd_version;
 
 	/* Local helper macro: */
-#define  StoreFxn(cast, pfn) \
-    (pIntfFxns->pfn = ((pDrvFxns->pfn != NULL) ? pDrvFxns->pfn : \
-    (cast)FxnNotImplemented))
-
-	DBC_Require(pIntfFxns != NULL);
-	DBC_Require(pDrvFxns != NULL);
-	DBC_Require(MAKEVERSION(pDrvFxns->dwWCDMajorVersion,
-		   pDrvFxns->dwWCDMinorVersion) <= WCDVERSION);
-	dwWMDVersion = MAKEVERSION(pDrvFxns->dwWCDMajorVersion,
-				  pDrvFxns->dwWCDMinorVersion);
-	pIntfFxns->dwWCDMajorVersion = pDrvFxns->dwWCDMajorVersion;
-	pIntfFxns->dwWCDMinorVersion = pDrvFxns->dwWCDMinorVersion;
+#define  STORE_FXN(cast, pfn) \
+    (intf_fxns->pfn = ((drv_fxns->pfn != NULL) ? drv_fxns->pfn : \
+    (cast)fxn_not_implemented))
+
+	DBC_REQUIRE(intf_fxns != NULL);
+	DBC_REQUIRE(drv_fxns != NULL);
+	DBC_REQUIRE(MAKEVERSION(drv_fxns->dw_wcd_major_version,
+				drv_fxns->dw_wcd_minor_version) <= WCDVERSION);
+	dw_wmd_version = MAKEVERSION(drv_fxns->dw_wcd_major_version,
+				     drv_fxns->dw_wcd_minor_version);
+	intf_fxns->dw_wcd_major_version = drv_fxns->dw_wcd_major_version;
+	intf_fxns->dw_wcd_minor_version = drv_fxns->dw_wcd_minor_version;
 	/* Install functions up to WCD version .80 (first alpha): */
-	if (dwWMDVersion > 0) {
-		StoreFxn(WMD_DEV_CREATE, pfnDevCreate);
-		StoreFxn(WMD_DEV_DESTROY, pfnDevDestroy);
-		StoreFxn(WMD_DEV_CTRL, pfnDevCntrl);
-		StoreFxn(WMD_BRD_MONITOR, pfnBrdMonitor);
-		StoreFxn(WMD_BRD_START, pfnBrdStart);
-		StoreFxn(WMD_BRD_STOP, pfnBrdStop);
-		StoreFxn(WMD_BRD_STATUS, pfnBrdStatus);
-		StoreFxn(WMD_BRD_READ, pfnBrdRead);
-		StoreFxn(WMD_BRD_WRITE, pfnBrdWrite);
-		StoreFxn(WMD_BRD_SETSTATE, pfnBrdSetState);
-		StoreFxn(WMD_BRD_MEMCOPY, pfnBrdMemCopy);
-		StoreFxn(WMD_BRD_MEMWRITE, pfnBrdMemWrite);
-		StoreFxn(WMD_BRD_MEMMAP, pfnBrdMemMap);
-		StoreFxn(WMD_BRD_MEMUNMAP, pfnBrdMemUnMap);
-		StoreFxn(WMD_CHNL_CREATE, pfnChnlCreate);
-		StoreFxn(WMD_CHNL_DESTROY, pfnChnlDestroy);
-		StoreFxn(WMD_CHNL_OPEN, pfnChnlOpen);
-		StoreFxn(WMD_CHNL_CLOSE, pfnChnlClose);
-		StoreFxn(WMD_CHNL_ADDIOREQ, pfnChnlAddIOReq);
-		StoreFxn(WMD_CHNL_GETIOC, pfnChnlGetIOC);
-		StoreFxn(WMD_CHNL_CANCELIO, pfnChnlCancelIO);
-		StoreFxn(WMD_CHNL_FLUSHIO, pfnChnlFlushIO);
-		StoreFxn(WMD_CHNL_GETINFO, pfnChnlGetInfo);
-		StoreFxn(WMD_CHNL_GETMGRINFO, pfnChnlGetMgrInfo);
-		StoreFxn(WMD_CHNL_IDLE, pfnChnlIdle);
-		StoreFxn(WMD_CHNL_REGISTERNOTIFY, pfnChnlRegisterNotify);
-		StoreFxn(WMD_DEH_CREATE, pfnDehCreate);
-		StoreFxn(WMD_DEH_DESTROY, pfnDehDestroy);
-		StoreFxn(WMD_DEH_NOTIFY, pfnDehNotify);
-		StoreFxn(WMD_DEH_REGISTERNOTIFY, pfnDehRegisterNotify);
-		StoreFxn(WMD_DEH_GETINFO, pfnDehGetInfo);
-		StoreFxn(WMD_IO_CREATE, pfnIOCreate);
-		StoreFxn(WMD_IO_DESTROY, pfnIODestroy);
-		StoreFxn(WMD_IO_ONLOADED, pfnIOOnLoaded);
-		StoreFxn(WMD_IO_GETPROCLOAD, pfnIOGetProcLoad);
-		StoreFxn(WMD_MSG_CREATE, pfnMsgCreate);
-		StoreFxn(WMD_MSG_CREATEQUEUE, pfnMsgCreateQueue);
-		StoreFxn(WMD_MSG_DELETE, pfnMsgDelete);
-		StoreFxn(WMD_MSG_DELETEQUEUE, pfnMsgDeleteQueue);
-		StoreFxn(WMD_MSG_GET, pfnMsgGet);
-		StoreFxn(WMD_MSG_PUT, pfnMsgPut);
-		StoreFxn(WMD_MSG_REGISTERNOTIFY, pfnMsgRegisterNotify);
-		StoreFxn(WMD_MSG_SETQUEUEID, pfnMsgSetQueueId);
+	if (dw_wmd_version > 0) {
+		STORE_FXN(fxn_dev_create, pfn_dev_create);
+		STORE_FXN(fxn_dev_destroy, pfn_dev_destroy);
+		STORE_FXN(fxn_dev_ctrl, pfn_dev_cntrl);
+		STORE_FXN(fxn_brd_monitor, pfn_brd_monitor);
+		STORE_FXN(fxn_brd_start, pfn_brd_start);
+		STORE_FXN(fxn_brd_stop, pfn_brd_stop);
+		STORE_FXN(fxn_brd_status, pfn_brd_status);
+		STORE_FXN(fxn_brd_read, pfn_brd_read);
+		STORE_FXN(fxn_brd_write, pfn_brd_write);
+		STORE_FXN(fxn_brd_setstate, pfn_brd_set_state);
+		STORE_FXN(fxn_brd_memcopy, pfn_brd_mem_copy);
+		STORE_FXN(fxn_brd_memwrite, pfn_brd_mem_write);
+		STORE_FXN(fxn_brd_memmap, pfn_brd_mem_map);
+		STORE_FXN(fxn_brd_memunmap, pfn_brd_mem_un_map);
+		STORE_FXN(fxn_chnl_create, pfn_chnl_create);
+		STORE_FXN(fxn_chnl_destroy, pfn_chnl_destroy);
+		STORE_FXN(fxn_chnl_open, pfn_chnl_open);
+		STORE_FXN(fxn_chnl_close, pfn_chnl_close);
+		STORE_FXN(fxn_chnl_addioreq, pfn_chnl_add_io_req);
+		STORE_FXN(fxn_chnl_getioc, pfn_chnl_get_ioc);
+		STORE_FXN(fxn_chnl_cancelio, pfn_chnl_cancel_io);
+		STORE_FXN(fxn_chnl_flushio, pfn_chnl_flush_io);
+		STORE_FXN(fxn_chnl_getinfo, pfn_chnl_get_info);
+		STORE_FXN(fxn_chnl_getmgrinfo, pfn_chnl_get_mgr_info);
+		STORE_FXN(fxn_chnl_idle, pfn_chnl_idle);
+		STORE_FXN(fxn_chnl_registernotify, pfn_chnl_register_notify);
+		STORE_FXN(fxn_deh_create, pfn_deh_create);
+		STORE_FXN(fxn_deh_destroy, pfn_deh_destroy);
+		STORE_FXN(fxn_deh_notify, pfn_deh_notify);
+		STORE_FXN(fxn_deh_registernotify, pfn_deh_register_notify);
+		STORE_FXN(fxn_deh_getinfo, pfn_deh_get_info);
+		STORE_FXN(fxn_io_create, pfn_io_create);
+		STORE_FXN(fxn_io_destroy, pfn_io_destroy);
+		STORE_FXN(fxn_io_onloaded, pfn_io_on_loaded);
+		STORE_FXN(fxn_io_getprocload, pfn_io_get_proc_load);
+		STORE_FXN(fxn_msg_create, pfn_msg_create);
+		STORE_FXN(fxn_msg_createqueue, pfn_msg_create_queue);
+		STORE_FXN(fxn_msg_delete, pfn_msg_delete);
+		STORE_FXN(fxn_msg_deletequeue, pfn_msg_delete_queue);
+		STORE_FXN(fxn_msg_get, pfn_msg_get);
+		STORE_FXN(fxn_msg_put, pfn_msg_put);
+		STORE_FXN(fxn_msg_registernotify, pfn_msg_register_notify);
+		STORE_FXN(fxn_msg_setqueueid, pfn_msg_set_queue_id);
 	}
 	/* Add code for any additional functions in newer WMD versions here: */
 	/* Ensure postcondition: */
-	DBC_Ensure(pIntfFxns->pfnDevCreate != NULL);
-	DBC_Ensure(pIntfFxns->pfnDevDestroy != NULL);
-	DBC_Ensure(pIntfFxns->pfnDevCntrl != NULL);
-	DBC_Ensure(pIntfFxns->pfnBrdMonitor != NULL);
-	DBC_Ensure(pIntfFxns->pfnBrdStart != NULL);
-	DBC_Ensure(pIntfFxns->pfnBrdStop != NULL);
-	DBC_Ensure(pIntfFxns->pfnBrdStatus != NULL);
-	DBC_Ensure(pIntfFxns->pfnBrdRead != NULL);
-	DBC_Ensure(pIntfFxns->pfnBrdWrite != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlCreate != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlDestroy != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlOpen != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlClose != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlAddIOReq != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlGetIOC != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlCancelIO != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlFlushIO != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlGetInfo != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlGetMgrInfo != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlIdle != NULL);
-	DBC_Ensure(pIntfFxns->pfnChnlRegisterNotify != NULL);
-	DBC_Ensure(pIntfFxns->pfnDehCreate != NULL);
-	DBC_Ensure(pIntfFxns->pfnDehDestroy != NULL);
-	DBC_Ensure(pIntfFxns->pfnDehNotify != NULL);
-	DBC_Ensure(pIntfFxns->pfnDehRegisterNotify != NULL);
-	DBC_Ensure(pIntfFxns->pfnDehGetInfo != NULL);
-	DBC_Ensure(pIntfFxns->pfnIOCreate != NULL);
-	DBC_Ensure(pIntfFxns->pfnIODestroy != NULL);
-	DBC_Ensure(pIntfFxns->pfnIOOnLoaded != NULL);
-	DBC_Ensure(pIntfFxns->pfnIOGetProcLoad != NULL);
-	DBC_Ensure(pIntfFxns->pfnMsgSetQueueId != NULL);
+	DBC_ENSURE(intf_fxns->pfn_dev_create != NULL);
+	DBC_ENSURE(intf_fxns->pfn_dev_destroy != NULL);
+	DBC_ENSURE(intf_fxns->pfn_dev_cntrl != NULL);
+	DBC_ENSURE(intf_fxns->pfn_brd_monitor != NULL);
+	DBC_ENSURE(intf_fxns->pfn_brd_start != NULL);
+	DBC_ENSURE(intf_fxns->pfn_brd_stop != NULL);
+	DBC_ENSURE(intf_fxns->pfn_brd_status != NULL);
+	DBC_ENSURE(intf_fxns->pfn_brd_read != NULL);
+	DBC_ENSURE(intf_fxns->pfn_brd_write != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_create != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_destroy != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_open != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_close != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_add_io_req != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_get_ioc != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_cancel_io != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_flush_io != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_get_info != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_get_mgr_info != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_idle != NULL);
+	DBC_ENSURE(intf_fxns->pfn_chnl_register_notify != NULL);
+	DBC_ENSURE(intf_fxns->pfn_deh_create != NULL);
+	DBC_ENSURE(intf_fxns->pfn_deh_destroy != NULL);
+	DBC_ENSURE(intf_fxns->pfn_deh_notify != NULL);
+	DBC_ENSURE(intf_fxns->pfn_deh_register_notify != NULL);
+	DBC_ENSURE(intf_fxns->pfn_deh_get_info != NULL);
+	DBC_ENSURE(intf_fxns->pfn_io_create != NULL);
+	DBC_ENSURE(intf_fxns->pfn_io_destroy != NULL);
+	DBC_ENSURE(intf_fxns->pfn_io_on_loaded != NULL);
+	DBC_ENSURE(intf_fxns->pfn_io_get_proc_load != NULL);
+	DBC_ENSURE(intf_fxns->pfn_msg_set_queue_id != NULL);
 
-#undef  StoreFxn
+#undef  STORE_FXN
 }
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/dmm.c kernel-power-2.6.28.new/drivers/dsp/bridge/pmgr/dmm.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/dmm.c	2011-10-11 13:51:00.869490944 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/pmgr/dmm.c	2011-10-23 08:22:37.637567000 +0100
@@ -3,6 +3,13 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * The Dynamic Memory Manager (DMM) module manages the DSP Virtual address
+ * space that can be directly mapped to any MPU buffer or memory region
+ *
+ * Notes:
+ *   Region: Generic memory entitiy having a start address and a size
+ *   Chunk:  Reserved region
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,46 +21,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== dmm.c ========
- *  Purpose:
- *      The Dynamic Memory Manager (DMM) module manages the DSP Virtual address
- *      space that can be directly mapped to any MPU buffer or memory region
- *
- *  Public Functions:
- *      DMM_CreateTables
- *      DMM_Create
- *      DMM_Destroy
- *      DMM_Exit
- *      DMM_Init
- *      DMM_MapMemory
- *      DMM_Reset
- *      DMM_ReserveMemory
- *      DMM_UnMapMemory
- *      DMM_UnReserveMemory
- *
- *  Private Functions:
- *      AddRegion
- *      CreateRegion
- *      GetRegion
- *	GetFreeRegion
- *	GetMappedRegion
- *
- *  Notes:
- *      Region: Generic memory entitiy having a start address and a size
- *      Chunk:  Reserved region
- *
- *
- *! Revision History:
- *! ================
- *! 04-Jun-2008 Hari K : Optimized DMM implementation. Removed linked list
- *!                                and instead used Table approach.
- *! 19-Apr-2004 sb: Integrated Alan's code review updates.
- *! 17-Mar-2004 ap: Fixed GetRegion for size=0 using tighter bound.
- *! 20-Feb-2004 sb: Created.
- *!
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -64,10 +31,8 @@
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
 #include <dspbridge/errbase.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/sync.h>
 
@@ -83,574 +48,506 @@
 #define DMMSIGNATURE       0x004d4d44	/* "DMM"   (in reverse) */
 
 #define DMM_ADDR_VIRTUAL(a) \
-	(((struct MapPage *)(a) - pVirtualMappingTable) * PG_SIZE_4K +\
-	dynMemMapBeg)
-#define DMM_ADDR_TO_INDEX(a) (((a) - dynMemMapBeg) / PG_SIZE_4K)
+	(((struct map_page *)(a) - virtual_mapping_table) * PG_SIZE4K +\
+	dyn_mem_map_beg)
+#define DMM_ADDR_TO_INDEX(a) (((a) - dyn_mem_map_beg) / PG_SIZE4K)
 
 /* DMM Mgr */
-struct DMM_OBJECT {
-	u32 dwSignature;	/* Used for object validation */
+struct dmm_object {
+	u32 dw_signature;	/* Used for object validation */
 	/* Dmm Lock is used to serialize access mem manager for
 	 * multi-threads. */
-	struct SYNC_CSOBJECT *hDmmLock;	/* Lock to access dmm mgr */
+	struct sync_csobject *dmm_lock;	/* Lock to access dmm mgr */
 };
 
-
 /*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask DMM_debugMask = { NULL, NULL };	/* GT trace variable */
-#endif
-
-static u32 cRefs;		/* module reference count */
-struct MapPage {
-	u32   RegionSize:15;
-	u32   MappedSize:15;
-	u32   bReserved:1;
-	u32   bMapped:1;
+static u32 refs;		/* module reference count */
+struct map_page {
+	u32 region_size:31;
+	u32 reserved:1;
+	u32 mapped_size:31;
+	u32 mapped:1;
 };
 
 /*  Create the free list */
-static struct MapPage *pVirtualMappingTable;
-static u32  iFreeRegion;	/* The index of free region */
-static u32  iFreeSize;
-static u32  dynMemMapBeg;	/* The Beginning of dynamic memory mapping */
-static u32  TableSize;/* The size of virtual and physical pages tables */
+static struct map_page *virtual_mapping_table;
+static u32 free_region;		/* The index of free region */
+static u32 free_size;
+static u32 dyn_mem_map_beg;	/* The Beginning of dynamic memory mapping */
+static u32 table_size;		/* The size of virt and phys pages tables */
 
 /*  ----------------------------------- Function Prototypes */
-static struct MapPage *GetRegion(u32 addr);
-static struct MapPage *GetFreeRegion(u32 aSize);
-static struct MapPage *GetMappedRegion(u32 aAddr);
+static struct map_page *get_region(u32 addr);
+static struct map_page *get_free_region(u32 aSize);
+static struct map_page *get_mapped_region(u32 aAddr);
 #ifdef DSP_DMM_DEBUG
-u32 DMM_MemMapDump(struct DMM_OBJECT *hDmmMgr);
+u32 dmm_mem_map_dump(struct dmm_object *dmm_mgr);
 #endif
 
-/*  ======== DMM_CreateTables ========
+/*  ======== dmm_create_tables ========
  *  Purpose:
  *      Create table to hold the information of physical address
  *      the buffer pages that is passed by the user, and the table
  *      to hold the information of the virtual memory that is reserved
  *      for DSP.
  */
-DSP_STATUS DMM_CreateTables(struct DMM_OBJECT *hDmmMgr, u32 addr, u32 size)
+dsp_status dmm_create_tables(struct dmm_object *dmm_mgr, u32 addr, u32 size)
 {
-	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
-	DSP_STATUS status = DSP_SOK;
+	struct dmm_object *dmm_obj = (struct dmm_object *)dmm_mgr;
+	dsp_status status = DSP_SOK;
 
-	GT_3trace(DMM_debugMask, GT_ENTER,
-		 "Entered DMM_CreateTables () hDmmMgr %x, addr"
-		 " %x, size %x\n", hDmmMgr, addr, size);
-	status = DMM_DeleteTables(pDmmObj);
+	status = dmm_delete_tables(dmm_obj);
 	if (DSP_SUCCEEDED(status)) {
-		SYNC_EnterCS(pDmmObj->hDmmLock);
-		dynMemMapBeg = addr;
-		TableSize = PG_ALIGN_HIGH(size, PG_SIZE_4K)/PG_SIZE_4K;
+		sync_enter_cs(dmm_obj->dmm_lock);
+		dyn_mem_map_beg = addr;
+		table_size = PG_ALIGN_HIGH(size, PG_SIZE4K) / PG_SIZE4K;
 		/*  Create the free list */
-		pVirtualMappingTable = (struct MapPage *) MEM_Calloc
-			(TableSize * sizeof(struct MapPage), MEM_LARGEVIRTMEM);
-		if (pVirtualMappingTable == NULL)
+		virtual_mapping_table = (struct map_page *)mem_calloc
+		    (table_size * sizeof(struct map_page), MEM_LARGEVIRTMEM);
+		if (virtual_mapping_table == NULL)
 			status = DSP_EMEMORY;
 		else {
 			/* On successful allocation,
-			* all entries are zero ('free') */
-			iFreeRegion = 0;
-			iFreeSize = TableSize*PG_SIZE_4K;
-			pVirtualMappingTable[0].RegionSize = TableSize;
+			 * all entries are zero ('free') */
+			free_region = 0;
+			free_size = table_size * PG_SIZE4K;
+			virtual_mapping_table[0].region_size = table_size;
 		}
-		SYNC_LeaveCS(pDmmObj->hDmmLock);
-	} else
-		GT_0trace(DMM_debugMask, GT_7CLASS,
-			 "DMM_CreateTables: DMM_DeleteTables"
-			 "Failure\n");
+		sync_leave_cs(dmm_obj->dmm_lock);
+	}
+
+	if (DSP_FAILED(status))
+		pr_err("%s: failure, status 0x%x\n", __func__, status);
 
-	GT_1trace(DMM_debugMask, GT_4CLASS, "Leaving DMM_CreateTables status"
-							"0x%x\n", status);
 	return status;
 }
 
 /*
- *  ======== DMM_Create ========
+ *  ======== dmm_create ========
  *  Purpose:
  *      Create a dynamic memory manager object.
  */
-DSP_STATUS DMM_Create(OUT struct DMM_OBJECT **phDmmMgr,
-		     struct DEV_OBJECT *hDevObject,
-		     IN CONST struct DMM_MGRATTRS *pMgrAttrs)
-{
-	struct DMM_OBJECT *pDmmObject = NULL;
-	DSP_STATUS status = DSP_SOK;
-	DBC_Require(cRefs > 0);
-	DBC_Require(phDmmMgr != NULL);
-
-	GT_3trace(DMM_debugMask, GT_ENTER,
-		 "DMM_Create: phDmmMgr: 0x%x hDevObject: "
-		 "0x%x pMgrAttrs: 0x%x\n", phDmmMgr, hDevObject, pMgrAttrs);
+dsp_status dmm_create(OUT struct dmm_object **phDmmMgr,
+		      struct dev_object *hdev_obj,
+		      IN CONST struct dmm_mgrattrs *pMgrAttrs)
+{
+	struct dmm_object *dmm_obj = NULL;
+	dsp_status status = DSP_SOK;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phDmmMgr != NULL);
+
 	*phDmmMgr = NULL;
 	/* create, zero, and tag a cmm mgr object */
-	MEM_AllocObject(pDmmObject, struct DMM_OBJECT, DMMSIGNATURE);
-	if (pDmmObject != NULL) {
-		status = SYNC_InitializeCS(&pDmmObject->hDmmLock);
+	MEM_ALLOC_OBJECT(dmm_obj, struct dmm_object, DMMSIGNATURE);
+	if (dmm_obj != NULL) {
+		status = sync_initialize_cs(&dmm_obj->dmm_lock);
 		if (DSP_SUCCEEDED(status))
-			*phDmmMgr = pDmmObject;
+			*phDmmMgr = dmm_obj;
 		else
-			DMM_Destroy(pDmmObject);
+			dmm_destroy(dmm_obj);
 	} else {
-		GT_0trace(DMM_debugMask, GT_7CLASS,
-			 "DMM_Create: Object Allocation "
-			 "Failure(DMM Object)\n");
 		status = DSP_EMEMORY;
 	}
-	GT_2trace(DMM_debugMask, GT_4CLASS,
-			"Leaving DMM_Create status %x pDmmObject %x\n",
-			status, pDmmObject);
 
 	return status;
 }
 
 /*
- *  ======== DMM_Destroy ========
+ *  ======== dmm_destroy ========
  *  Purpose:
  *      Release the communication memory manager resources.
  */
-DSP_STATUS DMM_Destroy(struct DMM_OBJECT *hDmmMgr)
+dsp_status dmm_destroy(struct dmm_object *dmm_mgr)
 {
-	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
-	DSP_STATUS status = DSP_SOK;
+	struct dmm_object *dmm_obj = (struct dmm_object *)dmm_mgr;
+	dsp_status status = DSP_SOK;
 
-	GT_1trace(DMM_debugMask, GT_ENTER,
-		"Entered DMM_Destroy () hDmmMgr %x\n", hDmmMgr);
-	DBC_Require(cRefs > 0);
-	if (MEM_IsValidHandle(hDmmMgr, DMMSIGNATURE)) {
-		status = DMM_DeleteTables(pDmmObj);
+	DBC_REQUIRE(refs > 0);
+	if (MEM_IS_VALID_HANDLE(dmm_mgr, DMMSIGNATURE)) {
+		status = dmm_delete_tables(dmm_obj);
 		if (DSP_SUCCEEDED(status)) {
 			/* Delete CS & dmm mgr object */
-			SYNC_DeleteCS(pDmmObj->hDmmLock);
-			MEM_FreeObject(pDmmObj);
-		} else
-			GT_0trace(DMM_debugMask, GT_7CLASS,
-			 "DMM_Destroy: DMM_DeleteTables "
-			 "Failure\n");
+			sync_delete_cs(dmm_obj->dmm_lock);
+			MEM_FREE_OBJECT(dmm_obj);
+		}
 	} else
 		status = DSP_EHANDLE;
-	GT_1trace(DMM_debugMask, GT_4CLASS, "Leaving DMM_Destroy status %x\n",
-								status);
+
 	return status;
 }
 
-
 /*
- *  ======== DMM_DeleteTables ========
+ *  ======== dmm_delete_tables ========
  *  Purpose:
  *      Delete DMM Tables.
  */
-DSP_STATUS DMM_DeleteTables(struct DMM_OBJECT *hDmmMgr)
+dsp_status dmm_delete_tables(struct dmm_object *dmm_mgr)
 {
-	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
-	DSP_STATUS status = DSP_SOK;
+	struct dmm_object *dmm_obj = (struct dmm_object *)dmm_mgr;
+	dsp_status status = DSP_SOK;
 
-	GT_1trace(DMM_debugMask, GT_ENTER,
-		"Entered DMM_DeleteTables () hDmmMgr %x\n", hDmmMgr);
-	DBC_Require(cRefs > 0);
-	if (MEM_IsValidHandle(hDmmMgr, DMMSIGNATURE)) {
+	DBC_REQUIRE(refs > 0);
+	if (MEM_IS_VALID_HANDLE(dmm_mgr, DMMSIGNATURE)) {
 		/* Delete all DMM tables */
-		SYNC_EnterCS(pDmmObj->hDmmLock);
+		sync_enter_cs(dmm_obj->dmm_lock);
 
-		if (pVirtualMappingTable != NULL)
-			MEM_VFree(pVirtualMappingTable);
+		vfree(virtual_mapping_table);
 
-		SYNC_LeaveCS(pDmmObj->hDmmLock);
+		sync_leave_cs(dmm_obj->dmm_lock);
 	} else
 		status = DSP_EHANDLE;
-	GT_1trace(DMM_debugMask, GT_4CLASS,
-		"Leaving DMM_DeleteTables status %x\n", status);
 	return status;
 }
 
-
-
-
 /*
- *  ======== DMM_Exit ========
+ *  ======== dmm_exit ========
  *  Purpose:
  *      Discontinue usage of module; free resources when reference count
  *      reaches 0.
  */
-void DMM_Exit(void)
+void dmm_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
-
-	GT_1trace(DMM_debugMask, GT_ENTER,
-		 "exiting DMM_Exit, ref count:0x%x\n", cRefs);
+	refs--;
 }
 
 /*
- *  ======== DMM_GetHandle ========
+ *  ======== dmm_get_handle ========
  *  Purpose:
  *      Return the dynamic memory manager object for this device.
  *      This is typically called from the client process.
  */
-DSP_STATUS DMM_GetHandle(DSP_HPROCESSOR hProcessor,
-			OUT struct DMM_OBJECT **phDmmMgr)
+dsp_status dmm_get_handle(void *hprocessor, OUT struct dmm_object **phDmmMgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *hDevObject;
+	dsp_status status = DSP_SOK;
+	struct dev_object *hdev_obj;
 
-	GT_2trace(DMM_debugMask, GT_ENTER,
-		 "DMM_GetHandle: hProcessor %x, phDmmMgr"
-		 "%x\n", hProcessor, phDmmMgr);
-	DBC_Require(cRefs > 0);
-	DBC_Require(phDmmMgr != NULL);
-	if (hProcessor != NULL)
-		status = PROC_GetDevObject(hProcessor, &hDevObject);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phDmmMgr != NULL);
+	if (hprocessor != NULL)
+		status = proc_get_dev_object(hprocessor, &hdev_obj);
 	else
-		hDevObject = DEV_GetFirst();	/* default */
+		hdev_obj = dev_get_first();	/* default */
 
 	if (DSP_SUCCEEDED(status))
-		status = DEV_GetDmmMgr(hDevObject, phDmmMgr);
+		status = dev_get_dmm_mgr(hdev_obj, phDmmMgr);
 
-	GT_2trace(DMM_debugMask, GT_4CLASS, "Leaving DMM_GetHandle status %x, "
-		 "*phDmmMgr %x\n", status, phDmmMgr ? *phDmmMgr : NULL);
 	return status;
 }
 
 /*
- *  ======== DMM_Init ========
+ *  ======== dmm_init ========
  *  Purpose:
  *      Initializes private state of DMM module.
  */
-bool DMM_Init(void)
+bool dmm_init(void)
 {
-	bool fRetval = true;
-
-	DBC_Require(cRefs >= 0);
-
-	if (cRefs == 0) {
-		/* Set the Trace mask */
-		/*"DM" for Dymanic Memory Manager */
-		GT_create(&DMM_debugMask, "DM");
-	}
+	bool ret = true;
 
-	if (fRetval)
-		cRefs++;
+	DBC_REQUIRE(refs >= 0);
 
-	GT_1trace(DMM_debugMask, GT_ENTER,
-		 "Entered DMM_Init, ref count:0x%x\n", cRefs);
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	pVirtualMappingTable = NULL ;
-	TableSize = 0;
+	virtual_mapping_table = NULL;
+	table_size = 0;
 
-	return fRetval;
+	return ret;
 }
 
 /*
- *  ======== DMM_MapMemory ========
+ *  ======== dmm_map_memory ========
  *  Purpose:
  *      Add a mapping block to the reserved chunk. DMM assumes that this block
  *  will be mapped in the DSP/IVA's address space. DMM returns an error if a
  *  mapping overlaps another one. This function stores the info that will be
  *  required later while unmapping the block.
  */
-DSP_STATUS DMM_MapMemory(struct DMM_OBJECT *hDmmMgr, u32 addr, u32 size)
+dsp_status dmm_map_memory(struct dmm_object *dmm_mgr, u32 addr, u32 size)
 {
-	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
-	struct MapPage *chunk;
-	DSP_STATUS status = DSP_SOK;
-
-	GT_3trace(DMM_debugMask, GT_ENTER,
-		 "Entered DMM_MapMemory () hDmmMgr %x, "
-		 "addr %x, size %x\n", hDmmMgr, addr, size);
-	SYNC_EnterCS(pDmmObj->hDmmLock);
+	struct dmm_object *dmm_obj = (struct dmm_object *)dmm_mgr;
+	struct map_page *chunk;
+	dsp_status status = DSP_SOK;
+
+	sync_enter_cs(dmm_obj->dmm_lock);
 	/* Find the Reserved memory chunk containing the DSP block to
 	 * be mapped */
-	chunk = (struct MapPage *)GetRegion(addr);
+	chunk = (struct map_page *)get_region(addr);
 	if (chunk != NULL) {
 		/* Mark the region 'mapped', leave the 'reserved' info as-is */
-		chunk->bMapped = true;
-		chunk->MappedSize = (size/PG_SIZE_4K);
+		chunk->mapped = true;
+		chunk->mapped_size = (size / PG_SIZE4K);
 	} else
 		status = DSP_ENOTFOUND;
-	SYNC_LeaveCS(pDmmObj->hDmmLock);
-	GT_2trace(DMM_debugMask, GT_4CLASS,
-		 "Leaving DMM_MapMemory status %x, chunk %x\n",
-		status, chunk);
+	sync_leave_cs(dmm_obj->dmm_lock);
+
+	dev_dbg(bridge, "%s dmm_mgr %p, addr %x, size %x\n\tstatus %x, "
+		"chunk %p", __func__, dmm_mgr, addr, size, status, chunk);
+
 	return status;
 }
 
 /*
- *  ======== DMM_ReserveMemory ========
+ *  ======== dmm_reserve_memory ========
  *  Purpose:
  *      Reserve a chunk of virtually contiguous DSP/IVA address space.
  */
-DSP_STATUS DMM_ReserveMemory(struct DMM_OBJECT *hDmmMgr, u32 size,
-							u32 *pRsvAddr)
+dsp_status dmm_reserve_memory(struct dmm_object *dmm_mgr, u32 size,
+			      u32 *prsv_addr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
-	struct MapPage *node;
-	u32 rsvAddr = 0;
-	u32 rsvSize = 0;
-
-	GT_3trace(DMM_debugMask, GT_ENTER,
-		 "Entered DMM_ReserveMemory () hDmmMgr %x, "
-		 "size %x, pRsvAddr %x\n", hDmmMgr, size, pRsvAddr);
-	SYNC_EnterCS(pDmmObj->hDmmLock);
+	dsp_status status = DSP_SOK;
+	struct dmm_object *dmm_obj = (struct dmm_object *)dmm_mgr;
+	struct map_page *node;
+	u32 rsv_addr = 0;
+	u32 rsv_size = 0;
+
+	sync_enter_cs(dmm_obj->dmm_lock);
 
 	/* Try to get a DSP chunk from the free list */
-	node = GetFreeRegion(size);
+	node = get_free_region(size);
 	if (node != NULL) {
 		/*  DSP chunk of given size is available. */
-		rsvAddr = DMM_ADDR_VIRTUAL(node);
+		rsv_addr = DMM_ADDR_VIRTUAL(node);
 		/* Calculate the number entries to use */
-		rsvSize = size/PG_SIZE_4K;
-		if (rsvSize < node->RegionSize) {
+		rsv_size = size / PG_SIZE4K;
+		if (rsv_size < node->region_size) {
 			/* Mark remainder of free region */
-			node[rsvSize].bMapped = false;
-			node[rsvSize].bReserved = false;
-			node[rsvSize].RegionSize = node->RegionSize - rsvSize;
-			node[rsvSize].MappedSize = 0;
+			node[rsv_size].mapped = false;
+			node[rsv_size].reserved = false;
+			node[rsv_size].region_size =
+			    node->region_size - rsv_size;
+			node[rsv_size].mapped_size = 0;
 		}
-		/*  GetRegion will return first fit chunk. But we only use what
-			is requested. */
-		node->bMapped = false;
-		node->bReserved = true;
-		node->RegionSize = rsvSize;
-		node->MappedSize = 0;
+		/*  get_region will return first fit chunk. But we only use what
+		   is requested. */
+		node->mapped = false;
+		node->reserved = true;
+		node->region_size = rsv_size;
+		node->mapped_size = 0;
 		/* Return the chunk's starting address */
-		*pRsvAddr = rsvAddr;
+		*prsv_addr = rsv_addr;
 	} else
 		/*dSP chunk of given size is not available */
 		status = DSP_EMEMORY;
 
-	SYNC_LeaveCS(pDmmObj->hDmmLock);
-	GT_3trace(DMM_debugMask, GT_4CLASS,
-		 "Leaving ReserveMemory status %x, rsvAddr"
-		 " %x, rsvSize %x\n", status, rsvAddr, rsvSize);
+	sync_leave_cs(dmm_obj->dmm_lock);
+
+	dev_dbg(bridge, "%s dmm_mgr %p, size %x, prsv_addr %p\n\tstatus %x, "
+		"rsv_addr %x, rsv_size %x\n", __func__, dmm_mgr, size,
+		prsv_addr, status, rsv_addr, rsv_size);
+
 	return status;
 }
 
-
 /*
- *  ======== DMM_UnMapMemory ========
+ *  ======== dmm_un_map_memory ========
  *  Purpose:
  *      Remove the mapped block from the reserved chunk.
  */
-DSP_STATUS DMM_UnMapMemory(struct DMM_OBJECT *hDmmMgr, u32 addr, u32 *pSize)
+dsp_status dmm_un_map_memory(struct dmm_object *dmm_mgr, u32 addr, u32 *psize)
 {
-	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
-	struct MapPage *chunk;
-	DSP_STATUS status = DSP_SOK;
-
-	GT_3trace(DMM_debugMask, GT_ENTER,
-		 "Entered DMM_UnMapMemory () hDmmMgr %x, "
-		 "addr %x, pSize %x\n", hDmmMgr, addr, pSize);
-	SYNC_EnterCS(pDmmObj->hDmmLock);
-	chunk = GetMappedRegion(addr) ;
+	struct dmm_object *dmm_obj = (struct dmm_object *)dmm_mgr;
+	struct map_page *chunk;
+	dsp_status status = DSP_SOK;
+
+	sync_enter_cs(dmm_obj->dmm_lock);
+	chunk = get_mapped_region(addr);
 	if (chunk == NULL)
-		status = DSP_ENOTFOUND ;
+		status = DSP_ENOTFOUND;
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Unmap the region */
-		*pSize = chunk->MappedSize * PG_SIZE_4K;
-		chunk->bMapped = false;
-		chunk->MappedSize = 0;
+		*psize = chunk->mapped_size * PG_SIZE4K;
+		chunk->mapped = false;
+		chunk->mapped_size = 0;
 	}
-	SYNC_LeaveCS(pDmmObj->hDmmLock);
-	GT_3trace(DMM_debugMask, GT_ENTER,
-		 "Leaving DMM_UnMapMemory status %x, chunk"
-		 " %x,  *pSize %x\n", status, chunk, *pSize);
+	sync_leave_cs(dmm_obj->dmm_lock);
+
+	dev_dbg(bridge, "%s: dmm_mgr %p, addr %x, psize %p\n\tstatus %x, "
+		"chunk %p\n", __func__, dmm_mgr, addr, psize, status, chunk);
 
 	return status;
 }
 
 /*
- *  ======== DMM_UnReserveMemory ========
+ *  ======== dmm_un_reserve_memory ========
  *  Purpose:
  *      Free a chunk of reserved DSP/IVA address space.
  */
-DSP_STATUS DMM_UnReserveMemory(struct DMM_OBJECT *hDmmMgr, u32 rsvAddr)
+dsp_status dmm_un_reserve_memory(struct dmm_object *dmm_mgr, u32 rsv_addr)
 {
-	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
-	struct MapPage *chunk;
+	struct dmm_object *dmm_obj = (struct dmm_object *)dmm_mgr;
+	struct map_page *chunk;
 	u32 i;
-	DSP_STATUS status = DSP_SOK;
-	u32 chunkSize;
-
-	GT_2trace(DMM_debugMask, GT_ENTER,
-		 "Entered DMM_UnReserveMemory () hDmmMgr "
-		 "%x, rsvAddr %x\n", hDmmMgr, rsvAddr);
+	dsp_status status = DSP_SOK;
+	u32 chunk_size;
 
-	SYNC_EnterCS(pDmmObj->hDmmLock);
+	sync_enter_cs(dmm_obj->dmm_lock);
 
 	/* Find the chunk containing the reserved address */
-	chunk = GetMappedRegion(rsvAddr);
+	chunk = get_mapped_region(rsv_addr);
 	if (chunk == NULL)
 		status = DSP_ENOTFOUND;
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Free all the mapped pages for this reserved region */
 		i = 0;
-		while (i < chunk->RegionSize) {
-			if (chunk[i].bMapped) {
+		while (i < chunk->region_size) {
+			if (chunk[i].mapped) {
 				/* Remove mapping from the page tables. */
-				chunkSize = chunk[i].MappedSize;
+				chunk_size = chunk[i].mapped_size;
 				/* Clear the mapping flags */
-				chunk[i].bMapped = false;
-				chunk[i].MappedSize = 0;
-				i += chunkSize;
+				chunk[i].mapped = false;
+				chunk[i].mapped_size = 0;
+				i += chunk_size;
 			} else
 				i++;
 		}
 		/* Clear the flags (mark the region 'free') */
-		chunk->bReserved = false;
+		chunk->reserved = false;
 		/* NOTE: We do NOT coalesce free regions here.
-		 * Free regions are coalesced in GetRegion(), as it traverses
+		 * Free regions are coalesced in get_region(), as it traverses
 		 *the whole mapping table
 		 */
 	}
-	SYNC_LeaveCS(pDmmObj->hDmmLock);
-	GT_2trace(DMM_debugMask, GT_ENTER,
-		 "Leaving DMM_UnReserveMemory status %x"
-		 " chunk %x\n", status, chunk);
+	sync_leave_cs(dmm_obj->dmm_lock);
+
+	dev_dbg(bridge, "%s: dmm_mgr %p, rsv_addr %x\n\tstatus %x chunk %p",
+		__func__, dmm_mgr, rsv_addr, status, chunk);
+
 	return status;
 }
 
-
 /*
- *  ======== GetRegion ========
+ *  ======== get_region ========
  *  Purpose:
  *      Returns a region containing the specified memory region
  */
-static struct MapPage *GetRegion(u32 aAddr)
+static struct map_page *get_region(u32 aAddr)
 {
-	struct MapPage *currRegion = NULL;
-	u32   i = 0;
+	struct map_page *curr_region = NULL;
+	u32 i = 0;
 
-	GT_1trace(DMM_debugMask, GT_ENTER, "Entered GetRegion () "
-		" aAddr %x\n", aAddr);
-
-	if (pVirtualMappingTable != NULL) {
+	if (virtual_mapping_table != NULL) {
 		/* find page mapped by this address */
 		i = DMM_ADDR_TO_INDEX(aAddr);
-		if (i < TableSize)
-			currRegion = pVirtualMappingTable + i;
+		if (i < table_size)
+			curr_region = virtual_mapping_table + i;
 	}
-	GT_3trace(DMM_debugMask, GT_4CLASS,
-	       "Leaving GetRegion currRegion %x, iFreeRegion %d\n,"
-	       "iFreeSize %d\n", currRegion, iFreeRegion, iFreeSize) ;
-	return currRegion;
+
+	dev_dbg(bridge, "%s: curr_region %p, free_region %d, free_size %d\n",
+		__func__, curr_region, free_region, free_size);
+	return curr_region;
 }
 
 /*
- *  ======== GetFreeRegion ========
+ *  ======== get_free_region ========
  *  Purpose:
  *  Returns the requested free region
  */
-static struct MapPage *GetFreeRegion(u32 aSize)
+static struct map_page *get_free_region(u32 aSize)
 {
-	struct MapPage *currRegion = NULL;
-	u32   i = 0;
-	u32   RegionSize = 0;
-	u32   nextI = 0;
-	GT_1trace(DMM_debugMask, GT_ENTER, "Entered GetFreeRegion () "
-		"aSize 0x%x\n", aSize);
-
-	if (pVirtualMappingTable == NULL)
-		return currRegion;
-	if (aSize > iFreeSize) {
+	struct map_page *curr_region = NULL;
+	u32 i = 0;
+	u32 region_size = 0;
+	u32 next_i = 0;
+
+	if (virtual_mapping_table == NULL)
+		return curr_region;
+
 		/* Find the largest free region
-		* (coalesce during the traversal) */
-		while (i < TableSize) {
-			RegionSize = pVirtualMappingTable[i].RegionSize;
-			nextI = i+RegionSize;
-			if (pVirtualMappingTable[i].bReserved == false) {
+		 * (coalesce during the traversal) */
+		while (i < table_size) {
+			region_size = virtual_mapping_table[i].region_size;
+			next_i = i + region_size;
+			if (virtual_mapping_table[i].reserved == false) {
 				/* Coalesce, if possible */
-				if (nextI < TableSize &&
-				pVirtualMappingTable[nextI].bReserved
-							== false) {
-					pVirtualMappingTable[i].RegionSize +=
-					pVirtualMappingTable[nextI].RegionSize;
+				if (next_i < table_size &&
+				    virtual_mapping_table[next_i].reserved
+				    == false) {
+					virtual_mapping_table[i].region_size +=
+					    virtual_mapping_table
+					    [next_i].region_size;
 					continue;
 				}
-				RegionSize *= PG_SIZE_4K;
-				if (RegionSize > iFreeSize) 	{
-					iFreeRegion = i;
-					iFreeSize = RegionSize;
+				region_size *= PG_SIZE4K;
+				if (region_size >= aSize) {
+					free_region = i;
+					free_size = region_size;
+					break;
 				}
 			}
-			i = nextI;
+			i = next_i;
 		}
+	if (aSize <= free_size) {
+		curr_region = virtual_mapping_table + free_region;
+		free_region += (aSize / PG_SIZE4K);
+		free_size -= aSize;
 	}
-	if (aSize <= iFreeSize) {
-		currRegion = pVirtualMappingTable + iFreeRegion;
-		iFreeRegion += (aSize / PG_SIZE_4K);
-		iFreeSize -= aSize;
-	}
-	return currRegion;
+	return curr_region;
 }
 
 /*
- *  ======== GetMappedRegion ========
+ *  ======== get_mapped_region ========
  *  Purpose:
  *  Returns the requestedmapped region
  */
-static struct MapPage *GetMappedRegion(u32 aAddr)
+static struct map_page *get_mapped_region(u32 aAddr)
 {
-	u32   i = 0;
-	struct MapPage *currRegion = NULL;
-	GT_1trace(DMM_debugMask, GT_ENTER, "Entered GetMappedRegion () "
-						"aAddr 0x%x\n", aAddr);
+	u32 i = 0;
+	struct map_page *curr_region = NULL;
 
-	if (pVirtualMappingTable == NULL)
-		return currRegion;
+	if (virtual_mapping_table == NULL)
+		return curr_region;
 
 	i = DMM_ADDR_TO_INDEX(aAddr);
-	if (i < TableSize && (pVirtualMappingTable[i].bMapped ||
-			pVirtualMappingTable[i].bReserved))
-		currRegion = pVirtualMappingTable + i;
-	return currRegion;
+	if (i < table_size && (virtual_mapping_table[i].mapped ||
+			       virtual_mapping_table[i].reserved))
+		curr_region = virtual_mapping_table + i;
+	return curr_region;
 }
 
 #ifdef DSP_DMM_DEBUG
-u32 DMM_MemMapDump(struct DMM_OBJECT *hDmmMgr)
+u32 dmm_mem_map_dump(struct dmm_object *dmm_mgr)
 {
-	struct MapPage *curNode = NULL;
+	struct map_page *curr_node = NULL;
 	u32 i;
 	u32 freemem = 0;
 	u32 bigsize = 0;
 
-	SYNC_EnterCS(hDmmMgr->hDmmLock);
+	sync_enter_cs(dmm_mgr->dmm_lock);
 
-	if (pVirtualMappingTable != NULL) {
-		for (i = 0; i < TableSize; i +=
-				pVirtualMappingTable[i].RegionSize) {
-			curNode = pVirtualMappingTable + i;
-			if (curNode->bReserved == TRUE)	{
+	if (virtual_mapping_table != NULL) {
+		for (i = 0; i < table_size; i +=
+		     virtual_mapping_table[i].region_size) {
+			curr_node = virtual_mapping_table + i;
+			if (curr_node->reserved == TRUE) {
 				/*printk("RESERVED size = 0x%x, "
-					"Map size = 0x%x\n",
-					(curNode->RegionSize * PG_SIZE_4K),
-					(curNode->bMapped == false) ? 0 :
-					(curNode->MappedSize * PG_SIZE_4K));
-*/
+				   "Map size = 0x%x\n",
+				   (curr_node->region_size * PG_SIZE4K),
+				   (curr_node->mapped == false) ? 0 :
+				   (curr_node->mapped_size * PG_SIZE4K));
+				 */
 			} else {
 /*				printk("UNRESERVED size = 0x%x\n",
-					(curNode->RegionSize * PG_SIZE_4K));
-*/
-				freemem += (curNode->RegionSize * PG_SIZE_4K);
-				if (curNode->RegionSize > bigsize)
-					bigsize = curNode->RegionSize;
+					(curr_node->region_size * PG_SIZE4K));
+ */
+				freemem += (curr_node->region_size * PG_SIZE4K);
+				if (curr_node->region_size > bigsize)
+					bigsize = curr_node->region_size;
 			}
 		}
 	}
 	printk(KERN_INFO "Total DSP VA FREE memory = %d Mbytes\n",
-			freemem/(1024*1024));
+	       freemem / (1024 * 1024));
 	printk(KERN_INFO "Total DSP VA USED memory= %d Mbytes \n",
-			(((TableSize * PG_SIZE_4K)-freemem))/(1024*1024));
+	       (((table_size * PG_SIZE4K) - freemem)) / (1024 * 1024));
 	printk(KERN_INFO "DSP VA - Biggest FREE block = %d Mbytes \n\n",
-			(bigsize*PG_SIZE_4K/(1024*1024)));
-	SYNC_LeaveCS(hDmmMgr->hDmmLock);
+	       (bigsize * PG_SIZE4K / (1024 * 1024)));
+	sync_leave_cs(dmm_mgr->dmm_lock);
 
 	return 0;
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/io.c kernel-power-2.6.28.new/drivers/dsp/bridge/pmgr/io.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/io.c	2011-10-11 13:51:00.892608882 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/pmgr/io.c	2011-10-23 08:22:37.637567000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * IO manager interface: Manages IO between CHNL and msg_ctrl.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,29 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== io.c ========
- *  Description:
- *      IO manager interface: Manages IO between CHNL and MSG.
- *
- *  Public Functions:
- *      IO_Create
- *      IO_Destroy
- *      IO_Exit
- *      IO_Init
- *      IO_OnLoaded
- *
- *  Notes:
- *      This interface is basically a pass through to the WMD IO functions.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 swa 	PMGR Code review comments incorporated.
- *! 04-Apr-2001 rr      WSX_STATUS initialized in IO_Create.
- *! 07-Nov-2000 jeh     Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -47,7 +26,6 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/cfg.h>
@@ -62,144 +40,105 @@
 #include <dspbridge/io.h>
 
 /*  ----------------------------------- Globals */
-static u32 cRefs;
-
-#if GT_TRACE
-static struct GT_Mask IO_DebugMask = { NULL, NULL };	/* WCD IO Mask */
-#endif
+static u32 refs;
 
 /*
- *  ======== IO_Create ========
+ *  ======== io_create ========
  *  Purpose:
  *      Create an IO manager object, responsible for managing IO between
- *      CHNL and MSG
+ *      CHNL and msg_ctrl
  */
-DSP_STATUS IO_Create(OUT struct IO_MGR **phIOMgr, struct DEV_OBJECT *hDevObject,
-		    IN CONST struct IO_ATTRS *pMgrAttrs)
+dsp_status io_create(OUT struct io_mgr **phIOMgr, struct dev_object *hdev_obj,
+		     IN CONST struct io_attrs *pMgrAttrs)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct IO_MGR *hIOMgr = NULL;
-	struct IO_MGR_ *pIOMgr = NULL;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(phIOMgr != NULL);
-	DBC_Require(pMgrAttrs != NULL);
-
-	GT_3trace(IO_DebugMask, GT_ENTER, "Entered IO_Create: phIOMgr: 0x%x\t "
-		 "hDevObject: 0x%x\tpMgrAttrs: 0x%x\n",
-		 phIOMgr, hDevObject, pMgrAttrs);
+	struct bridge_drv_interface *intf_fxns;
+	struct io_mgr *hio_mgr = NULL;
+	struct io_mgr_ *pio_mgr = NULL;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phIOMgr != NULL);
+	DBC_REQUIRE(pMgrAttrs != NULL);
 
 	*phIOMgr = NULL;
 
-	/* A memory base of 0 implies no memory base:  */
-	if ((pMgrAttrs->dwSMBase != 0) && (pMgrAttrs->uSMLength == 0)) {
+	/* A memory base of 0 implies no memory base: */
+	if ((pMgrAttrs->shm_base != 0) && (pMgrAttrs->usm_length == 0))
 		status = CHNL_E_INVALIDMEMBASE;
-		GT_0trace(IO_DebugMask, GT_7CLASS,
-			 "IO_Create:Invalid Mem Base\n");
-	}
 
-	if (pMgrAttrs->uWordSize == 0) {
+	if (pMgrAttrs->word_size == 0)
 		status = CHNL_E_INVALIDWORDSIZE;
-		GT_0trace(IO_DebugMask, GT_7CLASS,
-			 "IO_Create:Invalid Word size\n");
-	}
 
 	if (DSP_SUCCEEDED(status)) {
-		DEV_GetIntfFxns(hDevObject, &pIntfFxns);
+		dev_get_intf_fxns(hdev_obj, &intf_fxns);
 
 		/* Let WMD channel module finish the create: */
-		status = (*pIntfFxns->pfnIOCreate)(&hIOMgr, hDevObject,
-			 pMgrAttrs);
+		status = (*intf_fxns->pfn_io_create) (&hio_mgr, hdev_obj,
+						      pMgrAttrs);
 
 		if (DSP_SUCCEEDED(status)) {
-			pIOMgr = (struct IO_MGR_ *) hIOMgr;
-			pIOMgr->pIntfFxns = pIntfFxns;
-			pIOMgr->hDevObject = hDevObject;
+			pio_mgr = (struct io_mgr_ *)hio_mgr;
+			pio_mgr->intf_fxns = intf_fxns;
+			pio_mgr->hdev_obj = hdev_obj;
 
 			/* Return the new channel manager handle: */
-			*phIOMgr = hIOMgr;
-			GT_1trace(IO_DebugMask, GT_1CLASS,
-				 "IO_Create: Success hIOMgr: 0x%x\n",
-				 hIOMgr);
+			*phIOMgr = hio_mgr;
 		}
 	}
 
-	GT_2trace(IO_DebugMask, GT_ENTER,
-		 "Exiting IO_Create: hIOMgr: 0x%x, status:"
-		 " 0x%x\n", hIOMgr, status);
-
 	return status;
 }
 
 /*
- *  ======== IO_Destroy ========
+ *  ======== io_destroy ========
  *  Purpose:
  *      Delete IO manager.
  */
-DSP_STATUS IO_Destroy(struct IO_MGR *hIOMgr)
+dsp_status io_destroy(struct io_mgr *hio_mgr)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct IO_MGR_ *pIOMgr = (struct IO_MGR_ *)hIOMgr;
-	DSP_STATUS status;
+	struct bridge_drv_interface *intf_fxns;
+	struct io_mgr_ *pio_mgr = (struct io_mgr_ *)hio_mgr;
+	dsp_status status;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	GT_1trace(IO_DebugMask, GT_ENTER, "Entered IO_Destroy: hIOMgr: 0x%x\n",
-		  hIOMgr);
+	intf_fxns = pio_mgr->intf_fxns;
 
-	pIntfFxns = pIOMgr->pIntfFxns;
+	/* Let WMD channel module destroy the io_mgr: */
+	status = (*intf_fxns->pfn_io_destroy) (hio_mgr);
 
-	/* Let WMD channel module destroy the IO_MGR: */
-	status = (*pIntfFxns->pfnIODestroy) (hIOMgr);
-
-	GT_2trace(IO_DebugMask, GT_ENTER,
-		 "Exiting IO_Destroy: pIOMgr: 0x%x, status:"
-		 " 0x%x\n", pIOMgr, status);
 	return status;
 }
 
 /*
- *  ======== IO_Exit ========
+ *  ======== io_exit ========
  *  Purpose:
  *      Discontinue usage of the IO module.
  */
-void IO_Exit(void)
+void io_exit(void)
 {
-	DBC_Require(cRefs > 0);
-
-	cRefs--;
+	DBC_REQUIRE(refs > 0);
 
-	GT_1trace(IO_DebugMask, GT_5CLASS,
-		 "Entered IO_Exit, ref count: 0x%x\n", cRefs);
+	refs--;
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== IO_Init ========
+ *  ======== io_init ========
  *  Purpose:
  *      Initialize the IO module's private state.
  */
-bool IO_Init(void)
+bool io_init(void)
 {
-	bool fRetval = true;
-
-	DBC_Require(cRefs >= 0);
-
-	if (cRefs == 0) {
-		DBC_Assert(!IO_DebugMask.flags);
-		GT_create(&IO_DebugMask, "IO");	/* "IO" for IO */
-	}
-
-	if (fRetval)
-		cRefs++;
+	bool ret = true;
 
+	DBC_REQUIRE(refs >= 0);
 
-	GT_1trace(IO_DebugMask, GT_5CLASS,
-		 "Entered IO_Init, ref count: 0x%x\n", cRefs);
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	return fRetval;
+	return ret;
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/ioobj.h kernel-power-2.6.28.new/drivers/dsp/bridge/pmgr/ioobj.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/ioobj.h	2011-10-11 13:51:00.892608882 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/pmgr/ioobj.h	2011-10-23 08:22:37.637567000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Structure subcomponents of channel class library IO objects which
+ * are exposed to class driver from mini-driver.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,22 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== ioobj.h ========
- *  Description:
- *      Structure subcomponents of channel class library IO objects which
- *      are exposed to class driver from mini-driver.
- *
- *  Public Functions:
- *      None.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 swa PMGR Code review comments incorporated.
- *! 01/16/97 gp: Created from chnlpriv.h
- */
-
 #ifndef IOOBJ_
 #define IOOBJ_
 
@@ -37,16 +24,16 @@
 #include <dspbridge/wmd.h>
 
 /*
- *  This struct is the first field in a IO_MGR struct, as implemented in
+ *  This struct is the first field in a io_mgr struct, as implemented in
  *  a WMD channel class library.  Other, implementation specific fields
  *  follow this structure in memory.
  */
-struct IO_MGR_ {
-	/* These must be the first fields in a IO_MGR struct: */
-	u32 dwSignature;	/* Used for object validation.   */
-	struct WMD_DEV_CONTEXT *hWmdContext;	/* WMD device context.  */
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD. */
-	struct DEV_OBJECT *hDevObject;	/* Device this board represents. */
-} ;
+struct io_mgr_ {
+	/* These must be the first fields in a io_mgr struct: */
+	u32 dw_signature;	/* Used for object validation. */
+	struct wmd_dev_context *hwmd_context;	/* WMD device context. */
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD. */
+	struct dev_object *hdev_obj;	/* Device this board represents. */
+};
 
-#endif				/* IOOBJ_ */
+#endif /* IOOBJ_ */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/msg.c kernel-power-2.6.28.new/drivers/dsp/bridge/pmgr/msg.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/msg.c	2011-10-11 13:51:00.903354774 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/pmgr/msg.c	2011-10-23 08:22:37.637567000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge msg_ctrl Module.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,27 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== msg.c ========
- *  Description:
- *      DSP/BIOS Bridge MSG Module.
- *
- *  Public Functions:
- *      MSG_Create
- *      MSG_Delete
- *      MSG_Exit
- *      MSG_Init
- *
- *! Revision History:
- *! =================
- *! 24-Feb-2003 swa 	PMGR Code review comments incorporated.
- *! 15-May-2001 ag      Changed SUCCEEDED to DSP_SUCCEEDED.
- *! 16-Feb-2001 jeh     Fixed some comments.
- *! 15-Dec-2000 rr      MSG_Create returns DSP_EFAIL if pfnMsgCreate fails.
- *! 12-Sep-2000 jeh     Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -45,10 +26,8 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 
 /*  ----------------------------------- Mini Driver */
@@ -62,51 +41,43 @@
 #include <dspbridge/msg.h>
 
 /*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask MSG_debugMask = { NULL, NULL };	/* GT trace variable */
-#endif
-static u32 cRefs;		/* module reference count */
+static u32 refs;		/* module reference count */
 
 /*
- *  ======== MSG_Create ========
+ *  ======== msg_create ========
  *  Purpose:
  *      Create an object to manage message queues. Only one of these objects
  *      can exist per device object.
  */
-DSP_STATUS MSG_Create(OUT struct MSG_MGR **phMsgMgr,
-		      struct DEV_OBJECT *hDevObject, MSG_ONEXIT msgCallback)
+dsp_status msg_create(OUT struct msg_mgr **phMsgMgr,
+		      struct dev_object *hdev_obj, msg_onexit msgCallback)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct MSG_MGR_ *pMsgMgr;
-	struct MSG_MGR *hMsgMgr;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(phMsgMgr != NULL);
-	DBC_Require(msgCallback != NULL);
-	DBC_Require(hDevObject != NULL);
-
-	GT_3trace(MSG_debugMask, GT_ENTER, "MSG_Create: phMsgMgr: 0x%x\t"
-		 "hDevObject: 0x%x\tmsgCallback: 0x%x\n",
-		 phMsgMgr, hDevObject, msgCallback);
+	struct bridge_drv_interface *intf_fxns;
+	struct msg_mgr_ *msg_mgr_obj;
+	struct msg_mgr *hmsg_mgr;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phMsgMgr != NULL);
+	DBC_REQUIRE(msgCallback != NULL);
+	DBC_REQUIRE(hdev_obj != NULL);
 
 	*phMsgMgr = NULL;
 
-	DEV_GetIntfFxns(hDevObject, &pIntfFxns);
+	dev_get_intf_fxns(hdev_obj, &intf_fxns);
 
 	/* Let WMD message module finish the create: */
-	status = (*pIntfFxns->pfnMsgCreate)(&hMsgMgr, hDevObject, msgCallback);
+	status =
+	    (*intf_fxns->pfn_msg_create) (&hmsg_mgr, hdev_obj, msgCallback);
 
 	if (DSP_SUCCEEDED(status)) {
-		/* Fill in WCD message module's fields of the MSG_MGR
+		/* Fill in WCD message module's fields of the msg_mgr
 		 * structure */
-		pMsgMgr = (struct MSG_MGR_ *)hMsgMgr;
-		pMsgMgr->pIntfFxns = pIntfFxns;
+		msg_mgr_obj = (struct msg_mgr_ *)hmsg_mgr;
+		msg_mgr_obj->intf_fxns = intf_fxns;
 
 		/* Finally, return the new message manager handle: */
-		*phMsgMgr = hMsgMgr;
-		GT_1trace(MSG_debugMask, GT_1CLASS,
-			 "MSG_Create: Success pMsgMgr: 0x%x\n",	pMsgMgr);
+		*phMsgMgr = hmsg_mgr;
 	} else {
 		status = DSP_EFAIL;
 	}
@@ -114,60 +85,49 @@
 }
 
 /*
- *  ======== MSG_Delete ========
+ *  ======== msg_delete ========
  *  Purpose:
- *      Delete a MSG manager allocated in MSG_Create().
+ *      Delete a msg_ctrl manager allocated in msg_create().
  */
-void MSG_Delete(struct MSG_MGR *hMsgMgr)
+void msg_delete(struct msg_mgr *hmsg_mgr)
 {
-	struct MSG_MGR_ *pMsgMgr = (struct MSG_MGR_ *)hMsgMgr;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(pMsgMgr, MSGMGR_SIGNATURE));
+	struct msg_mgr_ *msg_mgr_obj = (struct msg_mgr_ *)hmsg_mgr;
+	struct bridge_drv_interface *intf_fxns;
 
-	GT_1trace(MSG_debugMask, GT_ENTER, "MSG_Delete: hMsgMgr: 0x%x\n",
-		 hMsgMgr);
+	DBC_REQUIRE(refs > 0);
 
-	pIntfFxns = pMsgMgr->pIntfFxns;
+	if (MEM_IS_VALID_HANDLE(msg_mgr_obj, MSGMGR_SIGNATURE)) {
+		intf_fxns = msg_mgr_obj->intf_fxns;
 
-	/* Let WMD message module destroy the MSG_MGR: */
-	(*pIntfFxns->pfnMsgDelete)(hMsgMgr);
-
-	DBC_Ensure(!MEM_IsValidHandle(pMsgMgr, MSGMGR_SIGNATURE));
+		/* Let WMD message module destroy the msg_mgr: */
+		(*intf_fxns->pfn_msg_delete) (hmsg_mgr);
+	} else {
+		dev_dbg(bridge, "%s: Error hmsg_mgr handle: %p\n",
+			__func__, hmsg_mgr);
+	}
 }
 
 /*
- *  ======== MSG_Exit ========
+ *  ======== msg_exit ========
  */
-void MSG_Exit(void)
+void msg_exit(void)
 {
-	DBC_Require(cRefs > 0);
-	cRefs--;
-	GT_1trace(MSG_debugMask, GT_5CLASS,
-		 "Entered MSG_Exit, ref count: 0x%x\n",	cRefs);
-	DBC_Ensure(cRefs >= 0);
+	DBC_REQUIRE(refs > 0);
+	refs--;
+
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== MSG_Init ========
+ *  ======== msg_mod_init ========
  */
-bool MSG_Init(void)
+bool msg_mod_init(void)
 {
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (cRefs == 0) {
-		DBC_Assert(!MSG_debugMask.flags);
-		GT_create(&MSG_debugMask, "MS");	/* "MS" for MSg */
-	}
-
-	cRefs++;
+	refs++;
 
-	GT_1trace(MSG_debugMask, GT_5CLASS, "MSG_Init(), ref count:  0x%x\n",
-		 cRefs);
-
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 
 	return true;
 }
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/msgobj.h kernel-power-2.6.28.new/drivers/dsp/bridge/pmgr/msgobj.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/msgobj.h	2011-10-11 13:51:00.903354774 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/pmgr/msgobj.h	2011-10-23 08:22:37.637567000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Structure subcomponents of channel class library msg_ctrl objects which
+ * are exposed to class driver from mini-driver.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,22 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== msgobj.h ========
- *  Description:
- *      Structure subcomponents of channel class library MSG objects which
- *      are exposed to class driver from mini-driver.
- *
- *  Public Functions:
- *      None.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 swa 	PMGR Code review comments incorporated.
- *! 17-Nov-2000 jeh     Created.
- */
-
 #ifndef MSGOBJ_
 #define MSGOBJ_
 
@@ -38,15 +25,14 @@
 #include <dspbridge/msgdefs.h>
 
 /*
- *  This struct is the first field in a MSG_MGR struct, as implemented in
+ *  This struct is the first field in a msg_mgr struct, as implemented in
  *  a WMD channel class library.  Other, implementation specific fields
  *  follow this structure in memory.
  */
-struct MSG_MGR_ {
+struct msg_mgr_ {
 	/* The first two fields must match those in msgobj.h */
-	u32 dwSignature;
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD. */
+	u32 dw_signature;
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD. */
 };
 
-#endif				/* MSGOBJ_ */
-
+#endif /* MSGOBJ_ */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/wcd.c kernel-power-2.6.28.new/drivers/dsp/bridge/pmgr/wcd.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/pmgr/wcd.c	2011-10-11 13:51:01.127013126 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/pmgr/wcd.c	2011-10-23 08:22:37.641906000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Common WCD functions, also includes the wrapper
+ * functions called directly by the DeviceIOControl interface.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,83 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== wcd.c ========
- *  Description:
- *      Common WCD functions, also includes the wrapper
- *      functions called directly by the DeviceIOControl interface.
- *
- *  Public Functions:
- *      WCD_CallDevIOCtl
- *      WCD_Init
- *      WCD_InitComplete2
- *      WCD_Exit
- *      <MOD>WRAP_*
- *
- *! Revision History:
- *! ================
- *! 29-Apr-2004 hp  Call PROC_AutoStart only for DSP device
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping APIs
- *! 03-Apr-2003 sb  Process environment pointer in PROCWRAP_Load
- *! 24-Feb-2003 swa PMGR Code review comments incorporated.
- *! 30-Jan-2002 ag  CMMWRAP_AllocBuf name changed to CMMWRAP_CallocBuf
- *! 15-Jan-2002 ag  Added actual bufSize param to STRMWRAP_Reclaim[issue].
- *! 14-Dec-2001 rr  ARGS_NODE_CONNECT maps the pAttr.
- *! 03-Oct-2001 rr  ARGS_NODE_ALLOCMSGBUF/FREEMSGBUF maps the pAttr.
- *! 10-Sep-2001 ag  Added CMD_CMM_GETHANDLE.
- *! 23-Apr-2001 jeh Pass pStatus to NODE_Terminate.
- *! 11-Apr-2001 jeh STRMWRAP_Reclaim embedded pointer is mapped and unmapped.
- *! 13-Feb-2001 kc: DSP/BIOS Bridge name updates.
- *! 06-Dec-2000 jeh WRAP_MAP2CALLER pointers in RegisterNotify calls.
- *! 05-Dec-2000 ag: Removed MAP2CALLER in NODEWRAP_FreeMsgBuf().
- *! 22-Nov-2000 kc: Added MGRWRAP_GetPerf_Data().
- *! 20-Nov-2000 jeh Added MSG_Init()/MSG_Exit(), IO_Init()/IO_Exit().
- *!		 WRAP pointers to handles for PROC_Attach, NODE_Allocate.
- *! 27-Oct-2000 jeh Added NODEWRAP_AllocMsgBuf, NODEWRAP_FreeMsgBuf. Removed
- *!		 NODEWRAP_GetMessageStream.
- *! 12-Oct-2000 ag: Added user CMM wrappers.
- *! 05-Oct-2000 rr: WcdInitComplete2 will fail even if one BRD or PROC
- *!		 AutoStart fails.
- *! 25-Sep-2000 rr: Updated to Version 0.9
- *! 13-Sep-2000 jeh Pass ARGS_NODE_CONNECT.pAttrs to NODE_Connect().
- *! 11-Aug-2000 rr: Part of node enabled.
- *! 31-Jul-2000 rr: UTIL_Wrap and MEM_Wrap added to RM.
- *! 27-Jul-2000 rr: PROCWRAP, NODEWRAP and STRMWRAP implemented.
- *!		 STRM and some NODE Wrappers are not implemented.
- *! 27-Jun-2000 rr: MGRWRAP fxns added.IFDEF to build for PM or DSP/BIOS Bridge
- *! 08-Feb-2000 rr  File name changed to wcd.c
- *! 03-Feb-2000 rr: Module initialization are done by SERVICES init. GT Class
- *!		 changes for module init/exit fxns.
- *! 24-Jan-2000 rr: Merged with Scott's code.
- *! 21-Jan-1999 sg: Changed ARGS_CHNL_GETMODE field name from pdwMode to pMode.
- *! 17-Jan-2000 rr: BRD_GetStatus does WRAP_MAP2CALLER for state.
- *! 14-Dec-1999 ag: Removed _MAP2CALLER in CHNL_GetMgr().
- *! 13-Dec-1999 rr: BRDWRAP_GetSymbol, BRDWRAP_GetTrace uses WRAP_MAP2CALLER
- *!		 macros.BRDWRAP_Load maps and unmaps embedded pointers.
- *! 10-Dec-1999 ag: User CHNL bufs mapped in _AddIOReq & _GetIOCompletion.
- *! 09-Dec-1999 rr: BRDWRAP_Open and CHNLWRAP_GetMgr does not map
- *!		 pointer as there was a change in config.c
- *! 06-Dec-1999 rr: BRD_Read and Write Maps the buf pointers.
- *! 03-Dec-1999 rr: CHNLWRAP_GetMgr and BRDWRAP_Open maps  hDevNode pointer.
- *!		 WCD_InitComplete2 Included for BRD_AutoStart.
- *! 16-Nov-1999 ag: Map buf to process in CHNLWRAP_AllocBuffer().
- *!		 CHNL_GetMgr() Mapping Fix.
- *! 10-Nov-1999 ag: Removed unnecessary calls to WRAP_MAP2CALLER.
- *! 08-Nov-1999 kc: Added MEMRY & enabled BRD_IOCtl for tests.
- *! 29-Oct-1999 ag: Added CHNL.
- *! 29-Oct-1999 kc: Added trace statements; added ptr mapping; updated
- *!		 use of UTIL module API.
- *! 29-Oct-1999 rr: Wrapper functions does the Mapping of the Pointers.
- *!		 in WinCE all the explicit pointers will be converted
- *!		 by the OS during interprocess but not the embedded pointers.
- *! 16-Oct-1999 kc: Code review cleanup.
- *! 07-Oct-1999 kc: Added UTILWRAP_TestDll() to run PM test harness. See
- *!		 /src/doc/pmtest.doc for more detail.
- *! 09-Sep-1999 rr: After exactly two years(!). Adopted for WinCE. GT Enabled.
- *! 09-Sep-1997 gp: Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -101,14 +27,12 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/cfg.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/ntfy.h>
 #include <dspbridge/services.h>
-#include <dspbridge/util.h>
 
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/chnl.h>
@@ -124,7 +48,6 @@
 #include <dspbridge/node.h>
 #include <dspbridge/rmm.h>
 
-
 /*  ----------------------------------- Others */
 #include <dspbridge/msg.h>
 #include <dspbridge/cmm.h>
@@ -134,9 +57,7 @@
 #include <dspbridge/_dcd.h>
 #include <dspbridge/dbdcd.h>
 
-#ifndef RES_CLEANUP_DISABLE
 #include <dspbridge/resourcecleanup.h>
-#endif
 
 /*  ----------------------------------- Defines, Data Structures, Typedefs */
 #define MAX_TRACEBUFLEN 255
@@ -145,20 +66,169 @@
 #define MAX_STREAMS     16
 #define MAX_BUFS	64
 
+#ifdef BRIDGE_NEW_API
+
+/* Used to get dspbridge ioctl table */
+#define DB_GET_IOC_TABLE(cmd)	(DB_GET_MODULE(cmd) >> DB_MODULE_SHIFT)
+
+#else /* BRIDGE_NEW_API */
+
+/* Used to get dspbridge ioctl module */
+static u32 DB_GET_MODULE(int cmd)
+{
+	/* Check for new API */
+	if(_IOC_TYPE(cmd) == DB)
+		return ((cmd) & DB_MODULE_MASK);
+	if(cmd<DB_PROC)
+		return DB_MGR;
+	else if(cmd<DB_NODE)
+		return DB_PROC;
+	else if(cmd<DB_STRM)
+		return DB_NODE;
+	else if(cmd<DB_CMM)
+		return DB_STRM;
+	else
+		return DB_CMM;
+}
+
+/* Used to get dspbridge ioctl number */
+static u32 DB_GET_IOC(int cmd)
+{
+	/* Check for new API */
+	if(_IOC_TYPE(cmd) == DB)
+		return ((cmd) & DB_IOC_MASK);
+	if(cmd<DB_PROC)
+		return (cmd-DB_MGR);
+	else if(cmd<DB_NODE)
+		return (cmd-DB_PROC);
+	else if(cmd<DB_STRM)
+		return (cmd-DB_NODE);
+	else if(cmd<DB_CMM)
+		return (cmd-DB_STRM);
+	else
+		return (cmd-DB_CMM);
+}
+
+/* Used to get dspbridge ioctl table */
+static u32 DB_GET_IOC_TABLE(int cmd)
+{
+	/* Check for new API */
+	if(_IOC_TYPE(cmd) == DB)
+		return (DB_GET_MODULE(cmd) >> DB_MODULE_SHIFT);
+	if(cmd<DB_PROC)
+		return 0;
+	else if(cmd<DB_NODE)
+		return 1;
+	else if(cmd<DB_STRM)
+		return 2;
+	else if(cmd<DB_CMM)
+		return 3;
+	else
+		return 4;
+}
+
+#endif
+
 /* Device IOCtl function pointer */
-struct WCD_Cmd {
-	u32(*fxn)(union Trapped_Args *args, void *pr_ctxt);
-	u32 dwIndex;
-} ;
+struct wcd_cmd {
+	u32(*fxn) (union Trapped_Args *args, void *pr_ctxt);
+	u32 dw_index;
+};
 
 /*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask WCD_debugMask = { NULL, NULL };	/* Core VxD Mask */
-#endif
-static u32 WCD_cRefs;
+static u32 wcd_c_refs;
+
+/*
+ *  Function tables.
+ *  The order of these functions MUST be the same as the order of the command
+ *  numbers defined in wcdioctl.h  This is how an IOCTL number in user mode
+ *  turns into a function call in kernel mode.
+ */
+
+/* MGR wrapper functions */
+static struct wcd_cmd mgr_cmd[] = {
+	{mgrwrap_enum_node_info},	/* MGR_ENUMNODE_INFO */
+	{mgrwrap_enum_proc_info},	/* MGR_ENUMPROC_INFO */
+	{mgrwrap_register_object},	/* MGR_REGISTEROBJECT */
+	{mgrwrap_unregister_object},	/* MGR_UNREGISTEROBJECT */
+	{mgrwrap_wait_for_bridge_events},	/* MGR_WAIT */
+	{mgrwrap_get_process_resources_info},	/* MGR_GET_PROC_RES */
+};
+
+/* PROC wrapper functions */
+static struct wcd_cmd proc_cmd[] = {
+	{procwrap_attach},	/* PROC_ATTACH */
+	{procwrap_ctrl},	/* PROC_CTRL */
+	{procwrap_detach},	/* PROC_DETACH */
+	{procwrap_enum_node_info},	/* PROC_ENUMNODE */
+	{procwrap_enum_resources},	/* PROC_ENUMRESOURCES */
+	{procwrap_get_state},	/* PROC_GET_STATE */
+	{procwrap_get_trace},	/* PROC_GET_TRACE */
+	{procwrap_load},	/* PROC_LOAD */
+	{procwrap_register_notify},	/* PROC_REGISTERNOTIFY */
+	{procwrap_start},	/* PROC_START */
+	{procwrap_reserve_memory},	/* PROC_RSVMEM */
+	{procwrap_un_reserve_memory},	/* PROC_UNRSVMEM */
+	{procwrap_map},		/* PROC_MAPMEM */
+	{procwrap_un_map},	/* PROC_UNMAPMEM */
+	{procwrap_flush_memory},	/* PROC_FLUSHMEMORY */
+	{procwrap_stop},	/* PROC_STOP */
+	{procwrap_invalidate_memory},	/* PROC_INVALIDATEMEMORY */
+};
 
-static inline void __cp_fm_usr(void *to, const void __user *from,
-			       DSP_STATUS *err, unsigned long bytes)
+/* NODE wrapper functions */
+static struct wcd_cmd node_cmd[] = {
+	{nodewrap_allocate},	/* NODE_ALLOCATE */
+	{nodewrap_alloc_msg_buf},	/* NODE_ALLOCMSGBUF */
+	{nodewrap_change_priority},	/* NODE_CHANGEPRIORITY */
+	{nodewrap_connect},	/* NODE_CONNECT */
+	{nodewrap_create},	/* NODE_CREATE */
+	{nodewrap_delete},	/* NODE_DELETE */
+	{nodewrap_free_msg_buf},	/* NODE_FREEMSGBUF */
+	{nodewrap_get_attr},	/* NODE_GETATTR */
+	{nodewrap_get_message},	/* NODE_GETMESSAGE */
+	{nodewrap_pause},	/* NODE_PAUSE */
+	{nodewrap_put_message},	/* NODE_PUTMESSAGE */
+	{nodewrap_register_notify},	/* NODE_REGISTERNOTIFY */
+	{nodewrap_run},		/* NODE_RUN */
+	{nodewrap_terminate},	/* NODE_TERMINATE */
+	{nodewrap_get_uuid_props},	/* NODE_GETUUIDPROPS */
+};
+
+/* STRM wrapper functions */
+static struct wcd_cmd strm_cmd[] = {
+	{strmwrap_allocate_buffer},	/* STRM_ALLOCATEBUFFER */
+	{strmwrap_close},	/* STRM_CLOSE */
+	{strmwrap_free_buffer},	/* STRM_FREEBUFFER */
+	{strmwrap_get_event_handle},	/* STRM_GETEVENTHANDLE */
+	{strmwrap_get_info},	/* STRM_GETINFO */
+	{strmwrap_idle},	/* STRM_IDLE */
+	{strmwrap_issue},	/* STRM_ISSUE */
+	{strmwrap_open},	/* STRM_OPEN */
+	{strmwrap_reclaim},	/* STRM_RECLAIM */
+	{strmwrap_register_notify},	/* STRM_REGISTERNOTIFY */
+	{strmwrap_select},	/* STRM_SELECT */
+};
+
+/* CMM wrapper functions */
+static struct wcd_cmd cmm_cmd[] = {
+	{cmmwrap_calloc_buf},	/* CMM_ALLOCBUF */
+	{cmmwrap_free_buf},	/* CMM_FREEBUF */
+	{cmmwrap_get_handle},	/* CMM_GETHANDLE */
+	{cmmwrap_get_info},	/* CMM_GETINFO */
+};
+
+/* Array used to store ioctl table sizes. It can hold up to 8 entries */
+static u8 size_cmd[] = {
+	ARRAY_SIZE(mgr_cmd),
+	ARRAY_SIZE(proc_cmd),
+	ARRAY_SIZE(node_cmd),
+	ARRAY_SIZE(strm_cmd),
+	ARRAY_SIZE(cmm_cmd),
+};
+
+static inline void _cp_fm_usr(void *to, const void __user * from,
+			      dsp_status *err, unsigned long bytes)
 {
 	if (DSP_FAILED(*err))
 		return;
@@ -168,17 +238,15 @@
 		return;
 	}
 
-	if (unlikely(copy_from_user(to, from, bytes))) {
-		GT_2trace(WCD_debugMask, GT_7CLASS,
-			  "%s failed, from=0x%08x\n", __func__, from);
+	if (unlikely(copy_from_user(to, from, bytes)))
 		*err = DSP_EPOINTER;
-	}
 }
-#define cp_fm_usr(to, from, err, n)				\
-	__cp_fm_usr(to, from, &(err), (n) * sizeof(*(to)))
 
-static inline void __cp_to_usr(void __user *to, const void *from,
-			       DSP_STATUS *err, unsigned long bytes)
+#define CP_FM_USR(to, from, err, n)				\
+	_cp_fm_usr(to, from, &(err), (n) * sizeof(*(to)))
+
+static inline void _cp_to_usr(void __user *to, const void *from,
+			      dsp_status *err, unsigned long bytes)
 {
 	if (DSP_FAILED(*err))
 		return;
@@ -188,228 +256,207 @@
 		return;
 	}
 
-	if (unlikely(copy_to_user(to, from, bytes))) {
-		GT_2trace(WCD_debugMask, GT_7CLASS,
-			  "%s failed, to=0x%08x\n", __func__, to);
+	if (unlikely(copy_to_user(to, from, bytes)))
 		*err = DSP_EPOINTER;
-	}
 }
-#define cp_to_usr(to, from, err, n)				\
-	__cp_to_usr(to, from, &(err), (n) * sizeof(*(from)))
 
-/*
- *  Function table.
- *  The order of these functions MUST be the same as the order of the command
- *  numbers defined in wcdioctl.h  This is how an IOCTL number in user mode
- *  turns into a function call in kernel mode.
- */
-static struct WCD_Cmd WCD_cmdTable[] = {
-	/* MGR module */
-	{MGRWRAP_EnumNode_Info, CMD_MGR_ENUMNODE_INFO_OFFSET},
-	{MGRWRAP_EnumProc_Info, CMD_MGR_ENUMPROC_INFO_OFFSET},
-	{MGRWRAP_RegisterObject, CMD_MGR_REGISTEROBJECT_OFFSET},
-	{MGRWRAP_UnregisterObject, CMD_MGR_UNREGISTEROBJECT_OFFSET},
-	{MGRWRAP_WaitForBridgeEvents, CMD_MGR_WAIT_OFFSET},
-#ifndef RES_CLEANUP_DISABLE
-	{MGRWRAP_GetProcessResourcesInfo, CMD_MGR_RESOUCES_OFFSET},
-#endif
-	/* PROC Module */
-	{PROCWRAP_Attach, CMD_PROC_ATTACH_OFFSET},
-	{PROCWRAP_Ctrl, CMD_PROC_CTRL_OFFSET},
-	{PROCWRAP_Detach, CMD_PROC_DETACH_OFFSET},
-	{PROCWRAP_EnumNode_Info, CMD_PROC_ENUMNODE_OFFSET},
-	{PROCWRAP_EnumResources, CMD_PROC_ENUMRESOURCES_OFFSET},
-	{PROCWRAP_GetState, CMD_PROC_GETSTATE_OFFSET},
-	{PROCWRAP_GetTrace, CMD_PROC_GETTRACE_OFFSET},
-	{PROCWRAP_Load, CMD_PROC_LOAD_OFFSET},
-	{PROCWRAP_RegisterNotify, CMD_PROC_REGISTERNOTIFY_OFFSET},
-	{PROCWRAP_Start, CMD_PROC_START_OFFSET},
-	{PROCWRAP_ReserveMemory, CMD_PROC_RSVMEM_OFFSET},
-	{PROCWRAP_UnReserveMemory, CMD_PROC_UNRSVMEM_OFFSET},
-	{PROCWRAP_Map, CMD_PROC_MAPMEM_OFFSET},
-	{PROCWRAP_UnMap, CMD_PROC_UNMAPMEM_OFFSET},
-	{PROCWRAP_FlushMemory, CMD_PROC_FLUSHMEMORY_OFFSET},
-	{PROCWRAP_Stop, CMD_PROC_STOP_OFFSET},
-	{PROCWRAP_InvalidateMemory, CMD_PROC_INVALIDATEMEMORY_OFFSET},
-	/* NODE Module */
-	{NODEWRAP_Allocate, CMD_NODE_ALLOCATE_OFFSET},
-	{NODEWRAP_AllocMsgBuf, CMD_NODE_ALLOCMSGBUF_OFFSET},
-	{NODEWRAP_ChangePriority, CMD_NODE_CHANGEPRIORITY_OFFSET},
-	{NODEWRAP_Connect, CMD_NODE_CONNECT_OFFSET},
-	{NODEWRAP_Create, CMD_NODE_CREATE_OFFSET},
-	{NODEWRAP_Delete, CMD_NODE_DELETE_OFFSET},
-	{NODEWRAP_FreeMsgBuf, CMD_NODE_FREEMSGBUF_OFFSET},
-	{NODEWRAP_GetAttr, CMD_NODE_GETATTR_OFFSET},
-	{NODEWRAP_GetMessage, CMD_NODE_GETMESSAGE_OFFSET},
-	{NODEWRAP_Pause, CMD_NODE_PAUSE_OFFSET},
-	{NODEWRAP_PutMessage, CMD_NODE_PUTMESSAGE_OFFSET},
-	{NODEWRAP_RegisterNotify, CMD_NODE_REGISTERNOTIFY_OFFSET},
-	{NODEWRAP_Run, CMD_NODE_RUN_OFFSET},
-	{NODEWRAP_Terminate, CMD_NODE_TERMINATE_OFFSET},
-	{NODEWRAP_GetUUIDProps, CMD_NODE_GETUUIDPROPS_OFFSET},
-	/* STRM wrapper functions */
-	{STRMWRAP_AllocateBuffer, CMD_STRM_ALLOCATEBUFFER_OFFSET},
-	{STRMWRAP_Close, CMD_STRM_CLOSE_OFFSET},
-	{STRMWRAP_FreeBuffer, CMD_STRM_FREEBUFFER_OFFSET},
-	{STRMWRAP_GetEventHandle, CMD_STRM_GETEVENTHANDLE_OFFSET},
-	{STRMWRAP_GetInfo, CMD_STRM_GETINFO_OFFSET},
-	{STRMWRAP_Idle, CMD_STRM_IDLE_OFFSET},
-	{STRMWRAP_Issue, CMD_STRM_ISSUE_OFFSET},
-	{STRMWRAP_Open, CMD_STRM_OPEN_OFFSET},
-	{STRMWRAP_Reclaim, CMD_STRM_RECLAIM_OFFSET},
-	{STRMWRAP_RegisterNotify, CMD_STRM_REGISTERNOTIFY_OFFSET},
-	{STRMWRAP_Select, CMD_STRM_SELECT_OFFSET},
-	/* CMM module */
-	{CMMWRAP_CallocBuf, CMD_CMM_ALLOCBUF_OFFSET},
-	{CMMWRAP_FreeBuf, CMD_CMM_FREEBUF_OFFSET},
-	{CMMWRAP_GetHandle, CMD_CMM_GETHANDLE_OFFSET},
-	{CMMWRAP_GetInfo, CMD_CMM_GETINFO_OFFSET}
-};
+#define CP_TO_USR(to, from, err, n)				\
+	_cp_to_usr(to, from, &(err), (n) * sizeof(*(from)))
 
 /*
- *  ======== WCD_CallDevIOCtl ========
+ *  ======== wcd_call_dev_io_ctl ========
  *  Purpose:
  *      Call the (wrapper) function for the corresponding WCD IOCTL.
  */
-inline DSP_STATUS WCD_CallDevIOCtl(u32 cmd, union Trapped_Args *args,
-				    u32 *pResult, void *pr_ctxt)
+inline dsp_status wcd_call_dev_io_ctl(u32 cmd, union Trapped_Args *args,
+				      u32 *result, void *pr_ctxt)
 {
-	if ((cmd < (sizeof(WCD_cmdTable) / sizeof(struct WCD_Cmd)))) {
-		/* make the fxn call via the cmd table */
-		*pResult = (*WCD_cmdTable[cmd].fxn) (args, pr_ctxt);
-		return DSP_SOK;
+	u32(*ioctl_cmd) (union Trapped_Args *args, void *pr_ctxt) = NULL;
+	u32 i;
+#ifdef BRIDGE_NEW_API
+	if (_IOC_TYPE(cmd) != DB) {
+		pr_err("%s: Incompatible dspbridge ioctl number\n", __func__);
+		goto err;
+	}
+	if (DB_GET_IOC_TABLE(cmd) > ARRAY_SIZE(size_cmd)) {
+#else
+	if (
+	    ((_IOC_TYPE(cmd) == DB) && (DB_GET_IOC_TABLE(cmd) > ARRAY_SIZE(size_cmd))) ||
+	    ((_IOC_TYPE(cmd) != DB) && (DB_GET_IOC_TABLE(cmd) >= ARRAY_SIZE(size_cmd)))
+	    ) {
+#endif
+	    pr_err("%s: undefined ioctl module\n", __func__);
+	    goto err;
+	}
+	/* Check the size of the required cmd table */
+	i = DB_GET_IOC(cmd);
+#ifdef BRIDGE_NEW_API
+	if (i > size_cmd[DB_GET_IOC_TABLE(cmd)]) {
+#else
+	if (
+	    ((_IOC_TYPE(cmd) == DB) && (i > size_cmd[DB_GET_IOC_TABLE(cmd)])) ||
+	    ((_IOC_TYPE(cmd) != DB) && (i >= size_cmd[DB_GET_IOC_TABLE(cmd)])) 
+	    ) {
+#endif
+		pr_err("%s: requested ioctl %08x out of bounds for table %d\n",
+		       __func__, i, DB_GET_IOC_TABLE(cmd));
+		goto err;
+	}
+#ifndef BRIDGE_NEW_API
+	/* Check for new API */
+	if(_IOC_TYPE(cmd) == DB) 
+		switch (DB_GET_MODULE(cmd)) {
+		case DB_MGR_NEW:
+			ioctl_cmd = mgr_cmd[i].fxn;
+			break;
+		case DB_PROC_NEW:
+			ioctl_cmd = proc_cmd[i].fxn;
+			break;
+		case DB_NODE_NEW:
+			ioctl_cmd = node_cmd[i].fxn;
+			break;
+		case DB_STRM_NEW:
+			ioctl_cmd = strm_cmd[i].fxn;
+			break;
+		case DB_CMM_NEW:
+			ioctl_cmd = cmm_cmd[i].fxn;
+			break;
+		}
+	else
+#endif
+		switch (DB_GET_MODULE(cmd)) {
+		case DB_MGR:
+			ioctl_cmd = mgr_cmd[i].fxn;
+			break;
+		case DB_PROC:
+			ioctl_cmd = proc_cmd[i].fxn;
+			break;
+		case DB_NODE:
+			ioctl_cmd = node_cmd[i].fxn;
+			break;
+		case DB_STRM:
+			ioctl_cmd = strm_cmd[i].fxn;
+			break;
+		case DB_CMM:
+			ioctl_cmd = cmm_cmd[i].fxn;
+			break;
+		}
+	if (!ioctl_cmd) {
+		pr_err("%s: requested ioctl %08x not defined\n", __func__,cmd);
+		goto err;
 	} else {
-		return DSP_EINVALIDARG;
+		*result = (*ioctl_cmd) (args, pr_ctxt);
 	}
+
+	return DSP_SOK;
+
+err:
+	return -EINVAL;
 }
 
 /*
- *  ======== WCD_Exit ========
+ *  ======== wcd_exit ========
  */
-void WCD_Exit(void)
+void wcd_exit(void)
 {
-	DBC_Require(WCD_cRefs > 0);
-	WCD_cRefs--;
-	GT_1trace(WCD_debugMask, GT_5CLASS,
-		 "Entered WCD_Exit, ref count:  0x%x\n", WCD_cRefs);
-	if (WCD_cRefs == 0) {
-		/* Release all WCD modules initialized in WCD_Init(). */
-		COD_Exit();
-		DEV_Exit();
-		CHNL_Exit();
-		MSG_Exit();
-		IO_Exit();
-		STRM_Exit();
-		NTFY_Exit();
-		DISP_Exit();
-		NODE_Exit();
-		PROC_Exit();
-		MGR_Exit();
-		RMM_exit();
-		DRV_Exit();
-		SERVICES_Exit();
+	DBC_REQUIRE(wcd_c_refs > 0);
+	wcd_c_refs--;
+
+	if (wcd_c_refs == 0) {
+		/* Release all WCD modules initialized in wcd_init(). */
+		cod_exit();
+		dev_exit();
+		chnl_exit();
+		msg_exit();
+		io_exit();
+		strm_exit();
+		disp_exit();
+		node_exit();
+		proc_exit();
+		mgr_exit();
+		rmm_exit();
+		drv_exit();
 	}
-	DBC_Ensure(WCD_cRefs >= 0);
+	DBC_ENSURE(wcd_c_refs >= 0);
 }
 
 /*
- *  ======== WCD_Init ========
+ *  ======== wcd_init ========
  *  Purpose:
  *      Module initialization is done by SERVICES Init.
  */
-bool WCD_Init(void)
+bool wcd_init(void)
 {
-	bool fInit = true;
-	bool fDRV, fDEV, fCOD, fSERVICES, fCHNL, fMSG, fIO;
-	bool fMGR, fPROC, fNODE, fDISP, fNTFY, fSTRM, fRMM;
-#ifdef DEBUG
-	/* runtime check of Device IOCtl array. */
-	u32 i;
-	for (i = 1; i < (sizeof(WCD_cmdTable) / sizeof(struct WCD_Cmd)); i++)
-		DBC_Assert(WCD_cmdTable[i - 1].dwIndex == i);
+	bool ret = true;
+	bool fdrv, fdev, fcod, fchnl, fmsg, fio;
+	bool fmgr, fproc, fnode, fdisp, fstrm, frmm;
 
-#endif
-	if (WCD_cRefs == 0) {
-		/* initialize all SERVICES modules */
-		fSERVICES = SERVICES_Init();
-		/* initialize debugging module */
-		DBC_Assert(!WCD_debugMask.flags);
-		GT_create(&WCD_debugMask, "CD");    /* CD for class driver */
+	if (wcd_c_refs == 0) {
 		/* initialize class driver and other modules */
-		fDRV = DRV_Init();
-		fMGR = MGR_Init();
-		fPROC = PROC_Init();
-		fNODE = NODE_Init();
-		fDISP = DISP_Init();
-		fNTFY = NTFY_Init();
-		fSTRM = STRM_Init();
-		fRMM = RMM_init();
-		fCHNL = CHNL_Init();
-		fMSG = MSG_Init();
-		fIO = IO_Init();
-		fDEV = DEV_Init();
-		fCOD = COD_Init();
-		fInit = fSERVICES && fDRV && fDEV && fCHNL && fCOD &&
-			fMSG && fIO;
-		fInit = fInit && fMGR && fPROC && fRMM;
-		if (!fInit) {
-			if (fSERVICES)
-				SERVICES_Exit();
-
-			if (fDRV)
-				DRV_Exit();
-
-			if (fMGR)
-				MGR_Exit();
-
-			if (fSTRM)
-				STRM_Exit();
-
-			if (fPROC)
-				PROC_Exit();
-
-			if (fNODE)
-				NODE_Exit();
-
-			if (fDISP)
-				DISP_Exit();
-
-			if (fNTFY)
-				NTFY_Exit();
-
-			if (fCHNL)
-				CHNL_Exit();
-
-			if (fMSG)
-				MSG_Exit();
-
-			if (fIO)
-				IO_Exit();
+		fdrv = drv_init();
+		fmgr = mgr_init();
+		fproc = proc_init();
+		fnode = node_init();
+		fdisp = disp_init();
+		fstrm = strm_init();
+		frmm = rmm_init();
+		fchnl = chnl_init();
+		fmsg = msg_mod_init();
+		fio = io_init();
+		fdev = dev_init();
+		fcod = cod_init();
+		ret = fdrv && fdev && fchnl && fcod && fmsg && fio;
+		ret = ret && fmgr && fproc && frmm;
+		if (!ret) {
+			if (fdrv)
+				drv_exit();
+
+			if (fmgr)
+				mgr_exit();
+
+			if (fstrm)
+				strm_exit();
+
+			if (fproc)
+				proc_exit();
+
+			if (fnode)
+				node_exit();
+
+			if (fdisp)
+				disp_exit();
+
+			if (fchnl)
+				chnl_exit();
+
+			if (fmsg)
+				msg_exit();
+
+			if (fio)
+				io_exit();
 
-			if (fDEV)
-				DEV_Exit();
+			if (fdev)
+				dev_exit();
 
-			if (fCOD)
-				COD_Exit();
+			if (fcod)
+				cod_exit();
 
-			if (fRMM)
-				RMM_exit();
+			if (frmm)
+				rmm_exit();
 
 		}
 	}
-	if (fInit)
-		WCD_cRefs++;
+	if (ret)
+		wcd_c_refs++;
 
-	GT_1trace(WCD_debugMask, GT_5CLASS,
-		 "Entered WCD_Init, ref count: 0x%x\n",	WCD_cRefs);
-	return fInit;
+	return ret;
 }
 
 /*
- *  ======== WCD_InitComplete2 ========
+ *  ======== wcd_init_complete2 ========
  *  Purpose:
  *      Perform any required WCD, and WMD initialization which
- *      cannot not be performed in WCD_Init() or DEV_StartDevice() due
+ *      cannot not be performed in wcd_init() or dev_start_device() due
  *      to the fact that some services are not yet
  *      completely initialized.
  *  Parameters:
@@ -420,497 +467,439 @@
  *      WCD initialized.
  *  Ensures:
  */
-DSP_STATUS WCD_InitComplete2(void)
+dsp_status wcd_init_complete2(void)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CFG_DEVNODE *DevNode;
-	struct DEV_OBJECT *hDevObject;
-	u32 devType;
-
-	DBC_Require(WCD_cRefs > 0);
-	GT_0trace(WCD_debugMask, GT_ENTER, "Entered WCD_InitComplete\n");
-	 /*  Walk the list of DevObjects, get each devnode, and attempting to
+	dsp_status status = DSP_SOK;
+	struct cfg_devnode *dev_node;
+	struct dev_object *hdev_obj;
+	u32 dev_type, tmp;
+
+	DBC_REQUIRE(wcd_c_refs > 0);
+
+	/*  Walk the list of DevObjects, get each devnode, and attempting to
 	 *  autostart the board. Note that this requires COF loading, which
-	 *  requires KFILE.  */
-	for (hDevObject = DEV_GetFirst(); hDevObject != NULL;
-	     hDevObject = DEV_GetNext(hDevObject)) {
-		if (DSP_FAILED(DEV_GetDevNode(hDevObject, &DevNode)))
+	 *  requires KFILE. */
+	for (hdev_obj = dev_get_first(); hdev_obj != NULL;
+	     hdev_obj = dev_get_next(hdev_obj)) {
+		if (DSP_FAILED(dev_get_dev_node(hdev_obj, &dev_node)))
 			continue;
 
-		if (DSP_FAILED(DEV_GetDevType(hDevObject, &devType)))
+		if (DSP_FAILED(dev_get_dev_type(hdev_obj, &dev_type)))
 			continue;
 
-		if ((devType == DSP_UNIT) || (devType == IVA_UNIT)) {
-			if (DSP_FAILED(PROC_AutoStart(DevNode, hDevObject))) {
-				GT_0trace(WCD_debugMask, GT_1CLASS,
-					 "WCD_InitComplete2 Failed\n");
-				status = DSP_EFAIL;
-				/* break; */
-			}
-		} else
-			GT_1trace(WCD_debugMask, GT_ENTER,
-				 "Ignoring PROC_AutoStart "
-				 "for Device Type = 0x%x \n", devType);
-	}			/* End For Loop */
-	GT_1trace(WCD_debugMask, GT_ENTER,
-		 "Exiting WCD_InitComplete status 0x%x\n", status);
+		if ((dev_type == DSP_UNIT) || (dev_type == IVA_UNIT))
+			if (cfg_get_auto_start(dev_node, &tmp) == DSP_SOK
+									&& tmp)
+				proc_auto_start(dev_node, hdev_obj);
+	}
+
 	return status;
 }
 
+/* TODO: Remove deprecated and not implemented ioctl wrappers */
+
 /*
- * ======== MGRWRAP_EnumNode_Info ========
- */
-u32 MGRWRAP_EnumNode_Info(union Trapped_Args *args, void *pr_ctxt)
-{
-	u8 *pNDBProps;
-	u32 uNumNodes;
-	DSP_STATUS status = DSP_SOK;
-	u32 size = args->ARGS_MGR_ENUMNODE_INFO.uNDBPropsSize;
-
-	GT_4trace(WCD_debugMask, GT_ENTER,
-		 "MGR_EnumNodeInfo: entered args:\n0x%x"
-		 " uNode: 0x%x\tpNDBProps: 0x%x\tuNDBPropsSize: "
-		 "0x%x\tpuNumNodes\n", args->ARGS_MGR_ENUMNODE_INFO.uNode,
-		 args->ARGS_MGR_ENUMNODE_INFO.pNDBProps,
-		 args->ARGS_MGR_ENUMNODE_INFO.uNDBPropsSize,
-		 args->ARGS_MGR_ENUMNODE_INFO.puNumNodes);
-	pNDBProps = MEM_Alloc(size, MEM_NONPAGED);
-	if (pNDBProps == NULL)
+ * ======== mgrwrap_enum_node_info ========
+ */
+u32 mgrwrap_enum_node_info(union Trapped_Args *args, void *pr_ctxt)
+{
+	u8 *pndb_props;
+	u32 num_nodes;
+	dsp_status status = DSP_SOK;
+	u32 size = args->args_mgr_enumnode_info.undb_props_size;
+
+	if (size < sizeof(struct dsp_ndbprops))
+		return DSP_ESIZE;
+
+	pndb_props = mem_alloc(size, MEM_NONPAGED);
+	if (pndb_props == NULL)
 		status = DSP_EMEMORY;
 
 	if (DSP_SUCCEEDED(status)) {
-		status = MGR_EnumNodeInfo(args->ARGS_MGR_ENUMNODE_INFO.uNode,
-					 (struct DSP_NDBPROPS *)pNDBProps,
-					 size, &uNumNodes);
+		status =
+		    mgr_enum_node_info(args->args_mgr_enumnode_info.node_id,
+				       (struct dsp_ndbprops *)pndb_props, size,
+				       &num_nodes);
 	}
-	cp_to_usr(args->ARGS_MGR_ENUMNODE_INFO.pNDBProps, pNDBProps, status,
-		 size);
-	cp_to_usr(args->ARGS_MGR_ENUMNODE_INFO.puNumNodes, &uNumNodes, status,
-		 1);
-	if (pNDBProps)
-		MEM_Free(pNDBProps);
+	CP_TO_USR(args->args_mgr_enumnode_info.pndb_props, pndb_props, status,
+		  size);
+	CP_TO_USR(args->args_mgr_enumnode_info.pu_num_nodes, &num_nodes, status,
+		  1);
+	kfree(pndb_props);
 
 	return status;
 }
 
 /*
- * ======== MGRWRAP_EnumProc_Info ========
+ * ======== mgrwrap_enum_proc_info ========
  */
-u32 MGRWRAP_EnumProc_Info(union Trapped_Args *args, void *pr_ctxt)
+u32 mgrwrap_enum_proc_info(union Trapped_Args *args, void *pr_ctxt)
 {
-	u8 *pProcessorInfo;
-	u32 uNumProcs;
-	DSP_STATUS status = DSP_SOK;
-	u32 size = args->ARGS_MGR_ENUMPROC_INFO.uProcessorInfoSize;
+	u8 *processor_info;
+	u32 num_procs;
+	dsp_status status = DSP_SOK;
+	u32 size = args->args_mgr_enumproc_info.processor_info_size;
+
+	if (size < sizeof(struct dsp_processorinfo))
+		return DSP_ESIZE;
 
-	GT_4trace(WCD_debugMask, GT_ENTER,
-		 "MGRWRAP_EnumProc_Info: entered args:\n"
-		 "0x%x uProcessor: 0x%x\tpProcessorInfo: 0x%x\t"
-		 "uProcessorInfoSize: 0x%x\tpuNumProcs \n",
-		 args->ARGS_MGR_ENUMPROC_INFO.uProcessor,
-		 args->ARGS_MGR_ENUMPROC_INFO.pProcessorInfo,
-		 args->ARGS_MGR_ENUMPROC_INFO.uProcessorInfoSize,
-		 args->ARGS_MGR_ENUMPROC_INFO.puNumProcs);
-	pProcessorInfo = MEM_Alloc(size, MEM_NONPAGED);
-	if (pProcessorInfo == NULL)
+	processor_info = mem_alloc(size, MEM_NONPAGED);
+	if (processor_info == NULL)
 		status = DSP_EMEMORY;
 
 	if (DSP_SUCCEEDED(status)) {
-		status = MGR_EnumProcessorInfo(args->
-				ARGS_MGR_ENUMPROC_INFO.uProcessor,
-				(struct DSP_PROCESSORINFO *)pProcessorInfo,
-				size, &uNumProcs);
-	}
-	cp_to_usr(args->ARGS_MGR_ENUMPROC_INFO.pProcessorInfo, pProcessorInfo,
-		 status, size);
-	cp_to_usr(args->ARGS_MGR_ENUMPROC_INFO.puNumProcs, &uNumProcs,
-		 status, 1);
-	if (pProcessorInfo)
-		MEM_Free(pProcessorInfo);
+		status =
+		    mgr_enum_processor_info(args->args_mgr_enumproc_info.
+					    processor_id,
+					    (struct dsp_processorinfo *)
+					    processor_info, size, &num_procs);
+	}
+	CP_TO_USR(args->args_mgr_enumproc_info.processor_info, processor_info,
+		  status, size);
+	CP_TO_USR(args->args_mgr_enumproc_info.pu_num_procs, &num_procs,
+		  status, 1);
+	kfree(processor_info);
 
 	return status;
 }
 
 #define WRAP_MAP2CALLER(x) x
 /*
- * ======== MGRWRAP_RegisterObject ========
+ * ======== mgrwrap_register_object ========
  */
-u32 MGRWRAP_RegisterObject(union Trapped_Args *args, void *pr_ctxt)
+u32 mgrwrap_register_object(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
-	struct DSP_UUID pUuid;
-	u32 pathSize = 0;
-	char *pszPathName = NULL;
-	DSP_STATUS status = DSP_SOK;
+	u32 ret;
+	struct dsp_uuid uuid_obj;
+	u32 path_size = 0;
+	char *psz_path_name = NULL;
+	dsp_status status = DSP_SOK;
 
-	cp_fm_usr(&pUuid, args->ARGS_MGR_REGISTEROBJECT.pUuid, status, 1);
+	CP_FM_USR(&uuid_obj, args->args_mgr_registerobject.uuid_obj, status, 1);
 	if (DSP_FAILED(status))
 		goto func_end;
-	/* pathSize is increased by 1 to accommodate NULL */
-	pathSize = strlen_user((char *)
-			args->ARGS_MGR_REGISTEROBJECT.pszPathName) + 1;
-	pszPathName = MEM_Alloc(pathSize, MEM_NONPAGED);
-	if (!pszPathName)
+	/* path_size is increased by 1 to accommodate NULL */
+	path_size = strlen_user((char *)
+				args->args_mgr_registerobject.psz_path_name) +
+	    1;
+	psz_path_name = mem_alloc(path_size, MEM_NONPAGED);
+	if (!psz_path_name)
 		goto func_end;
-	retVal = strncpy_from_user(pszPathName,
-			(char *)args->ARGS_MGR_REGISTEROBJECT.pszPathName,
-			pathSize);
-	if (!retVal) {
+	ret = strncpy_from_user(psz_path_name,
+				(char *)args->args_mgr_registerobject.
+				psz_path_name, path_size);
+	if (!ret) {
 		status = DSP_EPOINTER;
 		goto func_end;
 	}
 
-	GT_1trace(WCD_debugMask, GT_ENTER,
-		 "MGRWRAP_RegisterObject: entered pg2hMsg "
-		 "0x%x\n", args->ARGS_MGR_REGISTEROBJECT.pUuid);
-	status = DCD_RegisterObject(&pUuid,
-				args->ARGS_MGR_REGISTEROBJECT.objType,
-				(char *)pszPathName);
+	if (args->args_mgr_registerobject.obj_type >= DSP_DCDMAXOBJTYPE)
+		return DSP_EINVALIDARG;
+
+	status = dcd_register_object(&uuid_obj,
+				     args->args_mgr_registerobject.obj_type,
+				     (char *)psz_path_name);
 func_end:
-	if (pszPathName)
-		MEM_Free(pszPathName);
+	kfree(psz_path_name);
 	return status;
 }
 
 /*
- * ======== MGRWRAP_UnregisterObject ========
+ * ======== mgrwrap_unregister_object ========
  */
-u32 MGRWRAP_UnregisterObject(union Trapped_Args *args, void *pr_ctxt)
+u32 mgrwrap_unregister_object(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_UUID pUuid;
+	dsp_status status = DSP_SOK;
+	struct dsp_uuid uuid_obj;
 
-	cp_fm_usr(&pUuid, args->ARGS_MGR_REGISTEROBJECT.pUuid, status, 1);
+	CP_FM_USR(&uuid_obj, args->args_mgr_registerobject.uuid_obj, status, 1);
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	GT_1trace(WCD_debugMask, GT_ENTER,
-		 "MGRWRAP_UnregisterObject: entered pg2hMsg"
-		 " 0x%x\n", args->ARGS_MGR_UNREGISTEROBJECT.pUuid);
-	status = DCD_UnregisterObject(&pUuid,
-			args->ARGS_MGR_UNREGISTEROBJECT.objType);
+	status = dcd_unregister_object(&uuid_obj,
+				       args->args_mgr_unregisterobject.
+				       obj_type);
 func_end:
 	return status;
 
 }
 
 /*
- * ======== MGRWRAP_WaitForBridgeEvents ========
+ * ======== mgrwrap_wait_for_bridge_events ========
  */
-u32 MGRWRAP_WaitForBridgeEvents(union Trapped_Args *args, void *pr_ctxt)
+u32 mgrwrap_wait_for_bridge_events(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK, real_status = DSP_SOK;
-	struct DSP_NOTIFICATION *aNotifications[MAX_EVENTS];
-	struct DSP_NOTIFICATION notifications[MAX_EVENTS];
-	u32 uIndex, i;
-	u32 uCount = args->ARGS_MGR_WAIT.uCount;
+	dsp_status status = DSP_SOK;
+	struct dsp_notification *anotifications[MAX_EVENTS];
+	struct dsp_notification notifications[MAX_EVENTS];
+	u32 index, i;
+	u32 count = args->args_mgr_wait.count;
 
-	GT_0trace(WCD_debugMask, GT_ENTER,
-		 "MGRWRAP_WaitForBridgeEvents: entered\n");
-
-	if (uCount > MAX_EVENTS)
+	if (count > MAX_EVENTS)
 		status = DSP_EINVALIDARG;
 
 	/* get the array of pointers to user structures */
-	cp_fm_usr(aNotifications, args->ARGS_MGR_WAIT.aNotifications,
-	 status, uCount);
+	CP_FM_USR(anotifications, args->args_mgr_wait.anotifications,
+		  status, count);
 	/* get the events */
-	for (i = 0; i < uCount; i++) {
-		cp_fm_usr(&notifications[i], aNotifications[i], status, 1);
-		if (DSP_SUCCEEDED(status)) {
-			/* set the array of pointers to kernel structures*/
-			aNotifications[i] = &notifications[i];
+	for (i = 0; i < count; i++) {
+		CP_FM_USR(&notifications[i], anotifications[i], status, 1);
+		if (DSP_FAILED(status) || !notifications[i].handle) {
+			status = DSP_EINVALIDARG;
+			break;
 		}
+		/* set the array of pointers to kernel structures */
+		anotifications[i] = &notifications[i];
 	}
 	if (DSP_SUCCEEDED(status)) {
-		real_status = MGR_WaitForBridgeEvents(aNotifications, uCount,
-			 &uIndex, args->ARGS_MGR_WAIT.uTimeout);
+		status = mgr_wait_for_bridge_events(anotifications, count,
+							 &index,
+							 args->args_mgr_wait.
+							 utimeout);
 	}
-	cp_to_usr(args->ARGS_MGR_WAIT.puIndex, &uIndex, status, 1);
-	return real_status;
+	CP_TO_USR(args->args_mgr_wait.pu_index, &index, status, 1);
+	return status;
 }
 
-
-#ifndef RES_CLEANUP_DISABLE
 /*
  * ======== MGRWRAP_GetProcessResourceInfo ========
  */
-u32 MGRWRAP_GetProcessResourcesInfo(union Trapped_Args *args, void *pr_ctxt)
+u32 __deprecated mgrwrap_get_process_resources_info(union Trapped_Args * args,
+						    void *pr_ctxt)
 {
-    DSP_STATUS status = DSP_SOK;
-    u32 uSize = 0;
-    u8 *pBuf = MEM_Alloc(8092, MEM_NONPAGED);
-    status = DRV_ProcDisplayResInfo(pBuf, &uSize);
-    GT_1trace(WCD_debugMask, GT_ENTER,
-	     "MGRWRAP_GetProcessResourcesInfo:uSize=%d :\n", uSize);
-    cp_to_usr(args->ARGS_PROC_GETTRACE.pBuf, pBuf, status, uSize);
-    GT_0trace(WCD_debugMask, GT_ENTER, "\n***********"
-	     "123MGRWRAP_GetProcessResourcesInfo:**************\n");
-    GT_0trace(WCD_debugMask, GT_ENTER, "\n***********"
-	     "456MGRWRAP_GetProcessResourcesInfo:**************\n");
-    cp_to_usr(args->ARGS_PROC_GETTRACE.pSize, &uSize, status, 1);
-    MEM_Free(pBuf);
-    return status;
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
+	return DSP_SOK;
 }
-#endif
-
 
 /*
- * ======== PROCWRAP_Attach ========
+ * ======== procwrap_attach ========
  */
-u32 PROCWRAP_Attach(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_attach(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_HPROCESSOR processor;
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_PROCESSORATTRIN attrIn, *pAttrIn = NULL;
-
-	GT_3trace(WCD_debugMask, GT_ENTER,
-		 "PROCWRAP_Attach: entered args:\n" "0x%x"
-		 " uProcessor: 0x%x\tpAttrIn: 0x%x\tphProcessor \n",
-		 args->ARGS_PROC_ATTACH.uProcessor,
-		 args->ARGS_PROC_ATTACH.pAttrIn,
-		 args->ARGS_PROC_ATTACH.phProcessor);
+	void *processor;
+	dsp_status status = DSP_SOK;
+	struct dsp_processorattrin proc_attr_in, *attr_in = NULL;
+
 	/* Optional argument */
-	if (args->ARGS_PROC_ATTACH.pAttrIn) {
-		cp_fm_usr(&attrIn, args->ARGS_PROC_ATTACH.pAttrIn, status, 1);
+	if (args->args_proc_attach.attr_in) {
+		CP_FM_USR(&proc_attr_in, args->args_proc_attach.attr_in, status,
+			  1);
 		if (DSP_SUCCEEDED(status))
-			pAttrIn = &attrIn;
+			attr_in = &proc_attr_in;
 		else
 			goto func_end;
 
-
 	}
-	status = PROC_Attach(args->ARGS_PROC_ATTACH.uProcessor, pAttrIn,
-			    &processor, pr_ctxt);
-	cp_to_usr(args->ARGS_PROC_ATTACH.phProcessor, &processor, status, 1);
+	status = proc_attach(args->args_proc_attach.processor_id, attr_in,
+			     &processor, pr_ctxt);
+	CP_TO_USR(args->args_proc_attach.ph_processor, &processor, status, 1);
 func_end:
 	return status;
 }
 
 /*
- * ======== PROCWRAP_Ctrl ========
+ * ======== procwrap_ctrl ========
  */
-u32 PROCWRAP_Ctrl(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_ctrl(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 cbDataSize, __user *pSize = (u32 __user *)
-			args->ARGS_PROC_CTRL.pArgs;
-	u8 *pArgs = NULL;
-	DSP_STATUS status = DSP_SOK;
-
-	GT_3trace(WCD_debugMask, GT_ENTER,
-		 "PROCWRAP_Ctrl: entered args:\n 0x%x"
-		 " uProcessor: 0x%x\tdwCmd: 0x%x\tpArgs \n",
-		 args->ARGS_PROC_CTRL.hProcessor,
-		 args->ARGS_PROC_CTRL.dwCmd,
-		 args->ARGS_PROC_CTRL.pArgs);
-	if (pSize) {
-		if (get_user(cbDataSize, pSize)) {
+	u32 cb_data_size, __user * psize = (u32 __user *)
+	    args->args_proc_ctrl.pargs;
+	u8 *pargs = NULL;
+	dsp_status status = DSP_SOK;
+
+	if (psize) {
+		if (get_user(cb_data_size, psize)) {
 			status = DSP_EFAIL;
 			goto func_end;
 		}
-		cbDataSize += sizeof(u32);
-		pArgs = MEM_Alloc(cbDataSize, MEM_NONPAGED);
-		if (pArgs == NULL) {
+		cb_data_size += sizeof(u32);
+		pargs = mem_alloc(cb_data_size, MEM_NONPAGED);
+		if (pargs == NULL) {
 			status = DSP_EMEMORY;
 			goto func_end;
 		}
 
-		cp_fm_usr(pArgs, args->ARGS_PROC_CTRL.pArgs, status,
-			 cbDataSize);
+		CP_FM_USR(pargs, args->args_proc_ctrl.pargs, status,
+			  cb_data_size);
 	}
 	if (DSP_SUCCEEDED(status)) {
-		status = PROC_Ctrl(args->ARGS_PROC_CTRL.hProcessor,
-				  args->ARGS_PROC_CTRL.dwCmd,
-				  (struct DSP_CBDATA *)pArgs);
+		status = proc_ctrl(args->args_proc_ctrl.hprocessor,
+				   args->args_proc_ctrl.dw_cmd,
+				   (struct dsp_cbdata *)pargs);
 	}
 
-	/* cp_to_usr(args->ARGS_PROC_CTRL.pArgs, pArgs, status, 1);*/
-	if (pArgs)
-		MEM_Free(pArgs);
+	/* CP_TO_USR(args->args_proc_ctrl.pargs, pargs, status, 1); */
+	kfree(pargs);
 func_end:
 	return status;
 }
 
 /*
- * ======== PROCWRAP_Detach ========
+ * ======== procwrap_detach ========
  */
-u32 PROCWRAP_Detach(union Trapped_Args *args, void *pr_ctxt)
+u32 __deprecated procwrap_detach(union Trapped_Args * args, void *pr_ctxt)
 {
-	u32 retVal;
-
-	GT_1trace(WCD_debugMask, GT_ENTER,
-		 "PROCWRAP_Detach: entered args\n0x%x "
-		 "hProceesor \n", args->ARGS_PROC_DETACH.hProcessor);
-	retVal = PROC_Detach(args->ARGS_PROC_DETACH.hProcessor, pr_ctxt);
-
-	return retVal;
+	/* proc_detach called at bridge_release only */
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
+	return DSP_SOK;
 }
 
 /*
- * ======== PROCWRAP_EnumNode_Info ========
+ * ======== procwrap_enum_node_info ========
  */
-u32 PROCWRAP_EnumNode_Info(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_enum_node_info(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	DSP_HNODE aNodeTab[MAX_NODES];
-	u32 uNumNodes;
-	u32 uAllocated;
+	dsp_status status;
+	void *node_tab[MAX_NODES];
+	u32 num_nodes;
+	u32 alloc_cnt;
+
+	if (!args->args_proc_enumnode_info.node_tab_size)
+		return DSP_ESIZE;
 
-	GT_5trace(WCD_debugMask, GT_ENTER,
-		 "PROCWRAP_EnumNode_Info:entered args:\n0x"
-		 "%xhProcessor:0x%x\taNodeTab:0x%x\tuNodeTabSize:"
-		 "%0x%x\tpuNumNodes%\n0x%x puAllocated: \n",
-		 args->ARGS_PROC_ENUMNODE_INFO.hProcessor,
-		 args->ARGS_PROC_ENUMNODE_INFO.aNodeTab,
-		 args->ARGS_PROC_ENUMNODE_INFO.uNodeTabSize,
-		 args->ARGS_PROC_ENUMNODE_INFO.puNumNodes,
-		 args->ARGS_PROC_ENUMNODE_INFO.puAllocated);
-	DBC_Require(args->ARGS_PROC_ENUMNODE_INFO.uNodeTabSize <= MAX_NODES);
-	status = PROC_EnumNodes(args->ARGS_PROC_ENUMNODE_INFO.hProcessor,
-				aNodeTab,
-				args->ARGS_PROC_ENUMNODE_INFO.uNodeTabSize,
-				&uNumNodes, &uAllocated);
-	cp_to_usr(args->ARGS_PROC_ENUMNODE_INFO.aNodeTab, aNodeTab, status,
-		 uNumNodes);
-	cp_to_usr(args->ARGS_PROC_ENUMNODE_INFO.puNumNodes, &uNumNodes,
-		 status, 1);
-	cp_to_usr(args->ARGS_PROC_ENUMNODE_INFO.puAllocated, &uAllocated,
-		 status, 1);
+	status = proc_enum_nodes(args->args_proc_enumnode_info.hprocessor,
+				 node_tab,
+				 args->args_proc_enumnode_info.node_tab_size,
+				 &num_nodes, &alloc_cnt);
+	CP_TO_USR(args->args_proc_enumnode_info.node_tab, node_tab, status,
+		  num_nodes);
+	CP_TO_USR(args->args_proc_enumnode_info.pu_num_nodes, &num_nodes,
+		  status, 1);
+	CP_TO_USR(args->args_proc_enumnode_info.pu_allocated, &alloc_cnt,
+		  status, 1);
 	return status;
 }
 
 /*
- * ======== PROCWRAP_FlushMemory ========
+ * ======== procwrap_flush_memory ========
  */
-u32 PROCWRAP_FlushMemory(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_flush_memory(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
+	dsp_status status;
 
-	GT_0trace(WCD_debugMask, GT_ENTER, "PROCWRAP_FlushMemory: entered\n");
+	if (args->args_proc_flushmemory.ul_flags >
+	    PROC_WRITEBACK_INVALIDATE_MEM)
+		return DSP_EINVALIDARG;
 
-	status = PROC_FlushMemory(args->ARGS_PROC_FLUSHMEMORY.hProcessor,
-				 args->ARGS_PROC_FLUSHMEMORY.pMpuAddr,
-				 args->ARGS_PROC_FLUSHMEMORY.ulSize,
-				 args->ARGS_PROC_FLUSHMEMORY.ulFlags);
+	status = proc_flush_memory(args->args_proc_flushmemory.hprocessor,
+				   args->args_proc_flushmemory.pmpu_addr,
+				   args->args_proc_flushmemory.ul_size,
+				   args->args_proc_flushmemory.ul_flags);
 	return status;
 }
 
-
 /*
- * ======== PROCWRAP_InvalidateMemory ========
+ * ======== procwrap_invalidate_memory ========
  */
-u32 PROCWRAP_InvalidateMemory(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_invalidate_memory(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
+	dsp_status status;
 
-	GT_0trace(WCD_debugMask, GT_ENTER,
-		 "PROCWRAP_InvalidateMemory:entered\n");
-
-	status = PROC_InvalidateMemory(
-				  args->ARGS_PROC_INVALIDATEMEMORY.hProcessor,
-				  args->ARGS_PROC_INVALIDATEMEMORY.pMpuAddr,
-				  args->ARGS_PROC_INVALIDATEMEMORY.ulSize);
+	status =
+	    proc_invalidate_memory(args->args_proc_invalidatememory.hprocessor,
+				   args->args_proc_invalidatememory.pmpu_addr,
+				   args->args_proc_invalidatememory.ul_size);
 	return status;
 }
 
-
 /*
- * ======== PROCWRAP_EnumResources ========
+ * ======== procwrap_enum_resources ========
  */
-u32 PROCWRAP_EnumResources(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_enum_resources(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_RESOURCEINFO pResourceInfo;
+	dsp_status status = DSP_SOK;
+	struct dsp_resourceinfo resource_info;
 
-	if (DSP_FAILED(status))
-		goto func_end;
+	if (args->args_proc_enumresources.resource_info_size <
+	    sizeof(struct dsp_resourceinfo))
+		return DSP_ESIZE;
+
+	status =
+	    proc_get_resource_info(args->args_proc_enumresources.hprocessor,
+				   args->args_proc_enumresources.resource_type,
+				   &resource_info,
+				   args->args_proc_enumresources.
+				   resource_info_size);
+
+	CP_TO_USR(args->args_proc_enumresources.resource_info, &resource_info,
+		  status, 1);
 
-	GT_4trace(WCD_debugMask, GT_ENTER,
-		 "PROCWRAP_EnumResources: entered args:\n"
-		 "0x%x hProcessor: 0x%x\tuResourceMask: 0x%x\tpResourceInfo"
-		 " 0x%x\tuResourceInfoSixe \n",
-		 args->ARGS_PROC_ENUMRESOURCES.hProcessor,
-		 args->ARGS_PROC_ENUMRESOURCES.uResourceType,
-		 args->ARGS_PROC_ENUMRESOURCES.pResourceInfo,
-		 args->ARGS_PROC_ENUMRESOURCES.uResourceInfoSize);
-	status = PROC_GetResourceInfo(args->ARGS_PROC_ENUMRESOURCES.hProcessor,
-			args->ARGS_PROC_ENUMRESOURCES.uResourceType,
-			&pResourceInfo,
-			args->ARGS_PROC_ENUMRESOURCES.uResourceInfoSize);
-	if (DSP_FAILED(status))
-		goto func_end;
-	cp_to_usr(args->ARGS_PROC_ENUMRESOURCES.pResourceInfo, &pResourceInfo,
-						status, 1);
-func_end:
 	return status;
 
 }
 
 /*
- * ======== PROCWRAP_GetState ========
+ * ======== procwrap_get_state ========
  */
-u32 PROCWRAP_GetState(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_get_state(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	struct DSP_PROCESSORSTATE procStatus;
-	GT_0trace(WCD_debugMask, GT_ENTER, "PROCWRAP_GetState: entered\n");
-	status = PROC_GetState(args->ARGS_PROC_GETSTATE.hProcessor, &procStatus,
-			      args->ARGS_PROC_GETSTATE.uStateInfoSize);
-	cp_to_usr(args->ARGS_PROC_GETSTATE.pProcStatus, &procStatus, status, 1);
+	dsp_status status;
+	struct dsp_processorstate proc_state;
+
+	if (args->args_proc_getstate.state_info_size <
+	    sizeof(struct dsp_processorstate))
+		return DSP_ESIZE;
+
+	status =
+	    proc_get_state(args->args_proc_getstate.hprocessor, &proc_state,
+			   args->args_proc_getstate.state_info_size);
+	CP_TO_USR(args->args_proc_getstate.proc_state_obj, &proc_state, status,
+		  1);
 	return status;
 
 }
 
 /*
- * ======== PROCWRAP_GetTrace ========
+ * ======== procwrap_get_trace ========
  */
-u32 PROCWRAP_GetTrace(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_get_trace(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	u8 *pBuf;
+	dsp_status status;
+	u8 *pbuf;
 
-	GT_0trace(WCD_debugMask, GT_ENTER, "PROCWRAP_GetTrace: entered\n");
+	if (args->args_proc_gettrace.max_size > MAX_TRACEBUFLEN)
+		return DSP_ESIZE;
 
-	DBC_Require(args->ARGS_PROC_GETTRACE.uMaxSize <= MAX_TRACEBUFLEN);
-
-	pBuf = MEM_Calloc(args->ARGS_PROC_GETTRACE.uMaxSize, MEM_NONPAGED);
-	if (pBuf != NULL) {
-		status = PROC_GetTrace(args->ARGS_PROC_GETTRACE.hProcessor,
-				      pBuf, args->ARGS_PROC_GETTRACE.uMaxSize);
+	pbuf = mem_calloc(args->args_proc_gettrace.max_size, MEM_NONPAGED);
+	if (pbuf != NULL) {
+		status = proc_get_trace(args->args_proc_gettrace.hprocessor,
+					pbuf,
+					args->args_proc_gettrace.max_size);
 	} else {
 		status = DSP_EMEMORY;
 	}
-	cp_to_usr(args->ARGS_PROC_GETTRACE.pBuf, pBuf, status,
-		 args->ARGS_PROC_GETTRACE.uMaxSize);
-	if (pBuf)
-		MEM_Free(pBuf);
+	CP_TO_USR(args->args_proc_gettrace.pbuf, pbuf, status,
+		  args->args_proc_gettrace.max_size);
+	kfree(pbuf);
 
 	return status;
 }
 
 /*
- * ======== PROCWRAP_Load ========
+ * ======== procwrap_load ========
  */
-u32 PROCWRAP_Load(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_load(union Trapped_Args *args, void *pr_ctxt)
 {
 	s32 i, len;
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 	char *temp;
-	s32 count = args->ARGS_PROC_LOAD.iArgc;
-	u8 **argv, **envp = NULL;
+	s32 count = args->args_proc_load.argc_index;
+	u8 **argv = NULL, **envp = NULL;
 
-	DBC_Require(count > 0);
-	DBC_Require(count <= MAX_LOADARGS);
+	if (count <= 0 || count > MAX_LOADARGS) {
+		status = DSP_EINVALIDARG;
+		goto func_cont;
+	}
 
-	argv = MEM_Alloc(count * sizeof(u8 *), MEM_NONPAGED);
+	argv = mem_alloc(count * sizeof(u8 *), MEM_NONPAGED);
 	if (!argv) {
 		status = DSP_EMEMORY;
 		goto func_cont;
 	}
 
-	cp_fm_usr(argv, args->ARGS_PROC_LOAD.aArgv, status, count);
+	CP_FM_USR(argv, args->args_proc_load.user_args, status, count);
 	if (DSP_FAILED(status)) {
-		MEM_Free(argv);
+		kfree(argv);
 		argv = NULL;
 		goto func_cont;
 	}
@@ -918,15 +907,15 @@
 	for (i = 0; i < count; i++) {
 		if (argv[i]) {
 			/* User space pointer to argument */
-			temp = (char *) argv[i];
+			temp = (char *)argv[i];
 			/* len is increased by 1 to accommodate NULL */
 			len = strlen_user((char *)temp) + 1;
 			/* Kernel space pointer to argument */
-			argv[i] = MEM_Alloc(len, MEM_NONPAGED);
+			argv[i] = mem_alloc(len, MEM_NONPAGED);
 			if (argv[i]) {
-				cp_fm_usr(argv[i], temp, status, len);
+				CP_FM_USR(argv[i], temp, status, len);
 				if (DSP_FAILED(status)) {
-					MEM_Free(argv[i]);
+					kfree(argv[i]);
 					argv[i] = NULL;
 					goto func_cont;
 				}
@@ -937,22 +926,22 @@
 		}
 	}
 	/* TODO: validate this */
-	if (args->ARGS_PROC_LOAD.aEnvp) {
+	if (args->args_proc_load.user_envp) {
 		/* number of elements in the envp array including NULL */
 		count = 0;
 		do {
-			get_user(temp, args->ARGS_PROC_LOAD.aEnvp + count);
+			get_user(temp, args->args_proc_load.user_envp + count);
 			count++;
 		} while (temp);
-		envp = MEM_Alloc(count * sizeof(u8 *), MEM_NONPAGED);
+		envp = mem_alloc(count * sizeof(u8 *), MEM_NONPAGED);
 		if (!envp) {
 			status = DSP_EMEMORY;
 			goto func_cont;
 		}
 
-		cp_fm_usr(envp, args->ARGS_PROC_LOAD.aEnvp, status, count);
+		CP_FM_USR(envp, args->args_proc_load.user_envp, status, count);
 		if (DSP_FAILED(status)) {
-			MEM_Free(envp);
+			kfree(envp);
 			envp = NULL;
 			goto func_cont;
 		}
@@ -962,11 +951,11 @@
 			/* len is increased by 1 to accommodate NULL */
 			len = strlen_user((char *)temp) + 1;
 			/* Kernel space pointer to argument */
-			envp[i] = MEM_Alloc(len, MEM_NONPAGED);
+			envp[i] = mem_alloc(len, MEM_NONPAGED);
 			if (envp[i]) {
-				cp_fm_usr(envp[i], temp, status, len);
+				CP_FM_USR(envp[i], temp, status, len);
 				if (DSP_FAILED(status)) {
-					MEM_Free(envp[i]);
+					kfree(envp[i]);
 					envp[i] = NULL;
 					goto func_cont;
 				}
@@ -976,772 +965,785 @@
 			}
 		}
 	}
-	GT_5trace(WCD_debugMask, GT_ENTER,
-		"PROCWRAP_Load, hProcessor: 0x%x\n\tiArgc:"
-		"0x%x\n\taArgv: 0x%x\n\taArgv[0]: %s\n\taEnvp: 0x%0x\n",
-		args->ARGS_PROC_LOAD.hProcessor,
-		args->ARGS_PROC_LOAD.iArgc, args->ARGS_PROC_LOAD.aArgv,
-		argv[0], args->ARGS_PROC_LOAD.aEnvp);
+
 	if (DSP_SUCCEEDED(status)) {
-		status = PROC_Load(args->ARGS_PROC_LOAD.hProcessor,
-				args->ARGS_PROC_LOAD.iArgc,
-				(CONST char **)argv, (CONST char **)envp);
+		status = proc_load(args->args_proc_load.hprocessor,
+				   args->args_proc_load.argc_index,
+				   (CONST char **)argv, (CONST char **)envp);
 	}
 func_cont:
 	if (envp) {
 		i = 0;
 		while (envp[i])
-			MEM_Free(envp[i++]);
+			kfree(envp[i++]);
 
-		MEM_Free(envp);
+		kfree(envp);
 	}
 
 	if (argv) {
-		count = args->ARGS_PROC_LOAD.iArgc;
+		count = args->args_proc_load.argc_index;
 		for (i = 0; (i < count) && argv[i]; i++)
-			MEM_Free(argv[i]);
+			kfree(argv[i]);
 
-		MEM_Free(argv);
+		kfree(argv);
 	}
 
 	return status;
 }
 
 /*
- * ======== PROCWRAP_Map ========
+ * ======== procwrap_map ========
  */
-u32 PROCWRAP_Map(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_map(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	void *pMapAddr;
+	dsp_status status;
+	void *map_addr;
 
-	GT_0trace(WCD_debugMask, GT_ENTER, "PROCWRAP_Map: entered\n");
-	status = PROC_Map(args->ARGS_PROC_MAPMEM.hProcessor,
-			 args->ARGS_PROC_MAPMEM.pMpuAddr,
-			 args->ARGS_PROC_MAPMEM.ulSize,
-			 args->ARGS_PROC_MAPMEM.pReqAddr, &pMapAddr,
-			 args->ARGS_PROC_MAPMEM.ulMapAttr, pr_ctxt);
+	if (!args->args_proc_mapmem.ul_size)
+		return DSP_ESIZE;
+
+	status = proc_map(args->args_proc_mapmem.hprocessor,
+			  args->args_proc_mapmem.pmpu_addr,
+			  args->args_proc_mapmem.ul_size,
+			  args->args_proc_mapmem.req_addr, &map_addr,
+			  args->args_proc_mapmem.ul_map_attr, pr_ctxt);
 	if (DSP_SUCCEEDED(status)) {
-		if (put_user(pMapAddr, args->ARGS_PROC_MAPMEM.ppMapAddr))
+		if (put_user(map_addr, args->args_proc_mapmem.pp_map_addr)) {
 			status = DSP_EINVALIDARG;
+			proc_un_map(args->args_proc_mapmem.hprocessor,
+				    map_addr, pr_ctxt);
+		}
 
 	}
 	return status;
 }
 
 /*
- * ======== PROCWRAP_RegisterNotify ========
+ * ======== procwrap_register_notify ========
  */
-u32 PROCWRAP_RegisterNotify(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_register_notify(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	struct DSP_NOTIFICATION notification;
+	dsp_status status;
+	struct dsp_notification notification;
 
-	GT_0trace(WCD_debugMask, GT_ENTER,
-		 "PROCWRAP_RegisterNotify: entered\n");
-
-	/* Initialize the notification data structure  */
-	notification.psName = NULL;
+	/* Initialize the notification data structure */
+	notification.ps_name = NULL;
 	notification.handle = NULL;
 
-	status = PROC_RegisterNotify(args->ARGS_PROC_REGISTER_NOTIFY.hProcessor,
-				    args->ARGS_PROC_REGISTER_NOTIFY.uEventMask,
-				    args->ARGS_PROC_REGISTER_NOTIFY.uNotifyType,
-				    &notification);
-	cp_to_usr(args->ARGS_PROC_REGISTER_NOTIFY.hNotification, &notification,
-		 status, 1);
+	status =
+	    proc_register_notify(args->args_proc_register_notify.hprocessor,
+				 args->args_proc_register_notify.event_mask,
+				 args->args_proc_register_notify.notify_type,
+				 &notification);
+	CP_TO_USR(args->args_proc_register_notify.hnotification, &notification,
+		  status, 1);
 	return status;
 }
 
 /*
- * ======== PROCWRAP_ReserveMemory ========
+ * ======== procwrap_reserve_memory ========
  */
-u32 PROCWRAP_ReserveMemory(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_reserve_memory(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	void *pRsvAddr;
+	dsp_status status;
+	void *prsv_addr;
 
-	GT_0trace(WCD_debugMask, GT_ENTER, "PROCWRAP_ReserveMemory: entered\n");
-	status = PROC_ReserveMemory(args->ARGS_PROC_RSVMEM.hProcessor,
-				   args->ARGS_PROC_RSVMEM.ulSize, &pRsvAddr);
-	if (put_user(pRsvAddr, args->ARGS_PROC_RSVMEM.ppRsvAddr))
-		status = DSP_EINVALIDARG;
+	if ((args->args_proc_rsvmem.ul_size <= 0) ||
+	    (args->args_proc_rsvmem.ul_size & (PG_SIZE4K - 1)) != 0)
+		return DSP_ESIZE;
 
+	status = proc_reserve_memory(args->args_proc_rsvmem.hprocessor,
+				     args->args_proc_rsvmem.ul_size, &prsv_addr,
+				     pr_ctxt);
+	if (DSP_SUCCEEDED(status)) {
+		if (put_user(prsv_addr, args->args_proc_rsvmem.pp_rsv_addr)) {
+			status = DSP_EINVALIDARG;
+			proc_un_reserve_memory(args->args_proc_rsvmem.
+					       hprocessor, prsv_addr, pr_ctxt);
+		}
+	}
 	return status;
 }
 
 /*
- * ======== PROCWRAP_Start ========
+ * ======== procwrap_start ========
  */
-u32 PROCWRAP_Start(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_start(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	u32 ret;
 
-	GT_0trace(WCD_debugMask, GT_ENTER, "PROCWRAP_Start: entered\n");
-	retVal = PROC_Start(args->ARGS_PROC_START.hProcessor);
-	return retVal;
+	ret = proc_start(args->args_proc_start.hprocessor);
+	return ret;
 }
 
 /*
- * ======== PROCWRAP_UnMap ========
+ * ======== procwrap_un_map ========
  */
-u32 PROCWRAP_UnMap(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_un_map(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
+	dsp_status status;
 
-	GT_0trace(WCD_debugMask, GT_ENTER, "PROCWRAP_UnMap: entered\n");
-	status = PROC_UnMap(args->ARGS_PROC_UNMAPMEM.hProcessor,
-			   args->ARGS_PROC_UNMAPMEM.pMapAddr, pr_ctxt);
+	status = proc_un_map(args->args_proc_unmapmem.hprocessor,
+			     args->args_proc_unmapmem.map_addr, pr_ctxt);
 	return status;
 }
 
 /*
- * ======== PROCWRAP_UnReserveMemory ========
+ * ======== procwrap_un_reserve_memory ========
  */
-u32 PROCWRAP_UnReserveMemory(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_un_reserve_memory(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
+	dsp_status status;
 
-	GT_0trace(WCD_debugMask, GT_ENTER,
-		 "PROCWRAP_UnReserveMemory: entered\n");
-	status = PROC_UnReserveMemory(args->ARGS_PROC_UNRSVMEM.hProcessor,
-				     args->ARGS_PROC_UNRSVMEM.pRsvAddr);
+	status = proc_un_reserve_memory(args->args_proc_unrsvmem.hprocessor,
+					args->args_proc_unrsvmem.prsv_addr,
+					pr_ctxt);
 	return status;
 }
 
 /*
- * ======== PROCWRAP_Stop ========
+ * ======== procwrap_stop ========
  */
-u32 PROCWRAP_Stop(union Trapped_Args *args, void *pr_ctxt)
+u32 procwrap_stop(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	u32 ret;
 
-	GT_0trace(WCD_debugMask, GT_ENTER, "PROCWRAP_Stop: entered\n");
-	retVal = PROC_Stop(args->ARGS_PROC_STOP.hProcessor);
+	ret = proc_stop(args->args_proc_stop.hprocessor);
 
-	return retVal;
+	return ret;
 }
 
 /*
- * ======== NODEWRAP_Allocate ========
+ * ======== nodewrap_allocate ========
  */
-u32 NODEWRAP_Allocate(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_allocate(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_UUID nodeId;
-	u32 cbDataSize = 0;
-	u32 __user *pSize = (u32 __user *)args->ARGS_NODE_ALLOCATE.pArgs;
-	u8 *pArgs = NULL;
-	struct DSP_NODEATTRIN attrIn, *pAttrIn = NULL;
-	struct NODE_OBJECT *hNode;
-
-	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_Allocate: entered\n");
+	dsp_status status = DSP_SOK;
+	struct dsp_uuid node_uuid;
+	u32 cb_data_size = 0;
+	u32 __user *psize = (u32 __user *) args->args_node_allocate.pargs;
+	u8 *pargs = NULL;
+	struct dsp_nodeattrin proc_attr_in, *attr_in = NULL;
+	struct node_object *hnode;
 
 	/* Optional argument */
-	if (pSize) {
-		if (get_user(cbDataSize, pSize))
+	if (psize) {
+		if (get_user(cb_data_size, psize))
 			status = DSP_EFAIL;
 
-		cbDataSize += sizeof(u32);
+		cb_data_size += sizeof(u32);
 		if (DSP_SUCCEEDED(status)) {
-			pArgs = MEM_Alloc(cbDataSize, MEM_NONPAGED);
-			if (pArgs == NULL)
+			pargs = mem_alloc(cb_data_size, MEM_NONPAGED);
+			if (pargs == NULL)
 				status = DSP_EMEMORY;
 
 		}
-		cp_fm_usr(pArgs, args->ARGS_NODE_ALLOCATE.pArgs, status,
-			 cbDataSize);
+		CP_FM_USR(pargs, args->args_node_allocate.pargs, status,
+			  cb_data_size);
 	}
-	cp_fm_usr(&nodeId, args->ARGS_NODE_ALLOCATE.pNodeID, status, 1);
+	CP_FM_USR(&node_uuid, args->args_node_allocate.node_id_ptr, status, 1);
 	if (DSP_FAILED(status))
 		goto func_cont;
 	/* Optional argument */
-	if (args->ARGS_NODE_ALLOCATE.pAttrIn) {
-		cp_fm_usr(&attrIn, args->ARGS_NODE_ALLOCATE.pAttrIn, status, 1);
+	if (args->args_node_allocate.attr_in) {
+		CP_FM_USR(&proc_attr_in, args->args_node_allocate.attr_in,
+			  status, 1);
 		if (DSP_SUCCEEDED(status))
-			pAttrIn = &attrIn;
+			attr_in = &proc_attr_in;
 		else
 			status = DSP_EMEMORY;
 
 	}
 	if (DSP_SUCCEEDED(status)) {
-		status = NODE_Allocate(args->ARGS_NODE_ALLOCATE.hProcessor,
-				      &nodeId, (struct DSP_CBDATA *)pArgs,
-				      pAttrIn, &hNode, pr_ctxt);
+		status = node_allocate(args->args_node_allocate.hprocessor,
+				       &node_uuid, (struct dsp_cbdata *)pargs,
+				       attr_in, &hnode, pr_ctxt);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		CP_TO_USR(args->args_node_allocate.ph_node, &hnode, status, 1);
+		if (DSP_FAILED(status)) {
+			status = DSP_EPOINTER;
+			node_delete(hnode, pr_ctxt);
+		}
 	}
-	cp_to_usr(args->ARGS_NODE_ALLOCATE.phNode, &hNode, status, 1);
 func_cont:
-	if (pArgs)
-		MEM_Free(pArgs);
+	kfree(pargs);
 
 	return status;
 }
 
 /*
- *  ======== NODEWRAP_AllocMsgBuf ========
+ *  ======== nodewrap_alloc_msg_buf ========
  */
-u32 NODEWRAP_AllocMsgBuf(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_alloc_msg_buf(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_BUFFERATTR *pAttr = NULL;
-	struct DSP_BUFFERATTR attr;
-	u8 *pBuffer = NULL;
+	dsp_status status = DSP_SOK;
+	struct dsp_bufferattr *pattr = NULL;
+	struct dsp_bufferattr attr;
+	u8 *pbuffer = NULL;
 
-	if (args->ARGS_NODE_ALLOCMSGBUF.pAttr) {	/* Optional argument */
-		cp_fm_usr(&attr, args->ARGS_NODE_ALLOCMSGBUF.pAttr, status, 1);
+	if (!args->args_node_allocmsgbuf.usize)
+		return DSP_ESIZE;
+
+	if (args->args_node_allocmsgbuf.pattr) {	/* Optional argument */
+		CP_FM_USR(&attr, args->args_node_allocmsgbuf.pattr, status, 1);
 		if (DSP_SUCCEEDED(status))
-			pAttr = &attr;
+			pattr = &attr;
 
 	}
 	/* IN OUT argument */
-	cp_fm_usr(&pBuffer, args->ARGS_NODE_ALLOCMSGBUF.pBuffer, status, 1);
+	CP_FM_USR(&pbuffer, args->args_node_allocmsgbuf.pbuffer, status, 1);
 	if (DSP_SUCCEEDED(status)) {
-		status = NODE_AllocMsgBuf(args->ARGS_NODE_ALLOCMSGBUF.hNode,
-					 args->ARGS_NODE_ALLOCMSGBUF.uSize,
-					 pAttr, &pBuffer);
+		status = node_alloc_msg_buf(args->args_node_allocmsgbuf.hnode,
+					    args->args_node_allocmsgbuf.usize,
+					    pattr, &pbuffer);
 	}
-	cp_to_usr(args->ARGS_NODE_ALLOCMSGBUF.pBuffer, &pBuffer, status, 1);
+	CP_TO_USR(args->args_node_allocmsgbuf.pbuffer, &pbuffer, status, 1);
 	return status;
 }
 
 /*
- * ======== NODEWRAP_ChangePriority ========
+ * ======== nodewrap_change_priority ========
  */
-u32 NODEWRAP_ChangePriority(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_change_priority(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	u32 ret;
 
-	GT_0trace(WCD_debugMask, GT_ENTER,
-		 "NODEWRAP_ChangePriority: entered\n");
-	retVal = NODE_ChangePriority(args->ARGS_NODE_CHANGEPRIORITY.hNode,
-			args->ARGS_NODE_CHANGEPRIORITY.iPriority);
+	ret = node_change_priority(args->args_node_changepriority.hnode,
+				   args->args_node_changepriority.prio);
 
-	return retVal;
+	return ret;
 }
 
 /*
- * ======== NODEWRAP_Connect ========
+ * ======== nodewrap_connect ========
  */
-u32 NODEWRAP_Connect(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_connect(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_STRMATTR attrs;
-	struct DSP_STRMATTR *pAttrs = NULL;
-	u32 cbDataSize;
-	u32 __user *pSize = (u32 __user *)args->ARGS_NODE_CONNECT.pConnParam;
-	u8 *pArgs = NULL;
-
-	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_Connect: entered\n");
+	dsp_status status = DSP_SOK;
+	struct dsp_strmattr attrs;
+	struct dsp_strmattr *pattrs = NULL;
+	u32 cb_data_size;
+	u32 __user *psize = (u32 __user *) args->args_node_connect.conn_param;
+	u8 *pargs = NULL;
 
 	/* Optional argument */
-	if (pSize) {
-		if (get_user(cbDataSize, pSize))
+	if (psize) {
+		if (get_user(cb_data_size, psize))
 			status = DSP_EFAIL;
 
-		cbDataSize += sizeof(u32);
+		cb_data_size += sizeof(u32);
 		if (DSP_SUCCEEDED(status)) {
-			pArgs = MEM_Alloc(cbDataSize, MEM_NONPAGED);
-			if (pArgs == NULL) {
+			pargs = mem_alloc(cb_data_size, MEM_NONPAGED);
+			if (pargs == NULL) {
 				status = DSP_EMEMORY;
 				goto func_cont;
 			}
 
 		}
-		cp_fm_usr(pArgs, args->ARGS_NODE_CONNECT.pConnParam, status,
-			 cbDataSize);
+		CP_FM_USR(pargs, args->args_node_connect.conn_param, status,
+			  cb_data_size);
 		if (DSP_FAILED(status))
 			goto func_cont;
 	}
-	if (args->ARGS_NODE_CONNECT.pAttrs) {	/* Optional argument */
-		cp_fm_usr(&attrs, args->ARGS_NODE_CONNECT.pAttrs, status, 1);
+	if (args->args_node_connect.pattrs) {	/* Optional argument */
+		CP_FM_USR(&attrs, args->args_node_connect.pattrs, status, 1);
 		if (DSP_SUCCEEDED(status))
-			pAttrs = &attrs;
+			pattrs = &attrs;
 
 	}
 	if (DSP_SUCCEEDED(status)) {
-		status = NODE_Connect(args->ARGS_NODE_CONNECT.hNode,
-				     args->ARGS_NODE_CONNECT.uStream,
-				     args->ARGS_NODE_CONNECT.hOtherNode,
-				     args->ARGS_NODE_CONNECT.uOtherStream,
-				     pAttrs, (struct DSP_CBDATA *)pArgs);
+		status = node_connect(args->args_node_connect.hnode,
+				      args->args_node_connect.stream_id,
+				      args->args_node_connect.other_node,
+				      args->args_node_connect.other_stream,
+				      pattrs, (struct dsp_cbdata *)pargs);
 	}
 func_cont:
-	if (pArgs)
-		MEM_Free(pArgs);
+	kfree(pargs);
 
 	return status;
 }
 
 /*
- * ======== NODEWRAP_Create ========
+ * ======== nodewrap_create ========
  */
-u32 NODEWRAP_Create(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_create(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	u32 ret;
 
-	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_Create: entered\n");
-	retVal = NODE_Create(args->ARGS_NODE_CREATE.hNode);
+	ret = node_create(args->args_node_create.hnode);
 
-	return retVal;
+	return ret;
 }
 
 /*
- * ======== NODEWRAP_Delete ========
+ * ======== nodewrap_delete ========
  */
-u32 NODEWRAP_Delete(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_delete(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	u32 ret;
 
-	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_Delete: entered\n");
-	retVal = NODE_Delete(args->ARGS_NODE_DELETE.hNode, pr_ctxt);
+	ret = node_delete(args->args_node_delete.hnode, pr_ctxt);
 
-	return retVal;
+	return ret;
 }
 
 /*
- *  ======== NODEWRAP_FreeMsgBuf ========
+ *  ======== nodewrap_free_msg_buf ========
  */
-u32 NODEWRAP_FreeMsgBuf(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_free_msg_buf(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_BUFFERATTR *pAttr = NULL;
-	struct DSP_BUFFERATTR attr;
-	if (args->ARGS_NODE_FREEMSGBUF.pAttr) {	/* Optional argument */
-		cp_fm_usr(&attr, args->ARGS_NODE_FREEMSGBUF.pAttr, status, 1);
+	dsp_status status = DSP_SOK;
+	struct dsp_bufferattr *pattr = NULL;
+	struct dsp_bufferattr attr;
+	if (args->args_node_freemsgbuf.pattr) {	/* Optional argument */
+		CP_FM_USR(&attr, args->args_node_freemsgbuf.pattr, status, 1);
 		if (DSP_SUCCEEDED(status))
-			pAttr = &attr;
+			pattr = &attr;
 
 	}
+
+	if (!args->args_node_freemsgbuf.pbuffer)
+		return DSP_EPOINTER;
+
 	if (DSP_SUCCEEDED(status)) {
-		status = NODE_FreeMsgBuf(args->ARGS_NODE_FREEMSGBUF.hNode,
-					args->ARGS_NODE_FREEMSGBUF.pBuffer,
-					pAttr);
+		status = node_free_msg_buf(args->args_node_freemsgbuf.hnode,
+					   args->args_node_freemsgbuf.pbuffer,
+					   pattr);
 	}
 
 	return status;
 }
 
 /*
- * ======== NODEWRAP_GetAttr ========
+ * ======== nodewrap_get_attr ========
  */
-u32 NODEWRAP_GetAttr(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_get_attr(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_NODEATTR attr;
-
-	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_GetAttr: entered\n");
+	dsp_status status = DSP_SOK;
+	struct dsp_nodeattr attr;
 
-	status = NODE_GetAttr(args->ARGS_NODE_GETATTR.hNode, &attr,
-			     args->ARGS_NODE_GETATTR.uAttrSize);
-	cp_to_usr(args->ARGS_NODE_GETATTR.pAttr, &attr, status, 1);
+	status = node_get_attr(args->args_node_getattr.hnode, &attr,
+			       args->args_node_getattr.attr_size);
+	CP_TO_USR(args->args_node_getattr.pattr, &attr, status, 1);
 
 	return status;
 }
 
 /*
- * ======== NODEWRAP_GetMessage ========
+ * ======== nodewrap_get_message ========
  */
-u32 NODEWRAP_GetMessage(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_get_message(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	struct DSP_MSG msg;
+	dsp_status status;
+	struct dsp_msg msg;
 
-	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_GetMessage: entered\n");
+	status = node_get_message(args->args_node_getmessage.hnode, &msg,
+				  args->args_node_getmessage.utimeout);
 
-	status = NODE_GetMessage(args->ARGS_NODE_GETMESSAGE.hNode, &msg,
-				args->ARGS_NODE_GETMESSAGE.uTimeout);
-
-	cp_to_usr(args->ARGS_NODE_GETMESSAGE.pMessage, &msg, status, 1);
+	CP_TO_USR(args->args_node_getmessage.message, &msg, status, 1);
 
 	return status;
 }
 
 /*
- * ======== NODEWRAP_Pause ========
+ * ======== nodewrap_pause ========
  */
-u32 NODEWRAP_Pause(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_pause(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	u32 ret;
 
-	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_Pause: entered\n");
-	retVal = NODE_Pause(args->ARGS_NODE_PAUSE.hNode);
+	ret = node_pause(args->args_node_pause.hnode);
 
-	return retVal;
+	return ret;
 }
 
 /*
- * ======== NODEWRAP_PutMessage ========
+ * ======== nodewrap_put_message ========
  */
-u32 NODEWRAP_PutMessage(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_put_message(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_MSG msg;
-
-	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_PutMessage: entered\n");
+	dsp_status status = DSP_SOK;
+	struct dsp_msg msg;
 
-	cp_fm_usr(&msg, args->ARGS_NODE_PUTMESSAGE.pMessage, status, 1);
+	CP_FM_USR(&msg, args->args_node_putmessage.message, status, 1);
 
 	if (DSP_SUCCEEDED(status)) {
-		status = NODE_PutMessage(args->ARGS_NODE_PUTMESSAGE.hNode, &msg,
-					args->ARGS_NODE_PUTMESSAGE.uTimeout);
+		status =
+		    node_put_message(args->args_node_putmessage.hnode, &msg,
+				     args->args_node_putmessage.utimeout);
 	}
 
 	return status;
 }
 
 /*
- * ======== NODEWRAP_RegisterNotify ========
+ * ======== nodewrap_register_notify ========
  */
-u32 NODEWRAP_RegisterNotify(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_register_notify(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_NOTIFICATION notification;
+	dsp_status status = DSP_SOK;
+	struct dsp_notification notification;
 
-	GT_0trace(WCD_debugMask, GT_ENTER,
-		 "NODEWRAP_RegisterNotify: entered\n");
-
-	/* Initialize the notification data structure  */
-	notification.psName = NULL;
+	/* Initialize the notification data structure */
+	notification.ps_name = NULL;
 	notification.handle = NULL;
 
-	status = NODE_RegisterNotify(args->ARGS_NODE_REGISTERNOTIFY.hNode,
-				    args->ARGS_NODE_REGISTERNOTIFY.uEventMask,
-				    args->ARGS_NODE_REGISTERNOTIFY.uNotifyType,
-				    &notification);
-	cp_to_usr(args->ARGS_NODE_REGISTERNOTIFY.hNotification, &notification,
-		 status, 1);
+	if (!args->args_proc_register_notify.event_mask)
+		CP_FM_USR(&notification,
+			  args->args_proc_register_notify.hnotification,
+			  status, 1);
+
+	status = node_register_notify(args->args_node_registernotify.hnode,
+				      args->args_node_registernotify.event_mask,
+				      args->args_node_registernotify.
+				      notify_type, &notification);
+	CP_TO_USR(args->args_node_registernotify.hnotification, &notification,
+		  status, 1);
 	return status;
 }
 
 /*
- * ======== NODEWRAP_Run ========
+ * ======== nodewrap_run ========
  */
-u32 NODEWRAP_Run(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_run(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	u32 ret;
 
-	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_Run: entered\n");
-	retVal = NODE_Run(args->ARGS_NODE_RUN.hNode);
+	ret = node_run(args->args_node_run.hnode);
 
-	return retVal;
+	return ret;
 }
 
 /*
- * ======== NODEWRAP_Terminate ========
+ * ======== nodewrap_terminate ========
  */
-u32 NODEWRAP_Terminate(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_terminate(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	DSP_STATUS tempstatus;
+	dsp_status status;
+	dsp_status tempstatus;
 
-	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_Terminate: entered\n");
+	status = node_terminate(args->args_node_terminate.hnode, &tempstatus);
 
-	status = NODE_Terminate(args->ARGS_NODE_TERMINATE.hNode, &tempstatus);
-
-	cp_to_usr(args->ARGS_NODE_TERMINATE.pStatus, &tempstatus, status, 1);
+	CP_TO_USR(args->args_node_terminate.pstatus, &tempstatus, status, 1);
 
 	return status;
 }
 
-
 /*
- * ======== NODEWRAP_GetUUIDProps ========
+ * ======== nodewrap_get_uuid_props ========
  */
-u32 NODEWRAP_GetUUIDProps(union Trapped_Args *args, void *pr_ctxt)
+u32 nodewrap_get_uuid_props(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_UUID nodeId;
-	struct DSP_NDBPROPS    *pnodeProps = NULL;
-
-	GT_0trace(WCD_debugMask, GT_ENTER,
-		 "NODEWRAP_GetUUIDPropste: entered\n");
+	dsp_status status = DSP_SOK;
+	struct dsp_uuid node_uuid;
+	struct dsp_ndbprops *pnode_props = NULL;
 
-
-	cp_fm_usr(&nodeId, args->ARGS_NODE_GETUUIDPROPS.pNodeID, status, 1);
+	CP_FM_USR(&node_uuid, args->args_node_getuuidprops.node_id_ptr, status,
+		  1);
 	if (DSP_FAILED(status))
 		goto func_cont;
-	pnodeProps = MEM_Alloc(sizeof(struct DSP_NDBPROPS), MEM_NONPAGED);
-	if (pnodeProps != NULL) {
-		status = NODE_GetUUIDProps(args->
-					  ARGS_NODE_GETUUIDPROPS.hProcessor,
-					  &nodeId, pnodeProps);
-		cp_to_usr(args->ARGS_NODE_GETUUIDPROPS.pNodeProps, pnodeProps,
-			 status, 1);
+	pnode_props = mem_alloc(sizeof(struct dsp_ndbprops), MEM_NONPAGED);
+	if (pnode_props != NULL) {
+		status =
+		    node_get_uuid_props(args->args_node_getuuidprops.hprocessor,
+					&node_uuid, pnode_props);
+		CP_TO_USR(args->args_node_getuuidprops.node_props, pnode_props,
+			  status, 1);
 	} else
 		status = DSP_EMEMORY;
 func_cont:
-	if (pnodeProps)
-		MEM_Free(pnodeProps);
+	kfree(pnode_props);
 	return status;
 }
 
 /*
- * ======== STRMWRAP_AllocateBuffer ========
+ * ======== strmwrap_allocate_buffer ========
  */
-u32 STRMWRAP_AllocateBuffer(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_allocate_buffer(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status;
-	u8 **apBuffer = NULL;
-	u32 uNumBufs = args->ARGS_STRM_ALLOCATEBUFFER.uNumBufs;
+	dsp_status status;
+	u8 **ap_buffer = NULL;
+	u32 num_bufs = args->args_strm_allocatebuffer.num_bufs;
 
-	DBC_Require(uNumBufs <= MAX_BUFS);
+	if (num_bufs > MAX_BUFS)
+		return DSP_EINVALIDARG;
 
-	apBuffer = MEM_Alloc((uNumBufs * sizeof(u8 *)), MEM_NONPAGED);
+	ap_buffer = mem_alloc((num_bufs * sizeof(u8 *)), MEM_NONPAGED);
 
-	status = STRM_AllocateBuffer(args->ARGS_STRM_ALLOCATEBUFFER.hStream,
-				     args->ARGS_STRM_ALLOCATEBUFFER.uSize,
-				     apBuffer, uNumBufs, pr_ctxt);
-	cp_to_usr(args->ARGS_STRM_ALLOCATEBUFFER.apBuffer, apBuffer, status,
-		 uNumBufs);
-	if (apBuffer)
-		MEM_Free(apBuffer);
+	status = strm_allocate_buffer(args->args_strm_allocatebuffer.hstream,
+				      args->args_strm_allocatebuffer.usize,
+				      ap_buffer, num_bufs, pr_ctxt);
+	if (DSP_SUCCEEDED(status)) {
+		CP_TO_USR(args->args_strm_allocatebuffer.ap_buffer, ap_buffer,
+			  status, num_bufs);
+		if (DSP_FAILED(status)) {
+			status = DSP_EPOINTER;
+			strm_free_buffer(args->args_strm_allocatebuffer.hstream,
+					 ap_buffer, num_bufs, pr_ctxt);
+		}
+	}
+	kfree(ap_buffer);
 
 	return status;
 }
 
 /*
- * ======== STRMWRAP_Close ========
+ * ======== strmwrap_close ========
  */
-u32 STRMWRAP_Close(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_close(union Trapped_Args *args, void *pr_ctxt)
 {
-	return STRM_Close(args->ARGS_STRM_CLOSE.hStream, pr_ctxt);
+	return strm_close(args->args_strm_close.hstream, pr_ctxt);
 }
 
 /*
- * ======== STRMWRAP_FreeBuffer ========
+ * ======== strmwrap_free_buffer ========
  */
-u32 STRMWRAP_FreeBuffer(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_free_buffer(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	u8 **apBuffer = NULL;
-	u32 uNumBufs = args->ARGS_STRM_FREEBUFFER.uNumBufs;
+	dsp_status status = DSP_SOK;
+	u8 **ap_buffer = NULL;
+	u32 num_bufs = args->args_strm_freebuffer.num_bufs;
 
-	DBC_Require(uNumBufs <= MAX_BUFS);
+	if (num_bufs > MAX_BUFS)
+		return DSP_EINVALIDARG;
 
-	apBuffer = MEM_Alloc((uNumBufs * sizeof(u8 *)), MEM_NONPAGED);
+	ap_buffer = mem_alloc((num_bufs * sizeof(u8 *)), MEM_NONPAGED);
 
-	cp_fm_usr(apBuffer, args->ARGS_STRM_FREEBUFFER.apBuffer, status,
-		 uNumBufs);
+	CP_FM_USR(ap_buffer, args->args_strm_freebuffer.ap_buffer, status,
+		  num_bufs);
 
 	if (DSP_SUCCEEDED(status)) {
-		status = STRM_FreeBuffer(args->ARGS_STRM_FREEBUFFER.hStream,
-					 apBuffer, uNumBufs, pr_ctxt);
+		status = strm_free_buffer(args->args_strm_freebuffer.hstream,
+					  ap_buffer, num_bufs, pr_ctxt);
 	}
-	cp_to_usr(args->ARGS_STRM_FREEBUFFER.apBuffer, apBuffer, status,
-		 uNumBufs);
-	if (apBuffer)
-		MEM_Free(apBuffer);
+	CP_TO_USR(args->args_strm_freebuffer.ap_buffer, ap_buffer, status,
+		  num_bufs);
+	kfree(ap_buffer);
 
 	return status;
 }
 
 /*
- * ======== STRMWRAP_GetEventHandle ========
+ * ======== strmwrap_get_event_handle ========
  */
-u32 STRMWRAP_GetEventHandle(union Trapped_Args *args, void *pr_ctxt)
+u32 __deprecated strmwrap_get_event_handle(union Trapped_Args * args,
+					   void *pr_ctxt)
 {
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
 	return DSP_ENOTIMPL;
 }
 
 /*
- * ======== STRMWRAP_GetInfo ========
+ * ======== strmwrap_get_info ========
  */
-u32 STRMWRAP_GetInfo(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_get_info(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct STRM_INFO strmInfo;
-	struct DSP_STREAMINFO user;
-	struct DSP_STREAMINFO *temp;
+	dsp_status status = DSP_SOK;
+	struct stream_info strm_info;
+	struct dsp_streaminfo user;
+	struct dsp_streaminfo *temp;
 
-	cp_fm_usr(&strmInfo, args->ARGS_STRM_GETINFO.pStreamInfo, status, 1);
-	temp = strmInfo.pUser;
+	CP_FM_USR(&strm_info, args->args_strm_getinfo.stream_info, status, 1);
+	temp = strm_info.user_strm;
 
-	strmInfo.pUser = &user;
+	strm_info.user_strm = &user;
 
 	if (DSP_SUCCEEDED(status)) {
-		status = STRM_GetInfo(args->ARGS_STRM_GETINFO.hStream,
-			 &strmInfo, args->ARGS_STRM_GETINFO.uStreamInfoSize);
+		status = strm_get_info(args->args_strm_getinfo.hstream,
+				       &strm_info,
+				       args->args_strm_getinfo.
+				       stream_info_size);
 	}
-	cp_to_usr(temp, strmInfo.pUser, status, 1);
-	strmInfo.pUser = temp;
-	cp_to_usr(args->ARGS_STRM_GETINFO.pStreamInfo, &strmInfo, status, 1);
+	CP_TO_USR(temp, strm_info.user_strm, status, 1);
+	strm_info.user_strm = temp;
+	CP_TO_USR(args->args_strm_getinfo.stream_info, &strm_info, status, 1);
 	return status;
 }
 
 /*
- * ======== STRMWRAP_Idle ========
+ * ======== strmwrap_idle ========
  */
-u32 STRMWRAP_Idle(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_idle(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	u32 ret;
 
-	retVal = STRM_Idle(args->ARGS_STRM_IDLE.hStream,
-			args->ARGS_STRM_IDLE.bFlush);
+	ret = strm_idle(args->args_strm_idle.hstream,
+			args->args_strm_idle.flush_flag);
 
-	return retVal;
+	return ret;
 }
 
 /*
- * ======== STRMWRAP_Issue ========
+ * ======== strmwrap_issue ========
  */
-u32 STRMWRAP_Issue(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_issue(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	/* No need of doing cp_fm_usr for the user buffer (pBuffer)
-	as this is done in Bridge internal function WMD_CHNL_AddIOReq
-	in chnl_sm.c */
-	status = STRM_Issue(args->ARGS_STRM_ISSUE.hStream,
-			args->ARGS_STRM_ISSUE.pBuffer,
-			args->ARGS_STRM_ISSUE.dwBytes,
-			args->ARGS_STRM_ISSUE.dwBufSize,
-			args->ARGS_STRM_ISSUE.dwArg);
+	dsp_status status = DSP_SOK;
+
+	if (!args->args_strm_issue.pbuffer)
+		return DSP_EPOINTER;
+
+	/* No need of doing CP_FM_USR for the user buffer (pbuffer)
+	   as this is done in Bridge internal function bridge_chnl_add_io_req
+	   in chnl_sm.c */
+	status = strm_issue(args->args_strm_issue.hstream,
+			    args->args_strm_issue.pbuffer,
+			    args->args_strm_issue.dw_bytes,
+			    args->args_strm_issue.dw_buf_size,
+			    args->args_strm_issue.dw_arg);
 
 	return status;
 }
 
 /*
- * ======== STRMWRAP_Open ========
+ * ======== strmwrap_open ========
  */
-u32 STRMWRAP_Open(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_open(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct STRM_ATTR attr;
-	struct STRM_OBJECT *pStrm;
-	struct DSP_STREAMATTRIN strmAttrIn;
+	dsp_status status = DSP_SOK;
+	struct strm_attr attr;
+	struct strm_object *strm_obj;
+	struct dsp_streamattrin strm_attr_in;
 
-	cp_fm_usr(&attr, args->ARGS_STRM_OPEN.pAttrIn, status, 1);
+	CP_FM_USR(&attr, args->args_strm_open.attr_in, status, 1);
 
-	if (attr.pStreamAttrIn != NULL) {	/* Optional argument */
-		cp_fm_usr(&strmAttrIn, attr.pStreamAttrIn, status, 1);
-		if (DSP_SUCCEEDED(status))
-			attr.pStreamAttrIn = &strmAttrIn;
+	if (attr.stream_attr_in != NULL) {	/* Optional argument */
+		CP_FM_USR(&strm_attr_in, attr.stream_attr_in, status, 1);
+		if (DSP_SUCCEEDED(status)) {
+			attr.stream_attr_in = &strm_attr_in;
+			if (attr.stream_attr_in->strm_mode == STRMMODE_LDMA)
+				return DSP_ENOTIMPL;
+		}
 
 	}
-	status = STRM_Open(args->ARGS_STRM_OPEN.hNode,
-			  args->ARGS_STRM_OPEN.uDirection,
-			  args->ARGS_STRM_OPEN.uIndex, &attr, &pStrm,
-			  pr_ctxt);
-	cp_to_usr(args->ARGS_STRM_OPEN.phStream, &pStrm, status, 1);
+	status = strm_open(args->args_strm_open.hnode,
+			   args->args_strm_open.direction,
+			   args->args_strm_open.index, &attr, &strm_obj,
+			   pr_ctxt);
+	CP_TO_USR(args->args_strm_open.ph_stream, &strm_obj, status, 1);
 	return status;
 }
 
 /*
- * ======== STRMWRAP_Reclaim ========
+ * ======== strmwrap_reclaim ========
  */
-u32 STRMWRAP_Reclaim(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_reclaim(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	u8 *pBufPtr;
-	u32 ulBytes;
-	u32 dwArg;
-	u32 ulBufSize;
+	dsp_status status = DSP_SOK;
+	u8 *buf_ptr;
+	u32 ul_bytes;
+	u32 dw_arg;
+	u32 ul_buf_size;
 
-	status = STRM_Reclaim(args->ARGS_STRM_RECLAIM.hStream, &pBufPtr,
-			     &ulBytes, &ulBufSize, &dwArg);
-	cp_to_usr(args->ARGS_STRM_RECLAIM.pBufPtr, &pBufPtr, status, 1);
-	cp_to_usr(args->ARGS_STRM_RECLAIM.pBytes, &ulBytes, status, 1);
-	cp_to_usr(args->ARGS_STRM_RECLAIM.pdwArg, &dwArg, status, 1);
+	status = strm_reclaim(args->args_strm_reclaim.hstream, &buf_ptr,
+			      &ul_bytes, &ul_buf_size, &dw_arg);
+	CP_TO_USR(args->args_strm_reclaim.buf_ptr, &buf_ptr, status, 1);
+	CP_TO_USR(args->args_strm_reclaim.bytes, &ul_bytes, status, 1);
+	CP_TO_USR(args->args_strm_reclaim.pdw_arg, &dw_arg, status, 1);
 
-	if (args->ARGS_STRM_RECLAIM.pBufSize != NULL) {
-		cp_to_usr(args->ARGS_STRM_RECLAIM.pBufSize, &ulBufSize,
-			 status, 1);
+	if (args->args_strm_reclaim.buf_size_ptr != NULL) {
+		CP_TO_USR(args->args_strm_reclaim.buf_size_ptr, &ul_buf_size,
+			  status, 1);
 	}
 
 	return status;
 }
 
 /*
- * ======== STRMWRAP_RegisterNotify ========
+ * ======== strmwrap_register_notify ========
  */
-u32 STRMWRAP_RegisterNotify(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_register_notify(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_NOTIFICATION notification;
+	dsp_status status = DSP_SOK;
+	struct dsp_notification notification;
 
-	GT_0trace(WCD_debugMask, GT_ENTER,
-		 "NODEWRAP_RegisterNotify: entered\n");
-
-	/* Initialize the notification data structure  */
-	notification.psName = NULL;
+	/* Initialize the notification data structure */
+	notification.ps_name = NULL;
 	notification.handle = NULL;
 
-	status = STRM_RegisterNotify(args->ARGS_STRM_REGISTERNOTIFY.hStream,
-				    args->ARGS_STRM_REGISTERNOTIFY.uEventMask,
-				    args->ARGS_STRM_REGISTERNOTIFY.uNotifyType,
-				    &notification);
-	cp_to_usr(args->ARGS_STRM_REGISTERNOTIFY.hNotification, &notification,
-		 status, 1);
+	status = strm_register_notify(args->args_strm_registernotify.hstream,
+				      args->args_strm_registernotify.event_mask,
+				      args->args_strm_registernotify.
+				      notify_type, &notification);
+	CP_TO_USR(args->args_strm_registernotify.hnotification, &notification,
+		  status, 1);
 
 	return status;
 }
 
 /*
- * ======== STRMWRAP_Select ========
+ * ======== strmwrap_select ========
  */
-u32 STRMWRAP_Select(union Trapped_Args *args, void *pr_ctxt)
+u32 strmwrap_select(union Trapped_Args *args, void *pr_ctxt)
 {
 	u32 mask;
-	struct STRM_OBJECT *aStrmTab[MAX_STREAMS];
-	DSP_STATUS status = DSP_SOK;
+	struct strm_object *strm_tab[MAX_STREAMS];
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(args->ARGS_STRM_SELECT.nStreams <= MAX_STREAMS);
+	if (args->args_strm_select.strm_num > MAX_STREAMS)
+		return DSP_EINVALIDARG;
 
-	cp_fm_usr(aStrmTab, args->ARGS_STRM_SELECT.aStreamTab, status,
-		 args->ARGS_STRM_SELECT.nStreams);
+	CP_FM_USR(strm_tab, args->args_strm_select.stream_tab, status,
+		  args->args_strm_select.strm_num);
 	if (DSP_SUCCEEDED(status)) {
-		status = STRM_Select(aStrmTab, args->ARGS_STRM_SELECT.nStreams,
-				    &mask, args->ARGS_STRM_SELECT.uTimeout);
+		status = strm_select(strm_tab, args->args_strm_select.strm_num,
+				     &mask, args->args_strm_select.utimeout);
 	}
-	cp_to_usr(args->ARGS_STRM_SELECT.pMask, &mask, status, 1);
+	CP_TO_USR(args->args_strm_select.pmask, &mask, status, 1);
 	return status;
 }
 
 /* CMM */
 
 /*
- * ======== CMMWRAP_CallocBuf ========
+ * ======== cmmwrap_calloc_buf ========
  */
-u32 CMMWRAP_CallocBuf(union Trapped_Args *args, void *pr_ctxt)
+u32 __deprecated cmmwrap_calloc_buf(union Trapped_Args * args, void *pr_ctxt)
 {
 	/* This operation is done in kernel */
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
 	return DSP_ENOTIMPL;
 }
 
 /*
- * ======== CMMWRAP_FreeBuf ========
+ * ======== cmmwrap_free_buf ========
  */
-u32 CMMWRAP_FreeBuf(union Trapped_Args *args, void *pr_ctxt)
+u32 __deprecated cmmwrap_free_buf(union Trapped_Args * args, void *pr_ctxt)
 {
 	/* This operation is done in kernel */
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
 	return DSP_ENOTIMPL;
 }
 
 /*
- * ======== CMMWRAP_GetHandle ========
+ * ======== cmmwrap_get_handle ========
  */
-u32 CMMWRAP_GetHandle(union Trapped_Args *args, void *pr_ctxt)
+u32 cmmwrap_get_handle(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CMM_OBJECT *hCmmMgr;
+	dsp_status status = DSP_SOK;
+	struct cmm_object *hcmm_mgr;
 
-	status = CMM_GetHandle(args->ARGS_CMM_GETHANDLE.hProcessor, &hCmmMgr);
+	status = cmm_get_handle(args->args_cmm_gethandle.hprocessor, &hcmm_mgr);
 
-	cp_to_usr(args->ARGS_CMM_GETHANDLE.phCmmMgr, &hCmmMgr, status, 1);
+	CP_TO_USR(args->args_cmm_gethandle.ph_cmm_mgr, &hcmm_mgr, status, 1);
 
 	return status;
 }
 
 /*
- * ======== CMMWRAP_GetInfo ========
+ * ======== cmmwrap_get_info ========
  */
-u32 CMMWRAP_GetInfo(union Trapped_Args *args, void *pr_ctxt)
+u32 cmmwrap_get_info(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CMM_INFO cmmInfo;
+	dsp_status status = DSP_SOK;
+	struct cmm_info cmm_info_obj;
 
-	status = CMM_GetInfo(args->ARGS_CMM_GETINFO.hCmmMgr, &cmmInfo);
+	status = cmm_get_info(args->args_cmm_getinfo.hcmm_mgr, &cmm_info_obj);
 
-	cp_to_usr(args->ARGS_CMM_GETINFO.pCmmInfo, &cmmInfo, status, 1);
+	CP_TO_USR(args->args_cmm_getinfo.cmm_info_obj, &cmm_info_obj, status,
+		  1);
 
 	return status;
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/dbdcd.c kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/dbdcd.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/dbdcd.c	2011-10-11 13:51:01.146523130 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/rmgr/dbdcd.c	2011-10-23 08:22:37.641906000 +0100
@@ -3,6 +3,15 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This file contains the implementation of the DSP/BIOS Bridge
+ * Configuration Database (DCD).
+ *
+ * Notes:
+ *   The fxn dcd_get_objects can apply a callback fxn to each DCD object
+ *   that is located in a specified COFF file.  At the moment,
+ *   dcd_auto_register, dcd_auto_unregister, and NLDR module all use
+ *   dcd_get_objects.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,53 +23,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dbdcd.c ========
- *  Description:
- *      This file contains the implementation of the DSP/BIOS Bridge
- *      Configuration Database (DCD).
- *
- *  Notes:
- *      The fxn DCD_GetObjects can apply a callback fxn to each DCD object
- *      that is located in a specified COFF file.  At the moment,
- *      DCD_AutoRegister, DCD_AutoUnregister, and NLDR module all use
- *      DCD_GetObjects.
- *
- *! Revision History
- *! ================
- *! 03-Dec-2003 map Changed DCD_OBJTYPE to DSP_DCDOBJTYPE
- *! 17-Dec-2002 map Modified DCD_GetDepLibs, DCD_GetNumDepLibs, GetDepLibInfo
- *!                 to include phase information
- *! 02-Dec-2002 map Modified DCD_GetLibraryName for phases in different
- *!                 libraries
- *! 26-Feb-2003 kc  Updated DCD_AutoUnregister and DCD_GetObjects to simplify
- *!                 DCD implementation.
- *! 17-Jul-2002 jeh Call COD_Open() instead of COD_OpenBase(), call COD_Close()
- *! 11-Jul-2002 jeh Added DCD_GetDepLibs(), DCD_GetNumDepLibs().
- *! 18-Feb-2003 vp  Code review updates
- *! 18-Oct-2002 vp  Ported to Linux platform
- *! 15-Mar-2002 jeh Read dynamic loading memory requirements into node object
- *!                 data. Added DCD_GetLibraryName().
- *! 13-Feb-2002 jeh Get system stack size in GetAttrsFromBuf().
- *! 01-Aug-2001 ag: Added check for PROC "extended" attributes used for
- *!                    DSP-MMU setup. These are private attributes.
- *! 18-Apr-2001 jeh Use COD_OpenBase instead of COD_LoadBase.
- *! 03-Apr-2001 sg: Changed error names to DSP_EDCD* format.
- *! 11-Jan-2001 jeh Changes to DCD_GetObjectDef to match node.cdb, proc.cdb.
- *! 12-Dec-2000 kc: Added DCD_AutoUnregister. MSGNODE, DAISNODE added in
- *!                 GetAttrsFromBuf
- *! 22-Nov-2000 kc: Replaced sprintf() calls with strncat.
- *! 09-Nov-2000 kc: Optimized DCD module.
- *! 30-Oct-2000 kc: Added DCD_AutoRegister function; changed local var. names.
- *! 29-Sep-2000 kc: Added code review changes (src/reviews/dcd_reviews.txt).
- *! 06-Sep-2000 jeh Get message segid, message notification type. Added Atoi()
- *!                 to replace atoi(), until cdb generation can output in
- *!                 decimal format.
- *! 26-Jul-2000 kc: Created.
- *!
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -70,10 +32,8 @@
 #include <dspbridge/errbase.h>
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/reg.h>
 
@@ -89,607 +49,547 @@
 /*  ----------------------------------- Global defines. */
 #define SIGNATURE       0x5f444344	/* "DCD_" (in reverse). */
 
-#define IsValidHandle(h)    (((h) != NULL) && (h->dwSignature == SIGNATURE))
+#define IS_VALID_HANDLE(h) (((h) != NULL) && (h->dw_signature == SIGNATURE))
 
-#define MAX_INT2CHAR_LENGTH     16   /* Maximum int2char len of 32 bit int. */
+#define MAX_INT2CHAR_LENGTH     16	/* Max int2char len of 32 bit int */
 
 /* Name of section containing dependent libraries */
-#define DEPLIBSECT              ".dspbridge_deplibs"
+#define DEPLIBSECT		".dspbridge_deplibs"
 
 /* DCD specific structures. */
-struct DCD_MANAGER {
-	u32 dwSignature;	/* Used for object validation.   */
-	struct COD_MANAGER *hCodMgr;	/* Handle to COD manager object. */
+struct dcd_manager {
+	u32 dw_signature;	/* Used for object validation. */
+	struct cod_manager *cod_mgr;	/* Handle to COD manager object. */
 };
 
 /* Global reference variables. */
-static u32 cRefs;
-static u32 cEnumRefs;
-
-extern struct GT_Mask curTrace;
+static u32 refs;
+static u32 enum_refs;
 
-/* helper function prototypes. */
-static s32 Atoi(char *pszBuf);
-
-static DSP_STATUS GetAttrsFromBuf(char *pszBuf, u32 ulBufSize,
-				  enum DSP_DCDOBJTYPE objType,
-				  struct DCD_GENERICOBJ *pGenObj);
-
-static void CompressBuf(char *pszBuf, u32 ulBufSize, s32 cCharSize);
-
-static char DspChar2GppChar(char *pWord, s32 cDspCharSize);
-
-static DSP_STATUS GetDepLibInfo(IN struct DCD_MANAGER *hDcdMgr,
-				IN struct DSP_UUID *pUuid,
-				IN OUT u16 *pNumLibs,
-				OPTIONAL OUT u16 *pNumPersLibs,
-				OPTIONAL OUT struct DSP_UUID *pDepLibUuids,
-				OPTIONAL OUT bool *pPersistentDepLibs,
-				IN enum NLDR_PHASE phase);
+/* Helper function prototypes. */
+static s32 atoi(char *psz_buf);
+static dsp_status get_attrs_from_buf(char *psz_buf, u32 ul_buf_size,
+				     enum dsp_dcdobjtype obj_type,
+				     struct dcd_genericobj *pGenObj);
+static void compress_buf(char *psz_buf, u32 ul_buf_size, s32 cCharSize);
+static char dsp_char2_gpp_char(char *pWord, s32 cDspCharSize);
+static dsp_status get_dep_lib_info(IN struct dcd_manager *hdcd_mgr,
+				   IN struct dsp_uuid *uuid_obj,
+				   IN OUT u16 *pNumLibs,
+				   OPTIONAL OUT u16 *pNumPersLibs,
+				   OPTIONAL OUT struct dsp_uuid *pDepLibUuids,
+				   OPTIONAL OUT bool *pPersistentDepLibs,
+				   IN enum nldr_phase phase);
 
 /*
- *  ======== DCD_AutoRegister ========
+ *  ======== dcd_auto_register ========
  *  Purpose:
  *      Parses the supplied image and resigsters with DCD.
  */
-
-DSP_STATUS DCD_AutoRegister(IN struct DCD_MANAGER *hDcdMgr,
-			    IN char *pszCoffPath)
+dsp_status dcd_auto_register(IN struct dcd_manager *hdcd_mgr,
+			     IN char *pszCoffPath)
 {
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
+	dsp_status status = DSP_SOK;
 
-	GT_1trace(curTrace, GT_ENTER, "DCD_AutoRegister: hDcdMgr 0x%x\n",
-		 hDcdMgr);
+	DBC_REQUIRE(refs > 0);
 
-	if (IsValidHandle(hDcdMgr)) {
-		status = DCD_GetObjects(hDcdMgr, pszCoffPath,
-					(DCD_REGISTERFXN)DCD_RegisterObject,
-					(void *)pszCoffPath);
-	} else {
+	if (IS_VALID_HANDLE(hdcd_mgr))
+		status = dcd_get_objects(hdcd_mgr, pszCoffPath,
+					 (dcd_registerfxn) dcd_register_object,
+					 (void *)pszCoffPath);
+	else
 		status = DSP_EHANDLE;
-		GT_0trace(curTrace, GT_6CLASS,
-			 "DCD_AutoRegister: invalid DCD manager handle.\n");
-	}
 
 	return status;
 }
 
 /*
- *  ======== DCD_AutoUnregister ========
+ *  ======== dcd_auto_unregister ========
  *  Purpose:
  *      Parses the supplied DSP image and unresiters from DCD.
  */
-DSP_STATUS DCD_AutoUnregister(IN struct DCD_MANAGER *hDcdMgr,
-			     IN char *pszCoffPath)
+dsp_status dcd_auto_unregister(IN struct dcd_manager *hdcd_mgr,
+			       IN char *pszCoffPath)
 {
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
+	dsp_status status = DSP_SOK;
 
-	GT_1trace(curTrace, GT_ENTER, "DCD_AutoUnregister: hDcdMgr 0x%x\n",
-		 hDcdMgr);
+	DBC_REQUIRE(refs > 0);
 
-	if (IsValidHandle(hDcdMgr)) {
-		status = DCD_GetObjects(hDcdMgr, pszCoffPath,
-				       (DCD_REGISTERFXN)DCD_RegisterObject,
-				       NULL);
-	} else {
+	if (IS_VALID_HANDLE(hdcd_mgr))
+		status = dcd_get_objects(hdcd_mgr, pszCoffPath,
+					 (dcd_registerfxn) dcd_register_object,
+					 NULL);
+	else
 		status = DSP_EHANDLE;
-		GT_0trace(curTrace, GT_6CLASS,
-			 "DCD_AutoUnregister: invalid DCD manager"
-			 " handle.\n");
-	}
 
 	return status;
 }
 
 /*
- *  ======== DCD_CreateManager ========
+ *  ======== dcd_create_manager ========
  *  Purpose:
  *      Creates DCD manager.
  */
-DSP_STATUS DCD_CreateManager(IN char *pszZlDllName,
-			    OUT struct DCD_MANAGER **phDcdMgr)
+dsp_status dcd_create_manager(IN char *pszZlDllName,
+			      OUT struct dcd_manager **phDcdMgr)
 {
-	struct COD_MANAGER *hCodMgr;	/* COD manager handle */
-	struct DCD_MANAGER *pDcdMgr = NULL;	/* DCD Manager pointer */
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs >= 0);
-	DBC_Require(phDcdMgr);
+	struct cod_manager *cod_mgr;	/* COD manager handle */
+	struct dcd_manager *dcd_mgr_obj = NULL;	/* DCD Manager pointer */
+	dsp_status status = DSP_SOK;
 
-	GT_1trace(curTrace, GT_ENTER, "DCD_CreateManager: phDcdMgr 0x%x\n",
-		 phDcdMgr);
-
-	status = COD_Create(&hCodMgr, pszZlDllName, NULL);
-	if (DSP_SUCCEEDED(status)) {
+	DBC_REQUIRE(refs >= 0);
+	DBC_REQUIRE(phDcdMgr);
 
-		/* Create a DCD object. */
-		MEM_AllocObject(pDcdMgr, struct DCD_MANAGER, SIGNATURE);
-		if (pDcdMgr != NULL) {
-
-			/* Fill out the object. */
-			pDcdMgr->hCodMgr = hCodMgr;
-
-			/* Return handle to this DCD interface. */
-			*phDcdMgr = pDcdMgr;
-
-			GT_2trace(curTrace, GT_5CLASS,
-				 "DCD_CreateManager: pDcdMgr 0x%x, "
-				 " hCodMgr 0x%x", pDcdMgr, hCodMgr);
-		} else {
-			status = DSP_EMEMORY;
+	status = cod_create(&cod_mgr, pszZlDllName, NULL);
+	if (DSP_FAILED(status))
+		goto func_end;
 
-			/*
-			 * If allocation of DcdManager object failed, delete the
-			 * COD manager.
-			 */
-			COD_Delete(hCodMgr);
+	/* Create a DCD object. */
+	MEM_ALLOC_OBJECT(dcd_mgr_obj, struct dcd_manager, SIGNATURE);
+	if (dcd_mgr_obj != NULL) {
+		/* Fill out the object. */
+		dcd_mgr_obj->cod_mgr = cod_mgr;
 
-			GT_0trace(curTrace, GT_6CLASS,
-				 "DCD_CreateManager: MEM_AllocObject failed\n");
-		}
+		/* Return handle to this DCD interface. */
+		*phDcdMgr = dcd_mgr_obj;
 	} else {
-		status = DSP_EFAIL;
-		GT_0trace(curTrace, GT_6CLASS,
-			 "DCD_CreateManager: COD_Create failed\n");
+		status = DSP_EMEMORY;
+
+		/*
+		 * If allocation of DcdManager object failed, delete the
+		 * COD manager.
+		 */
+		cod_delete(cod_mgr);
 	}
 
-	DBC_Ensure((DSP_SUCCEEDED(status)) || ((hCodMgr == NULL) &&
-		  (status == DSP_EFAIL)) || ((pDcdMgr == NULL) &&
-		  (status == DSP_EMEMORY)));
+	DBC_ENSURE((DSP_SUCCEEDED(status)) || ((cod_mgr == NULL) &&
+					       (status == DSP_EFAIL))
+		   || ((dcd_mgr_obj == NULL) && (status == DSP_EMEMORY)));
 
+func_end:
 	return status;
 }
 
 /*
- *  ======== DCD_DestroyManager ========
+ *  ======== dcd_destroy_manager ========
  *  Purpose:
  *      Frees DCD Manager object.
  */
-DSP_STATUS DCD_DestroyManager(IN struct DCD_MANAGER *hDcdMgr)
+dsp_status dcd_destroy_manager(IN struct dcd_manager *hdcd_mgr)
 {
-	struct DCD_MANAGER *pDcdMgr = hDcdMgr;
-	DSP_STATUS status = DSP_EHANDLE;
-
-	DBC_Require(cRefs >= 0);
-
-	GT_1trace(curTrace, GT_ENTER, "DCD_DestroyManager: hDcdMgr 0x%x\n",
-		 hDcdMgr);
+	struct dcd_manager *dcd_mgr_obj = hdcd_mgr;
+	dsp_status status = DSP_EHANDLE;
 
-	if (IsValidHandle(hDcdMgr)) {
+	DBC_REQUIRE(refs >= 0);
 
+	if (IS_VALID_HANDLE(hdcd_mgr)) {
 		/* Delete the COD manager. */
-		COD_Delete(pDcdMgr->hCodMgr);
+		cod_delete(dcd_mgr_obj->cod_mgr);
 
 		/* Deallocate a DCD manager object. */
-		MEM_FreeObject(pDcdMgr);
+		MEM_FREE_OBJECT(dcd_mgr_obj);
 
 		status = DSP_SOK;
-	} else {
-		GT_0trace(curTrace, GT_6CLASS,
-			 "DCD_DestroyManager: invalid DCD manager handle.\n");
 	}
 
 	return status;
 }
 
 /*
- *  ======== DCD_EnumerateObject ========
+ *  ======== dcd_enumerate_object ========
  *  Purpose:
  *      Enumerates objects in the DCD.
  */
-DSP_STATUS DCD_EnumerateObject(IN s32 cIndex, IN enum DSP_DCDOBJTYPE objType,
-			       OUT struct DSP_UUID *pUuid)
+dsp_status dcd_enumerate_object(IN s32 cIndex, IN enum dsp_dcdobjtype obj_type,
+				OUT struct dsp_uuid *uuid_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	char szRegKey[REG_MAXREGPATHLENGTH];
-	char szValue[REG_MAXREGPATHLENGTH];
-	char szData[REG_MAXREGPATHLENGTH];
-	u32 dwValueSize;
-	u32 dwDataSize;
-	struct DSP_UUID dspUuid;
-	char szObjType[MAX_INT2CHAR_LENGTH];	/* str. rep. of objType. */
-	u32 dwKeyLen = 0;
-
-	DBC_Require(cRefs >= 0);
-	DBC_Require(cIndex >= 0);
-	DBC_Require(pUuid != NULL);
-
-	GT_3trace(curTrace, GT_ENTER,
-		 "DCD_EnumerateObject: cIndex %d, objType %d, "
-		 " pUuid 0x%x\n", cIndex, objType, pUuid);
+	dsp_status status = DSP_SOK;
+	char sz_reg_key[REG_MAXREGPATHLENGTH];
+	char sz_value[REG_MAXREGPATHLENGTH];
+	char sz_data[REG_MAXREGPATHLENGTH];
+	u32 dw_value_size;
+	u32 dw_data_size;
+	struct dsp_uuid dsp_uuid_obj;
+	char sz_obj_type[MAX_INT2CHAR_LENGTH];	/* str. rep. of obj_type. */
+	u32 dw_key_len = 0;
+
+	DBC_REQUIRE(refs >= 0);
+	DBC_REQUIRE(cIndex >= 0);
+	DBC_REQUIRE(uuid_obj != NULL);
 
-	if ((cIndex != 0) && (cEnumRefs == 0)) {
+	if ((cIndex != 0) && (enum_refs == 0)) {
 		/*
 		 * If an enumeration is being performed on an index greater
-		 * than zero, then the current cEnumRefs must have been
+		 * than zero, then the current enum_refs must have been
 		 * incremented to greater than zero.
 		 */
 		status = DSP_ECHANGEDURINGENUM;
 	} else {
 		/* Enumerate a specific key in the registry by index. */
-		dwValueSize = REG_MAXREGPATHLENGTH;
-		dwDataSize = REG_MAXREGPATHLENGTH;
+		dw_value_size = REG_MAXREGPATHLENGTH;
+		dw_data_size = REG_MAXREGPATHLENGTH;
 
 		/*
 		 * Pre-determine final key length. It's length of DCD_REGKEY +
-		 *  "_\0" + length of szObjType string + terminating NULL.
+		 *  "_\0" + length of sz_obj_type string + terminating NULL.
 		 */
-               dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
-		DBC_Assert(dwKeyLen < REG_MAXREGPATHLENGTH);
+		dw_key_len = strlen(DCD_REGKEY) + 1 + sizeof(sz_obj_type) + 1;
+		DBC_ASSERT(dw_key_len < REG_MAXREGPATHLENGTH);
 
 		/* Create proper REG key; concatenate DCD_REGKEY with
-		 * objType. */
-               strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
-               if ((strlen(szRegKey) + strlen("_\0")) <
-		   REG_MAXREGPATHLENGTH) {
-                       strncat(szRegKey, "_\0", 2);
+		 * obj_type. */
+		strncpy(sz_reg_key, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+		if ((strlen(sz_reg_key) + strlen("_\0")) <
+		    REG_MAXREGPATHLENGTH) {
+			strncat(sz_reg_key, "_\0", 2);
 		} else {
 			status = DSP_EFAIL;
 		}
 
 		/* This snprintf is guaranteed not to exceed max size of an
 		 * integer. */
-		status = snprintf(szObjType, MAX_INT2CHAR_LENGTH, "%d",
-				 objType);
+		status = snprintf(sz_obj_type, MAX_INT2CHAR_LENGTH, "%d",
+				  obj_type);
 
 		if (status == -1) {
 			status = DSP_EFAIL;
 		} else {
 			status = DSP_SOK;
-                       if ((strlen(szRegKey) + strlen(szObjType)) <
-			   REG_MAXREGPATHLENGTH) {
-                               strncat(szRegKey, szObjType,
-                                          strlen(szObjType) + 1);
+			if ((strlen(sz_reg_key) + strlen(sz_obj_type)) <
+			    REG_MAXREGPATHLENGTH) {
+				strncat(sz_reg_key, sz_obj_type,
+					strlen(sz_obj_type) + 1);
 			} else {
 				status = DSP_EFAIL;
 			}
 		}
 
 		if (DSP_SUCCEEDED(status)) {
-			status = REG_EnumValue(NULL, cIndex, szRegKey, szValue,
-					      &dwValueSize, szData,
-					      &dwDataSize);
+			status = reg_enum_value(cIndex, sz_reg_key, sz_value,
+						&dw_value_size, sz_data,
+						&dw_data_size);
 		}
 
 		if (DSP_SUCCEEDED(status)) {
 			/* Create UUID value using string retrieved from
 			 * registry. */
-			UUID_UuidFromString(szValue, &dspUuid);
+			uuid_uuid_from_string(sz_value, &dsp_uuid_obj);
 
-			*pUuid = dspUuid;
+			*uuid_obj = dsp_uuid_obj;
 
-			/* Increment cEnumRefs to update reference count. */
-			cEnumRefs++;
+			/* Increment enum_refs to update reference count. */
+			enum_refs++;
 
 			status = DSP_SOK;
 		} else if (status == REG_E_NOMOREITEMS) {
-			/* At the end of enumeration. Reset cEnumRefs. */
-			cEnumRefs = 0;
+			/* At the end of enumeration. Reset enum_refs. */
+			enum_refs = 0;
 
 			status = DSP_SENUMCOMPLETE;
 		} else {
 			status = DSP_EFAIL;
-			GT_1trace(curTrace, GT_6CLASS,
-				 "DCD_EnumerateObject: REG_EnumValue"
-				 " failed, status = 0x%x\n", status);
 		}
 	}
 
-	DBC_Ensure(pUuid || (status == DSP_EFAIL));
+	DBC_ENSURE(uuid_obj || (status == DSP_EFAIL));
 
 	return status;
 }
 
 /*
- *  ======== DCD_Exit ========
+ *  ======== dcd_exit ========
  *  Purpose:
  *      Discontinue usage of the DCD module.
  */
-void DCD_Exit(void)
+void dcd_exit(void)
 {
-	DBC_Require(cRefs > 0);
-
-	GT_1trace(curTrace, GT_5CLASS, "DCD_Exit: cRefs 0x%x\n", cRefs);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
-	if (cRefs == 0) {
-		REG_Exit();
-		COD_Exit();
-		MEM_Exit();
-	}
+	refs--;
+	if (refs == 0)
+		cod_exit();
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== DCD_GetDepLibs ========
+ *  ======== dcd_get_dep_libs ========
  */
-DSP_STATUS DCD_GetDepLibs(IN struct DCD_MANAGER *hDcdMgr,
-			 IN struct DSP_UUID *pUuid,
-			 u16 numLibs, OUT struct DSP_UUID *pDepLibUuids,
-			 OUT bool *pPersistentDepLibs, IN enum NLDR_PHASE phase)
+dsp_status dcd_get_dep_libs(IN struct dcd_manager *hdcd_mgr,
+			    IN struct dsp_uuid *uuid_obj,
+			    u16 numLibs, OUT struct dsp_uuid *pDepLibUuids,
+			    OUT bool *pPersistentDepLibs,
+			    IN enum nldr_phase phase)
 {
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValidHandle(hDcdMgr));
-	DBC_Require(pUuid != NULL);
-	DBC_Require(pDepLibUuids != NULL);
-	DBC_Require(pPersistentDepLibs != NULL);
+	dsp_status status = DSP_SOK;
 
-	GT_1trace(curTrace, GT_ENTER, "DCD_GetDepLibs: hDcdMgr 0x%x\n",
-		 hDcdMgr);
-
-	status = GetDepLibInfo(hDcdMgr, pUuid, &numLibs, NULL, pDepLibUuids,
-			      pPersistentDepLibs, phase);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID_HANDLE(hdcd_mgr));
+	DBC_REQUIRE(uuid_obj != NULL);
+	DBC_REQUIRE(pDepLibUuids != NULL);
+	DBC_REQUIRE(pPersistentDepLibs != NULL);
+
+	status =
+	    get_dep_lib_info(hdcd_mgr, uuid_obj, &numLibs, NULL, pDepLibUuids,
+			     pPersistentDepLibs, phase);
 
 	return status;
 }
 
 /*
- *  ======== DCD_GetNumDepLibs ========
+ *  ======== dcd_get_num_dep_libs ========
  */
-DSP_STATUS DCD_GetNumDepLibs(IN struct DCD_MANAGER *hDcdMgr,
-			    IN struct DSP_UUID *pUuid, OUT u16 *pNumLibs,
-			    OUT u16 *pNumPersLibs, IN enum NLDR_PHASE phase)
+dsp_status dcd_get_num_dep_libs(IN struct dcd_manager *hdcd_mgr,
+				IN struct dsp_uuid *uuid_obj,
+				OUT u16 *pNumLibs, OUT u16 *pNumPersLibs,
+				IN enum nldr_phase phase)
 {
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(IsValidHandle(hDcdMgr));
-	DBC_Require(pNumLibs != NULL);
-	DBC_Require(pNumPersLibs != NULL);
-	DBC_Require(pUuid != NULL);
+	dsp_status status = DSP_SOK;
 
-	GT_1trace(curTrace, GT_ENTER, "DCD_GetNumDepLibs: hDcdMgr 0x%x\n",
-		 hDcdMgr);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(IS_VALID_HANDLE(hdcd_mgr));
+	DBC_REQUIRE(pNumLibs != NULL);
+	DBC_REQUIRE(pNumPersLibs != NULL);
+	DBC_REQUIRE(uuid_obj != NULL);
 
-	status = GetDepLibInfo(hDcdMgr, pUuid, pNumLibs, pNumPersLibs,
-			      NULL, NULL, phase);
+	status = get_dep_lib_info(hdcd_mgr, uuid_obj, pNumLibs, pNumPersLibs,
+				  NULL, NULL, phase);
 
 	return status;
 }
 
 /*
- *  ======== DCD_GetObjectDef ========
+ *  ======== dcd_get_object_def ========
  *  Purpose:
  *      Retrieves the properties of a node or processor based on the UUID and
  *      object type.
  */
-DSP_STATUS DCD_GetObjectDef(IN struct DCD_MANAGER *hDcdMgr,
-			   IN struct DSP_UUID *pObjUuid,
-			   IN enum DSP_DCDOBJTYPE objType,
-			   OUT struct DCD_GENERICOBJ *pObjDef)
+dsp_status dcd_get_object_def(IN struct dcd_manager *hdcd_mgr,
+			      IN struct dsp_uuid *pObjUuid,
+			      IN enum dsp_dcdobjtype obj_type,
+			      OUT struct dcd_genericobj *pObjDef)
 {
-	struct DCD_MANAGER *pDcdMgr = hDcdMgr;	/* pointer to DCD manager */
-	struct COD_LIBRARYOBJ *lib = NULL;
-	DSP_STATUS status = DSP_SOK;
-	u32 ulAddr = 0;	/* Used by COD_GetSection */
-	u32 ulLen = 0;	/* Used by COD_GetSection */
-	u32 dwBufSize;	/* Used by REG functions */
-	char szRegKey[REG_MAXREGPATHLENGTH];
-	char *szUuid;		/*[MAXUUIDLEN];*/
-	char szRegData[REG_MAXREGPATHLENGTH];
-	char szSectName[MAXUUIDLEN + 2];	/* ".[UUID]\0" */
-	char *pszCoffBuf;
-	u32 dwKeyLen;		/* Len of REG key. */
-	char szObjType[MAX_INT2CHAR_LENGTH];	/* str. rep. of objType. */
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pObjDef != NULL);
-	DBC_Require(pObjUuid != NULL);
-
-	GT_4trace(curTrace, GT_ENTER,
-		 "DCD_GetObjectDef: hDcdMgr 0x%x, " "objUuid"
-		 " 0x%x, objType 0x%x, pObjDef 0x%x\n", hDcdMgr, pObjUuid,
-		 objType, pObjDef);
-	szUuid = (char *)MEM_Calloc(MAXUUIDLEN, MEM_PAGED);
-	if (!szUuid)
-		return status = DSP_EMEMORY;
+	struct dcd_manager *dcd_mgr_obj = hdcd_mgr;	/* ptr to DCD mgr */
+	struct cod_libraryobj *lib = NULL;
+	dsp_status status = DSP_SOK;
+	u32 ul_addr = 0;	/* Used by cod_get_section */
+	u32 ul_len = 0;		/* Used by cod_get_section */
+	u32 dw_buf_size;	/* Used by REG functions */
+	char sz_reg_key[REG_MAXREGPATHLENGTH];
+	char *sz_uuid;		/*[MAXUUIDLEN]; */
+	char sz_reg_data[REG_MAXREGPATHLENGTH];
+	char sz_sect_name[MAXUUIDLEN + 2];	/* ".[UUID]\0" */
+	char *psz_coff_buf;
+	u32 dw_key_len;		/* Len of REG key. */
+	char sz_obj_type[MAX_INT2CHAR_LENGTH];	/* str. rep. of obj_type. */
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pObjDef != NULL);
+	DBC_REQUIRE(pObjUuid != NULL);
 
-	if (!IsValidHandle(hDcdMgr)) {
+	sz_uuid = (char *)mem_calloc(MAXUUIDLEN, MEM_PAGED);
+	if (!sz_uuid) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+
+	if (!IS_VALID_HANDLE(hdcd_mgr)) {
 		status = DSP_EHANDLE;
-		GT_0trace(curTrace, GT_6CLASS, "DCD_GetObjectDef: invalid "
-			 "DCD manager handle.\n");
 		goto func_end;
 	}
-	 /* Pre-determine final key length. It's length of DCD_REGKEY +
-	 *  "_\0" + length of szObjType string + terminating NULL */
-       dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
-	DBC_Assert(dwKeyLen < REG_MAXREGPATHLENGTH);
-	/* Create proper REG key; concatenate DCD_REGKEY with objType. */
-       strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
 
-       if ((strlen(szRegKey) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
-               strncat(szRegKey, "_\0", 2);
+	/* Pre-determine final key length. It's length of DCD_REGKEY +
+	 *  "_\0" + length of sz_obj_type string + terminating NULL */
+	dw_key_len = strlen(DCD_REGKEY) + 1 + sizeof(sz_obj_type) + 1;
+	DBC_ASSERT(dw_key_len < REG_MAXREGPATHLENGTH);
+
+	/* Create proper REG key; concatenate DCD_REGKEY with obj_type. */
+	strncpy(sz_reg_key, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+
+	if ((strlen(sz_reg_key) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
+		strncat(sz_reg_key, "_\0", 2);
 	else
 		status = DSP_EFAIL;
 
-	status = snprintf(szObjType, MAX_INT2CHAR_LENGTH, "%d", objType);
+	status = snprintf(sz_obj_type, MAX_INT2CHAR_LENGTH, "%d", obj_type);
 	if (status == -1) {
 		status = DSP_EFAIL;
 	} else {
 		status = DSP_SOK;
 
-               if ((strlen(szRegKey) + strlen(szObjType)) <
-		   REG_MAXREGPATHLENGTH) {
-                       strncat(szRegKey, szObjType, strlen(szObjType) + 1);
+		if ((strlen(sz_reg_key) + strlen(sz_obj_type)) <
+		    REG_MAXREGPATHLENGTH) {
+			strncat(sz_reg_key, sz_obj_type,
+				strlen(sz_obj_type) + 1);
 		} else {
 			status = DSP_EFAIL;
 		}
+
 		/* Create UUID value to set in registry. */
-		UUID_UuidToString(pObjUuid, szUuid, MAXUUIDLEN);
+		uuid_uuid_to_string(pObjUuid, sz_uuid, MAXUUIDLEN);
 
-               if ((strlen(szRegKey) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
-                       strncat(szRegKey, szUuid, MAXUUIDLEN);
-               else
+		if ((strlen(sz_reg_key) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
+			strncat(sz_reg_key, sz_uuid, MAXUUIDLEN);
+		else
 			status = DSP_EFAIL;
 
-		/* Retrieve paths from the registry based on struct DSP_UUID */
-		dwBufSize = REG_MAXREGPATHLENGTH;
-	}
-	if (DSP_SUCCEEDED(status)) {
-		status = REG_GetValue(NULL, szRegKey, szRegKey, (u8 *)szRegData,
-				     &dwBufSize);
+		/* Retrieve paths from the registry based on struct dsp_uuid */
+		dw_buf_size = REG_MAXREGPATHLENGTH;
 	}
+	if (DSP_SUCCEEDED(status))
+		status =
+		    reg_get_value(sz_reg_key, (u8 *) sz_reg_data, &dw_buf_size);
+
 	if (DSP_FAILED(status)) {
 		status = DSP_EUUID;
-		GT_0trace(curTrace, GT_6CLASS, "DCD_GetObjectDef: "
-			 "REG_GetValue() failed\n");
 		goto func_end;
 	}
+
 	/* Open COFF file. */
-	status = COD_Open(pDcdMgr->hCodMgr, szRegData, COD_NOLOAD, &lib);
+	status = cod_open(dcd_mgr_obj->cod_mgr, sz_reg_data, COD_NOLOAD, &lib);
 	if (DSP_FAILED(status)) {
 		status = DSP_EDCDLOADBASE;
-		GT_0trace(curTrace, GT_6CLASS, "DCD_GetObjectDef: "
-			 "COD_OpenBase() failed\n");
 		goto func_end;
 	}
-	/* Ensure szUuid + 1 is not greater than sizeof szSectName. */
-       DBC_Assert((strlen(szUuid) + 1) < sizeof(szSectName));
+
+	/* Ensure sz_uuid + 1 is not greater than sizeof sz_sect_name. */
+	DBC_ASSERT((strlen(sz_uuid) + 1) < sizeof(sz_sect_name));
+
 	/* Create section name based on node UUID. A period is
 	 * pre-pended to the UUID string to form the section name.
 	 * I.e. ".24BC8D90_BB45_11d4_B756_006008BDB66F" */
-       strncpy(szSectName, ".", 2);
-       strncat(szSectName, szUuid, strlen(szUuid));
+	strncpy(sz_sect_name, ".", 2);
+	strncat(sz_sect_name, sz_uuid, strlen(sz_uuid));
+
 	/* Get section information. */
-	status = COD_GetSection(lib, szSectName, &ulAddr, &ulLen);
+	status = cod_get_section(lib, sz_sect_name, &ul_addr, &ul_len);
 	if (DSP_FAILED(status)) {
 		status = DSP_EDCDGETSECT;
-		GT_0trace(curTrace, GT_6CLASS, "DCD_GetObjectDef:"
-			 " COD_GetSection() failed\n");
 		goto func_end;
 	}
+
 	/* Allocate zeroed buffer. */
-	pszCoffBuf = MEM_Calloc(ulLen + 4, MEM_PAGED);
+	psz_coff_buf = mem_calloc(ul_len + 4, MEM_PAGED);
 #ifdef _DB_TIOMAP
-       if (strstr(szRegData, "iva") == NULL) {
+	if (strstr(sz_reg_data, "iva") == NULL) {
 		/* Locate section by objectID and read its content. */
-		status = COD_ReadSection(lib, szSectName, pszCoffBuf, ulLen);
+		status =
+		    cod_read_section(lib, sz_sect_name, psz_coff_buf, ul_len);
 	} else {
-		status = COD_ReadSection(lib, szSectName, pszCoffBuf, ulLen);
-		GT_0trace(curTrace, GT_4CLASS,
-			 "Skipped Byte swap for IVA !!\n");
+		status =
+		    cod_read_section(lib, sz_sect_name, psz_coff_buf, ul_len);
+		dev_dbg(bridge, "%s: Skipped Byte swap for IVA!!\n", __func__);
 	}
 #else
-	status = COD_ReadSection(lib, szSectName, pszCoffBuf, ulLen);
+	status = cod_read_section(lib, sz_sect_name, psz_coff_buf, ul_len);
 #endif
 	if (DSP_SUCCEEDED(status)) {
 		/* Compres DSP buffer to conform to PC format. */
-               if (strstr(szRegData, "iva") == NULL) {
-			CompressBuf(pszCoffBuf, ulLen, DSPWORDSIZE);
+		if (strstr(sz_reg_data, "iva") == NULL) {
+			compress_buf(psz_coff_buf, ul_len, DSPWORDSIZE);
 		} else {
-			CompressBuf(pszCoffBuf, ulLen, 1);
-			GT_0trace(curTrace, GT_4CLASS, "Compressing IVA "
-				 "COFF buffer by 1 for IVA !!\n");
+			compress_buf(psz_coff_buf, ul_len, 1);
+			dev_dbg(bridge, "%s: Compressing IVA COFF buffer by 1 "
+				"for IVA!!\n", __func__);
 		}
+
 		/* Parse the content of the COFF buffer. */
-		status = GetAttrsFromBuf(pszCoffBuf, ulLen, objType, pObjDef);
-		if (DSP_FAILED(status)) {
+		status =
+		    get_attrs_from_buf(psz_coff_buf, ul_len, obj_type, pObjDef);
+		if (DSP_FAILED(status))
 			status = DSP_EDCDPARSESECT;
-			GT_0trace(curTrace, GT_6CLASS, "DCD_GetObjectDef: "
-				 "GetAttrsFromBuf() failed\n");
-		}
 	} else {
 		status = DSP_EDCDREADSECT;
-		GT_0trace(curTrace, GT_6CLASS, "DCD_GetObjectDef: "
-			 "COD_ReadSection() failed\n");
 	}
+
 	/* Free the previously allocated dynamic buffer. */
-	MEM_Free(pszCoffBuf);
+	kfree(psz_coff_buf);
 func_end:
 	if (lib)
-		COD_Close(lib);
+		cod_close(lib);
+
+	kfree(sz_uuid);
 
-	if (szUuid)
-		MEM_Free(szUuid);
 	return status;
 }
 
 /*
- *  ======== DCD_GetObjects ========
+ *  ======== dcd_get_objects ========
  */
-DSP_STATUS DCD_GetObjects(IN struct DCD_MANAGER *hDcdMgr, IN char *pszCoffPath,
-			 DCD_REGISTERFXN registerFxn, void *handle)
+dsp_status dcd_get_objects(IN struct dcd_manager *hdcd_mgr,
+			   IN char *pszCoffPath, dcd_registerfxn registerFxn,
+			   void *handle)
 {
-	struct DCD_MANAGER *pDcdMgr = hDcdMgr;	/* pointer to DCD manager */
-	DSP_STATUS status = DSP_SOK;
-	char *pszCoffBuf;
-	char *pszCur;
-	struct COD_LIBRARYOBJ *lib = NULL;
-	u32 ulAddr = 0;	/* Used by COD_GetSection */
-	u32 ulLen = 0;	/* Used by COD_GetSection */
+	struct dcd_manager *dcd_mgr_obj = hdcd_mgr;
+	dsp_status status = DSP_SOK;
+	char *psz_coff_buf;
+	char *psz_cur;
+	struct cod_libraryobj *lib = NULL;
+	u32 ul_addr = 0;	/* Used by cod_get_section */
+	u32 ul_len = 0;		/* Used by cod_get_section */
 	char seps[] = ":, ";
-	char *pToken = NULL;
-	struct DSP_UUID dspUuid;
-	s32 cObjectType;
-
-	DBC_Require(cRefs > 0);
-	GT_1trace(curTrace, GT_ENTER,
-		 "DCD_GetObjects: hDcdMgr 0x%x\n", hDcdMgr);
-	if (!IsValidHandle(hDcdMgr)) {
+	char *token = NULL;
+	struct dsp_uuid dsp_uuid_obj;
+	s32 object_type;
+
+	DBC_REQUIRE(refs > 0);
+	if (!IS_VALID_HANDLE(hdcd_mgr)) {
 		status = DSP_EHANDLE;
-		GT_0trace(curTrace, GT_6CLASS,
-			 "DCD_GetObjects: invalid DCD manager handle.\n");
 		goto func_end;
 	}
+
 	/* Open DSP coff file, don't load symbols. */
-	status = COD_Open(pDcdMgr->hCodMgr, pszCoffPath, COD_NOLOAD, &lib);
+	status = cod_open(dcd_mgr_obj->cod_mgr, pszCoffPath, COD_NOLOAD, &lib);
 	if (DSP_FAILED(status)) {
 		status = DSP_EDCDLOADBASE;
-		GT_0trace(curTrace, GT_6CLASS,
-			 "DCD_AutoRegister: COD_Open() failed\n");
 		goto func_cont;
 	}
+
 	/* Get DCD_RESIGER_SECTION section information. */
-	status = COD_GetSection(lib, DCD_REGISTER_SECTION, &ulAddr, &ulLen);
-	if (DSP_FAILED(status) ||  !(ulLen > 0)) {
+	status = cod_get_section(lib, DCD_REGISTER_SECTION, &ul_addr, &ul_len);
+	if (DSP_FAILED(status) || !(ul_len > 0)) {
 		status = DSP_EDCDNOAUTOREGISTER;
-		GT_0trace(curTrace, GT_6CLASS,
-			 "DCD_GetObjects: COD_GetSection() "
-			 "- no auto register section\n");
 		goto func_cont;
 	}
+
 	/* Allocate zeroed buffer. */
-	pszCoffBuf = MEM_Calloc(ulLen + 4, MEM_PAGED);
+	psz_coff_buf = mem_calloc(ul_len + 4, MEM_PAGED);
 #ifdef _DB_TIOMAP
 	if (strstr(pszCoffPath, "iva") == NULL) {
 		/* Locate section by objectID and read its content. */
-		status = COD_ReadSection(lib, DCD_REGISTER_SECTION,
-					pszCoffBuf, ulLen);
+		status = cod_read_section(lib, DCD_REGISTER_SECTION,
+					  psz_coff_buf, ul_len);
 	} else {
-		GT_0trace(curTrace, GT_4CLASS, "Skipped Byte swap for IVA!!\n");
-		status = COD_ReadSection(lib, DCD_REGISTER_SECTION,
-					pszCoffBuf, ulLen);
+		dev_dbg(bridge, "%s: Skipped Byte swap for IVA!!\n", __func__);
+		status = cod_read_section(lib, DCD_REGISTER_SECTION,
+					  psz_coff_buf, ul_len);
 	}
 #else
-	status = COD_ReadSection(lib, DCD_REGISTER_SECTION, pszCoffBuf, ulLen);
+	status =
+	    cod_read_section(lib, DCD_REGISTER_SECTION, psz_coff_buf, ul_len);
 #endif
 	if (DSP_SUCCEEDED(status)) {
 		/* Compress DSP buffer to conform to PC format. */
-		GT_0trace(curTrace, GT_4CLASS,
-			 "Successfully read section !!\n");
 		if (strstr(pszCoffPath, "iva") == NULL) {
-			CompressBuf(pszCoffBuf, ulLen, DSPWORDSIZE);
+			compress_buf(psz_coff_buf, ul_len, DSPWORDSIZE);
 		} else {
-			CompressBuf(pszCoffBuf, ulLen, 1);
-			GT_0trace(curTrace, GT_4CLASS, "Compress COFF buffer "
-				 "with 1 word for IVA !!\n");
+			compress_buf(psz_coff_buf, ul_len, 1);
+			dev_dbg(bridge, "%s: Compress COFF buffer with 1 word "
+				"for IVA!!\n", __func__);
 		}
+
 		/* Read from buffer and register object in buffer. */
-		pszCur = pszCoffBuf;
-		while ((pToken = strsep(&pszCur, seps)) && *pToken != '\0') {
+		psz_cur = psz_coff_buf;
+		while ((token = strsep(&psz_cur, seps)) && *token != '\0') {
 			/*  Retrieve UUID string. */
-			UUID_UuidFromString(pToken, &dspUuid);
+			uuid_uuid_from_string(token, &dsp_uuid_obj);
+
 			/*  Retrieve object type */
-			pToken = strsep(&pszCur, seps);
+			token = strsep(&psz_cur, seps);
+
 			/*  Retrieve object type */
-			cObjectType = Atoi(pToken);
+			object_type = atoi(token);
+
 			/*
 			 *  Apply registerFxn to the found DCD object.
 			 *  Possible actions include:
@@ -698,294 +598,254 @@
 			 *  2) Unregister found DCD object (when handle == NULL)
 			 *  3) Add overlay node.
 			 */
-			GT_1trace(curTrace, GT_4CLASS, "Registering objtype "
-				 "%d \n", cObjectType);
-			status = registerFxn(&dspUuid, cObjectType, handle);
-			if (DSP_SUCCEEDED(status)) {
-				GT_1trace(curTrace, GT_5CLASS,
-					 "DCD_GetObjects: status 0x%x\n",
-					 status);
-			} else {
-				GT_0trace(curTrace, GT_6CLASS,
-					 "DCD_GetObjects: "
-					 "registration() failed\n");
+			status =
+			    registerFxn(&dsp_uuid_obj, object_type, handle);
+			if (DSP_FAILED(status)) {
 				/* if error occurs, break from while loop. */
 				break;
 			}
 		}
 	} else {
 		status = DSP_EDCDREADSECT;
-		GT_0trace(curTrace, GT_6CLASS, "DCD_GetObjects: "
-			 "COD_ReadSection() failed\n");
 	}
+
 	/* Free the previously allocated dynamic buffer. */
-	MEM_Free(pszCoffBuf);
+	kfree(psz_coff_buf);
 func_cont:
 	if (lib)
-		COD_Close(lib);
+		cod_close(lib);
 
 func_end:
 	return status;
 }
 
 /*
- *  ======== DCD_GetLibraryName ========
+ *  ======== dcd_get_library_name ========
  *  Purpose:
  *      Retrieves the library name for the given UUID.
  *
  */
-DSP_STATUS DCD_GetLibraryName(IN struct DCD_MANAGER *hDcdMgr,
-			     IN struct DSP_UUID *pUuid,
-			     IN OUT char *pstrLibName, IN OUT u32 *pdwSize,
-			     enum NLDR_PHASE phase, OUT bool *fPhaseSplit)
+dsp_status dcd_get_library_name(IN struct dcd_manager *hdcd_mgr,
+				IN struct dsp_uuid *uuid_obj,
+				IN OUT char *pstrLibName, IN OUT u32 * pdwSize,
+				enum nldr_phase phase, OUT bool *phase_split)
 {
-	char szRegKey[REG_MAXREGPATHLENGTH];
-	char szUuid[MAXUUIDLEN];
-	u32 dwKeyLen;		/* Len of REG key. */
-	char szObjType[MAX_INT2CHAR_LENGTH];	/* str. rep. of objType. */
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(pUuid != NULL);
-	DBC_Require(pstrLibName != NULL);
-	DBC_Require(pdwSize != NULL);
-	DBC_Require(IsValidHandle(hDcdMgr));
-
-	GT_4trace(curTrace, GT_ENTER,
-		 "DCD_GetLibraryName: hDcdMgr 0x%x, pUuid 0x%x, "
-		 " pstrLibName 0x%x, pdwSize 0x%x\n", hDcdMgr, pUuid,
-		 pstrLibName, pdwSize);
+	char sz_reg_key[REG_MAXREGPATHLENGTH];
+	char sz_uuid[MAXUUIDLEN];
+	u32 dw_key_len;		/* Len of REG key. */
+	char sz_obj_type[MAX_INT2CHAR_LENGTH];	/* str. rep. of obj_type. */
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(uuid_obj != NULL);
+	DBC_REQUIRE(pstrLibName != NULL);
+	DBC_REQUIRE(pdwSize != NULL);
+	DBC_REQUIRE(IS_VALID_HANDLE(hdcd_mgr));
+
+	dev_dbg(bridge, "%s: hdcd_mgr %p, uuid_obj %p, pstrLibName %p, pdwSize "
+		"%p\n", __func__, hdcd_mgr, uuid_obj, pstrLibName, pdwSize);
+
 	/*
 	 *  Pre-determine final key length. It's length of DCD_REGKEY +
-	 *  "_\0" + length of szObjType string + terminating NULL.
+	 *  "_\0" + length of sz_obj_type string + terminating NULL.
 	 */
-       dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
-	DBC_Assert(dwKeyLen < REG_MAXREGPATHLENGTH);
-	/* Create proper REG key; concatenate DCD_REGKEY with objType. */
-       strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
-       if ((strlen(szRegKey) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
-               strncat(szRegKey, "_\0", 2);
+	dw_key_len = strlen(DCD_REGKEY) + 1 + sizeof(sz_obj_type) + 1;
+	DBC_ASSERT(dw_key_len < REG_MAXREGPATHLENGTH);
+
+	/* Create proper REG key; concatenate DCD_REGKEY with obj_type. */
+	strncpy(sz_reg_key, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+	if ((strlen(sz_reg_key) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
+		strncat(sz_reg_key, "_\0", 2);
 	else
 		status = DSP_EFAIL;
 
 	switch (phase) {
 	case NLDR_CREATE:
 		/* create phase type */
-		sprintf(szObjType, "%d", DSP_DCDCREATELIBTYPE);
+		sprintf(sz_obj_type, "%d", DSP_DCDCREATELIBTYPE);
 		break;
 	case NLDR_EXECUTE:
 		/* execute phase type */
-		sprintf(szObjType, "%d", DSP_DCDEXECUTELIBTYPE);
+		sprintf(sz_obj_type, "%d", DSP_DCDEXECUTELIBTYPE);
 		break;
 	case NLDR_DELETE:
 		/* delete phase type */
-		sprintf(szObjType, "%d", DSP_DCDDELETELIBTYPE);
+		sprintf(sz_obj_type, "%d", DSP_DCDDELETELIBTYPE);
 		break;
 	case NLDR_NOPHASE:
 		/* known to be a dependent library */
-		sprintf(szObjType, "%d", DSP_DCDLIBRARYTYPE);
+		sprintf(sz_obj_type, "%d", DSP_DCDLIBRARYTYPE);
 		break;
 	default:
-		status = -1;
-		DBC_Assert(false);
+		status = DSP_EINVALIDARG;
+		DBC_ASSERT(false);
 	}
-	if (status == -1) {
-		status = DSP_EFAIL;
-	} else {
-		status = DSP_SOK;
-               if ((strlen(szRegKey) + strlen(szObjType))
-		   < REG_MAXREGPATHLENGTH) {
-                       strncat(szRegKey, szObjType, strlen(szObjType) + 1);
+	if (DSP_SUCCEEDED(status)) {
+		if ((strlen(sz_reg_key) + strlen(sz_obj_type)) <
+		    REG_MAXREGPATHLENGTH) {
+			strncat(sz_reg_key, sz_obj_type,
+				strlen(sz_obj_type) + 1);
 		} else {
 			status = DSP_EFAIL;
 		}
 		/* Create UUID value to find match in registry. */
-		UUID_UuidToString(pUuid, szUuid, MAXUUIDLEN);
-               if ((strlen(szRegKey) + MAXUUIDLEN) <
-		   REG_MAXREGPATHLENGTH) {
-                       strncat(szRegKey, szUuid, MAXUUIDLEN);
-		} else {
+		uuid_uuid_to_string(uuid_obj, sz_uuid, MAXUUIDLEN);
+		if ((strlen(sz_reg_key) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
+			strncat(sz_reg_key, sz_uuid, MAXUUIDLEN);
+		else
 			status = DSP_EFAIL;
-		}
 	}
 	if (DSP_SUCCEEDED(status)) {
-		/* Retrieve path from the registry based on DSP_UUID */
-		status = REG_GetValue(NULL, szRegKey, szRegKey,
-					(u8 *)pstrLibName, pdwSize);
+		/* Retrieve path from the registry based on dsp_uuid */
+		status = reg_get_value(sz_reg_key, (u8 *) pstrLibName, pdwSize);
 	}
+
 	/* If can't find, phases might be registered as generic LIBRARYTYPE */
 	if (DSP_FAILED(status) && phase != NLDR_NOPHASE) {
-		if (fPhaseSplit)
-			*fPhaseSplit = false;
+		if (phase_split)
+			*phase_split = false;
 
-               strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
-               if ((strlen(szRegKey) + strlen("_\0")) <
-		   REG_MAXREGPATHLENGTH) {
-                       strncat(szRegKey, "_\0", 2);
+		strncpy(sz_reg_key, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+		if ((strlen(sz_reg_key) + strlen("_\0")) <
+		    REG_MAXREGPATHLENGTH) {
+			strncat(sz_reg_key, "_\0", 2);
 		} else {
 			status = DSP_EFAIL;
 		}
-		sprintf(szObjType, "%d", DSP_DCDLIBRARYTYPE);
-               if ((strlen(szRegKey) + strlen(szObjType))
-		   < REG_MAXREGPATHLENGTH) {
-                       strncat(szRegKey, szObjType, strlen(szObjType) + 1);
+		sprintf(sz_obj_type, "%d", DSP_DCDLIBRARYTYPE);
+		if ((strlen(sz_reg_key) + strlen(sz_obj_type))
+		    < REG_MAXREGPATHLENGTH) {
+			strncat(sz_reg_key, sz_obj_type,
+				strlen(sz_obj_type) + 1);
 		} else {
 			status = DSP_EFAIL;
 		}
-		UUID_UuidToString(pUuid, szUuid, MAXUUIDLEN);
-               if ((strlen(szRegKey) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
-                       strncat(szRegKey, szUuid, MAXUUIDLEN);
-               else
+		uuid_uuid_to_string(uuid_obj, sz_uuid, MAXUUIDLEN);
+		if ((strlen(sz_reg_key) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
+			strncat(sz_reg_key, sz_uuid, MAXUUIDLEN);
+		else
 			status = DSP_EFAIL;
 
-		status = REG_GetValue(NULL, szRegKey, szRegKey,
-					(u8 *)pstrLibName, pdwSize);
+		status = reg_get_value(sz_reg_key, (u8 *) pstrLibName, pdwSize);
 	}
 
 	return status;
 }
 
 /*
- *  ======== DCD_Init ========
+ *  ======== dcd_init ========
  *  Purpose:
  *      Initialize the DCD module.
  */
-bool DCD_Init(void)
+bool dcd_init(void)
 {
-	bool fInitMEM;
-	bool fInitREG;
-	bool fInitCOD;
-	bool fInit = true;
+	bool init_cod;
+	bool ret = true;
 
-	DBC_Require(cRefs >= 0);
-
-	GT_1trace(curTrace, GT_ENTER, "DCD_Init: (on enter) cRefs = 0x%x\n",
-		 cRefs);
-
-	if (cRefs == 0) {
+	DBC_REQUIRE(refs >= 0);
 
+	if (refs == 0) {
 		/* Initialize required modules. */
-		fInitMEM = MEM_Init();
-		fInitCOD = COD_Init();
-		fInitREG = REG_Init();
-		if (!fInitMEM || !fInitCOD || !fInitREG) {
-			fInit = false;
-			GT_0trace(curTrace, GT_6CLASS, "DCD_Init failed\n");
-			/* Exit initialized modules. */
-			if (fInitMEM)
-				MEM_Exit();
-
-			if (fInitCOD)
-				COD_Exit();
-
-			if (fInitREG)
-				REG_Exit();
+		init_cod = cod_init();
 
+		if (!init_cod) {
+			ret = false;
+			/* Exit initialized modules. */
+			if (init_cod)
+				cod_exit();
 		}
 	}
 
-	if (fInit)
-		cRefs++;
-
+	if (ret)
+		refs++;
 
-	GT_1trace(curTrace, GT_5CLASS, "DCD_Init: (on exit) cRefs = 0x%x\n",
-		 cRefs);
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs == 0)));
 
-	DBC_Ensure((fInit && (cRefs > 0)) || (!fInit && (cRefs == 0)));
-
-	return fInit;
+	return ret;
 }
 
 /*
- *  ======== DCD_RegisterObject ========
+ *  ======== dcd_register_object ========
  *  Purpose:
  *      Registers a node or a processor with the DCD.
- *      If pszPathName == NULL, unregister the specified DCD object.
+ *      If psz_path_name == NULL, unregister the specified DCD object.
  */
-DSP_STATUS DCD_RegisterObject(IN struct DSP_UUID *pUuid,
-			     IN enum DSP_DCDOBJTYPE objType,
-			     IN char *pszPathName)
+dsp_status dcd_register_object(IN struct dsp_uuid *uuid_obj,
+			       IN enum dsp_dcdobjtype obj_type,
+			       IN char *psz_path_name)
 {
-	DSP_STATUS status = DSP_SOK;
-	char szRegKey[REG_MAXREGPATHLENGTH];
-	char szUuid[MAXUUIDLEN + 1];
-	u32 dwPathSize = 0;
-	u32 dwKeyLen;		/* Len of REG key. */
-	char szObjType[MAX_INT2CHAR_LENGTH];	/* str. rep. of objType. */
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pUuid != NULL);
-	DBC_Require((objType == DSP_DCDNODETYPE) ||
-		   (objType == DSP_DCDPROCESSORTYPE) ||
-		   (objType == DSP_DCDLIBRARYTYPE) ||
-		   (objType == DSP_DCDCREATELIBTYPE) ||
-		   (objType == DSP_DCDEXECUTELIBTYPE) ||
-		   (objType == DSP_DCDDELETELIBTYPE));
+	dsp_status status = DSP_SOK;
+	char sz_reg_key[REG_MAXREGPATHLENGTH];
+	char sz_uuid[MAXUUIDLEN + 1];
+	u32 dw_path_size = 0;
+	u32 dw_key_len;		/* Len of REG key. */
+	char sz_obj_type[MAX_INT2CHAR_LENGTH];	/* str. rep. of obj_type. */
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(uuid_obj != NULL);
+	DBC_REQUIRE((obj_type == DSP_DCDNODETYPE) ||
+		    (obj_type == DSP_DCDPROCESSORTYPE) ||
+		    (obj_type == DSP_DCDLIBRARYTYPE) ||
+		    (obj_type == DSP_DCDCREATELIBTYPE) ||
+		    (obj_type == DSP_DCDEXECUTELIBTYPE) ||
+		    (obj_type == DSP_DCDDELETELIBTYPE));
+
+	dev_dbg(bridge, "%s: object UUID %p, obj_type %d, szPathName %s\n",
+		__func__, uuid_obj, obj_type, psz_path_name);
 
-	GT_3trace(curTrace, GT_ENTER, "DCD_RegisterObject: object UUID 0x%x, "
-		 "objType %d, szPathName %s\n", pUuid, objType, pszPathName);
 	/*
 	 * Pre-determine final key length. It's length of DCD_REGKEY +
-	 *  "_\0" + length of szObjType string + terminating NULL.
+	 *  "_\0" + length of sz_obj_type string + terminating NULL.
 	 */
-       dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
-	DBC_Assert(dwKeyLen < REG_MAXREGPATHLENGTH);
-	/* Create proper REG key; concatenate DCD_REGKEY with objType. */
-       strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
-       if ((strlen(szRegKey) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
-               strncat(szRegKey, "_\0", 2);
-	else
+	dw_key_len = strlen(DCD_REGKEY) + 1 + sizeof(sz_obj_type) + 1;
+	DBC_ASSERT(dw_key_len < REG_MAXREGPATHLENGTH);
+
+	/* Create proper REG key; concatenate DCD_REGKEY with obj_type. */
+	strncpy(sz_reg_key, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+	if ((strlen(sz_reg_key) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
+		strncat(sz_reg_key, "_\0", 2);
+	else {
 		status = DSP_EFAIL;
+		goto func_end;
+	}
 
-	status = snprintf(szObjType, MAX_INT2CHAR_LENGTH, "%d", objType);
+	status = snprintf(sz_obj_type, MAX_INT2CHAR_LENGTH, "%d", obj_type);
 	if (status == -1) {
 		status = DSP_EFAIL;
 	} else {
 		status = DSP_SOK;
-               if ((strlen(szRegKey) + strlen(szObjType)) <
-		   REG_MAXREGPATHLENGTH) {
-                       strncat(szRegKey, szObjType, strlen(szObjType) + 1);
-		} else {
+		if ((strlen(sz_reg_key) + strlen(sz_obj_type)) <
+		    REG_MAXREGPATHLENGTH) {
+			strncat(sz_reg_key, sz_obj_type,
+				strlen(sz_obj_type) + 1);
+		} else
 			status = DSP_EFAIL;
-		}
+
 		/* Create UUID value to set in registry. */
-		UUID_UuidToString(pUuid, szUuid, MAXUUIDLEN);
-               if ((strlen(szRegKey) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
-                       strncat(szRegKey, szUuid, MAXUUIDLEN);
-               else
+		uuid_uuid_to_string(uuid_obj, sz_uuid, MAXUUIDLEN);
+		if ((strlen(sz_reg_key) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
+			strncat(sz_reg_key, sz_uuid, MAXUUIDLEN);
+		else
 			status = DSP_EFAIL;
-
 	}
 
-	if (DSP_SUCCEEDED(status)) {
-		/*
-		 * If pszPathName != NULL, perform registration, otherwise,
-		 * perform unregistration.
-		 */
-		if (pszPathName) {
-			/* Add new reg value (UUID+objType) with COFF path
-			 * info. */
-                       dwPathSize = strlen(pszPathName) + 1;
-			status = REG_SetValue(NULL, szRegKey, szRegKey, REG_SZ,
-					     (u8 *)pszPathName, dwPathSize);
-			GT_3trace(curTrace, GT_6CLASS,
-				 "REG_SetValue  REG_SZ=%d, "
-				 "(u8 *)pszPathName=%s, dwPathSize=%d\n",
-				 REG_SZ, pszPathName, dwPathSize);
-			if (DSP_FAILED(status)) {
-				status = DSP_EFAIL;
-				GT_0trace(curTrace, GT_6CLASS,
-				  "DCD_RegisterObject: REG_SetValue failed!\n");
-			}
-		} else {
-			/* Deregister an existing object. */
-			status = REG_DeleteValue(NULL, szRegKey, szRegKey);
-			if (DSP_FAILED(status)) {
-				status = DSP_EFAIL;
-				GT_0trace(curTrace, GT_6CLASS,
-					"DCD_UnregisterObject: "
-					"REG_DeleteValue failed!\n");
-			}
-		}
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/*
+	 * If psz_path_name != NULL, perform registration, otherwise,
+	 * perform unregistration.
+	 */
+	if (psz_path_name) {
+		/* Add new reg value (UUID+obj_type) with COFF path info */
+		dw_path_size = strlen(psz_path_name) + 1;
+		status =
+		    reg_set_value(sz_reg_key, (u8 *) psz_path_name,
+				  dw_path_size);
+		dev_dbg(bridge, "%s: psz_path_name=%s, dw_path_size=%d\n",
+			__func__, psz_path_name, dw_path_size);
+	} else {
+		/* Deregister an existing object */
+		status = reg_delete_value(sz_reg_key);
 	}
 
 	if (DSP_SUCCEEDED(status)) {
@@ -996,41 +856,36 @@
 		 *  current enumerations to reflect this update in the node
 		 *  database.
 		 */
-
-		cEnumRefs = 0;
+		enum_refs = 0;
 	}
-
+func_end:
 	return status;
 }
 
 /*
- *  ======== DCD_UnregisterObject ========
- *  Call DCD_Register object with pszPathName set to NULL to
+ *  ======== dcd_unregister_object ========
+ *  Call DCD_Register object with psz_path_name set to NULL to
  *  perform actual object de-registration.
  */
-DSP_STATUS DCD_UnregisterObject(IN struct DSP_UUID *pUuid,
-				IN enum DSP_DCDOBJTYPE objType)
+dsp_status dcd_unregister_object(IN struct dsp_uuid *uuid_obj,
+				 IN enum dsp_dcdobjtype obj_type)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pUuid != NULL);
-	DBC_Require((objType == DSP_DCDNODETYPE) ||
-		   (objType == DSP_DCDPROCESSORTYPE) ||
-		   (objType == DSP_DCDLIBRARYTYPE) ||
-		   (objType == DSP_DCDCREATELIBTYPE) ||
-		   (objType == DSP_DCDEXECUTELIBTYPE) ||
-		   (objType == DSP_DCDDELETELIBTYPE));
-
-	GT_2trace(curTrace, GT_ENTER,
-		 "DCD_UnregisterObject: object UUID 0x%x, "
-		 "objType %d\n", pUuid, objType);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(uuid_obj != NULL);
+	DBC_REQUIRE((obj_type == DSP_DCDNODETYPE) ||
+		    (obj_type == DSP_DCDPROCESSORTYPE) ||
+		    (obj_type == DSP_DCDLIBRARYTYPE) ||
+		    (obj_type == DSP_DCDCREATELIBTYPE) ||
+		    (obj_type == DSP_DCDEXECUTELIBTYPE) ||
+		    (obj_type == DSP_DCDDELETELIBTYPE));
 
 	/*
-	 *  When DCD_RegisterObject is called with NULL as pathname,
+	 *  When dcd_register_object is called with NULL as pathname,
 	 *  it indicates an unregister object operation.
 	 */
-	status = DCD_RegisterObject(pUuid, objType, NULL);
+	status = dcd_register_object(uuid_obj, obj_type, NULL);
 
 	return status;
 }
@@ -1042,277 +897,255 @@
  */
 
 /*
- *  ======== Atoi ========
+ *  ======== atoi ========
  *  Purpose:
  *      This function converts strings in decimal or hex format to integers.
  */
-static s32 Atoi(char *pszBuf)
+static s32 atoi(char *psz_buf)
 {
-	s32 result = 0;
-	char *pch = pszBuf;
-	char c;
-	char first;
-	s32 base = 10;
-	s32 len;
+	char *pch = psz_buf;
+	s32 base = 0;
 
 	while (isspace(*pch))
 		pch++;
 
-	first = *pch;
-	if (first == '-' || first == '+') {
+	if (*pch == '-' || *pch == '+') {
+		base = 10;
 		pch++;
-	} else {
-		/* Determine if base 10 or base 16 */
-		len = strlen(pch);
-		if (len  > 1) {
-			c = pch[1];
-			if ((*pch == '0' && (c == 'x' || c == 'X'))) {
-				base = 16;
-				pch += 2;
-			}
-			c = pch[len - 1];
-			if (c == 'h' || c == 'H')
-				base = 16;
-
-		}
+	} else if (*pch && tolower(pch[strlen(pch) - 1]) == 'h') {
+		base = 16;
 	}
 
-	while (isdigit(c = *pch) || ((base == 16) && isxdigit(c))) {
-		result *= base;
-		if ('A' <= c && c <= 'F') {
-			c = c - 'A' + 10;
-		} else {
-			if ('a' <= c && c <= 'f')
-				c = c - 'a' + 10;
-			else
-				c -= '0';
-
-		}
-		result += c;
-		++pch;
-	}
-
-	return result;
+	return simple_strtoul(pch, NULL, base);
 }
 
 /*
- *  ======== GetAttrsFromBuf ========
+ *  ======== get_attrs_from_buf ========
  *  Purpose:
  *      Parse the content of a buffer filled with DSP-side data and
  *      retrieve an object's attributes from it. IMPORTANT: Assume the
  *      buffer has been converted from DSP format to GPP format.
  */
-static DSP_STATUS GetAttrsFromBuf(char *pszBuf, u32 ulBufSize,
-				 enum DSP_DCDOBJTYPE objType,
-				 struct DCD_GENERICOBJ *pGenObj)
+static dsp_status get_attrs_from_buf(char *psz_buf, u32 ul_buf_size,
+				     enum dsp_dcdobjtype obj_type,
+				     struct dcd_genericobj *pGenObj)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 	char seps[] = ", ";
-	char *pszCur;
+	char *psz_cur;
 	char *token;
-	s32 cLen = 0;
+	s32 token_len = 0;
 	u32 i = 0;
 #ifdef _DB_TIOMAP
-	s32 iEntry;
+	s32 entry_id;
 #endif
 
-	DBC_Require(pszBuf != NULL);
-	DBC_Require(ulBufSize != 0);
-	DBC_Require((objType == DSP_DCDNODETYPE)
-		    || (objType == DSP_DCDPROCESSORTYPE));
-	DBC_Require(pGenObj != NULL);
-
+	DBC_REQUIRE(psz_buf != NULL);
+	DBC_REQUIRE(ul_buf_size != 0);
+	DBC_REQUIRE((obj_type == DSP_DCDNODETYPE)
+		    || (obj_type == DSP_DCDPROCESSORTYPE));
+	DBC_REQUIRE(pGenObj != NULL);
 
-	switch (objType) {
+	switch (obj_type) {
 	case DSP_DCDNODETYPE:
 		/*
 		 * Parse COFF sect buffer to retrieve individual tokens used
 		 * to fill in object attrs.
 		 */
-		pszCur = pszBuf;
-		token = strsep(&pszCur, seps);
+		psz_cur = psz_buf;
+		token = strsep(&psz_cur, seps);
 
-		/* u32 cbStruct */
-		pGenObj->objData.nodeObj.ndbProps.cbStruct =
-				(u32) Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* DSP_UUID uiNodeID */
-		UUID_UuidFromString(token,
-				  &pGenObj->objData.nodeObj.ndbProps.uiNodeID);
-		token = strsep(&pszCur, seps);
-
-		/* acName */
-               DBC_Require(token);
-		cLen = strlen(token);
-		if (cLen > DSP_MAXNAMELEN - 1)
-			cLen = DSP_MAXNAMELEN - 1;
-
-               strncpy(pGenObj->objData.nodeObj.ndbProps.acName,
-			   token, cLen);
-		pGenObj->objData.nodeObj.ndbProps.acName[cLen] = '\0';
-		token = strsep(&pszCur, seps);
-		/* u32 uNodeType */
-		pGenObj->objData.nodeObj.ndbProps.uNodeType = Atoi(token);
-		token = strsep(&pszCur, seps);
-		/* u32 bCacheOnGPP */
-		pGenObj->objData.nodeObj.ndbProps.bCacheOnGPP = Atoi(token);
-		token = strsep(&pszCur, seps);
-		/* DSP_RESOURCEREQMTS dspResourceReqmts */
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.cbStruct =
-				(u32) Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
-			uStaticDataSize = Atoi(token);
-		token = strsep(&pszCur, seps);
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
-			uGlobalDataSize = Atoi(token);
-		token = strsep(&pszCur, seps);
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
-			uProgramMemSize = Atoi(token);
-		token = strsep(&pszCur, seps);
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
-			uWCExecutionTime = Atoi(token);
-		token = strsep(&pszCur, seps);
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
-			uWCPeriod = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
-			uWCDeadline = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
-			uAvgExectionTime = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
-			uMinimumPeriod = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* s32 iPriority */
-		pGenObj->objData.nodeObj.ndbProps.iPriority = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* u32 uStackSize */
-		pGenObj->objData.nodeObj.ndbProps.uStackSize = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* u32 uSysStackSize */
-		pGenObj->objData.nodeObj.ndbProps.uSysStackSize = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* u32 uStackSeg */
-		pGenObj->objData.nodeObj.ndbProps.uStackSeg = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* u32 uMessageDepth */
-		pGenObj->objData.nodeObj.ndbProps.uMessageDepth = Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* u32 uNumInputStreams */
-		pGenObj->objData.nodeObj.ndbProps.uNumInputStreams =
-			Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* u32 uNumOutputStreams */
-		pGenObj->objData.nodeObj.ndbProps.uNumOutputStreams =
-			Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* u32 uTimeout */
-		pGenObj->objData.nodeObj.ndbProps.uTimeout =
-			Atoi(token);
-		token = strsep(&pszCur, seps);
-
-		/* char * pstrCreatePhaseFxn */
-               DBC_Require(token);
-		cLen = strlen(token);
-		pGenObj->objData.nodeObj.pstrCreatePhaseFxn =
-			MEM_Calloc(cLen + 1, MEM_PAGED);
-		strncpy(pGenObj->objData.nodeObj.pstrCreatePhaseFxn,
-			token, cLen);
-		pGenObj->objData.nodeObj.pstrCreatePhaseFxn[cLen] = '\0';
-		token = strsep(&pszCur, seps);
-
-		/* char * pstrExecutePhaseFxn */
-               DBC_Require(token);
-		cLen = strlen(token);
-		pGenObj->objData.nodeObj.pstrExecutePhaseFxn =
-			 MEM_Calloc(cLen + 1, MEM_PAGED);
-		strncpy(pGenObj->objData.nodeObj.pstrExecutePhaseFxn,
-			token, cLen);
-		pGenObj->objData.nodeObj.pstrExecutePhaseFxn[cLen] = '\0';
-		token = strsep(&pszCur, seps);
-
-		/* char * pstrDeletePhaseFxn */
-               DBC_Require(token);
-		cLen = strlen(token);
-		pGenObj->objData.nodeObj.pstrDeletePhaseFxn =
-			MEM_Calloc(cLen + 1, MEM_PAGED);
-		strncpy(pGenObj->objData.nodeObj.pstrDeletePhaseFxn,
-			token, cLen);
-		pGenObj->objData.nodeObj.pstrDeletePhaseFxn[cLen] = '\0';
-		token = strsep(&pszCur, seps);
+		/* u32 cb_struct */
+		pGenObj->obj_data.node_obj.ndb_props.cb_struct =
+		    (u32) atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* dsp_uuid ui_node_id */
+		uuid_uuid_from_string(token,
+				      &pGenObj->obj_data.node_obj.ndb_props.
+				      ui_node_id);
+		token = strsep(&psz_cur, seps);
+
+		/* ac_name */
+		DBC_REQUIRE(token);
+		token_len = strlen(token);
+		if (token_len > DSP_MAXNAMELEN - 1)
+			token_len = DSP_MAXNAMELEN - 1;
+
+		strncpy(pGenObj->obj_data.node_obj.ndb_props.ac_name,
+			token, token_len);
+		pGenObj->obj_data.node_obj.ndb_props.ac_name[token_len] = '\0';
+		token = strsep(&psz_cur, seps);
+		/* u32 ntype */
+		pGenObj->obj_data.node_obj.ndb_props.ntype = atoi(token);
+		token = strsep(&psz_cur, seps);
+		/* u32 cache_on_gpp */
+		pGenObj->obj_data.node_obj.ndb_props.cache_on_gpp = atoi(token);
+		token = strsep(&psz_cur, seps);
+		/* dsp_resourcereqmts dsp_resource_reqmts */
+		pGenObj->obj_data.node_obj.ndb_props.dsp_resource_reqmts.
+		    cb_struct = (u32) atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		pGenObj->obj_data.node_obj.ndb_props.
+		    dsp_resource_reqmts.static_data_size = atoi(token);
+		token = strsep(&psz_cur, seps);
+		pGenObj->obj_data.node_obj.ndb_props.
+		    dsp_resource_reqmts.global_data_size = atoi(token);
+		token = strsep(&psz_cur, seps);
+		pGenObj->obj_data.node_obj.ndb_props.
+		    dsp_resource_reqmts.program_mem_size = atoi(token);
+		token = strsep(&psz_cur, seps);
+		pGenObj->obj_data.node_obj.ndb_props.
+		    dsp_resource_reqmts.uwc_execution_time = atoi(token);
+		token = strsep(&psz_cur, seps);
+		pGenObj->obj_data.node_obj.ndb_props.
+		    dsp_resource_reqmts.uwc_period = atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		pGenObj->obj_data.node_obj.ndb_props.
+		    dsp_resource_reqmts.uwc_deadline = atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		pGenObj->obj_data.node_obj.ndb_props.
+		    dsp_resource_reqmts.avg_exection_time = atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		pGenObj->obj_data.node_obj.ndb_props.
+		    dsp_resource_reqmts.minimum_period = atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* s32 prio */
+		pGenObj->obj_data.node_obj.ndb_props.prio = atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* u32 stack_size */
+		pGenObj->obj_data.node_obj.ndb_props.stack_size = atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* u32 sys_stack_size */
+		pGenObj->obj_data.node_obj.ndb_props.sys_stack_size =
+		    atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* u32 stack_seg */
+		pGenObj->obj_data.node_obj.ndb_props.stack_seg = atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* u32 message_depth */
+		pGenObj->obj_data.node_obj.ndb_props.message_depth =
+		    atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* u32 num_input_streams */
+		pGenObj->obj_data.node_obj.ndb_props.num_input_streams =
+		    atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* u32 num_output_streams */
+		pGenObj->obj_data.node_obj.ndb_props.num_output_streams =
+		    atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* u32 utimeout */
+		pGenObj->obj_data.node_obj.ndb_props.utimeout = atoi(token);
+		token = strsep(&psz_cur, seps);
+
+		/* char *pstr_create_phase_fxn */
+		DBC_REQUIRE(token);
+		token_len = strlen(token);
+		pGenObj->obj_data.node_obj.pstr_create_phase_fxn =
+		    mem_calloc(token_len + 1, MEM_PAGED);
+		strncpy(pGenObj->obj_data.node_obj.pstr_create_phase_fxn,
+			token, token_len);
+		pGenObj->obj_data.node_obj.pstr_create_phase_fxn[token_len] =
+		    '\0';
+		token = strsep(&psz_cur, seps);
+
+		/* char *pstr_execute_phase_fxn */
+		DBC_REQUIRE(token);
+		token_len = strlen(token);
+		pGenObj->obj_data.node_obj.pstr_execute_phase_fxn =
+		    mem_calloc(token_len + 1, MEM_PAGED);
+		strncpy(pGenObj->obj_data.node_obj.pstr_execute_phase_fxn,
+			token, token_len);
+		pGenObj->obj_data.node_obj.pstr_execute_phase_fxn[token_len] =
+		    '\0';
+		token = strsep(&psz_cur, seps);
+
+		/* char *pstr_delete_phase_fxn */
+		DBC_REQUIRE(token);
+		token_len = strlen(token);
+		pGenObj->obj_data.node_obj.pstr_delete_phase_fxn =
+		    mem_calloc(token_len + 1, MEM_PAGED);
+		strncpy(pGenObj->obj_data.node_obj.pstr_delete_phase_fxn,
+			token, token_len);
+		pGenObj->obj_data.node_obj.pstr_delete_phase_fxn[token_len] =
+		    '\0';
+		token = strsep(&psz_cur, seps);
 
 		/* Segment id for message buffers */
-		pGenObj->objData.nodeObj.uMsgSegid = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.node_obj.msg_segid = atoi(token);
+		token = strsep(&psz_cur, seps);
 
 		/* Message notification type */
-		pGenObj->objData.nodeObj.uMsgNotifyType = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.node_obj.msg_notify_type = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		/* char * pstrIAlgName */
+		/* char *pstr_i_alg_name */
 		if (token) {
-			cLen = strlen(token);
-			pGenObj->objData.nodeObj.pstrIAlgName =
-				MEM_Calloc(cLen + 1, MEM_PAGED);
-			strncpy(pGenObj->objData.nodeObj.pstrIAlgName,
-				token, cLen);
-			pGenObj->objData.nodeObj.pstrIAlgName[cLen] = '\0';
-			token = strsep(&pszCur, seps);
+			token_len = strlen(token);
+			pGenObj->obj_data.node_obj.pstr_i_alg_name =
+			    mem_calloc(token_len + 1, MEM_PAGED);
+			strncpy(pGenObj->obj_data.node_obj.pstr_i_alg_name,
+				token, token_len);
+			pGenObj->obj_data.node_obj.pstr_i_alg_name[token_len] =
+			    '\0';
+			token = strsep(&psz_cur, seps);
 		}
 
 		/* Load type (static, dynamic, or overlay) */
 		if (token) {
-			pGenObj->objData.nodeObj.usLoadType = Atoi(token);
-			token = strsep(&pszCur, seps);
+			pGenObj->obj_data.node_obj.us_load_type = atoi(token);
+			token = strsep(&psz_cur, seps);
 		}
 
 		/* Dynamic load data requirements */
 		if (token) {
-			pGenObj->objData.nodeObj.ulDataMemSegMask = Atoi(token);
-			token = strsep(&pszCur, seps);
+			pGenObj->obj_data.node_obj.ul_data_mem_seg_mask =
+			    atoi(token);
+			token = strsep(&psz_cur, seps);
 		}
 
 		/* Dynamic load code requirements */
 		if (token) {
-			pGenObj->objData.nodeObj.ulCodeMemSegMask = Atoi(token);
-			token = strsep(&pszCur, seps);
+			pGenObj->obj_data.node_obj.ul_code_mem_seg_mask =
+			    atoi(token);
+			token = strsep(&psz_cur, seps);
 		}
 
 		/* Extract node profiles into node properties */
 		if (token) {
 
-			pGenObj->objData.nodeObj.ndbProps.uCountProfiles =
-				Atoi(token);
-			for (i = 0; i < pGenObj->objData.nodeObj.ndbProps.
-			    uCountProfiles; i++) {
-				token = strsep(&pszCur, seps);
+			pGenObj->obj_data.node_obj.ndb_props.count_profiles =
+			    atoi(token);
+			for (i = 0;
+			     i <
+			     pGenObj->obj_data.node_obj.
+			     ndb_props.count_profiles; i++) {
+				token = strsep(&psz_cur, seps);
 				if (token) {
 					/* Heap Size for the node */
-					pGenObj->objData.nodeObj.ndbProps.
-						aProfiles[i].ulHeapSize =
-						Atoi(token);
+					pGenObj->obj_data.node_obj.
+					    ndb_props.node_profiles[i].
+					    ul_heap_size = atoi(token);
 				}
 			}
 		}
-		token = strsep(&pszCur, seps);
+		token = strsep(&psz_cur, seps);
 		if (token) {
-			pGenObj->objData.nodeObj.ndbProps.uStackSegName =
-				(u32)(token);
+			pGenObj->obj_data.node_obj.ndb_props.stack_seg_name =
+			    (u32) (token);
 		}
 
 		break;
@@ -1322,49 +1155,49 @@
 		 * Parse COFF sect buffer to retrieve individual tokens used
 		 * to fill in object attrs.
 		 */
-		pszCur = pszBuf;
-		token = strsep(&pszCur, seps);
+		psz_cur = psz_buf;
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.cbStruct = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.cb_struct = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.uProcessorFamily = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.processor_family = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.uProcessorType = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.processor_type = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.uClockRate = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.clock_rate = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.ulInternalMemSize = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.ul_internal_mem_size = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.ulExternalMemSize = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.ul_external_mem_size = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.uProcessorID = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.processor_id = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.tyRunningRTOS = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.ty_running_rtos = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.nNodeMinPriority = Atoi(token);
-		token = strsep(&pszCur, seps);
+		pGenObj->obj_data.proc_info.node_min_priority = atoi(token);
+		token = strsep(&psz_cur, seps);
 
-		pGenObj->objData.procObj.nNodeMaxPriority = Atoi(token);
+		pGenObj->obj_data.proc_info.node_max_priority = atoi(token);
 
 #ifdef _DB_TIOMAP
 		/* Proc object may contain additional(extended) attributes. */
 		/* attr must match proc.hxx */
-		for (iEntry = 0; iEntry < 7; iEntry++) {
-			token = strsep(&pszCur, seps);
-			pGenObj->objData.extProcObj.tyTlb[iEntry].ulGppPhys =
-				Atoi(token);
-
-			token = strsep(&pszCur, seps);
-			pGenObj->objData.extProcObj.tyTlb[iEntry].ulDspVirt =
-				Atoi(token);
+		for (entry_id = 0; entry_id < 7; entry_id++) {
+			token = strsep(&psz_cur, seps);
+			pGenObj->obj_data.ext_proc_obj.ty_tlb[entry_id].
+			    ul_gpp_phys = atoi(token);
+
+			token = strsep(&psz_cur, seps);
+			pGenObj->obj_data.ext_proc_obj.ty_tlb[entry_id].
+			    ul_dsp_virt = atoi(token);
 		}
 #endif
 
@@ -1383,22 +1216,21 @@
  *  Purpose:
  *      Compress the DSP buffer, if necessary, to conform to PC format.
  */
-static void CompressBuf(char *pszBuf, u32 ulBufSize, s32 cCharSize)
+static void compress_buf(char *psz_buf, u32 ul_buf_size, s32 cCharSize)
 {
 	char *p;
 	char ch;
 	char *q;
 
-	p = pszBuf;
+	p = psz_buf;
 	if (p == NULL)
 		return;
 
-	for (q = pszBuf; q < (pszBuf + ulBufSize);) {
-
-		ch = DspChar2GppChar(q, cCharSize);
+	for (q = psz_buf; q < (psz_buf + ul_buf_size);) {
+		ch = dsp_char2_gpp_char(q, cCharSize);
 		if (ch == '\\') {
 			q += cCharSize;
-			ch = DspChar2GppChar(q, cCharSize);
+			ch = dsp_char2_gpp_char(q, cCharSize);
 			switch (ch) {
 			case 't':
 				*p = '\t';
@@ -1430,127 +1262,126 @@
 	/* NULL out remainder of buffer. */
 	while (p < q)
 		*p++ = '\0';
-
 }
 
 /*
- *  ======== DspChar2GppChar ========
+ *  ======== dsp_char2_gpp_char ========
  *  Purpose:
  *      Convert DSP char to host GPP char in a portable manner
  */
-static char DspChar2GppChar(char *pWord, s32 cDspCharSize)
+static char dsp_char2_gpp_char(char *pWord, s32 cDspCharSize)
 {
 	char ch = '\0';
-	char *chSrc;
+	char *ch_src;
 	s32 i;
 
-	for (chSrc = pWord, i = cDspCharSize; i > 0; i--)
-		ch |= *chSrc++;
+	for (ch_src = pWord, i = cDspCharSize; i > 0; i--)
+		ch |= *ch_src++;
 
 	return ch;
 }
 
 /*
- *  ======== GetDepLibInfo ========
+ *  ======== get_dep_lib_info ========
  */
-static DSP_STATUS GetDepLibInfo(IN struct DCD_MANAGER *hDcdMgr,
-				IN struct DSP_UUID *pUuid,
-				IN OUT u16 *pNumLibs,
-				OPTIONAL OUT u16 *pNumPersLibs,
-				OPTIONAL OUT struct DSP_UUID *pDepLibUuids,
-				OPTIONAL OUT bool *pPersistentDepLibs,
-				enum NLDR_PHASE phase)
+static dsp_status get_dep_lib_info(IN struct dcd_manager *hdcd_mgr,
+				   IN struct dsp_uuid *uuid_obj,
+				   IN OUT u16 *pNumLibs,
+				   OPTIONAL OUT u16 *pNumPersLibs,
+				   OPTIONAL OUT struct dsp_uuid *pDepLibUuids,
+				   OPTIONAL OUT bool *pPersistentDepLibs,
+				   enum nldr_phase phase)
 {
-	struct DCD_MANAGER *pDcdMgr = hDcdMgr;	/* pointer to DCD manager */
-	char *pszCoffBuf = NULL;
-	char *pszCur;
-	char *pszFileName = NULL;
-	struct COD_LIBRARYOBJ *lib = NULL;
-	u32 ulAddr = 0;	/* Used by COD_GetSection */
-	u32 ulLen = 0;	/* Used by COD_GetSection */
-	u32 dwDataSize = COD_MAXPATHLENGTH;
+	struct dcd_manager *dcd_mgr_obj = hdcd_mgr;
+	char *psz_coff_buf = NULL;
+	char *psz_cur;
+	char *psz_file_name = NULL;
+	struct cod_libraryobj *lib = NULL;
+	u32 ul_addr = 0;	/* Used by cod_get_section */
+	u32 ul_len = 0;		/* Used by cod_get_section */
+	u32 dw_data_size = COD_MAXPATHLENGTH;
 	char seps[] = ", ";
-	char *pToken = NULL;
-	bool fGetUuids = (pDepLibUuids != NULL);
-	u16 nDepLibs = 0;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-
-	DBC_Require(IsValidHandle(hDcdMgr));
-	DBC_Require(pNumLibs != NULL);
-	DBC_Require(pUuid != NULL);
-
-	GT_1trace(curTrace, GT_ENTER, "DCD_GetNumDepLibs: hDcdMgr 0x%x\n",
-		 hDcdMgr);
+	char *token = NULL;
+	bool get_uuids = (pDepLibUuids != NULL);
+	u16 dep_libs = 0;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(refs > 0);
+
+	DBC_REQUIRE(IS_VALID_HANDLE(hdcd_mgr));
+	DBC_REQUIRE(pNumLibs != NULL);
+	DBC_REQUIRE(uuid_obj != NULL);
 
 	/*  Initialize to 0 dependent libraries, if only counting number of
 	 *  dependent libraries */
-	if (!fGetUuids) {
+	if (!get_uuids) {
 		*pNumLibs = 0;
 		*pNumPersLibs = 0;
 	}
 
 	/* Allocate a buffer for file name */
-	pszFileName = MEM_Calloc(dwDataSize, MEM_PAGED);
-	if (pszFileName == NULL) {
+	psz_file_name = mem_calloc(dw_data_size, MEM_PAGED);
+	if (psz_file_name == NULL) {
 		status = DSP_EMEMORY;
 	} else {
 		/* Get the name of the library */
-		status = DCD_GetLibraryName(hDcdMgr, pUuid, pszFileName,
-			 &dwDataSize, phase, NULL);
+		status = dcd_get_library_name(hdcd_mgr, uuid_obj, psz_file_name,
+					      &dw_data_size, phase, NULL);
 	}
+
 	/* Open the library */
 	if (DSP_SUCCEEDED(status)) {
-		status = COD_Open(pDcdMgr->hCodMgr, pszFileName,
-				 COD_NOLOAD, &lib);
+		status = cod_open(dcd_mgr_obj->cod_mgr, psz_file_name,
+				  COD_NOLOAD, &lib);
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Get dependent library section information. */
-		status = COD_GetSection(lib, DEPLIBSECT, &ulAddr, &ulLen);
+		status = cod_get_section(lib, DEPLIBSECT, &ul_addr, &ul_len);
 
 		if (DSP_FAILED(status)) {
 			/* Ok, no dependent libraries */
-			ulLen = 0;
+			ul_len = 0;
 			status = DSP_SNODEPENDENTLIBS;
 		}
 	}
 
-	if (DSP_FAILED(status) || !(ulLen > 0))
+	if (DSP_FAILED(status) || !(ul_len > 0))
 		goto func_cont;
 
 	/* Allocate zeroed buffer. */
-	pszCoffBuf = MEM_Calloc(ulLen, MEM_PAGED);
-	if (pszCoffBuf == NULL)
+	psz_coff_buf = mem_calloc(ul_len + 4, MEM_PAGED);
+	if (psz_coff_buf == NULL)
 		status = DSP_EMEMORY;
 
 	/* Read section contents. */
-	status = COD_ReadSection(lib, DEPLIBSECT, pszCoffBuf, ulLen);
+	status = cod_read_section(lib, DEPLIBSECT, psz_coff_buf, ul_len);
 	if (DSP_FAILED(status))
 		goto func_cont;
 
 	/* Compress and format DSP buffer to conform to PC format. */
-	CompressBuf(pszCoffBuf, ulLen, DSPWORDSIZE);
+	compress_buf(psz_coff_buf, ul_len, DSPWORDSIZE);
+
 	/* Read from buffer */
-	pszCur = pszCoffBuf;
-	while ((pToken = strsep(&pszCur, seps)) && *pToken != '\0') {
-		if (fGetUuids) {
-			if (nDepLibs >= *pNumLibs) {
+	psz_cur = psz_coff_buf;
+	while ((token = strsep(&psz_cur, seps)) && *token != '\0') {
+		if (get_uuids) {
+			if (dep_libs >= *pNumLibs) {
 				/* Gone beyond the limit */
 				break;
 			} else {
 				/* Retrieve UUID string. */
-				UUID_UuidFromString(pToken,
-						 &(pDepLibUuids[nDepLibs]));
+				uuid_uuid_from_string(token,
+						      &(pDepLibUuids
+							[dep_libs]));
 				/* Is this library persistent? */
-				pToken = strsep(&pszCur, seps);
-				pPersistentDepLibs[nDepLibs] = Atoi(pToken);
-				nDepLibs++;
+				token = strsep(&psz_cur, seps);
+				pPersistentDepLibs[dep_libs] = atoi(token);
+				dep_libs++;
 			}
 		} else {
 			/* Advanc to next token */
-			pToken = strsep(&pszCur, seps);
-			if (Atoi(pToken))
+			token = strsep(&psz_cur, seps);
+			if (atoi(token))
 				(*pNumPersLibs)++;
 
 			/* Just counting number of dependent libraries */
@@ -1559,15 +1390,12 @@
 	}
 func_cont:
 	if (lib)
-		COD_Close(lib);
+		cod_close(lib);
 
 	/* Free previously allocated dynamic buffers. */
-	if (pszFileName)
-		MEM_Free(pszFileName);
+	kfree(psz_file_name);
 
-	if (pszCoffBuf)
-		MEM_Free(pszCoffBuf);
+	kfree(psz_coff_buf);
 
 	return status;
 }
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/disp.c kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/disp.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/disp.c	2011-10-11 13:51:01.165108622 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/rmgr/disp.c	2011-10-23 08:22:37.646645000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Node Dispatcher interface. Communicates with Resource Manager Server
+ * (RMS) on DSP. Access to RMS is synchronized in NODE.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software;  you can redistribute it and/or modify
@@ -14,38 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== disp.c ========
- *
- *  Description:
- *      Node Dispatcher interface. Communicates with Resource Manager Server
- *      (RMS) on DSP. Access to RMS is synchronized in NODE.
- *
- *  Public Functions:
- *      DISP_Create
- *      DISP_Delete
- *      DISP_Exit
- *      DISP_Init
- *      DISP_NodeChangePriority
- *      DISP_NodeCreate
- *      DISP_NodeDelete
- *      DISP_NodePause
- *      DISP_NodeRun
- *
- *! Revision History:
- *! =================
- *! 18-Feb-2003 vp      Code review updates
- *! 18-Oct-2002 vp      Ported to Linux platform
- *! 16-May-2002 jeh     Added DISP_DoCinit().
- *! 24-Apr-2002 jeh     Added DISP_MemWrite().
- *! 13-Feb-2002 jeh     Pass system stack size to RMS.
- *! 16-Jan-2002  ag     Added bufsize param to _ChnlAddIOReq() fxn
- *! 10-May-2001 jeh     Code Review cleanup.
- *! 26-Sep-2000 jeh     Fixed status values in SendMessage().
- *! 19-Jun-2000 jeh     Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -55,14 +26,11 @@
 #include <dspbridge/errbase.h>
 
 /*  ----------------------------------- Trace & Debug */
-#include <dspbridge/gt.h>
 #include <dspbridge/dbc.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/dev.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/sync.h>
-#include <dspbridge/csl.h>
 
 /*  ----------------------------------- Link Driver */
 #include <dspbridge/wmd.h>
@@ -82,7 +50,7 @@
 #define DISP_SIGNATURE       0x50534944	/* "PSID" */
 
 /* Size of a reply from RMS */
-#define REPLYSIZE (3 * sizeof(RMS_WORD))
+#define REPLYSIZE (3 * sizeof(rms_word))
 
 /* Reserved channel offsets for communication with RMS */
 #define CHNLTORMSOFFSET       0
@@ -90,86 +58,70 @@
 
 #define CHNLIOREQS      1
 
-#define SwapWord(x)     (((u32)(x) >> 16) | ((u32)(x) << 16))
+#define SWAP_WORD(x)     (((u32)(x) >> 16) | ((u32)(x) << 16))
 
 /*
- *  ======== DISP_OBJECT ========
+ *  ======== disp_object ========
  */
-struct DISP_OBJECT {
-	u32 dwSignature; 	/* Used for object validation */
-	struct DEV_OBJECT *hDevObject; 	/* Device for this processor */
-	struct WMD_DRV_INTERFACE *pIntfFxns; 	/* Function interface to WMD */
-	struct CHNL_MGR *hChnlMgr; 	/* Channel manager */
-	struct CHNL_OBJECT *hChnlToDsp;   /* Channel for commands to RMS */
-	struct CHNL_OBJECT *hChnlFromDsp;   /* Channel for replies from RMS */
-	u8 *pBuf; 		/* Buffer for commands, replies */
-	u32 ulBufsize; 	/* pBuf size in bytes */
-	u32 ulBufsizeRMS; 	/* pBuf size in RMS words */
-	u32 uCharSize; 		/* Size of DSP character */
-	u32 uWordSize; 		/* Size of DSP word */
-	u32 uDataMauSize; 	/* Size of DSP Data MAU */
+struct disp_object {
+	u32 dw_signature;	/* Used for object validation */
+	struct dev_object *hdev_obj;	/* Device for this processor */
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD */
+	struct chnl_mgr *hchnl_mgr;	/* Channel manager */
+	struct chnl_object *chnl_to_dsp;	/* Chnl for commands to RMS */
+	struct chnl_object *chnl_from_dsp;	/* Chnl for replies from RMS */
+	u8 *pbuf;		/* Buffer for commands, replies */
+	u32 ul_bufsize;		/* pbuf size in bytes */
+	u32 ul_bufsize_rms;	/* pbuf size in RMS words */
+	u32 char_size;		/* Size of DSP character */
+	u32 word_size;		/* Size of DSP word */
+	u32 data_mau_size;	/* Size of DSP Data MAU */
 };
 
-static u32 cRefs;
+static u32 refs;
 
-/* Debug msgs: */
-#if GT_TRACE
-static struct GT_Mask DISP_DebugMask = { NULL, NULL };
-#endif
-
-static void DeleteDisp(struct DISP_OBJECT *hDisp);
-static DSP_STATUS FillStreamDef(RMS_WORD *pdwBuf, u32 *ptotal, u32 offset,
-				struct NODE_STRMDEF strmDef, u32 max,
-				u32 uCharsInRMSWord);
-static DSP_STATUS SendMessage(struct DISP_OBJECT *hDisp, u32 dwTimeout,
-			     u32 ulBytes, OUT u32 *pdwArg);
+static void delete_disp(struct disp_object *disp_obj);
+static dsp_status fill_stream_def(rms_word *pdw_buf, u32 *ptotal, u32 offset,
+				  struct node_strmdef strm_def, u32 max,
+				  u32 chars_in_rms_word);
+static dsp_status send_message(struct disp_object *disp_obj, u32 dwTimeout,
+			       u32 ul_bytes, OUT u32 *pdw_arg);
 
 /*
- *  ======== DISP_Create ========
+ *  ======== disp_create ========
  *  Create a NODE Dispatcher object.
  */
-DSP_STATUS DISP_Create(OUT struct DISP_OBJECT **phDispObject,
-		      struct DEV_OBJECT *hDevObject,
-		      IN CONST struct DISP_ATTRS *pDispAttrs)
-{
-	struct DISP_OBJECT *pDisp;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	u32 ulChnlId;
-	struct CHNL_ATTRS chnlAttrs;
-	DSP_STATUS status = DSP_SOK;
-	u32 devType;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(phDispObject != NULL);
-	DBC_Require(pDispAttrs != NULL);
-	DBC_Require(hDevObject != NULL);
-
-	GT_3trace(DISP_DebugMask, GT_ENTER, "DISP_Create: phDispObject: 0x%x\t"
-		 "hDevObject: 0x%x\tpDispAttrs: 0x%x\n", phDispObject,
-		 hDevObject, pDispAttrs);
+dsp_status disp_create(OUT struct disp_object **phDispObject,
+		       struct dev_object *hdev_obj,
+		       IN CONST struct disp_attr *pDispAttrs)
+{
+	struct disp_object *disp_obj;
+	struct bridge_drv_interface *intf_fxns;
+	u32 ul_chnl_id;
+	struct chnl_attr chnl_attr_obj;
+	dsp_status status = DSP_SOK;
+	u32 dev_type;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phDispObject != NULL);
+	DBC_REQUIRE(pDispAttrs != NULL);
+	DBC_REQUIRE(hdev_obj != NULL);
 
 	*phDispObject = NULL;
 
 	/* Allocate Node Dispatcher object */
-	MEM_AllocObject(pDisp, struct DISP_OBJECT, DISP_SIGNATURE);
-	if (pDisp == NULL) {
+	MEM_ALLOC_OBJECT(disp_obj, struct disp_object, DISP_SIGNATURE);
+	if (disp_obj == NULL)
 		status = DSP_EMEMORY;
-		GT_0trace(DISP_DebugMask, GT_6CLASS,
-			 "DISP_Create: MEM_AllocObject() failed!\n");
-	} else {
-		pDisp->hDevObject = hDevObject;
-	}
+	else
+		disp_obj->hdev_obj = hdev_obj;
 
 	/* Get Channel manager and WMD function interface */
 	if (DSP_SUCCEEDED(status)) {
-		status = DEV_GetChnlMgr(hDevObject, &(pDisp->hChnlMgr));
+		status = dev_get_chnl_mgr(hdev_obj, &(disp_obj->hchnl_mgr));
 		if (DSP_SUCCEEDED(status)) {
-			(void) DEV_GetIntfFxns(hDevObject, &pIntfFxns);
-			pDisp->pIntfFxns = pIntfFxns;
-		} else {
-			GT_1trace(DISP_DebugMask, GT_6CLASS,
-				 "DISP_Create: Failed to get "
-				 "channel manager! status = 0x%x\n", status);
+			(void)dev_get_intf_fxns(hdev_obj, &intf_fxns);
+			disp_obj->intf_fxns = intf_fxns;
 		}
 	}
 
@@ -178,242 +130,195 @@
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-	status = DEV_GetDevType(hDevObject, &devType);
-	GT_1trace(DISP_DebugMask, GT_6CLASS, "DISP_Create: Creating DISP for "
-		 "device = 0x%x\n", devType);
+	status = dev_get_dev_type(hdev_obj, &dev_type);
+
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-	if (devType != DSP_UNIT) {
-		GT_0trace(DISP_DebugMask, GT_6CLASS,
-			 "DISP_Create: Unkown device "
-			 "type in Device object !! \n");
+	if (dev_type != DSP_UNIT) {
 		status = DSP_EFAIL;
 		goto func_cont;
 	}
-	if (DSP_SUCCEEDED(status)) {
-		pDisp->uCharSize = DSPWORDSIZE;
-		pDisp->uWordSize = DSPWORDSIZE;
-		pDisp->uDataMauSize = DSPWORDSIZE;
-		/* Open channels for communicating with the RMS */
-		chnlAttrs.uIOReqs = CHNLIOREQS;
-		chnlAttrs.hEvent = NULL;
-		ulChnlId = pDispAttrs->ulChnlOffset + CHNLTORMSOFFSET;
-		status = (*pIntfFxns->pfnChnlOpen)(&(pDisp->hChnlToDsp),
-			 pDisp->hChnlMgr, CHNL_MODETODSP, ulChnlId, &chnlAttrs);
-		if (DSP_FAILED(status)) {
-			GT_2trace(DISP_DebugMask, GT_6CLASS,
-				 "DISP_Create:  Channel to RMS "
-				 "open failed, chnl id = %d, status = 0x%x\n",
-				 ulChnlId, status);
-		}
-	}
-	if (DSP_SUCCEEDED(status)) {
-		ulChnlId = pDispAttrs->ulChnlOffset + CHNLFROMRMSOFFSET;
-		status = (*pIntfFxns->pfnChnlOpen)(&(pDisp->hChnlFromDsp),
-			 pDisp->hChnlMgr, CHNL_MODEFROMDSP, ulChnlId,
-			 &chnlAttrs);
-		if (DSP_FAILED(status)) {
-			GT_2trace(DISP_DebugMask, GT_6CLASS,
-				 "DISP_Create: Channel from RMS "
-				 "open failed, chnl id = %d, status = 0x%x\n",
-				 ulChnlId, status);
-		}
+
+	disp_obj->char_size = DSPWORDSIZE;
+	disp_obj->word_size = DSPWORDSIZE;
+	disp_obj->data_mau_size = DSPWORDSIZE;
+	/* Open channels for communicating with the RMS */
+	chnl_attr_obj.uio_reqs = CHNLIOREQS;
+	chnl_attr_obj.event_obj = NULL;
+	ul_chnl_id = pDispAttrs->ul_chnl_offset + CHNLTORMSOFFSET;
+	status = (*intf_fxns->pfn_chnl_open) (&(disp_obj->chnl_to_dsp),
+					      disp_obj->hchnl_mgr,
+					      CHNL_MODETODSP, ul_chnl_id,
+					      &chnl_attr_obj);
+
+	if (DSP_SUCCEEDED(status)) {
+		ul_chnl_id = pDispAttrs->ul_chnl_offset + CHNLFROMRMSOFFSET;
+		status =
+		    (*intf_fxns->pfn_chnl_open) (&(disp_obj->chnl_from_dsp),
+						 disp_obj->hchnl_mgr,
+						 CHNL_MODEFROMDSP, ul_chnl_id,
+						 &chnl_attr_obj);
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Allocate buffer for commands, replies */
-		pDisp->ulBufsize = pDispAttrs->ulChnlBufSize;
-		pDisp->ulBufsizeRMS = RMS_COMMANDBUFSIZE;
-		pDisp->pBuf = MEM_Calloc(pDisp->ulBufsize, MEM_PAGED);
-		if (pDisp->pBuf == NULL) {
+		disp_obj->ul_bufsize = pDispAttrs->ul_chnl_buf_size;
+		disp_obj->ul_bufsize_rms = RMS_COMMANDBUFSIZE;
+		disp_obj->pbuf = mem_calloc(disp_obj->ul_bufsize, MEM_PAGED);
+		if (disp_obj->pbuf == NULL)
 			status = DSP_EMEMORY;
-			GT_0trace(DISP_DebugMask, GT_6CLASS,
-				 "DISP_Create: Failed "
-				 "to allocate channel buffer!\n");
-		}
 	}
 func_cont:
 	if (DSP_SUCCEEDED(status))
-		*phDispObject = pDisp;
+		*phDispObject = disp_obj;
 	else
-		DeleteDisp(pDisp);
+		delete_disp(disp_obj);
 
-	DBC_Ensure(((DSP_FAILED(status)) && ((*phDispObject == NULL))) ||
-		  ((DSP_SUCCEEDED(status)) &&
-		  (MEM_IsValidHandle((*phDispObject), DISP_SIGNATURE))));
+	DBC_ENSURE(((DSP_FAILED(status)) && ((*phDispObject == NULL))) ||
+		   ((DSP_SUCCEEDED(status)) &&
+		    (MEM_IS_VALID_HANDLE((*phDispObject), DISP_SIGNATURE))));
 	return status;
 }
 
 /*
- *  ======== DISP_Delete ========
+ *  ======== disp_delete ========
  *  Delete the NODE Dispatcher.
  */
-void DISP_Delete(struct DISP_OBJECT *hDisp)
+void disp_delete(struct disp_object *disp_obj)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
-
-	GT_1trace(DISP_DebugMask, GT_ENTER,
-		 "DISP_Delete: hDisp: 0x%x\n", hDisp);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(disp_obj, DISP_SIGNATURE));
 
-	DeleteDisp(hDisp);
+	delete_disp(disp_obj);
 
-	DBC_Ensure(!MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
+	DBC_ENSURE(!MEM_IS_VALID_HANDLE(disp_obj, DISP_SIGNATURE));
 }
 
 /*
- *  ======== DISP_Exit ========
+ *  ======== disp_exit ========
  *  Discontinue usage of DISP module.
  */
-void DISP_Exit(void)
+void disp_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	GT_1trace(DISP_DebugMask, GT_5CLASS,
-		 "Entered DISP_Exit, ref count:  0x%x\n", cRefs);
-
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== DISP_Init ========
+ *  ======== disp_init ========
  *  Initialize the DISP module.
  */
-bool DISP_Init(void)
+bool disp_init(void)
 {
-	bool fRetVal = true;
-
-	DBC_Require(cRefs >= 0);
+	bool ret = true;
 
-	if (cRefs == 0) {
-		DBC_Assert(!DISP_DebugMask.flags);
-		GT_create(&DISP_DebugMask, "DI");  /* "DI" for DIspatcher */
-	}
-
-	if (fRetVal)
-		cRefs++;
+	DBC_REQUIRE(refs >= 0);
 
-	GT_1trace(DISP_DebugMask, GT_5CLASS,
-		 "DISP_Init(), ref count:  0x%x\n", cRefs);
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fRetVal && (cRefs > 0)) || (!fRetVal && (cRefs >= 0)));
-	return fRetVal;
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
+	return ret;
 }
 
 /*
- *  ======== DISP_NodeChangePriority ========
+ *  ======== disp_node_change_priority ========
  *  Change the priority of a node currently running on the target.
  */
-DSP_STATUS DISP_NodeChangePriority(struct DISP_OBJECT *hDisp,
-				  struct NODE_OBJECT *hNode,
-				  u32 ulRMSFxn, NODE_ENV nodeEnv,
-				  s32 nPriority)
-{
-	u32 dwArg;
-	struct RMS_Command *pCommand;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
-	DBC_Require(hNode != NULL);
-
-	GT_5trace(DISP_DebugMask, GT_ENTER, "DISP_NodeChangePriority: hDisp: "
-		"0x%x\thNode: 0x%x\tulRMSFxn: 0x%x\tnodeEnv: 0x%x\tnPriority\n",
-		hDisp, hNode, ulRMSFxn, nodeEnv, nPriority);
+dsp_status disp_node_change_priority(struct disp_object *disp_obj,
+				     struct node_object *hnode,
+				     u32 ulRMSFxn, nodeenv node_env, s32 prio)
+{
+	u32 dw_arg;
+	struct rms_command *rms_cmd;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(disp_obj, DISP_SIGNATURE));
+	DBC_REQUIRE(hnode != NULL);
 
 	/* Send message to RMS to change priority */
-	pCommand = (struct RMS_Command *)(hDisp->pBuf);
-	pCommand->fxn = (RMS_WORD)(ulRMSFxn);
-	pCommand->arg1 = (RMS_WORD)nodeEnv;
-	pCommand->arg2 = nPriority;
-	status = SendMessage(hDisp, NODE_GetTimeout(hNode),
-		 sizeof(struct RMS_Command), &dwArg);
-	if (DSP_FAILED(status)) {
-		GT_1trace(DISP_DebugMask, GT_6CLASS,
-			 "DISP_NodeChangePriority failed! "
-			 "status = 0x%x\n", status);
-	}
+	rms_cmd = (struct rms_command *)(disp_obj->pbuf);
+	rms_cmd->fxn = (rms_word) (ulRMSFxn);
+	rms_cmd->arg1 = (rms_word) node_env;
+	rms_cmd->arg2 = prio;
+	status = send_message(disp_obj, node_get_timeout(hnode),
+			      sizeof(struct rms_command), &dw_arg);
+
 	return status;
 }
 
 /*
- *  ======== DISP_NodeCreate ========
+ *  ======== disp_node_create ========
  *  Create a node on the DSP by remotely calling the node's create function.
  */
-DSP_STATUS DISP_NodeCreate(struct DISP_OBJECT *hDisp, struct NODE_OBJECT *hNode,
-			  u32 ulRMSFxn, u32 ulCreateFxn,
-			  IN CONST struct NODE_CREATEARGS *pArgs,
-			  OUT NODE_ENV *pNodeEnv)
-{
-	struct NODE_MSGARGS msgArgs;
-	struct NODE_TASKARGS taskArgs;
-	struct RMS_Command *pCommand;
-	struct RMS_MsgArgs *pMsgArgs;
-	struct RMS_MoreTaskArgs *pMoreTaskArgs;
-	enum NODE_TYPE nodeType;
-	u32 dwLength;
-	RMS_WORD *pdwBuf = NULL;
-	u32 ulBytes;
+dsp_status disp_node_create(struct disp_object *disp_obj,
+			    struct node_object *hnode, u32 ulRMSFxn,
+			    u32 ul_create_fxn,
+			    IN CONST struct node_createargs *pargs,
+			    OUT nodeenv *pNodeEnv)
+{
+	struct node_msgargs node_msg_args;
+	struct node_taskargs task_arg_obj;
+	struct rms_command *rms_cmd;
+	struct rms_msg_args *pmsg_args;
+	struct rms_more_task_args *more_task_args;
+	enum node_type node_type;
+	u32 dw_length;
+	rms_word *pdw_buf = NULL;
+	u32 ul_bytes;
 	u32 i;
 	u32 total;
-	u32 uCharsInRMSWord;
-	s32 taskArgsOffset;
-	s32 sioInDefOffset;
-	s32 sioOutDefOffset;
-	s32 sioDefsOffset;
-	s32 argsOffset = -1;
+	u32 chars_in_rms_word;
+	s32 task_args_offset;
+	s32 sio_in_def_offset;
+	s32 sio_out_def_offset;
+	s32 sio_defs_offset;
+	s32 args_offset = -1;
 	s32 offset;
-	struct NODE_STRMDEF strmDef;
+	struct node_strmdef strm_def;
 	u32 max;
-	DSP_STATUS status = DSP_SOK;
-	struct DSP_NODEINFO nodeInfo;
-	u32 devType;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
-	DBC_Require(hNode != NULL);
-	DBC_Require(NODE_GetType(hNode) != NODE_DEVICE);
-	DBC_Require(pNodeEnv != NULL);
-
-	GT_6trace(DISP_DebugMask, GT_ENTER,
-	     "DISP_NodeCreate: hDisp: 0x%x\thNode:"
-	     " 0x%x\tulRMSFxn: 0x%x\tulCreateFxn: 0x%x\tpArgs: 0x%x\tpNodeEnv:"
-	     " 0x%x\n", hDisp, hNode, ulRMSFxn, ulCreateFxn, pArgs, pNodeEnv);
+	dsp_status status = DSP_SOK;
+	struct dsp_nodeinfo node_info;
+	u32 dev_type;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(disp_obj, DISP_SIGNATURE));
+	DBC_REQUIRE(hnode != NULL);
+	DBC_REQUIRE(node_get_type(hnode) != NODE_DEVICE);
+	DBC_REQUIRE(pNodeEnv != NULL);
 
-	status = DEV_GetDevType(hDisp->hDevObject, &devType);
-
-	GT_1trace(DISP_DebugMask, GT_6CLASS, "DISP_Create: Creating DISP "
-		 "for device = 0x%x\n", devType);
+	status = dev_get_dev_type(disp_obj->hdev_obj, &dev_type);
 
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	if (devType != DSP_UNIT) {
-		GT_1trace(DISP_DebugMask, GT_7CLASS,
-			 "DISP_NodeCreate unknown device "
-			 "type = 0x%x\n", devType);
+	if (dev_type != DSP_UNIT) {
+		dev_dbg(bridge, "%s: unknown device type = 0x%x\n",
+			__func__, dev_type);
 		goto func_end;
 	}
-	DBC_Require(pArgs != NULL);
-	nodeType = NODE_GetType(hNode);
-	msgArgs = pArgs->asa.msgArgs;
-	max = hDisp->ulBufsizeRMS;    /*Max # of RMS words that can be sent */
-	DBC_Assert(max == RMS_COMMANDBUFSIZE);
-	uCharsInRMSWord = sizeof(RMS_WORD) / hDisp->uCharSize;
+	DBC_REQUIRE(pargs != NULL);
+	node_type = node_get_type(hnode);
+	node_msg_args = pargs->asa.node_msg_args;
+	max = disp_obj->ul_bufsize_rms;	/*Max # of RMS words that can be sent */
+	DBC_ASSERT(max == RMS_COMMANDBUFSIZE);
+	chars_in_rms_word = sizeof(rms_word) / disp_obj->char_size;
 	/* Number of RMS words needed to hold arg data */
-	dwLength = (msgArgs.uArgLength + uCharsInRMSWord - 1) / uCharsInRMSWord;
+	dw_length =
+	    (node_msg_args.arg_length + chars_in_rms_word -
+	     1) / chars_in_rms_word;
 	/* Make sure msg args and command fit in buffer */
-	total = sizeof(struct RMS_Command) / sizeof(RMS_WORD) +
-		sizeof(struct RMS_MsgArgs)
-		/ sizeof(RMS_WORD)  - 1 + dwLength;
+	total = sizeof(struct rms_command) / sizeof(rms_word) +
+	    sizeof(struct rms_msg_args)
+	    / sizeof(rms_word) - 1 + dw_length;
 	if (total >= max) {
 		status = DSP_EFAIL;
-		GT_2trace(DISP_DebugMask, GT_6CLASS,
-			"DISP_NodeCreate: Message args too"
-			" large for buffer! Message args size = %d, max = %d\n",
-			total, max);
+		dev_dbg(bridge, "%s: Message args too large for buffer! size "
+			"= %d, max = %d\n", __func__, total, max);
 	}
 	/*
 	 *  Fill in buffer to send to RMS.
@@ -450,145 +355,130 @@
 	 *
 	 */
 	if (DSP_SUCCEEDED(status)) {
-		total = 0; 	/* Total number of words in buffer so far */
-		pdwBuf = (RMS_WORD *)hDisp->pBuf;
-		pCommand = (struct RMS_Command *)pdwBuf;
-		pCommand->fxn = (RMS_WORD)(ulRMSFxn);
-		pCommand->arg1 = (RMS_WORD)(ulCreateFxn);
-		if (NODE_GetLoadType(hNode) == NLDR_DYNAMICLOAD) {
+		total = 0;	/* Total number of words in buffer so far */
+		pdw_buf = (rms_word *) disp_obj->pbuf;
+		rms_cmd = (struct rms_command *)pdw_buf;
+		rms_cmd->fxn = (rms_word) (ulRMSFxn);
+		rms_cmd->arg1 = (rms_word) (ul_create_fxn);
+		if (node_get_load_type(hnode) == NLDR_DYNAMICLOAD) {
 			/* Flush ICACHE on Load */
-			pCommand->arg2 = 1; 	/* dummy argument */
+			rms_cmd->arg2 = 1;	/* dummy argument */
 		} else {
 			/* Do not flush ICACHE */
-			pCommand->arg2 = 0; 	/* dummy argument */
+			rms_cmd->arg2 = 0;	/* dummy argument */
 		}
-		pCommand->data = NODE_GetType(hNode);
+		rms_cmd->data = node_get_type(hnode);
 		/*
-		 *  argsOffset is the offset of the data field in struct
-		 *  RMS_Command structure. We need this to calculate stream
+		 *  args_offset is the offset of the data field in struct
+		 *  rms_command structure. We need this to calculate stream
 		 *  definition offsets.
 		 */
-		argsOffset = 3;
-		total += sizeof(struct RMS_Command) / sizeof(RMS_WORD);
+		args_offset = 3;
+		total += sizeof(struct rms_command) / sizeof(rms_word);
 		/* Message args */
-		pMsgArgs = (struct RMS_MsgArgs *) (pdwBuf + total);
-		pMsgArgs->maxMessages = msgArgs.uMaxMessages;
-		pMsgArgs->segid = msgArgs.uSegid;
-		pMsgArgs->notifyType = msgArgs.uNotifyType;
-		pMsgArgs->argLength = msgArgs.uArgLength;
-		total += sizeof(struct RMS_MsgArgs) / sizeof(RMS_WORD) - 1;
-		memcpy(pdwBuf + total, msgArgs.pData, msgArgs.uArgLength);
-		total += dwLength;
+		pmsg_args = (struct rms_msg_args *)(pdw_buf + total);
+		pmsg_args->max_msgs = node_msg_args.max_msgs;
+		pmsg_args->segid = node_msg_args.seg_id;
+		pmsg_args->notify_type = node_msg_args.notify_type;
+		pmsg_args->arg_length = node_msg_args.arg_length;
+		total += sizeof(struct rms_msg_args) / sizeof(rms_word) - 1;
+		memcpy(pdw_buf + total, node_msg_args.pdata,
+		       node_msg_args.arg_length);
+		total += dw_length;
 	}
 	if (DSP_FAILED(status))
 		goto func_end;
 
 	/* If node is a task node, copy task create arguments into  buffer */
-	if (nodeType == NODE_TASK || nodeType == NODE_DAISSOCKET) {
-		taskArgs = pArgs->asa.taskArgs;
-		taskArgsOffset = total;
-		total += sizeof(struct RMS_MoreTaskArgs) / sizeof(RMS_WORD) +
-			1 + taskArgs.uNumInputs + taskArgs.uNumOutputs;
+	if (node_type == NODE_TASK || node_type == NODE_DAISSOCKET) {
+		task_arg_obj = pargs->asa.task_arg_obj;
+		task_args_offset = total;
+		total += sizeof(struct rms_more_task_args) / sizeof(rms_word) +
+		    1 + task_arg_obj.num_inputs + task_arg_obj.num_outputs;
 		/* Copy task arguments */
 		if (total < max) {
-			total = taskArgsOffset;
-			pMoreTaskArgs = (struct RMS_MoreTaskArgs *)(pdwBuf +
-					total);
+			total = task_args_offset;
+			more_task_args = (struct rms_more_task_args *)(pdw_buf +
+								       total);
 			/*
 			 * Get some important info about the node. Note that we
-			 * don't just reach into the hNode struct because
+			 * don't just reach into the hnode struct because
 			 * that would break the node object's abstraction.
 			 */
-			GetNodeInfo(hNode, &nodeInfo);
-			GT_2trace(DISP_DebugMask, GT_ENTER,
-				 "uExecutionPriority %x, nPriority %x\n",
-				 nodeInfo.uExecutionPriority,
-				 taskArgs.nPriority);
-			pMoreTaskArgs->priority = nodeInfo.uExecutionPriority;
-			pMoreTaskArgs->stackSize = taskArgs.uStackSize;
-			pMoreTaskArgs->sysstackSize = taskArgs.uSysStackSize;
-			pMoreTaskArgs->stackSeg = taskArgs.uStackSeg;
-			pMoreTaskArgs->heapAddr = taskArgs.uDSPHeapAddr;
-			pMoreTaskArgs->heapSize = taskArgs.uHeapSize;
-			pMoreTaskArgs->misc = taskArgs.ulDaisArg;
-			pMoreTaskArgs->numInputStreams = taskArgs.uNumInputs;
+			get_node_info(hnode, &node_info);
+			more_task_args->priority = node_info.execution_priority;
+			more_task_args->stack_size = task_arg_obj.stack_size;
+			more_task_args->sysstack_size =
+			    task_arg_obj.sys_stack_size;
+			more_task_args->stack_seg = task_arg_obj.stack_seg;
+			more_task_args->heap_addr = task_arg_obj.udsp_heap_addr;
+			more_task_args->heap_size = task_arg_obj.heap_size;
+			more_task_args->misc = task_arg_obj.ul_dais_arg;
+			more_task_args->num_input_streams =
+			    task_arg_obj.num_inputs;
 			total +=
-			    sizeof(struct RMS_MoreTaskArgs) / sizeof(RMS_WORD);
-			GT_2trace(DISP_DebugMask, GT_7CLASS,
-				 "DISP::::uDSPHeapAddr %x, "
-				 "uHeapSize %x\n", taskArgs.uDSPHeapAddr,
-				 taskArgs.uHeapSize);
+			    sizeof(struct rms_more_task_args) /
+			    sizeof(rms_word);
+			dev_dbg(bridge, "%s: udsp_heap_addr %x, heap_size %x\n",
+				__func__, task_arg_obj.udsp_heap_addr,
+				task_arg_obj.heap_size);
 			/* Keep track of pSIOInDef[] and pSIOOutDef[]
 			 * positions in the buffer, since this needs to be
-			 * filled in later.  */
-			sioInDefOffset = total;
-			total += taskArgs.uNumInputs;
-			pdwBuf[total++] = taskArgs.uNumOutputs;
-			sioOutDefOffset = total;
-			total += taskArgs.uNumOutputs;
-			sioDefsOffset = total;
+			 * filled in later. */
+			sio_in_def_offset = total;
+			total += task_arg_obj.num_inputs;
+			pdw_buf[total++] = task_arg_obj.num_outputs;
+			sio_out_def_offset = total;
+			total += task_arg_obj.num_outputs;
+			sio_defs_offset = total;
 			/* Fill SIO defs and offsets */
-			offset = sioDefsOffset;
-			for (i = 0; i < taskArgs.uNumInputs; i++) {
+			offset = sio_defs_offset;
+			for (i = 0; i < task_arg_obj.num_inputs; i++) {
 				if (DSP_FAILED(status))
 					break;
 
-				pdwBuf[sioInDefOffset + i] =
-					(offset - argsOffset)
-					* (sizeof(RMS_WORD) / DSPWORDSIZE);
-				strmDef = taskArgs.strmInDef[i];
-				status = FillStreamDef(pdwBuf, &total, offset,
-					 strmDef, max, uCharsInRMSWord);
+				pdw_buf[sio_in_def_offset + i] =
+				    (offset - args_offset)
+				    * (sizeof(rms_word) / DSPWORDSIZE);
+				strm_def = task_arg_obj.strm_in_def[i];
+				status =
+				    fill_stream_def(pdw_buf, &total, offset,
+						    strm_def, max,
+						    chars_in_rms_word);
 				offset = total;
 			}
-			for (i = 0;  (i < taskArgs.uNumOutputs) &&
-			    (DSP_SUCCEEDED(status)); i++) {
-				pdwBuf[sioOutDefOffset + i] =
-					(offset - argsOffset)
-					* (sizeof(RMS_WORD) / DSPWORDSIZE);
-				strmDef = taskArgs.strmOutDef[i];
-				status = FillStreamDef(pdwBuf, &total, offset,
-					 strmDef, max, uCharsInRMSWord);
+			for (i = 0; (i < task_arg_obj.num_outputs) &&
+			     (DSP_SUCCEEDED(status)); i++) {
+				pdw_buf[sio_out_def_offset + i] =
+				    (offset - args_offset)
+				    * (sizeof(rms_word) / DSPWORDSIZE);
+				strm_def = task_arg_obj.strm_out_def[i];
+				status =
+				    fill_stream_def(pdw_buf, &total, offset,
+						    strm_def, max,
+						    chars_in_rms_word);
 				offset = total;
 			}
-			if (DSP_FAILED(status)) {
-				GT_2trace(DISP_DebugMask, GT_6CLASS,
-				      "DISP_NodeCreate: Message"
-				      " args to large for buffer! Message args"
-				      " size = %d, max = %d\n", total, max);
-			}
 		} else {
 			/* Args won't fit */
 			status = DSP_EFAIL;
-			GT_2trace(DISP_DebugMask, GT_6CLASS,
-				 "DISP_NodeCreate: Message args "
-				 " too large for buffer! Message args size = %d"
-				 ", max = %d\n", total, max);
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
-		ulBytes = total * sizeof(RMS_WORD);
-		DBC_Assert(ulBytes < (RMS_COMMANDBUFSIZE * sizeof(RMS_WORD)));
-		status = SendMessage(hDisp, NODE_GetTimeout(hNode),
-			 ulBytes, pNodeEnv);
-		if (DSP_FAILED(status)) {
-			GT_1trace(DISP_DebugMask, GT_6CLASS,
-				  "DISP_NodeCreate  failed! "
-				  "status = 0x%x\n", status);
-		} else {
+		ul_bytes = total * sizeof(rms_word);
+		DBC_ASSERT(ul_bytes < (RMS_COMMANDBUFSIZE * sizeof(rms_word)));
+		status = send_message(disp_obj, node_get_timeout(hnode),
+				      ul_bytes, pNodeEnv);
+		if (DSP_SUCCEEDED(status)) {
 			/*
 			 * Message successfully received from RMS.
 			 * Return the status of the Node's create function
 			 * on the DSP-side
 			 */
-			status = (((RMS_WORD *)(hDisp->pBuf))[0]);
-			if (DSP_FAILED(status)) {
-				GT_1trace(DISP_DebugMask, GT_6CLASS,
-					 "DISP_NodeCreate, "
-					 "DSP-side Node Create failed: 0x%x\n",
-					 status);
-			}
-
+			status = (((rms_word *) (disp_obj->pbuf))[0]);
+			if (DSP_FAILED(status))
+				dev_dbg(bridge, "%s: DSP-side failed: 0x%x\n",
+					__func__, status);
 		}
 	}
 func_end:
@@ -596,199 +486,176 @@
 }
 
 /*
- *  ======== DISP_NodeDelete ========
+ *  ======== disp_node_delete ========
  *  purpose:
  *      Delete a node on the DSP by remotely calling the node's delete function.
  *
  */
-DSP_STATUS DISP_NodeDelete(struct DISP_OBJECT *hDisp, struct NODE_OBJECT *hNode,
-			  u32 ulRMSFxn, u32 ulDeleteFxn, NODE_ENV nodeEnv)
+dsp_status disp_node_delete(struct disp_object *disp_obj,
+			    struct node_object *hnode, u32 ulRMSFxn,
+			    u32 ul_delete_fxn, nodeenv node_env)
 {
-	u32 dwArg;
-	struct RMS_Command *pCommand;
-	DSP_STATUS status = DSP_SOK;
-	u32 devType;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
-	DBC_Require(hNode != NULL);
-
-	GT_5trace(DISP_DebugMask, GT_ENTER,
-		 "DISP_NodeDelete: hDisp: 0x%xthNode: "
-		 "0x%x\tulRMSFxn: 0x%x\tulDeleteFxn: 0x%x\tnodeEnv: 0x%x\n",
-		 hDisp, hNode, ulRMSFxn, ulDeleteFxn, nodeEnv);
+	u32 dw_arg;
+	struct rms_command *rms_cmd;
+	dsp_status status = DSP_SOK;
+	u32 dev_type;
 
-	status = DEV_GetDevType(hDisp->hDevObject, &devType);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(disp_obj, DISP_SIGNATURE));
+	DBC_REQUIRE(hnode != NULL);
+
+	status = dev_get_dev_type(disp_obj->hdev_obj, &dev_type);
 
 	if (DSP_SUCCEEDED(status)) {
 
-		if (devType == DSP_UNIT) {
+		if (dev_type == DSP_UNIT) {
 
 			/*
 			 *  Fill in buffer to send to RMS
 			 */
-			pCommand = (struct RMS_Command *)hDisp->pBuf;
-			pCommand->fxn = (RMS_WORD)(ulRMSFxn);
-			pCommand->arg1 = (RMS_WORD)nodeEnv;
-			pCommand->arg2 = (RMS_WORD)(ulDeleteFxn);
-			pCommand->data = NODE_GetType(hNode);
-
-			status = SendMessage(hDisp, NODE_GetTimeout(hNode),
-					    sizeof(struct RMS_Command), &dwArg);
-			if (DSP_FAILED(status)) {
-				GT_1trace(DISP_DebugMask, GT_6CLASS,
-					 "DISP_NodeDelete failed!"
-					 "status = 0x%x\n", status);
-			} else {
+			rms_cmd = (struct rms_command *)disp_obj->pbuf;
+			rms_cmd->fxn = (rms_word) (ulRMSFxn);
+			rms_cmd->arg1 = (rms_word) node_env;
+			rms_cmd->arg2 = (rms_word) (ul_delete_fxn);
+			rms_cmd->data = node_get_type(hnode);
+
+			status = send_message(disp_obj, node_get_timeout(hnode),
+					      sizeof(struct rms_command),
+					      &dw_arg);
+			if (DSP_SUCCEEDED(status)) {
 				/*
 				 * Message successfully received from RMS.
 				 * Return the status of the Node's delete
 				 * function on the DSP-side
 				 */
-				status = (((RMS_WORD *)(hDisp->pBuf))[0]);
-				if (DSP_FAILED(status)) {
-					GT_1trace(DISP_DebugMask, GT_6CLASS,
-					 "DISP_NodeDelete, "
-					 "DSP-side Node Delete failed: 0x%x\n",
-					 status);
-				}
+				status = (((rms_word *) (disp_obj->pbuf))[0]);
+				if (DSP_FAILED(status))
+					dev_dbg(bridge, "%s: DSP-side failed: "
+						"0x%x\n", __func__, status);
 			}
 
-
 		}
 	}
 	return status;
 }
 
 /*
- *  ======== DISP_NodeRun ========
+ *  ======== disp_node_run ========
  *  purpose:
  *      Start execution of a node's execute phase, or resume execution of a node
  *      that has been suspended (via DISP_NodePause()) on the DSP.
  */
-DSP_STATUS DISP_NodeRun(struct DISP_OBJECT *hDisp, struct NODE_OBJECT *hNode,
-			u32 ulRMSFxn, u32 ulExecuteFxn, NODE_ENV nodeEnv)
+dsp_status disp_node_run(struct disp_object *disp_obj,
+			 struct node_object *hnode, u32 ulRMSFxn,
+			 u32 ul_execute_fxn, nodeenv node_env)
 {
-	u32 dwArg;
-	struct RMS_Command *pCommand;
-	DSP_STATUS status = DSP_SOK;
-	u32 devType;
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
-	DBC_Require(hNode != NULL);
-
-	GT_5trace(DISP_DebugMask, GT_ENTER, "DISP_NodeRun: hDisp: 0x%xthNode: \
-		 0x%x\tulRMSFxn: 0x%x\tulExecuteFxn: 0x%x\tnodeEnv: 0x%x\n", \
-		 hDisp, hNode, ulRMSFxn, ulExecuteFxn, nodeEnv);
+	u32 dw_arg;
+	struct rms_command *rms_cmd;
+	dsp_status status = DSP_SOK;
+	u32 dev_type;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(disp_obj, DISP_SIGNATURE));
+	DBC_REQUIRE(hnode != NULL);
 
-	status = DEV_GetDevType(hDisp->hDevObject, &devType);
+	status = dev_get_dev_type(disp_obj->hdev_obj, &dev_type);
 
 	if (DSP_SUCCEEDED(status)) {
 
-		if (devType == DSP_UNIT) {
+		if (dev_type == DSP_UNIT) {
 
 			/*
 			 *  Fill in buffer to send to RMS.
 			 */
-			pCommand = (struct RMS_Command *) hDisp->pBuf;
-			pCommand->fxn = (RMS_WORD) (ulRMSFxn);
-			pCommand->arg1 = (RMS_WORD) nodeEnv;
-			pCommand->arg2 = (RMS_WORD) (ulExecuteFxn);
-			pCommand->data = NODE_GetType(hNode);
-
-			status = SendMessage(hDisp, NODE_GetTimeout(hNode),
-				 sizeof(struct RMS_Command), &dwArg);
-			if (DSP_FAILED(status)) {
-				GT_1trace(DISP_DebugMask, GT_6CLASS,
-					 "DISP_NodeRun failed!"
-					 "status = 0x%x\n", status);
-			} else {
+			rms_cmd = (struct rms_command *)disp_obj->pbuf;
+			rms_cmd->fxn = (rms_word) (ulRMSFxn);
+			rms_cmd->arg1 = (rms_word) node_env;
+			rms_cmd->arg2 = (rms_word) (ul_execute_fxn);
+			rms_cmd->data = node_get_type(hnode);
+
+			status = send_message(disp_obj, node_get_timeout(hnode),
+					      sizeof(struct rms_command),
+					      &dw_arg);
+			if (DSP_SUCCEEDED(status)) {
 				/*
 				 * Message successfully received from RMS.
 				 * Return the status of the Node's execute
 				 * function on the DSP-side
 				 */
-				status = (((RMS_WORD *)(hDisp->pBuf))[0]);
-				if (DSP_FAILED(status)) {
-					GT_1trace(DISP_DebugMask, GT_6CLASS,
-						"DISP_NodeRun, DSP-side Node "
-						"Execute failed: 0x%x\n",
-						status);
-		}
-		}
+				status = (((rms_word *) (disp_obj->pbuf))[0]);
+				if (DSP_FAILED(status))
+					dev_dbg(bridge, "%s: DSP-side failed: "
+						"0x%x\n", __func__, status);
+			}
 
-	}
+		}
 	}
 
 	return status;
 }
 
 /*
- *  ======== DeleteDisp ========
+ *  ======== delete_disp ========
  *  purpose:
  *      Frees the resources allocated for the dispatcher.
  */
-static void DeleteDisp(struct DISP_OBJECT *hDisp)
+static void delete_disp(struct disp_object *disp_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
+	dsp_status status = DSP_SOK;
+	struct bridge_drv_interface *intf_fxns;
 
-	if (MEM_IsValidHandle(hDisp, DISP_SIGNATURE)) {
-		pIntfFxns = hDisp->pIntfFxns;
+	if (MEM_IS_VALID_HANDLE(disp_obj, DISP_SIGNATURE)) {
+		intf_fxns = disp_obj->intf_fxns;
 
 		/* Free Node Dispatcher resources */
-		if (hDisp->hChnlFromDsp) {
+		if (disp_obj->chnl_from_dsp) {
 			/* Channel close can fail only if the channel handle
 			 * is invalid. */
-			status = (*pIntfFxns->pfnChnlClose)
-				 (hDisp->hChnlFromDsp);
+			status = (*intf_fxns->pfn_chnl_close)
+			    (disp_obj->chnl_from_dsp);
 			if (DSP_FAILED(status)) {
-				GT_1trace(DISP_DebugMask, GT_6CLASS,
-					 "DISP_Delete: Failed to "
-					 "close channel from RMS: 0x%x\n",
-					 status);
+				dev_dbg(bridge, "%s: Failed to close channel "
+					"from RMS: 0x%x\n", __func__, status);
 			}
 		}
-		if (hDisp->hChnlToDsp) {
-			status = (*pIntfFxns->pfnChnlClose)(hDisp->hChnlToDsp);
+		if (disp_obj->chnl_to_dsp) {
+			status =
+			    (*intf_fxns->pfn_chnl_close) (disp_obj->
+							  chnl_to_dsp);
 			if (DSP_FAILED(status)) {
-				GT_1trace(DISP_DebugMask, GT_6CLASS,
-					 "DISP_Delete: Failed to "
-					 "close channel to RMS: 0x%x\n",
-					 status);
+				dev_dbg(bridge, "%s: Failed to close channel to"
+					" RMS: 0x%x\n", __func__, status);
 			}
 		}
-		if (hDisp->pBuf)
-			MEM_Free(hDisp->pBuf);
+		kfree(disp_obj->pbuf);
 
-		MEM_FreeObject(hDisp);
+		MEM_FREE_OBJECT(disp_obj);
 	}
 }
 
 /*
- *  ======== FillStreamDef ========
+ *  ======== fill_stream_def ========
  *  purpose:
  *      Fills stream definitions.
  */
-static DSP_STATUS FillStreamDef(RMS_WORD *pdwBuf, u32 *ptotal, u32 offset,
-				struct NODE_STRMDEF strmDef, u32 max,
-				u32 uCharsInRMSWord)
+static dsp_status fill_stream_def(rms_word *pdw_buf, u32 *ptotal, u32 offset,
+				  struct node_strmdef strm_def, u32 max,
+				  u32 chars_in_rms_word)
 {
-	struct RMS_StrmDef *pStrmDef;
+	struct rms_strm_def *strm_def_obj;
 	u32 total = *ptotal;
-	u32 uNameLen;
-	u32 dwLength;
-	DSP_STATUS status = DSP_SOK;
+	u32 name_len;
+	u32 dw_length;
+	dsp_status status = DSP_SOK;
 
-	if (total + sizeof(struct RMS_StrmDef) / sizeof(RMS_WORD) >= max) {
+	if (total + sizeof(struct rms_strm_def) / sizeof(rms_word) >= max) {
 		status = DSP_EFAIL;
 	} else {
-		pStrmDef = (struct RMS_StrmDef *)(pdwBuf + total);
-		pStrmDef->bufsize = strmDef.uBufsize;
-		pStrmDef->nbufs = strmDef.uNumBufs;
-		pStrmDef->segid = strmDef.uSegid;
-		pStrmDef->align = strmDef.uAlignment;
-		pStrmDef->timeout = strmDef.uTimeout;
+		strm_def_obj = (struct rms_strm_def *)(pdw_buf + total);
+		strm_def_obj->bufsize = strm_def.buf_size;
+		strm_def_obj->nbufs = strm_def.num_bufs;
+		strm_def_obj->segid = strm_def.seg_id;
+		strm_def_obj->align = strm_def.buf_alignment;
+		strm_def_obj->timeout = strm_def.utimeout;
 	}
 
 	if (DSP_SUCCEEDED(status)) {
@@ -796,24 +663,25 @@
 		 *  Since we haven't added the device name yet, subtract
 		 *  1 from total.
 		 */
-		total += sizeof(struct RMS_StrmDef) / sizeof(RMS_WORD) - 1;
-               DBC_Require(strmDef.szDevice);
-               dwLength = strlen(strmDef.szDevice) + 1;
+		total += sizeof(struct rms_strm_def) / sizeof(rms_word) - 1;
+		DBC_REQUIRE(strm_def.sz_device);
+		dw_length = strlen(strm_def.sz_device) + 1;
 
 		/* Number of RMS_WORDS needed to hold device name */
-		uNameLen = (dwLength + uCharsInRMSWord - 1) / uCharsInRMSWord;
+		name_len =
+		    (dw_length + chars_in_rms_word - 1) / chars_in_rms_word;
 
-		if (total + uNameLen >= max) {
+		if (total + name_len >= max) {
 			status = DSP_EFAIL;
 		} else {
 			/*
 			 *  Zero out last word, since the device name may not
 			 *  extend to completely fill this word.
 			 */
-			pdwBuf[total + uNameLen - 1] = 0;
-			/** TODO USE SERVICES **/
-			memcpy(pdwBuf + total, strmDef.szDevice, dwLength);
-			total += uNameLen;
+			pdw_buf[total + name_len - 1] = 0;
+			/** TODO USE SERVICES * */
+			memcpy(pdw_buf + total, strm_def.sz_device, dw_length);
+			total += name_len;
 			*ptotal = total;
 		}
 	}
@@ -822,94 +690,71 @@
 }
 
 /*
- *  ======== SendMessage ======
+ *  ======== send_message ======
  *  Send command message to RMS, get reply from RMS.
  */
-static DSP_STATUS SendMessage(struct DISP_OBJECT *hDisp, u32 dwTimeout,
-			     u32 ulBytes, u32 *pdwArg)
+static dsp_status send_message(struct disp_object *disp_obj, u32 dwTimeout,
+			       u32 ul_bytes, u32 *pdw_arg)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct CHNL_OBJECT *hChnl;
-	u32 dwArg = 0;
-	u8 *pBuf;
-	struct CHNL_IOC chnlIOC;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(pdwArg != NULL);
-
-	*pdwArg = (u32) NULL;
-	pIntfFxns = hDisp->pIntfFxns;
-	hChnl = hDisp->hChnlToDsp;
-	pBuf = hDisp->pBuf;
+	struct bridge_drv_interface *intf_fxns;
+	struct chnl_object *chnl_obj;
+	u32 dw_arg = 0;
+	u8 *pbuf;
+	struct chnl_ioc chnl_ioc_obj;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(pdw_arg != NULL);
+
+	*pdw_arg = (u32) NULL;
+	intf_fxns = disp_obj->intf_fxns;
+	chnl_obj = disp_obj->chnl_to_dsp;
+	pbuf = disp_obj->pbuf;
 
 	/* Send the command */
-	status = (*pIntfFxns->pfnChnlAddIOReq) (hChnl, pBuf, ulBytes, 0,
-		 0L, dwArg);
+	status = (*intf_fxns->pfn_chnl_add_io_req) (chnl_obj, pbuf, ul_bytes, 0,
+						    0L, dw_arg);
+	if (DSP_FAILED(status))
+		goto func_end;
 
-	if (DSP_FAILED(status)) {
-		GT_1trace(DISP_DebugMask, GT_6CLASS,
-			 "SendMessage: Channel AddIOReq to"
-			 " RMS failed! Status = 0x%x\n", status);
-		goto func_cont;
-	}
-	status = (*pIntfFxns->pfnChnlGetIOC) (hChnl, dwTimeout, &chnlIOC);
+	status =
+	    (*intf_fxns->pfn_chnl_get_ioc) (chnl_obj, dwTimeout, &chnl_ioc_obj);
 	if (DSP_SUCCEEDED(status)) {
-		if (!CHNL_IsIOComplete(chnlIOC)) {
-			if (CHNL_IsTimedOut(chnlIOC)) {
+		if (!CHNL_IS_IO_COMPLETE(chnl_ioc_obj)) {
+			if (CHNL_IS_TIMED_OUT(chnl_ioc_obj))
 				status = DSP_ETIMEOUT;
-			} else {
-				GT_1trace(DISP_DebugMask, GT_6CLASS,
-					 "SendMessage failed! "
-					 "Channel IOC status = 0x%x\n",
-					 chnlIOC.status);
+			else
 				status = DSP_EFAIL;
-			}
 		}
-	} else {
-		GT_1trace(DISP_DebugMask, GT_6CLASS,
-			 "SendMessage: Channel GetIOC to"
-			 " RMS failed! Status = 0x%x\n", status);
 	}
-func_cont:
 	/* Get the reply */
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	hChnl = hDisp->hChnlFromDsp;
-	ulBytes = REPLYSIZE;
-	status = (*pIntfFxns->pfnChnlAddIOReq)(hChnl, pBuf, ulBytes,
-		 0, 0L, dwArg);
-	if (DSP_FAILED(status)) {
-		GT_1trace(DISP_DebugMask, GT_6CLASS,
-			 "SendMessage: Channel AddIOReq "
-			 "from RMS failed! Status = 0x%x\n", status);
+	chnl_obj = disp_obj->chnl_from_dsp;
+	ul_bytes = REPLYSIZE;
+	status = (*intf_fxns->pfn_chnl_add_io_req) (chnl_obj, pbuf, ul_bytes,
+						    0, 0L, dw_arg);
+	if (DSP_FAILED(status))
 		goto func_end;
-	}
-	status = (*pIntfFxns->pfnChnlGetIOC) (hChnl, dwTimeout, &chnlIOC);
+
+	status =
+	    (*intf_fxns->pfn_chnl_get_ioc) (chnl_obj, dwTimeout, &chnl_ioc_obj);
 	if (DSP_SUCCEEDED(status)) {
-		if (CHNL_IsTimedOut(chnlIOC)) {
+		if (CHNL_IS_TIMED_OUT(chnl_ioc_obj)) {
 			status = DSP_ETIMEOUT;
-		} else if (chnlIOC.cBytes < ulBytes) {
+		} else if (chnl_ioc_obj.byte_size < ul_bytes) {
 			/* Did not get all of the reply from the RMS */
-			GT_1trace(DISP_DebugMask, GT_6CLASS,
-				 "SendMessage: Did not get all"
-				 "of reply from RMS! Bytes received: %d\n",
-				 chnlIOC.cBytes);
 			status = DSP_EFAIL;
 		} else {
-			if (CHNL_IsIOComplete(chnlIOC)) {
-				DBC_Assert(chnlIOC.pBuf == pBuf);
-				status = (*((RMS_WORD *)chnlIOC.pBuf));
-				*pdwArg = (((RMS_WORD *)(chnlIOC.pBuf))[1]);
+			if (CHNL_IS_IO_COMPLETE(chnl_ioc_obj)) {
+				DBC_ASSERT(chnl_ioc_obj.pbuf == pbuf);
+				status = (*((rms_word *) chnl_ioc_obj.pbuf));
+				*pdw_arg =
+				    (((rms_word *) (chnl_ioc_obj.pbuf))[1]);
 			} else {
 				status = DSP_EFAIL;
 			}
 		}
-	} else {
-		/* GetIOC failed */
-		GT_1trace(DISP_DebugMask, GT_6CLASS,
-			 "SendMessage: Failed to get "
-			 "reply from RMS! Status = 0x%x\n", status);
 	}
 func_end:
 	return status;
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/drv.c kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/drv.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/drv.c	2011-10-11 13:51:19.504787763 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/rmgr/drv.c	2011-10-23 08:22:37.646645000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge resource allocation module.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,82 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== drv.c ========
- *  Description:
- *      DSP/BIOS Bridge resource allocation module.
- *
- *  Public Functions:
- *      DRV_Create
- *      DRV_Destroy
- *      DRV_Exit
- *      DRV_GetDevObject
- *      DRV_GetDevExtension
- *      DRV_GetFirstDevObject
- *      DRV_GetNextDevObject
- *      DRV_GetNextDevExtension
- *      DRV_Init
- *      DRV_InsertDevObject
- *      DRV_RemoveDevObject
- *      DRV_RequestResources
- *      DRV_ReleaseResources
- *
- *! Revision History
- *! ======== ========
- *! 19-Apr-2004 sb: Replaced OS specific APIs with MEM_AllocPhysMem and
-		    MEM_FreePhysMem. Fixed warnings. Cosmetic updates.
- *! 12-Apr-2004 hp: IVA clean up during bridge-uninstall
- *! 05-Jan-2004 vp: Updated for 24xx platform
- *! 21-Mar-2003 sb: Get SHM size from registry
- *! 10-Feb-2003 vp: Code review updates
- *! 18-Oct-2002 vp: Ported to Linux platform
- *! 30-Oct-2000 kc: Modified usage of REG_SetValue.
- *! 06-Sep-2000 jeh Read channel info into struct CFG_HOSTRES in
- *! 					RequestISAResources()
- *! 21-Sep-2000 rr: numwindows is calculated instead of default value in
- *!		 RequestISAResources.
- *! 07-Aug-2000 rr: static list of dev objects removed.
- *! 27-Jul-2000 rr: RequestResources split into two(Request and Release)
- *!		 Device extension created to hold the DevNodeString.
- *! 17-Jul-2000 rr: Driver Object holds the list of Device Objects.
- *!		 Added DRV_Create, DRV_Destroy, DRV_GetDevObject,
- *!		 DRV_GetFirst/NextDevObject, DRV_Insert/RemoveDevObject.
- *! 09-May-2000 rr: PCI Support is not L301 specific.Use of MEM_Calloc
- *!		 instead of MEM_Alloc.
- *! 28-Mar-2000 rr: PCI Support added. L301 Specific. TBD.
- *! 03-Feb-2000 rr: GT and Module Init/exit Changes. Merged with kc.
- *! 19-Jan-2000 rr: DBC_Ensure in RequestPCMCIA moved within PCCARD ifdef
- *! 29-Dec-1999 rr: PCCard support for any slot.Bus type stored in the
- *!		 struct CFG_HOSTRES Structure.
- *! 17-Dec-1999 rr: if PCCARD_Init fails we return DSP_EFAIL.
- *!		 DBC_Ensure checks for sucess and pDevice != NULL
- *! 11-Dec-1999 ag: #define "Isa" renamed to "IsaBus".
- *! 09-Dec-1999 rr: windows.h included to remove warnings.
- *! 02-Dec-1999 rr: struct GT_Mask is with in if DEBUG. Request resources checks
- *!		 status while making call to Reg functions.
- *! 23-Nov-1999 rr: windows.h included
- *! 19-Nov-1999 rr: DRV_RELEASE bug while setting the registry to zero.
- *!		 fixed.
- *! 12-Nov-1999 rr: RequestResources() reads values from the registry.
- *!		 Hardcoded bIRQRegister define removed.
- *! 05-Nov-1999 rr: Added hardcoded device interrupt.
- *! 25-Oct-1999 rr: Resource structure removed. Now it uses the Host
- *!		 Resource structure directly.
- *! 15-Oct-1999 rr: Resource Structure modified. See drv.h
- *!		 dwBusType taken from the registry.Hard coded
- *!		 registry entries removed.
- *! 05-Oct-1999 rr: Calling DEV_StartDevice moved to wcdce.c. DRV_Register
- *!		 MiniDriver has been renamed to DRV_RequestResources.
- *!		 DRV_UnRegisterMiniDriver fxn removed.
- *! 24-Sep-1999 rr: Significant changes to the RegisterMiniDriver fxns.
- *!		 Now it is simpler. IT stores the dev node in the
- *!		 registry, assign resources and calls the DEV_Start.
- *! 10-Sep-1999 rr: Register Minidriver modified.
- *!		 - Resource structure follows the NT model
- *! 08-Aug-1999 rr: Adopted for WinCE. Exports Fxns removed. Hull Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -100,1743 +26,1054 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/cfg.h>
-#include <dspbridge/csl.h>
 #include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/reg.h>
 
-/*  ----------------------------------- Others */
-#include <dspbridge/dbreg.h>
-
 /*  ----------------------------------- This */
 #include <dspbridge/drv.h>
 #include <dspbridge/dev.h>
 
-#ifndef RES_CLEANUP_DISABLE
 #include <dspbridge/node.h>
 #include <dspbridge/proc.h>
 #include <dspbridge/strm.h>
 #include <dspbridge/nodepriv.h>
 #include <dspbridge/wmdchnl.h>
 #include <dspbridge/resourcecleanup.h>
-#endif
 
 /*  ----------------------------------- Defines, Data Structures, Typedefs */
 #define SIGNATURE   0x5f52474d	/* "DRV_" (in reverse) */
 
-struct DRV_OBJECT {
-	u32 dwSignature;
-	struct LST_LIST *devList;
-	struct LST_LIST *devNodeString;
-#ifndef RES_CLEANUP_DISABLE
-	struct PROCESS_CONTEXT  *procCtxtList;
-#endif
+struct drv_object {
+	u32 dw_signature;
+	struct lst_list *dev_list;
+	struct lst_list *dev_node_string;
 };
 
 /*
  *  This is the Device Extension. Named with the Prefix
  *  DRV_ since it is living in this module
  */
-struct DRV_EXT {
-	struct LST_ELEM link;
-	char szString[MAXREGPATHLENGTH];
+struct drv_ext {
+	struct list_head link;
+	char sz_string[MAXREGPATHLENGTH];
 };
 
 /*  ----------------------------------- Globals */
-static s32 cRefs;
-
-#if GT_TRACE
-extern struct GT_Mask curTrace;
-#endif
+static s32 refs;
 
 /*  ----------------------------------- Function Prototypes */
-static DSP_STATUS RequestBridgeResources(u32 dwContext, s32 fRequest);
-static DSP_STATUS RequestBridgeResourcesDSP(u32 dwContext, s32 fRequest);
+static dsp_status request_bridge_resources(u32 dw_context, s32 fRequest);
+static dsp_status request_bridge_resources_dsp(u32 dw_context, s32 fRequest);
 
-#ifndef RES_CLEANUP_DISABLE
 /* GPP PROCESS CLEANUP CODE */
 
-static DSP_STATUS PrintProcessInformation(void);
-static DSP_STATUS DRV_ProcFreeNodeRes(HANDLE hPCtxt);
-static DSP_STATUS  DRV_ProcFreeSTRMRes(HANDLE hPCtxt);
-extern enum NODE_STATE NODE_GetState(HANDLE hNode);
-
-/* Get the process context list from driver object */
-
-/* Set the Process ID */
-DSP_STATUS DRV_ProcSetPID(HANDLE hPCtxt, s32 hProcess)
-{
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Assert(hPCtxt != NULL);
-
-	pCtxt->pid = hProcess;
-	return status;
-}
-
-
-/* Getting the head of the process context list */
-DSP_STATUS DRV_GetProcCtxtList(struct PROCESS_CONTEXT **pPctxt,
-				struct DRV_OBJECT *hDrvObject)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct DRV_OBJECT *pDrvObject = (struct DRV_OBJECT *)hDrvObject;
-
-	DBC_Assert(hDrvObject != NULL);
-	GT_2trace(curTrace, GT_ENTER,
-		"DRV_GetProcCtxtList: 2 *pPctxt:%x, pDrvObject"
-		":%x", *pPctxt, pDrvObject);
-	*pPctxt = pDrvObject->procCtxtList;
-	GT_2trace(curTrace, GT_ENTER,
-		"DRV_GetProcCtxtList: 3 *pPctxt:%x, pDrvObject"
-		":%x", *pPctxt, pDrvObject);
-	return status;
-}
-
-/* Add a new process context to process context list */
-DSP_STATUS DRV_InsertProcContext(struct DRV_OBJECT *hDrVObject, HANDLE hPCtxt)
-{
-	struct PROCESS_CONTEXT **pCtxt = (struct PROCESS_CONTEXT **)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct PROCESS_CONTEXT *pCtxtList = NULL;
-	struct DRV_OBJECT	     *hDRVObject;
-
-	GT_0trace(curTrace, GT_ENTER, "\n In DRV_InsertProcContext\n");
-
-	status = CFG_GetObject((u32 *)&hDRVObject, REG_DRV_OBJECT);
-	DBC_Assert(hDRVObject != NULL);
-
-	*pCtxt = MEM_Calloc(1 * sizeof(struct PROCESS_CONTEXT), MEM_PAGED);
-	if (!*pCtxt) {
-		pr_err("DSP: MEM_Calloc failed in DRV_InsertProcContext\n");
-		return DSP_EMEMORY;
-	}
-
-	spin_lock_init(&(*pCtxt)->proc_list_lock);
-	INIT_LIST_HEAD(&(*pCtxt)->processor_list);
-
-	spin_lock_init(&(*pCtxt)->dmm_list_lock);
-
-	GT_0trace(curTrace, GT_ENTER,
-		 "\n In DRV_InsertProcContext Calling "
-		 "DRV_GetProcCtxtList\n");
-	DRV_GetProcCtxtList(&pCtxtList, hDRVObject);
-	GT_0trace(curTrace, GT_ENTER,
-		 "\n In DRV_InsertProcContext After Calling "
-		 "DRV_GetProcCtxtList\n");
-	if (pCtxtList != NULL) {
-		GT_0trace(curTrace, GT_ENTER,
-			 "\n In DRV_InsertProcContext and pCtxt is "
-			 "not Null\n");
-		while (pCtxtList->next != NULL)
-			pCtxtList = pCtxtList->next;
-
-		pCtxtList->next = *pCtxt;
-	} else {
-		GT_0trace(curTrace, GT_ENTER,
-			 "\n In DRV_InsertProcContext and "
-			 "pCtxt is Null\n");
-		hDRVObject->procCtxtList = *pCtxt;
-	}
-	return status;
-}
-
-/* Delete a process context from process resource context list */
-DSP_STATUS DRV_RemoveProcContext(struct DRV_OBJECT *hDRVObject,
-		HANDLE pr_ctxt)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct PROCESS_CONTEXT *pr_ctxt_list = NULL;
-	struct PROCESS_CONTEXT *uninitialized_var(ptr_prev);
-
-	DBC_Assert(hDRVObject != NULL);
-
-	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveProcContext: 12");
-	DRV_GetProcCtxtList(&pr_ctxt_list, hDRVObject);
-
-	/* Special condition */
-	if (pr_ctxt_list == pr_ctxt) {
-		hDRVObject->procCtxtList = NULL;
-		goto func_cont;
-	}
-
-	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveProcContext: 13");
-	while (pr_ctxt_list && (pr_ctxt_list != pr_ctxt)) {
-		ptr_prev = pr_ctxt_list;
-		pr_ctxt_list = pr_ctxt_list->next;
-		GT_0trace(curTrace, GT_ENTER,
-			 "DRV_RemoveProcContext: 2");
-	}
-
-	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveProcContext: 3");
-
-	if (!pr_ctxt_list)
-		return DSP_ENOTFOUND;
-	else
-		ptr_prev->next = pr_ctxt_list->next;
-
-func_cont:
-	MEM_Free(pr_ctxt);
-	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveProcContext: 7");
-
-	return status;
-}
-
-/* Update the state of process context */
-DSP_STATUS DRV_ProcUpdatestate(HANDLE hPCtxt, enum GPP_PROC_RES_STATE status)
-{
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status1 = DSP_SOK;
-	if (pCtxt != NULL) {
-		pCtxt->resState = status;
-	} else {
-		GT_0trace(curTrace, GT_ENTER,
-			 "DRV_ProcUpdatestate: Failed to update "
-			 "process state");
-	}
-	return status1;
-}
+static dsp_status drv_proc_free_node_res(bhandle hPCtxt);
+extern enum node_state node_get_state(bhandle hnode);
 
 /* Allocate and add a node resource element
-* This function is called from .Node_Allocate.  */
-DSP_STATUS DRV_InsertNodeResElement(HANDLE hNode, HANDLE hNodeRes,
-					HANDLE hPCtxt)
-{
-	struct NODE_RES_OBJECT **pNodeRes = (struct NODE_RES_OBJECT **)hNodeRes;
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct NODE_RES_OBJECT   *pTempNodeRes = NULL;
-	GT_0trace(curTrace, GT_ENTER, "DRV_InsertNodeResElement: 1");
-	*pNodeRes = (struct NODE_RES_OBJECT *)MEM_Calloc
-		    (1 * sizeof(struct NODE_RES_OBJECT), MEM_PAGED);
-	DBC_Assert(hPCtxt != NULL);
-	if ((*pNodeRes == NULL) || (hPCtxt == NULL)) {
-		GT_0trace(curTrace, GT_ENTER, "DRV_InsertNodeResElement: 12");
+* This function is called from .Node_Allocate. */
+dsp_status drv_insert_node_res_element(bhandle hnode, bhandle hNodeRes,
+				       bhandle hPCtxt)
+{
+	struct node_res_object **node_res_obj =
+	    (struct node_res_object **)hNodeRes;
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	dsp_status status = DSP_SOK;
+	struct node_res_object *temp_node_res = NULL;
+
+	*node_res_obj = (struct node_res_object *)mem_calloc
+	    (1 * sizeof(struct node_res_object), MEM_PAGED);
+	if (*node_res_obj == NULL)
 		status = DSP_EHANDLE;
-	}
+
 	if (DSP_SUCCEEDED(status)) {
-		(*pNodeRes)->hNode = hNode;
-		if (pCtxt->pNodeList != NULL) {
-			pTempNodeRes = pCtxt->pNodeList;
-			while (pTempNodeRes->next != NULL)
-				pTempNodeRes = pTempNodeRes->next;
-
-			pTempNodeRes->next = *pNodeRes;
-			GT_0trace(curTrace, GT_ENTER,
-				 "DRV_InsertNodeResElement: 2");
+		if (mutex_lock_interruptible(&ctxt->node_mutex)) {
+			kfree(*node_res_obj);
+			return DSP_EFAIL;
+		}
+		(*node_res_obj)->hnode = hnode;
+		if (ctxt->node_list != NULL) {
+			temp_node_res = ctxt->node_list;
+			while (temp_node_res->next != NULL)
+				temp_node_res = temp_node_res->next;
+
+			temp_node_res->next = *node_res_obj;
 		} else {
-			pCtxt->pNodeList = *pNodeRes;
-			GT_0trace(curTrace, GT_ENTER,
-				 "DRV_InsertNodeResElement: 3");
+			ctxt->node_list = *node_res_obj;
 		}
+		mutex_unlock(&ctxt->node_mutex);
 	}
-	GT_0trace(curTrace, GT_ENTER, "DRV_InsertNodeResElement: 4");
+
 	return status;
 }
 
 /* Release all Node resources and its context
-* This is called from .Node_Delete.  */
-DSP_STATUS DRV_RemoveNodeResElement(HANDLE hNodeRes, HANDLE hPCtxt)
+* This is called from .Node_Delete. */
+dsp_status drv_remove_node_res_element(bhandle hNodeRes, bhandle hPCtxt)
 {
-	struct NODE_RES_OBJECT *pNodeRes = (struct NODE_RES_OBJECT *)hNodeRes;
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS	status = DSP_SOK;
-	struct NODE_RES_OBJECT *pTempNode2 = pCtxt->pNodeList;
-	struct NODE_RES_OBJECT *pTempNode = pCtxt->pNodeList;
-
-	DBC_Assert(hPCtxt != NULL);
-	GT_0trace(curTrace, GT_ENTER, "\nDRV_RemoveNodeResElement: 1\n");
-	while ((pTempNode != NULL) && (pTempNode != pNodeRes)) {
-		pTempNode2 = pTempNode;
-		pTempNode = pTempNode->next;
-	}
-	if (pCtxt->pNodeList == pNodeRes)
-		pCtxt->pNodeList = pNodeRes->next;
-
-	if (pTempNode == NULL)
-		return DSP_ENOTFOUND;
-	else if (pTempNode2->next != NULL)
-		pTempNode2->next = pTempNode2->next->next;
-
-	MEM_Free(pTempNode);
+	struct node_res_object *node_res_obj =
+	    (struct node_res_object *)hNodeRes;
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	struct node_res_object *temp_node;
+	dsp_status status = DSP_SOK;
+
+	if (mutex_lock_interruptible(&ctxt->node_mutex))
+		return DSP_EFAIL;
+	temp_node = ctxt->node_list;
+	if (temp_node == node_res_obj) {
+		ctxt->node_list = node_res_obj->next;
+	} else {
+		while (temp_node && temp_node->next != node_res_obj)
+			temp_node = temp_node->next;
+		if (!temp_node)
+			status = DSP_ENOTFOUND;
+		else
+			temp_node->next = node_res_obj->next;
+	}
+	mutex_unlock(&ctxt->node_mutex);
+	kfree(node_res_obj);
 	return status;
 }
 
 /* Actual Node De-Allocation */
-static DSP_STATUS DRV_ProcFreeNodeRes(HANDLE hPCtxt)
+static dsp_status drv_proc_free_node_res(bhandle hPCtxt)
 {
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct NODE_RES_OBJECT *pNodeList = NULL;
-	struct NODE_RES_OBJECT *pNodeRes = NULL;
-	u32  nState;
-
-	DBC_Assert(hPCtxt != NULL);
-	pNodeList = pCtxt->pNodeList;
-	while (pNodeList != NULL) {
-		GT_0trace(curTrace, GT_ENTER, "DRV_ProcFreeNodeRes: 1");
-		pNodeRes = pNodeList;
-		pNodeList = pNodeList->next;
-		if (pNodeRes->nodeAllocated) {
-			nState = NODE_GetState(pNodeRes->hNode) ;
-			GT_1trace(curTrace, GT_5CLASS,
-				"DRV_ProcFreeNodeRes: Node state %x\n", nState);
-			if (nState <= NODE_DELETING) {
-				if ((nState == NODE_RUNNING) ||
-					(nState == NODE_PAUSED) ||
-					(nState == NODE_TERMINATING)) {
-					GT_1trace(curTrace, GT_5CLASS,
-					"Calling Node_Terminate for Node:"
-					" 0x%x\n", pNodeRes->hNode);
-					status = NODE_Terminate
-						(pNodeRes->hNode, &status);
-					GT_1trace(curTrace, GT_5CLASS,
-						 "Calling Node_Delete for Node:"
-						 " 0x%x\n", pNodeRes->hNode);
-					status = NODE_Delete(pNodeRes->hNode,
-							pCtxt);
-					GT_1trace(curTrace, GT_5CLASS,
-					"the status after the NodeDelete %x\n",
-					status);
-				} else if ((nState == NODE_ALLOCATED)
-					|| (nState == NODE_CREATED))
-					status = NODE_Delete(pNodeRes->hNode,
-							pCtxt);
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	dsp_status status = DSP_SOK;
+	struct node_res_object *node_list = NULL;
+	struct node_res_object *node_res_obj = NULL;
+	u32 node_state;
+
+	node_list = ctxt->node_list;
+	while (node_list != NULL) {
+		node_res_obj = node_list;
+		node_list = node_list->next;
+		if (node_res_obj->node_allocated) {
+			node_state = node_get_state(node_res_obj->hnode);
+			if (node_state <= NODE_DELETING) {
+				if ((node_state == NODE_RUNNING) ||
+				    (node_state == NODE_PAUSED) ||
+				    (node_state == NODE_TERMINATING))
+					status = node_terminate
+					    (node_res_obj->hnode, &status);
+				status = node_delete(node_res_obj->hnode, ctxt);
 			}
 		}
 	}
 	return status;
 }
 
-/* Allocate the DMM resource element
-* This is called from Proc_Map. after the actual resource is allocated */
-DSP_STATUS DRV_InsertDMMResElement(HANDLE hDMMRes, HANDLE hPCtxt)
-{
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	struct DMM_RES_OBJECT **pDMMRes = (struct DMM_RES_OBJECT **)hDMMRes;
-	DSP_STATUS	status = DSP_SOK;
-	struct DMM_RES_OBJECT *pTempDMMRes = NULL;
-
-	*pDMMRes = (struct DMM_RES_OBJECT *)
-		    MEM_Calloc(1 * sizeof(struct DMM_RES_OBJECT), MEM_PAGED);
-	DBC_Assert(hPCtxt != NULL);
-	GT_0trace(curTrace, GT_ENTER, "DRV_InsertDMMResElement: 1");
-	if ((*pDMMRes == NULL) || (hPCtxt == NULL)) {
-		GT_0trace(curTrace, GT_5CLASS, "DRV_InsertDMMResElement: 2");
-		status = DSP_EHANDLE;
-	}
-	if (DSP_SUCCEEDED(status)) {
-		if (pCtxt->pDMMList != NULL) {
-			GT_0trace(curTrace, GT_5CLASS,
-				 "DRV_InsertDMMResElement: 3");
-			pTempDMMRes = pCtxt->pDMMList;
-			while (pTempDMMRes->next != NULL)
-				pTempDMMRes = pTempDMMRes->next;
-
-			pTempDMMRes->next = *pDMMRes;
-		} else {
-			pCtxt->pDMMList = *pDMMRes;
-			GT_0trace(curTrace, GT_5CLASS,
-				 "DRV_InsertDMMResElement: 4");
-		}
-	}
-	GT_0trace(curTrace, GT_ENTER, "DRV_InsertDMMResElement: 5");
-	return status;
-}
-
-
-
-/* Release DMM resource element context
-* This is called from Proc_UnMap. after the actual resource is freed */
-DSP_STATUS DRV_RemoveDMMResElement(HANDLE hDMMRes, HANDLE hPCtxt)
-{
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	struct DMM_RES_OBJECT *pDMMRes = (struct DMM_RES_OBJECT *)hDMMRes;
-	DSP_STATUS status = DSP_SOK;
-	struct DMM_RES_OBJECT *pTempDMMRes2 = NULL;
-	struct DMM_RES_OBJECT *pTempDMMRes = NULL;
-
-	DBC_Assert(hPCtxt != NULL);
-	pTempDMMRes2 = pCtxt->pDMMList;
-	pTempDMMRes = pCtxt->pDMMList;
-	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveDMMResElement: 1");
-	while ((pTempDMMRes != NULL) && (pTempDMMRes != pDMMRes)) {
-		GT_0trace(curTrace, GT_ENTER, "DRV_RemoveDMMResElement: 2");
-		pTempDMMRes2 = pTempDMMRes;
-		pTempDMMRes = pTempDMMRes->next;
-	}
-	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveDMMResElement: 3");
-	if (pCtxt->pDMMList == pTempDMMRes)
-		pCtxt->pDMMList = pTempDMMRes->next;
-
-	if (pTempDMMRes == NULL)
-		return DSP_ENOTFOUND;
-	else if (pTempDMMRes2->next != NULL)
-		pTempDMMRes2->next = pTempDMMRes2->next->next;
-
-	MEM_Free(pDMMRes);
-	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveDMMResElement: 4");
-	return status;
-}
-
-/* Update DMM resource status */
-DSP_STATUS DRV_UpdateDMMResElement(HANDLE hDMMRes, u32 pMpuAddr, u32 ulSize,
-				  u32 pReqAddr, u32 pMapAddr,
-				  HANDLE hProcessor)
-{
-	struct DMM_RES_OBJECT *pDMMRes = (struct DMM_RES_OBJECT *)hDMMRes;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Assert(hDMMRes != NULL);
-	pDMMRes->ulMpuAddr = pMpuAddr;
-	pDMMRes->ulDSPAddr = pMapAddr;
-	pDMMRes->ulDSPResAddr = pReqAddr;
-	pDMMRes->dmmSize = ulSize;
-	pDMMRes->hProcessor = hProcessor;
-	pDMMRes->dmmAllocated = 1;
-
-	return status;
-}
-
-/* Actual DMM De-Allocation */
-DSP_STATUS DRV_ProcFreeDMMRes(HANDLE hPCtxt)
+/* Release all Mapped and Reserved DMM resources */
+dsp_status drv_remove_all_dmm_res_elements(bhandle hPCtxt)
 {
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct DMM_RES_OBJECT *pDMMList = pCtxt->pDMMList;
-	struct DMM_RES_OBJECT *pDMMRes = NULL;
-
-	DBC_Assert(hPCtxt != NULL);
-	GT_0trace(curTrace, GT_ENTER, "\nDRV_ProcFreeDMMRes: 1\n");
-	while (pDMMList != NULL) {
-		pDMMRes = pDMMList;
-		pDMMList = pDMMList->next;
-		if (pDMMRes->dmmAllocated) {
-			/* PROC_UnMap frees pDMMRes */
-			void *processor = pDMMRes->hProcessor;
-			void *map_addr = (void*)pDMMRes->ulDSPAddr;
-			void *rsv_addr = (void*)pDMMRes->ulDSPResAddr;
-			status = PROC_UnMap(processor, map_addr, pCtxt);
-			status = PROC_UnReserveMemory(processor, rsv_addr);
-		}
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	dsp_status status = DSP_SOK;
+	struct dmm_map_object *temp_map, *map_obj;
+	struct dmm_rsv_object *temp_rsv, *rsv_obj;
+
+	/* Free DMM mapped memory resources */
+	list_for_each_entry_safe(map_obj, temp_map, &ctxt->dmm_map_list, link) {
+		status = proc_un_map(ctxt->hprocessor,
+				     (void *)map_obj->dsp_addr, ctxt);
+		if (DSP_FAILED(status))
+			pr_err("%s: proc_un_map failed!"
+			       " status = 0x%xn", __func__, status);
+	}
+
+	/* Free DMM reserved memory resources */
+	list_for_each_entry_safe(rsv_obj, temp_rsv, &ctxt->dmm_rsv_list, link) {
+		status = proc_un_reserve_memory(ctxt->hprocessor, (void *)
+						rsv_obj->dsp_reserved_addr,
+						ctxt);
+		if (DSP_FAILED(status))
+			pr_err("%s: proc_un_reserve_memory failed!"
+			       " status = 0x%xn", __func__, status);
 	}
 	return status;
 }
 
-
-/* Release all DMM resources and its context
-* This is called from .bridge_release. */
-DSP_STATUS DRV_RemoveAllDMMResElements(HANDLE hPCtxt)
-{
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct DMM_RES_OBJECT *pTempDMMRes2 = NULL;
-	struct DMM_RES_OBJECT *pTempDMMRes = NULL;
-
-	DBC_Assert(pCtxt != NULL);
-	DRV_ProcFreeDMMRes(pCtxt);
-	pTempDMMRes = pCtxt->pDMMList;
-	while (pTempDMMRes != NULL) {
-		pTempDMMRes2 = pTempDMMRes;
-		pTempDMMRes = pTempDMMRes->next;
-		MEM_Free(pTempDMMRes2);
-	}
-	pCtxt->pDMMList = NULL;
-	return status;
-}
-
-DSP_STATUS DRV_GetDMMResElement(u32 pMapAddr, HANDLE hDMMRes, HANDLE hPCtxt)
-{
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	struct DMM_RES_OBJECT **pDMMRes = (struct DMM_RES_OBJECT **)hDMMRes;
-	DSP_STATUS status = DSP_SOK;
-	struct DMM_RES_OBJECT *pTempDMM2 = NULL;
-	struct DMM_RES_OBJECT *pTempDMM = NULL;
-
-	DBC_Assert(hPCtxt != NULL);
-	pTempDMM = pCtxt->pDMMList;
-	while ((pTempDMM != NULL) && (pTempDMM->ulDSPAddr != pMapAddr)) {
-		GT_3trace(curTrace, GT_ENTER,
-			 "DRV_GetDMMResElement: 2 pTempDMM:%x "
-			 "pTempDMM->ulDSPAddr:%x pMapAddr:%x\n", pTempDMM,
-			 pTempDMM->ulDSPAddr, pMapAddr);
-		pTempDMM2 = pTempDMM;
-		pTempDMM = pTempDMM->next;
-	}
-	if (pTempDMM != NULL) {
-		GT_0trace(curTrace, GT_ENTER, "DRV_GetDMMResElement: 3");
-		*pDMMRes = pTempDMM;
-	} else {
-		status = DSP_ENOTFOUND;
-	} GT_0trace(curTrace, GT_ENTER, "DRV_GetDMMResElement: 4");
-	return status;
-}
-
 /* Update Node allocation status */
-void DRV_ProcNodeUpdateStatus(HANDLE hNodeRes, s32 status)
+void drv_proc_node_update_status(bhandle hNodeRes, s32 status)
 {
-	struct NODE_RES_OBJECT *pNodeRes = (struct NODE_RES_OBJECT *)hNodeRes;
-	DBC_Assert(hNodeRes != NULL);
-	pNodeRes->nodeAllocated = status;
+	struct node_res_object *node_res_obj =
+	    (struct node_res_object *)hNodeRes;
+	DBC_ASSERT(hNodeRes != NULL);
+	node_res_obj->node_allocated = status;
 }
 
 /* Update Node Heap status */
-void DRV_ProcNodeUpdateHeapStatus(HANDLE hNodeRes, s32 status)
+void drv_proc_node_update_heap_status(bhandle hNodeRes, s32 status)
 {
-	struct NODE_RES_OBJECT *pNodeRes = (struct NODE_RES_OBJECT *)hNodeRes;
-	DBC_Assert(hNodeRes != NULL);
-	pNodeRes->heapAllocated = status;
+	struct node_res_object *node_res_obj =
+	    (struct node_res_object *)hNodeRes;
+	DBC_ASSERT(hNodeRes != NULL);
+	node_res_obj->heap_allocated = status;
 }
 
 /* Release all Node resources and its context
 * This is called from .bridge_release.
-*/
-DSP_STATUS 	DRV_RemoveAllNodeResElements(HANDLE hPCtxt)
+ */
+dsp_status drv_remove_all_node_res_elements(bhandle hPCtxt)
 {
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct NODE_RES_OBJECT *pTempNode2 = NULL;
-	struct NODE_RES_OBJECT *pTempNode = NULL;
-
-	DBC_Assert(hPCtxt != NULL);
-	DRV_ProcFreeNodeRes(pCtxt);
-	pTempNode = pCtxt->pNodeList;
-	while (pTempNode != NULL) {
-		pTempNode2 = pTempNode;
-		pTempNode = pTempNode->next;
-		MEM_Free(pTempNode2);
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	dsp_status status = DSP_SOK;
+	struct node_res_object *temp_node2 = NULL;
+	struct node_res_object *temp_node = NULL;
+
+	drv_proc_free_node_res(ctxt);
+	temp_node = ctxt->node_list;
+	while (temp_node != NULL) {
+		temp_node2 = temp_node;
+		temp_node = temp_node->next;
+		kfree(temp_node2);
 	}
-	pCtxt->pNodeList = NULL;
+	ctxt->node_list = NULL;
 	return status;
 }
 
 /* Getting the node resource element */
-
-DSP_STATUS DRV_GetNodeResElement(HANDLE hNode, HANDLE hNodeRes, HANDLE hPCtxt)
+dsp_status drv_get_node_res_element(bhandle hnode, bhandle hNodeRes,
+				    bhandle hPCtxt)
 {
-	struct NODE_RES_OBJECT **nodeRes = (struct NODE_RES_OBJECT **)hNodeRes;
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct NODE_RES_OBJECT *pTempNode2 = NULL;
-	struct NODE_RES_OBJECT *pTempNode = NULL;
-
-	DBC_Assert(hPCtxt != NULL);
-	pTempNode = pCtxt->pNodeList;
-	GT_0trace(curTrace, GT_ENTER, "DRV_GetNodeResElement: 1");
-	while ((pTempNode != NULL) && (pTempNode->hNode != hNode)) {
-		pTempNode2 = pTempNode;
-		pTempNode = pTempNode->next;
+	struct node_res_object **node_res = (struct node_res_object **)hNodeRes;
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	dsp_status status = DSP_SOK;
+	struct node_res_object *temp_node2 = NULL;
+	struct node_res_object *temp_node = NULL;
+
+	if (mutex_lock_interruptible(&ctxt->node_mutex))
+		return DSP_EFAIL;
+
+	temp_node = ctxt->node_list;
+	while ((temp_node != NULL) && (temp_node->hnode != hnode)) {
+		temp_node2 = temp_node;
+		temp_node = temp_node->next;
 	}
-	if (pTempNode != NULL)
-		*nodeRes = pTempNode;
+
+	mutex_unlock(&ctxt->node_mutex);
+
+	if (temp_node != NULL)
+		*node_res = temp_node;
 	else
 		status = DSP_ENOTFOUND;
 
 	return status;
 }
 
-
-
 /* Allocate the STRM resource element
 * This is called after the actual resource is allocated
-*/
-DSP_STATUS DRV_ProcInsertSTRMResElement(HANDLE hStreamHandle, HANDLE hSTRMRes,
-					HANDLE hPCtxt)
-{
-	struct STRM_RES_OBJECT **pSTRMRes = (struct STRM_RES_OBJECT **)hSTRMRes;
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct STRM_RES_OBJECT *pTempSTRMRes = NULL;
-	DBC_Assert(hPCtxt != NULL);
-
-	*pSTRMRes = (struct STRM_RES_OBJECT *)
-		    MEM_Calloc(1 * sizeof(struct STRM_RES_OBJECT), MEM_PAGED);
-	if ((*pSTRMRes == NULL) || (hPCtxt == NULL)) {
-		GT_0trace(curTrace, GT_ENTER, "DRV_InsertSTRMResElement: 2");
+ */
+dsp_status drv_proc_insert_strm_res_element(bhandle hStreamHandle,
+					    bhandle hstrm_res, bhandle hPCtxt)
+{
+	struct strm_res_object **pstrm_res =
+	    (struct strm_res_object **)hstrm_res;
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	dsp_status status = DSP_SOK;
+	struct strm_res_object *temp_strm_res = NULL;
+
+	*pstrm_res = (struct strm_res_object *)
+	    mem_calloc(1 * sizeof(struct strm_res_object), MEM_PAGED);
+	if (*pstrm_res == NULL)
 		status = DSP_EHANDLE;
-	}
+
 	if (DSP_SUCCEEDED(status)) {
-		(*pSTRMRes)->hStream = hStreamHandle;
-		if (pCtxt->pSTRMList != NULL) {
-			GT_0trace(curTrace, GT_ENTER,
-				 "DRV_InsertiSTRMResElement: 3");
-			pTempSTRMRes = pCtxt->pSTRMList;
-			while (pTempSTRMRes->next != NULL)
-				pTempSTRMRes = pTempSTRMRes->next;
+		if (mutex_lock_interruptible(&ctxt->strm_mutex)) {
+			kfree(*pstrm_res);
+			return DSP_EFAIL;
+		}
+		(*pstrm_res)->hstream = hStreamHandle;
+		if (ctxt->pstrm_list != NULL) {
+			temp_strm_res = ctxt->pstrm_list;
+			while (temp_strm_res->next != NULL)
+				temp_strm_res = temp_strm_res->next;
 
-			pTempSTRMRes->next = *pSTRMRes;
+			temp_strm_res->next = *pstrm_res;
 		} else {
-			pCtxt->pSTRMList = *pSTRMRes;
-			GT_0trace(curTrace, GT_ENTER,
-				 "DRV_InsertSTRMResElement: 4");
+			ctxt->pstrm_list = *pstrm_res;
 		}
+		mutex_unlock(&ctxt->strm_mutex);
 	}
 	return status;
 }
 
-
-
 /* Release Stream resource element context
 * This function called after the actual resource is freed
-*/
-DSP_STATUS 	DRV_ProcRemoveSTRMResElement(HANDLE hSTRMRes, HANDLE hPCtxt)
+ */
+dsp_status drv_proc_remove_strm_res_element(bhandle hstrm_res, bhandle hPCtxt)
 {
-	struct STRM_RES_OBJECT *pSTRMRes = (struct STRM_RES_OBJECT *)hSTRMRes;
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct STRM_RES_OBJECT *pTempSTRMRes2 = pCtxt->pSTRMList;
-	struct STRM_RES_OBJECT *pTempSTRMRes = pCtxt->pSTRMList;
-
-	DBC_Assert(hPCtxt != NULL);
-	while ((pTempSTRMRes != NULL) && (pTempSTRMRes != pSTRMRes)) {
-		pTempSTRMRes2 = pTempSTRMRes;
-		pTempSTRMRes = pTempSTRMRes->next;
-	}
-	if (pCtxt->pSTRMList == pTempSTRMRes)
-		pCtxt->pSTRMList = pTempSTRMRes->next;
-
-	if (pTempSTRMRes == NULL)
-		status = DSP_ENOTFOUND;
-	else if (pTempSTRMRes2->next != NULL)
-		pTempSTRMRes2->next = pTempSTRMRes2->next->next;
+	struct strm_res_object *pstrm_res = (struct strm_res_object *)hstrm_res;
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	struct strm_res_object *temp_strm_res;
+	dsp_status status = DSP_SOK;
+
+	if (mutex_lock_interruptible(&ctxt->strm_mutex))
+		return DSP_EFAIL;
+	temp_strm_res = ctxt->pstrm_list;
 
-	MEM_Free(pSTRMRes);
+	if (ctxt->pstrm_list == pstrm_res) {
+		ctxt->pstrm_list = pstrm_res->next;
+	} else {
+		while (temp_strm_res && temp_strm_res->next != pstrm_res)
+			temp_strm_res = temp_strm_res->next;
+		if (temp_strm_res == NULL)
+			status = DSP_ENOTFOUND;
+		else
+			temp_strm_res->next = pstrm_res->next;
+	}
+	mutex_unlock(&ctxt->strm_mutex);
+	kfree(pstrm_res);
 	return status;
 }
 
-
-/* Actual Stream De-Allocation */
-static DSP_STATUS  DRV_ProcFreeSTRMRes(HANDLE hPCtxt)
+/* Release all Stream resources and its context
+* This is called from .bridge_release.
+ */
+dsp_status drv_remove_all_strm_res_elements(bhandle hPCtxt)
 {
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	DSP_STATUS status1 = DSP_SOK;
-	u8 **apBuffer = NULL;
-	struct STRM_RES_OBJECT *pSTRMList = NULL;
-	struct STRM_RES_OBJECT *pSTRMRes = NULL;
-	u8 *pBufPtr;
-	u32 ulBytes;
-	u32 dwArg;
-	s32 ulBufSize;
-
-
-	DBC_Assert(hPCtxt != NULL);
-	pSTRMList = pCtxt->pSTRMList;
-	while (pSTRMList != NULL) {
-		pSTRMRes = pSTRMList;
-		pSTRMList = pSTRMList->next;
-		if (pSTRMRes->uNumBufs != 0) {
-			apBuffer = MEM_Alloc((pSTRMRes->uNumBufs *
-					    sizeof(u8 *)), MEM_NONPAGED);
-			status = STRM_FreeBuffer(pSTRMRes->hStream, apBuffer,
-						pSTRMRes->uNumBufs, pCtxt);
-			MEM_Free(apBuffer);
-		}
-		status = STRM_Close(pSTRMRes->hStream, pCtxt);
-		if (DSP_FAILED(status)) {
-			if (status == DSP_EPENDING) {
-				status = STRM_Reclaim(pSTRMRes->hStream,
-						     &pBufPtr, &ulBytes,
-						     (u32 *)&ulBufSize, &dwArg);
-				if (DSP_SUCCEEDED(status))
-					status = STRM_Close(pSTRMRes->hStream,
-							pCtxt);
-
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	dsp_status status = DSP_SOK;
+	struct strm_res_object *strm_res = NULL;
+	struct strm_res_object *strm_tmp = NULL;
+	struct stream_info strm_info;
+	struct dsp_streaminfo user;
+	u8 **ap_buffer = NULL;
+	u8 *buf_ptr;
+	u32 ul_bytes;
+	u32 dw_arg;
+	s32 ul_buf_size;
+
+	strm_tmp = ctxt->pstrm_list;
+	while (strm_tmp) {
+		strm_res = strm_tmp;
+		strm_tmp = strm_tmp->next;
+		if (strm_res->num_bufs) {
+			ap_buffer = mem_alloc((strm_res->num_bufs *
+					       sizeof(u8 *)), MEM_NONPAGED);
+			if (ap_buffer) {
+				status = strm_free_buffer(strm_res->hstream,
+							  ap_buffer,
+							  strm_res->num_bufs,
+							  ctxt);
+				kfree(ap_buffer);
 			}
 		}
+		strm_info.user_strm = &user;
+		user.number_bufs_in_stream = 0;
+		strm_get_info(strm_res->hstream, &strm_info, sizeof(strm_info));
+		while (user.number_bufs_in_stream--)
+			strm_reclaim(strm_res->hstream, &buf_ptr, &ul_bytes,
+				     (u32 *) &ul_buf_size, &dw_arg);
+		status = strm_close(strm_res->hstream, ctxt);
 	}
-	return status1;
+	return status;
 }
 
-/* Release all Stream resources and its context
-* This is called from .bridge_release.
-*/
-DSP_STATUS	DRV_RemoveAllSTRMResElements(HANDLE hPCtxt)
+/* Getting the stream resource element */
+dsp_status drv_get_strm_res_element(bhandle hStrm, bhandle hstrm_res,
+				    bhandle hPCtxt)
 {
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct STRM_RES_OBJECT *pTempSTRMRes2 = NULL;
-	struct STRM_RES_OBJECT *pTempSTRMRes = NULL;
-
-	DBC_Assert(hPCtxt != NULL);
-	DRV_ProcFreeSTRMRes(pCtxt);
-	pTempSTRMRes = pCtxt->pSTRMList;
-	while (pTempSTRMRes != NULL) {
-		pTempSTRMRes2 = pTempSTRMRes;
-		pTempSTRMRes = pTempSTRMRes->next;
-		MEM_Free(pTempSTRMRes2);
+	struct strm_res_object **strm_res =
+	    (struct strm_res_object **)hstrm_res;
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	dsp_status status = DSP_SOK;
+	struct strm_res_object *temp_strm2 = NULL;
+	struct strm_res_object *temp_strm;
+
+	if (mutex_lock_interruptible(&ctxt->strm_mutex))
+		return DSP_EFAIL;
+
+	temp_strm = ctxt->pstrm_list;
+	while ((temp_strm != NULL) && (temp_strm->hstream != hStrm)) {
+		temp_strm2 = temp_strm;
+		temp_strm = temp_strm->next;
 	}
-	pCtxt->pSTRMList = NULL;
-	return status;
-}
 
+	mutex_unlock(&ctxt->strm_mutex);
 
-/* Getting the stream resource element */
-DSP_STATUS DRV_GetSTRMResElement(HANDLE hStrm, HANDLE hSTRMRes, HANDLE hPCtxt)
-{
-	struct STRM_RES_OBJECT **STRMRes = (struct STRM_RES_OBJECT **)hSTRMRes;
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct STRM_RES_OBJECT *pTempSTRM2 = NULL;
-	struct STRM_RES_OBJECT *pTempSTRM = pCtxt->pSTRMList;
-
-	DBC_Assert(hPCtxt != NULL);
-	while ((pTempSTRM != NULL) && (pTempSTRM->hStream != hStrm)) {
-		GT_0trace(curTrace, GT_ENTER, "DRV_GetSTRMResElement: 2");
-		pTempSTRM2 = pTempSTRM;
-		pTempSTRM = pTempSTRM->next;
-	}
-	if (pTempSTRM != NULL) {
-		GT_0trace(curTrace, GT_ENTER, "DRV_GetSTRMResElement: 3");
-		*STRMRes = pTempSTRM;
-	} else {
-		GT_0trace(curTrace, GT_ENTER, "DRV_GetSTRMResElement: 4");
+	if (temp_strm != NULL)
+		*strm_res = temp_strm;
+	else
 		status = DSP_ENOTFOUND;
-	}
-	GT_0trace(curTrace, GT_ENTER, "DRV_GetSTRMResElement: 5");
+
 	return status;
 }
 
 /* Updating the stream resource element */
-DSP_STATUS DRV_ProcUpdateSTRMRes(u32 uNumBufs, HANDLE hSTRMRes, HANDLE hPCtxt)
+dsp_status drv_proc_update_strm_res(u32 num_bufs, bhandle hstrm_res)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct STRM_RES_OBJECT **STRMRes = (struct STRM_RES_OBJECT **)hSTRMRes;
+	dsp_status status = DSP_SOK;
+	struct strm_res_object **strm_res =
+	    (struct strm_res_object **)hstrm_res;
 
-	DBC_Assert(hPCtxt != NULL);
-	(*STRMRes)->uNumBufs = uNumBufs;
-	return status;
-}
-
-/* Displaying the resources allocated by a process */
-DSP_STATUS DRV_ProcDisplayResInfo(u8 *pBuf1, u32 *pSize)
-{
-	struct PROCESS_CONTEXT *pCtxt = NULL;
-	struct NODE_RES_OBJECT *pNodeRes = NULL;
-	struct DMM_RES_OBJECT *pDMMRes = NULL;
-	struct STRM_RES_OBJECT *pSTRMRes = NULL;
-	struct DSPHEAP_RES_OBJECT *pDSPHEAPRes = NULL;
-	u32 tempCount = 1;
-	HANDLE hDrvObject = NULL;
-	void *pBuf = pBuf1;
-	u8 pTempBuf[250];
-	u32 tempStrLen = 0, tempStrLen2 = 0;
-	DSP_STATUS status = DSP_SOK;
-
-	CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	DRV_GetProcCtxtList(&pCtxt, (struct DRV_OBJECT *)hDrvObject);
-	GT_0trace(curTrace, GT_ENTER, "*********************"
-		 "DRV_ProcDisplayResourceInfo:*\n");
-	while (pCtxt != NULL) {
-		tempStrLen2 = sprintf((char *)pTempBuf,
-				     "-------------------------------------"
-				     "-----------------------------------\n");
-		tempStrLen2 += 2;
-		memmove(pBuf+tempStrLen, pTempBuf, tempStrLen2);
-		tempStrLen += tempStrLen2;
-		if (pCtxt->resState == PROC_RES_ALLOCATED) {
-			tempStrLen2 = sprintf((char *)pTempBuf,
-					"GPP Process Resource State: "
-					"pCtxt->resState = PROC_RES_ALLOCATED, "
-					" Process ID: %d\n", pCtxt->pid);
-			tempStrLen2 += 2;
-			memmove(pBuf+tempStrLen, pTempBuf, tempStrLen2);
-			tempStrLen += tempStrLen2;
-		} else {
-			tempStrLen2 = sprintf((char *)pTempBuf,
-				"GPP Resource State: pCtxt->resState"
-				" = PROC_RES_DEALLOCATED, Process ID:%d\n",
-				pCtxt->pid);
-			tempStrLen2 += 2;
-			memmove(pBuf+tempStrLen, pTempBuf, tempStrLen2);
-			tempStrLen += tempStrLen2;
-		}
-		pNodeRes = pCtxt->pNodeList;
-		tempCount = 1;
-		while (pNodeRes != NULL) {
-			GT_2trace(curTrace, GT_ENTER,
-				 "DRV_ProcDisplayResourceInfo: #:%d "
-				 "pCtxt->pNodeList->hNode:%x\n",
-				 tempCount, pNodeRes->hNode);
-			tempStrLen2 = sprintf((char *)pTempBuf,
-					"Node Resource Information: Node #"
-					" %d Node Handle hNode:0X%x\n",
-					tempCount, (u32)pNodeRes->hNode);
-			pNodeRes = pNodeRes->next;
-			tempStrLen2 += 2;
-			memmove(pBuf+tempStrLen, pTempBuf, tempStrLen2);
-			tempStrLen += tempStrLen2;
-			tempCount++;
-		}
-		tempCount = 1;
-		pDSPHEAPRes = pCtxt->pDSPHEAPList;
-		while (pDSPHEAPRes != NULL) {
-			GT_2trace(curTrace, GT_ENTER,
-				 "DRV_ProcDisplayResourceInfo: #:%d "
-				 "pCtxt->pDSPHEAPRList->ulMpuAddr:%x\n",
-				 tempCount, pDSPHEAPRes->ulMpuAddr);
-			tempStrLen2 = sprintf((char *)pTempBuf,
-				 "DSP Heap Resource Info: HEAP # %d"
-				 " Mapped GPP Address: 0x%x, size: 0x%x\n",
-				 tempCount, (u32)pDSPHEAPRes->ulMpuAddr,
-				 (u32)pDSPHEAPRes->heapSize);
-			pDSPHEAPRes = pDSPHEAPRes->next;
-			tempStrLen2 += 2;
-			memmove(pBuf+tempStrLen, pTempBuf, tempStrLen2);
-			tempStrLen += tempStrLen2;
-			tempCount++;
-		}
-		tempCount = 1;
-		pDMMRes = pCtxt->pDMMList;
-		while (pDMMRes != NULL) {
-			GT_2trace(curTrace, GT_ENTER,
-					"DRV_ProcDisplayResourceInfo: #:%d "
-					" pCtxt->pDMMList->ulMpuAddr:%x\n",
-					tempCount,
-					pDMMRes->ulMpuAddr);
-			tempStrLen2 = sprintf((char *)pTempBuf,
-					 "DMM Resource Info: DMM # %d Mapped"
-					 " GPP Address: 0x%x, size: 0x%x\n",
-					 tempCount, (u32)pDMMRes->ulMpuAddr,
-					 (u32)pDMMRes->dmmSize);
-			pDMMRes = pDMMRes->next;
-			tempStrLen2 += 2;
-			memmove(pBuf+tempStrLen, pTempBuf, tempStrLen2);
-			tempStrLen += tempStrLen2;
-			tempCount++;
-		}
-		tempCount = 1;
-		pSTRMRes = pCtxt->pSTRMList;
-		while (pSTRMRes != NULL) {
-			GT_2trace(curTrace, GT_ENTER,
-				 "DRV_ProcDisplayResourceInfo: #:%d "
-				 "pCtxt->pSTRMList->hStream:%x\n", tempCount,
-				 pSTRMRes->hStream);
-			tempStrLen2 = sprintf((char *)pTempBuf,
-					     "Stream Resource info: STRM # %d "
-					     "Stream Handle: 0x%x \n",
-					     tempCount, (u32)pSTRMRes->hStream);
-			pSTRMRes = pSTRMRes->next;
-			tempStrLen2 += 2;
-			memmove(pBuf+tempStrLen, pTempBuf, tempStrLen2);
-			tempStrLen += tempStrLen2;
-			tempCount++;
-		}
-		pCtxt = pCtxt->next;
-	}
-	*pSize = tempStrLen;
-	status = PrintProcessInformation();
-	GT_0trace(curTrace, GT_ENTER, "*********************"
-		"DRV_ProcDisplayResourceInfo:**\n");
-	return status;
-}
-
-/*
- *  ======== PrintProcessInformation ========
- *  Purpose:
- *      This function prints the Process's information stored in
- *      the process context list. Some of the information that
- *      it displays is Process's state, Node, Stream, DMM, and
- *      Heap information.
- */
-static DSP_STATUS PrintProcessInformation(void)
-{
-	struct DRV_OBJECT *hDrvObject = NULL;
-	struct PROCESS_CONTEXT *pCtxtList = NULL;
-	struct NODE_RES_OBJECT *pNodeRes = NULL;
-	struct DMM_RES_OBJECT *pDMMRes = NULL;
-	struct STRM_RES_OBJECT *pSTRMRes = NULL;
-	struct DSPHEAP_RES_OBJECT *pDSPHEAPRes = NULL;
-	struct PROC_OBJECT *proc_obj_ptr;
-	DSP_STATUS status = DSP_SOK;
-	u32 tempCount;
-	u32  procID;
-
-	/* Get the Process context list */
-	CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	DRV_GetProcCtxtList(&pCtxtList, hDrvObject);
-	GT_0trace(curTrace, GT_4CLASS, "\n### Debug information"
-			" for DSP bridge ##\n");
-	GT_0trace(curTrace, GT_4CLASS, " \n ###The  processes"
-			" information is as follows ### \n") ;
-	GT_0trace(curTrace, GT_4CLASS, "  ====================="
-			"============ \n");
-	/* Go through the entries in the Process context list */
-	while (pCtxtList  != NULL) {
-		GT_1trace(curTrace, GT_4CLASS, "\nThe process"
-				" id is %d\n", pCtxtList->pid);
-		GT_0trace(curTrace, GT_4CLASS, " -------------------"
-				"---------\n");
-		if (pCtxtList->resState == PROC_RES_ALLOCATED) {
-			GT_0trace(curTrace, GT_4CLASS, " \nThe Process"
-					" is in Allocated state\n");
-		} else {
-			GT_0trace(curTrace, GT_4CLASS, "\nThe Process"
-					" is in DeAllocated state\n");
-		}
-
-		spin_lock(&pCtxtList->proc_list_lock);
-		list_for_each_entry(proc_obj_ptr, &pCtxtList->processor_list,
-				proc_object) {
-			PROC_GetProcessorId(proc_obj_ptr, &procID);
-			if (procID == DSP_UNIT) {
-				GT_0trace(curTrace, GT_4CLASS,
-					"\nProcess connected to"
-					" DSP Processor\n");
-			} else if (procID == IVA_UNIT) {
-				GT_0trace(curTrace, GT_4CLASS,
-					"\nProcess connected to"
-					" IVA Processor\n");
-			} else {
-				GT_0trace(curTrace, GT_7CLASS,
-					"\n***ERROR:Invalid Processor Id***\n");
-			}
-		}
-		spin_unlock(&pCtxtList->proc_list_lock);
-
-		pNodeRes = pCtxtList->pNodeList;
-		tempCount = 1;
-		while (pNodeRes != NULL) {
-			if (tempCount == 1)
-				GT_0trace(curTrace, GT_4CLASS,
-					"\n***The Nodes allocated by"
-					" this Process are***\n");
-			GT_2trace(curTrace, GT_4CLASS,
-					"Node # %d Node Handle hNode:0x%x\n",
-					tempCount, (u32)pNodeRes->hNode);
-			pNodeRes = pNodeRes->next;
-			tempCount++;
-		}
-		if (tempCount == 1)
-			GT_0trace(curTrace, GT_4CLASS,
-					"\n ***There are no Nodes"
-					" allocated by this Process***\n");
-		tempCount = 1;
-		pDSPHEAPRes = pCtxtList->pDSPHEAPList;
-		while (pDSPHEAPRes != NULL) {
-			if (tempCount == 1)
-				GT_0trace(curTrace, GT_4CLASS,
-						"\n***The Heaps allocated by"
-						" this Process are***\n");
-			GT_3trace(curTrace, GT_4CLASS,
-				"DSP Heap Resource Info: HEAP # %d "
-				"Mapped GPP Address:0x%x, Size: 0x%lx\n",
-				tempCount, (u32)pDSPHEAPRes->ulMpuAddr,
-				pDSPHEAPRes->heapSize);
-			pDSPHEAPRes = pDSPHEAPRes->next;
-			tempCount++;
-		}
-		if (tempCount == 1)
-			GT_0trace(curTrace, GT_4CLASS,
-				"\n ***There are no Heaps allocated"
-				" by this Process***\n");
-		tempCount = 1;
-		pDMMRes = pCtxtList->pDMMList;
-		while (pDMMRes != NULL) {
-			if (tempCount == 1)
-				GT_0trace(curTrace, GT_4CLASS,
-					"\n ***The DMM resources allocated by"
-					" this Process are***\n");
-			GT_3trace(curTrace, GT_4CLASS,
-				"DMM Resource Info: DMM # %d "
-				"Mapped GPP Address:0X%lx, Size: 0X%lx\n",
-				tempCount, pDMMRes->ulMpuAddr,
-				pDMMRes->dmmSize);
-			pDMMRes = pDMMRes->next;
-			tempCount++;
-		}
-		if (tempCount == 1)
-			GT_0trace(curTrace, GT_4CLASS,
-				"\n ***There are no DMM resources"
-				" allocated by this Process***\n");
-		tempCount = 1;
-		pSTRMRes = pCtxtList->pSTRMList;
-		while (pSTRMRes != NULL) {
-			if (tempCount == 1)
-				GT_0trace(curTrace, GT_4CLASS,
-					"\n***The Stream resources allocated by"
-					" this Process are***\n");
-			GT_2trace(curTrace, GT_4CLASS,
-				"Stream Resource info: STRM # %d"
-				"Stream Handle:0X%x\n",	tempCount,
-				(u32)pSTRMRes->hStream);
-			pSTRMRes = pSTRMRes->next;
-			tempCount++;
-		}
-		if (tempCount == 1)
-			GT_0trace(curTrace, GT_4CLASS,
-				"\n ***There are no Stream resources"
-				"allocated by this Process***\n");
-		pCtxtList = pCtxtList->next;
-	}
+	(*strm_res)->num_bufs = num_bufs;
 	return status;
 }
 
 /* GPP PROCESS CLEANUP CODE END */
-#endif
 
 /*
- *  ======== = DRV_Create ======== =
+ *  ======== = drv_create ======== =
  *  Purpose:
  *      DRV Object gets created only once during Driver Loading.
  */
-DSP_STATUS DRV_Create(OUT struct DRV_OBJECT **phDRVObject)
+dsp_status drv_create(OUT struct drv_object **phDRVObject)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DRV_OBJECT *pDRVObject = NULL;
+	dsp_status status = DSP_SOK;
+	struct drv_object *pdrv_object = NULL;
 
-	DBC_Require(phDRVObject != NULL);
-	DBC_Require(cRefs > 0);
-	GT_1trace(curTrace, GT_ENTER, "Entering DRV_Create"
-			" phDRVObject 0x%x\n", phDRVObject);
-	MEM_AllocObject(pDRVObject, struct DRV_OBJECT, SIGNATURE);
-	if (pDRVObject) {
+	DBC_REQUIRE(phDRVObject != NULL);
+	DBC_REQUIRE(refs > 0);
+
+	MEM_ALLOC_OBJECT(pdrv_object, struct drv_object, SIGNATURE);
+	if (pdrv_object) {
 		/* Create and Initialize List of device objects */
-		pDRVObject->devList = LST_Create();
-		if (pDRVObject->devList) {
+		pdrv_object->dev_list = mem_calloc(sizeof(struct lst_list),
+						   MEM_NONPAGED);
+		if (pdrv_object->dev_list) {
 			/* Create and Initialize List of device Extension */
-			pDRVObject->devNodeString = LST_Create();
-			if (!(pDRVObject->devNodeString)) {
+			pdrv_object->dev_node_string =
+					mem_calloc(sizeof(struct lst_list),
+						   MEM_NONPAGED);
+			if (!(pdrv_object->dev_node_string)) {
 				status = DSP_EFAIL;
-				GT_0trace(curTrace, GT_7CLASS,
-					 "Failed to Create DRV_EXT list ");
-				MEM_FreeObject(pDRVObject);
+			} else {
+				INIT_LIST_HEAD(&pdrv_object->
+					       dev_node_string->head);
+				INIT_LIST_HEAD(&pdrv_object->dev_list->head);
 			}
 		} else {
-			status = DSP_EFAIL;
-			GT_0trace(curTrace, GT_7CLASS,
-				 "Failed to Create Dev List ");
-			MEM_FreeObject(pDRVObject);
+			status = DSP_EMEMORY;
 		}
 	} else {
-		status = DSP_EFAIL;
-		GT_0trace(curTrace, GT_7CLASS,
-			 "Failed to Allocate Memory for DRV Obj");
+		status = DSP_EMEMORY;
 	}
+	/* Store the DRV Object in the Registry */
+	if (DSP_SUCCEEDED(status))
+		status = cfg_set_object((u32) pdrv_object, REG_DRV_OBJECT);
 	if (DSP_SUCCEEDED(status)) {
-		/* Store the DRV Object in the Registry */
-		if (DSP_SUCCEEDED
-		    (CFG_SetObject((u32) pDRVObject, REG_DRV_OBJECT))) {
-			GT_1trace(curTrace, GT_1CLASS,
-				 "DRV Obj Created pDrvObject 0x%x\n ",
-				 pDRVObject);
-			*phDRVObject = pDRVObject;
-		} else {
-			/* Free the DRV Object */
-			status = DSP_EFAIL;
-			MEM_Free(pDRVObject);
-			GT_0trace(curTrace, GT_7CLASS,
-				 "Failed to update the Registry with "
-				 "DRV Object ");
-		}
+		*phDRVObject = pdrv_object;
+	} else {
+		kfree(pdrv_object->dev_list);
+		kfree(pdrv_object->dev_node_string);
+		/* Free the DRV Object */
+		kfree(pdrv_object);
 	}
-	GT_2trace(curTrace, GT_ENTER,
-		 "Exiting DRV_Create: phDRVObject: 0x%x\tstatus:"
-		 "0x%x\n", phDRVObject, status);
-	DBC_Ensure(DSP_FAILED(status) ||
-		  MEM_IsValidHandle(pDRVObject, SIGNATURE));
+
+	DBC_ENSURE(DSP_FAILED(status) ||
+		   MEM_IS_VALID_HANDLE(pdrv_object, SIGNATURE));
 	return status;
 }
 
 /*
- *  ======== DRV_Exit ========
+ *  ======== drv_exit ========
  *  Purpose:
  *      Discontinue usage of the DRV module.
  */
-void DRV_Exit(void)
+void drv_exit(void)
 {
-	DBC_Require(cRefs > 0);
-
-	GT_0trace(curTrace, GT_5CLASS, "Entering DRV_Exit \n");
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== = DRV_Destroy ======== =
+ *  ======== = drv_destroy ======== =
  *  purpose:
  *      Invoked during bridge de-initialization
  */
-DSP_STATUS DRV_Destroy(struct DRV_OBJECT *hDRVObject)
+dsp_status drv_destroy(struct drv_object *hDRVObject)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DRV_OBJECT *pDRVObject = (struct DRV_OBJECT *)hDRVObject;
+	dsp_status status = DSP_SOK;
+	struct drv_object *pdrv_object = (struct drv_object *)hDRVObject;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(pDRVObject, SIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(pdrv_object, SIGNATURE));
 
-	GT_1trace(curTrace, GT_ENTER, "Entering DRV_Destroy"
-			" hDRVObject 0x%x\n", hDRVObject);
 	/*
 	 *  Delete the List if it exists.Should not come here
-	 *  as the DRV_RemoveDevObject and the Last DRV_RequestResources
+	 *  as the drv_remove_dev_object and the Last drv_request_resources
 	 *  removes the list if the lists are empty.
 	 */
-	if (pDRVObject->devList) {
-		/* Could assert if the list is not empty  */
-		LST_Delete(pDRVObject->devList);
-	}
-	if (pDRVObject->devNodeString) {
-		/* Could assert if the list is not empty */
-		LST_Delete(pDRVObject->devNodeString);
-	}
-	MEM_FreeObject(pDRVObject);
+	kfree(pdrv_object->dev_list);
+	kfree(pdrv_object->dev_node_string);
+	MEM_FREE_OBJECT(pdrv_object);
 	/* Update the DRV Object in Registry to be 0 */
-	(void)CFG_SetObject(0, REG_DRV_OBJECT);
-	GT_2trace(curTrace, GT_ENTER,
-		 "Exiting DRV_Destroy: hDRVObject: 0x%x\tstatus:"
-		 "0x%x\n", hDRVObject, status);
-	DBC_Ensure(!MEM_IsValidHandle(pDRVObject, SIGNATURE));
+	(void)cfg_set_object(0, REG_DRV_OBJECT);
+	DBC_ENSURE(!MEM_IS_VALID_HANDLE(pdrv_object, SIGNATURE));
 	return status;
 }
 
 /*
- *  ======== DRV_GetDevObject ========
+ *  ======== drv_get_dev_object ========
  *  Purpose:
  *      Given a index, returns a handle to DevObject from the list.
  */
-DSP_STATUS DRV_GetDevObject(u32 uIndex, struct DRV_OBJECT *hDrvObject,
-			   struct DEV_OBJECT **phDevObject)
+dsp_status drv_get_dev_object(u32 index, struct drv_object *hdrv_obj,
+			      struct dev_object **phDevObject)
 {
-	DSP_STATUS status = DSP_SOK;
-#if GT_TRACE	/* pDrvObject is used only for Assertions and debug messages.*/
-	struct DRV_OBJECT *pDrvObject = (struct DRV_OBJECT *)hDrvObject;
+	dsp_status status = DSP_SOK;
+#ifdef CONFIG_BRIDGE_DEBUG
+	/* used only for Assertions and debug messages */
+	struct drv_object *pdrv_obj = (struct drv_object *)hdrv_obj;
 #endif
-	struct DEV_OBJECT *pDevObject;
+	struct dev_object *dev_obj;
 	u32 i;
-	DBC_Require(MEM_IsValidHandle(pDrvObject, SIGNATURE));
-	DBC_Require(phDevObject != NULL);
-	DBC_Require(uIndex >= 0);
-	DBC_Require(cRefs > 0);
-	DBC_Assert(!(LST_IsEmpty(pDrvObject->devList)));
-	GT_3trace(curTrace, GT_ENTER,
-		 "Entered DRV_GetDevObject, args:\n\tuIndex: "
-		 "0x%x\n\thDrvObject:  0x%x\n\tphDevObject:  0x%x\n",
-		 uIndex, hDrvObject, phDevObject);
-	pDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
-	for (i = 0; i < uIndex; i++) {
-		pDevObject =
-		   (struct DEV_OBJECT *)DRV_GetNextDevObject((u32)pDevObject);
-	}
-	if (pDevObject) {
-		*phDevObject = (struct DEV_OBJECT *) pDevObject;
-		status = DSP_SOK;
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(pdrv_obj, SIGNATURE));
+	DBC_REQUIRE(phDevObject != NULL);
+	DBC_REQUIRE(index >= 0);
+	DBC_REQUIRE(refs > 0);
+	DBC_ASSERT(!(LST_IS_EMPTY(pdrv_obj->dev_list)));
+
+	dev_obj = (struct dev_object *)drv_get_first_dev_object();
+	for (i = 0; i < index; i++) {
+		dev_obj =
+		    (struct dev_object *)drv_get_next_dev_object((u32) dev_obj);
+	}
+	if (dev_obj) {
+		*phDevObject = (struct dev_object *)dev_obj;
 	} else {
 		*phDevObject = NULL;
 		status = DSP_EFAIL;
-		GT_0trace(curTrace, GT_7CLASS,
-			 "DRV: Could not get the DevObject\n");
 	}
-	GT_2trace(curTrace, GT_ENTER,
-		 "Exiting Drv_GetDevObject\n\tstatus: 0x%x\n\t"
-		 "hDevObject: 0x%x\n", status, *phDevObject);
+
 	return status;
 }
 
 /*
- *  ======== DRV_GetFirstDevObject ========
+ *  ======== drv_get_first_dev_object ========
  *  Purpose:
  *      Retrieve the first Device Object handle from an internal linked list of
  *      of DEV_OBJECTs maintained by DRV.
  */
-u32 DRV_GetFirstDevObject(void)
+u32 drv_get_first_dev_object(void)
 {
-	u32 dwDevObject = 0;
-	struct DRV_OBJECT *pDrvObject;
+	u32 dw_dev_object = 0;
+	struct drv_object *pdrv_obj;
 
-	if (DSP_SUCCEEDED
-	    (CFG_GetObject((u32 *)&pDrvObject, REG_DRV_OBJECT))) {
-		if ((pDrvObject->devList != NULL) &&
-		   !LST_IsEmpty(pDrvObject->devList))
-			dwDevObject = (u32) LST_First(pDrvObject->devList);
+	if (DSP_SUCCEEDED(cfg_get_object((u32 *) &pdrv_obj, REG_DRV_OBJECT))) {
+		if (pdrv_obj && (pdrv_obj->dev_list != NULL) &&
+		    !LST_IS_EMPTY(pdrv_obj->dev_list))
+			dw_dev_object = (u32) lst_first(pdrv_obj->dev_list);
 	}
 
-	return dwDevObject;
+	return dw_dev_object;
 }
 
 /*
  *  ======== DRV_GetFirstDevNodeString ========
  *  Purpose:
  *      Retrieve the first Device Extension from an internal linked list of
- *      of Pointer to DevNode Strings maintained by DRV.
+ *      of Pointer to dev_node Strings maintained by DRV.
  */
-u32 DRV_GetFirstDevExtension(void)
+u32 drv_get_first_dev_extension(void)
 {
-	u32 dwDevExtension = 0;
-	struct DRV_OBJECT *pDrvObject;
+	u32 dw_dev_extension = 0;
+	struct drv_object *pdrv_obj;
 
-	if (DSP_SUCCEEDED
-	    (CFG_GetObject((u32 *)&pDrvObject, REG_DRV_OBJECT))) {
+	if (DSP_SUCCEEDED(cfg_get_object((u32 *) &pdrv_obj, REG_DRV_OBJECT))) {
 
-		if ((pDrvObject->devNodeString != NULL) &&
-		   !LST_IsEmpty(pDrvObject->devNodeString)) {
-			dwDevExtension = (u32)LST_First(pDrvObject->
-							devNodeString);
+		if ((pdrv_obj->dev_node_string != NULL) &&
+		    !LST_IS_EMPTY(pdrv_obj->dev_node_string)) {
+			dw_dev_extension =
+			    (u32) lst_first(pdrv_obj->dev_node_string);
 		}
 	}
 
-	return dwDevExtension;
+	return dw_dev_extension;
 }
 
 /*
- *  ======== DRV_GetNextDevObject ========
+ *  ======== drv_get_next_dev_object ========
  *  Purpose:
  *      Retrieve the next Device Object handle from an internal linked list of
  *      of DEV_OBJECTs maintained by DRV, after having previously called
- *      DRV_GetFirstDevObject() and zero or more DRV_GetNext.
+ *      drv_get_first_dev_object() and zero or more DRV_GetNext.
  */
-u32 DRV_GetNextDevObject(u32 hDevObject)
+u32 drv_get_next_dev_object(u32 hdev_obj)
 {
-	u32 dwNextDevObject = 0;
-	struct DRV_OBJECT *pDrvObject;
+	u32 dw_next_dev_object = 0;
+	struct drv_object *pdrv_obj;
 
-	DBC_Require(hDevObject != 0);
+	DBC_REQUIRE(hdev_obj != 0);
 
-	if (DSP_SUCCEEDED
-	    (CFG_GetObject((u32 *)&pDrvObject, REG_DRV_OBJECT))) {
+	if (DSP_SUCCEEDED(cfg_get_object((u32 *) &pdrv_obj, REG_DRV_OBJECT))) {
 
-		if ((pDrvObject->devList != NULL) &&
-		   !LST_IsEmpty(pDrvObject->devList)) {
-			dwNextDevObject = (u32)LST_Next(pDrvObject->devList,
-					  (struct LST_ELEM *)hDevObject);
+		if ((pdrv_obj->dev_list != NULL) &&
+		    !LST_IS_EMPTY(pdrv_obj->dev_list)) {
+			dw_next_dev_object = (u32) lst_next(pdrv_obj->dev_list,
+							    (struct list_head *)
+							    hdev_obj);
 		}
 	}
-	return dwNextDevObject;
+	return dw_next_dev_object;
 }
 
 /*
- *  ======== DRV_GetNextDevExtension ========
+ *  ======== drv_get_next_dev_extension ========
  *  Purpose:
  *      Retrieve the next Device Extension from an internal linked list of
  *      of pointer to DevNodeString maintained by DRV, after having previously
- *      called DRV_GetFirstDevExtension() and zero or more
- *      DRV_GetNextDevExtension().
+ *      called drv_get_first_dev_extension() and zero or more
+ *      drv_get_next_dev_extension().
  */
-u32 DRV_GetNextDevExtension(u32 hDevExtension)
+u32 drv_get_next_dev_extension(u32 hDevExtension)
 {
-	u32 dwDevExtension = 0;
-	struct DRV_OBJECT *pDrvObject;
+	u32 dw_dev_extension = 0;
+	struct drv_object *pdrv_obj;
 
-	DBC_Require(hDevExtension != 0);
-
-	if (DSP_SUCCEEDED(CFG_GetObject((u32 *)&pDrvObject,
-	   REG_DRV_OBJECT))) {
-		if ((pDrvObject->devNodeString != NULL) &&
-		   !LST_IsEmpty(pDrvObject->devNodeString)) {
-			dwDevExtension = (u32)LST_Next(pDrvObject->
-				devNodeString,
-				(struct LST_ELEM *)hDevExtension);
+	DBC_REQUIRE(hDevExtension != 0);
+
+	if (DSP_SUCCEEDED(cfg_get_object((u32 *) &pdrv_obj, REG_DRV_OBJECT))) {
+		if ((pdrv_obj->dev_node_string != NULL) &&
+		    !LST_IS_EMPTY(pdrv_obj->dev_node_string)) {
+			dw_dev_extension =
+			    (u32) lst_next(pdrv_obj->dev_node_string,
+					   (struct list_head *)hDevExtension);
 		}
 	}
 
-	return dwDevExtension;
+	return dw_dev_extension;
 }
 
 /*
- *  ======== DRV_Init ========
+ *  ======== drv_init ========
  *  Purpose:
  *      Initialize DRV module private state.
  */
-DSP_STATUS DRV_Init(void)
+dsp_status drv_init(void)
 {
-	s32 fRetval = 1;	/* function return value */
-
-	DBC_Require(cRefs >= 0);
+	s32 ret = 1;		/* function return value */
 
-	if (fRetval)
-		cRefs++;
+	DBC_REQUIRE(refs >= 0);
 
-	GT_1trace(curTrace, GT_5CLASS, "Entering DRV_Entry  crefs 0x%x \n",
-		 cRefs);
+	if (ret)
+		refs++;
 
-	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	return fRetval;
+	return ret;
 }
 
 /*
- *  ======== DRV_InsertDevObject ========
+ *  ======== drv_insert_dev_object ========
  *  Purpose:
  *      Insert a DevObject into the list of Manager object.
  */
-DSP_STATUS DRV_InsertDevObject(struct DRV_OBJECT *hDRVObject,
-			       struct DEV_OBJECT *hDevObject)
+dsp_status drv_insert_dev_object(struct drv_object *hDRVObject,
+				 struct dev_object *hdev_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DRV_OBJECT *pDRVObject = (struct DRV_OBJECT *)hDRVObject;
+	dsp_status status = DSP_SOK;
+	struct drv_object *pdrv_object = (struct drv_object *)hDRVObject;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(hDevObject != NULL);
-	DBC_Require(MEM_IsValidHandle(pDRVObject, SIGNATURE));
-	DBC_Assert(pDRVObject->devList);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(hdev_obj != NULL);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(pdrv_object, SIGNATURE));
+	DBC_ASSERT(pdrv_object->dev_list);
 
-	GT_2trace(curTrace, GT_ENTER,
-		 "Entering DRV_InsertProcObject hDRVObject "
-		 "0x%x\n, hDevObject 0x%x\n", hDRVObject, hDevObject);
+	lst_put_tail(pdrv_object->dev_list, (struct list_head *)hdev_obj);
 
-	LST_PutTail(pDRVObject->devList, (struct LST_ELEM *)hDevObject);
-
-	GT_1trace(curTrace, GT_ENTER,
-		 "Exiting InsertDevObject status 0x%x\n", status);
-
-	DBC_Ensure(DSP_SUCCEEDED(status) && !LST_IsEmpty(pDRVObject->devList));
+	DBC_ENSURE(DSP_SUCCEEDED(status)
+		   && !LST_IS_EMPTY(pdrv_object->dev_list));
 
 	return status;
 }
 
 /*
- *  ======== DRV_RemoveDevObject ========
+ *  ======== drv_remove_dev_object ========
  *  Purpose:
  *      Search for and remove a DeviceObject from the given list of DRV
  *      objects.
  */
-DSP_STATUS DRV_RemoveDevObject(struct DRV_OBJECT *hDRVObject,
-			       struct DEV_OBJECT *hDevObject)
+dsp_status drv_remove_dev_object(struct drv_object *hDRVObject,
+				 struct dev_object *hdev_obj)
 {
-	DSP_STATUS status = DSP_EFAIL;
-	struct DRV_OBJECT *pDRVObject = (struct DRV_OBJECT *)hDRVObject;
-	struct LST_ELEM *pCurElem;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(pDRVObject, SIGNATURE));
-	DBC_Require(hDevObject != NULL);
-
-	DBC_Require(pDRVObject->devList != NULL);
-	DBC_Require(!LST_IsEmpty(pDRVObject->devList));
-
-	GT_2trace(curTrace, GT_ENTER,
-		 "Entering DRV_RemoveDevObject hDevObject "
-		 "0x%x\n, hDRVObject 0x%x\n", hDevObject, hDRVObject);
-	/* Search list for pProcObject: */
-	for (pCurElem = LST_First(pDRVObject->devList); pCurElem != NULL;
-	    pCurElem = LST_Next(pDRVObject->devList, pCurElem)) {
+	dsp_status status = DSP_EFAIL;
+	struct drv_object *pdrv_object = (struct drv_object *)hDRVObject;
+	struct list_head *cur_elem;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(pdrv_object, SIGNATURE));
+	DBC_REQUIRE(hdev_obj != NULL);
+
+	DBC_REQUIRE(pdrv_object->dev_list != NULL);
+	DBC_REQUIRE(!LST_IS_EMPTY(pdrv_object->dev_list));
+
+	/* Search list for p_proc_object: */
+	for (cur_elem = lst_first(pdrv_object->dev_list); cur_elem != NULL;
+	     cur_elem = lst_next(pdrv_object->dev_list, cur_elem)) {
 		/* If found, remove it. */
-		if ((struct DEV_OBJECT *) pCurElem == hDevObject) {
-			LST_RemoveElem(pDRVObject->devList, pCurElem);
+		if ((struct dev_object *)cur_elem == hdev_obj) {
+			lst_remove_elem(pdrv_object->dev_list, cur_elem);
 			status = DSP_SOK;
 			break;
 		}
 	}
 	/* Remove list if empty. */
-	if (LST_IsEmpty(pDRVObject->devList)) {
-		LST_Delete(pDRVObject->devList);
-		pDRVObject->devList = NULL;
-	}
-	DBC_Ensure((pDRVObject->devList == NULL) ||
-		  !LST_IsEmpty(pDRVObject->devList));
-	GT_1trace(curTrace, GT_ENTER,
-		 "DRV_RemoveDevObject returning 0x%x\n", status);
+	if (LST_IS_EMPTY(pdrv_object->dev_list)) {
+		kfree(pdrv_object->dev_list);
+		pdrv_object->dev_list = NULL;
+	}
+	DBC_ENSURE((pdrv_object->dev_list == NULL) ||
+		   !LST_IS_EMPTY(pdrv_object->dev_list));
+
 	return status;
 }
 
 /*
- *  ======== DRV_RequestResources ========
+ *  ======== drv_request_resources ========
  *  Purpose:
  *      Requests  resources from the OS.
  */
-DSP_STATUS DRV_RequestResources(u32 dwContext, u32 *pDevNodeString)
+dsp_status drv_request_resources(u32 dw_context, u32 *pDevNodeString)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DRV_OBJECT *pDRVObject;
-	struct DRV_EXT *pszdevNode;
-
-	DBC_Require(dwContext != 0);
-	DBC_Require(pDevNodeString != NULL);
-	GT_0trace(curTrace, GT_ENTER, "Entering DRV_RequestResources\n");
+	dsp_status status = DSP_SOK;
+	struct drv_object *pdrv_object;
+	struct drv_ext *pszdev_node;
+
+	DBC_REQUIRE(dw_context != 0);
+	DBC_REQUIRE(pDevNodeString != NULL);
+
 	/*
 	 *  Allocate memory to hold the string. This will live untill
 	 *  it is freed in the Release resources. Update the driver object
 	 *  list.
 	 */
-	if (DSP_SUCCEEDED(CFG_GetObject((u32 *)&pDRVObject,
-	   REG_DRV_OBJECT))) {
-		pszdevNode = MEM_Calloc(sizeof(struct DRV_EXT), MEM_NONPAGED);
-		if (pszdevNode) {
-			LST_InitElem(&pszdevNode->link);
-			strncpy(pszdevNode->szString,
-				 (char *)dwContext, MAXREGPATHLENGTH - 1);
-			pszdevNode->szString[MAXREGPATHLENGTH - 1] = '\0';
+
+	status = cfg_get_object((u32 *) &pdrv_object, REG_DRV_OBJECT);
+	if (DSP_SUCCEEDED(status)) {
+		pszdev_node = mem_calloc(sizeof(struct drv_ext), MEM_NONPAGED);
+		if (pszdev_node) {
+			lst_init_elem(&pszdev_node->link);
+			strncpy(pszdev_node->sz_string,
+				(char *)dw_context, MAXREGPATHLENGTH - 1);
+			pszdev_node->sz_string[MAXREGPATHLENGTH - 1] = '\0';
 			/* Update the Driver Object List */
-			*pDevNodeString = (u32)pszdevNode->szString;
-			LST_PutTail(pDRVObject->devNodeString,
-				(struct LST_ELEM *)pszdevNode);
+			*pDevNodeString = (u32) pszdev_node->sz_string;
+			lst_put_tail(pdrv_object->dev_node_string,
+				     (struct list_head *)pszdev_node);
 		} else {
-			GT_0trace(curTrace, GT_7CLASS,
-				"Failed to Allocate Memory devNodeString ");
-			status = DSP_EFAIL;
+			status = DSP_EMEMORY;
 			*pDevNodeString = 0;
 		}
 	} else {
-		status = DSP_EFAIL;
-		GT_0trace(curTrace, GT_7CLASS,
-			 "Failed to get Driver Object from Registry");
+		dev_dbg(bridge, "%s: Failed to get Driver Object from Registry",
+			__func__);
 		*pDevNodeString = 0;
 	}
 
-       if (!(strcmp((char *) dwContext, "TIOMAP1510"))) {
-		GT_0trace(curTrace, GT_1CLASS,
-			  " Allocating resources for UMA \n");
-		status = RequestBridgeResourcesDSP(dwContext, DRV_ASSIGN);
+	if (!(strcmp((char *)dw_context, "TIOMAP1510"))) {
+		dev_dbg(bridge, "%s: Allocating resources for UMA\n", __func__);
+		status = request_bridge_resources_dsp(dw_context, DRV_ASSIGN);
 	} else {
 		status = DSP_EFAIL;
-		GT_0trace(curTrace, GT_7CLASS, "Unknown Device ");
+		dev_dbg(bridge, "%s: Unknown Device\n", __func__);
 	}
 
-	if (DSP_FAILED(status)) {
-		GT_0trace(curTrace, GT_7CLASS,
-			 "Failed to reserve bridge resources ");
-	}
-	DBC_Ensure((DSP_SUCCEEDED(status) && pDevNodeString != NULL &&
-		  !LST_IsEmpty(pDRVObject->devNodeString)) ||
-		  (DSP_FAILED(status) && *pDevNodeString == 0));
+	if (DSP_FAILED(status))
+		dev_dbg(bridge, "%s: Failed to reserve bridge resources\n",
+			__func__);
+
+	DBC_ENSURE((DSP_SUCCEEDED(status) && pDevNodeString != NULL &&
+		    !LST_IS_EMPTY(pdrv_object->dev_node_string)) ||
+		   (DSP_FAILED(status) && *pDevNodeString == 0));
 
 	return status;
 }
 
 /*
- *  ======== DRV_ReleaseResources ========
+ *  ======== drv_release_resources ========
  *  Purpose:
  *      Releases  resources from the OS.
  */
-DSP_STATUS DRV_ReleaseResources(u32 dwContext, struct DRV_OBJECT *hDrvObject)
+dsp_status drv_release_resources(u32 dw_context, struct drv_object *hdrv_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DRV_OBJECT *pDRVObject = (struct DRV_OBJECT *)hDrvObject;
-	struct DRV_EXT *pszdevNode;
-
-	GT_0trace(curTrace, GT_ENTER, "Entering DRV_Release Resources\n");
-
-       if (!(strcmp((char *)((struct DRV_EXT *)dwContext)->szString,
-	   "TIOMAP1510"))) {
-		GT_0trace(curTrace, GT_1CLASS,
-			 " Releasing DSP-Bridge resources \n");
-		status = RequestBridgeResources(dwContext, DRV_RELEASE);
-	} else {
-		GT_0trace(curTrace, GT_1CLASS, " Unknown device\n");
-	}
+	dsp_status status = DSP_SOK;
+	struct drv_object *pdrv_object = (struct drv_object *)hdrv_obj;
+	struct drv_ext *pszdev_node;
+
+	if (!(strcmp((char *)((struct drv_ext *)dw_context)->sz_string,
+		     "TIOMAP1510")))
+		status = request_bridge_resources(dw_context, DRV_RELEASE);
+	else
+		dev_dbg(bridge, "%s: Unknown device\n", __func__);
 
-	if (DSP_SUCCEEDED(status)) {
-		GT_0trace(curTrace, GT_1CLASS,
-			 "Failed to relese bridge resources\n");
-	}
+	if (DSP_FAILED(status))
+		dev_dbg(bridge, "%s: Failed to relese bridge resources\n",
+			__func__);
 
 	/*
 	 *  Irrespective of the status go ahead and clean it
 	 *  The following will over write the status.
 	 */
-	for (pszdevNode = (struct DRV_EXT *)DRV_GetFirstDevExtension();
-	    pszdevNode != NULL; pszdevNode = (struct DRV_EXT *)
-	    DRV_GetNextDevExtension((u32)pszdevNode)) {
-		if ((u32)pszdevNode == dwContext) {
+	for (pszdev_node = (struct drv_ext *)drv_get_first_dev_extension();
+	     pszdev_node != NULL; pszdev_node = (struct drv_ext *)
+	     drv_get_next_dev_extension((u32) pszdev_node)) {
+		if (!pdrv_object->dev_node_string) {
+			/* When this could happen? */
+			continue;
+		}
+		if ((u32) pszdev_node == dw_context) {
 			/* Found it */
 			/* Delete from the Driver object list */
-			LST_RemoveElem(pDRVObject->devNodeString,
-				      (struct LST_ELEM *)pszdevNode);
-			MEM_Free((void *) pszdevNode);
+			lst_remove_elem(pdrv_object->dev_node_string,
+					(struct list_head *)pszdev_node);
+			kfree((void *)pszdev_node);
 			break;
 		}
 		/* Delete the List if it is empty */
-		if (LST_IsEmpty(pDRVObject->devNodeString)) {
-			LST_Delete(pDRVObject->devNodeString);
-			pDRVObject->devNodeString = NULL;
+		if (LST_IS_EMPTY(pdrv_object->dev_node_string)) {
+			kfree(pdrv_object->dev_node_string);
+			pdrv_object->dev_node_string = NULL;
 		}
 	}
 	return status;
 }
 
 /*
- *  ======== RequestBridgeResources ========
+ *  ======== request_bridge_resources ========
  *  Purpose:
  *      Reserves shared memory for bridge.
  */
-static DSP_STATUS RequestBridgeResources(u32 dwContext, s32 bRequest)
+static dsp_status request_bridge_resources(u32 dw_context, s32 bRequest)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CFG_HOSTRES *pResources;
-	u32 dwBuffSize;
+	dsp_status status = DSP_SOK;
+	struct cfg_hostres *host_res;
+	u32 dw_buff_size;
 
-	struct DRV_EXT *driverExt;
+	struct drv_ext *driver_ext;
 	u32 shm_size;
 
-	DBC_Require(dwContext != 0);
-
-	GT_0trace(curTrace, GT_ENTER, "->RequestBridgeResources \n");
+	DBC_REQUIRE(dw_context != 0);
 
 	if (!bRequest) {
-		driverExt = (struct DRV_EXT *)dwContext;
-		/* Releasing resources by deleting the registry key  */
-		dwBuffSize = sizeof(struct CFG_HOSTRES);
-		pResources = MEM_Calloc(dwBuffSize, MEM_NONPAGED);
-		if (DSP_FAILED(REG_GetValue(NULL, (char *)driverExt->szString,
-		   CURRENTCONFIG, (u8 *)pResources, &dwBuffSize))) {
-			status = CFG_E_RESOURCENOTAVAIL;
-			GT_0trace(curTrace, GT_1CLASS,
-				 "REG_GetValue Failed \n");
-		} else {
-			GT_0trace(curTrace, GT_1CLASS,
-				 "REG_GetValue Succeeded \n");
-		}
+		driver_ext = (struct drv_ext *)dw_context;
+		/* Releasing resources by deleting the registry key */
+		dw_buff_size = sizeof(struct cfg_hostres);
+		host_res = mem_calloc(dw_buff_size, MEM_NONPAGED);
+		if (host_res != NULL) {
+			if (DSP_FAILED(reg_get_value(CURRENTCONFIG,
+						     (u8 *) host_res,
+						     &dw_buff_size))) {
+				status = CFG_E_RESOURCENOTAVAIL;
+			}
 
-		if (pResources != NULL) {
-			dwBuffSize = sizeof(shm_size);
-			status = REG_GetValue(NULL, CURRENTCONFIG, SHMSIZE,
-				(u8 *)&shm_size, &dwBuffSize);
+			dw_buff_size = sizeof(shm_size);
+			status = reg_get_value(SHMSIZE, (u8 *) &shm_size,
+					       &dw_buff_size);
 			if (DSP_SUCCEEDED(status)) {
-				if ((pResources->dwMemBase[1]) &&
-				   (pResources->dwMemPhys[1])) {
-					MEM_FreePhysMem((void *)pResources->
-					dwMemBase[1], pResources->dwMemPhys[1],
-					shm_size);
+				if ((host_res->dw_mem_base[1]) &&
+				    (host_res->dw_mem_phys[1])) {
+					mem_free_phys_mem((void *)
+							  host_res->dw_mem_base
+							  [1],
+							  host_res->dw_mem_phys
+							  [1], shm_size);
 				}
 			} else {
-				GT_1trace(curTrace, GT_7CLASS,
-					"Error getting SHM size from registry: "
-					"%x. Not calling MEM_FreePhysMem\n",
+				dev_dbg(bridge, "%s: Error getting shm size "
+					"from registry: %x. Not calling "
+					"mem_free_phys_mem\n", __func__,
 					status);
 			}
-			pResources->dwMemBase[1] = 0;
-			pResources->dwMemPhys[1] = 0;
+			host_res->dw_mem_base[1] = 0;
+			host_res->dw_mem_phys[1] = 0;
 
-			if (pResources->dwPrmBase)
-				iounmap(pResources->dwPrmBase);
-			if (pResources->dwCmBase)
-				iounmap(pResources->dwCmBase);
-			if (pResources->dwMboxBase)
-				iounmap(pResources->dwMboxBase);
-			if (pResources->dwMemBase[0])
-				iounmap((void *)pResources->dwMemBase[0]);
-			if (pResources->dwMemBase[2])
-				iounmap((void *)pResources->dwMemBase[2]);
-			if (pResources->dwMemBase[3])
-				iounmap((void *)pResources->dwMemBase[3]);
-			if (pResources->dwMemBase[4])
-				iounmap((void *)pResources->dwMemBase[4]);
-			if (pResources->dwWdTimerDspBase)
-				iounmap(pResources->dwWdTimerDspBase);
-			if (pResources->dwDmmuBase)
-				iounmap(pResources->dwDmmuBase);
-			if (pResources->dwPerBase)
-				iounmap(pResources->dwPerBase);
-                       if (pResources->dwPerPmBase)
-                               iounmap((void *)pResources->dwPerPmBase);
-                       if (pResources->dwCorePmBase)
-                               iounmap((void *)pResources->dwCorePmBase);
-			if (pResources->dwSysCtrlBase) {
-				iounmap(pResources->dwSysCtrlBase);
-				/* don't set pResources->dwSysCtrlBase to null
-				 * as it is used in BOARD_Stop */
-			}
-			pResources->dwPrmBase = NULL;
-			pResources->dwCmBase = NULL;
-			pResources->dwMboxBase = NULL;
-			pResources->dwMemBase[0] = (u32) NULL;
-			pResources->dwMemBase[2] = (u32) NULL;
-			pResources->dwMemBase[3] = (u32) NULL;
-			pResources->dwMemBase[4] = (u32) NULL;
-			pResources->dwWdTimerDspBase = NULL;
-			pResources->dwDmmuBase = NULL;
-
-			dwBuffSize = sizeof(struct CFG_HOSTRES);
-			status = REG_SetValue(NULL, (char *)driverExt->szString,
-				 CURRENTCONFIG, REG_BINARY, (u8 *)pResources,
-				 (u32)dwBuffSize);
+			if (host_res->dw_prm_base)
+				iounmap(host_res->dw_prm_base);
+			if (host_res->dw_cm_base)
+				iounmap(host_res->dw_cm_base);
+			if (host_res->dw_mem_base[0])
+				iounmap((void *)host_res->dw_mem_base[0]);
+			if (host_res->dw_mem_base[2])
+				iounmap((void *)host_res->dw_mem_base[2]);
+			if (host_res->dw_mem_base[3])
+				iounmap((void *)host_res->dw_mem_base[3]);
+			if (host_res->dw_mem_base[4])
+				iounmap((void *)host_res->dw_mem_base[4]);
+			if (host_res->dw_dmmu_base)
+				iounmap(host_res->dw_dmmu_base);
+			if (host_res->dw_per_base)
+				iounmap(host_res->dw_per_base);
+			if (host_res->dw_per_pm_base)
+				iounmap((void *)host_res->dw_per_pm_base);
+			if (host_res->dw_core_pm_base)
+				iounmap((void *)host_res->dw_core_pm_base);
+			if (host_res->dw_sys_ctrl_base)
+				iounmap(host_res->dw_sys_ctrl_base);
+
+			host_res->dw_prm_base = NULL;
+			host_res->dw_cm_base = NULL;
+			host_res->dw_mem_base[0] = (u32) NULL;
+			host_res->dw_mem_base[2] = (u32) NULL;
+			host_res->dw_mem_base[3] = (u32) NULL;
+			host_res->dw_mem_base[4] = (u32) NULL;
+			host_res->dw_dmmu_base = NULL;
+			host_res->dw_sys_ctrl_base = NULL;
+
+			dw_buff_size = sizeof(struct cfg_hostres);
+			status = reg_set_value(CURRENTCONFIG, (u8 *) host_res,
+					       (u32) dw_buff_size);
 			/*  Set all the other entries to NULL */
-			MEM_Free(pResources);
+			kfree(host_res);
+		} else {
+			status = DSP_EMEMORY;
 		}
-		GT_0trace(curTrace, GT_ENTER, " <- RequestBridgeResources \n");
 		return status;
 	}
-	dwBuffSize = sizeof(struct CFG_HOSTRES);
-	pResources = MEM_Calloc(dwBuffSize, MEM_NONPAGED);
-	if (pResources != NULL) {
-		/* wNumMemWindows must not be more than CFG_MAXMEMREGISTERS */
-		pResources->wNumMemWindows = 2;
+	dw_buff_size = sizeof(struct cfg_hostres);
+	host_res = mem_calloc(dw_buff_size, MEM_NONPAGED);
+	if (host_res != NULL) {
+		/* num_mem_windows must not be more than CFG_MAXMEMREGISTERS */
+		host_res->num_mem_windows = 2;
 		/* First window is for DSP internal memory */
 
-		pResources->dwPrmBase = ioremap(OMAP_IVA2_PRM_BASE,
-							OMAP_IVA2_PRM_SIZE);
-		pResources->dwCmBase = ioremap(OMAP_IVA2_CM_BASE,
-							OMAP_IVA2_CM_SIZE);
-		pResources->dwMboxBase = ioremap(OMAP_MBOX_BASE,
-							OMAP_MBOX_SIZE);
-		pResources->dwSysCtrlBase = ioremap(OMAP_SYSC_BASE,
-							OMAP_SYSC_SIZE);
-		GT_1trace(curTrace, GT_2CLASS, "dwMemBase[0] 0x%x\n",
-			 pResources->dwMemBase[0]);
-		GT_1trace(curTrace, GT_2CLASS, "dwMemBase[3] 0x%x\n",
-			 pResources->dwMemBase[3]);
-		GT_1trace(curTrace, GT_2CLASS, "dwPrmBase 0x%x\n",
-							pResources->dwPrmBase);
-		GT_1trace(curTrace, GT_2CLASS, "dwCmBase 0x%x\n",
-							pResources->dwCmBase);
-		GT_1trace(curTrace, GT_2CLASS, "dwWdTimerDspBase 0x%x\n",
-						pResources->dwWdTimerDspBase);
-		GT_1trace(curTrace, GT_2CLASS, "dwMboxBase 0x%x\n",
-						pResources->dwMboxBase);
-		GT_1trace(curTrace, GT_2CLASS, "dwDmmuBase 0x%x\n",
-						pResources->dwDmmuBase);
+		host_res->dw_prm_base = ioremap(OMAP_IVA2_PRM_BASE,
+						OMAP_IVA2_PRM_SIZE);
+		host_res->dw_cm_base = ioremap(OMAP_IVA2_CM_BASE,
+					       OMAP_IVA2_CM_SIZE);
+		host_res->dw_sys_ctrl_base = ioremap(OMAP_SYSC_BASE,
+						     OMAP_SYSC_SIZE);
+		dev_dbg(bridge, "dw_mem_base[0] 0x%x\n",
+			host_res->dw_mem_base[0]);
+		dev_dbg(bridge, "dw_mem_base[3] 0x%x\n",
+			host_res->dw_mem_base[3]);
+		dev_dbg(bridge, "dw_prm_base %p\n", host_res->dw_prm_base);
+		dev_dbg(bridge, "dw_cm_base %p\n", host_res->dw_cm_base);
+		dev_dbg(bridge, "dw_dmmu_base %p\n", host_res->dw_dmmu_base);
 
 		/* for 24xx base port is not mapping the mamory for DSP
 		 * internal memory TODO Do a ioremap here */
 		/* Second window is for DSP external memory shared with MPU */
-		if (DSP_SUCCEEDED(status)) {
-			/* for Linux, these are hard-coded values */
-			pResources->bIRQRegisters = 0;
-			pResources->bIRQAttrib = 0;
-			pResources->dwOffsetForMonitor = 0;
-			pResources->dwChnlOffset = 0;
-			/* CHNL_MAXCHANNELS */
-			pResources->dwNumChnls = CHNL_MAXCHANNELS;
-			pResources->dwChnlBufSize = 0x400;
-			dwBuffSize = sizeof(struct CFG_HOSTRES);
-			status = REG_SetValue(NULL, (char *) dwContext,
-					     CURRENTCONFIG, REG_BINARY,
-					     (u8 *)pResources,
-					     sizeof(struct CFG_HOSTRES));
-			if (DSP_SUCCEEDED(status)) {
-				GT_0trace(curTrace, GT_1CLASS,
-					 " Successfully set the registry "
-					 "value for CURRENTCONFIG\n");
-			} else {
-				GT_0trace(curTrace, GT_7CLASS,
-					 " Failed to set the registry "
-					 "value for CURRENTCONFIG\n");
-			}
+
+		/* For Linux, these are hard-coded values */
+		host_res->birq_registers = 0;
+		host_res->birq_attrib = 0;
+		host_res->dw_offset_for_monitor = 0;
+		host_res->dw_chnl_offset = 0;
+		/* CHNL_MAXCHANNELS */
+		host_res->dw_num_chnls = CHNL_MAXCHANNELS;
+		host_res->dw_chnl_buf_size = 0x400;
+		dw_buff_size = sizeof(struct cfg_hostres);
+		status = reg_set_value(CURRENTCONFIG, (u8 *) host_res,
+				       sizeof(struct cfg_hostres));
+		if (DSP_FAILED(status)) {
+			dev_dbg(bridge, "%s: Failed to set the registry value "
+				"for CURRENTCONFIG\n", __func__);
 		}
-		MEM_Free(pResources);
+		kfree(host_res);
 	}
 	/* End Mem alloc */
 	return status;
 }
 
 /*
- *  ======== RequestBridgeResourcesDSP ========
+ *  ======== request_bridge_resources_dsp ========
  *  Purpose:
  *      Reserves shared memory for bridge.
  */
-static DSP_STATUS RequestBridgeResourcesDSP(u32 dwContext, s32 bRequest)
+static dsp_status request_bridge_resources_dsp(u32 dw_context, s32 bRequest)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CFG_HOSTRES *pResources;
-	u32 dwBuffSize;
-	u32 dmaAddr;
+	dsp_status status = DSP_SOK;
+	struct cfg_hostres *host_res;
+	u32 dw_buff_size;
+	u32 dma_addr;
 	u32 shm_size;
 
-	DBC_Require(dwContext != 0);
+	DBC_REQUIRE(dw_context != 0);
 
-	GT_0trace(curTrace, GT_ENTER, "->RequestBridgeResourcesDSP \n");
+	dw_buff_size = sizeof(struct cfg_hostres);
 
-	dwBuffSize = sizeof(struct CFG_HOSTRES);
+	host_res = mem_calloc(dw_buff_size, MEM_NONPAGED);
 
-	pResources = MEM_Calloc(dwBuffSize, MEM_NONPAGED);
-
-	if (pResources != NULL) {
-		if (DSP_FAILED(CFG_GetHostResources((struct CFG_DEVNODE *)
-		   dwContext, pResources))) {
-			/* Call CFG_GetHostResources to get reserve resouces */
-			status = RequestBridgeResources(dwContext, bRequest);
+	if (host_res != NULL) {
+		if (DSP_FAILED(cfg_get_host_resources((struct cfg_devnode *)
+						      dw_context, host_res))) {
+			status = request_bridge_resources(dw_context, bRequest);
 			if (DSP_SUCCEEDED(status)) {
-				status = CFG_GetHostResources
-					((struct CFG_DEVNODE *) dwContext,
-					pResources);
+				status = cfg_get_host_resources
+				    ((struct cfg_devnode *)dw_context,
+				     host_res);
 			}
 		}
-		/* wNumMemWindows must not be more than CFG_MAXMEMREGISTERS */
-		pResources->wNumMemWindows = 4;
+		/* num_mem_windows must not be more than CFG_MAXMEMREGISTERS */
+		host_res->num_mem_windows = 4;
 
-		pResources->dwMemBase[0] = 0;
-		pResources->dwMemBase[2] = (u32)ioremap(OMAP_DSP_MEM1_BASE,
-							OMAP_DSP_MEM1_SIZE);
-		pResources->dwMemBase[3] = (u32)ioremap(OMAP_DSP_MEM2_BASE,
-							OMAP_DSP_MEM2_SIZE);
-		pResources->dwMemBase[4] = (u32)ioremap(OMAP_DSP_MEM3_BASE,
-							OMAP_DSP_MEM3_SIZE);
-		pResources->dwPerBase = ioremap(OMAP_PER_CM_BASE,
-							OMAP_PER_CM_SIZE);
-               pResources->dwPerPmBase = (u32)ioremap(OMAP_PER_PRM_BASE,
-                                                       OMAP_PER_PRM_SIZE);
-               pResources->dwCorePmBase = (u32)ioremap(OMAP_CORE_PRM_BASE,
-                                                       OMAP_CORE_PRM_SIZE);
-		pResources->dwDmmuBase = ioremap(OMAP_DMMU_BASE,
-							OMAP_DMMU_SIZE);
-		pResources->dwWdTimerDspBase = NULL;
-
-		GT_1trace(curTrace, GT_2CLASS, "dwMemBase[0] 0x%x\n",
-						pResources->dwMemBase[0]);
-		GT_1trace(curTrace, GT_2CLASS, "dwMemBase[1] 0x%x\n",
-						pResources->dwMemBase[1]);
-		GT_1trace(curTrace, GT_2CLASS, "dwMemBase[2] 0x%x\n",
-						pResources->dwMemBase[2]);
-		GT_1trace(curTrace, GT_2CLASS, "dwMemBase[3] 0x%x\n",
-						pResources->dwMemBase[3]);
-		GT_1trace(curTrace, GT_2CLASS, "dwMemBase[4] 0x%x\n",
-						pResources->dwMemBase[4]);
-		GT_1trace(curTrace, GT_2CLASS, "dwPrmBase 0x%x\n",
-						pResources->dwPrmBase);
-		GT_1trace(curTrace, GT_2CLASS, "dwCmBase 0x%x\n",
-						pResources->dwCmBase);
-		GT_1trace(curTrace, GT_2CLASS, "dwWdTimerDspBase 0x%x\n",
-						pResources->dwWdTimerDspBase);
-		GT_1trace(curTrace, GT_2CLASS, "dwMboxBase 0x%x\n",
-						pResources->dwMboxBase);
-		GT_1trace(curTrace, GT_2CLASS, "dwDmmuBase 0x%x\n",
-						pResources->dwDmmuBase);
-		dwBuffSize = sizeof(shm_size);
-		status = REG_GetValue(NULL, CURRENTCONFIG, SHMSIZE,
-				     (u8 *)&shm_size, &dwBuffSize);
+		host_res->dw_mem_base[0] = 0;
+		host_res->dw_mem_base[2] = (u32) ioremap(OMAP_DSP_MEM1_BASE,
+							 OMAP_DSP_MEM1_SIZE);
+		host_res->dw_mem_base[3] = (u32) ioremap(OMAP_DSP_MEM2_BASE,
+							 OMAP_DSP_MEM2_SIZE);
+		host_res->dw_mem_base[4] = (u32) ioremap(OMAP_DSP_MEM3_BASE,
+							 OMAP_DSP_MEM3_SIZE);
+		host_res->dw_per_base = ioremap(OMAP_PER_CM_BASE,
+						OMAP_PER_CM_SIZE);
+		host_res->dw_per_pm_base = (u32) ioremap(OMAP_PER_PRM_BASE,
+							 OMAP_PER_PRM_SIZE);
+		host_res->dw_core_pm_base = (u32) ioremap(OMAP_CORE_PRM_BASE,
+							  OMAP_CORE_PRM_SIZE);
+		host_res->dw_dmmu_base = ioremap(OMAP_DMMU_BASE,
+						 OMAP_DMMU_SIZE);
+
+		dev_dbg(bridge, "dw_mem_base[0] 0x%x\n",
+			host_res->dw_mem_base[0]);
+		dev_dbg(bridge, "dw_mem_base[1] 0x%x\n",
+			host_res->dw_mem_base[1]);
+		dev_dbg(bridge, "dw_mem_base[2] 0x%x\n",
+			host_res->dw_mem_base[2]);
+		dev_dbg(bridge, "dw_mem_base[3] 0x%x\n",
+			host_res->dw_mem_base[3]);
+		dev_dbg(bridge, "dw_mem_base[4] 0x%x\n",
+			host_res->dw_mem_base[4]);
+		dev_dbg(bridge, "dw_prm_base %p\n", host_res->dw_prm_base);
+		dev_dbg(bridge, "dw_cm_base %p\n", host_res->dw_cm_base);
+		dev_dbg(bridge, "dw_dmmu_base %p\n", host_res->dw_dmmu_base);
+		dw_buff_size = sizeof(shm_size);
+		status =
+		    reg_get_value(SHMSIZE, (u8 *) &shm_size, &dw_buff_size);
 		if (DSP_SUCCEEDED(status)) {
 			/* Allocate Physically contiguous,
 			 * non-cacheable  memory */
-			pResources->dwMemBase[1] =
-				(u32)MEM_AllocPhysMem(shm_size, 0x100000,
-							&dmaAddr);
-			if (pResources->dwMemBase[1] == 0) {
+			host_res->dw_mem_base[1] =
+			    (u32) mem_alloc_phys_mem(shm_size, 0x100000,
+						     &dma_addr);
+			if (host_res->dw_mem_base[1] == 0) {
 				status = DSP_EMEMORY;
-				GT_0trace(curTrace, GT_7CLASS,
-					 "SHM reservation Failed\n");
+				pr_err("shm reservation Failed\n");
 			} else {
-				pResources->dwMemLength[1] = shm_size;
-				pResources->dwMemPhys[1] = dmaAddr;
+				host_res->dw_mem_length[1] = shm_size;
+				host_res->dw_mem_phys[1] = dma_addr;
 
-				GT_3trace(curTrace, GT_1CLASS,
-					 "Bridge SHM address 0x%x dmaAddr"
-					 " %x size %x\n",
-					 pResources->dwMemBase[1],
-					 dmaAddr, shm_size);
+				dev_dbg(bridge, "%s: Bridge shm address 0x%x "
+					"dma_addr %x size %x\n", __func__,
+					host_res->dw_mem_base[1],
+					dma_addr, shm_size);
 			}
 		}
 		if (DSP_SUCCEEDED(status)) {
 			/* for Linux, these are hard-coded values */
-			pResources->bIRQRegisters = 0;
-			pResources->bIRQAttrib = 0;
-			pResources->dwOffsetForMonitor = 0;
-			pResources->dwChnlOffset = 0;
+			host_res->birq_registers = 0;
+			host_res->birq_attrib = 0;
+			host_res->dw_offset_for_monitor = 0;
+			host_res->dw_chnl_offset = 0;
 			/* CHNL_MAXCHANNELS */
-			pResources->dwNumChnls = CHNL_MAXCHANNELS;
-			pResources->dwChnlBufSize = 0x400;
-			dwBuffSize = sizeof(struct CFG_HOSTRES);
-			status = REG_SetValue(NULL, (char *)dwContext,
-					     CURRENTCONFIG, REG_BINARY,
-					     (u8 *)pResources,
-					     sizeof(struct CFG_HOSTRES));
-			if (DSP_SUCCEEDED(status)) {
-				GT_0trace(curTrace, GT_1CLASS,
-					 " Successfully set the registry"
-					 " value for CURRENTCONFIG\n");
-			} else {
-				GT_0trace(curTrace, GT_7CLASS,
-					 " Failed to set the registry value"
-					 " for CURRENTCONFIG\n");
+			host_res->dw_num_chnls = CHNL_MAXCHANNELS;
+			host_res->dw_chnl_buf_size = 0x400;
+			dw_buff_size = sizeof(struct cfg_hostres);
+			status = reg_set_value(CURRENTCONFIG, (u8 *) host_res,
+					       sizeof(struct cfg_hostres));
+			if (DSP_FAILED(status)) {
+				dev_dbg(bridge, "%s: Failed to set the registry"
+					" value for CURRENTCONFIG\n", __func__);
 			}
 		}
-		MEM_Free(pResources);
+		kfree(host_res);
 	}
 	/* End Mem alloc */
 	return status;
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/drv_interface.c kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/drv_interface.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/drv_interface.c	2011-10-11 13:51:01.294958226 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/rmgr/drv_interface.c	2011-10-29 20:22:02.350873000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge driver interface.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,36 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== linux_driver.c ========
- *  Description:
- *      DSP/BIOS Bridge driver interface.
- *
- *  Public Functions:
- *      driver_init
- *      driver_exit
- *      driver_open
- *      driver_release
- *      driver_ioctl
- *      driver_mmap
- *
- *! Revision History
- *! ================
- *! 21-Apr-2004 map   Deprecated use of MODULE_PARM for kernel versions
- *!		   greater than 2.5, use module_param.
- *! 08-Mar-2004 sb    Added the dsp_debug argument, which keeps the DSP in self
- *!		   loop after image load and waits in a loop for DSP to start
- *! 16-Feb-2004 vp    Deprecated the usage of MOD_INC_USE_COUNT and
- *! 						MOD_DEC_USE_COUNT
- *!		   for kernel versions greater than 2.5
- *! 20-May-2003 vp    Added unregister functions for the DPM.
- *! 24-Mar-2003 sb    Pass pid instead of driverContext to DSP_Close
- *! 24-Mar-2003 vp    Added Power Management support.
- *! 21-Mar-2003 sb    Configure SHM size using insmod argument shm_size
- *! 10-Feb-2003 vp    Updated based on code review comments
- *! 18-Oct-2002 sb    Created initial version
- */
-
 /*  ----------------------------------- Host OS */
 
 #include <dspbridge/host_os.h>
@@ -59,94 +31,90 @@
 #include <linux/moduleparam.h>
 #include <linux/cdev.h>
 
-#include <mach/board-3430sdp.h>
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
 #include <dspbridge/errbase.h>
 
 /*  ----------------------------------- Trace & Debug */
-#include <dspbridge/gt.h>
 #include <dspbridge/dbc.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/services.h>
 #include <dspbridge/sync.h>
 #include <dspbridge/reg.h>
-#include <dspbridge/csl.h>
 
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/wcdioctl.h>
 #include <dspbridge/_dcd.h>
 #include <dspbridge/dspdrv.h>
-#include <dspbridge/dbreg.h>
 
 /*  ----------------------------------- Resource Manager */
 #include <dspbridge/pwr.h>
 
 /*  ----------------------------------- This */
 #include <drv_interface.h>
+#include <policy.h>
 
-#ifndef RES_CLEANUP_DISABLE
 #include <dspbridge/cfg.h>
 #include <dspbridge/resourcecleanup.h>
 #include <dspbridge/chnl.h>
 #include <dspbridge/proc.h>
-#include <dspbridge/cfg.h>
 #include <dspbridge/dev.h>
 #include <dspbridge/drvdefs.h>
 #include <dspbridge/drv.h>
-#include <dspbridge/dbreg.h>
-#endif
 
-#include <mach/omap-pm.h>
+#ifdef CONFIG_BRIDGE_DVFS
 #include <mach-omap2/omap3-opp.h>
+#include <dspbridge/io_sm.h>
+#endif
 
 #define BRIDGE_NAME "C6410"
 /*  ----------------------------------- Globals */
 #define DRIVER_NAME  "DspBridge"
-#define DRIVER_MAJOR 0		/* Linux assigns our Major device number */
-#define DRIVER_MINOR 0		/* Linux assigns our Major device number */
+#define DSPBRIDGE_VERSION	"0.2"
 s32 dsp_debug;
 
 struct platform_device *omap_dspbridge_dev;
+struct device *bridge;
 
-struct bridge_dev {
-	struct cdev cdev;
-};
+/* This is a test variable used by Bridge to test different sleep states */
+s32 dsp_test_sleepstate;
 
-static struct bridge_dev *bridge_device;
+static struct cdev bridge_cdev;
 
 static struct class *bridge_class;
 
-static u32 driverContext;
-#ifdef CONFIG_BRIDGE_DEBUG
-static char *GT_str;
-#endif /* CONFIG_BRIDGE_DEBUG */
-static s32 driver_major = DRIVER_MAJOR;
-static s32 driver_minor = DRIVER_MINOR;
+static u32 driver_context;
+static s32 driver_major;
 static char *base_img;
 char *iva_img;
-static char *num_procs = "C55=1";
-static s32 shm_size = 0x400000;	/* 4 MB */
+static s32 shm_size = 0x500000;	/* 5 MB */
 static u32 phys_mempool_base;
 static u32 phys_mempool_size;
 static int tc_wordswapon;	/* Default value is always false */
-
+#ifdef CONFIG_BRIDGE_RECOVERY
+#define REC_TIMEOUT 5000	/*recovery timeout in msecs */
+static atomic_t bridge_cref;	/* number of bridge open handles */
+static struct workqueue_struct *bridge_rec_queue;
+static struct work_struct bridge_recovery_work;
+static DECLARE_COMPLETION(bridge_comp);
+static DECLARE_COMPLETION(bridge_open_comp);
+static bool recover;
+#endif
 /* Minimum ACTIVE VDD1 OPP level for reliable DSP operation */
 unsigned short min_active_opp = 3;
 
 #ifdef CONFIG_PM
-struct omap34xx_bridge_suspend_data {
+struct omap34_xx_bridge_suspend_data {
 	int suspended;
 	wait_queue_head_t suspend_wq;
 };
 
-static struct omap34xx_bridge_suspend_data bridge_suspend_data;
+static struct omap34_xx_bridge_suspend_data bridge_suspend_data;
 
-static int omap34xxbridge_suspend_lockout(
-		struct omap34xx_bridge_suspend_data *s, struct file *f)
+static int omap34_xxbridge_suspend_lockout(struct omap34_xx_bridge_suspend_data
+					   *s, struct file *f)
 {
 	if ((s)->suspended) {
 		if ((f)->f_flags & O_NONBLOCK)
@@ -155,36 +123,27 @@
 	}
 	return 0;
 }
-
 #endif
 
-#ifdef DEBUG
-module_param(GT_str, charp, 0);
-MODULE_PARM_DESC(GT_str, "GT string, default = NULL");
-
 module_param(dsp_debug, int, 0);
 MODULE_PARM_DESC(dsp_debug, "Wait after loading DSP image. default = false");
-#endif
 
-module_param(driver_major, int, 0);	/* Driver's major number */
-MODULE_PARM_DESC(driver_major, "Major device number, default = 0 (auto)");
-
-module_param(driver_minor, int, 0);	/* Driver's major number */
-MODULE_PARM_DESC(driver_minor, "Minor device number, default = 0 (auto)");
+module_param(dsp_test_sleepstate, int, 0);
+MODULE_PARM_DESC(dsp_test_sleepstate, "DSP Sleep state = 0");
 
 module_param(base_img, charp, 0);
 MODULE_PARM_DESC(base_img, "DSP base image, default = NULL");
 
 module_param(shm_size, int, 0);
-MODULE_PARM_DESC(shm_size, "SHM size, default = 4 MB, minimum = 64 KB");
+MODULE_PARM_DESC(shm_size, "shm size, default = 5 MB, minimum = 64 KB");
 
 module_param(phys_mempool_base, uint, 0);
 MODULE_PARM_DESC(phys_mempool_base,
-		"Physical memory pool base passed to driver");
+		 "Physical memory pool base passed to driver");
 
 module_param(phys_mempool_size, uint, 0);
 MODULE_PARM_DESC(phys_mempool_size,
-		"Physical memory pool size passed to driver");
+		 "Physical memory pool size passed to driver");
 module_param(tc_wordswapon, int, 0);
 MODULE_PARM_DESC(tc_wordswapon, "TC Word Swap Option. default = 0");
 
@@ -193,146 +152,114 @@
 
 MODULE_AUTHOR("Texas Instruments");
 MODULE_LICENSE("GPL");
+MODULE_VERSION(DSPBRIDGE_VERSION);
 
 static char *driver_name = DRIVER_NAME;
 
-#ifdef CONFIG_BRIDGE_DEBUG
-static struct GT_Mask driverTrace;
-#endif /* CONFIG_BRIDGE_DEBUG */
-
 static struct file_operations bridge_fops = {
-	.open		= bridge_open,
-	.release	= bridge_release,
-	.unlocked_ioctl	= bridge_ioctl,
-	.mmap		= bridge_mmap,
+	.open = bridge_open,
+	.release = bridge_release,
+	.unlocked_ioctl = bridge_ioctl,
+	.mmap = bridge_mmap,
 };
 
 #ifdef CONFIG_PM
-static u32 timeOut = 1000;
+static u32 time_out = 1000;
 #ifdef CONFIG_BRIDGE_DVFS
 static struct clk *clk_handle;
-s32 dsp_max_opps = VDD1_OPP5;
-#endif
-
-/* Maximum Opps that can be requested by IVA*/
-/*vdd1 rate table*/
-#ifdef CONFIG_BRIDGE_DVFS
-const struct omap_opp  vdd1_rate_table_bridge[] = {
-	{0, 0, 0},
-	/*OPP1*/
-	{S125M, VDD1_OPP1, 0},
-	/*OPP2*/
-	{S250M, VDD1_OPP2, 0},
-	/*OPP3*/
-	{S500M, VDD1_OPP3, 0},
-	/*OPP4*/
-	{S550M, VDD1_OPP4, 0},
-	/*OPP5*/
-	{S600M, VDD1_OPP5, 0},
-};
 #endif
 #endif
 
 struct dspbridge_platform_data *omap_dspbridge_pdata;
 
-u32 vdd1_dsp_freq[6][4] = {
-	{0, 0, 0, 0},
-	/*OPP1*/
-	{0, 90000, 0, 86000},
-	/*OPP2*/
-	{0, 180000, 80000, 170000},
-	/*OPP3*/
-	{0, 360000, 160000, 340000},
-	/*OPP4*/
-	{0, 396000, 325000, 376000},
-	/*OPP5*/
-	{0, 430000, 355000, 430000},
-};
-
+#ifdef CONFIG_BRIDGE_RECOVERY
+static void bridge_recover(struct work_struct *work)
+{
+	struct dev_object *dev;
+	struct cfg_devnode *dev_node;
+	if (atomic_read(&bridge_cref)) {
+		INIT_COMPLETION(bridge_comp);
+		while (!wait_for_completion_timeout(&bridge_comp,
+						msecs_to_jiffies(REC_TIMEOUT)))
+			pr_info("%s:%d handle(s) still opened\n",
+					__func__, atomic_read(&bridge_cref));
+	}
+	dev = dev_get_first();
+	dev_get_dev_node(dev, &dev_node);
+	if (!dev_node || DSP_FAILED(proc_auto_start(dev_node, dev)))
+		pr_err("DSP could not be restarted\n");
+	recover = false;
+	complete_all(&bridge_open_comp);
+}
+
+void bridge_recover_schedule(void)
+{
+	INIT_COMPLETION(bridge_open_comp);
+	recover = true;
+	queue_work(bridge_rec_queue, &bridge_recovery_work);
+}
+#endif
 #ifdef CONFIG_BRIDGE_DVFS
-static int dspbridge_post_scale(struct notifier_block *op, unsigned long level,
-				void *ptr)
+static int dspbridge_scale_notification(struct notifier_block *op,
+		unsigned long val, void *ptr)
 {
-	PWR_PM_PostScale(PRCM_VDD1, level);
+	struct dspbridge_platform_data *pdata =
+					omap_dspbridge_dev->dev.platform_data;
+	struct cpufreq_freqs *freqs = ptr;
+	if (CPUFREQ_POSTCHANGE == val && pdata->dsp_get_opp_for_freq) {
+
+		pwr_pm_post_scale(PRCM_VDD1, (*pdata->dsp_get_opp_for_freq)(freqs->new));
+	}
 	return 0;
 }
 
 static struct notifier_block iva_clk_notifier = {
-	.notifier_call = dspbridge_post_scale,
+	.notifier_call = dspbridge_scale_notification,
 	NULL,
 };
+
 #endif
 
-static int __devinit omap34xx_bridge_probe(struct platform_device *pdev)
+static int __devinit omap34_xx_bridge_probe(struct platform_device *pdev)
 {
 	int status;
-	u32 initStatus;
+	u32 init_status;
 	u32 temp;
-	dev_t   dev = 0 ;
-	int     result;
-#ifdef CONFIG_BRIDGE_DVFS
-	int i = 0;
-#endif
+	dev_t dev = 0;
+	int result;
 	struct dspbridge_platform_data *pdata = pdev->dev.platform_data;
 
 	omap_dspbridge_dev = pdev;
 
+	/* Global bridge device */
+	bridge = &omap_dspbridge_dev->dev;
+
 	/* use 2.6 device model */
-	if (driver_major) {
-		dev = MKDEV(driver_major, driver_minor);
-		result = register_chrdev_region(dev, 1, driver_name);
-	} else {
-		result = alloc_chrdev_region(&dev, driver_minor, 1,
-					    driver_name);
-		driver_major = MAJOR(dev);
+	result = alloc_chrdev_region(&dev, 0, 1, driver_name);
+	if (result < 0) {
+		pr_err("%s: Can't get major %d\n", __func__, driver_major);
+		goto err1;
 	}
 
-	if (result < 0) {
-		GT_1trace(driverTrace, GT_7CLASS, "bridge_init: "
-				"Can't get Major %d \n", driver_major);
-		return result;
-	}
-
-	bridge_device = kmalloc(sizeof(struct bridge_dev), GFP_KERNEL);
-	if (!bridge_device) {
-		result = -ENOMEM;
-		unregister_chrdev_region(dev, 1);
-		return result;
-	}
-	memset(bridge_device, 0, sizeof(struct bridge_dev));
-	cdev_init(&bridge_device->cdev, &bridge_fops);
-	bridge_device->cdev.owner = THIS_MODULE;
-	bridge_device->cdev.ops = &bridge_fops;
+	driver_major = MAJOR(dev);
 
-	status = cdev_add(&bridge_device->cdev, dev, 1);
+	cdev_init(&bridge_cdev, &bridge_fops);
+	bridge_cdev.owner = THIS_MODULE;
 
+	status = cdev_add(&bridge_cdev, dev, 1);
 	if (status) {
-		GT_0trace(driverTrace, GT_7CLASS,
-				"Failed to add the bridge device \n");
-		return status;
+		pr_err("%s: Failed to add bridge device\n", __func__);
+		goto err2;
 	}
 
 	/* udev support */
 	bridge_class = class_create(THIS_MODULE, "ti_bridge");
 
 	if (IS_ERR(bridge_class))
-		GT_0trace(driverTrace, GT_7CLASS,
-				"Error creating bridge class \n");
-
-	device_create(bridge_class, NULL, MKDEV(driver_major, driver_minor),
-			NULL, "DspBridge");
+		pr_err("%s: Error creating bridge class\n", __func__);
 
-	GT_init();
-	GT_create(&driverTrace, "LD");
-
-#ifdef DEBUG
-	if (GT_str)
-		GT_set(GT_str);
-#elif defined(DDSP_DEBUG_PRODUCT) && GT_TRACE
-	GT_set("**=67");
-#endif
-
-	GT_0trace(driverTrace, GT_ENTER, "-> driver_init\n");
+	device_create(bridge_class, NULL, MKDEV(driver_major, 0),
+		      NULL, "DspBridge");
 
 #ifdef CONFIG_PM
 	/* Initialize the wait queue */
@@ -342,193 +269,153 @@
 	}
 #endif
 
-	SERVICES_Init();
+	services_init();
 
 	/*  Autostart flag.  This should be set to true if the DSP image should
-	 *  be loaded and run during bridge module initialization  */
+	 *  be loaded and run during bridge module initialization */
 
 	if (base_img) {
 		temp = true;
-		REG_SetValue(NULL, NULL, AUTOSTART, REG_DWORD, (u8 *)&temp,
-			    sizeof(temp));
-		REG_SetValue(NULL, NULL, DEFEXEC, REG_SZ, (u8 *)base_img,
-						strlen(base_img) + 1);
+		reg_set_value(AUTOSTART, (u8 *) &temp, sizeof(temp));
+		reg_set_value(DEFEXEC, (u8 *) base_img, strlen(base_img) + 1);
 	} else {
 		temp = false;
-		REG_SetValue(NULL, NULL, AUTOSTART, REG_DWORD, (u8 *)&temp,
-			    sizeof(temp));
-		REG_SetValue(NULL, NULL, DEFEXEC, REG_SZ, (u8 *) "\0", (u32)2);
+		reg_set_value(AUTOSTART, (u8 *) &temp, sizeof(temp));
+		reg_set_value(DEFEXEC, (u8 *) "\0", (u32) 2);
 	}
-	REG_SetValue(NULL, NULL, NUMPROCS, REG_SZ, (u8 *) num_procs,
-						strlen(num_procs) + 1);
 
 	if (shm_size >= 0x10000) {	/* 64 KB */
-		initStatus = REG_SetValue(NULL, NULL, SHMSIZE, REG_DWORD,
-					  (u8 *)&shm_size, sizeof(shm_size));
+		init_status = reg_set_value(SHMSIZE, (u8 *) &shm_size,
+					    sizeof(shm_size));
 	} else {
-		initStatus = DSP_EINVALIDARG;
+		init_status = DSP_EINVALIDARG;
 		status = -1;
-		GT_0trace(driverTrace, GT_7CLASS,
-			  "SHM size must be at least 64 KB\n");
+		pr_err("%s: shm size must be at least 64 KB\n", __func__);
 	}
-	GT_1trace(driverTrace, GT_7CLASS,
-		 "requested shm_size = 0x%x\n", shm_size);
+	dev_dbg(bridge, "%s: requested shm_size = 0x%x\n", __func__, shm_size);
 
 	if (pdata->phys_mempool_base && pdata->phys_mempool_size) {
 		phys_mempool_base = pdata->phys_mempool_base;
 		phys_mempool_size = pdata->phys_mempool_size;
 	}
 
-	if (phys_mempool_base > 0x0) {
-		initStatus = REG_SetValue(NULL, NULL, PHYSMEMPOOLBASE,
-					 REG_DWORD, (u8 *)&phys_mempool_base,
-					 sizeof(phys_mempool_base));
-	}
-	GT_1trace(driverTrace, GT_7CLASS, "phys_mempool_base = 0x%x \n",
-		 phys_mempool_base);
-
-	if (phys_mempool_size > 0x0) {
-		initStatus = REG_SetValue(NULL, NULL, PHYSMEMPOOLSIZE,
-					 REG_DWORD, (u8 *)&phys_mempool_size,
-					 sizeof(phys_mempool_size));
-	}
-	GT_1trace(driverTrace, GT_7CLASS, "phys_mempool_size = 0x%x\n",
-		 phys_mempool_base);
+	dev_dbg(bridge, "%s: phys_mempool_base = 0x%x \n", __func__,
+		phys_mempool_base);
+
+	dev_dbg(bridge, "%s: phys_mempool_size = 0x%x\n", __func__,
+		phys_mempool_base);
 	if ((phys_mempool_base > 0x0) && (phys_mempool_size > 0x0))
-		MEM_ExtPhysPoolInit(phys_mempool_base, phys_mempool_size);
+		mem_ext_phys_pool_init(phys_mempool_base, phys_mempool_size);
 	if (tc_wordswapon) {
-		GT_0trace(driverTrace, GT_7CLASS, "TC Word Swap is enabled\n");
-		REG_SetValue(NULL, NULL, TCWORDSWAP, REG_DWORD,
-			    (u8 *)&tc_wordswapon, sizeof(tc_wordswapon));
+		dev_dbg(bridge, "%s: TC Word Swap is enabled\n", __func__);
+		reg_set_value(TCWORDSWAP, (u8 *) &tc_wordswapon,
+			      sizeof(tc_wordswapon));
 	} else {
-		GT_0trace(driverTrace, GT_7CLASS, "TC Word Swap is disabled\n");
-		REG_SetValue(NULL, NULL, TCWORDSWAP,
-			    REG_DWORD, (u8 *)&tc_wordswapon,
-			    sizeof(tc_wordswapon));
+		dev_dbg(bridge, "%s: TC Word Swap is disabled\n", __func__);
+		reg_set_value(TCWORDSWAP, (u8 *) &tc_wordswapon,
+			      sizeof(tc_wordswapon));
 	}
-	if (DSP_SUCCEEDED(initStatus)) {
+	if (DSP_SUCCEEDED(init_status)) {
 #ifdef CONFIG_BRIDGE_DVFS
-		for (i = 0; i < 6; i++)
-			pdata->mpu_speed[i] = vdd1_rate_table_bridge[i].rate;
-
 		clk_handle = clk_get(NULL, "iva2_ck");
-		if (!clk_handle) {
-			GT_0trace(driverTrace, GT_7CLASS,
-			"clk_get failed to get iva2_ck \n");
-		} else {
-			GT_0trace(driverTrace, GT_7CLASS,
-			"clk_get PASS to get iva2_ck \n");
-		}
-		if (!clk_notifier_register(clk_handle, &iva_clk_notifier)) {
-			GT_0trace(driverTrace, GT_7CLASS,
-			"clk_notifier_register PASS for iva2_ck \n");
-		} else {
-			GT_0trace(driverTrace, GT_7CLASS,
-			"clk_notifier_register FAIL for iva2_ck \n");
-		}
+		if (!clk_handle)
+			pr_err("%s: clk_get failed to get iva2_ck\n", __func__);
 
+		if (cpufreq_register_notifier(&iva_clk_notifier,
+						CPUFREQ_TRANSITION_NOTIFIER))
+			pr_err("%s: cpufreq_register_notifier failed for "
+			       "iva2_ck\n", __func__);
 		/*
 		 * When Smartreflex is ON, DSP requires at least OPP level 3
 		 * to operate reliably. So boost lower OPP levels to OPP3.
 		 */
 		if (pdata->dsp_set_min_opp)
 			(*pdata->dsp_set_min_opp)(min_active_opp);
+		/* Update min CPU speed accordingly */
+		pdata->mpu_min_speed=pdata->mpu_speeds[min_active_opp];
 #endif
-		driverContext = DSP_Init(&initStatus);
-		if (DSP_FAILED(initStatus)) {
+		driver_context = dsp_init(&init_status);
+		if (DSP_FAILED(init_status)) {
 			status = -1;
-			GT_0trace(driverTrace, GT_7CLASS,
-				 "DSP/BIOS Bridge initialization Failed\n");
+			pr_err("DSP Bridge driver initialization failed\n");
 		} else {
-			GT_0trace(driverTrace, GT_5CLASS,
-					"DSP/BIOS Bridge driver loaded\n");
+			pr_info("DSP Bridge driver loaded\n");
 		}
 	}
 
-	DBC_Assert(status == 0);
-	DBC_Assert(DSP_SUCCEEDED(initStatus));
-	GT_0trace(driverTrace, GT_ENTER, " <- driver_init\n");
-	return status;
+#ifdef CONFIG_BRIDGE_RECOVERY
+	bridge_rec_queue = create_workqueue("bridge_rec_queue");
+	INIT_WORK(&bridge_recovery_work, bridge_recover);
+	INIT_COMPLETION(bridge_comp);
+#endif
+	DBC_ASSERT(status == 0);
+	DBC_ASSERT(DSP_SUCCEEDED(init_status));
+
+	policy_init(bridge_class);
+
+	return 0;
+
+err2:
+	unregister_chrdev_region(dev, 1);
+err1:
+	return result;
 }
 
-static int __devexit omap34xx_bridge_remove(struct platform_device *pdev)
+static int __devexit omap34_xx_bridge_remove(struct platform_device *pdev)
 {
 	dev_t devno;
 	bool ret;
-	DSP_STATUS dsp_status = DSP_SOK;
-	HANDLE	     hDrvObject = NULL;
-	struct PROCESS_CONTEXT	*pTmp = NULL;
-	struct PROCESS_CONTEXT    *pCtxtclosed = NULL;
-	struct PROC_OBJECT *proc_obj_ptr, *temp;
+	dsp_status status = DSP_SOK;
+	bhandle hdrv_obj = NULL;
 
-	GT_0trace(driverTrace, GT_ENTER, "-> driver_exit\n");
+	policy_remove();
 
-	dsp_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	if (DSP_FAILED(dsp_status))
+	status = cfg_get_object((u32 *) &hdrv_obj, REG_DRV_OBJECT);
+	if (DSP_FAILED(status))
 		goto func_cont;
 
 #ifdef CONFIG_BRIDGE_DVFS
-	if (!clk_notifier_unregister(clk_handle, &iva_clk_notifier)) {
-		GT_0trace(driverTrace, GT_7CLASS,
-		"clk_notifier_unregister PASS for iva2_ck \n");
-	} else {
-		GT_0trace(driverTrace, GT_7CLASS,
-		"clk_notifier_unregister FAILED for iva2_ck \n");
-	}
+	if (cpufreq_unregister_notifier(&iva_clk_notifier,
+						CPUFREQ_TRANSITION_NOTIFIER))
+		pr_err("%s: cpufreq_unregister_notifier failed for iva2_ck\n",
+			__func__);
 #endif /* #ifdef CONFIG_BRIDGE_DVFS */
 
-	DRV_GetProcCtxtList(&pCtxtclosed, (struct DRV_OBJECT *)hDrvObject);
-	while (pCtxtclosed != NULL) {
-		GT_1trace(driverTrace, GT_5CLASS, "***Cleanup of "
-			 "process***%d\n", pCtxtclosed->pid);
-		DRV_RemoveAllResources(pCtxtclosed);
-		list_for_each_entry_safe(proc_obj_ptr, temp,
-				&pCtxtclosed->processor_list, proc_object) {
-			PROC_Detach(proc_obj_ptr, pCtxtclosed);
-		}
-		pTmp = pCtxtclosed->next;
-		DRV_RemoveProcContext((struct DRV_OBJECT *)hDrvObject,
-				pCtxtclosed);
-		pCtxtclosed = pTmp;
-	}
-
-	if (driverContext) {
+	if (driver_context) {
 		/* Put the DSP in reset state */
-		ret = DSP_Deinit(driverContext);
-		driverContext = 0;
-		DBC_Assert(ret == true);
+		ret = dsp_deinit(driver_context);
+		driver_context = 0;
+		DBC_ASSERT(ret == true);
 	}
-
+#ifdef CONFIG_BRIDGE_DVFS
 	clk_put(clk_handle);
 	clk_handle = NULL;
+#endif /* #ifdef CONFIG_BRIDGE_DVFS */
 
 func_cont:
-	SERVICES_Exit();
-	GT_exit();
+	mem_ext_phys_pool_release();
 
-	devno = MKDEV(driver_major, driver_minor);
-	if (bridge_device) {
-		cdev_del(&bridge_device->cdev);
-		kfree(bridge_device);
-	}
+	services_exit();
+
+	devno = MKDEV(driver_major, 0);
+	cdev_del(&bridge_cdev);
 	unregister_chrdev_region(devno, 1);
 	if (bridge_class) {
 		/* remove the device from sysfs */
-		device_destroy(bridge_class, MKDEV(driver_major, driver_minor));
+		device_destroy(bridge_class, MKDEV(driver_major, 0));
 		class_destroy(bridge_class);
 
 	}
 	return 0;
 }
 
-
 #ifdef CONFIG_PM
-static int bridge_suspend(struct platform_device *pdev, pm_message_t state)
+static int BRIDGE_SUSPEND(struct platform_device *pdev, pm_message_t state)
 {
 	u32 status;
 	u32 command = PWR_EMERGENCYDEEPSLEEP;
 
-	status = PWR_SleepDSP(command, timeOut);
+	status = pwr_sleep_dsp(command, time_out);
 	if (DSP_FAILED(status))
 		return -1;
 
@@ -536,11 +423,11 @@
 	return 0;
 }
 
-static int bridge_resume(struct platform_device *pdev)
+static int BRIDGE_RESUME(struct platform_device *pdev)
 {
 	u32 status;
 
-	status = PWR_WakeDSP(timeOut);
+	status = pwr_wake_dsp(time_out);
 	if (DSP_FAILED(status))
 		return -1;
 
@@ -549,18 +436,18 @@
 	return 0;
 }
 #else
-#define bridge_suspend NULL
-#define bridge_resume NULL
+#define BRIDGE_SUSPEND NULL
+#define BRIDGE_RESUME NULL
 #endif
 
 static struct platform_driver bridge_driver = {
 	.driver = {
-		.name = BRIDGE_NAME,
-	},
-	.probe	 = omap34xx_bridge_probe,
-	.remove	 = __devexit_p(omap34xx_bridge_remove),
-	.suspend = bridge_suspend,
-	.resume	 = bridge_resume,
+		   .name = BRIDGE_NAME,
+		   },
+	.probe = omap34_xx_bridge_probe,
+	.remove = __devexit_p(omap34_xx_bridge_remove),
+	.suspend = BRIDGE_SUSPEND,
+	.resume = BRIDGE_RESUME,
 };
 
 static int __init bridge_init(void)
@@ -580,32 +467,45 @@
 static int bridge_open(struct inode *ip, struct file *filp)
 {
 	int status = 0;
-	DSP_STATUS dsp_status;
-	HANDLE hDrvObject;
-	struct PROCESS_CONTEXT *pr_ctxt = NULL;
+	struct process_context *pr_ctxt = NULL;
 
-	GT_0trace(driverTrace, GT_ENTER, "-> bridge_open\n");
+#ifdef CONFIG_BRIDGE_RECOVERY
+	if (recover) {
+		if (filp->f_flags & O_NONBLOCK ||
+			wait_for_completion_interruptible(&bridge_open_comp))
+			return -EBUSY;
+	}
+#endif
 
-	dsp_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	if (DSP_SUCCEEDED(dsp_status)) {
-		/*
-		 * Allocate a new process context and insert it into global
-		 * process context list.
-		 */
-		DRV_InsertProcContext(hDrvObject, &pr_ctxt);
-		if (pr_ctxt) {
-			DRV_ProcUpdatestate(pr_ctxt, PROC_RES_ALLOCATED);
-			DRV_ProcSetPID(pr_ctxt, current->tgid);
-		} else {
-			status = -ENOMEM;
-		}
+	/*
+	 * Allocate a new process context and insert it into global
+	 * process context list.
+	 */
+	pr_ctxt = mem_calloc(sizeof(struct process_context), MEM_PAGED);
+	if (pr_ctxt) {
+		pr_ctxt->res_state = PROC_RES_ALLOCATED;
+		spin_lock_init(&pr_ctxt->dmm_map_lock);
+		INIT_LIST_HEAD(&pr_ctxt->dmm_map_list);
+		spin_lock_init(&pr_ctxt->dmm_rsv_lock);
+		INIT_LIST_HEAD(&pr_ctxt->dmm_rsv_list);
+		mutex_init(&pr_ctxt->node_mutex);
+		mutex_init(&pr_ctxt->strm_mutex);
 	} else {
-		status = -EIO;
+		return -ENOMEM;
 	}
 
 	filp->private_data = pr_ctxt;
 
-	GT_0trace(driverTrace, GT_ENTER, "<- bridge_open\n");
+	status = policy_open_hook(ip, filp);
+	if (status) {
+		kfree(pr_ctxt);
+		filp->private_data = NULL;
+		return status;
+	}
+
+#ifdef CONFIG_BRIDGE_RECOVERY
+	atomic_inc(&bridge_cref);
+#endif
 	return status;
 }
 
@@ -616,124 +516,127 @@
 static int bridge_release(struct inode *ip, struct file *filp)
 {
 	int status = 0;
-	DSP_STATUS dsp_status;
-	HANDLE hDrvObject;
-	struct PROCESS_CONTEXT *pr_ctxt;
-	struct PROC_OBJECT *proc_obj_ptr, *temp;
+	struct process_context *pr_ctxt;
 
-	GT_0trace(driverTrace, GT_ENTER, "-> bridge_release\n");
+	status = policy_release_hook(ip, filp);
+	if (status)
+		return status;
 
 	if (!filp->private_data) {
 		status = -EIO;
-	} else {
-		pr_ctxt = filp->private_data;
-		dsp_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-		if (DSP_SUCCEEDED(dsp_status)) {
-			flush_signals(current);
-			DRV_RemoveAllResources(pr_ctxt);
-			list_for_each_entry_safe(proc_obj_ptr, temp,
-					&pr_ctxt->processor_list,
-					proc_object) {
-				PROC_Detach(proc_obj_ptr, pr_ctxt);
-			}
-			DRV_RemoveProcContext((struct DRV_OBJECT *)hDrvObject,
-					pr_ctxt);
-		} else {
-			status = -EIO;
-		}
-		filp->private_data = NULL;
+		goto err;
 	}
 
-	GT_0trace(driverTrace, GT_ENTER, "<- bridge_release\n");
+	pr_ctxt = filp->private_data;
+	flush_signals(current);
+	drv_remove_all_resources(pr_ctxt);
+	proc_detach(pr_ctxt);
+	kfree(pr_ctxt);
+
+	filp->private_data = NULL;
+
+err:
+#ifdef CONFIG_BRIDGE_RECOVERY
+	if (!atomic_dec_return(&bridge_cref))
+		complete(&bridge_comp);
+#endif
 	return status;
 }
 
 /* This function provides IO interface to the bridge driver. */
 static long bridge_ioctl(struct file *filp, unsigned int code,
-		unsigned long args)
+			 unsigned long args)
 {
 	int status;
 	u32 retval = DSP_SOK;
-	union Trapped_Args pBufIn;
+	union Trapped_Args buf_in;
 
-	DBC_Require(filp != NULL);
+	status = policy_ioctl_pre_hook(filp, code, args);
+	if (status)
+		return status;
+
+	DBC_REQUIRE(filp != NULL);
+#ifdef CONFIG_BRIDGE_RECOVERY
+	if (recover) {
+		status = -EIO;
+		goto err;
+	}
+#endif
 #ifdef CONFIG_PM
-	status = omap34xxbridge_suspend_lockout(&bridge_suspend_data, filp);
+	status = omap34_xxbridge_suspend_lockout(&bridge_suspend_data, filp);
 	if (status != 0)
 		return status;
 #endif
 
-	GT_0trace(driverTrace, GT_ENTER, " -> driver_ioctl\n");
-
-	/* Deduct one for the CMD_BASE. */
-	code = (code - 1);
+	if (!filp->private_data) {
+		status = -EIO;
+		goto err;
+	}
 
-	status = copy_from_user(&pBufIn, (union Trapped_Args *)args,
+	status = copy_from_user(&buf_in, (union Trapped_Args *)args,
 				sizeof(union Trapped_Args));
 
-	if (status >= 0) {
-		status = WCD_CallDevIOCtl(code, &pBufIn, &retval,
-				filp->private_data);
+	if (!status) {
+		status = wcd_call_dev_io_ctl(code, &buf_in, &retval,
+					     filp->private_data);
 
 		if (DSP_SUCCEEDED(status)) {
 			status = retval;
 		} else {
-			GT_1trace(driverTrace, GT_7CLASS,
-				 "IOCTL Failed, code : 0x%x\n", code);
+			dev_dbg(bridge, "%s: IOCTL Failed, code: 0x%x "
+				"status 0x%x\n", __func__, code, status);
 			status = -1;
 		}
 
 	}
 
-	GT_0trace(driverTrace, GT_ENTER, " <- driver_ioctl\n");
+	status = policy_ioctl_post_hook(filp, code, args, status);
 
+err:
 	return status;
 }
 
 /* This function maps kernel space memory to user space memory. */
 static int bridge_mmap(struct file *filp, struct vm_area_struct *vma)
 {
-#if GT_TRACE
 	u32 offset = vma->vm_pgoff << PAGE_SHIFT;
-#endif
 	u32 status;
 
-	DBC_Assert(vma->vm_start < vma->vm_end);
+	status = policy_mmap_hook(filp);
+	if (status)
+		return status;
+
+	DBC_ASSERT(vma->vm_start < vma->vm_end);
 
 	vma->vm_flags |= VM_RESERVED | VM_IO;
 	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 
-	GT_6trace(driverTrace, GT_3CLASS,
-		 "vm filp %p offset %lx start %lx end %lx"
-		 " page_prot %lx flags %lx\n", filp, offset, vma->vm_start,
-		 vma->vm_end, vma->vm_page_prot, vma->vm_flags);
+	dev_dbg(bridge, "%s: vm filp %p offset %x start %lx end %lx page_prot "
+		"%lx flags %lx\n", __func__, filp, offset,
+		vma->vm_start, vma->vm_end, vma->vm_page_prot, vma->vm_flags);
 
 	status = remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
-				vma->vm_end - vma->vm_start, vma->vm_page_prot);
+				 vma->vm_end - vma->vm_start,
+				 vma->vm_page_prot);
 	if (status != 0)
 		status = -EAGAIN;
 
 	return status;
 }
 
-#ifndef RES_CLEANUP_DISABLE
 /* To remove all process resources before removing the process from the
- * process context list*/
-DSP_STATUS DRV_RemoveAllResources(HANDLE hPCtxt)
+ * process context list */
+dsp_status drv_remove_all_resources(bhandle hPCtxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	if (pCtxt != NULL) {
-		DRV_RemoveAllSTRMResElements(pCtxt);
-		DRV_RemoveAllNodeResElements(pCtxt);
-		DRV_RemoveAllDMMResElements(pCtxt);
-		DRV_ProcUpdatestate(pCtxt, PROC_RES_FREED);
-	}
+	dsp_status status = DSP_SOK;
+	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	drv_remove_all_strm_res_elements(ctxt);
+	drv_remove_all_node_res_elements(ctxt);
+	drv_remove_all_dmm_res_elements(ctxt);
+	ctxt->res_state = PROC_RES_FREED;
 	return status;
 }
-#endif
 
 /* Bridge driver initialization and de-initialization functions */
 module_init(bridge_init);
 module_exit(bridge_exit);
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/drv_interface.h kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/drv_interface.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/drv_interface.h	2011-10-11 13:51:01.294958226 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/rmgr/drv_interface.h	2011-10-23 08:22:37.652582000 +0100
@@ -14,18 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== drv_interface.h ========
- *
- *! Revision History
- *! ================
- *! 24-Mar-2003 vp  Added hooks for Power Management Test
- *! 18-Feb-2003 vp  Code review updates
- *! 18-Oct-2002 sb  Created initial version
-
- */
-
 #ifndef	_DRV_INTERFACE_H_
 #define _DRV_INTERFACE_H_
 
@@ -34,7 +22,6 @@
 static void __exit bridge_exit(void);	/* Opposite of initialize */
 static int bridge_open(struct inode *, struct file *);	/* Open */
 static int bridge_release(struct inode *, struct file *);	/* Release */
-static long bridge_ioctl(struct file *, unsigned int,
-			unsigned long);
+static long bridge_ioctl(struct file *, unsigned int, unsigned long);
 static int bridge_mmap(struct file *filp, struct vm_area_struct *vma);
-#endif				/* ifndef _DRV_INTERFACE_H_ */
+#endif /* ifndef _DRV_INTERFACE_H_ */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/dspdrv.c kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/dspdrv.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/dspdrv.c	2011-10-11 13:51:01.294958226 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/rmgr/dspdrv.c	2011-10-23 08:22:37.652582000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Interface to allocate and free bridge resources.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,83 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dspdrv.c ========
- *  Description:
- *      Interface to allocate and free bridge resources.
- *
- *! Revision History
- *! ================
- *! 12-Apr-2004 hp: Compile IVA only for 24xx.
- *! 09-Feb-2004 vp: Updated to support IVA.
- *! 10-Feb-2003 vp: Code review updates.
- *! 18-oct-2002 vp: Ported to the Linux platform.
- *! 03-Mar-2002 rr: DSP_Deinit bug fixed (gets the Mgrhandle from registry
- *!		            before calling MGR_Destroy.
- *! 11-Jul-2001 jeh Moved MGR_Create() from DSP_Init() to DEV_StartDevice().
- *! 02-Apr-2001 rr: WCD_InitComplete2 return value is not checked thus
- *!                 sllowing the class driver to load irrespective of
- *!                 the image load.
- *! 30-Oct-2000 kc: Made changes w.r.t. usage of REG_SetValue.
- *! 05-Oct-2000 rr: WCD_InitComplete2 return value checked for RM.
- *!                 Failure in WCD_InitComplete2 will cause the
- *!                 DSP_Init to fail.
- *! 12-Aug-2000 kc: Changed REG_EnumValue to REG_EnumKey.
- *! 07-Aug-2000 rr: MGR_Create does the job of loading the DCD Dll.
- *! 26-Jul-2000 rr: Driver Object holds the DevNodeStrings for each
- *!                 DevObjects. Static variables removed. Returns
- *!                 the Driver Object in DSP_Init.
- *! 17-Jul-2000 rr: Driver Object is created in DSP_Init and that holds
- *!                 the list of Device objects.
- *! 07-Jul-2000 rr: RM implementaion started.
- *! 24-May-2000 ag: Cleaned up debug msgs.
- *! 02-May-2000 rr: DSP_Open returns GetCallerProcess as dwOpenContext.
- *! 03-Feb-2000 rr: GT Changes.
- *! 28-Jan-2000 rr: Code Cleaned up.Type void changed to void.
- *!                 DSP_Deinit checks return values.dwCode in
- *!                 DSP_IO_CONTROL is decoded(not hard coded)
- *! 27-Jan-2000 rr: REG_EnumValue Used .EnumerateKey fxn removed.
- *! 13-Jan-2000 rr: CFG_GetPrivateDword renamed to CFG_GetDevObject.
- *! 29-Dec-1999 rr: Code Cleaned up
- *! 09-Dec-1999 rr: EnumerateKey changed for retail build.
- *! 06-Dec-1999 rr: ArrayofInstalledNode, index and  ArrayofInstalledDev
- *!                 is Global.DevObject stores this pointer as hDevNode.
- *! 02-Dec-1999 rr: DBG_SetGT and RetailMSG conditionally included.
- *!                 Comments changed.Deinit handled.Code cleaned up.
- *!                 DSP_IOControl, Close, Deinit returns bool values.
- *!                 Calls WCD_InitComplete2 for Board AutoStart.
- *! 29-Nov-1999 rr: DSP_IOControl returns the result through pBufOut.
- *!                 Global Arrays keeps track of installed devices.
- *! 19-Nov-1999 rr: DSP_Init handles multiple drivers.
- *! 12-Nov-1999 rr: GetDriverKey and EnumerateKey functions added.
- *!                 for multiple mini driver support.PCCARD flag
- *!                 checking to include PCMCIA related stuff.
- *! 25-Oct-1999 rr: GT_Init is called within the Process Attach.
- *!                 return value initalized to S_OK upfront in the
- *!                 Process Attach.
- *! 15-Oct-1999 rr: DSP_DeInit handles the return values
- *! 05-Oct-1999 rr: All the PCMCIA related functions are now in PCCARD.c
- *!                 DRV_Request Resources is used instead of the
- *!                 RegisterMiniDriver as it sounds close to what we are doing.
- *! 24-Sep-1999 rr: DRV_RegisterMiniDriver is being called from here. Only
- *!                 neccessaryPCMCIA fxns are here. Soon they will move out
- *!                  either to a seperate file for bus specific inits.
- *! 10-Sep-1999 rr: GT Enabled. Considerably changed the  driver structure as
- *!                 - This is the Class driver. After successfully initialized
- *!                   the Class driver will attempt to load the Mini driver.
- *!                 - Need to seperate the PCMCIA stuff based on bus type.
- *!                 - Changed the name of the file to wcdce.c
- *!                 - Made the Media Handle as Global again
- *!
- *! 19-Aug-1999 rr: Removed the Global hbhMediaHandle. Included the MemTest.
- *!                 Modified the DSP_Init, now three windows are opened.
- *!                 Split the driver into PDD so that hardware dependent
- *!                 functions will reside in PDD.
- *! 16-Jul-1999 ag  Adapted from rkw's CAC Bullet card driver.
- *!
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -101,11 +26,9 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/cfg.h>
-#include <dspbridge/csl.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/reg.h>
 
@@ -117,134 +40,106 @@
 /*  ----------------------------------- Resource Manager */
 #include <dspbridge/mgr.h>
 
-/*  ----------------------------------- Others */
-#include <dspbridge/dbreg.h>
-
 /*  ----------------------------------- This */
 #include <dspbridge/dspdrv.h>
 
-/*  ----------------------------------- Globals */
-struct GT_Mask curTrace;
-
 /*
- *  ======== DSP_Init ========
+ *  ======== dsp_init ========
  *  	Allocates bridge resources. Loads a base image onto DSP, if specified.
  */
-u32 DSP_Init(OUT u32 *initStatus)
+u32 dsp_init(OUT u32 *init_status)
 {
-	char devNode[MAXREGPATHLENGTH] = "TIOMAP1510";
-	DSP_STATUS status = DSP_EFAIL;
-	struct DRV_OBJECT *drvObject = NULL;
-	u32 index = 0;
-	u32 deviceNode;
-	u32 deviceNodeString;
-
-	GT_create(&curTrace, "DD");
+	char dev_node[MAXREGPATHLENGTH] = "TIOMAP1510";
+	dsp_status status = DSP_EFAIL;
+	struct drv_object *drv_obj = NULL;
+	u32 device_node;
+	u32 device_node_string;
 
-	GT_0trace(curTrace, GT_ENTER, "Entering DSP_Init \r\n");
-
-	if (DSP_FAILED(WCD_Init())) {
-		GT_0trace(curTrace, GT_7CLASS, "DSP_Init Failed \n");
+	if (!wcd_init())
 		goto func_cont;
-	}			/* End WCD_Exit */
-	if (DSP_FAILED(DRV_Create(&drvObject))) {
-		GT_0trace(curTrace, GT_7CLASS, "DSP_Init:DRV_Create Failed \n");
-		WCD_Exit();
+
+	status = drv_create(&drv_obj);
+	if (DSP_FAILED(status)) {
+		wcd_exit();
 		goto func_cont;
-	}		/* End DRV_Create */
-	GT_0trace(curTrace, GT_5CLASS, "DSP_Init:DRV Created \r\n");
+	}
 
+	/* End drv_create */
 	/* Request Resources */
-	if (DSP_SUCCEEDED(DRV_RequestResources((u32)&devNode,
-	   &deviceNodeString))) {
+	status = drv_request_resources((u32) &dev_node, &device_node_string);
+	if (DSP_SUCCEEDED(status)) {
 		/* Attempt to Start the Device */
-		if (DSP_SUCCEEDED(DEV_StartDevice(
-		   (struct CFG_DEVNODE *)deviceNodeString))) {
-			/* Retreive the DevObject from the Registry */
-			GT_2trace(curTrace, GT_1CLASS,
-				 "DSP_Init Succeeded for Device1:"
-				 "%d: value: %x\n", index, deviceNodeString);
-			status = DSP_SOK;
-		} else {
-			GT_0trace(curTrace, GT_7CLASS,
-				 "DSP_Init:DEV_StartDevice Failed\n");
-			(void)DRV_ReleaseResources
-				((u32) deviceNodeString, drvObject);
-			status = DSP_EFAIL;
-		}
+		status = dev_start_device((struct cfg_devnode *)
+					  device_node_string);
+		if (DSP_FAILED(status))
+			(void)drv_release_resources
+			    ((u32) device_node_string, drv_obj);
 	} else {
-		GT_0trace(curTrace, GT_7CLASS,
-			 "DSP_Init:DRV_RequestResources Failed \r\n");
+		dev_dbg(bridge, "%s: drv_request_resources Failed\n", __func__);
 		status = DSP_EFAIL;
-	}	/* DRV_RequestResources */
-	index++;
+	}
 
 	/* Unwind whatever was loaded */
 	if (DSP_FAILED(status)) {
-		/* irrespective of the status of DEV_RemoveDevice we conitinue
+		/* irrespective of the status of dev_remove_device we conitinue
 		 * unloading. Get the Driver Object iterate through and remove.
 		 * Reset the status to E_FAIL to avoid going through
-		 * WCD_InitComplete2. */
-		status = DSP_EFAIL;
-		for (deviceNode = DRV_GetFirstDevExtension(); deviceNode != 0;
-		    deviceNode = DRV_GetNextDevExtension(deviceNode)) {
-			(void)DEV_RemoveDevice
-				((struct CFG_DEVNODE *)deviceNode);
-			(void)DRV_ReleaseResources((u32)deviceNode,
-				drvObject);
+		 * wcd_init_complete2. */
+		for (device_node = drv_get_first_dev_extension();
+		     device_node != 0;
+		     device_node = drv_get_next_dev_extension(device_node)) {
+			(void)dev_remove_device((struct cfg_devnode *)
+						device_node);
+			(void)drv_release_resources((u32) device_node, drv_obj);
 		}
 		/* Remove the Driver Object */
-		(void)DRV_Destroy(drvObject);
-		drvObject = NULL;
-		WCD_Exit();
-		GT_0trace(curTrace, GT_7CLASS,
-			 "DSP_Init:Logical device Failed to Load\n");
-	}	/* Unwinding the loaded drivers */
+		(void)drv_destroy(drv_obj);
+		drv_obj = NULL;
+		wcd_exit();
+		dev_dbg(bridge, "%s: Logical device failed init\n", __func__);
+	}			/* Unwinding the loaded drivers */
 func_cont:
 	/* Attempt to Start the Board */
 	if (DSP_SUCCEEDED(status)) {
 		/* BRD_AutoStart could fail if the dsp execuetable is not the
 		 * correct one. We should not propagate that error
 		 * into the device loader. */
-		(void)WCD_InitComplete2();
-		GT_0trace(curTrace, GT_1CLASS, "DSP_Init Succeeded\n");
+		(void)wcd_init_complete2();
 	} else {
-		GT_0trace(curTrace, GT_7CLASS, "DSP_Init Failed\n");
-	}			/* End WCD_InitComplete2 */
-	DBC_Ensure((DSP_SUCCEEDED(status) && drvObject != NULL) ||
-		  (DSP_FAILED(status) && drvObject == NULL));
-	*initStatus = status;
+		dev_dbg(bridge, "%s: Failed\n", __func__);
+	}			/* End wcd_init_complete2 */
+	DBC_ENSURE((DSP_SUCCEEDED(status) && drv_obj != NULL) ||
+		   (DSP_FAILED(status) && drv_obj == NULL));
+	*init_status = status;
 	/* Return the Driver Object */
-	return (u32)drvObject;
+	return (u32) drv_obj;
 }
 
 /*
- *  ======== DSP_Deinit ========
+ *  ======== dsp_deinit ========
  *  	Frees the resources allocated for bridge.
  */
-bool DSP_Deinit(u32 deviceContext)
+bool dsp_deinit(u32 deviceContext)
 {
-	bool retVal = true;
-	u32 deviceNode;
-	struct MGR_OBJECT *mgrObject = NULL;
-
-	GT_0trace(curTrace, GT_ENTER, "Entering DSP_Deinit \r\n");
+	bool ret = true;
+	u32 device_node;
+	struct mgr_object *mgr_obj = NULL;
 
-	while ((deviceNode = DRV_GetFirstDevExtension()) != 0) {
-		(void)DEV_RemoveDevice((struct CFG_DEVNODE *)deviceNode);
+	while ((device_node = drv_get_first_dev_extension()) != 0) {
+		(void)dev_remove_device((struct cfg_devnode *)device_node);
 
-		(void)DRV_ReleaseResources((u32)deviceNode,
-			 (struct DRV_OBJECT *)deviceContext);
+		(void)drv_release_resources((u32) device_node,
+					    (struct drv_object *)deviceContext);
 	}
 
-	(void) DRV_Destroy((struct DRV_OBJECT *) deviceContext);
+	(void)drv_destroy((struct drv_object *)deviceContext);
 
 	/* Get the Manager Object from Registry
 	 * MGR Destroy will unload the DCD dll */
-	if (DSP_SUCCEEDED(CFG_GetObject((u32 *)&mgrObject, REG_MGR_OBJECT)))
-		(void)MGR_Destroy(mgrObject);
+	if (DSP_SUCCEEDED(cfg_get_object((u32 *) &mgr_obj, REG_MGR_OBJECT)))
+		(void)mgr_destroy(mgr_obj);
 
-	WCD_Exit();
+	wcd_exit();
 
-	return retVal;
+	return ret;
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/mgr.c kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/mgr.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/mgr.c	2011-10-11 13:51:01.294958226 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/rmgr/mgr.c	2011-10-23 08:22:37.652582000 +0100
@@ -3,6 +3,10 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implementation of Manager interface to the device object at the
+ * driver level. This queries the NDB data base and retrieves the
+ * data about Node and Processor.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,32 +18,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== mgr.c ========
- *  Description:
- *      Implementation of Manager interface to the device object at the
- *      driver level. This queries the NDB data base and retrieves the
- *      data about Node and Processor.
- *
- *
- *! Revision History:
- *! ================
- *! 12-Feb-2003 vp: Code review updates.
- *! 18-Oct-2002 vp: Ported to Linux platform
- *! 01-Aug-2001 ag: Added extended info for DSP-MMU setup support.
- *! 13-Feb-2001 kc: DSP/BIOS Bridge name updates.
- *! 22-Nov-2000 kc: Added MGR_GetPerfData.
- *! 03-Nov-2000 rr: Updated after code review.
- *! 25-Sep-2000 rr: Updated to Version 0.9
- *! 10-Aug-2000 rr: dwSignature is not specifically inserted in MGR Obj
- *!                 as it is taken care by MEM_AllocObject. stdwin.h added
- *!                 for retail build to succeed.
- *! 07-Aug-2000 rr: MGR_Create does the job of Loading DCD Dll.
- *! 26-Jul-2000 rr: MGR_Destroy releases the hNDBDll.
- *! 20-Jun-2000 rr: Created.
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
@@ -47,7 +25,6 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/cfg.h>
@@ -56,7 +33,6 @@
 
 /*  ----------------------------------- Others */
 #include <dspbridge/dbdcd.h>
-#include <dspbridge/dbreg.h>
 #include <dspbridge/drv.h>
 #include <dspbridge/dev.h>
 
@@ -67,245 +43,189 @@
 #define ZLDLLNAME               ""
 #define SIGNATURE               0x5f52474d	/* "MGR_" (in reverse) */
 
-struct MGR_OBJECT {
-	u32 dwSignature;
-	struct DCD_MANAGER *hDcdMgr;	/* Proc/Node data manager */
+struct mgr_object {
+	u32 dw_signature;
+	struct dcd_manager *hdcd_mgr;	/* Proc/Node data manager */
 };
 
 /*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask MGR_DebugMask = { NULL, NULL };
-#endif
-
-static u32 cRefs;
+static u32 refs;
 
 /*
- *  ========= MGR_Create =========
+ *  ========= mgr_create =========
  *  Purpose:
  *      MGR Object gets created only once during driver Loading.
  */
-DSP_STATUS MGR_Create(OUT struct MGR_OBJECT **phMgrObject,
-		     struct CFG_DEVNODE *hDevNode)
+dsp_status mgr_create(OUT struct mgr_object **phMgrObject,
+		      struct cfg_devnode *dev_node_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct MGR_OBJECT *pMgrObject = NULL;
+	dsp_status status = DSP_SOK;
+	struct mgr_object *pmgr_obj = NULL;
+
+	DBC_REQUIRE(phMgrObject != NULL);
+	DBC_REQUIRE(refs > 0);
 
-	DBC_Require(phMgrObject != NULL);
-	DBC_Require(cRefs > 0);
-	GT_1trace(MGR_DebugMask, GT_ENTER,
-		 "Entering MGR_Create phMgrObject 0x%x\n ",
-		 phMgrObject);
-	MEM_AllocObject(pMgrObject, struct MGR_OBJECT, SIGNATURE);
-	if (pMgrObject) {
-		if (DSP_SUCCEEDED(DCD_CreateManager(ZLDLLNAME,
-		   &pMgrObject->hDcdMgr))) {
+	MEM_ALLOC_OBJECT(pmgr_obj, struct mgr_object, SIGNATURE);
+	if (pmgr_obj) {
+		status = dcd_create_manager(ZLDLLNAME, &pmgr_obj->hdcd_mgr);
+		if (DSP_SUCCEEDED(status)) {
 			/* If succeeded store the handle in the MGR Object */
-			if (DSP_SUCCEEDED(CFG_SetObject((u32)pMgrObject,
-			   REG_MGR_OBJECT))) {
-				*phMgrObject = pMgrObject;
-				GT_0trace(MGR_DebugMask, GT_1CLASS,
-					 "MGR_Create:MGR Created\r\n");
+			status = cfg_set_object((u32) pmgr_obj, REG_MGR_OBJECT);
+			if (DSP_SUCCEEDED(status)) {
+				*phMgrObject = pmgr_obj;
 			} else {
-				status = DSP_EFAIL;
-				GT_0trace(MGR_DebugMask, GT_7CLASS,
-					 "MGR_Create:CFG_SetObject "
-					 "Failed\r\n");
-				DCD_DestroyManager(pMgrObject->hDcdMgr);
-				MEM_FreeObject(pMgrObject);
+				dcd_destroy_manager(pmgr_obj->hdcd_mgr);
+				MEM_FREE_OBJECT(pmgr_obj);
 			}
 		} else {
 			/* failed to Create DCD Manager */
-			status = DSP_EFAIL;
-			GT_0trace(MGR_DebugMask, GT_7CLASS,
-				 "MGR_Create:DCD_ManagerCreate Failed\r\n");
-			MEM_FreeObject(pMgrObject);
+			MEM_FREE_OBJECT(pmgr_obj);
 		}
 	} else {
 		status = DSP_EMEMORY;
-		GT_0trace(MGR_DebugMask, GT_7CLASS,
-			 "MGR_Create DSP_FAILED to allocate memory \n");
 	}
-	GT_2trace(MGR_DebugMask, GT_ENTER,
-		 "Exiting MGR_Create: phMgrObject: 0x%x\t"
-		 "status: 0x%x\n", phMgrObject, status);
-	DBC_Ensure(DSP_FAILED(status) ||
-		  MEM_IsValidHandle(pMgrObject, SIGNATURE));
+
+	DBC_ENSURE(DSP_FAILED(status) ||
+		   MEM_IS_VALID_HANDLE(pmgr_obj, SIGNATURE));
 	return status;
 }
 
 /*
- *  ========= MGR_Destroy =========
+ *  ========= mgr_destroy =========
  *     This function is invoked during bridge driver unloading.Frees MGR object.
  */
-DSP_STATUS MGR_Destroy(struct MGR_OBJECT *hMgrObject)
+dsp_status mgr_destroy(struct mgr_object *hmgr_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct MGR_OBJECT *pMgrObject = (struct MGR_OBJECT *)hMgrObject;
+	dsp_status status = DSP_SOK;
+	struct mgr_object *pmgr_obj = (struct mgr_object *)hmgr_obj;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hMgrObject, SIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hmgr_obj, SIGNATURE));
 
-	GT_1trace(MGR_DebugMask, GT_ENTER,
-		 "Entering MGR_Destroy hMgrObject 0x%x\n", hMgrObject);
 	/* Free resources */
-	if (hMgrObject->hDcdMgr)
-		DCD_DestroyManager(hMgrObject->hDcdMgr);
+	if (hmgr_obj->hdcd_mgr)
+		dcd_destroy_manager(hmgr_obj->hdcd_mgr);
 
-	MEM_FreeObject(pMgrObject);
+	MEM_FREE_OBJECT(pmgr_obj);
 	/* Update the Registry with NULL for MGR Object */
-	(void)CFG_SetObject(0, REG_MGR_OBJECT);
-
-	GT_2trace(MGR_DebugMask, GT_ENTER,
-		 "Exiting MGR_Destroy: hMgrObject: 0x%x\t"
-		 "status: 0x%x\n", hMgrObject, status);
+	(void)cfg_set_object(0, REG_MGR_OBJECT);
 
-	DBC_Ensure(DSP_FAILED(status) ||
-		 !MEM_IsValidHandle(hMgrObject, SIGNATURE));
+	DBC_ENSURE(DSP_FAILED(status) ||
+		   !MEM_IS_VALID_HANDLE(hmgr_obj, SIGNATURE));
 
 	return status;
 }
 
 /*
- *  ======== MGR_EnumNodeInfo ========
+ *  ======== mgr_enum_node_info ========
  *      Enumerate and get configuration information about nodes configured
  *      in the node database.
  */
-DSP_STATUS MGR_EnumNodeInfo(u32 uNode, OUT struct DSP_NDBPROPS *pNDBProps,
-			   u32 uNDBPropsSize, OUT u32 *puNumNodes)
+dsp_status mgr_enum_node_info(u32 node_id, OUT struct dsp_ndbprops *pndb_props,
+			      u32 undb_props_size, OUT u32 *pu_num_nodes)
 {
-	DSP_STATUS status = DSP_SOK;
-	DSP_STATUS status1 = DSP_SOK;
-	struct DSP_UUID Uuid, uTempUuid;
-	u32 uTempIndex = 0;
-	u32 uNodeIndex = 0;
-	struct DCD_GENERICOBJ GenObj;
-	struct MGR_OBJECT *pMgrObject = NULL;
-
-	DBC_Require(pNDBProps != NULL);
-	DBC_Require(puNumNodes != NULL);
-	DBC_Require(uNDBPropsSize >= sizeof(struct DSP_NDBPROPS));
-	DBC_Require(cRefs > 0);
-
-	GT_4trace(MGR_DebugMask, GT_ENTER, "Entered Manager_EnumNodeInfo, "
-		 "args:\n\t uNode: 0x%x\n\tpNDBProps:  0x%x\n\tuNDBPropsSize:"
-		 "0x%x\tpuNumNodes: 0x%x\n", uNode, pNDBProps,
-		 uNDBPropsSize, puNumNodes);
-	*puNumNodes = 0;
+	dsp_status status = DSP_SOK;
+	struct dsp_uuid node_uuid, temp_uuid;
+	u32 temp_index = 0;
+	u32 node_index = 0;
+	struct dcd_genericobj gen_obj;
+	struct mgr_object *pmgr_obj = NULL;
+
+	DBC_REQUIRE(pndb_props != NULL);
+	DBC_REQUIRE(pu_num_nodes != NULL);
+	DBC_REQUIRE(undb_props_size >= sizeof(struct dsp_ndbprops));
+	DBC_REQUIRE(refs > 0);
+
+	*pu_num_nodes = 0;
 	/* Get The Manager Object from the Registry */
-	if (DSP_FAILED(CFG_GetObject((u32 *)&pMgrObject,
-	   REG_MGR_OBJECT))) {
-		GT_0trace(MGR_DebugMask, GT_7CLASS,
-			 "Manager_EnumNodeInfo:Failed To Get"
-			 " MGR Object from Registry\r\n");
+	status = cfg_get_object((u32 *) &pmgr_obj, REG_MGR_OBJECT);
+	if (DSP_FAILED(status))
 		goto func_cont;
-	}
-	DBC_Assert(MEM_IsValidHandle(pMgrObject, SIGNATURE));
+
+	DBC_ASSERT(MEM_IS_VALID_HANDLE(pmgr_obj, SIGNATURE));
 	/* Forever loop till we hit failed or no more items in the
 	 * Enumeration. We will exit the loop other than DSP_SOK; */
 	while (status == DSP_SOK) {
-		status = DCD_EnumerateObject(uTempIndex++, DSP_DCDNODETYPE,
-					    &uTempUuid);
+		status = dcd_enumerate_object(temp_index++, DSP_DCDNODETYPE,
+					      &temp_uuid);
 		if (status == DSP_SOK) {
-			uNodeIndex++;
-			if (uNode == (uNodeIndex - 1))
-				Uuid = uTempUuid;
+			node_index++;
+			if (node_id == (node_index - 1))
+				node_uuid = temp_uuid;
 
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
-		if (uNode > (uNodeIndex - 1)) {
+		if (node_id > (node_index - 1)) {
 			status = DSP_EINVALIDARG;
-			GT_0trace(MGR_DebugMask, GT_7CLASS,
-				 "Manager_EnumNodeInfo: uNode"
-				 " is Invalid \r\n");
 		} else {
-			status1 = DCD_GetObjectDef(pMgrObject->hDcdMgr,
-						(struct DSP_UUID *)&Uuid,
-						DSP_DCDNODETYPE, &GenObj);
-			if (DSP_SUCCEEDED(status1)) {
+			status = dcd_get_object_def(pmgr_obj->hdcd_mgr,
+						    (struct dsp_uuid *)
+						    &node_uuid, DSP_DCDNODETYPE,
+						    &gen_obj);
+			if (DSP_SUCCEEDED(status)) {
 				/* Get the Obj def */
-				*pNDBProps = GenObj.objData.nodeObj.ndbProps;
-				*puNumNodes = uNodeIndex;
-				status = DSP_SOK;
-			} else {
-				GT_0trace(MGR_DebugMask, GT_7CLASS,
-					 "Manager_EnumNodeInfo: "
-					 "Failed to Get Node Info \r\n");
-				status = DSP_EFAIL;
+				*pndb_props =
+				    gen_obj.obj_data.node_obj.ndb_props;
+				*pu_num_nodes = node_index;
 			}
 		}
-	} else {
-		/* This could be changed during enum, EFAIL ... */
-		GT_0trace(MGR_DebugMask, GT_7CLASS, "Manager_EnumNodeInfo: "
-			 "Enumeration failure\r\n");
-		status = DSP_EFAIL;
 	}
+
 func_cont:
-	GT_4trace(MGR_DebugMask, GT_ENTER,
-		 "Exiting Manager_EnumNodeInfo, args:\n\t"
-		 "uNode: 0x%x\n\tpNDBProps:  0x%x\n\tuNDBPropsSize:"
-		 " 0x%x\tuNumNodes: 0x%x\n", uNode, pNDBProps,
-		uNDBPropsSize, *puNumNodes);
-	DBC_Ensure((DSP_SUCCEEDED(status) && *puNumNodes > 0) ||
-		  (DSP_FAILED(status) && *puNumNodes == 0));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && *pu_num_nodes > 0) ||
+		   (DSP_FAILED(status) && *pu_num_nodes == 0));
 
 	return status;
 }
 
 /*
- *  ======== MGR_EnumProcessorInfo ========
+ *  ======== mgr_enum_processor_info ========
  *      Enumerate and get configuration information about available
  *      DSP processors.
  */
-DSP_STATUS MGR_EnumProcessorInfo(u32 uProcessor,
-				OUT struct DSP_PROCESSORINFO *pProcessorInfo,
-				u32 uProcessorInfoSize, OUT u32 *puNumProcs)
+dsp_status mgr_enum_processor_info(u32 processor_id,
+				   OUT struct dsp_processorinfo *
+				   processor_info, u32 processor_info_size,
+				   OUT u32 *pu_num_procs)
 {
-	DSP_STATUS status = DSP_SOK;
-	DSP_STATUS status1 = DSP_SOK;
-	DSP_STATUS status2 = DSP_SOK;
-	struct DSP_UUID uTempUuid;
-	u32 uTempIndex = 0;
-	u32 uProcIndex = 0;
-	struct DCD_GENERICOBJ GenObj;
-	struct MGR_OBJECT *pMgrObject = NULL;
-	struct MGR_PROCESSOREXTINFO *pExtInfo;
-	struct DEV_OBJECT *hDevObject;
-	struct DRV_OBJECT *hDrvObject;
-	s32 devType;
-	struct CFG_DEVNODE *devNode;
-	struct CFG_DSPRES chipResources;
-	bool procDetect = false;
-
-	DBC_Require(pProcessorInfo != NULL);
-	DBC_Require(puNumProcs != NULL);
-	DBC_Require(uProcessorInfoSize >= sizeof(struct DSP_PROCESSORINFO));
-	DBC_Require(cRefs > 0);
-
-	GT_4trace(MGR_DebugMask, GT_ENTER,
-		 "Entered Manager_EnumProcessorInfo, "
-		 "args:\n\tuProcessor:  0x%x\n\tpProcessorInfo: 0x%x\n\t"
-		 "uProcessorInfoSize: 0x%x\tpuNumProcs: 0x%x\n", uProcessor,
-		 pProcessorInfo, uProcessorInfoSize, puNumProcs);
-	*puNumProcs = 0;
-	status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
+	dsp_status status = DSP_SOK;
+	dsp_status status1 = DSP_SOK;
+	dsp_status status2 = DSP_SOK;
+	struct dsp_uuid temp_uuid;
+	u32 temp_index = 0;
+	u32 proc_index = 0;
+	struct dcd_genericobj gen_obj;
+	struct mgr_object *pmgr_obj = NULL;
+	struct mgr_processorextinfo *ext_info;
+	struct dev_object *hdev_obj;
+	struct drv_object *hdrv_obj;
+	s32 dev_type;
+	struct cfg_devnode *dev_node;
+	struct cfg_dspres chip_resources;
+	bool proc_detect = false;
+
+	DBC_REQUIRE(processor_info != NULL);
+	DBC_REQUIRE(pu_num_procs != NULL);
+	DBC_REQUIRE(processor_info_size >= sizeof(struct dsp_processorinfo));
+	DBC_REQUIRE(refs > 0);
+
+	*pu_num_procs = 0;
+	status = cfg_get_object((u32 *) &hdrv_obj, REG_DRV_OBJECT);
 	if (DSP_SUCCEEDED(status)) {
-		status = DRV_GetDevObject(uProcessor, hDrvObject, &hDevObject);
+		status = drv_get_dev_object(processor_id, hdrv_obj, &hdev_obj);
 		if (DSP_SUCCEEDED(status)) {
-			status = DEV_GetDevType(hDevObject, (u32 *) &devType);
-			status = DEV_GetDevNode(hDevObject, &devNode);
-			if (devType == DSP_UNIT) {
-				status = CFG_GetDSPResources(devNode,
-							 &chipResources);
-			} else {
+			status = dev_get_dev_type(hdev_obj, (u32 *) &dev_type);
+			status = dev_get_dev_node(hdev_obj, &dev_node);
+			if (dev_type == DSP_UNIT)
+				status = cfg_get_dsp_resources(dev_node,
+							       &chip_resources);
+			else
 				status = DSP_EFAIL;
-				GT_1trace(MGR_DebugMask, GT_7CLASS,
-					 "Unsupported dev type gotten"
-					 "from device object %d\n", devType);
-			}
+
 			if (DSP_SUCCEEDED(status)) {
-				pProcessorInfo->uProcessorType =
-						chipResources.uChipType;
+				processor_info->processor_type =
+				    chip_resources.chip_type;
 			}
 		}
 	}
@@ -313,179 +233,157 @@
 		goto func_end;
 
 	/* Get The Manager Object from the Registry */
-	if (DSP_FAILED(CFG_GetObject((u32 *)&pMgrObject,
-	   REG_MGR_OBJECT))) {
-		GT_0trace(MGR_DebugMask, GT_7CLASS,
-			 "Manager_EnumProcessorInfo: "
-			 "Failed To Get MGR Object from Registry\r\n");
+	if (DSP_FAILED(cfg_get_object((u32 *) &pmgr_obj, REG_MGR_OBJECT))) {
+		dev_dbg(bridge, "%s: Failed to get MGR Object\n", __func__);
 		goto func_end;
 	}
-	DBC_Assert(MEM_IsValidHandle(pMgrObject, SIGNATURE));
+	DBC_ASSERT(MEM_IS_VALID_HANDLE(pmgr_obj, SIGNATURE));
 	/* Forever loop till we hit no more items in the
 	 * Enumeration. We will exit the loop other than DSP_SOK; */
 	while (status1 == DSP_SOK) {
-		status1 = DCD_EnumerateObject(uTempIndex++,
-					     DSP_DCDPROCESSORTYPE,
-					     &uTempUuid);
+		status1 = dcd_enumerate_object(temp_index++,
+					       DSP_DCDPROCESSORTYPE,
+					       &temp_uuid);
 		if (status1 != DSP_SOK)
 			break;
 
-		uProcIndex++;
+		proc_index++;
 		/* Get the Object properties to find the Device/Processor
 		 * Type */
-		if (procDetect != false)
+		if (proc_detect != false)
 			continue;
 
-		status2 = DCD_GetObjectDef(pMgrObject->hDcdMgr,
-					(struct DSP_UUID *)&uTempUuid,
-					DSP_DCDPROCESSORTYPE,
-					&GenObj);
+		status2 = dcd_get_object_def(pmgr_obj->hdcd_mgr,
+					     (struct dsp_uuid *)&temp_uuid,
+					     DSP_DCDPROCESSORTYPE, &gen_obj);
 		if (DSP_SUCCEEDED(status2)) {
 			/* Get the Obj def */
-			if (uProcessorInfoSize <
-					sizeof(struct MGR_PROCESSOREXTINFO)) {
-				*pProcessorInfo = GenObj.objData.procObj;
+			if (processor_info_size <
+			    sizeof(struct mgr_processorextinfo)) {
+				*processor_info = gen_obj.obj_data.proc_info;
 			} else {
 				/* extended info */
-				pExtInfo = (struct MGR_PROCESSOREXTINFO *)
-						pProcessorInfo;
-				*pExtInfo = GenObj.objData.extProcObj;
+				ext_info = (struct mgr_processorextinfo *)
+				    processor_info;
+				*ext_info = gen_obj.obj_data.ext_proc_obj;
 			}
-			GT_1trace(MGR_DebugMask, GT_7CLASS,
-				 "Manager_EnumProcessorInfo: Got"
-				 " Proctype  from DCD %x \r\n",
-				 pProcessorInfo->uProcessorType);
+			dev_dbg(bridge, "%s: Got proctype  from DCD %x\n",
+				__func__, processor_info->processor_type);
 			/* See if we got the needed processor */
-			if (devType == DSP_UNIT) {
-				if (pProcessorInfo->uProcessorType ==
-				   DSPPROCTYPE_C64)
-					procDetect = true;
-			} else if (devType == IVA_UNIT) {
-				if (pProcessorInfo->uProcessorType ==
-				   IVAPROCTYPE_ARM7)
-					procDetect = true;
+			if (dev_type == DSP_UNIT) {
+				if (processor_info->processor_type ==
+				    DSPPROCTYPE_C64)
+					proc_detect = true;
+			} else if (dev_type == IVA_UNIT) {
+				if (processor_info->processor_type ==
+				    IVAPROCTYPE_ARM7)
+					proc_detect = true;
 			}
 			/* User applciatiuons aonly check for chip type, so
 			 * this clumsy overwrite */
-			pProcessorInfo->uProcessorType =
-					 chipResources.uChipType;
+			processor_info->processor_type =
+			    chip_resources.chip_type;
 		} else {
-			GT_1trace(MGR_DebugMask, GT_7CLASS,
-				 "Manager_EnumProcessorInfo: "
-				 "Failed to Get DCD Processor Info %x \r\n",
-				 status2);
+			dev_dbg(bridge, "%s: Failed to get DCD processor info "
+				"%x\n", __func__, status2);
 			status = DSP_EFAIL;
 		}
 	}
-	*puNumProcs = uProcIndex;
-	if (procDetect == false) {
-		GT_0trace(MGR_DebugMask, GT_7CLASS,
-			 "Manager_EnumProcessorInfo: Failed"
-			 " to get Proc info from DCD , so use CFG registry\n");
-		pProcessorInfo->uProcessorType = chipResources.uChipType;
+	*pu_num_procs = proc_index;
+	if (proc_detect == false) {
+		dev_dbg(bridge, "%s: Failed to get proc info from DCD, so use "
+			"CFG registry\n", __func__);
+		processor_info->processor_type = chip_resources.chip_type;
 	}
 func_end:
 	return status;
 }
 
 /*
- *  ======== MGR_Exit ========
+ *  ======== mgr_exit ========
  *      Decrement reference count, and free resources when reference count is
  *      0.
  */
-void MGR_Exit(void)
+void mgr_exit(void)
 {
-	DBC_Require(cRefs > 0);
-	cRefs--;
-	if (cRefs == 0)
-		DCD_Exit();
-
-	GT_1trace(MGR_DebugMask, GT_5CLASS,
-		 "Entered MGR_Exit, ref count: 0x%x\n", cRefs);
-	DBC_Ensure(cRefs >= 0);
+	DBC_REQUIRE(refs > 0);
+	refs--;
+	if (refs == 0)
+		dcd_exit();
+
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== MGR_GetDCDHandle ========
+ *  ======== mgr_get_dcd_handle ========
  *      Retrieves the MGR handle. Accessor Function.
  */
-DSP_STATUS MGR_GetDCDHandle(struct MGR_OBJECT *hMGRHandle,
-			   OUT u32 *phDCDHandle)
+dsp_status mgr_get_dcd_handle(struct mgr_object *hMGRHandle,
+			      OUT u32 *phDCDHandle)
 {
-	DSP_STATUS status = DSP_EFAIL;
-	struct MGR_OBJECT *pMgrObject = (struct MGR_OBJECT *)hMGRHandle;
+	dsp_status status = DSP_EFAIL;
+	struct mgr_object *pmgr_obj = (struct mgr_object *)hMGRHandle;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phDCDHandle != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phDCDHandle != NULL);
 
-	*phDCDHandle = (u32)NULL;
-	if (MEM_IsValidHandle(pMgrObject, SIGNATURE)) {
-		*phDCDHandle = (u32) pMgrObject->hDcdMgr;
+	*phDCDHandle = (u32) NULL;
+	if (MEM_IS_VALID_HANDLE(pmgr_obj, SIGNATURE)) {
+		*phDCDHandle = (u32) pmgr_obj->hdcd_mgr;
 		status = DSP_SOK;
 	}
-	DBC_Ensure((DSP_SUCCEEDED(status) && *phDCDHandle != (u32)NULL) ||
-		  (DSP_FAILED(status) && *phDCDHandle == (u32)NULL));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && *phDCDHandle != (u32) NULL) ||
+		   (DSP_FAILED(status) && *phDCDHandle == (u32) NULL));
 
 	return status;
 }
 
 /*
- *  ======== MGR_Init ========
+ *  ======== mgr_init ========
  *      Initialize MGR's private state, keeping a reference count on each call.
  */
-bool MGR_Init(void)
+bool mgr_init(void)
 {
-	bool fRetval = true;
-	bool fInitDCD = false;
-
-	DBC_Require(cRefs >= 0);
+	bool ret = true;
+	bool init_dcd = false;
 
-	if (cRefs == 0) {
+	DBC_REQUIRE(refs >= 0);
 
-		/* Set the Trace mask */
-		DBC_Assert(!MGR_DebugMask.flags);
+	if (refs == 0) {
+		init_dcd = dcd_init();	/*  DCD Module */
 
-		GT_create(&MGR_DebugMask, "MG");	/* "MG" for Manager */
-		fInitDCD = DCD_Init();	/*  DCD Module */
-
-		if (!fInitDCD) {
-			fRetval = false;
-			GT_0trace(MGR_DebugMask, GT_6CLASS,
-				 "MGR_Init failed\n");
-		}
+		if (!init_dcd)
+			ret = false;
 	}
 
-	if (fRetval)
-		cRefs++;
+	if (ret)
+		refs++;
 
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	GT_1trace(MGR_DebugMask, GT_5CLASS,
-		 "Entered MGR_Init, ref count:  0x%x\n", cRefs);
-	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
-
-	return fRetval;
+	return ret;
 }
 
 /*
- *  ======== MGR_WaitForBridgeEvents ========
+ *  ======== mgr_wait_for_bridge_events ========
  *      Block on any Bridge event(s)
  */
-DSP_STATUS MGR_WaitForBridgeEvents(struct DSP_NOTIFICATION **aNotifications,
-				  u32 uCount, OUT u32 *puIndex, u32 uTimeout)
+dsp_status mgr_wait_for_bridge_events(struct dsp_notification **anotifications,
+				      u32 count, OUT u32 *pu_index,
+				      u32 utimeout)
 {
-	DSP_STATUS status;
-	struct SYNC_OBJECT *hSyncEvents[MAX_EVENTS];
+	dsp_status status;
+	struct sync_object *sync_events[MAX_EVENTS];
 	u32 i;
 
-	DBC_Require(uCount < MAX_EVENTS);
+	DBC_REQUIRE(count < MAX_EVENTS);
 
-	for (i = 0; i < uCount; i++)
-		hSyncEvents[i] = aNotifications[i]->handle;
+	for (i = 0; i < count; i++)
+		sync_events[i] = anotifications[i]->handle;
 
-	status = SYNC_WaitOnMultipleEvents(hSyncEvents, uCount, uTimeout,
-					 puIndex);
+	status = sync_wait_on_multiple_events(sync_events, count, utimeout,
+					      pu_index);
 
 	return status;
 
 }
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/nldr.c kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/nldr.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/nldr.c	2011-10-11 13:51:01.429729815 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/rmgr/nldr.c	2011-10-23 08:22:37.652582000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge dynamic + overlay Node loader.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,42 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== nldr.c ========
- *  Description:
- *      DSP/BIOS Bridge dynamic + overlay Node loader.
- *
- *  Public Functions:
- *      NLDR_Allocate
- *      NLDR_Create
- *      NLDR_Delete
- *      NLDR_Exit
- *      NLDR_Free
- *      NLDR_GetFxnAddr
- *      NLDR_Init
- *      NLDR_Load
- *      NLDR_Unload
- *
- *  Notes:
- *
- *! Revision History
- *! ================
- *! 07-Apr-2003 map Removed references to dead DLDR module
- *! 23-Jan-2003 map Updated RemoteAlloc to support memory granularity
- *! 20-Jan-2003 map Updated to maintain persistent dependent libraries
- *! 15-Jan-2003 map Adapted for use with multiple dynamic phase libraries
- *! 19-Dec-2002 map Fixed overlay bug in AddOvlySect for overlay
- *!		 sections > 1024 bytes.
- *! 13-Dec-2002 map Fixed NLDR_GetFxnAddr bug by searching dependent
- *!		 libs for symbols
- *! 27-Sep-2002 map Added RemoteFree to convert size to words for
- *!		 correct deallocation
- *! 16-Sep-2002 map Code Review Cleanup(from dldr.c)
- *! 29-Aug-2002 map Adjusted for ARM-side overlay copy
- *! 05-Aug-2002 jeh Created.
- */
-
 #include <dspbridge/host_os.h>
 
 #include <dspbridge/std.h>
@@ -57,13 +23,8 @@
 #include <dspbridge/errbase.h>
 
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
-#ifdef DEBUG
-#include <dspbridge/dbg.h>
-#endif
 
 /* OS adaptation layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/mem.h>
 
 /* Platform manager */
@@ -124,19 +85,19 @@
 #define MAXSEGID	3	/* Largest possible (real) segid */
 #define MEMINTERNALID   32	/* Segid meaning use internal mem */
 #define MEMEXTERNALID   33	/* Segid meaning use external mem */
-#define NULLID	  63	/* Segid meaning no memory req/pref */
-#define FLAGBIT	 7	/* 7th bit is pref./req. flag */
-#define SEGMASK	 0x3f	/* Bits 0 - 5 */
+#define NULLID	  63		/* Segid meaning no memory req/pref */
+#define FLAGBIT	 7		/* 7th bit is pref./req. flag */
+#define SEGMASK	 0x3f		/* Bits 0 - 5 */
 
-#define CREATEBIT       0	/* Create segid starts at bit 0 */
-#define DELETEBIT       8	/* Delete segid starts at bit 8 */
+#define CREATEBIT	0	/* Create segid starts at bit 0 */
+#define DELETEBIT	8	/* Delete segid starts at bit 8 */
 #define EXECUTEBIT      16	/* Execute segid starts at bit 16 */
 
 /*
  *  Masks that define memory type.  Must match defines in dynm.cdb.
  */
-#define DYNM_CODE       0x2
-#define DYNM_DATA       0x4
+#define DYNM_CODE	0x2
+#define DYNM_DATA	0x4
 #define DYNM_CODEDATA   (DYNM_CODE | DYNM_DATA)
 #define DYNM_INTERNAL   0x8
 #define DYNM_EXTERNAL   0x10
@@ -159,12 +120,12 @@
 #define DELETECODEFLAGBIT   5
 #define MAXFLAGS	    6
 
-#define IsInternal(hNldr, segid) (((segid) <= MAXSEGID && \
-	    hNldr->segTable[(segid)] & DYNM_INTERNAL) || \
+#define IS_INTERNAL(nldr_obj, segid) (((segid) <= MAXSEGID && \
+	    nldr_obj->seg_table[(segid)] & DYNM_INTERNAL) || \
 	    (segid) == MEMINTERNALID)
 
-#define IsExternal(hNldr, segid) (((segid) <= MAXSEGID && \
-	    hNldr->segTable[(segid)] & DYNM_EXTERNAL) || \
+#define IS_EXTERNAL(nldr_obj, segid) (((segid) <= MAXSEGID && \
+	    nldr_obj->seg_table[(segid)] & DYNM_EXTERNAL) || \
 	    (segid) == MEMEXTERNALID)
 
 #define SWAPLONG(x) ((((x) << 24) & 0xFF000000) | (((x) << 8) & 0xFF0000L) | \
@@ -175,25 +136,25 @@
     /*
      *  These names may be embedded in overlay sections to identify which
      *  node phase the section should be overlayed.
-     */
+ */
 #define PCREATE	 "create"
 #define PDELETE	 "delete"
 #define PEXECUTE	"execute"
 
-#define IsEqualUUID(uuid1, uuid2) (\
-	((uuid1).ulData1 == (uuid2).ulData1) && \
-	((uuid1).usData2 == (uuid2).usData2) && \
-	((uuid1).usData3 == (uuid2).usData3) && \
-	((uuid1).ucData4 == (uuid2).ucData4) && \
-	((uuid1).ucData5 == (uuid2).ucData5) && \
-       (strncmp((void *)(uuid1).ucData6, (void *)(uuid2).ucData6, 6)) == 0)
+#define IS_EQUAL_UUID(uuid1, uuid2) (\
+	((uuid1).ul_data1 == (uuid2).ul_data1) && \
+	((uuid1).us_data2 == (uuid2).us_data2) && \
+	((uuid1).us_data3 == (uuid2).us_data3) && \
+	((uuid1).uc_data4 == (uuid2).uc_data4) && \
+	((uuid1).uc_data5 == (uuid2).uc_data5) && \
+	(strncmp((void *)(uuid1).uc_data6, (void *)(uuid2).uc_data6, 6)) == 0)
 
     /*
-     *  ======== MemInfo ========
+     *  ======== mem_seg_info ========
      *  Format of dynamic loading memory segment info in coff file.
      *  Must match dynm.h55.
-     */
-struct MemInfo {
+ */
+struct mem_seg_info {
 	u32 segid;		/* Dynamic loading memory segment number */
 	u32 base;
 	u32 len;
@@ -201,622 +162,591 @@
 };
 
 /*
- *  ======== LibNode ========
+ *  ======== lib_node ========
  *  For maintaining a tree of library dependencies.
  */
-struct LibNode {
-	struct DBLL_LibraryObj *lib;	/* The library */
-	u16 nDepLibs;	/* Number of dependent libraries */
-	struct LibNode *pDepLibs;	/* Dependent libraries of lib */
+struct lib_node {
+	struct dbll_library_obj *lib;	/* The library */
+	u16 dep_libs;		/* Number of dependent libraries */
+	struct lib_node *dep_libs_tree;	/* Dependent libraries of lib */
 };
 
 /*
- *  ======== OvlySect ========
+ *  ======== ovly_sect ========
  *  Information needed to overlay a section.
  */
-struct OvlySect {
-	struct OvlySect *pNextSect;
-	u32 loadAddr;		/* Load address of section */
-	u32 runAddr;		/* Run address of section */
+struct ovly_sect {
+	struct ovly_sect *next_sect;
+	u32 sect_load_addr;	/* Load address of section */
+	u32 sect_run_addr;	/* Run address of section */
 	u32 size;		/* Size of section */
 	u16 page;		/* DBL_CODE, DBL_DATA */
 };
 
 /*
- *  ======== OvlyNode ========
+ *  ======== ovly_node ========
  *  For maintaining a list of overlay nodes, with sections that need to be
  *  overlayed for each of the nodes phases.
  */
-struct OvlyNode {
-	struct DSP_UUID uuid;
-	char *pNodeName;
-	struct OvlySect *pCreateSects;
-	struct OvlySect *pDeleteSects;
-	struct OvlySect *pExecuteSects;
-	struct OvlySect *pOtherSects;
-	u16 nCreateSects;
-	u16 nDeleteSects;
-	u16 nExecuteSects;
-	u16 nOtherSects;
-	u16 createRef;
-	u16 deleteRef;
-	u16 executeRef;
-	u16 otherRef;
+struct ovly_node {
+	struct dsp_uuid uuid;
+	char *node_name;
+	struct ovly_sect *create_sects_list;
+	struct ovly_sect *delete_sects_list;
+	struct ovly_sect *execute_sects_list;
+	struct ovly_sect *other_sects_list;
+	u16 create_sects;
+	u16 delete_sects;
+	u16 execute_sects;
+	u16 other_sects;
+	u16 create_ref;
+	u16 delete_ref;
+	u16 execute_ref;
+	u16 other_ref;
 };
 
 /*
- *  ======== NLDR_OBJECT ========
+ *  ======== nldr_object ========
  *  Overlay loader object.
  */
-struct NLDR_OBJECT {
-	u32 dwSignature;	/* For object validation */
-	struct DEV_OBJECT *hDevObject;	/* Device object */
-	struct DCD_MANAGER *hDcdMgr;	/* Proc/Node data manager */
-	struct DBLL_TarObj *dbll;	/* The DBL loader */
-	struct DBLL_LibraryObj *baseLib;	/* Base image library */
-	struct RMM_TargetObj *rmm;	/* Remote memory manager for DSP */
-	struct DBLL_Fxns dbllFxns;	/* Loader function table */
-	struct DBLL_Attrs dbllAttrs;	/* attrs to pass to loader functions */
-	NLDR_OVLYFXN ovlyFxn;	/* "write" for overlay nodes */
-	NLDR_WRITEFXN writeFxn;	/* "write" for dynamic nodes */
-	struct OvlyNode *ovlyTable;	/* Table of overlay nodes */
-	u16 nOvlyNodes;	/* Number of overlay nodes in base */
-	u16 nNode;		/* Index for tracking overlay nodes */
-	u16 nSegs;		/* Number of dynamic load mem segs */
-	u32 *segTable;	/* memtypes of dynamic memory segs
+struct nldr_object {
+	u32 dw_signature;	/* For object validation */
+	struct dev_object *hdev_obj;	/* Device object */
+	struct dcd_manager *hdcd_mgr;	/* Proc/Node data manager */
+	struct dbll_tar_obj *dbll;	/* The DBL loader */
+	struct dbll_library_obj *base_lib;	/* Base image library */
+	struct rmm_target_obj *rmm;	/* Remote memory manager for DSP */
+	struct dbll_fxns ldr_fxns;	/* Loader function table */
+	struct dbll_attrs ldr_attrs;	/* attrs to pass to loader functions */
+	nldr_ovlyfxn ovly_fxn;	/* "write" for overlay nodes */
+	nldr_writefxn write_fxn;	/* "write" for dynamic nodes */
+	struct ovly_node *ovly_table;	/* Table of overlay nodes */
+	u16 ovly_nodes;		/* Number of overlay nodes in base */
+	u16 ovly_nid;		/* Index for tracking overlay nodes */
+	u16 dload_segs;		/* Number of dynamic load mem segs */
+	u32 *seg_table;		/* memtypes of dynamic memory segs
 				 * indexed by segid
 				 */
-	u16 usDSPMauSize;	/* Size of DSP MAU */
-	u16 usDSPWordSize;	/* Size of DSP word */
+	u16 us_dsp_mau_size;	/* Size of DSP MAU */
+	u16 us_dsp_word_size;	/* Size of DSP word */
 };
 
 /*
- *  ======== NLDR_NODEOBJECT ========
+ *  ======== nldr_nodeobject ========
  *  Dynamic node object. This object is created when a node is allocated.
  */
-struct NLDR_NODEOBJECT {
-	u32 dwSignature;	/* For object validation */
-	struct NLDR_OBJECT *pNldr;	/* Dynamic loader handle */
-	void *pPrivRef;		/* Handle to pass to DBL_WriteFxn */
-	struct DSP_UUID uuid;		/* Node's UUID */
-	bool fDynamic;		/* Dynamically loaded node? */
-	bool fOverlay;		/* Overlay node? */
-	bool *pfPhaseSplit;	/* Multiple phase libraries? */
-	struct LibNode root;		/* Library containing node phase */
-	struct LibNode createLib;    /* Library containing create phase lib */
-	struct LibNode executeLib;   /* Library containing execute phase lib */
-	struct LibNode deleteLib;    /* Library containing delete phase lib */
-	struct LibNode persLib[MAXLIBS];  /* libs remain loaded until Delete */
-	s32 nPersLib;		/* Number of persistent libraries */
+struct nldr_nodeobject {
+	u32 dw_signature;	/* For object validation */
+	struct nldr_object *nldr_obj;	/* Dynamic loader handle */
+	void *priv_ref;		/* Handle to pass to dbl_write_fxn */
+	struct dsp_uuid uuid;	/* Node's UUID */
+	bool dynamic;		/* Dynamically loaded node? */
+	bool overlay;		/* Overlay node? */
+	bool *pf_phase_split;	/* Multiple phase libraries? */
+	struct lib_node root;	/* Library containing node phase */
+	struct lib_node create_lib;	/* Library with create phase lib */
+	struct lib_node execute_lib;	/* Library with execute phase lib */
+	struct lib_node delete_lib;	/* Library with delete phase lib */
+	/* libs remain loaded until Delete */
+	struct lib_node pers_lib_table[MAXLIBS];
+	s32 pers_libs;		/* Number of persistent libraries */
 	/* Path in lib dependency tree */
-	struct DBLL_LibraryObj *libPath[MAXDEPTH + 1];
-	enum NLDR_PHASE phase;	/* Node phase currently being loaded */
+	struct dbll_library_obj *lib_path[MAXDEPTH + 1];
+	enum nldr_phase phase;	/* Node phase currently being loaded */
 
 	/*
 	 *  Dynamic loading memory segments for data and code of each phase.
 	 */
-	u16 segId[MAXFLAGS];
+	u16 seg_id[MAXFLAGS];
 
 	/*
-	 *  Mask indicating whether each mem segment specified in segId[]
+	 *  Mask indicating whether each mem segment specified in seg_id[]
 	 *  is preferred or required.
-	 *  For example if (codeDataFlagMask & (1 << EXECUTEDATAFLAGBIT)) != 0,
+	 *  For example
+	 *  	if (code_data_flag_mask & (1 << EXECUTEDATAFLAGBIT)) != 0,
 	 *  then it is required to load execute phase data into the memory
-	 *  specified by segId[EXECUTEDATAFLAGBIT].
+	 *  specified by seg_id[EXECUTEDATAFLAGBIT].
 	 */
-	u32 codeDataFlagMask;
+	u32 code_data_flag_mask;
 };
 
 /* Dynamic loader function table */
-static struct DBLL_Fxns dbllFxns = {
-	(DBLL_CloseFxn) DBLL_close,
-	(DBLL_CreateFxn) DBLL_create,
-	(DBLL_DeleteFxn) DBLL_delete,
-	(DBLL_ExitFxn) DBLL_exit,
-	(DBLL_GetAttrsFxn) DBLL_getAttrs,
-	(DBLL_GetAddrFxn) DBLL_getAddr,
-	(DBLL_GetCAddrFxn) DBLL_getCAddr,
-	(DBLL_GetSectFxn) DBLL_getSect,
-	(DBLL_InitFxn) DBLL_init,
-	(DBLL_LoadFxn) DBLL_load,
-	(DBLL_LoadSectFxn) DBLL_loadSect,
-	(DBLL_OpenFxn) DBLL_open,
-	(DBLL_ReadSectFxn) DBLL_readSect,
-	(DBLL_SetAttrsFxn) DBLL_setAttrs,
-	(DBLL_UnloadFxn) DBLL_unload,
-	(DBLL_UnloadSectFxn) DBLL_unloadSect,
+static struct dbll_fxns ldr_fxns = {
+	(dbll_close_fxn) dbll_close,
+	(dbll_create_fxn) dbll_create,
+	(dbll_delete_fxn) dbll_delete,
+	(dbll_exit_fxn) dbll_exit,
+	(dbll_get_attrs_fxn) dbll_get_attrs,
+	(dbll_get_addr_fxn) dbll_get_addr,
+	(dbll_get_c_addr_fxn) dbll_get_c_addr,
+	(dbll_get_sect_fxn) dbll_get_sect,
+	(dbll_init_fxn) dbll_init,
+	(dbll_load_fxn) dbll_load,
+	(dbll_load_sect_fxn) dbll_load_sect,
+	(dbll_open_fxn) dbll_open,
+	(dbll_read_sect_fxn) dbll_read_sect,
+	(dbll_set_attrs_fxn) dbll_set_attrs,
+	(dbll_unload_fxn) dbll_unload,
+	(dbll_unload_sect_fxn) dbll_unload_sect,
 };
 
-static struct GT_Mask NLDR_debugMask = { NULL, NULL };	/* GT trace variable */
-static u32 cRefs;		/* module reference count */
+static u32 refs;		/* module reference count */
 
-static DSP_STATUS AddOvlyInfo(void *handle, struct DBLL_SectInfo *sectInfo,
-			     u32 addr, u32 nBytes);
-static DSP_STATUS AddOvlyNode(struct DSP_UUID *pUuid,
-			     enum DSP_DCDOBJTYPE objType,
-			     IN void *handle);
-static DSP_STATUS AddOvlySect(struct NLDR_OBJECT *hNldr,
-			      struct OvlySect **pList,
-			      struct DBLL_SectInfo *pSectInfo, bool *pExists,
-			      u32 addr, u32 nBytes);
-static s32 fakeOvlyWrite(void *handle, u32 dspAddr, void *buf, u32 nBytes,
-			s32 mtype);
-static void FreeSects(struct NLDR_OBJECT *hNldr, struct OvlySect *pPhaseSects,
-		     u16 nAlloc);
-static bool GetSymbolValue(void *handle, void *pArg, void *rmmHandle,
-			  char *symName, struct DBLL_Symbol **sym);
-static DSP_STATUS LoadLib(struct NLDR_NODEOBJECT *hNldrNode,
-			 struct LibNode *root, struct DSP_UUID uuid,
-			 bool rootPersistent, struct DBLL_LibraryObj **libPath,
-			 enum NLDR_PHASE phase, u16 depth);
-static DSP_STATUS LoadOvly(struct NLDR_NODEOBJECT *hNldrNode,
-			  enum NLDR_PHASE phase);
-static DSP_STATUS RemoteAlloc(void **pRef, u16 memType, u32 size,
-			     u32 align, u32 *dspAddr,
-			     OPTIONAL s32 segmentId, OPTIONAL s32 req,
-			     bool reserve);
-static DSP_STATUS RemoteFree(void **pRef, u16 space, u32 dspAddr,
-			    u32 size, bool reserve);
-
-static void UnloadLib(struct NLDR_NODEOBJECT *hNldrNode, struct LibNode *root);
-static void UnloadOvly(struct NLDR_NODEOBJECT *hNldrNode,
-		      enum NLDR_PHASE phase);
-static bool findInPersistentLibArray(struct NLDR_NODEOBJECT *hNldrNode,
-				    struct DBLL_LibraryObj *lib);
-static u32 findLcm(u32 a, u32 b);
-static u32 findGcf(u32 a, u32 b);
-
-/*
- *  ======== NLDR_Allocate ========
- */
-DSP_STATUS NLDR_Allocate(struct NLDR_OBJECT *hNldr, void *pPrivRef,
-			 IN CONST struct DCD_NODEPROPS *pNodeProps,
-			 OUT struct NLDR_NODEOBJECT **phNldrNode,
-			 IN bool *pfPhaseSplit)
-{
-	struct NLDR_NODEOBJECT *pNldrNode = NULL;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pNodeProps != NULL);
-	DBC_Require(phNldrNode != NULL);
-	DBC_Require(MEM_IsValidHandle(hNldr, NLDR_SIGNATURE));
-
-	GT_5trace(NLDR_debugMask, GT_ENTER, "NLDR_Allocate(0x%x, 0x%x, 0x%x, "
-		 "0x%x, 0x%x)\n", hNldr, pPrivRef, pNodeProps, phNldrNode,
-		 pfPhaseSplit);
+static dsp_status add_ovly_info(void *handle, struct dbll_sect_info *sect_info,
+				u32 addr, u32 bytes);
+static dsp_status add_ovly_node(struct dsp_uuid *uuid_obj,
+				enum dsp_dcdobjtype obj_type, IN void *handle);
+static dsp_status add_ovly_sect(struct nldr_object *nldr_obj,
+				struct ovly_sect **pList,
+				struct dbll_sect_info *pSectInfo,
+				bool *pExists, u32 addr, u32 bytes);
+static s32 fake_ovly_write(void *handle, u32 dspAddr, void *buf, u32 bytes,
+			   s32 mtype);
+static void free_sects(struct nldr_object *nldr_obj,
+		       struct ovly_sect *phase_sects, u16 alloc_num);
+static bool get_symbol_value(void *handle, void *parg, void *rmm_handle,
+			     char *symName, struct dbll_sym_val **sym);
+static dsp_status load_lib(struct nldr_nodeobject *nldr_node_obj,
+			   struct lib_node *root, struct dsp_uuid uuid,
+			   bool rootPersistent,
+			   struct dbll_library_obj **lib_path,
+			   enum nldr_phase phase, u16 depth);
+static dsp_status load_ovly(struct nldr_nodeobject *nldr_node_obj,
+			    enum nldr_phase phase);
+static dsp_status remote_alloc(void **pRef, u16 mem_sect_type, u32 size,
+			       u32 align, u32 *dspAddr, OPTIONAL s32 segmentId,
+			       OPTIONAL s32 req, bool reserve);
+static dsp_status remote_free(void **pRef, u16 space, u32 dspAddr, u32 size,
+			      bool reserve);
+
+static void unload_lib(struct nldr_nodeobject *nldr_node_obj,
+		       struct lib_node *root);
+static void unload_ovly(struct nldr_nodeobject *nldr_node_obj,
+			enum nldr_phase phase);
+static bool find_in_persistent_lib_array(struct nldr_nodeobject *nldr_node_obj,
+					 struct dbll_library_obj *lib);
+static u32 find_lcm(u32 a, u32 b);
+static u32 find_gcf(u32 a, u32 b);
+
+/*
+ *  ======== nldr_allocate ========
+ */
+dsp_status nldr_allocate(struct nldr_object *nldr_obj, void *priv_ref,
+			 IN CONST struct dcd_nodeprops *node_props,
+			 OUT struct nldr_nodeobject **phNldrNode,
+			 IN bool *pf_phase_split)
+{
+	struct nldr_nodeobject *nldr_node_obj = NULL;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(node_props != NULL);
+	DBC_REQUIRE(phNldrNode != NULL);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(nldr_obj, NLDR_SIGNATURE));
 
 	/* Initialize handle in case of failure */
 	*phNldrNode = NULL;
 	/* Allocate node object */
-	MEM_AllocObject(pNldrNode, struct NLDR_NODEOBJECT, NLDR_NODESIGNATURE);
+	MEM_ALLOC_OBJECT(nldr_node_obj, struct nldr_nodeobject,
+			 NLDR_NODESIGNATURE);
 
-	if (pNldrNode == NULL) {
-		GT_0trace(NLDR_debugMask, GT_6CLASS, "NLDR_Allocate: "
-			 "Memory allocation failed\n");
+	if (nldr_node_obj == NULL) {
 		status = DSP_EMEMORY;
 	} else {
-		pNldrNode->pfPhaseSplit = pfPhaseSplit;
-		pNldrNode->nPersLib = 0;
-		pNldrNode->pNldr = hNldr;
-		pNldrNode->pPrivRef = pPrivRef;
+		nldr_node_obj->pf_phase_split = pf_phase_split;
+		nldr_node_obj->pers_libs = 0;
+		nldr_node_obj->nldr_obj = nldr_obj;
+		nldr_node_obj->priv_ref = priv_ref;
 		/* Save node's UUID. */
-		pNldrNode->uuid = pNodeProps->ndbProps.uiNodeID;
+		nldr_node_obj->uuid = node_props->ndb_props.ui_node_id;
 		/*
 		 *  Determine if node is a dynamically loaded node from
-		 *  ndbProps.
+		 *  ndb_props.
 		 */
-		if (pNodeProps->usLoadType == NLDR_DYNAMICLOAD) {
+		if (node_props->us_load_type == NLDR_DYNAMICLOAD) {
 			/* Dynamic node */
-			pNldrNode->fDynamic = true;
+			nldr_node_obj->dynamic = true;
 			/*
-			 *  Extract memory requirements from ndbProps masks
+			 *  Extract memory requirements from ndb_props masks
 			 */
 			/* Create phase */
-			pNldrNode->segId[CREATEDATAFLAGBIT] = (u16)
-				(pNodeProps->ulDataMemSegMask >> CREATEBIT) &
-				SEGMASK;
-			pNldrNode->codeDataFlagMask |=
-				((pNodeProps->ulDataMemSegMask >>
-				(CREATEBIT + FLAGBIT)) & 1) <<
-				CREATEDATAFLAGBIT;
-			pNldrNode->segId[CREATECODEFLAGBIT] = (u16)
-				(pNodeProps->ulCodeMemSegMask >>
-				CREATEBIT) & SEGMASK;
-			pNldrNode->codeDataFlagMask |=
-				((pNodeProps->ulCodeMemSegMask >>
-				(CREATEBIT + FLAGBIT)) & 1) <<
-				CREATECODEFLAGBIT;
+			nldr_node_obj->seg_id[CREATEDATAFLAGBIT] = (u16)
+			    (node_props->ul_data_mem_seg_mask >> CREATEBIT) &
+			    SEGMASK;
+			nldr_node_obj->code_data_flag_mask |=
+			    ((node_props->ul_data_mem_seg_mask >>
+			      (CREATEBIT + FLAGBIT)) & 1) << CREATEDATAFLAGBIT;
+			nldr_node_obj->seg_id[CREATECODEFLAGBIT] = (u16)
+			    (node_props->ul_code_mem_seg_mask >>
+			     CREATEBIT) & SEGMASK;
+			nldr_node_obj->code_data_flag_mask |=
+			    ((node_props->ul_code_mem_seg_mask >>
+			      (CREATEBIT + FLAGBIT)) & 1) << CREATECODEFLAGBIT;
 			/* Execute phase */
-			pNldrNode->segId[EXECUTEDATAFLAGBIT] = (u16)
-				(pNodeProps->ulDataMemSegMask >>
-				EXECUTEBIT) & SEGMASK;
-			pNldrNode->codeDataFlagMask |=
-				((pNodeProps->ulDataMemSegMask >>
-				(EXECUTEBIT + FLAGBIT)) & 1) <<
-				EXECUTEDATAFLAGBIT;
-			pNldrNode->segId[EXECUTECODEFLAGBIT] = (u16)
-				(pNodeProps->ulCodeMemSegMask >>
-				EXECUTEBIT) & SEGMASK;
-			pNldrNode->codeDataFlagMask |=
-				((pNodeProps->ulCodeMemSegMask >>
-				(EXECUTEBIT + FLAGBIT)) & 1) <<
-				EXECUTECODEFLAGBIT;
+			nldr_node_obj->seg_id[EXECUTEDATAFLAGBIT] = (u16)
+			    (node_props->ul_data_mem_seg_mask >>
+			     EXECUTEBIT) & SEGMASK;
+			nldr_node_obj->code_data_flag_mask |=
+			    ((node_props->ul_data_mem_seg_mask >>
+			      (EXECUTEBIT + FLAGBIT)) & 1) <<
+			    EXECUTEDATAFLAGBIT;
+			nldr_node_obj->seg_id[EXECUTECODEFLAGBIT] = (u16)
+			    (node_props->ul_code_mem_seg_mask >>
+			     EXECUTEBIT) & SEGMASK;
+			nldr_node_obj->code_data_flag_mask |=
+			    ((node_props->ul_code_mem_seg_mask >>
+			      (EXECUTEBIT + FLAGBIT)) & 1) <<
+			    EXECUTECODEFLAGBIT;
 			/* Delete phase */
-			pNldrNode->segId[DELETEDATAFLAGBIT] = (u16)
-			    (pNodeProps->ulDataMemSegMask >> DELETEBIT) &
+			nldr_node_obj->seg_id[DELETEDATAFLAGBIT] = (u16)
+			    (node_props->ul_data_mem_seg_mask >> DELETEBIT) &
 			    SEGMASK;
-			pNldrNode->codeDataFlagMask |=
-				((pNodeProps->ulDataMemSegMask >>
-				(DELETEBIT + FLAGBIT)) & 1) <<
-				DELETEDATAFLAGBIT;
-			pNldrNode->segId[DELETECODEFLAGBIT] = (u16)
-				(pNodeProps->ulCodeMemSegMask >>
-				DELETEBIT) & SEGMASK;
-			pNldrNode->codeDataFlagMask |=
-				((pNodeProps->ulCodeMemSegMask >>
-				(DELETEBIT + FLAGBIT)) & 1) <<
-				DELETECODEFLAGBIT;
+			nldr_node_obj->code_data_flag_mask |=
+			    ((node_props->ul_data_mem_seg_mask >>
+			      (DELETEBIT + FLAGBIT)) & 1) << DELETEDATAFLAGBIT;
+			nldr_node_obj->seg_id[DELETECODEFLAGBIT] = (u16)
+			    (node_props->ul_code_mem_seg_mask >>
+			     DELETEBIT) & SEGMASK;
+			nldr_node_obj->code_data_flag_mask |=
+			    ((node_props->ul_code_mem_seg_mask >>
+			      (DELETEBIT + FLAGBIT)) & 1) << DELETECODEFLAGBIT;
 		} else {
 			/* Non-dynamically loaded nodes are part of the
 			 * base image */
-			pNldrNode->root.lib = hNldr->baseLib;
+			nldr_node_obj->root.lib = nldr_obj->base_lib;
 			/* Check for overlay node */
-			if (pNodeProps->usLoadType == NLDR_OVLYLOAD)
-				pNldrNode->fOverlay = true;
+			if (node_props->us_load_type == NLDR_OVLYLOAD)
+				nldr_node_obj->overlay = true;
 
 		}
-		*phNldrNode = (struct NLDR_NODEOBJECT *) pNldrNode;
+		*phNldrNode = (struct nldr_nodeobject *)nldr_node_obj;
 	}
 	/* Cleanup on failure */
-	if (DSP_FAILED(status) && pNldrNode)
-		NLDR_Free((struct NLDR_NODEOBJECT *) pNldrNode);
+	if (DSP_FAILED(status) && nldr_node_obj)
+		MEM_FREE_OBJECT(nldr_node_obj);
 
-	DBC_Ensure((DSP_SUCCEEDED(status) &&
-		  MEM_IsValidHandle(((struct NLDR_NODEOBJECT *)(*phNldrNode)),
-		  NLDR_NODESIGNATURE)) || (DSP_FAILED(status) &&
-		  *phNldrNode == NULL));
+	DBC_ENSURE((DSP_SUCCEEDED(status) &&
+		    MEM_IS_VALID_HANDLE(((struct nldr_nodeobject
+					  *)(*phNldrNode)), NLDR_NODESIGNATURE))
+		   || (DSP_FAILED(status) && *phNldrNode == NULL));
 	return status;
 }
 
 /*
- *  ======== NLDR_Create ========
+ *  ======== nldr_create ========
  */
-DSP_STATUS NLDR_Create(OUT struct NLDR_OBJECT **phNldr,
-		      struct DEV_OBJECT *hDevObject,
-		      IN CONST struct NLDR_ATTRS *pAttrs)
-{
-	struct COD_MANAGER *hCodMgr;	/* COD manager */
-	char *pszCoffBuf = NULL;
-	char szZLFile[COD_MAXPATHLENGTH];
-	struct NLDR_OBJECT *pNldr = NULL;
-	struct DBLL_Attrs saveAttrs;
-	struct DBLL_Attrs newAttrs;
-	DBLL_Flags flags;
-	u32 ulEntry;
-	u16 nSegs = 0;
-	struct MemInfo *pMemInfo;
-	u32 ulLen = 0;
-	u32 ulAddr;
-	struct RMM_Segment *rmmSegs = NULL;
+dsp_status nldr_create(OUT struct nldr_object **phNldr,
+		       struct dev_object *hdev_obj,
+		       IN CONST struct nldr_attrs *pattrs)
+{
+	struct cod_manager *cod_mgr;	/* COD manager */
+	char *psz_coff_buf = NULL;
+	char sz_zl_file[COD_MAXPATHLENGTH];
+	struct nldr_object *nldr_obj = NULL;
+	struct dbll_attrs save_attrs;
+	struct dbll_attrs new_attrs;
+	dbll_flags flags;
+	u32 ul_entry;
+	u16 dload_segs = 0;
+	struct mem_seg_info *mem_info_obj;
+	u32 ul_len = 0;
+	u32 ul_addr;
+	struct rmm_segment *rmm_segs = NULL;
 	u16 i;
-	DSP_STATUS status = DSP_SOK;
-	DBC_Require(cRefs > 0);
-	DBC_Require(phNldr != NULL);
-	DBC_Require(hDevObject != NULL);
-	DBC_Require(pAttrs != NULL);
-	DBC_Require(pAttrs->pfnOvly != NULL);
-	DBC_Require(pAttrs->pfnWrite != NULL);
-	GT_3trace(NLDR_debugMask, GT_ENTER, "NLDR_Create(0x%x, 0x%x, 0x%x)\n",
-		 phNldr, hDevObject, pAttrs);
+	dsp_status status = DSP_SOK;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phNldr != NULL);
+	DBC_REQUIRE(hdev_obj != NULL);
+	DBC_REQUIRE(pattrs != NULL);
+	DBC_REQUIRE(pattrs->pfn_ovly != NULL);
+	DBC_REQUIRE(pattrs->pfn_write != NULL);
+
 	/* Allocate dynamic loader object */
-	MEM_AllocObject(pNldr, struct NLDR_OBJECT, NLDR_SIGNATURE);
-	if (pNldr) {
-		pNldr->hDevObject = hDevObject;
+	MEM_ALLOC_OBJECT(nldr_obj, struct nldr_object, NLDR_SIGNATURE);
+	if (nldr_obj) {
+		nldr_obj->hdev_obj = hdev_obj;
 		/* warning, lazy status checking alert! */
-		status = DEV_GetCodMgr(hDevObject, &hCodMgr);
-		DBC_Assert(DSP_SUCCEEDED(status));
-		status = COD_GetLoader(hCodMgr, &pNldr->dbll);
-		DBC_Assert(DSP_SUCCEEDED(status));
-		status = COD_GetBaseLib(hCodMgr, &pNldr->baseLib);
-		DBC_Assert(DSP_SUCCEEDED(status));
-		status = COD_GetBaseName(hCodMgr, szZLFile, COD_MAXPATHLENGTH);
-		DBC_Assert(DSP_SUCCEEDED(status));
+		status = dev_get_cod_mgr(hdev_obj, &cod_mgr);
+		DBC_ASSERT(DSP_SUCCEEDED(status));
+		status = cod_get_loader(cod_mgr, &nldr_obj->dbll);
+		DBC_ASSERT(DSP_SUCCEEDED(status));
+		status = cod_get_base_lib(cod_mgr, &nldr_obj->base_lib);
+		DBC_ASSERT(DSP_SUCCEEDED(status));
+		status =
+		    cod_get_base_name(cod_mgr, sz_zl_file, COD_MAXPATHLENGTH);
+		DBC_ASSERT(DSP_SUCCEEDED(status));
 		status = DSP_SOK;
 		/* end lazy status checking */
-		pNldr->usDSPMauSize = pAttrs->usDSPMauSize;
-		pNldr->usDSPWordSize = pAttrs->usDSPWordSize;
-		pNldr->dbllFxns = dbllFxns;
-		if (!(pNldr->dbllFxns.initFxn()))
+		nldr_obj->us_dsp_mau_size = pattrs->us_dsp_mau_size;
+		nldr_obj->us_dsp_word_size = pattrs->us_dsp_word_size;
+		nldr_obj->ldr_fxns = ldr_fxns;
+		if (!(nldr_obj->ldr_fxns.init_fxn()))
 			status = DSP_EMEMORY;
 
 	} else {
-		GT_0trace(NLDR_debugMask, GT_6CLASS, "NLDR_Create: "
-			 "Memory allocation failed\n");
 		status = DSP_EMEMORY;
 	}
 	/* Create the DCD Manager */
 	if (DSP_SUCCEEDED(status))
-		status = DCD_CreateManager(NULL, &pNldr->hDcdMgr);
+		status = dcd_create_manager(NULL, &nldr_obj->hdcd_mgr);
 
 	/* Get dynamic loading memory sections from base lib */
 	if (DSP_SUCCEEDED(status)) {
-		status = pNldr->dbllFxns.getSectFxn(pNldr->baseLib, DYNMEMSECT,
-			 &ulAddr, &ulLen);
+		status =
+		    nldr_obj->ldr_fxns.get_sect_fxn(nldr_obj->base_lib,
+						    DYNMEMSECT, &ul_addr,
+						    &ul_len);
 		if (DSP_SUCCEEDED(status)) {
-			pszCoffBuf = MEM_Calloc(ulLen * pNldr->usDSPMauSize,
-						MEM_PAGED);
-			if (!pszCoffBuf) {
-				GT_0trace(NLDR_debugMask, GT_6CLASS,
-					 "NLDR_Create: Memory "
-					 "allocation failed\n");
+			psz_coff_buf =
+			    mem_calloc(ul_len * nldr_obj->us_dsp_mau_size,
+				       MEM_PAGED);
+			if (!psz_coff_buf)
 				status = DSP_EMEMORY;
-			}
 		} else {
 			/* Ok to not have dynamic loading memory */
 			status = DSP_SOK;
-			ulLen = 0;
-			GT_1trace(NLDR_debugMask, GT_6CLASS,
-				 "NLDR_Create: DBLL_getSect "
-				 "failed (no dynamic loading mem segments): "
-				 "0x%lx\n", status);
+			ul_len = 0;
+			dev_dbg(bridge, "%s: failed - no dynamic loading mem "
+				"segments: 0x%x\n", __func__, status);
 		}
 	}
-	if (DSP_SUCCEEDED(status) && ulLen > 0) {
+	if (DSP_SUCCEEDED(status) && ul_len > 0) {
 		/* Read section containing dynamic load mem segments */
-		status = pNldr->dbllFxns.readSectFxn(pNldr->baseLib, DYNMEMSECT,
-						    pszCoffBuf, ulLen);
-		if (DSP_FAILED(status)) {
-			GT_1trace(NLDR_debugMask, GT_6CLASS,
-				 "NLDR_Create: DBLL_read Section"
-				 "failed: 0x%lx\n", status);
-		}
+		status =
+		    nldr_obj->ldr_fxns.read_sect_fxn(nldr_obj->base_lib,
+						     DYNMEMSECT, psz_coff_buf,
+						     ul_len);
 	}
-	if (DSP_SUCCEEDED(status) && ulLen > 0) {
+	if (DSP_SUCCEEDED(status) && ul_len > 0) {
 		/* Parse memory segment data */
-		nSegs = (u16)(*((u32 *)pszCoffBuf));
-		if (nSegs > MAXMEMSEGS) {
-			GT_1trace(NLDR_debugMask, GT_6CLASS,
-				 "NLDR_Create: Invalid number of "
-				 "dynamic load mem segments: 0x%lx\n", nSegs);
+		dload_segs = (u16) (*((u32 *) psz_coff_buf));
+		if (dload_segs > MAXMEMSEGS)
 			status = DSP_ECORRUPTFILE;
-		}
 	}
 	/* Parse dynamic load memory segments */
-	if (DSP_SUCCEEDED(status) && nSegs > 0) {
-		rmmSegs = MEM_Calloc(sizeof(struct RMM_Segment) * nSegs,
-				    MEM_PAGED);
-		pNldr->segTable = MEM_Calloc(sizeof(u32) * nSegs, MEM_PAGED);
-		if (rmmSegs == NULL || pNldr->segTable == NULL) {
+	if (DSP_SUCCEEDED(status) && dload_segs > 0) {
+		rmm_segs = mem_calloc(sizeof(struct rmm_segment) * dload_segs,
+				      MEM_PAGED);
+		nldr_obj->seg_table =
+		    mem_calloc(sizeof(u32) * dload_segs, MEM_PAGED);
+		if (rmm_segs == NULL || nldr_obj->seg_table == NULL) {
 			status = DSP_EMEMORY;
 		} else {
-			pNldr->nSegs = nSegs;
-			pMemInfo = (struct MemInfo *)(pszCoffBuf +
-				   sizeof(u32));
-			for (i = 0; i < nSegs; i++) {
-				rmmSegs[i].base = (pMemInfo + i)->base;
-				rmmSegs[i].length = (pMemInfo + i)->len;
-				rmmSegs[i].space = 0;
-				pNldr->segTable[i] = (pMemInfo + i)->type;
-#ifdef DEBUG
-				DBG_Trace(DBG_LEVEL7,
-				    "** (proc) DLL MEMSEGMENT: %d, Base: 0x%x, "
-				    "Length: 0x%x\n", i, rmmSegs[i].base,
-				    rmmSegs[i].length);
-#endif
+			nldr_obj->dload_segs = dload_segs;
+			mem_info_obj = (struct mem_seg_info *)(psz_coff_buf +
+							       sizeof(u32));
+			for (i = 0; i < dload_segs; i++) {
+				rmm_segs[i].base = (mem_info_obj + i)->base;
+				rmm_segs[i].length = (mem_info_obj + i)->len;
+				rmm_segs[i].space = 0;
+				nldr_obj->seg_table[i] =
+				    (mem_info_obj + i)->type;
+				dev_dbg(bridge,
+					"(proc) DLL MEMSEGMENT: %d, "
+					"Base: 0x%x, Length: 0x%x\n", i,
+					rmm_segs[i].base, rmm_segs[i].length);
 			}
 		}
 	}
 	/* Create Remote memory manager */
 	if (DSP_SUCCEEDED(status))
-		status = RMM_create(&pNldr->rmm, rmmSegs, nSegs);
+		status = rmm_create(&nldr_obj->rmm, rmm_segs, dload_segs);
 
 	if (DSP_SUCCEEDED(status)) {
 		/* set the alloc, free, write functions for loader */
-		pNldr->dbllFxns.getAttrsFxn(pNldr->dbll, &saveAttrs);
-		newAttrs = saveAttrs;
-		newAttrs.alloc = (DBLL_AllocFxn) RemoteAlloc;
-		newAttrs.free = (DBLL_FreeFxn) RemoteFree;
-		newAttrs.symLookup = (DBLL_SymLookup) GetSymbolValue;
-		newAttrs.symHandle = pNldr;
-		newAttrs.write = (DBLL_WriteFxn) pAttrs->pfnWrite;
-		pNldr->ovlyFxn = pAttrs->pfnOvly;
-		pNldr->writeFxn = pAttrs->pfnWrite;
-		pNldr->dbllAttrs = newAttrs;
+		nldr_obj->ldr_fxns.get_attrs_fxn(nldr_obj->dbll, &save_attrs);
+		new_attrs = save_attrs;
+		new_attrs.alloc = (dbll_alloc_fxn) remote_alloc;
+		new_attrs.free = (dbll_free_fxn) remote_free;
+		new_attrs.sym_lookup = (dbll_sym_lookup) get_symbol_value;
+		new_attrs.sym_handle = nldr_obj;
+		new_attrs.write = (dbll_write_fxn) pattrs->pfn_write;
+		nldr_obj->ovly_fxn = pattrs->pfn_ovly;
+		nldr_obj->write_fxn = pattrs->pfn_write;
+		nldr_obj->ldr_attrs = new_attrs;
 	}
-	if (rmmSegs)
-		MEM_Free(rmmSegs);
+	kfree(rmm_segs);
 
-	if (pszCoffBuf)
-		MEM_Free(pszCoffBuf);
+	kfree(psz_coff_buf);
 
 	/* Get overlay nodes */
 	if (DSP_SUCCEEDED(status)) {
-		status = COD_GetBaseName(hCodMgr, szZLFile, COD_MAXPATHLENGTH);
+		status =
+		    cod_get_base_name(cod_mgr, sz_zl_file, COD_MAXPATHLENGTH);
 		/* lazy check */
-		DBC_Assert(DSP_SUCCEEDED(status));
+		DBC_ASSERT(DSP_SUCCEEDED(status));
 		/* First count number of overlay nodes */
-		status = DCD_GetObjects(pNldr->hDcdMgr, szZLFile, AddOvlyNode,
-					(void *) pNldr);
+		status =
+		    dcd_get_objects(nldr_obj->hdcd_mgr, sz_zl_file,
+				    add_ovly_node, (void *)nldr_obj);
 		/* Now build table of overlay nodes */
-		if (DSP_SUCCEEDED(status) && pNldr->nOvlyNodes > 0) {
+		if (DSP_SUCCEEDED(status) && nldr_obj->ovly_nodes > 0) {
 			/* Allocate table for overlay nodes */
-			pNldr->ovlyTable =
-			MEM_Calloc(sizeof(struct OvlyNode) * pNldr->nOvlyNodes,
-				  MEM_PAGED);
+			nldr_obj->ovly_table =
+			    mem_calloc(sizeof(struct ovly_node) *
+				       nldr_obj->ovly_nodes, MEM_PAGED);
 			/* Put overlay nodes in the table */
-			pNldr->nNode = 0;
-			status = DCD_GetObjects(pNldr->hDcdMgr, szZLFile,
-						AddOvlyNode,
-						(void *) pNldr);
+			nldr_obj->ovly_nid = 0;
+			status = dcd_get_objects(nldr_obj->hdcd_mgr, sz_zl_file,
+						 add_ovly_node,
+						 (void *)nldr_obj);
 		}
 	}
 	/* Do a fake reload of the base image to get overlay section info */
-	if (DSP_SUCCEEDED(status) && pNldr->nOvlyNodes > 0) {
-		saveAttrs.write = fakeOvlyWrite;
-		saveAttrs.logWrite = AddOvlyInfo;
-		saveAttrs.logWriteHandle = pNldr;
+	if (DSP_SUCCEEDED(status) && nldr_obj->ovly_nodes > 0) {
+		save_attrs.write = fake_ovly_write;
+		save_attrs.log_write = add_ovly_info;
+		save_attrs.log_write_handle = nldr_obj;
 		flags = DBLL_CODE | DBLL_DATA | DBLL_SYMB;
-		status = pNldr->dbllFxns.loadFxn(pNldr->baseLib, flags,
-						&saveAttrs, &ulEntry);
+		status = nldr_obj->ldr_fxns.load_fxn(nldr_obj->base_lib, flags,
+						     &save_attrs, &ul_entry);
 	}
 	if (DSP_SUCCEEDED(status)) {
-		*phNldr = (struct NLDR_OBJECT *) pNldr;
+		*phNldr = (struct nldr_object *)nldr_obj;
 	} else {
-		if (pNldr)
-			NLDR_Delete((struct NLDR_OBJECT *) pNldr);
+		if (nldr_obj)
+			nldr_delete((struct nldr_object *)nldr_obj);
 
 		*phNldr = NULL;
 	}
 	/* FIXME:Temp. Fix. Must be removed */
-	DBC_Ensure((DSP_SUCCEEDED(status) &&
-			 MEM_IsValidHandle(((struct NLDR_OBJECT *)*phNldr),
-					  NLDR_SIGNATURE))
-			|| (DSP_FAILED(status) && (*phNldr == NULL)));
+	DBC_ENSURE((DSP_SUCCEEDED(status) &&
+		    MEM_IS_VALID_HANDLE(((struct nldr_object *)*phNldr),
+					NLDR_SIGNATURE))
+		   || (DSP_FAILED(status) && (*phNldr == NULL)));
 	return status;
 }
 
 /*
- *  ======== NLDR_Delete ========
+ *  ======== nldr_delete ========
  */
-void NLDR_Delete(struct NLDR_OBJECT *hNldr)
+void nldr_delete(struct nldr_object *nldr_obj)
 {
-	struct OvlySect *pSect;
-	struct OvlySect *pNext;
+	struct ovly_sect *ovly_section;
+	struct ovly_sect *next;
 	u16 i;
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNldr, NLDR_SIGNATURE));
-	GT_1trace(NLDR_debugMask, GT_ENTER, "NLDR_Delete(0x%x)\n", hNldr);
-	hNldr->dbllFxns.exitFxn();
-	if (hNldr->rmm)
-		RMM_delete(hNldr->rmm);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(nldr_obj, NLDR_SIGNATURE));
+
+	nldr_obj->ldr_fxns.exit_fxn();
+	if (nldr_obj->rmm)
+		rmm_delete(nldr_obj->rmm);
 
-	if (hNldr->segTable)
-		MEM_Free(hNldr->segTable);
+	kfree(nldr_obj->seg_table);
 
-	if (hNldr->hDcdMgr)
-		DCD_DestroyManager(hNldr->hDcdMgr);
+	if (nldr_obj->hdcd_mgr)
+		dcd_destroy_manager(nldr_obj->hdcd_mgr);
 
 	/* Free overlay node information */
-	if (hNldr->ovlyTable) {
-		for (i = 0; i < hNldr->nOvlyNodes; i++) {
-			pSect = hNldr->ovlyTable[i].pCreateSects;
-			while (pSect) {
-				pNext = pSect->pNextSect;
-				MEM_Free(pSect);
-				pSect = pNext;
-			}
-			pSect = hNldr->ovlyTable[i].pDeleteSects;
-			while (pSect) {
-				pNext = pSect->pNextSect;
-				MEM_Free(pSect);
-				pSect = pNext;
-			}
-			pSect = hNldr->ovlyTable[i].pExecuteSects;
-			while (pSect) {
-				pNext = pSect->pNextSect;
-				MEM_Free(pSect);
-				pSect = pNext;
-			}
-			pSect = hNldr->ovlyTable[i].pOtherSects;
-			while (pSect) {
-				pNext = pSect->pNextSect;
-				MEM_Free(pSect);
-				pSect = pNext;
+	if (nldr_obj->ovly_table) {
+		for (i = 0; i < nldr_obj->ovly_nodes; i++) {
+			ovly_section =
+			    nldr_obj->ovly_table[i].create_sects_list;
+			while (ovly_section) {
+				next = ovly_section->next_sect;
+				kfree(ovly_section);
+				ovly_section = next;
+			}
+			ovly_section =
+			    nldr_obj->ovly_table[i].delete_sects_list;
+			while (ovly_section) {
+				next = ovly_section->next_sect;
+				kfree(ovly_section);
+				ovly_section = next;
+			}
+			ovly_section =
+			    nldr_obj->ovly_table[i].execute_sects_list;
+			while (ovly_section) {
+				next = ovly_section->next_sect;
+				kfree(ovly_section);
+				ovly_section = next;
+			}
+			ovly_section = nldr_obj->ovly_table[i].other_sects_list;
+			while (ovly_section) {
+				next = ovly_section->next_sect;
+				kfree(ovly_section);
+				ovly_section = next;
 			}
 		}
-		MEM_Free(hNldr->ovlyTable);
+		kfree(nldr_obj->ovly_table);
 	}
-	MEM_FreeObject(hNldr);
-	DBC_Ensure(!MEM_IsValidHandle(hNldr, NLDR_SIGNATURE));
+	MEM_FREE_OBJECT(nldr_obj);
+	DBC_ENSURE(!MEM_IS_VALID_HANDLE(nldr_obj, NLDR_SIGNATURE));
 }
 
 /*
- *  ======== NLDR_Exit ========
+ *  ======== nldr_exit ========
  *  Discontinue usage of NLDR module.
  */
-void NLDR_Exit(void)
+void nldr_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	GT_1trace(NLDR_debugMask, GT_5CLASS,
-		 "Entered NLDR_Exit, ref count:  0x%x\n", cRefs);
+	if (refs == 0)
+		rmm_exit();
 
-	if (cRefs == 0) {
-		RMM_exit();
-		NLDR_debugMask.flags = NULL;
-	}
-
-	DBC_Ensure(cRefs >= 0);
-}
-
-/*
- *  ======== NLDR_Free ========
- */
-void NLDR_Free(struct NLDR_NODEOBJECT *hNldrNode)
-{
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNldrNode, NLDR_NODESIGNATURE));
-
-	GT_1trace(NLDR_debugMask, GT_ENTER, "NLDR_Free(0x%x)\n", hNldrNode);
-
-	MEM_FreeObject(hNldrNode);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== NLDR_GetFxnAddr ========
+ *  ======== nldr_get_fxn_addr ========
  */
-DSP_STATUS NLDR_GetFxnAddr(struct NLDR_NODEOBJECT *hNldrNode, char *pstrFxn,
-			  u32 *pulAddr)
+dsp_status nldr_get_fxn_addr(struct nldr_nodeobject *nldr_node_obj,
+			     char *pstrFxn, u32 * pulAddr)
 {
-	struct DBLL_Symbol *pSym;
-	struct NLDR_OBJECT *hNldr;
-	DSP_STATUS status = DSP_SOK;
+	struct dbll_sym_val *dbll_sym;
+	struct nldr_object *nldr_obj;
+	dsp_status status = DSP_SOK;
 	bool status1 = false;
 	s32 i = 0;
-	struct LibNode root = { NULL, 0, NULL };
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNldrNode, NLDR_NODESIGNATURE));
-	DBC_Require(pulAddr != NULL);
-	DBC_Require(pstrFxn != NULL);
-	GT_3trace(NLDR_debugMask, GT_ENTER, "NLDR_GetFxnAddr(0x%x, %s, 0x%x)\n",
-		 hNldrNode, pstrFxn, pulAddr);
-
-	hNldr = hNldrNode->pNldr;
-	/* Called from NODE_Create(), NODE_Delete(), or NODE_Run(). */
-	if (hNldrNode->fDynamic && *hNldrNode->pfPhaseSplit) {
-		switch (hNldrNode->phase) {
+	struct lib_node root = { NULL, 0, NULL };
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(nldr_node_obj, NLDR_NODESIGNATURE));
+	DBC_REQUIRE(pulAddr != NULL);
+	DBC_REQUIRE(pstrFxn != NULL);
+
+	nldr_obj = nldr_node_obj->nldr_obj;
+	/* Called from node_create(), node_delete(), or node_run(). */
+	if (nldr_node_obj->dynamic && *nldr_node_obj->pf_phase_split) {
+		switch (nldr_node_obj->phase) {
 		case NLDR_CREATE:
-			root = hNldrNode->createLib;
+			root = nldr_node_obj->create_lib;
 			break;
 		case NLDR_EXECUTE:
-			root = hNldrNode->executeLib;
+			root = nldr_node_obj->execute_lib;
 			break;
 		case NLDR_DELETE:
-			root = hNldrNode->deleteLib;
+			root = nldr_node_obj->delete_lib;
 			break;
 		default:
-			DBC_Assert(false);
+			DBC_ASSERT(false);
 			break;
 		}
 	} else {
 		/* for Overlay nodes or non-split Dynamic nodes */
-		root = hNldrNode->root;
+		root = nldr_node_obj->root;
 	}
-	status1 = hNldr->dbllFxns.getCAddrFxn(root.lib, pstrFxn, &pSym);
+	status1 =
+	    nldr_obj->ldr_fxns.get_c_addr_fxn(root.lib, pstrFxn, &dbll_sym);
 	if (!status1)
-		status1 = hNldr->dbllFxns.getAddrFxn(root.lib, pstrFxn, &pSym);
+		status1 =
+		    nldr_obj->ldr_fxns.get_addr_fxn(root.lib, pstrFxn,
+						    &dbll_sym);
 
 	/* If symbol not found, check dependent libraries */
 	if (!status1) {
-		for (i = 0; i < root.nDepLibs; i++) {
-			status1 = hNldr->dbllFxns.getAddrFxn(root.pDepLibs[i].
-					lib, pstrFxn, &pSym);
+		for (i = 0; i < root.dep_libs; i++) {
+			status1 =
+			    nldr_obj->ldr_fxns.get_addr_fxn(root.dep_libs_tree
+							    [i].lib, pstrFxn,
+							    &dbll_sym);
 			if (!status1) {
-				status1 = hNldr->dbllFxns.getCAddrFxn(root.
-					pDepLibs[i].lib, pstrFxn, &pSym);
+				status1 =
+				    nldr_obj->ldr_fxns.
+				    get_c_addr_fxn(root.dep_libs_tree[i].lib,
+						   pstrFxn, &dbll_sym);
 			}
 			if (status1) {
 				/* Symbol found */
@@ -826,13 +756,16 @@
 	}
 	/* Check persistent libraries */
 	if (!status1) {
-		for (i = 0; i < hNldrNode->nPersLib; i++) {
-			status1 = hNldr->dbllFxns.getAddrFxn(hNldrNode->
-					persLib[i].lib,	pstrFxn, &pSym);
+		for (i = 0; i < nldr_node_obj->pers_libs; i++) {
+			status1 =
+			    nldr_obj->ldr_fxns.
+			    get_addr_fxn(nldr_node_obj->pers_lib_table[i].lib,
+					 pstrFxn, &dbll_sym);
 			if (!status1) {
 				status1 =
-				    hNldr->dbllFxns.getCAddrFxn(hNldrNode->
-					persLib[i].lib,	pstrFxn, &pSym);
+				    nldr_obj->ldr_fxns.
+				    get_c_addr_fxn(nldr_node_obj->pers_lib_table
+						   [i].lib, pstrFxn, &dbll_sym);
 			}
 			if (status1) {
 				/* Symbol found */
@@ -841,126 +774,111 @@
 		}
 	}
 
-	if (status1) {
-		*pulAddr = pSym->value;
-	} else {
-		GT_1trace(NLDR_debugMask, GT_6CLASS,
-			 "NLDR_GetFxnAddr: Symbol not found: "
-			 "%s\n", pstrFxn);
+	if (status1)
+		*pulAddr = dbll_sym->value;
+	else
 		status = DSP_ESYMBOL;
-	}
 
 	return status;
 }
 
 /*
- *  ======== NLDR_GetRmmManager ========
+ *  ======== nldr_get_rmm_manager ========
  *  Given a NLDR object, retrieve RMM Manager Handle
  */
-DSP_STATUS NLDR_GetRmmManager(struct NLDR_OBJECT *hNldrObject,
-			     OUT struct RMM_TargetObj **phRmmMgr)
+dsp_status nldr_get_rmm_manager(struct nldr_object *hNldrObject,
+				OUT struct rmm_target_obj **phRmmMgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct NLDR_OBJECT *pNldrObject = hNldrObject;
-	DBC_Require(phRmmMgr != NULL);
-	GT_2trace(NLDR_debugMask, GT_ENTER, "NLDR_GetRmmManager(0x%x, 0x%x)\n",
-		 hNldrObject, phRmmMgr);
-	if (MEM_IsValidHandle(hNldrObject, NLDR_SIGNATURE)) {
-		*phRmmMgr = pNldrObject->rmm;
+	dsp_status status = DSP_SOK;
+	struct nldr_object *nldr_obj = hNldrObject;
+	DBC_REQUIRE(phRmmMgr != NULL);
+
+	if (MEM_IS_VALID_HANDLE(hNldrObject, NLDR_SIGNATURE)) {
+		*phRmmMgr = nldr_obj->rmm;
 	} else {
 		*phRmmMgr = NULL;
 		status = DSP_EHANDLE;
-		GT_0trace(NLDR_debugMask, GT_7CLASS,
-			 "NLDR_GetRmmManager:Invalid handle");
 	}
 
-	GT_2trace(NLDR_debugMask, GT_ENTER, "Exit NLDR_GetRmmManager: status "
-		 "0x%x\n\tphRmmMgr:  0x%x\n", status, *phRmmMgr);
-
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phRmmMgr != NULL) &&
-		  (*phRmmMgr == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phRmmMgr != NULL) &&
+					     (*phRmmMgr == NULL)));
 
 	return status;
 }
 
 /*
- *  ======== NLDR_Init ========
+ *  ======== nldr_init ========
  *  Initialize the NLDR module.
  */
-bool NLDR_Init(void)
+bool nldr_init(void)
 {
-	DBC_Require(cRefs >= 0);
+	DBC_REQUIRE(refs >= 0);
 
-	if (cRefs == 0) {
-		DBC_Assert(!NLDR_debugMask.flags);
-		GT_create(&NLDR_debugMask, "NL");	/* "NL" for NLdr */
+	if (refs == 0)
+		rmm_init();
 
-		RMM_init();
-	}
+	refs++;
 
-	cRefs++;
-
-	GT_1trace(NLDR_debugMask, GT_5CLASS, "NLDR_Init(), ref count: 0x%x\n",
-		 cRefs);
-
-	DBC_Ensure(cRefs > 0);
+	DBC_ENSURE(refs > 0);
 	return true;
 }
 
 /*
- *  ======== NLDR_Load ========
+ *  ======== nldr_load ========
  */
-DSP_STATUS NLDR_Load(struct NLDR_NODEOBJECT *hNldrNode, enum NLDR_PHASE phase)
+dsp_status nldr_load(struct nldr_nodeobject *nldr_node_obj,
+		     enum nldr_phase phase)
 {
-	struct NLDR_OBJECT *hNldr;
-	struct DSP_UUID libUUID;
-	DSP_STATUS status = DSP_SOK;
+	struct nldr_object *nldr_obj;
+	struct dsp_uuid lib_uuid;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNldrNode, NLDR_NODESIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(nldr_node_obj, NLDR_NODESIGNATURE));
 
-	hNldr = hNldrNode->pNldr;
+	nldr_obj = nldr_node_obj->nldr_obj;
 
-	GT_2trace(NLDR_debugMask, GT_ENTER, "NLDR_Load(0x%x, 0x%x)\n",
-		 hNldrNode, phase);
+	if (nldr_node_obj->dynamic) {
+		nldr_node_obj->phase = phase;
 
-	if (hNldrNode->fDynamic) {
-		hNldrNode->phase = phase;
-
-		libUUID = hNldrNode->uuid;
+		lib_uuid = nldr_node_obj->uuid;
 
 		/* At this point, we may not know if node is split into
 		 * different libraries. So we'll go ahead and load the
 		 * library, and then save the pointer to the appropriate
 		 * location after we know. */
 
-		status = LoadLib(hNldrNode, &hNldrNode->root, libUUID, false,
-				hNldrNode->libPath, phase, 0);
+		status =
+		    load_lib(nldr_node_obj, &nldr_node_obj->root, lib_uuid,
+			     false, nldr_node_obj->lib_path, phase, 0);
 
 		if (DSP_SUCCEEDED(status)) {
-			if (*hNldrNode->pfPhaseSplit) {
+			if (*nldr_node_obj->pf_phase_split) {
 				switch (phase) {
 				case NLDR_CREATE:
-					hNldrNode->createLib = hNldrNode->root;
+					nldr_node_obj->create_lib =
+					    nldr_node_obj->root;
 					break;
 
 				case NLDR_EXECUTE:
-					hNldrNode->executeLib = hNldrNode->root;
+					nldr_node_obj->execute_lib =
+					    nldr_node_obj->root;
 					break;
 
 				case NLDR_DELETE:
-					hNldrNode->deleteLib = hNldrNode->root;
+					nldr_node_obj->delete_lib =
+					    nldr_node_obj->root;
 					break;
 
 				default:
-					DBC_Assert(false);
+					DBC_ASSERT(false);
 					break;
 				}
 			}
 		}
 	} else {
-		if (hNldrNode->fOverlay)
-			status = LoadOvly(hNldrNode, phase);
+		if (nldr_node_obj->overlay)
+			status = load_ovly(nldr_node_obj, phase);
 
 	}
 
@@ -968,50 +886,53 @@
 }
 
 /*
- *  ======== NLDR_Unload ========
+ *  ======== nldr_unload ========
  */
-DSP_STATUS NLDR_Unload(struct NLDR_NODEOBJECT *hNldrNode, enum NLDR_PHASE phase)
+dsp_status nldr_unload(struct nldr_nodeobject *nldr_node_obj,
+		       enum nldr_phase phase)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct LibNode *pRootLib = NULL;
+	dsp_status status = DSP_SOK;
+	struct lib_node *root_lib = NULL;
 	s32 i = 0;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNldrNode, NLDR_NODESIGNATURE));
-	GT_2trace(NLDR_debugMask, GT_ENTER, "NLDR_Unload(0x%x, 0x%x)\n",
-		 hNldrNode, phase);
-	if (hNldrNode != NULL) {
-		if (hNldrNode->fDynamic) {
-			if (*hNldrNode->pfPhaseSplit) {
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(nldr_node_obj, NLDR_NODESIGNATURE));
+
+	if (nldr_node_obj != NULL) {
+		if (nldr_node_obj->dynamic) {
+			if (*nldr_node_obj->pf_phase_split) {
 				switch (phase) {
 				case NLDR_CREATE:
-					pRootLib = &hNldrNode->createLib;
+					root_lib = &nldr_node_obj->create_lib;
 					break;
 				case NLDR_EXECUTE:
-					pRootLib = &hNldrNode->executeLib;
+					root_lib = &nldr_node_obj->execute_lib;
 					break;
 				case NLDR_DELETE:
-					pRootLib = &hNldrNode->deleteLib;
+					root_lib = &nldr_node_obj->delete_lib;
 					/* Unload persistent libraries */
-					for (i = 0; i < hNldrNode->nPersLib;
-					    i++) {
-						UnloadLib(hNldrNode,
-							&hNldrNode->persLib[i]);
+					for (i = 0;
+					     i < nldr_node_obj->pers_libs;
+					     i++) {
+						unload_lib(nldr_node_obj,
+							   &nldr_node_obj->
+							   pers_lib_table[i]);
 					}
-					hNldrNode->nPersLib = 0;
+					nldr_node_obj->pers_libs = 0;
 					break;
 				default:
-					DBC_Assert(false);
+					DBC_ASSERT(false);
 					break;
 				}
 			} else {
 				/* Unload main library */
-				pRootLib = &hNldrNode->root;
+				root_lib = &nldr_node_obj->root;
 			}
-			UnloadLib(hNldrNode, pRootLib);
+			if (root_lib)
+				unload_lib(nldr_node_obj, root_lib);
 		} else {
-			if (hNldrNode->fOverlay)
-				UnloadOvly(hNldrNode, phase);
+			if (nldr_node_obj->overlay)
+				unload_ovly(nldr_node_obj, phase);
 
 		}
 	}
@@ -1019,72 +940,78 @@
 }
 
 /*
- *  ======== AddOvlyInfo ========
+ *  ======== add_ovly_info ========
  */
-static DSP_STATUS AddOvlyInfo(void *handle, struct DBLL_SectInfo *sectInfo,
-			     u32 addr, u32 nBytes)
+static dsp_status add_ovly_info(void *handle, struct dbll_sect_info *sect_info,
+				u32 addr, u32 bytes)
 {
-	char *pNodeName;
-	char *pSectName = (char *)sectInfo->name;
-	bool fExists = false;
+	char *node_name;
+	char *sect_name = (char *)sect_info->name;
+	bool sect_exists = false;
 	char seps = ':';
 	char *pch;
 	u16 i;
-	struct NLDR_OBJECT *hNldr = (struct NLDR_OBJECT *)handle;
-	DSP_STATUS status = DSP_SOK;
+	struct nldr_object *nldr_obj = (struct nldr_object *)handle;
+	dsp_status status = DSP_SOK;
 
 	/* Is this an overlay section (load address != run address)? */
-	if (sectInfo->loadAddr == sectInfo->runAddr)
+	if (sect_info->sect_load_addr == sect_info->sect_run_addr)
 		goto func_end;
 
 	/* Find the node it belongs to */
-	for (i = 0; i < hNldr->nOvlyNodes; i++) {
-		pNodeName = hNldr->ovlyTable[i].pNodeName;
-               DBC_Require(pNodeName);
-               if (strncmp(pNodeName, pSectName + 1,
-                               strlen(pNodeName)) == 0) {
-				/* Found the node */
-				break;
+	for (i = 0; i < nldr_obj->ovly_nodes; i++) {
+		node_name = nldr_obj->ovly_table[i].node_name;
+		DBC_REQUIRE(node_name);
+		if (strncmp(node_name, sect_name + 1, strlen(node_name)) == 0) {
+			/* Found the node */
+			break;
 		}
 	}
-	if (!(i < hNldr->nOvlyNodes))
+	if (!(i < nldr_obj->ovly_nodes))
 		goto func_end;
 
 	/* Determine which phase this section belongs to */
-	for (pch = pSectName + 1; *pch && *pch != seps; pch++)
+	for (pch = sect_name + 1; *pch && *pch != seps; pch++)
 		;;
 
 	if (*pch) {
-		pch++;	/* Skip over the ':' */
-               if (strncmp(pch, PCREATE, strlen(PCREATE)) == 0) {
-			status = AddOvlySect(hNldr, &hNldr->ovlyTable[i].
-				pCreateSects, sectInfo, &fExists, addr, nBytes);
-			if (DSP_SUCCEEDED(status) && !fExists)
-				hNldr->ovlyTable[i].nCreateSects++;
-
-		} else
-               if (strncmp(pch, PDELETE, strlen(PDELETE)) == 0) {
-			status = AddOvlySect(hNldr, &hNldr->ovlyTable[i].
-					    pDeleteSects, sectInfo, &fExists,
-					    addr, nBytes);
-			if (DSP_SUCCEEDED(status) && !fExists)
-				hNldr->ovlyTable[i].nDeleteSects++;
-
-		} else
-               if (strncmp(pch, PEXECUTE, strlen(PEXECUTE)) == 0) {
-			status = AddOvlySect(hNldr, &hNldr->ovlyTable[i].
-					    pExecuteSects, sectInfo, &fExists,
-					    addr, nBytes);
-			if (DSP_SUCCEEDED(status) && !fExists)
-				hNldr->ovlyTable[i].nExecuteSects++;
+		pch++;		/* Skip over the ':' */
+		if (strncmp(pch, PCREATE, strlen(PCREATE)) == 0) {
+			status =
+			    add_ovly_sect(nldr_obj,
+					  &nldr_obj->
+					  ovly_table[i].create_sects_list,
+					  sect_info, &sect_exists, addr, bytes);
+			if (DSP_SUCCEEDED(status) && !sect_exists)
+				nldr_obj->ovly_table[i].create_sects++;
+
+		} else if (strncmp(pch, PDELETE, strlen(PDELETE)) == 0) {
+			status =
+			    add_ovly_sect(nldr_obj,
+					  &nldr_obj->
+					  ovly_table[i].delete_sects_list,
+					  sect_info, &sect_exists, addr, bytes);
+			if (DSP_SUCCEEDED(status) && !sect_exists)
+				nldr_obj->ovly_table[i].delete_sects++;
+
+		} else if (strncmp(pch, PEXECUTE, strlen(PEXECUTE)) == 0) {
+			status =
+			    add_ovly_sect(nldr_obj,
+					  &nldr_obj->
+					  ovly_table[i].execute_sects_list,
+					  sect_info, &sect_exists, addr, bytes);
+			if (DSP_SUCCEEDED(status) && !sect_exists)
+				nldr_obj->ovly_table[i].execute_sects++;
 
 		} else {
 			/* Put in "other" sectins */
-			status = AddOvlySect(hNldr, &hNldr->ovlyTable[i].
-					    pOtherSects, sectInfo, &fExists,
-					    addr, nBytes);
-			if (DSP_SUCCEEDED(status) && !fExists)
-				hNldr->ovlyTable[i].nOtherSects++;
+			status =
+			    add_ovly_sect(nldr_obj,
+					  &nldr_obj->
+					  ovly_table[i].other_sects_list,
+					  sect_info, &sect_exists, addr, bytes);
+			if (DSP_SUCCEEDED(status) && !sect_exists)
+				nldr_obj->ovly_table[i].other_sects++;
 
 		}
 	}
@@ -1093,113 +1020,114 @@
 }
 
 /*
- *  ======== AddOvlyNode =========
- *  Callback function passed to DCD_GetObjects.
+ *  ======== add_ovly_node =========
+ *  Callback function passed to dcd_get_objects.
  */
-static DSP_STATUS AddOvlyNode(struct DSP_UUID *pUuid,
-			     enum DSP_DCDOBJTYPE objType,
-			     IN void *handle)
-{
-	struct NLDR_OBJECT *hNldr = (struct NLDR_OBJECT *)handle;
-	char *pNodeName = NULL;
-	char *pBuf = NULL;
-	u32 uLen;
-	struct DCD_GENERICOBJ objDef;
-	DSP_STATUS status = DSP_SOK;
+static dsp_status add_ovly_node(struct dsp_uuid *uuid_obj,
+				enum dsp_dcdobjtype obj_type, IN void *handle)
+{
+	struct nldr_object *nldr_obj = (struct nldr_object *)handle;
+	char *node_name = NULL;
+	char *pbuf = NULL;
+	u32 len;
+	struct dcd_genericobj obj_def;
+	dsp_status status = DSP_SOK;
 
-	if (objType != DSP_DCDNODETYPE)
+	if (obj_type != DSP_DCDNODETYPE)
 		goto func_end;
 
-	status = DCD_GetObjectDef(hNldr->hDcdMgr, pUuid, objType, &objDef);
+	status =
+	    dcd_get_object_def(nldr_obj->hdcd_mgr, uuid_obj, obj_type,
+			       &obj_def);
 	if (DSP_FAILED(status))
 		goto func_end;
 
 	/* If overlay node, add to the list */
-	if (objDef.objData.nodeObj.usLoadType == NLDR_OVLYLOAD) {
-		if (hNldr->ovlyTable == NULL) {
-			hNldr->nOvlyNodes++;
+	if (obj_def.obj_data.node_obj.us_load_type == NLDR_OVLYLOAD) {
+		if (nldr_obj->ovly_table == NULL) {
+			nldr_obj->ovly_nodes++;
 		} else {
 			/* Add node to table */
-			hNldr->ovlyTable[hNldr->nNode].uuid = *pUuid;
-                       DBC_Require(objDef.objData.nodeObj.ndbProps.acName);
-                       uLen = strlen(objDef.objData.nodeObj.ndbProps.acName);
-			pNodeName = objDef.objData.nodeObj.ndbProps.acName;
-			pBuf = MEM_Calloc(uLen + 1, MEM_PAGED);
-			if (pBuf == NULL) {
+			nldr_obj->ovly_table[nldr_obj->ovly_nid].uuid =
+			    *uuid_obj;
+			DBC_REQUIRE(obj_def.obj_data.node_obj.ndb_props.
+				    ac_name);
+			len =
+			    strlen(obj_def.obj_data.node_obj.ndb_props.ac_name);
+			node_name = obj_def.obj_data.node_obj.ndb_props.ac_name;
+			pbuf = mem_calloc(len + 1, MEM_PAGED);
+			if (pbuf == NULL) {
 				status = DSP_EMEMORY;
 			} else {
-                               strncpy(pBuf, pNodeName, uLen);
-				hNldr->ovlyTable[hNldr->nNode].pNodeName = pBuf;
-				hNldr->nNode++;
+				strncpy(pbuf, node_name, len);
+				nldr_obj->ovly_table[nldr_obj->ovly_nid].
+				    node_name = pbuf;
+				nldr_obj->ovly_nid++;
 			}
 		}
 	}
-	/* These were allocated in DCD_GetObjectDef */
-	if (objDef.objData.nodeObj.pstrCreatePhaseFxn)
-		MEM_Free(objDef.objData.nodeObj.pstrCreatePhaseFxn);
+	/* These were allocated in dcd_get_object_def */
+	kfree(obj_def.obj_data.node_obj.pstr_create_phase_fxn);
 
-	if (objDef.objData.nodeObj.pstrExecutePhaseFxn)
-		MEM_Free(objDef.objData.nodeObj.pstrExecutePhaseFxn);
+	kfree(obj_def.obj_data.node_obj.pstr_execute_phase_fxn);
 
-	if (objDef.objData.nodeObj.pstrDeletePhaseFxn)
-		MEM_Free(objDef.objData.nodeObj.pstrDeletePhaseFxn);
+	kfree(obj_def.obj_data.node_obj.pstr_delete_phase_fxn);
 
-	if (objDef.objData.nodeObj.pstrIAlgName)
-		MEM_Free(objDef.objData.nodeObj.pstrIAlgName);
+	kfree(obj_def.obj_data.node_obj.pstr_i_alg_name);
 
 func_end:
 	return status;
 }
 
 /*
- *  ======== AddOvlySect ========
+ *  ======== add_ovly_sect ========
  */
-static DSP_STATUS AddOvlySect(struct NLDR_OBJECT *hNldr,
-			      struct OvlySect **pList,
-			      struct DBLL_SectInfo *pSectInfo, bool *pExists,
-			      u32 addr, u32 nBytes)
-{
-	struct OvlySect *pNewSect = NULL;
-	struct OvlySect *pLastSect;
-	struct OvlySect *pSect;
-	DSP_STATUS status = DSP_SOK;
+static dsp_status add_ovly_sect(struct nldr_object *nldr_obj,
+				struct ovly_sect **pList,
+				struct dbll_sect_info *pSectInfo,
+				bool *pExists, u32 addr, u32 bytes)
+{
+	struct ovly_sect *new_sect = NULL;
+	struct ovly_sect *last_sect;
+	struct ovly_sect *ovly_section;
+	dsp_status status = DSP_SOK;
 
-	pSect = pLastSect = *pList;
+	ovly_section = last_sect = *pList;
 	*pExists = false;
-	while (pSect) {
+	while (ovly_section) {
 		/*
 		 *  Make sure section has not already been added. Multiple
 		 *  'write' calls may be made to load the section.
 		 */
-		if (pSect->loadAddr == addr) {
+		if (ovly_section->sect_load_addr == addr) {
 			/* Already added */
 			*pExists = true;
 			break;
 		}
-		pLastSect = pSect;
-		pSect = pSect->pNextSect;
+		last_sect = ovly_section;
+		ovly_section = ovly_section->next_sect;
 	}
 
-	if (!pSect) {
+	if (!ovly_section) {
 		/* New section */
-		pNewSect = MEM_Calloc(sizeof(struct OvlySect), MEM_PAGED);
-		if (pNewSect == NULL) {
+		new_sect = mem_calloc(sizeof(struct ovly_sect), MEM_PAGED);
+		if (new_sect == NULL) {
 			status = DSP_EMEMORY;
 		} else {
-			pNewSect->loadAddr = addr;
-			pNewSect->runAddr = pSectInfo->runAddr +
-					    (addr - pSectInfo->loadAddr);
-			pNewSect->size = nBytes;
-			pNewSect->page = pSectInfo->type;
+			new_sect->sect_load_addr = addr;
+			new_sect->sect_run_addr = pSectInfo->sect_run_addr +
+			    (addr - pSectInfo->sect_load_addr);
+			new_sect->size = bytes;
+			new_sect->page = pSectInfo->type;
 		}
 
 		/* Add to the list */
 		if (DSP_SUCCEEDED(status)) {
 			if (*pList == NULL) {
 				/* First in the list */
-				*pList = pNewSect;
+				*pList = new_sect;
 			} else {
-				pLastSect->pNextSect = pNewSect;
+				last_sect->next_sect = new_sect;
 			}
 		}
 	}
@@ -1208,54 +1136,58 @@
 }
 
 /*
- *  ======== fakeOvlyWrite ========
+ *  ======== fake_ovly_write ========
  */
-static s32 fakeOvlyWrite(void *handle, u32 dspAddr, void *buf, u32 nBytes,
-			s32 mtype)
+static s32 fake_ovly_write(void *handle, u32 dspAddr, void *buf, u32 bytes,
+			   s32 mtype)
 {
-	return (s32)nBytes;
+	return (s32) bytes;
 }
 
 /*
- *  ======== FreeSects ========
+ *  ======== free_sects ========
  */
-static void FreeSects(struct NLDR_OBJECT *hNldr, struct OvlySect *pPhaseSects,
-		     u16 nAlloc)
+static void free_sects(struct nldr_object *nldr_obj,
+		       struct ovly_sect *phase_sects, u16 alloc_num)
 {
-	struct OvlySect *pSect = pPhaseSects;
+	struct ovly_sect *ovly_section = phase_sects;
 	u16 i = 0;
-	bool fRet;
+	bool ret;
 
-	while (pSect && i < nAlloc) {
+	while (ovly_section && i < alloc_num) {
 		/* 'Deallocate' */
 		/* segid - page not supported yet */
 		/* Reserved memory */
-		fRet = RMM_free(hNldr->rmm, 0, pSect->runAddr, pSect->size,
-				true);
-		DBC_Assert(fRet);
-		pSect = pSect->pNextSect;
+		ret =
+		    rmm_free(nldr_obj->rmm, 0, ovly_section->sect_run_addr,
+			     ovly_section->size, true);
+		DBC_ASSERT(ret);
+		ovly_section = ovly_section->next_sect;
 		i++;
 	}
 }
 
 /*
- *  ======== GetSymbolValue ========
+ *  ======== get_symbol_value ========
  *  Find symbol in library's base image.  If not there, check dependent
  *  libraries.
  */
-static bool GetSymbolValue(void *handle, void *pArg, void *rmmHandle,
-			  char *name, struct DBLL_Symbol **sym)
+static bool get_symbol_value(void *handle, void *parg, void *rmm_handle,
+			     char *name, struct dbll_sym_val **sym)
 {
-	struct NLDR_OBJECT *hNldr = (struct NLDR_OBJECT *)handle;
-	struct NLDR_NODEOBJECT *hNldrNode = (struct NLDR_NODEOBJECT *)rmmHandle;
-	struct LibNode *root = (struct LibNode *)pArg;
+	struct nldr_object *nldr_obj = (struct nldr_object *)handle;
+	struct nldr_nodeobject *nldr_node_obj =
+	    (struct nldr_nodeobject *)rmm_handle;
+	struct lib_node *root = (struct lib_node *)parg;
 	u16 i;
 	bool status = false;
 
 	/* check the base image */
-	status = hNldr->dbllFxns.getAddrFxn(hNldr->baseLib, name, sym);
+	status = nldr_obj->ldr_fxns.get_addr_fxn(nldr_obj->base_lib, name, sym);
 	if (!status)
-		status = hNldr->dbllFxns.getCAddrFxn(hNldr->baseLib, name, sym);
+		status =
+		    nldr_obj->ldr_fxns.get_c_addr_fxn(nldr_obj->base_lib, name,
+						      sym);
 
 	/*
 	 *  Check in root lib itself. If the library consists of
@@ -1263,10 +1195,11 @@
 	 *  library may need to be resolved.
 	 */
 	if (!status) {
-		status = hNldr->dbllFxns.getAddrFxn(root->lib, name, sym);
+		status = nldr_obj->ldr_fxns.get_addr_fxn(root->lib, name, sym);
 		if (!status) {
 			status =
-			    hNldr->dbllFxns.getCAddrFxn(root->lib, name, sym);
+			    nldr_obj->ldr_fxns.get_c_addr_fxn(root->lib, name,
+							      sym);
 		}
 	}
 
@@ -1275,12 +1208,15 @@
 	 *  libraries' dependents.
 	 */
 	if (!status) {
-		for (i = 0; i < root->nDepLibs; i++) {
-			status = hNldr->dbllFxns.getAddrFxn(root->pDepLibs[i].
-							   lib, name, sym);
+		for (i = 0; i < root->dep_libs; i++) {
+			status =
+			    nldr_obj->ldr_fxns.get_addr_fxn(root->dep_libs_tree
+							    [i].lib, name, sym);
 			if (!status) {
-				status = hNldr->dbllFxns.getCAddrFxn(root->
-					 pDepLibs[i].lib, name, sym);
+				status =
+				    nldr_obj->ldr_fxns.
+				    get_c_addr_fxn(root->dep_libs_tree[i].lib,
+						   name, sym);
 			}
 			if (status) {
 				/* Symbol found */
@@ -1292,12 +1228,15 @@
 	 * Check in persistent libraries
 	 */
 	if (!status) {
-		for (i = 0; i < hNldrNode->nPersLib; i++) {
-			status = hNldr->dbllFxns.getAddrFxn(hNldrNode->
-				 persLib[i].lib, name, sym);
+		for (i = 0; i < nldr_node_obj->pers_libs; i++) {
+			status =
+			    nldr_obj->ldr_fxns.
+			    get_addr_fxn(nldr_node_obj->pers_lib_table[i].lib,
+					 name, sym);
 			if (!status) {
-				status = hNldr->dbllFxns.getCAddrFxn
-					(hNldrNode->persLib[i].lib, name, sym);
+				status = nldr_obj->ldr_fxns.get_c_addr_fxn
+				    (nldr_node_obj->pers_lib_table[i].lib, name,
+				     sym);
 			}
 			if (status) {
 				/* Symbol found */
@@ -1310,76 +1249,82 @@
 }
 
 /*
- *  ======== LoadLib ========
+ *  ======== load_lib ========
  *  Recursively load library and all its dependent libraries. The library
  *  we're loading is specified by a uuid.
  */
-static DSP_STATUS LoadLib(struct NLDR_NODEOBJECT *hNldrNode,
-			 struct LibNode *root, struct DSP_UUID uuid,
-			 bool rootPersistent, struct DBLL_LibraryObj **libPath,
-			 enum NLDR_PHASE phase, u16 depth)
-{
-	struct NLDR_OBJECT *hNldr = hNldrNode->pNldr;
-	u16 nLibs = 0;	/* Number of dependent libraries */
-	u16 nPLibs = 0;	/* Number of persistent libraries */
-	u16 nLoaded = 0;	/* Number of dep. libraries loaded */
+static dsp_status load_lib(struct nldr_nodeobject *nldr_node_obj,
+			   struct lib_node *root, struct dsp_uuid uuid,
+			   bool rootPersistent,
+			   struct dbll_library_obj **lib_path,
+			   enum nldr_phase phase, u16 depth)
+{
+	struct nldr_object *nldr_obj = nldr_node_obj->nldr_obj;
+	u16 nd_libs = 0;	/* Number of dependent libraries */
+	u16 np_libs = 0;	/* Number of persistent libraries */
+	u16 nd_libs_loaded = 0;	/* Number of dep. libraries loaded */
 	u16 i;
 	u32 entry;
-	u32 dwBufSize = NLDR_MAXPATHLENGTH;
-	DBLL_Flags flags = DBLL_SYMB | DBLL_CODE | DBLL_DATA | DBLL_DYNAMIC;
-	struct DBLL_Attrs newAttrs;
-	char *pszFileName = NULL;
-	struct DSP_UUID *depLibUUIDs = NULL;
-	bool *persistentDepLibs = NULL;
-	DSP_STATUS status = DSP_SOK;
-	bool fStatus = false;
-	struct LibNode *pDepLib;
+	u32 dw_buf_size = NLDR_MAXPATHLENGTH;
+	dbll_flags flags = DBLL_SYMB | DBLL_CODE | DBLL_DATA | DBLL_DYNAMIC;
+	struct dbll_attrs new_attrs;
+	char *psz_file_name = NULL;
+	struct dsp_uuid *dep_lib_uui_ds = NULL;
+	bool *persistent_dep_libs = NULL;
+	dsp_status status = DSP_SOK;
+	bool lib_status = false;
+	struct lib_node *dep_lib;
 
 	if (depth > MAXDEPTH) {
 		/* Error */
-		DBC_Assert(false);
+		DBC_ASSERT(false);
 	}
 	root->lib = NULL;
 	/* Allocate a buffer for library file name of size DBL_MAXPATHLENGTH */
-	pszFileName = MEM_Calloc(DBLL_MAXPATHLENGTH, MEM_PAGED);
-	if (pszFileName == NULL)
+	psz_file_name = mem_calloc(DBLL_MAXPATHLENGTH, MEM_PAGED);
+	if (psz_file_name == NULL)
 		status = DSP_EMEMORY;
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Get the name of the library */
 		if (depth == 0) {
-			status = DCD_GetLibraryName(hNldrNode->pNldr->hDcdMgr,
-				&uuid, pszFileName, &dwBufSize, phase,
-				hNldrNode->pfPhaseSplit);
+			status =
+			    dcd_get_library_name(nldr_node_obj->nldr_obj->
+						 hdcd_mgr, &uuid, psz_file_name,
+						 &dw_buf_size, phase,
+						 nldr_node_obj->pf_phase_split);
 		} else {
 			/* Dependent libraries are registered with a phase */
-			status = DCD_GetLibraryName(hNldrNode->pNldr->hDcdMgr,
-				&uuid, pszFileName, &dwBufSize, NLDR_NOPHASE,
-				NULL);
+			status =
+			    dcd_get_library_name(nldr_node_obj->nldr_obj->
+						 hdcd_mgr, &uuid, psz_file_name,
+						 &dw_buf_size, NLDR_NOPHASE,
+						 NULL);
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Open the library, don't load symbols */
-		status = hNldr->dbllFxns.openFxn(hNldr->dbll, pszFileName,
-			 DBLL_NOLOAD, &root->lib);
+		status =
+		    nldr_obj->ldr_fxns.open_fxn(nldr_obj->dbll, psz_file_name,
+						DBLL_NOLOAD, &root->lib);
 	}
 	/* Done with file name */
-	if (pszFileName)
-		MEM_Free(pszFileName);
+	kfree(psz_file_name);
 
 	/* Check to see if library not already loaded */
 	if (DSP_SUCCEEDED(status) && rootPersistent) {
-		fStatus = findInPersistentLibArray(hNldrNode, root->lib);
+		lib_status =
+		    find_in_persistent_lib_array(nldr_node_obj, root->lib);
 		/* Close library */
-		if (fStatus) {
-			hNldr->dbllFxns.closeFxn(root->lib);
+		if (lib_status) {
+			nldr_obj->ldr_fxns.close_fxn(root->lib);
 			return DSP_SALREADYLOADED;
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Check for circular dependencies. */
 		for (i = 0; i < depth; i++) {
-			if (root->lib == libPath[i]) {
+			if (root->lib == lib_path[i]) {
 				/* This condition could be checked by a
 				 * tool at build time. */
 				status = DSP_EDYNLOAD;
@@ -1388,43 +1333,47 @@
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Add library to current path in dependency tree */
-		libPath[depth] = root->lib;
+		lib_path[depth] = root->lib;
 		depth++;
 		/* Get number of dependent libraries */
-		status = DCD_GetNumDepLibs(hNldrNode->pNldr->hDcdMgr, &uuid,
-					  &nLibs, &nPLibs, phase);
+		status =
+		    dcd_get_num_dep_libs(nldr_node_obj->nldr_obj->hdcd_mgr,
+					 &uuid, &nd_libs, &np_libs, phase);
 	}
-	DBC_Assert(nLibs >= nPLibs);
+	DBC_ASSERT(nd_libs >= np_libs);
 	if (DSP_SUCCEEDED(status)) {
-		if (!(*hNldrNode->pfPhaseSplit))
-			nPLibs = 0;
+		if (!(*nldr_node_obj->pf_phase_split))
+			np_libs = 0;
 
-		/* nLibs = #of dependent libraries */
-		root->nDepLibs = nLibs - nPLibs;
-		if (nLibs > 0) {
-			depLibUUIDs = MEM_Calloc(sizeof(struct DSP_UUID) *
-				      nLibs, MEM_PAGED);
-			persistentDepLibs =
-				MEM_Calloc(sizeof(bool) * nLibs, MEM_PAGED);
-			if (!depLibUUIDs || !persistentDepLibs)
+		/* nd_libs = #of dependent libraries */
+		root->dep_libs = nd_libs - np_libs;
+		if (nd_libs > 0) {
+			dep_lib_uui_ds = mem_calloc(sizeof(struct dsp_uuid) *
+						    nd_libs, MEM_PAGED);
+			persistent_dep_libs =
+			    mem_calloc(sizeof(bool) * nd_libs, MEM_PAGED);
+			if (!dep_lib_uui_ds || !persistent_dep_libs)
 				status = DSP_EMEMORY;
 
-			if (root->nDepLibs > 0) {
+			if (root->dep_libs > 0) {
 				/* Allocate arrays for dependent lib UUIDs,
 				 * lib nodes */
-				root->pDepLibs = MEM_Calloc
-					(sizeof(struct LibNode) *
-					(root->nDepLibs), MEM_PAGED);
-				if (!(root->pDepLibs))
+				root->dep_libs_tree = mem_calloc
+				    (sizeof(struct lib_node) *
+				     (root->dep_libs), MEM_PAGED);
+				if (!(root->dep_libs_tree))
 					status = DSP_EMEMORY;
 
 			}
 
 			if (DSP_SUCCEEDED(status)) {
 				/* Get the dependent library UUIDs */
-				status = DCD_GetDepLibs(hNldrNode->pNldr->
-					hDcdMgr, &uuid, nLibs, depLibUUIDs,
-					persistentDepLibs, phase);
+				status =
+				    dcd_get_dep_libs(nldr_node_obj->
+						     nldr_obj->hdcd_mgr, &uuid,
+						     nd_libs, dep_lib_uui_ds,
+						     persistent_dep_libs,
+						     phase);
 			}
 		}
 	}
@@ -1432,49 +1381,44 @@
 	/*
 	 *  Recursively load dependent libraries.
 	 */
-	if (DSP_SUCCEEDED(status) && persistentDepLibs) {
-		for (i = 0; i < nLibs; i++) {
+	if (DSP_SUCCEEDED(status)) {
+		for (i = 0; i < nd_libs; i++) {
 			/* If root library is NOT persistent, and dep library
 			 * is, then record it.  If root library IS persistent,
 			 * the deplib is already included */
-			if (!rootPersistent && persistentDepLibs[i] &&
-			   *hNldrNode->pfPhaseSplit) {
-				if ((hNldrNode->nPersLib) > MAXLIBS) {
+			if (!rootPersistent && persistent_dep_libs[i] &&
+			    *nldr_node_obj->pf_phase_split) {
+				if ((nldr_node_obj->pers_libs) > MAXLIBS) {
 					status = DSP_EDYNLOAD;
 					break;
 				}
 
 				/* Allocate library outside of phase */
-				pDepLib = &hNldrNode->persLib[hNldrNode->
-					  nPersLib];
+				dep_lib =
+				    &nldr_node_obj->pers_lib_table
+				    [nldr_node_obj->pers_libs];
 			} else {
 				if (rootPersistent)
-					persistentDepLibs[i] = true;
-
+					persistent_dep_libs[i] = true;
 
 				/* Allocate library within phase */
-				pDepLib = &root->pDepLibs[nLoaded];
+				dep_lib = &root->dep_libs_tree[nd_libs_loaded];
 			}
 
-			if (depLibUUIDs) {
-				status = LoadLib(hNldrNode, pDepLib,
-						depLibUUIDs[i],
-						persistentDepLibs[i], libPath,
-						phase,
-						depth);
-			} else {
-				status = DSP_EMEMORY;
-			}
+			status = load_lib(nldr_node_obj, dep_lib,
+					  dep_lib_uui_ds[i],
+					  persistent_dep_libs[i], lib_path,
+					  phase, depth);
 
 			if (DSP_SUCCEEDED(status)) {
 				if ((status != DSP_SALREADYLOADED) &&
-				   !rootPersistent && persistentDepLibs[i] &&
-				   *hNldrNode->pfPhaseSplit) {
-					(hNldrNode->nPersLib)++;
+				    !rootPersistent && persistent_dep_libs[i] &&
+				    *nldr_node_obj->pf_phase_split) {
+					(nldr_node_obj->pers_libs)++;
 				} else {
-					if (!persistentDepLibs[i] ||
-					   !(*hNldrNode->pfPhaseSplit)) {
-						nLoaded++;
+					if (!persistent_dep_libs[i] ||
+					    !(*nldr_node_obj->pf_phase_split)) {
+						nd_libs_loaded++;
 					}
 				}
 			} else {
@@ -1485,14 +1429,15 @@
 
 	/* Now we can load the root library */
 	if (DSP_SUCCEEDED(status)) {
-		newAttrs = hNldr->dbllAttrs;
-		newAttrs.symArg = root;
-		newAttrs.rmmHandle = hNldrNode;
-		newAttrs.wHandle = hNldrNode->pPrivRef;
-		newAttrs.baseImage = false;
-
-		status = hNldr->dbllFxns.loadFxn(root->lib, flags, &newAttrs,
-			 &entry);
+		new_attrs = nldr_obj->ldr_attrs;
+		new_attrs.sym_arg = root;
+		new_attrs.rmm_handle = nldr_node_obj;
+		new_attrs.input_params = nldr_node_obj->priv_ref;
+		new_attrs.base_image = false;
+
+		status =
+		    nldr_obj->ldr_fxns.load_fxn(root->lib, flags, &new_attrs,
+						&entry);
 	}
 
 	/*
@@ -1502,170 +1447,185 @@
 	 */
 	if (DSP_FAILED(status)) {
 		if (phase != NLDR_EXECUTE) {
-			for (i = 0; i < hNldrNode->nPersLib; i++)
-				UnloadLib(hNldrNode, &hNldrNode->persLib[i]);
+			for (i = 0; i < nldr_node_obj->pers_libs; i++)
+				unload_lib(nldr_node_obj,
+					   &nldr_node_obj->pers_lib_table[i]);
 
-			hNldrNode->nPersLib = 0;
+			nldr_node_obj->pers_libs = 0;
 		}
-		for (i = 0; i < nLoaded; i++)
-			UnloadLib(hNldrNode, &root->pDepLibs[i]);
+		for (i = 0; i < nd_libs_loaded; i++)
+			unload_lib(nldr_node_obj, &root->dep_libs_tree[i]);
 
 		if (root->lib)
-			hNldr->dbllFxns.closeFxn(root->lib);
+			nldr_obj->ldr_fxns.close_fxn(root->lib);
 
 	}
 
 	/* Going up one node in the dependency tree */
 	depth--;
 
-	if (depLibUUIDs) {
-		MEM_Free(depLibUUIDs);
-		depLibUUIDs = NULL;
-	}
+	kfree(dep_lib_uui_ds);
+	dep_lib_uui_ds = NULL;
 
-	if (persistentDepLibs) {
-		MEM_Free(persistentDepLibs);
-		persistentDepLibs = NULL;
-	}
+	kfree(persistent_dep_libs);
+	persistent_dep_libs = NULL;
 
 	return status;
 }
 
 /*
- *  ======== LoadOvly ========
+ *  ======== load_ovly ========
  */
-static DSP_STATUS LoadOvly(struct NLDR_NODEOBJECT *hNldrNode,
-			  enum NLDR_PHASE phase)
+static dsp_status load_ovly(struct nldr_nodeobject *nldr_node_obj,
+			    enum nldr_phase phase)
 {
-	struct NLDR_OBJECT *hNldr = hNldrNode->pNldr;
-	struct OvlyNode *pONode = NULL;
-	struct OvlySect *pPhaseSects = NULL;
-	struct OvlySect *pOtherSects = NULL;
+	struct nldr_object *nldr_obj = nldr_node_obj->nldr_obj;
+	struct ovly_node *po_node = NULL;
+	struct ovly_sect *phase_sects = NULL;
+	struct ovly_sect *other_sects_list = NULL;
 	u16 i;
-	u16 nAlloc = 0;
-	u16 nOtherAlloc = 0;
-	u16 *pRefCount = NULL;
-	u16 *pOtherRef = NULL;
-	u32 nBytes;
-	struct OvlySect *pSect;
-	DSP_STATUS status = DSP_SOK;
+	u16 alloc_num = 0;
+	u16 other_alloc = 0;
+	u16 *ref_count = NULL;
+	u16 *other_ref = NULL;
+	u32 bytes;
+	struct ovly_sect *ovly_section;
+	dsp_status status = DSP_SOK;
 
 	/* Find the node in the table */
-	for (i = 0; i < hNldr->nOvlyNodes; i++) {
-		if (IsEqualUUID(hNldrNode->uuid, hNldr->ovlyTable[i].uuid)) {
+	for (i = 0; i < nldr_obj->ovly_nodes; i++) {
+		if (IS_EQUAL_UUID
+		    (nldr_node_obj->uuid, nldr_obj->ovly_table[i].uuid)) {
 			/* Found it */
-			pONode = &(hNldr->ovlyTable[i]);
+			po_node = &(nldr_obj->ovly_table[i]);
 			break;
 		}
 	}
 
-	DBC_Assert(i < hNldr->nOvlyNodes);
+	DBC_ASSERT(i < nldr_obj->ovly_nodes);
+
+	if (!po_node) {
+		status = DSP_ENOTFOUND;
+		goto func_end;
+	}
+
 	switch (phase) {
 	case NLDR_CREATE:
-		pRefCount = &(pONode->createRef);
-		pOtherRef = &(pONode->otherRef);
-		pPhaseSects = pONode->pCreateSects;
-		pOtherSects = pONode->pOtherSects;
+		ref_count = &(po_node->create_ref);
+		other_ref = &(po_node->other_ref);
+		phase_sects = po_node->create_sects_list;
+		other_sects_list = po_node->other_sects_list;
 		break;
 
 	case NLDR_EXECUTE:
-		pRefCount = &(pONode->executeRef);
-		pPhaseSects = pONode->pExecuteSects;
+		ref_count = &(po_node->execute_ref);
+		phase_sects = po_node->execute_sects_list;
 		break;
 
 	case NLDR_DELETE:
-		pRefCount = &(pONode->deleteRef);
-		pPhaseSects = pONode->pDeleteSects;
+		ref_count = &(po_node->delete_ref);
+		phase_sects = po_node->delete_sects_list;
 		break;
 
 	default:
-		DBC_Assert(false);
+		DBC_ASSERT(false);
 		break;
 	}
 
-	DBC_Assert(pRefCount != NULL);
-	if (DSP_FAILED(status))
-		goto func_end;
-
-	if (pRefCount == NULL)
+	if (ref_count == NULL)
 		goto func_end;
 
-	if (*pRefCount != 0)
+	if (*ref_count != 0)
 		goto func_end;
 
 	/* 'Allocate' memory for overlay sections of this phase */
-	pSect = pPhaseSects;
-	while (pSect) {
-		/* allocate */ /* page not supported yet */
-		  /* reserve */ /* align */
-		status = RMM_alloc(hNldr->rmm, 0, pSect->size, 0,
-			 &(pSect->runAddr), true);
+	ovly_section = phase_sects;
+	while (ovly_section) {
+		/* allocate *//* page not supported yet */
+		/* reserve *//* align */
+		status = rmm_alloc(nldr_obj->rmm, 0, ovly_section->size, 0,
+				   &(ovly_section->sect_run_addr), true);
 		if (DSP_SUCCEEDED(status)) {
-			pSect = pSect->pNextSect;
-			nAlloc++;
+			ovly_section = ovly_section->next_sect;
+			alloc_num++;
 		} else {
 			break;
 		}
 	}
-	if (pOtherRef && *pOtherRef == 0) {
+	if (other_ref && *other_ref == 0) {
 		/* 'Allocate' memory for other overlay sections
 		 * (create phase) */
 		if (DSP_SUCCEEDED(status)) {
-			pSect = pOtherSects;
-			while (pSect) {
-				/* page not supported */ /* align */
+			ovly_section = other_sects_list;
+			while (ovly_section) {
+				/* page not supported *//* align */
 				/* reserve */
-				status = RMM_alloc(hNldr->rmm, 0, pSect->size,
-					 0, &(pSect->runAddr), true);
+				status =
+				    rmm_alloc(nldr_obj->rmm, 0,
+					      ovly_section->size, 0,
+					      &(ovly_section->sect_run_addr),
+					      true);
 				if (DSP_SUCCEEDED(status)) {
-					pSect = pSect->pNextSect;
-					nOtherAlloc++;
+					ovly_section = ovly_section->next_sect;
+					other_alloc++;
 				} else {
 					break;
 				}
 			}
 		}
 	}
-	if (*pRefCount == 0) {
+	if (*ref_count == 0) {
 		if (DSP_SUCCEEDED(status)) {
 			/* Load sections for this phase */
-			pSect = pPhaseSects;
-			while (pSect && DSP_SUCCEEDED(status)) {
-				nBytes = (*hNldr->ovlyFxn)(hNldrNode->pPrivRef,
-					 pSect->runAddr, pSect->loadAddr,
-					 pSect->size, pSect->page);
-				if (nBytes != pSect->size)
+			ovly_section = phase_sects;
+			while (ovly_section && DSP_SUCCEEDED(status)) {
+				bytes =
+				    (*nldr_obj->ovly_fxn) (nldr_node_obj->
+							   priv_ref,
+							   ovly_section->
+							   sect_run_addr,
+							   ovly_section->
+							   sect_load_addr,
+							   ovly_section->size,
+							   ovly_section->page);
+				if (bytes != ovly_section->size)
 					status = DSP_EFAIL;
 
-				pSect = pSect->pNextSect;
+				ovly_section = ovly_section->next_sect;
 			}
 		}
 	}
-	if (pOtherRef && *pOtherRef == 0) {
+	if (other_ref && *other_ref == 0) {
 		if (DSP_SUCCEEDED(status)) {
 			/* Load other sections (create phase) */
-			pSect = pOtherSects;
-			while (pSect && DSP_SUCCEEDED(status)) {
-				nBytes = (*hNldr->ovlyFxn)(hNldrNode->pPrivRef,
-					 pSect->runAddr, pSect->loadAddr,
-					 pSect->size, pSect->page);
-				if (nBytes != pSect->size)
+			ovly_section = other_sects_list;
+			while (ovly_section && DSP_SUCCEEDED(status)) {
+				bytes =
+				    (*nldr_obj->ovly_fxn) (nldr_node_obj->
+							   priv_ref,
+							   ovly_section->
+							   sect_run_addr,
+							   ovly_section->
+							   sect_load_addr,
+							   ovly_section->size,
+							   ovly_section->page);
+				if (bytes != ovly_section->size)
 					status = DSP_EFAIL;
 
-				pSect = pSect->pNextSect;
+				ovly_section = ovly_section->next_sect;
 			}
 		}
 	}
 	if (DSP_FAILED(status)) {
 		/* 'Deallocate' memory */
-		FreeSects(hNldr, pPhaseSects, nAlloc);
-		FreeSects(hNldr, pOtherSects, nOtherAlloc);
+		free_sects(nldr_obj, phase_sects, alloc_num);
+		free_sects(nldr_obj, other_sects_list, other_alloc);
 	}
 func_end:
-	if (DSP_SUCCEEDED(status) && (pRefCount != NULL)) {
-		*pRefCount += 1;
-		if (pOtherRef)
-			*pOtherRef += 1;
+	if (DSP_SUCCEEDED(status) && (ref_count != NULL)) {
+		*ref_count += 1;
+		if (other_ref)
+			*other_ref += 1;
 
 	}
 
@@ -1673,119 +1633,121 @@
 }
 
 /*
- *  ======== RemoteAlloc ========
+ *  ======== remote_alloc ========
  */
-static DSP_STATUS RemoteAlloc(void **pRef, u16 space, u32 size,
-			     u32 align, u32 *dspAddr,
-			     OPTIONAL s32 segmentId, OPTIONAL s32 req,
-			     bool reserve)
-{
-	struct NLDR_NODEOBJECT *hNode = (struct NLDR_NODEOBJECT *)pRef;
-	struct NLDR_OBJECT *hNldr;
-	struct RMM_TargetObj *rmm;
-	u16 memPhaseBit = MAXFLAGS;
+static dsp_status remote_alloc(void **pRef, u16 space, u32 size,
+			       u32 align, u32 *dspAddr,
+			       OPTIONAL s32 segmentId, OPTIONAL s32 req,
+			       bool reserve)
+{
+	struct nldr_nodeobject *hnode = (struct nldr_nodeobject *)pRef;
+	struct nldr_object *nldr_obj;
+	struct rmm_target_obj *rmm;
+	u16 mem_phase_bit = MAXFLAGS;
 	u16 segid = 0;
 	u16 i;
-	u16 memType;
-	u32 nWords;
-	struct RMM_Addr *pRmmAddr = (struct RMM_Addr *)dspAddr;
-	bool fReq = false;
-	DSP_STATUS status = DSP_EMEMORY;	/* Set to fail */
-	DBC_Require(MEM_IsValidHandle(hNode, NLDR_NODESIGNATURE));
-	DBC_Require(space == DBLL_CODE || space == DBLL_DATA ||
-		   space == DBLL_BSS);
-	hNldr = hNode->pNldr;
-	rmm = hNldr->rmm;
+	u16 mem_sect_type;
+	u32 word_size;
+	struct rmm_addr *rmm_addr_obj = (struct rmm_addr *)dspAddr;
+	bool mem_load_req = false;
+	dsp_status status = DSP_EMEMORY;	/* Set to fail */
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hnode, NLDR_NODESIGNATURE));
+	DBC_REQUIRE(space == DBLL_CODE || space == DBLL_DATA ||
+		    space == DBLL_BSS);
+	nldr_obj = hnode->nldr_obj;
+	rmm = nldr_obj->rmm;
 	/* Convert size to DSP words */
-	nWords = (size + hNldr->usDSPWordSize - 1) / hNldr->usDSPWordSize;
+	word_size =
+	    (size + nldr_obj->us_dsp_word_size -
+	     1) / nldr_obj->us_dsp_word_size;
 	/* Modify memory 'align' to account for DSP cache line size */
-	align = findLcm(GEM_CACHE_LINE_SIZE, align);
-	GT_1trace(NLDR_debugMask, GT_7CLASS,
-		 "RemoteAlloc: memory align to 0x%x \n", align);
+	align = find_lcm(GEM_CACHE_LINE_SIZE, align);
+	dev_dbg(bridge, "%s: memory align to 0x%x\n", __func__, align);
 	if (segmentId != -1) {
-		pRmmAddr->segid = segmentId;
+		rmm_addr_obj->segid = segmentId;
 		segid = segmentId;
-		fReq = req;
+		mem_load_req = req;
 	} else {
-		switch (hNode->phase) {
+		switch (hnode->phase) {
 		case NLDR_CREATE:
-			memPhaseBit = CREATEDATAFLAGBIT;
+			mem_phase_bit = CREATEDATAFLAGBIT;
 			break;
 		case NLDR_DELETE:
-			memPhaseBit = DELETEDATAFLAGBIT;
+			mem_phase_bit = DELETEDATAFLAGBIT;
 			break;
 		case NLDR_EXECUTE:
-			memPhaseBit = EXECUTEDATAFLAGBIT;
+			mem_phase_bit = EXECUTEDATAFLAGBIT;
 			break;
 		default:
-			DBC_Assert(false);
+			DBC_ASSERT(false);
 			break;
 		}
 		if (space == DBLL_CODE)
-			memPhaseBit++;
+			mem_phase_bit++;
 
-		if (memPhaseBit < MAXFLAGS)
-			segid = hNode->segId[memPhaseBit];
+		if (mem_phase_bit < MAXFLAGS)
+			segid = hnode->seg_id[mem_phase_bit];
 
 		/* Determine if there is a memory loading requirement */
-		if ((hNode->codeDataFlagMask >> memPhaseBit) & 0x1)
-			fReq = true;
+		if ((hnode->code_data_flag_mask >> mem_phase_bit) & 0x1)
+			mem_load_req = true;
 
 	}
-	memType = (space == DBLL_CODE) ? DYNM_CODE : DYNM_DATA;
+	mem_sect_type = (space == DBLL_CODE) ? DYNM_CODE : DYNM_DATA;
 
 	/* Find an appropriate segment based on space */
 	if (segid == NULLID) {
 		/* No memory requirements of preferences */
-		DBC_Assert(!fReq);
+		DBC_ASSERT(!mem_load_req);
 		goto func_cont;
 	}
 	if (segid <= MAXSEGID) {
-		DBC_Assert(segid < hNldr->nSegs);
+		DBC_ASSERT(segid < nldr_obj->dload_segs);
 		/* Attempt to allocate from segid first. */
-		pRmmAddr->segid = segid;
-		status = RMM_alloc(rmm, segid, nWords, align, dspAddr, false);
+		rmm_addr_obj->segid = segid;
+		status =
+		    rmm_alloc(rmm, segid, word_size, align, dspAddr, false);
 		if (DSP_FAILED(status)) {
-			GT_1trace(NLDR_debugMask, GT_6CLASS,
-				 "RemoteAlloc:Unable allocate "
-				 "from segment %d.\n", segid);
+			dev_dbg(bridge, "%s: Unable allocate from segment %d\n",
+				__func__, segid);
 		}
 	} else {
 		/* segid > MAXSEGID ==> Internal or external memory */
-		DBC_Assert(segid == MEMINTERNALID || segid == MEMEXTERNALID);
-		 /*  Check for any internal or external memory segment,
-		  *  depending on segid.*/
-		memType |= segid == MEMINTERNALID ?
-				 DYNM_INTERNAL : DYNM_EXTERNAL;
-		for (i = 0; i < hNldr->nSegs; i++) {
-			if ((hNldr->segTable[i] & memType) != memType)
+		DBC_ASSERT(segid == MEMINTERNALID || segid == MEMEXTERNALID);
+		/*  Check for any internal or external memory segment,
+		 *  depending on segid. */
+		mem_sect_type |= segid == MEMINTERNALID ?
+		    DYNM_INTERNAL : DYNM_EXTERNAL;
+		for (i = 0; i < nldr_obj->dload_segs; i++) {
+			if ((nldr_obj->seg_table[i] & mem_sect_type) !=
+			    mem_sect_type)
 				continue;
 
-			status = RMM_alloc(rmm, i, nWords, align, dspAddr,
+			status = rmm_alloc(rmm, i, word_size, align, dspAddr,
 					   false);
 			if (DSP_SUCCEEDED(status)) {
 				/* Save segid for freeing later */
-				pRmmAddr->segid = i;
+				rmm_addr_obj->segid = i;
 				break;
 			}
 		}
 	}
 func_cont:
 	/* Haven't found memory yet, attempt to find any segment that works */
-	if (status == DSP_EMEMORY && !fReq) {
-		GT_0trace(NLDR_debugMask, GT_6CLASS,
-			 "RemoteAlloc: Preferred segment "
-			 "unavailable, trying another segment.\n");
-		for (i = 0; i < hNldr->nSegs; i++) {
-			/* All bits of memType must be set */
-			if ((hNldr->segTable[i] & memType) != memType)
+	if (status == DSP_EMEMORY && !mem_load_req) {
+		dev_dbg(bridge, "%s: Preferred segment unavailable, trying "
+			"another\n", __func__);
+		for (i = 0; i < nldr_obj->dload_segs; i++) {
+			/* All bits of mem_sect_type must be set */
+			if ((nldr_obj->seg_table[i] & mem_sect_type) !=
+			    mem_sect_type)
 				continue;
 
-			status = RMM_alloc(rmm, i, nWords, align, dspAddr,
-					  false);
+			status = rmm_alloc(rmm, i, word_size, align, dspAddr,
+					   false);
 			if (DSP_SUCCEEDED(status)) {
 				/* Save segid */
-				pRmmAddr->segid = i;
+				rmm_addr_obj->segid = i;
 				break;
 			}
 		}
@@ -1794,142 +1756,147 @@
 	return status;
 }
 
-static DSP_STATUS RemoteFree(void **pRef, u16 space, u32 dspAddr,
-				u32 size, bool reserve)
+static dsp_status remote_free(void **pRef, u16 space, u32 dspAddr,
+			      u32 size, bool reserve)
 {
-	struct NLDR_OBJECT *hNldr = (struct NLDR_OBJECT *)pRef;
-	struct RMM_TargetObj *rmm;
-	u32 nWords;
-	DSP_STATUS status = DSP_EMEMORY;	/* Set to fail */
+	struct nldr_object *nldr_obj = (struct nldr_object *)pRef;
+	struct rmm_target_obj *rmm;
+	u32 word_size;
+	dsp_status status = DSP_EMEMORY;	/* Set to fail */
 
-	DBC_Require(MEM_IsValidHandle(hNldr, NLDR_SIGNATURE));
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(nldr_obj, NLDR_SIGNATURE));
 
-	rmm = hNldr->rmm;
+	rmm = nldr_obj->rmm;
 
 	/* Convert size to DSP words */
-	nWords = (size + hNldr->usDSPWordSize - 1) / hNldr->usDSPWordSize;
+	word_size =
+	    (size + nldr_obj->us_dsp_word_size -
+	     1) / nldr_obj->us_dsp_word_size;
 
-	if (RMM_free(rmm, space, dspAddr, nWords, reserve))
+	if (rmm_free(rmm, space, dspAddr, word_size, reserve))
 		status = DSP_SOK;
 
 	return status;
 }
 
 /*
- *  ======== UnloadLib ========
+ *  ======== unload_lib ========
  */
-static void UnloadLib(struct NLDR_NODEOBJECT *hNldrNode, struct LibNode *root)
+static void unload_lib(struct nldr_nodeobject *nldr_node_obj,
+		       struct lib_node *root)
 {
-	struct DBLL_Attrs newAttrs;
-	struct NLDR_OBJECT *hNldr = hNldrNode->pNldr;
+	struct dbll_attrs new_attrs;
+	struct nldr_object *nldr_obj = nldr_node_obj->nldr_obj;
 	u16 i;
 
-	DBC_Assert(root != NULL);
+	DBC_ASSERT(root != NULL);
 
 	/* Unload dependent libraries */
-	for (i = 0; i < root->nDepLibs; i++)
-		UnloadLib(hNldrNode, &root->pDepLibs[i]);
+	for (i = 0; i < root->dep_libs; i++)
+		unload_lib(nldr_node_obj, &root->dep_libs_tree[i]);
 
-	root->nDepLibs = 0;
+	root->dep_libs = 0;
 
-	newAttrs = hNldr->dbllAttrs;
-	newAttrs.rmmHandle = hNldr->rmm;
-	newAttrs.wHandle = hNldrNode->pPrivRef;
-	newAttrs.baseImage = false;
-	newAttrs.symArg = root;
+	new_attrs = nldr_obj->ldr_attrs;
+	new_attrs.rmm_handle = nldr_obj->rmm;
+	new_attrs.input_params = nldr_node_obj->priv_ref;
+	new_attrs.base_image = false;
+	new_attrs.sym_arg = root;
 
 	if (root->lib) {
 		/* Unload the root library */
-		hNldr->dbllFxns.unloadFxn(root->lib, &newAttrs);
-		hNldr->dbllFxns.closeFxn(root->lib);
+		nldr_obj->ldr_fxns.unload_fxn(root->lib, &new_attrs);
+		nldr_obj->ldr_fxns.close_fxn(root->lib);
 	}
 
 	/* Free dependent library list */
-	if (root->pDepLibs) {
-		MEM_Free(root->pDepLibs);
-		root->pDepLibs = NULL;
-	}
+	kfree(root->dep_libs_tree);
+	root->dep_libs_tree = NULL;
 }
 
 /*
- *  ======== UnloadOvly ========
+ *  ======== unload_ovly ========
  */
-static void UnloadOvly(struct NLDR_NODEOBJECT *hNldrNode, enum NLDR_PHASE phase)
+static void unload_ovly(struct nldr_nodeobject *nldr_node_obj,
+			enum nldr_phase phase)
 {
-	struct NLDR_OBJECT *hNldr = hNldrNode->pNldr;
-	struct OvlyNode *pONode = NULL;
-	struct OvlySect *pPhaseSects = NULL;
-	struct OvlySect *pOtherSects = NULL;
+	struct nldr_object *nldr_obj = nldr_node_obj->nldr_obj;
+	struct ovly_node *po_node = NULL;
+	struct ovly_sect *phase_sects = NULL;
+	struct ovly_sect *other_sects_list = NULL;
 	u16 i;
-	u16 nAlloc = 0;
-	u16 nOtherAlloc = 0;
-	u16 *pRefCount = NULL;
-	u16 *pOtherRef = NULL;
-	DSP_STATUS status = DSP_SOK;
+	u16 alloc_num = 0;
+	u16 other_alloc = 0;
+	u16 *ref_count = NULL;
+	u16 *other_ref = NULL;
 
 	/* Find the node in the table */
-	for (i = 0; i < hNldr->nOvlyNodes; i++) {
-		if (IsEqualUUID(hNldrNode->uuid, hNldr->ovlyTable[i].uuid)) {
+	for (i = 0; i < nldr_obj->ovly_nodes; i++) {
+		if (IS_EQUAL_UUID
+		    (nldr_node_obj->uuid, nldr_obj->ovly_table[i].uuid)) {
 			/* Found it */
-			pONode = &(hNldr->ovlyTable[i]);
+			po_node = &(nldr_obj->ovly_table[i]);
 			break;
 		}
 	}
 
-	DBC_Assert(i < hNldr->nOvlyNodes);
+	DBC_ASSERT(i < nldr_obj->ovly_nodes);
+
+	if (!po_node)
+		/* TODO: Should we print warning here? */
+		return;
+
 	switch (phase) {
 	case NLDR_CREATE:
-		pRefCount = &(pONode->createRef);
-		pPhaseSects = pONode->pCreateSects;
-		nAlloc = pONode->nCreateSects;
+		ref_count = &(po_node->create_ref);
+		phase_sects = po_node->create_sects_list;
+		alloc_num = po_node->create_sects;
 		break;
 	case NLDR_EXECUTE:
-		pRefCount = &(pONode->executeRef);
-		pPhaseSects = pONode->pExecuteSects;
-		nAlloc = pONode->nExecuteSects;
+		ref_count = &(po_node->execute_ref);
+		phase_sects = po_node->execute_sects_list;
+		alloc_num = po_node->execute_sects;
 		break;
 	case NLDR_DELETE:
-		pRefCount = &(pONode->deleteRef);
-		pOtherRef = &(pONode->otherRef);
-		pPhaseSects = pONode->pDeleteSects;
+		ref_count = &(po_node->delete_ref);
+		other_ref = &(po_node->other_ref);
+		phase_sects = po_node->delete_sects_list;
 		/* 'Other' overlay sections are unloaded in the delete phase */
-		pOtherSects = pONode->pOtherSects;
-		nAlloc = pONode->nDeleteSects;
-		nOtherAlloc = pONode->nOtherSects;
+		other_sects_list = po_node->other_sects_list;
+		alloc_num = po_node->delete_sects;
+		other_alloc = po_node->other_sects;
 		break;
 	default:
-		DBC_Assert(false);
+		DBC_ASSERT(false);
 		break;
 	}
-	if (DSP_SUCCEEDED(status)) {
-		DBC_Assert(pRefCount && (*pRefCount > 0));
-		 if (pRefCount && (*pRefCount > 0)) {
-			*pRefCount -= 1;
-			if (pOtherRef) {
-				DBC_Assert(*pOtherRef > 0);
-				*pOtherRef -= 1;
-			}
+	DBC_ASSERT(ref_count && (*ref_count > 0));
+	if (ref_count && (*ref_count > 0)) {
+		*ref_count -= 1;
+		if (other_ref) {
+			DBC_ASSERT(*other_ref > 0);
+			*other_ref -= 1;
 		}
 	}
-	if (pRefCount && (*pRefCount == 0)) {
+
+	if (ref_count && *ref_count == 0) {
 		/* 'Deallocate' memory */
-		FreeSects(hNldr, pPhaseSects, nAlloc);
+		free_sects(nldr_obj, phase_sects, alloc_num);
 	}
-	if (pOtherRef && *pOtherRef == 0)
-		FreeSects(hNldr, pOtherSects, nOtherAlloc);
-
+	if (other_ref && *other_ref == 0)
+		free_sects(nldr_obj, other_sects_list, other_alloc);
 }
 
 /*
- *  ======== findInPersistentLibArray ========
+ *  ======== find_in_persistent_lib_array ========
  */
-static bool findInPersistentLibArray(struct NLDR_NODEOBJECT *hNldrNode,
-				    struct DBLL_LibraryObj *lib)
+static bool find_in_persistent_lib_array(struct nldr_nodeobject *nldr_node_obj,
+					 struct dbll_library_obj *lib)
 {
 	s32 i = 0;
 
-	for (i = 0; i < hNldrNode->nPersLib; i++) {
-		if (lib == hNldrNode->persLib[i].lib)
+	for (i = 0; i < nldr_node_obj->pers_libs; i++) {
+		if (lib == nldr_node_obj->pers_lib_table[i].lib)
 			return true;
 
 	}
@@ -1940,19 +1907,19 @@
 /*
  * ================ Find LCM (Least Common Multiplier ===
  */
-static u32 findLcm(u32 a, u32 b)
+static u32 find_lcm(u32 a, u32 b)
 {
-	u32 retVal;
+	u32 ret;
 
-	retVal = a * b / findGcf(a, b);
+	ret = a * b / find_gcf(a, b);
 
-	return retVal;
+	return ret;
 }
 
 /*
  * ================ Find GCF (Greatest Common Factor ) ===
  */
-static u32 findGcf(u32 a, u32 b)
+static u32 find_gcf(u32 a, u32 b)
 {
 	u32 c;
 
@@ -1964,4 +1931,3 @@
 	}
 	return b;
 }
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/node.c kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/node.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/node.c	2011-10-11 13:51:01.604518511 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/rmgr/node.c	2011-10-24 16:43:22.322361000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge Node Manager.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,84 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== node.c ========
- *
- *  Description:
- *      DSP/BIOS Bridge Node Manager.
- *
- *  Public Functions:
- *      NODE_Allocate
- *      NODE_AllocMsgBuf
- *      NODE_ChangePriority
- *      NODE_Connect
- *      NODE_Create
- *      NODE_CreateMgr
- *      NODE_Delete
- *      NODE_DeleteMgr
- *      NODE_EnumNodes
- *      NODE_Exit
- *      NODE_FreeMsgBuf
- *      NODE_GetAttr
- *      NODE_GetChannelId
- *      NODE_GetMessage
- *      NODE_GetStrmMgr
- *      NODE_Init
- *      NODE_OnExit
- *      NODE_Pause
- *      NODE_PutMessage
- *      NODE_RegisterNotify
- *      NODE_Run
- *      NODE_Terminate
- *
- *! Revision History:
- *! =================
- *! 12-Apr-2004 hp  Compile IVA only for 24xx
- *! 09-Feb-2004 vp  Updated to support IVA.
- *! 07-Apr-2003 map	    Eliminated references to old DLDR
- *! 26-Mar-2003 vp  Commented the call to DSP deep sleep in Node_Delete
- *!		    function.
- *! 18-Feb-2003 vp  Code review updates.
- *! 06-Feb-2003 kc      Fixed FreeStream to release streams correctly.
- *! 23-Jan-2003 map     Removed call to DISP_DoCinit within Write()
- *! 03-Jan-2003 map     Only unload code after phase has executed if
- *!		     overlay or split dynload phases
- *! 18-Oct-2002 vp  Ported to Linux platform.
- *! 06-Nov-2002 map     Fixed NODE_Run on NODE_PAUSED bug
- *! 12-Oct-2002 map     Fixed DeleteNode bug in NODE_Create
- *! 11-Sep-2002 rr      DeleteNode frees the memory for strmConnect and dcd obj
- *! 29-Aug-2002 map     Modified Ovly and Write to use ARM-side copy
- *! 22-May-2002 sg      Changed use of cbData for PWR calls.
- *! 17-May-2002 jeh     Removed LoadLoaderFxns(). Get address of RMS_cinit()
- *!		     function. Call DISP_DoCinit() from Write(), if .cinit.
- *! 13-May-2002 sg      Added timeout to wake/sleep calls.
- *! 02-May-2002 sg      Added wake/sleep of DSP to support "nap" mode.
- *! 18-Apr-2002 jeh     Use dynamic loader if compile flag is set.
- *! 13-Feb-2002 jeh     Get uSysStackSize from DSP_NDBPROPS.
- *! 07-Jan-2002 ag      STRMMODE_ZEROCOPY(shared memory buffer swap) enabled.
- *! 17-Dec-2001 ag      STRMMODE_RDMA(DDMA) enabled.
- *! 12-Dec-2001 ag      Check for valid stream mode in NODE_Connect().
- *! 04-Dec-2001 jeh     Check for node sufficiently connected in NODE_Create().
- *! 15-Nov-2001 jeh     Removed DBC_Require(pNode->hXlator != NULL) from
- *!		     NODE_AllocMsgBuf(), and check node type != NODE_DEVICE.
- *! 11-Sep-2001 ag      Zero-copy messaging support.
- *! 28-Aug-2001 jeh     Overlay/dynamic loader infrastructure added. Removed
- *!		     NODE_GetDispatcher, excess node states.
- *! 07-Aug-2001 jeh     Removed critical section for dispatcher.
- *! 26-Jul-2001 jeh     Get ZL dll name through CFG.
- *! 05-Jun-2001 jeh     Assume DSP_STRMATTRS.uBufsize in GPP bytes.
- *! 11-May-2001 jeh     Some code review cleanup.
- *! 13-Feb-2001 kc:     DSP/BIOS Bridge name updates.
- *! 15-Dec-2000 sg      Convert IALG_Fxn address from byte addr to word addr.
- *! 04-Dec-2000 jeh     Call MSG Get and Put functions.
- *! 04-Dec-2000 ag      Added SM support for node messaging.
- *! 10-Nov-2000 rr:     NODE_MIN/MAX Priority is defined in dspdefs.h.
- *! 27-Oct-2000 jeh     Added NODE_AllocMsgBuf(), NODE_FreeMsgBuf().
- *! 11-Oct-2000 jeh     Changed NODE_EnumNodeInfo to NODE_EnumNodes. Added
- *!		     NODE_CloseOrphans(). Remove NODE_RegisterNotifyAllNodes
- *! 19-Jun-2000 jeh     Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -102,11 +26,9 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/cfg.h>
-#include <dspbridge/csl.h>
 #include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/proc.h>
@@ -131,10 +53,7 @@
 
 /*  ----------------------------------- Others */
 #include <dspbridge/gb.h>
-#ifdef DEBUG
 #include <dspbridge/uuidutil.h>
-#include <dspbridge/dbg.h>
-#endif
 
 /*  ----------------------------------- This */
 #include <dspbridge/nodepriv.h>
@@ -144,13 +63,9 @@
 #include <dspbridge/dbll.h>
 #include <dspbridge/nldr.h>
 
-#ifndef RES_CLEANUP_DISABLE
 #include <dspbridge/drv.h>
 #include <dspbridge/drvdefs.h>
-#include <dspbridge/dbreg.h>
 #include <dspbridge/resourcecleanup.h>
-#endif
-
 
 #define NODE_SIGNATURE      0x45444f4e	/* "EDON" */
 #define NODEMGR_SIGNATURE   0x52474d4e	/* "RGMN" */
@@ -158,12 +73,14 @@
 #define HOSTPREFIX	  "/host"
 #define PIPEPREFIX	  "/dbpipe"
 
-#define MaxInputs(h)  ((h)->dcdProps.objData.nodeObj.ndbProps.uNumInputStreams)
-#define MaxOutputs(h) ((h)->dcdProps.objData.nodeObj.ndbProps.uNumOutputStreams)
-
-#define NODE_GetPriority(h) ((h)->nPriority)
-#define NODE_SetPriority(hNode, nPriority) ((hNode)->nPriority = nPriority)
-#define NODE_SetState(hNode, state) ((hNode)->nState = state)
+#define MAX_INPUTS(h)  \
+		((h)->dcd_props.obj_data.node_obj.ndb_props.num_input_streams)
+#define MAX_OUTPUTS(h) \
+		((h)->dcd_props.obj_data.node_obj.ndb_props.num_output_streams)
+
+#define NODE_GET_PRIORITY(h) ((h)->prio)
+#define NODE_SET_PRIORITY(hnode, prio) ((hnode)->prio = prio)
+#define NODE_SET_STATE(hnode, state) ((hnode)->node_state = state)
 
 #define MAXPIPES	100	/* Max # of /pipe connections (CSL limit) */
 #define MAXDEVSUFFIXLEN 2	/* Max(Log base 10 of MAXPIPES, MAXSTREAMS) */
@@ -171,7 +88,7 @@
 #define PIPENAMELEN     (sizeof(PIPEPREFIX) + MAXDEVSUFFIXLEN)
 #define HOSTNAMELEN     (sizeof(HOSTPREFIX) + MAXDEVSUFFIXLEN)
 
-#define MAXDEVNAMELEN	32	/* DSP_NDBPROPS.acName size */
+#define MAXDEVNAMELEN	32	/* dsp_ndbprops.ac_name size */
 #define CREATEPHASE	1
 #define EXECUTEPHASE	2
 #define DELETEPHASE	3
@@ -202,672 +119,621 @@
 
 #define PWR_TIMEOUT		500	/* default PWR timeout in msec */
 
-#define STACKSEGLABEL "L1DSRAM_HEAP"  /* Label for DSP Stack Segment Address */
+#define STACKSEGLABEL "L1DSRAM_HEAP"	/* Label for DSP Stack Segment Addr */
 
 /*
- *  ======== NODE_MGR ========
+ *  ======== node_mgr ========
  */
-struct NODE_MGR {
-	u32 dwSignature;	/* For object validation */
-	struct DEV_OBJECT *hDevObject;	/* Device object */
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
-	struct DCD_MANAGER *hDcdMgr;	/* Proc/Node data manager */
-	struct DISP_OBJECT *hDisp;	/* Node dispatcher */
-	struct LST_LIST *nodeList;	/* List of all allocated nodes */
-	u32 uNumNodes;		/* Number of nodes in nodeList */
-	u32 uNumCreated;	/* Number of nodes *created* on DSP */
-	struct GB_TMap *pipeMap;		/* Pipe connection bit map */
-	struct GB_TMap *pipeDoneMap;	/* Pipes that are half free */
-	struct GB_TMap *chnlMap;		/* Channel allocation bit map */
-	struct GB_TMap *dmaChnlMap;	/* DMA Channel allocation bit map */
-	struct GB_TMap *zChnlMap;	/* Zero-Copy Channel alloc bit map */
-	struct NTFY_OBJECT *hNtfy;	/* Manages registered notifications */
-	struct SYNC_CSOBJECT *hSync;	/* For critical sections */
-	u32 ulFxnAddrs[NUMRMSFXNS];	/* RMS function addresses */
-	struct MSG_MGR *hMsg;
+struct node_mgr {
+	u32 dw_signature;	/* For object validation */
+	struct dev_object *hdev_obj;	/* Device object */
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD */
+	struct dcd_manager *hdcd_mgr;	/* Proc/Node data manager */
+	struct disp_object *disp_obj;	/* Node dispatcher */
+	struct lst_list *node_list;	/* List of all allocated nodes */
+	u32 num_nodes;		/* Number of nodes in node_list */
+	u32 num_created;	/* Number of nodes *created* on DSP */
+	struct gb_t_map *pipe_map;	/* Pipe connection bit map */
+	struct gb_t_map *pipe_done_map;	/* Pipes that are half free */
+	struct gb_t_map *chnl_map;	/* Channel allocation bit map */
+	struct gb_t_map *dma_chnl_map;	/* DMA Channel allocation bit map */
+	struct gb_t_map *zc_chnl_map;	/* Zero-Copy Channel alloc bit map */
+	struct ntfy_object *ntfy_obj;	/* Manages registered notifications */
+	struct sync_csobject *sync_obj;	/* For critical sections */
+	u32 ul_fxn_addrs[NUMRMSFXNS];	/* RMS function addresses */
+	struct msg_mgr *msg_mgr_obj;
 
 	/* Processor properties needed by Node Dispatcher */
-	u32 ulNumChnls;	/* Total number of channels */
-	u32 ulChnlOffset;	/* Offset of chnl ids rsvd for RMS */
-	u32 ulChnlBufSize;	/* Buffer size for data to RMS */
-	DSP_PROCFAMILY procFamily;	/* eg, 5000 */
-	DSP_PROCTYPE procType;	/* eg, 5510 */
-	u32 uDSPWordSize;	/* Size of DSP word on host bytes */
-	u32 uDSPDataMauSize;	/* Size of DSP data MAU */
-	u32 uDSPMauSize;	/* Size of MAU */
-	s32 nMinPri;		/* Minimum runtime priority for node */
-	s32 nMaxPri;		/* Maximum runtime priority for node */
+	u32 ul_num_chnls;	/* Total number of channels */
+	u32 ul_chnl_offset;	/* Offset of chnl ids rsvd for RMS */
+	u32 ul_chnl_buf_size;	/* Buffer size for data to RMS */
+	int proc_family;	/* eg, 5000 */
+	int proc_type;		/* eg, 5510 */
+	u32 udsp_word_size;	/* Size of DSP word on host bytes */
+	u32 udsp_data_mau_size;	/* Size of DSP data MAU */
+	u32 udsp_mau_size;	/* Size of MAU */
+	s32 min_pri;		/* Minimum runtime priority for node */
+	s32 max_pri;		/* Maximum runtime priority for node */
 
-	struct STRM_MGR *hStrmMgr;	/* STRM manager */
+	struct strm_mgr *strm_mgr_obj;	/* STRM manager */
 
 	/* Loader properties */
-	struct NLDR_OBJECT *hNldr;	/* Handle to loader */
-	struct NLDR_FXNS nldrFxns;	/* Handle to loader functions */
-	bool fLoaderInit;	/* Loader Init function succeeded? */
+	struct nldr_object *nldr_obj;	/* Handle to loader */
+	struct node_ldr_fxns nldr_fxns;	/* Handle to loader functions */
+	bool loader_init;	/* Loader Init function succeeded? */
 };
 
 /*
- *  ======== CONNECTTYPE ========
+ *  ======== connecttype ========
  */
-enum CONNECTTYPE {
+enum connecttype {
 	NOTCONNECTED = 0,
 	NODECONNECT,
 	HOSTCONNECT,
 	DEVICECONNECT,
-} ;
+};
 
 /*
- *  ======== STREAM ========
+ *  ======== stream_chnl ========
  */
-struct STREAM {
-	enum CONNECTTYPE type;	/* Type of stream connection */
-	u32 devId;		/* pipe or channel id */
+struct stream_chnl {
+	enum connecttype type;	/* Type of stream connection */
+	u32 dev_id;		/* pipe or channel id */
 };
 
 /*
- *  ======== NODE_OBJECT ========
+ *  ======== node_object ========
  */
-struct NODE_OBJECT {
-	struct LST_ELEM listElem;
-	u32 dwSignature;	/* For object validation */
-	struct NODE_MGR *hNodeMgr;	/* The manager of this node */
-	struct PROC_OBJECT *hProcessor;	/* Back pointer to processor */
-	struct DSP_UUID nodeId;	/* Node's ID */
-	s32 nPriority;		/* Node's current priority */
-	u32 uTimeout;		/* Timeout for blocking NODE calls */
-	u32 uHeapSize;		/* Heap Size */
-	u32 uDSPHeapVirtAddr;	/* Heap Size */
-	u32 uGPPHeapVirtAddr;	/* Heap Size */
-	enum NODE_TYPE nType;	/* Type of node: message, task, etc */
-	enum NODE_STATE nState;	/* NODE_ALLOCATED, NODE_CREATED, ... */
-	u32 uNumInputs;	/* Current number of inputs */
-	u32 uNumOutputs;	/* Current number of outputs */
-	u32 uMaxInputIndex;	/* Current max input stream index */
-	u32 uMaxOutputIndex;	/* Current max output stream index */
-	struct STREAM *inputs;		/* Node's input streams */
-	struct STREAM *outputs;	/* Node's output streams */
-	struct NODE_CREATEARGS createArgs;  /* Args for node create function */
-	NODE_ENV nodeEnv;	/* Environment returned by RMS */
-	struct DCD_GENERICOBJ dcdProps;	/* Node properties from DCD */
-	struct DSP_CBDATA *pArgs;	/* Optional args to pass to node */
-	struct NTFY_OBJECT *hNtfy;	/* Manages registered notifications */
-	char *pstrDevName;	/* device name, if device node */
-	struct SYNC_OBJECT *hSyncDone;	/* Synchronize NODE_Terminate */
-	s32 nExitStatus;	/* execute function return status */
-
-	/* Information needed for NODE_GetAttr() */
-	DSP_HNODE hDeviceOwner;	/* If dev node, task that owns it */
-	u32 uNumGPPInputs;	/* Current # of from GPP streams */
-	u32 uNumGPPOutputs;	/* Current # of to GPP streams */
+struct node_object {
+	struct list_head list_elem;
+	u32 dw_signature;	/* For object validation */
+	struct node_mgr *hnode_mgr;	/* The manager of this node */
+	struct proc_object *hprocessor;	/* Back pointer to processor */
+	struct dsp_uuid node_uuid;	/* Node's ID */
+	s32 prio;		/* Node's current priority */
+	u32 utimeout;		/* Timeout for blocking NODE calls */
+	u32 heap_size;		/* Heap Size */
+	u32 udsp_heap_virt_addr;	/* Heap Size */
+	u32 ugpp_heap_virt_addr;	/* Heap Size */
+	enum node_type ntype;	/* Type of node: message, task, etc */
+	enum node_state node_state;	/* NODE_ALLOCATED, NODE_CREATED, ... */
+	u32 num_inputs;		/* Current number of inputs */
+	u32 num_outputs;	/* Current number of outputs */
+	u32 max_input_index;	/* Current max input stream index */
+	u32 max_output_index;	/* Current max output stream index */
+	struct stream_chnl *inputs;	/* Node's input streams */
+	struct stream_chnl *outputs;	/* Node's output streams */
+	struct node_createargs create_args;	/* Args for node create func */
+	nodeenv node_env;	/* Environment returned by RMS */
+	struct dcd_genericobj dcd_props;	/* Node properties from DCD */
+	struct dsp_cbdata *pargs;	/* Optional args to pass to node */
+	struct ntfy_object *ntfy_obj;	/* Manages registered notifications */
+	char *pstr_dev_name;	/* device name, if device node */
+	struct sync_object *sync_done;	/* Synchronize node_terminate */
+	s32 exit_status;	/* execute function return status */
+
+	/* Information needed for node_get_attr() */
+	void *device_owner;	/* If dev node, task that owns it */
+	u32 num_gpp_inputs;	/* Current # of from GPP streams */
+	u32 num_gpp_outputs;	/* Current # of to GPP streams */
 	/* Current stream connections */
-	struct DSP_STREAMCONNECT *streamConnect;
+	struct dsp_streamconnect *stream_connect;
 
 	/* Message queue */
-	struct MSG_QUEUE *hMsgQueue;
+	struct msg_queue *msg_queue_obj;
 
 	/* These fields used for SM messaging */
-	struct CMM_XLATOROBJECT *hXlator;   /* Node's SM address translator */
+	struct cmm_xlatorobject *xlator;	/* Node's SM addr translator */
 
 	/* Handle to pass to dynamic loader */
-	struct NLDR_NODEOBJECT *hNldrNode;
-	bool fLoaded;		/* Code is (dynamically) loaded */
-	bool fPhaseSplit;	/* Phases split in many libs or ovly */
+	struct nldr_nodeobject *nldr_node_obj;
+	bool loaded;		/* Code is (dynamically) loaded */
+	bool phase_split;	/* Phases split in many libs or ovly */
 
-} ;
+};
 
 /* Default buffer attributes */
-static struct DSP_BUFFERATTR NODE_DFLTBUFATTRS = {
-	0, 			/* cbStruct */
-	1, 			/* uSegment */
-	0, 			/* uAlignment */
+static struct dsp_bufferattr node_dfltbufattrs = {
+	0,			/* cb_struct */
+	1,			/* segment_id */
+	0,			/* buf_alignment */
 };
 
-static void DeleteNode(struct NODE_OBJECT *hNode,
-		struct PROCESS_CONTEXT *pr_ctxt);
-static void DeleteNodeMgr(struct NODE_MGR *hNodeMgr);
-static void FillStreamConnect(struct NODE_OBJECT *hNode1,
-			     struct NODE_OBJECT *hNode2, u32 uStream1,
-			     u32 uStream2);
-static void FillStreamDef(struct NODE_OBJECT *hNode,
-			struct NODE_STRMDEF *pstrmDef,
-			struct DSP_STRMATTR *pAttrs);
-static void FreeStream(struct NODE_MGR *hNodeMgr, struct STREAM stream);
-static DSP_STATUS GetFxnAddress(struct NODE_OBJECT *hNode, u32 *pulFxnAddr,
-				u32 uPhase);
-static DSP_STATUS GetNodeProps(struct DCD_MANAGER *hDcdMgr,
-			       struct NODE_OBJECT *hNode,
-			       CONST struct DSP_UUID *pNodeId,
-			       struct DCD_GENERICOBJ *pdcdProps);
-static DSP_STATUS GetProcProps(struct NODE_MGR *hNodeMgr,
-			      struct DEV_OBJECT *hDevObject);
-static DSP_STATUS GetRMSFxns(struct NODE_MGR *hNodeMgr);
-static u32 Ovly(void *pPrivRef, u32 ulDspRunAddr, u32 ulDspLoadAddr,
-			u32 ulNumBytes, u32 nMemSpace);
-static u32 Write(void *pPrivRef, u32 ulDspAddr, void *pBuf,
-			u32 ulNumBytes, u32 nMemSpace);
-
-#if GT_TRACE
-static struct GT_Mask NODE_debugMask = { NULL, NULL };  /* GT trace variable */
-#endif
+static void delete_node(struct node_object *hnode,
+			struct process_context *pr_ctxt);
+static void delete_node_mgr(struct node_mgr *hnode_mgr);
+static void fill_stream_connect(struct node_object *hNode1,
+				struct node_object *hNode2, u32 uStream1,
+				u32 uStream2);
+static void fill_stream_def(struct node_object *hnode,
+			    struct node_strmdef *pstrm_def,
+			    struct dsp_strmattr *pattrs);
+static void free_stream(struct node_mgr *hnode_mgr, struct stream_chnl stream);
+static dsp_status get_fxn_address(struct node_object *hnode, u32 * pulFxnAddr,
+				  u32 uPhase);
+static dsp_status get_node_props(struct dcd_manager *hdcd_mgr,
+				 struct node_object *hnode,
+				 CONST struct dsp_uuid *pNodeId,
+				 struct dcd_genericobj *pdcdProps);
+static dsp_status get_proc_props(struct node_mgr *hnode_mgr,
+				 struct dev_object *hdev_obj);
+static dsp_status get_rms_fxns(struct node_mgr *hnode_mgr);
+static u32 ovly(void *priv_ref, u32 ulDspRunAddr, u32 ulDspLoadAddr,
+		u32 ul_num_bytes, u32 nMemSpace);
+static u32 mem_write(void *priv_ref, u32 ulDspAddr, void *pbuf,
+		     u32 ul_num_bytes, u32 nMemSpace);
 
 #ifdef DSP_DMM_DEBUG
-extern u32 DMM_MemMapDump(struct DMM_OBJECT *hDmmMgr);
+extern u32 dmm_mem_map_dump(struct dmm_object *dmm_mgr);
 #endif
 
-static u32 cRefs;		/* module reference count */
+static u32 refs;		/* module reference count */
 
 /* Dynamic loader functions. */
-static struct NLDR_FXNS nldrFxns = {
-	NLDR_Allocate,
-	NLDR_Create,
-	NLDR_Delete,
-	NLDR_Exit,
-	NLDR_Free,
-	NLDR_GetFxnAddr,
-	NLDR_Init,
-	NLDR_Load,
-	NLDR_Unload,
+static struct node_ldr_fxns nldr_fxns = {
+	nldr_allocate,
+	nldr_create,
+	nldr_delete,
+	nldr_exit,
+	nldr_get_fxn_addr,
+	nldr_init,
+	nldr_load,
+	nldr_unload,
 };
 
-enum NODE_STATE NODE_GetState(HANDLE hNode)
+enum node_state node_get_state(bhandle hnode)
 {
-       struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-       if (!MEM_IsValidHandle(pNode, NODE_SIGNATURE)) {
-               GT_1trace(NODE_debugMask, GT_5CLASS,
-                "NODE_GetState:hNode 0x%x\n", pNode);
-               return  -1;
-       } else
-               return pNode->nState;
-
+	struct node_object *pnode = (struct node_object *)hnode;
+	if (!MEM_IS_VALID_HANDLE(pnode, NODE_SIGNATURE))
+		return -1;
+	else
+		return pnode->node_state;
 }
 
 /*
- *  ======== NODE_Allocate ========
+ *  ======== node_allocate ========
  *  Purpose:
  *      Allocate GPP resources to manage a node on the DSP.
  */
-DSP_STATUS NODE_Allocate(struct PROC_OBJECT *hProcessor,
-			IN CONST struct DSP_UUID *pNodeId,
-			OPTIONAL IN CONST struct DSP_CBDATA *pArgs,
-			OPTIONAL IN CONST struct DSP_NODEATTRIN *pAttrIn,
-			OUT struct NODE_OBJECT **phNode,
-			struct PROCESS_CONTEXT *pr_ctxt)
-{
-	struct NODE_MGR *hNodeMgr;
-	struct DEV_OBJECT *hDevObject;
-	struct NODE_OBJECT *pNode = NULL;
-	enum NODE_TYPE nodeType = NODE_TASK;
-	struct NODE_MSGARGS *pmsgArgs;
-	struct NODE_TASKARGS *ptaskArgs;
-	u32 uNumStreams;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	DSP_STATUS status = DSP_SOK;
-	struct CMM_OBJECT *hCmmMgr = NULL; /* Shared memory manager hndl */
-	u32 procId;
-	char *label;
-	u32 pulValue;
-	u32 dynextBase;
-	u32 offSet = 0;
-	u32 ulStackSegAddr, ulStackSegVal;
-	u32 ulGppMemBase;
-	struct CFG_HOSTRES hostRes;
-	u32 pMappedAddr = 0;
-	u32 mapAttrs = 0x0;
-	struct DSP_PROCESSORSTATE procStatus;
+dsp_status node_allocate(struct proc_object *hprocessor,
+			 IN CONST struct dsp_uuid *pNodeId,
+			 OPTIONAL IN CONST struct dsp_cbdata *pargs,
+			 OPTIONAL IN CONST struct dsp_nodeattrin *attr_in,
+			 OUT struct node_object **ph_node,
+			 struct process_context *pr_ctxt)
+{
+	struct node_mgr *hnode_mgr;
+	struct dev_object *hdev_obj;
+	struct node_object *pnode = NULL;
+	enum node_type node_type = NODE_TASK;
+	struct node_msgargs *pmsg_args;
+	struct node_taskargs *ptask_args;
+	u32 num_streams;
+	struct bridge_drv_interface *intf_fxns;
+	dsp_status status = DSP_SOK;
+	struct cmm_object *hcmm_mgr = NULL;	/* Shared memory manager hndl */
+	u32 proc_id;
+	u32 pul_value;
+	u32 dynext_base;
+	u32 off_set = 0;
+	u32 ul_stack_seg_addr, ul_stack_seg_val;
+	u32 ul_gpp_mem_base;
+	struct cfg_hostres host_res;
+	u32 mapped_addr = 0;
+	u32 map_attrs = 0x0;
+	struct dsp_processorstate proc_state;
 #ifdef DSP_DMM_DEBUG
-	struct DMM_OBJECT *hDmmMgr;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	struct dmm_object *dmm_mgr;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
 #endif
 
-#ifndef RES_CLEANUP_DISABLE
-	HANDLE	     nodeRes;
-#endif
+	bhandle node_res;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(hProcessor != NULL);
-	DBC_Require(phNode != NULL);
-	DBC_Require(pNodeId != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(hprocessor != NULL);
+	DBC_REQUIRE(ph_node != NULL);
+	DBC_REQUIRE(pNodeId != NULL);
 
-	GT_5trace(NODE_debugMask, GT_ENTER, "NODE_Allocate: \thProcessor: "
-		"0x%x\tpNodeId: 0x%x\tpArgs: 0x%x\tpAttrIn: "
-		"0x%x\tphNode: 0x%x\n", hProcessor, pNodeId, pArgs, pAttrIn,
-		phNode);
+	*ph_node = NULL;
 
-	*phNode = NULL;
+	status = proc_get_processor_id(hprocessor, &proc_id);
 
-	status = PROC_GetProcessorId(hProcessor, &procId);
+	if (proc_id != DSP_UNIT)
+		goto func_end;
 
-	status = PROC_GetDevObject(hProcessor, &hDevObject);
+	status = proc_get_dev_object(hprocessor, &hdev_obj);
 	if (DSP_SUCCEEDED(status)) {
-		status = DEV_GetNodeManager(hDevObject, &hNodeMgr);
-		if (hNodeMgr == NULL)
+		status = dev_get_node_manager(hdev_obj, &hnode_mgr);
+		if (hnode_mgr == NULL)
 			status = DSP_EFAIL;
 
 	}
-	if (procId != DSP_UNIT)
-		goto func_cont;
 
 	if (DSP_FAILED(status))
-		goto func_cont;
+		goto func_end;
 
-	status = PROC_GetState(hProcessor, &procStatus,
-			sizeof(struct DSP_PROCESSORSTATE));
+	status = proc_get_state(hprocessor, &proc_state,
+				sizeof(struct dsp_processorstate));
 	if (DSP_FAILED(status))
 		goto func_end;
 	/* If processor is in error state then don't attempt
-	    to send the message */
-	if (procStatus.iState == PROC_ERROR) {
-		GT_1trace(NODE_debugMask, GT_5CLASS,
-			"NODE_Allocate: proc Status 0x%x\n",
-			procStatus.iState);
+	   to send the message */
+	if (proc_state.proc_state == PROC_ERROR) {
 		status = DSP_EFAIL;
 		goto func_end;
 	}
 
 	/* Assuming that 0 is not a valid function address */
-	if (hNodeMgr->ulFxnAddrs[0] == 0) {
+	if (hnode_mgr->ul_fxn_addrs[0] == 0) {
 		/* No RMS on target - we currently can't handle this */
-		GT_0trace(NODE_debugMask, GT_5CLASS, "No RMS functions in base "
-			 "image. Node allocation fails.\n");
+		pr_err("%s: Failed, no RMS in base image\n", __func__);
 		status = DSP_EFAIL;
 	} else {
-		/* Validate pAttrIn fields, if non-NULL */
-		if (pAttrIn) {
-			/* Check if pAttrIn->iPriority is within range */
-			if (pAttrIn->iPriority < hNodeMgr->nMinPri ||
-			   pAttrIn->iPriority > hNodeMgr->nMaxPri)
+		/* Validate attr_in fields, if non-NULL */
+		if (attr_in) {
+			/* Check if attr_in->prio is within range */
+			if (attr_in->prio < hnode_mgr->min_pri ||
+			    attr_in->prio > hnode_mgr->max_pri)
 				status = DSP_ERANGE;
 		}
 	}
-func_cont:
 	/* Allocate node object and fill in */
 	if (DSP_FAILED(status))
-		goto func_cont2;
+		goto func_end;
 
-	MEM_AllocObject(pNode, struct NODE_OBJECT, NODE_SIGNATURE);
-	if (pNode == NULL) {
+	MEM_ALLOC_OBJECT(pnode, struct node_object, NODE_SIGNATURE);
+	if (pnode == NULL) {
 		status = DSP_EMEMORY;
-		goto func_cont1;
+		goto func_end;
 	}
-	pNode->hNodeMgr = hNodeMgr;
-	/* This critical section protects GetNodeProps */
-	status = SYNC_EnterCS(hNodeMgr->hSync);
-	if (procId != DSP_UNIT)
-		goto func_cont3;
-
-	/* Get DSP_NDBPROPS from node database */
-	status = GetNodeProps(hNodeMgr->hDcdMgr, pNode, pNodeId,
-			     &(pNode->dcdProps));
-	if (DSP_FAILED(status))
-		goto func_cont3;
-
-	pNode->nodeId = *pNodeId;
-	pNode->hProcessor = hProcessor;
-	pNode->nType = pNode->dcdProps.objData.nodeObj.ndbProps.uNodeType;
-	pNode->uTimeout = pNode->dcdProps.objData.nodeObj.ndbProps.uTimeout;
-	pNode->nPriority = pNode->dcdProps.objData.nodeObj.ndbProps.iPriority;
+	pnode->hnode_mgr = hnode_mgr;
+	/* This critical section protects get_node_props */
+	status = sync_enter_cs(hnode_mgr->sync_obj);
+
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/* Get dsp_ndbprops from node database */
+	status = get_node_props(hnode_mgr->hdcd_mgr, pnode, pNodeId,
+				&(pnode->dcd_props));
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	pnode->node_uuid = *pNodeId;
+	pnode->hprocessor = hprocessor;
+	pnode->ntype = pnode->dcd_props.obj_data.node_obj.ndb_props.ntype;
+	pnode->utimeout = pnode->dcd_props.obj_data.node_obj.ndb_props.utimeout;
+	pnode->prio = pnode->dcd_props.obj_data.node_obj.ndb_props.prio;
 
 	/* Currently only C64 DSP builds support Node Dynamic * heaps */
 	/* Allocate memory for node heap */
-	pNode->createArgs.asa.taskArgs.uHeapSize = 0;
-	pNode->createArgs.asa.taskArgs.uDSPHeapAddr = 0;
-	pNode->createArgs.asa.taskArgs.uDSPHeapResAddr = 0;
-	pNode->createArgs.asa.taskArgs.uGPPHeapAddr = 0;
-	if (!pAttrIn)
-		goto func_cont3;
+	pnode->create_args.asa.task_arg_obj.heap_size = 0;
+	pnode->create_args.asa.task_arg_obj.udsp_heap_addr = 0;
+	pnode->create_args.asa.task_arg_obj.udsp_heap_res_addr = 0;
+	pnode->create_args.asa.task_arg_obj.ugpp_heap_addr = 0;
+	if (!attr_in)
+		goto func_cont;
 
 	/* Check if we have a user allocated node heap */
-	if (!(pAttrIn->pGPPVirtAddr))
-		goto func_cont3;
+	if (!(attr_in->pgpp_virt_addr))
+		goto func_cont;
 
 	/* check for page aligned Heap size */
-	if (((pAttrIn->uHeapSize) & (PG_SIZE_4K - 1))) {
-		GT_1trace(NODE_debugMask, GT_7CLASS,
-			 "NODE_Allocate: node heap page size"
-			 " not aligned to 4K page, size=0x%x \n",
-			 pAttrIn->uHeapSize);
+	if (((attr_in->heap_size) & (PG_SIZE4K - 1))) {
+		pr_err("%s: node heap size not aligned to 4K, size = 0x%x \n",
+		       __func__, attr_in->heap_size);
 		status = DSP_EINVALIDARG;
 	} else {
-		pNode->createArgs.asa.taskArgs.uHeapSize = pAttrIn->uHeapSize;
-		pNode->createArgs.asa.taskArgs.uGPPHeapAddr =
-						 (u32)pAttrIn->pGPPVirtAddr;
+		pnode->create_args.asa.task_arg_obj.heap_size =
+		    attr_in->heap_size;
+		pnode->create_args.asa.task_arg_obj.ugpp_heap_addr =
+		    (u32) attr_in->pgpp_virt_addr;
 	}
 	if (DSP_FAILED(status))
-		goto func_cont3;
+		goto func_cont;
 
-	status = PROC_ReserveMemory(hProcessor,
-			pNode->createArgs.asa.taskArgs.uHeapSize + PAGE_SIZE,
-			(void **)&(pNode->createArgs.asa.taskArgs.
-				uDSPHeapResAddr));
+	status = proc_reserve_memory(hprocessor,
+				     pnode->create_args.asa.task_arg_obj.
+				     heap_size + PAGE_SIZE,
+				     (void **)&(pnode->create_args.asa.
+					task_arg_obj.udsp_heap_res_addr),
+				     pr_ctxt);
 	if (DSP_FAILED(status)) {
-		GT_1trace(NODE_debugMask, GT_5CLASS,
-			 "NODE_Allocate:Failed to reserve "
-			 "memory for Heap: 0x%x\n", status);
-	} else {
-		GT_1trace(NODE_debugMask, GT_5CLASS,
-			 "NODE_Allocate: DSPProcessor_Reserve"
-			 " Memory successful: 0x%x\n", status);
+		pr_err("%s: Failed to reserve memory for heap: 0x%x\n",
+		       __func__, status);
+		goto func_cont;
 	}
 #ifdef DSP_DMM_DEBUG
-	status = DMM_GetHandle(pProcObject, &hDmmMgr);
-	if (DSP_SUCCEEDED(status))
-		DMM_MemMapDump(hDmmMgr);
-#endif
+	status = dmm_get_handle(p_proc_object, &dmm_mgr);
 	if (DSP_FAILED(status))
-		goto func_cont3;
+		goto func_cont;
 
-	mapAttrs |= DSP_MAPLITTLEENDIAN;
-	mapAttrs |= DSP_MAPELEMSIZE32;
-	mapAttrs |= DSP_MAPVIRTUALADDR;
-	status = PROC_Map(hProcessor, (void *)pAttrIn->pGPPVirtAddr,
-			pNode->createArgs.asa.taskArgs.uHeapSize,
-			(void *)pNode->createArgs.asa.taskArgs.uDSPHeapResAddr,
-			(void **)&pMappedAddr, mapAttrs, pr_ctxt);
-	if (DSP_FAILED(status)) {
-		GT_1trace(NODE_debugMask, GT_5CLASS,
-			 "NODE_Allocate: Failed to map memory"
-			 " for Heap: 0x%x\n", status);
-	} else {
-		pNode->createArgs.asa.taskArgs.uDSPHeapAddr =
-			(u32) pMappedAddr;
-		GT_1trace(NODE_debugMask, GT_5CLASS,
-			 "NODE_Allocate:DSPProcessor_Map"
-			 " successful: 0x%x\n", status);
-	}
+	dmm_mem_map_dump(dmm_mgr);
+#endif
 
-func_cont3:
-	(void)SYNC_LeaveCS(hNodeMgr->hSync);
-func_cont1:
-	if (pAttrIn != NULL) {
+	map_attrs |= DSP_MAPLITTLEENDIAN;
+	map_attrs |= DSP_MAPELEMSIZE32;
+	map_attrs |= DSP_MAPVIRTUALADDR;
+	status = proc_map(hprocessor, (void *)attr_in->pgpp_virt_addr,
+			  pnode->create_args.asa.task_arg_obj.heap_size,
+			  (void *)pnode->create_args.asa.task_arg_obj.
+			  udsp_heap_res_addr, (void **)&mapped_addr, map_attrs,
+			  pr_ctxt);
+	if (DSP_FAILED(status))
+		pr_err("%s: Failed to map memory for Heap: 0x%x\n",
+		       __func__, status);
+	else
+		pnode->create_args.asa.task_arg_obj.udsp_heap_addr =
+		    (u32) mapped_addr;
+
+func_cont:
+	(void)sync_leave_cs(hnode_mgr->sync_obj);
+	if (attr_in != NULL) {
 		/* Overrides of NBD properties */
-		pNode->uTimeout = pAttrIn->uTimeout;
-		pNode->nPriority = pAttrIn->iPriority;
+		pnode->utimeout = attr_in->utimeout;
+		pnode->prio = attr_in->prio;
 	}
-func_cont2:
 	/* Create object to manage notifications */
 	if (DSP_SUCCEEDED(status))
-		status = NTFY_Create(&pNode->hNtfy);
+		status = ntfy_create(&pnode->ntfy_obj);
 
 	if (DSP_SUCCEEDED(status)) {
-		nodeType = NODE_GetType(pNode);
-		 /*  Allocate DSP_STREAMCONNECT array for device, task, and
-		 *  dais socket nodes.  */
-		if (nodeType != NODE_MESSAGE) {
-			uNumStreams = MaxInputs(pNode) + MaxOutputs(pNode);
-			pNode->streamConnect = MEM_Calloc(uNumStreams *
-					       sizeof(struct DSP_STREAMCONNECT),
-					       MEM_PAGED);
-			if (uNumStreams > 0 && pNode->streamConnect == NULL)
+		node_type = node_get_type(pnode);
+		/*  Allocate dsp_streamconnect array for device, task, and
+		 *  dais socket nodes. */
+		if (node_type != NODE_MESSAGE) {
+			num_streams = MAX_INPUTS(pnode) + MAX_OUTPUTS(pnode);
+			pnode->stream_connect = mem_calloc(num_streams *
+					sizeof(struct dsp_streamconnect),
+					MEM_PAGED);
+			if (num_streams > 0 && pnode->stream_connect == NULL)
 				status = DSP_EMEMORY;
 
 		}
-		if (DSP_SUCCEEDED(status) && (nodeType == NODE_TASK ||
-		   nodeType == NODE_DAISSOCKET)) {
+		if (DSP_SUCCEEDED(status) && (node_type == NODE_TASK ||
+					      node_type == NODE_DAISSOCKET)) {
 			/* Allocate arrays for maintainig stream connections */
-			pNode->inputs =
-				MEM_Calloc(MaxInputs(pNode) *
-					sizeof(struct STREAM), MEM_PAGED);
-			pNode->outputs =
-				MEM_Calloc(MaxOutputs(pNode) *
-					sizeof(struct STREAM), MEM_PAGED);
-			ptaskArgs = &(pNode->createArgs.asa.taskArgs);
-			ptaskArgs->strmInDef =
-				MEM_Calloc(MaxInputs(pNode) *
-					sizeof(struct NODE_STRMDEF),
-					MEM_PAGED);
-			ptaskArgs->strmOutDef =
-					MEM_Calloc(MaxOutputs(pNode) *
-						sizeof(struct NODE_STRMDEF),
-						MEM_PAGED);
-			if ((MaxInputs(pNode) > 0 && (pNode->inputs == NULL ||
-			   ptaskArgs->strmInDef == NULL)) ||
-			   (MaxOutputs(pNode) > 0 && (pNode->outputs == NULL ||
-			   ptaskArgs->strmOutDef == NULL)))
+			pnode->inputs =
+			    mem_calloc(MAX_INPUTS(pnode) *
+				       sizeof(struct stream_chnl), MEM_PAGED);
+			pnode->outputs =
+			    mem_calloc(MAX_OUTPUTS(pnode) *
+				       sizeof(struct stream_chnl), MEM_PAGED);
+			ptask_args = &(pnode->create_args.asa.task_arg_obj);
+			ptask_args->strm_in_def =
+			    mem_calloc(MAX_INPUTS(pnode) *
+				       sizeof(struct node_strmdef), MEM_PAGED);
+			ptask_args->strm_out_def =
+			    mem_calloc(MAX_OUTPUTS(pnode) *
+				       sizeof(struct node_strmdef), MEM_PAGED);
+			if ((MAX_INPUTS(pnode) > 0 && (pnode->inputs == NULL ||
+						       ptask_args->strm_in_def
+						       == NULL))
+			    || (MAX_OUTPUTS(pnode) > 0
+				&& (pnode->outputs == NULL
+				    || ptask_args->strm_out_def == NULL)))
 				status = DSP_EMEMORY;
 		}
 	}
-	if (DSP_SUCCEEDED(status) && (nodeType != NODE_DEVICE)) {
+	if (DSP_SUCCEEDED(status) && (node_type != NODE_DEVICE)) {
 		/* Create an event that will be posted when RMS_EXIT is
 		 * received. */
-		status = SYNC_OpenEvent(&pNode->hSyncDone, NULL);
+		status = sync_open_event(&pnode->sync_done, NULL);
 		if (DSP_SUCCEEDED(status)) {
 			/*Get the shared mem mgr for this nodes dev object */
-			status = CMM_GetHandle(hProcessor, &hCmmMgr);
-			if (DSP_FAILED(status)) {
-				GT_1trace(NODE_debugMask, GT_5CLASS,
-					 "NODE_Allocate: Failed to"
-					 " get CMM Mgr handle: 0x%x\n", status);
-			} else {
+			status = cmm_get_handle(hprocessor, &hcmm_mgr);
+			if (DSP_SUCCEEDED(status)) {
 				/* Allocate a SM addr translator for this node
 				 * w/ deflt attr */
-				status = CMM_XlatorCreate(&pNode->hXlator,
-					 hCmmMgr, NULL);
-				if (DSP_FAILED(status)) {
-					GT_1trace(NODE_debugMask, GT_5CLASS,
-					    "NODE_Allocate: Failed"
-					    " to create SM translator: 0x%x\n",
-					    status);
-				}
+				status = cmm_xlator_create(&pnode->xlator,
+							   hcmm_mgr, NULL);
 			}
 		}
 		if (DSP_SUCCEEDED(status)) {
 			/* Fill in message args */
-			if ((pArgs != NULL) && (pArgs->cbData > 0)) {
-				pmsgArgs = &(pNode->createArgs.asa.msgArgs);
-				pmsgArgs->pData = MEM_Calloc(pArgs->cbData,
-							    MEM_PAGED);
-				if (pmsgArgs->pData == NULL) {
+			if ((pargs != NULL) && (pargs->cb_data > 0)) {
+				pmsg_args =
+				    &(pnode->create_args.asa.node_msg_args);
+				pmsg_args->pdata =
+				    mem_calloc(pargs->cb_data, MEM_PAGED);
+				if (pmsg_args->pdata == NULL) {
 					status = DSP_EMEMORY;
 				} else {
-					pmsgArgs->uArgLength = pArgs->cbData;
-					memcpy(pmsgArgs->pData, pArgs->cData,
-					      pArgs->cbData);
+					pmsg_args->arg_length = pargs->cb_data;
+					memcpy(pmsg_args->pdata,
+					       pargs->node_data,
+					       pargs->cb_data);
 				}
 			}
 		}
 	}
 
-	if (DSP_SUCCEEDED(status) && nodeType != NODE_DEVICE) {
+	if (DSP_SUCCEEDED(status) && node_type != NODE_DEVICE) {
 		/* Create a message queue for this node */
-		pIntfFxns = hNodeMgr->pIntfFxns;
-		status = (*pIntfFxns->pfnMsgCreateQueue)(hNodeMgr->hMsg,
-				&pNode->hMsgQueue, 0,
-				    pNode->createArgs.asa.msgArgs.uMaxMessages,
-				    pNode);
+		intf_fxns = hnode_mgr->intf_fxns;
+		status =
+		    (*intf_fxns->pfn_msg_create_queue) (hnode_mgr->msg_mgr_obj,
+							&pnode->msg_queue_obj,
+							0,
+							pnode->create_args.asa.
+							node_msg_args.max_msgs,
+							pnode);
 	}
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Create object for dynamic loading */
 
-		status = hNodeMgr->nldrFxns.pfnAllocate(hNodeMgr->hNldr,
-					     (void *) pNode,
-					     &pNode->dcdProps.objData.nodeObj,
-					     &pNode->hNldrNode,
-					     &pNode->fPhaseSplit);
-		if (DSP_FAILED(status)) {
-			GT_1trace(NODE_debugMask, GT_5CLASS,
-				 "NODE_Allocate: Failed to "
-				 "allocate NLDR node: 0x%x\n", status);
-		}
+		status = hnode_mgr->nldr_fxns.pfn_allocate(hnode_mgr->nldr_obj,
+							   (void *)pnode,
+							   &pnode->dcd_props.
+							   obj_data.node_obj,
+							   &pnode->
+							   nldr_node_obj,
+							   &pnode->phase_split);
 	}
 
-	/* Comapare value read from Node Properties and check if it is same as
+	/* Compare value read from Node Properties and check if it is same as
 	 * STACKSEGLABEL, if yes read the Address of STACKSEGLABEL, calculate
 	 * GPP Address, Read the value in that address and override the
-	 * uStackSeg value in task args */
+	 * stack_seg value in task args */
 	if (DSP_SUCCEEDED(status) &&
-	   (char *)pNode->dcdProps.objData.nodeObj.ndbProps.uStackSegName !=
-	   NULL) {
-		label = MEM_Calloc(sizeof(STACKSEGLABEL)+1, MEM_PAGED);
-               strncpy(label, STACKSEGLABEL, sizeof(STACKSEGLABEL)+1);
-
-               if (strcmp((char *)pNode->dcdProps.objData.nodeObj.
-				     ndbProps.uStackSegName, label) == 0) {
-			status = hNodeMgr->nldrFxns.pfnGetFxnAddr(pNode->
-				 hNldrNode, "DYNEXT_BEG", &dynextBase);
-			if (DSP_FAILED(status)) {
-				GT_1trace(NODE_debugMask, GT_5CLASS,
-				"NODE_Allocate: Failed to get Address for "
-				"DYNEXT_BEG: 0x%x\n", status);
-			}
+	    (char *)pnode->dcd_props.obj_data.node_obj.ndb_props.
+	    stack_seg_name != NULL) {
+		if (strcmp((char *)
+			   pnode->dcd_props.obj_data.node_obj.ndb_props.
+			   stack_seg_name, STACKSEGLABEL) == 0) {
+			status =
+			    hnode_mgr->nldr_fxns.
+			    pfn_get_fxn_addr(pnode->nldr_node_obj, "DYNEXT_BEG",
+					     &dynext_base);
+			if (DSP_FAILED(status))
+				pr_err("%s: Failed to get addr for DYNEXT_BEG"
+				       " status = 0x%x\n", __func__, status);
 
-			status = hNodeMgr->nldrFxns.pfnGetFxnAddr(pNode->
-				 hNldrNode, "L1DSRAM_HEAP", &pulValue);
+			status =
+			    hnode_mgr->nldr_fxns.
+			    pfn_get_fxn_addr(pnode->nldr_node_obj,
+					     "L1DSRAM_HEAP", &pul_value);
 
-			if (DSP_FAILED(status)) {
-				GT_1trace(NODE_debugMask, GT_5CLASS,
-				"NODE_Allocate: Failed to get Address for "
-				"L1DSRAM_HEAP: 0x%x\n", status);
-			}
+			if (DSP_FAILED(status))
+				pr_err("%s: Failed to get addr for L1DSRAM_HEAP"
+				       " status = 0x%x\n", __func__, status);
 
-			status = CFG_GetHostResources((struct CFG_DEVNODE *)
-				 DRV_GetFirstDevExtension(), &hostRes);
+			status = cfg_get_host_resources((struct cfg_devnode *)
+						drv_get_first_dev_extension(),
+						&host_res);
 
 			if (DSP_FAILED(status)) {
-				GT_1trace(NODE_debugMask, GT_5CLASS,
-				"NODE_Allocate: Failed to get host resource "
-				"0x%x\n", status);
+				pr_err("%s: Failed to get host resource, status"
+				       " = 0x%x\n", __func__, status);
+				goto func_end;
 			}
 
-			ulGppMemBase = (u32)hostRes.dwMemBase[1];
-			offSet = pulValue - dynextBase;
-			ulStackSegAddr = ulGppMemBase + offSet;
-			ulStackSegVal = (u32)*((REG_UWORD32 *)
-					((u32)(ulStackSegAddr)));
-
-			GT_1trace(NODE_debugMask, GT_5CLASS,
-				 "StackSegVal =0x%x\n", ulStackSegVal);
-			GT_1trace(NODE_debugMask, GT_5CLASS,
-				 "ulStackSegAddr = 0x%x\n", ulStackSegAddr);
+			ul_gpp_mem_base = (u32) host_res.dw_mem_base[1];
+			off_set = pul_value - dynext_base;
+			ul_stack_seg_addr = ul_gpp_mem_base + off_set;
+			ul_stack_seg_val = (u32) *((reg_uword32 *)
+						    ((u32)
+						     (ul_stack_seg_addr)));
+
+			dev_dbg(bridge, "%s: StackSegVal = 0x%x, StackSegAddr ="
+				" 0x%x\n", __func__, ul_stack_seg_val,
+				ul_stack_seg_addr);
 
-			pNode->createArgs.asa.taskArgs.uStackSeg =
-				ulStackSegVal;
+			pnode->create_args.asa.task_arg_obj.stack_seg =
+			    ul_stack_seg_val;
 
 		}
-
-		if (label)
-			MEM_Free(label);
-
 	}
 
-
 	if (DSP_SUCCEEDED(status)) {
 		/* Add the node to the node manager's list of allocated
 		 * nodes. */
-		LST_InitElem((struct LST_ELEM *)pNode);
-		NODE_SetState(pNode, NODE_ALLOCATED);
+		lst_init_elem((struct list_head *)pnode);
+		NODE_SET_STATE(pnode, NODE_ALLOCATED);
 
-		status = SYNC_EnterCS(hNodeMgr->hSync);
+		status = sync_enter_cs(hnode_mgr->sync_obj);
 
 		if (DSP_SUCCEEDED(status)) {
-			LST_PutTail(hNodeMgr->nodeList,
-			(struct LST_ELEM *) pNode);
-			++(hNodeMgr->uNumNodes);
+			lst_put_tail(hnode_mgr->node_list,
+				     (struct list_head *)pnode);
+			++(hnode_mgr->num_nodes);
 		}
 
 		/* Exit critical section */
-		(void) SYNC_LeaveCS(hNodeMgr->hSync);
+		(void)sync_leave_cs(hnode_mgr->sync_obj);
 
 		/* Preset this to assume phases are split
 		 * (for overlay and dll) */
-		pNode->fPhaseSplit = true;
+		pnode->phase_split = true;
 
 		if (DSP_SUCCEEDED(status))
-			*phNode = pNode;
-
+			*ph_node = pnode;
 
 		/* Notify all clients registered for DSP_NODESTATECHANGE. */
-		PROC_NotifyAllClients(hProcessor, DSP_NODESTATECHANGE);
+		proc_notify_all_clients(hprocessor, DSP_NODESTATECHANGE);
 	} else {
 		/* Cleanup */
-		if (pNode)
-			DeleteNode(pNode, pr_ctxt);
+		if (pnode)
+			delete_node(pnode, pr_ctxt);
 
 	}
 
-#ifndef RES_CLEANUP_DISABLE
 	if (DSP_SUCCEEDED(status)) {
-		DRV_InsertNodeResElement(*phNode, &nodeRes, pr_ctxt);
-		DRV_ProcNodeUpdateHeapStatus(nodeRes, true);
-		DRV_ProcNodeUpdateStatus(nodeRes, true);
+		drv_insert_node_res_element(*ph_node, &node_res, pr_ctxt);
+		drv_proc_node_update_heap_status(node_res, true);
+		drv_proc_node_update_status(node_res, true);
 	}
-#endif
-	DBC_Ensure((DSP_FAILED(status) && (*phNode == NULL)) ||
-		  (DSP_SUCCEEDED(status)
-		    && MEM_IsValidHandle((*phNode), NODE_SIGNATURE)));
+	DBC_ENSURE((DSP_FAILED(status) && (*ph_node == NULL)) ||
+		   (DSP_SUCCEEDED(status)
+		    && MEM_IS_VALID_HANDLE((*ph_node), NODE_SIGNATURE)));
 func_end:
+	dev_dbg(bridge, "%s: hprocessor: %p pNodeId: %p pargs: %p attr_in: %p "
+		"ph_node: %p status: 0x%x\n", __func__, hprocessor,
+		pNodeId, pargs, attr_in, ph_node, status);
 	return status;
 }
 
 /*
- *  ======== NODE_AllocMsgBuf ========
+ *  ======== node_alloc_msg_buf ========
  *  Purpose:
  *      Allocates buffer for zero copy messaging.
  */
-DBAPI NODE_AllocMsgBuf(struct NODE_OBJECT *hNode, u32 uSize,
-		       OPTIONAL IN OUT struct DSP_BUFFERATTR *pAttr,
-		       OUT u8 **pBuffer)
-{
-	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-	DSP_STATUS status = DSP_SOK;
-	bool bVirtAddr = false;
-	bool bSetInfo;
-	u32 procId;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pBuffer != NULL);
+DBAPI node_alloc_msg_buf(struct node_object *hnode, u32 usize,
+			 OPTIONAL IN OUT struct dsp_bufferattr *pattr,
+			 OUT u8 **pbuffer)
+{
+	struct node_object *pnode = (struct node_object *)hnode;
+	dsp_status status = DSP_SOK;
+	bool va_flag = false;
+	bool set_info;
+	u32 proc_id;
 
-	DBC_Require(uSize > 0);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pbuffer != NULL);
 
-	GT_4trace(NODE_debugMask, GT_ENTER,
-		 "NODE_AllocMsgBuf: hNode: 0x%x\tuSize:"
-		 " 0x%x\tpAttr: 0x%x\tpBuffer: %d\n", pNode, uSize, pAttr,
-		 pBuffer);
+	DBC_REQUIRE(usize > 0);
 
-	if (!MEM_IsValidHandle(pNode, NODE_SIGNATURE))
+	if (!MEM_IS_VALID_HANDLE(pnode, NODE_SIGNATURE))
 		status = DSP_EHANDLE;
-	else if (NODE_GetType(pNode) == NODE_DEVICE)
+	else if (node_get_type(pnode) == NODE_DEVICE)
 		status = DSP_ENODETYPE;
 
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	if (pAttr == NULL)
-		pAttr = &NODE_DFLTBUFATTRS;	/* set defaults */
+	if (pattr == NULL)
+		pattr = &node_dfltbufattrs;	/* set defaults */
 
-	status = PROC_GetProcessorId(pNode->hProcessor, &procId);
-	if (procId != DSP_UNIT) {
-		DBC_Assert(NULL);
+	status = proc_get_processor_id(pnode->hprocessor, &proc_id);
+	if (proc_id != DSP_UNIT) {
+		DBC_ASSERT(NULL);
 		goto func_end;
 	}
-	 /*  If segment ID includes MEM_SETVIRTUALSEGID then pBuffer is a
+	/*  If segment ID includes MEM_SETVIRTUALSEGID then pbuffer is a
 	 *  virt  address, so set this info in this node's translator
 	 *  object for  future ref. If MEM_GETVIRTUALSEGID then retrieve
-	 *  virtual address  from node's translator.  */
-	if ((pAttr->uSegment & MEM_SETVIRTUALSEGID) ||
-			    (pAttr->uSegment & MEM_GETVIRTUALSEGID)) {
-		bVirtAddr = true;
-		bSetInfo = (pAttr->uSegment & MEM_SETVIRTUALSEGID) ?
-			   true : false;
-		pAttr->uSegment &= ~MEM_MASKVIRTUALSEGID; /* clear mask bits */
+	 *  virtual address  from node's translator. */
+	if ((pattr->segment_id & MEM_SETVIRTUALSEGID) ||
+	    (pattr->segment_id & MEM_GETVIRTUALSEGID)) {
+		va_flag = true;
+		set_info = (pattr->segment_id & MEM_SETVIRTUALSEGID) ?
+		    true : false;
+		/* Clear mask bits */
+		pattr->segment_id &= ~MEM_MASKVIRTUALSEGID;
 		/* Set/get this node's translators virtual address base/size */
-		status = CMM_XlatorInfo(pNode->hXlator, pBuffer, uSize,
-					pAttr->uSegment, bSetInfo);
-		if (DSP_FAILED(status)) {
-			GT_1trace(NODE_debugMask, GT_7CLASS,
-				 "NODE_AllocMsgBuf "
-				 "failed: 0x%lx\n", status);
-		}
+		status = cmm_xlator_info(pnode->xlator, pbuffer, usize,
+					 pattr->segment_id, set_info);
 	}
-	if (DSP_SUCCEEDED(status) && (!bVirtAddr)) {
-		if (pAttr->uSegment != 1) {
+	if (DSP_SUCCEEDED(status) && (!va_flag)) {
+		if (pattr->segment_id != 1) {
 			/* Node supports single SM segment only. */
 			status = DSP_EBADSEGID;
 		}
-		 /*  Arbitrary SM buffer alignment not supported for host side
-		  *  allocs, but guaranteed for the following alignment
-		  *  values.  */
-		switch (pAttr->uAlignment) {
+		/*  Arbitrary SM buffer alignment not supported for host side
+		 *  allocs, but guaranteed for the following alignment
+		 *  values. */
+		switch (pattr->buf_alignment) {
 		case 0:
 		case 1:
 		case 2:
@@ -879,14 +745,13 @@
 			break;
 		}
 		if (DSP_SUCCEEDED(status)) {
-			/* allocate physical buffer from segId in node's
+			/* allocate physical buffer from seg_id in node's
 			 * translator */
-			(void)CMM_XlatorAllocBuf(pNode->hXlator, pBuffer,
-						 uSize);
-			if (*pBuffer == NULL) {
-				GT_0trace(NODE_debugMask, GT_7CLASS,
-					 "NODE_AllocMsgBuf: "
-					 "ERROR: Out of shared memory.\n");
+			(void)cmm_xlator_alloc_buf(pnode->xlator, pbuffer,
+						   usize);
+			if (*pbuffer == NULL) {
+				pr_err("%s: error - Out of shared memory\n",
+				       __func__);
 				status = DSP_EMEMORY;
 			}
 		}
@@ -896,117 +761,106 @@
 }
 
 /*
- *  ======== NODE_ChangePriority ========
+ *  ======== node_change_priority ========
  *  Purpose:
  *      Change the priority of a node in the allocated state, or that is
  *      currently running or paused on the target.
  */
-DSP_STATUS NODE_ChangePriority(struct NODE_OBJECT *hNode, s32 nPriority)
+dsp_status node_change_priority(struct node_object *hnode, s32 prio)
 {
-	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-	struct NODE_MGR *hNodeMgr = NULL;
-	enum NODE_TYPE nodeType;
-	enum NODE_STATE state;
-	DSP_STATUS status = DSP_SOK;
-	u32 procId;
-
-	DBC_Require(cRefs > 0);
-
-	GT_2trace(NODE_debugMask, GT_ENTER, "NODE_ChangePriority: "
-		 "hNode: 0x%x\tnPriority: %d\n", hNode, nPriority);
-
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-		GT_1trace(NODE_debugMask, GT_7CLASS,
-			 "Invalid NODE Handle: 0x%x\n", hNode);
+	struct node_object *pnode = (struct node_object *)hnode;
+	struct node_mgr *hnode_mgr = NULL;
+	enum node_type node_type;
+	enum node_state state;
+	dsp_status status = DSP_SOK;
+	u32 proc_id;
+
+	DBC_REQUIRE(refs > 0);
+
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE) || !hnode->hnode_mgr) {
 		status = DSP_EHANDLE;
 	} else {
-		hNodeMgr = hNode->hNodeMgr;
-		nodeType = NODE_GetType(hNode);
-		if (nodeType != NODE_TASK && nodeType != NODE_DAISSOCKET)
+		hnode_mgr = hnode->hnode_mgr;
+		node_type = node_get_type(hnode);
+		if (node_type != NODE_TASK && node_type != NODE_DAISSOCKET)
 			status = DSP_ENODETYPE;
-		else if (nPriority < hNodeMgr->nMinPri ||
-				nPriority > hNodeMgr->nMaxPri)
-				status = DSP_ERANGE;
+		else if (prio < hnode_mgr->min_pri || prio > hnode_mgr->max_pri)
+			status = DSP_ERANGE;
 	}
 	if (DSP_FAILED(status))
 		goto func_end;
 
 	/* Enter critical section */
-	status = SYNC_EnterCS(hNodeMgr->hSync);
+	status = sync_enter_cs(hnode_mgr->sync_obj);
 	if (DSP_FAILED(status))
-		goto func_cont;
+		goto func_end;
 
-	state = NODE_GetState(hNode);
+	state = node_get_state(hnode);
 	if (state == NODE_ALLOCATED || state == NODE_PAUSED) {
-		NODE_SetPriority(hNode, nPriority);
+		NODE_SET_PRIORITY(hnode, prio);
 	} else {
 		if (state != NODE_RUNNING) {
 			status = DSP_EWRONGSTATE;
 			goto func_cont;
 		}
-		if (DSP_SUCCEEDED(status)) {
-			status = PROC_GetProcessorId(pNode->hProcessor,
-						    &procId);
-			if (procId == DSP_UNIT) {
-				status = DISP_NodeChangePriority(hNodeMgr->
-				    hDisp, hNode,
-				    hNodeMgr->ulFxnAddrs[RMSCHANGENODEPRIORITY],
-				    hNode->nodeEnv, nPriority);
-			}
-			if (DSP_SUCCEEDED(status))
-				NODE_SetPriority(hNode, nPriority);
-
+		status = proc_get_processor_id(pnode->hprocessor, &proc_id);
+		if (proc_id == DSP_UNIT) {
+			status =
+			    disp_node_change_priority(hnode_mgr->disp_obj,
+						      hnode,
+						      hnode_mgr->ul_fxn_addrs
+						      [RMSCHANGENODEPRIORITY],
+						      hnode->node_env, prio);
 		}
+		if (DSP_SUCCEEDED(status))
+			NODE_SET_PRIORITY(hnode, prio);
+
 	}
 func_cont:
-		/* Leave critical section */
-		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	/* Leave critical section */
+	(void)sync_leave_cs(hnode_mgr->sync_obj);
 func_end:
 	return status;
 }
 
 /*
- *  ======== NODE_Connect ========
+ *  ======== node_connect ========
  *  Purpose:
  *      Connect two nodes on the DSP, or a node on the DSP to the GPP.
  */
-DSP_STATUS NODE_Connect(struct NODE_OBJECT *hNode1, u32 uStream1,
-			struct NODE_OBJECT *hNode2,
-			u32 uStream2, OPTIONAL IN struct DSP_STRMATTR *pAttrs,
-			OPTIONAL IN struct DSP_CBDATA *pConnParam)
-{
-	struct NODE_MGR *hNodeMgr;
-	char *pstrDevName = NULL;
-	enum NODE_TYPE node1Type = NODE_TASK;
-	enum NODE_TYPE node2Type = NODE_TASK;
-	struct NODE_STRMDEF *pstrmDef;
-	struct NODE_STRMDEF *pInput = NULL;
-	struct NODE_STRMDEF *pOutput = NULL;
-	struct NODE_OBJECT *hDevNode;
-	struct NODE_OBJECT *hNode;
-	struct STREAM *pStream;
-	GB_BitNum pipeId = GB_NOBITS;
-	GB_BitNum chnlId = GB_NOBITS;
-	CHNL_MODE uMode;
-	u32 dwLength;
-	DSP_STATUS status = DSP_SOK;
-	DBC_Require(cRefs > 0);
-	GT_5trace(NODE_debugMask, GT_ENTER,
-		 "NODE_Connect: hNode1: 0x%x\tuStream1:"
-		 " %d\thNode2: 0x%x\tuStream2: %d\tpAttrs: 0x%x\n", hNode1,
-		 uStream1, hNode2, uStream2, pAttrs);
-	if (DSP_SUCCEEDED(status)) {
-		if ((hNode1 != (struct NODE_OBJECT *) DSP_HGPPNODE &&
-		   !MEM_IsValidHandle(hNode1, NODE_SIGNATURE)) ||
-		   (hNode2 != (struct NODE_OBJECT *) DSP_HGPPNODE &&
-		   !MEM_IsValidHandle(hNode2, NODE_SIGNATURE)))
-			status = DSP_EHANDLE;
-	}
+dsp_status node_connect(struct node_object *hNode1, u32 uStream1,
+			struct node_object *hNode2,
+			u32 uStream2, OPTIONAL IN struct dsp_strmattr *pattrs,
+			OPTIONAL IN struct dsp_cbdata *conn_param)
+{
+	struct node_mgr *hnode_mgr;
+	char *pstr_dev_name = NULL;
+	enum node_type node1_type = NODE_TASK;
+	enum node_type node2_type = NODE_TASK;
+	struct node_strmdef *pstrm_def;
+	struct node_strmdef *input = NULL;
+	struct node_strmdef *output = NULL;
+	struct node_object *dev_node_obj;
+	struct node_object *hnode;
+	struct stream_chnl *pstream;
+	gb_bit_num pipe_id = GB_NOBITS;
+	gb_bit_num chnl_id = GB_NOBITS;
+	short int chnl_mode;
+	u32 dw_length;
+	dsp_status status = DSP_SOK;
+	DBC_REQUIRE(refs > 0);
+
+	if ((hNode1 != (struct node_object *)DSP_HGPPNODE &&
+	     !MEM_IS_VALID_HANDLE(hNode1, NODE_SIGNATURE)) ||
+	    (hNode2 != (struct node_object *)DSP_HGPPNODE &&
+	     !MEM_IS_VALID_HANDLE(hNode2, NODE_SIGNATURE)))
+		status = DSP_EHANDLE;
+
 	if (DSP_SUCCEEDED(status)) {
 		/* The two nodes must be on the same processor */
-		if (hNode1 != (struct NODE_OBJECT *)DSP_HGPPNODE &&
-		   hNode2 != (struct NODE_OBJECT *)DSP_HGPPNODE &&
-		   hNode1->hNodeMgr != hNode2->hNodeMgr)
+		if (hNode1 != (struct node_object *)DSP_HGPPNODE &&
+		    hNode2 != (struct node_object *)DSP_HGPPNODE &&
+		    hNode1->hnode_mgr != hNode2->hnode_mgr)
 			status = DSP_EFAIL;
 		/* Cannot connect a node to itself */
 		if (hNode1 == hNode2)
@@ -1014,14 +868,17 @@
 
 	}
 	if (DSP_SUCCEEDED(status)) {
-		/* NODE_GetType() will return NODE_GPP if hNode =
+		/* node_get_type() will return NODE_GPP if hnode =
 		 * DSP_HGPPNODE. */
-		node1Type = NODE_GetType(hNode1);
-		node2Type = NODE_GetType(hNode2);
-	/* Check stream indices ranges */
-		if ((node1Type != NODE_GPP && node1Type != NODE_DEVICE &&
-		   uStream1 >= MaxOutputs(hNode1)) || (node2Type != NODE_GPP &&
-		   node2Type != NODE_DEVICE && uStream2 >= MaxInputs(hNode2)))
+		node1_type = node_get_type(hNode1);
+		node2_type = node_get_type(hNode2);
+		/* Check stream indices ranges */
+		if ((node1_type != NODE_GPP && node1_type != NODE_DEVICE &&
+		     uStream1 >= MAX_OUTPUTS(hNode1)) || (node2_type != NODE_GPP
+							  && node2_type !=
+							  NODE_DEVICE
+							  && uStream2 >=
+							  MAX_INPUTS(hNode2)))
 			status = DSP_EVALUE;
 	}
 	if (DSP_SUCCEEDED(status)) {
@@ -1034,964 +891,924 @@
 		 *  ie, no message nodes, and at least one task or dais
 		 *  socket node.
 		 */
-		if (node1Type == NODE_MESSAGE || node2Type == NODE_MESSAGE ||
-		    (node1Type != NODE_TASK && node1Type != NODE_DAISSOCKET &&
-		     node2Type != NODE_TASK && node2Type != NODE_DAISSOCKET))
+		if (node1_type == NODE_MESSAGE || node2_type == NODE_MESSAGE ||
+		    (node1_type != NODE_TASK && node1_type != NODE_DAISSOCKET &&
+		     node2_type != NODE_TASK && node2_type != NODE_DAISSOCKET))
 			status = DSP_EFAIL;
 	}
 	/*
 	 * Check stream mode. Default is STRMMODE_PROCCOPY.
 	 */
-	if (DSP_SUCCEEDED(status) && pAttrs) {
-		if (pAttrs->lMode != STRMMODE_PROCCOPY)
+	if (DSP_SUCCEEDED(status) && pattrs) {
+		if (pattrs->strm_mode != STRMMODE_PROCCOPY)
 			status = DSP_ESTRMMODE;	/* illegal stream mode */
 
 	}
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	if (node1Type != NODE_GPP) {
-		hNodeMgr = hNode1->hNodeMgr;
+	if (node1_type != NODE_GPP) {
+		hnode_mgr = hNode1->hnode_mgr;
 	} else {
-		DBC_Assert(hNode2 != (struct NODE_OBJECT *)DSP_HGPPNODE);
-		hNodeMgr = hNode2->hNodeMgr;
+		DBC_ASSERT(hNode2 != (struct node_object *)DSP_HGPPNODE);
+		hnode_mgr = hNode2->hnode_mgr;
 	}
 	/* Enter critical section */
-	status = SYNC_EnterCS(hNodeMgr->hSync);
+	status = sync_enter_cs(hnode_mgr->sync_obj);
 	if (DSP_FAILED(status))
 		goto func_cont;
 
 	/* Nodes must be in the allocated state */
-	if (node1Type != NODE_GPP && NODE_GetState(hNode1) != NODE_ALLOCATED)
+	if (node1_type != NODE_GPP && node_get_state(hNode1) != NODE_ALLOCATED)
 		status = DSP_EWRONGSTATE;
 
-	if (node2Type != NODE_GPP && NODE_GetState(hNode2) != NODE_ALLOCATED)
+	if (node2_type != NODE_GPP && node_get_state(hNode2) != NODE_ALLOCATED)
 		status = DSP_EWRONGSTATE;
 
 	if (DSP_SUCCEEDED(status)) {
 		/*  Check that stream indices for task and dais socket nodes
 		 *  are not already be used. (Device nodes checked later) */
-		if (node1Type == NODE_TASK || node1Type == NODE_DAISSOCKET) {
-			pOutput = &(hNode1->createArgs.asa.taskArgs.
-				  strmOutDef[uStream1]);
-			if (pOutput->szDevice != NULL)
+		if (node1_type == NODE_TASK || node1_type == NODE_DAISSOCKET) {
+			output =
+			    &(hNode1->create_args.asa.
+			      task_arg_obj.strm_out_def[uStream1]);
+			if (output->sz_device != NULL)
 				status = DSP_EALREADYCONNECTED;
 
 		}
-		if (node2Type == NODE_TASK || node2Type == NODE_DAISSOCKET) {
-			pInput = &(hNode2->createArgs.asa.taskArgs.
-				 strmInDef[uStream2]);
-			if (pInput->szDevice != NULL)
+		if (node2_type == NODE_TASK || node2_type == NODE_DAISSOCKET) {
+			input =
+			    &(hNode2->create_args.asa.
+			      task_arg_obj.strm_in_def[uStream2]);
+			if (input->sz_device != NULL)
 				status = DSP_EALREADYCONNECTED;
 
 		}
 	}
 	/* Connecting two task nodes? */
-	if (DSP_SUCCEEDED(status) && ((node1Type == NODE_TASK ||
-	   node1Type == NODE_DAISSOCKET) && (node2Type == NODE_TASK ||
-	   node2Type == NODE_DAISSOCKET))) {
+	if (DSP_SUCCEEDED(status) && ((node1_type == NODE_TASK ||
+				       node1_type == NODE_DAISSOCKET)
+				      && (node2_type == NODE_TASK
+					  || node2_type == NODE_DAISSOCKET))) {
 		/* Find available pipe */
-		pipeId = GB_findandset(hNodeMgr->pipeMap);
-		if (pipeId == GB_NOBITS) {
+		pipe_id = gb_findandset(hnode_mgr->pipe_map);
+		if (pipe_id == GB_NOBITS) {
 			status = DSP_ENOMORECONNECTIONS;
 		} else {
 			hNode1->outputs[uStream1].type = NODECONNECT;
 			hNode2->inputs[uStream2].type = NODECONNECT;
-			hNode1->outputs[uStream1].devId = pipeId;
-			hNode2->inputs[uStream2].devId = pipeId;
-			pOutput->szDevice = MEM_Calloc(PIPENAMELEN + 1,
+			hNode1->outputs[uStream1].dev_id = pipe_id;
+			hNode2->inputs[uStream2].dev_id = pipe_id;
+			output->sz_device = mem_calloc(PIPENAMELEN + 1,
+						       MEM_PAGED);
+			input->sz_device = mem_calloc(PIPENAMELEN + 1,
 						      MEM_PAGED);
-			pInput->szDevice = MEM_Calloc(PIPENAMELEN + 1,
-						     MEM_PAGED);
-			if (pOutput->szDevice == NULL ||
-			   pInput->szDevice == NULL) {
+			if (output->sz_device == NULL ||
+			    input->sz_device == NULL) {
 				/* Undo the connection */
-				if (pOutput->szDevice)
-					MEM_Free(pOutput->szDevice);
+				kfree(output->sz_device);
 
-				if (pInput->szDevice)
-					MEM_Free(pInput->szDevice);
+				kfree(input->sz_device);
 
-				pOutput->szDevice = NULL;
-				pInput->szDevice = NULL;
-				GB_clear(hNodeMgr->pipeMap, pipeId);
+				output->sz_device = NULL;
+				input->sz_device = NULL;
+				gb_clear(hnode_mgr->pipe_map, pipe_id);
 				status = DSP_EMEMORY;
 			} else {
 				/* Copy "/dbpipe<pipId>" name to device names */
-				sprintf(pOutput->szDevice, "%s%d",
-						PIPEPREFIX, pipeId);
-				strcpy(pInput->szDevice, pOutput->szDevice);
+				sprintf(output->sz_device, "%s%d",
+					PIPEPREFIX, pipe_id);
+				strcpy(input->sz_device, output->sz_device);
 			}
 		}
 	}
 	/* Connecting task node to host? */
-	if (DSP_SUCCEEDED(status) && (node1Type == NODE_GPP ||
-	   node2Type == NODE_GPP)) {
-		if (node1Type == NODE_GPP) {
-			uMode = CHNL_MODETODSP;
+	if (DSP_SUCCEEDED(status) && (node1_type == NODE_GPP ||
+				      node2_type == NODE_GPP)) {
+		if (node1_type == NODE_GPP) {
+			chnl_mode = CHNL_MODETODSP;
 		} else {
-			DBC_Assert(node2Type == NODE_GPP);
-			uMode = CHNL_MODEFROMDSP;
+			DBC_ASSERT(node2_type == NODE_GPP);
+			chnl_mode = CHNL_MODEFROMDSP;
 		}
-		 /*  Reserve a channel id. We need to put the name "/host<id>"
-		 *  in the node's createArgs, but the host
+		/*  Reserve a channel id. We need to put the name "/host<id>"
+		 *  in the node's create_args, but the host
 		 *  side channel will not be opened until DSPStream_Open is
-		 *  called for this node.  */
-		if (pAttrs) {
-			if (pAttrs->lMode == STRMMODE_RDMA) {
-				chnlId = GB_findandset(hNodeMgr->dmaChnlMap);
+		 *  called for this node. */
+		if (pattrs) {
+			if (pattrs->strm_mode == STRMMODE_RDMA) {
+				chnl_id =
+				    gb_findandset(hnode_mgr->dma_chnl_map);
 				/* dma chans are 2nd transport chnl set
-				 * ids(e.g. 16-31)*/
-				(chnlId != GB_NOBITS) ?
-				   (chnlId = chnlId + hNodeMgr->ulNumChnls) :
-				   chnlId;
-			} else if (pAttrs->lMode == STRMMODE_ZEROCOPY) {
-				chnlId = GB_findandset(hNodeMgr->zChnlMap);
+				 * ids(e.g. 16-31) */
+				(chnl_id != GB_NOBITS) ?
+				    (chnl_id =
+				     chnl_id +
+				     hnode_mgr->ul_num_chnls) : chnl_id;
+			} else if (pattrs->strm_mode == STRMMODE_ZEROCOPY) {
+				chnl_id = gb_findandset(hnode_mgr->zc_chnl_map);
 				/* zero-copy chans are 3nd transport set
 				 * (e.g. 32-47) */
-				(chnlId != GB_NOBITS) ?  (chnlId = chnlId +
-					(2 * hNodeMgr->ulNumChnls)) : chnlId;
+				(chnl_id != GB_NOBITS) ? (chnl_id = chnl_id +
+							  (2 *
+							   hnode_mgr->
+							   ul_num_chnls))
+				    : chnl_id;
 			} else {	/* must be PROCCOPY */
-				DBC_Assert(pAttrs->lMode == STRMMODE_PROCCOPY);
-				chnlId = GB_findandset(hNodeMgr->chnlMap);
+				DBC_ASSERT(pattrs->strm_mode ==
+					   STRMMODE_PROCCOPY);
+				chnl_id = gb_findandset(hnode_mgr->chnl_map);
 				/* e.g. 0-15 */
 			}
 		} else {
 			/* default to PROCCOPY */
-			chnlId = GB_findandset(hNodeMgr->chnlMap);
+			chnl_id = gb_findandset(hnode_mgr->chnl_map);
 		}
-		if (chnlId == GB_NOBITS) {
+		if (chnl_id == GB_NOBITS) {
 			status = DSP_ENOMORECONNECTIONS;
 			goto func_cont2;
 		}
-		pstrDevName = MEM_Calloc(HOSTNAMELEN + 1, MEM_PAGED);
-		if (pstrDevName != NULL)
+		pstr_dev_name = mem_calloc(HOSTNAMELEN + 1, MEM_PAGED);
+		if (pstr_dev_name != NULL)
 			goto func_cont2;
 
-		if (pAttrs) {
-			if (pAttrs->lMode == STRMMODE_RDMA) {
-				GB_clear(hNodeMgr->dmaChnlMap, chnlId -
-					 hNodeMgr->ulNumChnls);
-			} else if (pAttrs->lMode == STRMMODE_ZEROCOPY) {
-				GB_clear(hNodeMgr->zChnlMap, chnlId -
-					(2*hNodeMgr->ulNumChnls));
+		if (pattrs) {
+			if (pattrs->strm_mode == STRMMODE_RDMA) {
+				gb_clear(hnode_mgr->dma_chnl_map, chnl_id -
+					 hnode_mgr->ul_num_chnls);
+			} else if (pattrs->strm_mode == STRMMODE_ZEROCOPY) {
+				gb_clear(hnode_mgr->zc_chnl_map, chnl_id -
+					 (2 * hnode_mgr->ul_num_chnls));
 			} else {
-				DBC_Assert(pAttrs->lMode == STRMMODE_PROCCOPY);
-				GB_clear(hNodeMgr->chnlMap, chnlId);
+				DBC_ASSERT(pattrs->strm_mode ==
+					   STRMMODE_PROCCOPY);
+				gb_clear(hnode_mgr->chnl_map, chnl_id);
 			}
 		} else {
-			GB_clear(hNodeMgr->chnlMap, chnlId);
+			gb_clear(hnode_mgr->chnl_map, chnl_id);
 		}
 		status = DSP_EMEMORY;
 func_cont2:
 		if (DSP_SUCCEEDED(status)) {
-			if (hNode1 == (struct NODE_OBJECT *) DSP_HGPPNODE) {
+			if (hNode1 == (struct node_object *)DSP_HGPPNODE) {
 				hNode2->inputs[uStream2].type = HOSTCONNECT;
-				hNode2->inputs[uStream2].devId = chnlId;
-				pInput->szDevice = pstrDevName;
+				hNode2->inputs[uStream2].dev_id = chnl_id;
+				input->sz_device = pstr_dev_name;
 			} else {
 				hNode1->outputs[uStream1].type = HOSTCONNECT;
-				hNode1->outputs[uStream1].devId = chnlId;
-				pOutput->szDevice = pstrDevName;
+				hNode1->outputs[uStream1].dev_id = chnl_id;
+				output->sz_device = pstr_dev_name;
 			}
-			sprintf(pstrDevName, "%s%d", HOSTPREFIX, chnlId);
+			sprintf(pstr_dev_name, "%s%d", HOSTPREFIX, chnl_id);
 		}
 	}
 	/* Connecting task node to device node? */
-	if (DSP_SUCCEEDED(status) && ((node1Type == NODE_DEVICE) ||
-	   (node2Type == NODE_DEVICE))) {
-		if (node2Type == NODE_DEVICE) {
+	if (DSP_SUCCEEDED(status) && ((node1_type == NODE_DEVICE) ||
+				      (node2_type == NODE_DEVICE))) {
+		if (node2_type == NODE_DEVICE) {
 			/* node1 == > device */
-			hDevNode = hNode2;
-			hNode = hNode1;
-			pStream = &(hNode1->outputs[uStream1]);
-			pstrmDef = pOutput;
+			dev_node_obj = hNode2;
+			hnode = hNode1;
+			pstream = &(hNode1->outputs[uStream1]);
+			pstrm_def = output;
 		} else {
 			/* device == > node2 */
-			hDevNode = hNode1;
-			hNode = hNode2;
-			pStream = &(hNode2->inputs[uStream2]);
-			pstrmDef = pInput;
+			dev_node_obj = hNode1;
+			hnode = hNode2;
+			pstream = &(hNode2->inputs[uStream2]);
+			pstrm_def = input;
 		}
 		/* Set up create args */
-		pStream->type = DEVICECONNECT;
-               dwLength = strlen(hDevNode->pstrDevName);
-		if (pConnParam != NULL) {
-			pstrmDef->szDevice = MEM_Calloc(dwLength + 1 +
-						(u32) pConnParam->cbData,
-						MEM_PAGED);
+		pstream->type = DEVICECONNECT;
+		dw_length = strlen(dev_node_obj->pstr_dev_name);
+		if (conn_param != NULL) {
+			pstrm_def->sz_device = mem_calloc(dw_length + 1 + (u32)
+							  conn_param->cb_data,
+							  MEM_PAGED);
 		} else {
-			pstrmDef->szDevice = MEM_Calloc(dwLength + 1,
-							MEM_PAGED);
+			pstrm_def->sz_device = mem_calloc(dw_length + 1,
+							  MEM_PAGED);
 		}
-		if (pstrmDef->szDevice == NULL) {
+		if (pstrm_def->sz_device == NULL) {
 			status = DSP_EMEMORY;
 		} else {
 			/* Copy device name */
-                       strncpy(pstrmDef->szDevice, hDevNode->pstrDevName,
-				   dwLength);
-			if (pConnParam != NULL) {
-                               strncat(pstrmDef->szDevice,
-                                       (char *)pConnParam->cData,
-                                       (u32)pConnParam->cbData);
+			strncpy(pstrm_def->sz_device,
+				dev_node_obj->pstr_dev_name, dw_length);
+			if (conn_param != NULL) {
+				strncat(pstrm_def->sz_device,
+					(char *)conn_param->node_data,
+					(u32) conn_param->cb_data);
 			}
-			hDevNode->hDeviceOwner = hNode;
+			dev_node_obj->device_owner = hnode;
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Fill in create args */
-		if (node1Type == NODE_TASK || node1Type == NODE_DAISSOCKET) {
-			hNode1->createArgs.asa.taskArgs.uNumOutputs++;
-			FillStreamDef(hNode1, pOutput, pAttrs);
+		if (node1_type == NODE_TASK || node1_type == NODE_DAISSOCKET) {
+			hNode1->create_args.asa.task_arg_obj.num_outputs++;
+			fill_stream_def(hNode1, output, pattrs);
 		}
-		if (node2Type == NODE_TASK || node2Type == NODE_DAISSOCKET) {
-			hNode2->createArgs.asa.taskArgs.uNumInputs++;
-			FillStreamDef(hNode2, pInput, pAttrs);
+		if (node2_type == NODE_TASK || node2_type == NODE_DAISSOCKET) {
+			hNode2->create_args.asa.task_arg_obj.num_inputs++;
+			fill_stream_def(hNode2, input, pattrs);
 		}
-		/* Update hNode1 and hNode2 streamConnect */
-		if (node1Type != NODE_GPP && node1Type != NODE_DEVICE) {
-			hNode1->uNumOutputs++;
-			if (uStream1 > hNode1->uMaxOutputIndex)
-				hNode1->uMaxOutputIndex = uStream1;
+		/* Update hNode1 and hNode2 stream_connect */
+		if (node1_type != NODE_GPP && node1_type != NODE_DEVICE) {
+			hNode1->num_outputs++;
+			if (uStream1 > hNode1->max_output_index)
+				hNode1->max_output_index = uStream1;
 
 		}
-		if (node2Type != NODE_GPP && node2Type != NODE_DEVICE) {
-			hNode2->uNumInputs++;
-			if (uStream2 > hNode2->uMaxInputIndex)
-				hNode2->uMaxInputIndex = uStream2;
+		if (node2_type != NODE_GPP && node2_type != NODE_DEVICE) {
+			hNode2->num_inputs++;
+			if (uStream2 > hNode2->max_input_index)
+				hNode2->max_input_index = uStream2;
 
 		}
-		FillStreamConnect(hNode1, hNode2, uStream1, uStream2);
+		fill_stream_connect(hNode1, hNode2, uStream1, uStream2);
 	}
 func_cont:
-	/* end of SYNC_EnterCS */
+	/* end of sync_enter_cs */
 	/* Exit critical section */
-	(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	(void)sync_leave_cs(hnode_mgr->sync_obj);
 func_end:
+	dev_dbg(bridge, "%s: hNode1: %p uStream1: %d hNode2: %p uStream2: %d"
+		"pattrs: %p status: 0x%x\n", __func__, hNode1,
+		uStream1, hNode2, uStream2, pattrs, status);
 	return status;
 }
 
 /*
- *  ======== NODE_Create ========
+ *  ======== node_create ========
  *  Purpose:
  *      Create a node on the DSP by remotely calling the node's create function.
  */
-DSP_STATUS NODE_Create(struct NODE_OBJECT *hNode)
+dsp_status node_create(struct node_object *hnode)
 {
-	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-	struct NODE_MGR *hNodeMgr;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	u32 ulCreateFxn;
-	enum NODE_TYPE nodeType;
-	DSP_STATUS status = DSP_SOK;
-	DSP_STATUS status1 = DSP_SOK;
-	bool bJustWokeDSP = false;
-	struct DSP_CBDATA cbData;
-	u32 procId = 255;
-	struct DSP_PROCESSORSTATE procStatus;
-	struct PROC_OBJECT *hProcessor;
+	struct node_object *pnode = (struct node_object *)hnode;
+	struct node_mgr *hnode_mgr;
+	struct bridge_drv_interface *intf_fxns;
+	u32 ul_create_fxn;
+	enum node_type node_type;
+	dsp_status status = DSP_SOK;
+	dsp_status status1 = DSP_SOK;
+	struct dsp_cbdata cb_data;
+	u32 proc_id = 255;
+	struct dsp_processorstate proc_state;
+	struct proc_object *hprocessor;
 #if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
 	struct dspbridge_platform_data *pdata =
-				omap_dspbridge_dev->dev.platform_data;
+	    omap_dspbridge_dev->dev.platform_data;
 #endif
 
-	DBC_Require(cRefs > 0);
-	GT_1trace(NODE_debugMask, GT_ENTER, "NODE_Create: hNode: 0x%x\n",
-		 hNode);
-	if (!MEM_IsValidHandle(pNode, NODE_SIGNATURE)) {
+	DBC_REQUIRE(refs > 0);
+	if (!MEM_IS_VALID_HANDLE(pnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	hProcessor = hNode->hProcessor;
-	status = PROC_GetState(hProcessor, &procStatus,
-					sizeof(struct DSP_PROCESSORSTATE));
+	hprocessor = hnode->hprocessor;
+	status = proc_get_state(hprocessor, &proc_state,
+				sizeof(struct dsp_processorstate));
 	if (DSP_FAILED(status))
 		goto func_end;
 	/* If processor is in error state then don't attempt to create
-	    new node */
-	if (procStatus.iState == PROC_ERROR) {
-		GT_1trace(NODE_debugMask, GT_4CLASS, "NODE_Create:"
-			"		proc Status 0x%x\n", procStatus.iState);
+	   new node */
+	if (proc_state.proc_state == PROC_ERROR) {
 		status = DSP_EFAIL;
 		goto func_end;
 	}
-	/* create struct DSP_CBDATA struct for PWR calls */
-	cbData.cbData = PWR_TIMEOUT;
-	nodeType = NODE_GetType(hNode);
-	hNodeMgr = hNode->hNodeMgr;
-	pIntfFxns = hNodeMgr->pIntfFxns;
+	/* create struct dsp_cbdata struct for PWR calls */
+	cb_data.cb_data = PWR_TIMEOUT;
+	node_type = node_get_type(hnode);
+	hnode_mgr = hnode->hnode_mgr;
+	intf_fxns = hnode_mgr->intf_fxns;
 	/* Get access to node dispatcher */
-	status = SYNC_EnterCS(hNodeMgr->hSync);
+	status = sync_enter_cs(hnode_mgr->sync_obj);
 	if (DSP_FAILED(status))
-		goto func_cont;
+		goto func_end;
 
 	/* Check node state */
-	if (NODE_GetState(hNode) != NODE_ALLOCATED)
+	if (node_get_state(hnode) != NODE_ALLOCATED)
 		status = DSP_EWRONGSTATE;
 
 	if (DSP_SUCCEEDED(status))
-		status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+		status = proc_get_processor_id(pnode->hprocessor, &proc_id);
 
 	if (DSP_FAILED(status))
 		goto func_cont2;
 
-	if (procId != DSP_UNIT)
+	if (proc_id != DSP_UNIT)
 		goto func_cont2;
 
 	/* Make sure streams are properly connected */
-	if ((hNode->uNumInputs && hNode->uMaxInputIndex >
-	   hNode->uNumInputs - 1) ||
-	   (hNode->uNumOutputs && hNode->uMaxOutputIndex >
-	   hNode->uNumOutputs - 1))
+	if ((hnode->num_inputs && hnode->max_input_index >
+	     hnode->num_inputs - 1) ||
+	    (hnode->num_outputs && hnode->max_output_index >
+	     hnode->num_outputs - 1))
 		status = DSP_ENOTCONNECTED;
 
 	if (DSP_SUCCEEDED(status)) {
 		/* If node's create function is not loaded, load it */
 		/* Boost the OPP level to max level that DSP can be requested */
 #if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
-		if (pdata->cpu_set_freq) {
-			(*pdata->cpu_set_freq)(pdata->mpu_speed[VDD1_OPP3]);
-
-			if (pdata->dsp_get_opp) {
-				GT_1trace(NODE_debugMask, GT_4CLASS, "opp level"
-				"after setting to VDD1_OPP3 is %d\n",
-				(*pdata->dsp_get_opp)());
-			}
-		}
+		if (pdata->cpu_set_freq)
+			(*pdata->cpu_set_freq) (pdata->mpu_max_speed);
 #endif
-		status = hNodeMgr->nldrFxns.pfnLoad(hNode->hNldrNode,
-						   NLDR_CREATE);
+		status = hnode_mgr->nldr_fxns.pfn_load(hnode->nldr_node_obj,
+						       NLDR_CREATE);
 		/* Get address of node's create function */
 		if (DSP_SUCCEEDED(status)) {
-			hNode->fLoaded = true;
-			if (nodeType != NODE_DEVICE) {
-				status = GetFxnAddress(hNode, &ulCreateFxn,
-							CREATEPHASE);
+			hnode->loaded = true;
+			if (node_type != NODE_DEVICE) {
+				status = get_fxn_address(hnode, &ul_create_fxn,
+							 CREATEPHASE);
 			}
 		} else {
-			GT_1trace(NODE_debugMask, GT_ENTER,
-				 "NODE_Create: failed to load"
-				 " create code: 0x%x\n", status);
+			pr_err("%s: failed to load create code: 0x%x\n",
+			       __func__, status);
 		}
-		/* Request the lowest OPP level*/
+		/* Request the lowest OPP level */
 #if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
-		if (pdata->cpu_set_freq) {
-			(*pdata->cpu_set_freq)(pdata->mpu_speed[VDD1_OPP1]);
-
-			if (pdata->dsp_get_opp) {
-				GT_1trace(NODE_debugMask, GT_4CLASS, "opp level"
-				"after setting to VDD1_OPP1 is %d\n",
-				(*pdata->dsp_get_opp)());
-			}
-		}
+		if (pdata->cpu_set_freq)
+			(*pdata->cpu_set_freq) (pdata->mpu_min_speed);
 #endif
 		/* Get address of iAlg functions, if socket node */
 		if (DSP_SUCCEEDED(status)) {
-			if (nodeType == NODE_DAISSOCKET) {
-				status = hNodeMgr->nldrFxns.pfnGetFxnAddr
-					(hNode->hNldrNode, hNode->dcdProps.
-					objData.nodeObj.pstrIAlgName,
-					&hNode->createArgs.asa.taskArgs.
-					ulDaisArg);
+			if (node_type == NODE_DAISSOCKET) {
+				status = hnode_mgr->nldr_fxns.pfn_get_fxn_addr
+				    (hnode->nldr_node_obj,
+				     hnode->dcd_props.obj_data.node_obj.
+				     pstr_i_alg_name,
+				     &hnode->create_args.asa.
+				     task_arg_obj.ul_dais_arg);
 			}
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
-		if (nodeType != NODE_DEVICE) {
-			status = DISP_NodeCreate(hNodeMgr->hDisp, hNode,
-				 hNodeMgr->ulFxnAddrs[RMSCREATENODE],
-				 ulCreateFxn, &(hNode->createArgs),
-				 &(hNode->nodeEnv));
+		if (node_type != NODE_DEVICE) {
+			status = disp_node_create(hnode_mgr->disp_obj, hnode,
+						  hnode_mgr->ul_fxn_addrs
+						  [RMSCREATENODE],
+						  ul_create_fxn,
+						  &(hnode->create_args),
+						  &(hnode->node_env));
 			if (DSP_SUCCEEDED(status)) {
 				/* Set the message queue id to the node env
 				 * pointer */
-				pIntfFxns = hNodeMgr->pIntfFxns;
-				(*pIntfFxns->pfnMsgSetQueueId)(hNode->hMsgQueue,
-				hNode->nodeEnv);
+				intf_fxns = hnode_mgr->intf_fxns;
+				(*intf_fxns->pfn_msg_set_queue_id) (hnode->
+							msg_queue_obj,
+							hnode->node_env);
 			}
 		}
 	}
+
+	/*
+	 * If node_env is not null, node_delete will take care of removing the
+	 * library along with deinitializing any other resources in the dsp.
+	 */
+	if (DSP_FAILED(status) && !hnode->node_env && hnode->loaded) {
+			hnode_mgr->nldr_fxns.pfn_unload(hnode->nldr_node_obj,
+								NLDR_CREATE);
+			hnode->loaded = false;
+	}
+
 	/*  Phase II/Overlays: Create, execute, delete phases  possibly in
 	 *  different files/sections. */
-	if (hNode->fLoaded && hNode->fPhaseSplit) {
+	if (hnode->loaded && hnode->phase_split) {
 		/* If create code was dynamically loaded, we can now unload
 		 * it. */
-		status1 = hNodeMgr->nldrFxns.pfnUnload(hNode->hNldrNode,
-						      NLDR_CREATE);
-		hNode->fLoaded = false;
-	}
-	if (DSP_FAILED(status1)) {
-		GT_1trace(NODE_debugMask, GT_5CLASS,
-			 "NODE_Create: Failed to unload "
-			 "create code: 0x%x\n", status1);
-	}
+		status1 = hnode_mgr->nldr_fxns.pfn_unload(hnode->nldr_node_obj,
+							  NLDR_CREATE);
+		hnode->loaded = false;
+	}
+	if (DSP_FAILED(status1))
+		pr_err("%s: Failed to unload create code: 0x%x\n",
+		       __func__, status1);
 func_cont2:
 	/* Update node state and node manager state */
 	if (DSP_SUCCEEDED(status)) {
-		NODE_SetState(hNode, NODE_CREATED);
-		hNodeMgr->uNumCreated++;
+		NODE_SET_STATE(hnode, NODE_CREATED);
+		hnode_mgr->num_created++;
 		goto func_cont;
 	}
 	if (status != DSP_EWRONGSTATE) {
 		/* Put back in NODE_ALLOCATED state if error occurred */
-		NODE_SetState(hNode, NODE_ALLOCATED);
-	}
-	if (procId == DSP_UNIT) {
-		/* If node create failed, see if should sleep DSP now */
-		if (bJustWokeDSP == true) {
-			/* Check to see if partial create happened on DSP */
-			if (hNode->nodeEnv == (u32)NULL) {
-				/* No environment allocated on DSP, re-sleep
-				 * DSP now */
-				PROC_Ctrl(hNode->hProcessor, WMDIOCTL_DEEPSLEEP,
-					 &cbData);
-			} else {
-				/* Increment count, sleep later when node fully
-				 * deleted */
-				hNodeMgr->uNumCreated++;
-			}
-		}
+		NODE_SET_STATE(hnode, NODE_ALLOCATED);
 	}
 func_cont:
-		/* Free access to node dispatcher */
-		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	/* Free access to node dispatcher */
+	(void)sync_leave_cs(hnode_mgr->sync_obj);
 func_end:
 	if (DSP_SUCCEEDED(status)) {
-		PROC_NotifyClients(hNode->hProcessor, DSP_NODESTATECHANGE);
-		NTFY_Notify(hNode->hNtfy, DSP_NODESTATECHANGE);
+		proc_notify_clients(hnode->hprocessor, DSP_NODESTATECHANGE);
+		ntfy_notify(hnode->ntfy_obj, DSP_NODESTATECHANGE);
 	}
 
+	dev_dbg(bridge, "%s: hnode: %p status: 0x%x\n", __func__,
+		hnode, status);
 	return status;
 }
 
 /*
- *  ======== NODE_CreateMgr ========
+ *  ======== node_create_mgr ========
  *  Purpose:
  *      Create a NODE Manager object.
  */
-DSP_STATUS NODE_CreateMgr(OUT struct NODE_MGR **phNodeMgr,
-			 struct DEV_OBJECT *hDevObject)
+dsp_status node_create_mgr(OUT struct node_mgr **phNodeMgr,
+			   struct dev_object *hdev_obj)
 {
 	u32 i;
-	struct NODE_MGR *pNodeMgr = NULL;
-	struct DISP_ATTRS dispAttrs;
-	char *szZLFile = "";
-	struct NLDR_ATTRS nldrAttrs;
-	DSP_STATUS status = DSP_SOK;
-	u32 devType;
-	DBC_Require(cRefs > 0);
-	DBC_Require(phNodeMgr != NULL);
-	DBC_Require(hDevObject != NULL);
-	GT_2trace(NODE_debugMask, GT_ENTER, "NODE_CreateMgr: phNodeMgr: 0x%x\t"
-		 "hDevObject: 0x%x\n", phNodeMgr, hDevObject);
+	struct node_mgr *node_mgr_obj = NULL;
+	struct disp_attr disp_attr_obj;
+	char *sz_zl_file = "";
+	struct nldr_attrs nldr_attrs_obj;
+	dsp_status status = DSP_SOK;
+	u32 dev_type;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phNodeMgr != NULL);
+	DBC_REQUIRE(hdev_obj != NULL);
+
 	*phNodeMgr = NULL;
 	/* Allocate Node manager object */
-	MEM_AllocObject(pNodeMgr, struct NODE_MGR, NODEMGR_SIGNATURE);
-	if (pNodeMgr) {
-		pNodeMgr->hDevObject = hDevObject;
-		pNodeMgr->nodeList = LST_Create();
-		pNodeMgr->pipeMap = GB_create(MAXPIPES);
-		pNodeMgr->pipeDoneMap = GB_create(MAXPIPES);
-		if (pNodeMgr->nodeList == NULL || pNodeMgr->pipeMap == NULL ||
-		   pNodeMgr->pipeDoneMap == NULL) {
+	MEM_ALLOC_OBJECT(node_mgr_obj, struct node_mgr, NODEMGR_SIGNATURE);
+	if (node_mgr_obj) {
+		node_mgr_obj->hdev_obj = hdev_obj;
+		node_mgr_obj->node_list = mem_calloc(sizeof(struct lst_list),
+						     MEM_NONPAGED);
+		node_mgr_obj->pipe_map = gb_create(MAXPIPES);
+		node_mgr_obj->pipe_done_map = gb_create(MAXPIPES);
+		if (node_mgr_obj->node_list == NULL
+		    || node_mgr_obj->pipe_map == NULL
+		    || node_mgr_obj->pipe_done_map == NULL) {
 			status = DSP_EMEMORY;
-			GT_0trace(NODE_debugMask, GT_6CLASS,
-				 "NODE_CreateMgr: Memory "
-				 "allocation failed\n");
 		} else {
-			status = NTFY_Create(&pNodeMgr->hNtfy);
+			INIT_LIST_HEAD(&node_mgr_obj->node_list->head);
+			status = ntfy_create(&node_mgr_obj->ntfy_obj);
 		}
-		pNodeMgr->uNumCreated = 0;
+		node_mgr_obj->num_created = 0;
 	} else {
-		GT_0trace(NODE_debugMask, GT_6CLASS,
-			 "NODE_CreateMgr: Memory allocation failed\n");
 		status = DSP_EMEMORY;
 	}
 	/* get devNodeType */
 	if (DSP_SUCCEEDED(status))
-		status = DEV_GetDevType(hDevObject, &devType);
+		status = dev_get_dev_type(hdev_obj, &dev_type);
 
 	/* Create the DCD Manager */
 	if (DSP_SUCCEEDED(status)) {
-		status = DCD_CreateManager(szZLFile, &pNodeMgr->hDcdMgr);
+		status =
+		    dcd_create_manager(sz_zl_file, &node_mgr_obj->hdcd_mgr);
 		if (DSP_SUCCEEDED(status))
-			status = GetProcProps(pNodeMgr, hDevObject);
+			status = get_proc_props(node_mgr_obj, hdev_obj);
 
 	}
 	/* Create NODE Dispatcher */
 	if (DSP_SUCCEEDED(status)) {
-		dispAttrs.ulChnlOffset = pNodeMgr->ulChnlOffset;
-		dispAttrs.ulChnlBufSize = pNodeMgr->ulChnlBufSize;
-		dispAttrs.procFamily = pNodeMgr->procFamily;
-		dispAttrs.procType = pNodeMgr->procType;
-		status = DISP_Create(&pNodeMgr->hDisp, hDevObject, &dispAttrs);
+		disp_attr_obj.ul_chnl_offset = node_mgr_obj->ul_chnl_offset;
+		disp_attr_obj.ul_chnl_buf_size = node_mgr_obj->ul_chnl_buf_size;
+		disp_attr_obj.proc_family = node_mgr_obj->proc_family;
+		disp_attr_obj.proc_type = node_mgr_obj->proc_type;
+		status =
+		    disp_create(&node_mgr_obj->disp_obj, hdev_obj,
+				&disp_attr_obj);
 	}
 	/* Create a STRM Manager */
 	if (DSP_SUCCEEDED(status))
-		status = STRM_Create(&pNodeMgr->hStrmMgr, hDevObject);
+		status = strm_create(&node_mgr_obj->strm_mgr_obj, hdev_obj);
 
 	if (DSP_SUCCEEDED(status)) {
-		DEV_GetIntfFxns(hDevObject, &pNodeMgr->pIntfFxns);
-		/* Get MSG queue manager */
-		DEV_GetMsgMgr(hDevObject, &pNodeMgr->hMsg);
-		status = SYNC_InitializeCS(&pNodeMgr->hSync);
-		if (DSP_FAILED(status))
-			status = DSP_EMEMORY;
-	}
-	if (DSP_SUCCEEDED(status)) {
-		pNodeMgr->chnlMap = GB_create(pNodeMgr->ulNumChnls);
-		/* dma chnl map. ulNumChnls is # per transport */
-		pNodeMgr->dmaChnlMap = GB_create(pNodeMgr->ulNumChnls);
-		pNodeMgr->zChnlMap = GB_create(pNodeMgr->ulNumChnls);
-		if ((pNodeMgr->chnlMap == NULL) ||
-		   (pNodeMgr->dmaChnlMap == NULL) ||
-		   (pNodeMgr->zChnlMap == NULL)) {
+		dev_get_intf_fxns(hdev_obj, &node_mgr_obj->intf_fxns);
+		/* Get msg_ctrl queue manager */
+		dev_get_msg_mgr(hdev_obj, &node_mgr_obj->msg_mgr_obj);
+		status = sync_initialize_cs(&node_mgr_obj->sync_obj);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		node_mgr_obj->chnl_map = gb_create(node_mgr_obj->ul_num_chnls);
+		/* dma chnl map. ul_num_chnls is # per transport */
+		node_mgr_obj->dma_chnl_map =
+		    gb_create(node_mgr_obj->ul_num_chnls);
+		node_mgr_obj->zc_chnl_map =
+		    gb_create(node_mgr_obj->ul_num_chnls);
+		if ((node_mgr_obj->chnl_map == NULL)
+		    || (node_mgr_obj->dma_chnl_map == NULL)
+		    || (node_mgr_obj->zc_chnl_map == NULL)) {
 			status = DSP_EMEMORY;
 		} else {
 			/* Block out reserved channels */
-			for (i = 0; i < pNodeMgr->ulChnlOffset; i++)
-				GB_set(pNodeMgr->chnlMap, i);
+			for (i = 0; i < node_mgr_obj->ul_chnl_offset; i++)
+				gb_set(node_mgr_obj->chnl_map, i);
 
 			/* Block out channels reserved for RMS */
-			GB_set(pNodeMgr->chnlMap, pNodeMgr->ulChnlOffset);
-			GB_set(pNodeMgr->chnlMap, pNodeMgr->ulChnlOffset + 1);
+			gb_set(node_mgr_obj->chnl_map,
+			       node_mgr_obj->ul_chnl_offset);
+			gb_set(node_mgr_obj->chnl_map,
+			       node_mgr_obj->ul_chnl_offset + 1);
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* NO RM Server on the IVA */
-		if (devType != IVA_UNIT) {
+		if (dev_type != IVA_UNIT) {
 			/* Get addresses of any RMS functions loaded */
-			status = GetRMSFxns(pNodeMgr);
-			if (DSP_FAILED(status)) {
-				GT_1trace(NODE_debugMask, GT_6CLASS,
-				"NODE_CreateMgr: Failed to"
-				" get RMS functions: status = 0x%x", status);
-			}
+			status = get_rms_fxns(node_mgr_obj);
 		}
 	}
 
 	/* Get loader functions and create loader */
+	if (DSP_SUCCEEDED(status))
+		node_mgr_obj->nldr_fxns = nldr_fxns;	/* Dyn loader funcs */
+
 	if (DSP_SUCCEEDED(status)) {
-		GT_0trace(NODE_debugMask, GT_1CLASS,
-			 "NODE_CreateMgr: using dynamic loader\n");
-		pNodeMgr->nldrFxns = nldrFxns;	/* Dynamic loader functions */
-	}
-	if (DSP_SUCCEEDED(status)) {
-		nldrAttrs.pfnOvly = Ovly;
-		nldrAttrs.pfnWrite = Write;
-		nldrAttrs.usDSPWordSize = pNodeMgr->uDSPWordSize;
-		nldrAttrs.usDSPMauSize = pNodeMgr->uDSPMauSize;
-		pNodeMgr->fLoaderInit = pNodeMgr->nldrFxns.pfnInit();
-		status = pNodeMgr->nldrFxns.pfnCreate(&pNodeMgr->hNldr,
-						     hDevObject, &nldrAttrs);
-		if (DSP_FAILED(status)) {
-			GT_1trace(NODE_debugMask, GT_6CLASS,
-				 "NODE_CreateMgr: Failed to "
-				 "create loader: status = 0x%x\n", status);
-		}
+		nldr_attrs_obj.pfn_ovly = ovly;
+		nldr_attrs_obj.pfn_write = mem_write;
+		nldr_attrs_obj.us_dsp_word_size = node_mgr_obj->udsp_word_size;
+		nldr_attrs_obj.us_dsp_mau_size = node_mgr_obj->udsp_mau_size;
+		node_mgr_obj->loader_init = node_mgr_obj->nldr_fxns.pfn_init();
+		status =
+		    node_mgr_obj->nldr_fxns.pfn_create(&node_mgr_obj->nldr_obj,
+						       hdev_obj,
+						       &nldr_attrs_obj);
 	}
 	if (DSP_SUCCEEDED(status))
-		*phNodeMgr = pNodeMgr;
+		*phNodeMgr = node_mgr_obj;
 	else
-		DeleteNodeMgr(pNodeMgr);
+		delete_node_mgr(node_mgr_obj);
 
-	DBC_Ensure((DSP_FAILED(status) && (*phNodeMgr == NULL)) ||
-		  (DSP_SUCCEEDED(status) &&
-		  MEM_IsValidHandle((*phNodeMgr), NODEMGR_SIGNATURE)));
+	DBC_ENSURE((DSP_FAILED(status) && (*phNodeMgr == NULL)) ||
+		   (DSP_SUCCEEDED(status) &&
+		    MEM_IS_VALID_HANDLE((*phNodeMgr), NODEMGR_SIGNATURE)));
 
 	return status;
 }
 
 /*
- *  ======== NODE_Delete ========
+ *  ======== node_delete ========
  *  Purpose:
  *      Delete a node on the DSP by remotely calling the node's delete function.
  *      Loads the node's delete function if necessary. Free GPP side resources
  *      after node's delete function returns.
  */
-DSP_STATUS NODE_Delete(struct NODE_OBJECT *hNode,
-		struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status node_delete(struct node_object *hnode,
+		       struct process_context *pr_ctxt)
 {
-	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-	struct NODE_MGR *hNodeMgr;
-	struct PROC_OBJECT *hProcessor;
-	struct DISP_OBJECT *hDisp;
-	u32 ulDeleteFxn;
-	enum NODE_TYPE nodeType;
-	enum NODE_STATE state;
-	DSP_STATUS status = DSP_SOK;
-	DSP_STATUS status1 = DSP_SOK;
-	struct DSP_CBDATA cbData;
-	u32 procId;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct node_object *pnode = (struct node_object *)hnode;
+	struct node_mgr *hnode_mgr;
+	struct proc_object *hprocessor;
+	struct disp_object *disp_obj;
+	u32 ul_delete_fxn;
+	enum node_type node_type;
+	enum node_state state;
+	dsp_status status = DSP_SOK;
+	dsp_status status1 = DSP_SOK;
+	struct dsp_cbdata cb_data;
+	u32 proc_id;
+	struct bridge_drv_interface *intf_fxns;
 
-#ifndef RES_CLEANUP_DISABLE
-	HANDLE		nodeRes;
-#endif
-	struct DSP_PROCESSORSTATE procStatus;
-	DBC_Require(cRefs > 0);
-	GT_1trace(NODE_debugMask, GT_ENTER, "NODE_Delete: hNode: 0x%x\n",
-		  hNode);
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	bhandle node_res;
+
+	struct dsp_processorstate proc_state;
+	DBC_REQUIRE(refs > 0);
+
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	/* create struct DSP_CBDATA struct for PWR call */
-	cbData.cbData = PWR_TIMEOUT;
-	hNodeMgr = hNode->hNodeMgr;
-	hProcessor = hNode->hProcessor;
-	hDisp = hNodeMgr->hDisp;
-	nodeType = NODE_GetType(hNode);
-	pIntfFxns = hNodeMgr->pIntfFxns;
+	/* create struct dsp_cbdata struct for PWR call */
+	cb_data.cb_data = PWR_TIMEOUT;
+	hnode_mgr = hnode->hnode_mgr;
+	hprocessor = hnode->hprocessor;
+	disp_obj = hnode_mgr->disp_obj;
+	node_type = node_get_type(hnode);
+	intf_fxns = hnode_mgr->intf_fxns;
 	/* Enter critical section */
-	status = SYNC_EnterCS(hNodeMgr->hSync);
+	status = sync_enter_cs(hnode_mgr->sync_obj);
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	state = NODE_GetState(hNode);
-	 /*  Execute delete phase code for non-device node in all cases
-	  *  except when the node was only allocated. Delete phase must be
-	  *  executed even if create phase was executed, but failed.
-	  *  If the node environment pointer is non-NULL, the delete phase
-	  *  code must be  executed.  */
-	if (!(state == NODE_ALLOCATED && hNode->nodeEnv == (u32)NULL) &&
-	   nodeType != NODE_DEVICE) {
-		status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+	state = node_get_state(hnode);
+	/*  Execute delete phase code for non-device node in all cases
+	 *  except when the node was only allocated. Delete phase must be
+	 *  executed even if create phase was executed, but failed.
+	 *  If the node environment pointer is non-NULL, the delete phase
+	 *  code must be  executed. */
+	if (!(state == NODE_ALLOCATED && hnode->node_env == (u32) NULL) &&
+	    node_type != NODE_DEVICE) {
+		status = proc_get_processor_id(pnode->hprocessor, &proc_id);
 		if (DSP_FAILED(status))
 			goto func_cont1;
 
-		if (procId == DSP_UNIT || procId == IVA_UNIT) {
+		if (proc_id == DSP_UNIT || proc_id == IVA_UNIT) {
 			/*  If node has terminated, execute phase code will
-			 *  have already been unloaded in NODE_OnExit(). If the
+			 *  have already been unloaded in node_on_exit(). If the
 			 *  node is PAUSED, the execute phase is loaded, and it
 			 *  is now ok to unload it. If the node is running, we
 			 *  will unload the execute phase only after deleting
-			 *  the node.  */
-			if (state == NODE_PAUSED && hNode->fLoaded &&
-			   hNode->fPhaseSplit) {
+			 *  the node. */
+			if (state == NODE_PAUSED && hnode->loaded &&
+			    hnode->phase_split) {
 				/* Ok to unload execute code as long as node
 				 * is not * running */
-				status1 = hNodeMgr->nldrFxns.pfnUnload(hNode->
-					  hNldrNode, NLDR_EXECUTE);
-				hNode->fLoaded = false;
-				NODE_SetState(hNode, NODE_DONE);
+				status1 =
+				    hnode_mgr->nldr_fxns.
+				    pfn_unload(hnode->nldr_node_obj,
+					       NLDR_EXECUTE);
+				hnode->loaded = false;
+				NODE_SET_STATE(hnode, NODE_DONE);
 			}
 			/* Load delete phase code if not loaded or if haven't
 			 * * unloaded EXECUTE phase */
-			if ((!(hNode->fLoaded) || (state == NODE_RUNNING)) &&
-			   hNode->fPhaseSplit) {
-				status = hNodeMgr->nldrFxns.pfnLoad(hNode->
-					 hNldrNode, NLDR_DELETE);
-				if (DSP_SUCCEEDED(status)) {
-					hNode->fLoaded = true;
-				} else {
-					GT_1trace(NODE_debugMask, GT_ENTER,
-						 "NODE_Delete: failed to "
-						 "load delete code: 0x%x\n",
-						 status);
-				}
+			if ((!(hnode->loaded) || (state == NODE_RUNNING)) &&
+			    hnode->phase_split) {
+				status =
+				    hnode_mgr->nldr_fxns.
+				    pfn_load(hnode->nldr_node_obj, NLDR_DELETE);
+				if (DSP_SUCCEEDED(status))
+					hnode->loaded = true;
+				else
+					pr_err("%s: fail - load delete code:"
+					       " 0x%x\n", __func__, status);
 			}
 		}
 func_cont1:
 		if (DSP_SUCCEEDED(status)) {
 			/* Unblock a thread trying to terminate the node */
-			(void)SYNC_SetEvent(hNode->hSyncDone);
-			if (procId == DSP_UNIT) {
-				/* ulDeleteFxn = address of node's delete
+			(void)sync_set_event(hnode->sync_done);
+			if (proc_id == DSP_UNIT) {
+				/* ul_delete_fxn = address of node's delete
 				 * function */
-				status = GetFxnAddress(hNode, &ulDeleteFxn,
-						      DELETEPHASE);
-			} else if (procId == IVA_UNIT)
-				ulDeleteFxn = (u32)hNode->nodeEnv;
+				status = get_fxn_address(hnode, &ul_delete_fxn,
+							 DELETEPHASE);
+			} else if (proc_id == IVA_UNIT)
+				ul_delete_fxn = (u32) hnode->node_env;
 			if (DSP_SUCCEEDED(status)) {
-				status = PROC_GetState(hProcessor, &procStatus,
-					sizeof(struct DSP_PROCESSORSTATE));
-				GT_1trace(NODE_debugMask, GT_4CLASS,
-						 "NODE_Delete: proc Status "
-						 "0x%x\n", procStatus.iState);
-				if (procStatus.iState != PROC_ERROR) {
-					status = DISP_NodeDelete(hDisp, hNode,
-					hNodeMgr->ulFxnAddrs[RMSDELETENODE],
-					ulDeleteFxn, hNode->nodeEnv);
+				status = proc_get_state(hprocessor,
+						&proc_state,
+						sizeof(struct
+						       dsp_processorstate));
+				if (proc_state.proc_state != PROC_ERROR) {
+					status =
+					    disp_node_delete(disp_obj, hnode,
+							     hnode_mgr->
+							     ul_fxn_addrs
+							     [RMSDELETENODE],
+							     ul_delete_fxn,
+							     hnode->node_env);
 				} else
-					NODE_SetState(hNode, NODE_DONE);
+					NODE_SET_STATE(hnode, NODE_DONE);
 
 				/* Unload execute, if not unloaded, and delete
 				 * function */
 				if (state == NODE_RUNNING &&
-				   hNode->fPhaseSplit) {
-					status1 = hNodeMgr->nldrFxns.pfnUnload(
-						hNode->hNldrNode, NLDR_EXECUTE);
-				}
-				if (DSP_FAILED(status1)) {
-					GT_1trace(NODE_debugMask, GT_ENTER,
-						  "NODE_Delete: failed to"
-						  "unload execute code: 0x%x\n",
-						  status1);
-				}
-				status1 = hNodeMgr->nldrFxns.pfnUnload(
-					  hNode->hNldrNode, NLDR_DELETE);
-				hNode->fLoaded = false;
-				if (DSP_FAILED(status1)) {
-					GT_1trace(NODE_debugMask, GT_ENTER,
-						  "NODE_Delete: failed to"
-						  "unload delete code: 0x%x\n",
-						  status1);
+				    hnode->phase_split) {
+					status1 =
+					    hnode_mgr->nldr_fxns.
+					    pfn_unload(hnode->nldr_node_obj,
+						       NLDR_EXECUTE);
 				}
+				if (DSP_FAILED(status1))
+					pr_err("%s: fail - unload execute code:"
+					       " 0x%x\n", __func__, status1);
+
+				status1 =
+				    hnode_mgr->nldr_fxns.pfn_unload(hnode->
+							    nldr_node_obj,
+							    NLDR_DELETE);
+				hnode->loaded = false;
+				if (DSP_FAILED(status1))
+					pr_err("%s: fail - unload delete code: "
+					       "0x%x\n", __func__, status1);
 			}
 		}
 	}
 	/* Free host side resources even if a failure occurred */
-	/* Remove node from hNodeMgr->nodeList */
-	LST_RemoveElem(hNodeMgr->nodeList, (struct LST_ELEM *) hNode);
-	hNodeMgr->uNumNodes--;
+	/* Remove node from hnode_mgr->node_list */
+	lst_remove_elem(hnode_mgr->node_list, (struct list_head *)hnode);
+	hnode_mgr->num_nodes--;
 	/* Decrement count of nodes created on DSP */
 	if ((state != NODE_ALLOCATED) || ((state == NODE_ALLOCATED) &&
-	(hNode->nodeEnv != (u32) NULL)))
-		hNodeMgr->uNumCreated--;
-	 /*  Free host-side resources allocated by NODE_Create()
-	 *  DeleteNode() fails if SM buffers not freed by client!  */
-#ifndef RES_CLEANUP_DISABLE
-	if (!pr_ctxt)
-		goto func_cont;
-	if (DRV_GetNodeResElement(hNode, &nodeRes, pr_ctxt) != DSP_ENOTFOUND) {
-		GT_0trace(NODE_debugMask, GT_5CLASS, "\nNODE_Delete12:\n");
-		DRV_ProcNodeUpdateStatus(nodeRes, false);
-	}
-#endif
-func_cont:
-	GT_0trace(NODE_debugMask, GT_ENTER, "\nNODE_Delete13:\n ");
-	DeleteNode(hNode, pr_ctxt);
-#ifndef RES_CLEANUP_DISABLE
-	GT_0trace(NODE_debugMask, GT_5CLASS, "\nNODE_Delete2:\n ");
-	if (pr_ctxt)
-		DRV_RemoveNodeResElement(nodeRes, pr_ctxt);
-#endif
-	GT_0trace(NODE_debugMask, GT_ENTER, "\nNODE_Delete3:\n ");
+					  (hnode->node_env != (u32) NULL)))
+		hnode_mgr->num_created--;
+	/*  Free host-side resources allocated by node_create()
+	 *  delete_node() fails if SM buffers not freed by client! */
+	if (drv_get_node_res_element(hnode, &node_res, pr_ctxt) !=
+	    DSP_ENOTFOUND)
+		drv_proc_node_update_status(node_res, false);
+	delete_node(hnode, pr_ctxt);
+
+	drv_remove_node_res_element(node_res, pr_ctxt);
 	/* Exit critical section */
-	(void)SYNC_LeaveCS(hNodeMgr->hSync);
-	PROC_NotifyClients(hProcessor, DSP_NODESTATECHANGE);
+	(void)sync_leave_cs(hnode_mgr->sync_obj);
+	proc_notify_clients(hprocessor, DSP_NODESTATECHANGE);
 func_end:
+	dev_dbg(bridge, "%s: hnode: %p status 0x%x\n", __func__, hnode, status);
 	return status;
 }
 
 /*
- *  ======== NODE_DeleteMgr ========
+ *  ======== node_delete_mgr ========
  *  Purpose:
  *      Delete the NODE Manager.
  */
-DSP_STATUS NODE_DeleteMgr(struct NODE_MGR *hNodeMgr)
+dsp_status node_delete_mgr(struct node_mgr *hnode_mgr)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE));
+	DBC_REQUIRE(refs > 0);
 
-	GT_1trace(NODE_debugMask, GT_ENTER, "NODE_DeleteMgr: hNodeMgr: 0x%x\n",
-		 hNodeMgr);
-	DeleteNodeMgr(hNodeMgr);
+	if (MEM_IS_VALID_HANDLE(hnode_mgr, NODEMGR_SIGNATURE))
+		delete_node_mgr(hnode_mgr);
+	else
+		status = DSP_EHANDLE;
 
 	return status;
 }
 
 /*
- *  ======== NODE_EnumNodes ========
+ *  ======== node_enum_nodes ========
  *  Purpose:
  *      Enumerate currently allocated nodes.
  */
-DSP_STATUS NODE_EnumNodes(struct NODE_MGR *hNodeMgr, IN DSP_HNODE *aNodeTab,
-			 u32 uNodeTabSize, OUT u32 *puNumNodes,
-			 OUT u32 *puAllocated)
+dsp_status node_enum_nodes(struct node_mgr *hnode_mgr, void **node_tab,
+			   u32 node_tab_size, OUT u32 *pu_num_nodes,
+			   OUT u32 *pu_allocated)
 {
-	struct NODE_OBJECT *hNode;
+	struct node_object *hnode;
 	u32 i;
-	DSP_STATUS status = DSP_SOK;
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE));
-	DBC_Require(aNodeTab != NULL || uNodeTabSize == 0);
-	DBC_Require(puNumNodes != NULL);
-	DBC_Require(puAllocated != NULL);
-	GT_5trace(NODE_debugMask, GT_ENTER, "NODE_EnumNodes: hNodeMgr: 0x%x\t"
-		 "aNodeTab: %d\tuNodeTabSize: 0x%x\tpuNumNodes: 0x%x\t"
-		 "puAllocated\n", hNodeMgr, aNodeTab, uNodeTabSize, puNumNodes,
-		 puAllocated);
+	dsp_status status = DSP_SOK;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(node_tab != NULL || node_tab_size == 0);
+	DBC_REQUIRE(pu_num_nodes != NULL);
+	DBC_REQUIRE(pu_allocated != NULL);
+
+	if (!MEM_IS_VALID_HANDLE(hnode_mgr, NODEMGR_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 	/* Enter critical section */
-	status = SYNC_EnterCS(hNodeMgr->hSync);
+	status = sync_enter_cs(hnode_mgr->sync_obj);
 	if (DSP_SUCCEEDED(status)) {
-		if (hNodeMgr->uNumNodes > uNodeTabSize) {
-			*puAllocated = hNodeMgr->uNumNodes;
-			*puNumNodes = 0;
+		if (hnode_mgr->num_nodes > node_tab_size) {
+			*pu_allocated = hnode_mgr->num_nodes;
+			*pu_num_nodes = 0;
 			status = DSP_ESIZE;
 		} else {
-			hNode = (struct NODE_OBJECT *)LST_First(hNodeMgr->
-				nodeList);
-			for (i = 0; i < hNodeMgr->uNumNodes; i++) {
-				DBC_Assert(MEM_IsValidHandle(hNode,
-					  NODE_SIGNATURE));
-				aNodeTab[i] = hNode;
-				hNode = (struct NODE_OBJECT *)LST_Next
-					(hNodeMgr->nodeList,
-					(struct LST_ELEM *)hNode);
+			hnode = (struct node_object *)
+			    lst_first(hnode_mgr->node_list);
+			for (i = 0; i < hnode_mgr->num_nodes; i++) {
+				DBC_ASSERT(MEM_IS_VALID_HANDLE(hnode,
+							       NODE_SIGNATURE));
+				node_tab[i] = hnode;
+				hnode = (struct node_object *)lst_next
+				    (hnode_mgr->node_list,
+				     (struct list_head *)hnode);
 			}
-			*puAllocated = *puNumNodes = hNodeMgr->uNumNodes;
+			*pu_allocated = *pu_num_nodes = hnode_mgr->num_nodes;
 		}
 	}
-	/* end of SYNC_EnterCS */
+	/* end of sync_enter_cs */
 	/* Exit critical section */
-	(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	(void)sync_leave_cs(hnode_mgr->sync_obj);
+func_end:
 	return status;
 }
 
 /*
- *  ======== NODE_Exit ========
+ *  ======== node_exit ========
  *  Purpose:
  *      Discontinue usage of NODE module.
  */
-void NODE_Exit(void)
+void node_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	cRefs--;
+	refs--;
 
-	GT_1trace(NODE_debugMask, GT_5CLASS,
-		 "Entered NODE_Exit, ref count:  0x%x\n", cRefs);
-
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== NODE_FreeMsgBuf ========
+ *  ======== node_free_msg_buf ========
  *  Purpose:
  *      Frees the message buffer.
  */
-DSP_STATUS NODE_FreeMsgBuf(struct NODE_OBJECT *hNode, IN u8 *pBuffer,
-				 OPTIONAL struct DSP_BUFFERATTR *pAttr)
+dsp_status node_free_msg_buf(struct node_object *hnode, IN u8 * pbuffer,
+			     OPTIONAL struct dsp_bufferattr *pattr)
 {
-	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-	DSP_STATUS status = DSP_SOK;
-	u32 procId;
-	DBC_Require(cRefs > 0);
-	DBC_Require(pBuffer != NULL);
-	DBC_Require(pNode != NULL);
-	DBC_Require(pNode->hXlator != NULL);
-	GT_3trace(NODE_debugMask, GT_ENTER, "NODE_FreeMsgBuf: hNode: 0x%x\t"
-		 "pBuffer: 0x%x\tpAttr: 0x%x\n", hNode, pBuffer, pAttr);
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	struct node_object *pnode = (struct node_object *)hnode;
+	dsp_status status = DSP_SOK;
+	u32 proc_id;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pbuffer != NULL);
+	DBC_REQUIRE(pnode != NULL);
+	DBC_REQUIRE(pnode->xlator != NULL);
+
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	status = PROC_GetProcessorId(pNode->hProcessor, &procId);
-	if (procId == DSP_UNIT) {
+	status = proc_get_processor_id(pnode->hprocessor, &proc_id);
+	if (proc_id == DSP_UNIT) {
 		if (DSP_SUCCEEDED(status)) {
-			if (pAttr == NULL) {
+			if (pattr == NULL) {
 				/* set defaults */
-				pAttr = &NODE_DFLTBUFATTRS;
+				pattr = &node_dfltbufattrs;
 			}
-			 /* Node supports single SM segment only */
-			if (pAttr->uSegment != 1)
+			/* Node supports single SM segment only */
+			if (pattr->segment_id != 1)
 				status = DSP_EBADSEGID;
 
-			/* pBuffer is clients Va. */
-			status = CMM_XlatorFreeBuf(pNode->hXlator, pBuffer);
-			if (DSP_FAILED(status))
-				status = DSP_EFAIL;
-			else
-				status = DSP_SOK;
-
+			/* pbuffer is clients Va. */
+			status = cmm_xlator_free_buf(pnode->xlator, pbuffer);
 		}
 	} else {
-		DBC_Assert(NULL);	/* BUG */
+		DBC_ASSERT(NULL);	/* BUG */
 	}
 func_end:
 	return status;
 }
 
 /*
- *  ======== NODE_GetAttr ========
+ *  ======== node_get_attr ========
  *  Purpose:
- *      Copy the current attributes of the specified node into a DSP_NODEATTR
+ *      Copy the current attributes of the specified node into a dsp_nodeattr
  *      structure.
  */
-DSP_STATUS NODE_GetAttr(struct NODE_OBJECT *hNode,
-			OUT struct DSP_NODEATTR *pAttr, u32 uAttrSize)
+dsp_status node_get_attr(struct node_object *hnode,
+			 OUT struct dsp_nodeattr *pattr, u32 attr_size)
 {
-	struct NODE_MGR *hNodeMgr;
-	DSP_STATUS status = DSP_SOK;
-	DBC_Require(cRefs > 0);
-	DBC_Require(pAttr != NULL);
-	DBC_Require(uAttrSize >= sizeof(struct DSP_NODEATTR));
-	GT_3trace(NODE_debugMask, GT_ENTER, "NODE_GetAttr: hNode: "
-		 "0x%x\tpAttr: 0x%x \tuAttrSize: 0x%x\n", hNode, pAttr,
-		 uAttrSize);
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	struct node_mgr *hnode_mgr;
+	dsp_status status = DSP_SOK;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pattr != NULL);
+	DBC_REQUIRE(attr_size >= sizeof(struct dsp_nodeattr));
+
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 	} else {
-		hNodeMgr = hNode->hNodeMgr;
-		 /* Enter hNodeMgr critical section (since we're accessing
-		  * data that could be changed by NODE_ChangePriority() and
-		  * NODE_Connect().  */
-		status = SYNC_EnterCS(hNodeMgr->hSync);
+		hnode_mgr = hnode->hnode_mgr;
+		/* Enter hnode_mgr critical section (since we're accessing
+		 * data that could be changed by node_change_priority() and
+		 * node_connect(). */
+		status = sync_enter_cs(hnode_mgr->sync_obj);
 		if (DSP_SUCCEEDED(status)) {
-			pAttr->cbStruct = sizeof(struct DSP_NODEATTR);
-			/* DSP_NODEATTRIN */
-			pAttr->inNodeAttrIn.cbStruct =
-					 sizeof(struct DSP_NODEATTRIN);
-			pAttr->inNodeAttrIn.iPriority = hNode->nPriority;
-			pAttr->inNodeAttrIn.uTimeout = hNode->uTimeout;
-			pAttr->inNodeAttrIn.uHeapSize =
-				hNode->createArgs.asa.taskArgs.uHeapSize;
-			pAttr->inNodeAttrIn.pGPPVirtAddr = (void *)
-				hNode->createArgs.asa.taskArgs.uGPPHeapAddr;
-			pAttr->uInputs = hNode->uNumGPPInputs;
-			pAttr->uOutputs = hNode->uNumGPPOutputs;
-			/* DSP_NODEINFO */
-			GetNodeInfo(hNode, &(pAttr->iNodeInfo));
+			pattr->cb_struct = sizeof(struct dsp_nodeattr);
+			/* dsp_nodeattrin */
+			pattr->in_node_attr_in.cb_struct =
+			    sizeof(struct dsp_nodeattrin);
+			pattr->in_node_attr_in.prio = hnode->prio;
+			pattr->in_node_attr_in.utimeout = hnode->utimeout;
+			pattr->in_node_attr_in.heap_size =
+			    hnode->create_args.asa.task_arg_obj.heap_size;
+			pattr->in_node_attr_in.pgpp_virt_addr = (void *)
+			    hnode->create_args.asa.task_arg_obj.ugpp_heap_addr;
+			pattr->node_attr_inputs = hnode->num_gpp_inputs;
+			pattr->node_attr_outputs = hnode->num_gpp_outputs;
+			/* dsp_nodeinfo */
+			get_node_info(hnode, &(pattr->node_info));
 		}
-		/* end of SYNC_EnterCS */
+		/* end of sync_enter_cs */
 		/* Exit critical section */
-		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+		(void)sync_leave_cs(hnode_mgr->sync_obj);
 	}
 	return status;
 }
 
 /*
- *  ======== NODE_GetChannelId ========
+ *  ======== node_get_channel_id ========
  *  Purpose:
  *      Get the channel index reserved for a stream connection between the
  *      host and a node.
  */
-DSP_STATUS NODE_GetChannelId(struct NODE_OBJECT *hNode, u32 uDir, u32 uIndex,
-			    OUT u32 *pulId)
+dsp_status node_get_channel_id(struct node_object *hnode, u32 dir, u32 index,
+			       OUT u32 *pulId)
 {
-	enum NODE_TYPE nodeType;
-	DSP_STATUS status = DSP_EVALUE;
-	DBC_Require(cRefs > 0);
-	DBC_Require(uDir == DSP_TONODE || uDir == DSP_FROMNODE);
-	DBC_Require(pulId != NULL);
-	GT_4trace(NODE_debugMask, GT_ENTER, "NODE_GetChannelId: hNode: "
-		 "0x%x\tuDir: %d\tuIndex: %d\tpulId: 0x%x\n", hNode, uDir,
-		 uIndex, pulId);
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	enum node_type node_type;
+	dsp_status status = DSP_EVALUE;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(dir == DSP_TONODE || dir == DSP_FROMNODE);
+	DBC_REQUIRE(pulId != NULL);
+
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		return status;
 	}
-	nodeType = NODE_GetType(hNode);
-	if (nodeType != NODE_TASK && nodeType != NODE_DAISSOCKET) {
+	node_type = node_get_type(hnode);
+	if (node_type != NODE_TASK && node_type != NODE_DAISSOCKET) {
 		status = DSP_ENODETYPE;
 		return status;
 	}
-	if (uDir == DSP_TONODE) {
-		if (uIndex < MaxInputs(hNode)) {
-			if (hNode->inputs[uIndex].type == HOSTCONNECT) {
-				*pulId = hNode->inputs[uIndex].devId;
+	if (dir == DSP_TONODE) {
+		if (index < MAX_INPUTS(hnode)) {
+			if (hnode->inputs[index].type == HOSTCONNECT) {
+				*pulId = hnode->inputs[index].dev_id;
 				status = DSP_SOK;
 			}
 		}
 	} else {
-		DBC_Assert(uDir == DSP_FROMNODE);
-		if (uIndex < MaxOutputs(hNode)) {
-			if (hNode->outputs[uIndex].type == HOSTCONNECT) {
-				*pulId = hNode->outputs[uIndex].devId;
+		DBC_ASSERT(dir == DSP_FROMNODE);
+		if (index < MAX_OUTPUTS(hnode)) {
+			if (hnode->outputs[index].type == HOSTCONNECT) {
+				*pulId = hnode->outputs[index].dev_id;
 				status = DSP_SOK;
 			}
 		}
@@ -2000,739 +1817,705 @@
 }
 
 /*
- *  ======== NODE_GetMessage ========
+ *  ======== node_get_message ========
  *  Purpose:
  *      Retrieve a message from a node on the DSP.
  */
-DSP_STATUS NODE_GetMessage(struct NODE_OBJECT *hNode, OUT struct DSP_MSG *pMsg,
-			  u32 uTimeout)
+dsp_status node_get_message(struct node_object *hnode,
+			    OUT struct dsp_msg *pmsg, u32 utimeout)
 {
-	struct NODE_MGR *hNodeMgr;
-	enum NODE_TYPE nodeType;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	DSP_STATUS status = DSP_SOK;
-	void *pTmpBuf;
-	struct DSP_PROCESSORSTATE procStatus;
-	struct PROC_OBJECT *hProcessor;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pMsg != NULL);
-	GT_3trace(NODE_debugMask, GT_ENTER,
-		 "NODE_GetMessage: hNode: 0x%x\tpMsg: "
-		 "0x%x\tuTimeout: 0x%x\n", hNode, pMsg, uTimeout);
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	struct node_mgr *hnode_mgr;
+	enum node_type node_type;
+	struct bridge_drv_interface *intf_fxns;
+	dsp_status status = DSP_SOK;
+	void *tmp_buf;
+	struct dsp_processorstate proc_state;
+	struct proc_object *hprocessor;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pmsg != NULL);
+
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	hProcessor = hNode->hProcessor;
-	status = PROC_GetState(hProcessor, &procStatus,
-					sizeof(struct DSP_PROCESSORSTATE));
+	hprocessor = hnode->hprocessor;
+	status = proc_get_state(hprocessor, &proc_state,
+				sizeof(struct dsp_processorstate));
 	if (DSP_FAILED(status))
 		goto func_end;
 	/* If processor is in error state then don't attempt to get the
-	    message */
-	if (procStatus.iState == PROC_ERROR) {
-		GT_1trace(NODE_debugMask, GT_4CLASS, "NODE_GetMessage:"
-			"		proc Status 0x%x\n", procStatus.iState);
+	   message */
+	if (proc_state.proc_state == PROC_ERROR) {
 		status = DSP_EFAIL;
 		goto func_end;
 	}
-	hNodeMgr = hNode->hNodeMgr;
-	nodeType = NODE_GetType(hNode);
-	if (nodeType != NODE_MESSAGE && nodeType != NODE_TASK &&
-	   nodeType != NODE_DAISSOCKET) {
+	hnode_mgr = hnode->hnode_mgr;
+	node_type = node_get_type(hnode);
+	if (node_type != NODE_MESSAGE && node_type != NODE_TASK &&
+	    node_type != NODE_DAISSOCKET) {
 		status = DSP_ENODETYPE;
 		goto func_end;
 	}
-	 /*  This function will block unless a message is available. Since
+	/*  This function will block unless a message is available. Since
 	 *  DSPNode_RegisterNotify() allows notification when a message
 	 *  is available, the system can be designed so that
 	 *  DSPNode_GetMessage() is only called when a message is
-	 *  available.  */
-	pIntfFxns = hNodeMgr->pIntfFxns;
-	status = (*pIntfFxns->pfnMsgGet)(hNode->hMsgQueue, pMsg, uTimeout);
+	 *  available. */
+	intf_fxns = hnode_mgr->intf_fxns;
+	status =
+	    (*intf_fxns->pfn_msg_get) (hnode->msg_queue_obj, pmsg, utimeout);
 	/* Check if message contains SM descriptor */
-	if (DSP_FAILED(status) ||  !(pMsg->dwCmd & DSP_RMSBUFDESC))
+	if (DSP_FAILED(status) || !(pmsg->dw_cmd & DSP_RMSBUFDESC))
 		goto func_end;
 
-	 /* Translate DSP byte addr to GPP Va.  */
-	pTmpBuf = CMM_XlatorTranslate(hNode->hXlator,
-		(void *)(pMsg->dwArg1 * hNode->hNodeMgr->uDSPWordSize),
-		CMM_DSPPA2PA);
-	if (pTmpBuf  != NULL) {
+	/* Translate DSP byte addr to GPP Va. */
+	tmp_buf = cmm_xlator_translate(hnode->xlator,
+				       (void *)(pmsg->dw_arg1 *
+						hnode->hnode_mgr->
+						udsp_word_size), CMM_DSPPA2PA);
+	if (tmp_buf != NULL) {
 		/* now convert this GPP Pa to Va */
-		pTmpBuf = CMM_XlatorTranslate(hNode->hXlator, pTmpBuf,
-							CMM_PA2VA);
-		if (pTmpBuf != NULL) {
+		tmp_buf = cmm_xlator_translate(hnode->xlator, tmp_buf,
+					       CMM_PA2VA);
+		if (tmp_buf != NULL) {
 			/* Adjust SM size in msg */
-			pMsg->dwArg1 = (u32) pTmpBuf;
-			pMsg->dwArg2 *= hNode->hNodeMgr->uDSPWordSize;
+			pmsg->dw_arg1 = (u32) tmp_buf;
+			pmsg->dw_arg2 *= hnode->hnode_mgr->udsp_word_size;
 		} else {
-			GT_0trace(NODE_debugMask, GT_7CLASS, "NODE_GetMessage: "
-				 "Failed SM translation!\n");
 			status = DSP_ETRANSLATE;
 		}
 	} else {
-		GT_0trace(NODE_debugMask, GT_7CLASS, "NODE_GetMessage: Failed "
-			 "SM Pa/Pa translation!\n");
 		status = DSP_ETRANSLATE;
 	}
 func_end:
+	dev_dbg(bridge, "%s: hnode: %p pmsg: %p utimeout: 0x%x\n", __func__,
+		hnode, pmsg, utimeout);
 	return status;
 }
 
 /*
- *   ======== NODE_GetNldrObj ========
+ *   ======== node_get_nldr_obj ========
  */
-DSP_STATUS NODE_GetNldrObj(struct NODE_MGR *hNodeMgr,
-			  struct NLDR_OBJECT **phNldrObj)
+dsp_status node_get_nldr_obj(struct node_mgr *hnode_mgr,
+			     struct nldr_object **phNldrObj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct NODE_MGR *pNodeMgr = hNodeMgr;
-	DBC_Require(phNldrObj != NULL);
-	GT_2trace(NODE_debugMask, GT_ENTER,
-		 "Entered NODE_GetNldrObj, hNodeMgr: "
-		 "0x%x\n\tphNldrObj:  0x%x\n", hNodeMgr, phNldrObj);
-	if (!MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE))
+	dsp_status status = DSP_SOK;
+	struct node_mgr *node_mgr_obj = hnode_mgr;
+	DBC_REQUIRE(phNldrObj != NULL);
+
+	if (!MEM_IS_VALID_HANDLE(hnode_mgr, NODEMGR_SIGNATURE))
 		status = DSP_EHANDLE;
 	else
-		*phNldrObj = pNodeMgr->hNldr;
+		*phNldrObj = node_mgr_obj->nldr_obj;
 
-	GT_2trace(NODE_debugMask, GT_ENTER,
-		 "Exit NODE_GetNldrObj: status 0x%x\n\t"
-		 "phNldrObj:  0x%x\n", status, *phNldrObj);
-	DBC_Ensure(DSP_SUCCEEDED(status) || ((phNldrObj != NULL) &&
-		  (*phNldrObj == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phNldrObj != NULL) &&
+					     (*phNldrObj == NULL)));
 	return status;
 }
 
 /*
- *  ======== NODE_GetStrmMgr ========
+ *  ======== node_get_strm_mgr ========
  *  Purpose:
  *      Returns the Stream manager.
  */
-DSP_STATUS NODE_GetStrmMgr(struct NODE_OBJECT *hNode,
-			  struct STRM_MGR **phStrmMgr)
+dsp_status node_get_strm_mgr(struct node_object *hnode,
+			     struct strm_mgr **phStrmMgr)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE))
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE))
 		status = DSP_EHANDLE;
 	else
-		*phStrmMgr = hNode->hNodeMgr->hStrmMgr;
+		*phStrmMgr = hnode->hnode_mgr->strm_mgr_obj;
 
 	return status;
 }
 
 /*
- *  ======== NODE_GetLoadType ========
+ *  ======== node_get_load_type ========
  */
-enum NLDR_LOADTYPE NODE_GetLoadType(struct NODE_OBJECT *hNode)
+enum nldr_loadtype node_get_load_type(struct node_object *hnode)
 {
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
-       if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-               GT_1trace(NODE_debugMask, GT_5CLASS,
-                        "NODE_GetLoadType: Failed. hNode:"
-                         " 0x%x\n", hNode);
-               return -1;
-       } else
-               return hNode->dcdProps.objData.nodeObj.usLoadType;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE));
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
+		dev_dbg(bridge, "%s: Failed. hnode: %p\n", __func__, hnode);
+		return -1;
+	} else {
+		return hnode->dcd_props.obj_data.node_obj.us_load_type;
+	}
 }
 
 /*
- *  ======== NODE_GetTimeout ========
+ *  ======== node_get_timeout ========
  *  Purpose:
  *      Returns the timeout value for this node.
  */
-u32 NODE_GetTimeout(struct NODE_OBJECT *hNode)
+u32 node_get_timeout(struct node_object *hnode)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
-       if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-               GT_1trace(NODE_debugMask, GT_5CLASS,
-                        "NODE_GetTimeout: Failed. hNode:"
-                         " 0x%x\n", hNode);
-               return 0;
-       } else
-               return hNode->uTimeout;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE));
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
+		dev_dbg(bridge, "%s: failed. hnode: %p\n", __func__, hnode);
+		return 0;
+	} else {
+		return hnode->utimeout;
+	}
 }
 
 /*
- *  ======== NODE_GetType ========
+ *  ======== node_get_type ========
  *  Purpose:
  *      Returns the node type.
  */
-enum NODE_TYPE NODE_GetType(struct NODE_OBJECT *hNode)
+enum node_type node_get_type(struct node_object *hnode)
 {
-	enum NODE_TYPE nodeType;
+	enum node_type node_type;
 
-	if (hNode == (struct NODE_OBJECT *) DSP_HGPPNODE)
-		nodeType = NODE_GPP;
+	if (hnode == (struct node_object *)DSP_HGPPNODE)
+		node_type = NODE_GPP;
 	else {
-                if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE))
-                        nodeType = -1;
-                else
-                        nodeType = hNode->nType;
+		if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE))
+			node_type = -1;
+		else
+			node_type = hnode->ntype;
 	}
-	return nodeType;
+	return node_type;
 }
 
 /*
- *  ======== NODE_Init ========
+ *  ======== node_init ========
  *  Purpose:
  *      Initialize the NODE module.
  */
-bool NODE_Init(void)
+bool node_init(void)
 {
-	bool fRetVal = true;
-
-	DBC_Require(cRefs >= 0);
-
-	if (cRefs == 0) {
-		DBC_Assert(!NODE_debugMask.flags);
-		GT_create(&NODE_debugMask, "NO");	/* "NO" for NOde */
-	}
-
-	if (fRetVal)
-		cRefs++;
+	DBC_REQUIRE(refs >= 0);
 
-	GT_1trace(NODE_debugMask, GT_5CLASS, "NODE_Init(), ref count: 0x%x\n",
-		 cRefs);
+	refs++;
 
-	DBC_Ensure((fRetVal && (cRefs > 0)) || (!fRetVal && (cRefs >= 0)));
-	return fRetVal;
+	return true;
 }
 
 /*
- *  ======== NODE_OnExit ========
+ *  ======== node_on_exit ========
  *  Purpose:
  *      Gets called when RMS_EXIT is received for a node.
  */
-void NODE_OnExit(struct NODE_OBJECT *hNode, s32 nStatus)
+void node_on_exit(struct node_object *hnode, s32 nStatus)
 {
-	DBC_Assert(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE))
+		return;
+
 	/* Set node state to done */
-	NODE_SetState(hNode, NODE_DONE);
-	hNode->nExitStatus = nStatus;
-	if (hNode->fLoaded && hNode->fPhaseSplit) {
-		(void)hNode->hNodeMgr->nldrFxns.pfnUnload(hNode->hNldrNode,
-							 NLDR_EXECUTE);
-		hNode->fLoaded = false;
+	NODE_SET_STATE(hnode, NODE_DONE);
+	hnode->exit_status = nStatus;
+	if (hnode->loaded && hnode->phase_split) {
+		(void)hnode->hnode_mgr->nldr_fxns.pfn_unload(hnode->
+							     nldr_node_obj,
+							     NLDR_EXECUTE);
+		hnode->loaded = false;
 	}
-	/* Unblock call to NODE_Terminate */
-	(void) SYNC_SetEvent(hNode->hSyncDone);
+	/* Unblock call to node_terminate */
+	(void)sync_set_event(hnode->sync_done);
 	/* Notify clients */
-	PROC_NotifyClients(hNode->hProcessor, DSP_NODESTATECHANGE);
-	NTFY_Notify(hNode->hNtfy, DSP_NODESTATECHANGE);
+	proc_notify_clients(hnode->hprocessor, DSP_NODESTATECHANGE);
+	ntfy_notify(hnode->ntfy_obj, DSP_NODESTATECHANGE);
 }
 
 /*
- *  ======== NODE_Pause ========
+ *  ======== node_pause ========
  *  Purpose:
  *      Suspend execution of a node currently running on the DSP.
  */
-DSP_STATUS NODE_Pause(struct NODE_OBJECT *hNode)
+dsp_status node_pause(struct node_object *hnode)
 {
-	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-	enum NODE_TYPE nodeType;
-	enum NODE_STATE state;
-	struct NODE_MGR *hNodeMgr;
-	DSP_STATUS status = DSP_SOK;
-	u32 procId;
-	struct DSP_PROCESSORSTATE procStatus;
-	struct PROC_OBJECT *hProcessor;
-
-	DBC_Require(cRefs > 0);
+	struct node_object *pnode = (struct node_object *)hnode;
+	enum node_type node_type;
+	enum node_state state;
+	struct node_mgr *hnode_mgr;
+	dsp_status status = DSP_SOK;
+	u32 proc_id;
+	struct dsp_processorstate proc_state;
+	struct proc_object *hprocessor;
 
-	GT_1trace(NODE_debugMask, GT_ENTER, "NODE_Pause: hNode: 0x%x\n", hNode);
+	DBC_REQUIRE(refs > 0);
 
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
-		goto func_end;
 	} else {
-		nodeType = NODE_GetType(hNode);
-		if (nodeType != NODE_TASK && nodeType != NODE_DAISSOCKET)
+		node_type = node_get_type(hnode);
+		if (node_type != NODE_TASK && node_type != NODE_DAISSOCKET)
 			status = DSP_ENODETYPE;
 	}
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+	status = proc_get_processor_id(pnode->hprocessor, &proc_id);
 
-	if (procId == IVA_UNIT)
+	if (proc_id == IVA_UNIT)
 		status = DSP_ENOTIMPL;
 
 	if (DSP_SUCCEEDED(status)) {
-		hNodeMgr = hNode->hNodeMgr;
+		hnode_mgr = hnode->hnode_mgr;
 
 		/* Enter critical section */
-		status = SYNC_EnterCS(hNodeMgr->hSync);
+		status = sync_enter_cs(hnode_mgr->sync_obj);
 
 		if (DSP_SUCCEEDED(status)) {
-			state = NODE_GetState(hNode);
+			state = node_get_state(hnode);
 			/* Check node state */
 			if (state != NODE_RUNNING)
 				status = DSP_EWRONGSTATE;
 
-			hProcessor = hNode->hProcessor;
-			status = PROC_GetState(hProcessor, &procStatus,
-					sizeof(struct DSP_PROCESSORSTATE));
 			if (DSP_FAILED(status))
-				goto func_end;
+				goto func_cont;
+			hprocessor = hnode->hprocessor;
+			status = proc_get_state(hprocessor, &proc_state,
+						sizeof(struct
+						       dsp_processorstate));
+			if (DSP_FAILED(status))
+				goto func_cont;
 			/* If processor is in error state then don't attempt
-			    to send the message */
-			if (procStatus.iState == PROC_ERROR) {
-				GT_1trace(NODE_debugMask, GT_4CLASS,
-					"NODE_Pause: proc Status 0x%x\n",
-					procStatus.iState);
+			   to send the message */
+			if (proc_state.proc_state == PROC_ERROR) {
 				status = DSP_EFAIL;
-				goto func_end;
+				goto func_cont;
 			}
 			if (DSP_SUCCEEDED(status)) {
-				status = DISP_NodeChangePriority(hNodeMgr->
-				   hDisp, hNode,
-				   hNodeMgr->ulFxnAddrs[RMSCHANGENODEPRIORITY],
-				   hNode->nodeEnv, NODE_SUSPENDEDPRI);
+				status =
+				    disp_node_change_priority
+				    (hnode_mgr->disp_obj, hnode,
+				     hnode_mgr->ul_fxn_addrs
+				     [RMSCHANGENODEPRIORITY], hnode->node_env,
+				     NODE_SUSPENDEDPRI);
 			}
 
 			/* Update state */
-			if (DSP_SUCCEEDED(status)) {
-				NODE_SetState(hNode, NODE_PAUSED);
-			} else {
-				GT_1trace(NODE_debugMask, GT_6CLASS,
-					 "NODE_Pause: Failed. hNode:"
-					 " 0x%x\n", hNode);
-			}
+			if (DSP_SUCCEEDED(status))
+				NODE_SET_STATE(hnode, NODE_PAUSED);
 		}
-		/* End of SYNC_EnterCS */
+func_cont:
+		/* End of sync_enter_cs */
 		/* Leave critical section */
-		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+		(void)sync_leave_cs(hnode_mgr->sync_obj);
 		if (DSP_SUCCEEDED(status)) {
-			PROC_NotifyClients(hNode->hProcessor,
-					  DSP_NODESTATECHANGE);
-			NTFY_Notify(hNode->hNtfy, DSP_NODESTATECHANGE);
+			proc_notify_clients(hnode->hprocessor,
+					    DSP_NODESTATECHANGE);
+			ntfy_notify(hnode->ntfy_obj, DSP_NODESTATECHANGE);
 		}
 	}
 func_end:
+	dev_dbg(bridge, "%s: hnode: %p status 0x%x\n", __func__, hnode, status);
 	return status;
 }
 
 /*
- *  ======== NODE_PutMessage ========
+ *  ======== node_put_message ========
  *  Purpose:
  *      Send a message to a message node, task node, or XDAIS socket node. This
  *      function will block until the message stream can accommodate the
  *      message, or a timeout occurs.
  */
-DSP_STATUS NODE_PutMessage(struct NODE_OBJECT *hNode,
-			  IN CONST struct DSP_MSG *pMsg, u32 uTimeout)
+dsp_status node_put_message(struct node_object *hnode,
+			    IN CONST struct dsp_msg *pmsg, u32 utimeout)
 {
-	struct NODE_MGR *hNodeMgr = NULL;
-	enum NODE_TYPE nodeType;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	enum NODE_STATE state;
-	DSP_STATUS status = DSP_SOK;
-	void *pTmpBuf;
-	struct DSP_MSG newMsg;
-	struct DSP_PROCESSORSTATE procStatus;
-	struct PROC_OBJECT *hProcessor;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pMsg != NULL);
-	GT_3trace(NODE_debugMask, GT_ENTER,
-		 "NODE_PutMessage: hNode: 0x%x\tpMsg: "
-		 "0x%x\tuTimeout: 0x%x\n", hNode, pMsg, uTimeout);
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	struct node_mgr *hnode_mgr = NULL;
+	enum node_type node_type;
+	struct bridge_drv_interface *intf_fxns;
+	enum node_state state;
+	dsp_status status = DSP_SOK;
+	void *tmp_buf;
+	struct dsp_msg new_msg;
+	struct dsp_processorstate proc_state;
+	struct proc_object *hprocessor;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pmsg != NULL);
+
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	hProcessor = hNode->hProcessor;
-	status = PROC_GetState(hProcessor, &procStatus,
-					sizeof(struct DSP_PROCESSORSTATE));
+	hprocessor = hnode->hprocessor;
+	status = proc_get_state(hprocessor, &proc_state,
+				sizeof(struct dsp_processorstate));
 	if (DSP_FAILED(status))
 		goto func_end;
 	/* If processor is in bad state then don't attempt sending the
-	    message */
-	if (procStatus.iState == PROC_ERROR) {
-		GT_1trace(NODE_debugMask, GT_4CLASS, "NODE_PutMessage:"
-			"		proc Status 0x%x\n", procStatus.iState);
+	   message */
+	if (proc_state.proc_state == PROC_ERROR) {
 		status = DSP_EFAIL;
 		goto func_end;
 	}
-	hNodeMgr = hNode->hNodeMgr;
-	nodeType = NODE_GetType(hNode);
-	if (nodeType != NODE_MESSAGE && nodeType != NODE_TASK &&
-	    nodeType != NODE_DAISSOCKET)
+	hnode_mgr = hnode->hnode_mgr;
+	node_type = node_get_type(hnode);
+	if (node_type != NODE_MESSAGE && node_type != NODE_TASK &&
+	    node_type != NODE_DAISSOCKET)
 		status = DSP_ENODETYPE;
 
 	if (DSP_SUCCEEDED(status)) {
 		/*  Check node state. Can't send messages to a node after
 		 *  we've sent the RMS_EXIT command. There is still the
-		 *  possibility that NODE_Terminate can be called after we've
+		 *  possibility that node_terminate can be called after we've
 		 *  checked the state. Could add another SYNC object to
-		 *  prevent this (can't use hNodeMgr->hSync, since we don't
+		 *  prevent this (can't use hnode_mgr->sync_obj, since we don't
 		 *  want to block other NODE functions). However, the node may
-		 *  still exit on its own, before this message is sent.  */
-		status = SYNC_EnterCS(hNodeMgr->hSync);
+		 *  still exit on its own, before this message is sent. */
+		status = sync_enter_cs(hnode_mgr->sync_obj);
 		if (DSP_SUCCEEDED(status)) {
-			state = NODE_GetState(hNode);
+			state = node_get_state(hnode);
 			if (state == NODE_TERMINATING || state == NODE_DONE)
 				status = DSP_EWRONGSTATE;
 
 		}
-		/* end of SYNC_EnterCS */
-		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+		/* end of sync_enter_cs */
+		(void)sync_leave_cs(hnode_mgr->sync_obj);
 	}
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	/* assign pMsg values to new msg  */
-	newMsg = *pMsg;
+	/* assign pmsg values to new msg */
+	new_msg = *pmsg;
 	/* Now, check if message contains a SM buffer descriptor */
-	if (pMsg->dwCmd & DSP_RMSBUFDESC) {
+	if (pmsg->dw_cmd & DSP_RMSBUFDESC) {
 		/* Translate GPP Va to DSP physical buf Ptr. */
-		pTmpBuf = CMM_XlatorTranslate(hNode->hXlator,
-			(void *)newMsg.dwArg1, CMM_VA2DSPPA);
-		if (pTmpBuf != NULL) {
+		tmp_buf = cmm_xlator_translate(hnode->xlator,
+					       (void *)new_msg.dw_arg1,
+					       CMM_VA2DSPPA);
+		if (tmp_buf != NULL) {
 			/* got translation, convert to MAUs in msg */
-			if (hNode->hNodeMgr->uDSPWordSize != 0) {
-				newMsg.dwArg1 =
-					(u32)pTmpBuf /
-					hNode->hNodeMgr->uDSPWordSize;
+			if (hnode->hnode_mgr->udsp_word_size != 0) {
+				new_msg.dw_arg1 =
+				    (u32) tmp_buf /
+				    hnode->hnode_mgr->udsp_word_size;
 				/* MAUs */
-				newMsg.dwArg2 /= hNode->hNodeMgr->uDSPWordSize;
+				new_msg.dw_arg2 /= hnode->hnode_mgr->
+				    udsp_word_size;
 			} else {
-				GT_0trace(NODE_debugMask, GT_7CLASS,
-					 "NODE_PutMessage: "
-					 "uDSPWordSize is zero!\n");
+				pr_err("%s: udsp_word_size is zero!\n",
+				       __func__);
 				status = DSP_EFAIL;	/* bad DSPWordSize */
 			}
 		} else {	/* failed to translate buffer address */
-			GT_0trace(NODE_debugMask, GT_7CLASS,
-				 "NODE_PutMessage: Failed to"
-				 " translate SM address\n");
 			status = DSP_ETRANSLATE;
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
-		pIntfFxns = hNodeMgr->pIntfFxns;
-		status = (*pIntfFxns->pfnMsgPut)(hNode->hMsgQueue,
-			 &newMsg, uTimeout);
+		intf_fxns = hnode_mgr->intf_fxns;
+		status = (*intf_fxns->pfn_msg_put) (hnode->msg_queue_obj,
+						    &new_msg, utimeout);
 	}
 func_end:
+	dev_dbg(bridge, "%s: hnode: %p pmsg: %p utimeout: 0x%x, "
+		"status 0x%x\n", __func__, hnode, pmsg, utimeout, status);
 	return status;
 }
 
 /*
- *  ======== NODE_RegisterNotify ========
+ *  ======== node_register_notify ========
  *  Purpose:
  *      Register to be notified on specific events for this node.
  */
-DSP_STATUS NODE_RegisterNotify(struct NODE_OBJECT *hNode, u32 uEventMask,
-			       u32 uNotifyType,
-			       struct DSP_NOTIFICATION *hNotification)
-{
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(hNotification != NULL);
-
-	GT_4trace(NODE_debugMask, GT_ENTER,
-		 "NODE_RegisterNotify: hNode: 0x%x\t"
-		 "uEventMask: 0x%x\tuNotifyType: 0x%x\thNotification: 0x%x\n",
-		 hNode, uEventMask, uNotifyType, hNotification);
+dsp_status node_register_notify(struct node_object *hnode, u32 event_mask,
+				u32 notify_type,
+				struct dsp_notification *hnotification)
+{
+	struct bridge_drv_interface *intf_fxns;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(hnotification != NULL);
 
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 	} else {
 		/* Check if event mask is a valid node related event */
-		if (uEventMask & ~(DSP_NODESTATECHANGE |
-		   DSP_NODEMESSAGEREADY))
+		if (event_mask & ~(DSP_NODESTATECHANGE | DSP_NODEMESSAGEREADY))
 			status = DSP_EVALUE;
 
 		/* Check if notify type is valid */
-		if (uNotifyType != DSP_SIGNALEVENT)
+		if (notify_type != DSP_SIGNALEVENT)
 			status = DSP_EVALUE;
 
 		/* Only one Notification can be registered at a
 		 * time - Limitation */
-		if (uEventMask == (DSP_NODESTATECHANGE |
-		   DSP_NODEMESSAGEREADY))
+		if (event_mask == (DSP_NODESTATECHANGE | DSP_NODEMESSAGEREADY))
 			status = DSP_EVALUE;
 	}
 	if (DSP_SUCCEEDED(status)) {
-		if (uEventMask == DSP_NODESTATECHANGE) {
-			status = NTFY_Register(hNode->hNtfy, hNotification,
-				 uEventMask & DSP_NODESTATECHANGE, uNotifyType);
+		if (event_mask == DSP_NODESTATECHANGE) {
+			status = ntfy_register(hnode->ntfy_obj, hnotification,
+					       event_mask & DSP_NODESTATECHANGE,
+					       notify_type);
 		} else {
-			/* Send Message part of event mask to MSG */
-			pIntfFxns = hNode->hNodeMgr->pIntfFxns;
-			status = (*pIntfFxns->pfnMsgRegisterNotify)
-				 (hNode->hMsgQueue,
-				 uEventMask & DSP_NODEMESSAGEREADY, uNotifyType,
-				 hNotification);
+			/* Send Message part of event mask to msg_ctrl */
+			intf_fxns = hnode->hnode_mgr->intf_fxns;
+			status = (*intf_fxns->pfn_msg_register_notify)
+			    (hnode->msg_queue_obj,
+			     event_mask & DSP_NODEMESSAGEREADY, notify_type,
+			     hnotification);
 		}
 
 	}
+	dev_dbg(bridge, "%s: hnode: %p event_mask: 0x%x notify_type: 0x%x "
+		"hnotification: %p status 0x%x\n", __func__, hnode,
+		event_mask, notify_type, hnotification, status);
 	return status;
 }
 
 /*
- *  ======== NODE_Run ========
+ *  ======== node_run ========
  *  Purpose:
  *      Start execution of a node's execute phase, or resume execution of a node
  *      that has been suspended (via NODE_NodePause()) on the DSP. Load the
  *      node's execute function if necessary.
  */
-DSP_STATUS NODE_Run(struct NODE_OBJECT *hNode)
+dsp_status node_run(struct node_object *hnode)
 {
-	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-	struct NODE_MGR *hNodeMgr;
-	enum NODE_TYPE nodeType;
-	enum NODE_STATE state;
-	u32 ulExecuteFxn;
-	u32 ulFxnAddr;
-	DSP_STATUS status = DSP_SOK;
-	u32 procId;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct DSP_PROCESSORSTATE procStatus;
-	struct PROC_OBJECT *hProcessor;
-
-	DBC_Require(cRefs > 0);
-	GT_1trace(NODE_debugMask, GT_ENTER, "NODE_Run: hNode: 0x%x\n", hNode);
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	struct node_object *pnode = (struct node_object *)hnode;
+	struct node_mgr *hnode_mgr;
+	enum node_type node_type;
+	enum node_state state;
+	u32 ul_execute_fxn;
+	u32 ul_fxn_addr;
+	dsp_status status = DSP_SOK;
+	u32 proc_id;
+	struct bridge_drv_interface *intf_fxns;
+	struct dsp_processorstate proc_state;
+	struct proc_object *hprocessor;
+
+	DBC_REQUIRE(refs > 0);
+
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	hProcessor = hNode->hProcessor;
-	status = PROC_GetState(hProcessor, &procStatus,
-					sizeof(struct DSP_PROCESSORSTATE));
+	hprocessor = hnode->hprocessor;
+	status = proc_get_state(hprocessor, &proc_state,
+				sizeof(struct dsp_processorstate));
 	if (DSP_FAILED(status))
 		goto func_end;
 	/* If processor is in error state then don't attempt to run the node */
-	if (procStatus.iState == PROC_ERROR) {
-		GT_1trace(NODE_debugMask, GT_4CLASS, "NODE_Run:"
-			"		proc Status 0x%x\n", procStatus.iState);
+	if (proc_state.proc_state == PROC_ERROR) {
 		status = DSP_EFAIL;
 		goto func_end;
 	}
-	nodeType = NODE_GetType(hNode);
-	if (nodeType == NODE_DEVICE)
+	node_type = node_get_type(hnode);
+	if (node_type == NODE_DEVICE)
 		status = DSP_ENODETYPE;
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	hNodeMgr = hNode->hNodeMgr;
-	pIntfFxns = hNodeMgr->pIntfFxns;
+	hnode_mgr = hnode->hnode_mgr;
+	if (!MEM_IS_VALID_HANDLE(hnode_mgr, NODEMGR_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	intf_fxns = hnode_mgr->intf_fxns;
 	/* Enter critical section */
-	status = SYNC_EnterCS(hNodeMgr->hSync);
+	status = sync_enter_cs(hnode_mgr->sync_obj);
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-	state = NODE_GetState(hNode);
+	state = node_get_state(hnode);
 	if (state != NODE_CREATED && state != NODE_PAUSED)
 		status = DSP_EWRONGSTATE;
 
 	if (DSP_SUCCEEDED(status))
-		status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+		status = proc_get_processor_id(pnode->hprocessor, &proc_id);
 
 	if (DSP_FAILED(status))
 		goto func_cont1;
 
-	if ((procId != DSP_UNIT) && (procId != IVA_UNIT))
+	if ((proc_id != DSP_UNIT) && (proc_id != IVA_UNIT))
 		goto func_cont1;
 
 	if (state == NODE_CREATED) {
 		/* If node's execute function is not loaded, load it */
-		if (!(hNode->fLoaded) && hNode->fPhaseSplit) {
-			status = hNodeMgr->nldrFxns.pfnLoad(hNode->hNldrNode,
-				NLDR_EXECUTE);
+		if (!(hnode->loaded) && hnode->phase_split) {
+			status =
+			    hnode_mgr->nldr_fxns.pfn_load(hnode->nldr_node_obj,
+							  NLDR_EXECUTE);
 			if (DSP_SUCCEEDED(status)) {
-				hNode->fLoaded = true;
+				hnode->loaded = true;
 			} else {
-				GT_1trace(NODE_debugMask, GT_ENTER,
-					 "NODE_Run: failed to load "
-					 "execute code:0x%x\n", status);
+				pr_err("%s: fail - load execute code: 0x%x\n",
+				       __func__, status);
 			}
 		}
 		if (DSP_SUCCEEDED(status)) {
 			/* Get address of node's execute function */
-			if (procId == IVA_UNIT)
-				ulExecuteFxn = (u32) hNode->nodeEnv;
+			if (proc_id == IVA_UNIT)
+				ul_execute_fxn = (u32) hnode->node_env;
 			else {
-				status = GetFxnAddress(hNode, &ulExecuteFxn,
-					 EXECUTEPHASE);
+				status = get_fxn_address(hnode, &ul_execute_fxn,
+							 EXECUTEPHASE);
 			}
 		}
 		if (DSP_SUCCEEDED(status)) {
-			ulFxnAddr = hNodeMgr->ulFxnAddrs[RMSEXECUTENODE];
-			status = DISP_NodeRun(hNodeMgr->hDisp, hNode, ulFxnAddr,
-					     ulExecuteFxn, hNode->nodeEnv);
+			ul_fxn_addr = hnode_mgr->ul_fxn_addrs[RMSEXECUTENODE];
+			status =
+			    disp_node_run(hnode_mgr->disp_obj, hnode,
+					  ul_fxn_addr, ul_execute_fxn,
+					  hnode->node_env);
 		}
 	} else if (state == NODE_PAUSED) {
-		ulFxnAddr = hNodeMgr->ulFxnAddrs[RMSCHANGENODEPRIORITY];
-		status = DISP_NodeChangePriority(hNodeMgr->hDisp, hNode,
-						ulFxnAddr, hNode->nodeEnv,
-						NODE_GetPriority(hNode));
+		ul_fxn_addr = hnode_mgr->ul_fxn_addrs[RMSCHANGENODEPRIORITY];
+		status = disp_node_change_priority(hnode_mgr->disp_obj, hnode,
+						   ul_fxn_addr, hnode->node_env,
+						   NODE_GET_PRIORITY(hnode));
 	} else {
 		/* We should never get here */
-		DBC_Assert(false);
+		DBC_ASSERT(false);
 	}
 func_cont1:
 	/* Update node state. */
 	if (DSP_SUCCEEDED(status))
-		NODE_SetState(hNode, NODE_RUNNING);
-	 else /* Set state back to previous value */
-		NODE_SetState(hNode, state);
-	/*End of SYNC_EnterCS */
+		NODE_SET_STATE(hnode, NODE_RUNNING);
+	else			/* Set state back to previous value */
+		NODE_SET_STATE(hnode, state);
+	/*End of sync_enter_cs */
 	/* Exit critical section */
 func_cont:
-	(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	(void)sync_leave_cs(hnode_mgr->sync_obj);
 	if (DSP_SUCCEEDED(status)) {
-		PROC_NotifyClients(hNode->hProcessor,
-			  DSP_NODESTATECHANGE);
-		NTFY_Notify(hNode->hNtfy, DSP_NODESTATECHANGE);
+		proc_notify_clients(hnode->hprocessor, DSP_NODESTATECHANGE);
+		ntfy_notify(hnode->ntfy_obj, DSP_NODESTATECHANGE);
 	}
 func_end:
+	dev_dbg(bridge, "%s: hnode: %p status 0x%x\n", __func__, hnode, status);
 	return status;
 }
 
 /*
- *  ======== NODE_Terminate ========
+ *  ======== node_terminate ========
  *  Purpose:
  *      Signal a node running on the DSP that it should exit its execute phase
  *      function.
  */
-DSP_STATUS NODE_Terminate(struct NODE_OBJECT *hNode, OUT DSP_STATUS *pStatus)
+dsp_status node_terminate(struct node_object *hnode, OUT dsp_status *pstatus)
 {
-	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-	struct NODE_MGR *hNodeMgr = NULL;
-	enum NODE_TYPE nodeType;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	enum NODE_STATE state;
-	struct DSP_MSG msg, killmsg;
-	DSP_STATUS status = DSP_SOK;
-	u32 procId, killTimeOut;
-	struct DEH_MGR *hDehMgr;
-	struct DSP_PROCESSORSTATE procStatus;
+	struct node_object *pnode = (struct node_object *)hnode;
+	struct node_mgr *hnode_mgr = NULL;
+	enum node_type node_type;
+	struct bridge_drv_interface *intf_fxns;
+	enum node_state state;
+	struct dsp_msg msg, killmsg;
+	dsp_status status = DSP_SOK;
+	u32 proc_id, kill_time_out;
+	struct deh_mgr *hdeh_mgr;
+	struct dsp_processorstate proc_state;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(pStatus != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pstatus != NULL);
 
-	GT_1trace(NODE_debugMask, GT_ENTER,
-		 "NODE_Terminate: hNode: 0x%x\n", hNode);
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE) || !hnode->hnode_mgr) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	if (pNode->hProcessor == NULL) {
-		GT_1trace(NODE_debugMask, GT_4CLASS,
-		"NODE_Terminate: pNode->hProcessor = 0x%x\n",
-		pNode->hProcessor);
+	if (pnode->hprocessor == NULL) {
+		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+	status = proc_get_processor_id(pnode->hprocessor, &proc_id);
 
 	if (DSP_SUCCEEDED(status)) {
-		hNodeMgr = hNode->hNodeMgr;
-		nodeType = NODE_GetType(hNode);
-		if (nodeType != NODE_TASK && nodeType !=
-			   NODE_DAISSOCKET)
-				status = DSP_ENODETYPE;
+		hnode_mgr = hnode->hnode_mgr;
+		node_type = node_get_type(hnode);
+		if (node_type != NODE_TASK && node_type != NODE_DAISSOCKET)
+			status = DSP_ENODETYPE;
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Check node state */
-		status = SYNC_EnterCS(hNodeMgr->hSync);
+		status = sync_enter_cs(hnode_mgr->sync_obj);
 		if (DSP_SUCCEEDED(status)) {
-			state = NODE_GetState(hNode);
+			state = node_get_state(hnode);
 			if (state != NODE_RUNNING) {
 				status = DSP_EWRONGSTATE;
 				/* Set the exit status if node terminated on
 				 * its own. */
 				if (state == NODE_DONE)
-					*pStatus = hNode->nExitStatus;
+					*pstatus = hnode->exit_status;
 
 			} else {
-				NODE_SetState(hNode, NODE_TERMINATING);
+				NODE_SET_STATE(hnode, NODE_TERMINATING);
 			}
 		}
-		/* end of SYNC_EnterCS */
-		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+		/* end of sync_enter_cs */
+		(void)sync_leave_cs(hnode_mgr->sync_obj);
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/*
 		 *  Send exit message. Do not change state to NODE_DONE
 		 *  here. That will be done in callback.
 		 */
-		GT_1trace(NODE_debugMask, GT_5CLASS,
-			 "NODE_Terminate: env = 0x%x\n", hNode->nodeEnv);
-
-		status = PROC_GetState(pNode->hProcessor, &procStatus,
-					sizeof(struct DSP_PROCESSORSTATE));
+		status = proc_get_state(pnode->hprocessor, &proc_state,
+					sizeof(struct dsp_processorstate));
 		if (DSP_FAILED(status))
 			goto func_cont;
 		/* If processor is in error state then don't attempt to send
 		 * A kill task command */
-		if (procStatus.iState == PROC_ERROR) {
-			GT_1trace(NODE_debugMask, GT_4CLASS, "NODE_Terminate:"
-				" proc Status 0x%x\n", procStatus.iState);
+		if (proc_state.proc_state == PROC_ERROR) {
 			status = DSP_EFAIL;
 			goto func_cont;
 		}
 
-		msg.dwCmd = RMS_EXIT;
-		msg.dwArg1 = hNode->nodeEnv;
-		killmsg.dwCmd = RMS_KILLTASK;
-		killmsg.dwArg1 = hNode->nodeEnv;
-		pIntfFxns = hNodeMgr->pIntfFxns;
+		msg.dw_cmd = RMS_EXIT;
+		msg.dw_arg1 = hnode->node_env;
+		killmsg.dw_cmd = RMS_KILLTASK;
+		killmsg.dw_arg1 = hnode->node_env;
+		intf_fxns = hnode_mgr->intf_fxns;
 
-		if (hNode->uTimeout > MAXTIMEOUT)
-			killTimeOut = MAXTIMEOUT;
+		if (hnode->utimeout > MAXTIMEOUT)
+			kill_time_out = MAXTIMEOUT;
 		else
-			killTimeOut = (hNode->uTimeout)*2;
+			kill_time_out = (hnode->utimeout) * 2;
 
-		status = (*pIntfFxns->pfnMsgPut)(hNode->hMsgQueue, &msg,
-							hNode->uTimeout);
+		status = (*intf_fxns->pfn_msg_put) (hnode->msg_queue_obj, &msg,
+						    hnode->utimeout);
+		/* FIXME */
 		if (DSP_SUCCEEDED(status)) {
 			/*  Wait on synchronization object that will be
 			 *  posted in the callback on receiving RMS_EXIT
-			 *  message, or by NODE_Delete. Check for valid hNode,
-			 *  in case posted by NODE_Delete().  */
-			status = SYNC_WaitOnEvent(hNode->hSyncDone,
-							killTimeOut/2);
+			 *  message, or by node_delete. Check for valid hnode,
+			 *  in case posted by node_delete(). */
+			status = sync_wait_on_event(hnode->sync_done,
+						    kill_time_out / 2);
 			if (DSP_FAILED(status)) {
 				if (status == DSP_ETIMEOUT) {
-					status = (*pIntfFxns->pfnMsgPut)
-						 (hNode->hMsgQueue, &killmsg,
-						 hNode->uTimeout);
+					status = (*intf_fxns->pfn_msg_put)
+					    (hnode->msg_queue_obj, &killmsg,
+					     hnode->utimeout);
 					if (DSP_SUCCEEDED(status)) {
-						status = SYNC_WaitOnEvent
-							(hNode->hSyncDone,
-							killTimeOut/2);
+						status = sync_wait_on_event
+						    (hnode->sync_done,
+						     kill_time_out / 2);
 						if (DSP_FAILED(status)) {
 							/* Here it goes the part
-							* of the simulation of
-							* the DSP exception */
-						    DEV_GetDehMgr(hNodeMgr->
-							hDevObject, &hDehMgr);
-						    if (hDehMgr) {
-							(*pIntfFxns->
-							pfnDehNotify)(hDehMgr,
-							DSP_SYSERROR,
-							DSP_EXCEPTIONABORT);
-							    status = DSP_EFAIL;
-						    }
+							 * of the simulation of
+							 * the DSP exception */
+							dev_get_deh_mgr
+							   (hnode_mgr->hdev_obj,
+							    &hdeh_mgr);
+							if (hdeh_mgr) {
+								(*intf_fxns->
+								pfn_deh_notify)
+								 (hdeh_mgr,
+								  DSP_SYSERROR,
+								  DSP_EXCEPTIONABORT);
+								status =
+								    DSP_EFAIL;
+							}
 						} else
-						    status = DSP_SOK;
+							status = DSP_SOK;
 					}
 				} else
 					status = DSP_EFAIL;
-			} else 	/* Convert SYNC status to DSP status */
+			} else	/* Convert SYNC status to DSP status */
 				status = DSP_SOK;
 		}
 	}
@@ -2740,517 +2523,475 @@
 	if (DSP_SUCCEEDED(status)) {
 		/* Enter CS before getting exit status, in case node was
 		 * deleted. */
-		status = SYNC_EnterCS(hNodeMgr->hSync);
+		status = sync_enter_cs(hnode_mgr->sync_obj);
 		/* Make sure node wasn't deleted while we blocked */
-		if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
 			status = DSP_EFAIL;
 		} else {
-			*pStatus = hNode->nExitStatus;
-			GT_1trace(NODE_debugMask, GT_ENTER,
-				 "NODE_Terminate: env = 0x%x "
-				 "succeeded.\n", hNode->nodeEnv);
+			*pstatus = hnode->exit_status;
+			dev_dbg(bridge, "%s: hnode: %p env 0x%x status 0x%x\n",
+				__func__, hnode, hnode->node_env, status);
 		}
-		(void)SYNC_LeaveCS(hNodeMgr->hSync);
-	}		/*End of SYNC_EnterCS */
+		(void)sync_leave_cs(hnode_mgr->sync_obj);
+	}			/*End of sync_enter_cs */
 func_end:
 	return status;
 }
 
 /*
- *  ======== DeleteNode ========
+ *  ======== delete_node ========
  *  Purpose:
- *      Free GPP resources allocated in NODE_Allocate() or NODE_Connect().
+ *      Free GPP resources allocated in node_allocate() or node_connect().
  */
-static void DeleteNode(struct NODE_OBJECT *hNode,
-		struct PROCESS_CONTEXT *pr_ctxt)
+static void delete_node(struct node_object *hnode,
+			struct process_context *pr_ctxt)
 {
-	struct NODE_MGR *hNodeMgr;
-	struct CMM_XLATOROBJECT *hXlator;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct node_mgr *hnode_mgr;
+	struct cmm_xlatorobject *xlator;
+	struct bridge_drv_interface *intf_fxns;
 	u32 i;
-	enum NODE_TYPE nodeType;
-	struct STREAM stream;
-	struct NODE_MSGARGS msgArgs;
-	struct NODE_TASKARGS taskArgs;
+	enum node_type node_type;
+	struct stream_chnl stream;
+	struct node_msgargs node_msg_args;
+	struct node_taskargs task_arg_obj;
 #ifdef DSP_DMM_DEBUG
-	struct DMM_OBJECT *hDmmMgr;
-	struct PROC_OBJECT *pProcObject =
-			(struct PROC_OBJECT *)hNode->hProcessor;
+	struct dmm_object *dmm_mgr;
+	struct proc_object *p_proc_object =
+	    (struct proc_object *)hnode->hprocessor;
 #endif
-	DSP_STATUS status;
-	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
-	hNodeMgr = hNode->hNodeMgr;
-       if (!MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE))
-               return;
-	hXlator = hNode->hXlator;
-	nodeType = NODE_GetType(hNode);
-	if (nodeType != NODE_DEVICE) {
-		msgArgs = hNode->createArgs.asa.msgArgs;
-		if (msgArgs.pData)
-			MEM_Free(msgArgs.pData);
-
-		/* Free MSG queue */
-		if (hNode->hMsgQueue) {
-			pIntfFxns = hNodeMgr->pIntfFxns;
-			(*pIntfFxns->pfnMsgDeleteQueue) (hNode->hMsgQueue);
-                       hNode->hMsgQueue = NULL;
-
+	dsp_status status;
+	if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE))
+		goto func_end;
+	hnode_mgr = hnode->hnode_mgr;
+	if (!MEM_IS_VALID_HANDLE(hnode_mgr, NODEMGR_SIGNATURE))
+		goto func_end;
+	xlator = hnode->xlator;
+	node_type = node_get_type(hnode);
+	if (node_type != NODE_DEVICE) {
+		node_msg_args = hnode->create_args.asa.node_msg_args;
+		kfree(node_msg_args.pdata);
+
+		/* Free msg_ctrl queue */
+		if (hnode->msg_queue_obj) {
+			intf_fxns = hnode_mgr->intf_fxns;
+			(*intf_fxns->pfn_msg_delete_queue) (hnode->
+							    msg_queue_obj);
+			hnode->msg_queue_obj = NULL;
 		}
-		if (hNode->hSyncDone)
-			(void) SYNC_CloseEvent(hNode->hSyncDone);
+		if (hnode->sync_done)
+			(void)sync_close_event(hnode->sync_done);
 
 		/* Free all stream info */
-		if (hNode->inputs) {
-			for (i = 0; i < MaxInputs(hNode); i++) {
-				stream = hNode->inputs[i];
-				FreeStream(hNodeMgr, stream);
-			}
-			MEM_Free(hNode->inputs);
-                       hNode->inputs = NULL;
-		}
-		if (hNode->outputs) {
-			for (i = 0; i < MaxOutputs(hNode); i++) {
-				stream = hNode->outputs[i];
-				FreeStream(hNodeMgr, stream);
-			}
-			MEM_Free(hNode->outputs);
-                       hNode->outputs = NULL;
-		}
-		taskArgs = hNode->createArgs.asa.taskArgs;
-		if (taskArgs.strmInDef) {
-			for (i = 0; i < MaxInputs(hNode); i++) {
-				if (taskArgs.strmInDef[i].szDevice) {
-					MEM_Free(taskArgs.strmInDef[i].
-						szDevice);
-                                       taskArgs.strmInDef[i].szDevice = NULL;
-				}
-			}
-			MEM_Free(taskArgs.strmInDef);
-			taskArgs.strmInDef = NULL;
-		}
-		if (taskArgs.strmOutDef) {
-			for (i = 0; i < MaxOutputs(hNode); i++) {
-				if (taskArgs.strmOutDef[i].szDevice) {
-					MEM_Free(taskArgs.strmOutDef[i].
-						szDevice);
-                                       taskArgs.strmOutDef[i].szDevice = NULL;
-				}
-			}
-			MEM_Free(taskArgs.strmOutDef);
-			taskArgs.strmOutDef = NULL;
-		}
-		if (taskArgs.uDSPHeapResAddr) {
-			status = PROC_UnMap(hNode->hProcessor,
-					(void *)taskArgs.uDSPHeapAddr,
-					pr_ctxt);
-			if (DSP_SUCCEEDED(status)) {
-				GT_0trace(NODE_debugMask, GT_5CLASS,
-					 "DSPProcessor_UnMap succeeded.\n");
-			} else {
-				GT_1trace(NODE_debugMask, GT_5CLASS,
-					 "DSPProcessor_UnMap failed."
-					 " Status = 0x%x\n", (u32)status);
-			}
-			status = PROC_UnReserveMemory(hNode->hProcessor,
-					(void *)taskArgs.uDSPHeapResAddr);
-			if (DSP_SUCCEEDED(status)) {
-				GT_0trace(NODE_debugMask, GT_5CLASS,
-					 "DSPProcessor_UnReserveMemory "
-					 "succeeded.\n");
-			} else {
-				GT_1trace(NODE_debugMask, GT_5CLASS,
-					 "DSPProcessor_UnReserveMemory "
-					 "failed. Status = 0x%x\n",
-					 (u32)status);
-			}
+		if (hnode->inputs) {
+			for (i = 0; i < MAX_INPUTS(hnode); i++) {
+				stream = hnode->inputs[i];
+				free_stream(hnode_mgr, stream);
+			}
+			kfree(hnode->inputs);
+			hnode->inputs = NULL;
+		}
+		if (hnode->outputs) {
+			for (i = 0; i < MAX_OUTPUTS(hnode); i++) {
+				stream = hnode->outputs[i];
+				free_stream(hnode_mgr, stream);
+			}
+			kfree(hnode->outputs);
+			hnode->outputs = NULL;
+		}
+		task_arg_obj = hnode->create_args.asa.task_arg_obj;
+		if (task_arg_obj.strm_in_def) {
+			for (i = 0; i < MAX_INPUTS(hnode); i++) {
+				kfree(task_arg_obj.strm_in_def[i].sz_device);
+				task_arg_obj.strm_in_def[i].sz_device = NULL;
+			}
+			kfree(task_arg_obj.strm_in_def);
+			task_arg_obj.strm_in_def = NULL;
+		}
+		if (task_arg_obj.strm_out_def) {
+			for (i = 0; i < MAX_OUTPUTS(hnode); i++) {
+				kfree(task_arg_obj.strm_out_def[i].sz_device);
+				task_arg_obj.strm_out_def[i].sz_device = NULL;
+			}
+			kfree(task_arg_obj.strm_out_def);
+			task_arg_obj.strm_out_def = NULL;
+		}
+		if (task_arg_obj.udsp_heap_res_addr) {
+			status = proc_un_map(hnode->hprocessor, (void *)
+					     task_arg_obj.udsp_heap_addr,
+					     pr_ctxt);
+
+			status = proc_un_reserve_memory(hnode->hprocessor,
+							(void *)
+							task_arg_obj.
+							udsp_heap_res_addr,
+							pr_ctxt);
 #ifdef DSP_DMM_DEBUG
-			status = DMM_GetHandle(pProcObject, &hDmmMgr);
+			status = dmm_get_handle(p_proc_object, &dmm_mgr);
 			if (DSP_SUCCEEDED(status))
-				DMM_MemMapDump(hDmmMgr);
+				dmm_mem_map_dump(dmm_mgr);
 #endif
 		}
 	}
-	if (nodeType != NODE_MESSAGE) {
-               if (hNode->streamConnect) {
-			MEM_Free(hNode->streamConnect);
-                       hNode->streamConnect = NULL;
-               }
-	}
-       if (hNode->pstrDevName) {
-		MEM_Free(hNode->pstrDevName);
-               hNode->pstrDevName = NULL;
-       }
-
-       if (hNode->hNtfy) {
-		NTFY_Delete(hNode->hNtfy);
-               hNode->hNtfy = NULL;
-       }
-
-	/* These were allocated in DCD_GetObjectDef (via NODE_Allocate) */
-       if (hNode->dcdProps.objData.nodeObj.pstrCreatePhaseFxn) {
-		MEM_Free(hNode->dcdProps.objData.nodeObj.pstrCreatePhaseFxn);
-               hNode->dcdProps.objData.nodeObj.pstrCreatePhaseFxn = NULL;
-       }
-
-       if (hNode->dcdProps.objData.nodeObj.pstrExecutePhaseFxn) {
-		MEM_Free(hNode->dcdProps.objData.nodeObj.pstrExecutePhaseFxn);
-               hNode->dcdProps.objData.nodeObj.pstrExecutePhaseFxn = NULL;
-       }
-
-       if (hNode->dcdProps.objData.nodeObj.pstrDeletePhaseFxn) {
-		MEM_Free(hNode->dcdProps.objData.nodeObj.pstrDeletePhaseFxn);
-               hNode->dcdProps.objData.nodeObj.pstrDeletePhaseFxn = NULL;
-       }
-
-       if (hNode->dcdProps.objData.nodeObj.pstrIAlgName) {
-		MEM_Free(hNode->dcdProps.objData.nodeObj.pstrIAlgName);
-               hNode->dcdProps.objData.nodeObj.pstrIAlgName = NULL;
-       }
+	if (node_type != NODE_MESSAGE) {
+		kfree(hnode->stream_connect);
+		hnode->stream_connect = NULL;
+	}
+	kfree(hnode->pstr_dev_name);
+	hnode->pstr_dev_name = NULL;
 
-	/* Free all SM address translator resources */
-       if (hXlator) {
-		(void) CMM_XlatorDelete(hXlator, TRUE);	/* force free */
-               hXlator = NULL;
-       }
+	if (hnode->ntfy_obj) {
+		ntfy_delete(hnode->ntfy_obj);
+		hnode->ntfy_obj = NULL;
+	}
+
+	/* These were allocated in dcd_get_object_def (via node_allocate) */
+	kfree(hnode->dcd_props.obj_data.node_obj.pstr_create_phase_fxn);
+	hnode->dcd_props.obj_data.node_obj.pstr_create_phase_fxn = NULL;
+
+	kfree(hnode->dcd_props.obj_data.node_obj.pstr_execute_phase_fxn);
+	hnode->dcd_props.obj_data.node_obj.pstr_execute_phase_fxn = NULL;
 
-       if (hNode->hNldrNode) {
-		hNodeMgr->nldrFxns.pfnFree(hNode->hNldrNode);
-               hNode->hNldrNode = NULL;
-       }
+	kfree(hnode->dcd_props.obj_data.node_obj.pstr_delete_phase_fxn);
+	hnode->dcd_props.obj_data.node_obj.pstr_delete_phase_fxn = NULL;
 
-	MEM_FreeObject(hNode);
-       hNode = NULL;
+	kfree(hnode->dcd_props.obj_data.node_obj.pstr_i_alg_name);
+	hnode->dcd_props.obj_data.node_obj.pstr_i_alg_name = NULL;
+
+	/* Free all SM address translator resources */
+	if (xlator) {
+		(void)cmm_xlator_delete(xlator, TRUE);	/* force free */
+		xlator = NULL;
+	}
+
+	kfree(hnode->nldr_node_obj);
+	hnode->nldr_node_obj = NULL;
+	hnode->hnode_mgr = NULL;
+	MEM_FREE_OBJECT(hnode);
+	hnode = NULL;
+func_end:
+	return;
 }
 
 /*
- *  ======== DeleteNodeMgr ========
+ *  ======== delete_node_mgr ========
  *  Purpose:
  *      Frees the node manager.
  */
-static void DeleteNodeMgr(struct NODE_MGR *hNodeMgr)
+static void delete_node_mgr(struct node_mgr *hnode_mgr)
 {
-	struct NODE_OBJECT *hNode;
+	struct node_object *hnode;
 
-	if (MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE)) {
+	if (MEM_IS_VALID_HANDLE(hnode_mgr, NODEMGR_SIGNATURE)) {
 		/* Free resources */
-		if (hNodeMgr->hDcdMgr)
-			DCD_DestroyManager(hNodeMgr->hDcdMgr);
+		if (hnode_mgr->hdcd_mgr)
+			dcd_destroy_manager(hnode_mgr->hdcd_mgr);
 
 		/* Remove any elements remaining in lists */
-		if (hNodeMgr->nodeList) {
-			while ((hNode =
-				(struct NODE_OBJECT *)LST_GetHead(hNodeMgr->
-				nodeList)))
-					DeleteNode(hNode, NULL);
+		if (hnode_mgr->node_list) {
+			while ((hnode = (struct node_object *)
+				lst_get_head(hnode_mgr->node_list)))
+				delete_node(hnode, NULL);
 
-			DBC_Assert(LST_IsEmpty(hNodeMgr->nodeList));
-			LST_Delete(hNodeMgr->nodeList);
+			DBC_ASSERT(LST_IS_EMPTY(hnode_mgr->node_list));
+			kfree(hnode_mgr->node_list);
 		}
-		if (hNodeMgr->hNtfy)
-			NTFY_Delete(hNodeMgr->hNtfy);
+		if (hnode_mgr->ntfy_obj)
+			ntfy_delete(hnode_mgr->ntfy_obj);
 
-		if (hNodeMgr->pipeMap)
-			GB_delete(hNodeMgr->pipeMap);
+		if (hnode_mgr->pipe_map)
+			gb_delete(hnode_mgr->pipe_map);
 
-		if (hNodeMgr->pipeDoneMap)
-			GB_delete(hNodeMgr->pipeDoneMap);
+		if (hnode_mgr->pipe_done_map)
+			gb_delete(hnode_mgr->pipe_done_map);
 
-		if (hNodeMgr->chnlMap)
-			GB_delete(hNodeMgr->chnlMap);
+		if (hnode_mgr->chnl_map)
+			gb_delete(hnode_mgr->chnl_map);
 
-		if (hNodeMgr->dmaChnlMap)
-			GB_delete(hNodeMgr->dmaChnlMap);
+		if (hnode_mgr->dma_chnl_map)
+			gb_delete(hnode_mgr->dma_chnl_map);
 
-		if (hNodeMgr->zChnlMap)
-			GB_delete(hNodeMgr->zChnlMap);
+		if (hnode_mgr->zc_chnl_map)
+			gb_delete(hnode_mgr->zc_chnl_map);
 
-		if (hNodeMgr->hDisp)
-			DISP_Delete(hNodeMgr->hDisp);
+		if (hnode_mgr->disp_obj)
+			disp_delete(hnode_mgr->disp_obj);
 
-		if (hNodeMgr->hSync)
-			SYNC_DeleteCS(hNodeMgr->hSync);
+		if (hnode_mgr->sync_obj)
+			sync_delete_cs(hnode_mgr->sync_obj);
 
-		if (hNodeMgr->hStrmMgr)
-			STRM_Delete(hNodeMgr->hStrmMgr);
+		if (hnode_mgr->strm_mgr_obj)
+			strm_delete(hnode_mgr->strm_mgr_obj);
 
 		/* Delete the loader */
-		if (hNodeMgr->hNldr)
-			hNodeMgr->nldrFxns.pfnDelete(hNodeMgr->hNldr);
+		if (hnode_mgr->nldr_obj)
+			hnode_mgr->nldr_fxns.pfn_delete(hnode_mgr->nldr_obj);
 
-		if (hNodeMgr->fLoaderInit)
-			hNodeMgr->nldrFxns.pfnExit();
+		if (hnode_mgr->loader_init)
+			hnode_mgr->nldr_fxns.pfn_exit();
 
-		MEM_FreeObject(hNodeMgr);
+		MEM_FREE_OBJECT(hnode_mgr);
 	}
 }
 
 /*
- *  ======== FillStreamConnect ========
+ *  ======== fill_stream_connect ========
  *  Purpose:
  *      Fills stream information.
  */
-static void FillStreamConnect(struct NODE_OBJECT *hNode1,
-			     struct NODE_OBJECT *hNode2,
-			     u32 uStream1, u32 uStream2)
-{
-	u32 uStrmIndex;
-	struct DSP_STREAMCONNECT *pStrm1 = NULL;
-	struct DSP_STREAMCONNECT *pStrm2 = NULL;
-	enum NODE_TYPE node1Type = NODE_TASK;
-	enum NODE_TYPE node2Type = NODE_TASK;
-
-	node1Type = NODE_GetType(hNode1);
-	node2Type = NODE_GetType(hNode2);
-	if (hNode1 != (struct NODE_OBJECT *)DSP_HGPPNODE) {
-
-		if (node1Type != NODE_DEVICE) {
-			uStrmIndex = hNode1->uNumInputs +
-				     hNode1->uNumOutputs - 1;
-			pStrm1 = &(hNode1->streamConnect[uStrmIndex]);
-			pStrm1->cbStruct = sizeof(struct DSP_STREAMCONNECT);
-			pStrm1->uThisNodeStreamIndex = uStream1;
-		}
-
-		if (hNode2 != (struct NODE_OBJECT *)DSP_HGPPNODE) {
-				/* NODE == > NODE */
-			if (node1Type != NODE_DEVICE) {
-				pStrm1->hConnectedNode = hNode2;
-				pStrm1->uiConnectedNodeID = hNode2->nodeId;
-				pStrm1->uConnectedNodeStreamIndex = uStream2;
-				pStrm1->lType = CONNECTTYPE_NODEOUTPUT;
-			}
-			if (node2Type != NODE_DEVICE) {
-				uStrmIndex = hNode2->uNumInputs +
-						hNode2->uNumOutputs - 1;
-				pStrm2 = &(hNode2->streamConnect[uStrmIndex]);
-				pStrm2->cbStruct =
-					sizeof(struct DSP_STREAMCONNECT);
-				pStrm2->uThisNodeStreamIndex = uStream2;
-				pStrm2->hConnectedNode = hNode1;
-				pStrm2->uiConnectedNodeID = hNode1->nodeId;
-				pStrm2->uConnectedNodeStreamIndex = uStream1;
-				pStrm2->lType = CONNECTTYPE_NODEINPUT;
+static void fill_stream_connect(struct node_object *hNode1,
+				struct node_object *hNode2,
+				u32 uStream1, u32 uStream2)
+{
+	u32 strm_index;
+	struct dsp_streamconnect *strm1 = NULL;
+	struct dsp_streamconnect *strm2 = NULL;
+	enum node_type node1_type = NODE_TASK;
+	enum node_type node2_type = NODE_TASK;
+
+	node1_type = node_get_type(hNode1);
+	node2_type = node_get_type(hNode2);
+	if (hNode1 != (struct node_object *)DSP_HGPPNODE) {
+
+		if (node1_type != NODE_DEVICE) {
+			strm_index = hNode1->num_inputs +
+			    hNode1->num_outputs - 1;
+			strm1 = &(hNode1->stream_connect[strm_index]);
+			strm1->cb_struct = sizeof(struct dsp_streamconnect);
+			strm1->this_node_stream_index = uStream1;
+		}
+
+		if (hNode2 != (struct node_object *)DSP_HGPPNODE) {
+			/* NODE == > NODE */
+			if (node1_type != NODE_DEVICE) {
+				strm1->connected_node = hNode2;
+				strm1->ui_connected_node_id = hNode2->node_uuid;
+				strm1->connected_node_stream_index = uStream2;
+				strm1->connect_type = CONNECTTYPE_NODEOUTPUT;
+			}
+			if (node2_type != NODE_DEVICE) {
+				strm_index = hNode2->num_inputs +
+				    hNode2->num_outputs - 1;
+				strm2 = &(hNode2->stream_connect[strm_index]);
+				strm2->cb_struct =
+				    sizeof(struct dsp_streamconnect);
+				strm2->this_node_stream_index = uStream2;
+				strm2->connected_node = hNode1;
+				strm2->ui_connected_node_id = hNode1->node_uuid;
+				strm2->connected_node_stream_index = uStream1;
+				strm2->connect_type = CONNECTTYPE_NODEINPUT;
 			}
-		} else if (node1Type != NODE_DEVICE)
-				pStrm1->lType = CONNECTTYPE_GPPOUTPUT;
+		} else if (node1_type != NODE_DEVICE)
+			strm1->connect_type = CONNECTTYPE_GPPOUTPUT;
 	} else {
 		/* GPP == > NODE */
-		DBC_Assert(hNode2 != (struct NODE_OBJECT *)DSP_HGPPNODE);
-		uStrmIndex = hNode2->uNumInputs + hNode2->uNumOutputs - 1;
-		pStrm2 = &(hNode2->streamConnect[uStrmIndex]);
-		pStrm2->cbStruct = sizeof(struct DSP_STREAMCONNECT);
-		pStrm2->uThisNodeStreamIndex = uStream2;
-		pStrm2->lType = CONNECTTYPE_GPPINPUT;
+		DBC_ASSERT(hNode2 != (struct node_object *)DSP_HGPPNODE);
+		strm_index = hNode2->num_inputs + hNode2->num_outputs - 1;
+		strm2 = &(hNode2->stream_connect[strm_index]);
+		strm2->cb_struct = sizeof(struct dsp_streamconnect);
+		strm2->this_node_stream_index = uStream2;
+		strm2->connect_type = CONNECTTYPE_GPPINPUT;
 	}
 }
 
 /*
- *  ======== FillStreamDef ========
+ *  ======== fill_stream_def ========
  *  Purpose:
  *      Fills Stream attributes.
  */
-static void FillStreamDef(struct NODE_OBJECT *hNode,
-			  struct NODE_STRMDEF *pstrmDef,
-			  struct DSP_STRMATTR *pAttrs)
-{
-	struct NODE_MGR *hNodeMgr = hNode->hNodeMgr;
-
-	if (pAttrs != NULL) {
-		pstrmDef->uNumBufs = pAttrs->uNumBufs;
-		pstrmDef->uBufsize = pAttrs->uBufsize / hNodeMgr->
-							uDSPDataMauSize;
-		pstrmDef->uSegid = pAttrs->uSegid;
-		pstrmDef->uAlignment = pAttrs->uAlignment;
-		pstrmDef->uTimeout = pAttrs->uTimeout;
+static void fill_stream_def(struct node_object *hnode,
+			    struct node_strmdef *pstrm_def,
+			    struct dsp_strmattr *pattrs)
+{
+	struct node_mgr *hnode_mgr = hnode->hnode_mgr;
+
+	if (pattrs != NULL) {
+		pstrm_def->num_bufs = pattrs->num_bufs;
+		pstrm_def->buf_size =
+		    pattrs->buf_size / hnode_mgr->udsp_data_mau_size;
+		pstrm_def->seg_id = pattrs->seg_id;
+		pstrm_def->buf_alignment = pattrs->buf_alignment;
+		pstrm_def->utimeout = pattrs->utimeout;
 	} else {
-		pstrmDef->uNumBufs = DEFAULTNBUFS;
-		pstrmDef->uBufsize = DEFAULTBUFSIZE / hNodeMgr->
-						      uDSPDataMauSize;
-		pstrmDef->uSegid = DEFAULTSEGID;
-		pstrmDef->uAlignment = DEFAULTALIGNMENT;
-		pstrmDef->uTimeout = DEFAULTTIMEOUT;
+		pstrm_def->num_bufs = DEFAULTNBUFS;
+		pstrm_def->buf_size =
+		    DEFAULTBUFSIZE / hnode_mgr->udsp_data_mau_size;
+		pstrm_def->seg_id = DEFAULTSEGID;
+		pstrm_def->buf_alignment = DEFAULTALIGNMENT;
+		pstrm_def->utimeout = DEFAULTTIMEOUT;
 	}
 }
 
 /*
- *  ======== FreeStream ========
+ *  ======== free_stream ========
  *  Purpose:
  *      Updates the channel mask and frees the pipe id.
  */
-static void FreeStream(struct NODE_MGR *hNodeMgr, struct STREAM stream)
+static void free_stream(struct node_mgr *hnode_mgr, struct stream_chnl stream)
 {
 	/* Free up the pipe id unless other node has not yet been deleted. */
 	if (stream.type == NODECONNECT) {
-		if (GB_test(hNodeMgr->pipeDoneMap, stream.devId)) {
+		if (gb_test(hnode_mgr->pipe_done_map, stream.dev_id)) {
 			/* The other node has already been deleted */
-			GB_clear(hNodeMgr->pipeDoneMap, stream.devId);
-			GB_clear(hNodeMgr->pipeMap, stream.devId);
+			gb_clear(hnode_mgr->pipe_done_map, stream.dev_id);
+			gb_clear(hnode_mgr->pipe_map, stream.dev_id);
 		} else {
 			/* The other node has not been deleted yet */
-			GB_set(hNodeMgr->pipeDoneMap, stream.devId);
+			gb_set(hnode_mgr->pipe_done_map, stream.dev_id);
 		}
 	} else if (stream.type == HOSTCONNECT) {
-		if (stream.devId < hNodeMgr->ulNumChnls) {
-			GB_clear(hNodeMgr->chnlMap, stream.devId);
-		} else if (stream.devId < (2 * hNodeMgr->ulNumChnls)) {
+		if (stream.dev_id < hnode_mgr->ul_num_chnls) {
+			gb_clear(hnode_mgr->chnl_map, stream.dev_id);
+		} else if (stream.dev_id < (2 * hnode_mgr->ul_num_chnls)) {
 			/* dsp-dma */
-			GB_clear(hNodeMgr->dmaChnlMap, stream.devId -
-				(1 * hNodeMgr->ulNumChnls));
-		} else if (stream.devId < (3 * hNodeMgr->ulNumChnls)) {
+			gb_clear(hnode_mgr->dma_chnl_map, stream.dev_id -
+				 (1 * hnode_mgr->ul_num_chnls));
+		} else if (stream.dev_id < (3 * hnode_mgr->ul_num_chnls)) {
 			/* zero-copy */
-			GB_clear(hNodeMgr->zChnlMap, stream.devId -
-				(2 * hNodeMgr->ulNumChnls));
+			gb_clear(hnode_mgr->zc_chnl_map, stream.dev_id -
+				 (2 * hnode_mgr->ul_num_chnls));
 		}
 	}
 }
 
 /*
- *  ======== GetFxnAddress ========
+ *  ======== get_fxn_address ========
  *  Purpose:
  *      Retrieves the address for create, execute or delete phase for a node.
  */
-static DSP_STATUS GetFxnAddress(struct NODE_OBJECT *hNode, u32 *pulFxnAddr,
-				u32 uPhase)
+static dsp_status get_fxn_address(struct node_object *hnode, u32 * pulFxnAddr,
+				  u32 uPhase)
 {
-	char *pstrFxnName = NULL;
-	struct NODE_MGR *hNodeMgr = hNode->hNodeMgr;
-	DSP_STATUS status = DSP_SOK;
-	DBC_Require(NODE_GetType(hNode) == NODE_TASK ||
-			NODE_GetType(hNode) == NODE_DAISSOCKET ||
-			NODE_GetType(hNode) == NODE_MESSAGE);
+	char *pstr_fxn_name = NULL;
+	struct node_mgr *hnode_mgr = hnode->hnode_mgr;
+	dsp_status status = DSP_SOK;
+	DBC_REQUIRE(node_get_type(hnode) == NODE_TASK ||
+		    node_get_type(hnode) == NODE_DAISSOCKET ||
+		    node_get_type(hnode) == NODE_MESSAGE);
 
 	switch (uPhase) {
 	case CREATEPHASE:
-		pstrFxnName = hNode->dcdProps.objData.nodeObj.
-			      pstrCreatePhaseFxn;
+		pstr_fxn_name =
+		    hnode->dcd_props.obj_data.node_obj.pstr_create_phase_fxn;
 		break;
 	case EXECUTEPHASE:
-		pstrFxnName = hNode->dcdProps.objData.nodeObj.
-			      pstrExecutePhaseFxn;
+		pstr_fxn_name =
+		    hnode->dcd_props.obj_data.node_obj.pstr_execute_phase_fxn;
 		break;
 	case DELETEPHASE:
-		pstrFxnName = hNode->dcdProps.objData.nodeObj.
-			      pstrDeletePhaseFxn;
+		pstr_fxn_name =
+		    hnode->dcd_props.obj_data.node_obj.pstr_delete_phase_fxn;
 		break;
 	default:
 		/* Should never get here */
-		DBC_Assert(false);
+		DBC_ASSERT(false);
 		break;
 	}
 
-	status = hNodeMgr->nldrFxns.pfnGetFxnAddr(hNode->hNldrNode, pstrFxnName,
-						pulFxnAddr);
+	status =
+	    hnode_mgr->nldr_fxns.pfn_get_fxn_addr(hnode->nldr_node_obj,
+						  pstr_fxn_name, pulFxnAddr);
 
 	return status;
 }
 
 /*
- *  ======== GetNodeInfo ========
+ *  ======== get_node_info ========
  *  Purpose:
  *      Retrieves the node information.
  */
-void GetNodeInfo(struct NODE_OBJECT *hNode, struct DSP_NODEINFO *pNodeInfo)
+void get_node_info(struct node_object *hnode, struct dsp_nodeinfo *pNodeInfo)
 {
 	u32 i;
 
-	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
-	DBC_Require(pNodeInfo != NULL);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE));
+	DBC_REQUIRE(pNodeInfo != NULL);
 
-	pNodeInfo->cbStruct = sizeof(struct DSP_NODEINFO);
-	pNodeInfo->nbNodeDatabaseProps = hNode->dcdProps.objData.nodeObj.
-					 ndbProps;
-	pNodeInfo->uExecutionPriority = hNode->nPriority;
-	pNodeInfo->hDeviceOwner = hNode->hDeviceOwner;
-	pNodeInfo->uNumberStreams = hNode->uNumInputs + hNode->uNumOutputs;
-	pNodeInfo->uNodeEnv = hNode->nodeEnv;
+	pNodeInfo->cb_struct = sizeof(struct dsp_nodeinfo);
+	pNodeInfo->nb_node_database_props =
+	    hnode->dcd_props.obj_data.node_obj.ndb_props;
+	pNodeInfo->execution_priority = hnode->prio;
+	pNodeInfo->device_owner = hnode->device_owner;
+	pNodeInfo->number_streams = hnode->num_inputs + hnode->num_outputs;
+	pNodeInfo->node_env = hnode->node_env;
 
-	pNodeInfo->nsExecutionState = NODE_GetState(hNode);
+	pNodeInfo->ns_execution_state = node_get_state(hnode);
 
 	/* Copy stream connect data */
-	for (i = 0; i < hNode->uNumInputs + hNode->uNumOutputs; i++)
-		pNodeInfo->scStreamConnection[i] = hNode->streamConnect[i];
+	for (i = 0; i < hnode->num_inputs + hnode->num_outputs; i++)
+		pNodeInfo->sc_stream_connection[i] = hnode->stream_connect[i];
 
 }
 
 /*
- *  ======== GetNodeProps ========
+ *  ======== get_node_props ========
  *  Purpose:
  *      Retrieve node properties.
  */
-static DSP_STATUS GetNodeProps(struct DCD_MANAGER *hDcdMgr,
-			      struct NODE_OBJECT *hNode,
-			      CONST struct DSP_UUID *pNodeId,
-			      struct DCD_GENERICOBJ *pdcdProps)
-{
-	u32 uLen;
-	struct NODE_MSGARGS *pMsgArgs;
-	struct NODE_TASKARGS *pTaskArgs;
-	enum NODE_TYPE nodeType = NODE_TASK;
-	struct DSP_NDBPROPS *pndbProps = &(pdcdProps->objData.nodeObj.ndbProps);
-	DSP_STATUS status = DSP_SOK;
-#ifdef DEBUG
-	char szUuid[MAXUUIDLEN];
-#endif
+static dsp_status get_node_props(struct dcd_manager *hdcd_mgr,
+				 struct node_object *hnode,
+				 CONST struct dsp_uuid *pNodeId,
+				 struct dcd_genericobj *pdcdProps)
+{
+	u32 len;
+	struct node_msgargs *pmsg_args;
+	struct node_taskargs *task_arg_obj;
+	enum node_type node_type = NODE_TASK;
+	struct dsp_ndbprops *pndb_props =
+	    &(pdcdProps->obj_data.node_obj.ndb_props);
+	dsp_status status = DSP_SOK;
+	char sz_uuid[MAXUUIDLEN];
 
-	status = DCD_GetObjectDef(hDcdMgr, (struct DSP_UUID *)pNodeId,
-				 DSP_DCDNODETYPE, pdcdProps);
+	status = dcd_get_object_def(hdcd_mgr, (struct dsp_uuid *)pNodeId,
+				    DSP_DCDNODETYPE, pdcdProps);
 
 	if (DSP_SUCCEEDED(status)) {
-		hNode->nType = nodeType = pndbProps->uNodeType;
+		hnode->ntype = node_type = pndb_props->ntype;
 
-#ifdef DEBUG
 		/* Create UUID value to set in registry. */
-		UUID_UuidToString((struct DSP_UUID *)pNodeId, szUuid,
-				 MAXUUIDLEN);
-		DBG_Trace(DBG_LEVEL7, "\n** (node) UUID: %s\n", szUuid);
-#endif
+		uuid_uuid_to_string((struct dsp_uuid *)pNodeId, sz_uuid,
+				    MAXUUIDLEN);
+		dev_dbg(bridge, "(node) UUID: %s\n", sz_uuid);
 
 		/* Fill in message args that come from NDB */
-		if (nodeType != NODE_DEVICE) {
-			pMsgArgs = &(hNode->createArgs.asa.msgArgs);
-			pMsgArgs->uSegid = pdcdProps->objData.nodeObj.uMsgSegid;
-			pMsgArgs->uNotifyType = pdcdProps->objData.nodeObj.
-						uMsgNotifyType;
-			pMsgArgs->uMaxMessages = pndbProps->uMessageDepth;
-#ifdef DEBUG
-			DBG_Trace(DBG_LEVEL7,
-				 "** (node) Max Number of Messages: 0x%x\n",
-				 pMsgArgs->uMaxMessages);
-#endif
+		if (node_type != NODE_DEVICE) {
+			pmsg_args = &(hnode->create_args.asa.node_msg_args);
+			pmsg_args->seg_id =
+			    pdcdProps->obj_data.node_obj.msg_segid;
+			pmsg_args->notify_type =
+			    pdcdProps->obj_data.node_obj.msg_notify_type;
+			pmsg_args->max_msgs = pndb_props->message_depth;
+			dev_dbg(bridge, "(node) Max Number of Messages: 0x%x\n",
+				pmsg_args->max_msgs);
 		} else {
 			/* Copy device name */
-                       DBC_Require(pndbProps->acName);
-                       uLen = strlen(pndbProps->acName);
-			DBC_Assert(uLen < MAXDEVNAMELEN);
-			hNode->pstrDevName = MEM_Calloc(uLen + 1, MEM_PAGED);
-			if (hNode->pstrDevName == NULL) {
+			DBC_REQUIRE(pndb_props->ac_name);
+			len = strlen(pndb_props->ac_name);
+			DBC_ASSERT(len < MAXDEVNAMELEN);
+			hnode->pstr_dev_name = mem_calloc(len + 1, MEM_PAGED);
+			if (hnode->pstr_dev_name == NULL) {
 				status = DSP_EMEMORY;
 			} else {
-                               strncpy(hNode->pstrDevName,
-					   pndbProps->acName, uLen);
+				strncpy(hnode->pstr_dev_name,
+					pndb_props->ac_name, len);
 			}
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Fill in create args that come from NDB */
-		if (nodeType == NODE_TASK || nodeType == NODE_DAISSOCKET) {
-			pTaskArgs = &(hNode->createArgs.asa.taskArgs);
-			pTaskArgs->nPriority = pndbProps->iPriority;
-			pTaskArgs->uStackSize = pndbProps->uStackSize;
-			pTaskArgs->uSysStackSize = pndbProps->uSysStackSize;
-			pTaskArgs->uStackSeg = pndbProps->uStackSeg;
-#ifdef DEBUG
-			DBG_Trace(DBG_LEVEL7,
-				 "** (node) Priority: 0x%x\n" "** (node) Stack"
-				 " Size: 0x%x words\n" "** (node) System Stack"
-				 " Size: 0x%x words\n" "** (node) Stack"
-				 " Segment: 0x%x\n\n",
-				  "** (node) profile count : 0x%x \n \n",
-				  pTaskArgs->nPriority, pTaskArgs->uStackSize,
-				  pTaskArgs->uSysStackSize,
-				  pTaskArgs->uStackSeg,
-				  pndbProps->uCountProfiles);
-#endif
+		if (node_type == NODE_TASK || node_type == NODE_DAISSOCKET) {
+			task_arg_obj = &(hnode->create_args.asa.task_arg_obj);
+			task_arg_obj->prio = pndb_props->prio;
+			task_arg_obj->stack_size = pndb_props->stack_size;
+			task_arg_obj->sys_stack_size =
+			    pndb_props->sys_stack_size;
+			task_arg_obj->stack_seg = pndb_props->stack_seg;
+			dev_dbg(bridge, "(node) Priority: 0x%x Stack Size: "
+				"0x%x words System Stack Size: 0x%x words "
+				"Stack Segment: 0x%x profile count : 0x%x\n",
+				task_arg_obj->prio, task_arg_obj->stack_size,
+				task_arg_obj->sys_stack_size,
+				task_arg_obj->stack_seg,
+				pndb_props->count_profiles);
 		}
 	}
 
@@ -3258,91 +2999,81 @@
 }
 
 /*
- *  ======== GetProcProps ========
+ *  ======== get_proc_props ========
  *  Purpose:
  *      Retrieve the processor properties.
  */
-static DSP_STATUS GetProcProps(struct NODE_MGR *hNodeMgr,
-				struct DEV_OBJECT *hDevObject)
+static dsp_status get_proc_props(struct node_mgr *hnode_mgr,
+				 struct dev_object *hdev_obj)
 {
-	struct CFG_DEVNODE *hDevNode;
-	struct CFG_HOSTRES hostRes;
-	DSP_STATUS status = DSP_SOK;
+	struct cfg_devnode *dev_node_obj;
+	struct cfg_hostres host_res;
+	dsp_status status = DSP_SOK;
 
-	status = DEV_GetDevNode(hDevObject, &hDevNode);
+	status = dev_get_dev_node(hdev_obj, &dev_node_obj);
 	if (DSP_SUCCEEDED(status))
-		status = CFG_GetHostResources(hDevNode, &hostRes);
+		status = cfg_get_host_resources(dev_node_obj, &host_res);
 
 	if (DSP_SUCCEEDED(status)) {
-		hNodeMgr->ulChnlOffset = hostRes.dwChnlOffset;
-		hNodeMgr->ulChnlBufSize = hostRes.dwChnlBufSize;
-		hNodeMgr->ulNumChnls = hostRes.dwNumChnls;
+		hnode_mgr->ul_chnl_offset = host_res.dw_chnl_offset;
+		hnode_mgr->ul_chnl_buf_size = host_res.dw_chnl_buf_size;
+		hnode_mgr->ul_num_chnls = host_res.dw_num_chnls;
 
 		/*
-		 *  PROC will add an API to get DSP_PROCESSORINFO.
+		 *  PROC will add an API to get dsp_processorinfo.
 		 *  Fill in default values for now.
 		 */
 		/* TODO -- Instead of hard coding, take from registry */
-		hNodeMgr->procFamily = 6000;
-		hNodeMgr->procType = 6410;
-		hNodeMgr->nMinPri = DSP_NODE_MIN_PRIORITY;
-		hNodeMgr->nMaxPri = DSP_NODE_MAX_PRIORITY;
-		hNodeMgr->uDSPWordSize = DSPWORDSIZE;
-		hNodeMgr->uDSPDataMauSize = DSPWORDSIZE;
-		hNodeMgr->uDSPMauSize = 1;
+		hnode_mgr->proc_family = 6000;
+		hnode_mgr->proc_type = 6410;
+		hnode_mgr->min_pri = DSP_NODE_MIN_PRIORITY;
+		hnode_mgr->max_pri = DSP_NODE_MAX_PRIORITY;
+		hnode_mgr->udsp_word_size = DSPWORDSIZE;
+		hnode_mgr->udsp_data_mau_size = DSPWORDSIZE;
+		hnode_mgr->udsp_mau_size = 1;
 
 	}
 	return status;
 }
 
-
-
 /*
- *  ======== NODE_GetUUIDProps ========
+ *  ======== node_get_uuid_props ========
  *  Purpose:
  *      Fetch Node UUID properties from DCD/DOF file.
  */
-DSP_STATUS NODE_GetUUIDProps(DSP_HPROCESSOR hProcessor,
-			    IN CONST struct DSP_UUID *pNodeId,
-			    OUT struct DSP_NDBPROPS *pNodeProps)
-{
-	struct NODE_MGR *hNodeMgr = NULL;
-	struct DEV_OBJECT *hDevObject;
-	DSP_STATUS status = DSP_SOK;
-	struct DCD_NODEPROPS   dcdNodeProps;
-	struct DSP_PROCESSORSTATE procStatus;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(hProcessor != NULL);
-	DBC_Require(pNodeId != NULL);
+dsp_status node_get_uuid_props(void *hprocessor,
+			       IN CONST struct dsp_uuid *pNodeId,
+			       OUT struct dsp_ndbprops *node_props)
+{
+	struct node_mgr *hnode_mgr = NULL;
+	struct dev_object *hdev_obj;
+	dsp_status status = DSP_SOK;
+	struct dcd_nodeprops dcd_node_props;
+	struct dsp_processorstate proc_state;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(hprocessor != NULL);
+	DBC_REQUIRE(pNodeId != NULL);
 
-	if (hProcessor == NULL || pNodeId == NULL) {
+	if (hprocessor == NULL || pNodeId == NULL) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	status = PROC_GetState(hProcessor, &procStatus,
-			sizeof(struct DSP_PROCESSORSTATE));
+	status = proc_get_state(hprocessor, &proc_state,
+				sizeof(struct dsp_processorstate));
 	if (DSP_FAILED(status))
 		goto func_end;
 	/* If processor is in error state then don't attempt
-	    to send the message */
-	if (procStatus.iState == PROC_ERROR) {
-		GT_1trace(NODE_debugMask, GT_5CLASS,
-			"NODE_GetUUIDProps: proc Status 0x%x\n",
-			procStatus.iState);
+	   to send the message */
+	if (proc_state.proc_state == PROC_ERROR) {
 		status = DSP_EFAIL;
 		goto func_end;
 	}
 
-	GT_3trace(NODE_debugMask, GT_ENTER,
-		 "NODE_GetUUIDProps: " "\thProcessor: "
-		 "0x%x\tpNodeId: 0x%x" "\tpNodeProps: 0x%x\n", hProcessor,
-		 pNodeId, pNodeProps);
-
-	status = PROC_GetDevObject(hProcessor, &hDevObject);
-	if (DSP_SUCCEEDED(status) && hDevObject != NULL) {
-		status = DEV_GetNodeManager(hDevObject, &hNodeMgr);
-		if (hNodeMgr == NULL) {
+	status = proc_get_dev_object(hprocessor, &hdev_obj);
+	if (hdev_obj) {
+		status = dev_get_node_manager(hdev_obj, &hnode_mgr);
+		if (hnode_mgr == NULL) {
 			status = DSP_EHANDLE;
 			goto func_end;
 		}
@@ -3350,83 +3081,78 @@
 
 	/*
 	 * Enter the critical section. This is needed because
-	 * DCD_GetObjectDef will ultimately end up calling DBLL_open/close,
+	 * dcd_get_object_def will ultimately end up calling dbll_open/close,
 	 * which needs to be protected in order to not corrupt the zlib manager
 	 * (COD).
 	 */
-	status = SYNC_EnterCS(hNodeMgr->hSync);
+	status = sync_enter_cs(hnode_mgr->sync_obj);
 
 	if (DSP_SUCCEEDED(status)) {
-		dcdNodeProps.pstrCreatePhaseFxn = NULL;
-		dcdNodeProps.pstrExecutePhaseFxn = NULL;
-		dcdNodeProps.pstrDeletePhaseFxn = NULL;
-		dcdNodeProps.pstrIAlgName = NULL;
-
-		status = DCD_GetObjectDef(hNodeMgr->hDcdMgr,
-				(struct DSP_UUID *) pNodeId,
-				DSP_DCDNODETYPE,
-				(struct DCD_GENERICOBJ *) &dcdNodeProps);
+		dcd_node_props.pstr_create_phase_fxn = NULL;
+		dcd_node_props.pstr_execute_phase_fxn = NULL;
+		dcd_node_props.pstr_delete_phase_fxn = NULL;
+		dcd_node_props.pstr_i_alg_name = NULL;
+
+		status = dcd_get_object_def(hnode_mgr->hdcd_mgr,
+					    (struct dsp_uuid *)pNodeId,
+					    DSP_DCDNODETYPE,
+					    (struct dcd_genericobj *)
+					    &dcd_node_props);
 		if (DSP_SUCCEEDED(status)) {
-			*pNodeProps = dcdNodeProps.ndbProps;
-			if (dcdNodeProps.pstrCreatePhaseFxn)
-				MEM_Free(dcdNodeProps.pstrCreatePhaseFxn);
+			*node_props = dcd_node_props.ndb_props;
+			kfree(dcd_node_props.pstr_create_phase_fxn);
 
-			if (dcdNodeProps.pstrExecutePhaseFxn)
-				MEM_Free(dcdNodeProps.pstrExecutePhaseFxn);
+			kfree(dcd_node_props.pstr_execute_phase_fxn);
 
-			if (dcdNodeProps.pstrDeletePhaseFxn)
-				MEM_Free(dcdNodeProps.pstrDeletePhaseFxn);
+			kfree(dcd_node_props.pstr_delete_phase_fxn);
 
-			if (dcdNodeProps.pstrIAlgName)
-				MEM_Free(dcdNodeProps.pstrIAlgName);
+			kfree(dcd_node_props.pstr_i_alg_name);
 		}
-		/*  Leave the critical section, we're done.  */
-		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+		/*  Leave the critical section, we're done. */
+		(void)sync_leave_cs(hnode_mgr->sync_obj);
 	}
 func_end:
 	return status;
 }
 
 /*
- *  ======== GetRMSFxns ========
+ *  ======== get_rms_fxns ========
  *  Purpose:
  *      Retrieve the RMS functions.
  */
-static DSP_STATUS GetRMSFxns(struct NODE_MGR *hNodeMgr)
+static dsp_status get_rms_fxns(struct node_mgr *hnode_mgr)
 {
 	s32 i;
-	struct DEV_OBJECT *hDev = hNodeMgr->hDevObject;
-	DSP_STATUS status = DSP_SOK;
+	struct dev_object *dev_obj = hnode_mgr->hdev_obj;
+	dsp_status status = DSP_SOK;
 
-	static char *pszFxns[NUMRMSFXNS] = {
-		"RMS_queryServer", 	/* RMSQUERYSERVER */
-		"RMS_configureServer", 	/* RMSCONFIGURESERVER */
-		"RMS_createNode", 	/* RMSCREATENODE */
-		"RMS_executeNode", 	/* RMSEXECUTENODE */
-		"RMS_deleteNode", 	/* RMSDELETENODE */
-		"RMS_changeNodePriority", 	/* RMSCHANGENODEPRIORITY */
-		"RMS_readMemory", 	/* RMSREADMEMORY */
-		"RMS_writeMemory", 	/* RMSWRITEMEMORY */
-		"RMS_copy", 	/* RMSCOPY */
+	static char *psz_fxns[NUMRMSFXNS] = {
+		"RMS_queryServer",	/* RMSQUERYSERVER */
+		"RMS_configureServer",	/* RMSCONFIGURESERVER */
+		"RMS_createNode",	/* RMSCREATENODE */
+		"RMS_executeNode",	/* RMSEXECUTENODE */
+		"RMS_deleteNode",	/* RMSDELETENODE */
+		"RMS_changeNodePriority",	/* RMSCHANGENODEPRIORITY */
+		"RMS_readMemory",	/* RMSREADMEMORY */
+		"RMS_writeMemory",	/* RMSWRITEMEMORY */
+		"RMS_copy",	/* RMSCOPY */
 	};
 
 	for (i = 0; i < NUMRMSFXNS; i++) {
-		status = DEV_GetSymbol(hDev, pszFxns[i],
-			 &(hNodeMgr->ulFxnAddrs[i]));
+		status = dev_get_symbol(dev_obj, psz_fxns[i],
+					&(hnode_mgr->ul_fxn_addrs[i]));
 		if (DSP_FAILED(status)) {
 			if (status == COD_E_SYMBOLNOTFOUND) {
 				/*
 				 *  May be loaded dynamically (in the future),
 				 *  but return an error for now.
 				 */
-				GT_1trace(NODE_debugMask, GT_6CLASS,
-					 "RMS function: %s "
-					 "currently not loaded\n", pszFxns[i]);
+				dev_dbg(bridge, "%s: RMS function: %s currently"
+					" not loaded\n", __func__, psz_fxns[i]);
 			} else {
-				GT_2trace(NODE_debugMask, GT_6CLASS,
-					 "GetRMSFxns: Symbol not "
-					 "found: %s\tstatus = 0x%x\n",
-					 pszFxns[i], status);
+				dev_dbg(bridge, "%s: Symbol not found: %s "
+					"status = 0x%x\n", __func__,
+					psz_fxns[i], status);
 				break;
 			}
 		}
@@ -3436,69 +3162,77 @@
 }
 
 /*
- *  ======== Ovly ========
+ *  ======== ovly ========
  *  Purpose:
  *      Called during overlay.Sends command to RMS to copy a block of data.
  */
-static u32 Ovly(void *pPrivRef, u32 ulDspRunAddr, u32 ulDspLoadAddr,
-			u32 ulNumBytes, u32 nMemSpace)
+static u32 ovly(void *priv_ref, u32 ulDspRunAddr, u32 ulDspLoadAddr,
+		u32 ul_num_bytes, u32 nMemSpace)
 {
-	struct NODE_OBJECT *hNode = (struct NODE_OBJECT *)pPrivRef;
-	struct NODE_MGR *hNodeMgr;
-	u32 ulBytes = 0;
-	u32 ulSize;
-	u32 ulTimeout;
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *hWmdContext;
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
+	struct node_object *hnode = (struct node_object *)priv_ref;
+	struct node_mgr *hnode_mgr;
+	u32 ul_bytes = 0;
+	u32 ul_size;
+	u32 ul_timeout;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *hwmd_context;
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD */
 
-	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE));
 
-	hNodeMgr = hNode->hNodeMgr;
+	hnode_mgr = hnode->hnode_mgr;
 
-	ulSize = ulNumBytes / hNodeMgr->uDSPWordSize;
-	ulTimeout = hNode->uTimeout;
+	ul_size = ul_num_bytes / hnode_mgr->udsp_word_size;
+	ul_timeout = hnode->utimeout;
 
 	/* Call new MemCopy function */
-	pIntfFxns = hNodeMgr->pIntfFxns;
-	status = DEV_GetWMDContext(hNodeMgr->hDevObject, &hWmdContext);
-	status = (*pIntfFxns->pfnBrdMemCopy)(hWmdContext, ulDspRunAddr,
-		 ulDspLoadAddr,	ulNumBytes, (u32) nMemSpace);
-
-	if (DSP_SUCCEEDED(status))
-		ulBytes = ulNumBytes;
+	intf_fxns = hnode_mgr->intf_fxns;
+	status = dev_get_wmd_context(hnode_mgr->hdev_obj, &hwmd_context);
+	if (DSP_SUCCEEDED(status)) {
+		status =
+		    (*intf_fxns->pfn_brd_mem_copy) (hwmd_context, ulDspRunAddr,
+						    ulDspLoadAddr, ul_num_bytes,
+						    (u32) nMemSpace);
+		if (DSP_SUCCEEDED(status))
+			ul_bytes = ul_num_bytes;
+		else
+			pr_debug("%s: failed to copy brd memory, status 0x%x\n",
+				 __func__, status);
+	} else {
+		pr_debug("%s: failed to get WMD context, status 0x%x\n",
+			 __func__, status);
+	}
 
-	return ulBytes;
+	return ul_bytes;
 }
 
 /*
- *  ======== Write ========
+ *  ======== mem_write ========
  */
-static u32 Write(void *pPrivRef, u32 ulDspAddr, void *pBuf,
-			u32 ulNumBytes, u32 nMemSpace)
+static u32 mem_write(void *priv_ref, u32 ulDspAddr, void *pbuf,
+		     u32 ul_num_bytes, u32 nMemSpace)
 {
-	struct NODE_OBJECT *hNode = (struct NODE_OBJECT *) pPrivRef;
-	struct NODE_MGR *hNodeMgr;
-	u16 memType;
-	u32 ulTimeout;
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *hWmdContext;
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
+	struct node_object *hnode = (struct node_object *)priv_ref;
+	struct node_mgr *hnode_mgr;
+	u16 mem_sect_type;
+	u32 ul_timeout;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *hwmd_context;
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD */
 
-	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
-	DBC_Require(nMemSpace & DBLL_CODE || nMemSpace & DBLL_DATA);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE));
+	DBC_REQUIRE(nMemSpace & DBLL_CODE || nMemSpace & DBLL_DATA);
 
-	hNodeMgr = hNode->hNodeMgr;
+	hnode_mgr = hnode->hnode_mgr;
 
-	ulTimeout = hNode->uTimeout;
-	memType = (nMemSpace & DBLL_CODE) ? RMS_CODE : RMS_DATA;
+	ul_timeout = hnode->utimeout;
+	mem_sect_type = (nMemSpace & DBLL_CODE) ? RMS_CODE : RMS_DATA;
 
 	/* Call new MemWrite function */
-	pIntfFxns = hNodeMgr->pIntfFxns;
-	status = DEV_GetWMDContext(hNodeMgr->hDevObject, &hWmdContext);
-	status = (*pIntfFxns->pfnBrdMemWrite) (hWmdContext, pBuf, ulDspAddr,
-		 ulNumBytes, memType);
+	intf_fxns = hnode_mgr->intf_fxns;
+	status = dev_get_wmd_context(hnode_mgr->hdev_obj, &hwmd_context);
+	status = (*intf_fxns->pfn_brd_mem_write) (hwmd_context, pbuf, ulDspAddr,
+						  ul_num_bytes, mem_sect_type);
 
-	return ulNumBytes;
+	return ul_num_bytes;
 }
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/policy.c kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/policy.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/policy.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/rmgr/policy.c	2011-10-23 08:22:37.664743000 +0100
@@ -0,0 +1,695 @@
+/*
+ * policy.c - policy enforcement point for TI DSP bridge access
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2010-2011 Nokia Corporation
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/device.h>
+#include <linux/timer.h>
+#include <linux/sysfs.h>
+
+#include <dspbridge/drv.h>
+
+#include <policy.h>
+
+/* TI DSP ioctl interface specific defines, here we need two of them */
+#define is_wait_for_events(code)      ((code & 0xff) == 0x04)
+#define is_node_get_message(code)     ((code & 0xff) == 0x48)
+
+struct policy_t {
+	struct class       *bridge_class;
+
+	pid_t               tgid;
+	pid_t               guest;
+	unsigned int        enabled;
+	unsigned int        guest_mode;
+	int                 preempt;
+
+	struct list_head    tasks;
+	struct list_head    pending_tasks;
+
+	struct timer_list   timer;
+	int                 pending_count;
+	/* mutex to access the list */
+	struct mutex        lock;
+};
+
+struct dsp_handler_t {
+	pid_t               tgid;
+	struct pid         *pid;
+
+	struct list_head    task_entry;
+	struct list_head    pending_entry;
+
+	int                 pending_count;
+
+	struct completion   pending_comp;
+};
+
+static struct policy_t policy;
+
+static inline bool is_handler_guest(struct dsp_handler_t *handler)
+{
+	return (policy.guest == handler->tgid || !policy.guest);
+}
+
+static inline bool is_guest(void)
+{
+	return (policy.guest == current->tgid || !policy.guest);
+}
+
+static inline bool is_handler_guest_restricted(struct dsp_handler_t *handler)
+{
+	return !policy.guest_mode || policy.tgid || !is_handler_guest(handler);
+}
+
+static inline bool is_guest_restricted(void)
+{
+	return !policy.guest_mode || policy.tgid || !is_guest();
+}
+
+static inline bool is_handler_restricted(struct dsp_handler_t *handler)
+{
+	return (policy.enabled && policy.tgid != handler->tgid &&
+		is_handler_guest_restricted(handler));
+}
+
+static inline bool is_restricted(void)
+{
+	return (policy.enabled && policy.tgid != current->tgid &&
+		is_guest_restricted());
+}
+
+static inline unsigned int count_pendings(pid_t tgid)
+{
+	unsigned int count = 0;
+	struct dsp_handler_t *handler;
+
+	list_for_each_entry(handler, &policy.tasks, task_entry)
+		if (tgid != handler->tgid &&
+		    !(tgid == policy.guest && policy.guest_mode))
+			count++;
+
+	return count;
+}
+
+static inline void unblock_pendings(void)
+{
+	struct dsp_handler_t *handler;
+
+	list_for_each_entry(handler, &policy.pending_tasks, pending_entry)
+		complete(&handler->pending_comp);
+}
+
+static void set_new_guest(void)
+{
+	struct dsp_handler_t *handler;
+
+	if (list_empty(&policy.tasks))
+		policy.guest = 0;
+	else {
+		handler = list_first_entry(&policy.tasks,
+					   struct dsp_handler_t, task_entry);
+		policy.guest = handler->tgid;
+	}
+}
+
+static int policy_preempt(pid_t tgid, int sig)
+{
+	struct dsp_handler_t *handler;
+
+	/* Send a signal to all policy restricted tasks */
+	list_for_each_entry(handler, &policy.tasks, task_entry)
+		if (tgid != handler->tgid) {
+			pr_info("%s: send %d signal to %d\n",
+				__func__, sig, handler->tgid);
+			kill_pid(handler->pid, sig, 0);
+		}
+
+	return 0;
+}
+
+static void policy_timer_preempt(unsigned long data)
+{
+	pid_t tgid = (pid_t)data;
+
+	mutex_lock(&policy.lock);
+	policy_preempt(tgid, SIGKILL);
+	mutex_unlock(&policy.lock);
+}
+
+static void policy_enable_preempt(pid_t tgid)
+{
+	if (policy.preempt > 0) {
+		/*
+		 * SIGURG signal can be handled by an application,
+		 * but it's not a destructive one
+		 */
+		policy_preempt(tgid, SIGURG);
+
+		policy.timer.data = tgid;
+		mod_timer(&policy.timer, jiffies + HZ * policy.preempt);
+	} else if (!policy.preempt) {
+		policy_preempt(tgid, SIGKILL);
+	}
+}
+
+static int wait_for_releasing(struct dsp_handler_t *handler)
+{
+	int status;
+
+	status = wait_for_completion_interruptible(&handler->pending_comp);
+
+	mutex_lock(&policy.lock);
+	list_del(&handler->pending_entry);
+	if (status)
+		status = -EINTR;
+
+	/* policy rules might have been changed while we're blocked */
+	if (is_restricted()) {
+		if (!status)
+			status = -EBUSY;
+		policy.pending_count--;
+		BUG_ON(policy.pending_count < 0);
+	}
+
+	if (status) {
+		list_del(&handler->task_entry);
+		if (is_guest())
+			set_new_guest();
+		kfree(handler);
+	}
+	mutex_unlock(&policy.lock);
+
+	return status;
+}
+
+static inline struct dsp_handler_t *handler_by_tgid(pid_t tgid)
+{
+	struct dsp_handler_t *handler;
+
+	list_for_each_entry(handler, &policy.tasks, task_entry)
+		if (tgid == handler->tgid)
+			return handler;
+
+	return NULL;
+}
+
+static inline struct dsp_handler_t *handler_by_pid(struct pid *pid)
+{
+	struct dsp_handler_t *handler;
+
+	list_for_each_entry(handler, &policy.tasks, task_entry)
+		if (pid == handler->pid)
+			return handler;
+
+	return NULL;
+}
+
+static void policy_enable(pid_t tgid)
+{
+	policy.enabled        = 1;
+	policy.tgid           = tgid;
+	policy.pending_count  = count_pendings(tgid);
+
+	/* blocked on open tasks are still in pendings list, remove them */
+	unblock_pendings();
+
+	/* preempt the current users of DSP if any */
+	policy_enable_preempt(tgid);
+
+	pr_debug("DSP policy enabled for %d process group, %d pendings\n",
+		 tgid, policy.pending_count);
+}
+
+static void policy_disable(void)
+{
+	/* do not preempt all current users of DSP */
+	policy.enabled        = 0;
+	policy.pending_count  = 0;
+
+	/* blocked on open tasks are still in pending list, remove them */
+	unblock_pendings();
+
+	del_timer_sync(&policy.timer);
+}
+
+static void policy_state_pid_update(int tgid)
+{
+	if (tgid != policy.tgid) {
+		policy.tgid = tgid;
+		if (policy.enabled)
+			policy_enable(tgid);
+	}
+}
+
+static void policy_state_enabled_update(int enabled)
+{
+	if (enabled > 0 && !policy.enabled)
+		policy_enable(policy.tgid);
+	else if (!enabled && policy.enabled)
+		policy_disable();
+}
+
+static void policy_state_guest_update(int guest_mode)
+{
+	if (guest_mode != policy.guest_mode) {
+		policy.guest_mode = guest_mode;
+		if (!guest_mode && policy.enabled && !policy.tgid)
+			policy_enable(0);
+	}
+}
+
+static ssize_t policy_show(struct class *class, char *buf)
+{
+	ssize_t len = 0;
+
+	if (mutex_lock_interruptible(&policy.lock))
+		return -EINTR;
+
+	len += snprintf(&buf[len], PAGE_SIZE, "%d\n", policy.tgid);
+
+	mutex_unlock(&policy.lock);
+
+	return len;
+}
+
+static ssize_t policy_store(struct class *class, const char *buf, size_t count)
+{
+	long tgid;
+	int  status;
+
+	if (mutex_lock_interruptible(&policy.lock))
+		return -EINTR;
+
+	status = strict_strtol(buf, 0, &tgid);
+	if (status < 0)
+		goto done;
+
+	if (tgid < 0 || tgid > PID_MAX_DEFAULT) {
+		status = -EINVAL;
+		goto done;
+	}
+
+	policy_state_pid_update(tgid);
+
+ done:
+	mutex_unlock(&policy.lock);
+
+	return status ? : count;
+}
+
+static ssize_t enabled_show(struct class *class, char *buf)
+{
+	ssize_t len = 0;
+
+	if (mutex_lock_interruptible(&policy.lock))
+		return -EINTR;
+
+	len += snprintf(&buf[len], PAGE_SIZE, "%u\n", policy.enabled);
+
+	mutex_unlock(&policy.lock);
+
+	return len;
+}
+
+static ssize_t enabled_store(struct class *class, const char *buf, size_t count)
+{
+	long enabled;
+	int  status;
+
+	if (mutex_lock_interruptible(&policy.lock))
+		return -EINTR;
+
+	status = strict_strtol(buf, 0, &enabled);
+	if (status < 0)
+		goto done;
+
+	if (enabled < 0) {
+		status = -EINVAL;
+		goto done;
+	}
+
+	policy_state_enabled_update(!!enabled);
+
+ done:
+	mutex_unlock(&policy.lock);
+
+	return status ? : count;
+}
+
+static ssize_t guest_mode_show(struct class *class, char *buf)
+{
+	ssize_t len = 0;
+
+	if (mutex_lock_interruptible(&policy.lock))
+		return -EINTR;
+
+	len += snprintf(&buf[len], PAGE_SIZE, "%u\n", policy.guest_mode);
+
+	mutex_unlock(&policy.lock);
+
+	return len;
+}
+
+static ssize_t guest_mode_store(struct class *class,
+			       const char *buf, size_t count)
+{
+	long guest_mode;
+	int  status;
+
+	if (mutex_lock_interruptible(&policy.lock))
+		return -EINTR;
+
+	status = strict_strtol(buf, 0, &guest_mode);
+	if (status < 0)
+		goto done;
+
+	if (guest_mode < 0) {
+		status = -EINVAL;
+		goto done;
+	}
+
+	policy_state_guest_update(!!guest_mode);
+
+ done:
+	mutex_unlock(&policy.lock);
+
+	return status ? : count;
+}
+
+static ssize_t preempt_show(struct class *class, char *buf)
+{
+	ssize_t len = 0;
+
+	if (mutex_lock_interruptible(&policy.lock))
+		return -EINTR;
+
+	len += snprintf(&buf[len], PAGE_SIZE, "%d\n", policy.preempt);
+
+	mutex_unlock(&policy.lock);
+
+	return len;
+}
+
+static ssize_t preempt_store(struct class *class, const char *buf, size_t count)
+{
+	long preempt;
+	int  status;
+
+	if (mutex_lock_interruptible(&policy.lock))
+		return -EINTR;
+
+	status = strict_strtol(buf, 0, &preempt);
+	if (status < 0)
+		goto done;
+
+	if (preempt < 0)
+		preempt = -1;
+
+	if (preempt > 60)
+		preempt = 60;
+
+	if (policy.preempt != preempt) {
+		policy.preempt = preempt;
+		if (policy.enabled)
+			policy_enable_preempt(policy.tgid);
+	}
+
+ done:
+	mutex_unlock(&policy.lock);
+
+	return status ? : count;
+}
+
+static struct class_attribute policy_attrs[] = {
+	__ATTR(policy,     S_IRUSR|S_IWUSR, policy_show,     policy_store),
+	__ATTR(enabled,    S_IRUSR|S_IWUSR, enabled_show,    enabled_store),
+	__ATTR(guest_mode, S_IRUSR|S_IWUSR, guest_mode_show, guest_mode_store),
+	__ATTR(preempt,    S_IRUSR|S_IWUSR, preempt_show,    preempt_store),
+};
+
+int policy_init(struct class *class)
+{
+	int i;
+	int status;
+
+	policy.bridge_class   = class;
+
+	policy.tgid           = 0;
+	policy.guest          = 0;
+	policy.enabled        = 0;
+	policy.guest_mode     = 0;
+	policy.preempt        = -1;
+	policy.pending_count  = 0;
+
+	INIT_LIST_HEAD(&policy.tasks);
+	INIT_LIST_HEAD(&policy.pending_tasks);
+
+	mutex_init(&policy.lock);
+
+	init_timer(&policy.timer);
+	policy.timer.data = 0;
+	policy.timer.function = policy_timer_preempt;
+
+	for (i = 0; i < ARRAY_SIZE(policy_attrs); i++) {
+		status = class_create_file(class, &policy_attrs[i]);
+		if (status != 0)
+			goto err_policy;
+	}
+
+	if (policy.enabled)
+		policy_enable(policy.tgid);
+
+	return status;
+
+ err_policy:
+	while (--i >= 0)
+		class_remove_file(policy.bridge_class, &policy_attrs[i]);
+
+	policy.bridge_class = NULL;
+	pr_err("dspbridge: policy for DSP is not initialized\n");
+
+	return status;
+}
+
+void policy_remove(void)
+{
+	int i;
+
+	if (!policy.bridge_class)
+		return;
+
+	for (i = 0; i < ARRAY_SIZE(policy_attrs); i++)
+		class_remove_file(policy.bridge_class, &policy_attrs[i]);
+
+	del_timer_sync(&policy.timer);
+
+	mutex_destroy(&policy.lock);
+
+	policy.bridge_class = NULL;
+	policy.tgid = 0;
+}
+
+
+/* Policy enforcement operations */
+int policy_open_hook(struct inode *ip, struct file *filp)
+{
+	int status = 0;
+	struct dsp_handler_t   *handler;
+	struct process_context *context = filp->private_data;
+
+	if (!context)
+		return -EIO;
+
+	if (mutex_lock_interruptible(&policy.lock))
+		return -EINTR;
+
+	if (is_restricted()) {
+		status = -EBUSY;
+		goto no_blocking;
+	}
+
+	handler = handler_by_tgid(current->tgid);
+	if (handler) {
+		context->policy = handler;
+		handler->pending_count++;
+		pr_debug("%s: handler for %d is incremented\n",
+			 __func__, current->tgid);
+		goto no_blocking;
+	}
+
+	if (policy.pending_count && (filp->f_flags & O_NONBLOCK)) {
+		status = -EAGAIN;
+		goto no_blocking;
+	}
+
+	handler = kzalloc(sizeof(struct dsp_handler_t), GFP_KERNEL);
+	if (!handler) {
+		status = -ENOMEM;
+		goto no_blocking;
+	}
+
+	context->policy = handler;
+
+	handler->tgid = current->tgid;
+	handler->pid  = get_pid(task_tgid(current));
+	handler->pending_count  = 1;
+
+	INIT_LIST_HEAD(&handler->task_entry);
+	INIT_LIST_HEAD(&handler->pending_entry);
+	init_completion(&handler->pending_comp);
+
+	list_add(&handler->task_entry, &policy.tasks);
+	pr_debug("%s: handler for %d is added\n", __func__, handler->tgid);
+
+	/*
+	 * Any process could become a guest,
+	 * that's a matter of future applied policy restrictions
+	 */
+	if (!policy.guest)
+		policy.guest = current->tgid;
+
+	/*
+	 * If policy is enabled, there might be tasks in the process of
+	 * releasing the resource, we need to wait for them.
+	 */
+	if (policy.pending_count) {
+		pr_debug("%s: %d pending tasks\n",
+			 __func__, policy.pending_count);
+		list_add(&handler->pending_entry, &policy.pending_tasks);
+		mutex_unlock(&policy.lock);
+		status = wait_for_releasing(handler);
+		return status;
+	}
+
+ no_blocking:
+	mutex_unlock(&policy.lock);
+
+	return status;
+}
+
+int policy_ioctl_pre_hook(struct file *filp, unsigned int code,
+			  unsigned long args)
+{
+	int status = 0;
+
+	mutex_lock(&policy.lock);
+
+	if (is_restricted()) {
+		if (is_wait_for_events(code)) {
+			/*
+			 * It is wanted to filter out wait_for_bridge_events to
+			 * decrease a preemption timeout before the clean up
+			 * procedure
+			 */
+			pr_debug("%s: ioctl restricted wait_for_events by %d\n",
+				 __func__, current->tgid);
+			status = -EBUSY;
+		} else if (is_node_get_message(code)) {
+			/*
+			 * Need to filter out get_message, due to a loop in
+			 * user space, which blocks a call of wait_for_events
+			 */
+			pr_debug("%s: ioctl restricted get_message by %d\n",
+				 __func__, current->tgid);
+			status = -EBUSY;
+		}
+
+		/*
+		 * Bypass all other ioctl commands from restricted processes,
+		 * they're needed for proper resource deinitialization
+		 */
+		goto exit;
+	}
+
+	if (is_wait_for_events(code))
+		pr_debug("%s: enter wait_for_events by %d\n",
+			 __func__, current->tgid);
+
+ exit:
+	mutex_unlock(&policy.lock);
+
+	return status;
+}
+
+int policy_ioctl_post_hook(struct file *filp, unsigned int code,
+			   unsigned long args, int status)
+{
+	if (is_wait_for_events(code))
+		pr_debug("%s: exit wait_for_events by %d\n",
+			 __func__, current->tgid);
+
+	return status;
+}
+
+int policy_mmap_hook(struct file *filp)
+{
+	int status = 0;
+
+	mutex_lock(&policy.lock);
+	if (is_restricted())
+		status = -EACCES;
+	mutex_unlock(&policy.lock);
+
+	return status;
+}
+
+int policy_release_hook(struct inode *ip, struct file *filp)
+{
+	struct process_context *context = filp->private_data;
+	struct dsp_handler_t   *handler;
+
+	if (!context || !context->policy)
+		return -EIO;
+
+	handler = context->policy;
+
+	mutex_lock(&policy.lock);
+
+	handler->pending_count--;
+	if (handler->pending_count) {
+		mutex_unlock(&policy.lock);
+		pr_debug("%s: handler for %d is decremented\n",
+			 __func__, current->tgid);
+		return 0;
+	}
+
+	put_pid(handler->pid);
+
+	list_del(&handler->task_entry);
+
+	if (is_handler_guest(handler))
+		set_new_guest();
+
+	/*
+	 * If the last policy prohibited task released the node,
+	 * we can unblock all policy allowed tasks opening it in their turn
+	 */
+	if (is_handler_restricted(handler)) {
+		policy.pending_count--;
+		pr_debug("%s: %d pending tasks\n",
+			 __func__, policy.pending_count);
+		BUG_ON(policy.pending_count < 0);
+		if (!policy.pending_count)
+			unblock_pendings();
+	}
+
+	mutex_unlock(&policy.lock);
+
+	kfree(handler);
+	pr_debug("%s: handler for %d is removed\n", __func__, current->tgid);
+
+	return 0;
+}
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/policy.h kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/policy.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/policy.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/rmgr/policy.h	2011-10-23 08:22:37.664743000 +0100
@@ -0,0 +1,26 @@
+/*
+ * policy.h - header file for policy enforcement point for TI DSP bridge access
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2010-2011 Nokia Corporation
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/fs.h>
+#include <linux/device.h>
+
+int policy_init(struct class *class);
+void policy_remove(void);
+
+int policy_open_hook(struct inode *ip, struct file *filp);
+int policy_ioctl_pre_hook(struct file *filp, unsigned int code,
+			  unsigned long args);
+int policy_ioctl_post_hook(struct file *filp, unsigned int code,
+			   unsigned long args, int status);
+int policy_mmap_hook(struct file *filp);
+int policy_release_hook(struct inode *ip, struct file *filp);
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/proc.c kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/proc.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/proc.c	2011-10-11 13:51:19.504787763 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/rmgr/proc.c	2011-10-24 16:43:27.531433000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Processor interface at the driver level.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,92 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== proc.c ========
- *  Description:
- *      Processor interface at the driver level.
- *
- *  Public Functions:
- *      PROC_Attach
- *      PROC_Ctrl
- *      PROC_Detach
- *      PROC_EnumNodes
- *      PROC_GetResourceInfo
- *      PROC_Exit
- *      PROC_FlushMemory
- *      PROC_GetState
- *      PROC_GetProcessorId
- *      PROC_GetTrace
- *      PROC_Init
- *      PROC_Load
- *      PROC_Map
- *      PROC_NotifyClients
- *      PROC_RegisterNotify
- *      PROC_ReserveMemory
- *      PROC_Start
- *      PROC_UnMap
- *      PROC_UnReserveMemory
- *      PROC_InvalidateMemory
-
- *! Revision History
- *! ======== ========
- *! 04-Apr-2007 sh  Added PROC_InvalidateMemory API
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *!		 Used MEM_FlushCache instead of OS specific API
- *!		 Integrated Alan's code review updates
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping feature
- *! 08-Mar-2004 vp  Added g_pszLastCoff member to PROC_OBJECT.
- *!		 This is required for multiprocessor environment.
- *! 09-Feb-2004 vp  Added PROC_GetProcessorID function
- *! 22-Apr-2003 vp  Fixed issue with the string that stores coff file name
- *! 03-Apr-2003 sb  Fix DEH deregistering bug
- *! 26-Mar-2003 vp  Commented the call to DSP deep sleep in PROC_Start function.
- *! 18-Feb-2003 vp  Code review updates.
- *! 18-Oct-2002 vp  Ported to Linux platform.
- *! 22-May-2002 sg  Do IOCTL-to-PWR translation before calling PWR_SleepDSP.
- *! 14-May-2002 sg  Use CSL_Atoi() instead of atoi().
- *! 13-May-2002 sg  Propagate PWR return codes upwards.
- *! 07-May-2002 sg  Added check for, and call to PWR functions in PROC_Ctrl.
- *! 02-May-2002 sg  Added "nap" mode: put DSP to sleep once booted.
- *! 01-Apr-2002 jeh Assume word addresses in PROC_GetTrace().
- *! 29-Nov-2001 jeh Don't call DEH function if hDehMgr == NULL.
- *! 05-Nov-2001 kc: Updated PROC_RegisterNotify and PROC_GetState to support
- *!		 DEH module.
- *! 09-Oct-2001 jeh Fix number of bytes calculated in PROC_GetTrace().
- *! 11-Sep-2001 jeh Delete MSG manager in PROC_Monitor() to fix memory leak.
- *! 29-Aug-2001 rr: DCD_AutoRegister and IOOnLoaded moved before COD_LoadBase
- *!		 to facilitate the external loading.
- *! 14-Aug-2001 ag  DCD_AutoRegister() now called before IOOnLoaded() fxn.
- *! 21-Jun-2001 rr: MSG_Create is done only the first time.
- *! 02-May-2001 jeh Return failure in PROC_Load if IOOnLoaded function returns
- *!		 error other than E_NOTIMPL.
- *! 03-Apr-2001 sg: Changed DSP_DCD_ENOAUTOREGISTER to DSP_EDCDNOAUTOREGISTER.
- *! 13-Feb-2001 kc: DSP/BIOS Bridge name updates.
- *! 05-Jan-2001 rr: PROC_LOAD MSG_Create error is checked.
- *! 15-Dec-2000 rr: IoOnLoaded is checked for WSX_STATUS. We fail to load
- *!		 if DEV_Create2 fails; ie, no non-RMS targets can be
- *!		 loaded.
- *! 12-Dec-2000 rr: PROC_Start's DEV_Create2 is checked for WSX_STATUS.
- *! 28-Nov-2000 jeh Added call to IO OnLoaded function to PROC_Load().
- *! 29-Nov-2000 rr: Incorporated code review changes.
- *! 03-Nov-2000 rr: Auto_Register happens after PROC_Load.
- *! 06-Oct-2000 rr: Updated to ver 0.9. PROC_Start calls DEV_Create2 and
- *!		 WMD_BRD_STOP is always followed by DEV_Destroy2.
- *! 05-Sep-2000 rr: PROC_GetTrace calculates the Trace symbol for 55 in a
- *!		 different way.
- *! 10-Aug-2000 rr: PROC_NotifyClients, PROC_GetProcessorHandle Added
- *! 07-Aug-2000 rr: PROC_IDLE/SYNCINIT/UNKNOWN state removed.
- *!		 WMD fxns are checked for WSX_STATUS.
- *!		 PROC_Attach does not alter the state of the BRD.
- *!		 PROC_Run removed.
- *! 04-Aug-2000 rr: All the functions return DSP_EHANDLE if proc handle is
- *!		 invalid
- *! 27-Jul-2000 rr: PROC_GetTrace and PROC_Load implemented. Updated to
- *!		 ver 0.8 API.
- *! 06-Jul-2000 rr: Created.
- */
-
 /* ------------------------------------ Host OS */
 #include <dspbridge/host_os.h>
 
@@ -110,11 +26,9 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/cfg.h>
-#include <dspbridge/csl.h>
 #include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/ntfy.h>
@@ -125,7 +39,6 @@
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/cod.h>
 #include <dspbridge/dev.h>
-#include <dspbridge/drv.h>
 #include <dspbridge/procpriv.h>
 #include <dspbridge/dmm.h>
 
@@ -137,265 +50,201 @@
 
 /*  ----------------------------------- Others */
 #include <dspbridge/dbdcd.h>
-#include <dspbridge/dbreg.h>
 #include <dspbridge/msg.h>
 #include <dspbridge/wmdioctl.h>
 #include <dspbridge/drv.h>
+#include <dspbridge/reg.h>
 
 /*  ----------------------------------- This */
 #include <dspbridge/proc.h>
 #include <dspbridge/pwr.h>
-#include <mach-omap2/omap3-opp.h>
 
-#ifndef RES_CLEANUP_DISABLE
 #include <dspbridge/resourcecleanup.h>
-#endif
 /*  ----------------------------------- Defines, Data Structures, Typedefs */
 #define PROC_SIGNATURE	   0x434F5250	/* "PROC" (in reverse). */
 #define MAXCMDLINELEN       255
 #define PROC_ENVPROCID      "PROC_ID=%d"
 #define MAXPROCIDLEN	(8 + 5)
-#define PROC_DFLT_TIMEOUT   10000	/* Time out in milliseconds  */
+#define PROC_DFLT_TIMEOUT   10000	/* Time out in milliseconds */
 #define PWR_TIMEOUT	 500	/* Sleep/wake timout in msec */
 #define EXTEND	      "_EXT_END"	/* Extmem end addr in DSP binary */
 
 #define DSP_CACHE_LINE 128
 
-extern char *iva_img;
-
-/*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask PROC_DebugMask = { NULL, NULL };	/* WCD MGR Mask */
-#endif
+#define BUFMODE_MASK	(3 << 14)
 
-static u32 cRefs;
+/* Buffer modes from DSP perspective */
+#define RBUF		0x4000		/* Input buffer */
+#define WBUF		0x8000		/* Output Buffer */
 
-struct SYNC_CSOBJECT *hProcLock;	/* For critical sections */
-
-/*  ----------------------------------- Function Prototypes */
-static DSP_STATUS PROC_Monitor(struct PROC_OBJECT *hProcessor);
-static s32 GetEnvpCount(char **envp);
-static char **PrependEnvp(char **newEnvp, char **envp, s32 cEnvp, s32 cNewEnvp,
-			 char *szVar);
-
-/*
- *  ======== PROC_CleanupAllResources =====
- *  Purpose:
- *      Funtion to clean the process resources.
- *      This function is intended to be called when the
- *       processor is in error state
- */
-DSP_STATUS PROC_CleanupAllResources(void)
-{
-	DSP_STATUS dsp_status = DSP_SOK;
-	HANDLE hDrvObject = NULL;
-	struct PROCESS_CONTEXT *pCtxtclosed = NULL;
-	struct PROC_OBJECT *proc_obj_ptr, *temp;
+extern char *iva_img;
 
-	GT_0trace(PROC_DebugMask, GT_ENTER, "PROC_CleanupAllResources\n");
+/*  ----------------------------------- Globals */
 
-	dsp_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	if (DSP_FAILED(dsp_status))
-		goto func_end;
+/* The proc_object structure. */
+struct proc_object {
+	struct list_head link;	/* Link to next proc_object */
+	u32 dw_signature;	/* Used for object validation */
+	struct dev_object *hdev_obj;	/* Device this PROC represents */
+	u32 process;		/* Process owning this Processor */
+	struct mgr_object *hmgr_obj;	/* Manager Object Handle */
+	u32 attach_count;	/* Processor attach count */
+	u32 processor_id;	/* Processor number */
+	u32 utimeout;		/* Time out count */
+	enum dsp_procstate proc_state;	/* Processor state */
+	u32 ul_unit;		/* DDSP unit number */
+	bool is_already_attached;	/*
+					 * True if the Device below has
+					 * GPP Client attached
+					 */
+	struct ntfy_object *ntfy_obj;	/* Manages  notifications */
+	struct wmd_dev_context *hwmd_context;	/* WMD Context Handle */
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD */
+	char *psz_last_coff;
+	struct list_head proc_list;
+};
 
-	DRV_GetProcCtxtList(&pCtxtclosed, (struct DRV_OBJECT *)hDrvObject);
+static u32 refs;
 
-	while (pCtxtclosed != NULL) {
-		if (current->tgid != pCtxtclosed->pid) {
-			GT_1trace(PROC_DebugMask, GT_5CLASS,
-				 "***Cleanup of "
-				 "process***%d\n", pCtxtclosed->pid);
-			list_for_each_entry_safe(proc_obj_ptr, temp,
-					&pCtxtclosed->processor_list,
-					proc_object) {
-				PROC_Detach(proc_obj_ptr, pCtxtclosed);
-			}
-		}
-		pCtxtclosed = pCtxtclosed->next;
-	}
+struct sync_csobject *proc_lock;	/* For critical sections */
 
-	WMD_DEH_ReleaseDummyMem();
-func_end:
-	return dsp_status;
-}
+/*  ----------------------------------- Function Prototypes */
+static dsp_status proc_monitor(struct proc_object *hprocessor);
+static s32 get_envp_count(char **envp);
+static char **prepend_envp(char **new_envp, char **envp, s32 envp_elems,
+			   s32 cnew_envp, char *szVar);
 
 /*
- *  ======== PROC_Attach ========
+ *  ======== proc_attach ========
  *  Purpose:
  *      Prepare for communication with a particular DSP processor, and return
  *      a handle to the processor object.
  */
-DSP_STATUS
-PROC_Attach(u32 uProcessor, OPTIONAL CONST struct DSP_PROCESSORATTRIN *pAttrIn,
-       OUT DSP_HPROCESSOR *phProcessor, struct PROCESS_CONTEXT *pr_ctxt)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct DEV_OBJECT *hDevObject;
-	struct PROC_OBJECT *pProcObject = NULL;
-	struct MGR_OBJECT *hMgrObject = NULL;
-	struct DRV_OBJECT *hDrvObject = NULL;
-	u32 devType;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(phProcessor != NULL);
-
-	GT_3trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Attach, args:\n\t"
-		 "uProcessor:  0x%x\n\tpAttrIn:  0x%x\n\tphProcessor:"
-		 "0x%x\n", uProcessor, pAttrIn, phProcessor);
+dsp_status
+proc_attach(u32 processor_id,
+	    OPTIONAL CONST struct dsp_processorattrin *attr_in,
+	    void **ph_processor, struct process_context *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	struct dev_object *hdev_obj;
+	struct proc_object *p_proc_object = NULL;
+	struct mgr_object *hmgr_obj = NULL;
+	struct drv_object *hdrv_obj = NULL;
+	u32 dev_type;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(ph_processor != NULL);
+
+	if (pr_ctxt->hprocessor) {
+		*ph_processor = pr_ctxt->hprocessor;
+		return status;
+	}
 
 	/* Get the Driver and Manager Object Handles */
-	status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	if (DSP_SUCCEEDED(status)) {
-		status = CFG_GetObject((u32 *)&hMgrObject, REG_MGR_OBJECT);
-		if (DSP_FAILED(status)) {
-			/* don't propogate CFG errors from this PROC function */
-			GT_1trace(PROC_DebugMask, GT_7CLASS,
-				 "PROC_Attach: DSP_FAILED to get"
-				 "the Manager Object.\n", status);
-		}
-	} else {
-		/* don't propogate CFG errors from this PROC function */
-		GT_1trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Attach: failed to get the"
-			 " DriverObject, 0x%x!\n", status);
-	}
+	status = cfg_get_object((u32 *) &hdrv_obj, REG_DRV_OBJECT);
+	if (DSP_SUCCEEDED(status))
+		status = cfg_get_object((u32 *) &hmgr_obj, REG_MGR_OBJECT);
+
 	if (DSP_SUCCEEDED(status)) {
 		/* Get the Device Object */
-		status = DRV_GetDevObject(uProcessor, hDrvObject, &hDevObject);
-		if (DSP_FAILED(status)) {
-			GT_1trace(PROC_DebugMask, GT_7CLASS,
-				 "PROC_Attach: failed to get"
-				 " DevObject, 0x%x!\n", status);
-		}
-	}
-	if (DSP_SUCCEEDED(status)) {
-		status = DEV_GetDevType(hDevObject, &devType);
-		if (DSP_FAILED(status)) {
-			GT_1trace(PROC_DebugMask, GT_7CLASS,
-				 "PROC_Attach: failed to get"
-				 " DevType, 0x%x!\n", status);
-		}
+		status = drv_get_dev_object(processor_id, hdrv_obj, &hdev_obj);
 	}
+	if (DSP_SUCCEEDED(status))
+		status = dev_get_dev_type(hdev_obj, &dev_type);
+
 	if (DSP_FAILED(status))
 		goto func_end;
 
 	/* If we made it this far, create the Proceesor object: */
-	MEM_AllocObject(pProcObject, struct PROC_OBJECT, PROC_SIGNATURE);
+	MEM_ALLOC_OBJECT(p_proc_object, struct proc_object, PROC_SIGNATURE);
 	/* Fill out the Processor Object: */
-	if (pProcObject == NULL) {
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Attach:Out of memeory \n");
-		status = DSP_EFAIL;
+	if (p_proc_object == NULL) {
+		status = DSP_EMEMORY;
 		goto func_end;
 	}
-	pProcObject->hDevObject = hDevObject;
-	pProcObject->hMgrObject = hMgrObject;
-	pProcObject->uProcessor = devType;
-	/* Store TGID of Caller Process */
-	pProcObject->hProcess = current->tgid;
+	p_proc_object->hdev_obj = hdev_obj;
+	p_proc_object->hmgr_obj = hmgr_obj;
+	p_proc_object->processor_id = dev_type;
+	/* Store TGID instead of process handle */
+	p_proc_object->process = current->tgid;
 
-	INIT_LIST_HEAD(&pProcObject->proc_object);
+	INIT_LIST_HEAD(&p_proc_object->proc_list);
 
-	if (pAttrIn)
-		pProcObject->uTimeout = pAttrIn->uTimeout;
+	if (attr_in)
+		p_proc_object->utimeout = attr_in->utimeout;
 	else
-		pProcObject->uTimeout = PROC_DFLT_TIMEOUT;
+		p_proc_object->utimeout = PROC_DFLT_TIMEOUT;
 
-	status = DEV_GetIntfFxns(hDevObject, &pProcObject->pIntfFxns);
+	status = dev_get_intf_fxns(hdev_obj, &p_proc_object->intf_fxns);
 	if (DSP_SUCCEEDED(status)) {
-		status = DEV_GetWMDContext(hDevObject,
-					 &pProcObject->hWmdContext);
-		if (DSP_FAILED(status)) {
-			GT_1trace(PROC_DebugMask, GT_7CLASS,
-				 "PROC_Attach Could not"
-				 " get the WMD Context.\n", status);
-			MEM_FreeObject(pProcObject);
-		}
-	} else {
-		GT_1trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Attach Could not get"
-			 " the DEV_ Interface fxns.\n", status);
-		MEM_FreeObject(pProcObject);
-	}
+		status = dev_get_wmd_context(hdev_obj,
+					     &p_proc_object->hwmd_context);
+		if (DSP_FAILED(status))
+			MEM_FREE_OBJECT(p_proc_object);
+	} else
+		MEM_FREE_OBJECT(p_proc_object);
+
 	if (DSP_FAILED(status))
 		goto func_end;
 
 	/* Create the Notification Object */
 	/* This is created with no event mask, no notify mask
 	 * and no valid handle to the notification. They all get
-	 * filled up when PROC_RegisterNotify is called */
-	status = NTFY_Create(&pProcObject->hNtfy);
+	 * filled up when proc_register_notify is called */
+	status = ntfy_create(&p_proc_object->ntfy_obj);
 	if (DSP_SUCCEEDED(status)) {
 		/* Insert the Processor Object into the DEV List.
 		 * Return handle to this Processor Object:
 		 * Find out if the Device is already attached to a
 		 * Processor. If so, return AlreadyAttached status */
-		LST_InitElem(&pProcObject->link);
-		status = DEV_InsertProcObject(pProcObject->hDevObject,
-					     (u32)pProcObject,
-					     &pProcObject->bIsAlreadyAttached);
+		lst_init_elem(&p_proc_object->link);
+		status = dev_insert_proc_object(p_proc_object->hdev_obj,
+						(u32) p_proc_object,
+						&p_proc_object->
+						is_already_attached);
 		if (DSP_SUCCEEDED(status)) {
-			if (pProcObject->bIsAlreadyAttached) {
+			if (p_proc_object->is_already_attached)
 				status = DSP_SALREADYATTACHED;
-				GT_0trace(PROC_DebugMask, GT_1CLASS,
-					 "PROC_Attach: Processor "
-					 "Already Attached!\n");
-			}
 		} else {
-			if (pProcObject->hNtfy)
-				NTFY_Delete(pProcObject->hNtfy);
+			if (p_proc_object->ntfy_obj)
+				ntfy_delete(p_proc_object->ntfy_obj);
 
-			MEM_FreeObject(pProcObject);
-			GT_1trace(PROC_DebugMask, GT_7CLASS,
-				 "PROC_Attach: failed to insert "
-				 "Proc Object into DEV, 0x%x!\n", status);
+			MEM_FREE_OBJECT(p_proc_object);
 		}
 		if (DSP_SUCCEEDED(status)) {
-			*phProcessor = (DSP_HPROCESSOR)pProcObject;
-			(void)PROC_NotifyClients(pProcObject,
-						 DSP_PROCESSORATTACH);
-			GT_0trace(PROC_DebugMask, GT_1CLASS,
-				 "PROC_Attach: Processor "
-				 "Attach Success!\n");
+			*ph_processor = (void *)p_proc_object;
+			pr_ctxt->hprocessor = *ph_processor;
+			(void)proc_notify_clients(p_proc_object,
+						  DSP_PROCESSORATTACH);
 		}
 	} else {
 		/* Don't leak memory if DSP_FAILED */
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Attach: Could not allocate "
-			 "storage for notification \n");
-		MEM_FreeObject(pProcObject);
-	}
-#ifndef RES_CLEANUP_DISABLE
-	spin_lock(&pr_ctxt->proc_list_lock);
-	list_add(&pProcObject->proc_object, &pr_ctxt->processor_list);
-	spin_unlock(&pr_ctxt->proc_list_lock);
-#endif
+		MEM_FREE_OBJECT(p_proc_object);
+	}
 func_end:
-	DBC_Ensure((status == DSP_EFAIL && *phProcessor == NULL) ||
-		  (DSP_SUCCEEDED(status) &&
-		  MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) ||
-		  (status == DSP_SALREADYATTACHED &&
-		  MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)));
-	GT_2trace(PROC_DebugMask, GT_ENTER, "Exiting PROC_Attach, results:\n\t"
-		 "status: 0x%x\n\thProcessor: 0x%x\n", status, *phProcessor);
+	DBC_ENSURE((status == DSP_EFAIL && *ph_processor == NULL) ||
+		   (DSP_SUCCEEDED(status) &&
+		    MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) ||
+		   (status == DSP_SALREADYATTACHED &&
+		    MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)));
 
 	return status;
 }
 
-static DSP_STATUS GetExecFile(struct CFG_DEVNODE *hDevNode,
-			     struct DEV_OBJECT *hDevObject,
-			     u32 size, char *execFile)
+static dsp_status get_exec_file(struct cfg_devnode *dev_node_obj,
+				struct dev_object *hdev_obj,
+				u32 size, char *execFile)
 {
-	s32 devType;
+	s32 dev_type;
 	s32 len;
 
-	DEV_GetDevType(hDevObject, (u32 *) &devType);
-	if (devType == DSP_UNIT) {
-		return CFG_GetExecFile(hDevNode, size, execFile);
-	} else if (devType == IVA_UNIT) {
+	dev_get_dev_type(hdev_obj, (u32 *) &dev_type);
+	if (dev_type == DSP_UNIT) {
+		return cfg_get_exec_file(dev_node_obj, size, execFile);
+	} else if (dev_type == IVA_UNIT) {
 		if (iva_img) {
-                       len = strlen(iva_img);
-                       strncpy(execFile, iva_img, len + 1);
+			len = strlen(iva_img);
+			strncpy(execFile, iva_img, len + 1);
 			return DSP_SOK;
 		}
 	}
@@ -403,298 +252,216 @@
 }
 
 /*
- *  ======== PROC_AutoStart ======== =
+ *  ======== proc_auto_start ======== =
  *  Purpose:
  *      A Particular device gets loaded with the default image
  *      if the AutoStart flag is set.
  *  Parameters:
- *      hDevObject:     Handle to the Device
+ *      hdev_obj:     Handle to the Device
  *  Returns:
  *      DSP_SOK:   On Successful Loading
  *      DSP_EFAIL  General Failure
  *  Requires:
- *      hDevObject != NULL
+ *      hdev_obj != NULL
  *  Ensures:
  */
-DSP_STATUS PROC_AutoStart(struct CFG_DEVNODE *hDevNode,
-			 struct DEV_OBJECT *hDevObject)
+dsp_status proc_auto_start(struct cfg_devnode *dev_node_obj,
+			   struct dev_object *hdev_obj)
 {
-	DSP_STATUS status = DSP_EFAIL;
-	u32 dwAutoStart = 0;	/* autostart flag */
-	struct PROC_OBJECT *pProcObject;
-	struct PROC_OBJECT *hProcObject;
-	char szExecFile[MAXCMDLINELEN];
+	dsp_status status = DSP_EFAIL;
+	struct proc_object *p_proc_object;
+	char sz_exec_file[MAXCMDLINELEN];
 	char *argv[2];
-	struct MGR_OBJECT *hMgrObject = NULL;
-	s32 devType;
+	struct mgr_object *hmgr_obj = NULL;
+	s32 dev_type;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(dev_node_obj != NULL);
+	DBC_REQUIRE(hdev_obj != NULL);
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(hDevNode != NULL);
-	DBC_Require(hDevObject != NULL);
-
-	GT_2trace(PROC_DebugMask, GT_ENTER,
-		 "Entered PROC_AutoStart, args:\n\t"
-		 "hDevNode: 0x%x\thDevObject: 0x%x\n", hDevNode, hDevObject);
 	/* Create a Dummy PROC Object */
-	if (DSP_FAILED(CFG_GetObject((u32 *)&hMgrObject,
-	   REG_MGR_OBJECT))) {
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_AutoStart: DSP_FAILED to "
-			 "Get MGR Object\n");
-		goto func_end;
-	}
-	MEM_AllocObject(pProcObject, struct PROC_OBJECT, PROC_SIGNATURE);
-	if (pProcObject == NULL) {
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_AutoStart: DSP_FAILED "
-			 "to Create a dummy Processor\n");
-		goto func_end;
-	}
-	GT_0trace(PROC_DebugMask, GT_1CLASS, "NTFY Created \n");
-	pProcObject->hDevObject = hDevObject;
-	pProcObject->hMgrObject = hMgrObject;
-	hProcObject = pProcObject;
-	if (DSP_SUCCEEDED(DEV_GetIntfFxns(hDevObject,
-	   &pProcObject->pIntfFxns))) {
-		if (DSP_SUCCEEDED(DEV_GetWMDContext(hDevObject,
-				 &pProcObject->hWmdContext))) {
-			status = DSP_SOK;
-		} else {
-			MEM_FreeObject(hProcObject);
-			GT_0trace(PROC_DebugMask, GT_7CLASS,
-				 "PROC_AutoStart: Failed "
-				 "to get WMD Context \n");
-		}
-	} else {
-		MEM_FreeObject(hProcObject);
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_AutoStart: Failed to "
-			 "get IntFxns \n");
-	}
+	status = cfg_get_object((u32 *) &hmgr_obj, REG_MGR_OBJECT);
 	if (DSP_FAILED(status))
 		goto func_end;
 
+	MEM_ALLOC_OBJECT(p_proc_object, struct proc_object, PROC_SIGNATURE);
+	if (p_proc_object == NULL) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+	p_proc_object->hdev_obj = hdev_obj;
+	p_proc_object->hmgr_obj = hmgr_obj;
+	status = dev_get_intf_fxns(hdev_obj, &p_proc_object->intf_fxns);
+	if (DSP_SUCCEEDED(status))
+		status = dev_get_wmd_context(hdev_obj,
+					     &p_proc_object->hwmd_context);
+	if (DSP_FAILED(status))
+		goto func_cont;
+
 	/* Stop the Device, put it into standby mode */
-	status = PROC_Stop(hProcObject);
-	if (DSP_FAILED(CFG_GetAutoStart(hDevNode, &dwAutoStart)) ||
-			   !dwAutoStart) {
-		status = DSP_EFAIL;
-		/* DSP_FAILED to Get s32 Fxn or Wmd Context */
-		GT_0trace(PROC_DebugMask, GT_1CLASS, "PROC_AutoStart: "
-			 "CFG_GetAutoStart DSP_FAILED \n");
+	status = proc_stop(p_proc_object);
+
+	if (DSP_FAILED(status))
 		goto func_cont;
-	}
+
 	/* Get the default executable for this board... */
-	DEV_GetDevType(hDevObject, (u32 *)&devType);
-	pProcObject->uProcessor = devType;
-	if (DSP_SUCCEEDED(GetExecFile(hDevNode, hDevObject,
-			 sizeof(szExecFile), szExecFile))) {
-		argv[0] = szExecFile;
+	dev_get_dev_type(hdev_obj, (u32 *) &dev_type);
+	p_proc_object->processor_id = dev_type;
+	status = get_exec_file(dev_node_obj, hdev_obj, sizeof(sz_exec_file),
+			       sz_exec_file);
+	if (DSP_SUCCEEDED(status)) {
+		argv[0] = sz_exec_file;
 		argv[1] = NULL;
 		/* ...and try to load it: */
-		status = PROC_Load(hProcObject, 1, (CONST char **)argv, NULL);
-		if (DSP_SUCCEEDED(status)) {
-			status = PROC_Start(hProcObject);
-			if (DSP_SUCCEEDED(status)) {
-				GT_0trace(PROC_DebugMask, GT_1CLASS,
-					  "PROC_AutoStart: Processor started "
-					  "running\n");
-			} else {
-				GT_0trace(PROC_DebugMask, GT_7CLASS,
-					  "PROC_AutoStart: DSP_FAILED To "
-					  "Start \n");
-			}
-		} else {
-			GT_0trace(PROC_DebugMask, GT_7CLASS,
-				  "PROC_AutoStart: DSP_FAILED to Load\n");
-		}
-	} else {
-		status = DSP_EFILE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_AutoStart: "
-			 "No Exec file found \n");
+		status = proc_load(p_proc_object, 1, (CONST char **)argv, NULL);
+		if (DSP_SUCCEEDED(status))
+			status = proc_start(p_proc_object);
 	}
+	kfree(p_proc_object->psz_last_coff);
+	p_proc_object->psz_last_coff = NULL;
 func_cont:
-	MEM_FreeObject(hProcObject);
+	MEM_FREE_OBJECT(p_proc_object);
 func_end:
-	GT_1trace(PROC_DebugMask, GT_ENTER,
-		 "Exiting PROC_AutoStart, status:0x%x\n", status);
 	return status;
 }
 
 /*
- *  ======== PROC_Ctrl ========
+ *  ======== proc_ctrl ========
  *  Purpose:
  *      Pass control information to the GPP device driver managing the
  *      DSP processor.
  *
  *      This will be an OEM-only function, and not part of the DSP/BIOS Bridge
  *      application developer's API.
- *      Call the WMD_ICOTL Fxn with the Argument This is a Synchronous
+ *      Call the WMD_ICOTL fxn with the Argument This is a Synchronous
  *      Operation. arg can be null.
  */
-DSP_STATUS PROC_Ctrl(DSP_HPROCESSOR hProcessor, u32 dwCmd,
-		    IN struct DSP_CBDATA *arg)
+dsp_status proc_ctrl(void *hprocessor, u32 dw_cmd, IN struct dsp_cbdata * arg)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = hProcessor;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = hprocessor;
 	u32 timeout = 0;
 
-	DBC_Require(cRefs > 0);
-	GT_3trace(PROC_DebugMask, GT_ENTER,
-		 "Entered PROC_Ctrl, args:\n\thProcessor:"
-		 " 0x%x\n\tdwCmd: 0x%x\n\targ: 0x%x\n", hProcessor, dwCmd, arg);
+	DBC_REQUIRE(refs > 0);
 
-	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	if (MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		/* intercept PWR deep sleep command */
-		if (dwCmd == WMDIOCTL_DEEPSLEEP) {
-			timeout = arg->cbData;
-			status = PWR_SleepDSP(PWR_DEEPSLEEP, timeout);
+		if (dw_cmd == WMDIOCTL_DEEPSLEEP) {
+			timeout = arg->cb_data;
+			status = pwr_sleep_dsp(PWR_DEEPSLEEP, timeout);
 		}
 		/* intercept PWR emergency sleep command */
-		else if (dwCmd == WMDIOCTL_EMERGENCYSLEEP) {
-			timeout = arg->cbData;
-			status = PWR_SleepDSP(PWR_EMERGENCYDEEPSLEEP, timeout);
-		} else if (dwCmd == PWR_DEEPSLEEP) {
-			/* timeout = arg->cbData; */
-			status = PWR_SleepDSP(PWR_DEEPSLEEP, timeout);
+		else if (dw_cmd == WMDIOCTL_EMERGENCYSLEEP) {
+			timeout = arg->cb_data;
+			status = pwr_sleep_dsp(PWR_EMERGENCYDEEPSLEEP, timeout);
+		} else if (dw_cmd == PWR_DEEPSLEEP) {
+			/* timeout = arg->cb_data; */
+			status = pwr_sleep_dsp(PWR_DEEPSLEEP, timeout);
 		}
 		/* intercept PWR wake commands */
-		else if (dwCmd == WMDIOCTL_WAKEUP) {
-			timeout = arg->cbData;
-			status = PWR_WakeDSP(timeout);
-		} else if (dwCmd == PWR_WAKEUP) {
-			/* timeout = arg->cbData; */
-			status = PWR_WakeDSP(timeout);
+		else if (dw_cmd == WMDIOCTL_WAKEUP) {
+			timeout = arg->cb_data;
+			status = pwr_wake_dsp(timeout);
+		} else if (dw_cmd == PWR_WAKEUP) {
+			/* timeout = arg->cb_data; */
+			status = pwr_wake_dsp(timeout);
 		} else
-		    if (DSP_SUCCEEDED
-			((*pProcObject->pIntfFxns->pfnDevCntrl)
-				(pProcObject->hWmdContext, dwCmd, arg))) {
+		    if (DSP_SUCCEEDED((*p_proc_object->intf_fxns->pfn_dev_cntrl)
+				      (p_proc_object->hwmd_context, dw_cmd,
+				       arg))) {
 			status = DSP_SOK;
 		} else {
 			status = DSP_EFAIL;
-			GT_0trace(PROC_DebugMask, GT_7CLASS,
-				 "PROC_Ctrl: Failed \n");
 		}
 	} else {
 		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Ctrl: InValid Processor Handle \n");
 	}
-	GT_1trace(PROC_DebugMask, GT_ENTER, "Exiting PROC_Ctrl, 0x%x\n",
-		 status);
+
 	return status;
 }
 
 /*
- *  ======== PROC_Detach ========
+ *  ======== proc_detach ========
  *  Purpose:
  *      Destroys the  Processor Object. Removes the notification from the Dev
  *      List.
  */
-DSP_STATUS PROC_Detach(DSP_HPROCESSOR hProcessor,
-		struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status proc_detach(struct process_context *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	DBC_Require(cRefs > 0);
-	GT_1trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Detach, args:\n\t"
-		 "hProcessor:  0x%x\n", hProcessor);
-
-	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-#ifndef RES_CLEANUP_DISABLE
-		if (pr_ctxt) {
-			spin_lock(&pr_ctxt->proc_list_lock);
-			list_del(&pProcObject->proc_object);
-			spin_unlock(&pr_ctxt->proc_list_lock);
-		}
-#endif
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = NULL;
+
+	DBC_REQUIRE(refs > 0);
+
+	p_proc_object = (struct proc_object *)pr_ctxt->hprocessor;
+
+	if (MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		/* Notify the Client */
-		NTFY_Notify(pProcObject->hNtfy, DSP_PROCESSORDETACH);
+		ntfy_notify(p_proc_object->ntfy_obj, DSP_PROCESSORDETACH);
 		/* Remove the notification memory */
-		if (pProcObject->hNtfy)
-			NTFY_Delete(pProcObject->hNtfy);
+		if (p_proc_object->ntfy_obj)
+			ntfy_delete(p_proc_object->ntfy_obj);
 
-		if (pProcObject->g_pszLastCoff) {
-			MEM_Free(pProcObject->g_pszLastCoff);
-			pProcObject->g_pszLastCoff = NULL;
-		}
+		kfree(p_proc_object->psz_last_coff);
+		p_proc_object->psz_last_coff = NULL;
 		/* Remove the Proc from the DEV List */
-		(void)DEV_RemoveProcObject(pProcObject->hDevObject,
-			(u32)pProcObject);
+		(void)dev_remove_proc_object(p_proc_object->hdev_obj,
+					     (u32) p_proc_object);
 		/* Free the Processor Object */
-		MEM_FreeObject(pProcObject);
+		MEM_FREE_OBJECT(p_proc_object);
+		pr_ctxt->hprocessor = NULL;
 	} else {
 		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Detach: InValid Processor Handle \n");
 	}
-	GT_1trace(PROC_DebugMask, GT_ENTER, "Exiting PROC_Detach, 0x%x\n",
-		 status);
+
 	return status;
 }
 
 /*
- *  ======== PROC_EnumNodes ========
+ *  ======== proc_enum_nodes ========
  *  Purpose:
  *      Enumerate and get configuration information about nodes allocated
  *      on a DSP processor.
  */
-DSP_STATUS PROC_EnumNodes(DSP_HPROCESSOR hProcessor, OUT DSP_HNODE *aNodeTab,
-               IN u32 uNodeTabSize, OUT u32 *puNumNodes,
-               OUT u32 *puAllocated)
-{
-	DSP_STATUS status = DSP_EFAIL;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	struct NODE_MGR *hNodeMgr = NULL;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(aNodeTab != NULL || uNodeTabSize == 0);
-	DBC_Require(puNumNodes != NULL);
-	DBC_Require(puAllocated != NULL);
-
-	GT_5trace(PROC_DebugMask, GT_ENTER, "Entered PROC_EnumNodes, args:\n\t"
-			"hProcessor:  0x%x\n\taNodeTab:  0x%x\n\tuNodeTabSize: "
-			" 0x%x\n\t puNumNodes 0x%x\n\t puAllocated: 0x%x\n",
-			hProcessor, aNodeTab, uNodeTabSize, puNumNodes,
-			puAllocated);
-	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		if (DSP_SUCCEEDED(DEV_GetNodeManager(pProcObject->hDevObject,
-				 &hNodeMgr))) {
-			if (hNodeMgr) {
-				status = NODE_EnumNodes(hNodeMgr, aNodeTab,
-							uNodeTabSize,
-							puNumNodes,
-							puAllocated);
+dsp_status proc_enum_nodes(void *hprocessor, void **node_tab,
+			   IN u32 node_tab_size, OUT u32 *pu_num_nodes,
+			   OUT u32 *pu_allocated)
+{
+	dsp_status status = DSP_EFAIL;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct node_mgr *hnode_mgr = NULL;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(node_tab != NULL || node_tab_size == 0);
+	DBC_REQUIRE(pu_num_nodes != NULL);
+	DBC_REQUIRE(pu_allocated != NULL);
+
+	if (MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
+		if (DSP_SUCCEEDED(dev_get_node_manager(p_proc_object->hdev_obj,
+						       &hnode_mgr))) {
+			if (hnode_mgr) {
+				status = node_enum_nodes(hnode_mgr, node_tab,
+							 node_tab_size,
+							 pu_num_nodes,
+							 pu_allocated);
 			}
 		}
 	} else {
 		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_EnumNodes: "
-			 "InValid Processor Handle \n");
 	}
-	GT_6trace(PROC_DebugMask, GT_ENTER, "Exit PROC_EnumNodes, args:\n\t"
-			"hProcessor:  0x%x\n\taNodeTab:  0x%x\n\tuNodeTabSize: "
-			" 0x%x\n\t puNumNodes 0x%x\n\t puAllocated: 0x%x\n\t "
-			"status: 0x%x \n", hProcessor, aNodeTab, uNodeTabSize,
-			puNumNodes, puAllocated, status);
 
 	return status;
 }
 
 /* Cache operation against kernel address instead of users */
 static int memory_sync_page(struct vm_area_struct *vma, unsigned long start,
-			    ssize_t len, enum DSP_FLUSHTYPE ftype)
+			    ssize_t len, enum dsp_flushtype ftype)
 {
 	struct page *page;
 	void *kaddr;
 	unsigned long offset;
 	ssize_t rest;
 
-#ifdef CHECK_DSP_CACHE_LINE
-	if ((start & DSP_CACHE_LINE) || (len & DSP_CACHE_LINE))
-		pr_warning("%s: not aligned: %08lx(%d)\n", __func__,
-			   start, len);
-#endif
 	while (len) {
 		page = follow_page(vma, start, FOLL_GET);
 		if (!page) {
@@ -707,11 +474,11 @@
 		}
 
 		offset = start & ~PAGE_MASK;
-		kaddr = page_address(page) + offset;
+		kaddr = kmap(page) + offset;
 		rest = min_t(ssize_t, PAGE_SIZE - offset, len);
+		mem_flush_cache(kaddr, rest, ftype);
 
-		MEM_FlushCache(kaddr, rest, ftype);
-
+		kunmap(page);
 		put_page(page);
 		len -= rest;
 		start += rest;
@@ -722,7 +489,7 @@
 
 /* Check if the given area blongs to process virtul memory address space */
 static int memory_sync_vma(unsigned long start, u32 len,
-			   enum DSP_FLUSHTYPE ftype)
+			   enum dsp_flushtype ftype)
 {
 	int err = 0;
 	unsigned long end;
@@ -759,274 +526,236 @@
 	return err;
 }
 
-static DSP_STATUS proc_memory_sync(DSP_HPROCESSOR hProcessor, void *pMpuAddr,
-				   u32 ulSize, u32 ulFlags,
-				   enum DSP_FLUSHTYPE FlushMemType)
+static dsp_status proc_memory_sync(void *hprocessor, void *pmpu_addr,
+				   u32 ul_size, u32 ul_flags,
+				   enum dsp_flushtype FlushMemType)
 {
 	/* Keep STATUS here for future additions to this function */
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+
+	DBC_REQUIRE(refs > 0);
 
-	DBC_Require(cRefs > 0);
-	GT_5trace(PROC_DebugMask, GT_ENTER,
-		  "Entered %s, args:\n\t"
-		  "hProcessor: 0x%x pMpuAddr: 0x%x ulSize 0x%x, ulFlags 0x%x\n",
-		  __func__, hProcessor, pMpuAddr, ulSize, ulFlags);
-
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		GT_1trace(PROC_DebugMask, GT_7CLASS,
-			  "%s: InValid Processor Handle\n", __func__);
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto err_out;
 	}
 
 	down_read(&current->mm->mmap_sem);
 
-	if (memory_sync_vma((u32)pMpuAddr, ulSize, FlushMemType)) {
+	if (memory_sync_vma((u32) pmpu_addr, ul_size, FlushMemType)) {
 		pr_err("%s: InValid address parameters %p %x\n",
-		       __func__, pMpuAddr, ulSize);
+		       __func__, pmpu_addr, ul_size);
 		status = DSP_EHANDLE;
 	}
 
 	up_read(&current->mm->mmap_sem);
+
 err_out:
-	GT_2trace(PROC_DebugMask, GT_ENTER,
-		  "Leaving %s [0x%x]", __func__, status);
 
 	return status;
 }
 
 /*
- *  ======== PROC_FlushMemory ========
+ *  ======== proc_flush_memory ========
  *  Purpose:
  *     Flush cache
  */
-DSP_STATUS PROC_FlushMemory(DSP_HPROCESSOR hProcessor, void *pMpuAddr,
-			    u32 ulSize, u32 ulFlags)
+dsp_status proc_flush_memory(void *hprocessor, void *pmpu_addr,
+			     u32 ul_size, u32 ul_flags)
 {
-	enum DSP_FLUSHTYPE mtype = PROC_WRITEBACK_INVALIDATE_MEM;
-
-	if (ulFlags & 1)
-		mtype = PROC_WRITEBACK_MEM;
+	enum dsp_flushtype mtype = PROC_WRITEBACK_INVALIDATE_MEM;
 
-	return proc_memory_sync(hProcessor, pMpuAddr, ulSize, ulFlags, mtype);
+	return proc_memory_sync(hprocessor, pmpu_addr, ul_size, ul_flags,
+				mtype);
 }
 
 /*
- *  ======== PROC_InvalidateMemory ========
+ *  ======== proc_invalidate_memory ========
  *  Purpose:
  *     Invalidates the memory specified
  */
-DSP_STATUS PROC_InvalidateMemory(DSP_HPROCESSOR hProcessor, void *pMpuAddr,
-				 u32 ulSize)
+dsp_status proc_invalidate_memory(void *hprocessor, void *pmpu_addr,
+				  u32 ul_size)
 {
-	enum DSP_FLUSHTYPE mtype = PROC_INVALIDATE_MEM;
+	enum dsp_flushtype mtype = PROC_INVALIDATE_MEM;
 
-	return proc_memory_sync(hProcessor, pMpuAddr, ulSize, 0, mtype);
+	return proc_memory_sync(hprocessor, pmpu_addr, ul_size, 0, mtype);
 }
 
 /*
- *  ======== PROC_GetResourceInfo ========
+ *  ======== proc_get_resource_info ========
  *  Purpose:
  *      Enumerate the resources currently available on a processor.
  */
-DSP_STATUS PROC_GetResourceInfo(DSP_HPROCESSOR hProcessor, u32 uResourceType,
-				OUT struct DSP_RESOURCEINFO *pResourceInfo,
-				u32 uResourceInfoSize)
-{
-	DSP_STATUS status = DSP_EFAIL;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	struct NODE_MGR *hNodeMgr = NULL;
-	struct NLDR_OBJECT *hNldr = NULL;
-	struct RMM_TargetObj *rmm = NULL;
-	struct IO_MGR *hIOMgr = NULL;		/* IO manager handle */
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pResourceInfo != NULL);
-	DBC_Require(uResourceInfoSize >= sizeof(struct DSP_RESOURCEINFO));
-
-	GT_4trace(PROC_DebugMask, GT_ENTER, "Entered PROC_GetResourceInfo,\n\t"
-		 "hProcessor:  0x%x\n\tuResourceType:  0x%x\n\tpResourceInfo:"
-		 " 0x%x\n\t uResourceInfoSize 0x%x\n", hProcessor,
-		 uResourceType, pResourceInfo, uResourceInfoSize);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+dsp_status proc_get_resource_info(void *hprocessor, u32 resource_type,
+				  OUT struct dsp_resourceinfo *resource_info,
+				  u32 resource_info_size)
+{
+	dsp_status status = DSP_EFAIL;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct node_mgr *hnode_mgr = NULL;
+	struct nldr_object *nldr_obj = NULL;
+	struct rmm_target_obj *rmm = NULL;
+	struct io_mgr *hio_mgr = NULL;	/* IO manager handle */
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(resource_info != NULL);
+	DBC_REQUIRE(resource_info_size >= sizeof(struct dsp_resourceinfo));
+
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_GetResourceInfo: InValid "
-			 "Processor Handle \n");
 		goto func_end;
 	}
-	switch (uResourceType) {
+	switch (resource_type) {
 	case DSP_RESOURCE_DYNDARAM:
 	case DSP_RESOURCE_DYNSARAM:
 	case DSP_RESOURCE_DYNEXTERNAL:
 	case DSP_RESOURCE_DYNSRAM:
-		if (DSP_FAILED(DEV_GetNodeManager(pProcObject->hDevObject,
-		   &hNodeMgr)))
+		status = dev_get_node_manager(p_proc_object->hdev_obj,
+					      &hnode_mgr);
+		if (DSP_FAILED(status))
 			goto func_end;
 
-		if (DSP_SUCCEEDED(NODE_GetNldrObj(hNodeMgr, &hNldr))) {
-			if (DSP_SUCCEEDED(NLDR_GetRmmManager(hNldr, &rmm))) {
-				DBC_Assert(rmm != NULL);
-				status = DSP_EVALUE;
-				if (RMM_stat(rmm,
-				   (enum DSP_MEMTYPE)uResourceType,
-				   (struct DSP_MEMSTAT *)&(pResourceInfo->
-				   result.memStat)))
-					status = DSP_SOK;
+		status = node_get_nldr_obj(hnode_mgr, &nldr_obj);
+		if (DSP_SUCCEEDED(status)) {
+			status = nldr_get_rmm_manager(nldr_obj, &rmm);
+			if (DSP_SUCCEEDED(status)) {
+				DBC_ASSERT(rmm != NULL);
+				if (!rmm_stat(rmm,
+					      (enum dsp_memtype)resource_type,
+					      (struct dsp_memstat *)
+					      &(resource_info->result.
+						mem_stat)))
+					status = DSP_EVALUE;
 			}
 		}
 		break;
 	case DSP_RESOURCE_PROCLOAD:
-		status = DEV_GetIOMgr(pProcObject->hDevObject, &hIOMgr);
-		status = pProcObject->pIntfFxns->pfnIOGetProcLoad(hIOMgr,
-			 (struct DSP_PROCLOADSTAT *)&(pResourceInfo->
-			 result.procLoadStat));
-		if (DSP_FAILED(status)) {
-			GT_1trace(PROC_DebugMask, GT_7CLASS,
-			"Error in procLoadStat function 0x%x\n", status);
-		}
+		status = dev_get_io_mgr(p_proc_object->hdev_obj, &hio_mgr);
+		if (DSP_SUCCEEDED(status))
+			status =
+			    p_proc_object->intf_fxns->
+			    pfn_io_get_proc_load(hio_mgr,
+						 (struct dsp_procloadstat *)
+						 &(resource_info->result.
+						   proc_load_stat));
 		break;
 	default:
 		status = DSP_EFAIL;
 		break;
 	}
 func_end:
-	GT_1trace(PROC_DebugMask, GT_ENTER, "Exiting PROC_GetResourceInfo, "
-		 "status 0x%x\n", status);
 	return status;
 }
 
 /*
- *  ======== PROC_Exit ========
+ *  ======== proc_exit ========
  *  Purpose:
  *      Decrement reference count, and free resources when reference count is
  *      0.
  */
-void PROC_Exit(void)
+void proc_exit(void)
 {
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(refs > 0);
 
-	if (hProcLock)
-		(void)SYNC_DeleteCS(hProcLock);
+	if (proc_lock)
+		(void)sync_delete_cs(proc_lock);
 
-	cRefs--;
+	refs--;
 
-	GT_1trace(PROC_DebugMask, GT_5CLASS,
-		 "Entered PROC_Exit, ref count:0x%x\n",	cRefs);
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== PROC_GetDevObject ========
+ *  ======== proc_get_dev_object ========
  *  Purpose:
  *      Return the Dev Object handle for a given Processor.
  *
  */
-DSP_STATUS PROC_GetDevObject(DSP_HPROCESSOR hProcessor,
-			     struct DEV_OBJECT **phDevObject)
+dsp_status proc_get_dev_object(void *hprocessor,
+			       struct dev_object **phDevObject)
 {
-	DSP_STATUS status = DSP_EFAIL;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	dsp_status status = DSP_EFAIL;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phDevObject != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phDevObject != NULL);
 
-	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		*phDevObject = pProcObject->hDevObject;
+	if (MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
+		*phDevObject = p_proc_object->hdev_obj;
 		status = DSP_SOK;
 	} else {
 		*phDevObject = NULL;
 		status = DSP_EHANDLE;
 	}
 
-	DBC_Ensure((DSP_SUCCEEDED(status) && *phDevObject != NULL) ||
+	DBC_ENSURE((DSP_SUCCEEDED(status) && *phDevObject != NULL) ||
 		   (DSP_FAILED(status) && *phDevObject == NULL));
 
 	return status;
 }
 
 /*
- *  ======== PROC_GetState ========
+ *  ======== proc_get_state ========
  *  Purpose:
  *      Report the state of the specified DSP processor.
  */
-DSP_STATUS PROC_GetState(DSP_HPROCESSOR hProcessor,
-			OUT struct DSP_PROCESSORSTATE *pProcStatus,
-			u32 uStateInfoSize)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	BRD_STATUS brdStatus;
-	struct DEH_MGR *hDehMgr;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pProcStatus != NULL);
-	DBC_Require(uStateInfoSize >= sizeof(struct DSP_PROCESSORSTATE));
-
-	GT_3trace(PROC_DebugMask, GT_ENTER, "Entering PROC_GetState, args:\n\t"
-		 "pProcStatus: 0x%x\n\thProcessor: 0x%x\n\t uStateInfoSize"
-		 " 0x%x\n", pProcStatus, hProcessor, uStateInfoSize);
-	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+dsp_status proc_get_state(void *hprocessor,
+			  OUT struct dsp_processorstate *proc_state_obj,
+			  u32 state_info_size)
+{
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	int brd_status;
+	struct deh_mgr *hdeh_mgr;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(proc_state_obj != NULL);
+	DBC_REQUIRE(state_info_size >= sizeof(struct dsp_processorstate));
+
+	if (MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		/* First, retrieve BRD state information */
-		if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
-		   (pProcObject->hWmdContext, &brdStatus))) {
-			switch (brdStatus) {
+		status = (*p_proc_object->intf_fxns->pfn_brd_status)
+		    (p_proc_object->hwmd_context, &brd_status);
+		if (DSP_SUCCEEDED(status)) {
+			switch (brd_status) {
 			case BRD_STOPPED:
-				pProcStatus->iState = PROC_STOPPED;
+				proc_state_obj->proc_state = PROC_STOPPED;
 				break;
+			case BRD_SLEEP_TRANSITION:
 			case BRD_DSP_HIBERNATION:
 				/* Fall through */
 			case BRD_RUNNING:
-				pProcStatus->iState = PROC_RUNNING;
+				proc_state_obj->proc_state = PROC_RUNNING;
 				break;
 			case BRD_LOADED:
-				pProcStatus->iState = PROC_LOADED;
+				proc_state_obj->proc_state = PROC_LOADED;
 				break;
 			case BRD_ERROR:
-				pProcStatus->iState = PROC_ERROR;
+				proc_state_obj->proc_state = PROC_ERROR;
 				break;
 			default:
-				pProcStatus->iState = 0xFF;
+				proc_state_obj->proc_state = 0xFF;
 				status = DSP_EFAIL;
 				break;
 			}
-		} else {
-			status = DSP_EFAIL;
-			GT_0trace(PROC_DebugMask, GT_7CLASS,
-				 "PROC_GetState: General Failure"
-				 " to read the PROC Status \n");
 		}
 		/* Next, retrieve error information, if any */
-		status = DEV_GetDehMgr(pProcObject->hDevObject, &hDehMgr);
-		if (DSP_SUCCEEDED(status) && hDehMgr) {
-			status = (*pProcObject->pIntfFxns->pfnDehGetInfo)
-				 (hDehMgr, &(pProcStatus->errInfo));
-			if (DSP_FAILED(status)) {
-				GT_0trace(PROC_DebugMask, GT_7CLASS,
-					 "PROC_GetState: Failed "
-					 "retrieve exception info.\n");
-			}
-		} else {
-			status = DSP_EFAIL;
-			GT_0trace(PROC_DebugMask, GT_7CLASS,
-				 "PROC_GetState: Failed to "
-				 "retrieve DEH handle.\n");
-		}
+		status = dev_get_deh_mgr(p_proc_object->hdev_obj, &hdeh_mgr);
+		if (DSP_SUCCEEDED(status) && hdeh_mgr)
+			status = (*p_proc_object->intf_fxns->pfn_deh_get_info)
+			    (hdeh_mgr, &(proc_state_obj->err_info));
 	} else {
 		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_GetState:InValid Processor Handle \n");
 	}
-	GT_2trace(PROC_DebugMask, GT_ENTER,
-		 "Exiting PROC_GetState, results:\n\t"
-		 "status:  0x%x\n\tpProcStatus: 0x%x\n", status,
-		 pProcStatus->iState);
+	dev_dbg(bridge, "%s, results: status: 0x%x proc_state_obj: 0x%x\n",
+		__func__, status, proc_state_obj->proc_state);
 	return status;
 }
 
 /*
- *  ======== PROC_GetTrace ========
+ *  ======== proc_get_trace ========
  *  Purpose:
  *      Retrieve the current contents of the trace buffer, located on the
  *      Processor.  Predefined symbols for the trace buffer must have been
@@ -1037,205 +766,175 @@
  *      This call is destructive, meaning the processor is placed in the monitor
  *      state as a result of this function.
  */
-DSP_STATUS PROC_GetTrace(DSP_HPROCESSOR hProcessor, u8 *pBuf, u32 uMaxSize)
+dsp_status proc_get_trace(void *hprocessor, u8 * pbuf, u32 max_size)
 {
-	DSP_STATUS status;
+	dsp_status status;
 	status = DSP_ENOTIMPL;
 	return status;
 }
 
 /*
- *  ======== PROC_Init ========
+ *  ======== proc_init ========
  *  Purpose:
  *      Initialize PROC's private state, keeping a reference count on each call
  */
-bool PROC_Init(void)
+bool proc_init(void)
 {
-	bool fRetval = true;
-
-	DBC_Require(cRefs >= 0);
+	bool ret = true;
 
-	if (cRefs == 0) {
-		/* Set the Trace mask */
-		DBC_Assert(!PROC_DebugMask.flags);
-		GT_create(&PROC_DebugMask, "PR");  /* "PR" for Processor */
+	DBC_REQUIRE(refs >= 0);
 
-		(void)SYNC_InitializeCS(&hProcLock);
-	}
+	if (refs == 0)
+		(void)sync_initialize_cs(&proc_lock);
 
-	if (fRetval)
-		cRefs++;
+	if (ret)
+		refs++;
 
-	GT_1trace(PROC_DebugMask, GT_5CLASS,
-		 "Entered PROC_Init, ref count:0x%x\n",	cRefs);
-	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	return fRetval;
+	return ret;
 }
 
 /*
- *  ======== PROC_Load ========
+ *  ======== proc_load ========
  *  Purpose:
  *      Reset a processor and load a new base program image.
  *      This will be an OEM-only function, and not part of the DSP/BIOS Bridge
  *      application developer's API.
  */
-DSP_STATUS PROC_Load(DSP_HPROCESSOR hProcessor, IN CONST s32 iArgc,
-		    IN CONST char **aArgv, IN CONST char **aEnvp)
+dsp_status proc_load(void *hprocessor, IN CONST s32 argc_index,
+		     IN CONST char **user_args, IN CONST char **user_envp)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	struct IO_MGR *hIOMgr;		/* IO manager handle */
-	struct MSG_MGR *hMsgMgr;
-	struct COD_MANAGER *hCodMgr;	/* Code manager handle */
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct io_mgr *hio_mgr;	/* IO manager handle */
+	struct msg_mgr *hmsg_mgr;
+	struct cod_manager *cod_mgr;	/* Code manager handle */
 	char *pargv0;		/* temp argv[0] ptr */
-	char **newEnvp;		/* Updated envp[] array. */
-	char szProcID[MAXPROCIDLEN];	/* Size of "PROC_ID=<n>" */
-	s32 cEnvp;		/* Num elements in envp[]. */
-	s32 cNewEnvp;		/* "  " in newEnvp[]     */
-	s32 nProcID = 0;	/* Anticipate MP version. */
-	struct DCD_MANAGER *hDCDHandle;
-	struct DMM_OBJECT *hDmmMgr;
-	u32 dwExtEnd;
-	u32 uProcId;
-#ifdef DEBUG
-	BRD_STATUS uBrdState;
-#endif
+	char **new_envp;	/* Updated envp[] array. */
+	char sz_proc_id[MAXPROCIDLEN];	/* Size of "PROC_ID=<n>" */
+	s32 envp_elems;		/* Num elements in envp[]. */
+	s32 cnew_envp;		/* "  " in new_envp[] */
+	s32 nproc_id = 0;	/* Anticipate MP version. */
+	struct dcd_manager *hdcd_handle;
+	struct dmm_object *dmm_mgr;
+	u32 dw_ext_end;
+	u32 proc_id;
+	int brd_state;
+
 #ifdef OPT_LOAD_TIME_INSTRUMENTATION
 	struct timeval tv1;
 	struct timeval tv2;
 #endif
-	DBC_Require(cRefs > 0);
-	DBC_Require(iArgc > 0);
-	DBC_Require(aArgv != NULL);
-#ifdef OPT_LOAD_TIME_INSTRUMENTATION
-	do_gettimeofday(&tv1);
-#endif
+
 #if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
 	struct dspbridge_platform_data *pdata =
-				omap_dspbridge_dev->dev.platform_data;
+	    omap_dspbridge_dev->dev.platform_data;
 #endif
-	GT_2trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Load, args:\n\t"
-		 "hProcessor:  0x%x\taArgv: 0x%x\n", hProcessor, aArgv[0]);
-	/* Call the WMD_BRD_Load Fxn */
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(argc_index > 0);
+	DBC_REQUIRE(user_args != NULL);
+
+#ifdef OPT_LOAD_TIME_INSTRUMENTATION
+	do_gettimeofday(&tv1);
+#endif
+	/* Call the WMD_BRD_Load fxn */
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_1CLASS,
-			 "PROC_Load: Invalid Processor Handle..\n");
 		goto func_end;
 	}
-	if (pProcObject->bIsAlreadyAttached) {
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Load GPP "
-			 "Client is already attached status  \n");
-	}
-	if (DSP_FAILED(DEV_GetCodMgr(pProcObject->hDevObject, &hCodMgr))) {
+	if (DSP_FAILED(dev_get_cod_mgr(p_proc_object->hdev_obj, &cod_mgr))) {
 		status = DSP_EFAIL;
-		GT_1trace(PROC_DebugMask, GT_7CLASS, "PROC_Load: DSP_FAILED in "
-			 "DEV_GetCodMgr status 0x%x \n", status);
 		goto func_end;
 	}
-	status = PROC_Stop(hProcessor);
-	if (DSP_FAILED(status)) {
-		GT_1trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Load: DSP_FAILED to Place the"
-			 " Processor in Stop Mode(PROC_STOP) status 0x%x \n",
-			 status);
+	status = proc_stop(hprocessor);
+	if (DSP_FAILED(status))
 		goto func_end;
-	}
+
 	/* Place the board in the monitor state. */
-	status = PROC_Monitor(hProcessor);
-	if (DSP_FAILED(status)) {
-		GT_1trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Load: DSP_FAILED to Place the"
-			 " Processor in Monitor Mode(PROC_IDLE) status 0x%x\n",
-			 status);
+	status = proc_monitor(hprocessor);
+	if (DSP_FAILED(status))
 		goto func_end;
-	}
+
 	/* Save ptr to  original argv[0]. */
-	pargv0 = (char *)aArgv[0];
-	/*Prepend "PROC_ID=<nProcID>"to envp array for target.*/
-	cEnvp = GetEnvpCount((char **)aEnvp);
-	cNewEnvp = (cEnvp ? (cEnvp + 1) : (cEnvp + 2));
-	newEnvp = MEM_Calloc(cNewEnvp * sizeof(char **), MEM_PAGED);
-	if (newEnvp) {
-		status = snprintf(szProcID, MAXPROCIDLEN, PROC_ENVPROCID,
-				    nProcID);
+	pargv0 = (char *)user_args[0];
+	/*Prepend "PROC_ID=<nproc_id>"to envp array for target. */
+	envp_elems = get_envp_count((char **)user_envp);
+	cnew_envp = (envp_elems ? (envp_elems + 1) : (envp_elems + 2));
+	new_envp = mem_calloc(cnew_envp * sizeof(char **), MEM_PAGED);
+	if (new_envp) {
+		status = snprintf(sz_proc_id, MAXPROCIDLEN, PROC_ENVPROCID,
+				  nproc_id);
 		if (status == -1) {
-			GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_Load: "
-				 "Proc ID string overflow \n");
+			dev_dbg(bridge, "%s: Proc ID string overflow\n",
+				__func__);
 			status = DSP_EFAIL;
 		} else {
-			newEnvp = PrependEnvp(newEnvp, (char **)aEnvp, cEnvp,
-					     cNewEnvp, szProcID);
+			new_envp =
+			    prepend_envp(new_envp, (char **)user_envp,
+					 envp_elems, cnew_envp, sz_proc_id);
 			/* Get the DCD Handle */
-			status = MGR_GetDCDHandle(pProcObject->hMgrObject,
-						 (u32 *)&hDCDHandle);
+			status = mgr_get_dcd_handle(p_proc_object->hmgr_obj,
+						    (u32 *) &hdcd_handle);
 			if (DSP_SUCCEEDED(status)) {
 				/*  Before proceeding with new load,
 				 *  check if a previously registered COFF
 				 *  exists.
 				 *  If yes, unregister nodes in previously
 				 *  registered COFF.  If any error occurred,
-				 *  set previously registered COFF to NULL.  */
-				if (pProcObject->g_pszLastCoff != NULL) {
-					status = DCD_AutoUnregister(hDCDHandle,
-						 pProcObject->g_pszLastCoff);
+				 *  set previously registered COFF to NULL. */
+				if (p_proc_object->psz_last_coff != NULL) {
+					status =
+					    dcd_auto_unregister(hdcd_handle,
+								p_proc_object->
+								psz_last_coff);
 					/* Regardless of auto unregister status,
 					 *  free previously allocated
-					 *  memory.  */
-					MEM_Free(pProcObject->g_pszLastCoff);
-					pProcObject->g_pszLastCoff = NULL;
+					 *  memory. */
+					kfree(p_proc_object->psz_last_coff);
+					p_proc_object->psz_last_coff = NULL;
 				}
 			}
-			/* On success, do COD_OpenBase() */
-			status = COD_OpenBase(hCodMgr, (char *)aArgv[0],
-					     COD_SYMB);
-			if (DSP_FAILED(status)) {
-				GT_1trace(PROC_DebugMask, GT_7CLASS,
-					 "PROC_Load: COD_OpenBase "
-					 "failed (0x%x)\n", status);
-			}
+			/* On success, do cod_open_base() */
+			status = cod_open_base(cod_mgr, (char *)user_args[0],
+					       COD_SYMB);
 		}
 	} else {
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 " PROC_Load:Out of Memory \n");
 		status = DSP_EMEMORY;
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Auto-register data base */
 		/* Get the DCD Handle */
-		status = MGR_GetDCDHandle(pProcObject->hMgrObject,
-					 (u32 *)&hDCDHandle);
+		status = mgr_get_dcd_handle(p_proc_object->hmgr_obj,
+					    (u32 *) &hdcd_handle);
 		if (DSP_SUCCEEDED(status)) {
 			/*  Auto register nodes in specified COFF
 			 *  file.  If registration did not fail,
 			 *  (status = DSP_SOK or DSP_EDCDNOAUTOREGISTER)
 			 *  save the name of the COFF file for
-			 *  de-registration in the future.  */
-			status = DCD_AutoRegister(hDCDHandle, (char *)aArgv[0]);
-			if (status == DSP_EDCDNOAUTOREGISTER) {
-				GT_0trace(PROC_DebugMask, GT_7CLASS,
-					  "PROC_Load: No Auto "
-					  "Register section.  Proceeding..\n");
+			 *  de-registration in the future. */
+			status =
+			    dcd_auto_register(hdcd_handle,
+					      (char *)user_args[0]);
+			if (status == DSP_EDCDNOAUTOREGISTER)
 				status = DSP_SOK;
-			}
+
 			if (DSP_FAILED(status)) {
 				status = DSP_EFAIL;
-				GT_0trace(PROC_DebugMask, GT_7CLASS,
-					  "PROC_Load: Failed to "
-					  "Auto Register..\n");
 			} else {
-				DBC_Assert(pProcObject->g_pszLastCoff == NULL);
+				DBC_ASSERT(p_proc_object->psz_last_coff ==
+					   NULL);
 				/* Allocate memory for pszLastCoff */
-				pProcObject->g_pszLastCoff = MEM_Calloc(
-                                       (strlen((char *)aArgv[0]) + 1),
-					MEM_PAGED);
-				/* If memory allocated, save COFF file name*/
-				if (pProcObject->g_pszLastCoff) {
-                                       strncpy(pProcObject->g_pszLastCoff,
-						(char *)aArgv[0],
-                                       (strlen((char *)aArgv[0]) + 1));
+				p_proc_object->psz_last_coff =
+				    mem_calloc((strlen((char *)user_args[0]) +
+						1), MEM_PAGED);
+				/* If memory allocated, save COFF file name */
+				if (p_proc_object->psz_last_coff) {
+					strncpy(p_proc_object->psz_last_coff,
+						(char *)user_args[0],
+						(strlen((char *)user_args[0]) +
+						 1));
 				}
 			}
 		}
@@ -1243,145 +942,108 @@
 	/* Update shared memory address and size */
 	if (DSP_SUCCEEDED(status)) {
 		/*  Create the message manager. This must be done
-		 *  before calling the IOOnLoaded function.  */
-		DEV_GetMsgMgr(pProcObject->hDevObject, &hMsgMgr);
-		if (!hMsgMgr) {
-			status = MSG_Create(&hMsgMgr, pProcObject->hDevObject,
-					   (MSG_ONEXIT)NODE_OnExit);
-			DBC_Assert(DSP_SUCCEEDED(status));
-			DEV_SetMsgMgr(pProcObject->hDevObject, hMsgMgr);
-		}
-		if (status == DSP_ENOTIMPL) {
-			/* It's OK not to have a message manager */
-			status = DSP_SOK;
+		 *  before calling the IOOnLoaded function. */
+		dev_get_msg_mgr(p_proc_object->hdev_obj, &hmsg_mgr);
+		if (!hmsg_mgr) {
+			status = msg_create(&hmsg_mgr, p_proc_object->hdev_obj,
+					    (msg_onexit) node_on_exit);
+			DBC_ASSERT(DSP_SUCCEEDED(status));
+			dev_set_msg_mgr(p_proc_object->hdev_obj, hmsg_mgr);
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Set the Device object's message manager */
-		status = DEV_GetIOMgr(pProcObject->hDevObject, &hIOMgr);
-		DBC_Assert(DSP_SUCCEEDED(status));
-		status = (*pProcObject->pIntfFxns->pfnIOOnLoaded)(hIOMgr);
-		if (status == DSP_ENOTIMPL) {
-			/* Ok not to implement this function */
-			status = DSP_SOK;
-		} else {
-			if (DSP_FAILED(status)) {
-				GT_1trace(PROC_DebugMask, GT_7CLASS,
-					  "PROC_Load: Failed to get shared "
-					  "memory or message buffer address "
-					  "from COFF status 0x%x\n", status);
-				status = DSP_EFAIL;
-			}
-		}
-	} else {
-		status = DSP_EFAIL;
-		GT_1trace(PROC_DebugMask, GT_7CLASS,
-			  "PROC_Load: DSP_FAILED in "
-			  "MSG_Create status 0x%x\n", status);
+		status = dev_get_io_mgr(p_proc_object->hdev_obj, &hio_mgr);
+		DBC_ASSERT(DSP_SUCCEEDED(status));
+		status =
+		    (*p_proc_object->intf_fxns->pfn_io_on_loaded) (hio_mgr);
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Now, attempt to load an exec: */
 
-	/* Boost the OPP level to Maximum level supported by baseport*/
+		/* Boost the OPP level to Maximum level supported by baseport */
 #if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
-	if (pdata->cpu_set_freq)
-		(*pdata->cpu_set_freq)(pdata->mpu_speed[VDD1_OPP5]);
+		if (pdata->cpu_set_freq)
+			(*pdata->cpu_set_freq) (pdata->mpu_max_speed);
 #endif
-		status = COD_LoadBase(hCodMgr, iArgc, (char **)aArgv,
-				     DEV_BrdWriteFxn,
-				     pProcObject->hDevObject, NULL);
+		status = cod_load_base(cod_mgr, argc_index, (char **)user_args,
+				       dev_brd_write_fxn,
+				       p_proc_object->hdev_obj, NULL);
 		if (DSP_FAILED(status)) {
 			if (status == COD_E_OPENFAILED) {
-				GT_0trace(PROC_DebugMask, GT_7CLASS,
-					"PROC_Load:Failure to Load the EXE\n");
+				dev_dbg(bridge, "%s: Failure to Load the EXE\n",
+					__func__);
 			}
 			if (status == COD_E_SYMBOLNOTFOUND) {
-				GT_0trace(PROC_DebugMask, GT_7CLASS,
-					"PROC_Load:Could not parse the file\n");
-			} else {
-				GT_1trace(PROC_DebugMask, GT_7CLASS,
-					 "PROC_Load: DSP_FAILED in "
-					 "COD_Load  status 0x%x \n", status);
+				pr_err("%s: Couldn't parse the file\n",
+				       __func__);
 			}
 		}
-	/* Requesting the lowest opp supported*/
+		/* Requesting the lowest opp supported */
 #if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
-	if (pdata->cpu_set_freq)
-		(*pdata->cpu_set_freq)(pdata->mpu_speed[VDD1_OPP1]);
+		if (pdata->cpu_set_freq)
+			(*pdata->cpu_set_freq) (pdata->mpu_min_speed);
 #endif
 
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Update the Processor status to loaded */
-		status = (*pProcObject->pIntfFxns->pfnBrdSetState)
-			 (pProcObject->hWmdContext, BRD_LOADED);
+		status = (*p_proc_object->intf_fxns->pfn_brd_set_state)
+		    (p_proc_object->hwmd_context, BRD_LOADED);
 		if (DSP_SUCCEEDED(status)) {
-			pProcObject->sState = PROC_LOADED;
-			if (pProcObject->hNtfy) {
-				PROC_NotifyClients(pProcObject,
-						 DSP_PROCESSORSTATECHANGE);
-			}
-		} else {
-			GT_1trace(PROC_DebugMask, GT_7CLASS,
-				 "PROC_Load, pfnBrdSetState "
-				 "failed: 0x%x\n", status);
-			status = DSP_EFAIL;
+			p_proc_object->proc_state = PROC_LOADED;
+			if (p_proc_object->ntfy_obj)
+				proc_notify_clients(p_proc_object,
+						    DSP_PROCESSORSTATECHANGE);
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
-		status = PROC_GetProcessorId(hProcessor, &uProcId);
-		if (uProcId == DSP_UNIT) {
+		status = proc_get_processor_id(hprocessor, &proc_id);
+		if (proc_id == DSP_UNIT) {
 			/* Use all available DSP address space after EXTMEM
 			 * for DMM */
+			if (DSP_SUCCEEDED(status))
+				status = cod_get_sym_value(cod_mgr, EXTEND,
+							   &dw_ext_end);
+
+			/* Reset DMM structs and add an initial free chunk */
 			if (DSP_SUCCEEDED(status)) {
-				status = COD_GetSymValue(hCodMgr, EXTEND,
-								&dwExtEnd);
-				if (DSP_FAILED(status)) {
-					GT_1trace(PROC_DebugMask, GT_7CLASS,
-						 "PROC_Load: Failed on "
-						 "COD_GetSymValue %s.\n",
-						 EXTEND);
-				}
-			}
-			/* Reset DMM structs and add an initial free chunk*/
-			if (DSP_SUCCEEDED(status)) {
-				status = DEV_GetDmmMgr(pProcObject->hDevObject,
-						      &hDmmMgr);
+				status =
+				    dev_get_dmm_mgr(p_proc_object->hdev_obj,
+						    &dmm_mgr);
 				if (DSP_SUCCEEDED(status)) {
-					/* Set dwExtEnd to DMM START u8
-					  * address */
-					dwExtEnd = (dwExtEnd + 1) * DSPWORDSIZE;
-					 /* DMM memory is from EXT_END */
-					status = DMM_CreateTables(hDmmMgr,
-						dwExtEnd, DMMPOOLSIZE);
+					/* Set dw_ext_end to DMM START u8
+					 * address */
+					dw_ext_end =
+					    (dw_ext_end + 1) * DSPWORDSIZE;
+					/* DMM memory is from EXT_END */
+					status = dmm_create_tables(dmm_mgr,
+								   dw_ext_end,
+								   DMMPOOLSIZE);
 				}
 			}
 		}
 	}
 	/* Restore the original argv[0] */
-	MEM_Free(newEnvp);
-	aArgv[0] = pargv0;
-#ifdef DEBUG
+	kfree(new_envp);
+	user_args[0] = pargv0;
 	if (DSP_SUCCEEDED(status)) {
-		if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
-		   (pProcObject->hWmdContext, &uBrdState))) {
-			GT_0trace(PROC_DebugMask, GT_1CLASS,
-				 "PROC_Load: Processor Loaded\n");
-			DBC_Assert(uBrdState == BRD_LOADED);
+		if (DSP_SUCCEEDED((*p_proc_object->intf_fxns->pfn_brd_status)
+				  (p_proc_object->hwmd_context, &brd_state))) {
+			pr_debug("%s: Processor Loaded %s\n", __func__, pargv0);
+			reg_set_value(DEFEXEC, (u8 *)pargv0,
+							strlen(pargv0) + 1);
+			DBC_ASSERT(brd_state == BRD_LOADED);
 		}
 	}
-#endif
+
 func_end:
-#ifdef DEBUG
 	if (DSP_FAILED(status)) {
-		GT_0trace(PROC_DebugMask, GT_1CLASS, "PROC_Load: "
-			 "Processor Load Failed.\n");
-
+		pr_err("%s: Processor failed to load\n", __func__);
+		proc_stop(p_proc_object);
 	}
-#endif
-	GT_1trace(PROC_DebugMask, GT_ENTER,
-		 "Exiting PROC_Load, status:  0x%x\n", status);
-	DBC_Ensure((DSP_SUCCEEDED(status) && pProcObject->sState == PROC_LOADED)
+	DBC_ENSURE((DSP_SUCCEEDED(status)
+		    && p_proc_object->proc_state == PROC_LOADED)
 		   || DSP_FAILED(status));
 #ifdef OPT_LOAD_TIME_INSTRUMENTATION
 	do_gettimeofday(&tv2);
@@ -1389,170 +1051,169 @@
 		tv2.tv_usec += 1000000;
 		tv2.tv_sec--;
 	}
-	GT_2trace(PROC_DebugMask, GT_1CLASS,
-			"Proc_Load: time to load %d sec and %d usec \n",
-		    tv2.tv_sec - tv1.tv_sec, tv2.tv_usec - tv1.tv_usec);
+	dev_dbg(bridge, "%s: time to load %d sec and %d usec\n", __func__,
+		tv2.tv_sec - tv1.tv_sec, tv2.tv_usec - tv1.tv_usec);
 #endif
 	return status;
 }
 
 /*
- *  ======== PROC_Map ========
+ *  ======== proc_map ========
  *  Purpose:
  *      Maps a MPU buffer to DSP address space.
  */
-DSP_STATUS PROC_Map(DSP_HPROCESSOR hProcessor, void *pMpuAddr, u32 ulSize,
-		   void *pReqAddr, void **ppMapAddr, u32 ulMapAttr,
-		   struct PROCESS_CONTEXT *pr_ctxt)
-{
-	u32 vaAlign;
-	u32 paAlign;
-	struct DMM_OBJECT *hDmmMgr;
-	u32 sizeAlign;
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-
-#ifndef RES_CLEANUP_DISABLE
-       HANDLE        dmmRes;
+dsp_status proc_map(void *hprocessor, void *pmpu_addr, u32 ul_size,
+		    void *req_addr, void **pp_map_addr, u32 ul_map_attr,
+		    struct process_context *pr_ctxt)
+{
+	u32 va_align;
+	u32 pa_align;
+	struct dmm_object *dmm_mgr;
+	u32 size_align;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct dmm_map_object *map_obj;
+
+#ifdef CONFIG_BRIDGE_CACHE_LINE_CHECK
+	if ((ul_map_attr & BUFMODE_MASK) != RBUF) {
+		if (!IS_ALIGNED((u32)pmpu_addr, DSP_CACHE_LINE) ||
+		    !IS_ALIGNED(ul_size, DSP_CACHE_LINE)) {
+			pr_err("%s: not aligned: 0x%x (%d)\n", __func__,
+						(u32)pmpu_addr, ul_size);
+			return -EFAULT;
+		}
+	}
 #endif
 
-	GT_6trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Map, args:\n\t"
-		 "hProcessor %x, pMpuAddr %x, ulSize %x, pReqAddr %x, "
-		 "ulMapAttr %x, ppMapAddr %x\n", hProcessor, pMpuAddr, ulSize,
-		 pReqAddr, ulMapAttr, ppMapAddr);
 	/* Calculate the page-aligned PA, VA and size */
-	vaAlign = PG_ALIGN_LOW((u32) pReqAddr, PG_SIZE_4K);
-	paAlign = PG_ALIGN_LOW((u32) pMpuAddr, PG_SIZE_4K);
-	sizeAlign = PG_ALIGN_HIGH(ulSize + (u32)pMpuAddr - paAlign,
-				 PG_SIZE_4K);
-
-	GT_3trace(PROC_DebugMask, GT_ENTER, "PROC_Map: vaAlign %x, paAlign %x, "
-		 "sizeAlign %x\n", vaAlign, paAlign, sizeAlign);
+	va_align = PG_ALIGN_LOW((u32) req_addr, PG_SIZE4K);
+	pa_align = PG_ALIGN_LOW((u32) pmpu_addr, PG_SIZE4K);
+	size_align = PG_ALIGN_HIGH(ul_size + (u32) pmpu_addr - pa_align,
+				   PG_SIZE4K);
 
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_Map: "
-			 "InValid Processor Handle \n");
 		goto func_end;
 	}
 	/* Critical section */
-	(void)SYNC_EnterCS(hProcLock);
-	status = DMM_GetHandle(pProcObject, &hDmmMgr);
-	if (DSP_FAILED(status)) {
-		GT_1trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Map: Failed to get DMM Mgr "
-			 "handle: 0x%x\n", status);
-	} else {
-		status = DMM_MapMemory(hDmmMgr, vaAlign, sizeAlign);
-	}
+	(void)sync_enter_cs(proc_lock);
+	status = dmm_get_handle(p_proc_object, &dmm_mgr);
+	if (DSP_SUCCEEDED(status))
+		status = dmm_map_memory(dmm_mgr, va_align, size_align);
+
 	/* Add mapping to the page tables. */
 	if (DSP_SUCCEEDED(status)) {
 
-		status = (*pProcObject->pIntfFxns->pfnBrdMemMap)
-			(pProcObject->hWmdContext, paAlign, vaAlign, sizeAlign,
-			ulMapAttr);
+		status = (*p_proc_object->intf_fxns->pfn_brd_mem_map)
+		    (p_proc_object->hwmd_context, pa_align, va_align,
+		     size_align, ul_map_attr);
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Mapped address = MSB of VA | LSB of PA */
-		*ppMapAddr = (void *) (vaAlign | ((u32) pMpuAddr &
-			     (PG_SIZE_4K - 1)));
+		*pp_map_addr = (void *)(va_align | ((u32) pmpu_addr &
+						    (PG_SIZE4K - 1)));
 	} else {
-		DMM_UnMapMemory(hDmmMgr, vaAlign, &sizeAlign);
+		dmm_un_map_memory(dmm_mgr, va_align, &size_align);
 	}
-	(void)SYNC_LeaveCS(hProcLock);
+	(void)sync_leave_cs(proc_lock);
 
-#ifndef RES_CLEANUP_DISABLE
-	if (DSP_SUCCEEDED(status)) {
-		spin_lock(&pr_ctxt->dmm_list_lock);
-
-		DRV_InsertDMMResElement(&dmmRes, pr_ctxt);
-		DRV_UpdateDMMResElement(dmmRes, (u32)pMpuAddr, ulSize,
-				(u32)pReqAddr, (u32)*ppMapAddr, hProcessor);
+	if (DSP_FAILED(status))
+		goto func_end;
 
-		spin_unlock(&pr_ctxt->dmm_list_lock);
+	/*
+	 * A successful map should be followed by insertion of map_obj
+	 * into dmm_map_list, so that mapped memory resource tracking
+	 * remains uptodate
+	 */
+	map_obj = kmalloc(sizeof(struct dmm_map_object), GFP_KERNEL);
+	if (map_obj) {
+		map_obj->dsp_addr = (u32) *pp_map_addr;
+		spin_lock(&pr_ctxt->dmm_map_lock);
+		list_add(&map_obj->link, &pr_ctxt->dmm_map_list);
+		spin_unlock(&pr_ctxt->dmm_map_lock);
 	}
-#endif
+
 func_end:
-	GT_1trace(PROC_DebugMask, GT_ENTER, "Leaving PROC_Map [0x%x]", status);
+	dev_dbg(bridge, "%s: hprocessor %p, pmpu_addr %p, ul_size %x, "
+		"req_addr %p, ul_map_attr %x, pp_map_addr %p, va_align %x, "
+		"pa_align %x, size_align %x status 0x%x\n", __func__,
+		hprocessor, pmpu_addr, ul_size, req_addr, ul_map_attr,
+		pp_map_addr, va_align, pa_align, size_align, status);
+
 	return status;
 }
 
 /*
- *  ======== PROC_RegisterNotify ========
+ *  ======== proc_register_notify ========
  *  Purpose:
  *      Register to be notified of specific processor events.
  */
-DSP_STATUS PROC_RegisterNotify(DSP_HPROCESSOR hProcessor, u32 uEventMask,
-			      u32 uNotifyType, struct DSP_NOTIFICATION
-			      *hNotification)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	struct DEH_MGR *hDehMgr;
-
-	DBC_Require(hNotification != NULL);
-	DBC_Require(cRefs > 0);
-
-	GT_4trace(PROC_DebugMask, GT_ENTER,
-		 "Entered PROC_RegisterNotify, args:\n\t"
-		 "hProcessor:  0x%x\n\tuEventMask:  0x%x\n\tuNotifyMask:"
-		 " 0x%x\n\t hNotification 0x%x\n", hProcessor, uEventMask,
-		 uNotifyType, hNotification);
+dsp_status proc_register_notify(void *hprocessor, u32 event_mask,
+				u32 notify_type, struct dsp_notification
+				* hnotification)
+{
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct deh_mgr *hdeh_mgr;
+
+	DBC_REQUIRE(hnotification != NULL);
+	DBC_REQUIRE(refs > 0);
 
 	/* Check processor handle */
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
-		GT_1trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_RegsiterNotify Invalid "
-			 "ProcessorHandle 0x%x\n", hProcessor);
 		goto func_end;
 	}
 	/* Check if event mask is a valid processor related event */
-	if (uEventMask & ~(DSP_PROCESSORSTATECHANGE | DSP_PROCESSORATTACH |
-	   DSP_PROCESSORDETACH | DSP_PROCESSORRESTART | DSP_MMUFAULT |
-	   DSP_SYSERROR | DSP_PWRERROR))
+	if (event_mask & ~(DSP_PROCESSORSTATECHANGE | DSP_PROCESSORATTACH |
+			DSP_PROCESSORDETACH | DSP_PROCESSORRESTART |
+			DSP_MMUFAULT | DSP_SYSERROR | DSP_PWRERROR |
+			DSP_WDTOVERFLOW))
+
 		status = DSP_EVALUE;
 
 	/* Check if notify type is valid */
-	if (uNotifyType != DSP_SIGNALEVENT)
+	if (notify_type != DSP_SIGNALEVENT)
 		status = DSP_EVALUE;
 
 	if (DSP_SUCCEEDED(status)) {
 		/* If event mask is not DSP_SYSERROR, DSP_MMUFAULT,
 		 * or DSP_PWRERROR then register event immediately. */
-		if (uEventMask &
-		    ~(DSP_SYSERROR | DSP_MMUFAULT | DSP_PWRERROR)) {
-			status = NTFY_Register(pProcObject->hNtfy,
-				 hNotification,	uEventMask, uNotifyType);
+		if (event_mask &
+		    ~(DSP_SYSERROR | DSP_MMUFAULT | DSP_PWRERROR |
+				DSP_WDTOVERFLOW)) {
+			status = ntfy_register(p_proc_object->ntfy_obj,
+					       hnotification, event_mask,
+					       notify_type);
 			/* Special case alert, special case alert!
-			 * If we're trying to *deregister* (i.e. uEventMask
+			 * If we're trying to *deregister* (i.e. event_mask
 			 * is 0), a DSP_SYSERROR or DSP_MMUFAULT notification,
 			 * we have to deregister with the DEH manager.
-			 * There's no way to know, based on uEventMask which
+			 * There's no way to know, based on event_mask which
 			 * manager the notification event was registered with,
-			 * so if we're trying to deregister and NTFY_Register
+			 * so if we're trying to deregister and ntfy_register
 			 * failed, we'll give the deh manager a shot.
 			 */
-			if ((uEventMask == 0) && DSP_FAILED(status)) {
-				status = DEV_GetDehMgr(pProcObject->hDevObject,
-					 &hDehMgr);
-				DBC_Assert(pProcObject->pIntfFxns->
-					   pfnDehRegisterNotify);
-				status = (*pProcObject->pIntfFxns->
-					 pfnDehRegisterNotify)
-					 (hDehMgr, uEventMask, uNotifyType,
-					 hNotification);
+			if ((event_mask == 0) && DSP_FAILED(status)) {
+				status =
+				    dev_get_deh_mgr(p_proc_object->hdev_obj,
+						    &hdeh_mgr);
+				DBC_ASSERT(p_proc_object->
+					   intf_fxns->pfn_deh_register_notify);
+				status =
+				    (*p_proc_object->
+				     intf_fxns->pfn_deh_register_notify)
+				    (hdeh_mgr, event_mask, notify_type,
+				     hnotification);
 			}
 		} else {
-			status = DEV_GetDehMgr(pProcObject->hDevObject,
-					      &hDehMgr);
-			DBC_Assert(pProcObject->pIntfFxns->
-				  pfnDehRegisterNotify);
-			status = (*pProcObject->pIntfFxns->pfnDehRegisterNotify)
-				 (hDehMgr, uEventMask, uNotifyType,
-				 hNotification);
-			if (DSP_FAILED(status))
-				status = DSP_EFAIL;
+			status = dev_get_deh_mgr(p_proc_object->hdev_obj,
+						 &hdeh_mgr);
+			DBC_ASSERT(p_proc_object->
+				   intf_fxns->pfn_deh_register_notify);
+			status =
+			    (*p_proc_object->intf_fxns->pfn_deh_register_notify)
+			    (hdeh_mgr, event_mask, notify_type, hnotification);
 
 		}
 	}
@@ -1561,339 +1222,312 @@
 }
 
 /*
- *  ======== PROC_ReserveMemory ========
+ *  ======== proc_reserve_memory ========
  *  Purpose:
  *      Reserve a virtually contiguous region of DSP address space.
  */
-DSP_STATUS PROC_ReserveMemory(DSP_HPROCESSOR hProcessor, u32 ulSize,
-			     void **ppRsvAddr)
-{
-	struct DMM_OBJECT *hDmmMgr;
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-
-	GT_3trace(PROC_DebugMask, GT_ENTER,
-		 "Entered PROC_ReserveMemory, args:\n\t"
-		 "hProcessor: 0x%x ulSize: 0x%x ppRsvAddr: 0x%x\n", hProcessor,
-		 ulSize, ppRsvAddr);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+dsp_status proc_reserve_memory(void *hprocessor, u32 ul_size,
+			       void **pp_rsv_addr,
+			       struct process_context *pr_ctxt)
+{
+	struct dmm_object *dmm_mgr;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct dmm_rsv_object *rsv_obj;
+
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_Map: "
-			 "InValid Processor Handle \n");
 		goto func_end;
 	}
-	status = DMM_GetHandle(pProcObject, &hDmmMgr);
-	if (DSP_FAILED(status)) {
-		GT_1trace(PROC_DebugMask, GT_7CLASS, "PROC_ReserveMemory: "
-			 "Failed to get DMM Mgr handle: 0x%x\n", status);
-	} else
-		status = DMM_ReserveMemory(hDmmMgr, ulSize, (u32 *)ppRsvAddr);
 
-	GT_1trace(PROC_DebugMask, GT_ENTER, "Leaving PROC_ReserveMemory [0x%x]",
-		 status);
+	status = dmm_get_handle(p_proc_object, &dmm_mgr);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	status = dmm_reserve_memory(dmm_mgr, ul_size, (u32 *) pp_rsv_addr);
+	if (status != DSP_SOK)
+		goto func_end;
+
+	/*
+	 * A successful reserve should be followed by insertion of rsv_obj
+	 * into dmm_rsv_list, so that reserved memory resource tracking
+	 * remains uptodate
+	 */
+	rsv_obj = kmalloc(sizeof(struct dmm_rsv_object), GFP_KERNEL);
+	if (rsv_obj) {
+		rsv_obj->dsp_reserved_addr = (u32) *pp_rsv_addr;
+		spin_lock(&pr_ctxt->dmm_rsv_lock);
+		list_add(&rsv_obj->link, &pr_ctxt->dmm_rsv_list);
+		spin_unlock(&pr_ctxt->dmm_rsv_lock);
+	}
+
 func_end:
+	dev_dbg(bridge, "%s: hprocessor: 0x%p ul_size: 0x%x pp_rsv_addr: 0x%p "
+		"status 0x%x\n", __func__, hprocessor,
+		ul_size, pp_rsv_addr, status);
 	return status;
 }
 
 /*
- *  ======== PROC_Start ========
+ *  ======== proc_start ========
  *  Purpose:
  *      Start a processor running.
  */
-DSP_STATUS PROC_Start(DSP_HPROCESSOR hProcessor)
+dsp_status proc_start(void *hprocessor)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	struct COD_MANAGER *hCodMgr;	/* Code manager handle    */
-	u32 dwDspAddr;	/* Loaded code's entry point.    */
-#ifdef DEBUG
-	BRD_STATUS uBrdState;
-#endif
-	DBC_Require(cRefs > 0);
-	GT_1trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Start, args:\n\t"
-		 "hProcessor:  0x%x\n", hProcessor);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct cod_manager *cod_mgr;	/* Code manager handle */
+	u32 dw_dsp_addr;	/* Loaded code's entry point. */
+	int brd_state;
+
+	DBC_REQUIRE(refs > 0);
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Start :InValid Handle \n");
 		goto func_end;
 	}
-	/* Call the WMD_BRD_Start */
-	if (pProcObject->sState != PROC_LOADED) {
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Start :Wrong state \n");
+	/* Call the bridge_brd_start */
+	if (p_proc_object->proc_state != PROC_LOADED) {
 		status = DSP_EWRONGSTATE;
 		goto func_end;
 	}
-	status = DEV_GetCodMgr(pProcObject->hDevObject, &hCodMgr);
-	if (DSP_FAILED(status)) {
-		status = DSP_EFAIL;
-		GT_1trace(PROC_DebugMask, GT_7CLASS,
-			 "Processor Start DSP_FAILED "
-			 "in Getting DEV_GetCodMgr status 0x%x\n", status);
+	status = dev_get_cod_mgr(p_proc_object->hdev_obj, &cod_mgr);
+	if (DSP_FAILED(status))
 		goto func_cont;
-	}
-	status = COD_GetEntry(hCodMgr, &dwDspAddr);
-	if (DSP_FAILED(status)) {
-		status = DSP_EFAIL;
-		GT_1trace(PROC_DebugMask, GT_7CLASS,
-			 "Processor Start  DSP_FAILED in "
-			 "Getting COD_GetEntry status 0x%x\n", status);
+
+	status = cod_get_entry(cod_mgr, &dw_dsp_addr);
+	if (DSP_FAILED(status))
 		goto func_cont;
-	}
-	status = (*pProcObject->pIntfFxns->pfnBrdStart)
-		 (pProcObject->hWmdContext, dwDspAddr);
-	if (DSP_FAILED(status)) {
-		status = DSP_EFAIL;
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Start Failed to Start the board\n");
+
+	status = (*p_proc_object->intf_fxns->pfn_brd_start)
+	    (p_proc_object->hwmd_context, dw_dsp_addr);
+	if (DSP_FAILED(status))
 		goto func_cont;
-	}
-	/* Call DEV_Create2 */
-	status = DEV_Create2(pProcObject->hDevObject);
+
+	/* Call dev_create2 */
+	status = dev_create2(p_proc_object->hdev_obj);
 	if (DSP_SUCCEEDED(status)) {
-		pProcObject->sState = PROC_RUNNING;
+		p_proc_object->proc_state = PROC_RUNNING;
 		/* Deep sleep switces off the peripheral clocks.
 		 * we just put the DSP CPU in idle in the idle loop.
 		 * so there is no need to send a command to DSP */
 
-		if (pProcObject->hNtfy) {
-			PROC_NotifyClients(pProcObject,
-					  DSP_PROCESSORSTATECHANGE);
+		if (p_proc_object->ntfy_obj) {
+			proc_notify_clients(p_proc_object,
+					    DSP_PROCESSORSTATECHANGE);
 		}
-		GT_0trace(PROC_DebugMask, GT_1CLASS, "PROC_Start: Processor "
-			 "Started and running \n");
 	} else {
 		/* Failed to Create Node Manager and DISP Object
 		 * Stop the Processor from running. Put it in STOPPED State */
-		(void)(*pProcObject->pIntfFxns->pfnBrdStop)(pProcObject->
-			hWmdContext);
-		status = DSP_EFAIL;
-		pProcObject->sState = PROC_STOPPED;
-		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_Start "
-			 "Failed to Create the Node Manager\n");
+		(void)(*p_proc_object->intf_fxns->
+		       pfn_brd_stop) (p_proc_object->hwmd_context);
+		p_proc_object->proc_state = PROC_STOPPED;
 	}
 func_cont:
-#ifdef DEBUG
 	if (DSP_SUCCEEDED(status)) {
-		if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
-		   (pProcObject->hWmdContext, &uBrdState))) {
-			GT_0trace(PROC_DebugMask, GT_1CLASS,
-				 "PROC_Start: Processor State is RUNNING \n");
-			DBC_Assert(uBrdState != BRD_HIBERNATION);
+		if (DSP_SUCCEEDED((*p_proc_object->intf_fxns->pfn_brd_status)
+				  (p_proc_object->hwmd_context, &brd_state))) {
+			pr_debug("%s: dsp in running state\n", __func__);
+			DBC_ASSERT(brd_state != BRD_HIBERNATION);
 		}
+	} else {
+		pr_err("%s: Failed to start the dsp\n", __func__);
+		proc_stop(p_proc_object);
 	}
-#endif
+
 func_end:
-	GT_1trace(PROC_DebugMask, GT_ENTER,
-		 "Exiting PROC_Start, status  0x%x\n", status);
-	DBC_Ensure((DSP_SUCCEEDED(status) && pProcObject->sState ==
-		  PROC_RUNNING)	|| DSP_FAILED(status));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && p_proc_object->proc_state ==
+		    PROC_RUNNING) || DSP_FAILED(status));
 	return status;
 }
 
 /*
- *  ======== PROC_Stop ========
+ *  ======== proc_stop ========
  *  Purpose:
  *      Stop a processor running.
  */
-DSP_STATUS PROC_Stop(DSP_HPROCESSOR hProcessor)
+dsp_status proc_stop(void *hprocessor)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	struct MSG_MGR *hMsgMgr;
-	struct NODE_MGR *hNodeMgr;
-	DSP_HNODE hNode;
-	u32 uNodeTabSize = 1;
-	u32 uNumNodes = 0;
-	u32 uNodesAllocated = 0;
-	BRD_STATUS uBrdState;
-
-	DBC_Require(cRefs > 0);
-	GT_1trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Stop, args:\n\t"
-		 "hProcessor:  0x%x\n", hProcessor);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct msg_mgr *hmsg_mgr;
+	struct node_mgr *hnode_mgr;
+	void *hnode;
+	u32 node_tab_size = 1;
+	u32 num_nodes = 0;
+	u32 nodes_allocated = 0;
+	int brd_state;
+
+	DBC_REQUIRE(refs > 0);
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Stop :InValid Handle \n");
 		goto func_end;
 	}
-	if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
-	   (pProcObject->hWmdContext, &uBrdState))) {
-		/* Clean up all the resources except the current running
-		 * process resources */
-		if (uBrdState == BRD_ERROR)
-			PROC_CleanupAllResources();
+	if (DSP_SUCCEEDED((*p_proc_object->intf_fxns->pfn_brd_status)
+			  (p_proc_object->hwmd_context, &brd_state))) {
+		if (brd_state == BRD_ERROR)
+			bridge_deh_release_dummy_mem();
 	}
 	/* check if there are any running nodes */
-	status = DEV_GetNodeManager(pProcObject->hDevObject, &hNodeMgr);
-	if (DSP_SUCCEEDED(status) && hNodeMgr) {
-		status = NODE_EnumNodes(hNodeMgr, &hNode, uNodeTabSize,
-					&uNumNodes, &uNodesAllocated);
-		if ((status == DSP_ESIZE) || (uNodesAllocated > 0)) {
-			GT_1trace(PROC_DebugMask, GT_7CLASS,
-				 "Can't stop device, Active "
-				 "nodes = 0x%x \n", uNodesAllocated);
+	status = dev_get_node_manager(p_proc_object->hdev_obj, &hnode_mgr);
+	if (DSP_SUCCEEDED(status) && hnode_mgr) {
+		status = node_enum_nodes(hnode_mgr, &hnode, node_tab_size,
+					 &num_nodes, &nodes_allocated);
+		if ((status == DSP_ESIZE) || (nodes_allocated > 0)) {
+			pr_err("%s: Can't stop device, active nodes = %d \n",
+			       __func__, nodes_allocated);
 			return DSP_EWRONGSTATE;
 		}
 	}
-	/* Call the WMD_BRD_Stop */
+	/* Call the bridge_brd_stop */
 	/* It is OK to stop a device that does n't have nodes OR not started */
-	status = (*pProcObject->pIntfFxns->pfnBrdStop)(pProcObject->
-		 hWmdContext);
+	status =
+	    (*p_proc_object->intf_fxns->
+	     pfn_brd_stop) (p_proc_object->hwmd_context);
 	if (DSP_SUCCEEDED(status)) {
-		GT_0trace(PROC_DebugMask, GT_1CLASS,
-			 "PROC_Stop: Processor Stopped, "
-			 "i.e in standby mode \n");
-		pProcObject->sState = PROC_STOPPED;
-		/* Destory the Node Manager, MSG Manager */
-		if (DSP_SUCCEEDED(DEV_Destroy2(pProcObject->hDevObject))) {
-			/* Destroy the MSG by calling MSG_Delete */
-			DEV_GetMsgMgr(pProcObject->hDevObject, &hMsgMgr);
-			if (hMsgMgr) {
-				MSG_Delete(hMsgMgr);
-				DEV_SetMsgMgr(pProcObject->hDevObject, NULL);
-			}
-#ifdef DEBUG
-			if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->
-			   pfnBrdStatus)(pProcObject->hWmdContext,
-			   &uBrdState))) {
-				GT_0trace(PROC_DebugMask, GT_1CLASS,
-					 "PROC_Monitor:Processor Stopped \n");
-				DBC_Assert(uBrdState == BRD_STOPPED);
+		dev_dbg(bridge, "%s: processor in standby mode\n", __func__);
+		p_proc_object->proc_state = PROC_STOPPED;
+		/* Destory the Node Manager, msg_ctrl Manager */
+		if (DSP_SUCCEEDED(dev_destroy2(p_proc_object->hdev_obj))) {
+			/* Destroy the msg_ctrl by calling msg_delete */
+			dev_get_msg_mgr(p_proc_object->hdev_obj, &hmsg_mgr);
+			if (hmsg_mgr) {
+				msg_delete(hmsg_mgr);
+				dev_set_msg_mgr(p_proc_object->hdev_obj, NULL);
 			}
-#endif
-		} else {
-			GT_0trace(PROC_DebugMask, GT_7CLASS,
-				 "PROC_Stop Couldn't delete node manager \n");
+			if (DSP_SUCCEEDED
+			    ((*p_proc_object->
+			      intf_fxns->pfn_brd_status) (p_proc_object->
+							  hwmd_context,
+							  &brd_state)))
+				DBC_ASSERT(brd_state == BRD_STOPPED);
 		}
 	} else {
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Stop Failed to Stop the processor/device \n");
+		pr_err("%s: Failed to stop the processor\n", __func__);
 	}
 func_end:
-	GT_1trace(PROC_DebugMask, GT_ENTER, "Exiting PROC_Stop, status  0x%x\n",
-		 status);
 
 	return status;
 }
 
 /*
- *  ======== PROC_UnMap ========
+ *  ======== proc_un_map ========
  *  Purpose:
  *      Removes a MPU buffer mapping from the DSP address space.
  */
-DSP_STATUS PROC_UnMap(DSP_HPROCESSOR hProcessor, void *pMapAddr,
-		struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status proc_un_map(void *hprocessor, void *map_addr,
+		       struct process_context *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	struct DMM_OBJECT *hDmmMgr;
-	u32 vaAlign;
-	u32 sizeAlign;
-#ifndef RES_CLEANUP_DISABLE
-	HANDLE	      dmmRes;
-#endif
-	GT_2trace(PROC_DebugMask, GT_ENTER,
-		 "Entered PROC_UnMap, args:\n\thProcessor:"
-		 "0x%x pMapAddr: 0x%x\n", hProcessor, pMapAddr);
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct dmm_object *dmm_mgr;
+	u32 va_align;
+	u32 size_align;
+	struct dmm_map_object *map_obj;
 
-	vaAlign = PG_ALIGN_LOW((u32) pMapAddr, PG_SIZE_4K);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	va_align = PG_ALIGN_LOW((u32) map_addr, PG_SIZE4K);
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_UnMap: "
-			 "InValid Processor Handle \n");
 		goto func_end;
 	}
 
-	status = DMM_GetHandle(hProcessor, &hDmmMgr);
+	status = dmm_get_handle(hprocessor, &dmm_mgr);
 	if (DSP_FAILED(status))
 		goto func_end;
+
 	/* Critical section */
-	(void)SYNC_EnterCS(hProcLock);
-	if (DSP_FAILED(status)) {
-		GT_1trace(PROC_DebugMask, GT_7CLASS, "PROC_UnMap: "
-			 "Failed to get DMM Mgr handle: 0x%x\n", status);
-	} else {
-		/* Update DMM structures. Get the size to unmap.
-		 This function returns error if the VA is not mapped */
-		status = DMM_UnMapMemory(hDmmMgr, (u32) vaAlign, &sizeAlign);
-	}
+	(void)sync_enter_cs(proc_lock);
+	/*
+	 * Update DMM structures. Get the size to unmap.
+	 * This function returns error if the VA is not mapped
+	 */
+	status = dmm_un_map_memory(dmm_mgr, (u32) va_align, &size_align);
 	/* Remove mapping from the page tables. */
 	if (DSP_SUCCEEDED(status)) {
-		status = (*pProcObject->pIntfFxns->pfnBrdMemUnMap)
-			 (pProcObject->hWmdContext, vaAlign, sizeAlign);
+		status = (*p_proc_object->intf_fxns->pfn_brd_mem_un_map)
+		    (p_proc_object->hwmd_context, va_align, size_align);
 	}
-	(void)SYNC_LeaveCS(hProcLock);
-#ifndef RES_CLEANUP_DISABLE
-	GT_1trace(PROC_DebugMask, GT_ENTER,
-		   "PROC_UnMap DRV_GetDMMResElement "
-		   "pMapAddr:[0x%x]", pMapAddr);
+	(void)sync_leave_cs(proc_lock);
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	if (pr_ctxt) {
-		DSP_STATUS rc;
-
-		spin_lock(&pr_ctxt->dmm_list_lock);
-
-		rc = DRV_GetDMMResElement((u32)pMapAddr, &dmmRes, pr_ctxt);
-		if (rc != DSP_ENOTFOUND)
-			DRV_RemoveDMMResElement(dmmRes, pr_ctxt);
-
-		spin_unlock(&pr_ctxt->dmm_list_lock);
+	/*
+	 * A successful unmap should be followed by removal of map_obj
+	 * from dmm_map_list, so that mapped memory resource tracking
+	 * remains uptodate
+	 */
+	spin_lock(&pr_ctxt->dmm_map_lock);
+	list_for_each_entry(map_obj, &pr_ctxt->dmm_map_list, link) {
+		if (map_obj->dsp_addr == (u32) map_addr) {
+			list_del(&map_obj->link);
+			kfree(map_obj);
+			break;
+		}
 	}
-#endif
+	spin_unlock(&pr_ctxt->dmm_map_lock);
+
 func_end:
-	GT_1trace(PROC_DebugMask, GT_ENTER,
-		 "Leaving PROC_UnMap [0x%x]", status);
+	dev_dbg(bridge, "%s: hprocessor: 0x%p map_addr: 0x%p status: 0x%x\n",
+		__func__, hprocessor, map_addr, status);
 	return status;
 }
 
 /*
- *  ======== PROC_UnReserveMemory ========
+ *  ======== proc_un_reserve_memory ========
  *  Purpose:
  *      Frees a previously reserved region of DSP address space.
  */
-DSP_STATUS PROC_UnReserveMemory(DSP_HPROCESSOR hProcessor, void *pRsvAddr)
+dsp_status proc_un_reserve_memory(void *hprocessor, void *prsv_addr,
+				  struct process_context *pr_ctxt)
 {
-	struct DMM_OBJECT *hDmmMgr;
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-
-	GT_2trace(PROC_DebugMask, GT_ENTER,
-		 "Entered PROC_UnReserveMemory, args:\n\t"
-		 "hProcessor: 0x%x pRsvAddr: 0x%x\n", hProcessor, pRsvAddr);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	struct dmm_object *dmm_mgr;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
+	struct dmm_rsv_object *rsv_obj;
+
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_UnMap: "
-			 "InValid Processor Handle \n");
 		goto func_end;
 	}
-	status = DMM_GetHandle(pProcObject, &hDmmMgr);
+
+	status = dmm_get_handle(p_proc_object, &dmm_mgr);
 	if (DSP_FAILED(status))
-		GT_1trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_UnReserveMemory: Failed to get DMM Mgr "
-			 "handle: 0x%x\n", status);
-	else
-		status = DMM_UnReserveMemory(hDmmMgr, (u32) pRsvAddr);
+		goto func_end;
+
+	status = dmm_un_reserve_memory(dmm_mgr, (u32) prsv_addr);
+	if (status != DSP_SOK)
+		goto func_end;
+
+	/*
+	 * A successful unreserve should be followed by removal of rsv_obj
+	 * from dmm_rsv_list, so that reserved memory resource tracking
+	 * remains uptodate
+	 */
+	spin_lock(&pr_ctxt->dmm_rsv_lock);
+	list_for_each_entry(rsv_obj, &pr_ctxt->dmm_rsv_list, link) {
+		if (rsv_obj->dsp_reserved_addr == (u32) prsv_addr) {
+			list_del(&rsv_obj->link);
+			kfree(rsv_obj);
+			break;
+		}
+	}
+	spin_unlock(&pr_ctxt->dmm_rsv_lock);
 
-	GT_1trace(PROC_DebugMask, GT_ENTER,
-		 "Leaving PROC_UnReserveMemory [0x%x]",
-		 status);
 func_end:
+	dev_dbg(bridge, "%s: hprocessor: 0x%p prsv_addr: 0x%p status: 0x%x\n",
+		__func__, hprocessor, prsv_addr, status);
 	return status;
 }
 
 /*
- *  ======== = PROC_Monitor ======== ==
+ *  ======== = proc_monitor ======== ==
  *  Purpose:
  *      Place the Processor in Monitor State. This is an internal
  *      function and a requirement before Processor is loaded.
- *      This does a WMD_BRD_Stop, DEV_Destroy2 and WMD_BRD_Monitor.
- *      In DEV_Destroy2 we delete the node manager.
+ *      This does a bridge_brd_stop, dev_destroy2 and bridge_brd_monitor.
+ *      In dev_destroy2 we delete the node manager.
  *  Parameters:
- *      hProcObject:    Handle to Processor Object
+ *      p_proc_object:    Pointer to Processor Object
  *  Returns:
  *      DSP_SOK:	Processor placed in monitor mode.
  *      !DSP_SOK:       Failed to place processor in monitor mode.
@@ -1902,173 +1536,148 @@
  *  Ensures:
  *      Success:	ProcObject state is PROC_IDLE
  */
-static DSP_STATUS PROC_Monitor(struct PROC_OBJECT *hProcObject)
+static dsp_status proc_monitor(struct proc_object *p_proc_object)
 {
-	DSP_STATUS status = DSP_EFAIL;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcObject;
-	struct MSG_MGR *hMsgMgr;
-#ifdef DEBUG
-	BRD_STATUS uBrdState;
-#endif
+	dsp_status status = DSP_EFAIL;
+	struct msg_mgr *hmsg_mgr;
+	int brd_state;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(pProcObject, PROC_SIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE));
 
-	GT_1trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Monitor, args:\n\t"
-		 "hProcessor: 0x%x\n", hProcObject);
 	/* This is needed only when Device is loaded when it is
 	 * already 'ACTIVE' */
-	/* Destory the Node Manager, MSG Manager */
-	if (DSP_SUCCEEDED(DEV_Destroy2(pProcObject->hDevObject))) {
-		/* Destroy the MSG by calling MSG_Delete */
-		DEV_GetMsgMgr(pProcObject->hDevObject, &hMsgMgr);
-		if (hMsgMgr) {
-			MSG_Delete(hMsgMgr);
-			DEV_SetMsgMgr(pProcObject->hDevObject, NULL);
+	/* Destory the Node Manager, msg_ctrl Manager */
+	if (DSP_SUCCEEDED(dev_destroy2(p_proc_object->hdev_obj))) {
+		/* Destroy the msg_ctrl by calling msg_delete */
+		dev_get_msg_mgr(p_proc_object->hdev_obj, &hmsg_mgr);
+		if (hmsg_mgr) {
+			msg_delete(hmsg_mgr);
+			dev_set_msg_mgr(p_proc_object->hdev_obj, NULL);
 		}
 	}
 	/* Place the Board in the Monitor State */
-	if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdMonitor)
-	   (pProcObject->hWmdContext))) {
+	if (DSP_SUCCEEDED((*p_proc_object->intf_fxns->pfn_brd_monitor)
+			  (p_proc_object->hwmd_context))) {
 		status = DSP_SOK;
-#ifdef DEBUG
-		if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
-		   (pProcObject->hWmdContext, &uBrdState))) {
-			GT_0trace(PROC_DebugMask, GT_1CLASS,
-				 "PROC_Monitor:Processor in "
-				 "Monitor State\n");
-			DBC_Assert(uBrdState == BRD_IDLE);
-		}
-#endif
-	} else {
-		/* Monitor Failure */
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Monitor: Processor Could not"
-			 "be put in Monitor mode \n");
-	}
-	GT_1trace(PROC_DebugMask, GT_ENTER,
-		 "Exiting PROC_Monitor, status  0x%x\n",
-		 status);
-#ifdef DEBUG
-	DBC_Ensure((DSP_SUCCEEDED(status) && uBrdState == BRD_IDLE) ||
-		  DSP_FAILED(status));
-#endif
+		if (DSP_SUCCEEDED((*p_proc_object->intf_fxns->pfn_brd_status)
+				  (p_proc_object->hwmd_context, &brd_state)))
+			DBC_ASSERT(brd_state == BRD_IDLE);
+	}
+
+	DBC_ENSURE((DSP_SUCCEEDED(status) && brd_state == BRD_IDLE) ||
+		   DSP_FAILED(status));
 	return status;
 }
 
 /*
- *  ======== GetEnvpCount ========
+ *  ======== get_envp_count ========
  *  Purpose:
  *      Return the number of elements in the envp array, including the
  *      terminating NULL element.
  */
-static s32 GetEnvpCount(char **envp)
+static s32 get_envp_count(char **envp)
 {
-	s32 cRetval = 0;
+	s32 ret = 0;
 	if (envp) {
 		while (*envp++)
-			cRetval++;
+			ret++;
 
-		cRetval += 1;	/* Include the terminating NULL in the count. */
+		ret += 1;	/* Include the terminating NULL in the count. */
 	}
 
-	return cRetval;
+	return ret;
 }
 
 /*
- *  ======== PrependEnvp ========
+ *  ======== prepend_envp ========
  *  Purpose:
  *      Prepend an environment variable=value pair to the new envp array, and
  *      copy in the existing var=value pairs in the old envp array.
  */
-static char **PrependEnvp(char **newEnvp, char **envp, s32 cEnvp, s32 cNewEnvp,
-			 char *szVar)
+static char **prepend_envp(char **new_envp, char **envp, s32 envp_elems,
+			   s32 cnew_envp, char *szVar)
 {
-	char **ppEnvp = newEnvp;
+	char **pp_envp = new_envp;
 
-	DBC_Require(newEnvp);
+	DBC_REQUIRE(new_envp);
 
 	/* Prepend new environ var=value string */
-	*newEnvp++ = szVar;
+	*new_envp++ = szVar;
 
 	/* Copy user's environment into our own. */
-	while (cEnvp--)
-		*newEnvp++ = *envp++;
+	while (envp_elems--)
+		*new_envp++ = *envp++;
 
 	/* Ensure NULL terminates the new environment strings array. */
-	if (cEnvp == 0)
-		*newEnvp = NULL;
+	if (envp_elems == 0)
+		*new_envp = NULL;
 
-	return ppEnvp;
+	return pp_envp;
 }
 
 /*
- *  ======== PROC_NotifyClients ========
+ *  ======== proc_notify_clients ========
  *  Purpose:
  *      Notify the processor the events.
  */
-DSP_STATUS PROC_NotifyClients(DSP_HPROCESSOR hProc, u32 uEvents)
+dsp_status proc_notify_clients(void *hProc, u32 uEvents)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProc;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hProc;
 
-	DBC_Require(MEM_IsValidHandle(pProcObject, PROC_SIGNATURE));
-	DBC_Require(IsValidProcEvent(uEvents));
-	DBC_Require(cRefs > 0);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE));
+	DBC_REQUIRE(IS_VALID_PROC_EVENT(uEvents));
+	DBC_REQUIRE(refs > 0);
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
 		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_NotifyClients: "
-			 "InValid Processor Handle \n");
 		goto func_end;
 	}
 
-	NTFY_Notify(pProcObject->hNtfy, uEvents);
-	GT_0trace(PROC_DebugMask, GT_1CLASS,
-		 "PROC_NotifyClients :Signaled. \n");
+	ntfy_notify(p_proc_object->ntfy_obj, uEvents);
 func_end:
 	return status;
 }
 
 /*
- *  ======== PROC_NotifyAllClients ========
+ *  ======== proc_notify_all_clients ========
  *  Purpose:
  *      Notify the processor the events. This includes notifying all clients
  *      attached to a particulat DSP.
  */
-DSP_STATUS PROC_NotifyAllClients(DSP_HPROCESSOR hProc, u32 uEvents)
+dsp_status proc_notify_all_clients(void *hProc, u32 uEvents)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProc;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hProc;
 
-	DBC_Require(MEM_IsValidHandle(pProcObject, PROC_SIGNATURE));
-	DBC_Require(IsValidProcEvent(uEvents));
-	DBC_Require(cRefs > 0);
+	DBC_REQUIRE(IS_VALID_PROC_EVENT(uEvents));
+	DBC_REQUIRE(refs > 0);
 
-	DEV_NotifyClients(pProcObject->hDevObject, uEvents);
+	if (!MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 
-	GT_0trace(PROC_DebugMask, GT_1CLASS,
-		 "PROC_NotifyAllClients :Signaled. \n");
+	dev_notify_clients(p_proc_object->hdev_obj, uEvents);
 
+func_end:
 	return status;
 }
 
 /*
- *  ======== PROC_GetProcessorId ========
+ *  ======== proc_get_processor_id ========
  *  Purpose:
  *      Retrieves the processor ID.
  */
-DSP_STATUS PROC_GetProcessorId(DSP_HPROCESSOR hProc, u32 *procID)
+dsp_status proc_get_processor_id(void *hProc, u32 * procID)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProc;
+	dsp_status status = DSP_SOK;
+	struct proc_object *p_proc_object = (struct proc_object *)hProc;
 
-	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE))
-		*procID = pProcObject->uProcessor;
-	else {
+	if (MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE))
+		*procID = p_proc_object->processor_id;
+	else
 		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_GetProcessorId: "
-			 "InValid Processor Handle \n");
-	}
+
 	return status;
 }
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/pwr.c kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/pwr.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/pwr.c	2011-10-11 13:51:01.713900288 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/rmgr/pwr.c	2011-10-29 20:56:26.035037000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * PWR API for controlling DSP power states.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,23 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== PWR.c ========
- *  PWR API for controlling DSP power states.
- *
- *  Public Functions:
- *      PWR_SleepDSP
- *      PWR_WakeDSP
- *
- *! Revision History
- *! ================
- *! 18-Feb-2003 vp  Code review updates.
- *! 18-Oct-2002 vp  Ported to Linux platform.
- *! 22-May-2002 sg  Do PWR-to-IOCTL code mapping in PWR_SleepDSP.
- *! 29-Apr-2002 sg  Initial.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -48,29 +33,30 @@
 #include <dspbridge/wmdioctl.h>
 
 /*
- *  ======== PWR_SleepDSP ========
+ *  ======== pwr_sleep_dsp ========
  *    Send command to DSP to enter sleep state.
  */
-DSP_STATUS PWR_SleepDSP(IN CONST u32 sleepCode, IN CONST u32 timeout)
+dsp_status pwr_sleep_dsp(IN CONST u32 sleepCode, IN CONST u32 timeout)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct WMD_DEV_CONTEXT *dwContext;
-	DSP_STATUS status = DSP_EFAIL;
-	struct DEV_OBJECT *hDevObject = NULL;
+	struct bridge_drv_interface *intf_fxns;
+	struct wmd_dev_context *dw_context;
+	dsp_status status = DSP_EFAIL;
+	struct dev_object *hdev_obj = NULL;
 	u32 ioctlcode = 0;
 	u32 arg = timeout;
 
-	for (hDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
-			  hDevObject != NULL;
-			hDevObject =
-				(struct DEV_OBJECT *)DRV_GetNextDevObject
-				((u32)hDevObject)) {
-		if (DSP_FAILED(DEV_GetWMDContext(hDevObject,
-		   (struct WMD_DEV_CONTEXT **)&dwContext))) {
+	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
+	     hdev_obj != NULL;
+	     hdev_obj =
+	     (struct dev_object *)drv_get_next_dev_object((u32) hdev_obj)) {
+		if (DSP_FAILED(dev_get_wmd_context(hdev_obj,
+						   (struct wmd_dev_context **)
+						   &dw_context))) {
 			continue;
 		}
-		if (DSP_FAILED(DEV_GetIntfFxns(hDevObject,
-		   (struct WMD_DRV_INTERFACE **)&pIntfFxns))) {
+		if (DSP_FAILED(dev_get_intf_fxns(hdev_obj,
+						 (struct bridge_drv_interface **)
+						 &intf_fxns))) {
 			continue;
 		}
 		if (sleepCode == PWR_DEEPSLEEP)
@@ -81,35 +67,41 @@
 			status = DSP_EINVALIDARG;
 
 		if (status != DSP_EINVALIDARG) {
-			status = (*pIntfFxns->pfnDevCntrl)(dwContext,
-				 ioctlcode, (void *)&arg);
+			status = (*intf_fxns->pfn_dev_cntrl) (dw_context,
+							      ioctlcode,
+							      (void *)&arg);
 		}
 	}
 	return status;
 }
 
 /*
- *  ======== PWR_WakeDSP ========
+ *  ======== pwr_wake_dsp ========
  *    Send command to DSP to wake it from sleep.
  */
-DSP_STATUS PWR_WakeDSP(IN CONST u32 timeout)
+dsp_status pwr_wake_dsp(IN CONST u32 timeout)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct WMD_DEV_CONTEXT *dwContext;
-	DSP_STATUS status = DSP_EFAIL;
-	struct DEV_OBJECT *hDevObject = NULL;
+	struct bridge_drv_interface *intf_fxns;
+	struct wmd_dev_context *dw_context;
+	dsp_status status = DSP_EFAIL;
+	struct dev_object *hdev_obj = NULL;
 	u32 arg = timeout;
 
-	for (hDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
-	     hDevObject != NULL;
-	     hDevObject = (struct DEV_OBJECT *)DRV_GetNextDevObject
-			  ((u32)hDevObject)) {
-		if (DSP_SUCCEEDED(DEV_GetWMDContext(hDevObject,
-		   (struct WMD_DEV_CONTEXT **)&dwContext))) {
-			if (DSP_SUCCEEDED(DEV_GetIntfFxns(hDevObject,
-			   (struct WMD_DRV_INTERFACE **)&pIntfFxns))) {
-				status = (*pIntfFxns->pfnDevCntrl)(dwContext,
-					 WMDIOCTL_WAKEUP, (void *)&arg);
+	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
+	     hdev_obj != NULL;
+	     hdev_obj = (struct dev_object *)drv_get_next_dev_object
+	     ((u32) hdev_obj)) {
+		if (DSP_SUCCEEDED(dev_get_wmd_context(hdev_obj,
+						      (struct wmd_dev_context
+						       **)&dw_context))) {
+			if (DSP_SUCCEEDED
+			    (dev_get_intf_fxns
+			     (hdev_obj,
+			      (struct bridge_drv_interface **)&intf_fxns))) {
+				status =
+				    (*intf_fxns->pfn_dev_cntrl) (dw_context,
+							WMDIOCTL_WAKEUP,
+							(void *)&arg);
 			}
 		}
 	}
@@ -117,31 +109,35 @@
 }
 
 /*
- *  ======== PWR_PM_PreScale========
+ *  ======== pwr_pm_pre_scale========
  *    Sends pre-notification message to DSP.
  */
-DSP_STATUS PWR_PM_PreScale(IN u16 voltage_domain, u32 level)
+dsp_status pwr_pm_pre_scale(IN u16 voltage_domain, u32 level)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct WMD_DEV_CONTEXT *dwContext;
-	DSP_STATUS status = DSP_EFAIL;
-	struct DEV_OBJECT *hDevObject = NULL;
+	struct bridge_drv_interface *intf_fxns;
+	struct wmd_dev_context *dw_context;
+	dsp_status status = DSP_EFAIL;
+	struct dev_object *hdev_obj = NULL;
 	u32 arg[2];
 
 	arg[0] = voltage_domain;
 	arg[1] = level;
 
-	for (hDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
-	    hDevObject != NULL;
-	    hDevObject = (struct DEV_OBJECT *)DRV_GetNextDevObject
-			 ((u32)hDevObject)) {
-		if (DSP_SUCCEEDED(DEV_GetWMDContext(hDevObject,
-		   (struct WMD_DEV_CONTEXT **)&dwContext))) {
-			if (DSP_SUCCEEDED(DEV_GetIntfFxns(hDevObject,
-			   (struct WMD_DRV_INTERFACE **)&pIntfFxns))) {
-				status = (*pIntfFxns->pfnDevCntrl)(dwContext,
-					 WMDIOCTL_PRESCALE_NOTIFY,
-					 (void *)&arg);
+	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
+	     hdev_obj != NULL;
+	     hdev_obj = (struct dev_object *)drv_get_next_dev_object
+	     ((u32) hdev_obj)) {
+		if (DSP_SUCCEEDED(dev_get_wmd_context(hdev_obj,
+						      (struct wmd_dev_context
+						       **)&dw_context))) {
+			if (DSP_SUCCEEDED
+			    (dev_get_intf_fxns
+			     (hdev_obj,
+			      (struct bridge_drv_interface **)&intf_fxns))) {
+				status =
+				    (*intf_fxns->pfn_dev_cntrl) (dw_context,
+						WMDIOCTL_PRESCALE_NOTIFY,
+						(void *)&arg);
 			}
 		}
 	}
@@ -149,36 +145,38 @@
 }
 
 /*
- *  ======== PWR_PM_PostScale========
+ *  ======== pwr_pm_post_scale========
  *    Sends post-notification message to DSP.
  */
-DSP_STATUS PWR_PM_PostScale(IN u16 voltage_domain, u32 level)
+dsp_status pwr_pm_post_scale(IN u16 voltage_domain, u32 level)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct WMD_DEV_CONTEXT *dwContext;
-	DSP_STATUS status = DSP_EFAIL;
-	struct DEV_OBJECT *hDevObject = NULL;
+	struct bridge_drv_interface *intf_fxns;
+	struct wmd_dev_context *dw_context;
+	dsp_status status = DSP_EFAIL;
+	struct dev_object *hdev_obj = NULL;
 	u32 arg[2];
 
 	arg[0] = voltage_domain;
 	arg[1] = level;
 
-	for (hDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
-	     hDevObject != NULL;
-	     hDevObject = (struct DEV_OBJECT *)DRV_GetNextDevObject
-			  ((u32)hDevObject)) {
-		if (DSP_SUCCEEDED(DEV_GetWMDContext(hDevObject,
-		   (struct WMD_DEV_CONTEXT **)&dwContext))) {
-			if (DSP_SUCCEEDED(DEV_GetIntfFxns(hDevObject,
-			   (struct WMD_DRV_INTERFACE **)&pIntfFxns))) {
-				status = (*pIntfFxns->pfnDevCntrl)(dwContext,
-					WMDIOCTL_POSTSCALE_NOTIFY,
-					(void *)&arg);
+	for (hdev_obj = (struct dev_object *)drv_get_first_dev_object();
+	     hdev_obj != NULL;
+	     hdev_obj = (struct dev_object *)drv_get_next_dev_object
+	     ((u32) hdev_obj)) {
+		if (DSP_SUCCEEDED(dev_get_wmd_context(hdev_obj,
+						      (struct wmd_dev_context
+						       **)&dw_context))) {
+			if (DSP_SUCCEEDED
+			    (dev_get_intf_fxns
+			     (hdev_obj,
+			      (struct bridge_drv_interface **)&intf_fxns))) {
+				status =
+				    (*intf_fxns->pfn_dev_cntrl) (dw_context,
+						WMDIOCTL_POSTSCALE_NOTIFY,
+						(void *)&arg);
 			}
 		}
 	}
 	return status;
 
 }
-
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/rmm.c kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/rmm.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/rmm.c	2011-10-11 13:51:01.726608762 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/rmgr/rmm.c	2011-10-23 08:22:37.673157000 +0100
@@ -14,11 +14,7 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
 /*
- *  ======== rmm.c ========
- *  Description:
- *
  *  This memory manager provides general heap management and arbitrary
  *  alignment for any number of memory segments.
  *
@@ -35,20 +31,10 @@
  *  and the start of the allocated block - the memory manager must free
  *  this memory to prevent a memory leak.
  *
- *  Overlay memory is managed by reserving through RMM_alloc, and freeing
- *  it through RMM_free. The memory manager prevents DSP code/data that is
+ *  Overlay memory is managed by reserving through rmm_alloc, and freeing
+ *  it through rmm_free. The memory manager prevents DSP code/data that is
  *  overlayed from being overwritten as long as the memory it runs at has
  *  been allocated, and not yet freed.
- *
- *! Revision History
- *! ================
- *! 18-Feb-2003 vp  Code review updates.
- *! 18-Oct-2002 vp  Ported to Linux Platform.
- *! 24-Sep-2002 map Updated from Code Review
- *! 25-Jun-2002 jeh     Free from segid passed to RMM_free().
- *! 24-Apr-2002 jeh     Determine segid based on address in RMM_free(). (No way
- *!                     to keep track of segid with dynamic loader library.)
- *! 16-Oct-2001 jeh     Based on gen tree rm.c. Added support for overlays.
  */
 
 /*  ----------------------------------- DSP/BIOS Bridge */
@@ -58,7 +44,6 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/list.h>
@@ -70,118 +55,113 @@
 #define RMM_TARGSIGNATURE   0x544d4d52	/* "TMMR" */
 
 /*
- *  ======== RMM_Header ========
+ *  ======== rmm_header ========
  *  This header is used to maintain a list of free memory blocks.
  */
-struct RMM_Header {
-	struct RMM_Header *next;	/* form a free memory link list */
+struct rmm_header {
+	struct rmm_header *next;	/* form a free memory link list */
 	u32 size;		/* size of the free memory */
 	u32 addr;		/* DSP address of memory block */
-} ;
+};
 
 /*
- *  ======== RMM_OvlySect ========
+ *  ======== rmm_ovly_sect ========
  *  Keeps track of memory occupied by overlay section.
  */
-struct RMM_OvlySect {
-	struct LST_ELEM listElem;
+struct rmm_ovly_sect {
+	struct list_head list_elem;
 	u32 addr;		/* Start of memory section */
 	u32 size;		/* Length (target MAUs) of section */
 	s32 page;		/* Memory page */
 };
 
 /*
- *  ======== RMM_TargetObj ========
+ *  ======== rmm_target_obj ========
  */
-struct RMM_TargetObj {
-	u32 dwSignature;
-	struct RMM_Segment *segTab;
-	struct RMM_Header **freeList;
-	u32 numSegs;
-	struct LST_LIST *ovlyList;	/* List of overlay memory in use */
+struct rmm_target_obj {
+	u32 dw_signature;
+	struct rmm_segment *seg_tab;
+	struct rmm_header **free_list;
+	u32 num_segs;
+	struct lst_list *ovly_list;	/* List of overlay memory in use */
 };
 
-#if GT_TRACE
-static struct GT_Mask RMM_debugMask = { NULL, NULL };	/* GT trace variable */
-#endif
-
-static u32 cRefs;		/* module reference count */
+static u32 refs;		/* module reference count */
 
-static bool allocBlock(struct RMM_TargetObj *target, u32 segid, u32 size,
-		      u32 align, u32 *dspAddr);
-static bool freeBlock(struct RMM_TargetObj *target, u32 segid, u32 addr,
-		     u32 size);
+static bool alloc_block(struct rmm_target_obj *target, u32 segid, u32 size,
+			u32 align, u32 *dspAddr);
+static bool free_block(struct rmm_target_obj *target, u32 segid, u32 addr,
+		       u32 size);
 
 /*
- *  ======== RMM_alloc ========
+ *  ======== rmm_alloc ========
  */
-DSP_STATUS RMM_alloc(struct RMM_TargetObj *target, u32 segid, u32 size,
-		    u32 align, u32 *dspAddr, bool reserve)
+dsp_status rmm_alloc(struct rmm_target_obj *target, u32 segid, u32 size,
+		     u32 align, u32 *dspAddr, bool reserve)
 {
-	struct RMM_OvlySect *sect;
-	struct RMM_OvlySect *prevSect = NULL;
-	struct RMM_OvlySect *newSect;
+	struct rmm_ovly_sect *sect;
+	struct rmm_ovly_sect *prev_sect = NULL;
+	struct rmm_ovly_sect *new_sect;
 	u32 addr;
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(target, RMM_TARGSIGNATURE));
+	DBC_REQUIRE(dspAddr != NULL);
+	DBC_REQUIRE(size > 0);
+	DBC_REQUIRE(reserve || (target->num_segs > 0));
+	DBC_REQUIRE(refs > 0);
 
-	DBC_Require(MEM_IsValidHandle(target, RMM_TARGSIGNATURE));
-	DBC_Require(dspAddr != NULL);
-	DBC_Require(size > 0);
-	DBC_Require(reserve || (target->numSegs > 0));
-	DBC_Require(cRefs > 0);
-
-	GT_6trace(RMM_debugMask, GT_ENTER,
-		 "RMM_alloc(0x%lx, 0x%lx, 0x%lx, 0x%lx, "
-		 "0x%lx, 0x%lx)\n", target, segid, size, align, dspAddr,
-		 reserve);
 	if (!reserve) {
-		if (!allocBlock(target, segid, size, align, dspAddr)) {
+		if (!alloc_block(target, segid, size, align, dspAddr)) {
 			status = DSP_EMEMORY;
 		} else {
 			/* Increment the number of allocated blocks in this
 			 * segment */
-			target->segTab[segid].number++;
+			target->seg_tab[segid].number++;
 		}
 		goto func_end;
 	}
 	/* An overlay section - See if block is already in use. If not,
-	 * insert into the list in ascending address size.  */
+	 * insert into the list in ascending address size. */
 	addr = *dspAddr;
-	sect = (struct RMM_OvlySect *)LST_First(target->ovlyList);
+	sect = (struct rmm_ovly_sect *)lst_first(target->ovly_list);
 	/*  Find place to insert new list element. List is sorted from
 	 *  smallest to largest address. */
 	while (sect != NULL) {
 		if (addr <= sect->addr) {
 			/* Check for overlap with sect */
-			if ((addr + size > sect->addr) || (prevSect &&
-			   (prevSect->addr + prevSect->size > addr))) {
+			if ((addr + size > sect->addr) || (prev_sect &&
+							   (prev_sect->addr +
+							    prev_sect->size >
+							    addr))) {
 				status = DSP_EOVERLAYMEMORY;
 			}
 			break;
 		}
-		prevSect = sect;
-		sect = (struct RMM_OvlySect *)LST_Next(target->ovlyList,
-			(struct LST_ELEM *)sect);
+		prev_sect = sect;
+		sect = (struct rmm_ovly_sect *)lst_next(target->ovly_list,
+							(struct list_head *)
+							sect);
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* No overlap - allocate list element for new section. */
-		newSect = MEM_Calloc(sizeof(struct RMM_OvlySect), MEM_PAGED);
-		if (newSect == NULL) {
+		new_sect = mem_calloc(sizeof(struct rmm_ovly_sect), MEM_PAGED);
+		if (new_sect == NULL) {
 			status = DSP_EMEMORY;
 		} else {
-			LST_InitElem((struct LST_ELEM *)newSect);
-			newSect->addr = addr;
-			newSect->size = size;
-			newSect->page = segid;
+			lst_init_elem((struct list_head *)new_sect);
+			new_sect->addr = addr;
+			new_sect->size = size;
+			new_sect->page = segid;
 			if (sect == NULL) {
 				/* Put new section at the end of the list */
-				LST_PutTail(target->ovlyList,
-					   (struct LST_ELEM *)newSect);
+				lst_put_tail(target->ovly_list,
+					     (struct list_head *)new_sect);
 			} else {
 				/* Put new section just before sect */
-				LST_InsertBefore(target->ovlyList,
-						(struct LST_ELEM *)newSect,
-						(struct LST_ELEM *)sect);
+				lst_insert_before(target->ovly_list,
+						  (struct list_head *)new_sect,
+						  (struct list_head *)sect);
 			}
 		}
 	}
@@ -190,73 +170,61 @@
 }
 
 /*
- *  ======== RMM_create ========
+ *  ======== rmm_create ========
  */
-DSP_STATUS RMM_create(struct RMM_TargetObj **pTarget,
-		     struct RMM_Segment segTab[], u32 numSegs)
+dsp_status rmm_create(struct rmm_target_obj **target_obj,
+		      struct rmm_segment seg_tab[], u32 num_segs)
 {
-	struct RMM_Header *hptr;
-	struct RMM_Segment *sptr, *tmp;
-	struct RMM_TargetObj *target;
+	struct rmm_header *hptr;
+	struct rmm_segment *sptr, *tmp;
+	struct rmm_target_obj *target;
 	s32 i;
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(pTarget != NULL);
-	DBC_Require(numSegs == 0 || segTab != NULL);
-
-	GT_3trace(RMM_debugMask, GT_ENTER,
-		 "RMM_create(0x%lx, 0x%lx, 0x%lx)\n",
-		 pTarget, segTab, numSegs);
+	DBC_REQUIRE(target_obj != NULL);
+	DBC_REQUIRE(num_segs == 0 || seg_tab != NULL);
 
 	/* Allocate DBL target object */
-	MEM_AllocObject(target, struct RMM_TargetObj, RMM_TARGSIGNATURE);
+	MEM_ALLOC_OBJECT(target, struct rmm_target_obj, RMM_TARGSIGNATURE);
 
-	if (target == NULL) {
-		GT_0trace(RMM_debugMask, GT_6CLASS,
-			 "RMM_create: Memory allocation failed\n");
+	if (target == NULL)
 		status = DSP_EMEMORY;
-	}
+
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-	target->numSegs = numSegs;
-	if (!(numSegs > 0))
+	target->num_segs = num_segs;
+	if (!(num_segs > 0))
 		goto func_cont;
 
 	/* Allocate the memory for freelist from host's memory */
-	target->freeList = MEM_Calloc(numSegs * sizeof(struct RMM_Header *),
-				     MEM_PAGED);
-	if (target->freeList == NULL) {
-		GT_0trace(RMM_debugMask, GT_6CLASS,
-			 "RMM_create: Memory allocation failed\n");
+	target->free_list = mem_calloc(num_segs * sizeof(struct rmm_header *),
+				       MEM_PAGED);
+	if (target->free_list == NULL) {
 		status = DSP_EMEMORY;
 	} else {
 		/* Allocate headers for each element on the free list */
-		for (i = 0; i < (s32) numSegs; i++) {
-			target->freeList[i] =
-					MEM_Calloc(sizeof(struct RMM_Header),
-					MEM_PAGED);
-			if (target->freeList[i] == NULL) {
-				GT_0trace(RMM_debugMask, GT_6CLASS,
-					 "RMM_create: Memory "
-					 "allocation failed\n");
+		for (i = 0; i < (s32) num_segs; i++) {
+			target->free_list[i] =
+			    mem_calloc(sizeof(struct rmm_header), MEM_PAGED);
+			if (target->free_list[i] == NULL) {
 				status = DSP_EMEMORY;
 				break;
 			}
 		}
 		/* Allocate memory for initial segment table */
-		target->segTab = MEM_Calloc(numSegs *
-				 sizeof(struct RMM_Segment), MEM_PAGED);
-		if (target->segTab == NULL) {
-			GT_0trace(RMM_debugMask, GT_6CLASS,
-				 "RMM_create: Memory allocation failed\n");
+		target->seg_tab = mem_calloc(num_segs *
+					     sizeof(struct rmm_segment),
+					     MEM_PAGED);
+		if (target->seg_tab == NULL) {
 			status = DSP_EMEMORY;
 		} else {
 			/* Initialize segment table and free list */
-			sptr = target->segTab;
-			for (i = 0, tmp = segTab; numSegs > 0; numSegs--, i++) {
+			sptr = target->seg_tab;
+			for (i = 0, tmp = seg_tab; num_segs > 0;
+			     num_segs--, i++) {
 				*sptr = *tmp;
-				hptr = target->freeList[i];
+				hptr = target->free_list[i];
 				hptr->addr = tmp->base;
 				hptr->size = tmp->length;
 				hptr->next = NULL;
@@ -268,217 +236,188 @@
 func_cont:
 	/* Initialize overlay memory list */
 	if (DSP_SUCCEEDED(status)) {
-		target->ovlyList = LST_Create();
-		if (target->ovlyList == NULL) {
-			GT_0trace(RMM_debugMask, GT_6CLASS,
-				 "RMM_create: Memory allocation failed\n");
+		target->ovly_list = mem_calloc(sizeof(struct lst_list),
+					       MEM_NONPAGED);
+		if (target->ovly_list == NULL)
 			status = DSP_EMEMORY;
-		}
+		else
+			INIT_LIST_HEAD(&target->ovly_list->head);
 	}
 
 	if (DSP_SUCCEEDED(status)) {
-		*pTarget = target;
+		*target_obj = target;
 	} else {
-		*pTarget = NULL;
+		*target_obj = NULL;
 		if (target)
-			RMM_delete(target);
+			rmm_delete(target);
 
 	}
 
-	DBC_Ensure((DSP_SUCCEEDED(status) && MEM_IsValidHandle((*pTarget),
-		  RMM_TARGSIGNATURE)) || (DSP_FAILED(status) && *pTarget ==
-		  NULL));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && MEM_IS_VALID_HANDLE((*target_obj),
+							RMM_TARGSIGNATURE))
+		   || (DSP_FAILED(status) && *target_obj == NULL));
 
 	return status;
 }
 
 /*
- *  ======== RMM_delete ========
+ *  ======== rmm_delete ========
  */
-void RMM_delete(struct RMM_TargetObj *target)
+void rmm_delete(struct rmm_target_obj *target)
 {
-	struct RMM_OvlySect *pSect;
-	struct RMM_Header *hptr;
-	struct RMM_Header *next;
+	struct rmm_ovly_sect *ovly_section;
+	struct rmm_header *hptr;
+	struct rmm_header *next;
 	u32 i;
 
-	DBC_Require(MEM_IsValidHandle(target, RMM_TARGSIGNATURE));
-
-	GT_1trace(RMM_debugMask, GT_ENTER, "RMM_delete(0x%lx)\n", target);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(target, RMM_TARGSIGNATURE));
 
-	if (target->segTab != NULL)
-		MEM_Free(target->segTab);
+	kfree(target->seg_tab);
 
-	if (target->ovlyList) {
-		while ((pSect = (struct RMM_OvlySect *)LST_GetHead
-		      (target->ovlyList))) {
-			MEM_Free(pSect);
+	if (target->ovly_list) {
+		while ((ovly_section = (struct rmm_ovly_sect *)lst_get_head
+			(target->ovly_list))) {
+			kfree(ovly_section);
 		}
-		DBC_Assert(LST_IsEmpty(target->ovlyList));
-		LST_Delete(target->ovlyList);
+		DBC_ASSERT(LST_IS_EMPTY(target->ovly_list));
+		kfree(target->ovly_list);
 	}
 
-	if (target->freeList != NULL) {
+	if (target->free_list != NULL) {
 		/* Free elements on freelist */
-		for (i = 0; i < target->numSegs; i++) {
-			hptr = next = target->freeList[i];
+		for (i = 0; i < target->num_segs; i++) {
+			hptr = next = target->free_list[i];
 			while (next) {
 				hptr = next;
 				next = hptr->next;
-				MEM_Free(hptr);
+				kfree(hptr);
 			}
 		}
-		MEM_Free(target->freeList);
+		kfree(target->free_list);
 	}
 
-	MEM_FreeObject(target);
+	MEM_FREE_OBJECT(target);
 }
 
 /*
- *  ======== RMM_exit ========
+ *  ======== rmm_exit ========
  */
-void RMM_exit(void)
+void rmm_exit(void)
 {
-	DBC_Require(cRefs > 0);
-
-	cRefs--;
+	DBC_REQUIRE(refs > 0);
 
-	GT_1trace(RMM_debugMask, GT_5CLASS, "RMM_exit() ref count: 0x%x\n",
-		 cRefs);
+	refs--;
 
-	if (cRefs == 0)
-		MEM_Exit();
-
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== RMM_free ========
+ *  ======== rmm_free ========
  */
-bool RMM_free(struct RMM_TargetObj *target, u32 segid, u32 addr, u32 size,
-	bool reserved)
-
+bool rmm_free(struct rmm_target_obj *target, u32 segid, u32 addr, u32 size,
+	      bool reserved)
 {
-	struct RMM_OvlySect *sect;
-	bool retVal = true;
+	struct rmm_ovly_sect *sect;
+	bool ret = true;
+
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(target, RMM_TARGSIGNATURE));
 
-	DBC_Require(MEM_IsValidHandle(target, RMM_TARGSIGNATURE));
+	DBC_REQUIRE(reserved || segid < target->num_segs);
+	DBC_REQUIRE(reserved || (addr >= target->seg_tab[segid].base &&
+				 (addr + size) <= (target->seg_tab[segid].base +
+						   target->seg_tab[segid].
+						   length)));
 
-	DBC_Require(reserved || segid < target->numSegs);
-	DBC_Require(reserved || (addr >= target->segTab[segid].base &&
-		   (addr + size) <= (target->segTab[segid].base +
-		   target->segTab[segid].length)));
-
-	GT_5trace(RMM_debugMask, GT_ENTER,
-		 "RMM_free(0x%lx, 0x%lx, 0x%lx, 0x%lx, "
-		 "0x%lx)\n", target, segid, addr, size, reserved);
 	/*
 	 *  Free or unreserve memory.
 	 */
 	if (!reserved) {
-		retVal = freeBlock(target, segid, addr, size);
-		if (retVal)
-			target->segTab[segid].number--;
+		ret = free_block(target, segid, addr, size);
+		if (ret)
+			target->seg_tab[segid].number--;
 
 	} else {
 		/* Unreserve memory */
-		sect = (struct RMM_OvlySect *)LST_First(target->ovlyList);
+		sect = (struct rmm_ovly_sect *)lst_first(target->ovly_list);
 		while (sect != NULL) {
 			if (addr == sect->addr) {
-				DBC_Assert(size == sect->size);
+				DBC_ASSERT(size == sect->size);
 				/* Remove from list */
-				LST_RemoveElem(target->ovlyList,
-					      (struct LST_ELEM *)sect);
-				MEM_Free(sect);
+				lst_remove_elem(target->ovly_list,
+						(struct list_head *)sect);
+				kfree(sect);
 				break;
 			}
-			sect = (struct RMM_OvlySect *)LST_Next(target->ovlyList,
-			       (struct LST_ELEM *)sect);
+			sect =
+			    (struct rmm_ovly_sect *)lst_next(target->ovly_list,
+							     (struct list_head
+							      *)sect);
 		}
 		if (sect == NULL)
-			retVal = false;
+			ret = false;
 
 	}
-	return retVal;
+	return ret;
 }
 
 /*
- *  ======== RMM_init ========
+ *  ======== rmm_init ========
  */
-bool RMM_init(void)
+bool rmm_init(void)
 {
-	bool retVal = true;
-
-	DBC_Require(cRefs >= 0);
-
-	if (cRefs == 0) {
-		DBC_Assert(!RMM_debugMask.flags);
-		GT_create(&RMM_debugMask, "RM");	/* "RM" for RMm */
-
-		retVal = MEM_Init();
+	DBC_REQUIRE(refs >= 0);
 
-		if (!retVal)
-			MEM_Exit();
+	refs++;
 
-	}
-
-	if (retVal)
-		cRefs++;
-
-	GT_1trace(RMM_debugMask, GT_5CLASS,
-		 "RMM_init(), ref count:  0x%x\n",
-		 cRefs);
-
-	DBC_Ensure((retVal && (cRefs > 0)) || (!retVal && (cRefs >= 0)));
-
-	return retVal;
+	return true;
 }
 
 /*
- *  ======== RMM_stat ========
+ *  ======== rmm_stat ========
  */
-bool RMM_stat(struct RMM_TargetObj *target, enum DSP_MEMTYPE segid,
-	     struct DSP_MEMSTAT *pMemStatBuf)
+bool rmm_stat(struct rmm_target_obj *target, enum dsp_memtype segid,
+	      struct dsp_memstat *pMemStatBuf)
 {
-	struct RMM_Header *head;
-	bool retVal = false;
-	u32 maxFreeSize = 0;
-	u32 totalFreeSize = 0;
-	u32 freeBlocks = 0;
+	struct rmm_header *head;
+	bool ret = false;
+	u32 max_free_size = 0;
+	u32 total_free_size = 0;
+	u32 free_blocks = 0;
 
-	DBC_Require(pMemStatBuf != NULL);
-	DBC_Assert(target != NULL);
+	DBC_REQUIRE(pMemStatBuf != NULL);
+	DBC_ASSERT(target != NULL);
 
-	if ((u32) segid < target->numSegs) {
-		head = target->freeList[segid];
+	if ((u32) segid < target->num_segs) {
+		head = target->free_list[segid];
 
-		/* Collect data from freeList */
+		/* Collect data from free_list */
 		while (head != NULL) {
-			maxFreeSize = max(maxFreeSize, head->size);
-			totalFreeSize += head->size;
-			freeBlocks++;
+			max_free_size = max(max_free_size, head->size);
+			total_free_size += head->size;
+			free_blocks++;
 			head = head->next;
 		}
 
-		/* ulSize */
-		pMemStatBuf->ulSize = target->segTab[segid].length;
+		/* ul_size */
+		pMemStatBuf->ul_size = target->seg_tab[segid].length;
 
-		/* ulNumFreeBlocks */
-		pMemStatBuf->ulNumFreeBlocks = freeBlocks;
+		/* ul_num_free_blocks */
+		pMemStatBuf->ul_num_free_blocks = free_blocks;
 
-		/* ulTotalFreeSize */
-		pMemStatBuf->ulTotalFreeSize = totalFreeSize;
+		/* ul_total_free_size */
+		pMemStatBuf->ul_total_free_size = total_free_size;
 
-		/* ulLenMaxFreeBlock */
-		pMemStatBuf->ulLenMaxFreeBlock = maxFreeSize;
+		/* ul_len_max_free_block */
+		pMemStatBuf->ul_len_max_free_block = max_free_size;
 
-		/* ulNumAllocBlocks */
-		pMemStatBuf->ulNumAllocBlocks = target->segTab[segid].number;
+		/* ul_num_alloc_blocks */
+		pMemStatBuf->ul_num_alloc_blocks =
+		    target->seg_tab[segid].number;
 
-		retVal = true;
+		ret = true;
 	}
 
-	return retVal;
+	return ret;
 }
 
 /*
@@ -486,12 +425,12 @@
  *  This allocation function allocates memory from the lowest addresses
  *  first.
  */
-static bool allocBlock(struct RMM_TargetObj *target, u32 segid, u32 size,
-		      u32 align, u32 *dspAddr)
+static bool alloc_block(struct rmm_target_obj *target, u32 segid, u32 size,
+			u32 align, u32 *dspAddr)
 {
-	struct RMM_Header *head;
-	struct RMM_Header *prevhead = NULL;
-	struct RMM_Header *next;
+	struct rmm_header *head;
+	struct rmm_header *prevhead = NULL;
+	struct rmm_header *next;
 	u32 tmpalign;
 	u32 alignbytes;
 	u32 hsize;
@@ -500,7 +439,7 @@
 
 	alignbytes = (align == 0) ? 1 : align;
 	prevhead = NULL;
-	head = target->freeList[segid];
+	head = target->free_list[segid];
 
 	do {
 		hsize = head->size;
@@ -518,7 +457,7 @@
 		if (hsize >= allocsize) {	/* big enough */
 			if (hsize == allocsize && prevhead != NULL) {
 				prevhead->next = next;
-				MEM_Free(head);
+				kfree(head);
 			} else {
 				head->size = hsize - allocsize;
 				head->addr += allocsize;
@@ -526,7 +465,7 @@
 
 			/* free up any hole created by alignment */
 			if (tmpalign)
-				freeBlock(target, segid, addr, tmpalign);
+				free_block(target, segid, addr, tmpalign);
 
 			*dspAddr = addr + tmpalign;
 			return true;
@@ -541,27 +480,27 @@
 }
 
 /*
- *  ======== freeBlock ========
- *  TO DO: freeBlock() allocates memory, which could result in failure.
- *  Could allocate an RMM_Header in RMM_alloc(), to be kept in a pool.
- *  freeBlock() could use an RMM_Header from the pool, freeing as blocks
+ *  ======== free_block ========
+ *  TO DO: free_block() allocates memory, which could result in failure.
+ *  Could allocate an rmm_header in rmm_alloc(), to be kept in a pool.
+ *  free_block() could use an rmm_header from the pool, freeing as blocks
  *  are coalesced.
  */
-static bool freeBlock(struct RMM_TargetObj *target, u32 segid, u32 addr,
-		     u32 size)
+static bool free_block(struct rmm_target_obj *target, u32 segid, u32 addr,
+		       u32 size)
 {
-	struct RMM_Header *head;
-	struct RMM_Header *thead;
-	struct RMM_Header *rhead;
-	bool retVal = true;
+	struct rmm_header *head;
+	struct rmm_header *thead;
+	struct rmm_header *rhead;
+	bool ret = true;
 
 	/* Create a memory header to hold the newly free'd block. */
-	rhead = MEM_Calloc(sizeof(struct RMM_Header), MEM_PAGED);
+	rhead = mem_calloc(sizeof(struct rmm_header), MEM_PAGED);
 	if (rhead == NULL) {
-		retVal = false;
+		ret = false;
 	} else {
 		/* search down the free list to find the right place for addr */
-		head = target->freeList[segid];
+		head = target->free_list[segid];
 
 		if (addr >= head->addr) {
 			while (head->next != NULL && addr > head->next->addr)
@@ -583,11 +522,11 @@
 
 		/* join with upper block, if possible */
 		if (thead != NULL && (rhead->addr + rhead->size) ==
-		   thead->addr) {
+		    thead->addr) {
 			head->next = rhead->next;
 			thead->size = size + thead->size;
 			thead->addr = addr;
-			MEM_Free(rhead);
+			kfree(rhead);
 			rhead = thead;
 		}
 
@@ -595,10 +534,9 @@
 		if ((head->addr + head->size) == rhead->addr) {
 			head->next = rhead->next;
 			head->size = head->size + rhead->size;
-			MEM_Free(rhead);
+			kfree(rhead);
 		}
 	}
 
-	return retVal;
+	return ret;
 }
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/strm.c kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/strm.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/rmgr/strm.c	2011-10-11 13:51:01.754958718 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/rmgr/strm.c	2011-10-23 08:22:37.673157000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge Stream Manager.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,53 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== strm.c ========
- *  Description:
- *      DSP/BIOS Bridge Stream Manager.
- *
- *  Public Functions:
- *      STRM_AllocateBuffer
- *      STRM_Close
- *      STRM_Create
- *      STRM_Delete
- *      STRM_Exit
- *      STRM_FreeBuffer
- *      STRM_GetEventHandle
- *      STRM_GetInfo
- *      STRM_Idle
- *      STRM_Init
- *      STRM_Issue
- *      STRM_Open
- *      STRM_PrepareBuffer
- *      STRM_Reclaim
- *      STRM_RegisterNotify
- *      STRM_Select
- *      STRM_UnprepareBuffer
- *
- *  Notes:
- *
- *! Revision History:
- *! =================
- *! 18-Feb-2003 vp  Code review updates.
- *! 18-Oct-2002 vp  Ported to Linux platform.
- *! 13-Mar-2002 map    pStrm init'd to NULL in STRM_Open to prevent error
- *! 12-Mar-2002 map Changed return var to WSX "wStatus" instead of "status"
- *!		    in DEV and CMM function calls to avoid confusion.
- *!		    Return DSP_SOK instead of S_OK from API fxns.
- *! 12-Mar-2002 map    Changed FAILED(..) to DSP_FAILED(..)
- *! 25-Jan-2002 ag  Allow neg seg ids(e.g. DSP_SHMSEG0) to denote SM.
- *! 15-Nov-2001 ag  Added STRMMODE & SM for DMA/ZCopy streaming.
- *!		 Changed DSP_STREAMINFO to STRM_INFO in STRM_GetInfo().
- *!		 Use strm timeout value for dma flush timeout.
- *! 09-May-2001 jeh Code review cleanup.
- *! 06-Feb-2001 kc  Updated DBC_Ensure in STRM_Select to check timeout.
- *! 23-Oct-2000 jeh Allow NULL STRM_ATTRS passed to STRM_Open() for DLL
- *!		 tests to pass.
- *! 25-Sep-2000 jeh Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -71,7 +26,6 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/mem.h>
@@ -89,11 +43,8 @@
 /*  ----------------------------------- This */
 #include <dspbridge/strm.h>
 
-#ifndef RES_CLEANUP_DISABLE
 #include <dspbridge/cfg.h>
-#include <dspbridge/dbreg.h>
 #include <dspbridge/resourcecleanup.h>
-#endif
 
 /*  ----------------------------------- Defines, Data Structures, Typedefs */
 #define STRM_SIGNATURE      0x4d525453	/* "MRTS" */
@@ -103,330 +54,287 @@
 #define DEFAULTNUMBUFS      2
 
 /*
- *  ======== STRM_MGR ========
- *  The STRM_MGR contains device information needed to open the underlying
+ *  ======== strm_mgr ========
+ *  The strm_mgr contains device information needed to open the underlying
  *  channels of a stream.
  */
-struct STRM_MGR {
-	u32 dwSignature;
-	struct DEV_OBJECT *hDev;	/* Device for this processor */
-	struct CHNL_MGR *hChnlMgr;	/* Channel manager */
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
-	struct SYNC_CSOBJECT *hSync;	/* For critical sections */
-} ;
-
-/*
- *  ======== STRM_OBJECT ========
- *  This object is allocated in STRM_Open().
- */
- struct STRM_OBJECT {
-	u32 dwSignature;
-	struct STRM_MGR *hStrmMgr;
-	struct CHNL_OBJECT *hChnl;
-	u32 uDir;		/* DSP_TONODE or DSP_FROMNODE */
-	u32 uTimeout;
-	u32 uNumBufs;		/* Max # of bufs allowed in stream */
-	u32 uNBufsInStrm;	/* Current # of bufs in stream */
-	u32 ulNBytes;		/* bytes transferred since idled */
-	enum DSP_STREAMSTATE strmState;	/* STREAM_IDLE, STREAM_READY, ... */
-	HANDLE hUserEvent;	/* Saved for STRM_GetInfo() */
-	enum DSP_STRMMODE lMode;	/* STRMMODE_[PROCCOPY][ZEROCOPY]... */
-	u32 uDMAChnlId;	/* DMA chnl id */
-	u32 uDMAPriority;	/* DMA priority:DMAPRI_[LOW][HIGH] */
-	u32 uSegment;		/* >0 is SM segment.=0 is local heap */
-	u32 uAlignment;	/* Alignment for stream bufs */
-	struct CMM_XLATOROBJECT *hXlator;  /* Stream's SM address translator */
-} ;
+struct strm_mgr {
+	u32 dw_signature;
+	struct dev_object *dev_obj;	/* Device for this processor */
+	struct chnl_mgr *hchnl_mgr;	/* Channel manager */
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD */
+	struct sync_csobject *sync_obj;	/* For critical sections */
+};
+
+/*
+ *  ======== strm_object ========
+ *  This object is allocated in strm_open().
+ */
+struct strm_object {
+	u32 dw_signature;
+	struct strm_mgr *strm_mgr_obj;
+	struct chnl_object *chnl_obj;
+	u32 dir;		/* DSP_TONODE or DSP_FROMNODE */
+	u32 utimeout;
+	u32 num_bufs;		/* Max # of bufs allowed in stream */
+	u32 un_bufs_in_strm;	/* Current # of bufs in stream */
+	u32 ul_n_bytes;		/* bytes transferred since idled */
+	/* STREAM_IDLE, STREAM_READY, ... */
+	enum dsp_streamstate strm_state;
+	bhandle user_event;	/* Saved for strm_get_info() */
+	enum dsp_strmmode strm_mode;	/* STRMMODE_[PROCCOPY][ZEROCOPY]... */
+	u32 udma_chnl_id;	/* DMA chnl id */
+	u32 udma_priority;	/* DMA priority:DMAPRI_[LOW][HIGH] */
+	u32 segment_id;		/* >0 is SM segment.=0 is local heap */
+	u32 buf_alignment;	/* Alignment for stream bufs */
+	/* Stream's SM address translator */
+	struct cmm_xlatorobject *xlator;
+};
 
 /*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask STRM_debugMask = { NULL, NULL };	/* GT trace variable */
-#endif
-static u32 cRefs;		/* module reference count */
+static u32 refs;		/* module reference count */
 
 /*  ----------------------------------- Function Prototypes */
-static DSP_STATUS DeleteStrm(struct STRM_OBJECT *hStrm);
-static void DeleteStrmMgr(struct STRM_MGR *hStrmMgr);
+static dsp_status delete_strm(struct strm_object *hStrm);
+static void delete_strm_mgr(struct strm_mgr *strm_mgr_obj);
 
 /*
- *  ======== STRM_AllocateBuffer ========
+ *  ======== strm_allocate_buffer ========
  *  Purpose:
  *      Allocates buffers for a stream.
  */
-DSP_STATUS STRM_AllocateBuffer(struct STRM_OBJECT *hStrm, u32 uSize,
-				OUT u8 **apBuffer, u32 uNumBufs,
-				struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status strm_allocate_buffer(struct strm_object *hStrm, u32 usize,
+				OUT u8 **ap_buffer, u32 num_bufs,
+				struct process_context *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
-	u32 uAllocated = 0;
+	dsp_status status = DSP_SOK;
+	u32 alloc_cnt = 0;
 	u32 i;
-#ifndef RES_CLEANUP_DISABLE
-	HANDLE hSTRMRes;
-#endif
-	DBC_Require(cRefs > 0);
-	DBC_Require(apBuffer != NULL);
-
-	GT_4trace(STRM_debugMask, GT_ENTER, "STRM_AllocateBuffer: hStrm: 0x%x\t"
-		 "uSize: 0x%x\tapBuffer: 0x%x\tuNumBufs: 0x%x\n",
-		 hStrm, uSize, apBuffer, uNumBufs);
-	if (MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+
+	bhandle hstrm_res;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(ap_buffer != NULL);
+
+	if (MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE)) {
 		/*
 		 * Allocate from segment specified at time of stream open.
 		 */
-		if (uSize == 0)
+		if (usize == 0)
 			status = DSP_ESIZE;
 
-	}
-	if (DSP_FAILED(status)) {
+	} else {
 		status = DSP_EHANDLE;
-		goto func_end;
 	}
-	for (i = 0; i < uNumBufs; i++) {
-		DBC_Assert(hStrm->hXlator != NULL);
-		(void)CMM_XlatorAllocBuf(hStrm->hXlator, &apBuffer[i], uSize);
-		if (apBuffer[i] == NULL) {
-			GT_0trace(STRM_debugMask, GT_7CLASS,
-				 "STRM_AllocateBuffer: "
-				 "DSP_FAILED to alloc shared memory.\n");
+
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	for (i = 0; i < num_bufs; i++) {
+		DBC_ASSERT(hStrm->xlator != NULL);
+		(void)cmm_xlator_alloc_buf(hStrm->xlator, &ap_buffer[i], usize);
+		if (ap_buffer[i] == NULL) {
 			status = DSP_EMEMORY;
-			uAllocated = i;
+			alloc_cnt = i;
 			break;
 		}
 	}
 	if (DSP_FAILED(status))
-		STRM_FreeBuffer(hStrm, apBuffer, uAllocated, pr_ctxt);
+		strm_free_buffer(hStrm, ap_buffer, alloc_cnt, pr_ctxt);
 
-#ifndef RES_CLEANUP_DISABLE
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	if (DRV_GetSTRMResElement(hStrm, &hSTRMRes, pr_ctxt) !=
-			DSP_ENOTFOUND) {
-		DRV_ProcUpdateSTRMRes(uNumBufs, hSTRMRes, pr_ctxt);
-	}
-#endif
+	if (drv_get_strm_res_element(hStrm, &hstrm_res, pr_ctxt) !=
+	    DSP_ENOTFOUND)
+		drv_proc_update_strm_res(num_bufs, hstrm_res);
+
 func_end:
 	return status;
 }
 
 /*
- *  ======== STRM_Close ========
+ *  ======== strm_close ========
  *  Purpose:
- *      Close a stream opened with STRM_Open().
+ *      Close a stream opened with strm_open().
  */
-DSP_STATUS STRM_Close(struct STRM_OBJECT *hStrm,
-		struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status strm_close(struct strm_object *hStrm,
+		      struct process_context *pr_ctxt)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct CHNL_INFO chnlInfo;
-	DSP_STATUS status = DSP_SOK;
-
-#ifndef RES_CLEANUP_DISABLE
-    HANDLE	      hSTRMRes;
-#endif
+	struct bridge_drv_interface *intf_fxns;
+	struct chnl_info chnl_info_obj;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
+	bhandle hstrm_res;
 
-	GT_1trace(STRM_debugMask, GT_ENTER, "STRM_Close: hStrm: 0x%x\n", hStrm);
+	DBC_REQUIRE(refs > 0);
 
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE)) {
 		status = DSP_EHANDLE;
 	} else {
 		/* Have all buffers been reclaimed? If not, return
 		 * DSP_EPENDING */
-		pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
-		status = (*pIntfFxns->pfnChnlGetInfo) (hStrm->hChnl, &chnlInfo);
-		DBC_Assert(DSP_SUCCEEDED(status));
+		intf_fxns = hStrm->strm_mgr_obj->intf_fxns;
+		status =
+		    (*intf_fxns->pfn_chnl_get_info) (hStrm->chnl_obj,
+						     &chnl_info_obj);
+		DBC_ASSERT(DSP_SUCCEEDED(status));
 
-		if (chnlInfo.cIOCs > 0 || chnlInfo.cIOReqs > 0) {
+		if (chnl_info_obj.cio_cs > 0 || chnl_info_obj.cio_reqs > 0)
 			status = DSP_EPENDING;
-		} else {
-
-			status = DeleteStrm(hStrm);
-
-			if (DSP_FAILED(status)) {
-				/* we already validated the handle. */
-				DBC_Assert(status != DSP_EHANDLE);
-
-				/* make sure we return a documented result */
-				status = DSP_EFAIL;
-			}
-		}
+		else
+			status = delete_strm(hStrm);
 	}
-#ifndef RES_CLEANUP_DISABLE
+
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	if (DRV_GetSTRMResElement(hStrm, &hSTRMRes, pr_ctxt) !=
-			DSP_ENOTFOUND) {
-		DRV_ProcRemoveSTRMResElement(hSTRMRes, pr_ctxt);
-	}
+	if (drv_get_strm_res_element(hStrm, &hstrm_res, pr_ctxt) !=
+	    DSP_ENOTFOUND)
+		drv_proc_remove_strm_res_element(hstrm_res, pr_ctxt);
 func_end:
-#endif
-	DBC_Ensure(status == DSP_SOK || status == DSP_EHANDLE ||
-		  status == DSP_EPENDING || status == DSP_EFAIL);
+	DBC_ENSURE(status == DSP_SOK || status == DSP_EHANDLE ||
+		   status == DSP_EPENDING || status == DSP_EFAIL);
 
+	dev_dbg(bridge, "%s: hStrm: %p, status 0x%x\n", __func__,
+		hStrm, status);
 	return status;
 }
 
 /*
- *  ======== STRM_Create ========
+ *  ======== strm_create ========
  *  Purpose:
  *      Create a STRM manager object.
  */
-DSP_STATUS STRM_Create(OUT struct STRM_MGR **phStrmMgr, struct DEV_OBJECT *hDev)
+dsp_status strm_create(OUT struct strm_mgr **phStrmMgr,
+		       struct dev_object *dev_obj)
 {
-	struct STRM_MGR *pStrmMgr;
-	DSP_STATUS status = DSP_SOK;
+	struct strm_mgr *strm_mgr_obj;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(phStrmMgr != NULL);
-	DBC_Require(hDev != NULL);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phStrmMgr != NULL);
+	DBC_REQUIRE(dev_obj != NULL);
 
-	GT_2trace(STRM_debugMask, GT_ENTER, "STRM_Create: phStrmMgr: "
-		 "0x%x\thDev: 0x%x\n", phStrmMgr, hDev);
 	*phStrmMgr = NULL;
 	/* Allocate STRM manager object */
-	MEM_AllocObject(pStrmMgr, struct STRM_MGR, STRMMGR_SIGNATURE);
-	if (pStrmMgr == NULL) {
+	MEM_ALLOC_OBJECT(strm_mgr_obj, struct strm_mgr, STRMMGR_SIGNATURE);
+	if (strm_mgr_obj == NULL)
 		status = DSP_EMEMORY;
-		GT_0trace(STRM_debugMask, GT_6CLASS, "STRM_Create: "
-			 "MEM_AllocObject() failed!\n ");
-	} else {
-		pStrmMgr->hDev = hDev;
-	}
+	else
+		strm_mgr_obj->dev_obj = dev_obj;
+
 	/* Get Channel manager and WMD function interface */
 	if (DSP_SUCCEEDED(status)) {
-		status = DEV_GetChnlMgr(hDev, &(pStrmMgr->hChnlMgr));
+		status = dev_get_chnl_mgr(dev_obj, &(strm_mgr_obj->hchnl_mgr));
 		if (DSP_SUCCEEDED(status)) {
-			(void) DEV_GetIntfFxns(hDev, &(pStrmMgr->pIntfFxns));
-			DBC_Assert(pStrmMgr->pIntfFxns != NULL);
-		} else {
-			GT_1trace(STRM_debugMask, GT_6CLASS, "STRM_Create: "
-				 "Failed to get channel manager! status = "
-				 "0x%x\n", status);
+			(void)dev_get_intf_fxns(dev_obj,
+						&(strm_mgr_obj->intf_fxns));
+			DBC_ASSERT(strm_mgr_obj->intf_fxns != NULL);
 		}
 	}
 	if (DSP_SUCCEEDED(status))
-		status = SYNC_InitializeCS(&pStrmMgr->hSync);
+		status = sync_initialize_cs(&strm_mgr_obj->sync_obj);
 
 	if (DSP_SUCCEEDED(status))
-		*phStrmMgr = pStrmMgr;
+		*phStrmMgr = strm_mgr_obj;
 	else
-		DeleteStrmMgr(pStrmMgr);
+		delete_strm_mgr(strm_mgr_obj);
 
-	DBC_Ensure(DSP_SUCCEEDED(status) &&
-		  (MEM_IsValidHandle((*phStrmMgr), STRMMGR_SIGNATURE) ||
-		  (DSP_FAILED(status) && *phStrmMgr == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) &&
+		   (MEM_IS_VALID_HANDLE((*phStrmMgr), STRMMGR_SIGNATURE) ||
+		    (DSP_FAILED(status) && *phStrmMgr == NULL)));
 
 	return status;
 }
 
 /*
- *  ======== STRM_Delete ========
+ *  ======== strm_delete ========
  *  Purpose:
  *      Delete the STRM Manager Object.
  */
-void STRM_Delete(struct STRM_MGR *hStrmMgr)
+void strm_delete(struct strm_mgr *strm_mgr_obj)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hStrmMgr, STRMMGR_SIGNATURE));
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(strm_mgr_obj, STRMMGR_SIGNATURE));
 
-	GT_1trace(STRM_debugMask, GT_ENTER, "STRM_Delete: hStrmMgr: 0x%x\n",
-		 hStrmMgr);
+	delete_strm_mgr(strm_mgr_obj);
 
-	DeleteStrmMgr(hStrmMgr);
-
-	DBC_Ensure(!MEM_IsValidHandle(hStrmMgr, STRMMGR_SIGNATURE));
+	DBC_ENSURE(!MEM_IS_VALID_HANDLE(strm_mgr_obj, STRMMGR_SIGNATURE));
 }
 
 /*
- *  ======== STRM_Exit ========
+ *  ======== strm_exit ========
  *  Purpose:
  *      Discontinue usage of STRM module.
  */
-void STRM_Exit(void)
+void strm_exit(void)
 {
-	DBC_Require(cRefs > 0);
-
-	cRefs--;
+	DBC_REQUIRE(refs > 0);
 
-	GT_1trace(STRM_debugMask, GT_5CLASS,
-		 "Entered STRM_Exit, ref count:  0x%x\n", cRefs);
+	refs--;
 
-	DBC_Ensure(cRefs >= 0);
+	DBC_ENSURE(refs >= 0);
 }
 
 /*
- *  ======== STRM_FreeBuffer ========
+ *  ======== strm_free_buffer ========
  *  Purpose:
  *      Frees the buffers allocated for a stream.
  */
-DSP_STATUS STRM_FreeBuffer(struct STRM_OBJECT *hStrm, u8 **apBuffer,
-		u32 uNumBufs, struct PROCESS_CONTEXT *pr_ctxt)
+dsp_status strm_free_buffer(struct strm_object *hStrm, u8 ** ap_buffer,
+			    u32 num_bufs, struct process_context *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 	u32 i = 0;
 
-#ifndef RES_CLEANUP_DISABLE
-	HANDLE hSTRMRes = NULL;
-#endif
-	DBC_Require(cRefs > 0);
-	DBC_Require(apBuffer != NULL);
+	bhandle hstrm_res = NULL;
 
-	GT_3trace(STRM_debugMask, GT_ENTER, "STRM_FreeBuffer: hStrm: 0x%x\t"
-		 "apBuffer: 0x%x\tuNumBufs: 0x%x\n", hStrm, apBuffer, uNumBufs);
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(ap_buffer != NULL);
 
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE))
+	if (!MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE))
 		status = DSP_EHANDLE;
 
 	if (DSP_SUCCEEDED(status)) {
-		for (i = 0; i < uNumBufs; i++) {
-			DBC_Assert(hStrm->hXlator != NULL);
-			status = CMM_XlatorFreeBuf(hStrm->hXlator, apBuffer[i]);
-			if (DSP_FAILED(status)) {
-				GT_0trace(STRM_debugMask, GT_7CLASS,
-					 "STRM_FreeBuffer: DSP_FAILED"
-					 " to free shared memory.\n");
+		for (i = 0; i < num_bufs; i++) {
+			DBC_ASSERT(hStrm->xlator != NULL);
+			status =
+			    cmm_xlator_free_buf(hStrm->xlator, ap_buffer[i]);
+			if (DSP_FAILED(status))
 				break;
-			}
-			apBuffer[i] = NULL;
+			ap_buffer[i] = NULL;
 		}
 	}
-#ifndef RES_CLEANUP_DISABLE
-	if (DRV_GetSTRMResElement(hStrm, hSTRMRes, pr_ctxt) !=
-			DSP_ENOTFOUND) {
-		DRV_ProcUpdateSTRMRes(uNumBufs-i, hSTRMRes, pr_ctxt);
-	}
-#endif
+	if (drv_get_strm_res_element(hStrm, hstrm_res, pr_ctxt) !=
+	    DSP_ENOTFOUND)
+		drv_proc_update_strm_res(num_bufs - i, hstrm_res);
+
 	return status;
 }
 
 /*
- *  ======== STRM_GetInfo ========
+ *  ======== strm_get_info ========
  *  Purpose:
  *      Retrieves information about a stream.
  */
-DSP_STATUS STRM_GetInfo(struct STRM_OBJECT *hStrm,
-			OUT struct STRM_INFO *pStreamInfo,
-			u32 uStreamInfoSize)
-{
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct CHNL_INFO chnlInfo;
-	DSP_STATUS status = DSP_SOK;
-	void *pVirtBase = NULL;	/* NULL if no SM used */
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pStreamInfo != NULL);
-	DBC_Require(uStreamInfoSize >= sizeof(struct STRM_INFO));
-
-	GT_3trace(STRM_debugMask, GT_ENTER, "STRM_GetInfo: hStrm: 0x%x\t"
-		 "pStreamInfo: 0x%x\tuStreamInfoSize: 0x%x\n", hStrm,
-		 pStreamInfo, uStreamInfoSize);
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+dsp_status strm_get_info(struct strm_object *hStrm,
+			 OUT struct stream_info *stream_info,
+			 u32 stream_info_size)
+{
+	struct bridge_drv_interface *intf_fxns;
+	struct chnl_info chnl_info_obj;
+	dsp_status status = DSP_SOK;
+	void *virt_base = NULL;	/* NULL if no SM used */
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(stream_info != NULL);
+	DBC_REQUIRE(stream_info_size >= sizeof(struct stream_info));
+
+	if (!MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE)) {
 		status = DSP_EHANDLE;
 	} else {
-		if (uStreamInfoSize < sizeof(struct STRM_INFO)) {
+		if (stream_info_size < sizeof(struct stream_info)) {
 			/* size of users info */
 			status = DSP_ESIZE;
 		}
@@ -434,36 +342,38 @@
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
-	status = (*pIntfFxns->pfnChnlGetInfo) (hStrm->hChnl, &chnlInfo);
+	intf_fxns = hStrm->strm_mgr_obj->intf_fxns;
+	status =
+	    (*intf_fxns->pfn_chnl_get_info) (hStrm->chnl_obj, &chnl_info_obj);
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	if (hStrm->hXlator) {
+	if (hStrm->xlator) {
 		/* We have a translator */
-		DBC_Assert(hStrm->uSegment > 0);
-		CMM_XlatorInfo(hStrm->hXlator, (u8 **)&pVirtBase, 0,
-			      hStrm->uSegment, false);
-	}
-	pStreamInfo->uSegment = hStrm->uSegment;
-	pStreamInfo->lMode = hStrm->lMode;
-	pStreamInfo->pVirtBase = pVirtBase;
-	pStreamInfo->pUser->uNumberBufsAllowed = hStrm->uNumBufs;
-	pStreamInfo->pUser->uNumberBufsInStream = chnlInfo.cIOCs +
-						 chnlInfo.cIOReqs;
+		DBC_ASSERT(hStrm->segment_id > 0);
+		cmm_xlator_info(hStrm->xlator, (u8 **) &virt_base, 0,
+				hStrm->segment_id, false);
+	}
+	stream_info->segment_id = hStrm->segment_id;
+	stream_info->strm_mode = hStrm->strm_mode;
+	stream_info->virt_base = virt_base;
+	stream_info->user_strm->number_bufs_allowed = hStrm->num_bufs;
+	stream_info->user_strm->number_bufs_in_stream = chnl_info_obj.cio_cs +
+	    chnl_info_obj.cio_reqs;
 	/* # of bytes transferred since last call to DSPStream_Idle() */
-	pStreamInfo->pUser->ulNumberBytes = chnlInfo.cPosition;
-	pStreamInfo->pUser->hSyncObjectHandle = chnlInfo.hEvent;
+	stream_info->user_strm->ul_number_bytes = chnl_info_obj.bytes_tx;
+	stream_info->user_strm->sync_object_handle = chnl_info_obj.event_obj;
 	/* Determine stream state based on channel state and info */
-	if (chnlInfo.dwState & CHNL_STATEEOS) {
-		pStreamInfo->pUser->ssStreamState = STREAM_DONE;
+	if (chnl_info_obj.dw_state & CHNL_STATEEOS) {
+		stream_info->user_strm->ss_stream_state = STREAM_DONE;
 	} else {
-		if (chnlInfo.cIOCs > 0)
-			pStreamInfo->pUser->ssStreamState = STREAM_READY;
-		else if (chnlInfo.cIOReqs > 0)
-			pStreamInfo->pUser->ssStreamState = STREAM_PENDING;
+		if (chnl_info_obj.cio_cs > 0)
+			stream_info->user_strm->ss_stream_state = STREAM_READY;
+		else if (chnl_info_obj.cio_reqs > 0)
+			stream_info->user_strm->ss_stream_state =
+			    STREAM_PENDING;
 		else
-			pStreamInfo->pUser->ssStreamState = STREAM_IDLE;
+			stream_info->user_strm->ss_stream_state = STREAM_IDLE;
 
 	}
 func_end:
@@ -471,432 +381,394 @@
 }
 
 /*
- *  ======== STRM_Idle ========
+ *  ======== strm_idle ========
  *  Purpose:
  *      Idles a particular stream.
  */
-DSP_STATUS STRM_Idle(struct STRM_OBJECT *hStrm, bool fFlush)
+dsp_status strm_idle(struct strm_object *hStrm, bool fFlush)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
+	struct bridge_drv_interface *intf_fxns;
+	dsp_status status = DSP_SOK;
 
-	GT_2trace(STRM_debugMask, GT_ENTER, "STRM_Idle: hStrm: 0x%x\t"
-		 "fFlush: 0x%x\n", hStrm, fFlush);
+	DBC_REQUIRE(refs > 0);
 
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE)) {
 		status = DSP_EHANDLE;
 	} else {
-		pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+		intf_fxns = hStrm->strm_mgr_obj->intf_fxns;
 
-		status = (*pIntfFxns->pfnChnlIdle) (hStrm->hChnl,
-			 hStrm->uTimeout, fFlush);
+		status = (*intf_fxns->pfn_chnl_idle) (hStrm->chnl_obj,
+						      hStrm->utimeout, fFlush);
 	}
+
+	dev_dbg(bridge, "%s: hStrm: %p fFlush: 0x%x status: 0x%x\n",
+		__func__, hStrm, fFlush, status);
 	return status;
 }
 
 /*
- *  ======== STRM_Init ========
+ *  ======== strm_init ========
  *  Purpose:
  *      Initialize the STRM module.
  */
-bool STRM_Init(void)
+bool strm_init(void)
 {
-	bool fRetVal = true;
-
-	DBC_Require(cRefs >= 0);
+	bool ret = true;
 
-	if (cRefs == 0) {
-#if GT_TRACE
-		DBC_Assert(!STRM_debugMask.flags);
-		GT_create(&STRM_debugMask, "ST");	/* "ST" for STrm */
-#endif
-	}
+	DBC_REQUIRE(refs >= 0);
 
-	if (fRetVal)
-		cRefs++;
+	if (ret)
+		refs++;
 
-	GT_1trace(STRM_debugMask, GT_5CLASS, "STRM_Init(), ref count: 0x%x\n",
-		 cRefs);
+	DBC_ENSURE((ret && (refs > 0)) || (!ret && (refs >= 0)));
 
-	DBC_Ensure((fRetVal && (cRefs > 0)) || (!fRetVal && (cRefs >= 0)));
-
-	return fRetVal;
+	return ret;
 }
 
 /*
- *  ======== STRM_Issue ========
+ *  ======== strm_issue ========
  *  Purpose:
  *      Issues a buffer on a stream
  */
-DSP_STATUS STRM_Issue(struct STRM_OBJECT *hStrm, IN u8 *pBuf, u32 ulBytes,
-		     u32 ulBufSize, u32 dwArg)
+dsp_status strm_issue(struct strm_object *hStrm, IN u8 *pbuf, u32 ul_bytes,
+		      u32 ul_buf_size, u32 dw_arg)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	DSP_STATUS status = DSP_SOK;
-	void *pTmpBuf = NULL;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pBuf != NULL);
-
-	GT_4trace(STRM_debugMask, GT_ENTER, "STRM_Issue: hStrm: 0x%x\tpBuf: "
-		 "0x%x\tulBytes: 0x%x\tdwArg: 0x%x\n", hStrm, pBuf, ulBytes,
-		 dwArg);
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+	struct bridge_drv_interface *intf_fxns;
+	dsp_status status = DSP_SOK;
+	void *tmp_buf = NULL;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(pbuf != NULL);
+
+	if (!MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE)) {
 		status = DSP_EHANDLE;
 	} else {
-		pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+		intf_fxns = hStrm->strm_mgr_obj->intf_fxns;
 
-		if (hStrm->uSegment != 0) {
-			pTmpBuf = CMM_XlatorTranslate(hStrm->hXlator,
-					(void *)pBuf, CMM_VA2DSPPA);
-			if (pTmpBuf == NULL)
+		if (hStrm->segment_id != 0) {
+			tmp_buf = cmm_xlator_translate(hStrm->xlator,
+						       (void *)pbuf,
+						       CMM_VA2DSPPA);
+			if (tmp_buf == NULL)
 				status = DSP_ETRANSLATE;
 
 		}
 		if (DSP_SUCCEEDED(status)) {
-			status = (*pIntfFxns->pfnChnlAddIOReq)
-				 (hStrm->hChnl, pBuf, ulBytes, ulBufSize,
-				 (u32) pTmpBuf, dwArg);
-		}
-		if (DSP_FAILED(status)) {
-			if (status == CHNL_E_NOIORPS)
-				status = DSP_ESTREAMFULL;
-			else
-				status = DSP_EFAIL;
-
+			status = (*intf_fxns->pfn_chnl_add_io_req)
+			    (hStrm->chnl_obj, pbuf, ul_bytes, ul_buf_size,
+			     (u32) tmp_buf, dw_arg);
 		}
+		if (status == CHNL_E_NOIORPS)
+			status = DSP_ESTREAMFULL;
 	}
+
+	dev_dbg(bridge, "%s: hStrm: %p pbuf: %p ul_bytes: 0x%x dw_arg: 0x%x "
+		"status: 0x%x\n", __func__, hStrm, pbuf,
+		ul_bytes, dw_arg, status);
 	return status;
 }
 
 /*
- *  ======== STRM_Open ========
+ *  ======== strm_open ========
  *  Purpose:
  *      Open a stream for sending/receiving data buffers to/from a task or
  *      XDAIS socket node on the DSP.
  */
-DSP_STATUS STRM_Open(struct NODE_OBJECT *hNode, u32 uDir, u32 uIndex,
-		    IN struct STRM_ATTR *pAttr,
-		    OUT struct STRM_OBJECT **phStrm,
-		    struct PROCESS_CONTEXT *pr_ctxt)
-{
-	struct STRM_MGR *hStrmMgr;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	u32 ulChnlId;
-	struct STRM_OBJECT *pStrm = NULL;
-	CHNL_MODE uMode;
-	struct CHNL_ATTRS chnlAttrs;
-	DSP_STATUS status = DSP_SOK;
-	struct CMM_OBJECT *hCmmMgr = NULL;	/* Shared memory manager hndl */
-
-#ifndef RES_CLEANUP_DISABLE
-	HANDLE              hSTRMRes;
-#endif
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(phStrm != NULL);
-	DBC_Require(pAttr != NULL);
-	GT_5trace(STRM_debugMask, GT_ENTER,
-		 "STRM_Open: hNode: 0x%x\tuDir: 0x%x\t"
-		 "uIndex: 0x%x\tpAttr: 0x%x\tphStrm: 0x%x\n",
-		 hNode, uDir, uIndex, pAttr, phStrm);
+dsp_status strm_open(struct node_object *hnode, u32 dir, u32 index,
+		     IN struct strm_attr *pattr,
+		     OUT struct strm_object **phStrm,
+		     struct process_context *pr_ctxt)
+{
+	struct strm_mgr *strm_mgr_obj;
+	struct bridge_drv_interface *intf_fxns;
+	u32 ul_chnl_id;
+	struct strm_object *strm_obj = NULL;
+	short int chnl_mode;
+	struct chnl_attr chnl_attr_obj;
+	dsp_status status = DSP_SOK;
+	struct cmm_object *hcmm_mgr = NULL;	/* Shared memory manager hndl */
+
+	bhandle hstrm_res;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(phStrm != NULL);
+	DBC_REQUIRE(pattr != NULL);
 	*phStrm = NULL;
-	if (uDir != DSP_TONODE && uDir != DSP_FROMNODE) {
+	if (dir != DSP_TONODE && dir != DSP_FROMNODE) {
 		status = DSP_EDIRECTION;
 	} else {
-		/* Get the channel id from the node (set in NODE_Connect()) */
-		status = NODE_GetChannelId(hNode, uDir, uIndex, &ulChnlId);
+		/* Get the channel id from the node (set in node_connect()) */
+		status = node_get_channel_id(hnode, dir, index, &ul_chnl_id);
 	}
 	if (DSP_SUCCEEDED(status))
-		status = NODE_GetStrmMgr(hNode, &hStrmMgr);
+		status = node_get_strm_mgr(hnode, &strm_mgr_obj);
 
 	if (DSP_SUCCEEDED(status)) {
-		MEM_AllocObject(pStrm, struct STRM_OBJECT, STRM_SIGNATURE);
-		if (pStrm == NULL) {
+		MEM_ALLOC_OBJECT(strm_obj, struct strm_object, STRM_SIGNATURE);
+		if (strm_obj == NULL) {
 			status = DSP_EMEMORY;
-			GT_0trace(STRM_debugMask, GT_6CLASS,
-				 "STRM_Open: MEM_AllocObject() failed!\n ");
 		} else {
-			pStrm->hStrmMgr = hStrmMgr;
-			pStrm->uDir = uDir;
-			pStrm->strmState = STREAM_IDLE;
-			pStrm->hUserEvent = pAttr->hUserEvent;
-			if (pAttr->pStreamAttrIn != NULL) {
-				pStrm->uTimeout = pAttr->pStreamAttrIn->
-						  uTimeout;
-				pStrm->uNumBufs = pAttr->pStreamAttrIn->
-						  uNumBufs;
-				pStrm->lMode = pAttr->pStreamAttrIn->lMode;
-				pStrm->uSegment = pAttr->pStreamAttrIn->
-						  uSegment;
-				pStrm->uAlignment = pAttr->pStreamAttrIn->
-						    uAlignment;
-				pStrm->uDMAChnlId = pAttr->pStreamAttrIn->
-						    uDMAChnlId;
-				pStrm->uDMAPriority = pAttr->pStreamAttrIn->
-						      uDMAPriority;
-				chnlAttrs.uIOReqs = pAttr->pStreamAttrIn->
-						    uNumBufs;
+			strm_obj->strm_mgr_obj = strm_mgr_obj;
+			strm_obj->dir = dir;
+			strm_obj->strm_state = STREAM_IDLE;
+			strm_obj->user_event = pattr->user_event;
+			if (pattr->stream_attr_in != NULL) {
+				strm_obj->utimeout =
+				    pattr->stream_attr_in->utimeout;
+				strm_obj->num_bufs =
+				    pattr->stream_attr_in->num_bufs;
+				strm_obj->strm_mode =
+				    pattr->stream_attr_in->strm_mode;
+				strm_obj->segment_id =
+				    pattr->stream_attr_in->segment_id;
+				strm_obj->buf_alignment =
+				    pattr->stream_attr_in->buf_alignment;
+				strm_obj->udma_chnl_id =
+				    pattr->stream_attr_in->udma_chnl_id;
+				strm_obj->udma_priority =
+				    pattr->stream_attr_in->udma_priority;
+				chnl_attr_obj.uio_reqs =
+				    pattr->stream_attr_in->num_bufs;
 			} else {
-				pStrm->uTimeout = DEFAULTTIMEOUT;
-				pStrm->uNumBufs = DEFAULTNUMBUFS;
-				pStrm->lMode = STRMMODE_PROCCOPY;
-				pStrm->uSegment = 0;	/* local memory */
-				pStrm->uAlignment = 0;
-				pStrm->uDMAChnlId = 0;
-				pStrm->uDMAPriority = 0;
-				chnlAttrs.uIOReqs = DEFAULTNUMBUFS;
+				strm_obj->utimeout = DEFAULTTIMEOUT;
+				strm_obj->num_bufs = DEFAULTNUMBUFS;
+				strm_obj->strm_mode = STRMMODE_PROCCOPY;
+				strm_obj->segment_id = 0;	/* local mem */
+				strm_obj->buf_alignment = 0;
+				strm_obj->udma_chnl_id = 0;
+				strm_obj->udma_priority = 0;
+				chnl_attr_obj.uio_reqs = DEFAULTNUMBUFS;
 			}
-			chnlAttrs.hReserved1 = NULL;
+			chnl_attr_obj.reserved1 = NULL;
 			/* DMA chnl flush timeout */
-			chnlAttrs.hReserved2 = pStrm->uTimeout;
-			chnlAttrs.hEvent = NULL;
-			if (pAttr->hUserEvent != NULL)
-				chnlAttrs.hEvent = pAttr->hUserEvent;
+			chnl_attr_obj.reserved2 = strm_obj->utimeout;
+			chnl_attr_obj.event_obj = NULL;
+			if (pattr->user_event != NULL)
+				chnl_attr_obj.event_obj = pattr->user_event;
 
 		}
 	}
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-	if ((pAttr->pVirtBase == NULL) || !(pAttr->ulVirtSize > 0))
+	if ((pattr->virt_base == NULL) || !(pattr->ul_virt_size > 0))
 		goto func_cont;
 
-	DBC_Assert(pStrm->lMode != STRMMODE_LDMA);	/* no System DMA */
+	/* No System DMA */
+	DBC_ASSERT(strm_obj->strm_mode != STRMMODE_LDMA);
 	/* Get the shared mem mgr for this streams dev object */
-	status = DEV_GetCmmMgr(hStrmMgr->hDev, &hCmmMgr);
-	if (DSP_FAILED(status)) {
-		GT_1trace(STRM_debugMask, GT_6CLASS, "STRM_Open: Failed to get "
-			 "CMM Mgr handle: 0x%x\n", status);
-	} else {
-		/*Allocate a SM addr translator for this strm.*/
-		status = CMM_XlatorCreate(&pStrm->hXlator, hCmmMgr, NULL);
-		if (DSP_FAILED(status)) {
-			GT_1trace(STRM_debugMask, GT_6CLASS,
-				 "STRM_Open: Failed to "
-				 "create SM translator: 0x%x\n", status);
-		} else {
-			DBC_Assert(pStrm->uSegment > 0);
+	status = dev_get_cmm_mgr(strm_mgr_obj->dev_obj, &hcmm_mgr);
+	if (DSP_SUCCEEDED(status)) {
+		/*Allocate a SM addr translator for this strm. */
+		status = cmm_xlator_create(&strm_obj->xlator, hcmm_mgr, NULL);
+		if (DSP_SUCCEEDED(status)) {
+			DBC_ASSERT(strm_obj->segment_id > 0);
 			/*  Set translators Virt Addr attributes */
-			status = CMM_XlatorInfo(pStrm->hXlator,
-				 (u8 **)&pAttr->pVirtBase, pAttr->ulVirtSize,
-				 pStrm->uSegment, true);
-			if (status != DSP_SOK) {
-				GT_0trace(STRM_debugMask, GT_6CLASS,
-					 "STRM_Open: ERROR: "
-					 "in setting CMM_XlatorInfo.\n");
-			}
+			status = cmm_xlator_info(strm_obj->xlator,
+						 (u8 **) &pattr->virt_base,
+						 pattr->ul_virt_size,
+						 strm_obj->segment_id, true);
 		}
 	}
 func_cont:
 	if (DSP_SUCCEEDED(status)) {
 		/* Open channel */
-		uMode = (uDir == DSP_TONODE) ?
-			CHNL_MODETODSP : CHNL_MODEFROMDSP;
-		pIntfFxns = hStrmMgr->pIntfFxns;
-		status = (*pIntfFxns->pfnChnlOpen) (&(pStrm->hChnl),
-			 hStrmMgr->hChnlMgr, uMode, ulChnlId, &chnlAttrs);
+		chnl_mode = (dir == DSP_TONODE) ?
+		    CHNL_MODETODSP : CHNL_MODEFROMDSP;
+		intf_fxns = strm_mgr_obj->intf_fxns;
+		status = (*intf_fxns->pfn_chnl_open) (&(strm_obj->chnl_obj),
+						      strm_mgr_obj->hchnl_mgr,
+						      chnl_mode, ul_chnl_id,
+						      &chnl_attr_obj);
 		if (DSP_FAILED(status)) {
 			/*
 			 * over-ride non-returnable status codes so we return
 			 * something documented
 			 */
 			if (status != DSP_EMEMORY && status !=
-			   DSP_EINVALIDARG && status != DSP_EFAIL) {
+			    DSP_EINVALIDARG && status != DSP_EFAIL) {
 				/*
 				 * We got a status that's not return-able.
 				 * Assert that we got something we were
 				 * expecting (DSP_EHANDLE isn't acceptable,
-				 * hStrmMgr->hChnlMgr better be valid or we
+				 * strm_mgr_obj->hchnl_mgr better be valid or we
 				 * assert here), and then return DSP_EFAIL.
 				 */
-				DBC_Assert(status == CHNL_E_OUTOFSTREAMS ||
+				DBC_ASSERT(status == CHNL_E_OUTOFSTREAMS ||
 					   status == CHNL_E_BADCHANID ||
 					   status == CHNL_E_CHANBUSY ||
 					   status == CHNL_E_NOIORPS);
 				status = DSP_EFAIL;
 			}
-			GT_2trace(STRM_debugMask, GT_6CLASS,
-				  "STRM_Open: Channel open failed, "
-				  "chnl id = %d, status = 0x%x\n", ulChnlId,
-				  status);
 		}
 	}
-	if (DSP_SUCCEEDED(status))
-		*phStrm = pStrm;
-	else
-		(void)DeleteStrm(pStrm);
+	if (DSP_SUCCEEDED(status)) {
+		*phStrm = strm_obj;
+		drv_proc_insert_strm_res_element(*phStrm, &hstrm_res, pr_ctxt);
+	} else {
+		(void)delete_strm(strm_obj);
+	}
 
-#ifndef RES_CLEANUP_DISABLE
-	DRV_ProcInsertSTRMResElement(*phStrm, &hSTRMRes, pr_ctxt);
-#endif
+	/* ensure we return a documented error code */
+	DBC_ENSURE((DSP_SUCCEEDED(status) &&
+		    MEM_IS_VALID_HANDLE((*phStrm), STRM_SIGNATURE)) ||
+		   (*phStrm == NULL && (status == DSP_EHANDLE ||
+					status == DSP_EDIRECTION
+					|| status == DSP_EVALUE
+					|| status == DSP_EFAIL)));
 
-	 /* ensure we return a documented error code */
-	DBC_Ensure((DSP_SUCCEEDED(status) &&
-		  MEM_IsValidHandle((*phStrm), STRM_SIGNATURE)) ||
-		  (*phStrm == NULL && (status == DSP_EHANDLE ||
-		  status == DSP_EDIRECTION || status == DSP_EVALUE ||
-		  status == DSP_EFAIL)));
+	dev_dbg(bridge, "%s: hnode: %p dir: 0x%x index: 0x%x pattr: %p "
+		"phStrm: %p status: 0x%x\n", __func__,
+		hnode, dir, index, pattr, phStrm, status);
 	return status;
 }
 
 /*
- *  ======== STRM_Reclaim ========
+ *  ======== strm_reclaim ========
  *  Purpose:
  *      Relcaims a buffer from a stream.
  */
-DSP_STATUS STRM_Reclaim(struct STRM_OBJECT *hStrm, OUT u8 **pBufPtr,
-			u32 *pulBytes, u32 *pulBufSize, u32 *pdwArg)
+dsp_status strm_reclaim(struct strm_object *hStrm, OUT u8 ** buf_ptr,
+			u32 *pulBytes, u32 *pulBufSize, u32 *pdw_arg)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct CHNL_IOC chnlIOC;
-	DSP_STATUS status = DSP_SOK;
-	void *pTmpBuf = NULL;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pBufPtr != NULL);
-	DBC_Require(pulBytes != NULL);
-	DBC_Require(pdwArg != NULL);
-
-	GT_4trace(STRM_debugMask, GT_ENTER,
-		 "STRM_Reclaim: hStrm: 0x%x\tpBufPtr: 0x%x"
-		 "\tpulBytes: 0x%x\tpdwArg: 0x%x\n", hStrm, pBufPtr, pulBytes,
-		 pdwArg);
+	struct bridge_drv_interface *intf_fxns;
+	struct chnl_ioc chnl_ioc_obj;
+	dsp_status status = DSP_SOK;
+	void *tmp_buf = NULL;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(buf_ptr != NULL);
+	DBC_REQUIRE(pulBytes != NULL);
+	DBC_REQUIRE(pdw_arg != NULL);
 
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
-	pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+	intf_fxns = hStrm->strm_mgr_obj->intf_fxns;
 
-	status = (*pIntfFxns->pfnChnlGetIOC)(hStrm->hChnl, hStrm->uTimeout,
-		 &chnlIOC);
-	if (DSP_FAILED(status)) {
-		GT_1trace(STRM_debugMask, GT_6CLASS,
-			 "STRM_Reclaim: GetIOC failed! "
-			 "Status = 0x%x\n", status);
-	} else {
-		*pulBytes = chnlIOC.cBytes;
+	status =
+	    (*intf_fxns->pfn_chnl_get_ioc) (hStrm->chnl_obj, hStrm->utimeout,
+					    &chnl_ioc_obj);
+	if (DSP_SUCCEEDED(status)) {
+		*pulBytes = chnl_ioc_obj.byte_size;
 		if (pulBufSize)
-			*pulBufSize = chnlIOC.cBufSize;
+			*pulBufSize = chnl_ioc_obj.buf_size;
 
-		*pdwArg = chnlIOC.dwArg;
-		if (!CHNL_IsIOComplete(chnlIOC)) {
-			if (CHNL_IsTimedOut(chnlIOC)) {
+		*pdw_arg = chnl_ioc_obj.dw_arg;
+		if (!CHNL_IS_IO_COMPLETE(chnl_ioc_obj)) {
+			if (CHNL_IS_TIMED_OUT(chnl_ioc_obj)) {
 				status = DSP_ETIMEOUT;
 			} else {
 				/* Allow reclaims after idle to succeed */
-				if (!CHNL_IsIOCancelled(chnlIOC))
+				if (!CHNL_IS_IO_CANCELLED(chnl_ioc_obj))
 					status = DSP_EFAIL;
 
 			}
 		}
 		/* Translate zerocopy buffer if channel not canceled. */
-		if (DSP_SUCCEEDED(status) && (!CHNL_IsIOCancelled(chnlIOC)) &&
-		   (hStrm->lMode == STRMMODE_ZEROCOPY)) {
+		if (DSP_SUCCEEDED(status)
+		    && (!CHNL_IS_IO_CANCELLED(chnl_ioc_obj))
+		    && (hStrm->strm_mode == STRMMODE_ZEROCOPY)) {
 			/*
-			 *  This is a zero-copy channel so chnlIOC.pBuf
+			 *  This is a zero-copy channel so chnl_ioc_obj.pbuf
 			 *  contains the DSP address of SM. We need to
 			 *  translate it to a virtual address for the user
 			 *  thread to access.
 			 *  Note: Could add CMM_DSPPA2VA to CMM in the future.
 			 */
-			pTmpBuf = CMM_XlatorTranslate(hStrm->hXlator,
-					chnlIOC.pBuf, CMM_DSPPA2PA);
-			if (pTmpBuf != NULL) {
+			tmp_buf = cmm_xlator_translate(hStrm->xlator,
+						       chnl_ioc_obj.pbuf,
+						       CMM_DSPPA2PA);
+			if (tmp_buf != NULL) {
 				/* now convert this GPP Pa to Va */
-				pTmpBuf = CMM_XlatorTranslate(hStrm->hXlator,
-					  pTmpBuf, CMM_PA2VA);
+				tmp_buf = cmm_xlator_translate(hStrm->xlator,
+							       tmp_buf,
+							       CMM_PA2VA);
 			}
-			if (pTmpBuf == NULL) {
-				GT_0trace(STRM_debugMask, GT_7CLASS,
-					 "STRM_Reclaim: Failed "
-					 "SM translation!\n");
+			if (tmp_buf == NULL)
 				status = DSP_ETRANSLATE;
-			}
-			chnlIOC.pBuf = pTmpBuf;
+
+			chnl_ioc_obj.pbuf = tmp_buf;
 		}
-		*pBufPtr = chnlIOC.pBuf;
+		*buf_ptr = chnl_ioc_obj.pbuf;
 	}
 func_end:
 	/* ensure we return a documented return code */
-	DBC_Ensure(DSP_SUCCEEDED(status) || status == DSP_EHANDLE ||
-		  status == DSP_ETIMEOUT || status == DSP_ETRANSLATE ||
-		  status == DSP_EFAIL);
+	DBC_ENSURE(DSP_SUCCEEDED(status) || status == DSP_EHANDLE ||
+		   status == DSP_ETIMEOUT || status == DSP_ETRANSLATE ||
+		   status == DSP_EFAIL);
+
+	dev_dbg(bridge, "%s: hStrm: %p buf_ptr: %p pulBytes: %p pdw_arg: %p "
+		"status 0x%x\n", __func__, hStrm,
+		buf_ptr, pulBytes, pdw_arg, status);
 	return status;
 }
 
 /*
- *  ======== STRM_RegisterNotify ========
+ *  ======== strm_register_notify ========
  *  Purpose:
  *      Register to be notified on specific events for this stream.
  */
-DSP_STATUS STRM_RegisterNotify(struct STRM_OBJECT *hStrm, u32 uEventMask,
-			      u32 uNotifyType, struct DSP_NOTIFICATION
-			      *hNotification)
-{
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(hNotification != NULL);
-
-	GT_4trace(STRM_debugMask, GT_ENTER,
-		 "STRM_RegisterNotify: hStrm: 0x%x\t"
-		 "uEventMask: 0x%x\tuNotifyType: 0x%x\thNotification: 0x%x\n",
-		 hStrm, uEventMask, uNotifyType, hNotification);
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+dsp_status strm_register_notify(struct strm_object *hStrm, u32 event_mask,
+				u32 notify_type, struct dsp_notification
+				* hnotification)
+{
+	struct bridge_drv_interface *intf_fxns;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(hnotification != NULL);
+
+	if (!MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE)) {
 		status = DSP_EHANDLE;
-	} else if ((uEventMask & ~((DSP_STREAMIOCOMPLETION) |
-		 DSP_STREAMDONE)) != 0) {
+	} else if ((event_mask & ~((DSP_STREAMIOCOMPLETION) |
+				   DSP_STREAMDONE)) != 0) {
 		status = DSP_EVALUE;
 	} else {
-		if (uNotifyType != DSP_SIGNALEVENT)
+		if (notify_type != DSP_SIGNALEVENT)
 			status = DSP_ENOTIMPL;
 
 	}
 	if (DSP_SUCCEEDED(status)) {
-		pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+		intf_fxns = hStrm->strm_mgr_obj->intf_fxns;
 
-		status = (*pIntfFxns->pfnChnlRegisterNotify)(hStrm->hChnl,
-			 uEventMask, uNotifyType, hNotification);
+		status =
+		    (*intf_fxns->pfn_chnl_register_notify) (hStrm->chnl_obj,
+							    event_mask,
+							    notify_type,
+							    hnotification);
 	}
 	/* ensure we return a documented return code */
-	DBC_Ensure(DSP_SUCCEEDED(status) || status == DSP_EHANDLE ||
-		  status == DSP_ETIMEOUT || status == DSP_ETRANSLATE ||
-		  status == DSP_ENOTIMPL || status == DSP_EFAIL);
+	DBC_ENSURE(DSP_SUCCEEDED(status) || status == DSP_EHANDLE ||
+		   status == DSP_ETIMEOUT || status == DSP_ETRANSLATE ||
+		   status == DSP_ENOTIMPL || status == DSP_EFAIL);
 	return status;
 }
 
 /*
- *  ======== STRM_Select ========
+ *  ======== strm_select ========
  *  Purpose:
  *      Selects a ready stream.
  */
-DSP_STATUS STRM_Select(IN struct STRM_OBJECT **aStrmTab, u32 nStrms,
-		      OUT u32 *pMask, u32 uTimeout)
+dsp_status strm_select(IN struct strm_object **strm_tab, u32 nStrms,
+		       OUT u32 *pmask, u32 utimeout)
 {
-	u32 uIndex;
-	struct CHNL_INFO chnlInfo;
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	struct SYNC_OBJECT **hSyncEvents = NULL;
+	u32 index;
+	struct chnl_info chnl_info_obj;
+	struct bridge_drv_interface *intf_fxns;
+	struct sync_object **sync_events = NULL;
 	u32 i;
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(cRefs > 0);
-	DBC_Require(aStrmTab != NULL);
-	DBC_Require(pMask != NULL);
-	DBC_Require(nStrms > 0);
-
-	GT_4trace(STRM_debugMask, GT_ENTER,
-		 "STRM_Select: aStrmTab: 0x%x \tnStrms: "
-		 "0x%x\tpMask: 0x%x\tuTimeout: 0x%x\n", aStrmTab,
-		 nStrms, pMask, uTimeout);
-	*pMask = 0;
+	DBC_REQUIRE(refs > 0);
+	DBC_REQUIRE(strm_tab != NULL);
+	DBC_REQUIRE(pmask != NULL);
+	DBC_REQUIRE(nStrms > 0);
+
+	*pmask = 0;
 	for (i = 0; i < nStrms; i++) {
-		if (!MEM_IsValidHandle(aStrmTab[i], STRM_SIGNATURE)) {
+		if (!MEM_IS_VALID_HANDLE(strm_tab[i], STRM_SIGNATURE)) {
 			status = DSP_EHANDLE;
 			break;
 		}
@@ -906,82 +778,85 @@
 
 	/* Determine which channels have IO ready */
 	for (i = 0; i < nStrms; i++) {
-		pIntfFxns = aStrmTab[i]->hStrmMgr->pIntfFxns;
-		status = (*pIntfFxns->pfnChnlGetInfo)(aStrmTab[i]->hChnl,
-			 &chnlInfo);
+		intf_fxns = strm_tab[i]->strm_mgr_obj->intf_fxns;
+		status = (*intf_fxns->pfn_chnl_get_info) (strm_tab[i]->chnl_obj,
+							  &chnl_info_obj);
 		if (DSP_FAILED(status)) {
 			break;
 		} else {
-			if (chnlInfo.cIOCs > 0)
-				*pMask |= (1 << i);
+			if (chnl_info_obj.cio_cs > 0)
+				*pmask |= (1 << i);
 
 		}
 	}
-	if (DSP_SUCCEEDED(status) && uTimeout > 0 && *pMask == 0) {
+	if (DSP_SUCCEEDED(status) && utimeout > 0 && *pmask == 0) {
 		/* Non-zero timeout */
-		hSyncEvents = (struct SYNC_OBJECT **)MEM_Alloc(nStrms *
-			      sizeof(struct SYNC_OBJECT *), MEM_PAGED);
-		if (hSyncEvents == NULL) {
+		sync_events = (struct sync_object **)mem_alloc(nStrms *
+						sizeof(struct sync_object *),
+						MEM_PAGED);
+		if (sync_events == NULL) {
 			status = DSP_EMEMORY;
 		} else {
 			for (i = 0; i < nStrms; i++) {
-				pIntfFxns = aStrmTab[i]->hStrmMgr->pIntfFxns;
-				status = (*pIntfFxns->pfnChnlGetInfo)
-					 (aStrmTab[i]->hChnl, &chnlInfo);
+				intf_fxns =
+				    strm_tab[i]->strm_mgr_obj->intf_fxns;
+				status = (*intf_fxns->pfn_chnl_get_info)
+				    (strm_tab[i]->chnl_obj, &chnl_info_obj);
 				if (DSP_FAILED(status))
 					break;
 				else
-					hSyncEvents[i] = chnlInfo.hSyncEvent;
+					sync_events[i] =
+					    chnl_info_obj.sync_event;
 
 			}
 		}
 		if (DSP_SUCCEEDED(status)) {
-			status = SYNC_WaitOnMultipleEvents(hSyncEvents, nStrms,
-				uTimeout, &uIndex);
+			status =
+			    sync_wait_on_multiple_events(sync_events, nStrms,
+							 utimeout, &index);
 			if (DSP_SUCCEEDED(status)) {
 				/* Since we waited on the event, we have to
 				 * reset it */
-				SYNC_SetEvent(hSyncEvents[uIndex]);
-				*pMask = 1 << uIndex;
+				sync_set_event(sync_events[index]);
+				*pmask = 1 << index;
 			}
 		}
 	}
 func_end:
-	if (hSyncEvents)
-		MEM_Free(hSyncEvents);
+	kfree(sync_events);
 
-	DBC_Ensure((DSP_SUCCEEDED(status) && (*pMask != 0 || uTimeout == 0)) ||
-		  (DSP_FAILED(status) && *pMask == 0));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && (*pmask != 0 || utimeout == 0)) ||
+		   (DSP_FAILED(status) && *pmask == 0));
 
 	return status;
 }
 
 /*
- *  ======== DeleteStrm ========
+ *  ======== delete_strm ========
  *  Purpose:
  *      Frees the resources allocated for a stream.
  */
-static DSP_STATUS DeleteStrm(struct STRM_OBJECT *hStrm)
+static dsp_status delete_strm(struct strm_object *hStrm)
 {
-	struct WMD_DRV_INTERFACE *pIntfFxns;
-	DSP_STATUS status = DSP_SOK;
+	struct bridge_drv_interface *intf_fxns;
+	dsp_status status = DSP_SOK;
 
-	if (MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
-		if (hStrm->hChnl) {
-			pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+	if (MEM_IS_VALID_HANDLE(hStrm, STRM_SIGNATURE)) {
+		if (hStrm->chnl_obj) {
+			intf_fxns = hStrm->strm_mgr_obj->intf_fxns;
 			/* Channel close can fail only if the channel handle
 			 * is invalid. */
-			status = (*pIntfFxns->pfnChnlClose) (hStrm->hChnl);
+			status = (*intf_fxns->pfn_chnl_close) (hStrm->chnl_obj);
 			/* Free all SM address translator resources */
 			if (DSP_SUCCEEDED(status)) {
-				if (hStrm->hXlator) {
+				if (hStrm->xlator) {
 					/* force free */
-					(void)CMM_XlatorDelete(hStrm->hXlator,
-					true);
+					(void)cmm_xlator_delete(hStrm->xlator,
+								true);
 				}
 			}
 		}
-		MEM_FreeObject(hStrm);
+		MEM_FREE_OBJECT(hStrm);
 	} else {
 		status = DSP_EHANDLE;
 	}
@@ -989,18 +864,17 @@
 }
 
 /*
- *  ======== DeleteStrmMgr ========
+ *  ======== delete_strm_mgr ========
  *  Purpose:
  *      Frees stream manager.
  */
-static void DeleteStrmMgr(struct STRM_MGR *hStrmMgr)
+static void delete_strm_mgr(struct strm_mgr *strm_mgr_obj)
 {
-	if (MEM_IsValidHandle(hStrmMgr, STRMMGR_SIGNATURE)) {
+	if (MEM_IS_VALID_HANDLE(strm_mgr_obj, STRMMGR_SIGNATURE)) {
 
-		if (hStrmMgr->hSync)
-			SYNC_DeleteCS(hStrmMgr->hSync);
+		if (strm_mgr_obj->sync_obj)
+			sync_delete_cs(strm_mgr_obj->sync_obj);
 
-		MEM_FreeObject(hStrmMgr);
+		MEM_FREE_OBJECT(strm_mgr_obj);
 	}
 }
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/services/cfg.c kernel-power-2.6.28.new/drivers/dsp/bridge/services/cfg.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/services/cfg.c	2011-10-11 13:51:01.754958718 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/services/cfg.c	2011-10-23 08:22:37.673157000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implementation of platform specific config services.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,64 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== cfgce.c ========
- *  Purpose:
- *      Implementation of platform specific config services.
- *
- *  Private Functions:
- *      CFG_Exit
- *      CFG_GetAutoStart
- *      CFG_GetDevObject
- *      CFG_GetDSPResources
- *      CFG_GetExecFile
- *      CFG_GetHostResources
- *      CFG_GetObject
- *      CFG_Init
- *      CFG_SetDevObject
- *      CFG_SetObject
- *
- *
- *! Revision History:
- *! ================
- *! 26-Arp-2004 hp  Support for handling more than one Device.
- *! 26-Feb-2003 kc  Removed unused CFG fxns.
- *! 10-Nov-2000 rr: CFG_GetBoardName local var initialized.
- *! 30-Oct-2000 kc: Changed local var. names to use Hungarian notation.
- *! 10-Aug-2000 rr: Cosmetic changes.
- *! 26-Jul-2000 rr: Added CFG_GetDCDName. CFG_Get/SetObject(based on a flag)
- *!                  replaces CFG_GetMgrObject & CFG_SetMgrObject.
- *! 17-Jul-2000 rr: Added CFG_GetMgrObject & CFG_SetMgrObject.
- *! 03-Feb-2000 rr: Module init/exit is handled by SERVICES Init/Exit.
- *!		    GT Changes.
- *! 31-Jan-2000 rr: Comments and bugfixes:  modified after code review
- *! 07-Jan-2000 rr: CFG_GetBoardName Ensure class checks strlen of the
- *!                 read value from the registry against the passed in BufSize;
- *!                 CFG_GetZLFile,CFG_GetWMDFileName and
- *!                 CFG_GetExecFile also modified same way.
- *! 06-Jan-2000 rr: CFG_GetSearchPath & CFG_GetWinBRIDGEDir removed.
- *! 09-Dec-1999 rr: CFG_SetDevObject stores the DevNodeString pointer.
- *! 03-Dec-1999 rr: CFG_GetDevObject reads stored DevObject from Registry.
- *!                 CFG_GetDevNode reads the Devnodestring from the registry.
- *!                 CFG_SetDevObject stores the registry path as
- *!                 DevNodestring in the registry.
- *! 02-Dec-1999 rr: CFG_debugMask is declared static now. stdwin.h included
- *! 22-Nov-1999 kc: Added windows.h to remove warnings.
- *! 25-Oct-1999 rr: CFG_GetHostResources reads the HostResource structure
- *!                 from the registry which was set by the DRV Request
- *!                 Resources.
- *! 15-Oct-1999 rr: Changes in CFG_SetPrivateDword & HostResources reflecting
- *!                 changes for  drv.h resource structure and wsxreg.h new
- *!                 entry(DevObject) Hard coded entries removed for those items
- *! 08-Oct-1999 rr: CFG_SetPrivateDword modified. it sets devobject into the
- *!                 registry. CFG_Get HostResources modified for opening up
- *!                 two mem winodws.
- *! 24-Sep-1999 rr: CFG_GetHostResources uses hardcoded Registry calls,uses NT
- *!                 type of Resource Structure.
- *! 19-Jul-1999 a0216266: Stubbed from cfgnt.c.
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
@@ -79,405 +23,298 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/reg.h>
 
-/*  ----------------------------------- Others */
-#include <dspbridge/dbreg.h>
-
 /*  ----------------------------------- This */
 #include <dspbridge/cfg.h>
-#include <dspbridge/list.h>
 
-struct DRV_EXT {
-	struct LST_ELEM link;
-	char szString[MAXREGPATHLENGTH];
+struct drv_ext {
+	struct list_head link;
+	char sz_string[MAXREGPATHLENGTH];
 };
 
-/*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask CFG_debugMask = { NULL, NULL };	/* CFG debug Mask */
-#endif
-
 /*
- *  ======== CFG_Exit ========
+ *  ======== cfg_exit ========
  *  Purpose:
  *      Discontinue usage of the CFG module.
  */
-void CFG_Exit(void)
+void cfg_exit(void)
 {
-	GT_0trace(CFG_debugMask, GT_5CLASS, "Entered CFG_Exit\n");
+	/* Do nothing */
 }
 
 /*
- *  ======== CFG_GetAutoStart ========
+ *  ======== cfg_get_auto_start ========
  *  Purpose:
  *      Retreive the autostart mask, if any, for this board.
  */
-DSP_STATUS CFG_GetAutoStart(struct CFG_DEVNODE *hDevNode,
-			    OUT u32 *pdwAutoStart)
+dsp_status cfg_get_auto_start(struct cfg_devnode *dev_node_obj,
+			      OUT u32 *pdwAutoStart)
 {
-	DSP_STATUS status = DSP_SOK;
-	u32 dwBufSize;
-	GT_2trace(CFG_debugMask, GT_ENTER,
-		  "Entered CFG_GetAutoStart: \n\thDevNode:"
-		  "0x%x\n\tpdwAutoStart: 0x%x\n", hDevNode, pdwAutoStart);
-	dwBufSize = sizeof(*pdwAutoStart);
-	if (!hDevNode)
+	dsp_status status = DSP_SOK;
+	u32 dw_buf_size;
+
+	dw_buf_size = sizeof(*pdwAutoStart);
+	if (!dev_node_obj)
 		status = CFG_E_INVALIDHDEVNODE;
 	if (!pdwAutoStart)
 		status = CFG_E_INVALIDPOINTER;
 	if (DSP_SUCCEEDED(status)) {
-		status = REG_GetValue(NULL, (char *)hDevNode, AUTOSTART,
-				     (u8 *)pdwAutoStart, &dwBufSize);
+		status = reg_get_value(AUTOSTART, (u8 *) pdwAutoStart,
+				       &dw_buf_size);
 		if (DSP_FAILED(status))
 			status = CFG_E_RESOURCENOTAVAIL;
 	}
-#ifdef DEBUG
-	if (DSP_SUCCEEDED(status)) {
-		GT_0trace(CFG_debugMask, GT_1CLASS,
-			 "CFG_GetAutoStart SUCCESS \n");
-	} else {
-		GT_0trace(CFG_debugMask, GT_6CLASS,
-		"CFG_GetAutoStart Failed \n");
-	}
-#endif
-	DBC_Ensure((status == DSP_SOK &&
-		(*pdwAutoStart == 0 || *pdwAutoStart == 1))
-		|| status != DSP_SOK);
+
+	DBC_ENSURE((status == DSP_SOK &&
+		    (*pdwAutoStart == 0 || *pdwAutoStart == 1))
+		   || status != DSP_SOK);
 	return status;
 }
 
 /*
- *  ======== CFG_GetDevObject ========
+ *  ======== cfg_get_dev_object ========
  *  Purpose:
  *      Retrieve the Device Object handle for a given devnode.
  */
-DSP_STATUS CFG_GetDevObject(struct CFG_DEVNODE *hDevNode, OUT u32 *pdwValue)
+dsp_status cfg_get_dev_object(struct cfg_devnode *dev_node_obj,
+			      OUT u32 *pdwValue)
 {
-	DSP_STATUS status = DSP_SOK;
-	u32 dwBufSize;
-	GT_2trace(CFG_debugMask, GT_ENTER, "Entered CFG_GetDevObject, args: "
-		 "\n\thDevNode: 0x%x\n\tpdwValue: 0x%x\n", hDevNode,
-		 *pdwValue);
-	if (!hDevNode)
+	dsp_status status = DSP_SOK;
+	u32 dw_buf_size;
+
+	if (!dev_node_obj)
 		status = CFG_E_INVALIDHDEVNODE;
 
 	if (!pdwValue)
 		status = CFG_E_INVALIDHDEVNODE;
 
-	dwBufSize = sizeof(pdwValue);
+	dw_buf_size = sizeof(pdwValue);
 	if (DSP_SUCCEEDED(status)) {
 
-		/* check the device string and then call the REG_SetValue*/
-               if (!(strcmp((char *)((struct DRV_EXT *)hDevNode)->szString,
-							"TIOMAP1510"))) {
-			GT_0trace(CFG_debugMask, GT_1CLASS,
-				  "Fetching DSP Device from "
-				  "Registry \n");
-			status = REG_GetValue(NULL, (char *)hDevNode,
-					      "DEVICE_DSP",
-					      (u8 *)pdwValue, &dwBufSize);
-		} else {
-			GT_0trace(CFG_debugMask, GT_6CLASS,
-				  "Failed to Identify the Device to Fetch \n");
-		}
-	}
-#ifdef DEBUG
-	if (DSP_SUCCEEDED(status)) {
-		GT_1trace(CFG_debugMask, GT_1CLASS,
-			  "CFG_GetDevObject SUCCESS DevObject"
-			  ": 0x%x\n ", *pdwValue);
-	} else {
-		GT_0trace(CFG_debugMask, GT_6CLASS,
-			  "CFG_GetDevObject Failed \n");
+		/* check the device string and then call the reg_set_value */
+		if (!
+		    (strcmp
+		     ((char *)((struct drv_ext *)dev_node_obj)->sz_string,
+		      "TIOMAP1510")))
+			status =
+			    reg_get_value("DEVICE_DSP", (u8 *) pdwValue,
+					  &dw_buf_size);
 	}
-#endif
+	if (DSP_FAILED(status))
+		pr_err("%s: Failed, status 0x%x\n", __func__, status);
 	return status;
 }
 
 /*
- *  ======== CFG_GetDSPResources ========
+ *  ======== cfg_get_dsp_resources ========
  *  Purpose:
  *      Get the DSP resources available to a given device.
  */
-DSP_STATUS CFG_GetDSPResources(struct CFG_DEVNODE *hDevNode,
-			       OUT struct CFG_DSPRES *pDSPResTable)
+dsp_status cfg_get_dsp_resources(struct cfg_devnode *dev_node_obj,
+				 OUT struct cfg_dspres *pDSPResTable)
 {
-	DSP_STATUS status = DSP_SOK;	/* return value */
-	u32 dwResSize;
-	GT_2trace(CFG_debugMask, GT_ENTER,
-		  "Entered CFG_GetDSPResources, args: "
-		  "\n\thDevNode:  0x%x\n\tpDSPResTable:  0x%x\n",
-		  hDevNode, pDSPResTable);
-	if (!hDevNode) {
+	dsp_status status = DSP_SOK;	/* return value */
+	u32 dw_res_size;
+
+	if (!dev_node_obj) {
 		status = CFG_E_INVALIDHDEVNODE;
 	} else if (!pDSPResTable) {
 		status = CFG_E_INVALIDPOINTER;
 	} else {
-		status = REG_GetValue(NULL, CONFIG, DSPRESOURCES,
-				     (u8 *)pDSPResTable,
-				     &dwResSize);
+		status = reg_get_value(DSPRESOURCES, (u8 *) pDSPResTable,
+				       &dw_res_size);
 	}
-	if (DSP_SUCCEEDED(status)) {
-		GT_0trace(CFG_debugMask, GT_1CLASS,
-			  "CFG_GetDSPResources SUCCESS\n");
-	} else {
+	if (DSP_FAILED(status)) {
 		status = CFG_E_RESOURCENOTAVAIL;
-		GT_0trace(CFG_debugMask, GT_6CLASS,
-			  "CFG_GetDSPResources Failed \n");
+		pr_err("%s: Failed, status 0x%x\n", __func__, status);
 	}
-#ifdef DEBUG
 	/* assert that resource values are reasonable */
-	DBC_Assert(pDSPResTable->uChipType < 256);
-	DBC_Assert(pDSPResTable->uWordSize > 0);
-	DBC_Assert(pDSPResTable->uWordSize < 32);
-	DBC_Assert(pDSPResTable->cChips > 0);
-	DBC_Assert(pDSPResTable->cChips < 256);
-#endif
+	DBC_ASSERT(pDSPResTable->chip_type < 256);
+	DBC_ASSERT(pDSPResTable->word_size > 0);
+	DBC_ASSERT(pDSPResTable->word_size < 32);
+	DBC_ASSERT(pDSPResTable->chip_number > 0);
+	DBC_ASSERT(pDSPResTable->chip_number < 256);
 	return status;
 }
 
 /*
- *  ======== CFG_GetExecFile ========
+ *  ======== cfg_get_exec_file ========
  *  Purpose:
  *      Retreive the default executable, if any, for this board.
  */
-DSP_STATUS CFG_GetExecFile(struct CFG_DEVNODE *hDevNode, u32 ulBufSize,
-			   OUT char *pstrExecFile)
+dsp_status cfg_get_exec_file(struct cfg_devnode *dev_node_obj, u32 ul_buf_size,
+			     OUT char *pstrExecFile)
 {
-	DSP_STATUS status = DSP_SOK;
-	u32 cExecSize = ulBufSize;
-	GT_3trace(CFG_debugMask, GT_ENTER,
-		  "Entered CFG_GetExecFile:\n\tthDevNode: "
-		  "0x%x\n\tulBufSize: 0x%x\n\tpstrExecFile: 0x%x\n", hDevNode,
-		  ulBufSize, pstrExecFile);
-	if (!hDevNode)
-		status = CFG_E_INVALIDHDEVNODE;
+	dsp_status status = DSP_SOK;
+	u32 exec_size = ul_buf_size;
 
-	if (!pstrExecFile)
+	if (!dev_node_obj)
+		status = CFG_E_INVALIDHDEVNODE;
+	else if (!pstrExecFile)
 		status = CFG_E_INVALIDPOINTER;
 
 	if (DSP_SUCCEEDED(status)) {
-		status = REG_GetValue(NULL, (char *)hDevNode, DEFEXEC,
-				     (u8 *)pstrExecFile, &cExecSize);
+		status =
+		    reg_get_value(DEFEXEC, (u8 *) pstrExecFile, &exec_size);
 		if (DSP_FAILED(status))
 			status = CFG_E_RESOURCENOTAVAIL;
-		else if (cExecSize > ulBufSize)
+		else if (exec_size > ul_buf_size)
 			status = DSP_ESIZE;
 
 	}
-#ifdef DEBUG
-	if (DSP_SUCCEEDED(status)) {
-		GT_1trace(CFG_debugMask, GT_1CLASS,
-			  "CFG_GetExecFile SUCCESS Exec File"
-			  "name : %s\n ", pstrExecFile);
-	} else {
-		GT_0trace(CFG_debugMask, GT_6CLASS,
-			  "CFG_GetExecFile Failed \n");
-	}
-#endif
-	DBC_Ensure(((status == DSP_SOK) &&
-                 (strlen(pstrExecFile) <= ulBufSize)) || (status != DSP_SOK));
+	if (DSP_FAILED(status))
+		pr_err("%s: Failed, status 0x%x\n", __func__, status);
+	DBC_ENSURE(((status == DSP_SOK) &&
+		    (strlen(pstrExecFile) <= ul_buf_size))
+		   || (status != DSP_SOK));
 	return status;
 }
 
 /*
- *  ======== CFG_GetHostResources ========
+ *  ======== cfg_get_host_resources ========
  *  Purpose:
  *      Get the Host allocated resources assigned to a given device.
  */
-DSP_STATUS CFG_GetHostResources(struct CFG_DEVNODE *hDevNode,
-				OUT struct CFG_HOSTRES *pHostResTable)
+dsp_status cfg_get_host_resources(struct cfg_devnode *dev_node_obj,
+				  OUT struct cfg_hostres *pHostResTable)
 {
-	DSP_STATUS status = DSP_SOK;
-	u32 dwBufSize;
-	GT_2trace(CFG_debugMask, GT_ENTER,
-		  "Entered CFG_GetHostResources, args:\n\t"
-		  "pHostResTable:  0x%x\n\thDevNode:  0x%x\n",
-		  pHostResTable, hDevNode);
-	if (!hDevNode)
+	dsp_status status = DSP_SOK;
+	u32 dw_buf_size;
+
+	if (!dev_node_obj)
 		status = CFG_E_INVALIDHDEVNODE;
 
 	if (!pHostResTable)
 		status = CFG_E_INVALIDPOINTER;
 
 	if (DSP_SUCCEEDED(status)) {
-		dwBufSize = sizeof(struct CFG_HOSTRES);
-		if (DSP_FAILED(REG_GetValue(NULL, (char *)hDevNode,
-			       CURRENTCONFIG,
-			      (u8 *)pHostResTable, &dwBufSize))) {
+		dw_buf_size = sizeof(struct cfg_hostres);
+		if (DSP_FAILED
+		    (reg_get_value
+		     (CURRENTCONFIG, (u8 *) pHostResTable, &dw_buf_size))) {
 			status = CFG_E_RESOURCENOTAVAIL;
 		}
 	}
-#ifdef DEBUG
-	if (DSP_SUCCEEDED(status)) {
-		GT_0trace(CFG_debugMask, GT_1CLASS,
-			  "CFG_GetHostResources SUCCESS \n");
-	} else {
-		GT_0trace(CFG_debugMask, GT_6CLASS,
-			  "CFG_GetHostResources Failed \n");
-	}
-#endif
+	if (DSP_FAILED(status))
+		dev_dbg(bridge, "%s Failed, status 0x%x\n", __func__, status);
 	return status;
 }
 
 /*
- *  ======== CFG_GetObject ========
+ *  ======== cfg_get_object ========
  *  Purpose:
  *      Retrieve the Object handle from the Registry
  */
-DSP_STATUS CFG_GetObject(OUT u32 *pdwValue, u32 dwType)
+dsp_status cfg_get_object(OUT u32 *pdwValue, u32 dw_type)
 {
-	DSP_STATUS status = DSP_EINVALIDARG;
-	u32 dwBufSize;
-	DBC_Require(pdwValue != NULL);
-	GT_1trace(CFG_debugMask, GT_ENTER,
-		 "Entered CFG_GetObject, args:pdwValue: "
-		 "0x%x\n", *pdwValue);
-	dwBufSize = sizeof(pdwValue);
-	switch (dwType) {
+	dsp_status status = DSP_EINVALIDARG;
+	u32 dw_buf_size;
+	DBC_REQUIRE(pdwValue != NULL);
+
+	dw_buf_size = sizeof(pdwValue);
+	switch (dw_type) {
 	case (REG_DRV_OBJECT):
-		status = REG_GetValue(NULL, CONFIG, DRVOBJECT,
-				     (u8 *)pdwValue,
-				     &dwBufSize);
+		status =
+		    reg_get_value(DRVOBJECT, (u8 *) pdwValue, &dw_buf_size);
+		if (DSP_FAILED(status))
+			status = CFG_E_RESOURCENOTAVAIL;
 		break;
 	case (REG_MGR_OBJECT):
-		status = REG_GetValue(NULL, CONFIG, MGROBJECT,
-				     (u8 *)pdwValue,
-				     &dwBufSize);
+		status =
+		    reg_get_value(MGROBJECT, (u8 *) pdwValue, &dw_buf_size);
+		if (DSP_FAILED(status))
+			status = CFG_E_RESOURCENOTAVAIL;
 		break;
 	default:
 		break;
 	}
-	if (DSP_SUCCEEDED(status)) {
-		GT_1trace(CFG_debugMask, GT_1CLASS,
-			  "CFG_GetObject SUCCESS DrvObject: "
-			  "0x%x\n ", *pdwValue);
-	} else {
-		status = CFG_E_RESOURCENOTAVAIL;
+	if (DSP_FAILED(status)) {
 		*pdwValue = 0;
-		GT_0trace(CFG_debugMask, GT_6CLASS, "CFG_GetObject Failed \n");
+		pr_err("%s: Failed, status 0x%x\n", __func__, status);
 	}
-	DBC_Ensure((DSP_SUCCEEDED(status) && *pdwValue != 0) ||
+	DBC_ENSURE((DSP_SUCCEEDED(status) && *pdwValue != 0) ||
 		   (DSP_FAILED(status) && *pdwValue == 0));
 	return status;
 }
 
 /*
- *  ======== CFG_Init ========
+ *  ======== cfg_init ========
  *  Purpose:
  *      Initialize the CFG module's private state.
  */
-bool CFG_Init(void)
+bool cfg_init(void)
 {
-	struct CFG_DSPRES dspResources;
-	GT_create(&CFG_debugMask, "CF");	/* CF for ConFig */
-	GT_0trace(CFG_debugMask, GT_5CLASS, "Entered CFG_Init\n");
-	GT_0trace(CFG_debugMask, GT_5CLASS, "Intializing DSP Registry Info \n");
-
-	dspResources.uChipType = DSPTYPE_64;
-	dspResources.cChips = 1;
-	dspResources.uWordSize = DSPWORDSIZE;
-	dspResources.cMemTypes = 0;
-	dspResources.aMemDesc[0].uMemType = 0;
-	dspResources.aMemDesc[0].ulMin = 0;
-	dspResources.aMemDesc[0].ulMax = 0;
-	if (DSP_SUCCEEDED(REG_SetValue(NULL, CONFIG, DSPRESOURCES, REG_BINARY,
-			 (u8 *)&dspResources, sizeof(struct CFG_DSPRES)))) {
-		GT_0trace(CFG_debugMask, GT_5CLASS,
-			  "Initialized DSP resources in "
-			  "Registry \n");
-	} else
-		GT_0trace(CFG_debugMask, GT_5CLASS,
-			  "Failed to Initialize DSP resources"
-			  " in Registry \n");
+	struct cfg_dspres dsp_resources;
+
+	dsp_resources.chip_type = DSPTYPE64;
+	dsp_resources.chip_number = 1;
+	dsp_resources.word_size = DSPWORDSIZE;
+	dsp_resources.mem_types = 0;
+	dsp_resources.mem_desc[0].mem_type = 0;
+	dsp_resources.mem_desc[0].ul_min = 0;
+	dsp_resources.mem_desc[0].ul_max = 0;
+	if (DSP_FAILED(reg_set_value(DSPRESOURCES, (u8 *) &dsp_resources,
+				     sizeof(struct cfg_dspres))))
+		pr_err("Failed to initialize DSP resources in registry\n");
+
 	return true;
 }
 
 /*
- *  ======== CFG_SetDevObject ========
+ *  ======== cfg_set_dev_object ========
  *  Purpose:
- *      Store the Device Object handle and devNode pointer for a given devnode.
+ *      Store the Device Object handle and dev_node pointer for a given devnode.
  */
-DSP_STATUS CFG_SetDevObject(struct CFG_DEVNODE *hDevNode, u32 dwValue)
+dsp_status cfg_set_dev_object(struct cfg_devnode *dev_node_obj, u32 dwValue)
 {
-	DSP_STATUS status = DSP_SOK;
-	u32 dwBuffSize;
-	GT_2trace(CFG_debugMask, GT_ENTER,
-		  "Entered CFG_SetDevObject, args: \n\t"
-		  "hDevNode: 0x%x\n\tdwValue: 0x%x\n", hDevNode, dwValue);
-	if (!hDevNode)
+	dsp_status status = DSP_SOK;
+	u32 dw_buff_size;
+
+	if (!dev_node_obj)
 		status = CFG_E_INVALIDHDEVNODE;
 
-	dwBuffSize = sizeof(dwValue);
+	dw_buff_size = sizeof(dwValue);
 	if (DSP_SUCCEEDED(status)) {
 		/* Store the WCD device object in the Registry */
 
-               if (!(strcmp((char *)hDevNode, "TIOMAP1510"))) {
-			GT_0trace(CFG_debugMask, GT_1CLASS,
-				  "Registering the DSP Device \n");
-			status = REG_SetValue(NULL, (char *)hDevNode,
-				  "DEVICE_DSP", REG_DWORD,\
-				  (u8 *)&dwValue, dwBuffSize);
-			if (DSP_SUCCEEDED(status)) {
-				dwBuffSize = sizeof(hDevNode);
-				status = REG_SetValue(NULL,
-					  (char *)hDevNode, "DEVNODESTRING_DSP",
-					  REG_DWORD, (u8 *)&hDevNode,
-					  dwBuffSize);
-			}
-		} else {
-			GT_0trace(CFG_debugMask, GT_6CLASS,
-				  "Failed to Register Device \n");
+		if (!(strcmp((char *)dev_node_obj, "TIOMAP1510"))) {
+			status = reg_set_value("DEVICE_DSP", (u8 *) &dwValue,
+					       dw_buff_size);
 		}
 	}
-#ifdef DEBUG
-	if (DSP_SUCCEEDED(status)) {
-		GT_0trace(CFG_debugMask, GT_1CLASS,
-			  "CFG_SetDevObject SUCCESS \n");
-	} else {
-		GT_0trace(CFG_debugMask, GT_6CLASS,
-			  "CFG_SetDevObject Failed \n");
-	}
-#endif
+	if (DSP_FAILED(status))
+		pr_err("%s: Failed, status 0x%x\n", __func__, status);
+
 	return status;
 }
 
 /*
- *  ======== CFG_SetObject ========
+ *  ======== cfg_set_object ========
  *  Purpose:
  *      Store the Driver Object handle
  */
-DSP_STATUS CFG_SetObject(u32 dwValue, u32 dwType)
+dsp_status cfg_set_object(u32 dwValue, u32 dw_type)
 {
-	DSP_STATUS status = DSP_EINVALIDARG;
-	u32 dwBuffSize;
-	GT_1trace(CFG_debugMask, GT_ENTER,
-		  "Entered CFG_SetObject, args: dwValue: "
-		  "0x%x\n", dwValue);
-	dwBuffSize = sizeof(dwValue);
-	switch (dwType) {
+	dsp_status status = DSP_EINVALIDARG;
+	u32 dw_buff_size;
+
+	dw_buff_size = sizeof(dwValue);
+	switch (dw_type) {
 	case (REG_DRV_OBJECT):
-		status = REG_SetValue(NULL, CONFIG, DRVOBJECT, REG_DWORD,
-			 (u8 *)&dwValue, dwBuffSize);
+		status =
+		    reg_set_value(DRVOBJECT, (u8 *) &dwValue, dw_buff_size);
 		break;
 	case (REG_MGR_OBJECT):
-		status = REG_SetValue(NULL, CONFIG, MGROBJECT, REG_DWORD,
-			 (u8 *) &dwValue, dwBuffSize);
+		status =
+		    reg_set_value(MGROBJECT, (u8 *) &dwValue, dw_buff_size);
 		break;
 	default:
 		break;
 	}
-#ifdef DEBUG
-	if (DSP_SUCCEEDED(status))
-		GT_0trace(CFG_debugMask, GT_1CLASS, "CFG_SetObject SUCCESS \n");
-	else
-		GT_0trace(CFG_debugMask, GT_6CLASS, "CFG_SetObject Failed \n");
-
-#endif
+	if (DSP_FAILED(status))
+		pr_err("%s: Failed, status 0x%x\n", __func__, status);
 	return status;
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/services/clk.c kernel-power-2.6.28.new/drivers/dsp/bridge/services/clk.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/services/clk.c	2011-10-11 13:51:01.761749946 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/services/clk.c	2011-10-23 08:22:37.677315000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Clock and Timer services.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,24 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== clk.c ========
- *  Purpose:
- *      Clock and Timer services.
- *
- *  Public Functions:
- *      CLK_Exit
- *      CLK_Init
- *	CLK_Enable
- *	CLK_Disable
- *	CLK_GetRate
- *	CLK_Set_32KHz
- *! Revision History:
- *! ================
- *! 08-May-2007 rg: moved all clock functions from sync module.
- *		    And added CLK_Set_32KHz, CLK_Set_SysClk.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -42,38 +26,36 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/mem.h>
 
 /*  ----------------------------------- This */
 #include <dspbridge/clk.h>
-#include <dspbridge/util.h>
-
 
 /*  ----------------------------------- Defines, Data Structures, Typedefs */
 
-typedef volatile unsigned long  REG_UWORD32;
-
-#define SSI_Base        0x48058000
+typedef volatile unsigned long reg_uword32;
 
-#define SSI_BASE                     IO_ADDRESS(SSI_Base)
+#define OMAP_SSI_OFFSET			0x58000
+#define OMAP_SSI_SIZE			0x1000
+#define OMAP_SSI_SYSCONFIG_OFFSET	0x10
 
+#define SSI_AUTOIDLE			(1 << 0)
+#define SSI_SIDLE_SMARTIDLE		(2 << 3)
+#define SSI_MIDLE_NOIDLE		(1 << 12)
 
-struct SERVICES_Clk_t {
+struct services_clk_t {
 	struct clk *clk_handle;
 	const char *clk_name;
 	int id;
 };
 
 /* The row order of the below array needs to match with the clock enumerations
- * 'SERVICES_ClkId' provided in the header file.. any changes in the
+ * 'services_clk_id' provided in the header file.. any changes in the
  * enumerations needs to be fixed in the array as well */
-static struct SERVICES_Clk_t SERVICES_Clks[] = {
+static struct services_clk_t services_clks[] = {
 	{NULL, "iva2_ck", -1},
-	{NULL, "mailboxes_ick", -1},
 	{NULL, "gpt5_fck", -1},
 	{NULL, "gpt5_ick", -1},
 	{NULL, "gpt6_fck", -1},
@@ -102,74 +84,58 @@
 };
 
 /* Generic TIMER object: */
-struct TIMER_OBJECT {
+struct timer_object {
 	struct timer_list timer;
 };
 
-/*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask CLK_debugMask = { NULL, NULL };	/* GT trace variable */
-#endif
-
 /*
- *  ======== CLK_Exit ========
+ *  ======== clk_exit ========
  *  Purpose:
  *      Cleanup CLK module.
  */
-void CLK_Exit(void)
+void clk_exit(void)
 {
 	int i = 0;
 
-	GT_0trace(CLK_debugMask, GT_5CLASS, "CLK_Exit\n");
 	/* Relinquish the clock handles */
 	while (i < SERVICESCLK_NOT_DEFINED) {
-		if (SERVICES_Clks[i].clk_handle)
-			clk_put(SERVICES_Clks[i].clk_handle);
+		if (services_clks[i].clk_handle)
+			clk_put(services_clks[i].clk_handle);
 
-		SERVICES_Clks[i].clk_handle = NULL;
+		services_clks[i].clk_handle = NULL;
 		i++;
 	}
 
 }
 
 /*
- *  ======== CLK_Init ========
+ *  ======== services_clk_init ========
  *  Purpose:
  *      Initialize CLK module.
  */
-bool CLK_Init(void)
+bool services_clk_init(void)
 {
 	static struct platform_device dspbridge_device;
 	struct clk *clk_handle;
 	int i = 0;
-	GT_create(&CLK_debugMask, "CK");	/* CK for CLK */
-	GT_0trace(CLK_debugMask, GT_5CLASS, "CLK_Init\n");
 
 	dspbridge_device.dev.bus = &platform_bus_type;
 
 	/* Get the clock handles from base port and store locally */
 	while (i < SERVICESCLK_NOT_DEFINED) {
 		/* get the handle from BP */
-		dspbridge_device.id = SERVICES_Clks[i].id;
+		dspbridge_device.id = services_clks[i].id;
 
 		clk_handle = clk_get(&dspbridge_device.dev,
-			     SERVICES_Clks[i].clk_name);
+				     services_clks[i].clk_name);
 
 		if (!clk_handle) {
-			GT_2trace(CLK_debugMask, GT_7CLASS,
-				  "CLK_Init: failed to get Clk handle %s, "
-				  "CLK dev id = %d\n",
-				  SERVICES_Clks[i].clk_name,
-				  SERVICES_Clks[i].id);
+			pr_err("%s: failed to get clk handle %s, dev id = %d\n",
+			       __func__, services_clks[i].clk_name,
+			       services_clks[i].id);
 			/* should we fail here?? */
-		} else {
-			GT_2trace(CLK_debugMask, GT_7CLASS,
-				  "CLK_Init: PASS and Clk handle %s, "
-				  "CLK dev id = %d\n",
-				  SERVICES_Clks[i].clk_name,
-				  SERVICES_Clks[i].id);
 		}
-		SERVICES_Clks[i].clk_handle = clk_handle;
+		services_clks[i].clk_handle = clk_handle;
 		i++;
 	}
 
@@ -177,36 +143,30 @@
 }
 
 /*
- *  ======== CLK_Enable ========
+ *  ======== services_clk_enable ========
  *  Purpose:
  *      Enable Clock .
  *
-*/
-DSP_STATUS CLK_Enable(IN enum SERVICES_ClkId clk_id)
+ */
+dsp_status services_clk_enable(IN enum services_clk_id clk_id)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct clk *pClk;
+	dsp_status status = DSP_SOK;
+	struct clk *clk_handle;
+
+	DBC_REQUIRE(clk_id < SERVICESCLK_NOT_DEFINED);
 
-	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
-	GT_2trace(CLK_debugMask, GT_6CLASS, "CLK_Enable: CLK %s, "
-		"CLK dev id = %d\n", SERVICES_Clks[clk_id].clk_name,
-		SERVICES_Clks[clk_id].id);
-
-	pClk = SERVICES_Clks[clk_id].clk_handle;
-	if (pClk) {
-		if (clk_enable(pClk) == 0x0) {
-			/* Success ? */
-		} else {
-			pr_err("CLK_Enable: failed to Enable CLK %s, "
-					"CLK dev id = %d\n",
-					SERVICES_Clks[clk_id].clk_name,
-					SERVICES_Clks[clk_id].id);
+	clk_handle = services_clks[clk_id].clk_handle;
+	if (clk_handle) {
+		if (clk_enable(clk_handle)) {
+			pr_err("services_clk_enable: failed to Enable CLK %s, "
+			       "CLK dev id = %d\n",
+			       services_clks[clk_id].clk_name,
+			       services_clks[clk_id].id);
 			status = DSP_EFAIL;
 		}
 	} else {
-		pr_err("CLK_Enable: failed to get CLK %s, CLK dev id = %d\n",
-					SERVICES_Clks[clk_id].clk_name,
-					SERVICES_Clks[clk_id].id);
+		pr_err("%s: failed to get CLK %s, CLK dev id = %d\n", __func__,
+		     services_clks[clk_id].clk_name, services_clks[clk_id].id);
 		status = DSP_EFAIL;
 	}
 	/* The SSI module need to configured not to have the Forced idle for
@@ -214,37 +174,33 @@
 	 * transitioning to standby thereby causing the client in the DSP hang
 	 * waiting for the SSI module to be active after enabling the clocks
 	 */
-	if (clk_id == SERVICESCLK_ssi_fck)
-		SSI_Clk_Prepare(true);
+	if (clk_id == SERVICESCLK_SSI_FCK)
+		ssi_clk_prepare(true);
 
 	return status;
 }
+
 /*
- *  ======== CLK_Set_32KHz ========
+ *  ======== clk_set32k_hz ========
  *  Purpose:
  *      To Set parent of a clock to 32KHz.
  */
 
-DSP_STATUS CLK_Set_32KHz(IN enum SERVICES_ClkId clk_id)
+dsp_status clk_set32k_hz(IN enum services_clk_id clk_id)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct clk *pClk;
-	struct clk *pClkParent;
-	enum SERVICES_ClkId sys_32k_id = SERVICESCLK_sys_32k_ck;
-	pClkParent =  SERVICES_Clks[sys_32k_id].clk_handle;
-
-	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
-	GT_2trace(CLK_debugMask, GT_6CLASS, "CLK_Set_32KHz: CLK %s, "
-		"CLK dev id = %d is setting to 32KHz \n",
-		SERVICES_Clks[clk_id].clk_name,
-		SERVICES_Clks[clk_id].id);
-	pClk = SERVICES_Clks[clk_id].clk_handle;
-	if (pClk) {
-		if (!(clk_set_parent(pClk, pClkParent) == 0x0)) {
-		       GT_2trace(CLK_debugMask, GT_7CLASS, "CLK_Set_32KHz: "
-				"Failed to set to 32KHz %s, CLK dev id = %d\n",
-				SERVICES_Clks[clk_id].clk_name,
-				SERVICES_Clks[clk_id].id);
+	dsp_status status = DSP_SOK;
+	struct clk *clk_handle;
+	struct clk *clk_parent;
+	clk_parent = services_clks[SERVICESCLK_SYS32K_CK].clk_handle;
+
+	DBC_REQUIRE(clk_id < SERVICESCLK_NOT_DEFINED);
+
+	clk_handle = services_clks[clk_id].clk_handle;
+	if (clk_handle) {
+		if (!(clk_set_parent(clk_handle, clk_parent) == 0x0)) {
+			pr_err("%s: failed for %s, dev id = %d\n", __func__,
+			       services_clks[clk_id].clk_name,
+			       services_clks[clk_id].id);
 			status = DSP_EFAIL;
 		}
 	}
@@ -252,124 +208,119 @@
 }
 
 /*
- *  ======== CLK_Disable ========
+ *  ======== services_clk_disable ========
  *  Purpose:
  *      Disable the clock.
  *
-*/
-DSP_STATUS CLK_Disable(IN enum SERVICES_ClkId clk_id)
+ */
+dsp_status services_clk_disable(IN enum services_clk_id clk_id)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct clk *pClk;
-	s32 clkUseCnt;
-
-	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
-	GT_2trace(CLK_debugMask, GT_6CLASS, "CLK_Disable: CLK %s, "
-		"CLK dev id = %d\n", SERVICES_Clks[clk_id].clk_name,
-		SERVICES_Clks[clk_id].id);
-
-	pClk = SERVICES_Clks[clk_id].clk_handle;
-
-	clkUseCnt = CLK_Get_UseCnt(clk_id);
-	if (clkUseCnt == -1) {
-		pr_err("CLK_Disable: failed to get CLK Use count for CLK %s,"
-				"CLK dev id = %d\n",
-				SERVICES_Clks[clk_id].clk_name,
-				SERVICES_Clks[clk_id].id);
-	} else if (clkUseCnt == 0) {
-		GT_2trace(CLK_debugMask, GT_4CLASS, "CLK_Disable: CLK %s,"
-				"CLK dev id= %d is already disabled\n",
-				SERVICES_Clks[clk_id].clk_name,
-				SERVICES_Clks[clk_id].id);
+	dsp_status status = DSP_SOK;
+	struct clk *clk_handle;
+	s32 clk_use_cnt;
+
+	DBC_REQUIRE(clk_id < SERVICESCLK_NOT_DEFINED);
+
+	clk_handle = services_clks[clk_id].clk_handle;
+
+	clk_use_cnt = clk_get_use_cnt(clk_id);
+	if (clk_use_cnt == -1) {
+		pr_err("%s: failed to get CLK Use count for CLK %s, CLK dev id"
+		       " = %d\n", __func__, services_clks[clk_id].clk_name,
+		       services_clks[clk_id].id);
+	} else if (clk_use_cnt == 0) {
 		return status;
 	}
-	if (clk_id == SERVICESCLK_ssi_ick)
-		SSI_Clk_Prepare(false);
+	if (clk_id == SERVICESCLK_SSI_ICK)
+		ssi_clk_prepare(false);
 
-		if (pClk) {
-			clk_disable(pClk);
-		} else {
-			pr_err("CLK_Disable: failed to get CLK %s,"
-					"CLK dev id = %d\n",
-					SERVICES_Clks[clk_id].clk_name,
-					SERVICES_Clks[clk_id].id);
-			status = DSP_EFAIL;
-		}
+	if (clk_handle) {
+		clk_disable(clk_handle);
+	} else {
+		pr_err("services_clk_disable: failed to get CLK %s,"
+		       "CLK dev id = %d\n",
+		       services_clks[clk_id].clk_name,
+		       services_clks[clk_id].id);
+		status = DSP_EFAIL;
+	}
 	return status;
 }
 
 /*
- *  ======== CLK_GetRate ========
+ *  ======== services_clk_get_rate ========
  *  Purpose:
  *      GetClock Speed.
  *
  */
 
-DSP_STATUS CLK_GetRate(IN enum SERVICES_ClkId clk_id, u32 *speedKhz)
+dsp_status services_clk_get_rate(IN enum services_clk_id clk_id, u32 *speedKhz)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct clk *pClk;
-	u32 clkSpeedHz;
+	dsp_status status = DSP_SOK;
+	struct clk *clk_handle;
+	u32 clk_speed_hz;
 
-	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
+	DBC_REQUIRE(clk_id < SERVICESCLK_NOT_DEFINED);
 	*speedKhz = 0x0;
 
-	GT_2trace(CLK_debugMask, GT_7CLASS, "CLK_GetRate: CLK %s, "
-		"CLK dev Id = %d \n", SERVICES_Clks[clk_id].clk_name,
-		SERVICES_Clks[clk_id].id);
-	pClk = SERVICES_Clks[clk_id].clk_handle;
-	if (pClk) {
-		clkSpeedHz = clk_get_rate(pClk);
-		*speedKhz = clkSpeedHz / 1000;
-		GT_2trace(CLK_debugMask, GT_6CLASS,
-			  "CLK_GetRate: clkSpeedHz = %d , "
-			 "speedinKhz=%d\n", clkSpeedHz, *speedKhz);
+	clk_handle = services_clks[clk_id].clk_handle;
+	if (clk_handle) {
+		clk_speed_hz = clk_get_rate(clk_handle);
+		*speedKhz = clk_speed_hz / 1000;
+		dev_dbg(bridge, "%s: clk_speed_hz = %d, speedinKhz = %d\n",
+			__func__, clk_speed_hz, *speedKhz);
 	} else {
-		GT_2trace(CLK_debugMask, GT_7CLASS,
-			 "CLK_GetRate: failed to get CLK %s, "
-			 "CLK dev Id = %d\n", SERVICES_Clks[clk_id].clk_name,
-			 SERVICES_Clks[clk_id].id);
+		pr_err("%s: failed to get %s, dev Id = %d\n", __func__,
+		       services_clks[clk_id].clk_name,
+		       services_clks[clk_id].id);
 		status = DSP_EFAIL;
 	}
 	return status;
 }
 
-s32 CLK_Get_UseCnt(IN enum SERVICES_ClkId clk_id)
+s32 clk_get_use_cnt(IN enum services_clk_id clk_id)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct clk *pClk;
-	s32 useCount = -1;
-	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
+	dsp_status status = DSP_SOK;
+	struct clk *clk_handle;
+	s32 use_count = -1;
+	DBC_REQUIRE(clk_id < SERVICESCLK_NOT_DEFINED);
 
-	pClk = SERVICES_Clks[clk_id].clk_handle;
+	clk_handle = services_clks[clk_id].clk_handle;
 
-	if (pClk) {
-		useCount =  pClk->usecount; /* FIXME: usecount shouldn't be used */
+	if (clk_handle) {
+		/* FIXME: usecount shouldn't be used */
+		use_count = clk_handle->usecount;
 	} else {
-		GT_2trace(CLK_debugMask, GT_7CLASS,
-			 "CLK_GetRate: failed to get CLK %s, "
-			 "CLK dev Id = %d\n", SERVICES_Clks[clk_id].clk_name,
-			 SERVICES_Clks[clk_id].id);
+		pr_err("%s: failed to get %s, dev Id = %d\n", __func__,
+		       services_clks[clk_id].clk_name,
+		       services_clks[clk_id].id);
 		status = DSP_EFAIL;
 	}
-	return useCount;
+	return use_count;
 }
 
-void SSI_Clk_Prepare(bool FLAG)
+void ssi_clk_prepare(bool FLAG)
 {
-	u32 ssi_sysconfig;
-	ssi_sysconfig = __raw_readl((SSI_BASE) + 0x10);
+	void __iomem *ssi_base;
+	unsigned int value;
+
+	ssi_base = ioremap(L4_34XX_BASE + OMAP_SSI_OFFSET, OMAP_SSI_SIZE);
+	if (!ssi_base) {
+		pr_err("%s: error, SSI not configured\n", __func__);
+		return;
+	}
 
 	if (FLAG) {
 		/* Set Autoidle, SIDLEMode to smart idle, and MIDLEmode to
 		 * no idle
 		 */
-		ssi_sysconfig = 0x1011;
+		value = SSI_AUTOIDLE | SSI_SIDLE_SMARTIDLE | SSI_MIDLE_NOIDLE;
 	} else {
 		/* Set Autoidle, SIDLEMode to forced idle, and MIDLEmode to
 		 * forced idle
 		 */
-		ssi_sysconfig = 0x1;
+		value = SSI_AUTOIDLE;
 	}
-	__raw_writel((u32)ssi_sysconfig, SSI_BASE + 0x10);
+
+	__raw_writel(value, ssi_base + OMAP_SSI_SYSCONFIG_OFFSET);
+	iounmap(ssi_base);
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/services/csl.c kernel-power-2.6.28.new/drivers/dsp/bridge/services/csl.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/services/csl.c	2011-10-11 13:51:01.774458423 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/services/csl.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,173 +0,0 @@
-/*
- * csl.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== cslce.c ========
- *  Purpose:
- *      Provides platform independent C Standard library functions.
- *
- *  Public Functions:
- *      CSL_Atoi
- *      CSL_Exit
- *      CSL_Init
- *      CSL_NumToAscii
- *      CSL_Strtokr
- *
- *! Revision History:
- *! ================
- *! 07-Aug-2002 jeh: Added CSL_Strtokr().
- *! 21-Sep-2001 jeh: Added CSL_Strncmp(). Alphabetized functions.
- *! 22-Nov-2000 map: Added CSL_Atoi and CSL_Strtok
- *! 19-Nov-2000 kc: Added CSL_ByteSwap.
- *! 09-Nov-2000 kc: Added CSL_Strncat.
- *! 03-Feb-2000 rr: Module init/exit is handled by SERVICES Init/Exit.
- *!		 GT Changes.
- *! 15-Dec-1999 ag: Removed incorrect assertion CSL_NumToAscii()
- *! 29-Oct-1999 kc: Added CSL_Wstrlen for UNICODE strings.
- *! 30-Sep-1999 ag: Removed DBC assertion (!CSL_DebugMask.flags) in
- *		  CSP_Init().
- *! 20-Sep-1999 ag: Added CSL_WcharToAnsi().
- *!		 Removed call to GT_set().
- *! 19-Jan-1998 cr: Code review cleanup.
- *! 29-Dec-1997 cr: Made platform independant, using MS CRT code, and
- *!		 combined csl32.c csl95.c and cslnt.c into csl.c.  Also
- *!		 changed CSL_lowercase to CSL_Uppercase.
- *! 21-Aug-1997 gp: Fix to CSL_strcpyn to initialize Source string, the NT way.
- *! 25-Jun-1997 cr: Created from csl95, added CSL_strcmp.
- */
-
-/* ----------------------------------- Host OS */
-#include <dspbridge/host_os.h>
-
-/*  ----------------------------------- DSP/BIOS Bridge */
-#include <dspbridge/std.h>
-#include <dspbridge/dbdefs.h>
-
-/*  ----------------------------------- Trace & Debug */
-#include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
-
-/*  ----------------------------------- This */
-#include <dspbridge/csl.h>
-
-/* Is character c in the string pstrDelim? */
-#define IsDelimiter(c, pstrDelim) ((c != '\0') && \
-				   (strchr(pstrDelim, c) != NULL))
-
-/*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask CSL_DebugMask = { NULL, NULL };	/* GT trace var. */
-#endif
-
-/*
- *  ======== CSL_Exit ========
- *  Purpose:
- *      Discontinue usage of the CSL module.
- */
-void CSL_Exit(void)
-{
-	GT_0trace(CSL_DebugMask, GT_5CLASS, "CSL_Exit\n");
-}
-
-/*
- *  ======== CSL_Init ========
- *  Purpose:
- *      Initialize the CSL module's private state.
- */
-bool CSL_Init(void)
-{
-	GT_create(&CSL_DebugMask, "CS");
-
-	GT_0trace(CSL_DebugMask, GT_5CLASS, "CSL_Init\n");
-
-	return true;
-}
-
-/*
- *  ======== CSL_NumToAscii ========
- *  Purpose:
- *      Convert a 1 or 2 digit number to a 2 digit string.
- */
-void CSL_NumToAscii(OUT char *pstrNumber, u32 dwNum)
-{
-	char tens;
-
-	DBC_Require(dwNum < 100);
-
-	if (dwNum < 100) {
-		tens = (char) dwNum / 10;
-		dwNum = dwNum % 10;
-
-		if (tens) {
-			pstrNumber[0] = tens + '0';
-			pstrNumber[1] = (char) dwNum + '0';
-			pstrNumber[2] = '\0';
-		} else {
-			pstrNumber[0] = (char) dwNum + '0';
-			pstrNumber[1] = '\0';
-		}
-	} else {
-		pstrNumber[0] = '\0';
-	}
-}
-
-
-
-
-/*
- *  ======= CSL_Strtokr =======
- *  Purpose:
- *      Re-entrant version of strtok.
- */
-char *CSL_Strtokr(IN char *pstrSrc, IN CONST char *szSeparators,
-		  OUT char **ppstrLast)
-{
-	char *pstrTemp;
-	char *pstrToken;
-
-	DBC_Require(szSeparators != NULL);
-	DBC_Require(ppstrLast != NULL);
-	DBC_Require(pstrSrc != NULL || *ppstrLast != NULL);
-
-	/*
-	 *  Set string location to beginning (pstrSrc != NULL) or to the
-	 *  beginning of the next token.
-	 */
-	pstrTemp = (pstrSrc != NULL) ? pstrSrc : *ppstrLast;
-	if (*pstrTemp == '\0') {
-		pstrToken = NULL;
-	} else {
-		pstrToken = pstrTemp;
-		while (*pstrTemp != '\0' && !IsDelimiter(*pstrTemp,
-		      szSeparators)) {
-			pstrTemp++;
-		}
-		if (*pstrTemp != '\0') {
-			while (IsDelimiter(*pstrTemp, szSeparators)) {
-				/* TODO: Shouldn't we do this for
-				 * only 1 char?? */
-				*pstrTemp = '\0';
-				pstrTemp++;
-			}
-		}
-
-		/* Location in string for next call */
-		*ppstrLast = pstrTemp;
-	}
-
-	return pstrToken;
-}
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/services/dbg.c kernel-power-2.6.28.new/drivers/dsp/bridge/services/dbg.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/services/dbg.c	2011-10-11 13:51:01.774458423 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/services/dbg.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,119 +0,0 @@
-/*
- * dbg.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dbgce.c ========
- *  Purpose:
- *      Provide debugging services for DSP/BIOS Bridge Mini Drivers.
- *
- *  Public Functions:
- *      DBG_Exit
- *      DBG_Init
- *      DBG_Trace
- *
- *  Notes:
- *      Requires gt.h.
- *
- *      This implementation does not create GT masks on a per WMD basis.
- *      There is currently no facility for a WMD to alter the GT mask.
- *
- *! Revision History:
- *! ================
- *! 15-Feb-2000 rr: DBG_Trace prints based on the DebugZones.
- *! 03-Feb-2000 rr: Module init/exit is handled by SERVICES Init/Exit.
- *!		 GT Changes.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 10-Oct-1997 cr: Added DBG_Printf service.
- *! 28-May-1997 cr: Added reference counting.
- *! 23-May-1997 cr: Updated DBG_Trace to new gt interface.
- *! 29-May-1996 gp: Removed WCD_ prefix.
- *! 20-May-1996 gp: Remove DEBUG conditional compilation.
- *! 15-May-1996 gp: Created.
- */
-
-/*  ----------------------------------- DSP/BIOS Bridge */
-#include <dspbridge/std.h>
-#include <dspbridge/dbdefs.h>
-#include <dspbridge/errbase.h>
-
-/*  ----------------------------------- Trace & Debug */
-#include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
-
-/*  ----------------------------------- This */
-#include <dspbridge/dbg.h>
-
-/*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask DBG_debugMask = { NULL, NULL };	/* GT trace var. */
-#endif
-
-#if (defined(DEBUG) || defined (DDSP_DEBUG_PRODUCT)) && GT_TRACE
-
-/*
- *  ======== DBG_Init ========
- *  Purpose:
- *      Ensures trace capability is set up for link drivers.
- */
-bool DBG_Init(void)
-{
-	GT_create(&DBG_debugMask, "WD");     /* for WmD (link driver) debug */
-
-	GT_0trace(DBG_debugMask, GT_5CLASS, "DBG_Init\n");
-
-	return true;
-}
-
-/*
- *  ======== DBG_Trace ========
- *  Purpose:
- *      Output a trace message to the debugger, if the given trace level
- *      is unmasked.
- */
-DSP_STATUS DBG_Trace(u8 bLevel, char *pstrFormat, ...)
-{
-	s32 arg1, arg2, arg3, arg4, arg5, arg6;
-	va_list va;
-
-	va_start(va, pstrFormat);
-
-	arg1 = va_arg(va, s32);
-	arg2 = va_arg(va, s32);
-	arg3 = va_arg(va, s32);
-	arg4 = va_arg(va, s32);
-	arg5 = va_arg(va, s32);
-	arg6 = va_arg(va, s32);
-
-	va_end(va);
-
-	if (bLevel & *(DBG_debugMask).flags)
-		printk(pstrFormat, arg1, arg2, arg3, arg4, arg5, arg6);
-
-	return DSP_SOK;
-}
-
-/*
- *  ======== DBG_Exit ========
- *  Purpose:
- *      Discontinue usage of the DBG module.
- */
-void DBG_Exit(void)
-{
-	GT_0trace(DBG_debugMask, GT_5CLASS, "DBG_Exit\n");
-}
-
-#endif	/* (defined(DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/services/dpc.c kernel-power-2.6.28.new/drivers/dsp/bridge/services/dpc.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/services/dpc.c	2011-10-11 13:51:01.778321654 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/services/dpc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,274 +0,0 @@
-/*
- * dpc.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dpcce.c ========
- *  Purpose:
- *      Deferred Procedure Call(DPC) Services.
- *
- *
- *  Public Functions:
- *      DPC_Create
- *      DPC_Destroy
- *      DPC_Exit
- *      DPC_Init
- *      DPC_Schedule
- *
- *! Revision History:
- *! ================
- *! 28-Mar-2001 ag: Added #ifdef CHNL_NOIPCINTR to set DPC thread priority
- *!                     to THREAD_PRIORITY_IDLE for polling IPC.
- *! 03-Feb-2000 rr: Module init/exit is handled by SERVICES Init/Exit.
- *!		 GT Changes.
- *! 31-Jan-2000 rr: Changes after code review.Terminate thread,handle
- *!                 modified.DPC_Destroy frees the DPC_Object only on
- *!                 Successful termination of the thread and the handle.
- *! 06-Jan-1999 ag: Format cleanup for code review.
- *!                 Removed DPC_[Lower|Raise]IRQL[From|To]DispatchLevel.
- *! 10-Dec-1999 ag: Added SetProcPermissions in DPC_DeferredProcedure().
- *!                 (Needed to access client(s) CHNL buffers).
- *! 19-Sep-1999 a0216266: Stubbed from dpcnt.c.
- */
-
-/*  ----------------------------------- Host OS */
-#include <dspbridge/host_os.h>
-
-/*  ----------------------------------- DSP/BIOS Bridge */
-#include <dspbridge/std.h>
-#include <dspbridge/dbdefs.h>
-#include <dspbridge/errbase.h>
-
-/*  ----------------------------------- Trace & Debug */
-#include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
-
-/*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/mem.h>
-
-/*  ----------------------------------- This */
-#include <dspbridge/dpc.h>
-
-/*  ----------------------------------- Defines, Data Structures, Typedefs */
-#define SIGNATURE       0x5f435044	/* "DPC_" (in reverse). */
-
-/* The DPC object, passed to our priority event callback routine: */
-struct DPC_OBJECT {
-	u32 dwSignature;	/* Used for object validation.   */
-	void *pRefData;		/* Argument for client's DPC.    */
-	DPC_PROC pfnDPC;	/* Client's DPC.                 */
-	u32 numRequested;	/* Number of requested DPC's.      */
-	u32 numScheduled;	/* Number of executed DPC's.      */
-	struct tasklet_struct dpc_tasklet;
-
-#ifdef DEBUG
-	u32 cEntryCount;	/* Number of times DPC reentered. */
-	u32 numRequestedMax;	/* Keep track of max pending DPC's. */
-#endif
-
-	spinlock_t dpc_lock;
-};
-
-/*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask DPC_DebugMask = { NULL, NULL };	/* DPC Debug Mask */
-#endif
-
-/*  ----------------------------------- Function Prototypes */
-static void DPC_DeferredProcedure(IN unsigned long pDeferredContext);
-
-/*
- *  ======== DPC_Create ========
- *  Purpose:
- *      Create a DPC object, allowing a client's own DPC procedure to be
- *      scheduled for a call with client reference data.
- */
-DSP_STATUS DPC_Create(OUT struct DPC_OBJECT **phDPC, DPC_PROC pfnDPC,
-		      void *pRefData)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct DPC_OBJECT *pDPCObject = NULL;
-
-	if ((phDPC != NULL) && (pfnDPC != NULL)) {
-		/*
-		 *  Allocate a DPC object to store information allowing our DPC
-		 *  callback to dispatch to the client's DPC.
-		 */
-		MEM_AllocObject(pDPCObject, struct DPC_OBJECT, SIGNATURE);
-		if (pDPCObject != NULL) {
-			tasklet_init(&pDPCObject->dpc_tasklet,
-				     DPC_DeferredProcedure,
-				     (u32) pDPCObject);
-			/* Fill out our DPC Object: */
-			pDPCObject->pRefData = pRefData;
-			pDPCObject->pfnDPC = pfnDPC;
-			pDPCObject->numRequested = 0;
-			pDPCObject->numScheduled = 0;
-#ifdef DEBUG
-			pDPCObject->numRequestedMax = 0;
-			pDPCObject->cEntryCount = 0;
-#endif
-			spin_lock_init(&pDPCObject->dpc_lock);
-			*phDPC = pDPCObject;
-		} else {
-			GT_0trace(DPC_DebugMask, GT_6CLASS,
-				  "DPC_Create: DSP_EMEMORY\n");
-			status = DSP_EMEMORY;
-		}
-	} else {
-		GT_0trace(DPC_DebugMask, GT_6CLASS,
-			  "DPC_Create: DSP_EPOINTER\n");
-		status = DSP_EPOINTER;
-	}
-	DBC_Ensure((DSP_FAILED(status) && (!phDPC || (phDPC && *phDPC == NULL)))
-		   || DSP_SUCCEEDED(status));
-	return status;
-}
-
-/*
- *  ======== DPC_Destroy ========
- *  Purpose:
- *      Cancel the last scheduled DPC, and deallocate a DPC object previously
- *      allocated with DPC_Create(). Frees the Object only if the thread
- *      and the event terminated successfuly.
- */
-DSP_STATUS DPC_Destroy(struct DPC_OBJECT *hDPC)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct DPC_OBJECT *pDPCObject = (struct DPC_OBJECT *)hDPC;
-
-	if (MEM_IsValidHandle(hDPC, SIGNATURE)) {
-
-		/* Free our DPC object: */
-		if (DSP_SUCCEEDED(status)) {
-			tasklet_kill(&pDPCObject->dpc_tasklet);
-			MEM_FreeObject(pDPCObject);
-			pDPCObject = NULL;
-			GT_0trace(DPC_DebugMask, GT_2CLASS,
-				  "DPC_Destroy: SUCCESS\n");
-		}
-	} else {
-		GT_0trace(DPC_DebugMask, GT_6CLASS,
-			  "DPC_Destroy: DSP_EHANDLE\n");
-		status = DSP_EHANDLE;
-	}
-	DBC_Ensure((DSP_SUCCEEDED(status) && pDPCObject == NULL)
-		   || DSP_FAILED(status));
-	return status;
-}
-
-/*
- *  ======== DPC_Exit ========
- *  Purpose:
- *      Discontinue usage of the DPC module.
- */
-void DPC_Exit(void)
-{
-	GT_0trace(DPC_DebugMask, GT_5CLASS, "Entered DPC_Exit\n");
-}
-
-/*
- *  ======== DPC_Init ========
- *  Purpose:
- *      Initialize the DPC module's private state.
- */
-bool DPC_Init(void)
-{
-	GT_create(&DPC_DebugMask, "DP");
-
-	GT_0trace(DPC_DebugMask, GT_5CLASS, "Entered DPC_Init\n");
-
-	return true;
-}
-
-/*
- *  ======== DPC_Schedule ========
- *  Purpose:
- *      Schedule a deferred procedure call to be executed at a later time.
- *      Latency and order of DPC execution is platform specific.
- */
-DSP_STATUS DPC_Schedule(struct DPC_OBJECT *hDPC)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct DPC_OBJECT *pDPCObject = (struct DPC_OBJECT *)hDPC;
-	unsigned long flags;
-
-	GT_1trace(DPC_DebugMask, GT_ENTER, "DPC_Schedule hDPC %x\n", hDPC);
-	if (MEM_IsValidHandle(hDPC, SIGNATURE)) {
-		/* Increment count of DPC's pending. Needs to be protected
-		 * from ISRs since this function is called from process
-		 * context also. */
-		spin_lock_irqsave(&hDPC->dpc_lock, flags);
-		pDPCObject->numRequested++;
-		spin_unlock_irqrestore(&hDPC->dpc_lock, flags);
-		tasklet_schedule(&(hDPC->dpc_tasklet));
-#ifdef DEBUG
-		if (pDPCObject->numRequested > pDPCObject->numScheduled +
-						pDPCObject->numRequestedMax) {
-			pDPCObject->numRequestedMax = pDPCObject->numRequested -
-						pDPCObject->numScheduled;
-		}
-#endif
-	/*  If an interrupt occurs between incrementing numRequested and the
-	 *  assertion below, then DPC will get executed while returning from
-	 *  ISR, which will complete all requests and make numRequested equal
-	 * to numScheduled, firing this assertion. This happens only when
-	 * DPC is being scheduled in process context */
-	} else {
-		GT_0trace(DPC_DebugMask, GT_6CLASS,
-			  "DPC_Schedule: DSP_EHANDLE\n");
-		status = DSP_EHANDLE;
-	}
-	GT_1trace(DPC_DebugMask, GT_ENTER, "DPC_Schedule status %x\n", status);
-	return status;
-}
-
-/*
- *  ======== DeferredProcedure ========
- *  Purpose:
- *      Main DPC routine.  This is called by host OS DPC callback
- *      mechanism with interrupts enabled.
- */
-static void DPC_DeferredProcedure(IN unsigned long pDeferredContext)
-{
-	struct DPC_OBJECT *pDPCObject = (struct DPC_OBJECT *)pDeferredContext;
-	/* read numRequested in local variable */
-	u32 requested;
-	u32 serviced;
-
-	DBC_Require(pDPCObject != NULL);
-	requested = pDPCObject->numRequested;
-	serviced = pDPCObject->numScheduled;
-
-	GT_1trace(DPC_DebugMask, GT_ENTER, "> DPC_DeferredProcedure "
-		  "pDeferredContext=%x\n", pDeferredContext);
-	/* Rollover taken care of using != instead of < */
-	if (serviced != requested) {
-		if (pDPCObject->pfnDPC != NULL) {
-			/* Process pending DPC's: */
-			do {
-				/* Call client's DPC: */
-				(*(pDPCObject->pfnDPC))(pDPCObject->pRefData);
-				serviced++;
-			} while (serviced != requested);
-		}
-		pDPCObject->numScheduled = requested;
-	}
-	GT_2trace(DPC_DebugMask, GT_ENTER,
-		  "< DPC_DeferredProcedure requested %d"
-		  " serviced %d\n", requested, serviced);
-}
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/services/kfile.c kernel-power-2.6.28.new/drivers/dsp/bridge/services/kfile.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/services/kfile.c	2011-10-11 13:51:01.784718101 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/services/kfile.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,335 +0,0 @@
-/*
- * kfile.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== kfilece.c ========
- *  Purpose:
- *      This module provides file i/o services.
- *
- *  Public Functions:
- *      KFILE_Close
- *      KFILE_Exit
- *      KFILE_Init
- *      KFILE_Open
- *      KFILE_Read
- *      KFILE_Seek
- *      KFILE_Tell
- *
- *! Revision History
- *! ================
- *! 03-Feb-2000 rr: Module init/exit is handled by SERVICES Init/Exit.
- *!		 GT Changes.
- *! 22-Nov-1999 kc: Added changes from code review.
- *! 12-Nov-1999 kc: Enabled CSL for UNICODE/ANSI string conversions.
- *! 30-Sep-1999 ag: Changed KFILE_Read() GT level from _ENTER to _4CLASS.
- *!                 Removed GT_set().
- *! 25-Aug-1999 ag: Changed MEM_Calloc allocation type to MEM_PAGED.
- *! 13-Jul-1999 a0216266(ww - TID): Stubbed from kfilent.c.
- */
-
-/*  ----------------------------------- Host OS */
-#include <dspbridge/host_os.h>
-
-/*  ----------------------------------- DSP/BIOS Bridge */
-#include <dspbridge/std.h>
-#include <dspbridge/dbdefs.h>
-#include <dspbridge/errbase.h>
-
-/*  ----------------------------------- Trace & Debug */
-#include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
-
-/*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
-#include <dspbridge/mem.h>
-
-/*  ----------------------------------- This */
-#include <dspbridge/kfile.h>
-
-/*  ----------------------------------- Defines, Data Structures, Typedefs */
-#define SIGNATURE           0x4c49464b	/* hex code of KFIL (reversed) */
-#define MAXFILENAMELENGTH   256
-#define GENERAL_FAILURE     0xffffffff	/* SetFilePointer error */
-
-/* The KFILE_FileObj abstracts the true file handle from a KFILE handle. */
-struct KFILE_FileObj {
-    u32 dwSignature;
-    __kernel_pid_t owner_pid;	/* PID of process that opened this file */
-    char 	*fileName  ;
-    bool          isOpen    ;
-    u32        size      ;
-    u32        curPos    ;
-    long 	  hInternal;		/* internal handle of file */
-    struct file *fileDesc;
-
-};
-
-/*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask KFILE_debugMask = { NULL, NULL };	/* Debug mask */
-#endif
-
-/*
- *  ======== KFILE_Close ========
- *  Purpose:
- *      This function closes a file's stream.
- */
-s32 KFILE_Close(struct KFILE_FileObj *hFile)
-{
-	s32 cRetVal = 0;	/* 0 indicates success */
-	s32 fRetVal = 0;
-
-	GT_1trace(KFILE_debugMask, GT_ENTER, "KFILE_Close: hFile 0x%x\n",
-		  hFile);
-
-	/* Check for valid handle */
-	if (MEM_IsValidHandle(hFile, SIGNATURE)) {
-		/* Close file only if opened by the same process (id). Otherwise
-		 * Linux closes all open file handles when process exits.*/
-		fRetVal = filp_close(hFile->fileDesc, NULL) ;
-		if (fRetVal) {
-			cRetVal = E_KFILE_ERROR;
-			GT_1trace(KFILE_debugMask, GT_6CLASS,
-				  "KFILE_Close: sys_close "
-				  "returned %d\n", fRetVal);
-		}
-		MEM_FreeObject(hFile);
-	} else {
-		cRetVal = E_KFILE_INVALIDHANDLE;
-		GT_0trace(KFILE_debugMask, GT_6CLASS, "KFILE_Close: "
-			  "invalid file handle\n");
-	}
-	return cRetVal;
-}
-
-/*
- *  ======== KFILE_Exit ========
- *  Purpose:
- *      Decrement reference count, and free resources when reference count
- *      is 0.
- */
-void KFILE_Exit(void)
-{
-	GT_0trace(KFILE_debugMask, GT_5CLASS, "KFILE_Exit\n");
-}
-
-/*
- *  ======== KFILE_Init ========
- */
-bool KFILE_Init(void)
-{
-	GT_create(&KFILE_debugMask, "KF");	/* "KF" for KFile */
-
-	GT_0trace(KFILE_debugMask, GT_5CLASS, "KFILE_Init\n");
-
-	return true;
-}
-
-/*
- *  ======== KFILE_Open ========
- *  Purpose:
- *      Open a file for reading ONLY
- */
-struct KFILE_FileObj *KFILE_Open(CONST char *pszFileName, CONST char *pszMode)
-{
-	struct KFILE_FileObj *hFile;	/* file handle */
-	DSP_STATUS status;
-	mm_segment_t fs;
-
-	struct file*fileDesc = NULL;
-	DBC_Require(pszMode != NULL);
-	DBC_Require(pszFileName != NULL);
-
-	GT_2trace(KFILE_debugMask, GT_ENTER,
-		  "KFILE_Open: pszFileName %s, pszMode "
-		  "%s\n", pszFileName, pszMode);
-
-	/* create a KFILE object */
-	MEM_AllocObject(hFile, struct KFILE_FileObj, SIGNATURE);
-
-	if (hFile) {
-		fs = get_fs();
-		set_fs(get_ds());
-	/* Third argument is mode (permissions). Ignored unless creating file */
-		fileDesc = filp_open(pszFileName, O_RDONLY, 0);
-		if ((IS_ERR(fileDesc)) || (fileDesc == NULL) ||
-		     (fileDesc->f_op == NULL) || (fileDesc->f_op->read == NULL)
-		     || (fileDesc->f_op->llseek == NULL)) {
-			status = DSP_EFILE;
-		} else {
-			hFile->fileDesc = fileDesc;
-			hFile->fileName = (char *)pszFileName;
-			hFile->isOpen	   = true;
-			hFile->curPos   = 0;
-			hFile->size = fileDesc->f_op->llseek(fileDesc, 0,
-							    SEEK_END);
-			fileDesc->f_op->llseek(fileDesc, 0, SEEK_SET);
-			/* Return TGID instead of process handle */
-			hFile->owner_pid = current->tgid;
-
-			status = DSP_SOK;
-		}
-		set_fs(fs);
-		if (DSP_FAILED(status)) {
-			/* free memory, and clear handle */
-			MEM_FreeObject(hFile);
-			hFile = NULL;
-		}
-	} else {
-			GT_0trace(KFILE_debugMask, GT_6CLASS,
-				  "KFILE_Open: MEM_AllocObject failed\n");
-			status = DSP_EMEMORY;
-	}
-	return hFile;
-}
-
-/*
- *  ======== KFILE_Read ========
- *  Purpose:
- *      Reads a specified number of bytes into a buffer.
- */
-s32
-KFILE_Read(void __user*pBuffer, s32 cSize, s32 cCount,
-			struct KFILE_FileObj *hFile)
-{
-	u32 dwBytesRead = 0;
-	s32 cRetVal = 0;
-	mm_segment_t fs;
-
-	DBC_Require(pBuffer != NULL);
-
-	GT_4trace(KFILE_debugMask, GT_4CLASS,
-		  "KFILE_Read: buffer 0x%x, cSize 0x%x,"
-		  "cCount 0x%x, hFile 0x%x\n", pBuffer, cSize, cCount, hFile);
-
-	/* check for valid file handle */
-	if (MEM_IsValidHandle(hFile, SIGNATURE)) {
-		if ((cSize > 0) && (cCount > 0) && pBuffer) {
-			/* read from file */
-			fs = get_fs();
-			set_fs(get_ds());
-			dwBytesRead = hFile->fileDesc->f_op->read(hFile->
-				      fileDesc, pBuffer, cSize *cCount,
-				      &(hFile->fileDesc->f_pos));
-			set_fs(fs);
-			if (dwBytesRead) {
-				cRetVal = dwBytesRead / cSize;
-				hFile->curPos += dwBytesRead;
-				DBC_Assert((dwBytesRead / cSize) <= \
-					  (u32)cCount);
-			} else {
-				cRetVal = E_KFILE_ERROR;
-				GT_0trace(KFILE_debugMask, GT_6CLASS,
-					  "KFILE_Read: sys_read() failed\n");
-			}
-		} else {
-			cRetVal = DSP_EINVALIDARG;
-			GT_0trace(KFILE_debugMask, GT_6CLASS,
-				  "KFILE_Read: Invalid argument(s)\n");
-		}
-	} else {
-		cRetVal = E_KFILE_INVALIDHANDLE;
-		GT_0trace(KFILE_debugMask, GT_6CLASS,
-			  "KFILE_Read: invalid file handle\n");
-	}
-
-	return cRetVal;
-}
-
-/*
- *  ======== KFILE_Seek ========
- *  Purpose:
- *      Sets the file position indicator. NOTE:  we don't support seeking
- *      beyond the boundaries of a file.
- */
-s32 KFILE_Seek(struct KFILE_FileObj *hFile, s32 lOffset, s32 cOrigin)
-{
-	s32 cRetVal = 0;	/* 0 for success */
-	loff_t dwCurPos = 0;
-
-	struct file *fileDesc = NULL;
-
-	GT_3trace(KFILE_debugMask, GT_ENTER, "KFILE_Seek: hFile 0x%x, "
-		  "lOffset 0x%x, cOrigin 0x%x\n",
-		  hFile, lOffset, cOrigin);
-
-	/* check for valid file handle */
-	if (MEM_IsValidHandle(hFile, SIGNATURE)) {
-		/* based on the origin flag, move the internal pointer */
-
-	fileDesc = hFile->fileDesc;
-		switch (cOrigin) {
-		case KFILE_SEEK_SET:
-			dwCurPos = hFile->fileDesc->f_op->llseek(hFile->
-				   fileDesc, lOffset, SEEK_SET);
-			cRetVal = ((dwCurPos >= 0) ? 0 : E_KFILE_ERROR);
-			break;
-
-		case KFILE_SEEK_CUR:
-			dwCurPos = hFile->fileDesc->f_op->llseek(hFile->
-				   fileDesc, lOffset, SEEK_CUR);
-			cRetVal = ((dwCurPos >= 0) ? 0 : E_KFILE_ERROR);
-			break;
-		case KFILE_SEEK_END:
-			dwCurPos = hFile->fileDesc->f_op->llseek(hFile->
-				   fileDesc, lOffset, SEEK_END);
-			cRetVal = ((dwCurPos >= 0) ? 0 : E_KFILE_ERROR);
-			break;
-		default:
-			cRetVal = E_KFILE_BADORIGINFLAG;
-			GT_0trace(KFILE_debugMask, GT_6CLASS,
-				  "KFILE_Seek:bad origin flag\n");
-			break;
-		}
-	} else {
-		cRetVal = E_KFILE_INVALIDHANDLE;
-		GT_0trace(KFILE_debugMask, GT_6CLASS,
-			  "KFILE_Seek:invalid file handle\n");
-	}
-	return cRetVal;
-}
-
-/*
- *  ======== KFILE_Tell ========
- *  Purpose:
- *      Reports the current value of the position indicator. We did not
- *	    consider 64 bit long file size, which implies a 4GB file limit
- *      (2 to 32 power).
- */
-s32 KFILE_Tell(struct KFILE_FileObj *hFile)
-{
-	loff_t dwCurPos = 0;
-	s32 lRetVal = E_KFILE_ERROR;
-
-	GT_1trace(KFILE_debugMask, GT_ENTER, "KFILE_Tell: hFile 0x%x\n", hFile);
-
-	if (MEM_IsValidHandle(hFile, SIGNATURE)) {
-
-		/* Get current position. */
-		dwCurPos = hFile->fileDesc->f_op->llseek(hFile->fileDesc, 0,
-			   SEEK_CUR);
-		if (dwCurPos >= 0)
-			lRetVal = dwCurPos;
-
-	} else {
-		lRetVal = E_KFILE_INVALIDHANDLE;
-		GT_0trace(KFILE_debugMask, GT_6CLASS,
-			  "KFILE_Seek:invalid file handle\n");
-	}
-	return lRetVal;
-}
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/services/list.c kernel-power-2.6.28.new/drivers/dsp/bridge/services/list.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/services/list.c	2011-10-11 13:51:01.907299244 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/services/list.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,285 +0,0 @@
-/*
- * list.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== listce.c ========
- *  Purpose
- *      Provides standard circular list handling functions.
- *
- *  Public Functions:
- *      LST_Create
- *      LST_Delete
- *      LST_Exit
- *      LST_First
- *      LST_GetHead
- *      LST_Init
- *      LST_InitElem
- *      LST_InsertBefore
- *      LST_Next
- *      LST_PutTail
- *      LST_RemoveElem
- *
- *! Revision History
- *! ================
- *! 06-Mar-2002 jeh Don't set element self to NULL in LST_RemoveElem().
- *! 10-Aug-2000 ag: Added LST_InsertBefore().
- *! 03-Feb-2000 rr: Module init/exit is handled by SERVICES Init/Exit.
- *!		 GT Changes.
- *! 22-Nov-1999 kc: Added changes from code review.
- *! 10-Aug-1999 kc: Based on wsx-c18.
- *! 16-Jun-1997 gp: Removed unnecessary enabling/disabling of interrupts around
- *!                 list manipulation code.
- *! 22-Oct-1996 gp: Added LST_RemoveElem, and LST_First/LST_Next iterators.
- *! 10-Aug-1996 gp: Acquired from SMM for WinSPOX v. 1.1; renamed identifiers.
- */
-
-/*  ----------------------------------- DSP/BIOS Bridge */
-#include <dspbridge/std.h>
-#include <dspbridge/dbdefs.h>
-
-/*  ----------------------------------- Trace & Debug */
-#include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
-
-/*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/mem.h>
-
-/*  ----------------------------------- This */
-#include <dspbridge/list.h>
-
-/*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask LST_debugMask = { NULL, NULL };	/* GT trace var. */
-#endif
-
-/*
- *  ======== LST_Create ========
- *  Purpose:
- *      Allocates and initializes a circular list.
- */
-struct LST_LIST *LST_Create(void)
-{
-	struct LST_LIST *pList;
-
-	GT_0trace(LST_debugMask, GT_ENTER, "LST_Create: entered\n");
-
-	pList = (struct LST_LIST *) MEM_Calloc(sizeof(struct LST_LIST),
-		MEM_NONPAGED);
-	if (pList != NULL) {
-		pList->head.next = &pList->head;
-		pList->head.prev = &pList->head;
-		pList->head.self = NULL;
-	}
-
-	return pList;
-}
-
-/*
- *  ======== LST_Delete ========
- *  Purpose:
- *      Removes a list by freeing its control structure's memory space.
- */
-void LST_Delete(struct LST_LIST *pList)
-{
-	DBC_Require(pList != NULL);
-
-	GT_1trace(LST_debugMask, GT_ENTER, "LST_Delete: pList 0x%x\n", pList);
-
-	MEM_Free(pList);
-}
-
-/*
- *  ======== LST_Exit ========
- *  Purpose:
- *      Discontinue usage of the LST module.
- */
-void LST_Exit(void)
-{
-	GT_0trace(LST_debugMask, GT_5CLASS, "LST_Exit\n");
-}
-
-/*
- *  ======== LST_First ========
- *  Purpose:
- *      Returns a pointer to the first element of the list, or NULL if the
- *      list is empty.
- */
-struct LST_ELEM *LST_First(struct LST_LIST *pList)
-{
-	struct LST_ELEM *pElem = NULL;
-
-	DBC_Require(pList != NULL);
-
-	GT_1trace(LST_debugMask, GT_ENTER, "LST_First: pList 0x%x\n", pList);
-
-	if (!LST_IsEmpty(pList))
-		pElem = pList->head.next;
-
-	return pElem;
-}
-
-/*
- *  ======== LST_GetHead ========
- *  Purpose:
- *      "Pops" the head off the list and returns a pointer to it.
- */
-struct LST_ELEM *LST_GetHead(struct LST_LIST *pList)
-{
-	struct LST_ELEM *pElem;
-
-	DBC_Require(pList != NULL);
-
-	GT_1trace(LST_debugMask, GT_ENTER, "LST_GetHead: pList 0x%x\n", pList);
-
-	if (LST_IsEmpty(pList))
-		return NULL;
-
-	/* pElem is always valid because the list cannot be empty
-	 * at this point */
-	pElem = pList->head.next;
-	pList->head.next = pElem->next;
-	pElem->next->prev = &pList->head;
-
-	return pElem->self;
-}
-
-/*
- *  ======== LST_Init ========
- *  Purpose:
- *      Initialize LST module private state.
- */
-bool LST_Init(void)
-{
-	GT_create(&LST_debugMask, "LS");	/* LS for LSt module */
-
-	GT_0trace(LST_debugMask, GT_5CLASS, "LST_Init\n");
-
-	return true;
-}
-
-/*
- *  ======== LST_InitElem ========
- *  Purpose:
- *      Initializes a list element to default (cleared) values
- */
-void LST_InitElem(struct LST_ELEM *pElem)
-{
-	DBC_Require(pElem != NULL);
-
-	GT_1trace(LST_debugMask, GT_ENTER, "LST_InitElem: pElem 0x%x\n", pElem);
-
-	if (pElem) {
-		pElem->next = NULL;
-		pElem->prev = NULL;
-		pElem->self = pElem;
-	}
-}
-
-/*
- *  ======== LST_InsertBefore ========
- *  Purpose:
- *      Insert the element before the existing element.
- */
-void LST_InsertBefore(struct LST_LIST *pList, struct LST_ELEM *pElem,
-		      struct LST_ELEM *pElemExisting)
-{
-	DBC_Require(pList != NULL);
-	DBC_Require(pElem != NULL);
-	DBC_Require(pElemExisting != NULL);
-
-	GT_3trace(LST_debugMask, GT_ENTER, "LST_InsertBefore: pList 0x%x, "
-		  "pElem 0x%x pElemExisting 0x%x\n", pList, pElem,
-		  pElemExisting);
-
-	pElemExisting->prev->next = pElem;
-	pElem->prev = pElemExisting->prev;
-	pElem->next = pElemExisting;
-	pElemExisting->prev = pElem;
-}
-
-/*
- *  ======== LST_Next ========
- *  Purpose:
- *      Returns a pointer to the next element of the list, or NULL if the
- *      next element is the head of the list or the list is empty.
- */
-struct LST_ELEM *LST_Next(struct LST_LIST *pList, struct LST_ELEM *pCurElem)
-{
-	struct LST_ELEM *pNextElem = NULL;
-
-	DBC_Require(pList != NULL);
-	DBC_Require(pCurElem != NULL);
-
-	GT_2trace(LST_debugMask, GT_ENTER,
-		  "LST_Next: pList 0x%x, pCurElem 0x%x\n",
-		  pList, pCurElem);
-
-	if (!LST_IsEmpty(pList)) {
-		if (pCurElem->next != &pList->head)
-			pNextElem = pCurElem->next;
-	}
-
-	return pNextElem;
-}
-
-/*
- *  ======== LST_PutTail ========
- *  Purpose:
- *      Adds the specified element to the tail of the list
- */
-void LST_PutTail(struct LST_LIST *pList, struct LST_ELEM *pElem)
-{
-	DBC_Require(pList != NULL);
-	DBC_Require(pElem != NULL);
-
-	GT_2trace(LST_debugMask, GT_ENTER,
-		  "LST_PutTail: pList 0x%x, pElem 0x%x\n",
-		  pList, pElem);
-
-	pElem->prev = pList->head.prev;
-	pElem->next = &pList->head;
-	pList->head.prev = pElem;
-	pElem->prev->next = pElem;
-
-	DBC_Ensure(!LST_IsEmpty(pList));
-}
-
-/*
- *  ======== LST_RemoveElem ========
- *  Purpose:
- *      Removes (unlinks) the given element from the list, if the list is not
- *      empty.  Does not free the list element.
- */
-void LST_RemoveElem(struct LST_LIST *pList, struct LST_ELEM *pCurElem)
-{
-	DBC_Require(pList != NULL);
-	DBC_Require(pCurElem != NULL);
-
-	GT_2trace(LST_debugMask, GT_ENTER,
-		  "LST_RemoveElem: pList 0x%x, pCurElem "
-		  "0x%x\n", pList, pCurElem);
-
-	if (!LST_IsEmpty(pList)) {
-		pCurElem->prev->next = pCurElem->next;
-		pCurElem->next->prev = pCurElem->prev;
-
-		/* set elem fields to NULL to prevent illegal references */
-		pCurElem->next = NULL;
-		pCurElem->prev = NULL;
-	}
-}
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/services/mem.c kernel-power-2.6.28.new/drivers/dsp/bridge/services/mem.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/services/mem.c	2011-10-11 13:51:01.913153003 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/services/mem.c	2011-10-23 08:22:37.677315000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implementation of platform specific memory services.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,43 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== mem.c ========
- *  Purpose:
- *      Implementation of platform specific memory services.
- *
- *  Public Functions:
- *      MEM_Alloc
- *      MEM_AllocPhysMem
- *      MEM_Calloc
- *      MEM_Exit
- *      MEM_FlushCache
- *      MEM_Free
- *      MEM_FreePhysMem
- *      MEM_Init
- *      MEM_ExtPhysPoolInit
- *
- *! Revision History:
- *! =================
- *! 18-Jan-2004 hp: Added support for External physical memory pool
- *! 19-Apr-2004 sb: Added Alloc/Free PhysMem, FlushCache, VirtualToPhysical
- *! 01-Sep-2001 ag: Code cleanup.
- *! 02-May-2001 ag: MEM_[UnMap]LinearAddress revamped to align Phys to Virt.
- *!		 Set PAGE_PHYSICAL if phy addr <= 512MB. Opposite uSoft doc!
- *! 29-Aug-2000 rr: MEM_LinearAddress does not check for 512MB for non-x86.
- *! 28-Mar-2000 rr: MEM_LinearAddress changed.Handles address larger than 512MB
- *! 03-Feb-2000 rr: Module init/exit is handled by SERVICES Init/Exit.
- *!		 GT Changes.
- *! 22-Nov-1999 kc: Added changes from code review.
- *! 16-Aug-1999 kc: modified for WinCE.
- *! 20-Mar-1999 ag: SP 4 fix in MEM_UMBCalloc().
- *!		 Mdl offset now ORed not added to userBuf.
- *! 23-Dec-1997 cr: Code review changes.
- *! 08-Dec-1997 cr: Prepared for code review.
- *! 24-Jun-1997 cr: Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -61,202 +26,90 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- This */
 #include <dspbridge/mem.h>
 #include <dspbridge/list.h>
 
 /*  ----------------------------------- Defines */
-#define MEM_512MB   0x1fffffff
-#define memInfoSign 0x464E494D	/* "MINF" (in reverse). */
-
-#ifdef DEBUG
-#define MEM_CHECK		/* Use to detect source of memory leaks */
-#endif
+#define MEM512MB   0x1fffffff
 
 /*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask MEM_debugMask = { NULL, NULL };	/* GT trace variable */
-#endif
-
-static u32 cRefs;		/* module reference count */
-
-static bool extPhysMemPoolEnabled;
-
-struct extPhysMemPool {
-	u32 physMemBase;
-	u32 physMemSize;
-	u32 virtMemBase;
-	u32 nextPhysAllocPtr;
-};
-
-static struct extPhysMemPool extMemPool;
-
-/*  Information about each element allocated on heap */
-struct memInfo {
-	struct LST_ELEM link;		/* Must be first */
-	size_t size;
-	void *caller;
-	u32 dwSignature;	/* Should be last */
-};
-
-#ifdef MEM_CHECK
+static bool ext_phys_mem_pool_enabled;
 
-/*
- *  This structure holds a linked list to all memory elements allocated on
- *  heap by DSP/BIOS Bridge. This is used to report memory leaks and free
- *  such elements while removing the DSP/BIOS Bridge driver
- */
-struct memMan {
-	struct LST_LIST lst;
-	spinlock_t lock;
+struct ext_phys_mem_pool {
+	u32 phys_mem_base;
+	u32 phys_mem_size;
+	u32 virt_mem_base;
+	u32 next_phys_alloc_ptr;
 };
 
-static struct memMan mMan;
+static struct ext_phys_mem_pool ext_mem_pool;
 
-/*
- *  These functions are similar to LST_PutTail and LST_RemoveElem and are
- *  duplicated here to make MEM independent of LST
- */
-static inline void MLST_PutTail(struct LST_LIST *pList, struct LST_ELEM *pElem)
-{
-	pElem->prev = pList->head.prev;
-	pElem->next = &pList->head;
-	pList->head.prev = pElem;
-	pElem->prev->next = pElem;
-	pElem->self = pElem;
-}
-
-static inline void MLST_RemoveElem(struct LST_LIST *pList,
-				   struct LST_ELEM *pCurElem)
-{
-	pCurElem->prev->next = pCurElem->next;
-	pCurElem->next->prev = pCurElem->prev;
-	pCurElem->next = NULL;
-	pCurElem->prev = NULL;
-}
-
-static void MEM_Check(void)
+void mem_ext_phys_pool_init(u32 poolPhysBase, u32 poolSize)
 {
-	struct memInfo *pMem;
-	struct LST_ELEM *last = &mMan.lst.head;
-	struct LST_ELEM *curr = mMan.lst.head.next;
-
-	if (!LST_IsEmpty(&mMan.lst)) {
-		GT_0trace(MEM_debugMask, GT_7CLASS, "*** MEMORY LEAK ***\n");
-		GT_0trace(MEM_debugMask, GT_7CLASS,
-			  "Addr      Size      Caller\n");
-		while (curr != last) {
-			pMem = (struct memInfo *)curr;
-			curr = curr->next;
-			if ((u32)pMem > PAGE_OFFSET &&
-			    MEM_IsValidHandle(pMem, memInfoSign)) {
-				GT_3trace(MEM_debugMask, GT_7CLASS,
-					"%lx  %d\t [<%p>]\n",
-					(u32) pMem + sizeof(struct memInfo),
-					pMem->size, pMem->caller);
-				MLST_RemoveElem(&mMan.lst,
-						(struct LST_ELEM *) pMem);
-				kfree(pMem);
-			} else {
-				GT_1trace(MEM_debugMask, GT_7CLASS,
-					  "Invalid allocation or "
-					  "Buffer underflow at %x\n",
-					  (u32)pMem +	sizeof(struct memInfo));
-				break;
-			}
-		}
-	}
-	DBC_Ensure(LST_IsEmpty(&mMan.lst));
-}
-
-#endif
-
-void MEM_ExtPhysPoolInit(u32 poolPhysBase, u32 poolSize)
-{
-	u32 poolVirtBase;
+	u32 pool_virt_base;
 
 	/* get the virtual address for the physical memory pool passed */
-	poolVirtBase = (u32)ioremap(poolPhysBase, poolSize);
+	pool_virt_base = (u32) ioremap(poolPhysBase, poolSize);
 
-	if ((void **)poolVirtBase == NULL) {
-		GT_0trace(MEM_debugMask, GT_7CLASS,
-			  "[PHYS_POOL]Mapping External "
-			  "physical memory to virt failed \n");
-		extPhysMemPoolEnabled = false;
+	if ((void **)pool_virt_base == NULL) {
+		pr_err("%s: external physical memory map failed\n", __func__);
+		ext_phys_mem_pool_enabled = false;
 	} else {
-		extMemPool.physMemBase = poolPhysBase;
-		extMemPool.physMemSize = poolSize;
-		extMemPool.virtMemBase = poolVirtBase;
-		extMemPool.nextPhysAllocPtr = poolPhysBase;
-		extPhysMemPoolEnabled = true;
-		GT_3trace(MEM_debugMask, GT_1CLASS,
-			  "ExtMemory Pool details " "Pool"
-			  "Physical mem base = %0x " "Pool Physical mem size "
-			  "= %0x" "Pool Virtual mem base = %0x \n",
-			  poolPhysBase, poolSize, poolVirtBase);
+		ext_mem_pool.phys_mem_base = poolPhysBase;
+		ext_mem_pool.phys_mem_size = poolSize;
+		ext_mem_pool.virt_mem_base = pool_virt_base;
+		ext_mem_pool.next_phys_alloc_ptr = poolPhysBase;
+		ext_phys_mem_pool_enabled = true;
 	}
 }
 
-static void MEM_ExtPhysPoolRelease(void)
+void mem_ext_phys_pool_release(void)
 {
-	GT_0trace(MEM_debugMask, GT_1CLASS,
-		  "Releasing External memory pool \n");
-	if (extPhysMemPoolEnabled) {
-		iounmap((void *)(extMemPool.virtMemBase));
-		extPhysMemPoolEnabled = false;
+	if (ext_phys_mem_pool_enabled) {
+		iounmap((void *)(ext_mem_pool.virt_mem_base));
+		ext_phys_mem_pool_enabled = false;
 	}
 }
 
 /*
- *  ======== MEM_ExtPhysMemAlloc ========
+ *  ======== mem_ext_phys_mem_alloc ========
  *  Purpose:
  *     Allocate physically contiguous, uncached memory from external memory pool
  */
 
-static void *MEM_ExtPhysMemAlloc(u32 bytes, u32 align, OUT u32 *pPhysAddr)
+static void *mem_ext_phys_mem_alloc(u32 bytes, u32 align, OUT u32 * pPhysAddr)
 {
-	u32 newAllocPtr;
+	u32 new_alloc_ptr;
 	u32 offset;
-	u32 virtAddr;
+	u32 virt_addr;
 
-	GT_2trace(MEM_debugMask, GT_1CLASS,
-		  "Ext Memory Allocation" "bytes=0x%x , "
-		  "align=0x%x \n", bytes, align);
-	if (align == 0) {
-		GT_0trace(MEM_debugMask, GT_7CLASS,
-			  "ExtPhysical Memory Allocation "
-			  "No alignment request in allocation call !! \n");
+	if (align == 0)
 		align = 1;
-	}
-	if (bytes > ((extMemPool.physMemBase + extMemPool.physMemSize)
-	    - extMemPool.nextPhysAllocPtr)) {
-		GT_1trace(MEM_debugMask, GT_7CLASS,
-			  "ExtPhysical Memory Allocation "
-			  "unable to allocate memory for bytes = 0x%x \n",
-			  bytes);
+
+	if (bytes > ((ext_mem_pool.phys_mem_base + ext_mem_pool.phys_mem_size)
+		     - ext_mem_pool.next_phys_alloc_ptr)) {
 		pPhysAddr = NULL;
 		return NULL;
 	} else {
-		offset = (extMemPool.nextPhysAllocPtr & (align - 1));
+		offset = (ext_mem_pool.next_phys_alloc_ptr & (align - 1));
 		if (offset == 0)
-			newAllocPtr = extMemPool.nextPhysAllocPtr;
+			new_alloc_ptr = ext_mem_pool.next_phys_alloc_ptr;
 		else
-			newAllocPtr = (extMemPool.nextPhysAllocPtr) +
-				      (align - offset);
-		if ((newAllocPtr + bytes) <=
-		    (extMemPool.physMemBase + extMemPool.physMemSize)) {
+			new_alloc_ptr = (ext_mem_pool.next_phys_alloc_ptr) +
+			    (align - offset);
+		if ((new_alloc_ptr + bytes) <=
+		    (ext_mem_pool.phys_mem_base + ext_mem_pool.phys_mem_size)) {
 			/* we can allocate */
-			*pPhysAddr = newAllocPtr;
-			extMemPool.nextPhysAllocPtr = newAllocPtr + bytes;
-			virtAddr = extMemPool.virtMemBase + (newAllocPtr -
-				   extMemPool.physMemBase);
-			GT_2trace(MEM_debugMask, GT_1CLASS,
-				  "Ext Memory Allocation succedded "
-				  "phys address=0x%x , virtaddress=0x%x \n",
-				  newAllocPtr, virtAddr);
-			return (void *)virtAddr;
+			*pPhysAddr = new_alloc_ptr;
+			ext_mem_pool.next_phys_alloc_ptr =
+			    new_alloc_ptr + bytes;
+			virt_addr =
+			    ext_mem_pool.virt_mem_base + (new_alloc_ptr -
+							  ext_mem_pool.
+							  phys_mem_base);
+			return (void *)virt_addr;
 		} else {
 			*pPhysAddr = 0;
 			return NULL;
@@ -265,364 +118,153 @@
 }
 
 /*
- *  ======== MEM_Alloc ========
+ *  ======== mem_alloc ========
  *  Purpose:
  *      Allocate memory from the paged or non-paged pools.
  */
-void *MEM_Alloc(u32 cBytes, enum MEM_POOLATTRS type)
+void *mem_alloc(u32 byte_size, enum mem_poolattrs type)
 {
-	struct memInfo *pMem = NULL;
+	void *mem = NULL;
 
-	GT_2trace(MEM_debugMask, GT_ENTER,
-		  "MEM_Alloc: cBytes 0x%x\ttype 0x%x\n", cBytes, type);
-	if (cBytes > 0) {
+	if (byte_size > 0) {
 		switch (type) {
 		case MEM_NONPAGED:
-		/* If non-paged memory required, see note at top of file. */
+			/* Fall through */
 		case MEM_PAGED:
-#ifndef MEM_CHECK
-			pMem = kmalloc(cBytes,
-				(in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
-#else
-			pMem = kmalloc(cBytes + sizeof(struct memInfo),
-				(in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
-			if (pMem) {
-				pMem->size = cBytes;
-				pMem->caller = __builtin_return_address(0);
-				pMem->dwSignature = memInfoSign;
-
-				spin_lock(&mMan.lock);
-				MLST_PutTail(&mMan.lst,
-					    (struct LST_ELEM *)pMem);
-				spin_unlock(&mMan.lock);
-
-				pMem = (void *)((u32)pMem +
-					sizeof(struct memInfo));
-			}
-#endif
+			mem = kmalloc(byte_size,
+				      (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
 			break;
 		case MEM_LARGEVIRTMEM:
-#ifndef MEM_CHECK
-			pMem = vmalloc(cBytes);
-#else
-			pMem = vmalloc(cBytes + sizeof(struct memInfo));
-			if (pMem) {
-				pMem->size = cBytes;
-				pMem->caller = __builtin_return_address(0);
-				pMem->dwSignature = memInfoSign;
-
-				spin_lock(&mMan.lock);
-				MLST_PutTail(&mMan.lst,
-					    (struct LST_ELEM *) pMem);
-				spin_unlock(&mMan.lock);
-
-				pMem = (void *)((u32)pMem +
-					sizeof(struct memInfo));
-			}
-#endif
+			mem = vmalloc(byte_size);
 			break;
 
 		default:
-			GT_0trace(MEM_debugMask, GT_6CLASS,
-				  "MEM_Alloc: unexpected "
-				  "MEM_POOLATTRS value\n");
 			break;
 		}
 	}
 
-	return pMem;
+	return mem;
 }
 
 /*
- *  ======== MEM_AllocPhysMem ========
+ *  ======== mem_alloc_phys_mem ========
  *  Purpose:
  *      Allocate physically contiguous, uncached memory
  */
-void *MEM_AllocPhysMem(u32 cBytes, u32 ulAlign, OUT u32 *pPhysicalAddress)
+void *mem_alloc_phys_mem(u32 byte_size, u32 ulAlign, OUT u32 * pPhysicalAddress)
 {
-	void *pVaMem = NULL;
-	dma_addr_t paMem;
+	void *va_mem = NULL;
+	dma_addr_t pa_mem;
 
-	DBC_Require(cRefs > 0);
-
-	GT_2trace(MEM_debugMask, GT_ENTER,
-		  "MEM_AllocPhysMem: cBytes 0x%x\tulAlign"
-		  "0x%x\n", cBytes, ulAlign);
-
-	if (cBytes > 0) {
-		if (extPhysMemPoolEnabled) {
-			pVaMem = MEM_ExtPhysMemAlloc(cBytes, ulAlign,
-						    (u32 *)&paMem);
+	if (byte_size > 0) {
+		if (ext_phys_mem_pool_enabled) {
+			va_mem = mem_ext_phys_mem_alloc(byte_size, ulAlign,
+							(u32 *) &pa_mem);
 		} else
-			pVaMem = dma_alloc_coherent(NULL, cBytes, &paMem,
-				(in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
-		if (pVaMem == NULL) {
+			va_mem = dma_alloc_coherent(NULL, byte_size, &pa_mem,
+						    (in_atomic()) ? GFP_ATOMIC :
+						    GFP_KERNEL);
+		if (va_mem == NULL)
 			*pPhysicalAddress = 0;
-			GT_1trace(MEM_debugMask, GT_6CLASS,
-				  "MEM_AllocPhysMem failed: "
-				  "0x%x\n", pVaMem);
-		} else {
-			*pPhysicalAddress = paMem;
-		}
+		else
+			*pPhysicalAddress = pa_mem;
 	}
-	return pVaMem;
+	return va_mem;
 }
 
 /*
- *  ======== MEM_Calloc ========
+ *  ======== mem_calloc ========
  *  Purpose:
  *      Allocate zero-initialized memory from the paged or non-paged pools.
  */
-void *MEM_Calloc(u32 cBytes, enum MEM_POOLATTRS type)
+void *mem_calloc(u32 byte_size, enum mem_poolattrs type)
 {
-	struct memInfo *pMem = NULL;
+	void *mem = NULL;
 
-	GT_2trace(MEM_debugMask, GT_ENTER,
-		  "MEM_Calloc: cBytes 0x%x\ttype 0x%x\n",
-		  cBytes, type);
-
-	if (cBytes > 0) {
+	if (byte_size > 0) {
 		switch (type) {
 		case MEM_NONPAGED:
-		/* If non-paged memory required, see note at top of file. */
+			/*  Fall through */
 		case MEM_PAGED:
-#ifndef MEM_CHECK
-			pMem = kmalloc(cBytes,
-				(in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
-			if (pMem)
-				memset(pMem, 0, cBytes);
-
-#else
-			pMem = kmalloc(cBytes + sizeof(struct memInfo),
-				(in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
-			if (pMem) {
-				memset((void *)((u32)pMem +
-					sizeof(struct memInfo)), 0, cBytes);
-				pMem->size = cBytes;
-				pMem->caller = __builtin_return_address(0);
-				pMem->dwSignature = memInfoSign;
-				spin_lock(&mMan.lock);
-				MLST_PutTail(&mMan.lst,
-					(struct LST_ELEM *) pMem);
-				spin_unlock(&mMan.lock);
-				pMem = (void *)((u32)pMem +
-					sizeof(struct memInfo));
-			}
-#endif
+			mem = kzalloc(byte_size,
+				      (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
 			break;
 		case MEM_LARGEVIRTMEM:
-#ifndef MEM_CHECK
-			pMem = vmalloc(cBytes);
-			if (pMem)
-				memset(pMem, 0, cBytes);
-#else
-			pMem = vmalloc(cBytes + sizeof(struct memInfo));
-			if (pMem) {
-				memset((void *)((u32)pMem +
-					sizeof(struct memInfo)), 0, cBytes);
-				pMem->size = cBytes;
-				pMem->caller = __builtin_return_address(0);
-				pMem->dwSignature = memInfoSign;
-				spin_lock(&mMan.lock);
-				MLST_PutTail(&mMan.lst, (struct LST_ELEM *)
-					pMem);
-				spin_unlock(&mMan.lock);
-				pMem = (void *)((u32)pMem +
-					sizeof(struct memInfo));
-			}
-#endif
+			mem = __vmalloc(byte_size,
+					GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO,
+					PAGE_KERNEL);
 			break;
 		default:
-			GT_1trace(MEM_debugMask, GT_6CLASS,
-				  "MEM_Calloc: unexpected "
-				  "MEM_POOLATTRS value 0x%x\n", type);
 			break;
 		}
 	}
 
-	return pMem;
+	return mem;
 }
 
 /*
- *  ======== MEM_Exit ========
+ *  ======== mem_exit ========
  *  Purpose:
  *      Discontinue usage of the MEM module.
  */
-void MEM_Exit(void)
+void mem_exit(void)
 {
-	DBC_Require(cRefs > 0);
-
-	GT_1trace(MEM_debugMask, GT_5CLASS, "MEM_Exit: cRefs 0x%x\n", cRefs);
-
-	cRefs--;
-#ifdef MEM_CHECK
-	if (cRefs == 0)
-		MEM_Check();
-
-#endif
-	MEM_ExtPhysPoolRelease();
-	DBC_Ensure(cRefs >= 0);
 }
 
 /*
- *  ======== MEM_FlushCache ========
+ *  ======== mem_flush_cache ========
  *  Purpose:
  *      Flush cache
  */
-void MEM_FlushCache(void *pMemBuf, u32 cBytes, s32 FlushType)
+void mem_flush_cache(void *pMemBuf, u32 byte_size, s32 FlushType)
 {
-	DBC_Require(cRefs > 0);
+	if (!pMemBuf)
+		return;
 
 	switch (FlushType) {
-	/* invalidate only */
+		/* invalidate only */
 	case PROC_INVALIDATE_MEM:
-		dmac_inv_range(pMemBuf, pMemBuf + cBytes);
-		outer_inv_range(__pa((u32)pMemBuf), __pa((u32)pMemBuf +
-				cBytes));
-	break;
-	/* writeback only */
+		dmac_inv_range(pMemBuf, pMemBuf + byte_size);
+		outer_inv_range(__pa((u32) pMemBuf), __pa((u32) pMemBuf +
+							  byte_size));
+		break;
+		/* writeback only */
 	case PROC_WRITEBACK_MEM:
-		dmac_clean_range(pMemBuf, pMemBuf + cBytes);
-		outer_clean_range(__pa((u32)pMemBuf), __pa((u32)pMemBuf +
-				  cBytes));
-	break;
-	/* writeback and invalidate */
+		dmac_clean_range(pMemBuf, pMemBuf + byte_size);
+		outer_clean_range(__pa((u32) pMemBuf), __pa((u32) pMemBuf +
+							    byte_size));
+		break;
+		/* writeback and invalidate */
 	case PROC_WRITEBACK_INVALIDATE_MEM:
-		dmac_flush_range(pMemBuf, pMemBuf + cBytes);
-		outer_flush_range(__pa((u32)pMemBuf), __pa((u32)pMemBuf +
-				  cBytes));
-	break;
-	default:
-		GT_1trace(MEM_debugMask, GT_6CLASS, "MEM_FlushCache: invalid "
-			  "FlushMemType 0x%x\n", FlushType);
-	break;
-	}
-
-}
-
-/*
- *  ======== MEM_VFree ========
- *  Purpose:
- *      Free the given block of system memory in virtual space.
- */
-void MEM_VFree(IN void *pMemBuf)
-{
-#ifdef MEM_CHECK
-	struct memInfo *pMem = (void *)((u32)pMemBuf - sizeof(struct memInfo));
-#endif
-
-	DBC_Require(pMemBuf != NULL);
-
-	GT_1trace(MEM_debugMask, GT_ENTER, "MEM_VFree: pMemBufs 0x%x\n",
-		  pMemBuf);
-
-	if (pMemBuf) {
-#ifndef MEM_CHECK
-		vfree(pMemBuf);
-#else
-		if (pMem) {
-			if (pMem->dwSignature == memInfoSign) {
-				spin_lock(&mMan.lock);
-				MLST_RemoveElem(&mMan.lst,
-						(struct LST_ELEM *) pMem);
-				spin_unlock(&mMan.lock);
-				pMem->dwSignature = 0;
-				vfree(pMem);
-			} else {
-				GT_1trace(MEM_debugMask, GT_7CLASS,
-					"Invalid allocation or "
-					"Buffer underflow at %x\n",
-					(u32) pMem + sizeof(struct memInfo));
-			}
-		}
-#endif
+		dmac_flush_range(pMemBuf, pMemBuf + byte_size);
+		outer_flush_range(__pa((u32) pMemBuf), __pa((u32) pMemBuf +
+							    byte_size));
+		break;
 	}
-}
 
-/*
- *  ======== MEM_Free ========
- *  Purpose:
- *      Free the given block of system memory.
- */
-void MEM_Free(IN void *pMemBuf)
-{
-#ifdef MEM_CHECK
-	struct memInfo *pMem = (void *)((u32)pMemBuf - sizeof(struct memInfo));
-#endif
-
-	DBC_Require(pMemBuf != NULL);
-
-	GT_1trace(MEM_debugMask, GT_ENTER, "MEM_Free: pMemBufs 0x%x\n",
-		  pMemBuf);
-
-	if (pMemBuf) {
-#ifndef MEM_CHECK
-		kfree(pMemBuf);
-#else
-		if (pMem) {
-			if (pMem->dwSignature == memInfoSign) {
-				spin_lock(&mMan.lock);
-				MLST_RemoveElem(&mMan.lst,
-						(struct LST_ELEM *) pMem);
-				spin_unlock(&mMan.lock);
-				pMem->dwSignature = 0;
-				kfree(pMem);
-			} else {
-				GT_1trace(MEM_debugMask, GT_7CLASS,
-					"Invalid allocation or "
-					"Buffer underflow at %x\n",
-					(u32) pMem + sizeof(struct memInfo));
-			}
-		}
-#endif
-	}
 }
 
 /*
- *  ======== MEM_FreePhysMem ========
+ *  ======== mem_free_phys_mem ========
  *  Purpose:
  *      Free the given block of physically contiguous memory.
  */
-void MEM_FreePhysMem(void *pVirtualAddress, u32 pPhysicalAddress,
-		     u32 cBytes)
+void mem_free_phys_mem(void *pVirtualAddress, u32 pPhysicalAddress,
+		       u32 byte_size)
 {
-	DBC_Require(cRefs > 0);
-	DBC_Require(pVirtualAddress != NULL);
-
-	GT_1trace(MEM_debugMask, GT_ENTER, "MEM_FreePhysMem: pVirtualAddress "
-		  "0x%x\n", pVirtualAddress);
+	DBC_REQUIRE(pVirtualAddress != NULL);
 
-	if (!extPhysMemPoolEnabled)
-		dma_free_coherent(NULL, cBytes, pVirtualAddress,
-				 pPhysicalAddress);
+	if (!ext_phys_mem_pool_enabled)
+		dma_free_coherent(NULL, byte_size, pVirtualAddress,
+				  pPhysicalAddress);
 }
 
 /*
- *  ======== MEM_Init ========
+ *  ======== services_mem_init ========
  *  Purpose:
  *      Initialize MEM module private state.
  */
-bool MEM_Init(void)
+bool services_mem_init(void)
 {
-	DBC_Require(cRefs >= 0);
-
-	if (cRefs == 0) {
-		GT_create(&MEM_debugMask, "MM");	/* MM for MeM module */
-
-#ifdef MEM_CHECK
-		mMan.lst.head.next = &mMan.lst.head;
-		mMan.lst.head.prev = &mMan.lst.head;
-		mMan.lst.head.self = NULL;
-		spin_lock_init(&mMan.lock);
-#endif
-
-	}
-
-	cRefs++;
-
-	GT_1trace(MEM_debugMask, GT_5CLASS, "MEM_Init: cRefs 0x%x\n", cRefs);
-
-	DBC_Ensure(cRefs > 0);
-
 	return true;
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/services/ntfy.c kernel-power-2.6.28.new/drivers/dsp/bridge/services/ntfy.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/services/ntfy.c	2011-10-11 13:51:01.913153003 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/services/ntfy.c	2011-10-23 08:22:37.677315000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Manage lists of notification events.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,31 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== ntfyce.c ========
- *  Purpose:
- *      Manage lists of notification events.
- *
- *  Public Functions:
- *      NTFY_Create
- *      NTFY_Delete
- *      NTFY_Exit
- *      NTFY_Init
- *      NTFY_Notify
- *      NTFY_Register
- *
- *! Revision History:
- *! =================
- *! 06-Feb-2003 kc      Removed DSP_POSTMESSAGE related code.
- *! 05-Nov-2001 kc      Updated DSP_HNOTIFICATION structure.
- *! 10-May-2001 jeh     Removed SERVICES module init/exit from NTFY_Init/Exit.
- *!                     NTFY_Register() returns DSP_ENOTIMPL for all but
- *!                     DSP_SIGNALEVENT.
- *! 12-Oct-2000 jeh     Use MEM_IsValidHandle().
- *! 07-Sep-2000 jeh     Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -49,10 +26,8 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/sync.h>
@@ -64,188 +39,183 @@
 #define NTFY_SIGNATURE      0x5946544e	/* "YFTN" */
 
 /*
- *  ======== NTFY_OBJECT ========
+ *  ======== ntfy_object ========
  */
-struct NTFY_OBJECT {
-	u32 dwSignature;	/* For object validation */
-	struct LST_LIST *notifyList;	/* List of NOTIFICATION objects */
-	struct SYNC_CSOBJECT *hSync;	/* For critical sections */
+struct ntfy_object {
+	u32 dw_signature;	/* For object validation */
+	struct lst_list *notify_list;	/* List of notifier objects */
+	struct sync_csobject *sync_obj;	/* For critical sections */
 };
 
 /*
- *  ======== NOTIFICATION ========
+ *  ======== notifier ========
  *  This object will be created when a client registers for events.
  */
-struct NOTIFICATION {
-	struct LST_ELEM listElem;
-	u32 uEventMask;	/* Events to be notified about */
-	u32 uNotifyType;	/* Type of notification to be sent */
+struct notifier {
+	struct list_head list_elem;
+	u32 event_mask;		/* Events to be notified about */
+	u32 notify_type;	/* Type of notification to be sent */
 
 	/*
 	 *  We keep a copy of the event name to check if the event has
 	 *  already been registered. (SYNC also keeps a copy of the name).
 	 */
-	char *pstrName;		/* Name of event */
-	HANDLE hEvent;		/* Handle for notification */
-	struct SYNC_OBJECT *hSync;
+	char *pstr_name;	/* Name of event */
+	bhandle event_obj;	/* Handle for notification */
+	struct sync_object *sync_obj;
 };
 
-/*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask NTFY_debugMask = { NULL, NULL };  /* GT trace variable */
-#endif
-
 /*  ----------------------------------- Function Prototypes */
-static void DeleteNotify(struct NOTIFICATION *pNotify);
+static void delete_notify(struct notifier *notifier_obj);
 
 /*
- *  ======== NTFY_Create ========
+ *  ======== ntfy_create ========
  *  Purpose:
  *      Create an empty list of notifications.
  */
-DSP_STATUS NTFY_Create(struct NTFY_OBJECT **phNtfy)
+dsp_status ntfy_create(struct ntfy_object **phNtfy)
 {
-	struct NTFY_OBJECT *pNtfy;
-	DSP_STATUS status = DSP_SOK;
+	struct ntfy_object *notify_obj;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(phNtfy != NULL);
+	DBC_REQUIRE(phNtfy != NULL);
 
 	*phNtfy = NULL;
-	MEM_AllocObject(pNtfy, struct NTFY_OBJECT, NTFY_SIGNATURE);
+	MEM_ALLOC_OBJECT(notify_obj, struct ntfy_object, NTFY_SIGNATURE);
 
-	if (pNtfy) {
+	if (notify_obj) {
 
-		status = SYNC_InitializeDPCCS(&pNtfy->hSync);
+		status = sync_initialize_dpccs(&notify_obj->sync_obj);
 		if (DSP_SUCCEEDED(status)) {
-			pNtfy->notifyList = LST_Create();
-			if (pNtfy->notifyList == NULL) {
-				(void) SYNC_DeleteCS(pNtfy->hSync);
-				MEM_FreeObject(pNtfy);
+			notify_obj->notify_list =
+			    mem_calloc(sizeof(struct lst_list), MEM_NONPAGED);
+			if (notify_obj->notify_list == NULL) {
+				(void)sync_delete_cs(notify_obj->sync_obj);
+				MEM_FREE_OBJECT(notify_obj);
 				status = DSP_EMEMORY;
 			} else {
-				*phNtfy = pNtfy;
+				INIT_LIST_HEAD(&notify_obj->notify_list->head);
+				*phNtfy = notify_obj;
 			}
 		}
 	} else {
 		status = DSP_EMEMORY;
 	}
 
-	DBC_Ensure((DSP_FAILED(status) && *phNtfy == NULL) ||
-		  (DSP_SUCCEEDED(status) && MEM_IsValidHandle((*phNtfy),
-		  NTFY_SIGNATURE)));
+	DBC_ENSURE((DSP_FAILED(status) && *phNtfy == NULL) ||
+		   (DSP_SUCCEEDED(status) && MEM_IS_VALID_HANDLE((*phNtfy),
+							 NTFY_SIGNATURE)));
 
 	return status;
 }
 
 /*
- *  ======== NTFY_Delete ========
+ *  ======== ntfy_delete ========
  *  Purpose:
- *      Free resources allocated in NTFY_Create.
+ *      Free resources allocated in ntfy_create.
  */
-void NTFY_Delete(struct NTFY_OBJECT *hNtfy)
+void ntfy_delete(struct ntfy_object *ntfy_obj)
 {
-	struct NOTIFICATION *pNotify;
+	struct notifier *notifier_obj;
 
-	DBC_Require(MEM_IsValidHandle(hNtfy, NTFY_SIGNATURE));
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(ntfy_obj, NTFY_SIGNATURE));
 
 	/* Remove any elements remaining in list */
-	if (hNtfy->notifyList) {
-		while ((pNotify = (struct NOTIFICATION *)LST_GetHead(hNtfy->
-								notifyList))) {
-			DeleteNotify(pNotify);
+	if (ntfy_obj->notify_list) {
+		while ((notifier_obj =
+		      (struct notifier *)lst_get_head(ntfy_obj->notify_list))) {
+			delete_notify(notifier_obj);
 		}
-		DBC_Assert(LST_IsEmpty(hNtfy->notifyList));
-		LST_Delete(hNtfy->notifyList);
+		DBC_ASSERT(LST_IS_EMPTY(ntfy_obj->notify_list));
+		kfree(ntfy_obj->notify_list);
 	}
-	if (hNtfy->hSync)
-		(void)SYNC_DeleteCS(hNtfy->hSync);
+	if (ntfy_obj->sync_obj)
+		(void)sync_delete_cs(ntfy_obj->sync_obj);
 
-	MEM_FreeObject(hNtfy);
+	MEM_FREE_OBJECT(ntfy_obj);
 }
 
 /*
- *  ======== NTFY_Exit ========
+ *  ======== ntfy_exit ========
  *  Purpose:
  *      Discontinue usage of NTFY module.
  */
-void NTFY_Exit(void)
+void ntfy_exit(void)
 {
-	GT_0trace(NTFY_debugMask, GT_5CLASS, "Entered NTFY_Exit\n");
+	/* Do nothing */
 }
 
 /*
- *  ======== NTFY_Init ========
+ *  ======== ntfy_init ========
  *  Purpose:
  *      Initialize the NTFY module.
  */
-bool NTFY_Init(void)
+bool ntfy_init(void)
 {
-	GT_create(&NTFY_debugMask, "NY");	/* "NY" for NtfY */
-
-	GT_0trace(NTFY_debugMask, GT_5CLASS, "NTFY_Init()\n");
-
 	return true;
 }
 
 /*
- *  ======== NTFY_Notify ========
+ *  ======== ntfy_notify ========
  *  Purpose:
  *      Execute notify function (signal event) for every
  *      element in the notification list that is to be notified about the
- *      event specified in uEventMask.
+ *      event specified in event_mask.
  */
-void NTFY_Notify(struct NTFY_OBJECT *hNtfy, u32 uEventMask)
+void ntfy_notify(struct ntfy_object *ntfy_obj, u32 event_mask)
 {
-	struct NOTIFICATION *pNotify;
+	struct notifier *notifier_obj;
 
-	DBC_Require(MEM_IsValidHandle(hNtfy, NTFY_SIGNATURE));
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(ntfy_obj, NTFY_SIGNATURE));
 
 	/*
-	 *  Go through notifyList and notify all clients registered for
-	 *  uEventMask events.
+	 *  Go through notify_list and notify all clients registered for
+	 *  event_mask events.
 	 */
 
-	(void) SYNC_EnterCS(hNtfy->hSync);
+	(void)sync_enter_cs(ntfy_obj->sync_obj);
 
-	pNotify = (struct NOTIFICATION *)LST_First(hNtfy->notifyList);
-	while (pNotify != NULL) {
-		if (pNotify->uEventMask & uEventMask) {
+	notifier_obj = (struct notifier *)lst_first(ntfy_obj->notify_list);
+	while (notifier_obj != NULL) {
+		if (notifier_obj->event_mask & event_mask) {
 			/* Notify */
-			if (pNotify->uNotifyType == DSP_SIGNALEVENT)
-				(void)SYNC_SetEvent(pNotify->hSync);
+			if (notifier_obj->notify_type == DSP_SIGNALEVENT)
+				(void)sync_set_event(notifier_obj->sync_obj);
 
 		}
-		pNotify = (struct NOTIFICATION *)LST_Next(hNtfy->notifyList,
-			  (struct LST_ELEM *)pNotify);
+		notifier_obj =
+		    (struct notifier *)lst_next(ntfy_obj->notify_list,
+						(struct list_head *)
+						notifier_obj);
 	}
 
-	(void) SYNC_LeaveCS(hNtfy->hSync);
+	(void)sync_leave_cs(ntfy_obj->sync_obj);
 }
 
 /*
- *  ======== NTFY_Register ========
+ *  ======== ntfy_register ========
  *  Purpose:
  *      Add a notification element to the list. If the notification is already
- *      registered, and uEventMask != 0, the notification will get posted for
+ *      registered, and event_mask != 0, the notification will get posted for
  *      events specified in the new event mask. If the notification is already
- *      registered and uEventMask == 0, the notification will be unregistered.
+ *      registered and event_mask == 0, the notification will be unregistered.
  */
-DSP_STATUS NTFY_Register(struct NTFY_OBJECT *hNtfy,
-			 struct DSP_NOTIFICATION *hNotification,
-			 u32 uEventMask, u32 uNotifyType)
+dsp_status ntfy_register(struct ntfy_object *ntfy_obj,
+			 struct dsp_notification *hnotification,
+			 u32 event_mask, u32 notify_type)
 {
-	struct NOTIFICATION *pNotify;
-	struct SYNC_ATTRS syncAttrs;
-	DSP_STATUS status = DSP_SOK;
+	struct notifier *notifier_obj;
+	struct sync_attrs sync_attrs_obj;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(MEM_IsValidHandle(hNtfy, NTFY_SIGNATURE));
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(ntfy_obj, NTFY_SIGNATURE));
 
-	if (hNotification == NULL)
+	if (hnotification == NULL)
 		status = DSP_EHANDLE;
 
-	/* Return DSP_ENOTIMPL if uNotifyType is not supported */
+	/* Return DSP_ENOTIMPL if notify_type is not supported */
 	if (DSP_SUCCEEDED(status)) {
-		if (!IsValidNotifyMask(uNotifyType))
+		if (!IS_VALID_NOTIFY_MASK(notify_type))
 			status = DSP_ENOTIMPL;
 
 	}
@@ -253,77 +223,79 @@
 	if (DSP_FAILED(status))
 		return status;
 
-	(void)SYNC_EnterCS(hNtfy->hSync);
+	(void)sync_enter_cs(ntfy_obj->sync_obj);
 
-	pNotify = (struct NOTIFICATION *)LST_First(hNtfy->notifyList);
-	while (pNotify != NULL) {
+	notifier_obj = (struct notifier *)lst_first(ntfy_obj->notify_list);
+	while (notifier_obj != NULL) {
 		/* If there is more than one notification type, each
-		 * type may require its own handler code.  */
+		 * type may require its own handler code. */
 
-		if (hNotification->handle == pNotify->hSync) {
+		if (hnotification->handle == notifier_obj->sync_obj) {
 			/* found */
 			break;
 		}
-		pNotify = (struct NOTIFICATION *)LST_Next(hNtfy->notifyList,
-			  (struct LST_ELEM *)pNotify);
+		notifier_obj =
+		    (struct notifier *)lst_next(ntfy_obj->notify_list,
+						(struct list_head *)
+						notifier_obj);
 	}
-	if (pNotify == NULL) {
+	if (notifier_obj == NULL) {
 		/* Not registered */
-		if (uEventMask == 0) {
+		if (event_mask == 0) {
 			status = DSP_EVALUE;
 		} else {
-			/* Allocate NOTIFICATION object, add to list */
-			pNotify = MEM_Calloc(sizeof(struct NOTIFICATION),
-					     MEM_PAGED);
-			if (pNotify == NULL)
+			/* Allocate notifier object, add to list */
+			notifier_obj = mem_calloc(sizeof(struct notifier),
+						  MEM_PAGED);
+			if (notifier_obj == NULL)
 				status = DSP_EMEMORY;
 
 		}
 		if (DSP_SUCCEEDED(status)) {
-			LST_InitElem((struct LST_ELEM *) pNotify);
-			 /* If there is more than one notification type, each
+			lst_init_elem((struct list_head *)notifier_obj);
+			/* If there is more than one notification type, each
 			 * type may require its own handler code. */
-			status = SYNC_OpenEvent(&pNotify->hSync, &syncAttrs);
-			hNotification->handle = pNotify->hSync;
+			status =
+			    sync_open_event(&notifier_obj->sync_obj,
+					    &sync_attrs_obj);
+			hnotification->handle = notifier_obj->sync_obj;
 
 			if (DSP_SUCCEEDED(status)) {
-				pNotify->uEventMask = uEventMask;
-				pNotify->uNotifyType = uNotifyType;
-				LST_PutTail(hNtfy->notifyList,
-					   (struct LST_ELEM *)pNotify);
+				notifier_obj->event_mask = event_mask;
+				notifier_obj->notify_type = notify_type;
+				lst_put_tail(ntfy_obj->notify_list,
+					     (struct list_head *)notifier_obj);
 			} else {
-				DeleteNotify(pNotify);
+				delete_notify(notifier_obj);
 			}
 		}
 	} else {
 		/* Found in list */
-		if (uEventMask == 0) {
+		if (event_mask == 0) {
 			/* Remove from list and free */
-			LST_RemoveElem(hNtfy->notifyList,
-				      (struct LST_ELEM *)pNotify);
-			DeleteNotify(pNotify);
+			lst_remove_elem(ntfy_obj->notify_list,
+					(struct list_head *)notifier_obj);
+			delete_notify(notifier_obj);
 		} else {
 			/* Update notification mask (type shouldn't change) */
-			pNotify->uEventMask = uEventMask;
+			notifier_obj->event_mask = event_mask;
 		}
 	}
-	(void)SYNC_LeaveCS(hNtfy->hSync);
+	(void)sync_leave_cs(ntfy_obj->sync_obj);
 	return status;
 }
 
 /*
- *  ======== DeleteNotify ========
+ *  ======== delete_notify ========
  *  Purpose:
  *      Free the notification object.
  */
-static void DeleteNotify(struct NOTIFICATION *pNotify)
+static void delete_notify(struct notifier *notifier_obj)
 {
-	if (pNotify->hSync)
-		(void) SYNC_CloseEvent(pNotify->hSync);
+	if (notifier_obj->sync_obj)
+		(void)sync_close_event(notifier_obj->sync_obj);
 
-	if (pNotify->pstrName)
-		MEM_Free(pNotify->pstrName);
+	kfree(notifier_obj->pstr_name);
 
-	MEM_Free(pNotify);
+	kfree(notifier_obj);
 }
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/services/reg.c kernel-power-2.6.28.new/drivers/dsp/bridge/services/reg.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/services/reg.c	2011-10-11 13:51:01.950311149 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/services/reg.c	2011-10-23 08:22:37.677315000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provide registry functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,25 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== regce.c ========
- *  Purpose:
- *      Provide registry functions.
- *
- *  Public Functions:
- *      REG_DeleteValue
- *      REG_EnumValue
- *      REG_Exit
- *      REG_GetValue
- *      REG_Init
- *      REG_SetValue
- *
- *! Revision History:
- *! ================
- *
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -43,107 +26,78 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/mem.h>
 
-/*  ----------------------------------- Others */
-#include <dspbridge/dbreg.h>
-
 /*  ----------------------------------- This */
 #include <dspbridge/reg.h>
 #include <regsup.h>
 
-#if GT_TRACE
-struct GT_Mask REG_debugMask = { NULL, NULL };	/* GT trace var. */
-#endif
-
 /*
- *  ======== REG_DeleteValue ========
+ *  ======== reg_delete_value ========
  *  Deletes a registry entry value.  NOTE:  A registry entry value is not the
  *  same as *  a registry key.
  */
-DSP_STATUS REG_DeleteValue(OPTIONAL IN HANDLE *phKey, IN CONST char *pstrSubkey,
-			   IN CONST char *pstrValue)
+dsp_status reg_delete_value(IN CONST char *pstrValue)
 {
-	DSP_STATUS status;
-	DBC_Require(pstrSubkey && pstrValue);
-	DBC_Require(phKey == NULL);
-       DBC_Require(strlen(pstrSubkey) < REG_MAXREGPATHLENGTH);
-       DBC_Require(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
+	dsp_status status;
+	DBC_REQUIRE(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
 
-	GT_0trace(REG_debugMask, GT_ENTER, "REG_DeleteValue: entered\n");
-
-	/*  Note that we don't use phKey */
-	if (regsupDeleteValue(pstrSubkey, pstrValue) == DSP_SOK)
-		status = DSP_SOK;
-	else
-		status = DSP_EFAIL;
+	status = regsup_delete_value(pstrValue);
 
 	return status;
 }
 
 /*
- *  ======== REG_EnumValue ========
+ *  ======== reg_enum_value ========
  *  Enumerates a registry key and retrieve values stored under the key.
  *  We will assume the input pdwValueSize is smaller than
  *  REG_MAXREGPATHLENGTH for implementation purposes.
  */
-DSP_STATUS REG_EnumValue(IN HANDLE *phKey, IN u32 dwIndex,
-			 IN CONST char *pstrKey, IN OUT char *pstrValue,
-			 IN OUT u32 *pdwValueSize, IN OUT char *pstrData,
-			 IN OUT u32 *pdwDataSize)
+dsp_status reg_enum_value(IN u32 dw_index,
+			  IN CONST char *pstrKey, IN OUT char *pstrValue,
+			  IN OUT u32 *pdwValueSize, IN OUT char *pstrData,
+			  IN OUT u32 *pdwDataSize)
 {
-	DSP_STATUS status;
+	dsp_status status;
 
-	DBC_Require(pstrKey && pstrValue && pdwValueSize && pstrData &&
+	DBC_REQUIRE(pstrKey && pstrValue && pdwValueSize && pstrData &&
 		    pdwDataSize);
-	DBC_Require(*pdwValueSize <= REG_MAXREGPATHLENGTH);
-	DBC_Require(phKey == NULL);
-       DBC_Require(strlen(pstrKey) < REG_MAXREGPATHLENGTH);
+	DBC_REQUIRE(*pdwValueSize <= REG_MAXREGPATHLENGTH);
+	DBC_REQUIRE(strlen(pstrKey) < REG_MAXREGPATHLENGTH);
 
-	GT_0trace(REG_debugMask, GT_ENTER, "REG_EnumValue: entered\n");
-
-	status = regsupEnumValue(dwIndex, pstrKey, pstrValue, pdwValueSize,
-				 pstrData, pdwDataSize);
+	status = regsup_enum_value(dw_index, pstrKey, pstrValue, pdwValueSize,
+				   pstrData, pdwDataSize);
 
 	return status;
 }
 
 /*
- *  ======== REG_Exit ========
+ *  ======== reg_exit ========
  *  Discontinue usage of the REG module.
  */
-void REG_Exit(void)
+void reg_exit(void)
 {
-	GT_0trace(REG_debugMask, GT_5CLASS, "REG_Exit\n");
-
-	regsupExit();
+	regsup_exit();
 }
 
 /*
- *  ======== REG_GetValue ========
+ *  ======== reg_get_value ========
  *  Retrieve a value from the registry.
  */
-DSP_STATUS REG_GetValue(OPTIONAL IN HANDLE *phKey, IN CONST char *pstrSubkey,
-			IN CONST char *pstrValue, OUT u8 *pbData,
-			IN OUT u32 *pdwDataSize)
-{
-	DSP_STATUS status;
-
-	DBC_Require(pstrSubkey && pstrValue && pbData);
-	DBC_Require(phKey == NULL);
-       DBC_Require(strlen(pstrSubkey) < REG_MAXREGPATHLENGTH);
-       DBC_Require(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
-
-	GT_0trace(REG_debugMask, GT_ENTER, "REG_GetValue: entered\n");
-
-	/*  We need to use regsup calls...  */
-	/*  ...for now we don't need the key handle or  */
-	/*  the subkey, all we need is the value to lookup.  */
-	if (regsupGetValue((char *)pstrValue, pbData, pdwDataSize) == DSP_SOK)
+dsp_status reg_get_value(IN CONST char *pstrValue, OUT u8 * pbData,
+			 IN OUT u32 *pdwDataSize)
+{
+	dsp_status status;
+
+	DBC_REQUIRE(pstrValue && pbData);
+	DBC_REQUIRE(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
+
+	/*  We need to use regsup calls... */
+	/*  ...for now we don't need the key handle or */
+	/*  the subkey, all we need is the value to lookup. */
+	if (regsup_get_value((char *)pstrValue, pbData, pdwDataSize) == DSP_SOK)
 		status = DSP_SOK;
 	else
 		status = DSP_EFAIL;
@@ -152,45 +106,37 @@
 }
 
 /*
- *  ======== REG_Init ========
+ *  ======== reg_init ========
  *  Initialize the REG module's private state.
  */
-bool REG_Init(void)
+bool reg_init(void)
 {
-	bool fInit;
-
-	GT_create(&REG_debugMask, "RG");	/* RG for ReG */
+	bool ret;
 
-	fInit = regsupInit();
+	ret = regsup_init();
 
-	GT_0trace(REG_debugMask, GT_5CLASS, "REG_Init\n");
-
-	return fInit;
+	return ret;
 }
 
 /*
- *  ======== REG_SetValue ========
+ *  ======== reg_set_value ========
  *  Set a value in the registry.
  */
-DSP_STATUS REG_SetValue(OPTIONAL IN HANDLE *phKey, IN CONST char *pstrSubkey,
-			IN CONST char *pstrValue, IN CONST u32 dwType,
-			IN u8 *pbData, IN u32 dwDataSize)
-{
-	DSP_STATUS status;
-
-	DBC_Require(pstrValue && pbData);
-	DBC_Require(phKey == NULL);
-	DBC_Require(dwDataSize > 0);
-       DBC_Require(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
-
-	/*  We need to use regsup calls...  */
-	/*  ...for now we don't need the key handle or  */
-	/*  the subkey, all we need is the value to lookup.  */
-	if (regsupSetValue((char *)pstrValue, pbData, dwDataSize) == DSP_SOK)
-		status = DSP_SOK;
-	else
-		status = DSP_EFAIL;
+dsp_status reg_set_value(IN CONST char *pstrValue, IN u8 * pbData,
+			 IN u32 dw_data_size)
+{
+	dsp_status status;
+
+	DBC_REQUIRE(pstrValue && pbData);
+	DBC_REQUIRE(dw_data_size > 0);
+	DBC_REQUIRE(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
+
+	/*
+	 * We need to use regsup calls
+	 * for now we don't need the key handle or
+	 * the subkey, all we need is the value to lookup.
+	 */
+	status = regsup_set_value((char *)pstrValue, pbData, dw_data_size);
 
 	return status;
 }
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/services/regsup.c kernel-power-2.6.28.new/drivers/dsp/bridge/services/regsup.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/services/regsup.c	2011-10-11 13:51:01.979530505 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/services/regsup.c	2011-10-23 08:22:37.677315000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provide registry support functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,20 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== regsup.c ========
- *  Purpose:
- *      Provide registry support functions.
- *
- *! Revision History:
- *! ================
- *! 28-May-2002  map: Integrated PSI's dspimage update mechanism
- *! 11-May-2002  gp:  Turned PERF "on".
- *! 21-May-2002  map: Fixed bug in SetValue - if resizing datasize, set
- *!		      new size too
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -35,336 +23,223 @@
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
 #include <dspbridge/errbase.h>
-#include <dspbridge/dbreg.h>
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/mem.h>
-#include <dspbridge/csl.h>
+#include <dspbridge/list.h>
 
 /*  ----------------------------------- This */
 #include <regsup.h>
 
-struct RegValueStruct {
-	char name[BRIDGE_MAX_NAME_SIZE];   /*  Name of a given value entry  */
-	u32 dataSize;		/*  Size of the data  */
-	void *pData;		/*  Pointer to the actual data  */
+struct reg_value {
+	struct list_head link;	/* Make it linked to a list */
+	char name[MAXREGPATHLENGTH];	/*  Name of a given value entry */
+	u32 data_size;		/*  Size of the data */
+	void *pdata;		/*  Pointer to the actual data */
 };
 
-struct RegKeyStruct {
-	/*The current number of value entries this key has*/
-	u32 numValueEntries;
-	/* Array of value entries */
-	struct RegValueStruct values[BRIDGE_MAX_NUM_REG_ENTRIES];
-};
-
-
-/*  Pointer to the registry support key  */
-static struct RegKeyStruct *pRegKey;
+/*  Pointer to the registry support key */
+static struct lst_list reg_key, *reg_key_list = &reg_key;
 
-#if GT_TRACE
-extern struct GT_Mask REG_debugMask;	/* GT trace var. */
 /*
- *  ======== printS ========
- *  Purpose:
- *      Displays printable characters in pBuf, if any.
- */
-static inline void printS(void *pBuf)
-{
-	int pos = 0;
-	if (*(REG_debugMask).flags & (GT_2CLASS)) {
-		while (*(u8 *)((pBuf)+pos) >= ' ' &&
-		       *(u8 *)((pBuf)+pos) <= '~') {
-			GT_1trace(REG_debugMask, GT_2CLASS, "%c",
-					*(u8 *)((pBuf) + pos++));
-		}
-
-		GT_0trace(REG_debugMask, GT_2CLASS, "\n");
-	}
-}
-#else
-#define printS(pBuf)
-#endif
-
-/*
- *  ======== regsupInit ========
+ *  ======== regsup_init ========
  *  Purpose:
  *      Initialize the Registry Support module's private state.
  */
-bool regsupInit(void)
+bool regsup_init(void)
 {
-	if (pRegKey != NULL)
-		return true;
-
-	/*  Need to allocate and setup our registry.  */
-	pRegKey = MEM_Calloc(sizeof(struct RegKeyStruct), MEM_NONPAGED);
-	if (pRegKey == NULL)
-		return false;
-
+	INIT_LIST_HEAD(&reg_key_list->head);
 	return true;
 }
 
 /*
- *  ======== regsupExit ========
+ *  ======== regsup_exit ========
  *  Purpose:
  *      Release all registry support allocations.
  */
-void regsupExit(void)
+void regsup_exit(void)
 {
-	u32 i;
-
-	/*  Make sure data has actually been allocated.  */
-	if (pRegKey == NULL) {
-		/*  Nothing initialized.return!  */
-		return;
-	}
+	struct reg_value *rv;
+	/*  Now go through each entry and free all resources. */
+	while (!LST_IS_EMPTY(reg_key_list)) {
+		rv = (struct reg_value *)lst_get_head(reg_key_list);
 
-	GT_1trace(REG_debugMask, GT_2CLASS, "pRegKey->numValueEntries %d\n",
-		  pRegKey->numValueEntries);
-
-	/*  Now go through each entry and free all resources.  */
-	for (i = 0; ((i < BRIDGE_MAX_NUM_REG_ENTRIES) &&
-	    (i < pRegKey->numValueEntries)); i++) {
-		if (pRegKey->values[i].name[0] != '\0') {
-			/*  We have a valid entry.free it up!  */
-			if (pRegKey->values[i].pData != NULL) {
-				GT_3trace(REG_debugMask, GT_2CLASS,
-					  "E %d\t %s DATA %x ", i,
-					  pRegKey->values[i].name,
-					  *(u32 *)pRegKey->values[i].pData);
-				printS((u8 *)(pRegKey->values[i].pData));
-				MEM_Free(pRegKey->values[i].pData);
-			}
-			pRegKey->values[i].pData = NULL;
-			pRegKey->values[i].dataSize = 0;
-			pRegKey->values[i].name[0] = '\0';
-		}
+		kfree(rv->pdata);
+		kfree(rv);
 	}
-
-	/*  Now that all of the resources are freed up, free the main one!  */
-	MEM_Free(pRegKey);
-
-	/*  Don't forget to NULL out the global entry!  */
-	pRegKey = NULL;
 }
 
 /*
- *  ======== regsupGetValue ========
+ *  ======== regsup_get_value ========
  *  Purpose:
  *      Get the value of the entry having the given name.
  */
-DSP_STATUS regsupGetValue(char *valName, void *pBuf, u32 *dataSize)
+dsp_status regsup_get_value(char *valName, void *pbuf, u32 * data_size)
 {
-	DSP_STATUS retVal = DSP_EFAIL;
-	u32 i;
+	dsp_status ret = DSP_EFAIL;
+	struct reg_value *rv = (struct reg_value *)lst_first(reg_key_list);
 
-	/*  Need to search through the entries looking for the right one.  */
-	for (i = 0; i < pRegKey->numValueEntries; i++) {
-		/*  See if the name matches.  */
-               if (strncmp(pRegKey->values[i].name, valName,
-		    BRIDGE_MAX_NAME_SIZE) == 0) {
-
-			/*  We have a match!  Copy out the data.  */
-			memcpy(pBuf, pRegKey->values[i].pData,
-			       pRegKey->values[i].dataSize);
+	/*  Need to search through the entries looking for the right one. */
+	while (rv) {
+		/*  See if the name matches. */
+		if (strncmp(rv->name, valName, MAXREGPATHLENGTH) == 0) {
+			/*  We have a match!  Copy out the data. */
+			memcpy(pbuf, rv->pdata, rv->data_size);
 
-			/*  Get the size for the caller.  */
-			*dataSize = pRegKey->values[i].dataSize;
+			/*  Get the size for the caller. */
+			*data_size = rv->data_size;
 
-			/*  Set our status to good and exit.  */
-			retVal = DSP_SOK;
+			/*  Set our status to good and exit. */
+			ret = DSP_SOK;
 			break;
 		}
+		rv = (struct reg_value *)lst_next(reg_key_list,
+						  (struct list_head *)rv);
 	}
 
-	if (DSP_SUCCEEDED(retVal)) {
-		GT_2trace(REG_debugMask, GT_2CLASS, "G %s DATA %x ", valName,
-			  *(u32 *)pBuf);
-		printS((u8 *)pBuf);
-	} else {
-		GT_1trace(REG_debugMask, GT_3CLASS, "G %s FAILED\n", valName);
-	}
+	dev_dbg(bridge, "REG: get %s, status = 0x%x\n", valName, ret);
 
-	return retVal;
+	return ret;
 }
 
 /*
- *  ======== regsupSetValue ========
+ *  ======== regsup_set_value ========
  *  Purpose:
  *      Sets the value of the entry having the given name.
  */
-DSP_STATUS regsupSetValue(char *valName, void *pBuf, u32 dataSize)
+dsp_status regsup_set_value(char *valName, void *pbuf, u32 data_size)
 {
-	DSP_STATUS retVal = DSP_EFAIL;
-	u32 i;
+	dsp_status ret = DSP_EFAIL;
+	struct reg_value *rv = (struct reg_value *)lst_first(reg_key_list);
 
-	GT_2trace(REG_debugMask, GT_2CLASS, "S %s DATA %x ", valName,
-		  *(u32 *)pBuf);
-	printS((u8 *)pBuf);
-
-	/*  Need to search through the entries looking for the right one.  */
-	for (i = 0; i < pRegKey->numValueEntries; i++) {
-		/*  See if the name matches.  */
-               if (strncmp(pRegKey->values[i].name, valName,
-		    BRIDGE_MAX_NAME_SIZE) == 0) {
-			/*  Make sure the new data size is the same.  */
-			if (dataSize != pRegKey->values[i].dataSize) {
-				/*  The caller needs a different data size!  */
-				MEM_Free(pRegKey->values[i].pData);
-				pRegKey->values[i].pData = MEM_Alloc(dataSize,
-							   MEM_NONPAGED);
-				if (pRegKey->values[i].pData == NULL)
+	/*  Need to search through the entries looking for the right one. */
+	while (rv) {
+		/*  See if the name matches. */
+		if (strncmp(rv->name, valName, MAXREGPATHLENGTH) == 0) {
+			/*  Make sure the new data size is the same. */
+			if (data_size != rv->data_size) {
+				/*  The caller needs a different data size! */
+				kfree(rv->pdata);
+				rv->pdata = mem_alloc(data_size, MEM_NONPAGED);
+				if (rv->pdata == NULL)
 					break;
-
 			}
 
-			/*  We have a match!  Copy out the data.  */
-			memcpy(pRegKey->values[i].pData, pBuf, dataSize);
+			/*  We have a match!  Copy out the data. */
+			memcpy(rv->pdata, pbuf, data_size);
 
 			/* Reset datasize - overwrite if new or same */
-			pRegKey->values[i].dataSize = dataSize;
+			rv->data_size = data_size;
 
-			/*  Set our status to good and exit.  */
-			retVal = DSP_SOK;
+			/*  Set our status to good and exit. */
+			ret = DSP_SOK;
 			break;
 		}
+		rv = (struct reg_value *)lst_next(reg_key_list,
+						  (struct list_head *)rv);
 	}
 
-	/*  See if we found a match or if this is a new entry  */
-	if (i == pRegKey->numValueEntries) {
-		/*  No match, need to make a new entry  */
-		/*  First check to see if we can make any more entries.  */
-		if (pRegKey->numValueEntries < BRIDGE_MAX_NUM_REG_ENTRIES) {
-			char *tmp_name =
-				pRegKey->values[pRegKey->numValueEntries].name;
-			strncpy(tmp_name, valName, BRIDGE_MAX_NAME_SIZE - 1);
-			tmp_name[BRIDGE_MAX_NAME_SIZE - 1] = '\0';
-			pRegKey->values[pRegKey->numValueEntries].pData =
-					MEM_Alloc(dataSize, MEM_NONPAGED);
-			if (pRegKey->values[pRegKey->numValueEntries].pData !=
-									NULL) {
-				memcpy(pRegKey->
-					values[pRegKey->numValueEntries].pData,
-					pBuf, dataSize);
-				pRegKey->
-				    values[pRegKey->numValueEntries].dataSize =
-				    dataSize;
-				pRegKey->numValueEntries++;
-				retVal = DSP_SOK;
-			}
-		} else {
-			GT_0trace(REG_debugMask, GT_7CLASS,
-				  "MAX NUM REG ENTRIES REACHED\n");
+	/*  See if we found a match or if this is a new entry */
+	if (!rv) {
+		/*  No match, need to make a new entry */
+		struct reg_value *new = mem_calloc(sizeof(struct reg_value),
+						   MEM_NONPAGED);
+
+		strncat(new->name, valName, MAXREGPATHLENGTH - 1);
+		new->pdata = mem_alloc(data_size, MEM_NONPAGED);
+		if (new->pdata != NULL) {
+			memcpy(new->pdata, pbuf, data_size);
+			new->data_size = data_size;
+			lst_put_tail(reg_key_list, (struct list_head *)new);
+			ret = DSP_SOK;
 		}
 	}
 
-	return retVal;
+	dev_dbg(bridge, "REG: set %s, status = 0x%x", valName, ret);
+
+	return ret;
 }
 
 /*
- *  ======== regsupEnumValue ========
+ *  ======== regsup_enum_value ========
  *  Purpose:
  *      Returns registry "values" and their "data" under a (sub)key.
  */
-DSP_STATUS regsupEnumValue(IN u32 dwIndex, IN CONST char *pstrKey,
-			   IN OUT char *pstrValue, IN OUT u32 *pdwValueSize,
-			   IN OUT char *pstrData, IN OUT u32 *pdwDataSize)
-{
-	DSP_STATUS retVal = REG_E_INVALIDSUBKEY;
-	u32 i;
-       u32 dwKeyLen;
+dsp_status regsup_enum_value(IN u32 dw_index, IN CONST char *pstrKey,
+			     IN OUT char *pstrValue, IN OUT u32 * pdwValueSize,
+			     IN OUT char *pstrData, IN OUT u32 * pdwDataSize)
+{
+	dsp_status ret = REG_E_INVALIDSUBKEY;
+	struct reg_value *rv = (struct reg_value *)lst_first(reg_key_list);
+	u32 dw_key_len;
 	u32 count = 0;
 
-       DBC_Require(pstrKey);
-       dwKeyLen = strlen(pstrKey);
+	DBC_REQUIRE(pstrKey);
+	dw_key_len = strlen(pstrKey);
 
-	/*  Need to search through the entries looking for the right one.  */
-	for (i = 0; i < pRegKey->numValueEntries; i++) {
-		/*  See if the name matches.  */
-               if ((strncmp(pRegKey->values[i].name, pstrKey,
-		    dwKeyLen) == 0) && count++ == dwIndex) {
-			/*  We have a match!  Copy out the data.  */
-			memcpy(pstrData, pRegKey->values[i].pData,
-				pRegKey->values[i].dataSize);
-			/*  Get the size for the caller.  */
-			*pdwDataSize = pRegKey->values[i].dataSize;
-                       *pdwValueSize = strlen(&(pRegKey->
-						values[i].name[dwKeyLen]));
-                       strncpy(pstrValue,
-				    &(pRegKey->values[i].name[dwKeyLen]),
-				    *pdwValueSize + 1);
-			GT_3trace(REG_debugMask, GT_2CLASS,
-				  "E Key %s, Value %s, Data %x ",
-				  pstrKey, pstrValue, *(u32 *)pstrData);
-			printS((u8 *)pstrData);
-			/*  Set our status to good and exit.  */
-			retVal = DSP_SOK;
+	/*  Need to search through the entries looking for the right one. */
+	while (rv) {
+		/*  See if the name matches. */
+		if (strncmp(rv->name, pstrKey, dw_key_len) == 0 &&
+		    count++ == dw_index) {
+			/*  We have a match!  Copy out the data. */
+			memcpy(pstrData, rv->pdata, rv->data_size);
+			/*  Get the size for the caller. */
+			*pdwDataSize = rv->data_size;
+			*pdwValueSize = strlen(&(rv->name[dw_key_len]));
+			strncpy(pstrValue, &(rv->name[dw_key_len]),
+				*pdwValueSize + 1);
+			/*  Set our status to good and exit. */
+			ret = DSP_SOK;
 			break;
 		}
+		rv = (struct reg_value *)lst_next(reg_key_list,
+						  (struct list_head *)rv);
 	}
 
-	if (count && DSP_FAILED(retVal))
-		retVal = REG_E_NOMOREITEMS;
+	if (count && DSP_FAILED(ret))
+		ret = REG_E_NOMOREITEMS;
+
+	dev_dbg(bridge, "REG: enum Key %s, Value %s, status = 0x%x",
+		pstrKey, pstrValue, ret);
 
-	return retVal;
+	return ret;
 }
 
 /*
- *  ======== regsupDeleteValue ========
+ *  ======== regsup_delete_value ========
  */
-DSP_STATUS regsupDeleteValue(IN CONST char *pstrSubkey,
-			    IN CONST char *pstrValue)
+dsp_status regsup_delete_value(IN CONST char *pstrValue)
 {
-	DSP_STATUS retVal = DSP_EFAIL;
-	u32 i;
+	dsp_status ret = DSP_EFAIL;
+	struct reg_value *rv = (struct reg_value *)lst_first(reg_key_list);
 
-	for (i = 0; ((i < BRIDGE_MAX_NUM_REG_ENTRIES) &&
-	    (i < pRegKey->numValueEntries)); i++) {
-		/*  See if the name matches...  */
-               if (strncmp(pRegKey->values[i].name, pstrValue,
-		    BRIDGE_MAX_NAME_SIZE) == 0) {
+	while (rv) {
+		/*  See if the name matches. */
+		if (strncmp(rv->name, pstrValue, MAXREGPATHLENGTH) == 0) {
 			/* We have a match!  Delete this key.  To delete a
 			 * key, we free all resources associated with this
 			 * key and, if we're not already the last entry in
 			 * the array, we copy that entry into this deleted
 			 * key.
 			 */
-			MEM_Free(pRegKey->values[i].pData);
-			if ((pRegKey->numValueEntries - 1) == i) {
-				/* we're deleting the last one */
-				pRegKey->values[i].name[0] = '\0';
-				pRegKey->values[i].dataSize = 0;
-				pRegKey->values[i].pData = NULL;
-			} else {
-				/* move the last one here */
-                               strncpy(pRegKey->values[i].name, pRegKey->
-				    values[pRegKey->numValueEntries - 1].name,
-				    BRIDGE_MAX_NAME_SIZE);
-				pRegKey->values[i].dataSize =
-				    pRegKey->
-				    values[pRegKey->numValueEntries-1].dataSize;
-				pRegKey->values[i].pData =
-				    pRegKey->
-				    values[pRegKey->numValueEntries-1].pData;
-				/* don't have to do this, but for
-				 * the paranoid... */
-				pRegKey->
-				    values[pRegKey->numValueEntries-1].name[0] =
-				    '\0';
-			}
-
-			/* another one bites the dust. */
-			pRegKey->numValueEntries--;
+			lst_remove_elem(reg_key_list, (struct list_head *)rv);
+			kfree(rv->pdata);
+			kfree(rv);
 
-			/*  Set our status to good and exit...  */
-			retVal = DSP_SOK;
+			/*  Set our status to good and exit... */
+			ret = DSP_SOK;
 			break;
 		}
+		rv = (struct reg_value *)lst_next(reg_key_list,
+						  (struct list_head *)rv);
 	}
-	return retVal;
 
-}
+	dev_dbg(bridge, "REG: del %s, status = 0x%x", pstrValue, ret);
 
+	return ret;
+
+}
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/services/regsup.h kernel-power-2.6.28.new/drivers/dsp/bridge/services/regsup.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/services/regsup.h	2011-10-11 13:51:02.004933770 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/services/regsup.h	2011-10-23 08:22:37.677315000 +0100
@@ -14,45 +14,35 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== regsup.h ========
- *
- *! Revision History
- *! ================
- */
-
 #ifndef _REGSUP_H_
 #define _REGSUP_H_
 
-#define BRIDGE_MAX_NAME_SIZE                     MAXREGPATHLENGTH
-#define BRIDGE_MAX_NUM_REG_ENTRIES               52
+/*  Init function. MUST be called BEFORE any calls are */
+/*  made into this psuedo-registry!!!  Returns TRUE/FALSE for SUCCESS/ERROR */
+extern bool regsup_init(void);
 
-/*  Init function. MUST be called BEFORE any calls are  */
-/*  made into this psuedo-registry!!!  Returns TRUE/FALSE for SUCCESS/ERROR  */
-extern bool regsupInit(void);
-
-/*  Release all registry support allocations.  */
-extern void regsupExit(void);
+/*  Release all registry support allocations. */
+extern void regsup_exit(void);
 
 /*
- *  ======== regsupDeleteValue ========
+ *  ======== regsup_delete_value ========
  */
-extern DSP_STATUS regsupDeleteValue(IN CONST char *pstrSubkey,
-				    IN CONST char *pstrValue);
-/*  Get the value of the entry having the given name.  Returns DSP_SOK  */
+extern dsp_status regsup_delete_value(IN CONST char *pstrValue);
+
+/*  Get the value of the entry having the given name.  Returns DSP_SOK */
 /*  if an entry was found and the value retrieved.  Returns DSP_EFAIL
- *  otherwise.*/
-extern DSP_STATUS regsupGetValue(char *valName, void *pBuf, u32 *dataSize);
+ *  otherwise. */
+extern dsp_status regsup_get_value(char *valName, void *pbuf, u32 * data_size);
 
-/*  Sets the value of the entry having the given name.  Returns DSP_SOK  */
-/*  if an entry was found and the value set.  Returns DSP_EFAIL otherwise.  */
-extern DSP_STATUS regsupSetValue(char *valName, void *pBuf, u32 dataSize);
+/*  Sets the value of the entry having the given name.  Returns DSP_SOK */
+/*  if an entry was found and the value set.  Returns DSP_EFAIL otherwise. */
+extern dsp_status regsup_set_value(char *valName, void *pbuf, u32 data_size);
 
 /*  Returns registry "values" and their "data" under a (sub)key. */
-extern DSP_STATUS regsupEnumValue(IN u32 dwIndex, IN CONST char *pstrKey,
-			IN OUT char *pstrValue, IN OUT u32 *pdwValueSize,
-			IN OUT char *pstrData, IN OUT u32 *pdwDataSize);
+extern dsp_status regsup_enum_value(IN u32 dw_index, IN CONST char *pstrKey,
+				    IN OUT char *pstrValue,
+				    IN OUT u32 *pdwValueSize,
+				    IN OUT char *pstrData,
+				    IN OUT u32 *pdwDataSize);
 
 #endif
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/services/services.c kernel-power-2.6.28.new/drivers/dsp/bridge/services/services.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/services/services.c	2011-10-11 13:51:02.017445333 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/services/services.c	2011-10-23 08:22:37.677315000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provide SERVICES loading.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,24 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== services.c ========
- *  Purpose:
- *      Provide SERVICES loading.
- *
- *  Public Functions:
- *      SERVICES_Exit
- *      SERVICES_Init
- *
- *
- *! Revision History
- *! ================
- *! 20-Nov-2000 rr: NTFY_Init/Exit added.
- *! 06-Jul-2000 rr: PROC prefix changed to PRCS to accomodate RM.
- *! 01-Feb-2000 kc: Created.
- */
-
 #include <dspbridge/host_os.h>
 
 /*  ----------------------------------- DSP/BIOS Bridge */
@@ -40,154 +24,76 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/cfg.h>
-#include <dspbridge/csl.h>
-#include <dspbridge/dbg.h>
-#include <dspbridge/dpc.h>
-#include <dspbridge/kfile.h>
-#include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/ntfy.h>
 #include <dspbridge/reg.h>
 #include <dspbridge/sync.h>
 #include <dspbridge/clk.h>
-#include <dspbridge/util.h>
 
 /*  ----------------------------------- This */
 #include <dspbridge/services.h>
 
-/*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask SERVICES_debugMask = { NULL, NULL };  /* GT trace var. */
-#endif
-
-static u32 cRefs;		/* SERVICES module reference count */
-
 /*
- *  ======== SERVICES_Exit ========
+ *  ======== services_exit ========
  *  Purpose:
  *      Discontinue usage of module; free resources when reference count
  *      reaches 0.
  */
-void SERVICES_Exit(void)
+void services_exit(void)
 {
-	DBC_Require(cRefs > 0);
-
-	GT_1trace(SERVICES_debugMask, GT_5CLASS, "SERVICES_Exit: cRefs 0x%x\n",
-		 cRefs);
-
-	cRefs--;
-	if (cRefs == 0) {
-		/* Uninitialize all SERVICES modules here */
-		NTFY_Exit();
-		UTIL_Exit();
-		SYNC_Exit();
-		CLK_Exit();
-		REG_Exit();
-		LST_Exit();
-		KFILE_Exit();
-		DPC_Exit();
-		DBG_Exit();
-		CSL_Exit();
-		CFG_Exit();
-		MEM_Exit();
-
-		GT_exit();
-	}
-
-	DBC_Ensure(cRefs >= 0);
+	/* Uninitialize all SERVICES modules here */
+	ntfy_exit();
+	sync_exit();
+	clk_exit();
+	reg_exit();
+	cfg_exit();
+	mem_exit();
 }
 
 /*
- *  ======== SERVICES_Init ========
+ *  ======== services_init ========
  *  Purpose:
  *      Initializes SERVICES modules.
  */
-bool SERVICES_Init(void)
+bool services_init(void)
 {
-	bool fInit = true;
-       bool fCFG, fCSL, fDBG, fDPC, fKFILE, fLST, fMEM;
-       bool fREG, fSYNC, fCLK, fUTIL, fNTFY;
-
-	DBC_Require(cRefs >= 0);
-
-	if (cRefs == 0) {
+	bool ret = true;
+	bool fcfg, fmem;
+	bool freg, fsync, fclk, fntfy;
+
+	/* Perform required initialization of SERVICES modules. */
+	fmem = services_mem_init();
+	freg = reg_init();
+	fcfg = cfg_init();
+	fsync = sync_init();
+	fclk = services_clk_init();
+	fntfy = ntfy_init();
+
+	ret = fcfg && fmem && freg && fsync && fclk;
+
+	if (!ret) {
+		if (fntfy)
+			ntfy_exit();
+
+		if (fsync)
+			sync_exit();
+
+		if (fclk)
+			clk_exit();
 
-		GT_init();
-		GT_create(&SERVICES_debugMask, "OS");	/* OS for OSal */
+		if (freg)
+			reg_exit();
 
-		GT_0trace(SERVICES_debugMask, GT_ENTER,
-			 "SERVICES_Init: entered\n");
+		if (fcfg)
+			cfg_exit();
 
-		/* Perform required initialization of SERVICES modules. */
-		fMEM = MEM_Init();
-		fREG = REG_Init();
-		fCFG = CFG_Init();
-		fCSL = CSL_Init();
-		fDBG = DBG_Init();
-		fDPC = DPC_Init();
-		fKFILE = KFILE_Init();
-		fLST = LST_Init();
-		/* fREG = REG_Init(); */
-		fSYNC = SYNC_Init();
-		fCLK  = CLK_Init();
-		fUTIL = UTIL_Init();
-		fNTFY = NTFY_Init();
+		if (fmem)
+			mem_exit();
 
-               fInit = fCFG && fCSL && fDBG && fDPC && fKFILE &&
-                       fLST && fMEM && fREG && fSYNC && fCLK && fUTIL;
-
-		if (!fInit) {
-			if (fNTFY)
-				NTFY_Exit();
-
-			if (fUTIL)
-				UTIL_Exit();
-
-			if (fSYNC)
-				SYNC_Exit();
-
-			if (fCLK)
-				CLK_Exit();
-
-			if (fREG)
-				REG_Exit();
-
-			if (fLST)
-				LST_Exit();
-
-			if (fKFILE)
-				KFILE_Exit();
-
-			if (fDPC)
-				DPC_Exit();
-
-			if (fDBG)
-				DBG_Exit();
-
-			if (fCSL)
-				CSL_Exit();
-
-			if (fCFG)
-				CFG_Exit();
-
-			if (fMEM)
-				MEM_Exit();
-
-		}
 	}
 
-	if (fInit)
-		cRefs++;
-
-	GT_1trace(SERVICES_debugMask, GT_5CLASS, "SERVICES_Init: cRefs 0x%x\n",
-		 cRefs);
-
-	DBC_Ensure((fInit && (cRefs > 0)) || (!fInit && (cRefs >= 0)));
-
-	return fInit;
+	return ret;
 }
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/services/sync.c kernel-power-2.6.28.new/drivers/dsp/bridge/services/sync.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/services/sync.c	2011-10-11 13:51:02.017445333 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/services/sync.c	2011-10-23 08:22:37.677315000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Synchronization services.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,39 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== sync.c ========
- *  Purpose:
- *      Synchronization services.
- *
- *  Public Functions:
- *      SYNC_CloseEvent
- *      SYNC_DeleteCS
- *      SYNC_EnterCS
- *      SYNC_Exit
- *      SYNC_Init
- *      SYNC_InitializeCS
- *      SYNC_LeaveCS
- *      SYNC_OpenEvent
- *      SYNC_ResetEvent
- *      SYNC_SetEvent
- *      SYNC_WaitOnEvent
- *      SYNC_WaitOnMultipleEvents
- *
- *! Revision History:
- *! ================
- *! 05-Nov-2001 kc: Minor cosmetic changes.
- *! 05-Oct-2000 jeh Added SYNC_WaitOnMultipleEvents().
- *! 10-Aug-2000 rr: SYNC_PostMessage added.
- *! 10-Jul-2000 jeh Modified SYNC_OpenEvent() to handle NULL attrs.
- *! 03-Feb-2000 rr: Module init/exit is handled by SERVICES Init/Exit.
- *!		 GT Changes.
- *! 01-Dec-1999 ag: Added optional named event creation in SYNC_OpenEvent().
- *! 22-Nov-1999 kc: Added changes from code review.
- *! 22-Sep-1999 kc: Modified from sync95.c.
- *! 05-Aug-1996 gp: Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -57,10 +26,8 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/mem.h>
 
 /*  ----------------------------------- This */
@@ -70,39 +37,34 @@
 #define SIGNATURE       0x434e5953	/* "SYNC" (in reverse) */
 
 enum wait_state {
-	wo_waiting,
-	wo_signalled
-} ;
+	WO_WAITING,
+	WO_SIGNALLED
+};
 
 enum sync_state {
-	so_reset,
-	so_signalled
-} ;
+	SO_RESET,
+	SO_SIGNALLED
+};
 
-struct WAIT_OBJECT {
+struct wait_object {
 	enum wait_state state;
-	struct SYNC_OBJECT *signalling_event;
+	struct sync_object *signalling_event;
 	struct semaphore sem;
 };
 
 /* Generic SYNC object: */
-struct SYNC_OBJECT {
-	u32 dwSignature;	/* Used for object validation. */
+struct sync_object {
+	u32 dw_signature;	/* Used for object validation. */
 	enum sync_state state;
 	spinlock_t sync_lock;
-	struct WAIT_OBJECT *pWaitObj;
+	struct wait_object *wait_obj;
 };
 
-struct SYNC_DPCCSOBJECT {
-	u32 dwSignature;	/* used for object validation */
+struct sync_dpccsobject {
+	u32 dw_signature;	/* used for object validation */
 	spinlock_t sync_dpccs_lock;
 	s32 count;
-} ;
-
-/*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask SYNC_debugMask = { NULL, NULL };  /* GT trace variable */
-#endif
+};
 
 static int test_and_set(volatile void *ptr, int val)
 {
@@ -114,124 +76,98 @@
 static void timeout_callback(unsigned long hWaitObj);
 
 /*
- *  ======== SYNC_CloseEvent ========
+ *  ======== sync_close_event ========
  *  Purpose:
  *      Close an existing SYNC event object.
  */
-DSP_STATUS SYNC_CloseEvent(struct SYNC_OBJECT *hEvent)
+dsp_status sync_close_event(struct sync_object *event_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_OBJECT *pEvent = (struct SYNC_OBJECT *)hEvent;
+	dsp_status status = DSP_SOK;
+	struct sync_object *event = (struct sync_object *)event_obj;
 
-	DBC_Require(pEvent != NULL && pEvent->pWaitObj == NULL);
+	DBC_REQUIRE(event != NULL && event->wait_obj == NULL);
 
-	GT_1trace(SYNC_debugMask, GT_ENTER, "SYNC_CloseEvent: hEvent 0x%x\n",
-		  hEvent);
-
-	if (MEM_IsValidHandle(hEvent, SIGNATURE)) {
-		if (pEvent->pWaitObj) {
+	if (MEM_IS_VALID_HANDLE(event_obj, SIGNATURE)) {
+		if (event->wait_obj)
 			status = DSP_EFAIL;
-			GT_0trace(SYNC_debugMask, GT_6CLASS,
-				  "SYNC_CloseEvent: Wait object not NULL\n");
-		}
-		MEM_FreeObject(pEvent);
+
+		MEM_FREE_OBJECT(event);
 
 	} else {
 		status = DSP_EHANDLE;
-		GT_1trace(SYNC_debugMask, GT_6CLASS,
-			  "SYNC_CloseEvent: invalid "
-			  "hEvent handle 0x%x\n", hEvent);
 	}
 
 	return status;
 }
 
 /*
- *  ======== SYNC_Exit ========
+ *  ======== sync_exit ========
  *  Purpose:
  *      Cleanup SYNC module.
  */
-void SYNC_Exit(void)
+void sync_exit(void)
 {
-	GT_0trace(SYNC_debugMask, GT_5CLASS, "SYNC_Exit\n");
+	/* Do nothing */
 }
 
 /*
- *  ======== SYNC_Init ========
+ *  ======== sync_init ========
  *  Purpose:
  *      Initialize SYNC module.
  */
-bool SYNC_Init(void)
+bool sync_init(void)
 {
-	GT_create(&SYNC_debugMask, "SY");	/* SY for SYnc */
-
-	GT_0trace(SYNC_debugMask, GT_5CLASS, "SYNC_Init\n");
-
 	return true;
 }
 
 /*
- *  ======== SYNC_OpenEvent ========
+ *  ======== sync_open_event ========
  *  Purpose:
  *      Open a new synchronization event object.
  */
-DSP_STATUS SYNC_OpenEvent(OUT struct SYNC_OBJECT **phEvent,
-			  IN OPTIONAL struct SYNC_ATTRS *pAttrs)
+dsp_status sync_open_event(OUT struct sync_object **ph_event,
+			   IN OPTIONAL struct sync_attrs *pattrs)
 {
-	struct SYNC_OBJECT *pEvent = NULL;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(phEvent != NULL);
+	struct sync_object *event = NULL;
+	dsp_status status = DSP_SOK;
 
-	GT_2trace(SYNC_debugMask, GT_ENTER,
-		  "SYNC_OpenEvent: phEvent 0x%x, pAttrs "
-		  "0x%x\n", phEvent, pAttrs);
+	DBC_REQUIRE(ph_event != NULL);
 
 	/* Allocate memory for sync object */
-	MEM_AllocObject(pEvent, struct SYNC_OBJECT, SIGNATURE);
-	if (pEvent != NULL) {
-		pEvent->state = so_reset;
-		pEvent->pWaitObj = NULL;
-		spin_lock_init(&pEvent->sync_lock);
+	MEM_ALLOC_OBJECT(event, struct sync_object, SIGNATURE);
+	if (event != NULL) {
+		event->state = SO_RESET;
+		event->wait_obj = NULL;
+		spin_lock_init(&event->sync_lock);
 	} else {
 		status = DSP_EMEMORY;
-		GT_0trace(SYNC_debugMask, GT_6CLASS,
-			  "SYNC_OpenEvent: MEM_AllocObject failed\n");
 	}
 
-	*phEvent = pEvent;
+	*ph_event = event;
 
 	return status;
 }
 
 /*
- *  ======== SYNC_ResetEvent ========
+ *  ======== sync_reset_event ========
  *  Purpose:
  *      Reset an event to non-signalled.
  */
-DSP_STATUS SYNC_ResetEvent(struct SYNC_OBJECT *hEvent)
+dsp_status sync_reset_event(struct sync_object *event_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_OBJECT *pEvent = (struct SYNC_OBJECT *)hEvent;
+	dsp_status status = DSP_SOK;
+	struct sync_object *event = (struct sync_object *)event_obj;
 
-	GT_1trace(SYNC_debugMask, GT_ENTER, "SYNC_ResetEvent: hEvent 0x%x\n",
-		  hEvent);
-
-	if (MEM_IsValidHandle(hEvent, SIGNATURE)) {
-		pEvent->state = so_reset;
-		status = DSP_SOK;
-	} else {
+	if (MEM_IS_VALID_HANDLE(event_obj, SIGNATURE))
+		event->state = SO_RESET;
+	else
 		status = DSP_EHANDLE;
-		GT_1trace(SYNC_debugMask, GT_6CLASS,
-			  "SYNC_ResetEvent: invalid hEvent "
-			  "handle 0x%x\n", hEvent);
-	}
 
 	return status;
 }
 
 /*
- *  ======== SYNC_SetEvent ========
+ *  ======== sync_set_event ========
  *  Purpose:
  *      Set an event to signaled and unblock one waiting thread.
  *
@@ -239,138 +175,106 @@
  *  are disabled to ensure atomicity.
  */
 
-DSP_STATUS SYNC_SetEvent(struct SYNC_OBJECT *hEvent)
+dsp_status sync_set_event(struct sync_object *event_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_OBJECT *pEvent = (struct SYNC_OBJECT *)hEvent;
+	dsp_status status = DSP_SOK;
+	struct sync_object *event = (struct sync_object *)event_obj;
 	unsigned long flags;
 
-	GT_1trace(SYNC_debugMask, GT_6CLASS, "SYNC_SetEvent: hEvent 0x%x\n",
-		  hEvent);
+	if (MEM_IS_VALID_HANDLE(event_obj, SIGNATURE)) {
+		spin_lock_irqsave(&event_obj->sync_lock, flags);
 
-	if (MEM_IsValidHandle(hEvent, SIGNATURE)) {
-		spin_lock_irqsave(&hEvent->sync_lock, flags);
-		GT_1trace(SYNC_debugMask, GT_6CLASS,
-			"SYNC_SetEvent: pEvent->pWaitObj "
-			"= 0x%x \n", pEvent->pWaitObj);
-	if (pEvent->pWaitObj)
-		GT_1trace(SYNC_debugMask, GT_6CLASS, "SYNC_SetEvent: "
-			"pEvent->pWaitObj->state = 0x%x \n",
-			pEvent->pWaitObj->state);
-		if (pEvent->pWaitObj != NULL &&
-		   test_and_set(&pEvent->pWaitObj->state,
-		   wo_signalled) == wo_waiting) {
-
-			pEvent->state = so_reset;
-			pEvent->pWaitObj->signalling_event = pEvent;
-			up(&pEvent->pWaitObj->sem);
-			GT_1trace(SYNC_debugMask, GT_6CLASS,
-				  "SYNC_SetEvent: Unlock "
-				  "Semaphore for hEvent 0x%x\n", hEvent);
+		if (event->wait_obj != NULL &&
+		    test_and_set(&event->wait_obj->state,
+				 WO_SIGNALLED) == WO_WAITING) {
+			event->state = SO_RESET;
+			event->wait_obj->signalling_event = event;
+			up(&event->wait_obj->sem);
 		} else {
-			pEvent->state = so_signalled;
+			event->state = SO_SIGNALLED;
 		}
-		spin_unlock_irqrestore(&hEvent->sync_lock, flags);
+		spin_unlock_irqrestore(&event_obj->sync_lock, flags);
 	} else {
 		status = DSP_EHANDLE;
-		GT_1trace(SYNC_debugMask, GT_6CLASS,
-			  "SYNC_SetEvent: invalid hEvent "
-			  "handle 0x%x\n", hEvent);
 	}
 	return status;
 }
 
 /*
- *  ======== SYNC_WaitOnEvent ========
+ *  ======== sync_wait_on_event ========
  *  Purpose:
  *      Wait for an event to be signalled, up to the specified timeout.
  *      Note: dwTimeOut must be 0xffffffff to signal infinite wait.
  */
-DSP_STATUS SYNC_WaitOnEvent(struct SYNC_OBJECT *hEvent, u32 dwTimeout)
+dsp_status sync_wait_on_event(struct sync_object *event_obj, u32 dwTimeout)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_OBJECT *pEvent = (struct SYNC_OBJECT *)hEvent;
+	dsp_status status = DSP_SOK;
+	struct sync_object *event = (struct sync_object *)event_obj;
 	u32 temp;
 
-	GT_2trace(SYNC_debugMask, GT_6CLASS, "SYNC_WaitOnEvent: hEvent 0x%x\n, "
-		  "dwTimeOut 0x%x", hEvent, dwTimeout);
-	if (MEM_IsValidHandle(hEvent, SIGNATURE)) {
-		status = SYNC_WaitOnMultipleEvents(&pEvent, 1, dwTimeout,
-						  &temp);
-	} else {
+	if (MEM_IS_VALID_HANDLE(event_obj, SIGNATURE))
+		status = sync_wait_on_multiple_events(&event, 1, dwTimeout,
+						      &temp);
+	else
 		status = DSP_EHANDLE;
-		GT_1trace(SYNC_debugMask, GT_6CLASS,
-			  "SYNC_WaitOnEvent: invalid hEvent"
-			  "handle 0x%x\n", hEvent);
-	}
+
 	return status;
 }
 
 /*
- *  ======== SYNC_WaitOnMultipleEvents ========
+ *  ======== sync_wait_on_multiple_events ========
  *  Purpose:
  *      Wait for any of an array of events to be signalled, up to the
  *      specified timeout.
  */
-DSP_STATUS SYNC_WaitOnMultipleEvents(struct SYNC_OBJECT **hSyncEvents,
-				     u32 uCount, u32 dwTimeout,
-				     OUT u32 *puIndex)
+dsp_status sync_wait_on_multiple_events(struct sync_object **sync_events,
+					u32 count, u32 dwTimeout,
+					OUT u32 *pu_index)
 {
 	u32 i;
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 	u32 curr;
-	struct WAIT_OBJECT *Wp;
+	struct wait_object *wp;
+
+	DBC_REQUIRE(count > 0);
+	DBC_REQUIRE(sync_events != NULL);
+	DBC_REQUIRE(pu_index != NULL);
 
-	DBC_Require(uCount > 0);
-	DBC_Require(hSyncEvents != NULL);
-	DBC_Require(puIndex != NULL);
-
-	for (i = 0; i < uCount; i++)
-		DBC_Require(MEM_IsValidHandle(hSyncEvents[i], SIGNATURE));
-
-	GT_4trace(SYNC_debugMask, GT_6CLASS,
-		  "SYNC_WaitOnMultipleEvents: hSyncEvents:"
-		  "0x%x\tuCount: 0x%x" "\tdwTimeout: 0x%x\tpuIndex: 0x%x\n",
-		  hSyncEvents, uCount, dwTimeout, puIndex);
+	for (i = 0; i < count; i++)
+		DBC_REQUIRE(MEM_IS_VALID_HANDLE(sync_events[i], SIGNATURE));
 
-	Wp = MEM_Calloc(sizeof(struct WAIT_OBJECT), MEM_NONPAGED);
-	if (Wp == NULL)
+	wp = mem_calloc(sizeof(struct wait_object), MEM_NONPAGED);
+	if (wp == NULL)
 		return DSP_EMEMORY;
 
-	Wp->state = wo_waiting;
-	Wp->signalling_event = NULL;
-	init_MUTEX_LOCKED(&(Wp->sem));
-
-	for (curr = 0; curr < uCount; curr++) {
-		hSyncEvents[curr]->pWaitObj = Wp;
-		if (hSyncEvents[curr]->state == so_signalled) {
-			GT_0trace(SYNC_debugMask, GT_6CLASS,
-				 "Detected signaled Event !!!\n");
-			if (test_and_set(&(Wp->state), wo_signalled) ==
-			   wo_waiting) {
-				GT_0trace(SYNC_debugMask, GT_6CLASS,
-					 "Setting Signal Event!!!\n");
-				hSyncEvents[curr]->state = so_reset;
-				Wp->signalling_event = hSyncEvents[curr];
+	wp->state = WO_WAITING;
+	wp->signalling_event = NULL;
+	init_MUTEX_LOCKED(&(wp->sem));
+
+	for (curr = 0; curr < count; curr++) {
+		sync_events[curr]->wait_obj = wp;
+		if (sync_events[curr]->state == SO_SIGNALLED) {
+			if (test_and_set(&(wp->state), WO_SIGNALLED) ==
+			    WO_WAITING) {
+				sync_events[curr]->state = SO_RESET;
+				wp->signalling_event = sync_events[curr];
 			}
-		curr++;	/* Will try optimizing later */
-		break;
+			curr++;	/* Will try optimizing later */
+			break;
 		}
 	}
 
 	curr--;			/* Will try optimizing later */
-	if (Wp->state != wo_signalled && dwTimeout > 0) {
+	if (wp->state != WO_SIGNALLED && dwTimeout > 0) {
 		struct timer_list timeout;
 		if (dwTimeout != SYNC_INFINITE) {
-			init_timer(&timeout);
+			init_timer_on_stack(&timeout);
 			timeout.function = timeout_callback;
-			timeout.data = (unsigned long)Wp;
+			timeout.data = (unsigned long)wp;
 			timeout.expires = jiffies + dwTimeout * HZ / 1000;
 			add_timer(&timeout);
 		}
-		if (down_interruptible(&(Wp->sem))) {
-			GT_0trace(SYNC_debugMask, GT_7CLASS, "SYNC: "
-				"WaitOnMultipleEvents Interrupted by signal\n");
+		if (down_interruptible(&(wp->sem))) {
 			/*
 			 * Most probably we are interrupted by a fake signal
 			 * from freezer. Return -ERESTARTSYS so that this
@@ -381,227 +285,168 @@
 		}
 		if (dwTimeout != SYNC_INFINITE) {
 			if (in_interrupt()) {
-				if (!del_timer(&timeout)) {
-					GT_0trace(SYNC_debugMask, GT_7CLASS,
-						  "SYNC: Timer expired\n");
-				}
+				del_timer(&timeout);
 			} else {
-				if (!del_timer_sync(&timeout)) {
-					GT_0trace(SYNC_debugMask, GT_7CLASS,
-						  "SYNC: Timer expired\n");
-				}
+				del_timer_sync(&timeout);
 			}
 		}
 	}
 	for (i = 0; i <= curr; i++) {
-		if (MEM_IsValidHandle(hSyncEvents[i], SIGNATURE)) {
-			/*  Memory corruption here if hSyncEvents[i] is
+		if (MEM_IS_VALID_HANDLE(sync_events[i], SIGNATURE)) {
+			/*  Memory corruption here if sync_events[i] is
 			 *  freed before following statememt. */
-			hSyncEvents[i]->pWaitObj = NULL;
+			sync_events[i]->wait_obj = NULL;
 		}
-		if (hSyncEvents[i] == Wp->signalling_event)
-			*puIndex = i;
+		if (sync_events[i] == wp->signalling_event)
+			*pu_index = i;
 
 	}
-	if (Wp->signalling_event == NULL && DSP_SUCCEEDED(status)) {
-		GT_0trace(SYNC_debugMask, GT_7CLASS,
-			  "SYNC:Signaling Event NULL!!!(:-\n");
+	if (wp->signalling_event == NULL && DSP_SUCCEEDED(status))
 		status = DSP_ETIMEOUT;
-	}
-	if (Wp)
-		MEM_Free(Wp);
+	kfree(wp);
 	return status;
 }
 
 static void timeout_callback(unsigned long hWaitObj)
 {
-	struct WAIT_OBJECT *pWaitObj = (struct WAIT_OBJECT *)hWaitObj;
-	if (test_and_set(&pWaitObj->state, wo_signalled) == wo_waiting)
-		up(&pWaitObj->sem);
+	struct wait_object *wait_obj = (struct wait_object *)hWaitObj;
+	if (test_and_set(&wait_obj->state, WO_SIGNALLED) == WO_WAITING)
+		up(&wait_obj->sem);
 
 }
 
 /*
- *  ======== SYNC_DeleteCS ========
+ *  ======== sync_delete_cs ========
  */
-DSP_STATUS SYNC_DeleteCS(struct SYNC_CSOBJECT *hCSObj)
+dsp_status sync_delete_cs(struct sync_csobject *hcs_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_CSOBJECT *pCSObj = (struct SYNC_CSOBJECT *)hCSObj;
+	dsp_status status = DSP_SOK;
+	struct sync_csobject *pcs_obj = (struct sync_csobject *)hcs_obj;
 
-	GT_0trace(SYNC_debugMask, GT_ENTER, "SYNC_DeleteCS\n");
+	if (MEM_IS_VALID_HANDLE(hcs_obj, SIGNATURECS)) {
+		if (down_trylock(&pcs_obj->sem) != 0)
+			DBC_ASSERT(0);
 
-	if (MEM_IsValidHandle(hCSObj, SIGNATURECS)) {
-		if (down_trylock(&pCSObj->sem) != 0) {
-			GT_1trace(SYNC_debugMask, GT_7CLASS,
-				  "CS in use (locked) while "
-				  "deleting! pCSObj=0x%X", pCSObj);
-			DBC_Assert(0);
-		}
-		MEM_FreeObject(hCSObj);
-	} else if (MEM_IsValidHandle(hCSObj, SIGNATUREDPCCS)) {
-		struct SYNC_DPCCSOBJECT *pDPCCSObj =
-					 (struct SYNC_DPCCSOBJECT *)hCSObj;
-		if (pDPCCSObj->count != 1) {
-			GT_1trace(SYNC_debugMask, GT_7CLASS,
-				  "DPC CS in use (locked) while "
-				  "deleting! pCSObj=0x%X", pCSObj);
-			DBC_Assert(0);
-		}
-		MEM_FreeObject(pDPCCSObj);
+		MEM_FREE_OBJECT(hcs_obj);
+	} else if (MEM_IS_VALID_HANDLE(hcs_obj, SIGNATUREDPCCS)) {
+		struct sync_dpccsobject *pdpccs_obj =
+		    (struct sync_dpccsobject *)hcs_obj;
+		if (pdpccs_obj->count != 1)
+			DBC_ASSERT(0);
+
+		MEM_FREE_OBJECT(pdpccs_obj);
 	} else {
 		status = DSP_EHANDLE;
-		GT_1trace(SYNC_debugMask, GT_6CLASS,
-			  "SYNC_DeleteCS: invalid hCSObj "
-			  "handle 0x%x\n", hCSObj);
 	}
 
 	return status;
 }
 
 /*
- *  ======== SYNC_EnterCS ========
+ *  ======== sync_enter_cs ========
  */
-DSP_STATUS SYNC_EnterCS(struct SYNC_CSOBJECT *hCSObj)
+dsp_status sync_enter_cs(struct sync_csobject *hcs_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_CSOBJECT *pCSObj = (struct SYNC_CSOBJECT *)hCSObj;
+	dsp_status status = DSP_SOK;
+	struct sync_csobject *pcs_obj = (struct sync_csobject *)hcs_obj;
 
-	GT_1trace(SYNC_debugMask, GT_ENTER, "SYNC_EnterCS: hCSObj %p\n",
-		 hCSObj);
-	if (MEM_IsValidHandle(hCSObj, SIGNATURECS)) {
+	if (MEM_IS_VALID_HANDLE(hcs_obj, SIGNATURECS)) {
 		if (in_interrupt()) {
 			status = DSP_EFAIL;
-			GT_0trace(SYNC_debugMask, GT_7CLASS,
-				 "SYNC_EnterCS called from "
-				 "ISR/DPC or with ISR/DPC disabled!");
-			DBC_Assert(0);
-		} else if (down_interruptible(&pCSObj->sem)) {
-			GT_1trace(SYNC_debugMask, GT_7CLASS,
-				 "CS interrupted by signal! "
-				 "pCSObj=0x%X", pCSObj);
+			DBC_ASSERT(0);
+		} else if (down_interruptible(&pcs_obj->sem)) {
 			status = DSP_EFAIL;
 		}
-	} else if (MEM_IsValidHandle(hCSObj, SIGNATUREDPCCS)) {
-		struct SYNC_DPCCSOBJECT *pDPCCSObj =
-					(struct SYNC_DPCCSOBJECT *)hCSObj;
-		GT_0trace(SYNC_debugMask, GT_ENTER, "SYNC_EnterCS DPC\n");
-		spin_lock_bh(&pDPCCSObj->sync_dpccs_lock);
-		pDPCCSObj->count--;
-		if (pDPCCSObj->count != 0) {
+	} else if (MEM_IS_VALID_HANDLE(hcs_obj, SIGNATUREDPCCS)) {
+		struct sync_dpccsobject *pdpccs_obj =
+		    (struct sync_dpccsobject *)hcs_obj;
+		spin_lock_bh(&pdpccs_obj->sync_dpccs_lock);
+		pdpccs_obj->count--;
+		if (pdpccs_obj->count != 0) {
 			/* FATAL ERROR : Failed to acquire DPC CS */
-			GT_2trace(SYNC_debugMask, GT_7CLASS,
-				  "SYNC_EnterCS DPCCS %x locked,"
-				  "count %d", pDPCCSObj, pDPCCSObj->count);
-			spin_unlock_bh(&pDPCCSObj->sync_dpccs_lock);
-			DBC_Assert(0);
+			spin_unlock_bh(&pdpccs_obj->sync_dpccs_lock);
+			DBC_ASSERT(0);
 		}
 	} else {
 		status = DSP_EHANDLE;
-		GT_1trace(SYNC_debugMask, GT_6CLASS,
-			  "SYNC_EnterCS: invalid hCSObj "
-			  "handle 0x%x\n", hCSObj);
 	}
 
 	return status;
 }
 
 /*
- *  ======== SYNC_InitializeCS ========
+ *  ======== sync_initialize_cs ========
  */
-DSP_STATUS SYNC_InitializeCS(OUT struct SYNC_CSOBJECT **phCSObj)
+dsp_status sync_initialize_cs(OUT struct sync_csobject **phCSObj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_CSOBJECT *pCSObj = NULL;
-
-	GT_0trace(SYNC_debugMask, GT_ENTER, "SYNC_InitializeCS\n");
+	dsp_status status = DSP_SOK;
+	struct sync_csobject *pcs_obj = NULL;
 
 	/* Allocate memory for sync CS object */
-	MEM_AllocObject(pCSObj, struct SYNC_CSOBJECT, SIGNATURECS);
-	if (pCSObj != NULL) {
-		init_MUTEX(&pCSObj->sem);
-	} else {
+	MEM_ALLOC_OBJECT(pcs_obj, struct sync_csobject, SIGNATURECS);
+	if (pcs_obj != NULL)
+		init_MUTEX(&pcs_obj->sem);
+	else
 		status = DSP_EMEMORY;
-		GT_0trace(SYNC_debugMask, GT_6CLASS,
-			  "SYNC_InitializeCS: MEM_AllocObject"
-			  "failed\n");
-	}
+
 	/* return CS object */
-	*phCSObj = pCSObj;
-	DBC_Assert(DSP_FAILED(status) || (pCSObj));
+	*phCSObj = pcs_obj;
+	DBC_ASSERT(DSP_FAILED(status) || (pcs_obj));
 	return status;
 }
 
-DSP_STATUS SYNC_InitializeDPCCS(OUT struct SYNC_CSOBJECT **phCSObj)
+dsp_status sync_initialize_dpccs(OUT struct sync_csobject **phCSObj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_DPCCSOBJECT *pCSObj = NULL;
+	dsp_status status = DSP_SOK;
+	struct sync_dpccsobject *pcs_obj = NULL;
 
-	DBC_Require(phCSObj);
-
-	GT_0trace(SYNC_debugMask, GT_ENTER, "SYNC_InitializeDPCCS\n");
+	DBC_REQUIRE(phCSObj);
 
 	if (phCSObj) {
 		/* Allocate memory for sync CS object */
-		MEM_AllocObject(pCSObj, struct SYNC_DPCCSOBJECT,
-				SIGNATUREDPCCS);
-		if (pCSObj != NULL) {
-			pCSObj->count = 1;
-			spin_lock_init(&pCSObj->sync_dpccs_lock);
+		MEM_ALLOC_OBJECT(pcs_obj, struct sync_dpccsobject,
+				 SIGNATUREDPCCS);
+		if (pcs_obj != NULL) {
+			pcs_obj->count = 1;
+			spin_lock_init(&pcs_obj->sync_dpccs_lock);
 		} else {
 			status = DSP_EMEMORY;
-			GT_0trace(SYNC_debugMask, GT_6CLASS,
-				  "SYNC_InitializeDPCCS: "
-				  "MEM_AllocObject failed\n");
 		}
 
 		/* return CS object */
-		*phCSObj = (struct SYNC_CSOBJECT *)pCSObj;
+		*phCSObj = (struct sync_csobject *)pcs_obj;
 	} else {
 		status = DSP_EPOINTER;
 	}
 
-	GT_1trace(SYNC_debugMask, GT_ENTER, "SYNC_InitializeDPCCS "
-		  "pCSObj %p\n", pCSObj);
-	DBC_Assert(DSP_FAILED(status) || (pCSObj));
+	DBC_ASSERT(DSP_FAILED(status) || (pcs_obj));
 
 	return status;
 }
 
 /*
- *  ======== SYNC_LeaveCS ========
+ *  ======== sync_leave_cs ========
  */
-DSP_STATUS SYNC_LeaveCS(struct SYNC_CSOBJECT *hCSObj)
+dsp_status sync_leave_cs(struct sync_csobject *hcs_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct SYNC_CSOBJECT *pCSObj = (struct SYNC_CSOBJECT *)hCSObj;
-
-	GT_1trace(SYNC_debugMask, GT_ENTER, "SYNC_LeaveCS: hCSObj %p\n",
-		  hCSObj);
+	dsp_status status = DSP_SOK;
+	struct sync_csobject *pcs_obj = (struct sync_csobject *)hcs_obj;
 
-	if (MEM_IsValidHandle(hCSObj, SIGNATURECS)) {
-		up(&pCSObj->sem);
-	} else if (MEM_IsValidHandle(hCSObj, SIGNATUREDPCCS)) {
-		struct SYNC_DPCCSOBJECT *pDPCCSObj =
-					(struct SYNC_DPCCSOBJECT *)hCSObj;
-		pDPCCSObj->count++;
-		if (pDPCCSObj->count != 1) {
+	if (MEM_IS_VALID_HANDLE(hcs_obj, SIGNATURECS)) {
+		up(&pcs_obj->sem);
+	} else if (MEM_IS_VALID_HANDLE(hcs_obj, SIGNATUREDPCCS)) {
+		struct sync_dpccsobject *pdpccs_obj =
+		    (struct sync_dpccsobject *)hcs_obj;
+		pdpccs_obj->count++;
+		if (pdpccs_obj->count != 1) {
 			/* FATAL ERROR : Invalid DPC CS count */
-			GT_2trace(SYNC_debugMask, GT_7CLASS,
-				  "SYNC_LeaveCS DPCCS %x, "
-				  "Invalid count %d", pDPCCSObj,
-				  pDPCCSObj->count);
-			spin_unlock_bh(&pDPCCSObj->sync_dpccs_lock);
-			DBC_Assert(0);
-			spin_lock_bh(&pDPCCSObj->sync_dpccs_lock);
+			spin_unlock_bh(&pdpccs_obj->sync_dpccs_lock);
+			DBC_ASSERT(0);
+			spin_lock_bh(&pdpccs_obj->sync_dpccs_lock);
 		}
-		spin_unlock_bh(&pDPCCSObj->sync_dpccs_lock);
-		GT_0trace(SYNC_debugMask, GT_ENTER, "SYNC_LeaveCS DPC\n");
+		spin_unlock_bh(&pdpccs_obj->sync_dpccs_lock);
 	} else {
 		status = DSP_EHANDLE;
-		GT_1trace(SYNC_debugMask, GT_6CLASS,
-			  "SYNC_LeaveCS: invalid hCSObj "
-			  "handle 0x%x\n", hCSObj);
 	}
 
 	return status;
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/chnl_sm.c kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/chnl_sm.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/chnl_sm.c	2011-10-11 13:51:02.143630515 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/chnl_sm.c	2011-10-23 08:22:37.682749000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implements upper edge functions for WMD channel module.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,33 +16,14 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
 /*
- *  ======== chnl_sm.c ========
- *  Description:
- *      Implements upper edge functions for WMD channel module.
- *
- *  Public Functions:
- *      WMD_CHNL_AddIOReq
- *      WMD_CHNL_CancelIO
- *      WMD_CHNL_Close
- *      WMD_CHNL_Create
- *      WMD_CHNL_Destroy
- *      WMD_CHNL_FlushIO
- *      WMD_CHNL_GetInfo
- *      WMD_CHNL_GetIOC
- *      WMD_CHNL_GetMgrInfo
- *      WMD_CHNL_Idle
- *      WMD_CHNL_Open
- *
- *  Notes:
  *      The lower edge functions must be implemented by the WMD writer, and
  *      are declared in chnl_sm.h.
  *
  *      Care is taken in this code to prevent simulataneous access to channel
  *      queues from
  *      1. Threads.
- *      2. IO_DPC(), scheduled from the IO_ISR() as an event.
+ *      2. io_dpc(), scheduled from the io_isr() as an event.
  *
  *      This is done primarily by:
  *      - Semaphores.
@@ -50,67 +33,13 @@
  *
  *  Channel Invariant:
  *      There is an important invariant condition which must be maintained per
- *      channel outside of WMD_CHNL_GetIOC() and IO_Dispatch(), violation of
- *      which may cause timeouts and/or failure offunction SYNC_WaitOnEvent.
+ *      channel outside of bridge_chnl_get_ioc() and IO_Dispatch(), violation of
+ *      which may cause timeouts and/or failure offunction sync_wait_on_event.
  *      This invariant condition is:
  *
- *          LST_Empty(pChnl->pIOCompletions) ==> pChnl->hSyncEvent is reset
+ *          LST_Empty(pchnl->pio_completions) ==> pchnl->sync_event is reset
  *      and
- *          !LST_Empty(pChnl->pIOCompletions) ==> pChnl->hSyncEvent is set.
- *
- *! Revision History:
- *! ================
- *! 10-Feb-2004 sb: Consolidated the MAILBOX_IRQ macro at the top of the file.
- *! 05-Jan-2004 vp: Updated for 2.6 kernel on 24xx platform.
- *! 23-Apr-2003 sb: Fixed mailbox deadlock
- *! 24-Feb-2003 vp: Code Review Updates.
- *! 18-Oct-2002 vp: Ported to Linux platform
- *! 29-Aug-2002 rr  Changed the SYNC error code return to DSP error code return
- *            in WMD_CHNL_GetIOC.
- *! 22-Jan-2002 ag  Zero-copy support added.
- *!                 CMM_CallocBuf() used for SM allocations.
- *! 04-Feb-2001 ag  DSP-DMA support added.
- *! 22-Nov-2000 kc: Updated usage of PERF_RegisterStat.
- *! 06-Nov-2000 jeh Move ISR_Install, DPC_Create from CHNL_Create to IO_Create.
- *! 13-Oct-2000 jeh Added dwArg parameter to WMD_CHNL_AddIOReq(), added
- *!                 WMD_CHNL_Idle and WMD_CHNL_RegisterNotify for DSPStream.
- *!                 Remove #ifdef DEBUG from around channel cIOCs field.
- *! 21-Sep-2000 rr: PreOMAP chnl class library acts like a IO class library.
- *! 25-Sep-2000 ag: MEM_[Unmap]LinearAddress added for #ifdef CHNL_PREOMAP.
- *! 07-Sep-2000 rr: Added new channel class for PreOMAP.
- *! 11-Jul-2000 jeh Allow NULL user event in WMD_CHNL_Open().
- *! 06-Jul-2000 rr: Changed prefix PROC to PRCS for process module calls.
- *! 20-Jan-2000 ag: Incorporated code review comments.
- *! 05-Jan-2000 ag: Text format cleanup.
- *! 07-Dec-1999 ag: Now setting ChnlMgr fSharedIRQ flag before ISR_Install().
- *! 01-Dec-1999 ag: WMD_CHNL_Open() now accepts named sync event.
- *! 14-Nov-1999 ag: DPC_Schedule() uncommented.
- *! 28-Oct-1999 ag: CHNL Attrs userEvent not supported.
- *!                 SM addrs taken from COFF(IO) or host resource(SM).
- *! 25-May-1999 jg: CHNL_IOCLASS boards now get their shared memory buffer
- *!                 address and length from symbols defined in the currently
- *!                 loaded COFF file. See _chn_sm.h.
- *! 18-Jun-1997 gp: Moved waiting back to ring 0 to improve performance.
- *! 22-Jan-1998 gp: Update User's pIOC struct in GetIOC at lower IRQL (NT).
- *! 16-Jan-1998 gp: Commented out PERF stuff, since it is not all there in NT.
- *! 13-Jan-1998 gp: Protect IOCTLs from IO_DPC by raising IRQL to DIRQL (NT).
- *! 22-Oct-1997 gp: Call SYNC_OpenEvent in CHNL_Open, for NT support.
- *! 18-Jun-1997 gp: Moved waiting back to ring 0 to improve performance.
- *! 16-Jun-1997 gp: Added call into lower edge CHNL function to allow override
- *!                 of the SHM window length reported by Windows CM.
- *! 05-Jun-1997 gp: Removed unnecessary critical sections.
- *! 18-Mar-1997 gp: Ensured CHNL_FlushIO on input leaves channel in READY state.
- *! 06-Jan-1997 gp: ifdefed to support the IO variant of SHM channel class lib.
- *! 21-Jan-1997 gp: CHNL_Close: set pChnl = NULL for DBC_Ensure().
- *! 14-Jan-1997 gp: Updated based on code review feedback.
- *! 03-Jan-1997 gp: Added CHNL_E_WAITTIMEOUT error return code to CHNL_FlushIO()
- *! 23-Oct-1996 gp: Tag channel with ring 0 process handle.
- *! 13-Sep-1996 gp: Added performance statistics for channel.
- *! 09-Sep-1996 gp: Added WMD_CHNL_GetMgrInfo().
- *! 04-Sep-1996 gp: Removed shared memory control struct offset: made zero.
- *! 01-Aug-1996 gp: Implemented basic channel manager and channel create/delete.
- *! 17-Jul-1996 gp: Started pseudo coding.
- *! 11-Jul-1996 gp: Stubbed out.
+ *          !LST_Empty(pchnl->pio_completions) ==> pchnl->sync_event is set.
  */
 
 /*  ----------------------------------- OS */
@@ -123,17 +52,16 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/dbg.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/mem.h>
 #include <dspbridge/cfg.h>
-#include <dspbridge/csl.h>
 #include <dspbridge/sync.h>
 
 /*  ----------------------------------- Mini-Driver */
 #include <dspbridge/wmd.h>
 #include <dspbridge/wmdchnl.h>
+#include "_tiomap.h"
 
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/dev.h>
@@ -147,406 +75,408 @@
 #define MAILBOX_IRQ INT_MAIL_MPU_IRQ
 
 /*  ----------------------------------- Function Prototypes */
-static struct LST_LIST *CreateChirpList(u32 uChirps);
+static struct lst_list *create_chirp_list(u32 uChirps);
 
-static void FreeChirpList(struct LST_LIST *pList);
+static void free_chirp_list(struct lst_list *pList);
 
-static struct CHNL_IRP *MakeNewChirp(void);
+static struct chnl_irp *make_new_chirp(void);
 
-static DSP_STATUS SearchFreeChannel(struct CHNL_MGR *pChnlMgr,
-				   OUT u32 *pdwChnl);
+static dsp_status search_free_channel(struct chnl_mgr *chnl_mgr_obj,
+				      OUT u32 *pdwChnl);
 
 /*
- *  ======== WMD_CHNL_AddIOReq ========
+ *  ======== bridge_chnl_add_io_req ========
  *      Enqueue an I/O request for data transfer on a channel to the DSP.
  *      The direction (mode) is specified in the channel object. Note the DSP
  *      address is specified for channels opened in direct I/O mode.
  */
-DSP_STATUS WMD_CHNL_AddIOReq(struct CHNL_OBJECT *hChnl, void *pHostBuf,
-			    u32 cBytes, u32 cBufSize,
-			    OPTIONAL u32 dwDspAddr, u32 dwArg)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
-	struct CHNL_IRP *pChirp = NULL;
-	u32 dwState;
-	bool fIsEOS;
-	struct CHNL_MGR *pChnlMgr = pChnl->pChnlMgr;
-	u8 *pHostSysBuf = NULL;
-	bool fSchedDPC = false;
-	u16 wMbVal = 0;
-
-	DBG_Trace(DBG_ENTER,
-		  "> WMD_CHNL_AddIOReq pChnl %p CHNL_IsOutput %x uChnlType "
-		  "%x Id %d\n", pChnl, CHNL_IsOutput(pChnl->uMode),
-		  pChnl->uChnlType, pChnl->uId);
+dsp_status bridge_chnl_add_io_req(struct chnl_object *chnl_obj, void *pHostBuf,
+			       u32 byte_size, u32 buf_size,
+			       OPTIONAL u32 dw_dsp_addr, u32 dw_arg)
+{
+	dsp_status status = DSP_SOK;
+	struct chnl_object *pchnl = (struct chnl_object *)chnl_obj;
+	struct chnl_irp *chnl_packet_obj = NULL;
+	struct wmd_dev_context *dev_ctxt;
+	struct dev_object *dev_obj;
+	u32 dw_state;
+	bool is_eos;
+	struct chnl_mgr *chnl_mgr_obj = pchnl->chnl_mgr_obj;
+	u8 *host_sys_buf = NULL;
+	bool sched_dpc = false;
+	u16 mb_val = 0;
+
+	is_eos = (byte_size == 0);
+
+	/* Validate args */
+	if (!pHostBuf) {
+		status = DSP_EPOINTER;
+	} else if (!MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE)) {
+		status = DSP_EHANDLE;
+	} else if (is_eos && CHNL_IS_INPUT(pchnl->chnl_mode)) {
+		status = CHNL_E_NOEOS;
+	} else {
+		/*
+		 * Check the channel state: only queue chirp if channel state
+		 * allows it.
+		 */
+		dw_state = pchnl->dw_state;
+		if (dw_state != CHNL_STATEREADY) {
+			if (dw_state & CHNL_STATECANCEL)
+				status = CHNL_E_CANCELLED;
+			else if ((dw_state & CHNL_STATEEOS) &&
+				 CHNL_IS_OUTPUT(pchnl->chnl_mode))
+				status = CHNL_E_EOS;
+			else
+				/* No other possible states left */
+				DBC_ASSERT(0);
+		}
+	}
 
-	fIsEOS = (cBytes == 0) ? true : false;
+	dev_obj = dev_get_first();
+	dev_get_wmd_context(dev_obj, &dev_ctxt);
+	if (!dev_ctxt)
+		status = DSP_EHANDLE;
 
-	if (pChnl->uChnlType == CHNL_PCPY && pChnl->uId > 1 && pHostBuf) {
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	if (pchnl->chnl_type == CHNL_PCPY && pchnl->chnl_id > 1 && pHostBuf) {
 		if (!(pHostBuf < (void *)USERMODE_ADDR)) {
-			pHostSysBuf = pHostBuf;
+			host_sys_buf = pHostBuf;
 			goto func_cont;
 		}
 		/* if addr in user mode, then copy to kernel space */
-		pHostSysBuf = MEM_Alloc(cBufSize, MEM_NONPAGED);
-		if (pHostSysBuf == NULL) {
+		host_sys_buf = mem_alloc(buf_size, MEM_NONPAGED);
+		if (host_sys_buf == NULL) {
 			status = DSP_EMEMORY;
-			DBG_Trace(DBG_LEVEL7,
-				 "No memory to allocate kernel buffer\n");
-			goto func_cont;
+			goto func_end;
 		}
-		if (CHNL_IsOutput(pChnl->uMode)) {
-			status = copy_from_user(pHostSysBuf, pHostBuf,
-						cBufSize);
+		if (CHNL_IS_OUTPUT(pchnl->chnl_mode)) {
+			status = copy_from_user(host_sys_buf, pHostBuf,
+						buf_size);
 			if (status) {
-				DBG_Trace(DBG_LEVEL7,
-					 "Error copying user buffer to "
-					 "kernel, %d bytes remaining.\n",
-					 status);
-				MEM_Free(pHostSysBuf);
-				pHostSysBuf = NULL;
+				kfree(host_sys_buf);
+				host_sys_buf = NULL;
 				status = DSP_EPOINTER;
+				goto func_end;
 			}
 		}
 	}
 func_cont:
-	/* Validate args:  */
-	if (pHostBuf == NULL) {
-		status = DSP_EPOINTER;
-	} else if (!MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
-		status = DSP_EHANDLE;
-	} else if (fIsEOS && CHNL_IsInput(pChnl->uMode)) {
-		status = CHNL_E_NOEOS;
-	} else {
-		/* Check the channel state: only queue chirp if channel state
-		 * allows */
-		dwState = pChnl->dwState;
-		if (dwState != CHNL_STATEREADY) {
-			if (dwState & CHNL_STATECANCEL) {
-				status = CHNL_E_CANCELLED;
-			} else if ((dwState & CHNL_STATEEOS)
-				   && CHNL_IsOutput(pChnl->uMode)) {
-				status = CHNL_E_EOS;
-			} else {
-				/* No other possible states left: */
-				DBC_Assert(0);
-			}
-		}
-	}
 	/* Mailbox IRQ is disabled to avoid race condition with DMA/ZCPY
 	 * channels. DPCCS is held to avoid race conditions with PCPY channels.
-	 * If DPC is scheduled in process context (IO_Schedule) and any
+	 * If DPC is scheduled in process context (iosm_schedule) and any
 	 * non-mailbox interrupt occurs, that DPC will run and break CS. Hence
-	 * we disable ALL DPCs. We will try to disable ONLY IO DPC later.  */
-	SYNC_EnterCS(pChnlMgr->hCSObj);
-	disable_irq(MAILBOX_IRQ);
-	if (pChnl->uChnlType == CHNL_PCPY) {
+	 * we disable ALL DPCs. We will try to disable ONLY IO DPC later. */
+	sync_enter_cs(chnl_mgr_obj->hcs_obj);
+	omap_mbox_disable_irq(dev_ctxt->mbox, IRQ_RX);
+	if (pchnl->chnl_type == CHNL_PCPY) {
 		/* This is a processor-copy channel. */
-		if (DSP_SUCCEEDED(status) && CHNL_IsOutput(pChnl->uMode)) {
+		if (DSP_SUCCEEDED(status) && CHNL_IS_OUTPUT(pchnl->chnl_mode)) {
 			/* Check buffer size on output channels for fit. */
-			if (cBytes > IO_BufSize(pChnl->pChnlMgr->hIOMgr))
+			if (byte_size >
+			    io_buf_size(pchnl->chnl_mgr_obj->hio_mgr))
 				status = CHNL_E_BUFSIZE;
 
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Get a free chirp: */
-		pChirp = (struct CHNL_IRP *)LST_GetHead(pChnl->pFreeList);
-		if (pChirp == NULL)
+		chnl_packet_obj =
+		    (struct chnl_irp *)lst_get_head(pchnl->free_packets_list);
+		if (chnl_packet_obj == NULL)
 			status = CHNL_E_NOIORPS;
 
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Enqueue the chirp on the chnl's IORequest queue: */
-		pChirp->pHostUserBuf = pChirp->pHostSysBuf = pHostBuf;
-		if (pChnl->uChnlType == CHNL_PCPY && pChnl->uId > 1)
-			pChirp->pHostSysBuf = pHostSysBuf;
-
-		if (DSP_SUCCEEDED(status)) {
-			/* Note: for dma chans dwDspAddr contains dsp address
-			 * of SM buffer.*/
-			DBC_Assert(pChnlMgr->uWordSize != 0);
-			/* DSP address */
-			pChirp->uDspAddr = dwDspAddr / pChnlMgr->uWordSize;
-			pChirp->cBytes = cBytes;
-			pChirp->cBufSize = cBufSize;
-			/* Only valid for output channel */
-			pChirp->dwArg = dwArg;
-			pChirp->status = (fIsEOS ? CHNL_IOCSTATEOS :
-					 CHNL_IOCSTATCOMPLETE);
-			LST_PutTail(pChnl->pIORequests, (struct LST_ELEM *)
-				   pChirp);
-			pChnl->cIOReqs++;
-			DBC_Assert(pChnl->cIOReqs <= pChnl->cChirps);
-			/* If end of stream, update the channel state to prevent
-			 * more IOR's: */
-			if (fIsEOS)
-				pChnl->dwState |= CHNL_STATEEOS;
+		chnl_packet_obj->host_user_buf = chnl_packet_obj->host_sys_buf =
+		    pHostBuf;
+		if (pchnl->chnl_type == CHNL_PCPY && pchnl->chnl_id > 1)
+			chnl_packet_obj->host_sys_buf = host_sys_buf;
+
+		/*
+		 * Note: for dma chans dw_dsp_addr contains dsp address
+		 * of SM buffer.
+		 */
+		DBC_ASSERT(chnl_mgr_obj->word_size != 0);
+		/* DSP address */
+		chnl_packet_obj->dsp_tx_addr =
+		    dw_dsp_addr / chnl_mgr_obj->word_size;
+		chnl_packet_obj->byte_size = byte_size;
+		chnl_packet_obj->buf_size = buf_size;
+		/* Only valid for output channel */
+		chnl_packet_obj->dw_arg = dw_arg;
+		chnl_packet_obj->status = (is_eos ? CHNL_IOCSTATEOS :
+					   CHNL_IOCSTATCOMPLETE);
+		lst_put_tail(pchnl->pio_requests,
+			     (struct list_head *)chnl_packet_obj);
+		pchnl->cio_reqs++;
+		DBC_ASSERT(pchnl->cio_reqs <= pchnl->chnl_packets);
+		/*
+		 * If end of stream, update the channel state to prevent
+		 * more IOR's.
+		 */
+		if (is_eos)
+			pchnl->dw_state |= CHNL_STATEEOS;
+
+		/* Legacy DSM Processor-Copy */
+		DBC_ASSERT(pchnl->chnl_type == CHNL_PCPY);
+		/* Request IO from the DSP */
+		io_request_chnl(chnl_mgr_obj->hio_mgr, pchnl,
+				(CHNL_IS_INPUT(pchnl->chnl_mode) ? IO_INPUT :
+				 IO_OUTPUT), &mb_val);
+		sched_dpc = true;
+
+	}
+	omap_mbox_enable_irq(dev_ctxt->mbox, IRQ_RX);
+	sync_leave_cs(chnl_mgr_obj->hcs_obj);
+	if (mb_val != 0)
+		io_intr_dsp2(chnl_mgr_obj->hio_mgr, mb_val);
+
+	/* Schedule a DPC, to do the actual data transfer */
+	if (sched_dpc)
+		iosm_schedule(chnl_mgr_obj->hio_mgr);
 
-			{
-				/* Legacy DSM Processor-Copy */
-				DBC_Assert(pChnl->uChnlType == CHNL_PCPY);
-				/* Request IO from the DSP */
-				IO_RequestChnl(pChnlMgr->hIOMgr, pChnl,
-					(CHNL_IsInput(pChnl->uMode) ?
-					IO_INPUT : IO_OUTPUT), &wMbVal);
-				fSchedDPC = true;
-			}
-		}
-	}
-	enable_irq(MAILBOX_IRQ);
-	SYNC_LeaveCS(pChnlMgr->hCSObj);
-	if (wMbVal != 0)
-		IO_IntrDSP2(pChnlMgr->hIOMgr, wMbVal);
-
-	if (fSchedDPC == true) {
-		/* Schedule a DPC, to do the actual data transfer: */
-		IO_Schedule(pChnlMgr->hIOMgr);
-	}
-	DBG_Trace(DBG_ENTER, "< WMD_CHNL_AddIOReq pChnl %p\n", pChnl);
+func_end:
 	return status;
 }
 
 /*
- *  ======== WMD_CHNL_CancelIO ========
+ *  ======== bridge_chnl_cancel_io ========
  *      Return all I/O requests to the client which have not yet been
  *      transferred.  The channel's I/O completion object is
  *      signalled, and all the I/O requests are queued as IOC's, with the
  *      status field set to CHNL_IOCSTATCANCEL.
  *      This call is typically used in abort situations, and is a prelude to
- *      CHNL_Close();
+ *      chnl_close();
  */
-DSP_STATUS WMD_CHNL_CancelIO(struct CHNL_OBJECT *hChnl)
+dsp_status bridge_chnl_cancel_io(struct chnl_object *chnl_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
-	u32 iChnl = -1;
-	CHNL_MODE uMode;
-	struct CHNL_IRP *pChirp;
-	struct CHNL_MGR *pChnlMgr = NULL;
+	dsp_status status = DSP_SOK;
+	struct chnl_object *pchnl = (struct chnl_object *)chnl_obj;
+	u32 chnl_id = -1;
+	short int chnl_mode;
+	struct chnl_irp *chnl_packet_obj;
+	struct chnl_mgr *chnl_mgr_obj = NULL;
 
 	/* Check args: */
-	if (MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
-		iChnl = pChnl->uId;
-		uMode = pChnl->uMode;
-		pChnlMgr = pChnl->pChnlMgr;
+	if (MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE) && pchnl->chnl_mgr_obj) {
+		chnl_id = pchnl->chnl_id;
+		chnl_mode = pchnl->chnl_mode;
+		chnl_mgr_obj = pchnl->chnl_mgr_obj;
 	} else {
 		status = DSP_EHANDLE;
 	}
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	 /*  Mark this channel as cancelled, to prevent further IORequests or
-	 *  IORequests or dispatching.  */
-	SYNC_EnterCS(pChnlMgr->hCSObj);
-	pChnl->dwState |= CHNL_STATECANCEL;
-	if (LST_IsEmpty(pChnl->pIORequests))
+	/*  Mark this channel as cancelled, to prevent further IORequests or
+	 *  IORequests or dispatching. */
+	sync_enter_cs(chnl_mgr_obj->hcs_obj);
+	pchnl->dw_state |= CHNL_STATECANCEL;
+	if (LST_IS_EMPTY(pchnl->pio_requests))
 		goto func_cont;
 
-	if (pChnl->uChnlType == CHNL_PCPY) {
+	if (pchnl->chnl_type == CHNL_PCPY) {
 		/* Indicate we have no more buffers available for transfer: */
-		if (CHNL_IsInput(pChnl->uMode)) {
-			IO_CancelChnl(pChnlMgr->hIOMgr, iChnl);
+		if (CHNL_IS_INPUT(pchnl->chnl_mode)) {
+			io_cancel_chnl(chnl_mgr_obj->hio_mgr, chnl_id);
 		} else {
 			/* Record that we no longer have output buffers
 			 * available: */
-			pChnlMgr->dwOutputMask &= ~(1 << iChnl);
+			chnl_mgr_obj->dw_output_mask &= ~(1 << chnl_id);
 		}
 	}
-	/* Move all IOR's to IOC queue:  */
-	while (!LST_IsEmpty(pChnl->pIORequests)) {
-		pChirp = (struct CHNL_IRP *)LST_GetHead(pChnl->pIORequests);
-		if (pChirp) {
-			pChirp->cBytes = 0;
-			pChirp->status |= CHNL_IOCSTATCANCEL;
-			LST_PutTail(pChnl->pIOCompletions,
-				   (struct LST_ELEM *)pChirp);
-			pChnl->cIOCs++;
-			pChnl->cIOReqs--;
-			DBC_Assert(pChnl->cIOReqs >= 0);
+	/* Move all IOR's to IOC queue: */
+	while (!LST_IS_EMPTY(pchnl->pio_requests)) {
+		chnl_packet_obj =
+		    (struct chnl_irp *)lst_get_head(pchnl->pio_requests);
+		if (chnl_packet_obj) {
+			chnl_packet_obj->byte_size = 0;
+			chnl_packet_obj->status |= CHNL_IOCSTATCANCEL;
+			lst_put_tail(pchnl->pio_completions,
+				     (struct list_head *)chnl_packet_obj);
+			pchnl->cio_cs++;
+			pchnl->cio_reqs--;
+			DBC_ASSERT(pchnl->cio_reqs >= 0);
 		}
 	}
 func_cont:
-		SYNC_LeaveCS(pChnlMgr->hCSObj);
+	sync_leave_cs(chnl_mgr_obj->hcs_obj);
 func_end:
 	return status;
 }
 
 /*
- *  ======== WMD_CHNL_Close ========
+ *  ======== bridge_chnl_close ========
  *  Purpose:
  *      Ensures all pending I/O on this channel is cancelled, discards all
  *      queued I/O completion notifications, then frees the resources allocated
  *      for this channel, and makes the corresponding logical channel id
  *      available for subsequent use.
  */
-DSP_STATUS WMD_CHNL_Close(struct CHNL_OBJECT *hChnl)
+dsp_status bridge_chnl_close(struct chnl_object *chnl_obj)
 {
-	DSP_STATUS status;
-	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
+	dsp_status status;
+	struct chnl_object *pchnl = (struct chnl_object *)chnl_obj;
 
 	/* Check args: */
-	if (!MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
+	if (!MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE)) {
 		status = DSP_EHANDLE;
 		goto func_cont;
 	}
 	{
 		/* Cancel IO: this ensures no further IO requests or
-		 * notifications.*/
-		status = WMD_CHNL_CancelIO(hChnl);
+		 * notifications. */
+		status = bridge_chnl_cancel_io(chnl_obj);
 	}
 func_cont:
 	if (DSP_SUCCEEDED(status)) {
 		/* Assert I/O on this channel is now cancelled: Protects
-		 * from IO_DPC. */
-		DBC_Assert((pChnl->dwState & CHNL_STATECANCEL));
+		 * from io_dpc. */
+		DBC_ASSERT((pchnl->dw_state & CHNL_STATECANCEL));
 		/* Invalidate channel object: Protects from
 		 * CHNL_GetIOCompletion(). */
-		pChnl->dwSignature = 0x0000;
+		pchnl->dw_signature = 0x0000;
 		/* Free the slot in the channel manager: */
-		pChnl->pChnlMgr->apChannel[pChnl->uId] = NULL;
-		pChnl->pChnlMgr->cOpenChannels -= 1;
-		if (pChnl->hNtfy) {
-			NTFY_Delete(pChnl->hNtfy);
-			pChnl->hNtfy = NULL;
+		pchnl->chnl_mgr_obj->ap_channel[pchnl->chnl_id] = NULL;
+		pchnl->chnl_mgr_obj->open_channels -= 1;
+		if (pchnl->ntfy_obj) {
+			ntfy_delete(pchnl->ntfy_obj);
+			pchnl->ntfy_obj = NULL;
 		}
-		/* Reset channel event: (NOTE: hUserEvent freed in user
+		/* Reset channel event: (NOTE: user_event freed in user
 		 * context.). */
-		if (pChnl->hSyncEvent) {
-			SYNC_ResetEvent(pChnl->hSyncEvent);
-			SYNC_CloseEvent(pChnl->hSyncEvent);
-			pChnl->hSyncEvent = NULL;
-		}
-		/* Free I/O request and I/O completion queues:  */
-		if (pChnl->pIOCompletions) {
-			FreeChirpList(pChnl->pIOCompletions);
-			pChnl->pIOCompletions = NULL;
-			pChnl->cIOCs = 0;
-		}
-		if (pChnl->pIORequests) {
-			FreeChirpList(pChnl->pIORequests);
-			pChnl->pIORequests = NULL;
-			pChnl->cIOReqs = 0;
-		}
-		if (pChnl->pFreeList) {
-			FreeChirpList(pChnl->pFreeList);
-			pChnl->pFreeList = NULL;
+		if (pchnl->sync_event) {
+			sync_reset_event(pchnl->sync_event);
+			sync_close_event(pchnl->sync_event);
+			pchnl->sync_event = NULL;
+		}
+		/* Free I/O request and I/O completion queues: */
+		if (pchnl->pio_completions) {
+			free_chirp_list(pchnl->pio_completions);
+			pchnl->pio_completions = NULL;
+			pchnl->cio_cs = 0;
+		}
+		if (pchnl->pio_requests) {
+			free_chirp_list(pchnl->pio_requests);
+			pchnl->pio_requests = NULL;
+			pchnl->cio_reqs = 0;
+		}
+		if (pchnl->free_packets_list) {
+			free_chirp_list(pchnl->free_packets_list);
+			pchnl->free_packets_list = NULL;
 		}
 		/* Release channel object. */
-		MEM_FreeObject(pChnl);
-		pChnl = NULL;
+		MEM_FREE_OBJECT(pchnl);
+		pchnl = NULL;
 	}
-	DBC_Ensure(DSP_FAILED(status) ||
-		  !MEM_IsValidHandle(pChnl, CHNL_SIGNATURE));
+	DBC_ENSURE(DSP_FAILED(status) ||
+		   !MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE));
 	return status;
 }
 
 /*
- *  ======== WMD_CHNL_Create ========
+ *  ======== bridge_chnl_create ========
  *      Create a channel manager object, responsible for opening new channels
  *      and closing old ones for a given board.
  */
-DSP_STATUS WMD_CHNL_Create(OUT struct CHNL_MGR **phChnlMgr,
-			  struct DEV_OBJECT *hDevObject,
-			  IN CONST struct CHNL_MGRATTRS *pMgrAttrs)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_MGR *pChnlMgr = NULL;
-	s32 cChannels;
-#ifdef DEBUG
-	struct CHNL_MGR *hChnlMgr;
-#endif
-	/* Check DBC requirements:  */
-	DBC_Require(phChnlMgr != NULL);
-	DBC_Require(pMgrAttrs != NULL);
-	DBC_Require(pMgrAttrs->cChannels > 0);
-	DBC_Require(pMgrAttrs->cChannels <= CHNL_MAXCHANNELS);
-	DBC_Require(pMgrAttrs->uWordSize != 0);
-#ifdef DEBUG
-	/* This for the purposes of DBC_Require: */
-	status = DEV_GetChnlMgr(hDevObject, &hChnlMgr);
-	DBC_Require(status != DSP_EHANDLE);
-	DBC_Require(hChnlMgr == NULL);
-#endif
-	if (DSP_SUCCEEDED(status)) {
-		/* Allocate channel manager object: */
-		MEM_AllocObject(pChnlMgr, struct CHNL_MGR, CHNL_MGRSIGNATURE);
-		if (pChnlMgr) {
-			/* The cChannels attr must equal the # of supported
-			 * chnls for each transport(# chnls for PCPY = DDMA =
-			 * ZCPY): i.e. pMgrAttrs->cChannels = CHNL_MAXCHANNELS =
-			 * DDMA_MAXDDMACHNLS = DDMA_MAXZCPYCHNLS.  */
-			DBC_Assert(pMgrAttrs->cChannels == CHNL_MAXCHANNELS);
-			cChannels = (CHNL_MAXCHANNELS + (CHNL_MAXCHANNELS *
-				    CHNL_PCPY));
-			/* Create array of channels: */
-			pChnlMgr->apChannel = MEM_Calloc(
-						sizeof(struct CHNL_OBJECT *) *
-						cChannels, MEM_NONPAGED);
-			if (pChnlMgr->apChannel) {
-				/* Initialize CHNL_MGR object: */
-				/* Shared memory driver. */
-				pChnlMgr->dwType = CHNL_TYPESM;
-				pChnlMgr->uWordSize = pMgrAttrs->uWordSize;
-				/* total # chnls supported */
-				pChnlMgr->cChannels = cChannels;
-				pChnlMgr->cOpenChannels = 0;
-				pChnlMgr->dwOutputMask = 0;
-				pChnlMgr->dwLastOutput = 0;
-				pChnlMgr->hDevObject = hDevObject;
-				if (DSP_SUCCEEDED(status)) {
-					status = SYNC_InitializeDPCCS
-						(&pChnlMgr->hCSObj);
-				}
-			} else {
-				status = DSP_EMEMORY;
-			}
+dsp_status bridge_chnl_create(OUT struct chnl_mgr **phChnlMgr,
+			      struct dev_object *hdev_obj,
+			      IN CONST struct chnl_mgrattrs *pMgrAttrs)
+{
+	dsp_status status = DSP_SOK;
+	struct chnl_mgr *chnl_mgr_obj = NULL;
+	s32 max_channels;
+
+	/* Check DBC requirements: */
+	DBC_REQUIRE(phChnlMgr != NULL);
+	DBC_REQUIRE(pMgrAttrs != NULL);
+	DBC_REQUIRE(pMgrAttrs->max_channels > 0);
+	DBC_REQUIRE(pMgrAttrs->max_channels <= CHNL_MAXCHANNELS);
+	DBC_REQUIRE(pMgrAttrs->word_size != 0);
+
+	/* Allocate channel manager object */
+	MEM_ALLOC_OBJECT(chnl_mgr_obj, struct chnl_mgr, CHNL_MGRSIGNATURE);
+	if (chnl_mgr_obj) {
+		/*
+		 * The max_channels attr must equal the # of supported chnls for
+		 * each transport(# chnls for PCPY = DDMA = ZCPY): i.e.
+		 *      pMgrAttrs->max_channels = CHNL_MAXCHANNELS =
+		 *                       DDMA_MAXDDMACHNLS = DDMA_MAXZCPYCHNLS.
+		 */
+		DBC_ASSERT(pMgrAttrs->max_channels == CHNL_MAXCHANNELS);
+		max_channels = CHNL_MAXCHANNELS + CHNL_MAXCHANNELS * CHNL_PCPY;
+		/* Create array of channels */
+		chnl_mgr_obj->ap_channel =
+		    mem_calloc(sizeof(struct chnl_object *) * max_channels,
+			       MEM_NONPAGED);
+		if (chnl_mgr_obj->ap_channel) {
+			/* Initialize chnl_mgr object */
+			chnl_mgr_obj->dw_type = CHNL_TYPESM;
+			chnl_mgr_obj->word_size = pMgrAttrs->word_size;
+			/* Total # chnls supported */
+			chnl_mgr_obj->max_channels = max_channels;
+			chnl_mgr_obj->open_channels = 0;
+			chnl_mgr_obj->dw_output_mask = 0;
+			chnl_mgr_obj->dw_last_output = 0;
+			chnl_mgr_obj->hdev_obj = hdev_obj;
+			if (DSP_SUCCEEDED(status))
+				status =
+				    sync_initialize_dpccs
+				    (&chnl_mgr_obj->hcs_obj);
 		} else {
 			status = DSP_EMEMORY;
 		}
+	} else {
+		status = DSP_EMEMORY;
 	}
+
 	if (DSP_FAILED(status)) {
-		WMD_CHNL_Destroy(pChnlMgr);
+		bridge_chnl_destroy(chnl_mgr_obj);
 		*phChnlMgr = NULL;
 	} else {
 		/* Return channel manager object to caller... */
-		*phChnlMgr = pChnlMgr;
+		*phChnlMgr = chnl_mgr_obj;
 	}
 	return status;
 }
 
 /*
- *  ======== WMD_CHNL_Destroy ========
+ *  ======== bridge_chnl_destroy ========
  *  Purpose:
  *      Close all open channels, and destroy the channel manager.
  */
-DSP_STATUS WMD_CHNL_Destroy(struct CHNL_MGR *hChnlMgr)
+dsp_status bridge_chnl_destroy(struct chnl_mgr *hchnl_mgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_MGR *pChnlMgr = hChnlMgr;
-	u32 iChnl;
+	dsp_status status = DSP_SOK;
+	struct chnl_mgr *chnl_mgr_obj = hchnl_mgr;
+	u32 chnl_id;
 
-	if (MEM_IsValidHandle(hChnlMgr, CHNL_MGRSIGNATURE)) {
+	if (MEM_IS_VALID_HANDLE(hchnl_mgr, CHNL_MGRSIGNATURE)) {
 		/* Close all open channels: */
-		for (iChnl = 0; iChnl < pChnlMgr->cChannels; iChnl++) {
-			if (DSP_SUCCEEDED
-			    (WMD_CHNL_Close(pChnlMgr->apChannel[iChnl]))) {
-				DBC_Assert(pChnlMgr->apChannel[iChnl] == NULL);
-			}
+		for (chnl_id = 0; chnl_id < chnl_mgr_obj->max_channels;
+		     chnl_id++) {
+			status =
+			    bridge_chnl_close(chnl_mgr_obj->ap_channel
+					      [chnl_id]);
+			if (DSP_FAILED(status))
+				dev_dbg(bridge, "%s: Error status 0x%x\n",
+					__func__, status);
 		}
 		/* release critical section */
-		if (pChnlMgr->hCSObj)
-			SYNC_DeleteCS(pChnlMgr->hCSObj);
+		if (chnl_mgr_obj->hcs_obj)
+			sync_delete_cs(chnl_mgr_obj->hcs_obj);
 
 		/* Free channel manager object: */
-		if (pChnlMgr->apChannel)
-			MEM_Free(pChnlMgr->apChannel);
+		kfree(chnl_mgr_obj->ap_channel);
 
-		/* Set hChnlMgr to NULL in device object. */
-		DEV_SetChnlMgr(pChnlMgr->hDevObject, NULL);
+		/* Set hchnl_mgr to NULL in device object. */
+		dev_set_chnl_mgr(chnl_mgr_obj->hdev_obj, NULL);
 		/* Free this Chnl Mgr object: */
-		MEM_FreeObject(hChnlMgr);
+		MEM_FREE_OBJECT(hchnl_mgr);
 	} else {
 		status = DSP_EHANDLE;
 	}
@@ -554,25 +484,25 @@
 }
 
 /*
- *  ======== WMD_CHNL_FlushIO ========
+ *  ======== bridge_chnl_flush_io ========
  *  purpose:
  *      Flushes all the outstanding data requests on a channel.
  */
-DSP_STATUS WMD_CHNL_FlushIO(struct CHNL_OBJECT *hChnl, u32 dwTimeOut)
+dsp_status bridge_chnl_flush_io(struct chnl_object *chnl_obj, u32 dwTimeOut)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
-	CHNL_MODE uMode = -1;
-	struct CHNL_MGR *pChnlMgr;
-	struct CHNL_IOC chnlIOC;
-	/* Check args:  */
-	if (MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
+	dsp_status status = DSP_SOK;
+	struct chnl_object *pchnl = (struct chnl_object *)chnl_obj;
+	short int chnl_mode = -1;
+	struct chnl_mgr *chnl_mgr_obj;
+	struct chnl_ioc chnl_ioc_obj;
+	/* Check args: */
+	if (MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE)) {
 		if ((dwTimeOut == CHNL_IOCNOWAIT)
-		    && CHNL_IsOutput(pChnl->uMode)) {
+		    && CHNL_IS_OUTPUT(pchnl->chnl_mode)) {
 			status = DSP_EINVALIDARG;
 		} else {
-			uMode = pChnl->uMode;
-			pChnlMgr = pChnl->pChnlMgr;
+			chnl_mode = pchnl->chnl_mode;
+			chnl_mgr_obj = pchnl->chnl_mgr_obj;
 		}
 	} else {
 		status = DSP_EHANDLE;
@@ -580,54 +510,55 @@
 	if (DSP_SUCCEEDED(status)) {
 		/* Note: Currently, if another thread continues to add IO
 		 * requests to this channel, this function will continue to
-		 * flush all such queued IO requests.  */
-		if (CHNL_IsOutput(uMode) && (pChnl->uChnlType == CHNL_PCPY)) {
+		 * flush all such queued IO requests. */
+		if (CHNL_IS_OUTPUT(chnl_mode)
+		    && (pchnl->chnl_type == CHNL_PCPY)) {
 			/* Wait for IO completions, up to the specified
 			 * timeout: */
-			while (!LST_IsEmpty(pChnl->pIORequests) &&
-			      DSP_SUCCEEDED(status)) {
-				status = WMD_CHNL_GetIOC(hChnl, dwTimeOut,
-							 &chnlIOC);
+			while (!LST_IS_EMPTY(pchnl->pio_requests) &&
+			       DSP_SUCCEEDED(status)) {
+				status = bridge_chnl_get_ioc(chnl_obj, dwTimeOut,
+							  &chnl_ioc_obj);
 				if (DSP_FAILED(status))
 					continue;
 
-				if (chnlIOC.status & CHNL_IOCSTATTIMEOUT)
+				if (chnl_ioc_obj.status & CHNL_IOCSTATTIMEOUT)
 					status = CHNL_E_WAITTIMEOUT;
 
 			}
 		} else {
-			status = WMD_CHNL_CancelIO(hChnl);
+			status = bridge_chnl_cancel_io(chnl_obj);
 			/* Now, leave the channel in the ready state: */
-			pChnl->dwState &= ~CHNL_STATECANCEL;
+			pchnl->dw_state &= ~CHNL_STATECANCEL;
 		}
 	}
-	DBC_Ensure(DSP_FAILED(status) || LST_IsEmpty(pChnl->pIORequests));
+	DBC_ENSURE(DSP_FAILED(status) || LST_IS_EMPTY(pchnl->pio_requests));
 	return status;
 }
 
 /*
- *  ======== WMD_CHNL_GetInfo ========
+ *  ======== bridge_chnl_get_info ========
  *  Purpose:
  *      Retrieve information related to a channel.
  */
-DSP_STATUS WMD_CHNL_GetInfo(struct CHNL_OBJECT *hChnl,
-			   OUT struct CHNL_INFO *pInfo)
+dsp_status bridge_chnl_get_info(struct chnl_object *chnl_obj,
+			     OUT struct chnl_info *pInfo)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
+	dsp_status status = DSP_SOK;
+	struct chnl_object *pchnl = (struct chnl_object *)chnl_obj;
 	if (pInfo != NULL) {
-		if (MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
-			/* Return the requested information:  */
-			pInfo->hChnlMgr = pChnl->pChnlMgr;
-			pInfo->hEvent = pChnl->hUserEvent;
-			pInfo->dwID = pChnl->uId;
-			pInfo->dwMode = pChnl->uMode;
-			pInfo->cPosition = pChnl->cBytesMoved;
-			pInfo->hProcess = pChnl->hProcess;
-			pInfo->hSyncEvent = pChnl->hSyncEvent;
-			pInfo->cIOCs = pChnl->cIOCs;
-			pInfo->cIOReqs = pChnl->cIOReqs;
-			pInfo->dwState = pChnl->dwState;
+		if (MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE)) {
+			/* Return the requested information: */
+			pInfo->hchnl_mgr = pchnl->chnl_mgr_obj;
+			pInfo->event_obj = pchnl->user_event;
+			pInfo->cnhl_id = pchnl->chnl_id;
+			pInfo->dw_mode = pchnl->chnl_mode;
+			pInfo->bytes_tx = pchnl->bytes_moved;
+			pInfo->process = pchnl->process;
+			pInfo->sync_event = pchnl->sync_event;
+			pInfo->cio_cs = pchnl->cio_cs;
+			pInfo->cio_reqs = pchnl->cio_reqs;
+			pInfo->dw_state = pchnl->dw_state;
 		} else {
 			status = DSP_EHANDLE;
 		}
@@ -638,185 +569,175 @@
 }
 
 /*
- *  ======== WMD_CHNL_GetIOC ========
+ *  ======== bridge_chnl_get_ioc ========
  *      Optionally wait for I/O completion on a channel.  Dequeue an I/O
  *      completion record, which contains information about the completed
  *      I/O request.
  *      Note: Ensures Channel Invariant (see notes above).
  */
-DSP_STATUS WMD_CHNL_GetIOC(struct CHNL_OBJECT *hChnl, u32 dwTimeOut,
-			  OUT struct CHNL_IOC *pIOC)
+dsp_status bridge_chnl_get_ioc(struct chnl_object *chnl_obj, u32 dwTimeOut,
+			    OUT struct chnl_ioc *pIOC)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
-	struct CHNL_IRP *pChirp;
-	DSP_STATUS statSync;
-	bool fDequeueIOC = true;
-	struct CHNL_IOC ioc = { NULL, 0, 0, 0, 0 };
-	u8 *pHostSysBuf = NULL;
-
-	DBG_Trace(DBG_ENTER, "> WMD_CHNL_GetIOC pChnl %p CHNL_IsOutput %x "
-		 "uChnlType %x\n", pChnl, CHNL_IsOutput(pChnl->uMode),
-		 pChnl->uChnlType);
+	dsp_status status = DSP_SOK;
+	struct chnl_object *pchnl = (struct chnl_object *)chnl_obj;
+	struct chnl_irp *chnl_packet_obj;
+	dsp_status stat_sync;
+	bool dequeue_ioc = true;
+	struct chnl_ioc ioc = { NULL, 0, 0, 0, 0 };
+	u8 *host_sys_buf = NULL;
+	struct wmd_dev_context *dev_ctxt;
+	struct dev_object *dev_obj;
+
 	/* Check args: */
 	if (pIOC == NULL) {
 		status = DSP_EPOINTER;
-	} else if (!MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
+	} else if (!MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE)) {
 		status = DSP_EHANDLE;
 	} else if (dwTimeOut == CHNL_IOCNOWAIT) {
-		if (LST_IsEmpty(pChnl->pIOCompletions))
+		if (LST_IS_EMPTY(pchnl->pio_completions))
 			status = CHNL_E_NOIOC;
 
 	}
+
+	dev_obj = dev_get_first();
+	dev_get_wmd_context(dev_obj, &dev_ctxt);
+	if (!dev_ctxt)
+		status = DSP_EHANDLE;
+
 	if (DSP_FAILED(status))
 		goto func_end;
 
 	ioc.status = CHNL_IOCSTATCOMPLETE;
-	if (dwTimeOut != CHNL_IOCNOWAIT && LST_IsEmpty(pChnl->pIOCompletions)) {
+	if (dwTimeOut !=
+	    CHNL_IOCNOWAIT && LST_IS_EMPTY(pchnl->pio_completions)) {
 		if (dwTimeOut == CHNL_IOCINFINITE)
 			dwTimeOut = SYNC_INFINITE;
 
-		statSync = SYNC_WaitOnEvent(pChnl->hSyncEvent, dwTimeOut);
-		if (statSync == DSP_ETIMEOUT) {
+		stat_sync = sync_wait_on_event(pchnl->sync_event, dwTimeOut);
+		if (stat_sync == DSP_ETIMEOUT) {
 			/* No response from DSP */
 			ioc.status |= CHNL_IOCSTATTIMEOUT;
-			fDequeueIOC = false;
-		} else if (statSync == DSP_EFAIL) {
+			dequeue_ioc = false;
+		} else if (stat_sync == DSP_EFAIL) {
 			/* This can occur when the user mode thread is
 			 * aborted (^C), or when _VWIN32_WaitSingleObject()
-			 * fails due to unkown causes.  */
+			 * fails due to unkown causes. */
 			/* Even though Wait failed, there may be something in
 			 * the Q: */
-			if (LST_IsEmpty(pChnl->pIOCompletions)) {
+			if (LST_IS_EMPTY(pchnl->pio_completions)) {
 				ioc.status |= CHNL_IOCSTATCANCEL;
-				fDequeueIOC = false;
+				dequeue_ioc = false;
 			}
 		}
 	}
 	/* See comment in AddIOReq */
-	SYNC_EnterCS(pChnl->pChnlMgr->hCSObj);
-	disable_irq(MAILBOX_IRQ);
-	if (fDequeueIOC) {
+	sync_enter_cs(pchnl->chnl_mgr_obj->hcs_obj);
+	omap_mbox_disable_irq(dev_ctxt->mbox, IRQ_RX);
+	if (dequeue_ioc) {
 		/* Dequeue IOC and set pIOC; */
-		DBC_Assert(!LST_IsEmpty(pChnl->pIOCompletions));
-		pChirp = (struct CHNL_IRP *)LST_GetHead(pChnl->pIOCompletions);
+		DBC_ASSERT(!LST_IS_EMPTY(pchnl->pio_completions));
+		chnl_packet_obj =
+		    (struct chnl_irp *)lst_get_head(pchnl->pio_completions);
 		/* Update pIOC from channel state and chirp: */
-		if (pChirp) {
-			pChnl->cIOCs--;
-			/*  If this is a zero-copy channel, then set IOC's pBuf
+		if (chnl_packet_obj) {
+			pchnl->cio_cs--;
+			/*  If this is a zero-copy channel, then set IOC's pbuf
 			 *  to the DSP's address. This DSP address will get
-			 *  translated to user's virtual addr later.  */
+			 *  translated to user's virtual addr later. */
 			{
-				pHostSysBuf = pChirp->pHostSysBuf;
-				ioc.pBuf = pChirp->pHostUserBuf;
+				host_sys_buf = chnl_packet_obj->host_sys_buf;
+				ioc.pbuf = chnl_packet_obj->host_user_buf;
 			}
-			ioc.cBytes = pChirp->cBytes;
-			ioc.cBufSize = pChirp->cBufSize;
-			ioc.dwArg = pChirp->dwArg;
-			ioc.status |= pChirp->status;
+			ioc.byte_size = chnl_packet_obj->byte_size;
+			ioc.buf_size = chnl_packet_obj->buf_size;
+			ioc.dw_arg = chnl_packet_obj->dw_arg;
+			ioc.status |= chnl_packet_obj->status;
 			/* Place the used chirp on the free list: */
-			LST_PutTail(pChnl->pFreeList, (struct LST_ELEM *)
-				   pChirp);
+			lst_put_tail(pchnl->free_packets_list,
+				     (struct list_head *)chnl_packet_obj);
 		} else {
-			ioc.pBuf = NULL;
-			ioc.cBytes = 0;
+			ioc.pbuf = NULL;
+			ioc.byte_size = 0;
 		}
 	} else {
-		ioc.pBuf = NULL;
-		ioc.cBytes = 0;
-		ioc.dwArg = 0;
-		ioc.cBufSize = 0;
+		ioc.pbuf = NULL;
+		ioc.byte_size = 0;
+		ioc.dw_arg = 0;
+		ioc.buf_size = 0;
 	}
 	/* Ensure invariant: If any IOC's are queued for this channel... */
-	if (!LST_IsEmpty(pChnl->pIOCompletions)) {
+	if (!LST_IS_EMPTY(pchnl->pio_completions)) {
 		/*  Since DSPStream_Reclaim() does not take a timeout
 		 *  parameter, we pass the stream's timeout value to
-		 *  WMD_CHNL_GetIOC. We cannot determine whether or not
+		 *  bridge_chnl_get_ioc. We cannot determine whether or not
 		 *  we have waited in User mode. Since the stream's timeout
 		 *  value may be non-zero, we still have to set the event.
 		 *  Therefore, this optimization is taken out.
 		 *
 		 *  if (dwTimeOut == CHNL_IOCNOWAIT) {
 		 *    ... ensure event is set..
-		 *      SYNC_SetEvent(pChnl->hSyncEvent);
+		 *      sync_set_event(pchnl->sync_event);
 		 *  } */
-		SYNC_SetEvent(pChnl->hSyncEvent);
+		sync_set_event(pchnl->sync_event);
 	} else {
 		/* else, if list is empty, ensure event is reset. */
-		SYNC_ResetEvent(pChnl->hSyncEvent);
+		sync_reset_event(pchnl->sync_event);
 	}
-	enable_irq(MAILBOX_IRQ);
-	SYNC_LeaveCS(pChnl->pChnlMgr->hCSObj);
-	if (fDequeueIOC && (pChnl->uChnlType == CHNL_PCPY && pChnl->uId > 1)) {
-		if (!(ioc.pBuf < (void *) USERMODE_ADDR))
+	omap_mbox_enable_irq(dev_ctxt->mbox, IRQ_RX);
+	sync_leave_cs(pchnl->chnl_mgr_obj->hcs_obj);
+	if (dequeue_ioc
+	    && (pchnl->chnl_type == CHNL_PCPY && pchnl->chnl_id > 1)) {
+		if (!(ioc.pbuf < (void *)USERMODE_ADDR))
 			goto func_cont;
 
 		/* If the addr is in user mode, then copy it */
-		if (!pHostSysBuf || !ioc.pBuf) {
+		if (!host_sys_buf || !ioc.pbuf) {
 			status = DSP_EPOINTER;
-			DBG_Trace(DBG_LEVEL7,
-				 "System buffer NULL in IO completion.\n");
 			goto func_cont;
 		}
-		if (!CHNL_IsInput(pChnl->uMode))
+		if (!CHNL_IS_INPUT(pchnl->chnl_mode))
 			goto func_cont1;
 
-		/*pHostUserBuf */
-		status = copy_to_user(ioc.pBuf, pHostSysBuf, ioc.cBytes);
-#ifndef RES_CLEANUP_DISABLE
+		/*host_user_buf */
+		status = copy_to_user(ioc.pbuf, host_sys_buf, ioc.byte_size);
 		if (status) {
-			if (current->flags & PF_EXITING) {
-				DBG_Trace(DBG_LEVEL7,
-					 "\n2current->flags ==  PF_EXITING, "
-					 " current->flags;0x%x\n",
-					 current->flags);
+			if (current->flags & PF_EXITING)
 				status = 0;
-			} else {
-				DBG_Trace(DBG_LEVEL7,
-					 "\n2current->flags != PF_EXITING, "
-					 " current->flags;0x%x\n",
-					 current->flags);
-			}
 		}
-#endif
-		if (status) {
-			DBG_Trace(DBG_LEVEL7,
-				 "Error copying kernel buffer to user, %d"
-				 " bytes remaining.  in_interupt %d\n",
-				 status, in_interrupt());
+		if (status)
 			status = DSP_EPOINTER;
-		}
 func_cont1:
-		MEM_Free(pHostSysBuf);
+		kfree(host_sys_buf);
 	}
 func_cont:
 	/* Update User's IOC block: */
 	*pIOC = ioc;
 func_end:
-	DBG_Trace(DBG_ENTER, "< WMD_CHNL_GetIOC pChnl %p\n", pChnl);
 	return status;
 }
 
 /*
- *  ======== WMD_CHNL_GetMgrInfo ========
+ *  ======== bridge_chnl_get_mgr_info ========
  *      Retrieve information related to the channel manager.
  */
-DSP_STATUS WMD_CHNL_GetMgrInfo(struct CHNL_MGR *hChnlMgr, u32 uChnlID,
-			      OUT struct CHNL_MGRINFO *pMgrInfo)
+dsp_status bridge_chnl_get_mgr_info(struct chnl_mgr *hchnl_mgr, u32 uChnlID,
+				 OUT struct chnl_mgrinfo *pMgrInfo)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_MGR *pChnlMgr = (struct CHNL_MGR *)hChnlMgr;
+	dsp_status status = DSP_SOK;
+	struct chnl_mgr *chnl_mgr_obj = (struct chnl_mgr *)hchnl_mgr;
 
 	if (pMgrInfo != NULL) {
 		if (uChnlID <= CHNL_MAXCHANNELS) {
-			if (MEM_IsValidHandle(hChnlMgr, CHNL_MGRSIGNATURE)) {
-				/* Return the requested information:  */
-				pMgrInfo->hChnl = pChnlMgr->apChannel[uChnlID];
-				pMgrInfo->cOpenChannels = pChnlMgr->
-							  cOpenChannels;
-				pMgrInfo->dwType = pChnlMgr->dwType;
+			if (MEM_IS_VALID_HANDLE(hchnl_mgr, CHNL_MGRSIGNATURE)) {
+				/* Return the requested information: */
+				pMgrInfo->chnl_obj =
+				    chnl_mgr_obj->ap_channel[uChnlID];
+				pMgrInfo->open_channels =
+				    chnl_mgr_obj->open_channels;
+				pMgrInfo->dw_type = chnl_mgr_obj->dw_type;
 				/* total # of chnls */
-				pMgrInfo->cChannels = pChnlMgr->cChannels;
+				pMgrInfo->max_channels =
+				    chnl_mgr_obj->max_channels;
 			} else {
 				status = DSP_EHANDLE;
 			}
@@ -831,184 +752,178 @@
 }
 
 /*
- *  ======== WMD_CHNL_Idle ========
+ *  ======== bridge_chnl_idle ========
  *      Idles a particular channel.
  */
-DSP_STATUS WMD_CHNL_Idle(struct CHNL_OBJECT *hChnl, u32 dwTimeOut,
-			 bool fFlush)
+dsp_status bridge_chnl_idle(struct chnl_object *chnl_obj, u32 dwTimeOut,
+			    bool fFlush)
 {
-	CHNL_MODE uMode;
-	struct CHNL_MGR *pChnlMgr;
-	DSP_STATUS status = DSP_SOK;
+	short int chnl_mode;
+	struct chnl_mgr *chnl_mgr_obj;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(MEM_IsValidHandle(hChnl, CHNL_SIGNATURE));
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(chnl_obj, CHNL_SIGNATURE));
 
-	uMode = hChnl->uMode;
-	pChnlMgr = hChnl->pChnlMgr;
+	chnl_mode = chnl_obj->chnl_mode;
+	chnl_mgr_obj = chnl_obj->chnl_mgr_obj;
 
-	if (CHNL_IsOutput(uMode) && !fFlush) {
+	if (CHNL_IS_OUTPUT(chnl_mode) && !fFlush) {
 		/* Wait for IO completions, up to the specified timeout: */
-		status = WMD_CHNL_FlushIO(hChnl, dwTimeOut);
+		status = bridge_chnl_flush_io(chnl_obj, dwTimeOut);
 	} else {
-		status = WMD_CHNL_CancelIO(hChnl);
+		status = bridge_chnl_cancel_io(chnl_obj);
 
 		/* Reset the byte count and put channel back in ready state. */
-		hChnl->cBytesMoved = 0;
-		hChnl->dwState &= ~CHNL_STATECANCEL;
+		chnl_obj->bytes_moved = 0;
+		chnl_obj->dw_state &= ~CHNL_STATECANCEL;
 	}
 
 	return status;
 }
 
 /*
- *  ======== WMD_CHNL_Open ========
+ *  ======== bridge_chnl_open ========
  *      Open a new half-duplex channel to the DSP board.
  */
-DSP_STATUS WMD_CHNL_Open(OUT struct CHNL_OBJECT **phChnl,
-			 struct CHNL_MGR *hChnlMgr, CHNL_MODE uMode,
-			 u32 uChnlId, CONST IN struct CHNL_ATTRS *pAttrs)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct CHNL_MGR *pChnlMgr = hChnlMgr;
-	struct CHNL_OBJECT *pChnl = NULL;
-	struct SYNC_ATTRS *pSyncAttrs = NULL;
-	struct SYNC_OBJECT *hSyncEvent = NULL;
-	/* Ensure DBC requirements:  */
-	DBC_Require(phChnl != NULL);
-	DBC_Require(pAttrs != NULL);
+dsp_status bridge_chnl_open(OUT struct chnl_object **phChnl,
+			    struct chnl_mgr *hchnl_mgr, short int chnl_mode,
+			    u32 uChnlId, CONST IN struct chnl_attr *pattrs)
+{
+	dsp_status status = DSP_SOK;
+	struct chnl_mgr *chnl_mgr_obj = hchnl_mgr;
+	struct chnl_object *pchnl = NULL;
+	struct sync_attrs *sync_attr_obj = NULL;
+	struct sync_object *sync_event = NULL;
+	/* Ensure DBC requirements: */
+	DBC_REQUIRE(phChnl != NULL);
+	DBC_REQUIRE(pattrs != NULL);
+	DBC_REQUIRE(hchnl_mgr != NULL);
 	*phChnl = NULL;
-	/* Validate Args:  */
-	if (pAttrs->uIOReqs == 0) {
+	/* Validate Args: */
+	if (pattrs->uio_reqs == 0) {
 		status = DSP_EINVALIDARG;
 	} else {
-		if (!MEM_IsValidHandle(hChnlMgr, CHNL_MGRSIGNATURE)) {
+		if (!MEM_IS_VALID_HANDLE(hchnl_mgr, CHNL_MGRSIGNATURE)) {
 			status = DSP_EHANDLE;
 		} else {
 			if (uChnlId != CHNL_PICKFREE) {
-				if (uChnlId >= pChnlMgr->cChannels) {
+				if (uChnlId >= chnl_mgr_obj->max_channels)
 					status = CHNL_E_BADCHANID;
-				} else if (pChnlMgr->apChannel[uChnlId] !=
-					  NULL) {
+				else if (chnl_mgr_obj->ap_channel[uChnlId] !=
+					 NULL)
 					status = CHNL_E_CHANBUSY;
-				}
 			} else {
 				/* Check for free channel */
-				status = SearchFreeChannel(pChnlMgr, &uChnlId);
+				status =
+				    search_free_channel(chnl_mgr_obj, &uChnlId);
 			}
 		}
 	}
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	DBC_Assert(uChnlId < pChnlMgr->cChannels);
-	/* Create channel object:  */
-	MEM_AllocObject(pChnl, struct CHNL_OBJECT, 0x0000);
-	if (!pChnl) {
+	DBC_ASSERT(uChnlId < chnl_mgr_obj->max_channels);
+	/* Create channel object: */
+	MEM_ALLOC_OBJECT(pchnl, struct chnl_object, 0x0000);
+	if (!pchnl) {
 		status = DSP_EMEMORY;
-		goto func_cont;
+		goto func_end;
 	}
-	/* Protect queues from IO_DPC: */
-	pChnl->dwState = CHNL_STATECANCEL;
+	/* Protect queues from io_dpc: */
+	pchnl->dw_state = CHNL_STATECANCEL;
 	/* Allocate initial IOR and IOC queues: */
-	pChnl->pFreeList = CreateChirpList(pAttrs->uIOReqs);
-	pChnl->pIORequests = CreateChirpList(0);
-	pChnl->pIOCompletions = CreateChirpList(0);
-	pChnl->cChirps = pAttrs->uIOReqs;
-	pChnl->cIOCs = 0;
-	pChnl->cIOReqs = 0;
-	status = SYNC_OpenEvent(&hSyncEvent, pSyncAttrs);
-	if (DSP_SUCCEEDED(status)) {
-		status = NTFY_Create(&pChnl->hNtfy);
-		if (DSP_FAILED(status)) {
-			/* The only failure that could have occurred */
-			status = DSP_EMEMORY;
-		}
-	}
+	pchnl->free_packets_list = create_chirp_list(pattrs->uio_reqs);
+	pchnl->pio_requests = create_chirp_list(0);
+	pchnl->pio_completions = create_chirp_list(0);
+	pchnl->chnl_packets = pattrs->uio_reqs;
+	pchnl->cio_cs = 0;
+	pchnl->cio_reqs = 0;
+	status = sync_open_event(&sync_event, sync_attr_obj);
+	if (DSP_SUCCEEDED(status))
+		status = ntfy_create(&pchnl->ntfy_obj);
+
 	if (DSP_SUCCEEDED(status)) {
-		if (pChnl->pIOCompletions && pChnl->pIORequests &&
-		   pChnl->pFreeList) {
-			/* Initialize CHNL object fields:    */
-			pChnl->pChnlMgr = pChnlMgr;
-			pChnl->uId = uChnlId;
-			pChnl->uMode = uMode;
-			pChnl->hUserEvent = hSyncEvent;	/* for Linux */
-			pChnl->hSyncEvent = hSyncEvent;
-			/* Return TGID instead of process handle */
-			pChnl->hProcess = current->tgid;
-			pChnl->pCBArg = 0;
-			pChnl->cBytesMoved = 0;
+		if (pchnl->pio_completions && pchnl->pio_requests &&
+		    pchnl->free_packets_list) {
+			/* Initialize CHNL object fields: */
+			pchnl->chnl_mgr_obj = chnl_mgr_obj;
+			pchnl->chnl_id = uChnlId;
+			pchnl->chnl_mode = chnl_mode;
+			pchnl->user_event = sync_event;	/* for Linux */
+			pchnl->sync_event = sync_event;
+			/* Get the process handle */
+			pchnl->process = current->tgid;
+			pchnl->pcb_arg = 0;
+			pchnl->bytes_moved = 0;
 			/* Default to proc-copy */
-			pChnl->uChnlType = CHNL_PCPY;
+			pchnl->chnl_type = CHNL_PCPY;
 		} else {
 			status = DSP_EMEMORY;
 		}
-	} else {
-		status = DSP_EINVALIDARG;
 	}
+
 	if (DSP_FAILED(status)) {
 		/* Free memory */
-		if (pChnl->pIOCompletions) {
-			FreeChirpList(pChnl->pIOCompletions);
-			pChnl->pIOCompletions = NULL;
-			pChnl->cIOCs = 0;
-		}
-		if (pChnl->pIORequests) {
-			FreeChirpList(pChnl->pIORequests);
-			pChnl->pIORequests = NULL;
-		}
-		if (pChnl->pFreeList) {
-			FreeChirpList(pChnl->pFreeList);
-			pChnl->pFreeList = NULL;
-		}
-		if (hSyncEvent) {
-			SYNC_CloseEvent(hSyncEvent);
-			hSyncEvent = NULL;
-		}
-		if (pChnl->hNtfy) {
-			NTFY_Delete(pChnl->hNtfy);
-			pChnl->hNtfy = NULL;
+		if (pchnl->pio_completions) {
+			free_chirp_list(pchnl->pio_completions);
+			pchnl->pio_completions = NULL;
+			pchnl->cio_cs = 0;
+		}
+		if (pchnl->pio_requests) {
+			free_chirp_list(pchnl->pio_requests);
+			pchnl->pio_requests = NULL;
+		}
+		if (pchnl->free_packets_list) {
+			free_chirp_list(pchnl->free_packets_list);
+			pchnl->free_packets_list = NULL;
+		}
+		if (sync_event) {
+			sync_close_event(sync_event);
+			sync_event = NULL;
+		}
+		if (pchnl->ntfy_obj) {
+			ntfy_delete(pchnl->ntfy_obj);
+			pchnl->ntfy_obj = NULL;
 		}
-		MEM_FreeObject(pChnl);
-	}
-func_cont:
-	if (DSP_SUCCEEDED(status)) {
+		MEM_FREE_OBJECT(pchnl);
+	} else {
 		/* Insert channel object in channel manager: */
-		pChnlMgr->apChannel[pChnl->uId] = pChnl;
-		SYNC_EnterCS(pChnlMgr->hCSObj);
-		pChnlMgr->cOpenChannels++;
-		SYNC_LeaveCS(pChnlMgr->hCSObj);
+		chnl_mgr_obj->ap_channel[pchnl->chnl_id] = pchnl;
+		sync_enter_cs(chnl_mgr_obj->hcs_obj);
+		chnl_mgr_obj->open_channels++;
+		sync_leave_cs(chnl_mgr_obj->hcs_obj);
 		/* Return result... */
-		pChnl->dwSignature = CHNL_SIGNATURE;
-		pChnl->dwState = CHNL_STATEREADY;
-		*phChnl = pChnl;
+		pchnl->dw_signature = CHNL_SIGNATURE;
+		pchnl->dw_state = CHNL_STATEREADY;
+		*phChnl = pchnl;
 	}
 func_end:
-	DBC_Ensure((DSP_SUCCEEDED(status) &&
-		  MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) ||
-		  (*phChnl == NULL));
+	DBC_ENSURE((DSP_SUCCEEDED(status) &&
+		    MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE)) ||
+		   (*phChnl == NULL));
 	return status;
 }
 
 /*
- *  ======== WMD_CHNL_RegisterNotify ========
+ *  ======== bridge_chnl_register_notify ========
  *      Registers for events on a particular channel.
  */
-DSP_STATUS WMD_CHNL_RegisterNotify(struct CHNL_OBJECT *hChnl, u32 uEventMask,
-				  u32 uNotifyType,
-				  struct DSP_NOTIFICATION *hNotification)
+dsp_status bridge_chnl_register_notify(struct chnl_object *chnl_obj,
+				    u32 event_mask, u32 notify_type,
+				    struct dsp_notification *hnotification)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 
-	DBC_Assert(!(uEventMask & ~(DSP_STREAMDONE | DSP_STREAMIOCOMPLETION)));
+	DBC_ASSERT(!(event_mask & ~(DSP_STREAMDONE | DSP_STREAMIOCOMPLETION)));
 
-	status = NTFY_Register(hChnl->hNtfy, hNotification, uEventMask,
-			      uNotifyType);
+	status = ntfy_register(chnl_obj->ntfy_obj, hnotification, event_mask,
+			       notify_type);
 
 	return status;
 }
 
 /*
- *  ======== CreateChirpList ========
+ *  ======== create_chirp_list ========
  *  Purpose:
  *      Initialize a queue of channel I/O Request/Completion packets.
  *  Parameters:
@@ -1018,78 +933,81 @@
  *  Requires:
  *  Ensures:
  */
-static struct LST_LIST *CreateChirpList(u32 uChirps)
+static struct lst_list *create_chirp_list(u32 uChirps)
 {
-	struct LST_LIST *pChirpList;
-	struct CHNL_IRP *pChirp;
+	struct lst_list *chirp_list;
+	struct chnl_irp *chnl_packet_obj;
 	u32 i;
 
-	pChirpList = LST_Create();
+	chirp_list = mem_calloc(sizeof(struct lst_list), MEM_NONPAGED);
 
-	if (pChirpList) {
+	if (chirp_list) {
+		INIT_LIST_HEAD(&chirp_list->head);
 		/* Make N chirps and place on queue. */
-		for (i = 0; (i < uChirps) && ((pChirp = MakeNewChirp()) !=
-		    NULL); i++) {
-			LST_PutTail(pChirpList, (struct LST_ELEM *)pChirp);
+		for (i = 0; (i < uChirps)
+		     && ((chnl_packet_obj = make_new_chirp()) != NULL); i++) {
+			lst_put_tail(chirp_list,
+				     (struct list_head *)chnl_packet_obj);
 		}
 
 		/* If we couldn't allocate all chirps, free those allocated: */
 		if (i != uChirps) {
-			FreeChirpList(pChirpList);
-			pChirpList = NULL;
+			free_chirp_list(chirp_list);
+			chirp_list = NULL;
 		}
 	}
 
-	return pChirpList;
+	return chirp_list;
 }
 
 /*
- *  ======== FreeChirpList ========
+ *  ======== free_chirp_list ========
  *  Purpose:
  *      Free the queue of Chirps.
  */
-static void FreeChirpList(struct LST_LIST *pChirpList)
+static void free_chirp_list(struct lst_list *chirp_list)
 {
-	DBC_Require(pChirpList != NULL);
+	DBC_REQUIRE(chirp_list != NULL);
 
-	while (!LST_IsEmpty(pChirpList))
-		MEM_Free(LST_GetHead(pChirpList));
+	while (!LST_IS_EMPTY(chirp_list))
+		kfree(lst_get_head(chirp_list));
 
-	LST_Delete(pChirpList);
+	kfree(chirp_list);
 }
 
 /*
- *  ======== MakeNewChirp ========
+ *  ======== make_new_chirp ========
  *      Allocate the memory for a new channel IRP.
  */
-static struct CHNL_IRP *MakeNewChirp(void)
+static struct chnl_irp *make_new_chirp(void)
 {
-	struct CHNL_IRP *pChirp;
+	struct chnl_irp *chnl_packet_obj;
 
-	pChirp = (struct CHNL_IRP *)MEM_Calloc(
-		 sizeof(struct CHNL_IRP), MEM_NONPAGED);
-	if (pChirp != NULL) {
-		/* LST_InitElem only resets the list's member values. */
-		LST_InitElem(&pChirp->link);
+	chnl_packet_obj =
+	    (struct chnl_irp *)mem_calloc(sizeof(struct chnl_irp),
+					  MEM_NONPAGED);
+	if (chnl_packet_obj != NULL) {
+		/* lst_init_elem only resets the list's member values. */
+		lst_init_elem(&chnl_packet_obj->link);
 	}
 
-	return pChirp;
+	return chnl_packet_obj;
 }
 
 /*
- *  ======== SearchFreeChannel ========
+ *  ======== search_free_channel ========
  *      Search for a free channel slot in the array of channel pointers.
  */
-static DSP_STATUS SearchFreeChannel(struct CHNL_MGR *pChnlMgr,
-				   OUT u32 *pdwChnl)
+static dsp_status search_free_channel(struct chnl_mgr *chnl_mgr_obj,
+				      OUT u32 *pdwChnl)
 {
-	DSP_STATUS status = CHNL_E_OUTOFSTREAMS;
+	dsp_status status = CHNL_E_OUTOFSTREAMS;
 	u32 i;
 
-	DBC_Require(MEM_IsValidHandle(pChnlMgr, CHNL_MGRSIGNATURE));
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(chnl_mgr_obj, CHNL_MGRSIGNATURE));
 
-	for (i = 0; i < pChnlMgr->cChannels; i++) {
-		if (pChnlMgr->apChannel[i] == NULL) {
+	for (i = 0; i < chnl_mgr_obj->max_channels; i++) {
+		if (chnl_mgr_obj->ap_channel[i] == NULL) {
 			status = DSP_SOK;
 			*pdwChnl = i;
 			break;
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/_cmm.h kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/_cmm.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/_cmm.h	2011-10-11 13:51:02.017445333 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/_cmm.h	2011-10-23 08:22:37.682749000 +0100
@@ -3,6 +3,10 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Private header file defining CMM manager objects and defines needed
+ * by IO manager to register shared memory regions when DSP base image
+ * is loaded(bridge_io_on_loaded).
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,24 +18,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _cmm.h ========
- *  Description:
- *      Private header file defining CMM manager objects and defines needed
- *      by IO manager to register shared memory regions when DSP base image
- *      is loaded(WMD_IO_OnLoaded).
- *
- *  Public Functions:
- *      None.
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 24-Aug-2001 ag     Created.
- */
-
 #ifndef _CMM_
 #define _CMM_
 
@@ -56,4 +42,4 @@
  *
  */
 
-#endif				/* _CMM_ */
+#endif /* _CMM_ */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/_deh.h kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/_deh.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/_deh.h	2011-10-11 13:51:02.017445333 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/_deh.h	2011-10-23 08:22:37.684782000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Private header for DEH module.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,33 +16,23 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _deh.h ========
- *  Description:
- *      Private header for DEH module.
- *
- *! Revision History:
- *! ================
- *! 21-Sep-2001 kc: created.
- */
-
 #ifndef _DEH_
 #define _DEH_
 
-#include <dspbridge/dpc.h>
 #include <dspbridge/ntfy.h>
 #include <dspbridge/wmd.h>
 
 #define SIGNATURE       0x5f484544	/* "DEH_" backwards */
 
 /* DEH Manager: only one created per board: */
-struct DEH_MGR {
-	u32 dwSignature;	/* Used for object validation.  */
-	struct WMD_DEV_CONTEXT *hWmdContext;	/* WMD device context. */
-	struct NTFY_OBJECT *hNtfy;	/* NTFY object                  */
-	struct DPC_OBJECT *hMmuFaultDpc;	/* DPC object handle.  */
-	struct DSP_ERRORINFO errInfo;	/* DSP exception info.          */
-} ;
+struct deh_mgr {
+	u32 dw_signature;	/* Used for object validation. */
+	struct wmd_dev_context *hwmd_context;	/* WMD device context. */
+	struct ntfy_object *ntfy_obj;	/* NTFY object */
+	struct dsp_errorinfo err_info;	/* DSP exception info. */
+
+	/* MMU Fault DPC */
+	struct tasklet_struct dpc_tasklet;
+};
 
-#endif				/* _DEH_ */
+#endif /* _DEH_ */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/io_sm.c kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/io_sm.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/io_sm.c	2011-10-11 13:51:02.254976563 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/io_sm.c	2011-10-23 08:22:37.688551000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * IO dispatcher for a shared memory channel driver.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -15,37 +17,14 @@
  */
 
 /*
- *  ======== io_sm.c ========
- *  Description:
- *      IO dispatcher for a shared memory channel driver.
- *
- *  Public Functions:
- *      WMD_IO_Create
- *      WMD_IO_Destroy
- *      WMD_IO_OnLoaded
- *      IO_AndSetValue
- *      IO_BufSize
- *      IO_CancelChnl
- *      IO_DPC
- *      IO_ISR
- *      IO_IVAISR
- *      IO_OrSetValue
- *      IO_ReadValue
- *      IO_ReadValueLong
- *      IO_RequestChnl
- *      IO_Schedule
- *      IO_WriteValue
- *      IO_WriteValueLong
- *
- *  Channel Invariant:
- *      There is an important invariant condition which must be maintained per
- *      channel outside of WMD_CHNL_GetIOC() and IO_Dispatch(), violation of
- *      which may cause timeouts and/or failure of the WIN32_WaitSingleObject
- *      function (SYNC_WaitOnEvent).
- *
+ * Channel Invariant:
+ * There is an important invariant condition which must be maintained per
+ * channel outside of bridge_chnl_get_ioc() and IO_Dispatch(), violation of
+ * which may cause timeouts and/or failure of the sync_wait_on_event
+ * function.
  */
 
-/*  ----------------------------------- Host OS */
+/* Host OS */
 #include <dspbridge/host_os.h>
 #include <linux/workqueue.h>
 
@@ -54,475 +33,449 @@
 #include <dspbridge/dbdefs.h>
 #include <dspbridge/errbase.h>
 
-/*  ----------------------------------- Trace & Debug */
+/* Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/dbg.h>
 
-/*  ----------------------------------- OS Adaptation Layer */
+/* Services Layer */
 #include <dspbridge/cfg.h>
-#include <dspbridge/dpc.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/ntfy.h>
 #include <dspbridge/sync.h>
 #include <dspbridge/reg.h>
 
-/* ------------------------------------ Hardware Abstraction Layer */
+/* Hardware Abstraction Layer */
 #include <hw_defs.h>
 #include <hw_mmu.h>
 
-/*  ----------------------------------- Mini Driver */
+/* Mini Driver */
 #include <dspbridge/wmddeh.h>
 #include <dspbridge/wmdio.h>
 #include <dspbridge/wmdioctl.h>
+#include <dspbridge/wdt.h>
 #include <_tiomap.h>
 #include <tiomap_io.h>
 #include <_tiomap_pwr.h>
-#include <tiomap_io.h>
 
-/*  ----------------------------------- Platform Manager */
+/* Platform Manager */
 #include <dspbridge/cod.h>
 #include <dspbridge/dev.h>
-#include <dspbridge/chnl_sm.h>
-#include <dspbridge/dbreg.h>
 
-/*  ----------------------------------- Others */
+/* Others */
 #include <dspbridge/rms_sh.h>
 #include <dspbridge/mgr.h>
 #include <dspbridge/drv.h>
 #include "_cmm.h"
 
-/*  ----------------------------------- This */
+/* This */
 #include <dspbridge/io_sm.h>
 #include "_msg_sm.h"
-#include <dspbridge/gt.h>
 
-/*  ----------------------------------- Defines, Data Structures, Typedefs */
+/* Defines, Data Structures, Typedefs */
 #define OUTPUTNOTREADY  0xffff
-#define NOTENABLED      0xffff	/* channel(s) not enabled */
+#define NOTENABLED      0xffff	/* Channel(s) not enabled */
 
 #define EXTEND      "_EXT_END"
 
-#define SwapWord(x)     (x)
-#define ulPageAlignSize 0x10000   /* Page Align Size */
+#define SWAP_WORD(x)     (x)
+#define UL_PAGE_ALIGN_SIZE 0x10000	/* Page Align Size */
 
 #define MAX_PM_REQS 32
 
-/* IO Manager: only one created per board: */
-struct IO_MGR {
-	/* These four fields must be the first fields in a IO_MGR_ struct: */
-	u32 dwSignature; 	/* Used for object validation   */
-	struct WMD_DEV_CONTEXT *hWmdContext; 	/* WMD device context  */
-	struct WMD_DRV_INTERFACE *pIntfFxns; 	/* Function interface to WMD */
-	struct DEV_OBJECT *hDevObject; 	/* Device this board represents */
-
-	/* These fields initialized in WMD_IO_Create():    */
-	struct CHNL_MGR *hChnlMgr;
-	struct SHM *pSharedMem; 	/* Shared Memory control	*/
-	u8 *pInput; 		/* Address of input channel     */
-	u8 *pOutput; 		/* Address of output channel    */
-	struct MSG_MGR *hMsgMgr; 	/* Message manager */
-	struct MSG *pMsgInputCtrl; 	/* Msg control for from DSP messages */
-	struct MSG *pMsgOutputCtrl; 	/* Msg control for to DSP messages */
-	u8 *pMsgInput; 	/* Address of input messages    */
-	u8 *pMsgOutput; 	/* Address of output messages   */
-	u32 uSMBufSize; 	/* Size of a shared memory I/O channel */
-	bool fSharedIRQ; 	/* Is this IRQ shared?	  */
-	struct DPC_OBJECT *hDPC; 	/* DPC object handle	    */
-	struct SYNC_CSOBJECT *hCSObj; 	/* Critical section object handle */
-	u32 uWordSize; 	/* Size in bytes of DSP word    */
-	u16 wIntrVal; 		/* interrupt value	      */
-	/* private extnd proc info; mmu setup */
-	struct MGR_PROCESSOREXTINFO extProcInfo;
-	struct CMM_OBJECT *hCmmMgr; 	/* Shared Mem Mngr	      */
-       struct work_struct io_workq;     /*workqueue */
-	u32 dQuePowerMbxVal[MAX_PM_REQS];
-	u32 iQuePowerHead;
-	u32 iQuePowerTail;
+/* IO Manager: only one created per board */
+struct io_mgr {
+	/* These four fields must be the first fields in a io_mgr_ struct */
+	u32 dw_signature;	/* Used for object validation */
+	struct wmd_dev_context *hwmd_context;	/* WMD device context */
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD */
+	struct dev_object *hdev_obj;	/* Device this board represents */
+
+	/* These fields initialized in bridge_io_create() */
+	struct chnl_mgr *hchnl_mgr;
+	struct shm *shared_mem;	/* Shared Memory control */
+	u8 *input;		/* Address of input channel */
+	u8 *output;		/* Address of output channel */
+	struct msg_mgr *hmsg_mgr;	/* Message manager */
+	/* Msg control for from DSP messages */
+	struct msg_ctrl *msg_input_ctrl;
+	/* Msg control for to DSP messages */
+	struct msg_ctrl *msg_output_ctrl;
+	u8 *msg_input;		/* Address of input messages */
+	u8 *msg_output;		/* Address of output messages */
+	u32 usm_buf_size;	/* Size of a shared memory I/O channel */
+	bool shared_irq;	/* Is this IRQ shared? */
+	struct sync_csobject *hcs_obj;	/* Critical section object handle */
+	u32 word_size;		/* Size in bytes of DSP word */
+	u16 intr_val;		/* Interrupt value */
+	/* Private extnd proc info; mmu setup */
+	struct mgr_processorextinfo ext_proc_info;
+	struct cmm_object *hcmm_mgr;	/* Shared Mem Mngr */
+	struct work_struct io_workq;	/* workqueue */
 #ifndef DSP_TRACEBUF_DISABLED
-	u32 ulTraceBufferBegin; 	/* Trace message start address */
-	u32 ulTraceBufferEnd; 	/* Trace message end address */
-	u32 ulTraceBufferCurrent; 	/* Trace message current address */
-	u32 ulGPPReadPointer; 	/* GPP Read pointer to Trace buffer */
-	u8 *pMsg;
-	u32 ulGppVa;
-	u32 ulDspVa;
+	u32 ul_trace_buffer_begin;	/* Trace message start address */
+	u32 ul_trace_buffer_end;	/* Trace message end address */
+	u32 ul_trace_buffer_current;	/* Trace message current address */
+	u32 ul_gpp_read_pointer;	/* GPP Read pointer to Trace buffer */
+	u8 *pmsg;
+	u32 ul_gpp_va;
+	u32 ul_dsp_va;
 #endif
-} ;
-
-/*  ----------------------------------- Function Prototypes */
-static void IO_DispatchChnl(IN struct IO_MGR *pIOMgr,
-			   IN OUT struct CHNL_OBJECT *pChnl, u32 iMode);
-static void IO_DispatchMsg(IN struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr);
-static void IO_DispatchPM(struct work_struct *work);
-static void NotifyChnlComplete(struct CHNL_OBJECT *pChnl,
-				struct CHNL_IRP *pChirp);
-static void InputChnl(struct IO_MGR *pIOMgr, struct CHNL_OBJECT *pChnl,
+	/* IO Dpc */
+	u32 dpc_req;		/* Number of requested DPC's. */
+	u32 dpc_sched;		/* Number of executed DPC's. */
+	struct tasklet_struct dpc_tasklet;
+	spinlock_t dpc_lock;
+
+};
+
+/* Function Prototypes */
+static void io_dispatch_chnl(IN struct io_mgr *pio_mgr,
+			     IN OUT struct chnl_object *pchnl, u32 iMode);
+static void io_dispatch_msg(IN struct io_mgr *pio_mgr,
+			    struct msg_mgr *hmsg_mgr);
+static void io_dispatch_pm(struct io_mgr *pio_mgr);
+static void notify_chnl_complete(struct chnl_object *pchnl,
+				 struct chnl_irp *chnl_packet_obj);
+static void input_chnl(struct io_mgr *pio_mgr, struct chnl_object *pchnl,
+		       u32 iMode);
+static void output_chnl(struct io_mgr *pio_mgr, struct chnl_object *pchnl,
 			u32 iMode);
-static void OutputChnl(struct IO_MGR *pIOMgr, struct CHNL_OBJECT *pChnl,
-			u32 iMode);
-static void InputMsg(struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr);
-static void OutputMsg(struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr);
-static u32 FindReadyOutput(struct CHNL_MGR *pChnlMgr,
-			     struct CHNL_OBJECT *pChnl, u32 dwMask);
-static u32 ReadData(struct WMD_DEV_CONTEXT *hDevContext, void *pDest,
-			void *pSrc, u32 uSize);
-static u32 WriteData(struct WMD_DEV_CONTEXT *hDevContext, void *pDest,
-			void *pSrc, u32 uSize);
-static struct workqueue_struct *bridge_workqueue;
-#ifndef DSP_TRACEBUF_DISABLED
-void PrintDSPDebugTrace(struct IO_MGR *hIOMgr);
-#endif
-
-/* Bus Addr (cached kernel)*/
-static DSP_STATUS registerSHMSegs(struct IO_MGR *hIOMgr,
-				  struct COD_MANAGER *hCodMan,
-				  u32 dwGPPBasePA);
+static void input_msg(struct io_mgr *pio_mgr, struct msg_mgr *hmsg_mgr);
+static void output_msg(struct io_mgr *pio_mgr, struct msg_mgr *hmsg_mgr);
+static u32 find_ready_output(struct chnl_mgr *chnl_mgr_obj,
+			     struct chnl_object *pchnl, u32 dwMask);
+static u32 read_data(struct wmd_dev_context *hDevContext, void *dest,
+		     void *pSrc, u32 usize);
+static u32 write_data(struct wmd_dev_context *hDevContext, void *dest,
+		      void *pSrc, u32 usize);
 
-#ifdef CONFIG_BRIDGE_DVFS
-/* The maximum number of OPPs that are supported */
-extern s32 dsp_max_opps;
-/* The Vdd1 opp table information */
-extern u32 vdd1_dsp_freq[6][4] ;
+#ifndef DSP_TRACEBUF_DISABLED
+void print_dsp_debug_trace(struct io_mgr *hio_mgr);
 #endif
 
-#if GT_TRACE
-static struct GT_Mask dsp_trace_mask = { NULL, NULL }; /* GT trace variable */
-#endif
+/* Bus Addr (cached kernel) */
+static dsp_status register_shm_segs(struct io_mgr *hio_mgr,
+				    struct cod_manager *cod_man,
+				    u32 dw_gpp_base_pa);
 
 /*
- *  ======== WMD_IO_Create ========
+ *  ======== bridge_io_create ========
  *      Create an IO manager object.
  */
-DSP_STATUS WMD_IO_Create(OUT struct IO_MGR **phIOMgr,
-			 struct DEV_OBJECT *hDevObject,
-			 IN CONST struct IO_ATTRS *pMgrAttrs)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct IO_MGR *pIOMgr = NULL;
-	struct SHM *pSharedMem = NULL;
-	struct WMD_DEV_CONTEXT *hWmdContext = NULL;
-	struct CFG_HOSTRES hostRes;
-	struct CFG_DEVNODE *hDevNode;
-	struct CHNL_MGR *hChnlMgr;
-	static int ref_count;
-	u32 devType;
-	/* Check DBC requirements:  */
-	DBC_Require(phIOMgr != NULL);
-	DBC_Require(pMgrAttrs != NULL);
-	DBC_Require(pMgrAttrs->uWordSize != 0);
-	/* This for the purposes of DBC_Require: */
-	status = DEV_GetChnlMgr(hDevObject, &hChnlMgr);
-	DBC_Require(status != DSP_EHANDLE);
-	DBC_Require(hChnlMgr != NULL);
-	DBC_Require(hChnlMgr->hIOMgr == NULL);
+dsp_status bridge_io_create(OUT struct io_mgr **phIOMgr,
+			    struct dev_object *hdev_obj,
+			    IN CONST struct io_attrs *pMgrAttrs)
+{
+	dsp_status status = DSP_SOK;
+	struct io_mgr *pio_mgr = NULL;
+	struct shm *shared_mem = NULL;
+	struct wmd_dev_context *hwmd_context = NULL;
+	struct cfg_hostres host_res;
+	struct cfg_devnode *dev_node_obj;
+	struct chnl_mgr *hchnl_mgr;
+	u32 dev_type;
+
+	/* Check requirements */
+	if (!phIOMgr || !pMgrAttrs || pMgrAttrs->word_size == 0) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	dev_get_chnl_mgr(hdev_obj, &hchnl_mgr);
+	if (!hchnl_mgr || hchnl_mgr->hio_mgr) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 	/*
 	 * Message manager will be created when a file is loaded, since
 	 * size of message buffer in shared memory is configurable in
 	 * the base image.
 	 */
-	DEV_GetWMDContext(hDevObject, &hWmdContext);
-	DBC_Assert(hWmdContext);
-	DEV_GetDevType(hDevObject, &devType);
+	dev_get_wmd_context(hdev_obj, &hwmd_context);
+	if (!hwmd_context) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	dev_get_dev_type(hdev_obj, &dev_type);
 	/*
 	 * DSP shared memory area will get set properly when
 	 * a program is loaded. They are unknown until a COFF file is
 	 * loaded. I chose the value -1 because it was less likely to be
 	 * a valid address than 0.
 	 */
-	pSharedMem = (struct SHM *) -1;
-	if (DSP_FAILED(status))
-		goto func_cont;
+	shared_mem = (struct shm *)-1;
 
-	/* Create a Single Threaded Work Queue */
-	if (ref_count == 0)
-		bridge_workqueue = create_workqueue("bridge_work-queue");
-
-	if (!bridge_workqueue)
-		DBG_Trace(DBG_LEVEL1, "Workqueue creation failed!\n");
-
-	/* Allocate IO manager object: */
-	MEM_AllocObject(pIOMgr, struct IO_MGR, IO_MGRSIGNATURE);
-	if (pIOMgr == NULL) {
+	/* Allocate IO manager object */
+	MEM_ALLOC_OBJECT(pio_mgr, struct io_mgr, IO_MGRSIGNATURE);
+	if (pio_mgr == NULL) {
 		status = DSP_EMEMORY;
-		goto func_cont;
+		goto func_end;
 	}
 
-	/* Intializing Work Element */
-	if (ref_count == 0) {
-		INIT_WORK(&pIOMgr->io_workq, (void *)IO_DispatchPM);
-		ref_count = 1;
-	} else
-		PREPARE_WORK(&pIOMgr->io_workq, (void *)IO_DispatchPM);
-
-	/* Initialize CHNL_MGR object:    */
+	/* Initialize chnl_mgr object */
 #ifndef DSP_TRACEBUF_DISABLED
-	pIOMgr->pMsg = NULL;
+	pio_mgr->pmsg = NULL;
 #endif
-	pIOMgr->hChnlMgr = hChnlMgr;
-	pIOMgr->uWordSize = pMgrAttrs->uWordSize;
-	pIOMgr->pSharedMem = pSharedMem;
+	pio_mgr->hchnl_mgr = hchnl_mgr;
+	pio_mgr->word_size = pMgrAttrs->word_size;
+	pio_mgr->shared_mem = shared_mem;
 	if (DSP_SUCCEEDED(status))
-		status = SYNC_InitializeCS(&pIOMgr->hCSObj);
+		status = sync_initialize_cs(&pio_mgr->hcs_obj);
 
-	if (devType == DSP_UNIT) {
-		/* Create a DPC object: */
-		status = DPC_Create(&pIOMgr->hDPC, IO_DPC, (void *)pIOMgr);
-		if (DSP_SUCCEEDED(status))
-			status = DEV_GetDevNode(hDevObject, &hDevNode);
+	if (dev_type == DSP_UNIT) {
+		/* Create an IO DPC */
+		tasklet_init(&pio_mgr->dpc_tasklet, io_dpc, (u32) pio_mgr);
+
+		/* Initialize DPC counters */
+		pio_mgr->dpc_req = 0;
+		pio_mgr->dpc_sched = 0;
 
-		pIOMgr->iQuePowerHead = 0;
-		pIOMgr->iQuePowerTail = 0;
+		spin_lock_init(&pio_mgr->dpc_lock);
+
+		if (DSP_SUCCEEDED(status))
+			status = dev_get_dev_node(hdev_obj, &dev_node_obj);
 	}
 	if (DSP_SUCCEEDED(status)) {
-		status = CFG_GetHostResources((struct CFG_DEVNODE *)
-				DRV_GetFirstDevExtension() , &hostRes);
+		status = cfg_get_host_resources((struct cfg_devnode *)
+						drv_get_first_dev_extension(),
+						&host_res);
 	}
 	if (DSP_SUCCEEDED(status)) {
-		pIOMgr->hWmdContext = hWmdContext;
-		pIOMgr->fSharedIRQ = pMgrAttrs->fShared;
-		IO_DisableInterrupt(hWmdContext);
-		if (devType == DSP_UNIT) {
-			HW_MBOX_initSettings(hostRes.dwMboxBase);
-			/* Plug the channel ISR:. */
-			if ((request_irq(INT_MAIL_MPU_IRQ, IO_ISR, 0,
-				"DspBridge\tmailbox", (void *)pIOMgr)) == 0)
-				status = DSP_SOK;
-			else
-				status = DSP_EFAIL;
-		}
-		if (DSP_SUCCEEDED(status))
-			DBG_Trace(DBG_LEVEL1, "ISR_IRQ Object 0x%x \n",
-					pIOMgr);
-		else
-			status = CHNL_E_ISR;
-	} else
+		pio_mgr->hwmd_context = hwmd_context;
+		pio_mgr->shared_irq = pMgrAttrs->irq_shared;
+		if (dsp_wdt_init())
+			status = DSP_EFAIL;
+	} else {
 		status = CHNL_E_ISR;
-func_cont:
+	}
+func_end:
 	if (DSP_FAILED(status)) {
-		/* Cleanup: */
-		WMD_IO_Destroy(pIOMgr);
-		*phIOMgr = NULL;
+		/* Cleanup */
+		bridge_io_destroy(pio_mgr);
+		if (phIOMgr)
+			*phIOMgr = NULL;
 	} else {
 		/* Return IO manager object to caller... */
-		hChnlMgr->hIOMgr = pIOMgr;
-		*phIOMgr = pIOMgr;
+		hchnl_mgr->hio_mgr = pio_mgr;
+		*phIOMgr = pio_mgr;
 	}
 	return status;
 }
 
 /*
- *  ======== WMD_IO_Destroy ========
+ *  ======== bridge_io_destroy ========
  *  Purpose:
  *      Disable interrupts, destroy the IO manager.
  */
-DSP_STATUS WMD_IO_Destroy(struct IO_MGR *hIOMgr)
+dsp_status bridge_io_destroy(struct io_mgr *hio_mgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *hWmdContext;
-	if (MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE)) {
-		/* Unplug IRQ:    */
-               /* Disable interrupts from the board:  */
-               if (DSP_SUCCEEDED(DEV_GetWMDContext(hIOMgr->hDevObject,
-                      &hWmdContext)))
-                               DBC_Assert(hWmdContext);
-               (void)CHNLSM_DisableInterrupt(hWmdContext);
-               destroy_workqueue(bridge_workqueue);
-               /* Linux function to uninstall ISR */
-               free_irq(INT_MAIL_MPU_IRQ, (void *)hIOMgr);
-               (void)DPC_Destroy(hIOMgr->hDPC);
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *hwmd_context;
+	if (MEM_IS_VALID_HANDLE(hio_mgr, IO_MGRSIGNATURE)) {
+		status = dev_get_wmd_context(hio_mgr->hdev_obj, &hwmd_context);
+
+		/* Free IO DPC object */
+		tasklet_kill(&hio_mgr->dpc_tasklet);
+
 #ifndef DSP_TRACEBUF_DISABLED
-		if (hIOMgr->pMsg)
-			MEM_Free(hIOMgr->pMsg);
+		kfree(hio_mgr->pmsg);
 #endif
-		SYNC_DeleteCS(hIOMgr->hCSObj); 	/* Leak Fix. */
-		/* Free this IO manager object: */
-		MEM_FreeObject(hIOMgr);
-       } else
+		sync_delete_cs(hio_mgr->hcs_obj);	/* Leak Fix. */
+		dsp_wdt_exit();
+		/* Free this IO manager object */
+		MEM_FREE_OBJECT(hio_mgr);
+	} else {
 		status = DSP_EHANDLE;
+	}
 
 	return status;
 }
 
 /*
- *  ======== WMD_IO_OnLoaded ========
+ *  ======== bridge_io_on_loaded ========
  *  Purpose:
  *      Called when a new program is loaded to get shared memory buffer
  *      parameters from COFF file. ulSharedBufferBase and ulSharedBufferLimit
  *      are in DSP address units.
  */
-DSP_STATUS WMD_IO_OnLoaded(struct IO_MGR *hIOMgr)
+dsp_status bridge_io_on_loaded(struct io_mgr *hio_mgr)
 {
-	struct COD_MANAGER *hCodMan;
-	struct CHNL_MGR *hChnlMgr;
-	struct MSG_MGR *hMsgMgr;
-	u32 ulShmBase;
-	u32 ulShmBaseOffset;
-	u32 ulShmLimit;
-	u32 ulShmLength = -1;
-	u32 ulMemLength = -1;
-	u32 ulMsgBase;
-	u32 ulMsgLimit;
-	u32 ulMsgLength = -1;
-	u32 ulExtEnd;
-	u32 ulGppPa = 0;
-	u32 ulGppVa = 0;
-	u32 ulDspVa = 0;
-	u32 ulSegSize = 0;
-	u32 ulPadSize = 0;
+	struct cod_manager *cod_man;
+	struct chnl_mgr *hchnl_mgr;
+	struct msg_mgr *hmsg_mgr;
+	u32 ul_shm_base;
+	u32 ul_shm_base_offset;
+	u32 ul_shm_limit;
+	u32 ul_shm_length = -1;
+	u32 ul_mem_length = -1;
+	u32 ul_msg_base;
+	u32 ul_msg_limit;
+	u32 ul_msg_length = -1;
+	u32 ul_ext_end;
+	u32 ul_gpp_pa = 0;
+	u32 ul_gpp_va = 0;
+	u32 ul_dsp_va = 0;
+	u32 ul_seg_size = 0;
+	u32 ul_pad_size = 0;
 	u32 i;
-	DSP_STATUS status = DSP_SOK;
-	u32 uNumProcs = 0;
+	dsp_status status = DSP_SOK;
+	u32 num_procs = 0;
 	s32 ndx = 0;
 	/* DSP MMU setup table */
-	struct WMDIOCTL_EXTPROC aEProc[WMDIOCTL_NUMOFMMUTLB];
-	struct CFG_HOSTRES hostRes;
-	u32 mapAttrs;
-	u32 ulShm0End;
-	u32 ulDynExtBase;
-	u32 ulSeg1Size = 0;
-	u32 paCurr = 0;
-	u32 vaCurr = 0;
-	u32 gppVaCurr = 0;
-	u32 numBytes = 0;
-	u32 allBits = 0;
-	u32 pgSize[] = { HW_PAGE_SIZE_16MB, HW_PAGE_SIZE_1MB,
-			   HW_PAGE_SIZE_64KB, HW_PAGE_SIZE_4KB };
-
-	status = DEV_GetCodMgr(hIOMgr->hDevObject, &hCodMan);
-	DBC_Assert(DSP_SUCCEEDED(status));
-	hChnlMgr = hIOMgr->hChnlMgr;
-	 /*  The message manager is destroyed when the board is stopped.  */
-	DEV_GetMsgMgr(hIOMgr->hDevObject, &hIOMgr->hMsgMgr);
-	hMsgMgr = hIOMgr->hMsgMgr;
-	DBC_Assert(MEM_IsValidHandle(hChnlMgr, CHNL_MGRSIGNATURE));
-	DBC_Assert(MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE));
-	if (hIOMgr->pSharedMem)
-		hIOMgr->pSharedMem = NULL;
+	struct wmdioctl_extproc ae_proc[WMDIOCTL_NUMOFMMUTLB];
+	struct cfg_hostres host_res;
+	u32 map_attrs;
+	u32 shm0_end;
+	u32 ul_dyn_ext_base;
+	u32 ul_seg1_size = 0;
+	u32 pa_curr = 0;
+	u32 va_curr = 0;
+	u32 gpp_va_curr = 0;
+	u32 num_bytes = 0;
+	u32 all_bits = 0;
+	u32 page_size[] = { HW_PAGE_SIZE16MB, HW_PAGE_SIZE1MB,
+		HW_PAGE_SIZE64KB, HW_PAGE_SIZE4KB
+	};
+
+	status = dev_get_cod_mgr(hio_mgr->hdev_obj, &cod_man);
+	if (DSP_FAILED(status))
+		goto func_end;
+	hchnl_mgr = hio_mgr->hchnl_mgr;
+	/* The message manager is destroyed when the board is stopped. */
+	dev_get_msg_mgr(hio_mgr->hdev_obj, &hio_mgr->hmsg_mgr);
+	hmsg_mgr = hio_mgr->hmsg_mgr;
+	if (!MEM_IS_VALID_HANDLE(hchnl_mgr, CHNL_MGRSIGNATURE) ||
+	    !MEM_IS_VALID_HANDLE(hmsg_mgr, MSGMGR_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	if (hio_mgr->shared_mem)
+		hio_mgr->shared_mem = NULL;
 
 	/* Get start and length of channel part of shared memory */
-	status = COD_GetSymValue(hCodMan, CHNL_SHARED_BUFFER_BASE_SYM,
-				 &ulShmBase);
+	status = cod_get_sym_value(cod_man, CHNL_SHARED_BUFFER_BASE_SYM,
+				   &ul_shm_base);
 	if (DSP_FAILED(status)) {
 		status = CHNL_E_NOMEMMAP;
-		goto func_cont1;
+		goto func_end;
 	}
-	status = COD_GetSymValue(hCodMan, CHNL_SHARED_BUFFER_LIMIT_SYM,
-				&ulShmLimit);
+	status = cod_get_sym_value(cod_man, CHNL_SHARED_BUFFER_LIMIT_SYM,
+				   &ul_shm_limit);
 	if (DSP_FAILED(status)) {
 		status = CHNL_E_NOMEMMAP;
-		goto func_cont1;
+		goto func_end;
 	}
-	if (ulShmLimit <= ulShmBase) {
+	if (ul_shm_limit <= ul_shm_base) {
 		status = CHNL_E_INVALIDMEMBASE;
-	} else {
-		/* get total length in bytes */
-		ulShmLength = (ulShmLimit - ulShmBase + 1) * hIOMgr->uWordSize;
-		/* Calculate size of a PROCCOPY shared memory region */
-		DBG_Trace(DBG_LEVEL7,
-			 "**(proc)PROCCOPY SHMMEM SIZE: 0x%x bytes\n",
-			  (ulShmLength - sizeof(struct SHM)));
+		goto func_end;
 	}
-func_cont1:
+	/* Get total length in bytes */
+	ul_shm_length = (ul_shm_limit - ul_shm_base + 1) * hio_mgr->word_size;
+	/* Calculate size of a PROCCOPY shared memory region */
+	dev_dbg(bridge, "%s: (proc)proccopy shmmem size: 0x%x bytes\n",
+		__func__, (ul_shm_length - sizeof(struct shm)));
+
 	if (DSP_SUCCEEDED(status)) {
 		/* Get start and length of message part of shared memory */
-		status = COD_GetSymValue(hCodMan, MSG_SHARED_BUFFER_BASE_SYM,
-					&ulMsgBase);
+		status = cod_get_sym_value(cod_man, MSG_SHARED_BUFFER_BASE_SYM,
+					   &ul_msg_base);
 	}
 	if (DSP_SUCCEEDED(status)) {
-		status = COD_GetSymValue(hCodMan, MSG_SHARED_BUFFER_LIMIT_SYM,
-					&ulMsgLimit);
+		status = cod_get_sym_value(cod_man, MSG_SHARED_BUFFER_LIMIT_SYM,
+					   &ul_msg_limit);
 		if (DSP_SUCCEEDED(status)) {
-			if (ulMsgLimit <= ulMsgBase) {
+			if (ul_msg_limit <= ul_msg_base) {
 				status = CHNL_E_INVALIDMEMBASE;
 			} else {
-				/* Length (bytes) of messaging part of shared
-				 * memory */
-				ulMsgLength = (ulMsgLimit - ulMsgBase + 1) *
-					      hIOMgr->uWordSize;
-				/* Total length (bytes) of shared memory:
-				 * chnl + msg */
-				ulMemLength = ulShmLength + ulMsgLength;
+				/*
+				 * Length (bytes) of messaging part of shared
+				 * memory.
+				 */
+				ul_msg_length =
+				    (ul_msg_limit - ul_msg_base +
+				     1) * hio_mgr->word_size;
+				/*
+				 * Total length (bytes) of shared memory:
+				 * chnl + msg.
+				 */
+				ul_mem_length = ul_shm_length + ul_msg_length;
 			}
 		} else {
 			status = CHNL_E_NOMEMMAP;
 		}
+	} else {
+		status = CHNL_E_NOMEMMAP;
 	}
 	if (DSP_SUCCEEDED(status)) {
 #ifndef DSP_TRACEBUF_DISABLED
-		status = COD_GetSymValue(hCodMan, DSP_TRACESEC_END, &ulShm0End);
-		DBG_Trace(DBG_LEVEL7, "_BRIDGE_TRACE_END value = %x \n",
-			 ulShm0End);
+		status =
+		    cod_get_sym_value(cod_man, DSP_TRACESEC_END, &shm0_end);
 #else
-		status = COD_GetSymValue(hCodMan, SHM0_SHARED_END_SYM,
-					 &ulShm0End);
-		DBG_Trace(DBG_LEVEL7, "_SHM0_END = %x \n", ulShm0End);
+		status = cod_get_sym_value(cod_man, SHM0_SHARED_END_SYM,
+					   &shm0_end);
 #endif
 		if (DSP_FAILED(status))
 			status = CHNL_E_NOMEMMAP;
-
 	}
 	if (DSP_SUCCEEDED(status)) {
-		status = COD_GetSymValue(hCodMan, DYNEXTBASE, &ulDynExtBase);
+		status =
+		    cod_get_sym_value(cod_man, DYNEXTBASE, &ul_dyn_ext_base);
 		if (DSP_FAILED(status))
 			status = CHNL_E_NOMEMMAP;
-
 	}
 	if (DSP_SUCCEEDED(status)) {
-		status = COD_GetSymValue(hCodMan, EXTEND, &ulExtEnd);
+		status = cod_get_sym_value(cod_man, EXTEND, &ul_ext_end);
 		if (DSP_FAILED(status))
 			status = CHNL_E_NOMEMMAP;
-
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Get memory reserved in host resources */
-		(void)MGR_EnumProcessorInfo(0,
-			(struct DSP_PROCESSORINFO *)&hIOMgr->extProcInfo,
-			sizeof(struct MGR_PROCESSOREXTINFO), &uNumProcs);
-		CFG_GetHostResources((
-			struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
-			&hostRes);
+		(void)mgr_enum_processor_info(0, (struct dsp_processorinfo *)
+					      &hio_mgr->ext_proc_info,
+					      sizeof(struct
+						     mgr_processorextinfo),
+					      &num_procs);
+		cfg_get_host_resources((struct cfg_devnode *)
+				       drv_get_first_dev_extension(),
+				       &host_res);
 		/* The first MMU TLB entry(TLB_0) in DCD is ShmBase. */
 		ndx = 0;
-		ulGppPa = hostRes.dwMemPhys[1];
-		ulGppVa = hostRes.dwMemBase[1];
-		/* THIS IS THE VIRTUAL UNCACHED IOREMAPPED ADDRESS !!! */
+		ul_gpp_pa = host_res.dw_mem_phys[1];
+		ul_gpp_va = host_res.dw_mem_base[1];
+		/* This is the virtual uncached ioremapped address!!! */
 		/* Why can't we directly take the DSPVA from the symbols? */
-		ulDspVa = hIOMgr->extProcInfo.tyTlb[0].ulDspVirt;
-		ulSegSize = (ulShm0End - ulDspVa) * hIOMgr->uWordSize;
-		ulSeg1Size = (ulExtEnd - ulDynExtBase) * hIOMgr->uWordSize;
-		ulSeg1Size = (ulSeg1Size + 0xFFF) & (~0xFFFUL); /* 4K align*/
-		ulSegSize = (ulSegSize + 0xFFFF) & (~0xFFFFUL); /* 64K align*/
-		ulPadSize = ulPageAlignSize - ((ulGppPa + ulSeg1Size) %
-			     ulPageAlignSize);
-			if (ulPadSize == ulPageAlignSize)
-				ulPadSize = 0x0;
-
-		 DBG_Trace(DBG_LEVEL7, "ulGppPa %x, ulGppVa %x, ulDspVa %x, "
-			  "ulShm0End %x, ulDynExtBase %x, ulExtEnd %x, "
-			  "ulSegSize %x ulSeg1Size %x \n", ulGppPa, ulGppVa,
-			  ulDspVa, ulShm0End, ulDynExtBase, ulExtEnd, ulSegSize,
-			  ulSeg1Size);
-
-		if ((ulSegSize + ulSeg1Size + ulPadSize) >
-		   hostRes.dwMemLength[1]) {
-			DBG_Trace(DBG_LEVEL7, "ulGppPa %x, ulGppVa %x, ulDspVa "
-				 "%x, ulShm0End %x, ulDynExtBase %x, ulExtEnd "
-				 "%x, ulSegSize %x, ulSeg1Size %x \n", ulGppPa,
-				 ulGppVa, ulDspVa, ulShm0End, ulDynExtBase,
-				 ulExtEnd, ulSegSize, ulSeg1Size);
-			DBG_Trace(DBG_LEVEL7, "Insufficient SHM Reserved 0x%x. "
-				 "Required 0x%x\n", hostRes.dwMemLength[1],
-				 ulSegSize + ulSeg1Size + ulPadSize);
+		ul_dsp_va = hio_mgr->ext_proc_info.ty_tlb[0].ul_dsp_virt;
+		ul_seg_size = (shm0_end - ul_dsp_va) * hio_mgr->word_size;
+		ul_seg1_size =
+		    (ul_ext_end - ul_dyn_ext_base) * hio_mgr->word_size;
+		/* 4K align */
+		ul_seg1_size = (ul_seg1_size + 0xFFF) & (~0xFFFUL);
+		/* 64K align */
+		ul_seg_size = (ul_seg_size + 0xFFFF) & (~0xFFFFUL);
+		ul_pad_size = UL_PAGE_ALIGN_SIZE - ((ul_gpp_pa + ul_seg1_size) %
+						    UL_PAGE_ALIGN_SIZE);
+		if (ul_pad_size == UL_PAGE_ALIGN_SIZE)
+			ul_pad_size = 0x0;
+
+		dev_dbg(bridge, "%s: ul_gpp_pa %x, ul_gpp_va %x, ul_dsp_va %x, "
+			"shm0_end %x, ul_dyn_ext_base %x, ul_ext_end %x, "
+			"ul_seg_size %x ul_seg1_size %x \n", __func__,
+			ul_gpp_pa, ul_gpp_va, ul_dsp_va, shm0_end,
+			ul_dyn_ext_base, ul_ext_end, ul_seg_size, ul_seg1_size);
+
+		if ((ul_seg_size + ul_seg1_size + ul_pad_size) >
+		    host_res.dw_mem_length[1]) {
+			pr_err("%s: shm Error, reserved 0x%x required 0x%x\n",
+			       __func__, host_res.dw_mem_length[1],
+			       ul_seg_size + ul_seg1_size + ul_pad_size);
 			status = DSP_EMEMORY;
 		}
 	}
 	if (DSP_FAILED(status))
-		goto func_cont;
+		goto func_end;
 
-	paCurr = ulGppPa;
-	vaCurr = ulDynExtBase * hIOMgr->uWordSize;
-	gppVaCurr = ulGppVa;
-	numBytes = ulSeg1Size;
+	pa_curr = ul_gpp_pa;
+	va_curr = ul_dyn_ext_base * hio_mgr->word_size;
+	gpp_va_curr = ul_gpp_va;
+	num_bytes = ul_seg1_size;
 
 	/*
 	 * Try to fit into TLB entries. If not possible, push them to page
@@ -530,1216 +483,1296 @@
 	 * bigger page boundary, we may end up making several small pages.
 	 * So, push them onto page tables, if that is the case.
 	 */
-	mapAttrs = 0x00000000;
-	mapAttrs = DSP_MAPLITTLEENDIAN;
-	mapAttrs |= DSP_MAPPHYSICALADDR;
-	mapAttrs |= DSP_MAPELEMSIZE32;
-	mapAttrs |= DSP_MAPDONOTLOCK;
-
-	while (numBytes && DSP_SUCCEEDED(status)) {
-		/* To find the max. page size with which both PA & VA are
-		 * aligned */
-		allBits = paCurr | vaCurr;
-		DBG_Trace(DBG_LEVEL1, "allBits %x, paCurr %x, vaCurr %x, "
-			 "numBytes %x\n", allBits, paCurr, vaCurr, numBytes);
+	map_attrs = 0x00000000;
+	map_attrs = DSP_MAPLITTLEENDIAN;
+	map_attrs |= DSP_MAPPHYSICALADDR;
+	map_attrs |= DSP_MAPELEMSIZE32;
+	map_attrs |= DSP_MAPDONOTLOCK;
+
+	while (num_bytes) {
+		/*
+		 * To find the max. page size with which both PA & VA are
+		 * aligned.
+		 */
+		all_bits = pa_curr | va_curr;
+		dev_dbg(bridge, "all_bits %x, pa_curr %x, va_curr %x, "
+			"num_bytes %x\n", all_bits, pa_curr, va_curr,
+			num_bytes);
 		for (i = 0; i < 4; i++) {
-			if ((numBytes >= pgSize[i]) && ((allBits &
-			   (pgSize[i] - 1)) == 0)) {
-				status = hIOMgr->pIntfFxns->pfnBrdMemMap
-					(hIOMgr->hWmdContext, paCurr, vaCurr,
-					pgSize[i], mapAttrs);
-				DBC_Assert(DSP_SUCCEEDED(status));
-				paCurr += pgSize[i];
-				vaCurr += pgSize[i];
-				gppVaCurr += pgSize[i];
-				numBytes -= pgSize[i];
-				/* Don't try smaller sizes. Hopefully we have
+			if ((num_bytes >= page_size[i]) && ((all_bits &
+							     (page_size[i] -
+							      1)) == 0)) {
+				status =
+				    hio_mgr->intf_fxns->
+				    pfn_brd_mem_map(hio_mgr->hwmd_context,
+						    pa_curr, va_curr,
+						    page_size[i], map_attrs);
+				if (DSP_FAILED(status))
+					goto func_end;
+				pa_curr += page_size[i];
+				va_curr += page_size[i];
+				gpp_va_curr += page_size[i];
+				num_bytes -= page_size[i];
+				/*
+				 * Don't try smaller sizes. Hopefully we have
 				 * reached an address aligned to a bigger page
-				 * size*/
+				 * size.
+				 */
 				break;
 			}
 		}
 	}
-	paCurr += ulPadSize;
-	vaCurr += ulPadSize;
-	gppVaCurr += ulPadSize;
-
-	/* configure the TLB entries for the next cacheable segment */
-	numBytes = ulSegSize;
-	vaCurr = ulDspVa * hIOMgr->uWordSize;
-	allBits = 0x0;
-	while (numBytes && DSP_SUCCEEDED(status)) {
-		/* To find the max. page size with which both PA & VA are
-		 * aligned*/
-		allBits = paCurr | vaCurr;
-		DBG_Trace(DBG_LEVEL1, "allBits for Seg1 %x, paCurr %x, "
-			 "vaCurr %x, numBytes %x\n", allBits, paCurr, vaCurr,
-			 numBytes);
+	pa_curr += ul_pad_size;
+	va_curr += ul_pad_size;
+	gpp_va_curr += ul_pad_size;
+
+	/* Configure the TLB entries for the next cacheable segment */
+	num_bytes = ul_seg_size;
+	va_curr = ul_dsp_va * hio_mgr->word_size;
+	while (num_bytes) {
+		/*
+		 * To find the max. page size with which both PA & VA are
+		 * aligned.
+		 */
+		all_bits = pa_curr | va_curr;
+		dev_dbg(bridge, "all_bits for Seg1 %x, pa_curr %x, "
+			"va_curr %x, num_bytes %x\n", all_bits, pa_curr,
+			va_curr, num_bytes);
 		for (i = 0; i < 4; i++) {
-			if (!(numBytes >= pgSize[i]) ||
-			   !((allBits & (pgSize[i]-1)) == 0))
+			if (!(num_bytes >= page_size[i]) ||
+			    !((all_bits & (page_size[i] - 1)) == 0))
 				continue;
 			if (ndx < MAX_LOCK_TLB_ENTRIES) {
-				/* This is the physical address written to
-				 * DSP MMU */
-				aEProc[ndx].ulGppPa = paCurr;
-				/* THIS IS THE VIRTUAL UNCACHED IOREMAPPED
-				 * ADDRESS!!! */
-				aEProc[ndx].ulGppVa = gppVaCurr;
-				aEProc[ndx].ulDspVa = vaCurr / hIOMgr->
-						      uWordSize;
-				aEProc[ndx].ulSize = pgSize[i];
-				aEProc[ndx].endianism = HW_LITTLE_ENDIAN;
-				aEProc[ndx].elemSize = HW_ELEM_SIZE_16BIT;
-				aEProc[ndx].mixedMode = HW_MMU_CPUES;
-				DBG_Trace(DBG_LEVEL1, "SHM MMU TLB entry PA %lx"
-					 " VA %lx DSP_VA %lx Size %lx\n",
-					 aEProc[ndx].ulGppPa,
-					 aEProc[ndx].ulGppVa,
-					 aEProc[ndx].ulDspVa *
-					 hIOMgr->uWordSize, pgSize[i]);
+				/*
+				 * This is the physical address written to
+				 * DSP MMU.
+				 */
+				ae_proc[ndx].ul_gpp_pa = pa_curr;
+				/*
+				 * This is the virtual uncached ioremapped
+				 * address!!!
+				 */
+				ae_proc[ndx].ul_gpp_va = gpp_va_curr;
+				ae_proc[ndx].ul_dsp_va =
+				    va_curr / hio_mgr->word_size;
+				ae_proc[ndx].ul_size = page_size[i];
+				ae_proc[ndx].endianism = HW_LITTLE_ENDIAN;
+				ae_proc[ndx].elem_size = HW_ELEM_SIZE16BIT;
+				ae_proc[ndx].mixed_mode = HW_MMU_CPUES;
+				dev_dbg(bridge, "shm MMU TLB entry PA %x"
+					" VA %x DSP_VA %x Size %x\n",
+					ae_proc[ndx].ul_gpp_pa,
+					ae_proc[ndx].ul_gpp_va,
+					ae_proc[ndx].ul_dsp_va *
+					hio_mgr->word_size, page_size[i]);
 				ndx++;
 			} else {
-				status = hIOMgr->pIntfFxns->pfnBrdMemMap(
-				hIOMgr->hWmdContext, paCurr, vaCurr, pgSize[i],
-					mapAttrs);
-				DBG_Trace(DBG_LEVEL1, "SHM MMU PTE entry PA %lx"
-					 " VA %lx DSP_VA %lx Size %lx\n",
-					 aEProc[ndx].ulGppPa,
-					 aEProc[ndx].ulGppVa,
-					 aEProc[ndx].ulDspVa *
-					 hIOMgr->uWordSize, pgSize[i]);
-				DBC_Assert(DSP_SUCCEEDED(status));
+				status =
+				    hio_mgr->intf_fxns->
+				    pfn_brd_mem_map(hio_mgr->hwmd_context,
+						    pa_curr, va_curr,
+						    page_size[i], map_attrs);
+				dev_dbg(bridge,
+					"shm MMU PTE entry PA %x"
+					" VA %x DSP_VA %x Size %x\n",
+					ae_proc[ndx].ul_gpp_pa,
+					ae_proc[ndx].ul_gpp_va,
+					ae_proc[ndx].ul_dsp_va *
+					hio_mgr->word_size, page_size[i]);
+				if (DSP_FAILED(status)) {
+					goto func_end;
+				}
 			}
-			paCurr += pgSize[i];
-			vaCurr += pgSize[i];
-			gppVaCurr += pgSize[i];
-			numBytes -= pgSize[i];
-			/* Don't try smaller sizes. Hopefully we have reached
-			 an address aligned to a bigger page size*/
+			pa_curr += page_size[i];
+			va_curr += page_size[i];
+			gpp_va_curr += page_size[i];
+			num_bytes -= page_size[i];
+			/*
+			 * Don't try smaller sizes. Hopefully we have reached
+			 * an address aligned to a bigger page size.
+			 */
 			break;
 		}
 	}
 
-	 /* Copy remaining entries from CDB. All entries are 1 MB and should not
-	 * conflict with SHM entries on MPU or DSP side */
-	for (i = 3; i < 7 && ndx < WMDIOCTL_NUMOFMMUTLB &&
-	    DSP_SUCCEEDED(status); i++) {
-		if (hIOMgr->extProcInfo.tyTlb[i].ulGppPhys == 0)
+	/*
+	 * Copy remaining entries from CDB. All entries are 1 MB and
+	 * should not conflict with shm entries on MPU or DSP side.
+	 */
+	for (i = 3; i < 7 && ndx < WMDIOCTL_NUMOFMMUTLB; i++) {
+		if (hio_mgr->ext_proc_info.ty_tlb[i].ul_gpp_phys == 0)
 			continue;
 
-		if ((hIOMgr->extProcInfo.tyTlb[i].ulGppPhys > ulGppPa - 0x100000
-			&& hIOMgr->extProcInfo.tyTlb[i].ulGppPhys <=
-				ulGppPa + ulSegSize)
-			|| (hIOMgr->extProcInfo.tyTlb[i].ulDspVirt > ulDspVa -
-				0x100000 / hIOMgr->uWordSize && hIOMgr->
-				extProcInfo.tyTlb[i].ulDspVirt
-				<= ulDspVa + ulSegSize / hIOMgr->uWordSize)) {
-			DBG_Trace(DBG_LEVEL7, "CDB MMU entry %d conflicts with "
-				 "SHM.\n\tCDB: GppPa %x, DspVa %x.\n\tSHM: "
-				 "GppPa %x, DspVa %x, Bytes %x.\n", i,
-				 hIOMgr->extProcInfo.tyTlb[i].ulGppPhys,
-				 hIOMgr->extProcInfo.tyTlb[i].ulDspVirt,
-				 ulGppPa, ulDspVa, ulSegSize);
+		if ((hio_mgr->ext_proc_info.ty_tlb[i].ul_gpp_phys >
+		     ul_gpp_pa - 0x100000
+		     && hio_mgr->ext_proc_info.ty_tlb[i].ul_gpp_phys <=
+		     ul_gpp_pa + ul_seg_size)
+		    || (hio_mgr->ext_proc_info.ty_tlb[i].ul_dsp_virt >
+			ul_dsp_va - 0x100000 / hio_mgr->word_size
+			&& hio_mgr->ext_proc_info.ty_tlb[i].ul_dsp_virt <=
+			ul_dsp_va + ul_seg_size / hio_mgr->word_size)) {
+			dev_dbg(bridge,
+				"CDB MMU entry %d conflicts with "
+				"shm.\n\tCDB: GppPa %x, DspVa %x.\n\tSHM: "
+				"GppPa %x, DspVa %x, Bytes %x.\n", i,
+				hio_mgr->ext_proc_info.ty_tlb[i].ul_gpp_phys,
+				hio_mgr->ext_proc_info.ty_tlb[i].ul_dsp_virt,
+				ul_gpp_pa, ul_dsp_va, ul_seg_size);
 			status = DSP_EFAIL;
 		} else {
 			if (ndx < MAX_LOCK_TLB_ENTRIES) {
-				aEProc[ndx].ulDspVa = hIOMgr->extProcInfo.
-					tyTlb[i].ulDspVirt;
-				aEProc[ndx].ulGppPa = hIOMgr->extProcInfo.
-					tyTlb[i].ulGppPhys;
-				aEProc[ndx].ulGppVa = 0;
-				/* Can't convert, so set to zero*/
-				aEProc[ndx].ulSize = 0x100000; 	/* 1 MB*/
-				DBG_Trace(DBG_LEVEL1, "SHM MMU entry PA %x "
-					 "DSP_VA 0x%x\n", aEProc[ndx].ulGppPa,
-					aEProc[ndx].ulDspVa);
+				ae_proc[ndx].ul_dsp_va =
+				    hio_mgr->ext_proc_info.ty_tlb[i].
+				    ul_dsp_virt;
+				ae_proc[ndx].ul_gpp_pa =
+				    hio_mgr->ext_proc_info.ty_tlb[i].
+				    ul_gpp_phys;
+				ae_proc[ndx].ul_gpp_va = 0;
+				/* 1 MB */
+				ae_proc[ndx].ul_size = 0x100000;
+				dev_dbg(bridge, "shm MMU entry PA %x "
+					"DSP_VA 0x%x\n", ae_proc[ndx].ul_gpp_pa,
+					ae_proc[ndx].ul_dsp_va);
 				ndx++;
 			} else {
-				status = hIOMgr->pIntfFxns->pfnBrdMemMap
-					(hIOMgr->hWmdContext,
-					hIOMgr->extProcInfo.tyTlb[i].ulGppPhys,
-					hIOMgr->extProcInfo.tyTlb[i].ulDspVirt,
-					0x100000, mapAttrs);
+				status = hio_mgr->intf_fxns->pfn_brd_mem_map
+				    (hio_mgr->hwmd_context,
+				     hio_mgr->ext_proc_info.ty_tlb[i].
+				     ul_gpp_phys,
+				     hio_mgr->ext_proc_info.ty_tlb[i].
+				     ul_dsp_virt, 0x100000, map_attrs);
 			}
 		}
+		if (DSP_FAILED(status))
+			goto func_end;
 	}
-	if (i < 7 && DSP_SUCCEEDED(status)) {
-		/* All CDB entries could not be made*/
-		status = DSP_EFAIL;
-	}
-func_cont:
-	mapAttrs = 0x00000000;
-	mapAttrs = DSP_MAPLITTLEENDIAN;
-	mapAttrs |= DSP_MAPPHYSICALADDR;
-	mapAttrs |= DSP_MAPELEMSIZE32;
-	mapAttrs |= DSP_MAPDONOTLOCK;
+
+	map_attrs = 0x00000000;
+	map_attrs = DSP_MAPLITTLEENDIAN;
+	map_attrs |= DSP_MAPPHYSICALADDR;
+	map_attrs |= DSP_MAPELEMSIZE32;
+	map_attrs |= DSP_MAPDONOTLOCK;
 
 	/* Map the L4 peripherals */
 	i = 0;
-	while (L4PeripheralTable[i].physAddr && DSP_SUCCEEDED(status)) {
-		status = hIOMgr->pIntfFxns->pfnBrdMemMap
-			(hIOMgr->hWmdContext, L4PeripheralTable[i].physAddr,
-			L4PeripheralTable[i].dspVirtAddr, HW_PAGE_SIZE_4KB,
-			mapAttrs);
+	while (l4_peripheral_table[i].phys_addr) {
+		status = hio_mgr->intf_fxns->pfn_brd_mem_map
+		    (hio_mgr->hwmd_context, l4_peripheral_table[i].phys_addr,
+		     l4_peripheral_table[i].dsp_virt_addr, HW_PAGE_SIZE4KB,
+		     map_attrs);
 		if (DSP_FAILED(status))
-			break;
+			goto func_end;
 		i++;
 	}
 
-	if (DSP_SUCCEEDED(status)) {
-		for (i = ndx; i < WMDIOCTL_NUMOFMMUTLB; i++) {
-			aEProc[i].ulDspVa = 0;
-			aEProc[i].ulGppPa = 0;
-			aEProc[i].ulGppVa = 0;
-			aEProc[i].ulSize = 0;
-		}
-		/* Set the SHM physical address entry (grayed out in CDB file)
-		 * to the virtual uncached ioremapped address of SHM reserved
-		 * on MPU */
-		hIOMgr->extProcInfo.tyTlb[0].ulGppPhys = (ulGppVa + ulSeg1Size +
-							 ulPadSize);
-		DBG_Trace(DBG_LEVEL1, "*********extProcInfo *********%x \n",
-			  hIOMgr->extProcInfo.tyTlb[0].ulGppPhys);
-		/* Need SHM Phys addr. IO supports only one DSP for now:
-		 * uNumProcs=1 */
-		if ((hIOMgr->extProcInfo.tyTlb[0].ulGppPhys == 0) ||
-		   (uNumProcs != 1)) {
-			status = CHNL_E_NOMEMMAP;
-			DBC_Assert(false);
-		} else {
-			DBC_Assert(aEProc[0].ulDspVa <= ulShmBase);
-			/* ulShmBase may not be at ulDspVa address */
-			ulShmBaseOffset = (ulShmBase - aEProc[0].ulDspVa) *
-			    hIOMgr->uWordSize;
-			 /* WMD_BRD_Ctrl() will set dev context dsp-mmu info. In
-			 *   _BRD_Start() the MMU will be re-programed with MMU
-			 *   DSPVa-GPPPa pair info while DSP is in a known
-			 *   (reset) state.  */
-			DBC_Assert(hIOMgr->pIntfFxns != NULL);
-			DBC_Assert(hIOMgr->hWmdContext != NULL);
-			status = hIOMgr->pIntfFxns->pfnDevCntrl(hIOMgr->
-				 hWmdContext, WMDIOCTL_SETMMUCONFIG, aEProc);
-			ulShmBase = hIOMgr->extProcInfo.tyTlb[0].ulGppPhys;
-			DBG_Trace(DBG_LEVEL1, "extProcInfo.tyTlb[0].ulGppPhys "
-				 "%x \n ", hIOMgr->extProcInfo.tyTlb[0].
-				 ulGppPhys);
-			ulShmBase += ulShmBaseOffset;
-			ulShmBase = (u32)MEM_LinearAddress((void *)ulShmBase,
-				    ulMemLength);
-			DBC_Assert(ulShmBase != 0);
-			if (DSP_SUCCEEDED(status)) {
-				status = registerSHMSegs(hIOMgr, hCodMan,
-					 aEProc[0].ulGppPa);
-				/* Register SM */
-			}
-		}
+	for (i = ndx; i < WMDIOCTL_NUMOFMMUTLB; i++) {
+		ae_proc[i].ul_dsp_va = 0;
+		ae_proc[i].ul_gpp_pa = 0;
+		ae_proc[i].ul_gpp_va = 0;
+		ae_proc[i].ul_size = 0;
 	}
-	if (DSP_SUCCEEDED(status)) {
-		hIOMgr->pSharedMem = (struct SHM *)ulShmBase;
-		hIOMgr->pInput = (u8 *)hIOMgr->pSharedMem +
-				 sizeof(struct SHM);
-		hIOMgr->pOutput = hIOMgr->pInput + (ulShmLength -
-				  sizeof(struct SHM))/2;
-		hIOMgr->uSMBufSize = hIOMgr->pOutput - hIOMgr->pInput;
-		DBG_Trace(DBG_LEVEL3,
-			 "hIOMgr: pInput %p pOutput %p ulShmLength %x\n",
-			 hIOMgr->pInput, hIOMgr->pOutput, ulShmLength);
-		DBG_Trace(DBG_LEVEL3,
-			 "pSharedMem %p uSMBufSize %x sizeof(SHM) %x\n",
-			 hIOMgr->pSharedMem, hIOMgr->uSMBufSize,
-			 sizeof(struct SHM));
-		 /*  Set up Shared memory addresses for messaging. */
-		hIOMgr->pMsgInputCtrl = (struct MSG *)((u8 *)
-					hIOMgr->pSharedMem +
-					ulShmLength);
-		hIOMgr->pMsgInput = (u8 *)hIOMgr->pMsgInputCtrl +
-				    sizeof(struct MSG);
-		hIOMgr->pMsgOutputCtrl = (struct MSG *)((u8 *)hIOMgr->
-					 pMsgInputCtrl + ulMsgLength / 2);
-		hIOMgr->pMsgOutput = (u8 *)hIOMgr->pMsgOutputCtrl +
-				     sizeof(struct MSG);
-		hMsgMgr->uMaxMsgs = ((u8 *)hIOMgr->pMsgOutputCtrl -
-				    hIOMgr->pMsgInput) /
-				    sizeof(struct MSG_DSPMSG);
-		DBG_Trace(DBG_LEVEL7, "IO MGR SHM details : pSharedMem 0x%x, "
-			 "pInput 0x%x, pOutput 0x%x, pMsgInputCtrl 0x%x, "
-			 "pMsgInput 0x%x, pMsgOutputCtrl 0x%x, pMsgOutput "
-			 "0x%x \n", (u8 *)hIOMgr->pSharedMem,
-			 (u8 *)hIOMgr->pInput, (u8 *)hIOMgr->pOutput,
-			 (u8 *)hIOMgr->pMsgInputCtrl,
-			 (u8 *)hIOMgr->pMsgInput,
-			 (u8 *)hIOMgr->pMsgOutputCtrl,
-			 (u8 *)hIOMgr->pMsgOutput);
-		DBG_Trace(DBG_LEVEL7, "** (proc) MAX MSGS IN SHARED MEMORY: "
-			 "0x%x\n", hMsgMgr->uMaxMsgs);
-		memset((void *) hIOMgr->pSharedMem, 0, sizeof(struct SHM));
-	}
-#ifndef DSP_TRACEBUF_DISABLED
-	if (DSP_SUCCEEDED(status)) {
-		/* Get the start address of trace buffer */
-		if (DSP_SUCCEEDED(status)) {
-			status = COD_GetSymValue(hCodMan, SYS_PUTCBEG,
-				 &hIOMgr->ulTraceBufferBegin);
-			if (DSP_FAILED(status))
-				status = CHNL_E_NOMEMMAP;
+	/*
+	 * Set the shm physical address entry (grayed out in CDB file)
+	 * to the virtual uncached ioremapped address of shm reserved
+	 * on MPU.
+	 */
+	hio_mgr->ext_proc_info.ty_tlb[0].ul_gpp_phys =
+	    (ul_gpp_va + ul_seg1_size + ul_pad_size);
 
+	/*
+	 * Need shm Phys addr. IO supports only one DSP for now:
+	 * num_procs = 1.
+	 */
+	if (!hio_mgr->ext_proc_info.ty_tlb[0].ul_gpp_phys || num_procs != 1) {
+		status = CHNL_E_NOMEMMAP;
+		goto func_end;
+	} else {
+		if (ae_proc[0].ul_dsp_va > ul_shm_base) {
+			status = DSP_EFAIL;
+			goto func_end;
 		}
-		hIOMgr->ulGPPReadPointer = hIOMgr->ulTraceBufferBegin =
-			(ulGppVa + ulSeg1Size + ulPadSize) +
-			(hIOMgr->ulTraceBufferBegin - ulDspVa);
-		/* Get the end address of trace buffer */
-		if (DSP_SUCCEEDED(status)) {
-			status = COD_GetSymValue(hCodMan, SYS_PUTCEND,
-				 &hIOMgr->ulTraceBufferEnd);
-			if (DSP_FAILED(status))
-				status = CHNL_E_NOMEMMAP;
+		/* ul_shm_base may not be at ul_dsp_va address */
+		ul_shm_base_offset = (ul_shm_base - ae_proc[0].ul_dsp_va) *
+		    hio_mgr->word_size;
+		/*
+		 * WMD_BRD_Ctrl() will set dev context dsp-mmu info. In
+		 * _BRD_Start() the MMU will be re-programed with MMU
+		 * DSPVa-GPPPa pair info while DSP is in a known
+		 * (reset) state.
+		 */
+
+		status =
+		    hio_mgr->intf_fxns->pfn_dev_cntrl(hio_mgr->hwmd_context,
+						      WMDIOCTL_SETMMUCONFIG,
+						      ae_proc);
+		if (DSP_FAILED(status))
+			goto func_end;
+		ul_shm_base = hio_mgr->ext_proc_info.ty_tlb[0].ul_gpp_phys;
+		ul_shm_base += ul_shm_base_offset;
+		ul_shm_base = (u32) MEM_LINEAR_ADDRESS((void *)ul_shm_base,
+						       ul_mem_length);
+		if (ul_shm_base == 0) {
+			status = DSP_EPOINTER;
+			goto func_end;
+		}
+		/* Register SM */
+		status =
+		    register_shm_segs(hio_mgr, cod_man, ae_proc[0].ul_gpp_pa);
+	}
+
+	hio_mgr->shared_mem = (struct shm *)ul_shm_base;
+	hio_mgr->input = (u8 *) hio_mgr->shared_mem + sizeof(struct shm);
+	hio_mgr->output = hio_mgr->input + (ul_shm_length -
+					    sizeof(struct shm)) / 2;
+	hio_mgr->usm_buf_size = hio_mgr->output - hio_mgr->input;
+
+	/*  Set up Shared memory addresses for messaging. */
+	hio_mgr->msg_input_ctrl = (struct msg_ctrl *)((u8 *) hio_mgr->shared_mem
+						      + ul_shm_length);
+	hio_mgr->msg_input =
+	    (u8 *) hio_mgr->msg_input_ctrl + sizeof(struct msg_ctrl);
+	hio_mgr->msg_output_ctrl =
+	    (struct msg_ctrl *)((u8 *) hio_mgr->msg_input_ctrl +
+				ul_msg_length / 2);
+	hio_mgr->msg_output =
+	    (u8 *) hio_mgr->msg_output_ctrl + sizeof(struct msg_ctrl);
+	hmsg_mgr->max_msgs =
+	    ((u8 *) hio_mgr->msg_output_ctrl - hio_mgr->msg_input)
+	    / sizeof(struct msg_dspmsg);
+	dev_dbg(bridge, "IO MGR shm details: shared_mem %p, input %p, "
+		"output %p, msg_input_ctrl %p, msg_input %p, "
+		"msg_output_ctrl %p, msg_output %p\n",
+		(u8 *) hio_mgr->shared_mem, hio_mgr->input,
+		hio_mgr->output, (u8 *) hio_mgr->msg_input_ctrl,
+		hio_mgr->msg_input, (u8 *) hio_mgr->msg_output_ctrl,
+		hio_mgr->msg_output);
+	dev_dbg(bridge, "(proc) Mas msgs in shared memory: 0x%x\n",
+		hmsg_mgr->max_msgs);
+	memset((void *)hio_mgr->shared_mem, 0, sizeof(struct shm));
 
-		}
-		hIOMgr->ulTraceBufferEnd = (ulGppVa + ulSeg1Size + ulPadSize) +
-					   (hIOMgr->ulTraceBufferEnd - ulDspVa);
-		/* Get the current address of DSP write pointer */
-		if (DSP_SUCCEEDED(status)) {
-			status = COD_GetSymValue(hCodMan,
-				 BRIDGE_SYS_PUTC_current,
-				 &hIOMgr->ulTraceBufferCurrent);
-			if (DSP_FAILED(status))
-				status = CHNL_E_NOMEMMAP;
-
-		}
-		hIOMgr->ulTraceBufferCurrent = (ulGppVa + ulSeg1Size +
-						ulPadSize) + (hIOMgr->
-						ulTraceBufferCurrent - ulDspVa);
-		/* Calculate the size of trace buffer */
-		if (hIOMgr->pMsg)
-			MEM_Free(hIOMgr->pMsg);
-		hIOMgr->pMsg = MEM_Alloc(((hIOMgr->ulTraceBufferEnd -
-					hIOMgr->ulTraceBufferBegin) *
-					hIOMgr->uWordSize) + 2, MEM_NONPAGED);
-		if (!hIOMgr->pMsg)
-			status = DSP_EMEMORY;
+#ifndef DSP_TRACEBUF_DISABLED
+	/* Get the start address of trace buffer */
+	status = cod_get_sym_value(cod_man, SYS_PUTCBEG,
+				   &hio_mgr->ul_trace_buffer_begin);
+	if (DSP_FAILED(status)) {
+		status = CHNL_E_NOMEMMAP;
+		goto func_end;
+	}
+
+	hio_mgr->ul_gpp_read_pointer = hio_mgr->ul_trace_buffer_begin =
+	    (ul_gpp_va + ul_seg1_size + ul_pad_size) +
+	    (hio_mgr->ul_trace_buffer_begin - ul_dsp_va);
+	/* Get the end address of trace buffer */
+	status = cod_get_sym_value(cod_man, SYS_PUTCEND,
+				   &hio_mgr->ul_trace_buffer_end);
+	if (DSP_FAILED(status)) {
+		status = CHNL_E_NOMEMMAP;
+		goto func_end;
+	}
+	hio_mgr->ul_trace_buffer_end =
+	    (ul_gpp_va + ul_seg1_size + ul_pad_size) +
+	    (hio_mgr->ul_trace_buffer_end - ul_dsp_va);
+	/* Get the current address of DSP write pointer */
+	status = cod_get_sym_value(cod_man, BRIDGE_SYS_PUTC_CURRENT,
+				   &hio_mgr->ul_trace_buffer_current);
+	if (DSP_FAILED(status)) {
+		status = CHNL_E_NOMEMMAP;
+		goto func_end;
+	}
+	hio_mgr->ul_trace_buffer_current =
+	    (ul_gpp_va + ul_seg1_size + ul_pad_size) +
+	    (hio_mgr->ul_trace_buffer_current - ul_dsp_va);
+	/* Calculate the size of trace buffer */
+	kfree(hio_mgr->pmsg);
+	hio_mgr->pmsg = mem_alloc(((hio_mgr->ul_trace_buffer_end -
+				    hio_mgr->ul_trace_buffer_begin) *
+				   hio_mgr->word_size) + 2, MEM_NONPAGED);
+	if (!hio_mgr->pmsg)
+		status = DSP_EMEMORY;
+
+	hio_mgr->ul_dsp_va = ul_dsp_va;
+	hio_mgr->ul_gpp_va = (ul_gpp_va + ul_seg1_size + ul_pad_size);
 
-		DBG_Trace(DBG_LEVEL1, "** hIOMgr->pMsg: 0x%x\n", hIOMgr->pMsg);
-		hIOMgr->ulDspVa = ulDspVa;
-		hIOMgr->ulGppVa = (ulGppVa + ulSeg1Size + ulPadSize);
-    }
 #endif
-	IO_EnableInterrupt(hIOMgr->hWmdContext);
+func_end:
 	return status;
 }
 
 /*
- *  ======== IO_BufSize ========
+ *  ======== io_buf_size ========
  *      Size of shared memory I/O channel.
  */
-u32 IO_BufSize(struct IO_MGR *hIOMgr)
+u32 io_buf_size(struct io_mgr *hio_mgr)
 {
-	DBC_Require(MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE));
-
-	return hIOMgr->uSMBufSize;
+	if (MEM_IS_VALID_HANDLE(hio_mgr, IO_MGRSIGNATURE))
+		return hio_mgr->usm_buf_size;
+	else
+		return 0;
 }
 
 /*
- *  ======== IO_CancelChnl ========
+ *  ======== io_cancel_chnl ========
  *      Cancel IO on a given PCPY channel.
  */
-void IO_CancelChnl(struct IO_MGR *hIOMgr, u32 ulChnl)
+void io_cancel_chnl(struct io_mgr *hio_mgr, u32 ulChnl)
 {
-	struct IO_MGR *pIOMgr = (struct IO_MGR *)hIOMgr;
-	struct SHM *sm;
+	struct io_mgr *pio_mgr = (struct io_mgr *)hio_mgr;
+	struct shm *sm;
 
-	DBC_Require(MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE));
-	sm = hIOMgr->pSharedMem;
+	if (!MEM_IS_VALID_HANDLE(hio_mgr, IO_MGRSIGNATURE))
+		goto func_end;
+	sm = hio_mgr->shared_mem;
 
-	/* Inform DSP that we have no more buffers on this channel:  */
-	IO_AndValue(pIOMgr->hWmdContext, struct SHM, sm, hostFreeMask,
-		   (~(1 << ulChnl)));
+	/* Inform DSP that we have no more buffers on this channel */
+	IO_AND_VALUE(pio_mgr->hwmd_context, struct shm, sm, host_free_mask,
+		     (~(1 << ulChnl)));
 
-	CHNLSM_InterruptDSP2(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
+	sm_interrupt_dsp(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
+func_end:
+	return;
 }
 
 /*
- *  ======== IO_DispatchChnl ========
+ *  ======== io_dispatch_chnl ========
  *      Proc-copy chanl dispatch.
  */
-static void IO_DispatchChnl(IN struct IO_MGR *pIOMgr,
-			   IN OUT struct CHNL_OBJECT *pChnl, u32 iMode)
+static void io_dispatch_chnl(IN struct io_mgr *pio_mgr,
+			     IN OUT struct chnl_object *pchnl, u32 iMode)
 {
-	DBC_Require(MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE));
-
-	DBG_Trace(DBG_LEVEL3, "Entering IO_DispatchChnl \n");
+	if (!MEM_IS_VALID_HANDLE(pio_mgr, IO_MGRSIGNATURE))
+		goto func_end;
 
-	/* See if there is any data available for transfer: */
-	DBC_Assert(iMode == IO_SERVICE);
+	/* See if there is any data available for transfer */
+	if (iMode != IO_SERVICE)
+		goto func_end;
 
-	/* Any channel will do for this mode: */
-	InputChnl(pIOMgr, pChnl, iMode);
-	OutputChnl(pIOMgr, pChnl, iMode);
+	/* Any channel will do for this mode */
+	input_chnl(pio_mgr, pchnl, iMode);
+	output_chnl(pio_mgr, pchnl, iMode);
+func_end:
+	return;
 }
 
 /*
- *  ======== IO_DispatchMsg ========
+ *  ======== io_dispatch_msg ========
  *      Performs I/O dispatch on message queues.
  */
-static void IO_DispatchMsg(IN struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr)
+static void io_dispatch_msg(IN struct io_mgr *pio_mgr, struct msg_mgr *hmsg_mgr)
 {
-	DBC_Require(MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE));
-
-	DBG_Trace(DBG_LEVEL3, "Entering IO_DispatchMsg \n");
+	if (!MEM_IS_VALID_HANDLE(pio_mgr, IO_MGRSIGNATURE))
+		goto func_end;
 
-	/*  We are performing both input and output processing. */
-	InputMsg(pIOMgr, hMsgMgr);
-	OutputMsg(pIOMgr, hMsgMgr);
+	/* We are performing both input and output processing. */
+	input_msg(pio_mgr, hmsg_mgr);
+	output_msg(pio_mgr, hmsg_mgr);
+func_end:
+	return;
 }
 
 /*
- *  ======== IO_DispatchPM ========
+ *  ======== io_dispatch_pm ========
  *      Performs I/O dispatch on PM related messages from DSP
  */
-static void IO_DispatchPM(struct work_struct *work)
+static void io_dispatch_pm(struct io_mgr *pio_mgr)
 {
-       struct IO_MGR *pIOMgr =
-                               container_of(work, struct IO_MGR, io_workq);
-	DSP_STATUS status;
-	u32 pArg[2];
-
-       /*DBC_Require(MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE));*/
-
-	DBG_Trace(DBG_LEVEL7, "IO_DispatchPM: Entering IO_DispatchPM : \n");
-
-	/*  Perform Power message processing here  */
-	while (pIOMgr->iQuePowerHead != pIOMgr->iQuePowerTail) {
-		pArg[0] = *(u32 *)&(pIOMgr->dQuePowerMbxVal[pIOMgr->
-			  iQuePowerTail]);
-		DBG_Trace(DBG_LEVEL7, "IO_DispatchPM - pArg[0] - 0x%x: \n",
-			 pArg[0]);
-		/* Send the command to the WMD clk/pwr manager to handle */
-		if (pArg[0] ==  MBX_PM_HIBERNATE_EN) {
-			DBG_Trace(DBG_LEVEL7, "IO_DispatchPM : Hibernate "
-				 "command\n");
-			status = pIOMgr->pIntfFxns->pfnDevCntrl(pIOMgr->
-				 hWmdContext, WMDIOCTL_PWR_HIBERNATE, pArg);
-			if (DSP_FAILED(status)) {
-				DBG_Trace(DBG_LEVEL7, "IO_DispatchPM : "
-					 "Hibernation command failed\n");
-			}
-		} else if (pArg[0] == MBX_PM_OPP_REQ) {
-			pArg[1] = pIOMgr->pSharedMem->oppRequest.rqstOppPt;
-			DBG_Trace(DBG_LEVEL7, "IO_DispatchPM : Value of OPP "
-				 "value =0x%x \n", pArg[1]);
-			status = pIOMgr->pIntfFxns->pfnDevCntrl(pIOMgr->
-				 hWmdContext, WMDIOCTL_CONSTRAINT_REQUEST,
-				 pArg);
-			if (DSP_FAILED(status)) {
-				DBG_Trace(DBG_LEVEL7, "IO_DispatchPM : Failed "
-					 "to set constraint = 0x%x \n",
-					 pArg[1]);
-			}
+	dsp_status status;
+	u32 parg[2];
 
-		} else {
-			DBG_Trace(DBG_LEVEL7, "IO_DispatchPM - clock control - "
-				 "value of msg = 0x%x: \n", pArg[0]);
-			status = pIOMgr->pIntfFxns->pfnDevCntrl(pIOMgr->
-				 hWmdContext, WMDIOCTL_CLK_CTRL, pArg);
-			if (DSP_FAILED(status)) {
-				DBG_Trace(DBG_LEVEL7, "IO_DispatchPM : Failed "
-					 "to control the DSP clk = 0x%x \n",
-					 *pArg);
-			}
-		}
-		/* increment the tail count here */
-		pIOMgr->iQuePowerTail++;
-		if (pIOMgr->iQuePowerTail >= MAX_PM_REQS)
-			pIOMgr->iQuePowerTail = 0;
+	/* Perform Power message processing here */
+	parg[0] = pio_mgr->intr_val;
 
+	/* Send the command to the WMD clk/pwr manager to handle */
+	if (parg[0] == MBX_PM_HIBERNATE_EN) {
+		dev_dbg(bridge, "PM: Hibernate command\n");
+		status = pio_mgr->intf_fxns->
+				pfn_dev_cntrl(pio_mgr->hwmd_context,
+					      WMDIOCTL_PWR_HIBERNATE, parg);
+		if (DSP_FAILED(status))
+			dev_dbg(bridge, "hibernate cmd failed 0x%x\n", status);
+	} else if (parg[0] == MBX_PM_OPP_REQ) {
+		parg[1] = pio_mgr->shared_mem->opp_request.rqst_opp_pt;
+		dev_dbg(bridge, "PM: Requested OPP = 0x%x\n", parg[1]);
+		status = pio_mgr->intf_fxns->
+				pfn_dev_cntrl(pio_mgr->hwmd_context,
+					WMDIOCTL_CONSTRAINT_REQUEST, parg);
+		if (DSP_FAILED(status))
+			dev_dbg(bridge, "PM: Failed to set constraint "
+				"= 0x%x \n", parg[1]);
+	} else {
+		dev_dbg(bridge, "PM: clk control value of msg = 0x%x\n",
+			parg[0]);
+		status = pio_mgr->intf_fxns->
+				pfn_dev_cntrl(pio_mgr->hwmd_context,
+					      WMDIOCTL_CLK_CTRL, parg);
+		if (DSP_FAILED(status))
+			dev_dbg(bridge, "PM: Failed to ctrl the DSP clk"
+				"= 0x%x\n", *parg);
 	}
-
 }
 
 /*
- *  ======== IO_DPC ========
+ *  ======== io_dpc ========
  *      Deferred procedure call for shared memory channel driver ISR.  Carries
  *      out the dispatch of I/O as a non-preemptible event.It can only be
  *      pre-empted      by an ISR.
  */
-void IO_DPC(IN OUT void *pRefData)
+void io_dpc(IN OUT unsigned long pRefData)
 {
-	struct IO_MGR *pIOMgr = (struct IO_MGR *)pRefData;
-	struct CHNL_MGR *pChnlMgr;
-	struct MSG_MGR *pMsgMgr;
-	struct DEH_MGR *hDehMgr;
-
-	DBC_Require(MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE));
-	pChnlMgr = pIOMgr->hChnlMgr;
-	DEV_GetMsgMgr(pIOMgr->hDevObject, &pMsgMgr);
-	DEV_GetDehMgr(pIOMgr->hDevObject, &hDehMgr);
-	DBC_Require(MEM_IsValidHandle(pChnlMgr, CHNL_MGRSIGNATURE));
-	DBG_Trace(DBG_LEVEL7, "Entering IO_DPC(0x%x)\n", pRefData);
-	/* Check value of interrupt register to ensure it is a valid error */
-	if ((pIOMgr->wIntrVal > DEH_BASE) && (pIOMgr->wIntrVal < DEH_LIMIT)) {
-		/* notify DSP/BIOS exception */
-		if (hDehMgr)
-			WMD_DEH_Notify(hDehMgr, DSP_SYSERROR, pIOMgr->wIntrVal);
+	struct io_mgr *pio_mgr = (struct io_mgr *)pRefData;
+	struct chnl_mgr *chnl_mgr_obj;
+	struct msg_mgr *msg_mgr_obj;
+	struct deh_mgr *hdeh_mgr;
+	u32 requested;
+	u32 serviced;
 
-	}
-	IO_DispatchChnl(pIOMgr, NULL, IO_SERVICE);
+	if (!MEM_IS_VALID_HANDLE(pio_mgr, IO_MGRSIGNATURE))
+		goto func_end;
+	chnl_mgr_obj = pio_mgr->hchnl_mgr;
+	dev_get_msg_mgr(pio_mgr->hdev_obj, &msg_mgr_obj);
+	dev_get_deh_mgr(pio_mgr->hdev_obj, &hdeh_mgr);
+	if (!MEM_IS_VALID_HANDLE(chnl_mgr_obj, CHNL_MGRSIGNATURE))
+		goto func_end;
+
+	requested = pio_mgr->dpc_req;
+	serviced = pio_mgr->dpc_sched;
+
+	if (serviced == requested)
+		goto func_end;
+
+	/* Process pending DPC's */
+	do {
+		/* Check value of interrupt reg to ensure it's a valid error */
+		if ((pio_mgr->intr_val > DEH_BASE) &&
+		    (pio_mgr->intr_val < DEH_LIMIT)) {
+			/* Notify DSP/BIOS exception */
+			if (hdeh_mgr)
+				bridge_deh_notify(hdeh_mgr, DSP_SYSERROR,
+						  pio_mgr->intr_val);
+		}
+		io_dispatch_chnl(pio_mgr, NULL, IO_SERVICE);
 #ifdef CHNL_MESSAGES
-	if (pMsgMgr) {
-		DBC_Require(MEM_IsValidHandle(pMsgMgr, MSGMGR_SIGNATURE));
-		IO_DispatchMsg(pIOMgr, pMsgMgr);
-	}
+		if (MEM_IS_VALID_HANDLE(msg_mgr_obj, MSGMGR_SIGNATURE))
+			io_dispatch_msg(pio_mgr, msg_mgr_obj);
 #endif
 #ifndef DSP_TRACEBUF_DISABLED
-	if (pIOMgr->wIntrVal & MBX_DBG_CLASS) {
-		/* notify DSP Trace message */
-		if (pIOMgr->wIntrVal & MBX_DBG_SYSPRINTF)
-			PrintDSPDebugTrace(pIOMgr);
-	}
-#endif
-
-#ifndef DSP_TRACEBUF_DISABLED
-	PrintDSPDebugTrace(pIOMgr);
+		if (pio_mgr->intr_val & MBX_DBG_SYSPRINTF) {
+			/* Notify DSP Trace message */
+			print_dsp_debug_trace(pio_mgr);
+		}
 #endif
+		serviced++;
+	} while (serviced != requested);
+	pio_mgr->dpc_sched = requested;
+func_end:
+	return;
 }
 
-
 /*
- *  ======== IO_ISR ========
+ *  ======== io_mbox_msg ========
  *      Main interrupt handler for the shared memory IO manager.
  *      Calls the WMD's CHNL_ISR to determine if this interrupt is ours, then
  *      schedules a DPC to dispatch I/O.
  */
-irqreturn_t IO_ISR(int irq, IN void *pRefData)
+void io_mbox_msg(u32 msg)
 {
-	struct IO_MGR *hIOMgr = (struct IO_MGR *)pRefData;
-	bool fSchedDPC;
-       DBC_Require(irq == INT_MAIL_MPU_IRQ);
-	DBC_Require(MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE));
-	DBG_Trace(DBG_LEVEL3, "Entering IO_ISR(0x%x)\n", pRefData);
-
-	/* Call WMD's CHNLSM_ISR() to see if interrupt is ours, and process. */
-	if (IO_CALLISR(hIOMgr->hWmdContext, &fSchedDPC, &hIOMgr->wIntrVal)) {
-		{
-			DBG_Trace(DBG_LEVEL3, "IO_ISR %x\n", hIOMgr->wIntrVal);
-			if (hIOMgr->wIntrVal & MBX_PM_CLASS) {
-				hIOMgr->dQuePowerMbxVal[hIOMgr->iQuePowerHead] =
-					hIOMgr->wIntrVal;
-				hIOMgr->iQuePowerHead++;
-				if (hIOMgr->iQuePowerHead >= MAX_PM_REQS)
-					hIOMgr->iQuePowerHead = 0;
+	struct io_mgr *pio_mgr;
+	struct dev_object *dev_obj;
+	unsigned long flags;
 
-                               queue_work(bridge_workqueue, &hIOMgr->io_workq);
-			}
-			if (hIOMgr->wIntrVal == MBX_DEH_RESET) {
-				DBG_Trace(DBG_LEVEL6, "*** DSP RESET ***\n");
-				hIOMgr->wIntrVal = 0;
-			} else if (fSchedDPC) {
-				/* PROC-COPY defer i/o  */
-				DPC_Schedule(hIOMgr->hDPC);
-			}
-		}
-       } else
-		/* Ensure that, if WMD didn't claim it, the IRQ is shared. */
-		DBC_Ensure(hIOMgr->fSharedIRQ);
-       return IRQ_HANDLED;
+	dev_obj = dev_get_first();
+	dev_get_io_mgr(dev_obj, &pio_mgr);
+
+	if (!pio_mgr)
+		return;
+
+	pio_mgr->intr_val = (u16)msg;
+	if (pio_mgr->intr_val & MBX_PM_CLASS)
+		io_dispatch_pm(pio_mgr);
+
+	if (pio_mgr->intr_val == MBX_DEH_RESET) {
+		pio_mgr->intr_val = 0;
+	} else {
+		spin_lock_irqsave(&pio_mgr->dpc_lock, flags);
+		pio_mgr->dpc_req++;
+		spin_unlock_irqrestore(&pio_mgr->dpc_lock, flags);
+		tasklet_schedule(&pio_mgr->dpc_tasklet);
+	}
+	return;
 }
 
 /*
- *  ======== IO_RequestChnl ========
+ *  ======== io_request_chnl ========
  *  Purpose:
  *      Request chanenel I/O from the DSP. Sets flags in shared memory, then
  *      interrupts the DSP.
  */
-void IO_RequestChnl(struct IO_MGR *pIOMgr, struct CHNL_OBJECT *pChnl,
-		   u32 iMode, OUT u16 *pwMbVal)
+void io_request_chnl(struct io_mgr *pio_mgr, struct chnl_object *pchnl,
+		     u32 iMode, OUT u16 *pwMbVal)
 {
-	struct CHNL_MGR *pChnlMgr;
-	struct SHM *sm;
-	DBC_Require(pChnl != NULL);
-	DBC_Require(pwMbVal != NULL);
-	pChnlMgr = pIOMgr->hChnlMgr;
-	sm = pIOMgr->pSharedMem;
+	struct chnl_mgr *chnl_mgr_obj;
+	struct shm *sm;
+
+	if (!pchnl || !pwMbVal)
+		goto func_end;
+	chnl_mgr_obj = pio_mgr->hchnl_mgr;
+	sm = pio_mgr->shared_mem;
 	if (iMode == IO_INPUT) {
-		/*  Assertion fires if CHNL_AddIOReq() called on a stream
-		 * which was cancelled, or attached to a dead board: */
-		DBC_Assert((pChnl->dwState == CHNL_STATEREADY) ||
-			  (pChnl->dwState == CHNL_STATEEOS));
-		/* Indicate to the DSP we have a buffer available for input: */
-		IO_OrValue(pIOMgr->hWmdContext, struct SHM, sm, hostFreeMask,
-			  (1 << pChnl->uId));
+		/*
+		 * Assertion fires if CHNL_AddIOReq() called on a stream
+		 * which was cancelled, or attached to a dead board.
+		 */
+		DBC_ASSERT((pchnl->dw_state == CHNL_STATEREADY) ||
+			   (pchnl->dw_state == CHNL_STATEEOS));
+		/* Indicate to the DSP we have a buffer available for input */
+		IO_OR_VALUE(pio_mgr->hwmd_context, struct shm, sm,
+			    host_free_mask, (1 << pchnl->chnl_id));
 		*pwMbVal = MBX_PCPY_CLASS;
 	} else if (iMode == IO_OUTPUT) {
-		/*  This assertion fails if CHNL_AddIOReq() was called on a
-		 * stream which was cancelled, or attached to a dead board: */
-		DBC_Assert((pChnl->dwState & ~CHNL_STATEEOS) ==
-			  CHNL_STATEREADY);
-		/* Record the fact that we have a buffer available for
-		 * output: */
-		pChnlMgr->dwOutputMask |= (1 << pChnl->uId);
+		/*
+		 * This assertion fails if CHNL_AddIOReq() was called on a
+		 * stream which was cancelled, or attached to a dead board.
+		 */
+		DBC_ASSERT((pchnl->dw_state & ~CHNL_STATEEOS) ==
+			   CHNL_STATEREADY);
+		/*
+		 * Record the fact that we have a buffer available for
+		 * output.
+		 */
+		chnl_mgr_obj->dw_output_mask |= (1 << pchnl->chnl_id);
 	} else {
-		DBC_Assert(iMode); 	/* Shouldn't get here. */
+		DBC_ASSERT(iMode);	/* Shouldn't get here. */
 	}
+func_end:
+	return;
 }
 
 /*
- *  ======== IO_Schedule ========
+ *  ======== iosm_schedule ========
  *      Schedule DPC for IO.
  */
-void IO_Schedule(struct IO_MGR *pIOMgr)
+void iosm_schedule(struct io_mgr *pio_mgr)
 {
-	DBC_Require(MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE));
+	unsigned long flags;
 
-	DPC_Schedule(pIOMgr->hDPC);
+	if (!MEM_IS_VALID_HANDLE(pio_mgr, IO_MGRSIGNATURE))
+		return;
+
+	/* Increment count of DPC's pending. */
+	spin_lock_irqsave(&pio_mgr->dpc_lock, flags);
+	pio_mgr->dpc_req++;
+	spin_unlock_irqrestore(&pio_mgr->dpc_lock, flags);
+
+	/* Schedule DPC */
+	tasklet_schedule(&pio_mgr->dpc_tasklet);
 }
 
 /*
- *  ======== FindReadyOutput ========
+ *  ======== find_ready_output ========
  *      Search for a host output channel which is ready to send.  If this is
  *      called as a result of servicing the DPC, then implement a round
  *      robin search; otherwise, this was called by a client thread (via
  *      IO_Dispatch()), so just start searching from the current channel id.
  */
-static u32 FindReadyOutput(struct CHNL_MGR *pChnlMgr,
-			     struct CHNL_OBJECT *pChnl, u32 dwMask)
+static u32 find_ready_output(struct chnl_mgr *chnl_mgr_obj,
+			     struct chnl_object *pchnl, u32 dwMask)
 {
-	u32 uRetval = OUTPUTNOTREADY;
-	u32 id, startId;
+	u32 ret = OUTPUTNOTREADY;
+	u32 id, start_id;
 	u32 shift;
 
-	id = (pChnl != NULL ? pChnl->uId : (pChnlMgr->dwLastOutput + 1));
+	id = (pchnl !=
+	      NULL ? pchnl->chnl_id : (chnl_mgr_obj->dw_last_output + 1));
 	id = ((id == CHNL_MAXCHANNELS) ? 0 : id);
-	DBC_Assert(id < CHNL_MAXCHANNELS);
+	if (id >= CHNL_MAXCHANNELS)
+		goto func_end;
 	if (dwMask) {
 		shift = (1 << id);
-		startId = id;
+		start_id = id;
 		do {
 			if (dwMask & shift) {
-				uRetval = id;
-				if (pChnl == NULL)
-					pChnlMgr->dwLastOutput = id;
-
+				ret = id;
+				if (pchnl == NULL)
+					chnl_mgr_obj->dw_last_output = id;
 				break;
 			}
 			id = id + 1;
 			id = ((id == CHNL_MAXCHANNELS) ? 0 : id);
 			shift = (1 << id);
-		} while (id != startId);
+		} while (id != start_id);
 	}
-	DBC_Ensure((uRetval == OUTPUTNOTREADY) || (uRetval < CHNL_MAXCHANNELS));
-	return uRetval;
+func_end:
+	return ret;
 }
 
 /*
- *  ======== InputChnl ========
+ *  ======== input_chnl ========
  *      Dispatch a buffer on an input channel.
  */
-static void InputChnl(struct IO_MGR *pIOMgr, struct CHNL_OBJECT *pChnl,
-		      u32 iMode)
+static void input_chnl(struct io_mgr *pio_mgr, struct chnl_object *pchnl,
+		       u32 iMode)
 {
-	struct CHNL_MGR *pChnlMgr;
-	struct SHM *sm;
-	u32 chnlId;
-	u32 uBytes;
-	struct CHNL_IRP *pChirp = NULL;
-	u32 dwArg;
-	bool fClearChnl = false;
-	bool fNotifyClient = false;
-
-	sm = pIOMgr->pSharedMem;
-	pChnlMgr = pIOMgr->hChnlMgr;
-
-	DBG_Trace(DBG_LEVEL3, "> InputChnl\n");
-
-	/* Attempt to perform input.... */
-	if (!IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm, inputFull))
-		goto func_end;
-
-	uBytes = IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm, inputSize) *
-			    pChnlMgr->uWordSize;
-	chnlId = IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm, inputId);
-	dwArg = IO_GetLong(pIOMgr->hWmdContext, struct SHM, sm, arg);
-	if (chnlId >= CHNL_MAXCHANNELS) {
-		/* Shouldn't be here: would indicate corrupted SHM. */
-		DBC_Assert(chnlId);
-		goto func_end;
-	}
-	pChnl = pChnlMgr->apChannel[chnlId];
-	if ((pChnl != NULL) && CHNL_IsInput(pChnl->uMode)) {
-		if ((pChnl->dwState & ~CHNL_STATEEOS) == CHNL_STATEREADY) {
-                       if (!pChnl->pIORequests)
-                               goto func_end;
-			/* Get the I/O request, and attempt a transfer:  */
-			pChirp = (struct CHNL_IRP *)LST_GetHead(pChnl->
-				 pIORequests);
-			if (pChirp) {
-				pChnl->cIOReqs--;
-				DBC_Assert(pChnl->cIOReqs >= 0);
-				/* Ensure we don't overflow the client's
-				 * buffer: */
-				uBytes = min(uBytes, pChirp->cBytes);
-				/* Transfer buffer from DSP side: */
-				uBytes = ReadData(pIOMgr->hWmdContext,
-						pChirp->pHostSysBuf,
-						pIOMgr->pInput, uBytes);
-				pChnl->cBytesMoved += uBytes;
-				pChirp->cBytes = uBytes;
-				pChirp->dwArg = dwArg;
-				pChirp->status = CHNL_IOCSTATCOMPLETE;
-				DBG_Trace(DBG_LEVEL7, "Input Chnl:status= 0x%x "
-					 "\n", *((RMS_WORD *)(pChirp->
-					 pHostSysBuf)));
-				if (uBytes == 0) {
-					/* This assertion fails if the DSP
+	struct chnl_mgr *chnl_mgr_obj;
+	struct shm *sm;
+	u32 chnl_id;
+	u32 bytes;
+	struct chnl_irp *chnl_packet_obj = NULL;
+	u32 dw_arg;
+	bool clear_chnl = false;
+	bool notify_client = false;
+
+	sm = pio_mgr->shared_mem;
+	chnl_mgr_obj = pio_mgr->hchnl_mgr;
+
+	/* Attempt to perform input */
+	if (!IO_GET_VALUE(pio_mgr->hwmd_context, struct shm, sm, input_full))
+		goto func_end;
+
+	bytes =
+	    IO_GET_VALUE(pio_mgr->hwmd_context, struct shm, sm,
+			 input_size) * chnl_mgr_obj->word_size;
+	chnl_id = IO_GET_VALUE(pio_mgr->hwmd_context, struct shm, sm, input_id);
+	dw_arg = IO_GET_LONG(pio_mgr->hwmd_context, struct shm, sm, arg);
+	if (chnl_id >= CHNL_MAXCHANNELS) {
+		/* Shouldn't be here: would indicate corrupted shm. */
+		DBC_ASSERT(chnl_id);
+		goto func_end;
+	}
+	pchnl = chnl_mgr_obj->ap_channel[chnl_id];
+	if ((pchnl != NULL) && CHNL_IS_INPUT(pchnl->chnl_mode)) {
+		if ((pchnl->dw_state & ~CHNL_STATEEOS) == CHNL_STATEREADY) {
+			if (!pchnl->pio_requests)
+				goto func_end;
+			/* Get the I/O request, and attempt a transfer */
+			chnl_packet_obj = (struct chnl_irp *)
+			    lst_get_head(pchnl->pio_requests);
+			if (chnl_packet_obj) {
+				pchnl->cio_reqs--;
+				if (pchnl->cio_reqs < 0)
+					goto func_end;
+				/*
+				 * Ensure we don't overflow the client's
+				 * buffer.
+				 */
+				bytes = min(bytes, chnl_packet_obj->byte_size);
+				/* Transfer buffer from DSP side */
+				bytes = read_data(pio_mgr->hwmd_context,
+						  chnl_packet_obj->host_sys_buf,
+						  pio_mgr->input, bytes);
+				pchnl->bytes_moved += bytes;
+				chnl_packet_obj->byte_size = bytes;
+				chnl_packet_obj->dw_arg = dw_arg;
+				chnl_packet_obj->status = CHNL_IOCSTATCOMPLETE;
+
+				if (bytes == 0) {
+					/*
+					 * This assertion fails if the DSP
 					 * sends EOS more than once on this
-					 * channel: */
-					DBC_Assert(!(pChnl->dwState &
-						  CHNL_STATEEOS));
-					 /* Zero bytes indicates EOS. Update
-					  * IOC status for this chirp, and also
-					  * the channel state: */
-					pChirp->status |= CHNL_IOCSTATEOS;
-					pChnl->dwState |= CHNL_STATEEOS;
-					/* Notify that end of stream has
-					 * occurred */
-					NTFY_Notify(pChnl->hNtfy,
-						   DSP_STREAMDONE);
-					DBG_Trace(DBG_LEVEL7, "Input Chnl NTFY "
-						 "chnl = 0x%x\n", pChnl);
+					 * channel.
+					 */
+					if (pchnl->dw_state & CHNL_STATEEOS)
+						goto func_end;
+					/*
+					 * Zero bytes indicates EOS. Update
+					 * IOC status for this chirp, and also
+					 * the channel state.
+					 */
+					chnl_packet_obj->status |=
+					    CHNL_IOCSTATEOS;
+					pchnl->dw_state |= CHNL_STATEEOS;
+					/*
+					 * Notify that end of stream has
+					 * occurred.
+					 */
+					ntfy_notify(pchnl->ntfy_obj,
+						    DSP_STREAMDONE);
 				}
-				/* Tell DSP if no more I/O buffers available: */
-                               if (!pChnl->pIORequests)
-                                       goto func_end;
-				if (LST_IsEmpty(pChnl->pIORequests)) {
-					IO_AndValue(pIOMgr->hWmdContext,
-						   struct SHM, sm, hostFreeMask,
-						   ~(1 << pChnl->uId));
+				/* Tell DSP if no more I/O buffers available */
+				if (!pchnl->pio_requests)
+					goto func_end;
+				if (LST_IS_EMPTY(pchnl->pio_requests)) {
+					IO_AND_VALUE(pio_mgr->hwmd_context,
+						     struct shm, sm,
+						     host_free_mask,
+						     ~(1 << pchnl->chnl_id));
 				}
-				fClearChnl = true;
-				fNotifyClient = true;
+				clear_chnl = true;
+				notify_client = true;
 			} else {
-				/* Input full for this channel, but we have no
+				/*
+				 * Input full for this channel, but we have no
 				 * buffers available.  The channel must be
 				 * "idling". Clear out the physical input
-				 * channel.  */
-				fClearChnl = true;
+				 * channel.
+				 */
+				clear_chnl = true;
 			}
 		} else {
-			/* Input channel cancelled:  clear input channel.  */
-			fClearChnl = true;
+			/* Input channel cancelled: clear input channel */
+			clear_chnl = true;
 		}
 	} else {
-		/* DPC fired after host closed channel: clear input channel. */
-		fClearChnl = true;
+		/* DPC fired after host closed channel: clear input channel */
+		clear_chnl = true;
 	}
-	if (fClearChnl) {
-		/* Indicate to the DSP we have read the input: */
-		IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, inputFull, 0);
-		CHNLSM_InterruptDSP2(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
-	}
-	if (fNotifyClient) {
-		/* Notify client with IO completion record:  */
-		NotifyChnlComplete(pChnl, pChirp);
+	if (clear_chnl) {
+		/* Indicate to the DSP we have read the input */
+		IO_SET_VALUE(pio_mgr->hwmd_context, struct shm, sm, input_full,
+			     0);
+		sm_interrupt_dsp(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
+	}
+	if (notify_client) {
+		/* Notify client with IO completion record */
+		notify_chnl_complete(pchnl, chnl_packet_obj);
 	}
 func_end:
-	DBG_Trace(DBG_LEVEL3, "< InputChnl\n");
+	return;
 }
 
 /*
- *  ======== InputMsg ========
+ *  ======== input_msg ========
  *      Copies messages from shared memory to the message queues.
  */
-static void InputMsg(struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr)
+static void input_msg(struct io_mgr *pio_mgr, struct msg_mgr *hmsg_mgr)
 {
-	u32 uMsgs;
+	u32 num_msgs;
 	u32 i;
-	u8 *pMsgInput;
-	struct MSG_QUEUE *hMsgQueue;
-	struct MSG_FRAME *pMsg;
-	struct MSG_DSPMSG msg;
-	struct MSG *pCtrl;
-	u32 fInputEmpty;
+	u8 *msg_input;
+	struct msg_queue *msg_queue_obj;
+	struct msg_frame *pmsg;
+	struct msg_dspmsg msg;
+	struct msg_ctrl *msg_ctr_obj;
+	u32 input_empty;
 	u32 addr;
 
-	pCtrl = pIOMgr->pMsgInputCtrl;
-	/* Get the number of input messages to be read. */
-	fInputEmpty = IO_GetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
-				 bufEmpty);
-	uMsgs = IO_GetValue(pIOMgr->hWmdContext, struct MSG, pCtrl, size);
-	if (fInputEmpty || uMsgs >= hMsgMgr->uMaxMsgs)
-		return;
+	msg_ctr_obj = pio_mgr->msg_input_ctrl;
+	/* Get the number of input messages to be read */
+	input_empty =
+	    IO_GET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl, msg_ctr_obj,
+			 buf_empty);
+	num_msgs =
+	    IO_GET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl, msg_ctr_obj,
+			 size);
+	if (input_empty)
+		goto func_end;
 
-	pMsgInput = pIOMgr->pMsgInput;
-	for (i = 0; i < uMsgs; i++) {
+	msg_input = pio_mgr->msg_input;
+	for (i = 0; i < num_msgs; i++) {
 		/* Read the next message */
-		addr = (u32)&(((struct MSG_DSPMSG *)pMsgInput)->msg.dwCmd);
-		msg.msg.dwCmd = ReadExt32BitDspData(pIOMgr->hWmdContext, addr);
-		addr = (u32)&(((struct MSG_DSPMSG *)pMsgInput)->msg.dwArg1);
-		msg.msg.dwArg1 = ReadExt32BitDspData(pIOMgr->hWmdContext, addr);
-		addr = (u32)&(((struct MSG_DSPMSG *)pMsgInput)->msg.dwArg2);
-		msg.msg.dwArg2 = ReadExt32BitDspData(pIOMgr->hWmdContext, addr);
-		addr = (u32)&(((struct MSG_DSPMSG *)pMsgInput)->dwId);
-		msg.dwId = ReadExt32BitDspData(pIOMgr->hWmdContext, addr);
-		pMsgInput += sizeof(struct MSG_DSPMSG);
-               if (!hMsgMgr->queueList)
-                       goto func_end;
+		addr = (u32) &(((struct msg_dspmsg *)msg_input)->msg.dw_cmd);
+		msg.msg.dw_cmd =
+		    read_ext32_bit_dsp_data(pio_mgr->hwmd_context, addr);
+		addr = (u32) &(((struct msg_dspmsg *)msg_input)->msg.dw_arg1);
+		msg.msg.dw_arg1 =
+		    read_ext32_bit_dsp_data(pio_mgr->hwmd_context, addr);
+		addr = (u32) &(((struct msg_dspmsg *)msg_input)->msg.dw_arg2);
+		msg.msg.dw_arg2 =
+		    read_ext32_bit_dsp_data(pio_mgr->hwmd_context, addr);
+		addr = (u32) &(((struct msg_dspmsg *)msg_input)->msgq_id);
+		msg.msgq_id =
+		    read_ext32_bit_dsp_data(pio_mgr->hwmd_context, addr);
+		msg_input += sizeof(struct msg_dspmsg);
+		if (!hmsg_mgr->queue_list)
+			goto func_end;
 
 		/* Determine which queue to put the message in */
-		hMsgQueue = (struct MSG_QUEUE *)LST_First(hMsgMgr->queueList);
-		DBG_Trace(DBG_LEVEL7, "InputMsg RECVD: dwCmd=0x%x dwArg1=0x%x "
-			 "dwArg2=0x%x dwId=0x%x \n", msg.msg.dwCmd,
-			 msg.msg.dwArg1, msg.msg.dwArg2, msg.dwId);
-		 /*  Interrupt may occur before shared memory and message
-		 *  input locations have been set up. If all nodes were
-		 *  cleaned up, hMsgMgr->uMaxMsgs should be 0.  */
-               if (hMsgQueue && uMsgs > hMsgMgr->uMaxMsgs)
-                       goto func_end;
-
-		while (hMsgQueue != NULL) {
-			if (msg.dwId == hMsgQueue->dwId) {
+		msg_queue_obj =
+		    (struct msg_queue *)lst_first(hmsg_mgr->queue_list);
+		dev_dbg(bridge,	"input msg: dw_cmd=0x%x dw_arg1=0x%x "
+			"dw_arg2=0x%x msgq_id=0x%x \n", msg.msg.dw_cmd,
+			msg.msg.dw_arg1, msg.msg.dw_arg2, msg.msgq_id);
+		/*
+		 * Interrupt may occur before shared memory and message
+		 * input locations have been set up. If all nodes were
+		 * cleaned up, hmsg_mgr->max_msgs should be 0.
+		 */
+		while (msg_queue_obj != NULL) {
+			if (msg.msgq_id == msg_queue_obj->msgq_id) {
 				/* Found it */
-				if (msg.msg.dwCmd == RMS_EXITACK) {
-					/* The exit message does not get
-					 * queued */
-					/* Call the node exit notification */
-					/* Node handle */ /* status */
-					(*hMsgMgr->onExit)((HANDLE)hMsgQueue->
-						hArg, msg.msg.dwArg1);
+				if (msg.msg.dw_cmd == RMS_EXITACK) {
+					/*
+					 * Call the node exit notification.
+					 * The exit message does not get
+					 * queued.
+					 */
+					(*hmsg_mgr->on_exit) ((bhandle)
+							   msg_queue_obj->arg,
+							   msg.msg.dw_arg1);
 				} else {
-					/* Not an exit acknowledgement, queue
-					 * the message */
-                                       if (!hMsgQueue->msgFreeList)
-                                               goto func_end;
-					pMsg = (struct MSG_FRAME *)LST_GetHead
-						(hMsgQueue->msgFreeList);
-                                       if (hMsgQueue->msgUsedList && pMsg) {
-						pMsg->msgData = msg;
-						LST_PutTail(hMsgQueue->
-						      msgUsedList,
-						      (struct LST_ELEM *)pMsg);
-						NTFY_Notify(hMsgQueue->hNtfy,
-							DSP_NODEMESSAGEREADY);
-						SYNC_SetEvent(hMsgQueue->
-							hSyncEvent);
+					/*
+					 * Not an exit acknowledgement, queue
+					 * the message.
+					 */
+					if (!msg_queue_obj->msg_free_list)
+						goto func_end;
+					pmsg = (struct msg_frame *)lst_get_head
+					    (msg_queue_obj->msg_free_list);
+					if (msg_queue_obj->msg_used_list
+					    && pmsg) {
+						pmsg->msg_data = msg;
+						lst_put_tail
+						 (msg_queue_obj->msg_used_list,
+						     (struct list_head *)pmsg);
+						ntfy_notify
+						    (msg_queue_obj->ntfy_obj,
+						     DSP_NODEMESSAGEREADY);
+						sync_set_event
+						    (msg_queue_obj->sync_event);
 					} else {
-						/* No free frame to copy the
-						 * message into */
-						DBG_Trace(DBG_LEVEL7, "NO FREE "
-							"MSG FRAMES, DISCARDING"
-							" MESSAGE\n");
+						/*
+						 * No free frame to copy the
+						 * message into.
+						 */
+						pr_err("%s: no free msg frames,"
+						       " discarding msg\n",
+						       __func__);
 					}
 				}
 				break;
 			}
 
-                       if (!hMsgMgr->queueList || !hMsgQueue)
-                               goto func_end;
-			hMsgQueue = (struct MSG_QUEUE *)LST_Next(hMsgMgr->
-				    queueList, (struct LST_ELEM *)hMsgQueue);
+			if (!hmsg_mgr->queue_list || !msg_queue_obj)
+				goto func_end;
+			msg_queue_obj =
+			    (struct msg_queue *)lst_next(hmsg_mgr->queue_list,
+							 (struct list_head *)
+							 msg_queue_obj);
 		}
 	}
 	/* Set the post SWI flag */
-	if (uMsgs > 0) {
+	if (num_msgs > 0) {
 		/* Tell the DSP we've read the messages */
-		IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl, bufEmpty,
-			   true);
-		IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl, postSWI,
-			   true);
-		CHNLSM_InterruptDSP2(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
+		IO_SET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl,
+			     msg_ctr_obj, buf_empty, true);
+		IO_SET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl,
+			     msg_ctr_obj, post_swi, true);
+		sm_interrupt_dsp(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
 	}
 func_end:
-       return;
-
+	return;
 }
 
 /*
- *  ======== NotifyChnlComplete ========
+ *  ======== notify_chnl_complete ========
  *  Purpose:
  *      Signal the channel event, notifying the client that I/O has completed.
  */
-static void NotifyChnlComplete(struct CHNL_OBJECT *pChnl,
-			      struct CHNL_IRP *pChirp)
+static void notify_chnl_complete(struct chnl_object *pchnl,
+				 struct chnl_irp *chnl_packet_obj)
 {
-	bool fSignalEvent;
+	bool signal_event;
 
-	DBC_Require(MEM_IsValidHandle(pChnl, CHNL_SIGNATURE));
-	DBC_Require(pChnl->hSyncEvent != NULL);
-	 /*  Note: we signal the channel event only if the queue of IO
-	  *  completions is empty.  If it is not empty, the event is sure to be
-	  *  signalled by the only IO completion list consumer:
-	  *  WMD_CHNL_GetIOC().  */
-	fSignalEvent = LST_IsEmpty(pChnl->pIOCompletions);
-	/* Enqueue the IO completion info for the client: */
-	LST_PutTail(pChnl->pIOCompletions, (struct LST_ELEM *) pChirp);
-	pChnl->cIOCs++;
-	DBC_Assert(pChnl->cIOCs <= pChnl->cChirps);
-	/* Signal the channel event (if not already set) that IO is complete: */
-	if (fSignalEvent)
-		SYNC_SetEvent(pChnl->hSyncEvent);
+	if (!MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE) || !pchnl->sync_event ||
+	    !pchnl->pio_completions || !chnl_packet_obj)
+		goto func_end;
+
+	/*
+	 * Note: we signal the channel event only if the queue of IO
+	 * completions is empty.  If it is not empty, the event is sure to be
+	 * signalled by the only IO completion list consumer:
+	 * bridge_chnl_get_ioc().
+	 */
+	signal_event = LST_IS_EMPTY(pchnl->pio_completions);
+	/* Enqueue the IO completion info for the client */
+	lst_put_tail(pchnl->pio_completions,
+		     (struct list_head *)chnl_packet_obj);
+	pchnl->cio_cs++;
+
+	if (pchnl->cio_cs > pchnl->chnl_packets)
+		goto func_end;
+	/* Signal the channel event (if not already set) that IO is complete */
+	if (signal_event)
+		sync_set_event(pchnl->sync_event);
 
 	/* Notify that IO is complete */
-	NTFY_Notify(pChnl->hNtfy, DSP_STREAMIOCOMPLETION);
+	ntfy_notify(pchnl->ntfy_obj, DSP_STREAMIOCOMPLETION);
+func_end:
+	return;
 }
 
 /*
- *  ======== OutputChnl ========
+ *  ======== output_chnl ========
  *  Purpose:
  *      Dispatch a buffer on an output channel.
  */
-static void OutputChnl(struct IO_MGR *pIOMgr, struct CHNL_OBJECT *pChnl,
+static void output_chnl(struct io_mgr *pio_mgr, struct chnl_object *pchnl,
 			u32 iMode)
 {
-	struct CHNL_MGR *pChnlMgr;
-	struct SHM *sm;
-	u32 chnlId;
-	struct CHNL_IRP *pChirp;
-	u32 dwDspFMask;
-
-	pChnlMgr = pIOMgr->hChnlMgr;
-	sm = pIOMgr->pSharedMem;
-	DBG_Trace(DBG_LEVEL3, "> OutputChnl\n");
-	/* Attempt to perform output: */
-	if (IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm, outputFull))
+	struct chnl_mgr *chnl_mgr_obj;
+	struct shm *sm;
+	u32 chnl_id;
+	struct chnl_irp *chnl_packet_obj;
+	u32 dw_dsp_f_mask;
+
+	chnl_mgr_obj = pio_mgr->hchnl_mgr;
+	sm = pio_mgr->shared_mem;
+	/* Attempt to perform output */
+	if (IO_GET_VALUE(pio_mgr->hwmd_context, struct shm, sm, output_full))
 		goto func_end;
 
-	if (pChnl && !((pChnl->dwState & ~CHNL_STATEEOS) == CHNL_STATEREADY))
+	if (pchnl && !((pchnl->dw_state & ~CHNL_STATEEOS) == CHNL_STATEREADY))
 		goto func_end;
 
-	/* Look to see if both a PC and DSP output channel are ready: */
-	dwDspFMask = IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm,
-				 dspFreeMask);
-	chnlId = FindReadyOutput(pChnlMgr, pChnl, (pChnlMgr->dwOutputMask &
-				 dwDspFMask));
-	if (chnlId == OUTPUTNOTREADY)
+	/* Look to see if both a PC and DSP output channel are ready */
+	dw_dsp_f_mask = IO_GET_VALUE(pio_mgr->hwmd_context, struct shm, sm,
+				     dsp_free_mask);
+	chnl_id =
+	    find_ready_output(chnl_mgr_obj, pchnl,
+			      (chnl_mgr_obj->dw_output_mask & dw_dsp_f_mask));
+	if (chnl_id == OUTPUTNOTREADY)
 		goto func_end;
 
-	pChnl = pChnlMgr->apChannel[chnlId];
-       if (!pChnl || !pChnl->pIORequests) {
-		/* Shouldn't get here: */
+	pchnl = chnl_mgr_obj->ap_channel[chnl_id];
+	if (!pchnl || !pchnl->pio_requests) {
+		/* Shouldn't get here */
 		goto func_end;
 	}
-	/* Get the I/O request, and attempt a transfer:  */
-	pChirp = (struct CHNL_IRP *)LST_GetHead(pChnl->pIORequests);
-	if (!pChirp)
+	/* Get the I/O request, and attempt a transfer */
+	chnl_packet_obj = (struct chnl_irp *)lst_get_head(pchnl->pio_requests);
+	if (!chnl_packet_obj)
 		goto func_end;
 
-	pChnl->cIOReqs--;
-       if (pChnl->cIOReqs < 0 || !pChnl->pIORequests)
-               goto func_end;
-
-	/* Record fact that no more I/O buffers available:  */
-	if (LST_IsEmpty(pChnl->pIORequests))
-		pChnlMgr->dwOutputMask &= ~(1 << chnlId);
+	pchnl->cio_reqs--;
+	if (pchnl->cio_reqs < 0 || !pchnl->pio_requests)
+		goto func_end;
 
-	/* Transfer buffer to DSP side: */
-	pChirp->cBytes = WriteData(pIOMgr->hWmdContext, pIOMgr->pOutput,
-			pChirp->pHostSysBuf, min(pIOMgr->uSMBufSize, pChirp->
-			cBytes));
-	pChnl->cBytesMoved += pChirp->cBytes;
+	/* Record fact that no more I/O buffers available */
+	if (LST_IS_EMPTY(pchnl->pio_requests))
+		chnl_mgr_obj->dw_output_mask &= ~(1 << chnl_id);
+
+	/* Transfer buffer to DSP side */
+	chnl_packet_obj->byte_size =
+	    write_data(pio_mgr->hwmd_context, pio_mgr->output,
+		       chnl_packet_obj->host_sys_buf, min(pio_mgr->usm_buf_size,
+						  chnl_packet_obj->byte_size));
+	pchnl->bytes_moved += chnl_packet_obj->byte_size;
 	/* Write all 32 bits of arg */
-	IO_SetLong(pIOMgr->hWmdContext, struct SHM, sm, arg, pChirp->dwArg);
+	IO_SET_LONG(pio_mgr->hwmd_context, struct shm, sm, arg,
+		    chnl_packet_obj->dw_arg);
 #if _CHNL_WORDSIZE == 2
-	IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, outputId,
-		   (u16)chnlId);
-	IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, outputSize,
-		   (u16)(pChirp->cBytes + (pChnlMgr->uWordSize-1)) /
-		   (u16)pChnlMgr->uWordSize);
+	IO_SET_VALUE(pio_mgr->hwmd_context, struct shm, sm, output_id,
+		     (u16) chnl_id);
+	IO_SET_VALUE(pio_mgr->hwmd_context, struct shm, sm, output_size,
+		     (u16) (chnl_packet_obj->byte_size +
+			    (chnl_mgr_obj->word_size -
+			     1)) / (u16) chnl_mgr_obj->word_size);
 #else
-	IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, outputId, chnlId);
-	IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, outputSize,
-		   (pChirp->cBytes + (pChnlMgr->uWordSize - 1)) / pChnlMgr->
-		   uWordSize);
+	IO_SET_VALUE(pio_mgr->hwmd_context, struct shm, sm, output_id, chnl_id);
+	IO_SET_VALUE(pio_mgr->hwmd_context, struct shm, sm, output_size,
+		     (chnl_packet_obj->byte_size +
+		      (chnl_mgr_obj->word_size - 1)) / chnl_mgr_obj->word_size);
 #endif
-	IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, outputFull, 1);
-	/* Indicate to the DSP we have written the output: */
-	CHNLSM_InterruptDSP2(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
+	IO_SET_VALUE(pio_mgr->hwmd_context, struct shm, sm, output_full, 1);
+	/* Indicate to the DSP we have written the output */
+	sm_interrupt_dsp(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
 	/* Notify client with IO completion record (keep EOS) */
-	pChirp->status &= CHNL_IOCSTATEOS;
-	NotifyChnlComplete(pChnl, pChirp);
+	chnl_packet_obj->status &= CHNL_IOCSTATEOS;
+	notify_chnl_complete(pchnl, chnl_packet_obj);
 	/* Notify if stream is done. */
-	if (pChirp->status & CHNL_IOCSTATEOS)
-		NTFY_Notify(pChnl->hNtfy, DSP_STREAMDONE);
+	if (chnl_packet_obj->status & CHNL_IOCSTATEOS)
+		ntfy_notify(pchnl->ntfy_obj, DSP_STREAMDONE);
 
 func_end:
-	DBG_Trace(DBG_LEVEL3, "< OutputChnl\n");
+	return;
 }
+
 /*
- *  ======== OutputMsg ========
+ *  ======== output_msg ========
  *      Copies messages from the message queues to the shared memory.
  */
-static void OutputMsg(struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr)
+static void output_msg(struct io_mgr *pio_mgr, struct msg_mgr *hmsg_mgr)
 {
-	u32 uMsgs = 0;
+	u32 num_msgs = 0;
 	u32 i;
-	u8 *pMsgOutput;
-	struct MSG_FRAME *pMsg;
-	struct MSG *pCtrl;
-	u32 fOutputEmpty;
+	u8 *msg_output;
+	struct msg_frame *pmsg;
+	struct msg_ctrl *msg_ctr_obj;
+	u32 output_empty;
 	u32 val;
 	u32 addr;
 
-	pCtrl = pIOMgr->pMsgOutputCtrl;
+	msg_ctr_obj = pio_mgr->msg_output_ctrl;
 
 	/* Check if output has been cleared */
-	fOutputEmpty = IO_GetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
-				  bufEmpty);
-	if (fOutputEmpty) {
-		uMsgs = (hMsgMgr->uMsgsPending > hMsgMgr->uMaxMsgs) ?
-			 hMsgMgr->uMaxMsgs : hMsgMgr->uMsgsPending;
-		pMsgOutput = pIOMgr->pMsgOutput;
-		/* Copy uMsgs messages into shared memory */
-		for (i = 0; i < uMsgs; i++) {
-                       if (!hMsgMgr->msgUsedList) {
-                               DBG_Trace(DBG_LEVEL3, "msgUsedList is NULL\n");
-                               pMsg = NULL;
-                               goto func_end;
-                       } else
-                               pMsg = (struct MSG_FRAME *)LST_GetHead(
-                                       hMsgMgr->msgUsedList);
-			if (pMsg != NULL) {
-				val = (pMsg->msgData).dwId;
-				addr = (u32)&(((struct MSG_DSPMSG *)
-					pMsgOutput)->dwId);
-				WriteExt32BitDspData(pIOMgr->hWmdContext, addr,
-						     val);
-				val = (pMsg->msgData).msg.dwCmd;
-				addr = (u32)&((((struct MSG_DSPMSG *)
-					pMsgOutput)->msg).dwCmd);
-				WriteExt32BitDspData(pIOMgr->hWmdContext, addr,
-						     val);
-				val = (pMsg->msgData).msg.dwArg1;
-				addr =
-					(u32)&((((struct MSG_DSPMSG *)
-					pMsgOutput)->msg).dwArg1);
-				WriteExt32BitDspData(pIOMgr->hWmdContext, addr,
-						    val);
-				val = (pMsg->msgData).msg.dwArg2;
-				addr =
-					(u32)&((((struct MSG_DSPMSG *)
-					pMsgOutput)->msg).dwArg2);
-				WriteExt32BitDspData(pIOMgr->hWmdContext, addr,
-						    val);
-				pMsgOutput += sizeof(struct MSG_DSPMSG);
-                               if (!hMsgMgr->msgFreeList)
-                                       goto func_end;
-				LST_PutTail(hMsgMgr->msgFreeList,
-					   (struct LST_ELEM *) pMsg);
-				SYNC_SetEvent(hMsgMgr->hSyncEvent);
+	output_empty =
+	    IO_GET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl, msg_ctr_obj,
+			 buf_empty);
+	if (output_empty) {
+		num_msgs = (hmsg_mgr->msgs_pending > hmsg_mgr->max_msgs) ?
+		    hmsg_mgr->max_msgs : hmsg_mgr->msgs_pending;
+		msg_output = pio_mgr->msg_output;
+		/* Copy num_msgs messages into shared memory */
+		for (i = 0; i < num_msgs; i++) {
+			if (!hmsg_mgr->msg_used_list) {
+				pmsg = NULL;
+				goto func_end;
 			} else {
-				DBG_Trace(DBG_LEVEL3, "pMsg is NULL\n");
+				pmsg = (struct msg_frame *)
+				    lst_get_head(hmsg_mgr->msg_used_list);
+			}
+			if (pmsg != NULL) {
+				val = (pmsg->msg_data).msgq_id;
+				addr = (u32) &(((struct msg_dspmsg *)
+						 msg_output)->msgq_id);
+				write_ext32_bit_dsp_data(pio_mgr->hwmd_context,
+							 addr, val);
+				val = (pmsg->msg_data).msg.dw_cmd;
+				addr = (u32) &((((struct msg_dspmsg *)
+						  msg_output)->msg).dw_cmd);
+				write_ext32_bit_dsp_data(pio_mgr->hwmd_context,
+							 addr, val);
+				val = (pmsg->msg_data).msg.dw_arg1;
+				addr = (u32) &((((struct msg_dspmsg *)
+						  msg_output)->msg).dw_arg1);
+				write_ext32_bit_dsp_data(pio_mgr->hwmd_context,
+							 addr, val);
+				val = (pmsg->msg_data).msg.dw_arg2;
+				addr = (u32) &((((struct msg_dspmsg *)
+						  msg_output)->msg).dw_arg2);
+				write_ext32_bit_dsp_data(pio_mgr->hwmd_context,
+							 addr, val);
+				msg_output += sizeof(struct msg_dspmsg);
+				if (!hmsg_mgr->msg_free_list)
+					goto func_end;
+				lst_put_tail(hmsg_mgr->msg_free_list,
+					     (struct list_head *)pmsg);
+				sync_set_event(hmsg_mgr->sync_event);
 			}
 		}
 
-		if (uMsgs > 0) {
-			hMsgMgr->uMsgsPending -= uMsgs;
+		if (num_msgs > 0) {
+			hmsg_mgr->msgs_pending -= num_msgs;
 #if _CHNL_WORDSIZE == 2
-			IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
-				   size, (u16)uMsgs);
+			IO_SET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl,
+				     msg_ctr_obj, size, (u16) num_msgs);
 #else
-			IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
-				   size, uMsgs);
+			IO_SET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl,
+				     msg_ctr_obj, size, num_msgs);
 #endif
-			IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
-				   bufEmpty, false);
+			IO_SET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl,
+				     msg_ctr_obj, buf_empty, false);
 			/* Set the post SWI flag */
-			IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
-				   postSWI, true);
+			IO_SET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl,
+				     msg_ctr_obj, post_swi, true);
 			/* Tell the DSP we have written the output. */
-			CHNLSM_InterruptDSP2(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
+			sm_interrupt_dsp(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
 		}
 	}
 func_end:
-       return;
-
+	return;
 }
 
 /*
- *  ======== registerSHMSegs ========
+ *  ======== register_shm_segs ========
  *  purpose:
  *      Registers GPP SM segment with CMM.
  */
-static DSP_STATUS registerSHMSegs(struct IO_MGR *hIOMgr,
-				 struct COD_MANAGER *hCodMan,
-				 u32 dwGPPBasePA)
-{
-	DSP_STATUS status = DSP_SOK;
-	u32 ulShm0_Base = 0;
-	u32 ulShm0_End = 0;
-	u32 ulShm0_RsrvdStart = 0;
-	u32 ulRsrvdSize = 0;
-	u32 ulGppPhys;
-	u32 ulDspVirt;
-	u32 ulShmSegId0 = 0;
-	u32 dwOffset, dwGPPBaseVA, ulDSPSize;
-
-	/* Read address and size info for first SM region.*/
-	/* Get start of 1st SM Heap region */
-	status = COD_GetSymValue(hCodMan, SHM0_SHARED_BASE_SYM, &ulShm0_Base);
-	DBC_Assert(ulShm0_Base != 0);
+static dsp_status register_shm_segs(struct io_mgr *hio_mgr,
+				    struct cod_manager *cod_man,
+				    u32 dw_gpp_base_pa)
+{
+	dsp_status status = DSP_SOK;
+	u32 ul_shm0_base = 0;
+	u32 shm0_end = 0;
+	u32 ul_shm0_rsrvd_start = 0;
+	u32 ul_rsrvd_size = 0;
+	u32 ul_gpp_phys;
+	u32 ul_dsp_virt;
+	u32 ul_shm_seg_id0 = 0;
+	u32 dw_offset, dw_gpp_base_va, ul_dsp_size;
+
+	/*
+	 * Read address and size info for first SM region.
+	 * Get start of 1st SM Heap region.
+	 */
+	status =
+	    cod_get_sym_value(cod_man, SHM0_SHARED_BASE_SYM, &ul_shm0_base);
+	if (ul_shm0_base == 0) {
+		status = DSP_EFAIL;
+		goto func_end;
+	}
 	/* Get end of 1st SM Heap region */
 	if (DSP_SUCCEEDED(status)) {
 		/* Get start and length of message part of shared memory */
-		status = COD_GetSymValue(hCodMan, SHM0_SHARED_END_SYM,
-					 &ulShm0_End);
-		DBC_Assert(ulShm0_End != 0);
+		status = cod_get_sym_value(cod_man, SHM0_SHARED_END_SYM,
+					   &shm0_end);
+		if (shm0_end == 0) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
 	}
-	/* start of Gpp reserved region */
+	/* Start of Gpp reserved region */
 	if (DSP_SUCCEEDED(status)) {
 		/* Get start and length of message part of shared memory */
-		status = COD_GetSymValue(hCodMan, SHM0_SHARED_RESERVED_BASE_SYM,
-					&ulShm0_RsrvdStart);
-		DBG_Trace(DBG_LEVEL1, "***ulShm0_RsrvdStart  0x%x \n",
-			 ulShm0_RsrvdStart);
-		DBC_Assert(ulShm0_RsrvdStart != 0);
+		status =
+		    cod_get_sym_value(cod_man, SHM0_SHARED_RESERVED_BASE_SYM,
+				      &ul_shm0_rsrvd_start);
+		if (ul_shm0_rsrvd_start == 0) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
 	}
 	/* Register with CMM */
 	if (DSP_SUCCEEDED(status)) {
-		status = DEV_GetCmmMgr(hIOMgr->hDevObject, &hIOMgr->hCmmMgr);
+		status = dev_get_cmm_mgr(hio_mgr->hdev_obj, &hio_mgr->hcmm_mgr);
 		if (DSP_SUCCEEDED(status)) {
-			status = CMM_UnRegisterGPPSMSeg(hIOMgr->hCmmMgr,
-				 CMM_ALLSEGMENTS);
-			if (DSP_FAILED(status)) {
-				DBG_Trace(DBG_LEVEL7, "ERROR - Unable to "
-					 "Un-Register SM segments \n");
-			}
-		} else {
-			DBG_Trace(DBG_LEVEL7, "ERROR - Unable to get CMM "
-				 "Handle \n");
+			status = cmm_un_register_gppsm_seg(hio_mgr->hcmm_mgr,
+							   CMM_ALLSEGMENTS);
 		}
 	}
 	/* Register new SM region(s) */
-	if (DSP_SUCCEEDED(status) && (ulShm0_End - ulShm0_Base) > 0) {
-		/* calc size (bytes) of SM the GPP can alloc from */
-		ulRsrvdSize = (ulShm0_End - ulShm0_RsrvdStart + 1) * hIOMgr->
-			      uWordSize;
-		DBC_Assert(ulRsrvdSize > 0);
-		/* calc size of SM DSP can alloc from */
-		ulDSPSize = (ulShm0_RsrvdStart - ulShm0_Base) * hIOMgr->
-			uWordSize;
-		DBC_Assert(ulDSPSize > 0);
-		/*  First TLB entry reserved for Bridge SM use.*/
-		ulGppPhys = hIOMgr->extProcInfo.tyTlb[0].ulGppPhys;
-		/* get size in bytes */
-		ulDspVirt = hIOMgr->extProcInfo.tyTlb[0].ulDspVirt * hIOMgr->
-			uWordSize;
-		 /* Calc byte offset used to convert GPP phys <-> DSP byte
-		  * address.*/
-		if (dwGPPBasePA > ulDspVirt)
-			dwOffset = dwGPPBasePA - ulDspVirt;
+	if (DSP_SUCCEEDED(status) && (shm0_end - ul_shm0_base) > 0) {
+		/* Calc size (bytes) of SM the GPP can alloc from */
+		ul_rsrvd_size =
+		    (shm0_end - ul_shm0_rsrvd_start + 1) * hio_mgr->word_size;
+		if (ul_rsrvd_size <= 0) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
+		/* Calc size of SM DSP can alloc from */
+		ul_dsp_size =
+		    (ul_shm0_rsrvd_start - ul_shm0_base) * hio_mgr->word_size;
+		if (ul_dsp_size <= 0) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
+		/* First TLB entry reserved for Bridge SM use. */
+		ul_gpp_phys = hio_mgr->ext_proc_info.ty_tlb[0].ul_gpp_phys;
+		/* Get size in bytes */
+		ul_dsp_virt =
+		    hio_mgr->ext_proc_info.ty_tlb[0].ul_dsp_virt *
+		    hio_mgr->word_size;
+		/*
+		 * Calc byte offset used to convert GPP phys <-> DSP byte
+		 * address.
+		 */
+		if (dw_gpp_base_pa > ul_dsp_virt)
+			dw_offset = dw_gpp_base_pa - ul_dsp_virt;
 		else
-			dwOffset = ulDspVirt - dwGPPBasePA;
+			dw_offset = ul_dsp_virt - dw_gpp_base_pa;
 
-		DBC_Assert(ulShm0_RsrvdStart * hIOMgr->uWordSize >= ulDspVirt);
-		/* calc Gpp phys base of SM region */
-		/* Linux - this is actually uncached kernel virtual address*/
-		dwGPPBaseVA = ulGppPhys + ulShm0_RsrvdStart * hIOMgr->uWordSize
-				- ulDspVirt;
-		/* calc Gpp phys base of SM region */
-		/* Linux - this is the physical address*/
-		dwGPPBasePA = dwGPPBasePA + ulShm0_RsrvdStart * hIOMgr->
-			      uWordSize - ulDspVirt;
-		 /* Register SM Segment 0.*/
-		status = CMM_RegisterGPPSMSeg(hIOMgr->hCmmMgr, dwGPPBasePA,
-			 ulRsrvdSize, dwOffset, (dwGPPBasePA > ulDspVirt) ?
-			 CMM_ADDTODSPPA : CMM_SUBFROMDSPPA,
-			 (u32)(ulShm0_Base * hIOMgr->uWordSize),
-			 ulDSPSize, &ulShmSegId0, dwGPPBaseVA);
-		if (DSP_FAILED(status)) {
-			DBG_Trace(DBG_LEVEL7, "ERROR - Failed to register SM "
-				 "Seg 0 \n");
+		if (ul_shm0_rsrvd_start * hio_mgr->word_size < ul_dsp_virt) {
+			status = DSP_EFAIL;
+			goto func_end;
 		}
-		/* first SM region is segId = 1 */
-		DBC_Assert(ulShmSegId0 == 1);
+		/*
+		 * Calc Gpp phys base of SM region.
+		 * This is actually uncached kernel virtual address.
+		 */
+		dw_gpp_base_va =
+		    ul_gpp_phys + ul_shm0_rsrvd_start * hio_mgr->word_size -
+		    ul_dsp_virt;
+		/*
+		 * Calc Gpp phys base of SM region.
+		 * This is the physical address.
+		 */
+		dw_gpp_base_pa =
+		    dw_gpp_base_pa + ul_shm0_rsrvd_start * hio_mgr->word_size -
+		    ul_dsp_virt;
+		/* Register SM Segment 0. */
+		status =
+		    cmm_register_gppsm_seg(hio_mgr->hcmm_mgr, dw_gpp_base_pa,
+					   ul_rsrvd_size, dw_offset,
+					   (dw_gpp_base_pa >
+					    ul_dsp_virt) ? CMM_ADDTODSPPA :
+					   CMM_SUBFROMDSPPA,
+					   (u32) (ul_shm0_base *
+						  hio_mgr->word_size),
+					   ul_dsp_size, &ul_shm_seg_id0,
+					   dw_gpp_base_va);
+		/* First SM region is seg_id = 1 */
+		if (ul_shm_seg_id0 != 1)
+			status = DSP_EFAIL;
 	}
+func_end:
 	return status;
 }
 
 /*
- *  ======== ReadData ========
+ *  ======== read_data ========
  *      Copies buffers from the shared memory to the host buffer.
  */
-static u32 ReadData(struct WMD_DEV_CONTEXT *hDevContext, void *pDest,
-		     void *pSrc, u32 uSize)
+static u32 read_data(struct wmd_dev_context *hDevContext, void *dest,
+		     void *pSrc, u32 usize)
 {
-	memcpy(pDest, pSrc, uSize);
-	return uSize;
+	memcpy(dest, pSrc, usize);
+	return usize;
 }
 
 /*
- *  ======== WriteData ========
+ *  ======== write_data ========
  *      Copies buffers from the host side buffer to the shared memory.
  */
-static u32 WriteData(struct WMD_DEV_CONTEXT *hDevContext, void *pDest,
-		       void *pSrc, u32 uSize)
+static u32 write_data(struct wmd_dev_context *hDevContext, void *dest,
+		      void *pSrc, u32 usize)
 {
-	memcpy(pDest, pSrc, uSize);
-	return uSize;
+	memcpy(dest, pSrc, usize);
+	return usize;
 }
 
 /* ZCPY IO routines. */
-void IO_IntrDSP2(IN struct IO_MGR *pIOMgr, IN u16 wMbVal)
+void io_intr_dsp2(IN struct io_mgr *pio_mgr, IN u16 mb_val)
 {
-	CHNLSM_InterruptDSP2(pIOMgr->hWmdContext, wMbVal);
+	sm_interrupt_dsp(pio_mgr->hwmd_context, mb_val);
 }
 
 /*
  *  ======== IO_SHMcontrol ========
- *      Sets the requested SHM setting.
+ *      Sets the requested shm setting.
  */
-DSP_STATUS IO_SHMsetting(IN struct IO_MGR *hIOMgr, IN enum SHM_DESCTYPE desc,
-			 IN void *pArgs)
+dsp_status io_sh_msetting(struct io_mgr *hio_mgr, u8 desc, void *pargs)
 {
 #ifdef CONFIG_BRIDGE_DVFS
 	u32 i;
 	struct dspbridge_platform_data *pdata =
-				omap_dspbridge_dev->dev.platform_data;
+	    omap_dspbridge_dev->dev.platform_data;
 
 	switch (desc) {
 	case SHM_CURROPP:
 		/* Update the shared memory with requested OPP information */
-		if (pArgs != NULL)
-			hIOMgr->pSharedMem->oppTableStruct.currOppPt =
-				*(u32 *)pArgs;
+		if (pargs != NULL)
+			hio_mgr->shared_mem->opp_table_struct.curr_opp_pt =
+			    *(u32 *) pargs;
 		else
 			return DSP_EFAIL;
 		break;
 	case SHM_OPPINFO:
-		/* Update the shared memory with the voltage, frequency,
-				   min and max frequency values for an OPP */
-		for (i = 0; i <= dsp_max_opps; i++) {
-			hIOMgr->pSharedMem->oppTableStruct.oppPoint[i].voltage =
-				vdd1_dsp_freq[i][0];
-			DBG_Trace(DBG_LEVEL5, "OPP shared memory -voltage: "
-				 "%d\n", hIOMgr->pSharedMem->oppTableStruct.
-				 oppPoint[i].voltage);
-			hIOMgr->pSharedMem->oppTableStruct.oppPoint[i].
-				frequency = vdd1_dsp_freq[i][1];
-			DBG_Trace(DBG_LEVEL5, "OPP shared memory -frequency: "
-				 "%d\n", hIOMgr->pSharedMem->oppTableStruct.
-				 oppPoint[i].frequency);
-			hIOMgr->pSharedMem->oppTableStruct.oppPoint[i].minFreq =
-				vdd1_dsp_freq[i][2];
-			DBG_Trace(DBG_LEVEL5, "OPP shared memory -min value: "
-				 "%d\n", hIOMgr->pSharedMem->oppTableStruct.
-				  oppPoint[i].minFreq);
-			hIOMgr->pSharedMem->oppTableStruct.oppPoint[i].maxFreq =
-				vdd1_dsp_freq[i][3];
-			DBG_Trace(DBG_LEVEL5, "OPP shared memory -max value: "
-				 "%d\n", hIOMgr->pSharedMem->oppTableStruct.
-				 oppPoint[i].maxFreq);
-		}
-		hIOMgr->pSharedMem->oppTableStruct.numOppPts = dsp_max_opps;
-		DBG_Trace(DBG_LEVEL5, "OPP shared memory - max OPP number: "
-			 "%d\n", hIOMgr->pSharedMem->oppTableStruct.numOppPts);
+		/*
+		 * Update the shared memory with the voltage, frequency,
+		 * min and max frequency values for an OPP.
+		 */
+		for (i = 0; i <= pdata->dsp_num_speeds; i++) {
+			hio_mgr->shared_mem->opp_table_struct.opp_point[i].
+			    voltage = pdata->dsp_freq_table[i].u_volts;
+			dev_dbg(bridge, "OPP-shm: voltage: %ld\n",
+				pdata->dsp_freq_table[i].u_volts);
+			hio_mgr->shared_mem->opp_table_struct.
+			    opp_point[i].frequency =
+			    pdata->dsp_freq_table[i].dsp_freq;
+			dev_dbg(bridge, "OPP-shm: frequency: %ld\n",
+				 pdata->dsp_freq_table[i].dsp_freq);
+			hio_mgr->shared_mem->opp_table_struct.opp_point[i].
+			    min_freq =
+			    pdata->dsp_freq_table[i].thresh_min_freq;
+			dev_dbg(bridge, "OPP-shm: min freq: %ld\n",
+				pdata->dsp_freq_table[i].thresh_min_freq);
+			hio_mgr->shared_mem->opp_table_struct.opp_point[i].
+			    max_freq = pdata->dsp_freq_table[i].thresh_max_freq;
+			dev_dbg(bridge, "OPP-shm: max freq: %ld\n",
+				pdata->dsp_freq_table[i].thresh_max_freq);
+		}
+		hio_mgr->shared_mem->opp_table_struct.num_opp_pts =
+		    pdata->dsp_num_speeds;
+		dev_dbg(bridge, "OPP-shm: max OPP number: %d\n",
+				pdata->dsp_num_speeds);
 		/* Update the current OPP number */
 		if (pdata->dsp_get_opp)
-			i = (*pdata->dsp_get_opp)();
-		hIOMgr->pSharedMem->oppTableStruct.currOppPt = i;
-		DBG_Trace(DBG_LEVEL7, "OPP value programmed to shared memory: "
-			 "%d\n", i);
+			i = (*pdata->dsp_get_opp) ();
+		hio_mgr->shared_mem->opp_table_struct.curr_opp_pt = i;
+		dev_dbg(bridge, "OPP-shm: value programmed = %d\n", i);
 		break;
 	case SHM_GETOPP:
 		/* Get the OPP that DSP has requested */
-		*(u32 *)pArgs = hIOMgr->pSharedMem->oppRequest.rqstOppPt;
+		*(u32 *) pargs = hio_mgr->shared_mem->opp_request.rqst_opp_pt;
 		break;
 	default:
 		break;
@@ -1749,261 +1782,240 @@
 }
 
 /*
- *  ======== WMD_IO_GetProcLoad ========
+ *  ======== bridge_io_get_proc_load ========
  *      Gets the Processor's Load information
  */
-DSP_STATUS WMD_IO_GetProcLoad(IN struct IO_MGR *hIOMgr,
-			     OUT struct DSP_PROCLOADSTAT *pProcStat)
+dsp_status bridge_io_get_proc_load(IN struct io_mgr *hio_mgr,
+				OUT struct dsp_procloadstat *pProcStat)
 {
-	pProcStat->uCurrLoad = hIOMgr->pSharedMem->loadMonInfo.currDspLoad;
-	pProcStat->uPredictedLoad = hIOMgr->pSharedMem->loadMonInfo.predDspLoad;
-	pProcStat->uCurrDspFreq = hIOMgr->pSharedMem->loadMonInfo.currDspFreq;
-	pProcStat->uPredictedFreq = hIOMgr->pSharedMem->loadMonInfo.predDspFreq;
-
-	DBG_Trace(DBG_LEVEL4, "Curr Load =%d, Pred Load = %d, Curr Freq = %d, "
-			     "Pred Freq = %d\n", pProcStat->uCurrLoad,
-			     pProcStat->uPredictedLoad, pProcStat->uCurrDspFreq,
-			     pProcStat->uPredictedFreq);
+	pProcStat->curr_load = hio_mgr->shared_mem->load_mon_info.curr_dsp_load;
+	pProcStat->predicted_load =
+	    hio_mgr->shared_mem->load_mon_info.pred_dsp_load;
+	pProcStat->curr_dsp_freq =
+	    hio_mgr->shared_mem->load_mon_info.curr_dsp_freq;
+	pProcStat->predicted_freq =
+	    hio_mgr->shared_mem->load_mon_info.pred_dsp_freq;
+
+	dev_dbg(bridge, "Curr Load = %d, Pred Load = %d, Curr Freq = %d, "
+		"Pred Freq = %d\n", pProcStat->curr_load,
+		pProcStat->predicted_load, pProcStat->curr_dsp_freq,
+		pProcStat->predicted_freq);
 	return DSP_SOK;
 }
 
 #ifndef DSP_TRACEBUF_DISABLED
-void PrintDSPDebugTrace(struct IO_MGR *hIOMgr)
+void print_dsp_debug_trace(struct io_mgr *hio_mgr)
 {
-	u32 ulNewMessageLength = 0, ulGPPCurPointer;
-
-       GT_0trace(dsp_trace_mask, GT_ENTER, "Entering PrintDSPDebugTrace\n");
+	u32 ul_new_message_length = 0, ul_gpp_cur_pointer;
 
 	while (true) {
 		/* Get the DSP current pointer */
-		ulGPPCurPointer = *(u32 *) (hIOMgr->ulTraceBufferCurrent);
-		ulGPPCurPointer = hIOMgr->ulGppVa + (ulGPPCurPointer -
-				  hIOMgr->ulDspVa);
+		ul_gpp_cur_pointer =
+		    *(u32 *) (hio_mgr->ul_trace_buffer_current);
+		ul_gpp_cur_pointer =
+		    hio_mgr->ul_gpp_va + (ul_gpp_cur_pointer -
+					  hio_mgr->ul_dsp_va);
 
 		/* No new debug messages available yet */
-		if (ulGPPCurPointer == hIOMgr->ulGPPReadPointer)
+		if (ul_gpp_cur_pointer == hio_mgr->ul_gpp_read_pointer) {
 			break;
-
-		/* Continuous data */
-		else if (ulGPPCurPointer > hIOMgr->ulGPPReadPointer) {
-			ulNewMessageLength = ulGPPCurPointer - hIOMgr->
-					     ulGPPReadPointer;
-
-			memcpy(hIOMgr->pMsg, (char *)hIOMgr->ulGPPReadPointer,
-			       ulNewMessageLength);
-			hIOMgr->pMsg[ulNewMessageLength] = '\0';
-			/* Advance the GPP trace pointer to DSP current
-			 * pointer */
-			hIOMgr->ulGPPReadPointer += ulNewMessageLength;
+		} else if (ul_gpp_cur_pointer > hio_mgr->ul_gpp_read_pointer) {
+			/* Continuous data */
+			ul_new_message_length =
+			    ul_gpp_cur_pointer - hio_mgr->ul_gpp_read_pointer;
+
+			memcpy(hio_mgr->pmsg,
+			       (char *)hio_mgr->ul_gpp_read_pointer,
+			       ul_new_message_length);
+			hio_mgr->pmsg[ul_new_message_length] = '\0';
+			/*
+			 * Advance the GPP trace pointer to DSP current
+			 * pointer.
+			 */
+			hio_mgr->ul_gpp_read_pointer += ul_new_message_length;
 			/* Print the trace messages */
-                       GT_0trace(dsp_trace_mask, GT_1CLASS, hIOMgr->pMsg);
-		}
-		/* Handle trace buffer wraparound */
-		else if (ulGPPCurPointer < hIOMgr->ulGPPReadPointer) {
-			memcpy(hIOMgr->pMsg, (char *)hIOMgr->ulGPPReadPointer,
-				hIOMgr->ulTraceBufferEnd -
-				hIOMgr->ulGPPReadPointer);
-			ulNewMessageLength = ulGPPCurPointer -
-				hIOMgr->ulTraceBufferBegin;
-			memcpy(&hIOMgr->pMsg[hIOMgr->ulTraceBufferEnd -
-				hIOMgr->ulGPPReadPointer],
-				(char *)hIOMgr->ulTraceBufferBegin,
-				ulNewMessageLength);
-			hIOMgr->pMsg[hIOMgr->ulTraceBufferEnd -
-				hIOMgr->ulGPPReadPointer +
-				ulNewMessageLength] = '\0';
-			/* Advance the GPP trace pointer to DSP current
-			 * pointer */
-			hIOMgr->ulGPPReadPointer = hIOMgr->ulTraceBufferBegin +
-						   ulNewMessageLength;
+			pr_info("DSPTrace: %s\n", hio_mgr->pmsg);
+		} else if (ul_gpp_cur_pointer < hio_mgr->ul_gpp_read_pointer) {
+			/* Handle trace buffer wraparound */
+			memcpy(hio_mgr->pmsg,
+			       (char *)hio_mgr->ul_gpp_read_pointer,
+			       hio_mgr->ul_trace_buffer_end -
+			       hio_mgr->ul_gpp_read_pointer);
+			ul_new_message_length =
+			    ul_gpp_cur_pointer - hio_mgr->ul_trace_buffer_begin;
+			memcpy(&hio_mgr->pmsg[hio_mgr->ul_trace_buffer_end -
+					      hio_mgr->ul_gpp_read_pointer],
+			       (char *)hio_mgr->ul_trace_buffer_begin,
+			       ul_new_message_length);
+			hio_mgr->pmsg[hio_mgr->ul_trace_buffer_end -
+				      hio_mgr->ul_gpp_read_pointer +
+				      ul_new_message_length] = '\0';
+			/*
+			 * Advance the GPP trace pointer to DSP current
+			 * pointer.
+			 */
+			hio_mgr->ul_gpp_read_pointer =
+			    hio_mgr->ul_trace_buffer_begin +
+			    ul_new_message_length;
 			/* Print the trace messages */
-                       GT_0trace(dsp_trace_mask, GT_1CLASS, hIOMgr->pMsg);
+			pr_info("DSPTrace: %s\n", hio_mgr->pmsg);
 		}
 	}
 }
 #endif
 
 /*
- *  ======== PackTraceBuffer ========
+ *  ======== pack_trace_buffer ========
  *      Removes extra nulls from the trace buffer returned from the DSP.
  *      Works even on buffers that already are packed (null removed); but has
  *      one bug in that case -- loses the last character (replaces with '\0').
- *      Continues through conversion for full set of nBytes input characters.
+ *      Continues through conversion for full set of bytes input characters.
  *  Parameters:
  *    lpBuf:            Pointer to input/output buffer
- *    nBytes:           Number of characters in the buffer
- *    ulNumWords:       Number of DSP words in the buffer.  Indicates potential
- *                      number of extra carriage returns to generate.
+ *    ibytes:           Number of characters in the buffer.
+ *    obytes:           Actual size of the buffer.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Unable to allocate memory.
  *  Requires:
- *      lpBuf must be a fully allocated writable block of at least nBytes.
- *      There are no more than ulNumWords extra characters needed (the number of
- *      linefeeds minus the number of NULLS in the input buffer).
- */
-#if (defined(DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE
-static DSP_STATUS PackTraceBuffer(char *lpBuf, u32 nBytes, u32 ulNumWords)
-{
-       DSP_STATUS status = DSP_SOK;
-       char *lpTmpBuf;
-       char *lpBufStart;
-       char *lpTmpStart;
-       u32 nCnt;
-       char thisChar;
-
-       /* tmp workspace, 1 KB longer than input buf */
-       lpTmpBuf = MEM_Calloc((nBytes + ulNumWords), MEM_PAGED);
-       if (lpTmpBuf == NULL) {
-               DBG_Trace(DBG_LEVEL7, "PackTrace buffer:OutofMemory \n");
-               status = DSP_EMEMORY;
-       }
-
-       if (DSP_SUCCEEDED(status)) {
-               lpBufStart = lpBuf;
-               lpTmpStart = lpTmpBuf;
-               for (nCnt = nBytes; nCnt > 0; nCnt--) {
-                       thisChar = *lpBuf++;
-                       switch (thisChar) {
-                       case '\0':      /* Skip null bytes */
-                       break;
-                       case '\n':      /* Convert \n to \r\n */
-                       /* NOTE: do not reverse order; Some OS */
-                       /* editors control doesn't understand "\n\r" */
-                       *lpTmpBuf++ = '\r';
-                       *lpTmpBuf++ = '\n';
-                       break;
-                       default:        /* Copy in the actual ascii byte */
-                       *lpTmpBuf++ = thisChar;
-                       break;
-                       }
-               }
-               *lpTmpBuf = '\0';    /* Make sure tmp buf is null terminated */
-               /* Cut output down to input buf size */
-               strncpy(lpBufStart, lpTmpStart, nBytes);
-               /*Make sure output is null terminated */
-               lpBufStart[nBytes - 1] = '\0';
-               MEM_Free(lpTmpStart);
-       }
+ *      lpBuf must be a writable block of at least obytes bytes.
+ */
+static dsp_status pack_trace_buffer(char *lpBuf, u32 ibytes, u32 obytes)
+{
+	dsp_status status = DSP_SOK;
+	char *lp_tmp_buf;
+	char *lp_buf_start;
+	char *lp_tmp_start;
+	u32 i;
+	char this_char;
+	const char escape = '\\';
+
+	/* Tmp workspace, longer than input buf */
+	lp_tmp_buf = mem_calloc(min(ibytes * 3 + 1, obytes + 3), MEM_PAGED);
+	if (lp_tmp_buf == NULL)
+		status = DSP_EMEMORY;
+
+	if (DSP_SUCCEEDED(status)) {
+		lp_buf_start = lpBuf;
+		lp_tmp_start = lp_tmp_buf;
+		for (i = ibytes; i > 0; i--) {
+			this_char = *lpBuf++;
+			/*
+			 * No attempt is made to keep any OSes or
+			 * "their editors" happy by explicitly expanding
+			 * \n into \r\n. All I care about is not sending
+			 * unsafe control characters to the console when
+			 * the root user types 'dmesg'.
+			 */
+			if (this_char == '\0') {
+				; /* skip null bytes */
+			} else if (this_char == '\t' || this_char == '\n') {
+				*lp_tmp_buf++ = this_char; /* safe ctrl char */
+			} else if (iscntrl(toascii(this_char))) {
+				lp_tmp_buf += sprintf(lp_tmp_buf, "%c%02x",
+					escape, (unsigned int)this_char);
+			} else if (this_char == escape) {
+				*lp_tmp_buf++ = escape;
+				*lp_tmp_buf++ = escape; /* self-escape */
+			} else {
+				*lp_tmp_buf++ = this_char; /* not a control */
+			}
 
-       return status;
+			if (lp_tmp_buf >= lp_tmp_start + obytes)
+				break;
+		}
+		*lp_tmp_buf = '\0';	/* Temp buf MUST be null terminated */
+		/* Cut output down to input buf size */
+		strncpy(lp_buf_start, lp_tmp_start, obytes);
+		/* Make sure output is null terminated */
+		lp_buf_start[obytes - 1] = '\0';
+		kfree(lp_tmp_start);
+	}
+
+	return status;
 }
-#endif    /* (defined(DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE */
 
 /*
- *  ======== PrintDspTraceBuffer ========
+ *  ======== print_dsp_trace_buffer ========
  *      Prints the trace buffer returned from the DSP (if DBG_Trace is enabled).
  *  Parameters:
- *    hDehMgr:          Handle to DEH manager object
+ *    hdeh_mgr:          Handle to DEH manager object
  *                      number of extra carriage returns to generate.
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Unable to allocate memory.
  *  Requires:
- *      hDehMgr muse be valid. Checked in WMD_DEH_Notify.
+ *      hdeh_mgr muse be valid. Checked in bridge_deh_notify.
  */
-DSP_STATUS PrintDspTraceBuffer(struct WMD_DEV_CONTEXT *hWmdContext)
+dsp_status print_dsp_trace_buffer(struct wmd_dev_context *hwmd_context)
 {
-       DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
+	struct cod_manager *cod_mgr;
+	u32 ul_trace_end;
+	u32 ul_trace_begin;
+	u32 ul_num_bytes = 0;
+	u32 ul_num_words = 0;
+	u32 ul_word_size = 2;
+	CONST u32 max_size = 512;
+	char *psz_buf;
+
+	struct wmd_dev_context *pwmd_context = (struct wmd_dev_context *)
+	    hwmd_context;
+	struct bridge_drv_interface *intf_fxns;
+	struct dev_object *dev_obj = (struct dev_object *)
+	    pwmd_context->hdev_obj;
 
-#if (defined(DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE
-       struct COD_MANAGER *hCodMgr;
-       u32 ulTraceEnd;
-       u32 ulTraceBegin;
-       u32 ulNumBytes = 0;
-       u32 ulNumWords = 0;
-       u32 ulWordSize = 2;
-       CONST u32 uMaxSize = 512;
-       char *pszBuf;
-       u16 *lpszBuf;
-
-       struct WMD_DEV_CONTEXT *pWmdContext = (struct WMD_DEV_CONTEXT *)
-                                               hWmdContext;
-       struct WMD_DRV_INTERFACE *pIntfFxns;
-       struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)
-                                       pWmdContext->hDevObject;
-
-       status = DEV_GetCodMgr(pDevObject, &hCodMgr);
-       if (DSP_FAILED(status))
-               GT_0trace(dsp_trace_mask, GT_2CLASS,
-               "PrintDspTraceBuffer: Failed on DEV_GetCodMgr.\n");
-
-       if (DSP_SUCCEEDED(status)) {
-               /* Look for SYS_PUTCBEG/SYS_PUTCEND: */
-               status = COD_GetSymValue(hCodMgr, COD_TRACEBEG, &ulTraceBegin);
-               GT_1trace(dsp_trace_mask, GT_2CLASS,
-                       "PrintDspTraceBuffer: ulTraceBegin Value 0x%x\n",
-                       ulTraceBegin);
-               if (DSP_FAILED(status))
-                       GT_0trace(dsp_trace_mask, GT_2CLASS,
-                               "PrintDspTraceBuffer: Failed on "
-                               "COD_GetSymValue.\n");
-       }
-       if (DSP_SUCCEEDED(status)) {
-               status = COD_GetSymValue(hCodMgr, COD_TRACEEND, &ulTraceEnd);
-               GT_1trace(dsp_trace_mask, GT_2CLASS,
-                       "PrintDspTraceBuffer: ulTraceEnd Value 0x%x\n",
-                       ulTraceEnd);
-               if (DSP_FAILED(status))
-                       GT_0trace(dsp_trace_mask, GT_2CLASS,
-                               "PrintDspTraceBuffer: Failed on "
-                               "COD_GetSymValue.\n");
-       }
-       if (DSP_SUCCEEDED(status)) {
-               ulNumBytes = (ulTraceEnd - ulTraceBegin) * ulWordSize;
-               /*  If the chip type is 55 then the addresses will be
-               *  byte addresses; convert them to word addresses.  */
-               if (ulNumBytes > uMaxSize)
-                       ulNumBytes = uMaxSize;
-
-               /* make sure the data we request fits evenly */
-               ulNumBytes = (ulNumBytes / ulWordSize) * ulWordSize;
-               GT_1trace(dsp_trace_mask, GT_2CLASS, "PrintDspTraceBuffer: "
-                       "ulNumBytes 0x%x\n", ulNumBytes);
-               ulNumWords = ulNumBytes * ulWordSize;
-               GT_1trace(dsp_trace_mask, GT_2CLASS, "PrintDspTraceBuffer: "
-                       "ulNumWords 0x%x\n", ulNumWords);
-               status = DEV_GetIntfFxns(pDevObject, &pIntfFxns);
-       }
-
-       if (DSP_SUCCEEDED(status)) {
-               pszBuf = MEM_Calloc(uMaxSize, MEM_NONPAGED);
-               lpszBuf = MEM_Calloc(ulNumBytes * 2, MEM_NONPAGED);
-               if (pszBuf != NULL) {
-                       /* Read bytes from the DSP trace buffer... */
-                       status = (*pIntfFxns->pfnBrdRead)(hWmdContext,
-                               (u8 *)pszBuf, (u32)ulTraceBegin,
-                               ulNumBytes, 0);
-                       if (DSP_FAILED(status))
-                               GT_0trace(dsp_trace_mask, GT_2CLASS,
-                                       "PrintDspTraceBuffer: "
-                                       "Failed to Read Trace Buffer.\n");
-
-                       if (DSP_SUCCEEDED(status)) {
-                               /* Pack and do newline conversion */
-                               GT_0trace(dsp_trace_mask, GT_2CLASS,
-                                       "PrintDspTraceBuffer: "
-                                       "before pack and unpack.\n");
-                               PackTraceBuffer(pszBuf, ulNumBytes, ulNumWords);
-                               GT_1trace(dsp_trace_mask, GT_1CLASS,
-                                       "DSP Trace Buffer:\n%s\n", pszBuf);
-                       }
-                       MEM_Free(pszBuf);
-                       MEM_Free(lpszBuf);
-               } else {
-                       GT_0trace(dsp_trace_mask, GT_2CLASS,
-                               "PrintDspTraceBuffer: Failed to "
-                               "allocate trace buffer.\n");
-                       status = DSP_EMEMORY;
-               }
-       }
-#endif
-       return status;
-}
+	status = dev_get_cod_mgr(dev_obj, &cod_mgr);
 
-void IO_SM_init(void)
-{
+	if (DSP_SUCCEEDED(status)) {
+		/* Look for SYS_PUTCBEG/SYS_PUTCEND */
+		status =
+		    cod_get_sym_value(cod_mgr, COD_TRACEBEG, &ul_trace_begin);
+	}
+	if (DSP_SUCCEEDED(status))
+		status =
+		    cod_get_sym_value(cod_mgr, COD_TRACEEND, &ul_trace_end);
+
+	if (DSP_SUCCEEDED(status)) {
+		ul_num_bytes = (ul_trace_end - ul_trace_begin) * ul_word_size;
+		/*
+		 * If the chip type is 55 then the addresses will be
+		 * byte addresses; convert them to word addresses.
+		 */
+		if (ul_num_bytes > max_size)
+			ul_num_bytes = max_size;
+
+		/* Make sure the data we request fits evenly */
+		ul_num_bytes = (ul_num_bytes / ul_word_size) * ul_word_size;
+		ul_num_words = ul_num_bytes * ul_word_size;
+		status = dev_get_intf_fxns(dev_obj, &intf_fxns);
+	}
 
-       GT_create(&dsp_trace_mask, "DT"); /* DSP Trace Mask */
+	if (DSP_SUCCEEDED(status)) {
+		psz_buf = mem_calloc(max_size, MEM_NONPAGED);
+		if (psz_buf != NULL) {
+			/* Read bytes from the DSP trace buffer... */
+			status = (*intf_fxns->pfn_brd_read) (hwmd_context,
+							     (u8 *) psz_buf,
+							     (u32)
+							     ul_trace_begin,
+							     ul_num_bytes, 0);
 
+			if (DSP_SUCCEEDED(status)) {
+				/* Pack and do escape conversion */
+				pack_trace_buffer(psz_buf, ul_num_bytes,
+						  max_size);
+				pr_info("%s:\n%s\n", __func__, psz_buf);
+			}
+			kfree(psz_buf);
+		} else {
+			status = DSP_EMEMORY;
+		}
+	}
+	return status;
+}
+
+void io_sm_init(void)
+{
+	/* Do nothing */
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/mmu_fault.c kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/mmu_fault.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/mmu_fault.c	2011-10-11 13:51:02.254976563 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/mmu_fault.c	2011-10-23 08:22:37.688551000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implements DSP MMU fault handling functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,23 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== mmu_fault.c ========
- *  Description:
- *      Implements DSP MMU fault handling functions.
- *
- *! Revision History:
- *! ================
- *! 26-Dec-2004 hn: Support for IVA MMU exception.
- *! 06-Mar-2003 sb: Print MMU fault address. Cosmetic changes.
- *! 16-Feb-2003 vp: Fixed warning in MMU_FaultIsr
- *! 05-Jan-2004 vp: Updated support for 24xx silicon
- *! 19-Feb-2003 vp: Code review updates.
- *!                 - Cosmetic changes.
- *! 18-Oct-2002 sb: Ported to Linux platform.
- *! 10-Sep-2001 kc: created.
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
@@ -39,10 +24,8 @@
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/host_os.h>
 #include <dspbridge/dbc.h>
-#include <dspbridge/dbg.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/dpc.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/drv.h>
 
@@ -60,113 +43,101 @@
 #include "_tiomap.h"
 #include "mmu_fault.h"
 
-static u32 dmmuEventMask;
-u32 faultAddr;
+static u32 dmmu_event_mask;
+u32 fault_addr;
 
-static bool MMU_CheckIfFault(struct WMD_DEV_CONTEXT *pDevContext);
+static bool mmu_check_if_fault(struct wmd_dev_context *dev_context);
 
 /*
- *  ======== MMU_FaultDpc ========
+ *  ======== mmu_fault_dpc ========
  *      Deferred procedure call to handle DSP MMU fault.
  */
-void MMU_FaultDpc(IN void *pRefData)
+void mmu_fault_dpc(IN unsigned long pRefData)
 {
-	struct DEH_MGR *hDehMgr = (struct DEH_MGR *)pRefData;
-	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)hDehMgr;
-
-	DBG_Trace(DBG_LEVEL1, "MMU_FaultDpc Enter: 0x%x\n", pRefData);
+	struct deh_mgr *hdeh_mgr = (struct deh_mgr *)pRefData;
 
-	if (pDehMgr)
-		WMD_DEH_Notify(hDehMgr, DSP_MMUFAULT, 0L);
+	if (hdeh_mgr)
+		bridge_deh_notify(hdeh_mgr, DSP_MMUFAULT, 0L);
 
-	DBG_Trace(DBG_LEVEL1, "MMU_FaultDpc Exit: 0x%x\n", pRefData);
 }
 
 /*
- *  ======== MMU_FaultIsr ========
+ *  ======== mmu_fault_isr ========
  *      ISR to be triggered by a DSP MMU fault interrupt.
  */
-irqreturn_t  MMU_FaultIsr(int irq, IN void *pRefData)
+irqreturn_t mmu_fault_isr(int irq, IN void *pRefData)
 {
-	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)pRefData;
-	struct WMD_DEV_CONTEXT *pDevContext;
-	struct CFG_HOSTRES resources;
-	DSP_STATUS status = DSP_SOK;
-
-
-	DBG_Trace(DBG_LEVEL1, "Entering DEH_DspMmuIsr: 0x%x\n", pRefData);
-       DBC_Require(irq == INT_DSP_MMU_IRQ);
-	DBC_Require(MEM_IsValidHandle(pDehMgr, SIGNATURE));
-
-	if (MEM_IsValidHandle(pDehMgr, SIGNATURE)) {
-
-		pDevContext = (struct WMD_DEV_CONTEXT *)pDehMgr->hWmdContext;
-		status = CFG_GetHostResources(
-			 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
-			 &resources);
+	struct deh_mgr *deh_mgr_obj = (struct deh_mgr *)pRefData;
+	struct wmd_dev_context *dev_context;
+	struct cfg_hostres resources;
+	dsp_status status = DSP_SOK;
+
+	DBC_REQUIRE(irq == INT_DSP_MMU_IRQ);
+	DBC_REQUIRE(MEM_IS_VALID_HANDLE(deh_mgr_obj, SIGNATURE));
+
+	if (MEM_IS_VALID_HANDLE(deh_mgr_obj, SIGNATURE)) {
+
+		dev_context =
+		    (struct wmd_dev_context *)deh_mgr_obj->hwmd_context;
+		status = cfg_get_host_resources((struct cfg_devnode *)
+						drv_get_first_dev_extension(),
+						&resources);
 		if (DSP_FAILED(status))
-			DBG_Trace(DBG_LEVEL7,
-				 "**Failed to get Host Resources "
-				 "in MMU ISR **\n");
-		if (MMU_CheckIfFault(pDevContext)) {
+			dev_dbg(bridge, "%s: Failed to get Host Resources\n",
+				__func__);
+		if (mmu_check_if_fault(dev_context)) {
 			printk(KERN_INFO "***** DSPMMU FAULT ***** IRQStatus "
-				"0x%x\n", dmmuEventMask);
-			printk(KERN_INFO "***** DSPMMU FAULT ***** faultAddr "
-				"0x%x\n", faultAddr);
-			/* Disable the MMU events, else once we clear it will
-			 * start to raise INTs again */
+			       "0x%x\n", dmmu_event_mask);
+			printk(KERN_INFO "***** DSPMMU FAULT ***** fault_addr "
+			       "0x%x\n", fault_addr);
 			/*
 			 * Schedule a DPC directly. In the future, it may be
 			 * necessary to check if DSP MMU fault is intended for
 			 * Bridge.
 			 */
-			DPC_Schedule(pDehMgr->hMmuFaultDpc);
-			/* Reset errInfo structure before use. */
-			pDehMgr->errInfo.dwErrMask = DSP_MMUFAULT;
-			pDehMgr->errInfo.dwVal1 = faultAddr >> 16;
-			pDehMgr->errInfo.dwVal2 = faultAddr & 0xFFFF;
-			pDehMgr->errInfo.dwVal3 = 0L;
+			tasklet_schedule(&deh_mgr_obj->dpc_tasklet);
+
+			/* Reset err_info structure before use. */
+			deh_mgr_obj->err_info.dw_err_mask = DSP_MMUFAULT;
+			deh_mgr_obj->err_info.dw_val1 = fault_addr >> 16;
+			deh_mgr_obj->err_info.dw_val2 = fault_addr & 0xFFFF;
+			deh_mgr_obj->err_info.dw_val3 = 0L;
 			/* Disable the MMU events, else once we clear it will
 			 * start to raise INTs again */
-			HW_MMU_EventDisable(resources.dwDmmuBase,
-					    HW_MMU_TRANSLATION_FAULT);
+			hw_mmu_event_disable(resources.dw_dmmu_base,
+					     HW_MMU_TRANSLATION_FAULT);
 		} else {
-			DBG_Trace(DBG_LEVEL7,
-				 "***** MMU FAULT ***** faultcode 0x%x\n",
-				 dmmuEventMask);
-			HW_MMU_EventDisable(resources.dwDmmuBase,
-					    HW_MMU_ALL_INTERRUPTS);
+			hw_mmu_event_disable(resources.dw_dmmu_base,
+					     HW_MMU_ALL_INTERRUPTS);
 		}
 	}
-       return IRQ_HANDLED;
+	return IRQ_HANDLED;
 }
 
-
 /*
- *  ======== MMU_CheckIfFault ========
+ *  ======== mmu_check_if_fault ========
  *      Check to see if MMU Fault is valid TLB miss from DSP
  *  Note: This function is called from an ISR
  */
-static bool MMU_CheckIfFault(struct WMD_DEV_CONTEXT *pDevContext)
+static bool mmu_check_if_fault(struct wmd_dev_context *dev_context)
 {
 
-
-	bool retVal = false;
-	DSP_STATUS status = DSP_SOK;
-	HW_STATUS hwStatus;
-	struct CFG_HOSTRES resources;
-	status = CFG_GetHostResources(
-		(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	bool ret = false;
+	dsp_status status = DSP_SOK;
+	hw_status hw_status_obj;
+	struct cfg_hostres resources;
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 	if (DSP_FAILED(status))
-		DBG_Trace(DBG_LEVEL7, "**Failed to get Host Resources in "
-			 "MMU_CheckIfFault **\n");
+		dev_dbg(bridge, "%s: Failed to get Host Resources in\n",
+			__func__);
 
-	hwStatus = HW_MMU_EventStatus(resources.dwDmmuBase, &dmmuEventMask);
-	if (dmmuEventMask  ==  HW_MMU_TRANSLATION_FAULT) {
-		HW_MMU_FaultAddrRead(resources.dwDmmuBase, &faultAddr);
-		DBG_Trace(DBG_LEVEL1, "WMD_DEH_Notify: DSP_MMUFAULT, fault "
-			 "address = 0x%x\n", faultAddr);
-		retVal = true;
+	hw_status_obj =
+	    hw_mmu_event_status(resources.dw_dmmu_base, &dmmu_event_mask);
+	if (dmmu_event_mask == HW_MMU_TRANSLATION_FAULT) {
+		hw_mmu_fault_addr_read(resources.dw_dmmu_base, &fault_addr);
+		ret = true;
 	}
-	return retVal;
+	return ret;
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/mmu_fault.h kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/mmu_fault.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/mmu_fault.h	2011-10-11 13:51:02.254976563 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/mmu_fault.h	2011-10-23 08:22:37.688551000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Defines DSP MMU fault handling functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,32 +16,19 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== mmu_fault.h ========
- *  Description:
- *      Defines DSP MMU fault handling functions.
- *
- *! Revision History:
- *! ================
- *! 26-Dec-2004 hn: IVA MMU handlers.
- *! 10-Sep-2001 kc: created.
- */
-
 #ifndef MMU_FAULT_
 #define MMU_FAULT_
 
 /*
- *  ======== MMU_FaultDpc ========
+ *  ======== mmu_fault_dpc ========
  *      Deferred procedure call to handle DSP MMU fault.
  */
-	void MMU_FaultDpc(IN void *pRefData);
+void mmu_fault_dpc(IN unsigned long pRefData);
 
 /*
- *  ======== MMU_FaultIsr ========
+ *  ======== mmu_fault_isr ========
  *      ISR to be triggered by a DSP MMU fault interrupt.
  */
-irqreturn_t  MMU_FaultIsr(int irq, IN void *pRefData);
-
-#endif				/* MMU_FAULT_ */
+irqreturn_t mmu_fault_isr(int irq, IN void *pRefData);
 
+#endif /* MMU_FAULT_ */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/msg_sm.c kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/msg_sm.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/msg_sm.c	2011-10-11 13:51:02.265697500 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/msg_sm.c	2011-10-23 08:22:37.688551000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implements upper edge functions for WMD message module.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,34 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== msg_sm.c ========
- *  Description:
- *      Implements upper edge functions for WMD message module.
- *
- *  Public Functions:
- *      WMD_MSG_Create
- *      WMD_MSG_CreateQueue
- *      WMD_MSG_Delete
- *      WMD_MSG_DeleteQueue
- *      WMD_MSG_Get
- *      WMD_MSG_Put
- *      WMD_MSG_RegisterNotify
- *      WMD_MSG_SetQueueId
- *
- *! Revision History:
- *! =================
- *! 24-Jul-2002 jeh     Release critical section in WMD_MSG_Put() before
- *!                     scheduling DPC.
- *! 09-May-2001 jeh     Free MSG queue NTFY object, remove unnecessary set/
- *!                     reset of events.
- *! 10-Jan-2001 jeh     Set/Reset message manager and message queue events
- *!                     correctly.
- *! 04-Dec-2000 jeh     Bug fixes.
- *! 12-Sep-2000 jeh     Created.
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
@@ -69,288 +43,318 @@
 #define MSGQ_SIGNATURE      0x5147534d	/* "QGSM" */
 
 /*  ----------------------------------- Function Prototypes */
-static DSP_STATUS AddNewMsg(struct LST_LIST *msgList);
-static void DeleteMsgMgr(struct MSG_MGR *hMsgMgr);
-static void DeleteMsgQueue(struct MSG_QUEUE *hMsgQueue, u32 uNumToDSP);
-static void FreeMsgList(struct LST_LIST *msgList);
+static dsp_status add_new_msg(struct lst_list *msgList);
+static void delete_msg_mgr(struct msg_mgr *hmsg_mgr);
+static void delete_msg_queue(struct msg_queue *msg_queue_obj, u32 uNumToDSP);
+static void free_msg_list(struct lst_list *msgList);
 
 /*
- *  ======== WMD_MSG_Create ========
+ *  ======== bridge_msg_create ========
  *      Create an object to manage message queues. Only one of these objects
  *      can exist per device object.
  */
-DSP_STATUS WMD_MSG_Create(OUT struct MSG_MGR **phMsgMgr,
-			 struct DEV_OBJECT *hDevObject, MSG_ONEXIT msgCallback)
-{
-	struct MSG_MGR *pMsgMgr;
-	struct IO_MGR *hIOMgr;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(phMsgMgr != NULL);
-	DBC_Require(msgCallback != NULL);
-	DBC_Require(hDevObject != NULL);
-	DEV_GetIOMgr(hDevObject, &hIOMgr);
-	DBC_Assert(hIOMgr != NULL);
+dsp_status bridge_msg_create(OUT struct msg_mgr **phMsgMgr,
+			     struct dev_object *hdev_obj,
+			     msg_onexit msgCallback)
+{
+	struct msg_mgr *msg_mgr_obj;
+	struct io_mgr *hio_mgr;
+	dsp_status status = DSP_SOK;
+
+	if (!phMsgMgr || !msgCallback || !hdev_obj) {
+		status = DSP_EPOINTER;
+		goto func_end;
+	}
+	dev_get_io_mgr(hdev_obj, &hio_mgr);
+	if (!hio_mgr) {
+		status = DSP_EPOINTER;
+		goto func_end;
+	}
 	*phMsgMgr = NULL;
-	/* Allocate MSG manager object */
-	MEM_AllocObject(pMsgMgr, struct MSG_MGR, MSGMGR_SIGNATURE);
+	/* Allocate msg_ctrl manager object */
+	MEM_ALLOC_OBJECT(msg_mgr_obj, struct msg_mgr, MSGMGR_SIGNATURE);
 
-	if (pMsgMgr) {
-		pMsgMgr->onExit = msgCallback;
-		pMsgMgr->hIOMgr = hIOMgr;
+	if (msg_mgr_obj) {
+		msg_mgr_obj->on_exit = msgCallback;
+		msg_mgr_obj->hio_mgr = hio_mgr;
 		/* List of MSG_QUEUEs */
-		pMsgMgr->queueList = LST_Create();
-		 /*  Queues of message frames for messages to the DSP. Message
-		  * frames will only be added to the free queue when a
-		  * MSG_QUEUE object is created.  */
-		pMsgMgr->msgFreeList = LST_Create();
-		pMsgMgr->msgUsedList = LST_Create();
-		if (pMsgMgr->queueList == NULL ||
-		    pMsgMgr->msgFreeList == NULL ||
-		    pMsgMgr->msgUsedList == NULL)
+		msg_mgr_obj->queue_list = mem_calloc(sizeof(struct lst_list),
+						     MEM_NONPAGED);
+		/*  Queues of message frames for messages to the DSP. Message
+		 * frames will only be added to the free queue when a
+		 * msg_queue object is created. */
+		msg_mgr_obj->msg_free_list = mem_calloc(sizeof(struct lst_list),
+							MEM_NONPAGED);
+		msg_mgr_obj->msg_used_list = mem_calloc(sizeof(struct lst_list),
+							MEM_NONPAGED);
+		if (msg_mgr_obj->queue_list == NULL ||
+		    msg_mgr_obj->msg_free_list == NULL ||
+		    msg_mgr_obj->msg_used_list == NULL) {
 			status = DSP_EMEMORY;
-		if (DSP_SUCCEEDED(status))
-			status = SYNC_InitializeDPCCS(&pMsgMgr->hSyncCS);
+		} else {
+			INIT_LIST_HEAD(&msg_mgr_obj->queue_list->head);
+			INIT_LIST_HEAD(&msg_mgr_obj->msg_free_list->head);
+			INIT_LIST_HEAD(&msg_mgr_obj->msg_used_list->head);
+			status = sync_initialize_dpccs(&msg_mgr_obj->sync_cs);
+		}
 
-		 /*  Create an event to be used by WMD_MSG_Put() in waiting
-		 *  for an available free frame from the message manager.  */
+		/*  Create an event to be used by bridge_msg_put() in waiting
+		 *  for an available free frame from the message manager. */
 		if (DSP_SUCCEEDED(status))
-			status = SYNC_OpenEvent(&pMsgMgr->hSyncEvent, NULL);
+			status =
+			    sync_open_event(&msg_mgr_obj->sync_event, NULL);
 
 		if (DSP_SUCCEEDED(status))
-			*phMsgMgr = pMsgMgr;
+			*phMsgMgr = msg_mgr_obj;
 		else
-			DeleteMsgMgr(pMsgMgr);
+			delete_msg_mgr(msg_mgr_obj);
 
 	} else {
 		status = DSP_EMEMORY;
 	}
+func_end:
 	return status;
 }
 
 /*
- *  ======== WMD_MSG_CreateQueue ========
- *      Create a MSG_QUEUE for sending/receiving messages to/from a node
+ *  ======== bridge_msg_create_queue ========
+ *      Create a msg_queue for sending/receiving messages to/from a node
  *      on the DSP.
  */
-DSP_STATUS WMD_MSG_CreateQueue(struct MSG_MGR *hMsgMgr,
-			      OUT struct MSG_QUEUE **phMsgQueue,
-			      u32 dwId, u32 uMaxMsgs, HANDLE hArg)
+dsp_status bridge_msg_create_queue(struct msg_mgr *hmsg_mgr,
+				OUT struct msg_queue **phMsgQueue,
+				u32 msgq_id, u32 max_msgs, bhandle arg)
 {
 	u32 i;
-	u32 uNumAllocated = 0;
-	struct MSG_QUEUE *pMsgQ;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE));
-	DBC_Require(phMsgQueue != NULL);
+	u32 num_allocated = 0;
+	struct msg_queue *msg_q;
+	dsp_status status = DSP_SOK;
+
+	if (!MEM_IS_VALID_HANDLE(hmsg_mgr, MSGMGR_SIGNATURE) ||
+	    phMsgQueue == NULL || !hmsg_mgr->msg_free_list) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 
 	*phMsgQueue = NULL;
-	/* Allocate MSG_QUEUE object */
-	MEM_AllocObject(pMsgQ, struct MSG_QUEUE, MSGQ_SIGNATURE);
-	if (!pMsgQ) {
+	/* Allocate msg_queue object */
+	MEM_ALLOC_OBJECT(msg_q, struct msg_queue, MSGQ_SIGNATURE);
+	if (!msg_q) {
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
-	LST_InitElem((struct LST_ELEM *) pMsgQ);
-	pMsgQ->uMaxMsgs = uMaxMsgs;
-	pMsgQ->hMsgMgr = hMsgMgr;
-	pMsgQ->hArg = hArg;	/* Node handle */
-	pMsgQ->dwId = dwId;	/* Node env (not valid yet) */
+	lst_init_elem((struct list_head *)msg_q);
+	msg_q->max_msgs = max_msgs;
+	msg_q->hmsg_mgr = hmsg_mgr;
+	msg_q->arg = arg;	/* Node handle */
+	msg_q->msgq_id = msgq_id;	/* Node env (not valid yet) */
 	/* Queues of Message frames for messages from the DSP */
-	pMsgQ->msgFreeList = LST_Create();
-	pMsgQ->msgUsedList = LST_Create();
-	if (pMsgQ->msgFreeList == NULL || pMsgQ->msgUsedList == NULL)
+	msg_q->msg_free_list =
+	    mem_calloc(sizeof(struct lst_list), MEM_NONPAGED);
+	msg_q->msg_used_list =
+	    mem_calloc(sizeof(struct lst_list), MEM_NONPAGED);
+	if (msg_q->msg_free_list == NULL || msg_q->msg_used_list == NULL)
 		status = DSP_EMEMORY;
+	else {
+		INIT_LIST_HEAD(&msg_q->msg_free_list->head);
+		INIT_LIST_HEAD(&msg_q->msg_used_list->head);
+	}
 
-	 /*  Create event that will be signalled when a message from
-	 *  the DSP is available.  */
+	/*  Create event that will be signalled when a message from
+	 *  the DSP is available. */
 	if (DSP_SUCCEEDED(status))
-		status = SYNC_OpenEvent(&pMsgQ->hSyncEvent, NULL);
+		status = sync_open_event(&msg_q->sync_event, NULL);
 
 	/* Create a notification list for message ready notification. */
 	if (DSP_SUCCEEDED(status))
-		status = NTFY_Create(&pMsgQ->hNtfy);
+		status = ntfy_create(&msg_q->ntfy_obj);
 
-	 /*  Create events that will be used to synchronize cleanup
-	 *  when the object is deleted. hSyncDone will be set to
-	 *  unblock threads in MSG_Put() or MSG_Get(). hSyncDoneAck
+	/*  Create events that will be used to synchronize cleanup
+	 *  when the object is deleted. sync_done will be set to
+	 *  unblock threads in MSG_Put() or MSG_Get(). sync_done_ack
 	 *  will be set by the unblocked thread to signal that it
-	 *  is unblocked and will no longer reference the object.  */
+	 *  is unblocked and will no longer reference the object. */
 	if (DSP_SUCCEEDED(status))
-		status = SYNC_OpenEvent(&pMsgQ->hSyncDone, NULL);
+		status = sync_open_event(&msg_q->sync_done, NULL);
 
 	if (DSP_SUCCEEDED(status))
-		status = SYNC_OpenEvent(&pMsgQ->hSyncDoneAck, NULL);
+		status = sync_open_event(&msg_q->sync_done_ack, NULL);
 
 	if (DSP_SUCCEEDED(status)) {
-               if (!hMsgMgr->msgFreeList) {
-                       status = DSP_EHANDLE;
-                       goto func_end;
-               }
 		/* Enter critical section */
-		(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
+		(void)sync_enter_cs(hmsg_mgr->sync_cs);
 		/* Initialize message frames and put in appropriate queues */
-		for (i = 0; i < uMaxMsgs && DSP_SUCCEEDED(status); i++) {
-			status = AddNewMsg(hMsgMgr->msgFreeList);
+		for (i = 0; i < max_msgs && DSP_SUCCEEDED(status); i++) {
+			status = add_new_msg(hmsg_mgr->msg_free_list);
 			if (DSP_SUCCEEDED(status)) {
-				uNumAllocated++;
-				status = AddNewMsg(pMsgQ->msgFreeList);
+				num_allocated++;
+				status = add_new_msg(msg_q->msg_free_list);
 			}
 		}
 		if (DSP_FAILED(status)) {
 			/*  Stay inside CS to prevent others from taking any
-			 *  of the newly allocated message frames.  */
-			DeleteMsgQueue(pMsgQ, uNumAllocated);
+			 *  of the newly allocated message frames. */
+			delete_msg_queue(msg_q, num_allocated);
 		} else {
-			LST_PutTail(hMsgMgr->queueList,
-				   (struct LST_ELEM *)pMsgQ);
-			*phMsgQueue = pMsgQ;
+			lst_put_tail(hmsg_mgr->queue_list,
+				     (struct list_head *)msg_q);
+			*phMsgQueue = msg_q;
 			/* Signal that free frames are now available */
-			if (!LST_IsEmpty(hMsgMgr->msgFreeList))
-				SYNC_SetEvent(hMsgMgr->hSyncEvent);
+			if (!LST_IS_EMPTY(hmsg_mgr->msg_free_list))
+				sync_set_event(hmsg_mgr->sync_event);
 
 		}
 		/* Exit critical section */
-		(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+		(void)sync_leave_cs(hmsg_mgr->sync_cs);
 	} else {
-		DeleteMsgQueue(pMsgQ, 0);
+		delete_msg_queue(msg_q, 0);
 	}
 func_end:
 	return status;
 }
 
 /*
- *  ======== WMD_MSG_Delete ========
- *      Delete a MSG manager allocated in WMD_MSG_Create().
+ *  ======== bridge_msg_delete ========
+ *      Delete a msg_ctrl manager allocated in bridge_msg_create().
  */
-void WMD_MSG_Delete(struct MSG_MGR *hMsgMgr)
+void bridge_msg_delete(struct msg_mgr *hmsg_mgr)
 {
-	DBC_Require(MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE));
-
-	DeleteMsgMgr(hMsgMgr);
+	if (MEM_IS_VALID_HANDLE(hmsg_mgr, MSGMGR_SIGNATURE))
+		delete_msg_mgr(hmsg_mgr);
 }
 
 /*
- *  ======== WMD_MSG_DeleteQueue ========
- *      Delete a MSG queue allocated in WMD_MSG_CreateQueue.
+ *  ======== bridge_msg_delete_queue ========
+ *      Delete a msg_ctrl queue allocated in bridge_msg_create_queue.
  */
-void WMD_MSG_DeleteQueue(struct MSG_QUEUE *hMsgQueue)
+void bridge_msg_delete_queue(struct msg_queue *msg_queue_obj)
 {
-	struct MSG_MGR *hMsgMgr = hMsgQueue->hMsgMgr;
-	u32 refCount;
+	struct msg_mgr *hmsg_mgr;
+	u32 io_msg_pend;
+
+	if (!MEM_IS_VALID_HANDLE(msg_queue_obj, MSGQ_SIGNATURE) ||
+	    !msg_queue_obj->hmsg_mgr)
+		goto func_end;
 
-	DBC_Require(MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE));
-	hMsgQueue->fDone = true;
-	 /*  Unblock all threads blocked in MSG_Get() or MSG_Put().  */
-	refCount = hMsgQueue->refCount;
-	while (refCount) {
+	hmsg_mgr = msg_queue_obj->hmsg_mgr;
+	msg_queue_obj->done = true;
+	/*  Unblock all threads blocked in MSG_Get() or MSG_Put(). */
+	io_msg_pend = msg_queue_obj->io_msg_pend;
+	while (io_msg_pend) {
 		/* Unblock thread */
-		SYNC_SetEvent(hMsgQueue->hSyncDone);
+		sync_set_event(msg_queue_obj->sync_done);
 		/* Wait for acknowledgement */
-		SYNC_WaitOnEvent(hMsgQueue->hSyncDoneAck, SYNC_INFINITE);
-		refCount = hMsgQueue->refCount;
+		sync_wait_on_event(msg_queue_obj->sync_done_ack, SYNC_INFINITE);
+		io_msg_pend = msg_queue_obj->io_msg_pend;
 	}
-	/* Remove message queue from hMsgMgr->queueList */
-	(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
-	LST_RemoveElem(hMsgMgr->queueList, (struct LST_ELEM *)hMsgQueue);
+	/* Remove message queue from hmsg_mgr->queue_list */
+	(void)sync_enter_cs(hmsg_mgr->sync_cs);
+	lst_remove_elem(hmsg_mgr->queue_list,
+			(struct list_head *)msg_queue_obj);
 	/* Free the message queue object */
-	DeleteMsgQueue(hMsgQueue, hMsgQueue->uMaxMsgs);
-       if (!hMsgMgr->msgFreeList)
-               goto func_cont;
-	if (LST_IsEmpty(hMsgMgr->msgFreeList))
-		SYNC_ResetEvent(hMsgMgr->hSyncEvent);
+	delete_msg_queue(msg_queue_obj, msg_queue_obj->max_msgs);
+	if (!hmsg_mgr->msg_free_list)
+		goto func_cont;
+	if (LST_IS_EMPTY(hmsg_mgr->msg_free_list))
+		sync_reset_event(hmsg_mgr->sync_event);
 func_cont:
-	(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+	(void)sync_leave_cs(hmsg_mgr->sync_cs);
+func_end:
+	return;
 }
 
 /*
- *  ======== WMD_MSG_Get ========
- *      Get a message from a MSG queue.
+ *  ======== bridge_msg_get ========
+ *      Get a message from a msg_ctrl queue.
  */
-DSP_STATUS WMD_MSG_Get(struct MSG_QUEUE *hMsgQueue,
-		      struct DSP_MSG *pMsg, u32 uTimeout)
+dsp_status bridge_msg_get(struct msg_queue *msg_queue_obj,
+			  struct dsp_msg *pmsg, u32 utimeout)
 {
-	struct MSG_FRAME *pMsgFrame;
-	struct MSG_MGR *hMsgMgr;
-	bool fGotMsg = false;
-	struct SYNC_OBJECT *hSyncs[2];
-	u32 uIndex;
-	DSP_STATUS status = DSP_SOK;
+	struct msg_frame *msg_frame_obj;
+	struct msg_mgr *hmsg_mgr;
+	bool got_msg = false;
+	struct sync_object *syncs[2];
+	u32 index;
+	dsp_status status = DSP_SOK;
 
-	DBC_Require(MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE));
-	DBC_Require(pMsg != NULL);
+	if (!MEM_IS_VALID_HANDLE(msg_queue_obj, MSGQ_SIGNATURE) ||
+	    pmsg == NULL) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
 
-	hMsgMgr = hMsgQueue->hMsgMgr;
-       if (!hMsgQueue->msgUsedList) {
-               status = DSP_EHANDLE;
-               goto func_end;
-       }
+	hmsg_mgr = msg_queue_obj->hmsg_mgr;
+	if (!msg_queue_obj->msg_used_list) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 
 	/* Enter critical section */
-	(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
+	(void)sync_enter_cs(hmsg_mgr->sync_cs);
 	/* If a message is already there, get it */
-	if (!LST_IsEmpty(hMsgQueue->msgUsedList)) {
-		pMsgFrame = (struct MSG_FRAME *)LST_GetHead(hMsgQueue->
-			    msgUsedList);
-		if (pMsgFrame != NULL) {
-			*pMsg = pMsgFrame->msgData.msg;
-			LST_PutTail(hMsgQueue->msgFreeList,
-				   (struct LST_ELEM *)pMsgFrame);
-			if (LST_IsEmpty(hMsgQueue->msgUsedList))
-				SYNC_ResetEvent(hMsgQueue->hSyncEvent);
+	if (!LST_IS_EMPTY(msg_queue_obj->msg_used_list)) {
+		msg_frame_obj = (struct msg_frame *)
+		    lst_get_head(msg_queue_obj->msg_used_list);
+		if (msg_frame_obj != NULL) {
+			*pmsg = msg_frame_obj->msg_data.msg;
+			lst_put_tail(msg_queue_obj->msg_free_list,
+				     (struct list_head *)msg_frame_obj);
+			if (LST_IS_EMPTY(msg_queue_obj->msg_used_list))
+				sync_reset_event(msg_queue_obj->sync_event);
 
-			fGotMsg = true;
+			got_msg = true;
 		}
 	} else {
-		if (hMsgQueue->fDone)
+		if (msg_queue_obj->done)
 			status = DSP_EFAIL;
 		else
-			hMsgQueue->refCount++;
+			msg_queue_obj->io_msg_pend++;
 
 	}
 	/* Exit critical section */
-	(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
-	if (DSP_SUCCEEDED(status) && !fGotMsg) {
+	(void)sync_leave_cs(hmsg_mgr->sync_cs);
+	if (DSP_SUCCEEDED(status) && !got_msg) {
 		/*  Wait til message is available, timeout, or done. We don't
 		 *  have to schedule the DPC, since the DSP will send messages
-		 *  when they are available.  */
-		hSyncs[0] = hMsgQueue->hSyncEvent;
-		hSyncs[1] = hMsgQueue->hSyncDone;
-		status = SYNC_WaitOnMultipleEvents(hSyncs, 2, uTimeout,
-			 &uIndex);
+		 *  when they are available. */
+		syncs[0] = msg_queue_obj->sync_event;
+		syncs[1] = msg_queue_obj->sync_done;
+		status = sync_wait_on_multiple_events(syncs, 2, utimeout,
+						      &index);
 		/* Enter critical section */
-		(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
-		if (hMsgQueue->fDone) {
-			hMsgQueue->refCount--;
+		(void)sync_enter_cs(hmsg_mgr->sync_cs);
+		if (msg_queue_obj->done) {
+			msg_queue_obj->io_msg_pend--;
 			/* Exit critical section */
-			(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
-			 /*  Signal that we're not going to access hMsgQueue
-			  *  anymore, so it can be deleted.  */
-			(void)SYNC_SetEvent(hMsgQueue->hSyncDoneAck);
+			(void)sync_leave_cs(hmsg_mgr->sync_cs);
+			/*  Signal that we're not going to access msg_queue_obj
+			 *  anymore, so it can be deleted. */
+			(void)sync_set_event(msg_queue_obj->sync_done_ack);
 			status = DSP_EFAIL;
 		} else {
 			if (DSP_SUCCEEDED(status)) {
-				DBC_Assert(!LST_IsEmpty(hMsgQueue->
-					  msgUsedList));
+				DBC_ASSERT(!LST_IS_EMPTY
+					   (msg_queue_obj->msg_used_list));
 				/* Get msg from used list */
-				pMsgFrame = (struct MSG_FRAME *)
-					   LST_GetHead(hMsgQueue->msgUsedList);
-				/* Copy message into pMsg and put frame on the
+				msg_frame_obj = (struct msg_frame *)
+				    lst_get_head(msg_queue_obj->msg_used_list);
+				/* Copy message into pmsg and put frame on the
 				 * free list */
-				if (pMsgFrame != NULL) {
-					*pMsg = pMsgFrame->msgData.msg;
-					LST_PutTail(hMsgQueue->msgFreeList,
-					(struct LST_ELEM *)pMsgFrame);
+				if (msg_frame_obj != NULL) {
+					*pmsg = msg_frame_obj->msg_data.msg;
+					lst_put_tail
+					    (msg_queue_obj->msg_free_list,
+					     (struct list_head *)
+					     msg_frame_obj);
 				}
 			}
-			hMsgQueue->refCount--;
+			msg_queue_obj->io_msg_pend--;
 			/* Reset the event if there are still queued messages */
-			if (!LST_IsEmpty(hMsgQueue->msgUsedList))
-				SYNC_SetEvent(hMsgQueue->hSyncEvent);
+			if (!LST_IS_EMPTY(msg_queue_obj->msg_used_list))
+				sync_set_event(msg_queue_obj->sync_event);
 
 			/* Exit critical section */
-			(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+			(void)sync_leave_cs(hmsg_mgr->sync_cs);
 		}
 	}
 func_end:
@@ -358,107 +362,112 @@
 }
 
 /*
- *  ======== WMD_MSG_Put ========
- *      Put a message onto a MSG queue.
+ *  ======== bridge_msg_put ========
+ *      Put a message onto a msg_ctrl queue.
  */
-DSP_STATUS WMD_MSG_Put(struct MSG_QUEUE *hMsgQueue,
-		      IN CONST struct DSP_MSG *pMsg, u32 uTimeout)
+dsp_status bridge_msg_put(struct msg_queue *msg_queue_obj,
+			  IN CONST struct dsp_msg *pmsg, u32 utimeout)
 {
-	struct MSG_FRAME *pMsgFrame;
-	struct MSG_MGR *hMsgMgr;
-	bool fPutMsg = false;
-	struct SYNC_OBJECT *hSyncs[2];
-	u32 uIndex;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE));
-	DBC_Require(pMsg != NULL);
-
-	hMsgMgr = hMsgQueue->hMsgMgr;
-
-       if (!hMsgMgr->msgFreeList) {
-               status = DSP_EHANDLE;
-               goto func_end;
-       }
+	struct msg_frame *msg_frame_obj;
+	struct msg_mgr *hmsg_mgr;
+	bool put_msg = false;
+	struct sync_object *syncs[2];
+	u32 index;
+	dsp_status status = DSP_SOK;
 
+	if (!MEM_IS_VALID_HANDLE(msg_queue_obj, MSGQ_SIGNATURE) || !pmsg ||
+	    !msg_queue_obj->hmsg_mgr) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+	hmsg_mgr = msg_queue_obj->hmsg_mgr;
+	if (!hmsg_mgr->msg_free_list) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 
-	(void) SYNC_EnterCS(hMsgMgr->hSyncCS);
+	(void)sync_enter_cs(hmsg_mgr->sync_cs);
 
 	/* If a message frame is available, use it */
-	if (!LST_IsEmpty(hMsgMgr->msgFreeList)) {
-		pMsgFrame = (struct MSG_FRAME *)LST_GetHead(hMsgMgr->
-			    msgFreeList);
-		if (pMsgFrame != NULL) {
-			pMsgFrame->msgData.msg = *pMsg;
-			pMsgFrame->msgData.dwId = hMsgQueue->dwId;
-			LST_PutTail(hMsgMgr->msgUsedList, (struct LST_ELEM *)
-				   pMsgFrame);
-			hMsgMgr->uMsgsPending++;
-			fPutMsg = true;
+	if (!LST_IS_EMPTY(hmsg_mgr->msg_free_list)) {
+		msg_frame_obj =
+		    (struct msg_frame *)lst_get_head(hmsg_mgr->msg_free_list);
+		if (msg_frame_obj != NULL) {
+			msg_frame_obj->msg_data.msg = *pmsg;
+			msg_frame_obj->msg_data.msgq_id =
+			    msg_queue_obj->msgq_id;
+			lst_put_tail(hmsg_mgr->msg_used_list,
+				     (struct list_head *)msg_frame_obj);
+			hmsg_mgr->msgs_pending++;
+			put_msg = true;
 		}
-		if (LST_IsEmpty(hMsgMgr->msgFreeList))
-			SYNC_ResetEvent(hMsgMgr->hSyncEvent);
+		if (LST_IS_EMPTY(hmsg_mgr->msg_free_list))
+			sync_reset_event(hmsg_mgr->sync_event);
 
 		/* Release critical section before scheduling DPC */
-		(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+		(void)sync_leave_cs(hmsg_mgr->sync_cs);
 		/* Schedule a DPC, to do the actual data transfer: */
-		IO_Schedule(hMsgMgr->hIOMgr);
+		iosm_schedule(hmsg_mgr->hio_mgr);
 	} else {
-		if (hMsgQueue->fDone)
+		if (msg_queue_obj->done)
 			status = DSP_EFAIL;
 		else
-			hMsgQueue->refCount++;
+			msg_queue_obj->io_msg_pend++;
 
-		(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+		(void)sync_leave_cs(hmsg_mgr->sync_cs);
 	}
-	if (DSP_SUCCEEDED(status) && !fPutMsg) {
+	if (DSP_SUCCEEDED(status) && !put_msg) {
 		/* Wait til a free message frame is available, timeout,
 		 * or done */
-		hSyncs[0] = hMsgMgr->hSyncEvent;
-		hSyncs[1] = hMsgQueue->hSyncDone;
-		status = SYNC_WaitOnMultipleEvents(hSyncs, 2, uTimeout,
-			 &uIndex);
+		syncs[0] = hmsg_mgr->sync_event;
+		syncs[1] = msg_queue_obj->sync_done;
+		status = sync_wait_on_multiple_events(syncs, 2, utimeout,
+						      &index);
+		if (DSP_FAILED(status))
+			goto func_end;
 		/* Enter critical section */
-		(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
-		if (hMsgQueue->fDone) {
-			hMsgQueue->refCount--;
+		(void)sync_enter_cs(hmsg_mgr->sync_cs);
+		if (msg_queue_obj->done) {
+			msg_queue_obj->io_msg_pend--;
 			/* Exit critical section */
-			(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
-			 /*  Signal that we're not going to access hMsgQueue
-			  *  anymore, so it can be deleted.  */
-			(void)SYNC_SetEvent(hMsgQueue->hSyncDoneAck);
+			(void)sync_leave_cs(hmsg_mgr->sync_cs);
+			/*  Signal that we're not going to access msg_queue_obj
+			 *  anymore, so it can be deleted. */
+			(void)sync_set_event(msg_queue_obj->sync_done_ack);
 			status = DSP_EFAIL;
 		} else {
-			if (DSP_SUCCEEDED(status)) {
-                               if (LST_IsEmpty(hMsgMgr->msgFreeList)) {
-                                       status = DSP_EPOINTER;
-                                       goto func_cont;
-                               }
-				/* Get msg from free list */
-				pMsgFrame = (struct MSG_FRAME *)
-					    LST_GetHead(hMsgMgr->msgFreeList);
-				/* Copy message into pMsg and put frame on the
-				 * used list */
-				if (pMsgFrame != NULL) {
-					pMsgFrame->msgData.msg = *pMsg;
-					pMsgFrame->msgData.dwId =
-						hMsgQueue->dwId;
-					LST_PutTail(hMsgMgr->msgUsedList,
-						   (struct LST_ELEM *)
-						   pMsgFrame);
-					hMsgMgr->uMsgsPending++;
-					/* Schedule a DPC, to do the actual
-					 * data transfer: */
-					IO_Schedule(hMsgMgr->hIOMgr);
-				}
+			if (LST_IS_EMPTY(hmsg_mgr->msg_free_list)) {
+				status = DSP_EPOINTER;
+				goto func_cont;
+			}
+			/* Get msg from free list */
+			msg_frame_obj = (struct msg_frame *)
+			    lst_get_head(hmsg_mgr->msg_free_list);
+			/*
+			 * Copy message into pmsg and put frame on the
+			 * used list.
+			 */
+			if (msg_frame_obj) {
+				msg_frame_obj->msg_data.msg = *pmsg;
+				msg_frame_obj->msg_data.msgq_id =
+				    msg_queue_obj->msgq_id;
+				lst_put_tail(hmsg_mgr->msg_used_list,
+					     (struct list_head *)msg_frame_obj);
+				hmsg_mgr->msgs_pending++;
+				/*
+				 * Schedule a DPC, to do the actual
+				 * data transfer.
+				 */
+				iosm_schedule(hmsg_mgr->hio_mgr);
 			}
-			hMsgQueue->refCount--;
+
+			msg_queue_obj->io_msg_pend--;
 			/* Reset event if there are still frames available */
-			if (!LST_IsEmpty(hMsgMgr->msgFreeList))
-				SYNC_SetEvent(hMsgMgr->hSyncEvent);
+			if (!LST_IS_EMPTY(hmsg_mgr->msg_free_list))
+				sync_set_event(hmsg_mgr->sync_event);
 func_cont:
 			/* Exit critical section */
-			(void) SYNC_LeaveCS(hMsgMgr->hSyncCS);
+			(void)sync_leave_cs(hmsg_mgr->sync_cs);
 		}
 	}
 func_end:
@@ -466,64 +475,74 @@
 }
 
 /*
- *  ======== WMD_MSG_RegisterNotify ========
+ *  ======== bridge_msg_register_notify ========
  */
-DSP_STATUS WMD_MSG_RegisterNotify(struct MSG_QUEUE *hMsgQueue, u32 uEventMask,
-				  u32 uNotifyType,
-				  struct DSP_NOTIFICATION *hNotification)
+dsp_status bridge_msg_register_notify(struct msg_queue *msg_queue_obj,
+				   u32 event_mask, u32 notify_type,
+				   struct dsp_notification *hnotification)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
+
+	if (!MEM_IS_VALID_HANDLE(msg_queue_obj, MSGQ_SIGNATURE)
+	    || !hnotification) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+
+	if (!(event_mask == DSP_NODEMESSAGEREADY || event_mask == 0)) {
+		status = DSP_ENODETYPE;
+		goto func_end;
+	}
 
-	DBC_Require(MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE));
-	DBC_Require(hNotification != NULL);
-	DBC_Require(uEventMask == DSP_NODEMESSAGEREADY || uEventMask == 0);
-	DBC_Require(uNotifyType == DSP_SIGNALEVENT);
+	if (notify_type != DSP_SIGNALEVENT) {
+		status = DSP_EWRONGSTATE;
+		goto func_end;
+	}
 
-	status = NTFY_Register(hMsgQueue->hNtfy, hNotification, uEventMask,
-			      uNotifyType);
+	status =
+	    ntfy_register(msg_queue_obj->ntfy_obj, hnotification, event_mask,
+			  notify_type);
 
 	if (status == DSP_EVALUE) {
 		/*  Not registered. Ok, since we couldn't have known. Node
 		 *  notifications are split between node state change handled
-		 *  by NODE, and message ready handled by MSG.  */
+		 *  by NODE, and message ready handled by msg_ctrl. */
 		status = DSP_SOK;
 	}
-
+func_end:
 	return status;
 }
 
 /*
- *  ======== WMD_MSG_SetQueueId ========
+ *  ======== bridge_msg_set_queue_id ========
  */
-void WMD_MSG_SetQueueId(struct MSG_QUEUE *hMsgQueue, u32 dwId)
+void bridge_msg_set_queue_id(struct msg_queue *msg_queue_obj, u32 msgq_id)
 {
-	DBC_Require(MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE));
-	/* DBC_Require(dwId != 0); */
-
 	/*
 	 *  A message queue must be created when a node is allocated,
-	 *  so that NODE_RegisterNotify() can be called before the node
+	 *  so that node_register_notify() can be called before the node
 	 *  is created. Since we don't know the node environment until the
-	 *  node is created, we need this function to set hMsgQueue->dwId
+	 *  node is created, we need this function to set msg_queue_obj->msgq_id
 	 *  to the node environment, after the node is created.
 	 */
-	hMsgQueue->dwId = dwId;
+	if (MEM_IS_VALID_HANDLE(msg_queue_obj, MSGQ_SIGNATURE))
+		msg_queue_obj->msgq_id = msgq_id;
 }
 
 /*
- *  ======== AddNewMsg ========
+ *  ======== add_new_msg ========
  *      Must be called in message manager critical section.
  */
-static DSP_STATUS AddNewMsg(struct LST_LIST *msgList)
+static dsp_status add_new_msg(struct lst_list *msgList)
 {
-	struct MSG_FRAME *pMsg;
-	DSP_STATUS status = DSP_SOK;
+	struct msg_frame *pmsg;
+	dsp_status status = DSP_SOK;
 
-	pMsg = (struct MSG_FRAME *)MEM_Calloc(sizeof(struct MSG_FRAME),
-		MEM_PAGED);
-	if (pMsg != NULL) {
-		LST_InitElem((struct LST_ELEM *) pMsg);
-		LST_PutTail(msgList, (struct LST_ELEM *) pMsg);
+	pmsg = (struct msg_frame *)mem_calloc(sizeof(struct msg_frame),
+					      MEM_PAGED);
+	if (pmsg != NULL) {
+		lst_init_elem((struct list_head *)pmsg);
+		lst_put_tail(msgList, (struct list_head *)pmsg);
 	} else {
 		status = DSP_EMEMORY;
 	}
@@ -532,112 +551,113 @@
 }
 
 /*
- *  ======== DeleteMsgMgr ========
+ *  ======== delete_msg_mgr ========
  */
-static void DeleteMsgMgr(struct MSG_MGR *hMsgMgr)
+static void delete_msg_mgr(struct msg_mgr *hmsg_mgr)
 {
-	DBC_Require(MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE));
+	if (!MEM_IS_VALID_HANDLE(hmsg_mgr, MSGMGR_SIGNATURE))
+		goto func_end;
 
-	if (hMsgMgr->queueList) {
-               if (LST_IsEmpty(hMsgMgr->queueList)) {
-                       LST_Delete(hMsgMgr->queueList);
-                       hMsgMgr->queueList = NULL;
-               }
+	if (hmsg_mgr->queue_list) {
+		if (LST_IS_EMPTY(hmsg_mgr->queue_list)) {
+			kfree(hmsg_mgr->queue_list);
+			hmsg_mgr->queue_list = NULL;
+		}
 	}
 
-       if (hMsgMgr->msgFreeList) {
-		FreeMsgList(hMsgMgr->msgFreeList);
-               hMsgMgr->msgFreeList = NULL;
-       }
+	if (hmsg_mgr->msg_free_list) {
+		free_msg_list(hmsg_mgr->msg_free_list);
+		hmsg_mgr->msg_free_list = NULL;
+	}
 
-       if (hMsgMgr->msgUsedList) {
-		FreeMsgList(hMsgMgr->msgUsedList);
-               hMsgMgr->msgUsedList = NULL;
-       }
+	if (hmsg_mgr->msg_used_list) {
+		free_msg_list(hmsg_mgr->msg_used_list);
+		hmsg_mgr->msg_used_list = NULL;
+	}
 
-	if (hMsgMgr->hSyncEvent)
-		SYNC_CloseEvent(hMsgMgr->hSyncEvent);
+	if (hmsg_mgr->sync_event)
+		sync_close_event(hmsg_mgr->sync_event);
 
-	if (hMsgMgr->hSyncCS)
-		SYNC_DeleteCS(hMsgMgr->hSyncCS);
+	if (hmsg_mgr->sync_cs)
+		sync_delete_cs(hmsg_mgr->sync_cs);
 
-	MEM_FreeObject(hMsgMgr);
+	MEM_FREE_OBJECT(hmsg_mgr);
+func_end:
+	return;
 }
 
 /*
- *  ======== DeleteMsgQueue ========
+ *  ======== delete_msg_queue ========
  */
-static void DeleteMsgQueue(struct MSG_QUEUE *hMsgQueue, u32 uNumToDSP)
+static void delete_msg_queue(struct msg_queue *msg_queue_obj, u32 uNumToDSP)
 {
-       struct MSG_MGR *hMsgMgr;
-	struct MSG_FRAME *pMsg;
+	struct msg_mgr *hmsg_mgr;
+	struct msg_frame *pmsg;
 	u32 i;
 
-       if (!MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE)
-               || !hMsgQueue->hMsgMgr || !hMsgQueue->hMsgMgr->msgFreeList)
-               goto func_end;
-       hMsgMgr = hMsgQueue->hMsgMgr;
+	if (!MEM_IS_VALID_HANDLE(msg_queue_obj, MSGQ_SIGNATURE) ||
+	    !msg_queue_obj->hmsg_mgr || !msg_queue_obj->hmsg_mgr->msg_free_list)
+		goto func_end;
 
+	hmsg_mgr = msg_queue_obj->hmsg_mgr;
 
 	/* Pull off uNumToDSP message frames from Msg manager and free */
 	for (i = 0; i < uNumToDSP; i++) {
 
-		if (!LST_IsEmpty(hMsgMgr->msgFreeList)) {
-			pMsg = (struct MSG_FRAME *)LST_GetHead(hMsgMgr->
-				msgFreeList);
-			MEM_Free(pMsg);
+		if (!LST_IS_EMPTY(hmsg_mgr->msg_free_list)) {
+			pmsg = (struct msg_frame *)
+			    lst_get_head(hmsg_mgr->msg_free_list);
+			kfree(pmsg);
 		} else {
 			/* Cannot free all of the message frames */
 			break;
 		}
 	}
 
-       if (hMsgQueue->msgFreeList) {
-		FreeMsgList(hMsgQueue->msgFreeList);
-               hMsgQueue->msgFreeList = NULL;
-       }
-
-       if (hMsgQueue->msgUsedList) {
-		FreeMsgList(hMsgQueue->msgUsedList);
-               hMsgQueue->msgUsedList = NULL;
-       }
+	if (msg_queue_obj->msg_free_list) {
+		free_msg_list(msg_queue_obj->msg_free_list);
+		msg_queue_obj->msg_free_list = NULL;
+	}
 
+	if (msg_queue_obj->msg_used_list) {
+		free_msg_list(msg_queue_obj->msg_used_list);
+		msg_queue_obj->msg_used_list = NULL;
+	}
 
-	if (hMsgQueue->hNtfy)
-		NTFY_Delete(hMsgQueue->hNtfy);
+	if (msg_queue_obj->ntfy_obj)
+		ntfy_delete(msg_queue_obj->ntfy_obj);
 
-	if (hMsgQueue->hSyncEvent)
-		SYNC_CloseEvent(hMsgQueue->hSyncEvent);
+	if (msg_queue_obj->sync_event)
+		sync_close_event(msg_queue_obj->sync_event);
 
-	if (hMsgQueue->hSyncDone)
-		SYNC_CloseEvent(hMsgQueue->hSyncDone);
+	if (msg_queue_obj->sync_done)
+		sync_close_event(msg_queue_obj->sync_done);
 
-	if (hMsgQueue->hSyncDoneAck)
-		SYNC_CloseEvent(hMsgQueue->hSyncDoneAck);
+	if (msg_queue_obj->sync_done_ack)
+		sync_close_event(msg_queue_obj->sync_done_ack);
 
-	MEM_FreeObject(hMsgQueue);
+	MEM_FREE_OBJECT(msg_queue_obj);
 func_end:
-       return;
+	return;
 
 }
 
 /*
- *  ======== FreeMsgList ========
+ *  ======== free_msg_list ========
  */
-static void FreeMsgList(struct LST_LIST *msgList)
+static void free_msg_list(struct lst_list *msgList)
 {
-	struct MSG_FRAME *pMsg;
+	struct msg_frame *pmsg;
 
-       if (!msgList)
-               goto func_end;
+	if (!msgList)
+		goto func_end;
 
-	while ((pMsg = (struct MSG_FRAME *)LST_GetHead(msgList)) != NULL)
-		MEM_Free(pMsg);
+	while ((pmsg = (struct msg_frame *)lst_get_head(msgList)) != NULL)
+		kfree(pmsg);
 
-	DBC_Assert(LST_IsEmpty(msgList));
+	DBC_ASSERT(LST_IS_EMPTY(msgList));
 
-	LST_Delete(msgList);
+	kfree(msgList);
 func_end:
-       return;
+	return;
 }
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/_msg_sm.h kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/_msg_sm.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/_msg_sm.h	2011-10-11 13:51:02.269540523 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/_msg_sm.h	2011-10-23 08:22:37.688551000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Private header file defining msg_ctrl manager objects and defines needed
+ * by IO manager.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,24 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _msg_sm.h ========
- *  Description:
- *      Private header file defining MSG manager objects and defines needed
- *      by IO manager.
- *
- *  Public Functions:
- *      None.
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 09-May-2001 jeh     Code Review cleanup.
- *! 08-Nov-2000 jeh     Created.
- */
-
 #ifndef _MSG_SM_
 #define _MSG_SM_
 
@@ -51,7 +36,7 @@
 #endif
 
 /*
- *  ======== MSG ========
+ *  ======== msg_ctrl ========
  *  There is a control structure for messages to the DSP, and a control
  *  structure for messages from the DSP. The shared memory region for
  *  transferring messages is partitioned as follows:
@@ -60,99 +45,98 @@
  *  |Control | Messages from DSP | Control | Messages to DSP |
  *  ----------------------------------------------------------
  *
- *  MSG control structure for messages to the DSP is used in the following
+ *  msg_ctrl control structure for messages to the DSP is used in the following
  *  way:
  *
- *  bufEmpty -      This flag is set to FALSE by the GPP after it has output
+ *  buf_empty -      This flag is set to FALSE by the GPP after it has output
  *                  messages for the DSP. The DSP host driver sets it to
  *                  TRUE after it has copied the messages.
- *  postSWI -       Set to 1 by the GPP after it has written the messages,
- *                  set the size, and set bufEmpty to FALSE.
- *                  The DSP Host driver uses SWI_andn of the postSWI field
+ *  post_swi -       Set to 1 by the GPP after it has written the messages,
+ *                  set the size, and set buf_empty to FALSE.
+ *                  The DSP Host driver uses SWI_andn of the post_swi field
  *                  when a host interrupt occurs. The host driver clears
  *                  this after posting the SWI.
  *  size -          Number of messages to be read by the DSP.
  *
  *  For messages from the DSP:
- *  bufEmpty -      This flag is set to FALSE by the DSP after it has output
+ *  buf_empty -      This flag is set to FALSE by the DSP after it has output
  *                  messages for the GPP. The DPC on the GPP sets it to
  *                  TRUE after it has copied the messages.
- *  postSWI -       Set to 1 the DPC on the GPP after copying the messages.
+ *  post_swi -       Set to 1 the DPC on the GPP after copying the messages.
  *  size -          Number of messages to be read by the GPP.
  */
-struct MSG {
-	u32 bufEmpty;	/* to/from DSP buffer is empty */
-	u32 postSWI;	/* Set to "1" to post MSG SWI */
-	u32 size;	/* Number of messages to/from the DSP */
+struct msg_ctrl {
+	u32 buf_empty;		/* to/from DSP buffer is empty */
+	u32 post_swi;		/* Set to "1" to post msg_ctrl SWI */
+	u32 size;		/* Number of messages to/from the DSP */
 	u32 resvd;
-} ;
+};
 
 /*
- *  ======== MSG_MGR ========
- *  The MSG_MGR maintains a list of all MSG_QUEUEs. Each NODE object can
- *  have MSG_QUEUE to hold all messages that come up from the corresponding
- *  node on the DSP. The MSG_MGR also has a shared queue of messages
+ *  ======== msg_mgr ========
+ *  The msg_mgr maintains a list of all MSG_QUEUEs. Each NODE object can
+ *  have msg_queue to hold all messages that come up from the corresponding
+ *  node on the DSP. The msg_mgr also has a shared queue of messages
  *  ready to go to the DSP.
  */
-struct MSG_MGR {
+struct msg_mgr {
 	/* The first two fields must match those in msgobj.h */
-	u32 dwSignature;
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD. */
+	u32 dw_signature;
+	struct bridge_drv_interface *intf_fxns;	/* Function interface to WMD. */
 
-	struct IO_MGR *hIOMgr;	/* IO manager */
-	struct LST_LIST *queueList;	/* List of MSG_QUEUEs */
-	struct SYNC_CSOBJECT *hSyncCS;	/* For critical sections */
+	struct io_mgr *hio_mgr;	/* IO manager */
+	struct lst_list *queue_list;	/* List of MSG_QUEUEs */
+	struct sync_csobject *sync_cs;	/* For critical sections */
 	/* Signalled when MsgFrame is available */
-	struct SYNC_OBJECT *hSyncEvent;
-	struct LST_LIST *msgFreeList;	/* Free MsgFrames ready to be filled */
-	struct LST_LIST *msgUsedList;	/* MsgFrames ready to go to DSP */
-	u32 uMsgsPending;	/* # of queued messages to go to DSP */
-	u32 uMaxMsgs;	/* Max # of msgs that fit in buffer */
-	MSG_ONEXIT onExit;	/* called when RMS_EXIT is received */
-} ;
+	struct sync_object *sync_event;
+	struct lst_list *msg_free_list;	/* Free MsgFrames ready to be filled */
+	struct lst_list *msg_used_list;	/* MsgFrames ready to go to DSP */
+	u32 msgs_pending;	/* # of queued messages to go to DSP */
+	u32 max_msgs;		/* Max # of msgs that fit in buffer */
+	msg_onexit on_exit;	/* called when RMS_EXIT is received */
+};
 
 /*
- *  ======== MSG_QUEUE ========
- *  Each NODE has a MSG_QUEUE for receiving messages from the
- *  corresponding node on the DSP. The MSG_QUEUE object maintains a list
+ *  ======== msg_queue ========
+ *  Each NODE has a msg_queue for receiving messages from the
+ *  corresponding node on the DSP. The msg_queue object maintains a list
  *  of messages that have been sent to the host, but not yet read (MSG_Get),
  *  and a list of free frames that can be filled when new messages arrive
  *  from the DSP.
- *  The MSG_QUEUE's hSynEvent gets posted when a message is ready.
+ *  The msg_queue's hSynEvent gets posted when a message is ready.
  */
-struct MSG_QUEUE {
-	struct LST_ELEM listElem;
-	u32 dwSignature;
-	struct MSG_MGR *hMsgMgr;
-	u32 uMaxMsgs;	/* Node message depth */
-	u32 dwId;	/* Node environment pointer */
-	struct LST_LIST *msgFreeList;	/* Free MsgFrames ready to be filled */
+struct msg_queue {
+	struct list_head list_elem;
+	u32 dw_signature;
+	struct msg_mgr *hmsg_mgr;
+	u32 max_msgs;		/* Node message depth */
+	u32 msgq_id;		/* Node environment pointer */
+	struct lst_list *msg_free_list;	/* Free MsgFrames ready to be filled */
 	/* Filled MsgFramess waiting to be read */
-	struct LST_LIST *msgUsedList;
-	HANDLE hArg;	/* Handle passed to mgr onExit callback */
-	struct SYNC_OBJECT *hSyncEvent;	/* Signalled when message is ready */
-	struct SYNC_OBJECT *hSyncDone;	/* For synchronizing cleanup */
-	struct SYNC_OBJECT *hSyncDoneAck;	/* For synchronizing cleanup */
-	struct NTFY_OBJECT *hNtfy;	/* For notification of message ready */
-	bool fDone;	/* TRUE <==> deleting the object */
-	u32 refCount;	/* Number of pending MSG_get/put calls */
+	struct lst_list *msg_used_list;
+	bhandle arg;		/* Handle passed to mgr on_exit callback */
+	struct sync_object *sync_event;	/* Signalled when message is ready */
+	struct sync_object *sync_done;	/* For synchronizing cleanup */
+	struct sync_object *sync_done_ack;	/* For synchronizing cleanup */
+	struct ntfy_object *ntfy_obj;	/* For notification of message ready */
+	bool done;		/* TRUE <==> deleting the object */
+	u32 io_msg_pend;	/* Number of pending MSG_get/put calls */
 };
 
 /*
- *  ======== MSG_DSPMSG ========
+ *  ======== msg_dspmsg ========
  */
-struct MSG_DSPMSG {
-	struct DSP_MSG msg;
-	u32 dwId;	/* Identifies the node the message goes to */
-} ;
+struct msg_dspmsg {
+	struct dsp_msg msg;
+	u32 msgq_id;		/* Identifies the node the message goes to */
+};
 
 /*
- *  ======== MSG_FRAME ========
+ *  ======== msg_frame ========
  */
-struct MSG_FRAME {
-	struct LST_ELEM listElem;
-	struct MSG_DSPMSG msgData;
-} ;
-
-#endif				/* _MSG_SM_ */
+struct msg_frame {
+	struct list_head list_elem;
+	struct msg_dspmsg msg_data;
+};
 
+#endif /* _MSG_SM_ */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/tiomap3430.c kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/tiomap3430.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/tiomap3430.c	2011-10-11 13:51:02.419241949 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/tiomap3430.c	2011-10-29 20:32:42.037395000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Processor Manager Driver for TI OMAP3430 EVM.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,18 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== tiomap.c ========
- *  Processor Manager Driver for TI OMAP3430 EVM.
- *
- *  Public Function:
- *      WMD_DRV_Entry
- *
- *! Revision History:
- *! ================
- *   26-March-2008 HK and AL:  Added WMD_DEV_WalkTbl funciton.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 #include <linux/mm.h>
@@ -43,16 +33,12 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/dbg.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/mem.h>
-#include <dspbridge/util.h>
 #include <dspbridge/reg.h>
-#include <dspbridge/dbreg.h>
 #include <dspbridge/cfg.h>
 #include <dspbridge/drv.h>
-#include <dspbridge/csl.h>
 #include <dspbridge/sync.h>
 
 /* ------------------------------------ Hardware Abstraction Layer */
@@ -60,7 +46,6 @@
 #include <hw_dspssC64P.h>
 #include <hw_prcm.h>
 #include <hw_mmu.h>
-#include <hw_mbox.h>
 
 /*  ----------------------------------- Link Driver */
 #include <dspbridge/wmd.h>
@@ -69,13 +54,13 @@
 #include <dspbridge/wmdio.h>
 #include <dspbridge/wmdmsg.h>
 #include <dspbridge/pwr.h>
-#include <dspbridge/chnl_sm.h>
 #include <dspbridge/io_sm.h>
 
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/dev.h>
 #include <dspbridge/wcd.h>
 #include <dspbridge/dmm.h>
+#include <dspbridge/wdt.h>
 
 /*  ----------------------------------- Local */
 #include "_tiomap.h"
@@ -84,7 +69,6 @@
 #include "_tiomap_util.h"
 #include "tiomap_io.h"
 
-
 /* Offset in shared mem to write to in order to synchronize start with DSP */
 #define SHMSYNCOFFSET 4		/* GPP byte offset */
 
@@ -95,82 +79,83 @@
 #define MMU_LARGE_PAGE_MASK      0xFFFF0000
 #define MMU_SMALL_PAGE_MASK      0xFFFFF000
 #define PAGES_II_LVL_TABLE   512
-#define phys_to_page(phys)      pfn_to_page((phys) >> PAGE_SHIFT)
+#define PHYS_TO_PAGE(phys)      pfn_to_page((phys) >> PAGE_SHIFT)
 
 #define MMU_GFLUSH 0x60
 
-extern unsigned short min_active_opp;
-
 /* Forward Declarations: */
-static DSP_STATUS WMD_BRD_Monitor(struct WMD_DEV_CONTEXT *pDevContext);
-static DSP_STATUS WMD_BRD_Read(struct WMD_DEV_CONTEXT *pDevContext,
-			OUT u8 *pbHostBuf,
-			u32 dwDSPAddr, u32 ulNumBytes, u32 ulMemType);
-static DSP_STATUS WMD_BRD_Start(struct WMD_DEV_CONTEXT *pDevContext,
-			u32 dwDSPAddr);
-static DSP_STATUS WMD_BRD_Status(struct WMD_DEV_CONTEXT *pDevContext,
-			OUT BRD_STATUS *pdwState);
-static DSP_STATUS WMD_BRD_Stop(struct WMD_DEV_CONTEXT *pDevContext);
-static DSP_STATUS WMD_BRD_Write(struct WMD_DEV_CONTEXT *pDevContext,
-			IN u8 *pbHostBuf,
-			u32 dwDSPAddr, u32 ulNumBytes, u32 ulMemType);
-static DSP_STATUS WMD_BRD_SetState(struct WMD_DEV_CONTEXT *hDevContext,
-			u32 ulBrdState);
-static DSP_STATUS WMD_BRD_MemCopy(struct WMD_DEV_CONTEXT *hDevContext,
-			u32 ulDspDestAddr, u32 ulDspSrcAddr,
-			u32 ulNumBytes, u32 ulMemType);
-static DSP_STATUS WMD_BRD_MemWrite(struct WMD_DEV_CONTEXT *pDevContext,
-			IN u8 *pbHostBuf, u32 dwDSPAddr,
-			u32 ulNumBytes, u32 ulMemType);
-static DSP_STATUS WMD_BRD_MemMap(struct WMD_DEV_CONTEXT *hDevContext,
-			u32 ulMpuAddr, u32 ulVirtAddr, u32 ulNumBytes,
-			u32 ulMapAttr);
-static DSP_STATUS WMD_BRD_MemUnMap(struct WMD_DEV_CONTEXT *hDevContext,
-			u32 ulVirtAddr, u32 ulNumBytes);
-static DSP_STATUS WMD_DEV_Create(OUT struct WMD_DEV_CONTEXT **ppDevContext,
-			struct DEV_OBJECT *hDevObject,
-			IN CONST struct CFG_HOSTRES *pConfig,
-			IN CONST struct CFG_DSPRES *pDspConfig);
-static DSP_STATUS WMD_DEV_Ctrl(struct WMD_DEV_CONTEXT *pDevContext, u32 dwCmd,
-			IN OUT void *pArgs);
-static DSP_STATUS WMD_DEV_Destroy(struct WMD_DEV_CONTEXT *pDevContext);
-static u32 user_va2pa(struct mm_struct *mm, u32 address);
-static DSP_STATUS PteUpdate(struct WMD_DEV_CONTEXT *hDevContext, u32 pa,
-			u32 va, u32 size,
-			struct HW_MMUMapAttrs_t *mapAttrs);
-static DSP_STATUS PteSet(struct PgTableAttrs *pt, u32 pa, u32 va,
-			u32 size, struct HW_MMUMapAttrs_t *attrs);
-static DSP_STATUS MemMapVmalloc(struct WMD_DEV_CONTEXT *hDevContext,
-			u32 ulMpuAddr, u32 ulVirtAddr,
-			u32 ulNumBytes, struct HW_MMUMapAttrs_t *hwAttrs);
+static dsp_status bridge_brd_monitor(struct wmd_dev_context *dev_context);
+static dsp_status bridge_brd_read(struct wmd_dev_context *dev_context,
+				  OUT u8 *pbHostBuf,
+				  u32 dwDSPAddr, u32 ul_num_bytes,
+				  u32 ulMemType);
+static dsp_status bridge_brd_start(struct wmd_dev_context *dev_context,
+				   u32 dwDSPAddr);
+static dsp_status bridge_brd_status(struct wmd_dev_context *dev_context,
+				    int *pdwState);
+static dsp_status bridge_brd_stop(struct wmd_dev_context *dev_context);
+static dsp_status bridge_brd_write(struct wmd_dev_context *dev_context,
+				   IN u8 *pbHostBuf,
+				   u32 dwDSPAddr, u32 ul_num_bytes,
+				   u32 ulMemType);
+static dsp_status bridge_brd_set_state(struct wmd_dev_context *hDevContext,
+				    u32 ulBrdState);
+static dsp_status bridge_brd_mem_copy(struct wmd_dev_context *hDevContext,
+				   u32 ulDspDestAddr, u32 ulDspSrcAddr,
+				   u32 ul_num_bytes, u32 ulMemType);
+static dsp_status bridge_brd_mem_write(struct wmd_dev_context *dev_context,
+				    IN u8 *pbHostBuf, u32 dwDSPAddr,
+				    u32 ul_num_bytes, u32 ulMemType);
+static dsp_status bridge_brd_mem_map(struct wmd_dev_context *hDevContext,
+				  u32 ul_mpu_addr, u32 ulVirtAddr,
+				  u32 ul_num_bytes, u32 ul_map_attr);
+static dsp_status bridge_brd_mem_un_map(struct wmd_dev_context *hDevContext,
+				     u32 ulVirtAddr, u32 ul_num_bytes);
+static dsp_status bridge_dev_create(OUT struct wmd_dev_context **ppDevContext,
+				    struct dev_object *hdev_obj,
+				    IN CONST struct cfg_hostres *pConfig,
+				    IN CONST struct cfg_dspres *pDspConfig);
+static dsp_status bridge_dev_ctrl(struct wmd_dev_context *dev_context,
+				  u32 dw_cmd, IN OUT void *pargs);
+static dsp_status bridge_dev_destroy(struct wmd_dev_context *dev_context);
+static u32 user_va2_pa(struct mm_struct *mm, u32 address);
+static dsp_status pte_update(struct wmd_dev_context *hDevContext, u32 pa,
+			     u32 va, u32 size,
+			     struct hw_mmu_map_attrs_t *map_attrs);
+static dsp_status pte_set(struct pg_table_attrs *pt, u32 pa, u32 va,
+			  u32 size, struct hw_mmu_map_attrs_t *attrs);
+static dsp_status mem_map_vmalloc(struct wmd_dev_context *hDevContext,
+				  u32 ul_mpu_addr, u32 ulVirtAddr,
+				  u32 ul_num_bytes,
+				  struct hw_mmu_map_attrs_t *hw_attrs);
 
 #ifdef CONFIG_BRIDGE_DEBUG
-static void GetHWRegs(void __iomem *prm_base, void __iomem *cm_base)
+static void get_hw_regs(void __iomem *prm_base, void __iomem *cm_base)
 {
 	u32 temp;
 	temp = __raw_readl((cm_base) + 0x00);
-	DBG_Trace(DBG_LEVEL6, "CM_FCLKEN_IVA2 = 0x%x \n", temp);
+	dev_dbg(bridge, "CM_FCLKEN_IVA2 = 0x%x\n", temp);
 	temp = __raw_readl((cm_base) + 0x10);
-	DBG_Trace(DBG_LEVEL6, "CM_ICLKEN1_IVA2 = 0x%x \n", temp);
+	dev_dbg(bridge, "CM_ICLKEN1_IVA2 = 0x%x \n", temp);
 	temp = __raw_readl((cm_base) + 0x20);
-	DBG_Trace(DBG_LEVEL6, "CM_IDLEST_IVA2 = 0x%x \n", temp);
+	dev_dbg(bridge, "CM_IDLEST_IVA2 = 0x%x \n", temp);
 	temp = __raw_readl((cm_base) + 0x48);
-	DBG_Trace(DBG_LEVEL6, "CM_CLKSTCTRL_IVA2 = 0x%x \n", temp);
+	dev_dbg(bridge, "CM_CLKSTCTRL_IVA2 = 0x%x \n", temp);
 	temp = __raw_readl((cm_base) + 0x4c);
-	DBG_Trace(DBG_LEVEL6, "CM_CLKSTST_IVA2 = 0x%x \n", temp);
+	dev_dbg(bridge, "CM_CLKSTST_IVA2 = 0x%x \n", temp);
 	temp = __raw_readl((prm_base) + 0x50);
-	DBG_Trace(DBG_LEVEL6, "RM_RSTCTRL_IVA2 = 0x%x \n", temp);
+	dev_dbg(bridge, "RM_RSTCTRL_IVA2 = 0x%x \n", temp);
 	temp = __raw_readl((prm_base) + 0x58);
-	DBG_Trace(DBG_LEVEL6, "RM_RSTST_IVA2 = 0x%x \n", temp);
+	dev_dbg(bridge, "RM_RSTST_IVA2 = 0x%x \n", temp);
 	temp = __raw_readl((prm_base) + 0xE0);
-	DBG_Trace(DBG_LEVEL6, "PM_PWSTCTRL_IVA2 = 0x%x \n", temp);
+	dev_dbg(bridge, "PM_PWSTCTRL_IVA2 = 0x%x \n", temp);
 	temp = __raw_readl((prm_base) + 0xE4);
-	DBG_Trace(DBG_LEVEL6, "PM_PWSTST_IVA2 = 0x%x \n", temp);
+	dev_dbg(bridge, "PM_PWSTST_IVA2 = 0x%x \n", temp);
 	temp = __raw_readl((cm_base) + 0xA10);
-	DBG_Trace(DBG_LEVEL6, "CM_ICLKEN1_CORE = 0x%x \n", temp);
+	dev_dbg(bridge, "CM_ICLKEN1_CORE = 0x%x \n", temp);
 }
 #else
-static inline void GetHWRegs(void __iomem *prm_base, void __iomem *cm_base)
+static inline void get_hw_regs(void __iomem *prm_base, void __iomem *cm_base)
 {
 }
 #endif
@@ -178,39 +163,40 @@
 /*  ----------------------------------- Globals */
 
 /* Attributes of L2 page tables for DSP MMU */
-struct PageInfo {
-	u32 numEntries;	/* Number of valid PTEs in the L2 PT */
-} ;
+struct page_info {
+	u32 num_entries;	/* Number of valid PTEs in the L2 PT */
+};
 
 /* Attributes used to manage the DSP MMU page tables */
-struct PgTableAttrs {
-	struct SYNC_CSOBJECT *hCSObj;	/* Critical section object handle */
+struct pg_table_attrs {
+	struct sync_csobject *hcs_obj;	/* Critical section object handle */
 
-	u32 L1BasePa;		/* Physical address of the L1 PT */
-	u32 L1BaseVa;		/* Virtual  address of the L1 PT */
-	u32 L1size;		/* Size of the L1 PT */
-	u32 L1TblAllocPa;
+	u32 l1_base_pa;		/* Physical address of the L1 PT */
+	u32 l1_base_va;		/* Virtual  address of the L1 PT */
+	u32 l1_size;		/* Size of the L1 PT */
+	u32 l1_tbl_alloc_pa;
 	/* Physical address of Allocated mem for L1 table. May not be aligned */
-	u32 L1TblAllocVa;
+	u32 l1_tbl_alloc_va;
 	/* Virtual address of Allocated mem for L1 table. May not be aligned */
-	u32 L1TblAllocSz;
+	u32 l1_tbl_alloc_sz;
 	/* Size of consistent memory allocated for L1 table.
 	 * May not be aligned */
 
-	u32 L2BasePa;		/* Physical address of the L2 PT */
-	u32 L2BaseVa;		/* Virtual  address of the L2 PT */
-	u32 L2size;		/* Size of the L2 PT */
-	u32 L2TblAllocPa;
+	u32 l2_base_pa;		/* Physical address of the L2 PT */
+	u32 l2_base_va;		/* Virtual  address of the L2 PT */
+	u32 l2_size;		/* Size of the L2 PT */
+	u32 l2_tbl_alloc_pa;
 	/* Physical address of Allocated mem for L2 table. May not be aligned */
-	u32 L2TblAllocVa;
+	u32 l2_tbl_alloc_va;
 	/* Virtual address of Allocated mem for L2 table. May not be aligned */
-	u32 L2TblAllocSz;
+	u32 l2_tbl_alloc_sz;
 	/* Size of consistent memory allocated for L2 table.
 	 * May not be aligned */
 
-	u32 L2NumPages;	/* Number of allocated L2 PT */
-	struct PageInfo *pgInfo;  /* Array [L2NumPages] of L2 PT info structs */
-} ;
+	u32 l2_num_pages;	/* Number of allocated L2 PT */
+	/* Array [l2_num_pages] of L2 PT info structs */
+	struct page_info *pg_info;
+};
 
 /*
  *  If dsp_debug is true, do not branch to the DSP entry point and wait for DSP
@@ -221,56 +207,57 @@
 /*
  *  This mini driver's function interface table.
  */
-static struct WMD_DRV_INTERFACE drvInterfaceFxns = {
-	WCD_MAJOR_VERSION,  /* WCD ver. for which this mini driver is built. */
+static struct bridge_drv_interface drv_interface_fxns = {
+	/* WCD ver. for which this mini driver is built. */
+	WCD_MAJOR_VERSION,
 	WCD_MINOR_VERSION,
-	WMD_DEV_Create,
-	WMD_DEV_Destroy,
-	WMD_DEV_Ctrl,
-	WMD_BRD_Monitor,
-	WMD_BRD_Start,
-	WMD_BRD_Stop,
-	WMD_BRD_Status,
-	WMD_BRD_Read,
-	WMD_BRD_Write,
-	WMD_BRD_SetState,
-	WMD_BRD_MemCopy,
-	WMD_BRD_MemWrite,
-	WMD_BRD_MemMap,
-	WMD_BRD_MemUnMap,
+	bridge_dev_create,
+	bridge_dev_destroy,
+	bridge_dev_ctrl,
+	bridge_brd_monitor,
+	bridge_brd_start,
+	bridge_brd_stop,
+	bridge_brd_status,
+	bridge_brd_read,
+	bridge_brd_write,
+	bridge_brd_set_state,
+	bridge_brd_mem_copy,
+	bridge_brd_mem_write,
+	bridge_brd_mem_map,
+	bridge_brd_mem_un_map,
 	/* The following CHNL functions are provided by chnl_io.lib: */
-	WMD_CHNL_Create,
-	WMD_CHNL_Destroy,
-	WMD_CHNL_Open,
-	WMD_CHNL_Close,
-	WMD_CHNL_AddIOReq,
-	WMD_CHNL_GetIOC,
-	WMD_CHNL_CancelIO,
-	WMD_CHNL_FlushIO,
-	WMD_CHNL_GetInfo,
-	WMD_CHNL_GetMgrInfo,
-	WMD_CHNL_Idle,
-	WMD_CHNL_RegisterNotify,
+	bridge_chnl_create,
+	bridge_chnl_destroy,
+	bridge_chnl_open,
+	bridge_chnl_close,
+	bridge_chnl_add_io_req,
+	bridge_chnl_get_ioc,
+	bridge_chnl_cancel_io,
+	bridge_chnl_flush_io,
+	bridge_chnl_get_info,
+	bridge_chnl_get_mgr_info,
+	bridge_chnl_idle,
+	bridge_chnl_register_notify,
 	/* The following DEH functions are provided by tihelen_ue_deh.c */
-	WMD_DEH_Create,
-	WMD_DEH_Destroy,
-	WMD_DEH_Notify,
-	WMD_DEH_RegisterNotify,
-	WMD_DEH_GetInfo,
+	bridge_deh_create,
+	bridge_deh_destroy,
+	bridge_deh_notify,
+	bridge_deh_register_notify,
+	bridge_deh_get_info,
 	/* The following IO functions are provided by chnl_io.lib: */
-	WMD_IO_Create,
-	WMD_IO_Destroy,
-	WMD_IO_OnLoaded,
-	WMD_IO_GetProcLoad,
-	/* The following MSG functions are provided by chnl_io.lib: */
-	WMD_MSG_Create,
-	WMD_MSG_CreateQueue,
-	WMD_MSG_Delete,
-	WMD_MSG_DeleteQueue,
-	WMD_MSG_Get,
-	WMD_MSG_Put,
-	WMD_MSG_RegisterNotify,
-	WMD_MSG_SetQueueId,
+	bridge_io_create,
+	bridge_io_destroy,
+	bridge_io_on_loaded,
+	bridge_io_get_proc_load,
+	/* The following msg_ctrl functions are provided by chnl_io.lib: */
+	bridge_msg_create,
+	bridge_msg_create_queue,
+	bridge_msg_delete,
+	bridge_msg_delete_queue,
+	bridge_msg_get,
+	bridge_msg_put,
+	bridge_msg_register_notify,
+	bridge_msg_set_queue_id,
 };
 
 static inline void tlb_flush_all(const void __iomem *base)
@@ -278,161 +265,150 @@
 	__raw_writeb(__raw_readb(base + MMU_GFLUSH) | 1, base + MMU_GFLUSH);
 }
 
-static inline void flush_all(struct WMD_DEV_CONTEXT *pDevContext)
+static inline void flush_all(struct wmd_dev_context *dev_context)
 {
-	if (pDevContext->dwBrdState == BRD_DSP_HIBERNATION ||
-			pDevContext->dwBrdState == BRD_HIBERNATION)
-		WakeDSP(pDevContext, NULL);
+	if (dev_context->dw_brd_state == BRD_DSP_HIBERNATION ||
+	    dev_context->dw_brd_state == BRD_HIBERNATION)
+		wake_dsp(dev_context, NULL);
 
-	tlb_flush_all(pDevContext->dwDSPMmuBase);
+	tlb_flush_all(dev_context->dw_dsp_mmu_base);
 }
 
 static void bad_page_dump(u32 pa, struct page *pg)
 {
 	pr_emerg("DSPBRIDGE: MAP function: COUNT 0 FOR PA 0x%x\n", pa);
 	pr_emerg("Bad page state in process '%s'\n"
-		"page:%p flags:0x%0*lx mapping:%p mapcount:%d count:%d\n"
-		"Backtrace:\n",
-		current->comm, pg, (int)(2*sizeof(unsigned long)),
-		(unsigned long)pg->flags, pg->mapping,
-		page_mapcount(pg), page_count(pg));
-	BUG();
+		 "page:%p flags:0x%0*lx mapping:%p mapcount:%d count:%d\n"
+		 "Backtrace:\n",
+		 current->comm, pg, (int)(2 * sizeof(unsigned long)),
+		 (unsigned long)pg->flags, pg->mapping,
+		 page_mapcount(pg), page_count(pg));
+	dump_stack();
 }
 
 /*
- *  ======== WMD_DRV_Entry ========
+ *  ======== bridge_drv_entry ========
  *  purpose:
  *      Mini Driver entry point.
  */
-void WMD_DRV_Entry(OUT struct WMD_DRV_INTERFACE **ppDrvInterface,
-	      IN CONST char *pstrWMDFileName)
+void bridge_drv_entry(OUT struct bridge_drv_interface **ppDrvInterface,
+		   IN CONST char *pstrWMDFileName)
 {
 
-	DBC_Require(pstrWMDFileName != NULL);
-	DBG_Trace(DBG_ENTER, "In the WMD_DRV_Entry \n");
+	DBC_REQUIRE(pstrWMDFileName != NULL);
 
-	IO_SM_init(); /* Initialization of io_sm module */
+	io_sm_init();		/* Initialization of io_sm module */
 
 	if (strcmp(pstrWMDFileName, "UMA") == 0)
-		*ppDrvInterface = &drvInterfaceFxns;
+		*ppDrvInterface = &drv_interface_fxns;
 	else
-		DBG_Trace(DBG_LEVEL7, "WMD_DRV_Entry Unknown WMD file name");
+		dev_dbg(bridge, "%s Unknown WMD file name", __func__);
 
 }
 
 /*
- *  ======== WMD_BRD_Monitor ========
+ *  ======== bridge_brd_monitor ========
  *  purpose:
- *      This WMD_BRD_Monitor puts DSP into a Loadable state.
+ *      This bridge_brd_monitor puts DSP into a Loadable state.
  *      i.e Application can load and start the device.
  *
  *  Preconditions:
  *      Device in 'OFF' state.
  */
-static DSP_STATUS WMD_BRD_Monitor(struct WMD_DEV_CONTEXT *hDevContext)
+static dsp_status bridge_brd_monitor(struct wmd_dev_context *hDevContext)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	struct CFG_HOSTRES resources;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
+	struct cfg_hostres resources;
 	u32 temp;
-	enum HW_PwrState_t    pwrState;
+	enum hw_pwr_state_t pwr_state;
 
-	DBG_Trace(DBG_ENTER, "Board in the monitor state  \n");
-	status = CFG_GetHostResources(
-		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 	if (DSP_FAILED(status))
 		goto error_return;
 
-	GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
-	HW_PWRST_IVA2RegGet(resources.dwPrmBase, &temp);
+	get_hw_regs(resources.dw_prm_base, resources.dw_cm_base);
+	hw_pwrst_iva2_reg_get(resources.dw_prm_base, &temp);
 	if ((temp & 0x03) != 0x03 || (temp & 0x03) != 0x02) {
 		/* IVA2 is not in ON state */
 		/* Read and set PM_PWSTCTRL_IVA2  to ON */
-		HW_PWR_IVA2PowerStateSet(resources.dwPrmBase,
-					  HW_PWR_DOMAIN_DSP,
-					  HW_PWR_STATE_ON);
+		hw_pwr_iva2_power_state_set(resources.dw_prm_base,
+					    HW_PWR_DOMAIN_DSP, HW_PWR_STATE_ON);
 		/* Set the SW supervised state transition */
-		HW_PWR_CLKCTRL_IVA2RegSet(resources.dwCmBase, HW_SW_SUP_WAKEUP);
+		hw_pwr_clkctrl_iva2_reg_set(resources.dw_cm_base,
+					    HW_SW_SUP_WAKEUP);
 		/* Wait until the state has moved to ON */
-		HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
-				     &pwrState);
+		hw_pwr_iva2_state_get(resources.dw_prm_base, HW_PWR_DOMAIN_DSP,
+				      &pwr_state);
 		/* Disable Automatic transition */
-		HW_PWR_CLKCTRL_IVA2RegSet(resources.dwCmBase, HW_AUTOTRANS_DIS);
+		hw_pwr_clkctrl_iva2_reg_set(resources.dw_cm_base,
+					    HW_AUTOTRANS_DIS);
 	}
-	DBG_Trace(DBG_LEVEL6, "WMD_BRD_Monitor - Middle ****** \n");
-	GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
-	HW_RST_UnReset(resources.dwPrmBase, HW_RST2_IVA2);
-	CLK_Enable(SERVICESCLK_iva2_ck);
+
+	get_hw_regs(resources.dw_prm_base, resources.dw_cm_base);
+	hw_rst_un_reset(resources.dw_prm_base, HW_RST2_IVA2);
+	services_clk_enable(SERVICESCLK_IVA2_CK);
 
 	if (DSP_SUCCEEDED(status)) {
 		/* set the device state to IDLE */
-		pDevContext->dwBrdState = BRD_IDLE;
+		dev_context->dw_brd_state = BRD_IDLE;
 	}
 error_return:
-	DBG_Trace(DBG_LEVEL6, "WMD_BRD_Monitor - End ****** \n");
-	GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
+	get_hw_regs(resources.dw_prm_base, resources.dw_cm_base);
 	return status;
 }
 
 /*
- *  ======== WMD_BRD_Read ========
+ *  ======== bridge_brd_read ========
  *  purpose:
  *      Reads buffers for DSP memory.
  */
-static DSP_STATUS WMD_BRD_Read(struct WMD_DEV_CONTEXT *hDevContext,
-			       OUT u8 *pbHostBuf, u32 dwDSPAddr,
-			       u32 ulNumBytes, u32 ulMemType)
+static dsp_status bridge_brd_read(struct wmd_dev_context *hDevContext,
+				  OUT u8 *pbHostBuf, u32 dwDSPAddr,
+				  u32 ul_num_bytes, u32 ulMemType)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
 	u32 offset;
-	u32 dspBaseAddr = hDevContext->dwDspBaseAddr;
+	u32 dsp_base_addr = hDevContext->dw_dsp_base_addr;
 
-	DBG_Trace(DBG_ENTER, "WMD_BRD_Read, pDevContext: 0x%x\n\t\tpbHostBuf:"
-		  " 0x%x\n\t\tdwDSPAddr:  0x%x\n\t\tulNumBytes:  0x%x\n\t\t"
-		  "ulMemType:  0x%x\n", pDevContext, pbHostBuf,
-		  dwDSPAddr, ulNumBytes, ulMemType);
-	if (dwDSPAddr < pDevContext->dwDSPStartAdd) {
-		DBG_Trace(DBG_LEVEL7,
-			  "WMD_BRD_Read: DSP address < start address \n ");
+	if (dwDSPAddr < dev_context->dw_dsp_start_add) {
 		status = DSP_EFAIL;
 		return status;
 	}
 	/* change here to account for the 3 bands of the DSP internal memory */
-	if ((dwDSPAddr - pDevContext->dwDSPStartAdd) <
-	    pDevContext->dwInternalSize) {
-		offset = dwDSPAddr - pDevContext->dwDSPStartAdd;
+	if ((dwDSPAddr - dev_context->dw_dsp_start_add) <
+	    dev_context->dw_internal_size) {
+		offset = dwDSPAddr - dev_context->dw_dsp_start_add;
 	} else {
-		DBG_Trace(DBG_LEVEL1,
-			  "**** Reading From external memory ****  \n ");
-		status = ReadExtDspData(pDevContext, pbHostBuf, dwDSPAddr,
-					ulNumBytes, ulMemType);
+		status = read_ext_dsp_data(dev_context, pbHostBuf, dwDSPAddr,
+					   ul_num_bytes, ulMemType);
 		return status;
 	}
 	/* copy the data from  DSP memory, */
-	memcpy(pbHostBuf, (void *)(dspBaseAddr + offset), ulNumBytes);
+	memcpy(pbHostBuf, (void *)(dsp_base_addr + offset), ul_num_bytes);
 	return status;
 }
 
 /*
- *  ======== WMD_BRD_SetState ========
+ *  ======== bridge_brd_set_state ========
  *  purpose:
  *      This routine updates the Board status.
  */
-static DSP_STATUS WMD_BRD_SetState(struct WMD_DEV_CONTEXT *hDevContext,
-				   u32 ulBrdState)
+static dsp_status bridge_brd_set_state(struct wmd_dev_context *hDevContext,
+				    u32 ulBrdState)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
 
-	DBG_Trace(DBG_ENTER, "WMD_BRD_SetState: Board State: 0x%x \n",
-		  ulBrdState);
-	pDevContext->dwBrdState = ulBrdState;
+	dev_context->dw_brd_state = ulBrdState;
 	return status;
 }
 
 /*
- *  ======== WMD_BRD_Start ========
+ *  ======== bridge_brd_start ========
  *  purpose:
  *      Initializes DSP MMU and Starts DSP.
  *
@@ -441,927 +417,867 @@
  *  b) DSP_RST1 is asserted.
  *  b) DSP_RST2 is released.
  */
-static DSP_STATUS WMD_BRD_Start(struct WMD_DEV_CONTEXT *hDevContext,
-				u32 dwDSPAddr)
+static dsp_status bridge_brd_start(struct wmd_dev_context *hDevContext,
+				   u32 dwDSPAddr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	u32 dwSyncAddr = 0;
-	u32 ulShmBase;	/* Gpp Phys SM base addr(byte) */
-	u32 ulShmBaseVirt;	/* Dsp Virt SM base addr */
-	u32 ulTLBBaseVirt;	/* Base of MMU TLB entry */
-	u32 ulShmOffsetVirt;	/* offset of ulShmBaseVirt from ulTLBBaseVirt */
-	s32 iEntryNdx;
-	s32 itmpEntryNdx = 0;	/* DSP-MMU TLB entry base address */
-	struct CFG_HOSTRES resources;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
+	u32 dw_sync_addr = 0;
+	u32 ul_shm_base;	/* Gpp Phys SM base addr(byte) */
+	u32 ul_shm_base_virt;	/* Dsp Virt SM base addr */
+	u32 ul_tlb_base_virt;	/* Base of MMU TLB entry */
+	/* Offset of shm_base_virt from tlb_base_virt */
+	u32 ul_shm_offset_virt;
+	s32 entry_ndx;
+	s32 itmp_entry_ndx = 0;	/* DSP-MMU TLB entry base address */
+	struct cfg_hostres resources;
 	u32 temp;
-	u32 ulDspClkRate;
-	u32 ulDspClkAddr;
-	u32 ulBiosGpTimer;
-	u32 uClkCmd;
-	struct IO_MGR *hIOMgr;
-	u32 ulLoadMonitorTimer;
-	u32 extClkId = 0;
-	u32 tmpIndex;
-	u32 clkIdIndex = MBX_PM_MAX_RESOURCES;
-
-	DBG_Trace(DBG_ENTER, "Entering WMD_BRD_Start:\n hDevContext: 0x%x\n\t "
-			     "dwDSPAddr: 0x%x\n", hDevContext, dwDSPAddr);
+	u32 ul_dsp_clk_rate;
+	u32 ul_dsp_clk_addr;
+	u32 ul_bios_gp_timer;
+	u32 clk_cmd;
+	struct io_mgr *hio_mgr;
+	u32 ul_load_monitor_timer;
+	u32 ext_clk_id = 0;
+	u32 tmp_index;
+	u32 clk_id_index = MBX_PM_MAX_RESOURCES;
 
 	/* The device context contains all the mmu setup info from when the
 	 * last dsp base image was loaded. The first entry is always
 	 * SHMMEM base. */
 	/* Get SHM_BEG - convert to byte address */
-	(void) DEV_GetSymbol(pDevContext->hDevObject, SHMBASENAME,
-			     &ulShmBaseVirt);
-	ulShmBaseVirt *= DSPWORDSIZE;
-	DBC_Assert(ulShmBaseVirt != 0);
+	(void)dev_get_symbol(dev_context->hdev_obj, SHMBASENAME,
+			     &ul_shm_base_virt);
+	ul_shm_base_virt *= DSPWORDSIZE;
+	DBC_ASSERT(ul_shm_base_virt != 0);
 	/* DSP Virtual address */
-	ulTLBBaseVirt = pDevContext->aTLBEntry[0].ulDspVa;
-	DBC_Assert(ulTLBBaseVirt <= ulShmBaseVirt);
-	ulShmOffsetVirt = ulShmBaseVirt - (ulTLBBaseVirt * DSPWORDSIZE);
+	ul_tlb_base_virt = dev_context->atlb_entry[0].ul_dsp_va;
+	DBC_ASSERT(ul_tlb_base_virt <= ul_shm_base_virt);
+	ul_shm_offset_virt =
+	    ul_shm_base_virt - (ul_tlb_base_virt * DSPWORDSIZE);
 	/* Kernel logical address */
-	ulShmBase = pDevContext->aTLBEntry[0].ulGppVa + ulShmOffsetVirt;
+	ul_shm_base = dev_context->atlb_entry[0].ul_gpp_va + ul_shm_offset_virt;
 
-	DBC_Assert(ulShmBase != 0);
+	DBC_ASSERT(ul_shm_base != 0);
 	/* 2nd wd is used as sync field */
-	dwSyncAddr = ulShmBase + SHMSYNCOFFSET;
-	 /* Write a signature into the SHM base + offset; this will
-	 * get cleared when the DSP program starts.  */
-	if ((ulShmBaseVirt == 0) || (ulShmBase == 0)) {
-		DBG_Trace(DBG_LEVEL6, "WMD_BRD_Start: Illegal SM base\n");
+	dw_sync_addr = ul_shm_base + SHMSYNCOFFSET;
+	/* Write a signature into the shm base + offset; this will
+	 * get cleared when the DSP program starts. */
+	if ((ul_shm_base_virt == 0) || (ul_shm_base == 0)) {
+		pr_err("%s: Illegal SM base\n", __func__);
 		status = DSP_EFAIL;
 	} else
-		*((volatile u32 *)dwSyncAddr) = 0xffffffff;
+		*((volatile u32 *)dw_sync_addr) = 0xffffffff;
 
 	if (DSP_SUCCEEDED(status)) {
-		status = CFG_GetHostResources(
-			(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
-			&resources);
-		/* Assert RST1 i.e only the RST only for DSP megacell  */
-		/* HW_RST_Reset(resources.dwPrcmBase, HW_RST1_IVA2);*/
+		status = cfg_get_host_resources((struct cfg_devnode *)
+						drv_get_first_dev_extension(),
+						&resources);
+		/* Assert RST1 i.e only the RST only for DSP megacell */
+		/* hw_rst_reset(resources.dwPrcmBase, HW_RST1_IVA2); */
 		if (DSP_SUCCEEDED(status)) {
-			HW_RST_Reset(resources.dwPrmBase, HW_RST1_IVA2);
+			hw_rst_reset(resources.dw_prm_base, HW_RST1_IVA2);
 			if (dsp_debug) {
-				/* Set the bootmode to self loop  */
-				DBG_Trace(DBG_LEVEL7,
-						"Set boot mode to self loop"
-						" for IVA2 Device\n");
-				HW_DSPSS_BootModeSet(resources.dwSysCtrlBase,
-					HW_DSPSYSC_SELFLOOPBOOT, dwDSPAddr);
+				/* Set the bootmode to self loop */
+				dev_dbg(bridge, "Set boot mode to self loop"
+					" for IVA2 Device\n");
+				hw_dspss_boot_mode_set
+				    (resources.dw_sys_ctrl_base,
+				     HW_DSPSYSC_SELFLOOPBOOT, dwDSPAddr);
 			} else {
 				/* Set the bootmode to '0' - direct boot */
-				DBG_Trace(DBG_LEVEL7,
-						"Set boot mode to direct"
-						" boot for IVA2 Device \n");
-				HW_DSPSS_BootModeSet(resources.dwSysCtrlBase,
-					HW_DSPSYSC_DIRECTBOOT, dwDSPAddr);
+				dev_dbg(bridge, "Set boot mode to direct boot"
+					" for IVA2 Device\n");
+				hw_dspss_boot_mode_set
+				    (resources.dw_sys_ctrl_base,
+				     HW_DSPSYSC_DIRECTBOOT, dwDSPAddr);
 			}
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Reset and Unreset the RST2, so that BOOTADDR is copied to
 		 * IVA2 SYSC register */
-		HW_RST_Reset(resources.dwPrmBase, HW_RST2_IVA2);
+		hw_rst_reset(resources.dw_prm_base, HW_RST2_IVA2);
 		udelay(100);
-		HW_RST_UnReset(resources.dwPrmBase, HW_RST2_IVA2);
+		hw_rst_un_reset(resources.dw_prm_base, HW_RST2_IVA2);
 		udelay(100);
-		DBG_Trace(DBG_LEVEL6, "WMD_BRD_Start 0 ****** \n");
-		GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
+
+		get_hw_regs(resources.dw_prm_base, resources.dw_cm_base);
 		/* Disbale the DSP MMU */
-		HW_MMU_Disable(resources.dwDmmuBase);
+		hw_mmu_disable(resources.dw_dmmu_base);
 		/* Disable TWL */
-		HW_MMU_TWLDisable(resources.dwDmmuBase);
+		hw_mmu_twl_disable(resources.dw_dmmu_base);
 
 		/* Only make TLB entry if both addresses are non-zero */
-		for (iEntryNdx = 0; iEntryNdx < WMDIOCTL_NUMOFMMUTLB;
-			iEntryNdx++) {
-			if ((pDevContext->aTLBEntry[iEntryNdx].ulGppPa != 0) &&
-			   (pDevContext->aTLBEntry[iEntryNdx].ulDspVa != 0)) {
-				DBG_Trace(DBG_LEVEL4, "** (proc) MMU %d GppPa:"
-				    " 0x%x DspVa 0x%x Size 0x%x\n",
-				    itmpEntryNdx,
-				    pDevContext->aTLBEntry[iEntryNdx].ulGppPa,
-				    pDevContext->aTLBEntry[iEntryNdx].ulDspVa,
-				    pDevContext->aTLBEntry[iEntryNdx].ulSize);
-				configureDspMmu(pDevContext,
-				    pDevContext->aTLBEntry[iEntryNdx].ulGppPa,
-				    pDevContext->aTLBEntry[iEntryNdx].ulDspVa *
-				    DSPWORDSIZE,
-				    pDevContext->aTLBEntry[iEntryNdx].ulSize,
-				    itmpEntryNdx,
-				    pDevContext->aTLBEntry[iEntryNdx].endianism,
-				    pDevContext->aTLBEntry[iEntryNdx].elemSize,
-				    pDevContext->aTLBEntry[iEntryNdx].
-				    mixedMode);
-				itmpEntryNdx++;
+		for (entry_ndx = 0; entry_ndx < WMDIOCTL_NUMOFMMUTLB;
+		     entry_ndx++) {
+			if ((dev_context->atlb_entry[entry_ndx].ul_gpp_pa != 0)
+			    && (dev_context->atlb_entry[entry_ndx].ul_dsp_va !=
+				0)) {
+				dev_dbg(bridge,
+					"(proc) MMU %d GppPa:"
+					" 0x%x DspVa 0x%x Size 0x%x\n",
+					itmp_entry_ndx,
+					dev_context->atlb_entry[entry_ndx].
+					ul_gpp_pa,
+					dev_context->atlb_entry[entry_ndx].
+					ul_dsp_va,
+					dev_context->atlb_entry[entry_ndx].
+					ul_size);
+				configure_dsp_mmu(dev_context,
+						  dev_context->
+						  atlb_entry[entry_ndx].
+						  ul_gpp_pa,
+						  dev_context->
+						  atlb_entry[entry_ndx].
+						  ul_dsp_va * DSPWORDSIZE,
+						  dev_context->
+						  atlb_entry[entry_ndx].ul_size,
+						  itmp_entry_ndx,
+						  dev_context->
+						  atlb_entry[entry_ndx].
+						  endianism,
+						  dev_context->
+						  atlb_entry[entry_ndx].
+						  elem_size,
+						  dev_context->
+						  atlb_entry[entry_ndx].
+						  mixed_mode);
+				itmp_entry_ndx++;
 			}
 		}		/* end for */
 	}
 
 	/* Lock the above TLB entries and get the BIOS and load monitor timer
-	 * information*/
+	 * information */
 	if (DSP_SUCCEEDED(status)) {
-		HW_MMU_NumLockedSet(resources.dwDmmuBase, itmpEntryNdx);
-		HW_MMU_VictimNumSet(resources.dwDmmuBase, itmpEntryNdx);
-		HW_MMU_TTBSet(resources.dwDmmuBase,
-				pDevContext->pPtAttrs->L1BasePa);
-		HW_MMU_TWLEnable(resources.dwDmmuBase);
+		hw_mmu_num_locked_set(resources.dw_dmmu_base, itmp_entry_ndx);
+		hw_mmu_victim_num_set(resources.dw_dmmu_base, itmp_entry_ndx);
+		hw_mmu_ttb_set(resources.dw_dmmu_base,
+			       dev_context->pt_attrs->l1_base_pa);
+		hw_mmu_twl_enable(resources.dw_dmmu_base);
 		/* Enable the SmartIdle and AutoIdle bit for MMU_SYSCONFIG */
 
-
-		temp = __raw_readl((resources.dwDmmuBase) + 0x10);
+		temp = __raw_readl((resources.dw_dmmu_base) + 0x10);
 		temp = (temp & 0xFFFFFFEF) | 0x11;
-		__raw_writel(temp, (resources.dwDmmuBase) + 0x10);
+		__raw_writel(temp, (resources.dw_dmmu_base) + 0x10);
 
 		/* Let the DSP MMU run */
-		HW_MMU_Enable(resources.dwDmmuBase);
+		hw_mmu_enable(resources.dw_dmmu_base);
 
-		/* Enable the BIOS clock  */
-		(void)DEV_GetSymbol(pDevContext->hDevObject,
-					BRIDGEINIT_BIOSGPTIMER,
-				     &ulBiosGpTimer);
-		DBG_Trace(DBG_LEVEL7, "BIOS GPTimer : 0x%x\n", ulBiosGpTimer);
-		(void)DEV_GetSymbol(pDevContext->hDevObject,
-				BRIDGEINIT_LOADMON_GPTIMER,
-				     &ulLoadMonitorTimer);
-		DBG_Trace(DBG_LEVEL7, "Load Monitor Timer : 0x%x\n",
-			  ulLoadMonitorTimer);
+		/* Enable the BIOS clock */
+		(void)dev_get_symbol(dev_context->hdev_obj,
+				     BRIDGEINIT_BIOSGPTIMER, &ul_bios_gp_timer);
+		(void)dev_get_symbol(dev_context->hdev_obj,
+				     BRIDGEINIT_LOADMON_GPTIMER,
+				     &ul_load_monitor_timer);
 	}
 
 	if (DSP_SUCCEEDED(status)) {
-		if (ulLoadMonitorTimer != 0xFFFF) {
-			uClkCmd = (BPWR_DisableClock << MBX_PM_CLK_CMDSHIFT) |
-						ulLoadMonitorTimer;
-			DBG_Trace(DBG_LEVEL7,
-			       "encoded LoadMonitor cmd for Disable: 0x%x\n",
-			       uClkCmd);
-			DSPPeripheralClkCtrl(pDevContext, &uClkCmd);
-
-			extClkId = uClkCmd & MBX_PM_CLK_IDMASK;
-			for (tmpIndex = 0; tmpIndex < MBX_PM_MAX_RESOURCES;
-				       tmpIndex++) {
-				if (extClkId == BPWR_CLKID[tmpIndex]) {
-					clkIdIndex = tmpIndex;
+		if (ul_load_monitor_timer != 0xFFFF) {
+			clk_cmd = (BPWR_DISABLE_CLOCK << MBX_PM_CLK_CMDSHIFT) |
+			    ul_load_monitor_timer;
+
+			dsp_peripheral_clk_ctrl(dev_context, &clk_cmd);
+
+			ext_clk_id = clk_cmd & MBX_PM_CLK_IDMASK;
+			for (tmp_index = 0; tmp_index < MBX_PM_MAX_RESOURCES;
+			     tmp_index++) {
+				if (ext_clk_id == bpwr_clkid[tmp_index]) {
+					clk_id_index = tmp_index;
 					break;
 				}
 			}
 
-			if (clkIdIndex < MBX_PM_MAX_RESOURCES)
-				status = CLK_Set_32KHz(
-						BPWR_Clks[clkIdIndex].funClk);
-			else
+			if (clk_id_index < MBX_PM_MAX_RESOURCES) {
+				status =
+				    clk_set32k_hz(bpwr_clks
+						  [clk_id_index].fun_clk);
+			} else {
 				status = DSP_EFAIL;
-
-			if (DSP_FAILED(status)) {
-				DBG_Trace(DBG_LEVEL7, " Error while setting"
-							"LM Timer  to 32KHz\n");
 			}
-			uClkCmd = (BPWR_EnableClock << MBX_PM_CLK_CMDSHIFT) |
-				  ulLoadMonitorTimer;
-			DBG_Trace(DBG_LEVEL7,
-				 "encoded LoadMonitor cmd for Enable : 0x%x\n",
-				 uClkCmd);
-			DSPPeripheralClkCtrl(pDevContext, &uClkCmd);
+			clk_cmd = (BPWR_ENABLE_CLOCK << MBX_PM_CLK_CMDSHIFT) |
+			    ul_load_monitor_timer;
+
+			dsp_peripheral_clk_ctrl(dev_context, &clk_cmd);
 
 		} else {
-			DBG_Trace(DBG_LEVEL7,
-				  "Not able to get the symbol for Load "
-				  "Monitor Timer\n");
+			dev_dbg(bridge, "Not able to get the symbol for Load "
+				"Monitor Timer\n");
 		}
 	}
 
 	if (DSP_SUCCEEDED(status)) {
-		if (ulBiosGpTimer != 0xFFFF) {
-			uClkCmd = (BPWR_DisableClock << MBX_PM_CLK_CMDSHIFT) |
-								ulBiosGpTimer;
-			DBG_Trace(DBG_LEVEL7, "encoded BIOS GPTimer cmd for"
-					"Disable: 0x%x\n", uClkCmd);
-			DSPPeripheralClkCtrl(pDevContext, &uClkCmd);
-
-			extClkId = uClkCmd & MBX_PM_CLK_IDMASK;
-
-			for (tmpIndex = 0; tmpIndex < MBX_PM_MAX_RESOURCES;
-			     tmpIndex++) {
-				if (extClkId == BPWR_CLKID[tmpIndex]) {
-					clkIdIndex = tmpIndex;
+		if (ul_bios_gp_timer != 0xFFFF) {
+			clk_cmd = (BPWR_DISABLE_CLOCK << MBX_PM_CLK_CMDSHIFT) |
+			    ul_bios_gp_timer;
+
+			dsp_peripheral_clk_ctrl(dev_context, &clk_cmd);
+
+			ext_clk_id = clk_cmd & MBX_PM_CLK_IDMASK;
+
+			for (tmp_index = 0; tmp_index < MBX_PM_MAX_RESOURCES;
+			     tmp_index++) {
+				if (ext_clk_id == bpwr_clkid[tmp_index]) {
+					clk_id_index = tmp_index;
 					break;
 				}
 			}
 
-			if (clkIdIndex < MBX_PM_MAX_RESOURCES)
-				status = CLK_Set_32KHz(
-						BPWR_Clks[clkIdIndex].funClk);
-			else
+			if (clk_id_index < MBX_PM_MAX_RESOURCES) {
+				status =
+				    clk_set32k_hz(bpwr_clks
+						  [clk_id_index].fun_clk);
+			} else {
 				status = DSP_EFAIL;
-
-			if (DSP_FAILED(status)) {
-				DBG_Trace(DBG_LEVEL7,
-				" Error while setting BIOS Timer  to 32KHz\n");
 			}
 
-			uClkCmd = (BPWR_EnableClock << MBX_PM_CLK_CMDSHIFT) |
-				   ulBiosGpTimer;
-			DBG_Trace(DBG_LEVEL7, "encoded BIOS GPTimer cmd :"
-						"0x%x\n", uClkCmd);
-			DSPPeripheralClkCtrl(pDevContext, &uClkCmd);
+			clk_cmd = (BPWR_ENABLE_CLOCK << MBX_PM_CLK_CMDSHIFT) |
+			    ul_bios_gp_timer;
+
+			dsp_peripheral_clk_ctrl(dev_context, &clk_cmd);
 
 		} else {
-		DBG_Trace(DBG_LEVEL7,
-			       "Not able to get the symbol for BIOS Timer\n");
+			dev_dbg(bridge,
+				"Not able to get the symbol for BIOS Timer\n");
 		}
 	}
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Set the DSP clock rate */
-		(void)DEV_GetSymbol(pDevContext->hDevObject,
-					"_BRIDGEINIT_DSP_FREQ", &ulDspClkAddr);
+		(void)dev_get_symbol(dev_context->hdev_obj,
+				     "_BRIDGEINIT_DSP_FREQ", &ul_dsp_clk_addr);
 		/*Set Autoidle Mode for IVA2 PLL */
-		temp = (u32) *((REG_UWORD32 *)
-			((u32) (resources.dwCmBase) + 0x34));
+		temp = (u32) *((reg_uword32 *)
+				((u32) (resources.dw_cm_base) + 0x34));
 		temp = (temp & 0xFFFFFFFE) | 0x1;
-		*((REG_UWORD32 *) ((u32) (resources.dwCmBase) + 0x34)) =
-			(u32) temp;
-		DBG_Trace(DBG_LEVEL5, "WMD_BRD_Start: _BRIDGE_DSP_FREQ Addr:"
-				"0x%x \n", ulDspClkAddr);
-		if ((unsigned int *)ulDspClkAddr != NULL) {
+		*((reg_uword32 *) ((u32) (resources.dw_cm_base) + 0x34)) =
+		    (u32) temp;
+		if ((unsigned int *)ul_dsp_clk_addr != NULL) {
 			/* Get the clock rate */
-			status = CLK_GetRate(SERVICESCLK_iva2_ck,
-				 &ulDspClkRate);
-			DBG_Trace(DBG_LEVEL5,
-				 "WMD_BRD_Start: DSP clock rate (KHZ): 0x%x \n",
-				 ulDspClkRate);
-			(void)WMD_BRD_Write(pDevContext, (u8 *)&ulDspClkRate,
-				 ulDspClkAddr, sizeof(u32), 0);
+			status = services_clk_get_rate(SERVICESCLK_IVA2_CK,
+						       &ul_dsp_clk_rate);
+			dev_dbg(bridge, "%s: DSP clock rate (KHZ): 0x%x \n",
+				__func__, ul_dsp_clk_rate);
+			(void)bridge_brd_write(dev_context,
+					       (u8 *) &ul_dsp_clk_rate,
+					       ul_dsp_clk_addr, sizeof(u32), 0);
 		}
+		/*
+		 * Enable Mailbox events and also drain any pending
+		 * stale messages.
+		 */
+		dev_context->mbox = omap_mbox_get("dsp");
+		if (IS_ERR(dev_context->mbox)) {
+			dev_context->mbox = NULL;
+			pr_err("%s: Failed to get dsp mailbox handle\n",
+								__func__);
+			status = DSP_EFAIL;
+		}
+
+	}
+	if (DSP_SUCCEEDED(status)) {
+		dev_context->mbox->rxq->callback = (int (*)(void *))io_mbox_msg;
+
 /*PM_IVA2GRPSEL_PER = 0xC0;*/
-		temp = (u32) *((REG_UWORD32 *)
-			((u32) (resources.dwPerPmBase) + 0xA8));
+		temp = (u32) *((reg_uword32 *)
+				((u32) (resources.dw_per_pm_base) + 0xA8));
 		temp = (temp & 0xFFFFFF30) | 0xC0;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8)) =
-			(u32) temp;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA8)) =
+		    (u32) temp;
 
-/*PM_MPUGRPSEL_PER &= 0xFFFFFF3F;*/
-		temp = (u32) *((REG_UWORD32 *)
-			((u32) (resources.dwPerPmBase) + 0xA4));
+/*PM_MPUGRPSEL_PER &= 0xFFFFFF3F; */
+		temp = (u32) *((reg_uword32 *)
+				((u32) (resources.dw_per_pm_base) + 0xA4));
 		temp = (temp & 0xFFFFFF3F);
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4)) =
-			(u32) temp;
-/*CM_SLEEPDEP_PER |= 0x04;*/
-		temp = (u32) *((REG_UWORD32 *)
-			((u32) (resources.dwPerBase) + 0x44));
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA4)) =
+		    (u32) temp;
+/*CM_SLEEPDEP_PER |= 0x04; */
+		temp = (u32) *((reg_uword32 *)
+				((u32) (resources.dw_per_base) + 0x44));
 		temp = (temp & 0xFFFFFFFB) | 0x04;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerBase) + 0x44)) =
-			(u32) temp;
+		*((reg_uword32 *) ((u32) (resources.dw_per_base) + 0x44)) =
+		    (u32) temp;
 
-/*CM_CLKSTCTRL_IVA2 = 0x00000003 -To Allow automatic transitions*/
-		temp = (u32) *((REG_UWORD32 *)
-			((u32) (resources.dwCmBase) + 0x48));
+/*CM_CLKSTCTRL_IVA2 = 0x00000003 -To Allow automatic transitions */
+		temp = (u32) *((reg_uword32 *)
+				((u32) (resources.dw_cm_base) + 0x48));
 		temp = (temp & 0xFFFFFFFC) | 0x03;
-		*((REG_UWORD32 *) ((u32) (resources.dwCmBase) + 0x48)) =
-			(u32) temp;
-
-		/* Enable Mailbox events and also drain any pending
-		 * stale messages */
-		(void)CHNLSM_EnableInterrupt(pDevContext);
-	}
-
-	if (DSP_SUCCEEDED(status)) {
-		HW_RSTCTRL_RegGet(resources.dwPrmBase, HW_RST1_IVA2, &temp);
-		DBG_Trace(DBG_LEVEL7, "BRD_Start: RM_RSTCTRL_DSP = 0x%x \n",
-				temp);
-		HW_RSTST_RegGet(resources.dwPrmBase, HW_RST1_IVA2, &temp);
-		DBG_Trace(DBG_LEVEL7, "BRD_Start0: RM_RSTST_DSP = 0x%x \n",
-				temp);
+		*((reg_uword32 *) ((u32) (resources.dw_cm_base) + 0x48)) =
+		    (u32) temp;
 
 		/* Let DSP go */
-		DBG_Trace(DBG_LEVEL7, "Unreset, WMD_BRD_Start\n");
+		dev_dbg(bridge, "%s Unreset\n", __func__);
 		/* Enable DSP MMU Interrupts */
-		HW_MMU_EventEnable(resources.dwDmmuBase,
-				HW_MMU_ALL_INTERRUPTS);
+		hw_mmu_event_enable(resources.dw_dmmu_base,
+				    HW_MMU_ALL_INTERRUPTS);
 		/* release the RST1, DSP starts executing now .. */
-		HW_RST_UnReset(resources.dwPrmBase, HW_RST1_IVA2);
+		hw_rst_un_reset(resources.dw_prm_base, HW_RST1_IVA2);
 
-		HW_RSTST_RegGet(resources.dwPrmBase, HW_RST1_IVA2, &temp);
-		DBG_Trace(DBG_LEVEL7, "BRD_Start: RM_RSTST_DSP = 0x%x \n",
-				temp);
-		HW_RSTCTRL_RegGet(resources.dwPrmBase, HW_RST1_IVA2, &temp);
-		DBG_Trace(DBG_LEVEL5, "WMD_BRD_Start: CM_RSTCTRL_DSP: 0x%x \n",
-				temp);
-		DBG_Trace(DBG_LEVEL7, "Driver waiting for Sync @ 0x%x \n",
-				dwSyncAddr);
-		DBG_Trace(DBG_LEVEL7, "DSP c_int00 Address =  0x%x \n",
-				dwDSPAddr);
+		dev_dbg(bridge, "Waiting for Sync @ 0x%x\n", dw_sync_addr);
+		dev_dbg(bridge, "DSP c_int00 Address =  0x%x\n", dwDSPAddr);
 		if (dsp_debug)
-			while (*((volatile u16 *)dwSyncAddr))
+			while (*((volatile u16 *)dw_sync_addr))
 				;;
-	}
 
-	if (DSP_SUCCEEDED(status)) {
 		/* Wait for DSP to clear word in shared memory */
 		/* Read the Location */
-		if (!WaitForStart(pDevContext, dwSyncAddr)) {
+		if (!wait_for_start(dev_context, dw_sync_addr))
 			status = WMD_E_TIMEOUT;
-			DBG_Trace(DBG_LEVEL7,
-				 "WMD_BRD_Start Failed to Synchronize\n");
-		}
-		status = DEV_GetIOMgr(pDevContext->hDevObject, &hIOMgr);
+
+		/* Start wdt */
+		dsp_wdt_sm_set((void *)ul_shm_base);
+		dsp_wdt_enable(true);
+
+		status = dev_get_io_mgr(dev_context->hdev_obj, &hio_mgr);
 		if (DSP_SUCCEEDED(status)) {
-			IO_SHMsetting(hIOMgr, SHM_OPPINFO, NULL);
-			DBG_Trace(DBG_LEVEL7,
-			"WMD_BRD_Start: OPP information initialzed\n");
+			io_sh_msetting(hio_mgr, SHM_OPPINFO, NULL);
 			/* Write the synchronization bit to indicate the
 			 * completion of OPP table update to DSP
 			 */
-			*((volatile u32 *)dwSyncAddr) = 0XCAFECAFE;
-		}
-		if (DSP_SUCCEEDED(status)) {
+			*((volatile u32 *)dw_sync_addr) = 0XCAFECAFE;
+
 			/* update board state */
-			pDevContext->dwBrdState = BRD_RUNNING;
-			/* (void)CHNLSM_EnableInterrupt(pDevContext);*/
-			DBG_Trace(DBG_LEVEL7, "Device Started \n ");
+			dev_context->dw_brd_state = BRD_RUNNING;
+			/* (void)chnlsm_enable_interrupt(dev_context); */
 		} else {
-			pDevContext->dwBrdState = BRD_UNKNOWN;
-			DBG_Trace(DBG_LEVEL7, "Device not Started \n ");
+			dev_context->dw_brd_state = BRD_UNKNOWN;
 		}
 	}
 	return status;
 }
 
 /*
- *  ======== WMD_BRD_Stop ========
+ *  ======== bridge_brd_stop ========
  *  purpose:
  *      Puts DSP in self loop.
  *
  *  Preconditions :
  *  a) None
  */
-static DSP_STATUS WMD_BRD_Stop(struct WMD_DEV_CONTEXT *hDevContext)
+static dsp_status bridge_brd_stop(struct wmd_dev_context *hDevContext)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	struct CFG_HOSTRES resources;
-	struct PgTableAttrs *pPtAttrs;
-	u32 dspPwrState;
-	DSP_STATUS clk_status;
-
-	DBG_Trace(DBG_ENTER, "Entering WMD_BRD_Stop:\nhDevContext: 0x%x\n",
-		  hDevContext);
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
+	struct cfg_hostres resources;
+	struct pg_table_attrs *pt_attrs;
+	u32 dsp_pwr_state;
+	dsp_status clk_status;
 
-	/* Disable the mail box interrupts */
-	(void)CHNLSM_DisableInterrupt(pDevContext);
-
-	if (pDevContext->dwBrdState == BRD_STOPPED)
+	if (dev_context->dw_brd_state == BRD_STOPPED)
 		return status;
 
 	/* as per TRM, it is advised to first drive the IVA2 to 'Standby' mode,
 	 * before turning off the clocks.. This is to ensure that there are no
 	 * pending L3 or other transactons from IVA2 */
-	status = CFG_GetHostResources(
-			(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
-			&resources);
-	if (DSP_FAILED(status)) {
-		DBG_Trace(DBG_LEVEL7,
-			  "WMD_BRD_Stop: Get Host resources failed \n");
-		DBG_Trace(DBG_LEVEL1, "Device Stopp failed \n ");
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
+	if (DSP_FAILED(status))
 		return DSP_EFAIL;
-	}
 
-	HW_PWRST_IVA2RegGet(resources.dwPrmBase, &dspPwrState);
-	if (dspPwrState != HW_PWR_STATE_OFF) {
-		CHNLSM_InterruptDSP2(pDevContext, MBX_PM_DSPIDLE);
+	hw_pwrst_iva2_reg_get(resources.dw_prm_base, &dsp_pwr_state);
+	if (dsp_pwr_state != HW_PWR_STATE_OFF) {
+		sm_interrupt_dsp(dev_context, MBX_PM_DSPIDLE);
 		mdelay(10);
-		GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
+		get_hw_regs(resources.dw_prm_base, resources.dw_cm_base);
 		udelay(50);
 
-		clk_status = CLK_Disable(SERVICESCLK_iva2_ck);
-		if (DSP_FAILED(clk_status)) {
-			DBG_Trace(DBG_LEVEL6,
-				 "\n WMD_BRD_Stop: CLK_Disable failed "
-				 "for iva2_fck\n");
-		}
 		/* IVA2 is not in OFF state */
 		/* Set PM_PWSTCTRL_IVA2  to OFF */
-		HW_PWR_IVA2PowerStateSet(resources.dwPrmBase,
-					  HW_PWR_DOMAIN_DSP,
-					  HW_PWR_STATE_OFF);
+		hw_pwr_iva2_power_state_set(resources.dw_prm_base,
+					    HW_PWR_DOMAIN_DSP,
+					    HW_PWR_STATE_OFF);
 		/* Set the SW supervised state transition for Sleep */
-		HW_PWR_CLKCTRL_IVA2RegSet(resources.dwCmBase, HW_SW_SUP_SLEEP);
-	} else {
-		clk_status = CLK_Disable(SERVICESCLK_iva2_ck);
-		if (DSP_FAILED(clk_status)) {
-			DBG_Trace(DBG_LEVEL6,
-				 "\n WMD_BRD_Stop: Else loop CLK_Disable failed"
-				 " for iva2_fck\n");
-		}
+		hw_pwr_clkctrl_iva2_reg_set(resources.dw_cm_base,
+					    HW_SW_SUP_SLEEP);
 	}
 	udelay(10);
 	/* Release the Ext Base virtual Address as the next DSP Program
 	 * may have a different load address */
-	if (pDevContext->dwDspExtBaseAddr)
-		pDevContext->dwDspExtBaseAddr = 0;
+	if (dev_context->dw_dsp_ext_base_addr)
+		dev_context->dw_dsp_ext_base_addr = 0;
+
+	dev_context->dw_brd_state = BRD_STOPPED;	/* update board state */
+
+	dsp_wdt_enable(false);
 
-	pDevContext->dwBrdState = BRD_STOPPED;	/* update board state */
-	DBG_Trace(DBG_LEVEL1, "Device Stopped \n ");
 	/* This is a good place to clear the MMU page tables as well */
-	if (pDevContext->pPtAttrs) {
-		pPtAttrs = pDevContext->pPtAttrs;
-		memset((u8 *) pPtAttrs->L1BaseVa, 0x00, pPtAttrs->L1size);
-		memset((u8 *) pPtAttrs->L2BaseVa, 0x00, pPtAttrs->L2size);
-		memset((u8 *) pPtAttrs->pgInfo, 0x00,
-		       (pPtAttrs->L2NumPages * sizeof(struct PageInfo)));
-	}
-	DBG_Trace(DBG_LEVEL6, "WMD_BRD_Stop - End ****** \n");
-	HW_RST_Reset(resources.dwPrmBase, HW_RST1_IVA2);
-	HW_RST_Reset(resources.dwPrmBase, HW_RST2_IVA2);
+	if (dev_context->pt_attrs) {
+		pt_attrs = dev_context->pt_attrs;
+		memset((u8 *) pt_attrs->l1_base_va, 0x00, pt_attrs->l1_size);
+		memset((u8 *) pt_attrs->l2_base_va, 0x00, pt_attrs->l2_size);
+		memset((u8 *) pt_attrs->pg_info, 0x00,
+		       (pt_attrs->l2_num_pages * sizeof(struct page_info)));
+	}
+	/* Disable the mailbox interrupts */
+	if (dev_context->mbox) {
+		omap_mbox_disable_irq(dev_context->mbox, IRQ_RX);
+		omap_mbox_put(dev_context->mbox);
+		dev_context->mbox = NULL;
+	}
+
+	hw_rst_reset(resources.dw_prm_base, HW_RST1_IVA2);
+	hw_rst_reset(resources.dw_prm_base, HW_RST2_IVA2);
+	hw_rst_reset(resources.dw_prm_base, HW_RST3_IVA2);
+
+	status = dsp_peripheral_clocks_disable(dev_context, NULL);
+	clk_status = services_clk_disable(SERVICESCLK_IVA2_CK);
 
 	return status;
 }
 
-
 /*
- *  ======== WMD_BRD_Delete ========
+ *  ======== wmd_brd_delete ========
  *  purpose:
  *      Puts DSP in Low power mode
  *
  *  Preconditions :
  *  a) None
  */
-static DSP_STATUS WMD_BRD_Delete(struct WMD_DEV_CONTEXT *hDevContext)
+static dsp_status wmd_brd_delete(struct wmd_dev_context *hDevContext)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	struct CFG_HOSTRES resources;
-	struct PgTableAttrs *pPtAttrs;
-	DSP_STATUS clk_status;
-
-	DBG_Trace(DBG_ENTER, "Entering WMD_BRD_Delete:\nhDevContext: 0x%x\n",
-		  hDevContext);
-
-	/* Disable the mail box interrupts */
-	(void) CHNLSM_DisableInterrupt(pDevContext);
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
+	struct cfg_hostres resources;
+	struct pg_table_attrs *pt_attrs;
+	dsp_status clk_status;
 
-	if (pDevContext->dwBrdState == BRD_STOPPED)
+	if (dev_context->dw_brd_state == BRD_STOPPED)
 		return status;
 
 	/* as per TRM, it is advised to first drive
 	 * the IVA2 to 'Standby' mode, before turning off the clocks.. This is
 	 * to ensure that there are no pending L3 or other transactons from
 	 * IVA2 */
-	status = CFG_GetHostResources(
-		(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
-	if (DSP_FAILED(status)) {
-		DBG_Trace(DBG_LEVEL7,
-			 "WMD_BRD_Stop: Get Host resources failed \n");
-		DBG_Trace(DBG_LEVEL1, "Device Delete failed \n ");
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
+	if (DSP_FAILED(status))
 		return DSP_EFAIL;
-	}
-	status = SleepDSP(pDevContext, PWR_EMERGENCYDEEPSLEEP, NULL);
-	clk_status = CLK_Disable(SERVICESCLK_iva2_ck);
-	if (DSP_FAILED(clk_status)) {
-		DBG_Trace(DBG_LEVEL6, "\n WMD_BRD_Stop: CLK_Disable failed for"
-			  " iva2_fck\n");
-	}
+
+	status = sleep_dsp(dev_context, PWR_EMERGENCYDEEPSLEEP, NULL);
+	clk_status = services_clk_disable(SERVICESCLK_IVA2_CK);
+
 	/* Release the Ext Base virtual Address as the next DSP Program
 	 * may have a different load address */
-	if (pDevContext->dwDspExtBaseAddr)
-		pDevContext->dwDspExtBaseAddr = 0;
+	if (dev_context->dw_dsp_ext_base_addr)
+		dev_context->dw_dsp_ext_base_addr = 0;
+
+	dev_context->dw_brd_state = BRD_STOPPED;	/* update board state */
 
-	pDevContext->dwBrdState = BRD_STOPPED;	/* update board state */
-	DBG_Trace(DBG_LEVEL1, "Device Stopped \n ");
 	/* This is a good place to clear the MMU page tables as well */
-	if (pDevContext->pPtAttrs) {
-		pPtAttrs = pDevContext->pPtAttrs;
-		memset((u8 *)pPtAttrs->L1BaseVa, 0x00, pPtAttrs->L1size);
-		memset((u8 *)pPtAttrs->L2BaseVa, 0x00, pPtAttrs->L2size);
-		memset((u8 *)pPtAttrs->pgInfo, 0x00,
-			(pPtAttrs->L2NumPages * sizeof(struct PageInfo)));
-	}
-	DBG_Trace(DBG_LEVEL6, "WMD_BRD_Delete - End ****** \n");
-	HW_RST_Reset(resources.dwPrmBase, HW_RST1_IVA2);
-	HW_RST_Reset(resources.dwPrmBase, HW_RST2_IVA2);
+	if (dev_context->pt_attrs) {
+		pt_attrs = dev_context->pt_attrs;
+		memset((u8 *) pt_attrs->l1_base_va, 0x00, pt_attrs->l1_size);
+		memset((u8 *) pt_attrs->l2_base_va, 0x00, pt_attrs->l2_size);
+		memset((u8 *) pt_attrs->pg_info, 0x00,
+		       (pt_attrs->l2_num_pages * sizeof(struct page_info)));
+	}
+	/* Disable the mail box interrupts */
+	if (dev_context->mbox) {
+		omap_mbox_disable_irq(dev_context->mbox, IRQ_RX);
+		omap_mbox_put(dev_context->mbox);
+		dev_context->mbox = NULL;
+	}
+
+	hw_rst_reset(resources.dw_prm_base, HW_RST1_IVA2);
+	hw_rst_reset(resources.dw_prm_base, HW_RST2_IVA2);
+	hw_rst_reset(resources.dw_prm_base, HW_RST3_IVA2);
 
 	return status;
 }
 
-
 /*
- *  ======== WMD_BRD_Status ========
+ *  ======== bridge_brd_status ========
  *      Returns the board status.
  */
-static DSP_STATUS WMD_BRD_Status(struct WMD_DEV_CONTEXT *hDevContext,
-				 OUT BRD_STATUS *pdwState)
+static dsp_status bridge_brd_status(struct wmd_dev_context *hDevContext,
+				    int *pdwState)
 {
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	*pdwState = pDevContext->dwBrdState;
+	struct wmd_dev_context *dev_context = hDevContext;
+	*pdwState = dev_context->dw_brd_state;
 	return DSP_SOK;
 }
 
 /*
- *  ======== WMD_BRD_Write ========
+ *  ======== bridge_brd_write ========
  *      Copies the buffers to DSP internal or external memory.
  */
-static DSP_STATUS WMD_BRD_Write(struct WMD_DEV_CONTEXT *hDevContext,
-				IN u8 *pbHostBuf, u32 dwDSPAddr,
-				u32 ulNumBytes, u32 ulMemType)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-
-	DBG_Trace(DBG_ENTER, "WMD_BRD_Write, pDevContext: 0x%x\n\t\t "
-		 "pbHostBuf: 0x%x\n\t\tdwDSPAddr: 0x%x\n\t\tulNumBytes: "
-		 "0x%x\n \t\t ulMemtype: 0x%x\n", pDevContext, pbHostBuf,
-		 dwDSPAddr, ulNumBytes, ulMemType);
-	if (dwDSPAddr < pDevContext->dwDSPStartAdd) {
-		DBG_Trace(DBG_LEVEL7,
-			 "WMD_BRD_Write: DSP address < start address \n ");
+static dsp_status bridge_brd_write(struct wmd_dev_context *hDevContext,
+				   IN u8 *pbHostBuf, u32 dwDSPAddr,
+				   u32 ul_num_bytes, u32 ulMemType)
+{
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
+
+	if (dwDSPAddr < dev_context->dw_dsp_start_add) {
 		status = DSP_EFAIL;
 		return status;
 	}
-	if ((dwDSPAddr - pDevContext->dwDSPStartAdd) <
-	   pDevContext->dwInternalSize) {
-		status = WriteDspData(hDevContext, pbHostBuf, dwDSPAddr,
-			 ulNumBytes, ulMemType);
+	if ((dwDSPAddr - dev_context->dw_dsp_start_add) <
+	    dev_context->dw_internal_size) {
+		status = write_dsp_data(hDevContext, pbHostBuf, dwDSPAddr,
+					ul_num_bytes, ulMemType);
 	} else {
-		status = WriteExtDspData(pDevContext, pbHostBuf, dwDSPAddr,
-					 ulNumBytes, ulMemType, false);
+		status = write_ext_dsp_data(dev_context, pbHostBuf, dwDSPAddr,
+					    ul_num_bytes, ulMemType, false);
 	}
 
-	DBG_Trace(DBG_ENTER, "WMD_BRD_Write, memcopy :  DspLogicAddr=0x%x \n",
-			pDevContext->dwDspBaseAddr);
 	return status;
 }
 
 /*
- *  ======== WMD_DEV_Create ========
+ *  ======== bridge_dev_create ========
  *      Creates a driver object. Puts DSP in self loop.
  */
-static DSP_STATUS WMD_DEV_Create(OUT struct WMD_DEV_CONTEXT **ppDevContext,
-				 struct DEV_OBJECT *hDevObject,
-				 IN CONST struct CFG_HOSTRES *pConfig,
-				 IN CONST struct CFG_DSPRES *pDspConfig)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = NULL;
-	s32 iEntryNdx;
-	s32 tcWordSwap;
-	u32 tcWordSwapSize = sizeof(tcWordSwap);
-	struct CFG_HOSTRES resources;
-	struct PgTableAttrs *pPtAttrs;
-	u32   pg_tbl_pa;
-	u32   pg_tbl_va;
-	u32   align_size;
-
-	DBG_Trace(DBG_ENTER, "WMD_DEV_Create, ppDevContext: 0x%x\n\t\t "
-		  "hDevObject: 0x%x\n\t\tpConfig: 0x%x\n\t\tpDspConfig: 0x%x\n",
-		  ppDevContext, hDevObject, pConfig, pDspConfig);
-	 /* Allocate and initialize a data structure to contain the mini driver
-	 *  state, which becomes the context for later calls into this WMD.  */
-	pDevContext = MEM_Calloc(sizeof(struct WMD_DEV_CONTEXT), MEM_NONPAGED);
-	if (!pDevContext) {
-		DBG_Trace(DBG_ENTER, "Failed to allocate mem  \n");
+static dsp_status bridge_dev_create(OUT struct wmd_dev_context **ppDevContext,
+				    struct dev_object *hdev_obj,
+				    IN CONST struct cfg_hostres *pConfig,
+				    IN CONST struct cfg_dspres *pDspConfig)
+{
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = NULL;
+	s32 entry_ndx;
+	s32 tc_word_swap;
+	u32 tc_word_swap_size = sizeof(tc_word_swap);
+	struct cfg_hostres resources;
+	struct pg_table_attrs *pt_attrs;
+	u32 pg_tbl_pa;
+	u32 pg_tbl_va;
+	u32 align_size;
+
+	/* Allocate and initialize a data structure to contain the mini driver
+	 *  state, which becomes the context for later calls into this WMD. */
+	dev_context = mem_calloc(sizeof(struct wmd_dev_context), MEM_NONPAGED);
+	if (!dev_context) {
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
-	status = CFG_GetHostResources(
-		(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 	if (DSP_FAILED(status)) {
-		DBG_Trace(DBG_ENTER, "Failed to get host resources   \n");
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
 
-	pDevContext->dwDSPStartAdd = (u32)OMAP_GEM_BASE;
-	pDevContext->dwSelfLoop = (u32)NULL;
-	pDevContext->uDspPerClks = 0;
-	pDevContext->dwInternalSize = OMAP_DSP_SIZE;
+	dev_context->dw_dsp_start_add = (u32) OMAP_GEM_BASE;
+	dev_context->dw_self_loop = (u32) NULL;
+	dev_context->dsp_per_clks = 0;
+	dev_context->dw_internal_size = OMAP_DSP_SIZE;
 	/*  Clear dev context MMU table entries.
 	 *  These get set on WMD_BRD_IOCTL() call after program loaded. */
-	for (iEntryNdx = 0; iEntryNdx < WMDIOCTL_NUMOFMMUTLB; iEntryNdx++) {
-		pDevContext->aTLBEntry[iEntryNdx].ulGppPa =
-			pDevContext->aTLBEntry[iEntryNdx].ulDspVa = 0;
-	}
-	pDevContext->numTLBEntries = 0;
-	pDevContext->dwDspBaseAddr = (u32)MEM_LinearAddress((void *)
-			(pConfig->dwMemBase[3]), pConfig->dwMemLength[3]);
-	if (!pDevContext->dwDspBaseAddr) {
+	for (entry_ndx = 0; entry_ndx < WMDIOCTL_NUMOFMMUTLB; entry_ndx++) {
+		dev_context->atlb_entry[entry_ndx].ul_gpp_pa =
+		    dev_context->atlb_entry[entry_ndx].ul_dsp_va = 0;
+	}
+	dev_context->num_tlb_entries = 0;
+	dev_context->dw_dsp_base_addr = (u32) MEM_LINEAR_ADDRESS((void *)
+								 (pConfig->
+								  dw_mem_base
+								  [3]),
+								 pConfig->
+								 dw_mem_length
+								 [3]);
+	if (!dev_context->dw_dsp_base_addr)
 		status = DSP_EFAIL;
-		DBG_Trace(DBG_LEVEL7,
-			 "WMD_DEV_Create: failed to Map the API memory\n");
-	}
-	pPtAttrs = MEM_Calloc(sizeof(struct PgTableAttrs), MEM_NONPAGED);
-	if (pPtAttrs != NULL) {
-		/* Assuming that we use only DSP's memory map
-		 * until 0x4000:0000 , we would need only 1024
-		 * L1 enties i.e L1 size = 4K */
-		pPtAttrs->L1size = 0x1000;
-		align_size = pPtAttrs->L1size;
+
+	pt_attrs = mem_calloc(sizeof(struct pg_table_attrs), MEM_NONPAGED);
+	if (pt_attrs != NULL) {
+		pt_attrs->l1_size = SZ_16K; /* 4096 entries of 32 bits */
+		align_size = pt_attrs->l1_size;
 		/* Align sizes are expected to be power of 2 */
 		/* we like to get aligned on L1 table size */
-		pg_tbl_va = (u32)MEM_AllocPhysMem(pPtAttrs->L1size,
-		    align_size, &pg_tbl_pa);
+		pg_tbl_va = (u32) mem_alloc_phys_mem(pt_attrs->l1_size,
+						     align_size, &pg_tbl_pa);
 
 		/* Check if the PA is aligned for us */
-		if ((pg_tbl_pa) & (align_size-1)) {
+		if ((pg_tbl_pa) & (align_size - 1)) {
 			/* PA not aligned to page table size ,
 			 * try with more allocation and align */
-			MEM_FreePhysMem((void *)pg_tbl_va, pg_tbl_pa,
-					pPtAttrs->L1size);
+			mem_free_phys_mem((void *)pg_tbl_va, pg_tbl_pa,
+					  pt_attrs->l1_size);
 			/* we like to get aligned on L1 table size */
-			pg_tbl_va = (u32) MEM_AllocPhysMem((pPtAttrs->L1size)*2,
-					align_size, &pg_tbl_pa);
+			pg_tbl_va =
+			    (u32) mem_alloc_phys_mem((pt_attrs->l1_size) * 2,
+						     align_size, &pg_tbl_pa);
 			/* We should be able to get aligned table now */
-			pPtAttrs->L1TblAllocPa = pg_tbl_pa;
-			pPtAttrs->L1TblAllocVa = pg_tbl_va;
-			pPtAttrs->L1TblAllocSz = pPtAttrs->L1size * 2;
+			pt_attrs->l1_tbl_alloc_pa = pg_tbl_pa;
+			pt_attrs->l1_tbl_alloc_va = pg_tbl_va;
+			pt_attrs->l1_tbl_alloc_sz = pt_attrs->l1_size * 2;
 			/* Align the PA to the next 'align'  boundary */
-			pPtAttrs->L1BasePa = ((pg_tbl_pa) + (align_size-1)) &
-				(~(align_size-1));
-			pPtAttrs->L1BaseVa = pg_tbl_va + (pPtAttrs->L1BasePa -
-				pg_tbl_pa);
+			pt_attrs->l1_base_pa =
+			    ((pg_tbl_pa) +
+			     (align_size - 1)) & (~(align_size - 1));
+			pt_attrs->l1_base_va =
+			    pg_tbl_va + (pt_attrs->l1_base_pa - pg_tbl_pa);
 		} else {
 			/* We got aligned PA, cool */
-			pPtAttrs->L1TblAllocPa = pg_tbl_pa;
-			pPtAttrs->L1TblAllocVa = pg_tbl_va;
-			pPtAttrs->L1TblAllocSz = pPtAttrs->L1size;
-			pPtAttrs->L1BasePa = pg_tbl_pa;
-			pPtAttrs->L1BaseVa = pg_tbl_va;
-		}
-		if (pPtAttrs->L1BaseVa)
-			memset((u8 *)pPtAttrs->L1BaseVa, 0x00,
-				pPtAttrs->L1size);
+			pt_attrs->l1_tbl_alloc_pa = pg_tbl_pa;
+			pt_attrs->l1_tbl_alloc_va = pg_tbl_va;
+			pt_attrs->l1_tbl_alloc_sz = pt_attrs->l1_size;
+			pt_attrs->l1_base_pa = pg_tbl_pa;
+			pt_attrs->l1_base_va = pg_tbl_va;
+		}
+		if (pt_attrs->l1_base_va)
+			memset((u8 *) pt_attrs->l1_base_va, 0x00,
+			       pt_attrs->l1_size);
 
 		/* number of L2 page tables = DMM pool used + SHMMEM +EXTMEM +
 		 * L4 pages */
-		pPtAttrs->L2NumPages = ((DMMPOOLSIZE >> 20) + 6);
-		pPtAttrs->L2size = HW_MMU_COARSE_PAGE_SIZE *
-				   pPtAttrs->L2NumPages;
-		align_size = 4; /* Make it u32 aligned  */
+		pt_attrs->l2_num_pages = ((DMMPOOLSIZE >> 20) + 6);
+		pt_attrs->l2_size = HW_MMU_COARSE_PAGE_SIZE *
+		    pt_attrs->l2_num_pages;
+		align_size = 4;	/* Make it u32 aligned */
 		/* we like to get aligned on L1 table size */
-		pg_tbl_va = (u32)MEM_AllocPhysMem(pPtAttrs->L2size,
-			    align_size, &pg_tbl_pa);
-		pPtAttrs->L2TblAllocPa = pg_tbl_pa;
-		pPtAttrs->L2TblAllocVa = pg_tbl_va;
-		pPtAttrs->L2TblAllocSz = pPtAttrs->L2size;
-		pPtAttrs->L2BasePa = pg_tbl_pa;
-		pPtAttrs->L2BaseVa = pg_tbl_va;
-
-		if (pPtAttrs->L2BaseVa)
-			memset((u8 *)pPtAttrs->L2BaseVa, 0x00,
-				pPtAttrs->L2size);
-
-		pPtAttrs->pgInfo = MEM_Calloc(pPtAttrs->L2NumPages *
-				sizeof(struct PageInfo), MEM_NONPAGED);
-		DBG_Trace(DBG_LEVEL1, "L1 pa %x, va %x, size %x\n L2 pa %x, va "
-			 "%x, size %x\n", pPtAttrs->L1BasePa,
-			 pPtAttrs->L1BaseVa, pPtAttrs->L1size,
-			 pPtAttrs->L2BasePa, pPtAttrs->L2BaseVa,
-			 pPtAttrs->L2size);
-		DBG_Trace(DBG_LEVEL1, "pPtAttrs %x L2 NumPages %x pgInfo %x\n",
-			 pPtAttrs, pPtAttrs->L2NumPages, pPtAttrs->pgInfo);
-	}
-	if ((pPtAttrs != NULL) && (pPtAttrs->L1BaseVa != 0) &&
-	   (pPtAttrs->L2BaseVa != 0) && (pPtAttrs->pgInfo != NULL))
-		pDevContext->pPtAttrs = pPtAttrs;
+		pg_tbl_va = (u32) mem_alloc_phys_mem(pt_attrs->l2_size,
+						     align_size, &pg_tbl_pa);
+		pt_attrs->l2_tbl_alloc_pa = pg_tbl_pa;
+		pt_attrs->l2_tbl_alloc_va = pg_tbl_va;
+		pt_attrs->l2_tbl_alloc_sz = pt_attrs->l2_size;
+		pt_attrs->l2_base_pa = pg_tbl_pa;
+		pt_attrs->l2_base_va = pg_tbl_va;
+
+		if (pt_attrs->l2_base_va)
+			memset((u8 *) pt_attrs->l2_base_va, 0x00,
+			       pt_attrs->l2_size);
+
+		pt_attrs->pg_info = mem_calloc(pt_attrs->l2_num_pages *
+					       sizeof(struct page_info),
+					       MEM_NONPAGED);
+		dev_dbg(bridge,
+			"L1 pa %x, va %x, size %x\n L2 pa %x, va "
+			"%x, size %x\n", pt_attrs->l1_base_pa,
+			pt_attrs->l1_base_va, pt_attrs->l1_size,
+			pt_attrs->l2_base_pa, pt_attrs->l2_base_va,
+			pt_attrs->l2_size);
+		dev_dbg(bridge, "pt_attrs %p L2 NumPages %x pg_info %p\n",
+			pt_attrs, pt_attrs->l2_num_pages, pt_attrs->pg_info);
+	}
+	if ((pt_attrs != NULL) && (pt_attrs->l1_base_va != 0) &&
+	    (pt_attrs->l2_base_va != 0) && (pt_attrs->pg_info != NULL))
+		dev_context->pt_attrs = pt_attrs;
 	else
 		status = DSP_EMEMORY;
 
 	if (DSP_SUCCEEDED(status))
-		status = SYNC_InitializeCS(&pPtAttrs->hCSObj);
+		status = sync_initialize_cs(&pt_attrs->hcs_obj);
 
 	if (DSP_SUCCEEDED(status)) {
-		/* Set the Endianism Register */ /* Need to set this */
+		/* Set the Endianism Register *//* Need to set this */
 		/* Retrieve the TC u16 SWAP Option */
-		status = REG_GetValue(NULL, CURRENTCONFIG, TCWORDSWAP,
-				     (u8 *)&tcWordSwap, &tcWordSwapSize);
+		status = reg_get_value(TCWORDSWAP, (u8 *) &tc_word_swap,
+				       &tc_word_swap_size);
 		/* Save the value */
-		pDevContext->tcWordSwapOn = tcWordSwap;
+		dev_context->tc_word_swap_on = tc_word_swap;
 	}
 	if (DSP_SUCCEEDED(status)) {
-		/* Set the Clock Divisor for the DSP module */
-		DBG_Trace(DBG_LEVEL7, "WMD_DEV_create:Reset mail box and "
-			  "enable the clock \n");
-		status = CLK_Enable(SERVICESCLK_mailbox_ick);
-		if (DSP_FAILED(status)) {
-			DBG_Trace(DBG_LEVEL7,
-				 "WMD_DEV_create:Reset mail box and "
-				 "enable the clock Fail\n");
-		}
-		udelay(5);
 		/* 24xx-Linux MMU address is obtained from the host
 		 * resources struct */
-		pDevContext->dwDSPMmuBase = resources.dwDmmuBase;
+		dev_context->dw_dsp_mmu_base = resources.dw_dmmu_base;
 	}
 	if (DSP_SUCCEEDED(status)) {
-		pDevContext->hDevObject = hDevObject;
-		pDevContext->ulIntMask = 0;
+		dev_context->hdev_obj = hdev_obj;
+		dev_context->ul_int_mask = 0;
 		/* Store current board state. */
-		pDevContext->dwBrdState = BRD_STOPPED;
-		/* Return this ptr to our device state to the WCD for storage:*/
-		*ppDevContext = pDevContext;
-		DBG_Trace(DBG_ENTER, "Device Created \n");
+		dev_context->dw_brd_state = BRD_STOPPED;
+		/* Return ptr to our device state to the WCD for storage */
+		*ppDevContext = dev_context;
 	} else {
-		if (pPtAttrs != NULL) {
-			if (pPtAttrs->hCSObj)
-				SYNC_DeleteCS(pPtAttrs->hCSObj);
-
-			if (pPtAttrs->pgInfo)
-				MEM_Free(pPtAttrs->pgInfo);
-
-			if (pPtAttrs->L2TblAllocVa) {
-				MEM_FreePhysMem((void *)pPtAttrs->L2TblAllocVa,
-						pPtAttrs->L2TblAllocPa,
-						pPtAttrs->L2TblAllocSz);
-			}
-			if (pPtAttrs->L1TblAllocVa) {
-				MEM_FreePhysMem((void *)pPtAttrs->L1TblAllocVa,
-						pPtAttrs->L1TblAllocPa,
-						pPtAttrs->L1TblAllocSz);
+		if (pt_attrs != NULL) {
+			if (pt_attrs->hcs_obj)
+				sync_delete_cs(pt_attrs->hcs_obj);
+
+			kfree(pt_attrs->pg_info);
+
+			if (pt_attrs->l2_tbl_alloc_va) {
+				mem_free_phys_mem((void *)
+						  pt_attrs->l2_tbl_alloc_va,
+						  pt_attrs->l2_tbl_alloc_pa,
+						  pt_attrs->l2_tbl_alloc_sz);
+			}
+			if (pt_attrs->l1_tbl_alloc_va) {
+				mem_free_phys_mem((void *)
+						  pt_attrs->l1_tbl_alloc_va,
+						  pt_attrs->l1_tbl_alloc_pa,
+						  pt_attrs->l1_tbl_alloc_sz);
 			}
 		}
-		if (pPtAttrs)
-			MEM_Free(pPtAttrs);
-
-		if (pDevContext)
-			MEM_Free(pDevContext);
-
-		DBG_Trace(DBG_LEVEL7,
-			 "WMD_DEV_Create Error Device  not created\n");
+		kfree(pt_attrs);
+		kfree(dev_context);
 	}
 func_end:
 	return status;
 }
 
 /*
- *  ======== WMD_DEV_Ctrl ========
+ *  ======== bridge_dev_ctrl ========
  *      Receives device specific commands.
  */
-static DSP_STATUS WMD_DEV_Ctrl(struct WMD_DEV_CONTEXT *pDevContext, u32 dwCmd,
-				IN OUT void *pArgs)
+static dsp_status bridge_dev_ctrl(struct wmd_dev_context *dev_context,
+				  u32 dw_cmd, IN OUT void *pargs)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct WMDIOCTL_EXTPROC *paExtProc = (struct WMDIOCTL_EXTPROC *)pArgs;
+	dsp_status status = DSP_SOK;
+	struct wmdioctl_extproc *pa_ext_proc = (struct wmdioctl_extproc *)pargs;
 	s32 ndx;
 
-	DBG_Trace(DBG_ENTER, "WMD_DEV_Ctrl, pDevContext:  0x%x\n\t\t dwCmd:  "
-		  "0x%x\n\t\tpArgs:  0x%x\n", pDevContext, dwCmd, pArgs);
-	switch (dwCmd) {
+	switch (dw_cmd) {
 	case WMDIOCTL_CHNLREAD:
 		break;
 	case WMDIOCTL_CHNLWRITE:
 		break;
 	case WMDIOCTL_SETMMUCONFIG:
 		/* store away dsp-mmu setup values for later use */
-		for (ndx = 0; ndx < WMDIOCTL_NUMOFMMUTLB; ndx++, paExtProc++)
-			pDevContext->aTLBEntry[ndx] = *paExtProc;
+		for (ndx = 0; ndx < WMDIOCTL_NUMOFMMUTLB; ndx++, pa_ext_proc++)
+			dev_context->atlb_entry[ndx] = *pa_ext_proc;
 		break;
 	case WMDIOCTL_DEEPSLEEP:
 	case WMDIOCTL_EMERGENCYSLEEP:
 		/* Currently only DSP Idle is supported Need to update for
 		 * later releases */
-		DBG_Trace(DBG_LEVEL5, "WMDIOCTL_DEEPSLEEP\n");
-		status = SleepDSP(pDevContext, PWR_DEEPSLEEP, pArgs);
+		status = sleep_dsp(dev_context, PWR_DEEPSLEEP, pargs);
 		break;
 	case WMDIOCTL_WAKEUP:
-		DBG_Trace(DBG_LEVEL5, "WMDIOCTL_WAKEUP\n");
-		status = WakeDSP(pDevContext, pArgs);
+		status = wake_dsp(dev_context, pargs);
 		break;
 	case WMDIOCTL_CLK_CTRL:
-		DBG_Trace(DBG_LEVEL5, "WMDIOCTL_CLK_CTRL\n");
 		status = DSP_SOK;
 		/* Looking For Baseport Fix for Clocks */
-		status = DSPPeripheralClkCtrl(pDevContext, pArgs);
+		status = dsp_peripheral_clk_ctrl(dev_context, pargs);
 		break;
 	case WMDIOCTL_PWR_HIBERNATE:
-		DBG_Trace(DBG_LEVEL5, "WMDIOCTL_PWR_HIBERNATE\n");
-		status = handle_hibernation_fromDSP(pDevContext);
+		status = handle_hibernation_from_dsp(dev_context);
 		break;
 	case WMDIOCTL_PRESCALE_NOTIFY:
-		DBG_Trace(DBG_LEVEL5, "WMDIOCTL_PRESCALE_NOTIFY\n");
-		status = PreScale_DSP(pDevContext, pArgs);
+		status = pre_scale_dsp(dev_context, pargs);
 		break;
 	case WMDIOCTL_POSTSCALE_NOTIFY:
-		DBG_Trace(DBG_LEVEL5, "WMDIOCTL_POSTSCALE_NOTIFY\n");
-		status = PostScale_DSP(pDevContext, pArgs);
+		status = post_scale_dsp(dev_context, pargs);
 		break;
 	case WMDIOCTL_CONSTRAINT_REQUEST:
-		DBG_Trace(DBG_LEVEL5, "WMDIOCTL_CONSTRAINT_REQUEST\n");
-		status = handle_constraints_set(pDevContext, pArgs);
+		status = handle_constraints_set(dev_context, pargs);
 		break;
 	default:
 		status = DSP_EFAIL;
-		DBG_Trace(DBG_LEVEL7, "Error in WMD_BRD_Ioctl \n");
 		break;
 	}
 	return status;
 }
 
 /*
- *  ======== WMD_DEV_Destroy ========
+ *  ======== bridge_dev_destroy ========
  *      Destroys the driver object.
  */
-static DSP_STATUS WMD_DEV_Destroy(struct WMD_DEV_CONTEXT *hDevContext)
+static dsp_status bridge_dev_destroy(struct wmd_dev_context *hDevContext)
 {
-	struct PgTableAttrs *pPtAttrs;
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = (struct WMD_DEV_CONTEXT *)
-						hDevContext;
-	DBG_Trace(DBG_ENTER, "Entering WMD_DEV_Destroy:n hDevContext ::0x%x\n",
-		  hDevContext);
+	struct pg_table_attrs *pt_attrs;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = (struct wmd_dev_context *)
+	    hDevContext;
+
+	/* It should never happen */
+	if (!hDevContext)
+		return DSP_EHANDLE;
+
 	/* first put the device to stop state */
-	WMD_BRD_Delete(pDevContext);
-	if (pDevContext && pDevContext->pPtAttrs) {
-		pPtAttrs = pDevContext->pPtAttrs;
-		if (pPtAttrs->hCSObj)
-			SYNC_DeleteCS(pPtAttrs->hCSObj);
-
-		if (pPtAttrs->pgInfo)
-			MEM_Free(pPtAttrs->pgInfo);
-
-		if (pPtAttrs->L2TblAllocVa) {
-			MEM_FreePhysMem((void *)pPtAttrs->L2TblAllocVa,
-					pPtAttrs->L2TblAllocPa, pPtAttrs->
-					L2TblAllocSz);
-		}
-		if (pPtAttrs->L1TblAllocVa) {
-			MEM_FreePhysMem((void *)pPtAttrs->L1TblAllocVa,
-					pPtAttrs->L1TblAllocPa, pPtAttrs->
-					L1TblAllocSz);
+	wmd_brd_delete(dev_context);
+	if (dev_context->pt_attrs) {
+		pt_attrs = dev_context->pt_attrs;
+		if (pt_attrs->hcs_obj)
+			sync_delete_cs(pt_attrs->hcs_obj);
+
+		kfree(pt_attrs->pg_info);
+
+		if (pt_attrs->l2_tbl_alloc_va) {
+			mem_free_phys_mem((void *)pt_attrs->l2_tbl_alloc_va,
+					  pt_attrs->l2_tbl_alloc_pa,
+					  pt_attrs->l2_tbl_alloc_sz);
+		}
+		if (pt_attrs->l1_tbl_alloc_va) {
+			mem_free_phys_mem((void *)pt_attrs->l1_tbl_alloc_va,
+					  pt_attrs->l1_tbl_alloc_pa,
+					  pt_attrs->l1_tbl_alloc_sz);
 		}
-		if (pPtAttrs)
-			MEM_Free(pPtAttrs);
+		kfree(pt_attrs);
 
 	}
 	/* Free the driver's device context: */
-	MEM_Free((void *) hDevContext);
+	kfree((void *)hDevContext);
 	return status;
 }
 
-static DSP_STATUS WMD_BRD_MemCopy(struct WMD_DEV_CONTEXT *hDevContext,
-				  u32 ulDspDestAddr, u32 ulDspSrcAddr,
-				  u32 ulNumBytes, u32 ulMemType)
-{
-	DSP_STATUS status = DSP_SOK;
-	u32 srcAddr = ulDspSrcAddr;
-	u32 destAddr = ulDspDestAddr;
-	u32 copyBytes = 0;
-	u32 totalBytes = ulNumBytes;
-	u8 hostBuf[BUFFERSIZE];
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	while ((totalBytes > 0) && DSP_SUCCEEDED(status)) {
-		copyBytes = totalBytes > BUFFERSIZE ? BUFFERSIZE : totalBytes;
+static dsp_status bridge_brd_mem_copy(struct wmd_dev_context *hDevContext,
+				   u32 ulDspDestAddr, u32 ulDspSrcAddr,
+				   u32 ul_num_bytes, u32 ulMemType)
+{
+	dsp_status status = DSP_SOK;
+	u32 src_addr = ulDspSrcAddr;
+	u32 dest_addr = ulDspDestAddr;
+	u32 copy_bytes = 0;
+	u32 total_bytes = ul_num_bytes;
+	u8 host_buf[BUFFERSIZE];
+	struct wmd_dev_context *dev_context = hDevContext;
+	while ((total_bytes > 0) && DSP_SUCCEEDED(status)) {
+		copy_bytes =
+		    total_bytes > BUFFERSIZE ? BUFFERSIZE : total_bytes;
 		/* Read from External memory */
-		status = ReadExtDspData(hDevContext, hostBuf, srcAddr,
-					copyBytes, ulMemType);
+		status = read_ext_dsp_data(hDevContext, host_buf, src_addr,
+					   copy_bytes, ulMemType);
 		if (DSP_SUCCEEDED(status)) {
-			if (destAddr < (pDevContext->dwDSPStartAdd +
-			    pDevContext->dwInternalSize)) {
+			if (dest_addr < (dev_context->dw_dsp_start_add +
+					 dev_context->dw_internal_size)) {
 				/* Write to Internal memory */
-				status = WriteDspData(hDevContext, hostBuf,
-					 destAddr, copyBytes, ulMemType);
+				status = write_dsp_data(hDevContext, host_buf,
+							dest_addr, copy_bytes,
+							ulMemType);
 			} else {
 				/* Write to External memory */
-				status = WriteExtDspData(hDevContext, hostBuf,
-					 destAddr, copyBytes, ulMemType, false);
+				status =
+				    write_ext_dsp_data(hDevContext, host_buf,
+						       dest_addr, copy_bytes,
+						       ulMemType, false);
 			}
 		}
-		totalBytes -= copyBytes;
-		srcAddr += copyBytes;
-		destAddr += copyBytes;
+		total_bytes -= copy_bytes;
+		src_addr += copy_bytes;
+		dest_addr += copy_bytes;
 	}
 	return status;
 }
 
-/* Mem Write does not halt the DSP to write unlike WMD_BRD_Write */
-static DSP_STATUS WMD_BRD_MemWrite(struct WMD_DEV_CONTEXT *hDevContext,
-				   IN u8 *pbHostBuf, u32 dwDSPAddr,
-				   u32 ulNumBytes, u32 ulMemType)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	u32 ulRemainBytes = 0;
-	u32 ulBytes = 0;
-	ulRemainBytes = ulNumBytes;
-	while (ulRemainBytes > 0 && DSP_SUCCEEDED(status)) {
-		ulBytes =
-			ulRemainBytes > BUFFERSIZE ? BUFFERSIZE : ulRemainBytes;
-		if (dwDSPAddr < (pDevContext->dwDSPStartAdd +
-		    pDevContext->dwInternalSize)) {
-			status = WriteDspData(hDevContext, pbHostBuf, dwDSPAddr,
-					      ulBytes, ulMemType);
+/* Mem Write does not halt the DSP to write unlike bridge_brd_write */
+static dsp_status bridge_brd_mem_write(struct wmd_dev_context *hDevContext,
+				    IN u8 *pbHostBuf, u32 dwDSPAddr,
+				    u32 ul_num_bytes, u32 ulMemType)
+{
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
+	u32 ul_remain_bytes = 0;
+	u32 ul_bytes = 0;
+	ul_remain_bytes = ul_num_bytes;
+	while (ul_remain_bytes > 0 && DSP_SUCCEEDED(status)) {
+		ul_bytes =
+		    ul_remain_bytes > BUFFERSIZE ? BUFFERSIZE : ul_remain_bytes;
+		if (dwDSPAddr < (dev_context->dw_dsp_start_add +
+				 dev_context->dw_internal_size)) {
+			status =
+			    write_dsp_data(hDevContext, pbHostBuf, dwDSPAddr,
+					   ul_bytes, ulMemType);
 		} else {
-			status = WriteExtDspData(hDevContext, pbHostBuf,
-				 dwDSPAddr, ulBytes, ulMemType, true);
-		}
-		ulRemainBytes -= ulBytes;
-		dwDSPAddr += ulBytes;
-		pbHostBuf = pbHostBuf + ulBytes;
+			status = write_ext_dsp_data(hDevContext, pbHostBuf,
+						    dwDSPAddr, ul_bytes,
+						    ulMemType, true);
+		}
+		ul_remain_bytes -= ul_bytes;
+		dwDSPAddr += ul_bytes;
+		pbHostBuf = pbHostBuf + ul_bytes;
 	}
 	return status;
 }
 
 /*
- *  ======== WMD_BRD_MemMap ========
+ *  ======== bridge_brd_mem_map ========
  *      This function maps MPU buffer to the DSP address space. It performs
  *  linear to physical address translation if required. It translates each
  *  page since linear addresses can be physically non-contiguous
@@ -1369,406 +1285,400 @@
  *
  *  TODO: Disable MMU while updating the page tables (but that'll stall DSP)
  */
-static DSP_STATUS WMD_BRD_MemMap(struct WMD_DEV_CONTEXT *hDevContext,
-				 u32 ulMpuAddr, u32 ulVirtAddr,
-				 u32 ulNumBytes, u32 ulMapAttr)
+static dsp_status bridge_brd_mem_map(struct wmd_dev_context *hDevContext,
+				  u32 ul_mpu_addr, u32 ulVirtAddr,
+				  u32 ul_num_bytes, u32 ul_map_attr)
 {
 	u32 attrs;
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	struct HW_MMUMapAttrs_t hwAttrs;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
+	struct hw_mmu_map_attrs_t hw_attrs;
 	struct vm_area_struct *vma;
 	struct mm_struct *mm = current->mm;
-	u32 numUsrPgs = 0, nr_pages = 0;
+	u32 write = 0;
+	u32 num_usr_pgs = 0;
+	struct page *mapped_page, *pg;
+	s32 pg_num;
 	u32 va = ulVirtAddr;
-
-	DBG_Trace(DBG_ENTER, "> WMD_BRD_MemMap hDevContext %x, pa %x, va %x, "
-		 "size %x, ulMapAttr %x\n", hDevContext, ulMpuAddr, ulVirtAddr,
-		 ulNumBytes, ulMapAttr);
-	if (ulNumBytes == 0)
+	struct task_struct *curr_task = current;
+	u32 pg_i = 0;
+	u32 mpu_addr, pa;
+
+	dev_dbg(bridge,
+		"%s hDevCtxt %p, pa %x, va %x, size %x, ul_map_attr %x\n",
+		__func__, hDevContext, ul_mpu_addr, ulVirtAddr, ul_num_bytes,
+		ul_map_attr);
+	if (ul_num_bytes == 0)
 		return DSP_EINVALIDARG;
 
-	if (ulMapAttr != 0) {
-		attrs = ulMapAttr;
+	if (ul_map_attr & DSP_MAP_DIR_MASK) {
+		attrs = ul_map_attr;
 	} else {
 		/* Assign default attributes */
-		attrs = DSP_MAPVIRTUALADDR | DSP_MAPELEMSIZE16;
+		attrs = ul_map_attr | (DSP_MAPVIRTUALADDR | DSP_MAPELEMSIZE16);
 	}
 	/* Take mapping properties */
 	if (attrs & DSP_MAPBIGENDIAN)
-		hwAttrs.endianism = HW_BIG_ENDIAN;
+		hw_attrs.endianism = HW_BIG_ENDIAN;
 	else
-		hwAttrs.endianism = HW_LITTLE_ENDIAN;
+		hw_attrs.endianism = HW_LITTLE_ENDIAN;
 
-	hwAttrs.mixedSize = (enum HW_MMUMixedSize_t)
-			       ((attrs & DSP_MAPMIXEDELEMSIZE) >> 2);
-	/* Ignore elementSize if mixedSize is enabled */
-	if (hwAttrs.mixedSize == 0) {
+	hw_attrs.mixed_size = (enum hw_mmu_mixed_size_t)
+	    ((attrs & DSP_MAPMIXEDELEMSIZE) >> 2);
+	/* Ignore element_size if mixed_size is enabled */
+	if (hw_attrs.mixed_size == 0) {
 		if (attrs & DSP_MAPELEMSIZE8) {
 			/* Size is 8 bit */
-			hwAttrs.elementSize = HW_ELEM_SIZE_8BIT;
+			hw_attrs.element_size = HW_ELEM_SIZE8BIT;
 		} else if (attrs & DSP_MAPELEMSIZE16) {
 			/* Size is 16 bit */
-			hwAttrs.elementSize = HW_ELEM_SIZE_16BIT;
+			hw_attrs.element_size = HW_ELEM_SIZE16BIT;
 		} else if (attrs & DSP_MAPELEMSIZE32) {
 			/* Size is 32 bit */
-			hwAttrs.elementSize = HW_ELEM_SIZE_32BIT;
+			hw_attrs.element_size = HW_ELEM_SIZE32BIT;
 		} else if (attrs & DSP_MAPELEMSIZE64) {
 			/* Size is 64 bit */
-			hwAttrs.elementSize = HW_ELEM_SIZE_64BIT;
+			hw_attrs.element_size = HW_ELEM_SIZE64BIT;
 		} else {
 			/*
 			 * Mixedsize isn't enabled, so size can't be
 			 * zero here
 			 */
-			DBG_Trace(DBG_LEVEL7,
-				 "WMD_BRD_MemMap: MMU element size is zero\n");
 			return DSP_EINVALIDARG;
 		}
 	}
 	if (attrs & DSP_MAPDONOTLOCK)
-		hwAttrs.donotlockmpupage = 1;
+		hw_attrs.donotlockmpupage = 1;
 	else
-		hwAttrs.donotlockmpupage = 0;
+		hw_attrs.donotlockmpupage = 0;
 
 	if (attrs & DSP_MAPVMALLOCADDR) {
-		return MemMapVmalloc(hDevContext, ulMpuAddr, ulVirtAddr,
-				       ulNumBytes, &hwAttrs);
+		return mem_map_vmalloc(hDevContext, ul_mpu_addr, ulVirtAddr,
+				       ul_num_bytes, &hw_attrs);
 	}
 	/*
 	 * Do OS-specific user-va to pa translation.
 	 * Combine physically contiguous regions to reduce TLBs.
-	 * Pass the translated pa to PteUpdate.
+	 * Pass the translated pa to pte_update.
 	 */
 	if ((attrs & DSP_MAPPHYSICALADDR)) {
-		status = PteUpdate(pDevContext, ulMpuAddr, ulVirtAddr,
-			 ulNumBytes, &hwAttrs);
+		status = pte_update(dev_context, ul_mpu_addr, ulVirtAddr,
+				    ul_num_bytes, &hw_attrs);
 		goto func_cont;
 	}
 
 	/*
-	 * Important Note: ulMpuAddr is mapped from user application process
+	 * Important Note: ul_mpu_addr is mapped from user application process
 	 * to current process - it must lie completely within the current
 	 * virtual memory address space in order to be of use to us here!
 	 */
 	down_read(&mm->mmap_sem);
-	vma = find_vma(mm, ulMpuAddr);
+	vma = find_vma(mm, ul_mpu_addr);
 	if (vma)
-		DBG_Trace(DBG_LEVEL6, "VMAfor UserBuf: ulMpuAddr=%x, "
-			"ulNumBytes=%x, vm_start=%x vm_end=%x vm_flags=%x \n",
-			ulMpuAddr, ulNumBytes, vma->vm_start,
-			vma->vm_end, vma->vm_flags);
+		dev_dbg(bridge,
+			"VMAfor UserBuf: ul_mpu_addr=%x, ul_num_bytes=%x, "
+			"vm_start=%lx, vm_end=%lx, vm_flags=%lx\n", ul_mpu_addr,
+			ul_num_bytes, vma->vm_start, vma->vm_end,
+			vma->vm_flags);
 
 	/*
 	 * It is observed that under some circumstances, the user buffer is
 	 * spread across several VMAs. So loop through and check if the entire
 	 * user buffer is covered
 	 */
-	while ((vma) && (ulMpuAddr + ulNumBytes > vma->vm_end)) {
+	while ((vma) && (ul_mpu_addr + ul_num_bytes > vma->vm_end)) {
 		/* jump to the next VMA region */
 		vma = find_vma(mm, vma->vm_end + 1);
-		DBG_Trace(DBG_LEVEL6, "VMAfor UserBuf ulMpuAddr=%x, "
-		       "ulNumBytes=%x, vm_start=%x vm_end=%x vm_flags=%x\n",
-		       ulMpuAddr, ulNumBytes, vma->vm_start,
-		       vma->vm_end, vma->vm_flags);
+		dev_dbg(bridge,
+			"VMA for UserBuf ul_mpu_addr=%x ul_num_bytes=%x, "
+			"vm_start=%lx, vm_end=%lx, vm_flags=%lx\n", ul_mpu_addr,
+			ul_num_bytes, vma->vm_start, vma->vm_end,
+			vma->vm_flags);
 	}
 	if (!vma) {
-		DBG_Trace(DBG_LEVEL7, "Failed to get the VMA region for "
-			  "MPU Buffer !!! \n");
+		pr_err("%s: Failed to get VMA region for 0x%x (%d)\n",
+		       __func__, ul_mpu_addr, ul_num_bytes);
 		status = DSP_EINVALIDARG;
 		up_read(&mm->mmap_sem);
 		goto func_cont;
 	}
 
-	numUsrPgs =  PAGE_ALIGN(ulNumBytes) / PG_SIZE_4K;
-
-	DBG_Trace(DBG_LEVEL4, "%s :numOfActualTabEntries=%d, ulNumBytes= %d\n",
-		  %s, numUsrPgs, ulNumBytes);
-
-	if (vma->vm_flags & (VM_IO | VM_PFNMAP | VM_RESERVED)) {
-		for (nr_pages = numUsrPgs; nr_pages > 0;) {
-			u32 pa;
-
-			pa = user_va2pa(mm, ulMpuAddr);
+	if (vma->vm_flags & VM_IO) {
+		num_usr_pgs = ul_num_bytes / PG_SIZE4K;
+		mpu_addr = ul_mpu_addr;
+
+		/* Get the physical addresses for user buffer */
+		for (pg_i = 0; pg_i < num_usr_pgs; pg_i++) {
+			pa = user_va2_pa(mm, mpu_addr);
 			if (!pa) {
 				status = DSP_EFAIL;
 				pr_err("DSPBRIDGE: VM_IO mapping physical"
 				       "address is invalid\n");
 				break;
 			}
-
-			status = PteSet(pDevContext->pPtAttrs, pa,
-					va, HW_PAGE_SIZE_4KB, &hwAttrs);
-			if (DSP_FAILED(status)) {
-				DBG_Trace(DBG_LEVEL7,
-					  "WMD_BRD_MemMap: FAILED IN VM_IO"
-					  "PTESET \n");
-				break;
+			if (pfn_valid(__phys_to_pfn(pa))) {
+				pg = PHYS_TO_PAGE(pa);
+				get_page(pg);
+				if (page_count(pg) < 1) {
+					pr_err("Bad page in VM_IO buffer\n");
+					bad_page_dump(pa, pg);
+				}
 			}
+			status = pte_set(dev_context->pt_attrs, pa,
+					 va, HW_PAGE_SIZE4KB, &hw_attrs);
+			if (DSP_FAILED(status))
+				break;
 
-			va += HW_PAGE_SIZE_4KB;
-			ulMpuAddr += HW_PAGE_SIZE_4KB;
-			nr_pages--;
+			va += HW_PAGE_SIZE4KB;
+			mpu_addr += HW_PAGE_SIZE4KB;
+			pa += HW_PAGE_SIZE4KB;
 		}
 	} else {
-		int write = 0;
-
+		num_usr_pgs = ul_num_bytes / PG_SIZE4K;
 		if (vma->vm_flags & (VM_WRITE | VM_MAYWRITE))
 			write = 1;
 
-		for (nr_pages = numUsrPgs; nr_pages > 0;) {
-			int i, ret;
-			struct page *pages[16]; /* for a reasonable batch */
-
-			ret = get_user_pages(current, mm, ulMpuAddr,
-					     min_t(int,  nr_pages, ARRAY_SIZE(pages)),
-					     write, 1, pages, NULL);
-			if (ret <= 0) {
+		for (pg_i = 0; pg_i < num_usr_pgs; pg_i++) {
+			pg_num = get_user_pages(curr_task, mm, ul_mpu_addr, 1,
+						write, 1, &mapped_page, NULL);
+			if (pg_num > 0) {
+				if (page_count(mapped_page) < 1) {
+					pr_err("Bad page count after doing"
+					       "get_user_pages on"
+					       "user buffer\n");
+					bad_page_dump(page_to_phys(mapped_page),
+						      mapped_page);
+				}
+				status = pte_set(dev_context->pt_attrs,
+						 page_to_phys(mapped_page), va,
+						 HW_PAGE_SIZE4KB, &hw_attrs);
+				if (DSP_FAILED(status))
+					break;
+
+				va += HW_PAGE_SIZE4KB;
+				ul_mpu_addr += HW_PAGE_SIZE4KB;
+			} else {
 				pr_err("DSPBRIDGE: get_user_pages FAILED,"
 				       "MPU addr = 0x%x,"
 				       "vma->vm_flags = 0x%lx,"
-				       "get_user_pages ErrValue = %d,"
-				       "Buffersize=0x%x\n",
-				       ulMpuAddr, vma->vm_flags, ret,
-				       ulNumBytes);
+				       "get_user_pages Err"
+				       "Value = %d, Buffer"
+				       "size=0x%x\n", ul_mpu_addr,
+				       vma->vm_flags, pg_num, ul_num_bytes);
 				status = DSP_EFAIL;
-				goto fail_mapping;
-			}
-
-			for (i = 0; i < ret; i++) {
-				struct page *page = pages[i];
-
-				status = PteSet(pDevContext->pPtAttrs,
-						page_to_phys(page), va,
-						HW_PAGE_SIZE_4KB, &hwAttrs);
-				if (DSP_FAILED(status)) {
-					pr_err("%s: FAILED IN PTESET\n",
-					       __func__);
-					goto fail_mapping;
-				}
-				SetPageMlocked(page);
-				va += HW_PAGE_SIZE_4KB;
-				ulMpuAddr += HW_PAGE_SIZE_4KB;
-				nr_pages--;
+				break;
 			}
 		}
 	}
-
-fail_mapping:
 	up_read(&mm->mmap_sem);
 func_cont:
 	/* Don't propogate Linux or HW status to upper layers */
 	if (DSP_SUCCEEDED(status)) {
 		status = DSP_SOK;
 	} else {
-		DBG_Trace(DBG_LEVEL7, "< WMD_BRD_MemMap status %x\n", status);
 		/*
 		 * Roll out the mapped pages incase it failed in middle of
 		 * mapping
 		 */
-		if (numUsrPgs - nr_pages) {
-			WMD_BRD_MemUnMap(pDevContext, ulVirtAddr,
-					 ((numUsrPgs - nr_pages) * PG_SIZE_4K));
+		if (pg_i) {
+			bridge_brd_mem_un_map(dev_context, ulVirtAddr,
+					   (pg_i * PG_SIZE4K));
 		}
 		status = DSP_EFAIL;
 	}
 	/*
 	 * In any case, flush the TLB
-	 * This is called from here instead from PteUpdate to avoid unnecessary
+	 * This is called from here instead from pte_update to avoid unnecessary
 	 * repetition while mapping non-contiguous physical regions of a virtual
 	 * region
 	 */
-	flush_all(pDevContext);
-	DBG_Trace(DBG_ENTER, "< WMD_BRD_MemMap status %x\n", status);
+	flush_all(dev_context);
+	dev_dbg(bridge, "%s status %x\n", __func__, status);
 	return status;
 }
 
 /*
- *  ======== WMD_BRD_MemUnMap ========
+ *  ======== bridge_brd_mem_un_map ========
  *      Invalidate the PTEs for the DSP VA block to be unmapped.
  *
  *      PTEs of a mapped memory block are contiguous in any page table
  *      So, instead of looking up the PTE address for every 4K block,
  *      we clear consecutive PTEs until we unmap all the bytes
  */
-static DSP_STATUS WMD_BRD_MemUnMap(struct WMD_DEV_CONTEXT *hDevContext,
-				   u32 ulVirtAddr, u32 ulNumBytes)
+static dsp_status bridge_brd_mem_un_map(struct wmd_dev_context *hDevContext,
+				     u32 ulVirtAddr, u32 ul_num_bytes)
 {
-	u32 L1BaseVa;
-	u32 L2BaseVa;
-	u32 L2BasePa;
-	u32 L2PageNum;
-	u32 pteVal;
-	u32 pteSize;
-	u32 pteCount;
-	u32 pteAddrL1;
-	u32 pteAddrL2 = 0;
-	u32 remBytes;
-	u32 remBytesL2;
-	u32 vaCurr;
+	u32 l1_base_va;
+	u32 l2_base_va;
+	u32 l2_base_pa;
+	u32 l2_page_num;
+	u32 pte_val;
+	u32 pte_size;
+	u32 pte_count;
+	u32 pte_addr_l1;
+	u32 pte_addr_l2 = 0;
+	u32 rem_bytes;
+	u32 rem_bytes_l2;
+	u32 va_curr;
 	struct page *pg = NULL;
-	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	struct PgTableAttrs *pt = pDevContext->pPtAttrs;
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
+	struct pg_table_attrs *pt = dev_context->pt_attrs;
 	u32 temp;
-	u32 pAddr;
-	u32 numof4KPages = 0;
+	u32 paddr;
+	u32 numof4k_pages = 0;
+
+	va_curr = ulVirtAddr;
+	rem_bytes = ul_num_bytes;
+	rem_bytes_l2 = 0;
+	l1_base_va = pt->l1_base_va;
+	pte_addr_l1 = hw_mmu_pte_addr_l1(l1_base_va, va_curr);
+	dev_dbg(bridge, "%s hDevContext %p, va %x, NumBytes %x l1_base_va %x, "
+		"pte_addr_l1 %x\n", __func__, hDevContext, ulVirtAddr,
+		ul_num_bytes, l1_base_va, pte_addr_l1);
 
-	DBG_Trace(DBG_ENTER, "> WMD_BRD_MemUnMap hDevContext %x, va %x, "
-		  "NumBytes %x\n", hDevContext, ulVirtAddr, ulNumBytes);
-	vaCurr = ulVirtAddr;
-	remBytes = ulNumBytes;
-	remBytesL2 = 0;
-	L1BaseVa = pt->L1BaseVa;
-	pteAddrL1 = HW_MMU_PteAddrL1(L1BaseVa, vaCurr);
-	DBG_Trace(DBG_ENTER, "WMD_BRD_MemUnMap L1BaseVa %x, pteAddrL1 %x "
-		  "vaCurr %x remBytes %x\n", L1BaseVa, pteAddrL1,
-		  vaCurr, remBytes);
-	while (remBytes && (DSP_SUCCEEDED(status))) {
-		u32 vaCurrOrig = vaCurr;
+	while (rem_bytes && (DSP_SUCCEEDED(status))) {
+		u32 va_curr_orig = va_curr;
 		/* Find whether the L1 PTE points to a valid L2 PT */
-		pteAddrL1 = HW_MMU_PteAddrL1(L1BaseVa, vaCurr);
-		pteVal = *(u32 *)pteAddrL1;
-		pteSize = HW_MMU_PteSizeL1(pteVal);
+		pte_addr_l1 = hw_mmu_pte_addr_l1(l1_base_va, va_curr);
+		pte_val = *(u32 *) pte_addr_l1;
+		pte_size = hw_mmu_pte_size_l1(pte_val);
 
-		if (pteSize != HW_MMU_COARSE_PAGE_SIZE)
+		if (pte_size != HW_MMU_COARSE_PAGE_SIZE)
 			goto skip_coarse_page;
 
 		/*
 		 * Get the L2 PA from the L1 PTE, and find
 		 * corresponding L2 VA
 		 */
-		L2BasePa = HW_MMU_PteCoarseL1(pteVal);
-		L2BaseVa = L2BasePa - pt->L2BasePa + pt->L2BaseVa;
-		L2PageNum = (L2BasePa - pt->L2BasePa) / HW_MMU_COARSE_PAGE_SIZE;
+		l2_base_pa = hw_mmu_pte_coarse_l1(pte_val);
+		l2_base_va = l2_base_pa - pt->l2_base_pa + pt->l2_base_va;
+		l2_page_num =
+		    (l2_base_pa - pt->l2_base_pa) / HW_MMU_COARSE_PAGE_SIZE;
 		/*
 		 * Find the L2 PTE address from which we will start
 		 * clearing, the number of PTEs to be cleared on this
 		 * page, and the size of VA space that needs to be
 		 * cleared on this L2 page
 		 */
-		pteAddrL2 = HW_MMU_PteAddrL2(L2BaseVa, vaCurr);
-		pteCount = pteAddrL2 & (HW_MMU_COARSE_PAGE_SIZE - 1);
-		pteCount = (HW_MMU_COARSE_PAGE_SIZE - pteCount) / sizeof(u32);
-		if (remBytes < (pteCount * PG_SIZE_4K))
-			pteCount = remBytes / PG_SIZE_4K;
-		remBytesL2 = pteCount * PG_SIZE_4K;
-		DBG_Trace(DBG_LEVEL1, "WMD_BRD_MemUnMap L2BasePa %x, "
-			  "L2BaseVa %x pteAddrL2 %x, remBytesL2 %x\n",
-			  L2BasePa, L2BaseVa, pteAddrL2, remBytesL2);
+		pte_addr_l2 = hw_mmu_pte_addr_l2(l2_base_va, va_curr);
+		pte_count = pte_addr_l2 & (HW_MMU_COARSE_PAGE_SIZE - 1);
+		pte_count = (HW_MMU_COARSE_PAGE_SIZE - pte_count) / sizeof(u32);
+		if (rem_bytes < (pte_count * PG_SIZE4K))
+			pte_count = rem_bytes / PG_SIZE4K;
+		rem_bytes_l2 = pte_count * PG_SIZE4K;
+
 		/*
 		 * Unmap the VA space on this L2 PT. A quicker way
-		 * would be to clear pteCount entries starting from
-		 * pteAddrL2. However, below code checks that we don't
+		 * would be to clear pte_count entries starting from
+		 * pte_addr_l2. However, below code checks that we don't
 		 * clear invalid entries or less than 64KB for a 64KB
 		 * entry. Similar checking is done for L1 PTEs too
 		 * below
 		 */
-		while (remBytesL2 && (DSP_SUCCEEDED(status))) {
-			pteVal = *(u32 *)pteAddrL2;
-			pteSize = HW_MMU_PteSizeL2(pteVal);
-			/* vaCurr aligned to pteSize? */
-			if (pteSize == 0 || remBytesL2 < pteSize ||
-						vaCurr & (pteSize - 1)) {
+		while (rem_bytes_l2 && (DSP_SUCCEEDED(status))) {
+			pte_val = *(u32 *) pte_addr_l2;
+			pte_size = hw_mmu_pte_size_l2(pte_val);
+			/* va_curr aligned to pte_size? */
+			if (pte_size == 0 || rem_bytes_l2 < pte_size ||
+			    va_curr & (pte_size - 1)) {
 				status = DSP_EFAIL;
 				break;
 			}
 
 			/* Collect Physical addresses from VA */
-			pAddr = (pteVal & ~(pteSize - 1));
-			if (pteSize == HW_PAGE_SIZE_64KB)
-				numof4KPages = 16;
+			paddr = (pte_val & ~(pte_size - 1));
+			if (pte_size == HW_PAGE_SIZE64KB)
+				numof4k_pages = 16;
 			else
-				numof4KPages = 1;
+				numof4k_pages = 1;
 			temp = 0;
-			while (temp++ < numof4KPages) {
-				if (!pfn_valid(__phys_to_pfn(pAddr))) {
-					pAddr += HW_PAGE_SIZE_4KB;
+			while (temp++ < numof4k_pages) {
+				if (!pfn_valid(__phys_to_pfn(paddr))) {
+					paddr += HW_PAGE_SIZE4KB;
 					continue;
 				}
-				pg = phys_to_page(pAddr);
+				pg = PHYS_TO_PAGE(paddr);
 				if (page_count(pg) < 1) {
 					pr_info("DSPBRIDGE: UNMAP function: "
 						"COUNT 0 FOR PA 0x%x, size = "
-						"0x%x\n", pAddr, ulNumBytes);
-					bad_page_dump(pAddr, pg);
+						"0x%x\n", paddr, ul_num_bytes);
+					bad_page_dump(paddr, pg);
+				} else {
+					SetPageDirty(pg);
+					page_cache_release(pg);
 				}
-				ClearPageMlocked(pg);
-				SetPageDirty(pg);
-				page_cache_release(pg);
-				pAddr += HW_PAGE_SIZE_4KB;
+				paddr += HW_PAGE_SIZE4KB;
 			}
-			if (HW_MMU_PteClear(pteAddrL2, vaCurr, pteSize)
-							 == RET_FAIL) {
+			if (hw_mmu_pte_clear(pte_addr_l2, va_curr, pte_size)
+			    == RET_FAIL) {
 				status = DSP_EFAIL;
 				goto EXIT_LOOP;
 			}
 
 			status = DSP_SOK;
-			remBytesL2 -= pteSize;
-			vaCurr += pteSize;
-			pteAddrL2 += (pteSize >> 12) * sizeof(u32);
-		}
-		SYNC_EnterCS(pt->hCSObj);
-		if (remBytesL2 == 0) {
-			pt->pgInfo[L2PageNum].numEntries -= pteCount;
-			if (pt->pgInfo[L2PageNum].numEntries == 0) {
+			rem_bytes_l2 -= pte_size;
+			va_curr += pte_size;
+			pte_addr_l2 += (pte_size >> 12) * sizeof(u32);
+		}
+		sync_enter_cs(pt->hcs_obj);
+		if (rem_bytes_l2 == 0) {
+			pt->pg_info[l2_page_num].num_entries -= pte_count;
+			if (pt->pg_info[l2_page_num].num_entries == 0) {
 				/*
 				 * Clear the L1 PTE pointing to the L2 PT
 				 */
-				if (HW_MMU_PteClear(L1BaseVa, vaCurrOrig,
-					    HW_MMU_COARSE_PAGE_SIZE) == RET_OK)
+				if (hw_mmu_pte_clear(l1_base_va, va_curr_orig,
+						     HW_MMU_COARSE_PAGE_SIZE) ==
+				    RET_OK)
 					status = DSP_SOK;
 				else {
 					status = DSP_EFAIL;
-					SYNC_LeaveCS(pt->hCSObj);
+					sync_leave_cs(pt->hcs_obj);
 					goto EXIT_LOOP;
 				}
 			}
-			remBytes -= pteCount * PG_SIZE_4K;
+			rem_bytes -= pte_count * PG_SIZE4K;
 		} else
 			status = DSP_EFAIL;
-		DBG_Trace(DBG_LEVEL1, "WMD_BRD_MemUnMap L2PageNum %x, "
-			  "numEntries %x, pteCount %x, status: 0x%x\n",
-			  L2PageNum, pt->pgInfo[L2PageNum].numEntries,
-			  pteCount, status);
-		SYNC_LeaveCS(pt->hCSObj);
+
+		sync_leave_cs(pt->hcs_obj);
 		continue;
 skip_coarse_page:
-		/* vaCurr aligned to pteSize? */
-		/* pteSize = 1 MB or 16 MB */
-		if (pteSize == 0 || remBytes < pteSize ||
-						 vaCurr & (pteSize - 1)) {
+		/* va_curr aligned to pte_size? */
+		/* pte_size = 1 MB or 16 MB */
+		if (pte_size == 0 || rem_bytes < pte_size ||
+		    va_curr & (pte_size - 1)) {
 			status = DSP_EFAIL;
 			break;
 		}
 
-		if (pteSize == HW_PAGE_SIZE_1MB)
-			numof4KPages = 256;
+		if (pte_size == HW_PAGE_SIZE1MB)
+			numof4k_pages = 256;
 		else
-			numof4KPages = 4096;
+			numof4k_pages = 4096;
 		temp = 0;
 		/* Collect Physical addresses from VA */
-		pAddr = (pteVal & ~(pteSize - 1));
-		while (temp++ < numof4KPages) {
-			if (pfn_valid(__phys_to_pfn(pAddr))) {
-				pg = phys_to_page(pAddr);
+		paddr = (pte_val & ~(pte_size - 1));
+		while (temp++ < numof4k_pages) {
+			if (pfn_valid(__phys_to_pfn(paddr))) {
+				pg = PHYS_TO_PAGE(paddr);
 				if (page_count(pg) < 1) {
 					pr_info("DSPBRIDGE: UNMAP function: "
 						"COUNT 0 FOR PA 0x%x, size = "
-						"0x%x\n", pAddr, ulNumBytes);
-					bad_page_dump(pAddr, pg);
+						"0x%x\n", paddr, ul_num_bytes);
+					bad_page_dump(paddr, pg);
+				} else {
+					SetPageDirty(pg);
+					page_cache_release(pg);
 				}
-				ClearPageMlocked(pg);
-				SetPageDirty(pg);
-				page_cache_release(pg);
 			}
-			pAddr += HW_PAGE_SIZE_4KB;
+			paddr += HW_PAGE_SIZE4KB;
 		}
-		if (HW_MMU_PteClear(L1BaseVa, vaCurr, pteSize) == RET_OK) {
+		if (hw_mmu_pte_clear(l1_base_va, va_curr, pte_size) == RET_OK) {
 			status = DSP_SOK;
-			remBytes -= pteSize;
-			vaCurr += pteSize;
+			rem_bytes -= pte_size;
+			va_curr += pte_size;
 		} else {
 			status = DSP_EFAIL;
 			goto EXIT_LOOP;
@@ -1779,21 +1689,21 @@
 	 * get flushed
 	 */
 EXIT_LOOP:
-	flush_all(pDevContext);
-	DBG_Trace(DBG_LEVEL1, "WMD_BRD_MemUnMap vaCurr %x, pteAddrL1 %x "
-		  "pteAddrL2 %x\n", vaCurr, pteAddrL1, pteAddrL2);
-	DBG_Trace(DBG_ENTER, "< WMD_BRD_MemUnMap status %x remBytes %x, "
-		  "remBytesL2 %x\n", status, remBytes, remBytesL2);
+	flush_all(dev_context);
+	dev_dbg(bridge,
+		"%s: va_curr %x, pte_addr_l1 %x pte_addr_l2 %x rem_bytes %x,"
+		" rem_bytes_l2 %x status %x\n", __func__, va_curr, pte_addr_l1,
+		pte_addr_l2, rem_bytes, rem_bytes_l2, status);
 	return status;
 }
 
 /*
- *  ======== user_va2pa ========
+ *  ======== user_va2_pa ========
  *  Purpose:
  *      This function walks through the Linux page tables to convert a userland
  *      virtual address to physical address
  */
-static u32 user_va2pa(struct mm_struct *mm, u32 address)
+static u32 user_va2_pa(struct mm_struct *mm, u32 address)
 {
 	pgd_t *pgd;
 	pmd_t *pmd;
@@ -1815,113 +1725,115 @@
 	return 0;
 }
 
-
 /*
- *  ======== PteUpdate ========
+ *  ======== pte_update ========
  *      This function calculates the optimum page-aligned addresses and sizes
  *      Caller must pass page-aligned values
  */
-static DSP_STATUS PteUpdate(struct WMD_DEV_CONTEXT *hDevContext, u32 pa,
-			    u32 va, u32 size,
-			    struct HW_MMUMapAttrs_t *mapAttrs)
+static dsp_status pte_update(struct wmd_dev_context *hDevContext, u32 pa,
+			     u32 va, u32 size,
+			     struct hw_mmu_map_attrs_t *map_attrs)
 {
 	u32 i;
-	u32 allBits;
-	u32 paCurr = pa;
-	u32 vaCurr = va;
-	u32 numBytes = size;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	DSP_STATUS status = DSP_SOK;
-	u32 pgSize[] = { HW_PAGE_SIZE_16MB, HW_PAGE_SIZE_1MB,
-			   HW_PAGE_SIZE_64KB, HW_PAGE_SIZE_4KB };
-	DBG_Trace(DBG_ENTER, "> PteUpdate hDevContext %x, pa %x, va %x, "
-		 "size %x, mapAttrs %x\n", hDevContext, pa, va, size, mapAttrs);
-	while (numBytes && DSP_SUCCEEDED(status)) {
+	u32 all_bits;
+	u32 pa_curr = pa;
+	u32 va_curr = va;
+	u32 num_bytes = size;
+	struct wmd_dev_context *dev_context = hDevContext;
+	dsp_status status = DSP_SOK;
+	u32 page_size[] = { HW_PAGE_SIZE16MB, HW_PAGE_SIZE1MB,
+		HW_PAGE_SIZE64KB, HW_PAGE_SIZE4KB
+	};
+
+	while (num_bytes && DSP_SUCCEEDED(status)) {
 		/* To find the max. page size with which both PA & VA are
 		 * aligned */
-		allBits = paCurr | vaCurr;
-		DBG_Trace(DBG_LEVEL1, "allBits %x, paCurr %x, vaCurr %x, "
-			 "numBytes %x ", allBits, paCurr, vaCurr, numBytes);
+		all_bits = pa_curr | va_curr;
+
 		for (i = 0; i < 4; i++) {
-			if ((numBytes >= pgSize[i]) && ((allBits &
-			   (pgSize[i] - 1)) == 0)) {
-				DBG_Trace(DBG_LEVEL1, "pgSize %x\n", pgSize[i]);
-				status = PteSet(pDevContext->pPtAttrs, paCurr,
-						vaCurr, pgSize[i], mapAttrs);
-				paCurr += pgSize[i];
-				vaCurr += pgSize[i];
-				numBytes -= pgSize[i];
-				 /* Don't try smaller sizes. Hopefully we have
+			if ((num_bytes >= page_size[i]) && ((all_bits &
+							     (page_size[i] -
+							      1)) == 0)) {
+				status =
+				    pte_set(dev_context->pt_attrs, pa_curr,
+					    va_curr, page_size[i], map_attrs);
+				pa_curr += page_size[i];
+				va_curr += page_size[i];
+				num_bytes -= page_size[i];
+				/* Don't try smaller sizes. Hopefully we have
 				 * reached an address aligned to a bigger page
 				 * size */
 				break;
 			}
 		}
 	}
-	DBG_Trace(DBG_ENTER, "< PteUpdate status %x numBytes %x\n", status,
-		  numBytes);
+
 	return status;
 }
 
 /*
- *  ======== PteSet ========
+ *  ======== pte_set ========
  *      This function calculates PTE address (MPU virtual) to be updated
  *      It also manages the L2 page tables
  */
-static DSP_STATUS PteSet(struct PgTableAttrs *pt, u32 pa, u32 va,
-			 u32 size, struct HW_MMUMapAttrs_t *attrs)
+static dsp_status pte_set(struct pg_table_attrs *pt, u32 pa, u32 va,
+			  u32 size, struct hw_mmu_map_attrs_t *attrs)
 {
 	u32 i;
-	u32 pteVal;
-	u32 pteAddrL1;
-	u32 pteSize;
-	u32 pgTblVa;      /* Base address of the PT that will be updated */
-	u32 L1BaseVa;
+	u32 pte_val;
+	u32 pte_addr_l1;
+	u32 pte_size;
+	/* Base address of the PT that will be updated */
+	u32 pg_tbl_va;
+	u32 l1_base_va;
 	/* Compiler warns that the next three variables might be used
 	 * uninitialized in this function. Doesn't seem so. Working around,
-	 * anyways.  */
-	u32 L2BaseVa = 0;
-	u32 L2BasePa = 0;
-	u32 L2PageNum = 0;
-	DSP_STATUS status = DSP_SOK;
-	DBG_Trace(DBG_ENTER, "> PteSet pPgTableAttrs %x, pa %x, va %x, "
-		 "size %x, attrs %x\n", pt, pa, va, size, attrs);
-	L1BaseVa = pt->L1BaseVa;
-	pgTblVa = L1BaseVa;
-	if ((size == HW_PAGE_SIZE_64KB) || (size == HW_PAGE_SIZE_4KB)) {
+	 * anyways. */
+	u32 l2_base_va = 0;
+	u32 l2_base_pa = 0;
+	u32 l2_page_num = 0;
+	dsp_status status = DSP_SOK;
+
+	l1_base_va = pt->l1_base_va;
+	pg_tbl_va = l1_base_va;
+	if ((size == HW_PAGE_SIZE64KB) || (size == HW_PAGE_SIZE4KB)) {
 		/* Find whether the L1 PTE points to a valid L2 PT */
-		pteAddrL1 = HW_MMU_PteAddrL1(L1BaseVa, va);
-		if (pteAddrL1 <= (pt->L1BaseVa + pt->L1size)) {
-			pteVal = *(u32 *)pteAddrL1;
-			pteSize = HW_MMU_PteSizeL1(pteVal);
+		pte_addr_l1 = hw_mmu_pte_addr_l1(l1_base_va, va);
+		if (pte_addr_l1 <= (pt->l1_base_va + pt->l1_size)) {
+			pte_val = *(u32 *) pte_addr_l1;
+			pte_size = hw_mmu_pte_size_l1(pte_val);
 		} else {
 			return DSP_EFAIL;
 		}
-		SYNC_EnterCS(pt->hCSObj);
-		if (pteSize == HW_MMU_COARSE_PAGE_SIZE) {
+		sync_enter_cs(pt->hcs_obj);
+		if (pte_size == HW_MMU_COARSE_PAGE_SIZE) {
 			/* Get the L2 PA from the L1 PTE, and find
 			 * corresponding L2 VA */
-			L2BasePa = HW_MMU_PteCoarseL1(pteVal);
-			L2BaseVa = L2BasePa - pt->L2BasePa + pt->L2BaseVa;
-			L2PageNum = (L2BasePa - pt->L2BasePa) /
-				    HW_MMU_COARSE_PAGE_SIZE;
-		} else if (pteSize == 0) {
+			l2_base_pa = hw_mmu_pte_coarse_l1(pte_val);
+			l2_base_va =
+			    l2_base_pa - pt->l2_base_pa + pt->l2_base_va;
+			l2_page_num =
+			    (l2_base_pa -
+			     pt->l2_base_pa) / HW_MMU_COARSE_PAGE_SIZE;
+		} else if (pte_size == 0) {
 			/* L1 PTE is invalid. Allocate a L2 PT and
 			 * point the L1 PTE to it */
 			/* Find a free L2 PT. */
-			for (i = 0; (i < pt->L2NumPages) &&
-			    (pt->pgInfo[i].numEntries != 0); i++)
+			for (i = 0; (i < pt->l2_num_pages) &&
+			     (pt->pg_info[i].num_entries != 0); i++)
 				;;
-			if (i < pt->L2NumPages) {
-				L2PageNum = i;
-				L2BasePa = pt->L2BasePa + (L2PageNum *
-					   HW_MMU_COARSE_PAGE_SIZE);
-				L2BaseVa = pt->L2BaseVa + (L2PageNum *
-					   HW_MMU_COARSE_PAGE_SIZE);
+			if (i < pt->l2_num_pages) {
+				l2_page_num = i;
+				l2_base_pa = pt->l2_base_pa + (l2_page_num *
+						HW_MMU_COARSE_PAGE_SIZE);
+				l2_base_va = pt->l2_base_va + (l2_page_num *
+						HW_MMU_COARSE_PAGE_SIZE);
 				/* Endianness attributes are ignored for
 				 * HW_MMU_COARSE_PAGE_SIZE */
-				status = HW_MMU_PteSet(L1BaseVa, L2BasePa, va,
-					 HW_MMU_COARSE_PAGE_SIZE, attrs);
+				status =
+				    hw_mmu_pte_set(l1_base_va, l2_base_pa, va,
+						   HW_MMU_COARSE_PAGE_SIZE,
+						   attrs);
 			} else {
 				status = DSP_EMEMORY;
 			}
@@ -1931,160 +1843,152 @@
 			status = DSP_EFAIL;
 		}
 		if (DSP_SUCCEEDED(status)) {
-			pgTblVa = L2BaseVa;
-			if (size == HW_PAGE_SIZE_64KB)
-				pt->pgInfo[L2PageNum].numEntries += 16;
+			pg_tbl_va = l2_base_va;
+			if (size == HW_PAGE_SIZE64KB)
+				pt->pg_info[l2_page_num].num_entries += 16;
 			else
-				pt->pgInfo[L2PageNum].numEntries++;
-			DBG_Trace(DBG_LEVEL1, "L2 BaseVa %x, BasePa %x, "
-				 "PageNum %x numEntries %x\n", L2BaseVa,
-				 L2BasePa, L2PageNum,
-				 pt->pgInfo[L2PageNum].numEntries);
+				pt->pg_info[l2_page_num].num_entries++;
+			dev_dbg(bridge, "PTE: L2 BaseVa %x, BasePa %x, PageNum "
+				"%x, num_entries %x\n", l2_base_va,
+				l2_base_pa, l2_page_num,
+				pt->pg_info[l2_page_num].num_entries);
 		}
-		SYNC_LeaveCS(pt->hCSObj);
+		sync_leave_cs(pt->hcs_obj);
 	}
 	if (DSP_SUCCEEDED(status)) {
-		DBG_Trace(DBG_LEVEL1, "PTE pgTblVa %x, pa %x, va %x, size %x\n",
-			 pgTblVa, pa, va, size);
-		DBG_Trace(DBG_LEVEL1, "PTE endianism %x, elementSize %x, "
-			  "mixedSize %x\n", attrs->endianism,
-			  attrs->elementSize, attrs->mixedSize);
-		status = HW_MMU_PteSet(pgTblVa, pa, va, size, attrs);
+		dev_dbg(bridge, "PTE: pg_tbl_va %x, pa %x, va %x, size %x\n",
+			pg_tbl_va, pa, va, size);
+		dev_dbg(bridge, "PTE: endianism %x, element_size %x, "
+			"mixed_size %x\n", attrs->endianism,
+			attrs->element_size, attrs->mixed_size);
+		status = hw_mmu_pte_set(pg_tbl_va, pa, va, size, attrs);
 	}
-	DBG_Trace(DBG_ENTER, "< PteSet status %x\n", status);
+
 	return status;
 }
 
 /* Memory map kernel VA -- memory allocated with vmalloc */
-static DSP_STATUS MemMapVmalloc(struct WMD_DEV_CONTEXT *pDevContext,
-				u32 ulMpuAddr, u32 ulVirtAddr, u32 ulNumBytes,
-				struct HW_MMUMapAttrs_t *hwAttrs)
+static dsp_status mem_map_vmalloc(struct wmd_dev_context *dev_context,
+				  u32 ul_mpu_addr, u32 ulVirtAddr,
+				  u32 ul_num_bytes,
+				  struct hw_mmu_map_attrs_t *hw_attrs)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct page *pPage[1];
+	dsp_status status = DSP_SOK;
+	struct page *page[1];
 	u32 i;
-	u32 paCurr;
-	u32 paNext;
-	u32 vaCurr;
-	u32 sizeCurr;
-	u32 numPages;
+	u32 pa_curr;
+	u32 pa_next;
+	u32 va_curr;
+	u32 size_curr;
+	u32 num_pages;
 	u32 pa;
-	u32 numOf4KPages;
+	u32 num_of4k_pages;
 	u32 temp = 0;
 
-	DBG_Trace(DBG_ENTER, "> MemMapVmalloc hDevContext %x, pa %x, va %x, "
-		  "size %x\n", pDevContext, ulMpuAddr, ulVirtAddr, ulNumBytes);
-
 	/*
 	 * Do Kernel va to pa translation.
 	 * Combine physically contiguous regions to reduce TLBs.
-	 * Pass the translated pa to PteUpdate.
+	 * Pass the translated pa to pte_update.
 	 */
-	numPages = ulNumBytes / PAGE_SIZE; /* PAGE_SIZE = OS page size */
+	num_pages = ul_num_bytes / PAGE_SIZE;	/* PAGE_SIZE = OS page size */
 	i = 0;
-	vaCurr = ulMpuAddr;
-	pPage[0] = vmalloc_to_page((void *)vaCurr);
-	paNext = page_to_phys(pPage[0]);
-	while (DSP_SUCCEEDED(status) && (i < numPages)) {
+	va_curr = ul_mpu_addr;
+	page[0] = vmalloc_to_page((void *)va_curr);
+	pa_next = page_to_phys(page[0]);
+	while (DSP_SUCCEEDED(status) && (i < num_pages)) {
 		/*
-		 * Reuse paNext from the previous iteraion to avoid
+		 * Reuse pa_next from the previous iteraion to avoid
 		 * an extra va2pa call
 		 */
-		paCurr = paNext;
-		sizeCurr = PAGE_SIZE;
+		pa_curr = pa_next;
+		size_curr = PAGE_SIZE;
 		/*
 		 * If the next page is physically contiguous,
 		 * map it with the current one by increasing
 		 * the size of the region to be mapped
 		 */
-		while (++i < numPages) {
-			pPage[0] = vmalloc_to_page((void *)(vaCurr + sizeCurr));
-			paNext = page_to_phys(pPage[0]);
-			DBG_Trace(DBG_LEVEL5, "Xlate Vmalloc VA=0x%x , "
-				 "PA=0x%x \n", (vaCurr + sizeCurr), paNext);
-			if (paNext == (paCurr + sizeCurr))
-				sizeCurr += PAGE_SIZE;
+		while (++i < num_pages) {
+			page[0] =
+			    vmalloc_to_page((void *)(va_curr + size_curr));
+			pa_next = page_to_phys(page[0]);
+
+			if (pa_next == (pa_curr + size_curr))
+				size_curr += PAGE_SIZE;
 			else
 				break;
 
 		}
-		if (paNext == 0) {
+		if (pa_next == 0) {
 			status = DSP_EMEMORY;
 			break;
 		}
-		pa = paCurr;
-		numOf4KPages = sizeCurr / HW_PAGE_SIZE_4KB;
-		while (temp++ < numOf4KPages) {
-			get_page(phys_to_page(pa));
-			pa += HW_PAGE_SIZE_4KB;
-		}
-		status = PteUpdate(pDevContext, paCurr, ulVirtAddr +
-				  (vaCurr - ulMpuAddr), sizeCurr, hwAttrs);
-		vaCurr += sizeCurr;
+		pa = pa_curr;
+		num_of4k_pages = size_curr / HW_PAGE_SIZE4KB;
+		while (temp++ < num_of4k_pages) {
+			get_page(PHYS_TO_PAGE(pa));
+			pa += HW_PAGE_SIZE4KB;
+		}
+		status = pte_update(dev_context, pa_curr, ulVirtAddr +
+				    (va_curr - ul_mpu_addr), size_curr,
+				    hw_attrs);
+		va_curr += size_curr;
 	}
 	/* Don't propogate Linux or HW status to upper layers */
-	if (DSP_SUCCEEDED(status)) {
+	if (DSP_SUCCEEDED(status))
 		status = DSP_SOK;
-		DBG_Trace(DBG_LEVEL7, "< WMD_BRD_MemMap succeeded %x\n",
-			 status);
-	} else {
-		DBG_Trace(DBG_LEVEL7, "< WMD_BRD_MemMap status %x\n", status);
+	else
 		status = DSP_EFAIL;
-	}
+
 	/*
 	 * In any case, flush the TLB
-	 * This is called from here instead from PteUpdate to avoid unnecessary
+	 * This is called from here instead from pte_update to avoid unnecessary
 	 * repetition while mapping non-contiguous physical regions of a virtual
 	 * region
 	 */
-	flush_all(pDevContext);
-	DBG_Trace(DBG_LEVEL7, "< WMD_BRD_MemMap at end status %x\n", status);
+	flush_all(dev_context);
+	dev_dbg(bridge, "%s status %x\n", __func__, status);
 	return status;
 }
 
 /*
- *  ======== configureDspMmu ========
+ *  ======== configure_dsp_mmu ========
  *      Make DSP MMU page table entries.
  */
-void configureDspMmu(struct WMD_DEV_CONTEXT *pDevContext, u32 dataBasePhys,
-		    u32 dspBaseVirt, u32 sizeInBytes, s32 nEntryStart,
-		    enum HW_Endianism_t endianism,
-		    enum HW_ElementSize_t elemSize,
-		    enum HW_MMUMixedSize_t mixedSize)
-{
-	struct CFG_HOSTRES resources;
-	struct HW_MMUMapAttrs_t mapAttrs = { endianism, elemSize, mixedSize };
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(sizeInBytes > 0);
-	DBG_Trace(DBG_LEVEL1,
-		 "configureDspMmu entry %x pa %x, va %x, bytes %x ",
-		 nEntryStart, dataBasePhys, dspBaseVirt, sizeInBytes);
-
-	DBG_Trace(DBG_LEVEL1, "endianism %x, elemSize %x, mixedSize %x\n",
-		 endianism, elemSize, mixedSize);
-	status = CFG_GetHostResources(
-		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
-	status = HW_MMU_TLBAdd(pDevContext->dwDSPMmuBase, dataBasePhys,
-				dspBaseVirt, sizeInBytes, nEntryStart,
-				&mapAttrs, HW_SET, HW_SET);
+void configure_dsp_mmu(struct wmd_dev_context *dev_context, u32 dataBasePhys,
+		       u32 dspBaseVirt, u32 sizeInBytes, s32 nEntryStart,
+		       enum hw_endianism_t endianism,
+		       enum hw_element_size_t elem_size,
+		       enum hw_mmu_mixed_size_t mixed_size)
+{
+	struct hw_mmu_map_attrs_t map_attrs = { endianism, elem_size,
+						mixed_size };
+
+	DBC_REQUIRE(sizeInBytes > 0);
+	dev_dbg(bridge, "%s: entry %x pa %x, va %x, bytes %x endianism %x, "
+		"elem_size %x, mixed_size %x", __func__, nEntryStart,
+		dataBasePhys, dspBaseVirt, sizeInBytes, endianism,
+		elem_size, mixed_size);
+
+	hw_mmu_tlb_add(dev_context->dw_dsp_mmu_base, dataBasePhys,
+		       dspBaseVirt, sizeInBytes, nEntryStart,
+		       &map_attrs, HW_SET, HW_SET);
 }
 
 /*
- *  ======== WaitForStart ========
+ *  ======== wait_for_start ========
  *      Wait for the singal from DSP that it has started, or time out.
  */
-bool WaitForStart(struct WMD_DEV_CONTEXT *pDevContext, u32 dwSyncAddr)
+bool wait_for_start(struct wmd_dev_context *dev_context, u32 dw_sync_addr)
 {
-	u16 usCount = TIHELEN_ACKTIMEOUT;
+	u16 timeout = TIHELEN_ACKTIMEOUT;
 
 	/*  Wait for response from board */
-	while (*((volatile u16 *)dwSyncAddr) && --usCount)
+	while (*((volatile u16 *)dw_sync_addr) && --timeout)
 		udelay(10);
 
 	/*  If timed out: return FALSE */
-	if (!usCount) {
-		DBG_Trace(DBG_LEVEL7, "Timed out Waiting for DSP to Start\n");
+	if (!timeout) {
+		pr_err("%s: Timed out waiting DSP to Start\n", __func__);
 		return FALSE;
 	}
 	return TRUE;
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/tiomap3430_pwr.c kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/tiomap3430_pwr.c	2011-10-11 13:51:02.421881294 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/tiomap3430_pwr.c	2011-10-29 20:31:41.353777000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implementation of DSP wake/sleep routines.
+ *
  * Copyright (C) 2007-2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,35 +16,15 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== _tiomap_pwr.c ========
- *  Description:
- *      Implementation of DSP wake/sleep routines.
- *
- *! Revision History
- *! ================
- *! 01-Nov-2007 HK: Added Off mode(Hibernation) support and DVFS support
- *! 05-Jan-2004 vp: Moved the file to platform specific folder and commented the
- *!		    code.
- *! 27-Mar-2003 vp: Added support for DSP boot idle mode.
- *! 06-Dec-2002 cring:  Added Palm support.
- *! 08-Oct-2002 rr:  Created.
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/dbdefs.h>
 #include <dspbridge/errbase.h>
 #include <dspbridge/cfg.h>
 #include <dspbridge/drv.h>
 #include <dspbridge/io_sm.h>
-#include <dspbridge/chnl_sm.h>
-
-/*  ----------------------------------- Trace & Debug */
-#include <dspbridge/dbg.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/mem.h>
-#include <dspbridge/util.h>
 
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/brddefs.h>
@@ -59,6 +41,10 @@
 
 /*  ----------------------------------- Mini Driver */
 #include <dspbridge/wmddeh.h>
+#include <dspbridge/wdt.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
 
 /*  ----------------------------------- specific to this file */
 #include "_tiomap.h"
@@ -66,374 +52,435 @@
 #include "_tiomap_util.h"
 #include <mach-omap2/prm-regbits-34xx.h>
 #include <mach-omap2/cm-regbits-34xx.h>
+#include "tiomap_io.h"
 
 #ifdef CONFIG_PM
-#include <mach/board-3430sdp.h>
+extern s32 dsp_test_sleepstate;
 #endif
-extern struct MAILBOX_CONTEXT mboxsetting;
-extern unsigned short enable_off_mode;
+extern struct mailbox_context mboxsetting;
 extern unsigned short min_active_opp;
+
+DEFINE_SPINLOCK(pwr_lock);
+
 /*
  *  ======== handle_constraints_set ========
  *  	Sets new DSP constraint
  */
-DSP_STATUS handle_constraints_set(struct WMD_DEV_CONTEXT *pDevContext,
-				  IN void *pArgs)
+dsp_status handle_constraints_set(struct wmd_dev_context *dev_context,
+				  IN void *pargs)
 {
 #ifdef CONFIG_BRIDGE_DVFS
-	u32 pConstraintVal;
-	DSP_STATUS status = DSP_SOK;
-	struct CFG_HOSTRES resources;
+	u32 *constraint_val;
 	struct dspbridge_platform_data *pdata =
-		omap_dspbridge_dev->dev.platform_data;
-	status = CFG_GetHostResources(
-		(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
-
-	pConstraintVal = *(((u32 *)pArgs) + 1);
-	/* Read the target value requested by DSP  */
-	DBG_Trace(DBG_LEVEL7, "handle_constraints_set:"
-		"opp requested = 0x%x\n", pConstraintVal);
-	status = HW_MBOX_saveSettings(resources.dwMboxBase);
+	    omap_dspbridge_dev->dev.platform_data;
+
+	constraint_val = (u32 *) (pargs);
+	/* Read the target value requested by DSP */
+	dev_dbg(bridge, "OPP: %s opp requested = 0x%x\n", __func__,
+		(u32) *(constraint_val + 1));
 
 	/* Set the new opp value */
-	if (pdata->dsp_set_min_opp) {
-		/*
-		 * When Smartreflex is ON, DSP requires at least OPP level 3
-		 * to operate reliably. So boost lower OPP levels to OPP3.
-		 */
-		if (pConstraintVal < min_active_opp) {
-			pr_debug("DSPBRIDGE: VDD1 OPP%x elevated to OPP%x\n",
-					pConstraintVal, min_active_opp);
+	if (pdata->dsp_set_min_opp)
+	{
+		if((u32) *(constraint_val + 1) > pdata->mpu_max_opp)
+			(*pdata->dsp_set_min_opp) (pdata->mpu_max_opp);
+		else if((u32) *(constraint_val + 1) < min_active_opp)
 			(*pdata->dsp_set_min_opp)(min_active_opp);
-		} else
-			(*pdata->dsp_set_min_opp)(pConstraintVal);
+		else
+			(*pdata->dsp_set_min_opp) ((u32) *(constraint_val + 1));
 	}
 #endif /* #ifdef CONFIG_BRIDGE_DVFS */
 	return DSP_SOK;
 }
 
 /*
- *  ======== handle_hibernation_fromDSP ========
- *  	Handle Hibernation requested from DSP
+ *  ======== handle_hibernation_from_dsp ========
+ *	Handle Hibernation requested from DSP
  */
-DSP_STATUS handle_hibernation_fromDSP(struct WMD_DEV_CONTEXT *pDevContext)
+dsp_status handle_hibernation_from_dsp(struct wmd_dev_context *dev_context)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 #ifdef CONFIG_PM
-	u16 usCount = TIHELEN_ACKTIMEOUT;
-	struct CFG_HOSTRES resources;
-	enum HW_PwrState_t pwrState;
+	u8 t;
+	unsigned long v;
+	struct cfg_hostres resources;
+	enum hw_pwr_state_t pwr_state;
 #ifdef CONFIG_BRIDGE_DVFS
 	u32 opplevel;
-	struct IO_MGR *hIOMgr;
+	struct io_mgr *hio_mgr;
 	struct dspbridge_platform_data *pdata =
-				omap_dspbridge_dev->dev.platform_data;
+	    omap_dspbridge_dev->dev.platform_data;
 #endif
 
-	status = CFG_GetHostResources(
-		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 	if (DSP_FAILED(status))
 		return status;
 
-	HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
-			    &pwrState);
-	/* Wait for DSP to move into Off state,  how much time should
-	 * we wait? */
-	while ((pwrState != HW_PWR_STATE_OFF) && --usCount) {
-		udelay(500);
-		HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
-				    &pwrState);
-	}
-	if (usCount == 0) {
-		DBG_Trace(DBG_LEVEL7, "Timed out Waiting for DSP Off mode \n");
-		status = WMD_E_TIMEOUT;
+	spin_lock_bh(&pwr_lock);
+
+	/* Wait for DSP to move into OFF state */
+	v = msecs_to_jiffies(PWRSTST_TIMEOUT) + jiffies;
+	do {
+		t = time_is_after_jiffies(v);
+		hw_pwr_iva2_state_get(resources.dw_prm_base, HW_PWR_DOMAIN_DSP,
+				      &pwr_state);
+		if (pwr_state == HW_PWR_STATE_OFF)
+			break;
+	} while (t);
+
+	if (!t) {
+		dev_dbg(bridge, "Timed out waiting for DSP off mode\n");
+		spin_unlock_bh(&pwr_lock);
+		return WMD_E_TIMEOUT;
+	}
+
+	/* Save mailbox settings */
+	omap_mbox_save_ctx(dev_context->mbox);
+
+	/* Turn off DSP Peripheral clocks and DSP Load monitor timer */
+	status = dsp_peripheral_clocks_disable(dev_context, NULL);
+
+	if (DSP_FAILED(status)) {
+		spin_unlock_bh(&pwr_lock);
 		return status;
-	} else {
+	}
+
+	status = services_clk_disable(SERVICESCLK_IVA2_CK);
+
+	/* Disable wdt on hibernation. */
+	dsp_wdt_enable(false);
+
+	/* Update the Bridger Driver state */
+	dev_context->dw_brd_state = BRD_DSP_HIBERNATION;
+
+	spin_unlock_bh(&pwr_lock);
 
-		/* Save mailbox settings */
-		status = HW_MBOX_saveSettings(resources.dwMboxBase);
-		DBG_Trace(DBG_LEVEL6, "MailBoxSettings: SYSCONFIG = 0x%x\n",
-			 mboxsetting.sysconfig);
-		DBG_Trace(DBG_LEVEL6, "MailBoxSettings: IRQENABLE0 = 0x%x\n",
-			 mboxsetting.irqEnable0);
-		DBG_Trace(DBG_LEVEL6, "MailBoxSettings: IRQENABLE1 = 0x%x\n",
-			 mboxsetting.irqEnable1);
-		/* Turn off DSP Peripheral clocks and DSP Load monitor timer */
-		status = DSP_PeripheralClocks_Disable(pDevContext, NULL);
-
-		if (DSP_SUCCEEDED(status)) {
-			/* Update the Bridger Driver state */
-			pDevContext->dwBrdState = BRD_DSP_HIBERNATION;
 #ifdef CONFIG_BRIDGE_DVFS
-			status = DEV_GetIOMgr(pDevContext->hDevObject, &hIOMgr);
-			if (DSP_FAILED(status))
-				return status;
-			IO_SHMsetting(hIOMgr, SHM_GETOPP, &opplevel);
-			if (opplevel != VDD1_OPP1) {
-				DBG_Trace(DBG_LEVEL5,
-					" DSP requested OPP = %d, MPU"
-					" requesting low OPP %d instead\n",
-					opplevel, VDD1_OPP1);
-			}
-			/*
-			 * Set the OPP to low level before moving to OFF
-			 * mode
-			 */
-			if (pdata->dsp_set_min_opp)
-				(*pdata->dsp_set_min_opp)(VDD1_OPP1);
+	status = dev_get_io_mgr(dev_context->hdev_obj, &hio_mgr);
+	if (!hio_mgr)
+		return DSP_EHANDLE;
+	io_sh_msetting(hio_mgr, SHM_GETOPP, &opplevel);
+
+	/*Set the OPP to low level before moving to OFF mode */
+	if (pdata->dsp_set_min_opp)
+		(*pdata->dsp_set_min_opp) (VDD1_OPP1);
 			status = DSP_SOK;
 #endif /* CONFIG_BRIDGE_DVFS */
-		} else {
-			DBG_Trace(DBG_LEVEL7,
-				 "handle_hibernation_fromDSP- FAILED\n");
-		}
-	}
 #endif
 	return status;
 }
 
 /*
- *  ======== SleepDSP ========
+ *  ======== sleep_dsp ========
  *  	Put DSP in low power consuming state.
  */
-DSP_STATUS SleepDSP(struct WMD_DEV_CONTEXT *pDevContext, IN u32 dwCmd,
-		   IN void *pArgs)
+dsp_status sleep_dsp(struct wmd_dev_context *dev_context, IN u32 dw_cmd,
+		     IN void *pargs)
 {
-	DSP_STATUS status = DSP_SOK;
+	dsp_status status = DSP_SOK;
 #ifdef CONFIG_PM
-	struct CFG_HOSTRES resources;
-	struct DEH_MGR *hDehMgr;
-	u16 usCount = TIHELEN_ACKTIMEOUT;
-	enum HW_PwrState_t pwrState, targetPwrState;
-
-	DBG_Trace(DBG_LEVEL7, "SleepDSP- Enter function \n");
+	struct cfg_hostres resources;
+#ifdef CONFIG_BRIDGE_NTFY_PWRERR
+	struct deh_mgr *hdeh_mgr;
+#endif /* CONFIG_BRIDGE_NTFY_PWRERR */
+	u8 t;
+	unsigned long v;
+	u32 mbx_msg;
+	enum hw_pwr_state_t pwr_state, target_pwr_state;
 
 	/* Check if sleep code is valid */
-	if ((dwCmd != PWR_DEEPSLEEP) && (dwCmd != PWR_EMERGENCYDEEPSLEEP)) {
-		DBG_Trace(DBG_LEVEL7, "SleepDSP- Illegal sleep command\n");
+	if ((dw_cmd != PWR_DEEPSLEEP) && (dw_cmd != PWR_EMERGENCYDEEPSLEEP))
 		return DSP_EINVALIDARG;
-	}
 
-	status = CFG_GetHostResources(
-		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 	if (DSP_FAILED(status))
 		return status;
 
-	switch (pDevContext->dwBrdState) {
+	switch (dev_context->dw_brd_state) {
 	case BRD_RUNNING:
-		status = HW_MBOX_saveSettings(resources.dwMboxBase);
-		if (enable_off_mode) {
-			CHNLSM_InterruptDSP2(pDevContext,
-					     MBX_PM_DSPHIBERNATE);
-			DBG_Trace(DBG_LEVEL7,
-				 "SleepDSP - Sent hibernate "
-				 "command to DSP\n");
-			targetPwrState = HW_PWR_STATE_OFF;
+		if (dsp_test_sleepstate == HW_PWR_STATE_OFF) {
+			mbx_msg = MBX_PM_DSPHIBERNATE;
+			dev_dbg(bridge, "PM: %s - sent hibernate cmd to DSP\n",
+				__func__);
+			target_pwr_state = HW_PWR_STATE_OFF;
 		} else {
-			CHNLSM_InterruptDSP2(pDevContext,
-					     MBX_PM_DSPRETENTION);
-			targetPwrState = HW_PWR_STATE_RET;
+			mbx_msg = MBX_PM_DSPRETENTION;
+			target_pwr_state = HW_PWR_STATE_RET;
 		}
 		break;
 	case BRD_RETENTION:
-		status = HW_MBOX_saveSettings(resources.dwMboxBase);
-		if (enable_off_mode) {
-			CHNLSM_InterruptDSP2(pDevContext,
-					     MBX_PM_DSPHIBERNATE);
-			targetPwrState = HW_PWR_STATE_OFF;
+		if (dsp_test_sleepstate == HW_PWR_STATE_OFF) {
+			mbx_msg = MBX_PM_DSPHIBERNATE;
+			target_pwr_state = HW_PWR_STATE_OFF;
 		} else
 			return DSP_SOK;
 		break;
 	case BRD_HIBERNATION:
 	case BRD_DSP_HIBERNATION:
 		/* Already in Hibernation, so just return */
-		DBG_Trace(DBG_LEVEL7, "SleepDSP- DSP already in "
-			 "hibernation\n");
+		dev_dbg(bridge, "PM: %s - DSP already in hibernation\n",
+			__func__);
 		return DSP_SOK;
 	case BRD_STOPPED:
-		DBG_Trace(DBG_LEVEL7,
-			 "SleepDSP- Board in STOP state \n");
+		dev_dbg(bridge, "PM: %s - Board in STOP state\n", __func__);
 		return DSP_SALREADYASLEEP;
 	default:
-		DBG_Trace(DBG_LEVEL7,
-			 "SleepDSP- Bridge in Illegal state\n");
-			return DSP_EFAIL;
-	}
-
-	/* Get the PRCM DSP power domain status */
-	HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
-			&pwrState);
-
-	/*
-	 * Wait for DSP to move into Standby state,  how much time
-	 * should we wait?
-	 */
-	while ((pwrState != targetPwrState) && --usCount) {
-		udelay(500);
-		HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
-				    &pwrState);
-	}
-
-	if (!usCount) {
-		DBG_Trace(DBG_LEVEL7, "SleepDSP: Timed out Waiting for DSP"
-			 " STANDBY %x \n", pwrState);
-		DEV_GetDehMgr(pDevContext->hDevObject, &hDehMgr);
-		WMD_DEH_Notify(hDehMgr, DSP_PWRERROR, 0);
+		dev_dbg(bridge, "PM: %s - Bridge in Illegal state\n", __func__);
+		return DSP_EFAIL;
+	}
+
+	spin_lock_bh(&pwr_lock);
+
+	omap_mbox_save_ctx(dev_context->mbox);
+
+	status = omap_mbox_msg_send(dev_context->mbox, mbx_msg);
+	if (DSP_FAILED(status)) {
+		spin_unlock_bh(&pwr_lock);
+		return status;
+	}
+
+	/* Wait for DSP to move into target power state */
+	v = msecs_to_jiffies(PWRSTST_TIMEOUT) + jiffies;
+	do {
+		t = time_is_after_jiffies(v);
+		hw_pwr_iva2_state_get(resources.dw_prm_base, HW_PWR_DOMAIN_DSP,
+				      &pwr_state);
+		if (pwr_state == target_pwr_state)
+			break;
+	} while (t);
+	if (!t) {
+		pr_err("%s: Timed out waiting for DSP off mode, state %x\n",
+		       __func__, pwr_state);
+#ifdef CONFIG_BRIDGE_NTFY_PWRERR
+		dev_get_deh_mgr(dev_context->hdev_obj, &hdeh_mgr);
+		bridge_deh_notify(hdeh_mgr, DSP_PWRERROR, 0);
+#endif /* CONFIG_BRIDGE_NTFY_PWRERR */
+		spin_unlock_bh(&pwr_lock);
 		return WMD_E_TIMEOUT;
-	} else {
-		DBG_Trace(DBG_LEVEL7, "SleepDSP: DSP STANDBY Pwr state %x \n",
-			 pwrState);
+	}
 
-		/* Update the Bridger Driver state */
-		if (enable_off_mode)
-			pDevContext->dwBrdState = BRD_HIBERNATION;
-		else
-			pDevContext->dwBrdState = BRD_RETENTION;
+	/* Update the Bridger Driver state */
+	if (dsp_test_sleepstate == HW_PWR_STATE_OFF)
+		dev_context->dw_brd_state = BRD_HIBERNATION;
+	else
+		dev_context->dw_brd_state = BRD_RETENTION;
+
+	/* Disable wdt on hibernation. */
+	dsp_wdt_enable(false);
+
+	/* Turn off DSP Peripheral clocks */
+	status = dsp_peripheral_clocks_disable(dev_context, NULL);
+	status = services_clk_disable(SERVICESCLK_IVA2_CK);
+	if (DSP_FAILED(status)) {
+		spin_unlock_bh(&pwr_lock);
+		return status;
+	}
+
+	spin_unlock_bh(&pwr_lock);
 
-		/* Turn off DSP Peripheral clocks  */
-		status = DSP_PeripheralClocks_Disable(pDevContext, NULL);
-		if (DSP_FAILED(status)) {
-			DBG_Trace(DBG_LEVEL7, "SleepDSP- FAILED\n");
-			return status;
-		}
 #ifdef CONFIG_BRIDGE_DVFS
-		else if (targetPwrState == HW_PWR_STATE_OFF) {
-			struct dspbridge_platform_data *pdata =
-				omap_dspbridge_dev->dev.platform_data;
-			/*
-			 * Set the OPP to low level before moving to OFF mode
-			 */
-			if (pdata->dsp_set_min_opp)
-				(*pdata->dsp_set_min_opp)(VDD1_OPP1);
-		}
-#endif /* CONFIG_BRIDGE_DVFS */
+	if (target_pwr_state == HW_PWR_STATE_OFF) {
+		struct dspbridge_platform_data *pdata =
+		    omap_dspbridge_dev->dev.platform_data;
+		/*
+		 * Set the OPP to low level before moving to OFF mode
+		 */
+		if (pdata->dsp_set_min_opp)
+			(*pdata->dsp_set_min_opp) (VDD1_OPP1);
 	}
+#endif /* CONFIG_BRIDGE_DVFS */
 #endif /* CONFIG_PM */
 	return status;
 }
 
-
 /*
- *  ======== WakeDSP ========
+ *  ======== wake_dsp ========
  *  	Wake up DSP from sleep.
  */
-DSP_STATUS WakeDSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs)
+dsp_status wake_dsp(struct wmd_dev_context *dev_context, IN void *pargs)
 {
+	dsp_status status = DSP_SOK;
 #ifdef CONFIG_PM
-	DSP_STATUS status = DSP_SOK;
-#ifdef CONFIG_BRIDGE_DEBUG
-	enum HW_PwrState_t pwrState;
-	struct CFG_HOSTRES resources;
+	struct cfg_hostres resources;
+	u32 temp;
 
-	status = CFG_GetHostResources(
-		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
-	if (DSP_FAILED(status))
-		return status;
-#endif /* CONFIG_BRIDGE_DEBUG */
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
+	if (!dev_context->mbox || DSP_FAILED(status))
+		return DSP_EFAIL;
 
-	/* Check the BRD/WMD state, if it is not 'SLEEP' then return failure */
-	if (pDevContext->dwBrdState == BRD_RUNNING ||
-	    pDevContext->dwBrdState == BRD_STOPPED) {
-		/* The Device is in 'RET' or 'OFF' state and WMD state is not
-		 * 'SLEEP', this means state inconsistency, so return  */
-		return DSP_SOK;
+	spin_lock_bh(&pwr_lock);
+
+	switch (dev_context->dw_brd_state) {
+	case BRD_STOPPED:
+		spin_unlock_bh(&pwr_lock);
+		return 0;
+	case BRD_RUNNING:
+		break;
+	case BRD_RETENTION:
+		services_clk_enable(SERVICESCLK_IVA2_CK);
+		/* Restart the peripheral clocks */
+		dsp_peripheral_clocks_enable(dev_context, NULL);
+
+		dsp_wdt_enable(true);
+
+		dev_context->dw_brd_state = BRD_RUNNING;
+
+		break;
+	case BRD_HIBERNATION:
+	case BRD_DSP_HIBERNATION:
+#ifdef CONFIG_BRIDGE_DVFS
+		{
+			struct dspbridge_platform_data *pdata =
+				omap_dspbridge_dev->dev.platform_data;
+			/*
+			 * When Smartreflex is ON, DSP requires at least OPP level 3
+			 * to operate reliably. So boost lower OPP levels to OPP3.
+			 */
+			if (pdata->dsp_set_min_opp)
+				(*pdata->dsp_set_min_opp)(min_active_opp);
+		}
+#endif
+		services_clk_enable(SERVICESCLK_IVA2_CK);
+		/* Restart the peripheral clocks */
+		dsp_peripheral_clocks_enable(dev_context, NULL);
+		dsp_wdt_enable(true);
+
+		/*
+		 * 2:0 AUTO_IVA2_DPLL - Enabling IVA2 DPLL auto control
+		 *     in CM_AUTOIDLE_PLL_IVA2 register
+		 */
+		*(reg_uword32 *) (resources.dw_cm_base + 0x34) = 0x1;
+
+		/*
+		 * 7:4 IVA2_DPLL_FREQSEL - IVA2 internal frq set to
+		 *     0.75 MHz - 1.0 MHz
+		 * 2:0 EN_IVA2_DPLL - Enable IVA2 DPLL in lock mode
+		 */
+		temp = *(reg_uword32 *) (resources.dw_cm_base + 0x4);
+		temp = (temp & 0xFFFFFF08) | 0x37;
+		*(reg_uword32 *) (resources.dw_cm_base + 0x4) = temp;
+
+		/* Restore mailbox settings */
+		omap_mbox_restore_ctx(dev_context->mbox);
+
+		/* Access MMU SYS CONFIG register to generate a short wakeup */
+		temp = *(reg_uword32 *) (resources.dw_dmmu_base + 0x10);
+
+		dev_context->dw_brd_state = BRD_RUNNING;
+
+		break;
+	default:
+		pr_err("%s: unexpected state %x\n", __func__,
+						dev_context->dw_brd_state);
+		spin_unlock_bh(&pwr_lock);
+		return DSP_EVALUE;
 	}
 
 	/* Send a wakeup message to DSP */
-	CHNLSM_InterruptDSP2(pDevContext, MBX_PM_DSPWAKEUP);
+	status = omap_mbox_msg_send(dev_context->mbox, MBX_PM_DSPWAKEUP);
 
-#ifdef CONFIG_BRIDGE_DEBUG
-	HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
-			&pwrState);
-	DBG_Trace(DBG_LEVEL7,
-			"\nWakeDSP: Power State After sending Interrupt "
-			"to DSP %x\n", pwrState);
-#endif /* CONFIG_BRIDGE_DEBUG */
+	spin_unlock_bh(&pwr_lock);
 
-	/* Set the device state to RUNNIG */
-	pDevContext->dwBrdState = BRD_RUNNING;
 #endif /* CONFIG_PM */
 	return status;
 }
 
 /*
- *  ======== DSPPeripheralClkCtrl ========
+ *  ======== dsp_peripheral_clk_ctrl ========
  *  	Enable/Disable the DSP peripheral clocks as needed..
  */
-DSP_STATUS DSPPeripheralClkCtrl(struct WMD_DEV_CONTEXT *pDevContext,
-				IN void *pArgs)
+dsp_status dsp_peripheral_clk_ctrl(struct wmd_dev_context *dev_context,
+				   IN void *pargs)
 {
-	u32 extClk = 0;
-	u32 extClkId = 0;
-	u32 extClkCmd = 0;
-	u32 clkIdIndex = MBX_PM_MAX_RESOURCES;
-	u32 tmpIndex;
-	u32 dspPerClksBefore;
-	DSP_STATUS status = DSP_SOK;
-	DSP_STATUS status1 = DSP_SOK;
-
-	DBG_Trace(DBG_ENTER, "Entering DSPPeripheralClkCtrl \n");
-	dspPerClksBefore = pDevContext->uDspPerClks;
-	DBG_Trace(DBG_ENTER, "DSPPeripheralClkCtrl : uDspPerClks = 0x%x \n",
-		  dspPerClksBefore);
-
-	extClk = (u32)*((u32 *)pArgs);
+	u32 ext_clk = 0;
+	u32 ext_clk_id = 0;
+	u32 ext_clk_cmd = 0;
+	u32 clk_id_index = MBX_PM_MAX_RESOURCES;
+	u32 tmp_index;
+	u32 dsp_per_clks_before;
+	dsp_status status = DSP_SOK;
+	dsp_status status1 = DSP_SOK;
+	struct cfg_hostres resources;
+	u32 value;
+
+	dsp_per_clks_before = dev_context->dsp_per_clks;
+
+	ext_clk = (u32) *((u32 *) pargs);
+
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 
-	DBG_Trace(DBG_LEVEL3, "DSPPeripheralClkCtrl : extClk+Cmd = 0x%x \n",
-		 extClk);
+	if (DSP_FAILED(status))
+		return DSP_EFAIL;
 
-	extClkId = extClk & MBX_PM_CLK_IDMASK;
+	ext_clk_id = ext_clk & MBX_PM_CLK_IDMASK;
 
 	/* process the power message -- TODO, keep it in a separate function */
-	for (tmpIndex = 0; tmpIndex < MBX_PM_MAX_RESOURCES; tmpIndex++) {
-		if (extClkId == BPWR_CLKID[tmpIndex]) {
-			clkIdIndex = tmpIndex;
+	for (tmp_index = 0; tmp_index < MBX_PM_MAX_RESOURCES; tmp_index++) {
+		if (ext_clk_id == bpwr_clkid[tmp_index]) {
+			clk_id_index = tmp_index;
 			break;
 		}
 	}
 	/* TODO -- Assert may be a too hard restriction here.. May be we should
 	 * just return with failure when the CLK ID does not match */
-	/* DBC_Assert(clkIdIndex < MBX_PM_MAX_RESOURCES);*/
-	if (clkIdIndex == MBX_PM_MAX_RESOURCES) {
-		DBG_Trace(DBG_LEVEL7,
-			 "DSPPeripheralClkCtrl : Could n't get clock Id for"
-			 "clkid 0x%x \n", clkIdIndex);
+	/* DBC_ASSERT(clk_id_index < MBX_PM_MAX_RESOURCES); */
+	if (clk_id_index == MBX_PM_MAX_RESOURCES) {
 		/* return with a more meaningfull error code */
 		return DSP_EFAIL;
 	}
-	extClkCmd = (extClk >> MBX_PM_CLK_CMDSHIFT) & MBX_PM_CLK_CMDMASK;
-	switch (extClkCmd) {
-	case BPWR_DisableClock:
+	ext_clk_cmd = (ext_clk >> MBX_PM_CLK_CMDSHIFT) & MBX_PM_CLK_CMDMASK;
+	switch (ext_clk_cmd) {
+	case BPWR_DISABLE_CLOCK:
 		/* Call BP to disable the needed clock */
-		DBG_Trace(DBG_LEVEL3,
-			 "DSPPeripheralClkCtrl : Disable CLK for \n");
-		status1 = CLK_Disable(BPWR_Clks[clkIdIndex].intClk);
-		status = CLK_Disable(BPWR_Clks[clkIdIndex].funClk);
-		DSPClkWakeupEventCtrl(BPWR_Clks[clkIdIndex].clkId, false);
+		status1 = services_clk_disable(bpwr_clks[clk_id_index].int_clk);
+		status = services_clk_disable(bpwr_clks[clk_id_index].fun_clk);
+		if (bpwr_clkid[clk_id_index] == BPWR_MCBSP1) {
+			/* clear MCBSP1_CLKS, on McBSP1 OFF */
+			value = __raw_readl(resources.dw_sys_ctrl_base + 0x274);
+			value &= ~(1 << 2);
+			__raw_writel(value, resources.dw_sys_ctrl_base + 0x274);
+		} else if (bpwr_clkid[clk_id_index] == BPWR_MCBSP2) {
+			/* clear MCBSP2_CLKS, on McBSP2 OFF */
+			value = __raw_readl(resources.dw_sys_ctrl_base + 0x274);
+			value &= ~(1 << 6);
+			__raw_writel(value, resources.dw_sys_ctrl_base + 0x274);
+		}
+		dsp_clk_wakeup_event_ctrl(bpwr_clks[clk_id_index].clk_id,
+					  false);
 		if ((DSP_SUCCEEDED(status)) && (DSP_SUCCEEDED(status1))) {
-			(pDevContext->uDspPerClks) &=
-				(~((u32) (1 << clkIdIndex)));
-		} else {
-			DBG_Trace(DBG_LEVEL7, "DSPPeripheralClkCtrl : Failed "
-				 "to disable clk\n");
+			(dev_context->dsp_per_clks) &=
+			    (~((u32) (1 << clk_id_index)));
 		}
 		break;
-	case BPWR_EnableClock:
-		DBG_Trace(DBG_LEVEL3,
-			 "DSPPeripheralClkCtrl : Enable CLK for \n");
-		status1 = CLK_Enable(BPWR_Clks[clkIdIndex].intClk);
-		status = CLK_Enable(BPWR_Clks[clkIdIndex].funClk);
-		DSPClkWakeupEventCtrl(BPWR_Clks[clkIdIndex].clkId, true);
+	case BPWR_ENABLE_CLOCK:
+		status1 = services_clk_enable(bpwr_clks[clk_id_index].int_clk);
+		status = services_clk_enable(bpwr_clks[clk_id_index].fun_clk);
+		if (bpwr_clkid[clk_id_index] == BPWR_MCBSP1) {
+			/* set MCBSP1_CLKS, on McBSP1 ON */
+			value = __raw_readl(resources.dw_sys_ctrl_base + 0x274);
+			value |= 1 << 2;
+			__raw_writel(value, resources.dw_sys_ctrl_base + 0x274);
+		} else if (bpwr_clkid[clk_id_index] == BPWR_MCBSP2) {
+			/* set MCBSP2_CLKS, on McBSP2 ON */
+			value = __raw_readl(resources.dw_sys_ctrl_base + 0x274);
+			value |= 1 << 6;
+			__raw_writel(value, resources.dw_sys_ctrl_base + 0x274);
+		}
+		dsp_clk_wakeup_event_ctrl(bpwr_clks[clk_id_index].clk_id, true);
 		if ((DSP_SUCCEEDED(status)) && (DSP_SUCCEEDED(status1))) {
-			(pDevContext->uDspPerClks) |= (1 << clkIdIndex);
-		} else {
-			DBG_Trace(DBG_LEVEL7,
-				 "DSPPeripheralClkCtrl:Failed to Enable clk\n");
+			(dev_context->dsp_per_clks) |= (1 << clk_id_index);
 		}
 		break;
 	default:
-		DBG_Trace(DBG_LEVEL3,
-			 "DSPPeripheralClkCtrl : Unsupported CMD \n");
+		dev_dbg(bridge, "%s: Unsupported CMD\n", __func__);
 		/* unsupported cmd */
 		/* TODO -- provide support for AUTOIDLE Enable/Disable
 		 * commands */
@@ -442,36 +489,33 @@
 }
 
 /*
- *  ========PreScale_DSP========
+ *  ========pre_scale_dsp========
  *  Sends prescale notification to DSP
  *
  */
-DSP_STATUS PreScale_DSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs)
+dsp_status pre_scale_dsp(struct wmd_dev_context *dev_context, IN void *pargs)
 {
 #ifdef CONFIG_BRIDGE_DVFS
 	u32 level;
 	u32 voltage_domain;
 
-	voltage_domain = *((u32 *)pArgs);
-	level = *((u32 *)pArgs + 1);
+	voltage_domain = *((u32 *) pargs);
+	level = *((u32 *) pargs + 1);
 
-	DBG_Trace(DBG_LEVEL7, "PreScale_DSP: voltage_domain = %x, level = "
-		 "0x%x\n", voltage_domain, level);
-	if ((pDevContext->dwBrdState == BRD_HIBERNATION) ||
-			(pDevContext->dwBrdState == BRD_RETENTION) ||
-			(pDevContext->dwBrdState == BRD_DSP_HIBERNATION)) {
-		DBG_Trace(DBG_LEVEL7, "PreScale_DSP: IVA in sleep. "
-			 "No notification to DSP\n");
+	dev_dbg(bridge, "OPP: %s voltage_domain = %x, level = 0x%x\n",
+		__func__, voltage_domain, level);
+	if ((dev_context->dw_brd_state == BRD_HIBERNATION) ||
+	    (dev_context->dw_brd_state == BRD_RETENTION) ||
+	    (dev_context->dw_brd_state == BRD_DSP_HIBERNATION)) {
+		dev_dbg(bridge, "OPP: %s IVA in sleep. No message to DSP\n",
+			__func__);
 		return DSP_SOK;
-	} else if ((pDevContext->dwBrdState == BRD_RUNNING)) {
+	} else if ((dev_context->dw_brd_state == BRD_RUNNING)) {
 		/* Send a prenotificatio to DSP */
-		DBG_Trace(DBG_LEVEL7,
-			 "PreScale_DSP: Sent notification to DSP\n");
-		CHNLSM_InterruptDSP2(pDevContext, MBX_PM_SETPOINT_PRENOTIFY);
+		dev_dbg(bridge, "OPP: %s sent notification to DSP\n", __func__);
+		sm_interrupt_dsp(dev_context, MBX_PM_SETPOINT_PRENOTIFY);
 		return DSP_SOK;
 	} else {
-		DBG_Trace(DBG_LEVEL7, "PreScale_DSP: Failed - DSP BRD"
-			  " state in wrong state");
 		return DSP_EFAIL;
 	}
 #endif /* #ifdef CONFIG_BRIDGE_DVFS */
@@ -479,100 +523,130 @@
 }
 
 /*
- *  ========PostScale_DSP========
+ *  ========post_scale_dsp========
  *  Sends postscale notification to DSP
  *
  */
-DSP_STATUS PostScale_DSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs)
+dsp_status post_scale_dsp(struct wmd_dev_context *dev_context, IN void *pargs)
 {
+	dsp_status status = DSP_SOK;
 #ifdef CONFIG_BRIDGE_DVFS
 	u32 level;
 	u32 voltage_domain;
-	struct IO_MGR *hIOMgr;
-	DSP_STATUS status = DSP_SOK;
+	struct io_mgr *hio_mgr;
 
-	status = DEV_GetIOMgr(pDevContext->hDevObject, &hIOMgr);
-
-	voltage_domain = *((u32 *)pArgs);
-	level = *((u32 *)pArgs + 1);
-	DBG_Trace(DBG_LEVEL7,
-		"PostScale_DSP: voltage_domain = %x, level = 0x%x\n",
-		voltage_domain, level);
-	if ((pDevContext->dwBrdState == BRD_HIBERNATION) ||
-			(pDevContext->dwBrdState == BRD_RETENTION) ||
-			(pDevContext->dwBrdState == BRD_DSP_HIBERNATION)) {
+	status = dev_get_io_mgr(dev_context->hdev_obj, &hio_mgr);
+	if (!hio_mgr)
+		return DSP_EHANDLE;
+
+	voltage_domain = *((u32 *) pargs);
+	level = *((u32 *) pargs + 1);
+	dev_dbg(bridge, "OPP: %s voltage_domain = %x, level = 0x%x\n",
+		__func__, voltage_domain, level);
+	if ((dev_context->dw_brd_state == BRD_HIBERNATION) ||
+	    (dev_context->dw_brd_state == BRD_RETENTION) ||
+	    (dev_context->dw_brd_state == BRD_DSP_HIBERNATION)) {
 		/* Update the OPP value in shared memory */
-		IO_SHMsetting(hIOMgr, SHM_CURROPP, &level);
-		DBG_Trace(DBG_LEVEL7,
-			 "PostScale_DSP: IVA in sleep. Wrote to shared "
-			 "memory \n");
-		return DSP_SOK;
-	} else  if ((pDevContext->dwBrdState == BRD_RUNNING)) {
+		io_sh_msetting(hio_mgr, SHM_CURROPP, &level);
+		dev_dbg(bridge, "OPP: %s IVA in sleep. Wrote to shm\n",
+			__func__);
+	} else if ((dev_context->dw_brd_state == BRD_RUNNING)) {
 		/* Update the OPP value in shared memory */
-		IO_SHMsetting(hIOMgr, SHM_CURROPP, &level);
+		io_sh_msetting(hio_mgr, SHM_CURROPP, &level);
 		/* Send a post notification to DSP */
-		CHNLSM_InterruptDSP2(pDevContext, MBX_PM_SETPOINT_POSTNOTIFY);
-		DBG_Trace(DBG_LEVEL7,
-			"PostScale_DSP: Wrote to shared memory Sent post"
-			" notification to DSP\n");
-		return DSP_SOK;
+		sm_interrupt_dsp(dev_context, MBX_PM_SETPOINT_POSTNOTIFY);
+		dev_dbg(bridge, "OPP: %s wrote to shm. Sent post notification "
+			"to DSP\n", __func__);
 	} else {
-		DBG_Trace(DBG_LEVEL7, "PostScale_DSP: Failed - DSP BRD state "
-			"in wrong state");
-		return DSP_EFAIL;
+		status = DSP_EFAIL;
 	}
 #endif /* #ifdef CONFIG_BRIDGE_DVFS */
-	return DSP_SOK;
+	return status;
 }
 
 /*
- *  ========DSP_PeripheralClocks_Disable========
+ *  ========dsp_peripheral_clocks_disable========
  *  Disables all the peripheral clocks that were requested by DSP
  */
-DSP_STATUS DSP_PeripheralClocks_Disable(struct WMD_DEV_CONTEXT *pDevContext,
-					IN void *pArgs)
+dsp_status dsp_peripheral_clocks_disable(struct wmd_dev_context *dev_context,
+					 IN void *pargs)
 {
+	u32 clk_idx;
+	dsp_status status = DSP_SOK;
+	struct cfg_hostres resources;
+	u32 value;
+
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 
-	u32 clkIdx;
-	DSP_STATUS status = DSP_SOK;
-
-	for (clkIdx = 0; clkIdx < MBX_PM_MAX_RESOURCES; clkIdx++) {
-		if (((pDevContext->uDspPerClks) >> clkIdx) & 0x01) {
+	for (clk_idx = 0; clk_idx < MBX_PM_MAX_RESOURCES; clk_idx++) {
+		if (((dev_context->dsp_per_clks) >> clk_idx) & 0x01) {
 			/* Disables the interface clock of the peripheral */
-			status = CLK_Disable(BPWR_Clks[clkIdx].intClk);
-			if (DSP_FAILED(status)) {
-				DBG_Trace(DBG_LEVEL7,
-					 "Failed to Enable the DSP Peripheral"
-					 "Clk 0x%x \n", BPWR_Clks[clkIdx]);
+			status =
+			    services_clk_disable(bpwr_clks[clk_idx].int_clk);
+			if (bpwr_clkid[clk_idx] == BPWR_MCBSP1) {
+				/* clear MCBSP1_CLKS, on McBSP1 OFF */
+				value = __raw_readl(resources.dw_sys_ctrl_base
+						    + 0x274);
+				value &= ~(1 << 2);
+				__raw_writel(value, resources.dw_sys_ctrl_base
+					     + 0x274);
+			} else if (bpwr_clkid[clk_idx] == BPWR_MCBSP2) {
+				/* clear MCBSP2_CLKS, on McBSP2 OFF */
+				value = __raw_readl(resources.dw_sys_ctrl_base
+						    + 0x274);
+				value &= ~(1 << 6);
+				__raw_writel(value, resources.dw_sys_ctrl_base
+					     + 0x274);
 			}
+
 			/* Disables the functional clock of the periphearl */
-			status = CLK_Disable(BPWR_Clks[clkIdx].funClk);
-			if (DSP_FAILED(status)) {
-				DBG_Trace(DBG_LEVEL7,
-					 "Failed to Enable the DSP Peripheral"
-					 "Clk 0x%x \n", BPWR_Clks[clkIdx]);
-			}
+			status =
+			    services_clk_disable(bpwr_clks[clk_idx].fun_clk);
 		}
 	}
 	return status;
 }
 
 /*
- *  ========DSP_PeripheralClocks_Enable========
+ *  ========dsp_peripheral_clocks_enable========
  *  Enables all the peripheral clocks that were requested by DSP
  */
-DSP_STATUS DSP_PeripheralClocks_Enable(struct WMD_DEV_CONTEXT *pDevContext,
-				      IN void *pArgs)
+dsp_status dsp_peripheral_clocks_enable(struct wmd_dev_context *dev_context,
+					IN void *pargs)
 {
-	u32 clkIdx;
-	DSP_STATUS int_clk_status = DSP_EFAIL, fun_clk_status = DSP_EFAIL;
+	u32 clk_idx;
+	dsp_status int_clk_status = DSP_EFAIL, fun_clk_status = DSP_EFAIL;
+	struct cfg_hostres resources;
+	u32 value;
+
+	cfg_get_host_resources((struct cfg_devnode *)
+			       drv_get_first_dev_extension(), &resources);
 
-	for (clkIdx = 0; clkIdx < MBX_PM_MAX_RESOURCES; clkIdx++) {
-		if (((pDevContext->uDspPerClks) >> clkIdx) & 0x01) {
+	for (clk_idx = 0; clk_idx < MBX_PM_MAX_RESOURCES; clk_idx++) {
+		if (((dev_context->dsp_per_clks) >> clk_idx) & 0x01) {
 			/* Enable the interface clock of the peripheral */
-			int_clk_status = CLK_Enable(BPWR_Clks[clkIdx].intClk);
+			int_clk_status =
+			    services_clk_enable(bpwr_clks[clk_idx].int_clk);
+			if (bpwr_clkid[clk_idx] == BPWR_MCBSP1) {
+				/* set MCBSP1_CLKS, on McBSP1 ON */
+				value = __raw_readl(resources.dw_sys_ctrl_base
+						    + 0x274);
+				value |= 1 << 2;
+				__raw_writel(value, resources.dw_sys_ctrl_base
+					     + 0x274);
+			} else if (bpwr_clkid[clk_idx] == BPWR_MCBSP2) {
+				/* set MCBSP2_CLKS, on McBSP2 ON */
+				value = __raw_readl(resources.dw_sys_ctrl_base
+						    + 0x274);
+				value |= 1 << 6;
+				__raw_writel(value, resources.dw_sys_ctrl_base
+					     + 0x274);
+			}
 			/* Enable the functional clock of the periphearl */
-			fun_clk_status = CLK_Enable(BPWR_Clks[clkIdx].funClk);
+			fun_clk_status =
+			    services_clk_enable(bpwr_clks[clk_idx].fun_clk);
 		}
 	}
 	if ((int_clk_status | fun_clk_status) != DSP_SOK)
@@ -580,24 +654,27 @@
 	return DSP_SOK;
 }
 
-void DSPClkWakeupEventCtrl(u32 ClkId, bool enable)
+void dsp_clk_wakeup_event_ctrl(u32 ClkId, bool enable)
 {
-	struct CFG_HOSTRES resources;
-	DSP_STATUS status = DSP_SOK;
+	struct cfg_hostres resources;
+	dsp_status status = DSP_SOK;
 	u32 iva2_grpsel;
 	u32 mpu_grpsel;
 
-	status = CFG_GetHostResources(
-		(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
 	if (DSP_FAILED(status))
 		return;
 
 	switch (ClkId) {
-	case BPWR_GPTimer5:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA4));
+	case BPWR_GP_TIMER5:
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_per_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_per_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_GPT5;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_GPT5;
@@ -605,16 +682,18 @@
 			mpu_grpsel |= OMAP3430_GRPSEL_GPT5;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_GPT5;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-				= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-				= mpu_grpsel;
-	break;
-	case BPWR_GPTimer6:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA4));
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
+	case BPWR_GP_TIMER6:
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_per_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_per_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_GPT6;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_GPT6;
@@ -622,16 +701,18 @@
 			mpu_grpsel |= OMAP3430_GRPSEL_GPT6;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_GPT6;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-							= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-							= mpu_grpsel;
-	break;
-	case BPWR_GPTimer7:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA4));
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
+	case BPWR_GP_TIMER7:
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_per_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_per_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_GPT7;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_GPT7;
@@ -639,16 +720,18 @@
 			mpu_grpsel |= OMAP3430_GRPSEL_GPT7;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_GPT7;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-							= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-							= mpu_grpsel;
-	break;
-	case BPWR_GPTimer8:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA4));
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
+	case BPWR_GP_TIMER8:
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_per_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_per_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_GPT8;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_GPT8;
@@ -656,16 +739,18 @@
 			mpu_grpsel |= OMAP3430_GRPSEL_GPT8;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_GPT8;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-							= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-							= mpu_grpsel;
-	break;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
 	case BPWR_MCBSP1:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwCorePmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwCorePmBase) + 0xA4));
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_core_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_core_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP1;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP1;
@@ -673,16 +758,18 @@
 			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP1;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP1;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA8))
-							= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA4))
-							= mpu_grpsel;
-	break;
+		*((reg_uword32 *) ((u32) (resources.dw_core_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_core_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
 	case BPWR_MCBSP2:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA4));
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_per_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_per_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP2;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP2;
@@ -690,16 +777,18 @@
 			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP2;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP2;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-							= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-							= mpu_grpsel;
-	break;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
 	case BPWR_MCBSP3:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA4));
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_per_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_per_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP3;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP3;
@@ -707,16 +796,18 @@
 			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP3;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP3;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-							= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-							= mpu_grpsel;
-	break;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
 	case BPWR_MCBSP4:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwPerPmBase) + 0xA4));
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_per_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_per_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP4;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP4;
@@ -724,16 +815,18 @@
 			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP4;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP4;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-							= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-							= mpu_grpsel;
-	break;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_per_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
 	case BPWR_MCBSP5:
-		iva2_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwCorePmBase) + 0xA8));
-		mpu_grpsel = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwCorePmBase) + 0xA4));
+		iva2_grpsel = (u32) *((reg_uword32 *)
+				       ((u32) (resources.dw_core_pm_base) +
+					0xA8));
+		mpu_grpsel = (u32) *((reg_uword32 *)
+				      ((u32) (resources.dw_core_pm_base) +
+				       0xA4));
 		if (enable) {
 			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP5;
 			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP5;
@@ -741,10 +834,10 @@
 			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP5;
 			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP5;
 		}
-		*((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA8))
-							= iva2_grpsel;
-		*((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA4))
-							= mpu_grpsel;
-	break;
+		*((reg_uword32 *) ((u32) (resources.dw_core_pm_base) + 0xA8))
+		    = iva2_grpsel;
+		*((reg_uword32 *) ((u32) (resources.dw_core_pm_base) + 0xA4))
+		    = mpu_grpsel;
+		break;
 	}
 }
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/_tiomap.h kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/_tiomap.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/_tiomap.h	2011-10-11 13:51:02.269540523 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/_tiomap.h	2011-10-23 08:22:37.693701000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definitions and types private to this WMD.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,27 +16,19 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== _tiomap.h ========
- *  Description:
- *      Definitions and types private to this WMD.
- *
- */
-
 #ifndef _TIOMAP_
 #define _TIOMAP_
 
 #include <dspbridge/devdefs.h>
 #include <hw_defs.h>
-#include <hw_mbox.h>
-#include <dspbridge/wmdioctl.h>		/* for WMDIOCTL_EXTPROC defn */
+#include <dspbridge/wmdioctl.h>	/* for wmdioctl_extproc defn */
 #include <dspbridge/sync.h>
 #include <dspbridge/clk.h>
 
-struct MAP_L4PERIPHERAL {
-	u32 physAddr;
-	u32 dspVirtAddr;
-} ;
+struct map_l4_peripheral {
+	u32 phys_addr;
+	u32 dsp_virt_addr;
+};
 
 #define ARM_MAILBOX_START               0xfffcf000
 #define ARM_MAILBOX_LENGTH              0x800
@@ -51,22 +45,22 @@
 #define API_CLKM_DPLL_DMA               0xfffec000
 #define ARM_INTERRUPT_OFFSET            0xb00
 
-#define BIOS_24XX
+#define BIOS24XX
 
 #define L4_PERIPHERAL_NULL          0x0
 #define DSPVA_PERIPHERAL_NULL       0x0
 
 #define MAX_LOCK_TLB_ENTRIES 15
 
-#define L4_PERIPHERAL_PRM        0x48306000  /*PRM L4 Peripheral */
+#define L4_PERIPHERAL_PRM        0x48306000	/*PRM L4 Peripheral */
 #define DSPVA_PERIPHERAL_PRM     0x1181e000
-#define L4_PERIPHERAL_SCM        0x48002000  /*SCM L4 Peripheral */
+#define L4_PERIPHERAL_SCM        0x48002000	/*SCM L4 Peripheral */
 #define DSPVA_PERIPHERAL_SCM     0x1181f000
-#define L4_PERIPHERAL_MMU        0x5D000000  /*MMU L4 Peripheral */
+#define L4_PERIPHERAL_MMU        0x5D000000	/*MMU L4 Peripheral */
 #define DSPVA_PERIPHERAL_MMU     0x11820000
-#define L4_PERIPHERAL_CM        0x48004000       /* Core L4, Clock Management */
+#define L4_PERIPHERAL_CM        0x48004000	/* Core L4, Clock Management */
 #define DSPVA_PERIPHERAL_CM     0x1181c000
-#define L4_PERIPHERAL_PER        0x48005000       /*  PER */
+#define L4_PERIPHERAL_PER        0x48005000	/*  PER */
 #define DSPVA_PERIPHERAL_PER     0x1181d000
 
 #define L4_PERIPHERAL_GPIO1       0x48310000
@@ -99,7 +93,7 @@
 #define DSPVA_PERIPHERAL_CAMERA   0x11819000
 
 #define L4_PERIPHERAL_SDMA        0x48056000
-#define DSPVA_PERIPHERAL_SDMA     0x11810000 /*0x1181d000 conflicts with PER */
+#define DSPVA_PERIPHERAL_SDMA     0x11810000	/* 0x1181d000 conflict w/ PER */
 
 #define L4_PERIPHERAL_UART1             0x4806a000
 #define DSPVA_PERIPHERAL_UART1          0x11811000
@@ -145,7 +139,7 @@
 #define DSPVA_PERIPHERAL_SIDETONE_MCBSP3 0x11825000
 
 /* define a static array with L4 mappings */
-static const struct MAP_L4PERIPHERAL L4PeripheralTable[] = {
+static const struct map_l4_peripheral l4_peripheral_table[] = {
 	{L4_PERIPHERAL_MBOX, DSPVA_PERIPHERAL_MBOX},
 	{L4_PERIPHERAL_SCM, DSPVA_PERIPHERAL_SCM},
 	{L4_PERIPHERAL_MMU, DSPVA_PERIPHERAL_MMU},
@@ -214,34 +208,30 @@
 #define MBX_PM_MAX_RESOURCES 11
 
 /*  Power Management Commands */
-enum BPWR_ExtClockCmd {
-	BPWR_DisableClock = 0,
-	BPWR_EnableClock,
-	BPWR_DisableAutoIdle,
-	BPWR_EnableAutoIdle
-} ;
+#define BPWR_DISABLE_CLOCK	0
+#define BPWR_ENABLE_CLOCK	1
 
 /* OMAP242x specific resources */
-enum BPWR_ExtClockId {
-	BPWR_GPTimer5 = 0x10,
-	BPWR_GPTimer6,
-	BPWR_GPTimer7,
-	BPWR_GPTimer8,
-	BPWR_WDTimer3,
+enum bpwr_ext_clock_id {
+	BPWR_GP_TIMER5 = 0x10,
+	BPWR_GP_TIMER6,
+	BPWR_GP_TIMER7,
+	BPWR_GP_TIMER8,
+	BPWR_WD_TIMER3,
 	BPWR_MCBSP1,
 	BPWR_MCBSP2,
 	BPWR_MCBSP3,
 	BPWR_MCBSP4,
 	BPWR_MCBSP5,
 	BPWR_SSI = 0x20
-} ;
+};
 
-static const u32 BPWR_CLKID[] = {
-	(u32) BPWR_GPTimer5,
-	(u32) BPWR_GPTimer6,
-	(u32) BPWR_GPTimer7,
-	(u32) BPWR_GPTimer8,
-	(u32) BPWR_WDTimer3,
+static const u32 bpwr_clkid[] = {
+	(u32) BPWR_GP_TIMER5,
+	(u32) BPWR_GP_TIMER6,
+	(u32) BPWR_GP_TIMER7,
+	(u32) BPWR_GP_TIMER8,
+	(u32) BPWR_WD_TIMER3,
 	(u32) BPWR_MCBSP1,
 	(u32) BPWR_MCBSP2,
 	(u32) BPWR_MCBSP3,
@@ -250,46 +240,31 @@
 	(u32) BPWR_SSI
 };
 
-struct BPWR_Clk_t {
-	u32 clkId;
-	enum SERVICES_ClkId funClk;
-	enum SERVICES_ClkId intClk;
-} ;
-
-static const struct BPWR_Clk_t BPWR_Clks[] = {
-	{(u32) BPWR_GPTimer5, SERVICESCLK_gpt5_fck, SERVICESCLK_gpt5_ick},
-	{(u32) BPWR_GPTimer6, SERVICESCLK_gpt6_fck, SERVICESCLK_gpt6_ick},
-	{(u32) BPWR_GPTimer7, SERVICESCLK_gpt7_fck, SERVICESCLK_gpt7_ick},
-	{(u32) BPWR_GPTimer8, SERVICESCLK_gpt8_fck, SERVICESCLK_gpt8_ick},
-	{(u32) BPWR_WDTimer3, SERVICESCLK_wdt3_fck, SERVICESCLK_wdt3_ick},
-	{(u32) BPWR_MCBSP1, SERVICESCLK_mcbsp1_fck, SERVICESCLK_mcbsp1_ick},
-	{(u32) BPWR_MCBSP2, SERVICESCLK_mcbsp2_fck, SERVICESCLK_mcbsp2_ick},
-	{(u32) BPWR_MCBSP3, SERVICESCLK_mcbsp3_fck, SERVICESCLK_mcbsp3_ick},
-	{(u32) BPWR_MCBSP4, SERVICESCLK_mcbsp4_fck, SERVICESCLK_mcbsp4_ick},
-	{(u32) BPWR_MCBSP5, SERVICESCLK_mcbsp5_fck, SERVICESCLK_mcbsp5_ick},
-	{(u32) BPWR_SSI, SERVICESCLK_ssi_fck, SERVICESCLK_ssi_ick}
+struct bpwr_clk_t {
+	u32 clk_id;
+	enum services_clk_id fun_clk;
+	enum services_clk_id int_clk;
+};
+
+static const struct bpwr_clk_t bpwr_clks[] = {
+	{(u32) BPWR_GP_TIMER5, SERVICESCLK_GPT5_FCK, SERVICESCLK_GPT5_ICK},
+	{(u32) BPWR_GP_TIMER6, SERVICESCLK_GPT6_FCK, SERVICESCLK_GPT6_ICK},
+	{(u32) BPWR_GP_TIMER7, SERVICESCLK_GPT7_FCK, SERVICESCLK_GPT7_ICK},
+	{(u32) BPWR_GP_TIMER8, SERVICESCLK_GPT8_FCK, SERVICESCLK_GPT8_ICK},
+	{(u32) BPWR_WD_TIMER3, SERVICESCLK_WDT3_FCK, SERVICESCLK_WDT3_ICK},
+	{(u32) BPWR_MCBSP1, SERVICESCLK_MCBSP1_FCK, SERVICESCLK_MCBSP1_ICK},
+	{(u32) BPWR_MCBSP2, SERVICESCLK_MCBSP2_FCK, SERVICESCLK_MCBSP2_ICK},
+	{(u32) BPWR_MCBSP3, SERVICESCLK_MCBSP3_FCK, SERVICESCLK_MCBSP3_ICK},
+	{(u32) BPWR_MCBSP4, SERVICESCLK_MCBSP4_FCK, SERVICESCLK_MCBSP4_ICK},
+	{(u32) BPWR_MCBSP5, SERVICESCLK_MCBSP5_FCK, SERVICESCLK_MCBSP5_ICK},
+	{(u32) BPWR_SSI, SERVICESCLK_SSI_FCK, SERVICESCLK_SSI_ICK}
 };
 
 /* Interrupt Register Offsets */
-#define INTH_IT_REG_OFFSET              0x00	/* Interrupt register offset  */
-#define INTH_MASK_IT_REG_OFFSET         0x04	/* Mask Interrupt reg offset  */
+#define INTH_IT_REG_OFFSET              0x00	/* Interrupt register offset */
+#define INTH_MASK_IT_REG_OFFSET         0x04	/* Mask Interrupt reg offset */
 
 #define   DSP_MAILBOX1_INT              10
-
-/*
- *  INTH_InterruptKind_t
- *  Identify the kind of interrupt: either FIQ/IRQ
- */
-enum INTH_InterruptKind_t {
-	INTH_IRQ = 0,
-	INTH_FIQ = 1
-} ;
-
-enum INTH_SensitiveEdge_t {
-	FALLING_EDGE_SENSITIVE = 0,
-	LOW_LEVEL_SENSITIVE = 1
-} ;
-
 /*
  *  Bit definition of  Interrupt  Level  Registers
  */
@@ -305,8 +280,8 @@
 
 #define MB_ARM2DSP_FLAG                 0x0001
 
-#define MBOX_ARM2DSP HW_MBOX_ID_0
-#define MBOX_DSP2ARM HW_MBOX_ID_1
+#define MBOX_ARM2DSP HW_MBOX_ID0
+#define MBOX_DSP2ARM HW_MBOX_ID1
 #define MBOX_ARM HW_MBOX_U0_ARM
 #define MBOX_DSP HW_MBOX_U1_DSP1
 
@@ -317,68 +292,84 @@
 #define LOW_LEVEL                       false
 
 /* Macro's */
-#define REG16(A)    (*(REG_UWORD16 *)(A))
+#define REG16(A)    (*(reg_uword16 *)(A))
 
-#define ClearBit(reg, mask)             (reg &= ~mask)
-#define SetBit(reg, mask)               (reg |= mask)
+#define CLEAR_BIT(reg, mask)             (reg &= ~mask)
+#define SET_BIT(reg, mask)               (reg |= mask)
 
-#define SetGroupBits16(reg, position, width, value) \
+#define SET_GROUP_BITS16(reg, position, width, value) \
 	do {\
 		reg &= ~((0xFFFF >> (16 - (width))) << (position)) ; \
 		reg |= ((value & (0xFFFF >> (16 - (width)))) << (position)); \
 	} while (0);
 
-#define ClearBitIndex(reg, index)   (reg &= ~(1 << (index)))
+#define CLEAR_BIT_INDEX(reg, index)   (reg &= ~(1 << (index)))
 
 /* This mini driver's device context: */
-struct WMD_DEV_CONTEXT {
-	struct DEV_OBJECT *hDevObject;	/* Handle to WCD device object. */
-	u32 dwDspBaseAddr;	/* Arm's API to DSP virtual base addr */
+struct wmd_dev_context {
+	struct dev_object *hdev_obj;	/* Handle to WCD device object. */
+	u32 dw_dsp_base_addr;	/* Arm's API to DSP virt base addr */
 	/*
 	 * DSP External memory prog address as seen virtually by the OS on
 	 * the host side.
 	 */
-	u32 dwDspExtBaseAddr;	/* See the comment above        */
-	u32 dwAPIRegBase;	/* API memory mapped registers  */
-	void __iomem *dwDSPMmuBase;	/* DSP MMU Mapped registers     */
-	u32 dwMailBoxBase;	/* Mail box mapped registers    */
-	u32 dwAPIClkBase;	/* CLK Registers                */
-	u32 dwDSPClkM2Base;	/* DSP Clock Module m2          */
-	u32 dwPublicRhea;	/* Pub Rhea                     */
-	u32 dwIntAddr;	/* MB INTR reg                  */
-	u32 dwTCEndianism;	/* TC Endianism register        */
-	u32 dwTestBase;	/* DSP MMU Mapped registers     */
-	u32 dwSelfLoop;	/* Pointer to the selfloop      */
-	u32 dwDSPStartAdd;	/* API Boot vector              */
-	u32 dwInternalSize;	/* Internal memory size         */
+	u32 dw_dsp_ext_base_addr;	/* See the comment above */
+	u32 dw_api_reg_base;	/* API mem map'd registers */
+	void __iomem *dw_dsp_mmu_base;	/* DSP MMU Mapped registers */
+	u32 dw_api_clk_base;	/* CLK Registers */
+	u32 dw_dsp_clk_m2_base;	/* DSP Clock Module m2 */
+	u32 dw_public_rhea;	/* Pub Rhea */
+	u32 dw_int_addr;	/* MB INTR reg */
+	u32 dw_tc_endianism;	/* TC Endianism register */
+	u32 dw_test_base;	/* DSP MMU Mapped registers */
+	u32 dw_self_loop;	/* Pointer to the selfloop */
+	u32 dw_dsp_start_add;	/* API Boot vector */
+	u32 dw_internal_size;	/* Internal memory size */
+
+	struct omap_mbox *mbox;		/* Mail box handle */
 
 	/*
 	 * Processor specific info is set when prog loaded and read from DCD.
 	 * [See WMD_BRD_Ctrl()]  PROC info contains DSP-MMU TLB entries.
 	 */
 	/* DMMU TLB entries */
-	struct WMDIOCTL_EXTPROC aTLBEntry[WMDIOCTL_NUMOFMMUTLB];
-	u32 dwBrdState;	/* Last known board state.      */
-	u32 ulIntMask;	/* int mask                     */
-	u16 ioBase;	/* Board I/O base               */
-	u32 numTLBEntries;	/* DSP MMU TLB entry counter    */
-	u32 fixedTLBEntries;	/* Fixed DSPMMU TLB entry count */
+	struct wmdioctl_extproc atlb_entry[WMDIOCTL_NUMOFMMUTLB];
+	u32 dw_brd_state;	/* Last known board state. */
+	u32 ul_int_mask;	/* int mask */
+	u16 io_base;		/* Board I/O base */
+	u32 num_tlb_entries;	/* DSP MMU TLB entry counter */
+	u32 fixed_tlb_entries;	/* Fixed DSPMMU TLB entry count */
 
 	/* TC Settings */
-	bool tcWordSwapOn;	/* Traffic Controller Word Swap */
-	struct PgTableAttrs *pPtAttrs;
-	u32 uDspPerClks;
-} ;
+	bool tc_word_swap_on;	/* Traffic Controller Word Swap */
+	struct pg_table_attrs *pt_attrs;
+	u32 dsp_per_clks;
+};
 
 	/*
-	 * ======== WMD_TLB_DspVAToMpuPA ========
+	 * ======== wmd_tlb_dsp_va_to_mpu_pa ========
 	 *     Given a DSP virtual address, traverse the page table and return
 	 *     a corresponding MPU physical address and size.
 	 */
-extern DSP_STATUS WMD_TLB_DspVAToMpuPA(struct WMD_DEV_CONTEXT *pDevContext,
-				       IN u32 ulVirtAddr,
-				       OUT u32 *ulPhysAddr,
-				       OUT u32 *sizeTlb);
-
-#endif				/* _TIOMAP_ */
+extern dsp_status wmd_tlb_dsp_va_to_mpu_pa(struct wmd_dev_context *dev_context,
+					   IN u32 ulVirtAddr,
+					   OUT u32 *ulPhysAddr,
+					   OUT u32 *sizeTlb);
+/*
+ *  ======== sm_interrupt_dsp ========
+ *  Purpose:
+ *      Set interrupt value & send an interrupt to the DSP processor(s).
+ *      This is typicaly used when mailbox interrupt mechanisms allow data
+ *      to be associated with interrupt such as for OMAP's CMD/DATA regs.
+ *  Parameters:
+ *      dev_context:    Handle to mini-driver defined device info.
+ *      mb_val:         Value associated with interrupt(e.g. mailbox value).
+ *  Returns:
+ *      DSP_SOK:        Interrupt sent;
+ *      else:           Unable to send interrupt.
+ *  Requires:
+ *  Ensures:
+ */
+dsp_status sm_interrupt_dsp(struct wmd_dev_context *dev_context, u16 mb_val);
 
+#endif /* _TIOMAP_ */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/tiomap_io.c kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/tiomap_io.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/tiomap_io.c	2011-10-11 13:51:02.269540523 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/tiomap_io.c	2011-10-23 08:22:37.693701000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implementation for the io read/write routines.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,28 +16,12 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _tiomap_io.c ========
- *  Description:
- *      Implementation for the io read/write routines.
- *
- *! Revision History
- *! ================
- *! 16-Feb-2004 vp:  Fixed warning in WriteDspData function.
- *! 16-Apr-2003 vp:  Added support for TC word swap
- *! 26-Feb-2003 vp:  Fixed issue with EXT_BEG and EXT_END address.
- *! 24-Feb-2003 vp:  Ported to Linux platform
- *! 08-Oct-2002 rr:  Created.
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/dbdefs.h>
 #include <dspbridge/errbase.h>
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/dbg.h>
 
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/dev.h>
@@ -43,385 +29,389 @@
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/mem.h>
-#include <dspbridge/util.h>
 #include <dspbridge/cfg.h>
+#include <dspbridge/wdt.h>
 
 /*  ----------------------------------- specific to this file */
 #include "_tiomap.h"
 #include "_tiomap_pwr.h"
 #include "tiomap_io.h"
 
-static u32 ulExtBase;
-static u32 ulExtEnd;
+static u32 ul_ext_base;
+static u32 ul_ext_end;
 
-static u32 ulShm0End;
-static u32 ulDynExtBase;
-static u32 ulTraceSecBeg;
-static u32 ulTraceSecEnd;
-static u32 ulShmBaseVirt;
+static u32 shm0_end;
+static u32 ul_dyn_ext_base;
+static u32 ul_trace_sec_beg;
+static u32 ul_trace_sec_end;
+static u32 ul_shm_base_virt;
 
-bool bSymbolsReloaded = true;
+bool symbols_reloaded = true;
 
 /*
- *  ======== ReadExtDspData ========
+ *  ======== read_ext_dsp_data ========
  *      Copies DSP external memory buffers to the host side buffers.
  */
-DSP_STATUS ReadExtDspData(struct WMD_DEV_CONTEXT *hDevContext,
-			 OUT u8 *pbHostBuf, u32 dwDSPAddr,
-			 u32 ulNumBytes, u32 ulMemType)
+dsp_status read_ext_dsp_data(struct wmd_dev_context *hDevContext,
+			     OUT u8 *pbHostBuf, u32 dwDSPAddr,
+			     u32 ul_num_bytes, u32 ulMemType)
 {
-	DSP_STATUS	status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	u32	offset;
-	u32	ulTLBBaseVirt = 0;
-	u32	ulShmOffsetVirt = 0;
-	u32	dwExtProgVirtMem;
-	u32	dwBaseAddr = pDevContext->dwDspExtBaseAddr;
-	bool	bTraceRead = false;
-
-	DBG_Trace(DBG_ENTER, "ReadExtDspData,"
-	"hDevContext: 0x%x\n\t\tpbHostBuf: 0x%x"
-	"\n\t\tdwDSPAddr:  0x%x\n\t\tulNumBytes:  0x%x\n\t\t"
-	"ulMemType:  0x%x\n", pDevContext, pbHostBuf, dwDSPAddr,
-	ulNumBytes, ulMemType);
-
-	if (!ulShmBaseVirt) {
-		status = DEV_GetSymbol(pDevContext->hDevObject,
-		SHMBASENAME, &ulShmBaseVirt);
+	dsp_status status = DSP_SOK;
+	struct wmd_dev_context *dev_context = hDevContext;
+	u32 offset;
+	u32 ul_tlb_base_virt = 0;
+	u32 ul_shm_offset_virt = 0;
+	u32 dw_ext_prog_virt_mem;
+	u32 dw_base_addr = dev_context->dw_dsp_ext_base_addr;
+	bool trace_read = false;
+
+	if (!ul_shm_base_virt) {
+		status = dev_get_symbol(dev_context->hdev_obj,
+					SHMBASENAME, &ul_shm_base_virt);
 	}
-	DBC_Assert(ulShmBaseVirt != 0);
+	DBC_ASSERT(ul_shm_base_virt != 0);
 
 	/* Check if it is a read of Trace section */
-	if (!ulTraceSecBeg) {
-		status = DEV_GetSymbol(pDevContext->hDevObject,
-		DSP_TRACESEC_BEG, &ulTraceSecBeg);
+	if (DSP_SUCCEEDED(status) && !ul_trace_sec_beg) {
+		status = dev_get_symbol(dev_context->hdev_obj,
+					DSP_TRACESEC_BEG, &ul_trace_sec_beg);
 	}
-	DBC_Assert(ulTraceSecBeg != 0);
+	DBC_ASSERT(ul_trace_sec_beg != 0);
 
-	if (DSP_SUCCEEDED(status) && !ulTraceSecEnd) {
-		status = DEV_GetSymbol(pDevContext->hDevObject,
-		DSP_TRACESEC_END, &ulTraceSecEnd);
+	if (DSP_SUCCEEDED(status) && !ul_trace_sec_end) {
+		status = dev_get_symbol(dev_context->hdev_obj,
+					DSP_TRACESEC_END, &ul_trace_sec_end);
 	}
-	DBC_Assert(ulTraceSecEnd != 0);
+	DBC_ASSERT(ul_trace_sec_end != 0);
 
 	if (DSP_SUCCEEDED(status)) {
-		if ((dwDSPAddr <= ulTraceSecEnd) &&
-			(dwDSPAddr >= ulTraceSecBeg)) {
-			DBG_Trace(DBG_LEVEL5, "Reading from DSP Trace"
-				 "section 0x%x \n", dwDSPAddr);
-			bTraceRead = true;
-		}
+		if ((dwDSPAddr <= ul_trace_sec_end) &&
+		    (dwDSPAddr >= ul_trace_sec_beg))
+			trace_read = true;
 	}
 
 	/* If reading from TRACE, force remap/unmap */
-	if ((bTraceRead) && dwBaseAddr) {
-		dwBaseAddr = 0;
-		pDevContext->dwDspExtBaseAddr = 0;
+	if (trace_read && dw_base_addr) {
+		dw_base_addr = 0;
+		dev_context->dw_dsp_ext_base_addr = 0;
 	}
 
-	if (!dwBaseAddr) {
-		/* Initialize ulExtBase and ulExtEnd */
-		ulExtBase = 0;
-		ulExtEnd = 0;
-
-		/* Get DYNEXT_BEG, EXT_BEG and EXT_END.*/
-		if (DSP_SUCCEEDED(status) && !ulDynExtBase) {
-			status = DEV_GetSymbol(pDevContext->hDevObject,
-					DYNEXTBASE, &ulDynExtBase);
+	if (!dw_base_addr) {
+		/* Initialize ul_ext_base and ul_ext_end */
+		ul_ext_base = 0;
+		ul_ext_end = 0;
+
+		/* Get DYNEXT_BEG, EXT_BEG and EXT_END. */
+		if (DSP_SUCCEEDED(status) && !ul_dyn_ext_base) {
+			status = dev_get_symbol(dev_context->hdev_obj,
+						DYNEXTBASE, &ul_dyn_ext_base);
 		}
-		DBC_Assert(ulDynExtBase != 0);
+		DBC_ASSERT(ul_dyn_ext_base != 0);
 
 		if (DSP_SUCCEEDED(status)) {
-			status = DEV_GetSymbol(pDevContext->hDevObject,
-				 EXTBASE, &ulExtBase);
+			status = dev_get_symbol(dev_context->hdev_obj,
+						EXTBASE, &ul_ext_base);
 		}
-		DBC_Assert(ulExtBase != 0);
+		DBC_ASSERT(ul_ext_base != 0);
 
 		if (DSP_SUCCEEDED(status)) {
-			status = DEV_GetSymbol(pDevContext->hDevObject,
-					EXTEND,	&ulExtEnd);
+			status = dev_get_symbol(dev_context->hdev_obj,
+						EXTEND, &ul_ext_end);
 		}
-		DBC_Assert(ulExtEnd != 0);
+		DBC_ASSERT(ul_ext_end != 0);
 
-	/* Trace buffer is right after the SHM SEG0,
-	*  so set the base address to SHMBASE */
-		if (bTraceRead) {
-			ulExtBase = ulShmBaseVirt;
-			ulExtEnd = ulTraceSecEnd;
+		/* Trace buffer is right after the shm SEG0,
+		 *  so set the base address to SHMBASE */
+		if (trace_read) {
+			ul_ext_base = ul_shm_base_virt;
+			ul_ext_end = ul_trace_sec_end;
 		}
 
-		DBC_Assert(ulExtEnd != 0);
-		DBC_Assert(ulExtEnd > ulExtBase);
+		DBC_ASSERT(ul_ext_end != 0);
+		DBC_ASSERT(ul_ext_end > ul_ext_base);
 
-		if (ulExtEnd < ulExtBase)
+		if (ul_ext_end < ul_ext_base)
 			status = DSP_EFAIL;
 
 		if (DSP_SUCCEEDED(status)) {
-			ulTLBBaseVirt =
-			pDevContext->aTLBEntry[0].ulDspVa * DSPWORDSIZE;
-			DBC_Assert(ulTLBBaseVirt <= ulShmBaseVirt);
-			dwExtProgVirtMem = pDevContext->aTLBEntry[0].ulGppVa;
-
-			if (bTraceRead) {
-				DBG_Trace(DBG_LEVEL7, "ReadExtDspData: "
-				"GPP VA pointing to SHMMEMBASE 0x%x \n",
-				 dwExtProgVirtMem);
-			} else {
-				ulShmOffsetVirt = ulShmBaseVirt - ulTLBBaseVirt;
-				ulShmOffsetVirt += PG_ALIGN_HIGH(ulExtEnd -
-						ulDynExtBase + 1,
-						HW_PAGE_SIZE_64KB);
-				dwExtProgVirtMem -= ulShmOffsetVirt;
-				dwExtProgVirtMem += (ulExtBase - ulDynExtBase);
-				DBG_Trace(DBG_LEVEL7, "ReadExtDspData: "
-				"GPP VA pointing to EXTMEMBASE 0x%x \n",
-				dwExtProgVirtMem);
-				pDevContext->dwDspExtBaseAddr =
-						dwExtProgVirtMem;
-
-	/* This dwDspExtBaseAddr will get cleared only when the board is
-	* stopped. */
-				if (!pDevContext->dwDspExtBaseAddr) {
+			ul_tlb_base_virt =
+			    dev_context->atlb_entry[0].ul_dsp_va * DSPWORDSIZE;
+			DBC_ASSERT(ul_tlb_base_virt <= ul_shm_base_virt);
+			dw_ext_prog_virt_mem =
+			    dev_context->atlb_entry[0].ul_gpp_va;
+
+			if (!trace_read) {
+				ul_shm_offset_virt =
+				    ul_shm_base_virt - ul_tlb_base_virt;
+				ul_shm_offset_virt +=
+				    PG_ALIGN_HIGH(ul_ext_end - ul_dyn_ext_base +
+						  1, HW_PAGE_SIZE64KB);
+				dw_ext_prog_virt_mem -= ul_shm_offset_virt;
+				dw_ext_prog_virt_mem +=
+				    (ul_ext_base - ul_dyn_ext_base);
+				dev_context->dw_dsp_ext_base_addr =
+				    dw_ext_prog_virt_mem;
+
+				/*
+				 * This dw_dsp_ext_base_addr will get cleared
+				 * only when the board is stopped.
+				*/
+				if (!dev_context->dw_dsp_ext_base_addr)
 					status = DSP_EFAIL;
-					DBG_Trace(DBG_LEVEL7, "ReadExtDspData: "
-					"failed to Map the program memory\n");
-				}
 			}
 
-			dwBaseAddr = dwExtProgVirtMem;
+			dw_base_addr = dw_ext_prog_virt_mem;
 		}
 	}
 
-	if (!dwBaseAddr || !ulExtBase || !ulExtEnd) {
-		DBG_Trace(DBG_LEVEL7,
-		"Symbols missing for Ext Prog reading \n");
+	if (!dw_base_addr || !ul_ext_base || !ul_ext_end)
 		status = DSP_EFAIL;
-	}
 
-	offset = dwDSPAddr - ulExtBase;
+	offset = dwDSPAddr - ul_ext_base;
 
 	if (DSP_SUCCEEDED(status))
-		memcpy(pbHostBuf, (u8 *)dwBaseAddr+offset, ulNumBytes);
+		memcpy(pbHostBuf, (u8 *) dw_base_addr + offset, ul_num_bytes);
 
 	return status;
 }
+
 /*
- *  ======== WriteDspData ========
+ *  ======== write_dsp_data ========
  *  purpose:
  *      Copies buffers to the DSP internal/external memory.
  */
-DSP_STATUS WriteDspData(struct WMD_DEV_CONTEXT *hDevContext, IN u8 *pbHostBuf,
-			u32 dwDSPAddr, u32 ulNumBytes, u32 ulMemType)
+dsp_status write_dsp_data(struct wmd_dev_context *hDevContext,
+			  IN u8 *pbHostBuf, u32 dwDSPAddr, u32 ul_num_bytes,
+			  u32 ulMemType)
 {
 	u32 offset;
-	u32 dwBaseAddr = hDevContext->dwDspBaseAddr;
-	struct CFG_HOSTRES resources;
-	DSP_STATUS status;
+	u32 dw_base_addr = hDevContext->dw_dsp_base_addr;
+	struct cfg_hostres resources;
+	dsp_status status;
 	u32 base1, base2, base3;
 	base1 = OMAP_DSP_MEM1_SIZE;
 	base2 = OMAP_DSP_MEM2_BASE - OMAP_DSP_MEM1_BASE;
 	base3 = OMAP_DSP_MEM3_BASE - OMAP_DSP_MEM1_BASE;
-	DBG_Trace(DBG_ENTER, "Entered WriteDspData \n");
 
-	status =  CFG_GetHostResources(
-		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
+
+	if (DSP_FAILED(status))
+		return status;
 
-	offset = dwDSPAddr - hDevContext->dwDSPStartAdd;
+	offset = dwDSPAddr - hDevContext->dw_dsp_start_add;
 	if (offset < base1) {
-		dwBaseAddr = MEM_LinearAddress(resources.dwMemBase[2],
-						resources.dwMemLength[2]);
-	} else if (offset > base1 && offset < base2+OMAP_DSP_MEM2_SIZE) {
-		dwBaseAddr = MEM_LinearAddress(resources.dwMemBase[3],
-						resources.dwMemLength[3]);
+		dw_base_addr = MEM_LINEAR_ADDRESS(resources.dw_mem_base[2],
+						  resources.dw_mem_length[2]);
+	} else if (offset > base1 && offset < base2 + OMAP_DSP_MEM2_SIZE) {
+		dw_base_addr = MEM_LINEAR_ADDRESS(resources.dw_mem_base[3],
+						  resources.dw_mem_length[3]);
 		offset = offset - base2;
-	} else if (offset >= base2+OMAP_DSP_MEM2_SIZE &&
-		offset < base3 + OMAP_DSP_MEM3_SIZE) {
-		dwBaseAddr = MEM_LinearAddress(resources.dwMemBase[4],
-						resources.dwMemLength[4]);
+	} else if (offset >= base2 + OMAP_DSP_MEM2_SIZE &&
+		   offset < base3 + OMAP_DSP_MEM3_SIZE) {
+		dw_base_addr = MEM_LINEAR_ADDRESS(resources.dw_mem_base[4],
+						  resources.dw_mem_length[4]);
 		offset = offset - base3;
-	} else{
-		status = DSP_EFAIL;
-		return status;
+	} else {
+		return DSP_EFAIL;
 	}
-	if (ulNumBytes)
-		memcpy((u8 *) (dwBaseAddr+offset), pbHostBuf, ulNumBytes);
+	if (ul_num_bytes)
+		memcpy((u8 *) (dw_base_addr + offset), pbHostBuf, ul_num_bytes);
 	else
-		*((u32 *) pbHostBuf) = dwBaseAddr+offset;
+		*((u32 *) pbHostBuf) = dw_base_addr + offset;
 
 	return status;
 }
 
 /*
- *  ======== WriteExtDspData ========
+ *  ======== write_ext_dsp_data ========
  *  purpose:
  *      Copies buffers to the external memory.
  *
  */
-DSP_STATUS WriteExtDspData(struct WMD_DEV_CONTEXT *pDevContext,
-			  IN u8 *pbHostBuf, u32 dwDSPAddr, u32 ulNumBytes,
-			  u32 ulMemType, bool bDynamicLoad)
+dsp_status write_ext_dsp_data(struct wmd_dev_context *dev_context,
+			      IN u8 *pbHostBuf, u32 dwDSPAddr,
+			      u32 ul_num_bytes, u32 ulMemType,
+			      bool bDynamicLoad)
 {
-	u32 dwBaseAddr = pDevContext->dwDspExtBaseAddr;
-	u32 dwOffset = 0;
-	u8 bTempByte1, bTempByte2;
-	u8 remainByte[4];
+	u32 dw_base_addr = dev_context->dw_dsp_ext_base_addr;
+	u32 dw_offset = 0;
+	u8 temp_byte1, temp_byte2;
+	u8 remain_byte[4];
 	s32 i;
-	DSP_STATUS retVal = DSP_SOK;
-	u32 dwExtProgVirtMem;
-	u32 ulTLBBaseVirt = 0;
-	u32 ulShmOffsetVirt = 0;
-	struct CFG_HOSTRES hostRes;
-	bool bTraceLoad = false;
-	bTempByte1 = 0x0;
-	bTempByte2 = 0x0;
-
-	DBG_Trace(DBG_ENTER, "Entered WriteExtDspData dwDSPAddr 0x%x "
-		 "ulNumBytes 0x%x \n", dwDSPAddr, ulNumBytes);
-	  if (bSymbolsReloaded) {
+	dsp_status ret = DSP_SOK;
+	u32 dw_ext_prog_virt_mem;
+	u32 ul_tlb_base_virt = 0;
+	u32 ul_shm_offset_virt = 0;
+	struct cfg_hostres host_res;
+	bool trace_load = false;
+	temp_byte1 = 0x0;
+	temp_byte2 = 0x0;
+
+	if (symbols_reloaded) {
 		/* Check if it is a load to Trace section */
-		retVal = DEV_GetSymbol(pDevContext->hDevObject,
-					DSP_TRACESEC_BEG, &ulTraceSecBeg);
-		if (DSP_SUCCEEDED(retVal))
-			retVal = DEV_GetSymbol(pDevContext->hDevObject,
-				 DSP_TRACESEC_END, &ulTraceSecEnd);
-	}
-	if (DSP_SUCCEEDED(retVal)) {
-		if ((dwDSPAddr <= ulTraceSecEnd) &&
-		   (dwDSPAddr >= ulTraceSecBeg)) {
-			DBG_Trace(DBG_LEVEL5, "Writing to DSP Trace "
-				 "section 0x%x \n", dwDSPAddr);
-			bTraceLoad = true;
-		}
+		ret = dev_get_symbol(dev_context->hdev_obj,
+				     DSP_TRACESEC_BEG, &ul_trace_sec_beg);
+		if (DSP_SUCCEEDED(ret))
+			ret = dev_get_symbol(dev_context->hdev_obj,
+					     DSP_TRACESEC_END,
+					     &ul_trace_sec_end);
+	}
+	if (DSP_SUCCEEDED(ret)) {
+		if ((dwDSPAddr <= ul_trace_sec_end) &&
+		    (dwDSPAddr >= ul_trace_sec_beg))
+			trace_load = true;
 	}
 
 	/* If dynamic, force remap/unmap */
-	if ((bDynamicLoad || bTraceLoad) && dwBaseAddr) {
-		dwBaseAddr = 0;
-		MEM_UnmapLinearAddress((void *)pDevContext->dwDspExtBaseAddr);
-		pDevContext->dwDspExtBaseAddr = 0x0;
+	if ((bDynamicLoad || trace_load) && dw_base_addr) {
+		dw_base_addr = 0;
+		MEM_UNMAP_LINEAR_ADDRESS((void *)
+					 dev_context->dw_dsp_ext_base_addr);
+		dev_context->dw_dsp_ext_base_addr = 0x0;
 	}
-	if (!dwBaseAddr) {
-		if (bSymbolsReloaded)
+	if (!dw_base_addr) {
+		if (symbols_reloaded)
 			/* Get SHM_BEG  EXT_BEG and EXT_END. */
-			retVal = DEV_GetSymbol(pDevContext->hDevObject,
-						SHMBASENAME, &ulShmBaseVirt);
-		DBC_Assert(ulShmBaseVirt != 0);
+			ret = dev_get_symbol(dev_context->hdev_obj,
+					     SHMBASENAME, &ul_shm_base_virt);
+		DBC_ASSERT(ul_shm_base_virt != 0);
 		if (bDynamicLoad) {
-			if (DSP_SUCCEEDED(retVal)) {
-				if (bSymbolsReloaded)
-					retVal = DEV_GetSymbol(pDevContext->
-						hDevObject, DYNEXTBASE,
-						&ulExtBase);
+			if (DSP_SUCCEEDED(ret)) {
+				if (symbols_reloaded)
+					ret =
+					    dev_get_symbol
+					    (dev_context->hdev_obj, DYNEXTBASE,
+					     &ul_ext_base);
 			}
-			DBC_Assert(ulExtBase != 0);
-			if (DSP_SUCCEEDED(retVal)) {
+			DBC_ASSERT(ul_ext_base != 0);
+			if (DSP_SUCCEEDED(ret)) {
 				/* DR  OMAPS00013235 : DLModules array may be
 				 * in EXTMEM. It is expected that DYNEXTMEM and
 				 * EXTMEM are contiguous, so checking for the
 				 * upper bound at EXTEND should be Ok. */
-				if (bSymbolsReloaded)
-					retVal = DEV_GetSymbol(pDevContext->
-						hDevObject, EXTEND, &ulExtEnd);
+				if (symbols_reloaded)
+					ret =
+					    dev_get_symbol
+					    (dev_context->hdev_obj, EXTEND,
+					     &ul_ext_end);
 			}
 		} else {
-			if (bSymbolsReloaded) {
-				if (DSP_SUCCEEDED(retVal))
-					retVal = DEV_GetSymbol(pDevContext->
-						hDevObject, EXTBASE,
-						&ulExtBase);
-				DBC_Assert(ulExtBase != 0);
-				if (DSP_SUCCEEDED(retVal))
-					retVal = DEV_GetSymbol(pDevContext->
-						hDevObject, EXTEND, &ulExtEnd);
+			if (symbols_reloaded) {
+				if (DSP_SUCCEEDED(ret))
+					ret =
+					    dev_get_symbol
+					    (dev_context->hdev_obj, EXTBASE,
+					     &ul_ext_base);
+				DBC_ASSERT(ul_ext_base != 0);
+				if (DSP_SUCCEEDED(ret))
+					ret =
+					    dev_get_symbol
+					    (dev_context->hdev_obj, EXTEND,
+					     &ul_ext_end);
 			}
 		}
-		/* Trace buffer it right after the SHM SEG0, so set the
-		 * 	base address to SHMBASE */
-		if (bTraceLoad)
-			ulExtBase = ulShmBaseVirt;
-
-		DBC_Assert(ulExtEnd != 0);
-		DBC_Assert(ulExtEnd > ulExtBase);
-		if (ulExtEnd < ulExtBase)
-			retVal = DSP_EFAIL;
-
-		if (DSP_SUCCEEDED(retVal)) {
-			ulTLBBaseVirt = pDevContext->aTLBEntry[0].ulDspVa *
-					DSPWORDSIZE;
-			DBC_Assert(ulTLBBaseVirt <= ulShmBaseVirt);
-
-			if (bSymbolsReloaded) {
-				if (DSP_SUCCEEDED(retVal)) {
-					retVal = DEV_GetSymbol(pDevContext->
-						 hDevObject, DSP_TRACESEC_END,
-						 &ulShm0End);
+		/* Trace buffer it right after the shm SEG0, so set the
+		 *      base address to SHMBASE */
+		if (trace_load)
+			ul_ext_base = ul_shm_base_virt;
+
+		DBC_ASSERT(ul_ext_end != 0);
+		DBC_ASSERT(ul_ext_end > ul_ext_base);
+		if (ul_ext_end < ul_ext_base)
+			ret = DSP_EFAIL;
+
+		if (DSP_SUCCEEDED(ret)) {
+			ul_tlb_base_virt =
+			    dev_context->atlb_entry[0].ul_dsp_va * DSPWORDSIZE;
+			DBC_ASSERT(ul_tlb_base_virt <= ul_shm_base_virt);
+
+			if (symbols_reloaded) {
+				if (DSP_SUCCEEDED(ret)) {
+					ret =
+					    dev_get_symbol
+					    (dev_context->hdev_obj,
+					     DSP_TRACESEC_END, &shm0_end);
 				}
-				if (DSP_SUCCEEDED(retVal)) {
-					retVal = DEV_GetSymbol(pDevContext->
-						 hDevObject, DYNEXTBASE,
-						 &ulDynExtBase);
+				if (DSP_SUCCEEDED(ret)) {
+					ret =
+					    dev_get_symbol
+					    (dev_context->hdev_obj, DYNEXTBASE,
+					     &ul_dyn_ext_base);
 				}
 			}
-			ulShmOffsetVirt = ulShmBaseVirt - ulTLBBaseVirt;
-			if (bTraceLoad) {
-				dwExtProgVirtMem = pDevContext->aTLBEntry[0].
-						   ulGppVa;
+			ul_shm_offset_virt =
+			    ul_shm_base_virt - ul_tlb_base_virt;
+			if (trace_load) {
+				dw_ext_prog_virt_mem =
+				    dev_context->atlb_entry[0].ul_gpp_va;
 			} else {
-				CFG_GetHostResources(
-					(struct CFG_DEVNODE *)
-					DRV_GetFirstDevExtension(), &hostRes);
-				dwExtProgVirtMem = hostRes.dwMemBase[1];
-				dwExtProgVirtMem += (ulExtBase - ulDynExtBase);
-			}
-			DBG_Trace(DBG_LEVEL7, "WriteExtDspData: GPP VA "
-				 "pointing to EXTMEMBASE 0x%x \n",
-				 dwExtProgVirtMem);
-
-			pDevContext->dwDspExtBaseAddr =
-				(u32)MEM_LinearAddress((void *)
-				TO_VIRTUAL_UNCACHED(dwExtProgVirtMem), ulExtEnd
-				- ulExtBase);
-			dwBaseAddr += pDevContext->dwDspExtBaseAddr;
-			/* This dwDspExtBaseAddr will get cleared only when
-			 * the board is stopped.  */
-			if (!pDevContext->dwDspExtBaseAddr) {
-				retVal = DSP_EFAIL;
-				DBG_Trace(DBG_LEVEL7, "WriteExtDspData: failed "
-					 "to Map the program memory\n");
+				cfg_get_host_resources((struct cfg_devnode *)
+						drv_get_first_dev_extension(),
+						&host_res);
+				dw_ext_prog_virt_mem = host_res.dw_mem_base[1];
+				dw_ext_prog_virt_mem +=
+				    (ul_ext_base - ul_dyn_ext_base);
 			}
+
+			dev_context->dw_dsp_ext_base_addr =
+			    (u32) MEM_LINEAR_ADDRESS((void *)
+						     dw_ext_prog_virt_mem,
+						     ul_ext_end - ul_ext_base);
+			dw_base_addr += dev_context->dw_dsp_ext_base_addr;
+			/* This dw_dsp_ext_base_addr will get cleared only when
+			 * the board is stopped. */
+			if (!dev_context->dw_dsp_ext_base_addr)
+				ret = DSP_EFAIL;
 		}
 	}
-	if (!dwBaseAddr || !ulExtBase || !ulExtEnd) {
-		DBG_Trace(DBG_LEVEL7, "Symbols missing for Ext Prog loading\n");
-		retVal = DSP_EFAIL;
-	}
-	if (DSP_SUCCEEDED(retVal)) {
+	if (!dw_base_addr || !ul_ext_base || !ul_ext_end)
+		ret = DSP_EFAIL;
+
+	if (DSP_SUCCEEDED(ret)) {
 		for (i = 0; i < 4; i++)
-			remainByte[i] = 0x0;
+			remain_byte[i] = 0x0;
 
-		dwOffset = dwDSPAddr - ulExtBase;
-		/* Also make sure the dwDSPAddr is < ulExtEnd */
-		if (dwDSPAddr > ulExtEnd || dwOffset > dwDSPAddr) {
-			DBG_Trace(DBG_LEVEL7, "We can not load at this address "
-				 "dwDSPAddr=0x%x, ulExt/DynBase=0x%x, "
-				 "ulExtEnd=0x%x\n", dwDSPAddr, ulExtBase,
-				 ulExtEnd);
-			retVal = DSP_EFAIL;
-		}
-	}
-	if (DSP_SUCCEEDED(retVal)) {
-		if (ulNumBytes)
-			memcpy((u8 *) dwBaseAddr + dwOffset, pbHostBuf,
-				ulNumBytes);
+		dw_offset = dwDSPAddr - ul_ext_base;
+		/* Also make sure the dwDSPAddr is < ul_ext_end */
+		if (dwDSPAddr > ul_ext_end || dw_offset > dwDSPAddr)
+			ret = DSP_EFAIL;
+	}
+	if (DSP_SUCCEEDED(ret)) {
+		if (ul_num_bytes)
+			memcpy((u8 *) dw_base_addr + dw_offset, pbHostBuf,
+			       ul_num_bytes);
 		else
-			*((u32 *) pbHostBuf) = dwBaseAddr+dwOffset;
+			*((u32 *) pbHostBuf) = dw_base_addr + dw_offset;
 	}
 	/* Unmap here to force remap for other Ext loads */
-	if ((bDynamicLoad || bTraceLoad) && pDevContext->dwDspExtBaseAddr) {
-		MEM_UnmapLinearAddress((void *) pDevContext->dwDspExtBaseAddr);
-		pDevContext->dwDspExtBaseAddr = 0x0;
+	if ((bDynamicLoad || trace_load) && dev_context->dw_dsp_ext_base_addr) {
+		MEM_UNMAP_LINEAR_ADDRESS((void *)
+					 dev_context->dw_dsp_ext_base_addr);
+		dev_context->dw_dsp_ext_base_addr = 0x0;
 	}
-	bSymbolsReloaded = false;
-	return retVal;
+	symbols_reloaded = false;
+	return ret;
 }
 
+dsp_status sm_interrupt_dsp(struct wmd_dev_context *dev_context, u16 mb_val)
+{
+	dsp_status status = DSP_SOK;
+
+	if (!dev_context->mbox)
+		return DSP_SOK;
+
+	status = wake_dsp(dev_context, NULL);
+	if (status)
+		return status;
+
+	status = omap_mbox_msg_send(dev_context->mbox, mb_val);
+
+	if (status) {
+		pr_err("omap_mbox_msg_send Fail and status = %d\n", status);
+		status = DSP_EFAIL;
+	}
+
+	return DSP_SOK;
+}
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/tiomap_io.h kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/tiomap_io.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/tiomap_io.h	2011-10-11 13:51:02.269540523 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/tiomap_io.h	2011-10-23 08:22:37.693701000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definitions, types and function prototypes for the io (r/w external mem).
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,18 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _tiomap_io.h ========
- *  Description:
- *      Definitions, types and function prototypes for the io
- *      (r/w external mem).
- *
- *! Revision History
- *! ================
- *! 08-Oct-2002 rr:  Created.
- */
-
 #ifndef _TIOMAP_IO_
 #define _TIOMAP_IO_
 
@@ -43,70 +33,72 @@
 #define IVAEXTMEMBASE   "_IVAEXTMEM_BEG"
 #define IVAEXTMEMEND   "_IVAEXTMEM_END"
 
-
 #define DSP_TRACESEC_BEG  "_BRIDGE_TRACE_BEG"
 #define DSP_TRACESEC_END  "_BRIDGE_TRACE_END"
 
 #define SYS_PUTCBEG               "_SYS_PUTCBEG"
 #define SYS_PUTCEND               "_SYS_PUTCEND"
-#define BRIDGE_SYS_PUTC_current   "_BRIDGE_SYS_PUTC_current"
-
+#define BRIDGE_SYS_PUTC_CURRENT   "_BRIDGE_SYS_PUTC_current"
 
 #define WORDSWAP_ENABLE 0x3	/* Enable word swap */
 
 /*
- *  ======== ReadExtDspData ========
+ *  ======== read_ext_dsp_data ========
  *  Reads it from DSP External memory. The external memory for the DSP
- * is configured by the combination of DSP MMU and SHM Memory manager in the CDB
+ * is configured by the combination of DSP MMU and shm Memory manager in the CDB
  */
-extern DSP_STATUS ReadExtDspData(struct WMD_DEV_CONTEXT *pDevContext,
-				OUT u8 *pbHostBuf, u32 dwDSPAddr,
-				u32 ulNumBytes, u32 ulMemType);
+extern dsp_status read_ext_dsp_data(struct wmd_dev_context *dev_context,
+				    OUT u8 *pbHostBuf, u32 dwDSPAddr,
+				    u32 ul_num_bytes, u32 ulMemType);
 
 /*
- *  ======== WriteDspData ========
+ *  ======== write_dsp_data ========
  */
-extern DSP_STATUS WriteDspData(struct WMD_DEV_CONTEXT *pDevContext,
-			       OUT u8 *pbHostBuf, u32 dwDSPAddr,
-			       u32 ulNumBytes, u32 ulMemType);
+extern dsp_status write_dsp_data(struct wmd_dev_context *dev_context,
+				 OUT u8 *pbHostBuf, u32 dwDSPAddr,
+				 u32 ul_num_bytes, u32 ulMemType);
 
 /*
- *  ======== WriteExtDspData ========
+ *  ======== write_ext_dsp_data ========
  *  Writes to the DSP External memory for external program.
  *  The ext mem for progra is configured by the combination of DSP MMU and
- *  SHM Memory manager in the CDB
+ *  shm Memory manager in the CDB
  */
-extern DSP_STATUS WriteExtDspData(struct WMD_DEV_CONTEXT *pDevContext,
-				 IN u8 *pbHostBuf, u32 dwDSPAddr,
-				 u32 ulNumBytes, u32 ulMemType,
-				 bool bDynamicLoad);
+extern dsp_status write_ext_dsp_data(struct wmd_dev_context *dev_context,
+				     IN u8 *pbHostBuf, u32 dwDSPAddr,
+				     u32 ul_num_bytes, u32 ulMemType,
+				     bool bDynamicLoad);
 
 /*
- * ======== WriteExt32BitDspData ========
+ * ======== write_ext32_bit_dsp_data ========
  * Writes 32 bit data to the external memory
  */
-extern inline void WriteExt32BitDspData(IN const
-		struct WMD_DEV_CONTEXT *pDevContext, IN u32 dwDSPAddr,
-		IN u32 val)
+extern inline void write_ext32_bit_dsp_data(IN const
+					    struct wmd_dev_context *dev_context,
+					    IN u32 dwDSPAddr, IN u32 val)
 {
-	*(u32 *)dwDSPAddr = ((pDevContext->tcWordSwapOn) ? (((val << 16) &
-			      0xFFFF0000) | ((val >> 16) & 0x0000FFFF)) : val);
+	*(u32 *) dwDSPAddr = ((dev_context->tc_word_swap_on) ? (((val << 16) &
+								 0xFFFF0000) |
+								((val >> 16) &
+								 0x0000FFFF)) :
+			      val);
 }
 
 /*
- * ======== ReadExt32BitDspData ========
+ * ======== read_ext32_bit_dsp_data ========
  * Reads 32 bit data from the external memory
  */
-extern inline u32 ReadExt32BitDspData(IN const struct WMD_DEV_CONTEXT
-				       *pDevContext, IN u32 dwDSPAddr)
+extern inline u32 read_ext32_bit_dsp_data(IN const struct wmd_dev_context
+					  *dev_context, IN u32 dwDSPAddr)
 {
-	u32 retVal;
-	retVal = *(u32 *)dwDSPAddr;
+	u32 ret;
+	ret = *(u32 *) dwDSPAddr;
 
-	retVal = ((pDevContext->tcWordSwapOn) ? (((retVal << 16)
-		 & 0xFFFF0000) | ((retVal >> 16) & 0x0000FFFF)) : retVal);
-	return retVal;
+	ret = ((dev_context->tc_word_swap_on) ? (((ret << 16)
+						  & 0xFFFF0000) | ((ret >> 16) &
+								   0x0000FFFF))
+	       : ret);
+	return ret;
 }
 
-#endif				/* _TIOMAP_IO_ */
-
+#endif /* _TIOMAP_IO_ */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/_tiomap_mmu.h kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/_tiomap_mmu.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/_tiomap_mmu.h	2011-10-11 13:51:02.269540523 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/_tiomap_mmu.h	2011-10-23 08:22:37.693701000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definitions and types for the DSP MMU modules.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,40 +16,26 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _tiomap_mmu.h ========
- *  Description:
- *      Definitions and types for the DSP MMU modules
- *
- *! Revision History
- *! ================
- *! 19-Apr-2004 sb:  Renamed HW types. Removed dspMmuTlbEntry
- *! 05-Jan-2004 vp:  Moved the file to a platform specific folder from common.
- *! 21-Mar-2003 sb:  Added macro definition TIHEL_LARGEPAGESIZE
- *! 08-Oct-2002 rr:  Created.
- */
-
 #ifndef _TIOMAP_MMU_
 #define _TIOMAP_MMU_
 
 #include "_tiomap.h"
 
 /*
- *  ======== configureDspMmu ========
+ *  ======== configure_dsp_mmu ========
  *
  *  Make DSP MMu page table entries.
  *  Note: Not utilizing Coarse / Fine page tables.
  *  SECTION = 1MB, LARGE_PAGE = 64KB, SMALL_PAGE = 4KB, TINY_PAGE = 1KB.
  *  DSP Byte address 0x40_0000 is word addr 0x20_0000.
  */
-extern void configureDspMmu(struct WMD_DEV_CONTEXT *pDevContext,
-			    u32 dataBasePhys,
-			    u32 dspBaseVirt,
-			    u32 sizeInBytes,
-			    s32 nEntryStart,
-			    enum HW_Endianism_t endianism,
-			    enum HW_ElementSize_t elemSize,
-			    enum HW_MMUMixedSize_t mixedSize);
+extern void configure_dsp_mmu(struct wmd_dev_context *dev_context,
+			      u32 dataBasePhys,
+			      u32 dspBaseVirt,
+			      u32 sizeInBytes,
+			      s32 nEntryStart,
+			      enum hw_endianism_t endianism,
+			      enum hw_element_size_t elem_size,
+			      enum hw_mmu_mixed_size_t mixed_size);
 
-#endif				/* _TIOMAP_MMU_ */
+#endif /* _TIOMAP_MMU_ */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/_tiomap_pwr.h kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/_tiomap_pwr.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/_tiomap_pwr.h	2011-10-11 13:51:02.269540523 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/_tiomap_pwr.h	2011-10-29 20:32:38.512193043 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definitions and types for the DSP wake/sleep routines.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,89 +16,77 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _tiomap_pwr.h ========
- *  Description:
- *      Definitions and types for the DSP wake/sleep routines.
- *
- *! Revision History
- *! ================
- *! 08-Oct-2002 rr:  Created.
- */
-
 #ifndef _TIOMAP_PWR_
 #define _TIOMAP_PWR_
 
 /*
- * ======== WakeDSP =========
+ * ======== wake_dsp =========
  * Wakes up the DSP from DeepSleep
  */
-extern DSP_STATUS WakeDSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs);
+extern dsp_status wake_dsp(struct wmd_dev_context *dev_context, IN void *pargs);
 
 /*
- * ======== SleepDSP =========
+ * ======== sleep_dsp =========
  * Places the DSP in DeepSleep.
  */
-extern DSP_STATUS SleepDSP(struct WMD_DEV_CONTEXT *pDevContext,
-			   IN u32 dwCmd, IN void *pArgs);
+extern dsp_status sleep_dsp(struct wmd_dev_context *dev_context,
+			    IN u32 dw_cmd, IN void *pargs);
 /*
- *  ========InterruptDSP========
+ *  ========interrupt_dsp========
  *  	  Sends an interrupt to DSP unconditionally.
  */
-extern void InterruptDSP(struct WMD_DEV_CONTEXT *pDevContext, IN u16 wMbVal);
+extern void interrupt_dsp(struct wmd_dev_context *dev_context, IN u16 mb_val);
 
 /*
- * ======== WakeDSP =========
+ * ======== wake_dsp =========
  * Wakes up the DSP from DeepSleep
  */
-extern DSP_STATUS DSPPeripheralClkCtrl(struct WMD_DEV_CONTEXT *pDevContext,
-				       IN void *pArgs);
+extern dsp_status dsp_peripheral_clk_ctrl(struct wmd_dev_context *dev_context,
+					  IN void *pargs);
 /*
- *  ======== handle_hibernation_fromDSP ========
+ *  ======== handle_hibernation_from_dsp ========
  *  	Handle Hibernation requested from DSP
  */
-DSP_STATUS handle_hibernation_fromDSP(struct WMD_DEV_CONTEXT *pDevContext);
+dsp_status handle_hibernation_from_dsp(struct wmd_dev_context *dev_context);
 /*
- *  ======== PostScale_DSP ========
+ *  ======== post_scale_dsp ========
  *  	Handle Post Scale notification to DSP
  */
-DSP_STATUS PostScale_DSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs);
+dsp_status post_scale_dsp(struct wmd_dev_context *dev_context, IN void *pargs);
 /*
- *  ======== PreScale_DSP ========
+ *  ======== pre_scale_dsp ========
  *  	Handle Pre Scale notification to DSP
  */
-DSP_STATUS PreScale_DSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs);
+dsp_status pre_scale_dsp(struct wmd_dev_context *dev_context, IN void *pargs);
 /*
  *  ======== handle_constraints_set ========
  *  	Handle constraints request from DSP
  */
-DSP_STATUS handle_constraints_set(struct WMD_DEV_CONTEXT *pDevContext,
-				 IN void *pArgs);
+dsp_status handle_constraints_set(struct wmd_dev_context *dev_context,
+				  IN void *pargs);
 /*
- *  ======== DSP_PeripheralClocks_Disable ========
+ *  ======== dsp_peripheral_clocks_disable ========
  *  	This function disables all the peripheral clocks that
  *	were enabled by DSP. Call this function only when
  *	DSP is entering Hibernation or when DSP is in
  *	Error state
  */
-DSP_STATUS DSP_PeripheralClocks_Disable(struct WMD_DEV_CONTEXT *pDevContext,
-					IN void *pArgs);
+dsp_status dsp_peripheral_clocks_disable(struct wmd_dev_context *dev_context,
+					 IN void *pargs);
 
 /*
- *  ======== DSP_PeripheralClocks_Enable ========
+ *  ======== dsp_peripheral_clocks_enable ========
  *  	This function enables all the peripheral clocks that
  *	were requested by DSP.
  */
-DSP_STATUS DSP_PeripheralClocks_Enable(struct WMD_DEV_CONTEXT *pDevContext,
-				       IN void *pArgs);
+dsp_status dsp_peripheral_clocks_enable(struct wmd_dev_context *dev_context,
+					IN void *pargs);
 
 /*
- *  ======== DSPClkWakeupEventCtrl ========
+ *  ======== dsp_clk_wakeup_event_ctrl ========
  *     This function sets the group selction bits for while
  *     enabling/disabling.
  */
-void DSPClkWakeupEventCtrl(u32 ClkId, bool enable);
-
-#endif				/* _TIOMAP_PWR_ */
+void dsp_clk_wakeup_event_ctrl(u32 ClkId, bool enable);
 
+#endif /* _TIOMAP_PWR_ */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/tiomap_sm.c kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/tiomap_sm.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/tiomap_sm.c	2011-10-11 13:51:02.352617853 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/tiomap_sm.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,197 +0,0 @@
-/*
- * tiomap_sm.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#include <dspbridge/dbdefs.h>
-#include <dspbridge/errbase.h>
-
-#include <dspbridge/cfg.h>
-#include <dspbridge/drv.h>
-#include <dspbridge/dev.h>
-
-#include <dspbridge/dbg.h>
-
-#include "_tiomap.h"
-#include "_tiomap_pwr.h"
-
-#define MAILBOX_FIFOSTATUS(m) (0x80 + 4 * (m))
-
-extern unsigned short min_active_opp;
-
-static inline unsigned int fifo_full(void __iomem *mbox_base, int mbox_id)
-{
-	return __raw_readl(mbox_base + MAILBOX_FIFOSTATUS(mbox_id)) & 0x1;
-}
-
-DSP_STATUS CHNLSM_EnableInterrupt(struct WMD_DEV_CONTEXT *pDevContext)
-{
-	DSP_STATUS status = DSP_SOK;
-	u32 numMbxMsg;
-	u32 mbxValue;
-	struct CFG_HOSTRES resources;
-	u32 devType;
-	struct IO_MGR *hIOMgr;
-
-	DBG_Trace(DBG_ENTER, "CHNLSM_EnableInterrupt(0x%x)\n", pDevContext);
-
-	/* Read the messages in the mailbox until the message queue is empty */
-
-	CFG_GetHostResources((struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
-			     &resources);
-	DEV_GetDevType(pDevContext->hDevObject, &devType);
-	status = DEV_GetIOMgr(pDevContext->hDevObject, &hIOMgr);
-	if (devType == DSP_UNIT) {
-		HW_MBOX_NumMsgGet(resources.dwMboxBase,
-				  MBOX_DSP2ARM, &numMbxMsg);
-		while (numMbxMsg != 0) {
-			HW_MBOX_MsgRead(resources.dwMboxBase,
-					MBOX_DSP2ARM,
-					&mbxValue);
-			numMbxMsg--;
-		}
-		/* clear the DSP mailbox as well...*/
-		HW_MBOX_NumMsgGet(resources.dwMboxBase,
-				  MBOX_ARM2DSP, &numMbxMsg);
-		while (numMbxMsg != 0) {
-			HW_MBOX_MsgRead(resources.dwMboxBase,
-					MBOX_ARM2DSP, &mbxValue);
-			numMbxMsg--;
-			udelay(10);
-
-			HW_MBOX_EventAck(resources.dwMboxBase, MBOX_ARM2DSP,
-					 HW_MBOX_U1_DSP1,
-					 HW_MBOX_INT_NEW_MSG);
-		}
-		/* Enable the new message events on this IRQ line */
-		HW_MBOX_EventEnable(resources.dwMboxBase,
-				    MBOX_DSP2ARM,
-				    MBOX_ARM,
-				    HW_MBOX_INT_NEW_MSG);
-	}
-
-	return status;
-}
-
-DSP_STATUS CHNLSM_DisableInterrupt(struct WMD_DEV_CONTEXT *pDevContext)
-{
-	struct CFG_HOSTRES resources;
-
-	DBG_Trace(DBG_ENTER, "CHNLSM_DisableInterrupt(0x%x)\n", pDevContext);
-
-	CFG_GetHostResources((struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
-			     &resources);
-	HW_MBOX_EventDisable(resources.dwMboxBase, MBOX_DSP2ARM,
-			     MBOX_ARM, HW_MBOX_INT_NEW_MSG);
-	return DSP_SOK;
-}
-
-DSP_STATUS CHNLSM_InterruptDSP2(struct WMD_DEV_CONTEXT *pDevContext,
-				u16 wMbVal)
-{
-	struct CFG_HOSTRES resources;
-	DSP_STATUS status = DSP_SOK;
-	unsigned long timeout;
-	u32 temp;
-
-	status = CFG_GetHostResources((struct CFG_DEVNODE *)
-			DRV_GetFirstDevExtension(), &resources);
-	if (DSP_FAILED(status))
-		return DSP_EFAIL;
-
-	if (pDevContext->dwBrdState == BRD_DSP_HIBERNATION ||
-	    pDevContext->dwBrdState == BRD_HIBERNATION) {
-#ifdef CONFIG_BRIDGE_DVFS
-		struct dspbridge_platform_data *pdata =
-			omap_dspbridge_dev->dev.platform_data;
-		/*
-		 * When Smartreflex is ON, DSP requires at least OPP level 3
-		 * to operate reliably. So boost lower OPP levels to OPP3.
-		 */
-		if (pdata->dsp_set_min_opp)
-			(*pdata->dsp_set_min_opp)(min_active_opp);
-#endif
-		/* Restart the peripheral clocks */
-		DSP_PeripheralClocks_Enable(pDevContext, NULL);
-
-		/*
-		 * 2:0 AUTO_IVA2_DPLL - Enabling IVA2 DPLL auto control
-		 *     in CM_AUTOIDLE_PLL_IVA2 register
-		 */
-		*(REG_UWORD32 *)(resources.dwCmBase + 0x34) = 0x1;
-
-		/*
-		 * 7:4 IVA2_DPLL_FREQSEL - IVA2 internal frq set to
-		 *     0.75 MHz - 1.0 MHz
-		 * 2:0 EN_IVA2_DPLL - Enable IVA2 DPLL in lock mode
-		 */
-		temp = *(REG_UWORD32 *)(resources.dwCmBase + 0x4);
-		temp = (temp & 0xFFFFFF08) | 0x37;
-		*(REG_UWORD32 *)(resources.dwCmBase + 0x4) = temp;
-
-		/*
-		 * This delay is needed to avoid mailbox timed out
-		 * issue experienced while SmartReflex is ON.
-		 * TODO: Instead of 1 ms calculate proper value.
-		 */
-		mdelay(1);
-
-		/* Restore mailbox settings */
-		HW_MBOX_restoreSettings(resources.dwMboxBase);
-
-		/* Access MMU SYS CONFIG register to generate a short wakeup */
-		temp = *(REG_UWORD32 *)(resources.dwDmmuBase + 0x10);
-
-		pDevContext->dwBrdState = BRD_RUNNING;
-	}
-
-	timeout = jiffies + msecs_to_jiffies(1);
-	while (fifo_full((void __iomem *) resources.dwMboxBase, 0)) {
-		if (time_after(jiffies, timeout)) {
-			pr_err("dspbridge: timed out waiting for mailbox\n");
-			return WMD_E_TIMEOUT;
-		}
-	}
-
-	DBG_Trace(DBG_LEVEL3, "writing %x to Mailbox\n", wMbVal);
-	HW_MBOX_MsgWrite(resources.dwMboxBase, MBOX_ARM2DSP, wMbVal);
-	return DSP_SOK;
-}
-
-bool CHNLSM_ISR(struct WMD_DEV_CONTEXT *pDevContext, bool *pfSchedDPC,
-		u16 *pwIntrVal)
-{
-	struct CFG_HOSTRES resources;
-	u32 numMbxMsg;
-	u32 mbxValue;
-
-	DBG_Trace(DBG_ENTER, "CHNLSM_ISR(0x%x)\n", pDevContext);
-
-	CFG_GetHostResources((struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
-
-	HW_MBOX_NumMsgGet(resources.dwMboxBase, MBOX_DSP2ARM, &numMbxMsg);
-
-	if (numMbxMsg > 0) {
-		HW_MBOX_MsgRead(resources.dwMboxBase, MBOX_DSP2ARM, &mbxValue);
-
-		HW_MBOX_EventAck(resources.dwMboxBase, MBOX_DSP2ARM,
-				 HW_MBOX_U0_ARM, HW_MBOX_INT_NEW_MSG);
-
-		DBG_Trace(DBG_LEVEL3, "Read %x from Mailbox\n", mbxValue);
-		*pwIntrVal = (u16) mbxValue;
-	}
-	/* Set *pfSchedDPC to true; */
-	*pfSchedDPC = true;
-	return true;
-}
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/_tiomap_util.h kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/_tiomap_util.h
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/_tiomap_util.h	2011-10-11 13:51:02.352617853 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/_tiomap_util.h	2011-10-23 08:22:37.693701000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definitions and types for the utility routines.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,33 +16,28 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _tiomap_util.h ========
- *  Description:
- *      Definitions and types for the utility routines.
- *
- *! Revision History
- *! ================
- *! 08-Oct-2002 rr:  Created.
- */
-
 #ifndef _TIOMAP_UTIL_
 #define _TIOMAP_UTIL_
 
-/* Time out Values in uSeconds*/
+/* Time out Values in uSeconds */
 #define TIHELEN_ACKTIMEOUT  10000
 
+/*
+ * Time out for power state transition (in msecs), due to system
+ * latencies and HZ resolution this timer can vary.
+ */
+#define PWRSTST_TIMEOUT		200
+
 /*  Time delay for HOM->SAM transition. */
 #define  WAIT_SAM   1000000	/* in usec (1000 millisec) */
 
 /*
- *  ======== WaitForStart ========
+ *  ======== wait_for_start ========
  *  Wait for the singal from DSP that it has started, or time out.
- *  The argument dwSyncAddr is set to 1 before releasing the DSP.
+ *  The argument dw_sync_addr is set to 1 before releasing the DSP.
  *  If the DSP starts running, it will clear this location.
  */
-extern bool WaitForStart(struct WMD_DEV_CONTEXT *pDevContext, u32 dwSyncAddr);
-
-#endif				/* _TIOMAP_UTIL_ */
+extern bool wait_for_start(struct wmd_dev_context *dev_context,
+			   u32 dw_sync_addr);
 
+#endif /* _TIOMAP_UTIL_ */
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/ue_deh.c kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/ue_deh.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/ue_deh.c	2011-10-11 13:51:02.425778233 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/ue_deh.c	2011-10-23 08:22:37.693701000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implements upper edge DSP exception handling (DEH) functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,23 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== ue_deh.c ========
- *  Description:
- *      Implements upper edge DSP exception handling (DEH) functions.
- *
- *! Revision History:
- *! ================
- *! 03-Jan-2005 hn: Support for IVA DEH.
- *! 05-Jan-2004 vp: Updated for the 24xx HW library.
- *! 19-Feb-2003 vp: Code review updates.
- *!                 - Cosmetic changes.
- *! 18-Oct-2002 sb: Ported to Linux platform.
- *! 10-Dec-2001 kc: Updated DSP error reporting in DEBUG mode.
- *! 10-Sep-2001 kc: created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -41,12 +26,9 @@
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
-#include <dspbridge/dbg.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/cfg.h>
-#include <dspbridge/dpc.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/ntfy.h>
 #include <dspbridge/drv.h>
@@ -57,6 +39,7 @@
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/dev.h>
 #include <dspbridge/wcd.h>
+#include <dspbridge/wdt.h>
 
 /* ------------------------------------ Hardware Abstraction Layer */
 #include <hw_defs.h>
@@ -70,302 +53,282 @@
 #include "_tiomap_pwr.h"
 #include <dspbridge/io_sm.h>
 
-static struct HW_MMUMapAttrs_t  mapAttrs = { HW_LITTLE_ENDIAN,
-					HW_ELEM_SIZE_16BIT,
-					HW_MMU_CPUES} ;
-#define VirtToPhys(x)       ((x) - PAGE_OFFSET + PHYS_OFFSET)
+static struct hw_mmu_map_attrs_t map_attrs = { HW_LITTLE_ENDIAN,
+	HW_ELEM_SIZE16BIT,
+	HW_MMU_CPUES
+};
+
+#define VIRT_TO_PHYS(x)       ((x) - PAGE_OFFSET + PHYS_OFFSET)
 
-static u32 dummyVaAddr;
 /*
- *  ======== WMD_DEH_Create ========
+ *  ======== bridge_deh_create ========
  *      Creates DEH manager object.
  */
-DSP_STATUS WMD_DEH_Create(OUT struct DEH_MGR **phDehMgr,
-			 struct DEV_OBJECT *hDevObject)
+dsp_status bridge_deh_create(OUT struct deh_mgr **phDehMgr,
+			     struct dev_object *hdev_obj)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEH_MGR *pDehMgr = NULL;
-	struct CFG_HOSTRES cfgHostRes;
-	struct CFG_DEVNODE *hDevNode;
-	struct WMD_DEV_CONTEXT *hWmdContext = NULL;
+	dsp_status status = DSP_SOK;
+	struct deh_mgr *deh_mgr_obj = NULL;
+	struct cfg_hostres cfg_host_res;
+	struct cfg_devnode *dev_node_obj;
+	struct wmd_dev_context *hwmd_context = NULL;
 
-	DBG_Trace(DBG_LEVEL1, "Entering DEH_Create: 0x%x\n", phDehMgr);
-	 /*  Message manager will be created when a file is loaded, since
+	/*  Message manager will be created when a file is loaded, since
 	 *  size of message buffer in shared memory is configurable in
-	 *  the base image.  */
+	 *  the base image. */
 	/* Get WMD context info. */
-	DEV_GetWMDContext(hDevObject, &hWmdContext);
-	DBC_Assert(hWmdContext);
-	dummyVaAddr = 0;
+	dev_get_wmd_context(hdev_obj, &hwmd_context);
+	DBC_ASSERT(hwmd_context);
 	/* Allocate IO manager object: */
-	MEM_AllocObject(pDehMgr, struct DEH_MGR, SIGNATURE);
-	if (pDehMgr == NULL) {
+	MEM_ALLOC_OBJECT(deh_mgr_obj, struct deh_mgr, SIGNATURE);
+	if (deh_mgr_obj == NULL) {
 		status = DSP_EMEMORY;
 	} else {
 		/* Create an NTFY object to manage notifications */
-		if (DSP_SUCCEEDED(status))
-			status = NTFY_Create(&pDehMgr->hNtfy);
+		status = ntfy_create(&deh_mgr_obj->ntfy_obj);
+
+		/* Create a MMUfault DPC */
+		tasklet_init(&deh_mgr_obj->dpc_tasklet, mmu_fault_dpc,
+			     (u32) deh_mgr_obj);
 
-		/* Create a DPC object. */
-		status = DPC_Create(&pDehMgr->hMmuFaultDpc, MMU_FaultDpc,
-				   (void *)pDehMgr);
 		if (DSP_SUCCEEDED(status))
-			status = DEV_GetDevNode(hDevObject, &hDevNode);
+			status = dev_get_dev_node(hdev_obj, &dev_node_obj);
 
 		if (DSP_SUCCEEDED(status))
-			status = CFG_GetHostResources(hDevNode, &cfgHostRes);
+			status =
+			    cfg_get_host_resources(dev_node_obj, &cfg_host_res);
 
 		if (DSP_SUCCEEDED(status)) {
 			/* Fill in context structure */
-			pDehMgr->hWmdContext = hWmdContext;
-			pDehMgr->errInfo.dwErrMask = 0L;
-			pDehMgr->errInfo.dwVal1 = 0L;
-			pDehMgr->errInfo.dwVal2 = 0L;
-			pDehMgr->errInfo.dwVal3 = 0L;
+			deh_mgr_obj->hwmd_context = hwmd_context;
+			deh_mgr_obj->err_info.dw_err_mask = 0L;
+			deh_mgr_obj->err_info.dw_val1 = 0L;
+			deh_mgr_obj->err_info.dw_val2 = 0L;
+			deh_mgr_obj->err_info.dw_val3 = 0L;
 			/* Install ISR function for DSP MMU fault */
-                       if ((request_irq(INT_DSP_MMU_IRQ, MMU_FaultIsr, 0,
-                                           "DspBridge\tiommu fault", (void *)pDehMgr)) == 0)
-                               status = DSP_SOK;
-                       else
-                               status = DSP_EFAIL;
+			if ((request_irq(INT_DSP_MMU_IRQ, mmu_fault_isr, 0,
+					 "DspBridge\tiommu fault",
+					 (void *)deh_mgr_obj)) == 0)
+				status = DSP_SOK;
+			else
+				status = DSP_EFAIL;
 		}
 	}
 	if (DSP_FAILED(status)) {
 		/* If create failed, cleanup */
-		WMD_DEH_Destroy((struct DEH_MGR *)pDehMgr);
+		bridge_deh_destroy((struct deh_mgr *)deh_mgr_obj);
 		*phDehMgr = NULL;
 	} else {
-		*phDehMgr = (struct DEH_MGR *)pDehMgr;
-               DBG_Trace(DBG_LEVEL1, "ISR_IRQ Object 0x%x \n",
-                                        pDehMgr);
+		*phDehMgr = (struct deh_mgr *)deh_mgr_obj;
 	}
-	DBG_Trace(DBG_LEVEL1, "Exiting DEH_Create.\n");
+
 	return status;
 }
 
 /*
- *  ======== WMD_DEH_Destroy ========
+ *  ======== bridge_deh_destroy ========
  *      Destroys DEH manager object.
  */
-DSP_STATUS WMD_DEH_Destroy(struct DEH_MGR *hDehMgr)
+dsp_status bridge_deh_destroy(struct deh_mgr *hdeh_mgr)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)hDehMgr;
+	dsp_status status = DSP_SOK;
+	struct deh_mgr *deh_mgr_obj = (struct deh_mgr *)hdeh_mgr;
 
-	DBG_Trace(DBG_LEVEL1, "Entering DEH_Destroy: 0x%x\n", pDehMgr);
-	if (MEM_IsValidHandle(pDehMgr, SIGNATURE)) {
+	if (MEM_IS_VALID_HANDLE(deh_mgr_obj, SIGNATURE)) {
 		/* Release dummy VA buffer */
-		WMD_DEH_ReleaseDummyMem();
+		bridge_deh_release_dummy_mem();
 		/* If notification object exists, delete it */
-		if (pDehMgr->hNtfy)
-			(void)NTFY_Delete(pDehMgr->hNtfy);
+		if (deh_mgr_obj->ntfy_obj)
+			(void)ntfy_delete(deh_mgr_obj->ntfy_obj);
 		/* Disable DSP MMU fault */
-               free_irq(INT_DSP_MMU_IRQ, pDehMgr);
-		(void)DPC_Destroy(pDehMgr->hMmuFaultDpc);
+		free_irq(INT_DSP_MMU_IRQ, deh_mgr_obj);
+
+		/* Free DPC object */
+		tasklet_kill(&deh_mgr_obj->dpc_tasklet);
+
 		/* Deallocate the DEH manager object */
-		MEM_FreeObject(pDehMgr);
+		MEM_FREE_OBJECT(deh_mgr_obj);
 	}
-	DBG_Trace(DBG_LEVEL1, "Exiting DEH_Destroy.\n");
+
 	return status;
 }
 
 /*
- *  ======== WMD_DEH_RegisterNotify ========
+ *  ======== bridge_deh_register_notify ========
  *      Registers for DEH notifications.
  */
-DSP_STATUS WMD_DEH_RegisterNotify(struct DEH_MGR *hDehMgr, u32 uEventMask,
-				 u32 uNotifyType,
-				 struct DSP_NOTIFICATION *hNotification)
+dsp_status bridge_deh_register_notify(struct deh_mgr *hdeh_mgr, u32 event_mask,
+				   u32 notify_type,
+				   struct dsp_notification *hnotification)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)hDehMgr;
-
-	DBG_Trace(DBG_LEVEL1, "Entering WMD_DEH_RegisterNotify: 0x%x\n",
-		 pDehMgr);
+	dsp_status status = DSP_SOK;
+	struct deh_mgr *deh_mgr_obj = (struct deh_mgr *)hdeh_mgr;
 
-	if (MEM_IsValidHandle(pDehMgr, SIGNATURE)) {
-		status = NTFY_Register(pDehMgr->hNtfy, hNotification,
-			 uEventMask, uNotifyType);
+	if (MEM_IS_VALID_HANDLE(deh_mgr_obj, SIGNATURE)) {
+		status = ntfy_register(deh_mgr_obj->ntfy_obj, hnotification,
+				       event_mask, notify_type);
 	}
-	DBG_Trace(DBG_LEVEL1, "Exiting WMD_DEH_RegisterNotify.\n");
+
 	return status;
 }
 
-
 /*
- *  ======== WMD_DEH_Notify ========
+ *  ======== bridge_deh_notify ========
  *      DEH error notification function. Informs user about the error.
  */
-void WMD_DEH_Notify(struct DEH_MGR *hDehMgr, u32 ulEventMask,
-			 u32 dwErrInfo)
+void bridge_deh_notify(struct deh_mgr *hdeh_mgr, u32 ulEventMask, u32 dwErrInfo)
 {
-	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)hDehMgr;
-	struct WMD_DEV_CONTEXT *pDevContext;
-	DSP_STATUS status = DSP_SOK;
-	DSP_STATUS status1 = DSP_EFAIL;
-	u32 memPhysical = 0;
-	u32 HW_MMU_MAX_TLB_COUNT = 31;
-	extern u32 faultAddr;
-	struct CFG_HOSTRES resources;
-	HW_STATUS hwStatus;
-
-	status = CFG_GetHostResources(
-			(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
-			&resources);
-	if (DSP_FAILED(status))
-		DBG_Trace(DBG_LEVEL7,
-			 "**Failed to get Host Resources in MMU ISR **\n");
-
-	DBG_Trace(DBG_LEVEL1, "Entering WMD_DEH_Notify: 0x%x, 0x%x\n", pDehMgr,
-		 ulEventMask);
-	if (MEM_IsValidHandle(pDehMgr, SIGNATURE)) {
-		printk(KERN_INFO "WMD_DEH_Notify: ********** DEVICE EXCEPTION "
-			"**********\n");
-		pDevContext = (struct WMD_DEV_CONTEXT *)pDehMgr->hWmdContext;
+	struct deh_mgr *deh_mgr_obj = (struct deh_mgr *)hdeh_mgr;
+	struct wmd_dev_context *dev_context;
+	dsp_status status = DSP_SOK;
+	u32 hw_mmu_max_tlb_count = 31;
+	extern u32 fault_addr;
+	struct cfg_hostres resources;
+	hw_status hw_status_obj;
+
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
+
+	if (MEM_IS_VALID_HANDLE(deh_mgr_obj, SIGNATURE)) {
+		printk(KERN_INFO
+		       "bridge_deh_notify: ********** DEVICE EXCEPTION "
+		       "**********\n");
+		dev_context =
+		    (struct wmd_dev_context *)deh_mgr_obj->hwmd_context;
 
 		switch (ulEventMask) {
 		case DSP_SYSERROR:
-			/* reset errInfo structure before use */
-			pDehMgr->errInfo.dwErrMask = DSP_SYSERROR;
-			pDehMgr->errInfo.dwVal1 = 0L;
-			pDehMgr->errInfo.dwVal2 = 0L;
-			pDehMgr->errInfo.dwVal3 = 0L;
-			pDehMgr->errInfo.dwVal1 = dwErrInfo;
-			printk(KERN_ERR "WMD_DEH_Notify: DSP_SYSERROR, errInfo "
-				"= 0x%x\n", dwErrInfo);
+			/* reset err_info structure before use */
+			deh_mgr_obj->err_info.dw_err_mask = DSP_SYSERROR;
+			deh_mgr_obj->err_info.dw_val1 = 0L;
+			deh_mgr_obj->err_info.dw_val2 = 0L;
+			deh_mgr_obj->err_info.dw_val3 = 0L;
+			deh_mgr_obj->err_info.dw_val1 = dwErrInfo;
+			printk(KERN_ERR
+			       "bridge_deh_notify: DSP_SYSERROR, err_info "
+			       "= 0x%x\n", dwErrInfo);
 			break;
 		case DSP_MMUFAULT:
 			/* MMU fault routine should have set err info
 			 * structure */
-			pDehMgr->errInfo.dwErrMask = DSP_MMUFAULT;
-			printk(KERN_INFO "WMD_DEH_Notify: DSP_MMUFAULT,"
-				"errInfo = 0x%x\n", dwErrInfo);
-			printk(KERN_INFO "WMD_DEH_Notify: DSP_MMUFAULT, High "
-				"Address = 0x%x\n",
-				(unsigned int)pDehMgr->errInfo.dwVal1);
-			printk(KERN_INFO "WMD_DEH_Notify: DSP_MMUFAULT, Low "
-				"Address = 0x%x\n",
-				(unsigned int)pDehMgr->errInfo.dwVal2);
-			printk(KERN_INFO "WMD_DEH_Notify: DSP_MMUFAULT, fault "
-				"address = 0x%x\n", (unsigned int)faultAddr);
-			dummyVaAddr = (u32)MEM_Calloc(sizeof(char) * 0x1000,
-					MEM_PAGED);
-			memPhysical  = VirtToPhys(PG_ALIGN_LOW((u32)dummyVaAddr,
-								PG_SIZE_4K));
-DBG_Trace(DBG_LEVEL6, "WMD_DEH_Notify: DSP_MMUFAULT, "
-				 "mem Physical= 0x%x\n", memPhysical);
-			pDevContext = (struct WMD_DEV_CONTEXT *)
-						pDehMgr->hWmdContext;
+			deh_mgr_obj->err_info.dw_err_mask = DSP_MMUFAULT;
+			printk(KERN_INFO "bridge_deh_notify: DSP_MMUFAULT,"
+			       "err_info = 0x%x\n", dwErrInfo);
+			printk(KERN_INFO
+			       "bridge_deh_notify: DSP_MMUFAULT, High "
+			       "Address = 0x%x\n",
+			       (unsigned int)deh_mgr_obj->err_info.dw_val1);
+			printk(KERN_INFO "bridge_deh_notify: DSP_MMUFAULT, Low "
+			       "Address = 0x%x\n",
+			       (unsigned int)deh_mgr_obj->err_info.dw_val2);
+			printk(KERN_INFO
+			       "bridge_deh_notify: DSP_MMUFAULT, fault "
+			       "address = 0x%x\n", (unsigned int)fault_addr);
+			dev_context = (struct wmd_dev_context *)
+			    deh_mgr_obj->hwmd_context;
 			/* Reset the dynamic mmu index to fixed count if it
 			 * exceeds 31. So that the dynmmuindex is always
 			 * between the range of standard/fixed entries
-			 * and 31.  */
-			if (pDevContext->numTLBEntries >
-			   HW_MMU_MAX_TLB_COUNT) {
-				pDevContext->numTLBEntries = pDevContext->
-					fixedTLBEntries;
+			 * and 31. */
+			if (dev_context->num_tlb_entries >
+			    hw_mmu_max_tlb_count) {
+				dev_context->num_tlb_entries =
+				    dev_context->fixed_tlb_entries;
 			}
-			DBG_Trace(DBG_LEVEL6, "Adding TLB Entry %d: VA: 0x%x, "
-				 "PA: 0x%x\n", pDevContext->
-				numTLBEntries, faultAddr, memPhysical);
 			if (DSP_SUCCEEDED(status)) {
-				hwStatus = HW_MMU_TLBAdd(resources.dwDmmuBase,
-					memPhysical, faultAddr,
-					HW_PAGE_SIZE_4KB, 1, &mapAttrs,
-					HW_SET, HW_SET);
+				hw_status_obj =
+				    hw_mmu_tlb_add(resources.dw_dmmu_base,
+						   0, fault_addr,
+						   HW_PAGE_SIZE4KB, 1,
+						   &map_attrs, HW_SET, HW_SET);
 			}
 			/* send an interrupt to DSP */
-			HW_MBOX_MsgWrite(resources.dwMboxBase, MBOX_ARM2DSP,
-					 MBX_DEH_CLASS | MBX_DEH_EMMU);
+			omap_mbox_msg_send(dev_context->mbox,
+						MBX_DEH_CLASS | MBX_DEH_EMMU);
 			/* Clear MMU interrupt */
-			HW_MMU_EventAck(resources.dwDmmuBase,
+			hw_mmu_event_ack(resources.dw_dmmu_base,
 					 HW_MMU_TRANSLATION_FAULT);
 			break;
+#ifdef CONFIG_BRIDGE_NTFY_PWRERR
 		case DSP_PWRERROR:
-			/* reset errInfo structure before use */
-			pDehMgr->errInfo.dwErrMask = DSP_PWRERROR;
-			pDehMgr->errInfo.dwVal1 = 0L;
-			pDehMgr->errInfo.dwVal2 = 0L;
-			pDehMgr->errInfo.dwVal3 = 0L;
-			pDehMgr->errInfo.dwVal1 = dwErrInfo;
-			printk(KERN_ERR "WMD_DEH_Notify: DSP_PWRERROR, errInfo "
-					"= 0x%x\n", dwErrInfo);
+			/* reset err_info structure before use */
+			deh_mgr_obj->err_info.dw_err_mask = DSP_PWRERROR;
+			deh_mgr_obj->err_info.dw_val1 = 0L;
+			deh_mgr_obj->err_info.dw_val2 = 0L;
+			deh_mgr_obj->err_info.dw_val3 = 0L;
+			deh_mgr_obj->err_info.dw_val1 = dwErrInfo;
+			printk(KERN_ERR
+			       "bridge_deh_notify: DSP_PWRERROR, err_info "
+			       "= 0x%x\n", dwErrInfo);
+			break;
+#endif /* CONFIG_BRIDGE_NTFY_PWRERR */
+		case DSP_WDTOVERFLOW:
+			deh_mgr_obj->err_info.dw_err_mask = DSP_WDTOVERFLOW;
+			deh_mgr_obj->err_info.dw_val1 = 0L;
+			deh_mgr_obj->err_info.dw_val2 = 0L;
+			deh_mgr_obj->err_info.dw_val3 = 0L;
+			dev_err(bridge, "%s: DSP_WDTOVERFLOW\n", __func__);
 			break;
 		default:
-			DBG_Trace(DBG_LEVEL6,
-				 "WMD_DEH_Notify: Unknown Error, errInfo = "
-				 "0x%x\n", dwErrInfo);
+			dev_dbg(bridge, "%s: Unknown Error, err_info = 0x%x\n",
+				__func__, dwErrInfo);
 			break;
 		}
 
 		/* Filter subsequent notifications when an error occurs */
-		if (pDevContext->dwBrdState != BRD_ERROR) {
-			/* Use it as a flag to send notifications the
-			 * first time and error occurred, next time
-			 * state will be BRD_ERROR */
-			status1 = DSP_EFAIL;
+		if (dev_context->dw_brd_state != BRD_ERROR) {
+			ntfy_notify(deh_mgr_obj->ntfy_obj, ulEventMask);
+#ifdef CONFIG_BRIDGE_RECOVERY
+			bridge_recover_schedule();
+#endif
 		}
 
-		/* Filter subsequent notifications when an error occurs */
-		if (pDevContext->dwBrdState != BRD_ERROR)
-			status1 = DSP_SOK;
-
 		/* Set the Board state as ERROR */
-		pDevContext->dwBrdState = BRD_ERROR;
+		dev_context->dw_brd_state = BRD_ERROR;
 		/* Disable all the clocks that were enabled by DSP */
-		(void)DSP_PeripheralClocks_Disable(pDevContext, NULL);
+		(void)dsp_peripheral_clocks_disable(dev_context, NULL);
 		/* Call DSP Trace Buffer */
-		PrintDspTraceBuffer(hDehMgr->hWmdContext);
-
-		if (DSP_SUCCEEDED(status1)) {
-			/* Signal DSP error/exception event. */
-			NTFY_Notify(pDehMgr->hNtfy, ulEventMask);
-		}
-
+		print_dsp_trace_buffer(hdeh_mgr->hwmd_context);
+		/*
+		* Avoid the subsequent WDT if it happens once,
+		* also if fatal error occurs.
+		*/
+		dsp_wdt_enable(false);
 	}
-	DBG_Trace(DBG_LEVEL1, "Exiting WMD_DEH_Notify\n");
-
 }
 
 /*
- *  ======== WMD_DEH_GetInfo ========
+ *  ======== bridge_deh_get_info ========
  *      Retrieves error information.
  */
-DSP_STATUS WMD_DEH_GetInfo(struct DEH_MGR *hDehMgr,
-			  struct DSP_ERRORINFO *pErrInfo)
+dsp_status bridge_deh_get_info(struct deh_mgr *hdeh_mgr,
+			    struct dsp_errorinfo *pErrInfo)
 {
-	DSP_STATUS status = DSP_SOK;
-	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)hDehMgr;
-
-	DBC_Require(pDehMgr);
-	DBC_Require(pErrInfo);
+	dsp_status status = DSP_SOK;
+	struct deh_mgr *deh_mgr_obj = (struct deh_mgr *)hdeh_mgr;
 
-	DBG_Trace(DBG_LEVEL1, "Entering WMD_DEH_GetInfo: 0x%x\n", hDehMgr);
+	DBC_REQUIRE(deh_mgr_obj);
+	DBC_REQUIRE(pErrInfo);
 
-	if (MEM_IsValidHandle(pDehMgr, SIGNATURE)) {
+	if (MEM_IS_VALID_HANDLE(deh_mgr_obj, SIGNATURE)) {
 		/* Copy DEH error info structure to PROC error info
 		 * structure. */
-		pErrInfo->dwErrMask = pDehMgr->errInfo.dwErrMask;
-		pErrInfo->dwVal1 = pDehMgr->errInfo.dwVal1;
-		pErrInfo->dwVal2 = pDehMgr->errInfo.dwVal2;
-		pErrInfo->dwVal3 = pDehMgr->errInfo.dwVal3;
+		pErrInfo->dw_err_mask = deh_mgr_obj->err_info.dw_err_mask;
+		pErrInfo->dw_val1 = deh_mgr_obj->err_info.dw_val1;
+		pErrInfo->dw_val2 = deh_mgr_obj->err_info.dw_val2;
+		pErrInfo->dw_val3 = deh_mgr_obj->err_info.dw_val3;
+	} else {
+		status = DSP_EHANDLE;
 	}
 
-	DBG_Trace(DBG_LEVEL1, "Exiting WMD_DEH_GetInfo\n");
-
 	return status;
 }
 
-
 /*
- *  ======== WMD_DEH_ReleaseDummyMem ========
+ *  ======== bridge_deh_release_dummy_mem ========
  *      Releases memory allocated for dummy page
  */
-void WMD_DEH_ReleaseDummyMem(void)
+void bridge_deh_release_dummy_mem(void)
 {
-	if (dummyVaAddr) {
-		MEM_Free((void *)dummyVaAddr);
-		dummyVaAddr = 0;
-	}
 }
-
diff -urN kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/wdt.c kernel-power-2.6.28.new/drivers/dsp/bridge/wmd/wdt.c
--- kernel-cssu-2.6.28/drivers/dsp/bridge/wmd/wdt.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-cssu-2.6.28.new/drivers/dsp/bridge/wmd/wdt.c	2011-10-23 08:22:37.693701000 +0100
@@ -0,0 +1,147 @@
+/*
+ * wdt.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * IO dispatcher for a shared memory channel driver.
+ *
+ * Copyright (C) 2010 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+#include <dspbridge/wmddeh.h>
+#include <dspbridge/dev.h>
+#include <dspbridge/_chnl_sm.h>
+#include <dspbridge/wdt.h>
+#include <dspbridge/host_os.h>
+
+
+#ifdef CONFIG_BRIDGE_WDT3
+static struct dsp_wdt_setting dsp_wdt;
+
+static void dsp_wdt_dpc(unsigned long data)
+{
+	struct deh_mgr *deh_mgr;
+	dev_get_deh_mgr(dev_get_first(), &deh_mgr);
+	if (deh_mgr)
+		bridge_deh_notify(deh_mgr, DSP_WDTOVERFLOW, 0);
+}
+
+static irqreturn_t dsp_wdt_isr(int irq, void *data)
+{
+	u32 value;
+	/* ack wdt3 interrupt */
+	value = __raw_readl(dsp_wdt.reg_base + OMAP3_WDT3_ISR_OFFSET);
+	__raw_writel(value, dsp_wdt.reg_base + OMAP3_WDT3_ISR_OFFSET);
+
+	tasklet_schedule(&dsp_wdt.wdt3_tasklet);
+	return IRQ_HANDLED;
+}
+
+int dsp_wdt_init(void)
+{
+	int ret = 0;
+
+	dsp_wdt.sm_wdt = NULL;
+	dsp_wdt.reg_base = OMAP2_L4_IO_ADDRESS(OMAP34XX_WDT3_BASE);
+	tasklet_init(&dsp_wdt.wdt3_tasklet, dsp_wdt_dpc, 0);
+
+	dsp_wdt.fclk = clk_get(NULL, "wdt3_fck");
+
+	if (dsp_wdt.fclk) {
+		dsp_wdt.iclk = clk_get(NULL, "wdt3_ick");
+		if (!dsp_wdt.iclk) {
+			clk_put(dsp_wdt.fclk);
+			dsp_wdt.fclk = NULL;
+			ret = -EFAULT;
+		}
+	} else
+		ret = -EFAULT;
+
+	if (!ret)
+		ret = request_irq(INT_34XX_WDT3_IRQ, dsp_wdt_isr, 0,
+							"dsp_wdt", &dsp_wdt);
+
+	/* Disable at this moment, it will be enabled when DSP starts */
+	if (!ret)
+		disable_irq(INT_34XX_WDT3_IRQ);
+
+	return ret;
+}
+
+void dsp_wdt_sm_set(void *data)
+{
+	dsp_wdt.sm_wdt = data;
+	dsp_wdt.sm_wdt->wdt_overflow = CONFIG_WDT_TIMEOUT;
+}
+
+
+void dsp_wdt_exit(void)
+{
+	free_irq(INT_34XX_WDT3_IRQ, &dsp_wdt);
+	tasklet_kill(&dsp_wdt.wdt3_tasklet);
+
+	if (dsp_wdt.fclk)
+		clk_put(dsp_wdt.fclk);
+	if (dsp_wdt.iclk)
+		clk_put(dsp_wdt.iclk);
+
+	dsp_wdt.fclk = NULL;
+	dsp_wdt.iclk = NULL;
+	dsp_wdt.sm_wdt = NULL;
+	dsp_wdt.reg_base = NULL;
+}
+
+void dsp_wdt_enable(bool enable)
+{
+	u32 tmp;
+	static bool wdt_enable;
+
+	if (wdt_enable == enable || !dsp_wdt.fclk || !dsp_wdt.iclk)
+		return;
+
+	wdt_enable = enable;
+
+	if (enable) {
+		clk_enable(dsp_wdt.fclk);
+		clk_enable(dsp_wdt.iclk);
+		dsp_wdt.sm_wdt->wdt_setclocks = 1;
+		tmp = __raw_readl(dsp_wdt.reg_base + OMAP3_WDT3_ISR_OFFSET);
+		__raw_writel(tmp, dsp_wdt.reg_base + OMAP3_WDT3_ISR_OFFSET);
+		enable_irq(INT_34XX_WDT3_IRQ);
+	} else {
+		disable_irq(INT_34XX_WDT3_IRQ);
+		dsp_wdt.sm_wdt->wdt_setclocks = 0;
+		clk_disable(dsp_wdt.iclk);
+		clk_disable(dsp_wdt.fclk);
+	}
+}
+
+#else
+void dsp_wdt_enable(bool enable)
+{
+}
+
+void dsp_wdt_sm_set(void *data)
+{
+}
+
+int dsp_wdt_init(void)
+{
+	return 0;
+}
+
+void dsp_wdt_exit(void)
+{
+}
+#endif
