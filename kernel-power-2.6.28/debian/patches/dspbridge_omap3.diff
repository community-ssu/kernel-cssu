diff -urN kernel-power-2.6.28/arch/arm/plat-omap/mailbox.c kernel-power-2.6.28.new/arch/arm/plat-omap/mailbox.c
--- kernel-power-2.6.28/arch/arm/plat-omap/mailbox.c	2011-10-03 21:46:25.000000000 +0100
+++ kernel-power-2.6.28.new/arch/arm/plat-omap/mailbox.c	2011-10-03 20:15:03.000000000 +0100
@@ -34,7 +34,7 @@
 
 static struct omap_mbox *mboxes;
 static DEFINE_RWLOCK(mboxes_lock);
-
+static bool rq_full;
 /*
  * Mailbox sequence bit API
  */
@@ -219,6 +219,10 @@
 	while (1) {
 		spin_lock_irqsave(q->queue_lock, flags);
 		rq = elv_next_request(q);
+		if (rq_full) {
+			omap_mbox_enable_irq(mbox, IRQ_RX);
+			rq_full = false;
+		}
 		spin_unlock_irqrestore(q->queue_lock, flags);
 		if (!rq)
 			break;
@@ -227,8 +231,8 @@
 
 		if (blk_end_request(rq, 0, 0))
 			BUG();
-
-		mbox->rxq->callback((void *)msg);
+		if(mbox->rxq->callback)
+		    mbox->rxq->callback((void *)msg);
 	}
 }
 
@@ -260,8 +264,11 @@
 
 	while (!mbox_fifo_empty(mbox)) {
 		rq = blk_get_request(q, WRITE, GFP_ATOMIC);
-		if (unlikely(!rq))
+		if (unlikely(!rq)){
+			omap_mbox_disable_irq(mbox, IRQ_RX);
+			rq_full = true;
 			goto nomem;
+		}
 
 		msg = mbox_fifo_read(mbox);
 		rq->data = (void *)msg;
@@ -446,11 +453,12 @@
 
 static void omap_mbox_fini(struct omap_mbox *mbox)
 {
+	free_irq(mbox->irq, mbox);
+	tasklet_kill(&mbox->txq->tasklet);
+	flush_work(&mbox->rxq->work);
 	mbox_queue_free(mbox->txq);
 	mbox_queue_free(mbox->rxq);
 
-	free_irq(mbox->irq, mbox);
-
 	if (unlikely(mbox->ops->shutdown))
 		mbox->ops->shutdown(mbox);
 }
diff -urN kernel-power-2.6.28/drivers/dsp/bridge/rmgr/drv.c kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/drv.c
--- kernel-power-2.6.28/drivers/dsp/bridge/rmgr/drv.c	2011-10-03 21:46:33.000000000 +0100
+++ kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/drv.c	2011-10-03 21:30:40.000000000 +0100
@@ -77,7 +77,6 @@
 /* GPP PROCESS CLEANUP CODE */
 
 static DSP_STATUS DRV_ProcFreeNodeRes(HANDLE hPCtxt);
-static DSP_STATUS  DRV_ProcFreeSTRMRes(HANDLE hPCtxt);
 extern enum NODE_STATE NODE_GetState(HANDLE hNode);
 
 /* Allocate and add a node resource element
@@ -290,7 +289,7 @@
 		pDMMList = pDMMList->next;
 		if (pDMMRes->dmmAllocated) {
 			status = PROC_UnMap(pDMMRes->hProcessor,
-				 (void *)pDMMRes->ulDSPResAddr, pCtxt);
+				 (void *)pDMMRes->ulDSPAddr, pCtxt);
 			if (DSP_FAILED(status))
 				pr_debug("%s: PROC_UnMap failed! status ="
 						" 0x%xn", __func__, status);
@@ -489,60 +488,45 @@
 	return status;
 }
 
-/* Actual Stream De-Allocation */
-static DSP_STATUS  DRV_ProcFreeSTRMRes(HANDLE hPCtxt)
-{
+/* Release all Stream resources and its context
+* This is called from .bridge_release.
+*/
+DSP_STATUS DRV_RemoveAllSTRMResElements(HANDLE hPCtxt){
 	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
 	DSP_STATUS status = DSP_SOK;
-	u8 **apBuffer = NULL;
-	struct STRM_RES_OBJECT *pSTRMRes = NULL;
+	struct STRM_RES_OBJECT *strm_res = NULL;
+	struct STRM_RES_OBJECT *strm_tmp = NULL;	
 	struct STRM_INFO strm_info;
 	struct DSP_STREAMINFO user;
+	u8 **apBuffer = NULL;
 	u8 *pBufPtr;
 	u32 ulBytes;
 	u32 dwArg;
 	s32 ulBufSize;
 
-	pSTRMRes = pCtxt->pSTRMList;
-	while (pSTRMRes) {
-		if (pSTRMRes->uNumBufs) {
-			apBuffer = MEM_Alloc(pSTRMRes->uNumBufs *
-					    sizeof(u8 *), MEM_NONPAGED);
-			if (!apBuffer)
-				return DSP_EMEMORY;
-			status = STRM_FreeBuffer(pSTRMRes->hStream, apBuffer,
-						pSTRMRes->uNumBufs, pCtxt);
-			MEM_Free(apBuffer);
+	strm_tmp = pCtxt->pSTRMList;
+	while (strm_tmp) {
+		strm_res = strm_tmp;
+		strm_tmp = strm_tmp->next;
+		if (strm_res->uNumBufs) {
+			apBuffer = MEM_Alloc((strm_res->uNumBufs *
+						sizeof(u8 *)), MEM_NONPAGED);
+			status = STRM_FreeBuffer(strm_res->hStream, apBuffer,
+						strm_res->uNumBufs, pCtxt);
+			if (apBuffer) {
+				status = STRM_FreeBuffer(strm_res->hStream,
+					apBuffer, strm_res->uNumBufs, pCtxt);
+				MEM_Free(apBuffer);
+			}
 		}
 		strm_info.pUser = &user;
 		user.uNumberBufsInStream = 0;
-		STRM_GetInfo(pSTRMRes->hStream, &strm_info, sizeof(strm_info));
-		while (strm_info.pUser->uNumberBufsInStream--)
-			STRM_Reclaim(pSTRMRes->hStream, &pBufPtr, &ulBytes,
-					     (u32 *)&ulBufSize, &dwArg);
-
-	}
-	return status;
-}
-
-/* Release all Stream resources and its context
-* This is called from .bridge_release.
-*/
-DSP_STATUS	DRV_RemoveAllSTRMResElements(HANDLE hPCtxt)
-{
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct STRM_RES_OBJECT *pTempSTRMRes2 = NULL;
-	struct STRM_RES_OBJECT *pTempSTRMRes = NULL;
-
-	DRV_ProcFreeSTRMRes(pCtxt);
-	pTempSTRMRes = pCtxt->pSTRMList;
-	while (pTempSTRMRes != NULL) {
-		pTempSTRMRes2 = pTempSTRMRes;
-		pTempSTRMRes = pTempSTRMRes->next;
-		MEM_Free(pTempSTRMRes2);
+		STRM_GetInfo(strm_res->hStream, &strm_info, sizeof(strm_info));
+		while (user.uNumberBufsInStream--)
+			STRM_Reclaim(strm_res->hStream, &pBufPtr, &ulBytes,
+					    (u32 *)&ulBufSize, &dwArg);
+		status = STRM_Close(strm_res->hStream, pCtxt);
 	}
-	pCtxt->pSTRMList = NULL;
 	return status;
 }
 
diff -urN kernel-power-2.6.28/drivers/dsp/bridge/rmgr/node.c kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/node.c
--- kernel-power-2.6.28/drivers/dsp/bridge/rmgr/node.c	2011-10-03 21:46:33.000000000 +0100
+++ kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/node.c	2011-10-03 20:17:41.000000000 +0100
@@ -3170,7 +3170,7 @@
 		 pNodeId, pNodeProps);
 
 	status = PROC_GetDevObject(hProcessor, &hDevObject);
-	if (hDevObject != NULL)
+	if (hDevObject)
 		status = DEV_GetNodeManager(hDevObject, &hNodeMgr);
 
 	if (hNodeMgr == NULL) {
diff -urN kernel-power-2.6.28/drivers/dsp/bridge/rmgr/proc.c kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/proc.c
--- kernel-power-2.6.28/drivers/dsp/bridge/rmgr/proc.c	2011-10-03 21:46:33.000000000 +0100
+++ kernel-power-2.6.28.new/drivers/dsp/bridge/rmgr/proc.c	2011-10-03 20:21:33.000000000 +0100
@@ -351,13 +351,11 @@
 		status = DEV_GetWMDContext(hDevObject,
 					&pProcObject->hWmdContext);
 		if (DSP_FAILED(status)) {
-			MEM_FreeObject(hProcObject);
 			GT_0trace(PROC_DebugMask, GT_7CLASS,
 				 "PROC_AutoStart: Failed "
 				 "to get WMD Context \n");
 		}
 	} else {
-		MEM_FreeObject(hProcObject);
 		GT_0trace(PROC_DebugMask, GT_7CLASS,
 			 "PROC_AutoStart: Failed to "
 			 "get IntFxns \n");
@@ -408,6 +406,8 @@
 		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_AutoStart: "
 			 "No Exec file found \n");
 	}
+	MEM_Free(hProcObject->g_pszLastCoff);
+	hProcObject->g_pszLastCoff = NULL;
 func_cont:
 	MEM_FreeObject(hProcObject);
 func_end:
