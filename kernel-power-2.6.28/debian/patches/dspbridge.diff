diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,12 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Private header file defining channel manager and channel objects for
+ * a shared memory channel driver.
+ *
+ * Shared between the modules implementing the shared memory channel class
+ * library.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,50 +20,11 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _chnl_sm.h ========
- *  Description:
- *      Private header file defining channel manager and channel objects for
- *      a shared memory channel driver.
- *
- *  Public Functions:
- *      None.
- *
- *  Notes:
- *      Shared between the modules implementing the shared memory channel class
- *      library.
- *
- *! Revision History:
- *! ================
- *! 15-Oct-2002 kc  Removed legacy PERF code.
- *! 12-Jan-2002 ag  Removed unused gppReqIO & ddmaChnlId DDMA fields.
- *!                 Added zero-copy chnl descriptor array: zchnldesc.
- *! 21-Dec-2001 ag  Moved descPaGpp to private chnl obj from chnl descriptor.
- *! 20-May-2001 ag/jeh Removed fShmSyms field from CHNL_MGR.
- *! 04-Feb-2001 ag  DSP-DMA support added.
- *! 26-Oct-2000 jeh Added arg and resvd to SHM control structure. Added dwArg
- *!                 to CHNL_IRP.
- *! 16-Oct-2000 jeh Removed #ifdef DEBUG from around channel object's cIOCs
- *!                 field, added cIOReqs.
- *! 20-Jan-2000 ag: Incorporated code review comments.
- *! 05-Jan-2000 ag: Text format cleanup.
- *! 03-Nov-1999 ag: Added szEventName[] to CHNL object for name event support.
- *! 02-Nov-1999 ag: _SHM_BEG & _END Syms from COFF now used for IO and SM CLASS.
- *! 27-Oct-1999 jeh Define SHM structure to work for 16-bit targets.
- *! 25-May-1999 jg: Added target side symbol names for share memory buffer
- *! 03-Jan-1997 gp: Added fSharedIRQ field.
- *! 22-Oct-1996 gp: Made dwProcessID a handle.
- *! 09-Sep-1996 gp: Added dwProcessID field to CHNL_OBJECT.
- *! 13-Aug-1996 gp: Created.
- */
-
 #ifndef _CHNL_SM_
 #define _CHNL_SM_
 
 #include <dspbridge/wcd.h>
 #include <dspbridge/wmd.h>
-#include <dspbridge/dpc.h>
 
 #include <dspbridge/list.h>
 #include <dspbridge/ntfy.h>
@@ -78,6 +45,11 @@
 
 #define MAXOPPS 16
 
+/* Shared memory config options */
+#define SHM_CURROPP	0	/* Set current OPP in SHM */
+#define SHM_OPPINFO	1	/* Set dsp voltage and freq table values */
+#define SHM_GETOPP	2	/* Get opp requested by DSP */
+
 struct oppTableEntry {
     u32 voltage;
     u32 frequency;
@@ -105,12 +77,6 @@ struct loadMonStruct {
     u32 predDspFreq;
 };
 
-	enum SHM_DESCTYPE {
-		SHM_CURROPP = 0,
-		SHM_OPPINFO = 1,
-		SHM_GETOPP = 2,		/* Get DSP requested OPP info */
-	} ;
-
 /* Structure in shared between DSP and PC for communication.*/
 	struct SHM {
 		u32 dspFreeMask;	/* Written by DSP, read by PC. */
@@ -177,7 +143,7 @@ struct loadMonStruct {
 		struct SYNC_OBJECT *hSyncEvent;
 		/* Name of Sync event */
 		char szEventName[SYNC_MAXNAMELENGTH + 1];
-               u32 hProcess;   /* Process which created this channel */
+		u32 hProcess;   /* Process which created this channel */
 		u32 pCBArg;	/* Argument to use with callback */
 		struct LST_LIST *pIORequests;	/* List of IOR's to driver */
 		s32 cIOCs;	/* Number of IOC's in queue */
@@ -197,7 +163,7 @@ struct loadMonStruct {
 
 /* I/O Request/completion packet: */
 	struct CHNL_IRP {
-		struct LST_ELEM link;	/* Link to next CHIRP in queue. */
+		struct list_head link;	/* Link to next CHIRP in queue. */
 		/* Buffer to be filled/emptied. (User)   */
 		u8 *pHostUserBuf;
 		/* Buffer to be filled/emptied. (System) */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/_dcd.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/_dcd.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/_dcd.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/_dcd.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Includes the wrapper functions called directly by the
+ * DeviceIOControl interface.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,43 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _dcd.h ========
- *  Description:
- *      Includes the wrapper functions called directly by the
- *      DeviceIOControl interface.
- *
- *  Public Functions:
- *      WCD_CallDevIOCtl
- *      WCD_Init
- *      WCD_InitComplete2
- *      WCD_Exit
- *      <MOD>WRAP_*
- *
- *  Notes:
- *      Compiled with CDECL calling convention.
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping feature
- *! 30-Jan-2002 ag  Renamed CMMWRAP_AllocBuf to CMMWRAP_CallocBuf.
- *! 22-Nov-2000 kc: Added MGRWRAP_GetPerf_Data to acquire PERF stats.
- *! 27-Oct-2000 jeh Added NODEWRAP_AllocMsgBuf, NODEWRAP_FreeMsgBuf. Removed
- *!                 NODEWRAP_GetMessageStream.
- *! 10-Oct-2000 ag: Added user CMM wrappers.
- *! 04-Aug-2000 rr: MEMWRAP and UTIL_Wrap added.
- *! 27-Jul-2000 rr: NODEWRAP, STRMWRAP added.
- *! 27-Jun-2000 rr: MGRWRAP fxns added.IFDEF to build for PM or DSP/BIOS Bridge
- *! 03-Dec-1999 rr: WCD_InitComplete2 enabled for BRD_AutoStart.
- *! 09-Nov-1999 kc: Added MEMRY.
- *! 02-Nov-1999 ag: Added CHNL.
- *! 08-Oct-1999 rr: Utilwrap_Testdll fxn added
- *! 24-Sep-1999 rr: header changed from _wcd.h to _dcd.h
- *! 09-Sep-1997 gp: Created.
- */
-
 #ifndef _WCD_
 #define _WCD_
 
@@ -130,11 +96,8 @@
 	extern u32 MGRWRAP_WaitForBridgeEvents(union Trapped_Args *args,
 			void *pr_ctxt);
 
-#ifndef RES_CLEANUP_DISABLE
 	extern u32 MGRWRAP_GetProcessResourcesInfo(union Trapped_Args *args,
 			void *pr_ctxt);
-#endif
-
 
 /* CPRC (Processor) wrapper Functions */
 	extern u32 PROCWRAP_Attach(union Trapped_Args *args, void *pr_ctxt);
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/brddefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/brddefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/brddefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/brddefs.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global BRD constants and types, shared between WCD and WMD.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,22 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== brddefs.h ========
- *  Description:
- *      Global BRD constants and types, shared between WSX, WCD, and WMD.
- *
- *! Revision History:
- *! ================
- *! 31-Jan-2000 rr: Comment Exec changed to Monitor
- *! 22-Jul-1999 jeh Added BRD_LOADED state.
- *! 26-Mar-1997 gp: Added BRD_SYNCINIT state.
- *! 11-Dec-1996 cr: Added BRD_LASTSTATE definition.
- *! 11-Jul-1996 gp: Added missing u32 callback argument to BRD_CALLBACK.
- *! 10-Jun-1996 gp: Created from board.h and brd.h.
- */
-
 #ifndef BRDDEFS_
 #define BRDDEFS_
 
@@ -46,7 +32,6 @@
 #define BRD_RETENTION     0x8       /* Retention mode */
 #define BRD_DSP_HIBERNATION     0x9       /* DSP initiated hibernation */
 #define BRD_ERROR		0xA       /* Board state is Error */
-	typedef u32 BRD_STATUS;
 
 /* BRD Object */
 	struct BRD_OBJECT;
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/cfg.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/cfg.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/cfg.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/cfg.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * PM Configuration module.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,54 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== cfg.h ========
- *  Purpose:
- *      PM Configuration module.
- *
- *  Private Functions:
- *      CFG_Exit
- *      CFG_GetAutoStart
- *      CFG_GetCDVersion
- *      CFG_GetDevObject
- *      CFG_GetDSPResources
- *      CFG_GetExecFile
- *      CFG_GetHostResources
- *      CFG_GetObject
- *      CFG_GetPerfValue
- *      CFG_GetWMDFileName
- *      CFG_GetZLFile
- *      CFG_Init
- *      CFG_SetDevObject
- *      CFG_SetObject
- *
- *! Revision History:
- *! =================
- *! 26-Feb-2003 kc  Removed unused CFG fxns.
- *! 28-Aug-2001 jeh  Added CFG_GetLoaderName.
- *! 26-Jul-2000 rr:  Added CFG_GetDCDName to retrieve the DCD Dll name.
- *! 13-Jul-2000 rr:  Added CFG_GetObject & CFG_SetObject.
- *! 13-Jan-2000 rr:  CFG_Get/SetPrivateDword renamed to CFG_Get/SetDevObject.
- *!                  CFG_GetWinBRIDGEDir/Directory,CFG_GetSearchPath removed.
- *! 15-Jan-1998 cr:  Code review cleanup.
- *! 16-Aug-1997 cr:  Added explicit cdecl identifiers.
- *! 12-Dec-1996 gp:  Moved CFG_FindInSearchPath to CSP module.
- *! 13-Sep-1996 gp:  Added CFG_GetBoardName().
- *! 22-Jul-1996 gp:  Added CFG_GetTraceStr, to retrieve an initial GT trace.
- *! 26-Jun-1996 cr:  Added CFG_FindInSearchPath.
- *! 25-Jun-1996 cr:  Added CFG_GetWinSPOXDir.
- *! 17-Jun-1996 cr:  Added CFG_GetDevNode.
- *! 11-Jun-1996 cr:  Cleaned up for code review.
- *! 07-Jun-1996 cr:  Added CFG_GetExecFile and CFG_GetZLFileName functions.
- *! 04-Jun-1996 gp:  Added AutoStart regkey and accessor function.  Placed
- *!                  OUT parameters in accessor function param. lists at end.
- *! 29-May-1996 gp:  Moved DEV_HDEVNODE to here and renamed CFG_HDEVNODE.
- *! 22-May-1996 cr:  Added GetHostResources, GetDSPResources, and
- *!                  GetWMDFileName services.
- *! 18-May-1996 gp:  Created.
- */
-
 #ifndef CFG_
 #define CFG_
 #include <dspbridge/host_os.h>
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/cfgdefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/cfgdefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/cfgdefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/cfgdefs.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global CFG constants and types, shared between class and mini driver.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,31 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== cfgdefs.h ========
- *  Purpose:
- *      Global CFG constants and types, shared between class and mini driver.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 kc  Removed wIOPort* in CFG_HOSTRES.
- *! 06-Sep-2000 jeh Added channel info to CFG_HOSTRES.
- *! 09-May-2000 rr: CFG_HOSTRES now support multiple windows for PCI support.
- *! 31-Jan-2000 rr: Comments changed after code review.
- *! 06-Jan-2000 rr: Bus Type included in CFG_HOSTRES.
- *! 12-Nov-1999 rr: CFG_HOSTRES member names changed.
- *! 25-Oct-1999 rr: Modified the CFG_HOSTRES Structure
- *!                 PCMCIA ISR Register/Unregister fxn removed..
- *!                 New flag PCCARD introduced during compile time.
- *! 10-Sep-1999 ww: Added PCMCIA ISR Register/Unregister fxn.
- *! 01-Sep-1999 ag: Removed NT/95 specific fields in CFG_HOSTRES
- *! 27-Oct-1997 cr: Updated CFG_HOSTRES struct to support 1+ IRQs per board.
- *! 17-Sep-1997 gp: Tacked some NT config info to end of CFG_HOSTRES structure.
- *! 12-Dec-1996 cr: Cleaned up after code review.
- *! 14-Nov-1996 gp: Renamed from wsxcfg.h
- *! 19-Jun-1996 cr: Created.
- */
-
 #ifndef CFGDEFS_
 #define CFGDEFS_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/chnl.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/chnl.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/chnl.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/chnl.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,11 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * WCD channel interface: multiplexes data streams through the single
+ * physical link managed by a mini-driver.
+ *
+ * See DSP API chnl.h for more details.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,46 +19,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== chnl.h ========
- *  Description:
- *      WCD channel interface: multiplexes data streams through the single
- *      physical link managed by a mini-driver.
- *
- *  Public Functions:
- *      CHNL_AddIOReq
- *      CHNL_AllocBuffer
- *      CHNL_CancelIO
- *      CHNL_Close
- *      CHNL_CloseOrphans
- *      CHNL_Create
- *      CHNL_Destroy
- *      CHNL_Exit
- *      CHNL_FlushIO
- *      CHNL_FreeBuffer
- *      CHNL_GetEventHandle
- *      CHNL_GetHandle
- *      CHNL_GetIOCompletion
- *      CHNL_GetId
- *      CHNL_GetMgr
- *      CHNL_GetMode
- *      CHNL_GetPosition
- *      CHNL_GetProcessHandle
- *      CHNL_Init
- *      CHNL_Open
- *
- *  Notes:
- *      See DSP API chnl.h for more details.
- *
- *! Revision History:
- *! ================
- *! 14-Jan-1997 gp: Updated based on code review feedback.
- *! 24-Oct-1996 gp: Move CloseOrphans into here from dspsys.
- *! 09-Sep-1996 gp: Added CHNL_GetProcessID() and CHNL_GetHandle().
- *! 10-Jul-1996 gp: Created.
- */
-
 #ifndef CHNL_
 #define CHNL_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/chnl_sm.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/chnl_sm.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/chnl_sm.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/chnl_sm.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,14 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Prototypes for channel lower edge functions for a Bridge mini driver
+ * implementing data transfer via shared memory.
+ *
+ * Notes:
+ *   These lower edge functions must be implemented by the WMD writer.
+ *   Currently, CHNLSM_Read() and CHNLSM_Write() are not called, but must
+ *   be defined to link.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,28 +22,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== chnl_sm.h ========
- *  Description:
- *      Prototypes for channel lower edge functions for a WinBRIDGE mini driver
- *      implementing data transfer via shared memory.
- *
- *  Public Functions:
- *      CHNLSM_DisableInterrupt;
- *      CHNLSM_EnableInterrupt;
- *      CHNLSM_ISR;
- *      CHNLSM_Read;
- *      CHNLSM_UpdateSHMLength;
- *      CHNLSM_Write;
- *
- *  Notes:
- *      These lower edge functions must be implemented by the WMD writer.
- *      Currently, CHNLSM_Read() and CHNLSM_Write() are not called, but must
- *      be defined to link.
- *
- */
-
 #ifndef CHNLSM_
 #define CHNLSM_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/chnldefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/chnldefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/chnldefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/chnldefs.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * System-wide channel objects and constants.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,30 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== chnldefs.h ========
- *  Purpose:
- *      System-wide channel objects and constants.
- *
- *! Revision History:
- *! ================
- *! 19-Jan-2002 ag  Added cBufSize to IOC.
- *! 05-Jan-2000 ag: Text format cleanup.
- *! 02-Dec-1999 ag: Added new chnl attribute pstrEventName.
- *! 12-Nov-1999 kc: Enabled hEvent attribute for tests.
- *! 01-Nov-1999 ag: hEvent attribute not supported(yet).
- *! 16-Jan-1997 gp: Moved private stuff into chnlpriv.h
- *! 14-Jan-1997 gp: Updated based on code review feedback:
- *!                 Removed CHNL_MODENOWAIT, CHNL_MODEDIRECT,
- *! 03-Jan-1997 gp: Added channel class library types.
- *! 14-Dec-1996 gp: Moved uChnlId field from CHNL_ATTRS to CHNL_Open().
- *! 10-Dec-1996 gp: Added CHNL_IsTimedOut() macro.
- *! 14-Nov-1996 gp: Renamed from wsxchnl.h.
- *! 09-Sep-1996 gp: Added hReserved2 field to CHNL_ATTRS. Updated CHNL_INFO.
- *! 10-Jul-1996 gp: Created from channel.h.
- */
-
 #ifndef CHNLDEFS_
 #define CHNLDEFS_
 
@@ -67,8 +45,6 @@
 #define CHNL_IsIOCancelled(ioc) (ioc.status & CHNL_IOCSTATCANCEL)
 #define CHNL_IsTimedOut(ioc)    (ioc.status & CHNL_IOCSTATTIMEOUT)
 
-/* CHNL types: */
-	typedef u32 CHNL_MODE;	/* Channel transfer mode.         */
 
 /* Channel attributes: */
 	struct CHNL_ATTRS {
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/chnlpriv.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/chnlpriv.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/chnlpriv.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/chnlpriv.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Private channel header shared between DSPSYS, WCD and WMD modules.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,35 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== chnlpriv.h ========
- *  Description:
- *      Private channel header shared between DSPSYS, WCD and WMD modules.
- *
- *  Public Functions:
- *      None.
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 05-Jan-2002 ag  Added cChannels(total # of chnls) to CHNL_MGRINFO struct.
- *!                 Added private CHNL_[PCPY][ZCPY][DDMA].
- *! 17-Nov-2000 jeh Removed IRQ, shared memory from CHNL_MGRATTRS, since these
- *!                 now belong to IO_ATTRS.
- *! 21-Jan-2000 ag: Code review comments added.
- *! 05-Jan-2000 ag: Text format cleanup.
- *! 11-Dec-1999 ag: Added CHNL_MAXLOCKPAGES for CHNL_PrepareBuffer().
- *! 04-Dec-1999 ag: Added CHNL_MAXEVTNAMELEN for i/o compl named event support.
- *! 01-Nov-1999 ag: CHNL_MAXCHANNELS set to 16 for 16-bit DSPs.
- *! 27-Oct-1997 cr: Expanded CHNL_MAXIRQ from 0x0f to 0xff.
- *! 16-Jan-1997 gp: Moved symbols into here from chnldefs.h.
- *! 03-Jan-1997 gp: Added CHNL_MAXIRQ define.
- *! 09-Dec-1996 gp: Removed CHNL_STATEIDLE.
- *! 15-Jul-1996 gp: Created.
- */
-
 #ifndef CHNLPRIV_
 #define CHNLPRIV_
 
@@ -110,7 +83,7 @@
 		u32 cPosition;	/* Total bytes transferred.        */
 		u32 cIOCs;	/* Number of IOCs in queue.               */
 		u32 cIOReqs;	/* Number of IO Requests in queue.        */
-               u32 hProcess;   /* Process owning this channel.     */
+		u32 hProcess;   /* Process owning this channel.     */
 		/*
 		 * Name of channel I/O completion event. Not required in Linux
 		 */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/clk.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/clk.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/clk.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/clk.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provides Clock functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,15 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== clk.h ========
- *  Purpose: Provides Clock functions.
- *
- *! Revision History:
- *! ================
- *! 08-May-2007 rg: Moved all clock functions from sync module.
- */
-
 #ifndef _CLK_H
 #define _CLK_H
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/cmm.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/cmm.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/cmm.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/cmm.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,22 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * The Communication Memory Management(CMM) module provides shared memory
+ * management services for DSP/BIOS Bridge data streaming and messaging.
+ * Multiple shared memory segments can be registered with CMM. Memory is
+ * coelesced back to the appropriate pool when a buffer is freed.
+ *
+ * The CMM_Xlator[xxx] functions are used for node messaging and data
+ * streaming address translation to perform zero-copy inter-processor
+ * data transfer(GPP<->DSP). A "translator" object is created for a node or
+ * stream object that contains per thread virtual address information. This
+ * translator info is used at runtime to perform SM address translation
+ * to/from the DSP address space.
+ *
+ * Notes:
+ *   CMM_XlatorAllocBuf - Used by Node and Stream modules for SM address
+ *			  translation.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,56 +30,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== cmm.h ========
- *  Purpose:
- *      The Communication Memory Management(CMM) module provides shared memory
- *      management services for DSP/BIOS Bridge data streaming and messaging.
- *      Multiple shared memory segments can be registered with CMM. Memory is
- *      coelesced back to the appropriate pool when a buffer is freed.
- *
- *      The CMM_Xlator[xxx] functions are used for node messaging and data
- *      streaming address translation to perform zero-copy inter-processor
- *      data transfer(GPP<->DSP). A "translator" object is created for a node or
- *      stream object that contains per thread virtual address information. This
- *      translator info is used at runtime to perform SM address translation
- *      to/from the DSP address space.
- *
- *
- *  Public Functions:
- *      CMM_CallocBuf
- *      CMM_Create
- *      CMM_Destroy
- *      CMM_Exit
- *      CMM_FreeBuf
- *      CMM_GetHandle
- *      CMM_GetInfo
- *      CMM_Init
- *      CMM_RegisterGPPSMSeg
- *      CMM_UnRegisterGPPSMSeg
- *      CMM_XlatorAllocBuf       (Note #1 below)
- *      CMM_XlatorCreate           "
- *      CMM_XlatorDelete           "
- *      CMM_XlatorFreeBuf          "
- *      CMM_XlatorTranslate        "
- *
- *
- *  Notes:
- *      #1: Used by Node and Stream modules for SM address translation.
- *
- *! Revision History:
- *! ================
- *! 30-Jan-2002 ag  Removed unused CMM_Alloc[Free]Desc & CMM_XlatorRegisterPa.
- *!                 Renamed CMM_AllocBuf() to CMM_CallocBuf().
- *! 29-Aug-2001 ag: Added dsp virt base and size to CMM_RegisterGPPSMSeg().
- *! 12-Aug-2001 ag: Added CMM_UnRegisterGPP[DSP}SMSeg[s]().
- *! 05-Dec-2000 ag: Added param to CMM_XlatorDelete() to force buf cleanup.
- *! 30-Oct-2000 ag: Added conversion factor to CMM_RegisterDSP[GPP]SMSeg().
- *! 12-Oct-2000 ag: Added CMM_Xlator[xxx] functions.
- *! 10-Aug-2000 ag: Created.
- *!
- */
-
 #ifndef CMM_
 #define CMM_
 
@@ -194,7 +160,7 @@
  *      hDevObject != NULL
  *  Ensures:
  */
-	extern DSP_STATUS CMM_GetHandle(DSP_HPROCESSOR hProcessor,
+	extern DSP_STATUS CMM_GetHandle(void *hProcessor,
 					OUT struct CMM_OBJECT **phCmmMgr);
 
 /*
@@ -261,7 +227,7 @@
 					       unsigned int dwGPPBasePA,
 					       u32 ulSize,
 					       u32 dwDSPAddrOffset,
-					       enum CMM_CNVTTYPE cFactor,
+					       s8  cFactor,
 					       unsigned int dwDSPBase,
 					       u32 ulDSPSize,
 					       u32 *pulSegId,
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/cmmdefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/cmmdefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/cmmdefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/cmmdefs.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global MEM constants and types.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,24 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== cmmdefs.h ========
- *  Purpose:
- *      Global MEM constants and types.
- *
- *! Revision History:
- *! ================
- *! 12-Nov-2001 ag  CMM_KERNMAPTYPE added for dsp<->device process addr map'n.
- *!                 This allows addr conversion from drvr process <-> DSP addr.
- *! 29-Aug-2001 ag  Added CMM_ALLSEGMENTS.
- *! 08-Dec-2000 ag  Added bus address conversion type CMM_POMAPEMIF2DSPBUS.
- *! 05-Dec-2000 ag  Added default CMM_DEFLTCONVFACTOR & CMM_DEFLTDSPADDROFFSET.
- *! 29-Oct-2000 ag  Added converstion factor for GPP DSP Pa translation.
- *! 15-Oct-2000 ag  Added address translator attributes and defaults.
- *! 12-Jul-2000 ag  Created.
- */
-
 #ifndef CMMDEFS_
 #define CMMDEFS_
 
@@ -55,15 +39,9 @@
  *  For typical platforms:
  *      converted Address = PaDSP + ( cFactor * addressToConvert).
  */
-	enum CMM_CNVTTYPE {
-		CMM_SUBFROMDSPPA = -1,
-		/* PreOMAP is special case: not simple offset */
-		CMM_POMAPEMIF2DSPBUS = 0,
-		CMM_ADDTODSPPA = 1
-	} ;
+#define CMM_SUBFROMDSPPA	-1
+#define CMM_ADDTODSPPA		1
 
-#define CMM_DEFLTDSPADDROFFSET  0
-#define CMM_DEFLTCONVFACTOR     CMM_POMAPEMIF2DSPBUS /* PreOMAP DSPBUS<->EMIF */
 #define CMM_ALLSEGMENTS         0xFFFFFF	/* All SegIds */
 #define CMM_MAXGPPSEGS          1	/* Maximum # of SM segs */
 
@@ -121,14 +99,6 @@
 		CMM_DSPPA2PA = 4,	/* DSP Pa to GPP Pa */
 	} ;
 
-/*
- *  Used to "map" between device process virt addr and dsp addr.
- */
-	enum CMM_KERNMAPTYPE {
-		CMM_KERNVA2DSP = 0, /* Device process context to dsp address. */
-		CMM_DSP2KERNVA = 1, /* Dsp address to device process context. */
-	} ;
-
 	struct CMM_OBJECT;
 	struct CMM_XLATOROBJECT;
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/cod.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/cod.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/cod.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/cod.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,10 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Code management module for DSPs. This module provides an interface
+ * interface for loading both static and dynamic code objects onto DSP
+ * systems.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,60 +18,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== cod.h ========
- *  Description:
- *      Code management module for DSPs. This module provides an interface
- *      interface for loading both static and dynamic code objects onto DSP
- *      systems.
- *
- *  Public Functions:
- *      COD_Close
- *      COD_Create
- *      COD_Delete
- *      COD_Exit
- *      COD_GetBaseLib
- *      COD_GetBaseName
- *      COD_GetLoader
- *      COD_GetSection
- *      COD_GetSymValue
- *      COD_Init
- *      COD_LoadBase
- *      COD_Open
- *      COD_OpenBase
- *      COD_ReadSection
- *      COD_UnloadSection
- *
- *  Note:
- *      Currently, only static loading is supported.
- *
- *! Revision History
- *! ================
- *! 08-Apr-2003 map: Changed DBL to DBLL
- *! 07-Aug-2002 jeh: Added COD_GetBaseName().
- *! 17-Jul-2002 jeh: Added COD_Open(), COD_Close().
- *! 15-Mar-2002 jeh: Added DBL_Flags param to COD_OpenBase().
- *! 19-Oct-2001 jeh: Added COD_GetBaseLib, COD_GetLoader, (left in
- *!                  COD_LoadSection(), COD_UnloadSection(), since they
- *!                  may be needed for BridgeLite).
- *! 07-Sep-2001 jeh: Added COD_LoadSection(), COD_UnloadSection().
- *! 11-Jan-2001 jeh: Added COD_OpenBase.
- *! 29-Sep-2000 kc:  Added size param to COD_ReadSection for input buffer
- *!                  validation.
- *! 02-Aug-2000 kc:  Added COD_ReadSection.
- *! 04-Sep-1997 gp:  Added CDECL identifier to COD_WRITEFXN (for NT)..
- *! 18-Aug-1997 cr:  Added explicit CDECL identifier.
- *! 28-Oct-1996 gp:  Added COD_GetSection.
- *! 30-Jul-1996 gp:  Added envp[] argument to COD_LoadBase().
- *! 12-Jun-1996 gp:  Moved OUT param first in _Create().  Updated _Create()
- *!                  call to take a ZLFileName.  Moved COD_ processor types
- *!                  to CFG.
- *! 29-May-1996 gp:  Changed WCD_STATUS to DSP_STATUS.  Removed include's.
- *! 07-May-1996 mg:  Created.
- *
- */
-
 #ifndef COD_
 #define COD_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/csl.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/csl.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/csl.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/csl.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,135 +0,0 @@
-/*
- * csl.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*
- *  ======== csl.h ========
- *  Purpose:
- *      Platform independent C Standard library functions.
- *
- *  Public Functions:
- *      CSL_AnsiToWchar
- *      CSL_ByteSwap
- *      CSL_Exit
- *      CSL_Init
- *      CSL_NumToAscii
- *      CSL_Strtok
- *      CSL_Strtokr
- *      CSL_WcharToAnsi
- *
- *! Revision History:
- *! ================
- *! 07-Aug-2002 jeh: Added CSL_Strtokr().
- *! 21-Sep-2001 jeh: Added CSL_Strncmp.
- *! 22-Nov-2000 map: Added CSL_Atoi and CSL_Strtok
- *! 19-Nov-2000 kc:  Added CSL_ByteSwap().
- *! 09-Nov-2000 kc:  Added CSL_Strncat.
- *! 29-Oct-1999 kc:  Added CSL_Wstrlen().
- *! 20-Sep-1999 ag:  Added CSL_Wchar2Ansi().
- *! 19-Jan-1998 cr:  Code review cleanup (mostly documentation fixes).
- *! 29-Dec-1997 cr:  Changed CSL_lowercase to CSL_Uppercase, added
- *!                  CSL_AnsiToWchar.
- *! 30-Sep-1997 cr:  Added explicit cdecl descriptors to fxn definitions.
- *! 25-Jun-1997 cr:  Added CSL_strcmp.
- *! 12-Jun-1996 gp:  Created.
- */
-
-#ifndef CSL_
-#define CSL_
-
-#include <dspbridge/host_os.h>
-
-/*
- *  ======== CSL_Exit ========
- *  Purpose:
- *      Discontinue usage of the CSL module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      CSL initialized.
- *  Ensures:
- *      Resources acquired in CSL_Init(void) are freed.
- */
-	extern void CSL_Exit(void);
-
-/*
- *  ======== CSL_Init ========
- *  Purpose:
- *      Initialize the CSL module's private state.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- *      A requirement for each of the other public CSL functions.
- */
-	extern bool CSL_Init(void);
-
-/*
- *  ======== CSL_NumToAscii ========
- *  Purpose:
- *      Convert a 1 or 2 digit number to a 2 digit string.
- *  Parameters:
- *      pstrNumber: Buffer to store converted string.
- *      dwNum:      Number to convert.
- *  Returns:
- *  Requires:
- *      pstrNumber must be able to hold at least three characters.
- *  Ensures:
- *      pstrNumber will be null terminated.
- */
-	extern void CSL_NumToAscii(OUT char *pstrNumber, IN u32 dwNum);
-
-
-/*
- *  ======== CSL_Strtok ========
- *  Purpose:
- *      Tokenize a NULL terminated string
- *  Parameters:
- *      ptstrSrc:       pointer to string.
- *      szSeparators:   pointer to a string of seperators
- *  Returns:
- *      char *
- *  Requires:
- *      CSL initialized.
- *      ptstrSrc is a valid string pointer.
- *      szSeparators is a valid string pointer.
- *  Ensures:
- */
-	extern char *CSL_Strtok(IN char *ptstrSrc,
-				IN CONST char *szSeparators);
-
-/*
- *  ======== CSL_Strtokr ========
- *  Purpose:
- *      Re-entrant version of strtok.
- *  Parameters:
- *      pstrSrc:        Pointer to string. May be NULL on subsequent calls.
- *      szSeparators:   Pointer to a string of seperators
- *      ppstrCur:       Location to store start of string for next call to
- *                      to CSL_Strtokr.
- *  Returns:
- *      char * (the token)
- *  Requires:
- *      CSL initialized.
- *      szSeparators != NULL
- *      ppstrCur != NULL
- *  Ensures:
- */
-	extern char *CSL_Strtokr(IN char *pstrSrc,
-				 IN CONST char *szSeparators,
-				 OUT char **ppstrCur);
-
-#endif				/* CSL_ */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbc.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbc.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbc.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbc.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,14 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * "Design by Contract" programming macros.
+ *
+ * Notes:
+ *   Requires that the GT->ERROR function has been defaulted to a valid
+ *   error handler for the given execution environment.
+ *
+ *   Does not require that GT_init() be called.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,28 +22,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== dbc.h ========
- *  Purpose:
- *      "Design by Contract" programming macros.
- *
- *  Public Functions:
- *      DBC_Assert
- *      DBC_Require
- *      DBC_Ensure
- *
- *  Notes:
- *      Requires that the GT->ERROR function has been defaulted to a valid
- *      error handler for the given execution environment.
- *
- *      Does not require that GT_init() be called.
- *
- *! Revision History:
- *! ================
- *! 11-Aug-2000 ag: Removed include <dspbridge/std.h>
- *! 22-Apr-1996 gp: Created.
- */
-
 #ifndef DBC_
 #define DBC_
 
@@ -48,10 +34,12 @@
 
 #include <dspbridge/gt.h>
 
-#define DBC_Assert(exp) \
-    if (!(exp)) \
-	printk("%s, line %d: Assertion (" #exp ") failed.\n", \
-	__FILE__, __LINE__)
+#define DBC_Assert(exp) 						       \
+do {									       \
+	if (!(exp))							       \
+		pr_err("%s, line %d: Assertion (" #exp ") failed.\n", \
+		__FILE__, __LINE__);					       \
+} while (0)
 #define DBC_Require DBC_Assert	/* Function Precondition.  */
 #define DBC_Ensure  DBC_Assert	/* Function Postcondition. */
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbdcd.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbdcd.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbdcd.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbdcd.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Defines the DSP/BIOS Bridge Configuration Database (DCD) API.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,30 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== dbdcd.h ========
- *  Description:
- *      Defines the DSP/BIOS Bridge Configuration Database (DCD) API.
- *
- *! Revision History
- *! ================
- *! 03-Dec-2003 map Changed DCD_OBJTYPE to DSP_DCDOBJTYPE
- *! 24-Feb-2003 kc  Updated DCD_AutoUnregister and DCD_GetObjects to simplify
- *!                 DCD implementation.
- *! 05-Aug-2002 jeh Added DCD_GetObjects().
- *! 11-Jul-2002 jeh Added DCD_GetDepLibs(), DCD_GetNumDepLibs().
- *! 22-Apr-2002 jeh Added DCD_GetLibraryName().
- *! 03-Apr-2001 sg  Changed error names to have DCD_E* format.
- *! 13-Feb-2001 kc  Name changed from dcdbs.h to dbdcd.h.
- *! 12-Dec-2000 kc  Added DCD_AutoUnregister.
- *! 09-Nov-2000 kc  Updated usage of DCD_EnumerateObject.
- *! 30-Oct-2000 kc  Added DCD_AutoRegister. Updated error DCD error codes.
- *! 29-Sep-2000 kc  Incorporated code review comments. See
- *!                 /src/reviews/dcd_review.txt.
- *! 26-Jul-2000 kc  Created.
- *!
- */
-
 #ifndef DBDCD_
 #define DBDCD_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbdcddef.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbdcddef.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbdcddef.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbdcddef.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DCD (DSP/BIOS Bridge Configuration Database) constants and types.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,31 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dbdcddef.h ========
- *  Description:
- *      DCD (DSP/BIOS Bridge Configuration Database) constants and types.
- *
- *! Revision History:
- *! ================
- *! 03-Dec-2003 map Moved and renamed DCD_OBJTYPE to DSP_DCDOBJTYPE in dbdefs.h
- *! 05-Dec-2002 map Added DCD_CREATELIBTYPE, DCD_EXECUTELIBTYPE,
- *                        DCD_DELETELIBTYPE
- *! 24-Feb-2003 kc  Updated REG entry names to DspBridge.
- *! 22-Nov-2002 gp  Cleaned up comments, formatting.
- *! 05-Aug-2002 jeh Added DCD_REGISTERFXN.
- *! 19-Apr-2002 jeh Added DCD_LIBRARYTYPE to DCD_OBJTYPE, dynamic load
- *!                 properties to DCD_NODEPROPS.
- *! 29-Jul-2001 ag  Added extended procObj.
- *! 13-Feb-2001 kc: Named changed from dcdbsdef.h dbdcddef.h.
- *! 12-Dec-2000 jeh Added DAIS iAlg name to DCD_NODEPROPS.
- *! 30-Oct-2000 kc: Added #defines for DCD_AutoRegister function.
- *! 05-Sep-2000 jeh Added DCD_NODEPROPS.
- *! 12-Aug-2000 kc: Incoroporated the use of types defined in <dspdefs.h>.
- *! 29-Jul-2000 kc: Created.
- */
-
 #ifndef DBDCDDEF_
 #define DBDCDDEF_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbdefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbdefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbdefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbdefs.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global definitions and constants for DSP/BIOS Bridge.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,65 +16,14 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== dbdefs.h ========
- *  Description:
- *      Global definitions and constants for DSP/BIOS Bridge.
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *! 08-Mar-2004 sb  Added MAPATTR & ELEM_SIZE for Dynamic Memory Mapping feature
- *! 09-Feb-2004 vp  Added processor ID numbers for DSP and IVA
- *! 06-Feb-2003 kc  Removed DSP_POSTMESSAGE. Updated IsValid*Event macros.
- *! 22-Nov-2002 gp  Cleaned up comments, formatting.
- *!                 Removed unused DSP_ENUMLASTNODE define.
- *! 13-Feb-2002 jeh Added uSysStackSize to DSP_NDBPROPS.
- *! 23-Jan-2002 ag  Added #define DSP_SHMSEG0.
- *! 12-Dec-2001 ag  Added DSP_ESTRMMODE error code.
- *! 04-Dec-2001 jeh Added DSP_ENOTCONNECTED error code.
- *! 10-Dec-2001 kc: Modified macros and definitions to disable DSP_POSTMESSAGE.
- *! 01-Nov-2001 jeh Added DSP_EOVERLAYMEMORY.
- *! 18-Oct-2001 ag  Added DSP_STRMMODE type.
- *!                 Added DSP_ENOTSHAREDMEM.
- *! 21-Sep-2001 ag  Added additional error codes.
- *! 07-Jun-2001 sg  Made DSPStream_AllocateBuffer fxn name plural.
- *! 11-May-2001 jeh Changed DSP_NODE_MIN_PRIORITY from 0 to 1. Removed hNode
- *!                 from DSP_NODEINFO.
- *! 02-Apr-2001 sg  Added missing error codes, rearranged codes, switched to
- *!             hex offsets, renamed some codes to match API spec.
- *! 16-Jan-2001 jeh Added DSP_ESYMBOL, DSP_EUUID.
- *! 13-Feb-2001 kc: DSP/BIOS Bridge name updates.
- *! 05-Dec-2000 ag: Added DSP_RMSxxx user available message command codes.
- *! 09-Nov-2000 rr: Added DSP_PROCEESORRESTART define; Removed DSP_PBUFFER.
- *!                 Added DSP_DCD_ENOAUTOREGISTER, DSP_EUSER1-16, DSP_ESTRMFUL
- *!                 Removed DSP_EDONE. Macros's modified.
- *! 23-Oct-2000 jeh Replaced DSP_STREAMSTATECHANGE with DSP_STREAMDONE.
- *! 09-Oct-2000 jeh Updated to version 0.9 DSP Bridge API spec.
- *! 29-Sep-2000 kc  Added error codes for DCD and REG to simplify use of
- *!                 these codes within the RM module.
- *! 27-Sep-2000 jeh Added segid, alignment, uNumBufs to DSP_STREAMATTRIN.
- *! 29-Aug-2000 jeh Added DSP_NODETYPE enum, changed DSP_EALREADYATTACHED to
- *!                 DSP_EALREADYCONNECTED. Changed scStreamConnection[1]
- *!                 to scStreamConnection[16] in DSP_NODEINFO structure.
- *!                 Added DSP_NOTIFICATION, DSP_STRMATTR. PSTRING changed
- *!                 back to TCHAR * and moved to dbtype.h.
- *! 11-Aug-2000 rr: Macros to check valid events and notify masks added.
- *! 09-Aug-2000 rr: Changed PSTRING to *s8
- *! 07-Aug-2000 rr: PROC_IDLE/SYNCINIT/UNKNOWN state removed.
- *! 20-Jul-2000 rr: Updated to version 0.8
- *! 17-Jul-2000 rr: New PROC states added to the DSP_PROCSTATE.
- *! 27-Jun-2000 rr: Created from dspapi.h
- */
-
 #ifndef DBDEFS_
 #define DBDEFS_
 
 #include <linux/types.h>
 
-#include <dspbridge/dbtype.h>		/* GPP side type definitions           */
-#include <dspbridge/std.h>		/* DSP/BIOS type definitions           */
-#include <dspbridge/rms_sh.h>		/* Types shared between GPP and DSP    */
+#include <dspbridge/dbtype.h>		/* GPP side type definitions */
+#include <dspbridge/std.h>		/* DSP/BIOS type definitions */
+#include <dspbridge/rms_sh.h>		/* Types shared between GPP and DSP */
 
 #define PG_SIZE_4K 4096
 #define PG_MASK(pg_size) (~((pg_size)-1))
@@ -155,17 +106,12 @@
 
 #define    MAX_PROFILES     16
 
+/* DSP chip type */
+#define DSPTYPE_64	0x99
+
 /* Types defined for 'Bridge API */
 	typedef u32 DSP_STATUS;	/* API return code type         */
 
-	typedef HANDLE DSP_HNODE;	/* Handle to a DSP Node object  */
-	typedef HANDLE DSP_HPROCESSOR;	/* Handle to a Processor object */
-	typedef HANDLE DSP_HSTREAM;	/* Handle to a Stream object    */
-
-	typedef u32 DSP_PROCFAMILY;	/* Processor family             */
-	typedef u32 DSP_PROCTYPE;	/* Processor type (w/in family) */
-	typedef u32 DSP_RTOSTYPE;	/* Type of DSP RTOS             */
-
 /* Handy Macros */
 #define IsValidProcEvent(x) (((x) == 0) || (((x) & (DSP_PROCESSORSTATECHANGE | \
 				    DSP_PROCESSORATTACH | \
@@ -217,7 +163,9 @@
 		DSP_DCDLIBRARYTYPE,
 		DSP_DCDCREATELIBTYPE,
 		DSP_DCDEXECUTELIBTYPE,
-		DSP_DCDDELETELIBTYPE
+		DSP_DCDDELETELIBTYPE,
+		/* DSP_DCDMAXOBJTYPE is meant to be the last DCD object type */
+		DSP_DCDMAXOBJTYPE
 	} ;
 
 /* Processor states */
@@ -371,7 +319,7 @@
 		u32 cbStruct;
 		enum DSP_CONNECTTYPE lType;
 		u32 uThisNodeStreamIndex;
-		DSP_HNODE hConnectedNode;
+		void *hConnectedNode;
 		struct DSP_UUID uiConnectedNodeID;
 		u32 uConnectedNodeStreamIndex;
 	} ;
@@ -421,7 +369,7 @@
 		struct DSP_NDBPROPS nbNodeDatabaseProps;
 		u32 uExecutionPriority;
 		enum NODE_STATE nsExecutionState;
-		DSP_HNODE hDeviceOwner;
+		void *hDeviceOwner;
 		u32 uNumberStreams;
 		struct DSP_STREAMCONNECT scStreamConnection[16];
 		u32 uNodeEnv;
@@ -450,26 +398,19 @@
 		u32 cbStruct;
 		u32 uTimeout;
 	} ;
-
-	enum chipTypes {
-		DSPTYPE_55 = 6,
-		IVA_ARM7 = 0x97,
-		DSPTYPE_64 = 0x99
-	};
-
 /*
  * The DSP_PROCESSORINFO structure describes basic capabilities of a
  * DSP processor
  */
 	struct DSP_PROCESSORINFO {
 		u32 cbStruct;
-		DSP_PROCFAMILY uProcessorFamily;
-		DSP_PROCTYPE uProcessorType;
+		long uProcessorFamily;
+		long uProcessorType;
 		u32 uClockRate;
 		u32 ulInternalMemSize;
 		u32 ulExternalMemSize;
 		u32 uProcessorID;
-		DSP_RTOSTYPE tyRunningRTOS;
+		long tyRunningRTOS;
 		s32 nNodeMinPriority;
 		s32 nNodeMaxPriority;
 	} ;
@@ -580,4 +521,30 @@ bit 6 - MMU element size = 64bit (valid 
 #define GEM_CACHE_LINE_SIZE     128
 #define GEM_L1P_PREFETCH_SIZE   128
 
+
+/*
+ * Definitions from dbreg.h
+ */
+
+#define DSPPROCTYPE_C64		6410
+#define IVAPROCTYPE_ARM7	470
+
+#define REG_MGR_OBJECT	1
+#define REG_DRV_OBJECT	2
+
+/* registry */
+#define DRVOBJECT	"DrvObject"
+#define MGROBJECT	"MgrObject"
+
+/* Max registry path length. Also the max registry value length. */
+#define MAXREGPATHLENGTH	255
+
+/* MiniDriver related definitions */
+#define DEFEXEC		"DefaultExecutable"	/* Default executable */
+#define AUTOSTART	"AutoStart"		/* Statically load flag */
+#define CURRENTCONFIG	"CurrentConfig"		/* Current resources */
+#define SHMSIZE		"SHMSize"		/* Size of SHM reservd on MPU */
+#define TCWORDSWAP	"TCWordSwap"		/* Traffic Controller WordSwp */
+#define DSPRESOURCES	"DspTMSResources"	/* C55 DSP resurces on OMAP */
+
 #endif				/* DBDEFS_ */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbg.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbg.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbg.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbg.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provide debugging services for Bridge Mini Drivers.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,29 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== dbg.h ========
- *  Purpose:
- *      Provide debugging services for 'Bridge Mini Drivers.
- *
- *  Public Functions:
- *      DBG_Exit
- *      DBG_Init
- *      DBG_Printf
- *      DBG_Trace
- *
- *  Notes:
- *      WMD's must not call DBG_Init or DBG_Exit.
- *
- *! Revision History:
- *! ================
- *! 03-Feb-2000 rr: DBG Levels redefined.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 10-Oct-1997 cr: Added DBG_Printf service.
- *! 29-May-1996 gp: Removed WCD_ prefix.
- *! 15-May-1996 gp: Created.
- */
-
 #ifndef DBG_
 #define DBG_
 #include <dspbridge/host_os.h>
@@ -52,7 +31,7 @@
 #define DBG_LEVEL6  (u8)(0x40)	/* Warn SERVICES Failures */
 #define DBG_LEVEL7  (u8)(0x80)	/* Warn Critical Errors */
 
-#if (defined(DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE
+#if (defined(CONFIG_BRIDGE_DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE
 
 /*
  *  ======== DBG_Exit ========
@@ -105,6 +84,6 @@
 #define DBG_Init(void) true
 #define DBG_Trace(bLevel, pstrFormat, args...) do {} while (0)
 
-#endif	     /* (defined(DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE */
+#endif	     /* (defined(CONFIG_BRIDGE_DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE */
 
 #endif				/* DBG_ */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbl.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbl.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbl.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbl.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,354 +0,0 @@
-/*
- * dbl.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dbl.h ========
- *
- *! Revision History
- *! ================
- *! 19-Mar-2002 jeh     Pass DBL_Symbol pointer to DBL_getAddr, DBL_getCAddr
- *!                     to accomodate dynamic loader library.
- *! 20-Nov-2001 jeh     Removed DBL_loadArgs().
- *! 24-Sep-2001 jeh     Code review changes.
- *! 07-Sep-2001 jeh     Added DBL_LoadSect(), DBL_UnloadSect().
- *! 05-Jun-2001 jeh     Created based on zl.h.
- */
-
-#ifndef DBL_
-#define DBL_
-
-#include <dspbridge/dbdefs.h>
-#include <dspbridge/dbldefs.h>
-
-/*
- *  ======== DBL_close ========
- *  Close library opened with DBL_open.
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *  Ensures:
- */
-	extern void DBL_close(struct DBL_LibraryObj *lib);
-
-/*
- *  ======== DBL_create ========
- *  Create a target object by specifying the alloc, free, and write
- *  functions for the target.
- *  Parameters:
- *      pTarget         - Location to store target handle on output.
- *      pAttrs          - Attributes.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Memory allocation failed.
- *  Requires:
- *      DBL initialized.
- *      pAttrs != NULL.
- *      pTarget != NULL;
- *  Ensures:
- *      Success:        *pTarget != NULL.
- *      Failure:        *pTarget == NULL.
- */
-	extern DSP_STATUS DBL_create(struct DBL_TargetObj **pTarget,
-				     struct DBL_Attrs *pAttrs);
-
-/*
- *  ======== DBL_delete ========
- *  Delete target object and free resources for any loaded libraries.
- *  Parameters:
- *      target          - Handle returned from DBL_Create().
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *  Ensures:
- */
-	extern void DBL_delete(struct DBL_TargetObj *target);
-
-/*
- *  ======== DBL_exit ========
- *  Discontinue use of DBL module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      cRefs > 0.
- *  Ensures:
- *      cRefs >= 0.
- */
-	extern void DBL_exit(void);
-
-/*
- *  ======== DBL_getAddr ========
- *  Get address of name in the specified library.
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      name            - Name of symbol
- *      ppSym           - Location to store symbol address on output.
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Symbol not found.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      name != NULL.
- *      pAddr != NULL.
- *  Ensures:
- */
-	extern bool DBL_getAddr(struct DBL_LibraryObj *lib, char *name,
-				struct DBL_Symbol **ppSym);
-
-/*
- *  ======== DBL_getAttrs ========
- *  Retrieve the attributes of the target.
- *  Parameters:
- *      target          - Handle returned from DBL_Create().
- *      pAttrs          - Location to store attributes on output.
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *      pAttrs != NULL.
- *  Ensures:
- */
-	extern void DBL_getAttrs(struct DBL_TargetObj *target,
-				 struct DBL_Attrs *pAttrs);
-
-/*
- *  ======== DBL_getCAddr ========
- *  Get address of "C" name in the specified library.
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      name            - Name of symbol
- *      ppSym           - Location to store symbol address on output.
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Symbol not found.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      name != NULL.
- *      pAddr != NULL.
- *  Ensures:
- */
-	extern bool DBL_getCAddr(struct DBL_LibraryObj *lib, char *name,
-				 struct DBL_Symbol **ppSym);
-
-/*
- *  ======== DBL_getEntry ========
- *  Get program entry point.
- *
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      pEntry          - Location to store entry address on output.
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Failure.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      pEntry != NULL.
- *  Ensures:
- */
-	extern bool DBL_getEntry(struct DBL_LibraryObj *lib, u32 *pEntry);
-
-/*
- *  ======== DBL_getSect ========
- *  Get address and size of a named section.
- *  Parameters:
- *      lib             - Library handle returned from DBL_open().
- *      name            - Name of section.
- *      pAddr           - Location to store section address on output.
- *      pSize           - Location to store section size on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Section not found.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      name != NULL.
- *      pAddr != NULL;
- *      pSize != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DBL_getSect(struct DBL_LibraryObj *lib, char *name,
-				      u32 *pAddr, u32 *pSize);
-
-/*
- *  ======== DBL_init ========
- *  Initialize DBL module.
- *  Parameters:
- *  Returns:
- *      TRUE:           Success.
- *      FALSE:          Failure.
- *  Requires:
- *      cRefs >= 0.
- *  Ensures:
- *      Success:        cRefs > 0.
- *      Failure:        cRefs >= 0.
- */
-	extern bool DBL_init(void);
-
-/*
- *  ======== DBL_load ========
- *  Add symbols/code/data defined in file to that already present on
- *  the target.
- *
- *  Parameters:
- *      lib             - Library handle returned from DBL_open().
- *      flags           - Specifies whether loading code, data, and/or symbols.
- *      attrs           - May contain write, alloc, and free functions.
- *      pulEntry        - Location to store program entry on output.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EFREAD:     File read failed.
- *      DSP_EFWRITE:    Write to target failed.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      pEntry != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DBL_load(struct DBL_LibraryObj *lib, DBL_Flags flags,
-				   struct DBL_Attrs *attrs, u32 *pEntry);
-
-/*
- *  ======== DBL_loadSect ========
- *  Load a named section from an library (for overlay support).
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      sectName        - Name of section to load.
- *      attrs           - Contains write function and handle to pass to it.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Section not found.
- *      DSP_EFWRITE:    Write function failed.
- *  Requires:
- *      Valid lib.
- *      sectName != NULL.
- *      attrs != NULL.
- *      attrs->write != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DBL_loadSect(struct DBL_LibraryObj *lib,
-				       char *sectName,
-				       struct DBL_Attrs *attrs);
-
-/*
- *  ======== DBL_open ========
- *  DBL_open() returns a library handle that can be used to load/unload
- *  the symbols/code/data via DBL_load()/DBL_unload().
- *  Parameters:
- *      target          - Handle returned from DBL_create().
- *      file            - Name of file to open.
- *      flags           - Specifies whether to load symbols now.
- *      pLib            - Location to store library handle on output.
- *  Returns:
- *      DSP_SOK:            Success.
- *      DSP_EMEMORY:        Memory allocation failure.
- *      DSP_EFOPEN:         File open failure.
- *      DSP_EFREAD:         File read failure.
- *      DSP_ECORRUPTFILE:   Unable to determine target type.
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *      file != NULL.
- *      pLib != NULL.
- *      struct DBL_Attrs fopen function non-NULL.
- *  Ensures:
- *      Success:        Valid *pLib.
- *      Failure:        *pLib == NULL.
- */
-	extern DSP_STATUS DBL_open(struct DBL_TargetObj *target, char *file,
-				   DBL_Flags flags,
-				   struct DBL_LibraryObj **pLib);
-
-/*
- *  ======== DBL_readSect ========
- *  Read COFF section into a character buffer.
- *  Parameters:
- *      lib             - Library handle returned from DBL_open().
- *      name            - Name of section.
- *      pBuf            - Buffer to write section contents into.
- *      size            - Buffer size
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Named section does not exists.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      name != NULL.
- *      pBuf != NULL.
- *      size != 0.
- *  Ensures:
- */
-	extern DSP_STATUS DBL_readSect(struct DBL_LibraryObj *lib, char *name,
-				       char *pBuf, u32 size);
-
-/*
- *  ======== DBL_setAttrs ========
- *  Set the attributes of the target.
- *  Parameters:
- *      target          - Handle returned from DBL_create().
- *      pAttrs          - New attributes.
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid target.
- *      pAttrs != NULL.
- *  Ensures:
- */
-	extern void DBL_setAttrs(struct DBL_TargetObj *target,
-				 struct DBL_Attrs *pAttrs);
-
-/*
- *  ======== DBL_unload ========
- *  Remove the symbols/code/data corresponding to the library lib.
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      attrs           - Contains free() function and handle to pass to it.
- *  Returns:
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *  Ensures:
- */
-	extern void DBL_unload(struct DBL_LibraryObj *lib,
-			       struct DBL_Attrs *attrs);
-
-/*
- *  ======== DBL_unloadSect ========
- *  Unload a named section from an library (for overlay support).
- *  Parameters:
- *      lib             - Handle returned from DBL_open().
- *      sectName        - Name of section to load.
- *      attrs           - Contains free() function and handle to pass to it.
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_ENOSECT:    Named section not found.
- *  Requires:
- *      DBL initialized.
- *      Valid lib.
- *      sectName != NULL.
- *  Ensures:
- */
-	extern DSP_STATUS DBL_unloadSect(struct DBL_LibraryObj *lib,
-					 char *sectName,
-					 struct DBL_Attrs *attrs);
-
-#endif				/* DBL_ */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbldefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbldefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbldefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbldefs.h	2011-05-02 22:36:48.000000000 +0100
@@ -14,16 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dbldefs.h ========
- *
- *! Revision History
- *! ================
- *! 19-Mar-2002 jeh     Added DBL_Fxns type (to make it easier to switch
- *!                     between different loaders).
- *! 28-Sep-2001 jeh     Created from zl.h.
- */
 #ifndef DBLDEFS_
 #define DBLDEFS_
 
@@ -39,8 +29,6 @@
 
 #define DBL_MAXPATHLENGTH       255
 
-
-
 /*
  *  ======== DBL_Flags ========
  *  Specifies whether to load code, data, or symbols
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbll.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbll.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbll.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbll.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ *  DSP/BIOS Bridge Dynamic load library module interface. Function header
+ *  comments are in the file dblldefs.h.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,18 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dbll.h ========
- *  DSP/BIOS Bridge Dynamic load library module interface. Function header
- *  comments are in the file dblldefs.h.
- *
- *! Revision History
- *! ================
- *! 31-Jul-2002 jeh     Removed function comments (now in dblldefs.h).
- *! 17-Apr-2002 jeh     Created based on zl.h.
- */
-
 #ifndef DBLL_
 #define DBLL_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dblldefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dblldefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dblldefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dblldefs.h	2011-05-02 22:36:48.000000000 +0100
@@ -14,17 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dblldefs.h ========
- *
- *! Revision History
- *! ================
- *! 08-Apr-2003 map	    Consolidated DBL into DBLL name
- *! 19-Mar-2002 jeh     Added DBL_Fxns type (to make it easier to switch
- *!                     between different loaders).
- *! 28-Sep-2001 jeh     Created from zl.h.
- */
 #ifndef DBLLDEFS_
 #define DBLLDEFS_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbof.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbof.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbof.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbof.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,117 +0,0 @@
-/*
- * dbof.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dbof.h ========
- *  Description:
- *      Defines and typedefs for DSP/BIOS Bridge Object File Format (DBOF).
- *
- *! Revision History
- *! ================
- *! 12-Jul-2002 jeh     Added defines for DBOF_SectHdr page.
- *! 12-Oct-2001 jeh     Converted to std.h format.
- *! 07-Sep-2001 jeh     Added overlay support.
- *! 06-Jul-2001 jeh     Created.
- */
-
-#ifndef DBOF_
-#define DBOF_
-
-/* Enough to hold DCD section names: 32 digit ID + underscores */
-#define DBOF_DCDSECTNAMELEN     40
-
-/* Values for DBOF_SectHdr page field. */
-#define         DBOF_PROGRAM    0
-#define         DBOF_DATA       1
-#define         DBOF_CINIT      2
-
-/*
- *  ======== DBOF_FileHdr ========
- */
-	struct DBOF_FileHdr {
-		u32 magic;	/* COFF magic number */
-		u32 entry;	/* Program entry point */
-		u16 numSymbols;	/* Number of bridge symbols */
-		u16 numDCDSects;	/* Number of DCD sections */
-		u16 numSects;	/* Number of sections to load */
-		u16 numOvlySects;	/* Number of overlay sections */
-		u32 symOffset;	/* Offset in file to symbols */
-		u32 dcdSectOffset;	/* Offset to DCD sections */
-		u32 loadSectOffset;	/* Offset to loadable sections */
-		u32 ovlySectOffset;	/* Offset to overlay data */
-		u16 version;	/* DBOF version number */
-		u16 resvd;	/* Reserved for future use */
-	} ;
-
-/*
- *  ======== DBOF_DCDSectHdr ========
- */
-	struct DBOF_DCDSectHdr {
-		u32 size;	/* Sect size (target MAUs) */
-		char name[DBOF_DCDSECTNAMELEN];	/* DCD section name */
-	} ;
-
-/*
- *  ======== DBOF_OvlySectHdr ========
- */
-	struct DBOF_OvlySectHdr {
-		u16 nameLen;	/* Length of section name */
-		u16 numCreateSects;	/* # of sects loaded for create phase */
-		u16 numDeleteSects;	/* # of sects loaded for delete phase */
-		u16 numExecuteSects; /* # of sects loaded for execute phase */
-
-		/*
-		 *  Number of sections where load/unload phase is not specified.
-		 *  These sections will be loaded when create phase sects are
-		 *  loaded, and unloaded when the delete phase is unloaded.
-		 */
-		u16 numOtherSects;
-		u16 resvd;	/* Reserved for future use */
-	};
-
-/*
- *  ======== DBOF_OvlySectData ========
- */
-	struct DBOF_OvlySectData {
-		u32 loadAddr;	/* Section load address */
-		u32 runAddr;	/* Section run address */
-		u32 size;	/* Section size (target MAUs) */
-		u16 page;	/* Memory page number */
-		u16 resvd;	/* Reserved */
-	} ;
-
-/*
- *  ======== DBOF_SectHdr ========
- */
-	struct DBOF_SectHdr {
-		u32 addr;	/* Section address */
-		u32 size;	/* Section size (target MAUs) */
-		u16 page;	/* Page number */
-		u16 resvd;	/* Reserved for future use */
-	} ;
-
-/*
- *  ======== DBOF_SymbolHdr ========
- */
-	struct DBOF_SymbolHdr {
-		u32 value;	/* Symbol value */
-		u16 nameLen;	/* Length of symbol name */
-		u16 resvd;	/* Reserved for future use */
-	} ;
-
-#endif				/* DBOF_ */
-
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbreg.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbreg.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbreg.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbreg.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,113 +0,0 @@
-/*
- * dbreg.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dbreg.h ========
- *  Purpose:
- *      Registry keys for use in Linux.  This is the clearinghouse for
- *      registry definitions, hopefully eliminating overlapping between
- *      modules.
- *
- *! Revision History:
- *! ================
- *! 10-Apr-2003 vp:  Added macro for subkey TCWORDSWAP.
- *! 21-Mar-2003 sb:  Added macro for subkey SHMSize
- *! 27-Aug-2001 jeh  Added WSXREG_LOADERFILENAME.
- *! 13-Feb-2001 kc:  DSP/BIOS Bridge name updates.
- *! 29-Nov-2000 rr:  Added WSXREG_DSPTYPE_55 as 6.
- *! 06-Sep-2000 jeh: Added WSXREG_CHNLOFFSET, WSXREG_NUMCHNLS,
- *!                  WSXREG_CHNLBUFSIZE.
- *! 26-Aug-2000 rr:  MEMBASE expanded to 9 entries.
- *! 26-Jul-2000 rr:  Added WSXREG_DCDNAME for the DCD Dll name. It will
- *!                  live under WSXREG_WINSPOXCONFIG.
- *! 17-Jul-2000 rr:  REG_MGR_OBJECT and REG_DRV_OBJECT defined. They
- *!                  are stored in the Registrty under WSXREG_WINSPOXCONFIG
- *!                  when they are created in DSP_Init. WSXREG_DEVOBJECT
- *!                  and WSXREG_MGROBJECT defined.
- *! 11-Dec-1999 ag:  Renamed Isa to IsaBus due to conflict with ceddk.h.
- *! 12-Nov-1999 rr:  New Registry Defnitions.
- *! 15-Oct-1999 rr:  New entry for DevObject created. WSXREG_DEVOBJECT
- *!                  under WSXREG_DDSPDRIVERPATH
- *! 10-Nov-1997 cr:  Added WSXREG_INFPATH, WSXREG_WINDEVICEPATH,
- *!                  WSXREG_WINCURVERSION
- *! 21-Oct-1997 cr:  Added WSXREG_BUSTYPE.
- *! 08-Sep-1997 cr:  Added WSXREG_SERVICES, WSXREG_SERVICENAME and
- *!                  WSXREG_CLASSINDEX.
- *! 30-Aug-1997 cr:  Added WSXREG_SOFTWAREPATHNT & WSXREG_WBCLASSGUID.
- *! 24-Mar-1997 gp:  Added MAXCHIPINFOSUBKEY def.
- *! 18-Feb-1997 cr:  Changed Version1.1 -> Version1.0
- *! 12-Feb-1997 cr:  Changed WinSPOX -> WinBRIDGE.
- *! 11-Dec-1996 gp:  Added Perf key name in WinSPOX Config.
- *! 22-Jul-1996 gp:  Added Trace key name.
- *! 30-May-1996 cr:  Created.
- */
-
-#ifndef DBREG_
-#define DBREG_ 1	/* Defined as "1" so InstallShield programs compile. */
-
-#define REG_MGR_OBJECT      1
-#define REG_DRV_OBJECT      2
-/* general registry definitions */
-#define MAXREGPATHLENGTH    255	/* Max registry path length. Also the
-				   max registry value length. */
-#define DSPTYPE_55          6	/* This is the DSP Chip type for 55 */
-#define DSPTYPE_64          0x99
-#define IVA_ARM7            0x97    /* This is the DSP Chip type for IVA/ARM7 */
-
-#define DSPPROCTYPE_C55		5510
-#define DSPPROCTYPE_C64		6410
-#define IVAPROCTYPE_ARM7	470
-/* registry */
-#define DEVNODESTRING    "DevNode"	/* u32 devnode */
-#define CONFIG           "Software\\TexasInstruments\\DirectDSP\\Config"
-#define DRVOBJECT        "DrvObject"
-#define MGROBJECT        "MgrObject"
-#define CLASS            "Device"	/*  device class */
-#define TRACE            "Trace"	/* GT Trace settings.  */
-#define PERFR            "Perf"	/* Enable perf bool.  */
-#define ROOT             "Root"	/*  root dir */
-
-/* MiniDriver related definitions */
-/* The following definitions are under "Drivers\\DirectDSP\\Device\\XXX "
- * Where XXX is the device or board name */
-
-#define WMDFILENAME      "MiniDriver"	/* WMD entry name */
-#define CHIPTYPE         "ChipType"	/* Chip type */
-#define CHIPNUM          "NumChips"	/* Number of chips */
-#define NUMPROCS         "NumOfProcessors"	/* Number of processors */
-#define DEFEXEC          "DefaultExecutable"	/* Default executable */
-#define AUTOSTART        "AutoStart"	/* Statically load flag */
-#define IVAAUTOSTART     "IvaAutoStart"	/* Statically load flag */
-#define BOARDNAME        "BoardName"	/* Name of the Board */
-#define UNITNUMBER       "UnitNumber"	/* Unit # of the Board */
-#define BUSTYPE          "BusType"	/* Bus type board is on */
-#define BUSNUMBER        "BusNumber"	/* Bus number board is on */
-#define CURRENTCONFIG    "CurrentConfig"	/* Current resources */
-#define PCIVENDEVID      "VendorDeviceId"	/* The board's id */
-#define INFPATH          "InfPath"	/* wmd's inf filename */
-#define DEVOBJECT        "DevObject"
-#define ZLFILENAME       "ZLFileName"	/* Name of ZL file */
-#define WORDSIZE         "WordSize"	/* NumBytes in DSP Word */
-#define SHMSIZE          "SHMSize"	/* Size of SHM reservd on MPU */
-#define IVAEXTMEMSIZE    "IVAEXTMEMSize"	/* IVA External Memeory size  */
-#define TCWORDSWAP       "TCWordSwap"	/* Traffic Contoller Word Swap */
-#define DSPRESOURCES     "DspTMSResources"	/* C55 DSP resurces on OMAP */
-#define IVA1RESOURCES    "ARM7IvaResources"	/* ARM7 IVA resurces on OMAP */
-#define PHYSMEMPOOLBASE  "PhysicalMemBase"   /* Physical mem passed to driver */
-#define PHYSMEMPOOLSIZE  "PhysicalMemSize"   /* Physical mem passed to driver */
-
-#endif				/* DBREG_ */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbtype.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbtype.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dbtype.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dbtype.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,10 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This header defines data types for DSP/BIOS Bridge APIs and device
+ * driver modules. It also defines the Hungarian prefix to use for each
+ * base type.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,23 +18,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== dbtype.h ========
- *  Description:
- *      This header defines data types for DSP/BIOS Bridge APIs and device
- *      driver modules. It also defines the Hungarian
- *      prefix to use for each base type.
- *
- *
- *! Revision History:
- *! =================
- *! 23-Nov-2002 gp: Purpose -> Description in file header.
- *! 13-Feb-2001 kc: Name changed from ddsptype.h dbtype.h.
- *! 09-Oct-2000 jeh Added CHARACTER.
- *! 11-Aug-2000 ag: Added 'typedef void void'.
- *! 08-Apr-2000 ww: Cloned.
- */
-
 #ifndef DBTYPE_
 #define DBTYPE_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dehdefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dehdefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dehdefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dehdefs.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definition for mini-driver module DEH.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,18 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== dehdefs.h ========
- *  Purpose:
- *      Definition for mini-driver module DEH.
- *
- *! Revision History:
- *! ================
- *! 17-Dec-2001 ag: added #include <dspbridge/mbx_sh.h> for shared mailbox codes.
- *! 10-Dec-2001 kc: added DEH error base value and error max value.
- *! 11-Sep-2001 kc: created.
- */
-
 #ifndef DEHDEFS_
 #define DEHDEFS_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dev.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dev.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dev.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dev.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Bridge Mini-driver device operations.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,68 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dev.h ========
- *  Description:
- *      'Bridge Mini-driver device operations.
- *
- *  Public Functions:
- *      DEV_BrdWriteFxn
- *      DEV_CreateDevice
- *      DEV_Create2
- *      DEV_Destroy2
- *      DEV_DestroyDevice
- *      DEV_GetChnlMgr
- *      DEV_GetCmmMgr
- *      DEV_GetCodMgr
- *      DEV_GetDehMgr
- *      DEV_GetDevNode
- *      DEV_GetDSPWordSize
- *      DEV_GetFirst
- *      DEV_GetIntfFxns
- *      DEV_GetIOMgr
- *      DEV_GetMsgMgr
- *      DEV_GetNext
- *      DEV_GetNodeManager
- *      DEV_GetSymbol
- *      DEV_GetWMDContext
- *      DEV_Exit
- *      DEV_Init
- *      DEV_InsertProcObject
- *      DEV_IsLocked
- *      DEV_NotifyClient
- *      DEV_RegisterNotify
- *      DEV_ReleaseCodMgr
- *      DEV_RemoveDevice
- *      DEV_RemoveProcObject
- *      DEV_SetChnlMgr
- *      DEV_SetMsgMgr
- *      DEV_SetLockOwner
- *      DEV_StartDevice
- *
- *! Revision History:
- *! ================
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping feature - Dev_GetDmmMgr
- *! 09-Feb-2004 vp  Added functions required for IVA
- *! 25-Feb-2003 swa PMGR Code Review changes incorporated
- *! 05-Nov-2001 kc: Added DEV_GetDehMgr.
- *! 05-Dec-2000 jeh Added DEV_SetMsgMgr.
- *! 29-Nov-2000 rr: Incorporated code review changes.
- *! 17-Nov-2000 jeh Added DEV_GetMsgMgr.
- *! 05-Oct-2000 rr: DEV_Create2 & DEV_Destroy2 Added.
- *! 02-Oct-2000 rr: Added DEV_GetNodeManager.
- *! 11-Aug-2000 ag: Added DEV_GetCmmMgr() for shared memory management.
- *! 10-Aug-2000 rr: DEV_InsertProcObject/RemoveProcObject added.
- *! 06-Jun-2000 jeh Added DEV_GetSymbol().
- *! 05-Nov-1999 kc: Updated function prototypes.
- *! 08-Oct-1997 cr: Added explicit CDECL function identifiers.
- *! 07-Nov-1996 gp: Updated for code review.
- *! 22-Oct-1996 gp: Added DEV_CleanupProcessState().
- *! 29-May-1996 gp: Changed DEV_HDEVNODE --> CFG_HDEVNODE.
- *! 18-May-1996 gp: Created.
- */
-
 #ifndef DEV_
 #define DEV_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/devdefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/devdefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/devdefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/devdefs.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definition of common include typedef between wmd.h and dev.h. Required
+ * to break circular dependency between WMD and DEV include files.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,18 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== devdefs.h ========
- *  Purpose:
- *      Definition of common include typedef between wmd.h and dev.h. Required
- *      to break circular dependency between WMD and DEV include files.
- *
- *! Revision History:
- *! ================
- *! 12-Nov-1996 gp: Renamed from dev1.h.
- *! 30-May-1996 gp: Broke out from dev.h
- */
-
 #ifndef DEVDEFS_
 #define DEVDEFS_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/disp.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/disp.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/disp.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/disp.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge Node Dispatcher.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,35 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== disp.h ========
- *
- *  Description:
- *      DSP/BIOS Bridge Node Dispatcher.
- *
- *  Public Functions:
- *      DISP_Create
- *      DISP_Delete
- *      DISP_Exit
- *      DISP_Init
- *      DISP_NodeChangePriority
- *      DISP_NodeCreate
- *      DISP_NodeDelete
- *      DISP_NodeRun
- *
- *! Revision History:
- *! =================
- *! 28-Jan-2003 map     Removed DISP_DoCinit().
- *! 15-May-2002 jeh     Added DISP_DoCinit().
- *! 24-Apr-2002 jeh     Added DISP_MemWrite().
- *! 07-Sep-2001 jeh     Added DISP_MemCopy().
- *! 10-May-2001 jeh     Code review cleanup.
- *! 08-Aug-2000 jeh     Removed DISP_NodeTerminate since it no longer uses RMS.
- *! 17-Jul-2000 jeh     Updates to function headers.
- *! 19-Jun-2000 jeh     Created.
- */
-
 #ifndef DISP_
 #define DISP_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dispdefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dispdefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dispdefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dispdefs.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global DISP constants and types, shared by PROCESSOR, NODE, and DISP.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,18 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dispdefs.h ========
- *  Description:
- *      Global DISP constants and types, shared by PROCESSOR, NODE, and DISP.
- *
- *! Revision History
- *! ================
- *! 08-Aug-2000 jeh     Added fields to DISP_ATTRS.
- *! 06-Jul-2000 jeh     Created.
- */
-
 #ifndef DISPDEFS_
 #define DISPDEFS_
 
@@ -36,8 +26,8 @@
 		u32 ulChnlOffset; /* Offset of channel ids reserved for RMS */
 		/* Size of buffer for sending data to RMS */
 		u32 ulChnlBufSize;
-		DSP_PROCFAMILY procFamily;	/* eg, 5000 */
-		DSP_PROCTYPE procType;	/* eg, 5510 */
+		long procFamily;	/* eg, 5000 */
+		long procType;		/* eg, 5510 */
 		HANDLE hReserved1;	/* Reserved for future use. */
 		u32 hReserved2;	/* Reserved for future use. */
 	} ;
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dmm.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dmm.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dmm.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dmm.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * The Dynamic Memory Mapping(DMM) module manages the DSP Virtual address
+ * space that can be directly mapped to any MPU buffer or memory region.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,21 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dmm.h ========
- *  Purpose:
- *      The Dynamic Memory Mapping(DMM) module manages the DSP Virtual address
- *      space that can be directly mapped to any MPU buffer or memory region
- *
- *  Public Functions:
- *
- *! Revision History:
- *! ================
- *! 20-Feb-2004 sb: Created.
- *!
- */
-
 #ifndef DMM_
 #define DMM_
 
@@ -50,7 +38,7 @@
  *      This is typically called from the client process.
  */
 
-	extern DSP_STATUS DMM_GetHandle(DSP_HPROCESSOR hProcessor,
+	extern DSP_STATUS DMM_GetHandle(void *hProcessor,
 					OUT struct DMM_OBJECT **phDmmMgr);
 
 	extern DSP_STATUS DMM_ReserveMemory(struct DMM_OBJECT *hDmmMgr,
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dpc.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dpc.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dpc.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dpc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,167 +0,0 @@
-/*
- * dpc.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dpc.h ========
- *  Purpose:
- *      Deferred Procedure Call(DPC) Services.
- *
- *  Public Functions:
- *      DPC_Cancel
- *      DPC_Create
- *      DPC_Destroy
- *      DPC_Exit
- *      DPC_Init
- *      DPC_Schedule
- *
- *! Revision History:
- *! ================
- *! 31-Jan-2000 rr:  DPC_Destroy ensures Suceess and DPC Object is NULL.
- *! 21-Jan-2000 ag:  Updated comments per code review.
- *! 06-Jan-2000 ag:  Removed DPC_[Lower|Raise]IRQL[From|To]DispatchLevel.
- *! 14-Jan-1998 gp:  Added DPC_[Lower|Raise]IRQL[From|To]DispatchLevel.
- *! 18-Aug-1997 cr:  Added explicit CDECL identifiers.
- *! 28-Jul-1996 gp:  Created.
- */
-
-#ifndef DPC_
-#define DPC_
-
-	struct DPC_OBJECT;
-
-/*
- *  ======== DPC_PROC ========
- *  Purpose:
- *      Deferred processing routine.  Typically scheduled from an ISR to
- *      complete I/O processing.
- *  Parameters:
- *      pRefData:   Ptr to user data: passed in via ISR_ScheduleDPC.
- *  Returns:
- *  Requires:
- *      The DPC should not block, or otherwise acquire resources.
- *      Interrupts to the processor are enabled.
- *      DPC_PROC executes in a critical section.
- *  Ensures:
- *      This DPC will not be reenterred on the same thread.
- *      However, the DPC may take hardware interrupts during execution.
- *      Interrupts to the processor are enabled.
- */
-       typedef void(*DPC_PROC) (void *pRefData);
-
-/*
- *  ======== DPC_Cancel ========
- *  Purpose:
- *      Cancel a DPC previously scheduled by DPC_Schedule.
- *  Parameters:
- *      hDPC:           A DPC object handle created in DPC_Create().
- *  Returns:
- *      DSP_SOK:        Scheduled DPC, if any, is cancelled.
- *      DSP_SFALSE:     No DPC is currently scheduled for execution.
- *      DSP_EHANDLE:    Invalid hDPC.
- *  Requires:
- *  Ensures:
- *      If the DPC has already executed, is executing, or was not yet
- *      scheduled, this function will have no effect.
- */
-       extern DSP_STATUS DPC_Cancel(IN struct DPC_OBJECT *hDPC);
-
-/*
- *  ======== DPC_Create ========
- *  Purpose:
- *      Create a DPC object, allowing a client's own DPC procedure to be
- *      scheduled for a call with client reference data.
- *  Parameters:
- *      phDPC:          Pointer to location to store DPC object.
- *      pfnDPC:         Client's DPC procedure.
- *      pRefData:       Pointer to user-defined reference data.
- *  Returns:
- *      DSP_SOK:        DPC object created.
- *      DSP_EPOINTER:   phDPC == NULL or pfnDPC == NULL.
- *      DSP_EMEMORY:    Insufficient memory.
- *  Requires:
- *      Must not be called at interrupt time.
- *  Ensures:
- *      DSP_SOK: DPC object is created;
- *      else: *phDPC is set to NULL.
- */
-       extern DSP_STATUS DPC_Create(OUT struct DPC_OBJECT **phDPC,
-					   IN DPC_PROC pfnDPC,
-					   IN void *pRefData);
-
-/*
- *  ======== DPC_Destroy ========
- *  Purpose:
- *      Cancel the last scheduled DPC, and deallocate a DPC object previously
- *      allocated with DPC_Create().Frees the Object only if the thread and
- *      the events are terminated successfuly.
- *  Parameters:
- *      hDPC:           A DPC object handle created in DPC_Create().
- *  Returns:
- *      DSP_SOK:        Success.
- *      DSP_EHANDLE:    Invalid hDPC.
- *  Requires:
- *      All DPC's scheduled for the DPC object must have completed their
- *      processing.
- *  Ensures:
- *      (SUCCESS && hDPC is NULL) or DSP_EFAILED status
- */
-       extern DSP_STATUS DPC_Destroy(IN struct DPC_OBJECT *hDPC);
-
-/*
- *  ======== DPC_Exit ========
- *  Purpose:
- *      Discontinue usage of the DPC module.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      DPC_Init(void) was previously called.
- *  Ensures:
- *      Resources acquired in DPC_Init(void) are freed.
- */
-       extern void DPC_Exit(void);
-
-/*
- *  ======== DPC_Init ========
- *  Purpose:
- *      Initialize the DPC module's private state.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE if error occured.
- *  Requires:
- *  Ensures:
- *      A requirement for each of the other public DPC functions.
- */
-       extern bool DPC_Init(void);
-
-/*
- *  ======== DPC_Schedule ========
- *  Purpose:
- *      Schedule a deferred procedure call to be executed at a later time.
- *      Latency and order of DPC execution is platform specific.
- *  Parameters:
- *      hDPC:           A DPC object handle created in DPC_Create().
- *  Returns:
- *      DSP_SOK:        An event is scheduled for deferred processing.
- *      DSP_EHANDLE:    Invalid hDPC.
- *  Requires:
- *      See requirements for DPC_PROC.
- *  Ensures:
- *      DSP_SOK:        The DPC will not be called before this function returns.
- */
-       extern DSP_STATUS DPC_Schedule(IN struct DPC_OBJECT *hDPC);
-
-#endif				/* DPC_ */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/drv.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/drv.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/drv.h	2011-04-17 17:32:27.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/drv.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,10 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DRV Resource allocation module. Driver Object gets Created
+ * at the time of Loading. It holds the List of Device Objects
+ * in the system.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,50 +18,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== drv.h ========
- *  Purpose:
- *      DRV Resource allocation module. Driver Object gets Created
- *      at the time of Loading. It holds the List of Device Objects
- *      in the Syste,
- *
- *  Public Functions:
- *      DRV_Create
- *      DRV_Destroy
- *      DRV_Exit
- *      DRV_GetDevObject
- *      DRV_GetDevExtension
- *      DRV_GetFirstDevObject
- *      DRV_GetNextDevObject
- *      DRV_GetNextDevExtension
- *      DRV_Init
- *      DRV_InsertDevObject
- *      DRV_RemoveDevObject
- *      DRV_RequestResources
- *      DRV_ReleaseResources
- *
- *! Revision History
- *! ================
- *! 10-Feb-2004 vp:  Added OMAP24xx specific definitions.
- *! 14-Aug-2000 rr:  Cleaned up.
- *! 27-Jul-2000 rr:  DRV_RequestResources split into two(Request and Release)
- *!                  Device extension created to hold the DevNodeString.
- *! 17-Jul-2000 rr:  Driver Object holds the list of Device Objects.
- *!                  Added DRV_Create, DRV_Destroy, DRV_GetDevObject,
- *!                  DRV_GetFirst/NextDevObject, DRV_Insert/RemoveDevObject.
- *! 12-Nov-1999 rr:  New Flag defines for DRV_ASSIGN and DRV_RELEASE
- *! 25-Oct-1999 rr:  Resource Structure removed.
- *! 15-Oct-1999 rr:  New Resource structure created.
- *! 05-Oct-1999 rr:  Added DRV_RequestResources
- *!                  Removed fxn'sDRV_RegisterMiniDriver(),
- *!		     DRV_UnRegisterMiniDriver()
- *!                  Removed Structures DSP_DRIVER & DRV_EXTENSION.
- *!
- *! 24-Sep-1999 rr:  Added DRV_EXTENSION and DSP_DRIVER structures.
- *!
- */
-
 #ifndef DRV_
 #define DRV_
 
@@ -118,13 +78,12 @@
 #define OMAP_PRCM_VDD1_DOMAIN 1
 #define OMAP_PRCM_VDD2_DOMAIN 2
 
-#ifndef RES_CLEANUP_DISABLE
 
 /* GPP PROCESS CLEANUP Data structures */
 
 /* New structure (member of process context) abstracts NODE resource info */
 struct NODE_RES_OBJECT {
-	DSP_HNODE       hNode;
+	void *hNode;
 	s32            nodeAllocated; /* Node status */
 	s32            heapAllocated; /* Heap status */
 	s32            streamsAllocated; /* Streams status */
@@ -156,7 +115,7 @@ struct DSPHEAP_RES_OBJECT {
 /* New structure (member of process context) abstracts stream resource info */
 struct STRM_RES_OBJECT {
 	s32                    streamAllocated; /* Stream status */
-	DSP_HSTREAM             hStream;
+	void *hStream;
 	u32                    uNumBufs;
 	u32                    uDir;
 	struct STRM_RES_OBJECT         *next;
@@ -173,31 +132,25 @@ struct PROCESS_CONTEXT{
 	/* Process State */
 	enum GPP_PROC_RES_STATE resState;
 
-	/* Process ID (Same as UNIX process ID) */
-	u32 pid;
-
-	/* Pointer to next process context
-	* (To maintain a linked list of process contexts) */
-	struct PROCESS_CONTEXT *next;
-
-	/* List of Processors */
-	struct list_head processor_list;
-	spinlock_t proc_list_lock;
+	/* Handle to Processor */
+	void *hProcessor;
 
 	/* DSP Node resources */
 	struct NODE_RES_OBJECT *pNodeList;
+	struct mutex node_mutex;
 
 	/* DMM resources */
 	struct DMM_RES_OBJECT *pDMMList;
-	spinlock_t dmm_list_lock;
+	struct mutex dmm_mutex;
 
 	/* DSP Heap resources */
 	struct DSPHEAP_RES_OBJECT *pDSPHEAPList;
 
 	/* Stream resources */
 	struct STRM_RES_OBJECT *pSTRMList;
+	struct mutex strm_mutex;
 } ;
-#endif
+
 
 /*
  *  ======== DRV_Create ========
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/drvdefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/drvdefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/drvdefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/drvdefs.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definition of common struct between wmd.h and drv.h.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,17 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== drvdefs.h ========
- *  Purpose:
- *      Definition of common include typedef between wmd.h and drv.h.
- *
- *! Revision History:
- *! ================
- *! 17-Jul-2000 rr: Created
- */
-
 #ifndef DRVDEFS_
 #define DRVDEFS_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dspdrv.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dspdrv.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dspdrv.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dspdrv.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This is the Stream Interface for the DDSP Class driver.
+ * All Device operations are performed via DeviceIOControl.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,36 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dspdrv.h ========
- *  Purpose:
- *      This is the Stream Interface for the DDSP Class driver.
- *      All Device operations are performed via DeviceIOControl.
- *      Read, Seek and Write not used.
- *
- *  Public Functions
- *      DSP_Close
- *      DSP_Deinit
- *      DSP_Init
- *      DSP_IOControl
- *      DSP_Open
- *      DSP_PowerUp
- *      DSP_PowerDown
- *
- *! Revision History
- *! ================
- *! 28-Jan-2000 rr: Type void changed to Void.
- *! 02-Dec-1999 rr: MAX_DEV define moved from wcdce.c file.Code cleaned up.
- *! 12-Nov-1999 rr: "#include<wncnxerr.h> removed.
- *! 05-Oct-1999 rr  Renamed the file name to wcdce.h Removed Bus Specific
- *!                 code and #defines to PCCARD.h.
- *! 24-Sep-1999 rr  Changed the DSP_COMMON_WINDOW_SIZE to 0x4000(16k) for the
- *!                 Memory windows.
- *! 16-Jul-1999 ag  Adapted from rkw's CAC Bullet driver.
- *!
- */
-
 #if !defined __DSPDRV_h__
 #define __DSPDRV_h__
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dynamic_loader.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dynamic_loader.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/dynamic_loader.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/dynamic_loader.h	2011-05-02 22:36:48.000000000 +0100
@@ -14,8 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-
 #ifndef _DYNAMIC_LOADER_H_
 #define _DYNAMIC_LOADER_H_
 #include <linux/kernel.h>
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/errbase.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/errbase.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/errbase.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/errbase.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,14 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Central repository for DSP/BIOS Bridge error and status code.
+ *
+ * Error codes are of the form:
+ *     [<MODULE>]_E<ERRORCODE>
+ *
+ * Success codes are of the form:
+ *     [<MODULE>]_S<SUCCESSCODE>
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,35 +22,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== errbase.h ========
- *  Description:
- *      Central repository for DSP/BIOS Bridge error and status code.
- *
- *  Error codes are of the form:
- *      [<MODULE>]_E<ERRORCODE>
- *
- *  Success codes are of the form:
- *      [<MODULE>]_S<SUCCESSCODE>
- *
- *! Revision History:
- *! ================
- *! 24-Jan-2003 map Added DSP_SALREADYLOADED for persistent library checking
- *! 23-Nov-2002 gp: Minor comment cleanup.
- *! 13-May-2002 sg  Added DSP_SALREADYASLEEP and DSP_SALREADYWAKE.
- *! 18-Feb-2002 mk: Added DSP_EOVERLAYMEMORY, EFWRITE, ENOSECT.
- *! 31-Jan-2002 mk: Added definitions of DSP_STRUE and DSP_SFALSE.
- *! 29-Jan-2002 mk: Added definition of CFG_E_INSUFFICIENTBUFSIZE.
- *! 24-Oct-2001 sp: Consolidated all the error codes into this file.
- *! 24-Jul-2001 mk: Type-casted all definitions of WSX_STATUS types for
- *!                 removal of compile warnings.
- *! 22-Nov-1999 kc: Changes from code review.
- *! 18-Aug-1999 rr: Ported From WSX.
- *! 29-May-1996 gp: Removed WCD_ and WMD_ error ranges. Redefined format of
- *!                 error codes.
- *! 10-May-1996 gp: Created.
- */
-
 #ifndef ERRBASE_
 #define ERRBASE_
 
@@ -324,21 +303,6 @@
 /* Insufficient buffer size */
 #define CFG_E_INSUFFICIENTBUFSIZE   (CFG_EBASE + 0x05)
 
-/* FAILURE Codes : BRD */
-#define BRD_EBASE                   (DSP_COMP_EBASE + 0x300)
-
-/* Board client does not have sufficient access rights for this operation. */
-#define BRD_E_ACCESSDENIED          (BRD_EBASE + 0x00)
-
-/* Unable to find trace buffer symbols in the DSP executable COFF file. */
-#define BRD_E_NOTRACEBUFFER         (BRD_EBASE + 0x01)
-
-/* Attempted to auto-start board, but no default DSP executable configured. */
-#define BRD_E_NOEXEC                (BRD_EBASE + 0x02)
-
-/* The operation failed because it was started from a wrong state */
-#define BRD_E_WRONGSTATE            (BRD_EBASE + 0x03)
-
 /* FAILURE Codes : COD */
 #define COD_EBASE                   (DSP_COMP_EBASE + 0x400)
 
@@ -479,31 +443,4 @@
 /* Insufficient space to hold data in registry value. */
 #define REG_E_MOREDATA              (REG_EBASE + 0x03)
 
-/* FAILURE Codes : KFILE */
-#define KFILE_EBASE                 (DSP_COMP_EBASE + 0x900)
-
-/* Invalid file handle. */
-#define E_KFILE_INVALIDHANDLE       (KFILE_EBASE + 0x01)
-
-/* Bad file name. */
-#define E_KFILE_BADFILENAME         (KFILE_EBASE + 0x02)
-
-/* Invalid file mode. */
-#define E_KFILE_INVALIDMODE         (KFILE_EBASE + 0x03)
-
-/* No resources available. */
-#define E_KFILE_NORESOURCES         (KFILE_EBASE + 0x04)
-
-/* Invalid file buffer        . */
-#define E_KFILE_INVALIDBUFFER       (KFILE_EBASE + 0x05)
-
-/* Bad origin argument. */
-#define E_KFILE_BADORIGINFLAG       (KFILE_EBASE + 0x06)
-
-/* Invalid file offset value. */
-#define E_KFILE_INVALIDOFFSET       (KFILE_EBASE + 0x07)
-
-/* General KFILE error condition */
-#define E_KFILE_ERROR               (KFILE_EBASE + 0x08)
-
 #endif				/* ERRBASE_ */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/gb.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/gb.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/gb.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/gb.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Generic bitmap manager.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,14 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== gb.h ========
- *  Generic bitmap manager.
- *
- *! Revision History
- *! ================
- */
-
 #ifndef GB_
 #define GB_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/getsection.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/getsection.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/getsection.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/getsection.h	2011-05-02 22:36:48.000000000 +0100
@@ -3,6 +3,14 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This file provides an API add-on to the dynamic loader that allows the user
+ * to query section information and extract section data from dynamic load
+ * modules.
+ *
+ * Notes:
+ *   Functions in this API assume that the supplied Dynamic_Loader_Stream
+ *   object supports the set_file_posn method.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,25 +22,12 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
 #ifndef _GETSECTION_H_
 #define _GETSECTION_H_
 
 
 #include "dynamic_loader.h"
 
-/*
- * Get Section Information
- *
- * This file provides an API add-on to the dynamic loader that allows the user
- * to query section information and extract section data from dynamic load
- * modules.
- *
- * NOTE:
- * Functions in this API assume that the supplied Dynamic_Loader_Stream object
- * supports the set_file_posn method.
- */
-
 	/* opaque handle for module information */
 	typedef void *DLOAD_module_info;
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/gh.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/gh.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/gh.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/gh.h	2011-05-02 22:36:48.000000000 +0100
@@ -14,14 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== gh.h ========
- *
- *! Revision History
- *! ================
- */
-
 #ifndef GH_
 #define GH_
 #include <dspbridge/host_os.h>
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/gs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/gs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/gs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/gs.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,11 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Memory allocation/release wrappers.  This module allows clients to
+ * avoid OS spacific issues related to memory allocation.  It also provides
+ * simple diagnostic capabilities to assist in the detection of memory
+ * leaks.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,16 +19,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== gs.h ========
- *  Memory allocation/release wrappers.  This module allows clients to
- *  avoid OS spacific issues related to memory allocation.  It also provides
- *  simple diagnostic capabilities to assist in the detection of memory
- *  leaks.
- *! Revision History
- *! ================
- */
-
 #ifndef GS_
 #define GS_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/gt.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/gt.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/gt.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/gt.h	2011-05-02 22:36:49.000000000 +0100
@@ -14,25 +14,16 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
 /*
- *  ======== gt.h ========
- *  Purpose:
- *      There are two definitions that affect which portions of trace
- *      are acutally compiled into the client: GT_TRACE and GT_ASSERT. If
- *      GT_TRACE is set to 0 then all trace statements (except for assertions)
- *      will be compiled out of the client. If GT_ASSERT is set to 0 then
- *      assertions will be compiled out of the client. GT_ASSERT can not be
- *      set to 0 unless GT_TRACE is also set to 0 (i.e. GT_TRACE == 1 implies
- *      GT_ASSERT == 1).
- *
- *! Revision History
- *! ================
- *! 02-Feb-2000 rr: Renamed this file to gtce.h. GT CLASS and trace definitions
- *!                 are WinCE Specific.
- *! 03-Jan-1997	ge	Replaced "GT_" prefix to GT_Config structure members
- *!                 to eliminate preprocessor confusion with other macros.
+ * There are two definitions that affect which portions of trace
+ * are acutally compiled into the client: GT_TRACE and GT_ASSERT. If
+ * GT_TRACE is set to 0 then all trace statements (except for assertions)
+ * will be compiled out of the client. If GT_ASSERT is set to 0 then
+ * assertions will be compiled out of the client. GT_ASSERT can not be
+ * set to 0 unless GT_TRACE is also set to 0 (i.e. GT_TRACE == 1 implies
+ * GT_ASSERT == 1).
  */
+
 #include <linux/types.h>
 #ifndef GT_
 #define GT_
@@ -241,7 +232,7 @@ extern struct GT_Config _GT_params;
 
 #define GT_assert(mask, expr) \
 	(!(expr) ? \
-	    printk("assertion violation: %s, line %d\n", \
+	    pr_err("assertion violation: %s, line %d\n", \
 			    __FILE__, __LINE__), NULL : NULL)
 
 #define GT_config(config)     (_GT_params = *(config))
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/host_os.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/host_os.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/host_os.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/host_os.h	2011-05-02 22:36:49.000000000 +0100
@@ -14,16 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== windows.h ========
- *
- *! Revision History
- *! ================
- *! 08-Mar-2004 sb Added cacheflush.h to support Dynamic Memory Mapping feature
- *! 16-Feb-2004 sb Added headers required for consistent_alloc
- */
-
 #ifndef _HOST_OS_H_
 #define _HOST_OS_H_
 
@@ -54,7 +44,7 @@
 #include <linux/ioport.h>
 #include <linux/platform_device.h>
 #include <dspbridge/dbtype.h>
-#include <mach/clock.h>
+#include <mach/clock.h>
 #include <linux/clk.h>
 #include <linux/pagemap.h>
 #include <asm/cacheflush.h>
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/io.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/io.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/io.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/io.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * The io module manages IO between CHNL and MSG.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,25 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== io.h ========
- *  Description:
- *      The io module manages IO between CHNL and MSG.
- *
- *  Public Functions:
- *      IO_Create
- *      IO_Destroy
- *      IO_Exit
- *      IO_Init
- *      IO_OnLoaded
- *
- *
- *! Revision History:
- *! ================
- *! 07-Nov-2000 jeh     Created.
- */
-
 #ifndef IO_
 #define IO_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/io_sm.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/io_sm.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/io_sm.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/io_sm.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * IO dispatcher for a shared memory channel driver.
+ * Also, includes macros to simulate SHM via port io calls.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,41 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== io_sm.h ========
- *  Description:
- *      IO dispatcher for a shared memory channel driver.
- *      Also, includes macros to simulate SHM via port io calls.
- *
- *  Public Functions:
- *      IO_Dispatch
- *      IO_DPC
- *      IO_ISR
- *      IO_RequestChnl
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 01-Mar-2004 vp: Added IVA releated functions.
- *! 23-Apr-2003 sb: Fixed mailbox deadlock
- *! 06-Feb-2003 kc  Added IO_DDMAClearChnlDesc and IO_DDZCClearChnlDesc.
- *! 21-Dec-2001 ag  Removed unused param in IO_DDMAInitChnlDesc().
- *                  Updated comments. Removed #ifdef CHNL_NOIPCINTR.
- *! 05-Nov-2001 kc  Updated IO_CALLISR macro.
- *! 01-May-2001 jeh Removed IO_RequestMsg.
- *! 29-Mar-2001 ag  Added #ifdef CHNL_NOIPCINTR.
- *! 04-Dec-2000 jeh Added IO_RequestMsg.
- *! 26-Oct-2000 jeh Added IO_GetLong, IO_SetLong, IO_ReadValueLong, and
- *!                 IO_WriteValueLong, for passing arg in SHM structure.
- *! 20-Jan-2000 ag: Updated header comments per code review.
- *! 05-Jan-2000 ag: Text format clean-up.
- *! 02-Nov-1999 ag: Updated header descriptions.
- *! 25-May-1999 jg: Removed assumption of 4 bytes / word.
- *! 12-Aug-1996 gp: Created.
- */
-
 #ifndef IOSM_
 #define IOSM_
 
@@ -109,7 +77,7 @@
  *  Ensures:
  *      Non-preemptible (but interruptible).
  */
-	extern void IO_DPC(IN OUT void *pRefData);
+	extern void IO_DPC(IN OUT unsigned long pRefData);
 
 /*
  *  ======== IO_ISR ========
@@ -292,9 +260,8 @@
  *      pArgs != NULL
  *  Ensures:
  */
-	extern DSP_STATUS IO_SHMsetting(IN struct IO_MGR *hIOMgr,
-					IN enum SHM_DESCTYPE desc,
-					IN void *pArgs);
+	extern DSP_STATUS IO_SHMsetting(struct IO_MGR *hIOMgr,
+					u8 desc, void *pArgs);
 
 /*
  *  Misc functions for the CHNL_IO shared memory library:
@@ -323,13 +290,13 @@
 
 	extern void IO_IntrDSP2(IN struct IO_MGR *pIOMgr, IN u16 wMbVal);
 
-       extern void IO_SM_init(void);
+	extern void IO_SM_init(void);
 
 /*
  *  ========PrintDspTraceBuffer ========
  *      Print DSP tracebuffer.
  */
-       extern DSP_STATUS PrintDspTraceBuffer(struct WMD_DEV_CONTEXT
-                                               *hWmdContext);
+	extern DSP_STATUS PrintDspTraceBuffer(struct WMD_DEV_CONTEXT
+						*hWmdContext);
 
 #endif				/* IOSM_ */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/iodefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/iodefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/iodefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/iodefs.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * System-wide channel objects and constants.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,17 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== iodefs.h ========
- *  Description:
- *      System-wide channel objects and constants.
- *
- *! Revision History:
- *! ================
- *! 07-Nov-2000 jeh     Created.
- */
-
 #ifndef IODEFS_
 #define IODEFS_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/kfile.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/kfile.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/kfile.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/kfile.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,216 +0,0 @@
-/*
- * kfile.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== kfile.h ========
- *  Purpose:
- *      Provide file I/O management capabilities.
- *
- *  Public Functions:
- *      KFILE_Close
- *      KFILE_Exit
- *      KFILE_Init
- *      KFILE_Open
- *      KFILE_Read
- *      KFILE_Seek
- *      KFILE_Tell
- *      KFILE_Write
- *
- *  Notes:
- *      The KFILE module is not like most of the other DSP/BIOS Bridge modules
- *      in that it doesn't return WSX_STATUS type values.  Rather, it's
- *      prototypes are meant to match the stdio file prototypes
- *      (ie, fopen, fclose, etc.).
- *
- *! Revision History
- *! ================
- *! 29-Oct-1999 kc:  Clean up for code review.
- *! 07-Jan-1998 cr:  Clean up for code review.
- *! 15-Aug-1997 cr:  Added E_KFILE_ERROR for general error condition.
- *! 04-Aug-1997 cr:  Added explicit CDECL descriptions.
- *! 11-Nov-1996 cr:  Implemented changes based on code review.
- *! 05-Nov-1996 cr:  Cleaned up for code review.
- *! 29-May-1996 gp:  Added requirement that size != 0 in _Write() and _Read().
- *! 28-May-1996 mg:  Changed return values for Read/Write.
- *! 14-Dec-1995 cr:  Created.
- */
-
-#ifndef KFILE_
-#define KFILE_
-
-/*
- *  Constants for KFILE_Seek.  Note that these MUST be the same definitions as
- *  those defined for fseek.
- */
-#define KFILE_SEEK_SET          0x00	/* seek from beginning of file */
-#define KFILE_SEEK_CUR          0x01	/* seek from current position */
-#define KFILE_SEEK_END          0x02	/* seek from end of file */
-
-	struct KFILE_FileObj;
-
-/*
- *  ======== KFILE_Close ========
- *  Purpose:
- *      This function closes a file's stream.
- *  Parameters:
- *      hFile:      Handle of the file stream returned by KFILE_Open.
- *  Returns:
- *      E_KFILE_INVALIDHANDLE:  bad handle.
- *      0:                      success.
- *      E_KFILE_ERROR:          unable to close specified handle.
- *  Requires:
- *      KFILE initialized.
- *  Ensures:
- */
-	extern s32 KFILE_Close(IN struct KFILE_FileObj *hFile);
-
-/*
- *  ======== KFILE_Exit ========
- *  Purpose:
- *      Discontinue usage of module; free resources when reference count
- *      reaches 0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      KFILE initialized.
- *  Ensures:
- *      Resources used by module are freed when cRef reaches zero.
- */
-	extern void KFILE_Exit(void);
-
-/*
- *  ======== KFILE_Init ========
- *  Purpose:
- *      Initializes private state of KFILE module.
- *  Parameters:
- *  Returns:
- *      TRUE if success, else FALSE.
- *  Requires:
- *  Ensures:
- *      KFILE initialized.
- */
-	extern bool KFILE_Init(void);
-
-/*
- *  ======== KFILE_Open ========
- *  Purpose:
- *      Opens a file for use.
- *  Parameters:
- *      pszFileName:    Full path to name of the file to open.
- *      pszMode:        String containing open status.  Only the first
- *                      character of the string is examined, for either
- *                      "r" (read) or "w" (write) mode.
- *  Returns:
- *      A valid file handle if success, else NULL.
- *  Requires:
- *      - KFILE initialized.
- *      - pszMode != NULL.
- *      - pszFileName != NULL.
- *  Ensures:
- */
-	extern struct KFILE_FileObj *KFILE_Open(IN CONST char *filename,
-				       IN CONST char *mode);
-
-/*
- *  ======== KFILE_Read ========
- *  Purpose:
- *      This function reads a specified number of bytes into a buffer.
- *  Parameters:
- *      pBuffer:    Array to which the file data is copied.
- *      cSize:      Number of characters in each object.
- *      cCount:     Number of objects to read in.
- *      hFile:      Handle of the file stream returned by KFILE_Open.
- *  Returns:
- *      E_KFILE_INVALIDHANDLE:  bad file handle.
- *      E_KFILE_ERROR:          general failure.
- *      > 0:                    success; # of objects read from file.
- *  Requires:
- *      KFILE initialized.
- *      pBuffer is a valid pointer.
- *  Ensures:
- */
-	extern s32 KFILE_Read(OUT void __user*buffer,
-			      IN s32 size, IN s32 count,
-			      IN struct KFILE_FileObj *hFile);
-
-/*
- *  ======== KFILE_Seek ========
- *  Purpose:
- *      This function sets the file position indicator.  NOTE:  we don't
- *      support seeking beyond the boundaries of a file.
- *  Parameters:
- *      hFile:      Handle of the file stream returned by KFILE_Open.
- *      offset:     Number of bytes from the origin to move.
- *      origin:     File reference point, one of the following values:
- *                  KFILE_SEEK_SET:  Seek from beginning of file.
- *                  KFILE_SEEK_CUR:  Seek from current position.
- *                  KFILE_SEEK_END:  Seek from end of file.
- *  Returns:
- *      0: success.
- *      E_KFILE_INVALIDHANDLE:  bad handle.
- *      E_KFILE_BADORIGIN:      invalid origin paramater.
- *      E_KFILE_ERROR:          general failure.
- *  Requires:
- *      KFILE initialized.
- *  Ensures:
- */
-	extern s32 KFILE_Seek(IN struct KFILE_FileObj *hFile,
-			      IN s32 offset, IN s32 origin);
-
-/*
- *  ======== KFILE_Tell ========
- *  Purpose:
- *      This function reports the current value of the position indicator.
- *  Parameters:
- *      hFile:          Handle of the file stream returned by KFILE_Open.
- *  Return value:
- *      > 0: success; returns # of bytes the position indicator is from
- *           beginning of file.
- *      E_KFILE_ERROR:          general failure.
- *      E_KFILE_INVALIDHANDLE:  bad file handle.
- *  Requires:
- *      KFILE initialized.
- *  Ensures:
- */
-	extern s32 KFILE_Tell(IN struct KFILE_FileObj *hFile);
-
-/*
- *  ======== KFILE_Write ========
- *  Purpose:
- *      This function writes a number of objects to the stream.
- *  Parameters:
- *      pBuffer:    Array from which the file data is written.
- *      cSize:      Number of characters in each object.
- *      cCount:     Number of objects to write out.
- *      hFile:      Handle of the file stream returned by KFILE_Open.
- *  Returns:
- *      E_KFILE_INVALIDHANDLE:  bad file handle.
- *      E_KFILE_ERROR:          general failure.
- *      > 0:                    success; # of objects written to file.
- *  Requires:
- *      KFILE initialized.
- *      pBuffer != NULL.
- *  Postcondition:
- *      The file position indicator is advanced by the number of
- *      characters written.
- */
-	extern s32 KFILE_Write(OUT void *buffer,
-			       IN s32 size,
-			       IN s32 count,
-			       IN struct KFILE_FileObj *hFile);
-
-#endif				/* KFILE_ */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/ldr.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/ldr.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/ldr.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/ldr.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,12 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provide module loading services and symbol export services.
+ *
+ * Notes:
+ *   This service is meant to be used by modules of the DSP/BIOS Bridge
+ *   class driver.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,34 +20,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== ldr.h ========
- *  Purpose:
- *      Provide module loading services and symbol export services.
- *
- *  Public Functions:
- *      LDR_Exit
- *      LDR_FreeModule
- *      LDR_GetProcAddress
- *      LDR_Init
- *      LDR_LoadModule
- *
- *  Notes:
- *      This service is meant to be used by modules of the DSP/BIOS Bridge
- *       class driver.
- *
- *! Revision History:
- *! ================
- *! 22-Nov-1999 kc: Changes from code review.
- *! 12-Nov-1999 kc: Removed declaration of unused loader object.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 12-Jan-1998 cr: Cleaned up for code review.
- *! 04-Aug-1997 cr: Added explicit CDECL identifiers.
- *! 11-Nov-1996 cr: Cleaned up for code review.
- *! 16-May-1996 gp: Created.
- */
-
 #ifndef LDR_
 #define LDR_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/list.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/list.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/list.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/list.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Declarations of list management control structures and definitions
+ * of inline list management functions.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,115 +17,17 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== list.h ========
- *  Purpose:
- *      Declarations of list management control structures and definitions
- *      of inline list management functions.
- *
- *  Public Functions:
- *      LST_Create
- *      LST_Delete
- *      LST_Exit
- *      LST_First
- *      LST_GetHead
- *      LST_InitElem
- *      LST_Init
- *      LST_InsertBefore
- *      LST_IsEmpty
- *      LST_Next
- *      LST_PutTail
- *      LST_RemoveElem
- *
- *  Notes:
- *
- *! Revision History
- *! ================
- *! 10-Aug-2000 ag:  Added LST_InsertBefore().
- *! 29-Oct-1999 kc:  Cleaned up for code review.
- *! 16-Aug-1997 cr:  added explicit identifiers.
- *! 10-Aug-1996 gp:  Acquired from SMM for WinSPOX v.1.1; renamed identifiers.
- *! 21-Oct-1994 dh4: Cleaned / commented for code review.
- *! 08-Jun-1994 dh4: Converted to SPM (added extern "C").
- */
-
 #ifndef LIST_
 #define LIST_
 
 #include <dspbridge/host_os.h>
+#include <linux/list.h>
 
-#define LST_IsEmpty(l)      (((l)->head.next == &(l)->head))
+#define LST_IsEmpty(l)      list_empty(&(l)->head)
 
-	struct LST_ELEM {
-		struct LST_ELEM *next;
-		struct LST_ELEM *prev;
-		struct LST_ELEM *self;
-	} ;
-
-	struct LST_LIST {
-		struct LST_ELEM head;
-	} ;
-
-/*
- *  ======== LST_Create ========
- *  Purpose:
- *      Allocates and initializes a circular list.
- *  Details:
- *      Uses portable MEM_Calloc() function to allocate a list containing
- *      a single element and initializes that element to indicate that it
- *      is the "end of the list" (i.e., the list is empty).
- *      An empty list is indicated by the "next" pointer in the element
- *      at the head of the list pointing to the head of the list, itself.
- *  Parameters:
- *  Returns:
- *      Pointer to beginning of created list (success)
- *      NULL --> Allocation failed
- *  Requires:
- *      LST initialized.
- *  Ensures:
- *  Notes:
- *      The created list contains a single element.  This element is the
- *      "empty" element, because its "next" and "prev" pointers point at
- *      the same location (the element itself).
- */
-	extern struct LST_LIST *LST_Create(void);
-
-/*
- *  ======== LST_Delete ========
- *  Purpose:
- *      Removes a list by freeing its control structure's memory space.
- *  Details:
- *      Uses portable MEM_Free() function to deallocate the memory
- *      block pointed at by the input parameter.
- *  Parameters:
- *      pList:  Pointer to list control structure of list to be deleted
- *  Returns:
- *      Void
- *  Requires:
- *      - LST initialized.
- *      - pList != NULL.
- *  Ensures:
- *  Notes:
- *      Must ONLY be used for empty lists, because it does not walk the
- *      chain of list elements.  Calling this function on a non-empty list
- *      will cause a memory leak.
- */
-	extern void LST_Delete(IN struct LST_LIST *pList);
-
-/*
- *  ======== LST_Exit ========
- *  Purpose:
- *      Discontinue usage of module; free resources when reference count
- *      reaches 0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      LST initialized.
- *  Ensures:
- *      Resources used by module are freed when cRef reaches zero.
- */
-	extern void LST_Exit(void);
+struct LST_LIST {
+	struct list_head head;
+};
 
 /*
  *  ======== LST_First ========
@@ -138,7 +43,12 @@
  *      - pList != NULL.
  *  Ensures:
  */
-	extern struct LST_ELEM *LST_First(IN struct LST_LIST *pList);
+static inline struct list_head *LST_First(struct LST_LIST *pList)
+{
+	if (pList && !list_empty(&pList->head))
+		return pList->head.next;
+	return NULL;
+}
 
 /*
  *  ======== LST_GetHead ========
@@ -160,7 +70,6 @@
  *      Pointer to element that was at the head of the list (success)
  *      NULL          No elements in list
  *  Requires:
- *      - head.self must be correctly set to &head.
  *      - LST initialized.
  *      - pList != NULL.
  *  Ensures:
@@ -169,20 +78,19 @@
  *      the head of the list, and the head of the list points backward (its
  *      "prev" pointer) to the tail of the list, this list is circular.
  */
-	extern struct LST_ELEM *LST_GetHead(IN struct LST_LIST *pList);
+static inline struct list_head *LST_GetHead(struct LST_LIST *pList)
+{
+	struct list_head *pElem;
+
+	if (!pList || list_empty(&pList->head))
+		return NULL;
+
+	pElem = pList->head.next;
+	pList->head.next = pElem->next;
+	pElem->next->prev = &pList->head;
 
-/*
- *  ======== LST_Init ========
- *  Purpose:
- *      Initializes private state of LST module.
- *  Parameters:
- *  Returns:
- *      TRUE if initialized; FALSE otherwise.
- *  Requires:
- *  Ensures:
- *      LST initialized.
- */
-	extern bool LST_Init(void);
+	return pElem;
+}
 
 /*
  *  ======== LST_InitElem ========
@@ -200,7 +108,13 @@
  *      of a list chain -- that would break the chain.
  *
  */
-	extern void LST_InitElem(IN struct LST_ELEM *pListElem);
+static inline void LST_InitElem(struct list_head *pElem)
+{
+	if (pElem) {
+		pElem->next = NULL;
+		pElem->prev = NULL;
+	}
+}
 
 /*
  *  ======== LST_InsertBefore ========
@@ -218,9 +132,13 @@
  *      - pElemExisting != NULL.
  *  Ensures:
  */
-	extern void LST_InsertBefore(IN struct LST_LIST *pList,
-				     IN struct LST_ELEM *pElem,
-				     IN struct LST_ELEM *pElemExisting);
+static inline void LST_InsertBefore(struct LST_LIST *pList,
+				    struct list_head *pElem,
+				    struct list_head *pElemExisting)
+{
+	if (pList && pElem && pElemExisting)
+		list_add_tail(pElem, pElemExisting);
+}
 
 /*
  *  ======== LST_Next ========
@@ -238,8 +156,14 @@
  *      - pCurElem != NULL.
  *  Ensures:
  */
-	extern struct LST_ELEM *LST_Next(IN struct LST_LIST *pList,
-					 IN struct LST_ELEM *pCurElem);
+static inline struct list_head *LST_Next(struct LST_LIST *pList,
+					 struct list_head *pCurElem)
+{
+	if (pList && !list_empty(&pList->head) && pCurElem &&
+	   (pCurElem->next != &pList->head))
+		return pCurElem->next;
+	return NULL;
+}
 
 /*
  *  ======== LST_PutTail ========
@@ -262,18 +186,18 @@
  *      Void
  *  Requires:
  *      *pElem and *pList must both exist.
- *      pElem->self = pElem before pElem is passed to this function.
  *      LST initialized.
  *  Ensures:
  *  Notes:
  *      Because the tail is always "just before" the head of the list (the
  *      tail's "next" pointer points at the head of the list, and the head's
  *      "prev" pointer points at the tail of the list), the list is circular.
- *  Warning: if pElem->self is not set beforehand, LST_GetHead() will
- *      return an erroneous pointer when it is called for this element.
  */
-	extern void LST_PutTail(IN struct LST_LIST *pList,
-				IN struct LST_ELEM *pListElem);
+static inline void LST_PutTail(struct LST_LIST *pList, struct list_head *pElem)
+{
+	if (pList && pElem)
+		list_add_tail(pElem, &pList->head);
+}
 
 /*
  *  ======== LST_RemoveElem ========
@@ -290,7 +214,11 @@
  *      - pCurElem != NULL.
  *  Ensures:
  */
-extern void LST_RemoveElem(IN struct LST_LIST *pList,
-			   IN struct LST_ELEM *pCurElem);
+static inline void LST_RemoveElem(struct LST_LIST *pList,
+				  struct list_head *pCurElem)
+{
+	if (pList && !list_empty(&pList->head) && pCurElem)
+		list_del_init(pCurElem);
+}
 
 #endif				/* LIST_ */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/mbx_sh.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/mbx_sh.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/mbx_sh.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/mbx_sh.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definitions for shared mailbox cmd/data values.(used on both
+ * the GPP and DSP sides).
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,15 +17,10 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
 /*
- *  ======== mbx_sh.h ========
- *  Definitions for shared mailbox cmd/data values.(used on both
- *     the GPP and DSP sides).
- *
  *  Bridge usage of OMAP mailbox 1 is determined by the "class" of the
- *     mailbox interrupt's cmd value received. The class value are defined
- *     as a bit (10 thru 15) being set.
+ *  mailbox interrupt's cmd value received. The class value are defined
+ *  as a bit (10 thru 15) being set.
  *
  *  Note: Only 16 bits of each  is used. Other 16 bit data reg available.
  *
@@ -37,7 +35,6 @@
  *   |  (class)  | (module specific) |
  *
  *
- *
  * B: DSP-DMA link driver channels (DDMA) : class = 1.
  *
  *    15         10                  0
@@ -50,8 +47,6 @@
  *         c -> channel Id    (32 DDMA chnls max)
  *
  *
- *
- *
  * C: Proc-copy link driver channels (PCPY) : class = 2.
  *
  *    15         10                  0
@@ -110,16 +105,6 @@
  *   where x -> not used
  *         c -> Power management command
  *
- *
- *
- *! Revision History:
- *! ================
- *! 19-Sep-2002 mr  Added DEH reset const
- *! 24-Apr-2002 sg  Added more PM commands.
- *! 04-Mar-2002 gv  Added MBX_PM_CLASS
- *! 22-Jan-2002 ag  Bug fix in MBX_SETZCPYVAL(x) macro.
- *! 21-Dec-2001 ag  Added bit masks defns.
- *! 17-Dec-2001 ag: created.
  */
 
 #ifndef _MBX_SH_H
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/mem.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/mem.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/mem.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/mem.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Memory management and address mapping services for the DSP/BIOS Bridge
+ * class driver and mini-driver.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,57 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== mem.h ========
- *  Purpose:
- *      Memory management and address mapping services for the DSP/BIOS Bridge
- *      class driver and mini-driver.
- *
- *  Public Functions:
- *      MEM_Alloc
- *      MEM_AllocObject
- *      MEM_AllocPhysMem
- *      MEM_Calloc
- *      MEM_Exit
- *      MEM_FlushCache
- *      MEM_Free
- *      MEM_FreeObject
- *      MEM_FreePhysMem
- *      MEM_GetNumPages
- *      MEM_Init
- *      MEM_IsValidHandle
- *      MEM_LinearAddress
- *      MEM_PageLock
- *      MEM_PageUnlock
- *      MEM_UnMapLinearAddress
- *      MEM_VirtualToPhysical
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb: Added Alloc/Free PhysMem, FlushCache, VirtualToPhysical
- *! 01-Sep-2001 ag: Cleaned up notes for MEM_LinearAddress() does not
- *!                   require phys address to be page aligned!
- *! 02-Dec-1999 rr: stdwin.h included for retail build
- *! 12-Nov-1999 kc: Added warning about use of MEM_LinearAddress.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 10-Aug-1999 kc: Based on wsx-c18.
- *! 07-Jan-1998 gp: Added MEM_AllocUMB and MEM_UMBFree for User Mapped Buffers
- *!                 used by WMD_CHNL.
- *! 23-Dec-1997 cr: Code review cleanup, removed dead Ring 3 code.
- *! 04-Aug-1997 cr: Added explicit CDECL identifiers.
- *! 01-Nov-1996 gp: Updated based on code review.
- *! 04-Sep-1996 gp: Added MEM_PageLock() and MEM_PageUnlock() services.
- *! 14-Aug-1996 mg: Added MEM_GetPhysAddr() and MEM_GetNumPages()
- *! 25-Jul-1996 gp: Added MEM_IsValidHandle() macro.
- *! 10-May-1996 gp: Added MEM_Calloc().
- *! 25-Apr-1996 gp: Added MEM_PhysicalAddress()
- *! 17-Apr-1996 gp: Added MEM_Exit function; updated to latest naming standard.
- *! 08-Apr-1996 gp: Created.
- */
-
 #ifndef MEM_
 #define MEM_
 
@@ -108,13 +60,13 @@
  *  Ensures:
  *      A subsequent call to MEM_IsValidHandle() will succeed for this object.
  */
-#define MEM_AllocObject(pObj, Obj, Signature)           \
-{                                                       \
-    pObj = MEM_Calloc(sizeof(Obj), MEM_NONPAGED);       \
-    if (pObj) {                                         \
-	pObj->dwSignature = Signature;                  \
-    }                                                   \
-}
+#define MEM_AllocObject(pObj, Obj, Signature)		\
+do {							\
+	pObj = MEM_Calloc(sizeof(Obj), MEM_NONPAGED);	\
+	if (pObj) {					\
+		pObj->dwSignature = Signature;		\
+	}						\
+} while (0)
 
 /*  ======== MEM_AllocPhysMem ========
  *  Purpose:
@@ -252,11 +204,11 @@
  *  Ensures:
  *      A subsequent call to MEM_IsValidHandle() will fail for this object.
  */
-#define MEM_FreeObject(pObj)    \
-{                               \
-    pObj->dwSignature = 0x00;   \
-    MEM_Free(pObj);             \
-}
+#define MEM_FreeObject(pObj)		\
+do {					\
+	pObj->dwSignature = 0x00;	\
+	MEM_Free(pObj);			\
+} while (0)
 
 /*
  *  ======== MEM_GetNumPages ========
@@ -354,4 +306,9 @@
 	extern void MEM_ExtPhysPoolInit(IN u32 poolPhysBase,
 					IN u32 poolSize);
 
+/*
+ *  ======== MEM_ExtPhysPoolRelease ========
+ */
+	extern void MEM_ExtPhysPoolRelease(void);
+
 #endif				/* MEM_ */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/memdefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/memdefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/memdefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/memdefs.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global MEM constants and types, shared between WCD and WMD.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,20 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== memdefs.h ========
- *  Purpose:
- *      Global MEM constants and types, shared between WSX, WCD, and WMD.
- *
- *! Revision History:
- *! ================
- *! 28-Aug-2001 ag:  Added MEM_[SET][GET]VIRTUALSEGID.
- *! 10-Aug-1999 kc:  Based on wsx-c18.
- *! 15-Nov-1996 gp:  Renamed from wsxmem.h and moved to kwinos.
- *! 21-Aug-1996 cr:  Created from mem.h.
- */
-
 #ifndef MEMDEFS_
 #define MEMDEFS_
 
@@ -46,7 +34,4 @@
 #define MEM_GETVIRTUALSEGID     0x20000000
 #define MEM_MASKVIRTUALSEGID    (MEM_SETVIRTUALSEGID | MEM_GETVIRTUALSEGID)
 
-#define TO_VIRTUAL_UNCACHED(x) x
-#define INTREG_TO_VIRTUAL_UNCACHED(x) x
-
 #endif				/* MEMDEFS_ */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/mgr.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/mgr.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/mgr.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/mgr.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This is the Class driver RM module interface.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,36 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== mgr.h ========
- *  Description:
- *      This is the Class driver RM module interface.
- *
- *  Public Functions:
- *      MGR_Create
- *      MGR_Destroy
- *      MGR_EnumNodeInfo
- *      MGR_EnumProcessorInfo
- *      MGR_Exit
- *      MGR_GetDCDHandle
- *      MGR_Init
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 15-Oct-2002 kc: Removed legacy PERF definitions.
- *! 11-Jul-2001 jeh Added CFG_HDEVNODE parameter to MGR_Create().
- *! 22-Nov-2000 kc: Added MGR_GetPerfData for acquiring PERF stats.
- *! 03-Nov-2000 rr: Added MGR_GetDCDHandle. Modified after code review.
- *! 25-Sep-2000 rr: Updated to Version 0.9
- *! 14-Aug-2000 rr: Cleaned up.
- *! 07-Aug-2000 rr: MGR_Create does the job of Loading DCD Dll.
- *! 27-Jul-2000 rr: Updated to ver 0.8 of DSPAPI(types).
- *! 20-Jun-2000 rr: Created.
- */
-
 #ifndef MGR_
 #define MGR_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/mgrpriv.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/mgrpriv.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/mgrpriv.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/mgrpriv.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global MGR constants and types, shared by PROC, MGR, and WCD.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,18 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== mgrpriv.h ========
- *  Description:
- *      Global MGR constants and types, shared by PROC, MGR, and WCD.
- *
- *! Revision History:
- *! ================
- *! 29-July-2001 ag: added MGR_PROCESSOREXTINFO.
- *! 05-July-2000 rr: Created
- */
-
 #ifndef MGRPRIV_
 #define MGRPRIV_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/msg.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/msg.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/msg.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/msg.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge MSG Module.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,28 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== msg.h ========
- *  Description:
- *      DSP/BIOS Bridge MSG Module.
- *
- *  Public Functions:
- *      MSG_Create
- *      MSG_Delete
- *      MSG_Exit
- *      MSG_Init
- *
- *  Notes:
- *
- *! Revision History:
- *! =================
- *! 17-Nov-2000 jeh     Removed MSG_Get, MSG_Put, MSG_CreateQueue,
- *!                     MSG_DeleteQueue, and MSG_RegisterNotify, since these
- *!                     are now part of mini-driver.
- *! 12-Sep-2000 jeh     Created.
- */
-
 #ifndef MSG_
 #define MSG_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/msgdefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/msgdefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/msgdefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/msgdefs.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global MSG constants and types.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,19 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== msgdefs.h ========
- *  Description:
- *      Global MSG constants and types.
- *
- *! Revision History
- *! ================
- *! 09-May-2001 jeh Removed MSG_TODSP, MSG_FROMDSP.
- *! 17-Nov-2000 jeh Added MSGMGR_SIGNATURE.
- *! 12-Sep-2000 jeh Created.
- */
-
 #ifndef MSGDEFS_
 #define MSGDEFS_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/nldr.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/nldr.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/nldr.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/nldr.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge dynamic loader interface.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,33 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== nldr.h ========
- *
- *  Description:
- *      DSP/BIOS Bridge dynamic loader interface. See the file dldrdefs.h
- *  for a description of these functions.
- *
- *  Public Functions:
- *      NLDR_Allocate
- *      NLDR_Create
- *      NLDR_Delete
- *      NLDR_Exit
- *      NLDR_Free
- *      NLDR_GetFxnAddr
- *      NLDR_Init
- *      NLDR_Load
- *      NLDR_Unload
- *
- *  Notes:
- *
- *! Revision History
- *! ================
- *! 31-Jul-2002 jeh     Removed function header comments.
- *! 17-Apr-2002 jeh     Created.
- */
-
 #include <dspbridge/dbdefs.h>
 #include <dspbridge/dbdcddef.h>
 #include <dspbridge/dev.h>
@@ -63,7 +38,6 @@
 
 	extern void NLDR_Delete(struct NLDR_OBJECT *hNldr);
 	extern void NLDR_Exit(void);
-	extern void NLDR_Free(struct NLDR_NODEOBJECT *hNldrNode);
 
 	extern DSP_STATUS NLDR_GetFxnAddr(struct NLDR_NODEOBJECT *hNldrNode,
 					  char *pstrFxn, u32 *pulAddr);
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/nldrdefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/nldrdefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/nldrdefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/nldrdefs.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global Dynamic + static/overlay Node loader (NLDR) constants and types.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,18 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== nldrdefs.h ========
- *  Description:
- *      Global Dynamic + static/overlay Node loader (NLDR) constants and types.
- *
- *! Revision History
- *! ================
- *! 07-Apr-2003 map     Consolidated dldrdefs.h into nldrdefs.h
- *! 05-Aug-2002 jeh     Created.
- */
-
 #ifndef NLDRDEFS_
 #define NLDRDEFS_
 
@@ -297,7 +287,6 @@
 		NLDR_CREATEFXN pfnCreate;
 		NLDR_DELETEFXN pfnDelete;
 		NLDR_EXITFXN pfnExit;
-		NLDR_FREEFXN pfnFree;
 		NLDR_GETFXNADDRFXN pfnGetFxnAddr;
 		NLDR_INITFXN pfnInit;
 		NLDR_LOADFXN pfnLoad;
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/node.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/node.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/node.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/node.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge Node Manager.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,52 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== node.h ========
- *  Description:
- *      DSP/BIOS Bridge Node Manager.
- *
- *  Public Functions:
- *      NODE_Allocate
- *      NODE_AllocMsgBuf
- *      NODE_ChangePriority
- *      NODE_Connect
- *      NODE_Create
- *      NODE_CreateMgr
- *      NODE_Delete
- *      NODE_DeleteMgr
- *      NODE_EnumNodes
- *      NODE_Exit
- *      NODE_FreeMsgBuf
- *      NODE_GetAttr
- *      NODE_GetMessage
- *      NODE_GetProcessor
- *      NODE_Init
- *      NODE_OnExit
- *      NODE_Pause
- *      NODE_PutMessage
- *      NODE_RegisterNotify
- *      NODE_Run
- *      NODE_Terminate
- *
- *  Notes:
- *
- *! Revision History:
- *! =================
- *! 23-Apr-2001 jeh     Updated with code review changes.
- *! 16-Jan-2001 jeh     Added DSP_ESYMBOL, DSP_EUUID to return codes.
- *! 17-Nov-2000 jeh     Added NODE_OnExit().
- *! 27-Oct-2000 jeh     Added timeouts to NODE_GetMessage, NODE_PutMessage.
- *! 12-Oct-2000 jeh     Changed NODE_EnumNodeInfo to NODE_EnumNodes. Removed
- *!                     NODE_RegisterAllNodes().
- *! 07-Sep-2000 jeh     Changed type HANDLE in NODE_RegisterNotify to
- *!                     DSP_HNOTIFICATION. Added DSP_STRMATTR param to
- *!                     NODE_Connect(). Removed NODE_GetMessageStream().
- *! 17-Jul-2000 jeh     Updated function header descriptions.
- *! 19-Jun-2000 jeh     Created.
- */
-
 #ifndef NODE_
 #define NODE_
 
@@ -352,7 +308,7 @@
  *        (*puAllocated == *puNumNodes)
  */
 	extern DSP_STATUS NODE_EnumNodes(struct NODE_MGR *hNodeMgr,
-					 IN DSP_HNODE *aNodeTab,
+					 void **aNodeTab,
 					 u32 uNodeTabSize,
 					 OUT u32 *puNumNodes,
 					 OUT u32 *puAllocated);
@@ -614,7 +570,7 @@
  *  Parameters:
  *
  */
-	extern DSP_STATUS NODE_GetUUIDProps(DSP_HPROCESSOR hProcessor,
+	extern DSP_STATUS NODE_GetUUIDProps(void *hProcessor,
 					    IN CONST struct DSP_UUID *pNodeId,
 					    OUT struct DSP_NDBPROPS
 					    *pNodeProps);
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/nodedefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/nodedefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/nodedefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/nodedefs.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global NODE constants and types, shared by PROCESSOR, NODE, and DISP.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,20 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== nodedefs.h ========
- *  Description:
- *      Global NODE constants and types, shared by PROCESSOR, NODE, and DISP.
- *
- *! Revision History
- *! ================
- *! 23-Apr-2001 jeh     Removed NODE_MGRATTRS.
- *! 21-Sep-2000 jeh     Removed NODE_TYPE enum.
- *! 17-Jul-2000 jeh     Changed order of node types to match rms_sh.h.
- *! 20-Jun-2000 jeh     Created.
- */
-
 #ifndef NODEDEFS_
 #define NODEDEFS_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/nodepriv.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/nodepriv.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/nodepriv.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/nodepriv.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Private node header shared by NODE and DISP.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,27 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== nodepriv.h ========
- *  Description:
- *      Private node header shared by NODE and DISP.
- *
- *  Public Functions:
- *      NODE_GetChannelId
- *      NODE_GetStrmMgr
- *      NODE_GetTimeout
- *      NODE_GetType
- *      NODE_GetLoadType
- *
- *! Revision History
- *! ================
- *! 19-Nov-2002 map     Added NODE_GetLoadType
- *! 13-Feb-2002 jeh     Added uSysStackSize to NODE_TASKARGS.
- *! 23-Apr-2001 jeh     Removed unused typedefs, defines.
- *! 10-Oct-2000 jeh     Added alignment to NODE_STRMDEF.
- *! 20-Jun-2000 jeh     Created.
- */
-
 #ifndef NODEPRIV_
 #define NODEPRIV_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/ntfy.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/ntfy.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/ntfy.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/ntfy.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Manage lists of notification events.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,26 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== ntfy.h ========
- *  Purpose:
- *      Manage lists of notification events.
- *
- *  Public Functions:
- *      NTFY_Create
- *      NTFY_Delete
- *      NTFY_Exit
- *      NTFY_Init
- *      NTFY_Notify
- *      NTFY_Register
- *
- *! Revision History:
- *! =================
- *! 05-Nov-2001 kc: Updated NTFY_Register.
- *! 07-Sep-2000 jeh Created.
- */
-
 #ifndef NTFY_
 #define NTFY_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/proc.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/proc.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/proc.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/proc.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This is the Class driver RM module interface.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,51 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== proc.h ========
- *  Description:
- *	This is the Class driver RM module interface.
- *
- *  Public Functions:
- *      PROC_Attach
- *      PROC_Create
- *      PROC_Ctrl	       (OEM-function)
- *      PROC_Destroy
- *      PROC_Detach
- *      PROC_EnumNodes
- *      PROC_Exit
- *      PROC_FlushMemory
- *      PROC_GetDevObject       (OEM-function)
- *      PROC_GetResourceInfo
- *      PROC_GetState
- *      PROC_GetProcessorId
- *      PROC_GetTrace	   (OEM-function)
- *      PROC_Init
- *      PROC_Load	       (OEM-function)
- *      PROC_Map
- *      PROC_NotifyAllclients
- *      PROC_NotifyClients      (OEM-function)
- *      PROC_RegisterNotify
- *      PROC_ReserveMemory
- *      PROC_Start	      (OEM-function)
- *      PROC_UnMap
- *      PROC_UnReserveMemory
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping APIs
- *! 09-Feb-2003 vp: Added PROC_GetProcessorID function
- *! 29-Nov-2000 rr: Incorporated code review changes.
- *! 28-Sep-2000 rr: Updated to Version 0.9.
- *! 10-Aug-2000 rr: PROC_NotifyClients, PROC_GetProcessorHandle Added
- *! 27-Jul-2000 rr: Updated to ver 0.8 of DSPAPI(types). GetTrace added.
- *! 27-Jun-2000 rr: Created from dspapi.h
- */
-
 #ifndef PROC_
 #define PROC_
 
@@ -66,29 +23,6 @@
 #include <dspbridge/devdefs.h>
 #include <dspbridge/drv.h>
 
-/* The PROC_OBJECT structure.   */
-struct PROC_OBJECT {
-	struct LST_ELEM link;		/* Link to next PROC_OBJECT */
-	u32 dwSignature;		/* Used for object validation */
-	struct DEV_OBJECT *hDevObject;	/* Device this PROC represents */
-	u32 hProcess;			/* Process owning this Processor */
-	struct MGR_OBJECT *hMgrObject;	/* Manager Object Handle */
-	u32 uAttachCount;		/* Processor attach count */
-	u32 uProcessor;			/* Processor number */
-	u32 uTimeout;			/* Time out count */
-	enum DSP_PROCSTATE sState;	/* Processor state */
-	u32 ulUnit;			/* DDSP unit number */
-	bool bIsAlreadyAttached;	/*
-					 * True if the Device below has
-					 * GPP Client attached
-					 */
-	struct NTFY_OBJECT *hNtfy;	/* Manages  notifications */
-	struct WMD_DEV_CONTEXT *hWmdContext;	/* WMD Context Handle */
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
-	char *g_pszLastCoff;
-	struct list_head proc_object;
-};
-
 /*
  *  ======== PROC_Attach ========
  *  Purpose:
@@ -117,8 +51,7 @@ struct PROC_OBJECT {
  */
 	extern DSP_STATUS PROC_Attach(u32 uProcessor,
 				      OPTIONAL CONST struct DSP_PROCESSORATTRIN
-				      *pAttrIn,
-				      OUT DSP_HPROCESSOR *phProcessor,
+				      *pAttrIn, void **phProcessor,
 				      struct PROCESS_CONTEXT *pr_ctxt);
 
 /*
@@ -167,7 +100,7 @@ struct PROC_OBJECT {
  *  Details:
  *      This function Calls WMD_BRD_Ioctl.
  */
-	extern DSP_STATUS PROC_Ctrl(DSP_HPROCESSOR hProcessor,
+	extern DSP_STATUS PROC_Ctrl(void *hProcessor,
 				    u32 dwCmd, IN struct DSP_CBDATA *pArgs);
 
 /*
@@ -176,7 +109,7 @@ struct PROC_OBJECT {
  *      Close a DSP processor and de-allocate all (GPP) resources reserved
  *      for it. The Processor Object is deleted.
  *  Parameters:
- *      hProcessor  :   The processor handle.
+ *      pr_ctxt     :   The processor handle.
  *  Returns:
  *      DSP_SOK     :   Success.
  *      DSP_EHANDLE :   InValid Handle.
@@ -186,8 +119,7 @@ struct PROC_OBJECT {
  *  Ensures:
  *      PROC Object is destroyed.
  */
-	extern DSP_STATUS PROC_Detach(DSP_HPROCESSOR hProcessor,
-			struct PROCESS_CONTEXT *pr_ctxt);
+	extern DSP_STATUS PROC_Detach(struct PROCESS_CONTEXT *pr_ctxt);
 
 /*
  *  ======== PROC_EnumNodes ========
@@ -220,8 +152,8 @@ struct PROC_OBJECT {
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_EnumNodes(DSP_HPROCESSOR hProcessor,
-					 IN DSP_HNODE *aNodeTab,
+	extern DSP_STATUS PROC_EnumNodes(void *hProcessor,
+					 void **aNodeTab,
 					 IN u32 uNodeTabSize,
 					 OUT u32 *puNumNodes,
 					 OUT u32 *puAllocated);
@@ -254,7 +186,7 @@ struct PROC_OBJECT {
  *      This function currently returns
  *      DSP_ENOTIMPL, and does not write any data to the pResourceInfo struct.
  */
-	extern DSP_STATUS PROC_GetResourceInfo(DSP_HPROCESSOR hProcessor,
+	extern DSP_STATUS PROC_GetResourceInfo(void *hProcessor,
 					       u32 uResourceType,
 					       OUT struct DSP_RESOURCEINFO *
 					       pResourceInfo,
@@ -291,7 +223,7 @@ struct PROC_OBJECT {
  *      DSP_SOK     :   *phDevObject is not NULL
  *      DSP_EFAIL   :   *phDevObject is NULL.
  */
-	extern DSP_STATUS PROC_GetDevObject(DSP_HPROCESSOR hProcessor,
+	extern DSP_STATUS PROC_GetDevObject(void *hProcessor,
 					    struct DEV_OBJECT **phDevObject);
 
 /*
@@ -328,7 +260,7 @@ struct PROC_OBJECT {
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_GetState(DSP_HPROCESSOR hProcessor,
+	extern DSP_STATUS PROC_GetState(void *hProcessor,
 					OUT struct DSP_PROCESSORSTATE
 					*pProcStatus,
 					u32 uStateInfoSize);
@@ -352,7 +284,7 @@ struct PROC_OBJECT {
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_GetProcessorId(DSP_HPROCESSOR hProcessor,
+	extern DSP_STATUS PROC_GetProcessorId(void *hProcessor,
 					      u32 *procID);
 
 /*
@@ -375,7 +307,7 @@ struct PROC_OBJECT {
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_GetTrace(DSP_HPROCESSOR hProcessor, u8 *pBuf,
+	extern DSP_STATUS PROC_GetTrace(void *hProcessor, u8 *pBuf,
 					u32 uMaxSize);
 
 /*
@@ -409,7 +341,7 @@ struct PROC_OBJECT {
  *      Does not implement access rights to control which GPP application
  *      can load the processor.
  */
-	extern DSP_STATUS PROC_Load(DSP_HPROCESSOR hProcessor,
+	extern DSP_STATUS PROC_Load(void *hProcessor,
 				    IN CONST s32 iArgc, IN CONST char **aArgv,
 				    IN CONST char **aEnvp);
 
@@ -435,7 +367,7 @@ struct PROC_OBJECT {
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_RegisterNotify(DSP_HPROCESSOR hProcessor,
+	extern DSP_STATUS PROC_RegisterNotify(void *hProcessor,
 					      u32 uEventMask, u32 uNotifyType,
 					      struct DSP_NOTIFICATION
 					      *hNotification);
@@ -457,7 +389,7 @@ struct PROC_OBJECT {
  *      PROC Initialized.
  *  Ensures:
  */
-	extern DSP_STATUS PROC_NotifyClients(DSP_HPROCESSOR hProc,
+	extern DSP_STATUS PROC_NotifyClients(void *hProc,
 					     u32 uEvents);
 
 /*
@@ -480,7 +412,7 @@ struct PROC_OBJECT {
  *      NODE And STRM would use this function to notify their clients
  *      about the state changes in NODE or STRM.
  */
-	extern DSP_STATUS PROC_NotifyAllClients(DSP_HPROCESSOR hProc,
+	extern DSP_STATUS PROC_NotifyAllClients(void *hProc,
 						u32 uEvents);
 
 /*
@@ -503,7 +435,7 @@ struct PROC_OBJECT {
  *      Success and ProcState == PROC_RUNNING or DSP_FAILED status.
  *  Details:
  */
-	extern DSP_STATUS PROC_Start(DSP_HPROCESSOR hProcessor);
+	extern DSP_STATUS PROC_Start(void *hProcessor);
 
 /*
  *  ======== PROC_Stop ========
@@ -525,7 +457,7 @@ struct PROC_OBJECT {
  *      Success and ProcState == PROC_RUNNING or DSP_FAILED status.
  *  Details:
  */
-	extern DSP_STATUS PROC_Stop(DSP_HPROCESSOR hProcessor);
+	extern DSP_STATUS PROC_Stop(void *hProcessor);
 
 /*
  *  ======== PROC_FlushMemory ========
@@ -546,7 +478,7 @@ struct PROC_OBJECT {
  *  Details:
  *      All the arguments are currently ignored.
  */
-	extern DSP_STATUS PROC_FlushMemory(DSP_HPROCESSOR hProcessor,
+	extern DSP_STATUS PROC_FlushMemory(void *hProcessor,
 					   void *pMpuAddr,
 					   u32 ulSize, u32 ulFlags);
 
@@ -569,7 +501,7 @@ struct PROC_OBJECT {
  *  Details:
  *      All the arguments are currently ignored.
  */
-	extern DSP_STATUS PROC_InvalidateMemory(DSP_HPROCESSOR hProcessor,
+	extern DSP_STATUS PROC_InvalidateMemory(void *hProcessor,
 					   void *pMpuAddr,
 					   u32 ulSize);
 
@@ -600,7 +532,7 @@ struct PROC_OBJECT {
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_Map(DSP_HPROCESSOR hProcessor,
+	extern DSP_STATUS PROC_Map(void *hProcessor,
 				   void *pMpuAddr,
 				   u32 ulSize,
 				   void *pReqAddr,
@@ -626,7 +558,7 @@ struct PROC_OBJECT {
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_ReserveMemory(DSP_HPROCESSOR hProcessor,
+	extern DSP_STATUS PROC_ReserveMemory(void *hProcessor,
 					     u32 ulSize, void **ppRsvAddr);
 
 /*
@@ -648,7 +580,7 @@ struct PROC_OBJECT {
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_UnMap(DSP_HPROCESSOR hProcessor, void *pMapAddr,
+	extern DSP_STATUS PROC_UnMap(void *hProcessor, void *pMapAddr,
 			struct PROCESS_CONTEXT *pr_ctxt);
 
 /*
@@ -670,7 +602,7 @@ struct PROC_OBJECT {
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_UnReserveMemory(DSP_HPROCESSOR hProcessor,
+	extern DSP_STATUS PROC_UnReserveMemory(void *hProcessor,
 					       void *pRsvAddr);
 
 #endif				/* PROC_ */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/procpriv.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/procpriv.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/procpriv.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/procpriv.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global PROC constants and types, shared by PROC, MGR and WCD.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,17 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== procpriv.h ========
- *  Description:
- *      Global PROC constants and types, shared by PROC, MGR, and WCD.
- *
- *! Revision History:
- *! ================
- *! 05-July-2000 rr: Created
- */
-
 #ifndef PROCPRIV_
 #define PROCPRIV_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/pwr.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/pwr.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/pwr.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/pwr.h	2011-05-02 22:36:49.000000000 +0100
@@ -14,25 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== pwr.h ========
- *
- *  Public Functions:
- *
- *      PWR_SleepDSP
- *      PWR_WakeDSP
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 06-Jun-2002 sg  Replaced dspdefs.h with includes of dbdefs.h and errbase.h.
- *! 13-May-2002 sg  Added DSP_SAREADYASLEEP and DSP_SALREADYAWAKE.
- *! 09-May-2002 sg  Updated, added timeouts.
- *! 02-May-2002 sg  Initial.
- */
-
 #ifndef PWR_
 #define PWR_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/pwr_sh.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/pwr_sh.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/pwr_sh.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/pwr_sh.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Power Manager shared definitions (used on both GPP and DSP sides).
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,16 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== pwr_sh.h ========
- *
- *  Power Manager shared definitions (used on both GPP and DSP sides).
- *
- *! Revision History
- *! ================
- *! 17-Apr-2002 sg: Initial.
- */
-
 #ifndef PWR_SH_
 #define PWR_SH_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/reg.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/reg.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/reg.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/reg.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provides registry functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,62 +16,11 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== reg.h ========
- *  Purpose:
- *      Provide registry functions.
- *
- *  Public Functions:
- *      REG_DeleteValue
- *      REG_EnumKey
- *      REG_EnumValue
- *      REG_Exit
- *      REG_GetValue
- *      REG_Init
- *      REG_SetValue
- *
- *! Revision History:
- *! =================
- *! 30-Oct-2000 kc: Updated REG_SetValue & REG_GetValue; renamed
- *!                 REG_DeleteEntry to REG_DeleteValue.
- *! 29-Sep-2000 kc: Updated a REG functions for code review.
- *! 12-Aug-2000 kc: Renamed REG_EnumValue to REG_EnumKey. Re-implemented
- *!                 REG_EnumValue.
- *! 03-Feb-2000 rr: REG_EnumValue Fxn Added
- *! 13-Dec-1999 rr: windows.h removed
- *! 02-Dec-1999 rr: windows.h included for retail build
- *! 22-Nov-1999 kc: Changes from code review.
- *! 29-Dec-1997 cr: Changes from code review.
- *! 27-Oct-1997 cr: Added REG_DeleteValue.
- *! 20-Oct-1997 cr: Added ability to pass bValue = NULL to REG_GetValue
- *!                 and return size of reg entry in pdwValueSize.
- *! 29-Sep-1997 cr: Added REG_SetValue
- *! 29-Aug-1997 cr: Created.
- */
-
 #ifndef _REG_H
 #define _REG_H
 
 #include <linux/types.h>
 
-/*  ------------------------- Defines, Data Structures, Typedefs for Linux */
-#ifndef UNDER_CE
-
-#ifndef REG_SZ
-#define REG_SZ          1
-#endif
-
-#ifndef REG_BINARY
-#define REG_BINARY      3
-#endif
-
-#ifndef REG_DWORD
-#define REG_DWORD       4
-#endif
-
-#endif				/* UNDER_CE */
-
 #define REG_MAXREGPATHLENGTH    255
 
 /*
@@ -78,57 +29,18 @@
  *      Deletes a registry entry. NOTE: A registry entry is not the same as
  *      a registry key.
  *  Parameters:
- *      phKey:      Currently reserved; must be NULL.
- *      pstrSubkey: Path to key to open.
  *      pstrValue:  Name of entry to delete.
  *  Returns:
  *      DSP_SOK:    Success.
  *      DSP_EFAIL:  General failure.
  *  Requires:
  *      - REG initialized.
- *      - pstrSubkey & pstrValue are non-NULL values.
- *      - phKey is NULL.
- *      - length of pstrSubkey < REG_MAXREGPATHLENGTH.
+ *      - pstrValue is non-NULL value.
  *      - length of pstrValue < REG_MAXREGPATHLENGTH.
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS REG_DeleteValue(OPTIONAL IN HANDLE *phKey,
-					  IN CONST char *pstrSubkey,
-					  IN CONST char *pstrValue);
-
-/*
- *  ======== REG_EnumKey ========
- *  Purpose:
- *      Enumerates subkeys of the specified path to the  registry key
- *      Retrieves the  name of the subkey(given the index) and
- *      appends with the orignal path to form the full path.
- *  Parameters:
- *      phKey:      Currently reserved; must be NULL.
- *      pstrKey     The name of the registry key to be enumerated.
- *      dwIndex     Specifies the index of the subkey to retrieve.
- *      pstrSubkey: Pointer to buffer that receives full path name of the
- *                  specified key + the sub-key
- *      pdwValueSize:   Specifies bytes of memory pstrSubkey points to on input,
- *                      on output, specifies actual memory bytes written into.
- *                      If there is no sub key,pdwValueSize returns NULL.
- *  Returns:
- *      DSP_SOK:    Success.
- *      DSP_EFAIL:  General failure.
- *  Requires:
- *      - REG initialized.
- *      - pstrKey is non-NULL value.
- *      - pdwValueSize is a valid pointer.
- *      - phKey is NULL.
- *      - length of pstrKey < REG_MAXREGPATHLENGTH.
- *  Ensures:
- *      - strlen(pstrSubkey) is > strlen(pstrKey) &&
- *      - strlen(pstrSubkey) is < REG_MAXREGPATHLENGTH
- */
-	extern DSP_STATUS REG_EnumKey(OPTIONAL IN HANDLE *phKey,
-				      IN u32 dwIndex, IN CONST char *pstrKey,
-				      IN OUT char *pstrSubkey,
-				      IN OUT u32 *pdwValueSize);
+extern DSP_STATUS REG_DeleteValue(IN CONST char *pstrValue);
 
 /*
  *  ======== REG_EnumValue ========
@@ -136,7 +48,6 @@
  *      Enumerates values of a specified key. Retrieves each value name and
  *      the data associated with the value.
  *  Parameters:
- *      phKey:          Currently reserved; must be NULL.
  *      dwIndex:        Specifies the index of the value to retrieve.
  *      pstrKey:        The name of the registry key to be enumerated.
  *      pstrValue:      Pointer to buffer that receives the name of the value.
@@ -152,19 +63,16 @@
  *      DSP_EFAIL:      General failure.
  *  Requires:
  *      REG initialized.
- *      phKey is NULL.
  *      pstrKey is a non-NULL value.
  *      pstrValue, pstrData, pdwValueSize and pdwDataSize are valid pointers.
  *      Length of pstrKey is less than REG_MAXREGPATHLENGTH.
  *  Ensures:
  */
-	extern DSP_STATUS REG_EnumValue(IN HANDLE *phKey,
-					IN u32 dwIndex,
-					IN CONST char *pstrKey,
-					IN OUT char *pstrValue,
-					IN OUT u32 *pdwValueSize,
-					IN OUT char *pstrData,
-					IN OUT u32 *pdwDataSize);
+extern DSP_STATUS REG_EnumValue(IN u32 dwIndex, IN CONST char *pstrKey,
+				IN OUT char *pstrValue,
+				IN OUT u32 *pdwValueSize,
+				IN OUT char *pstrData,
+				IN OUT u32 *pdwDataSize);
 
 /*
  *  ======== REG_Exit ========
@@ -185,8 +93,6 @@
  *  Purpose:
  *      Retrieve a value from the registry.
  *  Parameters:
- *      phKey:          Currently reserved; must be NULL.
- *      pstrSubkey:     Path to key to open.
  *      pstrEntry:      Name of entry to retrieve.
  *      pbValue:        Upon return, points to retrieved value.
  *      pdwValueSize:   Specifies bytes of memory pbValue points to on input,
@@ -198,18 +104,13 @@
  *      DSP_EFAIL:      General failure.
  *  Requires:
  *      - REG initialized.
- *      - pstrSubkey & pstrEntry are non-NULL values.
+ *      - pstrEntry is non-NULL value.
  *      - pbValue is a valid pointer.
- *      - phKey is NULL.
- *      - length of pstrSubkey < REG_MAXREGPATHLENGTH.
  *      - length of pstrEntry < REG_MAXREGPATHLENGTH.
  *  Ensures:
  */
-	extern DSP_STATUS REG_GetValue(OPTIONAL IN HANDLE *phKey,
-				       IN CONST char *pstrSubkey,
-				       IN CONST char *pstrEntry,
-				       OUT u8 *pbValue,
-				       IN OUT u32 *pdwValueSize);
+extern DSP_STATUS REG_GetValue(IN CONST char *pstrEntry, OUT u8 *pbValue,
+			       IN OUT u32 *pdwValueSize);
 
 /*
  *  ======== REG_Init ========
@@ -229,10 +130,7 @@
  *  Purpose:
  *      Set a value in the registry.
  *  Parameters:
- *      phKey:          Handle to open reg key, or NULL if pSubkey is full path.
- *      pstrSubkey:     Path to key to open, could be based on phKey.
  *      pstrEntry:      Name of entry to set.
- *      dwType:         Data type of new registry value.
  *      pbValue:        Points to buffer containing new data.
  *      dwValueSize:    Specifies bytes of memory bValue points to.
  *  Returns:
@@ -240,18 +138,13 @@
  *      DSP_EFAIL:      General failure.
  *  Requires:
  *      - REG initialized.
- *      - pstrSubkey & pstrEntry are non-NULL values.
+ *      - pstrEntry is non-NULL value.
  *      - pbValue is a valid pointer.
- *      - phKey is NULL.
  *      - dwValuSize > 0.
- *      - length of pstrSubkey < REG_MAXREGPATHLENGTH.
  *      - length of pstrEntry < REG_MAXREGPATHLENGTH.
  *  Ensures:
  */
-	extern DSP_STATUS REG_SetValue(OPTIONAL IN HANDLE *phKey,
-				       IN CONST char *pstrSubKey,
-				       IN CONST char *pstrEntry,
-				       IN CONST u32 dwType,
-				       IN u8 *pbValue, IN u32 dwValueSize);
+extern DSP_STATUS REG_SetValue(IN CONST char *pstrEntry, IN u8 *pbValue,
+			       IN u32 dwValueSize);
 
 #endif				/* _REG_H */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h	2011-05-02 22:36:49.000000000 +0100
@@ -14,7 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#ifndef RES_CLEANUP_DISABLE
 
 #include <dspbridge/nodepriv.h>
 #include <dspbridge/drv.h>
@@ -30,15 +29,12 @@ extern DSP_STATUS DRV_RemoveAllDMMResEle
 
 extern DSP_STATUS DRV_RemoveAllNodeResElements(HANDLE pCtxt);
 
-extern DSP_STATUS DRV_ProcUpdatestate(HANDLE pCtxt,
-				      enum GPP_PROC_RES_STATE resState);
-
 extern DSP_STATUS DRV_ProcSetPID(HANDLE pCtxt, s32 hProcess);
 
 extern DSP_STATUS DRV_RemoveAllResources(HANDLE pPctxt);
 
 extern DSP_STATUS DRV_RemoveProcContext(struct DRV_OBJECT *hDRVObject,
-				     HANDLE hPCtxt);
+				     HANDLE pr_ctxt);
 
 extern DSP_STATUS DRV_GetNodeResElement(HANDLE hNode, HANDLE nodeRes,
 					HANDLE pCtxt);
@@ -63,8 +59,7 @@ extern DSP_STATUS DRV_GetDMMResElement(u
 
 extern DSP_STATUS DRV_RemoveDMMResElement(HANDLE dmmRes, HANDLE pCtxt);
 
-extern DSP_STATUS DRV_ProcUpdateSTRMRes(u32 uNumBufs, HANDLE STRMRes,
-					HANDLE pCtxt);
+extern DSP_STATUS DRV_ProcUpdateSTRMRes(u32 uNumBufs, HANDLE STRMRes);
 
 extern DSP_STATUS DRV_ProcInsertSTRMResElement(HANDLE hStrm, HANDLE STRMRes,
 						HANDLE pPctxt);
@@ -76,8 +71,5 @@ extern DSP_STATUS DRV_ProcRemoveSTRMResE
 
 extern DSP_STATUS DRV_RemoveAllSTRMResElements(HANDLE pCtxt);
 
-extern DSP_STATUS DRV_ProcDisplayResInfo(u8 *pBuf, u32 *pSize);
-
 extern enum NODE_STATE NODE_GetState(HANDLE hNode);
 
-#endif
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/rmm.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/rmm.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/rmm.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/rmm.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,10 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This memory manager provides general heap management and arbitrary
+ * alignment for any number of memory segments, and management of overlay
+ * memory.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,28 +18,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== rmm.h ========
- *
- *  This memory manager provides general heap management and arbitrary
- *  alignment for any number of memory segments, and management of overlay
- *  memory.
- *
- *  Public functions:
- *      RMM_alloc
- *      RMM_create
- *      RMM_delete
- *      RMM_exit
- *      RMM_free
- *      RMM_init
- *
- *! Revision History
- *! ================
- *! 25-Jun-2002 jeh     Added RMM_Addr. Removed RMM_reserve, RMM_stat.
- *! 15-Oct-2001 jeh     Based on rm.h in gen tree.
- */
-
 #ifndef RMM_
 #define RMM_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/rms_sh.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/rms_sh.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/rms_sh.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/rms_sh.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge Resource Manager Server shared definitions (used on both
+ * GPP and DSP sides).
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,37 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== rms_sh.h ========
- *
- *  DSP/BIOS Bridge Resource Manager Server shared definitions (used on both
- *  GPP and DSP sides).
- *
- *! Revision History
- *! ================
- *! 24-Mar-2003 vp  Merged updates required for CCS2.2 transition.
- *! 24-Feb-2003 kc  Rearranged order of node types to temporarily support
- *!		    legacy message node code
- *! 23-Nov-2002 gp  Converted tabs -> spaces, to fix formatting.
- *! 13-Feb-2002 jeh Added sysstacksize element to RMS_MoreTaskArgs.
- *! 11-Dec-2000 sg  Added 'misc' element to RMS_MoreTaskArgs.
- *! 04-Dec-2000 ag  Added RMS_BUFDESC command code.
- *!                 C/R code value changed to allow ORing of system/user codes.
- *! 10-Oct-2000 sg  Added 'align' field to RMS_StrmDef.
- *! 09-Oct-2000 sg  Moved pre-defined message codes here from rmsdefs.h.
- *! 02-Oct-2000 sg  Changed ticks to msec.
- *! 24-Aug-2000 sg  Moved definitions that will be exposed to app developers
- *!  		    to a separate file, rmsdefs.h.
- *! 10-Aug-2000 sg  Added RMS_COMMANDBUFSIZE and RMS_RESPONSEBUFSIZE; added
- *!		    pre-defined command/response codes; more comments.
- *! 09-Aug-2000 sg  Added RMS_ETASK.
- *! 08-Aug-2000 jeh Define RMS_WORD for GPP, rename DSP_MSG to RMS_DSPMSG.
- *!                 Added RMS_MsgArgs, RMS_MoreTaskArgs.
- *! 25-Jul-2000 sg: Changed SIO to STRM.
- *! 30-Jun-2000 sg: Initial.
- */
-
 #ifndef RMS_SH_
 #define RMS_SH_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/rmstypes.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/rmstypes.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/rmstypes.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/rmstypes.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge Resource Manager Server shared data type definitions.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,19 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== rmstypes.h ========
- *
- *  DSP/BIOS Bridge Resource Manager Server shared data type definitions.
- *
- *! Revision History
- *! ================
- *! 06-Oct-2000 sg  Added LgFxn type.
- *! 05-Oct-2000 sg  Changed RMS_STATUS to LgUns.
- *! 31-Aug-2000 sg  Added RMS_DSPMSG.
- *! 25-Aug-2000 sg  Initial.
- */
-
 #ifndef RMSTYPES_
 #define RMSTYPES_
 #include <linux/types.h>
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/services.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/services.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/services.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/services.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provide loading and unloading of SERVICES modules.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,21 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== services.h ========
- *  Purpose:
- *      Provide loading and unloading of SERVICES modules.
- *
- *  Public Functions:
- *      SERVICES_Exit(void)
- *      SERVICES_Init(void)
- *
- *! Revision History:
- *! ================
- *! 01-Feb-2000 kc: Created.
- */
-
 #ifndef SERVICES_
 #define SERVICES_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/std.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/std.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/std.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/std.h	2011-05-02 22:36:49.000000000 +0100
@@ -14,54 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== std.h ========
- *
- *! Revision History
- *! ================
- *! 16-Feb-2004 vp	GNU compiler 3.x defines inline keyword. Added
- *!			appropriate macros not to redefine inline keyword in
- *!			this file.
- *! 24-Oct-2002	ashu	defined _TI_ and _FIXED_ symbols for 28x.
- *! 24-Oct-2002	ashu	defined _TI_ for 24x.
- *! 01-Mar-2002 kln	changed LARGE_MODEL and Arg definition for 28x
- *! 01-Feb-2002 kln	added definitions for 28x
- *! 08-Dec-2000 kw:	added 'ArgToInt' and 'ArgToPtr' macros
- *! 30-Nov-2000 mf:	Added _64_, _6x_; removed _7d_
- *! 30-May-2000 srid:	Added   __TMS320C55X__ for 55x; Arg is void * for 55 .
- *! 18-Jun-1999 dr:	Added '_TI_', fixed __inline for SUN4, added inline
- *! 10-Feb-1999 rt:	Added '55' support, changed 54's symbol to _TMS320C5XX
- *! 29-Aug-1998 mf: 	fixed typo, removed obsolete targets
- *! 08-Jun-1998 mf: 	_67_ is synonym for _7d_
- *! 10-Oct-1997 rt;	added _7d_ for Raytheon C7DSP triggered by _TMS320C6700
- *! 04-Aug-1997 cc:	added _29_ for _TMS320C2XX
- *! 11-Jul-1997 dlr:	_5t_, and STD_SPOXTASK keyword for Tasking
- *! 12-Jun-1997 mf: 	_TMS320C60 -> _TMS320C6200
- *! 13-Feb-1997 mf:	_62_, with 32-bit LgInt
- *! 26-Nov-1996 kw: 	merged bios-c00's and wsx-a27's <dspbridge/std.h> changes
- *!			*and* revision history
- *! 12-Sep-1996 kw: 	added C54x #ifdef's
- *! 21-Aug-1996 mf: 	removed #define main smain for _21_
- *! 14-May-1996 gp:     def'd out INT, FLOAT, and COMPLEX defines for WSX.
- *! 11-Apr-1996 kw:     define _W32_ based on _WIN32 (defined by MS compiler)
- *! 07-Mar-1996 mg:     added Win32 support
- *! 06-Sep-1995 dh:	added _77_ dynamic stack support via fxns77.h
- *! 27-Jun-1995 dh:	added _77_ support
- *! 16-Mar-1995 mf: 	for _21_: #define main smain
- *! 01-Mar-1995 mf: 	set _20_ and _60_ (as well as _21_ for both)
- *! 22-Feb-1995 mf: 	Float is float for _SUN_ and _80_
- *! 22-Dec-1994 mf: 	Added _80_ definition, for PP or MP.
- *! 09-Dec-1994 mf: 	Added _53_ definition.
- *!			Added definitions of _30_, etc.
- *! 23-Aug-1994 dh	removed _21_ special case (kw)
- *! 17-Aug-1994 dh	added _51_ support
- *! 03-Aug-1994 kw	updated _80_ support
- *! 30-Jun-1994 kw	added _80_ support
- *! 05-Apr-1994 kw:	Added _SUN_ to _FLOAT_ definition
- *! 01-Mar-1994 kw: 	Made Bool an int (was u16) for _56_ (more efficient).
- *!			Added _53_ support.
- */
-
 #ifndef STD_
 #define STD_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/strm.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/strm.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/strm.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/strm.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSPBridge Stream Manager.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,45 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== strm.h ========
- *  Description:
- *      DSPBridge Stream Manager.
- *
- *  Public Functions:
- *      STRM_AllocateBuffer
- *      STRM_Close
- *      STRM_Create
- *      STRM_Delete
- *      STRM_Exit
- *      STRM_FreeBuffer
- *      STRM_GetEventHandle
- *      STRM_GetInfo
- *      STRM_Idle
- *      STRM_Init
- *      STRM_Issue
- *      STRM_Open
- *      STRM_PrepareBuffer
- *      STRM_Reclaim
- *      STRM_RegisterNotify
- *      STRM_Select
- *      STRM_UnprepareBuffer
- *
- *  Notes:
- *
- *! Revision History:
- *! =================
- *! 15-Nov-2001 ag  Changed DSP_STREAMINFO to STRM_INFO in STRM_GetInfo().
- *!                 Added DSP_ESIZE error to STRM_AllocateBuffer().
- *! 07-Jun-2001 sg  Made DSPStream_AllocateBuffer fxn name plural.
- *! 10-May-2001 jeh Code review cleanup.
- *! 13-Feb-2001 kc  DSP/BIOS Bridge name updates.
- *! 06-Feb-2001 kc  Updated DBC_Ensure for STRM_Select().
- *! 23-Oct-2000 jeh Allow NULL STRM_ATTRS passed to STRM_Open().
- *! 25-Sep-2000 jeh Created.
- */
-
 #ifndef STRM_
 #define STRM_
 
@@ -104,7 +67,7 @@
  *  Ensures:
  */
 	extern DSP_STATUS STRM_Close(struct STRM_OBJECT *hStrm,
-			struct PROCESS_CONTEXT *pr_ctxt);
+				struct PROCESS_CONTEXT *pr_ctxt);
 
 /*
  *  ======== STRM_Create ========
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/strmdefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/strmdefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/strmdefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/strmdefs.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global STRM constants and types.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,18 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== strmdefs.h ========
- *  Purpose:
- *      Global STRM constants and types.
- *
- *! Revision History
- *! ================
- *! 19-Nov-2001 ag      Added STRM_INFO..
- *! 25-Sep-2000 jeh     Created.
- */
-
 #ifndef STRMDEFS_
 #define STRMDEFS_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/sync.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/sync.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/sync.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/sync.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provide synchronization services.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,44 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== sync.h ========
- *  Purpose:
- *      Provide synchronization services.
- *
- *  Public Functions:
- *      SYNC_CloseEvent
- *      SYNC_DeleteCS
- *      SYNC_EnterCS
- *      SYNC_Exit
- *      SYNC_Init
- *      SYNC_InitializeCS
- *      SYNC_LeaveCS
- *      SYNC_OpenEvent
- *      SYNC_PostMessage
- *      SYNC_ResetEvent
- *      SYNC_SetEvent
- *      SYNC_WaitOnEvent
- *      SYNC_WaitOnMultipleEvents
- *
- *! Revision History:
- *! ================
- *! 05-Oct-2000 jeh Added SYNC_WaitOnMultipleEvents().
- *! 01-Dec-1999 ag: Added #define SYNC_MAXNAMELENGTH.
- *! 04-Nov-1999 kc: Added critical section functions and objects to SYNC.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 24-Sep-1999 kc: Added WinCE notes.
- *! 20-Oct-1997 gp: Removed unused SYNC_ critical section and must complete fxns
- *!                 Added SYNC_HOBJECT, SYNC_ATTRS, and object validation, and
- *!                 merged SYNC_DestroyEvent into SYNC_CloseEvent, and merged
- *!                 SYNC_CreateEvent into SYNC_OpenEvent.
- *! 07-Oct-1997 gp: Added SYNC_Create/DestroyEvent (for NT testing).
- *! 06-Oct-1997 gp: Added SYNC_OpenEvent.
- *! 03-Jun-1997 gp: Added SYNC_{Begin|End}CritSection() functions.
- *! 03-Jan-1997 gp: Added SYNC_INFINITE define.
- *! 05-Aug-1996 gp: Created.
- */
-
 #ifndef _SYNC_H
 #define _SYNC_H
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/util.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/util.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/util.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/util.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,122 +0,0 @@
-/*
- * util.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== util.h ========
- *  Purpose:
- *      Provide general purpose utility functions.
- *
- *  Public Functions:
- *      UTIL_CDTestDll
- *      UTIL_CmdLineToArgs
- *      UTIL_Exit
- *      UTIL_GetSysInfo
- *      UTIL_Init
- */
-
-#ifndef _UTIL_H
-#define _UTIL_H
-
-#include <linux/delay.h>
-#include <linux/sched.h>
-
-#include <dspbridge/utildefs.h>
-
-/*
- *  ======== UTIL_CDTestDll ========
- *  Purpose:
- *      Provides test entry point in class driver context.
- *  Parameters:
- *      cArgc:  test module command line input count.
- *      ppArgv: test module command line args.
- *  Returns:
- *      0 if successful, a negative value otherwise.
- *  Requires:
- *      UTIL initialized.
- *  Ensures:
- */
-	extern u32 UTIL_CDTestDll(IN s32 cArgc, IN char **ppArgv);
-
-/*
- *  ======== UTIL_CmdLineToArgs ========
- *  Purpose:
- *      This function re-creates C-style cmd line argc & argv from WinMain()
- *      cmd line args.
- *  Parameters:
- *      s8 *pszProgName   - The name of the program currently being executed.
- *      s8 *argv[]        - The argument vector.
- *      s8 *pCmdLine      - The pointer to the command line.
- *      bool fHasProgName   - Indicats whether a program name is supplied.
- *  Returns:
- *      Returns the number of arguments found.
- *  Requires:
- *      UTIL initialized.
- *  Ensures:
- */
-	extern s32 UTIL_CmdLineToArgs(IN char *pszProgName,
-				      IN char *argv[UTIL_MAXARGVS],
-				      IN char *pCmdLine, IN bool fHasProgName);
-
-/*
- *  ======== UTIL_Exit ========
- *  Purpose:
- *      Discontinue usage of module; free resources when reference count
- *      reaches 0.
- *  Parameters:
- *  Returns:
- *  Requires:
- *      UTIL initialized.
- *  Ensures:
- *      Resources used by module are freed when cRef reaches zero.
- */
-	extern inline void UTIL_Exit(void)
-	{
-	}
-/*
- *  ======== UTIL_GetSysInfo ========
- *  Purpose:
- *      This function return platform specific system information.
- *
- *  Parameters:
- *      pSysInfo  - address to store the system information.
- *  Returns:
- *      DSP_SOK
- *      S_FAIL
- *  Requires:
- *      UTIL initialized.
- *      pSysInfo != NULL
- *  Ensures:
- */
-	extern DSP_STATUS UTIL_GetSysInfo(OUT struct UTIL_SYSINFO *pSysInfo);
-
-/*
- *  ======== UTIL_Init ========
- *  Purpose:
- *      Initializes private state of UTIL module.
- *  Parameters:
- *  Returns:
- *      TRUE if success, else FALSE.
- *  Requires:
- *  Ensures:
- *      UTIL initialized.
- */
-	extern inline bool UTIL_Init(void)
-	{
-		return true;
-	}
-
-#endif				/* _UTIL_H */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/utildefs.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/utildefs.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/utildefs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/utildefs.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global UTIL constants and types, shared between WCD and DSPSYS.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,20 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== utildefs.h ========
- *  Purpose:
- *      Global UTIL constants and types, shared between WCD and DSPSYS.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 kc  Removed wIOPort* entries from UTIL_HOSTCONFIG.
- *! 12-Aug-2000 ag  Added UTIL_SYSINFO typedef.
- *! 08-Oct-1999 rr  Adopted for WinCE where test fxns will be added in util.h
- *! 26-Dec-1996 cr  Created.
- */
-
 #ifndef UTILDEFS_
 #define UTILDEFS_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/uuidutil.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/uuidutil.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/uuidutil.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/uuidutil.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This file contains the specification of UUID helper functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,20 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== uuidutil.h ========
- *  Description:
- *      This file contains the specification of UUID helper functions.
- *
- *! Revision History
- *! ================
- *! 09-Nov-2000 kc: Modified description of UUID utility functions.
- *! 29-Sep-2000 kc: Appended "UUID_" prefix to UUID helper functions.
- *! 10-Aug-2000 kc: Created.
- *!
- */
-
 #ifndef UUIDUTIL_
 #define UUIDUTIL_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/wcd.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/wcd.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/wcd.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/wcd.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,18 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Bridge class driver library functions, object definitions, and
+ * return error/status codes.  To be included by Bridge mini drivers.
+ *
+ * Notes:
+ *   Bridge Class Driver services exported to WMD's are initialized by the
+ *   WCD on behalf of the WMD.  WMD's must not call module Init/Exit
+ *   functions.
+ *
+ *   To ensure WMD binary compatibility across different platforms,
+ *   for the same processor, a WMD must restrict its usage of system
+ *   services to those exported by the 'Bridge class library.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,43 +26,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== wcd.h ========
- *  Description:
- *      'Bridge class driver library functions, object definitions, and
- *      return error/status codes.  To be included by 'Bridge mini drivers.
- *
- *  Public Functions:
- *      See mem.h and dbg.h.
- *
- *  Notes:
- *      'Bridge Class Driver services exported to WMD's are initialized by the
- *      WCD on behalf of the WMD.  WMD's must not call module Init/Exit
- *      functions.
- *
- *      To ensure WMD binary compatibility across different platforms,
- *      for the same processor, a WMD must restrict its usage of system
- *      services to those exported by the 'Bridge class library.
- *
- *! Revision History:
- *! ================
- *! 07-Jun-2000 jeh Added dev.h
- *! 01-Nov-1999 ag: #WINCE# WCD_MAJOR_VERSION=8 & WCD_MINOR_VERSION=0 to match
- *!		    dll stamps.
- *!                 0.80 - 0.89 Alpha, 0.90 - 0.99 Beta, 1.00 - 1.10 FCS.
- *! 17-Sep-1997 gp: Changed size of CFG_HOSTRES structure; and ISR_Install API;
- *!                 Changed WCD_MINOR_VERSION 3 -> 4.
- *! 15-Sep-1997 gp: Moved WCD_(Un)registerMinidriver to drv.
- *! 25-Jul-1997 cr: Added WCD_UnregisterMinidriver.
- *! 22-Jul-1997 cr: Added WCD_RegisterMinidriver, WCD_MINOR_VERSION 2 -> 3.
- *! 12-Nov-1996 gp: Defined port io macros.
- *! 07-Nov-1996 gp: Updated for code review.
- *! 16-Jul-1996 gp: Added CHNL fxns; updated WCD lib version to 2.
- *! 10-May-1996 gp: Separated WMD def.s' into wmd.h.
- *! 03-May-1996 gp: Created.
- */
-
 #ifndef WCD_
 #define WCD_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/wcdioctl.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/wcdioctl.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/wcdioctl.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/wcdioctl.h	2011-05-06 14:38:24.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Contains structures and commands that are used for interaction
+ * between the DDSP API and class driver.
+ *
  * Copyright (C) 2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,55 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== wcdioctl.h ========
- *  Purpose:
- *      Contains structures and commands that are used for interaction
- *      between the DDSP API and class driver.
- *
- *! Revision History
- *! ================
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping structs & offsets
- *! 15-Oct-2002 kc  Updated definitions for private PERF module.
- *! 16-Aug-2002 map Added ARGS_MGR_REGISTEROBJECT & ARGS_MGR_UNREGISTEROBJECT
- *!		 Added CMD_MGR_REGISTEROBJECT_OFFSET &
- *!		 CMD_MGR_UNREGISTEROBJECT_OFFSET
- *! 15-Jan-2002 ag  Added actaul bufSize to ARGS_STRM_[RECLAIM][ISSUE].
- *! 15-Nov-2001 ag  change to STRMINFO in ARGS_STRM_GETINFO.
- *! 11-Sep-2001 ag  ARGS_CMM_GETHANDLE defn uses DSP_HPROCESSOR.
- *! 23-Apr-2001 jeh Added pStatus to NODE_TERMINATE args.
- *! 13-Feb-2001 kc  DSP/BIOS Bridge name updates.
- *! 22-Nov-2000 kc: Added CMD_MGR_GETPERF_DATA_OFFSET for acquiring PERF stats.
- *! 27-Oct-2000 jeh Added timeouts to NODE_GETMESSAGE, NODE_PUTMESSAGE args.
- *!		 Removed NODE_GETMESSAGESTRM args.
- *! 11-Oct-2000 ag: Added SM mgr(CMM) args.
- *! 27-Sep-2000 jeh Removed struct DSP_BUFFERATTR param from
- *!		    ARGS_STRM_ALLOCATEBUFFER.
- *! 25-Sep-2000 rr: Updated to Version 0.9
- *! 07-Sep-2000 jeh Changed HANDLE to DSP_HNOTIFICATION in RegisterNotify args.
- *!		 Added DSP_STRMATTR to DSPNode_Connect args.
- *! 04-Aug-2000 rr: MEM and UTIL added to RM.
- *! 27-Jul-2000 rr: NODE, MGR,STRM and PROC added
- *! 27-Jun-2000 rr: Modifed to Use either PM or DSP/BIOS Bridge
- *!		 IFDEF to build for PM or DSP/BIOS Bridge
- *! 28-Jan-2000 rr: NT_CMD_FROM_OFFSET moved out to dsptrap.h
- *! 24-Jan-2000 rr: Merged with Scott's code.
- *! 21-Jan-2000 sg: In ARGS_CHNL_GETMODE changed mode to be u32 to be
- *!		 consistent with chnldefs.h.
- *! 11-Jan-2000 rr: CMD_CFG_GETCDVERSION_OFFSET added.
- *! 12-Nov-1999 rr: CMD_BRD_MONITOR_OFFSET added
- *! 09-Nov-1999 kc: Added MEMRY and enabled CMD_BRD_IOCTL_OFFSET.
- *! 05-Nov-1999 ag: Added CHNL.
- *! 02-Nov-1999 kc: Removed field from ARGS_UTIL_TESTDLL.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 08-Oct-1999 rr: Util control offsets added.
- *! 13-Sep-1999 kc: Added ARGS_UTIL_TESTDLL for PM test infrastructure.
- *! 19-Aug-1999 rr: Created from WSX. Minimal Implementaion of BRD_Start and BRD
- *!		 and BRD_Stop. IOCTL Offsets and CTRL Code.
- */
-
 #ifndef WCDIOCTL_
 #define WCDIOCTL_
 
@@ -100,7 +54,7 @@ union Trapped_Args {
 	} ARGS_MGR_UNREGISTEROBJECT;
 
 	struct {
-		struct DSP_NOTIFICATION  __user*__user *aNotifications;
+		struct DSP_NOTIFICATION  __user *__user *aNotifications;
 		u32 uCount;
 		u32 __user *puIndex;
 		u32 uTimeout;
@@ -110,82 +64,79 @@ union Trapped_Args {
 	struct {
 		u32 uProcessor;
 		struct DSP_PROCESSORATTRIN __user *pAttrIn;
-		DSP_HPROCESSOR __user *phProcessor;
+		void *__user *phProcessor;
 	} ARGS_PROC_ATTACH;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 		u32 dwCmd;
 		struct DSP_CBDATA __user *pArgs;
 	} ARGS_PROC_CTRL;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 	} ARGS_PROC_DETACH;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
-		DSP_HNODE __user *aNodeTab;
+		void *hProcessor;
+		void *__user *aNodeTab;
 		u32 uNodeTabSize;
 		u32 __user *puNumNodes;
 		u32 __user *puAllocated;
 	} ARGS_PROC_ENUMNODE_INFO;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 		u32 uResourceType;
 		struct DSP_RESOURCEINFO *pResourceInfo;
 		u32 uResourceInfoSize;
 	} ARGS_PROC_ENUMRESOURCES;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 		struct DSP_PROCESSORSTATE __user *pProcStatus;
 		u32 uStateInfoSize;
 	} ARGS_PROC_GETSTATE;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 		u8 __user *pBuf;
-
-	#ifndef RES_CLEANUP_DISABLE
-	    u8 __user *pSize;
-    #endif
+		u8 __user *pSize;
 		u32 uMaxSize;
 	} ARGS_PROC_GETTRACE;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 		s32 iArgc;
-		char __user*__user *aArgv;
+		char __user *__user *aArgv;
 		char *__user *aEnvp;
 	} ARGS_PROC_LOAD;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 		u32 uEventMask;
 		u32 uNotifyType;
 		struct DSP_NOTIFICATION __user *hNotification;
 	} ARGS_PROC_REGISTER_NOTIFY;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 	} ARGS_PROC_START;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 		u32 ulSize;
 		void *__user *ppRsvAddr;
 	} ARGS_PROC_RSVMEM;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 		u32 ulSize;
 		void *pRsvAddr;
 	} ARGS_PROC_UNRSVMEM;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 		void *pMpuAddr;
 		u32 ulSize;
 		void *pReqAddr;
@@ -194,24 +145,24 @@ union Trapped_Args {
 	} ARGS_PROC_MAPMEM;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 		u32 ulSize;
 		void *pMapAddr;
 	} ARGS_PROC_UNMAPMEM;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 		void *pMpuAddr;
 		u32 ulSize;
 		u32 ulFlags;
 	} ARGS_PROC_FLUSHMEMORY;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 	} ARGS_PROC_STOP;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 		void *pMpuAddr;
 		u32 ulSize;
 	} ARGS_PROC_INVALIDATEMEMORY;
@@ -219,88 +170,88 @@ union Trapped_Args {
 
 	/* NODE Module */
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 		struct DSP_UUID __user *pNodeID;
 		struct DSP_CBDATA __user *pArgs;
 		struct DSP_NODEATTRIN __user *pAttrIn;
-		DSP_HNODE __user *phNode;
+		void *__user *phNode;
 	} ARGS_NODE_ALLOCATE;
 
 	struct {
-		DSP_HNODE hNode;
+		void *hNode;
 		u32 uSize;
 		struct DSP_BUFFERATTR __user *pAttr;
 		u8 *__user *pBuffer;
 	} ARGS_NODE_ALLOCMSGBUF;
 
 	struct {
-		DSP_HNODE hNode;
+		void *hNode;
 		s32 iPriority;
 	} ARGS_NODE_CHANGEPRIORITY;
 
 	struct {
-		DSP_HNODE hNode;
+		void *hNode;
 		u32 uStream;
-		DSP_HNODE hOtherNode;
+		void *hOtherNode;
 		u32 uOtherStream;
 		struct DSP_STRMATTR __user *pAttrs;
 		struct DSP_CBDATA __user *pConnParam;
 	} ARGS_NODE_CONNECT;
 
 	struct {
-		DSP_HNODE hNode;
+		void *hNode;
 	} ARGS_NODE_CREATE;
 
 	struct {
-		DSP_HNODE hNode;
+		void *hNode;
 	} ARGS_NODE_DELETE;
 
 	struct {
-		DSP_HNODE hNode;
+		void *hNode;
 		struct DSP_BUFFERATTR __user *pAttr;
 		u8 *pBuffer;
 	} ARGS_NODE_FREEMSGBUF;
 
 	struct {
-		DSP_HNODE hNode;
+		void *hNode;
 		struct DSP_NODEATTR __user *pAttr;
 		u32 uAttrSize;
 	} ARGS_NODE_GETATTR;
 
 	struct {
-		DSP_HNODE hNode;
+		void *hNode;
 		struct DSP_MSG __user *pMessage;
 		u32 uTimeout;
 	} ARGS_NODE_GETMESSAGE;
 
 	struct {
-		DSP_HNODE hNode;
+		void *hNode;
 	} ARGS_NODE_PAUSE;
 
 	struct {
-		DSP_HNODE hNode;
+		void *hNode;
 		struct DSP_MSG __user *pMessage;
 		u32 uTimeout;
 	} ARGS_NODE_PUTMESSAGE;
 
 	struct {
-		DSP_HNODE hNode;
+		void *hNode;
 		u32 uEventMask;
 		u32 uNotifyType;
 		struct DSP_NOTIFICATION __user *hNotification;
 	} ARGS_NODE_REGISTERNOTIFY;
 
 	struct {
-		DSP_HNODE hNode;
+		void *hNode;
 	} ARGS_NODE_RUN;
 
 	struct {
-		DSP_HNODE hNode;
+		void *hNode;
 		DSP_STATUS __user *pStatus;
 	} ARGS_NODE_TERMINATE;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 		struct DSP_UUID __user *pNodeID;
 		struct DSP_NDBPROPS __user *pNodeProps;
 	} ARGS_NODE_GETUUIDPROPS;
@@ -308,40 +259,40 @@ union Trapped_Args {
 	/* STRM module */
 
 	struct {
-		DSP_HSTREAM hStream;
+		void *hStream;
 		u32 uSize;
 		u8 *__user *apBuffer;
 		u32 uNumBufs;
 	} ARGS_STRM_ALLOCATEBUFFER;
 
 	struct {
-		DSP_HSTREAM hStream;
+		void *hStream;
 	} ARGS_STRM_CLOSE;
 
 	struct {
-		DSP_HSTREAM hStream;
+		void *hStream;
 		u8 *__user *apBuffer;
 		u32 uNumBufs;
 	} ARGS_STRM_FREEBUFFER;
 
 	struct {
-		DSP_HSTREAM hStream;
+		void *hStream;
 		HANDLE *phEvent;
 	} ARGS_STRM_GETEVENTHANDLE;
 
 	struct {
-		DSP_HSTREAM hStream;
+		void *hStream;
 		struct STRM_INFO __user *pStreamInfo;
 		u32 uStreamInfoSize;
 	} ARGS_STRM_GETINFO;
 
 	struct {
-		DSP_HSTREAM hStream;
+		void *hStream;
 		bool bFlush;
 	} ARGS_STRM_IDLE;
 
 	struct {
-		DSP_HSTREAM hStream;
+		void *hStream;
 		u8 *pBuffer;
 		u32 dwBytes;
 		u32 dwBufSize;
@@ -349,15 +300,15 @@ union Trapped_Args {
 	} ARGS_STRM_ISSUE;
 
 	struct {
-		DSP_HNODE hNode;
+		void *hNode;
 		u32 uDirection;
 		u32 uIndex;
 		struct STRM_ATTR __user *pAttrIn;
-		DSP_HSTREAM __user *phStream;
+		void *__user *phStream;
 	} ARGS_STRM_OPEN;
 
 	struct {
-		DSP_HSTREAM hStream;
+		void *hStream;
 		u8 *__user *pBufPtr;
 		u32 __user *pBytes;
 		u32 __user *pBufSize;
@@ -365,14 +316,14 @@ union Trapped_Args {
 	} ARGS_STRM_RECLAIM;
 
 	struct {
-		DSP_HSTREAM hStream;
+		void *hStream;
 		u32 uEventMask;
 		u32 uNotifyType;
 		struct DSP_NOTIFICATION __user *hNotification;
 	} ARGS_STRM_REGISTERNOTIFY;
 
 	struct {
-		DSP_HSTREAM __user *aStreamTab;
+		void *__user *aStreamTab;
 		u32 nStreams;
 		u32 __user *pMask;
 		u32 uTimeout;
@@ -393,7 +344,7 @@ union Trapped_Args {
 	} ARGS_CMM_FREEBUF;
 
 	struct {
-		DSP_HPROCESSOR hProcessor;
+		void *hProcessor;
 		struct CMM_OBJECT *__user *phCmmMgr;
 	} ARGS_CMM_GETHANDLE;
 
@@ -437,83 +388,159 @@ union Trapped_Args {
 	} ARGS_UTIL_TESTDLL;
 } ;
 
-#define CMD_BASE		    1
+/*
+ * Dspbridge Ioctl numbering scheme
+ *
+ *    7                           0
+ *  ---------------------------------
+ *  |  Module   |   Ioctl Number    |
+ *  ---------------------------------
+ *  | x | x | x | 0 | 0 | 0 | 0 | 0 |
+ *  ---------------------------------
+ */
+
+/* Ioctl driver identifier */
+#define DB		0xDB
+#ifdef CONFIG_BRIDGE_NEW_API
+/*
+ * Following are used to distinguish between module ioctls, this is needed
+ * in case new ioctls are introduced.
+ */
+#define DB_MODULE_MASK		0xE0
+#define DB_IOC_MASK		0x1F
 
-/* MGR module offsets */
-#define CMD_MGR_BASE_OFFSET	     CMD_BASE
-#define CMD_MGR_ENUMNODE_INFO_OFFSET    (CMD_MGR_BASE_OFFSET + 0)
-#define CMD_MGR_ENUMPROC_INFO_OFFSET    (CMD_MGR_BASE_OFFSET + 1)
-#define CMD_MGR_REGISTEROBJECT_OFFSET   (CMD_MGR_BASE_OFFSET + 2)
-#define CMD_MGR_UNREGISTEROBJECT_OFFSET (CMD_MGR_BASE_OFFSET + 3)
-#define CMD_MGR_WAIT_OFFSET	     (CMD_MGR_BASE_OFFSET + 4)
-
-#ifndef RES_CLEANUP_DISABLE
-#define CMD_MGR_RESOUCES_OFFSET	 (CMD_MGR_BASE_OFFSET + 5)
-#define CMD_MGR_END_OFFSET	      CMD_MGR_RESOUCES_OFFSET
-#else
-#define CMD_MGR_END_OFFSET	      CMD_MGR_WAIT_OFFSET
-#endif
-
-#define CMD_PROC_BASE_OFFSET	    (CMD_MGR_END_OFFSET + 1)
-#define CMD_PROC_ATTACH_OFFSET	  (CMD_PROC_BASE_OFFSET + 0)
-#define CMD_PROC_CTRL_OFFSET	    (CMD_PROC_BASE_OFFSET + 1)
-#define CMD_PROC_DETACH_OFFSET	  (CMD_PROC_BASE_OFFSET + 2)
-#define CMD_PROC_ENUMNODE_OFFSET	(CMD_PROC_BASE_OFFSET + 3)
-#define CMD_PROC_ENUMRESOURCES_OFFSET   (CMD_PROC_BASE_OFFSET + 4)
-#define CMD_PROC_GETSTATE_OFFSET	(CMD_PROC_BASE_OFFSET + 5)
-#define CMD_PROC_GETTRACE_OFFSET	(CMD_PROC_BASE_OFFSET + 6)
-#define CMD_PROC_LOAD_OFFSET	    (CMD_PROC_BASE_OFFSET + 7)
-#define CMD_PROC_REGISTERNOTIFY_OFFSET  (CMD_PROC_BASE_OFFSET + 8)
-#define CMD_PROC_START_OFFSET	   (CMD_PROC_BASE_OFFSET + 9)
-#define CMD_PROC_RSVMEM_OFFSET	  (CMD_PROC_BASE_OFFSET + 10)
-#define CMD_PROC_UNRSVMEM_OFFSET	(CMD_PROC_BASE_OFFSET + 11)
-#define CMD_PROC_MAPMEM_OFFSET	  (CMD_PROC_BASE_OFFSET + 12)
-#define CMD_PROC_UNMAPMEM_OFFSET	(CMD_PROC_BASE_OFFSET + 13)
-#define CMD_PROC_FLUSHMEMORY_OFFSET      (CMD_PROC_BASE_OFFSET + 14)
-#define CMD_PROC_STOP_OFFSET	    (CMD_PROC_BASE_OFFSET + 15)
-#define CMD_PROC_INVALIDATEMEMORY_OFFSET (CMD_PROC_BASE_OFFSET + 16)
-#define CMD_PROC_END_OFFSET	     CMD_PROC_INVALIDATEMEMORY_OFFSET
-
-
-#define CMD_NODE_BASE_OFFSET	    (CMD_PROC_END_OFFSET + 1)
-#define CMD_NODE_ALLOCATE_OFFSET	(CMD_NODE_BASE_OFFSET + 0)
-#define CMD_NODE_ALLOCMSGBUF_OFFSET     (CMD_NODE_BASE_OFFSET + 1)
-#define CMD_NODE_CHANGEPRIORITY_OFFSET  (CMD_NODE_BASE_OFFSET + 2)
-#define CMD_NODE_CONNECT_OFFSET	 (CMD_NODE_BASE_OFFSET + 3)
-#define CMD_NODE_CREATE_OFFSET	  (CMD_NODE_BASE_OFFSET + 4)
-#define CMD_NODE_DELETE_OFFSET	  (CMD_NODE_BASE_OFFSET + 5)
-#define CMD_NODE_FREEMSGBUF_OFFSET      (CMD_NODE_BASE_OFFSET + 6)
-#define CMD_NODE_GETATTR_OFFSET	 (CMD_NODE_BASE_OFFSET + 7)
-#define CMD_NODE_GETMESSAGE_OFFSET      (CMD_NODE_BASE_OFFSET + 8)
-#define CMD_NODE_PAUSE_OFFSET	   (CMD_NODE_BASE_OFFSET + 9)
-#define CMD_NODE_PUTMESSAGE_OFFSET      (CMD_NODE_BASE_OFFSET + 10)
-#define CMD_NODE_REGISTERNOTIFY_OFFSET  (CMD_NODE_BASE_OFFSET + 11)
-#define CMD_NODE_RUN_OFFSET	     (CMD_NODE_BASE_OFFSET + 12)
-#define CMD_NODE_TERMINATE_OFFSET       (CMD_NODE_BASE_OFFSET + 13)
-#define CMD_NODE_GETUUIDPROPS_OFFSET    (CMD_NODE_BASE_OFFSET + 14)
-#define CMD_NODE_END_OFFSET	     CMD_NODE_GETUUIDPROPS_OFFSET
-
-#define CMD_STRM_BASE_OFFSET	    (CMD_NODE_END_OFFSET + 1)
-#define CMD_STRM_ALLOCATEBUFFER_OFFSET  (CMD_STRM_BASE_OFFSET + 0)
-#define CMD_STRM_CLOSE_OFFSET	   (CMD_STRM_BASE_OFFSET + 1)
-#define CMD_STRM_FREEBUFFER_OFFSET      (CMD_STRM_BASE_OFFSET + 2)
-#define CMD_STRM_GETEVENTHANDLE_OFFSET  (CMD_STRM_BASE_OFFSET + 3)
-#define CMD_STRM_GETINFO_OFFSET	 (CMD_STRM_BASE_OFFSET + 4)
-#define CMD_STRM_IDLE_OFFSET	    (CMD_STRM_BASE_OFFSET + 5)
-#define CMD_STRM_ISSUE_OFFSET	   (CMD_STRM_BASE_OFFSET + 6)
-#define CMD_STRM_OPEN_OFFSET	    (CMD_STRM_BASE_OFFSET + 7)
-#define CMD_STRM_RECLAIM_OFFSET	 (CMD_STRM_BASE_OFFSET + 8)
-#define CMD_STRM_REGISTERNOTIFY_OFFSET  (CMD_STRM_BASE_OFFSET + 9)
-#define CMD_STRM_SELECT_OFFSET	  (CMD_STRM_BASE_OFFSET + 10)
-#define CMD_STRM_END_OFFSET	     CMD_STRM_SELECT_OFFSET
-
-/* Communication Memory Manager (UCMM) */
-#define CMD_CMM_BASE_OFFSET	     (CMD_STRM_END_OFFSET + 1)
-#define CMD_CMM_ALLOCBUF_OFFSET	 (CMD_CMM_BASE_OFFSET + 0)
-#define CMD_CMM_FREEBUF_OFFSET	  (CMD_CMM_BASE_OFFSET + 1)
-#define CMD_CMM_GETHANDLE_OFFSET	(CMD_CMM_BASE_OFFSET + 2)
-#define CMD_CMM_GETINFO_OFFSET	  (CMD_CMM_BASE_OFFSET + 3)
-#define CMD_CMM_END_OFFSET	      CMD_CMM_GETINFO_OFFSET
+/* Ioctl module masks */
+#define DB_MGR		0x0
+#define DB_PROC		0x20
+#define DB_NODE		0x40
+#define DB_STRM		0x60
+#define DB_CMM		0x80
+
+#define DB_MODULE_SHIFT		5
+
+/* Used to calculate the ioctl per dspbridge module */
+#define DB_IOC(module, num) \
+			(((module) & DB_MODULE_MASK) | ((num) & DB_IOC_MASK))
+/* Used to get dspbridge ioctl module */
+#define DB_GET_MODULE(cmd)	((cmd) & DB_MODULE_MASK)
+/* Used to get dspbridge ioctl number */
+#define DB_GET_IOC(cmd)		((cmd) & DB_IOC_MASK)
+
+#else /* NEW_API */
+
+#define DB_MGR  1
+#define DB_PROC 7
+#define DB_NODE 24
+#define DB_STRM 39
+#define DB_CMM  50
+
+#define DB_IOC(module, num)	((module) + (num))
+
+/* Used to get dspbridge ioctl module */
+static int DB_GET_MODULE(int cmd)
+{
+    if(cmd<DB_PROC)
+	return DB_MGR;
+    else if(cmd<DB_NODE)
+	return DB_PROC;
+    else if(cmd<DB_STRM)
+	return DB_NODE;
+    else if(cmd<DB_CMM)
+	return DB_STRM;
+    else
+	return DB_CMM;
+}
+
+/* Used to get dspbridge ioctl number */
+static int DB_GET_IOC(int cmd)
+{
+    if(cmd<DB_PROC)
+	return (cmd-DB_MGR);
+    else if(cmd<DB_NODE)
+	return (cmd-DB_PROC);
+    else if(cmd<DB_STRM)
+	return (cmd-DB_NODE);
+    else if(cmd<DB_CMM)
+	return (cmd-DB_STRM);
+    else
+	return (cmd-DB_CMM);
+}
+
+#undef _IOR
+#undef _IOW
+#undef _IOWR
+
+#define _IOR(type, nr, size)	(nr)
+#define _IOW(type, nr, size)	(nr)
+#define _IOWR(type, nr, size)	(nr)
+#endif /* NEW_API */
+
+
+/* TODO: Remove deprecated and not implemented */
+
+/* MGR Module */
+#define MGR_ENUMNODE_INFO	_IOWR(DB, DB_IOC(DB_MGR, 0), unsigned long)
+#define MGR_ENUMPROC_INFO	_IOWR(DB, DB_IOC(DB_MGR, 1), unsigned long)
+#define MGR_REGISTEROBJECT	_IOWR(DB, DB_IOC(DB_MGR, 2), unsigned long)
+#define MGR_UNREGISTEROBJECT	_IOWR(DB, DB_IOC(DB_MGR, 3), unsigned long)
+#define MGR_WAIT		_IOWR(DB, DB_IOC(DB_MGR, 4), unsigned long)
+/* MGR_GET_PROC_RES Deprecated */
+#define MGR_GET_PROC_RES	_IOR(DB, DB_IOC(DB_MGR, 5), unsigned long)
+
+/* PROC Module */
+#define PROC_ATTACH		_IOWR(DB, DB_IOC(DB_PROC, 0), unsigned long)
+#define PROC_CTRL		_IOR(DB, DB_IOC(DB_PROC, 1), unsigned long)
+/* PROC_DETACH Deprecated */
+#define PROC_DETACH		_IOR(DB, DB_IOC(DB_PROC, 2), unsigned long)
+#define PROC_ENUMNODE		_IOWR(DB, DB_IOC(DB_PROC, 3), unsigned long)
+#define PROC_ENUMRESOURCES	_IOWR(DB, DB_IOC(DB_PROC, 4), unsigned long)
+#define PROC_GET_STATE		_IOWR(DB, DB_IOC(DB_PROC, 5), unsigned long)
+#define PROC_GET_TRACE		_IOWR(DB, DB_IOC(DB_PROC, 6), unsigned long)
+#define PROC_LOAD		_IOW(DB, DB_IOC(DB_PROC, 7), unsigned long)
+#define PROC_REGISTERNOTIFY	_IOWR(DB, DB_IOC(DB_PROC, 8), unsigned long)
+#define PROC_START		_IOW(DB, DB_IOC(DB_PROC, 9), unsigned long)
+#define PROC_RSVMEM		_IOWR(DB, DB_IOC(DB_PROC, 10), unsigned long)
+#define PROC_UNRSVMEM		_IOW(DB, DB_IOC(DB_PROC, 11), unsigned long)
+#define PROC_MAPMEM		_IOWR(DB, DB_IOC(DB_PROC, 12), unsigned long)
+#define PROC_UNMAPMEM		_IOR(DB, DB_IOC(DB_PROC, 13), unsigned long)
+#define PROC_FLUSHMEMORY	_IOW(DB, DB_IOC(DB_PROC, 14), unsigned long)
+#define PROC_STOP		_IOWR(DB, DB_IOC(DB_PROC, 15), unsigned long)
+#define PROC_INVALIDATEMEMORY	_IOW(DB, DB_IOC(DB_PROC, 16), unsigned long)
+
+/* NODE Module */
+#define NODE_ALLOCATE		_IOWR(DB, DB_IOC(DB_NODE, 0), unsigned long)
+#define NODE_ALLOCMSGBUF	_IOWR(DB, DB_IOC(DB_NODE, 1), unsigned long)
+#define NODE_CHANGEPRIORITY	_IOW(DB, DB_IOC(DB_NODE, 2), unsigned long)
+#define NODE_CONNECT		_IOW(DB, DB_IOC(DB_NODE, 3), unsigned long)
+#define NODE_CREATE		_IOW(DB, DB_IOC(DB_NODE, 4), unsigned long)
+#define NODE_DELETE		_IOW(DB, DB_IOC(DB_NODE, 5), unsigned long)
+#define NODE_FREEMSGBUF		_IOW(DB, DB_IOC(DB_NODE, 6), unsigned long)
+#define NODE_GETATTR		_IOWR(DB, DB_IOC(DB_NODE, 7), unsigned long)
+#define NODE_GETMESSAGE		_IOWR(DB, DB_IOC(DB_NODE, 8), unsigned long)
+#define NODE_PAUSE		_IOW(DB, DB_IOC(DB_NODE, 9), unsigned long)
+#define NODE_PUTMESSAGE		_IOW(DB, DB_IOC(DB_NODE, 10), unsigned long)
+#define NODE_REGISTERNOTIFY	_IOWR(DB, DB_IOC(DB_NODE, 11), unsigned long)
+#define NODE_RUN		_IOW(DB, DB_IOC(DB_NODE, 12), unsigned long)
+#define NODE_TERMINATE		_IOWR(DB, DB_IOC(DB_NODE, 13), unsigned long)
+#define NODE_GETUUIDPROPS	_IOWR(DB, DB_IOC(DB_NODE, 14), unsigned long)
+
+/* STRM Module */
+#define STRM_ALLOCATEBUFFER	_IOWR(DB, DB_IOC(DB_STRM, 0), unsigned long)
+#define STRM_CLOSE		_IOW(DB, DB_IOC(DB_STRM, 1), unsigned long)
+#define STRM_FREEBUFFER		_IOWR(DB, DB_IOC(DB_STRM, 2), unsigned long)
+#define STRM_GETEVENTHANDLE	_IO(DB, DB_IOC(DB_STRM, 3))	/* Not Impl'd */
+#define STRM_GETINFO		_IOWR(DB, DB_IOC(DB_STRM, 4), unsigned long)
+#define STRM_IDLE		_IOW(DB, DB_IOC(DB_STRM, 5), unsigned long)
+#define STRM_ISSUE		_IOW(DB, DB_IOC(DB_STRM, 6), unsigned long)
+#define STRM_OPEN		_IOWR(DB, DB_IOC(DB_STRM, 7), unsigned long)
+#define STRM_RECLAIM		_IOWR(DB, DB_IOC(DB_STRM, 8), unsigned long)
+#define STRM_REGISTERNOTIFY	_IOWR(DB, DB_IOC(DB_STRM, 9), unsigned long)
+#define STRM_SELECT		_IOWR(DB, DB_IOC(DB_STRM, 10), unsigned long)
+
+/* CMM Module */
+#define CMM_ALLOCBUF		_IO(DB, DB_IOC(DB_CMM, 0))	/* Not Impl'd */
+#define CMM_FREEBUF		_IO(DB, DB_IOC(DB_CMM, 1))	/* Not Impl'd */
+#define CMM_GETHANDLE		_IOR(DB, DB_IOC(DB_CMM, 2), unsigned long)
+#define CMM_GETINFO		_IOR(DB, DB_IOC(DB_CMM, 3), unsigned long)
 
-#define CMD_BASE_END_OFFSET	CMD_CMM_END_OFFSET
 #endif				/* WCDIOCTL_ */
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/wmd.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/wmd.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/wmd.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/wmd.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,18 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Bridge mini driver entry point and interface function declarations.
+ *
+ * Notes:
+ *   The Bridge class driver obtains it's function interface to
+ *   the Bridge mini driver via a call to WMD_DRV_Entry().
+ *
+ *   Bridge Class Driver services exported to WMD's are initialized by the
+ *   WCD on behalf of the WMD.
+ *
+ *   WMD function DBC Requires and Ensures are also made by the WCD on
+ *   behalf of the WMD, to simplify the WMD code.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,51 +26,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== wmd.h ========
- *  Purpose:
- *      'Bridge mini driver entry point and interface function declarations.
- *
- *  Public Functions:
- *      WMD_DRV_Entry
- *
- *  Notes:
- *      The 'Bridge class driver obtains it's function interface to
- *      the 'Bridge mini driver via a call to WMD_DRV_Entry().
- *
- *      'Bridge Class Driver services exported to WMD's are initialized by the
- *      WCD on behalf of the WMD.
- *
- *      WMD function DBC Requires and Ensures are also made by the WCD on
- *      behalf of the WMD, to simplify the WMD code.
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping APIs - WMD_BRD_MemMap/UnMap
- *! 01-Mar-2004 vp  Added filename argument to WMD_DRV_Entry function.
- *! 29-Aug-2002 map Added WMD_BRD_MemWrite()
- *! 26-Aug-2002 map Added WMD_BRD_MemCopy()
- *! 07-Jan-2002 ag  Added cBufSize to WMD_CHNL_AddIOReq().
- *! 05-Nov-2001 kc: Added error handling DEH functions.
- *! 06-Dec-2000 jeh Added uEventMask to WMD_MSG_RegisterNotify().
- *! 17-Nov-2000 jeh Added WMD_MSG and WMD_IO definitions.
- *! 01-Nov-2000 jeh Added more error codes to WMD_CHNL_RegisterNotify().
- *! 13-Oct-2000 jeh Added dwArg to WMD_CHNL_AddIOReq(), added WMD_CHNL_IDLE
- *!                 and WMD_CHNL_RegisterNotify for DSPStream support.
- *! 17-Jan-2000 rr: WMD_BRD_SETSTATE Added.
- *! 30-Jul-1997 gp: Split wmd IOCTL space into reserved and private.
- *! 07-Nov-1996 gp: Updated for code review.
- *! 18-Oct-1996 gp: Added WMD_E_HARDWARE return code from WMD_BRD_Monitor.
- *! 09-Sep-1996 gp: Subtly altered the semantics of WMD_CHNL_GetInfo().
- *! 02-Aug-1996 gp: Ensured on BRD_Start that interrupts to the PC are enabled.
- *! 11-Jul-1996 gp: Added CHNL interface. Note stronger DBC_Require conditions.
- *! 29-May-1996 gp: Removed WCD_ prefix from functions imported from WCD.LIB.
- *! 29-May-1996 gp: Made OUT param first in WMD_DEV_Create().
- *! 09-May-1996 gp: Created.
- */
-
 #ifndef WMD_
 #define WMD_
 
@@ -277,7 +244,7 @@
  */
        typedef DSP_STATUS(*
 			   WMD_BRD_STATUS) (struct WMD_DEV_CONTEXT *hDevContext,
-					    OUT BRD_STATUS * pdwState);
+					    int *pdwState);
 
 /*
  *  ======== WMD_BRD_Read ========
@@ -451,7 +418,7 @@ typedef DSP_STATUS(*WMD_BRD_WRITE)(struc
        typedef DSP_STATUS(*WMD_CHNL_OPEN) (OUT struct CHNL_OBJECT
 						   **phChnl,
 						   struct CHNL_MGR *hChnlMgr,
-						   CHNL_MODE uMode,
+						   short int uMode,
 						   u32 uChnlId,
 						   CONST IN OPTIONAL struct
 						   CHNL_ATTRS *pAttrs);
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/wmdchnl.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/wmdchnl.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/wmdchnl.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/wmdchnl.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,13 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Declares the upper edge channel class library functions required by
+ * all WMD / WCD driver interface tables.  These functions are implemented
+ * by every class of WMD channel library.
+ *
+ * Notes:
+ *   The function comment headers reside in wmd.h.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,28 +21,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== wmdchnl.h ========
- *  Description:
- *      Declares the upper edge channel class library functions required by
- *      all WMD / WCD driver interface tables.  These functions are implemented
- *      by every class of WMD channel library.
- *
- *  Public Functions:
- *
- *  Notes:
- *      The function comment headers reside with the function typedefs in wmd.h.
- *
- *! Revision History:
- *! ================
- *! 07-Jan-2002 ag  Added cBufSize to WMD_CHNL_AddIOReq().
- *! 13-Oct-2000 jeh Added dwArg parameter to WMD_CHNL_AddIOReq(), added
- *!                 WMD_CHNL_Idle and WMD_CHNL_RegisterNotify for DSPStream
- *!                 support.
- *! 11-Jul-1996 gp: Created.
- */
-
 #ifndef WMDCHNL_
 #define WMDCHNL_
 
@@ -48,7 +33,7 @@
 
 	extern DSP_STATUS WMD_CHNL_Open(OUT struct CHNL_OBJECT **phChnl,
 					struct CHNL_MGR *hChnlMgr,
-					CHNL_MODE uMode,
+					short int uMode,
 					u32 uChnlId,
 					CONST IN OPTIONAL struct CHNL_ATTRS
 					*pAttrs);
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/wmddeh.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/wmddeh.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/wmddeh.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/wmddeh.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,12 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Defines upper edge DEH functions required by all WMD/WCD driver
+ * interface tables.
+ *
+ * Notes:
+ *   Function comment headers reside with the function typedefs in wmd.h.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,30 +20,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== wmddeh.h ========
- *  Description:
- *      Defines upper edge DEH functions required by all WMD/WCD driver
- *      interface tables.
- *
- *  Public Functions:
- *      WMD_DEH_Create
- *      IVA_DEH_Create
- *      WMD_DEH_Destroy
- *      WMD_DEH_GetInfo
- *      WMD_DEH_RegisterNotify
- *      WMD_DEH_Notify
- *
- *  Notes:
- *      Function comment headers reside with the function typedefs in wmd.h.
- *
- *! Revision History:
- *! ================
- *! 26-Dec-2004 hn: added IVA_DEH_Create.
- *! 13-Sep-2001 kc: created.
- */
-
 #ifndef WMDDEH_
 #define WMDDEH_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/wmdio.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/wmdio.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/wmdio.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/wmdio.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,12 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Declares the upper edge IO functions required by all WMD / WCD
+ * driver interface tables.
+ *
+ * Notes:
+ *   Function comment headers reside in wmd.h.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,24 +20,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== wmdio.h ========
- *  Description:
- *      Declares the upper edge IO  functions required by
- *      all WMD / WCD driver interface tables.
- *
- *  Public Functions:
- *
- *  Notes:
- *      Function comment headers reside with the function typedefs in wmd.h.
- *
- *! Revision History:
- *! ================
- *! 27-Feb-2004 vp		Added IVA releated function.
- *! 06-Nov-2000 jeh     Created.
- */
-
 #ifndef WMDIO_
 #define WMDIO_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/wmdioctl.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/wmdioctl.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/wmdioctl.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/wmdioctl.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * BRIDGE Minidriver BRD_IOCtl reserved command definitions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,30 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== wmdioctl.h ========
- *  Description:
- *    BRIDGE Minidriver BRD_IOCtl reserved command definitions.
- *
- *! Revision History
- *! ================
- *! 19-Apr-2004 sb   Updated HW typedefs
- *! 16-Feb-2004 vp   Added MMU endianness attributes to WMDIOCTL_EXTPROC
- *! 21-Mar-2003 sb   Changed WMDIOCTL_NUMOFMMUTLB from 7 to 32
- *! 14-May-2001 sg   Added codes for PWR.
- *! 10-Aug-2001 ag   Added _SETMMUCONFIG ioctl used for DSP-MMU init.
- *! 16-Nov-1999 rajesh ?
- *! 18-Jun-1998 ag   Moved EMIF, SDRAM_C, & CE space init to ENBLEXTMEM ioctl.
- *!                  Added ENBLEXTMEM, RESETDSP, UNRESETDSP & ASSERTSIG ioctls.
- *! 07-Jun-1998 ag   Added JTAG_SELECT, MAP_TBC, GET_CONFIGURATION ioctls.
- *! 26-Jan-1998 jeh: Added START, RECV, and SEND ioctls.
- *! 07-Nov-1997 nn:  Added command to interrupt DSP for interrupt test.
- *! 20-Oct-1997 nn:  Added commands for getting and resetting interrupt count.
- *! 17-Oct-1997 gp:  Moved to src/wmd. Standardized prefix.
- *! 08-Oct-1997 nn:  Created.
- */
-
 #ifndef WMDIOCTL_
 #define WMDIOCTL_
 
diff -rupN kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/wmdmsg.h kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/wmdmsg.h
--- kernel-power-2.6.28.orig/arch/arm/plat-omap/include/dspbridge/wmdmsg.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/arch/arm/plat-omap/include/dspbridge/wmdmsg.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,13 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Declares the upper edge message class library functions required by
+ * all WMD / WCD driver interface tables.  These functions are
+ * implemented by every class of WMD channel library.
+ *
+ * Notes:
+ *   Function comment headers reside in wmd.h.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,26 +21,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== wmdmsg.h ========
- *  Description:
- *      Declares the upper edge message class library functions required by
- *      all WMD / WCD driver interface tables.  These functions are
- *      implemented by every class of WMD channel library.
- *
- *  Public Functions:
- *
- *  Notes:
- *      Function comment headers reside with the function typedefs in wmd.h.
- *
- *! Revision History:
- *! ================
- *! 06-Dec-2000 jeh     Added uEventMask to WMD_MSG_RegisterNotify(). Added
- *!                     WMD_MSG_SetQueueId().
- *! 17-Nov-2000 jeh     Created.
- */
-
 #ifndef WMDMSG_
 #define WMDMSG_
 
diff -rupN kernel-power-2.6.28.orig/debian/rx51power_defconfig kernel-power-2.6.28/debian/rx51power_defconfig
--- kernel-power-2.6.28.orig/debian/rx51power_defconfig	2011-04-17 17:32:12.000000000 +0100
+++ kernel-power-2.6.28/debian/rx51power_defconfig	2011-05-06 14:16:04.000000000 +0100
@@ -1512,7 +1512,7 @@ CONFIG_FB_CFB_IMAGEBLIT=y
 CONFIG_FB_OMAP_BOOTLOADER_INIT=y
 CONFIG_FB_OMAP_CONSISTENT_DMA_SIZE=14
 CONFIG_OMAP2_DSS=y
-CONFIG_OMAP2_DSS_VRAM_SIZE=0
+CONFIG_OMAP2_DSS_VRAM_SIZE=6
 # CONFIG_OMAP2_DSS_DEBUG_SUPPORT is not set
 # CONFIG_OMAP2_DSS_RFBI is not set
 CONFIG_OMAP2_DSS_VENC=y
@@ -1943,9 +1943,9 @@ CONFIG_REGULATOR_TWL4030=y
 # CONFIG_CBUS is not set
 CONFIG_MPU_BRIDGE=m
 CONFIG_BRIDGE_DVFS=y
-CONFIG_BRIDGE_MEMPOOL_SIZE=0x412800
+CONFIG_BRIDGE_MEMPOOL_SIZE=0x600000
 # CONFIG_BRIDGE_DEBUG is not set
-
+# CONFIG_BRIDGE_NTFY_PWRERR is not set
 #
 # File systems
 #
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/Kbuild kernel-power-2.6.28/drivers/dsp/bridge/Kbuild
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/Kbuild	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/Kbuild	1970-01-01 01:00:00.000000000 +0100
@@ -1,39 +0,0 @@
-obj-$(CONFIG_MPU_BRIDGE)	+= bridgedriver.o
-
-libgen = gen/gb.o gen/gt.o gen/gs.o gen/gh.o gen/_gt_para.o gen/uuidutil.o
-libservices = services/csl.o services/mem.o services/list.o services/dpc.o \
-               services/kfile.o services/sync.o \
-		services/clk.o services/cfg.o services/reg.o \
-               services/regsup.o services/ntfy.o \
-		services/dbg.o services/services.o
-libwmd = wmd/chnl_sm.o wmd/msg_sm.o wmd/io_sm.o wmd/tiomap3430.o \
-		wmd/tiomap3430_pwr.o wmd/tiomap_sm.o wmd/tiomap_io.o \
-		wmd/mmu_fault.o wmd/ue_deh.o
-libpmgr = pmgr/chnl.o pmgr/io.o pmgr/msg.o pmgr/cod.o pmgr/dev.o pmgr/wcd.o \
-		pmgr/dmm.o pmgr/cmm.o pmgr/dbll.o
-librmgr = rmgr/dbdcd.o rmgr/disp.o rmgr/drv.o rmgr/mgr.o rmgr/node.o \
-		rmgr/proc.o rmgr/pwr.o rmgr/rmm.o rmgr/strm.o rmgr/dspdrv.o \
-		rmgr/nldr.o rmgr/drv_interface.o
-libdload = dynload/cload.o dynload/getsection.o dynload/reloc.o
-libhw = hw/hw_prcm.o hw/hw_dspssC64P.o hw/hw_mmu.o hw/hw_mbox.o
-
-bridgedriver-objs = $(libgen) $(libservices) $(libwmd) $(libpmgr) $(librmgr) \
-			$(libdload) $(libhw)
-
-# Debug
-ifeq ($(CONFIG_BRIDGE_DEBUG),y)
-ccflags-y += -DGT_TRACE -DDEBUG
-endif
-
-#Machine dependent
-ccflags-y += -D_TI_ -D_DB_TIOMAP -DTMS32060 \
-		-DTICFG_PROC_VER -DTICFG_EVM_TYPE -DCHNL_SMCLASS \
-		-DCHNL_MESSAGES -DUSE_LEVEL_1_MACROS
-
-#Header files
-ccflags-y += -Idrivers/dsp/bridge/services
-ccflags-y += -Idrivers/dsp/bridge/wmd
-ccflags-y += -Idrivers/dsp/bridge/pmgr
-ccflags-y += -Idrivers/dsp/bridge/rmgr
-ccflags-y += -Idrivers/dsp/bridge/hw
-ccflags-y += -Iarch/arm
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/Kconfig kernel-power-2.6.28/drivers/dsp/bridge/Kconfig
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/Kconfig	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/Kconfig	2011-05-02 22:36:49.000000000 +0100
@@ -34,3 +34,14 @@ config BRIDGE_DEBUG
 	depends on MPU_BRIDGE
 	help
 	  Say Y to enable Bridge debugging capabilities
+
+comment "Bridge Notifications"
+	depends on MPU_BRIDGE
+
+config BRIDGE_NTFY_PWRERR
+	bool "Notify DSP Power Error"
+	depends on MPU_BRIDGE
+	help
+	  Enable notifications to registered clients on the event of power errror
+	  trying to suspend bridge driver. Say Y, to signal this event as a fatal
+	  error, this will require a bridge restart to recover.
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/Makefile kernel-power-2.6.28/drivers/dsp/bridge/Makefile
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/Makefile	2011-05-02 22:36:49.000000000 +0100
@@ -0,0 +1,39 @@
+obj-$(CONFIG_MPU_BRIDGE)	+= bridgedriver.o
+
+libgen = gen/gb.o gen/gt.o gen/gs.o gen/gh.o gen/_gt_para.o gen/uuidutil.o
+libservices = services/mem.o services/sync.o \
+		services/clk.o services/cfg.o services/reg.o \
+               services/regsup.o services/ntfy.o \
+		services/dbg.o services/services.o
+libwmd = wmd/chnl_sm.o wmd/msg_sm.o wmd/io_sm.o wmd/tiomap3430.o \
+		wmd/tiomap3430_pwr.o wmd/tiomap_sm.o wmd/tiomap_io.o \
+		wmd/mmu_fault.o wmd/ue_deh.o
+libpmgr = pmgr/chnl.o pmgr/io.o pmgr/msg.o pmgr/cod.o pmgr/dev.o pmgr/wcd.o \
+		pmgr/dmm.o pmgr/cmm.o pmgr/dbll.o
+librmgr = rmgr/dbdcd.o rmgr/disp.o rmgr/drv.o rmgr/mgr.o rmgr/node.o \
+		rmgr/proc.o rmgr/pwr.o rmgr/rmm.o rmgr/strm.o rmgr/dspdrv.o \
+		rmgr/nldr.o rmgr/drv_interface.o
+libdload = dynload/cload.o dynload/getsection.o dynload/reloc.o \
+		 dynload/tramp.o
+libhw = hw/hw_prcm.o hw/hw_dspssC64P.o hw/hw_mmu.o hw/hw_mbox.o
+
+bridgedriver-objs = $(libgen) $(libservices) $(libwmd) $(libpmgr) $(librmgr) \
+			$(libdload) $(libhw)
+
+# Debug
+ifeq ($(CONFIG_BRIDGE_DEBUG),y)
+ccflags-y += -DGT_TRACE
+endif
+
+#Machine dependent
+ccflags-y += -D_TI_ -D_DB_TIOMAP -DTMS32060 \
+		-DTICFG_PROC_VER -DTICFG_EVM_TYPE -DCHNL_SMCLASS \
+		-DCHNL_MESSAGES -DUSE_LEVEL_1_MACROS
+
+#Header files
+ccflags-y += -Idrivers/dsp/bridge/services
+ccflags-y += -Idrivers/dsp/bridge/wmd
+ccflags-y += -Idrivers/dsp/bridge/pmgr
+ccflags-y += -Idrivers/dsp/bridge/rmgr
+ccflags-y += -Idrivers/dsp/bridge/hw
+ccflags-y += -Iarch/arm
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/cload.c kernel-power-2.6.28/drivers/dsp/bridge/dynload/cload.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/cload.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/dynload/cload.c	2011-05-02 22:36:49.000000000 +0100
@@ -191,6 +191,8 @@ int Dynamic_Load_Module(struct Dynamic_L
 		symbol_table_free(&dl_state);
 		section_table_free(&dl_state);
 		string_table_free(&dl_state);
+		dload_tramp_cleanup(&dl_state);
+
 
 		if (dl_state.dload_errcount) {
 			Dynamic_Unload_Module(dl_state.myhandle, syms, alloc,
@@ -489,10 +491,14 @@ static void allocate_sections(struct dlo
 		DL_ERROR("Arg 3 (alloc) required but NULL", 0);
 		return;
 	}
-	/* allocate space for the module handle, which we will
-	 *	keep for unload purposes */
-	siz = dlthis->dfile_hdr.df_target_scns *
-	      sizeof(struct LDR_SECTION_INFO) + MY_HANDLE_SIZE;
+	/*
+	 * allocate space for the module handle, which we will keep for unload
+	 * purposes include an additional section store for an auto-generated
+	 * trampoline section in case we need it.
+	 */
+	siz = (dlthis->dfile_hdr.df_target_scns + 1) *
+		sizeof(struct LDR_SECTION_INFO) + MY_HANDLE_SIZE;
+
 	hndl = (struct my_handle *)dlthis->mysym->Allocate(dlthis->mysym, siz);
 	if (!hndl) {		/* not enough storage */
 		DL_ERROR(E_ALLOC, siz);
@@ -587,7 +593,7 @@ static void section_table_free(struct dl
  * big unsorted array.  We just read that array into memory in bulk.
  ************************************************************************/
 static const char S_STRINGTBL[] = { "string table" };
-void dload_strings(struct dload_state *dlthis, boolean sec_names_only)
+void dload_strings(struct dload_state *dlthis, bool sec_names_only)
 {
 	u32 ssiz;
 	char *strbuf;
@@ -707,11 +713,16 @@ static void dload_symbols(struct dload_s
 	if (s_count == 0)
 		return;
 
-	/* We keep a local symbol table for all of the symbols in the input.
+	/*
+	 * We keep a local symbol table for all of the symbols in the input.
 	 * This table contains only section & value info, as we do not have
 	 * to do any name processing for locals.  We reuse this storage
 	 * as a temporary for .dllview record construction.
-	 * Allocate storage for the whole table.*/
+	 * Allocate storage for the whole table.  Add 1 to the section count
+	 * in case a trampoline section is auto-generated as well as the
+	 * size of the trampoline section name so DLLView doens't get lost.
+	 */
+
 	siz = s_count * sizeof(struct Local_Symbol);
 	dsiz = DBG_HDR_SIZE +
 		(sizeof(struct dll_sect) * dlthis->allocated_secn_count) +
@@ -790,6 +801,12 @@ static void dload_symbols(struct dload_s
 					goto loop_cont;
 				}
 				val = delta = symp->value;
+#ifdef ENABLE_TRAMP_DEBUG
+				dload_syms_error(dlthis->mysym,
+						"===> ext sym [%s] at %x",
+						sname, val);
+#endif
+
 				goto loop_cont;
 			}
 			/* symbol defined by this module */
@@ -1045,9 +1062,11 @@ loopexit:
 #define MY_RELOC_BUF_SIZ 8
 /* careful! exists at the same time as the image buffer*/
 static int relocate_packet(struct dload_state *dlthis,
-			   struct image_packet_t *ipacket, u32 *checks)
+				struct image_packet_t *ipacket,
+				u32 *checks, bool *tramps_generated)
 {
 	u32 rnum;
+	*tramps_generated = false;
 
 	rnum = ipacket->i_num_relocs;
 	do {			/* all relocs */
@@ -1068,11 +1087,21 @@ static int relocate_packet(struct dload_
 		*checks += dload_checksum(rp, siz);
 		do {
 			/* perform the relocation operation */
-			dload_relocate(dlthis, (TgtAU_t *) ipacket->i_bits, rp);
+			dload_relocate(dlthis, (TgtAU_t *) ipacket->i_bits, rp,
+					tramps_generated, false);
 			rp += 1;
 			rnum -= 1;
 		} while ((rinbuf -= 1) > 0);
 	} while (rnum > 0);	/* all relocs */
+	/* If trampoline(s) were generated, we need to do an update of the
+	 * trampoline copy of the packet since a 2nd phase relo will be done
+	 * later.  */
+	if (*tramps_generated == true) {
+		dload_tramp_pkt_udpate(dlthis,
+				(dlthis->image_secn - dlthis->ldr_sections),
+				dlthis->image_offset, ipacket);
+	}
+
 	return 1;
 }				/* dload_read_reloc */
 
@@ -1097,7 +1126,7 @@ static void dload_data(struct dload_stat
 	struct doff_scnhdr_t *sptr = dlthis->sect_hdrs;
 	struct LDR_SECTION_INFO *lptr = dlthis->ldr_sections;
 #ifdef OPT_ZERO_COPY_LOADER
-	boolean bZeroCopy = false;
+	bool bZeroCopy = false;
 #endif
 	u8 *pDest;
 
@@ -1107,7 +1136,7 @@ static void dload_data(struct dload_stat
 	} ibuf;
 
 	/* Indicates whether CINIT processing has occurred */
-	boolean cinit_processed = false;
+	bool cinit_processed = false;
 
 	/* Loop through the sections and load them one at a time.
 	 */
@@ -1132,6 +1161,8 @@ static void dload_data(struct dload_stat
 
 				s32 ipsize;
 				u32 checks;
+				bool  tramp_generated = false;
+
 				/* get the fixed header bits */
 				if (dlthis->strm->read_buffer(dlthis->strm,
 				    &ibuf.ipacket, IPH_SIZE) != IPH_SIZE) {
@@ -1203,33 +1234,44 @@ static void dload_data(struct dload_stat
 				if (ibuf.ipacket.i_num_relocs) {
 					dlthis->image_offset = image_offset;
 					if (!relocate_packet(dlthis,
-					    &ibuf.ipacket, &checks))
+					    &ibuf.ipacket, &checks,
+					    &tramp_generated))
 						return;	/* serious error */
 				}
 				if (~checks)
 					DL_ERROR(E_CHECKSUM, IMAGEPAK);
-				/* stuff the result into target memory */
-				if (DLOAD_SECT_TYPE(sptr) == DLOAD_CINIT) {
-					cload_cinit(dlthis, &ibuf.ipacket);
-					cinit_processed = true;
-				} else {
+				/* Only write the result to the target if no
+				  * trampoline was generated.  Otherwise it
+				  *will be done during trampoline finalize.  */
+
+				if (tramp_generated == false) {
+
+					/* stuff the result into target
+					 * memory */
+					if (DLOAD_SECT_TYPE(sptr) ==
+					    DLOAD_CINIT) {
+						cload_cinit(dlthis,
+							&ibuf.ipacket);
+						cinit_processed = true;
+					} else {
 #ifdef OPT_ZERO_COPY_LOADER
-				    if (!bZeroCopy) {
+						if (!bZeroCopy) {
 #endif
-
-					if (!dlthis->myio->writemem
-					   (dlthis->myio, ibuf.bufr,
-					   lptr->load_addr + image_offset, lptr,
-					   BYTE_TO_HOST
-					   (ibuf.ipacket.i_packet_size))) {
-						DL_ERROR(
-						"Write to " FMT_UI32 " failed",
-						lptr->load_addr + image_offset);
-					}
+						if (!dlthis->myio->writemem
+						(dlthis->myio, ibuf.bufr,
+						lptr->load_addr + image_offset,
+						lptr, BYTE_TO_HOST
+						(ibuf.ipacket.i_packet_size))) {
+							DL_ERROR(
+							"Write to " FMT_UI32
+							" failed",
+							lptr->load_addr +
+							image_offset);
+						}
 #ifdef OPT_ZERO_COPY_LOADER
-				}
+					}
 #endif
-
+					}
 				}
 				image_offset +=
 				      BYTE_TO_TADDR(ibuf.ipacket.i_packet_size);
@@ -1281,6 +1323,12 @@ loop_cont:
 		sptr += 1;
 		lptr += 1;
 	}			/* load sections */
+
+	/*  Finalize any trampolines that were created during the load  */
+	if (dload_tramp_finalize(dlthis) == 0) {
+		DL_ERROR("Finalization of auto-trampolines (size = " FMT_UI32
+			") failed", dlthis->tramp.tramp_sect_next_addr);
+    }
 }				/* dload_data */
 
 /*************************************************************************
@@ -1475,10 +1523,6 @@ static char *copy_tgt_strings(void *dstp
 #if TARGET_AU_BITS <= BITS_PER_AU
 		/* byte-swapping issues may exist for strings on target */
 		*dst++ = *src++;
-#elif TARGET_ENDIANNESS_DIFFERS(TARGET_BIG_ENDIAN)
-		register TgtAU_t tmp;
-		tmp = *src++;
-		*dst++ = SWAP16BY8(tmp);  /* right for TARGET_AU_BITS == 16 */
 #else
 		*dst++ = *src++;
 #endif
@@ -1486,8 +1530,6 @@ static char *copy_tgt_strings(void *dstp
 	/*apply force to make sure that the string table has null terminator */
 #if (BITS_PER_AU == BITS_PER_BYTE) && (TARGET_AU_BITS == BITS_PER_BYTE)
 	dst[-1] = 0;
-#elif TARGET_BIG_ENDIAN
-	dst[-1] &= ~BYTE_MASK;	/*  big-endian */
 #else
 	dst[-1] &= (1 << (BITS_PER_AU - BITS_PER_BYTE)) - 1; /* little endian */
 #endif
@@ -1532,6 +1574,16 @@ static void init_module_handle(struct dl
 	hndl = dlthis->myhandle;
 	if (!hndl)
 		return;		/* must be errors detected, so forget it */
+
+	/*  Store the section count  */
+	hndl->secn_count = dlthis->allocated_secn_count;
+
+	/*  If a trampoline section was created, add it in  */
+	if (dlthis->tramp.tramp_sect_next_addr != 0)
+		hndl->secn_count += 1;
+
+	hndl->secn_count = hndl->secn_count << 1;
+
 	hndl->secn_count = dlthis->allocated_secn_count << 1;
 #ifndef TARGET_ENDIANNESS
 	if (dlthis->big_e_target)
@@ -1609,10 +1661,30 @@ static void init_module_handle(struct dl
 		dbsec += 1;
 		asecs += 1;
 	}
+
+	/*  If a trampoline section was created go ahead and add its info  */
+	if (dlthis->tramp.tramp_sect_next_addr != 0) {
+		dbmod->num_sects++;
+		dbsec->sect_load_adr = asecs->load_addr;
+		dbsec->sect_run_adr = asecs->run_addr;
+		dbsec++;
+		asecs++;
+	}
+
 	/* now cram in the names */
 	cp = copy_tgt_strings(dbsec, dlthis->str_head,
 			      dlthis->debug_string_size);
 
+
+	/* If a trampoline section was created, add its name so DLLView
+	 * can show the user the section info.  */
+	if (dlthis->tramp.tramp_sect_next_addr != 0) {
+		cp = copy_tgt_strings(cp,
+			dlthis->tramp.final_string_table,
+			strlen(dlthis->tramp.final_string_table) + 1);
+	}
+
+
 	/* round off the size of the debug record, and remember same */
 	hndl->dm.dbsiz = HOST_TO_TDATA_ROUND(cp - (char *)dbmod);
 	*cp = 0;		/* strictly to make our test harness happy */
@@ -1719,7 +1791,9 @@ int Dynamic_Unload_Module(DLOAD_mhandle 
 	if (!syms)
 		return 1;
 	syms->Purge_Symbol_Table(syms, (unsigned) hndl);
-	 /* Deallocate target memory for sections */
+	 /* Deallocate target memory for sections
+	  * NOTE: The trampoline section, if created, gets deleted here, too */
+
 	asecs = hndl->secns;
 	if (alloc)
 		for (curr_sect = (hndl->secn_count >> 1); curr_sect > 0;
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/dlclasses_hdr.h kernel-power-2.6.28/drivers/dsp/bridge/dynload/dlclasses_hdr.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/dlclasses_hdr.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/dynload/dlclasses_hdr.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-/*
- * dlclasses_hdr.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-
-#ifndef _DLCLASSES_HDR_H
-#define _DLCLASSES_HDR_H
-
-/*****************************************************************************
- *****************************************************************************
- *
- *                          DLCLASSES_HDR.H
- *
- * Sample classes in support of the dynamic loader
- *
- * These are just concrete derivations of the virtual ones in dynamic_loader.h
- * with a few additional interfaces for init, etc.
- *****************************************************************************
- *****************************************************************************/
-
-#include <dspbridge/dynamic_loader.h>
-
-#include "DLstream.h"
-#include "DLsymtab.h"
-#include "DLalloc.h"
-#include "DLinit.h"
-
-#endif				/* _DLCLASSES_HDR_H */
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/dload_internal.h kernel-power-2.6.28/drivers/dsp/bridge/dynload/dload_internal.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/dload_internal.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/dynload/dload_internal.h	2011-05-02 22:36:49.000000000 +0100
@@ -14,8 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-
 #ifndef __DLOAD_INTERNAL__
 #define __DLOAD_INTERNAL__
 
@@ -120,7 +118,103 @@ struct Local_Symbol {
 	s32 delta;	/* Original value in input file */
 	s16 secnn;		/* section number */
 	s16 sclass;		/* symbol class */
-} ;
+};
+
+
+/*
+ * Trampoline data structures
+ */
+#define TRAMP_NO_GEN_AVAIL              65535
+#define TRAMP_SYM_PREFIX                "__$dbTR__"
+#define TRAMP_SECT_NAME                 ".dbTR"
+#define TRAMP_SYM_PREFIX_LEN            9  /*  MUST MATCH THE LENGTH ABOVE!! */
+#define TRAMP_SYM_HEX_ASCII_LEN         9  /*  Includes NULL termination  */
+
+#define GET_CONTAINER(ptr, type, field) ((type *)((unsigned long)ptr -\
+				(unsigned long)(&((type *)0)->field)))
+#ifndef FIELD_OFFSET
+#define FIELD_OFFSET(type, field)       ((unsigned long)(&((type *)0)->field))
+#endif
+
+
+/*
+    The trampoline code for the target is located in a table called
+    "tramp_gen_info" with is indexed by looking up the index in the table
+    "tramp_map".  The tramp_map index is acquired using the target
+    HASH_FUNC on the relocation type that caused the trampoline.  Each
+    trampoline code table entry MUST follow this format:
+
+    |----------------------------------------------|
+    |  tramp_gen_code_hdr                          |
+    |----------------------------------------------|
+    |  Trampoline image code                       |
+    |  (the raw instruction code for the target)   |
+    |----------------------------------------------|
+    |  Relocation entries for the image code       |
+    |----------------------------------------------|
+
+    This is very similar to how image data is laid out in the DOFF file
+    itself.
+*/
+struct tramp_gen_code_hdr {
+	u32		tramp_code_size;    /*  in BYTES  */
+	u32		num_relos;
+	u32		relo_offset;   /*  in BYTES  */
+};
+
+struct tramp_img_pkt {
+	struct tramp_img_pkt	*next;    /*  MUST BE FIRST  */
+	u32		base;
+	struct tramp_gen_code_hdr	hdr;
+	u8		payload[VARIABLE_SIZE];
+};
+
+struct tramp_img_dup_relo {
+	struct tramp_img_dup_relo	*next;
+	struct reloc_record_t	relo;
+};
+
+struct tramp_img_dup_pkt {
+	struct tramp_img_dup_pkt  *next;    /*  MUST BE FIRST  */
+	s16		secnn;
+	u32		offset;
+	struct image_packet_t                img_pkt;
+	struct tramp_img_dup_relo            *relo_chain;
+
+	/*  PAYLOAD OF IMG PKT FOLLOWS  */
+};
+
+struct tramp_sym {
+	struct tramp_sym	*next;    /*  MUST BE FIRST  */
+	u32		index;
+	u32		str_index;
+	struct Local_Symbol sym_info;
+};
+
+struct tramp_string {
+	struct tramp_string	*next;    /*  MUST BE FIRST  */
+	u32	index;
+	char    str[VARIABLE_SIZE];    /*  NULL terminated  */
+};
+
+struct tramp_info {
+	u32		tramp_sect_next_addr;
+	struct LDR_SECTION_INFO	sect_info;
+
+	struct tramp_sym		*symbol_head;
+	struct tramp_sym		*symbol_tail;
+	u32		tramp_sym_next_index;
+	struct	Local_Symbol		*final_sym_table;
+
+	struct tramp_string                *string_head;
+	struct tramp_string                *string_tail;
+	u32		tramp_string_next_index;
+	u32		tramp_string_size;
+	char		*final_string_table;
+
+	struct tramp_img_pkt		*tramp_pkts;
+	struct tramp_img_dup_pkt	*dup_pkts;
+};
 
 /*
  * States of the .cinit state machine
@@ -187,6 +281,8 @@ struct dload_state {
 	struct doff_filehdr_t dfile_hdr;	/* DOFF file header structure */
 	struct doff_verify_rec_t verify;	/* Verify record */
 
+	struct tramp_info tramp;	/* Trampoline data, if needed  */
+
 	int relstkidx;		/* index into relocation value stack */
 	/* relocation value stack used in relexp.c */
 	RVALUE relstk[STATIC_EXPR_STK_SIZE];
@@ -206,7 +302,7 @@ extern void dload_error(struct dload_sta
 extern void dload_syms_error(struct Dynamic_Loader_Sym *syms,
 			     const char *errtxt, ...);
 extern void dload_headers(struct dload_state *dlthis);
-extern void dload_strings(struct dload_state *dlthis, boolean sec_names_only);
+extern void dload_strings(struct dload_state *dlthis, bool sec_names_only);
 extern void dload_sections(struct dload_state *dlthis);
 extern void dload_reorder(void *data, int dsiz, u32 map);
 extern u32 dload_checksum(void *data, unsigned siz);
@@ -226,7 +322,8 @@ extern uint32_t dload_reverse_checksum_1
  * exported by reloc.c
  */
 extern void dload_relocate(struct dload_state *dlthis, TgtAU_t *data,
-			   struct reloc_record_t *rp);
+			struct reloc_record_t *rp, bool *tramps_generated,
+			bool second_pass);
 
 extern RVALUE dload_unpack(struct dload_state *dlthis, TgtAU_t *data,
 			   int fieldsz, int offset, unsigned sgn);
@@ -234,4 +331,24 @@ extern RVALUE dload_unpack(struct dload_
 extern int dload_repack(struct dload_state *dlthis, RVALUE val, TgtAU_t *data,
 			int fieldsz, int offset, unsigned sgn);
 
+
+/*
+ * exported by tramp.c
+ */
+extern bool dload_tramp_avail(struct dload_state *dlthis,
+			struct reloc_record_t *rp);
+
+int dload_tramp_generate(struct dload_state *dlthis, s16 secnn,
+			u32 image_offset, struct image_packet_t *ipacket,
+			struct reloc_record_t *rp);
+
+extern int dload_tramp_pkt_udpate(struct dload_state *dlthis,
+			s16 secnn, u32 image_offset,
+			struct image_packet_t *ipacket);
+
+extern int dload_tramp_finalize(struct dload_state *dlthis);
+
+extern void dload_tramp_cleanup(struct dload_state *dlthis);
+
+
 #endif				/* __DLOAD_INTERNAL__ */
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/doff.h kernel-power-2.6.28/drivers/dsp/bridge/dynload/doff.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/doff.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/dynload/doff.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,13 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Structures & definitions used for dynamically loaded modules file format.
+ * This format is a reformatted version of COFF. It optimizes the layout for
+ * the dynamic loader.
+ *
+ * .dof files, when viewed as a sequence of 32-bit integers, look the same
+ * on big-endian and little-endian machines.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,16 +21,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*****************************************************************************/
-/*  DOFF.H - Structures & definitions used for dynamically                   */
-/*           loaded modules file format.  This format is a reformatted       */
-/*           version of COFF.(see coff.h for details)  It optimizes the      */
-/*           layout for the dynamic loader.                                  */
-/*                                                                           */
-/*  .dof files, when viewed as a sequence of 32-bit integers, look the same  */
-/*  on big-endian and little-endian machines.                                */
-/*****************************************************************************/
 #ifndef _DOFF_H
 #define _DOFF_H
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/getsection.c kernel-power-2.6.28/drivers/dsp/bridge/dynload/getsection.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/getsection.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/dynload/getsection.c	2011-05-02 22:36:49.000000000 +0100
@@ -14,8 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-
 #include <dspbridge/getsection.h>
 #include "header.h"
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/header.h kernel-power-2.6.28/drivers/dsp/bridge/dynload/header.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/header.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/dynload/header.h	2011-05-02 22:36:49.000000000 +0100
@@ -14,8 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-
 #define TRUE 1
 #define FALSE 0
 #ifndef NULL
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/module_list.h kernel-power-2.6.28/drivers/dsp/bridge/dynload/module_list.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/module_list.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/dynload/module_list.h	2011-05-02 22:36:49.000000000 +0100
@@ -14,50 +14,44 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*============================================================================
- Filename:     module_list.h
-
- Copyright (C) 2002 Texas Instruments Incorporated
-
-
- This C header file gives the layout of the data structure created by the
- dynamic loader to describe the set of modules loaded into the DSP.
-
- Linked List Structure:
- ----------------------
- The data structure defined here is a singly-linked list.  The list
- represents the set of modules which are currently loaded in the DSP memory.
- The first entry in the list is a header record which contains a flag
- representing the state of the list.  The rest of the entries in the list
- are module records.
-
- Global symbol  _DLModules designates the first record in the list (i.e. the
- header record).  This symbol must be defined in any program that wishes to
- use DLLview plug-in.
-
- String Representation:
- ----------------------
- The string names of the module and its sections are stored in a block of
- memory which follows the module record itself.  The strings are ordered:
- module name first, followed by section names in order from the first
- section to the last.  String names are tightly packed arrays of 8-bit
- characters (two characters per 16-bit word on the C55x).  Strings are
- zero-byte-terminated.
-
- Creating and updating the list:
--------------------------------
- Upon loading a new module into the DSP memory the dynamic loader inserts a
-new module record as the first module record in the list.  The fields of
- this module record are initialized to reflect the properties of the module.
- The dynamic loader does NOT increment the flag/counter in the list's header
- record.
-
- Upon unloading a module from the DSP memory the dynamic loader removes the
-module's record from this list.  The dynamic loader also increments the
- flag/counter in the list's header record to indicate that the list has been
- changed.
-
-============================================================================*/
+/*
+ * This C header file gives the layout of the data structure created by the
+ * dynamic loader to describe the set of modules loaded into the DSP.
+ *
+ * Linked List Structure:
+ * ----------------------
+ * The data structure defined here is a singly-linked list.  The list
+ * represents the set of modules which are currently loaded in the DSP memory.
+ * The first entry in the list is a header record which contains a flag
+ * representing the state of the list.  The rest of the entries in the list
+ * are module records.
+ *
+ * Global symbol  _DLModules designates the first record in the list (i.e. the
+ * header record).  This symbol must be defined in any program that wishes to
+ * use DLLview plug-in.
+ *
+ * String Representation:
+ * ----------------------
+ * The string names of the module and its sections are stored in a block of
+ * memory which follows the module record itself.  The strings are ordered:
+ * module name first, followed by section names in order from the first
+ * section to the last.  String names are tightly packed arrays of 8-bit
+ * characters (two characters per 16-bit word on the C55x).  Strings are
+ * zero-byte-terminated.
+ *
+ * Creating and updating the list:
+ * -------------------------------
+ * Upon loading a new module into the DSP memory the dynamic loader inserts a
+ * new module record as the first module record in the list.  The fields of
+ * this module record are initialized to reflect the properties of the module.
+ * The dynamic loader does NOT increment the flag/counter in the list's header
+ * record.
+ *
+ * Upon unloading a module from the DSP memory the dynamic loader removes the
+ * module's record from this list.  The dynamic loader also increments the
+ * flag/counter in the list's header record to indicate that the list has been
+ * changed.
+ */
 
 #ifndef _MODULE_LIST_H_
 #define _MODULE_LIST_H_
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/params.h kernel-power-2.6.28/drivers/dsp/bridge/dynload/params.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/params.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/dynload/params.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,15 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This file defines host and target properties for all machines
+ * supported by the dynamic loader.  To be tedious...
+ *
+ * host: the machine on which the dynamic loader runs
+ * target: the machine that the dynamic loader is loading
+ *
+ * Host and target may or may not be the same, depending upon the particular
+ * use.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,26 +23,9 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-
-/******************************************************************************
- *
- * This file defines host and target properties for all machines
- * supported by the dynamic loader.  To be tedious...
- *
- *		host == the machine on which the dynamic loader runs
- *		target == the machine that the dynamic loader is loading
- *
- * Host and target may or may not be the same, depending upon the particular
- * use.
- *****************************************************************************/
-
-/******************************************************************************
- *
- *							Host Properties
- *
- *****************************************************************************/
-
+/*
+ * Host Properties
+ */
 #define BITS_PER_BYTE 8		/* bits in the standard PC/SUN byte */
 #define LOG_BITS_PER_BYTE 3	/* log base 2 of same */
 #define BYTE_MASK ((1U<<BITS_PER_BYTE)-1)
@@ -57,12 +49,9 @@
 
 /* !! don't be tempted to insert type definitions here; use <stdint.h> !! */
 
-/******************************************************************************
- *
- *							Target Properties
- *
- *****************************************************************************/
-
+/*
+ * Target Properties
+ */
 
 /*--------------------------------------------------------------------------*/
 /* TMS320C6x Target Specific Parameters (byte-addressable)                  */
@@ -122,9 +111,7 @@
 #endif
 
 /*
- *
  * Useful properties and conversions derived from the above
- *
  */
 
 /*
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/reloc.c kernel-power-2.6.28/drivers/dsp/bridge/dynload/reloc.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/reloc.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/dynload/reloc.c	2011-05-02 22:36:49.000000000 +0100
@@ -163,10 +163,10 @@ static const u8 C60_Scale[SCALE_MASK+1] 
  *	Performs the specified relocation operation
  **************************************************************************/
 void dload_relocate(struct dload_state *dlthis, TgtAU_t *data,
-		    struct reloc_record_t *rp)
+			struct reloc_record_t *rp, bool *tramps_genereted,
+			bool second_pass)
 {
-	RVALUE val = 0;
-	RVALUE reloc_amt = 0;
+	RVALUE val, reloc_amt, orig_val = 0;
 	unsigned int fieldsz = 0;
 	unsigned int offset = 0;
 	unsigned int reloc_info = 0;
@@ -178,26 +178,39 @@ void dload_relocate(struct dload_state *
 #ifdef RFV_SCALE
 	unsigned int scale = 0;
 #endif
+	struct image_packet_t *img_pkt = NULL;
+
+	/* The image packet data struct is only used during first pass
+	  * relocation in the event that a trampoline is needed.  2nd pass
+	  * relocation doesn't guarantee that data is coming from an
+	  * image_packet_t structure. See cload.c, dload_data for how i_bits is
+	  * set. If that changes this needs to be updated!!!  */
+	if (second_pass == false)
+		img_pkt = (struct image_packet_t *)((u8 *)data -
+				sizeof(struct image_packet_t));
+
 
 	rx = HASH_FUNC(rp->r_type);
 	while (rop_map1[rx] != rp->r_type) {
 		rx = HASH_L(rop_map2[rx]);
 		if (rx < 0) {
 #if TMS32060
-		switch (rp->r_type) {
-		case R_C60ALIGN:
-		case R_C60NOCMP:
-		case R_C60FPHEAD:
-		    /* Ignore these reloc types and return */
-		    break;
-		default:
-		    /* Unknown reloc type, print error and return */
-		    dload_error(dlthis, "Bad coff operator 0x%x", rp->r_type);
-	    }
+			switch (rp->r_type) {
+			case R_C60ALIGN:
+			case R_C60NOCMP:
+			case R_C60FPHEAD:
+				/* Ignore these reloc types and return */
+				break;
+			default:
+				/* Unknown reloc type, print error and return */
+				dload_error(dlthis, "Bad coff operator 0x%x",
+						rp->r_type);
+			}
 #else
-	    dload_error(dlthis, "Bad coff operator 0x%x", rp->r_type);
+			dload_error(dlthis, "Bad coff operator 0x%x",
+					rp->r_type);
 #endif
-	    return;
+			return;
 		}
 	}
 	rx = HASH_I(rop_map2[rx]);
@@ -205,22 +218,29 @@ void dload_relocate(struct dload_state *
 	   && (rx < (sizeof(rop_info)/sizeof(uint_least16_t))) && (rx > 0)) {
 		reloc_action = rop_action[rx]; reloc_info = rop_info[rx];
 	} else {
-	    dload_error(dlthis, "Buffer Overflow - Array Index Out of Bounds");
+		dload_error(dlthis, "Buffer Overflow - Array Index Out "
+				"of Bounds");
 	}
 
 	/* Compute the relocation amount for the referenced symbol, if any */
 	reloc_amt = rp->r_uval;
 	if (RFV_SYM(reloc_info)) {	/* relocation uses a symbol reference */
-		if ((u32)rp->r_symndx < dlthis->dfile_hdr.df_no_syms) {
-			/* real symbol reference */
-			svp = &dlthis->local_symtab[rp->r_symndx];
-			reloc_amt = (RFV_SYM(reloc_info) == ROP_SYMD) ?
-				    svp->delta : svp->value;
+		/* If this is first pass, use the module local symbol table,
+		  * else use the trampoline symbol table.  */
+	       if (second_pass == false) {
+			if ((u32)rp->r_symndx < dlthis->dfile_hdr.df_no_syms) {
+				/* real symbol reference */
+				svp = &dlthis->local_symtab[rp->r_symndx];
+				reloc_amt = (RFV_SYM(reloc_info) == ROP_SYMD) ?
+					    svp->delta : svp->value;
+			}
+			/* reloc references current section */
+			else if (rp->r_symndx == -1) {
+				reloc_amt = (RFV_SYM(reloc_info) == ROP_SYMD) ?
+				dlthis->delta_runaddr :
+				dlthis->image_secn->run_addr;
+			}
 		}
-		/* reloc references current section */
-		else if (rp->r_symndx == -1)
-			reloc_amt = (RFV_SYM(reloc_info) == ROP_SYMD) ?
-			  dlthis->delta_runaddr : dlthis->image_secn->run_addr;
 	}	/* relocation uses a symbol reference */
 	/* Handle stack adjustment */
 	val = 0;
@@ -277,6 +297,10 @@ void dload_relocate(struct dload_state *
 	if (reloc_info & ROP_R) {    /* relocation reads current image value */
 		val = dload_unpack(dlthis, data, fieldsz, offset,
 		      RFV_SIGN(reloc_info));
+	/* Save off the original value in case the relo overflows and
+	  * we can trampoline it.  */
+	orig_val = val;
+
 #ifdef RFV_SCALE
 		val <<= scale;
 #endif
@@ -414,10 +438,38 @@ void dload_relocate(struct dload_state *
 #endif
 		if (dload_repack(dlthis, val, data, fieldsz, offset,
 		   RFV_SIGN(reloc_info))) {
-			dload_error(dlthis, "Relocation value " FMT_UI32
-			    " overflows %d bits in %s offset " FMT_UI32, val,
-			    fieldsz, dlthis->image_secn->name,
-			    dlthis->image_offset + rp->r_vaddr);
+			/* Check to see if this relo can be trampolined,
+			  * but only in first phase relocation.  2nd phase
+			  * relocation cannot trampoline.  */
+			if ((second_pass == false) &&
+				(dload_tramp_avail(dlthis, rp) == true)) {
+
+				/* Before generating the trampoline, restore
+				  * the value to its original so the 2nd pass
+				  *  relo will work.  */
+				dload_repack(dlthis, orig_val, data, fieldsz,
+					offset, RFV_SIGN(reloc_info));
+				if (!dload_tramp_generate(dlthis,
+					(dlthis->image_secn - dlthis->
+					ldr_sections), dlthis->image_offset,
+					img_pkt, rp)) {
+					dload_error(dlthis, "Failed to "
+					     "generate trampoline for bit "
+					     "overflow");
+					dload_error(dlthis, "Relocation value "
+					   FMT_UI32 " overflows %d bits in %s "
+					   "offset " FMT_UI32, val, fieldsz,
+					   dlthis->image_secn->name,
+					   dlthis->image_offset + rp->r_vaddr);
+				} else
+					*tramps_genereted = true;
+			} else {
+				dload_error(dlthis, "Relocation value "
+					FMT_UI32 " overflows %d bits in %s"
+					" offset " FMT_UI32, val, fieldsz,
+					dlthis->image_secn->name,
+					dlthis->image_offset + rp->r_vaddr);
+			}
 		}
 	} else if (top)
 		*stackp = val;
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/reloc_table.h kernel-power-2.6.28/drivers/dsp/bridge/dynload/reloc_table.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/reloc_table.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/dynload/reloc_table.h	2011-05-02 22:36:49.000000000 +0100
@@ -14,8 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-
 #ifndef __RELOC_TABLE_H__
 #define __RELOC_TABLE_H__
 /*
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/reloc_table_c6000.c kernel-power-2.6.28/drivers/dsp/bridge/dynload/reloc_table_c6000.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/reloc_table_c6000.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/dynload/reloc_table_c6000.c	2011-04-17 20:03:04.000000000 +0100
@@ -14,7 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
 /* Tables generated for c6000 */
 
 #define HASH_FUNC(zz) (((((zz) + 1) * UINT32_C(1845)) >> 11) & 63)
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/tramp.c kernel-power-2.6.28/drivers/dsp/bridge/dynload/tramp.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/tramp.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/dynload/tramp.c	2011-05-02 22:36:49.000000000 +0100
@@ -0,0 +1,1118 @@
+/*
+ * tramp.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include "header.h"
+
+#if TMS32060
+#include "tramp_table_c6000.c"
+#endif
+
+#define MAX_RELOS_PER_PASS	4
+
+/*
+ * Function:	priv_tramp_sect_tgt_alloc
+ * Description: Allocate target memory for the trampoline section.  The
+ *	  target mem size is easily obtained as the next available address.
+ */
+static int priv_tramp_sect_tgt_alloc(struct dload_state *dlthis)
+{
+	int ret_val = 0;
+	struct LDR_SECTION_INFO	*sect_info;
+
+	/*  Populate the trampoline loader section and allocate it on the
+	 * target.  The section name is ALWAYS the first string in the final
+	 * string table for trampolines.  The trampoline section is always
+	 * 1 beyond the total number of allocated sections.  */
+	sect_info = &dlthis->ldr_sections[dlthis->allocated_secn_count];
+
+	sect_info->name = dlthis->tramp.final_string_table;
+	sect_info->size = dlthis->tramp.tramp_sect_next_addr;
+	sect_info->context = 0;
+	sect_info->type =
+		(4 << 8) | DLOAD_TEXT | DS_ALLOCATE_MASK | DS_DOWNLOAD_MASK;
+	sect_info->page = 0;
+	sect_info->run_addr = 0;
+	sect_info->load_addr = 0;
+	ret_val = dlthis->myalloc->Allocate(dlthis->myalloc,
+			sect_info, DS_ALIGNMENT(sect_info->type));
+
+	if (ret_val == 0)
+		dload_error(dlthis, "Failed to allocate target memory for"
+							" trampoline");
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_h2a
+ * Description: Helper function to convert a hex value to its ASCII
+ *	  representation.  Used for trampoline symbol name generation.
+ */
+static u8 priv_h2a(u8 value)
+{
+	if (value > 0xF)
+		return 0xFF;
+
+	if (value <= 9)
+		value += 0x30;
+	else
+		value += 0x37;
+
+	return value;
+}
+
+/*
+ * Function:	priv_tramp_sym_gen_name
+ * Description: Generate a trampoline symbol name (ASCII) using the value
+ *	  of the symbol.  This places the new name into the user buffer.
+ *	  The name is fixed in length and of the form: __$dbTR__xxxxxxxx
+ *	  (where "xxxxxxxx" is the hex value.
+ */
+static void priv_tramp_sym_gen_name(u32 value, char *dst)
+{
+	u32 i;
+	volatile char *prefix = TRAMP_SYM_PREFIX;
+	volatile char *dst_local = dst;
+	u8 tmp;
+
+	/*  Clear out the destination, including the ending NULL  */
+	for (i = 0; i < (TRAMP_SYM_PREFIX_LEN + TRAMP_SYM_HEX_ASCII_LEN); i++)
+		*(dst_local + i) = 0;
+
+	/*  Copy the prefix to start  */
+	for (i = 0; i < strlen(TRAMP_SYM_PREFIX); i++) {
+		*dst_local = *(prefix + i);
+		dst_local++;
+	}
+
+	/*  Now convert the value passed in to a string equiv of the hex  */
+	for (i = 0; i < sizeof(value); i++) {
+#ifndef _BIG_ENDIAN
+		tmp = *(((u8 *)&value) + (sizeof(value) - 1) - i);
+		*dst_local = priv_h2a((tmp & 0xF0) >> 4);
+		dst_local++;
+		*dst_local = priv_h2a(tmp & 0x0F);
+		dst_local++;
+#else
+		tmp = *(((u8 *)&value) + i);
+		*dst_local = priv_h2a((tmp & 0xF0) >> 4);
+		dst_local++;
+		*dst_local = priv_h2a(tmp & 0x0F);
+		dst_local++;
+#endif
+	}
+
+	/*  NULL terminate  */
+	*dst_local = 0;
+}
+
+/*
+ * Function:	priv_tramp_string_create
+ * Description: Create a new string specific to the trampoline loading and add
+ *	  it to the trampoline string list.  This list contains the
+ *	  trampoline section name and trampoline point symbols.
+ */
+static struct tramp_string *priv_tramp_string_create(struct dload_state *dlthis,
+	  u32 str_len, char *str)
+{
+	struct tramp_string *new_string = NULL;
+	u32 i;
+
+	/*  Create a new string object with the specified size.  */
+	new_string = (struct tramp_string *)dlthis->mysym->Allocate(
+		dlthis->mysym, (sizeof(struct tramp_string) + str_len + 1));
+	if (new_string != NULL) {
+		/*  Clear the string first.  This ensures the ending NULL is
+		 * present and the optimizer won't touch it.  */
+		for (i = 0; i < (sizeof(struct tramp_string) + str_len + 1);
+				i++)
+			*((u8 *)new_string + i) = 0;
+
+		/*  Add this string to our virtual table by assigning it the
+		 * next index and pushing it to the tail of the list.  */
+		new_string->index = dlthis->tramp.tramp_string_next_index;
+		dlthis->tramp.tramp_string_next_index++;
+		dlthis->tramp.tramp_string_size += str_len + 1;
+
+		new_string->next = NULL;
+		if (dlthis->tramp.string_head == NULL)
+			dlthis->tramp.string_head = new_string;
+		else
+			dlthis->tramp.string_tail->next = new_string;
+
+		dlthis->tramp.string_tail = new_string;
+
+		/*  Copy the string over to the new object  */
+		for (i = 0; i < str_len; i++)
+			new_string->str[i] = str[i];
+	}
+
+	return new_string;
+}
+
+/*
+ * Function:	priv_tramp_string_find
+ * Description: Walk the trampoline string list and find a match for the
+ *	  provided string.  If not match is found, NULL is returned.
+ */
+static struct tramp_string *priv_tramp_string_find(struct dload_state *dlthis,
+								char *str)
+{
+	struct tramp_string *cur_str = NULL;
+	struct tramp_string *ret_val = NULL;
+	u32 i;
+	u32 str_len = strlen(str);
+
+	for (cur_str = dlthis->tramp.string_head;
+		 (ret_val == NULL) && (cur_str != NULL);
+		 cur_str = cur_str->next) {
+		/*  If the string lengths aren't equal, don't bother
+		 * comparing  */
+		if (str_len != strlen(cur_str->str))
+			continue;
+
+		/*  Walk the strings until one of them ends  */
+		for (i = 0; i < str_len; i++) {
+			/*  If they don't match in the current position then
+			 * break out now, no sense in continuing to look at
+			 * this string.  */
+			if (str[i] != cur_str->str[i])
+				break;
+		}
+
+		if (i == str_len)
+			ret_val = cur_str;
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_string_tbl_finalize
+ * Description: Flatten the trampoline string list into a table of NULL
+ *	  terminated strings.  This is the same format of string table
+ *	  as used by the COFF/DOFF file.
+ */
+static int priv_string_tbl_finalize(struct dload_state *dlthis)
+{
+	int ret_val = 0;
+	struct tramp_string *cur_string;
+	char *cur_loc;
+	char *tmp;
+
+	/*  Allocate enough space for all strings that have been created.  The
+	 * table is simply all strings concatenated together will NULL
+	 * endings.  */
+	dlthis->tramp.final_string_table =
+		(char *)dlthis->mysym->Allocate(dlthis->mysym,
+					dlthis->tramp.tramp_string_size);
+	if (dlthis->tramp.final_string_table != NULL) {
+		/*  We got our buffer, walk the list and release the nodes as*
+		 * we go  */
+		cur_loc = dlthis->tramp.final_string_table;
+		cur_string = dlthis->tramp.string_head;
+		while (cur_string != NULL) {
+			/*  Move the head/tail pointers  */
+			dlthis->tramp.string_head = cur_string->next;
+			if (dlthis->tramp.string_tail == cur_string)
+				dlthis->tramp.string_tail = NULL;
+
+			/*  Copy the string contents  */
+			for (tmp = cur_string->str;
+				 *tmp != '\0';
+				 tmp++, cur_loc++)
+				*cur_loc = *tmp;
+
+			/*  Pick up the NULL termination since it was missed by
+			 * breaking using it to end the above loop.  */
+			*cur_loc = '\0';
+			cur_loc++;
+
+			/*  Free the string node, we don't need it any more. */
+			dlthis->mysym->Deallocate(dlthis->mysym, cur_string);
+
+			/*  Move our pointer to the next one  */
+			cur_string = dlthis->tramp.string_head;
+		}
+
+		/*  Update our return value to success  */
+		ret_val = 1;
+	} else
+		dload_error(dlthis, "Failed to allocate trampoline "
+						"string table");
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_tramp_sect_alloc
+ * Description: Virtually allocate space from the trampoline section.  This
+ *	  function returns the next offset within the trampoline section
+ *	  that is available and moved the next available offset by the
+ *	  requested size.  NO TARGET ALLOCATION IS DONE AT THIS TIME.
+ */
+static u32 priv_tramp_sect_alloc(struct dload_state *dlthis, u32 tramp_size)
+{
+	u32 ret_val;
+
+	/*  If the next available address is 0, this is our first allocation.
+	 * Create a section name string to go into the string table .  */
+	if (dlthis->tramp.tramp_sect_next_addr == 0) {
+		dload_syms_error(dlthis->mysym, "*** WARNING ***  created "
+			"dynamic TRAMPOLINE section for module %s",
+			dlthis->str_head);
+	}
+
+	/*  Reserve space for the new trampoline  */
+	ret_val = dlthis->tramp.tramp_sect_next_addr;
+	dlthis->tramp.tramp_sect_next_addr += tramp_size;
+	return ret_val;
+}
+
+/*
+ * Function:	priv_tramp_sym_create
+ * Description: Allocate and create a new trampoline specific symbol and add
+ *	  it to the trampoline symbol list.  These symbols will include
+ *	  trampoline points as well as the external symbols they
+ *	  reference.
+ */
+static struct tramp_sym *priv_tramp_sym_create(struct dload_state *dlthis,
+			u32 str_index, struct Local_Symbol *tmp_sym)
+{
+	struct tramp_sym	*new_sym = NULL;
+	u32 i;
+
+	/*  Allocate new space for the symbol in the symbol table.  */
+	new_sym = (struct tramp_sym *)dlthis->mysym->Allocate(dlthis->mysym,
+						   sizeof(struct tramp_sym));
+	if (new_sym != NULL) {
+		for (i = 0; i != sizeof(struct tramp_sym); i++)
+			*((char *)new_sym + i) = 0;
+
+		/*  Assign this symbol the next symbol index for easier
+		 * reference later during relocation.  */
+		new_sym->index = dlthis->tramp.tramp_sym_next_index;
+		dlthis->tramp.tramp_sym_next_index++;
+
+		/*  Populate the symbol information.  At this point any
+		 * trampoline symbols will be the offset location, not the
+		 * final.  Copy over the symbol info to start, then be sure to
+		 * get the string index from the trampoline string table.  */
+		new_sym->sym_info = *tmp_sym;
+		new_sym->str_index = str_index;
+
+		/*  Push the new symbol to the tail of the symbol table list  */
+		new_sym->next = NULL;
+		if (dlthis->tramp.symbol_head == NULL)
+			dlthis->tramp.symbol_head = new_sym;
+		else
+			dlthis->tramp.symbol_tail->next = new_sym;
+
+		dlthis->tramp.symbol_tail = new_sym;
+	}
+
+	return new_sym;
+}
+
+/*
+ * Function:	priv_tramp_sym_get
+ * Description: Search for the symbol with the matching string index (from
+ *	  the trampoline string table) and return the trampoline
+ *	  symbol object, if found.  Otherwise return NULL.
+ */
+static struct tramp_sym *priv_tramp_sym_get(struct dload_state *dlthis,
+						 u32 string_index)
+{
+	struct tramp_sym *sym_found = NULL;
+
+	/*  Walk the symbol table list and search vs. the string index  */
+	for (sym_found = dlthis->tramp.symbol_head;
+		 sym_found != NULL;
+		 sym_found = sym_found->next) {
+		if (sym_found->str_index == string_index)
+			break;
+	}
+
+	return sym_found;
+}
+
+/*
+ * Function:	priv_tramp_sym_find
+ * Description: Search for a trampoline symbol based on the string name of
+ *	  the symbol.  Return the symbol object, if found, otherwise
+ *	  return NULL.
+ */
+static struct tramp_sym *priv_tramp_sym_find(struct dload_state *dlthis,
+							char *string)
+{
+	struct tramp_sym *sym_found = NULL;
+	struct tramp_string *str_found = NULL;
+
+	/*  First, search for the string, then search for the sym based on the
+		string index.  */
+	str_found = priv_tramp_string_find(dlthis, string);
+	if (str_found != NULL)
+		sym_found = priv_tramp_sym_get(dlthis, str_found->index);
+
+	return sym_found;
+}
+
+/*
+ * Function:	priv_tramp_sym_finalize
+ * Description: Allocate a flat symbol table for the trampoline section,
+ *	  put each trampoline symbol into the table, adjust the
+ *	  symbol value based on the section address on the target and
+ *	  free the trampoline symbol list nodes.
+ */
+static int priv_tramp_sym_finalize(struct dload_state *dlthis)
+{
+	int ret_val = 0;
+	struct tramp_sym *cur_sym;
+	struct LDR_SECTION_INFO *tramp_sect =
+		&dlthis->ldr_sections[dlthis->allocated_secn_count];
+	struct Local_Symbol *new_sym;
+
+	/*  Allocate a table to hold a flattened version of all symbols
+	 * created.  */
+	dlthis->tramp.final_sym_table =
+		(struct Local_Symbol *)dlthis->mysym->Allocate(
+			dlthis->mysym, (sizeof(struct Local_Symbol) *
+			dlthis->tramp.tramp_sym_next_index));
+	if (dlthis->tramp.final_sym_table != NULL) {
+		/*  Walk the list of all symbols, copy it over to the flattened
+		 * table. After it has been copied, the node can be freed as
+		 * it is no longer needed.  */
+		new_sym = dlthis->tramp.final_sym_table;
+		cur_sym = dlthis->tramp.symbol_head;
+		while (cur_sym != NULL) {
+			/*  Pop it off the list  */
+			dlthis->tramp.symbol_head = cur_sym->next;
+			if (cur_sym == dlthis->tramp.symbol_tail)
+				dlthis->tramp.symbol_tail = NULL;
+
+			/*  Copy the symbol contents into the flat table  */
+			*new_sym = cur_sym->sym_info;
+
+			/*  Now finaize the symbol.  If it is in the tramp
+			 * section, we need to adjust for the section start.
+			 * If it is external then we don't need to adjust at
+			 * all.
+			 * NOTE: THIS CODE ASSUMES THAT THE TRAMPOLINE IS
+			 * REFERENCED LIKE A CALL TO AN EXTERNAL SO VALUE AND
+			 * DELTA ARE THE SAME.  SEE THE FUNCTION dload_symbols
+			 * WHERE DN_UNDEF IS HANDLED FOR MORE REFERENCE.  */
+			if (new_sym->secnn < 0) {
+				new_sym->value += tramp_sect->load_addr;
+				new_sym->delta = new_sym->value;
+			}
+
+			/*  Let go of the symbol node  */
+			dlthis->mysym->Deallocate(dlthis->mysym, cur_sym);
+
+			/*  Move to the next node  */
+			cur_sym = dlthis->tramp.symbol_head;
+			new_sym++;
+		}
+
+		ret_val = 1;
+	} else
+		dload_error(dlthis, "Failed to alloc trampoline sym table");
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_tgt_img_gen
+ * Description: Allocate storage for and copy the target specific image data
+ *	and fix up its relocations for the new external symbol.  If
+ *	a trampoline image packet was successfully created it is added
+ *	to the trampoline list.
+ */
+static int priv_tgt_img_gen(struct dload_state *dlthis, u32 base,
+		u32 gen_index, struct tramp_sym *new_ext_sym)
+{
+	struct tramp_img_pkt *new_img_pkt = NULL;
+	u32 i;
+	u32 pkt_size = tramp_img_pkt_size_get();
+	u8 *gen_tbl_entry;
+	u8 *pkt_data;
+	struct reloc_record_t *cur_relo;
+	int ret_val = 0;
+
+	/*  Allocate a new image packet and set it up.  */
+	new_img_pkt =
+		(struct tramp_img_pkt *)dlthis->mysym->Allocate(dlthis->mysym,
+								 pkt_size);
+	if (new_img_pkt != NULL) {
+		/*  Save the base, this is where it goes in the section  */
+		new_img_pkt->base = base;
+
+		/*  Copy over the image data and relos from the target table */
+		pkt_data = (u8 *)&new_img_pkt->hdr;
+		gen_tbl_entry = (u8 *)&tramp_gen_info[gen_index];
+		for (i = 0; i < pkt_size; i++) {
+			*pkt_data = *gen_tbl_entry;
+			pkt_data++;
+			gen_tbl_entry++;
+		}
+
+		/*  Update the relocations to point to the external symbol  */
+		cur_relo =
+			(struct reloc_record_t *)((u8 *)&new_img_pkt->hdr +
+					   new_img_pkt->hdr.relo_offset);
+		for (i = 0; i < new_img_pkt->hdr.num_relos; i++)
+			cur_relo[i].r_symndx = new_ext_sym->index;
+
+		/*  Add it to the trampoline list.  */
+		new_img_pkt->next = dlthis->tramp.tramp_pkts;
+		dlthis->tramp.tramp_pkts = new_img_pkt;
+
+		ret_val = 1;
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_pkt_relo
+ * Description: Take the provided image data and the collection of relocations
+ *	  for it and perform the relocations.  Note that all relocations
+ *	  at this stage are considered SECOND PASS since the original
+ *	  image has already been processed in the first pass.  This means
+ *	  TRAMPOLINES ARE TREATED AS 2ND PASS even though this is really
+ *	  the first (and only) relocation that will be performed on them.
+ */
+static int priv_pkt_relo(struct dload_state *dlthis, TgtAU_t *data,
+			 struct reloc_record_t *rp[], u32 relo_count)
+{
+	int ret_val = 1;
+	u32 i;
+	bool tmp;
+
+	/*  Walk through all of the relos and process them.  This function is
+	 * the equivalent of relocate_packet() from cload.c, but specialized
+	 * for trampolines and 2nd phase relocations.  */
+	for (i = 0; i < relo_count; i++)
+		dload_relocate(dlthis, data, rp[i], &tmp, true);
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_tramp_pkt_finalize
+ * Description: Walk the list of all trampoline packets and finalize them.
+ *	  Each trampoline image packet will be relocated now that the
+ *	  trampoline section has been allocated on the target.  Once
+ *	  all of the relocations are done the trampoline image data
+ *	  is written into target memory and the trampoline packet
+ *	  is freed: it is no longer needed after this point.
+ */
+static int priv_tramp_pkt_finalize(struct dload_state *dlthis)
+{
+	int ret_val = 1;
+	struct tramp_img_pkt *cur_pkt = NULL;
+	struct reloc_record_t *relos[MAX_RELOS_PER_PASS];
+	u32 relos_done;
+	u32 i;
+	struct reloc_record_t *cur_relo;
+	struct LDR_SECTION_INFO *sect_info =
+		&dlthis->ldr_sections[dlthis->allocated_secn_count];
+
+	/*  Walk the list of trampoline packets and relocate each packet.  This
+	 * function is the trampoline equivalent of dload_data() from
+	 * cload.c.  */
+	cur_pkt = dlthis->tramp.tramp_pkts;
+	while ((ret_val != 0) && (cur_pkt != NULL)) {
+		/*  Remove the pkt from the list  */
+		dlthis->tramp.tramp_pkts = cur_pkt->next;
+
+		/*  Setup section and image offset information for the relo  */
+		dlthis->image_secn = sect_info;
+		dlthis->image_offset = cur_pkt->base;
+		dlthis->delta_runaddr = sect_info->run_addr;
+
+		/*  Walk through all relos for the packet  */
+		relos_done = 0;
+		cur_relo = (struct reloc_record_t *)((u8 *)&cur_pkt->hdr +
+						  cur_pkt->hdr.relo_offset);
+		while (relos_done < cur_pkt->hdr.num_relos) {
+#ifdef ENABLE_TRAMP_DEBUG
+			dload_syms_error(dlthis->mysym,
+				 "===> Trampoline %x branches to %x",
+				 sect_info->run_addr + dlthis->image_offset,
+				 dlthis->tramp.
+				 final_sym_table[cur_relo->r_symndx].value);
+#endif
+
+			for (i = 0;
+				 ((i < MAX_RELOS_PER_PASS) &&
+				  ((i + relos_done) < cur_pkt->hdr.num_relos));
+				 i++)
+				relos[i] = cur_relo + i;
+
+			/*  Do the actual relo  */
+			ret_val = priv_pkt_relo(dlthis,
+						(TgtAU_t *)&cur_pkt->payload,
+						relos, i);
+			if (ret_val == 0) {
+				dload_error(dlthis,
+				"Relocation of trampoline pkt at %x failed",
+				cur_pkt->base + sect_info->run_addr);
+				break;
+			}
+
+			relos_done += i;
+			cur_relo += i;
+		}
+
+		/*  Make sure we didn't hit a problem  */
+		if (ret_val != 0) {
+			/*  Relos are done for the packet, write it to the
+			 * target  */
+			ret_val = dlthis->myio->writemem(dlthis->myio,
+					   &cur_pkt->payload,
+					   sect_info->load_addr + cur_pkt->base
+					   , sect_info, BYTE_TO_HOST(
+					   cur_pkt->hdr.tramp_code_size));
+			if (ret_val == 0) {
+				dload_error(dlthis,
+					"Write to " FMT_UI32 " failed",
+					sect_info->load_addr + cur_pkt->base);
+			}
+
+			/*  Done with the pkt, let it go  */
+			dlthis->mysym->Deallocate(dlthis->mysym, cur_pkt);
+
+			/*  Get the next packet to process  */
+			cur_pkt = dlthis->tramp.tramp_pkts;
+		}
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_dup_pkt_finalize
+ * Description: Walk the list of duplicate image packets and finalize them.
+ *	  Each duplicate packet will be relocated again for the
+ *	  relocations that previously failed and have been adjusted
+ *	  to point at a trampoline.  Once all relocations for a packet
+ *	  have been done, write the packet into target memory.  The
+ *	  duplicate packet and its relocation chain are all freed
+ *	  after use here as they are no longer needed after this.
+ */
+static int priv_dup_pkt_finalize(struct dload_state *dlthis)
+{
+	int ret_val = 1;
+	struct tramp_img_dup_pkt *cur_pkt;
+	struct tramp_img_dup_relo *cur_relo;
+	struct reloc_record_t *relos[MAX_RELOS_PER_PASS];
+	struct doff_scnhdr_t *sect_hdr = NULL;
+	s32 i;
+
+	/* Similar to the trampoline pkt finalize, this function walks each dup
+	 * pkt that was generated and performs all relocations that were
+	 * deferred to a 2nd pass.  This is the equivalent of dload_data() from
+	 * cload.c, but does not need the additional reorder and checksum
+	 * processing as it has already been done.  */
+	cur_pkt = dlthis->tramp.dup_pkts;
+	while ((ret_val != 0) && (cur_pkt != NULL)) {
+		/*  Remove the node from the list, we'll be freeing it
+		 * shortly  */
+		dlthis->tramp.dup_pkts = cur_pkt->next;
+
+		/*  Setup the section and image offset for relocation  */
+		dlthis->image_secn = &dlthis->ldr_sections[cur_pkt->secnn];
+		dlthis->image_offset = cur_pkt->offset;
+
+		/*  In order to get the delta run address, we need to reference
+		 * the original section header.  It's a bit ugly, but needed
+		 * for relo.  */
+		i = (s32)(dlthis->image_secn - dlthis->ldr_sections);
+		sect_hdr = dlthis->sect_hdrs + i;
+		dlthis->delta_runaddr = sect_hdr->ds_paddr;
+
+		/*  Walk all relos in the chain and process each.  */
+		cur_relo = cur_pkt->relo_chain;
+		while (cur_relo != NULL) {
+			/*  Process them a chunk at a time to be efficient  */
+			for (i = 0; (i < MAX_RELOS_PER_PASS)
+				 && (cur_relo != NULL);
+				 i++, cur_relo = cur_relo->next) {
+				relos[i] = &cur_relo->relo;
+				cur_pkt->relo_chain = cur_relo->next;
+			}
+
+			/*  Do the actual relo  */
+			ret_val = priv_pkt_relo(dlthis,
+				cur_pkt->img_pkt.i_bits,
+				relos, i);
+			if (ret_val == 0) {
+				dload_error(dlthis,
+					"Relocation of dup pkt at %x failed",
+					cur_pkt->offset + dlthis->image_secn->
+					run_addr);
+				break;
+			}
+
+			/*  Release all of these relos, we're done with them */
+			while (i > 0) {
+				dlthis->mysym->Deallocate(dlthis->mysym,
+					  GET_CONTAINER(relos[i - 1],
+					struct tramp_img_dup_relo, relo));
+				i--;
+			}
+
+			/*  DO NOT ADVANCE cur_relo, IT IS ALREADY READY TO
+			 * GO!  */
+		}
+
+		/* Done with all relos.  Make sure we didn't have a problem and
+		 * write it out to the target  */
+		if (ret_val != 0) {
+			ret_val = dlthis->myio->writemem(dlthis->myio,
+				   cur_pkt->img_pkt.i_bits,
+				   dlthis->image_secn->load_addr +
+				   cur_pkt->offset, dlthis->image_secn,
+				   BYTE_TO_HOST(cur_pkt->
+				   img_pkt.i_packet_size));
+			if (ret_val == 0) {
+				dload_error(dlthis,
+					"Write to " FMT_UI32 " failed",
+					dlthis->image_secn->load_addr +
+					cur_pkt->offset);
+			}
+
+			dlthis->mysym->Deallocate(dlthis->mysym, cur_pkt);
+
+			/*  Advance to the next packet  */
+			cur_pkt = dlthis->tramp.dup_pkts;
+		}
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_dup_find
+ * Description: Walk the list of existing duplicate packets and find a
+ *	  match based on the section number and image offset.  Return
+ *	  the duplicate packet if found, otherwise NULL.
+ */
+static struct tramp_img_dup_pkt *priv_dup_find(struct dload_state *dlthis,
+					s16 secnn, u32 image_offset)
+{
+	struct tramp_img_dup_pkt *cur_pkt = NULL;
+
+	for (cur_pkt = dlthis->tramp.dup_pkts;
+		 cur_pkt != NULL;
+		 cur_pkt = cur_pkt->next) {
+		if ((cur_pkt->secnn == secnn) &&
+			(cur_pkt->offset == image_offset)) {
+			/*  Found a match, break out  */
+			break;
+		}
+	}
+
+	return cur_pkt;
+}
+
+/*
+ * Function:	priv_img_pkt_dup
+ * Description: Duplicate the original image packet.  If this is the first
+ *	  time this image packet has been seen (based on section number
+ *	  and image offset), create a new duplicate packet and add it
+ *	  to the dup packet list.  If not, just get the existing one and
+ *	  update it with the current packet contents (since relocation
+ *	  on the packet is still ongoing in first pass.)  Create a
+ *	  duplicate of the provided relocation, but update it to point
+ *	  to the new trampoline symbol.  Add the new relocation dup to
+ *	  the dup packet's relo chain for 2nd pass relocation later.
+ */
+static int priv_img_pkt_dup(struct dload_state *dlthis,
+	s16 secnn, u32 image_offset, struct image_packet_t *ipacket,
+	struct reloc_record_t *rp, struct tramp_sym *new_tramp_sym)
+{
+	struct tramp_img_dup_pkt *dup_pkt = NULL;
+	u32 new_dup_size;
+	s32 i;
+	int ret_val = 0;
+	struct tramp_img_dup_relo *dup_relo = NULL;
+
+	/*  Determinne if this image packet is already being tracked in the
+		dup list for other trampolines.  */
+	dup_pkt = priv_dup_find(dlthis, secnn, image_offset);
+
+	if (dup_pkt == NULL) {
+		/*  This image packet does not exist in our tracking, so create
+		 * a new one and add it to the head of the list.  */
+		new_dup_size = sizeof(struct tramp_img_dup_pkt) +
+						ipacket->i_packet_size;
+
+		dup_pkt = (struct tramp_img_dup_pkt *)
+			dlthis->mysym->Allocate(dlthis->mysym, new_dup_size);
+		if (dup_pkt != NULL) {
+			/*  Save off the section and offset information  */
+			dup_pkt->secnn = secnn;
+			dup_pkt->offset = image_offset;
+			dup_pkt->relo_chain = NULL;
+
+			/*  Copy the original packet content  */
+			dup_pkt->img_pkt = *ipacket;
+			dup_pkt->img_pkt.i_bits = (u8 *)(dup_pkt + 1);
+			for (i = 0; i < ipacket->i_packet_size; i++)
+				*(dup_pkt->img_pkt.i_bits + i) =
+					*(ipacket->i_bits + i);
+
+			/*  Add the packet to the dup list  */
+			dup_pkt->next = dlthis->tramp.dup_pkts;
+			dlthis->tramp.dup_pkts = dup_pkt;
+		} else
+			dload_error(dlthis, "Failed to create dup packet!");
+	} else {
+		/*  The image packet contents could have changed since
+		 * trampoline detection happens during relocation of the image
+		 * packets.  So, we need to update the image packet contents
+		 * before adding relo information.  */
+		for (i = 0; i < dup_pkt->img_pkt.i_packet_size; i++)
+			*(dup_pkt->img_pkt.i_bits + i) =
+				*(ipacket->i_bits + i);
+	}
+
+	/*  Since the previous code may have allocated a new dup packet for us,
+		double check that we actually have one.  */
+	if (dup_pkt != NULL) {
+		/*  Allocate a new node for the relo chain.  Each image packet
+		 * can potentially have multiple relocations that cause a
+		 * trampoline to be generated.  So, we keep them in a chain,
+		 * order is not important.  */
+		dup_relo = dlthis->mysym->Allocate(dlthis->mysym,
+					   sizeof(struct tramp_img_dup_relo));
+		if (dup_relo != NULL) {
+			/*  Copy the relo contents, adjust for the new
+			 * trampoline and add it to the list.  */
+			dup_relo->relo = *rp;
+			dup_relo->relo.r_symndx = new_tramp_sym->index;
+
+			dup_relo->next = dup_pkt->relo_chain;
+			dup_pkt->relo_chain = dup_relo;
+
+			/*  That's it, we're done.  Make sure we update our
+			 * return value to be success since everything finished
+			 * ok  */
+			ret_val = 1;
+		} else
+			dload_error(dlthis, "Unable to alloc dup relo");
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	dload_tramp_avail
+ * Description: Check to see if the target supports a trampoline for this type
+ *	  of relocation.  Return true if it does, otherwise false.
+ */
+bool dload_tramp_avail(struct dload_state *dlthis, struct reloc_record_t *rp)
+{
+	bool ret_val = false;
+	u16 map_index;
+	u16 gen_index;
+
+	/*  Check type hash vs. target tramp table  */
+	map_index = HASH_FUNC(rp->r_type);
+	gen_index = tramp_map[map_index];
+	if (gen_index != TRAMP_NO_GEN_AVAIL)
+		ret_val = true;
+
+	return ret_val;
+}
+
+/*
+ * Function:	dload_tramp_generate
+ * Description: Create a new trampoline for the provided image packet and
+ *	  relocation causing problems.  This will create the trampoline
+ *	  as well as duplicate/update the image packet and relocation
+ *	  causing the problem, which will be relo'd again during
+ *	  finalization.
+ */
+int dload_tramp_generate(struct dload_state *dlthis, s16 secnn,
+	u32 image_offset, struct image_packet_t *ipacket,
+	struct reloc_record_t *rp)
+{
+	u16 map_index;
+	u16 gen_index;
+	int ret_val = 1;
+	char tramp_sym_str[TRAMP_SYM_PREFIX_LEN + TRAMP_SYM_HEX_ASCII_LEN];
+	struct Local_Symbol *ref_sym;
+	struct tramp_sym	*new_tramp_sym;
+	struct tramp_sym	*new_ext_sym;
+	struct tramp_string *new_tramp_str;
+	u32 new_tramp_base;
+	struct Local_Symbol tmp_sym;
+	struct Local_Symbol ext_tmp_sym;
+
+	/*  Hash the relo type to get our generator information  */
+	map_index = HASH_FUNC(rp->r_type);
+	gen_index = tramp_map[map_index];
+	if (gen_index != TRAMP_NO_GEN_AVAIL) {
+		/*  If this is the first trampoline, create the section name in
+		 * our string table for debug help later.  */
+		if (dlthis->tramp.string_head == NULL) {
+			priv_tramp_string_create(dlthis,
+				 strlen(TRAMP_SECT_NAME), TRAMP_SECT_NAME);
+		}
+
+#ifdef ENABLE_TRAMP_DEBUG
+		dload_syms_error(dlthis->mysym,
+			 "Trampoline at img loc %x, references %x",
+			 dlthis->ldr_sections[secnn].run_addr + image_offset +
+			 rp->r_vaddr,
+			 dlthis->local_symtab[rp->r_symndx].value);
+#endif
+
+		/*  Generate the trampoline string, check if already defined.
+		 * If the relo symbol index is -1, it means we need the section
+		 * info for relo later.  To do this we'll dummy up a symbol
+		 * with the section delta and run addresses.  */
+		if (rp->r_symndx == -1) {
+			ext_tmp_sym.value =
+				dlthis->ldr_sections[secnn].run_addr;
+			ext_tmp_sym.delta = dlthis->sect_hdrs[secnn].ds_paddr;
+			ref_sym = &ext_tmp_sym;
+		} else
+			ref_sym = &(dlthis->local_symtab[rp->r_symndx]);
+
+		priv_tramp_sym_gen_name(ref_sym->value, tramp_sym_str);
+		new_tramp_sym = priv_tramp_sym_find(dlthis, tramp_sym_str);
+		if (new_tramp_sym == NULL) {
+			/*  If tramp string not defined, create it and a new
+			 * string, and symbol for it as well as the original
+			 * symbol which caused the trampoline.  */
+			new_tramp_str = priv_tramp_string_create(dlthis,
+				 strlen(tramp_sym_str), tramp_sym_str);
+			if (new_tramp_str == NULL) {
+				dload_error(dlthis, "Failed to create new "
+					"trampoline string\n");
+				ret_val = 0;
+			} else {
+				/*  Allocate tramp section space for the new
+				 * tramp from the target  */
+				new_tramp_base = priv_tramp_sect_alloc(dlthis,
+							   tramp_size_get());
+
+				/*  We have a string, create the new symbol and
+				 * duplicate the external.  */
+				tmp_sym.value = new_tramp_base;
+				tmp_sym.delta = 0;
+				tmp_sym.secnn = -1;
+				tmp_sym.sclass = 0;
+				new_tramp_sym = priv_tramp_sym_create(dlthis,
+					  new_tramp_str->index, &tmp_sym);
+
+				new_ext_sym = priv_tramp_sym_create(dlthis,
+								-1, ref_sym);
+
+				if ((new_tramp_sym != NULL) &&
+					(new_ext_sym != NULL)) {
+					/*  Call the image generator to get the
+					 * new image data and fix up its
+					 * relocations for the external
+					 * symbol.  */
+					ret_val = priv_tgt_img_gen(dlthis,
+					   new_tramp_base, gen_index,
+					   new_ext_sym);
+
+					/*  Add generated image data to tramp
+					 * image list  */
+					if (ret_val != 1) {
+						dload_error(dlthis, "Failed to"
+						   " create image packet for "
+						   "trampoline\n");
+					}
+				} else {
+					dload_error(dlthis, "Failed to create "
+					   "new tramp syms (%8.8X, %8.8X)\n",
+					   new_tramp_sym, new_ext_sym);
+					ret_val = 0;
+				}
+			}
+		}
+
+		/*  Duplicate the image data and relo record that caused the
+		 * tramp, including update the relo data to point to the tramp
+		 * symbol.  */
+		if (ret_val == 1) {
+			ret_val = priv_img_pkt_dup(dlthis, secnn, image_offset,
+				   ipacket, rp, new_tramp_sym);
+			if (ret_val != 1) {
+				dload_error(dlthis, "Failed to create dup of "
+					"original img pkt\n");
+			}
+		}
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	dload_tramp_pkt_update
+ * Description: Update the duplicate copy of this image packet, which the
+ *	  trampoline layer is already tracking.  This is call is critical
+ *	  to make if trampolines were generated anywhere within the
+ *	  packet and first pass relo continued on the remainder.  The
+ *	  trampoline layer needs the updates image data so when 2nd
+ *	  pass relo is done during finalize the image packet can be
+ *	  written to the target since all relo is done.
+ */
+int dload_tramp_pkt_udpate(struct dload_state *dlthis, s16 secnn,
+	   u32 image_offset, struct image_packet_t *ipacket)
+{
+	struct tramp_img_dup_pkt *dup_pkt = NULL;
+	s32 i;
+	int ret_val = 0;
+
+	/*  Find the image packet in question, the caller needs us to update it
+		since a trampoline was previously generated.  */
+	dup_pkt = priv_dup_find(dlthis, secnn, image_offset);
+	if (dup_pkt != NULL) {
+		for (i = 0; i < dup_pkt->img_pkt.i_packet_size; i++)
+			*(dup_pkt->img_pkt.i_bits + i) = *(ipacket->i_bits + i);
+
+		ret_val = 1;
+	} else {
+		dload_error(dlthis,
+			"Unable to find existing DUP pkt for %x, offset %x",
+			secnn, image_offset);
+
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	dload_tramp_finalize
+ * Description: If any trampolines were created, finalize everything on the
+ *	  target by allocating the trampoline section on the target,
+ *	  finalizing the trampoline symbols, finalizing the trampoline
+ *	  packets (write the new section to target memory) and finalize
+ *	  the duplicate packets by doing 2nd pass relo over them.
+ */
+int dload_tramp_finalize(struct dload_state *dlthis)
+{
+	int ret_val = 1;
+
+	if (dlthis->tramp.tramp_sect_next_addr != 0) {
+		/*  Finalize strings into a flat table.  This is needed so it
+		 * can be added to the debug string table later.  */
+		ret_val = priv_string_tbl_finalize(dlthis);
+
+		/*  Do target allocation for section BEFORE finalizing
+		 * symbols.  */
+		if (ret_val != 0)
+			ret_val = priv_tramp_sect_tgt_alloc(dlthis);
+
+		/*  Finalize symbols with their correct target information and
+		 * flatten  */
+		if (ret_val != 0)
+			ret_val = priv_tramp_sym_finalize(dlthis);
+
+		/*  Finalize all trampoline packets.  This performs the
+		 * relocation on the packets as well as writing them to target
+		 * memory.  */
+		if (ret_val != 0)
+			ret_val = priv_tramp_pkt_finalize(dlthis);
+
+		/*  Perform a 2nd pass relocation on the dup list.  */
+		if (ret_val != 0)
+			ret_val = priv_dup_pkt_finalize(dlthis);
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	dload_tramp_cleanup
+ * Description: Release all temporary resources used in the trampoline layer.
+ *	  Note that the target memory which may have been allocated and
+ *	  written to store the trampolines is NOT RELEASED HERE since it
+ *	  is potentially still in use.  It is automatically released
+ *	  when the module is unloaded.
+ */
+void dload_tramp_cleanup(struct dload_state *dlthis)
+{
+	struct tramp_info *tramp = &dlthis->tramp;
+	struct tramp_sym *cur_sym;
+	struct tramp_string *cur_string;
+	struct tramp_img_pkt *cur_tramp_pkt;
+	struct tramp_img_dup_pkt *cur_dup_pkt;
+	struct tramp_img_dup_relo *cur_dup_relo;
+
+	/*  If there were no tramps generated, just return  */
+	if (tramp->tramp_sect_next_addr == 0)
+		return;
+
+	/*  Destroy all tramp information  */
+	for (cur_sym = tramp->symbol_head;
+		 cur_sym != NULL;
+		 cur_sym = tramp->symbol_head) {
+		tramp->symbol_head = cur_sym->next;
+		if (tramp->symbol_tail == cur_sym)
+			tramp->symbol_tail = NULL;
+
+		dlthis->mysym->Deallocate(dlthis->mysym, cur_sym);
+	}
+
+	if (tramp->final_sym_table != NULL)
+		dlthis->mysym->Deallocate(dlthis->mysym,
+			tramp->final_sym_table);
+
+	for (cur_string = tramp->string_head;
+		 cur_string != NULL;
+		 cur_string = tramp->string_head) {
+		tramp->string_head = cur_string->next;
+		if (tramp->string_tail == cur_string)
+			tramp->string_tail = NULL;
+
+		dlthis->mysym->Deallocate(dlthis->mysym, cur_string);
+	}
+
+	if (tramp->final_string_table != NULL)
+		dlthis->mysym->Deallocate(dlthis->mysym,
+			tramp->final_string_table);
+
+	for (cur_tramp_pkt = tramp->tramp_pkts;
+		 cur_tramp_pkt != NULL;
+		 cur_tramp_pkt = tramp->tramp_pkts) {
+		tramp->tramp_pkts = cur_tramp_pkt->next;
+		dlthis->mysym->Deallocate(dlthis->mysym, cur_tramp_pkt);
+	}
+
+	for (cur_dup_pkt = tramp->dup_pkts;
+		 cur_dup_pkt != NULL;
+		 cur_dup_pkt = tramp->dup_pkts) {
+		tramp->dup_pkts = cur_dup_pkt->next;
+
+		for (cur_dup_relo = cur_dup_pkt->relo_chain;
+			 cur_dup_relo != NULL;
+			 cur_dup_relo = cur_dup_pkt->relo_chain) {
+			cur_dup_pkt->relo_chain = cur_dup_relo->next;
+			dlthis->mysym->Deallocate(dlthis->mysym, cur_dup_relo);
+		}
+
+		dlthis->mysym->Deallocate(dlthis->mysym, cur_dup_pkt);
+	}
+}
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/tramp_table_c6000.c kernel-power-2.6.28/drivers/dsp/bridge/dynload/tramp_table_c6000.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/dynload/tramp_table_c6000.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/dynload/tramp_table_c6000.c	2011-05-02 22:36:49.000000000 +0100
@@ -0,0 +1,172 @@
+/*
+ * tramp_table_c6000.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include "dload_internal.h"
+
+/*  These are defined in coff.h, but may not be available on all platforms
+	so we'll go ahead and define them here.  */
+#ifndef R_C60LO16
+#define R_C60LO16	  0x54	   /* C60: MVK Low Half Register	  */
+#define R_C60HI16	  0x55	   /* C60: MVKH/MVKLH High Half Register  */
+#endif
+
+#define C6X_TRAMP_WORD_COUNT			8
+#define C6X_TRAMP_MAX_RELOS			 8
+
+/*  THIS HASH FUNCTION MUST MATCH THE ONE IN reloc_table_c6000.c  */
+#define HASH_FUNC(zz) (((((zz) + 1) * UINT32_C(1845)) >> 11) & 63)
+
+
+/*  THIS MUST MATCH reloc_record_t FOR A SYMBOL BASED RELO  */
+struct c6000_relo_record {
+	s32 r_vaddr;
+	s32 symndx;
+#ifndef _BIG_ENDIAN
+	u16 disp;
+	u16 type;
+#else
+	u16 type;
+	u16 disp;
+#endif
+};
+
+struct c6000_gen_code {
+	struct tramp_gen_code_hdr	hdr;
+	u32 tramp_instrs[C6X_TRAMP_WORD_COUNT];
+	struct c6000_relo_record relos[C6X_TRAMP_MAX_RELOS];
+};
+
+
+/*  Hash mapping for relos that can cause trampolines.  */
+static const u16 tramp_map[] =
+{
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	0,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535
+};
+
+
+static const struct c6000_gen_code   tramp_gen_info[] =
+{
+	/*  Tramp caused by R_C60PCR21  */
+	{
+		/*  Header - 8 instructions, 2 relos  */
+		{
+			sizeof(u32) * C6X_TRAMP_WORD_COUNT,
+			2,
+			FIELD_OFFSET(struct c6000_gen_code, relos)
+		},
+
+		/*  Trampoline instructions  */
+		{
+			0x053C54F7,	/*	 STW.D2T2  B10, *sp--[2]  */
+			0x0500002A,	/*  || MVK.S2	<blank>, B10   */
+			0x0500006A,	/*	 MVKH.S2   <blank>, B10   */
+			0x00280362,	/*	 B.S2	  B10		*/
+			0x053C52E6,	/*	 LDW.D2T2  *++sp[2], B10  */
+			0x00006000,	/*	 NOP	   4		*/
+			0x00000000,	/*	 NOP			*/
+			0x00000000	/*	 NOP			*/
+		},
+
+		/*  Relocations  */
+		{
+			{ 4, 0, 0, R_C60LO16 },
+			{ 8, 0, 0, R_C60HI16 },
+			{ 0, 0, 0, 0x0000 },
+			{ 0, 0, 0, 0x0000 },
+			{ 0, 0, 0, 0x0000 },
+			{ 0, 0, 0, 0x0000 },
+			{ 0, 0, 0, 0x0000 },
+			{ 0, 0, 0, 0x0000 }
+		}
+	}
+};
+
+
+
+/*  TARGET SPECIFIC FUNCTIONS THAT MUST BE DEFINED  */
+static u32 tramp_size_get(void)
+{
+	return sizeof(u32) * C6X_TRAMP_WORD_COUNT;
+}
+
+
+static u32 tramp_img_pkt_size_get(void)
+{
+	return sizeof(struct c6000_gen_code);
+}
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/gen/_gt_para.c kernel-power-2.6.28/drivers/dsp/bridge/gen/_gt_para.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/gen/_gt_para.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/gen/_gt_para.c	2011-05-02 22:36:49.000000000 +0100
@@ -14,24 +14,12 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
 /*
- *  ======== _gt_para.c ========
- *  Description:
- *      Configuration parameters for GT.  This file is separated from
- *      gt.c so that GT_assert() can reference the error function without
- *      forcing the linker to include all the code for GT_set(), GT_init(),
- *      etc. into a fully bound image.  Thus, GT_assert() can be retained in
- *      a program for which GT_?trace() has been compiled out.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 vp: Code Review Updates.
- *! 18-Oct-2002 sb: Ported to Linux platform.
- *! 03-Jul-2001 rr: Removed kfuncs.h because of build errors.
- *! 07-Dec-1999 ag: Fxn error now causes a WinCE DebugBreak;
- *! 30-Aug-1999 ag: Now uses GP_printf for printf and error.
- *!
+ * Configuration parameters for GT.  This file is separated from
+ * gt.c so that GT_assert() can reference the error function without
+ * forcing the linker to include all the code for GT_set(), GT_init(),
+ * etc. into a fully bound image.  Thus, GT_assert() can be retained in
+ * a program for which GT_?trace() has been compiled out.
  */
 
 /*  ----------------------------------- Host OS */
@@ -89,10 +77,10 @@ static void error(char *fmt, ...)
 
 	va_end(va);
 
-	printk("ERROR: ");
+	pr_err("ERROR: ");
 	printk(fmt, arg1, arg2, arg3, arg4, arg5, arg6);
 
-#if defined(DEBUG) || defined(DDSP_DEBUG_PRODUCT)
+#if defined(CONFIG_BRIDGE_DEBUG) || defined(DDSP_DEBUG_PRODUCT)
 	if (in_interrupt()) {
 		printk(KERN_INFO "Not stopping after error since ISR/DPC "
 			"are disabled\n");
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/gen/gb.c kernel-power-2.6.28/drivers/dsp/bridge/gen/gb.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/gen/gb.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/gen/gb.c	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Generic bitmap operations.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,21 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== gb.c ========
- *  Description: Generic bitmap operations.
- *
- *! Revision History
- *! ================
- *! 24-Feb-2003 vp  Code review updates.
- *! 17-Dec-2002 map Fixed GB_minset(), GB_empty(), and GB_full(),
- *!                 to ensure only 'len' bits are considered in the map
- *! 18-Oct-2002 sb  Ported to Linux platform.
- *! 06-Dec-2001 jeh Fixed bug in GB_minclear().
- *!
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 #include <linux/types.h>
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/gen/gh.c kernel-power-2.6.28/drivers/dsp/bridge/gen/gh.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/gen/gh.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/gen/gh.c	2011-05-02 22:36:49.000000000 +0100
@@ -14,11 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== gh.c ========
- */
-
 #include <dspbridge/std.h>
 
 #include <dspbridge/host_os.h>
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/gen/gs.c kernel-power-2.6.28/drivers/dsp/bridge/gen/gs.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/gen/gs.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/gen/gs.c	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * General storage memory allocator services.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,21 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== gs.c ========
- *  Description:
- *      General storage memory allocator services.
- *
- *! Revision History
- *! ================
- *! 29-Sep-1999 ag:  Un-commented MEM_Init in GS_init().
- *! 14-May-1997 mg:  Modified to use new GS API for GS_free() and GS_frees().
- *! 06-Nov-1996 gp:  Re-commented MEM_Init in GS_init(). GS needs GS_Exit().
- *! 21-Oct-1996 db:  Un-commented MEM_Init in GS_init().
- *! 21-May-1996 mg:  Created from original stdlib implementation.
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
@@ -65,7 +52,7 @@ void *GS_alloc(u32 size)
  */
 void GS_exit(void)
 {
-	MEM_Exit();
+	/* Do nothing */
 }
 
 /*
@@ -98,9 +85,5 @@ void GS_frees(void *ptr, u32 size)
  */
 void GS_init(void)
 {
-	static bool curInit;
-
-	if (curInit == false) {
-		curInit = MEM_Init(); /* which can't fail currently. */
-	}
+	/* Do nothing */
 }
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/gen/gt.c kernel-power-2.6.28/drivers/dsp/bridge/gen/gt.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/gen/gt.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/gen/gt.c	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This module implements the trace mechanism for bridge.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,20 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- * ======== gt.c ========
- * Description: This module implements the trace mechanism for bridge.
- *
- *! Revision History
- *! ================
- *! 16-May-1997 dr	Changed GT_Config member names to conform to coding
- *!			standards.
- *! 23-Apr-1997 ge	Check for GT->TIDFXN for NULL before calling it.
- *! 03-Jan-1997	ge	Changed GT_Config structure member names to eliminate
- *!			preprocessor confusion with other macros.
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 
@@ -238,7 +226,7 @@ s32 _GT_trace(struct GT_Mask *mask, char
 	arg6 = va_arg(va, s32);
 
 	va_end(va);
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 	if (GT->PIDFXN == NULL) {
 		printk(GT_1format, mask->modName, GT->TIDFXN ?
 		(*GT->TIDFXN)() : 0);
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/gen/uuidutil.c kernel-power-2.6.28/drivers/dsp/bridge/gen/uuidutil.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/gen/uuidutil.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/gen/uuidutil.c	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This file contains the implementation of UUID helper functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,24 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== uuidutil.c ========
- *  Description:
- *  This file contains the implementation of UUID helper functions.
- *
- *! Revision History
- *! ================
- *! 23-Feb-2003 vp: Code review updates.
- *! 18-Oct-2003 vp: Ported to Linux platform.
- *! 31-Aug-2000 rr: UUID_UuidFromString bug fixed.
- *! 29-Aug-2000 rr: Modified UUID_UuidFromString.
- *! 09-Nov-2000 kc: Modified UUID_UuidFromString to simplify implementation.
- *! 30-Oct-2000 kc: Modified UUID utility module function prefix.
- *! 10-Aug-2000 kc: Created.
- *!
- */
-
 /*  ----------------------------------- Host OS  */
 #include <dspbridge/host_os.h>
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/GlobalTypes.h kernel-power-2.6.28/drivers/dsp/bridge/hw/GlobalTypes.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/GlobalTypes.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/hw/GlobalTypes.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global HW definitions
+ *
  * Copyright (C) 2007 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,16 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== GlobalTypes.h ========
- *  Description:
- *      Global HW definitions
- *
- *! Revision History:
- *! ================
- *! 16 Feb 2003 sb: Initial version
- */
 #ifndef __GLOBALTYPES_H
 #define __GLOBALTYPES_H
 
@@ -109,7 +101,7 @@
  * DESCRIPTION: Returns a 32 bit value given a 16 bit lower value and a 16
  *		bit upper value
  */
-#define RETURN_32BITS_FROM_16LOWER_AND_16UPPER(lower16Bits,upper16Bits)\
+#define RETURN_32BITS_FROM_16LOWER_AND_16UPPER(lower16Bits, upper16Bits)\
     (((((u32)lower16Bits)  & LOWER_16BIT_MASK)) | \
      (((((u32)upper16Bits) & LOWER_16BIT_MASK) << UPPER_16BIT_SHIFT)))
 
@@ -119,7 +111,7 @@
  * DESCRIPTION:  Returns a 16 bit value given a 8 bit lower value and a 8
  *	       bit upper value
  */
-#define RETURN_16BITS_FROM_8LOWER_AND_8UPPER(lower8Bits,upper8Bits)\
+#define RETURN_16BITS_FROM_8LOWER_AND_8UPPER(lower8Bits, upper8Bits)\
     (((((u32)lower8Bits)  & LOWER_8BIT_MASK)) | \
      (((((u32)upper8Bits) & LOWER_8BIT_MASK) << UPPER_8BIT_OF16_SHIFT)))
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/IPIAccInt.h kernel-power-2.6.28/drivers/dsp/bridge/hw/IPIAccInt.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/IPIAccInt.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/hw/IPIAccInt.h	2011-05-02 22:36:49.000000000 +0100
@@ -22,20 +22,5 @@
 #define SYSC_IVA2BOOTADDR_OFFSET                0x400
 #define SYSC_IVA2BOOTADDR_MASK                 0xfffffc00
 
-
-/* The following represent the enumerated values for each bitfield */
-
-enum IPIIPI_SYSCONFIGAutoIdleE {
-	IPIIPI_SYSCONFIGAutoIdleclkfree = 0x0000,
-	IPIIPI_SYSCONFIGAutoIdleautoclkgate = 0x0001
-} ;
-
-enum IPIIPI_ENTRYElemSizeValueE {
-	IPIIPI_ENTRYElemSizeValueElemSz8b = 0x0000,
-	IPIIPI_ENTRYElemSizeValueElemSz16b = 0x0001,
-	IPIIPI_ENTRYElemSizeValueElemSz32b = 0x0002,
-	IPIIPI_ENTRYElemSizeValueReserved = 0x0003
-} ;
-
 #endif				/* _IPI_ACC_INT_H */
 /* EOF */
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/IVA2RegAcM.h kernel-power-2.6.28/drivers/dsp/bridge/hw/IVA2RegAcM.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/IVA2RegAcM.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/hw/IVA2RegAcM.h	2011-05-02 22:36:49.000000000 +0100
@@ -14,8 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-
 #ifndef _IVA2_REG_ACM_H
 #define _IVA2_REG_ACM_H
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/MLBAccInt.h kernel-power-2.6.28/drivers/dsp/bridge/hw/MLBAccInt.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/MLBAccInt.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/hw/MLBAccInt.h	2011-05-02 22:36:49.000000000 +0100
@@ -14,7 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
 #ifndef _MLB_ACC_INT_H
 #define _MLB_ACC_INT_H
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/MLBRegAcM.h kernel-power-2.6.28/drivers/dsp/bridge/hw/MLBRegAcM.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/MLBRegAcM.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/hw/MLBRegAcM.h	2011-05-02 22:36:49.000000000 +0100
@@ -24,177 +24,158 @@
 
 #if defined(USE_LEVEL_1_MACROS)
 
-#define MLBMAILBOX_SYSCONFIGReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGReadRegister32),\
-      __raw_readl(((baseAddress))+ \
-      MLB_MAILBOX_SYSCONFIG_OFFSET))
-
-
-#define MLBMAILBOX_SYSCONFIGWriteRegister32(baseAddress, value)\
-{\
-    const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGWriteRegister32);\
-    __raw_writel(newValue, ((baseAddress))+offset);\
-}
-
-
-#define MLBMAILBOX_SYSCONFIGSIdleModeRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeRead32),\
-      (((__raw_readl((((u32)(baseAddress))+\
-      (MLB_MAILBOX_SYSCONFIG_OFFSET)))) &\
-      MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK) >>\
-      MLB_MAILBOX_SYSCONFIG_SIdleMode_OFFSET))
-
-
-#define MLBMAILBOX_SYSCONFIGSIdleModeWrite32(baseAddress, value)\
-{\
-    const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;\
-    register u32 data = __raw_readl(((u32)(baseAddress)) +\
-			    offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeWrite32);\
-    data &= ~(MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK);\
-    newValue <<= MLB_MAILBOX_SYSCONFIG_SIdleMode_OFFSET;\
-    newValue &= MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define MLBMAILBOX_SYSCONFIGSoftResetWrite32(baseAddress, value)\
-{\
-    const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;\
-    register u32 data =\
-    __raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSoftResetWrite32);\
-    data &= ~(MLB_MAILBOX_SYSCONFIG_SoftReset_MASK);\
-    newValue <<= MLB_MAILBOX_SYSCONFIG_SoftReset_OFFSET;\
-    newValue &= MLB_MAILBOX_SYSCONFIG_SoftReset_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define MLBMAILBOX_SYSCONFIGAutoIdleRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleRead32),\
-      (((__raw_readl((((u32)(baseAddress))+\
-      (MLB_MAILBOX_SYSCONFIG_OFFSET)))) &\
-      MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK) >>\
-      MLB_MAILBOX_SYSCONFIG_AutoIdle_OFFSET))
-
-
-#define MLBMAILBOX_SYSCONFIGAutoIdleWrite32(baseAddress, value)\
-{\
-    const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;\
-    register u32 data =\
-    __raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleWrite32);\
-    data &= ~(MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK);\
-    newValue <<= MLB_MAILBOX_SYSCONFIG_AutoIdle_OFFSET;\
-    newValue &= MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
+#define MLBMAILBOX_SYSCONFIGReadRegister32(baseAddress)			 \
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGReadRegister32), \
+	__raw_readl(((baseAddress)) + MLB_MAILBOX_SYSCONFIG_OFFSET))
+
+
+#define MLBMAILBOX_SYSCONFIGWriteRegister32(baseAddress, value)		\
+do {									\
+	const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;		\
+	register u32 newValue = ((u32)(value));				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGWriteRegister32);\
+	__raw_writel(newValue, ((baseAddress)) + offset);		\
+} while (0)
+
+#define MLBMAILBOX_SYSCONFIGSIdleModeRead32(baseAddress)		  \
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeRead32), \
+	(((__raw_readl((((u32)(baseAddress)) +				  \
+	(MLB_MAILBOX_SYSCONFIG_OFFSET)))) &				  \
+	MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK) >>			  \
+	MLB_MAILBOX_SYSCONFIG_SIdleMode_OFFSET))
+
+#define MLBMAILBOX_SYSCONFIGSIdleModeWrite32(baseAddress, value)	  \
+do {									  \
+	const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;		  \
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	  \
+	register u32 newValue = ((u32)(value));				  \
+	_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeWrite32); \
+	data &= ~(MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK);		  \
+	newValue <<= MLB_MAILBOX_SYSCONFIG_SIdleMode_OFFSET;		  \
+	newValue &= MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK;		  \
+	newValue |= data;						  \
+	__raw_writel(newValue, (u32)(baseAddress) + offset);		  \
+} while (0)
+
+#define MLBMAILBOX_SYSCONFIGSoftResetWrite32(baseAddress, value)	    \
+do {									    \
+	const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;		    \
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	    \
+	register u32 newValue = ((u32)(value));				    \
+	_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSoftResetWrite32);   \
+	data &= ~(MLB_MAILBOX_SYSCONFIG_SoftReset_MASK);		    \
+	newValue <<= MLB_MAILBOX_SYSCONFIG_SoftReset_OFFSET;		    \
+	newValue &= MLB_MAILBOX_SYSCONFIG_SoftReset_MASK;		    \
+	newValue |= data;						    \
+	__raw_writel(newValue, (u32)(baseAddress) + offset);		    \
+} while (0)
+
+#define MLBMAILBOX_SYSCONFIGAutoIdleRead32(baseAddress)			 \
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleRead32), \
+	(((__raw_readl((((u32)(baseAddress)) +				 \
+	(MLB_MAILBOX_SYSCONFIG_OFFSET)))) &				 \
+	MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK) >>				 \
+	MLB_MAILBOX_SYSCONFIG_AutoIdle_OFFSET))
+
+#define MLBMAILBOX_SYSCONFIGAutoIdleWrite32(baseAddress, value)		 \
+do {									 \
+	const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;		 \
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	 \
+	register u32 newValue = ((u32)(value));				 \
+	_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleWrite32); \
+	data &= ~(MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK);			 \
+	newValue <<= MLB_MAILBOX_SYSCONFIG_AutoIdle_OFFSET;		 \
+	newValue &= MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK;		 \
+	newValue |= data;						 \
+	__raw_writel(newValue, (u32)(baseAddress)+offset);		 \
+} while (0)
 
 #define MLBMAILBOX_SYSSTATUSResetDoneRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSSTATUSResetDoneRead32),\
-      (((__raw_readl((((u32)(baseAddress))+\
-      (MLB_MAILBOX_SYSSTATUS_OFFSET)))) &\
-      MLB_MAILBOX_SYSSTATUS_ResetDone_MASK) >>\
-      MLB_MAILBOX_SYSSTATUS_ResetDone_OFFSET))
-
-
-#define MLBMAILBOX_MESSAGE___0_15ReadRegister32(baseAddress, bank)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_MESSAGE___0_15ReadRegister32),\
-      __raw_readl(((baseAddress))+\
-      (MLB_MAILBOX_MESSAGE___REGSET_0_15_OFFSET +\
-      MLB_MAILBOX_MESSAGE___0_15_OFFSET+(\
-      (bank)*MLB_MAILBOX_MESSAGE___REGSET_0_15_STEP))))
-
-
-#define MLBMAILBOX_MESSAGE___0_15WriteRegister32(baseAddress, bank, value)\
-{\
-    const u32 offset = MLB_MAILBOX_MESSAGE___REGSET_0_15_OFFSET +\
-    MLB_MAILBOX_MESSAGE___0_15_OFFSET +\
-    ((bank)*MLB_MAILBOX_MESSAGE___REGSET_0_15_STEP);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_MESSAGE___0_15WriteRegister32);\
-    __raw_writel(newValue, ((baseAddress))+offset);\
-}
-
-
-#define MLBMAILBOX_FIFOSTATUS___0_15ReadRegister32(baseAddress, bank)\
-    (_DEBUG_LEVEL_1_EASI(\
-      EASIL1_MLBMAILBOX_FIFOSTATUS___0_15ReadRegister32),\
-      __raw_readl(((u32)(baseAddress))+\
-      (MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_OFFSET +\
-      MLB_MAILBOX_FIFOSTATUS___0_15_OFFSET+\
-      ((bank)*MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_STEP))))
-
-
-#define MLBMAILBOX_FIFOSTATUS___0_15FifoFullMBmRead32(baseAddress, bank)\
-    (_DEBUG_LEVEL_1_EASI(\
-      EASIL1_MLBMAILBOX_FIFOSTATUS___0_15FifoFullMBmRead32),\
-      (((__raw_readl(((baseAddress))+\
-      (MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_OFFSET +\
-      MLB_MAILBOX_FIFOSTATUS___0_15_OFFSET+\
-      ((bank)*MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_STEP)))) &\
-      MLB_MAILBOX_FIFOSTATUS___0_15_FifoFullMBm_MASK) >>\
-      MLB_MAILBOX_FIFOSTATUS___0_15_FifoFullMBm_OFFSET))
-
-
-#define MLBMAILBOX_MSGSTATUS___0_15NbOfMsgMBmRead32(baseAddress, bank)\
-    (_DEBUG_LEVEL_1_EASI(\
-      EASIL1_MLBMAILBOX_MSGSTATUS___0_15NbOfMsgMBmRead32),\
-      (((__raw_readl(((baseAddress))+\
-      (MLB_MAILBOX_MSGSTATUS___REGSET_0_15_OFFSET +\
-      MLB_MAILBOX_MSGSTATUS___0_15_OFFSET+\
-      ((bank)*MLB_MAILBOX_MSGSTATUS___REGSET_0_15_STEP)))) &\
-      MLB_MAILBOX_MSGSTATUS___0_15_NbOfMsgMBm_MASK) >>\
-      MLB_MAILBOX_MSGSTATUS___0_15_NbOfMsgMBm_OFFSET))
-
-
-#define MLBMAILBOX_IRQSTATUS___0_3ReadRegister32(baseAddress, bank)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQSTATUS___0_3ReadRegister32),\
-      __raw_readl(((baseAddress))+\
-      (MLB_MAILBOX_IRQSTATUS___REGSET_0_3_OFFSET +\
-      MLB_MAILBOX_IRQSTATUS___0_3_OFFSET+\
-      ((bank)*MLB_MAILBOX_IRQSTATUS___REGSET_0_3_STEP))))
-
-
-#define MLBMAILBOX_IRQSTATUS___0_3WriteRegister32(baseAddress, bank, value)\
-{\
-    const u32 offset = MLB_MAILBOX_IRQSTATUS___REGSET_0_3_OFFSET +\
-    MLB_MAILBOX_IRQSTATUS___0_3_OFFSET +\
-    ((bank)*MLB_MAILBOX_IRQSTATUS___REGSET_0_3_STEP);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQSTATUS___0_3WriteRegister32);\
-    __raw_writel(newValue, ((baseAddress))+offset);\
-}
-
-
-#define MLBMAILBOX_IRQENABLE___0_3ReadRegister32(baseAddress, bank)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQENABLE___0_3ReadRegister32),\
-      __raw_readl(((baseAddress))+\
-      (MLB_MAILBOX_IRQENABLE___REGSET_0_3_OFFSET +\
-      MLB_MAILBOX_IRQENABLE___0_3_OFFSET+\
-       ((bank)*MLB_MAILBOX_IRQENABLE___REGSET_0_3_STEP))))
-
-
-#define MLBMAILBOX_IRQENABLE___0_3WriteRegister32(baseAddress, bank, value)\
-{\
-    const u32 offset = MLB_MAILBOX_IRQENABLE___REGSET_0_3_OFFSET +\
-      MLB_MAILBOX_IRQENABLE___0_3_OFFSET +\
-      ((bank)*MLB_MAILBOX_IRQENABLE___REGSET_0_3_STEP);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQENABLE___0_3WriteRegister32);\
-    __raw_writel(newValue, ((baseAddress))+offset);\
-}
-
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSSTATUSResetDoneRead32), \
+	(((__raw_readl((((u32)(baseAddress)) +				  \
+	(MLB_MAILBOX_SYSSTATUS_OFFSET)))) &				  \
+	MLB_MAILBOX_SYSSTATUS_ResetDone_MASK) >>			  \
+	MLB_MAILBOX_SYSSTATUS_ResetDone_OFFSET))
+
+#define MLBMAILBOX_MESSAGE___0_15ReadRegister32(baseAddress, bank)	      \
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_MESSAGE___0_15ReadRegister32), \
+	__raw_readl(((baseAddress)) +					      \
+	(MLB_MAILBOX_MESSAGE___REGSET_0_15_OFFSET +			      \
+	MLB_MAILBOX_MESSAGE___0_15_OFFSET +				      \
+	((bank) * MLB_MAILBOX_MESSAGE___REGSET_0_15_STEP))))
+
+#define MLBMAILBOX_MESSAGE___0_15WriteRegister32(baseAddress, bank, value)    \
+do {									      \
+	const u32 offset = MLB_MAILBOX_MESSAGE___REGSET_0_15_OFFSET +	      \
+	MLB_MAILBOX_MESSAGE___0_15_OFFSET +				      \
+	((bank) * MLB_MAILBOX_MESSAGE___REGSET_0_15_STEP);		      \
+	register u32 newValue = ((u32)(value));				      \
+	_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_MESSAGE___0_15WriteRegister32); \
+	__raw_writel(newValue, ((baseAddress)) + offset);		      \
+} while (0)
+
+#define MLBMAILBOX_FIFOSTATUS___0_15ReadRegister32(baseAddress, bank)	\
+	(_DEBUG_LEVEL_1_EASI						\
+	(EASIL1_MLBMAILBOX_FIFOSTATUS___0_15ReadRegister32),		\
+	__raw_readl(((u32)(baseAddress)) +				\
+	(MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_OFFSET +			\
+	MLB_MAILBOX_FIFOSTATUS___0_15_OFFSET +				\
+	((bank) * MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_STEP))))
+
+#define MLBMAILBOX_FIFOSTATUS___0_15FifoFullMBmRead32(baseAddress, bank) \
+	(_DEBUG_LEVEL_1_EASI(						 \
+	EASIL1_MLBMAILBOX_FIFOSTATUS___0_15FifoFullMBmRead32),		 \
+	(((__raw_readl(((baseAddress)) +				 \
+	(MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_OFFSET +			 \
+	MLB_MAILBOX_FIFOSTATUS___0_15_OFFSET +				 \
+	((bank) * MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_STEP)))) &	 \
+	MLB_MAILBOX_FIFOSTATUS___0_15_FifoFullMBm_MASK) >>		 \
+	MLB_MAILBOX_FIFOSTATUS___0_15_FifoFullMBm_OFFSET))
+
+#define MLBMAILBOX_MSGSTATUS___0_15NbOfMsgMBmRead32(baseAddress, bank)	\
+	(_DEBUG_LEVEL_1_EASI(						\
+	EASIL1_MLBMAILBOX_MSGSTATUS___0_15NbOfMsgMBmRead32),		\
+	(((__raw_readl(((baseAddress)) +				\
+	(MLB_MAILBOX_MSGSTATUS___REGSET_0_15_OFFSET +			\
+	MLB_MAILBOX_MSGSTATUS___0_15_OFFSET +				\
+	((bank) * MLB_MAILBOX_MSGSTATUS___REGSET_0_15_STEP)))) &	\
+	MLB_MAILBOX_MSGSTATUS___0_15_NbOfMsgMBm_MASK) >>		\
+	MLB_MAILBOX_MSGSTATUS___0_15_NbOfMsgMBm_OFFSET))
+
+#define MLBMAILBOX_IRQSTATUS___0_3ReadRegister32(baseAddress, bank)	       \
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQSTATUS___0_3ReadRegister32), \
+	__raw_readl(((baseAddress)) +					       \
+	(MLB_MAILBOX_IRQSTATUS___REGSET_0_3_OFFSET +			       \
+	MLB_MAILBOX_IRQSTATUS___0_3_OFFSET +				       \
+	((bank) * MLB_MAILBOX_IRQSTATUS___REGSET_0_3_STEP))))
+
+#define MLBMAILBOX_IRQSTATUS___0_3WriteRegister32(baseAddress, bank, value)    \
+do {									       \
+	const u32 offset = MLB_MAILBOX_IRQSTATUS___REGSET_0_3_OFFSET +	       \
+	MLB_MAILBOX_IRQSTATUS___0_3_OFFSET +				       \
+	((bank) * MLB_MAILBOX_IRQSTATUS___REGSET_0_3_STEP);		       \
+	register u32 newValue = ((u32)(value));				       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQSTATUS___0_3WriteRegister32); \
+	__raw_writel(newValue, ((baseAddress)) + offset);		       \
+} while (0)
+
+#define MLBMAILBOX_IRQENABLE___0_3ReadRegister32(baseAddress, bank)	       \
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQENABLE___0_3ReadRegister32), \
+	__raw_readl(((baseAddress)) +					       \
+	(MLB_MAILBOX_IRQENABLE___REGSET_0_3_OFFSET +			       \
+	MLB_MAILBOX_IRQENABLE___0_3_OFFSET +				       \
+	((bank) * MLB_MAILBOX_IRQENABLE___REGSET_0_3_STEP))))
+
+
+#define MLBMAILBOX_IRQENABLE___0_3WriteRegister32(baseAddress, bank, value)    \
+do {									       \
+	const u32 offset = MLB_MAILBOX_IRQENABLE___REGSET_0_3_OFFSET +	       \
+	MLB_MAILBOX_IRQENABLE___0_3_OFFSET +				       \
+	((bank)*MLB_MAILBOX_IRQENABLE___REGSET_0_3_STEP);		       \
+	register u32 newValue = ((u32)(value));				       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQENABLE___0_3WriteRegister32); \
+	__raw_writel(newValue, ((baseAddress)) + offset);		       \
+} while (0)
 
 #endif	/* USE_LEVEL_1_MACROS */
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/MMURegAcM.h kernel-power-2.6.28/drivers/dsp/bridge/hw/MMURegAcM.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/MMURegAcM.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/hw/MMURegAcM.h	2011-05-02 22:36:49.000000000 +0100
@@ -14,7 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
 #ifndef _MMU_REG_ACM_H
 #define _MMU_REG_ACM_H
 
@@ -26,227 +25,200 @@
 
 #if defined(USE_LEVEL_1_MACROS)
 
-
-#define MMUMMU_SYSCONFIGReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGReadRegister32),\
-      __raw_readl((baseAddress)+MMU_MMU_SYSCONFIG_OFFSET))
-
-
-#define MMUMMU_SYSCONFIGIdleModeWrite32(baseAddress, value)\
-{\
-    const u32 offset = MMU_MMU_SYSCONFIG_OFFSET;\
-    register u32 data = __raw_readl((baseAddress)+offset);\
-    register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGIdleModeWrite32);\
-    data &= ~(MMU_MMU_SYSCONFIG_IdleMode_MASK);\
-    newValue <<= MMU_MMU_SYSCONFIG_IdleMode_OFFSET;\
-    newValue &= MMU_MMU_SYSCONFIG_IdleMode_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, baseAddress+offset);\
-}
-
-
-#define MMUMMU_SYSCONFIGAutoIdleWrite32(baseAddress, value)\
-{\
-    const u32 offset = MMU_MMU_SYSCONFIG_OFFSET;\
-    register u32 data = __raw_readl((baseAddress)+offset);\
-    register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGAutoIdleWrite32);\
-    data &= ~(MMU_MMU_SYSCONFIG_AutoIdle_MASK);\
-    newValue <<= MMU_MMU_SYSCONFIG_AutoIdle_OFFSET;\
-    newValue &= MMU_MMU_SYSCONFIG_AutoIdle_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, baseAddress+offset);\
-}
-
-
-#define MMUMMU_IRQSTATUSReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQSTATUSReadRegister32),\
-      __raw_readl((baseAddress)+MMU_MMU_IRQSTATUS_OFFSET))
-
-
-#define MMUMMU_IRQSTATUSWriteRegister32(baseAddress, value)\
-{\
-    const u32 offset = MMU_MMU_IRQSTATUS_OFFSET;\
-    register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQSTATUSWriteRegister32);\
-    __raw_writel(newValue, (baseAddress)+offset);\
-}
-
-
-#define MMUMMU_IRQENABLEReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQENABLEReadRegister32),\
-      __raw_readl((baseAddress)+MMU_MMU_IRQENABLE_OFFSET))
-
-
-#define MMUMMU_IRQENABLEWriteRegister32(baseAddress, value)\
-{\
-    const u32 offset = MMU_MMU_IRQENABLE_OFFSET;\
-    register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQENABLEWriteRegister32);\
-    __raw_writel(newValue, (baseAddress)+offset);\
-}
-
-
-#define MMUMMU_WALKING_STTWLRunningRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_WALKING_STTWLRunningRead32),\
-      (((__raw_readl(((baseAddress)+(MMU_MMU_WALKING_ST_OFFSET))))\
-      & MMU_MMU_WALKING_ST_TWLRunning_MASK) >>\
-      MMU_MMU_WALKING_ST_TWLRunning_OFFSET))
-
-
-#define MMUMMU_CNTLTWLEnableRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLTWLEnableRead32),\
-      (((__raw_readl(((baseAddress)+(MMU_MMU_CNTL_OFFSET)))) &\
-      MMU_MMU_CNTL_TWLEnable_MASK) >>\
-      MMU_MMU_CNTL_TWLEnable_OFFSET))
-
-
-#define MMUMMU_CNTLTWLEnableWrite32(baseAddress, value)\
-{\
-    const u32 offset = MMU_MMU_CNTL_OFFSET;\
-    register u32 data = __raw_readl((baseAddress)+offset);\
-    register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLTWLEnableWrite32);\
-    data &= ~(MMU_MMU_CNTL_TWLEnable_MASK);\
-    newValue <<= MMU_MMU_CNTL_TWLEnable_OFFSET;\
-    newValue &= MMU_MMU_CNTL_TWLEnable_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, baseAddress+offset);\
-}
-
-
-#define MMUMMU_CNTLMMUEnableWrite32(baseAddress, value)\
-{\
-    const u32 offset = MMU_MMU_CNTL_OFFSET;\
-    register u32 data = __raw_readl((baseAddress)+offset);\
-    register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLMMUEnableWrite32);\
-    data &= ~(MMU_MMU_CNTL_MMUEnable_MASK);\
-    newValue <<= MMU_MMU_CNTL_MMUEnable_OFFSET;\
-    newValue &= MMU_MMU_CNTL_MMUEnable_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, baseAddress+offset);\
-}
-
-
-#define MMUMMU_FAULT_ADReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_FAULT_ADReadRegister32),\
-      __raw_readl((baseAddress)+MMU_MMU_FAULT_AD_OFFSET))
-
-
-#define MMUMMU_TTBWriteRegister32(baseAddress, value)\
-{\
-    const u32 offset = MMU_MMU_TTB_OFFSET;\
-    register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_TTBWriteRegister32);\
-    __raw_writel(newValue, (baseAddress)+offset);\
-}
-
-
-#define MMUMMU_LOCKReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKReadRegister32),\
-      __raw_readl((baseAddress)+MMU_MMU_LOCK_OFFSET))
-
-
-#define MMUMMU_LOCKWriteRegister32(baseAddress, value)\
-{\
-    const u32 offset = MMU_MMU_LOCK_OFFSET;\
-    register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKWriteRegister32);\
-    __raw_writel(newValue, (baseAddress)+offset);\
-}
-
-
-#define MMUMMU_LOCKBaseValueRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKBaseValueRead32),\
-      (((__raw_readl(((baseAddress)+(MMU_MMU_LOCK_OFFSET)))) &\
-      MMU_MMU_LOCK_BaseValue_MASK) >>\
-      MMU_MMU_LOCK_BaseValue_OFFSET))
-
-
-#define MMUMMU_LOCKBaseValueWrite32(baseAddress, value)\
-{\
-    const u32 offset = MMU_MMU_LOCK_OFFSET;\
-    register u32 data = __raw_readl((baseAddress)+offset);\
-    register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKBaseValueWrite32);\
-    data &= ~(MMU_MMU_LOCK_BaseValue_MASK);\
-    newValue <<= MMU_MMU_LOCK_BaseValue_OFFSET;\
-    newValue &= MMU_MMU_LOCK_BaseValue_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, baseAddress+offset);\
-}
-
-
-#define MMUMMU_LOCKCurrentVictimRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKCurrentVictimRead32),\
-      (((__raw_readl(((baseAddress)+(MMU_MMU_LOCK_OFFSET)))) &\
-      MMU_MMU_LOCK_CurrentVictim_MASK) >>\
-      MMU_MMU_LOCK_CurrentVictim_OFFSET))
-
-
-#define MMUMMU_LOCKCurrentVictimWrite32(baseAddress, value)\
-{\
-    const u32 offset = MMU_MMU_LOCK_OFFSET;\
-    register u32 data = __raw_readl((baseAddress)+offset);\
-    register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKCurrentVictimWrite32);\
-    data &= ~(MMU_MMU_LOCK_CurrentVictim_MASK);\
-    newValue <<= MMU_MMU_LOCK_CurrentVictim_OFFSET;\
-    newValue &= MMU_MMU_LOCK_CurrentVictim_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, baseAddress+offset);\
-}
-
-
-#define MMUMMU_LOCKCurrentVictimSet32(var, value)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKCurrentVictimSet32),\
-      (((var) & ~(MMU_MMU_LOCK_CurrentVictim_MASK)) |\
-      (((value) << MMU_MMU_LOCK_CurrentVictim_OFFSET) &\
-      MMU_MMU_LOCK_CurrentVictim_MASK)))
-
-
-#define MMUMMU_LD_TLBReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LD_TLBReadRegister32),\
-      __raw_readl((baseAddress)+MMU_MMU_LD_TLB_OFFSET))
-
-
-#define MMUMMU_LD_TLBWriteRegister32(baseAddress, value)\
-{\
-    const u32 offset = MMU_MMU_LD_TLB_OFFSET;\
-    register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LD_TLBWriteRegister32);\
-    __raw_writel(newValue, (baseAddress)+offset);\
-}
-
-
-#define MMUMMU_CAMWriteRegister32(baseAddress, value)\
-{\
-    const u32 offset = MMU_MMU_CAM_OFFSET;\
-    register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CAMWriteRegister32);\
-    __raw_writel(newValue, (baseAddress)+offset);\
-}
-
-
-#define MMUMMU_RAMWriteRegister32(baseAddress, value)\
-{\
-    const u32 offset = MMU_MMU_RAM_OFFSET;\
-    register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_RAMWriteRegister32);\
-    __raw_writel(newValue, (baseAddress)+offset);\
-}
-
-
-#define MMUMMU_FLUSH_ENTRYWriteRegister32(baseAddress, value)\
-{\
-    const u32 offset = MMU_MMU_FLUSH_ENTRY_OFFSET;\
-    register u32 newValue = (value);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_FLUSH_ENTRYWriteRegister32);\
-    __raw_writel(newValue, (baseAddress)+offset);\
-}
-
+#define MMUMMU_SYSCONFIGReadRegister32(baseAddress)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGReadRegister32),	\
+	__raw_readl((baseAddress) + MMU_MMU_SYSCONFIG_OFFSET))
+
+#define MMUMMU_SYSCONFIGIdleModeWrite32(baseAddress, value)		\
+do {									\
+	const u32 offset = MMU_MMU_SYSCONFIG_OFFSET;			\
+	register u32 data = __raw_readl((baseAddress) + offset);	\
+	register u32 newValue = (value);				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGIdleModeWrite32);	\
+	data &= ~(MMU_MMU_SYSCONFIG_IdleMode_MASK);			\
+	newValue <<= MMU_MMU_SYSCONFIG_IdleMode_OFFSET;			\
+	newValue &= MMU_MMU_SYSCONFIG_IdleMode_MASK;			\
+	newValue |= data;						\
+	__raw_writel(newValue, baseAddress + offset);			\
+} while (0)
+
+#define MMUMMU_SYSCONFIGAutoIdleWrite32(baseAddress, value)		\
+do {									\
+	const u32 offset = MMU_MMU_SYSCONFIG_OFFSET;			\
+	register u32 data = __raw_readl((baseAddress) + offset);	\
+	register u32 newValue = (value);				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGAutoIdleWrite32);	\
+	data &= ~(MMU_MMU_SYSCONFIG_AutoIdle_MASK);			\
+	newValue <<= MMU_MMU_SYSCONFIG_AutoIdle_OFFSET;			\
+	newValue &= MMU_MMU_SYSCONFIG_AutoIdle_MASK;			\
+	newValue |= data;						\
+	__raw_writel(newValue, baseAddress + offset);			\
+} while (0)
+
+#define MMUMMU_IRQSTATUSReadRegister32(baseAddress)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQSTATUSReadRegister32),	\
+	__raw_readl((baseAddress) + MMU_MMU_IRQSTATUS_OFFSET))
+
+#define MMUMMU_IRQSTATUSWriteRegister32(baseAddress, value)		\
+do {									\
+	const u32 offset = MMU_MMU_IRQSTATUS_OFFSET;			\
+	register u32 newValue = (value);				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQSTATUSWriteRegister32);	\
+	__raw_writel(newValue, (baseAddress) + offset);			\
+} while (0)
+
+#define MMUMMU_IRQENABLEReadRegister32(baseAddress)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQENABLEReadRegister32),	\
+	__raw_readl((baseAddress) + MMU_MMU_IRQENABLE_OFFSET))
+
+#define MMUMMU_IRQENABLEWriteRegister32(baseAddress, value)		\
+do {									\
+	const u32 offset = MMU_MMU_IRQENABLE_OFFSET;			\
+	register u32 newValue = (value);				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQENABLEWriteRegister32);	\
+	__raw_writel(newValue, (baseAddress) + offset);			\
+} while (0)
+
+#define MMUMMU_WALKING_STTWLRunningRead32(baseAddress)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_WALKING_STTWLRunningRead32),	\
+	(((__raw_readl(((baseAddress) + (MMU_MMU_WALKING_ST_OFFSET))))	\
+	& MMU_MMU_WALKING_ST_TWLRunning_MASK) >>			\
+	MMU_MMU_WALKING_ST_TWLRunning_OFFSET))
+
+#define MMUMMU_CNTLTWLEnableRead32(baseAddress)				\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLTWLEnableRead32),	\
+	(((__raw_readl(((baseAddress)+(MMU_MMU_CNTL_OFFSET)))) &	\
+	MMU_MMU_CNTL_TWLEnable_MASK) >>					\
+	MMU_MMU_CNTL_TWLEnable_OFFSET))
+
+#define MMUMMU_CNTLTWLEnableWrite32(baseAddress, value)			\
+do {									\
+	const u32 offset = MMU_MMU_CNTL_OFFSET;				\
+	register u32 data = __raw_readl((baseAddress) + offset);	\
+	register u32 newValue = (value);				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLTWLEnableWrite32);	\
+	data &= ~(MMU_MMU_CNTL_TWLEnable_MASK);				\
+	newValue <<= MMU_MMU_CNTL_TWLEnable_OFFSET;			\
+	newValue &= MMU_MMU_CNTL_TWLEnable_MASK;			\
+	newValue |= data;						\
+	__raw_writel(newValue, baseAddress+offset);			\
+} while (0)
+
+#define MMUMMU_CNTLMMUEnableWrite32(baseAddress, value)			\
+do {									\
+	const u32 offset = MMU_MMU_CNTL_OFFSET;				\
+	register u32 data = __raw_readl((baseAddress) + offset);	\
+	register u32 newValue = (value);				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLMMUEnableWrite32);	\
+	data &= ~(MMU_MMU_CNTL_MMUEnable_MASK);				\
+	newValue <<= MMU_MMU_CNTL_MMUEnable_OFFSET;			\
+	newValue &= MMU_MMU_CNTL_MMUEnable_MASK;			\
+	newValue |= data;						\
+	__raw_writel(newValue, baseAddress + offset);			\
+} while (0)
+
+#define MMUMMU_FAULT_ADReadRegister32(baseAddress)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_FAULT_ADReadRegister32),	\
+	__raw_readl((baseAddress) + MMU_MMU_FAULT_AD_OFFSET))
+
+#define MMUMMU_TTBWriteRegister32(baseAddress, value)			\
+do {									\
+	const u32 offset = MMU_MMU_TTB_OFFSET;				\
+	register u32 newValue = (value);				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_TTBWriteRegister32);		\
+	__raw_writel(newValue, (baseAddress) + offset);			\
+} while (0)
+
+#define MMUMMU_LOCKReadRegister32(baseAddress)				\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKReadRegister32),		\
+	__raw_readl((baseAddress) + MMU_MMU_LOCK_OFFSET))
+
+#define MMUMMU_LOCKWriteRegister32(baseAddress, value)			\
+do {									\
+	const u32 offset = MMU_MMU_LOCK_OFFSET;				\
+	register u32 newValue = (value);				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKWriteRegister32);		\
+	__raw_writel(newValue, (baseAddress) + offset);			\
+} while (0)
+
+#define MMUMMU_LOCKBaseValueRead32(baseAddress)				\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKBaseValueRead32),	\
+	(((__raw_readl(((baseAddress) + (MMU_MMU_LOCK_OFFSET)))) &	\
+	MMU_MMU_LOCK_BaseValue_MASK) >>	MMU_MMU_LOCK_BaseValue_OFFSET))	\
+
+#define MMUMMU_LOCKBaseValueWrite32(baseAddress, value)			\
+do {									\
+	const u32 offset = MMU_MMU_LOCK_OFFSET;				\
+	register u32 data = __raw_readl((baseAddress) + offset);	\
+	register u32 newValue = (value);				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKBaseValueWrite32);	\
+	data &= ~(MMU_MMU_LOCK_BaseValue_MASK);				\
+	newValue <<= MMU_MMU_LOCK_BaseValue_OFFSET;			\
+	newValue &= MMU_MMU_LOCK_BaseValue_MASK;			\
+	newValue |= data;						\
+	__raw_writel(newValue, baseAddress+offset);			\
+} while (0)
+
+#define MMUMMU_LOCKCurrentVictimRead32(baseAddress)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKCurrentVictimRead32),	\
+	(((__raw_readl(((baseAddress) + (MMU_MMU_LOCK_OFFSET)))) &	\
+	MMU_MMU_LOCK_CurrentVictim_MASK) >>				\
+	MMU_MMU_LOCK_CurrentVictim_OFFSET))
+
+#define MMUMMU_LOCKCurrentVictimWrite32(baseAddress, value)		\
+do {									\
+	const u32 offset = MMU_MMU_LOCK_OFFSET;				\
+	register u32 data = __raw_readl((baseAddress) + offset);	\
+	register u32 newValue = (value);				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKCurrentVictimWrite32);	\
+	data &= ~(MMU_MMU_LOCK_CurrentVictim_MASK);			\
+	newValue <<= MMU_MMU_LOCK_CurrentVictim_OFFSET;			\
+	newValue &= MMU_MMU_LOCK_CurrentVictim_MASK;			\
+	newValue |= data;						\
+	__raw_writel(newValue, baseAddress + offset);			\
+} while (0)
+
+#define MMUMMU_LOCKCurrentVictimSet32(var, value)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKCurrentVictimSet32),	\
+	(((var) & ~(MMU_MMU_LOCK_CurrentVictim_MASK)) |			\
+	(((value) << MMU_MMU_LOCK_CurrentVictim_OFFSET) &		\
+	MMU_MMU_LOCK_CurrentVictim_MASK)))
+
+#define MMUMMU_LD_TLBReadRegister32(baseAddress)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LD_TLBReadRegister32),	\
+	__raw_readl((baseAddress) + MMU_MMU_LD_TLB_OFFSET))
+
+#define MMUMMU_LD_TLBWriteRegister32(baseAddress, value)		\
+do {									\
+	const u32 offset = MMU_MMU_LD_TLB_OFFSET;			\
+	register u32 newValue = (value);				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LD_TLBWriteRegister32);	\
+	__raw_writel(newValue, (baseAddress) + offset);			\
+} while (0)
+
+#define MMUMMU_CAMWriteRegister32(baseAddress, value)			\
+do {									\
+	const u32 offset = MMU_MMU_CAM_OFFSET;				\
+	register u32 newValue = (value);				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CAMWriteRegister32);		\
+	__raw_writel(newValue, (baseAddress) + offset);			\
+} while (0)
+
+#define MMUMMU_RAMWriteRegister32(baseAddress, value)			\
+do {									\
+	const u32 offset = MMU_MMU_RAM_OFFSET;				\
+	register u32 newValue = (value);				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_RAMWriteRegister32);		\
+	__raw_writel(newValue, (baseAddress) + offset);			\
+} while (0)
+
+#define MMUMMU_FLUSH_ENTRYWriteRegister32(baseAddress, value)		\
+do {									\
+	const u32 offset = MMU_MMU_FLUSH_ENTRY_OFFSET;			\
+	register u32 newValue = (value);				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_FLUSH_ENTRYWriteRegister32);	\
+	__raw_writel(newValue, (baseAddress) + offset);			\
+} while (0)
 
 #endif	/* USE_LEVEL_1_MACROS */
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/PRCMRegAcM.h kernel-power-2.6.28/drivers/dsp/bridge/hw/PRCMRegAcM.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/PRCMRegAcM.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/hw/PRCMRegAcM.h	2011-05-02 22:36:49.000000000 +0100
@@ -26,644 +26,575 @@
 
 #if defined(USE_LEVEL_1_MACROS)
 
-#define PRCMPRCM_CLKCFG_CTRLValid_configWriteClk_valid32(baseAddress)\
-{\
-    const u32 offset = PRCM_PRCM_CLKCFG_CTRL_OFFSET;\
-    const u32 newValue = \
-	(u32)PRCMPRCM_CLKCFG_CTRLValid_configClk_valid <<\
-      PRCM_PRCM_CLKCFG_CTRL_Valid_config_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(\
-      EASIL1_PRCMPRCM_CLKCFG_CTRLValid_configWriteClk_valid32);\
-    data &= ~(PRCM_PRCM_CLKCFG_CTRL_Valid_config_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-
-#define CM_FCLKEN_PERReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),\
-      __raw_readl(((u32)(baseAddress))+CM_FCLKEN_PER_OFFSET))
-
-
-#define CM_ICLKEN_PERReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),\
-      __raw_readl(((u32)(baseAddress))+CM_ICLKEN_PER_OFFSET))
-
-
-#define CM_FCLKEN_PER_GPT5WriteRegister32(baseAddress,value)\
-{\
-    const u32 offset = CM_FCLKEN_PER_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_CM_FCLKEN_PER_GPT5WriteRegister32);\
-   data &= ~(CM_FCLKEN_PER_GPT5_MASK);\
-   newValue <<= CM_FCLKEN_PER_GPT5_OFFSET;\
-   newValue &= CM_FCLKEN_PER_GPT5_MASK;\
-   newValue |= data;\
-    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
-}
-
-
-#define CM_FCLKEN_PER_GPT6WriteRegister32(baseAddress,value)\
-{\
-    const u32 offset = CM_FCLKEN_PER_OFFSET;\
-    register u32 data =\
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_CM_FCLKEN_PER_GPT5WriteRegister32);\
-   data &= ~(CM_FCLKEN_PER_GPT6_MASK);\
-   newValue <<= CM_FCLKEN_PER_GPT6_OFFSET;\
-   newValue &= CM_FCLKEN_PER_GPT6_MASK;\
-   newValue |= data;\
-    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
-}
-
-
-#define CM_ICLKEN_PER_GPT5WriteRegister32(baseAddress,value)\
-{\
-    const u32 offset = CM_ICLKEN_PER_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_CM_ICLKEN_PER_GPT5WriteRegister32);\
-   data &= ~(CM_ICLKEN_PER_GPT5_MASK);\
-   newValue <<= CM_ICLKEN_PER_GPT5_OFFSET;\
-   newValue &= CM_ICLKEN_PER_GPT5_MASK;\
-   newValue |= data;\
-    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
-}
-
-
-#define CM_ICLKEN_PER_GPT6WriteRegister32(baseAddress,value)\
-{\
-    const u32 offset = CM_ICLKEN_PER_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_CM_ICLKEN_PER_GPT5WriteRegister32);\
-   data &= ~(CM_ICLKEN_PER_GPT6_MASK);\
-   newValue <<= CM_ICLKEN_PER_GPT6_OFFSET;\
-   newValue &= CM_ICLKEN_PER_GPT6_MASK;\
-   newValue |= data;\
-    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
-}
-
-
-#define CM_FCLKEN1_COREReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),\
-      __raw_readl(((u32)(baseAddress))+CM_FCLKEN1_CORE_OFFSET))
-
-
-#define PRCMCM_FCLKEN1_COREEN_GPT8Write32(baseAddress,value)\
-{\
-    const u32 offset = PRCM_CM_FCLKEN1_CORE_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT8Write32);\
-    data &= ~(PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK);\
-    newValue <<= PRCM_CM_FCLKEN1_CORE_EN_GPT8_OFFSET;\
-    newValue &= PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_FCLKEN1_COREEN_GPT7Write32(baseAddress,value)\
-{\
-    const u32 offset = PRCM_CM_FCLKEN1_CORE_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT7Write32);\
-    data &= ~(PRCM_CM_FCLKEN1_CORE_EN_GPT7_MASK);\
-    newValue <<= PRCM_CM_FCLKEN1_CORE_EN_GPT7_OFFSET;\
-    newValue &= PRCM_CM_FCLKEN1_CORE_EN_GPT7_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define CM_ICLKEN1_COREReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREReadRegister32),\
-      __raw_readl(((u32)(baseAddress))+CM_ICLKEN1_CORE_OFFSET))
-
-
-#define  CM_ICLKEN1_COREEN_MAILBOXESWrite32(baseAddress, value)\
-{\
-    const u32 offset = CM_ICLKEN1_CORE_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_MAILBOXESWrite32);\
-    data &= ~(CM_ICLKEN1_CORE_EN_MAILBOXES_MASK);\
-    newValue <<= CM_ICLKEN1_CORE_EN_MAILBOXES_OFFSET;\
-    newValue &= CM_ICLKEN1_CORE_EN_MAILBOXES_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_ICLKEN1_COREEN_GPT8Write32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_ICLKEN1_CORE_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT8Write32);\
-    data &= ~(PRCM_CM_ICLKEN1_CORE_EN_GPT8_MASK);\
-    newValue <<= PRCM_CM_ICLKEN1_CORE_EN_GPT8_OFFSET;\
-    newValue &= PRCM_CM_ICLKEN1_CORE_EN_GPT8_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_ICLKEN1_COREEN_GPT7Write32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_ICLKEN1_CORE_OFFSET;\
-    register u32 data =\
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT7Write32);\
-    data &= ~(PRCM_CM_ICLKEN1_CORE_EN_GPT7_MASK);\
-    newValue <<= PRCM_CM_ICLKEN1_CORE_EN_GPT7_OFFSET;\
-    newValue &= PRCM_CM_ICLKEN1_CORE_EN_GPT7_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8Write32k32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT832k <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8Write32k32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteSys32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8Sys <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteSys32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteExt32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8Ext <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteExt32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7Write32k32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT732k <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7Write32k32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteSys32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7Sys <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteSys32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteExt32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7Ext <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteExt32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteSys32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6Sys <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteSys32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteExt32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6Ext <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteExt32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-
-#define CM_CLKSEL_PER_GPT5Write32k32(baseAddress)\
-{\
-    const u32 offset = CM_CLKSEL_PER_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532k <<\
-      CM_CLKSEL_PER_GPT5_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_CM_CLKSEL_PER_GPT5Write32k32);\
-    data &= ~(CM_CLKSEL_PER_GPT5_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-
-#define CM_CLKSEL_PER_GPT6Write32k32(baseAddress)\
-{\
-    const u32 offset = CM_CLKSEL_PER_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532k <<\
-      CM_CLKSEL_PER_GPT6_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_CM_CLKSEL_PER_GPT6Write32k32);\
-    data &= ~(CM_CLKSEL_PER_GPT6_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteSys32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5Sys <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteSys32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteExt32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5Ext <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteExt32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_CLKSEL1_PLLAPLLs_ClkinRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL1_PLLAPLLs_ClkinRead32),\
-      (((__raw_readl((((u32)(baseAddress))+\
-	(PRCM_CM_CLKSEL1_PLL_OFFSET)))) &\
-      PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_MASK) >>\
-      PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_OFFSET))
-
-
-#define CM_FCLKEN_IVA2EN_DSPWrite32(baseAddress,value)\
-{\
-    const u32 offset = CM_FCLKEN_IVA2_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN_DSPEN_DSPWrite32);\
-    data &= ~(CM_FCLKEN_IVA2_EN_MASK);\
-    newValue <<= CM_FCLKEN_IVA2_EN_OFFSET;\
-    newValue &= CM_FCLKEN_IVA2_EN_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_ICLKEN_DSPEN_DSP_IPIWrite32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_ICLKEN_DSP_OFFSET;\
-    register u32 data = \
-      __raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN_DSPEN_DSP_IPIWrite32);\
-    data &= ~(PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK);\
-    newValue <<= PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_OFFSET;\
-    newValue &= PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_IDLEST_DSPReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPReadRegister32),\
-      __raw_readl(((u32)(baseAddress))+PRCM_CM_IDLEST_DSP_OFFSET))
-
-
-#define PRCMCM_IDLEST_DSPST_IPIRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_IPIRead32),\
-      (((__raw_readl((((u32)(baseAddress))+\
-	(PRCM_CM_IDLEST_DSP_OFFSET)))) &\
-      PRCM_CM_IDLEST_DSP_ST_IPI_MASK) >>\
-      PRCM_CM_IDLEST_DSP_ST_IPI_OFFSET))
+#define PRCMPRCM_CLKCFG_CTRLValid_configWriteClk_valid32(baseAddress)	       \
+do {									       \
+	const u32 offset = PRCM_PRCM_CLKCFG_CTRL_OFFSET;		       \
+	const u32 newValue = (u32)PRCMPRCM_CLKCFG_CTRLValid_configClk_valid << \
+			PRCM_PRCM_CLKCFG_CTRL_Valid_config_OFFSET;	       \
+	register u32 data = __raw_readl((u32)(baseAddress) + offset);	       \
+	_DEBUG_LEVEL_1_EASI(						       \
+		EASIL1_PRCMPRCM_CLKCFG_CTRLValid_configWriteClk_valid32);      \
+	data &= ~(PRCM_PRCM_CLKCFG_CTRL_Valid_config_MASK);		       \
+	data |= newValue;						       \
+	__raw_writel(data, (u32)(baseAddress) + offset);		       \
+} while (0)
+
+#define CM_FCLKEN_PERReadRegister32(baseAddress)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),	\
+	__raw_readl(((u32)(baseAddress)) + CM_FCLKEN_PER_OFFSET))
+
+#define CM_ICLKEN_PERReadRegister32(baseAddress)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),	\
+	__raw_readl(((u32)(baseAddress)) + CM_ICLKEN_PER_OFFSET))
+
+#define CM_FCLKEN_PER_GPT5WriteRegister32(baseAddress, value)		\
+do {									\
+	const u32 offset = CM_FCLKEN_PER_OFFSET;			\
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	\
+	register u32 newValue = ((u32)(value));				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_CM_FCLKEN_PER_GPT5WriteRegister32);	\
+	data &= ~(CM_FCLKEN_PER_GPT5_MASK);				\
+	newValue <<= CM_FCLKEN_PER_GPT5_OFFSET;				\
+	newValue &= CM_FCLKEN_PER_GPT5_MASK;				\
+	newValue |= data;						\
+	__raw_writel(newValue, ((u32)(baseAddress)) + offset);		\
+} while (0)
+
+#define CM_FCLKEN_PER_GPT6WriteRegister32(baseAddress, value)		\
+do {									\
+	const u32 offset = CM_FCLKEN_PER_OFFSET;			\
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	\
+	register u32 newValue = ((u32)(value));				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_CM_FCLKEN_PER_GPT5WriteRegister32);	\
+	data &= ~(CM_FCLKEN_PER_GPT6_MASK);				\
+	newValue <<= CM_FCLKEN_PER_GPT6_OFFSET;				\
+	newValue &= CM_FCLKEN_PER_GPT6_MASK;				\
+	newValue |= data;						\
+	__raw_writel(newValue, ((u32)(baseAddress)) + offset);		\
+} while (0)
+
+#define CM_ICLKEN_PER_GPT5WriteRegister32(baseAddress, value)		\
+do {									\
+	const u32 offset = CM_ICLKEN_PER_OFFSET;			\
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	\
+	register u32 newValue = ((u32)(value));				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_CM_ICLKEN_PER_GPT5WriteRegister32);	\
+	data &= ~(CM_ICLKEN_PER_GPT5_MASK);				\
+	newValue <<= CM_ICLKEN_PER_GPT5_OFFSET;				\
+	newValue &= CM_ICLKEN_PER_GPT5_MASK;				\
+	newValue |= data;						\
+	__raw_writel(newValue, ((u32)(baseAddress)) + offset);		\
+} while (0)
+
+#define CM_ICLKEN_PER_GPT6WriteRegister32(baseAddress, value)		\
+do {									\
+	const u32 offset = CM_ICLKEN_PER_OFFSET;			\
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	\
+	register u32 newValue = ((u32)(value));				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_CM_ICLKEN_PER_GPT5WriteRegister32);	\
+	data &= ~(CM_ICLKEN_PER_GPT6_MASK);				\
+	newValue <<= CM_ICLKEN_PER_GPT6_OFFSET;				\
+	newValue &= CM_ICLKEN_PER_GPT6_MASK;				\
+	newValue |= data;						\
+	__raw_writel(newValue, ((u32)(baseAddress)) + offset);		\
+} while (0)
+
+#define CM_FCLKEN1_COREReadRegister32(baseAddress)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),	\
+	__raw_readl(((u32)(baseAddress)) + CM_FCLKEN1_CORE_OFFSET))
+
+
+#define PRCMCM_FCLKEN1_COREEN_GPT8Write32(baseAddress, value)		\
+do {									\
+	const u32 offset = PRCM_CM_FCLKEN1_CORE_OFFSET;			\
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	\
+	register u32 newValue = ((u32)(value));				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT8Write32);	\
+	data &= ~(PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK);			\
+	newValue <<= PRCM_CM_FCLKEN1_CORE_EN_GPT8_OFFSET;		\
+	newValue &= PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK;			\
+	newValue |= data;						\
+	__raw_writel(newValue, (u32)(baseAddress) + offset);		\
+} while (0)
+
+#define PRCMCM_FCLKEN1_COREEN_GPT7Write32(baseAddress, value)		\
+do {									\
+	const u32 offset = PRCM_CM_FCLKEN1_CORE_OFFSET;			\
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	\
+	register u32 newValue = ((u32)(value));				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT7Write32);	\
+	data &= ~(PRCM_CM_FCLKEN1_CORE_EN_GPT7_MASK);			\
+	newValue <<= PRCM_CM_FCLKEN1_CORE_EN_GPT7_OFFSET;		\
+	newValue &= PRCM_CM_FCLKEN1_CORE_EN_GPT7_MASK;			\
+	newValue |= data;						\
+	__raw_writel(newValue, (u32)(baseAddress) + offset);		\
+} while (0)
+
+#define CM_ICLKEN1_COREReadRegister32(baseAddress)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREReadRegister32),	\
+	__raw_readl(((u32)(baseAddress)) + CM_ICLKEN1_CORE_OFFSET))
+
+#define CM_ICLKEN1_COREEN_MAILBOXESWrite32(baseAddress, value)		    \
+do {									    \
+	const u32 offset = CM_ICLKEN1_CORE_OFFSET;			    \
+	register u32 data = 						    \
+	__raw_readl(((u32)(baseAddress)) + offset);			    \
+	register u32 newValue = ((u32)(value));				    \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_MAILBOXESWrite32); \
+	data &= ~(CM_ICLKEN1_CORE_EN_MAILBOXES_MASK);			    \
+	newValue <<= CM_ICLKEN1_CORE_EN_MAILBOXES_OFFSET;		    \
+	newValue &= CM_ICLKEN1_CORE_EN_MAILBOXES_MASK;			    \
+	newValue |= data;						    \
+	__raw_writel(newValue, (u32)(baseAddress) + offset);		    \
+} while (0)
+
+#define PRCMCM_ICLKEN1_COREEN_GPT8Write32(baseAddress, value)		\
+do {									\
+	const u32 offset = PRCM_CM_ICLKEN1_CORE_OFFSET;			\
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	\
+	register u32 newValue = ((u32)(value));				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT8Write32);	\
+	data &= ~(PRCM_CM_ICLKEN1_CORE_EN_GPT8_MASK);			\
+	newValue <<= PRCM_CM_ICLKEN1_CORE_EN_GPT8_OFFSET;		\
+	newValue &= PRCM_CM_ICLKEN1_CORE_EN_GPT8_MASK;			\
+	newValue |= data;						\
+	__raw_writel(newValue, (u32)(baseAddress) + offset);		\
+} while (0)
+
+#define PRCMCM_ICLKEN1_COREEN_GPT7Write32(baseAddress, value)		\
+do {									\
+	const u32 offset = PRCM_CM_ICLKEN1_CORE_OFFSET;			\
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	\
+	register u32 newValue = ((u32)(value));				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT7Write32);	\
+	data &= ~(PRCM_CM_ICLKEN1_CORE_EN_GPT7_MASK);			\
+	newValue <<= PRCM_CM_ICLKEN1_CORE_EN_GPT7_OFFSET;		\
+	newValue &= PRCM_CM_ICLKEN1_CORE_EN_GPT7_MASK;			\
+	newValue |= data;						\
+	__raw_writel(newValue, (u32)(baseAddress) + offset);		\
+} while (0)
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8Write32k32(baseAddress)		      \
+do {									      \
+	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			      \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT832k <<	      \
+		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;		      \
+	register u32 data = __raw_readl((u32)(baseAddress) + offset);	      \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8Write32k32); \
+	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);		      \
+	data |= newValue;						      \
+	__raw_writel(data, (u32)(baseAddress) + offset);		      \
+} while (0)
+
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteSys32(baseAddress)		      \
+do {									      \
+	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			      \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8Sys <<	      \
+		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;		      \
+	register u32 data = __raw_readl((u32)(baseAddress) + offset);	      \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteSys32); \
+	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);		      \
+	data |= newValue;						      \
+	__raw_writel(data, (u32)(baseAddress) + offset);		      \
+} while (0)
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteExt32(baseAddress)		      \
+do {									      \
+	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			      \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8Ext <<	      \
+		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;		      \
+	register u32 data = __raw_readl((u32)(baseAddress) + offset);	      \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteExt32); \
+	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);		      \
+	data |= newValue;						      \
+	__raw_writel(data, (u32)(baseAddress) + offset);		      \
+} while (0)
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7Write32k32(baseAddress)		      \
+do {									      \
+	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			      \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT732k <<	      \
+		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;		      \
+	register u32 data = __raw_readl((u32)(baseAddress) + offset);	      \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7Write32k32); \
+	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);		      \
+	data |= newValue;						      \
+	__raw_writel(data, (u32)(baseAddress) + offset);		      \
+} while (0)
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteSys32(baseAddress)		      \
+do {									      \
+	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			      \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7Sys <<	      \
+		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;		      \
+	register u32 data = __raw_readl((u32)(baseAddress) + offset);	      \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteSys32); \
+	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);		      \
+	data |= newValue;						      \
+	__raw_writel(data, (u32)(baseAddress) + offset);		      \
+} while (0)
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteExt32(baseAddress)		       \
+do {									       \
+	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			       \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7Ext <<	       \
+		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;		       \
+	register u32 data = __raw_readl((u32)(baseAddress) + offset);	       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteExt32);  \
+	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);		       \
+	data |= newValue;						       \
+	__raw_writel(data, (u32)(baseAddress) + offset);		       \
+} while (0)
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteSys32(baseAddress)		       \
+do {									       \
+	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			       \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6Sys <<	       \
+		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_OFFSET;		       \
+	register u32 data = __raw_readl((u32)(baseAddress) + offset);	       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteSys32);  \
+	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_MASK);		       \
+	data |= newValue;						       \
+	__raw_writel(data, (u32)(baseAddress) + offset);		       \
+} while (0)
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteExt32(baseAddress)		       \
+do {									       \
+	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			       \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6Ext <<	       \
+		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_OFFSET;		       \
+	register u32 data = __raw_readl((u32)(baseAddress) + offset);	       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteExt32);  \
+	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_MASK);		       \
+	data |= newValue;						       \
+	__raw_writel(data, (u32)(baseAddress) + offset);		       \
+} while (0)
+
+#define CM_CLKSEL_PER_GPT5Write32k32(baseAddress)			       \
+do {									       \
+	const u32 offset = CM_CLKSEL_PER_OFFSET;			       \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532k <<	       \
+		CM_CLKSEL_PER_GPT5_OFFSET;				       \
+	register u32 data = __raw_readl((u32)(baseAddress) + offset);	       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_CM_CLKSEL_PER_GPT5Write32k32);	       \
+	data &= ~(CM_CLKSEL_PER_GPT5_MASK);				       \
+	data |= newValue;						       \
+	__raw_writel(data, (u32)(baseAddress) + offset);		       \
+} while (0)
+
+#define CM_CLKSEL_PER_GPT6Write32k32(baseAddress)			       \
+do {									       \
+	const u32 offset = CM_CLKSEL_PER_OFFSET;			       \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532k <<	       \
+		CM_CLKSEL_PER_GPT6_OFFSET;				       \
+	register u32 data = __raw_readl((u32)(baseAddress) + offset);	       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_CM_CLKSEL_PER_GPT6Write32k32);	       \
+	data &= ~(CM_CLKSEL_PER_GPT6_MASK);				       \
+	data |= newValue;						       \
+	__raw_writel(data, (u32)(baseAddress) + offset);		       \
+} while (0)
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteSys32(baseAddress)		       \
+do {									       \
+	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			       \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5Sys <<	       \
+		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET;		       \
+	register u32 data = __raw_readl((u32)(baseAddress) + offset);	       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteSys32);  \
+	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK);		       \
+	data |= newValue;						       \
+	__raw_writel(data, (u32)(baseAddress) + offset);		       \
+} while (0);
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteExt32(baseAddress)		       \
+do {									       \
+	const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;			       \
+	const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5Ext <<	       \
+		PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET;		       \
+	register u32 data = __raw_readl((u32)(baseAddress) + offset);	       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteExt32);  \
+	data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK);		       \
+	data |= newValue;						       \
+	__raw_writel(data, (u32)(baseAddress) + offset);		       \
+} while (0)
+
+#define PRCMCM_CLKSEL1_PLLAPLLs_ClkinRead32(baseAddress)		       \
+	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL1_PLLAPLLs_ClkinRead32),      \
+	(((__raw_readl((((u32)(baseAddress)) +				       \
+	(PRCM_CM_CLKSEL1_PLL_OFFSET)))) &				       \
+	PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_MASK) >>			       \
+	PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_OFFSET))
+
+#define CM_FCLKEN_IVA2EN_DSPWrite32(baseAddress, value)			       \
+do {									       \
+	const u32 offset = CM_FCLKEN_IVA2_OFFSET;			       \
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	       \
+	register u32 newValue = ((u32)(value));				       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN_DSPEN_DSPWrite32);	       \
+	data &= ~(CM_FCLKEN_IVA2_EN_MASK);				       \
+	newValue <<= CM_FCLKEN_IVA2_EN_OFFSET;				       \
+	newValue &= CM_FCLKEN_IVA2_EN_MASK;				       \
+	newValue |= data;						       \
+	__raw_writel(newValue, (u32)(baseAddress) + offset);		       \
+} while (0)
+
+#define PRCMCM_ICLKEN_DSPEN_DSP_IPIWrite32(baseAddress, value)		       \
+do {									       \
+	const u32 offset = PRCM_CM_ICLKEN_DSP_OFFSET;			       \
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	       \
+	register u32 newValue = ((u32)(value));				       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN_DSPEN_DSP_IPIWrite32);	       \
+	data &= ~(PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK);			       \
+	newValue <<= PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_OFFSET;		       \
+	newValue &= PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK;			       \
+	newValue |= data;						       \
+	__raw_writel(newValue, (u32)(baseAddress) + offset);		       \
+} while (0)
+
+#define PRCMCM_IDLEST_DSPReadRegister32(baseAddress)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPReadRegister32),	\
+	__raw_readl(((u32)(baseAddress)) + PRCM_CM_IDLEST_DSP_OFFSET))
+
+
+#define PRCMCM_IDLEST_DSPST_IPIRead32(baseAddress)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_IPIRead32),	\
+	(((__raw_readl((((u32)(baseAddress)) +				\
+	(PRCM_CM_IDLEST_DSP_OFFSET)))) &				\
+	PRCM_CM_IDLEST_DSP_ST_IPI_MASK) >>				\
+	PRCM_CM_IDLEST_DSP_ST_IPI_OFFSET))
 
 
 #define PRM_IDLEST_IVA2ST_IVA2Read32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_DSPRead32),\
-      (((__raw_readl((((u32)(baseAddress))+\
-	  (CM_IDLEST_IVA2_OFFSET)))) &\
-      CM_IDLEST_IVA2_ST_IVA2_MASK) >>\
-      CM_IDLEST_IVA2_ST_IVA2_OFFSET))
-
-
-#define PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPIWrite32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_AUTOIDLE_DSP_OFFSET;\
-    register u32 data =\
-      __raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPIWrite32);\
-    data &= ~(PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_MASK);\
-    newValue <<= PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_OFFSET;\
-    newValue &= PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_CLKSEL_DSPSYNC_DSPWrite32(baseAddress,value)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPSYNC_DSPWrite32);\
-    data &= ~(PRCM_CM_CLKSEL_DSP_SYNC_DSP_MASK);\
-    newValue <<= PRCM_CM_CLKSEL_DSP_SYNC_DSP_OFFSET;\
-    newValue &= PRCM_CM_CLKSEL_DSP_SYNC_DSP_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_CLKSEL_DSPCLKSEL_DSP_IFWrite32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;\
-    register u32 data = \
-      __raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_IFWrite32);\
-    data &= ~(PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_MASK);\
-    newValue <<= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_OFFSET;\
-    newValue &= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_CLKSEL_DSPCLKSEL_DSPWrite32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;\
-    register u32 data = \
-      __raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSPWrite32);\
-    data &= ~(PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK);\
-    newValue <<= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_OFFSET;\
-    newValue &= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMCM_CLKSTCTRL_IVA2WriteRegister32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_CLKSTCTRL_IVA2_OFFSET;\
-    register u32 data = \
-      __raw_readl(((baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_IVA2WriteRegister32);\
-    data &= ~(CM_CLKSTCTRL_IVA2_MASK);\
-    newValue <<= CM_CLKSTCTRL_IVA2_OFFSET;\
-    newValue &= CM_CLKSTCTRL_IVA2_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (baseAddress)+offset);\
-}
-
-
-#define PRCMCM_CLKSTCTRL_DSPAutostate_DSPRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPRead32),\
-      (((__raw_readl((((u32)(baseAddress))+\
-	(PRCM_CM_CLKSTCTRL_DSP_OFFSET)))) &\
-      PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK) >>\
-      PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_OFFSET))
-
-
-#define PRCMCM_CLKSTCTRL_DSPAutostate_DSPWrite32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_CLKSTCTRL_DSP_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPWrite32);\
-    data &= ~(PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK);\
-    newValue <<= PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_OFFSET;\
-    newValue &= PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMRM_RSTCTRL_DSPReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPReadRegister32),\
-      __raw_readl(((baseAddress))+PRCM_RM_RSTCTRL_DSP_OFFSET))
-
-
-#define PRM_RSTCTRL_IVA2RST1_DSPWrite32(baseAddress,value)\
-{\
-    const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;\
-    register u32 data =\
-    __raw_readl(((baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);\
-    data &= ~(PRM_RSTCTRL_IVA2_RST1_MASK);\
-    newValue <<= PRM_RSTCTRL_IVA2_RST1_OFFSET;\
-    newValue &= PRM_RSTCTRL_IVA2_RST1_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (baseAddress)+offset);\
-}
-
-
-#define PRM_RSTCTRL_IVA2RST2_DSPWrite32(baseAddress,value)\
-{\
-    const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;\
-    register u32 data =\
-	__raw_readl(((baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);\
-    data &= ~(PRM_RSTCTRL_IVA2_RST2_MASK);\
-    newValue <<= PRM_RSTCTRL_IVA2_RST2_OFFSET;\
-    newValue &= PRM_RSTCTRL_IVA2_RST2_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (baseAddress)+offset);\
-}
-
-
-#define PRM_RSTCTRL_IVA2RST3_DSPWrite32(baseAddress,value)\
-{\
-    const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;\
-    register u32 data =\
-      __raw_readl(((baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);\
-    data &= ~(PRM_RSTCTRL_IVA2_RST3_MASK);\
-    newValue <<= PRM_RSTCTRL_IVA2_RST3_OFFSET;\
-    newValue &= PRM_RSTCTRL_IVA2_RST3_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (baseAddress)+offset);\
-}
-
-
-#define PRCMRM_RSTST_DSPReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTST_DSPReadRegister32),\
-      __raw_readl(((baseAddress))+PRCM_RM_RSTST_DSP_OFFSET))
-
-
-#define PRCMRM_RSTST_DSPWriteRegister32(baseAddress,value)\
-{\
-    const u32 offset = PRCM_RM_RSTST_DSP_OFFSET;\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTST_DSPWriteRegister32);\
-    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
-}
-
-
-#define PRCMPM_PWSTCTRL_DSPForceStateWrite32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_PM_PWSTCTRL_DSP_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSPForceStateWrite32);\
-    data &= ~(PRCM_PM_PWSTCTRL_DSP_ForceState_MASK);\
-    newValue <<= PRCM_PM_PWSTCTRL_DSP_ForceState_OFFSET;\
-    newValue &= PRCM_PM_PWSTCTRL_DSP_ForceState_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-
-#define PRCMPM_PWSTCTRL_IVA2PowerStateWriteON32(baseAddress)\
-{\
-    const u32 offset = PRCM_PM_PWSTCTRL_IVA2_OFFSET;\
-    const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2PowerStateON <<\
-      PRCM_PM_PWSTCTRL_IVA2_PowerState_OFFSET;\
-    register u32 data = __raw_readl((baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteON32);\
-    data &= ~(PRCM_PM_PWSTCTRL_IVA2_PowerState_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (baseAddress)+offset);\
-}
-
-
-#define PRCMPM_PWSTCTRL_IVA2PowerStateWriteOFF32(baseAddress)\
-{\
-    const u32 offset = PRCM_PM_PWSTCTRL_IVA2_OFFSET;\
-    const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2PowerStateOFF <<\
-      PRCM_PM_PWSTCTRL_IVA2_PowerState_OFFSET;\
-    register u32 data = __raw_readl((baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteOFF32);\
-    data &= ~(PRCM_PM_PWSTCTRL_IVA2_PowerState_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (baseAddress)+offset);\
-}
-
-
-#define PRCMPM_PWSTCTRL_DSPPowerStateWriteRET32(baseAddress)\
-{\
-    const u32 offset = PRCM_PM_PWSTCTRL_DSP_OFFSET;\
-    const u32 newValue = (u32)PRCMPM_PWSTCTRL_DSPPowerStateRET <<\
-      PRCM_PM_PWSTCTRL_DSP_PowerState_OFFSET;\
-    register u32 data = __raw_readl((baseAddress)+offset);\
-    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSPPowerStateWriteRET32);\
-    data &= ~(PRCM_PM_PWSTCTRL_DSP_PowerState_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (baseAddress)+offset);\
-}
-
-
-#define PRCMPM_PWSTST_DSPReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_DSPReadRegister32),\
-      __raw_readl(((u32)(baseAddress))+PRCM_PM_PWSTST_DSP_OFFSET))
-
-
-#define PRCMPM_PWSTST_IVA2ReadRegister32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_IVA2ReadRegister32),\
-      __raw_readl((baseAddress) + PRCM_PM_PWSTST_IVA2_OFFSET))
-
-
-#define PRCMPM_PWSTST_DSPInTransitionRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_DSPInTransitionRead32),\
-      (((__raw_readl((((u32)(baseAddress))+\
-	(PRCM_PM_PWSTST_DSP_OFFSET)))) &\
-      PRCM_PM_PWSTST_DSP_InTransition_MASK) >>\
-      PRCM_PM_PWSTST_DSP_InTransition_OFFSET))
-
-
-#define PRCMPM_PWSTST_IVA2InTransitionRead32(baseAddress)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_IVA2InTransitionRead32),\
-      (((__raw_readl((((baseAddress))+\
-	(PRCM_PM_PWSTST_IVA2_OFFSET)))) &\
-      PRCM_PM_PWSTST_IVA2_InTransition_MASK) >>\
-      PRCM_PM_PWSTST_IVA2_InTransition_OFFSET))
-
-
-#define PRCMPM_PWSTST_DSPPowerStateStGet32(var)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_DSPPowerStateStGet32),\
-      (u32)((((u32)(var)) & PRCM_PM_PWSTST_DSP_PowerStateSt_MASK) >>\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_DSPRead32),	       \
+	(((__raw_readl((((u32)(baseAddress)) + (CM_IDLEST_IVA2_OFFSET)))) &    \
+	CM_IDLEST_IVA2_ST_IVA2_MASK) >>	CM_IDLEST_IVA2_ST_IVA2_OFFSET))
+
+#define PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPIWrite32(baseAddress, value)	       \
+do {									       \
+	const u32 offset = PRCM_CM_AUTOIDLE_DSP_OFFSET;			       \
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	       \
+	register u32 newValue = ((u32)(value));				       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPIWrite32);    \
+	data &= ~(PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_MASK);		       \
+	newValue <<= PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_OFFSET;		       \
+	newValue &= PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_MASK;		       \
+	newValue |= data;						       \
+	__raw_writel(newValue, (u32)(baseAddress) + offset);		       \
+} while (0)
+
+
+#define PRCMCM_CLKSEL_DSPSYNC_DSPWrite32(baseAddress, value)		       \
+do {									       \
+	const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;			       \
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	       \
+	register u32 newValue = ((u32)(value));				       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPSYNC_DSPWrite32);	       \
+	data &= ~(PRCM_CM_CLKSEL_DSP_SYNC_DSP_MASK);			       \
+	newValue <<= PRCM_CM_CLKSEL_DSP_SYNC_DSP_OFFSET;		       \
+	newValue &= PRCM_CM_CLKSEL_DSP_SYNC_DSP_MASK;			       \
+	newValue |= data;						       \
+	__raw_writel(newValue, (u32)(baseAddress) + offset);		       \
+} while (0)
+
+
+#define PRCMCM_CLKSEL_DSPCLKSEL_DSP_IFWrite32(baseAddress, value)	       \
+do {									       \
+	const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;			       \
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	       \
+	register u32 newValue = ((u32)(value));				       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_IFWrite32);     \
+	data &= ~(PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_MASK);		       \
+	newValue <<= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_OFFSET;		       \
+	newValue &= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_MASK;		       \
+	newValue |= data;						       \
+	__raw_writel(newValue, (u32)(baseAddress) + offset);		       \
+} while (0)
+
+#define PRCMCM_CLKSEL_DSPCLKSEL_DSPWrite32(baseAddress, value)		       \
+do {									       \
+	const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;			       \
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	       \
+	register u32 newValue = ((u32)(value));				       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSPWrite32);	       \
+	data &= ~(PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK);			       \
+	newValue <<= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_OFFSET;		       \
+	newValue &= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK;			       \
+	newValue |= data;						       \
+	__raw_writel(newValue, (u32)(baseAddress) + offset);		       \
+} while (0)
+
+#define PRCMCM_CLKSTCTRL_IVA2WriteRegister32(baseAddress, value)	       \
+do {									       \
+	const u32 offset = PRCM_CM_CLKSTCTRL_IVA2_OFFSET;		       \
+	register u32 data = __raw_readl(((baseAddress)) + offset);	       \
+	register u32 newValue = ((u32)(value));				       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_IVA2WriteRegister32);      \
+	data &= ~(CM_CLKSTCTRL_IVA2_MASK);				       \
+	newValue <<= CM_CLKSTCTRL_IVA2_OFFSET;				       \
+	newValue &= CM_CLKSTCTRL_IVA2_MASK;				       \
+	newValue |= data;						       \
+	__raw_writel(newValue, (baseAddress) + offset);			       \
+} while (0)
+
+
+#define PRCMCM_CLKSTCTRL_DSPAutostate_DSPRead32(baseAddress)		       \
+	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPRead32),  \
+	(((__raw_readl((((u32)(baseAddress)) +				       \
+	(PRCM_CM_CLKSTCTRL_DSP_OFFSET)))) &				       \
+	PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK) >>			       \
+	PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_OFFSET))
+
+#define PRCMCM_CLKSTCTRL_DSPAutostate_DSPWrite32(baseAddress, value)	       \
+do {									       \
+	const u32 offset = PRCM_CM_CLKSTCTRL_DSP_OFFSET;		       \
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	       \
+	register u32 newValue = ((u32)(value));				       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPWrite32);  \
+	data &= ~(PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK);		       \
+	newValue <<= PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_OFFSET;	       \
+	newValue &= PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK;		       \
+	newValue |= data;						       \
+	__raw_writel(newValue, (u32)(baseAddress) + offset);		       \
+} while (0)
+
+#define PRCMRM_RSTCTRL_DSPReadRegister32(baseAddress)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPReadRegister32),	\
+	__raw_readl(((baseAddress)) + PRCM_RM_RSTCTRL_DSP_OFFSET))
+
+#define PRM_RSTCTRL_IVA2RST1_DSPWrite32(baseAddress, value)		       \
+do {									       \
+	const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;			       \
+	register u32 data = __raw_readl(((baseAddress)) + offset);	       \
+	register u32 newValue = ((u32)(value));				       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);	       \
+	data &= ~(PRM_RSTCTRL_IVA2_RST1_MASK);				       \
+	newValue <<= PRM_RSTCTRL_IVA2_RST1_OFFSET;			       \
+	newValue &= PRM_RSTCTRL_IVA2_RST1_MASK;				       \
+	newValue |= data;						       \
+	__raw_writel(newValue, (baseAddress) + offset);			       \
+} while (0)
+
+#define PRM_RSTCTRL_IVA2RST2_DSPWrite32(baseAddress, value)		\
+do {									\
+	const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;			\
+	register u32 data = __raw_readl(((baseAddress)) + offset);	\
+	register u32 newValue = ((u32)(value));				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);	\
+	data &= ~(PRM_RSTCTRL_IVA2_RST2_MASK);				\
+	newValue <<= PRM_RSTCTRL_IVA2_RST2_OFFSET;			\
+	newValue &= PRM_RSTCTRL_IVA2_RST2_MASK;				\
+	newValue |= data;						\
+	__raw_writel(newValue, (baseAddress) + offset);			\
+} while (0)
+
+#define PRM_RSTCTRL_IVA2RST3_DSPWrite32(baseAddress, value)		\
+do {									\
+	const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;			\
+	register u32 data = __raw_readl(((baseAddress)) + offset);	\
+	register u32 newValue = ((u32)(value));				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);	\
+	data &= ~(PRM_RSTCTRL_IVA2_RST3_MASK);				\
+	newValue <<= PRM_RSTCTRL_IVA2_RST3_OFFSET;			\
+	newValue &= PRM_RSTCTRL_IVA2_RST3_MASK;				\
+	newValue |= data;						\
+	__raw_writel(newValue, (baseAddress) + offset);			\
+} while (0)
+
+#define PRCMRM_RSTST_DSPReadRegister32(baseAddress)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTST_DSPReadRegister32),	\
+	__raw_readl(((baseAddress)) + PRCM_RM_RSTST_DSP_OFFSET))
+
+#define PRCMRM_RSTST_DSPWriteRegister32(baseAddress, value)		\
+do {									\
+	const u32 offset = PRCM_RM_RSTST_DSP_OFFSET;			\
+	register u32 newValue = ((u32)(value));				\
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTST_DSPWriteRegister32);	\
+	__raw_writel(newValue, ((u32)(baseAddress)) + offset);		\
+} while (0)
+
+#define PRCMPM_PWSTCTRL_DSPForceStateWrite32(baseAddress, value)	  \
+do {									  \
+	const u32 offset = PRCM_PM_PWSTCTRL_DSP_OFFSET;			  \
+	register u32 data = __raw_readl(((u32)(baseAddress)) + offset);	  \
+	register u32 newValue = ((u32)(value));				  \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSPForceStateWrite32); \
+	data &= ~(PRCM_PM_PWSTCTRL_DSP_ForceState_MASK);		  \
+	newValue <<= PRCM_PM_PWSTCTRL_DSP_ForceState_OFFSET;		  \
+	newValue &= PRCM_PM_PWSTCTRL_DSP_ForceState_MASK;		  \
+	newValue |= data;						  \
+	__raw_writel(newValue, (u32)(baseAddress) + offset);		  \
+} while (0)
+
+#define PRCMPM_PWSTCTRL_IVA2PowerStateWriteON32(baseAddress)		       \
+do {									       \
+	const u32 offset = PRCM_PM_PWSTCTRL_IVA2_OFFSET;		       \
+	const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2PowerStateON <<	       \
+		PRCM_PM_PWSTCTRL_IVA2_PowerState_OFFSET;		       \
+	register u32 data = __raw_readl((baseAddress) + offset);	       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteON32);   \
+	data &= ~(PRCM_PM_PWSTCTRL_IVA2_PowerState_MASK);		       \
+	data |= newValue;						       \
+	__raw_writel(data, (baseAddress) + offset);			       \
+} while (0)
+
+#define PRCMPM_PWSTCTRL_IVA2PowerStateWriteOFF32(baseAddress)		       \
+do {									       \
+	const u32 offset = PRCM_PM_PWSTCTRL_IVA2_OFFSET;		       \
+	const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2PowerStateOFF <<	       \
+		PRCM_PM_PWSTCTRL_IVA2_PowerState_OFFSET;		       \
+	register u32 data = __raw_readl((baseAddress) + offset);	       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteOFF32);  \
+	data &= ~(PRCM_PM_PWSTCTRL_IVA2_PowerState_MASK);		       \
+	data |= newValue;						       \
+	__raw_writel(data, (baseAddress) + offset);			       \
+} while (0)
+
+#define PRCMPM_PWSTCTRL_DSPPowerStateWriteRET32(baseAddress)		       \
+do {									       \
+	const u32 offset = PRCM_PM_PWSTCTRL_DSP_OFFSET;			       \
+	const u32 newValue = (u32)PRCMPM_PWSTCTRL_DSPPowerStateRET <<	       \
+		PRCM_PM_PWSTCTRL_DSP_PowerState_OFFSET;			       \
+	register u32 data = __raw_readl((baseAddress) + offset);	       \
+	_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSPPowerStateWriteRET32);   \
+	data &= ~(PRCM_PM_PWSTCTRL_DSP_PowerState_MASK);		       \
+	data |= newValue;						       \
+	__raw_writel(data, (baseAddress) + offset);			       \
+} while (0)
+
+#define PRCMPM_PWSTST_DSPReadRegister32(baseAddress)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_DSPReadRegister32),	\
+	__raw_readl(((u32)(baseAddress)) + PRCM_PM_PWSTST_DSP_OFFSET))
+
+
+#define PRCMPM_PWSTST_IVA2ReadRegister32(baseAddress)			\
+	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_IVA2ReadRegister32),	\
+	__raw_readl((baseAddress) + PRCM_PM_PWSTST_IVA2_OFFSET))
+
+
+#define PRCMPM_PWSTST_DSPInTransitionRead32(baseAddress)		       \
+	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_DSPInTransitionRead32),      \
+	(((__raw_readl((((u32)(baseAddress)) + 				       \
+	(PRCM_PM_PWSTST_DSP_OFFSET)))) &				       \
+	PRCM_PM_PWSTST_DSP_InTransition_MASK) >>			       \
+	PRCM_PM_PWSTST_DSP_InTransition_OFFSET))
+
+#define PRCMPM_PWSTST_IVA2InTransitionRead32(baseAddress)		       \
+	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_IVA2InTransitionRead32),     \
+	(((__raw_readl((((baseAddress)) +	 			       \
+	(PRCM_PM_PWSTST_IVA2_OFFSET)))) &				       \
+	PRCM_PM_PWSTST_IVA2_InTransition_MASK) >>			       \
+	PRCM_PM_PWSTST_IVA2_InTransition_OFFSET))
+
+#define PRCMPM_PWSTST_DSPPowerStateStGet32(var)				       \
+	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_DSPPowerStateStGet32),       \
+	(u32)((((u32)(var)) & PRCM_PM_PWSTST_DSP_PowerStateSt_MASK) >>	       \
 	PRCM_PM_PWSTST_DSP_PowerStateSt_OFFSET))
 
-
-#define PRCMPM_PWSTST_IVA2PowerStateStGet32(var)\
-    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_IVA2PowerStateStGet32),\
-      (u32)((((u32)(var)) & PRCM_PM_PWSTST_IVA2_PowerStateSt_MASK) >>\
-      PRCM_PM_PWSTST_IVA2_PowerStateSt_OFFSET))
-
+#define PRCMPM_PWSTST_IVA2PowerStateStGet32(var)			       \
+	(_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_IVA2PowerStateStGet32),      \
+	(u32)((((u32)(var)) & PRCM_PM_PWSTST_IVA2_PowerStateSt_MASK) >>	       \
+	PRCM_PM_PWSTST_IVA2_PowerStateSt_OFFSET))
 
 #endif  /* USE_LEVEL_1_MACROS */
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_defs.h kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_defs.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_defs.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_defs.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Global HW definitions
+ *
  * Copyright (C) 2007 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,17 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== hw_defs.h ========
- *  Description:
- *      Global HW definitions
- *
- *! Revision History:
- *! ================
- *! 19 Apr 2004 sb: Added generic page size, endianness and element size defns
- *! 16 Feb 2003 sb: Initial version
- */
 #ifndef __HW_DEFS_H
 #define __HW_DEFS_H
 
@@ -39,11 +30,9 @@
 /* HW_STATUS:  return type for HW API */
 typedef long HW_STATUS;
 
-/* HW_SetClear_t:  Enumerated Type used to set and clear any bit */
-enum HW_SetClear_t {
-    HW_CLEAR,
-    HW_SET
-} ;
+/*  Macro used to set and clear any bit */
+#define HW_CLEAR	0
+#define HW_SET		1
 
 /* HW_Endianism_t:  Enumerated Type used to specify the endianism
  *		Do NOT change these values. They are used as bit fields. */
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_dspssC64P.c kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_dspssC64P.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_dspssC64P.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_dspssC64P.c	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * API definitions to configure DSP Subsystem modules like IPI
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,17 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== hw_dspss64P.c ========
- *  Description:
- *      API definitions to configure DSP Subsystem modules like IPI
- *
- *! Revision History:
- *! ================
- *! 19 Apr 2004 sb: Implemented HW_DSPSS_IPIEndianismSet
- *! 16 Feb 2003 sb: Initial version
- */
-
 /* PROJECT SPECIFIC INCLUDE FILES */
 #include <GlobalTypes.h>
 #include <linux/io.h>
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_dspssC64P.h kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_dspssC64P.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_dspssC64P.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_dspssC64P.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP Subsystem API declarations
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,19 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== hw_dspss.h ========
- *  Description:
- *      DSP Subsystem API declarations
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb: Removed redundant argument from HW_DSPSS_IPIEndianismSet
- *!		    Moved endianness and element size to generic hw_defs.h
- *! 16 Feb 2003 sb: Initial version
- */
-
 #ifndef __HW_DSPSS_H
 #define __HW_DSPSS_H
 #include <linux/types.h>
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_mbox.c kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_mbox.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_mbox.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_mbox.c	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Mailbox messaging & configuration API definitions
+ *
  * Copyright (C) 2007 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,17 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== hw_mbox.c ========
- *  Description:
- *      Mailbox messaging & configuration API definitions
- *
- *! Revision History:
- *! ================
- *! 16 Feb 2003 sb: Initial version
- */
-
 #include <GlobalTypes.h>
 #include "MLBRegAcM.h"
 #include <hw_defs.h>
@@ -33,10 +24,20 @@
 /* width in bits of MBOX Id */
 #define HW_MBOX_ID_WIDTH	   2
 
+/* SYSCONFIG: register bit definition */
+#define AUTOIDLE	(1 << 0)
+#define SMARTIDLE	(2 << 3)
+
 struct MAILBOX_CONTEXT mboxsetting = {
-	.sysconfig = 2 << 3 | 1, /* SMART/AUTO-IDLE */
+	.sysconfig = SMARTIDLE | AUTOIDLE,
 };
 
+HW_STATUS HW_MBOX_initSettings(void __iomem *baseAddress)
+{
+	MLBMAILBOX_SYSCONFIGWriteRegister32(baseAddress, SMARTIDLE | AUTOIDLE);
+	return RET_OK;
+}
+
 /* Saves the mailbox context */
 HW_STATUS HW_MBOX_saveSettings(void __iomem *baseAddress)
 {
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_mbox.h kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_mbox.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_mbox.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_mbox.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * HW Mailbox API and types definitions
+ *
  * Copyright (C) 2007 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,15 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== hw_mbox.h ========
- *  Description:
- *      HW Mailbox API and types definitions
- *
- *! Revision History:
- *! ================
- *! 16 Feb 2003 sb: Initial version
- */
 #ifndef __MBOX_H
 #define __MBOX_H
 
@@ -123,11 +116,8 @@ extern HW_STATUS HW_MBOX_MsgRead(const v
 * PURPOSE:      : this function writes a u32 from the sub module message
 *		 box Specified.
 */
-extern HW_STATUS HW_MBOX_MsgWrite(
-		      const void __iomem *baseAddress,
-		      const HW_MBOX_Id_t   mailBoxId,
-		      const u32	 writeValue
-		  );
+extern HW_STATUS HW_MBOX_MsgWrite(const void __iomem *baseAddress,
+			const HW_MBOX_Id_t mailBoxId, const u32 writeValue);
 
 /*
 * FUNCTION      : HW_MBOX_NumMsgGet
@@ -157,11 +147,8 @@ extern HW_STATUS HW_MBOX_MsgWrite(
 *
 * PURPOSE:      : this function gets number of messages in a specified mailbox.
 */
-extern HW_STATUS HW_MBOX_NumMsgGet(
-		      const void	 __iomem *baseAddress,
-		      const HW_MBOX_Id_t   mailBoxId,
-		      u32 *const	pNumMsg
-		  );
+extern HW_STATUS HW_MBOX_NumMsgGet(const void __iomem *baseAddress,
+			const HW_MBOX_Id_t mailBoxId, u32 *const pNumMsg);
 
 /*
 * FUNCTION      : HW_MBOX_EventEnable
@@ -193,12 +180,10 @@ extern HW_STATUS HW_MBOX_NumMsgGet(
 *
 * PURPOSE:      : this function enables the specified IRQ.
 */
-extern HW_STATUS HW_MBOX_EventEnable(
-		      const void __iomem *baseAddress,
-		      const HW_MBOX_Id_t       mailBoxId,
-		      const HW_MBOX_UserId_t   userId,
-		      const u32	     events
-		  );
+extern HW_STATUS HW_MBOX_EventEnable(const void __iomem *baseAddress,
+			const HW_MBOX_Id_t mailBoxId,
+			const HW_MBOX_UserId_t userId,
+			const u32 events);
 
 /*
 * FUNCTION      : HW_MBOX_EventDisable
@@ -230,12 +215,10 @@ extern HW_STATUS HW_MBOX_EventEnable(
 *
 * PURPOSE:      : this function disables the specified IRQ.
 */
-extern HW_STATUS HW_MBOX_EventDisable(
-		      const void __iomem *baseAddress,
-		      const HW_MBOX_Id_t       mailBoxId,
-		      const HW_MBOX_UserId_t   userId,
-		      const u32	     events
-		  );
+extern HW_STATUS HW_MBOX_EventDisable(const void __iomem *baseAddress,
+		const HW_MBOX_Id_t mailBoxId,
+		const HW_MBOX_UserId_t userId,
+		const u32 events);
 
 /*
 * FUNCTION      : HW_MBOX_EventAck
@@ -269,12 +252,32 @@ extern HW_STATUS HW_MBOX_EventDisable(
 *
 * PURPOSE:      : this function sets the status of the specified IRQ.
 */
-extern HW_STATUS HW_MBOX_EventAck(
-		      const void	__iomem *baseAddress,
-		      const HW_MBOX_Id_t	mailBoxId,
-		      const HW_MBOX_UserId_t    userId,
-		      const u32	      event
-		  );
+extern HW_STATUS HW_MBOX_EventAck(const void __iomem *baseAddress,
+			const HW_MBOX_Id_t mailBoxId,
+			const HW_MBOX_UserId_t userId,
+			const u32 event);
+
+/*
+* FUNCTION      : HW_MBOX_initSettings
+*
+* INPUTS:
+*
+*   Identifier  : baseAddress
+*   Type	: const u32
+*   Description : Base Address of instance of Mailbox module
+*
+*
+* RETURNS:
+*
+*   Type	: ReturnCode_t
+*   Description : RET_OK	      No errors occured
+*		 RET_BAD_NULL_PARAM  Address/pointer Paramater was set to 0/NULL
+*		 RET_INVALID_ID      Invalid Id used
+*		 RET_EMPTY	   Mailbox empty
+*
+* PURPOSE:      : This function initialize the mailbox configuration.
+*/
+extern HW_STATUS HW_MBOX_initSettings(void __iomem *baseAddres);
 
 /*
 * FUNCTION      : HW_MBOX_saveSettings
@@ -320,9 +323,4 @@ extern HW_STATUS HW_MBOX_saveSettings(vo
 */
 extern HW_STATUS HW_MBOX_restoreSettings(void __iomem *baseAddres);
 
-static inline void HW_MBOX_initSettings(void __iomem *baseAddres)
-{
-	HW_MBOX_restoreSettings(baseAddres);
-}
-
 #endif  /* __MBOX_H */
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_mmu.c kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_mmu.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_mmu.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_mmu.c	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * API definitions to setup MMU TLB and PTE
+ *
  * Copyright (C) 2007 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,21 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== hw_mmu.c ========
- *  Description:
- *      API definitions to setup MMU TLB and PTE
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb  TLBAdd and TLBFlush input the page size in bytes instead
-		    of an enum. TLBAdd inputs mapping attributes struct instead
-		    of individual arguments.
-		    Removed MMU.h and other cosmetic updates.
- *! 08-Mar-2004 sb  Added the Page Table Management APIs
- *! 16 Feb 2003 sb: Initial version
- */
-
 #include <GlobalTypes.h>
 #include <linux/io.h>
 #include "MMURegAcM.h"
@@ -350,8 +337,7 @@ HW_STATUS HW_MMU_TLBAdd(const void __iom
 			   u32	      pageSize,
 			   u32	      entryNum,
 			   struct HW_MMUMapAttrs_t    *mapAttrs,
-			   enum HW_SetClear_t       preservedBit,
-			   enum HW_SetClear_t       validBit)
+			   s8 preservedBit, s8 validBit)
 {
     HW_STATUS  status = RET_OK;
     u32 lockReg;
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_mmu.h kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_mmu.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_mmu.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_mmu.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * MMU types and API declarations
+ *
  * Copyright (C) 2007 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,19 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== hw_mmu.h ========
- *  Description:
- *      MMU types and API declarations
- *
- *! Revision History:
- *! ================
- *! 19-Apr-2004 sb  Moved & renamed endianness, page size, element size
-		    TLBAdd takes in MMUMapAttrs instead of separate arguments
- *! 08-Mar-2004 sb  Added the Page Table management APIs
- *! 16 Feb 2003 sb: Initial version
- */
 #ifndef __HW_MMU_H
 #define __HW_MMU_H
 
@@ -98,8 +87,7 @@ extern HW_STATUS HW_MMU_TLBAdd(const voi
 				  u32	   pageSize,
 				  u32	    entryNum,
 				  struct HW_MMUMapAttrs_t *mapAttrs,
-				  enum HW_SetClear_t    preservedBit,
-				  enum HW_SetClear_t    validBit);
+				  s8 preservedBit, s8 validBit);
 
 
 /* For PTEs */
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_prcm.c kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_prcm.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_prcm.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_prcm.c	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * API definitions to configure PRCM (Power, Reset & Clocks Manager)
+ *
  * Copyright (C) 2007 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,24 +16,13 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== hw_prcm.c ========
- *  Description:
- *      API definitions to configure PRCM (Power, Reset & Clocks Manager)
- *
- *! Revision History:
- *! ================
- *! 16 Feb 2003 sb: Initial version
- */
-
 #include <GlobalTypes.h>
 #include "PRCMRegAcM.h"
 #include <hw_defs.h>
 #include <hw_prcm.h>
 
 static HW_STATUS HW_RST_WriteVal(const void __iomem *baseAddress,
-				    enum HW_RstModule_t r,
-				    enum HW_SetClear_t val);
+				    enum HW_RstModule_t r, s8 val);
 
 HW_STATUS HW_RST_Reset(const void __iomem *baseAddress, enum HW_RstModule_t r)
 {
@@ -44,8 +35,7 @@ HW_STATUS HW_RST_UnReset(const void __io
 }
 
 static HW_STATUS HW_RST_WriteVal(const void __iomem *baseAddress,
-				    enum HW_RstModule_t r,
-				    enum HW_SetClear_t val)
+				    enum HW_RstModule_t r, s8 val)
 {
 	HW_STATUS status = RET_OK;
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_prcm.h kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_prcm.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/hw/hw_prcm.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/hw/hw_prcm.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * PRCM types and API declarations
+ *
  * Copyright (C) 2007 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,16 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== hw_prcm.h ========
- *  Description:
- *      PRCM types and API declarations
- *
- *! Revision History:
- *! ================
- *! 16 Feb 2003 sb: Initial version
- */
-
 #ifndef __HW_PRCM_H
 #define __HW_PRCM_H
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/chnl.c kernel-power-2.6.28/drivers/dsp/bridge/pmgr/chnl.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/chnl.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/pmgr/chnl.c	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * WCD channel interface: multiplexes data streams through the single
+ * physical link managed by a Bridge mini-driver.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,54 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== chnl.c ========
- *  Description:
- *      WCD channel interface: multiplexes data streams through the single
- *      physical link managed by a 'Bridge mini-driver.
- *
- *  Public Functions:
- *      CHNL_Close
- *      CHNL_CloseOrphans
- *      CHNL_Create
- *      CHNL_Destroy
- *      CHNL_Exit
- *      CHNL_GetHandle
- *      CHNL_GetProcessHandle
- *      CHNL_Init
- *      CHNL_Open
- *
- *  Notes:
- *      This interface is basically a pass through to the WMD CHNL functions,
- *      except for the CHNL_Get() accessor functions which call
- *      WMD_CHNL_GetInfo().
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 swa PMGR Code review comments incorporated.
- *! 07-Jan-2002 ag  CHNL_CloseOrphans() now closes supported # of channels.
- *! 17-Nov-2000 jeh Removed IRQ, shared memory stuff from CHNL_Create.
- *! 28-Feb-2000 rr: New GT USage Implementation
- *! 03-Feb-2000 rr: GT and Module init/exit Changes.(Done up front from
- *!		    SERVICES)
- *! 21-Jan-2000 ag: Added code review comments.
- *! 13-Jan-2000 rr: CFG_Get/SetPrivateDword renamed to CFG_Get/SetDevObject.
- *! 08-Dec-1999 ag: CHNL_[Alloc|Free]Buffer bufs taken from client process heap.
- *! 02-Dec-1999 ag: Implemented CHNL_GetEventHandle().
- *! 17-Nov-1999 ag: CHNL_AllocBuffer() allocs extra word for process mapping.
- *! 28-Oct-1999 ag: WinCE port. Search for "WinCE" for changes(TBR).
- *! 07-Jan-1998 gp: CHNL_[Alloc|Free]Buffer now call MEM_UMB functions.
- *! 22-Oct-1997 gp: Removed requirement in CHNL_Open that hReserved1 != NULL.
- *! 30-Aug-1997 cr: Renamed cfg.h wbwcd.h b/c of WINNT file name collision.
- *! 10-Mar-1997 gp: Added GT trace.
- *! 14-Jan-1997 gp: Updated based on code review feedback.
- *! 03-Jan-1997 gp: Moved CHNL_AllocBuffer/CHNL_FreeBuffer code from udspsys.
- *! 14-Dec-1996 gp: Added uChnlId parameter to CHNL_Open().
- *! 09-Sep-1996 gp: Added CHNL_GetProcessHandle().
- *! 15-Jul-1996 gp: Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -76,9 +31,6 @@
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/cfg.h>
-#include <dspbridge/csl.h>
-#include <dspbridge/dpc.h>
-#include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/sync.h>
 
@@ -153,10 +105,12 @@ DSP_STATUS CHNL_Create(OUT struct CHNL_M
 
 	if (DSP_SUCCEEDED(status)) {
 		struct WMD_DRV_INTERFACE *pIntfFxns;
-		DEV_GetIntfFxns(hDevObject, &pIntfFxns);
-		/* Let WMD channel module finish the create: */
-		status = (*pIntfFxns->pfnChnlCreate)(&hChnlMgr, hDevObject,
-			  pMgrAttrs);
+		status = DEV_GetIntfFxns(hDevObject, &pIntfFxns);
+		if (pIntfFxns) {
+			/* Let WMD channel module finish the create */
+			status = (*pIntfFxns->pfnChnlCreate)(&hChnlMgr,
+						hDevObject, pMgrAttrs);
+		}
 		if (DSP_SUCCEEDED(status)) {
 			/* Fill in WCD channel module's fields of the
 			 * CHNL_MGR structure */
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/chnlobj.h kernel-power-2.6.28/drivers/dsp/bridge/pmgr/chnlobj.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/chnlobj.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/pmgr/chnlobj.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Structure subcomponents of channel class library channel objects which
+ * are exposed to class driver from mini-driver.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,24 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== chnlobj.h ========
- *  Description:
- *      Structure subcomponents of channel class library channel objects which
- *      are exposed to class driver from mini-driver.
- *
- *  Public Functions:
- *      None.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 swa 	PMGR Code review comments incorporated.
- *! 17-Nov-2000 jeh     Removed some fields from CHNL_MGR_ to match CHNL_MGR
- *!                     structure defined in _chnl_sm.h.
- *! 16-Jan-1997 gp:     Created from chnlpriv.h
- */
-
 #ifndef CHNLOBJ_
 #define CHNLOBJ_
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/cmm.c kernel-power-2.6.28/drivers/dsp/bridge/pmgr/cmm.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/cmm.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/pmgr/cmm.c	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,22 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * The Communication(Shared) Memory Management(CMM) module provides
+ * shared memory management services for DSP/BIOS Bridge data streaming
+ * and messaging.
+ *
+ * Multiple shared memory segments can be registered with CMM.
+ * Each registered SM segment is represented by a SM "allocator" that
+ * describes a block of physically contiguous shared memory used for
+ * future allocations by CMM.
+ *
+ * Memory is coelesced back to the appropriate heap when a buffer is
+ * freed.
+ *
+ * Notes:
+ *   Va: Virtual address.
+ *   Pa: Physical or kernel system address.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,85 +30,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== cmm.c ========
- *  Purpose:
- *      The Communication(Shared) Memory Management(CMM) module provides
- *      shared memory management services for DSP/BIOS Bridge data streaming
- *      and messaging.
- *
- *      Multiple shared memory segments can be registered with CMM.
- *      Each registered SM segment is represented by a SM "allocator" that
- *      describes a block of physically contiguous shared memory used for
- *      future allocations by CMM.
- *
- *      Memory is coelesced back to the appropriate heap when a buffer is
- *      freed.
- *
- *  Public Functions:
- *      CMM_CallocBuf
- *      CMM_Create
- *      CMM_Destroy
- *      CMM_Exit
- *      CMM_FreeBuf
- *      CMM_GetHandle
- *      CMM_GetInfo
- *      CMM_Init
- *      CMM_RegisterGPPSMSeg
- *      CMM_UnRegisterGPPSMSeg
- *
- *      The CMM_Xlator[xxx] routines below are used by Node and Stream
- *      to perform SM address translation to the client process address space.
- *      A "translator" object is created by a node/stream for each SM seg used.
- *
- *  Translator Routines:
- *      CMM_XlatorAllocBuf
- *      CMM_XlatorCreate
- *      CMM_XlatorDelete
- *      CMM_XlatorFreeBuf
- *      CMM_XlatorInfo
- *      CMM_XlatorTranslate
- *
- *  Private Functions:
- *      AddToFreeList
- *      GetAllocator
- *      GetFreeBlock
- *      GetNode
- *      GetSlot
- *      UnRegisterGPPSMSeg
- *
- *  Notes:
- *      Va: Virtual address.
- *      Pa: Physical or kernel system address.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 swa PMGR Code review comments incorporated.
- *! 16-Feb-2002 ag  Code review cleanup.
- *!                 PreOMAP address translation no longner supported.
- *! 30-Jan-2002 ag  Updates to CMM_XlatorTranslate() per TII, ANSI C++
- *!                 warnings.
- *! 27-Jan-2002 ag  Removed unused CMM_[Alloc][Free]Desc() & #ifdef USELOOKUP,
- *!                 & unused VALIDATECMM and VaPaConvert().
- *!                 Removed bFastXlate from CMM_XLATOR. Always fast lookup.
- *! 03-Jan-2002 ag  Clear SM in CMM_AllocBuf(). Renamed to CMM_CallocBuf().
- *! 13-Nov-2001 ag  Now delete pNodeFreeListHead and nodes in CMM_Destroy().
- *! 28-Aug-2001 ag  CMM_GetHandle() returns CMM Mgr hndle given HPROCESSOR.
- *!                 Removed unused CMM_[Un]RegisterDSPSMSeg() &
- *                  CMM_[Un}ReserveVirtSpace fxns. Some cleanup.
- *! 12-Aug-2001 ag  Exposed CMM_UnRegisterGPP[DSP]SMSeg.
- *! 13-Feb-2001 kc  DSP/BIOS Bridge name update.
- *! 21-Dec-2000 rr  GetFreeBlock checks for pAllocator.
- *! 09-Dec-2000 ag  Added GPPPA2DSPPA, DSPPA2GPPPA macros.
- *! 05-Dec-2000 ag  CMM_XlatorDelete() optionally frees SM bufs and descriptors.
- *! 30-Oct-2000 ag  Buf size bug fixed in CMM_AllocBuf() causing leak.
- *!                 Revamped XlatorTranslate() routine.
- *! 10-Oct-2000 ag  Added CMM_Xlator[xxx] functions.
- *! 02-Aug-2000 ag  Created.
- *!
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
@@ -107,7 +44,7 @@
 #include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/sync.h>
-#include <dspbridge/util.h>
+#include <dspbridge/utildefs.h>
 
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/dev.h>
@@ -142,8 +79,7 @@ struct CMM_ALLOCATOR {	/* sma */
 				 * context for 'sma') */
 	u32 dwDSPPhysAddrOffset;	/* DSP PA to GPP PA offset for this
 					 * SM space */
-	/* CMM_ADDTO[SUBFROM]DSPPA, _POMAPEMIF2DSPBUS */
-	enum CMM_CNVTTYPE cFactor;
+	s8 cFactor;			/* DSPPa to GPPPa Conversion Factor */
 	unsigned int dwDSPBase;	/* DSP virt base byte address */
 	u32 ulDSPSize;	/* DSP seg size in bytes */
 	struct CMM_OBJECT *hCmmMgr;	/* back ref to parent mgr */
@@ -199,7 +135,7 @@ static struct CMM_XLATORATTRS CMM_DFLTXL
 
 /* SM node representing a block of memory. */
 struct CMM_MNODE {
-	struct LST_ELEM link;		/* must be 1st element */
+	struct list_head link;		/* must be 1st element */
 	u32 dwPA;		/* Phys addr */
 	u32 dwVA;		/* Virtual address in device process context */
 	u32 ulSize;		/* SM block size in bytes */
@@ -275,8 +211,10 @@ void *CMM_CallocBuf(struct CMM_OBJECT *h
 				pNewNode = GetNode(pCmmMgr, pNode->dwPA + uSize,
 					   pNode->dwVA + uSize,
 					   (u32)uDeltaSize);
-				/* leftovers go free */
-				AddToFreeList(pAllocator, pNewNode);
+				if (pNewNode) {
+					/* leftovers go free */
+					AddToFreeList(pAllocator, pNewNode);
+				}
 				/* adjust our node's size */
 				pNode->ulSize = uSize;
 			}
@@ -289,7 +227,7 @@ void *CMM_CallocBuf(struct CMM_OBJECT *h
 
 			/* put our node on InUse list */
 			LST_PutTail(pAllocator->pInUseListHead,
-				   (struct LST_ELEM *)pNode);
+				   (struct list_head *)pNode);
 			pBufPA = (void *)pNode->dwPA;	/* physical address */
 			/* clear mem */
 			pByte = (u8 *)pNode->dwVA;
@@ -359,12 +297,15 @@ DSP_STATUS CMM_Create(OUT struct CMM_OBJ
 		 * MEM_AllocObject */
 		if (DSP_SUCCEEDED(status)) {
 			/* create node free list */
-			pCmmObject->pNodeFreeListHead = LST_Create();
+			pCmmObject->pNodeFreeListHead = MEM_Calloc(sizeof(struct
+				LST_LIST), MEM_NONPAGED);
 			if (pCmmObject->pNodeFreeListHead == NULL) {
 				GT_0trace(CMM_debugMask, GT_7CLASS,
-					  "CMM_Create: LST_Create() "
-					  "failed \n");
+					  "CMM_Create: Out of memory\n");
 				status = DSP_EMEMORY;
+			} else {
+				INIT_LIST_HEAD(&pCmmObject->pNodeFreeListHead->
+					head);
 			}
 		}
 		if (DSP_SUCCEEDED(status))
@@ -428,14 +369,12 @@ DSP_STATUS CMM_Destroy(struct CMM_OBJECT
 	if (pCmmMgr->pNodeFreeListHead != NULL) {
 		/* Free the free nodes */
 		while (!LST_IsEmpty(pCmmMgr->pNodeFreeListHead)) {
-			/* (struct LST_ELEM*) pNode =
-			 * LST_GetHead(pCmmMgr->pNodeFreeListHead);*/
 			pNode = (struct CMM_MNODE *)LST_GetHead(pCmmMgr->
 				 pNodeFreeListHead);
 			MEM_Free(pNode);
 		}
 		/* delete NodeFreeList list */
-		LST_Delete(pCmmMgr->pNodeFreeListHead);
+		MEM_Free(pCmmMgr->pNodeFreeListHead);
 	}
 	SYNC_LeaveCS(pCmmMgr->hCmmLock);
 	if (DSP_SUCCEEDED(status)) {
@@ -496,7 +435,7 @@ DSP_STATUS CMM_FreeBuf(struct CMM_OBJECT
 			if ((u32)pBufPA == pCurNode->dwPA) {
 				/* Found it */
 				LST_RemoveElem(pAllocator->pInUseListHead,
-					      (struct LST_ELEM *)pCurNode);
+					      (struct list_head *)pCurNode);
 				/* back to freelist */
 				AddToFreeList(pAllocator, pCurNode);
 				status = DSP_SOK;	/* all right! */
@@ -504,7 +443,8 @@ DSP_STATUS CMM_FreeBuf(struct CMM_OBJECT
 			}
 			/* next node. */
 			pCurNode = (struct CMM_MNODE *)LST_Next(pAllocator->
-				   pInUseListHead, (struct LST_ELEM *)pCurNode);
+					pInUseListHead,
+					(struct list_head *)pCurNode);
 		}
 		SYNC_LeaveCS(pCmmMgr->hCmmLock);
 	}
@@ -517,7 +457,7 @@ DSP_STATUS CMM_FreeBuf(struct CMM_OBJECT
  *      Return the communication memory manager object for this device.
  *      This is typically called from the client process.
  */
-DSP_STATUS CMM_GetHandle(DSP_HPROCESSOR hProcessor,
+DSP_STATUS CMM_GetHandle(void *hProcessor,
 			OUT struct CMM_OBJECT **phCmmMgr)
 {
 	DSP_STATUS status = DSP_SOK;
@@ -590,7 +530,7 @@ DSP_STATUS CMM_GetInfo(struct CMM_OBJECT
 				/* next node. */
 				pCurNode = (struct CMM_MNODE *)LST_Next(pAltr->
 					pInUseListHead,
-					(struct LST_ELEM *)pCurNode);
+					(struct list_head *)pCurNode);
 			}
 		}
 	}		/* end for */
@@ -632,7 +572,7 @@ bool CMM_Init(void)
  */
 DSP_STATUS CMM_RegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr, u32 dwGPPBasePA,
 				u32 ulSize, u32 dwDSPAddrOffset,
-				enum CMM_CNVTTYPE cFactor, u32 dwDSPBase,
+				s8 cFactor, u32 dwDSPBase,
 				u32 ulDSPSize, u32 *pulSegId,
 				u32 dwGPPBaseVA)
 {
@@ -699,25 +639,29 @@ DSP_STATUS CMM_RegisterGPPSMSeg(struct C
 			/* return the actual segment identifier */
 			*pulSegId = (u32) nSlot + 1;
 			/* create memory free list */
-			pSMA->pFreeListHead = LST_Create();
+			pSMA->pFreeListHead = MEM_Calloc(sizeof(struct
+				LST_LIST), MEM_NONPAGED);
 			if (pSMA->pFreeListHead == NULL) {
 				GT_0trace(CMM_debugMask, GT_7CLASS,
 					  "CMM_RegisterGPPSMSeg: "
-					  "Out Of Memory \n");
+					  "Out Of Memory 1\n");
 				status = DSP_EMEMORY;
 				goto func_end;
 			}
+			INIT_LIST_HEAD(&pSMA->pFreeListHead->head);
 		}
 		if (DSP_SUCCEEDED(status)) {
 			/* create memory in-use list */
-			pSMA->pInUseListHead = LST_Create();
+			pSMA->pInUseListHead = MEM_Calloc(sizeof(struct
+				LST_LIST), MEM_NONPAGED);
 			if (pSMA->pInUseListHead == NULL) {
 				GT_0trace(CMM_debugMask, GT_7CLASS,
 					  "CMM_RegisterGPPSMSeg: "
-					  "LST_Create failed\n");
+					  "Out of memory 2\n");
 				status = DSP_EMEMORY;
 				goto func_end;
 			}
+			INIT_LIST_HEAD(&pSMA->pInUseListHead->head);
 		}
 		if (DSP_SUCCEEDED(status)) {
 			/* Get a mem node for this hunk-o-memory */
@@ -726,7 +670,7 @@ DSP_STATUS CMM_RegisterGPPSMSeg(struct C
 			/* Place node on the SM allocator's free list */
 			if (pNewNode) {
 				LST_PutTail(pSMA->pFreeListHead,
-					   (struct LST_ELEM *)pNewNode);
+					   (struct list_head *)pNewNode);
 			} else {
 				status = DSP_EMEMORY;
 				goto func_end;
@@ -820,27 +764,27 @@ static void UnRegisterGPPSMSeg(struct CM
 		while (pCurNode) {
 			pNextNode = (struct CMM_MNODE *)LST_Next(pSMA->
 				     pFreeListHead,
-				    (struct LST_ELEM *)pCurNode);
+				    (struct list_head *)pCurNode);
 			LST_RemoveElem(pSMA->pFreeListHead,
-				      (struct LST_ELEM *)pCurNode);
+				      (struct list_head *)pCurNode);
 			MEM_Free((void *) pCurNode);
 			/* next node. */
 			pCurNode = pNextNode;
 		}
-		LST_Delete(pSMA->pFreeListHead);	/* delete freelist */
+		MEM_Free(pSMA->pFreeListHead);		/* delete freelist */
 		/* free nodes on InUse list */
 		pCurNode = (struct CMM_MNODE *)LST_First(pSMA->pInUseListHead);
 		while (pCurNode) {
 			pNextNode = (struct CMM_MNODE *)LST_Next(pSMA->
 				    pInUseListHead,
-				    (struct LST_ELEM *)pCurNode);
+				    (struct list_head *)pCurNode);
 			LST_RemoveElem(pSMA->pInUseListHead,
-				      (struct LST_ELEM *)pCurNode);
+				      (struct list_head *)pCurNode);
 			MEM_Free((void *) pCurNode);
 			/* next node. */
 			pCurNode = pNextNode;
 		}
-		LST_Delete(pSMA->pInUseListHead);	/* delete InUse list */
+		MEM_Free(pSMA->pInUseListHead);		/* delete InUse list */
 	}
 	if ((void *) pSMA->dwVmBase != NULL)
 		MEM_UnmapLinearAddress((void *) pSMA->dwVmBase);
@@ -893,15 +837,13 @@ static struct CMM_MNODE *GetNode(struct 
 			MEM_PAGED);
 	} else {
 		/* surely a valid element */
-		/* (struct LST_ELEM*) pNode = LST_GetHead(pCmmMgr->
-		 * pNodeFreeListHead);*/
 		pNode = (struct CMM_MNODE *)LST_GetHead(pCmmMgr->
 			pNodeFreeListHead);
 	}
 	if (pNode == NULL) {
 		GT_0trace(CMM_debugMask, GT_7CLASS, "GetNode: Out Of Memory\n");
 	} else {
-		LST_InitElem((struct LST_ELEM *) pNode);	/* set self */
+		LST_InitElem((struct list_head *) pNode);	/* set self */
 		pNode->dwPA = dwPA;	/* Physical addr of start of block */
 		pNode->dwVA = dwVA;	/* Virtual   "            "        */
 		pNode->ulSize = ulSize;	/* Size of block */
@@ -918,8 +860,8 @@ static struct CMM_MNODE *GetNode(struct 
 static void DeleteNode(struct CMM_OBJECT *pCmmMgr, struct CMM_MNODE *pNode)
 {
 	DBC_Require(pNode != NULL);
-	LST_InitElem((struct LST_ELEM *) pNode);	/* init .self ptr */
-	LST_PutTail(pCmmMgr->pNodeFreeListHead, (struct LST_ELEM *) pNode);
+	LST_InitElem((struct list_head *) pNode);	/* init .self ptr */
+	LST_PutTail(pCmmMgr->pNodeFreeListHead, (struct list_head *) pNode);
 }
 
 /*
@@ -937,12 +879,13 @@ static struct CMM_MNODE *GetFreeBlock(st
 		while (pCurNode) {
 			if (uSize <= (u32) pCurNode->ulSize) {
 				LST_RemoveElem(pAllocator->pFreeListHead,
-					      (struct LST_ELEM *)pCurNode);
+					      (struct list_head *)pCurNode);
 				return pCurNode;
 			}
 			/* next node. */
 			pCurNode = (struct CMM_MNODE *)LST_Next(pAllocator->
-				    pFreeListHead, (struct LST_ELEM *)pCurNode);
+					pFreeListHead,
+					(struct list_head *)pCurNode);
 		}
 	}
 	return NULL;
@@ -977,7 +920,8 @@ static void AddToFreeList(struct CMM_ALL
 		if ((pNodePrev == NULL) || (pNodeNext == NULL)) {
 			/* next node. */
 			pCurNode = (struct CMM_MNODE *)LST_Next(pAllocator->
-				    pFreeListHead, (struct LST_ELEM *)pCurNode);
+					pFreeListHead,
+					(struct list_head *)pCurNode);
 		} else {
 			/* got 'em */
 			break;
@@ -986,7 +930,7 @@ static void AddToFreeList(struct CMM_ALL
 	if (pNodePrev != NULL) {
 		/* combine with previous block */
 		LST_RemoveElem(pAllocator->pFreeListHead,
-			      (struct LST_ELEM *)pNodePrev);
+			      (struct list_head *)pNodePrev);
 		/* grow node to hold both */
 		pNode->ulSize += pNodePrev->ulSize;
 		pNode->dwPA = pNodePrev->dwPA;
@@ -997,7 +941,7 @@ static void AddToFreeList(struct CMM_ALL
 	if (pNodeNext != NULL) {
 		/* combine with next block */
 		LST_RemoveElem(pAllocator->pFreeListHead,
-			      (struct LST_ELEM *)pNodeNext);
+			      (struct list_head *)pNodeNext);
 		/* grow da node */
 		pNode->ulSize += pNodeNext->ulSize;
 		/* place node on mgr nodeFreeList */
@@ -1011,17 +955,17 @@ static void AddToFreeList(struct CMM_ALL
 
 		/* next node. */
 		pCurNode = (struct CMM_MNODE *)LST_Next(pAllocator->
-			   pFreeListHead, (struct LST_ELEM *)pCurNode);
+			   pFreeListHead, (struct list_head *)pCurNode);
 	}
 	/* if pCurNode is NULL then add our pNode to the end of the freelist */
 	if (pCurNode == NULL) {
 		LST_PutTail(pAllocator->pFreeListHead,
-			   (struct LST_ELEM *)pNode);
+			   (struct list_head *)pNode);
 	} else {
 		/* insert our node before the current traversed node */
 		LST_InsertBefore(pAllocator->pFreeListHead,
-				(struct LST_ELEM *)pNode,
-				(struct LST_ELEM *)pCurNode);
+				(struct list_head *)pNode,
+				(struct list_head *)pCurNode);
 	}
 }
 
@@ -1050,6 +994,12 @@ static struct CMM_ALLOCATOR *GetAllocato
 }
 
 /*
+ *  The CMM_Xlator[xxx] routines below are used by Node and Stream
+ *  to perform SM address translation to the client process address space.
+ *  A "translator" object is created by a node/stream for each SM seg used.
+ */
+
+/*
  *  ======== CMM_XlatorCreate ========
  *  Purpose:
  *      Create an address translator object.
@@ -1101,11 +1051,10 @@ DSP_STATUS CMM_XlatorDelete(struct CMM_X
 
 	DBC_Require(cRefs > 0);
 
-	if (MEM_IsValidHandle(pXlator, CMMXLATESIGNATURE)) {
+	if (MEM_IsValidHandle(pXlator, CMMXLATESIGNATURE))
 		MEM_FreeObject(pXlator);
-	} else {
+	else
 		status = DSP_EHANDLE;
-	}
 
 	return status;
 }
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/cod.c kernel-power-2.6.28/drivers/dsp/bridge/pmgr/cod.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/cod.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/pmgr/cod.c	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,12 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This module implements DSP code management for the DSP/BIOS Bridge
+ * environment. It is mostly a thin wrapper.
+ *
+ * This module provides an interface for loading both static and
+ * dynamic code objects onto DSP systems.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,49 +20,10 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== cod.c ========
- *  This module implements DSP code management for the DSP/BIOS Bridge
- *  environment. It is mostly a thin wrapper.
- *
- *  This module provides an interface for loading both static and
- *  dynamic code objects onto DSP systems.
- *
- *! Revision History
- *! ================
- *! 08-Apr-2003 map: Consolidated DBL to DBLL loader name
- *! 24-Feb-2003 swa: PMGR Code review comments incorporated.
- *! 18-Apr-2002 jeh: Added DBL function tables.
- *! 20-Nov-2001 jeh: Removed call to ZL_loadArgs function.
- *! 19-Oct-2001 jeh: Access DBL as a static library. Added COD_GetBaseLib,
- *!		  COD_GetLoader, removed COD_LoadSection, COD_UnloadSection.
- *! 07-Sep-2001 jeh: Added COD_LoadSection(), COD_UnloadSection().
- *! 07-Aug-2001 rr:  hMgr->baseLib is updated after zlopen in COD_LoadBase.
- *! 18-Apr-2001 jeh: Check for fLoaded flag before ZL_unload, to allow
- *!		  COD_OpenBase to be used.
- *! 11-Jan-2001 jeh: Added COD_OpenBase (not used yet, since there is an
- *!		  occasional crash).
- *! 02-Aug-2000 kc:  Added COD_ReadSection to COD module. Incorporates use
- *!		  of ZL_readSect (new function in ZL module).
- *! 28-Feb-2000 rr:  New GT Usage Implementation
- *! 08-Dec-1999 ag:  Removed x86 specific __asm int 3.
- *! 02-Oct-1999 ag:  Added #ifdef DEBUGINT3COD for debug.
- *! 20-Sep-1999 ag:  Removed call to GT_set().
- *! 04-Jun-1997 cr:  Added validation of argc/argv pair in COD_LoadBase, as it
- *!		     is a requirement to ZL_loadArgs.
- *! 31-May-1997 cr:  Changed COD_LoadBase argc value from u32 to int, added
- *!	       DSP_ENOTIMPL return value to COD_Create when attrs != NULL.
- *! 29-May-1997 cr:  Added debugging support.
- *! 24-Oct-1996 gp:  Added COD_GetSection().
- *! 18-Jun-1996 gp:  Updated GetSymValue() to check for lib; updated E_ codes.
- *! 12-Jun-1996 gp:  Imported CSL_ services for strcpyn(); Added ref counting.
- *! 20-May-1996 mg:  Adapted for new MEM and LDR modules.
- *! 08-May-1996 mg:  Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
 
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
@@ -68,8 +35,6 @@
 #include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
-#include <dspbridge/kfile.h>
 #include <dspbridge/ldr.h>
 #include <dspbridge/mem.h>
 
@@ -137,6 +102,101 @@ static struct DBLL_Fxns dbllFxns = {
 static bool NoOp(void);
 
 /*
+ * File operations (originally were under kfile.c)
+ */
+static s32 COD_fClose(struct file *hFile)
+{
+	/* Check for valid handle */
+	if (!hFile)
+		return DSP_EHANDLE;
+
+	filp_close(hFile, NULL);
+
+	/* we can't use DSP_SOK here */
+	return 0;
+}
+
+static struct file *COD_fOpen(CONST char *pszFileName, CONST char *pszMode)
+{
+	mm_segment_t fs;
+	struct file *hFile;
+
+	fs = get_fs();
+	set_fs(get_ds());
+
+	/* ignore given mode and open file as read-only */
+	hFile = filp_open(pszFileName, O_RDONLY, 0);
+
+	if (IS_ERR(hFile))
+		hFile = NULL;
+
+	set_fs(fs);
+
+	return hFile;
+}
+
+static s32 COD_fRead(void __user *pBuffer, s32 cSize, s32 cCount,
+		     struct file *hFile)
+{
+	/* check for valid file handle */
+	if (!hFile)
+		return DSP_EHANDLE;
+
+	if ((cSize > 0) && (cCount > 0) && pBuffer) {
+		u32 dwBytesRead;
+		mm_segment_t fs;
+
+		/* read from file */
+		fs = get_fs();
+		set_fs(get_ds());
+		dwBytesRead = hFile->f_op->read(hFile, pBuffer, cSize * cCount,
+						&(hFile->f_pos));
+		set_fs(fs);
+
+		if (!dwBytesRead)
+			return DSP_EFREAD;
+
+		return dwBytesRead / cSize;
+	}
+
+	return DSP_EINVALIDARG;
+}
+
+static s32 COD_fSeek(struct file *hFile, s32 lOffset, s32 cOrigin)
+{
+	loff_t dwCurPos;
+
+	/* check for valid file handle */
+	if (!hFile)
+		return DSP_EHANDLE;
+
+	/* based on the origin flag, move the internal pointer */
+	dwCurPos = hFile->f_op->llseek(hFile, lOffset, cOrigin);
+
+	if ((s32)dwCurPos < 0)
+		return DSP_EFAIL;
+
+	/* we can't use DSP_SOK here */
+	return 0;
+}
+
+static s32 COD_fTell(struct file *hFile)
+{
+	loff_t dwCurPos;
+
+	if (!hFile)
+		return DSP_EHANDLE;
+
+	/* Get current position */
+	dwCurPos = hFile->f_op->llseek(hFile, 0, SEEK_CUR);
+
+	if ((s32)dwCurPos < 0)
+		return DSP_EFAIL;
+
+	return dwCurPos;
+}
+
+/*
  *  ======== COD_Close ========
  */
 void COD_Close(struct COD_LIBRARYOBJ *lib)
@@ -200,11 +260,11 @@ DSP_STATUS COD_Create(OUT struct COD_MAN
 
 	zlAttrs.alloc = (DBLL_AllocFxn)NoOp;
 	zlAttrs.free = (DBLL_FreeFxn)NoOp;
-	zlAttrs.fread = (DBLL_ReadFxn)KFILE_Read;
-	zlAttrs.fseek = (DBLL_SeekFxn)KFILE_Seek;
-	zlAttrs.ftell = (DBLL_TellFxn)KFILE_Tell;
-	zlAttrs.fclose = (DBLL_FCloseFxn)KFILE_Close;
-	zlAttrs.fopen = (DBLL_FOpenFxn)KFILE_Open;
+	zlAttrs.fread = (DBLL_ReadFxn)COD_fRead;
+	zlAttrs.fseek = (DBLL_SeekFxn)COD_fSeek;
+	zlAttrs.ftell = (DBLL_TellFxn)COD_fTell;
+	zlAttrs.fclose = (DBLL_FCloseFxn)COD_fClose;
+	zlAttrs.fopen = (DBLL_FOpenFxn)COD_fOpen;
 	zlAttrs.symLookup = NULL;
 	zlAttrs.baseImage = true;
 	zlAttrs.logWrite = NULL;
@@ -308,7 +368,7 @@ DSP_STATUS COD_GetBaseName(struct COD_MA
 	DBC_Require(pszName != NULL);
 
 	if (uSize <= COD_MAXPATHLENGTH)
-               strncpy(pszName, hManager->szZLFile, uSize);
+		strncpy(pszName, hManager->szZLFile, uSize);
 	else
 		status = DSP_EFAIL;
 
@@ -341,7 +401,7 @@ DSP_STATUS COD_GetEntry(struct COD_MANAG
  *      Get handle to the DBLL loader.
  */
 DSP_STATUS COD_GetLoader(struct COD_MANAGER *hManager,
-			       struct DBLL_TarObj **phLoader)
+				struct DBLL_TarObj **phLoader)
 {
 	DSP_STATUS status = DSP_SOK;
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/dbl.c kernel-power-2.6.28/drivers/dsp/bridge/pmgr/dbl.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/dbl.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/pmgr/dbl.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1385 +0,0 @@
-/*
- * dbl.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dbl.c ========
- *  Dynamic BOF Loader library. Contains functions related to
- *  loading and unloading symbols/code/data on DSP.
- *  Also contains other support functions.
- *
- *! Revision History
- *! ================
- *! 24-Feb-2003 swa 	PMGR Code review comments incorporated.
- *! 24-May-2002 jeh     Free DCD sects in DBL_close().
- *! 19-Mar-2002 jeh     Changes made to match dynamic loader (dbll.c): Pass
- *!		     DBL_Library to DBL_getAddr() instead of DBL_Target,
- *!		     eliminate scope param, use DBL_Symbol. Pass attrs to
- *!		     DBL_load(), DBL_unload().
- *! 20-Nov-2001 jeh     Removed DBL_loadArgs().
- *! 07-Sep-2001 jeh     Added overlay support.
- *! 31-Jul-2001 jeh     Include windows.h.
- *! 06-Jun-2001 jeh     Created.
- */
-
-/*  ----------------------------------- Host OS */
-#include <dspbridge/host_os.h>
-
-/*  ----------------------------------- DSP/BIOS Bridge */
-#include <dspbridge/std.h>
-#include <dspbridge/dbdefs.h>
-#include <dspbridge/errbase.h>
-
-/*  ----------------------------------- Trace & Debug */
-#include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
-
-/*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
-#include <dspbridge/mem.h>
-#include <dspbridge/kfile.h>
-
-/*  ----------------------------------- This */
-#include <dspbridge/dbof.h>
-#include <dspbridge/dbl.h>
-
-#define DBL_TARGSIGNATURE      0x544c4244	/* "TLBD" */
-#define DBL_LIBSIGNATURE       0x4c4c4244	/* "LLBD" */
-
-#define C54TARG	 0
-#define C55TARG	 1
-#define NUMTARGS	2
-
-#define C54MAGIC	0x98	/* Magic number for TI C54 COF  */
-#define C55MAGIC	0x9c	/* Magic number for LEAD3 (C55) COF  */
-
-/* Three task phases */
-#define CREATEPHASE 0
-#define DELETEPHASE 1
-#define EXECUTEPHASE 2
-#define NONE 3		/* For overlay section with phase not specified */
-
-/* Default load buffer size */
-#define LOADBUFSIZE     0x800
-
-#define SWAPLONG(x) ((((x) << 24) & 0xFF000000) | (((x) << 8) & 0xFF0000L) | \
-		      (((x) >> 8) & 0xFF00L) | (((x) >> 24) & 0xFF))
-
-#define SWAPWORD(x) ((((x) << 8) & 0xFF00) | (((x) >> 8) & 0xFF))
-
-/*
- *  Macros for accessing the following types of overlay data within a
- *  structure of type OvlyData:
- *      - Overlay data not associated with a particular phase
- *      - Create phase overlay data
- *      - Delete phase overlay data
- *      - Execute phase overlay data
- */
-#define numOtherSects(pOvlyData)    ((pOvlyData)->hdr.dbofHdr.numOtherSects)
-#define numCreateSects(pOvlyData)   ((pOvlyData)->hdr.dbofHdr.numCreateSects)
-#define numDeleteSects(pOvlyData)   ((pOvlyData)->hdr.dbofHdr.numDeleteSects)
-#define numExecuteSects(pOvlyData)  ((pOvlyData)->hdr.dbofHdr.numExecuteSects)
-#define otherOffset(pOvlyData)      0
-#define createOffset(pOvlyData)     ((pOvlyData)->hdr.dbofHdr.numOtherSects)
-#define deleteOffset(pOvlyData)     (createOffset(pOvlyData) + \
-				     (pOvlyData->hdr.dbofHdr.numCreateSects))
-#define executeOffset(pOvlyData)    (deleteOffset(pOvlyData) + \
-				     (pOvlyData->hdr.dbofHdr.numDeleteSects))
-/*
- *  ======== OvlyHdr ========
- */
-struct OvlyHdr {
-	struct DBOF_OvlySectHdr dbofHdr;
-	char *pName; 		/* Name of overlay section */
-	u16 createRef; 	/* Reference count for create phase */
-	u16 deleteRef; 	/* Reference count for delete phase */
-	u16 executeRef; 	/* Execute phase ref count */
-	u16 otherRef; 		/* Unspecified phase ref count */
-} ;
-
-/*
- *  ======== OvlyData ========
- */
-struct OvlyData {
-	struct OvlyHdr hdr;
-	struct DBOF_OvlySectData data[1];
-} ;
-
-/*
- *  ======== Symbol ========
- */
-struct Symbol {
-	struct DBL_Symbol sym;
-	char *pSymName;
-};
-
-/*
- *  ======== DCDSect ========
- */
-struct DCDSect {
-	struct DBOF_DCDSectHdr sectHdr;
-	char *pData;
-} ;
-
-/*
- *  ======== DBL_TargetObj ========
- */
-struct DBL_TargetObj {
-	u32 dwSignature; 	/* For object validation */
-	struct DBL_Attrs dblAttrs; 	/* file read, write, etc. functions */
-	char *pBuf; 		/* Load buffer */
-};
-
-/*
- *  ======== TargetInfo ========
- */
-struct TargetInfo {
-	u16 dspType; 		/* eg, C54TARG, C55TARG */
-	u32 magic; 		/* COFF magic number, identifies target type */
-	u16 wordSize; 	/* Size of a DSP word */
-	u16 mauSize; 		/* Size of minimum addressable unit */
-	u16 charSize; 	/* For C55x, mausize = 1, but charsize = 2 */
-} ;
-
-/*
- *  ======== DBL_LibraryObj ========
- *  Represents a library loaded on a target.
- */
-struct DBL_LibraryObj {
-	u32 dwSignature; 	/* For object validation */
-	struct DBL_TargetObj *pTarget; 	/* Target for this library */
-	struct KFILE_FileObj *file; 	/* DBOF file handle */
-	bool byteSwapped; 	/* Are bytes swapped? */
-	struct DBOF_FileHdr fileHdr; 	/* Header of DBOF file */
-	u16 nSymbols; 		/* Number of DSP/Bridge symbols */
-	struct Symbol *symbols; 	/* Table of DSP/Bridge symbols */
-	u16 nDCDSects; 	/* Number of DCD sections */
-	u16 nOvlySects; 	/* Number of overlay nodes */
-	struct DCDSect *dcdSects; 	/* DCD section data */
-	struct OvlyData **ppOvlyData; 	/* Array of overlay section data */
-	struct TargetInfo *pTargetInfo; 	/* Entry in targetTab[] below */
-} ;
-
-#if GT_TRACE
-static struct GT_Mask DBL_debugMask = { NULL, NULL }; 	/* GT trace variable */
-#endif
-
-static u32 cRefs; 		/* module reference count */
-
-static u32 magicTab[NUMTARGS] = { C54MAGIC, C55MAGIC };
-
-static struct TargetInfo targetTab[] = {
-	/* targ     magic       wordsize    mausize    charsize */
-	{C54TARG, C54MAGIC, 2, 2, 2}, 	/* C54  */
-	{C55TARG, C55MAGIC, 2, 1, 2}, 	/* C55  */
-};
-
-static void freeSects(struct DBL_TargetObj *dbl, struct OvlyData *pOvlyData,
-		     s32 offset, s32 nSects);
-static DSP_STATUS loadSect(struct DBL_TargetObj *dbl,
-			  struct DBL_LibraryObj *pdblLib);
-static DSP_STATUS readDCDSects(struct DBL_TargetObj *dbl,
-			      struct DBL_LibraryObj *pdblLib);
-static DSP_STATUS readHeader(struct DBL_TargetObj *dbl,
-			    struct DBL_LibraryObj *pdblLib);
-static DSP_STATUS readOvlySects(struct DBL_TargetObj *dbl,
-				struct DBL_LibraryObj *pdblLib);
-static DSP_STATUS readSymbols(struct DBL_TargetObj *dbl,
-			     struct DBL_LibraryObj *pdblLib);
-
-/*
- *  ======== DBL_close ========
- *  Purpose:
- *  	Close library opened with DBL_open.
- */
-void DBL_close(struct DBL_LibraryObj *lib)
-{
-	struct DBL_LibraryObj *pdblLib = (struct DBL_LibraryObj *)lib;
-	u16 i;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(pdblLib, DBL_LIBSIGNATURE));
-
-	GT_1trace(DBL_debugMask, GT_ENTER, "DBL_close: lib: 0x%x\n", lib);
-
-	/* Free symbols */
-	if (pdblLib->symbols) {
-		for (i = 0; i < pdblLib->nSymbols; i++) {
-			if (pdblLib->symbols[i].pSymName)
-				MEM_Free(pdblLib->symbols[i].pSymName);
-
-		}
-		MEM_Free(pdblLib->symbols);
-	}
-
-	/* Free DCD sects */
-	if (pdblLib->dcdSects) {
-		for (i = 0; i < pdblLib->nDCDSects; i++) {
-			if (pdblLib->dcdSects[i].pData)
-				MEM_Free(pdblLib->dcdSects[i].pData);
-
-		}
-		MEM_Free(pdblLib->dcdSects);
-	}
-
-	/* Free overlay sects */
-	if (pdblLib->ppOvlyData) {
-		for (i = 0;  i < pdblLib->nOvlySects;  i++) {
-			if (pdblLib->ppOvlyData[i]) {
-				if (pdblLib->ppOvlyData[i]->hdr.pName) {
-					MEM_Free(pdblLib->ppOvlyData[i]->
-						hdr.pName);
-				}
-				MEM_Free(pdblLib->ppOvlyData[i]);
-			}
-		}
-		MEM_Free(pdblLib->ppOvlyData);
-	}
-
-	/* Close the file */
-	if (pdblLib->file)
-		(*pdblLib->pTarget->dblAttrs.fclose) (pdblLib->file);
-
-
-	MEM_FreeObject(pdblLib);
-}
-
-/*
- *  ======== DBL_create ========
- *  Purpose:
- *  	Create a target object by specifying the alloc, free, and
- *  	write functions for the target.
- */
-DSP_STATUS DBL_create(struct DBL_TargetObj **pTarget, struct DBL_Attrs *pAttrs)
-{
-	struct DBL_TargetObj *pdblTarget = NULL;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(pAttrs != NULL);
-	DBC_Require(pTarget != NULL);
-
-	GT_2trace(DBL_debugMask, GT_ENTER,
-		 "DBL_create: pTarget: 0x%x pAttrs: 0x%x\n",
-		 pTarget, pAttrs);
-	/* Allocate DBL target object */
-	MEM_AllocObject(pdblTarget, struct DBL_TargetObj, DBL_TARGSIGNATURE);
-	if (pdblTarget == NULL) {
-		GT_0trace(DBL_debugMask, GT_6CLASS,
-			 "DBL_create: Memory allocation failed\n");
-		status = DSP_EMEMORY;
-	} else {
-		pdblTarget->dblAttrs = *pAttrs;
-		/* Allocate buffer for loading target */
-		pdblTarget->pBuf = MEM_Calloc(LOADBUFSIZE, MEM_PAGED);
-		if (pdblTarget->pBuf == NULL)
-			status = DSP_EMEMORY;
-
-	}
-	if (DSP_SUCCEEDED(status)) {
-		*pTarget = pdblTarget;
-	} else {
-		*pTarget = NULL;
-		if (pdblTarget)
-			DBL_delete(pdblTarget);
-
-	}
-	DBC_Ensure(DSP_SUCCEEDED(status) &&
-		  ((MEM_IsValidHandle((*pTarget), DBL_TARGSIGNATURE)) ||
-		  (DSP_FAILED(status) && *pTarget == NULL)));
-	return status;
-}
-
-/*
- *  ======== DBL_delete ========
- *  Purpose:
- *  	Delete target object and free resources for any loaded libraries.
- */
-void DBL_delete(struct DBL_TargetObj *target)
-{
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(target, DBL_TARGSIGNATURE));
-
-	GT_1trace(DBL_debugMask, GT_ENTER,
-		 "DBL_delete: target: 0x%x\n", target);
-
-	if (target->pBuf)
-		MEM_Free(target->pBuf);
-
-	MEM_FreeObject(target);
-}
-
-/*
- *  ======== DBL_exit ========
- *  Purpose
- *  	Discontinue usage of DBL module.
- */
-void DBL_exit()
-{
-	DBC_Require(cRefs > 0);
-	cRefs--;
-	GT_1trace(DBL_debugMask, GT_5CLASS,
-		 "DBL_exit() ref count: 0x%x\n", cRefs);
-	DBC_Ensure(cRefs >= 0);
-}
-
-/*
- *  ======== DBL_getAddr ========
- *  Purpose:
- *  	Get address of name in the specified library.
- */
-bool DBL_getAddr(struct DBL_LibraryObj *lib, char *name,
-		struct DBL_Symbol **ppSym)
-{
-	bool retVal = false;
-	struct Symbol *symbol;
-	u16 i;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(lib, DBL_LIBSIGNATURE));
-	DBC_Require(name != NULL);
-	DBC_Require(ppSym != NULL);
-
-	GT_3trace(DBL_debugMask, GT_ENTER,
-		 "DBL_getAddr: libt: 0x%x name: %s pAddr: "
-		 "0x%x\n", lib, name, ppSym);
-	for (i = 0; i < lib->nSymbols; i++) {
-		symbol = &lib->symbols[i];
-		if (CSL_Strcmp(name, symbol->pSymName) == 0) {
-			/* Found it */
-			*ppSym = &lib->symbols[i].sym;
-			retVal = true;
-			break;
-		}
-	}
-	return retVal;
-}
-
-/*
- *  ======== DBL_getAttrs ========
- *  Purpose:
- *  	Retrieve the attributes of the target.
- */
-void DBL_getAttrs(struct DBL_TargetObj *target, struct DBL_Attrs *pAttrs)
-{
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(target, DBL_TARGSIGNATURE));
-	DBC_Require(pAttrs != NULL);
-	GT_2trace(DBL_debugMask, GT_ENTER, "DBL_getAttrs: target: 0x%x pAttrs: "
-		  "0x%x\n", target, pAttrs);
-	*pAttrs = target->dblAttrs;
-}
-
-/*
- *  ======== DBL_getCAddr ========
- *  Purpose:
- *  	Get address of "C" name in the specified library.
- */
-bool DBL_getCAddr(struct DBL_LibraryObj *lib, char *name,
-		 struct DBL_Symbol **ppSym)
-{
-	bool retVal = false;
-	struct Symbol *symbol;
-	u16 i;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(lib, DBL_LIBSIGNATURE));
-	DBC_Require(name != NULL);
-	DBC_Require(ppSym != NULL);
-
-	GT_3trace(DBL_debugMask, GT_ENTER,
-		 "DBL_getCAddr: target: 0x%x name:%s pAddr:"
-		 " 0x%x\n", lib, name, ppSym);
-	for (i = 0;  i < lib->nSymbols;  i++) {
-		symbol = &lib->symbols[i];
-		if ((CSL_Strcmp(name, symbol->pSymName) == 0) ||
-		    (CSL_Strcmp(name, symbol->pSymName + 1) == 0 &&
-		     symbol->pSymName[0] == '_')) {
-			/* Found it */
-			*ppSym = &lib->symbols[i].sym;
-			retVal = true;
-			break;
-		}
-	}
-	return retVal;
-}
-
-/*
- *  ======== DBL_getEntry ========
- *  Purpose:
- *  	Get program entry point.
- *
- */
-bool DBL_getEntry(struct DBL_LibraryObj *lib, u32 *pEntry)
-{
-	struct DBL_LibraryObj *pdblLib = (struct DBL_LibraryObj *)lib;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(pdblLib, DBL_LIBSIGNATURE));
-	DBC_Require(pEntry != NULL);
-
-	GT_2trace(DBL_debugMask, GT_ENTER,
-		 "DBL_getEntry: lib: 0x%x pEntry: 0x%x\n", lib, pEntry);
-	*pEntry = pdblLib->fileHdr.entry;
-
-	return true;
-}
-
-/*
- *  ======== DBL_getSect ========
- *  Purpose:
- *  	Get address and size of a named section.
- */
-DSP_STATUS DBL_getSect(struct DBL_LibraryObj *lib, char *name, u32 *pAddr,
-		      u32 *pSize)
-{
-	struct DBL_LibraryObj *pdblLib = (struct DBL_LibraryObj *)lib;
-	u16 i;
-	DSP_STATUS status = DSP_ENOSECT;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(name != NULL);
-	DBC_Require(pAddr != NULL);
-	DBC_Require(pSize != NULL);
-	DBC_Require(MEM_IsValidHandle(pdblLib, DBL_LIBSIGNATURE));
-
-	GT_4trace(DBL_debugMask, GT_ENTER,
-		 "DBL_getSect: lib: 0x%x name: %s pAddr:"
-		 " 0x%x pSize: 0x%x\n", lib, name, pAddr, pSize);
-
-	/*
-	 *  Check for DCD and overlay sections. Overlay loader uses DBL_getSect
-	 *  to determine whether or not a node has overlay sections.
-	 *  DCD section names begin with '.'
-	 */
-	if (name[0] == '.') {
-		/* Get DCD section size (address is 0, since it's a NOLOAD). */
-		for (i = 0; i < pdblLib->nDCDSects; i++) {
-			if (CSL_Strcmp(pdblLib->dcdSects[i].sectHdr.name,
-			   name) == 0) {
-				*pAddr = 0;
-				*pSize = pdblLib->dcdSects[i].sectHdr.size *
-					 pdblLib->pTargetInfo->mauSize;
-				status = DSP_SOK;
-				break;
-			}
-		}
-	} else {
-		/* Check for overlay section */
-		for (i = 0;  i < pdblLib->nOvlySects;  i++) {
-			if (CSL_Strcmp(pdblLib->ppOvlyData[i]->hdr.pName,
-			   name) == 0) {
-				/* Address and size are meaningless */
-				*pAddr = 0;
-				*pSize = 0;
-				status = DSP_SOK;
-				break;
-			}
-		}
-	}
-
-	return status;
-}
-
-/*
- *  ======== DBL_init ========
- *  Purpose:
- *  	Initialize DBL module.
- */
-bool DBL_init(void)
-{
-	bool retVal = true;
-
-	DBC_Require(cRefs >= 0);
-
-	if (cRefs == 0) {
-		DBC_Assert(!DBL_debugMask.flags);
-		GT_create(&DBL_debugMask, "BL"); 	/* "BL" for dBL */
-
-	}
-
-	if (retVal)
-		cRefs++;
-
-
-	GT_1trace(DBL_debugMask, GT_5CLASS, "DBL_init(), ref count:  0x%x\n",
-		  cRefs);
-
-	DBC_Ensure((retVal && (cRefs > 0)) || (!retVal && (cRefs >= 0)));
-
-	return retVal;
-}
-
-/*
- *  ======== DBL_load ========
- *  Purpose:
- *  	Add symbols/code/data defined in file to that already present
- *  	on the target.
- */
-DSP_STATUS DBL_load(struct DBL_LibraryObj *lib, DBL_Flags flags,
-		   struct DBL_Attrs *attrs, u32 *pEntry)
-{
-	struct DBL_LibraryObj *pdblLib = (struct DBL_LibraryObj *)lib;
-	struct DBL_TargetObj *dbl;
-	u16 i;
-	u16 nSects;
-	DSP_STATUS status = DSP_EFAIL;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(pdblLib, DBL_LIBSIGNATURE));
-	DBC_Require(pEntry != NULL);
-	DBC_Require(attrs != NULL);
-
-	GT_4trace(DBL_debugMask, GT_ENTER, "DBL_load: lib: 0x%x flags: "
-		 "0x%x attrs: 0x%x pEntry: 0x%x\n", lib, flags, attrs, pEntry);
-
-	dbl = pdblLib->pTarget;
-	*pEntry = pdblLib->fileHdr.entry;
-	nSects = pdblLib->fileHdr.numSects;
-	dbl->dblAttrs = *attrs;
-
-	for (i = 0; i < nSects; i++) {
-		/* Load the section at the current file offset */
-		status = loadSect(dbl, lib);
-		if (DSP_FAILED(status))
-			break;
-
-	}
-
-	/* Done with file, we can close it */
-	if (pdblLib->file) {
-		(*pdblLib->pTarget->dblAttrs.fclose) (pdblLib->file);
-		pdblLib->file = NULL;
-	}
-	return status;
-}
-
-/*
- *  ======== DBL_loadSect ========
- *  Purpose:
- *  	Load a named section from an library (for overlay support).
- */
-DSP_STATUS DBL_loadSect(struct DBL_LibraryObj *lib, char *sectName,
-			struct DBL_Attrs *attrs)
-{
-	struct DBL_TargetObj *dbl;
-	s32 i;
-	s32 phase;
-	s32 offset = -1;
-	s32 nSects = -1;
-	s32 allocdSects = 0;
-	u32 loadAddr;
-	u32 runAddr;
-	u32 size;
-	u32 space;
-	u32 ulBytes;
-	u16 mauSize;
-	u16 wordSize;
-	u16 *phaseRef = NULL;
-	u16 *otherRef = NULL;
-	char *name = NULL;
-	struct OvlyData *pOvlyData;
-	DSP_STATUS status = DSP_ENOSECT;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(lib, DBL_LIBSIGNATURE));
-	DBC_Require(sectName != NULL);
-	DBC_Require(attrs != NULL);
-	DBC_Require(attrs->write != NULL);
-	GT_3trace(DBL_debugMask, GT_ENTER,
-		 "DBL_loadSect: lib: 0x%x sectName: %s "
-		 "attrs: 0x%x\n", lib, sectName, attrs);
-	dbl = lib->pTarget;
-	mauSize = lib->pTargetInfo->mauSize;
-	wordSize = lib->pTargetInfo->wordSize;
-	/* Check for match of sect name in overlay table */
-	for (i = 0; i < lib->nOvlySects; i++) {
-		name = lib->ppOvlyData[i]->hdr.pName;
-		if (!CSL_Strncmp(name, sectName, CSL_Strlen(name))) {
-			/* Match found */
-			status = DSP_SOK;
-			break;
-		}
-	}
-	if (DSP_SUCCEEDED(status)) {
-		DBC_Assert(i < lib->nOvlySects);
-		pOvlyData = lib->ppOvlyData[i];
-		/*
-		 *  If node overlay, phase will be encoded in name. If not node
-		 *  overlay, set phase to NONE.
-		 */
-		phase = (CSL_Strcmp(name, sectName)) ?
-			CSL_Atoi(sectName + CSL_Strlen(sectName) - 1) : NONE;
-		 /*  Get reference count of node phase to be loaded, offset into
-		 *  overlay data array, and number of sections to overlay.  */
-		switch (phase) {
-		case NONE:
-			/* Not a node overlay */
-			phaseRef = &pOvlyData->hdr.otherRef;
-			nSects = numOtherSects(pOvlyData);
-			offset = otherOffset(pOvlyData);
-			break;
-		case CREATEPHASE:
-			phaseRef = &pOvlyData->hdr.createRef;
-			otherRef = &pOvlyData->hdr.otherRef;
-			if (*otherRef) {
-				/* The overlay sections where node phase was
-				 * not specified, have already been loaded.  */
-				nSects = numCreateSects(pOvlyData);
-				offset = createOffset(pOvlyData);
-			} else {
-				/* Overlay sections where node phase was not
-				 * specified get loaded at create time, along
-				 * with create sects.  */
-				nSects = numCreateSects(pOvlyData) +
-					 numOtherSects(pOvlyData);
-				offset = otherOffset(pOvlyData);
-			}
-			break;
-		case DELETEPHASE:
-			phaseRef = &pOvlyData->hdr.deleteRef;
-			nSects = numDeleteSects(pOvlyData);
-			offset = deleteOffset(pOvlyData);
-			break;
-		case EXECUTEPHASE:
-			phaseRef = &pOvlyData->hdr.executeRef;
-			nSects = numExecuteSects(pOvlyData);
-			offset = executeOffset(pOvlyData);
-			break;
-		default:
-			/* ERROR */
-			DBC_Assert(false);
-			break;
-		}
-		/* Do overlay if reference count is 0 */
-		if (!(*phaseRef)) {
-			/* "Allocate" all sections */
-			for (i = 0; i < nSects; i++) {
-				runAddr = pOvlyData->data[offset + i].runAddr;
-				size = pOvlyData->data[offset + i].size;
-				space = pOvlyData->data[offset + i].page;
-				status = (dbl->dblAttrs.alloc)(dbl->dblAttrs.
-					 rmmHandle, space, size, 0,
-					 &runAddr, true);
-				if (DSP_FAILED(status))
-					break;
-
-				allocdSects++;
-			}
-			if (DSP_SUCCEEDED(status)) {
-				/* Load sections */
-				for (i = 0; i < nSects; i++) {
-					loadAddr = pOvlyData->data[offset + i].
-						   loadAddr;
-					runAddr = pOvlyData->data[offset + i].
-						  runAddr;
-					size = pOvlyData->data[offset + i].
-						size;
-					space = pOvlyData->data[offset + i].
-						page;
-					/* Convert to word address, call
-					 * write function */
-					loadAddr /= (wordSize / mauSize);
-					runAddr /= (wordSize / mauSize);
-					ulBytes = size * mauSize;
-					if ((*attrs->write)(attrs->wHandle,
-					   runAddr, (void *)loadAddr, ulBytes,
-					   space) != ulBytes) {
-						GT_0trace(DBL_debugMask,
-							GT_6CLASS,
-							"DBL_loadSect: write"
-							" failed\n");
-						status = DSP_EFWRITE;
-						break;
-					}
-				}
-			}
-			/* Free sections on failure */
-			if (DSP_FAILED(status))
-				freeSects(dbl, pOvlyData, offset, allocdSects);
-
-		}
-	}
-	if (DSP_SUCCEEDED(status)) {
-		/* Increment reference counts */
-		if (otherRef)
-			*otherRef = *otherRef + 1;
-
-		*phaseRef = *phaseRef + 1;
-	}
-	return status;
-}
-
-/*
- *  ======== DBL_open ========
- *  Purpose:
- *  	DBL_open() returns a library handle that can be used to
- *  	load/unload the symbols/code/data via DBL_load()/DBL_unload().
- */
-DSP_STATUS DBL_open(struct DBL_TargetObj *target, char *file, DBL_Flags flags,
-		   struct DBL_LibraryObj **pLib)
-{
-	struct DBL_LibraryObj *pdblLib = NULL;
-	u16 nSymbols;
-	u16 nDCDSects;
-	DSP_STATUS status = DSP_SOK;
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(target, DBL_TARGSIGNATURE));
-	DBC_Require(target->dblAttrs.fopen != NULL);
-	DBC_Require(file != NULL);
-	DBC_Require(pLib != NULL);
-
-	GT_3trace(DBL_debugMask, GT_ENTER, "DBL_open: target: 0x%x file: %s "
-		 "pLib: 0x%x\n", target, file, pLib);
-	/* Allocate DBL library object */
-	MEM_AllocObject(pdblLib, struct DBL_LibraryObj, DBL_LIBSIGNATURE);
-	if (pdblLib == NULL)
-		status = DSP_EMEMORY;
-
-	/* Open the file */
-	if (DSP_SUCCEEDED(status)) {
-		pdblLib->pTarget = target;
-		pdblLib->file = (*target->dblAttrs.fopen)(file, "rb");
-		if (pdblLib->file == NULL)
-			status = DSP_EFOPEN;
-
-	}
-	/* Read file header */
-	if (DSP_SUCCEEDED(status)) {
-		status = readHeader(target, pdblLib);
-		if (DSP_FAILED(status)) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "DBL_open(): Failed to read file header\n");
-		}
-	}
-	/* Allocate symbol table */
-	if (DSP_SUCCEEDED(status)) {
-		nSymbols = pdblLib->nSymbols = pdblLib->fileHdr.numSymbols;
-		pdblLib->symbols = MEM_Calloc(nSymbols * sizeof(struct Symbol),
-					     MEM_PAGED);
-		if (pdblLib->symbols == NULL)
-			status = DSP_EMEMORY;
-
-	}
-	/* Read all the symbols */
-	if (DSP_SUCCEEDED(status)) {
-		status = readSymbols(target, pdblLib);
-		if (DSP_FAILED(status)) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "DBL_open(): Failed to read symbols\n");
-		}
-	}
-	/* Allocate DCD sect table */
-	if (DSP_SUCCEEDED(status)) {
-		nDCDSects = pdblLib->nDCDSects = pdblLib->fileHdr.numDCDSects;
-		pdblLib->dcdSects = MEM_Calloc(nDCDSects *
-					 sizeof(struct DCDSect), MEM_PAGED);
-		if (pdblLib->dcdSects == NULL)
-			status = DSP_EMEMORY;
-
-	}
-	/* Read DCD sections */
-	if (DSP_SUCCEEDED(status)) {
-		status = readDCDSects(target, pdblLib);
-		if (DSP_FAILED(status)) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "DBL_open(): Failed to read DCD sections\n");
-		}
-	}
-	/* Read overlay sections */
-	if (DSP_SUCCEEDED(status)) {
-		status = readOvlySects(target, pdblLib);
-		if (DSP_FAILED(status)) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "DBL_open(): Failed to read "
-				 "overlay sections\n");
-		}
-	}
-	if (DSP_FAILED(status)) {
-		*pLib = NULL;
-		if (pdblLib != NULL)
-			DBL_close((struct DBL_LibraryObj *) pdblLib);
-
-	} else {
-		*pLib = pdblLib;
-	}
-	DBC_Ensure((DSP_SUCCEEDED(status) &&
-		  (MEM_IsValidHandle((*pLib), DBL_LIBSIGNATURE))) ||
-		  (DSP_FAILED(status) && *pLib == NULL));
-	return status;
-}
-
-/*
- *  ======== DBL_readSect ========
- *  Purpose:
- *  	Read COFF section into a character buffer.
- */
-DSP_STATUS DBL_readSect(struct DBL_LibraryObj *lib, char *name, char *pContent,
-			u32 size)
-{
-	struct DBL_LibraryObj *pdblLib = (struct DBL_LibraryObj *)lib;
-	u16 i;
-	u32 mauSize;
-	u32 max;
-	DSP_STATUS status = DSP_ENOSECT;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(pdblLib, DBL_LIBSIGNATURE));
-	DBC_Require(name != NULL);
-	DBC_Require(pContent != NULL);
-	DBC_Require(size != 0);
-	GT_4trace(DBL_debugMask, GT_ENTER, "DBL_readSect: lib: 0x%x name: %s "
-		 "pContent: 0x%x size: 0x%x\n", lib, name, pContent, size);
-
-	mauSize = pdblLib->pTargetInfo->mauSize;
-
-	/* Attempt to find match with DCD section names. */
-	for (i = 0; i < pdblLib->nDCDSects; i++) {
-		if (CSL_Strcmp(pdblLib->dcdSects[i].sectHdr.name, name) == 0) {
-			/* Match found */
-			max = pdblLib->dcdSects[i].sectHdr.size * mauSize;
-			max = (max > size) ? size : max;
-			memcpy(pContent, pdblLib->dcdSects[i].pData, max);
-			status = DSP_SOK;
-			break;
-		}
-	}
-
-	return status;
-}
-
-/*
- *  ======== DBL_setAttrs ========
- *  Purpose:
- *  	Set the attributes of the target.
- */
-void DBL_setAttrs(struct DBL_TargetObj *target, struct DBL_Attrs *pAttrs)
-{
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(target, DBL_TARGSIGNATURE));
-	DBC_Require(pAttrs != NULL);
-
-	GT_2trace(DBL_debugMask, GT_ENTER, "DBL_setAttrs: target: 0x%x pAttrs: "
-		 "0x%x\n", target, pAttrs);
-
-	target->dblAttrs = *pAttrs;
-}
-
-/*
- *  ======== DBL_unload ========
- *  Purpose:
- *  	Remove the symbols/code/data corresponding to the library lib.
- */
-void DBL_unload(struct DBL_LibraryObj *lib, struct DBL_Attrs *attrs)
-{
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(lib, DBL_LIBSIGNATURE));
-
-	GT_1trace(DBL_debugMask, GT_ENTER, "DBL_unload: lib: 0x%x\n", lib);
-
-	/* Nothing to do for static loading */
-}
-
-/*
- *  ======== DBL_unloadSect ========
- *  Purpose:
- *  	Unload a named section from an library (for overlay support).
- */
-DSP_STATUS DBL_unloadSect(struct DBL_LibraryObj *lib, char *sectName,
-			  struct DBL_Attrs *attrs)
-{
-	struct DBL_TargetObj *dbl;
-	s32 i;
-	s32 phase;
-	s32 offset = -1;
-	s32 nSects = -1;
-	u16 *phaseRef = NULL;
-	u16 *otherRef = NULL;
-	char *pName = NULL;
-	struct OvlyData *pOvlyData;
-	DSP_STATUS status = DSP_ENOSECT;
-
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(lib, DBL_LIBSIGNATURE));
-	DBC_Require(sectName != NULL);
-
-	GT_2trace(DBL_debugMask, GT_ENTER,
-		 "DBL_unloadSect: lib: 0x%x sectName: %s\n", lib, sectName);
-	dbl = lib->pTarget;
-	/* Check for match of sect name in overlay table */
-	for (i = 0; i < lib->nOvlySects; i++) {
-		pName = lib->ppOvlyData[i]->hdr.pName;
-		if (!CSL_Strncmp(pName, sectName, CSL_Strlen(pName))) {
-			/* Match found */
-			status = DSP_SOK;
-			break;
-		}
-	}
-	if (DSP_SUCCEEDED(status)) {
-		DBC_Assert(i < lib->nOvlySects);
-		pOvlyData = lib->ppOvlyData[i];
-		/* If node overlay, phase will be encoded in name. */
-		phase = (CSL_Strcmp(pName, sectName)) ?
-			CSL_Atoi(sectName + CSL_Strlen(sectName) - 1) : NONE;
-		switch (phase) {
-		case NONE:
-			nSects = numOtherSects(pOvlyData);
-			phaseRef = &pOvlyData->hdr.otherRef;
-			offset = otherOffset(pOvlyData);
-			break;
-		case CREATEPHASE:
-			nSects = numCreateSects(pOvlyData);
-			offset = createOffset(pOvlyData);
-			phaseRef = &pOvlyData->hdr.createRef;
-			break;
-		case DELETEPHASE:
-			nSects = numDeleteSects(pOvlyData);
-			offset = deleteOffset(pOvlyData);
-			phaseRef = &pOvlyData->hdr.deleteRef;
-			otherRef = &pOvlyData->hdr.otherRef;
-			break;
-		case EXECUTEPHASE:
-			nSects = numExecuteSects(pOvlyData);
-			offset = executeOffset(pOvlyData);
-			phaseRef = &pOvlyData->hdr.executeRef;
-			break;
-		default:
-			/* ERROR */
-			DBC_Assert(false);
-			break;
-		}
-		if (*phaseRef) {
-			*phaseRef = *phaseRef - 1;
-			if (*phaseRef == 0) {
-				/* Unload overlay sections for phase */
-				freeSects(dbl, pOvlyData, offset, nSects);
-			}
-			if (phase == DELETEPHASE) {
-				DBC_Assert(*otherRef);
-				*otherRef = *otherRef - 1;
-				if (*otherRef == 0) {
-					/* Unload other overlay sections */
-					nSects = numOtherSects(pOvlyData);
-					offset = otherOffset(pOvlyData);
-					freeSects(dbl, pOvlyData, offset,
-						 nSects);
-				}
-			}
-		}
-	}
-
-	return status;
-}
-
-/*
- *  ======== freeSects ========
- *  Purpose:
- *  	Free section
- */
-static void freeSects(struct DBL_TargetObj *dbl, struct OvlyData *pOvlyData,
-		     s32 offset, s32 nSects)
-{
-	u32 runAddr;
-	u32 size;
-	u32 space;
-	s32 i;
-
-	for (i = 0; i < nSects; i++) {
-		runAddr = pOvlyData->data[offset + i].runAddr;
-		size = pOvlyData->data[offset + i].size;
-		space = pOvlyData->data[offset + i].page;
-		if (!(dbl->dblAttrs.free)
-		    (dbl->dblAttrs.rmmHandle, space, runAddr, size, true)) {
-			/*
-			 *  Free function will not fail for overlay, unless
-			 *  address passed in is bad.
-			 */
-			DBC_Assert(false);
-		}
-	}
-}
-
-/*
- *  ======== loadSect ========
- *  Purpose:
- *  	Load section to target
- */
-static DSP_STATUS loadSect(struct DBL_TargetObj *dbl,
-			  struct DBL_LibraryObj *pdblLib)
-{
-	struct DBOF_SectHdr sectHdr;
-	char *pBuf;
-	struct KFILE_FileObj *file;
-	u32 space;
-	u32 addr;
-	u32 total;
-	u32 nWords = 0;
-	u32 nBytes = 0;
-	u16 mauSize;
-	u32 bufSize;
-	DSP_STATUS status = DSP_SOK;
-
-	file = pdblLib->file;
-	mauSize = pdblLib->pTargetInfo->mauSize;
-	bufSize = LOADBUFSIZE / mauSize;
-	pBuf = dbl->pBuf;
-
-	/* Read the section header */
-	if ((*dbl->dblAttrs.fread)(&sectHdr, sizeof(struct DBOF_SectHdr),
-	   1, file) != 1) {
-		GT_0trace(DBL_debugMask, GT_6CLASS,
-			 "Failed to read DCD sect header\n");
-		status = DSP_EFREAD;
-	} else {
-		if (pdblLib->byteSwapped) {
-			sectHdr.size = SWAPLONG(sectHdr.size);
-			sectHdr.addr = SWAPLONG(sectHdr.addr);
-			sectHdr.page = SWAPWORD(sectHdr.page);
-		}
-	}
-	if (DSP_SUCCEEDED(status)) {
-		addr = sectHdr.addr;
-		space = sectHdr.page;
-		for (total = sectHdr.size; total > 0; total -= nWords) {
-			nWords = min(total, bufSize);
-			nBytes = nWords * mauSize;
-			/* Read section data */
-			if ((*dbl->dblAttrs.fread)(pBuf, nBytes, 1,
-			   file) != 1) {
-				GT_0trace(DBL_debugMask, GT_6CLASS,
-					 "Failed to read DCD sect header\n");
-				status = DSP_EFREAD;
-				break;
-			}
-			/* Write section to target */
-			if (!(*dbl->dblAttrs.write)(dbl->dblAttrs.wHandle,
-			   addr, pBuf, nBytes, space)) {
-				GT_0trace(DBL_debugMask, GT_6CLASS,
-					 "Failed to write section data\n");
-				status = DSP_EFWRITE;
-				break;
-			}
-			addr += nWords;
-		}
-	}
-	return status;
-}
-
-/*
- *  ======== readDCDSects ========
- *  Purpose:
- *  	Read DCD sections.
- */
-static DSP_STATUS readDCDSects(struct DBL_TargetObj *dbl,
-			      struct DBL_LibraryObj *pdblLib)
-{
-	struct DBOF_DCDSectHdr *pSectHdr;
-	struct DCDSect *pSect;
-	struct KFILE_FileObj *file;
-	u16 nSects;
-	u16 i;
-	u16 mauSize;
-	DSP_STATUS status = DSP_SOK;
-
-	file = pdblLib->file;
-	mauSize = pdblLib->pTargetInfo->mauSize;
-	nSects = pdblLib->fileHdr.numDCDSects;
-	for (i = 0; i < nSects; i++) {
-		pSect = &pdblLib->dcdSects[i];
-		pSectHdr = &pdblLib->dcdSects[i].sectHdr;
-		/* Read sect header */
-		if ((*dbl->dblAttrs.fread)(pSectHdr,
-		   sizeof(struct DBOF_DCDSectHdr), 1, file) != 1) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "Failed to read DCD sect header\n");
-			status = DSP_EFREAD;
-			break;
-		}
-		if (pdblLib->byteSwapped)
-			pSectHdr->size = SWAPLONG(pSectHdr->size);
-
-		pSect->pData = (char *)MEM_Calloc(pSectHdr->size *
-				mauSize, MEM_PAGED);
-		if (pSect->pData == NULL) {
-			GT_2trace(DBL_debugMask, GT_6CLASS,
-				 "Memory allocation for sect %s "
-				 "data failed: Size: 0x%lx\n", pSectHdr->name,
-				 pSectHdr->size);
-			status = DSP_EMEMORY;
-			break;
-		}
-		/* Read DCD sect data */
-		if ((*dbl->dblAttrs.fread)(pSect->pData, mauSize,
-		   pSectHdr->size, file) != pSectHdr->size) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				  "Failed to read DCD sect data\n");
-			status = DSP_EFREAD;
-			break;
-		}
-	}
-
-	return status;
-}
-
-/*
- *  ======== readHeader ========
- *  Purpose:
- *  	Read Header.
- */
-static DSP_STATUS readHeader(struct DBL_TargetObj *dbl,
-			    struct DBL_LibraryObj *pdblLib)
-{
-	struct KFILE_FileObj *file;
-	s32 i;
-	struct DBOF_FileHdr *pHdr;
-	u32 swapMagic;
-	DSP_STATUS status = DSP_SOK;
-
-	pdblLib->byteSwapped = false;
-	file = pdblLib->file;
-	pHdr = &pdblLib->fileHdr;
-	if ((*dbl->dblAttrs.fread)(pHdr, sizeof(struct DBOF_FileHdr), 1,
-	   file) != 1) {
-		GT_0trace(DBL_debugMask, GT_6CLASS,
-			 "readHeader: Failed to read file header\n");
-		status = DSP_EFREAD;
-	}
-
-	if (DSP_SUCCEEDED(status)) {
-		/* Determine if byte swapped */
-		for (i = 0; i < NUMTARGS; i++) {
-			swapMagic = SWAPLONG(pHdr->magic);
-			if (pHdr->magic == magicTab[i] || swapMagic ==
-			   magicTab[i]) {
-				if (swapMagic == magicTab[i]) {
-					pdblLib->byteSwapped = true;
-					pHdr->magic = SWAPLONG(pHdr->magic);
-					pHdr->entry = SWAPLONG(pHdr->entry);
-					pHdr->symOffset = SWAPLONG(pHdr->
-								symOffset);
-					pHdr->dcdSectOffset = SWAPLONG(pHdr->
-								dcdSectOffset);
-					pHdr->loadSectOffset = SWAPLONG(pHdr->
-								loadSectOffset);
-					pHdr->ovlySectOffset = SWAPLONG(pHdr->
-								ovlySectOffset);
-					pHdr->numSymbols = SWAPWORD(pHdr->
-								numSymbols);
-					pHdr->numDCDSects = SWAPWORD(pHdr->
-								numDCDSects);
-					pHdr->numSects = SWAPWORD(pHdr->
-								numSects);
-					pHdr->numOvlySects = SWAPWORD(pHdr->
-								numOvlySects);
-				}
-				break;
-			}
-		}
-		if (i == NUMTARGS) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "readHeader: Failed to determine"
-				 " target type\n");
-			status = DSP_ECORRUPTFILE;
-		} else {
-			pdblLib->pTargetInfo = &targetTab[i];
-			GT_1trace(DBL_debugMask, GT_ENTER,
-				 "COF type: 0x%lx\n", pHdr->magic);
-			GT_1trace(DBL_debugMask, GT_ENTER,
-				 "Entry point:0x%lx\n", pHdr->entry);
-		}
-	}
-	return status;
-}
-
-/*
- *  ======== readOvlySects ========
- *  Purpose:
- *  	Read Overlay Sections
- */
-static DSP_STATUS readOvlySects(struct DBL_TargetObj *dbl,
-				struct DBL_LibraryObj *pdblLib)
-{
-	struct DBOF_OvlySectHdr hdr;
-	struct DBOF_OvlySectData *pData;
-	struct OvlyData *pOvlyData;
-	char *pName;
-	struct KFILE_FileObj *file;
-	u16 i, j;
-	u16 nSects;
-	u16 n;
-	DSP_STATUS status = DSP_SOK;
-
-	pdblLib->nOvlySects = nSects = pdblLib->fileHdr.numOvlySects;
-	file = pdblLib->file;
-	if (nSects > 0) {
-		pdblLib->ppOvlyData = MEM_Calloc(nSects * sizeof(OvlyData *),
-						 MEM_PAGED);
-		if (pdblLib->ppOvlyData == NULL) {
-			GT_0trace(DBL_debugMask, GT_7CLASS,
-				 "Failed to allocatate overlay "
-				 "data memory\n");
-			status = DSP_EMEMORY;
-		}
-	}
-	if (DSP_SUCCEEDED(status)) {
-		/* Read overlay data for each node */
-		for (i = 0; i < nSects; i++) {
-			/* Read overlay section header */
-			if ((*dbl->dblAttrs.fread)(&hdr,
-			   sizeof(struct DBOF_OvlySectHdr), 1, file) != 1) {
-				GT_0trace(DBL_debugMask, GT_6CLASS,
-					 "Failed to read overlay sect"
-					 " header\n");
-				status = DSP_EFREAD;
-				break;
-			}
-			if (pdblLib->byteSwapped) {
-				hdr.nameLen = SWAPWORD(hdr.nameLen);
-				hdr.numCreateSects =
-						SWAPWORD(hdr.numCreateSects);
-				hdr.numDeleteSects =
-						SWAPWORD(hdr.numDeleteSects);
-				hdr.numExecuteSects =
-						SWAPWORD(hdr.numExecuteSects);
-				hdr.numOtherSects =
-						SWAPWORD(hdr.numOtherSects);
-				hdr.resvd = SWAPWORD(hdr.resvd);
-			}
-			n = hdr.numCreateSects + hdr.numDeleteSects +
-			    hdr.numExecuteSects + hdr.numOtherSects;
-
-			/* Allocate memory for node's overlay data */
-			pOvlyData = (struct OvlyData *)MEM_Calloc
-				    (sizeof(struct OvlyHdr) +
-				    n * sizeof(struct DBOF_OvlySectData),
-				    MEM_PAGED);
-			if (pOvlyData == NULL) {
-				GT_0trace(DBL_debugMask, GT_7CLASS,
-					 "Failed to allocatate ovlyay"
-					 " data memory\n");
-				status = DSP_EMEMORY;
-				break;
-			}
-			pOvlyData->hdr.dbofHdr = hdr;
-			pdblLib->ppOvlyData[i] = pOvlyData;
-			/* Allocate memory for section name */
-			pName = (char *)MEM_Calloc(hdr.nameLen + 1, MEM_PAGED);
-			if (pName == NULL) {
-				GT_0trace(DBL_debugMask, GT_7CLASS,
-					 "Failed to allocatate ovlyay"
-					 " section name\n");
-				status = DSP_EMEMORY;
-				break;
-			}
-			pOvlyData->hdr.pName = pName;
-			/* Read the overlay section name */
-			if ((*dbl->dblAttrs.fread)(pName, sizeof(char),
-			   hdr.nameLen, file) != hdr.nameLen) {
-				GT_0trace(DBL_debugMask, GT_7CLASS,
-					 "readOvlySects: Unable to "
-					 "read overlay name.\n");
-				status = DSP_EFREAD;
-				break;
-			}
-			/* Read the overlay section data */
-			pData = pOvlyData->data;
-			if ((*dbl->dblAttrs.fread)(pData,
-			   sizeof(struct DBOF_OvlySectData), n, file) != n) {
-				GT_0trace(DBL_debugMask, GT_7CLASS,
-					 "readOvlySects: Unable to "
-					 "read overlay data.\n");
-				status = DSP_EFREAD;
-				break;
-			}
-			/* Swap overlay data, if necessary */
-			if (pdblLib->byteSwapped) {
-				for (j = 0; j < n; j++) {
-					pData[j].loadAddr =
-						 SWAPLONG(pData[j].loadAddr);
-					pData[j].runAddr =
-						 SWAPLONG(pData[j].runAddr);
-					pData[j].size =
-						 SWAPLONG(pData[j].size);
-					pData[j].page =
-						 SWAPWORD(pData[j].page);
-				}
-			}
-		}
-	}
-	return status;
-}
-
-/*
- *  ======== readSymbols ========
- *  Purpose:
- *  	Read Symbols
- */
-static DSP_STATUS readSymbols(struct DBL_TargetObj *dbl,
-			     struct DBL_LibraryObj *pdblLib)
-{
-	struct DBOF_SymbolHdr symHdr;
-	struct KFILE_FileObj *file;
-	u16 i;
-	u16 nSymbols;
-	u16 len;
-	char *pName = NULL;
-	DSP_STATUS status = DSP_SOK;
-
-	file = pdblLib->file;
-
-	nSymbols = pdblLib->fileHdr.numSymbols;
-
-	for (i = 0; i < nSymbols; i++) {
-		/* Read symbol value */
-		if ((*dbl->dblAttrs.fread)(&symHdr,
-		   sizeof(struct DBOF_SymbolHdr), 1, file) != 1) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "Failed to read symbol value\n");
-			status = DSP_EFREAD;
-			break;
-		}
-		if (pdblLib->byteSwapped) {
-			symHdr.nameLen = SWAPWORD(symHdr.nameLen);
-			symHdr.value = SWAPLONG(symHdr.value);
-		}
-		/* Allocate buffer for symbol name */
-		len = symHdr.nameLen;
-		pName = (char *)MEM_Calloc(len + 1, MEM_PAGED);
-		if (pName == NULL) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "Memory allocation failed\n");
-			status = DSP_EMEMORY;
-			break;
-		}
-		pdblLib->symbols[i].pSymName = pName;
-		pdblLib->symbols[i].sym.value = symHdr.value;
-		/* Read symbol name */
-		if ((*dbl->dblAttrs.fread) (pName, sizeof(char), len, file) !=
-		   len) {
-			GT_0trace(DBL_debugMask, GT_6CLASS,
-				 "Failed to read symbol value\n");
-			status = DSP_EFREAD;
-			break;
-		} else {
-			pName[len] = '\0';
-			GT_2trace(DBL_debugMask, GT_ENTER,
-				 "Symbol: %s  Value: 0x%lx\n",
-				 pName, symHdr.value);
-		}
-	}
-	return status;
-}
-
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/dbll.c kernel-power-2.6.28/drivers/dsp/bridge/pmgr/dbll.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/dbll.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/pmgr/dbll.c	2011-05-02 22:36:49.000000000 +0100
@@ -14,26 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== dbll.c ========
- *
- *! Revision History
- *! ================
- *! 25-Apr-2030 map:    Fixed symbol redefinition bug + unload and return error
- *! 08-Apr-2003 map: 	Consolidated DBL with DBLL loader name
- *! 24-Mar-2003 map:    Updated findSymbol to support dllview update
- *! 23-Jan-2003 map:    Updated rmmAlloc to support memory granularity
- *! 21-Nov-2002 map:    Combine fopen and DLOAD_module_open to increase
- *!         performance on start.
- *! 04-Oct-2002 map:    Integrated new TIP dynamic loader w/ DOF api.
- *! 27-Sep-2002 map:    Changed handle passed to RemoteFree, instead of
- *!         RMM_free;  added GT_trace to rmmDealloc
- *! 20-Sep-2002 map:    Updated from Code Review
- *! 08-Aug-2002 jeh:    Updated to support overlays.
- *! 25-Jun-2002 jeh:    Pass RMM_Addr object to alloc function in rmmAlloc().
- *! 20-Mar-2002 jeh:    Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -48,7 +28,6 @@
 #include <dspbridge/gh.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/mem.h>
 
 /* Dynamic loader library interface */
@@ -338,8 +317,6 @@ void DBLL_exit(void)
 		  cRefs);
 
 	if (cRefs == 0) {
-		MEM_Exit();
-		CSL_Exit();
 		GH_exit();
 #if GT_TRACE
 		DBLL_debugMask.flags = NULL;
@@ -490,31 +467,20 @@ DSP_STATUS DBLL_getSect(struct DBLL_Libr
  */
 bool DBLL_init(void)
 {
-	bool retVal = true;
-
 	DBC_Require(cRefs >= 0);
 
 	if (cRefs == 0) {
 		DBC_Assert(!DBLL_debugMask.flags);
 		GT_create(&DBLL_debugMask, "DL"); 	/* "DL" for dbDL */
 		GH_init();
-		CSL_Init();
-		retVal = MEM_Init();
-		if (!retVal)
-			MEM_Exit();
-
 	}
 
-	if (retVal)
-		cRefs++;
-
+	cRefs++;
 
 	GT_1trace(DBLL_debugMask, GT_5CLASS, "DBLL_init(), ref count:  0x%x\n",
 		 cRefs);
 
-	DBC_Ensure((retVal && (cRefs > 0)) || (!retVal && (cRefs >= 0)));
-
-	return retVal;
+	return true;
 }
 
 /*
@@ -671,7 +637,7 @@ DSP_STATUS DBLL_open(struct DBLL_TarObj 
 		 " 0x%x\n", target, file, pLib);
 	zlLib = zlTarget->head;
 	while (zlLib != NULL) {
-               if (strcmp(zlLib->fileName, file) == 0) {
+		if (strcmp(zlLib->fileName, file) == 0) {
 			/* Library is already opened */
 			zlLib->openRef++;
 			break;
@@ -693,7 +659,7 @@ DSP_STATUS DBLL_open(struct DBLL_TarObj 
 			zlLib->openRef++;
 			zlLib->pTarget = zlTarget;
 			/* Keep a copy of the file name */
-                       zlLib->fileName = MEM_Calloc(strlen(file) + 1,
+			zlLib->fileName = MEM_Calloc(strlen(file) + 1,
 							MEM_PAGED);
 			if (zlLib->fileName == NULL) {
 				GT_0trace(DBLL_debugMask, GT_6CLASS,
@@ -701,8 +667,8 @@ DSP_STATUS DBLL_open(struct DBLL_TarObj 
 					 "allocation failed\n");
 				status = DSP_EMEMORY;
 			} else {
-                               strncpy(zlLib->fileName, file,
-                                          strlen(file) + 1);
+				strncpy(zlLib->fileName, file,
+					strlen(file) + 1);
 			}
 			zlLib->symTab = NULL;
 		}
@@ -909,26 +875,23 @@ void DBLL_unload(struct DBLL_LibraryObj 
 		goto func_end;
 
 	zlLib->pTarget->attrs = *attrs;
-	if (zlLib != NULL) {
-		if (zlLib->mHandle) {
-			err = Dynamic_Unload_Module(zlLib->mHandle,
-				&zlLib->symbol.dlSymbol,
-				&zlLib->allocate.dlAlloc, &zlLib->init.dlInit);
-			if (err != 0) {
-				GT_1trace(DBLL_debugMask, GT_5CLASS,
-					 "Dynamic_Unload_Module "
-					 "failed: 0x%x\n", err);
-			}
-		}
-		/* remove symbols from symbol table */
-		if (zlLib->symTab != NULL) {
-			GH_delete(zlLib->symTab);
-			zlLib->symTab = NULL;
+	if (zlLib->mHandle) {
+		err = Dynamic_Unload_Module(zlLib->mHandle,
+			&zlLib->symbol.dlSymbol,
+			&zlLib->allocate.dlAlloc, &zlLib->init.dlInit);
+		if (err != 0) {
+			GT_1trace(DBLL_debugMask, GT_5CLASS,
+				 "Dynamic_Unload_Module failed: 0x%x\n", err);
 		}
-		/* delete DOFF desc since it holds *lots* of host OS
-		 * resources */
-		dofClose(zlLib);
 	}
+	/* remove symbols from symbol table */
+	if (zlLib->symTab != NULL) {
+		GH_delete(zlLib->symTab);
+		zlLib->symTab = NULL;
+	}
+	/* delete DOFF desc since it holds *lots* of host OS
+	 * resources */
+	dofClose(zlLib);
 func_end:
 	DBC_Ensure(zlLib->loadRef >= 0);
 }
@@ -1024,7 +987,7 @@ static bool nameMatch(void *key, void *v
 	DBC_Require(value != NULL);
 
 	if ((key != NULL) && (value != NULL)) {
-               if (strcmp((char *)key, ((struct Symbol *)value)->name) == 0)
+		if (strcmp((char *)key, ((struct Symbol *)value)->name) == 0)
 			return true;
 	}
 	return false;
@@ -1183,7 +1146,7 @@ static struct dynload_symbol *addToSymbo
 	struct dynload_symbol *retVal;
 
 	DBC_Require(this != NULL);
-       DBC_Require(name);
+	DBC_Require(name);
 	lib = pSymbol->lib;
 	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
 
@@ -1201,15 +1164,15 @@ static struct dynload_symbol *addToSymbo
 		}
 	}
 	/* Allocate string to copy symbol name */
-       symbol.name = (char *)MEM_Calloc(strlen((char *const)name) + 1,
+	symbol.name = (char *)MEM_Calloc(strlen((char *const)name) + 1,
 							MEM_PAGED);
 	if (symbol.name == NULL)
 		return NULL;
 
 	if (symbol.name != NULL) {
 		/* Just copy name (value will be filled in by dynamic loader) */
-               strncpy(symbol.name, (char *const)name,
-                          strlen((char *const)name) + 1);
+		strncpy(symbol.name, (char *const)name,
+			strlen((char *const)name) + 1);
 
 		/* Add symbol to symbol table */
 		symPtr = (struct Symbol *)GH_insert(lib->symTab, (void *)name,
@@ -1316,6 +1279,7 @@ static int rmmAlloc(struct Dynamic_Loade
 	s32 req = -1;
 	s32 count = 0;
 	u32 allocSize = 0;
+	u32 runAddrFlag = 0;
 
 	DBC_Require(this != NULL);
 	lib = pAlloc->lib;
@@ -1326,8 +1290,8 @@ static int rmmAlloc(struct Dynamic_Loade
 
 	/* Attempt to extract the segment ID and requirement information from
 	 the name of the section */
-       DBC_Require(info->name);
-       tokenLen = strlen((char *)(info->name)) + 1;
+	DBC_Require(info->name);
+	tokenLen = strlen((char *)(info->name)) + 1;
 
 	szSectName = MEM_Calloc(tokenLen, MEM_PAGED);
 	szLastToken = MEM_Calloc(tokenLen, MEM_PAGED);
@@ -1338,11 +1302,11 @@ static int rmmAlloc(struct Dynamic_Loade
 		status = DSP_EMEMORY;
 		goto func_cont;
 	}
-       strncpy(szSectName, (char *)(info->name), tokenLen);
+	strncpy(szSectName, (char *)(info->name), tokenLen);
 	pszCur = szSectName;
 	while ((pToken = strsep(&pszCur, ":")) && *pToken != '\0') {
-               strncpy(szSecLastToken, szLastToken, strlen(szLastToken) + 1);
-               strncpy(szLastToken, pToken, strlen(pToken) + 1);
+		strncpy(szSecLastToken, szLastToken, strlen(szLastToken) + 1);
+		strncpy(szLastToken, pToken, strlen(pToken) + 1);
 		pToken = strsep(&pszCur, ":");
 		count++; 	/* optimizes processing*/
 	}
@@ -1351,19 +1315,18 @@ static int rmmAlloc(struct Dynamic_Loade
 	 within the section name - only process if there are at least three
 	 tokens within the section name (just a minor optimization)*/
 	if (count >= 3)
-               strict_strtol(szLastToken, 10, (long *)&req);
+		strict_strtol(szLastToken, 10, (long *)&req);
 
 	if ((req == 0) || (req == 1)) {
-               if (strcmp(szSecLastToken, "DYN_DARAM") == 0) {
+		if (strcmp(szSecLastToken, "DYN_DARAM") == 0) {
 			segId = 0;
 		} else {
-                       if (strcmp(szSecLastToken, "DYN_SARAM") == 0) {
+			if (strcmp(szSecLastToken, "DYN_SARAM") == 0) {
 				segId = 1;
 			} else {
-                               if (strcmp(szSecLastToken,
-				   "DYN_EXTERNAL") == 0) {
+				if (strcmp(szSecLastToken,
+				   "DYN_EXTERNAL") == 0)
 					segId = 2;
-				}
 			}
 		}
 		if (segId != -1) {
@@ -1373,17 +1336,23 @@ static int rmmAlloc(struct Dynamic_Loade
 				 req, segId);
 		}
 	}
+func_cont:
 	MEM_Free(szSectName);
 	szSectName = NULL;
 	MEM_Free(szLastToken);
 	szLastToken = NULL;
 	MEM_Free(szSecLastToken);
 	szSecLastToken = NULL;
-func_cont:
+
 	if (memType == DBLL_CODE)
 		allocSize = info->size + GEM_L1P_PREFETCH_SIZE;
 	else
 		allocSize = info->size;
+	GT_2trace(DBLL_debugMask, GT_5CLASS,
+			 "Beg info->run_addr = 0x%x, info->load_addr= 0x%x\n",
+			 info->run_addr, info->load_addr);
+	if (info->load_addr != info->run_addr)
+		runAddrFlag = 1;
 	/* TODO - ideally, we can pass the alignment requirement also
 	 * from here */
 	if (lib != NULL) {
@@ -1396,12 +1365,16 @@ func_cont:
 	} else {
 		/* RMM gives word address. Need to convert to byte address */
 		info->load_addr = rmmAddr.addr * DSPWORDSIZE;
-		info->run_addr = info->load_addr;
+		if (!runAddrFlag)
+			info->run_addr = info->load_addr;
 		info->context = (u32)rmmAddr.segid;
 		GT_3trace(DBLL_debugMask, GT_5CLASS,
 			 "Remote alloc: %s  base = 0x%lx len"
 			 "= 0x%lx\n", info->name, info->load_addr / DSPWORDSIZE,
 			 info->size / DSPWORDSIZE);
+		GT_2trace(DBLL_debugMask, GT_5CLASS,
+			 "info->run_addr = 0x%x, info->load_addr= 0x%x\n",
+			 info->run_addr, info->load_addr);
 	}
 	return retVal;
 }
@@ -1410,7 +1383,7 @@ func_cont:
  *  ======== rmmDealloc ========
  */
 static void rmmDealloc(struct Dynamic_Loader_Allocate *this,
-		       struct LDR_SECTION_INFO *info)
+			struct LDR_SECTION_INFO *info)
 {
 	struct DBLLAlloc *pAlloc = (struct DBLLAlloc *)this;
 	struct DBLL_LibraryObj *lib;
@@ -1488,13 +1461,14 @@ static int writeMem(struct Dynamic_Loade
 
 	DBC_Require(this != NULL);
 	lib = pInit->lib;
-	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	if (!MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE))
+		return false;
+
+	pTarget = lib->pTarget;
 
 	memType = (DLOAD_SECTION_TYPE(info->type) == DLOAD_TEXT) ? DBLL_CODE :
 		  DBLL_DATA;
-	if ((lib != NULL) &&
-	    ((pTarget = lib->pTarget) != NULL) &&
-	    (pTarget->attrs.write != NULL)) {
+	if (pTarget && pTarget->attrs.write) {
 		retVal = (*pTarget->attrs.write)(pTarget->attrs.wHandle,
 						 addr, buf, nBytes, memType);
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/dev.c kernel-power-2.6.28/drivers/dsp/bridge/pmgr/dev.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/dev.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/pmgr/dev.c	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implementation of Bridge Mini-driver device operations.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,104 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dev.c ========
- *  Description:
- *      Implementation of 'Bridge Mini-driver device operations.
- *
- *  Public Functions:
- *      DEV_BrdWriteFxn
- *      DEV_CreateDevice
- *      DEV_Create2
- *      DEV_Destroy2
- *      DEV_DestroyDevice
- *      DEV_GetChnlMgr
- *      DEV_GetCmmMgr
- *      DEV_GetCodMgr
- *      DEV_GetDehMgr
- *      DEV_GetDevNode
- *      DEV_GetDSPWordSize
- *      DEV_GetFirst
- *      DEV_GetIntfFxns
- *      DEV_GetIOMgr
- *      DEV_GetNext
- *      DEV_GetNodeManager
- *      DEV_GetSymbol
- *      DEV_GetWMDContext
- *      DEV_Exit
- *      DEV_Init
- *      DEV_InsertProcObject
- *      DEV_IsLocked
- *      DEV_NotifyClient
- *      DEV_RegisterNotify
- *      DEV_ReleaseCodMgr
- *      DEV_RemoveDevice
- *      DEV_RemoveProcObject
- *      DEV_SetChnlMgr
- *      DEV_SetMsgMgr
- *      DEV_SetLockOwner
- *      DEV_StartDevice
- *
- *  Private Functions:
- *      FxnNotImplemented
- *      InitCodMgr
- *      InsertDevObject
- *      IsValidHandle
- *      RemoveDevObject
- *      StoreInterfaceFxns
- *
- *! Revision History:
- *! ================
- *! 03-Jan-2005 hn  Support for IVA DEH
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping feature
- *! 09-Feb-2004 vp	Updated to support IVA.
- *! 24-Feb-2003 swa PMGR Code review comments incorporated.
- *! 29-Nov-2001 jeh Check for DSP_ENOTIMPL status of DEH create function.
- *! 05-Nov-2001 kc  Added support for DEH module.
- *! 05-Aug-2001 ag  Shared memory registration moved to WMD_IO_OnLoaded().
- *! 11-Jul-2001 jeh Moved MGR_Create() from DSP_Init() to DEV_StartDevice().
- *! 11-Apr-2001 rr: Removed CMM_RegisterGPPSMSeg.
- *! 02-Apr-2001 rr: CHNL_Create failure is printed out.
- *! 15-Jan-2001 jeh Removed call to IO_OnLoaded() from DEV_Create2().
- *! 13-Feb-2001 kc: DSP/BIOS Bridge name update.
- *! 15-Dec-2000 rr: Dev_Create2 returns error if NODE_CreateMgr fails.
- *! 05-Dec-2000 jeh Moved IO_OnLoaded() to PROC_Load. Added DEV_SetMsgMgr.
- *! 05-Dev-2000 ag  SM Heap for messaging registered via CMM_RegisterGPPSMSeg().
- *!                 SM heap base and size currently taken from registry.
- *! 29-Nov-2000 rr: Incorporated code review changes.
- *! 17-Nov-2000 jeh Added calls to get IO manager (IO_Create), IO_OnLoaded().
- *! 06-Oct-2000 rr: DEV_Destroy2 and DEV_Create2 added.
- *! 02-Oct-2000 rr: DEV_GetNodeManager added.
- *! 11-Aug-2000 ag: Added DEV_GetCmmMgr(), CMM_Init() & CMM_Exit().
- *!                 Removed <dspbridge/std.h> & <stdwin.h>, added <dspbridge/dbtype.h>
- *! 10-Aug-2000 rr: DEV_InsertProcObject/RemoveProcObject added.
- *!                 DEV_Cleanup calls PROC_Detach if it is a matching process.
- *! 27-Jul-2000 rr: DEV is in new directoy DEV and produces devlib.lib
- *! 17-Jul-2000 rr: DRV Object holds the list of Dev Objects. DEV gets
- *!                 the List and Next devices through DRV.
- *!                 DEV object has a back pointer to DRV Object.
- *! 06-Jun-2000 jeh Added DEV_GetSymbol().
- *! 09-May-2000 rr: dwMemBase has index for multiple windows need.
- *! 28-Feb-2000 rr: New GT Usage implemented.
- *! 03-Feb-2000 rr: GT and Module init/exit Changes.(Done up front from
- *!		    SERVICES)
- *! 31-Jan-2000 rr: Comments changed after code review.
- *! 21-Jan-2000 rr: windows.h, tchar.h, HMODULE removed. FreeLibrary replaced
- *!                 with LDR_FreeModule
- *! 17-Jan-2000 rr: CFG_Get/SetPrivateDword renamed to CFG_Get/SetDevObject.
- *!                 StoreInterfaceFxns stores the new fxn WMD_BRD_SETSTATE.
- *! 20-Nov-1999 ag: Actual uSMLength =  total - monitor offset.
- *! 12-Nov-1999 rr: bIRQ and IRQAttrib taken from the struct CFG_HOSTRES.
- *!		    dMemBase is added with offset for monitor taken from
- *!		    registry.
- *! 31-Oct-1999 ag: Added CHNL support.
- *! 10-Sep-1999 rr: GT Enabled. DEV_Create will Load the Mini Driver and will
- *!                 find its fxn table. Right now lot of things are hardcoded
- *!                 as the REG is not ready.
- *! 10-Jun-1996 rr: Created from WSX
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -130,7 +34,6 @@
 #include <dspbridge/ldr.h>
 #include <dspbridge/list.h>
 #include <dspbridge/mem.h>
-#include <dspbridge/util.h>
 
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/cod.h>
@@ -143,7 +46,6 @@
 #include <dspbridge/node.h>
 
 /*  ----------------------------------- Others */
-#include <dspbridge/dbreg.h>
 #include <dspbridge/wcd.h>		/* WCD version info. */
 
 #include <dspbridge/chnl.h>
@@ -163,7 +65,7 @@
 /* The WMD device object: */
 struct DEV_OBJECT {
 	/* LST requires "link" to be first field!                        */
-	struct LST_ELEM link;		/* Link to next DEV_OBJECT.      */
+	struct list_head link;		/* Link to next DEV_OBJECT.      */
 	u32 devType;		/* Device Type */
 	u32 dwSignature;	/* Used for object validation.   */
 	struct CFG_DEVNODE *hDevNode;	/* Platform specific device id   */
@@ -375,11 +277,14 @@ DSP_STATUS DEV_CreateDevice(OUT struct D
 	}
 	/* Create the Processor List */
 	if (DSP_SUCCEEDED(status)) {
-		pDevObject->procList = LST_Create();
+		pDevObject->procList = MEM_Calloc(sizeof(struct LST_LIST),
+			MEM_NONPAGED);
 		if (!(pDevObject->procList)) {
 			status = DSP_EFAIL;
 			GT_0trace(debugMask, GT_7CLASS, "DEV_Create: "
 				 "Failed to Create Proc List");
+		} else {
+			INIT_LIST_HEAD(&pDevObject->procList->head);
 		}
 	}
 	 /*  If all went well, return a handle to the dev object;
@@ -391,7 +296,7 @@ DSP_STATUS DEV_CreateDevice(OUT struct D
 			 "0x%x\n", pDevObject);
 	} else {
 		if (pDevObject && pDevObject->procList)
-			LST_Delete(pDevObject->procList);
+			MEM_Free(pDevObject->procList);
 
 		if (pDevObject && pDevObject->hCodMgr)
 			COD_Delete(pDevObject->hCodMgr);
@@ -497,11 +402,15 @@ DSP_STATUS DEV_DestroyDevice(struct DEV_
 	GT_1trace(debugMask, GT_ENTER, "Entered DEV_DestroyDevice, hDevObject: "
 		 "0x%x\n", hDevObject);
 	if (IsValidHandle(hDevObject)) {
-		if (pDevObject->hCodMgr)
+		if (pDevObject->hCodMgr) {
 			COD_Delete(pDevObject->hCodMgr);
+			pDevObject->hCodMgr = NULL;
+		}
 
-		if (pDevObject->hNodeMgr)
+		if (pDevObject->hNodeMgr) {
 			NODE_DeleteMgr(pDevObject->hNodeMgr);
+			pDevObject->hNodeMgr = NULL;
+		}
 
 		/* Free the io, channel, and message managers for this board: */
 		if (pDevObject->hIOMgr) {
@@ -512,28 +421,40 @@ DSP_STATUS DEV_DestroyDevice(struct DEV_
 			CHNL_Destroy(pDevObject->hChnlMgr);
 			pDevObject->hChnlMgr = NULL;
 		}
-		if (pDevObject->hMsgMgr)
+		if (pDevObject->hMsgMgr) {
 			MSG_Delete(pDevObject->hMsgMgr);
+			pDevObject->hMsgMgr = NULL;
+		}
 
 		if (pDevObject->hDehMgr) {
 			/* Uninitialize DEH module. */
 			(*pDevObject->intfFxns.pfnDehDestroy)
 			(pDevObject->hDehMgr);
+			pDevObject->hDehMgr = NULL;
 		}
-		if (pDevObject->hCmmMgr)
+		if (pDevObject->hCmmMgr) {
 			CMM_Destroy(pDevObject->hCmmMgr, true);
+			pDevObject->hCmmMgr = NULL;
+		}
 
-		if (pDevObject->hDmmMgr)
+		if (pDevObject->hDmmMgr) {
 			DMM_Destroy(pDevObject->hDmmMgr);
+			pDevObject->hDmmMgr = NULL;
+		}
 
 		/* Call the driver's WMD_DEV_Destroy() function: */
 		/* Require of DevDestroy */
-		DBC_Assert(pDevObject->hWmdContext != NULL);
-		status = (*pDevObject->intfFxns.pfnDevDestroy)
-			 (pDevObject->hWmdContext);
+		if (pDevObject->hWmdContext) {
+			status = (*pDevObject->intfFxns.pfnDevDestroy)
+				(pDevObject->hWmdContext);
+			pDevObject->hWmdContext = NULL;
+		} else
+			status = DSP_EFAIL;
 		if (DSP_SUCCEEDED(status)) {
-			if (pDevObject->procList)
-				LST_Delete(pDevObject->procList);
+			if (pDevObject->procList) {
+				MEM_Free(pDevObject->procList);
+				pDevObject->procList = NULL;
+			}
 
 			/* Remove this DEV_Object from the global list: */
 			DRV_RemoveDevObject(pDevObject->hDrvObject, pDevObject);
@@ -541,6 +462,7 @@ DSP_STATUS DEV_DestroyDevice(struct DEV_
 			 * (pDevObject->hModule);*/
 			/* Free this dev object: */
 			MEM_FreeObject(pDevObject);
+			pDevObject = NULL;
 		}
 	} else {
 		GT_0trace(debugMask, GT_7CLASS, "DEV_Destroy: Invlaid handle");
@@ -1021,15 +943,15 @@ DSP_STATUS DEV_NotifyClients(struct DEV_
 	DSP_STATUS status = DSP_SOK;
 
 	struct DEV_OBJECT *pDevObject = hDevObject;
-	DSP_HPROCESSOR hProcObject;
+	void *hProcObject;
 
 	GT_2trace(debugMask, GT_ENTER,
 		 "Entered DEV_NotifyClients, hDevObject: 0x%x\n"
 		 "\t\tulStatus: 0x%x\n", hDevObject, ulStatus);
-	for (hProcObject = (DSP_HPROCESSOR)LST_First(pDevObject->procList);
+	for (hProcObject = (void *)LST_First(pDevObject->procList);
 		hProcObject != NULL;
-		hProcObject = (DSP_HPROCESSOR)LST_Next(pDevObject->procList,
-						(struct LST_ELEM *)hProcObject))
+		hProcObject = (void *)LST_Next(pDevObject->procList,
+					(struct list_head *)hProcObject))
 		PROC_NotifyClients(hProcObject, (u32) ulStatus);
 
 	return status;
@@ -1286,7 +1208,7 @@ DSP_STATUS DEV_InsertProcObject(struct D
 		*pbAlreadyAttached = true;
 
 	/* Add DevObject to tail. */
-	LST_PutTail(pDevObject->procList, (struct LST_ELEM *)hProcObject);
+	LST_PutTail(pDevObject->procList, (struct list_head *)hProcObject);
 
 	GT_1trace(debugMask, GT_ENTER,
 		 "Exiting DEV_InsetProcObject status 0x%x\n", status);
@@ -1317,7 +1239,7 @@ DSP_STATUS DEV_RemoveProcObject(struct D
 				     u32 hProcObject)
 {
 	DSP_STATUS status = DSP_EFAIL;
-	struct LST_ELEM *pCurElem;
+	struct list_head *pCurElem;
 	struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)hDevObject;
 
 	DBC_Require(IsValidHandle(pDevObject));
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/dmm.c kernel-power-2.6.28/drivers/dsp/bridge/pmgr/dmm.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/dmm.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/pmgr/dmm.c	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,13 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * The Dynamic Memory Manager (DMM) module manages the DSP Virtual address
+ * space that can be directly mapped to any MPU buffer or memory region
+ *
+ * Notes:
+ *   Region: Generic memory entitiy having a start address and a size
+ *   Chunk:  Reserved region
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,46 +21,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== dmm.c ========
- *  Purpose:
- *      The Dynamic Memory Manager (DMM) module manages the DSP Virtual address
- *      space that can be directly mapped to any MPU buffer or memory region
- *
- *  Public Functions:
- *      DMM_CreateTables
- *      DMM_Create
- *      DMM_Destroy
- *      DMM_Exit
- *      DMM_Init
- *      DMM_MapMemory
- *      DMM_Reset
- *      DMM_ReserveMemory
- *      DMM_UnMapMemory
- *      DMM_UnReserveMemory
- *
- *  Private Functions:
- *      AddRegion
- *      CreateRegion
- *      GetRegion
- *	GetFreeRegion
- *	GetMappedRegion
- *
- *  Notes:
- *      Region: Generic memory entitiy having a start address and a size
- *      Chunk:  Reserved region
- *
- *
- *! Revision History:
- *! ================
- *! 04-Jun-2008 Hari K : Optimized DMM implementation. Removed linked list
- *!                                and instead used Table approach.
- *! 19-Apr-2004 sb: Integrated Alan's code review updates.
- *! 17-Mar-2004 ap: Fixed GetRegion for size=0 using tighter bound.
- *! 20-Feb-2004 sb: Created.
- *!
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -67,7 +34,6 @@
 #include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/sync.h>
 
@@ -290,7 +256,7 @@ void DMM_Exit(void)
  *      Return the dynamic memory manager object for this device.
  *      This is typically called from the client process.
  */
-DSP_STATUS DMM_GetHandle(DSP_HPROCESSOR hProcessor,
+DSP_STATUS DMM_GetHandle(void *hProcessor,
 			OUT struct DMM_OBJECT **phDmmMgr)
 {
 	DSP_STATUS status = DSP_SOK;
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/io.c kernel-power-2.6.28/drivers/dsp/bridge/pmgr/io.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/io.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/pmgr/io.c	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * IO manager interface: Manages IO between CHNL and MSG.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,29 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== io.c ========
- *  Description:
- *      IO manager interface: Manages IO between CHNL and MSG.
- *
- *  Public Functions:
- *      IO_Create
- *      IO_Destroy
- *      IO_Exit
- *      IO_Init
- *      IO_OnLoaded
- *
- *  Notes:
- *      This interface is basically a pass through to the WMD IO functions.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 swa 	PMGR Code review comments incorporated.
- *! 04-Apr-2001 rr      WSX_STATUS initialized in IO_Create.
- *! 07-Nov-2000 jeh     Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -106,11 +85,13 @@ DSP_STATUS IO_Create(OUT struct IO_MGR *
 	}
 
 	if (DSP_SUCCEEDED(status)) {
-		DEV_GetIntfFxns(hDevObject, &pIntfFxns);
+		status = DEV_GetIntfFxns(hDevObject, &pIntfFxns);
 
-		/* Let WMD channel module finish the create: */
-		status = (*pIntfFxns->pfnIOCreate)(&hIOMgr, hDevObject,
-			 pMgrAttrs);
+		if (pIntfFxns) {
+			/* Let WMD channel module finish the create */
+			status = (*pIntfFxns->pfnIOCreate)(&hIOMgr, hDevObject,
+					pMgrAttrs);
+		}
 
 		if (DSP_SUCCEEDED(status)) {
 			pIOMgr = (struct IO_MGR_ *) hIOMgr;
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/ioobj.h kernel-power-2.6.28/drivers/dsp/bridge/pmgr/ioobj.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/ioobj.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/pmgr/ioobj.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Structure subcomponents of channel class library IO objects which
+ * are exposed to class driver from mini-driver.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,22 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== ioobj.h ========
- *  Description:
- *      Structure subcomponents of channel class library IO objects which
- *      are exposed to class driver from mini-driver.
- *
- *  Public Functions:
- *      None.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 swa PMGR Code review comments incorporated.
- *! 01/16/97 gp: Created from chnlpriv.h
- */
-
 #ifndef IOOBJ_
 #define IOOBJ_
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/msg.c kernel-power-2.6.28/drivers/dsp/bridge/pmgr/msg.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/msg.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/pmgr/msg.c	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge MSG Module.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,27 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== msg.c ========
- *  Description:
- *      DSP/BIOS Bridge MSG Module.
- *
- *  Public Functions:
- *      MSG_Create
- *      MSG_Delete
- *      MSG_Exit
- *      MSG_Init
- *
- *! Revision History:
- *! =================
- *! 24-Feb-2003 swa 	PMGR Code review comments incorporated.
- *! 15-May-2001 ag      Changed SUCCEEDED to DSP_SUCCEEDED.
- *! 16-Feb-2001 jeh     Fixed some comments.
- *! 15-Dec-2000 rr      MSG_Create returns DSP_EFAIL if pfnMsgCreate fails.
- *! 12-Sep-2000 jeh     Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -48,7 +29,6 @@
 #include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 
 /*  ----------------------------------- Mini Driver */
@@ -92,10 +72,13 @@ DSP_STATUS MSG_Create(OUT struct MSG_MGR
 
 	*phMsgMgr = NULL;
 
-	DEV_GetIntfFxns(hDevObject, &pIntfFxns);
+	status = DEV_GetIntfFxns(hDevObject, &pIntfFxns);
 
-	/* Let WMD message module finish the create: */
-	status = (*pIntfFxns->pfnMsgCreate)(&hMsgMgr, hDevObject, msgCallback);
+	if (pIntfFxns) {
+		/* Let WMD message module finish the create */
+		status = (*pIntfFxns->pfnMsgCreate)(&hMsgMgr,
+				hDevObject, msgCallback);
+	}
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Fill in WCD message module's fields of the MSG_MGR
@@ -134,7 +117,9 @@ void MSG_Delete(struct MSG_MGR *hMsgMgr)
 	/* Let WMD message module destroy the MSG_MGR: */
 	(*pIntfFxns->pfnMsgDelete)(hMsgMgr);
 
-	DBC_Ensure(!MEM_IsValidHandle(pMsgMgr, MSGMGR_SIGNATURE));
+	if (MEM_IsValidHandle(pMsgMgr, MSGMGR_SIGNATURE))
+		GT_1trace(MSG_debugMask, GT_7CLASS, "MSG_Delete: Error hMsgMgr "
+					"Valid Handle: 0x%x\n", hMsgMgr);
 }
 
 /*
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/msgobj.h kernel-power-2.6.28/drivers/dsp/bridge/pmgr/msgobj.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/msgobj.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/pmgr/msgobj.h	2011-05-02 22:36:49.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Structure subcomponents of channel class library MSG objects which
+ * are exposed to class driver from mini-driver.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,22 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== msgobj.h ========
- *  Description:
- *      Structure subcomponents of channel class library MSG objects which
- *      are exposed to class driver from mini-driver.
- *
- *  Public Functions:
- *      None.
- *
- *! Revision History:
- *! ================
- *! 24-Feb-2003 swa 	PMGR Code review comments incorporated.
- *! 17-Nov-2000 jeh     Created.
- */
-
 #ifndef MSGOBJ_
 #define MSGOBJ_
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/wcd.c kernel-power-2.6.28/drivers/dsp/bridge/pmgr/wcd.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/pmgr/wcd.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/pmgr/wcd.c	2011-05-06 14:38:05.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Common WCD functions, also includes the wrapper
+ * functions called directly by the DeviceIOControl interface.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,83 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== wcd.c ========
- *  Description:
- *      Common WCD functions, also includes the wrapper
- *      functions called directly by the DeviceIOControl interface.
- *
- *  Public Functions:
- *      WCD_CallDevIOCtl
- *      WCD_Init
- *      WCD_InitComplete2
- *      WCD_Exit
- *      <MOD>WRAP_*
- *
- *! Revision History:
- *! ================
- *! 29-Apr-2004 hp  Call PROC_AutoStart only for DSP device
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping APIs
- *! 03-Apr-2003 sb  Process environment pointer in PROCWRAP_Load
- *! 24-Feb-2003 swa PMGR Code review comments incorporated.
- *! 30-Jan-2002 ag  CMMWRAP_AllocBuf name changed to CMMWRAP_CallocBuf
- *! 15-Jan-2002 ag  Added actual bufSize param to STRMWRAP_Reclaim[issue].
- *! 14-Dec-2001 rr  ARGS_NODE_CONNECT maps the pAttr.
- *! 03-Oct-2001 rr  ARGS_NODE_ALLOCMSGBUF/FREEMSGBUF maps the pAttr.
- *! 10-Sep-2001 ag  Added CMD_CMM_GETHANDLE.
- *! 23-Apr-2001 jeh Pass pStatus to NODE_Terminate.
- *! 11-Apr-2001 jeh STRMWRAP_Reclaim embedded pointer is mapped and unmapped.
- *! 13-Feb-2001 kc: DSP/BIOS Bridge name updates.
- *! 06-Dec-2000 jeh WRAP_MAP2CALLER pointers in RegisterNotify calls.
- *! 05-Dec-2000 ag: Removed MAP2CALLER in NODEWRAP_FreeMsgBuf().
- *! 22-Nov-2000 kc: Added MGRWRAP_GetPerf_Data().
- *! 20-Nov-2000 jeh Added MSG_Init()/MSG_Exit(), IO_Init()/IO_Exit().
- *!		 WRAP pointers to handles for PROC_Attach, NODE_Allocate.
- *! 27-Oct-2000 jeh Added NODEWRAP_AllocMsgBuf, NODEWRAP_FreeMsgBuf. Removed
- *!		 NODEWRAP_GetMessageStream.
- *! 12-Oct-2000 ag: Added user CMM wrappers.
- *! 05-Oct-2000 rr: WcdInitComplete2 will fail even if one BRD or PROC
- *!		 AutoStart fails.
- *! 25-Sep-2000 rr: Updated to Version 0.9
- *! 13-Sep-2000 jeh Pass ARGS_NODE_CONNECT.pAttrs to NODE_Connect().
- *! 11-Aug-2000 rr: Part of node enabled.
- *! 31-Jul-2000 rr: UTIL_Wrap and MEM_Wrap added to RM.
- *! 27-Jul-2000 rr: PROCWRAP, NODEWRAP and STRMWRAP implemented.
- *!		 STRM and some NODE Wrappers are not implemented.
- *! 27-Jun-2000 rr: MGRWRAP fxns added.IFDEF to build for PM or DSP/BIOS Bridge
- *! 08-Feb-2000 rr  File name changed to wcd.c
- *! 03-Feb-2000 rr: Module initialization are done by SERVICES init. GT Class
- *!		 changes for module init/exit fxns.
- *! 24-Jan-2000 rr: Merged with Scott's code.
- *! 21-Jan-1999 sg: Changed ARGS_CHNL_GETMODE field name from pdwMode to pMode.
- *! 17-Jan-2000 rr: BRD_GetStatus does WRAP_MAP2CALLER for state.
- *! 14-Dec-1999 ag: Removed _MAP2CALLER in CHNL_GetMgr().
- *! 13-Dec-1999 rr: BRDWRAP_GetSymbol, BRDWRAP_GetTrace uses WRAP_MAP2CALLER
- *!		 macros.BRDWRAP_Load maps and unmaps embedded pointers.
- *! 10-Dec-1999 ag: User CHNL bufs mapped in _AddIOReq & _GetIOCompletion.
- *! 09-Dec-1999 rr: BRDWRAP_Open and CHNLWRAP_GetMgr does not map
- *!		 pointer as there was a change in config.c
- *! 06-Dec-1999 rr: BRD_Read and Write Maps the buf pointers.
- *! 03-Dec-1999 rr: CHNLWRAP_GetMgr and BRDWRAP_Open maps  hDevNode pointer.
- *!		 WCD_InitComplete2 Included for BRD_AutoStart.
- *! 16-Nov-1999 ag: Map buf to process in CHNLWRAP_AllocBuffer().
- *!		 CHNL_GetMgr() Mapping Fix.
- *! 10-Nov-1999 ag: Removed unnecessary calls to WRAP_MAP2CALLER.
- *! 08-Nov-1999 kc: Added MEMRY & enabled BRD_IOCtl for tests.
- *! 29-Oct-1999 ag: Added CHNL.
- *! 29-Oct-1999 kc: Added trace statements; added ptr mapping; updated
- *!		 use of UTIL module API.
- *! 29-Oct-1999 rr: Wrapper functions does the Mapping of the Pointers.
- *!		 in WinCE all the explicit pointers will be converted
- *!		 by the OS during interprocess but not the embedded pointers.
- *! 16-Oct-1999 kc: Code review cleanup.
- *! 07-Oct-1999 kc: Added UTILWRAP_TestDll() to run PM test harness. See
- *!		 /src/doc/pmtest.doc for more detail.
- *! 09-Sep-1999 rr: After exactly two years(!). Adopted for WinCE. GT Enabled.
- *! 09-Sep-1997 gp: Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -108,7 +34,6 @@
 #include <dspbridge/mem.h>
 #include <dspbridge/ntfy.h>
 #include <dspbridge/services.h>
-#include <dspbridge/util.h>
 
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/chnl.h>
@@ -134,9 +59,7 @@
 #include <dspbridge/_dcd.h>
 #include <dspbridge/dbdcd.h>
 
-#ifndef RES_CLEANUP_DISABLE
 #include <dspbridge/resourcecleanup.h>
-#endif
 
 /*  ----------------------------------- Defines, Data Structures, Typedefs */
 #define MAX_TRACEBUFLEN 255
@@ -145,6 +68,30 @@
 #define MAX_STREAMS     16
 #define MAX_BUFS	64
 
+#ifdef CONFIG_BRIDGE_NEW_API
+
+/* Used to get dspbridge ioctl table */
+#define DB_GET_IOC_TABLE(cmd)	(DB_GET_MODULE(cmd) >> DB_MODULE_SHIFT)
+
+#else /* CONFIG_BRIDGE_NEW_API */
+/* Used to get dspbridge ioctl table */
+static int DB_GET_IOC_TABLE(int cmd)
+{
+    if(cmd<DB_PROC)
+	return 0;
+    else if(cmd<DB_NODE)
+	return 1;
+    else if(cmd<DB_STRM)
+	return 2;
+    else if(cmd<DB_CMM)
+	return 3;
+    else
+	return 4;
+}
+#undef _IOC_TYPE
+#define _IOC_TYPE(cmd) DB
+
+#endif
 /* Device IOCtl function pointer */
 struct WCD_Cmd {
 	u32(*fxn)(union Trapped_Args *args, void *pr_ctxt);
@@ -157,6 +104,95 @@ static struct GT_Mask WCD_debugMask = { 
 #endif
 static u32 WCD_cRefs;
 
+/*
+ *  Function tables.
+ *  The order of these functions MUST be the same as the order of the command
+ *  numbers defined in wcdioctl.h  This is how an IOCTL number in user mode
+ *  turns into a function call in kernel mode.
+ */
+
+/* MGR wrapper functions */
+static struct WCD_Cmd mgr_cmd[] = {
+	{MGRWRAP_EnumNode_Info},		/* MGR_ENUMNODE_INFO */
+	{MGRWRAP_EnumProc_Info},		/* MGR_ENUMPROC_INFO */
+	{MGRWRAP_RegisterObject},		/* MGR_REGISTEROBJECT */
+	{MGRWRAP_UnregisterObject},		/* MGR_UNREGISTEROBJECT */
+	{MGRWRAP_WaitForBridgeEvents},		/* MGR_WAIT */
+	{MGRWRAP_GetProcessResourcesInfo},	/* MGR_GET_PROC_RES */
+};
+
+/* PROC wrapper functions */
+static struct WCD_Cmd proc_cmd[] = {
+	{PROCWRAP_Attach},			/* PROC_ATTACH */
+	{PROCWRAP_Ctrl},			/* PROC_CTRL */
+	{PROCWRAP_Detach},			/* PROC_DETACH */
+	{PROCWRAP_EnumNode_Info},		/* PROC_ENUMNODE */
+	{PROCWRAP_EnumResources},		/* PROC_ENUMRESOURCES */
+	{PROCWRAP_GetState},			/* PROC_GET_STATE */
+	{PROCWRAP_GetTrace},			/* PROC_GET_TRACE */
+	{PROCWRAP_Load},			/* PROC_LOAD */
+	{PROCWRAP_RegisterNotify},		/* PROC_REGISTERNOTIFY */
+	{PROCWRAP_Start},			/* PROC_START */
+	{PROCWRAP_ReserveMemory},		/* PROC_RSVMEM */
+	{PROCWRAP_UnReserveMemory},		/* PROC_UNRSVMEM */
+	{PROCWRAP_Map},				/* PROC_MAPMEM */
+	{PROCWRAP_UnMap},			/* PROC_UNMAPMEM */
+	{PROCWRAP_FlushMemory},			/* PROC_FLUSHMEMORY */
+	{PROCWRAP_Stop},			/* PROC_STOP */
+	{PROCWRAP_InvalidateMemory},		/* PROC_INVALIDATEMEMORY */
+};
+
+/* NODE wrapper functions */
+static struct WCD_Cmd node_cmd[] = {
+	{NODEWRAP_Allocate},			/* NODE_ALLOCATE */
+	{NODEWRAP_AllocMsgBuf},			/* NODE_ALLOCMSGBUF */
+	{NODEWRAP_ChangePriority},		/* NODE_CHANGEPRIORITY */
+	{NODEWRAP_Connect},			/* NODE_CONNECT */
+	{NODEWRAP_Create},			/* NODE_CREATE */
+	{NODEWRAP_Delete},			/* NODE_DELETE */
+	{NODEWRAP_FreeMsgBuf},			/* NODE_FREEMSGBUF */
+	{NODEWRAP_GetAttr},			/* NODE_GETATTR */
+	{NODEWRAP_GetMessage},			/* NODE_GETMESSAGE */
+	{NODEWRAP_Pause},			/* NODE_PAUSE */
+	{NODEWRAP_PutMessage},			/* NODE_PUTMESSAGE */
+	{NODEWRAP_RegisterNotify},		/* NODE_REGISTERNOTIFY */
+	{NODEWRAP_Run},				/* NODE_RUN */
+	{NODEWRAP_Terminate},			/* NODE_TERMINATE */
+	{NODEWRAP_GetUUIDProps},		/* NODE_GETUUIDPROPS */
+};
+
+/* STRM wrapper functions */
+static struct WCD_Cmd strm_cmd[] = {
+	{STRMWRAP_AllocateBuffer},		/* STRM_ALLOCATEBUFFER */
+	{STRMWRAP_Close},			/* STRM_CLOSE */
+	{STRMWRAP_FreeBuffer},			/* STRM_FREEBUFFER */
+	{STRMWRAP_GetEventHandle},		/* STRM_GETEVENTHANDLE */
+	{STRMWRAP_GetInfo},			/* STRM_GETINFO */
+	{STRMWRAP_Idle},			/* STRM_IDLE */
+	{STRMWRAP_Issue},			/* STRM_ISSUE */
+	{STRMWRAP_Open},			/* STRM_OPEN */
+	{STRMWRAP_Reclaim},			/* STRM_RECLAIM */
+	{STRMWRAP_RegisterNotify},		/* STRM_REGISTERNOTIFY */
+	{STRMWRAP_Select},			/* STRM_SELECT */
+};
+
+/* CMM wrapper functions */
+static struct WCD_Cmd cmm_cmd[] = {
+	{CMMWRAP_CallocBuf},			/* CMM_ALLOCBUF */
+	{CMMWRAP_FreeBuf},			/* CMM_FREEBUF */
+	{CMMWRAP_GetHandle},			/* CMM_GETHANDLE */
+	{CMMWRAP_GetInfo},			/* CMM_GETINFO */
+};
+
+/* Array used to store ioctl table sizes. It can hold up to 8 entries */
+static u8 size_cmd[] = {
+	ARRAY_SIZE(mgr_cmd),
+	ARRAY_SIZE(proc_cmd),
+	ARRAY_SIZE(node_cmd),
+	ARRAY_SIZE(strm_cmd),
+	ARRAY_SIZE(cmm_cmd),
+};
+
 static inline void __cp_fm_usr(void *to, const void __user *from,
 			       DSP_STATUS *err, unsigned long bytes)
 {
@@ -198,89 +234,63 @@ static inline void __cp_to_usr(void __us
 	__cp_to_usr(to, from, &(err), (n) * sizeof(*(from)))
 
 /*
- *  Function table.
- *  The order of these functions MUST be the same as the order of the command
- *  numbers defined in wcdioctl.h  This is how an IOCTL number in user mode
- *  turns into a function call in kernel mode.
- */
-static struct WCD_Cmd WCD_cmdTable[] = {
-	/* MGR module */
-	{MGRWRAP_EnumNode_Info, CMD_MGR_ENUMNODE_INFO_OFFSET},
-	{MGRWRAP_EnumProc_Info, CMD_MGR_ENUMPROC_INFO_OFFSET},
-	{MGRWRAP_RegisterObject, CMD_MGR_REGISTEROBJECT_OFFSET},
-	{MGRWRAP_UnregisterObject, CMD_MGR_UNREGISTEROBJECT_OFFSET},
-	{MGRWRAP_WaitForBridgeEvents, CMD_MGR_WAIT_OFFSET},
-#ifndef RES_CLEANUP_DISABLE
-	{MGRWRAP_GetProcessResourcesInfo, CMD_MGR_RESOUCES_OFFSET},
-#endif
-	/* PROC Module */
-	{PROCWRAP_Attach, CMD_PROC_ATTACH_OFFSET},
-	{PROCWRAP_Ctrl, CMD_PROC_CTRL_OFFSET},
-	{PROCWRAP_Detach, CMD_PROC_DETACH_OFFSET},
-	{PROCWRAP_EnumNode_Info, CMD_PROC_ENUMNODE_OFFSET},
-	{PROCWRAP_EnumResources, CMD_PROC_ENUMRESOURCES_OFFSET},
-	{PROCWRAP_GetState, CMD_PROC_GETSTATE_OFFSET},
-	{PROCWRAP_GetTrace, CMD_PROC_GETTRACE_OFFSET},
-	{PROCWRAP_Load, CMD_PROC_LOAD_OFFSET},
-	{PROCWRAP_RegisterNotify, CMD_PROC_REGISTERNOTIFY_OFFSET},
-	{PROCWRAP_Start, CMD_PROC_START_OFFSET},
-	{PROCWRAP_ReserveMemory, CMD_PROC_RSVMEM_OFFSET},
-	{PROCWRAP_UnReserveMemory, CMD_PROC_UNRSVMEM_OFFSET},
-	{PROCWRAP_Map, CMD_PROC_MAPMEM_OFFSET},
-	{PROCWRAP_UnMap, CMD_PROC_UNMAPMEM_OFFSET},
-	{PROCWRAP_FlushMemory, CMD_PROC_FLUSHMEMORY_OFFSET},
-	{PROCWRAP_Stop, CMD_PROC_STOP_OFFSET},
-	{PROCWRAP_InvalidateMemory, CMD_PROC_INVALIDATEMEMORY_OFFSET},
-	/* NODE Module */
-	{NODEWRAP_Allocate, CMD_NODE_ALLOCATE_OFFSET},
-	{NODEWRAP_AllocMsgBuf, CMD_NODE_ALLOCMSGBUF_OFFSET},
-	{NODEWRAP_ChangePriority, CMD_NODE_CHANGEPRIORITY_OFFSET},
-	{NODEWRAP_Connect, CMD_NODE_CONNECT_OFFSET},
-	{NODEWRAP_Create, CMD_NODE_CREATE_OFFSET},
-	{NODEWRAP_Delete, CMD_NODE_DELETE_OFFSET},
-	{NODEWRAP_FreeMsgBuf, CMD_NODE_FREEMSGBUF_OFFSET},
-	{NODEWRAP_GetAttr, CMD_NODE_GETATTR_OFFSET},
-	{NODEWRAP_GetMessage, CMD_NODE_GETMESSAGE_OFFSET},
-	{NODEWRAP_Pause, CMD_NODE_PAUSE_OFFSET},
-	{NODEWRAP_PutMessage, CMD_NODE_PUTMESSAGE_OFFSET},
-	{NODEWRAP_RegisterNotify, CMD_NODE_REGISTERNOTIFY_OFFSET},
-	{NODEWRAP_Run, CMD_NODE_RUN_OFFSET},
-	{NODEWRAP_Terminate, CMD_NODE_TERMINATE_OFFSET},
-	{NODEWRAP_GetUUIDProps, CMD_NODE_GETUUIDPROPS_OFFSET},
-	/* STRM wrapper functions */
-	{STRMWRAP_AllocateBuffer, CMD_STRM_ALLOCATEBUFFER_OFFSET},
-	{STRMWRAP_Close, CMD_STRM_CLOSE_OFFSET},
-	{STRMWRAP_FreeBuffer, CMD_STRM_FREEBUFFER_OFFSET},
-	{STRMWRAP_GetEventHandle, CMD_STRM_GETEVENTHANDLE_OFFSET},
-	{STRMWRAP_GetInfo, CMD_STRM_GETINFO_OFFSET},
-	{STRMWRAP_Idle, CMD_STRM_IDLE_OFFSET},
-	{STRMWRAP_Issue, CMD_STRM_ISSUE_OFFSET},
-	{STRMWRAP_Open, CMD_STRM_OPEN_OFFSET},
-	{STRMWRAP_Reclaim, CMD_STRM_RECLAIM_OFFSET},
-	{STRMWRAP_RegisterNotify, CMD_STRM_REGISTERNOTIFY_OFFSET},
-	{STRMWRAP_Select, CMD_STRM_SELECT_OFFSET},
-	/* CMM module */
-	{CMMWRAP_CallocBuf, CMD_CMM_ALLOCBUF_OFFSET},
-	{CMMWRAP_FreeBuf, CMD_CMM_FREEBUF_OFFSET},
-	{CMMWRAP_GetHandle, CMD_CMM_GETHANDLE_OFFSET},
-	{CMMWRAP_GetInfo, CMD_CMM_GETINFO_OFFSET}
-};
-
-/*
  *  ======== WCD_CallDevIOCtl ========
  *  Purpose:
  *      Call the (wrapper) function for the corresponding WCD IOCTL.
  */
 inline DSP_STATUS WCD_CallDevIOCtl(u32 cmd, union Trapped_Args *args,
-				    u32 *pResult, void *pr_ctxt)
+				    u32 *result, void *pr_ctxt)
 {
-	if ((cmd < (sizeof(WCD_cmdTable) / sizeof(struct WCD_Cmd)))) {
-		/* make the fxn call via the cmd table */
-		*pResult = (*WCD_cmdTable[cmd].fxn) (args, pr_ctxt);
-		return DSP_SOK;
+	u32 (*ioctl_cmd)(union Trapped_Args *args, void *pr_ctxt) = NULL;
+	int i;
+
+	if (_IOC_TYPE(cmd) != DB) {
+		pr_err("%s: Incompatible dspbridge ioctl number\n", __func__);
+		goto err;
+	}
+
+	if (DB_GET_IOC_TABLE(cmd) > ARRAY_SIZE(size_cmd)) {
+		pr_err("%s: undefined ioctl module\n", __func__);
+		goto err;
+	}
+
+	/* Check the size of the required cmd table */
+	i = DB_GET_IOC(cmd);
+	if (i > size_cmd[DB_GET_IOC_TABLE(cmd)]) {
+		pr_err("%s: requested ioctl %d out of bounds for table %d\n",
+					__func__, i, DB_GET_IOC_TABLE(cmd));
+		goto err;
+	}
+
+	switch (DB_GET_MODULE(cmd)) {
+	case DB_MGR:
+		ioctl_cmd = mgr_cmd[i].fxn;
+		break;
+	case DB_PROC:
+		ioctl_cmd = proc_cmd[i].fxn;
+		break;
+	case DB_NODE:
+		ioctl_cmd = node_cmd[i].fxn;
+		break;
+	case DB_STRM:
+		ioctl_cmd = strm_cmd[i].fxn;
+		break;
+	case DB_CMM:
+		ioctl_cmd = cmm_cmd[i].fxn;
+		break;
+	}
+
+	if (!ioctl_cmd) {
+		pr_err("%s: requested ioctl not defined\n", __func__);
+		goto err;
 	} else {
-		return DSP_EINVALIDARG;
+		*result = (*ioctl_cmd)(args, pr_ctxt);
 	}
+
+	return DSP_SOK;
+
+err:
+	return -EINVAL;
 }
 
 /*
@@ -300,14 +310,12 @@ void WCD_Exit(void)
 		MSG_Exit();
 		IO_Exit();
 		STRM_Exit();
-		NTFY_Exit();
 		DISP_Exit();
 		NODE_Exit();
 		PROC_Exit();
 		MGR_Exit();
 		RMM_exit();
 		DRV_Exit();
-		SERVICES_Exit();
 	}
 	DBC_Ensure(WCD_cRefs >= 0);
 }
@@ -320,18 +328,10 @@ void WCD_Exit(void)
 bool WCD_Init(void)
 {
 	bool fInit = true;
-	bool fDRV, fDEV, fCOD, fSERVICES, fCHNL, fMSG, fIO;
-	bool fMGR, fPROC, fNODE, fDISP, fNTFY, fSTRM, fRMM;
-#ifdef DEBUG
-	/* runtime check of Device IOCtl array. */
-	u32 i;
-	for (i = 1; i < (sizeof(WCD_cmdTable) / sizeof(struct WCD_Cmd)); i++)
-		DBC_Assert(WCD_cmdTable[i - 1].dwIndex == i);
+	bool fDRV, fDEV, fCOD, fCHNL, fMSG, fIO;
+	bool fMGR, fPROC, fNODE, fDISP, fSTRM, fRMM;
 
-#endif
 	if (WCD_cRefs == 0) {
-		/* initialize all SERVICES modules */
-		fSERVICES = SERVICES_Init();
 		/* initialize debugging module */
 		DBC_Assert(!WCD_debugMask.flags);
 		GT_create(&WCD_debugMask, "CD");    /* CD for class driver */
@@ -341,7 +341,6 @@ bool WCD_Init(void)
 		fPROC = PROC_Init();
 		fNODE = NODE_Init();
 		fDISP = DISP_Init();
-		fNTFY = NTFY_Init();
 		fSTRM = STRM_Init();
 		fRMM = RMM_init();
 		fCHNL = CHNL_Init();
@@ -349,13 +348,10 @@ bool WCD_Init(void)
 		fIO = IO_Init();
 		fDEV = DEV_Init();
 		fCOD = COD_Init();
-		fInit = fSERVICES && fDRV && fDEV && fCHNL && fCOD &&
+		fInit = fDRV && fDEV && fCHNL && fCOD &&
 			fMSG && fIO;
 		fInit = fInit && fMGR && fPROC && fRMM;
 		if (!fInit) {
-			if (fSERVICES)
-				SERVICES_Exit();
-
 			if (fDRV)
 				DRV_Exit();
 
@@ -374,9 +370,6 @@ bool WCD_Init(void)
 			if (fDISP)
 				DISP_Exit();
 
-			if (fNTFY)
-				NTFY_Exit();
-
 			if (fCHNL)
 				CHNL_Exit();
 
@@ -457,6 +450,8 @@ DSP_STATUS WCD_InitComplete2(void)
 	return status;
 }
 
+/* TODO: Remove deprecated and not implemented ioctl wrappers */
+
 /*
  * ======== MGRWRAP_EnumNode_Info ========
  */
@@ -474,6 +469,10 @@ u32 MGRWRAP_EnumNode_Info(union Trapped_
 		 args->ARGS_MGR_ENUMNODE_INFO.pNDBProps,
 		 args->ARGS_MGR_ENUMNODE_INFO.uNDBPropsSize,
 		 args->ARGS_MGR_ENUMNODE_INFO.puNumNodes);
+
+	if (size < sizeof(struct DSP_NDBPROPS))
+		return DSP_ESIZE;
+
 	pNDBProps = MEM_Alloc(size, MEM_NONPAGED);
 	if (pNDBProps == NULL)
 		status = DSP_EMEMORY;
@@ -511,6 +510,10 @@ u32 MGRWRAP_EnumProc_Info(union Trapped_
 		 args->ARGS_MGR_ENUMPROC_INFO.pProcessorInfo,
 		 args->ARGS_MGR_ENUMPROC_INFO.uProcessorInfoSize,
 		 args->ARGS_MGR_ENUMPROC_INFO.puNumProcs);
+
+	if (size < sizeof(struct DSP_PROCESSORINFO))
+		return DSP_ESIZE;
+
 	pProcessorInfo = MEM_Alloc(size, MEM_NONPAGED);
 	if (pProcessorInfo == NULL)
 		status = DSP_EMEMORY;
@@ -543,6 +546,11 @@ u32 MGRWRAP_RegisterObject(union Trapped
 	char *pszPathName = NULL;
 	DSP_STATUS status = DSP_SOK;
 
+
+	GT_1trace(WCD_debugMask, GT_ENTER,
+		 "MGRWRAP_RegisterObject: entered "
+		 "0x%x\n", args->ARGS_MGR_REGISTEROBJECT.pUuid);
+
 	cp_fm_usr(&pUuid, args->ARGS_MGR_REGISTEROBJECT.pUuid, status, 1);
 	if (DSP_FAILED(status))
 		goto func_end;
@@ -560,9 +568,9 @@ u32 MGRWRAP_RegisterObject(union Trapped
 		goto func_end;
 	}
 
-	GT_1trace(WCD_debugMask, GT_ENTER,
-		 "MGRWRAP_RegisterObject: entered pg2hMsg "
-		 "0x%x\n", args->ARGS_MGR_REGISTEROBJECT.pUuid);
+	if (args->ARGS_MGR_REGISTEROBJECT.objType >= DSP_DCDMAXOBJTYPE)
+		return DSP_EINVALIDARG;
+
 	status = DCD_RegisterObject(&pUuid,
 				args->ARGS_MGR_REGISTEROBJECT.objType,
 				(char *)pszPathName);
@@ -631,28 +639,15 @@ u32 MGRWRAP_WaitForBridgeEvents(union Tr
 }
 
 
-#ifndef RES_CLEANUP_DISABLE
 /*
  * ======== MGRWRAP_GetProcessResourceInfo ========
  */
-u32 MGRWRAP_GetProcessResourcesInfo(union Trapped_Args *args, void *pr_ctxt)
+u32 __deprecated MGRWRAP_GetProcessResourcesInfo(union Trapped_Args *args,
+						void *pr_ctxt)
 {
-    DSP_STATUS status = DSP_SOK;
-    u32 uSize = 0;
-    u8 *pBuf = MEM_Alloc(8092, MEM_NONPAGED);
-    status = DRV_ProcDisplayResInfo(pBuf, &uSize);
-    GT_1trace(WCD_debugMask, GT_ENTER,
-	     "MGRWRAP_GetProcessResourcesInfo:uSize=%d :\n", uSize);
-    cp_to_usr(args->ARGS_PROC_GETTRACE.pBuf, pBuf, status, uSize);
-    GT_0trace(WCD_debugMask, GT_ENTER, "\n***********"
-	     "123MGRWRAP_GetProcessResourcesInfo:**************\n");
-    GT_0trace(WCD_debugMask, GT_ENTER, "\n***********"
-	     "456MGRWRAP_GetProcessResourcesInfo:**************\n");
-    cp_to_usr(args->ARGS_PROC_GETTRACE.pSize, &uSize, status, 1);
-    MEM_Free(pBuf);
-    return status;
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
+	return DSP_SOK;
 }
-#endif
 
 
 /*
@@ -660,7 +655,7 @@ u32 MGRWRAP_GetProcessResourcesInfo(unio
  */
 u32 PROCWRAP_Attach(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_HPROCESSOR processor;
+	void *processor;
 	DSP_STATUS status = DSP_SOK;
 	struct DSP_PROCESSORATTRIN attrIn, *pAttrIn = NULL;
 
@@ -696,6 +691,7 @@ u32 PROCWRAP_Ctrl(union Trapped_Args *ar
 			args->ARGS_PROC_CTRL.pArgs;
 	u8 *pArgs = NULL;
 	DSP_STATUS status = DSP_SOK;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
 
 	GT_3trace(WCD_debugMask, GT_ENTER,
 		 "PROCWRAP_Ctrl: entered args:\n 0x%x"
@@ -703,6 +699,10 @@ u32 PROCWRAP_Ctrl(union Trapped_Args *ar
 		 args->ARGS_PROC_CTRL.hProcessor,
 		 args->ARGS_PROC_CTRL.dwCmd,
 		 args->ARGS_PROC_CTRL.pArgs);
+	if (args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 	if (pSize) {
 		if (get_user(cbDataSize, pSize)) {
 			status = DSP_EFAIL;
@@ -734,16 +734,11 @@ func_end:
 /*
  * ======== PROCWRAP_Detach ========
  */
-u32 PROCWRAP_Detach(union Trapped_Args *args, void *pr_ctxt)
+u32 __deprecated PROCWRAP_Detach(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
-
-	GT_1trace(WCD_debugMask, GT_ENTER,
-		 "PROCWRAP_Detach: entered args\n0x%x "
-		 "hProceesor \n", args->ARGS_PROC_DETACH.hProcessor);
-	retVal = PROC_Detach(args->ARGS_PROC_DETACH.hProcessor, pr_ctxt);
-
-	return retVal;
+	/* PROC_Detach called at bridge_release only */
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
+	return DSP_SOK;
 }
 
 /*
@@ -752,9 +747,10 @@ u32 PROCWRAP_Detach(union Trapped_Args *
 u32 PROCWRAP_EnumNode_Info(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
-	DSP_HNODE aNodeTab[MAX_NODES];
+	void *aNodeTab[MAX_NODES];
 	u32 uNumNodes;
 	u32 uAllocated;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
 
 	GT_5trace(WCD_debugMask, GT_ENTER,
 		 "PROCWRAP_EnumNode_Info:entered args:\n0x"
@@ -765,7 +761,13 @@ u32 PROCWRAP_EnumNode_Info(union Trapped
 		 args->ARGS_PROC_ENUMNODE_INFO.uNodeTabSize,
 		 args->ARGS_PROC_ENUMNODE_INFO.puNumNodes,
 		 args->ARGS_PROC_ENUMNODE_INFO.puAllocated);
-	DBC_Require(args->ARGS_PROC_ENUMNODE_INFO.uNodeTabSize <= MAX_NODES);
+
+	if (args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor)
+		return DSP_EHANDLE;
+
+	if (!args->ARGS_PROC_ENUMNODE_INFO.uNodeTabSize)
+		return DSP_ESIZE;
+
 	status = PROC_EnumNodes(args->ARGS_PROC_ENUMNODE_INFO.hProcessor,
 				aNodeTab,
 				args->ARGS_PROC_ENUMNODE_INFO.uNodeTabSize,
@@ -785,9 +787,17 @@ u32 PROCWRAP_EnumNode_Info(union Trapped
 u32 PROCWRAP_FlushMemory(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "PROCWRAP_FlushMemory: entered\n");
 
+	if (args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor)
+		return DSP_EHANDLE;
+
+	if (args->ARGS_PROC_FLUSHMEMORY.ulFlags >
+					 PROC_WRITEBACK_INVALIDATE_MEM)
+		return DSP_EINVALIDARG;
+
 	status = PROC_FlushMemory(args->ARGS_PROC_FLUSHMEMORY.hProcessor,
 				 args->ARGS_PROC_FLUSHMEMORY.pMpuAddr,
 				 args->ARGS_PROC_FLUSHMEMORY.ulSize,
@@ -802,10 +812,14 @@ u32 PROCWRAP_FlushMemory(union Trapped_A
 u32 PROCWRAP_InvalidateMemory(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
 
 	GT_0trace(WCD_debugMask, GT_ENTER,
 		 "PROCWRAP_InvalidateMemory:entered\n");
 
+	if (args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor)
+		return DSP_EHANDLE;
+
 	status = PROC_InvalidateMemory(
 				  args->ARGS_PROC_INVALIDATEMEMORY.hProcessor,
 				  args->ARGS_PROC_INVALIDATEMEMORY.pMpuAddr,
@@ -821,9 +835,7 @@ u32 PROCWRAP_EnumResources(union Trapped
 {
 	DSP_STATUS status = DSP_SOK;
 	struct DSP_RESOURCEINFO pResourceInfo;
-
-	if (DSP_FAILED(status))
-		goto func_end;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
 
 	GT_4trace(WCD_debugMask, GT_ENTER,
 		 "PROCWRAP_EnumResources: entered args:\n"
@@ -833,15 +845,22 @@ u32 PROCWRAP_EnumResources(union Trapped
 		 args->ARGS_PROC_ENUMRESOURCES.uResourceType,
 		 args->ARGS_PROC_ENUMRESOURCES.pResourceInfo,
 		 args->ARGS_PROC_ENUMRESOURCES.uResourceInfoSize);
+
+	if (args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor)
+		return DSP_EHANDLE;
+
+	if (args->ARGS_PROC_ENUMRESOURCES.uResourceInfoSize <
+		sizeof(struct DSP_RESOURCEINFO))
+		return DSP_ESIZE;
+
 	status = PROC_GetResourceInfo(args->ARGS_PROC_ENUMRESOURCES.hProcessor,
 			args->ARGS_PROC_ENUMRESOURCES.uResourceType,
 			&pResourceInfo,
 			args->ARGS_PROC_ENUMRESOURCES.uResourceInfoSize);
-	if (DSP_FAILED(status))
-		goto func_end;
+
 	cp_to_usr(args->ARGS_PROC_ENUMRESOURCES.pResourceInfo, &pResourceInfo,
 						status, 1);
-func_end:
+
 	return status;
 
 }
@@ -853,7 +872,17 @@ u32 PROCWRAP_GetState(union Trapped_Args
 {
 	DSP_STATUS status;
 	struct DSP_PROCESSORSTATE procStatus;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
+
 	GT_0trace(WCD_debugMask, GT_ENTER, "PROCWRAP_GetState: entered\n");
+
+	if (args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor)
+		return DSP_EHANDLE;
+
+	if (args->ARGS_PROC_GETSTATE.uStateInfoSize <
+		sizeof(struct DSP_PROCESSORSTATE))
+		return DSP_ESIZE;
+
 	status = PROC_GetState(args->ARGS_PROC_GETSTATE.hProcessor, &procStatus,
 			      args->ARGS_PROC_GETSTATE.uStateInfoSize);
 	cp_to_usr(args->ARGS_PROC_GETSTATE.pProcStatus, &procStatus, status, 1);
@@ -868,10 +897,15 @@ u32 PROCWRAP_GetTrace(union Trapped_Args
 {
 	DSP_STATUS status;
 	u8 *pBuf;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "PROCWRAP_GetTrace: entered\n");
 
-	DBC_Require(args->ARGS_PROC_GETTRACE.uMaxSize <= MAX_TRACEBUFLEN);
+	if (args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor)
+		return DSP_EHANDLE;
+
+	if (args->ARGS_PROC_GETTRACE.uMaxSize > MAX_TRACEBUFLEN)
+		return DSP_ESIZE;
 
 	pBuf = MEM_Calloc(args->ARGS_PROC_GETTRACE.uMaxSize, MEM_NONPAGED);
 	if (pBuf != NULL) {
@@ -897,10 +931,18 @@ u32 PROCWRAP_Load(union Trapped_Args *ar
 	DSP_STATUS status = DSP_SOK;
 	char *temp;
 	s32 count = args->ARGS_PROC_LOAD.iArgc;
-	u8 **argv, **envp = NULL;
+	u8 **argv = NULL, **envp = NULL;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
+
+	if (args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor) {
+		status = DSP_EHANDLE;
+		goto func_cont;
+	}
 
-	DBC_Require(count > 0);
-	DBC_Require(count <= MAX_LOADARGS);
+	if (count <= 0 || count > MAX_LOADARGS) {
+		status = DSP_EINVALIDARG;
+		goto func_cont;
+	}
 
 	argv = MEM_Alloc(count * sizeof(u8 *), MEM_NONPAGED);
 	if (!argv) {
@@ -1014,16 +1056,27 @@ u32 PROCWRAP_Map(union Trapped_Args *arg
 {
 	DSP_STATUS status;
 	void *pMapAddr;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "PROCWRAP_Map: entered\n");
+
+	if (args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor)
+		return DSP_EHANDLE;
+
+	if (!args->ARGS_PROC_MAPMEM.ulSize)
+		return DSP_ESIZE;
+
 	status = PROC_Map(args->ARGS_PROC_MAPMEM.hProcessor,
 			 args->ARGS_PROC_MAPMEM.pMpuAddr,
 			 args->ARGS_PROC_MAPMEM.ulSize,
 			 args->ARGS_PROC_MAPMEM.pReqAddr, &pMapAddr,
 			 args->ARGS_PROC_MAPMEM.ulMapAttr, pr_ctxt);
 	if (DSP_SUCCEEDED(status)) {
-		if (put_user(pMapAddr, args->ARGS_PROC_MAPMEM.ppMapAddr))
+		if (put_user(pMapAddr, args->ARGS_PROC_MAPMEM.ppMapAddr)) {
 			status = DSP_EINVALIDARG;
+			PROC_UnMap(args->ARGS_PROC_MAPMEM.hProcessor,
+				pMapAddr, pr_ctxt);
+		}
 
 	}
 	return status;
@@ -1036,10 +1089,14 @@ u32 PROCWRAP_RegisterNotify(union Trappe
 {
 	DSP_STATUS status;
 	struct DSP_NOTIFICATION notification;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
 
 	GT_0trace(WCD_debugMask, GT_ENTER,
 		 "PROCWRAP_RegisterNotify: entered\n");
 
+	if (args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor)
+		return DSP_EHANDLE;
+
 	/* Initialize the notification data structure  */
 	notification.psName = NULL;
 	notification.handle = NULL;
@@ -1060,13 +1117,26 @@ u32 PROCWRAP_ReserveMemory(union Trapped
 {
 	DSP_STATUS status;
 	void *pRsvAddr;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "PROCWRAP_ReserveMemory: entered\n");
+
+	if (args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor)
+		return DSP_EHANDLE;
+
+	if ((args->ARGS_PROC_RSVMEM.ulSize <= 0) ||
+		(args->ARGS_PROC_RSVMEM.ulSize & (PG_SIZE_4K - 1)) != 0)
+		return DSP_ESIZE;
+
 	status = PROC_ReserveMemory(args->ARGS_PROC_RSVMEM.hProcessor,
 				   args->ARGS_PROC_RSVMEM.ulSize, &pRsvAddr);
-	if (put_user(pRsvAddr, args->ARGS_PROC_RSVMEM.ppRsvAddr))
-		status = DSP_EINVALIDARG;
-
+	if (DSP_SUCCEEDED(status)) {
+		if (put_user(pRsvAddr, args->ARGS_PROC_RSVMEM.ppRsvAddr)) {
+			status = DSP_EINVALIDARG;
+			PROC_UnReserveMemory(args->ARGS_PROC_RSVMEM.hProcessor,
+				pRsvAddr);
+		}
+	}
 	return status;
 }
 
@@ -1076,8 +1146,13 @@ u32 PROCWRAP_ReserveMemory(union Trapped
 u32 PROCWRAP_Start(union Trapped_Args *args, void *pr_ctxt)
 {
 	u32 retVal;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "PROCWRAP_Start: entered\n");
+
+	if (args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor)
+		return DSP_EHANDLE;
+
 	retVal = PROC_Start(args->ARGS_PROC_START.hProcessor);
 	return retVal;
 }
@@ -1088,8 +1163,13 @@ u32 PROCWRAP_Start(union Trapped_Args *a
 u32 PROCWRAP_UnMap(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "PROCWRAP_UnMap: entered\n");
+
+	if (args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor)
+		return DSP_EHANDLE;
+
 	status = PROC_UnMap(args->ARGS_PROC_UNMAPMEM.hProcessor,
 			   args->ARGS_PROC_UNMAPMEM.pMapAddr, pr_ctxt);
 	return status;
@@ -1101,9 +1181,14 @@ u32 PROCWRAP_UnMap(union Trapped_Args *a
 u32 PROCWRAP_UnReserveMemory(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
 
 	GT_0trace(WCD_debugMask, GT_ENTER,
 		 "PROCWRAP_UnReserveMemory: entered\n");
+
+	if (args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor)
+		return DSP_EHANDLE;
+
 	status = PROC_UnReserveMemory(args->ARGS_PROC_UNRSVMEM.hProcessor,
 				     args->ARGS_PROC_UNRSVMEM.pRsvAddr);
 	return status;
@@ -1115,13 +1200,41 @@ u32 PROCWRAP_UnReserveMemory(union Trapp
 u32 PROCWRAP_Stop(union Trapped_Args *args, void *pr_ctxt)
 {
 	u32 retVal;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "PROCWRAP_Stop: entered\n");
+
+	if (args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor)
+		return DSP_EHANDLE;
+
 	retVal = PROC_Stop(args->ARGS_PROC_STOP.hProcessor);
 
 	return retVal;
 }
 
+bool validate_node_handle(struct NODE_OBJECT *hNode, void *pr_ctxt)
+{
+	bool retVal = false;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
+	struct NODE_RES_OBJECT *pNode = pCtxt->pNodeList;
+
+	if (hNode == (struct NODE_OBJECT *) DSP_HGPPNODE)
+		retVal = true;
+
+	if (mutex_lock_interruptible(&pCtxt->node_mutex))
+		return DSP_EFAIL;
+
+	while (pNode && !retVal) {
+		if (hNode == pNode->hNode)
+			retVal = true;
+		pNode = pNode->next;
+	}
+
+	mutex_unlock(&pCtxt->node_mutex);
+
+	return retVal;
+}
+
 /*
  * ======== NODEWRAP_Allocate ========
  */
@@ -1134,9 +1247,15 @@ u32 NODEWRAP_Allocate(union Trapped_Args
 	u8 *pArgs = NULL;
 	struct DSP_NODEATTRIN attrIn, *pAttrIn = NULL;
 	struct NODE_OBJECT *hNode;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_Allocate: entered\n");
 
+	if (args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor) {
+		status =  DSP_EHANDLE;
+		goto func_cont;
+	}
+
 	/* Optional argument */
 	if (pSize) {
 		if (get_user(cbDataSize, pSize))
@@ -1169,7 +1288,13 @@ u32 NODEWRAP_Allocate(union Trapped_Args
 				      &nodeId, (struct DSP_CBDATA *)pArgs,
 				      pAttrIn, &hNode, pr_ctxt);
 	}
-	cp_to_usr(args->ARGS_NODE_ALLOCATE.phNode, &hNode, status, 1);
+	if (DSP_SUCCEEDED(status)) {
+		cp_to_usr(args->ARGS_NODE_ALLOCATE.phNode, &hNode, status, 1);
+		if (DSP_FAILED(status)) {
+			status = DSP_EPOINTER;
+			NODE_Delete(hNode, pr_ctxt);
+		}
+	}
 func_cont:
 	if (pArgs)
 		MEM_Free(pArgs);
@@ -1187,6 +1312,13 @@ u32 NODEWRAP_AllocMsgBuf(union Trapped_A
 	struct DSP_BUFFERATTR attr;
 	u8 *pBuffer = NULL;
 
+	if (!args->ARGS_NODE_ALLOCMSGBUF.uSize)
+		return DSP_ESIZE;
+
+	if (!validate_node_handle(args->ARGS_NODE_ALLOCMSGBUF.hNode,
+		pr_ctxt))
+		return DSP_EHANDLE;
+
 	if (args->ARGS_NODE_ALLOCMSGBUF.pAttr) {	/* Optional argument */
 		cp_fm_usr(&attr, args->ARGS_NODE_ALLOCMSGBUF.pAttr, status, 1);
 		if (DSP_SUCCEEDED(status))
@@ -1195,6 +1327,7 @@ u32 NODEWRAP_AllocMsgBuf(union Trapped_A
 	}
 	/* IN OUT argument */
 	cp_fm_usr(&pBuffer, args->ARGS_NODE_ALLOCMSGBUF.pBuffer, status, 1);
+
 	if (DSP_SUCCEEDED(status)) {
 		status = NODE_AllocMsgBuf(args->ARGS_NODE_ALLOCMSGBUF.hNode,
 					 args->ARGS_NODE_ALLOCMSGBUF.uSize,
@@ -1213,6 +1346,11 @@ u32 NODEWRAP_ChangePriority(union Trappe
 
 	GT_0trace(WCD_debugMask, GT_ENTER,
 		 "NODEWRAP_ChangePriority: entered\n");
+
+	if (!validate_node_handle(args->ARGS_NODE_CHANGEPRIORITY.hNode,
+		pr_ctxt))
+		return DSP_EHANDLE;
+
 	retVal = NODE_ChangePriority(args->ARGS_NODE_CHANGEPRIORITY.hNode,
 			args->ARGS_NODE_CHANGEPRIORITY.iPriority);
 
@@ -1233,6 +1371,13 @@ u32 NODEWRAP_Connect(union Trapped_Args 
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_Connect: entered\n");
 
+	if (!validate_node_handle(args->ARGS_NODE_CONNECT.hNode,
+		pr_ctxt) ||
+		!validate_node_handle(args->ARGS_NODE_CONNECT.hOtherNode,
+		pr_ctxt)) {
+		status = DSP_EHANDLE;
+		goto func_cont;
+	}
 	/* Optional argument */
 	if (pSize) {
 		if (get_user(cbDataSize, pSize))
@@ -1258,6 +1403,7 @@ u32 NODEWRAP_Connect(union Trapped_Args 
 			pAttrs = &attrs;
 
 	}
+
 	if (DSP_SUCCEEDED(status)) {
 		status = NODE_Connect(args->ARGS_NODE_CONNECT.hNode,
 				     args->ARGS_NODE_CONNECT.uStream,
@@ -1280,6 +1426,11 @@ u32 NODEWRAP_Create(union Trapped_Args *
 	u32 retVal;
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_Create: entered\n");
+
+	if (!validate_node_handle(args->ARGS_NODE_CREATE.hNode,
+		pr_ctxt))
+		return DSP_EHANDLE;
+
 	retVal = NODE_Create(args->ARGS_NODE_CREATE.hNode);
 
 	return retVal;
@@ -1293,6 +1444,11 @@ u32 NODEWRAP_Delete(union Trapped_Args *
 	u32 retVal;
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_Delete: entered\n");
+
+	if (!validate_node_handle(args->ARGS_NODE_DELETE.hNode,
+		pr_ctxt))
+		return DSP_EHANDLE;
+
 	retVal = NODE_Delete(args->ARGS_NODE_DELETE.hNode, pr_ctxt);
 
 	return retVal;
@@ -1306,12 +1462,21 @@ u32 NODEWRAP_FreeMsgBuf(union Trapped_Ar
 	DSP_STATUS status = DSP_SOK;
 	struct DSP_BUFFERATTR *pAttr = NULL;
 	struct DSP_BUFFERATTR attr;
+
+	if (!args->ARGS_NODE_FREEMSGBUF.pBuffer)
+		return DSP_EPOINTER;
+
+	if (!validate_node_handle(args->ARGS_NODE_FREEMSGBUF.hNode,
+		pr_ctxt))
+		return DSP_EHANDLE;
+
 	if (args->ARGS_NODE_FREEMSGBUF.pAttr) {	/* Optional argument */
 		cp_fm_usr(&attr, args->ARGS_NODE_FREEMSGBUF.pAttr, status, 1);
 		if (DSP_SUCCEEDED(status))
 			pAttr = &attr;
 
 	}
+
 	if (DSP_SUCCEEDED(status)) {
 		status = NODE_FreeMsgBuf(args->ARGS_NODE_FREEMSGBUF.hNode,
 					args->ARGS_NODE_FREEMSGBUF.pBuffer,
@@ -1331,6 +1496,10 @@ u32 NODEWRAP_GetAttr(union Trapped_Args 
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_GetAttr: entered\n");
 
+	if (!validate_node_handle(args->ARGS_NODE_GETATTR.hNode,
+		pr_ctxt))
+		return DSP_EHANDLE;
+
 	status = NODE_GetAttr(args->ARGS_NODE_GETATTR.hNode, &attr,
 			     args->ARGS_NODE_GETATTR.uAttrSize);
 	cp_to_usr(args->ARGS_NODE_GETATTR.pAttr, &attr, status, 1);
@@ -1348,6 +1517,10 @@ u32 NODEWRAP_GetMessage(union Trapped_Ar
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_GetMessage: entered\n");
 
+	if (!validate_node_handle(args->ARGS_NODE_GETMESSAGE.hNode,
+		pr_ctxt))
+		return DSP_EHANDLE;
+
 	status = NODE_GetMessage(args->ARGS_NODE_GETMESSAGE.hNode, &msg,
 				args->ARGS_NODE_GETMESSAGE.uTimeout);
 
@@ -1364,6 +1537,11 @@ u32 NODEWRAP_Pause(union Trapped_Args *a
 	u32 retVal;
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_Pause: entered\n");
+
+	if (!validate_node_handle(args->ARGS_NODE_PAUSE.hNode,
+		pr_ctxt))
+		return DSP_EHANDLE;
+
 	retVal = NODE_Pause(args->ARGS_NODE_PAUSE.hNode);
 
 	return retVal;
@@ -1379,6 +1557,10 @@ u32 NODEWRAP_PutMessage(union Trapped_Ar
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_PutMessage: entered\n");
 
+	if (!validate_node_handle(args->ARGS_NODE_PUTMESSAGE.hNode,
+		pr_ctxt))
+		status = DSP_EHANDLE;
+
 	cp_fm_usr(&msg, args->ARGS_NODE_PUTMESSAGE.pMessage, status, 1);
 
 	if (DSP_SUCCEEDED(status)) {
@@ -1404,6 +1586,15 @@ u32 NODEWRAP_RegisterNotify(union Trappe
 	notification.psName = NULL;
 	notification.handle = NULL;
 
+	if (!validate_node_handle(args->ARGS_NODE_REGISTERNOTIFY.hNode,
+		pr_ctxt))
+		return DSP_EHANDLE;
+
+	if (!args->ARGS_PROC_REGISTER_NOTIFY.uEventMask)
+		cp_fm_usr(&notification,
+			args->ARGS_PROC_REGISTER_NOTIFY.hNotification,
+			status, 1);
+
 	status = NODE_RegisterNotify(args->ARGS_NODE_REGISTERNOTIFY.hNode,
 				    args->ARGS_NODE_REGISTERNOTIFY.uEventMask,
 				    args->ARGS_NODE_REGISTERNOTIFY.uNotifyType,
@@ -1421,6 +1612,11 @@ u32 NODEWRAP_Run(union Trapped_Args *arg
 	u32 retVal;
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_Run: entered\n");
+
+	if (!validate_node_handle(args->ARGS_NODE_RUN.hNode,
+		pr_ctxt))
+		return DSP_EHANDLE;
+
 	retVal = NODE_Run(args->ARGS_NODE_RUN.hNode);
 
 	return retVal;
@@ -1436,6 +1632,10 @@ u32 NODEWRAP_Terminate(union Trapped_Arg
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_Terminate: entered\n");
 
+	if (!validate_node_handle(args->ARGS_NODE_TERMINATE.hNode,
+		pr_ctxt))
+		return DSP_EHANDLE;
+
 	status = NODE_Terminate(args->ARGS_NODE_TERMINATE.hNode, &tempstatus);
 
 	cp_to_usr(args->ARGS_NODE_TERMINATE.pStatus, &tempstatus, status, 1);
@@ -1452,10 +1652,13 @@ u32 NODEWRAP_GetUUIDProps(union Trapped_
 	DSP_STATUS status = DSP_SOK;
 	struct DSP_UUID nodeId;
 	struct DSP_NDBPROPS    *pnodeProps = NULL;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
 
 	GT_0trace(WCD_debugMask, GT_ENTER,
 		 "NODEWRAP_GetUUIDPropste: entered\n");
 
+	if (args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor)
+		return DSP_EHANDLE;
 
 	cp_fm_usr(&nodeId, args->ARGS_NODE_GETUUIDPROPS.pNodeID, status, 1);
 	if (DSP_FAILED(status))
@@ -1475,6 +1678,27 @@ func_cont:
 	return status;
 }
 
+
+bool validate_strm_handle(struct STRM_OBJECT *hStrm, void *pr_ctxt)
+{
+	bool retVal = false;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
+	struct STRM_RES_OBJECT *pStrm = pCtxt->pSTRMList;
+
+	if (mutex_lock_interruptible(&pCtxt->strm_mutex))
+		return DSP_EFAIL;
+
+	while (pStrm && !retVal) {
+		if (hStrm == pStrm->hStream)
+			retVal = true;
+		pStrm = pStrm->next;
+	}
+
+	mutex_unlock(&pCtxt->strm_mutex);
+
+	return retVal;
+}
+
 /*
  * ======== STRMWRAP_AllocateBuffer ========
  */
@@ -1484,15 +1708,28 @@ u32 STRMWRAP_AllocateBuffer(union Trappe
 	u8 **apBuffer = NULL;
 	u32 uNumBufs = args->ARGS_STRM_ALLOCATEBUFFER.uNumBufs;
 
-	DBC_Require(uNumBufs <= MAX_BUFS);
+	if (!validate_strm_handle(args->ARGS_STRM_ALLOCATEBUFFER.hStream,
+		pr_ctxt))
+		return DSP_EHANDLE;
+
+	if (uNumBufs > MAX_BUFS)
+		return DSP_EINVALIDARG;
 
 	apBuffer = MEM_Alloc((uNumBufs * sizeof(u8 *)), MEM_NONPAGED);
 
 	status = STRM_AllocateBuffer(args->ARGS_STRM_ALLOCATEBUFFER.hStream,
 				     args->ARGS_STRM_ALLOCATEBUFFER.uSize,
 				     apBuffer, uNumBufs, pr_ctxt);
-	cp_to_usr(args->ARGS_STRM_ALLOCATEBUFFER.apBuffer, apBuffer, status,
-		 uNumBufs);
+	if (DSP_SUCCEEDED(status)) {
+		cp_to_usr(args->ARGS_STRM_ALLOCATEBUFFER.apBuffer, apBuffer,
+			status, uNumBufs);
+		if (DSP_FAILED(status)) {
+			status = DSP_EPOINTER;
+			STRM_FreeBuffer(
+				args->ARGS_STRM_ALLOCATEBUFFER.hStream,
+				apBuffer, uNumBufs, pr_ctxt);
+		}
+	}
 	if (apBuffer)
 		MEM_Free(apBuffer);
 
@@ -1504,6 +1741,9 @@ u32 STRMWRAP_AllocateBuffer(union Trappe
  */
 u32 STRMWRAP_Close(union Trapped_Args *args, void *pr_ctxt)
 {
+	if (!validate_strm_handle(args->ARGS_STRM_CLOSE.hStream, pr_ctxt))
+		return DSP_EHANDLE;
+
 	return STRM_Close(args->ARGS_STRM_CLOSE.hStream, pr_ctxt);
 }
 
@@ -1516,7 +1756,11 @@ u32 STRMWRAP_FreeBuffer(union Trapped_Ar
 	u8 **apBuffer = NULL;
 	u32 uNumBufs = args->ARGS_STRM_FREEBUFFER.uNumBufs;
 
-	DBC_Require(uNumBufs <= MAX_BUFS);
+	if (!validate_strm_handle(args->ARGS_STRM_FREEBUFFER.hStream, pr_ctxt))
+		return DSP_EHANDLE;
+
+	if (uNumBufs > MAX_BUFS)
+		return DSP_EINVALIDARG;
 
 	apBuffer = MEM_Alloc((uNumBufs * sizeof(u8 *)), MEM_NONPAGED);
 
@@ -1538,8 +1782,10 @@ u32 STRMWRAP_FreeBuffer(union Trapped_Ar
 /*
  * ======== STRMWRAP_GetEventHandle ========
  */
-u32 STRMWRAP_GetEventHandle(union Trapped_Args *args, void *pr_ctxt)
+u32 __deprecated STRMWRAP_GetEventHandle(union Trapped_Args *args,
+					void *pr_ctxt)
 {
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
 	return DSP_ENOTIMPL;
 }
 
@@ -1553,6 +1799,9 @@ u32 STRMWRAP_GetInfo(union Trapped_Args 
 	struct DSP_STREAMINFO user;
 	struct DSP_STREAMINFO *temp;
 
+	if (!validate_strm_handle(args->ARGS_STRM_GETINFO.hStream, pr_ctxt))
+		return DSP_EHANDLE;
+
 	cp_fm_usr(&strmInfo, args->ARGS_STRM_GETINFO.pStreamInfo, status, 1);
 	temp = strmInfo.pUser;
 
@@ -1575,6 +1824,9 @@ u32 STRMWRAP_Idle(union Trapped_Args *ar
 {
 	u32 retVal;
 
+	if (!validate_strm_handle(args->ARGS_STRM_IDLE.hStream, pr_ctxt))
+		return DSP_EHANDLE;
+
 	retVal = STRM_Idle(args->ARGS_STRM_IDLE.hStream,
 			args->ARGS_STRM_IDLE.bFlush);
 
@@ -1587,6 +1839,13 @@ u32 STRMWRAP_Idle(union Trapped_Args *ar
 u32 STRMWRAP_Issue(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
+
+	if (!validate_strm_handle(args->ARGS_STRM_ISSUE.hStream, pr_ctxt))
+		return DSP_EHANDLE;
+
+	if (!args->ARGS_STRM_ISSUE.pBuffer)
+		return DSP_EPOINTER;
+
 	/* No need of doing cp_fm_usr for the user buffer (pBuffer)
 	as this is done in Bridge internal function WMD_CHNL_AddIOReq
 	in chnl_sm.c */
@@ -1609,12 +1868,19 @@ u32 STRMWRAP_Open(union Trapped_Args *ar
 	struct STRM_OBJECT *pStrm;
 	struct DSP_STREAMATTRIN strmAttrIn;
 
+	if (!validate_node_handle(args->ARGS_NODE_ALLOCMSGBUF.hNode,
+		pr_ctxt))
+		status = DSP_EHANDLE;
+
 	cp_fm_usr(&attr, args->ARGS_STRM_OPEN.pAttrIn, status, 1);
 
 	if (attr.pStreamAttrIn != NULL) {	/* Optional argument */
 		cp_fm_usr(&strmAttrIn, attr.pStreamAttrIn, status, 1);
-		if (DSP_SUCCEEDED(status))
+		if (DSP_SUCCEEDED(status)) {
 			attr.pStreamAttrIn = &strmAttrIn;
+			if (attr.pStreamAttrIn->lMode == STRMMODE_LDMA)
+				return DSP_ENOTIMPL;
+		}
 
 	}
 	status = STRM_Open(args->ARGS_STRM_OPEN.hNode,
@@ -1636,6 +1902,9 @@ u32 STRMWRAP_Reclaim(union Trapped_Args 
 	u32 dwArg;
 	u32 ulBufSize;
 
+	if (!validate_strm_handle(args->ARGS_STRM_RECLAIM.hStream, pr_ctxt))
+		return DSP_EHANDLE;
+
 	status = STRM_Reclaim(args->ARGS_STRM_RECLAIM.hStream, &pBufPtr,
 			     &ulBytes, &ulBufSize, &dwArg);
 	cp_to_usr(args->ARGS_STRM_RECLAIM.pBufPtr, &pBufPtr, status, 1);
@@ -1661,6 +1930,10 @@ u32 STRMWRAP_RegisterNotify(union Trappe
 	GT_0trace(WCD_debugMask, GT_ENTER,
 		 "NODEWRAP_RegisterNotify: entered\n");
 
+	if (!validate_strm_handle(args->ARGS_STRM_REGISTERNOTIFY.hStream,
+		pr_ctxt))
+		return DSP_EHANDLE;
+
 	/* Initialize the notification data structure  */
 	notification.psName = NULL;
 	notification.handle = NULL;
@@ -1684,7 +1957,8 @@ u32 STRMWRAP_Select(union Trapped_Args *
 	struct STRM_OBJECT *aStrmTab[MAX_STREAMS];
 	DSP_STATUS status = DSP_SOK;
 
-	DBC_Require(args->ARGS_STRM_SELECT.nStreams <= MAX_STREAMS);
+	if (args->ARGS_STRM_SELECT.nStreams > MAX_STREAMS)
+		return DSP_EINVALIDARG;
 
 	cp_fm_usr(aStrmTab, args->ARGS_STRM_SELECT.aStreamTab, status,
 		 args->ARGS_STRM_SELECT.nStreams);
@@ -1701,18 +1975,20 @@ u32 STRMWRAP_Select(union Trapped_Args *
 /*
  * ======== CMMWRAP_CallocBuf ========
  */
-u32 CMMWRAP_CallocBuf(union Trapped_Args *args, void *pr_ctxt)
+u32 __deprecated CMMWRAP_CallocBuf(union Trapped_Args *args, void *pr_ctxt)
 {
 	/* This operation is done in kernel */
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
 	return DSP_ENOTIMPL;
 }
 
 /*
  * ======== CMMWRAP_FreeBuf ========
  */
-u32 CMMWRAP_FreeBuf(union Trapped_Args *args, void *pr_ctxt)
+u32 __deprecated CMMWRAP_FreeBuf(union Trapped_Args *args, void *pr_ctxt)
 {
 	/* This operation is done in kernel */
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
 	return DSP_ENOTIMPL;
 }
 
@@ -1723,6 +1999,11 @@ u32 CMMWRAP_GetHandle(union Trapped_Args
 {
 	DSP_STATUS status = DSP_SOK;
 	struct CMM_OBJECT *hCmmMgr;
+	struct PROCESS_CONTEXT *pCtxt = pr_ctxt;
+
+	if (args->ARGS_PROC_CTRL.hProcessor &&
+		args->ARGS_PROC_CTRL.hProcessor != pCtxt->hProcessor)
+		return DSP_EHANDLE;
 
 	status = CMM_GetHandle(args->ARGS_CMM_GETHANDLE.hProcessor, &hCmmMgr);
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/dbdcd.c kernel-power-2.6.28/drivers/dsp/bridge/rmgr/dbdcd.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/dbdcd.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/rmgr/dbdcd.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,15 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * This file contains the implementation of the DSP/BIOS Bridge
+ * Configuration Database (DCD).
+ *
+ * Notes:
+ *   The fxn DCD_GetObjects can apply a callback fxn to each DCD object
+ *   that is located in a specified COFF file.  At the moment,
+ *   DCD_AutoRegister, DCD_AutoUnregister, and NLDR module all use
+ *   DCD_GetObjects.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,53 +23,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dbdcd.c ========
- *  Description:
- *      This file contains the implementation of the DSP/BIOS Bridge
- *      Configuration Database (DCD).
- *
- *  Notes:
- *      The fxn DCD_GetObjects can apply a callback fxn to each DCD object
- *      that is located in a specified COFF file.  At the moment,
- *      DCD_AutoRegister, DCD_AutoUnregister, and NLDR module all use
- *      DCD_GetObjects.
- *
- *! Revision History
- *! ================
- *! 03-Dec-2003 map Changed DCD_OBJTYPE to DSP_DCDOBJTYPE
- *! 17-Dec-2002 map Modified DCD_GetDepLibs, DCD_GetNumDepLibs, GetDepLibInfo
- *!                 to include phase information
- *! 02-Dec-2002 map Modified DCD_GetLibraryName for phases in different
- *!                 libraries
- *! 26-Feb-2003 kc  Updated DCD_AutoUnregister and DCD_GetObjects to simplify
- *!                 DCD implementation.
- *! 17-Jul-2002 jeh Call COD_Open() instead of COD_OpenBase(), call COD_Close()
- *! 11-Jul-2002 jeh Added DCD_GetDepLibs(), DCD_GetNumDepLibs().
- *! 18-Feb-2003 vp  Code review updates
- *! 18-Oct-2002 vp  Ported to Linux platform
- *! 15-Mar-2002 jeh Read dynamic loading memory requirements into node object
- *!                 data. Added DCD_GetLibraryName().
- *! 13-Feb-2002 jeh Get system stack size in GetAttrsFromBuf().
- *! 01-Aug-2001 ag: Added check for PROC "extended" attributes used for
- *!                    DSP-MMU setup. These are private attributes.
- *! 18-Apr-2001 jeh Use COD_OpenBase instead of COD_LoadBase.
- *! 03-Apr-2001 sg: Changed error names to DSP_EDCD* format.
- *! 11-Jan-2001 jeh Changes to DCD_GetObjectDef to match node.cdb, proc.cdb.
- *! 12-Dec-2000 kc: Added DCD_AutoUnregister. MSGNODE, DAISNODE added in
- *!                 GetAttrsFromBuf
- *! 22-Nov-2000 kc: Replaced sprintf() calls with strncat.
- *! 09-Nov-2000 kc: Optimized DCD module.
- *! 30-Oct-2000 kc: Added DCD_AutoRegister function; changed local var. names.
- *! 29-Sep-2000 kc: Added code review changes (src/reviews/dcd_reviews.txt).
- *! 06-Sep-2000 jeh Get message segid, message notification type. Added Atoi()
- *!                 to replace atoi(), until cdb generation can output in
- *!                 decimal format.
- *! 26-Jul-2000 kc: Created.
- *!
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -73,7 +35,6 @@
 #include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/reg.h>
 
@@ -89,12 +50,12 @@
 /*  ----------------------------------- Global defines. */
 #define SIGNATURE       0x5f444344	/* "DCD_" (in reverse). */
 
-#define IsValidHandle(h)    (((h) != NULL) && (h->dwSignature == SIGNATURE))
+#define IsValidHandle(h)	(((h) != NULL) && (h->dwSignature == SIGNATURE))
 
 #define MAX_INT2CHAR_LENGTH     16   /* Maximum int2char len of 32 bit int. */
 
 /* Name of section containing dependent libraries */
-#define DEPLIBSECT              ".dspbridge_deplibs"
+#define DEPLIBSECT		".dspbridge_deplibs"
 
 /* DCD specific structures. */
 struct DCD_MANAGER {
@@ -108,17 +69,13 @@ static u32 cEnumRefs;
 
 extern struct GT_Mask curTrace;
 
-/* helper function prototypes. */
+/* Helper function prototypes. */
 static s32 Atoi(char *pszBuf);
-
 static DSP_STATUS GetAttrsFromBuf(char *pszBuf, u32 ulBufSize,
 				  enum DSP_DCDOBJTYPE objType,
 				  struct DCD_GENERICOBJ *pGenObj);
-
 static void CompressBuf(char *pszBuf, u32 ulBufSize, s32 cCharSize);
-
 static char DspChar2GppChar(char *pWord, s32 cDspCharSize);
-
 static DSP_STATUS GetDepLibInfo(IN struct DCD_MANAGER *hDcdMgr,
 				IN struct DSP_UUID *pUuid,
 				IN OUT u16 *pNumLibs,
@@ -132,9 +89,8 @@ static DSP_STATUS GetDepLibInfo(IN struc
  *  Purpose:
  *      Parses the supplied image and resigsters with DCD.
  */
-
 DSP_STATUS DCD_AutoRegister(IN struct DCD_MANAGER *hDcdMgr,
-			    IN char *pszCoffPath)
+				IN char *pszCoffPath)
 {
 	DSP_STATUS status = DSP_SOK;
 
@@ -162,7 +118,7 @@ DSP_STATUS DCD_AutoRegister(IN struct DC
  *      Parses the supplied DSP image and unresiters from DCD.
  */
 DSP_STATUS DCD_AutoUnregister(IN struct DCD_MANAGER *hDcdMgr,
-			     IN char *pszCoffPath)
+				IN char *pszCoffPath)
 {
 	DSP_STATUS status = DSP_SOK;
 
@@ -173,8 +129,7 @@ DSP_STATUS DCD_AutoUnregister(IN struct 
 
 	if (IsValidHandle(hDcdMgr)) {
 		status = DCD_GetObjects(hDcdMgr, pszCoffPath,
-				       (DCD_REGISTERFXN)DCD_RegisterObject,
-				       NULL);
+				(DCD_REGISTERFXN)DCD_RegisterObject, NULL);
 	} else {
 		status = DSP_EHANDLE;
 		GT_0trace(curTrace, GT_6CLASS,
@@ -191,9 +146,9 @@ DSP_STATUS DCD_AutoUnregister(IN struct 
  *      Creates DCD manager.
  */
 DSP_STATUS DCD_CreateManager(IN char *pszZlDllName,
-			    OUT struct DCD_MANAGER **phDcdMgr)
+				OUT struct DCD_MANAGER **phDcdMgr)
 {
-	struct COD_MANAGER *hCodMgr;	/* COD manager handle */
+	struct COD_MANAGER *hCodMgr;		/* COD manager handle */
 	struct DCD_MANAGER *pDcdMgr = NULL;	/* DCD Manager pointer */
 	DSP_STATUS status = DSP_SOK;
 
@@ -204,43 +159,43 @@ DSP_STATUS DCD_CreateManager(IN char *ps
 		 phDcdMgr);
 
 	status = COD_Create(&hCodMgr, pszZlDllName, NULL);
-	if (DSP_SUCCEEDED(status)) {
-
-		/* Create a DCD object. */
-		MEM_AllocObject(pDcdMgr, struct DCD_MANAGER, SIGNATURE);
-		if (pDcdMgr != NULL) {
-
-			/* Fill out the object. */
-			pDcdMgr->hCodMgr = hCodMgr;
-
-			/* Return handle to this DCD interface. */
-			*phDcdMgr = pDcdMgr;
-
-			GT_2trace(curTrace, GT_5CLASS,
-				 "DCD_CreateManager: pDcdMgr 0x%x, "
-				 " hCodMgr 0x%x", pDcdMgr, hCodMgr);
-		} else {
-			status = DSP_EMEMORY;
 
-			/*
-			 * If allocation of DcdManager object failed, delete the
-			 * COD manager.
-			 */
-			COD_Delete(hCodMgr);
+	if (DSP_FAILED(status)) {
+		GT_0trace(curTrace, GT_6CLASS,
+			 "DCD_CreateManager: COD_Create failed\n");
+		goto func_end;
+	}
 
-			GT_0trace(curTrace, GT_6CLASS,
-				 "DCD_CreateManager: MEM_AllocObject failed\n");
-		}
+	/* Create a DCD object. */
+	MEM_AllocObject(pDcdMgr, struct DCD_MANAGER, SIGNATURE);
+	if (pDcdMgr != NULL) {
+		/* Fill out the object. */
+		pDcdMgr->hCodMgr = hCodMgr;
+
+		/* Return handle to this DCD interface. */
+		*phDcdMgr = pDcdMgr;
+
+		GT_2trace(curTrace, GT_5CLASS,
+			 "DCD_CreateManager: pDcdMgr 0x%x, "
+			 " hCodMgr 0x%x", pDcdMgr, hCodMgr);
 	} else {
-		status = DSP_EFAIL;
+		status = DSP_EMEMORY;
+
+		/*
+		 * If allocation of DcdManager object failed, delete the
+		 * COD manager.
+		 */
+		COD_Delete(hCodMgr);
+
 		GT_0trace(curTrace, GT_6CLASS,
-			 "DCD_CreateManager: COD_Create failed\n");
+			 "DCD_CreateManager: MEM_AllocObject failed\n");
 	}
 
 	DBC_Ensure((DSP_SUCCEEDED(status)) || ((hCodMgr == NULL) &&
-		  (status == DSP_EFAIL)) || ((pDcdMgr == NULL) &&
-		  (status == DSP_EMEMORY)));
+			(status == DSP_EFAIL)) || ((pDcdMgr == NULL) &&
+			(status == DSP_EMEMORY)));
 
+func_end:
 	return status;
 }
 
@@ -260,7 +215,6 @@ DSP_STATUS DCD_DestroyManager(IN struct 
 		 hDcdMgr);
 
 	if (IsValidHandle(hDcdMgr)) {
-
 		/* Delete the COD manager. */
 		COD_Delete(pDcdMgr->hCodMgr);
 
@@ -318,15 +272,15 @@ DSP_STATUS DCD_EnumerateObject(IN s32 cI
 		 * Pre-determine final key length. It's length of DCD_REGKEY +
 		 *  "_\0" + length of szObjType string + terminating NULL.
 		 */
-               dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
+		dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
 		DBC_Assert(dwKeyLen < REG_MAXREGPATHLENGTH);
 
 		/* Create proper REG key; concatenate DCD_REGKEY with
 		 * objType. */
-               strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
-               if ((strlen(szRegKey) + strlen("_\0")) <
+		strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+		if ((strlen(szRegKey) + strlen("_\0")) <
 		   REG_MAXREGPATHLENGTH) {
-                       strncat(szRegKey, "_\0", 2);
+			strncat(szRegKey, "_\0", 2);
 		} else {
 			status = DSP_EFAIL;
 		}
@@ -340,19 +294,18 @@ DSP_STATUS DCD_EnumerateObject(IN s32 cI
 			status = DSP_EFAIL;
 		} else {
 			status = DSP_SOK;
-                       if ((strlen(szRegKey) + strlen(szObjType)) <
+			if ((strlen(szRegKey) + strlen(szObjType)) <
 			   REG_MAXREGPATHLENGTH) {
-                               strncat(szRegKey, szObjType,
-                                          strlen(szObjType) + 1);
+				strncat(szRegKey, szObjType,
+					strlen(szObjType) + 1);
 			} else {
 				status = DSP_EFAIL;
 			}
 		}
 
 		if (DSP_SUCCEEDED(status)) {
-			status = REG_EnumValue(NULL, cIndex, szRegKey, szValue,
-					      &dwValueSize, szData,
-					      &dwDataSize);
+			status = REG_EnumValue(cIndex, szRegKey, szValue,
+					&dwValueSize, szData, &dwDataSize);
 		}
 
 		if (DSP_SUCCEEDED(status)) {
@@ -397,9 +350,7 @@ void DCD_Exit(void)
 
 	cRefs--;
 	if (cRefs == 0) {
-		REG_Exit();
 		COD_Exit();
-		MEM_Exit();
 	}
 
 	DBC_Ensure(cRefs >= 0);
@@ -449,7 +400,7 @@ DSP_STATUS DCD_GetNumDepLibs(IN struct D
 		 hDcdMgr);
 
 	status = GetDepLibInfo(hDcdMgr, pUuid, pNumLibs, pNumPersLibs,
-			      NULL, NULL, phase);
+				NULL, NULL, phase);
 
 	return status;
 }
@@ -461,9 +412,9 @@ DSP_STATUS DCD_GetNumDepLibs(IN struct D
  *      object type.
  */
 DSP_STATUS DCD_GetObjectDef(IN struct DCD_MANAGER *hDcdMgr,
-			   IN struct DSP_UUID *pObjUuid,
-			   IN enum DSP_DCDOBJTYPE objType,
-			   OUT struct DCD_GENERICOBJ *pObjDef)
+			IN struct DSP_UUID *pObjUuid,
+			IN enum DSP_DCDOBJTYPE objType,
+			OUT struct DCD_GENERICOBJ *pObjDef)
 {
 	struct DCD_MANAGER *pDcdMgr = hDcdMgr;	/* pointer to DCD manager */
 	struct COD_LIBRARYOBJ *lib = NULL;
@@ -488,8 +439,10 @@ DSP_STATUS DCD_GetObjectDef(IN struct DC
 		 " 0x%x, objType 0x%x, pObjDef 0x%x\n", hDcdMgr, pObjUuid,
 		 objType, pObjDef);
 	szUuid = (char *)MEM_Calloc(MAXUUIDLEN, MEM_PAGED);
-	if (!szUuid)
-		return status = DSP_EMEMORY;
+	if (!szUuid) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
 
 	if (!IsValidHandle(hDcdMgr)) {
 		status = DSP_EHANDLE;
@@ -497,15 +450,17 @@ DSP_STATUS DCD_GetObjectDef(IN struct DC
 			 "DCD manager handle.\n");
 		goto func_end;
 	}
-	 /* Pre-determine final key length. It's length of DCD_REGKEY +
+
+	/* Pre-determine final key length. It's length of DCD_REGKEY +
 	 *  "_\0" + length of szObjType string + terminating NULL */
-       dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
+	dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
 	DBC_Assert(dwKeyLen < REG_MAXREGPATHLENGTH);
+
 	/* Create proper REG key; concatenate DCD_REGKEY with objType. */
-       strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+	strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
 
-       if ((strlen(szRegKey) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
-               strncat(szRegKey, "_\0", 2);
+	if ((strlen(szRegKey) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
+		strncat(szRegKey, "_\0", 2);
 	else
 		status = DSP_EFAIL;
 
@@ -515,33 +470,34 @@ DSP_STATUS DCD_GetObjectDef(IN struct DC
 	} else {
 		status = DSP_SOK;
 
-               if ((strlen(szRegKey) + strlen(szObjType)) <
+		if ((strlen(szRegKey) + strlen(szObjType)) <
 		   REG_MAXREGPATHLENGTH) {
-                       strncat(szRegKey, szObjType, strlen(szObjType) + 1);
+			strncat(szRegKey, szObjType, strlen(szObjType) + 1);
 		} else {
 			status = DSP_EFAIL;
 		}
+
 		/* Create UUID value to set in registry. */
 		UUID_UuidToString(pObjUuid, szUuid, MAXUUIDLEN);
 
-               if ((strlen(szRegKey) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
-                       strncat(szRegKey, szUuid, MAXUUIDLEN);
-               else
+		if ((strlen(szRegKey) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
+			strncat(szRegKey, szUuid, MAXUUIDLEN);
+		else
 			status = DSP_EFAIL;
 
 		/* Retrieve paths from the registry based on struct DSP_UUID */
 		dwBufSize = REG_MAXREGPATHLENGTH;
 	}
-	if (DSP_SUCCEEDED(status)) {
-		status = REG_GetValue(NULL, szRegKey, szRegKey, (u8 *)szRegData,
-				     &dwBufSize);
-	}
+	if (DSP_SUCCEEDED(status))
+		status = REG_GetValue(szRegKey, (u8 *)szRegData, &dwBufSize);
+
 	if (DSP_FAILED(status)) {
 		status = DSP_EUUID;
 		GT_0trace(curTrace, GT_6CLASS, "DCD_GetObjectDef: "
 			 "REG_GetValue() failed\n");
 		goto func_end;
 	}
+
 	/* Open COFF file. */
 	status = COD_Open(pDcdMgr->hCodMgr, szRegData, COD_NOLOAD, &lib);
 	if (DSP_FAILED(status)) {
@@ -550,13 +506,16 @@ DSP_STATUS DCD_GetObjectDef(IN struct DC
 			 "COD_OpenBase() failed\n");
 		goto func_end;
 	}
+
 	/* Ensure szUuid + 1 is not greater than sizeof szSectName. */
-       DBC_Assert((strlen(szUuid) + 1) < sizeof(szSectName));
+	DBC_Assert((strlen(szUuid) + 1) < sizeof(szSectName));
+
 	/* Create section name based on node UUID. A period is
 	 * pre-pended to the UUID string to form the section name.
 	 * I.e. ".24BC8D90_BB45_11d4_B756_006008BDB66F" */
-       strncpy(szSectName, ".", 2);
-       strncat(szSectName, szUuid, strlen(szUuid));
+	strncpy(szSectName, ".", 2);
+	strncat(szSectName, szUuid, strlen(szUuid));
+
 	/* Get section information. */
 	status = COD_GetSection(lib, szSectName, &ulAddr, &ulLen);
 	if (DSP_FAILED(status)) {
@@ -565,10 +524,11 @@ DSP_STATUS DCD_GetObjectDef(IN struct DC
 			 " COD_GetSection() failed\n");
 		goto func_end;
 	}
+
 	/* Allocate zeroed buffer. */
 	pszCoffBuf = MEM_Calloc(ulLen + 4, MEM_PAGED);
 #ifdef _DB_TIOMAP
-       if (strstr(szRegData, "iva") == NULL) {
+	if (strstr(szRegData, "iva") == NULL) {
 		/* Locate section by objectID and read its content. */
 		status = COD_ReadSection(lib, szSectName, pszCoffBuf, ulLen);
 	} else {
@@ -581,13 +541,14 @@ DSP_STATUS DCD_GetObjectDef(IN struct DC
 #endif
 	if (DSP_SUCCEEDED(status)) {
 		/* Compres DSP buffer to conform to PC format. */
-               if (strstr(szRegData, "iva") == NULL) {
+		if (strstr(szRegData, "iva") == NULL) {
 			CompressBuf(pszCoffBuf, ulLen, DSPWORDSIZE);
 		} else {
 			CompressBuf(pszCoffBuf, ulLen, 1);
 			GT_0trace(curTrace, GT_4CLASS, "Compressing IVA "
 				 "COFF buffer by 1 for IVA !!\n");
 		}
+
 		/* Parse the content of the COFF buffer. */
 		status = GetAttrsFromBuf(pszCoffBuf, ulLen, objType, pObjDef);
 		if (DSP_FAILED(status)) {
@@ -600,6 +561,7 @@ DSP_STATUS DCD_GetObjectDef(IN struct DC
 		GT_0trace(curTrace, GT_6CLASS, "DCD_GetObjectDef: "
 			 "COD_ReadSection() failed\n");
 	}
+
 	/* Free the previously allocated dynamic buffer. */
 	MEM_Free(pszCoffBuf);
 func_end:
@@ -608,6 +570,7 @@ func_end:
 
 	if (szUuid)
 		MEM_Free(szUuid);
+
 	return status;
 }
 
@@ -638,6 +601,7 @@ DSP_STATUS DCD_GetObjects(IN struct DCD_
 			 "DCD_GetObjects: invalid DCD manager handle.\n");
 		goto func_end;
 	}
+
 	/* Open DSP coff file, don't load symbols. */
 	status = COD_Open(pDcdMgr->hCodMgr, pszCoffPath, COD_NOLOAD, &lib);
 	if (DSP_FAILED(status)) {
@@ -646,6 +610,7 @@ DSP_STATUS DCD_GetObjects(IN struct DCD_
 			 "DCD_AutoRegister: COD_Open() failed\n");
 		goto func_cont;
 	}
+
 	/* Get DCD_RESIGER_SECTION section information. */
 	status = COD_GetSection(lib, DCD_REGISTER_SECTION, &ulAddr, &ulLen);
 	if (DSP_FAILED(status) ||  !(ulLen > 0)) {
@@ -655,6 +620,7 @@ DSP_STATUS DCD_GetObjects(IN struct DCD_
 			 "- no auto register section\n");
 		goto func_cont;
 	}
+
 	/* Allocate zeroed buffer. */
 	pszCoffBuf = MEM_Calloc(ulLen + 4, MEM_PAGED);
 #ifdef _DB_TIOMAP
@@ -681,15 +647,19 @@ DSP_STATUS DCD_GetObjects(IN struct DCD_
 			GT_0trace(curTrace, GT_4CLASS, "Compress COFF buffer "
 				 "with 1 word for IVA !!\n");
 		}
+
 		/* Read from buffer and register object in buffer. */
 		pszCur = pszCoffBuf;
 		while ((pToken = strsep(&pszCur, seps)) && *pToken != '\0') {
 			/*  Retrieve UUID string. */
 			UUID_UuidFromString(pToken, &dspUuid);
+
 			/*  Retrieve object type */
 			pToken = strsep(&pszCur, seps);
+
 			/*  Retrieve object type */
 			cObjectType = Atoi(pToken);
+
 			/*
 			 *  Apply registerFxn to the found DCD object.
 			 *  Possible actions include:
@@ -718,6 +688,7 @@ DSP_STATUS DCD_GetObjects(IN struct DCD_
 		GT_0trace(curTrace, GT_6CLASS, "DCD_GetObjects: "
 			 "COD_ReadSection() failed\n");
 	}
+
 	/* Free the previously allocated dynamic buffer. */
 	MEM_Free(pszCoffBuf);
 func_cont:
@@ -735,9 +706,9 @@ func_end:
  *
  */
 DSP_STATUS DCD_GetLibraryName(IN struct DCD_MANAGER *hDcdMgr,
-			     IN struct DSP_UUID *pUuid,
-			     IN OUT char *pstrLibName, IN OUT u32 *pdwSize,
-			     enum NLDR_PHASE phase, OUT bool *fPhaseSplit)
+			IN struct DSP_UUID *pUuid,
+			IN OUT char *pstrLibName, IN OUT u32 *pdwSize,
+			enum NLDR_PHASE phase, OUT bool *fPhaseSplit)
 {
 	char szRegKey[REG_MAXREGPATHLENGTH];
 	char szUuid[MAXUUIDLEN];
@@ -754,16 +725,18 @@ DSP_STATUS DCD_GetLibraryName(IN struct 
 		 "DCD_GetLibraryName: hDcdMgr 0x%x, pUuid 0x%x, "
 		 " pstrLibName 0x%x, pdwSize 0x%x\n", hDcdMgr, pUuid,
 		 pstrLibName, pdwSize);
+
 	/*
 	 *  Pre-determine final key length. It's length of DCD_REGKEY +
 	 *  "_\0" + length of szObjType string + terminating NULL.
 	 */
-       dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
+	dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
 	DBC_Assert(dwKeyLen < REG_MAXREGPATHLENGTH);
+
 	/* Create proper REG key; concatenate DCD_REGKEY with objType. */
-       strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
-       if ((strlen(szRegKey) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
-               strncat(szRegKey, "_\0", 2);
+	strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+	if ((strlen(szRegKey) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
+		strncat(szRegKey, "_\0", 2);
 	else
 		status = DSP_EFAIL;
 
@@ -785,60 +758,56 @@ DSP_STATUS DCD_GetLibraryName(IN struct 
 		sprintf(szObjType, "%d", DSP_DCDLIBRARYTYPE);
 		break;
 	default:
-		status = -1;
+		status = DSP_EINVALIDARG;
 		DBC_Assert(false);
 	}
-	if (status == -1) {
-		status = DSP_EFAIL;
-	} else {
-		status = DSP_SOK;
-               if ((strlen(szRegKey) + strlen(szObjType))
-		   < REG_MAXREGPATHLENGTH) {
-                       strncat(szRegKey, szObjType, strlen(szObjType) + 1);
+	if (DSP_SUCCEEDED(status)) {
+		if ((strlen(szRegKey) + strlen(szObjType)) <
+		   REG_MAXREGPATHLENGTH) {
+			strncat(szRegKey, szObjType, strlen(szObjType) + 1);
 		} else {
 			status = DSP_EFAIL;
 		}
 		/* Create UUID value to find match in registry. */
 		UUID_UuidToString(pUuid, szUuid, MAXUUIDLEN);
-               if ((strlen(szRegKey) + MAXUUIDLEN) <
+		if ((strlen(szRegKey) + MAXUUIDLEN) <
 		   REG_MAXREGPATHLENGTH) {
-                       strncat(szRegKey, szUuid, MAXUUIDLEN);
+			strncat(szRegKey, szUuid, MAXUUIDLEN);
 		} else {
 			status = DSP_EFAIL;
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Retrieve path from the registry based on DSP_UUID */
-		status = REG_GetValue(NULL, szRegKey, szRegKey,
-					(u8 *)pstrLibName, pdwSize);
+		status = REG_GetValue(szRegKey,	(u8 *)pstrLibName, pdwSize);
 	}
+
 	/* If can't find, phases might be registered as generic LIBRARYTYPE */
 	if (DSP_FAILED(status) && phase != NLDR_NOPHASE) {
 		if (fPhaseSplit)
 			*fPhaseSplit = false;
 
-               strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
-               if ((strlen(szRegKey) + strlen("_\0")) <
+		strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+		if ((strlen(szRegKey) + strlen("_\0")) <
 		   REG_MAXREGPATHLENGTH) {
-                       strncat(szRegKey, "_\0", 2);
+			strncat(szRegKey, "_\0", 2);
 		} else {
 			status = DSP_EFAIL;
 		}
 		sprintf(szObjType, "%d", DSP_DCDLIBRARYTYPE);
-               if ((strlen(szRegKey) + strlen(szObjType))
+		if ((strlen(szRegKey) + strlen(szObjType))
 		   < REG_MAXREGPATHLENGTH) {
-                       strncat(szRegKey, szObjType, strlen(szObjType) + 1);
+			strncat(szRegKey, szObjType, strlen(szObjType) + 1);
 		} else {
 			status = DSP_EFAIL;
 		}
 		UUID_UuidToString(pUuid, szUuid, MAXUUIDLEN);
-               if ((strlen(szRegKey) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
-                       strncat(szRegKey, szUuid, MAXUUIDLEN);
-               else
+		if ((strlen(szRegKey) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
+			strncat(szRegKey, szUuid, MAXUUIDLEN);
+		else
 			status = DSP_EFAIL;
 
-		status = REG_GetValue(NULL, szRegKey, szRegKey,
-					(u8 *)pstrLibName, pdwSize);
+		status = REG_GetValue(szRegKey, (u8 *)pstrLibName, pdwSize);
 	}
 
 	return status;
@@ -851,8 +820,6 @@ DSP_STATUS DCD_GetLibraryName(IN struct 
  */
 bool DCD_Init(void)
 {
-	bool fInitMEM;
-	bool fInitREG;
 	bool fInitCOD;
 	bool fInit = true;
 
@@ -862,24 +829,15 @@ bool DCD_Init(void)
 		 cRefs);
 
 	if (cRefs == 0) {
-
 		/* Initialize required modules. */
-		fInitMEM = MEM_Init();
 		fInitCOD = COD_Init();
-		fInitREG = REG_Init();
-		if (!fInitMEM || !fInitCOD || !fInitREG) {
+
+		if (!fInitCOD) {
 			fInit = false;
 			GT_0trace(curTrace, GT_6CLASS, "DCD_Init failed\n");
 			/* Exit initialized modules. */
-			if (fInitMEM)
-				MEM_Exit();
-
 			if (fInitCOD)
 				COD_Exit();
-
-			if (fInitREG)
-				REG_Exit();
-
 		}
 	}
 
@@ -902,92 +860,89 @@ bool DCD_Init(void)
  *      If pszPathName == NULL, unregister the specified DCD object.
  */
 DSP_STATUS DCD_RegisterObject(IN struct DSP_UUID *pUuid,
-			     IN enum DSP_DCDOBJTYPE objType,
-			     IN char *pszPathName)
+			IN enum DSP_DCDOBJTYPE objType,
+			IN char *pszPathName)
 {
 	DSP_STATUS status = DSP_SOK;
 	char szRegKey[REG_MAXREGPATHLENGTH];
 	char szUuid[MAXUUIDLEN + 1];
 	u32 dwPathSize = 0;
-	u32 dwKeyLen;		/* Len of REG key. */
+	u32 dwKeyLen;				/* Len of REG key. */
 	char szObjType[MAX_INT2CHAR_LENGTH];	/* str. rep. of objType. */
 
 	DBC_Require(cRefs > 0);
 	DBC_Require(pUuid != NULL);
 	DBC_Require((objType == DSP_DCDNODETYPE) ||
-		   (objType == DSP_DCDPROCESSORTYPE) ||
-		   (objType == DSP_DCDLIBRARYTYPE) ||
-		   (objType == DSP_DCDCREATELIBTYPE) ||
-		   (objType == DSP_DCDEXECUTELIBTYPE) ||
-		   (objType == DSP_DCDDELETELIBTYPE));
+			(objType == DSP_DCDPROCESSORTYPE) ||
+			(objType == DSP_DCDLIBRARYTYPE) ||
+			(objType == DSP_DCDCREATELIBTYPE) ||
+			(objType == DSP_DCDEXECUTELIBTYPE) ||
+			(objType == DSP_DCDDELETELIBTYPE));
 
 	GT_3trace(curTrace, GT_ENTER, "DCD_RegisterObject: object UUID 0x%x, "
 		 "objType %d, szPathName %s\n", pUuid, objType, pszPathName);
+
 	/*
 	 * Pre-determine final key length. It's length of DCD_REGKEY +
 	 *  "_\0" + length of szObjType string + terminating NULL.
 	 */
-       dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
+	dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
 	DBC_Assert(dwKeyLen < REG_MAXREGPATHLENGTH);
+
 	/* Create proper REG key; concatenate DCD_REGKEY with objType. */
-       strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
-       if ((strlen(szRegKey) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
-               strncat(szRegKey, "_\0", 2);
-	else
+	strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+	if ((strlen(szRegKey) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
+		strncat(szRegKey, "_\0", 2);
+	else {
 		status = DSP_EFAIL;
+		goto func_end;
+	}
 
 	status = snprintf(szObjType, MAX_INT2CHAR_LENGTH, "%d", objType);
 	if (status == -1) {
 		status = DSP_EFAIL;
 	} else {
 		status = DSP_SOK;
-               if ((strlen(szRegKey) + strlen(szObjType)) <
+		if ((strlen(szRegKey) + strlen(szObjType)) <
 		   REG_MAXREGPATHLENGTH) {
-                       strncat(szRegKey, szObjType, strlen(szObjType) + 1);
-		} else {
+			strncat(szRegKey, szObjType, strlen(szObjType) + 1);
+		} else
 			status = DSP_EFAIL;
-		}
+
 		/* Create UUID value to set in registry. */
 		UUID_UuidToString(pUuid, szUuid, MAXUUIDLEN);
-               if ((strlen(szRegKey) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
-                       strncat(szRegKey, szUuid, MAXUUIDLEN);
-               else
+		if ((strlen(szRegKey) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
+			strncat(szRegKey, szUuid, MAXUUIDLEN);
+		else
 			status = DSP_EFAIL;
-
 	}
 
-	if (DSP_SUCCEEDED(status)) {
-		/*
-		 * If pszPathName != NULL, perform registration, otherwise,
-		 * perform unregistration.
-		 */
-		if (pszPathName) {
-			/* Add new reg value (UUID+objType) with COFF path
-			 * info. */
-                       dwPathSize = strlen(pszPathName) + 1;
-			status = REG_SetValue(NULL, szRegKey, szRegKey, REG_SZ,
-					     (u8 *)pszPathName, dwPathSize);
-			GT_3trace(curTrace, GT_6CLASS,
-				 "REG_SetValue  REG_SZ=%d, "
-				 "(u8 *)pszPathName=%s, dwPathSize=%d\n",
-				 REG_SZ, pszPathName, dwPathSize);
-			if (DSP_FAILED(status)) {
-				status = DSP_EFAIL;
-				GT_0trace(curTrace, GT_6CLASS,
-				  "DCD_RegisterObject: REG_SetValue failed!\n");
-			}
-		} else {
-			/* Deregister an existing object. */
-			status = REG_DeleteValue(NULL, szRegKey, szRegKey);
-			if (DSP_FAILED(status)) {
-				status = DSP_EFAIL;
-				GT_0trace(curTrace, GT_6CLASS,
-					"DCD_UnregisterObject: "
-					"REG_DeleteValue failed!\n");
-			}
-		}
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/*
+	 * If pszPathName != NULL, perform registration, otherwise,
+	 * perform unregistration.
+	 */
+	if (pszPathName) {
+		/* Add new reg value (UUID+objType) with COFF path info */
+		dwPathSize = strlen(pszPathName) + 1;
+		status = REG_SetValue(szRegKey, (u8 *)pszPathName, dwPathSize);
+		GT_2trace(curTrace, GT_6CLASS, "REG_SetValue  "
+			  "(u8 *)pszPathName=%s, dwPathSize=%d\n",
+			  pszPathName, dwPathSize);
+		if (DSP_FAILED(status))
+			GT_0trace(curTrace, GT_6CLASS,
+				"DCD_RegisterObject: REG_SetValue failed!\n");
+	} else {
+		/* Deregister an existing object */
+		status = REG_DeleteValue(szRegKey);
+		if (DSP_FAILED(status))
+			GT_0trace(curTrace, GT_6CLASS, "DCD_UnregisterObject: "
+				"REG_DeleteValue failed!\n");
 	}
 
+
 	if (DSP_SUCCEEDED(status)) {
 		/*
 		 *  Because the node database has been updated through a
@@ -996,10 +951,9 @@ DSP_STATUS DCD_RegisterObject(IN struct 
 		 *  current enumerations to reflect this update in the node
 		 *  database.
 		 */
-
 		cEnumRefs = 0;
 	}
-
+func_end:
 	return status;
 }
 
@@ -1086,7 +1040,6 @@ static s32 Atoi(char *pszBuf)
 				c = c - 'a' + 10;
 			else
 				c -= '0';
-
 		}
 		result += c;
 		++pch;
@@ -1122,7 +1075,6 @@ static DSP_STATUS GetAttrsFromBuf(char *
 		    || (objType == DSP_DCDPROCESSORTYPE));
 	DBC_Require(pGenObj != NULL);
 
-
 	switch (objType) {
 	case DSP_DCDNODETYPE:
 		/*
@@ -1143,12 +1095,12 @@ static DSP_STATUS GetAttrsFromBuf(char *
 		token = strsep(&pszCur, seps);
 
 		/* acName */
-               DBC_Require(token);
+		DBC_Require(token);
 		cLen = strlen(token);
 		if (cLen > DSP_MAXNAMELEN - 1)
 			cLen = DSP_MAXNAMELEN - 1;
 
-               strncpy(pGenObj->objData.nodeObj.ndbProps.acName,
+		strncpy(pGenObj->objData.nodeObj.ndbProps.acName,
 			   token, cLen);
 		pGenObj->objData.nodeObj.ndbProps.acName[cLen] = '\0';
 		token = strsep(&pszCur, seps);
@@ -1226,31 +1178,43 @@ static DSP_STATUS GetAttrsFromBuf(char *
 			Atoi(token);
 		token = strsep(&pszCur, seps);
 
-		/* char * pstrCreatePhaseFxn */
-               DBC_Require(token);
+		/* char *pstrCreatePhaseFxn */
+		DBC_Require(token);
 		cLen = strlen(token);
 		pGenObj->objData.nodeObj.pstrCreatePhaseFxn =
 			MEM_Calloc(cLen + 1, MEM_PAGED);
+		if (!pGenObj->objData.nodeObj.pstrCreatePhaseFxn) {
+			status = DSP_EMEMORY;
+			break;
+		}
 		strncpy(pGenObj->objData.nodeObj.pstrCreatePhaseFxn,
 			token, cLen);
 		pGenObj->objData.nodeObj.pstrCreatePhaseFxn[cLen] = '\0';
 		token = strsep(&pszCur, seps);
 
-		/* char * pstrExecutePhaseFxn */
-               DBC_Require(token);
+		/* char *pstrExecutePhaseFxn */
+		DBC_Require(token);
 		cLen = strlen(token);
 		pGenObj->objData.nodeObj.pstrExecutePhaseFxn =
 			 MEM_Calloc(cLen + 1, MEM_PAGED);
+		if (!pGenObj->objData.nodeObj.pstrExecutePhaseFxn) {
+			status = DSP_EMEMORY;
+			break;
+		}
 		strncpy(pGenObj->objData.nodeObj.pstrExecutePhaseFxn,
 			token, cLen);
 		pGenObj->objData.nodeObj.pstrExecutePhaseFxn[cLen] = '\0';
 		token = strsep(&pszCur, seps);
 
-		/* char * pstrDeletePhaseFxn */
-               DBC_Require(token);
+		/* char *pstrDeletePhaseFxn */
+		DBC_Require(token);
 		cLen = strlen(token);
 		pGenObj->objData.nodeObj.pstrDeletePhaseFxn =
 			MEM_Calloc(cLen + 1, MEM_PAGED);
+		if (!pGenObj->objData.nodeObj.pstrDeletePhaseFxn) {
+			status = DSP_EMEMORY;
+			break;
+		}
 		strncpy(pGenObj->objData.nodeObj.pstrDeletePhaseFxn,
 			token, cLen);
 		pGenObj->objData.nodeObj.pstrDeletePhaseFxn[cLen] = '\0';
@@ -1264,11 +1228,15 @@ static DSP_STATUS GetAttrsFromBuf(char *
 		pGenObj->objData.nodeObj.uMsgNotifyType = Atoi(token);
 		token = strsep(&pszCur, seps);
 
-		/* char * pstrIAlgName */
+		/* char *pstrIAlgName */
 		if (token) {
 			cLen = strlen(token);
 			pGenObj->objData.nodeObj.pstrIAlgName =
 				MEM_Calloc(cLen + 1, MEM_PAGED);
+			if (!pGenObj->objData.nodeObj.pstrIAlgName) {
+				status = DSP_EMEMORY;
+				break;
+			}
 			strncpy(pGenObj->objData.nodeObj.pstrIAlgName,
 				token, cLen);
 			pGenObj->objData.nodeObj.pstrIAlgName[cLen] = '\0';
@@ -1375,6 +1343,13 @@ static DSP_STATUS GetAttrsFromBuf(char *
 		break;
 	}
 
+	/* Check for Memory leak */
+	if (status == DSP_EMEMORY) {
+		MEM_Free(pGenObj->objData.nodeObj.pstrCreatePhaseFxn);
+		MEM_Free(pGenObj->objData.nodeObj.pstrExecutePhaseFxn);
+		MEM_Free(pGenObj->objData.nodeObj.pstrDeletePhaseFxn);
+	}
+
 	return status;
 }
 
@@ -1394,7 +1369,6 @@ static void CompressBuf(char *pszBuf, u3
 		return;
 
 	for (q = pszBuf; q < (pszBuf + ulBufSize);) {
-
 		ch = DspChar2GppChar(q, cCharSize);
 		if (ch == '\\') {
 			q += cCharSize;
@@ -1430,7 +1404,6 @@ static void CompressBuf(char *pszBuf, u3
 	/* NULL out remainder of buffer. */
 	while (p < q)
 		*p++ = '\0';
-
 }
 
 /*
@@ -1466,8 +1439,8 @@ static DSP_STATUS GetDepLibInfo(IN struc
 	char *pszCur;
 	char *pszFileName = NULL;
 	struct COD_LIBRARYOBJ *lib = NULL;
-	u32 ulAddr = 0;	/* Used by COD_GetSection */
-	u32 ulLen = 0;	/* Used by COD_GetSection */
+	u32 ulAddr = 0;				/* Used by COD_GetSection */
+	u32 ulLen = 0;				/* Used by COD_GetSection */
 	u32 dwDataSize = COD_MAXPATHLENGTH;
 	char seps[] = ", ";
 	char *pToken = NULL;
@@ -1500,6 +1473,7 @@ static DSP_STATUS GetDepLibInfo(IN struc
 		status = DCD_GetLibraryName(hDcdMgr, pUuid, pszFileName,
 			 &dwDataSize, phase, NULL);
 	}
+
 	/* Open the library */
 	if (DSP_SUCCEEDED(status)) {
 		status = COD_Open(pDcdMgr->hCodMgr, pszFileName,
@@ -1520,7 +1494,7 @@ static DSP_STATUS GetDepLibInfo(IN struc
 		goto func_cont;
 
 	/* Allocate zeroed buffer. */
-	pszCoffBuf = MEM_Calloc(ulLen, MEM_PAGED);
+	pszCoffBuf = MEM_Calloc(ulLen + 4, MEM_PAGED);
 	if (pszCoffBuf == NULL)
 		status = DSP_EMEMORY;
 
@@ -1531,6 +1505,7 @@ static DSP_STATUS GetDepLibInfo(IN struc
 
 	/* Compress and format DSP buffer to conform to PC format. */
 	CompressBuf(pszCoffBuf, ulLen, DSPWORDSIZE);
+
 	/* Read from buffer */
 	pszCur = pszCoffBuf;
 	while ((pToken = strsep(&pszCur, seps)) && *pToken != '\0') {
@@ -1570,4 +1545,3 @@ func_cont:
 
 	return status;
 }
-
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/disp.c kernel-power-2.6.28/drivers/dsp/bridge/rmgr/disp.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/disp.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/rmgr/disp.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Node Dispatcher interface. Communicates with Resource Manager Server
+ * (RMS) on DSP. Access to RMS is synchronized in NODE.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software;  you can redistribute it and/or modify
@@ -14,38 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== disp.c ========
- *
- *  Description:
- *      Node Dispatcher interface. Communicates with Resource Manager Server
- *      (RMS) on DSP. Access to RMS is synchronized in NODE.
- *
- *  Public Functions:
- *      DISP_Create
- *      DISP_Delete
- *      DISP_Exit
- *      DISP_Init
- *      DISP_NodeChangePriority
- *      DISP_NodeCreate
- *      DISP_NodeDelete
- *      DISP_NodePause
- *      DISP_NodeRun
- *
- *! Revision History:
- *! =================
- *! 18-Feb-2003 vp      Code review updates
- *! 18-Oct-2002 vp      Ported to Linux platform
- *! 16-May-2002 jeh     Added DISP_DoCinit().
- *! 24-Apr-2002 jeh     Added DISP_MemWrite().
- *! 13-Feb-2002 jeh     Pass system stack size to RMS.
- *! 16-Jan-2002  ag     Added bufsize param to _ChnlAddIOReq() fxn
- *! 10-May-2001 jeh     Code Review cleanup.
- *! 26-Sep-2000 jeh     Fixed status values in SendMessage().
- *! 19-Jun-2000 jeh     Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -59,10 +30,8 @@
 #include <dspbridge/dbc.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/dev.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/sync.h>
-#include <dspbridge/csl.h>
 
 /*  ----------------------------------- Link Driver */
 #include <dspbridge/wmd.h>
@@ -164,7 +133,7 @@ DSP_STATUS DISP_Create(OUT struct DISP_O
 	if (DSP_SUCCEEDED(status)) {
 		status = DEV_GetChnlMgr(hDevObject, &(pDisp->hChnlMgr));
 		if (DSP_SUCCEEDED(status)) {
-			(void) DEV_GetIntfFxns(hDevObject, &pIntfFxns);
+			status = DEV_GetIntfFxns(hDevObject, &pIntfFxns);
 			pDisp->pIntfFxns = pIntfFxns;
 		} else {
 			GT_1trace(DISP_DebugMask, GT_6CLASS,
@@ -191,23 +160,22 @@ DSP_STATUS DISP_Create(OUT struct DISP_O
 		status = DSP_EFAIL;
 		goto func_cont;
 	}
-	if (DSP_SUCCEEDED(status)) {
-		pDisp->uCharSize = DSPWORDSIZE;
-		pDisp->uWordSize = DSPWORDSIZE;
-		pDisp->uDataMauSize = DSPWORDSIZE;
-		/* Open channels for communicating with the RMS */
-		chnlAttrs.uIOReqs = CHNLIOREQS;
-		chnlAttrs.hEvent = NULL;
-		ulChnlId = pDispAttrs->ulChnlOffset + CHNLTORMSOFFSET;
-		status = (*pIntfFxns->pfnChnlOpen)(&(pDisp->hChnlToDsp),
-			 pDisp->hChnlMgr, CHNL_MODETODSP, ulChnlId, &chnlAttrs);
-		if (DSP_FAILED(status)) {
-			GT_2trace(DISP_DebugMask, GT_6CLASS,
-				 "DISP_Create:  Channel to RMS "
-				 "open failed, chnl id = %d, status = 0x%x\n",
-				 ulChnlId, status);
-		}
-	}
+
+	pDisp->uCharSize = DSPWORDSIZE;
+	pDisp->uWordSize = DSPWORDSIZE;
+	pDisp->uDataMauSize = DSPWORDSIZE;
+	/* Open channels for communicating with the RMS */
+	chnlAttrs.uIOReqs = CHNLIOREQS;
+	chnlAttrs.hEvent = NULL;
+	ulChnlId = pDispAttrs->ulChnlOffset + CHNLTORMSOFFSET;
+	status = (*pIntfFxns->pfnChnlOpen)(&(pDisp->hChnlToDsp),
+		 pDisp->hChnlMgr, CHNL_MODETODSP, ulChnlId, &chnlAttrs);
+	if (DSP_FAILED(status))
+		GT_2trace(DISP_DebugMask, GT_6CLASS,
+			 "DISP_Create:  Channel to RMS "
+			 "open failed, chnl id = %d, status = 0x%x\n",
+			 ulChnlId, status);
+
 	if (DSP_SUCCEEDED(status)) {
 		ulChnlId = pDispAttrs->ulChnlOffset + CHNLFROMRMSOFFSET;
 		status = (*pIntfFxns->pfnChnlOpen)(&(pDisp->hChnlFromDsp),
@@ -797,8 +765,8 @@ static DSP_STATUS FillStreamDef(RMS_WORD
 		 *  1 from total.
 		 */
 		total += sizeof(struct RMS_StrmDef) / sizeof(RMS_WORD) - 1;
-               DBC_Require(strmDef.szDevice);
-               dwLength = strlen(strmDef.szDevice) + 1;
+		DBC_Require(strmDef.szDevice);
+		dwLength = strlen(strmDef.szDevice) + 1;
 
 		/* Number of RMS_WORDS needed to hold device name */
 		uNameLen = (dwLength + uCharsInRMSWord - 1) / uCharsInRMSWord;
@@ -850,7 +818,7 @@ static DSP_STATUS SendMessage(struct DIS
 		GT_1trace(DISP_DebugMask, GT_6CLASS,
 			 "SendMessage: Channel AddIOReq to"
 			 " RMS failed! Status = 0x%x\n", status);
-		goto func_cont;
+		goto func_end;
 	}
 	status = (*pIntfFxns->pfnChnlGetIOC) (hChnl, dwTimeout, &chnlIOC);
 	if (DSP_SUCCEEDED(status)) {
@@ -870,7 +838,6 @@ static DSP_STATUS SendMessage(struct DIS
 			 "SendMessage: Channel GetIOC to"
 			 " RMS failed! Status = 0x%x\n", status);
 	}
-func_cont:
 	/* Get the reply */
 	if (DSP_FAILED(status))
 		goto func_end;
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/drv.c kernel-power-2.6.28/drivers/dsp/bridge/rmgr/drv.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/drv.c	2011-04-17 17:32:28.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/rmgr/drv.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge resource allocation module.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,82 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== drv.c ========
- *  Description:
- *      DSP/BIOS Bridge resource allocation module.
- *
- *  Public Functions:
- *      DRV_Create
- *      DRV_Destroy
- *      DRV_Exit
- *      DRV_GetDevObject
- *      DRV_GetDevExtension
- *      DRV_GetFirstDevObject
- *      DRV_GetNextDevObject
- *      DRV_GetNextDevExtension
- *      DRV_Init
- *      DRV_InsertDevObject
- *      DRV_RemoveDevObject
- *      DRV_RequestResources
- *      DRV_ReleaseResources
- *
- *! Revision History
- *! ======== ========
- *! 19-Apr-2004 sb: Replaced OS specific APIs with MEM_AllocPhysMem and
-		    MEM_FreePhysMem. Fixed warnings. Cosmetic updates.
- *! 12-Apr-2004 hp: IVA clean up during bridge-uninstall
- *! 05-Jan-2004 vp: Updated for 24xx platform
- *! 21-Mar-2003 sb: Get SHM size from registry
- *! 10-Feb-2003 vp: Code review updates
- *! 18-Oct-2002 vp: Ported to Linux platform
- *! 30-Oct-2000 kc: Modified usage of REG_SetValue.
- *! 06-Sep-2000 jeh Read channel info into struct CFG_HOSTRES in
- *! 					RequestISAResources()
- *! 21-Sep-2000 rr: numwindows is calculated instead of default value in
- *!		 RequestISAResources.
- *! 07-Aug-2000 rr: static list of dev objects removed.
- *! 27-Jul-2000 rr: RequestResources split into two(Request and Release)
- *!		 Device extension created to hold the DevNodeString.
- *! 17-Jul-2000 rr: Driver Object holds the list of Device Objects.
- *!		 Added DRV_Create, DRV_Destroy, DRV_GetDevObject,
- *!		 DRV_GetFirst/NextDevObject, DRV_Insert/RemoveDevObject.
- *! 09-May-2000 rr: PCI Support is not L301 specific.Use of MEM_Calloc
- *!		 instead of MEM_Alloc.
- *! 28-Mar-2000 rr: PCI Support added. L301 Specific. TBD.
- *! 03-Feb-2000 rr: GT and Module Init/exit Changes. Merged with kc.
- *! 19-Jan-2000 rr: DBC_Ensure in RequestPCMCIA moved within PCCARD ifdef
- *! 29-Dec-1999 rr: PCCard support for any slot.Bus type stored in the
- *!		 struct CFG_HOSTRES Structure.
- *! 17-Dec-1999 rr: if PCCARD_Init fails we return DSP_EFAIL.
- *!		 DBC_Ensure checks for sucess and pDevice != NULL
- *! 11-Dec-1999 ag: #define "Isa" renamed to "IsaBus".
- *! 09-Dec-1999 rr: windows.h included to remove warnings.
- *! 02-Dec-1999 rr: struct GT_Mask is with in if DEBUG. Request resources checks
- *!		 status while making call to Reg functions.
- *! 23-Nov-1999 rr: windows.h included
- *! 19-Nov-1999 rr: DRV_RELEASE bug while setting the registry to zero.
- *!		 fixed.
- *! 12-Nov-1999 rr: RequestResources() reads values from the registry.
- *!		 Hardcoded bIRQRegister define removed.
- *! 05-Nov-1999 rr: Added hardcoded device interrupt.
- *! 25-Oct-1999 rr: Resource structure removed. Now it uses the Host
- *!		 Resource structure directly.
- *! 15-Oct-1999 rr: Resource Structure modified. See drv.h
- *!		 dwBusType taken from the registry.Hard coded
- *!		 registry entries removed.
- *! 05-Oct-1999 rr: Calling DEV_StartDevice moved to wcdce.c. DRV_Register
- *!		 MiniDriver has been renamed to DRV_RequestResources.
- *!		 DRV_UnRegisterMiniDriver fxn removed.
- *! 24-Sep-1999 rr: Significant changes to the RegisterMiniDriver fxns.
- *!		 Now it is simpler. IT stores the dev node in the
- *!		 registry, assign resources and calls the DEV_Start.
- *! 10-Sep-1999 rr: Register Minidriver modified.
- *!		 - Resource structure follows the NT model
- *! 08-Aug-1999 rr: Adopted for WinCE. Exports Fxns removed. Hull Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -104,26 +30,20 @@
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/cfg.h>
-#include <dspbridge/csl.h>
 #include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/reg.h>
 
-/*  ----------------------------------- Others */
-#include <dspbridge/dbreg.h>
-
 /*  ----------------------------------- This */
 #include <dspbridge/drv.h>
 #include <dspbridge/dev.h>
 
-#ifndef RES_CLEANUP_DISABLE
 #include <dspbridge/node.h>
 #include <dspbridge/proc.h>
 #include <dspbridge/strm.h>
 #include <dspbridge/nodepriv.h>
 #include <dspbridge/wmdchnl.h>
 #include <dspbridge/resourcecleanup.h>
-#endif
 
 /*  ----------------------------------- Defines, Data Structures, Typedefs */
 #define SIGNATURE   0x5f52474d	/* "DRV_" (in reverse) */
@@ -132,9 +52,6 @@ struct DRV_OBJECT {
 	u32 dwSignature;
 	struct LST_LIST *devList;
 	struct LST_LIST *devNodeString;
-#ifndef RES_CLEANUP_DISABLE
-	struct PROCESS_CONTEXT  *procCtxtList;
-#endif
 };
 
 /*
@@ -142,7 +59,7 @@ struct DRV_OBJECT {
  *  DRV_ since it is living in this module
  */
 struct DRV_EXT {
-	struct LST_ELEM link;
+	struct list_head link;
 	char szString[MAXREGPATHLENGTH];
 };
 
@@ -157,151 +74,12 @@ extern struct GT_Mask curTrace;
 static DSP_STATUS RequestBridgeResources(u32 dwContext, s32 fRequest);
 static DSP_STATUS RequestBridgeResourcesDSP(u32 dwContext, s32 fRequest);
 
-#ifndef RES_CLEANUP_DISABLE
 /* GPP PROCESS CLEANUP CODE */
 
-static DSP_STATUS PrintProcessInformation(void);
 static DSP_STATUS DRV_ProcFreeNodeRes(HANDLE hPCtxt);
 static DSP_STATUS  DRV_ProcFreeSTRMRes(HANDLE hPCtxt);
 extern enum NODE_STATE NODE_GetState(HANDLE hNode);
 
-/* Get the process context list from driver object */
-
-/* Set the Process ID */
-DSP_STATUS DRV_ProcSetPID(HANDLE hPCtxt, s32 hProcess)
-{
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-
-	DBC_Assert(hPCtxt != NULL);
-
-	pCtxt->pid = hProcess;
-	return status;
-}
-
-
-/* Getting the head of the process context list */
-DSP_STATUS DRV_GetProcCtxtList(struct PROCESS_CONTEXT **pPctxt,
-				struct DRV_OBJECT *hDrvObject)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct DRV_OBJECT *pDrvObject = (struct DRV_OBJECT *)hDrvObject;
-
-	DBC_Assert(hDrvObject != NULL);
-	GT_2trace(curTrace, GT_ENTER,
-		"DRV_GetProcCtxtList: 2 *pPctxt:%x, pDrvObject"
-		":%x", *pPctxt, pDrvObject);
-	*pPctxt = pDrvObject->procCtxtList;
-	GT_2trace(curTrace, GT_ENTER,
-		"DRV_GetProcCtxtList: 3 *pPctxt:%x, pDrvObject"
-		":%x", *pPctxt, pDrvObject);
-	return status;
-}
-
-/* Add a new process context to process context list */
-DSP_STATUS DRV_InsertProcContext(struct DRV_OBJECT *hDrVObject, HANDLE hPCtxt)
-{
-	struct PROCESS_CONTEXT **pCtxt = (struct PROCESS_CONTEXT **)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct PROCESS_CONTEXT *pCtxtList = NULL;
-	struct DRV_OBJECT	     *hDRVObject;
-
-	GT_0trace(curTrace, GT_ENTER, "\n In DRV_InsertProcContext\n");
-
-	status = CFG_GetObject((u32 *)&hDRVObject, REG_DRV_OBJECT);
-	DBC_Assert(hDRVObject != NULL);
-
-	*pCtxt = MEM_Calloc(1 * sizeof(struct PROCESS_CONTEXT), MEM_PAGED);
-	if (!*pCtxt) {
-		pr_err("DSP: MEM_Calloc failed in DRV_InsertProcContext\n");
-		return DSP_EMEMORY;
-	}
-
-	spin_lock_init(&(*pCtxt)->proc_list_lock);
-	INIT_LIST_HEAD(&(*pCtxt)->processor_list);
-
-	spin_lock_init(&(*pCtxt)->dmm_list_lock);
-
-	GT_0trace(curTrace, GT_ENTER,
-		 "\n In DRV_InsertProcContext Calling "
-		 "DRV_GetProcCtxtList\n");
-	DRV_GetProcCtxtList(&pCtxtList, hDRVObject);
-	GT_0trace(curTrace, GT_ENTER,
-		 "\n In DRV_InsertProcContext After Calling "
-		 "DRV_GetProcCtxtList\n");
-	if (pCtxtList != NULL) {
-		GT_0trace(curTrace, GT_ENTER,
-			 "\n In DRV_InsertProcContext and pCtxt is "
-			 "not Null\n");
-		while (pCtxtList->next != NULL)
-			pCtxtList = pCtxtList->next;
-
-		pCtxtList->next = *pCtxt;
-	} else {
-		GT_0trace(curTrace, GT_ENTER,
-			 "\n In DRV_InsertProcContext and "
-			 "pCtxt is Null\n");
-		hDRVObject->procCtxtList = *pCtxt;
-	}
-	return status;
-}
-
-/* Delete a process context from process resource context list */
-DSP_STATUS DRV_RemoveProcContext(struct DRV_OBJECT *hDRVObject,
-		HANDLE pr_ctxt)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct PROCESS_CONTEXT *pr_ctxt_list = NULL;
-	struct PROCESS_CONTEXT *uninitialized_var(ptr_prev);
-
-	DBC_Assert(hDRVObject != NULL);
-
-	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveProcContext: 12");
-	DRV_GetProcCtxtList(&pr_ctxt_list, hDRVObject);
-
-	/* Special condition */
-	if (pr_ctxt_list == pr_ctxt) {
-		hDRVObject->procCtxtList = NULL;
-		goto func_cont;
-	}
-
-	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveProcContext: 13");
-	while (pr_ctxt_list && (pr_ctxt_list != pr_ctxt)) {
-		ptr_prev = pr_ctxt_list;
-		pr_ctxt_list = pr_ctxt_list->next;
-		GT_0trace(curTrace, GT_ENTER,
-			 "DRV_RemoveProcContext: 2");
-	}
-
-	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveProcContext: 3");
-
-	if (!pr_ctxt_list)
-		return DSP_ENOTFOUND;
-	else
-		ptr_prev->next = pr_ctxt_list->next;
-
-func_cont:
-	MEM_Free(pr_ctxt);
-	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveProcContext: 7");
-
-	return status;
-}
-
-/* Update the state of process context */
-DSP_STATUS DRV_ProcUpdatestate(HANDLE hPCtxt, enum GPP_PROC_RES_STATE status)
-{
-	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS status1 = DSP_SOK;
-	if (pCtxt != NULL) {
-		pCtxt->resState = status;
-	} else {
-		GT_0trace(curTrace, GT_ENTER,
-			 "DRV_ProcUpdatestate: Failed to update "
-			 "process state");
-	}
-	return status1;
-}
-
 /* Allocate and add a node resource element
 * This function is called from .Node_Allocate.  */
 DSP_STATUS DRV_InsertNodeResElement(HANDLE hNode, HANDLE hNodeRes,
@@ -314,12 +92,13 @@ DSP_STATUS DRV_InsertNodeResElement(HAND
 	GT_0trace(curTrace, GT_ENTER, "DRV_InsertNodeResElement: 1");
 	*pNodeRes = (struct NODE_RES_OBJECT *)MEM_Calloc
 		    (1 * sizeof(struct NODE_RES_OBJECT), MEM_PAGED);
-	DBC_Assert(hPCtxt != NULL);
-	if ((*pNodeRes == NULL) || (hPCtxt == NULL)) {
+	if (*pNodeRes == NULL) {
 		GT_0trace(curTrace, GT_ENTER, "DRV_InsertNodeResElement: 12");
 		status = DSP_EHANDLE;
 	}
 	if (DSP_SUCCEEDED(status)) {
+		if (mutex_lock_interruptible(&pCtxt->node_mutex))
+			return DSP_EFAIL;
 		(*pNodeRes)->hNode = hNode;
 		if (pCtxt->pNodeList != NULL) {
 			pTempNodeRes = pCtxt->pNodeList;
@@ -334,6 +113,7 @@ DSP_STATUS DRV_InsertNodeResElement(HAND
 			GT_0trace(curTrace, GT_ENTER,
 				 "DRV_InsertNodeResElement: 3");
 		}
+		mutex_unlock(&pCtxt->node_mutex);
 	}
 	GT_0trace(curTrace, GT_ENTER, "DRV_InsertNodeResElement: 4");
 	return status;
@@ -345,25 +125,24 @@ DSP_STATUS DRV_RemoveNodeResElement(HAND
 {
 	struct NODE_RES_OBJECT *pNodeRes = (struct NODE_RES_OBJECT *)hNodeRes;
 	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	DSP_STATUS	status = DSP_SOK;
-	struct NODE_RES_OBJECT *pTempNode2 = pCtxt->pNodeList;
-	struct NODE_RES_OBJECT *pTempNode = pCtxt->pNodeList;
+	struct NODE_RES_OBJECT *pTempNode;
+	DSP_STATUS status = DSP_SOK;
 
-	DBC_Assert(hPCtxt != NULL);
-	GT_0trace(curTrace, GT_ENTER, "\nDRV_RemoveNodeResElement: 1\n");
-	while ((pTempNode != NULL) && (pTempNode != pNodeRes)) {
-		pTempNode2 = pTempNode;
-		pTempNode = pTempNode->next;
-	}
-	if (pCtxt->pNodeList == pNodeRes)
+	if (mutex_lock_interruptible(&pCtxt->node_mutex))
+		return DSP_EFAIL;
+	pTempNode = pCtxt->pNodeList;
+	if (pTempNode == pNodeRes) {
 		pCtxt->pNodeList = pNodeRes->next;
-
-	if (pTempNode == NULL)
-		return DSP_ENOTFOUND;
-	else if (pTempNode2->next != NULL)
-		pTempNode2->next = pTempNode2->next->next;
-
-	MEM_Free(pTempNode);
+	} else {
+		while (pTempNode && pTempNode->next != pNodeRes)
+			pTempNode = pTempNode->next;
+		if (!pTempNode)
+			status = DSP_ENOTFOUND;
+		else
+			pTempNode->next = pNodeRes->next;
+	}
+	mutex_unlock(&pCtxt->node_mutex);
+	MEM_Free(pNodeRes);
 	return status;
 }
 
@@ -376,7 +155,6 @@ static DSP_STATUS DRV_ProcFreeNodeRes(HA
 	struct NODE_RES_OBJECT *pNodeRes = NULL;
 	u32  nState;
 
-	DBC_Assert(hPCtxt != NULL);
 	pNodeList = pCtxt->pNodeList;
 	while (pNodeList != NULL) {
 		GT_0trace(curTrace, GT_ENTER, "DRV_ProcFreeNodeRes: 1");
@@ -424,13 +202,15 @@ DSP_STATUS DRV_InsertDMMResElement(HANDL
 
 	*pDMMRes = (struct DMM_RES_OBJECT *)
 		    MEM_Calloc(1 * sizeof(struct DMM_RES_OBJECT), MEM_PAGED);
-	DBC_Assert(hPCtxt != NULL);
 	GT_0trace(curTrace, GT_ENTER, "DRV_InsertDMMResElement: 1");
-	if ((*pDMMRes == NULL) || (hPCtxt == NULL)) {
+	if (*pDMMRes == NULL) {
 		GT_0trace(curTrace, GT_5CLASS, "DRV_InsertDMMResElement: 2");
 		status = DSP_EHANDLE;
 	}
 	if (DSP_SUCCEEDED(status)) {
+		if (mutex_lock_interruptible(&pCtxt->dmm_mutex))
+			return DSP_EFAIL;
+
 		if (pCtxt->pDMMList != NULL) {
 			GT_0trace(curTrace, GT_5CLASS,
 				 "DRV_InsertDMMResElement: 3");
@@ -444,43 +224,36 @@ DSP_STATUS DRV_InsertDMMResElement(HANDL
 			GT_0trace(curTrace, GT_5CLASS,
 				 "DRV_InsertDMMResElement: 4");
 		}
+		mutex_unlock(&pCtxt->dmm_mutex);
 	}
 	GT_0trace(curTrace, GT_ENTER, "DRV_InsertDMMResElement: 5");
 	return status;
 }
 
-
-
 /* Release DMM resource element context
 * This is called from Proc_UnMap. after the actual resource is freed */
 DSP_STATUS DRV_RemoveDMMResElement(HANDLE hDMMRes, HANDLE hPCtxt)
 {
 	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
 	struct DMM_RES_OBJECT *pDMMRes = (struct DMM_RES_OBJECT *)hDMMRes;
-	DSP_STATUS status = DSP_SOK;
-	struct DMM_RES_OBJECT *pTempDMMRes2 = NULL;
 	struct DMM_RES_OBJECT *pTempDMMRes = NULL;
+	DSP_STATUS status = DSP_SOK;
 
-	DBC_Assert(hPCtxt != NULL);
-	pTempDMMRes2 = pCtxt->pDMMList;
+	if (mutex_lock_interruptible(&pCtxt->dmm_mutex))
+		return DSP_EFAIL;
 	pTempDMMRes = pCtxt->pDMMList;
-	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveDMMResElement: 1");
-	while ((pTempDMMRes != NULL) && (pTempDMMRes != pDMMRes)) {
-		GT_0trace(curTrace, GT_ENTER, "DRV_RemoveDMMResElement: 2");
-		pTempDMMRes2 = pTempDMMRes;
-		pTempDMMRes = pTempDMMRes->next;
+	if (pCtxt->pDMMList == pDMMRes) {
+		pCtxt->pDMMList = pDMMRes->next;
+	} else {
+		while (pTempDMMRes && pTempDMMRes->next != pDMMRes)
+			pTempDMMRes = pTempDMMRes->next;
+		if (!pTempDMMRes)
+			status = DSP_ENOTFOUND;
+		else
+			pTempDMMRes->next = pDMMRes->next;
 	}
-	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveDMMResElement: 3");
-	if (pCtxt->pDMMList == pTempDMMRes)
-		pCtxt->pDMMList = pTempDMMRes->next;
-
-	if (pTempDMMRes == NULL)
-		return DSP_ENOTFOUND;
-	else if (pTempDMMRes2->next != NULL)
-		pTempDMMRes2->next = pTempDMMRes2->next->next;
-
+	mutex_unlock(&pCtxt->dmm_mutex);
 	MEM_Free(pDMMRes);
-	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveDMMResElement: 4");
 	return status;
 }
 
@@ -504,31 +277,34 @@ DSP_STATUS DRV_UpdateDMMResElement(HANDL
 }
 
 /* Actual DMM De-Allocation */
-DSP_STATUS DRV_ProcFreeDMMRes(HANDLE hPCtxt)
+DSP_STATUS  DRV_ProcFreeDMMRes(HANDLE hPCtxt)
 {
 	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
 	DSP_STATUS status = DSP_SOK;
 	struct DMM_RES_OBJECT *pDMMList = pCtxt->pDMMList;
 	struct DMM_RES_OBJECT *pDMMRes = NULL;
 
-	DBC_Assert(hPCtxt != NULL);
 	GT_0trace(curTrace, GT_ENTER, "\nDRV_ProcFreeDMMRes: 1\n");
 	while (pDMMList != NULL) {
 		pDMMRes = pDMMList;
 		pDMMList = pDMMList->next;
 		if (pDMMRes->dmmAllocated) {
-			/* PROC_UnMap frees pDMMRes */
-			void *processor = pDMMRes->hProcessor;
-			void *map_addr = (void*)pDMMRes->ulDSPAddr;
-			void *rsv_addr = (void*)pDMMRes->ulDSPResAddr;
-			status = PROC_UnMap(processor, map_addr, pCtxt);
-			status = PROC_UnReserveMemory(processor, rsv_addr);
+			status = PROC_UnMap(pDMMRes->hProcessor,
+				 (void *)pDMMRes->ulDSPResAddr, pCtxt);
+			if (DSP_FAILED(status))
+				pr_debug("%s: PROC_UnMap failed! status ="
+						" 0x%xn", __func__, status);
+			status = PROC_UnReserveMemory(pDMMRes->hProcessor,
+				 (void *)pDMMRes->ulDSPResAddr);
+			if (DSP_FAILED(status))
+				pr_debug("%s: PROC_UnReserveMemory failed!"
+					" status = 0x%xn", __func__, status);
+			pDMMRes->dmmAllocated = 0;
 		}
 	}
 	return status;
 }
 
-
 /* Release all DMM resources and its context
 * This is called from .bridge_release. */
 DSP_STATUS DRV_RemoveAllDMMResElements(HANDLE hPCtxt)
@@ -538,7 +314,6 @@ DSP_STATUS DRV_RemoveAllDMMResElements(H
 	struct DMM_RES_OBJECT *pTempDMMRes2 = NULL;
 	struct DMM_RES_OBJECT *pTempDMMRes = NULL;
 
-	DBC_Assert(pCtxt != NULL);
 	DRV_ProcFreeDMMRes(pCtxt);
 	pTempDMMRes = pCtxt->pDMMList;
 	while (pTempDMMRes != NULL) {
@@ -555,19 +330,22 @@ DSP_STATUS DRV_GetDMMResElement(u32 pMap
 	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
 	struct DMM_RES_OBJECT **pDMMRes = (struct DMM_RES_OBJECT **)hDMMRes;
 	DSP_STATUS status = DSP_SOK;
-	struct DMM_RES_OBJECT *pTempDMM2 = NULL;
 	struct DMM_RES_OBJECT *pTempDMM = NULL;
 
-	DBC_Assert(hPCtxt != NULL);
+	if (mutex_lock_interruptible(&pCtxt->dmm_mutex))
+		return DSP_EFAIL;
+
 	pTempDMM = pCtxt->pDMMList;
 	while ((pTempDMM != NULL) && (pTempDMM->ulDSPAddr != pMapAddr)) {
 		GT_3trace(curTrace, GT_ENTER,
 			 "DRV_GetDMMResElement: 2 pTempDMM:%x "
 			 "pTempDMM->ulDSPAddr:%x pMapAddr:%x\n", pTempDMM,
 			 pTempDMM->ulDSPAddr, pMapAddr);
-		pTempDMM2 = pTempDMM;
 		pTempDMM = pTempDMM->next;
 	}
+
+	mutex_unlock(&pCtxt->dmm_mutex);
+
 	if (pTempDMM != NULL) {
 		GT_0trace(curTrace, GT_ENTER, "DRV_GetDMMResElement: 3");
 		*pDMMRes = pTempDMM;
@@ -603,7 +381,6 @@ DSP_STATUS 	DRV_RemoveAllNodeResElements
 	struct NODE_RES_OBJECT *pTempNode2 = NULL;
 	struct NODE_RES_OBJECT *pTempNode = NULL;
 
-	DBC_Assert(hPCtxt != NULL);
 	DRV_ProcFreeNodeRes(pCtxt);
 	pTempNode = pCtxt->pNodeList;
 	while (pTempNode != NULL) {
@@ -616,7 +393,6 @@ DSP_STATUS 	DRV_RemoveAllNodeResElements
 }
 
 /* Getting the node resource element */
-
 DSP_STATUS DRV_GetNodeResElement(HANDLE hNode, HANDLE hNodeRes, HANDLE hPCtxt)
 {
 	struct NODE_RES_OBJECT **nodeRes = (struct NODE_RES_OBJECT **)hNodeRes;
@@ -625,13 +401,18 @@ DSP_STATUS DRV_GetNodeResElement(HANDLE 
 	struct NODE_RES_OBJECT *pTempNode2 = NULL;
 	struct NODE_RES_OBJECT *pTempNode = NULL;
 
-	DBC_Assert(hPCtxt != NULL);
+	if (mutex_lock_interruptible(&pCtxt->node_mutex))
+		return DSP_EFAIL;
+
 	pTempNode = pCtxt->pNodeList;
 	GT_0trace(curTrace, GT_ENTER, "DRV_GetNodeResElement: 1");
 	while ((pTempNode != NULL) && (pTempNode->hNode != hNode)) {
 		pTempNode2 = pTempNode;
 		pTempNode = pTempNode->next;
 	}
+
+	mutex_unlock(&pCtxt->node_mutex);
+
 	if (pTempNode != NULL)
 		*nodeRes = pTempNode;
 	else
@@ -640,8 +421,6 @@ DSP_STATUS DRV_GetNodeResElement(HANDLE 
 	return status;
 }
 
-
-
 /* Allocate the STRM resource element
 * This is called after the actual resource is allocated
 */
@@ -652,15 +431,16 @@ DSP_STATUS DRV_ProcInsertSTRMResElement(
 	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
 	DSP_STATUS status = DSP_SOK;
 	struct STRM_RES_OBJECT *pTempSTRMRes = NULL;
-	DBC_Assert(hPCtxt != NULL);
 
 	*pSTRMRes = (struct STRM_RES_OBJECT *)
 		    MEM_Calloc(1 * sizeof(struct STRM_RES_OBJECT), MEM_PAGED);
-	if ((*pSTRMRes == NULL) || (hPCtxt == NULL)) {
+	if (*pSTRMRes == NULL) {
 		GT_0trace(curTrace, GT_ENTER, "DRV_InsertSTRMResElement: 2");
 		status = DSP_EHANDLE;
 	}
 	if (DSP_SUCCEEDED(status)) {
+		if (mutex_lock_interruptible(&pCtxt->strm_mutex))
+			return DSP_EFAIL;
 		(*pSTRMRes)->hStream = hStreamHandle;
 		if (pCtxt->pSTRMList != NULL) {
 			GT_0trace(curTrace, GT_ENTER,
@@ -675,12 +455,11 @@ DSP_STATUS DRV_ProcInsertSTRMResElement(
 			GT_0trace(curTrace, GT_ENTER,
 				 "DRV_InsertSTRMResElement: 4");
 		}
+		mutex_unlock(&pCtxt->strm_mutex);
 	}
 	return status;
 }
 
-
-
 /* Release Stream resource element context
 * This function called after the actual resource is freed
 */
@@ -688,69 +467,62 @@ DSP_STATUS 	DRV_ProcRemoveSTRMResElement
 {
 	struct STRM_RES_OBJECT *pSTRMRes = (struct STRM_RES_OBJECT *)hSTRMRes;
 	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
+	struct STRM_RES_OBJECT *pTempSTRMRes;
 	DSP_STATUS status = DSP_SOK;
-	struct STRM_RES_OBJECT *pTempSTRMRes2 = pCtxt->pSTRMList;
-	struct STRM_RES_OBJECT *pTempSTRMRes = pCtxt->pSTRMList;
-
-	DBC_Assert(hPCtxt != NULL);
-	while ((pTempSTRMRes != NULL) && (pTempSTRMRes != pSTRMRes)) {
-		pTempSTRMRes2 = pTempSTRMRes;
-		pTempSTRMRes = pTempSTRMRes->next;
-	}
-	if (pCtxt->pSTRMList == pTempSTRMRes)
-		pCtxt->pSTRMList = pTempSTRMRes->next;
 
-	if (pTempSTRMRes == NULL)
-		status = DSP_ENOTFOUND;
-	else if (pTempSTRMRes2->next != NULL)
-		pTempSTRMRes2->next = pTempSTRMRes2->next->next;
+	if (mutex_lock_interruptible(&pCtxt->strm_mutex))
+		return DSP_EFAIL;
+	pTempSTRMRes = pCtxt->pSTRMList;
 
+	if (pCtxt->pSTRMList == pSTRMRes) {
+		pCtxt->pSTRMList = pSTRMRes->next;
+	} else {
+		while (pTempSTRMRes && pTempSTRMRes->next != pSTRMRes)
+			pTempSTRMRes = pTempSTRMRes->next;
+		if (pTempSTRMRes == NULL)
+			status = DSP_ENOTFOUND;
+		else
+			pTempSTRMRes->next = pSTRMRes->next;
+	}
+	mutex_unlock(&pCtxt->strm_mutex);
 	MEM_Free(pSTRMRes);
 	return status;
 }
 
-
 /* Actual Stream De-Allocation */
 static DSP_STATUS  DRV_ProcFreeSTRMRes(HANDLE hPCtxt)
 {
 	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
 	DSP_STATUS status = DSP_SOK;
-	DSP_STATUS status1 = DSP_SOK;
 	u8 **apBuffer = NULL;
-	struct STRM_RES_OBJECT *pSTRMList = NULL;
 	struct STRM_RES_OBJECT *pSTRMRes = NULL;
+	struct STRM_INFO strm_info;
+	struct DSP_STREAMINFO user;
 	u8 *pBufPtr;
 	u32 ulBytes;
 	u32 dwArg;
 	s32 ulBufSize;
 
-
-	DBC_Assert(hPCtxt != NULL);
-	pSTRMList = pCtxt->pSTRMList;
-	while (pSTRMList != NULL) {
-		pSTRMRes = pSTRMList;
-		pSTRMList = pSTRMList->next;
-		if (pSTRMRes->uNumBufs != 0) {
-			apBuffer = MEM_Alloc((pSTRMRes->uNumBufs *
-					    sizeof(u8 *)), MEM_NONPAGED);
+	pSTRMRes = pCtxt->pSTRMList;
+	while (pSTRMRes) {
+		if (pSTRMRes->uNumBufs) {
+			apBuffer = MEM_Alloc(pSTRMRes->uNumBufs *
+					    sizeof(u8 *), MEM_NONPAGED);
+			if (!apBuffer)
+				return DSP_EMEMORY;
 			status = STRM_FreeBuffer(pSTRMRes->hStream, apBuffer,
 						pSTRMRes->uNumBufs, pCtxt);
 			MEM_Free(apBuffer);
 		}
-		status = STRM_Close(pSTRMRes->hStream, pCtxt);
-		if (DSP_FAILED(status)) {
-			if (status == DSP_EPENDING) {
-				status = STRM_Reclaim(pSTRMRes->hStream,
-						     &pBufPtr, &ulBytes,
-						     (u32 *)&ulBufSize, &dwArg);
-				if (DSP_SUCCEEDED(status))
-					status = STRM_Close(pSTRMRes->hStream,
-							pCtxt);
+		strm_info.pUser = &user;
+		user.uNumberBufsInStream = 0;
+		STRM_GetInfo(pSTRMRes->hStream, &strm_info, sizeof(strm_info));
+		while (strm_info.pUser->uNumberBufsInStream--)
+			STRM_Reclaim(pSTRMRes->hStream, &pBufPtr, &ulBytes,
+					     (u32 *)&ulBufSize, &dwArg);
 
-			}
-		}
 	}
-	return status1;
+	return status;
 }
 
 /* Release all Stream resources and its context
@@ -763,7 +535,6 @@ DSP_STATUS	DRV_RemoveAllSTRMResElements(
 	struct STRM_RES_OBJECT *pTempSTRMRes2 = NULL;
 	struct STRM_RES_OBJECT *pTempSTRMRes = NULL;
 
-	DBC_Assert(hPCtxt != NULL);
 	DRV_ProcFreeSTRMRes(pCtxt);
 	pTempSTRMRes = pCtxt->pSTRMList;
 	while (pTempSTRMRes != NULL) {
@@ -775,7 +546,6 @@ DSP_STATUS	DRV_RemoveAllSTRMResElements(
 	return status;
 }
 
-
 /* Getting the stream resource element */
 DSP_STATUS DRV_GetSTRMResElement(HANDLE hStrm, HANDLE hSTRMRes, HANDLE hPCtxt)
 {
@@ -783,14 +553,20 @@ DSP_STATUS DRV_GetSTRMResElement(HANDLE 
 	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
 	DSP_STATUS status = DSP_SOK;
 	struct STRM_RES_OBJECT *pTempSTRM2 = NULL;
-	struct STRM_RES_OBJECT *pTempSTRM = pCtxt->pSTRMList;
+	struct STRM_RES_OBJECT *pTempSTRM;
+
+	if (mutex_lock_interruptible(&pCtxt->strm_mutex))
+		return DSP_EFAIL;
 
-	DBC_Assert(hPCtxt != NULL);
+	pTempSTRM = pCtxt->pSTRMList;
 	while ((pTempSTRM != NULL) && (pTempSTRM->hStream != hStrm)) {
 		GT_0trace(curTrace, GT_ENTER, "DRV_GetSTRMResElement: 2");
 		pTempSTRM2 = pTempSTRM;
 		pTempSTRM = pTempSTRM->next;
 	}
+
+	mutex_unlock(&pCtxt->strm_mutex);
+
 	if (pTempSTRM != NULL) {
 		GT_0trace(curTrace, GT_ENTER, "DRV_GetSTRMResElement: 3");
 		*STRMRes = pTempSTRM;
@@ -803,282 +579,16 @@ DSP_STATUS DRV_GetSTRMResElement(HANDLE 
 }
 
 /* Updating the stream resource element */
-DSP_STATUS DRV_ProcUpdateSTRMRes(u32 uNumBufs, HANDLE hSTRMRes, HANDLE hPCtxt)
+DSP_STATUS DRV_ProcUpdateSTRMRes(u32 uNumBufs, HANDLE hSTRMRes)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct STRM_RES_OBJECT **STRMRes = (struct STRM_RES_OBJECT **)hSTRMRes;
 
-	DBC_Assert(hPCtxt != NULL);
 	(*STRMRes)->uNumBufs = uNumBufs;
 	return status;
 }
 
-/* Displaying the resources allocated by a process */
-DSP_STATUS DRV_ProcDisplayResInfo(u8 *pBuf1, u32 *pSize)
-{
-	struct PROCESS_CONTEXT *pCtxt = NULL;
-	struct NODE_RES_OBJECT *pNodeRes = NULL;
-	struct DMM_RES_OBJECT *pDMMRes = NULL;
-	struct STRM_RES_OBJECT *pSTRMRes = NULL;
-	struct DSPHEAP_RES_OBJECT *pDSPHEAPRes = NULL;
-	u32 tempCount = 1;
-	HANDLE hDrvObject = NULL;
-	void *pBuf = pBuf1;
-	u8 pTempBuf[250];
-	u32 tempStrLen = 0, tempStrLen2 = 0;
-	DSP_STATUS status = DSP_SOK;
-
-	CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	DRV_GetProcCtxtList(&pCtxt, (struct DRV_OBJECT *)hDrvObject);
-	GT_0trace(curTrace, GT_ENTER, "*********************"
-		 "DRV_ProcDisplayResourceInfo:*\n");
-	while (pCtxt != NULL) {
-		tempStrLen2 = sprintf((char *)pTempBuf,
-				     "-------------------------------------"
-				     "-----------------------------------\n");
-		tempStrLen2 += 2;
-		memmove(pBuf+tempStrLen, pTempBuf, tempStrLen2);
-		tempStrLen += tempStrLen2;
-		if (pCtxt->resState == PROC_RES_ALLOCATED) {
-			tempStrLen2 = sprintf((char *)pTempBuf,
-					"GPP Process Resource State: "
-					"pCtxt->resState = PROC_RES_ALLOCATED, "
-					" Process ID: %d\n", pCtxt->pid);
-			tempStrLen2 += 2;
-			memmove(pBuf+tempStrLen, pTempBuf, tempStrLen2);
-			tempStrLen += tempStrLen2;
-		} else {
-			tempStrLen2 = sprintf((char *)pTempBuf,
-				"GPP Resource State: pCtxt->resState"
-				" = PROC_RES_DEALLOCATED, Process ID:%d\n",
-				pCtxt->pid);
-			tempStrLen2 += 2;
-			memmove(pBuf+tempStrLen, pTempBuf, tempStrLen2);
-			tempStrLen += tempStrLen2;
-		}
-		pNodeRes = pCtxt->pNodeList;
-		tempCount = 1;
-		while (pNodeRes != NULL) {
-			GT_2trace(curTrace, GT_ENTER,
-				 "DRV_ProcDisplayResourceInfo: #:%d "
-				 "pCtxt->pNodeList->hNode:%x\n",
-				 tempCount, pNodeRes->hNode);
-			tempStrLen2 = sprintf((char *)pTempBuf,
-					"Node Resource Information: Node #"
-					" %d Node Handle hNode:0X%x\n",
-					tempCount, (u32)pNodeRes->hNode);
-			pNodeRes = pNodeRes->next;
-			tempStrLen2 += 2;
-			memmove(pBuf+tempStrLen, pTempBuf, tempStrLen2);
-			tempStrLen += tempStrLen2;
-			tempCount++;
-		}
-		tempCount = 1;
-		pDSPHEAPRes = pCtxt->pDSPHEAPList;
-		while (pDSPHEAPRes != NULL) {
-			GT_2trace(curTrace, GT_ENTER,
-				 "DRV_ProcDisplayResourceInfo: #:%d "
-				 "pCtxt->pDSPHEAPRList->ulMpuAddr:%x\n",
-				 tempCount, pDSPHEAPRes->ulMpuAddr);
-			tempStrLen2 = sprintf((char *)pTempBuf,
-				 "DSP Heap Resource Info: HEAP # %d"
-				 " Mapped GPP Address: 0x%x, size: 0x%x\n",
-				 tempCount, (u32)pDSPHEAPRes->ulMpuAddr,
-				 (u32)pDSPHEAPRes->heapSize);
-			pDSPHEAPRes = pDSPHEAPRes->next;
-			tempStrLen2 += 2;
-			memmove(pBuf+tempStrLen, pTempBuf, tempStrLen2);
-			tempStrLen += tempStrLen2;
-			tempCount++;
-		}
-		tempCount = 1;
-		pDMMRes = pCtxt->pDMMList;
-		while (pDMMRes != NULL) {
-			GT_2trace(curTrace, GT_ENTER,
-					"DRV_ProcDisplayResourceInfo: #:%d "
-					" pCtxt->pDMMList->ulMpuAddr:%x\n",
-					tempCount,
-					pDMMRes->ulMpuAddr);
-			tempStrLen2 = sprintf((char *)pTempBuf,
-					 "DMM Resource Info: DMM # %d Mapped"
-					 " GPP Address: 0x%x, size: 0x%x\n",
-					 tempCount, (u32)pDMMRes->ulMpuAddr,
-					 (u32)pDMMRes->dmmSize);
-			pDMMRes = pDMMRes->next;
-			tempStrLen2 += 2;
-			memmove(pBuf+tempStrLen, pTempBuf, tempStrLen2);
-			tempStrLen += tempStrLen2;
-			tempCount++;
-		}
-		tempCount = 1;
-		pSTRMRes = pCtxt->pSTRMList;
-		while (pSTRMRes != NULL) {
-			GT_2trace(curTrace, GT_ENTER,
-				 "DRV_ProcDisplayResourceInfo: #:%d "
-				 "pCtxt->pSTRMList->hStream:%x\n", tempCount,
-				 pSTRMRes->hStream);
-			tempStrLen2 = sprintf((char *)pTempBuf,
-					     "Stream Resource info: STRM # %d "
-					     "Stream Handle: 0x%x \n",
-					     tempCount, (u32)pSTRMRes->hStream);
-			pSTRMRes = pSTRMRes->next;
-			tempStrLen2 += 2;
-			memmove(pBuf+tempStrLen, pTempBuf, tempStrLen2);
-			tempStrLen += tempStrLen2;
-			tempCount++;
-		}
-		pCtxt = pCtxt->next;
-	}
-	*pSize = tempStrLen;
-	status = PrintProcessInformation();
-	GT_0trace(curTrace, GT_ENTER, "*********************"
-		"DRV_ProcDisplayResourceInfo:**\n");
-	return status;
-}
-
-/*
- *  ======== PrintProcessInformation ========
- *  Purpose:
- *      This function prints the Process's information stored in
- *      the process context list. Some of the information that
- *      it displays is Process's state, Node, Stream, DMM, and
- *      Heap information.
- */
-static DSP_STATUS PrintProcessInformation(void)
-{
-	struct DRV_OBJECT *hDrvObject = NULL;
-	struct PROCESS_CONTEXT *pCtxtList = NULL;
-	struct NODE_RES_OBJECT *pNodeRes = NULL;
-	struct DMM_RES_OBJECT *pDMMRes = NULL;
-	struct STRM_RES_OBJECT *pSTRMRes = NULL;
-	struct DSPHEAP_RES_OBJECT *pDSPHEAPRes = NULL;
-	struct PROC_OBJECT *proc_obj_ptr;
-	DSP_STATUS status = DSP_SOK;
-	u32 tempCount;
-	u32  procID;
-
-	/* Get the Process context list */
-	CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	DRV_GetProcCtxtList(&pCtxtList, hDrvObject);
-	GT_0trace(curTrace, GT_4CLASS, "\n### Debug information"
-			" for DSP bridge ##\n");
-	GT_0trace(curTrace, GT_4CLASS, " \n ###The  processes"
-			" information is as follows ### \n") ;
-	GT_0trace(curTrace, GT_4CLASS, "  ====================="
-			"============ \n");
-	/* Go through the entries in the Process context list */
-	while (pCtxtList  != NULL) {
-		GT_1trace(curTrace, GT_4CLASS, "\nThe process"
-				" id is %d\n", pCtxtList->pid);
-		GT_0trace(curTrace, GT_4CLASS, " -------------------"
-				"---------\n");
-		if (pCtxtList->resState == PROC_RES_ALLOCATED) {
-			GT_0trace(curTrace, GT_4CLASS, " \nThe Process"
-					" is in Allocated state\n");
-		} else {
-			GT_0trace(curTrace, GT_4CLASS, "\nThe Process"
-					" is in DeAllocated state\n");
-		}
-
-		spin_lock(&pCtxtList->proc_list_lock);
-		list_for_each_entry(proc_obj_ptr, &pCtxtList->processor_list,
-				proc_object) {
-			PROC_GetProcessorId(proc_obj_ptr, &procID);
-			if (procID == DSP_UNIT) {
-				GT_0trace(curTrace, GT_4CLASS,
-					"\nProcess connected to"
-					" DSP Processor\n");
-			} else if (procID == IVA_UNIT) {
-				GT_0trace(curTrace, GT_4CLASS,
-					"\nProcess connected to"
-					" IVA Processor\n");
-			} else {
-				GT_0trace(curTrace, GT_7CLASS,
-					"\n***ERROR:Invalid Processor Id***\n");
-			}
-		}
-		spin_unlock(&pCtxtList->proc_list_lock);
-
-		pNodeRes = pCtxtList->pNodeList;
-		tempCount = 1;
-		while (pNodeRes != NULL) {
-			if (tempCount == 1)
-				GT_0trace(curTrace, GT_4CLASS,
-					"\n***The Nodes allocated by"
-					" this Process are***\n");
-			GT_2trace(curTrace, GT_4CLASS,
-					"Node # %d Node Handle hNode:0x%x\n",
-					tempCount, (u32)pNodeRes->hNode);
-			pNodeRes = pNodeRes->next;
-			tempCount++;
-		}
-		if (tempCount == 1)
-			GT_0trace(curTrace, GT_4CLASS,
-					"\n ***There are no Nodes"
-					" allocated by this Process***\n");
-		tempCount = 1;
-		pDSPHEAPRes = pCtxtList->pDSPHEAPList;
-		while (pDSPHEAPRes != NULL) {
-			if (tempCount == 1)
-				GT_0trace(curTrace, GT_4CLASS,
-						"\n***The Heaps allocated by"
-						" this Process are***\n");
-			GT_3trace(curTrace, GT_4CLASS,
-				"DSP Heap Resource Info: HEAP # %d "
-				"Mapped GPP Address:0x%x, Size: 0x%lx\n",
-				tempCount, (u32)pDSPHEAPRes->ulMpuAddr,
-				pDSPHEAPRes->heapSize);
-			pDSPHEAPRes = pDSPHEAPRes->next;
-			tempCount++;
-		}
-		if (tempCount == 1)
-			GT_0trace(curTrace, GT_4CLASS,
-				"\n ***There are no Heaps allocated"
-				" by this Process***\n");
-		tempCount = 1;
-		pDMMRes = pCtxtList->pDMMList;
-		while (pDMMRes != NULL) {
-			if (tempCount == 1)
-				GT_0trace(curTrace, GT_4CLASS,
-					"\n ***The DMM resources allocated by"
-					" this Process are***\n");
-			GT_3trace(curTrace, GT_4CLASS,
-				"DMM Resource Info: DMM # %d "
-				"Mapped GPP Address:0X%lx, Size: 0X%lx\n",
-				tempCount, pDMMRes->ulMpuAddr,
-				pDMMRes->dmmSize);
-			pDMMRes = pDMMRes->next;
-			tempCount++;
-		}
-		if (tempCount == 1)
-			GT_0trace(curTrace, GT_4CLASS,
-				"\n ***There are no DMM resources"
-				" allocated by this Process***\n");
-		tempCount = 1;
-		pSTRMRes = pCtxtList->pSTRMList;
-		while (pSTRMRes != NULL) {
-			if (tempCount == 1)
-				GT_0trace(curTrace, GT_4CLASS,
-					"\n***The Stream resources allocated by"
-					" this Process are***\n");
-			GT_2trace(curTrace, GT_4CLASS,
-				"Stream Resource info: STRM # %d"
-				"Stream Handle:0X%x\n",	tempCount,
-				(u32)pSTRMRes->hStream);
-			pSTRMRes = pSTRMRes->next;
-			tempCount++;
-		}
-		if (tempCount == 1)
-			GT_0trace(curTrace, GT_4CLASS,
-				"\n ***There are no Stream resources"
-				"allocated by this Process***\n");
-		pCtxtList = pCtxtList->next;
-	}
-	return status;
-}
-
 /* GPP PROCESS CLEANUP CODE END */
-#endif
 
 /*
  *  ======== = DRV_Create ======== =
@@ -1097,43 +607,48 @@ DSP_STATUS DRV_Create(OUT struct DRV_OBJ
 	MEM_AllocObject(pDRVObject, struct DRV_OBJECT, SIGNATURE);
 	if (pDRVObject) {
 		/* Create and Initialize List of device objects */
-		pDRVObject->devList = LST_Create();
+		pDRVObject->devList = MEM_Calloc(sizeof(struct LST_LIST),
+			MEM_NONPAGED);
 		if (pDRVObject->devList) {
 			/* Create and Initialize List of device Extension */
-			pDRVObject->devNodeString = LST_Create();
+			pDRVObject->devNodeString = MEM_Calloc(sizeof(struct
+				LST_LIST), MEM_NONPAGED);
 			if (!(pDRVObject->devNodeString)) {
 				status = DSP_EFAIL;
 				GT_0trace(curTrace, GT_7CLASS,
 					 "Failed to Create DRV_EXT list ");
-				MEM_FreeObject(pDRVObject);
+			} else {
+				INIT_LIST_HEAD(&pDRVObject->devNodeString->
+					head);
+				INIT_LIST_HEAD(&pDRVObject->devList->head);
 			}
 		} else {
-			status = DSP_EFAIL;
+			status = DSP_EMEMORY;
 			GT_0trace(curTrace, GT_7CLASS,
 				 "Failed to Create Dev List ");
-			MEM_FreeObject(pDRVObject);
 		}
 	} else {
-		status = DSP_EFAIL;
+		status = DSP_EMEMORY;
 		GT_0trace(curTrace, GT_7CLASS,
 			 "Failed to Allocate Memory for DRV Obj");
 	}
+	/* Store the DRV Object in the Registry */
+	if (DSP_SUCCEEDED(status))
+		status = CFG_SetObject((u32) pDRVObject, REG_DRV_OBJECT);
 	if (DSP_SUCCEEDED(status)) {
-		/* Store the DRV Object in the Registry */
-		if (DSP_SUCCEEDED
-		    (CFG_SetObject((u32) pDRVObject, REG_DRV_OBJECT))) {
-			GT_1trace(curTrace, GT_1CLASS,
-				 "DRV Obj Created pDrvObject 0x%x\n ",
-				 pDRVObject);
-			*phDRVObject = pDRVObject;
-		} else {
-			/* Free the DRV Object */
-			status = DSP_EFAIL;
-			MEM_Free(pDRVObject);
-			GT_0trace(curTrace, GT_7CLASS,
-				 "Failed to update the Registry with "
+		GT_1trace(curTrace, GT_1CLASS,
+			 "DRV Obj Created pDrvObject 0x%x\n ",
+			 pDRVObject);
+		*phDRVObject = pDRVObject;
+	} else {
+		MEM_Free(pDRVObject->devList);
+		MEM_Free(pDRVObject->devNodeString);
+		/* Free the DRV Object */
+		MEM_Free(pDRVObject);
+		GT_0trace(curTrace, GT_7CLASS,
+			 "Failed to update the Registry with "
 				 "DRV Object ");
-		}
+
 	}
 	GT_2trace(curTrace, GT_ENTER,
 		 "Exiting DRV_Create: phDRVObject: 0x%x\tstatus:"
@@ -1181,11 +696,11 @@ DSP_STATUS DRV_Destroy(struct DRV_OBJECT
 	 */
 	if (pDRVObject->devList) {
 		/* Could assert if the list is not empty  */
-		LST_Delete(pDRVObject->devList);
+		MEM_Free(pDRVObject->devList);
 	}
 	if (pDRVObject->devNodeString) {
 		/* Could assert if the list is not empty */
-		LST_Delete(pDRVObject->devNodeString);
+		MEM_Free(pDRVObject->devNodeString);
 	}
 	MEM_FreeObject(pDRVObject);
 	/* Update the DRV Object in Registry to be 0 */
@@ -1227,7 +742,6 @@ DSP_STATUS DRV_GetDevObject(u32 uIndex, 
 	}
 	if (pDevObject) {
 		*phDevObject = (struct DEV_OBJECT *) pDevObject;
-		status = DSP_SOK;
 	} else {
 		*phDevObject = NULL;
 		status = DSP_EFAIL;
@@ -1305,7 +819,7 @@ u32 DRV_GetNextDevObject(u32 hDevObject)
 		if ((pDrvObject->devList != NULL) &&
 		   !LST_IsEmpty(pDrvObject->devList)) {
 			dwNextDevObject = (u32)LST_Next(pDrvObject->devList,
-					  (struct LST_ELEM *)hDevObject);
+					  (struct list_head *)hDevObject);
 		}
 	}
 	return dwNextDevObject;
@@ -1332,7 +846,7 @@ u32 DRV_GetNextDevExtension(u32 hDevExte
 		   !LST_IsEmpty(pDrvObject->devNodeString)) {
 			dwDevExtension = (u32)LST_Next(pDrvObject->
 				devNodeString,
-				(struct LST_ELEM *)hDevExtension);
+				(struct list_head *)hDevExtension);
 		}
 	}
 
@@ -1367,7 +881,7 @@ DSP_STATUS DRV_Init(void)
  *      Insert a DevObject into the list of Manager object.
  */
 DSP_STATUS DRV_InsertDevObject(struct DRV_OBJECT *hDRVObject,
-			       struct DEV_OBJECT *hDevObject)
+				struct DEV_OBJECT *hDevObject)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct DRV_OBJECT *pDRVObject = (struct DRV_OBJECT *)hDRVObject;
@@ -1381,7 +895,7 @@ DSP_STATUS DRV_InsertDevObject(struct DR
 		 "Entering DRV_InsertProcObject hDRVObject "
 		 "0x%x\n, hDevObject 0x%x\n", hDRVObject, hDevObject);
 
-	LST_PutTail(pDRVObject->devList, (struct LST_ELEM *)hDevObject);
+	LST_PutTail(pDRVObject->devList, (struct list_head *)hDevObject);
 
 	GT_1trace(curTrace, GT_ENTER,
 		 "Exiting InsertDevObject status 0x%x\n", status);
@@ -1398,11 +912,11 @@ DSP_STATUS DRV_InsertDevObject(struct DR
  *      objects.
  */
 DSP_STATUS DRV_RemoveDevObject(struct DRV_OBJECT *hDRVObject,
-			       struct DEV_OBJECT *hDevObject)
+				struct DEV_OBJECT *hDevObject)
 {
 	DSP_STATUS status = DSP_EFAIL;
 	struct DRV_OBJECT *pDRVObject = (struct DRV_OBJECT *)hDRVObject;
-	struct LST_ELEM *pCurElem;
+	struct list_head *pCurElem;
 
 	DBC_Require(cRefs > 0);
 	DBC_Require(MEM_IsValidHandle(pDRVObject, SIGNATURE));
@@ -1426,7 +940,7 @@ DSP_STATUS DRV_RemoveDevObject(struct DR
 	}
 	/* Remove list if empty. */
 	if (LST_IsEmpty(pDRVObject->devList)) {
-		LST_Delete(pDRVObject->devList);
+		MEM_Free(pDRVObject->devList);
 		pDRVObject->devList = NULL;
 	}
 	DBC_Ensure((pDRVObject->devList == NULL) ||
@@ -1455,8 +969,9 @@ DSP_STATUS DRV_RequestResources(u32 dwCo
 	 *  it is freed in the Release resources. Update the driver object
 	 *  list.
 	 */
-	if (DSP_SUCCEEDED(CFG_GetObject((u32 *)&pDRVObject,
-	   REG_DRV_OBJECT))) {
+
+	status = CFG_GetObject((u32 *)&pDRVObject, REG_DRV_OBJECT);
+	if (DSP_SUCCEEDED(status)) {
 		pszdevNode = MEM_Calloc(sizeof(struct DRV_EXT), MEM_NONPAGED);
 		if (pszdevNode) {
 			LST_InitElem(&pszdevNode->link);
@@ -1466,21 +981,20 @@ DSP_STATUS DRV_RequestResources(u32 dwCo
 			/* Update the Driver Object List */
 			*pDevNodeString = (u32)pszdevNode->szString;
 			LST_PutTail(pDRVObject->devNodeString,
-				(struct LST_ELEM *)pszdevNode);
+					(struct list_head *)pszdevNode);
 		} else {
 			GT_0trace(curTrace, GT_7CLASS,
 				"Failed to Allocate Memory devNodeString ");
-			status = DSP_EFAIL;
+			status = DSP_EMEMORY;
 			*pDevNodeString = 0;
 		}
 	} else {
-		status = DSP_EFAIL;
 		GT_0trace(curTrace, GT_7CLASS,
 			 "Failed to get Driver Object from Registry");
 		*pDevNodeString = 0;
 	}
 
-       if (!(strcmp((char *) dwContext, "TIOMAP1510"))) {
+	if (!(strcmp((char *) dwContext, "TIOMAP1510"))) {
 		GT_0trace(curTrace, GT_1CLASS,
 			  " Allocating resources for UMA \n");
 		status = RequestBridgeResourcesDSP(dwContext, DRV_ASSIGN);
@@ -1513,7 +1027,7 @@ DSP_STATUS DRV_ReleaseResources(u32 dwCo
 
 	GT_0trace(curTrace, GT_ENTER, "Entering DRV_Release Resources\n");
 
-       if (!(strcmp((char *)((struct DRV_EXT *)dwContext)->szString,
+	if (!(strcmp((char *)((struct DRV_EXT *)dwContext)->szString,
 	   "TIOMAP1510"))) {
 		GT_0trace(curTrace, GT_1CLASS,
 			 " Releasing DSP-Bridge resources \n");
@@ -1522,10 +1036,9 @@ DSP_STATUS DRV_ReleaseResources(u32 dwCo
 		GT_0trace(curTrace, GT_1CLASS, " Unknown device\n");
 	}
 
-	if (DSP_SUCCEEDED(status)) {
+	if (DSP_FAILED(status))
 		GT_0trace(curTrace, GT_1CLASS,
 			 "Failed to relese bridge resources\n");
-	}
 
 	/*
 	 *  Irrespective of the status go ahead and clean it
@@ -1534,17 +1047,21 @@ DSP_STATUS DRV_ReleaseResources(u32 dwCo
 	for (pszdevNode = (struct DRV_EXT *)DRV_GetFirstDevExtension();
 	    pszdevNode != NULL; pszdevNode = (struct DRV_EXT *)
 	    DRV_GetNextDevExtension((u32)pszdevNode)) {
+		if (!pDRVObject->devNodeString) {
+			/* When this could happen? */
+			continue;
+		}
 		if ((u32)pszdevNode == dwContext) {
 			/* Found it */
 			/* Delete from the Driver object list */
 			LST_RemoveElem(pDRVObject->devNodeString,
-				      (struct LST_ELEM *)pszdevNode);
+				      (struct list_head *)pszdevNode);
 			MEM_Free((void *) pszdevNode);
 			break;
 		}
 		/* Delete the List if it is empty */
 		if (LST_IsEmpty(pDRVObject->devNodeString)) {
-			LST_Delete(pDRVObject->devNodeString);
+			MEM_Free(pDRVObject->devNodeString);
 			pDRVObject->devNodeString = NULL;
 		}
 	}
@@ -1574,20 +1091,20 @@ static DSP_STATUS RequestBridgeResources
 		/* Releasing resources by deleting the registry key  */
 		dwBuffSize = sizeof(struct CFG_HOSTRES);
 		pResources = MEM_Calloc(dwBuffSize, MEM_NONPAGED);
-		if (DSP_FAILED(REG_GetValue(NULL, (char *)driverExt->szString,
-		   CURRENTCONFIG, (u8 *)pResources, &dwBuffSize))) {
-			status = CFG_E_RESOURCENOTAVAIL;
-			GT_0trace(curTrace, GT_1CLASS,
-				 "REG_GetValue Failed \n");
-		} else {
-			GT_0trace(curTrace, GT_1CLASS,
-				 "REG_GetValue Succeeded \n");
-		}
-
 		if (pResources != NULL) {
+			if (DSP_FAILED(REG_GetValue(CURRENTCONFIG,
+					(u8 *)pResources, &dwBuffSize))) {
+				status = CFG_E_RESOURCENOTAVAIL;
+				GT_0trace(curTrace, GT_1CLASS,
+					 "REG_GetValue Failed \n");
+			} else {
+				GT_0trace(curTrace, GT_1CLASS,
+					 "REG_GetValue Succeeded \n");
+			}
+
 			dwBuffSize = sizeof(shm_size);
-			status = REG_GetValue(NULL, CURRENTCONFIG, SHMSIZE,
-				(u8 *)&shm_size, &dwBuffSize);
+			status = REG_GetValue(SHMSIZE, (u8 *)&shm_size,
+					      &dwBuffSize);
 			if (DSP_SUCCEEDED(status)) {
 				if ((pResources->dwMemBase[1]) &&
 				   (pResources->dwMemPhys[1])) {
@@ -1624,15 +1141,13 @@ static DSP_STATUS RequestBridgeResources
 				iounmap(pResources->dwDmmuBase);
 			if (pResources->dwPerBase)
 				iounmap(pResources->dwPerBase);
-                       if (pResources->dwPerPmBase)
-                               iounmap((void *)pResources->dwPerPmBase);
-                       if (pResources->dwCorePmBase)
-                               iounmap((void *)pResources->dwCorePmBase);
-			if (pResources->dwSysCtrlBase) {
+			if (pResources->dwPerPmBase)
+				iounmap((void *)pResources->dwPerPmBase);
+			if (pResources->dwCorePmBase)
+				iounmap((void *)pResources->dwCorePmBase);
+			if (pResources->dwSysCtrlBase)
 				iounmap(pResources->dwSysCtrlBase);
-				/* don't set pResources->dwSysCtrlBase to null
-				 * as it is used in BOARD_Stop */
-			}
+
 			pResources->dwPrmBase = NULL;
 			pResources->dwCmBase = NULL;
 			pResources->dwMboxBase = NULL;
@@ -1642,13 +1157,15 @@ static DSP_STATUS RequestBridgeResources
 			pResources->dwMemBase[4] = (u32) NULL;
 			pResources->dwWdTimerDspBase = NULL;
 			pResources->dwDmmuBase = NULL;
+			pResources->dwSysCtrlBase = NULL;
 
 			dwBuffSize = sizeof(struct CFG_HOSTRES);
-			status = REG_SetValue(NULL, (char *)driverExt->szString,
-				 CURRENTCONFIG, REG_BINARY, (u8 *)pResources,
+			status = REG_SetValue(CURRENTCONFIG, (u8 *)pResources,
 				 (u32)dwBuffSize);
 			/*  Set all the other entries to NULL */
 			MEM_Free(pResources);
+		} else {
+			status = DSP_EMEMORY;
 		}
 		GT_0trace(curTrace, GT_ENTER, " <- RequestBridgeResources \n");
 		return status;
@@ -1686,29 +1203,26 @@ static DSP_STATUS RequestBridgeResources
 		/* for 24xx base port is not mapping the mamory for DSP
 		 * internal memory TODO Do a ioremap here */
 		/* Second window is for DSP external memory shared with MPU */
+
+		/* for Linux, these are hard-coded values */
+		pResources->bIRQRegisters = 0;
+		pResources->bIRQAttrib = 0;
+		pResources->dwOffsetForMonitor = 0;
+		pResources->dwChnlOffset = 0;
+		/* CHNL_MAXCHANNELS */
+		pResources->dwNumChnls = CHNL_MAXCHANNELS;
+		pResources->dwChnlBufSize = 0x400;
+		dwBuffSize = sizeof(struct CFG_HOSTRES);
+		status = REG_SetValue(CURRENTCONFIG, (u8 *)pResources,
+						sizeof(struct CFG_HOSTRES));
 		if (DSP_SUCCEEDED(status)) {
-			/* for Linux, these are hard-coded values */
-			pResources->bIRQRegisters = 0;
-			pResources->bIRQAttrib = 0;
-			pResources->dwOffsetForMonitor = 0;
-			pResources->dwChnlOffset = 0;
-			/* CHNL_MAXCHANNELS */
-			pResources->dwNumChnls = CHNL_MAXCHANNELS;
-			pResources->dwChnlBufSize = 0x400;
-			dwBuffSize = sizeof(struct CFG_HOSTRES);
-			status = REG_SetValue(NULL, (char *) dwContext,
-					     CURRENTCONFIG, REG_BINARY,
-					     (u8 *)pResources,
-					     sizeof(struct CFG_HOSTRES));
-			if (DSP_SUCCEEDED(status)) {
-				GT_0trace(curTrace, GT_1CLASS,
-					 " Successfully set the registry "
-					 "value for CURRENTCONFIG\n");
-			} else {
-				GT_0trace(curTrace, GT_7CLASS,
-					 " Failed to set the registry "
-					 "value for CURRENTCONFIG\n");
-			}
+			GT_0trace(curTrace, GT_1CLASS,
+				 " Successfully set the registry "
+				 "value for CURRENTCONFIG\n");
+		} else {
+			GT_0trace(curTrace, GT_7CLASS,
+				 " Failed to set the registry "
+				 "value for CURRENTCONFIG\n");
 		}
 		MEM_Free(pResources);
 	}
@@ -1760,10 +1274,10 @@ static DSP_STATUS RequestBridgeResources
 							OMAP_DSP_MEM3_SIZE);
 		pResources->dwPerBase = ioremap(OMAP_PER_CM_BASE,
 							OMAP_PER_CM_SIZE);
-               pResources->dwPerPmBase = (u32)ioremap(OMAP_PER_PRM_BASE,
-                                                       OMAP_PER_PRM_SIZE);
-               pResources->dwCorePmBase = (u32)ioremap(OMAP_CORE_PRM_BASE,
-                                                       OMAP_CORE_PRM_SIZE);
+		pResources->dwPerPmBase = (u32)ioremap(OMAP_PER_PRM_BASE,
+							OMAP_PER_PRM_SIZE);
+		pResources->dwCorePmBase = (u32)ioremap(OMAP_CORE_PRM_BASE,
+							OMAP_CORE_PRM_SIZE);
 		pResources->dwDmmuBase = ioremap(OMAP_DMMU_BASE,
 							OMAP_DMMU_SIZE);
 		pResources->dwWdTimerDspBase = NULL;
@@ -1789,8 +1303,7 @@ static DSP_STATUS RequestBridgeResources
 		GT_1trace(curTrace, GT_2CLASS, "dwDmmuBase 0x%x\n",
 						pResources->dwDmmuBase);
 		dwBuffSize = sizeof(shm_size);
-		status = REG_GetValue(NULL, CURRENTCONFIG, SHMSIZE,
-				     (u8 *)&shm_size, &dwBuffSize);
+		status = REG_GetValue(SHMSIZE, (u8 *)&shm_size, &dwBuffSize);
 		if (DSP_SUCCEEDED(status)) {
 			/* Allocate Physically contiguous,
 			 * non-cacheable  memory */
@@ -1822,9 +1335,7 @@ static DSP_STATUS RequestBridgeResources
 			pResources->dwNumChnls = CHNL_MAXCHANNELS;
 			pResources->dwChnlBufSize = 0x400;
 			dwBuffSize = sizeof(struct CFG_HOSTRES);
-			status = REG_SetValue(NULL, (char *)dwContext,
-					     CURRENTCONFIG, REG_BINARY,
-					     (u8 *)pResources,
+			status = REG_SetValue(CURRENTCONFIG, (u8 *)pResources,
 					     sizeof(struct CFG_HOSTRES));
 			if (DSP_SUCCEEDED(status)) {
 				GT_0trace(curTrace, GT_1CLASS,
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/drv_interface.c kernel-power-2.6.28/drivers/dsp/bridge/rmgr/drv_interface.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/drv_interface.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/rmgr/drv_interface.c	2011-05-06 15:29:59.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge driver interface.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,36 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== linux_driver.c ========
- *  Description:
- *      DSP/BIOS Bridge driver interface.
- *
- *  Public Functions:
- *      driver_init
- *      driver_exit
- *      driver_open
- *      driver_release
- *      driver_ioctl
- *      driver_mmap
- *
- *! Revision History
- *! ================
- *! 21-Apr-2004 map   Deprecated use of MODULE_PARM for kernel versions
- *!		   greater than 2.5, use module_param.
- *! 08-Mar-2004 sb    Added the dsp_debug argument, which keeps the DSP in self
- *!		   loop after image load and waits in a loop for DSP to start
- *! 16-Feb-2004 vp    Deprecated the usage of MOD_INC_USE_COUNT and
- *! 						MOD_DEC_USE_COUNT
- *!		   for kernel versions greater than 2.5
- *! 20-May-2003 vp    Added unregister functions for the DPM.
- *! 24-Mar-2003 sb    Pass pid instead of driverContext to DSP_Close
- *! 24-Mar-2003 vp    Added Power Management support.
- *! 21-Mar-2003 sb    Configure SHM size using insmod argument shm_size
- *! 10-Feb-2003 vp    Updated based on code review comments
- *! 18-Oct-2002 sb    Created initial version
- */
-
 /*  ----------------------------------- Host OS */
 
 #include <dspbridge/host_os.h>
@@ -59,8 +31,6 @@
 #include <linux/moduleparam.h>
 #include <linux/cdev.h>
 
-#include <mach/board-3430sdp.h>
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
@@ -74,13 +44,11 @@
 #include <dspbridge/services.h>
 #include <dspbridge/sync.h>
 #include <dspbridge/reg.h>
-#include <dspbridge/csl.h>
 
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/wcdioctl.h>
 #include <dspbridge/_dcd.h>
 #include <dspbridge/dspdrv.h>
-#include <dspbridge/dbreg.h>
 
 /*  ----------------------------------- Resource Manager */
 #include <dspbridge/pwr.h>
@@ -88,30 +56,28 @@
 /*  ----------------------------------- This */
 #include <drv_interface.h>
 
-#ifndef RES_CLEANUP_DISABLE
 #include <dspbridge/cfg.h>
 #include <dspbridge/resourcecleanup.h>
 #include <dspbridge/chnl.h>
 #include <dspbridge/proc.h>
-#include <dspbridge/cfg.h>
 #include <dspbridge/dev.h>
 #include <dspbridge/drvdefs.h>
 #include <dspbridge/drv.h>
-#include <dspbridge/dbreg.h>
-#endif
 
-#include <mach/omap-pm.h>
+#ifdef CONFIG_BRIDGE_DVFS
 #include <mach-omap2/omap3-opp.h>
+#endif
 
 #define BRIDGE_NAME "C6410"
 /*  ----------------------------------- Globals */
 #define DRIVER_NAME  "DspBridge"
-#define DRIVER_MAJOR 0		/* Linux assigns our Major device number */
-#define DRIVER_MINOR 0		/* Linux assigns our Major device number */
+#define DSPBRIDGE_VERSION	"0.1"
 s32 dsp_debug;
 
 struct platform_device *omap_dspbridge_dev;
 
+/* This is a test variable used by Bridge to test different sleep states */
+s32 dsp_test_sleepstate;
 struct bridge_dev {
 	struct cdev cdev;
 };
@@ -124,19 +90,17 @@ static u32 driverContext;
 #ifdef CONFIG_BRIDGE_DEBUG
 static char *GT_str;
 #endif /* CONFIG_BRIDGE_DEBUG */
-static s32 driver_major = DRIVER_MAJOR;
-static s32 driver_minor = DRIVER_MINOR;
+static s32 driver_major;
+static s32 driver_minor;
 static char *base_img;
 char *iva_img;
-static char *num_procs = "C55=1";
-static s32 shm_size = 0x400000;	/* 4 MB */
+static s32 _shm_size = 0x500000;	/* 5 MB */
+static s32 shm_size = 0;
+
 static u32 phys_mempool_base;
 static u32 phys_mempool_size;
 static int tc_wordswapon;	/* Default value is always false */
 
-/* Minimum ACTIVE VDD1 OPP level for reliable DSP operation */
-unsigned short min_active_opp = 3;
-
 #ifdef CONFIG_PM
 struct omap34xx_bridge_suspend_data {
 	int suspended;
@@ -155,10 +119,9 @@ static int omap34xxbridge_suspend_lockou
 	}
 	return 0;
 }
-
 #endif
 
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 module_param(GT_str, charp, 0);
 MODULE_PARM_DESC(GT_str, "GT string, default = NULL");
 
@@ -166,11 +129,8 @@ module_param(dsp_debug, int, 0);
 MODULE_PARM_DESC(dsp_debug, "Wait after loading DSP image. default = false");
 #endif
 
-module_param(driver_major, int, 0);	/* Driver's major number */
-MODULE_PARM_DESC(driver_major, "Major device number, default = 0 (auto)");
-
-module_param(driver_minor, int, 0);	/* Driver's major number */
-MODULE_PARM_DESC(driver_minor, "Minor device number, default = 0 (auto)");
+module_param(dsp_test_sleepstate, int, 0);
+MODULE_PARM_DESC(dsp_test_sleepstate, "DSP Sleep state = 0");
 
 module_param(base_img, charp, 0);
 MODULE_PARM_DESC(base_img, "DSP base image, default = NULL");
@@ -188,11 +148,9 @@ MODULE_PARM_DESC(phys_mempool_size,
 module_param(tc_wordswapon, int, 0);
 MODULE_PARM_DESC(tc_wordswapon, "TC Word Swap Option. default = 0");
 
-module_param(min_active_opp, ushort, S_IRUSR | S_IWUSR);
-MODULE_PARM_DESC(min_active_opp, "Minimum ACTIVE VDD1 OPP Level, default = 3");
-
 MODULE_AUTHOR("Texas Instruments");
 MODULE_LICENSE("GPL");
+MODULE_VERSION(DSPBRIDGE_VERSION);
 
 static char *driver_name = DRIVER_NAME;
 
@@ -200,7 +158,7 @@ static char *driver_name = DRIVER_NAME;
 static struct GT_Mask driverTrace;
 #endif /* CONFIG_BRIDGE_DEBUG */
 
-static struct file_operations bridge_fops = {
+static const struct file_operations bridge_fops = {
 	.open		= bridge_open,
 	.release	= bridge_release,
 	.unlocked_ioctl	= bridge_ioctl,
@@ -278,38 +236,29 @@ static int __devinit omap34xx_bridge_pro
 	omap_dspbridge_dev = pdev;
 
 	/* use 2.6 device model */
-	if (driver_major) {
-		dev = MKDEV(driver_major, driver_minor);
-		result = register_chrdev_region(dev, 1, driver_name);
-	} else {
-		result = alloc_chrdev_region(&dev, driver_minor, 1,
-					    driver_name);
-		driver_major = MAJOR(dev);
-	}
-
+	result = alloc_chrdev_region(&dev, driver_minor, 1, driver_name);
 	if (result < 0) {
 		GT_1trace(driverTrace, GT_7CLASS, "bridge_init: "
 				"Can't get Major %d \n", driver_major);
-		return result;
+		goto err1;
 	}
 
-	bridge_device = kmalloc(sizeof(struct bridge_dev), GFP_KERNEL);
+	driver_major = MAJOR(dev);
+
+	bridge_device = kzalloc(sizeof(struct bridge_dev), GFP_KERNEL);
 	if (!bridge_device) {
 		result = -ENOMEM;
-		unregister_chrdev_region(dev, 1);
-		return result;
+		goto err2;
 	}
-	memset(bridge_device, 0, sizeof(struct bridge_dev));
 	cdev_init(&bridge_device->cdev, &bridge_fops);
 	bridge_device->cdev.owner = THIS_MODULE;
 	bridge_device->cdev.ops = &bridge_fops;
 
 	status = cdev_add(&bridge_device->cdev, dev, 1);
-
 	if (status) {
 		GT_0trace(driverTrace, GT_7CLASS,
 				"Failed to add the bridge device \n");
-		return status;
+		goto err3;
 	}
 
 	/* udev support */
@@ -325,7 +274,7 @@ static int __devinit omap34xx_bridge_pro
 	GT_init();
 	GT_create(&driverTrace, "LD");
 
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 	if (GT_str)
 		GT_set(GT_str);
 #elif defined(DDSP_DEBUG_PRODUCT) && GT_TRACE
@@ -349,22 +298,17 @@ static int __devinit omap34xx_bridge_pro
 
 	if (base_img) {
 		temp = true;
-		REG_SetValue(NULL, NULL, AUTOSTART, REG_DWORD, (u8 *)&temp,
-			    sizeof(temp));
-		REG_SetValue(NULL, NULL, DEFEXEC, REG_SZ, (u8 *)base_img,
-						strlen(base_img) + 1);
+		REG_SetValue(AUTOSTART, (u8 *)&temp, sizeof(temp));
+		REG_SetValue(DEFEXEC, (u8 *)base_img, strlen(base_img) + 1);
 	} else {
 		temp = false;
-		REG_SetValue(NULL, NULL, AUTOSTART, REG_DWORD, (u8 *)&temp,
-			    sizeof(temp));
-		REG_SetValue(NULL, NULL, DEFEXEC, REG_SZ, (u8 *) "\0", (u32)2);
-	}
-	REG_SetValue(NULL, NULL, NUMPROCS, REG_SZ, (u8 *) num_procs,
-						strlen(num_procs) + 1);
-
-	if (shm_size >= 0x10000) {	/* 64 KB */
-		initStatus = REG_SetValue(NULL, NULL, SHMSIZE, REG_DWORD,
-					  (u8 *)&shm_size, sizeof(shm_size));
+		REG_SetValue(AUTOSTART, (u8 *)&temp, sizeof(temp));
+		REG_SetValue(DEFEXEC, (u8 *) "\0", (u32)2);
+	}
+
+	if (_shm_size >= 0x10000) {	/* 64 KB */
+		initStatus = REG_SetValue(SHMSIZE, (u8 *)&_shm_size,
+					  sizeof(_shm_size));
 	} else {
 		initStatus = DSP_EINVALIDARG;
 		status = -1;
@@ -372,38 +316,27 @@ static int __devinit omap34xx_bridge_pro
 			  "SHM size must be at least 64 KB\n");
 	}
 	GT_1trace(driverTrace, GT_7CLASS,
-		 "requested shm_size = 0x%x\n", shm_size);
+		 "requested shm_size = 0x%x\n", _shm_size);
 
 	if (pdata->phys_mempool_base && pdata->phys_mempool_size) {
 		phys_mempool_base = pdata->phys_mempool_base;
 		phys_mempool_size = pdata->phys_mempool_size;
 	}
 
-	if (phys_mempool_base > 0x0) {
-		initStatus = REG_SetValue(NULL, NULL, PHYSMEMPOOLBASE,
-					 REG_DWORD, (u8 *)&phys_mempool_base,
-					 sizeof(phys_mempool_base));
-	}
 	GT_1trace(driverTrace, GT_7CLASS, "phys_mempool_base = 0x%x \n",
 		 phys_mempool_base);
 
-	if (phys_mempool_size > 0x0) {
-		initStatus = REG_SetValue(NULL, NULL, PHYSMEMPOOLSIZE,
-					 REG_DWORD, (u8 *)&phys_mempool_size,
-					 sizeof(phys_mempool_size));
-	}
 	GT_1trace(driverTrace, GT_7CLASS, "phys_mempool_size = 0x%x\n",
 		 phys_mempool_base);
 	if ((phys_mempool_base > 0x0) && (phys_mempool_size > 0x0))
 		MEM_ExtPhysPoolInit(phys_mempool_base, phys_mempool_size);
 	if (tc_wordswapon) {
 		GT_0trace(driverTrace, GT_7CLASS, "TC Word Swap is enabled\n");
-		REG_SetValue(NULL, NULL, TCWORDSWAP, REG_DWORD,
-			    (u8 *)&tc_wordswapon, sizeof(tc_wordswapon));
+		REG_SetValue(TCWORDSWAP, (u8 *)&tc_wordswapon,
+			    sizeof(tc_wordswapon));
 	} else {
 		GT_0trace(driverTrace, GT_7CLASS, "TC Word Swap is disabled\n");
-		REG_SetValue(NULL, NULL, TCWORDSWAP,
-			    REG_DWORD, (u8 *)&tc_wordswapon,
+		REG_SetValue(TCWORDSWAP, (u8 *)&tc_wordswapon,
 			    sizeof(tc_wordswapon));
 	}
 	if (DSP_SUCCEEDED(initStatus)) {
@@ -426,13 +359,6 @@ static int __devinit omap34xx_bridge_pro
 			GT_0trace(driverTrace, GT_7CLASS,
 			"clk_notifier_register FAIL for iva2_ck \n");
 		}
-
-		/*
-		 * When Smartreflex is ON, DSP requires at least OPP level 3
-		 * to operate reliably. So boost lower OPP levels to OPP3.
-		 */
-		if (pdata->dsp_set_min_opp)
-			(*pdata->dsp_set_min_opp)(min_active_opp);
 #endif
 		driverContext = DSP_Init(&initStatus);
 		if (DSP_FAILED(initStatus)) {
@@ -448,7 +374,17 @@ static int __devinit omap34xx_bridge_pro
 	DBC_Assert(status == 0);
 	DBC_Assert(DSP_SUCCEEDED(initStatus));
 	GT_0trace(driverTrace, GT_ENTER, " <- driver_init\n");
-	return status;
+
+	return 0;
+
+err3:
+	kfree(bridge_device);
+
+err2:
+	unregister_chrdev_region(dev, 1);
+
+err1:
+	return result;
 }
 
 static int __devexit omap34xx_bridge_remove(struct platform_device *pdev)
@@ -456,10 +392,7 @@ static int __devexit omap34xx_bridge_rem
 	dev_t devno;
 	bool ret;
 	DSP_STATUS dsp_status = DSP_SOK;
-	HANDLE	     hDrvObject = NULL;
-	struct PROCESS_CONTEXT	*pTmp = NULL;
-	struct PROCESS_CONTEXT    *pCtxtclosed = NULL;
-	struct PROC_OBJECT *proc_obj_ptr, *temp;
+	HANDLE hDrvObject = NULL;
 
 	GT_0trace(driverTrace, GT_ENTER, "-> driver_exit\n");
 
@@ -477,21 +410,6 @@ static int __devexit omap34xx_bridge_rem
 	}
 #endif /* #ifdef CONFIG_BRIDGE_DVFS */
 
-	DRV_GetProcCtxtList(&pCtxtclosed, (struct DRV_OBJECT *)hDrvObject);
-	while (pCtxtclosed != NULL) {
-		GT_1trace(driverTrace, GT_5CLASS, "***Cleanup of "
-			 "process***%d\n", pCtxtclosed->pid);
-		DRV_RemoveAllResources(pCtxtclosed);
-		list_for_each_entry_safe(proc_obj_ptr, temp,
-				&pCtxtclosed->processor_list, proc_object) {
-			PROC_Detach(proc_obj_ptr, pCtxtclosed);
-		}
-		pTmp = pCtxtclosed->next;
-		DRV_RemoveProcContext((struct DRV_OBJECT *)hDrvObject,
-				pCtxtclosed);
-		pCtxtclosed = pTmp;
-	}
-
 	if (driverContext) {
 		/* Put the DSP in reset state */
 		ret = DSP_Deinit(driverContext);
@@ -499,10 +417,14 @@ static int __devexit omap34xx_bridge_rem
 		DBC_Assert(ret == true);
 	}
 
+#ifdef CONFIG_BRIDGE_DVFS
 	clk_put(clk_handle);
 	clk_handle = NULL;
+#endif /* #ifdef CONFIG_BRIDGE_DVFS */
 
 func_cont:
+	MEM_ExtPhysPoolRelease();
+
 	SERVICES_Exit();
 	GT_exit();
 
@@ -580,27 +502,22 @@ static void __exit bridge_exit(void)
 static int bridge_open(struct inode *ip, struct file *filp)
 {
 	int status = 0;
-	DSP_STATUS dsp_status;
-	HANDLE hDrvObject;
 	struct PROCESS_CONTEXT *pr_ctxt = NULL;
 
 	GT_0trace(driverTrace, GT_ENTER, "-> bridge_open\n");
 
-	dsp_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	if (DSP_SUCCEEDED(dsp_status)) {
-		/*
-		 * Allocate a new process context and insert it into global
-		 * process context list.
-		 */
-		DRV_InsertProcContext(hDrvObject, &pr_ctxt);
-		if (pr_ctxt) {
-			DRV_ProcUpdatestate(pr_ctxt, PROC_RES_ALLOCATED);
-			DRV_ProcSetPID(pr_ctxt, current->tgid);
-		} else {
-			status = -ENOMEM;
-		}
+	/*
+	 * Allocate a new process context and insert it into global
+	 * process context list.
+	 */
+	pr_ctxt = MEM_Calloc(sizeof(struct PROCESS_CONTEXT), MEM_PAGED);
+	if (pr_ctxt) {
+		pr_ctxt->resState = PROC_RES_ALLOCATED;
+		mutex_init(&pr_ctxt->dmm_mutex);
+		mutex_init(&pr_ctxt->node_mutex);
+		mutex_init(&pr_ctxt->strm_mutex);
 	} else {
-		status = -EIO;
+		status = -ENOMEM;
 	}
 
 	filp->private_data = pr_ctxt;
@@ -616,34 +533,25 @@ static int bridge_open(struct inode *ip,
 static int bridge_release(struct inode *ip, struct file *filp)
 {
 	int status = 0;
-	DSP_STATUS dsp_status;
-	HANDLE hDrvObject;
 	struct PROCESS_CONTEXT *pr_ctxt;
-	struct PROC_OBJECT *proc_obj_ptr, *temp;
 
 	GT_0trace(driverTrace, GT_ENTER, "-> bridge_release\n");
 
 	if (!filp->private_data) {
 		status = -EIO;
-	} else {
-		pr_ctxt = filp->private_data;
-		dsp_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-		if (DSP_SUCCEEDED(dsp_status)) {
-			flush_signals(current);
-			DRV_RemoveAllResources(pr_ctxt);
-			list_for_each_entry_safe(proc_obj_ptr, temp,
-					&pr_ctxt->processor_list,
-					proc_object) {
-				PROC_Detach(proc_obj_ptr, pr_ctxt);
-			}
-			DRV_RemoveProcContext((struct DRV_OBJECT *)hDrvObject,
-					pr_ctxt);
-		} else {
-			status = -EIO;
-		}
-		filp->private_data = NULL;
+		goto err;
 	}
 
+	pr_ctxt = filp->private_data;
+	flush_signals(current);
+	DRV_RemoveAllResources(pr_ctxt);
+	if (pr_ctxt->hProcessor)
+		PROC_Detach(pr_ctxt);
+	MEM_Free(pr_ctxt);
+
+	filp->private_data = NULL;
+
+err:
 	GT_0trace(driverTrace, GT_ENTER, "<- bridge_release\n");
 	return status;
 }
@@ -665,13 +573,15 @@ static long bridge_ioctl(struct file *fi
 
 	GT_0trace(driverTrace, GT_ENTER, " -> driver_ioctl\n");
 
-	/* Deduct one for the CMD_BASE. */
-	code = (code - 1);
+	if (!filp->private_data) {
+		status = -EIO;
+		goto err;
+	}
 
 	status = copy_from_user(&pBufIn, (union Trapped_Args *)args,
 				sizeof(union Trapped_Args));
 
-	if (status >= 0) {
+	if (!status) {
 		status = WCD_CallDevIOCtl(code, &pBufIn, &retval,
 				filp->private_data);
 
@@ -685,8 +595,8 @@ static long bridge_ioctl(struct file *fi
 
 	}
 
+err:
 	GT_0trace(driverTrace, GT_ENTER, " <- driver_ioctl\n");
-
 	return status;
 }
 
@@ -716,22 +626,18 @@ static int bridge_mmap(struct file *filp
 	return status;
 }
 
-#ifndef RES_CLEANUP_DISABLE
 /* To remove all process resources before removing the process from the
  * process context list*/
 DSP_STATUS DRV_RemoveAllResources(HANDLE hPCtxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
-	if (pCtxt != NULL) {
-		DRV_RemoveAllSTRMResElements(pCtxt);
-		DRV_RemoveAllNodeResElements(pCtxt);
-		DRV_RemoveAllDMMResElements(pCtxt);
-		DRV_ProcUpdatestate(pCtxt, PROC_RES_FREED);
-	}
+	DRV_RemoveAllSTRMResElements(pCtxt);
+	DRV_RemoveAllNodeResElements(pCtxt);
+	DRV_RemoveAllDMMResElements(pCtxt);
+	pCtxt->resState = PROC_RES_FREED;
 	return status;
 }
-#endif
 
 /* Bridge driver initialization and de-initialization functions */
 module_init(bridge_init);
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/drv_interface.h kernel-power-2.6.28/drivers/dsp/bridge/rmgr/drv_interface.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/drv_interface.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/rmgr/drv_interface.h	2011-05-02 22:36:50.000000000 +0100
@@ -14,18 +14,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== drv_interface.h ========
- *
- *! Revision History
- *! ================
- *! 24-Mar-2003 vp  Added hooks for Power Management Test
- *! 18-Feb-2003 vp  Code review updates
- *! 18-Oct-2002 sb  Created initial version
-
- */
-
 #ifndef	_DRV_INTERFACE_H_
 #define _DRV_INTERFACE_H_
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/dspdrv.c kernel-power-2.6.28/drivers/dsp/bridge/rmgr/dspdrv.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/dspdrv.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/rmgr/dspdrv.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Interface to allocate and free bridge resources.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,83 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dspdrv.c ========
- *  Description:
- *      Interface to allocate and free bridge resources.
- *
- *! Revision History
- *! ================
- *! 12-Apr-2004 hp: Compile IVA only for 24xx.
- *! 09-Feb-2004 vp: Updated to support IVA.
- *! 10-Feb-2003 vp: Code review updates.
- *! 18-oct-2002 vp: Ported to the Linux platform.
- *! 03-Mar-2002 rr: DSP_Deinit bug fixed (gets the Mgrhandle from registry
- *!		            before calling MGR_Destroy.
- *! 11-Jul-2001 jeh Moved MGR_Create() from DSP_Init() to DEV_StartDevice().
- *! 02-Apr-2001 rr: WCD_InitComplete2 return value is not checked thus
- *!                 sllowing the class driver to load irrespective of
- *!                 the image load.
- *! 30-Oct-2000 kc: Made changes w.r.t. usage of REG_SetValue.
- *! 05-Oct-2000 rr: WCD_InitComplete2 return value checked for RM.
- *!                 Failure in WCD_InitComplete2 will cause the
- *!                 DSP_Init to fail.
- *! 12-Aug-2000 kc: Changed REG_EnumValue to REG_EnumKey.
- *! 07-Aug-2000 rr: MGR_Create does the job of loading the DCD Dll.
- *! 26-Jul-2000 rr: Driver Object holds the DevNodeStrings for each
- *!                 DevObjects. Static variables removed. Returns
- *!                 the Driver Object in DSP_Init.
- *! 17-Jul-2000 rr: Driver Object is created in DSP_Init and that holds
- *!                 the list of Device objects.
- *! 07-Jul-2000 rr: RM implementaion started.
- *! 24-May-2000 ag: Cleaned up debug msgs.
- *! 02-May-2000 rr: DSP_Open returns GetCallerProcess as dwOpenContext.
- *! 03-Feb-2000 rr: GT Changes.
- *! 28-Jan-2000 rr: Code Cleaned up.Type void changed to void.
- *!                 DSP_Deinit checks return values.dwCode in
- *!                 DSP_IO_CONTROL is decoded(not hard coded)
- *! 27-Jan-2000 rr: REG_EnumValue Used .EnumerateKey fxn removed.
- *! 13-Jan-2000 rr: CFG_GetPrivateDword renamed to CFG_GetDevObject.
- *! 29-Dec-1999 rr: Code Cleaned up
- *! 09-Dec-1999 rr: EnumerateKey changed for retail build.
- *! 06-Dec-1999 rr: ArrayofInstalledNode, index and  ArrayofInstalledDev
- *!                 is Global.DevObject stores this pointer as hDevNode.
- *! 02-Dec-1999 rr: DBG_SetGT and RetailMSG conditionally included.
- *!                 Comments changed.Deinit handled.Code cleaned up.
- *!                 DSP_IOControl, Close, Deinit returns bool values.
- *!                 Calls WCD_InitComplete2 for Board AutoStart.
- *! 29-Nov-1999 rr: DSP_IOControl returns the result through pBufOut.
- *!                 Global Arrays keeps track of installed devices.
- *! 19-Nov-1999 rr: DSP_Init handles multiple drivers.
- *! 12-Nov-1999 rr: GetDriverKey and EnumerateKey functions added.
- *!                 for multiple mini driver support.PCCARD flag
- *!                 checking to include PCMCIA related stuff.
- *! 25-Oct-1999 rr: GT_Init is called within the Process Attach.
- *!                 return value initalized to S_OK upfront in the
- *!                 Process Attach.
- *! 15-Oct-1999 rr: DSP_DeInit handles the return values
- *! 05-Oct-1999 rr: All the PCMCIA related functions are now in PCCARD.c
- *!                 DRV_Request Resources is used instead of the
- *!                 RegisterMiniDriver as it sounds close to what we are doing.
- *! 24-Sep-1999 rr: DRV_RegisterMiniDriver is being called from here. Only
- *!                 neccessaryPCMCIA fxns are here. Soon they will move out
- *!                  either to a seperate file for bus specific inits.
- *! 10-Sep-1999 rr: GT Enabled. Considerably changed the  driver structure as
- *!                 - This is the Class driver. After successfully initialized
- *!                   the Class driver will attempt to load the Mini driver.
- *!                 - Need to seperate the PCMCIA stuff based on bus type.
- *!                 - Changed the name of the file to wcdce.c
- *!                 - Made the Media Handle as Global again
- *!
- *! 19-Aug-1999 rr: Removed the Global hbhMediaHandle. Included the MemTest.
- *!                 Modified the DSP_Init, now three windows are opened.
- *!                 Split the driver into PDD so that hardware dependent
- *!                 functions will reside in PDD.
- *! 16-Jul-1999 ag  Adapted from rkw's CAC Bullet card driver.
- *!
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -105,7 +30,6 @@
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/cfg.h>
-#include <dspbridge/csl.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/reg.h>
 
@@ -117,9 +41,6 @@
 /*  ----------------------------------- Resource Manager */
 #include <dspbridge/mgr.h>
 
-/*  ----------------------------------- Others */
-#include <dspbridge/dbreg.h>
-
 /*  ----------------------------------- This */
 #include <dspbridge/dspdrv.h>
 
@@ -135,7 +56,6 @@ u32 DSP_Init(OUT u32 *initStatus)
 	char devNode[MAXREGPATHLENGTH] = "TIOMAP1510";
 	DSP_STATUS status = DSP_EFAIL;
 	struct DRV_OBJECT *drvObject = NULL;
-	u32 index = 0;
 	u32 deviceNode;
 	u32 deviceNodeString;
 
@@ -143,11 +63,12 @@ u32 DSP_Init(OUT u32 *initStatus)
 
 	GT_0trace(curTrace, GT_ENTER, "Entering DSP_Init \r\n");
 
-	if (DSP_FAILED(WCD_Init())) {
+	if (!WCD_Init()) {
 		GT_0trace(curTrace, GT_7CLASS, "DSP_Init Failed \n");
 		goto func_cont;
 	}			/* End WCD_Exit */
-	if (DSP_FAILED(DRV_Create(&drvObject))) {
+	status = DRV_Create(&drvObject);
+	if (DSP_FAILED(status)) {
 		GT_0trace(curTrace, GT_7CLASS, "DSP_Init:DRV_Create Failed \n");
 		WCD_Exit();
 		goto func_cont;
@@ -155,29 +76,27 @@ u32 DSP_Init(OUT u32 *initStatus)
 	GT_0trace(curTrace, GT_5CLASS, "DSP_Init:DRV Created \r\n");
 
 	/* Request Resources */
-	if (DSP_SUCCEEDED(DRV_RequestResources((u32)&devNode,
-	   &deviceNodeString))) {
+	status = DRV_RequestResources((u32)&devNode, &deviceNodeString);
+	if (DSP_SUCCEEDED(status)) {
 		/* Attempt to Start the Device */
-		if (DSP_SUCCEEDED(DEV_StartDevice(
-		   (struct CFG_DEVNODE *)deviceNodeString))) {
+		status = DEV_StartDevice((struct CFG_DEVNODE *)
+							deviceNodeString);
+		if (DSP_SUCCEEDED(status)) {
 			/* Retreive the DevObject from the Registry */
-			GT_2trace(curTrace, GT_1CLASS,
-				 "DSP_Init Succeeded for Device1:"
-				 "%d: value: %x\n", index, deviceNodeString);
-			status = DSP_SOK;
+			GT_1trace(curTrace, GT_1CLASS,
+				 "DSP_Init Succeeded for Device1 value: %x\n",
+				 deviceNodeString);
 		} else {
 			GT_0trace(curTrace, GT_7CLASS,
 				 "DSP_Init:DEV_StartDevice Failed\n");
 			(void)DRV_ReleaseResources
 				((u32) deviceNodeString, drvObject);
-			status = DSP_EFAIL;
 		}
 	} else {
 		GT_0trace(curTrace, GT_7CLASS,
 			 "DSP_Init:DRV_RequestResources Failed \r\n");
 		status = DSP_EFAIL;
-	}	/* DRV_RequestResources */
-	index++;
+	}
 
 	/* Unwind whatever was loaded */
 	if (DSP_FAILED(status)) {
@@ -185,7 +104,6 @@ u32 DSP_Init(OUT u32 *initStatus)
 		 * unloading. Get the Driver Object iterate through and remove.
 		 * Reset the status to E_FAIL to avoid going through
 		 * WCD_InitComplete2. */
-		status = DSP_EFAIL;
 		for (deviceNode = DRV_GetFirstDevExtension(); deviceNode != 0;
 		    deviceNode = DRV_GetNextDevExtension(deviceNode)) {
 			(void)DEV_RemoveDevice
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/mgr.c kernel-power-2.6.28/drivers/dsp/bridge/rmgr/mgr.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/mgr.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/rmgr/mgr.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,10 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implementation of Manager interface to the device object at the
+ * driver level. This queries the NDB data base and retrieves the
+ * data about Node and Processor.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,32 +18,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== mgr.c ========
- *  Description:
- *      Implementation of Manager interface to the device object at the
- *      driver level. This queries the NDB data base and retrieves the
- *      data about Node and Processor.
- *
- *
- *! Revision History:
- *! ================
- *! 12-Feb-2003 vp: Code review updates.
- *! 18-Oct-2002 vp: Ported to Linux platform
- *! 01-Aug-2001 ag: Added extended info for DSP-MMU setup support.
- *! 13-Feb-2001 kc: DSP/BIOS Bridge name updates.
- *! 22-Nov-2000 kc: Added MGR_GetPerfData.
- *! 03-Nov-2000 rr: Updated after code review.
- *! 25-Sep-2000 rr: Updated to Version 0.9
- *! 10-Aug-2000 rr: dwSignature is not specifically inserted in MGR Obj
- *!                 as it is taken care by MEM_AllocObject. stdwin.h added
- *!                 for retail build to succeed.
- *! 07-Aug-2000 rr: MGR_Create does the job of Loading DCD Dll.
- *! 26-Jul-2000 rr: MGR_Destroy releases the hNDBDll.
- *! 20-Jun-2000 rr: Created.
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
@@ -56,7 +34,6 @@
 
 /*  ----------------------------------- Others */
 #include <dspbridge/dbdcd.h>
-#include <dspbridge/dbreg.h>
 #include <dspbridge/drv.h>
 #include <dspbridge/dev.h>
 
@@ -97,16 +74,16 @@ DSP_STATUS MGR_Create(OUT struct MGR_OBJ
 		 phMgrObject);
 	MEM_AllocObject(pMgrObject, struct MGR_OBJECT, SIGNATURE);
 	if (pMgrObject) {
-		if (DSP_SUCCEEDED(DCD_CreateManager(ZLDLLNAME,
-		   &pMgrObject->hDcdMgr))) {
+		status = DCD_CreateManager(ZLDLLNAME, &pMgrObject->hDcdMgr);
+		if (DSP_SUCCEEDED(status)) {
 			/* If succeeded store the handle in the MGR Object */
-			if (DSP_SUCCEEDED(CFG_SetObject((u32)pMgrObject,
-			   REG_MGR_OBJECT))) {
+			status = CFG_SetObject((u32)pMgrObject,
+							REG_MGR_OBJECT);
+			if (DSP_SUCCEEDED(status)) {
 				*phMgrObject = pMgrObject;
 				GT_0trace(MGR_DebugMask, GT_1CLASS,
 					 "MGR_Create:MGR Created\r\n");
 			} else {
-				status = DSP_EFAIL;
 				GT_0trace(MGR_DebugMask, GT_7CLASS,
 					 "MGR_Create:CFG_SetObject "
 					 "Failed\r\n");
@@ -115,7 +92,6 @@ DSP_STATUS MGR_Create(OUT struct MGR_OBJ
 			}
 		} else {
 			/* failed to Create DCD Manager */
-			status = DSP_EFAIL;
 			GT_0trace(MGR_DebugMask, GT_7CLASS,
 				 "MGR_Create:DCD_ManagerCreate Failed\r\n");
 			MEM_FreeObject(pMgrObject);
@@ -174,7 +150,6 @@ DSP_STATUS MGR_EnumNodeInfo(u32 uNode, O
 			   u32 uNDBPropsSize, OUT u32 *puNumNodes)
 {
 	DSP_STATUS status = DSP_SOK;
-	DSP_STATUS status1 = DSP_SOK;
 	struct DSP_UUID Uuid, uTempUuid;
 	u32 uTempIndex = 0;
 	u32 uNodeIndex = 0;
@@ -192,8 +167,8 @@ DSP_STATUS MGR_EnumNodeInfo(u32 uNode, O
 		 uNDBPropsSize, puNumNodes);
 	*puNumNodes = 0;
 	/* Get The Manager Object from the Registry */
-	if (DSP_FAILED(CFG_GetObject((u32 *)&pMgrObject,
-	   REG_MGR_OBJECT))) {
+	status = CFG_GetObject((u32 *)&pMgrObject, REG_MGR_OBJECT);
+	if (DSP_FAILED(status)) {
 		GT_0trace(MGR_DebugMask, GT_7CLASS,
 			 "Manager_EnumNodeInfo:Failed To Get"
 			 " MGR Object from Registry\r\n");
@@ -219,26 +194,23 @@ DSP_STATUS MGR_EnumNodeInfo(u32 uNode, O
 				 "Manager_EnumNodeInfo: uNode"
 				 " is Invalid \r\n");
 		} else {
-			status1 = DCD_GetObjectDef(pMgrObject->hDcdMgr,
+			status = DCD_GetObjectDef(pMgrObject->hDcdMgr,
 						(struct DSP_UUID *)&Uuid,
 						DSP_DCDNODETYPE, &GenObj);
-			if (DSP_SUCCEEDED(status1)) {
+			if (DSP_SUCCEEDED(status)) {
 				/* Get the Obj def */
 				*pNDBProps = GenObj.objData.nodeObj.ndbProps;
 				*puNumNodes = uNodeIndex;
-				status = DSP_SOK;
 			} else {
 				GT_0trace(MGR_DebugMask, GT_7CLASS,
 					 "Manager_EnumNodeInfo: "
 					 "Failed to Get Node Info \r\n");
-				status = DSP_EFAIL;
 			}
 		}
 	} else {
 		/* This could be changed during enum, EFAIL ... */
 		GT_0trace(MGR_DebugMask, GT_7CLASS, "Manager_EnumNodeInfo: "
 			 "Enumeration failure\r\n");
-		status = DSP_EFAIL;
 	}
 func_cont:
 	GT_4trace(MGR_DebugMask, GT_ENTER,
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/nldr.c kernel-power-2.6.28/drivers/dsp/bridge/rmgr/nldr.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/nldr.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/rmgr/nldr.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge dynamic + overlay Node loader.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,42 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== nldr.c ========
- *  Description:
- *      DSP/BIOS Bridge dynamic + overlay Node loader.
- *
- *  Public Functions:
- *      NLDR_Allocate
- *      NLDR_Create
- *      NLDR_Delete
- *      NLDR_Exit
- *      NLDR_Free
- *      NLDR_GetFxnAddr
- *      NLDR_Init
- *      NLDR_Load
- *      NLDR_Unload
- *
- *  Notes:
- *
- *! Revision History
- *! ================
- *! 07-Apr-2003 map Removed references to dead DLDR module
- *! 23-Jan-2003 map Updated RemoteAlloc to support memory granularity
- *! 20-Jan-2003 map Updated to maintain persistent dependent libraries
- *! 15-Jan-2003 map Adapted for use with multiple dynamic phase libraries
- *! 19-Dec-2002 map Fixed overlay bug in AddOvlySect for overlay
- *!		 sections > 1024 bytes.
- *! 13-Dec-2002 map Fixed NLDR_GetFxnAddr bug by searching dependent
- *!		 libs for symbols
- *! 27-Sep-2002 map Added RemoteFree to convert size to words for
- *!		 correct deallocation
- *! 16-Sep-2002 map Code Review Cleanup(from dldr.c)
- *! 29-Aug-2002 map Adjusted for ARM-side overlay copy
- *! 05-Aug-2002 jeh Created.
- */
-
 #include <dspbridge/host_os.h>
 
 #include <dspbridge/std.h>
@@ -58,12 +24,11 @@
 
 #include <dspbridge/dbc.h>
 #include <dspbridge/gt.h>
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 #include <dspbridge/dbg.h>
 #endif
 
 /* OS adaptation layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/mem.h>
 
 /* Platform manager */
@@ -128,15 +93,15 @@
 #define FLAGBIT	 7	/* 7th bit is pref./req. flag */
 #define SEGMASK	 0x3f	/* Bits 0 - 5 */
 
-#define CREATEBIT       0	/* Create segid starts at bit 0 */
-#define DELETEBIT       8	/* Delete segid starts at bit 8 */
+#define CREATEBIT	0	/* Create segid starts at bit 0 */
+#define DELETEBIT	8	/* Delete segid starts at bit 8 */
 #define EXECUTEBIT      16	/* Execute segid starts at bit 16 */
 
 /*
  *  Masks that define memory type.  Must match defines in dynm.cdb.
  */
-#define DYNM_CODE       0x2
-#define DYNM_DATA       0x4
+#define DYNM_CODE	0x2
+#define DYNM_DATA	0x4
 #define DYNM_CODEDATA   (DYNM_CODE | DYNM_DATA)
 #define DYNM_INTERNAL   0x8
 #define DYNM_EXTERNAL   0x10
@@ -186,7 +151,7 @@
 	((uuid1).usData3 == (uuid2).usData3) && \
 	((uuid1).ucData4 == (uuid2).ucData4) && \
 	((uuid1).ucData5 == (uuid2).ucData5) && \
-       (strncmp((void *)(uuid1).ucData6, (void *)(uuid2).ucData6, 6)) == 0)
+	(strncmp((void *)(uuid1).ucData6, (void *)(uuid2).ucData6, 6)) == 0)
 
     /*
      *  ======== MemInfo ========
@@ -470,7 +435,7 @@ DSP_STATUS NLDR_Allocate(struct NLDR_OBJ
 	}
 	/* Cleanup on failure */
 	if (DSP_FAILED(status) && pNldrNode)
-		NLDR_Free((struct NLDR_NODEOBJECT *) pNldrNode);
+		MEM_FreeObject(pNldrNode);
 
 	DBC_Ensure((DSP_SUCCEEDED(status) &&
 		  MEM_IsValidHandle(((struct NLDR_NODEOBJECT *)(*phNldrNode)),
@@ -513,17 +478,12 @@ DSP_STATUS NLDR_Create(OUT struct NLDR_O
 	MEM_AllocObject(pNldr, struct NLDR_OBJECT, NLDR_SIGNATURE);
 	if (pNldr) {
 		pNldr->hDevObject = hDevObject;
-		/* warning, lazy status checking alert! */
 		status = DEV_GetCodMgr(hDevObject, &hCodMgr);
-		DBC_Assert(DSP_SUCCEEDED(status));
-		status = COD_GetLoader(hCodMgr, &pNldr->dbll);
-		DBC_Assert(DSP_SUCCEEDED(status));
-		status = COD_GetBaseLib(hCodMgr, &pNldr->baseLib);
-		DBC_Assert(DSP_SUCCEEDED(status));
-		status = COD_GetBaseName(hCodMgr, szZLFile, COD_MAXPATHLENGTH);
-		DBC_Assert(DSP_SUCCEEDED(status));
-		status = DSP_SOK;
-		/* end lazy status checking */
+		if (hCodMgr) {
+			COD_GetLoader(hCodMgr, &pNldr->dbll);
+			COD_GetBaseLib(hCodMgr, &pNldr->baseLib);
+			COD_GetBaseName(hCodMgr, szZLFile, COD_MAXPATHLENGTH);
+		}
 		pNldr->usDSPMauSize = pAttrs->usDSPMauSize;
 		pNldr->usDSPWordSize = pAttrs->usDSPWordSize;
 		pNldr->dbllFxns = dbllFxns;
@@ -598,7 +558,7 @@ DSP_STATUS NLDR_Create(OUT struct NLDR_O
 				rmmSegs[i].length = (pMemInfo + i)->len;
 				rmmSegs[i].space = 0;
 				pNldr->segTable[i] = (pMemInfo + i)->type;
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 				DBG_Trace(DBG_LEVEL7,
 				    "** (proc) DLL MEMSEGMENT: %d, Base: 0x%x, "
 				    "Length: 0x%x\n", i, rmmSegs[i].base,
@@ -753,19 +713,6 @@ void NLDR_Exit(void)
 }
 
 /*
- *  ======== NLDR_Free ========
- */
-void NLDR_Free(struct NLDR_NODEOBJECT *hNldrNode)
-{
-	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNldrNode, NLDR_NODESIGNATURE));
-
-	GT_1trace(NLDR_debugMask, GT_ENTER, "NLDR_Free(0x%x)\n", hNldrNode);
-
-	MEM_FreeObject(hNldrNode);
-}
-
-/*
  *  ======== NLDR_GetFxnAddr ========
  */
 DSP_STATUS NLDR_GetFxnAddr(struct NLDR_NODEOBJECT *hNldrNode, char *pstrFxn,
@@ -1008,7 +955,8 @@ DSP_STATUS NLDR_Unload(struct NLDR_NODEO
 				/* Unload main library */
 				pRootLib = &hNldrNode->root;
 			}
-			UnloadLib(hNldrNode, pRootLib);
+			if (pRootLib)
+				UnloadLib(hNldrNode, pRootLib);
 		} else {
 			if (hNldrNode->fOverlay)
 				UnloadOvly(hNldrNode, phase);
@@ -1040,9 +988,9 @@ static DSP_STATUS AddOvlyInfo(void *hand
 	/* Find the node it belongs to */
 	for (i = 0; i < hNldr->nOvlyNodes; i++) {
 		pNodeName = hNldr->ovlyTable[i].pNodeName;
-               DBC_Require(pNodeName);
-               if (strncmp(pNodeName, pSectName + 1,
-                               strlen(pNodeName)) == 0) {
+		DBC_Require(pNodeName);
+		if (strncmp(pNodeName, pSectName + 1,
+				strlen(pNodeName)) == 0) {
 				/* Found the node */
 				break;
 		}
@@ -1052,18 +1000,18 @@ static DSP_STATUS AddOvlyInfo(void *hand
 
 	/* Determine which phase this section belongs to */
 	for (pch = pSectName + 1; *pch && *pch != seps; pch++)
-		;;
+		;
 
 	if (*pch) {
 		pch++;	/* Skip over the ':' */
-               if (strncmp(pch, PCREATE, strlen(PCREATE)) == 0) {
+		if (strncmp(pch, PCREATE, strlen(PCREATE)) == 0) {
 			status = AddOvlySect(hNldr, &hNldr->ovlyTable[i].
 				pCreateSects, sectInfo, &fExists, addr, nBytes);
 			if (DSP_SUCCEEDED(status) && !fExists)
 				hNldr->ovlyTable[i].nCreateSects++;
 
 		} else
-               if (strncmp(pch, PDELETE, strlen(PDELETE)) == 0) {
+		if (strncmp(pch, PDELETE, strlen(PDELETE)) == 0) {
 			status = AddOvlySect(hNldr, &hNldr->ovlyTable[i].
 					    pDeleteSects, sectInfo, &fExists,
 					    addr, nBytes);
@@ -1071,7 +1019,7 @@ static DSP_STATUS AddOvlyInfo(void *hand
 				hNldr->ovlyTable[i].nDeleteSects++;
 
 		} else
-               if (strncmp(pch, PEXECUTE, strlen(PEXECUTE)) == 0) {
+		if (strncmp(pch, PEXECUTE, strlen(PEXECUTE)) == 0) {
 			status = AddOvlySect(hNldr, &hNldr->ovlyTable[i].
 					    pExecuteSects, sectInfo, &fExists,
 					    addr, nBytes);
@@ -1121,14 +1069,14 @@ static DSP_STATUS AddOvlyNode(struct DSP
 		} else {
 			/* Add node to table */
 			hNldr->ovlyTable[hNldr->nNode].uuid = *pUuid;
-                       DBC_Require(objDef.objData.nodeObj.ndbProps.acName);
-                       uLen = strlen(objDef.objData.nodeObj.ndbProps.acName);
+			DBC_Require(objDef.objData.nodeObj.ndbProps.acName);
+			uLen = strlen(objDef.objData.nodeObj.ndbProps.acName);
 			pNodeName = objDef.objData.nodeObj.ndbProps.acName;
 			pBuf = MEM_Calloc(uLen + 1, MEM_PAGED);
 			if (pBuf == NULL) {
 				status = DSP_EMEMORY;
 			} else {
-                               strncpy(pBuf, pNodeName, uLen);
+				strncpy(pBuf, pNodeName, uLen);
 				hNldr->ovlyTable[hNldr->nNode].pNodeName = pBuf;
 				hNldr->nNode++;
 			}
@@ -1432,7 +1380,7 @@ static DSP_STATUS LoadLib(struct NLDR_NO
 	/*
 	 *  Recursively load dependent libraries.
 	 */
-	if (DSP_SUCCEEDED(status) && persistentDepLibs) {
+	if (DSP_SUCCEEDED(status)) {
 		for (i = 0; i < nLibs; i++) {
 			/* If root library is NOT persistent, and dep library
 			 * is, then record it.  If root library IS persistent,
@@ -1456,15 +1404,11 @@ static DSP_STATUS LoadLib(struct NLDR_NO
 				pDepLib = &root->pDepLibs[nLoaded];
 			}
 
-			if (depLibUUIDs) {
-				status = LoadLib(hNldrNode, pDepLib,
+			status = LoadLib(hNldrNode, pDepLib,
 						depLibUUIDs[i],
 						persistentDepLibs[i], libPath,
 						phase,
 						depth);
-			} else {
-				status = DSP_EMEMORY;
-			}
 
 			if (DSP_SUCCEEDED(status)) {
 				if ((status != DSP_SALREADYLOADED) &&
@@ -1560,6 +1504,12 @@ static DSP_STATUS LoadOvly(struct NLDR_N
 	}
 
 	DBC_Assert(i < hNldr->nOvlyNodes);
+
+	if (!pONode) {
+		status = DSP_ENOTFOUND;
+		goto func_end;
+	}
+
 	switch (phase) {
 	case NLDR_CREATE:
 		pRefCount = &(pONode->createRef);
@@ -1583,10 +1533,6 @@ static DSP_STATUS LoadOvly(struct NLDR_N
 		break;
 	}
 
-	DBC_Assert(pRefCount != NULL);
-	if (DSP_FAILED(status))
-		goto func_end;
-
 	if (pRefCount == NULL)
 		goto func_end;
 
@@ -1865,7 +1811,6 @@ static void UnloadOvly(struct NLDR_NODEO
 	u16 nOtherAlloc = 0;
 	u16 *pRefCount = NULL;
 	u16 *pOtherRef = NULL;
-	DSP_STATUS status = DSP_SOK;
 
 	/* Find the node in the table */
 	for (i = 0; i < hNldr->nOvlyNodes; i++) {
@@ -1877,6 +1822,11 @@ static void UnloadOvly(struct NLDR_NODEO
 	}
 
 	DBC_Assert(i < hNldr->nOvlyNodes);
+
+	if (!pONode)
+		/* TODO: Should we print warning here? */
+		return;
+
 	switch (phase) {
 	case NLDR_CREATE:
 		pRefCount = &(pONode->createRef);
@@ -1901,23 +1851,21 @@ static void UnloadOvly(struct NLDR_NODEO
 		DBC_Assert(false);
 		break;
 	}
-	if (DSP_SUCCEEDED(status)) {
-		DBC_Assert(pRefCount && (*pRefCount > 0));
-		 if (pRefCount && (*pRefCount > 0)) {
-			*pRefCount -= 1;
-			if (pOtherRef) {
-				DBC_Assert(*pOtherRef > 0);
-				*pOtherRef -= 1;
-			}
+	DBC_Assert(pRefCount && (*pRefCount > 0));
+	 if (pRefCount && (*pRefCount > 0)) {
+		*pRefCount -= 1;
+		if (pOtherRef) {
+			DBC_Assert(*pOtherRef > 0);
+			*pOtherRef -= 1;
 		}
 	}
-	if (pRefCount && (*pRefCount == 0)) {
+
+	if (pRefCount && *pRefCount == 0) {
 		/* 'Deallocate' memory */
 		FreeSects(hNldr, pPhaseSects, nAlloc);
 	}
 	if (pOtherRef && *pOtherRef == 0)
 		FreeSects(hNldr, pOtherSects, nOtherAlloc);
-
 }
 
 /*
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/node.c kernel-power-2.6.28/drivers/dsp/bridge/rmgr/node.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/node.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/rmgr/node.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge Node Manager.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,84 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== node.c ========
- *
- *  Description:
- *      DSP/BIOS Bridge Node Manager.
- *
- *  Public Functions:
- *      NODE_Allocate
- *      NODE_AllocMsgBuf
- *      NODE_ChangePriority
- *      NODE_Connect
- *      NODE_Create
- *      NODE_CreateMgr
- *      NODE_Delete
- *      NODE_DeleteMgr
- *      NODE_EnumNodes
- *      NODE_Exit
- *      NODE_FreeMsgBuf
- *      NODE_GetAttr
- *      NODE_GetChannelId
- *      NODE_GetMessage
- *      NODE_GetStrmMgr
- *      NODE_Init
- *      NODE_OnExit
- *      NODE_Pause
- *      NODE_PutMessage
- *      NODE_RegisterNotify
- *      NODE_Run
- *      NODE_Terminate
- *
- *! Revision History:
- *! =================
- *! 12-Apr-2004 hp  Compile IVA only for 24xx
- *! 09-Feb-2004 vp  Updated to support IVA.
- *! 07-Apr-2003 map	    Eliminated references to old DLDR
- *! 26-Mar-2003 vp  Commented the call to DSP deep sleep in Node_Delete
- *!		    function.
- *! 18-Feb-2003 vp  Code review updates.
- *! 06-Feb-2003 kc      Fixed FreeStream to release streams correctly.
- *! 23-Jan-2003 map     Removed call to DISP_DoCinit within Write()
- *! 03-Jan-2003 map     Only unload code after phase has executed if
- *!		     overlay or split dynload phases
- *! 18-Oct-2002 vp  Ported to Linux platform.
- *! 06-Nov-2002 map     Fixed NODE_Run on NODE_PAUSED bug
- *! 12-Oct-2002 map     Fixed DeleteNode bug in NODE_Create
- *! 11-Sep-2002 rr      DeleteNode frees the memory for strmConnect and dcd obj
- *! 29-Aug-2002 map     Modified Ovly and Write to use ARM-side copy
- *! 22-May-2002 sg      Changed use of cbData for PWR calls.
- *! 17-May-2002 jeh     Removed LoadLoaderFxns(). Get address of RMS_cinit()
- *!		     function. Call DISP_DoCinit() from Write(), if .cinit.
- *! 13-May-2002 sg      Added timeout to wake/sleep calls.
- *! 02-May-2002 sg      Added wake/sleep of DSP to support "nap" mode.
- *! 18-Apr-2002 jeh     Use dynamic loader if compile flag is set.
- *! 13-Feb-2002 jeh     Get uSysStackSize from DSP_NDBPROPS.
- *! 07-Jan-2002 ag      STRMMODE_ZEROCOPY(shared memory buffer swap) enabled.
- *! 17-Dec-2001 ag      STRMMODE_RDMA(DDMA) enabled.
- *! 12-Dec-2001 ag      Check for valid stream mode in NODE_Connect().
- *! 04-Dec-2001 jeh     Check for node sufficiently connected in NODE_Create().
- *! 15-Nov-2001 jeh     Removed DBC_Require(pNode->hXlator != NULL) from
- *!		     NODE_AllocMsgBuf(), and check node type != NODE_DEVICE.
- *! 11-Sep-2001 ag      Zero-copy messaging support.
- *! 28-Aug-2001 jeh     Overlay/dynamic loader infrastructure added. Removed
- *!		     NODE_GetDispatcher, excess node states.
- *! 07-Aug-2001 jeh     Removed critical section for dispatcher.
- *! 26-Jul-2001 jeh     Get ZL dll name through CFG.
- *! 05-Jun-2001 jeh     Assume DSP_STRMATTRS.uBufsize in GPP bytes.
- *! 11-May-2001 jeh     Some code review cleanup.
- *! 13-Feb-2001 kc:     DSP/BIOS Bridge name updates.
- *! 15-Dec-2000 sg      Convert IALG_Fxn address from byte addr to word addr.
- *! 04-Dec-2000 jeh     Call MSG Get and Put functions.
- *! 04-Dec-2000 ag      Added SM support for node messaging.
- *! 10-Nov-2000 rr:     NODE_MIN/MAX Priority is defined in dspdefs.h.
- *! 27-Oct-2000 jeh     Added NODE_AllocMsgBuf(), NODE_FreeMsgBuf().
- *! 11-Oct-2000 jeh     Changed NODE_EnumNodeInfo to NODE_EnumNodes. Added
- *!		     NODE_CloseOrphans(). Remove NODE_RegisterNotifyAllNodes
- *! 19-Jun-2000 jeh     Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -106,7 +30,6 @@
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/cfg.h>
-#include <dspbridge/csl.h>
 #include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/proc.h>
@@ -131,7 +54,7 @@
 
 /*  ----------------------------------- Others */
 #include <dspbridge/gb.h>
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 #include <dspbridge/uuidutil.h>
 #include <dspbridge/dbg.h>
 #endif
@@ -144,12 +67,9 @@
 #include <dspbridge/dbll.h>
 #include <dspbridge/nldr.h>
 
-#ifndef RES_CLEANUP_DISABLE
 #include <dspbridge/drv.h>
 #include <dspbridge/drvdefs.h>
-#include <dspbridge/dbreg.h>
 #include <dspbridge/resourcecleanup.h>
-#endif
 
 
 #define NODE_SIGNATURE      0x45444f4e	/* "EDON" */
@@ -230,8 +150,8 @@ struct NODE_MGR {
 	u32 ulNumChnls;	/* Total number of channels */
 	u32 ulChnlOffset;	/* Offset of chnl ids rsvd for RMS */
 	u32 ulChnlBufSize;	/* Buffer size for data to RMS */
-	DSP_PROCFAMILY procFamily;	/* eg, 5000 */
-	DSP_PROCTYPE procType;	/* eg, 5510 */
+	long procFamily;	/* eg, 5000 */
+	long procType;	/* eg, 5510 */
 	u32 uDSPWordSize;	/* Size of DSP word on host bytes */
 	u32 uDSPDataMauSize;	/* Size of DSP data MAU */
 	u32 uDSPMauSize;	/* Size of MAU */
@@ -268,7 +188,7 @@ struct STREAM {
  *  ======== NODE_OBJECT ========
  */
 struct NODE_OBJECT {
-	struct LST_ELEM listElem;
+	struct list_head listElem;
 	u32 dwSignature;	/* For object validation */
 	struct NODE_MGR *hNodeMgr;	/* The manager of this node */
 	struct PROC_OBJECT *hProcessor;	/* Back pointer to processor */
@@ -296,7 +216,7 @@ struct NODE_OBJECT {
 	s32 nExitStatus;	/* execute function return status */
 
 	/* Information needed for NODE_GetAttr() */
-	DSP_HNODE hDeviceOwner;	/* If dev node, task that owns it */
+	void *hDeviceOwner;	/* If dev node, task that owns it */
 	u32 uNumGPPInputs;	/* Current # of from GPP streams */
 	u32 uNumGPPOutputs;	/* Current # of to GPP streams */
 	/* Current stream connections */
@@ -335,9 +255,9 @@ static void FreeStream(struct NODE_MGR *
 static DSP_STATUS GetFxnAddress(struct NODE_OBJECT *hNode, u32 *pulFxnAddr,
 				u32 uPhase);
 static DSP_STATUS GetNodeProps(struct DCD_MANAGER *hDcdMgr,
-			       struct NODE_OBJECT *hNode,
-			       CONST struct DSP_UUID *pNodeId,
-			       struct DCD_GENERICOBJ *pdcdProps);
+				struct NODE_OBJECT *hNode,
+				CONST struct DSP_UUID *pNodeId,
+				struct DCD_GENERICOBJ *pdcdProps);
 static DSP_STATUS GetProcProps(struct NODE_MGR *hNodeMgr,
 			      struct DEV_OBJECT *hDevObject);
 static DSP_STATUS GetRMSFxns(struct NODE_MGR *hNodeMgr);
@@ -362,7 +282,6 @@ static struct NLDR_FXNS nldrFxns = {
 	NLDR_Create,
 	NLDR_Delete,
 	NLDR_Exit,
-	NLDR_Free,
 	NLDR_GetFxnAddr,
 	NLDR_Init,
 	NLDR_Load,
@@ -371,14 +290,13 @@ static struct NLDR_FXNS nldrFxns = {
 
 enum NODE_STATE NODE_GetState(HANDLE hNode)
 {
-       struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
-       if (!MEM_IsValidHandle(pNode, NODE_SIGNATURE)) {
-               GT_1trace(NODE_debugMask, GT_5CLASS,
-                "NODE_GetState:hNode 0x%x\n", pNode);
-               return  -1;
-       } else
-               return pNode->nState;
-
+	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
+	if (!MEM_IsValidHandle(pNode, NODE_SIGNATURE)) {
+		GT_1trace(NODE_debugMask, GT_5CLASS,
+				"NODE_GetState:hNode 0x%x\n", pNode);
+		return  -1;
+	} else
+		return pNode->nState;
 }
 
 /*
@@ -404,7 +322,6 @@ DSP_STATUS NODE_Allocate(struct PROC_OBJ
 	DSP_STATUS status = DSP_SOK;
 	struct CMM_OBJECT *hCmmMgr = NULL; /* Shared memory manager hndl */
 	u32 procId;
-	char *label;
 	u32 pulValue;
 	u32 dynextBase;
 	u32 offSet = 0;
@@ -419,9 +336,7 @@ DSP_STATUS NODE_Allocate(struct PROC_OBJ
 	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
 #endif
 
-#ifndef RES_CLEANUP_DISABLE
-	HANDLE	     nodeRes;
-#endif
+	HANDLE nodeRes;
 
 	DBC_Require(cRefs > 0);
 	DBC_Require(hProcessor != NULL);
@@ -437,6 +352,9 @@ DSP_STATUS NODE_Allocate(struct PROC_OBJ
 
 	status = PROC_GetProcessorId(hProcessor, &procId);
 
+	if (procId != DSP_UNIT)
+		goto func_end;
+
 	status = PROC_GetDevObject(hProcessor, &hDevObject);
 	if (DSP_SUCCEEDED(status)) {
 		status = DEV_GetNodeManager(hDevObject, &hNodeMgr);
@@ -444,11 +362,9 @@ DSP_STATUS NODE_Allocate(struct PROC_OBJ
 			status = DSP_EFAIL;
 
 	}
-	if (procId != DSP_UNIT)
-		goto func_cont;
 
 	if (DSP_FAILED(status))
-		goto func_cont;
+		goto func_end;
 
 	status = PROC_GetState(hProcessor, &procStatus,
 			sizeof(struct DSP_PROCESSORSTATE));
@@ -479,27 +395,27 @@ DSP_STATUS NODE_Allocate(struct PROC_OBJ
 				status = DSP_ERANGE;
 		}
 	}
-func_cont:
 	/* Allocate node object and fill in */
 	if (DSP_FAILED(status))
-		goto func_cont2;
+		goto func_end;
 
 	MEM_AllocObject(pNode, struct NODE_OBJECT, NODE_SIGNATURE);
 	if (pNode == NULL) {
 		status = DSP_EMEMORY;
-		goto func_cont1;
+		goto func_end;
 	}
 	pNode->hNodeMgr = hNodeMgr;
 	/* This critical section protects GetNodeProps */
 	status = SYNC_EnterCS(hNodeMgr->hSync);
-	if (procId != DSP_UNIT)
-		goto func_cont3;
+
+	if (DSP_FAILED(status))
+		goto func_end;
 
 	/* Get DSP_NDBPROPS from node database */
 	status = GetNodeProps(hNodeMgr->hDcdMgr, pNode, pNodeId,
 			     &(pNode->dcdProps));
 	if (DSP_FAILED(status))
-		goto func_cont3;
+		goto func_cont;
 
 	pNode->nodeId = *pNodeId;
 	pNode->hProcessor = hProcessor;
@@ -514,11 +430,11 @@ func_cont:
 	pNode->createArgs.asa.taskArgs.uDSPHeapResAddr = 0;
 	pNode->createArgs.asa.taskArgs.uGPPHeapAddr = 0;
 	if (!pAttrIn)
-		goto func_cont3;
+		goto func_cont;
 
 	/* Check if we have a user allocated node heap */
 	if (!(pAttrIn->pGPPVirtAddr))
-		goto func_cont3;
+		goto func_cont;
 
 	/* check for page aligned Heap size */
 	if (((pAttrIn->uHeapSize) & (PG_SIZE_4K - 1))) {
@@ -533,7 +449,7 @@ func_cont:
 						 (u32)pAttrIn->pGPPVirtAddr;
 	}
 	if (DSP_FAILED(status))
-		goto func_cont3;
+		goto func_cont;
 
 	status = PROC_ReserveMemory(hProcessor,
 			pNode->createArgs.asa.taskArgs.uHeapSize + PAGE_SIZE,
@@ -543,18 +459,16 @@ func_cont:
 		GT_1trace(NODE_debugMask, GT_5CLASS,
 			 "NODE_Allocate:Failed to reserve "
 			 "memory for Heap: 0x%x\n", status);
-	} else {
-		GT_1trace(NODE_debugMask, GT_5CLASS,
-			 "NODE_Allocate: DSPProcessor_Reserve"
-			 " Memory successful: 0x%x\n", status);
+
+		goto func_cont;
 	}
 #ifdef DSP_DMM_DEBUG
 	status = DMM_GetHandle(pProcObject, &hDmmMgr);
-	if (DSP_SUCCEEDED(status))
-		DMM_MemMapDump(hDmmMgr);
-#endif
 	if (DSP_FAILED(status))
-		goto func_cont3;
+		goto func_cont;
+
+	DMM_MemMapDump(hDmmMgr);
+#endif
 
 	mapAttrs |= DSP_MAPLITTLEENDIAN;
 	mapAttrs |= DSP_MAPELEMSIZE32;
@@ -575,15 +489,13 @@ func_cont:
 			 " successful: 0x%x\n", status);
 	}
 
-func_cont3:
+func_cont:
 	(void)SYNC_LeaveCS(hNodeMgr->hSync);
-func_cont1:
 	if (pAttrIn != NULL) {
 		/* Overrides of NBD properties */
 		pNode->uTimeout = pAttrIn->uTimeout;
 		pNode->nPriority = pAttrIn->iPriority;
 	}
-func_cont2:
 	/* Create object to manage notifications */
 	if (DSP_SUCCEEDED(status))
 		status = NTFY_Create(&pNode->hNtfy);
@@ -595,8 +507,8 @@ func_cont2:
 		if (nodeType != NODE_MESSAGE) {
 			uNumStreams = MaxInputs(pNode) + MaxOutputs(pNode);
 			pNode->streamConnect = MEM_Calloc(uNumStreams *
-					       sizeof(struct DSP_STREAMCONNECT),
-					       MEM_PAGED);
+					sizeof(struct DSP_STREAMCONNECT),
+					MEM_PAGED);
 			if (uNumStreams > 0 && pNode->streamConnect == NULL)
 				status = DSP_EMEMORY;
 
@@ -644,9 +556,9 @@ func_cont2:
 					 hCmmMgr, NULL);
 				if (DSP_FAILED(status)) {
 					GT_1trace(NODE_debugMask, GT_5CLASS,
-					    "NODE_Allocate: Failed"
-					    " to create SM translator: 0x%x\n",
-					    status);
+						"NODE_Allocate: Failed to "
+						"create SM translator: 0x%x\n",
+						status);
 				}
 			}
 		}
@@ -661,7 +573,7 @@ func_cont2:
 				} else {
 					pmsgArgs->uArgLength = pArgs->cbData;
 					memcpy(pmsgArgs->pData, pArgs->cData,
-					      pArgs->cbData);
+						pArgs->cbData);
 				}
 			}
 		}
@@ -691,18 +603,16 @@ func_cont2:
 		}
 	}
 
-	/* Comapare value read from Node Properties and check if it is same as
+	/* Compare value read from Node Properties and check if it is same as
 	 * STACKSEGLABEL, if yes read the Address of STACKSEGLABEL, calculate
 	 * GPP Address, Read the value in that address and override the
 	 * uStackSeg value in task args */
 	if (DSP_SUCCEEDED(status) &&
 	   (char *)pNode->dcdProps.objData.nodeObj.ndbProps.uStackSegName !=
 	   NULL) {
-		label = MEM_Calloc(sizeof(STACKSEGLABEL)+1, MEM_PAGED);
-               strncpy(label, STACKSEGLABEL, sizeof(STACKSEGLABEL)+1);
-
-               if (strcmp((char *)pNode->dcdProps.objData.nodeObj.
-				     ndbProps.uStackSegName, label) == 0) {
+		if (strcmp((char *)
+		    pNode->dcdProps.objData.nodeObj.ndbProps.uStackSegName,
+		    STACKSEGLABEL) == 0) {
 			status = hNodeMgr->nldrFxns.pfnGetFxnAddr(pNode->
 				 hNldrNode, "DYNEXT_BEG", &dynextBase);
 			if (DSP_FAILED(status)) {
@@ -727,6 +637,7 @@ func_cont2:
 				GT_1trace(NODE_debugMask, GT_5CLASS,
 				"NODE_Allocate: Failed to get host resource "
 				"0x%x\n", status);
+				goto func_end;
 			}
 
 			ulGppMemBase = (u32)hostRes.dwMemBase[1];
@@ -744,24 +655,20 @@ func_cont2:
 				ulStackSegVal;
 
 		}
-
-		if (label)
-			MEM_Free(label);
-
 	}
 
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Add the node to the node manager's list of allocated
 		 * nodes. */
-		LST_InitElem((struct LST_ELEM *)pNode);
+		LST_InitElem((struct list_head *)pNode);
 		NODE_SetState(pNode, NODE_ALLOCATED);
 
 		status = SYNC_EnterCS(hNodeMgr->hSync);
 
 		if (DSP_SUCCEEDED(status)) {
 			LST_PutTail(hNodeMgr->nodeList,
-			(struct LST_ELEM *) pNode);
+					(struct list_head *) pNode);
 			++(hNodeMgr->uNumNodes);
 		}
 
@@ -785,13 +692,11 @@ func_cont2:
 
 	}
 
-#ifndef RES_CLEANUP_DISABLE
 	if (DSP_SUCCEEDED(status)) {
 		DRV_InsertNodeResElement(*phNode, &nodeRes, pr_ctxt);
 		DRV_ProcNodeUpdateHeapStatus(nodeRes, true);
 		DRV_ProcNodeUpdateStatus(nodeRes, true);
 	}
-#endif
 	DBC_Ensure((DSP_FAILED(status) && (*phNode == NULL)) ||
 		  (DSP_SUCCEEDED(status)
 		    && MEM_IsValidHandle((*phNode), NODE_SIGNATURE)));
@@ -805,8 +710,8 @@ func_end:
  *      Allocates buffer for zero copy messaging.
  */
 DBAPI NODE_AllocMsgBuf(struct NODE_OBJECT *hNode, u32 uSize,
-		       OPTIONAL IN OUT struct DSP_BUFFERATTR *pAttr,
-		       OUT u8 **pBuffer)
+			OPTIONAL IN OUT struct DSP_BUFFERATTR *pAttr,
+			OUT u8 **pBuffer)
 {
 	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
 	DSP_STATUS status = DSP_SOK;
@@ -824,9 +729,7 @@ DBAPI NODE_AllocMsgBuf(struct NODE_OBJEC
 		 " 0x%x\tpAttr: 0x%x\tpBuffer: %d\n", pNode, uSize, pAttr,
 		 pBuffer);
 
-	if (!MEM_IsValidHandle(pNode, NODE_SIGNATURE))
-		status = DSP_EHANDLE;
-	else if (NODE_GetType(pNode) == NODE_DEVICE)
+	if (NODE_GetType(pNode) == NODE_DEVICE)
 		status = DSP_ENODETYPE;
 
 	if (DSP_FAILED(status))
@@ -915,7 +818,7 @@ DSP_STATUS NODE_ChangePriority(struct NO
 	GT_2trace(NODE_debugMask, GT_ENTER, "NODE_ChangePriority: "
 		 "hNode: 0x%x\tnPriority: %d\n", hNode, nPriority);
 
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	if (!hNode->hNodeMgr) {
 		GT_1trace(NODE_debugMask, GT_7CLASS,
 			 "Invalid NODE Handle: 0x%x\n", hNode);
 		status = DSP_EHANDLE;
@@ -934,7 +837,7 @@ DSP_STATUS NODE_ChangePriority(struct NO
 	/* Enter critical section */
 	status = SYNC_EnterCS(hNodeMgr->hSync);
 	if (DSP_FAILED(status))
-		goto func_cont;
+		goto func_end;
 
 	state = NODE_GetState(hNode);
 	if (state == NODE_ALLOCATED || state == NODE_PAUSED) {
@@ -944,19 +847,16 @@ DSP_STATUS NODE_ChangePriority(struct NO
 			status = DSP_EWRONGSTATE;
 			goto func_cont;
 		}
-		if (DSP_SUCCEEDED(status)) {
-			status = PROC_GetProcessorId(pNode->hProcessor,
-						    &procId);
-			if (procId == DSP_UNIT) {
-				status = DISP_NodeChangePriority(hNodeMgr->
-				    hDisp, hNode,
-				    hNodeMgr->ulFxnAddrs[RMSCHANGENODEPRIORITY],
-				    hNode->nodeEnv, nPriority);
-			}
-			if (DSP_SUCCEEDED(status))
-				NODE_SetPriority(hNode, nPriority);
-
+		status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+		if (procId == DSP_UNIT) {
+			status = DISP_NodeChangePriority(hNodeMgr->
+			    hDisp, hNode,
+			    hNodeMgr->ulFxnAddrs[RMSCHANGENODEPRIORITY],
+			    hNode->nodeEnv, nPriority);
 		}
+		if (DSP_SUCCEEDED(status))
+			NODE_SetPriority(hNode, nPriority);
+
 	}
 func_cont:
 		/* Leave critical section */
@@ -987,7 +887,7 @@ DSP_STATUS NODE_Connect(struct NODE_OBJE
 	struct STREAM *pStream;
 	GB_BitNum pipeId = GB_NOBITS;
 	GB_BitNum chnlId = GB_NOBITS;
-	CHNL_MODE uMode;
+	short int uMode;
 	u32 dwLength;
 	DSP_STATUS status = DSP_SOK;
 	DBC_Require(cRefs > 0);
@@ -995,13 +895,13 @@ DSP_STATUS NODE_Connect(struct NODE_OBJE
 		 "NODE_Connect: hNode1: 0x%x\tuStream1:"
 		 " %d\thNode2: 0x%x\tuStream2: %d\tpAttrs: 0x%x\n", hNode1,
 		 uStream1, hNode2, uStream2, pAttrs);
-	if (DSP_SUCCEEDED(status)) {
-		if ((hNode1 != (struct NODE_OBJECT *) DSP_HGPPNODE &&
-		   !MEM_IsValidHandle(hNode1, NODE_SIGNATURE)) ||
-		   (hNode2 != (struct NODE_OBJECT *) DSP_HGPPNODE &&
-		   !MEM_IsValidHandle(hNode2, NODE_SIGNATURE)))
-			status = DSP_EHANDLE;
-	}
+
+	if ((hNode1 != (struct NODE_OBJECT *) DSP_HGPPNODE &&
+			!MEM_IsValidHandle(hNode1, NODE_SIGNATURE)) ||
+			(hNode2 != (struct NODE_OBJECT *) DSP_HGPPNODE &&
+			!MEM_IsValidHandle(hNode2, NODE_SIGNATURE)))
+		status = DSP_EHANDLE;
+
 	if (DSP_SUCCEEDED(status)) {
 		/* The two nodes must be on the same processor */
 		if (hNode1 != (struct NODE_OBJECT *)DSP_HGPPNODE &&
@@ -1215,7 +1115,7 @@ func_cont2:
 		}
 		/* Set up create args */
 		pStream->type = DEVICECONNECT;
-               dwLength = strlen(hDevNode->pstrDevName);
+		dwLength = strlen(hDevNode->pstrDevName);
 		if (pConnParam != NULL) {
 			pstrmDef->szDevice = MEM_Calloc(dwLength + 1 +
 						(u32) pConnParam->cbData,
@@ -1228,12 +1128,12 @@ func_cont2:
 			status = DSP_EMEMORY;
 		} else {
 			/* Copy device name */
-                       strncpy(pstrmDef->szDevice, hDevNode->pstrDevName,
-				   dwLength);
+			strncpy(pstrmDef->szDevice, hDevNode->pstrDevName,
+				dwLength);
 			if (pConnParam != NULL) {
-                               strncat(pstrmDef->szDevice,
-                                       (char *)pConnParam->cData,
-                                       (u32)pConnParam->cbData);
+				strncat(pstrmDef->szDevice,
+					(char *)pConnParam->cData,
+					(u32)pConnParam->cbData);
 			}
 			hDevNode->hDeviceOwner = hNode;
 		}
@@ -1285,7 +1185,6 @@ DSP_STATUS NODE_Create(struct NODE_OBJEC
 	enum NODE_TYPE nodeType;
 	DSP_STATUS status = DSP_SOK;
 	DSP_STATUS status1 = DSP_SOK;
-	bool bJustWokeDSP = false;
 	struct DSP_CBDATA cbData;
 	u32 procId = 255;
 	struct DSP_PROCESSORSTATE procStatus;
@@ -1298,10 +1197,7 @@ DSP_STATUS NODE_Create(struct NODE_OBJEC
 	DBC_Require(cRefs > 0);
 	GT_1trace(NODE_debugMask, GT_ENTER, "NODE_Create: hNode: 0x%x\n",
 		 hNode);
-	if (!MEM_IsValidHandle(pNode, NODE_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		goto func_end;
-	}
+
 	hProcessor = hNode->hProcessor;
 	status = PROC_GetState(hProcessor, &procStatus,
 					sizeof(struct DSP_PROCESSORSTATE));
@@ -1323,7 +1219,7 @@ DSP_STATUS NODE_Create(struct NODE_OBJEC
 	/* Get access to node dispatcher */
 	status = SYNC_EnterCS(hNodeMgr->hSync);
 	if (DSP_FAILED(status))
-		goto func_cont;
+		goto func_end;
 
 	/* Check node state */
 	if (NODE_GetState(hNode) != NODE_ALLOCATED)
@@ -1436,22 +1332,6 @@ func_cont2:
 		/* Put back in NODE_ALLOCATED state if error occurred */
 		NODE_SetState(hNode, NODE_ALLOCATED);
 	}
-	if (procId == DSP_UNIT) {
-		/* If node create failed, see if should sleep DSP now */
-		if (bJustWokeDSP == true) {
-			/* Check to see if partial create happened on DSP */
-			if (hNode->nodeEnv == (u32)NULL) {
-				/* No environment allocated on DSP, re-sleep
-				 * DSP now */
-				PROC_Ctrl(hNode->hProcessor, WMDIOCTL_DEEPSLEEP,
-					 &cbData);
-			} else {
-				/* Increment count, sleep later when node fully
-				 * deleted */
-				hNodeMgr->uNumCreated++;
-			}
-		}
-	}
 func_cont:
 		/* Free access to node dispatcher */
 		(void)SYNC_LeaveCS(hNodeMgr->hSync);
@@ -1489,7 +1369,8 @@ DSP_STATUS NODE_CreateMgr(OUT struct NOD
 	MEM_AllocObject(pNodeMgr, struct NODE_MGR, NODEMGR_SIGNATURE);
 	if (pNodeMgr) {
 		pNodeMgr->hDevObject = hDevObject;
-		pNodeMgr->nodeList = LST_Create();
+		pNodeMgr->nodeList = MEM_Calloc(sizeof(struct LST_LIST),
+						MEM_NONPAGED);
 		pNodeMgr->pipeMap = GB_create(MAXPIPES);
 		pNodeMgr->pipeDoneMap = GB_create(MAXPIPES);
 		if (pNodeMgr->nodeList == NULL || pNodeMgr->pipeMap == NULL ||
@@ -1499,6 +1380,7 @@ DSP_STATUS NODE_CreateMgr(OUT struct NOD
 				 "NODE_CreateMgr: Memory "
 				 "allocation failed\n");
 		} else {
+			INIT_LIST_HEAD(&pNodeMgr->nodeList->head);
 			status = NTFY_Create(&pNodeMgr->hNtfy);
 		}
 		pNodeMgr->uNumCreated = 0;
@@ -1535,8 +1417,6 @@ DSP_STATUS NODE_CreateMgr(OUT struct NOD
 		/* Get MSG queue manager */
 		DEV_GetMsgMgr(hDevObject, &pNodeMgr->hMsg);
 		status = SYNC_InitializeCS(&pNodeMgr->hSync);
-		if (DSP_FAILED(status))
-			status = DSP_EMEMORY;
 	}
 	if (DSP_SUCCEEDED(status)) {
 		pNodeMgr->chnlMap = GB_create(pNodeMgr->ulNumChnls);
@@ -1625,17 +1505,12 @@ DSP_STATUS NODE_Delete(struct NODE_OBJEC
 	u32 procId;
 	struct WMD_DRV_INTERFACE *pIntfFxns;
 
-#ifndef RES_CLEANUP_DISABLE
 	HANDLE		nodeRes;
-#endif
+
 	struct DSP_PROCESSORSTATE procStatus;
 	DBC_Require(cRefs > 0);
 	GT_1trace(NODE_debugMask, GT_ENTER, "NODE_Delete: hNode: 0x%x\n",
 		  hNode);
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		goto func_end;
-	}
 	/* create struct DSP_CBDATA struct for PWR call */
 	cbData.cbData = PWR_TIMEOUT;
 	hNodeMgr = hNode->hNodeMgr;
@@ -1743,7 +1618,7 @@ func_cont1:
 	}
 	/* Free host side resources even if a failure occurred */
 	/* Remove node from hNodeMgr->nodeList */
-	LST_RemoveElem(hNodeMgr->nodeList, (struct LST_ELEM *) hNode);
+	LST_RemoveElem(hNodeMgr->nodeList, (struct list_head *) hNode);
 	hNodeMgr->uNumNodes--;
 	/* Decrement count of nodes created on DSP */
 	if ((state != NODE_ALLOCATED) || ((state == NODE_ALLOCATED) &&
@@ -1751,22 +1626,15 @@ func_cont1:
 		hNodeMgr->uNumCreated--;
 	 /*  Free host-side resources allocated by NODE_Create()
 	 *  DeleteNode() fails if SM buffers not freed by client!  */
-#ifndef RES_CLEANUP_DISABLE
-	if (!pr_ctxt)
-		goto func_cont;
 	if (DRV_GetNodeResElement(hNode, &nodeRes, pr_ctxt) != DSP_ENOTFOUND) {
 		GT_0trace(NODE_debugMask, GT_5CLASS, "\nNODE_Delete12:\n");
 		DRV_ProcNodeUpdateStatus(nodeRes, false);
 	}
-#endif
-func_cont:
 	GT_0trace(NODE_debugMask, GT_ENTER, "\nNODE_Delete13:\n ");
 	DeleteNode(hNode, pr_ctxt);
-#ifndef RES_CLEANUP_DISABLE
+
 	GT_0trace(NODE_debugMask, GT_5CLASS, "\nNODE_Delete2:\n ");
-	if (pr_ctxt)
-		DRV_RemoveNodeResElement(nodeRes, pr_ctxt);
-#endif
+	DRV_RemoveNodeResElement(nodeRes, pr_ctxt);
 	GT_0trace(NODE_debugMask, GT_ENTER, "\nNODE_Delete3:\n ");
 	/* Exit critical section */
 	(void)SYNC_LeaveCS(hNodeMgr->hSync);
@@ -1785,11 +1653,13 @@ DSP_STATUS NODE_DeleteMgr(struct NODE_MG
 	DSP_STATUS status = DSP_SOK;
 
 	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE));
 
 	GT_1trace(NODE_debugMask, GT_ENTER, "NODE_DeleteMgr: hNodeMgr: 0x%x\n",
 		 hNodeMgr);
-	DeleteNodeMgr(hNodeMgr);
+	if (MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE))
+		DeleteNodeMgr(hNodeMgr);
+	else
+		status = DSP_EHANDLE;
 
 	return status;
 }
@@ -1799,7 +1669,7 @@ DSP_STATUS NODE_DeleteMgr(struct NODE_MG
  *  Purpose:
  *      Enumerate currently allocated nodes.
  */
-DSP_STATUS NODE_EnumNodes(struct NODE_MGR *hNodeMgr, IN DSP_HNODE *aNodeTab,
+DSP_STATUS NODE_EnumNodes(struct NODE_MGR *hNodeMgr, void **aNodeTab,
 			 u32 uNodeTabSize, OUT u32 *puNumNodes,
 			 OUT u32 *puAllocated)
 {
@@ -1807,7 +1677,6 @@ DSP_STATUS NODE_EnumNodes(struct NODE_MG
 	u32 i;
 	DSP_STATUS status = DSP_SOK;
 	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE));
 	DBC_Require(aNodeTab != NULL || uNodeTabSize == 0);
 	DBC_Require(puNumNodes != NULL);
 	DBC_Require(puAllocated != NULL);
@@ -1815,6 +1684,10 @@ DSP_STATUS NODE_EnumNodes(struct NODE_MG
 		 "aNodeTab: %d\tuNodeTabSize: 0x%x\tpuNumNodes: 0x%x\t"
 		 "puAllocated\n", hNodeMgr, aNodeTab, uNodeTabSize, puNumNodes,
 		 puAllocated);
+	if (!MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 	/* Enter critical section */
 	status = SYNC_EnterCS(hNodeMgr->hSync);
 	if (DSP_SUCCEEDED(status)) {
@@ -1831,7 +1704,7 @@ DSP_STATUS NODE_EnumNodes(struct NODE_MG
 				aNodeTab[i] = hNode;
 				hNode = (struct NODE_OBJECT *)LST_Next
 					(hNodeMgr->nodeList,
-					(struct LST_ELEM *)hNode);
+					(struct list_head *)hNode);
 			}
 			*puAllocated = *puNumNodes = hNodeMgr->uNumNodes;
 		}
@@ -1839,6 +1712,7 @@ DSP_STATUS NODE_EnumNodes(struct NODE_MG
 	/* end of SYNC_EnterCS */
 	/* Exit critical section */
 	(void)SYNC_LeaveCS(hNodeMgr->hSync);
+func_end:
 	return status;
 }
 
@@ -1876,10 +1750,6 @@ DSP_STATUS NODE_FreeMsgBuf(struct NODE_O
 	DBC_Require(pNode->hXlator != NULL);
 	GT_3trace(NODE_debugMask, GT_ENTER, "NODE_FreeMsgBuf: hNode: 0x%x\t"
 		 "pBuffer: 0x%x\tpAttr: 0x%x\n", hNode, pBuffer, pAttr);
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		goto func_end;
-	}
 	status = PROC_GetProcessorId(pNode->hProcessor, &procId);
 	if (procId == DSP_UNIT) {
 		if (DSP_SUCCEEDED(status)) {
@@ -1893,16 +1763,11 @@ DSP_STATUS NODE_FreeMsgBuf(struct NODE_O
 
 			/* pBuffer is clients Va. */
 			status = CMM_XlatorFreeBuf(pNode->hXlator, pBuffer);
-			if (DSP_FAILED(status))
-				status = DSP_EFAIL;
-			else
-				status = DSP_SOK;
-
 		}
 	} else {
 		DBC_Assert(NULL);	/* BUG */
 	}
-func_end:
+
 	return status;
 }
 
@@ -1923,34 +1788,32 @@ DSP_STATUS NODE_GetAttr(struct NODE_OBJE
 	GT_3trace(NODE_debugMask, GT_ENTER, "NODE_GetAttr: hNode: "
 		 "0x%x\tpAttr: 0x%x \tuAttrSize: 0x%x\n", hNode, pAttr,
 		 uAttrSize);
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-		status = DSP_EHANDLE;
-	} else {
-		hNodeMgr = hNode->hNodeMgr;
-		 /* Enter hNodeMgr critical section (since we're accessing
-		  * data that could be changed by NODE_ChangePriority() and
-		  * NODE_Connect().  */
-		status = SYNC_EnterCS(hNodeMgr->hSync);
-		if (DSP_SUCCEEDED(status)) {
-			pAttr->cbStruct = sizeof(struct DSP_NODEATTR);
-			/* DSP_NODEATTRIN */
-			pAttr->inNodeAttrIn.cbStruct =
-					 sizeof(struct DSP_NODEATTRIN);
-			pAttr->inNodeAttrIn.iPriority = hNode->nPriority;
-			pAttr->inNodeAttrIn.uTimeout = hNode->uTimeout;
-			pAttr->inNodeAttrIn.uHeapSize =
-				hNode->createArgs.asa.taskArgs.uHeapSize;
-			pAttr->inNodeAttrIn.pGPPVirtAddr = (void *)
-				hNode->createArgs.asa.taskArgs.uGPPHeapAddr;
-			pAttr->uInputs = hNode->uNumGPPInputs;
-			pAttr->uOutputs = hNode->uNumGPPOutputs;
-			/* DSP_NODEINFO */
-			GetNodeInfo(hNode, &(pAttr->iNodeInfo));
-		}
-		/* end of SYNC_EnterCS */
-		/* Exit critical section */
-		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+
+	hNodeMgr = hNode->hNodeMgr;
+	 /* Enter hNodeMgr critical section (since we're accessing
+	  * data that could be changed by NODE_ChangePriority() and
+	  * NODE_Connect().  */
+	status = SYNC_EnterCS(hNodeMgr->hSync);
+	if (DSP_SUCCEEDED(status)) {
+		pAttr->cbStruct = sizeof(struct DSP_NODEATTR);
+		/* DSP_NODEATTRIN */
+		pAttr->inNodeAttrIn.cbStruct =
+				 sizeof(struct DSP_NODEATTRIN);
+		pAttr->inNodeAttrIn.iPriority = hNode->nPriority;
+		pAttr->inNodeAttrIn.uTimeout = hNode->uTimeout;
+		pAttr->inNodeAttrIn.uHeapSize =
+			hNode->createArgs.asa.taskArgs.uHeapSize;
+		pAttr->inNodeAttrIn.pGPPVirtAddr = (void *)
+			hNode->createArgs.asa.taskArgs.uGPPHeapAddr;
+		pAttr->uInputs = hNode->uNumGPPInputs;
+		pAttr->uOutputs = hNode->uNumGPPOutputs;
+		/* DSP_NODEINFO */
+		GetNodeInfo(hNode, &(pAttr->iNodeInfo));
 	}
+	/* end of SYNC_EnterCS */
+	/* Exit critical section */
+	(void)SYNC_LeaveCS(hNodeMgr->hSync);
+
 	return status;
 }
 
@@ -1971,10 +1834,6 @@ DSP_STATUS NODE_GetChannelId(struct NODE
 	GT_4trace(NODE_debugMask, GT_ENTER, "NODE_GetChannelId: hNode: "
 		 "0x%x\tuDir: %d\tuIndex: %d\tpulId: 0x%x\n", hNode, uDir,
 		 uIndex, pulId);
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		return status;
-	}
 	nodeType = NODE_GetType(hNode);
 	if (nodeType != NODE_TASK && nodeType != NODE_DAISSOCKET) {
 		status = DSP_ENODETYPE;
@@ -2020,10 +1879,7 @@ DSP_STATUS NODE_GetMessage(struct NODE_O
 	GT_3trace(NODE_debugMask, GT_ENTER,
 		 "NODE_GetMessage: hNode: 0x%x\tpMsg: "
 		 "0x%x\tuTimeout: 0x%x\n", hNode, pMsg, uTimeout);
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		goto func_end;
-	}
+
 	hProcessor = hNode->hProcessor;
 	status = PROC_GetState(hProcessor, &procStatus,
 					sizeof(struct DSP_PROCESSORSTATE));
@@ -2118,10 +1974,7 @@ DSP_STATUS NODE_GetStrmMgr(struct NODE_O
 
 	DBC_Require(cRefs > 0);
 
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE))
-		status = DSP_EHANDLE;
-	else
-		*phStrmMgr = hNode->hNodeMgr->hStrmMgr;
+	*phStrmMgr = hNode->hNodeMgr->hStrmMgr;
 
 	return status;
 }
@@ -2131,16 +1984,10 @@ DSP_STATUS NODE_GetStrmMgr(struct NODE_O
  */
 enum NLDR_LOADTYPE NODE_GetLoadType(struct NODE_OBJECT *hNode)
 {
-
 	DBC_Require(cRefs > 0);
 	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
-       if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-               GT_1trace(NODE_debugMask, GT_5CLASS,
-                        "NODE_GetLoadType: Failed. hNode:"
-                         " 0x%x\n", hNode);
-               return -1;
-       } else
-               return hNode->dcdProps.objData.nodeObj.usLoadType;
+
+	return hNode->dcdProps.objData.nodeObj.usLoadType;
 }
 
 /*
@@ -2152,13 +1999,8 @@ u32 NODE_GetTimeout(struct NODE_OBJECT *
 {
 	DBC_Require(cRefs > 0);
 	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
-       if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-               GT_1trace(NODE_debugMask, GT_5CLASS,
-                        "NODE_GetTimeout: Failed. hNode:"
-                         " 0x%x\n", hNode);
-               return 0;
-       } else
-               return hNode->uTimeout;
+
+	return hNode->uTimeout;
 }
 
 /*
@@ -2172,12 +2014,8 @@ enum NODE_TYPE NODE_GetType(struct NODE_
 
 	if (hNode == (struct NODE_OBJECT *) DSP_HGPPNODE)
 		nodeType = NODE_GPP;
-	else {
-                if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE))
-                        nodeType = -1;
-                else
-                        nodeType = hNode->nType;
-	}
+	else
+		nodeType = hNode->nType;
 	return nodeType;
 }
 
@@ -2188,8 +2026,6 @@ enum NODE_TYPE NODE_GetType(struct NODE_
  */
 bool NODE_Init(void)
 {
-	bool fRetVal = true;
-
 	DBC_Require(cRefs >= 0);
 
 	if (cRefs == 0) {
@@ -2197,14 +2033,12 @@ bool NODE_Init(void)
 		GT_create(&NODE_debugMask, "NO");	/* "NO" for NOde */
 	}
 
-	if (fRetVal)
-		cRefs++;
+	cRefs++;
 
 	GT_1trace(NODE_debugMask, GT_5CLASS, "NODE_Init(), ref count: 0x%x\n",
 		 cRefs);
 
-	DBC_Ensure((fRetVal && (cRefs > 0)) || (!fRetVal && (cRefs >= 0)));
-	return fRetVal;
+	return true;
 }
 
 /*
@@ -2214,7 +2048,9 @@ bool NODE_Init(void)
  */
 void NODE_OnExit(struct NODE_OBJECT *hNode, s32 nStatus)
 {
-	DBC_Assert(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE))
+		return;
+
 	/* Set node state to done */
 	NODE_SetState(hNode, NODE_DONE);
 	hNode->nExitStatus = nStatus;
@@ -2250,14 +2086,10 @@ DSP_STATUS NODE_Pause(struct NODE_OBJECT
 
 	GT_1trace(NODE_debugMask, GT_ENTER, "NODE_Pause: hNode: 0x%x\n", hNode);
 
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		goto func_end;
-	} else {
-		nodeType = NODE_GetType(hNode);
-		if (nodeType != NODE_TASK && nodeType != NODE_DAISSOCKET)
-			status = DSP_ENODETYPE;
-	}
+	nodeType = NODE_GetType(hNode);
+	if (nodeType != NODE_TASK && nodeType != NODE_DAISSOCKET)
+		status = DSP_ENODETYPE;
+
 	if (DSP_FAILED(status))
 		goto func_end;
 
@@ -2278,11 +2110,13 @@ DSP_STATUS NODE_Pause(struct NODE_OBJECT
 			if (state != NODE_RUNNING)
 				status = DSP_EWRONGSTATE;
 
+			if (DSP_FAILED(status))
+				goto func_cont;
 			hProcessor = hNode->hProcessor;
 			status = PROC_GetState(hProcessor, &procStatus,
 					sizeof(struct DSP_PROCESSORSTATE));
 			if (DSP_FAILED(status))
-				goto func_end;
+				goto func_cont;
 			/* If processor is in error state then don't attempt
 			    to send the message */
 			if (procStatus.iState == PROC_ERROR) {
@@ -2290,7 +2124,7 @@ DSP_STATUS NODE_Pause(struct NODE_OBJECT
 					"NODE_Pause: proc Status 0x%x\n",
 					procStatus.iState);
 				status = DSP_EFAIL;
-				goto func_end;
+				goto func_cont;
 			}
 			if (DSP_SUCCEEDED(status)) {
 				status = DISP_NodeChangePriority(hNodeMgr->
@@ -2308,6 +2142,7 @@ DSP_STATUS NODE_Pause(struct NODE_OBJECT
 					 " 0x%x\n", hNode);
 			}
 		}
+func_cont:
 		/* End of SYNC_EnterCS */
 		/* Leave critical section */
 		(void)SYNC_LeaveCS(hNodeMgr->hSync);
@@ -2346,10 +2181,7 @@ DSP_STATUS NODE_PutMessage(struct NODE_O
 	GT_3trace(NODE_debugMask, GT_ENTER,
 		 "NODE_PutMessage: hNode: 0x%x\tpMsg: "
 		 "0x%x\tuTimeout: 0x%x\n", hNode, pMsg, uTimeout);
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		goto func_end;
-	}
+
 	hProcessor = hNode->hProcessor;
 	status = PROC_GetState(hProcessor, &procStatus,
 					sizeof(struct DSP_PROCESSORSTATE));
@@ -2433,8 +2265,8 @@ func_end:
  *      Register to be notified on specific events for this node.
  */
 DSP_STATUS NODE_RegisterNotify(struct NODE_OBJECT *hNode, u32 uEventMask,
-			       u32 uNotifyType,
-			       struct DSP_NOTIFICATION *hNotification)
+				u32 uNotifyType,
+				struct DSP_NOTIFICATION *hNotification)
 {
 	struct WMD_DRV_INTERFACE *pIntfFxns;
 	DSP_STATUS status = DSP_SOK;
@@ -2447,24 +2279,21 @@ DSP_STATUS NODE_RegisterNotify(struct NO
 		 "uEventMask: 0x%x\tuNotifyType: 0x%x\thNotification: 0x%x\n",
 		 hNode, uEventMask, uNotifyType, hNotification);
 
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-		status = DSP_EHANDLE;
-	} else {
-		/* Check if event mask is a valid node related event */
-		if (uEventMask & ~(DSP_NODESTATECHANGE |
-		   DSP_NODEMESSAGEREADY))
-			status = DSP_EVALUE;
-
-		/* Check if notify type is valid */
-		if (uNotifyType != DSP_SIGNALEVENT)
-			status = DSP_EVALUE;
+	/* Check if event mask is a valid node related event */
+	if (uEventMask & ~(DSP_NODESTATECHANGE |
+	   DSP_NODEMESSAGEREADY))
+		status = DSP_EVALUE;
+
+	/* Check if notify type is valid */
+	if (uNotifyType != DSP_SIGNALEVENT)
+		status = DSP_EVALUE;
+
+	/* Only one Notification can be registered at a
+	 * time - Limitation */
+	if (uEventMask == (DSP_NODESTATECHANGE |
+	   DSP_NODEMESSAGEREADY))
+		status = DSP_EVALUE;
 
-		/* Only one Notification can be registered at a
-		 * time - Limitation */
-		if (uEventMask == (DSP_NODESTATECHANGE |
-		   DSP_NODEMESSAGEREADY))
-			status = DSP_EVALUE;
-	}
 	if (DSP_SUCCEEDED(status)) {
 		if (uEventMask == DSP_NODESTATECHANGE) {
 			status = NTFY_Register(hNode->hNtfy, hNotification,
@@ -2505,10 +2334,7 @@ DSP_STATUS NODE_Run(struct NODE_OBJECT *
 
 	DBC_Require(cRefs > 0);
 	GT_1trace(NODE_debugMask, GT_ENTER, "NODE_Run: hNode: 0x%x\n", hNode);
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		goto func_end;
-	}
+
 	hProcessor = hNode->hProcessor;
 	status = PROC_GetState(hProcessor, &procStatus,
 					sizeof(struct DSP_PROCESSORSTATE));
@@ -2528,6 +2354,10 @@ DSP_STATUS NODE_Run(struct NODE_OBJECT *
 		goto func_end;
 
 	hNodeMgr = hNode->hNodeMgr;
+	if (!MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 	pIntfFxns = hNodeMgr->pIntfFxns;
 	/* Enter critical section */
 	status = SYNC_EnterCS(hNodeMgr->hSync);
@@ -2626,7 +2456,7 @@ DSP_STATUS NODE_Terminate(struct NODE_OB
 
 	GT_1trace(NODE_debugMask, GT_ENTER,
 		 "NODE_Terminate: hNode: 0x%x\n", hNode);
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+	if (!hNode->hNodeMgr) {
 		status = DSP_EHANDLE;
 		goto func_end;
 	}
@@ -2778,10 +2608,10 @@ static void DeleteNode(struct NODE_OBJEC
 			(struct PROC_OBJECT *)hNode->hProcessor;
 #endif
 	DSP_STATUS status;
-	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
+
 	hNodeMgr = hNode->hNodeMgr;
-       if (!MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE))
-               return;
+	if (!MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE))
+		goto func_end;
 	hXlator = hNode->hXlator;
 	nodeType = NODE_GetType(hNode);
 	if (nodeType != NODE_DEVICE) {
@@ -2793,8 +2623,7 @@ static void DeleteNode(struct NODE_OBJEC
 		if (hNode->hMsgQueue) {
 			pIntfFxns = hNodeMgr->pIntfFxns;
 			(*pIntfFxns->pfnMsgDeleteQueue) (hNode->hMsgQueue);
-                       hNode->hMsgQueue = NULL;
-
+			hNode->hMsgQueue = NULL;
 		}
 		if (hNode->hSyncDone)
 			(void) SYNC_CloseEvent(hNode->hSyncDone);
@@ -2806,7 +2635,7 @@ static void DeleteNode(struct NODE_OBJEC
 				FreeStream(hNodeMgr, stream);
 			}
 			MEM_Free(hNode->inputs);
-                       hNode->inputs = NULL;
+			hNode->inputs = NULL;
 		}
 		if (hNode->outputs) {
 			for (i = 0; i < MaxOutputs(hNode); i++) {
@@ -2814,7 +2643,7 @@ static void DeleteNode(struct NODE_OBJEC
 				FreeStream(hNodeMgr, stream);
 			}
 			MEM_Free(hNode->outputs);
-                       hNode->outputs = NULL;
+			hNode->outputs = NULL;
 		}
 		taskArgs = hNode->createArgs.asa.taskArgs;
 		if (taskArgs.strmInDef) {
@@ -2822,7 +2651,7 @@ static void DeleteNode(struct NODE_OBJEC
 				if (taskArgs.strmInDef[i].szDevice) {
 					MEM_Free(taskArgs.strmInDef[i].
 						szDevice);
-                                       taskArgs.strmInDef[i].szDevice = NULL;
+					taskArgs.strmInDef[i].szDevice = NULL;
 				}
 			}
 			MEM_Free(taskArgs.strmInDef);
@@ -2833,7 +2662,7 @@ static void DeleteNode(struct NODE_OBJEC
 				if (taskArgs.strmOutDef[i].szDevice) {
 					MEM_Free(taskArgs.strmOutDef[i].
 						szDevice);
-                                       taskArgs.strmOutDef[i].szDevice = NULL;
+					taskArgs.strmOutDef[i].szDevice = NULL;
 				}
 			}
 			MEM_Free(taskArgs.strmOutDef);
@@ -2841,8 +2670,8 @@ static void DeleteNode(struct NODE_OBJEC
 		}
 		if (taskArgs.uDSPHeapResAddr) {
 			status = PROC_UnMap(hNode->hProcessor,
-					(void *)taskArgs.uDSPHeapAddr,
-					pr_ctxt);
+					   (void *)taskArgs.uDSPHeapAddr,
+					   pr_ctxt);
 			if (DSP_SUCCEEDED(status)) {
 				GT_0trace(NODE_debugMask, GT_5CLASS,
 					 "DSPProcessor_UnMap succeeded.\n");
@@ -2871,55 +2700,57 @@ static void DeleteNode(struct NODE_OBJEC
 		}
 	}
 	if (nodeType != NODE_MESSAGE) {
-               if (hNode->streamConnect) {
+		if (hNode->streamConnect) {
 			MEM_Free(hNode->streamConnect);
-                       hNode->streamConnect = NULL;
-               }
+			hNode->streamConnect = NULL;
+		}
 	}
-       if (hNode->pstrDevName) {
+	if (hNode->pstrDevName) {
 		MEM_Free(hNode->pstrDevName);
-               hNode->pstrDevName = NULL;
-       }
+		hNode->pstrDevName = NULL;
+	}
 
-       if (hNode->hNtfy) {
+	if (hNode->hNtfy) {
 		NTFY_Delete(hNode->hNtfy);
-               hNode->hNtfy = NULL;
-       }
+		hNode->hNtfy = NULL;
+	}
 
 	/* These were allocated in DCD_GetObjectDef (via NODE_Allocate) */
-       if (hNode->dcdProps.objData.nodeObj.pstrCreatePhaseFxn) {
+	if (hNode->dcdProps.objData.nodeObj.pstrCreatePhaseFxn) {
 		MEM_Free(hNode->dcdProps.objData.nodeObj.pstrCreatePhaseFxn);
-               hNode->dcdProps.objData.nodeObj.pstrCreatePhaseFxn = NULL;
-       }
+		hNode->dcdProps.objData.nodeObj.pstrCreatePhaseFxn = NULL;
+	}
 
-       if (hNode->dcdProps.objData.nodeObj.pstrExecutePhaseFxn) {
+	if (hNode->dcdProps.objData.nodeObj.pstrExecutePhaseFxn) {
 		MEM_Free(hNode->dcdProps.objData.nodeObj.pstrExecutePhaseFxn);
-               hNode->dcdProps.objData.nodeObj.pstrExecutePhaseFxn = NULL;
-       }
+		hNode->dcdProps.objData.nodeObj.pstrExecutePhaseFxn = NULL;
+	}
 
-       if (hNode->dcdProps.objData.nodeObj.pstrDeletePhaseFxn) {
+	if (hNode->dcdProps.objData.nodeObj.pstrDeletePhaseFxn) {
 		MEM_Free(hNode->dcdProps.objData.nodeObj.pstrDeletePhaseFxn);
-               hNode->dcdProps.objData.nodeObj.pstrDeletePhaseFxn = NULL;
-       }
+		hNode->dcdProps.objData.nodeObj.pstrDeletePhaseFxn = NULL;
+	}
 
-       if (hNode->dcdProps.objData.nodeObj.pstrIAlgName) {
+	if (hNode->dcdProps.objData.nodeObj.pstrIAlgName) {
 		MEM_Free(hNode->dcdProps.objData.nodeObj.pstrIAlgName);
-               hNode->dcdProps.objData.nodeObj.pstrIAlgName = NULL;
-       }
+		hNode->dcdProps.objData.nodeObj.pstrIAlgName = NULL;
+	}
 
 	/* Free all SM address translator resources */
-       if (hXlator) {
+	if (hXlator) {
 		(void) CMM_XlatorDelete(hXlator, TRUE);	/* force free */
-               hXlator = NULL;
-       }
-
-       if (hNode->hNldrNode) {
-		hNodeMgr->nldrFxns.pfnFree(hNode->hNldrNode);
-               hNode->hNldrNode = NULL;
-       }
+		hXlator = NULL;
+	}
 
+	if (hNode->hNldrNode) {
+		MEM_Free(hNode->hNldrNode);
+		hNode->hNldrNode = NULL;
+	}
+	hNode->hNodeMgr = NULL;
 	MEM_FreeObject(hNode);
-       hNode = NULL;
+	hNode = NULL;
+func_end:
+	return;
 }
 
 /*
@@ -2944,7 +2775,7 @@ static void DeleteNodeMgr(struct NODE_MG
 					DeleteNode(hNode, NULL);
 
 			DBC_Assert(LST_IsEmpty(hNodeMgr->nodeList));
-			LST_Delete(hNodeMgr->nodeList);
+			MEM_Free(hNodeMgr->nodeList);
 		}
 		if (hNodeMgr->hNtfy)
 			NTFY_Delete(hNodeMgr->hNtfy);
@@ -2990,8 +2821,8 @@ static void DeleteNodeMgr(struct NODE_MG
  *      Fills stream information.
  */
 static void FillStreamConnect(struct NODE_OBJECT *hNode1,
-			     struct NODE_OBJECT *hNode2,
-			     u32 uStream1, u32 uStream2)
+				struct NODE_OBJECT *hNode2,
+				u32 uStream1, u32 uStream2)
 {
 	u32 uStrmIndex;
 	struct DSP_STREAMCONNECT *pStrm1 = NULL;
@@ -3005,7 +2836,7 @@ static void FillStreamConnect(struct NOD
 
 		if (node1Type != NODE_DEVICE) {
 			uStrmIndex = hNode1->uNumInputs +
-				     hNode1->uNumOutputs - 1;
+					hNode1->uNumOutputs - 1;
 			pStrm1 = &(hNode1->streamConnect[uStrmIndex]);
 			pStrm1->cbStruct = sizeof(struct DSP_STREAMCONNECT);
 			pStrm1->uThisNodeStreamIndex = uStream1;
@@ -3065,7 +2896,7 @@ static void FillStreamDef(struct NODE_OB
 	} else {
 		pstrmDef->uNumBufs = DEFAULTNBUFS;
 		pstrmDef->uBufsize = DEFAULTBUFSIZE / hNodeMgr->
-						      uDSPDataMauSize;
+							uDSPDataMauSize;
 		pstrmDef->uSegid = DEFAULTSEGID;
 		pstrmDef->uAlignment = DEFAULTALIGNMENT;
 		pstrmDef->uTimeout = DEFAULTTIMEOUT;
@@ -3122,15 +2953,15 @@ static DSP_STATUS GetFxnAddress(struct N
 	switch (uPhase) {
 	case CREATEPHASE:
 		pstrFxnName = hNode->dcdProps.objData.nodeObj.
-			      pstrCreatePhaseFxn;
+				pstrCreatePhaseFxn;
 		break;
 	case EXECUTEPHASE:
 		pstrFxnName = hNode->dcdProps.objData.nodeObj.
-			      pstrExecutePhaseFxn;
+				pstrExecutePhaseFxn;
 		break;
 	case DELETEPHASE:
 		pstrFxnName = hNode->dcdProps.objData.nodeObj.
-			      pstrDeletePhaseFxn;
+				pstrDeletePhaseFxn;
 		break;
 	default:
 		/* Should never get here */
@@ -3153,7 +2984,6 @@ void GetNodeInfo(struct NODE_OBJECT *hNo
 {
 	u32 i;
 
-	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
 	DBC_Require(pNodeInfo != NULL);
 
 	pNodeInfo->cbStruct = sizeof(struct DSP_NODEINFO);
@@ -3178,9 +3008,9 @@ void GetNodeInfo(struct NODE_OBJECT *hNo
  *      Retrieve node properties.
  */
 static DSP_STATUS GetNodeProps(struct DCD_MANAGER *hDcdMgr,
-			      struct NODE_OBJECT *hNode,
-			      CONST struct DSP_UUID *pNodeId,
-			      struct DCD_GENERICOBJ *pdcdProps)
+				struct NODE_OBJECT *hNode,
+				CONST struct DSP_UUID *pNodeId,
+				struct DCD_GENERICOBJ *pdcdProps)
 {
 	u32 uLen;
 	struct NODE_MSGARGS *pMsgArgs;
@@ -3188,7 +3018,7 @@ static DSP_STATUS GetNodeProps(struct DC
 	enum NODE_TYPE nodeType = NODE_TASK;
 	struct DSP_NDBPROPS *pndbProps = &(pdcdProps->objData.nodeObj.ndbProps);
 	DSP_STATUS status = DSP_SOK;
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 	char szUuid[MAXUUIDLEN];
 #endif
 
@@ -3198,7 +3028,7 @@ static DSP_STATUS GetNodeProps(struct DC
 	if (DSP_SUCCEEDED(status)) {
 		hNode->nType = nodeType = pndbProps->uNodeType;
 
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 		/* Create UUID value to set in registry. */
 		UUID_UuidToString((struct DSP_UUID *)pNodeId, szUuid,
 				 MAXUUIDLEN);
@@ -3212,22 +3042,22 @@ static DSP_STATUS GetNodeProps(struct DC
 			pMsgArgs->uNotifyType = pdcdProps->objData.nodeObj.
 						uMsgNotifyType;
 			pMsgArgs->uMaxMessages = pndbProps->uMessageDepth;
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 			DBG_Trace(DBG_LEVEL7,
 				 "** (node) Max Number of Messages: 0x%x\n",
 				 pMsgArgs->uMaxMessages);
 #endif
 		} else {
 			/* Copy device name */
-                       DBC_Require(pndbProps->acName);
-                       uLen = strlen(pndbProps->acName);
+			DBC_Require(pndbProps->acName);
+			uLen = strlen(pndbProps->acName);
 			DBC_Assert(uLen < MAXDEVNAMELEN);
 			hNode->pstrDevName = MEM_Calloc(uLen + 1, MEM_PAGED);
 			if (hNode->pstrDevName == NULL) {
 				status = DSP_EMEMORY;
 			} else {
-                               strncpy(hNode->pstrDevName,
-					   pndbProps->acName, uLen);
+				strncpy(hNode->pstrDevName,
+					pndbProps->acName, uLen);
 			}
 		}
 	}
@@ -3239,17 +3069,17 @@ static DSP_STATUS GetNodeProps(struct DC
 			pTaskArgs->uStackSize = pndbProps->uStackSize;
 			pTaskArgs->uSysStackSize = pndbProps->uSysStackSize;
 			pTaskArgs->uStackSeg = pndbProps->uStackSeg;
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 			DBG_Trace(DBG_LEVEL7,
-				 "** (node) Priority: 0x%x\n" "** (node) Stack"
-				 " Size: 0x%x words\n" "** (node) System Stack"
-				 " Size: 0x%x words\n" "** (node) Stack"
-				 " Segment: 0x%x\n\n",
-				  "** (node) profile count : 0x%x \n \n",
-				  pTaskArgs->nPriority, pTaskArgs->uStackSize,
-				  pTaskArgs->uSysStackSize,
-				  pTaskArgs->uStackSeg,
-				  pndbProps->uCountProfiles);
+				"** (node) Priority: 0x%x\n" "** (node) Stack"
+				" Size: 0x%x words\n" "** (node) System Stack"
+				" Size: 0x%x words\n" "** (node) Stack"
+				" Segment: 0x%x\n\n",
+				"** (node) profile count : 0x%x \n \n",
+				pTaskArgs->nPriority, pTaskArgs->uStackSize,
+				pTaskArgs->uSysStackSize,
+				pTaskArgs->uStackSeg,
+				pndbProps->uCountProfiles);
 #endif
 		}
 	}
@@ -3302,14 +3132,14 @@ static DSP_STATUS GetProcProps(struct NO
  *  Purpose:
  *      Fetch Node UUID properties from DCD/DOF file.
  */
-DSP_STATUS NODE_GetUUIDProps(DSP_HPROCESSOR hProcessor,
+DSP_STATUS NODE_GetUUIDProps(void *hProcessor,
 			    IN CONST struct DSP_UUID *pNodeId,
 			    OUT struct DSP_NDBPROPS *pNodeProps)
 {
 	struct NODE_MGR *hNodeMgr = NULL;
 	struct DEV_OBJECT *hDevObject;
 	DSP_STATUS status = DSP_SOK;
-	struct DCD_NODEPROPS   dcdNodeProps;
+	struct DCD_NODEPROPS dcdNodeProps;
 	struct DSP_PROCESSORSTATE procStatus;
 
 	DBC_Require(cRefs > 0);
@@ -3340,12 +3170,12 @@ DSP_STATUS NODE_GetUUIDProps(DSP_HPROCES
 		 pNodeId, pNodeProps);
 
 	status = PROC_GetDevObject(hProcessor, &hDevObject);
-	if (DSP_SUCCEEDED(status) && hDevObject != NULL) {
+	if (hDevObject != NULL)
 		status = DEV_GetNodeManager(hDevObject, &hNodeMgr);
-		if (hNodeMgr == NULL) {
-			status = DSP_EHANDLE;
-			goto func_end;
-		}
+
+	if (hNodeMgr == NULL) {
+		status = DSP_EHANDLE;
+		goto func_end;
 	}
 
 	/*
@@ -3452,8 +3282,6 @@ static u32 Ovly(void *pPrivRef, u32 ulDs
 	struct WMD_DEV_CONTEXT *hWmdContext;
 	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
 
-	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
-
 	hNodeMgr = hNode->hNodeMgr;
 
 	ulSize = ulNumBytes / hNodeMgr->uDSPWordSize;
@@ -3462,11 +3290,18 @@ static u32 Ovly(void *pPrivRef, u32 ulDs
 	/* Call new MemCopy function */
 	pIntfFxns = hNodeMgr->pIntfFxns;
 	status = DEV_GetWMDContext(hNodeMgr->hDevObject, &hWmdContext);
-	status = (*pIntfFxns->pfnBrdMemCopy)(hWmdContext, ulDspRunAddr,
-		 ulDspLoadAddr,	ulNumBytes, (u32) nMemSpace);
-
-	if (DSP_SUCCEEDED(status))
-		ulBytes = ulNumBytes;
+	if (DSP_SUCCEEDED(status)) {
+		status = (*pIntfFxns->pfnBrdMemCopy)(hWmdContext, ulDspRunAddr,
+			 ulDspLoadAddr,	ulNumBytes, (u32) nMemSpace);
+		if (DSP_SUCCEEDED(status))
+			ulBytes = ulNumBytes;
+		else
+			pr_debug("%s: failed to copy brd memory, status 0x%x\n"
+						, __func__, status);
+	} else {
+		pr_debug("%s: failed to get WMD context, status 0x%x\n",
+							__func__, status);
+	}
 
 	return ulBytes;
 }
@@ -3485,7 +3320,6 @@ static u32 Write(void *pPrivRef, u32 ulD
 	struct WMD_DEV_CONTEXT *hWmdContext;
 	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
 
-	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
 	DBC_Require(nMemSpace & DBLL_CODE || nMemSpace & DBLL_DATA);
 
 	hNodeMgr = hNode->hNodeMgr;
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/proc.c kernel-power-2.6.28/drivers/dsp/bridge/rmgr/proc.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/proc.c	2011-04-17 17:32:28.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/rmgr/proc.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Processor interface at the driver level.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,92 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== proc.c ========
- *  Description:
- *      Processor interface at the driver level.
- *
- *  Public Functions:
- *      PROC_Attach
- *      PROC_Ctrl
- *      PROC_Detach
- *      PROC_EnumNodes
- *      PROC_GetResourceInfo
- *      PROC_Exit
- *      PROC_FlushMemory
- *      PROC_GetState
- *      PROC_GetProcessorId
- *      PROC_GetTrace
- *      PROC_Init
- *      PROC_Load
- *      PROC_Map
- *      PROC_NotifyClients
- *      PROC_RegisterNotify
- *      PROC_ReserveMemory
- *      PROC_Start
- *      PROC_UnMap
- *      PROC_UnReserveMemory
- *      PROC_InvalidateMemory
-
- *! Revision History
- *! ======== ========
- *! 04-Apr-2007 sh  Added PROC_InvalidateMemory API
- *! 19-Apr-2004 sb  Aligned DMM definitions with Symbian
- *!		 Used MEM_FlushCache instead of OS specific API
- *!		 Integrated Alan's code review updates
- *! 08-Mar-2004 sb  Added the Dynamic Memory Mapping feature
- *! 08-Mar-2004 vp  Added g_pszLastCoff member to PROC_OBJECT.
- *!		 This is required for multiprocessor environment.
- *! 09-Feb-2004 vp  Added PROC_GetProcessorID function
- *! 22-Apr-2003 vp  Fixed issue with the string that stores coff file name
- *! 03-Apr-2003 sb  Fix DEH deregistering bug
- *! 26-Mar-2003 vp  Commented the call to DSP deep sleep in PROC_Start function.
- *! 18-Feb-2003 vp  Code review updates.
- *! 18-Oct-2002 vp  Ported to Linux platform.
- *! 22-May-2002 sg  Do IOCTL-to-PWR translation before calling PWR_SleepDSP.
- *! 14-May-2002 sg  Use CSL_Atoi() instead of atoi().
- *! 13-May-2002 sg  Propagate PWR return codes upwards.
- *! 07-May-2002 sg  Added check for, and call to PWR functions in PROC_Ctrl.
- *! 02-May-2002 sg  Added "nap" mode: put DSP to sleep once booted.
- *! 01-Apr-2002 jeh Assume word addresses in PROC_GetTrace().
- *! 29-Nov-2001 jeh Don't call DEH function if hDehMgr == NULL.
- *! 05-Nov-2001 kc: Updated PROC_RegisterNotify and PROC_GetState to support
- *!		 DEH module.
- *! 09-Oct-2001 jeh Fix number of bytes calculated in PROC_GetTrace().
- *! 11-Sep-2001 jeh Delete MSG manager in PROC_Monitor() to fix memory leak.
- *! 29-Aug-2001 rr: DCD_AutoRegister and IOOnLoaded moved before COD_LoadBase
- *!		 to facilitate the external loading.
- *! 14-Aug-2001 ag  DCD_AutoRegister() now called before IOOnLoaded() fxn.
- *! 21-Jun-2001 rr: MSG_Create is done only the first time.
- *! 02-May-2001 jeh Return failure in PROC_Load if IOOnLoaded function returns
- *!		 error other than E_NOTIMPL.
- *! 03-Apr-2001 sg: Changed DSP_DCD_ENOAUTOREGISTER to DSP_EDCDNOAUTOREGISTER.
- *! 13-Feb-2001 kc: DSP/BIOS Bridge name updates.
- *! 05-Jan-2001 rr: PROC_LOAD MSG_Create error is checked.
- *! 15-Dec-2000 rr: IoOnLoaded is checked for WSX_STATUS. We fail to load
- *!		 if DEV_Create2 fails; ie, no non-RMS targets can be
- *!		 loaded.
- *! 12-Dec-2000 rr: PROC_Start's DEV_Create2 is checked for WSX_STATUS.
- *! 28-Nov-2000 jeh Added call to IO OnLoaded function to PROC_Load().
- *! 29-Nov-2000 rr: Incorporated code review changes.
- *! 03-Nov-2000 rr: Auto_Register happens after PROC_Load.
- *! 06-Oct-2000 rr: Updated to ver 0.9. PROC_Start calls DEV_Create2 and
- *!		 WMD_BRD_STOP is always followed by DEV_Destroy2.
- *! 05-Sep-2000 rr: PROC_GetTrace calculates the Trace symbol for 55 in a
- *!		 different way.
- *! 10-Aug-2000 rr: PROC_NotifyClients, PROC_GetProcessorHandle Added
- *! 07-Aug-2000 rr: PROC_IDLE/SYNCINIT/UNKNOWN state removed.
- *!		 WMD fxns are checked for WSX_STATUS.
- *!		 PROC_Attach does not alter the state of the BRD.
- *!		 PROC_Run removed.
- *! 04-Aug-2000 rr: All the functions return DSP_EHANDLE if proc handle is
- *!		 invalid
- *! 27-Jul-2000 rr: PROC_GetTrace and PROC_Load implemented. Updated to
- *!		 ver 0.8 API.
- *! 06-Jul-2000 rr: Created.
- */
-
 /* ------------------------------------ Host OS */
 #include <dspbridge/host_os.h>
 
@@ -114,7 +30,6 @@
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/cfg.h>
-#include <dspbridge/csl.h>
 #include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/ntfy.h>
@@ -125,7 +40,6 @@
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/cod.h>
 #include <dspbridge/dev.h>
-#include <dspbridge/drv.h>
 #include <dspbridge/procpriv.h>
 #include <dspbridge/dmm.h>
 
@@ -137,7 +51,6 @@
 
 /*  ----------------------------------- Others */
 #include <dspbridge/dbdcd.h>
-#include <dspbridge/dbreg.h>
 #include <dspbridge/msg.h>
 #include <dspbridge/wmdioctl.h>
 #include <dspbridge/drv.h>
@@ -145,11 +58,8 @@
 /*  ----------------------------------- This */
 #include <dspbridge/proc.h>
 #include <dspbridge/pwr.h>
-#include <mach-omap2/omap3-opp.h>
 
-#ifndef RES_CLEANUP_DISABLE
 #include <dspbridge/resourcecleanup.h>
-#endif
 /*  ----------------------------------- Defines, Data Structures, Typedefs */
 #define PROC_SIGNATURE	   0x434F5250	/* "PROC" (in reverse). */
 #define MAXCMDLINELEN       255
@@ -159,8 +69,6 @@
 #define PWR_TIMEOUT	 500	/* Sleep/wake timout in msec */
 #define EXTEND	      "_EXT_END"	/* Extmem end addr in DSP binary */
 
-#define DSP_CACHE_LINE 128
-
 extern char *iva_img;
 
 /*  ----------------------------------- Globals */
@@ -168,6 +76,29 @@ extern char *iva_img;
 static struct GT_Mask PROC_DebugMask = { NULL, NULL };	/* WCD MGR Mask */
 #endif
 
+/* The PROC_OBJECT structure.   */
+struct PROC_OBJECT {
+	struct list_head link;		/* Link to next PROC_OBJECT */
+	u32 dwSignature;		/* Used for object validation */
+	struct DEV_OBJECT *hDevObject;	/* Device this PROC represents */
+	u32 hProcess;			/* Process owning this Processor */
+	struct MGR_OBJECT *hMgrObject;	/* Manager Object Handle */
+	u32 uAttachCount;		/* Processor attach count */
+	u32 uProcessor;			/* Processor number */
+	u32 uTimeout;			/* Time out count */
+	enum DSP_PROCSTATE sState;	/* Processor state */
+	u32 ulUnit;			/* DDSP unit number */
+	bool bIsAlreadyAttached;	/*
+					 * True if the Device below has
+					 * GPP Client attached
+					 */
+	struct NTFY_OBJECT *hNtfy;	/* Manages  notifications */
+	struct WMD_DEV_CONTEXT *hWmdContext;	/* WMD Context Handle */
+	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
+	char *g_pszLastCoff;
+	struct list_head proc_object;
+};
+
 static u32 cRefs;
 
 struct SYNC_CSOBJECT *hProcLock;	/* For critical sections */
@@ -179,47 +110,6 @@ static char **PrependEnvp(char **newEnvp
 			 char *szVar);
 
 /*
- *  ======== PROC_CleanupAllResources =====
- *  Purpose:
- *      Funtion to clean the process resources.
- *      This function is intended to be called when the
- *       processor is in error state
- */
-DSP_STATUS PROC_CleanupAllResources(void)
-{
-	DSP_STATUS dsp_status = DSP_SOK;
-	HANDLE hDrvObject = NULL;
-	struct PROCESS_CONTEXT *pCtxtclosed = NULL;
-	struct PROC_OBJECT *proc_obj_ptr, *temp;
-
-	GT_0trace(PROC_DebugMask, GT_ENTER, "PROC_CleanupAllResources\n");
-
-	dsp_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	if (DSP_FAILED(dsp_status))
-		goto func_end;
-
-	DRV_GetProcCtxtList(&pCtxtclosed, (struct DRV_OBJECT *)hDrvObject);
-
-	while (pCtxtclosed != NULL) {
-		if (current->tgid != pCtxtclosed->pid) {
-			GT_1trace(PROC_DebugMask, GT_5CLASS,
-				 "***Cleanup of "
-				 "process***%d\n", pCtxtclosed->pid);
-			list_for_each_entry_safe(proc_obj_ptr, temp,
-					&pCtxtclosed->processor_list,
-					proc_object) {
-				PROC_Detach(proc_obj_ptr, pCtxtclosed);
-			}
-		}
-		pCtxtclosed = pCtxtclosed->next;
-	}
-
-	WMD_DEH_ReleaseDummyMem();
-func_end:
-	return dsp_status;
-}
-
-/*
  *  ======== PROC_Attach ========
  *  Purpose:
  *      Prepare for communication with a particular DSP processor, and return
@@ -227,7 +117,7 @@ func_end:
  */
 DSP_STATUS
 PROC_Attach(u32 uProcessor, OPTIONAL CONST struct DSP_PROCESSORATTRIN *pAttrIn,
-       OUT DSP_HPROCESSOR *phProcessor, struct PROCESS_CONTEXT *pr_ctxt)
+       void **phProcessor, struct PROCESS_CONTEXT *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct DEV_OBJECT *hDevObject;
@@ -243,6 +133,11 @@ PROC_Attach(u32 uProcessor, OPTIONAL CON
 		 "uProcessor:  0x%x\n\tpAttrIn:  0x%x\n\tphProcessor:"
 		 "0x%x\n", uProcessor, pAttrIn, phProcessor);
 
+	if (pr_ctxt->hProcessor) {
+		*phProcessor = pr_ctxt->hProcessor;
+		return status;
+	}
+
 	/* Get the Driver and Manager Object Handles */
 	status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
 	if (DSP_SUCCEEDED(status)) {
@@ -285,13 +180,13 @@ PROC_Attach(u32 uProcessor, OPTIONAL CON
 	if (pProcObject == NULL) {
 		GT_0trace(PROC_DebugMask, GT_7CLASS,
 			 "PROC_Attach:Out of memeory \n");
-		status = DSP_EFAIL;
+		status = DSP_EMEMORY;
 		goto func_end;
 	}
 	pProcObject->hDevObject = hDevObject;
 	pProcObject->hMgrObject = hMgrObject;
 	pProcObject->uProcessor = devType;
-	/* Store TGID of Caller Process */
+	/* Store TGID instead of process handle */
 	pProcObject->hProcess = current->tgid;
 
 	INIT_LIST_HEAD(&pProcObject->proc_object);
@@ -351,7 +246,8 @@ PROC_Attach(u32 uProcessor, OPTIONAL CON
 				 "Proc Object into DEV, 0x%x!\n", status);
 		}
 		if (DSP_SUCCEEDED(status)) {
-			*phProcessor = (DSP_HPROCESSOR)pProcObject;
+			*phProcessor = (void *)pProcObject;
+			pr_ctxt->hProcessor = *phProcessor;
 			(void)PROC_NotifyClients(pProcObject,
 						 DSP_PROCESSORATTACH);
 			GT_0trace(PROC_DebugMask, GT_1CLASS,
@@ -365,11 +261,6 @@ PROC_Attach(u32 uProcessor, OPTIONAL CON
 			 "storage for notification \n");
 		MEM_FreeObject(pProcObject);
 	}
-#ifndef RES_CLEANUP_DISABLE
-	spin_lock(&pr_ctxt->proc_list_lock);
-	list_add(&pProcObject->proc_object, &pr_ctxt->processor_list);
-	spin_unlock(&pr_ctxt->proc_list_lock);
-#endif
 func_end:
 	DBC_Ensure((status == DSP_EFAIL && *phProcessor == NULL) ||
 		  (DSP_SUCCEEDED(status) &&
@@ -394,8 +285,8 @@ static DSP_STATUS GetExecFile(struct CFG
 		return CFG_GetExecFile(hDevNode, size, execFile);
 	} else if (devType == IVA_UNIT) {
 		if (iva_img) {
-                       len = strlen(iva_img);
-                       strncpy(execFile, iva_img, len + 1);
+			len = strlen(iva_img);
+			strncpy(execFile, iva_img, len + 1);
 			return DSP_SOK;
 		}
 	}
@@ -436,8 +327,8 @@ DSP_STATUS PROC_AutoStart(struct CFG_DEV
 		 "Entered PROC_AutoStart, args:\n\t"
 		 "hDevNode: 0x%x\thDevObject: 0x%x\n", hDevNode, hDevObject);
 	/* Create a Dummy PROC Object */
-	if (DSP_FAILED(CFG_GetObject((u32 *)&hMgrObject,
-	   REG_MGR_OBJECT))) {
+	status = CFG_GetObject((u32 *)&hMgrObject, REG_MGR_OBJECT);
+	if (DSP_FAILED(status)) {
 		GT_0trace(PROC_DebugMask, GT_7CLASS,
 			 "PROC_AutoStart: DSP_FAILED to "
 			 "Get MGR Object\n");
@@ -448,18 +339,18 @@ DSP_STATUS PROC_AutoStart(struct CFG_DEV
 		GT_0trace(PROC_DebugMask, GT_7CLASS,
 			 "PROC_AutoStart: DSP_FAILED "
 			 "to Create a dummy Processor\n");
+		status = DSP_EMEMORY;
 		goto func_end;
 	}
 	GT_0trace(PROC_DebugMask, GT_1CLASS, "NTFY Created \n");
 	pProcObject->hDevObject = hDevObject;
 	pProcObject->hMgrObject = hMgrObject;
 	hProcObject = pProcObject;
-	if (DSP_SUCCEEDED(DEV_GetIntfFxns(hDevObject,
-	   &pProcObject->pIntfFxns))) {
-		if (DSP_SUCCEEDED(DEV_GetWMDContext(hDevObject,
-				 &pProcObject->hWmdContext))) {
-			status = DSP_SOK;
-		} else {
+	status = DEV_GetIntfFxns(hDevObject, &pProcObject->pIntfFxns);
+	if (DSP_SUCCEEDED(status)) {
+		status = DEV_GetWMDContext(hDevObject,
+					&pProcObject->hWmdContext);
+		if (DSP_FAILED(status)) {
 			MEM_FreeObject(hProcObject);
 			GT_0trace(PROC_DebugMask, GT_7CLASS,
 				 "PROC_AutoStart: Failed "
@@ -472,12 +363,16 @@ DSP_STATUS PROC_AutoStart(struct CFG_DEV
 			 "get IntFxns \n");
 	}
 	if (DSP_FAILED(status))
-		goto func_end;
+		goto func_cont;
 
 	/* Stop the Device, put it into standby mode */
 	status = PROC_Stop(hProcObject);
-	if (DSP_FAILED(CFG_GetAutoStart(hDevNode, &dwAutoStart)) ||
-			   !dwAutoStart) {
+
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	status = CFG_GetAutoStart(hDevNode, &dwAutoStart);
+	if (DSP_FAILED(status) || !dwAutoStart) {
 		status = DSP_EFAIL;
 		/* DSP_FAILED to Get s32 Fxn or Wmd Context */
 		GT_0trace(PROC_DebugMask, GT_1CLASS, "PROC_AutoStart: "
@@ -487,8 +382,9 @@ DSP_STATUS PROC_AutoStart(struct CFG_DEV
 	/* Get the default executable for this board... */
 	DEV_GetDevType(hDevObject, (u32 *)&devType);
 	pProcObject->uProcessor = devType;
-	if (DSP_SUCCEEDED(GetExecFile(hDevNode, hDevObject,
-			 sizeof(szExecFile), szExecFile))) {
+	status = GetExecFile(hDevNode, hDevObject, sizeof(szExecFile),
+							szExecFile);
+	if (DSP_SUCCEEDED(status)) {
 		argv[0] = szExecFile;
 		argv[1] = NULL;
 		/* ...and try to load it: */
@@ -509,7 +405,6 @@ DSP_STATUS PROC_AutoStart(struct CFG_DEV
 				  "PROC_AutoStart: DSP_FAILED to Load\n");
 		}
 	} else {
-		status = DSP_EFILE;
 		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_AutoStart: "
 			 "No Exec file found \n");
 	}
@@ -532,7 +427,7 @@ func_end:
  *      Call the WMD_ICOTL Fxn with the Argument This is a Synchronous
  *      Operation. arg can be null.
  */
-DSP_STATUS PROC_Ctrl(DSP_HPROCESSOR hProcessor, u32 dwCmd,
+DSP_STATUS PROC_Ctrl(void *hProcessor, u32 dwCmd,
 		    IN struct DSP_CBDATA *arg)
 {
 	DSP_STATUS status = DSP_SOK;
@@ -544,42 +439,38 @@ DSP_STATUS PROC_Ctrl(DSP_HPROCESSOR hPro
 		 "Entered PROC_Ctrl, args:\n\thProcessor:"
 		 " 0x%x\n\tdwCmd: 0x%x\n\targ: 0x%x\n", hProcessor, dwCmd, arg);
 
-	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		/* intercept PWR deep sleep command */
-		if (dwCmd == WMDIOCTL_DEEPSLEEP) {
-			timeout = arg->cbData;
-			status = PWR_SleepDSP(PWR_DEEPSLEEP, timeout);
-		}
-		/* intercept PWR emergency sleep command */
-		else if (dwCmd == WMDIOCTL_EMERGENCYSLEEP) {
-			timeout = arg->cbData;
-			status = PWR_SleepDSP(PWR_EMERGENCYDEEPSLEEP, timeout);
-		} else if (dwCmd == PWR_DEEPSLEEP) {
-			/* timeout = arg->cbData; */
-			status = PWR_SleepDSP(PWR_DEEPSLEEP, timeout);
-		}
-		/* intercept PWR wake commands */
-		else if (dwCmd == WMDIOCTL_WAKEUP) {
-			timeout = arg->cbData;
-			status = PWR_WakeDSP(timeout);
-		} else if (dwCmd == PWR_WAKEUP) {
-			/* timeout = arg->cbData; */
-			status = PWR_WakeDSP(timeout);
-		} else
-		    if (DSP_SUCCEEDED
-			((*pProcObject->pIntfFxns->pfnDevCntrl)
-				(pProcObject->hWmdContext, dwCmd, arg))) {
-			status = DSP_SOK;
-		} else {
-			status = DSP_EFAIL;
-			GT_0trace(PROC_DebugMask, GT_7CLASS,
-				 "PROC_Ctrl: Failed \n");
-		}
+
+	/* intercept PWR deep sleep command */
+	if (dwCmd == WMDIOCTL_DEEPSLEEP) {
+		timeout = arg->cbData;
+		status = PWR_SleepDSP(PWR_DEEPSLEEP, timeout);
+	}
+	/* intercept PWR emergency sleep command */
+	else if (dwCmd == WMDIOCTL_EMERGENCYSLEEP) {
+		timeout = arg->cbData;
+		status = PWR_SleepDSP(PWR_EMERGENCYDEEPSLEEP, timeout);
+	} else if (dwCmd == PWR_DEEPSLEEP) {
+		/* timeout = arg->cbData; */
+		status = PWR_SleepDSP(PWR_DEEPSLEEP, timeout);
+	}
+	/* intercept PWR wake commands */
+	else if (dwCmd == WMDIOCTL_WAKEUP) {
+		timeout = arg->cbData;
+		status = PWR_WakeDSP(timeout);
+	} else if (dwCmd == PWR_WAKEUP) {
+		/* timeout = arg->cbData; */
+		status = PWR_WakeDSP(timeout);
+	} else
+	    if (DSP_SUCCEEDED
+		((*pProcObject->pIntfFxns->pfnDevCntrl)
+			(pProcObject->hWmdContext, dwCmd, arg))) {
+		status = DSP_SOK;
 	} else {
-		status = DSP_EHANDLE;
+		status = DSP_EFAIL;
 		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Ctrl: InValid Processor Handle \n");
+			 "PROC_Ctrl: Failed \n");
 	}
+
 	GT_1trace(PROC_DebugMask, GT_ENTER, "Exiting PROC_Ctrl, 0x%x\n",
 		 status);
 	return status;
@@ -591,29 +482,23 @@ DSP_STATUS PROC_Ctrl(DSP_HPROCESSOR hPro
  *      Destroys the  Processor Object. Removes the notification from the Dev
  *      List.
  */
-DSP_STATUS PROC_Detach(DSP_HPROCESSOR hProcessor,
-		struct PROCESS_CONTEXT *pr_ctxt)
+DSP_STATUS PROC_Detach(struct PROCESS_CONTEXT *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	struct PROC_OBJECT *pProcObject = NULL;
+
 	DBC_Require(cRefs > 0);
-	GT_1trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Detach, args:\n\t"
-		 "hProcessor:  0x%x\n", hProcessor);
+	GT_0trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Detach\n");
+
+	pProcObject = (struct PROC_OBJECT *)pr_ctxt->hProcessor;
 
 	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-#ifndef RES_CLEANUP_DISABLE
-		if (pr_ctxt) {
-			spin_lock(&pr_ctxt->proc_list_lock);
-			list_del(&pProcObject->proc_object);
-			spin_unlock(&pr_ctxt->proc_list_lock);
-		}
-#endif
-		/* Notify the Client */
-		NTFY_Notify(pProcObject->hNtfy, DSP_PROCESSORDETACH);
-		/* Remove the notification memory */
-		if (pProcObject->hNtfy)
+		if (pProcObject->hNtfy) {
+			/* Notify the Client */
+			NTFY_Notify(pProcObject->hNtfy, DSP_PROCESSORDETACH);
+			/* Remove the notification memory */
 			NTFY_Delete(pProcObject->hNtfy);
-
+		}
 		if (pProcObject->g_pszLastCoff) {
 			MEM_Free(pProcObject->g_pszLastCoff);
 			pProcObject->g_pszLastCoff = NULL;
@@ -623,11 +508,13 @@ DSP_STATUS PROC_Detach(DSP_HPROCESSOR hP
 			(u32)pProcObject);
 		/* Free the Processor Object */
 		MEM_FreeObject(pProcObject);
+		pr_ctxt->hProcessor = NULL;
 	} else {
 		status = DSP_EHANDLE;
 		GT_0trace(PROC_DebugMask, GT_7CLASS,
 			 "PROC_Detach: InValid Processor Handle \n");
 	}
+
 	GT_1trace(PROC_DebugMask, GT_ENTER, "Exiting PROC_Detach, 0x%x\n",
 		 status);
 	return status;
@@ -639,9 +526,9 @@ DSP_STATUS PROC_Detach(DSP_HPROCESSOR hP
  *      Enumerate and get configuration information about nodes allocated
  *      on a DSP processor.
  */
-DSP_STATUS PROC_EnumNodes(DSP_HPROCESSOR hProcessor, OUT DSP_HNODE *aNodeTab,
-               IN u32 uNodeTabSize, OUT u32 *puNumNodes,
-               OUT u32 *puAllocated)
+DSP_STATUS PROC_EnumNodes(void *hProcessor, void **aNodeTab,
+		IN u32 uNodeTabSize, OUT u32 *puNumNodes,
+		OUT u32 *puAllocated)
 {
 	DSP_STATUS status = DSP_EFAIL;
 	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
@@ -657,21 +544,17 @@ DSP_STATUS PROC_EnumNodes(DSP_HPROCESSOR
 			" 0x%x\n\t puNumNodes 0x%x\n\t puAllocated: 0x%x\n",
 			hProcessor, aNodeTab, uNodeTabSize, puNumNodes,
 			puAllocated);
-	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		if (DSP_SUCCEEDED(DEV_GetNodeManager(pProcObject->hDevObject,
-				 &hNodeMgr))) {
-			if (hNodeMgr) {
-				status = NODE_EnumNodes(hNodeMgr, aNodeTab,
-							uNodeTabSize,
-							puNumNodes,
-							puAllocated);
-			}
+
+	if (DSP_SUCCEEDED(DEV_GetNodeManager(pProcObject->hDevObject,
+			 &hNodeMgr))) {
+		if (hNodeMgr) {
+			status = NODE_EnumNodes(hNodeMgr, aNodeTab,
+						uNodeTabSize,
+						puNumNodes,
+						puAllocated);
 		}
-	} else {
-		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_EnumNodes: "
-			 "InValid Processor Handle \n");
 	}
+
 	GT_6trace(PROC_DebugMask, GT_ENTER, "Exit PROC_EnumNodes, args:\n\t"
 			"hProcessor:  0x%x\n\taNodeTab:  0x%x\n\tuNodeTabSize: "
 			" 0x%x\n\t puNumNodes 0x%x\n\t puAllocated: 0x%x\n\t "
@@ -690,11 +573,6 @@ static int memory_sync_page(struct vm_ar
 	unsigned long offset;
 	ssize_t rest;
 
-#ifdef CHECK_DSP_CACHE_LINE
-	if ((start & DSP_CACHE_LINE) || (len & DSP_CACHE_LINE))
-		pr_warning("%s: not aligned: %08lx(%d)\n", __func__,
-			   start, len);
-#endif
 	while (len) {
 		page = follow_page(vma, start, FOLL_GET);
 		if (!page) {
@@ -750,7 +628,6 @@ static int memory_sync_vma(unsigned long
 			break;
 
 		start = vma->vm_end;
-		len -= size;
 	}
 
 	if (!vma)
@@ -759,13 +636,12 @@ static int memory_sync_vma(unsigned long
 	return err;
 }
 
-static DSP_STATUS proc_memory_sync(DSP_HPROCESSOR hProcessor, void *pMpuAddr,
+static DSP_STATUS proc_memory_sync(void *hProcessor, void *pMpuAddr,
 				   u32 ulSize, u32 ulFlags,
 				   enum DSP_FLUSHTYPE FlushMemType)
 {
 	/* Keep STATUS here for future additions to this function */
 	DSP_STATUS status = DSP_SOK;
-	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
 
 	DBC_Require(cRefs > 0);
 	GT_5trace(PROC_DebugMask, GT_ENTER,
@@ -773,13 +649,6 @@ static DSP_STATUS proc_memory_sync(DSP_H
 		  "hProcessor: 0x%x pMpuAddr: 0x%x ulSize 0x%x, ulFlags 0x%x\n",
 		  __func__, hProcessor, pMpuAddr, ulSize, ulFlags);
 
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		GT_1trace(PROC_DebugMask, GT_7CLASS,
-			  "%s: InValid Processor Handle\n", __func__);
-		status = DSP_EHANDLE;
-		goto err_out;
-	}
-
 	down_read(&current->mm->mmap_sem);
 
 	if (memory_sync_vma((u32)pMpuAddr, ulSize, FlushMemType)) {
@@ -789,7 +658,7 @@ static DSP_STATUS proc_memory_sync(DSP_H
 	}
 
 	up_read(&current->mm->mmap_sem);
-err_out:
+
 	GT_2trace(PROC_DebugMask, GT_ENTER,
 		  "Leaving %s [0x%x]", __func__, status);
 
@@ -801,14 +670,11 @@ err_out:
  *  Purpose:
  *     Flush cache
  */
-DSP_STATUS PROC_FlushMemory(DSP_HPROCESSOR hProcessor, void *pMpuAddr,
+DSP_STATUS PROC_FlushMemory(void *hProcessor, void *pMpuAddr,
 			    u32 ulSize, u32 ulFlags)
 {
 	enum DSP_FLUSHTYPE mtype = PROC_WRITEBACK_INVALIDATE_MEM;
 
-	if (ulFlags & 1)
-		mtype = PROC_WRITEBACK_MEM;
-
 	return proc_memory_sync(hProcessor, pMpuAddr, ulSize, ulFlags, mtype);
 }
 
@@ -817,7 +683,7 @@ DSP_STATUS PROC_FlushMemory(DSP_HPROCESS
  *  Purpose:
  *     Invalidates the memory specified
  */
-DSP_STATUS PROC_InvalidateMemory(DSP_HPROCESSOR hProcessor, void *pMpuAddr,
+DSP_STATUS PROC_InvalidateMemory(void *hProcessor, void *pMpuAddr,
 				 u32 ulSize)
 {
 	enum DSP_FLUSHTYPE mtype = PROC_INVALIDATE_MEM;
@@ -830,7 +696,7 @@ DSP_STATUS PROC_InvalidateMemory(DSP_HPR
  *  Purpose:
  *      Enumerate the resources currently available on a processor.
  */
-DSP_STATUS PROC_GetResourceInfo(DSP_HPROCESSOR hProcessor, u32 uResourceType,
+DSP_STATUS PROC_GetResourceInfo(void *hProcessor, u32 uResourceType,
 				OUT struct DSP_RESOURCEINFO *pResourceInfo,
 				u32 uResourceInfoSize)
 {
@@ -849,43 +715,39 @@ DSP_STATUS PROC_GetResourceInfo(DSP_HPRO
 		 "hProcessor:  0x%x\n\tuResourceType:  0x%x\n\tpResourceInfo:"
 		 " 0x%x\n\t uResourceInfoSize 0x%x\n", hProcessor,
 		 uResourceType, pResourceInfo, uResourceInfoSize);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_GetResourceInfo: InValid "
-			 "Processor Handle \n");
-		goto func_end;
-	}
+
 	switch (uResourceType) {
 	case DSP_RESOURCE_DYNDARAM:
 	case DSP_RESOURCE_DYNSARAM:
 	case DSP_RESOURCE_DYNEXTERNAL:
 	case DSP_RESOURCE_DYNSRAM:
-		if (DSP_FAILED(DEV_GetNodeManager(pProcObject->hDevObject,
-		   &hNodeMgr)))
+		status = DEV_GetNodeManager(pProcObject->hDevObject,
+								&hNodeMgr);
+		if (DSP_FAILED(status))
 			goto func_end;
 
-		if (DSP_SUCCEEDED(NODE_GetNldrObj(hNodeMgr, &hNldr))) {
-			if (DSP_SUCCEEDED(NLDR_GetRmmManager(hNldr, &rmm))) {
+		status = NODE_GetNldrObj(hNodeMgr, &hNldr);
+		if (DSP_SUCCEEDED(status)) {
+			status = NLDR_GetRmmManager(hNldr, &rmm);
+			if (DSP_SUCCEEDED(status)) {
 				DBC_Assert(rmm != NULL);
-				status = DSP_EVALUE;
-				if (RMM_stat(rmm,
+				if (!RMM_stat(rmm,
 				   (enum DSP_MEMTYPE)uResourceType,
 				   (struct DSP_MEMSTAT *)&(pResourceInfo->
 				   result.memStat)))
-					status = DSP_SOK;
+					status = DSP_EVALUE;
 			}
 		}
 		break;
 	case DSP_RESOURCE_PROCLOAD:
 		status = DEV_GetIOMgr(pProcObject->hDevObject, &hIOMgr);
-		status = pProcObject->pIntfFxns->pfnIOGetProcLoad(hIOMgr,
-			 (struct DSP_PROCLOADSTAT *)&(pResourceInfo->
-			 result.procLoadStat));
-		if (DSP_FAILED(status)) {
+		if (DSP_SUCCEEDED(status))
+			status = pProcObject->pIntfFxns->pfnIOGetProcLoad(
+				hIOMgr, (struct DSP_PROCLOADSTAT *)&
+				(pResourceInfo->result.procLoadStat));
+		if (DSP_FAILED(status))
 			GT_1trace(PROC_DebugMask, GT_7CLASS,
 			"Error in procLoadStat function 0x%x\n", status);
-		}
 		break;
 	default:
 		status = DSP_EFAIL;
@@ -923,7 +785,7 @@ void PROC_Exit(void)
  *      Return the Dev Object handle for a given Processor.
  *
  */
-DSP_STATUS PROC_GetDevObject(DSP_HPROCESSOR hProcessor,
+DSP_STATUS PROC_GetDevObject(void *hProcessor,
 			     struct DEV_OBJECT **phDevObject)
 {
 	DSP_STATUS status = DSP_EFAIL;
@@ -932,13 +794,8 @@ DSP_STATUS PROC_GetDevObject(DSP_HPROCES
 	DBC_Require(cRefs > 0);
 	DBC_Require(phDevObject != NULL);
 
-	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		*phDevObject = pProcObject->hDevObject;
-		status = DSP_SOK;
-	} else {
-		*phDevObject = NULL;
-		status = DSP_EHANDLE;
-	}
+	*phDevObject = pProcObject->hDevObject;
+	status = DSP_SOK;
 
 	DBC_Ensure((DSP_SUCCEEDED(status) && *phDevObject != NULL) ||
 		   (DSP_FAILED(status) && *phDevObject == NULL));
@@ -951,13 +808,13 @@ DSP_STATUS PROC_GetDevObject(DSP_HPROCES
  *  Purpose:
  *      Report the state of the specified DSP processor.
  */
-DSP_STATUS PROC_GetState(DSP_HPROCESSOR hProcessor,
+DSP_STATUS PROC_GetState(void *hProcessor,
 			OUT struct DSP_PROCESSORSTATE *pProcStatus,
 			u32 uStateInfoSize)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-	BRD_STATUS brdStatus;
+	int brdStatus;
 	struct DEH_MGR *hDehMgr;
 
 	DBC_Require(cRefs > 0);
@@ -967,37 +824,38 @@ DSP_STATUS PROC_GetState(DSP_HPROCESSOR 
 	GT_3trace(PROC_DebugMask, GT_ENTER, "Entering PROC_GetState, args:\n\t"
 		 "pProcStatus: 0x%x\n\thProcessor: 0x%x\n\t uStateInfoSize"
 		 " 0x%x\n", pProcStatus, hProcessor, uStateInfoSize);
-	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		/* First, retrieve BRD state information */
-		if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
-		   (pProcObject->hWmdContext, &brdStatus))) {
-			switch (brdStatus) {
-			case BRD_STOPPED:
-				pProcStatus->iState = PROC_STOPPED;
-				break;
-			case BRD_DSP_HIBERNATION:
-				/* Fall through */
-			case BRD_RUNNING:
-				pProcStatus->iState = PROC_RUNNING;
-				break;
-			case BRD_LOADED:
-				pProcStatus->iState = PROC_LOADED;
-				break;
-			case BRD_ERROR:
-				pProcStatus->iState = PROC_ERROR;
-				break;
-			default:
-				pProcStatus->iState = 0xFF;
-				status = DSP_EFAIL;
-				break;
-			}
-		} else {
+
+	/* First, retrieve BRD state information */
+	status = (*pProcObject->pIntfFxns->pfnBrdStatus)
+			   (pProcObject->hWmdContext, &brdStatus);
+	if (DSP_SUCCEEDED(status)) {
+		switch (brdStatus) {
+		case BRD_STOPPED:
+			pProcStatus->iState = PROC_STOPPED;
+			break;
+		case BRD_SLEEP_TRANSITION:
+		case BRD_DSP_HIBERNATION:
+			/* Fall through */
+		case BRD_RUNNING:
+			pProcStatus->iState = PROC_RUNNING;
+			break;
+		case BRD_LOADED:
+			pProcStatus->iState = PROC_LOADED;
+			break;
+		case BRD_ERROR:
+			pProcStatus->iState = PROC_ERROR;
+			break;
+		default:
+			pProcStatus->iState = 0xFF;
 			status = DSP_EFAIL;
-			GT_0trace(PROC_DebugMask, GT_7CLASS,
-				 "PROC_GetState: General Failure"
-				 " to read the PROC Status \n");
 		}
-		/* Next, retrieve error information, if any */
+	} else {
+		GT_0trace(PROC_DebugMask, GT_7CLASS,
+			 "PROC_GetState: General Failure"
+			 " to read the PROC Status \n");
+	}
+	/* Next, retrieve error information, if any */
+	if (DSP_SUCCEEDED(status)) {
 		status = DEV_GetDehMgr(pProcObject->hDevObject, &hDehMgr);
 		if (DSP_SUCCEEDED(status) && hDehMgr) {
 			status = (*pProcObject->pIntfFxns->pfnDehGetInfo)
@@ -1008,15 +866,10 @@ DSP_STATUS PROC_GetState(DSP_HPROCESSOR 
 					 "retrieve exception info.\n");
 			}
 		} else {
-			status = DSP_EFAIL;
 			GT_0trace(PROC_DebugMask, GT_7CLASS,
 				 "PROC_GetState: Failed to "
 				 "retrieve DEH handle.\n");
 		}
-	} else {
-		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_GetState:InValid Processor Handle \n");
 	}
 	GT_2trace(PROC_DebugMask, GT_ENTER,
 		 "Exiting PROC_GetState, results:\n\t"
@@ -1037,7 +890,7 @@ DSP_STATUS PROC_GetState(DSP_HPROCESSOR 
  *      This call is destructive, meaning the processor is placed in the monitor
  *      state as a result of this function.
  */
-DSP_STATUS PROC_GetTrace(DSP_HPROCESSOR hProcessor, u8 *pBuf, u32 uMaxSize)
+DSP_STATUS PROC_GetTrace(void *hProcessor, u8 *pBuf, u32 uMaxSize)
 {
 	DSP_STATUS status;
 	status = DSP_ENOTIMPL;
@@ -1080,7 +933,7 @@ bool PROC_Init(void)
  *      This will be an OEM-only function, and not part of the DSP/BIOS Bridge
  *      application developer's API.
  */
-DSP_STATUS PROC_Load(DSP_HPROCESSOR hProcessor, IN CONST s32 iArgc,
+DSP_STATUS PROC_Load(void *hProcessor, IN CONST s32 iArgc,
 		    IN CONST char **aArgv, IN CONST char **aEnvp)
 {
 	DSP_STATUS status = DSP_SOK;
@@ -1098,32 +951,31 @@ DSP_STATUS PROC_Load(DSP_HPROCESSOR hPro
 	struct DMM_OBJECT *hDmmMgr;
 	u32 dwExtEnd;
 	u32 uProcId;
-#ifdef DEBUG
-	BRD_STATUS uBrdState;
+#ifdef CONFIG_BRIDGE_DEBUG
+	int uBrdState;
 #endif
+
 #ifdef OPT_LOAD_TIME_INSTRUMENTATION
 	struct timeval tv1;
 	struct timeval tv2;
 #endif
+
+#if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
+	struct dspbridge_platform_data *pdata =
+				omap_dspbridge_dev->dev.platform_data;
+#endif
+
 	DBC_Require(cRefs > 0);
 	DBC_Require(iArgc > 0);
 	DBC_Require(aArgv != NULL);
+
 #ifdef OPT_LOAD_TIME_INSTRUMENTATION
 	do_gettimeofday(&tv1);
 #endif
-#if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
-	struct dspbridge_platform_data *pdata =
-				omap_dspbridge_dev->dev.platform_data;
-#endif
 	GT_2trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Load, args:\n\t"
 		 "hProcessor:  0x%x\taArgv: 0x%x\n", hProcessor, aArgv[0]);
 	/* Call the WMD_BRD_Load Fxn */
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_1CLASS,
-			 "PROC_Load: Invalid Processor Handle..\n");
-		goto func_end;
-	}
+
 	if (pProcObject->bIsAlreadyAttached) {
 		GT_0trace(PROC_DebugMask, GT_7CLASS,
 			 "PROC_Load GPP "
@@ -1229,13 +1081,13 @@ DSP_STATUS PROC_Load(DSP_HPROCESSOR hPro
 				DBC_Assert(pProcObject->g_pszLastCoff == NULL);
 				/* Allocate memory for pszLastCoff */
 				pProcObject->g_pszLastCoff = MEM_Calloc(
-                                       (strlen((char *)aArgv[0]) + 1),
+					(strlen((char *)aArgv[0]) + 1),
 					MEM_PAGED);
 				/* If memory allocated, save COFF file name*/
 				if (pProcObject->g_pszLastCoff) {
-                                       strncpy(pProcObject->g_pszLastCoff,
+					strncpy(pProcObject->g_pszLastCoff,
 						(char *)aArgv[0],
-                                       (strlen((char *)aArgv[0]) + 1));
+						(strlen((char *)aArgv[0]) + 1));
 				}
 			}
 		}
@@ -1251,30 +1103,19 @@ DSP_STATUS PROC_Load(DSP_HPROCESSOR hPro
 			DBC_Assert(DSP_SUCCEEDED(status));
 			DEV_SetMsgMgr(pProcObject->hDevObject, hMsgMgr);
 		}
-		if (status == DSP_ENOTIMPL) {
-			/* It's OK not to have a message manager */
-			status = DSP_SOK;
-		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Set the Device object's message manager */
 		status = DEV_GetIOMgr(pProcObject->hDevObject, &hIOMgr);
 		DBC_Assert(DSP_SUCCEEDED(status));
 		status = (*pProcObject->pIntfFxns->pfnIOOnLoaded)(hIOMgr);
-		if (status == DSP_ENOTIMPL) {
-			/* Ok not to implement this function */
-			status = DSP_SOK;
-		} else {
-			if (DSP_FAILED(status)) {
-				GT_1trace(PROC_DebugMask, GT_7CLASS,
-					  "PROC_Load: Failed to get shared "
-					  "memory or message buffer address "
-					  "from COFF status 0x%x\n", status);
-				status = DSP_EFAIL;
-			}
-		}
+		if (DSP_FAILED(status))
+			GT_1trace(PROC_DebugMask, GT_7CLASS,
+				  "PROC_Load: Failed to get shared "
+				  "memory or message buffer address "
+				  "from COFF status 0x%x\n", status);
+
 	} else {
-		status = DSP_EFAIL;
 		GT_1trace(PROC_DebugMask, GT_7CLASS,
 			  "PROC_Load: DSP_FAILED in "
 			  "MSG_Create status 0x%x\n", status);
@@ -1317,15 +1158,13 @@ DSP_STATUS PROC_Load(DSP_HPROCESSOR hPro
 			 (pProcObject->hWmdContext, BRD_LOADED);
 		if (DSP_SUCCEEDED(status)) {
 			pProcObject->sState = PROC_LOADED;
-			if (pProcObject->hNtfy) {
+			if (pProcObject->hNtfy)
 				PROC_NotifyClients(pProcObject,
 						 DSP_PROCESSORSTATECHANGE);
-			}
 		} else {
 			GT_1trace(PROC_DebugMask, GT_7CLASS,
 				 "PROC_Load, pfnBrdSetState "
 				 "failed: 0x%x\n", status);
-			status = DSP_EFAIL;
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
@@ -1361,7 +1200,7 @@ DSP_STATUS PROC_Load(DSP_HPROCESSOR hPro
 	/* Restore the original argv[0] */
 	MEM_Free(newEnvp);
 	aArgv[0] = pargv0;
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 	if (DSP_SUCCEEDED(status)) {
 		if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
 		   (pProcObject->hWmdContext, &uBrdState))) {
@@ -1372,7 +1211,7 @@ DSP_STATUS PROC_Load(DSP_HPROCESSOR hPro
 	}
 #endif
 func_end:
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 	if (DSP_FAILED(status)) {
 		GT_0trace(PROC_DebugMask, GT_1CLASS, "PROC_Load: "
 			 "Processor Load Failed.\n");
@@ -1401,7 +1240,7 @@ func_end:
  *  Purpose:
  *      Maps a MPU buffer to DSP address space.
  */
-DSP_STATUS PROC_Map(DSP_HPROCESSOR hProcessor, void *pMpuAddr, u32 ulSize,
+DSP_STATUS PROC_Map(void *hProcessor, void *pMpuAddr, u32 ulSize,
 		   void *pReqAddr, void **ppMapAddr, u32 ulMapAttr,
 		   struct PROCESS_CONTEXT *pr_ctxt)
 {
@@ -1412,9 +1251,7 @@ DSP_STATUS PROC_Map(DSP_HPROCESSOR hProc
 	DSP_STATUS status = DSP_SOK;
 	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
 
-#ifndef RES_CLEANUP_DISABLE
        HANDLE        dmmRes;
-#endif
 
 	GT_6trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Map, args:\n\t"
 		 "hProcessor %x, pMpuAddr %x, ulSize %x, pReqAddr %x, "
@@ -1429,12 +1266,6 @@ DSP_STATUS PROC_Map(DSP_HPROCESSOR hProc
 	GT_3trace(PROC_DebugMask, GT_ENTER, "PROC_Map: vaAlign %x, paAlign %x, "
 		 "sizeAlign %x\n", vaAlign, paAlign, sizeAlign);
 
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_Map: "
-			 "InValid Processor Handle \n");
-		goto func_end;
-	}
 	/* Critical section */
 	(void)SYNC_EnterCS(hProcLock);
 	status = DMM_GetHandle(pProcObject, &hDmmMgr);
@@ -1461,18 +1292,11 @@ DSP_STATUS PROC_Map(DSP_HPROCESSOR hProc
 	}
 	(void)SYNC_LeaveCS(hProcLock);
 
-#ifndef RES_CLEANUP_DISABLE
 	if (DSP_SUCCEEDED(status)) {
-		spin_lock(&pr_ctxt->dmm_list_lock);
-
 		DRV_InsertDMMResElement(&dmmRes, pr_ctxt);
 		DRV_UpdateDMMResElement(dmmRes, (u32)pMpuAddr, ulSize,
 				(u32)pReqAddr, (u32)*ppMapAddr, hProcessor);
-
-		spin_unlock(&pr_ctxt->dmm_list_lock);
 	}
-#endif
-func_end:
 	GT_1trace(PROC_DebugMask, GT_ENTER, "Leaving PROC_Map [0x%x]", status);
 	return status;
 }
@@ -1482,7 +1306,7 @@ func_end:
  *  Purpose:
  *      Register to be notified of specific processor events.
  */
-DSP_STATUS PROC_RegisterNotify(DSP_HPROCESSOR hProcessor, u32 uEventMask,
+DSP_STATUS PROC_RegisterNotify(void *hProcessor, u32 uEventMask,
 			      u32 uNotifyType, struct DSP_NOTIFICATION
 			      *hNotification)
 {
@@ -1499,14 +1323,6 @@ DSP_STATUS PROC_RegisterNotify(DSP_HPROC
 		 " 0x%x\n\t hNotification 0x%x\n", hProcessor, uEventMask,
 		 uNotifyType, hNotification);
 
-	/* Check processor handle */
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		GT_1trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_RegsiterNotify Invalid "
-			 "ProcessorHandle 0x%x\n", hProcessor);
-		goto func_end;
-	}
 	/* Check if event mask is a valid processor related event */
 	if (uEventMask & ~(DSP_PROCESSORSTATECHANGE | DSP_PROCESSORATTACH |
 	   DSP_PROCESSORDETACH | DSP_PROCESSORRESTART | DSP_MMUFAULT |
@@ -1551,12 +1367,9 @@ DSP_STATUS PROC_RegisterNotify(DSP_HPROC
 			status = (*pProcObject->pIntfFxns->pfnDehRegisterNotify)
 				 (hDehMgr, uEventMask, uNotifyType,
 				 hNotification);
-			if (DSP_FAILED(status))
-				status = DSP_EFAIL;
 
 		}
 	}
-func_end:
 	return status;
 }
 
@@ -1565,7 +1378,7 @@ func_end:
  *  Purpose:
  *      Reserve a virtually contiguous region of DSP address space.
  */
-DSP_STATUS PROC_ReserveMemory(DSP_HPROCESSOR hProcessor, u32 ulSize,
+DSP_STATUS PROC_ReserveMemory(void *hProcessor, u32 ulSize,
 			     void **ppRsvAddr)
 {
 	struct DMM_OBJECT *hDmmMgr;
@@ -1576,12 +1389,7 @@ DSP_STATUS PROC_ReserveMemory(DSP_HPROCE
 		 "Entered PROC_ReserveMemory, args:\n\t"
 		 "hProcessor: 0x%x ulSize: 0x%x ppRsvAddr: 0x%x\n", hProcessor,
 		 ulSize, ppRsvAddr);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_Map: "
-			 "InValid Processor Handle \n");
-		goto func_end;
-	}
+
 	status = DMM_GetHandle(pProcObject, &hDmmMgr);
 	if (DSP_FAILED(status)) {
 		GT_1trace(PROC_DebugMask, GT_7CLASS, "PROC_ReserveMemory: "
@@ -1591,7 +1399,6 @@ DSP_STATUS PROC_ReserveMemory(DSP_HPROCE
 
 	GT_1trace(PROC_DebugMask, GT_ENTER, "Leaving PROC_ReserveMemory [0x%x]",
 		 status);
-func_end:
 	return status;
 }
 
@@ -1600,24 +1407,19 @@ func_end:
  *  Purpose:
  *      Start a processor running.
  */
-DSP_STATUS PROC_Start(DSP_HPROCESSOR hProcessor)
+DSP_STATUS PROC_Start(void *hProcessor)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
 	struct COD_MANAGER *hCodMgr;	/* Code manager handle    */
 	u32 dwDspAddr;	/* Loaded code's entry point.    */
-#ifdef DEBUG
-	BRD_STATUS uBrdState;
+#ifdef CONFIG_BRIDGE_DEBUG
+	int uBrdState;
 #endif
 	DBC_Require(cRefs > 0);
 	GT_1trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Start, args:\n\t"
 		 "hProcessor:  0x%x\n", hProcessor);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Start :InValid Handle \n");
-		goto func_end;
-	}
+
 	/* Call the WMD_BRD_Start */
 	if (pProcObject->sState != PROC_LOADED) {
 		GT_0trace(PROC_DebugMask, GT_7CLASS,
@@ -1627,7 +1429,6 @@ DSP_STATUS PROC_Start(DSP_HPROCESSOR hPr
 	}
 	status = DEV_GetCodMgr(pProcObject->hDevObject, &hCodMgr);
 	if (DSP_FAILED(status)) {
-		status = DSP_EFAIL;
 		GT_1trace(PROC_DebugMask, GT_7CLASS,
 			 "Processor Start DSP_FAILED "
 			 "in Getting DEV_GetCodMgr status 0x%x\n", status);
@@ -1635,7 +1436,6 @@ DSP_STATUS PROC_Start(DSP_HPROCESSOR hPr
 	}
 	status = COD_GetEntry(hCodMgr, &dwDspAddr);
 	if (DSP_FAILED(status)) {
-		status = DSP_EFAIL;
 		GT_1trace(PROC_DebugMask, GT_7CLASS,
 			 "Processor Start  DSP_FAILED in "
 			 "Getting COD_GetEntry status 0x%x\n", status);
@@ -1644,7 +1444,6 @@ DSP_STATUS PROC_Start(DSP_HPROCESSOR hPr
 	status = (*pProcObject->pIntfFxns->pfnBrdStart)
 		 (pProcObject->hWmdContext, dwDspAddr);
 	if (DSP_FAILED(status)) {
-		status = DSP_EFAIL;
 		GT_0trace(PROC_DebugMask, GT_7CLASS,
 			 "PROC_Start Failed to Start the board\n");
 		goto func_cont;
@@ -1668,13 +1467,12 @@ DSP_STATUS PROC_Start(DSP_HPROCESSOR hPr
 		 * Stop the Processor from running. Put it in STOPPED State */
 		(void)(*pProcObject->pIntfFxns->pfnBrdStop)(pProcObject->
 			hWmdContext);
-		status = DSP_EFAIL;
 		pProcObject->sState = PROC_STOPPED;
 		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_Start "
 			 "Failed to Create the Node Manager\n");
 	}
 func_cont:
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 	if (DSP_SUCCEEDED(status)) {
 		if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
 		   (pProcObject->hWmdContext, &uBrdState))) {
@@ -1697,33 +1495,26 @@ func_end:
  *  Purpose:
  *      Stop a processor running.
  */
-DSP_STATUS PROC_Stop(DSP_HPROCESSOR hProcessor)
+DSP_STATUS PROC_Stop(void *hProcessor)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
 	struct MSG_MGR *hMsgMgr;
 	struct NODE_MGR *hNodeMgr;
-	DSP_HNODE hNode;
+	void *hNode;
 	u32 uNodeTabSize = 1;
 	u32 uNumNodes = 0;
 	u32 uNodesAllocated = 0;
-	BRD_STATUS uBrdState;
+	int uBrdState;
 
 	DBC_Require(cRefs > 0);
 	GT_1trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Stop, args:\n\t"
 		 "hProcessor:  0x%x\n", hProcessor);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Stop :InValid Handle \n");
-		goto func_end;
-	}
+
 	if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
 	   (pProcObject->hWmdContext, &uBrdState))) {
-		/* Clean up all the resources except the current running
-		 * process resources */
 		if (uBrdState == BRD_ERROR)
-			PROC_CleanupAllResources();
+			WMD_DEH_ReleaseDummyMem();
 	}
 	/* check if there are any running nodes */
 	status = DEV_GetNodeManager(pProcObject->hDevObject, &hNodeMgr);
@@ -1754,7 +1545,7 @@ DSP_STATUS PROC_Stop(DSP_HPROCESSOR hPro
 				MSG_Delete(hMsgMgr);
 				DEV_SetMsgMgr(pProcObject->hDevObject, NULL);
 			}
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 			if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->
 			   pfnBrdStatus)(pProcObject->hWmdContext,
 			   &uBrdState))) {
@@ -1771,7 +1562,7 @@ DSP_STATUS PROC_Stop(DSP_HPROCESSOR hPro
 		GT_0trace(PROC_DebugMask, GT_7CLASS,
 			 "PROC_Stop Failed to Stop the processor/device \n");
 	}
-func_end:
+
 	GT_1trace(PROC_DebugMask, GT_ENTER, "Exiting PROC_Stop, status  0x%x\n",
 		 status);
 
@@ -1783,7 +1574,7 @@ func_end:
  *  Purpose:
  *      Removes a MPU buffer mapping from the DSP address space.
  */
-DSP_STATUS PROC_UnMap(DSP_HPROCESSOR hProcessor, void *pMapAddr,
+DSP_STATUS PROC_UnMap(void *hProcessor, void *pMapAddr,
 		struct PROCESS_CONTEXT *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
@@ -1791,59 +1582,44 @@ DSP_STATUS PROC_UnMap(DSP_HPROCESSOR hPr
 	struct DMM_OBJECT *hDmmMgr;
 	u32 vaAlign;
 	u32 sizeAlign;
-#ifndef RES_CLEANUP_DISABLE
+
 	HANDLE	      dmmRes;
-#endif
+
 	GT_2trace(PROC_DebugMask, GT_ENTER,
 		 "Entered PROC_UnMap, args:\n\thProcessor:"
 		 "0x%x pMapAddr: 0x%x\n", hProcessor, pMapAddr);
 
 	vaAlign = PG_ALIGN_LOW((u32) pMapAddr, PG_SIZE_4K);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_UnMap: "
-			 "InValid Processor Handle \n");
-		goto func_end;
-	}
 
 	status = DMM_GetHandle(hProcessor, &hDmmMgr);
-	if (DSP_FAILED(status))
-		goto func_end;
-	/* Critical section */
-	(void)SYNC_EnterCS(hProcLock);
 	if (DSP_FAILED(status)) {
 		GT_1trace(PROC_DebugMask, GT_7CLASS, "PROC_UnMap: "
-			 "Failed to get DMM Mgr handle: 0x%x\n", status);
-	} else {
-		/* Update DMM structures. Get the size to unmap.
-		 This function returns error if the VA is not mapped */
-		status = DMM_UnMapMemory(hDmmMgr, (u32) vaAlign, &sizeAlign);
+			"Failed to get DMM Mgr handle: 0x%x\n", status);
+		goto func_end;
 	}
+
+	/* Critical section */
+	(void)SYNC_EnterCS(hProcLock);
+	/*
+	 * Update DMM structures. Get the size to unmap.
+	 * This function returns error if the VA is not mapped
+	 */
+	status = DMM_UnMapMemory(hDmmMgr, (u32) vaAlign, &sizeAlign);
 	/* Remove mapping from the page tables. */
 	if (DSP_SUCCEEDED(status)) {
 		status = (*pProcObject->pIntfFxns->pfnBrdMemUnMap)
 			 (pProcObject->hWmdContext, vaAlign, sizeAlign);
 	}
 	(void)SYNC_LeaveCS(hProcLock);
-#ifndef RES_CLEANUP_DISABLE
 	GT_1trace(PROC_DebugMask, GT_ENTER,
 		   "PROC_UnMap DRV_GetDMMResElement "
 		   "pMapAddr:[0x%x]", pMapAddr);
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	if (pr_ctxt) {
-		DSP_STATUS rc;
-
-		spin_lock(&pr_ctxt->dmm_list_lock);
-
-		rc = DRV_GetDMMResElement((u32)pMapAddr, &dmmRes, pr_ctxt);
-		if (rc != DSP_ENOTFOUND)
-			DRV_RemoveDMMResElement(dmmRes, pr_ctxt);
-
-		spin_unlock(&pr_ctxt->dmm_list_lock);
-	}
-#endif
+	if (DRV_GetDMMResElement((u32)pMapAddr, &dmmRes, pr_ctxt)
+							!= DSP_ENOTFOUND)
+		DRV_RemoveDMMResElement(dmmRes, pr_ctxt);
 func_end:
 	GT_1trace(PROC_DebugMask, GT_ENTER,
 		 "Leaving PROC_UnMap [0x%x]", status);
@@ -1855,7 +1631,7 @@ func_end:
  *  Purpose:
  *      Frees a previously reserved region of DSP address space.
  */
-DSP_STATUS PROC_UnReserveMemory(DSP_HPROCESSOR hProcessor, void *pRsvAddr)
+DSP_STATUS PROC_UnReserveMemory(void *hProcessor, void *pRsvAddr)
 {
 	struct DMM_OBJECT *hDmmMgr;
 	DSP_STATUS status = DSP_SOK;
@@ -1864,12 +1640,7 @@ DSP_STATUS PROC_UnReserveMemory(DSP_HPRO
 	GT_2trace(PROC_DebugMask, GT_ENTER,
 		 "Entered PROC_UnReserveMemory, args:\n\t"
 		 "hProcessor: 0x%x pRsvAddr: 0x%x\n", hProcessor, pRsvAddr);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_UnMap: "
-			 "InValid Processor Handle \n");
-		goto func_end;
-	}
+
 	status = DMM_GetHandle(pProcObject, &hDmmMgr);
 	if (DSP_FAILED(status))
 		GT_1trace(PROC_DebugMask, GT_7CLASS,
@@ -1881,7 +1652,7 @@ DSP_STATUS PROC_UnReserveMemory(DSP_HPRO
 	GT_1trace(PROC_DebugMask, GT_ENTER,
 		 "Leaving PROC_UnReserveMemory [0x%x]",
 		 status);
-func_end:
+
 	return status;
 }
 
@@ -1907,12 +1678,11 @@ static DSP_STATUS PROC_Monitor(struct PR
 	DSP_STATUS status = DSP_EFAIL;
 	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcObject;
 	struct MSG_MGR *hMsgMgr;
-#ifdef DEBUG
-	BRD_STATUS uBrdState;
+#ifdef CONFIG_BRIDGE_DEBUG
+	int uBrdState;
 #endif
 
 	DBC_Require(cRefs > 0);
-	DBC_Require(MEM_IsValidHandle(pProcObject, PROC_SIGNATURE));
 
 	GT_1trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Monitor, args:\n\t"
 		 "hProcessor: 0x%x\n", hProcObject);
@@ -1931,7 +1701,7 @@ static DSP_STATUS PROC_Monitor(struct PR
 	if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdMonitor)
 	   (pProcObject->hWmdContext))) {
 		status = DSP_SOK;
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 		if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
 		   (pProcObject->hWmdContext, &uBrdState))) {
 			GT_0trace(PROC_DebugMask, GT_1CLASS,
@@ -1949,7 +1719,7 @@ static DSP_STATUS PROC_Monitor(struct PR
 	GT_1trace(PROC_DebugMask, GT_ENTER,
 		 "Exiting PROC_Monitor, status  0x%x\n",
 		 status);
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 	DBC_Ensure((DSP_SUCCEEDED(status) && uBrdState == BRD_IDLE) ||
 		  DSP_FAILED(status));
 #endif
@@ -2007,25 +1777,18 @@ static char **PrependEnvp(char **newEnvp
  *  Purpose:
  *      Notify the processor the events.
  */
-DSP_STATUS PROC_NotifyClients(DSP_HPROCESSOR hProc, u32 uEvents)
+DSP_STATUS PROC_NotifyClients(void *hProc, u32 uEvents)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProc;
 
-	DBC_Require(MEM_IsValidHandle(pProcObject, PROC_SIGNATURE));
 	DBC_Require(IsValidProcEvent(uEvents));
 	DBC_Require(cRefs > 0);
-	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_NotifyClients: "
-			 "InValid Processor Handle \n");
-		goto func_end;
-	}
 
 	NTFY_Notify(pProcObject->hNtfy, uEvents);
 	GT_0trace(PROC_DebugMask, GT_1CLASS,
 		 "PROC_NotifyClients :Signaled. \n");
-func_end:
+
 	return status;
 }
 
@@ -2035,20 +1798,26 @@ func_end:
  *      Notify the processor the events. This includes notifying all clients
  *      attached to a particulat DSP.
  */
-DSP_STATUS PROC_NotifyAllClients(DSP_HPROCESSOR hProc, u32 uEvents)
+DSP_STATUS PROC_NotifyAllClients(void *hProc, u32 uEvents)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProc;
 
-	DBC_Require(MEM_IsValidHandle(pProcObject, PROC_SIGNATURE));
 	DBC_Require(IsValidProcEvent(uEvents));
 	DBC_Require(cRefs > 0);
 
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_NotifyAllClients: "
+			 "InValid Processor Handle \n");
+		goto func_end;
+	}
+
 	DEV_NotifyClients(pProcObject->hDevObject, uEvents);
 
 	GT_0trace(PROC_DebugMask, GT_1CLASS,
 		 "PROC_NotifyAllClients :Signaled. \n");
-
+func_end:
 	return status;
 }
 
@@ -2057,7 +1826,7 @@ DSP_STATUS PROC_NotifyAllClients(DSP_HPR
  *  Purpose:
  *      Retrieves the processor ID.
  */
-DSP_STATUS PROC_GetProcessorId(DSP_HPROCESSOR hProc, u32 *procID)
+DSP_STATUS PROC_GetProcessorId(void *hProc, u32 *procID)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProc;
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/pwr.c kernel-power-2.6.28/drivers/dsp/bridge/rmgr/pwr.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/pwr.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/rmgr/pwr.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * PWR API for controlling DSP power states.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,23 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== PWR.c ========
- *  PWR API for controlling DSP power states.
- *
- *  Public Functions:
- *      PWR_SleepDSP
- *      PWR_WakeDSP
- *
- *! Revision History
- *! ================
- *! 18-Feb-2003 vp  Code review updates.
- *! 18-Oct-2002 vp  Ported to Linux platform.
- *! 22-May-2002 sg  Do PWR-to-IOCTL code mapping in PWR_SleepDSP.
- *! 29-Apr-2002 sg  Initial.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/rmm.c kernel-power-2.6.28/drivers/dsp/bridge/rmgr/rmm.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/rmm.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/rmgr/rmm.c	2011-05-02 22:36:50.000000000 +0100
@@ -14,11 +14,7 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
 /*
- *  ======== rmm.c ========
- *  Description:
- *
  *  This memory manager provides general heap management and arbitrary
  *  alignment for any number of memory segments.
  *
@@ -39,16 +35,6 @@
  *  it through RMM_free. The memory manager prevents DSP code/data that is
  *  overlayed from being overwritten as long as the memory it runs at has
  *  been allocated, and not yet freed.
- *
- *! Revision History
- *! ================
- *! 18-Feb-2003 vp  Code review updates.
- *! 18-Oct-2002 vp  Ported to Linux Platform.
- *! 24-Sep-2002 map Updated from Code Review
- *! 25-Jun-2002 jeh     Free from segid passed to RMM_free().
- *! 24-Apr-2002 jeh     Determine segid based on address in RMM_free(). (No way
- *!                     to keep track of segid with dynamic loader library.)
- *! 16-Oct-2001 jeh     Based on gen tree rm.c. Added support for overlays.
  */
 
 /*  ----------------------------------- DSP/BIOS Bridge */
@@ -84,7 +70,7 @@ struct RMM_Header {
  *  Keeps track of memory occupied by overlay section.
  */
 struct RMM_OvlySect {
-	struct LST_ELEM listElem;
+	struct list_head listElem;
 	u32 addr;		/* Start of memory section */
 	u32 size;		/* Length (target MAUs) of section */
 	s32 page;		/* Memory page */
@@ -161,7 +147,7 @@ DSP_STATUS RMM_alloc(struct RMM_TargetOb
 		}
 		prevSect = sect;
 		sect = (struct RMM_OvlySect *)LST_Next(target->ovlyList,
-			(struct LST_ELEM *)sect);
+			(struct list_head *)sect);
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* No overlap - allocate list element for new section. */
@@ -169,19 +155,19 @@ DSP_STATUS RMM_alloc(struct RMM_TargetOb
 		if (newSect == NULL) {
 			status = DSP_EMEMORY;
 		} else {
-			LST_InitElem((struct LST_ELEM *)newSect);
+			LST_InitElem((struct list_head *)newSect);
 			newSect->addr = addr;
 			newSect->size = size;
 			newSect->page = segid;
 			if (sect == NULL) {
 				/* Put new section at the end of the list */
 				LST_PutTail(target->ovlyList,
-					   (struct LST_ELEM *)newSect);
+					   (struct list_head *)newSect);
 			} else {
 				/* Put new section just before sect */
 				LST_InsertBefore(target->ovlyList,
-						(struct LST_ELEM *)newSect,
-						(struct LST_ELEM *)sect);
+						(struct list_head *)newSect,
+						(struct list_head *)sect);
 			}
 		}
 	}
@@ -268,11 +254,14 @@ DSP_STATUS RMM_create(struct RMM_TargetO
 func_cont:
 	/* Initialize overlay memory list */
 	if (DSP_SUCCEEDED(status)) {
-		target->ovlyList = LST_Create();
+		target->ovlyList = MEM_Calloc(sizeof(struct LST_LIST),
+			MEM_NONPAGED);
 		if (target->ovlyList == NULL) {
 			GT_0trace(RMM_debugMask, GT_6CLASS,
 				 "RMM_create: Memory allocation failed\n");
 			status = DSP_EMEMORY;
+		} else {
+			INIT_LIST_HEAD(&target->ovlyList->head);
 		}
 	}
 
@@ -315,7 +304,7 @@ void RMM_delete(struct RMM_TargetObj *ta
 			MEM_Free(pSect);
 		}
 		DBC_Assert(LST_IsEmpty(target->ovlyList));
-		LST_Delete(target->ovlyList);
+		MEM_Free(target->ovlyList);
 	}
 
 	if (target->freeList != NULL) {
@@ -346,9 +335,6 @@ void RMM_exit(void)
 	GT_1trace(RMM_debugMask, GT_5CLASS, "RMM_exit() ref count: 0x%x\n",
 		 cRefs);
 
-	if (cRefs == 0)
-		MEM_Exit();
-
 	DBC_Ensure(cRefs >= 0);
 }
 
@@ -388,12 +374,12 @@ bool RMM_free(struct RMM_TargetObj *targ
 				DBC_Assert(size == sect->size);
 				/* Remove from list */
 				LST_RemoveElem(target->ovlyList,
-					      (struct LST_ELEM *)sect);
+					      (struct list_head *)sect);
 				MEM_Free(sect);
 				break;
 			}
 			sect = (struct RMM_OvlySect *)LST_Next(target->ovlyList,
-			       (struct LST_ELEM *)sect);
+			       (struct list_head *)sect);
 		}
 		if (sect == NULL)
 			retVal = false;
@@ -407,31 +393,21 @@ bool RMM_free(struct RMM_TargetObj *targ
  */
 bool RMM_init(void)
 {
-	bool retVal = true;
-
 	DBC_Require(cRefs >= 0);
 
 	if (cRefs == 0) {
 		DBC_Assert(!RMM_debugMask.flags);
 		GT_create(&RMM_debugMask, "RM");	/* "RM" for RMm */
 
-		retVal = MEM_Init();
-
-		if (!retVal)
-			MEM_Exit();
-
 	}
 
-	if (retVal)
-		cRefs++;
+	cRefs++;
 
 	GT_1trace(RMM_debugMask, GT_5CLASS,
 		 "RMM_init(), ref count:  0x%x\n",
 		 cRefs);
 
-	DBC_Ensure((retVal && (cRefs > 0)) || (!retVal && (cRefs >= 0)));
-
-	return retVal;
+	return true;
 }
 
 /*
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/strm.c kernel-power-2.6.28/drivers/dsp/bridge/rmgr/strm.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/rmgr/strm.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/rmgr/strm.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * DSP/BIOS Bridge Stream Manager.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,53 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== strm.c ========
- *  Description:
- *      DSP/BIOS Bridge Stream Manager.
- *
- *  Public Functions:
- *      STRM_AllocateBuffer
- *      STRM_Close
- *      STRM_Create
- *      STRM_Delete
- *      STRM_Exit
- *      STRM_FreeBuffer
- *      STRM_GetEventHandle
- *      STRM_GetInfo
- *      STRM_Idle
- *      STRM_Init
- *      STRM_Issue
- *      STRM_Open
- *      STRM_PrepareBuffer
- *      STRM_Reclaim
- *      STRM_RegisterNotify
- *      STRM_Select
- *      STRM_UnprepareBuffer
- *
- *  Notes:
- *
- *! Revision History:
- *! =================
- *! 18-Feb-2003 vp  Code review updates.
- *! 18-Oct-2002 vp  Ported to Linux platform.
- *! 13-Mar-2002 map    pStrm init'd to NULL in STRM_Open to prevent error
- *! 12-Mar-2002 map Changed return var to WSX "wStatus" instead of "status"
- *!		    in DEV and CMM function calls to avoid confusion.
- *!		    Return DSP_SOK instead of S_OK from API fxns.
- *! 12-Mar-2002 map    Changed FAILED(..) to DSP_FAILED(..)
- *! 25-Jan-2002 ag  Allow neg seg ids(e.g. DSP_SHMSEG0) to denote SM.
- *! 15-Nov-2001 ag  Added STRMMODE & SM for DMA/ZCopy streaming.
- *!		 Changed DSP_STREAMINFO to STRM_INFO in STRM_GetInfo().
- *!		 Use strm timeout value for dma flush timeout.
- *! 09-May-2001 jeh Code review cleanup.
- *! 06-Feb-2001 kc  Updated DBC_Ensure in STRM_Select to check timeout.
- *! 23-Oct-2000 jeh Allow NULL STRM_ATTRS passed to STRM_Open() for DLL
- *!		 tests to pass.
- *! 25-Sep-2000 jeh Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -89,11 +44,8 @@
 /*  ----------------------------------- This */
 #include <dspbridge/strm.h>
 
-#ifndef RES_CLEANUP_DISABLE
 #include <dspbridge/cfg.h>
-#include <dspbridge/dbreg.h>
 #include <dspbridge/resourcecleanup.h>
-#endif
 
 /*  ----------------------------------- Defines, Data Structures, Typedefs */
 #define STRM_SIGNATURE      0x4d525453	/* "MRTS" */
@@ -160,27 +112,24 @@ DSP_STATUS STRM_AllocateBuffer(struct ST
 	DSP_STATUS status = DSP_SOK;
 	u32 uAllocated = 0;
 	u32 i;
-#ifndef RES_CLEANUP_DISABLE
+
 	HANDLE hSTRMRes;
-#endif
+
 	DBC_Require(cRefs > 0);
 	DBC_Require(apBuffer != NULL);
 
 	GT_4trace(STRM_debugMask, GT_ENTER, "STRM_AllocateBuffer: hStrm: 0x%x\t"
 		 "uSize: 0x%x\tapBuffer: 0x%x\tuNumBufs: 0x%x\n",
 		 hStrm, uSize, apBuffer, uNumBufs);
-	if (MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
-		/*
-		 * Allocate from segment specified at time of stream open.
-		 */
-		if (uSize == 0)
-			status = DSP_ESIZE;
+	/*
+	 * Allocate from segment specified at time of stream open.
+	 */
+	if (uSize == 0)
+		status = DSP_ESIZE;
 
-	}
-	if (DSP_FAILED(status)) {
-		status = DSP_EHANDLE;
+	if (DSP_FAILED(status))
 		goto func_end;
-	}
+
 	for (i = 0; i < uNumBufs; i++) {
 		DBC_Assert(hStrm->hXlator != NULL);
 		(void)CMM_XlatorAllocBuf(hStrm->hXlator, &apBuffer[i], uSize);
@@ -196,15 +145,13 @@ DSP_STATUS STRM_AllocateBuffer(struct ST
 	if (DSP_FAILED(status))
 		STRM_FreeBuffer(hStrm, apBuffer, uAllocated, pr_ctxt);
 
-#ifndef RES_CLEANUP_DISABLE
 	if (DSP_FAILED(status))
 		goto func_end;
 
 	if (DRV_GetSTRMResElement(hStrm, &hSTRMRes, pr_ctxt) !=
-			DSP_ENOTFOUND) {
-		DRV_ProcUpdateSTRMRes(uNumBufs, hSTRMRes, pr_ctxt);
-	}
-#endif
+			DSP_ENOTFOUND)
+		DRV_ProcUpdateSTRMRes(uNumBufs, hSTRMRes);
+
 func_end:
 	return status;
 }
@@ -221,48 +168,31 @@ DSP_STATUS STRM_Close(struct STRM_OBJECT
 	struct CHNL_INFO chnlInfo;
 	DSP_STATUS status = DSP_SOK;
 
-#ifndef RES_CLEANUP_DISABLE
-    HANDLE	      hSTRMRes;
-#endif
+	HANDLE	      hSTRMRes;
 
 	DBC_Require(cRefs > 0);
 
 	GT_1trace(STRM_debugMask, GT_ENTER, "STRM_Close: hStrm: 0x%x\n", hStrm);
 
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
-		status = DSP_EHANDLE;
-	} else {
-		/* Have all buffers been reclaimed? If not, return
-		 * DSP_EPENDING */
-		pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
-		status = (*pIntfFxns->pfnChnlGetInfo) (hStrm->hChnl, &chnlInfo);
-		DBC_Assert(DSP_SUCCEEDED(status));
-
-		if (chnlInfo.cIOCs > 0 || chnlInfo.cIOReqs > 0) {
-			status = DSP_EPENDING;
-		} else {
 
-			status = DeleteStrm(hStrm);
+	/* Have all buffers been reclaimed? If not, return
+	 * DSP_EPENDING */
+	pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+	status = (*pIntfFxns->pfnChnlGetInfo) (hStrm->hChnl, &chnlInfo);
+	DBC_Assert(DSP_SUCCEEDED(status));
 
-			if (DSP_FAILED(status)) {
-				/* we already validated the handle. */
-				DBC_Assert(status != DSP_EHANDLE);
+	if (chnlInfo.cIOCs > 0 || chnlInfo.cIOReqs > 0)
+		status = DSP_EPENDING;
+	else
+		status = DeleteStrm(hStrm);
 
-				/* make sure we return a documented result */
-				status = DSP_EFAIL;
-			}
-		}
-	}
-#ifndef RES_CLEANUP_DISABLE
 	if (DSP_FAILED(status))
 		goto func_end;
 
 	if (DRV_GetSTRMResElement(hStrm, &hSTRMRes, pr_ctxt) !=
-			DSP_ENOTFOUND) {
+			DSP_ENOTFOUND)
 		DRV_ProcRemoveSTRMResElement(hSTRMRes, pr_ctxt);
-	}
 func_end:
-#endif
 	DBC_Ensure(status == DSP_SOK || status == DSP_EHANDLE ||
 		  status == DSP_EPENDING || status == DSP_EFAIL);
 
@@ -368,37 +298,31 @@ DSP_STATUS STRM_FreeBuffer(struct STRM_O
 	DSP_STATUS status = DSP_SOK;
 	u32 i = 0;
 
-#ifndef RES_CLEANUP_DISABLE
 	HANDLE hSTRMRes = NULL;
-#endif
+
 	DBC_Require(cRefs > 0);
 	DBC_Require(apBuffer != NULL);
 
 	GT_3trace(STRM_debugMask, GT_ENTER, "STRM_FreeBuffer: hStrm: 0x%x\t"
 		 "apBuffer: 0x%x\tuNumBufs: 0x%x\n", hStrm, apBuffer, uNumBufs);
 
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE))
-		status = DSP_EHANDLE;
-
-	if (DSP_SUCCEEDED(status)) {
-		for (i = 0; i < uNumBufs; i++) {
-			DBC_Assert(hStrm->hXlator != NULL);
-			status = CMM_XlatorFreeBuf(hStrm->hXlator, apBuffer[i]);
-			if (DSP_FAILED(status)) {
-				GT_0trace(STRM_debugMask, GT_7CLASS,
-					 "STRM_FreeBuffer: DSP_FAILED"
-					 " to free shared memory.\n");
-				break;
-			}
-			apBuffer[i] = NULL;
+	for (i = 0; i < uNumBufs; i++) {
+		DBC_Assert(hStrm->hXlator != NULL);
+		status = CMM_XlatorFreeBuf(hStrm->hXlator, apBuffer[i]);
+		if (DSP_FAILED(status)) {
+			GT_0trace(STRM_debugMask, GT_7CLASS,
+				 "STRM_FreeBuffer: DSP_FAILED"
+				 " to free shared memory.\n");
+			break;
 		}
+		apBuffer[i] = NULL;
 	}
-#ifndef RES_CLEANUP_DISABLE
-	if (DRV_GetSTRMResElement(hStrm, hSTRMRes, pr_ctxt) !=
-			DSP_ENOTFOUND) {
-		DRV_ProcUpdateSTRMRes(uNumBufs-i, hSTRMRes, pr_ctxt);
+
+	if (DSP_SUCCEEDED(status)) {
+		if (DRV_GetSTRMResElement(hStrm, hSTRMRes, pr_ctxt) !=
+				DSP_ENOTFOUND)
+			DRV_ProcUpdateSTRMRes(uNumBufs-i, hSTRMRes);
 	}
-#endif
 	return status;
 }
 
@@ -423,14 +347,12 @@ DSP_STATUS STRM_GetInfo(struct STRM_OBJE
 	GT_3trace(STRM_debugMask, GT_ENTER, "STRM_GetInfo: hStrm: 0x%x\t"
 		 "pStreamInfo: 0x%x\tuStreamInfoSize: 0x%x\n", hStrm,
 		 pStreamInfo, uStreamInfoSize);
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
-		status = DSP_EHANDLE;
-	} else {
-		if (uStreamInfoSize < sizeof(struct STRM_INFO)) {
-			/* size of users info */
-			status = DSP_ESIZE;
-		}
+
+	if (uStreamInfoSize < sizeof(struct STRM_INFO)) {
+		/* size of users info */
+		status = DSP_ESIZE;
 	}
+
 	if (DSP_FAILED(status))
 		goto func_end;
 
@@ -485,14 +407,11 @@ DSP_STATUS STRM_Idle(struct STRM_OBJECT 
 	GT_2trace(STRM_debugMask, GT_ENTER, "STRM_Idle: hStrm: 0x%x\t"
 		 "fFlush: 0x%x\n", hStrm, fFlush);
 
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
-		status = DSP_EHANDLE;
-	} else {
-		pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+	pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+
+	status = (*pIntfFxns->pfnChnlIdle) (hStrm->hChnl,
+		 hStrm->uTimeout, fFlush);
 
-		status = (*pIntfFxns->pfnChnlIdle) (hStrm->hChnl,
-			 hStrm->uTimeout, fFlush);
-	}
 	return status;
 }
 
@@ -543,31 +462,24 @@ DSP_STATUS STRM_Issue(struct STRM_OBJECT
 	GT_4trace(STRM_debugMask, GT_ENTER, "STRM_Issue: hStrm: 0x%x\tpBuf: "
 		 "0x%x\tulBytes: 0x%x\tdwArg: 0x%x\n", hStrm, pBuf, ulBytes,
 		 dwArg);
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
-		status = DSP_EHANDLE;
-	} else {
-		pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
 
-		if (hStrm->uSegment != 0) {
-			pTmpBuf = CMM_XlatorTranslate(hStrm->hXlator,
-					(void *)pBuf, CMM_VA2DSPPA);
-			if (pTmpBuf == NULL)
-				status = DSP_ETRANSLATE;
+	pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
 
-		}
-		if (DSP_SUCCEEDED(status)) {
-			status = (*pIntfFxns->pfnChnlAddIOReq)
-				 (hStrm->hChnl, pBuf, ulBytes, ulBufSize,
-				 (u32) pTmpBuf, dwArg);
-		}
-		if (DSP_FAILED(status)) {
-			if (status == CHNL_E_NOIORPS)
-				status = DSP_ESTREAMFULL;
-			else
-				status = DSP_EFAIL;
+	if (hStrm->uSegment != 0) {
+		pTmpBuf = CMM_XlatorTranslate(hStrm->hXlator,
+				(void *)pBuf, CMM_VA2DSPPA);
+		if (pTmpBuf == NULL)
+			status = DSP_ETRANSLATE;
 
-		}
 	}
+	if (DSP_SUCCEEDED(status)) {
+		status = (*pIntfFxns->pfnChnlAddIOReq)
+			 (hStrm->hChnl, pBuf, ulBytes, ulBufSize,
+			 (u32) pTmpBuf, dwArg);
+	}
+	if (status == CHNL_E_NOIORPS)
+		status = DSP_ESTREAMFULL;
+
 	return status;
 }
 
@@ -578,22 +490,20 @@ DSP_STATUS STRM_Issue(struct STRM_OBJECT
  *      XDAIS socket node on the DSP.
  */
 DSP_STATUS STRM_Open(struct NODE_OBJECT *hNode, u32 uDir, u32 uIndex,
-		    IN struct STRM_ATTR *pAttr,
-		    OUT struct STRM_OBJECT **phStrm,
-		    struct PROCESS_CONTEXT *pr_ctxt)
+		IN struct STRM_ATTR *pAttr,
+		OUT struct STRM_OBJECT **phStrm,
+		struct PROCESS_CONTEXT *pr_ctxt)
 {
 	struct STRM_MGR *hStrmMgr;
 	struct WMD_DRV_INTERFACE *pIntfFxns;
 	u32 ulChnlId;
 	struct STRM_OBJECT *pStrm = NULL;
-	CHNL_MODE uMode;
+	short int uMode;
 	struct CHNL_ATTRS chnlAttrs;
 	DSP_STATUS status = DSP_SOK;
 	struct CMM_OBJECT *hCmmMgr = NULL;	/* Shared memory manager hndl */
 
-#ifndef RES_CLEANUP_DISABLE
-	HANDLE              hSTRMRes;
-#endif
+	HANDLE hSTRMRes;
 
 	DBC_Require(cRefs > 0);
 	DBC_Require(phStrm != NULL);
@@ -724,14 +634,12 @@ func_cont:
 				  status);
 		}
 	}
-	if (DSP_SUCCEEDED(status))
+	if (DSP_SUCCEEDED(status)) {
 		*phStrm = pStrm;
-	else
+		DRV_ProcInsertSTRMResElement(*phStrm, &hSTRMRes, pr_ctxt);
+	} else {
 		(void)DeleteStrm(pStrm);
-
-#ifndef RES_CLEANUP_DISABLE
-	DRV_ProcInsertSTRMResElement(*phStrm, &hSTRMRes, pr_ctxt);
-#endif
+	}
 
 	 /* ensure we return a documented error code */
 	DBC_Ensure((DSP_SUCCEEDED(status) &&
@@ -765,10 +673,6 @@ DSP_STATUS STRM_Reclaim(struct STRM_OBJE
 		 "\tpulBytes: 0x%x\tpdwArg: 0x%x\n", hStrm, pBufPtr, pulBytes,
 		 pdwArg);
 
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		goto func_end;
-	}
 	pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
 
 	status = (*pIntfFxns->pfnChnlGetIOC)(hStrm->hChnl, hStrm->uTimeout,
@@ -820,7 +724,6 @@ DSP_STATUS STRM_Reclaim(struct STRM_OBJE
 		}
 		*pBufPtr = chnlIOC.pBuf;
 	}
-func_end:
 	/* ensure we return a documented return code */
 	DBC_Ensure(DSP_SUCCEEDED(status) || status == DSP_EHANDLE ||
 		  status == DSP_ETIMEOUT || status == DSP_ETRANSLATE ||
@@ -847,9 +750,8 @@ DSP_STATUS STRM_RegisterNotify(struct ST
 		 "STRM_RegisterNotify: hStrm: 0x%x\t"
 		 "uEventMask: 0x%x\tuNotifyType: 0x%x\thNotification: 0x%x\n",
 		 hStrm, uEventMask, uNotifyType, hNotification);
-	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
-		status = DSP_EHANDLE;
-	} else if ((uEventMask & ~((DSP_STREAMIOCOMPLETION) |
+
+	if ((uEventMask & ~((DSP_STREAMIOCOMPLETION) |
 		 DSP_STREAMDONE)) != 0) {
 		status = DSP_EVALUE;
 	} else {
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/services/cfg.c kernel-power-2.6.28/drivers/dsp/bridge/services/cfg.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/services/cfg.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/services/cfg.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implementation of platform specific config services.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,64 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== cfgce.c ========
- *  Purpose:
- *      Implementation of platform specific config services.
- *
- *  Private Functions:
- *      CFG_Exit
- *      CFG_GetAutoStart
- *      CFG_GetDevObject
- *      CFG_GetDSPResources
- *      CFG_GetExecFile
- *      CFG_GetHostResources
- *      CFG_GetObject
- *      CFG_Init
- *      CFG_SetDevObject
- *      CFG_SetObject
- *
- *
- *! Revision History:
- *! ================
- *! 26-Arp-2004 hp  Support for handling more than one Device.
- *! 26-Feb-2003 kc  Removed unused CFG fxns.
- *! 10-Nov-2000 rr: CFG_GetBoardName local var initialized.
- *! 30-Oct-2000 kc: Changed local var. names to use Hungarian notation.
- *! 10-Aug-2000 rr: Cosmetic changes.
- *! 26-Jul-2000 rr: Added CFG_GetDCDName. CFG_Get/SetObject(based on a flag)
- *!                  replaces CFG_GetMgrObject & CFG_SetMgrObject.
- *! 17-Jul-2000 rr: Added CFG_GetMgrObject & CFG_SetMgrObject.
- *! 03-Feb-2000 rr: Module init/exit is handled by SERVICES Init/Exit.
- *!		    GT Changes.
- *! 31-Jan-2000 rr: Comments and bugfixes:  modified after code review
- *! 07-Jan-2000 rr: CFG_GetBoardName Ensure class checks strlen of the
- *!                 read value from the registry against the passed in BufSize;
- *!                 CFG_GetZLFile,CFG_GetWMDFileName and
- *!                 CFG_GetExecFile also modified same way.
- *! 06-Jan-2000 rr: CFG_GetSearchPath & CFG_GetWinBRIDGEDir removed.
- *! 09-Dec-1999 rr: CFG_SetDevObject stores the DevNodeString pointer.
- *! 03-Dec-1999 rr: CFG_GetDevObject reads stored DevObject from Registry.
- *!                 CFG_GetDevNode reads the Devnodestring from the registry.
- *!                 CFG_SetDevObject stores the registry path as
- *!                 DevNodestring in the registry.
- *! 02-Dec-1999 rr: CFG_debugMask is declared static now. stdwin.h included
- *! 22-Nov-1999 kc: Added windows.h to remove warnings.
- *! 25-Oct-1999 rr: CFG_GetHostResources reads the HostResource structure
- *!                 from the registry which was set by the DRV Request
- *!                 Resources.
- *! 15-Oct-1999 rr: Changes in CFG_SetPrivateDword & HostResources reflecting
- *!                 changes for  drv.h resource structure and wsxreg.h new
- *!                 entry(DevObject) Hard coded entries removed for those items
- *! 08-Oct-1999 rr: CFG_SetPrivateDword modified. it sets devobject into the
- *!                 registry. CFG_Get HostResources modified for opening up
- *!                 two mem winodws.
- *! 24-Sep-1999 rr: CFG_GetHostResources uses hardcoded Registry calls,uses NT
- *!                 type of Resource Structure.
- *! 19-Jul-1999 a0216266: Stubbed from cfgnt.c.
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
@@ -82,18 +26,13 @@
 #include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/reg.h>
 
-/*  ----------------------------------- Others */
-#include <dspbridge/dbreg.h>
-
 /*  ----------------------------------- This */
 #include <dspbridge/cfg.h>
-#include <dspbridge/list.h>
 
 struct DRV_EXT {
-	struct LST_ELEM link;
+	struct list_head link;
 	char szString[MAXREGPATHLENGTH];
 };
 
@@ -131,12 +70,12 @@ DSP_STATUS CFG_GetAutoStart(struct CFG_D
 	if (!pdwAutoStart)
 		status = CFG_E_INVALIDPOINTER;
 	if (DSP_SUCCEEDED(status)) {
-		status = REG_GetValue(NULL, (char *)hDevNode, AUTOSTART,
-				     (u8 *)pdwAutoStart, &dwBufSize);
+		status = REG_GetValue(AUTOSTART, (u8 *)pdwAutoStart,
+				      &dwBufSize);
 		if (DSP_FAILED(status))
 			status = CFG_E_RESOURCENOTAVAIL;
 	}
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 	if (DSP_SUCCEEDED(status)) {
 		GT_0trace(CFG_debugMask, GT_1CLASS,
 			 "CFG_GetAutoStart SUCCESS \n");
@@ -173,20 +112,19 @@ DSP_STATUS CFG_GetDevObject(struct CFG_D
 	if (DSP_SUCCEEDED(status)) {
 
 		/* check the device string and then call the REG_SetValue*/
-               if (!(strcmp((char *)((struct DRV_EXT *)hDevNode)->szString,
+		if (!(strcmp((char *)((struct DRV_EXT *)hDevNode)->szString,
 							"TIOMAP1510"))) {
 			GT_0trace(CFG_debugMask, GT_1CLASS,
 				  "Fetching DSP Device from "
 				  "Registry \n");
-			status = REG_GetValue(NULL, (char *)hDevNode,
-					      "DEVICE_DSP",
-					      (u8 *)pdwValue, &dwBufSize);
+			status = REG_GetValue("DEVICE_DSP", (u8 *)pdwValue,
+					      &dwBufSize);
 		} else {
 			GT_0trace(CFG_debugMask, GT_6CLASS,
 				  "Failed to Identify the Device to Fetch \n");
 		}
 	}
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 	if (DSP_SUCCEEDED(status)) {
 		GT_1trace(CFG_debugMask, GT_1CLASS,
 			  "CFG_GetDevObject SUCCESS DevObject"
@@ -213,15 +151,13 @@ DSP_STATUS CFG_GetDSPResources(struct CF
 		  "Entered CFG_GetDSPResources, args: "
 		  "\n\thDevNode:  0x%x\n\tpDSPResTable:  0x%x\n",
 		  hDevNode, pDSPResTable);
-	if (!hDevNode) {
+	if (!hDevNode)
 		status = CFG_E_INVALIDHDEVNODE;
-	} else if (!pDSPResTable) {
+	else if (!pDSPResTable)
 		status = CFG_E_INVALIDPOINTER;
-	} else {
-		status = REG_GetValue(NULL, CONFIG, DSPRESOURCES,
-				     (u8 *)pDSPResTable,
-				     &dwResSize);
-	}
+	else
+		status = REG_GetValue(DSPRESOURCES, (u8 *)pDSPResTable,
+					&dwResSize);
 	if (DSP_SUCCEEDED(status)) {
 		GT_0trace(CFG_debugMask, GT_1CLASS,
 			  "CFG_GetDSPResources SUCCESS\n");
@@ -230,7 +166,7 @@ DSP_STATUS CFG_GetDSPResources(struct CF
 		GT_0trace(CFG_debugMask, GT_6CLASS,
 			  "CFG_GetDSPResources Failed \n");
 	}
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 	/* assert that resource values are reasonable */
 	DBC_Assert(pDSPResTable->uChipType < 256);
 	DBC_Assert(pDSPResTable->uWordSize > 0);
@@ -257,20 +193,18 @@ DSP_STATUS CFG_GetExecFile(struct CFG_DE
 		  ulBufSize, pstrExecFile);
 	if (!hDevNode)
 		status = CFG_E_INVALIDHDEVNODE;
-
-	if (!pstrExecFile)
+	else if (!pstrExecFile)
 		status = CFG_E_INVALIDPOINTER;
 
 	if (DSP_SUCCEEDED(status)) {
-		status = REG_GetValue(NULL, (char *)hDevNode, DEFEXEC,
-				     (u8 *)pstrExecFile, &cExecSize);
+		status = REG_GetValue(DEFEXEC, (u8 *)pstrExecFile, &cExecSize);
 		if (DSP_FAILED(status))
 			status = CFG_E_RESOURCENOTAVAIL;
 		else if (cExecSize > ulBufSize)
 			status = DSP_ESIZE;
 
 	}
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 	if (DSP_SUCCEEDED(status)) {
 		GT_1trace(CFG_debugMask, GT_1CLASS,
 			  "CFG_GetExecFile SUCCESS Exec File"
@@ -281,7 +215,7 @@ DSP_STATUS CFG_GetExecFile(struct CFG_DE
 	}
 #endif
 	DBC_Ensure(((status == DSP_SOK) &&
-                 (strlen(pstrExecFile) <= ulBufSize)) || (status != DSP_SOK));
+		(strlen(pstrExecFile) <= ulBufSize)) || (status != DSP_SOK));
 	return status;
 }
 
@@ -307,13 +241,12 @@ DSP_STATUS CFG_GetHostResources(struct C
 
 	if (DSP_SUCCEEDED(status)) {
 		dwBufSize = sizeof(struct CFG_HOSTRES);
-		if (DSP_FAILED(REG_GetValue(NULL, (char *)hDevNode,
-			       CURRENTCONFIG,
-			      (u8 *)pHostResTable, &dwBufSize))) {
+		if (DSP_FAILED(REG_GetValue(CURRENTCONFIG, (u8 *)pHostResTable,
+					    &dwBufSize))) {
 			status = CFG_E_RESOURCENOTAVAIL;
 		}
 	}
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 	if (DSP_SUCCEEDED(status)) {
 		GT_0trace(CFG_debugMask, GT_1CLASS,
 			  "CFG_GetHostResources SUCCESS \n");
@@ -341,14 +274,14 @@ DSP_STATUS CFG_GetObject(OUT u32 *pdwVal
 	dwBufSize = sizeof(pdwValue);
 	switch (dwType) {
 	case (REG_DRV_OBJECT):
-		status = REG_GetValue(NULL, CONFIG, DRVOBJECT,
-				     (u8 *)pdwValue,
-				     &dwBufSize);
+		status = REG_GetValue(DRVOBJECT, (u8 *)pdwValue, &dwBufSize);
+		if (DSP_FAILED(status))
+			status = CFG_E_RESOURCENOTAVAIL;
 		break;
 	case (REG_MGR_OBJECT):
-		status = REG_GetValue(NULL, CONFIG, MGROBJECT,
-				     (u8 *)pdwValue,
-				     &dwBufSize);
+		status = REG_GetValue(MGROBJECT, (u8 *)pdwValue, &dwBufSize);
+		if (DSP_FAILED(status))
+			status = CFG_E_RESOURCENOTAVAIL;
 		break;
 	default:
 		break;
@@ -358,7 +291,6 @@ DSP_STATUS CFG_GetObject(OUT u32 *pdwVal
 			  "CFG_GetObject SUCCESS DrvObject: "
 			  "0x%x\n ", *pdwValue);
 	} else {
-		status = CFG_E_RESOURCENOTAVAIL;
 		*pdwValue = 0;
 		GT_0trace(CFG_debugMask, GT_6CLASS, "CFG_GetObject Failed \n");
 	}
@@ -386,8 +318,8 @@ bool CFG_Init(void)
 	dspResources.aMemDesc[0].uMemType = 0;
 	dspResources.aMemDesc[0].ulMin = 0;
 	dspResources.aMemDesc[0].ulMax = 0;
-	if (DSP_SUCCEEDED(REG_SetValue(NULL, CONFIG, DSPRESOURCES, REG_BINARY,
-			 (u8 *)&dspResources, sizeof(struct CFG_DSPRES)))) {
+	if (DSP_SUCCEEDED(REG_SetValue(DSPRESOURCES, (u8 *)&dspResources,
+				       sizeof(struct CFG_DSPRES)))) {
 		GT_0trace(CFG_debugMask, GT_5CLASS,
 			  "Initialized DSP resources in "
 			  "Registry \n");
@@ -417,25 +349,17 @@ DSP_STATUS CFG_SetDevObject(struct CFG_D
 	if (DSP_SUCCEEDED(status)) {
 		/* Store the WCD device object in the Registry */
 
-               if (!(strcmp((char *)hDevNode, "TIOMAP1510"))) {
+		if (!(strcmp((char *)hDevNode, "TIOMAP1510"))) {
 			GT_0trace(CFG_debugMask, GT_1CLASS,
 				  "Registering the DSP Device \n");
-			status = REG_SetValue(NULL, (char *)hDevNode,
-				  "DEVICE_DSP", REG_DWORD,\
-				  (u8 *)&dwValue, dwBuffSize);
-			if (DSP_SUCCEEDED(status)) {
-				dwBuffSize = sizeof(hDevNode);
-				status = REG_SetValue(NULL,
-					  (char *)hDevNode, "DEVNODESTRING_DSP",
-					  REG_DWORD, (u8 *)&hDevNode,
-					  dwBuffSize);
-			}
+			status = REG_SetValue("DEVICE_DSP", (u8 *)&dwValue,
+						dwBuffSize);
 		} else {
 			GT_0trace(CFG_debugMask, GT_6CLASS,
 				  "Failed to Register Device \n");
 		}
 	}
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 	if (DSP_SUCCEEDED(status)) {
 		GT_0trace(CFG_debugMask, GT_1CLASS,
 			  "CFG_SetDevObject SUCCESS \n");
@@ -462,17 +386,15 @@ DSP_STATUS CFG_SetObject(u32 dwValue, u3
 	dwBuffSize = sizeof(dwValue);
 	switch (dwType) {
 	case (REG_DRV_OBJECT):
-		status = REG_SetValue(NULL, CONFIG, DRVOBJECT, REG_DWORD,
-			 (u8 *)&dwValue, dwBuffSize);
+		status = REG_SetValue(DRVOBJECT, (u8 *)&dwValue, dwBuffSize);
 		break;
 	case (REG_MGR_OBJECT):
-		status = REG_SetValue(NULL, CONFIG, MGROBJECT, REG_DWORD,
-			 (u8 *) &dwValue, dwBuffSize);
+		status = REG_SetValue(MGROBJECT, (u8 *) &dwValue, dwBuffSize);
 		break;
 	default:
 		break;
 	}
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 	if (DSP_SUCCEEDED(status))
 		GT_0trace(CFG_debugMask, GT_1CLASS, "CFG_SetObject SUCCESS \n");
 	else
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/services/clk.c kernel-power-2.6.28/drivers/dsp/bridge/services/clk.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/services/clk.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/services/clk.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Clock and Timer services.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,24 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== clk.c ========
- *  Purpose:
- *      Clock and Timer services.
- *
- *  Public Functions:
- *      CLK_Exit
- *      CLK_Init
- *	CLK_Enable
- *	CLK_Disable
- *	CLK_GetRate
- *	CLK_Set_32KHz
- *! Revision History:
- *! ================
- *! 08-May-2007 rg: moved all clock functions from sync module.
- *		    And added CLK_Set_32KHz, CLK_Set_SysClk.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -45,22 +29,22 @@
 #include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/mem.h>
 
 /*  ----------------------------------- This */
 #include <dspbridge/clk.h>
-#include <dspbridge/util.h>
-
 
 /*  ----------------------------------- Defines, Data Structures, Typedefs */
 
 typedef volatile unsigned long  REG_UWORD32;
 
-#define SSI_Base        0x48058000
-
-#define SSI_BASE                     IO_ADDRESS(SSI_Base)
-
+#define OMAP_SSI_OFFSET			0x58000
+#define OMAP_SSI_SIZE			0x1000
+#define OMAP_SSI_SYSCONFIG_OFFSET	0x10
+
+#define SSI_AUTOIDLE			(1 << 0)
+#define SSI_SIDLE_SMARTIDLE		(2 << 3)
+#define SSI_MIDLE_NOIDLE		(1 << 12)
 
 struct SERVICES_Clk_t {
 	struct clk *clk_handle;
@@ -194,9 +178,7 @@ DSP_STATUS CLK_Enable(IN enum SERVICES_C
 
 	pClk = SERVICES_Clks[clk_id].clk_handle;
 	if (pClk) {
-		if (clk_enable(pClk) == 0x0) {
-			/* Success ? */
-		} else {
+		if (clk_enable(pClk)) {
 			pr_err("CLK_Enable: failed to Enable CLK %s, "
 					"CLK dev id = %d\n",
 					SERVICES_Clks[clk_id].clk_name,
@@ -230,8 +212,7 @@ DSP_STATUS CLK_Set_32KHz(IN enum SERVICE
 	DSP_STATUS status = DSP_SOK;
 	struct clk *pClk;
 	struct clk *pClkParent;
-	enum SERVICES_ClkId sys_32k_id = SERVICESCLK_sys_32k_ck;
-	pClkParent =  SERVICES_Clks[sys_32k_id].clk_handle;
+	pClkParent =  SERVICES_Clks[SERVICESCLK_sys_32k_ck].clk_handle;
 
 	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
 	GT_2trace(CLK_debugMask, GT_6CLASS, "CLK_Set_32KHz: CLK %s, "
@@ -241,8 +222,8 @@ DSP_STATUS CLK_Set_32KHz(IN enum SERVICE
 	pClk = SERVICES_Clks[clk_id].clk_handle;
 	if (pClk) {
 		if (!(clk_set_parent(pClk, pClkParent) == 0x0)) {
-		       GT_2trace(CLK_debugMask, GT_7CLASS, "CLK_Set_32KHz: "
-				"Failed to set to 32KHz %s, CLK dev id = %d\n",
+			GT_2trace(CLK_debugMask, GT_7CLASS, "CLK_Set_32KHz: "
+				"Failed to set to 32KHz %s, CLK dev id = %s\n",
 				SERVICES_Clks[clk_id].clk_name,
 				SERVICES_Clks[clk_id].id);
 			status = DSP_EFAIL;
@@ -344,7 +325,8 @@ s32 CLK_Get_UseCnt(IN enum SERVICES_ClkI
 	pClk = SERVICES_Clks[clk_id].clk_handle;
 
 	if (pClk) {
-		useCount =  pClk->usecount; /* FIXME: usecount shouldn't be used */
+		/* FIXME: usecount shouldn't be used */
+		useCount = pClk->usecount;
 	} else {
 		GT_2trace(CLK_debugMask, GT_7CLASS,
 			 "CLK_GetRate: failed to get CLK %s, "
@@ -357,19 +339,27 @@ s32 CLK_Get_UseCnt(IN enum SERVICES_ClkI
 
 void SSI_Clk_Prepare(bool FLAG)
 {
-	u32 ssi_sysconfig;
-	ssi_sysconfig = __raw_readl((SSI_BASE) + 0x10);
+	void __iomem *ssi_base;
+	unsigned int value;
+
+	ssi_base = ioremap(L4_34XX_BASE + OMAP_SSI_OFFSET, OMAP_SSI_SIZE);
+	if (!ssi_base) {
+		pr_err("%s: error, SSI not configured\n", __func__);
+		return;
+	}
 
 	if (FLAG) {
 		/* Set Autoidle, SIDLEMode to smart idle, and MIDLEmode to
 		 * no idle
 		 */
-		ssi_sysconfig = 0x1011;
+		value = SSI_AUTOIDLE | SSI_SIDLE_SMARTIDLE | SSI_MIDLE_NOIDLE;
 	} else {
 		/* Set Autoidle, SIDLEMode to forced idle, and MIDLEmode to
 		 * forced idle
 		 */
-		ssi_sysconfig = 0x1;
+		value = SSI_AUTOIDLE;
 	}
-	__raw_writel((u32)ssi_sysconfig, SSI_BASE + 0x10);
+
+	__raw_writel(value, ssi_base + OMAP_SSI_SYSCONFIG_OFFSET);
+	iounmap(ssi_base);
 }
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/services/csl.c kernel-power-2.6.28/drivers/dsp/bridge/services/csl.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/services/csl.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/services/csl.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,173 +0,0 @@
-/*
- * csl.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== cslce.c ========
- *  Purpose:
- *      Provides platform independent C Standard library functions.
- *
- *  Public Functions:
- *      CSL_Atoi
- *      CSL_Exit
- *      CSL_Init
- *      CSL_NumToAscii
- *      CSL_Strtokr
- *
- *! Revision History:
- *! ================
- *! 07-Aug-2002 jeh: Added CSL_Strtokr().
- *! 21-Sep-2001 jeh: Added CSL_Strncmp(). Alphabetized functions.
- *! 22-Nov-2000 map: Added CSL_Atoi and CSL_Strtok
- *! 19-Nov-2000 kc: Added CSL_ByteSwap.
- *! 09-Nov-2000 kc: Added CSL_Strncat.
- *! 03-Feb-2000 rr: Module init/exit is handled by SERVICES Init/Exit.
- *!		 GT Changes.
- *! 15-Dec-1999 ag: Removed incorrect assertion CSL_NumToAscii()
- *! 29-Oct-1999 kc: Added CSL_Wstrlen for UNICODE strings.
- *! 30-Sep-1999 ag: Removed DBC assertion (!CSL_DebugMask.flags) in
- *		  CSP_Init().
- *! 20-Sep-1999 ag: Added CSL_WcharToAnsi().
- *!		 Removed call to GT_set().
- *! 19-Jan-1998 cr: Code review cleanup.
- *! 29-Dec-1997 cr: Made platform independant, using MS CRT code, and
- *!		 combined csl32.c csl95.c and cslnt.c into csl.c.  Also
- *!		 changed CSL_lowercase to CSL_Uppercase.
- *! 21-Aug-1997 gp: Fix to CSL_strcpyn to initialize Source string, the NT way.
- *! 25-Jun-1997 cr: Created from csl95, added CSL_strcmp.
- */
-
-/* ----------------------------------- Host OS */
-#include <dspbridge/host_os.h>
-
-/*  ----------------------------------- DSP/BIOS Bridge */
-#include <dspbridge/std.h>
-#include <dspbridge/dbdefs.h>
-
-/*  ----------------------------------- Trace & Debug */
-#include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
-
-/*  ----------------------------------- This */
-#include <dspbridge/csl.h>
-
-/* Is character c in the string pstrDelim? */
-#define IsDelimiter(c, pstrDelim) ((c != '\0') && \
-				   (strchr(pstrDelim, c) != NULL))
-
-/*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask CSL_DebugMask = { NULL, NULL };	/* GT trace var. */
-#endif
-
-/*
- *  ======== CSL_Exit ========
- *  Purpose:
- *      Discontinue usage of the CSL module.
- */
-void CSL_Exit(void)
-{
-	GT_0trace(CSL_DebugMask, GT_5CLASS, "CSL_Exit\n");
-}
-
-/*
- *  ======== CSL_Init ========
- *  Purpose:
- *      Initialize the CSL module's private state.
- */
-bool CSL_Init(void)
-{
-	GT_create(&CSL_DebugMask, "CS");
-
-	GT_0trace(CSL_DebugMask, GT_5CLASS, "CSL_Init\n");
-
-	return true;
-}
-
-/*
- *  ======== CSL_NumToAscii ========
- *  Purpose:
- *      Convert a 1 or 2 digit number to a 2 digit string.
- */
-void CSL_NumToAscii(OUT char *pstrNumber, u32 dwNum)
-{
-	char tens;
-
-	DBC_Require(dwNum < 100);
-
-	if (dwNum < 100) {
-		tens = (char) dwNum / 10;
-		dwNum = dwNum % 10;
-
-		if (tens) {
-			pstrNumber[0] = tens + '0';
-			pstrNumber[1] = (char) dwNum + '0';
-			pstrNumber[2] = '\0';
-		} else {
-			pstrNumber[0] = (char) dwNum + '0';
-			pstrNumber[1] = '\0';
-		}
-	} else {
-		pstrNumber[0] = '\0';
-	}
-}
-
-
-
-
-/*
- *  ======= CSL_Strtokr =======
- *  Purpose:
- *      Re-entrant version of strtok.
- */
-char *CSL_Strtokr(IN char *pstrSrc, IN CONST char *szSeparators,
-		  OUT char **ppstrLast)
-{
-	char *pstrTemp;
-	char *pstrToken;
-
-	DBC_Require(szSeparators != NULL);
-	DBC_Require(ppstrLast != NULL);
-	DBC_Require(pstrSrc != NULL || *ppstrLast != NULL);
-
-	/*
-	 *  Set string location to beginning (pstrSrc != NULL) or to the
-	 *  beginning of the next token.
-	 */
-	pstrTemp = (pstrSrc != NULL) ? pstrSrc : *ppstrLast;
-	if (*pstrTemp == '\0') {
-		pstrToken = NULL;
-	} else {
-		pstrToken = pstrTemp;
-		while (*pstrTemp != '\0' && !IsDelimiter(*pstrTemp,
-		      szSeparators)) {
-			pstrTemp++;
-		}
-		if (*pstrTemp != '\0') {
-			while (IsDelimiter(*pstrTemp, szSeparators)) {
-				/* TODO: Shouldn't we do this for
-				 * only 1 char?? */
-				*pstrTemp = '\0';
-				pstrTemp++;
-			}
-		}
-
-		/* Location in string for next call */
-		*ppstrLast = pstrTemp;
-	}
-
-	return pstrToken;
-}
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/services/dbg.c kernel-power-2.6.28/drivers/dsp/bridge/services/dbg.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/services/dbg.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/services/dbg.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provide debugging services for DSP/BIOS Bridge Mini Driver.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,37 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== dbgce.c ========
- *  Purpose:
- *      Provide debugging services for DSP/BIOS Bridge Mini Drivers.
- *
- *  Public Functions:
- *      DBG_Exit
- *      DBG_Init
- *      DBG_Trace
- *
- *  Notes:
- *      Requires gt.h.
- *
- *      This implementation does not create GT masks on a per WMD basis.
- *      There is currently no facility for a WMD to alter the GT mask.
- *
- *! Revision History:
- *! ================
- *! 15-Feb-2000 rr: DBG_Trace prints based on the DebugZones.
- *! 03-Feb-2000 rr: Module init/exit is handled by SERVICES Init/Exit.
- *!		 GT Changes.
- *! 29-Oct-1999 kc: Cleaned up for code review.
- *! 10-Oct-1997 cr: Added DBG_Printf service.
- *! 28-May-1997 cr: Added reference counting.
- *! 23-May-1997 cr: Updated DBG_Trace to new gt interface.
- *! 29-May-1996 gp: Removed WCD_ prefix.
- *! 20-May-1996 gp: Remove DEBUG conditional compilation.
- *! 15-May-1996 gp: Created.
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
@@ -62,7 +33,7 @@
 static struct GT_Mask DBG_debugMask = { NULL, NULL };	/* GT trace var. */
 #endif
 
-#if (defined(DEBUG) || defined (DDSP_DEBUG_PRODUCT)) && GT_TRACE
+#if (defined(CONFIG_BRIDGE_DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE
 
 /*
  *  ======== DBG_Init ========
@@ -116,4 +87,4 @@ void DBG_Exit(void)
 	GT_0trace(DBG_debugMask, GT_5CLASS, "DBG_Exit\n");
 }
 
-#endif	/* (defined(DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE */
+#endif	/* (defined(CONFIG_BRIDGE_DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE */
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/services/dpc.c kernel-power-2.6.28/drivers/dsp/bridge/services/dpc.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/services/dpc.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/services/dpc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,274 +0,0 @@
-/*
- * dpc.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== dpcce.c ========
- *  Purpose:
- *      Deferred Procedure Call(DPC) Services.
- *
- *
- *  Public Functions:
- *      DPC_Create
- *      DPC_Destroy
- *      DPC_Exit
- *      DPC_Init
- *      DPC_Schedule
- *
- *! Revision History:
- *! ================
- *! 28-Mar-2001 ag: Added #ifdef CHNL_NOIPCINTR to set DPC thread priority
- *!                     to THREAD_PRIORITY_IDLE for polling IPC.
- *! 03-Feb-2000 rr: Module init/exit is handled by SERVICES Init/Exit.
- *!		 GT Changes.
- *! 31-Jan-2000 rr: Changes after code review.Terminate thread,handle
- *!                 modified.DPC_Destroy frees the DPC_Object only on
- *!                 Successful termination of the thread and the handle.
- *! 06-Jan-1999 ag: Format cleanup for code review.
- *!                 Removed DPC_[Lower|Raise]IRQL[From|To]DispatchLevel.
- *! 10-Dec-1999 ag: Added SetProcPermissions in DPC_DeferredProcedure().
- *!                 (Needed to access client(s) CHNL buffers).
- *! 19-Sep-1999 a0216266: Stubbed from dpcnt.c.
- */
-
-/*  ----------------------------------- Host OS */
-#include <dspbridge/host_os.h>
-
-/*  ----------------------------------- DSP/BIOS Bridge */
-#include <dspbridge/std.h>
-#include <dspbridge/dbdefs.h>
-#include <dspbridge/errbase.h>
-
-/*  ----------------------------------- Trace & Debug */
-#include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
-
-/*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/mem.h>
-
-/*  ----------------------------------- This */
-#include <dspbridge/dpc.h>
-
-/*  ----------------------------------- Defines, Data Structures, Typedefs */
-#define SIGNATURE       0x5f435044	/* "DPC_" (in reverse). */
-
-/* The DPC object, passed to our priority event callback routine: */
-struct DPC_OBJECT {
-	u32 dwSignature;	/* Used for object validation.   */
-	void *pRefData;		/* Argument for client's DPC.    */
-	DPC_PROC pfnDPC;	/* Client's DPC.                 */
-	u32 numRequested;	/* Number of requested DPC's.      */
-	u32 numScheduled;	/* Number of executed DPC's.      */
-	struct tasklet_struct dpc_tasklet;
-
-#ifdef DEBUG
-	u32 cEntryCount;	/* Number of times DPC reentered. */
-	u32 numRequestedMax;	/* Keep track of max pending DPC's. */
-#endif
-
-	spinlock_t dpc_lock;
-};
-
-/*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask DPC_DebugMask = { NULL, NULL };	/* DPC Debug Mask */
-#endif
-
-/*  ----------------------------------- Function Prototypes */
-static void DPC_DeferredProcedure(IN unsigned long pDeferredContext);
-
-/*
- *  ======== DPC_Create ========
- *  Purpose:
- *      Create a DPC object, allowing a client's own DPC procedure to be
- *      scheduled for a call with client reference data.
- */
-DSP_STATUS DPC_Create(OUT struct DPC_OBJECT **phDPC, DPC_PROC pfnDPC,
-		      void *pRefData)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct DPC_OBJECT *pDPCObject = NULL;
-
-	if ((phDPC != NULL) && (pfnDPC != NULL)) {
-		/*
-		 *  Allocate a DPC object to store information allowing our DPC
-		 *  callback to dispatch to the client's DPC.
-		 */
-		MEM_AllocObject(pDPCObject, struct DPC_OBJECT, SIGNATURE);
-		if (pDPCObject != NULL) {
-			tasklet_init(&pDPCObject->dpc_tasklet,
-				     DPC_DeferredProcedure,
-				     (u32) pDPCObject);
-			/* Fill out our DPC Object: */
-			pDPCObject->pRefData = pRefData;
-			pDPCObject->pfnDPC = pfnDPC;
-			pDPCObject->numRequested = 0;
-			pDPCObject->numScheduled = 0;
-#ifdef DEBUG
-			pDPCObject->numRequestedMax = 0;
-			pDPCObject->cEntryCount = 0;
-#endif
-			spin_lock_init(&pDPCObject->dpc_lock);
-			*phDPC = pDPCObject;
-		} else {
-			GT_0trace(DPC_DebugMask, GT_6CLASS,
-				  "DPC_Create: DSP_EMEMORY\n");
-			status = DSP_EMEMORY;
-		}
-	} else {
-		GT_0trace(DPC_DebugMask, GT_6CLASS,
-			  "DPC_Create: DSP_EPOINTER\n");
-		status = DSP_EPOINTER;
-	}
-	DBC_Ensure((DSP_FAILED(status) && (!phDPC || (phDPC && *phDPC == NULL)))
-		   || DSP_SUCCEEDED(status));
-	return status;
-}
-
-/*
- *  ======== DPC_Destroy ========
- *  Purpose:
- *      Cancel the last scheduled DPC, and deallocate a DPC object previously
- *      allocated with DPC_Create(). Frees the Object only if the thread
- *      and the event terminated successfuly.
- */
-DSP_STATUS DPC_Destroy(struct DPC_OBJECT *hDPC)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct DPC_OBJECT *pDPCObject = (struct DPC_OBJECT *)hDPC;
-
-	if (MEM_IsValidHandle(hDPC, SIGNATURE)) {
-
-		/* Free our DPC object: */
-		if (DSP_SUCCEEDED(status)) {
-			tasklet_kill(&pDPCObject->dpc_tasklet);
-			MEM_FreeObject(pDPCObject);
-			pDPCObject = NULL;
-			GT_0trace(DPC_DebugMask, GT_2CLASS,
-				  "DPC_Destroy: SUCCESS\n");
-		}
-	} else {
-		GT_0trace(DPC_DebugMask, GT_6CLASS,
-			  "DPC_Destroy: DSP_EHANDLE\n");
-		status = DSP_EHANDLE;
-	}
-	DBC_Ensure((DSP_SUCCEEDED(status) && pDPCObject == NULL)
-		   || DSP_FAILED(status));
-	return status;
-}
-
-/*
- *  ======== DPC_Exit ========
- *  Purpose:
- *      Discontinue usage of the DPC module.
- */
-void DPC_Exit(void)
-{
-	GT_0trace(DPC_DebugMask, GT_5CLASS, "Entered DPC_Exit\n");
-}
-
-/*
- *  ======== DPC_Init ========
- *  Purpose:
- *      Initialize the DPC module's private state.
- */
-bool DPC_Init(void)
-{
-	GT_create(&DPC_DebugMask, "DP");
-
-	GT_0trace(DPC_DebugMask, GT_5CLASS, "Entered DPC_Init\n");
-
-	return true;
-}
-
-/*
- *  ======== DPC_Schedule ========
- *  Purpose:
- *      Schedule a deferred procedure call to be executed at a later time.
- *      Latency and order of DPC execution is platform specific.
- */
-DSP_STATUS DPC_Schedule(struct DPC_OBJECT *hDPC)
-{
-	DSP_STATUS status = DSP_SOK;
-	struct DPC_OBJECT *pDPCObject = (struct DPC_OBJECT *)hDPC;
-	unsigned long flags;
-
-	GT_1trace(DPC_DebugMask, GT_ENTER, "DPC_Schedule hDPC %x\n", hDPC);
-	if (MEM_IsValidHandle(hDPC, SIGNATURE)) {
-		/* Increment count of DPC's pending. Needs to be protected
-		 * from ISRs since this function is called from process
-		 * context also. */
-		spin_lock_irqsave(&hDPC->dpc_lock, flags);
-		pDPCObject->numRequested++;
-		spin_unlock_irqrestore(&hDPC->dpc_lock, flags);
-		tasklet_schedule(&(hDPC->dpc_tasklet));
-#ifdef DEBUG
-		if (pDPCObject->numRequested > pDPCObject->numScheduled +
-						pDPCObject->numRequestedMax) {
-			pDPCObject->numRequestedMax = pDPCObject->numRequested -
-						pDPCObject->numScheduled;
-		}
-#endif
-	/*  If an interrupt occurs between incrementing numRequested and the
-	 *  assertion below, then DPC will get executed while returning from
-	 *  ISR, which will complete all requests and make numRequested equal
-	 * to numScheduled, firing this assertion. This happens only when
-	 * DPC is being scheduled in process context */
-	} else {
-		GT_0trace(DPC_DebugMask, GT_6CLASS,
-			  "DPC_Schedule: DSP_EHANDLE\n");
-		status = DSP_EHANDLE;
-	}
-	GT_1trace(DPC_DebugMask, GT_ENTER, "DPC_Schedule status %x\n", status);
-	return status;
-}
-
-/*
- *  ======== DeferredProcedure ========
- *  Purpose:
- *      Main DPC routine.  This is called by host OS DPC callback
- *      mechanism with interrupts enabled.
- */
-static void DPC_DeferredProcedure(IN unsigned long pDeferredContext)
-{
-	struct DPC_OBJECT *pDPCObject = (struct DPC_OBJECT *)pDeferredContext;
-	/* read numRequested in local variable */
-	u32 requested;
-	u32 serviced;
-
-	DBC_Require(pDPCObject != NULL);
-	requested = pDPCObject->numRequested;
-	serviced = pDPCObject->numScheduled;
-
-	GT_1trace(DPC_DebugMask, GT_ENTER, "> DPC_DeferredProcedure "
-		  "pDeferredContext=%x\n", pDeferredContext);
-	/* Rollover taken care of using != instead of < */
-	if (serviced != requested) {
-		if (pDPCObject->pfnDPC != NULL) {
-			/* Process pending DPC's: */
-			do {
-				/* Call client's DPC: */
-				(*(pDPCObject->pfnDPC))(pDPCObject->pRefData);
-				serviced++;
-			} while (serviced != requested);
-		}
-		pDPCObject->numScheduled = requested;
-	}
-	GT_2trace(DPC_DebugMask, GT_ENTER,
-		  "< DPC_DeferredProcedure requested %d"
-		  " serviced %d\n", requested, serviced);
-}
-
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/services/kfile.c kernel-power-2.6.28/drivers/dsp/bridge/services/kfile.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/services/kfile.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/services/kfile.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,335 +0,0 @@
-/*
- * kfile.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== kfilece.c ========
- *  Purpose:
- *      This module provides file i/o services.
- *
- *  Public Functions:
- *      KFILE_Close
- *      KFILE_Exit
- *      KFILE_Init
- *      KFILE_Open
- *      KFILE_Read
- *      KFILE_Seek
- *      KFILE_Tell
- *
- *! Revision History
- *! ================
- *! 03-Feb-2000 rr: Module init/exit is handled by SERVICES Init/Exit.
- *!		 GT Changes.
- *! 22-Nov-1999 kc: Added changes from code review.
- *! 12-Nov-1999 kc: Enabled CSL for UNICODE/ANSI string conversions.
- *! 30-Sep-1999 ag: Changed KFILE_Read() GT level from _ENTER to _4CLASS.
- *!                 Removed GT_set().
- *! 25-Aug-1999 ag: Changed MEM_Calloc allocation type to MEM_PAGED.
- *! 13-Jul-1999 a0216266(ww - TID): Stubbed from kfilent.c.
- */
-
-/*  ----------------------------------- Host OS */
-#include <dspbridge/host_os.h>
-
-/*  ----------------------------------- DSP/BIOS Bridge */
-#include <dspbridge/std.h>
-#include <dspbridge/dbdefs.h>
-#include <dspbridge/errbase.h>
-
-/*  ----------------------------------- Trace & Debug */
-#include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
-
-/*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
-#include <dspbridge/mem.h>
-
-/*  ----------------------------------- This */
-#include <dspbridge/kfile.h>
-
-/*  ----------------------------------- Defines, Data Structures, Typedefs */
-#define SIGNATURE           0x4c49464b	/* hex code of KFIL (reversed) */
-#define MAXFILENAMELENGTH   256
-#define GENERAL_FAILURE     0xffffffff	/* SetFilePointer error */
-
-/* The KFILE_FileObj abstracts the true file handle from a KFILE handle. */
-struct KFILE_FileObj {
-    u32 dwSignature;
-    __kernel_pid_t owner_pid;	/* PID of process that opened this file */
-    char 	*fileName  ;
-    bool          isOpen    ;
-    u32        size      ;
-    u32        curPos    ;
-    long 	  hInternal;		/* internal handle of file */
-    struct file *fileDesc;
-
-};
-
-/*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask KFILE_debugMask = { NULL, NULL };	/* Debug mask */
-#endif
-
-/*
- *  ======== KFILE_Close ========
- *  Purpose:
- *      This function closes a file's stream.
- */
-s32 KFILE_Close(struct KFILE_FileObj *hFile)
-{
-	s32 cRetVal = 0;	/* 0 indicates success */
-	s32 fRetVal = 0;
-
-	GT_1trace(KFILE_debugMask, GT_ENTER, "KFILE_Close: hFile 0x%x\n",
-		  hFile);
-
-	/* Check for valid handle */
-	if (MEM_IsValidHandle(hFile, SIGNATURE)) {
-		/* Close file only if opened by the same process (id). Otherwise
-		 * Linux closes all open file handles when process exits.*/
-		fRetVal = filp_close(hFile->fileDesc, NULL) ;
-		if (fRetVal) {
-			cRetVal = E_KFILE_ERROR;
-			GT_1trace(KFILE_debugMask, GT_6CLASS,
-				  "KFILE_Close: sys_close "
-				  "returned %d\n", fRetVal);
-		}
-		MEM_FreeObject(hFile);
-	} else {
-		cRetVal = E_KFILE_INVALIDHANDLE;
-		GT_0trace(KFILE_debugMask, GT_6CLASS, "KFILE_Close: "
-			  "invalid file handle\n");
-	}
-	return cRetVal;
-}
-
-/*
- *  ======== KFILE_Exit ========
- *  Purpose:
- *      Decrement reference count, and free resources when reference count
- *      is 0.
- */
-void KFILE_Exit(void)
-{
-	GT_0trace(KFILE_debugMask, GT_5CLASS, "KFILE_Exit\n");
-}
-
-/*
- *  ======== KFILE_Init ========
- */
-bool KFILE_Init(void)
-{
-	GT_create(&KFILE_debugMask, "KF");	/* "KF" for KFile */
-
-	GT_0trace(KFILE_debugMask, GT_5CLASS, "KFILE_Init\n");
-
-	return true;
-}
-
-/*
- *  ======== KFILE_Open ========
- *  Purpose:
- *      Open a file for reading ONLY
- */
-struct KFILE_FileObj *KFILE_Open(CONST char *pszFileName, CONST char *pszMode)
-{
-	struct KFILE_FileObj *hFile;	/* file handle */
-	DSP_STATUS status;
-	mm_segment_t fs;
-
-	struct file*fileDesc = NULL;
-	DBC_Require(pszMode != NULL);
-	DBC_Require(pszFileName != NULL);
-
-	GT_2trace(KFILE_debugMask, GT_ENTER,
-		  "KFILE_Open: pszFileName %s, pszMode "
-		  "%s\n", pszFileName, pszMode);
-
-	/* create a KFILE object */
-	MEM_AllocObject(hFile, struct KFILE_FileObj, SIGNATURE);
-
-	if (hFile) {
-		fs = get_fs();
-		set_fs(get_ds());
-	/* Third argument is mode (permissions). Ignored unless creating file */
-		fileDesc = filp_open(pszFileName, O_RDONLY, 0);
-		if ((IS_ERR(fileDesc)) || (fileDesc == NULL) ||
-		     (fileDesc->f_op == NULL) || (fileDesc->f_op->read == NULL)
-		     || (fileDesc->f_op->llseek == NULL)) {
-			status = DSP_EFILE;
-		} else {
-			hFile->fileDesc = fileDesc;
-			hFile->fileName = (char *)pszFileName;
-			hFile->isOpen	   = true;
-			hFile->curPos   = 0;
-			hFile->size = fileDesc->f_op->llseek(fileDesc, 0,
-							    SEEK_END);
-			fileDesc->f_op->llseek(fileDesc, 0, SEEK_SET);
-			/* Return TGID instead of process handle */
-			hFile->owner_pid = current->tgid;
-
-			status = DSP_SOK;
-		}
-		set_fs(fs);
-		if (DSP_FAILED(status)) {
-			/* free memory, and clear handle */
-			MEM_FreeObject(hFile);
-			hFile = NULL;
-		}
-	} else {
-			GT_0trace(KFILE_debugMask, GT_6CLASS,
-				  "KFILE_Open: MEM_AllocObject failed\n");
-			status = DSP_EMEMORY;
-	}
-	return hFile;
-}
-
-/*
- *  ======== KFILE_Read ========
- *  Purpose:
- *      Reads a specified number of bytes into a buffer.
- */
-s32
-KFILE_Read(void __user*pBuffer, s32 cSize, s32 cCount,
-			struct KFILE_FileObj *hFile)
-{
-	u32 dwBytesRead = 0;
-	s32 cRetVal = 0;
-	mm_segment_t fs;
-
-	DBC_Require(pBuffer != NULL);
-
-	GT_4trace(KFILE_debugMask, GT_4CLASS,
-		  "KFILE_Read: buffer 0x%x, cSize 0x%x,"
-		  "cCount 0x%x, hFile 0x%x\n", pBuffer, cSize, cCount, hFile);
-
-	/* check for valid file handle */
-	if (MEM_IsValidHandle(hFile, SIGNATURE)) {
-		if ((cSize > 0) && (cCount > 0) && pBuffer) {
-			/* read from file */
-			fs = get_fs();
-			set_fs(get_ds());
-			dwBytesRead = hFile->fileDesc->f_op->read(hFile->
-				      fileDesc, pBuffer, cSize *cCount,
-				      &(hFile->fileDesc->f_pos));
-			set_fs(fs);
-			if (dwBytesRead) {
-				cRetVal = dwBytesRead / cSize;
-				hFile->curPos += dwBytesRead;
-				DBC_Assert((dwBytesRead / cSize) <= \
-					  (u32)cCount);
-			} else {
-				cRetVal = E_KFILE_ERROR;
-				GT_0trace(KFILE_debugMask, GT_6CLASS,
-					  "KFILE_Read: sys_read() failed\n");
-			}
-		} else {
-			cRetVal = DSP_EINVALIDARG;
-			GT_0trace(KFILE_debugMask, GT_6CLASS,
-				  "KFILE_Read: Invalid argument(s)\n");
-		}
-	} else {
-		cRetVal = E_KFILE_INVALIDHANDLE;
-		GT_0trace(KFILE_debugMask, GT_6CLASS,
-			  "KFILE_Read: invalid file handle\n");
-	}
-
-	return cRetVal;
-}
-
-/*
- *  ======== KFILE_Seek ========
- *  Purpose:
- *      Sets the file position indicator. NOTE:  we don't support seeking
- *      beyond the boundaries of a file.
- */
-s32 KFILE_Seek(struct KFILE_FileObj *hFile, s32 lOffset, s32 cOrigin)
-{
-	s32 cRetVal = 0;	/* 0 for success */
-	loff_t dwCurPos = 0;
-
-	struct file *fileDesc = NULL;
-
-	GT_3trace(KFILE_debugMask, GT_ENTER, "KFILE_Seek: hFile 0x%x, "
-		  "lOffset 0x%x, cOrigin 0x%x\n",
-		  hFile, lOffset, cOrigin);
-
-	/* check for valid file handle */
-	if (MEM_IsValidHandle(hFile, SIGNATURE)) {
-		/* based on the origin flag, move the internal pointer */
-
-	fileDesc = hFile->fileDesc;
-		switch (cOrigin) {
-		case KFILE_SEEK_SET:
-			dwCurPos = hFile->fileDesc->f_op->llseek(hFile->
-				   fileDesc, lOffset, SEEK_SET);
-			cRetVal = ((dwCurPos >= 0) ? 0 : E_KFILE_ERROR);
-			break;
-
-		case KFILE_SEEK_CUR:
-			dwCurPos = hFile->fileDesc->f_op->llseek(hFile->
-				   fileDesc, lOffset, SEEK_CUR);
-			cRetVal = ((dwCurPos >= 0) ? 0 : E_KFILE_ERROR);
-			break;
-		case KFILE_SEEK_END:
-			dwCurPos = hFile->fileDesc->f_op->llseek(hFile->
-				   fileDesc, lOffset, SEEK_END);
-			cRetVal = ((dwCurPos >= 0) ? 0 : E_KFILE_ERROR);
-			break;
-		default:
-			cRetVal = E_KFILE_BADORIGINFLAG;
-			GT_0trace(KFILE_debugMask, GT_6CLASS,
-				  "KFILE_Seek:bad origin flag\n");
-			break;
-		}
-	} else {
-		cRetVal = E_KFILE_INVALIDHANDLE;
-		GT_0trace(KFILE_debugMask, GT_6CLASS,
-			  "KFILE_Seek:invalid file handle\n");
-	}
-	return cRetVal;
-}
-
-/*
- *  ======== KFILE_Tell ========
- *  Purpose:
- *      Reports the current value of the position indicator. We did not
- *	    consider 64 bit long file size, which implies a 4GB file limit
- *      (2 to 32 power).
- */
-s32 KFILE_Tell(struct KFILE_FileObj *hFile)
-{
-	loff_t dwCurPos = 0;
-	s32 lRetVal = E_KFILE_ERROR;
-
-	GT_1trace(KFILE_debugMask, GT_ENTER, "KFILE_Tell: hFile 0x%x\n", hFile);
-
-	if (MEM_IsValidHandle(hFile, SIGNATURE)) {
-
-		/* Get current position. */
-		dwCurPos = hFile->fileDesc->f_op->llseek(hFile->fileDesc, 0,
-			   SEEK_CUR);
-		if (dwCurPos >= 0)
-			lRetVal = dwCurPos;
-
-	} else {
-		lRetVal = E_KFILE_INVALIDHANDLE;
-		GT_0trace(KFILE_debugMask, GT_6CLASS,
-			  "KFILE_Seek:invalid file handle\n");
-	}
-	return lRetVal;
-}
-
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/services/list.c kernel-power-2.6.28/drivers/dsp/bridge/services/list.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/services/list.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/services/list.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,285 +0,0 @@
-/*
- * list.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-
-/*
- *  ======== listce.c ========
- *  Purpose
- *      Provides standard circular list handling functions.
- *
- *  Public Functions:
- *      LST_Create
- *      LST_Delete
- *      LST_Exit
- *      LST_First
- *      LST_GetHead
- *      LST_Init
- *      LST_InitElem
- *      LST_InsertBefore
- *      LST_Next
- *      LST_PutTail
- *      LST_RemoveElem
- *
- *! Revision History
- *! ================
- *! 06-Mar-2002 jeh Don't set element self to NULL in LST_RemoveElem().
- *! 10-Aug-2000 ag: Added LST_InsertBefore().
- *! 03-Feb-2000 rr: Module init/exit is handled by SERVICES Init/Exit.
- *!		 GT Changes.
- *! 22-Nov-1999 kc: Added changes from code review.
- *! 10-Aug-1999 kc: Based on wsx-c18.
- *! 16-Jun-1997 gp: Removed unnecessary enabling/disabling of interrupts around
- *!                 list manipulation code.
- *! 22-Oct-1996 gp: Added LST_RemoveElem, and LST_First/LST_Next iterators.
- *! 10-Aug-1996 gp: Acquired from SMM for WinSPOX v. 1.1; renamed identifiers.
- */
-
-/*  ----------------------------------- DSP/BIOS Bridge */
-#include <dspbridge/std.h>
-#include <dspbridge/dbdefs.h>
-
-/*  ----------------------------------- Trace & Debug */
-#include <dspbridge/dbc.h>
-#include <dspbridge/gt.h>
-
-/*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/mem.h>
-
-/*  ----------------------------------- This */
-#include <dspbridge/list.h>
-
-/*  ----------------------------------- Globals */
-#if GT_TRACE
-static struct GT_Mask LST_debugMask = { NULL, NULL };	/* GT trace var. */
-#endif
-
-/*
- *  ======== LST_Create ========
- *  Purpose:
- *      Allocates and initializes a circular list.
- */
-struct LST_LIST *LST_Create(void)
-{
-	struct LST_LIST *pList;
-
-	GT_0trace(LST_debugMask, GT_ENTER, "LST_Create: entered\n");
-
-	pList = (struct LST_LIST *) MEM_Calloc(sizeof(struct LST_LIST),
-		MEM_NONPAGED);
-	if (pList != NULL) {
-		pList->head.next = &pList->head;
-		pList->head.prev = &pList->head;
-		pList->head.self = NULL;
-	}
-
-	return pList;
-}
-
-/*
- *  ======== LST_Delete ========
- *  Purpose:
- *      Removes a list by freeing its control structure's memory space.
- */
-void LST_Delete(struct LST_LIST *pList)
-{
-	DBC_Require(pList != NULL);
-
-	GT_1trace(LST_debugMask, GT_ENTER, "LST_Delete: pList 0x%x\n", pList);
-
-	MEM_Free(pList);
-}
-
-/*
- *  ======== LST_Exit ========
- *  Purpose:
- *      Discontinue usage of the LST module.
- */
-void LST_Exit(void)
-{
-	GT_0trace(LST_debugMask, GT_5CLASS, "LST_Exit\n");
-}
-
-/*
- *  ======== LST_First ========
- *  Purpose:
- *      Returns a pointer to the first element of the list, or NULL if the
- *      list is empty.
- */
-struct LST_ELEM *LST_First(struct LST_LIST *pList)
-{
-	struct LST_ELEM *pElem = NULL;
-
-	DBC_Require(pList != NULL);
-
-	GT_1trace(LST_debugMask, GT_ENTER, "LST_First: pList 0x%x\n", pList);
-
-	if (!LST_IsEmpty(pList))
-		pElem = pList->head.next;
-
-	return pElem;
-}
-
-/*
- *  ======== LST_GetHead ========
- *  Purpose:
- *      "Pops" the head off the list and returns a pointer to it.
- */
-struct LST_ELEM *LST_GetHead(struct LST_LIST *pList)
-{
-	struct LST_ELEM *pElem;
-
-	DBC_Require(pList != NULL);
-
-	GT_1trace(LST_debugMask, GT_ENTER, "LST_GetHead: pList 0x%x\n", pList);
-
-	if (LST_IsEmpty(pList))
-		return NULL;
-
-	/* pElem is always valid because the list cannot be empty
-	 * at this point */
-	pElem = pList->head.next;
-	pList->head.next = pElem->next;
-	pElem->next->prev = &pList->head;
-
-	return pElem->self;
-}
-
-/*
- *  ======== LST_Init ========
- *  Purpose:
- *      Initialize LST module private state.
- */
-bool LST_Init(void)
-{
-	GT_create(&LST_debugMask, "LS");	/* LS for LSt module */
-
-	GT_0trace(LST_debugMask, GT_5CLASS, "LST_Init\n");
-
-	return true;
-}
-
-/*
- *  ======== LST_InitElem ========
- *  Purpose:
- *      Initializes a list element to default (cleared) values
- */
-void LST_InitElem(struct LST_ELEM *pElem)
-{
-	DBC_Require(pElem != NULL);
-
-	GT_1trace(LST_debugMask, GT_ENTER, "LST_InitElem: pElem 0x%x\n", pElem);
-
-	if (pElem) {
-		pElem->next = NULL;
-		pElem->prev = NULL;
-		pElem->self = pElem;
-	}
-}
-
-/*
- *  ======== LST_InsertBefore ========
- *  Purpose:
- *      Insert the element before the existing element.
- */
-void LST_InsertBefore(struct LST_LIST *pList, struct LST_ELEM *pElem,
-		      struct LST_ELEM *pElemExisting)
-{
-	DBC_Require(pList != NULL);
-	DBC_Require(pElem != NULL);
-	DBC_Require(pElemExisting != NULL);
-
-	GT_3trace(LST_debugMask, GT_ENTER, "LST_InsertBefore: pList 0x%x, "
-		  "pElem 0x%x pElemExisting 0x%x\n", pList, pElem,
-		  pElemExisting);
-
-	pElemExisting->prev->next = pElem;
-	pElem->prev = pElemExisting->prev;
-	pElem->next = pElemExisting;
-	pElemExisting->prev = pElem;
-}
-
-/*
- *  ======== LST_Next ========
- *  Purpose:
- *      Returns a pointer to the next element of the list, or NULL if the
- *      next element is the head of the list or the list is empty.
- */
-struct LST_ELEM *LST_Next(struct LST_LIST *pList, struct LST_ELEM *pCurElem)
-{
-	struct LST_ELEM *pNextElem = NULL;
-
-	DBC_Require(pList != NULL);
-	DBC_Require(pCurElem != NULL);
-
-	GT_2trace(LST_debugMask, GT_ENTER,
-		  "LST_Next: pList 0x%x, pCurElem 0x%x\n",
-		  pList, pCurElem);
-
-	if (!LST_IsEmpty(pList)) {
-		if (pCurElem->next != &pList->head)
-			pNextElem = pCurElem->next;
-	}
-
-	return pNextElem;
-}
-
-/*
- *  ======== LST_PutTail ========
- *  Purpose:
- *      Adds the specified element to the tail of the list
- */
-void LST_PutTail(struct LST_LIST *pList, struct LST_ELEM *pElem)
-{
-	DBC_Require(pList != NULL);
-	DBC_Require(pElem != NULL);
-
-	GT_2trace(LST_debugMask, GT_ENTER,
-		  "LST_PutTail: pList 0x%x, pElem 0x%x\n",
-		  pList, pElem);
-
-	pElem->prev = pList->head.prev;
-	pElem->next = &pList->head;
-	pList->head.prev = pElem;
-	pElem->prev->next = pElem;
-
-	DBC_Ensure(!LST_IsEmpty(pList));
-}
-
-/*
- *  ======== LST_RemoveElem ========
- *  Purpose:
- *      Removes (unlinks) the given element from the list, if the list is not
- *      empty.  Does not free the list element.
- */
-void LST_RemoveElem(struct LST_LIST *pList, struct LST_ELEM *pCurElem)
-{
-	DBC_Require(pList != NULL);
-	DBC_Require(pCurElem != NULL);
-
-	GT_2trace(LST_debugMask, GT_ENTER,
-		  "LST_RemoveElem: pList 0x%x, pCurElem "
-		  "0x%x\n", pList, pCurElem);
-
-	if (!LST_IsEmpty(pList)) {
-		pCurElem->prev->next = pCurElem->next;
-		pCurElem->next->prev = pCurElem->prev;
-
-		/* set elem fields to NULL to prevent illegal references */
-		pCurElem->next = NULL;
-		pCurElem->prev = NULL;
-	}
-}
-
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/services/mem.c kernel-power-2.6.28/drivers/dsp/bridge/services/mem.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/services/mem.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/services/mem.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implementation of platform specific memory services.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,43 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== mem.c ========
- *  Purpose:
- *      Implementation of platform specific memory services.
- *
- *  Public Functions:
- *      MEM_Alloc
- *      MEM_AllocPhysMem
- *      MEM_Calloc
- *      MEM_Exit
- *      MEM_FlushCache
- *      MEM_Free
- *      MEM_FreePhysMem
- *      MEM_Init
- *      MEM_ExtPhysPoolInit
- *
- *! Revision History:
- *! =================
- *! 18-Jan-2004 hp: Added support for External physical memory pool
- *! 19-Apr-2004 sb: Added Alloc/Free PhysMem, FlushCache, VirtualToPhysical
- *! 01-Sep-2001 ag: Code cleanup.
- *! 02-May-2001 ag: MEM_[UnMap]LinearAddress revamped to align Phys to Virt.
- *!		 Set PAGE_PHYSICAL if phy addr <= 512MB. Opposite uSoft doc!
- *! 29-Aug-2000 rr: MEM_LinearAddress does not check for 512MB for non-x86.
- *! 28-Mar-2000 rr: MEM_LinearAddress changed.Handles address larger than 512MB
- *! 03-Feb-2000 rr: Module init/exit is handled by SERVICES Init/Exit.
- *!		 GT Changes.
- *! 22-Nov-1999 kc: Added changes from code review.
- *! 16-Aug-1999 kc: modified for WinCE.
- *! 20-Mar-1999 ag: SP 4 fix in MEM_UMBCalloc().
- *!		 Mdl offset now ORed not added to userBuf.
- *! 23-Dec-1997 cr: Code review changes.
- *! 08-Dec-1997 cr: Prepared for code review.
- *! 24-Jun-1997 cr: Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -71,7 +36,7 @@
 #define MEM_512MB   0x1fffffff
 #define memInfoSign 0x464E494D	/* "MINF" (in reverse). */
 
-#ifdef DEBUG
+#ifdef CONFIG_BRIDGE_DEBUG
 #define MEM_CHECK		/* Use to detect source of memory leaks */
 #endif
 
@@ -80,8 +45,6 @@
 static struct GT_Mask MEM_debugMask = { NULL, NULL };	/* GT trace variable */
 #endif
 
-static u32 cRefs;		/* module reference count */
-
 static bool extPhysMemPoolEnabled;
 
 struct extPhysMemPool {
@@ -95,7 +58,7 @@ static struct extPhysMemPool extMemPool;
 
 /*  Information about each element allocated on heap */
 struct memInfo {
-	struct LST_ELEM link;		/* Must be first */
+	struct list_head link;		/* Must be first */
 	size_t size;
 	void *caller;
 	u32 dwSignature;	/* Should be last */
@@ -119,17 +82,16 @@ static struct memMan mMan;
  *  These functions are similar to LST_PutTail and LST_RemoveElem and are
  *  duplicated here to make MEM independent of LST
  */
-static inline void MLST_PutTail(struct LST_LIST *pList, struct LST_ELEM *pElem)
+static inline void MLST_PutTail(struct LST_LIST *pList, struct list_head *pElem)
 {
 	pElem->prev = pList->head.prev;
 	pElem->next = &pList->head;
 	pList->head.prev = pElem;
 	pElem->prev->next = pElem;
-	pElem->self = pElem;
 }
 
 static inline void MLST_RemoveElem(struct LST_LIST *pList,
-				   struct LST_ELEM *pCurElem)
+				   struct list_head *pCurElem)
 {
 	pCurElem->prev->next = pCurElem->next;
 	pCurElem->next->prev = pCurElem->prev;
@@ -140,8 +102,8 @@ static inline void MLST_RemoveElem(struc
 static void MEM_Check(void)
 {
 	struct memInfo *pMem;
-	struct LST_ELEM *last = &mMan.lst.head;
-	struct LST_ELEM *curr = mMan.lst.head.next;
+	struct list_head *last = &mMan.lst.head;
+	struct list_head *curr = last->next;
 
 	if (!LST_IsEmpty(&mMan.lst)) {
 		GT_0trace(MEM_debugMask, GT_7CLASS, "*** MEMORY LEAK ***\n");
@@ -157,7 +119,7 @@ static void MEM_Check(void)
 					(u32) pMem + sizeof(struct memInfo),
 					pMem->size, pMem->caller);
 				MLST_RemoveElem(&mMan.lst,
-						(struct LST_ELEM *) pMem);
+						(struct list_head *)pMem);
 				kfree(pMem);
 			} else {
 				GT_1trace(MEM_debugMask, GT_7CLASS,
@@ -199,7 +161,7 @@ void MEM_ExtPhysPoolInit(u32 poolPhysBas
 	}
 }
 
-static void MEM_ExtPhysPoolRelease(void)
+void MEM_ExtPhysPoolRelease(void)
 {
 	GT_0trace(MEM_debugMask, GT_1CLASS,
 		  "Releasing External memory pool \n");
@@ -293,7 +255,7 @@ void *MEM_Alloc(u32 cBytes, enum MEM_POO
 
 				spin_lock(&mMan.lock);
 				MLST_PutTail(&mMan.lst,
-					    (struct LST_ELEM *)pMem);
+					    (struct list_head *)pMem);
 				spin_unlock(&mMan.lock);
 
 				pMem = (void *)((u32)pMem +
@@ -313,7 +275,7 @@ void *MEM_Alloc(u32 cBytes, enum MEM_POO
 
 				spin_lock(&mMan.lock);
 				MLST_PutTail(&mMan.lst,
-					    (struct LST_ELEM *) pMem);
+					    (struct list_head *)pMem);
 				spin_unlock(&mMan.lock);
 
 				pMem = (void *)((u32)pMem +
@@ -343,8 +305,6 @@ void *MEM_AllocPhysMem(u32 cBytes, u32 u
 	void *pVaMem = NULL;
 	dma_addr_t paMem;
 
-	DBC_Require(cRefs > 0);
-
 	GT_2trace(MEM_debugMask, GT_ENTER,
 		  "MEM_AllocPhysMem: cBytes 0x%x\tulAlign"
 		  "0x%x\n", cBytes, ulAlign);
@@ -403,7 +363,7 @@ void *MEM_Calloc(u32 cBytes, enum MEM_PO
 				pMem->dwSignature = memInfoSign;
 				spin_lock(&mMan.lock);
 				MLST_PutTail(&mMan.lst,
-					(struct LST_ELEM *) pMem);
+					(struct list_head *)pMem);
 				spin_unlock(&mMan.lock);
 				pMem = (void *)((u32)pMem +
 					sizeof(struct memInfo));
@@ -424,8 +384,8 @@ void *MEM_Calloc(u32 cBytes, enum MEM_PO
 				pMem->caller = __builtin_return_address(0);
 				pMem->dwSignature = memInfoSign;
 				spin_lock(&mMan.lock);
-				MLST_PutTail(&mMan.lst, (struct LST_ELEM *)
-					pMem);
+				MLST_PutTail(&mMan.lst,
+						(struct list_head *)pMem);
 				spin_unlock(&mMan.lock);
 				pMem = (void *)((u32)pMem +
 					sizeof(struct memInfo));
@@ -450,18 +410,9 @@ void *MEM_Calloc(u32 cBytes, enum MEM_PO
  */
 void MEM_Exit(void)
 {
-	DBC_Require(cRefs > 0);
-
-	GT_1trace(MEM_debugMask, GT_5CLASS, "MEM_Exit: cRefs 0x%x\n", cRefs);
-
-	cRefs--;
 #ifdef MEM_CHECK
-	if (cRefs == 0)
-		MEM_Check();
-
+	MEM_Check();
 #endif
-	MEM_ExtPhysPoolRelease();
-	DBC_Ensure(cRefs >= 0);
 }
 
 /*
@@ -471,7 +422,8 @@ void MEM_Exit(void)
  */
 void MEM_FlushCache(void *pMemBuf, u32 cBytes, s32 FlushType)
 {
-	DBC_Require(cRefs > 0);
+	if (!pMemBuf)
+		return;
 
 	switch (FlushType) {
 	/* invalidate only */
@@ -492,10 +444,6 @@ void MEM_FlushCache(void *pMemBuf, u32 c
 		outer_flush_range(__pa((u32)pMemBuf), __pa((u32)pMemBuf +
 				  cBytes));
 	break;
-	default:
-		GT_1trace(MEM_debugMask, GT_6CLASS, "MEM_FlushCache: invalid "
-			  "FlushMemType 0x%x\n", FlushType);
-	break;
 	}
 
 }
@@ -524,7 +472,7 @@ void MEM_VFree(IN void *pMemBuf)
 			if (pMem->dwSignature == memInfoSign) {
 				spin_lock(&mMan.lock);
 				MLST_RemoveElem(&mMan.lst,
-						(struct LST_ELEM *) pMem);
+						(struct list_head *)pMem);
 				spin_unlock(&mMan.lock);
 				pMem->dwSignature = 0;
 				vfree(pMem);
@@ -563,7 +511,7 @@ void MEM_Free(IN void *pMemBuf)
 			if (pMem->dwSignature == memInfoSign) {
 				spin_lock(&mMan.lock);
 				MLST_RemoveElem(&mMan.lst,
-						(struct LST_ELEM *) pMem);
+						(struct list_head *)pMem);
 				spin_unlock(&mMan.lock);
 				pMem->dwSignature = 0;
 				kfree(pMem);
@@ -586,7 +534,6 @@ void MEM_Free(IN void *pMemBuf)
 void MEM_FreePhysMem(void *pVirtualAddress, u32 pPhysicalAddress,
 		     u32 cBytes)
 {
-	DBC_Require(cRefs > 0);
 	DBC_Require(pVirtualAddress != NULL);
 
 	GT_1trace(MEM_debugMask, GT_ENTER, "MEM_FreePhysMem: pVirtualAddress "
@@ -604,25 +551,13 @@ void MEM_FreePhysMem(void *pVirtualAddre
  */
 bool MEM_Init(void)
 {
-	DBC_Require(cRefs >= 0);
-
-	if (cRefs == 0) {
-		GT_create(&MEM_debugMask, "MM");	/* MM for MeM module */
+	GT_create(&MEM_debugMask, "MM");	/* MM for MeM module */
 
 #ifdef MEM_CHECK
-		mMan.lst.head.next = &mMan.lst.head;
-		mMan.lst.head.prev = &mMan.lst.head;
-		mMan.lst.head.self = NULL;
-		spin_lock_init(&mMan.lock);
+	mMan.lst.head.next = &mMan.lst.head;
+	mMan.lst.head.prev = &mMan.lst.head;
+	spin_lock_init(&mMan.lock);
 #endif
 
-	}
-
-	cRefs++;
-
-	GT_1trace(MEM_debugMask, GT_5CLASS, "MEM_Init: cRefs 0x%x\n", cRefs);
-
-	DBC_Ensure(cRefs > 0);
-
 	return true;
 }
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/services/ntfy.c kernel-power-2.6.28/drivers/dsp/bridge/services/ntfy.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/services/ntfy.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/services/ntfy.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Manage lists of notification events.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,31 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== ntfyce.c ========
- *  Purpose:
- *      Manage lists of notification events.
- *
- *  Public Functions:
- *      NTFY_Create
- *      NTFY_Delete
- *      NTFY_Exit
- *      NTFY_Init
- *      NTFY_Notify
- *      NTFY_Register
- *
- *! Revision History:
- *! =================
- *! 06-Feb-2003 kc      Removed DSP_POSTMESSAGE related code.
- *! 05-Nov-2001 kc      Updated DSP_HNOTIFICATION structure.
- *! 10-May-2001 jeh     Removed SERVICES module init/exit from NTFY_Init/Exit.
- *!                     NTFY_Register() returns DSP_ENOTIMPL for all but
- *!                     DSP_SIGNALEVENT.
- *! 12-Oct-2000 jeh     Use MEM_IsValidHandle().
- *! 07-Sep-2000 jeh     Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -52,7 +29,6 @@
 #include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/sync.h>
@@ -77,7 +53,7 @@ struct NTFY_OBJECT {
  *  This object will be created when a client registers for events.
  */
 struct NOTIFICATION {
-	struct LST_ELEM listElem;
+	struct list_head listElem;
 	u32 uEventMask;	/* Events to be notified about */
 	u32 uNotifyType;	/* Type of notification to be sent */
 
@@ -117,12 +93,14 @@ DSP_STATUS NTFY_Create(struct NTFY_OBJEC
 
 		status = SYNC_InitializeDPCCS(&pNtfy->hSync);
 		if (DSP_SUCCEEDED(status)) {
-			pNtfy->notifyList = LST_Create();
+			pNtfy->notifyList = MEM_Calloc(sizeof(struct LST_LIST),
+							MEM_NONPAGED);
 			if (pNtfy->notifyList == NULL) {
 				(void) SYNC_DeleteCS(pNtfy->hSync);
 				MEM_FreeObject(pNtfy);
 				status = DSP_EMEMORY;
 			} else {
+				INIT_LIST_HEAD(&pNtfy->notifyList->head);
 				*phNtfy = pNtfy;
 			}
 		}
@@ -155,7 +133,7 @@ void NTFY_Delete(struct NTFY_OBJECT *hNt
 			DeleteNotify(pNotify);
 		}
 		DBC_Assert(LST_IsEmpty(hNtfy->notifyList));
-		LST_Delete(hNtfy->notifyList);
+		MEM_Free(hNtfy->notifyList);
 	}
 	if (hNtfy->hSync)
 		(void)SYNC_DeleteCS(hNtfy->hSync);
@@ -216,7 +194,7 @@ void NTFY_Notify(struct NTFY_OBJECT *hNt
 
 		}
 		pNotify = (struct NOTIFICATION *)LST_Next(hNtfy->notifyList,
-			  (struct LST_ELEM *)pNotify);
+			  (struct list_head *)pNotify);
 	}
 
 	(void) SYNC_LeaveCS(hNtfy->hSync);
@@ -265,7 +243,7 @@ DSP_STATUS NTFY_Register(struct NTFY_OBJ
 			break;
 		}
 		pNotify = (struct NOTIFICATION *)LST_Next(hNtfy->notifyList,
-			  (struct LST_ELEM *)pNotify);
+			  (struct list_head *)pNotify);
 	}
 	if (pNotify == NULL) {
 		/* Not registered */
@@ -280,7 +258,7 @@ DSP_STATUS NTFY_Register(struct NTFY_OBJ
 
 		}
 		if (DSP_SUCCEEDED(status)) {
-			LST_InitElem((struct LST_ELEM *) pNotify);
+			LST_InitElem((struct list_head *)pNotify);
 			 /* If there is more than one notification type, each
 			 * type may require its own handler code. */
 			status = SYNC_OpenEvent(&pNotify->hSync, &syncAttrs);
@@ -290,7 +268,7 @@ DSP_STATUS NTFY_Register(struct NTFY_OBJ
 				pNotify->uEventMask = uEventMask;
 				pNotify->uNotifyType = uNotifyType;
 				LST_PutTail(hNtfy->notifyList,
-					   (struct LST_ELEM *)pNotify);
+					   (struct list_head *)pNotify);
 			} else {
 				DeleteNotify(pNotify);
 			}
@@ -300,7 +278,7 @@ DSP_STATUS NTFY_Register(struct NTFY_OBJ
 		if (uEventMask == 0) {
 			/* Remove from list and free */
 			LST_RemoveElem(hNtfy->notifyList,
-				      (struct LST_ELEM *)pNotify);
+				      (struct list_head *)pNotify);
 			DeleteNotify(pNotify);
 		} else {
 			/* Update notification mask (type shouldn't change) */
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/services/reg.c kernel-power-2.6.28/drivers/dsp/bridge/services/reg.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/services/reg.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/services/reg.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provide registry functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,25 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== regce.c ========
- *  Purpose:
- *      Provide registry functions.
- *
- *  Public Functions:
- *      REG_DeleteValue
- *      REG_EnumValue
- *      REG_Exit
- *      REG_GetValue
- *      REG_Init
- *      REG_SetValue
- *
- *! Revision History:
- *! ================
- *
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -46,12 +29,8 @@
 #include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/mem.h>
 
-/*  ----------------------------------- Others */
-#include <dspbridge/dbreg.h>
-
 /*  ----------------------------------- This */
 #include <dspbridge/reg.h>
 #include <regsup.h>
@@ -65,22 +44,14 @@ struct GT_Mask REG_debugMask = { NULL, N
  *  Deletes a registry entry value.  NOTE:  A registry entry value is not the
  *  same as *  a registry key.
  */
-DSP_STATUS REG_DeleteValue(OPTIONAL IN HANDLE *phKey, IN CONST char *pstrSubkey,
-			   IN CONST char *pstrValue)
+DSP_STATUS REG_DeleteValue(IN CONST char *pstrValue)
 {
 	DSP_STATUS status;
-	DBC_Require(pstrSubkey && pstrValue);
-	DBC_Require(phKey == NULL);
-       DBC_Require(strlen(pstrSubkey) < REG_MAXREGPATHLENGTH);
-       DBC_Require(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
+	DBC_Require(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
 
 	GT_0trace(REG_debugMask, GT_ENTER, "REG_DeleteValue: entered\n");
 
-	/*  Note that we don't use phKey */
-	if (regsupDeleteValue(pstrSubkey, pstrValue) == DSP_SOK)
-		status = DSP_SOK;
-	else
-		status = DSP_EFAIL;
+	status = regsupDeleteValue(pstrValue);
 
 	return status;
 }
@@ -91,7 +62,7 @@ DSP_STATUS REG_DeleteValue(OPTIONAL IN H
  *  We will assume the input pdwValueSize is smaller than
  *  REG_MAXREGPATHLENGTH for implementation purposes.
  */
-DSP_STATUS REG_EnumValue(IN HANDLE *phKey, IN u32 dwIndex,
+DSP_STATUS REG_EnumValue(IN u32 dwIndex,
 			 IN CONST char *pstrKey, IN OUT char *pstrValue,
 			 IN OUT u32 *pdwValueSize, IN OUT char *pstrData,
 			 IN OUT u32 *pdwDataSize)
@@ -101,7 +72,6 @@ DSP_STATUS REG_EnumValue(IN HANDLE *phKe
 	DBC_Require(pstrKey && pstrValue && pdwValueSize && pstrData &&
 		    pdwDataSize);
 	DBC_Require(*pdwValueSize <= REG_MAXREGPATHLENGTH);
-	DBC_Require(phKey == NULL);
        DBC_Require(strlen(pstrKey) < REG_MAXREGPATHLENGTH);
 
 	GT_0trace(REG_debugMask, GT_ENTER, "REG_EnumValue: entered\n");
@@ -127,15 +97,12 @@ void REG_Exit(void)
  *  ======== REG_GetValue ========
  *  Retrieve a value from the registry.
  */
-DSP_STATUS REG_GetValue(OPTIONAL IN HANDLE *phKey, IN CONST char *pstrSubkey,
-			IN CONST char *pstrValue, OUT u8 *pbData,
+DSP_STATUS REG_GetValue(IN CONST char *pstrValue, OUT u8 *pbData,
 			IN OUT u32 *pdwDataSize)
 {
 	DSP_STATUS status;
 
-	DBC_Require(pstrSubkey && pstrValue && pbData);
-	DBC_Require(phKey == NULL);
-       DBC_Require(strlen(pstrSubkey) < REG_MAXREGPATHLENGTH);
+	DBC_Require(pstrValue && pbData);
        DBC_Require(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
 
 	GT_0trace(REG_debugMask, GT_ENTER, "REG_GetValue: entered\n");
@@ -172,24 +139,21 @@ bool REG_Init(void)
  *  ======== REG_SetValue ========
  *  Set a value in the registry.
  */
-DSP_STATUS REG_SetValue(OPTIONAL IN HANDLE *phKey, IN CONST char *pstrSubkey,
-			IN CONST char *pstrValue, IN CONST u32 dwType,
-			IN u8 *pbData, IN u32 dwDataSize)
+DSP_STATUS REG_SetValue(IN CONST char *pstrValue, IN u8 *pbData,
+			IN u32 dwDataSize)
 {
 	DSP_STATUS status;
 
 	DBC_Require(pstrValue && pbData);
-	DBC_Require(phKey == NULL);
 	DBC_Require(dwDataSize > 0);
-       DBC_Require(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
+	DBC_Require(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
 
-	/*  We need to use regsup calls...  */
-	/*  ...for now we don't need the key handle or  */
-	/*  the subkey, all we need is the value to lookup.  */
-	if (regsupSetValue((char *)pstrValue, pbData, dwDataSize) == DSP_SOK)
-		status = DSP_SOK;
-	else
-		status = DSP_EFAIL;
+	/*
+	 * We need to use regsup calls
+	 * for now we don't need the key handle or
+	 * the subkey, all we need is the value to lookup.
+	 */
+	status = regsupSetValue((char *)pstrValue, pbData, dwDataSize);
 
 	return status;
 }
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/services/regsup.c kernel-power-2.6.28/drivers/dsp/bridge/services/regsup.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/services/regsup.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/services/regsup.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provide registry support functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,20 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== regsup.c ========
- *  Purpose:
- *      Provide registry support functions.
- *
- *! Revision History:
- *! ================
- *! 28-May-2002  map: Integrated PSI's dspimage update mechanism
- *! 11-May-2002  gp:  Turned PERF "on".
- *! 21-May-2002  map: Fixed bug in SetValue - if resizing datasize, set
- *!		      new size too
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -35,7 +23,6 @@
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
 #include <dspbridge/errbase.h>
-#include <dspbridge/dbreg.h>
 
 /*  ----------------------------------- Trace & Debug */
 #include <dspbridge/dbc.h>
@@ -43,50 +30,23 @@
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/mem.h>
-#include <dspbridge/csl.h>
+#include <dspbridge/list.h>
 
 /*  ----------------------------------- This */
 #include <regsup.h>
 
-struct RegValueStruct {
-	char name[BRIDGE_MAX_NAME_SIZE];   /*  Name of a given value entry  */
+struct RegValue {
+	struct list_head link;	/* Make it linked to a list */
+	char name[MAXREGPATHLENGTH];   /*  Name of a given value entry  */
 	u32 dataSize;		/*  Size of the data  */
 	void *pData;		/*  Pointer to the actual data  */
 };
 
-struct RegKeyStruct {
-	/*The current number of value entries this key has*/
-	u32 numValueEntries;
-	/* Array of value entries */
-	struct RegValueStruct values[BRIDGE_MAX_NUM_REG_ENTRIES];
-};
-
-
 /*  Pointer to the registry support key  */
-static struct RegKeyStruct *pRegKey;
+static struct LST_LIST regKey, *pRegKey = &regKey;
 
 #if GT_TRACE
 extern struct GT_Mask REG_debugMask;	/* GT trace var. */
-/*
- *  ======== printS ========
- *  Purpose:
- *      Displays printable characters in pBuf, if any.
- */
-static inline void printS(void *pBuf)
-{
-	int pos = 0;
-	if (*(REG_debugMask).flags & (GT_2CLASS)) {
-		while (*(u8 *)((pBuf)+pos) >= ' ' &&
-		       *(u8 *)((pBuf)+pos) <= '~') {
-			GT_1trace(REG_debugMask, GT_2CLASS, "%c",
-					*(u8 *)((pBuf) + pos++));
-		}
-
-		GT_0trace(REG_debugMask, GT_2CLASS, "\n");
-	}
-}
-#else
-#define printS(pBuf)
 #endif
 
 /*
@@ -96,14 +56,7 @@ static inline void printS(void *pBuf)
  */
 bool regsupInit(void)
 {
-	if (pRegKey != NULL)
-		return true;
-
-	/*  Need to allocate and setup our registry.  */
-	pRegKey = MEM_Calloc(sizeof(struct RegKeyStruct), MEM_NONPAGED);
-	if (pRegKey == NULL)
-		return false;
-
+	INIT_LIST_HEAD(&pRegKey->head);
 	return true;
 }
 
@@ -114,41 +67,14 @@ bool regsupInit(void)
  */
 void regsupExit(void)
 {
-	u32 i;
-
-	/*  Make sure data has actually been allocated.  */
-	if (pRegKey == NULL) {
-		/*  Nothing initialized.return!  */
-		return;
-	}
-
-	GT_1trace(REG_debugMask, GT_2CLASS, "pRegKey->numValueEntries %d\n",
-		  pRegKey->numValueEntries);
-
+	struct RegValue *rv;
 	/*  Now go through each entry and free all resources.  */
-	for (i = 0; ((i < BRIDGE_MAX_NUM_REG_ENTRIES) &&
-	    (i < pRegKey->numValueEntries)); i++) {
-		if (pRegKey->values[i].name[0] != '\0') {
-			/*  We have a valid entry.free it up!  */
-			if (pRegKey->values[i].pData != NULL) {
-				GT_3trace(REG_debugMask, GT_2CLASS,
-					  "E %d\t %s DATA %x ", i,
-					  pRegKey->values[i].name,
-					  *(u32 *)pRegKey->values[i].pData);
-				printS((u8 *)(pRegKey->values[i].pData));
-				MEM_Free(pRegKey->values[i].pData);
-			}
-			pRegKey->values[i].pData = NULL;
-			pRegKey->values[i].dataSize = 0;
-			pRegKey->values[i].name[0] = '\0';
-		}
-	}
-
-	/*  Now that all of the resources are freed up, free the main one!  */
-	MEM_Free(pRegKey);
+	while (!LST_IsEmpty(pRegKey)) {
+		rv = (struct RegValue *) LST_GetHead(pRegKey);
 
-	/*  Don't forget to NULL out the global entry!  */
-	pRegKey = NULL;
+		MEM_Free(rv->pData);
+		MEM_Free(rv);
+	}
 }
 
 /*
@@ -159,31 +85,29 @@ void regsupExit(void)
 DSP_STATUS regsupGetValue(char *valName, void *pBuf, u32 *dataSize)
 {
 	DSP_STATUS retVal = DSP_EFAIL;
-	u32 i;
+	struct RegValue *rv = (struct RegValue *) LST_First(pRegKey);
 
 	/*  Need to search through the entries looking for the right one.  */
-	for (i = 0; i < pRegKey->numValueEntries; i++) {
+	while (rv) {
 		/*  See if the name matches.  */
-               if (strncmp(pRegKey->values[i].name, valName,
-		    BRIDGE_MAX_NAME_SIZE) == 0) {
-
+		if (strncmp(rv->name, valName, MAXREGPATHLENGTH) == 0) {
 			/*  We have a match!  Copy out the data.  */
-			memcpy(pBuf, pRegKey->values[i].pData,
-			       pRegKey->values[i].dataSize);
+			memcpy(pBuf, rv->pData, rv->dataSize);
 
 			/*  Get the size for the caller.  */
-			*dataSize = pRegKey->values[i].dataSize;
+			*dataSize = rv->dataSize;
 
 			/*  Set our status to good and exit.  */
 			retVal = DSP_SOK;
 			break;
 		}
+		rv = (struct RegValue *) LST_Next(pRegKey,
+						(struct list_head *) rv);
 	}
 
 	if (DSP_SUCCEEDED(retVal)) {
 		GT_2trace(REG_debugMask, GT_2CLASS, "G %s DATA %x ", valName,
 			  *(u32 *)pBuf);
-		printS((u8 *)pBuf);
 	} else {
 		GT_1trace(REG_debugMask, GT_3CLASS, "G %s FAILED\n", valName);
 	}
@@ -199,65 +123,51 @@ DSP_STATUS regsupGetValue(char *valName,
 DSP_STATUS regsupSetValue(char *valName, void *pBuf, u32 dataSize)
 {
 	DSP_STATUS retVal = DSP_EFAIL;
-	u32 i;
+	struct RegValue *rv = (struct RegValue *) LST_First(pRegKey);
 
 	GT_2trace(REG_debugMask, GT_2CLASS, "S %s DATA %x ", valName,
 		  *(u32 *)pBuf);
-	printS((u8 *)pBuf);
 
 	/*  Need to search through the entries looking for the right one.  */
-	for (i = 0; i < pRegKey->numValueEntries; i++) {
+	while (rv) {
 		/*  See if the name matches.  */
-               if (strncmp(pRegKey->values[i].name, valName,
-		    BRIDGE_MAX_NAME_SIZE) == 0) {
+		if (strncmp(rv->name, valName, MAXREGPATHLENGTH) == 0) {
 			/*  Make sure the new data size is the same.  */
-			if (dataSize != pRegKey->values[i].dataSize) {
+			if (dataSize != rv->dataSize) {
 				/*  The caller needs a different data size!  */
-				MEM_Free(pRegKey->values[i].pData);
-				pRegKey->values[i].pData = MEM_Alloc(dataSize,
-							   MEM_NONPAGED);
-				if (pRegKey->values[i].pData == NULL)
+				MEM_Free(rv->pData);
+				rv->pData = MEM_Alloc(dataSize, MEM_NONPAGED);
+				if (rv->pData == NULL)
 					break;
-
 			}
 
 			/*  We have a match!  Copy out the data.  */
-			memcpy(pRegKey->values[i].pData, pBuf, dataSize);
+			memcpy(rv->pData, pBuf, dataSize);
 
 			/* Reset datasize - overwrite if new or same */
-			pRegKey->values[i].dataSize = dataSize;
+			rv->dataSize = dataSize;
 
 			/*  Set our status to good and exit.  */
 			retVal = DSP_SOK;
 			break;
 		}
+	       rv = (struct RegValue *) LST_Next(pRegKey,
+					(struct list_head *) rv);
 	}
 
 	/*  See if we found a match or if this is a new entry  */
-	if (i == pRegKey->numValueEntries) {
+	if (!rv) {
 		/*  No match, need to make a new entry  */
-		/*  First check to see if we can make any more entries.  */
-		if (pRegKey->numValueEntries < BRIDGE_MAX_NUM_REG_ENTRIES) {
-			char *tmp_name =
-				pRegKey->values[pRegKey->numValueEntries].name;
-			strncpy(tmp_name, valName, BRIDGE_MAX_NAME_SIZE - 1);
-			tmp_name[BRIDGE_MAX_NAME_SIZE - 1] = '\0';
-			pRegKey->values[pRegKey->numValueEntries].pData =
-					MEM_Alloc(dataSize, MEM_NONPAGED);
-			if (pRegKey->values[pRegKey->numValueEntries].pData !=
-									NULL) {
-				memcpy(pRegKey->
-					values[pRegKey->numValueEntries].pData,
-					pBuf, dataSize);
-				pRegKey->
-				    values[pRegKey->numValueEntries].dataSize =
-				    dataSize;
-				pRegKey->numValueEntries++;
-				retVal = DSP_SOK;
-			}
-		} else {
-			GT_0trace(REG_debugMask, GT_7CLASS,
-				  "MAX NUM REG ENTRIES REACHED\n");
+		struct RegValue *new = MEM_Calloc(sizeof(struct RegValue),
+						MEM_NONPAGED);
+
+		strncat(new->name, valName, MAXREGPATHLENGTH - 1);
+		new->pData = MEM_Alloc(dataSize, MEM_NONPAGED);
+		if (new->pData != NULL) {
+			memcpy(new->pData, pBuf, dataSize);
+			new->dataSize = dataSize;
+			LST_PutTail(pRegKey, (struct list_head *) new);
+			retVal = DSP_SOK;
 		}
 	}
 
@@ -274,7 +184,7 @@ DSP_STATUS regsupEnumValue(IN u32 dwInde
 			   IN OUT char *pstrData, IN OUT u32 *pdwDataSize)
 {
 	DSP_STATUS retVal = REG_E_INVALIDSUBKEY;
-	u32 i;
+	struct RegValue *rv = (struct RegValue *) LST_First(pRegKey);
        u32 dwKeyLen;
 	u32 count = 0;
 
@@ -282,28 +192,26 @@ DSP_STATUS regsupEnumValue(IN u32 dwInde
        dwKeyLen = strlen(pstrKey);
 
 	/*  Need to search through the entries looking for the right one.  */
-	for (i = 0; i < pRegKey->numValueEntries; i++) {
+	while (rv) {
 		/*  See if the name matches.  */
-               if ((strncmp(pRegKey->values[i].name, pstrKey,
-		    dwKeyLen) == 0) && count++ == dwIndex) {
+		if (strncmp(rv->name, pstrKey, dwKeyLen) == 0 &&
+			count++ == dwIndex) {
 			/*  We have a match!  Copy out the data.  */
-			memcpy(pstrData, pRegKey->values[i].pData,
-				pRegKey->values[i].dataSize);
+			memcpy(pstrData, rv->pData, rv->dataSize);
 			/*  Get the size for the caller.  */
-			*pdwDataSize = pRegKey->values[i].dataSize;
-                       *pdwValueSize = strlen(&(pRegKey->
-						values[i].name[dwKeyLen]));
-                       strncpy(pstrValue,
-				    &(pRegKey->values[i].name[dwKeyLen]),
+			*pdwDataSize = rv->dataSize;
+			*pdwValueSize = strlen(&(rv->name[dwKeyLen]));
+			strncpy(pstrValue, &(rv->name[dwKeyLen]),
 				    *pdwValueSize + 1);
 			GT_3trace(REG_debugMask, GT_2CLASS,
 				  "E Key %s, Value %s, Data %x ",
 				  pstrKey, pstrValue, *(u32 *)pstrData);
-			printS((u8 *)pstrData);
 			/*  Set our status to good and exit.  */
 			retVal = DSP_SOK;
 			break;
 		}
+	       rv = (struct RegValue *) LST_Next(pRegKey,
+						(struct list_head *) rv);
 	}
 
 	if (count && DSP_FAILED(retVal))
@@ -315,54 +223,30 @@ DSP_STATUS regsupEnumValue(IN u32 dwInde
 /*
  *  ======== regsupDeleteValue ========
  */
-DSP_STATUS regsupDeleteValue(IN CONST char *pstrSubkey,
-			    IN CONST char *pstrValue)
+DSP_STATUS regsupDeleteValue(IN CONST char *pstrValue)
 {
 	DSP_STATUS retVal = DSP_EFAIL;
-	u32 i;
+	struct RegValue *rv = (struct RegValue *) LST_First(pRegKey);
 
-	for (i = 0; ((i < BRIDGE_MAX_NUM_REG_ENTRIES) &&
-	    (i < pRegKey->numValueEntries)); i++) {
-		/*  See if the name matches...  */
-               if (strncmp(pRegKey->values[i].name, pstrValue,
-		    BRIDGE_MAX_NAME_SIZE) == 0) {
+	while (rv) {
+		/*  See if the name matches.  */
+		if (strncmp(rv->name, pstrValue, MAXREGPATHLENGTH) == 0) {
 			/* We have a match!  Delete this key.  To delete a
 			 * key, we free all resources associated with this
 			 * key and, if we're not already the last entry in
 			 * the array, we copy that entry into this deleted
 			 * key.
 			 */
-			MEM_Free(pRegKey->values[i].pData);
-			if ((pRegKey->numValueEntries - 1) == i) {
-				/* we're deleting the last one */
-				pRegKey->values[i].name[0] = '\0';
-				pRegKey->values[i].dataSize = 0;
-				pRegKey->values[i].pData = NULL;
-			} else {
-				/* move the last one here */
-                               strncpy(pRegKey->values[i].name, pRegKey->
-				    values[pRegKey->numValueEntries - 1].name,
-				    BRIDGE_MAX_NAME_SIZE);
-				pRegKey->values[i].dataSize =
-				    pRegKey->
-				    values[pRegKey->numValueEntries-1].dataSize;
-				pRegKey->values[i].pData =
-				    pRegKey->
-				    values[pRegKey->numValueEntries-1].pData;
-				/* don't have to do this, but for
-				 * the paranoid... */
-				pRegKey->
-				    values[pRegKey->numValueEntries-1].name[0] =
-				    '\0';
-			}
-
-			/* another one bites the dust. */
-			pRegKey->numValueEntries--;
+			LST_RemoveElem(pRegKey, (struct list_head *)rv);
+			MEM_Free(rv->pData);
+			MEM_Free(rv);
 
 			/*  Set our status to good and exit...  */
 			retVal = DSP_SOK;
 			break;
 		}
+		rv = (struct RegValue *)LST_Next(pRegKey,
+				(struct list_head *)rv);
 	}
 	return retVal;
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/services/regsup.h kernel-power-2.6.28/drivers/dsp/bridge/services/regsup.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/services/regsup.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/services/regsup.h	2011-05-02 22:36:50.000000000 +0100
@@ -14,20 +14,9 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== regsup.h ========
- *
- *! Revision History
- *! ================
- */
-
 #ifndef _REGSUP_H_
 #define _REGSUP_H_
 
-#define BRIDGE_MAX_NAME_SIZE                     MAXREGPATHLENGTH
-#define BRIDGE_MAX_NUM_REG_ENTRIES               52
-
 /*  Init function. MUST be called BEFORE any calls are  */
 /*  made into this psuedo-registry!!!  Returns TRUE/FALSE for SUCCESS/ERROR  */
 extern bool regsupInit(void);
@@ -38,8 +27,8 @@ extern void regsupExit(void);
 /*
  *  ======== regsupDeleteValue ========
  */
-extern DSP_STATUS regsupDeleteValue(IN CONST char *pstrSubkey,
-				    IN CONST char *pstrValue);
+extern DSP_STATUS regsupDeleteValue(IN CONST char *pstrValue);
+
 /*  Get the value of the entry having the given name.  Returns DSP_SOK  */
 /*  if an entry was found and the value retrieved.  Returns DSP_EFAIL
  *  otherwise.*/
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/services/services.c kernel-power-2.6.28/drivers/dsp/bridge/services/services.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/services/services.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/services/services.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Provide SERVICES loading.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,24 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== services.c ========
- *  Purpose:
- *      Provide SERVICES loading.
- *
- *  Public Functions:
- *      SERVICES_Exit
- *      SERVICES_Init
- *
- *
- *! Revision History
- *! ================
- *! 20-Nov-2000 rr: NTFY_Init/Exit added.
- *! 06-Jul-2000 rr: PROC prefix changed to PRCS to accomodate RM.
- *! 01-Feb-2000 kc: Created.
- */
-
 #include <dspbridge/host_os.h>
 
 /*  ----------------------------------- DSP/BIOS Bridge */
@@ -44,17 +28,12 @@
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/cfg.h>
-#include <dspbridge/csl.h>
 #include <dspbridge/dbg.h>
-#include <dspbridge/dpc.h>
-#include <dspbridge/kfile.h>
-#include <dspbridge/list.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/ntfy.h>
 #include <dspbridge/reg.h>
 #include <dspbridge/sync.h>
 #include <dspbridge/clk.h>
-#include <dspbridge/util.h>
 
 /*  ----------------------------------- This */
 #include <dspbridge/services.h>
@@ -64,8 +43,6 @@
 static struct GT_Mask SERVICES_debugMask = { NULL, NULL };  /* GT trace var. */
 #endif
 
-static u32 cRefs;		/* SERVICES module reference count */
-
 /*
  *  ======== SERVICES_Exit ========
  *  Purpose:
@@ -74,31 +51,16 @@ static u32 cRefs;		/* SERVICES module re
  */
 void SERVICES_Exit(void)
 {
-	DBC_Require(cRefs > 0);
+	/* Uninitialize all SERVICES modules here */
+	NTFY_Exit();
+	SYNC_Exit();
+	CLK_Exit();
+	REG_Exit();
+	DBG_Exit();
+	CFG_Exit();
+	MEM_Exit();
 
-	GT_1trace(SERVICES_debugMask, GT_5CLASS, "SERVICES_Exit: cRefs 0x%x\n",
-		 cRefs);
-
-	cRefs--;
-	if (cRefs == 0) {
-		/* Uninitialize all SERVICES modules here */
-		NTFY_Exit();
-		UTIL_Exit();
-		SYNC_Exit();
-		CLK_Exit();
-		REG_Exit();
-		LST_Exit();
-		KFILE_Exit();
-		DPC_Exit();
-		DBG_Exit();
-		CSL_Exit();
-		CFG_Exit();
-		MEM_Exit();
-
-		GT_exit();
-	}
-
-	DBC_Ensure(cRefs >= 0);
+	GT_exit();
 }
 
 /*
@@ -109,84 +71,49 @@ void SERVICES_Exit(void)
 bool SERVICES_Init(void)
 {
 	bool fInit = true;
-       bool fCFG, fCSL, fDBG, fDPC, fKFILE, fLST, fMEM;
-       bool fREG, fSYNC, fCLK, fUTIL, fNTFY;
-
-	DBC_Require(cRefs >= 0);
+	bool fCFG, fDBG, fMEM;
+	bool fREG, fSYNC, fCLK, fNTFY;
 
-	if (cRefs == 0) {
+	GT_init();
+	GT_create(&SERVICES_debugMask, "OS");	/* OS for OSal */
 
-		GT_init();
-		GT_create(&SERVICES_debugMask, "OS");	/* OS for OSal */
-
-		GT_0trace(SERVICES_debugMask, GT_ENTER,
+	GT_0trace(SERVICES_debugMask, GT_ENTER,
 			 "SERVICES_Init: entered\n");
 
-		/* Perform required initialization of SERVICES modules. */
-		fMEM = MEM_Init();
-		fREG = REG_Init();
-		fCFG = CFG_Init();
-		fCSL = CSL_Init();
-		fDBG = DBG_Init();
-		fDPC = DPC_Init();
-		fKFILE = KFILE_Init();
-		fLST = LST_Init();
-		/* fREG = REG_Init(); */
-		fSYNC = SYNC_Init();
-		fCLK  = CLK_Init();
-		fUTIL = UTIL_Init();
-		fNTFY = NTFY_Init();
-
-               fInit = fCFG && fCSL && fDBG && fDPC && fKFILE &&
-                       fLST && fMEM && fREG && fSYNC && fCLK && fUTIL;
-
-		if (!fInit) {
-			if (fNTFY)
-				NTFY_Exit();
-
-			if (fUTIL)
-				UTIL_Exit();
-
-			if (fSYNC)
-				SYNC_Exit();
-
-			if (fCLK)
-				CLK_Exit();
-
-			if (fREG)
-				REG_Exit();
-
-			if (fLST)
-				LST_Exit();
-
-			if (fKFILE)
-				KFILE_Exit();
-
-			if (fDPC)
-				DPC_Exit();
-
-			if (fDBG)
-				DBG_Exit();
-
-			if (fCSL)
-				CSL_Exit();
-
-			if (fCFG)
-				CFG_Exit();
+	/* Perform required initialization of SERVICES modules. */
+	fMEM = MEM_Init();
+	fREG = REG_Init();
+	fCFG = CFG_Init();
+	fDBG = DBG_Init();
+	fSYNC = SYNC_Init();
+	fCLK  = CLK_Init();
+	fNTFY = NTFY_Init();
+
+	fInit = fCFG && fDBG && fMEM && fREG && fSYNC && fCLK;
+
+	if (!fInit) {
+		if (fNTFY)
+			NTFY_Exit();
+
+		if (fSYNC)
+			SYNC_Exit();
+
+		if (fCLK)
+			CLK_Exit();
+
+		if (fREG)
+			REG_Exit();
 
-			if (fMEM)
-				MEM_Exit();
+		if (fDBG)
+			DBG_Exit();
 
-		}
-	}
+		if (fCFG)
+			CFG_Exit();
 
-	if (fInit)
-		cRefs++;
+		if (fMEM)
+			MEM_Exit();
 
-	GT_1trace(SERVICES_debugMask, GT_5CLASS, "SERVICES_Init: cRefs 0x%x\n",
-		 cRefs);
-
-	DBC_Ensure((fInit && (cRefs > 0)) || (!fInit && (cRefs >= 0)));
+	}
 
 	return fInit;
 }
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/services/sync.c kernel-power-2.6.28/drivers/dsp/bridge/services/sync.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/services/sync.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/services/sync.c	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Synchronization services.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,39 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== sync.c ========
- *  Purpose:
- *      Synchronization services.
- *
- *  Public Functions:
- *      SYNC_CloseEvent
- *      SYNC_DeleteCS
- *      SYNC_EnterCS
- *      SYNC_Exit
- *      SYNC_Init
- *      SYNC_InitializeCS
- *      SYNC_LeaveCS
- *      SYNC_OpenEvent
- *      SYNC_ResetEvent
- *      SYNC_SetEvent
- *      SYNC_WaitOnEvent
- *      SYNC_WaitOnMultipleEvents
- *
- *! Revision History:
- *! ================
- *! 05-Nov-2001 kc: Minor cosmetic changes.
- *! 05-Oct-2000 jeh Added SYNC_WaitOnMultipleEvents().
- *! 10-Aug-2000 rr: SYNC_PostMessage added.
- *! 10-Jul-2000 jeh Modified SYNC_OpenEvent() to handle NULL attrs.
- *! 03-Feb-2000 rr: Module init/exit is handled by SERVICES Init/Exit.
- *!		 GT Changes.
- *! 01-Dec-1999 ag: Added optional named event creation in SYNC_OpenEvent().
- *! 22-Nov-1999 kc: Added changes from code review.
- *! 22-Sep-1999 kc: Modified from sync95.c.
- *! 05-Aug-1996 gp: Created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -60,7 +29,6 @@
 #include <dspbridge/gt.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/mem.h>
 
 /*  ----------------------------------- This */
@@ -219,7 +187,6 @@ DSP_STATUS SYNC_ResetEvent(struct SYNC_O
 
 	if (MEM_IsValidHandle(hEvent, SIGNATURE)) {
 		pEvent->state = so_reset;
-		status = DSP_SOK;
 	} else {
 		status = DSP_EHANDLE;
 		GT_1trace(SYNC_debugMask, GT_6CLASS,
@@ -362,7 +329,7 @@ DSP_STATUS SYNC_WaitOnMultipleEvents(str
 	if (Wp->state != wo_signalled && dwTimeout > 0) {
 		struct timer_list timeout;
 		if (dwTimeout != SYNC_INFINITE) {
-			init_timer(&timeout);
+			init_timer_on_stack(&timeout);
 			timeout.function = timeout_callback;
 			timeout.data = (unsigned long)Wp;
 			timeout.expires = jiffies + dwTimeout * HZ / 1000;
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/_cmm.h kernel-power-2.6.28/drivers/dsp/bridge/wmd/_cmm.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/_cmm.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/_cmm.h	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,10 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Private header file defining CMM manager objects and defines needed
+ * by IO manager to register shared memory regions when DSP base image
+ * is loaded(WMD_IO_OnLoaded).
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,24 +18,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _cmm.h ========
- *  Description:
- *      Private header file defining CMM manager objects and defines needed
- *      by IO manager to register shared memory regions when DSP base image
- *      is loaded(WMD_IO_OnLoaded).
- *
- *  Public Functions:
- *      None.
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 24-Aug-2001 ag     Created.
- */
-
 #ifndef _CMM_
 #define _CMM_
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/_deh.h kernel-power-2.6.28/drivers/dsp/bridge/wmd/_deh.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/_deh.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/_deh.h	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Private header for DEH module.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,21 +16,9 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _deh.h ========
- *  Description:
- *      Private header for DEH module.
- *
- *! Revision History:
- *! ================
- *! 21-Sep-2001 kc: created.
- */
-
 #ifndef _DEH_
 #define _DEH_
 
-#include <dspbridge/dpc.h>
 #include <dspbridge/ntfy.h>
 #include <dspbridge/wmd.h>
 
@@ -39,8 +29,10 @@ struct DEH_MGR {
 	u32 dwSignature;	/* Used for object validation.  */
 	struct WMD_DEV_CONTEXT *hWmdContext;	/* WMD device context. */
 	struct NTFY_OBJECT *hNtfy;	/* NTFY object                  */
-	struct DPC_OBJECT *hMmuFaultDpc;	/* DPC object handle.  */
 	struct DSP_ERRORINFO errInfo;	/* DSP exception info.          */
+
+	/* MMU Fault DPC */
+	struct tasklet_struct dpc_tasklet;
 } ;
 
 #endif				/* _DEH_ */
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/_msg_sm.h kernel-power-2.6.28/drivers/dsp/bridge/wmd/_msg_sm.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/_msg_sm.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/_msg_sm.h	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,9 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Private header file defining MSG manager objects and defines needed
+ * by IO manager.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,24 +17,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _msg_sm.h ========
- *  Description:
- *      Private header file defining MSG manager objects and defines needed
- *      by IO manager.
- *
- *  Public Functions:
- *      None.
- *
- *  Notes:
- *
- *! Revision History:
- *! ================
- *! 09-May-2001 jeh     Code Review cleanup.
- *! 08-Nov-2000 jeh     Created.
- */
-
 #ifndef _MSG_SM_
 #define _MSG_SM_
 
@@ -121,7 +106,7 @@ struct MSG_MGR {
  *  The MSG_QUEUE's hSynEvent gets posted when a message is ready.
  */
 struct MSG_QUEUE {
-	struct LST_ELEM listElem;
+	struct list_head listElem;
 	u32 dwSignature;
 	struct MSG_MGR *hMsgMgr;
 	u32 uMaxMsgs;	/* Node message depth */
@@ -150,7 +135,7 @@ struct MSG_DSPMSG {
  *  ======== MSG_FRAME ========
  */
 struct MSG_FRAME {
-	struct LST_ELEM listElem;
+	struct list_head listElem;
 	struct MSG_DSPMSG msgData;
 } ;
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/_tiomap.h kernel-power-2.6.28/drivers/dsp/bridge/wmd/_tiomap.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/_tiomap.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/_tiomap.h	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definitions and types private to this WMD.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,13 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== _tiomap.h ========
- *  Description:
- *      Definitions and types private to this WMD.
- *
- */
-
 #ifndef _TIOMAP_
 #define _TIOMAP_
 
@@ -214,12 +209,8 @@ static const struct MAP_L4PERIPHERAL L4P
 #define MBX_PM_MAX_RESOURCES 11
 
 /*  Power Management Commands */
-enum BPWR_ExtClockCmd {
-	BPWR_DisableClock = 0,
-	BPWR_EnableClock,
-	BPWR_DisableAutoIdle,
-	BPWR_EnableAutoIdle
-} ;
+#define BPWR_DisableClock	0
+#define BPWR_EnableClock	1
 
 /* OMAP242x specific resources */
 enum BPWR_ExtClockId {
@@ -275,21 +266,6 @@ static const struct BPWR_Clk_t BPWR_Clks
 #define INTH_MASK_IT_REG_OFFSET         0x04	/* Mask Interrupt reg offset  */
 
 #define   DSP_MAILBOX1_INT              10
-
-/*
- *  INTH_InterruptKind_t
- *  Identify the kind of interrupt: either FIQ/IRQ
- */
-enum INTH_InterruptKind_t {
-	INTH_IRQ = 0,
-	INTH_FIQ = 1
-} ;
-
-enum INTH_SensitiveEdge_t {
-	FALLING_EDGE_SENSITIVE = 0,
-	LOW_LEVEL_SENSITIVE = 1
-} ;
-
 /*
  *  Bit definition of  Interrupt  Level  Registers
  */
@@ -322,9 +298,9 @@ enum INTH_SensitiveEdge_t {
 #define ClearBit(reg, mask)             (reg &= ~mask)
 #define SetBit(reg, mask)               (reg |= mask)
 
-#define SetGroupBits16(reg, position, width, value) \
-	do {\
-		reg &= ~((0xFFFF >> (16 - (width))) << (position)) ; \
+#define SetGroupBits16(reg, position, width, value)			     \
+	do {								     \
+		reg &= ~((0xFFFF >> (16 - (width))) << (position));	     \
 		reg |= ((value & (0xFFFF >> (16 - (width)))) << (position)); \
 	} while (0);
 
@@ -333,24 +309,24 @@ enum INTH_SensitiveEdge_t {
 /* This mini driver's device context: */
 struct WMD_DEV_CONTEXT {
 	struct DEV_OBJECT *hDevObject;	/* Handle to WCD device object. */
-	u32 dwDspBaseAddr;	/* Arm's API to DSP virtual base addr */
+	u32 dwDspBaseAddr; 		/* Arm's API to DSP virt base addr */
 	/*
 	 * DSP External memory prog address as seen virtually by the OS on
 	 * the host side.
 	 */
-	u32 dwDspExtBaseAddr;	/* See the comment above        */
-	u32 dwAPIRegBase;	/* API memory mapped registers  */
-	void __iomem *dwDSPMmuBase;	/* DSP MMU Mapped registers     */
-	u32 dwMailBoxBase;	/* Mail box mapped registers    */
-	u32 dwAPIClkBase;	/* CLK Registers                */
-	u32 dwDSPClkM2Base;	/* DSP Clock Module m2          */
-	u32 dwPublicRhea;	/* Pub Rhea                     */
-	u32 dwIntAddr;	/* MB INTR reg                  */
-	u32 dwTCEndianism;	/* TC Endianism register        */
-	u32 dwTestBase;	/* DSP MMU Mapped registers     */
-	u32 dwSelfLoop;	/* Pointer to the selfloop      */
-	u32 dwDSPStartAdd;	/* API Boot vector              */
-	u32 dwInternalSize;	/* Internal memory size         */
+	u32 dwDspExtBaseAddr;		/* See the comment above */
+	u32 dwAPIRegBase;		/* API mem map'd registers */
+	void __iomem *dwDSPMmuBase;	/* DSP MMU Mapped registers */
+	u32 dwMailBoxBase;		/* Mail box mapped registers */
+	u32 dwAPIClkBase;		/* CLK Registers */
+	u32 dwDSPClkM2Base;		/* DSP Clock Module m2 */
+	u32 dwPublicRhea;		/* Pub Rhea */
+	u32 dwIntAddr;			/* MB INTR reg */
+	u32 dwTCEndianism;		/* TC Endianism register */
+	u32 dwTestBase;			/* DSP MMU Mapped registers */
+	u32 dwSelfLoop;			/* Pointer to the selfloop */
+	u32 dwDSPStartAdd;		/* API Boot vector */
+	u32 dwInternalSize;		/* Internal memory size */
 
 	/*
 	 * Processor specific info is set when prog loaded and read from DCD.
@@ -358,14 +334,14 @@ struct WMD_DEV_CONTEXT {
 	 */
 	/* DMMU TLB entries */
 	struct WMDIOCTL_EXTPROC aTLBEntry[WMDIOCTL_NUMOFMMUTLB];
-	u32 dwBrdState;	/* Last known board state.      */
-	u32 ulIntMask;	/* int mask                     */
-	u16 ioBase;	/* Board I/O base               */
-	u32 numTLBEntries;	/* DSP MMU TLB entry counter    */
-	u32 fixedTLBEntries;	/* Fixed DSPMMU TLB entry count */
+	u32 dwBrdState;			/* Last known board state. */
+	u32 ulIntMask;			/* int mask */
+	u16 ioBase;			/* Board I/O base */
+	u32 numTLBEntries;		/* DSP MMU TLB entry counter */
+	u32 fixedTLBEntries;		/* Fixed DSPMMU TLB entry count */
 
 	/* TC Settings */
-	bool tcWordSwapOn;	/* Traffic Controller Word Swap */
+	bool tcWordSwapOn;		/* Traffic Controller Word Swap */
 	struct PgTableAttrs *pPtAttrs;
 	u32 uDspPerClks;
 } ;
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/_tiomap_mmu.h kernel-power-2.6.28/drivers/dsp/bridge/wmd/_tiomap_mmu.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/_tiomap_mmu.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/_tiomap_mmu.h	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definitions and types for the DSP MMU modules.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,20 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _tiomap_mmu.h ========
- *  Description:
- *      Definitions and types for the DSP MMU modules
- *
- *! Revision History
- *! ================
- *! 19-Apr-2004 sb:  Renamed HW types. Removed dspMmuTlbEntry
- *! 05-Jan-2004 vp:  Moved the file to a platform specific folder from common.
- *! 21-Mar-2003 sb:  Added macro definition TIHEL_LARGEPAGESIZE
- *! 08-Oct-2002 rr:  Created.
- */
-
 #ifndef _TIOMAP_MMU_
 #define _TIOMAP_MMU_
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/_tiomap_pwr.h kernel-power-2.6.28/drivers/dsp/bridge/wmd/_tiomap_pwr.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/_tiomap_pwr.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/_tiomap_pwr.h	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definitions and types for the DSP wake/sleep routines.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,17 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _tiomap_pwr.h ========
- *  Description:
- *      Definitions and types for the DSP wake/sleep routines.
- *
- *! Revision History
- *! ================
- *! 08-Oct-2002 rr:  Created.
- */
-
 #ifndef _TIOMAP_PWR_
 #define _TIOMAP_PWR_
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/_tiomap_util.h kernel-power-2.6.28/drivers/dsp/bridge/wmd/_tiomap_util.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/_tiomap_util.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/_tiomap_util.h	2011-05-02 22:36:50.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definitions and types for the utility routines.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,23 +16,18 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _tiomap_util.h ========
- *  Description:
- *      Definitions and types for the utility routines.
- *
- *! Revision History
- *! ================
- *! 08-Oct-2002 rr:  Created.
- */
-
 #ifndef _TIOMAP_UTIL_
 #define _TIOMAP_UTIL_
 
 /* Time out Values in uSeconds*/
 #define TIHELEN_ACKTIMEOUT  10000
 
+/*
+ * Time out for power state transition (in msecs), due to system
+ * latencies and HZ resolution this timer can vary.
+ */
+#define PWRSTST_TIMEOUT		200
+
 /*  Time delay for HOM->SAM transition. */
 #define  WAIT_SAM   1000000	/* in usec (1000 millisec) */
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/chnl_sm.c kernel-power-2.6.28/drivers/dsp/bridge/wmd/chnl_sm.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/chnl_sm.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/chnl_sm.c	2011-05-02 22:36:51.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implements upper edge functions for WMD channel module.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,26 +16,7 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
 /*
- *  ======== chnl_sm.c ========
- *  Description:
- *      Implements upper edge functions for WMD channel module.
- *
- *  Public Functions:
- *      WMD_CHNL_AddIOReq
- *      WMD_CHNL_CancelIO
- *      WMD_CHNL_Close
- *      WMD_CHNL_Create
- *      WMD_CHNL_Destroy
- *      WMD_CHNL_FlushIO
- *      WMD_CHNL_GetInfo
- *      WMD_CHNL_GetIOC
- *      WMD_CHNL_GetMgrInfo
- *      WMD_CHNL_Idle
- *      WMD_CHNL_Open
- *
- *  Notes:
  *      The lower edge functions must be implemented by the WMD writer, and
  *      are declared in chnl_sm.h.
  *
@@ -57,60 +40,6 @@
  *          LST_Empty(pChnl->pIOCompletions) ==> pChnl->hSyncEvent is reset
  *      and
  *          !LST_Empty(pChnl->pIOCompletions) ==> pChnl->hSyncEvent is set.
- *
- *! Revision History:
- *! ================
- *! 10-Feb-2004 sb: Consolidated the MAILBOX_IRQ macro at the top of the file.
- *! 05-Jan-2004 vp: Updated for 2.6 kernel on 24xx platform.
- *! 23-Apr-2003 sb: Fixed mailbox deadlock
- *! 24-Feb-2003 vp: Code Review Updates.
- *! 18-Oct-2002 vp: Ported to Linux platform
- *! 29-Aug-2002 rr  Changed the SYNC error code return to DSP error code return
- *            in WMD_CHNL_GetIOC.
- *! 22-Jan-2002 ag  Zero-copy support added.
- *!                 CMM_CallocBuf() used for SM allocations.
- *! 04-Feb-2001 ag  DSP-DMA support added.
- *! 22-Nov-2000 kc: Updated usage of PERF_RegisterStat.
- *! 06-Nov-2000 jeh Move ISR_Install, DPC_Create from CHNL_Create to IO_Create.
- *! 13-Oct-2000 jeh Added dwArg parameter to WMD_CHNL_AddIOReq(), added
- *!                 WMD_CHNL_Idle and WMD_CHNL_RegisterNotify for DSPStream.
- *!                 Remove #ifdef DEBUG from around channel cIOCs field.
- *! 21-Sep-2000 rr: PreOMAP chnl class library acts like a IO class library.
- *! 25-Sep-2000 ag: MEM_[Unmap]LinearAddress added for #ifdef CHNL_PREOMAP.
- *! 07-Sep-2000 rr: Added new channel class for PreOMAP.
- *! 11-Jul-2000 jeh Allow NULL user event in WMD_CHNL_Open().
- *! 06-Jul-2000 rr: Changed prefix PROC to PRCS for process module calls.
- *! 20-Jan-2000 ag: Incorporated code review comments.
- *! 05-Jan-2000 ag: Text format cleanup.
- *! 07-Dec-1999 ag: Now setting ChnlMgr fSharedIRQ flag before ISR_Install().
- *! 01-Dec-1999 ag: WMD_CHNL_Open() now accepts named sync event.
- *! 14-Nov-1999 ag: DPC_Schedule() uncommented.
- *! 28-Oct-1999 ag: CHNL Attrs userEvent not supported.
- *!                 SM addrs taken from COFF(IO) or host resource(SM).
- *! 25-May-1999 jg: CHNL_IOCLASS boards now get their shared memory buffer
- *!                 address and length from symbols defined in the currently
- *!                 loaded COFF file. See _chn_sm.h.
- *! 18-Jun-1997 gp: Moved waiting back to ring 0 to improve performance.
- *! 22-Jan-1998 gp: Update User's pIOC struct in GetIOC at lower IRQL (NT).
- *! 16-Jan-1998 gp: Commented out PERF stuff, since it is not all there in NT.
- *! 13-Jan-1998 gp: Protect IOCTLs from IO_DPC by raising IRQL to DIRQL (NT).
- *! 22-Oct-1997 gp: Call SYNC_OpenEvent in CHNL_Open, for NT support.
- *! 18-Jun-1997 gp: Moved waiting back to ring 0 to improve performance.
- *! 16-Jun-1997 gp: Added call into lower edge CHNL function to allow override
- *!                 of the SHM window length reported by Windows CM.
- *! 05-Jun-1997 gp: Removed unnecessary critical sections.
- *! 18-Mar-1997 gp: Ensured CHNL_FlushIO on input leaves channel in READY state.
- *! 06-Jan-1997 gp: ifdefed to support the IO variant of SHM channel class lib.
- *! 21-Jan-1997 gp: CHNL_Close: set pChnl = NULL for DBC_Ensure().
- *! 14-Jan-1997 gp: Updated based on code review feedback.
- *! 03-Jan-1997 gp: Added CHNL_E_WAITTIMEOUT error return code to CHNL_FlushIO()
- *! 23-Oct-1996 gp: Tag channel with ring 0 process handle.
- *! 13-Sep-1996 gp: Added performance statistics for channel.
- *! 09-Sep-1996 gp: Added WMD_CHNL_GetMgrInfo().
- *! 04-Sep-1996 gp: Removed shared memory control struct offset: made zero.
- *! 01-Aug-1996 gp: Implemented basic channel manager and channel create/delete.
- *! 17-Jul-1996 gp: Started pseudo coding.
- *! 11-Jul-1996 gp: Stubbed out.
  */
 
 /*  ----------------------------------- OS */
@@ -128,7 +57,6 @@
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/mem.h>
 #include <dspbridge/cfg.h>
-#include <dspbridge/csl.h>
 #include <dspbridge/sync.h>
 
 /*  ----------------------------------- Mini-Driver */
@@ -183,6 +111,31 @@ DSP_STATUS WMD_CHNL_AddIOReq(struct CHNL
 
 	fIsEOS = (cBytes == 0) ? true : false;
 
+	/* Validate args:  */
+	if (pHostBuf == NULL) {
+		status = DSP_EPOINTER;
+	} else if (!MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
+		status = DSP_EHANDLE;
+	} else if (fIsEOS && CHNL_IsInput(pChnl->uMode)) {
+		status = CHNL_E_NOEOS;
+	} else {
+		/* Check the channel state: only queue chirp if channel state
+		 * allows */
+		dwState = pChnl->dwState;
+		if (dwState != CHNL_STATEREADY) {
+			if (dwState & CHNL_STATECANCEL)
+				status = CHNL_E_CANCELLED;
+			else if ((dwState & CHNL_STATEEOS)
+				   && CHNL_IsOutput(pChnl->uMode))
+				status = CHNL_E_EOS;
+			else
+				/* No other possible states left: */
+				DBC_Assert(0);
+		}
+	}
+	if (DSP_FAILED(status))
+		goto func_end;
+
 	if (pChnl->uChnlType == CHNL_PCPY && pChnl->uId > 1 && pHostBuf) {
 		if (!(pHostBuf < (void *)USERMODE_ADDR)) {
 			pHostSysBuf = pHostBuf;
@@ -194,7 +147,7 @@ DSP_STATUS WMD_CHNL_AddIOReq(struct CHNL
 			status = DSP_EMEMORY;
 			DBG_Trace(DBG_LEVEL7,
 				 "No memory to allocate kernel buffer\n");
-			goto func_cont;
+			goto func_end;
 		}
 		if (CHNL_IsOutput(pChnl->uMode)) {
 			status = copy_from_user(pHostSysBuf, pHostBuf,
@@ -207,33 +160,11 @@ DSP_STATUS WMD_CHNL_AddIOReq(struct CHNL
 				MEM_Free(pHostSysBuf);
 				pHostSysBuf = NULL;
 				status = DSP_EPOINTER;
+				goto func_end;
 			}
 		}
 	}
 func_cont:
-	/* Validate args:  */
-	if (pHostBuf == NULL) {
-		status = DSP_EPOINTER;
-	} else if (!MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
-		status = DSP_EHANDLE;
-	} else if (fIsEOS && CHNL_IsInput(pChnl->uMode)) {
-		status = CHNL_E_NOEOS;
-	} else {
-		/* Check the channel state: only queue chirp if channel state
-		 * allows */
-		dwState = pChnl->dwState;
-		if (dwState != CHNL_STATEREADY) {
-			if (dwState & CHNL_STATECANCEL) {
-				status = CHNL_E_CANCELLED;
-			} else if ((dwState & CHNL_STATEEOS)
-				   && CHNL_IsOutput(pChnl->uMode)) {
-				status = CHNL_E_EOS;
-			} else {
-				/* No other possible states left: */
-				DBC_Assert(0);
-			}
-		}
-	}
 	/* Mailbox IRQ is disabled to avoid race condition with DMA/ZCPY
 	 * channels. DPCCS is held to avoid race conditions with PCPY channels.
 	 * If DPC is scheduled in process context (IO_Schedule) and any
@@ -263,47 +194,47 @@ func_cont:
 		if (pChnl->uChnlType == CHNL_PCPY && pChnl->uId > 1)
 			pChirp->pHostSysBuf = pHostSysBuf;
 
-		if (DSP_SUCCEEDED(status)) {
-			/* Note: for dma chans dwDspAddr contains dsp address
-			 * of SM buffer.*/
-			DBC_Assert(pChnlMgr->uWordSize != 0);
-			/* DSP address */
-			pChirp->uDspAddr = dwDspAddr / pChnlMgr->uWordSize;
-			pChirp->cBytes = cBytes;
-			pChirp->cBufSize = cBufSize;
-			/* Only valid for output channel */
-			pChirp->dwArg = dwArg;
-			pChirp->status = (fIsEOS ? CHNL_IOCSTATEOS :
-					 CHNL_IOCSTATCOMPLETE);
-			LST_PutTail(pChnl->pIORequests, (struct LST_ELEM *)
-				   pChirp);
-			pChnl->cIOReqs++;
-			DBC_Assert(pChnl->cIOReqs <= pChnl->cChirps);
-			/* If end of stream, update the channel state to prevent
-			 * more IOR's: */
-			if (fIsEOS)
-				pChnl->dwState |= CHNL_STATEEOS;
+		/*
+		 * Note: for dma chans dwDspAddr contains dsp address
+		 * of SM buffer.
+		 */
+		DBC_Assert(pChnlMgr->uWordSize != 0);
+		/* DSP address */
+		pChirp->uDspAddr = dwDspAddr / pChnlMgr->uWordSize;
+		pChirp->cBytes = cBytes;
+		pChirp->cBufSize = cBufSize;
+		/* Only valid for output channel */
+		pChirp->dwArg = dwArg;
+		pChirp->status = (fIsEOS ? CHNL_IOCSTATEOS :
+						CHNL_IOCSTATCOMPLETE);
+		LST_PutTail(pChnl->pIORequests, (struct list_head *)pChirp);
+		pChnl->cIOReqs++;
+		DBC_Assert(pChnl->cIOReqs <= pChnl->cChirps);
+		/* If end of stream, update the channel state to prevent
+		 * more IOR's: */
+		if (fIsEOS)
+			pChnl->dwState |= CHNL_STATEEOS;
+
+		/* Legacy DSM Processor-Copy */
+		DBC_Assert(pChnl->uChnlType == CHNL_PCPY);
+		/* Request IO from the DSP */
+		IO_RequestChnl(pChnlMgr->hIOMgr, pChnl,
+			(CHNL_IsInput(pChnl->uMode) ? IO_INPUT : IO_OUTPUT),
+								&wMbVal);
+		fSchedDPC = true;
+
 
-			{
-				/* Legacy DSM Processor-Copy */
-				DBC_Assert(pChnl->uChnlType == CHNL_PCPY);
-				/* Request IO from the DSP */
-				IO_RequestChnl(pChnlMgr->hIOMgr, pChnl,
-					(CHNL_IsInput(pChnl->uMode) ?
-					IO_INPUT : IO_OUTPUT), &wMbVal);
-				fSchedDPC = true;
-			}
-		}
 	}
 	enable_irq(MAILBOX_IRQ);
 	SYNC_LeaveCS(pChnlMgr->hCSObj);
 	if (wMbVal != 0)
 		IO_IntrDSP2(pChnlMgr->hIOMgr, wMbVal);
 
-	if (fSchedDPC == true) {
-		/* Schedule a DPC, to do the actual data transfer: */
+	/* Schedule a DPC, to do the actual data transfer: */
+	if (fSchedDPC)
 		IO_Schedule(pChnlMgr->hIOMgr);
-	}
+
+func_end:
 	DBG_Trace(DBG_ENTER, "< WMD_CHNL_AddIOReq pChnl %p\n", pChnl);
 	return status;
 }
@@ -322,12 +253,12 @@ DSP_STATUS WMD_CHNL_CancelIO(struct CHNL
 	DSP_STATUS status = DSP_SOK;
 	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
 	u32 iChnl = -1;
-	CHNL_MODE uMode;
+	short int uMode;
 	struct CHNL_IRP *pChirp;
 	struct CHNL_MGR *pChnlMgr = NULL;
 
 	/* Check args: */
-	if (MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
+	if (MEM_IsValidHandle(pChnl, CHNL_SIGNATURE) && pChnl->pChnlMgr) {
 		iChnl = pChnl->uId;
 		uMode = pChnl->uMode;
 		pChnlMgr = pChnl->pChnlMgr;
@@ -361,7 +292,7 @@ DSP_STATUS WMD_CHNL_CancelIO(struct CHNL
 			pChirp->cBytes = 0;
 			pChirp->status |= CHNL_IOCSTATCANCEL;
 			LST_PutTail(pChnl->pIOCompletions,
-				   (struct LST_ELEM *)pChirp);
+				   (struct list_head *)pChirp);
 			pChnl->cIOCs++;
 			pChnl->cIOReqs--;
 			DBC_Assert(pChnl->cIOReqs >= 0);
@@ -454,58 +385,48 @@ DSP_STATUS WMD_CHNL_Create(OUT struct CH
 	DSP_STATUS status = DSP_SOK;
 	struct CHNL_MGR *pChnlMgr = NULL;
 	s32 cChannels;
-#ifdef DEBUG
-	struct CHNL_MGR *hChnlMgr;
-#endif
+
 	/* Check DBC requirements:  */
 	DBC_Require(phChnlMgr != NULL);
 	DBC_Require(pMgrAttrs != NULL);
 	DBC_Require(pMgrAttrs->cChannels > 0);
 	DBC_Require(pMgrAttrs->cChannels <= CHNL_MAXCHANNELS);
 	DBC_Require(pMgrAttrs->uWordSize != 0);
-#ifdef DEBUG
-	/* This for the purposes of DBC_Require: */
-	status = DEV_GetChnlMgr(hDevObject, &hChnlMgr);
-	DBC_Require(status != DSP_EHANDLE);
-	DBC_Require(hChnlMgr == NULL);
-#endif
-	if (DSP_SUCCEEDED(status)) {
-		/* Allocate channel manager object: */
-		MEM_AllocObject(pChnlMgr, struct CHNL_MGR, CHNL_MGRSIGNATURE);
-		if (pChnlMgr) {
-			/* The cChannels attr must equal the # of supported
-			 * chnls for each transport(# chnls for PCPY = DDMA =
-			 * ZCPY): i.e. pMgrAttrs->cChannels = CHNL_MAXCHANNELS =
-			 * DDMA_MAXDDMACHNLS = DDMA_MAXZCPYCHNLS.  */
-			DBC_Assert(pMgrAttrs->cChannels == CHNL_MAXCHANNELS);
-			cChannels = (CHNL_MAXCHANNELS + (CHNL_MAXCHANNELS *
-				    CHNL_PCPY));
-			/* Create array of channels: */
-			pChnlMgr->apChannel = MEM_Calloc(
-						sizeof(struct CHNL_OBJECT *) *
-						cChannels, MEM_NONPAGED);
-			if (pChnlMgr->apChannel) {
-				/* Initialize CHNL_MGR object: */
-				/* Shared memory driver. */
-				pChnlMgr->dwType = CHNL_TYPESM;
-				pChnlMgr->uWordSize = pMgrAttrs->uWordSize;
-				/* total # chnls supported */
-				pChnlMgr->cChannels = cChannels;
-				pChnlMgr->cOpenChannels = 0;
-				pChnlMgr->dwOutputMask = 0;
-				pChnlMgr->dwLastOutput = 0;
-				pChnlMgr->hDevObject = hDevObject;
-				if (DSP_SUCCEEDED(status)) {
-					status = SYNC_InitializeDPCCS
-						(&pChnlMgr->hCSObj);
-				}
-			} else {
-				status = DSP_EMEMORY;
-			}
+
+	/* Allocate channel manager object: */
+	MEM_AllocObject(pChnlMgr, struct CHNL_MGR, CHNL_MGRSIGNATURE);
+	if (pChnlMgr) {
+		/* The cChannels attr must equal the # of supported
+		 * chnls for each transport(# chnls for PCPY = DDMA =
+		 * ZCPY): i.e. pMgrAttrs->cChannels = CHNL_MAXCHANNELS =
+		 * DDMA_MAXDDMACHNLS = DDMA_MAXZCPYCHNLS.  */
+		DBC_Assert(pMgrAttrs->cChannels == CHNL_MAXCHANNELS);
+		cChannels = CHNL_MAXCHANNELS + CHNL_MAXCHANNELS * CHNL_PCPY;
+		/* Create array of channels: */
+		pChnlMgr->apChannel = MEM_Calloc(
+				sizeof(struct CHNL_OBJECT *) *
+				cChannels, MEM_NONPAGED);
+		if (pChnlMgr->apChannel) {
+			/* Initialize CHNL_MGR object: */
+			/* Shared memory driver. */
+			pChnlMgr->dwType = CHNL_TYPESM;
+			pChnlMgr->uWordSize = pMgrAttrs->uWordSize;
+			/* total # chnls supported */
+			pChnlMgr->cChannels = cChannels;
+			pChnlMgr->cOpenChannels = 0;
+			pChnlMgr->dwOutputMask = 0;
+			pChnlMgr->dwLastOutput = 0;
+			pChnlMgr->hDevObject = hDevObject;
+			if (DSP_SUCCEEDED(status))
+				status = SYNC_InitializeDPCCS(
+							&pChnlMgr->hCSObj);
 		} else {
 			status = DSP_EMEMORY;
 		}
+	} else {
+		status = DSP_EMEMORY;
 	}
+
 	if (DSP_FAILED(status)) {
 		WMD_CHNL_Destroy(pChnlMgr);
 		*phChnlMgr = NULL;
@@ -530,10 +451,10 @@ DSP_STATUS WMD_CHNL_Destroy(struct CHNL_
 	if (MEM_IsValidHandle(hChnlMgr, CHNL_MGRSIGNATURE)) {
 		/* Close all open channels: */
 		for (iChnl = 0; iChnl < pChnlMgr->cChannels; iChnl++) {
-			if (DSP_SUCCEEDED
-			    (WMD_CHNL_Close(pChnlMgr->apChannel[iChnl]))) {
-				DBC_Assert(pChnlMgr->apChannel[iChnl] == NULL);
-			}
+			status = WMD_CHNL_Close(pChnlMgr->apChannel[iChnl]);
+			if (DSP_FAILED(status))
+				DBG_Trace(DBG_LEVEL7, "Error in CHNL_Close "
+						"status 0x%x\n", status);
 		}
 		/* release critical section */
 		if (pChnlMgr->hCSObj)
@@ -562,7 +483,7 @@ DSP_STATUS WMD_CHNL_FlushIO(struct CHNL_
 {
 	DSP_STATUS status = DSP_SOK;
 	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
-	CHNL_MODE uMode = -1;
+	short int uMode = -1;
 	struct CHNL_MGR *pChnlMgr;
 	struct CHNL_IOC chnlIOC;
 	/* Check args:  */
@@ -715,8 +636,8 @@ DSP_STATUS WMD_CHNL_GetIOC(struct CHNL_O
 			ioc.dwArg = pChirp->dwArg;
 			ioc.status |= pChirp->status;
 			/* Place the used chirp on the free list: */
-			LST_PutTail(pChnl->pFreeList, (struct LST_ELEM *)
-				   pChirp);
+			LST_PutTail(pChnl->pFreeList,
+					(struct list_head *)pChirp);
 		} else {
 			ioc.pBuf = NULL;
 			ioc.cBytes = 0;
@@ -763,7 +684,6 @@ DSP_STATUS WMD_CHNL_GetIOC(struct CHNL_O
 
 		/*pHostUserBuf */
 		status = copy_to_user(ioc.pBuf, pHostSysBuf, ioc.cBytes);
-#ifndef RES_CLEANUP_DISABLE
 		if (status) {
 			if (current->flags & PF_EXITING) {
 				DBG_Trace(DBG_LEVEL7,
@@ -778,7 +698,6 @@ DSP_STATUS WMD_CHNL_GetIOC(struct CHNL_O
 					 current->flags);
 			}
 		}
-#endif
 		if (status) {
 			DBG_Trace(DBG_LEVEL7,
 				 "Error copying kernel buffer to user, %d"
@@ -837,7 +756,7 @@ DSP_STATUS WMD_CHNL_GetMgrInfo(struct CH
 DSP_STATUS WMD_CHNL_Idle(struct CHNL_OBJECT *hChnl, u32 dwTimeOut,
 			 bool fFlush)
 {
-	CHNL_MODE uMode;
+	short int uMode;
 	struct CHNL_MGR *pChnlMgr;
 	DSP_STATUS status = DSP_SOK;
 
@@ -865,7 +784,7 @@ DSP_STATUS WMD_CHNL_Idle(struct CHNL_OBJ
  *      Open a new half-duplex channel to the DSP board.
  */
 DSP_STATUS WMD_CHNL_Open(OUT struct CHNL_OBJECT **phChnl,
-			 struct CHNL_MGR *hChnlMgr, CHNL_MODE uMode,
+			 struct CHNL_MGR *hChnlMgr, short int uMode,
 			 u32 uChnlId, CONST IN struct CHNL_ATTRS *pAttrs)
 {
 	DSP_STATUS status = DSP_SOK;
@@ -876,6 +795,7 @@ DSP_STATUS WMD_CHNL_Open(OUT struct CHNL
 	/* Ensure DBC requirements:  */
 	DBC_Require(phChnl != NULL);
 	DBC_Require(pAttrs != NULL);
+	DBC_Require(hChnlMgr != NULL);
 	*phChnl = NULL;
 	/* Validate Args:  */
 	if (pAttrs->uIOReqs == 0) {
@@ -885,12 +805,11 @@ DSP_STATUS WMD_CHNL_Open(OUT struct CHNL
 			status = DSP_EHANDLE;
 		} else {
 			if (uChnlId != CHNL_PICKFREE) {
-				if (uChnlId >= pChnlMgr->cChannels) {
+				if (uChnlId >= pChnlMgr->cChannels)
 					status = CHNL_E_BADCHANID;
-				} else if (pChnlMgr->apChannel[uChnlId] !=
-					  NULL) {
+				else if (pChnlMgr->apChannel[uChnlId] !=
+					  NULL)
 					status = CHNL_E_CHANBUSY;
-				}
 			} else {
 				/* Check for free channel */
 				status = SearchFreeChannel(pChnlMgr, &uChnlId);
@@ -905,7 +824,7 @@ DSP_STATUS WMD_CHNL_Open(OUT struct CHNL
 	MEM_AllocObject(pChnl, struct CHNL_OBJECT, 0x0000);
 	if (!pChnl) {
 		status = DSP_EMEMORY;
-		goto func_cont;
+		goto func_end;
 	}
 	/* Protect queues from IO_DPC: */
 	pChnl->dwState = CHNL_STATECANCEL;
@@ -917,13 +836,9 @@ DSP_STATUS WMD_CHNL_Open(OUT struct CHNL
 	pChnl->cIOCs = 0;
 	pChnl->cIOReqs = 0;
 	status = SYNC_OpenEvent(&hSyncEvent, pSyncAttrs);
-	if (DSP_SUCCEEDED(status)) {
+	if (DSP_SUCCEEDED(status))
 		status = NTFY_Create(&pChnl->hNtfy);
-		if (DSP_FAILED(status)) {
-			/* The only failure that could have occurred */
-			status = DSP_EMEMORY;
-		}
-	}
+
 	if (DSP_SUCCEEDED(status)) {
 		if (pChnl->pIOCompletions && pChnl->pIORequests &&
 		   pChnl->pFreeList) {
@@ -933,7 +848,7 @@ DSP_STATUS WMD_CHNL_Open(OUT struct CHNL
 			pChnl->uMode = uMode;
 			pChnl->hUserEvent = hSyncEvent;	/* for Linux */
 			pChnl->hSyncEvent = hSyncEvent;
-			/* Return TGID instead of process handle */
+			/* Get the process handle */
 			pChnl->hProcess = current->tgid;
 			pChnl->pCBArg = 0;
 			pChnl->cBytesMoved = 0;
@@ -942,9 +857,8 @@ DSP_STATUS WMD_CHNL_Open(OUT struct CHNL
 		} else {
 			status = DSP_EMEMORY;
 		}
-	} else {
-		status = DSP_EINVALIDARG;
 	}
+
 	if (DSP_FAILED(status)) {
 		/* Free memory */
 		if (pChnl->pIOCompletions) {
@@ -969,9 +883,7 @@ DSP_STATUS WMD_CHNL_Open(OUT struct CHNL
 			pChnl->hNtfy = NULL;
 		}
 		MEM_FreeObject(pChnl);
-	}
-func_cont:
-	if (DSP_SUCCEEDED(status)) {
+	} else {
 		/* Insert channel object in channel manager: */
 		pChnlMgr->apChannel[pChnl->uId] = pChnl;
 		SYNC_EnterCS(pChnlMgr->hCSObj);
@@ -1024,13 +936,14 @@ static struct LST_LIST *CreateChirpList(
 	struct CHNL_IRP *pChirp;
 	u32 i;
 
-	pChirpList = LST_Create();
+	pChirpList = MEM_Calloc(sizeof(struct LST_LIST), MEM_NONPAGED);
 
 	if (pChirpList) {
+		INIT_LIST_HEAD(&pChirpList->head);
 		/* Make N chirps and place on queue. */
 		for (i = 0; (i < uChirps) && ((pChirp = MakeNewChirp()) !=
 		    NULL); i++) {
-			LST_PutTail(pChirpList, (struct LST_ELEM *)pChirp);
+			LST_PutTail(pChirpList, (struct list_head *)pChirp);
 		}
 
 		/* If we couldn't allocate all chirps, free those allocated: */
@@ -1055,7 +968,7 @@ static void FreeChirpList(struct LST_LIS
 	while (!LST_IsEmpty(pChirpList))
 		MEM_Free(LST_GetHead(pChirpList));
 
-	LST_Delete(pChirpList);
+	MEM_Free(pChirpList);
 }
 
 /*
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/io_sm.c kernel-power-2.6.28/drivers/dsp/bridge/wmd/io_sm.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/io_sm.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/io_sm.c	2011-05-02 22:36:51.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * IO dispatcher for a shared memory channel driver.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -15,37 +17,14 @@
  */
 
 /*
- *  ======== io_sm.c ========
- *  Description:
- *      IO dispatcher for a shared memory channel driver.
- *
- *  Public Functions:
- *      WMD_IO_Create
- *      WMD_IO_Destroy
- *      WMD_IO_OnLoaded
- *      IO_AndSetValue
- *      IO_BufSize
- *      IO_CancelChnl
- *      IO_DPC
- *      IO_ISR
- *      IO_IVAISR
- *      IO_OrSetValue
- *      IO_ReadValue
- *      IO_ReadValueLong
- *      IO_RequestChnl
- *      IO_Schedule
- *      IO_WriteValue
- *      IO_WriteValueLong
- *
- *  Channel Invariant:
- *      There is an important invariant condition which must be maintained per
- *      channel outside of WMD_CHNL_GetIOC() and IO_Dispatch(), violation of
- *      which may cause timeouts and/or failure of the WIN32_WaitSingleObject
- *      function (SYNC_WaitOnEvent).
- *
+ * Channel Invariant:
+ * There is an important invariant condition which must be maintained per
+ * channel outside of WMD_CHNL_GetIOC() and IO_Dispatch(), violation of
+ * which may cause timeouts and/or failure of the SYNC_WaitOnEvent
+ * function.
  */
 
-/*  ----------------------------------- Host OS */
+/* Host OS */
 #include <dspbridge/host_os.h>
 #include <linux/workqueue.h>
 
@@ -54,51 +33,48 @@
 #include <dspbridge/dbdefs.h>
 #include <dspbridge/errbase.h>
 
-/*  ----------------------------------- Trace & Debug */
+/* Trace & Debug */
 #include <dspbridge/dbc.h>
 #include <dspbridge/dbg.h>
 
-/*  ----------------------------------- OS Adaptation Layer */
+/* Services Layer */
 #include <dspbridge/cfg.h>
-#include <dspbridge/dpc.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/ntfy.h>
 #include <dspbridge/sync.h>
 #include <dspbridge/reg.h>
 
-/* ------------------------------------ Hardware Abstraction Layer */
+/* Hardware Abstraction Layer */
 #include <hw_defs.h>
 #include <hw_mmu.h>
 
-/*  ----------------------------------- Mini Driver */
+/* Mini Driver */
 #include <dspbridge/wmddeh.h>
 #include <dspbridge/wmdio.h>
 #include <dspbridge/wmdioctl.h>
 #include <_tiomap.h>
 #include <tiomap_io.h>
 #include <_tiomap_pwr.h>
-#include <tiomap_io.h>
 
-/*  ----------------------------------- Platform Manager */
+/* Platform Manager */
 #include <dspbridge/cod.h>
 #include <dspbridge/dev.h>
 #include <dspbridge/chnl_sm.h>
-#include <dspbridge/dbreg.h>
 
-/*  ----------------------------------- Others */
+/* Others */
 #include <dspbridge/rms_sh.h>
 #include <dspbridge/mgr.h>
 #include <dspbridge/drv.h>
 #include "_cmm.h"
 
-/*  ----------------------------------- This */
+/* This */
 #include <dspbridge/io_sm.h>
 #include "_msg_sm.h"
 #include <dspbridge/gt.h>
 
-/*  ----------------------------------- Defines, Data Structures, Typedefs */
+/* Defines, Data Structures, Typedefs */
 #define OUTPUTNOTREADY  0xffff
-#define NOTENABLED      0xffff	/* channel(s) not enabled */
+#define NOTENABLED      0xffff	/* Channel(s) not enabled */
 
 #define EXTEND      "_EXT_END"
 
@@ -107,34 +83,33 @@
 
 #define MAX_PM_REQS 32
 
-/* IO Manager: only one created per board: */
+/* IO Manager: only one created per board */
 struct IO_MGR {
-	/* These four fields must be the first fields in a IO_MGR_ struct: */
-	u32 dwSignature; 	/* Used for object validation   */
-	struct WMD_DEV_CONTEXT *hWmdContext; 	/* WMD device context  */
+	/* These four fields must be the first fields in a IO_MGR_ struct */
+	u32 dwSignature; 	/* Used for object validation */
+	struct WMD_DEV_CONTEXT *hWmdContext; 	/* WMD device context */
 	struct WMD_DRV_INTERFACE *pIntfFxns; 	/* Function interface to WMD */
 	struct DEV_OBJECT *hDevObject; 	/* Device this board represents */
 
-	/* These fields initialized in WMD_IO_Create():    */
+	/* These fields initialized in WMD_IO_Create() */
 	struct CHNL_MGR *hChnlMgr;
-	struct SHM *pSharedMem; 	/* Shared Memory control	*/
-	u8 *pInput; 		/* Address of input channel     */
-	u8 *pOutput; 		/* Address of output channel    */
+	struct SHM *pSharedMem; 	/* Shared Memory control */
+	u8 *pInput; 		/* Address of input channel */
+	u8 *pOutput; 		/* Address of output channel */
 	struct MSG_MGR *hMsgMgr; 	/* Message manager */
 	struct MSG *pMsgInputCtrl; 	/* Msg control for from DSP messages */
 	struct MSG *pMsgOutputCtrl; 	/* Msg control for to DSP messages */
-	u8 *pMsgInput; 	/* Address of input messages    */
-	u8 *pMsgOutput; 	/* Address of output messages   */
+	u8 *pMsgInput; 	/* Address of input messages */
+	u8 *pMsgOutput; 	/* Address of output messages */
 	u32 uSMBufSize; 	/* Size of a shared memory I/O channel */
-	bool fSharedIRQ; 	/* Is this IRQ shared?	  */
-	struct DPC_OBJECT *hDPC; 	/* DPC object handle	    */
+	bool fSharedIRQ; 	/* Is this IRQ shared? */
 	struct SYNC_CSOBJECT *hCSObj; 	/* Critical section object handle */
-	u32 uWordSize; 	/* Size in bytes of DSP word    */
-	u16 wIntrVal; 		/* interrupt value	      */
-	/* private extnd proc info; mmu setup */
+	u32 uWordSize; 	/* Size in bytes of DSP word */
+	u16 wIntrVal; 		/* Interrupt value */
+	/* Private extnd proc info; mmu setup */
 	struct MGR_PROCESSOREXTINFO extProcInfo;
-	struct CMM_OBJECT *hCmmMgr; 	/* Shared Mem Mngr	      */
-       struct work_struct io_workq;     /*workqueue */
+	struct CMM_OBJECT *hCmmMgr; 	/* Shared Mem Mngr */
+	struct work_struct io_workq;     /* workqueue */
 	u32 dQuePowerMbxVal[MAX_PM_REQS];
 	u32 iQuePowerHead;
 	u32 iQuePowerTail;
@@ -147,9 +122,15 @@ struct IO_MGR {
 	u32 ulGppVa;
 	u32 ulDspVa;
 #endif
+	/* IO Dpc */
+	u32 dpc_req;				/* Number of requested DPC's. */
+	u32 dpc_sched;				/* Number of executed DPC's. */
+	struct tasklet_struct dpc_tasklet;
+	spinlock_t dpc_lock;
+
 } ;
 
-/*  ----------------------------------- Function Prototypes */
+/* Function Prototypes */
 static void IO_DispatchChnl(IN struct IO_MGR *pIOMgr,
 			   IN OUT struct CHNL_OBJECT *pChnl, u32 iMode);
 static void IO_DispatchMsg(IN struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr);
@@ -173,7 +154,7 @@ static struct workqueue_struct *bridge_w
 void PrintDSPDebugTrace(struct IO_MGR *hIOMgr);
 #endif
 
-/* Bus Addr (cached kernel)*/
+/* Bus Addr (cached kernel) */
 static DSP_STATUS registerSHMSegs(struct IO_MGR *hIOMgr,
 				  struct COD_MANAGER *hCodMan,
 				  u32 dwGPPBasePA);
@@ -206,22 +187,26 @@ DSP_STATUS WMD_IO_Create(OUT struct IO_M
 	struct CHNL_MGR *hChnlMgr;
 	static int ref_count;
 	u32 devType;
-	/* Check DBC requirements:  */
-	DBC_Require(phIOMgr != NULL);
-	DBC_Require(pMgrAttrs != NULL);
-	DBC_Require(pMgrAttrs->uWordSize != 0);
-	/* This for the purposes of DBC_Require: */
-	status = DEV_GetChnlMgr(hDevObject, &hChnlMgr);
-	DBC_Require(status != DSP_EHANDLE);
-	DBC_Require(hChnlMgr != NULL);
-	DBC_Require(hChnlMgr->hIOMgr == NULL);
+	/* Check requirements */
+	if (!phIOMgr || !pMgrAttrs || pMgrAttrs->uWordSize == 0) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	DEV_GetChnlMgr(hDevObject, &hChnlMgr);
+	if (!hChnlMgr || hChnlMgr->hIOMgr) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 	/*
 	 * Message manager will be created when a file is loaded, since
 	 * size of message buffer in shared memory is configurable in
 	 * the base image.
 	 */
 	DEV_GetWMDContext(hDevObject, &hWmdContext);
-	DBC_Assert(hWmdContext);
+	if (!hWmdContext) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 	DEV_GetDevType(hDevObject, &devType);
 	/*
 	 * DSP shared memory area will get set properly when
@@ -230,31 +215,30 @@ DSP_STATUS WMD_IO_Create(OUT struct IO_M
 	 * a valid address than 0.
 	 */
 	pSharedMem = (struct SHM *) -1;
-	if (DSP_FAILED(status))
-		goto func_cont;
 
 	/* Create a Single Threaded Work Queue */
 	if (ref_count == 0)
 		bridge_workqueue = create_workqueue("bridge_work-queue");
 
-	if (!bridge_workqueue)
-		DBG_Trace(DBG_LEVEL1, "Workqueue creation failed!\n");
+	if (bridge_workqueue <= 0)
+		DBG_Trace(DBG_LEVEL1, "Workque Create failed 0x%d \n",
+						bridge_workqueue);
 
-	/* Allocate IO manager object: */
+	/* Allocate IO manager object */
 	MEM_AllocObject(pIOMgr, struct IO_MGR, IO_MGRSIGNATURE);
 	if (pIOMgr == NULL) {
 		status = DSP_EMEMORY;
-		goto func_cont;
+		goto func_end;
 	}
-
 	/* Intializing Work Element */
 	if (ref_count == 0) {
 		INIT_WORK(&pIOMgr->io_workq, (void *)IO_DispatchPM);
 		ref_count = 1;
-	} else
+	} else {
 		PREPARE_WORK(&pIOMgr->io_workq, (void *)IO_DispatchPM);
+	}
 
-	/* Initialize CHNL_MGR object:    */
+	/* Initialize CHNL_MGR object */
 #ifndef DSP_TRACEBUF_DISABLED
 	pIOMgr->pMsg = NULL;
 #endif
@@ -265,8 +249,15 @@ DSP_STATUS WMD_IO_Create(OUT struct IO_M
 		status = SYNC_InitializeCS(&pIOMgr->hCSObj);
 
 	if (devType == DSP_UNIT) {
-		/* Create a DPC object: */
-		status = DPC_Create(&pIOMgr->hDPC, IO_DPC, (void *)pIOMgr);
+		/* Create an IO DPC */
+		tasklet_init(&pIOMgr->dpc_tasklet, IO_DPC, (u32)pIOMgr);
+
+		/* Initialize DPC counters */
+		pIOMgr->dpc_req = 0;
+		pIOMgr->dpc_sched = 0;
+
+		spin_lock_init(&pIOMgr->dpc_lock);
+
 		if (DSP_SUCCEEDED(status))
 			status = DEV_GetDevNode(hDevObject, &hDevNode);
 
@@ -283,25 +274,23 @@ DSP_STATUS WMD_IO_Create(OUT struct IO_M
 		IO_DisableInterrupt(hWmdContext);
 		if (devType == DSP_UNIT) {
 			HW_MBOX_initSettings(hostRes.dwMboxBase);
-			/* Plug the channel ISR:. */
+			/* Plug the channel ISR */
 			if ((request_irq(INT_MAIL_MPU_IRQ, IO_ISR, 0,
-				"DspBridge\tmailbox", (void *)pIOMgr)) == 0)
-				status = DSP_SOK;
+			  "DspBridge\tmailbox", (void *)pIOMgr)) == 0)
+				DBG_Trace(DBG_LEVEL1, "ISR_IRQ Object 0x%x \n",
+						pIOMgr);
 			else
-				status = DSP_EFAIL;
+				status = CHNL_E_ISR;
 		}
-		if (DSP_SUCCEEDED(status))
-			DBG_Trace(DBG_LEVEL1, "ISR_IRQ Object 0x%x \n",
-					pIOMgr);
-		else
-			status = CHNL_E_ISR;
-	} else
+	} else {
 		status = CHNL_E_ISR;
-func_cont:
+	}
+func_end:
 	if (DSP_FAILED(status)) {
-		/* Cleanup: */
+		/* Cleanup */
 		WMD_IO_Destroy(pIOMgr);
-		*phIOMgr = NULL;
+		if (phIOMgr)
+			*phIOMgr = NULL;
 	} else {
 		/* Return IO manager object to caller... */
 		hChnlMgr->hIOMgr = pIOMgr;
@@ -320,25 +309,29 @@ DSP_STATUS WMD_IO_Destroy(struct IO_MGR 
 	DSP_STATUS status = DSP_SOK;
 	struct WMD_DEV_CONTEXT *hWmdContext;
 	if (MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE)) {
-		/* Unplug IRQ:    */
-               /* Disable interrupts from the board:  */
-               if (DSP_SUCCEEDED(DEV_GetWMDContext(hIOMgr->hDevObject,
-                      &hWmdContext)))
-                               DBC_Assert(hWmdContext);
-               (void)CHNLSM_DisableInterrupt(hWmdContext);
-               destroy_workqueue(bridge_workqueue);
-               /* Linux function to uninstall ISR */
-               free_irq(INT_MAIL_MPU_IRQ, (void *)hIOMgr);
-               (void)DPC_Destroy(hIOMgr->hDPC);
+		/* Disable interrupts from the board */
+		status = DEV_GetWMDContext(hIOMgr->hDevObject, &hWmdContext);
+		if (DSP_SUCCEEDED(status))
+			(void)CHNLSM_DisableInterrupt(hWmdContext);
+
+		destroy_workqueue(bridge_workqueue);
+		/* Linux function to uninstall ISR */
+		free_irq(INT_MAIL_MPU_IRQ, (void *)hIOMgr);
+
+		/* Free IO DPC object */
+		tasklet_kill(&hIOMgr->dpc_tasklet);
+		DBG_Trace(GT_2CLASS, "DPC_Destroy: SUCCESS\n");
+
 #ifndef DSP_TRACEBUF_DISABLED
 		if (hIOMgr->pMsg)
 			MEM_Free(hIOMgr->pMsg);
 #endif
 		SYNC_DeleteCS(hIOMgr->hCSObj); 	/* Leak Fix. */
-		/* Free this IO manager object: */
+		/* Free this IO manager object */
 		MEM_FreeObject(hIOMgr);
-       } else
+	} else {
 		status = DSP_EHANDLE;
+	}
 
 	return status;
 }
@@ -389,13 +382,17 @@ DSP_STATUS WMD_IO_OnLoaded(struct IO_MGR
 			   HW_PAGE_SIZE_64KB, HW_PAGE_SIZE_4KB };
 
 	status = DEV_GetCodMgr(hIOMgr->hDevObject, &hCodMan);
-	DBC_Assert(DSP_SUCCEEDED(status));
+	if (DSP_FAILED(status))
+		goto func_end;
 	hChnlMgr = hIOMgr->hChnlMgr;
-	 /*  The message manager is destroyed when the board is stopped.  */
+	/* The message manager is destroyed when the board is stopped. */
 	DEV_GetMsgMgr(hIOMgr->hDevObject, &hIOMgr->hMsgMgr);
 	hMsgMgr = hIOMgr->hMsgMgr;
-	DBC_Assert(MEM_IsValidHandle(hChnlMgr, CHNL_MGRSIGNATURE));
-	DBC_Assert(MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE));
+	if (!MEM_IsValidHandle(hChnlMgr, CHNL_MGRSIGNATURE) ||
+	   !MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 	if (hIOMgr->pSharedMem)
 		hIOMgr->pSharedMem = NULL;
 
@@ -404,25 +401,25 @@ DSP_STATUS WMD_IO_OnLoaded(struct IO_MGR
 				 &ulShmBase);
 	if (DSP_FAILED(status)) {
 		status = CHNL_E_NOMEMMAP;
-		goto func_cont1;
+		goto func_end;
 	}
 	status = COD_GetSymValue(hCodMan, CHNL_SHARED_BUFFER_LIMIT_SYM,
 				&ulShmLimit);
 	if (DSP_FAILED(status)) {
 		status = CHNL_E_NOMEMMAP;
-		goto func_cont1;
+		goto func_end;
 	}
 	if (ulShmLimit <= ulShmBase) {
 		status = CHNL_E_INVALIDMEMBASE;
-	} else {
-		/* get total length in bytes */
-		ulShmLength = (ulShmLimit - ulShmBase + 1) * hIOMgr->uWordSize;
-		/* Calculate size of a PROCCOPY shared memory region */
-		DBG_Trace(DBG_LEVEL7,
-			 "**(proc)PROCCOPY SHMMEM SIZE: 0x%x bytes\n",
-			  (ulShmLength - sizeof(struct SHM)));
+		goto func_end;
 	}
-func_cont1:
+	/* Get total length in bytes */
+	ulShmLength = (ulShmLimit - ulShmBase + 1) * hIOMgr->uWordSize;
+	/* Calculate size of a PROCCOPY shared memory region */
+	DBG_Trace(DBG_LEVEL7,
+		 "**(proc)PROCCOPY SHMMEM SIZE: 0x%x bytes\n",
+		  (ulShmLength - sizeof(struct SHM)));
+
 	if (DSP_SUCCEEDED(status)) {
 		/* Get start and length of message part of shared memory */
 		status = COD_GetSymValue(hCodMan, MSG_SHARED_BUFFER_BASE_SYM,
@@ -435,17 +432,23 @@ func_cont1:
 			if (ulMsgLimit <= ulMsgBase) {
 				status = CHNL_E_INVALIDMEMBASE;
 			} else {
-				/* Length (bytes) of messaging part of shared
-				 * memory */
+				/*
+				 * Length (bytes) of messaging part of shared
+				 * memory.
+				 */
 				ulMsgLength = (ulMsgLimit - ulMsgBase + 1) *
 					      hIOMgr->uWordSize;
-				/* Total length (bytes) of shared memory:
-				 * chnl + msg */
+				/*
+				 * Total length (bytes) of shared memory:
+				 * chnl + msg.
+				 */
 				ulMemLength = ulShmLength + ulMsgLength;
 			}
 		} else {
 			status = CHNL_E_NOMEMMAP;
 		}
+	} else {
+		status = CHNL_E_NOMEMMAP;
 	}
 	if (DSP_SUCCEEDED(status)) {
 #ifndef DSP_TRACEBUF_DISABLED
@@ -459,19 +462,16 @@ func_cont1:
 #endif
 		if (DSP_FAILED(status))
 			status = CHNL_E_NOMEMMAP;
-
 	}
 	if (DSP_SUCCEEDED(status)) {
 		status = COD_GetSymValue(hCodMan, DYNEXTBASE, &ulDynExtBase);
 		if (DSP_FAILED(status))
 			status = CHNL_E_NOMEMMAP;
-
 	}
 	if (DSP_SUCCEEDED(status)) {
 		status = COD_GetSymValue(hCodMan, EXTEND, &ulExtEnd);
 		if (DSP_FAILED(status))
 			status = CHNL_E_NOMEMMAP;
-
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Get memory reserved in host resources */
@@ -485,7 +485,7 @@ func_cont1:
 		ndx = 0;
 		ulGppPa = hostRes.dwMemPhys[1];
 		ulGppVa = hostRes.dwMemBase[1];
-		/* THIS IS THE VIRTUAL UNCACHED IOREMAPPED ADDRESS !!! */
+		/* This is the virtual uncached ioremapped address!!! */
 		/* Why can't we directly take the DSPVA from the symbols? */
 		ulDspVa = hIOMgr->extProcInfo.tyTlb[0].ulDspVirt;
 		ulSegSize = (ulShm0End - ulDspVa) * hIOMgr->uWordSize;
@@ -517,7 +517,7 @@ func_cont1:
 		}
 	}
 	if (DSP_FAILED(status))
-		goto func_cont;
+		goto func_end;
 
 	paCurr = ulGppPa;
 	vaCurr = ulDynExtBase * hIOMgr->uWordSize;
@@ -536,9 +536,11 @@ func_cont1:
 	mapAttrs |= DSP_MAPELEMSIZE32;
 	mapAttrs |= DSP_MAPDONOTLOCK;
 
-	while (numBytes && DSP_SUCCEEDED(status)) {
-		/* To find the max. page size with which both PA & VA are
-		 * aligned */
+	while (numBytes) {
+		/*
+		 * To find the max. page size with which both PA & VA are
+		 * aligned.
+		 */
 		allBits = paCurr | vaCurr;
 		DBG_Trace(DBG_LEVEL1, "allBits %x, paCurr %x, vaCurr %x, "
 			 "numBytes %x\n", allBits, paCurr, vaCurr, numBytes);
@@ -548,14 +550,17 @@ func_cont1:
 				status = hIOMgr->pIntfFxns->pfnBrdMemMap
 					(hIOMgr->hWmdContext, paCurr, vaCurr,
 					pgSize[i], mapAttrs);
-				DBC_Assert(DSP_SUCCEEDED(status));
+				if (DSP_FAILED(status))
+					goto func_end;
 				paCurr += pgSize[i];
 				vaCurr += pgSize[i];
 				gppVaCurr += pgSize[i];
 				numBytes -= pgSize[i];
-				/* Don't try smaller sizes. Hopefully we have
+				/*
+				 * Don't try smaller sizes. Hopefully we have
 				 * reached an address aligned to a bigger page
-				 * size*/
+				 * size.
+				 */
 				break;
 			}
 		}
@@ -564,13 +569,14 @@ func_cont1:
 	vaCurr += ulPadSize;
 	gppVaCurr += ulPadSize;
 
-	/* configure the TLB entries for the next cacheable segment */
+	/* Configure the TLB entries for the next cacheable segment */
 	numBytes = ulSegSize;
 	vaCurr = ulDspVa * hIOMgr->uWordSize;
-	allBits = 0x0;
-	while (numBytes && DSP_SUCCEEDED(status)) {
-		/* To find the max. page size with which both PA & VA are
-		 * aligned*/
+	while (numBytes ) {
+		/*
+		 * To find the max. page size with which both PA & VA are
+		 * aligned.
+		 */
 		allBits = paCurr | vaCurr;
 		DBG_Trace(DBG_LEVEL1, "allBits for Seg1 %x, paCurr %x, "
 			 "vaCurr %x, numBytes %x\n", allBits, paCurr, vaCurr,
@@ -580,11 +586,15 @@ func_cont1:
 			   !((allBits & (pgSize[i]-1)) == 0))
 				continue;
 			if (ndx < MAX_LOCK_TLB_ENTRIES) {
-				/* This is the physical address written to
-				 * DSP MMU */
+				/*
+				 * This is the physical address written to
+				 * DSP MMU.
+				 */
 				aEProc[ndx].ulGppPa = paCurr;
-				/* THIS IS THE VIRTUAL UNCACHED IOREMAPPED
-				 * ADDRESS!!! */
+				/*
+				 * This is the virtual uncached ioremapped
+				 * address!!!
+				 */
 				aEProc[ndx].ulGppVa = gppVaCurr;
 				aEProc[ndx].ulDspVa = vaCurr / hIOMgr->
 						      uWordSize;
@@ -609,22 +619,26 @@ func_cont1:
 					 aEProc[ndx].ulGppVa,
 					 aEProc[ndx].ulDspVa *
 					 hIOMgr->uWordSize, pgSize[i]);
-				DBC_Assert(DSP_SUCCEEDED(status));
+				if (DSP_FAILED(status))
+					goto func_end;
 			}
 			paCurr += pgSize[i];
 			vaCurr += pgSize[i];
 			gppVaCurr += pgSize[i];
 			numBytes -= pgSize[i];
-			/* Don't try smaller sizes. Hopefully we have reached
-			 an address aligned to a bigger page size*/
+			/*
+			 * Don't try smaller sizes. Hopefully we have reached
+			 * an address aligned to a bigger page size.
+			 */
 			break;
 		}
 	}
 
-	 /* Copy remaining entries from CDB. All entries are 1 MB and should not
-	 * conflict with SHM entries on MPU or DSP side */
-	for (i = 3; i < 7 && ndx < WMDIOCTL_NUMOFMMUTLB &&
-	    DSP_SUCCEEDED(status); i++) {
+	/*
+	 * Copy remaining entries from CDB. All entries are 1 MB and
+	 * should not conflict with SHM entries on MPU or DSP side.
+	 */
+	for (i = 3; i < 7 && ndx < WMDIOCTL_NUMOFMMUTLB; i++) {
 		if (hIOMgr->extProcInfo.tyTlb[i].ulGppPhys == 0)
 			continue;
 
@@ -649,8 +663,8 @@ func_cont1:
 				aEProc[ndx].ulGppPa = hIOMgr->extProcInfo.
 					tyTlb[i].ulGppPhys;
 				aEProc[ndx].ulGppVa = 0;
-				/* Can't convert, so set to zero*/
-				aEProc[ndx].ulSize = 0x100000; 	/* 1 MB*/
+				/* Can't convert, so set to zero */
+				aEProc[ndx].ulSize = 0x100000; 	/* 1 MB */
 				DBG_Trace(DBG_LEVEL1, "SHM MMU entry PA %x "
 					 "DSP_VA 0x%x\n", aEProc[ndx].ulGppPa,
 					aEProc[ndx].ulDspVa);
@@ -663,12 +677,10 @@ func_cont1:
 					0x100000, mapAttrs);
 			}
 		}
+		if (DSP_FAILED(status))
+			goto func_end;
 	}
-	if (i < 7 && DSP_SUCCEEDED(status)) {
-		/* All CDB entries could not be made*/
-		status = DSP_EFAIL;
-	}
-func_cont:
+
 	mapAttrs = 0x00000000;
 	mapAttrs = DSP_MAPLITTLEENDIAN;
 	mapAttrs |= DSP_MAPPHYSICALADDR;
@@ -677,154 +689,148 @@ func_cont:
 
 	/* Map the L4 peripherals */
 	i = 0;
-	while (L4PeripheralTable[i].physAddr && DSP_SUCCEEDED(status)) {
+	while (L4PeripheralTable[i].physAddr) {
 		status = hIOMgr->pIntfFxns->pfnBrdMemMap
 			(hIOMgr->hWmdContext, L4PeripheralTable[i].physAddr,
 			L4PeripheralTable[i].dspVirtAddr, HW_PAGE_SIZE_4KB,
 			mapAttrs);
 		if (DSP_FAILED(status))
-			break;
+			goto func_end;
 		i++;
 	}
 
-	if (DSP_SUCCEEDED(status)) {
-		for (i = ndx; i < WMDIOCTL_NUMOFMMUTLB; i++) {
-			aEProc[i].ulDspVa = 0;
-			aEProc[i].ulGppPa = 0;
-			aEProc[i].ulGppVa = 0;
-			aEProc[i].ulSize = 0;
-		}
-		/* Set the SHM physical address entry (grayed out in CDB file)
-		 * to the virtual uncached ioremapped address of SHM reserved
-		 * on MPU */
-		hIOMgr->extProcInfo.tyTlb[0].ulGppPhys = (ulGppVa + ulSeg1Size +
-							 ulPadSize);
-		DBG_Trace(DBG_LEVEL1, "*********extProcInfo *********%x \n",
-			  hIOMgr->extProcInfo.tyTlb[0].ulGppPhys);
-		/* Need SHM Phys addr. IO supports only one DSP for now:
-		 * uNumProcs=1 */
-		if ((hIOMgr->extProcInfo.tyTlb[0].ulGppPhys == 0) ||
-		   (uNumProcs != 1)) {
-			status = CHNL_E_NOMEMMAP;
-			DBC_Assert(false);
-		} else {
-			DBC_Assert(aEProc[0].ulDspVa <= ulShmBase);
-			/* ulShmBase may not be at ulDspVa address */
-			ulShmBaseOffset = (ulShmBase - aEProc[0].ulDspVa) *
-			    hIOMgr->uWordSize;
-			 /* WMD_BRD_Ctrl() will set dev context dsp-mmu info. In
-			 *   _BRD_Start() the MMU will be re-programed with MMU
-			 *   DSPVa-GPPPa pair info while DSP is in a known
-			 *   (reset) state.  */
-			DBC_Assert(hIOMgr->pIntfFxns != NULL);
-			DBC_Assert(hIOMgr->hWmdContext != NULL);
-			status = hIOMgr->pIntfFxns->pfnDevCntrl(hIOMgr->
-				 hWmdContext, WMDIOCTL_SETMMUCONFIG, aEProc);
-			ulShmBase = hIOMgr->extProcInfo.tyTlb[0].ulGppPhys;
-			DBG_Trace(DBG_LEVEL1, "extProcInfo.tyTlb[0].ulGppPhys "
-				 "%x \n ", hIOMgr->extProcInfo.tyTlb[0].
-				 ulGppPhys);
-			ulShmBase += ulShmBaseOffset;
-			ulShmBase = (u32)MEM_LinearAddress((void *)ulShmBase,
-				    ulMemLength);
-			DBC_Assert(ulShmBase != 0);
-			if (DSP_SUCCEEDED(status)) {
-				status = registerSHMSegs(hIOMgr, hCodMan,
-					 aEProc[0].ulGppPa);
-				/* Register SM */
-			}
-		}
-	}
-	if (DSP_SUCCEEDED(status)) {
-		hIOMgr->pSharedMem = (struct SHM *)ulShmBase;
-		hIOMgr->pInput = (u8 *)hIOMgr->pSharedMem +
-				 sizeof(struct SHM);
-		hIOMgr->pOutput = hIOMgr->pInput + (ulShmLength -
-				  sizeof(struct SHM))/2;
-		hIOMgr->uSMBufSize = hIOMgr->pOutput - hIOMgr->pInput;
-		DBG_Trace(DBG_LEVEL3,
-			 "hIOMgr: pInput %p pOutput %p ulShmLength %x\n",
-			 hIOMgr->pInput, hIOMgr->pOutput, ulShmLength);
-		DBG_Trace(DBG_LEVEL3,
-			 "pSharedMem %p uSMBufSize %x sizeof(SHM) %x\n",
-			 hIOMgr->pSharedMem, hIOMgr->uSMBufSize,
-			 sizeof(struct SHM));
-		 /*  Set up Shared memory addresses for messaging. */
-		hIOMgr->pMsgInputCtrl = (struct MSG *)((u8 *)
-					hIOMgr->pSharedMem +
-					ulShmLength);
-		hIOMgr->pMsgInput = (u8 *)hIOMgr->pMsgInputCtrl +
-				    sizeof(struct MSG);
-		hIOMgr->pMsgOutputCtrl = (struct MSG *)((u8 *)hIOMgr->
-					 pMsgInputCtrl + ulMsgLength / 2);
-		hIOMgr->pMsgOutput = (u8 *)hIOMgr->pMsgOutputCtrl +
-				     sizeof(struct MSG);
-		hMsgMgr->uMaxMsgs = ((u8 *)hIOMgr->pMsgOutputCtrl -
-				    hIOMgr->pMsgInput) /
-				    sizeof(struct MSG_DSPMSG);
-		DBG_Trace(DBG_LEVEL7, "IO MGR SHM details : pSharedMem 0x%x, "
-			 "pInput 0x%x, pOutput 0x%x, pMsgInputCtrl 0x%x, "
-			 "pMsgInput 0x%x, pMsgOutputCtrl 0x%x, pMsgOutput "
-			 "0x%x \n", (u8 *)hIOMgr->pSharedMem,
-			 (u8 *)hIOMgr->pInput, (u8 *)hIOMgr->pOutput,
-			 (u8 *)hIOMgr->pMsgInputCtrl,
-			 (u8 *)hIOMgr->pMsgInput,
-			 (u8 *)hIOMgr->pMsgOutputCtrl,
-			 (u8 *)hIOMgr->pMsgOutput);
-		DBG_Trace(DBG_LEVEL7, "** (proc) MAX MSGS IN SHARED MEMORY: "
-			 "0x%x\n", hMsgMgr->uMaxMsgs);
-		memset((void *) hIOMgr->pSharedMem, 0, sizeof(struct SHM));
+
+	for (i = ndx; i < WMDIOCTL_NUMOFMMUTLB; i++) {
+		aEProc[i].ulDspVa = 0;
+		aEProc[i].ulGppPa = 0;
+		aEProc[i].ulGppVa = 0;
+		aEProc[i].ulSize = 0;
 	}
+	/*
+	 * Set the SHM physical address entry (grayed out in CDB file)
+	 * to the virtual uncached ioremapped address of SHM reserved
+	 * on MPU.
+	 */
+	hIOMgr->extProcInfo.tyTlb[0].ulGppPhys = (ulGppVa + ulSeg1Size +
+						 ulPadSize);
+	DBG_Trace(DBG_LEVEL1, "*********extProcInfo *********%x \n",
+		  hIOMgr->extProcInfo.tyTlb[0].ulGppPhys);
+	/*
+	 * Need SHM Phys addr. IO supports only one DSP for now:
+	 * uNumProcs = 1.
+	 */
+	if (!hIOMgr->extProcInfo.tyTlb[0].ulGppPhys || uNumProcs != 1) {
+		status = CHNL_E_NOMEMMAP;
+		goto func_end;
+	} else {
+		if (aEProc[0].ulDspVa > ulShmBase) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
+		/* ulShmBase may not be at ulDspVa address */
+		ulShmBaseOffset = (ulShmBase - aEProc[0].ulDspVa) *
+				hIOMgr->uWordSize;
+		/*
+		 * WMD_BRD_Ctrl() will set dev context dsp-mmu info. In
+		 * _BRD_Start() the MMU will be re-programed with MMU
+		 * DSPVa-GPPPa pair info while DSP is in a known
+		 * (reset) state.
+		 */
+
+		status = hIOMgr->pIntfFxns->pfnDevCntrl(hIOMgr->hWmdContext,
+						WMDIOCTL_SETMMUCONFIG, aEProc);
+		if (DSP_FAILED(status))
+			goto func_end;
+		ulShmBase = hIOMgr->extProcInfo.tyTlb[0].ulGppPhys;
+		DBG_Trace(DBG_LEVEL1, "extProcInfo.tyTlb[0].ulGppPhys %x \n ",
+				hIOMgr->extProcInfo.tyTlb[0].ulGppPhys);
+		ulShmBase += ulShmBaseOffset;
+		ulShmBase = (u32)MEM_LinearAddress((void *)ulShmBase,
+				    ulMemLength);
+		if (ulShmBase == 0) {
+			status = DSP_EPOINTER;
+			goto func_end;
+		}
+		/* Register SM */
+		status = registerSHMSegs(hIOMgr, hCodMan, aEProc[0].ulGppPa);
+	}
+
+	hIOMgr->pSharedMem = (struct SHM *)ulShmBase;
+	hIOMgr->pInput = (u8 *)hIOMgr->pSharedMem + sizeof(struct SHM);
+	hIOMgr->pOutput = hIOMgr->pInput + (ulShmLength -
+						sizeof(struct SHM)) / 2;
+	hIOMgr->uSMBufSize = hIOMgr->pOutput - hIOMgr->pInput;
+	DBG_Trace(DBG_LEVEL3, "hIOMgr: pInput %p pOutput %p ulShmLength %x\n",
+				 hIOMgr->pInput, hIOMgr->pOutput, ulShmLength);
+	DBG_Trace(DBG_LEVEL3, "pSharedMem %p uSMBufSize %x sizeof(SHM) %x\n",
+		 hIOMgr->pSharedMem, hIOMgr->uSMBufSize, sizeof(struct SHM));
+	 /*  Set up Shared memory addresses for messaging. */
+	hIOMgr->pMsgInputCtrl = (struct MSG *)((u8 *)hIOMgr->pSharedMem
+							+ ulShmLength);
+	hIOMgr->pMsgInput = (u8 *)hIOMgr->pMsgInputCtrl + sizeof(struct MSG);
+	hIOMgr->pMsgOutputCtrl = (struct MSG *)((u8 *)hIOMgr->pMsgInputCtrl
+							+ ulMsgLength / 2);
+	hIOMgr->pMsgOutput = (u8 *)hIOMgr->pMsgOutputCtrl + sizeof(struct MSG);
+	hMsgMgr->uMaxMsgs = ((u8 *)hIOMgr->pMsgOutputCtrl - hIOMgr->pMsgInput)
+						/ sizeof(struct MSG_DSPMSG);
+	DBG_Trace(DBG_LEVEL7, "IO MGR SHM details : pSharedMem 0x%x, "
+		"pInput 0x%x, pOutput 0x%x, pMsgInputCtrl 0x%x, "
+		"pMsgInput 0x%x, pMsgOutputCtrl 0x%x, pMsgOutput "
+		"0x%x \n", (u8 *)hIOMgr->pSharedMem, (u8 *)hIOMgr->pInput,
+		(u8 *)hIOMgr->pOutput, (u8 *)hIOMgr->pMsgInputCtrl,
+		(u8 *)hIOMgr->pMsgInput, (u8 *)hIOMgr->pMsgOutputCtrl,
+		(u8 *)hIOMgr->pMsgOutput);
+	DBG_Trace(DBG_LEVEL7, "** (proc) MAX MSGS IN SHARED MEMORY: "
+					"0x%x\n", hMsgMgr->uMaxMsgs);
+	memset((void *) hIOMgr->pSharedMem, 0, sizeof(struct SHM));
+
 #ifndef DSP_TRACEBUF_DISABLED
-	if (DSP_SUCCEEDED(status)) {
-		/* Get the start address of trace buffer */
-		if (DSP_SUCCEEDED(status)) {
-			status = COD_GetSymValue(hCodMan, SYS_PUTCBEG,
+	/* Get the start address of trace buffer */
+	status = COD_GetSymValue(hCodMan, SYS_PUTCBEG,
 				 &hIOMgr->ulTraceBufferBegin);
-			if (DSP_FAILED(status))
-				status = CHNL_E_NOMEMMAP;
+	if (DSP_FAILED(status)) {
+		status = CHNL_E_NOMEMMAP;
+		goto func_end;
+	}
 
-		}
-		hIOMgr->ulGPPReadPointer = hIOMgr->ulTraceBufferBegin =
-			(ulGppVa + ulSeg1Size + ulPadSize) +
-			(hIOMgr->ulTraceBufferBegin - ulDspVa);
-		/* Get the end address of trace buffer */
-		if (DSP_SUCCEEDED(status)) {
-			status = COD_GetSymValue(hCodMan, SYS_PUTCEND,
-				 &hIOMgr->ulTraceBufferEnd);
-			if (DSP_FAILED(status))
-				status = CHNL_E_NOMEMMAP;
+	hIOMgr->ulGPPReadPointer = hIOMgr->ulTraceBufferBegin =
+		(ulGppVa + ulSeg1Size + ulPadSize) +
+		(hIOMgr->ulTraceBufferBegin - ulDspVa);
+	/* Get the end address of trace buffer */
 
-		}
-		hIOMgr->ulTraceBufferEnd = (ulGppVa + ulSeg1Size + ulPadSize) +
-					   (hIOMgr->ulTraceBufferEnd - ulDspVa);
-		/* Get the current address of DSP write pointer */
-		if (DSP_SUCCEEDED(status)) {
-			status = COD_GetSymValue(hCodMan,
-				 BRIDGE_SYS_PUTC_current,
-				 &hIOMgr->ulTraceBufferCurrent);
-			if (DSP_FAILED(status))
-				status = CHNL_E_NOMEMMAP;
+	status = COD_GetSymValue(hCodMan, SYS_PUTCEND,
+						&hIOMgr->ulTraceBufferEnd);
+	if (DSP_FAILED(status)) {
+		status = CHNL_E_NOMEMMAP;
+		goto func_end;
+	}
+	hIOMgr->ulTraceBufferEnd = (ulGppVa + ulSeg1Size + ulPadSize) +
+				   (hIOMgr->ulTraceBufferEnd - ulDspVa);
+	/* Get the current address of DSP write pointer */
+	status = COD_GetSymValue(hCodMan, BRIDGE_SYS_PUTC_current,
+					 &hIOMgr->ulTraceBufferCurrent);
+	if (DSP_FAILED(status)) {
+		status = CHNL_E_NOMEMMAP;
+		goto func_end;
+	}
+	hIOMgr->ulTraceBufferCurrent = (ulGppVa + ulSeg1Size + ulPadSize) +
+				(hIOMgr->ulTraceBufferCurrent - ulDspVa);
+	/* Calculate the size of trace buffer */
+	if (hIOMgr->pMsg)
+		MEM_Free(hIOMgr->pMsg);
+	hIOMgr->pMsg = MEM_Alloc(((hIOMgr->ulTraceBufferEnd -
+				hIOMgr->ulTraceBufferBegin) *
+				hIOMgr->uWordSize) + 2, MEM_NONPAGED);
+	if (!hIOMgr->pMsg)
+		status = DSP_EMEMORY;
 
-		}
-		hIOMgr->ulTraceBufferCurrent = (ulGppVa + ulSeg1Size +
-						ulPadSize) + (hIOMgr->
-						ulTraceBufferCurrent - ulDspVa);
-		/* Calculate the size of trace buffer */
-		if (hIOMgr->pMsg)
-			MEM_Free(hIOMgr->pMsg);
-		hIOMgr->pMsg = MEM_Alloc(((hIOMgr->ulTraceBufferEnd -
-					hIOMgr->ulTraceBufferBegin) *
-					hIOMgr->uWordSize) + 2, MEM_NONPAGED);
-		if (!hIOMgr->pMsg)
-			status = DSP_EMEMORY;
+	DBG_Trace(DBG_LEVEL1, "** hIOMgr->pMsg: 0x%x\n", hIOMgr->pMsg);
+	hIOMgr->ulDspVa = ulDspVa;
+	hIOMgr->ulGppVa = (ulGppVa + ulSeg1Size + ulPadSize);
 
-		DBG_Trace(DBG_LEVEL1, "** hIOMgr->pMsg: 0x%x\n", hIOMgr->pMsg);
-		hIOMgr->ulDspVa = ulDspVa;
-		hIOMgr->ulGppVa = (ulGppVa + ulSeg1Size + ulPadSize);
-    }
 #endif
 	IO_EnableInterrupt(hIOMgr->hWmdContext);
+func_end:
 	return status;
 }
 
@@ -834,9 +840,10 @@ func_cont:
  */
 u32 IO_BufSize(struct IO_MGR *hIOMgr)
 {
-	DBC_Require(MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE));
-
-	return hIOMgr->uSMBufSize;
+	if (MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE))
+		return hIOMgr->uSMBufSize;
+	else
+		return 0;
 }
 
 /*
@@ -848,14 +855,17 @@ void IO_CancelChnl(struct IO_MGR *hIOMgr
 	struct IO_MGR *pIOMgr = (struct IO_MGR *)hIOMgr;
 	struct SHM *sm;
 
-	DBC_Require(MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE));
+	if (!MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE))
+		goto func_end;
 	sm = hIOMgr->pSharedMem;
 
-	/* Inform DSP that we have no more buffers on this channel:  */
+	/* Inform DSP that we have no more buffers on this channel */
 	IO_AndValue(pIOMgr->hWmdContext, struct SHM, sm, hostFreeMask,
 		   (~(1 << ulChnl)));
 
 	CHNLSM_InterruptDSP2(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
+func_end:
+	return;
 }
 
 /*
@@ -865,16 +875,20 @@ void IO_CancelChnl(struct IO_MGR *hIOMgr
 static void IO_DispatchChnl(IN struct IO_MGR *pIOMgr,
 			   IN OUT struct CHNL_OBJECT *pChnl, u32 iMode)
 {
-	DBC_Require(MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE));
+	if (!MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE))
+		goto func_end;
 
 	DBG_Trace(DBG_LEVEL3, "Entering IO_DispatchChnl \n");
 
-	/* See if there is any data available for transfer: */
-	DBC_Assert(iMode == IO_SERVICE);
+	/* See if there is any data available for transfer */
+	if (iMode != IO_SERVICE)
+		goto func_end;
 
-	/* Any channel will do for this mode: */
+	/* Any channel will do for this mode */
 	InputChnl(pIOMgr, pChnl, iMode);
 	OutputChnl(pIOMgr, pChnl, iMode);
+func_end:
+	return;
 }
 
 /*
@@ -883,13 +897,16 @@ static void IO_DispatchChnl(IN struct IO
  */
 static void IO_DispatchMsg(IN struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr)
 {
-	DBC_Require(MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE));
+	if (!MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE))
+		goto func_end;
 
 	DBG_Trace(DBG_LEVEL3, "Entering IO_DispatchMsg \n");
 
-	/*  We are performing both input and output processing. */
+	/* We are performing both input and output processing. */
 	InputMsg(pIOMgr, hMsgMgr);
 	OutputMsg(pIOMgr, hMsgMgr);
+func_end:
+	return;
 }
 
 /*
@@ -898,16 +915,13 @@ static void IO_DispatchMsg(IN struct IO_
  */
 static void IO_DispatchPM(struct work_struct *work)
 {
-       struct IO_MGR *pIOMgr =
-                               container_of(work, struct IO_MGR, io_workq);
+	struct IO_MGR *pIOMgr = container_of(work, struct IO_MGR, io_workq);
 	DSP_STATUS status;
 	u32 pArg[2];
 
-       /*DBC_Require(MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE));*/
-
 	DBG_Trace(DBG_LEVEL7, "IO_DispatchPM: Entering IO_DispatchPM : \n");
 
-	/*  Perform Power message processing here  */
+	/* Perform Power message processing here */
 	while (pIOMgr->iQuePowerHead != pIOMgr->iQuePowerTail) {
 		pArg[0] = *(u32 *)&(pIOMgr->dQuePowerMbxVal[pIOMgr->
 			  iQuePowerTail]);
@@ -947,13 +961,11 @@ static void IO_DispatchPM(struct work_st
 					 *pArg);
 			}
 		}
-		/* increment the tail count here */
+		/* Increment the tail count here */
 		pIOMgr->iQuePowerTail++;
 		if (pIOMgr->iQuePowerTail >= MAX_PM_REQS)
 			pIOMgr->iQuePowerTail = 0;
-
 	}
-
 }
 
 /*
@@ -962,47 +974,58 @@ static void IO_DispatchPM(struct work_st
  *      out the dispatch of I/O as a non-preemptible event.It can only be
  *      pre-empted      by an ISR.
  */
-void IO_DPC(IN OUT void *pRefData)
+void IO_DPC(IN OUT unsigned long pRefData)
 {
 	struct IO_MGR *pIOMgr = (struct IO_MGR *)pRefData;
 	struct CHNL_MGR *pChnlMgr;
 	struct MSG_MGR *pMsgMgr;
 	struct DEH_MGR *hDehMgr;
+	u32 requested;
+	u32 serviced;
 
-	DBC_Require(MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE));
+	if (!MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE))
+		goto func_end;
 	pChnlMgr = pIOMgr->hChnlMgr;
 	DEV_GetMsgMgr(pIOMgr->hDevObject, &pMsgMgr);
 	DEV_GetDehMgr(pIOMgr->hDevObject, &hDehMgr);
-	DBC_Require(MEM_IsValidHandle(pChnlMgr, CHNL_MGRSIGNATURE));
+	if (!MEM_IsValidHandle(pChnlMgr, CHNL_MGRSIGNATURE))
+		goto func_end;
 	DBG_Trace(DBG_LEVEL7, "Entering IO_DPC(0x%x)\n", pRefData);
-	/* Check value of interrupt register to ensure it is a valid error */
-	if ((pIOMgr->wIntrVal > DEH_BASE) && (pIOMgr->wIntrVal < DEH_LIMIT)) {
-		/* notify DSP/BIOS exception */
-		if (hDehMgr)
-			WMD_DEH_Notify(hDehMgr, DSP_SYSERROR, pIOMgr->wIntrVal);
 
-	}
-	IO_DispatchChnl(pIOMgr, NULL, IO_SERVICE);
+	requested = pIOMgr->dpc_req;
+	serviced = pIOMgr->dpc_sched;
+
+	if (serviced == requested)
+		goto func_end;
+
+	/* Process pending DPC's */
+	do {
+		/* Check value of interrupt reg to ensure it's a valid error */
+		if ((pIOMgr->wIntrVal > DEH_BASE) &&
+		   (pIOMgr->wIntrVal < DEH_LIMIT)) {
+			/* Notify DSP/BIOS exception */
+			if (hDehMgr)
+				WMD_DEH_Notify(hDehMgr, DSP_SYSERROR,
+						pIOMgr->wIntrVal);
+		}
+		IO_DispatchChnl(pIOMgr, NULL, IO_SERVICE);
 #ifdef CHNL_MESSAGES
-	if (pMsgMgr) {
-		DBC_Require(MEM_IsValidHandle(pMsgMgr, MSGMGR_SIGNATURE));
-		IO_DispatchMsg(pIOMgr, pMsgMgr);
-	}
+		if (MEM_IsValidHandle(pMsgMgr, MSGMGR_SIGNATURE))
+			IO_DispatchMsg(pIOMgr, pMsgMgr);
 #endif
 #ifndef DSP_TRACEBUF_DISABLED
-	if (pIOMgr->wIntrVal & MBX_DBG_CLASS) {
-		/* notify DSP Trace message */
-		if (pIOMgr->wIntrVal & MBX_DBG_SYSPRINTF)
-			PrintDSPDebugTrace(pIOMgr);
+	if (pIOMgr->wIntrVal & MBX_DBG_SYSPRINTF) {
+		/* Notify DSP Trace message */
+		PrintDSPDebugTrace(pIOMgr);
 	}
 #endif
-
-#ifndef DSP_TRACEBUF_DISABLED
-	PrintDSPDebugTrace(pIOMgr);
-#endif
+		serviced++;
+	} while (serviced != requested);
+	pIOMgr->dpc_sched = requested;
+func_end:
+	return;
 }
 
-
 /*
  *  ======== IO_ISR ========
  *      Main interrupt handler for the shared memory IO manager.
@@ -1013,35 +1036,46 @@ irqreturn_t IO_ISR(int irq, IN void *pRe
 {
 	struct IO_MGR *hIOMgr = (struct IO_MGR *)pRefData;
 	bool fSchedDPC;
-       DBC_Require(irq == INT_MAIL_MPU_IRQ);
-	DBC_Require(MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE));
+	unsigned long flags;
+
+	if (irq != INT_MAIL_MPU_IRQ ||
+	   !MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE))
+		return IRQ_NONE;
 	DBG_Trace(DBG_LEVEL3, "Entering IO_ISR(0x%x)\n", pRefData);
 
 	/* Call WMD's CHNLSM_ISR() to see if interrupt is ours, and process. */
 	if (IO_CALLISR(hIOMgr->hWmdContext, &fSchedDPC, &hIOMgr->wIntrVal)) {
-		{
-			DBG_Trace(DBG_LEVEL3, "IO_ISR %x\n", hIOMgr->wIntrVal);
-			if (hIOMgr->wIntrVal & MBX_PM_CLASS) {
-				hIOMgr->dQuePowerMbxVal[hIOMgr->iQuePowerHead] =
-					hIOMgr->wIntrVal;
-				hIOMgr->iQuePowerHead++;
-				if (hIOMgr->iQuePowerHead >= MAX_PM_REQS)
-					hIOMgr->iQuePowerHead = 0;
+		DBG_Trace(DBG_LEVEL3, "IO_ISR %x\n", hIOMgr->wIntrVal);
+		if (hIOMgr->wIntrVal & MBX_PM_CLASS) {
+			hIOMgr->dQuePowerMbxVal[hIOMgr->iQuePowerHead] =
+				hIOMgr->wIntrVal;
+			hIOMgr->iQuePowerHead++;
+			if (hIOMgr->iQuePowerHead >= MAX_PM_REQS)
+				hIOMgr->iQuePowerHead = 0;
+
+			queue_work(bridge_workqueue, &hIOMgr->io_workq);
+		}
+		if (hIOMgr->wIntrVal == MBX_DEH_RESET) {
+			DBG_Trace(DBG_LEVEL6, "*** DSP RESET ***\n");
+			hIOMgr->wIntrVal = 0;
+		} else if (fSchedDPC) {
+			/*
+			 * PROC-COPY defer i/o.
+			 * Increment count of DPC's pending.
+			 */
+			spin_lock_irqsave(&hIOMgr->dpc_lock, flags);
+			hIOMgr->dpc_req++;
+			spin_unlock_irqrestore(&hIOMgr->dpc_lock, flags);
 
-                               queue_work(bridge_workqueue, &hIOMgr->io_workq);
-			}
-			if (hIOMgr->wIntrVal == MBX_DEH_RESET) {
-				DBG_Trace(DBG_LEVEL6, "*** DSP RESET ***\n");
-				hIOMgr->wIntrVal = 0;
-			} else if (fSchedDPC) {
-				/* PROC-COPY defer i/o  */
-				DPC_Schedule(hIOMgr->hDPC);
-			}
+			/* Schedule DPC */
+			tasklet_schedule(&hIOMgr->dpc_tasklet);
 		}
-       } else
+	} else {
 		/* Ensure that, if WMD didn't claim it, the IRQ is shared. */
 		DBC_Ensure(hIOMgr->fSharedIRQ);
-       return IRQ_HANDLED;
+	}
+
+	return IRQ_HANDLED;
 }
 
 /*
@@ -1055,30 +1089,39 @@ void IO_RequestChnl(struct IO_MGR *pIOMg
 {
 	struct CHNL_MGR *pChnlMgr;
 	struct SHM *sm;
-	DBC_Require(pChnl != NULL);
-	DBC_Require(pwMbVal != NULL);
+
+	if (!pChnl || !pwMbVal)
+		goto func_end;
 	pChnlMgr = pIOMgr->hChnlMgr;
 	sm = pIOMgr->pSharedMem;
 	if (iMode == IO_INPUT) {
-		/*  Assertion fires if CHNL_AddIOReq() called on a stream
-		 * which was cancelled, or attached to a dead board: */
+		/*
+		 * Assertion fires if CHNL_AddIOReq() called on a stream
+		 * which was cancelled, or attached to a dead board.
+		 */
 		DBC_Assert((pChnl->dwState == CHNL_STATEREADY) ||
 			  (pChnl->dwState == CHNL_STATEEOS));
-		/* Indicate to the DSP we have a buffer available for input: */
+		/* Indicate to the DSP we have a buffer available for input */
 		IO_OrValue(pIOMgr->hWmdContext, struct SHM, sm, hostFreeMask,
 			  (1 << pChnl->uId));
 		*pwMbVal = MBX_PCPY_CLASS;
 	} else if (iMode == IO_OUTPUT) {
-		/*  This assertion fails if CHNL_AddIOReq() was called on a
-		 * stream which was cancelled, or attached to a dead board: */
+		/*
+		 * This assertion fails if CHNL_AddIOReq() was called on a
+		 * stream which was cancelled, or attached to a dead board.
+		 */
 		DBC_Assert((pChnl->dwState & ~CHNL_STATEEOS) ==
 			  CHNL_STATEREADY);
-		/* Record the fact that we have a buffer available for
-		 * output: */
+		/*
+		 * Record the fact that we have a buffer available for
+		 * output.
+		 */
 		pChnlMgr->dwOutputMask |= (1 << pChnl->uId);
 	} else {
 		DBC_Assert(iMode); 	/* Shouldn't get here. */
 	}
+func_end:
+	return;
 }
 
 /*
@@ -1087,9 +1130,18 @@ void IO_RequestChnl(struct IO_MGR *pIOMg
  */
 void IO_Schedule(struct IO_MGR *pIOMgr)
 {
-	DBC_Require(MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE));
+	unsigned long flags;
+
+	if (!MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE))
+		return;
+
+	/* Increment count of DPC's pending. */
+	spin_lock_irqsave(&pIOMgr->dpc_lock, flags);
+	pIOMgr->dpc_req++;
+	spin_unlock_irqrestore(&pIOMgr->dpc_lock, flags);
 
-	DPC_Schedule(pIOMgr->hDPC);
+	/* Schedule DPC */
+	tasklet_schedule(&pIOMgr->dpc_tasklet);
 }
 
 /*
@@ -1108,7 +1160,8 @@ static u32 FindReadyOutput(struct CHNL_M
 
 	id = (pChnl != NULL ? pChnl->uId : (pChnlMgr->dwLastOutput + 1));
 	id = ((id == CHNL_MAXCHANNELS) ? 0 : id);
-	DBC_Assert(id < CHNL_MAXCHANNELS);
+	if (id >= CHNL_MAXCHANNELS)
+		goto func_end;
 	if (dwMask) {
 		shift = (1 << id);
 		startId = id;
@@ -1117,7 +1170,6 @@ static u32 FindReadyOutput(struct CHNL_M
 				uRetval = id;
 				if (pChnl == NULL)
 					pChnlMgr->dwLastOutput = id;
-
 				break;
 			}
 			id = id + 1;
@@ -1125,7 +1177,7 @@ static u32 FindReadyOutput(struct CHNL_M
 			shift = (1 << id);
 		} while (id != startId);
 	}
-	DBC_Ensure((uRetval == OUTPUTNOTREADY) || (uRetval < CHNL_MAXCHANNELS));
+func_end:
 	return uRetval;
 }
 
@@ -1150,7 +1202,7 @@ static void InputChnl(struct IO_MGR *pIO
 
 	DBG_Trace(DBG_LEVEL3, "> InputChnl\n");
 
-	/* Attempt to perform input.... */
+	/* Attempt to perform input */
 	if (!IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm, inputFull))
 		goto func_end;
 
@@ -1166,18 +1218,21 @@ static void InputChnl(struct IO_MGR *pIO
 	pChnl = pChnlMgr->apChannel[chnlId];
 	if ((pChnl != NULL) && CHNL_IsInput(pChnl->uMode)) {
 		if ((pChnl->dwState & ~CHNL_STATEEOS) == CHNL_STATEREADY) {
-                       if (!pChnl->pIORequests)
-                               goto func_end;
-			/* Get the I/O request, and attempt a transfer:  */
+			if (!pChnl->pIORequests)
+				goto func_end;
+			/* Get the I/O request, and attempt a transfer */
 			pChirp = (struct CHNL_IRP *)LST_GetHead(pChnl->
 				 pIORequests);
 			if (pChirp) {
 				pChnl->cIOReqs--;
-				DBC_Assert(pChnl->cIOReqs >= 0);
-				/* Ensure we don't overflow the client's
-				 * buffer: */
+				if (pChnl->cIOReqs < 0)
+					goto func_end;
+				/*
+				 * Ensure we don't overflow the client's
+				 * buffer.
+				 */
 				uBytes = min(uBytes, pChirp->cBytes);
-				/* Transfer buffer from DSP side: */
+				/* Transfer buffer from DSP side */
 				uBytes = ReadData(pIOMgr->hWmdContext,
 						pChirp->pHostSysBuf,
 						pIOMgr->pInput, uBytes);
@@ -1189,26 +1244,32 @@ static void InputChnl(struct IO_MGR *pIO
 					 "\n", *((RMS_WORD *)(pChirp->
 					 pHostSysBuf)));
 				if (uBytes == 0) {
-					/* This assertion fails if the DSP
+					/*
+					 * This assertion fails if the DSP
 					 * sends EOS more than once on this
-					 * channel: */
-					DBC_Assert(!(pChnl->dwState &
-						  CHNL_STATEEOS));
-					 /* Zero bytes indicates EOS. Update
-					  * IOC status for this chirp, and also
-					  * the channel state: */
+					 * channel.
+					 */
+					if (pChnl->dwState & CHNL_STATEEOS)
+						goto func_end;
+					/*
+					 * Zero bytes indicates EOS. Update
+					 * IOC status for this chirp, and also
+					 * the channel state.
+					 */
 					pChirp->status |= CHNL_IOCSTATEOS;
 					pChnl->dwState |= CHNL_STATEEOS;
-					/* Notify that end of stream has
-					 * occurred */
+					/*
+					 * Notify that end of stream has
+					 * occurred.
+					 */
 					NTFY_Notify(pChnl->hNtfy,
 						   DSP_STREAMDONE);
 					DBG_Trace(DBG_LEVEL7, "Input Chnl NTFY "
 						 "chnl = 0x%x\n", pChnl);
 				}
-				/* Tell DSP if no more I/O buffers available: */
-                               if (!pChnl->pIORequests)
-                                       goto func_end;
+				/* Tell DSP if no more I/O buffers available */
+				if (!pChnl->pIORequests)
+					goto func_end;
 				if (LST_IsEmpty(pChnl->pIORequests)) {
 					IO_AndValue(pIOMgr->hWmdContext,
 						   struct SHM, sm, hostFreeMask,
@@ -1217,27 +1278,29 @@ static void InputChnl(struct IO_MGR *pIO
 				fClearChnl = true;
 				fNotifyClient = true;
 			} else {
-				/* Input full for this channel, but we have no
+				/*
+				 * Input full for this channel, but we have no
 				 * buffers available.  The channel must be
 				 * "idling". Clear out the physical input
-				 * channel.  */
+				 * channel.
+				 */
 				fClearChnl = true;
 			}
 		} else {
-			/* Input channel cancelled:  clear input channel.  */
+			/* Input channel cancelled: clear input channel */
 			fClearChnl = true;
 		}
 	} else {
-		/* DPC fired after host closed channel: clear input channel. */
+		/* DPC fired after host closed channel: clear input channel */
 		fClearChnl = true;
 	}
 	if (fClearChnl) {
-		/* Indicate to the DSP we have read the input: */
+		/* Indicate to the DSP we have read the input */
 		IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, inputFull, 0);
 		CHNLSM_InterruptDSP2(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
 	}
 	if (fNotifyClient) {
-		/* Notify client with IO completion record:  */
+		/* Notify client with IO completion record */
 		NotifyChnlComplete(pChnl, pChirp);
 	}
 func_end:
@@ -1261,12 +1324,12 @@ static void InputMsg(struct IO_MGR *pIOM
 	u32 addr;
 
 	pCtrl = pIOMgr->pMsgInputCtrl;
-	/* Get the number of input messages to be read. */
+	/* Get the number of input messages to be read */
 	fInputEmpty = IO_GetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
 				 bufEmpty);
 	uMsgs = IO_GetValue(pIOMgr->hWmdContext, struct MSG, pCtrl, size);
-	if (fInputEmpty || uMsgs >= hMsgMgr->uMaxMsgs)
-		return;
+	if (fInputEmpty)
+		goto func_end;
 
 	pMsgInput = pIOMgr->pMsgInput;
 	for (i = 0; i < uMsgs; i++) {
@@ -1280,49 +1343,53 @@ static void InputMsg(struct IO_MGR *pIOM
 		addr = (u32)&(((struct MSG_DSPMSG *)pMsgInput)->dwId);
 		msg.dwId = ReadExt32BitDspData(pIOMgr->hWmdContext, addr);
 		pMsgInput += sizeof(struct MSG_DSPMSG);
-               if (!hMsgMgr->queueList)
-                       goto func_end;
+		if (!hMsgMgr->queueList)
+			goto func_end;
 
 		/* Determine which queue to put the message in */
 		hMsgQueue = (struct MSG_QUEUE *)LST_First(hMsgMgr->queueList);
 		DBG_Trace(DBG_LEVEL7, "InputMsg RECVD: dwCmd=0x%x dwArg1=0x%x "
 			 "dwArg2=0x%x dwId=0x%x \n", msg.msg.dwCmd,
 			 msg.msg.dwArg1, msg.msg.dwArg2, msg.dwId);
-		 /*  Interrupt may occur before shared memory and message
-		 *  input locations have been set up. If all nodes were
-		 *  cleaned up, hMsgMgr->uMaxMsgs should be 0.  */
-               if (hMsgQueue && uMsgs > hMsgMgr->uMaxMsgs)
-                       goto func_end;
-
+		/*
+		 * Interrupt may occur before shared memory and message
+		 * input locations have been set up. If all nodes were
+		 * cleaned up, hMsgMgr->uMaxMsgs should be 0.
+		 */
 		while (hMsgQueue != NULL) {
 			if (msg.dwId == hMsgQueue->dwId) {
 				/* Found it */
 				if (msg.msg.dwCmd == RMS_EXITACK) {
-					/* The exit message does not get
-					 * queued */
-					/* Call the node exit notification */
-					/* Node handle */ /* status */
+					/*
+					 * Call the node exit notification.
+					 * The exit message does not get
+					 * queued.
+					 */
 					(*hMsgMgr->onExit)((HANDLE)hMsgQueue->
 						hArg, msg.msg.dwArg1);
 				} else {
-					/* Not an exit acknowledgement, queue
-					 * the message */
-                                       if (!hMsgQueue->msgFreeList)
-                                               goto func_end;
+					/*
+					 * Not an exit acknowledgement, queue
+					 * the message.
+					 */
+					if (!hMsgQueue->msgFreeList)
+						goto func_end;
 					pMsg = (struct MSG_FRAME *)LST_GetHead
 						(hMsgQueue->msgFreeList);
-                                       if (hMsgQueue->msgUsedList && pMsg) {
+					if (hMsgQueue->msgUsedList && pMsg) {
 						pMsg->msgData = msg;
 						LST_PutTail(hMsgQueue->
-						      msgUsedList,
-						      (struct LST_ELEM *)pMsg);
+						    msgUsedList,
+						    (struct list_head *)pMsg);
 						NTFY_Notify(hMsgQueue->hNtfy,
 							DSP_NODEMESSAGEREADY);
 						SYNC_SetEvent(hMsgQueue->
 							hSyncEvent);
 					} else {
-						/* No free frame to copy the
-						 * message into */
+						/*
+						 * No free frame to copy the
+						 * message into.
+						 */
 						DBG_Trace(DBG_LEVEL7, "NO FREE "
 							"MSG FRAMES, DISCARDING"
 							" MESSAGE\n");
@@ -1331,10 +1398,10 @@ static void InputMsg(struct IO_MGR *pIOM
 				break;
 			}
 
-                       if (!hMsgMgr->queueList || !hMsgQueue)
-                               goto func_end;
+			if (!hMsgMgr->queueList || !hMsgQueue)
+				goto func_end;
 			hMsgQueue = (struct MSG_QUEUE *)LST_Next(hMsgMgr->
-				    queueList, (struct LST_ELEM *)hMsgQueue);
+				    queueList, (struct list_head *)hMsgQueue);
 		}
 	}
 	/* Set the post SWI flag */
@@ -1347,8 +1414,7 @@ static void InputMsg(struct IO_MGR *pIOM
 		CHNLSM_InterruptDSP2(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
 	}
 func_end:
-       return;
-
+	return;
 }
 
 /*
@@ -1361,23 +1427,31 @@ static void NotifyChnlComplete(struct CH
 {
 	bool fSignalEvent;
 
-	DBC_Require(MEM_IsValidHandle(pChnl, CHNL_SIGNATURE));
-	DBC_Require(pChnl->hSyncEvent != NULL);
-	 /*  Note: we signal the channel event only if the queue of IO
-	  *  completions is empty.  If it is not empty, the event is sure to be
-	  *  signalled by the only IO completion list consumer:
-	  *  WMD_CHNL_GetIOC().  */
+	if (!MEM_IsValidHandle(pChnl, CHNL_SIGNATURE) || !pChnl->hSyncEvent ||
+	   !pChnl->pIOCompletions || !pChirp)
+		goto func_end;
+
+	/*
+	 * Note: we signal the channel event only if the queue of IO
+	 * completions is empty.  If it is not empty, the event is sure to be
+	 * signalled by the only IO completion list consumer:
+	 * WMD_CHNL_GetIOC().
+	 */
 	fSignalEvent = LST_IsEmpty(pChnl->pIOCompletions);
-	/* Enqueue the IO completion info for the client: */
-	LST_PutTail(pChnl->pIOCompletions, (struct LST_ELEM *) pChirp);
+	/* Enqueue the IO completion info for the client */
+	LST_PutTail(pChnl->pIOCompletions, (struct list_head *)pChirp);
 	pChnl->cIOCs++;
-	DBC_Assert(pChnl->cIOCs <= pChnl->cChirps);
-	/* Signal the channel event (if not already set) that IO is complete: */
+
+	if (pChnl->cIOCs > pChnl->cChirps)
+		goto func_end;
+	/* Signal the channel event (if not already set) that IO is complete */
 	if (fSignalEvent)
 		SYNC_SetEvent(pChnl->hSyncEvent);
 
 	/* Notify that IO is complete */
 	NTFY_Notify(pChnl->hNtfy, DSP_STREAMIOCOMPLETION);
+func_end:
+	return;
 }
 
 /*
@@ -1397,14 +1471,14 @@ static void OutputChnl(struct IO_MGR *pI
 	pChnlMgr = pIOMgr->hChnlMgr;
 	sm = pIOMgr->pSharedMem;
 	DBG_Trace(DBG_LEVEL3, "> OutputChnl\n");
-	/* Attempt to perform output: */
+	/* Attempt to perform output */
 	if (IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm, outputFull))
 		goto func_end;
 
 	if (pChnl && !((pChnl->dwState & ~CHNL_STATEEOS) == CHNL_STATEREADY))
 		goto func_end;
 
-	/* Look to see if both a PC and DSP output channel are ready: */
+	/* Look to see if both a PC and DSP output channel are ready */
 	dwDspFMask = IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm,
 				 dspFreeMask);
 	chnlId = FindReadyOutput(pChnlMgr, pChnl, (pChnlMgr->dwOutputMask &
@@ -1413,24 +1487,24 @@ static void OutputChnl(struct IO_MGR *pI
 		goto func_end;
 
 	pChnl = pChnlMgr->apChannel[chnlId];
-       if (!pChnl || !pChnl->pIORequests) {
-		/* Shouldn't get here: */
+	if (!pChnl || !pChnl->pIORequests) {
+		/* Shouldn't get here */
 		goto func_end;
 	}
-	/* Get the I/O request, and attempt a transfer:  */
+	/* Get the I/O request, and attempt a transfer */
 	pChirp = (struct CHNL_IRP *)LST_GetHead(pChnl->pIORequests);
 	if (!pChirp)
 		goto func_end;
 
 	pChnl->cIOReqs--;
-       if (pChnl->cIOReqs < 0 || !pChnl->pIORequests)
-               goto func_end;
+	if (pChnl->cIOReqs < 0 || !pChnl->pIORequests)
+		goto func_end;
 
-	/* Record fact that no more I/O buffers available:  */
+	/* Record fact that no more I/O buffers available */
 	if (LST_IsEmpty(pChnl->pIORequests))
 		pChnlMgr->dwOutputMask &= ~(1 << chnlId);
 
-	/* Transfer buffer to DSP side: */
+	/* Transfer buffer to DSP side */
 	pChirp->cBytes = WriteData(pIOMgr->hWmdContext, pIOMgr->pOutput,
 			pChirp->pHostSysBuf, min(pIOMgr->uSMBufSize, pChirp->
 			cBytes));
@@ -1450,7 +1524,7 @@ static void OutputChnl(struct IO_MGR *pI
 		   uWordSize);
 #endif
 	IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, outputFull, 1);
-	/* Indicate to the DSP we have written the output: */
+	/* Indicate to the DSP we have written the output */
 	CHNLSM_InterruptDSP2(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
 	/* Notify client with IO completion record (keep EOS) */
 	pChirp->status &= CHNL_IOCSTATEOS;
@@ -1488,13 +1562,14 @@ static void OutputMsg(struct IO_MGR *pIO
 		pMsgOutput = pIOMgr->pMsgOutput;
 		/* Copy uMsgs messages into shared memory */
 		for (i = 0; i < uMsgs; i++) {
-                       if (!hMsgMgr->msgUsedList) {
-                               DBG_Trace(DBG_LEVEL3, "msgUsedList is NULL\n");
-                               pMsg = NULL;
-                               goto func_end;
-                       } else
-                               pMsg = (struct MSG_FRAME *)LST_GetHead(
-                                       hMsgMgr->msgUsedList);
+			if (!hMsgMgr->msgUsedList) {
+				DBG_Trace(DBG_LEVEL3, "msgUsedList is NULL\n");
+				pMsg = NULL;
+				goto func_end;
+			} else {
+				pMsg = (struct MSG_FRAME *)LST_GetHead(
+					hMsgMgr->msgUsedList);
+			}
 			if (pMsg != NULL) {
 				val = (pMsg->msgData).dwId;
 				addr = (u32)&(((struct MSG_DSPMSG *)
@@ -1519,10 +1594,10 @@ static void OutputMsg(struct IO_MGR *pIO
 				WriteExt32BitDspData(pIOMgr->hWmdContext, addr,
 						    val);
 				pMsgOutput += sizeof(struct MSG_DSPMSG);
-                               if (!hMsgMgr->msgFreeList)
-                                       goto func_end;
+				if (!hMsgMgr->msgFreeList)
+					goto func_end;
 				LST_PutTail(hMsgMgr->msgFreeList,
-					   (struct LST_ELEM *) pMsg);
+					   (struct list_head *)pMsg);
 				SYNC_SetEvent(hMsgMgr->hSyncEvent);
 			} else {
 				DBG_Trace(DBG_LEVEL3, "pMsg is NULL\n");
@@ -1544,12 +1619,12 @@ static void OutputMsg(struct IO_MGR *pIO
 			IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
 				   postSWI, true);
 			/* Tell the DSP we have written the output. */
-			CHNLSM_InterruptDSP2(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
+			CHNLSM_InterruptDSP2(pIOMgr->hWmdContext,
+						MBX_PCPY_CLASS);
 		}
 	}
 func_end:
-       return;
-
+	return;
 }
 
 /*
@@ -1571,25 +1646,36 @@ static DSP_STATUS registerSHMSegs(struct
 	u32 ulShmSegId0 = 0;
 	u32 dwOffset, dwGPPBaseVA, ulDSPSize;
 
-	/* Read address and size info for first SM region.*/
-	/* Get start of 1st SM Heap region */
+	/*
+	 * Read address and size info for first SM region.
+	 * Get start of 1st SM Heap region.
+	 */
 	status = COD_GetSymValue(hCodMan, SHM0_SHARED_BASE_SYM, &ulShm0_Base);
-	DBC_Assert(ulShm0_Base != 0);
+	if (ulShm0_Base == 0) {
+		status = DSP_EFAIL;
+		goto func_end;
+	}
 	/* Get end of 1st SM Heap region */
 	if (DSP_SUCCEEDED(status)) {
 		/* Get start and length of message part of shared memory */
 		status = COD_GetSymValue(hCodMan, SHM0_SHARED_END_SYM,
 					 &ulShm0_End);
-		DBC_Assert(ulShm0_End != 0);
+		if (ulShm0_End == 0) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
 	}
-	/* start of Gpp reserved region */
+	/* Start of Gpp reserved region */
 	if (DSP_SUCCEEDED(status)) {
 		/* Get start and length of message part of shared memory */
 		status = COD_GetSymValue(hCodMan, SHM0_SHARED_RESERVED_BASE_SYM,
 					&ulShm0_RsrvdStart);
 		DBG_Trace(DBG_LEVEL1, "***ulShm0_RsrvdStart  0x%x \n",
 			 ulShm0_RsrvdStart);
-		DBC_Assert(ulShm0_RsrvdStart != 0);
+		if (ulShm0_RsrvdStart == 0) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
 	}
 	/* Register with CMM */
 	if (DSP_SUCCEEDED(status)) {
@@ -1608,36 +1694,51 @@ static DSP_STATUS registerSHMSegs(struct
 	}
 	/* Register new SM region(s) */
 	if (DSP_SUCCEEDED(status) && (ulShm0_End - ulShm0_Base) > 0) {
-		/* calc size (bytes) of SM the GPP can alloc from */
+		/* Calc size (bytes) of SM the GPP can alloc from */
 		ulRsrvdSize = (ulShm0_End - ulShm0_RsrvdStart + 1) * hIOMgr->
 			      uWordSize;
-		DBC_Assert(ulRsrvdSize > 0);
-		/* calc size of SM DSP can alloc from */
+		if (ulRsrvdSize <= 0) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
+		/* Calc size of SM DSP can alloc from */
 		ulDSPSize = (ulShm0_RsrvdStart - ulShm0_Base) * hIOMgr->
 			uWordSize;
-		DBC_Assert(ulDSPSize > 0);
-		/*  First TLB entry reserved for Bridge SM use.*/
+		if (ulDSPSize <= 0) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
+		/* First TLB entry reserved for Bridge SM use.*/
 		ulGppPhys = hIOMgr->extProcInfo.tyTlb[0].ulGppPhys;
-		/* get size in bytes */
+		/* Get size in bytes */
 		ulDspVirt = hIOMgr->extProcInfo.tyTlb[0].ulDspVirt * hIOMgr->
 			uWordSize;
-		 /* Calc byte offset used to convert GPP phys <-> DSP byte
-		  * address.*/
+		/*
+		 * Calc byte offset used to convert GPP phys <-> DSP byte
+		 * address.
+		 */
 		if (dwGPPBasePA > ulDspVirt)
 			dwOffset = dwGPPBasePA - ulDspVirt;
 		else
 			dwOffset = ulDspVirt - dwGPPBasePA;
 
-		DBC_Assert(ulShm0_RsrvdStart * hIOMgr->uWordSize >= ulDspVirt);
-		/* calc Gpp phys base of SM region */
-		/* Linux - this is actually uncached kernel virtual address*/
+		if (ulShm0_RsrvdStart * hIOMgr->uWordSize < ulDspVirt) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
+		/*
+		 * Calc Gpp phys base of SM region.
+		 * This is actually uncached kernel virtual address.
+		 */
 		dwGPPBaseVA = ulGppPhys + ulShm0_RsrvdStart * hIOMgr->uWordSize
 				- ulDspVirt;
-		/* calc Gpp phys base of SM region */
-		/* Linux - this is the physical address*/
+		/*
+		 * Calc Gpp phys base of SM region.
+		 * This is the physical address.
+		 */
 		dwGPPBasePA = dwGPPBasePA + ulShm0_RsrvdStart * hIOMgr->
 			      uWordSize - ulDspVirt;
-		 /* Register SM Segment 0.*/
+		/* Register SM Segment 0.*/
 		status = CMM_RegisterGPPSMSeg(hIOMgr->hCmmMgr, dwGPPBasePA,
 			 ulRsrvdSize, dwOffset, (dwGPPBasePA > ulDspVirt) ?
 			 CMM_ADDTODSPPA : CMM_SUBFROMDSPPA,
@@ -1647,9 +1748,11 @@ static DSP_STATUS registerSHMSegs(struct
 			DBG_Trace(DBG_LEVEL7, "ERROR - Failed to register SM "
 				 "Seg 0 \n");
 		}
-		/* first SM region is segId = 1 */
-		DBC_Assert(ulShmSegId0 == 1);
+		/* First SM region is segId = 1 */
+		if (ulShmSegId0 != 1)
+			status = DSP_EFAIL;
 	}
+func_end:
 	return status;
 }
 
@@ -1669,7 +1772,7 @@ static u32 ReadData(struct WMD_DEV_CONTE
  *      Copies buffers from the host side buffer to the shared memory.
  */
 static u32 WriteData(struct WMD_DEV_CONTEXT *hDevContext, void *pDest,
-		       void *pSrc, u32 uSize)
+			void *pSrc, u32 uSize)
 {
 	memcpy(pDest, pSrc, uSize);
 	return uSize;
@@ -1685,8 +1788,7 @@ void IO_IntrDSP2(IN struct IO_MGR *pIOMg
  *  ======== IO_SHMcontrol ========
  *      Sets the requested SHM setting.
  */
-DSP_STATUS IO_SHMsetting(IN struct IO_MGR *hIOMgr, IN enum SHM_DESCTYPE desc,
-			 IN void *pArgs)
+DSP_STATUS IO_SHMsetting(struct IO_MGR *hIOMgr, u8 desc, void *pArgs)
 {
 #ifdef CONFIG_BRIDGE_DVFS
 	u32 i;
@@ -1703,8 +1805,10 @@ DSP_STATUS IO_SHMsetting(IN struct IO_MG
 			return DSP_EFAIL;
 		break;
 	case SHM_OPPINFO:
-		/* Update the shared memory with the voltage, frequency,
-				   min and max frequency values for an OPP */
+		/*
+		 * Update the shared memory with the voltage, frequency,
+		 * min and max frequency values for an OPP.
+		 */
 		for (i = 0; i <= dsp_max_opps; i++) {
 			hIOMgr->pSharedMem->oppTableStruct.oppPoint[i].voltage =
 				vdd1_dsp_freq[i][0];
@@ -1772,7 +1876,7 @@ void PrintDSPDebugTrace(struct IO_MGR *h
 {
 	u32 ulNewMessageLength = 0, ulGPPCurPointer;
 
-       GT_0trace(dsp_trace_mask, GT_ENTER, "Entering PrintDSPDebugTrace\n");
+	GT_0trace(dsp_trace_mask, GT_ENTER, "Entering PrintDSPDebugTrace\n");
 
 	while (true) {
 		/* Get the DSP current pointer */
@@ -1781,25 +1885,25 @@ void PrintDSPDebugTrace(struct IO_MGR *h
 				  hIOMgr->ulDspVa);
 
 		/* No new debug messages available yet */
-		if (ulGPPCurPointer == hIOMgr->ulGPPReadPointer)
+		if (ulGPPCurPointer == hIOMgr->ulGPPReadPointer) {
 			break;
-
-		/* Continuous data */
-		else if (ulGPPCurPointer > hIOMgr->ulGPPReadPointer) {
+		} else if (ulGPPCurPointer > hIOMgr->ulGPPReadPointer) {
+			/* Continuous data */
 			ulNewMessageLength = ulGPPCurPointer - hIOMgr->
 					     ulGPPReadPointer;
 
 			memcpy(hIOMgr->pMsg, (char *)hIOMgr->ulGPPReadPointer,
-			       ulNewMessageLength);
+				ulNewMessageLength);
 			hIOMgr->pMsg[ulNewMessageLength] = '\0';
-			/* Advance the GPP trace pointer to DSP current
-			 * pointer */
+			/*
+			 * Advance the GPP trace pointer to DSP current
+			 * pointer.
+			 */
 			hIOMgr->ulGPPReadPointer += ulNewMessageLength;
 			/* Print the trace messages */
-                       GT_0trace(dsp_trace_mask, GT_1CLASS, hIOMgr->pMsg);
-		}
+			pr_info("DSPTrace:%s", hIOMgr->pMsg);
+		} else if (ulGPPCurPointer < hIOMgr->ulGPPReadPointer) {
 		/* Handle trace buffer wraparound */
-		else if (ulGPPCurPointer < hIOMgr->ulGPPReadPointer) {
 			memcpy(hIOMgr->pMsg, (char *)hIOMgr->ulGPPReadPointer,
 				hIOMgr->ulTraceBufferEnd -
 				hIOMgr->ulGPPReadPointer);
@@ -1812,12 +1916,14 @@ void PrintDSPDebugTrace(struct IO_MGR *h
 			hIOMgr->pMsg[hIOMgr->ulTraceBufferEnd -
 				hIOMgr->ulGPPReadPointer +
 				ulNewMessageLength] = '\0';
-			/* Advance the GPP trace pointer to DSP current
-			 * pointer */
+			/*
+			 * Advance the GPP trace pointer to DSP current
+			 * pointer.
+			 */
 			hIOMgr->ulGPPReadPointer = hIOMgr->ulTraceBufferBegin +
 						   ulNewMessageLength;
 			/* Print the trace messages */
-                       GT_0trace(dsp_trace_mask, GT_1CLASS, hIOMgr->pMsg);
+			pr_info("DSPTrace:%s", hIOMgr->pMsg);
 		}
 	}
 }
@@ -1842,53 +1948,55 @@ void PrintDSPDebugTrace(struct IO_MGR *h
  *      There are no more than ulNumWords extra characters needed (the number of
  *      linefeeds minus the number of NULLS in the input buffer).
  */
-#if (defined(DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE
+#if (defined(CONFIG_BRIDGE_DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE
 static DSP_STATUS PackTraceBuffer(char *lpBuf, u32 nBytes, u32 ulNumWords)
 {
-       DSP_STATUS status = DSP_SOK;
-       char *lpTmpBuf;
-       char *lpBufStart;
-       char *lpTmpStart;
-       u32 nCnt;
-       char thisChar;
-
-       /* tmp workspace, 1 KB longer than input buf */
-       lpTmpBuf = MEM_Calloc((nBytes + ulNumWords), MEM_PAGED);
-       if (lpTmpBuf == NULL) {
-               DBG_Trace(DBG_LEVEL7, "PackTrace buffer:OutofMemory \n");
-               status = DSP_EMEMORY;
-       }
-
-       if (DSP_SUCCEEDED(status)) {
-               lpBufStart = lpBuf;
-               lpTmpStart = lpTmpBuf;
-               for (nCnt = nBytes; nCnt > 0; nCnt--) {
-                       thisChar = *lpBuf++;
-                       switch (thisChar) {
-                       case '\0':      /* Skip null bytes */
-                       break;
-                       case '\n':      /* Convert \n to \r\n */
-                       /* NOTE: do not reverse order; Some OS */
-                       /* editors control doesn't understand "\n\r" */
-                       *lpTmpBuf++ = '\r';
-                       *lpTmpBuf++ = '\n';
-                       break;
-                       default:        /* Copy in the actual ascii byte */
-                       *lpTmpBuf++ = thisChar;
-                       break;
-                       }
-               }
-               *lpTmpBuf = '\0';    /* Make sure tmp buf is null terminated */
-               /* Cut output down to input buf size */
-               strncpy(lpBufStart, lpTmpStart, nBytes);
-               /*Make sure output is null terminated */
-               lpBufStart[nBytes - 1] = '\0';
-               MEM_Free(lpTmpStart);
-       }
+	DSP_STATUS status = DSP_SOK;
+	char *lpTmpBuf;
+	char *lpBufStart;
+	char *lpTmpStart;
+	u32 nCnt;
+	char thisChar;
+
+	/* Tmp workspace, 1 KB longer than input buf */
+	lpTmpBuf = MEM_Calloc((nBytes + ulNumWords), MEM_PAGED);
+	if (lpTmpBuf == NULL) {
+		DBG_Trace(DBG_LEVEL7, "PackTrace buffer:OutofMemory \n");
+		status = DSP_EMEMORY;
+	}
 
-       return status;
+	if (DSP_SUCCEEDED(status)) {
+		lpBufStart = lpBuf;
+		lpTmpStart = lpTmpBuf;
+		for (nCnt = nBytes; nCnt > 0; nCnt--) {
+			thisChar = *lpBuf++;
+			switch (thisChar) {
+			case '\0':      /* Skip null bytes */
+				break;
+			case '\n':      /* Convert \n to \r\n */
+				/*
+				 * NOTE: do not reverse order; Some OS
+				 * editors control doesn't understand "\n\r"
+				 */
+				*lpTmpBuf++ = '\r';
+				*lpTmpBuf++ = '\n';
+				break;
+			default:	 /* Copy in the actual ascii byte */
+				*lpTmpBuf++ = thisChar;
+				break;
+			}
+		}
+		*lpTmpBuf = '\0';    /* Make sure tmp buf is null terminated */
+		/* Cut output down to input buf size */
+		strncpy(lpBufStart, lpTmpStart, nBytes);
+		/* Make sure output is null terminated */
+		lpBufStart[nBytes - 1] = '\0';
+		MEM_Free(lpTmpStart);
+	}
+
+	return status;
 }
-#endif    /* (defined(DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE */
+#endif    /* (defined(CONFIG_BRIDGE_DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE */
 
 /*
  *  ======== PrintDspTraceBuffer ========
@@ -1904,106 +2012,106 @@ static DSP_STATUS PackTraceBuffer(char *
  */
 DSP_STATUS PrintDspTraceBuffer(struct WMD_DEV_CONTEXT *hWmdContext)
 {
-       DSP_STATUS status = DSP_SOK;
+	DSP_STATUS status = DSP_SOK;
+
+#if (defined(CONFIG_BRIDGE_DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE
+	struct COD_MANAGER *hCodMgr;
+	u32 ulTraceEnd;
+	u32 ulTraceBegin;
+	u32 ulNumBytes = 0;
+	u32 ulNumWords = 0;
+	u32 ulWordSize = 2;
+	CONST u32 uMaxSize = 512;
+	char *pszBuf;
+	u16 *lpszBuf;
+
+	struct WMD_DEV_CONTEXT *pWmdContext = (struct WMD_DEV_CONTEXT *)
+						     hWmdContext;
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)
+					    pWmdContext->hDevObject;
+
+	status = DEV_GetCodMgr(pDevObject, &hCodMgr);
+	if (DSP_FAILED(status))
+		GT_0trace(dsp_trace_mask, GT_2CLASS,
+			"PrintDspTraceBuffer: Failed on DEV_GetCodMgr.\n");
+
+	if (DSP_SUCCEEDED(status)) {
+		/* Look for SYS_PUTCBEG/SYS_PUTCEND */
+		status = COD_GetSymValue(hCodMgr, COD_TRACEBEG, &ulTraceBegin);
+		GT_1trace(dsp_trace_mask, GT_2CLASS,
+			"PrintDspTraceBuffer: ulTraceBegin Value 0x%x\n",
+			ulTraceBegin);
+		if (DSP_FAILED(status))
+			GT_0trace(dsp_trace_mask, GT_2CLASS,
+				"PrintDspTraceBuffer: Failed on "
+				"COD_GetSymValue.\n");
+	}
+	if (DSP_SUCCEEDED(status)) {
+		status = COD_GetSymValue(hCodMgr, COD_TRACEEND, &ulTraceEnd);
+		GT_1trace(dsp_trace_mask, GT_2CLASS,
+			"PrintDspTraceBuffer: ulTraceEnd Value 0x%x\n",
+			ulTraceEnd);
+		 if (DSP_FAILED(status))
+			GT_0trace(dsp_trace_mask, GT_2CLASS,
+				"PrintDspTraceBuffer: Failed on "
+				"COD_GetSymValue.\n");
+	}
+	if (DSP_SUCCEEDED(status)) {
+		ulNumBytes = (ulTraceEnd - ulTraceBegin) * ulWordSize;
+		/*
+		 * If the chip type is 55 then the addresses will be
+		 * byte addresses; convert them to word addresses.
+		 */
+		if (ulNumBytes > uMaxSize)
+			ulNumBytes = uMaxSize;
+
+		/* Make sure the data we request fits evenly */
+		ulNumBytes = (ulNumBytes / ulWordSize) * ulWordSize;
+		GT_1trace(dsp_trace_mask, GT_2CLASS, "PrintDspTraceBuffer: "
+			"ulNumBytes 0x%x\n", ulNumBytes);
+		ulNumWords = ulNumBytes * ulWordSize;
+		GT_1trace(dsp_trace_mask, GT_2CLASS, "PrintDspTraceBuffer: "
+			"ulNumWords 0x%x\n", ulNumWords);
+		status = DEV_GetIntfFxns(pDevObject, &pIntfFxns);
+	}
 
-#if (defined(DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE
-       struct COD_MANAGER *hCodMgr;
-       u32 ulTraceEnd;
-       u32 ulTraceBegin;
-       u32 ulNumBytes = 0;
-       u32 ulNumWords = 0;
-       u32 ulWordSize = 2;
-       CONST u32 uMaxSize = 512;
-       char *pszBuf;
-       u16 *lpszBuf;
-
-       struct WMD_DEV_CONTEXT *pWmdContext = (struct WMD_DEV_CONTEXT *)
-                                               hWmdContext;
-       struct WMD_DRV_INTERFACE *pIntfFxns;
-       struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)
-                                       pWmdContext->hDevObject;
-
-       status = DEV_GetCodMgr(pDevObject, &hCodMgr);
-       if (DSP_FAILED(status))
-               GT_0trace(dsp_trace_mask, GT_2CLASS,
-               "PrintDspTraceBuffer: Failed on DEV_GetCodMgr.\n");
-
-       if (DSP_SUCCEEDED(status)) {
-               /* Look for SYS_PUTCBEG/SYS_PUTCEND: */
-               status = COD_GetSymValue(hCodMgr, COD_TRACEBEG, &ulTraceBegin);
-               GT_1trace(dsp_trace_mask, GT_2CLASS,
-                       "PrintDspTraceBuffer: ulTraceBegin Value 0x%x\n",
-                       ulTraceBegin);
-               if (DSP_FAILED(status))
-                       GT_0trace(dsp_trace_mask, GT_2CLASS,
-                               "PrintDspTraceBuffer: Failed on "
-                               "COD_GetSymValue.\n");
-       }
-       if (DSP_SUCCEEDED(status)) {
-               status = COD_GetSymValue(hCodMgr, COD_TRACEEND, &ulTraceEnd);
-               GT_1trace(dsp_trace_mask, GT_2CLASS,
-                       "PrintDspTraceBuffer: ulTraceEnd Value 0x%x\n",
-                       ulTraceEnd);
-               if (DSP_FAILED(status))
-                       GT_0trace(dsp_trace_mask, GT_2CLASS,
-                               "PrintDspTraceBuffer: Failed on "
-                               "COD_GetSymValue.\n");
-       }
-       if (DSP_SUCCEEDED(status)) {
-               ulNumBytes = (ulTraceEnd - ulTraceBegin) * ulWordSize;
-               /*  If the chip type is 55 then the addresses will be
-               *  byte addresses; convert them to word addresses.  */
-               if (ulNumBytes > uMaxSize)
-                       ulNumBytes = uMaxSize;
-
-               /* make sure the data we request fits evenly */
-               ulNumBytes = (ulNumBytes / ulWordSize) * ulWordSize;
-               GT_1trace(dsp_trace_mask, GT_2CLASS, "PrintDspTraceBuffer: "
-                       "ulNumBytes 0x%x\n", ulNumBytes);
-               ulNumWords = ulNumBytes * ulWordSize;
-               GT_1trace(dsp_trace_mask, GT_2CLASS, "PrintDspTraceBuffer: "
-                       "ulNumWords 0x%x\n", ulNumWords);
-               status = DEV_GetIntfFxns(pDevObject, &pIntfFxns);
-       }
-
-       if (DSP_SUCCEEDED(status)) {
-               pszBuf = MEM_Calloc(uMaxSize, MEM_NONPAGED);
-               lpszBuf = MEM_Calloc(ulNumBytes * 2, MEM_NONPAGED);
-               if (pszBuf != NULL) {
-                       /* Read bytes from the DSP trace buffer... */
-                       status = (*pIntfFxns->pfnBrdRead)(hWmdContext,
-                               (u8 *)pszBuf, (u32)ulTraceBegin,
-                               ulNumBytes, 0);
-                       if (DSP_FAILED(status))
-                               GT_0trace(dsp_trace_mask, GT_2CLASS,
-                                       "PrintDspTraceBuffer: "
-                                       "Failed to Read Trace Buffer.\n");
-
-                       if (DSP_SUCCEEDED(status)) {
-                               /* Pack and do newline conversion */
-                               GT_0trace(dsp_trace_mask, GT_2CLASS,
-                                       "PrintDspTraceBuffer: "
-                                       "before pack and unpack.\n");
-                               PackTraceBuffer(pszBuf, ulNumBytes, ulNumWords);
-                               GT_1trace(dsp_trace_mask, GT_1CLASS,
-                                       "DSP Trace Buffer:\n%s\n", pszBuf);
-                       }
-                       MEM_Free(pszBuf);
-                       MEM_Free(lpszBuf);
-               } else {
-                       GT_0trace(dsp_trace_mask, GT_2CLASS,
-                               "PrintDspTraceBuffer: Failed to "
-                               "allocate trace buffer.\n");
-                       status = DSP_EMEMORY;
-               }
-       }
+	if (DSP_SUCCEEDED(status)) {
+		pszBuf = MEM_Calloc(uMaxSize, MEM_NONPAGED);
+		lpszBuf = MEM_Calloc(ulNumBytes * 2, MEM_NONPAGED);
+		if (pszBuf != NULL) {
+			/* Read bytes from the DSP trace buffer... */
+			status = (*pIntfFxns->pfnBrdRead)(hWmdContext,
+				(u8 *)pszBuf, (u32)ulTraceBegin,
+				ulNumBytes, 0);
+			if (DSP_FAILED(status))
+				GT_0trace(dsp_trace_mask, GT_2CLASS,
+					"PrintDspTraceBuffer: "
+					"Failed to Read Trace Buffer.\n");
+
+			if (DSP_SUCCEEDED(status)) {
+				/* Pack and do newline conversion */
+				GT_0trace(dsp_trace_mask, GT_2CLASS,
+					"PrintDspTraceBuffer: "
+					"before pack and unpack.\n");
+				PackTraceBuffer(pszBuf, ulNumBytes, ulNumWords);
+				GT_1trace(dsp_trace_mask, GT_1CLASS,
+					"DSP Trace Buffer:\n%s\n", pszBuf);
+			}
+			MEM_Free(pszBuf);
+			MEM_Free(lpszBuf);
+		} else {
+			  GT_0trace(dsp_trace_mask, GT_2CLASS,
+				"PrintDspTraceBuffer: Failed to "
+				"allocate trace buffer.\n");
+			  status = DSP_EMEMORY;
+		}
+	}
 #endif
-       return status;
+	return status;
 }
 
 void IO_SM_init(void)
 {
-
-       GT_create(&dsp_trace_mask, "DT"); /* DSP Trace Mask */
-
+	GT_create(&dsp_trace_mask, "DT"); /* DSP Trace Mask */
 }
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/mmu_fault.c kernel-power-2.6.28/drivers/dsp/bridge/wmd/mmu_fault.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/mmu_fault.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/mmu_fault.c	2011-05-02 22:36:51.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implements DSP MMU fault handling functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,23 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== mmu_fault.c ========
- *  Description:
- *      Implements DSP MMU fault handling functions.
- *
- *! Revision History:
- *! ================
- *! 26-Dec-2004 hn: Support for IVA MMU exception.
- *! 06-Mar-2003 sb: Print MMU fault address. Cosmetic changes.
- *! 16-Feb-2003 vp: Fixed warning in MMU_FaultIsr
- *! 05-Jan-2004 vp: Updated support for 24xx silicon
- *! 19-Feb-2003 vp: Code review updates.
- *!                 - Cosmetic changes.
- *! 18-Oct-2002 sb: Ported to Linux platform.
- *! 10-Sep-2001 kc: created.
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
@@ -42,7 +27,6 @@
 #include <dspbridge/dbg.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/dpc.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/drv.h>
 
@@ -69,14 +53,13 @@ static bool MMU_CheckIfFault(struct WMD_
  *  ======== MMU_FaultDpc ========
  *      Deferred procedure call to handle DSP MMU fault.
  */
-void MMU_FaultDpc(IN void *pRefData)
+void MMU_FaultDpc(IN unsigned long pRefData)
 {
 	struct DEH_MGR *hDehMgr = (struct DEH_MGR *)pRefData;
-	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)hDehMgr;
 
 	DBG_Trace(DBG_LEVEL1, "MMU_FaultDpc Enter: 0x%x\n", pRefData);
 
-	if (pDehMgr)
+	if (hDehMgr)
 		WMD_DEH_Notify(hDehMgr, DSP_MMUFAULT, 0L);
 
 	DBG_Trace(DBG_LEVEL1, "MMU_FaultDpc Exit: 0x%x\n", pRefData);
@@ -93,9 +76,8 @@ irqreturn_t  MMU_FaultIsr(int irq, IN vo
 	struct CFG_HOSTRES resources;
 	DSP_STATUS status = DSP_SOK;
 
-
 	DBG_Trace(DBG_LEVEL1, "Entering DEH_DspMmuIsr: 0x%x\n", pRefData);
-       DBC_Require(irq == INT_DSP_MMU_IRQ);
+	DBC_Require(irq == INT_DSP_MMU_IRQ);
 	DBC_Require(MEM_IsValidHandle(pDehMgr, SIGNATURE));
 
 	if (MEM_IsValidHandle(pDehMgr, SIGNATURE)) {
@@ -113,14 +95,13 @@ irqreturn_t  MMU_FaultIsr(int irq, IN vo
 				"0x%x\n", dmmuEventMask);
 			printk(KERN_INFO "***** DSPMMU FAULT ***** faultAddr "
 				"0x%x\n", faultAddr);
-			/* Disable the MMU events, else once we clear it will
-			 * start to raise INTs again */
 			/*
 			 * Schedule a DPC directly. In the future, it may be
 			 * necessary to check if DSP MMU fault is intended for
 			 * Bridge.
 			 */
-			DPC_Schedule(pDehMgr->hMmuFaultDpc);
+			tasklet_schedule(&pDehMgr->dpc_tasklet);
+
 			/* Reset errInfo structure before use. */
 			pDehMgr->errInfo.dwErrMask = DSP_MMUFAULT;
 			pDehMgr->errInfo.dwVal1 = faultAddr >> 16;
@@ -138,7 +119,7 @@ irqreturn_t  MMU_FaultIsr(int irq, IN vo
 					    HW_MMU_ALL_INTERRUPTS);
 		}
 	}
-       return IRQ_HANDLED;
+	return IRQ_HANDLED;
 }
 
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/mmu_fault.h kernel-power-2.6.28/drivers/dsp/bridge/wmd/mmu_fault.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/mmu_fault.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/mmu_fault.h	2011-05-02 22:36:51.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Defines DSP MMU fault handling functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,18 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== mmu_fault.h ========
- *  Description:
- *      Defines DSP MMU fault handling functions.
- *
- *! Revision History:
- *! ================
- *! 26-Dec-2004 hn: IVA MMU handlers.
- *! 10-Sep-2001 kc: created.
- */
-
 #ifndef MMU_FAULT_
 #define MMU_FAULT_
 
@@ -33,7 +23,7 @@
  *  ======== MMU_FaultDpc ========
  *      Deferred procedure call to handle DSP MMU fault.
  */
-	void MMU_FaultDpc(IN void *pRefData);
+	void MMU_FaultDpc(IN unsigned long pRefData);
 
 /*
  *  ======== MMU_FaultIsr ========
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/msg_sm.c kernel-power-2.6.28/drivers/dsp/bridge/wmd/msg_sm.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/msg_sm.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/msg_sm.c	2011-05-02 22:36:51.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implements upper edge functions for WMD message module.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,34 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== msg_sm.c ========
- *  Description:
- *      Implements upper edge functions for WMD message module.
- *
- *  Public Functions:
- *      WMD_MSG_Create
- *      WMD_MSG_CreateQueue
- *      WMD_MSG_Delete
- *      WMD_MSG_DeleteQueue
- *      WMD_MSG_Get
- *      WMD_MSG_Put
- *      WMD_MSG_RegisterNotify
- *      WMD_MSG_SetQueueId
- *
- *! Revision History:
- *! =================
- *! 24-Jul-2002 jeh     Release critical section in WMD_MSG_Put() before
- *!                     scheduling DPC.
- *! 09-May-2001 jeh     Free MSG queue NTFY object, remove unnecessary set/
- *!                     reset of events.
- *! 10-Jan-2001 jeh     Set/Reset message manager and message queue events
- *!                     correctly.
- *! 04-Dec-2000 jeh     Bug fixes.
- *! 12-Sep-2000 jeh     Created.
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
@@ -86,11 +60,15 @@ DSP_STATUS WMD_MSG_Create(OUT struct MSG
 	struct IO_MGR *hIOMgr;
 	DSP_STATUS status = DSP_SOK;
 
-	DBC_Require(phMsgMgr != NULL);
-	DBC_Require(msgCallback != NULL);
-	DBC_Require(hDevObject != NULL);
+	if (!phMsgMgr || !msgCallback || !hDevObject) {
+		status = DSP_EPOINTER;
+		goto func_end;
+	}
 	DEV_GetIOMgr(hDevObject, &hIOMgr);
-	DBC_Assert(hIOMgr != NULL);
+	if (!hIOMgr) {
+		status = DSP_EPOINTER;
+		goto func_end;
+	}
 	*phMsgMgr = NULL;
 	/* Allocate MSG manager object */
 	MEM_AllocObject(pMsgMgr, struct MSG_MGR, MSGMGR_SIGNATURE);
@@ -99,18 +77,25 @@ DSP_STATUS WMD_MSG_Create(OUT struct MSG
 		pMsgMgr->onExit = msgCallback;
 		pMsgMgr->hIOMgr = hIOMgr;
 		/* List of MSG_QUEUEs */
-		pMsgMgr->queueList = LST_Create();
+		pMsgMgr->queueList = MEM_Calloc(sizeof(struct LST_LIST),
+			MEM_NONPAGED);
 		 /*  Queues of message frames for messages to the DSP. Message
 		  * frames will only be added to the free queue when a
 		  * MSG_QUEUE object is created.  */
-		pMsgMgr->msgFreeList = LST_Create();
-		pMsgMgr->msgUsedList = LST_Create();
+		pMsgMgr->msgFreeList = MEM_Calloc(sizeof(struct LST_LIST),
+					MEM_NONPAGED);
+		pMsgMgr->msgUsedList = MEM_Calloc(sizeof(struct LST_LIST),
+					MEM_NONPAGED);
 		if (pMsgMgr->queueList == NULL ||
 		    pMsgMgr->msgFreeList == NULL ||
-		    pMsgMgr->msgUsedList == NULL)
+		    pMsgMgr->msgUsedList == NULL) {
 			status = DSP_EMEMORY;
-		if (DSP_SUCCEEDED(status))
+		} else {
+			INIT_LIST_HEAD(&pMsgMgr->queueList->head);
+			INIT_LIST_HEAD(&pMsgMgr->msgFreeList->head);
+			INIT_LIST_HEAD(&pMsgMgr->msgUsedList->head);
 			status = SYNC_InitializeDPCCS(&pMsgMgr->hSyncCS);
+		}
 
 		 /*  Create an event to be used by WMD_MSG_Put() in waiting
 		 *  for an available free frame from the message manager.  */
@@ -125,6 +110,7 @@ DSP_STATUS WMD_MSG_Create(OUT struct MSG
 	} else {
 		status = DSP_EMEMORY;
 	}
+func_end:
 	return status;
 }
 
@@ -142,8 +128,11 @@ DSP_STATUS WMD_MSG_CreateQueue(struct MS
 	struct MSG_QUEUE *pMsgQ;
 	DSP_STATUS status = DSP_SOK;
 
-	DBC_Require(MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE));
-	DBC_Require(phMsgQueue != NULL);
+	if (!MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE) ||
+	   phMsgQueue == NULL || !hMsgMgr->msgFreeList) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 
 	*phMsgQueue = NULL;
 	/* Allocate MSG_QUEUE object */
@@ -152,16 +141,20 @@ DSP_STATUS WMD_MSG_CreateQueue(struct MS
 		status = DSP_EMEMORY;
 		goto func_end;
 	}
-	LST_InitElem((struct LST_ELEM *) pMsgQ);
+	LST_InitElem((struct list_head *)pMsgQ);
 	pMsgQ->uMaxMsgs = uMaxMsgs;
 	pMsgQ->hMsgMgr = hMsgMgr;
 	pMsgQ->hArg = hArg;	/* Node handle */
 	pMsgQ->dwId = dwId;	/* Node env (not valid yet) */
 	/* Queues of Message frames for messages from the DSP */
-	pMsgQ->msgFreeList = LST_Create();
-	pMsgQ->msgUsedList = LST_Create();
+	pMsgQ->msgFreeList = MEM_Calloc(sizeof(struct LST_LIST), MEM_NONPAGED);
+	pMsgQ->msgUsedList = MEM_Calloc(sizeof(struct LST_LIST), MEM_NONPAGED);
 	if (pMsgQ->msgFreeList == NULL || pMsgQ->msgUsedList == NULL)
 		status = DSP_EMEMORY;
+	else {
+		INIT_LIST_HEAD(&pMsgQ->msgFreeList->head);
+		INIT_LIST_HEAD(&pMsgQ->msgUsedList->head);
+	}
 
 	 /*  Create event that will be signalled when a message from
 	 *  the DSP is available.  */
@@ -184,10 +177,6 @@ DSP_STATUS WMD_MSG_CreateQueue(struct MS
 		status = SYNC_OpenEvent(&pMsgQ->hSyncDoneAck, NULL);
 
 	if (DSP_SUCCEEDED(status)) {
-               if (!hMsgMgr->msgFreeList) {
-                       status = DSP_EHANDLE;
-                       goto func_end;
-               }
 		/* Enter critical section */
 		(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
 		/* Initialize message frames and put in appropriate queues */
@@ -204,7 +193,7 @@ DSP_STATUS WMD_MSG_CreateQueue(struct MS
 			DeleteMsgQueue(pMsgQ, uNumAllocated);
 		} else {
 			LST_PutTail(hMsgMgr->queueList,
-				   (struct LST_ELEM *)pMsgQ);
+				   (struct list_head *)pMsgQ);
 			*phMsgQueue = pMsgQ;
 			/* Signal that free frames are now available */
 			if (!LST_IsEmpty(hMsgMgr->msgFreeList))
@@ -226,9 +215,8 @@ func_end:
  */
 void WMD_MSG_Delete(struct MSG_MGR *hMsgMgr)
 {
-	DBC_Require(MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE));
-
-	DeleteMsgMgr(hMsgMgr);
+	if (MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE))
+		DeleteMsgMgr(hMsgMgr);
 }
 
 /*
@@ -237,10 +225,14 @@ void WMD_MSG_Delete(struct MSG_MGR *hMsg
  */
 void WMD_MSG_DeleteQueue(struct MSG_QUEUE *hMsgQueue)
 {
-	struct MSG_MGR *hMsgMgr = hMsgQueue->hMsgMgr;
+	struct MSG_MGR *hMsgMgr;
 	u32 refCount;
 
-	DBC_Require(MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE));
+	if (!MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE) ||
+			!hMsgQueue->hMsgMgr)
+		goto func_end;
+
+	hMsgMgr = hMsgQueue->hMsgMgr;
 	hMsgQueue->fDone = true;
 	 /*  Unblock all threads blocked in MSG_Get() or MSG_Put().  */
 	refCount = hMsgQueue->refCount;
@@ -253,15 +245,17 @@ void WMD_MSG_DeleteQueue(struct MSG_QUEU
 	}
 	/* Remove message queue from hMsgMgr->queueList */
 	(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
-	LST_RemoveElem(hMsgMgr->queueList, (struct LST_ELEM *)hMsgQueue);
+	LST_RemoveElem(hMsgMgr->queueList, (struct list_head *)hMsgQueue);
 	/* Free the message queue object */
 	DeleteMsgQueue(hMsgQueue, hMsgQueue->uMaxMsgs);
-       if (!hMsgMgr->msgFreeList)
-               goto func_cont;
+	if (!hMsgMgr->msgFreeList)
+		goto func_cont;
 	if (LST_IsEmpty(hMsgMgr->msgFreeList))
 		SYNC_ResetEvent(hMsgMgr->hSyncEvent);
 func_cont:
 	(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+func_end:
+	return;
 }
 
 /*
@@ -278,14 +272,16 @@ DSP_STATUS WMD_MSG_Get(struct MSG_QUEUE 
 	u32 uIndex;
 	DSP_STATUS status = DSP_SOK;
 
-	DBC_Require(MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE));
-	DBC_Require(pMsg != NULL);
+	if (!MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE) || pMsg == NULL) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
 
 	hMsgMgr = hMsgQueue->hMsgMgr;
-       if (!hMsgQueue->msgUsedList) {
-               status = DSP_EHANDLE;
-               goto func_end;
-       }
+	if (!hMsgQueue->msgUsedList) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 
 	/* Enter critical section */
 	(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
@@ -296,9 +292,14 @@ DSP_STATUS WMD_MSG_Get(struct MSG_QUEUE 
 		if (pMsgFrame != NULL) {
 			*pMsg = pMsgFrame->msgData.msg;
 			LST_PutTail(hMsgQueue->msgFreeList,
-				   (struct LST_ELEM *)pMsgFrame);
+				   (struct list_head *)pMsgFrame);
 			if (LST_IsEmpty(hMsgQueue->msgUsedList))
 				SYNC_ResetEvent(hMsgQueue->hSyncEvent);
+			else {
+				NTFY_Notify(hMsgQueue->hNtfy,
+					DSP_NODEMESSAGEREADY);
+				SYNC_SetEvent(hMsgQueue->hSyncEvent);
+			}
 
 			fGotMsg = true;
 		}
@@ -341,14 +342,16 @@ DSP_STATUS WMD_MSG_Get(struct MSG_QUEUE 
 				if (pMsgFrame != NULL) {
 					*pMsg = pMsgFrame->msgData.msg;
 					LST_PutTail(hMsgQueue->msgFreeList,
-					(struct LST_ELEM *)pMsgFrame);
+					(struct list_head *)pMsgFrame);
 				}
 			}
 			hMsgQueue->refCount--;
 			/* Reset the event if there are still queued messages */
-			if (!LST_IsEmpty(hMsgQueue->msgUsedList))
+			if (!LST_IsEmpty(hMsgQueue->msgUsedList)) {
+				NTFY_Notify(hMsgQueue->hNtfy,
+					DSP_NODEMESSAGEREADY);
 				SYNC_SetEvent(hMsgQueue->hSyncEvent);
-
+			}
 			/* Exit critical section */
 			(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
 		}
@@ -371,16 +374,16 @@ DSP_STATUS WMD_MSG_Put(struct MSG_QUEUE 
 	u32 uIndex;
 	DSP_STATUS status = DSP_SOK;
 
-	DBC_Require(MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE));
-	DBC_Require(pMsg != NULL);
-
+	if (!MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE) || !pMsg ||
+						!hMsgQueue->hMsgMgr) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
 	hMsgMgr = hMsgQueue->hMsgMgr;
-
-       if (!hMsgMgr->msgFreeList) {
-               status = DSP_EHANDLE;
-               goto func_end;
-       }
-
+	if (!hMsgMgr->msgFreeList) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 
 	(void) SYNC_EnterCS(hMsgMgr->hSyncCS);
 
@@ -391,8 +394,8 @@ DSP_STATUS WMD_MSG_Put(struct MSG_QUEUE 
 		if (pMsgFrame != NULL) {
 			pMsgFrame->msgData.msg = *pMsg;
 			pMsgFrame->msgData.dwId = hMsgQueue->dwId;
-			LST_PutTail(hMsgMgr->msgUsedList, (struct LST_ELEM *)
-				   pMsgFrame);
+			LST_PutTail(hMsgMgr->msgUsedList,
+					(struct list_head *)pMsgFrame);
 			hMsgMgr->uMsgsPending++;
 			fPutMsg = true;
 		}
@@ -418,6 +421,8 @@ DSP_STATUS WMD_MSG_Put(struct MSG_QUEUE 
 		hSyncs[1] = hMsgQueue->hSyncDone;
 		status = SYNC_WaitOnMultipleEvents(hSyncs, 2, uTimeout,
 			 &uIndex);
+		if (DSP_FAILED(status))
+			goto func_end;
 		/* Enter critical section */
 		(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
 		if (hMsgQueue->fDone) {
@@ -429,29 +434,28 @@ DSP_STATUS WMD_MSG_Put(struct MSG_QUEUE 
 			(void)SYNC_SetEvent(hMsgQueue->hSyncDoneAck);
 			status = DSP_EFAIL;
 		} else {
-			if (DSP_SUCCEEDED(status)) {
-                               if (LST_IsEmpty(hMsgMgr->msgFreeList)) {
-                                       status = DSP_EPOINTER;
-                                       goto func_cont;
-                               }
-				/* Get msg from free list */
-				pMsgFrame = (struct MSG_FRAME *)
+			if (LST_IsEmpty(hMsgMgr->msgFreeList)) {
+				status = DSP_EPOINTER;
+				goto func_cont;
+			}
+			/* Get msg from free list */
+			pMsgFrame = (struct MSG_FRAME *)
 					    LST_GetHead(hMsgMgr->msgFreeList);
-				/* Copy message into pMsg and put frame on the
-				 * used list */
-				if (pMsgFrame != NULL) {
-					pMsgFrame->msgData.msg = *pMsg;
-					pMsgFrame->msgData.dwId =
-						hMsgQueue->dwId;
-					LST_PutTail(hMsgMgr->msgUsedList,
-						   (struct LST_ELEM *)
-						   pMsgFrame);
-					hMsgMgr->uMsgsPending++;
-					/* Schedule a DPC, to do the actual
-					 * data transfer: */
-					IO_Schedule(hMsgMgr->hIOMgr);
-				}
+			/*
+			 * Copy message into pMsg and put frame on the
+			 * used list
+			 */
+			if (pMsgFrame) {
+				pMsgFrame->msgData.msg = *pMsg;
+				pMsgFrame->msgData.dwId = hMsgQueue->dwId;
+				LST_PutTail(hMsgMgr->msgUsedList,
+					   (struct list_head *)pMsgFrame);
+				hMsgMgr->uMsgsPending++;
+				/* Schedule a DPC, to do the actual
+				 * data transfer: */
+				IO_Schedule(hMsgMgr->hIOMgr);
 			}
+
 			hMsgQueue->refCount--;
 			/* Reset event if there are still frames available */
 			if (!LST_IsEmpty(hMsgMgr->msgFreeList))
@@ -474,10 +478,20 @@ DSP_STATUS WMD_MSG_RegisterNotify(struct
 {
 	DSP_STATUS status = DSP_SOK;
 
-	DBC_Require(MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE));
-	DBC_Require(hNotification != NULL);
-	DBC_Require(uEventMask == DSP_NODEMESSAGEREADY || uEventMask == 0);
-	DBC_Require(uNotifyType == DSP_SIGNALEVENT);
+	if (!MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE) || !hNotification) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+
+	if (!(uEventMask == DSP_NODEMESSAGEREADY || uEventMask == 0)) {
+		status = DSP_ENODETYPE;
+		goto func_end;
+	}
+
+	if (uNotifyType != DSP_SIGNALEVENT) {
+		status = DSP_EWRONGSTATE;
+		goto func_end;
+	}
 
 	status = NTFY_Register(hMsgQueue->hNtfy, hNotification, uEventMask,
 			      uNotifyType);
@@ -488,7 +502,7 @@ DSP_STATUS WMD_MSG_RegisterNotify(struct
 		 *  by NODE, and message ready handled by MSG.  */
 		status = DSP_SOK;
 	}
-
+func_end:
 	return status;
 }
 
@@ -497,9 +511,6 @@ DSP_STATUS WMD_MSG_RegisterNotify(struct
  */
 void WMD_MSG_SetQueueId(struct MSG_QUEUE *hMsgQueue, u32 dwId)
 {
-	DBC_Require(MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE));
-	/* DBC_Require(dwId != 0); */
-
 	/*
 	 *  A message queue must be created when a node is allocated,
 	 *  so that NODE_RegisterNotify() can be called before the node
@@ -507,7 +518,8 @@ void WMD_MSG_SetQueueId(struct MSG_QUEUE
 	 *  node is created, we need this function to set hMsgQueue->dwId
 	 *  to the node environment, after the node is created.
 	 */
-	hMsgQueue->dwId = dwId;
+	if (MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE))
+		hMsgQueue->dwId = dwId;
 }
 
 /*
@@ -522,8 +534,8 @@ static DSP_STATUS AddNewMsg(struct LST_L
 	pMsg = (struct MSG_FRAME *)MEM_Calloc(sizeof(struct MSG_FRAME),
 		MEM_PAGED);
 	if (pMsg != NULL) {
-		LST_InitElem((struct LST_ELEM *) pMsg);
-		LST_PutTail(msgList, (struct LST_ELEM *) pMsg);
+		LST_InitElem((struct list_head *)pMsg);
+		LST_PutTail(msgList, (struct list_head *)pMsg);
 	} else {
 		status = DSP_EMEMORY;
 	}
@@ -536,24 +548,25 @@ static DSP_STATUS AddNewMsg(struct LST_L
  */
 static void DeleteMsgMgr(struct MSG_MGR *hMsgMgr)
 {
-	DBC_Require(MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE));
+	if (!MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE))
+		goto func_end;
 
 	if (hMsgMgr->queueList) {
-               if (LST_IsEmpty(hMsgMgr->queueList)) {
-                       LST_Delete(hMsgMgr->queueList);
-                       hMsgMgr->queueList = NULL;
-               }
+		if (LST_IsEmpty(hMsgMgr->queueList)) {
+			MEM_Free(hMsgMgr->queueList);
+			hMsgMgr->queueList = NULL;
+		}
 	}
 
-       if (hMsgMgr->msgFreeList) {
+	if (hMsgMgr->msgFreeList) {
 		FreeMsgList(hMsgMgr->msgFreeList);
-               hMsgMgr->msgFreeList = NULL;
-       }
+		hMsgMgr->msgFreeList = NULL;
+	}
 
-       if (hMsgMgr->msgUsedList) {
+	if (hMsgMgr->msgUsedList) {
 		FreeMsgList(hMsgMgr->msgUsedList);
-               hMsgMgr->msgUsedList = NULL;
-       }
+		hMsgMgr->msgUsedList = NULL;
+	}
 
 	if (hMsgMgr->hSyncEvent)
 		SYNC_CloseEvent(hMsgMgr->hSyncEvent);
@@ -562,6 +575,8 @@ static void DeleteMsgMgr(struct MSG_MGR 
 		SYNC_DeleteCS(hMsgMgr->hSyncCS);
 
 	MEM_FreeObject(hMsgMgr);
+func_end:
+	return;
 }
 
 /*
@@ -573,11 +588,11 @@ static void DeleteMsgQueue(struct MSG_QU
 	struct MSG_FRAME *pMsg;
 	u32 i;
 
-       if (!MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE)
-               || !hMsgQueue->hMsgMgr || !hMsgQueue->hMsgMgr->msgFreeList)
-               goto func_end;
-       hMsgMgr = hMsgQueue->hMsgMgr;
+	if (!MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE) ||
+	    !hMsgQueue->hMsgMgr || !hMsgQueue->hMsgMgr->msgFreeList)
+		goto func_end;
 
+	hMsgMgr = hMsgQueue->hMsgMgr;
 
 	/* Pull off uNumToDSP message frames from Msg manager and free */
 	for (i = 0; i < uNumToDSP; i++) {
@@ -594,12 +609,12 @@ static void DeleteMsgQueue(struct MSG_QU
 
        if (hMsgQueue->msgFreeList) {
 		FreeMsgList(hMsgQueue->msgFreeList);
-               hMsgQueue->msgFreeList = NULL;
+		hMsgQueue->msgFreeList = NULL;
        }
 
        if (hMsgQueue->msgUsedList) {
 		FreeMsgList(hMsgQueue->msgUsedList);
-               hMsgQueue->msgUsedList = NULL;
+		hMsgQueue->msgUsedList = NULL;
        }
 
 
@@ -628,16 +643,16 @@ static void FreeMsgList(struct LST_LIST 
 {
 	struct MSG_FRAME *pMsg;
 
-       if (!msgList)
-               goto func_end;
+	if (!msgList)
+		goto func_end;
 
 	while ((pMsg = (struct MSG_FRAME *)LST_GetHead(msgList)) != NULL)
 		MEM_Free(pMsg);
 
 	DBC_Assert(LST_IsEmpty(msgList));
 
-	LST_Delete(msgList);
+	MEM_Free(msgList);
 func_end:
-       return;
+	return;
 }
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/tiomap3430.c kernel-power-2.6.28/drivers/dsp/bridge/wmd/tiomap3430.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/tiomap3430.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/tiomap3430.c	2011-05-02 22:36:51.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Processor Manager Driver for TI OMAP3430 EVM.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,18 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== tiomap.c ========
- *  Processor Manager Driver for TI OMAP3430 EVM.
- *
- *  Public Function:
- *      WMD_DRV_Entry
- *
- *! Revision History:
- *! ================
- *   26-March-2008 HK and AL:  Added WMD_DEV_WalkTbl funciton.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 #include <linux/mm.h>
@@ -34,7 +24,7 @@
 #include <mach-omap2/cm.h>
 #include <mach-omap2/prm-regbits-34xx.h>
 #include <mach-omap2/cm-regbits-34xx.h>
-#include <mach/control.h>
+#include <mach/control.h>
 
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/std.h>
@@ -47,12 +37,9 @@
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/mem.h>
-#include <dspbridge/util.h>
 #include <dspbridge/reg.h>
-#include <dspbridge/dbreg.h>
 #include <dspbridge/cfg.h>
 #include <dspbridge/drv.h>
-#include <dspbridge/csl.h>
 #include <dspbridge/sync.h>
 
 /* ------------------------------------ Hardware Abstraction Layer */
@@ -95,12 +82,9 @@
 #define MMU_LARGE_PAGE_MASK      0xFFFF0000
 #define MMU_SMALL_PAGE_MASK      0xFFFFF000
 #define PAGES_II_LVL_TABLE   512
-#define phys_to_page(phys)      pfn_to_page((phys) >> PAGE_SHIFT)
 
 #define MMU_GFLUSH 0x60
 
-extern unsigned short min_active_opp;
-
 /* Forward Declarations: */
 static DSP_STATUS WMD_BRD_Monitor(struct WMD_DEV_CONTEXT *pDevContext);
 static DSP_STATUS WMD_BRD_Read(struct WMD_DEV_CONTEXT *pDevContext,
@@ -109,7 +93,7 @@ static DSP_STATUS WMD_BRD_Read(struct WM
 static DSP_STATUS WMD_BRD_Start(struct WMD_DEV_CONTEXT *pDevContext,
 			u32 dwDSPAddr);
 static DSP_STATUS WMD_BRD_Status(struct WMD_DEV_CONTEXT *pDevContext,
-			OUT BRD_STATUS *pdwState);
+			int *pdwState);
 static DSP_STATUS WMD_BRD_Stop(struct WMD_DEV_CONTEXT *pDevContext);
 static DSP_STATUS WMD_BRD_Write(struct WMD_DEV_CONTEXT *pDevContext,
 			IN u8 *pbHostBuf,
@@ -281,7 +265,7 @@ static inline void tlb_flush_all(const v
 static inline void flush_all(struct WMD_DEV_CONTEXT *pDevContext)
 {
 	if (pDevContext->dwBrdState == BRD_DSP_HIBERNATION ||
-			pDevContext->dwBrdState == BRD_HIBERNATION)
+				pDevContext->dwBrdState == BRD_HIBERNATION)
 		WakeDSP(pDevContext, NULL);
 
 	tlb_flush_all(pDevContext->dwDSPMmuBase);
@@ -296,7 +280,7 @@ static void bad_page_dump(u32 pa, struct
 		current->comm, pg, (int)(2*sizeof(unsigned long)),
 		(unsigned long)pg->flags, pg->mapping,
 		page_mapcount(pg), page_count(pg));
-	BUG();
+	dump_stack();
 }
 
 /*
@@ -579,12 +563,11 @@ static DSP_STATUS WMD_BRD_Start(struct W
 
 		/* Enable the BIOS clock  */
 		(void)DEV_GetSymbol(pDevContext->hDevObject,
-					BRIDGEINIT_BIOSGPTIMER,
-				     &ulBiosGpTimer);
+				BRIDGEINIT_BIOSGPTIMER, &ulBiosGpTimer);
 		DBG_Trace(DBG_LEVEL7, "BIOS GPTimer : 0x%x\n", ulBiosGpTimer);
 		(void)DEV_GetSymbol(pDevContext->hDevObject,
 				BRIDGEINIT_LOADMON_GPTIMER,
-				     &ulLoadMonitorTimer);
+				&ulLoadMonitorTimer);
 		DBG_Trace(DBG_LEVEL7, "Load Monitor Timer : 0x%x\n",
 			  ulLoadMonitorTimer);
 	}
@@ -600,20 +583,18 @@ static DSP_STATUS WMD_BRD_Start(struct W
 
 			extClkId = uClkCmd & MBX_PM_CLK_IDMASK;
 			for (tmpIndex = 0; tmpIndex < MBX_PM_MAX_RESOURCES;
-				       tmpIndex++) {
+			     tmpIndex++) {
 				if (extClkId == BPWR_CLKID[tmpIndex]) {
 					clkIdIndex = tmpIndex;
 					break;
 				}
 			}
 
-			if (clkIdIndex < MBX_PM_MAX_RESOURCES)
-				status = CLK_Set_32KHz(
-						BPWR_Clks[clkIdIndex].funClk);
-			else
+			if (clkIdIndex < MBX_PM_MAX_RESOURCES) {
+				status =
+				    CLK_Set_32KHz(BPWR_Clks[clkIdIndex].funClk);
+			} else {
 				status = DSP_EFAIL;
-
-			if (DSP_FAILED(status)) {
 				DBG_Trace(DBG_LEVEL7, " Error while setting"
 							"LM Timer  to 32KHz\n");
 			}
@@ -649,13 +630,11 @@ static DSP_STATUS WMD_BRD_Start(struct W
 				}
 			}
 
-			if (clkIdIndex < MBX_PM_MAX_RESOURCES)
+			if (clkIdIndex < MBX_PM_MAX_RESOURCES) {
 				status = CLK_Set_32KHz(
 						BPWR_Clks[clkIdIndex].funClk);
-			else
+			} else {
 				status = DSP_EFAIL;
-
-			if (DSP_FAILED(status)) {
 				DBG_Trace(DBG_LEVEL7,
 				" Error while setting BIOS Timer  to 32KHz\n");
 			}
@@ -724,9 +703,7 @@ static DSP_STATUS WMD_BRD_Start(struct W
 		/* Enable Mailbox events and also drain any pending
 		 * stale messages */
 		(void)CHNLSM_EnableInterrupt(pDevContext);
-	}
 
-	if (DSP_SUCCEEDED(status)) {
 		HW_RSTCTRL_RegGet(resources.dwPrmBase, HW_RST1_IVA2, &temp);
 		DBG_Trace(DBG_LEVEL7, "BRD_Start: RM_RSTCTRL_DSP = 0x%x \n",
 				temp);
@@ -754,10 +731,8 @@ static DSP_STATUS WMD_BRD_Start(struct W
 				dwDSPAddr);
 		if (dsp_debug)
 			while (*((volatile u16 *)dwSyncAddr))
-				;;
-	}
+				;
 
-	if (DSP_SUCCEEDED(status)) {
 		/* Wait for DSP to clear word in shared memory */
 		/* Read the Location */
 		if (!WaitForStart(pDevContext, dwSyncAddr)) {
@@ -774,8 +749,7 @@ static DSP_STATUS WMD_BRD_Start(struct W
 			 * completion of OPP table update to DSP
 			 */
 			*((volatile u32 *)dwSyncAddr) = 0XCAFECAFE;
-		}
-		if (DSP_SUCCEEDED(status)) {
+
 			/* update board state */
 			pDevContext->dwBrdState = BRD_RUNNING;
 			/* (void)CHNLSM_EnableInterrupt(pDevContext);*/
@@ -874,6 +848,7 @@ static DSP_STATUS WMD_BRD_Stop(struct WM
 	DBG_Trace(DBG_LEVEL6, "WMD_BRD_Stop - End ****** \n");
 	HW_RST_Reset(resources.dwPrmBase, HW_RST1_IVA2);
 	HW_RST_Reset(resources.dwPrmBase, HW_RST2_IVA2);
+	HW_RST_Reset(resources.dwPrmBase, HW_RST3_IVA2);
 
 	return status;
 }
@@ -940,6 +915,7 @@ static DSP_STATUS WMD_BRD_Delete(struct 
 	DBG_Trace(DBG_LEVEL6, "WMD_BRD_Delete - End ****** \n");
 	HW_RST_Reset(resources.dwPrmBase, HW_RST1_IVA2);
 	HW_RST_Reset(resources.dwPrmBase, HW_RST2_IVA2);
+	HW_RST_Reset(resources.dwPrmBase, HW_RST3_IVA2);
 
 	return status;
 }
@@ -950,7 +926,7 @@ static DSP_STATUS WMD_BRD_Delete(struct 
  *      Returns the board status.
  */
 static DSP_STATUS WMD_BRD_Status(struct WMD_DEV_CONTEXT *hDevContext,
-				 OUT BRD_STATUS *pdwState)
+				 int *pdwState)
 {
 	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
 	*pdwState = pDevContext->dwBrdState;
@@ -1132,8 +1108,8 @@ static DSP_STATUS WMD_DEV_Create(OUT str
 	if (DSP_SUCCEEDED(status)) {
 		/* Set the Endianism Register */ /* Need to set this */
 		/* Retrieve the TC u16 SWAP Option */
-		status = REG_GetValue(NULL, CURRENTCONFIG, TCWORDSWAP,
-				     (u8 *)&tcWordSwap, &tcWordSwapSize);
+		status = REG_GetValue(TCWORDSWAP, (u8 *)&tcWordSwap,
+				      &tcWordSwapSize);
 		/* Save the value */
 		pDevContext->tcWordSwapOn = tcWordSwap;
 	}
@@ -1266,11 +1242,16 @@ static DSP_STATUS WMD_DEV_Destroy(struct
 	DSP_STATUS status = DSP_SOK;
 	struct WMD_DEV_CONTEXT *pDevContext = (struct WMD_DEV_CONTEXT *)
 						hDevContext;
+
+	/* It should never happen */
+	if (!hDevContext)
+		return DSP_EHANDLE;
+
 	DBG_Trace(DBG_ENTER, "Entering WMD_DEV_Destroy:n hDevContext ::0x%x\n",
 		  hDevContext);
 	/* first put the device to stop state */
 	WMD_BRD_Delete(pDevContext);
-	if (pDevContext && pDevContext->pPtAttrs) {
+	if (pDevContext->pPtAttrs) {
 		pPtAttrs = pDevContext->pPtAttrs;
 		if (pPtAttrs->hCSObj)
 			SYNC_DeleteCS(pPtAttrs->hCSObj);
@@ -1379,8 +1360,14 @@ static DSP_STATUS WMD_BRD_MemMap(struct 
 	struct HW_MMUMapAttrs_t hwAttrs;
 	struct vm_area_struct *vma;
 	struct mm_struct *mm = current->mm;
-	u32 numUsrPgs = 0, nr_pages = 0;
+	u32 write = 0;
+	u32 numUsrPgs = 0;
+	struct page *mappedPage, *pg;
+	s32 pgNum;
 	u32 va = ulVirtAddr;
+	struct task_struct *curr_task = current;
+	u32 pgI = 0;
+	u32 mpuAddr, pa;
 
 	DBG_Trace(DBG_ENTER, "> WMD_BRD_MemMap hDevContext %x, pa %x, va %x, "
 		 "size %x, ulMapAttr %x\n", hDevContext, ulMpuAddr, ulVirtAddr,
@@ -1480,81 +1467,80 @@ static DSP_STATUS WMD_BRD_MemMap(struct 
 		goto func_cont;
 	}
 
-	numUsrPgs =  PAGE_ALIGN(ulNumBytes) / PG_SIZE_4K;
-
-	DBG_Trace(DBG_LEVEL4, "%s :numOfActualTabEntries=%d, ulNumBytes= %d\n",
-		  %s, numUsrPgs, ulNumBytes);
-
-	if (vma->vm_flags & (VM_IO | VM_PFNMAP | VM_RESERVED)) {
-		for (nr_pages = numUsrPgs; nr_pages > 0;) {
-			u32 pa;
-
-			pa = user_va2pa(mm, ulMpuAddr);
+	if (vma->vm_flags & VM_IO) {
+		numUsrPgs =  ulNumBytes / PG_SIZE_4K;
+		mpuAddr = ulMpuAddr;
+		DBG_Trace(DBG_LEVEL4, "WMD_BRD_MemMap:numOfActualTabEntries=%d,"
+			  "ulNumBytes= %d\n",  numUsrPgs, ulNumBytes);
+		/* Get the physical addresses for user buffer */
+		for (pgI = 0; pgI < numUsrPgs; pgI++) {
+			pa = user_va2pa(mm, mpuAddr);
 			if (!pa) {
 				status = DSP_EFAIL;
 				pr_err("DSPBRIDGE: VM_IO mapping physical"
-				       "address is invalid\n");
+						"address is invalid\n");
 				break;
 			}
-
+			if (pfn_valid(__phys_to_pfn(pa))) {
+				pg = phys_to_page(pa);
+				get_page(pg);
+				if (page_count(pg) < 1) {
+					pr_err("Bad page in VM_IO buffer\n");
+					bad_page_dump(pa, pg);
+				}
+			}
 			status = PteSet(pDevContext->pPtAttrs, pa,
 					va, HW_PAGE_SIZE_4KB, &hwAttrs);
 			if (DSP_FAILED(status)) {
 				DBG_Trace(DBG_LEVEL7,
-					  "WMD_BRD_MemMap: FAILED IN VM_IO"
-					  "PTESET \n");
+					"WMD_BRD_MemMap: FAILED IN VM_IO"
+					"PTESET \n");
 				break;
 			}
-
 			va += HW_PAGE_SIZE_4KB;
-			ulMpuAddr += HW_PAGE_SIZE_4KB;
-			nr_pages--;
+			mpuAddr += HW_PAGE_SIZE_4KB;
+			pa += HW_PAGE_SIZE_4KB;
 		}
 	} else {
-		int write = 0;
-
+		numUsrPgs =  ulNumBytes / PG_SIZE_4K;
 		if (vma->vm_flags & (VM_WRITE | VM_MAYWRITE))
 			write = 1;
 
-		for (nr_pages = numUsrPgs; nr_pages > 0;) {
-			int i, ret;
-			struct page *pages[16]; /* for a reasonable batch */
-
-			ret = get_user_pages(current, mm, ulMpuAddr,
-					     min_t(int,  nr_pages, ARRAY_SIZE(pages)),
-					     write, 1, pages, NULL);
-			if (ret <= 0) {
-				pr_err("DSPBRIDGE: get_user_pages FAILED,"
-				       "MPU addr = 0x%x,"
-				       "vma->vm_flags = 0x%lx,"
-				       "get_user_pages ErrValue = %d,"
-				       "Buffersize=0x%x\n",
-				       ulMpuAddr, vma->vm_flags, ret,
-				       ulNumBytes);
-				status = DSP_EFAIL;
-				goto fail_mapping;
-			}
-
-			for (i = 0; i < ret; i++) {
-				struct page *page = pages[i];
-
+		for (pgI = 0; pgI < numUsrPgs; pgI++) {
+			pgNum = get_user_pages(curr_task, mm, ulMpuAddr, 1,
+						write, 1, &mappedPage, NULL);
+			if (pgNum > 0) {
+				if (page_count(mappedPage) < 1) {
+					pr_err("Bad page count after doing"
+							"get_user_pages on"
+							"user buffer\n");
+					bad_page_dump(page_to_phys(mappedPage),
+								mappedPage);
+				}
 				status = PteSet(pDevContext->pPtAttrs,
-						page_to_phys(page), va,
-						HW_PAGE_SIZE_4KB, &hwAttrs);
+					page_to_phys(mappedPage), va,
+					HW_PAGE_SIZE_4KB, &hwAttrs);
 				if (DSP_FAILED(status)) {
-					pr_err("%s: FAILED IN PTESET\n",
-					       __func__);
-					goto fail_mapping;
+					DBG_Trace(DBG_LEVEL7,
+					"WMD_BRD_MemMap: FAILED IN PTESET \n");
+					break;
 				}
-				SetPageMlocked(page);
 				va += HW_PAGE_SIZE_4KB;
 				ulMpuAddr += HW_PAGE_SIZE_4KB;
-				nr_pages--;
+			} else {
+				pr_err("DSPBRIDGE: get_user_pages FAILED,"
+						"MPU addr = 0x%x,"
+						"vma->vm_flags = 0x%lx,"
+						"get_user_pages Err"
+						"Value = %d, Buffer"
+						"size=0x%x\n", ulMpuAddr,
+						vma->vm_flags, pgNum,
+						ulNumBytes);
+				status = DSP_EFAIL;
+				break;
 			}
 		}
 	}
-
-fail_mapping:
 	up_read(&mm->mmap_sem);
 func_cont:
 	/* Don't propogate Linux or HW status to upper layers */
@@ -1566,9 +1552,9 @@ func_cont:
 		 * Roll out the mapped pages incase it failed in middle of
 		 * mapping
 		 */
-		if (numUsrPgs - nr_pages) {
+		if (pgI) {
 			WMD_BRD_MemUnMap(pDevContext, ulVirtAddr,
-					 ((numUsrPgs - nr_pages) * PG_SIZE_4K));
+						(pgI * PG_SIZE_4K));
 		}
 		status = DSP_EFAIL;
 	}
@@ -1692,10 +1678,10 @@ static DSP_STATUS WMD_BRD_MemUnMap(struc
 						"COUNT 0 FOR PA 0x%x, size = "
 						"0x%x\n", pAddr, ulNumBytes);
 					bad_page_dump(pAddr, pg);
+				} else {
+					SetPageDirty(pg);
+					page_cache_release(pg);
 				}
-				ClearPageMlocked(pg);
-				SetPageDirty(pg);
-				page_cache_release(pg);
 				pAddr += HW_PAGE_SIZE_4KB;
 			}
 			if (HW_MMU_PteClear(pteAddrL2, vaCurr, pteSize)
@@ -1758,10 +1744,10 @@ skip_coarse_page:
 						"COUNT 0 FOR PA 0x%x, size = "
 						"0x%x\n", pAddr, ulNumBytes);
 					bad_page_dump(pAddr, pg);
+				} else {
+					SetPageDirty(pg);
+					page_cache_release(pg);
 				}
-				ClearPageMlocked(pg);
-				SetPageDirty(pg);
-				page_cache_release(pg);
 			}
 			pAddr += HW_PAGE_SIZE_4KB;
 		}
@@ -2052,9 +2038,7 @@ void configureDspMmu(struct WMD_DEV_CONT
 		    enum HW_ElementSize_t elemSize,
 		    enum HW_MMUMixedSize_t mixedSize)
 {
-	struct CFG_HOSTRES resources;
 	struct HW_MMUMapAttrs_t mapAttrs = { endianism, elemSize, mixedSize };
-	DSP_STATUS status = DSP_SOK;
 
 	DBC_Require(sizeInBytes > 0);
 	DBG_Trace(DBG_LEVEL1,
@@ -2063,9 +2047,8 @@ void configureDspMmu(struct WMD_DEV_CONT
 
 	DBG_Trace(DBG_LEVEL1, "endianism %x, elemSize %x, mixedSize %x\n",
 		 endianism, elemSize, mixedSize);
-	status = CFG_GetHostResources(
-		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
-	status = HW_MMU_TLBAdd(pDevContext->dwDSPMmuBase, dataBasePhys,
+
+	HW_MMU_TLBAdd(pDevContext->dwDSPMmuBase, dataBasePhys,
 				dspBaseVirt, sizeInBytes, nEntryStart,
 				&mapAttrs, HW_SET, HW_SET);
 }
@@ -2076,14 +2059,14 @@ void configureDspMmu(struct WMD_DEV_CONT
  */
 bool WaitForStart(struct WMD_DEV_CONTEXT *pDevContext, u32 dwSyncAddr)
 {
-	u16 usCount = TIHELEN_ACKTIMEOUT;
+	u16 timeout = TIHELEN_ACKTIMEOUT;
 
 	/*  Wait for response from board */
-	while (*((volatile u16 *)dwSyncAddr) && --usCount)
+	while (*((volatile u16 *)dwSyncAddr) && --timeout)
 		udelay(10);
 
 	/*  If timed out: return FALSE */
-	if (!usCount) {
+	if (!timeout) {
 		DBG_Trace(DBG_LEVEL7, "Timed out Waiting for DSP to Start\n");
 		return FALSE;
 	}
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/tiomap3430_pwr.c kernel-power-2.6.28/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/tiomap3430_pwr.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/tiomap3430_pwr.c	2011-05-02 22:36:51.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implementation of DSP wake/sleep routines.
+ *
  * Copyright (C) 2007-2008 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,21 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-/*
- *  ======== _tiomap_pwr.c ========
- *  Description:
- *      Implementation of DSP wake/sleep routines.
- *
- *! Revision History
- *! ================
- *! 01-Nov-2007 HK: Added Off mode(Hibernation) support and DVFS support
- *! 05-Jan-2004 vp: Moved the file to platform specific folder and commented the
- *!		    code.
- *! 27-Mar-2003 vp: Added support for DSP boot idle mode.
- *! 06-Dec-2002 cring:  Added Palm support.
- *! 08-Oct-2002 rr:  Created.
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/dbdefs.h>
 #include <dspbridge/errbase.h>
@@ -42,7 +29,6 @@
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/mem.h>
-#include <dspbridge/util.h>
 
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/brddefs.h>
@@ -68,11 +54,10 @@
 #include <mach-omap2/cm-regbits-34xx.h>
 
 #ifdef CONFIG_PM
-#include <mach/board-3430sdp.h>
+extern s32 dsp_test_sleepstate;
 #endif
 extern struct MAILBOX_CONTEXT mboxsetting;
-extern unsigned short enable_off_mode;
-extern unsigned short min_active_opp;
+
 /*
  *  ======== handle_constraints_set ========
  *  	Sets new DSP constraint
@@ -81,33 +66,18 @@ DSP_STATUS handle_constraints_set(struct
 				  IN void *pArgs)
 {
 #ifdef CONFIG_BRIDGE_DVFS
-	u32 pConstraintVal;
-	DSP_STATUS status = DSP_SOK;
-	struct CFG_HOSTRES resources;
+	u32 *pConstraintVal;
 	struct dspbridge_platform_data *pdata =
 		omap_dspbridge_dev->dev.platform_data;
-	status = CFG_GetHostResources(
-		(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
 
-	pConstraintVal = *(((u32 *)pArgs) + 1);
+	pConstraintVal = (u32 *)(pArgs);
 	/* Read the target value requested by DSP  */
 	DBG_Trace(DBG_LEVEL7, "handle_constraints_set:"
-		"opp requested = 0x%x\n", pConstraintVal);
-	status = HW_MBOX_saveSettings(resources.dwMboxBase);
+		"opp requested = 0x%x\n", (u32)*(pConstraintVal+1));
 
 	/* Set the new opp value */
-	if (pdata->dsp_set_min_opp) {
-		/*
-		 * When Smartreflex is ON, DSP requires at least OPP level 3
-		 * to operate reliably. So boost lower OPP levels to OPP3.
-		 */
-		if (pConstraintVal < min_active_opp) {
-			pr_debug("DSPBRIDGE: VDD1 OPP%x elevated to OPP%x\n",
-					pConstraintVal, min_active_opp);
-			(*pdata->dsp_set_min_opp)(min_active_opp);
-		} else
-			(*pdata->dsp_set_min_opp)(pConstraintVal);
-	}
+	if (pdata->dsp_set_min_opp)
+		(*pdata->dsp_set_min_opp)((u32)*(pConstraintVal+1));
 #endif /* #ifdef CONFIG_BRIDGE_DVFS */
 	return DSP_SOK;
 }
@@ -120,7 +90,7 @@ DSP_STATUS handle_hibernation_fromDSP(st
 {
 	DSP_STATUS status = DSP_SOK;
 #ifdef CONFIG_PM
-	u16 usCount = TIHELEN_ACKTIMEOUT;
+	u16 timeout = PWRSTST_TIMEOUT / 10;
 	struct CFG_HOSTRES resources;
 	enum HW_PwrState_t pwrState;
 #ifdef CONFIG_BRIDGE_DVFS
@@ -137,14 +107,16 @@ DSP_STATUS handle_hibernation_fromDSP(st
 
 	HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
 			    &pwrState);
-	/* Wait for DSP to move into Off state,  how much time should
-	 * we wait? */
-	while ((pwrState != HW_PWR_STATE_OFF) && --usCount) {
-		udelay(500);
+	/* Wait for DSP to move into OFF state */
+	while ((pwrState != HW_PWR_STATE_OFF) && --timeout) {
+		if (msleep_interruptible(10)) {
+			pr_err("Waiting for DSP OFF mode interrupted\n");
+			return DSP_EFAIL;
+		}
 		HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
 				    &pwrState);
 	}
-	if (usCount == 0) {
+	if (timeout == 0) {
 		DBG_Trace(DBG_LEVEL7, "Timed out Waiting for DSP Off mode \n");
 		status = WMD_E_TIMEOUT;
 		return status;
@@ -202,8 +174,10 @@ DSP_STATUS SleepDSP(struct WMD_DEV_CONTE
 	DSP_STATUS status = DSP_SOK;
 #ifdef CONFIG_PM
 	struct CFG_HOSTRES resources;
+#ifdef CONFIG_BRIDGE_NTFY_PWRERR
 	struct DEH_MGR *hDehMgr;
-	u16 usCount = TIHELEN_ACKTIMEOUT;
+#endif /* CONFIG_BRIDGE_NTFY_PWRERR */
+	u16 timeout = PWRSTST_TIMEOUT / 10;
 	enum HW_PwrState_t pwrState, targetPwrState;
 
 	DBG_Trace(DBG_LEVEL7, "SleepDSP- Enter function \n");
@@ -222,7 +196,7 @@ DSP_STATUS SleepDSP(struct WMD_DEV_CONTE
 	switch (pDevContext->dwBrdState) {
 	case BRD_RUNNING:
 		status = HW_MBOX_saveSettings(resources.dwMboxBase);
-		if (enable_off_mode) {
+		if (dsp_test_sleepstate == HW_PWR_STATE_OFF) {
 			CHNLSM_InterruptDSP2(pDevContext,
 					     MBX_PM_DSPHIBERNATE);
 			DBG_Trace(DBG_LEVEL7,
@@ -237,7 +211,7 @@ DSP_STATUS SleepDSP(struct WMD_DEV_CONTE
 		break;
 	case BRD_RETENTION:
 		status = HW_MBOX_saveSettings(resources.dwMboxBase);
-		if (enable_off_mode) {
+		if (dsp_test_sleepstate == HW_PWR_STATE_OFF) {
 			CHNLSM_InterruptDSP2(pDevContext,
 					     MBX_PM_DSPHIBERNATE);
 			targetPwrState = HW_PWR_STATE_OFF;
@@ -264,28 +238,30 @@ DSP_STATUS SleepDSP(struct WMD_DEV_CONTE
 	HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
 			&pwrState);
 
-	/*
-	 * Wait for DSP to move into Standby state,  how much time
-	 * should we wait?
-	 */
-	while ((pwrState != targetPwrState) && --usCount) {
-		udelay(500);
+	/* Wait for DSP to move into target power state */
+	while ((pwrState != targetPwrState) && --timeout) {
+		if (msleep_interruptible(10)) {
+			pr_err("Waiting for DSP to Suspend interrupted\n");
+			return DSP_EFAIL;
+		}
 		HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
 				    &pwrState);
 	}
 
-	if (!usCount) {
+	if (!timeout) {
 		DBG_Trace(DBG_LEVEL7, "SleepDSP: Timed out Waiting for DSP"
 			 " STANDBY %x \n", pwrState);
+#ifdef CONFIG_BRIDGE_NTFY_PWRERR
 		DEV_GetDehMgr(pDevContext->hDevObject, &hDehMgr);
 		WMD_DEH_Notify(hDehMgr, DSP_PWRERROR, 0);
+#endif /* CONFIG_BRIDGE_NTFY_PWRERR */
 		return WMD_E_TIMEOUT;
 	} else {
 		DBG_Trace(DBG_LEVEL7, "SleepDSP: DSP STANDBY Pwr state %x \n",
 			 pwrState);
 
 		/* Update the Bridger Driver state */
-		if (enable_off_mode)
+		if (dsp_test_sleepstate == HW_PWR_STATE_OFF)
 			pDevContext->dwBrdState = BRD_HIBERNATION;
 		else
 			pDevContext->dwBrdState = BRD_RETENTION;
@@ -319,8 +295,8 @@ DSP_STATUS SleepDSP(struct WMD_DEV_CONTE
  */
 DSP_STATUS WakeDSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs)
 {
-#ifdef CONFIG_PM
 	DSP_STATUS status = DSP_SOK;
+#ifdef CONFIG_PM
 #ifdef CONFIG_BRIDGE_DEBUG
 	enum HW_PwrState_t pwrState;
 	struct CFG_HOSTRES resources;
@@ -371,6 +347,8 @@ DSP_STATUS DSPPeripheralClkCtrl(struct W
 	u32 dspPerClksBefore;
 	DSP_STATUS status = DSP_SOK;
 	DSP_STATUS status1 = DSP_SOK;
+	struct CFG_HOSTRES resources;
+	u32 value;
 
 	DBG_Trace(DBG_ENTER, "Entering DSPPeripheralClkCtrl \n");
 	dspPerClksBefore = pDevContext->uDspPerClks;
@@ -379,6 +357,13 @@ DSP_STATUS DSPPeripheralClkCtrl(struct W
 
 	extClk = (u32)*((u32 *)pArgs);
 
+	status = CFG_GetHostResources(
+			(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
+			&resources);
+
+	if (DSP_FAILED(status))
+		return DSP_EFAIL;
+
 	DBG_Trace(DBG_LEVEL3, "DSPPeripheralClkCtrl : extClk+Cmd = 0x%x \n",
 		 extClk);
 
@@ -409,6 +394,17 @@ DSP_STATUS DSPPeripheralClkCtrl(struct W
 			 "DSPPeripheralClkCtrl : Disable CLK for \n");
 		status1 = CLK_Disable(BPWR_Clks[clkIdIndex].intClk);
 		status = CLK_Disable(BPWR_Clks[clkIdIndex].funClk);
+		if (BPWR_CLKID[clkIdIndex] == BPWR_MCBSP1) {
+			/* clear MCBSP1_CLKS, on McBSP1 OFF */
+			value = __raw_readl(resources.dwSysCtrlBase + 0x274);
+			value &= ~(1 << 2);
+			__raw_writel(value, resources.dwSysCtrlBase + 0x274);
+		} else if (BPWR_CLKID[clkIdIndex] == BPWR_MCBSP2) {
+			/* clear MCBSP2_CLKS, on McBSP2 OFF */
+			value = __raw_readl(resources.dwSysCtrlBase + 0x274);
+			value &= ~(1 << 6);
+			__raw_writel(value, resources.dwSysCtrlBase + 0x274);
+		}
 		DSPClkWakeupEventCtrl(BPWR_Clks[clkIdIndex].clkId, false);
 		if ((DSP_SUCCEEDED(status)) && (DSP_SUCCEEDED(status1))) {
 			(pDevContext->uDspPerClks) &=
@@ -423,6 +419,17 @@ DSP_STATUS DSPPeripheralClkCtrl(struct W
 			 "DSPPeripheralClkCtrl : Enable CLK for \n");
 		status1 = CLK_Enable(BPWR_Clks[clkIdIndex].intClk);
 		status = CLK_Enable(BPWR_Clks[clkIdIndex].funClk);
+		if (BPWR_CLKID[clkIdIndex] == BPWR_MCBSP1) {
+			/* set MCBSP1_CLKS, on McBSP1 ON */
+			value = __raw_readl(resources.dwSysCtrlBase + 0x274);
+			value |= 1 << 2;
+			__raw_writel(value, resources.dwSysCtrlBase + 0x274);
+		} else if (BPWR_CLKID[clkIdIndex] == BPWR_MCBSP2) {
+			/* set MCBSP2_CLKS, on McBSP2 ON */
+			value = __raw_readl(resources.dwSysCtrlBase + 0x274);
+			value |= 1 << 6;
+			__raw_writel(value, resources.dwSysCtrlBase + 0x274);
+		}
 		DSPClkWakeupEventCtrl(BPWR_Clks[clkIdIndex].clkId, true);
 		if ((DSP_SUCCEEDED(status)) && (DSP_SUCCEEDED(status1))) {
 			(pDevContext->uDspPerClks) |= (1 << clkIdIndex);
@@ -485,13 +492,15 @@ DSP_STATUS PreScale_DSP(struct WMD_DEV_C
  */
 DSP_STATUS PostScale_DSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs)
 {
+	DSP_STATUS status = DSP_SOK;
 #ifdef CONFIG_BRIDGE_DVFS
 	u32 level;
 	u32 voltage_domain;
 	struct IO_MGR *hIOMgr;
-	DSP_STATUS status = DSP_SOK;
 
 	status = DEV_GetIOMgr(pDevContext->hDevObject, &hIOMgr);
+	if (!hIOMgr)
+		return DSP_EHANDLE;
 
 	voltage_domain = *((u32 *)pArgs);
 	level = *((u32 *)pArgs + 1);
@@ -506,7 +515,6 @@ DSP_STATUS PostScale_DSP(struct WMD_DEV_
 		DBG_Trace(DBG_LEVEL7,
 			 "PostScale_DSP: IVA in sleep. Wrote to shared "
 			 "memory \n");
-		return DSP_SOK;
 	} else  if ((pDevContext->dwBrdState == BRD_RUNNING)) {
 		/* Update the OPP value in shared memory */
 		IO_SHMsetting(hIOMgr, SHM_CURROPP, &level);
@@ -515,14 +523,13 @@ DSP_STATUS PostScale_DSP(struct WMD_DEV_
 		DBG_Trace(DBG_LEVEL7,
 			"PostScale_DSP: Wrote to shared memory Sent post"
 			" notification to DSP\n");
-		return DSP_SOK;
 	} else {
 		DBG_Trace(DBG_LEVEL7, "PostScale_DSP: Failed - DSP BRD state "
 			"in wrong state");
-		return DSP_EFAIL;
+		status = DSP_EFAIL;
 	}
 #endif /* #ifdef CONFIG_BRIDGE_DVFS */
-	return DSP_SOK;
+	return status;
 }
 
 /*
@@ -532,14 +539,34 @@ DSP_STATUS PostScale_DSP(struct WMD_DEV_
 DSP_STATUS DSP_PeripheralClocks_Disable(struct WMD_DEV_CONTEXT *pDevContext,
 					IN void *pArgs)
 {
-
 	u32 clkIdx;
 	DSP_STATUS status = DSP_SOK;
+	struct CFG_HOSTRES resources;
+	u32 value;
+
+	status = CFG_GetHostResources(
+			(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
+			&resources);
 
 	for (clkIdx = 0; clkIdx < MBX_PM_MAX_RESOURCES; clkIdx++) {
 		if (((pDevContext->uDspPerClks) >> clkIdx) & 0x01) {
 			/* Disables the interface clock of the peripheral */
 			status = CLK_Disable(BPWR_Clks[clkIdx].intClk);
+			if (BPWR_CLKID[clkIdx] == BPWR_MCBSP1) {
+				/* clear MCBSP1_CLKS, on McBSP1 OFF */
+				value = __raw_readl(resources.dwSysCtrlBase
+								+ 0x274);
+				value &= ~(1 << 2);
+				__raw_writel(value, resources.dwSysCtrlBase
+								+ 0x274);
+			} else if (BPWR_CLKID[clkIdx] == BPWR_MCBSP2) {
+				/* clear MCBSP2_CLKS, on McBSP2 OFF */
+				value = __raw_readl(resources.dwSysCtrlBase
+								+ 0x274);
+				value &= ~(1 << 6);
+				__raw_writel(value, resources.dwSysCtrlBase
+								+ 0x274);
+			}
 			if (DSP_FAILED(status)) {
 				DBG_Trace(DBG_LEVEL7,
 					 "Failed to Enable the DSP Peripheral"
@@ -566,11 +593,31 @@ DSP_STATUS DSP_PeripheralClocks_Enable(s
 {
 	u32 clkIdx;
 	DSP_STATUS int_clk_status = DSP_EFAIL, fun_clk_status = DSP_EFAIL;
+	struct CFG_HOSTRES resources;
+	u32 value;
+
+	CFG_GetHostResources((struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
+			&resources);
 
 	for (clkIdx = 0; clkIdx < MBX_PM_MAX_RESOURCES; clkIdx++) {
 		if (((pDevContext->uDspPerClks) >> clkIdx) & 0x01) {
 			/* Enable the interface clock of the peripheral */
 			int_clk_status = CLK_Enable(BPWR_Clks[clkIdx].intClk);
+			if (BPWR_CLKID[clkIdx] == BPWR_MCBSP1) {
+				/* set MCBSP1_CLKS, on McBSP1 ON */
+				value = __raw_readl(resources.dwSysCtrlBase
+								+ 0x274);
+				value |= 1 << 2;
+				__raw_writel(value, resources.dwSysCtrlBase
+								+ 0x274);
+			} else if (BPWR_CLKID[clkIdx] == BPWR_MCBSP2) {
+				/* set MCBSP2_CLKS, on McBSP2 ON */
+				value = __raw_readl(resources.dwSysCtrlBase
+								+ 0x274);
+				value |= 1 << 6;
+				__raw_writel(value, resources.dwSysCtrlBase
+								+ 0x274);
+			}
 			/* Enable the functional clock of the periphearl */
 			fun_clk_status = CLK_Enable(BPWR_Clks[clkIdx].funClk);
 		}
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/tiomap_io.c kernel-power-2.6.28/drivers/dsp/bridge/wmd/tiomap_io.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/tiomap_io.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/tiomap_io.c	2011-05-02 22:36:51.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implementation for the io read/write routines.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,21 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _tiomap_io.c ========
- *  Description:
- *      Implementation for the io read/write routines.
- *
- *! Revision History
- *! ================
- *! 16-Feb-2004 vp:  Fixed warning in WriteDspData function.
- *! 16-Apr-2003 vp:  Added support for TC word swap
- *! 26-Feb-2003 vp:  Fixed issue with EXT_BEG and EXT_END address.
- *! 24-Feb-2003 vp:  Ported to Linux platform
- *! 08-Oct-2002 rr:  Created.
- */
-
 /*  ----------------------------------- DSP/BIOS Bridge */
 #include <dspbridge/dbdefs.h>
 #include <dspbridge/errbase.h>
@@ -43,7 +30,6 @@
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/mem.h>
-#include <dspbridge/util.h>
 #include <dspbridge/cfg.h>
 
 /*  ----------------------------------- specific to this file */
@@ -92,7 +78,7 @@ DSP_STATUS ReadExtDspData(struct WMD_DEV
 	DBC_Assert(ulShmBaseVirt != 0);
 
 	/* Check if it is a read of Trace section */
-	if (!ulTraceSecBeg) {
+	if (DSP_SUCCEEDED(status) && !ulTraceSecBeg) {
 		status = DEV_GetSymbol(pDevContext->hDevObject,
 		DSP_TRACESEC_BEG, &ulTraceSecBeg);
 	}
@@ -114,7 +100,7 @@ DSP_STATUS ReadExtDspData(struct WMD_DEV
 	}
 
 	/* If reading from TRACE, force remap/unmap */
-	if ((bTraceRead) && dwBaseAddr) {
+	if (bTraceRead && dwBaseAddr) {
 		dwBaseAddr = 0;
 		pDevContext->dwDspExtBaseAddr = 0;
 	}
@@ -226,6 +212,9 @@ DSP_STATUS WriteDspData(struct WMD_DEV_C
 	status =  CFG_GetHostResources(
 		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
 
+	if (DSP_FAILED(status))
+		return status;
+
 	offset = dwDSPAddr - hDevContext->dwDSPStartAdd;
 	if (offset < base1) {
 		dwBaseAddr = MEM_LinearAddress(resources.dwMemBase[2],
@@ -240,8 +229,7 @@ DSP_STATUS WriteDspData(struct WMD_DEV_C
 						resources.dwMemLength[4]);
 		offset = offset - base3;
 	} else{
-		status = DSP_EFAIL;
-		return status;
+		return DSP_EFAIL;
 	}
 	if (ulNumBytes)
 		memcpy((u8 *) (dwBaseAddr+offset), pbHostBuf, ulNumBytes);
@@ -378,9 +366,8 @@ DSP_STATUS WriteExtDspData(struct WMD_DE
 				 dwExtProgVirtMem);
 
 			pDevContext->dwDspExtBaseAddr =
-				(u32)MEM_LinearAddress((void *)
-				TO_VIRTUAL_UNCACHED(dwExtProgVirtMem), ulExtEnd
-				- ulExtBase);
+				(u32)MEM_LinearAddress((void *)dwExtProgVirtMem,
+					ulExtEnd - ulExtBase);
 			dwBaseAddr += pDevContext->dwDspExtBaseAddr;
 			/* This dwDspExtBaseAddr will get cleared only when
 			 * the board is stopped.  */
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/tiomap_io.h kernel-power-2.6.28/drivers/dsp/bridge/wmd/tiomap_io.h
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/tiomap_io.h	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/tiomap_io.h	2011-05-02 22:36:51.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Definitions, types and function prototypes for the io (r/w external mem).
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,18 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== _tiomap_io.h ========
- *  Description:
- *      Definitions, types and function prototypes for the io
- *      (r/w external mem).
- *
- *! Revision History
- *! ================
- *! 08-Oct-2002 rr:  Created.
- */
-
 #ifndef _TIOMAP_IO_
 #define _TIOMAP_IO_
 
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/tiomap_sm.c kernel-power-2.6.28/drivers/dsp/bridge/wmd/tiomap_sm.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/tiomap_sm.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/tiomap_sm.c	2011-05-02 22:36:51.000000000 +0100
@@ -28,8 +28,6 @@
 
 #define MAILBOX_FIFOSTATUS(m) (0x80 + 4 * (m))
 
-extern unsigned short min_active_opp;
-
 static inline unsigned int fifo_full(void __iomem *mbox_base, int mbox_id)
 {
 	return __raw_readl(mbox_base + MAILBOX_FIFOSTATUS(mbox_id)) & 0x1;
@@ -42,7 +40,6 @@ DSP_STATUS CHNLSM_EnableInterrupt(struct
 	u32 mbxValue;
 	struct CFG_HOSTRES resources;
 	u32 devType;
-	struct IO_MGR *hIOMgr;
 
 	DBG_Trace(DBG_ENTER, "CHNLSM_EnableInterrupt(0x%x)\n", pDevContext);
 
@@ -51,7 +48,6 @@ DSP_STATUS CHNLSM_EnableInterrupt(struct
 	CFG_GetHostResources((struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
 			     &resources);
 	DEV_GetDevType(pDevContext->hDevObject, &devType);
-	status = DEV_GetIOMgr(pDevContext->hDevObject, &hIOMgr);
 	if (devType == DSP_UNIT) {
 		HW_MBOX_NumMsgGet(resources.dwMboxBase,
 				  MBOX_DSP2ARM, &numMbxMsg);
@@ -100,6 +96,11 @@ DSP_STATUS CHNLSM_DisableInterrupt(struc
 DSP_STATUS CHNLSM_InterruptDSP2(struct WMD_DEV_CONTEXT *pDevContext,
 				u16 wMbVal)
 {
+#ifdef CONFIG_BRIDGE_DVFS
+	struct dspbridge_platform_data *pdata =
+		omap_dspbridge_dev->dev.platform_data;
+	u32 opplevel = 0;
+#endif
 	struct CFG_HOSTRES resources;
 	DSP_STATUS status = DSP_SOK;
 	unsigned long timeout;
@@ -113,14 +114,12 @@ DSP_STATUS CHNLSM_InterruptDSP2(struct W
 	if (pDevContext->dwBrdState == BRD_DSP_HIBERNATION ||
 	    pDevContext->dwBrdState == BRD_HIBERNATION) {
 #ifdef CONFIG_BRIDGE_DVFS
-		struct dspbridge_platform_data *pdata =
-			omap_dspbridge_dev->dev.platform_data;
-		/*
-		 * When Smartreflex is ON, DSP requires at least OPP level 3
-		 * to operate reliably. So boost lower OPP levels to OPP3.
-		 */
-		if (pdata->dsp_set_min_opp)
-			(*pdata->dsp_set_min_opp)(min_active_opp);
+		if (pdata->dsp_get_opp)
+			opplevel = (*pdata->dsp_get_opp)();
+		if (opplevel == VDD1_OPP1) {
+			if (pdata->dsp_set_min_opp)
+				(*pdata->dsp_set_min_opp)(VDD1_OPP2);
+		}
 #endif
 		/* Restart the peripheral clocks */
 		DSP_PeripheralClocks_Enable(pDevContext, NULL);
@@ -140,13 +139,6 @@ DSP_STATUS CHNLSM_InterruptDSP2(struct W
 		temp = (temp & 0xFFFFFF08) | 0x37;
 		*(REG_UWORD32 *)(resources.dwCmBase + 0x4) = temp;
 
-		/*
-		 * This delay is needed to avoid mailbox timed out
-		 * issue experienced while SmartReflex is ON.
-		 * TODO: Instead of 1 ms calculate proper value.
-		 */
-		mdelay(1);
-
 		/* Restore mailbox settings */
 		HW_MBOX_restoreSettings(resources.dwMboxBase);
 
@@ -154,6 +146,9 @@ DSP_STATUS CHNLSM_InterruptDSP2(struct W
 		temp = *(REG_UWORD32 *)(resources.dwDmmuBase + 0x10);
 
 		pDevContext->dwBrdState = BRD_RUNNING;
+	} else if (pDevContext->dwBrdState == BRD_RETENTION) {
+		/* Restart the peripheral clocks */
+		DSP_PeripheralClocks_Enable(pDevContext, NULL);
 	}
 
 	timeout = jiffies + msecs_to_jiffies(1);
diff -rupN kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/ue_deh.c kernel-power-2.6.28/drivers/dsp/bridge/wmd/ue_deh.c
--- kernel-power-2.6.28.orig/drivers/dsp/bridge/wmd/ue_deh.c	2011-04-17 17:32:26.000000000 +0100
+++ kernel-power-2.6.28/drivers/dsp/bridge/wmd/ue_deh.c	2011-05-02 22:36:51.000000000 +0100
@@ -3,6 +3,8 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
+ * Implements upper edge DSP exception handling (DEH) functions.
+ *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
  * This package is free software; you can redistribute it and/or modify
@@ -14,23 +16,6 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-
-/*
- *  ======== ue_deh.c ========
- *  Description:
- *      Implements upper edge DSP exception handling (DEH) functions.
- *
- *! Revision History:
- *! ================
- *! 03-Jan-2005 hn: Support for IVA DEH.
- *! 05-Jan-2004 vp: Updated for the 24xx HW library.
- *! 19-Feb-2003 vp: Code review updates.
- *!                 - Cosmetic changes.
- *! 18-Oct-2002 sb: Ported to Linux platform.
- *! 10-Dec-2001 kc: Updated DSP error reporting in DEBUG mode.
- *! 10-Sep-2001 kc: created.
- */
-
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
 
@@ -44,9 +29,7 @@
 #include <dspbridge/dbg.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/csl.h>
 #include <dspbridge/cfg.h>
-#include <dspbridge/dpc.h>
 #include <dspbridge/mem.h>
 #include <dspbridge/ntfy.h>
 #include <dspbridge/drv.h>
@@ -103,12 +86,11 @@ DSP_STATUS WMD_DEH_Create(OUT struct DEH
 		status = DSP_EMEMORY;
 	} else {
 		/* Create an NTFY object to manage notifications */
-		if (DSP_SUCCEEDED(status))
-			status = NTFY_Create(&pDehMgr->hNtfy);
+		status = NTFY_Create(&pDehMgr->hNtfy);
+
+		/* Create a MMUfault DPC */
+		tasklet_init(&pDehMgr->dpc_tasklet, MMU_FaultDpc, (u32)pDehMgr);
 
-		/* Create a DPC object. */
-		status = DPC_Create(&pDehMgr->hMmuFaultDpc, MMU_FaultDpc,
-				   (void *)pDehMgr);
 		if (DSP_SUCCEEDED(status))
 			status = DEV_GetDevNode(hDevObject, &hDevNode);
 
@@ -123,11 +105,11 @@ DSP_STATUS WMD_DEH_Create(OUT struct DEH
 			pDehMgr->errInfo.dwVal2 = 0L;
 			pDehMgr->errInfo.dwVal3 = 0L;
 			/* Install ISR function for DSP MMU fault */
-                       if ((request_irq(INT_DSP_MMU_IRQ, MMU_FaultIsr, 0,
-                                           "DspBridge\tiommu fault", (void *)pDehMgr)) == 0)
-                               status = DSP_SOK;
-                       else
-                               status = DSP_EFAIL;
+			if ((request_irq(INT_DSP_MMU_IRQ, MMU_FaultIsr, 0,
+			   "DspBridge\tiommu fault", (void *)pDehMgr)) == 0)
+				status = DSP_SOK;
+			else
+				status = DSP_EFAIL;
 		}
 	}
 	if (DSP_FAILED(status)) {
@@ -136,8 +118,7 @@ DSP_STATUS WMD_DEH_Create(OUT struct DEH
 		*phDehMgr = NULL;
 	} else {
 		*phDehMgr = (struct DEH_MGR *)pDehMgr;
-               DBG_Trace(DBG_LEVEL1, "ISR_IRQ Object 0x%x \n",
-                                        pDehMgr);
+		DBG_Trace(DBG_LEVEL1, "ISR_IRQ Object 0x%x \n", pDehMgr);
 	}
 	DBG_Trace(DBG_LEVEL1, "Exiting DEH_Create.\n");
 	return status;
@@ -160,8 +141,12 @@ DSP_STATUS WMD_DEH_Destroy(struct DEH_MG
 		if (pDehMgr->hNtfy)
 			(void)NTFY_Delete(pDehMgr->hNtfy);
 		/* Disable DSP MMU fault */
-               free_irq(INT_DSP_MMU_IRQ, pDehMgr);
-		(void)DPC_Destroy(pDehMgr->hMmuFaultDpc);
+		free_irq(INT_DSP_MMU_IRQ, pDehMgr);
+
+		/* Free DPC object */
+		tasklet_kill(&pDehMgr->dpc_tasklet);
+		DBG_Trace(GT_2CLASS, "DPC_Destroy: SUCCESS\n");
+
 		/* Deallocate the DEH manager object */
 		MEM_FreeObject(pDehMgr);
 	}
@@ -202,7 +187,6 @@ void WMD_DEH_Notify(struct DEH_MGR *hDeh
 	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)hDehMgr;
 	struct WMD_DEV_CONTEXT *pDevContext;
 	DSP_STATUS status = DSP_SOK;
-	DSP_STATUS status1 = DSP_EFAIL;
 	u32 memPhysical = 0;
 	u32 HW_MMU_MAX_TLB_COUNT = 31;
 	extern u32 faultAddr;
@@ -281,6 +265,7 @@ DBG_Trace(DBG_LEVEL6, "WMD_DEH_Notify: D
 			HW_MMU_EventAck(resources.dwDmmuBase,
 					 HW_MMU_TRANSLATION_FAULT);
 			break;
+#ifdef CONFIG_BRIDGE_NTFY_PWRERR
 		case DSP_PWRERROR:
 			/* reset errInfo structure before use */
 			pDehMgr->errInfo.dwErrMask = DSP_PWRERROR;
@@ -291,6 +276,7 @@ DBG_Trace(DBG_LEVEL6, "WMD_DEH_Notify: D
 			printk(KERN_ERR "WMD_DEH_Notify: DSP_PWRERROR, errInfo "
 					"= 0x%x\n", dwErrInfo);
 			break;
+#endif /* CONFIG_BRIDGE_NTFY_PWRERR */
 		default:
 			DBG_Trace(DBG_LEVEL6,
 				 "WMD_DEH_Notify: Unknown Error, errInfo = "
@@ -299,16 +285,8 @@ DBG_Trace(DBG_LEVEL6, "WMD_DEH_Notify: D
 		}
 
 		/* Filter subsequent notifications when an error occurs */
-		if (pDevContext->dwBrdState != BRD_ERROR) {
-			/* Use it as a flag to send notifications the
-			 * first time and error occurred, next time
-			 * state will be BRD_ERROR */
-			status1 = DSP_EFAIL;
-		}
-
-		/* Filter subsequent notifications when an error occurs */
 		if (pDevContext->dwBrdState != BRD_ERROR)
-			status1 = DSP_SOK;
+			NTFY_Notify(pDehMgr->hNtfy, ulEventMask);
 
 		/* Set the Board state as ERROR */
 		pDevContext->dwBrdState = BRD_ERROR;
@@ -317,11 +295,6 @@ DBG_Trace(DBG_LEVEL6, "WMD_DEH_Notify: D
 		/* Call DSP Trace Buffer */
 		PrintDspTraceBuffer(hDehMgr->hWmdContext);
 
-		if (DSP_SUCCEEDED(status1)) {
-			/* Signal DSP error/exception event. */
-			NTFY_Notify(pDehMgr->hNtfy, ulEventMask);
-		}
-
 	}
 	DBG_Trace(DBG_LEVEL1, "Exiting WMD_DEH_Notify\n");
 
@@ -349,6 +322,8 @@ DSP_STATUS WMD_DEH_GetInfo(struct DEH_MG
 		pErrInfo->dwVal1 = pDehMgr->errInfo.dwVal1;
 		pErrInfo->dwVal2 = pDehMgr->errInfo.dwVal2;
 		pErrInfo->dwVal3 = pDehMgr->errInfo.dwVal3;
+	} else {
+		status = DSP_EHANDLE;
 	}
 
 	DBG_Trace(DBG_LEVEL1, "Exiting WMD_DEH_GetInfo\n");
