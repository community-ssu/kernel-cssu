--- kernel-power-2.6.28.orig/drivers/usb/musb/musb_core.c
+++ kernel-power-2.6.28/drivers/usb/musb/musb_core.c
@@ -241,8 +241,10 @@
 			r = musb_readb(musb->mregs, MUSB_DEVCTL);
 			if ((r & MUSB_DEVCTL_VBUS)
 					== (3 << MUSB_DEVCTL_VBUS_SHIFT)) {
+#ifdef	CONFIG_USB_MUSB_OTG
 				musb_save_ctx_and_suspend(&musb->g, 0);
 				musb_restore_ctx_and_resume(&musb->g);
+#endif
 				if (musb->board && musb->board->set_pm_limits)
 					musb->board->set_pm_limits(
 							musb->controller, 1);
@@ -1980,7 +1982,11 @@
 	int		ret = -EINVAL;
 
 	spin_lock_irqsave(&musb->lock, flags);
+#ifdef	CONFIG_USB_MUSB_OTG
 	ret = sprintf(buf, "%d\n", musb->softconnect);
+#else
+        ret = 0;
+#endif
 	spin_unlock_irqrestore(&musb->lock, flags);
 
 	return ret;
@@ -2003,6 +2009,7 @@
 	}
 
 	spin_lock_irqsave(&musb->lock, flags);
+#ifdef	CONFIG_USB_MUSB_OTG
 
 	power = musb_readb(musb->mregs, MUSB_POWER);
 
@@ -2013,7 +2020,7 @@
 
 	musb->softconnect = !!val;
 	musb_writeb(musb->mregs, MUSB_POWER, power);
-
+#endif
 	spin_unlock_irqrestore(&musb->lock, flags);
 
 	return n;
@@ -2462,8 +2469,10 @@
 	/* Resets the controller. Has to be done. Without this, most likely
 	 * the state machine inside the transceiver doesn't get fixed properly
 	 */
+#ifdef	CONFIG_USB_MUSB_OTG
 	musb_save_ctx_and_suspend(&musb->g, 0);
 	musb_restore_ctx_and_resume(&musb->g);
+#endif
 
 	return 0;
 
--- kernel-power-2.6.28.orig/drivers/usb/musb/omap2430.c
+++ kernel-power-2.6.28/drivers/usb/musb/omap2430.c
@@ -161,7 +161,9 @@
 }
 void musb_platform_disable(struct musb *musb)
 {
+#ifdef CONFIG_USB_MUSB_OTG
 	twl4030_upd_usb_suspended(musb->is_suspended);
+#endif
 }
 static void omap_vbus_power(struct musb *musb, int is_on, int sleeping)
 {
@@ -364,6 +366,7 @@
 }
 
 #ifdef CONFIG_PM
+#ifdef CONFIG_USB_MUSB_OTG
 
 void musb_save_ctx_and_suspend(struct usb_gadget *gadget, int overwrite)
 {
@@ -471,3 +474,4 @@
 }
 EXPORT_SYMBOL_GPL(musb_restore_ctx_and_resume);
 #endif
+#endif
--- kernel-power-2.6.28.orig/drivers/usb/otg/twl4030-usb.c
+++ kernel-power-2.6.28/drivers/usb/otg/twl4030-usb.c
@@ -475,8 +475,11 @@
 	}
 }
 
+#ifdef CONFIG_USB_MUSB_OTG
+
 extern void musb_save_ctx_and_suspend(struct usb_gadget *gadget, int overwrite);
 extern void musb_restore_ctx_and_resume(struct usb_gadget *gadget);
+#endif
 
 static void twl4030_phy_suspend(struct twl4030_usb *twl, int controller_off)
 {
@@ -487,8 +490,10 @@
 	if (!controller_off)
 		twl->asleep = 1;
 
+#ifdef CONFIG_USB_MUSB_OTG
 	if (twl->otg.gadget)
 		musb_save_ctx_and_suspend(twl->otg.gadget, 0);
+#endif
 }
 
 static void twl4030_phy_resume(struct twl4030_usb *twl)
@@ -502,9 +507,10 @@
 	if (twl->usb_mode == T2_USB_MODE_ULPI)
 		twl4030_i2c_access(twl, 0);
 	twl->asleep = 0;
-
+#ifdef CONFIG_USB_MUSB_OTG
 	if (twl->otg.gadget)
 		musb_restore_ctx_and_resume(twl->otg.gadget);
+#endif
 }
 
 static int twl4030_usb_ldo_init(struct twl4030_usb *twl)
