diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/boot/compressed/head.S kernel-2.6.28-20093908+0m5/arch/arm/boot/compressed/head.S
--- kernel-2.6.28-20091602+0m5/arch/arm/boot/compressed/head.S	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/boot/compressed/head.S	2012-12-16 13:13:01.508330148 +0100
@@ -717,6 +717,9 @@ __armv7_mmu_cache_off:
 		bl	__armv7_mmu_cache_flush
 		mov	r0, #0
 		mcr	p15, 0, r0, c8, c7, 0	@ invalidate whole TLB
+		mcr	p15, 0, r0, c7, c5, 6	@ invalidate BTC
+		mcr	p15, 0, r0, c7, c10, 4	@ DSB
+		mcr	p15, 0, r0, c7, c5, 4	@ ISB
 		mov	pc, r12
 
 __arm6_mmu_cache_off:
@@ -778,12 +781,13 @@ __armv6_mmu_cache_flush:
 __armv7_mmu_cache_flush:
 		mrc	p15, 0, r10, c0, c1, 5	@ read ID_MMFR1
 		tst	r10, #0xf << 16		@ hierarchical cache (ARMv7)
-		beq	hierarchical
 		mov	r10, #0
+		beq	hierarchical
 		mcr	p15, 0, r10, c7, c14, 0	@ clean+invalidate D
 		b	iflush
 hierarchical:
-		stmfd	sp!, {r0-r5, r7, r9-r11}
+		mcr	p15, 0, r10, c7, c10, 5	@ DMB
+		stmfd	sp!, {r0-r5, r7, r9, r11}
 		mrc	p15, 1, r0, c0, c0, 1	@ read clidr
 		ands	r3, r0, #0x7000000	@ extract loc from clidr
 		mov	r3, r3, lsr #23		@ left align loc bit field
@@ -820,12 +824,14 @@ skip:
 		cmp	r3, r10
 		bgt	loop1
 finished:
+		ldmfd	sp!, {r0-r5, r7, r9, r11}
 		mov	r10, #0			@ swith back to cache level 0
 		mcr	p15, 2, r10, c0, c0, 0	@ select current cache level in cssr
-		ldmfd	sp!, {r0-r5, r7, r9-r11}
 iflush:
+		mcr	p15, 0, r10, c7, c10, 4	@ DSB
 		mcr	p15, 0, r10, c7, c5, 0	@ invalidate I+BTB
-		mcr	p15, 0, r10, c7, c10, 4	@ drain WB
+		mcr	p15, 0, r10, c7, c10, 4	@ DSB
+		mcr	p15, 0, r10, c7, c5, 4	@ ISB
 		mov	pc, lr
 
 __armv5tej_mmu_cache_flush:
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/configs/rx51_defconfig kernel-2.6.28-20093908+0m5/arch/arm/configs/rx51_defconfig
--- kernel-2.6.28-20091602+0m5/arch/arm/configs/rx51_defconfig	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/configs/rx51_defconfig	2012-12-16 13:13:01.512330148 +0100
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.28-omap1
-# Thu Apr  2 16:13:27 2009
+# Thu Jul  9 09:32:52 2009
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -47,12 +47,20 @@ CONFIG_BSD_PROCESS_ACCT=y
 # CONFIG_AUDIT is not set
 # CONFIG_IKCONFIG is not set
 CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_CGROUPS is not set
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+# CONFIG_CGROUP_NS is not set
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_DEVICE is not set
 CONFIG_GROUP_SCHED=y
 CONFIG_FAIR_GROUP_SCHED=y
 # CONFIG_RT_GROUP_SCHED is not set
 CONFIG_USER_SCHED=y
 # CONFIG_CGROUP_SCHED is not set
+# CONFIG_CGROUP_CPUACCT is not set
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_MM_OWNER=y
+CONFIG_CGROUP_MEM_RES_CTLR=y
 CONFIG_SYSFS_DEPRECATED=y
 CONFIG_SYSFS_DEPRECATED_V2=y
 # CONFIG_RELAY is not set
@@ -82,8 +90,9 @@ CONFIG_EVENTFD=y
 CONFIG_SHMEM=y
 CONFIG_AIO=y
 CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_SLAB=y
-# CONFIG_SLUB is not set
+CONFIG_SLUB_DEBUG=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
 # CONFIG_SLOB is not set
 CONFIG_PROFILING=y
 # CONFIG_MARKERS is not set
@@ -196,6 +205,7 @@ CONFIG_OMAP_MCBSP=y
 # CONFIG_OMAP_MMU_FWK is not set
 # CONFIG_OMAP_MBOX_FWK is not set
 CONFIG_OMAP_IOMMU=m
+# CONFIG_OMAP_IOMMU_DEBUG is not set
 # CONFIG_OMAP_MPU_TIMER is not set
 CONFIG_OMAP_32K_TIMER=y
 # CONFIG_OMAP3_DEBOBS is not set
@@ -567,7 +577,8 @@ CONFIG_EXTRA_FIRMWARE=""
 # CONFIG_DEBUG_DRIVER is not set
 # CONFIG_DEBUG_DEVRES is not set
 # CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_CONNECTOR is not set
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
 # CONFIG_MTD_CONCAT is not set
@@ -676,7 +687,6 @@ CONFIG_OMAP_STI_CONSOLE=y
 # CONFIG_C2PORT is not set
 CONFIG_OMAP_SSI=m
 CONFIG_SSI_MCSAAB_IMP=m
-# CONFIG_SSI_MCSAAB_DEBUG is not set
 CONFIG_SSI_CMT_SPEECH=m
 # CONFIG_SSI_CMT_SPEECH_DEBUG is not set
 CONFIG_HAVE_IDE=y
@@ -769,7 +779,9 @@ CONFIG_WLAN_80211=y
 # CONFIG_B43LEGACY is not set
 # CONFIG_ZD1211RW is not set
 # CONFIG_RT2X00 is not set
-CONFIG_WL12XX=m
+CONFIG_WL12XX=y
+CONFIG_WL1251=m
+# CONFIG_WL1271 is not set
 
 #
 # USB Network Adapters
@@ -879,7 +891,8 @@ CONFIG_SERIAL_CORE_CONSOLE=y
 CONFIG_UNIX98_PTYS=y
 # CONFIG_LEGACY_PTYS is not set
 # CONFIG_IPMI_HANDLER is not set
-CONFIG_HW_RANDOM=m
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_OMAP3_ROM=y
 # CONFIG_NVRAM is not set
 # CONFIG_R3964 is not set
 # CONFIG_RAW_DRIVER is not set
@@ -1101,15 +1114,23 @@ CONFIG_VIDEO_MEDIA=m
 #
 # CONFIG_MEDIA_ATTACH is not set
 CONFIG_MEDIA_TUNER=m
-# CONFIG_MEDIA_TUNER_CUSTOMIZE is not set
-CONFIG_MEDIA_TUNER_SIMPLE=m
-CONFIG_MEDIA_TUNER_TDA8290=m
-CONFIG_MEDIA_TUNER_TDA9887=m
-CONFIG_MEDIA_TUNER_TEA5761=m
-CONFIG_MEDIA_TUNER_TEA5767=m
-CONFIG_MEDIA_TUNER_MT20XX=m
-CONFIG_MEDIA_TUNER_XC2028=m
-CONFIG_MEDIA_TUNER_XC5000=m
+CONFIG_MEDIA_TUNER_CUSTOMIZE=y
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
 CONFIG_VIDEO_V4L2=m
 CONFIG_VIDEO_V4L1=m
 CONFIG_VIDEOBUF_GEN=m
@@ -1228,9 +1249,8 @@ CONFIG_I2C_BCM2048=m
 #
 CONFIG_PVR=m
 # CONFIG_DRM_VER_ORIG is not set
-CONFIG_DRM_VER_TUNGSTEN=y
-CONFIG_DRM_TUNGSTEN=y
-CONFIG_DRM_TUNGSTEN_PVR2D=m
+# CONFIG_DRM_VER_TUNGSTEN is not set
+# CONFIG_DRM_TUNGSTEN is not set
 # CONFIG_VGASTATE is not set
 # CONFIG_VIDEO_OUTPUT_CONTROL is not set
 CONFIG_FB=y
@@ -1255,6 +1275,7 @@ CONFIG_FB_CFB_IMAGEBLIT=y
 #
 # Frame buffer hardware drivers
 #
+# CONFIG_FB_UVESA is not set
 # CONFIG_FB_S1D13XXX is not set
 # CONFIG_FB_VIRTUAL is not set
 # CONFIG_FB_METRONOME is not set
@@ -1262,7 +1283,7 @@ CONFIG_FB_CFB_IMAGEBLIT=y
 CONFIG_FB_OMAP_BOOTLOADER_INIT=y
 CONFIG_FB_OMAP_CONSISTENT_DMA_SIZE=14
 CONFIG_OMAP2_DSS=y
-CONFIG_OMAP2_DSS_VRAM_SIZE=4
+CONFIG_OMAP2_DSS_VRAM_SIZE=0
 # CONFIG_OMAP2_DSS_DEBUG_SUPPORT is not set
 # CONFIG_OMAP2_DSS_RFBI is not set
 CONFIG_OMAP2_DSS_VENC=y
@@ -1276,6 +1297,9 @@ CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK=0
 #
 # CONFIG_PANEL_NEVADA is not set
 CONFIG_PANEL_ACX565AKM=y
+# CONFIG_PANEL_GENERIC is not set
+# CONFIG_PANEL_SAMSUNG_LTE430WQ_F0C is not set
+# CONFIG_PANEL_SHARP_LS037V7DW01 is not set
 CONFIG_FB_OMAP2=y
 # CONFIG_FB_OMAP2_DEBUG_SUPPORT is not set
 # CONFIG_FB_OMAP2_FORCE_AUTO_UPDATE is not set
@@ -1376,15 +1400,15 @@ CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
 CONFIG_USB_ARCH_HAS_EHCI=y
 CONFIG_USB=y
-CONFIG_USB_DEBUG=y
-CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
 
 #
 # Miscellaneous USB options
 #
 CONFIG_USB_DEVICEFS=y
-CONFIG_USB_DEVICE_CLASS=y
-# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_DEVICE_CLASS is not set
+CONFIG_USB_DYNAMIC_MINORS=y
 CONFIG_USB_SUSPEND=y
 CONFIG_USB_OTG=y
 CONFIG_USB_OTG_WHITELIST=y
@@ -1487,9 +1511,9 @@ CONFIG_USB_TEST=m
 # CONFIG_USB_ISIGHTFW is not set
 # CONFIG_USB_VST is not set
 CONFIG_USB_GADGET=m
-CONFIG_USB_GADGET_DEBUG=y
-CONFIG_USB_GADGET_DEBUG_FILES=y
-CONFIG_USB_GADGET_DEBUG_FS=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
 CONFIG_USB_GADGET_VBUS_DRAW=2
 CONFIG_USB_GADGET_SELECTED=y
 # CONFIG_USB_GADGET_AT91 is not set
@@ -1512,12 +1536,13 @@ CONFIG_USB_ZERO=m
 # CONFIG_USB_ETH is not set
 # CONFIG_USB_GADGETFS is not set
 CONFIG_USB_FILE_STORAGE=m
-# CONFIG_USB_FILE_STORAGE_TEST is not set
+CONFIG_USB_FILE_STORAGE_TEST=y
 # CONFIG_USB_G_SERIAL is not set
 # CONFIG_USB_MIDI_GADGET is not set
 # CONFIG_USB_G_PRINTER is not set
 # CONFIG_USB_CDC_COMPOSITE is not set
 CONFIG_USB_G_NOKIA=m
+CONFIG_USB_G_SOFTUPD=m
 
 #
 # OTG and related infrastructure
@@ -1528,7 +1553,7 @@ CONFIG_USB_OTG_UTILS=y
 CONFIG_TWL4030_USB=y
 CONFIG_MMC=m
 # CONFIG_MMC_DEBUG is not set
-# CONFIG_MMC_UNSAFE_RESUME is not set
+CONFIG_MMC_UNSAFE_RESUME=y
 
 #
 # MMC/SD/SDIO Card Drivers
@@ -1642,7 +1667,7 @@ CONFIG_REGULATOR_TWL4030=y
 # CONFIG_CBUS is not set
 CONFIG_MPU_BRIDGE=m
 CONFIG_BRIDGE_DVFS=y
-CONFIG_BRIDGE_MEMPOOL_SIZE=0x600000
+CONFIG_BRIDGE_MEMPOOL_SIZE=0x412800
 # CONFIG_BRIDGE_DEBUG is not set
 
 #
@@ -1825,14 +1850,13 @@ CONFIG_DEBUG_FS=y
 # CONFIG_HEADERS_CHECK is not set
 CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_SHIRQ is not set
-CONFIG_DETECT_SOFTLOCKUP=y
-# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
-CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
-CONFIG_SCHED_DEBUG=y
+# CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_SCHED_DEBUG is not set
 # CONFIG_SCHEDSTATS is not set
 CONFIG_TIMER_STATS=y
 # CONFIG_DEBUG_OBJECTS is not set
-# CONFIG_DEBUG_SLAB is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
 # CONFIG_DEBUG_PREEMPT is not set
 # CONFIG_DEBUG_RT_MUTEXES is not set
 # CONFIG_RT_MUTEX_TESTER is not set
@@ -1844,7 +1868,7 @@ CONFIG_TIMER_STATS=y
 # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
 # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
 # CONFIG_DEBUG_KOBJECT is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_BUGVERBOSE=y
 CONFIG_DEBUG_INFO=y
 # CONFIG_DEBUG_VM is not set
 # CONFIG_DEBUG_WRITECOUNT is not set
@@ -1893,7 +1917,7 @@ CONFIG_SECURITY=y
 # CONFIG_SECURITY_FILE_CAPABILITIES is not set
 # CONFIG_SECURITY_ROOTPLUG is not set
 CONFIG_SECURITY_LOWMEM=y
-CONFIG_SECURITY_DEFAULT_MMAP_MIN_ADDR=0
+CONFIG_SECURITY_DEFAULT_MMAP_MIN_ADDR=4096
 CONFIG_CRYPTO=y
 
 #
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/include/asm/cache.h kernel-2.6.28-20093908+0m5/arch/arm/include/asm/cache.h
--- kernel-2.6.28-20091602+0m5/arch/arm/include/asm/cache.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/include/asm/cache.h	2012-12-16 13:13:01.512330148 +0100
@@ -4,7 +4,23 @@
 #ifndef __ASMARM_CACHE_H
 #define __ASMARM_CACHE_H
 
-#define L1_CACHE_SHIFT		5
+#define L1_CACHE_SHIFT		6
 #define L1_CACHE_BYTES		(1 << L1_CACHE_SHIFT)
 
+/*
+ * Memory returned by kmalloc() may be used for DMA, so we must make
+ * sure that all such allocations are cache aligned. Otherwise,
+ * unrelated code may cause parts of the buffer to be read into the
+ * cache before the transfer is done, causing old data to be seen by
+ * the CPU.
+ */
+#define ARCH_KMALLOC_MINALIGN	L1_CACHE_BYTES
+
+/*
+ * With EABI on ARMv5 and above we must have 64-bit aligned slab pointers.
+ */
+#if defined(CONFIG_AEABI) && (__LINUX_ARM_ARCH__ >= 5)
+#define ARCH_SLAB_MINALIGN 8
+#endif
+
 #endif
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/include/asm/elf.h kernel-2.6.28-20093908+0m5/arch/arm/include/asm/elf.h
--- kernel-2.6.28-20091602+0m5/arch/arm/include/asm/elf.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/include/asm/elf.h	2012-12-16 13:13:01.512330148 +0100
@@ -45,11 +45,13 @@ typedef struct user_fp elf_fpregset_t;
 #define EF_ARM_HASENTRY		0x00000002	/* All */
 #define EF_ARM_RELEXEC		0x00000001	/* All */
 
-#define R_ARM_NONE	0
-#define R_ARM_PC24	1
-#define R_ARM_ABS32	2
-#define R_ARM_CALL	28
-#define R_ARM_JUMP24	29
+#define R_ARM_NONE		0
+#define R_ARM_PC24		1
+#define R_ARM_ABS32		2
+#define R_ARM_CALL		28
+#define R_ARM_JUMP24		29
+#define R_ARM_MOVW_ABS_NC	43
+#define R_ARM_MOVT_ABS		44
 
 /*
  * These are used to set parameters in the core dumps.
@@ -94,6 +96,10 @@ extern int arm_elf_read_implies_exec(con
 #define USE_ELF_CORE_DUMP
 #define ELF_EXEC_PAGESIZE	4096
 
+int dump_task_regs(struct task_struct *t, elf_gregset_t *elfregs);
+
+#define ELF_CORE_COPY_TASK_REGS dump_task_regs
+
 /* This is the location that an ET_DYN program is loaded if exec'ed.  Typical
    use of this is to invoke "./ld.so someprog" to test out a new version of
    the loader.  We need to make sure that it is out of the way of the program
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/include/asm/hwcap.h kernel-2.6.28-20093908+0m5/arch/arm/include/asm/hwcap.h
--- kernel-2.6.28-20091602+0m5/arch/arm/include/asm/hwcap.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/include/asm/hwcap.h	2012-12-16 13:13:01.512330148 +0100
@@ -16,6 +16,9 @@
 #define HWCAP_IWMMXT	512
 #define HWCAP_CRUNCH	1024
 #define HWCAP_THUMBEE	2048
+#define HWCAP_NEON	4096
+#define HWCAP_VFPv3	8192
+#define HWCAP_VFPv3D16	16384
 
 #if defined(__KERNEL__) && !defined(__ASSEMBLY__)
 /*
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/include/asm/page.h kernel-2.6.28-20093908+0m5/arch/arm/include/asm/page.h
--- kernel-2.6.28-20091602+0m5/arch/arm/include/asm/page.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/include/asm/page.h	2012-12-16 13:13:01.512330148 +0100
@@ -188,13 +188,6 @@ typedef struct page *pgtable_t;
 	(((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0) | \
 	 VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
-/*
- * With EABI on ARMv5 and above we must have 64-bit aligned slab pointers.
- */
-#if defined(CONFIG_AEABI) && (__LINUX_ARM_ARCH__ >= 5)
-#define ARCH_SLAB_MINALIGN 8
-#endif
-
 #include <asm-generic/page.h>
 
 #endif
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/include/asm/ptrace.h kernel-2.6.28-20093908+0m5/arch/arm/include/asm/ptrace.h
--- kernel-2.6.28-20091602+0m5/arch/arm/include/asm/ptrace.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/include/asm/ptrace.h	2012-12-16 13:13:01.512330148 +0100
@@ -27,6 +27,8 @@
 /* PTRACE_SYSCALL is 24 */
 #define PTRACE_GETCRUNCHREGS	25
 #define PTRACE_SETCRUNCHREGS	26
+#define PTRACE_GETVFPREGS	27
+#define PTRACE_SETVFPREGS	28
 
 /*
  * PSR bits
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/include/asm/thread_info.h kernel-2.6.28-20093908+0m5/arch/arm/include/asm/thread_info.h
--- kernel-2.6.28-20091602+0m5/arch/arm/include/asm/thread_info.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/include/asm/thread_info.h	2012-12-16 13:13:01.512330148 +0100
@@ -113,6 +113,8 @@ extern void iwmmxt_task_restore(struct t
 extern void iwmmxt_task_release(struct thread_info *);
 extern void iwmmxt_task_switch(struct thread_info *);
 
+extern void vfp_sync_state(struct thread_info *thread);
+
 #endif
 
 /*
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/include/asm/ucontext.h kernel-2.6.28-20093908+0m5/arch/arm/include/asm/ucontext.h
--- kernel-2.6.28-20091602+0m5/arch/arm/include/asm/ucontext.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/include/asm/ucontext.h	2012-12-16 13:13:01.512330148 +0100
@@ -59,23 +59,19 @@ struct iwmmxt_sigframe {
 #endif /* CONFIG_IWMMXT */
 
 #ifdef CONFIG_VFP
-#if __LINUX_ARM_ARCH__ < 6
-/* For ARM pre-v6, we use fstmiax and fldmiax.  This adds one extra
- * word after the registers, and a word of padding at the end for
- * alignment.  */
 #define VFP_MAGIC		0x56465001
-#define VFP_STORAGE_SIZE	152
-#else
-#define VFP_MAGIC		0x56465002
-#define VFP_STORAGE_SIZE	144
-#endif
 
 struct vfp_sigframe
 {
 	unsigned long		magic;
 	unsigned long		size;
-	union vfp_state		storage;
-};
+	struct user_vfp		ufp;
+	unsigned long		reserved;
+} __attribute__((__aligned__(8)));
+
+/* 8 byte for magic and size, 260 byte for ufp and 4 byte padding */
+#define VFP_STORAGE_SIZE	sizeof(struct vfp_sigframe)
+
 #endif /* CONFIG_VFP */
 
 /*
@@ -91,7 +87,7 @@ struct aux_sigframe {
 #ifdef CONFIG_IWMMXT
 	struct iwmmxt_sigframe	iwmmxt;
 #endif
-#if 0 && defined CONFIG_VFP /* Not yet saved.  */
+#ifdef CONFIG_VFP
 	struct vfp_sigframe	vfp;
 #endif
 	/* Something that isn't a valid magic number for any coprocessor.  */
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/include/asm/user.h kernel-2.6.28-20093908+0m5/arch/arm/include/asm/user.h
--- kernel-2.6.28-20091602+0m5/arch/arm/include/asm/user.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/include/asm/user.h	2012-12-16 13:13:01.512330148 +0100
@@ -81,4 +81,13 @@ struct user{
 #define HOST_TEXT_START_ADDR (u.start_code)
 #define HOST_STACK_END_ADDR (u.start_stack + u.u_ssize * NBPG)
 
+/*
+ * User specific VFP registers. If only VFPv2 is present, registers 16 to 31
+ * are ignored by the ptrace system call.
+ */
+struct user_vfp {
+	unsigned long long fpregs[32];
+	unsigned long fpscr;
+};
+
 #endif /* _ARM_USER_H */
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/kernel/irq.c kernel-2.6.28-20093908+0m5/arch/arm/kernel/irq.c
--- kernel-2.6.28-20091602+0m5/arch/arm/kernel/irq.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/kernel/irq.c	2012-12-16 13:13:01.512330148 +0100
@@ -98,12 +98,6 @@ unlock:
 	return 0;
 }
 
-/* Handle bad interrupts */
-static struct irq_desc bad_irq_desc = {
-	.handle_irq = handle_bad_irq,
-	.lock = SPIN_LOCK_UNLOCKED
-};
-
 /*
  * do_IRQ handles all hardware IRQ's.  Decoded IRQs should not
  * come via this function.  Instead, they should provide their
@@ -119,10 +113,13 @@ asmlinkage void __exception asm_do_IRQ(u
 	 * Some hardware gives randomly wrong interrupts.  Rather
 	 * than crashing, do something sensible.
 	 */
-	if (irq >= NR_IRQS)
-		handle_bad_irq(irq, &bad_irq_desc);
-	else
+	if (unlikely(irq >= NR_IRQS)) {
+		if (printk_ratelimit())
+			printk(KERN_WARNING "Bad IRQ%u\n", irq);
+		ack_bad_irq(irq);
+	} else {
 		generic_handle_irq(irq);
+	}
 
 	/* AT91 specific workaround */
 	irq_finish(irq);
@@ -160,10 +157,6 @@ void __init init_IRQ(void)
 	for (irq = 0; irq < NR_IRQS; irq++)
 		irq_desc[irq].status |= IRQ_NOREQUEST | IRQ_NOPROBE;
 
-#ifdef CONFIG_SMP
-	bad_irq_desc.affinity = CPU_MASK_ALL;
-	bad_irq_desc.cpu = smp_processor_id();
-#endif
 	init_arch_irq();
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/kernel/module.c kernel-2.6.28-20093908+0m5/arch/arm/kernel/module.c
--- kernel-2.6.28-20091602+0m5/arch/arm/kernel/module.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/kernel/module.c	2012-12-16 13:13:01.512330148 +0100
@@ -132,6 +132,21 @@ apply_relocate(Elf32_Shdr *sechdrs, cons
 			*(u32 *)loc |= offset & 0x00ffffff;
 			break;
 
+		case R_ARM_MOVW_ABS_NC:
+		case R_ARM_MOVT_ABS:
+			offset = *(u32 *)loc;
+			offset = ((offset & 0xf0000) >> 4) | (offset & 0xfff);
+			offset = (offset ^ 0x8000) - 0x8000;
+
+			offset += sym->st_value;
+			if (ELF32_R_TYPE(rel->r_info) == R_ARM_MOVT_ABS)
+				offset >>= 16;
+
+			*(u32 *)loc &= 0xfff0f000;
+			*(u32 *)loc |= ((offset & 0xf000) << 4) |
+					(offset & 0x0fff);
+			break;
+
 		default:
 			printk(KERN_ERR "%s: unknown relocation: %u\n",
 			       module->name, ELF32_R_TYPE(rel->r_info));
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/kernel/process.c kernel-2.6.28-20093908+0m5/arch/arm/kernel/process.c
--- kernel-2.6.28-20091602+0m5/arch/arm/kernel/process.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/kernel/process.c	2012-12-16 13:13:01.512330148 +0100
@@ -349,6 +349,15 @@ copy_thread(int nr, unsigned long clone_
 }
 
 /*
+ * Fill in the task's elfregs structure for a core dump
+ */
+int dump_task_regs(struct task_struct *t, elf_gregset_t *elfregs)
+{
+	elf_core_copy_regs(elfregs, task_pt_regs(t));
+	return 1;
+}
+
+/*
  * fill in the fpe structure for a core dump...
  */
 int dump_fpu (struct pt_regs *regs, struct user_fp *fp)
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/kernel/ptrace.c kernel-2.6.28-20093908+0m5/arch/arm/kernel/ptrace.c
--- kernel-2.6.28-20091602+0m5/arch/arm/kernel/ptrace.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/kernel/ptrace.c	2012-12-16 13:13:01.512330148 +0100
@@ -653,6 +653,54 @@ static int ptrace_setcrunchregs(struct t
 }
 #endif
 
+#ifdef CONFIG_VFP
+/*
+ * Get the child VFP state.
+ */
+static int ptrace_getvfpregs(struct task_struct *tsk, void __user *data)
+{
+	struct thread_info *thread = task_thread_info(tsk);
+	union vfp_state *vfp = &thread->vfpstate;
+	struct user_vfp __user *ufp = data;
+
+	vfp_sync_state(thread);
+
+	/* copy the floating point registers */
+	if (copy_to_user(&ufp->fpregs, &vfp->hard.fpregs,
+			 sizeof(vfp->hard.fpregs)))
+		return -EFAULT;
+
+	/* copy the status and control register */
+	if (put_user(vfp->hard.fpscr, &ufp->fpscr))
+		return -EFAULT;
+
+	return 0;
+}
+
+/*
+ * Set the child VFP state.
+ */
+static int ptrace_setvfpregs(struct task_struct *tsk, void __user *data)
+{
+	struct thread_info *thread = task_thread_info(tsk);
+	union vfp_state *vfp = &thread->vfpstate;
+	struct user_vfp __user *ufp = data;
+
+	vfp_sync_state(thread);
+
+	/* copy the floating point registers */
+	if (copy_from_user(&vfp->hard.fpregs, &ufp->fpregs,
+			   sizeof(vfp->hard.fpregs)))
+		return -EFAULT;
+
+	/* copy the status and control register */
+	if (get_user(vfp->hard.fpscr, &ufp->fpscr))
+		return -EFAULT;
+
+	return 0;
+}
+#endif
+
 long arch_ptrace(struct task_struct *child, long request, long addr, long data)
 {
 	int ret;
@@ -775,6 +823,16 @@ long arch_ptrace(struct task_struct *chi
 			break;
 #endif
 
+#ifdef CONFIG_VFP
+		case PTRACE_GETVFPREGS:
+			ret = ptrace_getvfpregs(child, (void __user *)data);
+			break;
+
+		case PTRACE_SETVFPREGS:
+			ret = ptrace_setvfpregs(child, (void __user *)data);
+			break;
+#endif
+
 		default:
 			ret = ptrace_request(child, request, addr, data);
 			break;
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/kernel/setup.c kernel-2.6.28-20093908+0m5/arch/arm/kernel/setup.c
--- kernel-2.6.28-20091602+0m5/arch/arm/kernel/setup.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/kernel/setup.c	2012-12-16 13:13:01.512330148 +0100
@@ -772,6 +772,10 @@ static const char *hwcap_str[] = {
 	"java",
 	"iwmmxt",
 	"crunch",
+	"thumbee",
+	"neon",
+	"vfpv3",
+	"vfpv3d16",
 	NULL
 };
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/kernel/signal.c kernel-2.6.28-20093908+0m5/arch/arm/kernel/signal.c
--- kernel-2.6.28-20091602+0m5/arch/arm/kernel/signal.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/kernel/signal.c	2012-12-16 13:13:01.512330148 +0100
@@ -196,6 +196,67 @@ static int restore_iwmmxt_context(struct
 
 #endif
 
+#ifdef CONFIG_VFP
+
+static int preserve_vfp_context(struct vfp_sigframe __user *frame)
+{
+	struct thread_info *thread = current_thread_info();
+	struct vfp_hard_struct *h = &thread->vfpstate.hard;
+	const unsigned long magic = VFP_MAGIC;
+	const unsigned long size = VFP_STORAGE_SIZE;
+	int err = 0;
+
+	vfp_sync_state(thread);
+	__put_user_error(magic, &frame->magic, err);
+	__put_user_error(size, &frame->size, err);
+
+	/*
+	 * Copy the floating point registers. There can be unused
+	 * registers see asm/hwcap.h for details.
+	 */
+	err |= __copy_to_user(&frame->ufp.fpregs, &h->fpregs,
+			      sizeof(h->fpregs));
+	/*
+	 * Copy the status and control register.
+	 */
+	__put_user_error(h->fpscr, &frame->ufp.fpscr, err);
+
+	return err ? -EFAULT : 0;
+}
+
+static int restore_vfp_context(struct vfp_sigframe __user *frame)
+{
+	struct thread_info *thread = current_thread_info();
+	struct vfp_hard_struct *h = &thread->vfpstate.hard;
+	unsigned long magic;
+	unsigned long size;
+	int err = 0;
+
+	vfp_sync_state(thread);
+	__get_user_error(magic, &frame->magic, err);
+	__get_user_error(size, &frame->size, err);
+
+	if (err)
+		return -EFAULT;
+	if (magic != VFP_MAGIC || size != VFP_STORAGE_SIZE)
+		return -EINVAL;
+
+	/*
+	 * Copy the floating point registers. There can be unused
+	 * registers see asm/hwcap.h for details.
+	 */
+	err |= __copy_from_user(&h->fpregs, &frame->ufp.fpregs,
+				sizeof(h->fpregs));
+	/*
+	 * Copy the status and control register.
+	 */
+	__get_user_error(h->fpscr, &frame->ufp.fpscr, err);
+
+	return err ? -EFAULT : 0;
+}
+
+#endif
+
 /*
  * Do a signal return; undo the signal stack.  These are aligned to 64-bit.
  */
@@ -254,8 +315,8 @@ static int restore_sigframe(struct pt_re
 		err |= restore_iwmmxt_context(&aux->iwmmxt);
 #endif
 #ifdef CONFIG_VFP
-//	if (err == 0)
-//		err |= vfp_restore_state(&sf->aux.vfp);
+	if (err == 0)
+		err |= restore_vfp_context(&aux->vfp);
 #endif
 
 	return err;
@@ -369,8 +430,8 @@ setup_sigframe(struct sigframe __user *s
 		err |= preserve_iwmmxt_context(&aux->iwmmxt);
 #endif
 #ifdef CONFIG_VFP
-//	if (err == 0)
-//		err |= vfp_save_state(&sf->aux.vfp);
+	if (err == 0)
+		err |= preserve_vfp_context(&aux->vfp);
 #endif
 	__put_user_error(0, &aux->end_magic, err);
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-apollon.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-apollon.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-apollon.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-apollon.c	2012-12-16 13:13:01.512330148 +0100
@@ -323,7 +323,7 @@ out:
 
 static void __init omap_apollon_init_irq(void)
 {
-	omap2_init_common_hw(NULL, NULL, NULL, NULL);
+	omap2_init_common_hw(NULL, NULL, NULL, NULL, NULL);
 	omap_init_irq();
 	omap_gpio_init();
 	apollon_init_smc91x();
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-generic.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-generic.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-generic.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-generic.c	2012-12-16 13:13:01.512330148 +0100
@@ -33,7 +33,7 @@
 
 static void __init omap_generic_init_irq(void)
 {
-	omap2_init_common_hw(NULL, NULL, NULL, NULL);
+	omap2_init_common_hw(NULL, NULL, NULL, NULL, NULL);
 	omap_init_irq();
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-h4.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-h4.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-h4.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-h4.c	2012-12-16 13:13:01.512330148 +0100
@@ -348,7 +348,7 @@ static void __init h4_init_flash(void)
 
 static void __init omap_h4_init_irq(void)
 {
-	omap2_init_common_hw(NULL, NULL, NULL, NULL);
+	omap2_init_common_hw(NULL, NULL, NULL, NULL, NULL);
 	omap_init_irq();
 	omap_gpio_init();
 	h4_init_flash();
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-ldp.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-ldp.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-ldp.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-ldp.c	2012-12-16 13:13:01.512330148 +0100
@@ -345,7 +345,7 @@ static inline void __init ldp_init_smc91
 
 static void __init omap_ldp_init_irq(void)
 {
-	omap2_init_common_hw(NULL, NULL, NULL, NULL);
+	omap2_init_common_hw(NULL, NULL, NULL, NULL, NULL);
 	omap_init_irq();
 	omap_gpio_init();
 	ldp_init_smc911x();
@@ -529,7 +529,7 @@ static void __init omap_ldp_init(void)
 	msecure_init();
 	ads7846_dev_init();
 	omap_serial_init();
-	usb_musb_init();
+	usb_musb_init(NULL);
 	twl4030_mmc_init(mmc);
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-n800.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-n800.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-n800.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-n800.c	2012-12-16 13:13:01.512330148 +0100
@@ -51,6 +51,9 @@
 #define N800_DAV_IRQ_GPIO		103
 #define N800_TSC2301_RESET_GPIO		118
 
+#define N810_TSC2005_IRQ_GPIO		106
+#define N810_TSC2005_RESET_GPIO		94
+
 #ifdef CONFIG_MACH_NOKIA_N810
 static s16 rx44_keymap[LM8323_KEYMAP_SIZE] = {
 	[0x01] = KEY_Q,
@@ -123,7 +126,7 @@ static struct lm8323_platform_data lm832
 
 void __init nokia_n800_init_irq(void)
 {
-	omap2_init_common_hw(NULL, NULL, NULL, NULL);
+	omap2_init_common_hw(NULL, NULL, NULL, NULL, NULL);
 	omap_init_irq();
 	omap_gpio_init();
 
@@ -363,8 +366,9 @@ static struct omap2_mcspi_device_config
 
 #ifdef CONFIG_TOUCHSCREEN_TSC2005
 static struct tsc2005_platform_data tsc2005_config = {
-	.reset_gpio = 94,
-	.dav_gpio = 106
+	.esd_timeout	= 8*1000, /* ms of inactivity before we check */
+
+	.set_reset	= NULL
 };
 
 static struct omap2_mcspi_device_config tsc2005_mcspi_config = {
@@ -465,6 +469,35 @@ static void __init tsc2005_set_config(vo
 	}
 }
 
+#ifdef CONFIG_TOUCHSCREEN_TSC2005
+static void n810_tsc2005_set_reset(bool enable)
+{
+	gpio_set_value(N810_TSC2005_RESET_GPIO, enable);
+}
+#endif
+
+static void __init n810_init_tsc2005(void)
+{
+#ifdef CONFIG_TOUCHSCREEN_TSC2005
+	int r;
+
+	r = gpio_request(N810_TSC2005_IRQ_GPIO, "tsc2005 DAV IRQ");
+	if (r >= 0)
+		gpio_direction_input(N810_TSC2005_IRQ_GPIO);
+	else
+		printk(KERN_ERR "unable to get DAV GPIO\n");
+
+	r = gpio_request(N810_TSC2005_RESET_GPIO, "tsc2005 reset");
+	if (r >= 0) {
+		gpio_direction_output(N810_TSC2005_RESET_GPIO, 1);
+		tsc2005_config.set_reset = n810_tsc2005_set_reset;
+	} else {
+		printk(KERN_ERR "unable to get tsc2005 reset GPIO\n");
+		tsc2005_config.esd_timeout = 0;
+	}
+#endif
+}
+
 #if defined(CONFIG_CBUS_RETU) && defined(CONFIG_LEDS_OMAP_PWM)
 
 void retu_keypad_led_set_power(struct omap_pwm_led_platform_data *self,
@@ -676,6 +709,7 @@ void __init nokia_n800_common_init(void)
 				ARRAY_SIZE(n800_spi_board_info));
 	if (machine_is_nokia_n810()) {
 		tsc2005_set_config();
+		n810_init_tsc2005();
 		spi_register_board_info(n810_spi_board_info,
 				ARRAY_SIZE(n810_spi_board_info));
 	}
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-n800-flash.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-n800-flash.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-n800-flash.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-n800-flash.c	2012-12-16 13:13:01.512330148 +0100
@@ -38,9 +38,21 @@ static struct platform_device n800_onena
 	},
 };
 
+static unsigned short omap2_onenand_readw(void __iomem *addr)
+{
+	return readw(addr);
+}
+
+static void omap2_onenand_writew(unsigned short value, void __iomem *addr)
+{
+	writew(value, addr);
+}
+
 static int omap2_onenand_set_async_mode(int cs, void __iomem *onenand_base)
 {
 	struct gpmc_timings t;
+	u32 reg;
+	int err;
 
 	const int t_cer = 15;
 	const int t_avdp = 12;
@@ -53,6 +65,11 @@ static int omap2_onenand_set_async_mode(
 	const int t_wpl = 40;
 	const int t_wph = 30;
 
+	/* Ensure sync read and sync write are disabled */
+	reg = omap2_onenand_readw(onenand_base + ONENAND_REG_SYS_CFG1);
+	reg &= ~ONENAND_SYS_CFG1_SYNC_READ & ~ONENAND_SYS_CFG1_SYNC_WRITE;
+	omap2_onenand_writew(reg, onenand_base + ONENAND_REG_SYS_CFG1);
+
 	memset(&t, 0, sizeof(t));
 	t.sync_clk = 0;
 	t.cs_on = 0;
@@ -84,17 +101,16 @@ static int omap2_onenand_set_async_mode(
 			  GPMC_CONFIG1_DEVICESIZE_16 |
 			  GPMC_CONFIG1_MUXADDDATA);
 
-	return gpmc_cs_set_timings(cs, &t);
-}
-
-static unsigned short omap2_onenand_readw(void __iomem *addr)
-{
-	return readw(addr);
-}
+	err = gpmc_cs_set_timings(cs, &t);
+	if (err)
+		return err;
+
+	/* Ensure sync read and sync write are disabled */
+	reg = omap2_onenand_readw(onenand_base + ONENAND_REG_SYS_CFG1);
+	reg &= ~ONENAND_SYS_CFG1_SYNC_READ & ~ONENAND_SYS_CFG1_SYNC_WRITE;
+	omap2_onenand_writew(reg, onenand_base + ONENAND_REG_SYS_CFG1);
 
-static void omap2_onenand_writew(unsigned short value, void __iomem *addr)
-{
-	writew(value, addr);
+	return 0;
 }
 
 static void set_onenand_cfg(void __iomem *onenand_base, int latency,
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-omap2evm.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-omap2evm.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-omap2evm.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-omap2evm.c	2012-12-16 13:13:01.516330148 +0100
@@ -277,7 +277,7 @@ static struct twl4030_keypad_data omap2e
 
 static void __init omap2_evm_init_irq(void)
 {
-	omap2_init_common_hw(NULL, NULL, NULL, NULL);
+	omap2_init_common_hw(NULL, NULL, NULL, NULL, NULL);
 	omap_init_irq();
 	omap_gpio_init();
 	omap2evm_init_smc911x();
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-omap3beagle.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-omap3beagle.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-omap3beagle.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-omap3beagle.c	2012-12-16 13:13:01.516330148 +0100
@@ -236,8 +236,11 @@ static int __init omap3_beagle_i2c_init(
 
 static void __init omap3_beagle_init_irq(void)
 {
-	omap2_init_common_hw(mt46h32m32lf6_sdrc_params, omap3_mpu_rate_table,
-			     omap3_dsp_rate_table, omap3_l3_rate_table);
+	omap2_init_common_hw(mt46h32m32lf6_sdrc_params,
+			     mt46h32m32lf6_sdrc_params,
+			     omap3_mpu_rate_table,
+			     omap3_dsp_rate_table,
+			     omap3_l3_rate_table);
 	omap_init_irq();
 	omap_gpio_init();
 }
@@ -367,9 +370,13 @@ static void __init omap3_beagle_init(voi
 	/* REVISIT leave DVI powered down until it's needed ... */
 	gpio_direction_output(170, true);
 
-	usb_musb_init();
+	usb_musb_init(NULL);
 	usb_ehci_init();
 	omap3beagle_flash_init();
+
+	/* Ensure SDRC pins are mux'd for self-refresh */
+	omap_cfg_reg(H16_34XX_SDRC_CKE0);
+	omap_cfg_reg(H17_34XX_SDRC_CKE1);
 }
 
 static void __init omap3_beagle_map_io(void)
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-omap3evm.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-omap3evm.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-omap3evm.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-omap3evm.c	2012-12-16 13:13:01.516330148 +0100
@@ -217,7 +217,10 @@ struct spi_board_info omap3evm_spi_board
 
 static void __init omap3_evm_init_irq(void)
 {
-	omap2_init_common_hw(mt46h32m32lf6_sdrc_params, NULL, NULL, NULL);
+	omap2_init_common_hw(mt46h32m32lf6_sdrc_params, NULL,
+			     omap3_mpu_rate_table,
+			     omap3_dsp_rate_table,
+			     omap3_l3_rate_table);
 	omap_init_irq();
 	omap_gpio_init();
 	omap3evm_init_smc911x();
@@ -256,7 +259,7 @@ static void __init omap3_evm_init(void)
 
 	omap_serial_init();
 	twl4030_mmc_init(mmc);
-	usb_musb_init();
+	usb_musb_init(NULL);
 	usb_ehci_init();
 	omap3evm_flash_init();
 	ads7846_dev_init();
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-omap3pandora.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-omap3pandora.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-omap3pandora.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-omap3pandora.c	2012-12-16 13:13:01.516330148 +0100
@@ -215,7 +215,8 @@ static int __init omap3pandora_i2c_init(
 
 static void __init omap3pandora_init_irq(void)
 {
-	omap2_init_common_hw(mt46h32m32lf6_sdrc_params);
+	omap2_init_common_hw(mt46h32m32lf6_sdrc_params, NULL,
+			     NULL, NULL, NULL);
 	omap_init_irq();
 	omap_gpio_init();
 }
@@ -297,7 +298,7 @@ static void __init omap3pandora_init(voi
 	omap_serial_init();
 	spi_register_board_info(omap3pandora_spi_board_info,
 			ARRAY_SIZE(omap3pandora_spi_board_info));
-	usb_musb_init();
+	usb_musb_init(NULL);
 	usb_ehci_init();
 	omap3pandora_flash_init();
 	omap3pandora_ads7846_init();
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-overo.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-overo.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-overo.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-overo.c	2012-12-16 13:13:01.516330148 +0100
@@ -44,6 +44,7 @@
 #include <mach/gpmc.h>
 #include <mach/hardware.h>
 #include <mach/nand.h>
+#include <mach/mux.h>
 #include <mach/usb-ehci.h>
 #include <mach/usb-musb.h>
 
@@ -184,7 +185,9 @@ static int __init overo_i2c_init(void)
 
 static void __init overo_init_irq(void)
 {
-	omap2_init_common_hw(mt46h32m32lf6_sdrc_params, NULL, NULL, NULL);
+	omap2_init_common_hw(mt46h32m32lf6_sdrc_params,
+			     mt46h32m32lf6_sdrc_params,
+			     NULL, NULL, NULL);
 	omap_init_irq();
 	omap_gpio_init();
 }
@@ -232,10 +235,14 @@ static void __init overo_init(void)
 	omap_board_config_size = ARRAY_SIZE(overo_config);
 	omap_serial_init();
 	twl4030_mmc_init(mmc);
-	usb_musb_init();
+	usb_musb_init(NULL);
 	usb_ehci_init();
 	overo_flash_init();
 
+	/* Ensure SDRC pins are mux'd for self-refresh */
+	omap_cfg_reg(H16_34XX_SDRC_CKE0);
+	omap_cfg_reg(H17_34XX_SDRC_CKE1);
+
 	if ((gpio_request(OVERO_GPIO_W2W_NRESET,
 			  "OVERO_GPIO_W2W_NRESET") == 0) &&
 	    (gpio_direction_output(OVERO_GPIO_W2W_NRESET, 1) == 0)) {
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-rx51-audio.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-rx51-audio.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-rx51-audio.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-rx51-audio.c	2012-12-16 13:13:01.516330148 +0100
@@ -13,6 +13,7 @@
 #include <linux/i2c.h>
 #include <linux/gpio.h>
 #include <linux/delay.h>
+#include <linux/i2c/twl4030.h>
 #include <linux/i2c/tpa6130a2.h>
 #include <media/radio-bcm2048.h>
 #include "../drivers/media/radio/radio-si4713.h"
@@ -30,10 +31,19 @@
 
 static int si4713_set_power(int power)
 {
+	/* Make sure VAUX1 is enabled before we rise reset line */
+	if (power)
+		twl4030_enable_regulator(RES_VAUX1);
+
 	if (!power)
 		udelay(1);
 	gpio_set_value(RX51_FMTX_RESET_GPIO, power);
 	udelay(50);
+
+	/* As reset line is down, no need to keep VAUX1 */
+	if (!power)
+		twl4030_disable_regulator(RES_VAUX1);
+
 	return 0;
 }
 
@@ -52,8 +62,6 @@ static void __init rx51_init_si4713(void
 	}
 
 	gpio_direction_output(RX51_FMTX_RESET_GPIO, 0);
-	udelay(50);
-	gpio_set_value(RX51_FMTX_RESET_GPIO, 0);
 }
 
 static void __init rx51_init_bcm2048(void)
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-rx51.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-rx51.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-rx51.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-rx51.c	2012-12-16 13:13:01.516330148 +0100
@@ -15,6 +15,7 @@
 #include <linux/err.h>
 #include <linux/clk.h>
 #include <linux/omapfb.h>
+#include <linux/usb/musb.h>
 
 #include <mach/hardware.h>
 #include <asm/mach-types.h>
@@ -39,41 +40,23 @@
 #include "omap3-opp.h"
 #include "pm.h"
 
+#include <mach/pm.h>
+#include <mach/omap-pm.h>
+#include <mach/prcm.h>
+#include "cm.h"
+
+#define RX51_USB_TRANSCEIVER_RST_GPIO	67
+
 extern int omap_init_fb(void);
+extern void rx51_video_mem_init(void);
 
 static struct omap_uart_config rx51_uart_config = {
 	.enabled_uarts	= ((1 << 0) | (1 << 1) | (1 << 2)),
 };
 
-#if defined CONFIG_FB_OMAP || defined CONFIG_FB_OMAP_MODULE
-static struct omap_lcd_config rx51_lcd_config = {
-	.ctrl_name	= "internal",
-};
-
-static struct omap_fbmem_config rx51_fbmem0_config = {
-	.size = (800 * 480 * 2) * 5,
-};
-
-static struct omap_fbmem_config rx51_fbmem1_config = {
-	.size = 752 * 1024,
-};
-
-static struct omap_fbmem_config rx51_fbmem2_config = {
-	.size = 752 * 1024,
-};
-
-static struct omap_board_config_kernel rx51_config[] = {
-	{ OMAP_TAG_UART,	&rx51_uart_config },
-	{ OMAP_TAG_FBMEM,	&rx51_fbmem0_config },
-	{ OMAP_TAG_FBMEM,	&rx51_fbmem1_config },
-	{ OMAP_TAG_FBMEM,	&rx51_fbmem2_config },
-	{ OMAP_TAG_LCD,		&rx51_lcd_config },
-};
-#else
 static struct omap_board_config_kernel rx51_config[] = {
 	{ OMAP_TAG_UART,	&rx51_uart_config },
 };
-#endif	/* CONFIG_FB_OMAP || CONFIG_FB_OMAP_MODULE */
 
 static struct omap_bluetooth_config rx51_bt_config = {
 	.chip_type		= BT_CHIP_BCM,
@@ -86,10 +69,14 @@ static struct omap_bluetooth_config rx51
 
 static void __init rx51_init_irq(void)
 {
-	omap2_init_common_hw(rx51_get_sdram_timings(),
-				omap3_mpu_rate_table,
-				omap3_dsp_rate_table,
-				omap3_l3_rate_table);
+	struct omap_sdrc_params *sdrc_params;
+
+	sdrc_params = rx51_get_sdram_timings();
+
+	omap2_init_common_hw(sdrc_params, sdrc_params,
+			     omap3_mpu_rate_table,
+			     omap3_dsp_rate_table,
+			     omap3_l3_rate_table);
 	omap_init_irq();
 	omap_gpio_init();
 }
@@ -97,19 +84,83 @@ static void __init rx51_init_irq(void)
 static void __init rx51_pm_init(void)
 {
 	struct prm_setup_times prm_setup = {
-		.clksetup = 0,
-		.voltsetup_time1 = 60,
-		.voltsetup_time2 = 60,
-		.voltoffset = 56,
-		.voltsetup2 = 150,
+		.clksetup = 81,
+		.voltsetup_time1 = 270,
+		.voltsetup_time2 = 150,
+		.voltoffset = 17,
+		.voltsetup2 = 37,
 	};
 
 	omap3_set_prm_setup_times(&prm_setup);
 }
 
+static void __init rx51_xceiv_init(void)
+{
+	if (gpio_request(RX51_USB_TRANSCEIVER_RST_GPIO, NULL) < 0)
+		BUG();
+	gpio_direction_output(RX51_USB_TRANSCEIVER_RST_GPIO, 1);
+}
+
+static int rx51_xceiv_reset(void)
+{
+	/* make sure the transceiver is awake */
+	msleep(15);
+	/* only reset powered transceivers */
+	if (!gpio_get_value(RX51_USB_TRANSCEIVER_RST_GPIO))
+		return 0;
+	gpio_set_value(RX51_USB_TRANSCEIVER_RST_GPIO, 0);
+	msleep(1);
+	gpio_set_value(RX51_USB_TRANSCEIVER_RST_GPIO, 1);
+	msleep(15);
+
+	return 0;
+}
+
+static int rx51_xceiv_power(bool power)
+{
+	unsigned long	timeout;
+
+	if (!power) {
+		/* Let musb go stdby before powering down the transceiver */
+		timeout = jiffies + msecs_to_jiffies(100);
+		while (!time_after(jiffies, timeout))
+			if (cm_read_mod_reg(CORE_MOD, CM_IDLEST1)
+				& OMAP3430ES2_ST_HSOTGUSB_STDBY_MASK)
+				break;
+		if (!(cm_read_mod_reg(CORE_MOD, CM_IDLEST1)
+			& OMAP3430ES2_ST_HSOTGUSB_STDBY_MASK))
+			WARN(1, "could not put musb to sleep\n");
+	}
+	gpio_set_value(RX51_USB_TRANSCEIVER_RST_GPIO, power);
+
+	return 0;
+}
+
+/**
+ * rx51_usb_set_pm_limits - sets omap3-related pm constraints
+ * @dev:	musb's device pointer
+ * @set:	set or clear constraints
+ *
+ * For now we only need mpu wakeup latency mpu frequency, if we
+ * need anything else we just add the logic here and the driver
+ * is already handling what needs to be handled.
+ */
+static void rx51_usb_set_pm_limits(struct device *dev, bool set)
+{
+	omap_pm_set_max_mpu_wakeup_lat(dev, set ? 10 : -1);
+	omap_pm_set_min_mpu_freq(dev, set ? 500000000 : 0);
+}
+
+static struct musb_board_data rx51_musb_data = {
+	.xceiv_reset	= rx51_xceiv_reset,
+	.xceiv_power	= rx51_xceiv_power,
+	.set_pm_limits	= rx51_usb_set_pm_limits,
+};
+
 static void __init rx51_init(void)
 {
-	usb_musb_init();
+	rx51_xceiv_init();
+	usb_musb_init(&rx51_musb_data);
 	omap_serial_init();
 	rx51_pm_init();
 	/*
@@ -127,10 +178,8 @@ static void __init rx51_map_io(void)
 	omap_board_config = rx51_config;
 	omap_board_config_size = ARRAY_SIZE(rx51_config);
 	omap2_set_globals_343x();
-#ifdef CONFIG_OMAP2_DSS
-	omap2_set_sdram_vram(1024 * 752 * 2, 0);
-#endif
 	omap2_map_common_io();
+	rx51_video_mem_init();
 }
 
 MACHINE_START(NOKIA_RX51, "Nokia RX-51 board")
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-rx51-camera.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-rx51-camera.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-rx51-camera.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-rx51-camera.c	2012-12-16 13:13:01.516330148 +0100
@@ -73,7 +73,7 @@
 #define VAUX4_2V8		0x09
 
 /* Earlier rx51 builds require VAUX3. */
-#define NEEDS_VAUX3		(system_rev >= 100 && system_rev < 900)
+#define NEEDS_VAUX3		(system_rev >= 0x100 && system_rev < 0x900)
 
 static struct rx51_camera {
 	int okay;
@@ -389,7 +389,7 @@ static struct isp_interface_config rx51_
 	.strobe = 0,
 	.prestrobe = 0,
 	.shutter = 0,
-	.wait_hs_vs = 2,
+	.wait_hs_vs = 1,
 	.u = {
 		.csi = {
 			 .crc		=	1,
@@ -579,10 +579,12 @@ static struct adp1653_platform_data adp1
 	.g_priv			 = rx51_adp1653_g_priv,
 	.power_on		 = rx51_adp1653_power_on,
 	.power_off		 = rx51_adp1653_power_off,
-	.max_flash_timeout	 = 820000,		/* us */
+	/* Must be limited to 500 ms in RX-51 */
+	.max_flash_timeout	 = 500000,		/* us */
 	/* Must be limited to 320 mA in RX-51 B3 and newer hardware */
-	.max_flash_intensity	 = 21,
-	.max_torch_intensity	 = ADP1653_TORCH_INTENSITY_MAX,
+	.max_flash_intensity	 = 19,
+	/* Must be limited to 50 mA in RX-51 */
+	.max_torch_intensity	 = 1,
 	.max_indicator_intensity = ADP1653_REG_OUT_SEL_ILED_MAX,
 };
 
@@ -601,7 +603,7 @@ static struct isp_interface_config rx51_
 	.strobe = 0,
 	.prestrobe = 0,
 	.shutter = 0,
-	.wait_hs_vs = 2,
+	.wait_hs_vs = 1,
 	.u = {
 		.csi = {
 			 .crc		=	0,
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-rx51-flash.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-rx51-flash.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-rx51-flash.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-rx51-flash.c	2012-12-16 13:13:01.516330148 +0100
@@ -13,6 +13,7 @@
 #include <linux/platform_device.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
+#include <linux/mmc/host.h>
 
 #include <asm/mach/flash.h>
 #include <asm/mach-types.h>
@@ -24,7 +25,7 @@
 #define	RX51_FLASH_CS	0
 #define VAUX3_DEV_GRP		0x1F
 #define SYSTEM_REV_B_USES_VAUX3	0x1699
-#define SYSTEM_REV_S_USES_VAUX3	0x8
+#define SYSTEM_REV_S_USES_VAUX3	0x7
 
 extern struct mtd_partition n800_partitions[ONENAND_MAX_PARTITIONS];
 extern int n800_onenand_setup(void __iomem *onenand_base, int freq);
@@ -63,6 +64,8 @@ static struct twl4030_hsmmc_info mmc[] _
 		.cover_only	= true,
 		.gpio_cd	= 160,
 		.gpio_wp	= -EINVAL,
+		.power_saving	= true,
+		.caps		= MMC_CAP_SD_ONLY,
 	},
 	{
 		.name		= "internal",
@@ -71,6 +74,8 @@ static struct twl4030_hsmmc_info mmc[] _
 		.gpio_cd	= -EINVAL,
 		.gpio_wp	= -EINVAL,
 		.vsim_18v	= true,
+		.power_saving	= true,
+		.caps		= MMC_CAP_MMC_ONLY | MMC_CAP_NONREMOVABLE,
 	},
 	{}	/* Terminator */
 };
@@ -83,6 +88,8 @@ static int __init rx51_flash_init(void)
 	if ((system_rev >= SYSTEM_REV_S_USES_VAUX3 && system_rev < 0x100) ||
 	    system_rev >= SYSTEM_REV_B_USES_VAUX3)
 		mmc[1].vmmc_dev_grp = VAUX3_DEV_GRP;
+	else
+		mmc[1].power_saving = false;
 
 	platform_add_devices(rx51_flash_devices, ARRAY_SIZE(rx51_flash_devices));
 	n800_flash_init();
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-rx51-peripherals.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-rx51-peripherals.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-rx51-peripherals.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-rx51-peripherals.c	2012-12-16 13:13:01.516330148 +0100
@@ -17,6 +17,7 @@
 #include <linux/spi/wl12xx.h>
 #include <linux/i2c.h>
 #include <linux/i2c/twl4030.h>
+#include <linux/i2c/tsl2563.h>
 #include <linux/camera_button.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
@@ -53,6 +54,7 @@
 #define RX51_WL12XX_IRQ_GPIO		42
 
 static void rx51_wl12xx_set_power(bool enable);
+static void rx51_tsc2005_set_reset(bool enable);
 
 static struct resource rx51_smc91x_resources[] = {
 	[0] = {
@@ -75,8 +77,6 @@ static struct platform_device rx51_smc91
 };
 
 static struct tsc2005_platform_data tsc2005_config = {
-	.reset_gpio 		= RX51_TSC2005_RESET_GPIO, /* used for esd */
-
 	.ts_x_plate_ohm		= 280,
 	.ts_hw_avg		= 0,
 	.ts_touch_pressure	= 1500,
@@ -89,6 +89,8 @@ static struct tsc2005_platform_data tsc2
 	.ts_y_fudge		= 7,
 
 	.esd_timeout		= 8*1000, /* ms of inactivity before we check */
+
+	.set_reset		= NULL,
 };
 
 static struct lis302dl_platform_data rx51_lis302dl_data = {
@@ -143,6 +145,10 @@ static struct lp5523_platform_data rx51_
 	.chip_en     	= RX51_LP5523_CHIP_EN_GPIO,
 };
 
+static struct tsl2563_platform_data rx51_tsl2563_platform_data = {
+	.cover_comp_gain = 16,
+};
+
 static struct wl12xx_platform_data wl12xx_pdata = {
 	.set_power = rx51_wl12xx_set_power,
 };
@@ -172,7 +178,7 @@ static struct spi_board_info rx51_periph
 		.bus_num		= 4,
 		.chip_select		= 0,
 		.max_speed_hz   	= 48000000,
-		.mode                   = SPI_MODE_2,
+		.mode                   = SPI_MODE_3,
 		.controller_data	= &wl12xx_mcspi_config,
 		.platform_data		= &wl12xx_pdata,
 	},
@@ -327,17 +333,22 @@ static void __init rx51_init_tsc2005(voi
 		gpio_direction_input(RX51_TSC2005_IRQ_GPIO);
 	else
 		printk(KERN_ERR "unable to get DAV GPIO\n");
-	if (tsc2005_config.esd_timeout) {
-		r = gpio_request(tsc2005_config.reset_gpio, "tsc2005 reset");
-		if (r >= 0) {
-			gpio_direction_output(tsc2005_config.reset_gpio, 1);
-		} else {
-			printk(KERN_ERR "unable to get tsc2005 reset GPIO\n");
-			tsc2005_config.esd_timeout = 0;
-		}
+
+	r = gpio_request(RX51_TSC2005_RESET_GPIO, "tsc2005 reset");
+	if (r >= 0) {
+		gpio_direction_output(RX51_TSC2005_RESET_GPIO, 1);
+		tsc2005_config.set_reset = rx51_tsc2005_set_reset;
+	} else {
+		printk(KERN_ERR "unable to get tsc2005 reset GPIO\n");
+		tsc2005_config.esd_timeout = 0;
 	}
 }
 
+static void rx51_tsc2005_set_reset(bool enable)
+{
+	gpio_set_value(RX51_TSC2005_RESET_GPIO, enable);
+}
+
 static void rx51_wl12xx_set_power(bool enable)
 {
 	gpio_set_value(RX51_WL12XX_POWER_GPIO, enable);
@@ -403,53 +414,42 @@ static struct twl4030_gpio_platform_data
 
 static struct twl4030_ins sleep_on_seq[] = {
 /*
- * Turn off VDD1 and VDD2.
+ * Turn off everything.
  */
-	{MSG_SINGULAR(DEV_GRP_P1, 0xf, RES_STATE_OFF), 4},
-	{MSG_SINGULAR(DEV_GRP_P1, 0x10, RES_STATE_OFF), 2},
-/*
- * And also turn off the OMAP3 PLLs and the sysclk output.
- */
-	{MSG_SINGULAR(DEV_GRP_P1, 0x7, RES_STATE_OFF), 3},
-	{MSG_SINGULAR(DEV_GRP_P1, 0x17, RES_STATE_OFF), 3},
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, 1, 0, RES_STATE_SLEEP), 2},
 };
 
 static struct twl4030_script sleep_on_script = {
-	.script	= sleep_on_seq,
-	.size	= ARRAY_SIZE(sleep_on_seq),
-	.flags	= TRITON_SLEEP_SCRIPT,
+	.script		  = sleep_on_seq,
+	.size		  = ARRAY_SIZE(sleep_on_seq),
+	.number_of_events = 1,
+	.events[0] = {
+		.offset = 0,
+		.event = TRITON_SLEEP,
+	},
 };
 
 static struct twl4030_ins wakeup_seq[] = {
 /*
- * Reenable the OMAP3 PLLs.
- * Wakeup VDD1 and VDD2.
- * Reenable sysclk output.
+ * Reenable everything.
  */
-	{MSG_SINGULAR(DEV_GRP_P1, 0x7, RES_STATE_ACTIVE), 0x30},
-	{MSG_SINGULAR(DEV_GRP_P1, 0xf, RES_STATE_ACTIVE), 0x30},
-	{MSG_SINGULAR(DEV_GRP_P1, 0x10, RES_STATE_ACTIVE), 0x37},
-	{MSG_SINGULAR(DEV_GRP_P1, 0x19, RES_STATE_ACTIVE), 3},
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, 1, 0, RES_STATE_ACTIVE), 2},
 };
 
 static struct twl4030_script wakeup_script = {
-	.script	= wakeup_seq,
-	.size	= ARRAY_SIZE(wakeup_seq),
-	.flags	= TRITON_WAKEUP12_SCRIPT,
-};
-
-static struct twl4030_ins wakeup_p3_seq[] = {
-/*
- * Wakeup VDD1 (dummy to be able to insert a delay)
- * Enable CLKEN
- */
-	{MSG_SINGULAR(DEV_GRP_P1, 0x17, RES_STATE_ACTIVE), 3},
-};
-
-static struct twl4030_script wakeup_p3_script = {
-	.script	= wakeup_p3_seq,
-	.size	= ARRAY_SIZE(wakeup_p3_seq),
-	.flags	= TRITON_WAKEUP3_SCRIPT,
+	.script		  = wakeup_seq,
+	.size		  = ARRAY_SIZE(wakeup_seq),
+	.number_of_events = 2,
+	.events = {
+		[0] = {
+			.offset = 0,
+			.event = TRITON_WAKEUP12,
+		},
+		[1] = {
+			.offset = 0,
+			.event = TRITON_WAKEUP3,
+		},
+	},
 };
 
 static struct twl4030_ins wrst_seq[] = {
@@ -464,45 +464,80 @@ static struct twl4030_ins wrst_seq[] = {
 	{MSG_SINGULAR(DEV_GRP_NULL, RES_RESET, RES_STATE_OFF), 2},
 	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, 0, 1, RES_STATE_ACTIVE),
 		0x13},
-	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_PP, 0, 2, RES_STATE_WRST), 0x13},
 	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_PP, 0, 3, RES_STATE_OFF), 0x13},
 	{MSG_SINGULAR(DEV_GRP_NULL, RES_VDD1, RES_STATE_WRST), 0x13},
 	{MSG_SINGULAR(DEV_GRP_NULL, RES_VDD2, RES_STATE_WRST), 0x13},
 	{MSG_SINGULAR(DEV_GRP_NULL, RES_VPLL1, RES_STATE_WRST), 0x35},
-	{MSG_SINGULAR(DEV_GRP_P1, RES_HFCLKOUT, RES_STATE_ACTIVE), 2},
+	{MSG_SINGULAR(DEV_GRP_P3, RES_HFCLKOUT, RES_STATE_ACTIVE), 2},
 	{MSG_SINGULAR(DEV_GRP_NULL, RES_RESET, RES_STATE_ACTIVE), 2},
 };
 
 static struct twl4030_script wrst_script = {
-	.script = wrst_seq,
-	.size   = ARRAY_SIZE(wrst_seq),
-	.flags  = TRITON_WRST_SCRIPT,
+	.script 	  = wrst_seq,
+	.size   	  = ARRAY_SIZE(wrst_seq),
+	.number_of_events = 1,
+	.events[0] = {
+		.offset = 0,
+		.event = TRITON_WRST,
+	},
 };
 
 static struct twl4030_script *twl4030_scripts[] = {
 	&sleep_on_script,
 	&wakeup_script,
-	&wakeup_p3_script,
 	&wrst_script,
 };
 
 static struct twl4030_resconfig twl4030_rconfig[] = {
-	{ .resource = RES_VINTANA1, .devgroup = -1, .type = -1, .type2 = 1 },
-	{ .resource = RES_VINTANA2, .devgroup = -1, .type = -1, .type2 = 1 },
-	{ .resource = RES_VINTDIG, .devgroup = -1, .type = -1, .type2 = 1 },
-	{ .resource = RES_VMMC1, .devgroup = -1, .type = -1, .type2 = 3},
-	{ .resource = RES_VMMC2, .devgroup = DEV_GRP_NULL, .type = -1,
-	  .type2 = 3},
-	{ .resource = RES_VAUX1, .devgroup = -1, .type = -1, .type2 = 3},
-	{ .resource = RES_VAUX2, .devgroup = -1, .type = -1, .type2 = 2},
-	{ .resource = RES_VAUX3, .devgroup = -1, .type = -1, .type2 = 3},
-	{ .resource = RES_VAUX4, .devgroup = -1, .type = -1, .type2 = 2},
-	{ .resource = RES_VPLL2, .devgroup = -1, .type = -1, .type2 = 2},
-	{ .resource = RES_VDAC, .devgroup = -1, .type = -1, .type2 = 3},
-	{ .resource = RES_VSIM, .devgroup = DEV_GRP_NULL, .type = -1,
-	  .type2 = 3},
-	{ .resource = RES_CLKEN, .devgroup = DEV_GRP_P3, .type = -1,
-		.type2 = 1 },
+
+	{ .resource = RES_VDD1, .devgroup = -1, .type = 1, .type2 = -1,
+		.remap = 0 },
+	{ .resource = RES_VDD2, .devgroup = -1, .type = 1, .type2 = -1,
+		.remap = 0 },
+	{ .resource = RES_VPLL1, .devgroup = -1, .type = 1, .type2 = -1,
+		.remap = 0 },
+	{ .resource = RES_VPLL2, .devgroup = -1, .type = -1, .type2 = 3,
+		.remap = -1 },
+	{ .resource = RES_VAUX1, .devgroup = -1, .type = -1, .type2 = 3,
+		.remap = -1 },
+	{ .resource = RES_VAUX2, .devgroup = -1, .type = -1, .type2 = 3,
+		.remap = -1 },
+	{ .resource = RES_VAUX3, .devgroup = -1, .type = -1, .type2 = 3,
+		.remap = -1 },
+	{ .resource = RES_VAUX4, .devgroup = -1, .type = -1, .type2 = 3,
+		.remap = -1 },
+	{ .resource = RES_VMMC1, .devgroup = -1, .type = -1, .type2 = 3,
+		.remap = -1 },
+	{ .resource = RES_VMMC2, .devgroup = -1, .type = -1, .type2 = 3,
+		.remap = -1 },
+	{ .resource = RES_VDAC, .devgroup = -1, .type = -1, .type2 = 3,
+		.remap = -1 },
+	{ .resource = RES_VSIM, .devgroup = -1, .type = -1, .type2 = 3,
+		.remap = -1 },
+	{ .resource = RES_VINTANA1, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
+		.type = -1, .type2 = -1, .remap = -1 },
+	{ .resource = RES_VINTANA2, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
+		.type = 1, .type2 = -1, .remap = -1 },
+	{ .resource = RES_VINTDIG, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
+		.type = -1, .type2 = -1, .remap = -1 },
+	{ .resource = RES_VIO, .devgroup = DEV_GRP_P3,
+		.type = 1, .type2 = -1, .remap = -1 },
+	{ .resource = RES_CLKEN, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
+		.type = 1, .type2 = -1 , .remap = -1 },
+	{ .resource = RES_REGEN, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
+		.type = 1, .type2 = -1, .remap = -1 },
+	{ .resource = RES_NRES_PWRON, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
+		.type = 1, .type2 = -1, .remap = -1 },
+	{ .resource = RES_SYSEN, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
+		.type = 1, .type2 = -1, .remap = -1 },
+	{ .resource = RES_HFCLKOUT, .devgroup = DEV_GRP_P3, .type = 1,
+		.type2 = -1, .remap = -1 },
+	{ .resource = RES_32KCLKOUT, .devgroup = -1, .type = 1, .type2 = -1,
+		.remap = -1 },
+	{ .resource = RES_RESET, .devgroup = -1, .type = 1, .type2 = -1,
+		.remap = -1 },
+	{ .resource = RES_Main_Ref, .devgroup = -1, .type = 1, .type2 = -1,
+		.remap = -1 },
 	{ 0, 0},
 };
 
@@ -512,6 +547,9 @@ static struct twl4030_power_data rx51_t2
 	.resource_config = twl4030_rconfig,
 };
 
+
+extern struct regulator_init_data rx51_vdac_data;
+
 static struct twl4030_platform_data rx51_twldata = {
 	.irq_base		= TWL4030_IRQ_BASE,
 	.irq_end		= TWL4030_IRQ_END,
@@ -522,6 +560,9 @@ static struct twl4030_platform_data rx51
 	.madc			= &rx51_madc_data,
 	.power			= &rx51_t2scripts_data,
 	.usb			= &rx51_usb_data,
+
+	/* LDOs */
+	.vdac			= &rx51_vdac_data,
 };
 
 static struct omap_ssi_board_config ssi_board_config = {
@@ -545,6 +586,7 @@ static struct i2c_board_info __initdata
 	},
 	{
 		I2C_BOARD_INFO("tsl2563", 0x29),
+		.platform_data = &rx51_tsl2563_platform_data,
 	},
 };
 
@@ -557,7 +599,7 @@ static struct i2c_board_info __initdata
 
 static int __init rx51_i2c_init(void)
 {
-	omap_register_i2c_bus(1, 2600, rx51_peripherals_i2c_board_info_1,
+	omap_register_i2c_bus(1, 2200, rx51_peripherals_i2c_board_info_1,
 			ARRAY_SIZE(rx51_peripherals_i2c_board_info_1));
 	omap_register_i2c_bus(2, 100, rx51_peripherals_i2c_board_info_2,
 			      ARRAY_SIZE(rx51_peripherals_i2c_board_info_2));
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-rx51-sdram.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-rx51-sdram.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-rx51-sdram.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-rx51-sdram.c	2012-12-16 13:13:01.516330148 +0100
@@ -1,5 +1,5 @@
 /*
- * SDRC register values for the Samsung K4X1G323PC
+ * SDRC register values for the Nokia Memories
  *
  * Copyright (C) 2008 Nokia Corporation
  *
@@ -23,7 +23,7 @@
 #include <mach/sdrc.h>
 
 
-/* In picoseconds, except for tREF */
+/* In picoseconds, except for tREF (ns), tXP, tCKE, tWTR (clks) */
 struct sdram_timings {
 	u32 casl;
 	u32 tDAL;
@@ -36,7 +36,11 @@ struct sdram_timings {
 	u32 tRFC;
 	u32 tXSR;
 
-	u32 tREF; /* in ms */
+	u32 tREF; /* in ns */
+
+	u32 tXP;
+	u32 tCKE;
+	u32 tWTR;
 };
 
 struct sdram_info {
@@ -49,22 +53,22 @@ struct omap_sdrc_params rx51_sdrc_params
 static const struct sdram_timings rx51_timings[] = {
 	{
 		.casl = 3,
-		.tDAL = 15000 + 18000,
+		.tDAL = 33000,
 		.tDPL = 15000,
 		.tRRD = 12000,
-		.tRCD = 18000,
+		.tRCD = 22500,
 		.tRP = 18000,
 		.tRAS = 42000,
 		.tRC = 66000,
-		.tRFC = 97500,
-		.tXSR = 120000,
+		.tRFC = 138000,
+		.tXSR = 200000,
 
-		.tREF = 64,
-	},
-};
+		.tREF = 7800,
 
-static const struct sdram_info rx51_info = {
-	.row_lines = 13,
+		.tXP = 2,
+		.tCKE = 2,
+		.tWTR = 2
+	},
 };
 
 #define CM_BASE		    0x48004000
@@ -86,38 +90,6 @@ static const unsigned long sys_clk_rate_
 	12000, 13000, 19200, 26000, 38400, 16800
 };
 
-static unsigned long get_sys_clk_rate(void)
-{
-	unsigned long rate;
-
-	rate = sys_clk_rate_table[*(u32 *)OMAP2_IO_ADDRESS(PRM_CLKSEL) & 0x07];
-	if (((*(u32 *)OMAP2_IO_ADDRESS(PRM_CLKSRC_CTRL) >> 6) & 0x03) == 0x02)
-		rate /= 2;
-	return rate;
-}
-
-static unsigned long get_core_rate(void)
-{
-	unsigned long rate;
-	u32 l;
-
-	l = cm_read_reg(CM_CLKSEL1_PLL);
-	rate = get_sys_clk_rate();
-	rate *= ((l >> 16) & 0x7ff);
-	rate /= ((l >> 8) & 0x7f) + 1;
-	rate /= (l >> 27) & 0x1f;
-
-	return rate;
-}
-
-static unsigned long get_l3_rate(void)
-{
-	u32 l;
-
-	l = cm_read_reg(CM_CLKSEL_CORE);
-	return get_core_rate() / (l & 0x03);
-}
-
 static unsigned long sdrc_get_fclk_period(long rate)
 {
 	/* In picoseconds */
@@ -136,18 +108,14 @@ static unsigned int sdrc_ps_to_ticks(uns
 #undef DEBUG
 #ifdef DEBUG
 static int set_sdrc_timing_regval(u32 *regval, int st_bit, int end_bit,
-			       int time, long rate, const char *name)
+				int ticks, long rate, const char *name)
 #else
 static int set_sdrc_timing_regval(u32 *regval, int st_bit, int end_bit,
-			       int time, long rate)
+			       int ticks)
 #endif
 {
-	int ticks, mask, nr_bits;
+	int mask, nr_bits;
 
-	if (time == 0)
-		ticks = 0;
-	else
-		ticks = sdrc_ps_to_ticks(time, rate);
 	nr_bits = end_bit - st_bit + 1;
 	if (ticks >= 1 << nr_bits)
 		return -1;
@@ -155,7 +123,7 @@ static int set_sdrc_timing_regval(u32 *r
 	*regval &= ~(mask << st_bit);
 	*regval |= ticks << st_bit;
 #ifdef DEBUG
-	printk("SDRC %s: %i ticks %i ns\n", name, ticks,
+	printk(KERN_INFO "SDRC %s: %i ticks %i ns\n", name, ticks,
 			(unsigned int)sdrc_get_fclk_period(rate) * ticks /
 			1000);
 #endif
@@ -164,44 +132,101 @@ static int set_sdrc_timing_regval(u32 *r
 }
 
 #ifdef DEBUG
-#define SDRC_SET_ONE(reg, st, end, field, rate) \
-	if (set_sdrc_timing_regval((reg), (st), (end), rx51_timings->field, (rate), #field) < 0) \
-		err = -1
+#define SDRC_SET_ONE(reg, st, end, field, rate)				\
+	if (set_sdrc_timing_regval((reg), (st), (end),			\
+					rx51_timings->field,		\
+					(rate), #field) < 0)		\
+		err = -1;
+
 #else
-#define SDRC_SET_ONE(reg, st, end, field, rate) \
-	if (set_sdrc_timing_regval((reg), (st), (end), rx51_timings->field, (rate)) < 0) \
-		err = -1
+#define SDRC_SET_ONE(reg, st, end, field, rate)			\
+	if (set_sdrc_timing_regval((reg), (st), (end), rx51_timings->field) \
+		< 0)							\
+		err = -1;
+
+#endif
+
+#ifdef DEBUG
+static int set_sdrc_timing_regval_ps(u32 *regval, int st_bit, int end_bit,
+			       int time, long rate, const char *name)
+#else
+static int set_sdrc_timing_regval_ps(u32 *regval, int st_bit, int end_bit,
+			       int time, long rate)
+#endif
+{
+	int ticks, ret;
+	ret = 0;
+
+	if (time == 0)
+		ticks = 0;
+	else
+		ticks = sdrc_ps_to_ticks(time, rate);
+
+#ifdef DEBUG
+	ret = set_sdrc_timing_regval(regval, st_bit, end_bit, ticks,
+				     rate, name);
+#else
+	ret = set_sdrc_timing_regval(regval, st_bit, end_bit, ticks);
+#endif
+
+	return ret;
+}
+
+#ifdef DEBUG
+#define SDRC_SET_ONE_PS(reg, st, end, field, rate)	\
+	if (set_sdrc_timing_regval_ps((reg), (st), (end),		\
+					rx51_timings->field,		\
+					(rate), #field) < 0)		\
+		err = -1;
+
+#else
+#define SDRC_SET_ONE_PS(reg, st, end, field, rate)			\
+	if (set_sdrc_timing_regval_ps((reg), (st), (end),		\
+					rx51_timings->field, (rate)) < 0) \
+		err = -1;
 #endif
 
 static int sdrc_timings(int id, long rate)
 {
-	u32 ticks_per_ms;
+	u32 ticks_per_us;
 	u32 rfr, l;
 	u32 actim_ctrla = 0, actim_ctrlb = 0;
 	u32 rfr_ctrl;
 	int err = 0;
 	long l3_rate = rate / 1000;
 
-	SDRC_SET_ONE(&actim_ctrla,  0,  4, tDAL, l3_rate);
-	SDRC_SET_ONE(&actim_ctrla,  6,  8, tDPL, l3_rate);
-	SDRC_SET_ONE(&actim_ctrla,  9, 11, tRRD, l3_rate);
-	SDRC_SET_ONE(&actim_ctrla, 12, 14, tRCD, l3_rate);
-	SDRC_SET_ONE(&actim_ctrla, 15, 17, tRP, l3_rate);
-	SDRC_SET_ONE(&actim_ctrla, 18, 21, tRAS, l3_rate);
-	SDRC_SET_ONE(&actim_ctrla, 22, 26, tRC, l3_rate);
-	SDRC_SET_ONE(&actim_ctrla, 27, 31, tRFC, l3_rate);
+#ifdef DEBUG
+	printk(KERN_INFO "SDRC CLK rate: %i MHz\n", (int)l3_rate/1000);
+#endif
 
-	SDRC_SET_ONE(&actim_ctrlb,  0,  7, tXSR, l3_rate);
+	SDRC_SET_ONE_PS(&actim_ctrla,  0,  4, tDAL, l3_rate);
+	SDRC_SET_ONE_PS(&actim_ctrla,  6,  8, tDPL, l3_rate);
+	SDRC_SET_ONE_PS(&actim_ctrla,  9, 11, tRRD, l3_rate);
+	SDRC_SET_ONE_PS(&actim_ctrla, 12, 14, tRCD, l3_rate);
+	SDRC_SET_ONE_PS(&actim_ctrla, 15, 17, tRP, l3_rate);
+	SDRC_SET_ONE_PS(&actim_ctrla, 18, 21, tRAS, l3_rate);
+	SDRC_SET_ONE_PS(&actim_ctrla, 22, 26, tRC, l3_rate);
+	SDRC_SET_ONE_PS(&actim_ctrla, 27, 31, tRFC, l3_rate);
+
+	SDRC_SET_ONE_PS(&actim_ctrlb,  0,  7, tXSR, l3_rate);
+
+	SDRC_SET_ONE(&actim_ctrlb,  8,  10, tXP, l3_rate);
+	SDRC_SET_ONE(&actim_ctrlb,  12,  14, tCKE, l3_rate);
+	SDRC_SET_ONE(&actim_ctrlb,  16,  17, tWTR, l3_rate);
 
-	ticks_per_ms = sdrc_ps_to_ticks(1000000000, l3_rate);
-	rfr = rx51_timings[0].tREF * ticks_per_ms / (1 << rx51_info.row_lines);
+	ticks_per_us = sdrc_ps_to_ticks(1000000, l3_rate);
+	rfr = rx51_timings[0].tREF * ticks_per_us / 1000;
 	if (rfr > 65535 + 50)
 		rfr = 65535;
 	else
 		rfr -= 50;
 
+#ifdef DEBUG
+	printk(KERN_INFO "SDRC tREF: %i ticks\n", rfr);
+#endif
+
 	l = rfr << 8;
-	rfr_ctrl = l | 0x3; /* autorefresh, reload counter with 8xARCV */
+	rfr_ctrl = l | 0x1; /* autorefresh, reload counter with 1xARCV */
 
 	rx51_sdrc_params[id].rate = rate;
 	rx51_sdrc_params[id].actim_ctrla = actim_ctrla;
@@ -219,7 +244,7 @@ struct omap_sdrc_params *rx51_get_sdram_
 	int err;
 
 	err = sdrc_timings(0, 41500000);
-	err = sdrc_timings(1, 83000000);
+	err |= sdrc_timings(1, 83000000);
 	err |= sdrc_timings(2, 166000000);
 
 	return &rx51_sdrc_params[0];
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-rx51-video.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-rx51-video.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-rx51-video.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-rx51-video.c	2012-12-16 13:13:01.516330148 +0100
@@ -10,10 +10,13 @@
 
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/mm.h>
 #include <linux/platform_device.h>
 #include <linux/delay.h>
 #include <linux/spi/spi.h>
 #include <linux/i2c/twl4030.h>
+#include <linux/regulator/machine.h>
+#include <linux/bootmem.h>
 
 #include <asm/mach-types.h>
 
@@ -21,14 +24,16 @@
 #include <mach/gpio.h>
 #include <mach/board.h>
 #include <mach/pm.h>
+#include <mach/vram.h>
+#include <mach/vrfb.h>
+#include <mach/dss_boottime.h>
+#include <mach/omap-pm.h>
 
-#if defined(CONFIG_FB_OMAP) || defined(CONFIG_FB_OMAP_MODULE)
-#include <mach/lcd_mipid.h>
-#else
 #include <linux/omapfb.h>
 #include <mach/display.h>
 #include <../drivers/video/omap2/displays/panel-acx565akm.h>
-#endif
+
+#if defined(CONFIG_FB_OMAP2) || defined(CONFIG_FB_OMAP2_MODULE)
 
 static struct omap2_mcspi_device_config mipid_mcspi_config = {
 	.turbo_mode	= 0,
@@ -102,95 +107,6 @@ static void twl4030_set_bklight_level(in
 	twl4030_bklight_level = level;
 }
 
-#if defined(CONFIG_FB_OMAP) || defined(CONFIG_FB_OMAP_MODULE)
-
-
-static struct platform_device rx51_lcd_device = {
-	.name		= "lcd_mipid",
-	.id		= -1,
-};
-
-static void mipid_shutdown(struct mipid_platform_data *pdata)
-{
-	if (pdata->nreset_gpio != -1) {
-		pr_info("shutdown LCD\n");
-		gpio_set_value(pdata->nreset_gpio, 0);
-		msleep(120);
-	}
-}
-
-static void mipid_set_bklight_level(struct mipid_platform_data *md, int level)
-{
-	twl4030_set_bklight_level(level);
-}
-
-static int mipid_get_bklight_level(struct mipid_platform_data *md)
-{
-	return twl4030_get_bklight_level();
-}
-
-static int mipid_get_bklight_max(struct mipid_platform_data *md)
-{
-	return twl4030_bklight_max;
-}
-
-static struct mipid_platform_data rx51_mipid_platform_data = {
-	.bc_connected		= 1,
-	.shutdown		= mipid_shutdown,
-	.set_bklight_level	= mipid_set_bklight_level,
-	.get_bklight_level	= mipid_get_bklight_level,
-	.get_bklight_max	= mipid_get_bklight_max,
-};
-
-static void __init mipid_dev_init(void)
-{
-	const struct omap_lcd_config *conf;
-
-	conf = omap_get_config(OMAP_TAG_LCD, struct omap_lcd_config);
-	if (conf != NULL) {
-		int ret = gpio_request(conf->nreset_gpio, "mipid-reset");
-		if (ret) {
-			printk(KERN_ERR "Failed to request GPIO %d for "
-				"mipid reset\n", conf->nreset_gpio);
-		} else {
-			gpio_direction_output(conf->nreset_gpio, 1);
-			rx51_mipid_platform_data.nreset_gpio =
-				conf->nreset_gpio;
-		}
-
-		rx51_mipid_platform_data.data_lines = conf->data_lines;
-	}
-}
-
-static struct spi_board_info rx51_video_spi_board_info[] = {
-	[0] = {
-		.modalias		= "lcd_mipid",
-		.bus_num		= 1,
-		.chip_select		= 2,
-		.max_speed_hz		= 6000000,
-		.controller_data	= &mipid_mcspi_config,
-		.platform_data		= &rx51_mipid_platform_data,
-	},
-};
-
-static struct platform_device *rx51_video_devices[] = {
-	&rx51_lcd_device,
-};
-
-static int __init rx51_video_init(void)
-{
-	if (!(machine_is_nokia_rx51() || machine_is_nokia_rx71()))
-		return 0;
-
-	platform_add_devices(rx51_video_devices, ARRAY_SIZE(rx51_video_devices));
-	spi_register_board_info(rx51_video_spi_board_info,
-			ARRAY_SIZE(rx51_video_spi_board_info));
-	mipid_dev_init();
-	return 0;
-}
-
-#else	/* CONFIG_FB_OMAP || CONFIG_FB_OMAP_MODULE */
-
 static struct spi_board_info rx51_video_spi_board_info[] = {
 	[0] = {
 		.modalias		= "acx565akm",
@@ -205,9 +121,8 @@ static struct spi_board_info rx51_video_
 static int acx565akm_enable(struct omap_display *display)
 {
 	if (display->hw_config.panel_reset_gpio != -1) {
-		pr_info("Release LCD reset\n");
+		pr_debug("Release LCD reset\n");
 		gpio_set_value(display->hw_config.panel_reset_gpio, 1);
-		msleep(15);
 	}
 
 	return 0;
@@ -216,9 +131,8 @@ static int acx565akm_enable(struct omap_
 static void acx565akm_disable(struct omap_display *display)
 {
 	if (display->hw_config.panel_reset_gpio != -1) {
-		pr_info("Enable LCD reset\n");
+		pr_debug("Enable LCD reset\n");
 		gpio_set_value(display->hw_config.panel_reset_gpio, 0);
-		msleep(120);
 	}
 }
 
@@ -273,7 +187,6 @@ static void __init acx565akm_dev_init(vo
 }
 
 /* TV-out */
-
 static struct omap_dss_display_config venc_display_data = {
 	.type = OMAP_DISPLAY_TYPE_VENC,
 	.name = "tv",
@@ -283,11 +196,15 @@ static struct omap_dss_display_config ve
 /* DSS */
 static struct omap_dss_board_info rx51_dss_data = {
 	.get_last_off_on_transaction_id = get_last_off_on_transaction_id,
+	.set_min_bus_tput = omap_pm_set_min_bus_tput,
 	.num_displays = 2,
 	.displays = {
 		&acx565akm_display_data,
 		&venc_display_data,
-	}
+	},
+	.fifo_thresholds = {
+		[OMAP_DSS_GFX] = { .low = 2944, .high = 3008, },
+	},
 };
 
 static struct platform_device rx51_dss_device = {
@@ -302,8 +219,131 @@ static struct platform_device *rx51_vide
 	&rx51_dss_device,
 };
 
+/* TV-OUT (VDAC) regulator */
+static struct regulator_consumer_supply rx51_vdac_supply = {
+	.supply		= "vdac",
+	.dev		= &rx51_dss_device.dev,
+};
+
+struct regulator_init_data rx51_vdac_data = {
+	.constraints = {
+		.name			= "VDAC_18",
+		.min_uV			= 1800000,
+		.max_uV			= 1800000,
+		.apply_uV		= true,
+		.valid_modes_mask	= REGULATOR_MODE_NORMAL
+					| REGULATOR_MODE_STANDBY,
+		.valid_ops_mask		= REGULATOR_CHANGE_MODE
+					| REGULATOR_CHANGE_STATUS,
+	},
+	.num_consumer_supplies  = 1,
+	.consumer_supplies      = &rx51_vdac_supply,
+};
+
+static struct omapfb_platform_data omapfb_config;
+
+static size_t rx51_vrfb_min_phys_size(int bpp)
+{
+	unsigned bytespp = bpp >> 3;
+	size_t landscape;
+	size_t portrait;
+
+	/* For physical screen resolution of 800x480. */
+	landscape = omap_vrfb_min_phys_size(800, 480, bytespp);
+	portrait = omap_vrfb_min_phys_size(480, 800, bytespp);
+
+	return max(landscape, portrait);
+}
+
+
+static void __init rx51_add_gfx_fb(u32 paddr, size_t size, enum omapfb_color_format format)
+{
+	omapfb_config.mem_desc.region_cnt = 1;
+	omapfb_config.mem_desc.region[0].paddr = paddr;
+	omapfb_config.mem_desc.region[0].size = size;
+	omapfb_config.mem_desc.region[0].format = format;
+	omapfb_config.mem_desc.region[0].format_used = 1;
+	omapfb_set_platform_data(&omapfb_config);
+}
+
+static void __init rx51_detect_vram(size_t vid_plane_mem_size)
+{
+	unsigned long vram_paddr;
+	size_t vram_size;
+	unsigned long gfx_paddr;
+	size_t gfx_size;
+	enum omapfb_color_format format;
+
+	gfx_paddr = dss_boottime_get_plane_base(0);
+
+	if (gfx_paddr == -1UL)
+		return;
+
+	gfx_size = rx51_vrfb_min_phys_size(dss_boottime_get_plane_bpp(0));
+	format = dss_boottime_get_plane_format(0);
+
+	vram_size = PAGE_ALIGN(gfx_size) + PAGE_ALIGN(vid_plane_mem_size);
+	vram_paddr = gfx_paddr + PAGE_ALIGN(gfx_size) - vram_size;
+
+	rx51_add_gfx_fb(gfx_paddr, gfx_size, format);
+
+	if (reserve_bootmem(vram_paddr, vram_size, BOOTMEM_EXCLUSIVE) < 0) {
+		pr_err("FB: can't reserve VRAM region\n");
+		return;
+	}
+
+	if (omap_vram_add_region(vram_paddr, vram_size) < 0) {
+		free_bootmem(vram_paddr, vram_size);
+		pr_err("Can't set VRAM region\n");
+		return;
+	}
+
+	pr_info("VRAM: %zd bytes at 0x%lx. (Detected %zd at %#lx)\n",
+		vram_size, vram_paddr, gfx_size, gfx_paddr);
+}
+
+static void __init rx51_alloc_vram(size_t vid_plane_mem_size)
+{
+	unsigned long vram_paddr;
+	size_t vram_size;
+	size_t gfx_size;
+
+	gfx_size = rx51_vrfb_min_phys_size(16);
+
+	vram_size = PAGE_ALIGN(gfx_size) + PAGE_ALIGN(vid_plane_mem_size);
+	vram_paddr = virt_to_phys(alloc_bootmem_pages(vram_size));
+	BUG_ON(vram_paddr & ~PAGE_MASK);
+
+	rx51_add_gfx_fb(vram_paddr, gfx_size, OMAPFB_COLOR_RGB565);
+
+	if (omap_vram_add_region(vram_paddr, vram_size) < 0) {
+		free_bootmem(vram_paddr, vram_size);
+		pr_err("Can't set VRAM region\n");
+		return;
+	}
+
+	pr_info("VRAM: %zd bytes at 0x%lx\n", vram_size, vram_paddr);
+}
+
+
+void __init rx51_video_mem_init(void)
+{
+	size_t vid_plane_mem_size;
+
+	/* 2 VID planes, 2 buffers, 2 bytes per pixel, 864x648 resolution. */
+	vid_plane_mem_size = 2 * 2 * PAGE_ALIGN(2 * 864 * 648);
+
+	if (dss_boottime_plane_is_enabled(0))
+		rx51_detect_vram(vid_plane_mem_size);
+	else
+		rx51_alloc_vram(vid_plane_mem_size);
+}
+
 static int __init rx51_video_init(void)
 {
+	if (!machine_is_nokia_rx51())
+		return 0;
+
 	platform_add_devices(rx51_video_devices, ARRAY_SIZE(rx51_video_devices));
 	spi_register_board_info(rx51_video_spi_board_info,
 			ARRAY_SIZE(rx51_video_spi_board_info));
@@ -311,7 +351,13 @@ static int __init rx51_video_init(void)
 	return 0;
 }
 
-#endif	/* CONFIG_FB_OMAP || CONFIG_FB_OMAP_MODULE */
-
 subsys_initcall(rx51_video_init);
 
+#else
+
+void __init rx51_video_mem_init(void)
+{
+}
+
+#endif	/* CONFIG_FB_OMAP2 || CONFIG_FB_OMAP2_MODULE */
+
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-rx71.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-rx71.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-rx71.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-rx71.c	2012-12-16 13:13:01.516330148 +0100
@@ -101,7 +101,11 @@ static struct omap_board_config_kernel r
 
 static void __init rx71_init_irq(void)
 {
-	omap2_init_common_hw(rx51_get_sdram_timings(),
+	struct omap_sdrc_params *sdrc_params;
+
+	sdrc_params = rx51_get_sdram_timings();
+
+	omap2_init_common_hw(sdrc_params, sdrc_params,
 				rx71_mpu_rate_table,
 				rx71_dsp_rate_table,
 				rx71_l3_rate_table);
@@ -114,7 +118,7 @@ static void __init rx71_init(void)
 {
 	omap_board_config = rx71_config;
 	omap_board_config_size = ARRAY_SIZE(rx71_config);
-	usb_musb_init();
+	usb_musb_init(NULL);
 	omap_serial_init();
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-2430sdp.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-2430sdp.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-2430sdp.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-2430sdp.c	2012-12-16 13:13:01.516330148 +0100
@@ -323,7 +323,7 @@ out:
 
 static void __init omap_2430sdp_init_irq(void)
 {
-	omap2_init_common_hw(NULL);
+	omap2_init_common_hw(NULL, NULL, NULL, NULL, NULL);
 	omap_init_irq();
 	omap_gpio_init();
 	sdp2430_init_smc91x();
@@ -411,7 +411,7 @@ static void __init omap_2430sdp_init(voi
 	msecure_init();
 
 	sdp2430_flash_init();
-	usb_musb_init();
+	usb_musb_init(NULL);
 
 	spi_register_board_info(sdp2430_spi_board_info,
 				ARRAY_SIZE(sdp2430_spi_board_info));
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-3430sdp.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-3430sdp.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/board-3430sdp.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/board-3430sdp.c	2012-12-16 13:13:01.516330148 +0100
@@ -286,8 +286,10 @@ static inline void __init sdp3430_init_s
 
 static void __init omap_3430sdp_init_irq(void)
 {
-	omap2_init_common_hw(hyb18m512160af6_sdrc_params, omap3_mpu_rate_table,
-			     omap3_dsp_rate_table, omap3_l3_rate_table);
+	omap2_init_common_hw(hyb18m512160af6_sdrc_params, NULL,
+			     omap3_mpu_rate_table,
+			     omap3_dsp_rate_table,
+			     omap3_l3_rate_table);
 	omap_init_irq();
 	omap_gpio_init();
 	sdp3430_init_smc91x();
@@ -483,7 +485,7 @@ static void __init omap_3430sdp_init(voi
 	sdp3430_flash_init();
 	msecure_init();
 	omap_serial_init();
-	usb_musb_init();
+	usb_musb_init(NULL);
 	usb_ehci_init();
 	twl4030_mmc_init(mmc);
 }
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/clockdomain.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/clockdomain.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/clockdomain.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/clockdomain.c	2012-12-16 13:13:01.516330148 +0100
@@ -133,6 +133,36 @@ static void _clkdm_del_autodeps(struct c
 	}
 }
 
+/*
+ * _omap2_clkdm_set_hwsup - set the hwsup idle transition bit
+ * @clkdm: struct clockdomain *
+ * @enable: int 0 to disable, 1 to enable
+ *
+ * Internal helper for actually switching the bit that controls hwsup
+ * idle transitions for clkdm.
+ */
+static void _omap2_clkdm_set_hwsup(struct clockdomain *clkdm, int enable)
+{
+	u32 v;
+
+	if (cpu_is_omap24xx()) {
+		if (enable)
+			v = OMAP24XX_CLKSTCTRL_ENABLE_AUTO;
+		else
+			v = OMAP24XX_CLKSTCTRL_DISABLE_AUTO;
+	} else if (cpu_is_omap34xx()) {
+		if (enable)
+			v = OMAP34XX_CLKSTCTRL_ENABLE_AUTO;
+		else
+			v = OMAP34XX_CLKSTCTRL_DISABLE_AUTO;
+	} else {
+		BUG();
+	}
+
+	cm_rmw_mod_reg_bits(clkdm->clktrctrl_mask,
+			    v << __ffs(clkdm->clktrctrl_mask),
+			    clkdm->pwrdm.ptr->prcm_offs, CM_CLKSTCTRL);
+}
 
 static struct clockdomain *_clkdm_lookup(const char *name)
 {
@@ -452,8 +482,6 @@ int omap2_clkdm_wakeup(struct clockdomai
  */
 void omap2_clkdm_allow_idle(struct clockdomain *clkdm)
 {
-	u32 v;
-
 	if (!clkdm)
 		return;
 
@@ -469,18 +497,7 @@ void omap2_clkdm_allow_idle(struct clock
 	if (atomic_read(&clkdm->usecount) > 0)
 		_clkdm_add_autodeps(clkdm);
 
-	if (cpu_is_omap24xx())
-		v = OMAP24XX_CLKSTCTRL_ENABLE_AUTO;
-	else if (cpu_is_omap34xx())
-		v = OMAP34XX_CLKSTCTRL_ENABLE_AUTO;
-	else
-		BUG();
-
-
-	cm_rmw_mod_reg_bits(clkdm->clktrctrl_mask,
-			    v << __ffs(clkdm->clktrctrl_mask),
-			    clkdm->pwrdm.ptr->prcm_offs,
-			    CM_CLKSTCTRL);
+	_omap2_clkdm_set_hwsup(clkdm, 1);
 
 	pwrdm_clkdm_state_switch(clkdm);
 }
@@ -496,8 +513,6 @@ void omap2_clkdm_allow_idle(struct clock
  */
 void omap2_clkdm_deny_idle(struct clockdomain *clkdm)
 {
-	u32 v;
-
 	if (!clkdm)
 		return;
 
@@ -510,16 +525,7 @@ void omap2_clkdm_deny_idle(struct clockd
 	pr_debug("clockdomain: disabling automatic idle transitions for %s\n",
 		 clkdm->name);
 
-	if (cpu_is_omap24xx())
-		v = OMAP24XX_CLKSTCTRL_DISABLE_AUTO;
-	else if (cpu_is_omap34xx())
-		v = OMAP34XX_CLKSTCTRL_DISABLE_AUTO;
-	else
-		BUG();
-
-	cm_rmw_mod_reg_bits(clkdm->clktrctrl_mask,
-			    v << __ffs(clkdm->clktrctrl_mask),
-			    clkdm->pwrdm.ptr->prcm_offs, CM_CLKSTCTRL);
+	_omap2_clkdm_set_hwsup(clkdm, 0);
 
 	if (atomic_read(&clkdm->usecount) > 0)
 		_clkdm_del_autodeps(clkdm);
@@ -565,10 +571,14 @@ int omap2_clkdm_clk_enable(struct clockd
 	v = omap2_clkdm_clktrctrl_read(clkdm);
 
 	if ((cpu_is_omap34xx() && v == OMAP34XX_CLKSTCTRL_ENABLE_AUTO) ||
-	    (cpu_is_omap24xx() && v == OMAP24XX_CLKSTCTRL_ENABLE_AUTO))
+	    (cpu_is_omap24xx() && v == OMAP24XX_CLKSTCTRL_ENABLE_AUTO)) {
+		/* Disable HW transitions when we are changing deps */
+		_omap2_clkdm_set_hwsup(clkdm, 0);
 		_clkdm_add_autodeps(clkdm);
-	else
+		_omap2_clkdm_set_hwsup(clkdm, 1);
+	} else {
 		omap2_clkdm_wakeup(clkdm);
+	}
 
 	pwrdm_wait_transition(clkdm->pwrdm.ptr);
 	pwrdm_clkdm_state_switch(clkdm);
@@ -619,10 +629,14 @@ int omap2_clkdm_clk_disable(struct clock
 	v = omap2_clkdm_clktrctrl_read(clkdm);
 
 	if ((cpu_is_omap34xx() && v == OMAP34XX_CLKSTCTRL_ENABLE_AUTO) ||
-	    (cpu_is_omap24xx() && v == OMAP24XX_CLKSTCTRL_ENABLE_AUTO))
+	    (cpu_is_omap24xx() && v == OMAP24XX_CLKSTCTRL_ENABLE_AUTO)) {
+		/* Disable HW transitions when we are changing deps */
+		_omap2_clkdm_set_hwsup(clkdm, 0);
 		_clkdm_del_autodeps(clkdm);
-	else
+		_omap2_clkdm_set_hwsup(clkdm, 1);
+	} else {
 		omap2_clkdm_sleep(clkdm);
+	}
 
 	pwrdm_clkdm_state_switch(clkdm);
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/clock34xx.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/clock34xx.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/clock34xx.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/clock34xx.c	2012-12-16 13:13:01.516330148 +0100
@@ -56,7 +56,7 @@
 #define SDRC_MPURATE_SCALE		8
 
 /* 2^SDRC_MPURATE_BASE_SHIFT: MPU MHz that SDRC_MPURATE_LOOPS is defined for */
-#define SDRC_MPURATE_BASE_SHIFT		9
+#define SDRC_MPURATE_BASE_SHIFT		11
 
 /*
  * SDRC_MPURATE_LOOPS: Number of MPU loops to execute at
@@ -136,7 +136,7 @@ static u16 _omap3_dpll_compute_freqsel(s
 	unsigned long fint;
 	u16 f = 0;
 
-	fint = clk->parent->rate / (n + 1);
+	fint = clk->parent->rate / n;
 
 	pr_debug("clock: fint is %lu\n", fint);
 
@@ -478,7 +478,9 @@ static int omap3_core_dpll_m2_set_rate(s
 	u32 unlock_dll = 0;
 	u32 c;
 	unsigned long validrate, sdrcrate, mpurate;
-	struct omap_sdrc_params *sp;
+	struct omap_sdrc_params *sdrc_cs0;
+	struct omap_sdrc_params *sdrc_cs1;
+	int ret;
 
 	if (!clk || !rate)
 		return -EINVAL;
@@ -496,8 +498,8 @@ static int omap3_core_dpll_m2_set_rate(s
 	else
 		sdrcrate >>= ((clk->rate / rate) >> 1);
 
-	sp = omap2_sdrc_get_params(sdrcrate);
-	if (!sp)
+	ret = omap2_sdrc_get_params(sdrcrate, &sdrc_cs0, &sdrc_cs1);
+	if (ret)
 		return -EINVAL;
 
 	if (sdrcrate < MIN_SDRC_DLL_LOCK_FREQ) {
@@ -516,14 +518,37 @@ static int omap3_core_dpll_m2_set_rate(s
 	if (c == 0)
 		c = 1;
 
+	/* Increase delay for OPP2 & OPP3 by one to avoid random crashes */
+	if (c == 12 || c == 23)
+		c++;
 	pr_debug("clock: changing CORE DPLL rate from %lu to %lu\n", clk->rate,
 		 validrate);
-	pr_debug("clock: SDRC timing params used: %08x %08x %08x\n",
-		 sp->rfr_ctrl, sp->actim_ctrla, sp->actim_ctrlb);
+	pr_debug("clock: SDRC CS0 timing params used:"
+		 " RFR %08x CTRLA %08x CTRLB %08x MR %08x\n",
+		 sdrc_cs0->rfr_ctrl, sdrc_cs0->actim_ctrla,
+		 sdrc_cs0->actim_ctrlb, sdrc_cs0->mr);
+	if (sdrc_cs1)
+		pr_debug("clock: SDRC CS1 timing params used: "
+		 " RFR %08x CTRLA %08x CTRLB %08x MR %08x\n",
+		 sdrc_cs1->rfr_ctrl, sdrc_cs1->actim_ctrla,
+		 sdrc_cs1->actim_ctrlb, sdrc_cs1->mr);
 
-	omap3_configure_core_dpll(sp->rfr_ctrl, sp->actim_ctrla,
-				  sp->actim_ctrlb, new_div, unlock_dll, c,
-				  sp->mr, rate > clk->rate);
+	/*
+	 * Only the SDRC RFRCTRL value is seen to be safe to be
+	 * changed during dvfs.
+	 * The ACTiming values are left unchanged and should be
+	 * the ones programmed by the bootloader for higher OPP.
+	 */
+	if (sdrc_cs1)
+		omap3_configure_core_dpll(
+				  new_div, unlock_dll, c, rate > clk->rate,
+				  sdrc_cs0->rfr_ctrl, sdrc_cs0->mr,
+				  sdrc_cs1->rfr_ctrl, sdrc_cs1->mr);
+	else
+		omap3_configure_core_dpll(
+				  new_div, unlock_dll, c, rate > clk->rate,
+				  sdrc_cs0->rfr_ctrl, sdrc_cs0->mr,
+				  0, 0);
 
 	return 0;
 }
@@ -634,7 +659,7 @@ static void omap3_clkoutx2_recalc(struct
 		pclk = pclk->parent;
 
 	/* clk does not have a DPLL as a parent? */
-	WARN_ON(!pclk);
+	BUG_ON(!pclk);
 
 	dd = pclk->dpll_data;
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/clock34xx.h kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/clock34xx.h
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/clock34xx.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/clock34xx.h	2012-12-16 13:13:01.516330148 +0100
@@ -818,6 +818,8 @@ static struct clk dpll4_m5_ck = {
 	.flags		= CLOCK_IN_OMAP343X | PARENT_CONTROLS_CLOCK,
 	.clkdm		= { .name = "dpll4_clkdm" },
 	.recalc		= &omap2_clksel_recalc,
+	.set_rate	= &omap2_clksel_set_rate,
+	.round_rate	= &omap2_clksel_round_rate,
 };
 
 /* The PWRDN bit is apparently only available on 3430ES2 and above */
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/cm.h kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/cm.h
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/cm.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/cm.h	2012-12-16 13:13:01.516330148 +0100
@@ -74,6 +74,7 @@
 #define OMAP3430ES2_CM_CLKEN2				0x0004
 #define OMAP3430ES2_CM_FCLKEN3				0x0008
 #define OMAP3430_CM_IDLEST_PLL				CM_IDLEST2
+#define OMAP3430_CM_IDLEST3				0x0028
 #define OMAP3430_CM_AUTOIDLE_PLL			CM_AUTOIDLE2
 #define OMAP3430ES2_CM_AUTOIDLE2_PLL			CM_AUTOIDLE2
 #define OMAP3430_CM_CLKSEL1				CM_CLKSEL
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/cm-regbits-34xx.h kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/cm-regbits-34xx.h
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/cm-regbits-34xx.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/cm-regbits-34xx.h	2012-12-16 13:13:01.516330148 +0100
@@ -680,6 +680,7 @@
 #define OMAP3430_CLKSEL_GPT2_SHIFT			0
 
 /* CM_SLEEPDEP_PER specific bits */
+#define OMAP3430_CM_SLEEPDEP_PER_EN_MPU			(1 << 1)
 #define OMAP3430_CM_SLEEPDEP_PER_EN_IVA2		(1 << 2)
 
 /* CM_CLKSTCTRL_PER */
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/control.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/control.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/control.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/control.c	2012-12-16 13:13:01.516330148 +0100
@@ -94,6 +94,7 @@ void *omap3_secure_ram_storage;
  * during the restore path.
  */
 u32 omap3_arm_context[128];
+u32 omap3_aux_ctrl[2] = { 0x1, 0x0 };
 
 struct omap3_control_regs {
 	u32 sysconfig;
@@ -235,7 +236,7 @@ void omap3_save_scratchpad_contents(void
 	prcm_block_contents.cm_clksel_wkup =
 			cm_read_mod_reg(WKUP_MOD, CM_CLKSEL);
 	prcm_block_contents.cm_clken_pll =
-			cm_read_mod_reg(PLL_MOD, OMAP3430_CM_CLKEN_PLL);
+			cm_read_mod_reg(PLL_MOD, CM_CLKEN);
 	prcm_block_contents.cm_autoidle_pll =
 			cm_read_mod_reg(PLL_MOD, OMAP3430_CM_AUTOIDLE_PLL);
 	prcm_block_contents.cm_clksel1_pll =
@@ -265,7 +266,10 @@ void omap3_save_scratchpad_contents(void
 			(sdrc_read_reg(SDRC_ERR_TYPE) & 0xFFFF);
 	sdrc_block_contents.dll_a_ctrl = sdrc_read_reg(SDRC_DLLA_CTRL);
 	sdrc_block_contents.dll_b_ctrl = 0x0;
-	sdrc_block_contents.power = sdrc_read_reg(SDRC_POWER);
+	sdrc_block_contents.power = (sdrc_read_reg(SDRC_POWER) &
+			~(SDRC_POWER_AUTOCOUNT_MASK|SDRC_POWER_CLKCTRL_MASK)) |
+			(1 << SDRC_POWER_AUTOCOUNT_SHIFT) |
+			SDRC_SELF_REFRESH_ON_AUTOCOUNT;
 	sdrc_block_contents.cs_0 = 0x0;
 	sdrc_block_contents.mcfg_0 = sdrc_read_reg(SDRC_MCFG_0);
 	sdrc_block_contents.mr_0 = (sdrc_read_reg(SDRC_MR_0) & 0xFFFF);
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/cpuidle34xx.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/cpuidle34xx.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/cpuidle34xx.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/cpuidle34xx.c	2012-12-16 13:13:01.516330148 +0100
@@ -37,7 +37,7 @@
 
 #define OMAP3_MAX_STATES 7
 #define OMAP3_STATE_C1 0 /* C1 - MPU WFI + Core active */
-#define OMAP3_STATE_C2 1 /* C2 - MPU WFI + Core inactive */
+#define OMAP3_STATE_C2 1 /* C2 - MPU inactive + Core inactive */
 #define OMAP3_STATE_C3 2 /* C3 - MPU CSWR + Core inactive */
 #define OMAP3_STATE_C4 3 /* C4 - MPU OFF + Core iactive */
 #define OMAP3_STATE_C5 4 /* C5 - MPU RET + Core RET */
@@ -136,7 +136,7 @@ return_sleep_time:
 	local_irq_enable();
 	local_fiq_enable();
 
-	return (u32)timespec_to_ns(&ts_idle)/1000;
+	return ts_idle.tv_nsec / NSEC_PER_USEC + ts_idle.tv_sec * USEC_PER_SEC;
 }
 
 /**
@@ -168,7 +168,7 @@ DEFINE_PER_CPU(struct cpuidle_device, om
  *
  * Below is the desciption of each C state.
  * 	C1 . MPU WFI + Core active
- *	C2 . MPU WFI + Core inactive
+ *	C2 . MPU inactive + Core inactive
  *	C3 . MPU CSWR + Core inactive
  *	C4 . MPU OFF + Core inactive
  *	C5 . MPU CSWR + Core CSWR
@@ -180,8 +180,8 @@ void omap_init_power_states(void)
 	/* C1 . MPU WFI + Core active */
 	omap3_power_states[OMAP3_STATE_C1].valid = 1;
 	omap3_power_states[OMAP3_STATE_C1].type = OMAP3_STATE_C1;
-	omap3_power_states[OMAP3_STATE_C1].sleep_latency = 2;
-	omap3_power_states[OMAP3_STATE_C1].wakeup_latency = 2;
+	omap3_power_states[OMAP3_STATE_C1].sleep_latency = 58;
+	omap3_power_states[OMAP3_STATE_C1].wakeup_latency = 52;
 	omap3_power_states[OMAP3_STATE_C1].threshold = 5;
 	omap3_power_states[OMAP3_STATE_C1].mpu_state = PWRDM_POWER_ON;
 	omap3_power_states[OMAP3_STATE_C1].core_state = PWRDM_POWER_ON;
@@ -190,30 +190,31 @@ void omap_init_power_states(void)
 	/* C2 . MPU WFI + Core inactive */
 	omap3_power_states[OMAP3_STATE_C2].valid = 1;
 	omap3_power_states[OMAP3_STATE_C2].type = OMAP3_STATE_C2;
-	omap3_power_states[OMAP3_STATE_C2].sleep_latency = 10;
-	omap3_power_states[OMAP3_STATE_C2].wakeup_latency = 10;
+	omap3_power_states[OMAP3_STATE_C2].sleep_latency = 73;
+	omap3_power_states[OMAP3_STATE_C2].wakeup_latency = 164;
 	omap3_power_states[OMAP3_STATE_C2].threshold = 30;
 	omap3_power_states[OMAP3_STATE_C2].mpu_state = PWRDM_POWER_ON;
 	omap3_power_states[OMAP3_STATE_C2].core_state = PWRDM_POWER_ON;
-	omap3_power_states[OMAP3_STATE_C2].flags = CPUIDLE_FLAG_TIME_VALID;
+	omap3_power_states[OMAP3_STATE_C2].flags = CPUIDLE_FLAG_TIME_VALID |
+				CPUIDLE_FLAG_CHECK_BM;
 
 	/* C3 . MPU CSWR + Core inactive */
-	omap3_power_states[OMAP3_STATE_C3].valid = 1;
+	omap3_power_states[OMAP3_STATE_C3].valid = 0;
 	omap3_power_states[OMAP3_STATE_C3].type = OMAP3_STATE_C3;
-	omap3_power_states[OMAP3_STATE_C3].sleep_latency = 50;
-	omap3_power_states[OMAP3_STATE_C3].wakeup_latency = 50;
-	omap3_power_states[OMAP3_STATE_C3].threshold = 300;
+	omap3_power_states[OMAP3_STATE_C3].sleep_latency = 90;
+	omap3_power_states[OMAP3_STATE_C3].wakeup_latency = 267;
+	omap3_power_states[OMAP3_STATE_C3].threshold = 113872; /* vs. C2 */
 	omap3_power_states[OMAP3_STATE_C3].mpu_state = PWRDM_POWER_RET;
 	omap3_power_states[OMAP3_STATE_C3].core_state = PWRDM_POWER_ON;
 	omap3_power_states[OMAP3_STATE_C3].flags = CPUIDLE_FLAG_TIME_VALID |
 				CPUIDLE_FLAG_CHECK_BM;
 
 	/* C4 . MPU OFF + Core inactive */
-	omap3_power_states[OMAP3_STATE_C4].valid = 1;
+	omap3_power_states[OMAP3_STATE_C4].valid = 0;
 	omap3_power_states[OMAP3_STATE_C4].type = OMAP3_STATE_C4;
-	omap3_power_states[OMAP3_STATE_C4].sleep_latency = 1500;
-	omap3_power_states[OMAP3_STATE_C4].wakeup_latency = 1800;
-	omap3_power_states[OMAP3_STATE_C4].threshold = 4000;
+	omap3_power_states[OMAP3_STATE_C4].sleep_latency = 4130;
+	omap3_power_states[OMAP3_STATE_C4].wakeup_latency = 2130;
+	omap3_power_states[OMAP3_STATE_C4].threshold = 619328; /* vs. C2 */
 	omap3_power_states[OMAP3_STATE_C4].mpu_state = PWRDM_POWER_OFF;
 	omap3_power_states[OMAP3_STATE_C4].core_state = PWRDM_POWER_ON;
 	omap3_power_states[OMAP3_STATE_C4].flags = CPUIDLE_FLAG_TIME_VALID |
@@ -222,20 +223,20 @@ void omap_init_power_states(void)
 	/* C5 . MPU CSWR + Core CSWR*/
 	omap3_power_states[OMAP3_STATE_C5].valid = 1;
 	omap3_power_states[OMAP3_STATE_C5].type = OMAP3_STATE_C5;
-	omap3_power_states[OMAP3_STATE_C5].sleep_latency = 2500;
-	omap3_power_states[OMAP3_STATE_C5].wakeup_latency = 7500;
-	omap3_power_states[OMAP3_STATE_C5].threshold = 12000;
+	omap3_power_states[OMAP3_STATE_C5].sleep_latency = 596;
+	omap3_power_states[OMAP3_STATE_C5].wakeup_latency = 1000;
+	omap3_power_states[OMAP3_STATE_C5].threshold = 7971;
 	omap3_power_states[OMAP3_STATE_C5].mpu_state = PWRDM_POWER_RET;
 	omap3_power_states[OMAP3_STATE_C5].core_state = PWRDM_POWER_RET;
 	omap3_power_states[OMAP3_STATE_C5].flags = CPUIDLE_FLAG_TIME_VALID |
 				CPUIDLE_FLAG_CHECK_BM;
 
 	/* C6 . MPU OFF + Core CSWR */
-	omap3_power_states[OMAP3_STATE_C6].valid = 1;
+	omap3_power_states[OMAP3_STATE_C6].valid = 0;
 	omap3_power_states[OMAP3_STATE_C6].type = OMAP3_STATE_C6;
-	omap3_power_states[OMAP3_STATE_C6].sleep_latency = 3000;
-	omap3_power_states[OMAP3_STATE_C6].wakeup_latency = 8500;
-	omap3_power_states[OMAP3_STATE_C6].threshold = 15000;
+	omap3_power_states[OMAP3_STATE_C6].sleep_latency = 4600;
+	omap3_power_states[OMAP3_STATE_C6].wakeup_latency = 2850;
+	omap3_power_states[OMAP3_STATE_C6].threshold = 2801100; /* vs. C5 */
 	omap3_power_states[OMAP3_STATE_C6].mpu_state = PWRDM_POWER_OFF;
 	omap3_power_states[OMAP3_STATE_C6].core_state = PWRDM_POWER_RET;
 	omap3_power_states[OMAP3_STATE_C6].flags = CPUIDLE_FLAG_TIME_VALID |
@@ -244,9 +245,9 @@ void omap_init_power_states(void)
 	/* C7 . MPU OFF + Core OFF */
 	omap3_power_states[OMAP3_STATE_C7].valid = 1;
 	omap3_power_states[OMAP3_STATE_C7].type = OMAP3_STATE_C7;
-	omap3_power_states[OMAP3_STATE_C7].sleep_latency = 10000;
-	omap3_power_states[OMAP3_STATE_C7].wakeup_latency = 30000;
-	omap3_power_states[OMAP3_STATE_C7].threshold = 300000;
+	omap3_power_states[OMAP3_STATE_C7].sleep_latency = 4760;
+	omap3_power_states[OMAP3_STATE_C7].wakeup_latency = 7780;
+	omap3_power_states[OMAP3_STATE_C7].threshold = 610082;
 	omap3_power_states[OMAP3_STATE_C7].mpu_state = PWRDM_POWER_OFF;
 	omap3_power_states[OMAP3_STATE_C7].core_state = PWRDM_POWER_OFF;
 	omap3_power_states[OMAP3_STATE_C7].flags = CPUIDLE_FLAG_TIME_VALID |
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/io.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/io.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/io.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/io.c	2012-12-16 13:13:01.520330148 +0100
@@ -234,7 +234,8 @@ static int __init _omap2_init_reprogram_
 	return v;
 }
 
-void __init omap2_init_common_hw(struct omap_sdrc_params *sp,
+void __init omap2_init_common_hw(struct omap_sdrc_params *sdrc_cs0,
+				 struct omap_sdrc_params *sdrc_cs1,
 				 struct omap_opp *mpu_opps,
 				 struct omap_opp *dsp_opps,
 				 struct omap_opp *l3_opps)
@@ -247,7 +248,7 @@ void __init omap2_init_common_hw(struct
 	omapdev_init(omapdevs);
 	omap2_clk_init();
 	omap_pm_if_init();
-	omap2_sdrc_init(sp);
+	omap2_sdrc_init(sdrc_cs0, sdrc_cs1);
 
 	_omap2_init_reprogram_sdrc();
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/irq.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/irq.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/irq.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/irq.c	2012-12-16 13:13:01.520330148 +0100
@@ -174,8 +174,10 @@ static void __init omap_irq_bank_init_on
 	while (!(intc_bank_read_reg(bank, INTC_SYSSTATUS) & 0x1))
 		/* Wait for reset to complete */;
 
-	/* Enable autoidle */
+	/* Do not enable autoidle as it seems to cause problems */
+#if 0
 	intc_bank_write_reg(1 << 0, bank, INTC_SYSCONFIG);
+#endif
 }
 
 int omap_irq_pending(void)
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/Kconfig kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/Kconfig
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/Kconfig	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/Kconfig	2012-12-16 13:13:01.520330148 +0100
@@ -64,7 +64,7 @@ config MACH_NOKIA_RX51
 
 config VIDEO_MACH_RX51
 	tristate "Nokia RX-51 board camera"
-	depends on MACH_NOKIA_RX51 && VIDEO_DEV && TWL4030_CORE
+	depends on MACH_NOKIA_RX51 && VIDEO_DEV && VIDEO_OMAP3 && TWL4030_CORE
 
 config VIDEO_MACH_RX51_OLD_I2C
 	bool "Camera related devices on I2C bus 2 instead of 3"
@@ -156,6 +156,6 @@ config MACH_OMAP3_PANDORA
 
 config RX51_CAMERA_BUTTON
 	tristate "RX51 Camera Button"
-	depends on MACH_NOKIA_RX51
+	depends on VIDEO_MACH_RX51
 	help
 	  Say Y here if you want to support the rx51 camera button
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/mcbsp.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/mcbsp.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/mcbsp.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/mcbsp.c	2012-12-16 13:13:01.520330148 +0100
@@ -145,7 +145,7 @@ static struct omap_mcbsp_platform_data o
 		.ops		= &omap2_mcbsp_ops,
 		.clk_names	= clk_names,
 		.num_clks	= 2,
-		.buffer_size	= 0x7F,
+		.buffer_size	= 0x6F,
 	},
 	{
 		.phys_base	= OMAP34XX_MCBSP2_BASE,
@@ -169,7 +169,7 @@ static struct omap_mcbsp_platform_data o
 		.ops		= &omap2_mcbsp_ops,
 		.clk_names	= clk_names,
 		.num_clks	= 2,
-		.buffer_size	= 0x7F,
+		.buffer_size	= 0x6F,
 	},
 	{
 		.phys_base	= OMAP34XX_MCBSP4_BASE,
@@ -180,7 +180,7 @@ static struct omap_mcbsp_platform_data o
 		.ops		= &omap2_mcbsp_ops,
 		.clk_names	= clk_names,
 		.num_clks	= 2,
-		.buffer_size	= 0x7F,
+		.buffer_size	= 0x6F,
 	},
 	{
 		.phys_base	= OMAP34XX_MCBSP5_BASE,
@@ -191,7 +191,7 @@ static struct omap_mcbsp_platform_data o
 		.ops		= &omap2_mcbsp_ops,
 		.clk_names	= clk_names,
 		.num_clks	= 2,
-		.buffer_size	= 0x7F,
+		.buffer_size	= 0x6F,
 	},
 };
 #define OMAP34XX_MCBSP_PDATA_SZ		ARRAY_SIZE(omap34xx_mcbsp_pdata)
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/mmc-twl4030.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/mmc-twl4030.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/mmc-twl4030.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/mmc-twl4030.c	2012-12-16 13:13:01.520330148 +0100
@@ -23,6 +23,7 @@
 #include <mach/control.h>
 #include <mach/mmc.h>
 #include <mach/board.h>
+#include <mach/omap-pm.h>
 
 #include "mmc-twl4030.h"
 
@@ -226,7 +227,6 @@ static void twl_mmc_cleanup(struct devic
 }
 
 #ifdef CONFIG_PM
-
 static int twl_mmc_suspend(struct device *dev, int slot)
 {
 	struct omap_mmc_platform_data *mmc = dev->platform_data;
@@ -248,6 +248,17 @@ static int twl_mmc_resume(struct device
 #define twl_mmc_resume	NULL
 #endif
 
+#if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_PM)
+
+static int twl4030_mmc_get_context_loss(struct device *dev)
+{
+	return omap_pm_get_dev_context_loss_count(dev);
+}
+
+#else
+#define twl4030_mmc_get_context_loss NULL
+#endif
+
 /*
  * Sets the MMC voltage in twl4030
  */
@@ -258,12 +269,11 @@ static int twl_mmc_resume(struct device
 		|MMC_VDD_25_26|MMC_VDD_26_27|MMC_VDD_27_28 \
 		|MMC_VDD_28_29|MMC_VDD_29_30|MMC_VDD_30_31|MMC_VDD_31_32)
 
-
 #define VMMC1_ID 5
 #define VMMC2_ID 6
 #define VAUX3_ID 3
 #define VSIM_ID 9
-
+#define BAD_ID 255
 
 static int twl_mmc_i2c_wait(void)
 {
@@ -286,38 +296,10 @@ static int twl_mmc_i2c_wait(void)
 	return -1;
 }
 
-static int twl_mmc_enable_regulator(u8 vmmc_dev_grp)
+static int twl_mmc_send_pb_msg(u16 msg)
 {
 	int ret;
-	u16 msg;
-	u8 reg_id, pwb_state;
-
-	switch (vmmc_dev_grp) {
-	case VMMC1_DEV_GRP:
-		reg_id = VMMC1_ID;
-		break;
-	case VMMC2_DEV_GRP:
-		reg_id = VMMC2_ID;
-		break;
-	case VAUX3_DEV_GRP:
-		reg_id = VAUX3_ID;
-		break;
-	case VSIM_DEV_GRP:
-		reg_id = VSIM_ID;
-		break;
-	default:
-		printk(KERN_ERR "twl_mmc_enable_regulator: unknown dev grp\n");
-		return -1;
-	}
-
-	/* add regulator to dev grp P1 */
-	ret = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
-				   VMMC_DEV_GRP_P1, vmmc_dev_grp);
-	if (ret)
-		return ret;
-
-	/* construct message to enable regulator on P1 */
-	msg = (1 << 13) | (reg_id << 4) | 0xe;
+	u8 pwb_state;
 
 	ret = twl4030_i2c_read_u8(TWL4030_MODULE_PM_MASTER,
 				  &pwb_state, 0x14);
@@ -352,10 +334,62 @@ out:
 	twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER,
 			     pwb_state, 0x14);
 
+	return ret;
+}
+
+static u8 dev_grp_to_id(u8 vmmc_dev_grp)
+{
+	switch (vmmc_dev_grp) {
+	case VMMC1_DEV_GRP:
+		return VMMC1_ID;
+	case VMMC2_DEV_GRP:
+		return VMMC2_ID;
+	case VAUX3_DEV_GRP:
+		return VAUX3_ID;
+	case VSIM_DEV_GRP:
+		return VSIM_ID;
+	default:
+		return BAD_ID;
+	}
+}
+
+static int twl_mmc_regulator_set_mode(u8 vmmc_dev_grp, int sleep)
+{
+	u8 reg_id = dev_grp_to_id(vmmc_dev_grp);
+	u16 msg;
+
+	if (reg_id == BAD_ID)
+		return -EINVAL;
+
+	if (sleep)
+		msg = MSG_SINGULAR(DEV_GRP_P1, reg_id, RES_STATE_SLEEP);
+	else
+		msg = MSG_SINGULAR(DEV_GRP_P1, reg_id, RES_STATE_ACTIVE);
+
+	return twl_mmc_send_pb_msg(msg);
+}
+
+static int twl_mmc_enable_regulator(u8 vmmc_dev_grp)
+{
+	int ret;
+	u16 msg;
+	u8 reg_id = dev_grp_to_id(vmmc_dev_grp);
+
+	if (reg_id == BAD_ID) {
+		printk(KERN_ERR "twl_mmc_enable_regulator: unknown dev grp\n");
+		return -1;
+	}
+
+	/* add regulator to dev grp P1 */
+	ret = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
+				   VMMC_DEV_GRP_P1, vmmc_dev_grp);
 	if (ret)
 		return ret;
 
-	return 0;
+	/* construct message to enable regulator on P1 */
+	msg = (1 << 13) | (reg_id << 4) | 0xe;
+
+	return twl_mmc_send_pb_msg(msg);
 }
 
 static int twl_mmc_set_regulator(u8 vmmc_dev_grp, u8 vmmc)
@@ -580,6 +614,72 @@ static int twl_mmc2_set_power(struct dev
 	return ret;
 }
 
+static int twl_mmc1_set_sleep(struct device *dev, int slot, int sleep, int vdd,
+			      int cardsleep)
+{
+	struct twl_mmc_controller *c = &hsmmc[0];
+	int err;
+
+	if (!c->vsim_18v)
+		return twl_mmc_regulator_set_mode(c->twl_vmmc_dev_grp, sleep);
+
+	if (cardsleep) {
+		/* VCC can be turned off if card is asleep */
+		c->vsim_18v = 0;
+		if (sleep)
+			err = twl_mmc1_set_power(dev, slot, 0, 0);
+		else
+			err = twl_mmc1_set_power(dev, slot, 1, vdd);
+		c->vsim_18v = 1;
+	} else
+		err = twl_mmc_regulator_set_mode(c->twl_vmmc_dev_grp, sleep);
+	if (err)
+		return err;
+	return twl_mmc_regulator_set_mode(VSIM_DEV_GRP, sleep);
+}
+
+static int twl_mmc2_set_sleep(struct device *dev, int slot, int sleep, int vdd,
+			      int cardsleep)
+{
+	struct twl_mmc_controller *c = &hsmmc[1];
+
+	int err;
+
+	if (!c->vsim_18v)
+		return twl_mmc_regulator_set_mode(c->twl_vmmc_dev_grp, sleep);
+
+	if (cardsleep) {
+		/* VCC can be turned off if card is asleep */
+		c->vsim_18v = 0;
+		if (sleep)
+			err = twl_mmc2_set_power(dev, slot, 0, 0);
+		else
+			err = twl_mmc2_set_power(dev, slot, 1, vdd);
+		c->vsim_18v = 1;
+	} else
+		err = twl_mmc_regulator_set_mode(c->twl_vmmc_dev_grp, sleep);
+	if (err)
+		return err;
+	return twl_mmc_regulator_set_mode(VSIM_DEV_GRP, sleep);
+}
+
+#if defined(CONFIG_BRIDGE_DVFS)
+/*
+ * This handler can be used for setting other DVFS/PM constraints:
+ * intr latency, wakeup latency, DMA start latency, bus throughput
+ * according to API in mach/omap-pm.h
+ * Currently we only set constraints for MPU frequency which forces
+ * VDD1 to stay at OPP3.
+ */
+#define MMC_MIN_MPU_FREQUENCY	500000000	/* S500M at OPP3 */
+static void mmc_set_pm_constraints(struct device *dev, int on)
+{
+	omap_pm_set_min_mpu_freq(dev, (on ? MMC_MIN_MPU_FREQUENCY : 0));
+}
+#else
+#define mmc_set_pm_constraints NULL
+#endif
+
 static struct omap_mmc_platform_data *hsmmc_data[OMAP34XX_NR_MMC] __initdata;
 
 void __init twl4030_mmc_init(struct twl4030_hsmmc_info *controllers)
@@ -642,6 +742,11 @@ void __init twl4030_mmc_init(struct twl4
 		} else
 			mmc->slots[0].switch_pin = -EINVAL;
 
+		mmc->get_context_loss_count =
+				twl4030_mmc_get_context_loss;
+
+		mmc->set_pm_constraints = mmc_set_pm_constraints;
+
 		/* write protect normally uses an OMAP gpio */
 		if (gpio_is_valid(c->gpio_wp)) {
 			gpio_request(c->gpio_wp, "mmc_wp");
@@ -652,6 +757,11 @@ void __init twl4030_mmc_init(struct twl4
 		} else
 			mmc->slots[0].gpio_wp = -EINVAL;
 
+		if (c->power_saving)
+			mmc->slots[0].power_saving = 1;
+
+		mmc->slots[0].caps = c->caps;
+
 		/* NOTE:  we assume OMAP's MMC1 and MMC2 use
 		 * the TWL4030's VMMC1 and VMMC2, respectively;
 		 * and that OMAP's MMC3 isn't used.
@@ -660,10 +770,12 @@ void __init twl4030_mmc_init(struct twl4
 		switch (c->mmc) {
 		case 1:
 			mmc->slots[0].set_power = twl_mmc1_set_power;
+			mmc->slots[0].set_sleep = twl_mmc1_set_sleep;
 			mmc->slots[0].ocr_mask = MMC1_OCR;
 			break;
 		case 2:
 			mmc->slots[0].set_power = twl_mmc2_set_power;
+			mmc->slots[0].set_sleep = twl_mmc2_set_sleep;
 			if (c->vmmc_dev_grp)
 				twl->twl_vmmc_dev_grp = c->vmmc_dev_grp;
 			if (c->transceiver)
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/mmc-twl4030.h kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/mmc-twl4030.h
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/mmc-twl4030.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/mmc-twl4030.h	2012-12-16 13:13:01.520330148 +0100
@@ -14,6 +14,8 @@ struct twl4030_hsmmc_info {
 	u8      vmmc_dev_grp;   /* override default regulator */
 	bool	vsim_18v;	/* MMC-2 option */
 	bool	cover_only;	/* No card detect - just cover switch */
+	bool	power_saving;	/* Try to sleep or power off when possible */
+	unsigned long caps;	/* MMC host capabilities */
 	int	gpio_cd;	/* or -EINVAL */
 	int	gpio_wp;	/* or -EINVAL */
 	char	*name;		/* or NULL for default */
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/mux.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/mux.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/mux.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/mux.c	2012-12-16 13:13:01.520330148 +0100
@@ -472,6 +472,11 @@ MUX_CFG_34XX("AF5_34XX_GPIO142", 0x170,
 MUX_CFG_34XX("AE5_34XX_GPIO143", 0x172,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
 
+/* OMAP3 SDRC CKE signals to SDR/DDR ram chips */
+MUX_CFG_34XX("H16_34XX_SDRC_CKE0", 0x262,
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("H17_34XX_SDRC_CKE1", 0x264,
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
 };
 
 #define OMAP34XX_PINS_SZ	ARRAY_SIZE(omap34xx_pins)
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/omapdev242x.h kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/omapdev242x.h
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/omapdev242x.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/omapdev242x.h	2012-12-16 13:13:01.520330148 +0100
@@ -230,7 +230,7 @@ static struct omapdev dap_242x_omapdev =
 static struct omapdev dsi_242x_omapdev = {
 	.name		= "dsi_omapdev",
 	.pwrdm		= { .name = "core_pwrdm" },
-	.pdev_name	= "omap-dss",
+	.pdev_name	= "omapdss",
 	.pdev_id	= -1,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
@@ -238,7 +238,7 @@ static struct omapdev dsi_242x_omapdev =
 static struct omapdev dsi_pll_242x_omapdev = {
 	.name		= "dsi_pll_omapdev",
 	.pwrdm		= { .name = "core_pwrdm" },
-	.pdev_name	= "omap-dss",
+	.pdev_name	= "omapdss",
 	.pdev_id	= -1,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
@@ -246,7 +246,7 @@ static struct omapdev dsi_pll_242x_omapd
 static struct omapdev dss_242x_omapdev = {
 	.name		= "dss_omapdev",
 	.pwrdm		= { .name = "core_pwrdm" },
-	.pdev_name	= "omap-dss",
+	.pdev_name	= "omapdss",
 	.pdev_id	= -1,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
@@ -254,7 +254,7 @@ static struct omapdev dss_242x_omapdev =
 static struct omapdev dispc_242x_omapdev = {
 	.name		= "dispc_omapdev",
 	.pwrdm		= { .name = "core_pwrdm" },
-	.pdev_name	= "omap-dss",
+	.pdev_name	= "omapdss",
 	.pdev_id	= -1,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
@@ -262,7 +262,7 @@ static struct omapdev dispc_242x_omapdev
 static struct omapdev rfbi_242x_omapdev = {
 	.name		= "rfbi_omapdev",
 	.pwrdm		= { .name = "core_pwrdm" },
-	.pdev_name	= "omap-dss",
+	.pdev_name	= "omapdss",
 	.pdev_id	= -1,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
@@ -270,7 +270,7 @@ static struct omapdev rfbi_242x_omapdev
 static struct omapdev venc_242x_omapdev = {
 	.name		= "venc_omapdev",
 	.pwrdm		= { .name = "core_pwrdm" },
-	.pdev_name	= "omap-dss",
+	.pdev_name	= "omapdss",
 	.pdev_id	= -1,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/omapdev243x.h kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/omapdev243x.h
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/omapdev243x.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/omapdev243x.h	2012-12-16 13:13:01.520330148 +0100
@@ -237,7 +237,7 @@ static struct omapdev dap_243x_omapdev =
 static struct omapdev dsi_243x_omapdev = {
 	.name		= "dsi_omapdev",
 	.pwrdm		= { .name = "core_pwrdm" },
-	.pdev_name	= "omap-dss",
+	.pdev_name	= "omapdss",
 	.pdev_id	= -1,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2430),
 };
@@ -245,7 +245,7 @@ static struct omapdev dsi_243x_omapdev =
 static struct omapdev dsi_pll_243x_omapdev = {
 	.name		= "dsi_pll_omapdev",
 	.pwrdm		= { .name = "core_pwrdm" },
-	.pdev_name	= "omap-dss",
+	.pdev_name	= "omapdss",
 	.pdev_id	= -1,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2430),
 };
@@ -253,7 +253,7 @@ static struct omapdev dsi_pll_243x_omapd
 static struct omapdev dss_243x_omapdev = {
 	.name		= "dss_omapdev",
 	.pwrdm		= { .name = "core_pwrdm" },
-	.pdev_name	= "omap-dss",
+	.pdev_name	= "omapdss",
 	.pdev_id	= -1,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2430),
 };
@@ -261,7 +261,7 @@ static struct omapdev dss_243x_omapdev =
 static struct omapdev dispc_243x_omapdev = {
 	.name		= "dispc_omapdev",
 	.pwrdm		= { .name = "core_pwrdm" },
-	.pdev_name	= "omap-dss",
+	.pdev_name	= "omapdss",
 	.pdev_id	= -1,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2430),
 };
@@ -269,7 +269,7 @@ static struct omapdev dispc_243x_omapdev
 static struct omapdev rfbi_243x_omapdev = {
 	.name		= "rfbi_omapdev",
 	.pwrdm		= { .name = "core_pwrdm" },
-	.pdev_name	= "omap-dss",
+	.pdev_name	= "omapdss",
 	.pdev_id	= -1,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2430),
 };
@@ -277,7 +277,7 @@ static struct omapdev rfbi_243x_omapdev
 static struct omapdev venc_243x_omapdev = {
 	.name		= "venc_omapdev",
 	.pwrdm		= { .name = "core_pwrdm" },
-	.pdev_name	= "omap-dss",
+	.pdev_name	= "omapdss",
 	.pdev_id	= -1,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2430),
 };
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/omapdev3xxx.h kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/omapdev3xxx.h
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/omapdev3xxx.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/omapdev3xxx.h	2012-12-16 13:13:01.520330148 +0100
@@ -250,7 +250,7 @@ static struct omapdev mcbsp5_3xxx_omapde
 static struct omapdev hsmmc1_3xxx_omapdev = {
 	.name		= "hsmmc1_omapdev",
 	.pwrdm		= { .name = "core_pwrdm" },
-	.pdev_name	= "mmci-omap",
+	.pdev_name	= "mmci-omap-hs",
 	.pdev_id	= 0,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
 };
@@ -258,7 +258,7 @@ static struct omapdev hsmmc1_3xxx_omapde
 static struct omapdev hsmmc2_3xxx_omapdev = {
 	.name		= "hsmmc2_omapdev",
 	.pwrdm		= { .name = "core_pwrdm" },
-	.pdev_name	= "mmci-omap",
+	.pdev_name	= "mmci-omap-hs",
 	.pdev_id	= 1,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430),
 };
@@ -374,7 +374,7 @@ static struct omapdev neon_3xxx_omapdev
 static struct omapdev sgx_3xxx_omapdev = {
 	.name		= "sgx_omapdev",
 	.pwrdm		= { .name = "sgx_pwrdm" },
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430ES2),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES2),
 };
 
 /* CORE */
@@ -433,9 +433,9 @@ static struct omapdev i2c3_3xxx_omapdev
 static struct omapdev hsmmc3_3xxx_omapdev = {
 	.name		= "hsmmc3_omapdev",
 	.pwrdm		= { .name = "core_pwrdm" },
-	.pdev_name	= "mmci-omap",
+	.pdev_name	= "mmci-omap-hs",
 	.pdev_id	= 2,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430ES2),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES2),
 };
 
 static struct omapdev mcspi4_3xxx_omapdev = {
@@ -658,7 +658,7 @@ static struct omapdev usbhost_3xxx_omapd
 	.pwrdm		= { .name = "usbhost_pwrdm" },
 	.pdev_name	= "ehci-omap",
 	.pdev_id	= 0,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430ES2),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES2),
 };
 
 static struct omapdev usbotg_3xxx_omapdev = {
@@ -666,7 +666,7 @@ static struct omapdev usbotg_3xxx_omapde
 	.pwrdm		= { .name = "usbhost_pwrdm" },
 	.pdev_name	= "musb_hdrc",
 	.pdev_id	= -1,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430ES2),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES2),
 };
 
 static struct omapdev usbtll_3xxx_omapdev = {
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/omap3-opp.h kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/omap3-opp.h
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/omap3-opp.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/omap3-opp.h	2012-12-16 13:13:01.520330148 +0100
@@ -24,9 +24,9 @@
 static struct omap_opp omap3_mpu_rate_table[] = {
 	{0, 0, 0},
 	/*OPP1*/
-	{S125M, VDD1_OPP1, 0x1E},
+	{0, VDD1_OPP1, 0x1E},
 	/*OPP2*/
-	{S250M, VDD1_OPP2, 0x24},
+	{S250M, VDD1_OPP2, 0x26},
 	/*OPP3*/
 	{S500M, VDD1_OPP3, 0x30},
 	/*OPP4*/
@@ -50,7 +50,7 @@ static struct omap_opp omap3_dsp_rate_ta
 	/*OPP1*/
 	{S90M, VDD1_OPP1, 0x1E},
 	/*OPP2*/
-	{S180M, VDD1_OPP2, 0x24},
+	{S180M, VDD1_OPP2, 0x26},
 	/*OPP3*/
 	{S360M, VDD1_OPP3, 0x30},
 	/*OPP4*/
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/pm.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/pm.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/pm.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/pm.c	2012-12-16 13:13:01.520330148 +0100
@@ -215,7 +215,7 @@ void omap2_allow_sleep(void)
 	BUG_ON(i < 0);
 }
 
-unsigned get_last_off_on_transaction_id(struct device *dev)
+int get_last_off_on_transaction_id(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct omapdev *odev = omapdev_find_pdev(pdev);
@@ -224,7 +224,7 @@ unsigned get_last_off_on_transaction_id(
 	if (odev) {
 		pwrdm = omapdev_get_pwrdm(odev);
 		if (pwrdm)
-			return pwrdm->state_counter[0];
+			return pwrdm->state_counter[0] & INT_MAX;
 	}
 
 	return 0;
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/pm-debug.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/pm-debug.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/pm-debug.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/pm-debug.c	2012-12-16 13:13:01.520330148 +0100
@@ -169,6 +169,7 @@ static int pm_dbg_init_done;
 enum {
 	DEBUG_FILE_COUNTERS = 0,
 	DEBUG_FILE_TIMERS,
+	DEBUG_FILE_RESOURCES
 };
 
 struct pm_module_def {
@@ -433,6 +434,9 @@ static int pm_dbg_open(struct inode *ino
 	case DEBUG_FILE_COUNTERS:
 		return single_open(file, pm_dbg_show_counters,
 			&inode->i_private);
+	case DEBUG_FILE_RESOURCES:
+		return single_open(file, resource_dump_reqs,
+			&inode->i_private);
 	case DEBUG_FILE_TIMERS:
 	default:
 		return single_open(file, pm_dbg_show_timers,
@@ -542,6 +546,8 @@ static int __init pm_dbg_init(void)
 		d, (void *)DEBUG_FILE_COUNTERS, &debug_fops);
 	(void) debugfs_create_file("time", S_IRUGO,
 		d, (void *)DEBUG_FILE_TIMERS, &debug_fops);
+	(void) debugfs_create_file("resources", S_IRUGO,
+		d, (void *)DEBUG_FILE_RESOURCES, &debug_fops);
 
 	pwrdm_for_each(pwrdms_setup, (void *)d);
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/pm.h kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/pm.h
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/pm.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/pm.h	2012-12-16 13:13:01.520330148 +0100
@@ -40,7 +40,12 @@ struct prm_setup_times {
 	u16 voltoffset;
 	u16 voltsetup2;
 };
+#endif
 
+extern void vfp_pm_save_context(void);
+extern void vfp_pm_restore_context(void);
+extern void vfp_enable(void);
+#if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_PM)
 extern void omap3_pm_off_mode_enable(int);
 extern int omap3_pm_get_suspend_state(struct powerdomain *pwrdm);
 extern int omap3_pm_set_suspend_state(struct powerdomain *pwrdm, int state);
@@ -49,6 +54,7 @@ extern void omap3_set_prm_setup_times(st
 #define omap3_pm_off_mode_enable(int) do {} while (0);
 #define omap3_pm_get_suspend_state(pwrdm) do {} while (0);
 #define omap3_pm_set_suspend_state(pwrdm, state) do {} while (0);
+#define omap3_set_prm_setup_times(setup_times) do {} while (0);
 #endif
 extern int set_pwrdm_state(struct powerdomain *pwrdm, u32 state);
 extern int resource_set_opp_level(int res, u32 target_level, int flags);
@@ -65,11 +71,13 @@ extern int omap2_pm_debug;
 extern void pm_dbg_update_time(struct powerdomain *pwrdm, int prev);
 extern int pm_dbg_regset_save(int reg_set);
 extern int pm_dbg_regset_init(int reg_set);
+extern int resource_dump_reqs(struct seq_file *s, void *unused);
 #else
 #define omap2_pm_dump(mode, resume, us)		do {} while (0);
 #define omap2_pm_debug				0
 #define pm_dbg_update_time(pwrdm, prev) do {} while (0);
 #define pm_dbg_regset_save(reg_set) do {} while (0);
 #define pm_dbg_regset_init(reg_set) do {} while (0);
+#define resource_dump_reqs(s,unused) do {} while (0);
 #endif /* CONFIG_PM_DEBUG */
 #endif
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/pm34xx.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/pm34xx.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/pm34xx.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/pm34xx.c	2012-12-16 13:13:01.524330148 +0100
@@ -26,6 +26,7 @@
 #include <linux/module.h>
 #include <linux/list.h>
 #include <linux/err.h>
+#include <linux/delay.h>
 
 #include <mach/gpio.h>
 #include <mach/sram.h>
@@ -42,6 +43,9 @@
 #include <mach/dma.h>
 #include <mach/gpmc.h>
 #include <mach/dma.h>
+#include <mach/vrfb.h>
+#include <mach/ssi.h>
+
 #include <asm/tlbflush.h>
 
 #include "cm.h"
@@ -53,17 +57,59 @@
 #include "smartreflex.h"
 #include "sdrc.h"
 
-#define SDRC_POWER_AUTOCOUNT_SHIFT 8
-#define SDRC_POWER_AUTOCOUNT_MASK (0xffff << SDRC_POWER_AUTOCOUNT_SHIFT)
-#define SDRC_POWER_CLKCTRL_SHIFT 4
-#define SDRC_POWER_CLKCTRL_MASK (0x3 << SDRC_POWER_CLKCTRL_SHIFT)
-#define SDRC_SELF_REFRESH_ON_AUTOCOUNT (0x2 << SDRC_POWER_CLKCTRL_SHIFT)
-
 /* Scratchpad offsets */
 #define OMAP343X_TABLE_ADDRESS_OFFSET	   0x31
 #define OMAP343X_TABLE_VALUE_OFFSET	   0x30
 #define OMAP343X_CONTROL_REG_VALUE_OFFSET  0x32
 
+/* IDLEST bitmasks for core status checks */
+#define CORE_IDLEST1_ALL		(\
+		OMAP3430ES2_ST_MMC3_MASK|OMAP3430_ST_ICR_MASK|\
+		OMAP3430_ST_AES2_MASK|OMAP3430_ST_SHA12_MASK|\
+		OMAP3430_ST_DES2_MASK|OMAP3430_ST_MMC2_MASK|\
+		OMAP3430_ST_MMC1_MASK|OMAP3430_ST_MSPRO_MASK|\
+		OMAP3430_ST_HDQ_MASK|OMAP3430_ST_MCSPI4_MASK|\
+		OMAP3430_ST_MCSPI3_MASK|OMAP3430_ST_MCSPI2_MASK|\
+		OMAP3430_ST_MCSPI1_MASK|OMAP3430_ST_I2C3_MASK|\
+		OMAP3430_ST_I2C2_MASK|OMAP3430_ST_I2C1_MASK|\
+		OMAP3430_ST_UART2_MASK|OMAP3430_ST_UART1_MASK|\
+		OMAP3430_ST_GPT11_MASK|OMAP3430_ST_GPT10_MASK|\
+		OMAP3430_ST_MCBSP5_MASK|OMAP3430_ST_MCBSP1_MASK|\
+		OMAP3430ES2_ST_HSOTGUSB_STDBY_MASK|\
+		OMAP3430ES2_ST_SSI_IDLE_MASK|OMAP3430_ST_SDMA_MASK|\
+		OMAP3430_ST_SSI_STDBY_MASK|OMAP3430_ST_D2D_MASK)
+#define CORE_IDLEST2_ALL		(\
+		OMAP3430_ST_PKA_MASK|OMAP3430_ST_AES1_MASK|\
+		OMAP3430_ST_RNG_MASK|OMAP3430_ST_SHA11_MASK|\
+		OMAP3430_ST_DES1_MASK)
+#define CORE_IDLEST3_ALL		(\
+		OMAP3430ES2_ST_USBTLL_MASK|OMAP3430ES2_ST_CPEFUSE_MASK)
+#define PER_IDLEST_ALL			(\
+		OMAP3430_ST_WDT3_MASK|OMAP3430_ST_MCBSP4_MASK|\
+		OMAP3430_ST_MCBSP3_MASK|OMAP3430_ST_MCBSP2_MASK|\
+		OMAP3430_ST_GPT9_MASK|OMAP3430_ST_GPT8_MASK|\
+		OMAP3430_ST_GPT7_MASK|OMAP3430_ST_GPT6_MASK|\
+		OMAP3430_ST_GPT5_MASK|OMAP3430_ST_GPT4_MASK|\
+		OMAP3430_ST_GPT3_MASK|OMAP3430_ST_GPT2_MASK)
+
+#define SGX_IDLEST_ALL			OMAP_ST_GFX
+#define DSS_IDLEST_ALL			(\
+		OMAP3430ES2_ST_DSS_STDBY_MASK|\
+		OMAP3430ES2_ST_DSS_IDLE_MASK)
+#define CAM_IDLEST_ALL			OMAP3430_ST_CAM
+
+#define OMAP343X_SSI_PORT1_BASE		0x48058000
+#define CONTROL_PADCONF_MCBSP4_DX	0x158
+#define CONTROL_PADCONF_UART1_TX	0x14c
+
+static u16 ssi_rx_rdy;
+static u16 ssi_tx_dat;
+static u16 ssi_tx_flag;
+static int ssi_pads_saved;
+
+/* Interrupt controller control register offset */
+#define INTC_CONTROL	0x48
+
 struct power_state {
 	struct powerdomain *pwrdm;
 	u32 next_state;
@@ -83,7 +129,7 @@ static void (*saved_idle)(void);
 
 static struct powerdomain *mpu_pwrdm, *neon_pwrdm;
 static struct powerdomain *core_pwrdm, *per_pwrdm;
-static struct powerdomain *cam_pwrdm;
+static struct powerdomain *cam_pwrdm, *iva2_pwrdm, *dss_pwrdm, *usb_pwrdm;
 
 static struct prm_setup_times prm_setup = {
 	.clksetup = 0xff,
@@ -131,22 +177,136 @@ static void omap3_disable_io_chain(void)
 		prm_clear_mod_reg_bits(OMAP3430_EN_IO_CHAIN, WKUP_MOD, PM_WKEN);
 }
 
+/*
+ * The following 4 helper functions are a workaround for a hardware bug
+ * which causes SSI_RX_RDY, SSI_TX_DAT and SSI_TX_FLAG to be raised
+ * erronously after resume from off mode. We work around this issue by
+ * putting these pads into tristate mode and enable their internal pull
+ * down before we enter off * mode. After resuming off mode, we reset
+ * the SSI module and then restore the configuration of these pads to their
+ * original state.
+ */
+
+static void save_ssi_padconf(void)
+{
+
+	ssi_rx_rdy = omap_ctrl_readw(OMAP2_CONTROL_PADCONFS +
+					CONTROL_PADCONF_MCBSP4_DX);
+	ssi_tx_dat = omap_ctrl_readw(OMAP2_CONTROL_PADCONFS +
+					CONTROL_PADCONF_UART1_TX);
+	ssi_tx_flag = omap_ctrl_readw(OMAP2_CONTROL_PADCONFS +
+					CONTROL_PADCONF_UART1_TX + 2);
+}
+
+static void ssi_padconf_save_mode(void)
+{
+	u32 fck_core1;
+
+	ssi_pads_saved = 0;
+
+	fck_core1 = cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
+
+	if (fck_core1 & 1)
+		return ;
+
+	/* Set pad to save mode and enable pulldown */
+	omap_ctrl_writew(0x10f, OMAP2_CONTROL_PADCONFS +
+					CONTROL_PADCONF_MCBSP4_DX);
+	omap_ctrl_writew(0x10f, OMAP2_CONTROL_PADCONFS +
+					CONTROL_PADCONF_UART1_TX);
+	omap_ctrl_writew(0x10f, OMAP2_CONTROL_PADCONFS +
+					CONTROL_PADCONF_UART1_TX + 2);
+
+	ssi_pads_saved = 1;
+}
+
+static void reset_ssi(void)
+{
+	int timeout = 0;
+
+	/* reset the SSI module */
+
+	cm_set_mod_reg_bits(0x1, CORE_MOD, CM_ICLKEN);
+	cm_set_mod_reg_bits(0x1, CORE_MOD, CM_FCLKEN);
+
+	while (cm_read_mod_reg(CORE_MOD, CM_IDLEST1) &
+		        OMAP3430ES2_ST_SSI_IDLE_MASK) {
+		timeout++;
+		if (timeout > 1000)
+			break;
+		}
+
+	omap_writel(SSI_SOFTRESET, OMAP343X_SSI_PORT1_BASE +
+			SSI_SYS_SYSCONFIG_REG);
+	dsb();
+
+	timeout = 0;
+	while (!(omap_readl(SSI_SYS_SYSSTATUS_REG + OMAP343X_SSI_PORT1_BASE)
+			& SSI_RESETDONE)) {
+		timeout++;
+		if (timeout > 1000)
+			break;
+		}
+
+	cm_clear_mod_reg_bits(0x1, CORE_MOD, CM_ICLKEN);
+	cm_clear_mod_reg_bits(0x1, CORE_MOD, CM_FCLKEN);
+}
+
+static void restore_ssi_padconf(void)
+{
+	if (ssi_pads_saved) {
+		/* restore the SSI pads configuration */
+		omap_ctrl_writew(ssi_rx_rdy, OMAP2_CONTROL_PADCONFS +
+				CONTROL_PADCONF_MCBSP4_DX);
+		omap_ctrl_writew(ssi_tx_dat, OMAP2_CONTROL_PADCONFS +
+				CONTROL_PADCONF_UART1_TX);
+		omap_ctrl_writew(ssi_tx_flag, OMAP2_CONTROL_PADCONFS +
+				CONTROL_PADCONF_UART1_TX + 2);
+		ssi_pads_saved = 0;
+	}
+}
+
+int pm_check_idle(void)
+{
+	if ((cm_read_mod_reg(CORE_MOD, CM_IDLEST1) & CORE_IDLEST1_ALL)
+			!= CORE_IDLEST1_ALL)
+		return 0;
+	if ((cm_read_mod_reg(CORE_MOD, CM_IDLEST2) & CORE_IDLEST2_ALL)
+			!= CORE_IDLEST2_ALL)
+		return 0;
+	if ((cm_read_mod_reg(CORE_MOD, OMAP3430_CM_IDLEST3) & CORE_IDLEST3_ALL)
+			!= CORE_IDLEST3_ALL)
+		return 0;
+	if ((cm_read_mod_reg(OMAP3430_PER_MOD, CM_IDLEST1) & PER_IDLEST_ALL)
+			!= PER_IDLEST_ALL)
+		return 0;
+	if (cm_read_mod_reg(OMAP3430ES2_SGX_MOD, CM_IDLEST1) != SGX_IDLEST_ALL)
+		return 0;
+	if (cm_read_mod_reg(OMAP3430_CAM_MOD, CM_IDLEST1) != CAM_IDLEST_ALL)
+		return 0;
+	if (cm_read_mod_reg(OMAP3430_DSS_MOD, CM_IDLEST1) != DSS_IDLEST_ALL)
+		return 0;
+	return 1;
+}
+
 static void omap3_core_save_context(void)
 {
 	u32 control_padconf_off;
+
 	/* Save the padconf registers */
 	control_padconf_off =
 	omap_ctrl_readl(OMAP343X_CONTROL_PADCONF_OFF);
 	control_padconf_off |= START_PADCONF_SAVE;
 	omap_ctrl_writel(control_padconf_off, OMAP343X_CONTROL_PADCONF_OFF);
 	/* wait for the save to complete */
-	while (!omap_ctrl_readl(OMAP343X_CONTROL_GENERAL_PURPOSE_STATUS)
-			& PADCONF_SAVE_DONE)
+	while (!(omap_ctrl_readl(OMAP343X_CONTROL_GENERAL_PURPOSE_STATUS)
+			& PADCONF_SAVE_DONE))
 		;
 	/* Save the Interrupt controller context */
 	omap3_intc_save_context();
 	/* Save the GPMC context */
 	omap3_gpmc_save_context();
+	/* The VRFB context is saved while it's being configured */
 	/* Save the system control module context, padconf already save above*/
 	omap3_control_save_context();
 	omap_dma_global_context_save();
@@ -158,6 +318,8 @@ static void omap3_core_restore_context(v
 	omap3_control_restore_context();
 	/* Restore the GPMC context */
 	omap3_gpmc_restore_context();
+	/* Restore the VRFB context */
+	omap_vrfb_restore_context();
 	/* Restore the interrupt controller context */
 	omap3_intc_restore_context();
 	omap_dma_global_context_restore();
@@ -197,7 +359,12 @@ static void omap3_save_secure_ram_contex
 static irqreturn_t prcm_interrupt_handler (int irq, void *dev_id)
 {
 	u32 wkst, irqstatus_mpu;
-	u32 fclk, iclk;
+	u32 fclk, iclk, clken_pll;
+
+	/* Ensure that DPLL4_M2X2_CLK path is powered up */
+	clken_pll = cm_read_mod_reg(OMAP3430_CCR_MOD, CM_CLKEN);
+	cm_clear_mod_reg_bits(1 << OMAP3430_PWRDN_96M_SHIFT,
+			      OMAP3430_CCR_MOD, CM_CLKEN);
 
 	/* WKUP */
 	wkst = prm_read_mod_reg(WKUP_MOD, PM_WKST);
@@ -207,7 +374,7 @@ static irqreturn_t prcm_interrupt_handle
 		cm_set_mod_reg_bits(wkst, WKUP_MOD, CM_ICLKEN);
 		cm_set_mod_reg_bits(wkst, WKUP_MOD, CM_FCLKEN);
 		prm_write_mod_reg(wkst, WKUP_MOD, PM_WKST);
-		while (prm_read_mod_reg(WKUP_MOD, PM_WKST));
+		prm_read_mod_reg(WKUP_MOD, PM_WKST);
 		cm_write_mod_reg(iclk, WKUP_MOD, CM_ICLKEN);
 		cm_write_mod_reg(fclk, WKUP_MOD, CM_FCLKEN);
 	}
@@ -220,7 +387,7 @@ static irqreturn_t prcm_interrupt_handle
 		cm_set_mod_reg_bits(wkst, CORE_MOD, CM_ICLKEN1);
 		cm_set_mod_reg_bits(wkst, CORE_MOD, CM_FCLKEN1);
 		prm_write_mod_reg(wkst, CORE_MOD, PM_WKST1);
-		while (prm_read_mod_reg(CORE_MOD, PM_WKST1));
+		prm_read_mod_reg(CORE_MOD, PM_WKST1);
 		cm_write_mod_reg(iclk, CORE_MOD, CM_ICLKEN1);
 		cm_write_mod_reg(fclk, CORE_MOD, CM_FCLKEN1);
 	}
@@ -231,7 +398,7 @@ static irqreturn_t prcm_interrupt_handle
 		cm_set_mod_reg_bits(wkst, CORE_MOD, CM_ICLKEN3);
 		cm_set_mod_reg_bits(wkst, CORE_MOD, OMAP3430ES2_CM_FCLKEN3);
 		prm_write_mod_reg(wkst, CORE_MOD, OMAP3430ES2_PM_WKST3);
-		while (prm_read_mod_reg(CORE_MOD, OMAP3430ES2_PM_WKST3));
+		prm_read_mod_reg(CORE_MOD, OMAP3430ES2_PM_WKST3);
 		cm_write_mod_reg(iclk, CORE_MOD, CM_ICLKEN3);
 		cm_write_mod_reg(fclk, CORE_MOD, OMAP3430ES2_CM_FCLKEN3);
 	}
@@ -244,7 +411,7 @@ static irqreturn_t prcm_interrupt_handle
 		cm_set_mod_reg_bits(wkst, OMAP3430_PER_MOD, CM_ICLKEN);
 		cm_set_mod_reg_bits(wkst, OMAP3430_PER_MOD, CM_FCLKEN);
 		prm_write_mod_reg(wkst, OMAP3430_PER_MOD, PM_WKST);
-		while (prm_read_mod_reg(OMAP3430_PER_MOD, PM_WKST));
+		prm_read_mod_reg(OMAP3430_PER_MOD, PM_WKST);
 		cm_write_mod_reg(iclk, OMAP3430_PER_MOD, CM_ICLKEN);
 		cm_write_mod_reg(fclk, OMAP3430_PER_MOD, CM_FCLKEN);
 	}
@@ -263,8 +430,7 @@ static irqreturn_t prcm_interrupt_handle
 					 CM_FCLKEN);
 			prm_write_mod_reg(wkst, OMAP3430ES2_USBHOST_MOD,
 					  PM_WKST);
-			while (prm_read_mod_reg(OMAP3430ES2_USBHOST_MOD,
-						PM_WKST));
+			prm_read_mod_reg(OMAP3430ES2_USBHOST_MOD, PM_WKST);
 			cm_write_mod_reg(iclk, OMAP3430ES2_USBHOST_MOD,
 					 CM_ICLKEN);
 			cm_write_mod_reg(fclk, OMAP3430ES2_USBHOST_MOD,
@@ -272,12 +438,14 @@ static irqreturn_t prcm_interrupt_handle
 		}
 	}
 
+	cm_write_mod_reg(clken_pll, OMAP3430_CCR_MOD, CM_CLKEN);
+
 	irqstatus_mpu = prm_read_mod_reg(OCP_MOD,
 					OMAP2_PRM_IRQSTATUS_MPU_OFFSET);
 	prm_write_mod_reg(irqstatus_mpu, OCP_MOD,
 					OMAP2_PRM_IRQSTATUS_MPU_OFFSET);
 
-	while (prm_read_mod_reg(OCP_MOD, OMAP2_PRM_IRQSTATUS_MPU_OFFSET));
+	prm_read_mod_reg(OCP_MOD, OMAP2_PRM_IRQSTATUS_MPU_OFFSET);
 
 	return IRQ_HANDLED;
 }
@@ -287,6 +455,21 @@ static void restore_control_register(u32
 	__asm__ __volatile__ ("mcr p15, 0, %0, c1, c0, 0" : : "r" (val));
 }
 
+void omap3_save_neon_context(void)
+{
+#ifdef CONFIG_VFP
+	vfp_pm_save_context();
+#endif
+}
+
+void omap3_restore_neon_context(void)
+{
+#ifdef CONFIG_VFP
+	vfp_enable();
+	vfp_pm_restore_context();
+#endif
+}
+
 /* Function to restore the table entry that was modified for enabling MMU */
 static void restore_table_entry(void)
 {
@@ -319,11 +502,16 @@ void omap_sram_idle(void)
 	/* save_state = 3 => L1, L2 and logic lost */
 	int save_state = 0;
 	int mpu_next_state = PWRDM_POWER_ON;
+	int neon_next_state = PWRDM_POWER_ON;
 	int per_next_state = PWRDM_POWER_ON;
 	int core_next_state = PWRDM_POWER_ON;
+	int dss_state = PWRDM_POWER_ON;
+	int iva2_state = PWRDM_POWER_ON;
+	int usb_state = PWRDM_POWER_ON;
 	int core_prev_state, per_prev_state;
 	u32 sdrc_pwr = 0;
 	int per_state_modified = 0;
+	int core_saved_state = PWRDM_POWER_ON;
 
 	if (!_omap_sram_idle)
 		return;
@@ -352,12 +540,56 @@ void omap_sram_idle(void)
 	pwrdm_pre_transition();
 
 	/* NEON control */
-	if (pwrdm_read_pwrst(neon_pwrdm) == PWRDM_POWER_ON)
+	if (pwrdm_read_pwrst(neon_pwrdm) == PWRDM_POWER_ON) {
 		pwrdm_set_next_pwrst(neon_pwrdm, mpu_next_state);
+		neon_next_state = mpu_next_state;
+		if (neon_next_state == PWRDM_POWER_OFF)
+			omap3_save_neon_context();
+	}
 
-	/* PER */
-	per_next_state = pwrdm_read_next_pwrst(per_pwrdm);
+	/* Get powerdomain state data */
 	core_next_state = pwrdm_read_next_pwrst(core_pwrdm);
+	dss_state = pwrdm_read_pwrst(dss_pwrdm);
+	iva2_state = pwrdm_read_pwrst(iva2_pwrdm);
+	usb_state = pwrdm_read_pwrst(usb_pwrdm);
+	per_next_state = pwrdm_read_next_pwrst(per_pwrdm);
+
+	/* Check if PER domain can enter OFF or not */
+	if (per_next_state == PWRDM_POWER_OFF) {
+		if ((cm_read_mod_reg(OMAP3430_PER_MOD, CM_IDLEST) &
+				PER_IDLEST_ALL) != PER_IDLEST_ALL) {
+			per_next_state = PWRDM_POWER_RET;
+			pwrdm_set_next_pwrst(per_pwrdm, per_next_state);
+			per_state_modified = 1;
+		}
+	}
+	/*
+	 * Check whether core will enter idle or not. This is needed
+	 * because I/O pad wakeup will fail if core stays on and PER
+	 * enters off. This will also prevent unnecessary core context
+	 * save / restore.
+	 */
+	if (core_next_state < PWRDM_POWER_ON) {
+		core_saved_state = core_next_state;
+		if ((cm_read_mod_reg(CORE_MOD, CM_IDLEST1) & CORE_IDLEST1_ALL)
+				!= CORE_IDLEST1_ALL ||
+		    (cm_read_mod_reg(CORE_MOD, CM_IDLEST2) & CORE_IDLEST2_ALL)
+				!= CORE_IDLEST2_ALL ||
+		    (cm_read_mod_reg(CORE_MOD, OMAP3430_CM_IDLEST3) &
+				CORE_IDLEST3_ALL) != CORE_IDLEST3_ALL) {
+			core_next_state = PWRDM_POWER_ON;
+			pwrdm_set_next_pwrst(core_pwrdm, PWRDM_POWER_ON);
+		} else if (core_next_state == PWRDM_POWER_OFF &&
+				 (dss_state == PWRDM_POWER_ON ||
+				  iva2_state >= PWRDM_POWER_RET ||
+				  usb_state >= PWRDM_POWER_RET ||
+				  per_next_state >= PWRDM_POWER_RET)) {
+			core_next_state = PWRDM_POWER_RET;
+			pwrdm_set_next_pwrst(core_pwrdm, PWRDM_POWER_RET);
+		}
+	}
+
+	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
 		omap_uart_prepare_idle(2);
 		omap2_gpio_prepare_for_idle(per_next_state);
@@ -374,17 +606,24 @@ void omap_sram_idle(void)
 	if (pwrdm_read_pwrst(cam_pwrdm) == PWRDM_POWER_ON)
 		omap2_clkdm_deny_idle(mpu_pwrdm->pwrdm_clkdms[0]);
 
-	/* CORE */
-	if (core_next_state < PWRDM_POWER_ON) {
-		/* Disable smartreflex before entering WFI */
+	/*
+	 * Disable smartreflex before entering WFI.
+	 * Only needed if we are going to enter retention.
+	 */
+	if (mpu_next_state < PWRDM_POWER_ON)
 		disable_smartreflex(SR1);
+	if (core_next_state < PWRDM_POWER_ON)
 		disable_smartreflex(SR2);
+
+	/* CORE */
+	if (core_next_state < PWRDM_POWER_ON) {
 		omap_uart_prepare_idle(0);
 		omap_uart_prepare_idle(1);
 		if (core_next_state == PWRDM_POWER_OFF) {
 			prm_set_mod_reg_bits(OMAP3430_AUTO_OFF,
 					     OMAP3430_GR_MOD,
 					     OMAP3_PRM_VOLTCTRL_OFFSET);
+			ssi_padconf_save_mode();
 			omap3_core_save_context();
 			omap3_prcm_save_context();
 		}
@@ -408,6 +647,30 @@ void omap_sram_idle(void)
 			SDRC_SELF_REFRESH_ON_AUTOCOUNT, SDRC_POWER);
 	}
 
+	/* Write voltage setup times which are changed dynamically */
+	if (core_next_state == PWRDM_POWER_OFF) {
+		prm_write_mod_reg(0, OMAP3430_GR_MOD,
+				OMAP3_PRM_VOLTSETUP1_OFFSET);
+		prm_write_mod_reg(prm_setup.voltsetup2, OMAP3430_GR_MOD,
+				  OMAP3_PRM_VOLTSETUP2_OFFSET);
+		prm_write_mod_reg(prm_setup.clksetup, OMAP3430_GR_MOD,
+				  OMAP3_PRM_CLKSETUP_OFFSET);
+	} else {
+		prm_write_mod_reg((prm_setup.voltsetup_time2 <<
+				   OMAP3430_SETUP_TIME2_SHIFT) |
+				  (prm_setup.voltsetup_time1 <<
+				   OMAP3430_SETUP_TIME1_SHIFT),
+				  OMAP3430_GR_MOD, OMAP3_PRM_VOLTSETUP1_OFFSET);
+		prm_write_mod_reg(0, OMAP3430_GR_MOD,
+				  OMAP3_PRM_VOLTSETUP2_OFFSET);
+		/*
+		 * Use static 1 as only HF_CLKOUT is turned off.
+		 * Value taken from application note SWPA152
+		 */
+		prm_write_mod_reg(0x1, OMAP3430_GR_MOD,
+				  OMAP3_PRM_CLKSETUP_OFFSET);
+	}
+
 	/*
 	 * omap3_arm_context is the location where ARM registers
 	 * get saved. The restore path then reads from this
@@ -425,6 +688,8 @@ void omap_sram_idle(void)
 	if (pwrdm_read_prev_pwrst(mpu_pwrdm) == PWRDM_POWER_OFF)
 		restore_table_entry();
 
+	if (neon_next_state == PWRDM_POWER_OFF)
+		omap3_restore_neon_context();
 
 	/* CORE */
 	if (core_next_state < PWRDM_POWER_ON) {
@@ -433,17 +698,30 @@ void omap_sram_idle(void)
 			omap3_core_restore_context();
 			omap3_prcm_restore_context();
 			omap3_sram_restore_context();
+			omap2_sms_restore_context();
+			reset_ssi();
 		}
 		omap_uart_resume_idle(0);
 		omap_uart_resume_idle(1);
-		if (core_next_state == PWRDM_POWER_OFF)
+		if (core_next_state == PWRDM_POWER_OFF) {
 			prm_clear_mod_reg_bits(OMAP3430_AUTO_OFF,
 					       OMAP3430_GR_MOD,
 					       OMAP3_PRM_VOLTCTRL_OFFSET);
-		/* Enable smartreflex after WFI */
+			restore_ssi_padconf();
+		}
+	}
+
+	/*
+	 * Enable smartreflex after WFI. Only needed if we
+	 * entered retention.
+	 */
+	if (mpu_next_state < PWRDM_POWER_ON)
 		enable_smartreflex(SR1);
+	if (core_next_state < PWRDM_POWER_ON)
 		enable_smartreflex(SR2);
-	}
+
+	if (core_saved_state != core_next_state)
+		pwrdm_set_next_pwrst(core_pwrdm, core_saved_state);
 
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
@@ -563,6 +841,12 @@ static int omap3_pm_suspend(void)
 		pwrst->saved_state = pwrdm_read_next_pwrst(pwrst->pwrdm);
 	/* Set ones wanted by suspend */
 	list_for_each_entry(pwrst, &pwrst_list, node) {
+		/* Special handling for IVA2, just use current sleep state */
+		if (pwrst->pwrdm == iva2_pwrdm) {
+			state = pwrdm_read_pwrst(pwrst->pwrdm);
+			if (state < PWRDM_POWER_ON)
+				pwrst->next_state = state;
+		}
 		if (set_pwrdm_state(pwrst->pwrdm, pwrst->next_state))
 			goto restore;
 		if (pwrdm_clear_all_prev_pwrst(pwrst->pwrdm))
@@ -570,6 +854,8 @@ static int omap3_pm_suspend(void)
 	}
 
 	omap_uart_prepare_suspend();
+	/* ACK pending interrupts */
+	omap_writel(1, OMAP34XX_IC_BASE + INTC_CONTROL);
 	omap_sram_idle();
 
 restore:
@@ -682,6 +968,8 @@ static void __init omap3_iva_idle(void)
 
 static void __init prcm_setup_regs(void)
 {
+	struct clk *clk;
+
 	/* reset modem */
 	prm_write_mod_reg(OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RSTPWRON |
 			  OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RST,
@@ -697,6 +985,23 @@ static void __init prcm_setup_regs(void)
 	prm_write_mod_reg(0, OMAP3430_CAM_MOD, PM_WKDEP);
 	prm_write_mod_reg(0, OMAP3430_PER_MOD, PM_WKDEP);
 	if (omap_rev() > OMAP3430_REV_ES1_0) {
+
+		/*
+		 * This workaround is needed to prevent SGX and USBHOST from
+		 * failing to transition to RET/OFF after a warm reset in OFF
+		 * mode. Workaround sets a sleepdep of each of these domains
+		 * with MPU, waits for a min 2 sysclk cycles and clears the sleepdep.
+		 */
+		cm_write_mod_reg(OMAP3430_CM_SLEEPDEP_PER_EN_MPU,
+				OMAP3430ES2_USBHOST_MOD, OMAP3430_CM_SLEEPDEP);
+		cm_write_mod_reg(OMAP3430_CM_SLEEPDEP_PER_EN_MPU,
+				OMAP3430ES2_SGX_MOD, OMAP3430_CM_SLEEPDEP);
+		udelay(100);
+		cm_write_mod_reg(0, OMAP3430ES2_USBHOST_MOD,
+				OMAP3430_CM_SLEEPDEP);
+		cm_write_mod_reg(0, OMAP3430ES2_SGX_MOD,
+				OMAP3430_CM_SLEEPDEP);
+
 		prm_write_mod_reg(0, OMAP3430ES2_SGX_MOD, PM_WKDEP);
 		prm_write_mod_reg(0, OMAP3430ES2_USBHOST_MOD, PM_WKDEP);
 	} else
@@ -802,6 +1107,8 @@ static void __init prcm_setup_regs(void)
 			CM_AUTOIDLE);
 	}
 
+	omap_ctrl_writel(OMAP3430_AUTOIDLE, OMAP2_CONTROL_SYSCONFIG);
+
 	/*
 	 * Set all plls to autoidle. This is needed until autoidle is
 	 * enabled by clockfw
@@ -830,9 +1137,8 @@ static void __init prcm_setup_regs(void)
 			     OMAP3_PRM_CLKSRC_CTRL_OFFSET);
 
 	/* setup wakup source */
-	prm_write_mod_reg(OMAP3430_EN_IO | OMAP3430_EN_GPIO1 |
-			  OMAP3430_EN_GPT1 | OMAP3430_EN_GPT12,
-			  WKUP_MOD, PM_WKEN);
+	prm_write_mod_reg(OMAP3430_EN_GPIO1 | OMAP3430_EN_GPT1 |
+			  OMAP3430_EN_GPT12, WKUP_MOD, PM_WKEN);
 	/* No need to write EN_IO, that is always enabled */
 	prm_write_mod_reg(OMAP3430_EN_GPIO1 | OMAP3430_EN_GPT1 |
 			  OMAP3430_EN_GPT12,
@@ -843,6 +1149,13 @@ static void __init prcm_setup_regs(void)
 			OCP_MOD, OMAP2_PRM_IRQENABLE_MPU_OFFSET);
 
 	omap3_iva_idle();
+
+	/*
+	 * Permanently enable USB interface clock, needed for the
+	 * OTG_SYSCONFIG save / restore hack
+	 */
+	clk = clk_get(NULL, "hsotgusb_ick");
+	clk_enable(clk);
 }
 
 void omap3_pm_off_mode_enable(int enable)
@@ -984,6 +1297,9 @@ int __init omap3_pm_init(void)
 	per_pwrdm = pwrdm_lookup("per_pwrdm");
 	core_pwrdm = pwrdm_lookup("core_pwrdm");
 	cam_pwrdm = pwrdm_lookup("cam_pwrdm");
+	iva2_pwrdm = pwrdm_lookup("iva2_pwrdm");
+	dss_pwrdm = pwrdm_lookup("dss_pwrdm");
+	usb_pwrdm = pwrdm_lookup("usbhost_pwrdm");
 
 	omap_push_sram_idle();
 
@@ -1012,6 +1328,8 @@ int __init omap3_pm_init(void)
 	}
 	omap3_save_scratchpad_contents();
 
+	save_ssi_padconf();
+
 	if (omap_type() != OMAP2_DEVICE_TYPE_GP) {
 		local_irq_disable();
 		local_fiq_disable();
@@ -1083,19 +1401,9 @@ static void __init configure_vc(void)
 	prm_write_mod_reg(OMAP3430_AUTO_RET,
 			  OMAP3430_GR_MOD, OMAP3_PRM_VOLTCTRL_OFFSET);
 
-	/* Write setup times */
-	prm_write_mod_reg(prm_setup.clksetup, OMAP3430_GR_MOD,
-			OMAP3_PRM_CLKSETUP_OFFSET);
-	prm_write_mod_reg((prm_setup.voltsetup_time2 <<
-			OMAP3430_SETUP_TIME2_SHIFT) |
-			(prm_setup.voltsetup_time1 <<
-			OMAP3430_SETUP_TIME1_SHIFT),
-			OMAP3430_GR_MOD, OMAP3_PRM_VOLTSETUP1_OFFSET);
-
+	/* Write static setup times */
 	prm_write_mod_reg(prm_setup.voltoffset, OMAP3430_GR_MOD,
 			OMAP3_PRM_VOLTOFFSET_OFFSET);
-	prm_write_mod_reg(prm_setup.voltsetup2, OMAP3430_GR_MOD,
-			OMAP3_PRM_VOLTSETUP2_OFFSET);
 }
 
 static int __init omap3_pm_early_init(void)
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/powerdomains34xx.h kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/powerdomains34xx.h
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/powerdomains34xx.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/powerdomains34xx.h	2012-12-16 13:13:01.524330148 +0100
@@ -338,7 +338,13 @@ static struct powerdomain usbhost_pwrdm
 	.sleepdep_srcs	  = dss_per_usbhost_sleepdeps,
 	.pwrsts		  = PWRSTS_OFF_RET_ON,
 	.pwrsts_logic_ret = PWRDM_POWER_RET,
-	.flags		  = PWRDM_HAS_HDWR_SAR, /* for USBHOST ctrlr only */
+	/*
+	 * REVISIT: Enabling usb host save and restore mechanism seems to
+	 * leave the usb host domain permanently in ACTIVE mode after
+	 * changing the usb host power domain state from OFF to active once.
+	 * Disabling for now.
+	 */
+	/*.flags	  = PWRDM_HAS_HDWR_SAR,*/ /* for USBHOST ctrlr only */
 	.banks		  = 1,
 	.pwrsts_mem_ret	  = {
 		[0] = PWRDM_POWER_RET, /* MEMRETSTATE */
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/prcm.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/prcm.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/prcm.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/prcm.c	2012-12-16 13:13:01.524330148 +0100
@@ -31,6 +31,8 @@
 #include "prm.h"
 #include "prm-regbits-24xx.h"
 
+#define OTG_SYSCONFIG (OMAP34XX_HSUSB_OTG_BASE + 0x404)
+
 static void __iomem *prm_base;
 static void __iomem *cm_base;
 
@@ -53,6 +55,7 @@ struct omap3_prcm_regs {
 	u32 pll_cm_clken2;
 	u32 cm_polctrl;
 	u32 iva2_cm_fclken;
+	u32 iva2_cm_clken_pll;
 	u32 core_cm_fclken1;
 	u32 core_cm_fclken3;
 	u32 sgx_cm_fclken;
@@ -112,6 +115,7 @@ struct omap3_prcm_regs {
 	u32 per_pm_mpugrpsel;
 	u32 per_pm_ivagrpsel;
 	u32 wkup_pm_wken;
+	u32 otg_sysconfig;
 };
 
 struct omap3_prcm_regs prcm_context;
@@ -268,6 +272,8 @@ void omap3_prcm_save_context(void)
 	prcm_context.cm_polctrl = __raw_readl(OMAP3430_CM_POLCTRL);
 	prcm_context.iva2_cm_fclken =
 			 cm_read_mod_reg(OMAP3430_IVA2_MOD, CM_FCLKEN);
+	prcm_context.iva2_cm_clken_pll = cm_read_mod_reg(OMAP3430_IVA2_MOD,
+			OMAP3430_CM_CLKEN_PLL);
 	prcm_context.core_cm_fclken1 =
 			 cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
 	prcm_context.core_cm_fclken3 =
@@ -385,6 +391,11 @@ void omap3_prcm_save_context(void)
 	prcm_context.per_pm_ivagrpsel =
 		 prm_read_mod_reg(OMAP3430_PER_MOD, OMAP3430_PM_IVAGRPSEL);
 	prcm_context.wkup_pm_wken = prm_read_mod_reg(WKUP_MOD, PM_WKEN);
+	/*
+	 * OTG_SYSCONFIG must be saved & restored because enabled AUTOIDLE
+	 * bit will eventually block sleep due to OMAP bug
+	 */
+	prcm_context.otg_sysconfig = omap_readl(OTG_SYSCONFIG);
 	return;
 }
 
@@ -422,6 +433,8 @@ void omap3_prcm_restore_context(void)
 	__raw_writel(prcm_context.cm_polctrl, OMAP3430_CM_POLCTRL);
 	cm_write_mod_reg(prcm_context.iva2_cm_fclken, OMAP3430_IVA2_MOD,
 					 CM_FCLKEN);
+	cm_write_mod_reg(prcm_context.iva2_cm_clken_pll, OMAP3430_IVA2_MOD,
+					OMAP3430_CM_CLKEN_PLL);
 	cm_write_mod_reg(prcm_context.core_cm_fclken1, CORE_MOD, CM_FCLKEN1);
 	cm_write_mod_reg(prcm_context.core_cm_fclken3, CORE_MOD,
 					 OMAP3430ES2_CM_FCLKEN3);
@@ -529,6 +542,7 @@ void omap3_prcm_restore_context(void)
 	prm_write_mod_reg(prcm_context.per_pm_ivagrpsel, OMAP3430_PER_MOD,
 					 OMAP3430_PM_IVAGRPSEL);
 	prm_write_mod_reg(prcm_context.wkup_pm_wken, WKUP_MOD, PM_WKEN);
+	omap_writel(prcm_context.otg_sysconfig, OTG_SYSCONFIG);
 	return;
 }
 #endif
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/resource34xx.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/resource34xx.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/resource34xx.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/resource34xx.c	2012-12-16 13:13:01.524330148 +0100
@@ -147,7 +147,8 @@ static int vdd2_lock;
 static struct clk *dpll1_clk, *dpll2_clk, *dpll3_clk;
 static int curr_vdd1_opp;
 static int curr_vdd2_opp;
-static DEFINE_MUTEX(dvfs_mutex);
+
+DEFINE_MUTEX(dvfs_mutex);
 
 static unsigned short get_opp(struct omap_opp *opp_freq_table,
 		unsigned long freq)
@@ -264,27 +265,38 @@ static int program_opp_freq(int res, int
 static int program_opp(int res, struct omap_opp *opp, int target_level,
 		int current_level)
 {
-	int i, ret = 0, raise;
+	int i, ret = 0, raise, sr_status;
 #ifdef CONFIG_OMAP_SMARTREFLEX
-	unsigned long t_opp;
+	unsigned long t_opp, c_opp;
 
 	t_opp = ID_VDD(res) | ID_OPP_NO(opp[target_level].opp_id);
+	c_opp = ID_VDD(res) | ID_OPP_NO(opp[current_level].opp_id);
 #endif
 	if (target_level > current_level)
 		raise = 1;
 	else
 		raise = 0;
 
+#ifdef CONFIG_OMAP_SMARTREFLEX
+	sr_status = sr_stop_vddautocomap((get_vdd(t_opp) == PRCM_VDD1) ?
+			SR1 : SR2);
+#endif
 	for (i = 0; i < 2; i++) {
 		if (i == raise)
 			ret = program_opp_freq(res, target_level,
 					current_level);
 #ifdef CONFIG_OMAP_SMARTREFLEX
 		else
-			sr_voltagescale_vcbypass(t_opp,
-					opp[target_level].vsel);
+			sr_voltagescale_vcbypass(t_opp, c_opp,
+				opp[target_level].vsel,
+				opp[current_level].vsel);
 #endif
 	}
+#ifdef CONFIG_OMAP_SMARTREFLEX
+	if (sr_status)
+		sr_start_vddautocomap((get_vdd(t_opp) == PRCM_VDD1) ? SR1 : SR2,
+				opp[target_level].opp_id);
+#endif
 
 	return ret;
 }
@@ -354,6 +366,9 @@ int set_opp(struct shared_resource *resp
 	int ind;
 
 	if (resp == vdd1_resp) {
+		if (target_level < 3)
+			resource_release_locked("vdd2_opp", &vdd2_dev);
+
 		resource_set_opp_level(PRCM_VDD1, target_level, 0);
 		/*
 		 * For VDD1 OPP3 and above, make sure the interconnect
@@ -361,9 +376,7 @@ int set_opp(struct shared_resource *resp
 		 * throughput in KiB/s for 100 Mhz = 100 * 1000 * 4.
 		 */
 		if (target_level >= 3)
-			resource_request("vdd2_opp", &vdd2_dev, 400000);
-		else
-			resource_release("vdd2_opp", &vdd2_dev);
+			resource_request_locked("vdd2_opp", &vdd2_dev, 400000);
 	} else if (resp == vdd2_resp) {
 		tput = target_level;
 
@@ -428,10 +441,10 @@ int set_freq(struct shared_resource *res
 
 	if (strcmp(resp->name, "mpu_freq") == 0) {
 		vdd1_opp = get_opp(mpu_opps + MAX_VDD1_OPP, target_level);
-		resource_request("vdd1_opp", &dummy_mpu_dev, vdd1_opp);
+		resource_request_locked("vdd1_opp", &dummy_mpu_dev, vdd1_opp);
 	} else if (strcmp(resp->name, "dsp_freq") == 0) {
 		vdd1_opp = get_opp(dsp_opps + MAX_VDD1_OPP, target_level);
-		resource_request("vdd1_opp", &dummy_dsp_dev, vdd1_opp);
+		resource_request_locked("vdd1_opp", &dummy_dsp_dev, vdd1_opp);
 	}
 	resp->curr_level = target_level;
 	return 0;
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/resource34xx.h kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/resource34xx.h
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/resource34xx.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/resource34xx.h	2012-12-16 13:13:01.524330148 +0100
@@ -26,8 +26,9 @@
 #include <mach/clock.h>
 #include <mach/powerdomain.h>
 #include <mach/omap-pm.h>
+#include "resource34xx_mutex.h"
 
-extern int sr_voltagescale_vcbypass(u32 target_opp, u8 vsel);
+extern int sr_voltagescale_vcbypass(u32 t_opp, u32 c_opp, u8 t_vsel, u8 c_vsel);
 
 /*
  * mpu_latency/core_latency are used to control the cpuidle C state.
@@ -92,6 +93,7 @@ static struct shared_resource core_pwrdm
 	.ops		= &lat_res_ops,
 };
 
+#if !defined(CONFIG_MPU_BRIDGE) && !defined(CONFIG_MPU_BRIDGE_MODULE)
 static struct pd_latency_db iva2_pwrdm_lat_db = {
 	.pwrdm_name = "iva2_pwrdm",
 	.latency[PD_LATENCY_OFF] = 1100,
@@ -106,6 +108,7 @@ static struct shared_resource iva2_pwrdm
 	.resource_data	= &iva2_pwrdm_lat_db,
 	.ops		= &pd_lat_res_ops,
 };
+#endif
 
 static struct pd_latency_db gfx_pwrdm_lat_db = {
 	.pwrdm_name = "gfx_pwrdm",
@@ -132,7 +135,7 @@ static struct shared_resource gfx_pwrdm_
 
 static struct shared_resource sgx_pwrdm_latency = {
 	.name 		= "sgx_pwrdm_latency",
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430ES2),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES2),
 	.resource_data  = &sgx_pwrdm_lat_db,
 	.ops		= &pd_lat_res_ops,
 };
@@ -207,7 +210,7 @@ static struct pd_latency_db usbhost_pwrd
 
 static struct shared_resource usbhost_pwrdm_latency = {
 	.name		= "usbhost_pwrdm_latency",
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP3430ES2),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES2),
 	.resource_data  = &usbhost_pwrdm_lat_db,
 	.ops		= &pd_lat_res_ops,
 };
@@ -279,7 +282,9 @@ struct shared_resource *resources_omap[]
 	&core_latency,
 	/* Power Domain Latency resources */
 	&core_pwrdm_latency,
+#if !defined(CONFIG_MPU_BRIDGE) && !defined(CONFIG_MPU_BRIDGE_MODULE)
 	&iva2_pwrdm_latency,
+#endif
 	&gfx_pwrdm_latency,
 	&sgx_pwrdm_latency,
 	&dss_pwrdm_latency,
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/resource34xx_mutex.h kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/resource34xx_mutex.h
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/resource34xx_mutex.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/resource34xx_mutex.h	2012-12-16 13:13:01.524330148 +0100
@@ -0,0 +1,9 @@
+#ifndef __ARCH_ARM_MACH_OMAP2_RESOURCE_MUTEX_H
+#define __ARCH_ARM_MACH_OMAP2_RESOURCE_MUTEX_H
+
+extern struct mutex dvfs_mutex;
+
+#endif
+
+
+
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/sdrc.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/sdrc.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/sdrc.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/sdrc.c	2012-12-16 13:13:01.524330148 +0100
@@ -32,43 +32,88 @@
 #include <mach/sdrc.h>
 #include "sdrc.h"
 
-static struct omap_sdrc_params *sdrc_init_params;
+static struct omap_sdrc_params *sdrc_init_params_cs0, *sdrc_init_params_cs1;
 
 void __iomem *omap2_sdrc_base;
 void __iomem *omap2_sms_base;
 
+struct omap2_sms_regs {
+	u32	sms_sysconfig;
+};
+
+static struct omap2_sms_regs sms_context;
+
 /* SDRC_POWER register bits */
 #define SDRC_POWER_EXTCLKDIS_SHIFT		3
 #define SDRC_POWER_PWDENA_SHIFT			2
 #define SDRC_POWER_PAGEPOLICY_SHIFT		0
 
 /**
+ * omap2_sms_save_context - Save SMS registers
+ *
+ * Save SMS registers that need to be restored after off mode.
+ */
+void omap2_sms_save_context(void)
+{
+	sms_context.sms_sysconfig = sms_read_reg(SMS_SYSCONFIG);
+}
+
+/**
+ * omap2_sms_restore_context - Restore SMS registers
+ *
+ * Restore SMS registers that need to be Restored after off mode.
+ */
+void omap2_sms_restore_context(void)
+{
+	sms_write_reg(sms_context.sms_sysconfig, SMS_SYSCONFIG);
+}
+
+/**
  * omap2_sdrc_get_params - return SDRC register values for a given clock rate
  * @r: SDRC clock rate (in Hz)
+ * @sdrc_cs0: chip select 0 ram timings **
+ * @sdrc_cs1: chip select 1 ram timings **
  *
  * Return pre-calculated values for the SDRC_ACTIM_CTRLA,
- * SDRC_ACTIM_CTRLB, SDRC_RFR_CTRL, and SDRC_MR registers, for a given
- * SDRC clock rate 'r'.  These parameters control various timing
- * delays in the SDRAM controller that are expressed in terms of the
- * number of SDRC clock cycles to wait; hence the clock rate
- * dependency. Note that sdrc_init_params must be sorted rate
- * descending.  Also assumes that both chip-selects use the same
- * timing parameters.  Returns a struct omap_sdrc_params * upon
- * success, or NULL upon failure.
+ *  SDRC_ACTIM_CTRLB, SDRC_RFR_CTRL, and SDRC_MR registers in sdrc_cs[01]
+ *  structs, for a given SDRC clock rate 'r'.
+ * These parameters control various timing delays in the SDRAM controller
+ *  that are expressed in terms of the number of SDRC clock cycles to
+ *  wait; hence the clock rate dependency.
+ *
+ * Supports 2 different timing parameters for both chip selects.
+ *
+ * Note 1: the sdrc_init_params_cs[01] must be sorted rate descending.
+ * Note 2: If sdrc_init_params_cs_1 is not NULL it must be of same size
+ *  as sdrc_init_params_cs_0.
+ *
+ * Fills in the struct omap_sdrc_params * for each chip select.
+ * Returns 0 upon success or -1 upon failure.
  */
-struct omap_sdrc_params *omap2_sdrc_get_params(unsigned long r)
+int omap2_sdrc_get_params(unsigned long r,
+			struct omap_sdrc_params **sdrc_cs0,
+			struct omap_sdrc_params **sdrc_cs1)
 {
-	struct omap_sdrc_params *sp;
-
-	sp = sdrc_init_params;
+	struct omap_sdrc_params *sp0, *sp1;
 
-	while (sp->rate && sp->rate != r)
-		sp++;
+	if (!sdrc_init_params_cs0)
+		return -1;
 
-	if (!sp->rate)
-		return NULL;
+	sp0 = sdrc_init_params_cs0;
+	sp1 = sdrc_init_params_cs1;
 
-	return sp;
+	while (sp0->rate && sp0->rate != r) {
+		sp0++;
+		if (sdrc_init_params_cs1)
+			sp1++;
+	}
+
+	if (!sp0->rate)
+		return -1;
+
+	*sdrc_cs0 = sp0;
+	*sdrc_cs1 = sp1;
+	return 0;
 }
 
 
@@ -80,13 +125,15 @@ void __init omap2_set_globals_sdrc(struc
 
 /**
  * omap2_sdrc_init - initialize SMS, SDRC devices on boot
- * @sp: pointer to a null-terminated list of struct omap_sdrc_params
+ * @sdrc_cs[01]: pointers to a null-terminated list of struct omap_sdrc_params
+ *  Support for 2 chip selects timings
  *
  * Turn on smart idle modes for SDRAM scheduler and controller.
- * Program a known-good configuration for the SDRC to deal with buggy
- * bootloaders.
+ * Bootloaders should make proper configuration for SDRC since kernel
+ * is running from SDRAM.
  */
-void __init omap2_sdrc_init(struct omap_sdrc_params *sp)
+void __init omap2_sdrc_init(struct omap_sdrc_params *sdrc_cs0,
+			struct omap_sdrc_params *sdrc_cs1)
 {
 	u32 l;
 
@@ -100,11 +147,8 @@ void __init omap2_sdrc_init(struct omap_
 	l |= (0x2 << 3);
 	sdrc_write_reg(l, SDRC_SYSCONFIG);
 
-	sdrc_init_params = sp;
+	sdrc_init_params_cs0 = sdrc_cs0;
+	sdrc_init_params_cs1 = sdrc_cs1;
 
-	/* XXX Enable SRFRONIDLEREQ here also? */
-	l = (1 << SDRC_POWER_EXTCLKDIS_SHIFT) |
-		(1 << SDRC_POWER_PWDENA_SHIFT) |
-		(1 << SDRC_POWER_PAGEPOLICY_SHIFT);
-	sdrc_write_reg(l, SDRC_POWER);
+	omap2_sms_save_context();
 }
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/serial.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/serial.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/serial.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/serial.c	2012-12-16 13:13:01.524330148 +0100
@@ -243,7 +243,8 @@ static void omap_uart_allow_sleep(struct
 	if (!uart->clocked)
 		return;
 
-	omap_uart_smart_idle_enable(uart, 1);
+	if (serial_read_reg(uart->p, UART_LSR) & UART_LSR_TEMT)
+		omap_uart_smart_idle_enable(uart, 1);
 	uart->can_sleep = 1;
 	del_timer(&uart->timer);
 }
@@ -264,7 +265,11 @@ void omap_uart_prepare_idle(int num)
 			continue;
 
 		if (num == uart->num && uart->can_sleep) {
-			omap_uart_disable_clocks(uart);
+			if (serial_read_reg(uart->p, UART_LSR) &
+					UART_LSR_TEMT)
+				omap_uart_disable_clocks(uart);
+			else
+				omap_uart_smart_idle_enable(uart, 0);
 			return;
 		}
 	}
@@ -337,8 +342,14 @@ int omap_uart_can_sleep(void)
 static irqreturn_t omap_uart_interrupt(int irq, void *dev_id)
 {
 	struct omap_uart_state *uart = dev_id;
+	u8 lsr;
 
-	omap_uart_block_sleep(uart);
+	lsr = serial_read_reg(uart->p, UART_LSR);
+	/* Check for receive interrupt */
+	if (lsr & UART_LSR_DR)
+		omap_uart_block_sleep(uart);
+	if (lsr & UART_LSR_TEMT && uart->can_sleep)
+		omap_uart_smart_idle_enable(uart, 1);
 
 	return IRQ_NONE;
 }
@@ -465,8 +476,11 @@ static ssize_t sleep_timeout_store(struc
 		return -EINVAL;
 	}
 	sleep_timeout = value * HZ;
-	list_for_each_entry(uart, &uart_list, node)
+	list_for_each_entry(uart, &uart_list, node) {
 		uart->timeout = sleep_timeout;
+		if (timer_pending(&uart->timer))
+			mod_timer(&uart->timer, jiffies + sleep_timeout);
+	}
 	return n;
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/sleep34xx.S kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/sleep34xx.S
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/sleep34xx.S	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/sleep34xx.S	2012-12-16 13:13:01.524330148 +0100
@@ -26,6 +26,7 @@
  */
 #include <linux/linkage.h>
 #include <asm/assembler.h>
+#include <asm/memory.h>
 #include <mach/io.h>
 #include <mach/pm.h>
 #include <mach/control.h>
@@ -250,7 +251,11 @@ restore:
 	mov	r1, #0		@ set task id for ROM code in r1
 	mov	r2, #4		@ set some flags in r2, r6
 	mov	r6, #0xff
-	adr	r3, write_aux_control_params	@ r3 points to parameters
+	ldr	r3, write_aux_control_params	@ r3 points to parameters
+	ldr	r4, phys_offset
+	adds	r3, r3, r4
+	ldr	r4, page_offset
+	subs	r3, r3, r4
 	mcr	p15, 0, r0, c7, c10, 4	@ data write barrier
 	mcr	p15, 0, r0, c7, c10, 5	@ data memory barrier
 	.word	0xE1600071		@ call SMI monitor (smi #1)
@@ -259,13 +264,18 @@ restore:
 l2_inv_api_params:
 	.word   0x1, 0x00
 write_aux_control_params:
-	.word   0x1, 0x72
+	.word	omap3_aux_ctrl
 l2_inv_gp:
 	/* Execute smi to invalidate L2 cache */
 	mov r12, #0x1                         @ set up to invalide L2
 smi:    .word 0xE1600070		@ Call SMI monitor (smieq)
 	/* Write to Aux control register to set some bits */
-	mov	r0, #0x72
+	ldr	r1, write_aux_control_params
+	ldr	r0, phys_offset
+	adds	r1, r1, r0
+	ldr	r0, page_offset
+	subs	r1, r1, r0
+	ldr	r0, [r1, #4]
 	mov	r12, #0x3
 	.word 0xE1600070	@ Call SMI monitor (smieq)
 logic_l1_restore:
@@ -444,6 +454,9 @@ usettbr0:
 save_context_wfi:
 	/*b	save_context_wfi*/	@ enable to debug save code
 	mov	r8, r0 /* Store SDRAM address in r8 */
+	mrc	p15, 0, r4, c1, c0, 1	@ Read Auxiliary Control Register
+	ldr	r5, write_aux_control_params
+	str	r4, [r5, #4]
         /* Check what that target sleep state is:stored in r1*/
         /* 1 - Only L1 and logic lost */
         /* 2 - Only L2 lost */
@@ -684,6 +697,10 @@ wait_dll_lock:
         bne     wait_dll_lock
         bx      lr
 
+phys_offset:
+	.word	PHYS_OFFSET
+page_offset:
+	.word	PAGE_OFFSET
 cm_idlest1_core:
 	.word	CM_IDLEST1_CORE_V
 sdrc_dlla_status:
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/smartreflex.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/smartreflex.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/smartreflex.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/smartreflex.c	2012-12-16 13:13:01.528330149 +0100
@@ -26,6 +26,7 @@
 #include <linux/kobject.h>
 #include <linux/i2c/twl4030.h>
 #include <linux/io.h>
+#include "resource34xx_mutex.h"
 
 #include <mach/omap34xx.h>
 #include <mach/control.h>
@@ -37,6 +38,41 @@
 #include "smartreflex.h"
 #include "prm-regbits-34xx.h"
 
+/*
+ * VP_TRANXDONE_TIMEOUT: maximum microseconds to wait for the VP to
+ * indicate that any pending transactions are complete.  [The current
+ * 62 microsecond timeout was measured empirically by Nishanth Menon
+ * during an overnight run; its granularity is ~ 30.5 microseconds, since
+ * it was measured with the 32KiHz sync timer; see bug 133793]
+ */
+#define VP_TRANXDONE_TIMEOUT	62
+
+/*
+ * VP_IDLE_TIMEOUT: maximum microseconds to wait for the VP to enter
+ * IDLE.  [The current 3.472 millisecond timeout was measured
+ * empirically by Nishanth Menon during an overnight run; its
+ * granularity is ~ 30.5 microseconds, since it was measured with the
+ * 32KiHz sync timer; see bug 133793]
+ */
+#define VP_IDLE_TIMEOUT		3472
+
+/*
+ * SR_DISABLE_TIMEOUT: maximum microseconds to wait for the SR to
+ * disable.  [The current 3.472 millisecond timeout was measured
+ * empirically by Nishanth Menon during an overnight run; its
+ * granularity is ~ 30.5 microseconds, since it was measured with the
+ * 32KiHz sync timer; see bug 133793]
+ */
+#define SR_DISABLE_TIMEOUT	3472
+
+/*
+ * SR_DISABLE_MAX_ATTEMPTS: arbitrary value intended to avoid system
+ * crashes if the SR disable process fails the first few times.  The
+ * kernel will WARN() for every timeout, but will BUG() after
+ * SR_DISABLE_MAX_ATTEMPTS.
+ */
+#define SR_DISABLE_MAX_ATTEMPTS 4
+
 struct omap_sr {
 	int		srid;
 	int		is_sr_reset;
@@ -83,8 +119,8 @@ static int sr_clk_enable(struct omap_sr
 	}
 
 	/* set fclk- active , iclk- idle */
-	sr_modify_reg(sr, ERRCONFIG, SR_CLKACTIVITY_MASK,
-		      SR_CLKACTIVITY_IOFF_FON);
+	sr_modify_reg(sr, ERRCONFIG, SR_CLKACTIVITY_MASK |
+		ERRCONFIG_INTERRUPT_STATUS_MASK, SR_CLKACTIVITY_IOFF_FON);
 
 	return 0;
 }
@@ -92,8 +128,8 @@ static int sr_clk_enable(struct omap_sr
 static void sr_clk_disable(struct omap_sr *sr)
 {
 	/* set fclk, iclk- idle */
-	sr_modify_reg(sr, ERRCONFIG, SR_CLKACTIVITY_MASK,
-		      SR_CLKACTIVITY_IOFF_FOFF);
+	sr_modify_reg(sr, ERRCONFIG, SR_CLKACTIVITY_MASK |
+		ERRCONFIG_INTERRUPT_STATUS_MASK, SR_CLKACTIVITY_IOFF_FOFF);
 
 	clk_disable(sr->clk);
 	sr->is_sr_reset = 1;
@@ -248,14 +284,20 @@ static void sr_set_nvalues(struct omap_s
 static void sr_configure_vp(int srid)
 {
 	u32 vpconfig;
+	u8 curr_opp_no;
 
 	if (srid == SR1) {
+		curr_opp_no = resource_get_level("vdd1_opp");
+
 		vpconfig = PRM_VP1_CONFIG_ERROROFFSET |
-			PRM_VP1_CONFIG_ERRORGAIN |
 			PRM_VP1_CONFIG_TIMEOUTEN |
-			mpu_opps[resource_get_level("vdd1_opp")].vsel <<
+			mpu_opps[curr_opp_no].vsel <<
 			OMAP3430_INITVOLTAGE_SHIFT;
 
+		vpconfig |= (curr_opp_no > SR_MAX_LOW_OPP) ?
+			PRM_VP1_CONFIG_ERRORGAIN_HIGHOPP :
+			PRM_VP1_CONFIG_ERRORGAIN_LOWOPP;
+
 		prm_write_mod_reg(vpconfig, OMAP3430_GR_MOD,
 					OMAP3_PRM_VP1_CONFIG_OFFSET);
 		prm_write_mod_reg(PRM_VP1_VSTEPMIN_SMPSWAITTIMEMIN |
@@ -290,12 +332,17 @@ static void sr_configure_vp(int srid)
 				       OMAP3_PRM_VP1_CONFIG_OFFSET);
 
 	} else if (srid == SR2) {
+		curr_opp_no = resource_get_level("vdd2_opp");
+
 		vpconfig = PRM_VP2_CONFIG_ERROROFFSET |
-			PRM_VP2_CONFIG_ERRORGAIN |
 			PRM_VP2_CONFIG_TIMEOUTEN |
-			l3_opps[resource_get_level("vdd2_opp")].vsel <<
+			l3_opps[curr_opp_no].vsel <<
 			OMAP3430_INITVOLTAGE_SHIFT;
 
+		vpconfig |= (curr_opp_no > SR_MAX_LOW_OPP) ?
+			PRM_VP2_CONFIG_ERRORGAIN_HIGHOPP :
+			PRM_VP2_CONFIG_ERRORGAIN_LOWOPP;
+
 		prm_write_mod_reg(vpconfig, OMAP3430_GR_MOD,
 					OMAP3_PRM_VP2_CONFIG_OFFSET);
 		prm_write_mod_reg(PRM_VP2_VSTEPMIN_SMPSWAITTIMEMIN |
@@ -356,8 +403,8 @@ static void sr_configure(struct omap_sr
 					SR1_AVGWEIGHT_SENNAVGWEIGHT);
 
 		sr_modify_reg(sr, ERRCONFIG, (SR_ERRWEIGHT_MASK |
-			SR_ERRMAXLIMIT_MASK | SR_ERRMINLIMIT_MASK),
-			(SR1_ERRWEIGHT | SR1_ERRMAXLIMIT | SR1_ERRMINLIMIT));
+			SR_ERRMAXLIMIT_MASK) | ERRCONFIG_INTERRUPT_STATUS_MASK,
+			(SR1_ERRWEIGHT | SR1_ERRMAXLIMIT));
 
 	} else if (sr->srid == SR2) {
 		sr_config = SR2_SRCONFIG_ACCUMDATA |
@@ -372,8 +419,8 @@ static void sr_configure(struct omap_sr
 		sr_write_reg(sr, AVGWEIGHT, SR2_AVGWEIGHT_SENPAVGWEIGHT |
 					SR2_AVGWEIGHT_SENNAVGWEIGHT);
 		sr_modify_reg(sr, ERRCONFIG, (SR_ERRWEIGHT_MASK |
-			SR_ERRMAXLIMIT_MASK | SR_ERRMINLIMIT_MASK),
-			(SR2_ERRWEIGHT | SR2_ERRMAXLIMIT | SR2_ERRMINLIMIT));
+			SR_ERRMAXLIMIT_MASK) | ERRCONFIG_INTERRUPT_STATUS_MASK,
+			(SR2_ERRWEIGHT | SR2_ERRMAXLIMIT));
 
 	}
 	sr->is_sr_reset = 0;
@@ -385,17 +432,41 @@ static int sr_reset_voltage(int srid)
 	u32 reg_addr = 0;
 	u32 loop_cnt = 0, retries_cnt = 0;
 	u32 vc_bypass_value;
+	u32 t2_smps_steps = 0;
+	u32 t2_smps_delay = 0;
+	u32 prm_vp1_voltage, prm_vp2_voltage, vp_config_offs;
+	u32 errorgain;
 
 	if (srid == SR1) {
-		target_opp_no = resource_get_level("vdd1_opp");
+		target_opp_no = sr1.req_opp_no;
 		vsel = mpu_opps[target_opp_no].vsel;
 		reg_addr = R_VDD1_SR_CONTROL;
+		prm_vp1_voltage = prm_read_mod_reg(OMAP3430_GR_MOD,
+						OMAP3_PRM_VP1_VOLTAGE_OFFSET);
+		t2_smps_steps = abs(vsel - prm_vp1_voltage);
+		errorgain = (target_opp_no > SR_MAX_LOW_OPP) ?
+			PRM_VP1_CONFIG_ERRORGAIN_HIGHOPP :
+			PRM_VP1_CONFIG_ERRORGAIN_LOWOPP;
+		vp_config_offs = OMAP3_PRM_VP1_CONFIG_OFFSET;
 	} else if (srid == SR2) {
-		target_opp_no = resource_get_level("vdd2_opp");
+		target_opp_no = sr2.req_opp_no;
 		vsel = l3_opps[target_opp_no].vsel;
 		reg_addr = R_VDD2_SR_CONTROL;
+		prm_vp2_voltage = prm_read_mod_reg(OMAP3430_GR_MOD,
+						OMAP3_PRM_VP2_VOLTAGE_OFFSET);
+		t2_smps_steps = abs(vsel - prm_vp2_voltage);
+		errorgain = (target_opp_no > SR_MAX_LOW_OPP) ?
+			PRM_VP2_CONFIG_ERRORGAIN_HIGHOPP :
+			PRM_VP2_CONFIG_ERRORGAIN_LOWOPP;
+		vp_config_offs = OMAP3_PRM_VP2_CONFIG_OFFSET;
+	} else {
+		WARN(1, "Bad SR ID %d", srid);
+		return SR_FAIL;
 	}
 
+	prm_rmw_mod_reg_bits(OMAP3430_ERRORGAIN_MASK, errorgain,
+			     OMAP3430_GR_MOD, vp_config_offs);
+
 	vc_bypass_value = (vsel << OMAP3430_DATA_SHIFT) |
 			(reg_addr << OMAP3430_REGADDR_SHIFT) |
 			(R_SRI2C_SLAVE_ADDR << OMAP3430_SLAVEADDR_SHIFT);
@@ -421,12 +492,21 @@ static int sr_reset_voltage(int srid)
 		vc_bypass_value = prm_read_mod_reg(OMAP3430_GR_MOD,
 					OMAP3_PRM_VC_BYPASS_VAL_OFFSET);
 	}
+
+	/*
+	 *  T2 SMPS slew rate (min) 4mV/uS, step size 12.5mV,
+	 *  2us added as buffer.
+	 */
+	t2_smps_delay = ((t2_smps_steps * 125) / 40) + 2;
+	udelay(t2_smps_delay);
+
 	return SR_PASS;
 }
 
 static int sr_enable(struct omap_sr *sr, u32 target_opp_no)
 {
 	u32 nvalue_reciprocal, v;
+	u8 errminlimit;
 
 	BUG_ON(!(mpu_opps && l3_opps));
 
@@ -479,11 +559,14 @@ static int sr_enable(struct omap_sr *sr,
 	sr_write_reg(sr, NVALUERECIPROCAL, nvalue_reciprocal);
 
 	/* Enable the interrupt */
-	sr_modify_reg(sr, ERRCONFIG,
-			(ERRCONFIG_VPBOUNDINTEN | ERRCONFIG_VPBOUNDINTST),
+	sr_modify_reg(sr, ERRCONFIG, (ERRCONFIG_VPBOUNDINTEN |
+				ERRCONFIG_INTERRUPT_STATUS_MASK),
 			(ERRCONFIG_VPBOUNDINTEN | ERRCONFIG_VPBOUNDINTST));
 
 	if (sr->srid == SR1) {
+		errminlimit = (target_opp_no > SR_MAX_LOW_OPP) ?
+			SR1_ERRMINLIMIT_HIGHOPP : SR1_ERRMINLIMIT_LOWOPP;
+
 		/* set/latch init voltage */
 		v = prm_read_mod_reg(OMAP3430_GR_MOD,
 				     OMAP3_PRM_VP1_CONFIG_OFFSET);
@@ -502,6 +585,9 @@ static int sr_enable(struct omap_sr *sr,
 		prm_set_mod_reg_bits(PRM_VP1_CONFIG_VPENABLE, OMAP3430_GR_MOD,
 				     OMAP3_PRM_VP1_CONFIG_OFFSET);
 	} else if (sr->srid == SR2) {
+		errminlimit = (target_opp_no > SR_MAX_LOW_OPP) ?
+			SR2_ERRMINLIMIT_HIGHOPP : SR2_ERRMINLIMIT_LOWOPP;
+
 		/* set/latch init voltage */
 		v = prm_read_mod_reg(OMAP3430_GR_MOD,
 				     OMAP3_PRM_VP2_CONFIG_OFFSET);
@@ -519,29 +605,144 @@ static int sr_enable(struct omap_sr *sr,
 		/* Enable VP2 */
 		prm_set_mod_reg_bits(PRM_VP2_CONFIG_VPENABLE, OMAP3430_GR_MOD,
 				     OMAP3_PRM_VP2_CONFIG_OFFSET);
+	} else {
+		WARN(1, "Bad SR ID %d", sr->srid);
+		return SR_FAIL;
 	}
 
+	sr_modify_reg(sr, ERRCONFIG, SR_ERRMINLIMIT_MASK |
+			ERRCONFIG_INTERRUPT_STATUS_MASK, errminlimit);
+
 	/* SRCONFIG - enable SR */
 	sr_modify_reg(sr, SRCONFIG, SRCONFIG_SRENABLE, SRCONFIG_SRENABLE);
 	return SR_TRUE;
 }
 
-static void sr_disable(struct omap_sr *sr)
+static void vp_disable(struct omap_sr *sr)
 {
-	sr->is_sr_reset = 1;
-
-	/* SRCONFIG - disable SR */
-	sr_modify_reg(sr, SRCONFIG, SRCONFIG_SRENABLE, ~SRCONFIG_SRENABLE);
+	u32 vp_config_offs, vp_status_offs;
+	u32 vp_tranxdone_st;
+	int c = 0, v;
 
 	if (sr->srid == SR1) {
-		/* Disable VP1 */
-		prm_clear_mod_reg_bits(PRM_VP1_CONFIG_VPENABLE, OMAP3430_GR_MOD,
-					OMAP3_PRM_VP1_CONFIG_OFFSET);
+		vp_config_offs = OMAP3_PRM_VP1_CONFIG_OFFSET;
+		vp_status_offs = OMAP3_PRM_VP1_STATUS_OFFSET;
+		vp_tranxdone_st = OMAP3430_VP1_TRANXDONE_ST;
 	} else if (sr->srid == SR2) {
-		/* Disable VP2 */
-		prm_clear_mod_reg_bits(PRM_VP2_CONFIG_VPENABLE, OMAP3430_GR_MOD,
-					OMAP3_PRM_VP2_CONFIG_OFFSET);
+		vp_config_offs = OMAP3_PRM_VP2_CONFIG_OFFSET;
+		vp_status_offs = OMAP3_PRM_VP2_STATUS_OFFSET;
+		vp_tranxdone_st = OMAP3430_VP2_TRANXDONE_ST;
+	} else {
+		WARN(1, "Bad SR ID");
+		return;
+	}
+
+	/*
+	 * Clear all pending TransactionDone int/st here
+	 * XXX Do we need to make sure this INTEN bit is masked so the
+	 * PRCM ISR isn't called?
+	 */
+	do {
+		prm_write_mod_reg(vp_tranxdone_st, OCP_MOD,
+				  OMAP2_PRM_IRQSTATUS_MPU_OFFSET);
+		v = prm_read_mod_reg(OCP_MOD, OMAP2_PRM_IRQSTATUS_MPU_OFFSET);
+		v &= vp_tranxdone_st;
+		/*
+		 * XXX This udelay(1) will wait for longer than 1
+		 * microsecond when switching to a lower OPP, since
+		 * loops_per_jiffy is not yet updated at this point
+		 */
+		if (v)
+			udelay(1);
+		c++;
+	} while (v && c < VP_TRANXDONE_TIMEOUT);
+
+	/* XXX Need clarity from TI on what to do if the timeout is reached */
+	WARN(c == VP_TRANXDONE_TIMEOUT, "VP: TRANXDONE timeout exceeded");
+
+	/* Disable VP */
+	prm_clear_mod_reg_bits(OMAP3430_VPENABLE, OMAP3430_GR_MOD,
+			       vp_config_offs);
+
+	/* Wait for VP to be in IDLE - typical latency < 1 microsecond */
+	c = 0;
+	while (c < VP_IDLE_TIMEOUT &&
+	       !(prm_read_mod_reg(OMAP3430_GR_MOD, vp_status_offs) &
+		 OMAP3430_VPINIDLE)) {
+		/*
+		 * XXX This udelay(1) will wait for longer than 1
+		 * microsecond when switching to a lower OPP, since
+		 * loops_per_jiffy is not yet updated at this point
+		 */
+		udelay(1);
+		c++;
 	}
+
+	/* XXX Need clarity from TI on what to do if the timeout is reached */
+	WARN(c == VP_IDLE_TIMEOUT, "VP: IDLE timeout exceeded");
+}
+
+static void sr_disable(struct omap_sr *sr)
+{
+	u32 srconfig;
+	int c;
+	u8 retries = 0;
+
+	/* Check to see if SR is already disabled.  If so, skip */
+	srconfig = sr_read_reg(sr, SRCONFIG);
+	if (!(srconfig & SRCONFIG_SRENABLE)) {
+		/* XXX In callers, add disable VP after sr_clk_disable() etc */
+		sr->is_sr_reset = 1;
+		return;
+	}
+
+	/* Enable MCUDisableAcknowledge interrupt */
+	sr_modify_reg(sr, ERRCONFIG, ERRCONFIG_MCUDISACKINTEN |
+			ERRCONFIG_INTERRUPT_STATUS_MASK,
+		      ERRCONFIG_MCUDISACKINTEN);
+
+	/* Clear SREnable */
+	srconfig &= ~SRCONFIG_SRENABLE;
+	sr_write_reg(sr, SRCONFIG, srconfig);
+
+	/* Disable VPBOUND interrupt enable and status */
+	sr_modify_reg(sr, ERRCONFIG, ERRCONFIG_VPBOUNDINTEN |
+			ERRCONFIG_INTERRUPT_STATUS_MASK,
+		      ERRCONFIG_VPBOUNDINTST);
+
+	do {
+		c = 0;
+		/* Wait for SR to be disabled - typical time < 1 microsecond */
+		while (c < SR_DISABLE_TIMEOUT &&
+		       !(sr_read_reg(sr, ERRCONFIG) & ERRCONFIG_MCUDISACKINTST)) {
+			/*
+			 * XXX This udelay(1) will wait for longer than 1
+			 * microsecond when switching to a lower OPP, since
+			 * loops_per_jiffy is not yet updated at this point
+			 */
+			udelay(1);
+			c++;
+		}
+
+		/* Could be due to a board-level I2C4 problem */
+		WARN(c == SR_DISABLE_TIMEOUT, "SR disable timed out - "
+		     "should never happen");
+
+	} while ((c == SR_DISABLE_TIMEOUT) &&
+		 (++retries < SR_DISABLE_MAX_ATTEMPTS));
+
+	WARN(retries == SR_DISABLE_MAX_ATTEMPTS, "SR voltage change failed "
+	     "despite %d retries - should never happen - system will likely "
+	     "crash soon", SR_DISABLE_MAX_ATTEMPTS);
+
+	/* Disable MCUDisableAck interrupt and clear pending */
+	sr_modify_reg(sr, ERRCONFIG, (ERRCONFIG_MCUDISACKINTEN |
+				ERRCONFIG_INTERRUPT_STATUS_MASK),
+			ERRCONFIG_MCUDISACKINTST);
+
+	/* Disable SR func clk - done by sr_clk_disable() */
+
+	sr->is_sr_reset = 1;
 }
 
 
@@ -553,6 +754,8 @@ void sr_start_vddautocomap(int srid, u32
 		sr = &sr1;
 	else if (srid == SR2)
 		sr = &sr2;
+	else
+		return;
 
 	if (sr->is_sr_reset == 1) {
 		sr_clk_enable(sr);
@@ -576,8 +779,11 @@ int sr_stop_vddautocomap(int srid)
 		sr = &sr1;
 	else if (srid == SR2)
 		sr = &sr2;
+	else
+		return -EINVAL;
 
 	if (sr->is_autocomp_active == 1) {
+		vp_disable(sr);
 		sr_disable(sr);
 		sr_clk_disable(sr);
 		sr->is_autocomp_active = 0;
@@ -598,16 +804,15 @@ void enable_smartreflex(int srid)
 		sr = &sr1;
 	else if (srid == SR2)
 		sr = &sr2;
+	else
+		return;
 
 	if (sr->is_autocomp_active == 1) {
 		if (sr->is_sr_reset == 1) {
 			/* Enable SR clks */
 			sr_clk_enable(sr);
 
-			if (srid == SR1)
-				target_opp_no = resource_get_level("vdd1_opp");
-			else if (srid == SR2)
-				target_opp_no = resource_get_level("vdd2_opp");
+			target_opp_no = sr->req_opp_no;
 
 			sr_configure(sr);
 
@@ -625,28 +830,17 @@ void disable_smartreflex(int srid)
 		sr = &sr1;
 	else if (srid == SR2)
 		sr = &sr2;
+	else
+		return;
 
 	if (sr->is_autocomp_active == 1) {
 		if (sr->is_sr_reset == 0) {
 
 			sr->is_sr_reset = 1;
-			/* SRCONFIG - disable SR */
-			sr_modify_reg(sr, SRCONFIG, SRCONFIG_SRENABLE,
-							~SRCONFIG_SRENABLE);
-
+			vp_disable(sr);
+			sr_disable(sr);
 			/* Disable SR clk */
 			sr_clk_disable(sr);
-			if (sr->srid == SR1) {
-				/* Disable VP1 */
-				prm_clear_mod_reg_bits(PRM_VP1_CONFIG_VPENABLE,
-						OMAP3430_GR_MOD,
-						OMAP3_PRM_VP1_CONFIG_OFFSET);
-			} else if (sr->srid == SR2) {
-				/* Disable VP2 */
-				prm_clear_mod_reg_bits(PRM_VP2_CONFIG_VPENABLE,
-						OMAP3430_GR_MOD,
-						OMAP3_PRM_VP2_CONFIG_OFFSET);
-			}
 			/* Reset the volatage for current OPP */
 			sr_reset_voltage(srid);
 		}
@@ -654,37 +848,62 @@ void disable_smartreflex(int srid)
 }
 
 /* Voltage Scaling using SR VCBYPASS */
-int sr_voltagescale_vcbypass(u32 target_opp, u8 vsel)
+int sr_voltagescale_vcbypass(u32 target_opp, u32 current_opp,
+					u8 target_vsel, u8 current_vsel)
 {
-	int sr_status = 0;
-	u32 vdd, target_opp_no;
+	u32 vdd, target_opp_no, current_opp_no;
 	u32 vc_bypass_value;
 	u32 reg_addr = 0;
 	u32 loop_cnt = 0, retries_cnt = 0;
+	u32 t2_smps_steps = 0;
+	u32 t2_smps_delay = 0;
+	u32 vc_cmd_val_offs, vp_config_offs;
+	u32 errorgain;
+	struct omap_sr *sr;
 
 	vdd = get_vdd(target_opp);
 	target_opp_no = get_opp_no(target_opp);
+	current_opp_no = get_opp_no(current_opp);
 
 	if (vdd == PRCM_VDD1) {
-		sr_status = sr_stop_vddautocomap(SR1);
+		t2_smps_steps = abs(target_vsel - current_vsel);
+		errorgain = (target_opp_no > SR_MAX_LOW_OPP) ?
+			PRM_VP1_CONFIG_ERRORGAIN_HIGHOPP :
+			PRM_VP1_CONFIG_ERRORGAIN_LOWOPP;
 
-		prm_rmw_mod_reg_bits(OMAP3430_VC_CMD_ON_MASK,
-					(vsel << OMAP3430_VC_CMD_ON_SHIFT),
-					OMAP3430_GR_MOD,
-					OMAP3_PRM_VC_CMD_VAL_0_OFFSET);
+		vc_cmd_val_offs = OMAP3_PRM_VC_CMD_VAL_0_OFFSET;
+		vp_config_offs = OMAP3_PRM_VP1_CONFIG_OFFSET;
 		reg_addr = R_VDD1_SR_CONTROL;
-
+		sr = &sr1;
 	} else if (vdd == PRCM_VDD2) {
-		sr_status = sr_stop_vddautocomap(SR2);
+		t2_smps_steps = abs(target_vsel - current_vsel);
+		errorgain = (target_opp_no > SR_MAX_LOW_OPP) ?
+			PRM_VP2_CONFIG_ERRORGAIN_HIGHOPP :
+			PRM_VP2_CONFIG_ERRORGAIN_LOWOPP;
 
-		prm_rmw_mod_reg_bits(OMAP3430_VC_CMD_ON_MASK,
-					(vsel << OMAP3430_VC_CMD_ON_SHIFT),
-					OMAP3430_GR_MOD,
-					OMAP3_PRM_VC_CMD_VAL_1_OFFSET);
+		vc_cmd_val_offs = OMAP3_PRM_VC_CMD_VAL_1_OFFSET;
+		vp_config_offs = OMAP3_PRM_VP2_CONFIG_OFFSET;
 		reg_addr = R_VDD2_SR_CONTROL;
+		sr = &sr2;
+	} else {
+		WARN(1, "SR: invalid VDD in vcbypass scale");
+		return SR_FAIL;
 	}
 
-	vc_bypass_value = (vsel << OMAP3430_DATA_SHIFT) |
+	if (sr->is_autocomp_active) {
+		WARN(1, "SR: Must not transmit VCBYPASS command while SR is "
+		     "active");
+		return SR_FAIL;
+	}
+
+	prm_rmw_mod_reg_bits(OMAP3430_ERRORGAIN_MASK, errorgain,
+			     OMAP3430_GR_MOD, vp_config_offs);
+
+	prm_rmw_mod_reg_bits(OMAP3430_VC_CMD_ON_MASK,
+			     (target_vsel << OMAP3430_VC_CMD_ON_SHIFT),
+			     OMAP3430_GR_MOD, vc_cmd_val_offs);
+
+	vc_bypass_value = (target_vsel << OMAP3430_DATA_SHIFT) |
 			(reg_addr << OMAP3430_REGADDR_SHIFT) |
 			(R_SRI2C_SLAVE_ADDR << OMAP3430_SLAVEADDR_SHIFT);
 
@@ -710,14 +929,13 @@ int sr_voltagescale_vcbypass(u32 target_
 					OMAP3_PRM_VC_BYPASS_VAL_OFFSET);
 	}
 
-	udelay(T2_SMPS_UPDATE_DELAY);
+	/*
+	 *  T2 SMPS slew rate (min) 4mV/uS, step size 12.5mV,
+	 *  2us added as buffer.
+	 */
+	t2_smps_delay = ((t2_smps_steps * 125) / 40) + 2;
+	udelay(t2_smps_delay);
 
-	if (sr_status) {
-		if (vdd == PRCM_VDD1)
-			sr_start_vddautocomap(SR1, target_opp_no);
-		else if (vdd == PRCM_VDD2)
-			sr_start_vddautocomap(SR2, target_opp_no);
-	}
 
 	return SR_PASS;
 }
@@ -733,7 +951,6 @@ static ssize_t omap_sr_vdd1_autocomp_sto
 					struct kobj_attribute *attr,
 					const char *buf, size_t n)
 {
-	u32 current_vdd1opp_no;
 	unsigned short value;
 
 	if (sscanf(buf, "%hu", &value) != 1 || (value > 1)) {
@@ -741,12 +958,20 @@ static ssize_t omap_sr_vdd1_autocomp_sto
 		return -EINVAL;
 	}
 
-	current_vdd1opp_no = resource_get_level("vdd1_opp");
+	mutex_lock(&dvfs_mutex);
 
-	if (value == 0)
+	if (value == 0) {
 		sr_stop_vddautocomap(SR1);
-	else
+	} else {
+		u32 current_vdd1opp_no = resource_get_level("vdd1_opp");
+		if (IS_ERR_VALUE(current_vdd1opp_no)) {
+			mutex_unlock(&dvfs_mutex);
+			return -ENODEV;
+		}
 		sr_start_vddautocomap(SR1, current_vdd1opp_no);
+	}
+
+	mutex_unlock(&dvfs_mutex);
 
 	return n;
 }
@@ -779,6 +1004,8 @@ static ssize_t omap_sr_vdd2_autocomp_sto
 		return -EINVAL;
 	}
 
+	mutex_lock(&dvfs_mutex);
+
 	current_vdd2opp_no = resource_get_level("vdd2_opp");
 
 	if (value == 0)
@@ -786,6 +1013,8 @@ static ssize_t omap_sr_vdd2_autocomp_sto
 	else
 		sr_start_vddautocomap(SR2, current_vdd2opp_no);
 
+	mutex_unlock(&dvfs_mutex);
+
 	return n;
 }
 
@@ -798,7 +1027,20 @@ static struct kobj_attribute sr_vdd2_aut
 	.store = omap_sr_vdd2_autocomp_store,
 };
 
+static ssize_t omap_sr_opp1_efuse_show(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	return sprintf(buf, "%08x\n", sr1.opp1_nvalue);
+}
 
+static struct kobj_attribute sr_opp1_efuse = {
+	.attr = {
+	.name = "OPP1Efuse",
+	.mode = 0444,
+	},
+	.show = omap_sr_opp1_efuse_show,
+};
 
 static int __init omap3_sr_init(void)
 {
@@ -837,6 +1079,10 @@ static int __init omap3_sr_init(void)
 	if (ret)
 		printk(KERN_ERR "sysfs_create_file failed: %d\n", ret);
 
+	ret = sysfs_create_file(power_kobj, &sr_opp1_efuse.attr);
+	if (ret)
+		printk(KERN_ERR "sysfs_create_file failed for OPP data: %d\n", ret);
+
 	return 0;
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/smartreflex.h kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/smartreflex.h
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/smartreflex.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/smartreflex.h	2012-12-16 13:13:01.528330149 +0100
@@ -48,7 +48,8 @@
 
 /* PRM_VP1_CONFIG */
 #define PRM_VP1_CONFIG_ERROROFFSET	(0x00 << 24)
-#define PRM_VP1_CONFIG_ERRORGAIN	(0x20 << 16)
+#define PRM_VP1_CONFIG_ERRORGAIN_LOWOPP		(0x0C << 16)  /* OPPs 1,2 */
+#define PRM_VP1_CONFIG_ERRORGAIN_HIGHOPP	(0x18 << 16)  /* OPPs 3,4,5 */
 
 #define PRM_VP1_CONFIG_INITVOLTAGE	(0x30 << 8) /* 1.2 volt */
 #define PRM_VP1_CONFIG_TIMEOUTEN	(0x1 << 3)
@@ -66,12 +67,13 @@
 
 /* PRM_VP1_VLIMITTO */
 #define PRM_VP1_VLIMITTO_VDDMAX		(0x3C << 24)
-#define PRM_VP1_VLIMITTO_VDDMIN		(0x0 << 16)
-#define PRM_VP1_VLIMITTO_TIMEOUT	(0xFFFF << 0)
+#define PRM_VP1_VLIMITTO_VDDMIN		(0x14 << 16)
+#define PRM_VP1_VLIMITTO_TIMEOUT	(0xF00 << 0)
 
 /* PRM_VP2_CONFIG */
 #define PRM_VP2_CONFIG_ERROROFFSET	(0x00 << 24)
-#define PRM_VP2_CONFIG_ERRORGAIN	(0x20 << 16)
+#define PRM_VP2_CONFIG_ERRORGAIN_LOWOPP		(0x0C << 16)  /* OPPs 1,2 */
+#define PRM_VP2_CONFIG_ERRORGAIN_HIGHOPP	(0x18 << 16)  /* OPPs 3,4,5 */
 
 #define PRM_VP2_CONFIG_INITVOLTAGE	(0x30 << 8) /* 1.2 volt */
 #define PRM_VP2_CONFIG_TIMEOUTEN	(0x1 << 3)
@@ -89,8 +91,8 @@
 
 /* PRM_VP2_VLIMITTO */
 #define PRM_VP2_VLIMITTO_VDDMAX		(0x2C << 24)
-#define PRM_VP2_VLIMITTO_VDDMIN		(0x0 << 16)
-#define PRM_VP2_VLIMITTO_TIMEOUT	(0xFFFF << 0)
+#define PRM_VP2_VLIMITTO_VDDMIN		(0x18 << 16)
+#define PRM_VP2_VLIMITTO_TIMEOUT	(0xF00 << 0)
 
 /* SRCONFIG */
 #define SR1_SRCONFIG_ACCUMDATA		(0x1F4 << 22)
@@ -139,13 +141,34 @@
 #define ERRCONFIG_VPBOUNDINTEN		(0x1 << 31)
 #define ERRCONFIG_VPBOUNDINTST		(0x1 << 30)
 
+#define ERRCONFIG_MCUDISACKINTEN	(0x1 << 23)
+#define ERRCONFIG_MCUDISACKINTST	(0x1 << 22)
+
+/* Status Bits */
+#define ERRCONFIG_MCUACCUMINTST		(0x1 << 28)
+#define ERRCONFIG_MCUVALIDINTST		(0x1 << 26)
+#define ERRCONFIG_MCUBOUNDINTST		(0x1 << 24)
+#define ERRCONFIG_RESERVED		(0x1 << 19)
+
+/* WARNING: Ensure all access to errconfig register skips
+ * clearing intst bits to ensure that we dont clear status
+ * bits unwantedly.. esp vpbound
+ */
+#define ERRCONFIG_INTERRUPT_STATUS_MASK  (ERRCONFIG_VPBOUNDINTST |\
+		ERRCONFIG_MCUACCUMINTST |\
+		ERRCONFIG_MCUVALIDINTST |\
+		ERRCONFIG_MCUBOUNDINTST |\
+		ERRCONFIG_MCUDISACKINTST | ERRCONFIG_RESERVED)
+
 #define SR1_ERRWEIGHT			(0x07 << 16)
 #define SR1_ERRMAXLIMIT			(0x02 << 8)
-#define SR1_ERRMINLIMIT			(0xFA << 0)
+#define SR1_ERRMINLIMIT_LOWOPP		(0xF4 << 0)	/* OPP1, 2 */
+#define SR1_ERRMINLIMIT_HIGHOPP		(0xF9 << 0)	/* OPP3, 4, 5 */
 
 #define SR2_ERRWEIGHT			(0x07 << 16)
 #define SR2_ERRMAXLIMIT			(0x02 << 8)
-#define SR2_ERRMINLIMIT			(0xF9 << 0)
+#define SR2_ERRMINLIMIT_LOWOPP		(0xF4 << 0)	/* OPP1, 2 */
+#define SR2_ERRMINLIMIT_HIGHOPP		(0xF9 << 0)	/* OPP3, 4, 5 */
 
 /* T2 SMART REFLEX */
 #define R_SRI2C_SLAVE_ADDR		0x12
@@ -230,6 +253,9 @@
 #define PRCM_NO_VDD2_OPPS	3
 /* XXX: end remove/move */
 
+/* SR_MAX_LOW_OPP: the highest of the "low OPPs", 1 and 2. */
+#define SR_MAX_LOW_OPP		2
+
 /* XXX: find more appropriate place for these once DVFS is in place */
 extern u32 current_vdd1_opp;
 extern u32 current_vdd2_opp;
@@ -248,7 +274,7 @@ extern u32 current_vdd2_opp;
 #ifdef CONFIG_OMAP_SMARTREFLEX
 void enable_smartreflex(int srid);
 void disable_smartreflex(int srid);
-int sr_voltagescale_vcbypass(u32 target_opp, u8 vsel);
+int sr_voltagescale_vcbypass(u32 t_opp, u32 c_opp, u8 t_vsel, u8 c_vsel);
 void sr_start_vddautocomap(int srid, u32 target_opp_no);
 int sr_stop_vddautocomap(int srid);
 #else
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/sram34xx.S kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/sram34xx.S
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/sram34xx.S	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/sram34xx.S	2012-12-16 13:13:01.528330149 +0100
@@ -36,7 +36,7 @@
 
 	.text
 
-/* r4 parameters */
+/* r1 parameters */
 #define SDRC_NO_UNLOCK_DLL		0x0
 #define SDRC_UNLOCK_DLL			0x1
 
@@ -61,41 +61,60 @@
 
 /*
  * omap3_sram_configure_core_dpll - change DPLL3 M2 divider
- * r0 = new SDRC_RFR_CTRL register contents
- * r1 = new SDRC_ACTIM_CTRLA register contents
- * r2 = new SDRC_ACTIM_CTRLB register contents
- * r3 = new M2 divider setting (only 1 and 2 supported right now)
- * r4 = unlock SDRC DLL? (1 = yes, 0 = no).  Only unlock DLL for
+ *
+ * Params passed in registers:
+ *  r0 = new M2 divider setting (only 1 and 2 supported right now)
+ *  r1 = unlock SDRC DLL? (1 = yes, 0 = no).  Only unlock DLL for
  *      SDRC rates < 83MHz
- * r5 = number of MPU cycles to wait for SDRC to stabilize after
+ *  r2 = number of MPU cycles to wait for SDRC to stabilize after
  *      reprogramming the SDRC when switching to a slower MPU speed
- * r6 = new SDRC_MR_0 register value
- * r7 = increasing SDRC rate? (1 = yes, 0 = no)
+ *  r3 = increasing SDRC rate? (1 = yes, 0 = no)
+ *
+ * Params passed via the stack. The needed params will be copied in SRAM
+ *  before use by the code in SRAM (SDRAM is not accessible during SDRC
+ *  reconfiguration):
+ *  new SDRC_RFR_CTRL_0 register contents
+ *  new SDRC_MR_0 register value
+ *  new SDRC_RFR_CTRL_1 register contents
+ *  new SDRC_MR_1 register value
  *
+ * If the param SDRC_RFR_CTRL_1 is 0, the parameters
+ *  are not programmed into the SDRC CS1 registers
  */
 ENTRY(omap3_sram_configure_core_dpll)
 	stmfd	sp!, {r1-r12, lr}	@ store regs to stack
-	ldr	r4, [sp, #52]		@ pull extra args off the stack
-	ldr	r5, [sp, #56]		@ load extra args from the stack
-	ldr	r6, [sp, #60]		@ load extra args from the stack
-	ldr	r7, [sp, #64]		@ load extra args from the stack
+
+					@ pull the extra args off the stack
+					@  and store them in SRAM
+	ldr	r4, [sp, #52]
+	str     r4, omap_sdrc_rfr_ctrl_0_val
+	ldr	r4, [sp, #56]
+	str     r4, omap_sdrc_mr_0_val
+	ldr	r4, [sp, #60]
+	str     r4, omap_sdrc_rfr_ctrl_1_val
+	cmp	r4, #0			@ if SDRC_RFR_CTRL_1 is 0,
+	beq	skip_cs1_params		@  do not use cs1 params
+	ldr	r4, [sp, #64]
+	str     r4, omap_sdrc_mr_1_val
+skip_cs1_params:
 	dsb				@ flush buffered writes to interconnect
-	cmp	r7, #1			@ if increasing SDRC clk rate,
+
+	cmp	r3, #1			@ if increasing SDRC clk rate,
 	bleq	configure_sdrc		@ program the SDRC regs early (for RFR)
-	cmp	r4, #SDRC_UNLOCK_DLL	@ set the intended DLL state
+	cmp	r1, #SDRC_UNLOCK_DLL	@ set the intended DLL state
 	bleq	unlock_dll
 	blne	lock_dll
 	bl	sdram_in_selfrefresh	@ put SDRAM in self refresh, idle SDRC
 	bl 	configure_core_dpll	@ change the DPLL3 M2 divider
+	mov	r12, r2
+	bl	wait_clk_stable		@ wait for SDRC to stabilize
 	bl	enable_sdrc		@ take SDRC out of idle
-	cmp	r4, #SDRC_UNLOCK_DLL	@ wait for DLL status to change
+	cmp	r1, #SDRC_UNLOCK_DLL	@ wait for DLL status to change
 	bleq	wait_dll_unlock
 	blne	wait_dll_lock
-	cmp	r7, #1			@ if increasing SDRC clk rate,
+	cmp	r3, #1			@ if increasing SDRC clk rate,
 	beq	return_to_sdram		@ return to SDRAM code, otherwise,
 	bl	configure_sdrc		@ reprogram SDRC regs now
-	mov	r12, r5
-	bl	wait_clk_stable		@ wait for SDRC to stabilize
 return_to_sdram:
 	isb				@ prevent speculative exec past here
 	mov 	r0, #0 			@ return value
@@ -137,7 +156,7 @@ configure_core_dpll:
 	ldr	r12, [r11]
 	ldr	r10, core_m2_mask_val	@ modify m2 for core dpll
 	and	r12, r12, r10
-	orr	r12, r12, r3, lsl #CORE_DPLL_CLKOUT_DIV_SHIFT
+	orr	r12, r12, r0, lsl #CORE_DPLL_CLKOUT_DIV_SHIFT
 	str	r12, [r11]
 	ldr	r12, [r11]		@ posted-write barrier for CM
 	bx	lr
@@ -175,15 +194,22 @@ wait_dll_unlock:
 	bne	wait_dll_unlock
 	bx	lr
 configure_sdrc:
-	ldr	r11, omap3_sdrc_rfr_ctrl
-	str	r0, [r11]
-	ldr	r11, omap3_sdrc_actim_ctrla
-	str	r1, [r11]
-	ldr	r11, omap3_sdrc_actim_ctrlb
-	str	r2, [r11]
+	ldr	r12, omap_sdrc_rfr_ctrl_0_val	@ fetch value from SRAM
+	ldr	r11, omap3_sdrc_rfr_ctrl_0	@ fetch addr from SRAM
+	str	r12, [r11]			@ store
+	ldr	r12, omap_sdrc_mr_0_val
 	ldr	r11, omap3_sdrc_mr_0
-	str	r6, [r11]
-	ldr	r6, [r11]		@ posted-write barrier for SDRC
+	str	r12, [r11]
+	ldr	r12, omap_sdrc_rfr_ctrl_1_val
+	cmp	r12, #0			@ if SDRC_RFR_CTRL_1 is 0,
+	beq	skip_cs1_prog		@  do not program cs1 params
+	ldr	r11, omap3_sdrc_rfr_ctrl_1
+	str	r12, [r11]
+	ldr	r12, omap_sdrc_mr_1_val
+	ldr	r11, omap3_sdrc_mr_1
+	str	r12, [r11]
+skip_cs1_prog:
+	ldr	r12, [r11]		@ posted-write barrier for SDRC
 	bx	lr
 
 omap3_sdrc_power:
@@ -194,14 +220,24 @@ omap3_cm_idlest1_core:
 	.word OMAP34XX_CM_REGADDR(CORE_MOD, CM_IDLEST)
 omap3_cm_iclken1_core:
 	.word OMAP34XX_CM_REGADDR(CORE_MOD, CM_ICLKEN1)
-omap3_sdrc_rfr_ctrl:
+
+omap3_sdrc_rfr_ctrl_0:
 	.word OMAP34XX_SDRC_REGADDR(SDRC_RFR_CTRL_0)
-omap3_sdrc_actim_ctrla:
-	.word OMAP34XX_SDRC_REGADDR(SDRC_ACTIM_CTRL_A_0)
-omap3_sdrc_actim_ctrlb:
-	.word OMAP34XX_SDRC_REGADDR(SDRC_ACTIM_CTRL_B_0)
+omap3_sdrc_rfr_ctrl_1:
+	.word OMAP34XX_SDRC_REGADDR(SDRC_RFR_CTRL_1)
 omap3_sdrc_mr_0:
 	.word OMAP34XX_SDRC_REGADDR(SDRC_MR_0)
+omap3_sdrc_mr_1:
+	.word OMAP34XX_SDRC_REGADDR(SDRC_MR_1)
+omap_sdrc_rfr_ctrl_0_val:
+	.word 0xDEADBEEF
+omap_sdrc_rfr_ctrl_1_val:
+	.word 0xDEADBEEF
+omap_sdrc_mr_0_val:
+	.word 0xDEADBEEF
+omap_sdrc_mr_1_val:
+	.word 0xDEADBEEF
+
 omap3_sdrc_dlla_status:
 	.word OMAP34XX_SDRC_REGADDR(SDRC_DLLA_STATUS)
 omap3_sdrc_dlla_ctrl:
@@ -211,3 +247,4 @@ core_m2_mask_val:
 
 ENTRY(omap3_sram_configure_core_dpll_sz)
 	.word	. - omap3_sram_configure_core_dpll
+
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/ssi.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/ssi.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/ssi.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/ssi.c	2012-12-16 13:13:01.528330149 +0100
@@ -32,6 +32,8 @@
 #include <linux/ssi_driver_if.h>
 #include "clock.h"
 #include <mach/omap-pm.h>
+#include "cm.h"
+#include "cm-regbits-34xx.h"
 
 #define SSI_RATE_CHANGE		1
 
@@ -153,8 +155,7 @@ static int ssi_clk_notifier_unregister(s
 
 	ssi_clk = container_of(clk, struct ssi_internal_clk, clk);
 	ssi_clk->drv_nb = NULL;
-	ssi_clk->nb.priority = INT_MAX;
-	return clk_notifier_unregister(ssi_clk->childs[1], nb); /* FCK */
+	return clk_notifier_unregister(ssi_clk->childs[1], &ssi_clk->nb);
 }
 
 static void ssi_save_ctx(struct platform_device *pdev)
@@ -363,6 +364,24 @@ static int ssi_clk_init(struct ssi_inter
 	return 0;
 }
 
+static void disable_dpll3_autoidle(void)
+{
+	u32 v;
+
+	v = cm_read_mod_reg(PLL_MOD, CM_AUTOIDLE);
+	v &= ~0x7;
+	cm_write_mod_reg(v, PLL_MOD, CM_AUTOIDLE);
+}
+
+static void enable_dpll3_autoidle(void)
+{
+	u32 v;
+
+	v = cm_read_mod_reg(PLL_MOD, CM_AUTOIDLE);
+	v |= 1;
+	cm_write_mod_reg(v, PLL_MOD, CM_AUTOIDLE);
+}
+
 static int ssi_clk_enable(struct clk *clk)
 {
 	struct ssi_internal_clk *ssi_clk =
@@ -370,6 +389,8 @@ static int ssi_clk_enable(struct clk *cl
 	int err;
 	int i;
 
+	disable_dpll3_autoidle();
+
 	for (i = 0; i < ssi_clk->n_childs; i++) {
 		err = omap2_clk_enable(ssi_clk->childs[i]);
 		if (unlikely(err < 0))
@@ -392,6 +413,8 @@ rollback:
 	for (i = i - 1; i >= 0; i--)
 		omap2_clk_disable(ssi_clk->childs[i]);
 
+	enable_dpll3_autoidle();
+
 	return err;
 }
 
@@ -410,6 +433,9 @@ static void ssi_clk_disable(struct clk *
 
 	for (i = 0; i < ssi_clk->n_childs; i++)
 		omap2_clk_disable(ssi_clk->childs[i]);
+
+	enable_dpll3_autoidle();
+
 }
 
 int omap_ssi_config(struct omap_ssi_board_config *ssi_config)
@@ -434,8 +460,6 @@ int omap_ssi_config(struct omap_ssi_boar
 		ssi_resources[6 + port].flags &= ~IORESOURCE_UNSET;
 		ssi_resources[6 + port].flags |= IORESOURCE_IRQ_HIGHEDGE |
 							IORESOURCE_IRQ_LOWEDGE;
-
-		set_irq_type(gpio_to_irq(cawake_gpio), IRQ_TYPE_EDGE_BOTH);
 	}
 	return 0;
 }
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/timer-gp.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/timer-gp.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/timer-gp.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/timer-gp.c	2012-12-16 13:13:01.528330149 +0100
@@ -81,9 +81,21 @@ static void omap2_gp_timer_set_mode(enum
 	case CLOCK_EVT_MODE_ONESHOT:
 		break;
 	case CLOCK_EVT_MODE_UNUSED:
-	case CLOCK_EVT_MODE_SHUTDOWN:
 	case CLOCK_EVT_MODE_RESUME:
 		break;
+	case CLOCK_EVT_MODE_SHUTDOWN:
+		/*
+		 * Wait for min period x 2 to make sure that timer is
+		 * stopped
+		 */
+		udelay(evt->min_delta_ns / 500);
+		/*
+		 * Clear possibly pending interrupt, this will occasionally
+		 * generate spurious timer IRQs during suspend but this
+		 * is okay, as another option is not to enter suspend at all
+		 */
+		omap_dm_timer_write_status(gptimer, OMAP_TIMER_INT_OVERFLOW);
+		break;
 	}
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/usb-musb.c kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/usb-musb.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mach-omap2/usb-musb.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mach-omap2/usb-musb.c	2012-12-16 13:13:01.528330149 +0100
@@ -163,8 +163,10 @@ static struct platform_device musb_devic
 #endif
 
 
-void __init usb_musb_init(void)
+void __init usb_musb_init(struct musb_board_data *board)
 {
+	musb_plat.board = board;
+
 #ifdef CONFIG_USB_MUSB_SOC
 	if (platform_device_register(&musb_device) < 0) {
 		printk(KERN_ERR "Unable to register HS-USB (MUSB) device\n");
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mm/cache-v7.S kernel-2.6.28-20093908+0m5/arch/arm/mm/cache-v7.S
--- kernel-2.6.28-20091602+0m5/arch/arm/mm/cache-v7.S	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mm/cache-v7.S	2012-12-16 13:13:01.528330149 +0100
@@ -26,6 +26,7 @@
  *	- mm    - mm_struct describing address space
  */
 ENTRY(v7_flush_dcache_all)
+	dmb					@ ensure ordering with previous memory accesses
 	mrc	p15, 1, r0, c0, c0, 1		@ read clidr
 	ands	r3, r0, #0x7000000		@ extract loc from clidr
 	mov	r3, r3, lsr #23			@ left align loc bit field
@@ -64,6 +65,7 @@ skip:
 finished:
 	mov	r10, #0				@ swith back to cache level 0
 	mcr	p15, 2, r10, c0, c0, 0		@ select current cache level in cssr
+	dsb
 	isb
 	mov	pc, lr
 ENDPROC(v7_flush_dcache_all)
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/mm/fault.c kernel-2.6.28-20093908+0m5/arch/arm/mm/fault.c
--- kernel-2.6.28-20091602+0m5/arch/arm/mm/fault.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/mm/fault.c	2012-12-16 13:13:01.528330149 +0100
@@ -22,6 +22,19 @@
 
 #include "fault.h"
 
+/*
+ * Fault status register encodings.  We steal bit 31 for our own purposes.
+ */
+#define FSR_LNX_PF		(1 << 31)
+#define FSR_WRITE		(1 << 11)
+#define FSR_FS4			(1 << 10)
+#define FSR_FS3_0		(15)
+
+static inline int fsr_fs(unsigned int fsr)
+{
+	return (fsr & FSR_FS3_0) | (fsr & FSR_FS4) >> 6;
+}
+
 
 #ifdef CONFIG_KPROBES
 static inline int notify_page_fault(struct pt_regs *regs, unsigned int fsr)
@@ -172,18 +185,35 @@ void do_bad_area(unsigned long addr, uns
 #define VM_FAULT_BADMAP		0x010000
 #define VM_FAULT_BADACCESS	0x020000
 
-static int
+/*
+ * Check that the permissions on the VMA allow for the fault which occurred.
+ * If we encountered a write fault, we must have write permission, otherwise
+ * we allow any permission.
+ */
+static inline bool access_error(unsigned int fsr, struct vm_area_struct *vma)
+{
+	unsigned int mask = VM_READ | VM_WRITE | VM_EXEC;
+
+	if (fsr & FSR_WRITE)
+		mask = VM_WRITE;
+	if (fsr & FSR_LNX_PF)
+		mask = VM_EXEC;
+
+	return vma->vm_flags & mask ? false : true;
+}
+
+static int __kprobes
 __do_page_fault(struct mm_struct *mm, unsigned long addr, unsigned int fsr,
 		struct task_struct *tsk)
 {
 	struct vm_area_struct *vma;
-	int fault, mask;
+	int fault;
 
 	vma = find_vma(mm, addr);
 	fault = VM_FAULT_BADMAP;
-	if (!vma)
+	if (unlikely(!vma))
 		goto out;
-	if (vma->vm_start > addr)
+	if (unlikely(vma->vm_start > addr))
 		goto check_stack;
 
 	/*
@@ -191,14 +221,10 @@ __do_page_fault(struct mm_struct *mm, un
 	 * memory access, so we can handle it.
 	 */
 good_area:
-	if (fsr & (1 << 11)) /* write? */
-		mask = VM_WRITE;
-	else
-		mask = VM_READ|VM_EXEC|VM_WRITE;
-
-	fault = VM_FAULT_BADACCESS;
-	if (!(vma->vm_flags & mask))
+	if (access_error(fsr, vma)) {
+		fault = VM_FAULT_BADACCESS;
 		goto out;
+	}
 
 	/*
 	 * If for any reason at all we couldn't handle
@@ -206,7 +232,7 @@ good_area:
 	 * than endlessly redo the fault.
 	 */
 survive:
-	fault = handle_mm_fault(mm, vma, addr & PAGE_MASK, fsr & (1 << 11));
+	fault = handle_mm_fault(mm, vma, addr & PAGE_MASK, fsr & FSR_WRITE);
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
@@ -268,6 +294,13 @@ do_page_fault(unsigned long addr, unsign
 		if (!user_mode(regs) && !search_exception_tables(regs->ARM_pc))
 			goto no_context;
 		down_read(&mm->mmap_sem);
+	} else {
+		/*
+		 * The above down_read_trylock() might have succeeded in
+		 * which case, we'll have missed the might_sleep() from
+		 * down_read()
+		 */
+		might_sleep();
 	}
 
 	fault = __do_page_fault(mm, addr, fsr, tsk);
@@ -463,10 +496,10 @@ hook_fault_code(int nr, int (*fn)(unsign
 asmlinkage void __exception
 do_DataAbort(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
 {
-	const struct fsr_info *inf = fsr_info + (fsr & 15) + ((fsr & (1 << 10)) >> 6);
+	const struct fsr_info *inf = fsr_info + fsr_fs(fsr);
 	struct siginfo info;
 
-	if (!inf->fn(addr, fsr, regs))
+	if (!inf->fn(addr, fsr & ~FSR_LNX_PF, regs))
 		return;
 
 	printk(KERN_ALERT "Unhandled fault: %s (0x%03x) at 0x%08lx\n",
@@ -482,6 +515,6 @@ do_DataAbort(unsigned long addr, unsigne
 asmlinkage void __exception
 do_PrefetchAbort(unsigned long addr, struct pt_regs *regs)
 {
-	do_translation_fault(addr, 0, regs);
+	do_translation_fault(addr, FSR_LNX_PF, regs);
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/oprofile/backtrace.c kernel-2.6.28-20093908+0m5/arch/arm/oprofile/backtrace.c
--- kernel-2.6.28-20091602+0m5/arch/arm/oprofile/backtrace.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/oprofile/backtrace.c	2012-12-16 13:13:01.528330149 +0100
@@ -33,41 +33,54 @@ static int report_trace(struct stackfram
 	return *depth == 0;
 }
 
-/*
- * The registers we're interested in are at the end of the variable
- * length saved register structure. The fp points at the end of this
- * structure so the address of this struct is:
- * (struct frame_tail *)(xxx->fp)-1
- */
-struct frame_tail {
-	struct frame_tail *fp;
-	unsigned long sp;
-	unsigned long lr;
-} __attribute__((packed));
-
-static struct frame_tail* user_backtrace(struct frame_tail *tail)
+static void **user_backtrace(struct pt_regs * const regs,
+				void **frame, int step)
 {
-	struct frame_tail buftail[2];
+	void *frame_data[4];
+	int   instr;
 
-	/* Also check accessibility of one struct frame_tail beyond */
-	if (!access_ok(VERIFY_READ, tail, sizeof(buftail)))
-		return NULL;
-	if (__copy_from_user_inatomic(buftail, tail, sizeof(buftail)))
-		return NULL;
+	void *ret_addr;
+	void **next_frame;
 
-	oprofile_add_trace(buftail[0].lr);
+	if (!access_ok(VERIFY_READ, frame - 3, sizeof(frame_data)))
+		return 0;
+	if (__copy_from_user_inatomic(frame_data, frame - 3,
+						sizeof(frame_data)))
+		return 0;
+
+	if (access_ok(VERIFY_READ, (int *)frame_data[3] - 2, sizeof(instr)) &&
+		__copy_from_user_inatomic(&instr, (int *)frame_data[3] - 2,
+						sizeof(instr)) == 0 &&
+					(instr & 0xFFFFD800) == 0xE92DD800) {
+		/* Standard APCS frame */
+		ret_addr = frame_data[2];
+		next_frame = frame_data[0];
+	} else if (step != 0 ||
+		(unsigned long)frame_data[2] - (unsigned long)regs->ARM_sp <
+		(unsigned long)frame_data[3] - (unsigned long)regs->ARM_sp) {
+		/* Heuristic detection: codesourcery optimized normal frame */
+		ret_addr = frame_data[3];
+		next_frame = frame_data[2];
+	} else {
+		/* Heuristic detection: codesourcery optimized leaf frame */
+		ret_addr = (void *)regs->ARM_lr;
+		next_frame = frame_data[3];
+	}
 
 	/* frame pointers should strictly progress back up the stack
 	 * (towards higher addresses) */
-	if (tail >= buftail[0].fp)
+	if (next_frame <= frame)
 		return NULL;
 
-	return buftail[0].fp-1;
+	oprofile_add_trace((unsigned long)ret_addr);
+
+	return next_frame;
 }
 
 void arm_backtrace(struct pt_regs * const regs, unsigned int depth)
 {
-	struct frame_tail *tail = ((struct frame_tail *) regs->ARM_fp) - 1;
+	int step = 0;
+	void **frame = (void **)regs->ARM_fp;
 
 	if (!user_mode(regs)) {
 		unsigned long base = ((unsigned long)regs) & ~(THREAD_SIZE - 1);
@@ -76,6 +89,6 @@ void arm_backtrace(struct pt_regs * cons
 		return;
 	}
 
-	while (depth-- && tail && !((unsigned long) tail & 3))
-		tail = user_backtrace(tail);
+	while (depth-- && frame && !((unsigned long) frame & 3))
+		frame = user_backtrace(regs, frame, step++);
 }
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/common.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/common.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/common.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/common.c	2012-12-16 13:13:01.528330149 +0100
@@ -46,6 +46,12 @@ int omap_bootloader_tag_len;
 struct omap_board_config_kernel *omap_board_config;
 int omap_board_config_size;
 
+#ifdef CONFIG_OMAP_PM_NONE
+struct omap_opp *mpu_opps;
+struct omap_opp *dsp_opps;
+struct omap_opp *l3_opps;
+#endif
+
 #ifdef CONFIG_OMAP_BOOT_TAG
 
 static int __init parse_tag_omap(const struct tag *tag)
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/cpu-omap.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/cpu-omap.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/cpu-omap.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/cpu-omap.c	2012-12-16 13:13:01.528330149 +0100
@@ -89,10 +89,10 @@ static int omap_target(struct cpufreq_po
 
 	/* Ensure desired rate is within allowed range.  Some govenors
 	 * (ondemand) will just pass target_freq=0 to get the minimum. */
-	if (target_freq < policy->cpuinfo.min_freq)
-		target_freq = policy->cpuinfo.min_freq;
-	if (target_freq > policy->cpuinfo.max_freq)
-		target_freq = policy->cpuinfo.max_freq;
+	if (target_freq < policy->min)
+		target_freq = policy->min;
+	if (target_freq > policy->max)
+		target_freq = policy->max;
 
 #ifdef CONFIG_ARCH_OMAP1
 	freqs.old = omap_getspeed(0);
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/dma.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/dma.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/dma.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/dma.c	2012-12-16 13:13:01.528330149 +0100
@@ -315,41 +315,62 @@ EXPORT_SYMBOL(omap_set_dma_transfer_para
 
 void omap_set_dma_color_mode(int lch, enum omap_dma_color_mode mode, u32 color)
 {
-	u16 w;
-
 	BUG_ON(omap_dma_in_1510_mode());
 
-	if (cpu_class_is_omap2()) {
-		REVISIT_24XX();
-		return;
-	}
+	if (cpu_class_is_omap1()) {
+		u16 w;
 
-	w = dma_read(CCR2(lch));
-	w &= ~0x03;
+		w = dma_read(CCR2(lch));
+		w &= ~0x03;
 
-	switch (mode) {
-	case OMAP_DMA_CONSTANT_FILL:
-		w |= 0x01;
-		break;
-	case OMAP_DMA_TRANSPARENT_COPY:
-		w |= 0x02;
-		break;
-	case OMAP_DMA_COLOR_DIS:
-		break;
-	default:
-		BUG();
+		switch (mode) {
+		case OMAP_DMA_CONSTANT_FILL:
+			w |= 0x01;
+			break;
+		case OMAP_DMA_TRANSPARENT_COPY:
+			w |= 0x02;
+			break;
+		case OMAP_DMA_COLOR_DIS:
+			break;
+		default:
+			BUG();
+		}
+		dma_write(w, CCR2(lch));
+
+		w = dma_read(LCH_CTRL(lch));
+		w &= ~0x0f;
+		/* Default is channel type 2D */
+		if (mode) {
+			dma_write((u16)color, COLOR_L(lch));
+			dma_write((u16)(color >> 16), COLOR_U(lch));
+			w |= 1;		/* Channel type G */
+		}
+		dma_write(w, LCH_CTRL(lch));
 	}
-	dma_write(w, CCR2(lch));
 
-	w = dma_read(LCH_CTRL(lch));
-	w &= ~0x0f;
-	/* Default is channel type 2D */
-	if (mode) {
-		dma_write((u16)color, COLOR_L(lch));
-		dma_write((u16)(color >> 16), COLOR_U(lch));
-		w |= 1;		/* Channel type G */
+	if (cpu_class_is_omap2()) {
+		u32 val;
+
+		val = dma_read(CCR(lch));
+		val &= ~((1 << 17) | (1 << 16));
+
+		switch (mode) {
+		case OMAP_DMA_CONSTANT_FILL:
+			val |= 1 << 16;
+			break;
+		case OMAP_DMA_TRANSPARENT_COPY:
+			val |= 1 << 17;
+			break;
+		case OMAP_DMA_COLOR_DIS:
+			break;
+		default:
+			BUG();
+		}
+		dma_write(val, CCR(lch));
+
+		color &= 0xffffff;
+		dma_write(color, COLOR(lch));
 	}
-	dma_write(w, LCH_CTRL(lch));
 }
 EXPORT_SYMBOL(omap_set_dma_color_mode);
 
@@ -2320,6 +2341,8 @@ EXPORT_SYMBOL(omap_dma_global_context_sa
 
 void omap_dma_global_context_restore(void)
 {
+	int ch;
+
 	dma_write(omap_dma_global_context.dma_gcr, GCR);
 	dma_write(omap_dma_global_context.dma_ocp_sysconfig,
 		OCP_SYSCONFIG);
@@ -2335,6 +2358,10 @@ void omap_dma_global_context_restore(voi
 	if (cpu_is_omap34xx() && (omap_type() != OMAP2_DEVICE_TYPE_GP)) {
 		dma_write(0x3 , IRQSTATUS_L0);
 	}
+
+	for (ch = 0; ch < dma_chan_count; ch++)
+		if (dma_chan[ch].dev_id != -1)
+			omap_clear_dma(ch);
 }
 EXPORT_SYMBOL(omap_dma_global_context_restore);
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/dmtimer.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/dmtimer.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/dmtimer.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/dmtimer.c	2012-12-16 13:13:01.528330149 +0100
@@ -319,6 +319,7 @@ static void omap_dm_timer_reset(struct o
 	l = omap_dm_timer_read_reg(timer, OMAP_TIMER_OCP_CFG_REG);
 	l |= 0x02 << 3;  /* Set to smart-idle mode */
 	l |= 0x2 << 8;   /* Set clock activity to perserve f-clock on idle */
+	l |= 0x1 << 0;   /* Set autoidle */
 
 	/*
 	 * Enable wake-up on OMAP2 CPUs.
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/dss_boottime.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/dss_boottime.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/dss_boottime.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/dss_boottime.c	2012-12-16 13:13:01.528330149 +0100
@@ -27,6 +27,7 @@
 #include <linux/err.h>
 #include <linux/clk.h>
 #include <linux/omapfb.h>
+#include <linux/delay.h>
 
 #include <asm/io.h>
 
@@ -178,6 +179,18 @@ static u32 __init dispc_read_reg(int reg
 }
 
 /**
+ * dispc_write_reg          Write a DISPC register
+ * @reg - DISPC register to write
+ * @val - value to write
+ *
+ * Assumes that clocks are on.
+ */
+static void __init dispc_write_reg(int reg, u32 val)
+{
+	omap_writel(val, DISPC_BASE + reg);
+}
+
+/**
  * dss_read_reg          Read a DSS register
  * @reg - DSS register to read
  *
@@ -308,6 +321,20 @@ enum omapfb_color_format __init dss_boot
 	return mode_info[mode].format;
 }
 
+int __init dss_boottime_get_plane_bpp(int plane_idx)
+{
+	unsigned mode;
+	unsigned bpp;
+
+	if (!dss_boottime_plane_is_enabled(plane_idx))
+		return -1;
+
+	mode = get_plane_mode(plane_idx);
+	bpp = mode_info[mode].bpp;
+
+	return bpp;
+}
+
 /**
  * dss_boottime_get_plane_size - get size of a plane's FB
  * @plane_idx - plane index
@@ -318,7 +345,6 @@ enum omapfb_color_format __init dss_boot
 size_t __init dss_boottime_get_plane_size(int plane_idx)
 {
 	u32 l;
-	unsigned mode;
 	unsigned bpp;
 	unsigned x, y;
 	size_t size;
@@ -326,8 +352,7 @@ size_t __init dss_boottime_get_plane_siz
 	if (!dss_boottime_plane_is_enabled(plane_idx))
 		return -1;
 
-	mode = get_plane_mode(plane_idx);
-	bpp = mode_info[mode].bpp;
+	bpp = dss_boottime_get_plane_bpp(plane_idx);
 
 	l = dispc_read_reg(siz_reg[plane_idx]);
 	x = l & ((1 << 11) - 1);
@@ -362,6 +387,15 @@ int __init dss_boottime_reset(void)
 	if (enable_digit_clocks() < 0)
 		goto err2;
 
+	/* Resetting DSS right after enabling clocks, or if
+	 * bootloader has enabled the display, seems to put
+	 * DSS sometimes in an invalid state. Disabling output
+	 * and waiting after enabling clocks seem to fix this */
+
+	/* disable LCD & DIGIT output */
+	dispc_write_reg(DISPC_CONTROL, dispc_read_reg(DISPC_CONTROL) & ~0x3);
+	msleep(50);
+
 	/* Soft reset */
 	l = dss_read_reg(DSS_SYSCONFIG);
 	l |= 1 << 1;
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/fb.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/fb.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/fb.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/fb.c	2012-12-16 13:13:01.528330149 +0100
@@ -491,10 +491,6 @@ void omapfb_set_platform_data(struct oma
 #ifdef CONFIG_FB_OMAP_BOOTLOADER_INIT
 static void __init enable_used_clocks(void)
 {
-	unsigned long paddr;
-	size_t size;
-	enum omapfb_color_format format;
-
 	if (!dss_boottime_plane_is_enabled(0))
 		return;
 
@@ -508,17 +504,6 @@ static void __init enable_used_clocks(vo
 		dss_boottime_put_clocks();
 	}
 
-	paddr = dss_boottime_get_plane_base(0);
-	format = dss_boottime_get_plane_format(0);
-	size = dss_boottime_get_plane_size(0);
-
-	omapfb_config.mem_desc.region[0].paddr = paddr;
-	omapfb_config.mem_desc.region[0].format = format;
-	omapfb_config.mem_desc.region[0].format_used = 1;
-	omapfb_config.mem_desc.region[0].size = size;
-	if (!omapfb_config.mem_desc.region_cnt)
-		omapfb_config.mem_desc.region_cnt = 1;
-
 	return;
 }
 #else
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/gpio.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/gpio.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/gpio.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/gpio.c	2012-12-16 13:13:01.528330149 +0100
@@ -226,6 +226,7 @@ static struct gpio_bank gpio_bank_34xx[6
 #define OMAP34XX_PAD_SAFE_MODE 0x7
 #define OMAP34XX_PAD_IN_PU_GPIO 0x11c
 #define OMAP34XX_PAD_IN_PD_GPIO 0x10c
+#define OMAP34XX_PAD_WAKE_EN (1 << 14)
 
 struct omap3_gpio_regs {
 	u32 sysconfig;
@@ -578,6 +579,9 @@ static inline void set_24xx_gpio_trigger
 {
 	void __iomem *base = bank->base;
 	u32 gpio_bit = 1 << gpio;
+	struct gpio_pad *pad;
+	int gpio_num;
+	u16 val;
 
 	MOD_REG_BIT(OMAP24XX_GPIO_LEVELDETECT0, gpio_bit,
 		trigger & IRQ_TYPE_LEVEL_LOW);
@@ -589,6 +593,21 @@ static inline void set_24xx_gpio_trigger
 		trigger & IRQ_TYPE_EDGE_FALLING);
 
 	if (likely(!(bank->non_wakeup_gpios & gpio_bit))) {
+		pad = gpio_pads;
+
+		gpio_num = bank->virtual_irq_start - IH_GPIO_BASE + gpio;
+		/* Find the pad corresponding the GPIO */
+		while (pad->gpio >= 0 && pad->gpio != gpio_num)
+			pad++;
+		/* Enable / disable pad wakeup */
+		if (pad->gpio == gpio_num) {
+			val = omap_ctrl_readw(pad->offset);
+			if (trigger)
+				val |= OMAP34XX_PAD_WAKE_EN;
+			else
+				val &= ~(u16)OMAP34XX_PAD_WAKE_EN;
+			omap_ctrl_writew(val, pad->offset);
+		}
 		if (trigger != 0)
 			__raw_writel(1 << gpio, bank->base
 					+ OMAP24XX_GPIO_SETWKUENA);
@@ -1131,6 +1150,7 @@ static void gpio_mask_irq(unsigned int i
 	struct gpio_bank *bank = get_irq_chip_data(irq);
 
 	_set_gpio_irqenable(bank, gpio, 0);
+	_set_gpio_triggering(bank, get_gpio_index(gpio), IRQ_TYPE_NONE);
 }
 
 static void gpio_unmask_irq(unsigned int irq)
@@ -1138,6 +1158,11 @@ static void gpio_unmask_irq(unsigned int
 	unsigned int gpio = irq - IH_GPIO_BASE;
 	struct gpio_bank *bank = get_irq_chip_data(irq);
 	unsigned int irq_mask = 1 << get_gpio_index(gpio);
+	struct irq_desc *desc = irq_to_desc(irq);
+	u32 trigger = desc->status & IRQ_TYPE_SENSE_MASK;
+
+	if (trigger)
+		_set_gpio_triggering(bank, get_gpio_index(gpio), trigger);
 
 	/* For level-triggered GPIOs, the clearing must be done after
 	 * the HW source is cleared, thus after the handler has run */
@@ -1408,7 +1433,7 @@ static int __init omap3_gpio_pads_init(v
 	kfree(gpio_pad_map);
 	return 0;
 }
-late_initcall(omap3_gpio_pads_init);
+early_initcall(omap3_gpio_pads_init);
 #endif
 
 /* This lock class tells lockdep that GPIO irqs are in a different
@@ -1797,7 +1822,7 @@ void omap2_gpio_resume_after_idle(void)
 		min = 1;
 	for (i = min; i < gpio_bank_count; i++) {
 		struct gpio_bank *bank = &gpio_bank[i];
-		u32 l;
+		u32 l, gen, gen0, gen1;
 
 		if (cpu_is_omap34xx() && bank->dbck_enable_mask)
 			clk_enable(bank->dbck);
@@ -1822,13 +1847,32 @@ void omap2_gpio_resume_after_idle(void)
 #endif
 		l ^= bank->saved_datain;
 		l &= bank->enabled_non_wakeup_gpios;
-		if (l) {
+
+		/*
+		 * No need to generate IRQs for the rising edge for gpio IRQs
+		 * configured with falling edge only; and vice versa.
+		 */
+		gen0 = l & bank->saved_fallingdetect;
+		gen0 &= bank->saved_datain;
+
+		gen1 = l & bank->saved_risingdetect;
+		gen1 &= ~(bank->saved_datain);
+
+		/* FIXME: Consider GPIO IRQs with level detections properly! */
+		gen = l & (~(bank->saved_fallingdetect) &
+				~(bank->saved_risingdetect));
+		/* Consider all GPIO IRQs needed to be updated */
+		gen |= gen0 | gen1;
+
+		if (gen) {
 			u32 old0, old1;
 #if defined(CONFIG_ARCH_OMAP24XX) || defined(CONFIG_ARCH_OMAP34XX)
 			old0 = __raw_readl(bank->base + OMAP24XX_GPIO_LEVELDETECT0);
 			old1 = __raw_readl(bank->base + OMAP24XX_GPIO_LEVELDETECT1);
-			__raw_writel(old0 | l, bank->base + OMAP24XX_GPIO_LEVELDETECT0);
-			__raw_writel(old1 | l, bank->base + OMAP24XX_GPIO_LEVELDETECT1);
+			__raw_writel(old0 | gen, bank->base +
+				OMAP24XX_GPIO_LEVELDETECT0);
+			__raw_writel(old1 | gen, bank->base +
+				OMAP24XX_GPIO_LEVELDETECT1);
 			__raw_writel(old0, bank->base + OMAP24XX_GPIO_LEVELDETECT0);
 			__raw_writel(old1, bank->base + OMAP24XX_GPIO_LEVELDETECT1);
 #endif
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/gpio-switch.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/gpio-switch.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/gpio-switch.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/gpio-switch.c	2012-12-16 13:13:01.528330149 +0100
@@ -37,6 +37,8 @@ struct gpio_switch {
 	u16		debounce_rising;
 	u16		debounce_falling;
 
+	int		disabled;
+
 	void (* notify)(void *data, int state);
 	void *notify_data;
 
@@ -151,6 +153,8 @@ static ssize_t gpio_sw_state_show(struct
 	struct gpio_switch *sw = dev_get_drvdata(dev);
 	const char **str;
 
+	if (sw->disabled)
+		sw->state = gpio_sw_get_state(sw);
 	str = get_sw_str(sw);
 	return sprintf(buf, "%s\n", str[sw->state]);
 }
@@ -182,6 +186,42 @@ static ssize_t gpio_sw_direction_show(st
 
 static DEVICE_ATTR(direction, S_IRUGO, gpio_sw_direction_show, NULL);
 
+static ssize_t gpio_sw_disable_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf,
+				   size_t count)
+{
+	struct gpio_switch *sw = dev_get_drvdata(dev);
+	unsigned long res;
+
+	if (strict_strtoul(buf, 10, &res) < 0)
+		return -EINVAL;
+
+	if (!!res == sw->disabled)
+		goto out;
+	sw->disabled = !!res;
+
+	if (res) {
+		disable_irq(gpio_to_irq(sw->gpio));
+	} else {
+		sw->state = gpio_sw_get_state(sw);
+		enable_irq(gpio_to_irq(sw->gpio));
+	}
+out:
+	return count;
+}
+
+static ssize_t gpio_sw_disable_show(struct device *dev,
+				  struct device_attribute *attr,
+				  char *buf)
+{
+	struct gpio_switch *sw = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sw->disabled);
+}
+
+static DEVICE_ATTR(disable, S_IRUGO | S_IWUSR, gpio_sw_disable_show,
+		   gpio_sw_disable_store);
 
 static irqreturn_t gpio_sw_irq_handler(int irq, void *arg)
 {
@@ -302,6 +342,8 @@ static int __init new_switch(struct gpio
 	r |= device_create_file(&sw->pdev.dev, &dev_attr_state);
 	r |= device_create_file(&sw->pdev.dev, &dev_attr_type);
 	r |= device_create_file(&sw->pdev.dev, &dev_attr_direction);
+	if (direction)
+		r |= device_create_file(&sw->pdev.dev, &dev_attr_disable);
 	if (r)
 		printk(KERN_ERR "gpio-switch: attribute file creation "
 		       "failed for %s\n", sw->name);
@@ -393,51 +435,6 @@ no_check:
 	return NULL;
 }
 
-int omap_update_gpio_switch(const struct omap_gpio_switch *cfg)
-{
-	struct gpio_switch *sw;
-	int r;
-
-	if (cfg->name != NULL && strlen(cfg->name) > sizeof(sw->name) - 1)
-		return -EINVAL;
-
-	sw = find_switch(cfg->gpio, cfg->name);
-	if (sw != NULL) {
-		sw->debounce_rising = cfg->debounce_rising;
-		sw->debounce_falling = cfg->debounce_falling;
-		sw->notify = cfg->notify;
-		sw->notify_data = cfg->notify_data;
-		return 0;
-	} else {
-		if (cfg->gpio < 0 || cfg->name == NULL) {
-			printk(KERN_ERR "gpio-switch: required switch not "
-				"found (%d, %s)\n", cfg->gpio,
-				cfg->name);
-			return -EINVAL;
-		}
-	}
-	sw = kzalloc(sizeof(*sw), GFP_KERNEL);
-	if (sw == NULL) {
-		printk(KERN_ERR "gpio-switch: kmalloc failed\n");
-		return -ENOMEM;
-	}
-	strlcpy(sw->name, cfg->name, sizeof(sw->name));
-	sw->gpio = cfg->gpio;
-	sw->flags = cfg->flags;
-	sw->type = cfg->type;
-	sw->debounce_rising = cfg->debounce_rising;
-	sw->debounce_falling = cfg->debounce_falling;
-	sw->notify = cfg->notify;
-	sw->notify_data = cfg->notify_data;
-	r = new_switch(sw);
-	if (r < 0) {
-		kfree(sw);
-		return r;
-	}
-	return 0;
-}
-EXPORT_SYMBOL(omap_update_gpio_switch);
-
 static int __init add_board_switches(void)
 {
 	int i;
@@ -504,6 +501,9 @@ static void gpio_sw_cleanup(void)
 		device_remove_file(&sw->pdev.dev, &dev_attr_type);
 		device_remove_file(&sw->pdev.dev, &dev_attr_direction);
 
+		if (!(sw->flags & OMAP_GPIO_SWITCH_FLAG_OUTPUT))
+			device_remove_file(&sw->pdev.dev, &dev_attr_disable);
+
 		platform_device_unregister(&sw->pdev);
 		gpio_free(sw->gpio);
 		old = sw;
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/cfgdefs.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/cfgdefs.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/cfgdefs.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/cfgdefs.h	2012-12-16 13:13:01.528330149 +0100
@@ -77,15 +77,6 @@
 		u8 bIRQAttrib;	/* IRQ Attribute */
 		u32 dwOffsetForMonitor;	/* The Shared memory starts from
 					 * dwMemBase + this offset */
-		u32 dwBusType;	/* Bus type for this device */
-		u32 dwProgBase;	/* DSP ProgBase */
-		u32 dwProgLength;	/* DSP ProgBase Length */
-		u32 dwRegBase;	/* DSP memory mapped register base */
-		u32 dwRegLength;	/* DSP Register Base Length */
-		u32 ClientHandle;	/* Client Handle */
-		u32 SocketHandle;	/* Socket and Function Pair */
-		u32 CardInfo;	/* This will be used as a context data in
-				 * in the CardRequestIRQ */
 	/*
 	 *  Info needed by NODE for allocating channels to communicate with RMS:
 	 *      dwChnlOffset:       Offset of RMS channels. Lower channels are
@@ -96,16 +87,15 @@
 		u32 dwChnlOffset;
 		u32 dwChnlBufSize;
 		u32 dwNumChnls;
-		u32 dwPrmBase;
-		u32 dwCmBase;
-		u32 dwPerBase;
-               u32 dwPerPmBase;
-               u32 dwCorePmBase;
-		u32 dwWdTimerDspBase;
-		u32 dwMboxBase;
-		u32 dwDmmuBase;
-		u32 dwDipiBase;
-		u32 dwSysCtrlBase;
+		void __iomem *dwPrmBase;
+		void __iomem *dwCmBase;
+		void __iomem *dwPerBase;
+		u32 dwPerPmBase;
+		u32 dwCorePmBase;
+		void __iomem *dwWdTimerDspBase;
+		void __iomem *dwMboxBase;
+		void __iomem *dwDmmuBase;
+		void __iomem *dwSysCtrlBase;
 	} ;
 
 	struct CFG_DSPMEMDESC {
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/dbc.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/dbc.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/dbc.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/dbc.h	2012-12-16 13:13:01.532330149 +0100
@@ -57,9 +57,9 @@
 
 #else
 
-#define DBC_Assert(exp)
-#define DBC_Require(exp)
-#define DBC_Ensure(exp)
+#define DBC_Assert(exp) {}
+#define DBC_Require(exp) {}
+#define DBC_Ensure(exp) {}
 
 #endif				/* DEBUG */
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/dbdefs.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/dbdefs.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/dbdefs.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/dbdefs.h	2012-12-16 13:13:01.532330149 +0100
@@ -101,6 +101,7 @@
 #define DSP_MMUFAULT                0x00000010
 #define DSP_SYSERROR                0x00000020
 #define DSP_EXCEPTIONABORT          0x00000300
+#define DSP_PWRERROR                0x00000080
 
 /* IVA exception events (IVA MMU fault) */
 #define IVA_MMUFAULT                0x00000040
@@ -174,7 +175,8 @@
 				    DSP_STREAMDONE | \
 				    DSP_STREAMIOCOMPLETION | \
 				    DSP_MMUFAULT | \
-				    DSP_SYSERROR)) && \
+				    DSP_SYSERROR | \
+				    DSP_PWRERROR)) && \
 				!((x) & ~(DSP_PROCESSORSTATECHANGE | \
 				    DSP_PROCESSORATTACH | \
 				    DSP_PROCESSORDETACH | \
@@ -183,7 +185,8 @@
 				    DSP_STREAMDONE | \
 				    DSP_STREAMIOCOMPLETION | \
 				    DSP_MMUFAULT | \
-				    DSP_SYSERROR))))
+				    DSP_SYSERROR | \
+				    DSP_PWRERROR))))
 
 #define IsValidNodeEvent(x)    (((x) == 0) || (((x) & (DSP_NODESTATECHANGE | \
 				DSP_NODEMESSAGEREADY)) && \
@@ -571,6 +574,9 @@ bit 6 - MMU element size = 64bit (valid
 
 #define DSP_MAPVMALLOCADDR         0x00000080
 
+#define DSP_MAPDONOTLOCK	   0x00000100
+
+
 #define GEM_CACHE_LINE_SIZE     128
 #define GEM_L1P_PREFETCH_SIZE   128
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/dbg.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/dbg.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/dbg.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/dbg.h	2012-12-16 13:13:01.532330149 +0100
@@ -101,9 +101,9 @@
 	extern DSP_STATUS DBG_Trace(IN u8 bLevel, IN char *pstrFormat, ...);
 #else
 
-#define DBG_Exit(void)
+#define DBG_Exit(void) do {} while (0)
 #define DBG_Init(void) true
-#define DBG_Trace(bLevel, pstrFormat, args...)
+#define DBG_Trace(bLevel, pstrFormat, args...) do {} while (0)
 
 #endif	     /* (defined(DEBUG) || defined(DDSP_DEBUG_PRODUCT)) && GT_TRACE */
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/_dcd.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/_dcd.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/_dcd.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/_dcd.h	2012-12-16 13:13:01.532330149 +0100
@@ -72,7 +72,7 @@
  */
 	extern DSP_STATUS WCD_CallDevIOCtl(unsigned int cmd,
 					   union Trapped_Args *args,
-					   u32 *pResult);
+					   u32 *pResult, void *pr_ctxt);
 
 /*
  *  ======== WCD_Init ========
@@ -119,69 +119,94 @@
 	extern void WCD_Exit(void);
 
 /* MGR wrapper functions */
-	extern u32 MGRWRAP_EnumNode_Info(union Trapped_Args *args);
-	extern u32 MGRWRAP_EnumProc_Info(union Trapped_Args *args);
-	extern u32 MGRWRAP_RegisterObject(union Trapped_Args *args);
-	extern u32 MGRWRAP_UnregisterObject(union Trapped_Args *args);
-	extern u32 MGRWRAP_WaitForBridgeEvents(union Trapped_Args *args);
+	extern u32 MGRWRAP_EnumNode_Info(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 MGRWRAP_EnumProc_Info(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 MGRWRAP_RegisterObject(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 MGRWRAP_UnregisterObject(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 MGRWRAP_WaitForBridgeEvents(union Trapped_Args *args,
+			void *pr_ctxt);
 
 #ifndef RES_CLEANUP_DISABLE
-	extern u32 MGRWRAP_GetProcessResourcesInfo(union Trapped_Args *args);
+	extern u32 MGRWRAP_GetProcessResourcesInfo(union Trapped_Args *args,
+			void *pr_ctxt);
 #endif
 
 
 /* CPRC (Processor) wrapper Functions */
-	extern u32 PROCWRAP_Attach(union Trapped_Args *args);
-	extern u32 PROCWRAP_Ctrl(union Trapped_Args *args);
-	extern u32 PROCWRAP_Detach(union Trapped_Args *args);
-	extern u32 PROCWRAP_EnumNode_Info(union Trapped_Args *args);
-	extern u32 PROCWRAP_EnumResources(union Trapped_Args *args);
-	extern u32 PROCWRAP_GetState(union Trapped_Args *args);
-	extern u32 PROCWRAP_GetTrace(union Trapped_Args *args);
-	extern u32 PROCWRAP_Load(union Trapped_Args *args);
-	extern u32 PROCWRAP_RegisterNotify(union Trapped_Args *args);
-	extern u32 PROCWRAP_Start(union Trapped_Args *args);
-	extern u32 PROCWRAP_ReserveMemory(union Trapped_Args *args);
-	extern u32 PROCWRAP_UnReserveMemory(union Trapped_Args *args);
-	extern u32 PROCWRAP_Map(union Trapped_Args *args);
-	extern u32 PROCWRAP_UnMap(union Trapped_Args *args);
-	extern u32 PROCWRAP_FlushMemory(union Trapped_Args *args);
-	extern u32 PROCWRAP_Stop(union Trapped_Args *args);
-	extern u32 PROCWRAP_InvalidateMemory(union Trapped_Args *args);
+	extern u32 PROCWRAP_Attach(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_Ctrl(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_Detach(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_EnumNode_Info(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 PROCWRAP_EnumResources(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 PROCWRAP_GetState(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_GetTrace(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_Load(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_RegisterNotify(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 PROCWRAP_Start(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_ReserveMemory(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 PROCWRAP_UnReserveMemory(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 PROCWRAP_Map(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_UnMap(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_FlushMemory(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 PROCWRAP_Stop(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_InvalidateMemory(union Trapped_Args *args,
+			void *pr_ctxt);
 
 /* NODE wrapper functions */
-	extern u32 NODEWRAP_Allocate(union Trapped_Args *args);
-	extern u32 NODEWRAP_AllocMsgBuf(union Trapped_Args *args);
-	extern u32 NODEWRAP_ChangePriority(union Trapped_Args *args);
-	extern u32 NODEWRAP_Connect(union Trapped_Args *args);
-	extern u32 NODEWRAP_Create(union Trapped_Args *args);
-	extern u32 NODEWRAP_Delete(union Trapped_Args *args);
-	extern u32 NODEWRAP_FreeMsgBuf(union Trapped_Args *args);
-	extern u32 NODEWRAP_GetAttr(union Trapped_Args *args);
-	extern u32 NODEWRAP_GetMessage(union Trapped_Args *args);
-	extern u32 NODEWRAP_Pause(union Trapped_Args *args);
-	extern u32 NODEWRAP_PutMessage(union Trapped_Args *args);
-	extern u32 NODEWRAP_RegisterNotify(union Trapped_Args *args);
-	extern u32 NODEWRAP_Run(union Trapped_Args *args);
-	extern u32 NODEWRAP_Terminate(union Trapped_Args *args);
-	extern u32 NODEWRAP_GetUUIDProps(union Trapped_Args *args);
+	extern u32 NODEWRAP_Allocate(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 NODEWRAP_AllocMsgBuf(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 NODEWRAP_ChangePriority(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 NODEWRAP_Connect(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 NODEWRAP_Create(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 NODEWRAP_Delete(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 NODEWRAP_FreeMsgBuf(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 NODEWRAP_GetAttr(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 NODEWRAP_GetMessage(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 NODEWRAP_Pause(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 NODEWRAP_PutMessage(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 NODEWRAP_RegisterNotify(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 NODEWRAP_Run(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 NODEWRAP_Terminate(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 NODEWRAP_GetUUIDProps(union Trapped_Args *args,
+			void *pr_ctxt);
 
 /* STRM wrapper functions */
-	extern u32 STRMWRAP_AllocateBuffer(union Trapped_Args *args);
-	extern u32 STRMWRAP_Close(union Trapped_Args *args);
-	extern u32 STRMWRAP_FreeBuffer(union Trapped_Args *args);
-	extern u32 STRMWRAP_GetEventHandle(union Trapped_Args *args);
-	extern u32 STRMWRAP_GetInfo(union Trapped_Args *args);
-	extern u32 STRMWRAP_Idle(union Trapped_Args *args);
-	extern u32 STRMWRAP_Issue(union Trapped_Args *args);
-	extern u32 STRMWRAP_Open(union Trapped_Args *args);
-	extern u32 STRMWRAP_Reclaim(union Trapped_Args *args);
-	extern u32 STRMWRAP_RegisterNotify(union Trapped_Args *args);
-	extern u32 STRMWRAP_Select(union Trapped_Args *args);
-
-	extern u32 CMMWRAP_CallocBuf(union Trapped_Args *args);
-	extern u32 CMMWRAP_FreeBuf(union Trapped_Args *args);
-	extern u32 CMMWRAP_GetHandle(union Trapped_Args *args);
-	extern u32 CMMWRAP_GetInfo(union Trapped_Args *args);
+	extern u32 STRMWRAP_AllocateBuffer(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 STRMWRAP_Close(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 STRMWRAP_FreeBuffer(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 STRMWRAP_GetEventHandle(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 STRMWRAP_GetInfo(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 STRMWRAP_Idle(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 STRMWRAP_Issue(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 STRMWRAP_Open(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 STRMWRAP_Reclaim(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 STRMWRAP_RegisterNotify(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 STRMWRAP_Select(union Trapped_Args *args, void *pr_ctxt);
+
+	extern u32 CMMWRAP_CallocBuf(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 CMMWRAP_FreeBuf(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 CMMWRAP_GetHandle(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 CMMWRAP_GetInfo(union Trapped_Args *args, void *pr_ctxt);
 
 #endif				/* _WCD_ */
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/dmm.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/dmm.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/dmm.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/dmm.h	2012-12-16 13:13:01.532330149 +0100
@@ -81,5 +81,4 @@
 
 	extern DSP_STATUS DMM_CreateTables(struct DMM_OBJECT *hDmmMgr,
 						u32 addr, u32 size);
-	extern u32 *DMM_GetPhysicalAddrTable(void);
 #endif				/* DMM_ */
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/drv.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/drv.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/drv.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/drv.h	2012-12-16 13:13:01.532330149 +0100
@@ -180,8 +180,9 @@ struct PROCESS_CONTEXT{
 	* (To maintain a linked list of process contexts) */
 	struct PROCESS_CONTEXT *next;
 
-	/* Processor info to which the process is related */
-	DSP_HPROCESSOR hProcessor;
+	/* List of Processors */
+	struct list_head processor_list;
+	spinlock_t proc_list_lock;
 
 	/* DSP Node resources */
 	struct NODE_RES_OBJECT *pNodeList;
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/dspdrv.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/dspdrv.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/dspdrv.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/dspdrv.h	2012-12-16 13:13:01.532330149 +0100
@@ -50,23 +50,6 @@
 #define MAX_DEV     10		/* Max support of 10 devices */
 
 /*
- *  ======== DSP_Close ========
- *  Purpose:
- *      Called when the client application/driver unloads the DDSP DLL. Upon
- *      unloading, the DDSP DLL will call CloseFile().
- *  Parameters:
- *      dwDeviceContext:    Handle returned by XXX_Open used to identify
- *                          the open context of the device
- *  Returns:
- *      TRUE indicates the device is successfully closed. FALSE indicates
- *      otherwise.
- *  Requires:
- *      dwOpenContext!= NULL.
- *  Ensures:The Application instance owned objects are cleaned up.
- */
-extern bool DSP_Close(u32 dwDeviceContext);
-
-/*
  *  ======== DSP_Deinit ========
  *  Purpose:
  *      This function is called by Device Manager to de-initialize a device.
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/gt.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/gt.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/gt.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/gt.h	2012-12-16 13:13:01.536330149 +0100
@@ -261,13 +261,15 @@ extern struct GT_Config _GT_params;
 
 #define GT_query(mask, class)     false
 
-#define GT_0trace(mask, class, format)
-#define GT_1trace(mask, class, format, arg1)
-#define GT_2trace(mask, class, format, arg1, arg2)
-#define GT_3trace(mask, class, format, arg1, arg2, arg3)
-#define GT_4trace(mask, class, format, arg1, arg2, arg3, arg4)
-#define GT_5trace(mask, class, format, arg1, arg2, arg3, arg4, arg5)
-#define GT_6trace(mask, class, format, arg1, arg2, arg3, arg4, arg5, arg6)
+#define GT_0trace(mask, class, format) do {} while (0)
+#define GT_1trace(mask, class, format, arg1) do {} while (0)
+#define GT_2trace(mask, class, format, arg1, arg2) do {} while (0)
+#define GT_3trace(mask, class, format, arg1, arg2, arg3) do {} while (0)
+#define GT_4trace(mask, class, format, arg1, arg2, arg3, arg4) do {} while (0)
+#define GT_5trace(mask, class, format, arg1, arg2, arg3, arg4, arg5) \
+	do {} while (0)
+#define GT_6trace(mask, class, format, arg1, arg2, arg3, arg4, arg5, arg6) \
+	do {} while (0)
 
 #else				/* GT_TRACE == 1 */
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/host_os.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/host_os.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/host_os.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/host_os.h	2012-12-16 13:13:01.536330149 +0100
@@ -60,12 +60,6 @@
 #include <asm/cacheflush.h>
 #include <linux/dma-mapping.h>
 
-/*  ----------------------------------- Macros */
-
-#define SEEK_SET        0	/* Seek from beginning of file.  */
-#define SEEK_CUR        1	/* Seek from current position.  */
-#define SEEK_END        2	/* Seek from end of file.  */
-
 /* TODO -- Remove, once BP defines them */
 #define INT_MAIL_MPU_IRQ        26
 #define INT_DSP_MMU_IRQ        28
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/mem.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/mem.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/mem.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/mem.h	2012-12-16 13:13:01.536330149 +0100
@@ -203,6 +203,23 @@
 	extern void MEM_Free(IN void *pMemBuf);
 
 /*
+ *  ======== MEM_VFree ========
+ *  Purpose:
+ *      Free the given block of system memory in virtual space.
+ *  Parameters:
+ *      pMemBuf:    Pointer to memory allocated by MEM_Calloc/Alloc()
+ *		    using vmalloc.
+ *  Returns:
+ *  Requires:
+ *      MEM initialized.
+ *      pMemBuf is a valid memory address returned by MEM_Calloc/Alloc()
+ *	using vmalloc.
+ *  Ensures:
+ *      pMemBuf is no longer a valid pointer to memory.
+ */
+	extern void MEM_VFree(IN void *pMemBuf);
+
+/*
  *  ======== MEM_FreePhysMem ========
  *  Purpose:
  *      Free the given block of physically contiguous memory.
@@ -317,7 +334,7 @@
  *  Ensures:
  *      - pBaseAddr no longer points to a valid linear address.
  */
-#define MEM_UnmapLinearAddress(pBaseAddr)
+#define MEM_UnmapLinearAddress(pBaseAddr) {}
 
 /*
  *  ======== MEM_ExtPhysPoolInit ========
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/node.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/node.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/node.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/node.h	2012-12-16 13:13:01.536330149 +0100
@@ -68,6 +68,7 @@
 #include <dspbridge/nodedefs.h>
 #include <dspbridge/dispdefs.h>
 #include <dspbridge/nldrdefs.h>
+#include <dspbridge/drv.h>
 
 /*
  *  ======== NODE_Allocate ========
@@ -104,7 +105,8 @@
 					*pArgs,
 					OPTIONAL IN CONST struct DSP_NODEATTRIN
 					*pAttrIn,
-					OUT struct NODE_OBJECT **phNode);
+					OUT struct NODE_OBJECT **phNode,
+					struct PROCESS_CONTEXT *pr_ctxt);
 
 /*
  *  ======== NODE_AllocMsgBuf ========
@@ -307,7 +309,8 @@
  *  Ensures:
  *      DSP_SOK:            hNode is invalid.
  */
-	extern DSP_STATUS NODE_Delete(struct NODE_OBJECT *hNode);
+	extern DSP_STATUS NODE_Delete(struct NODE_OBJECT *hNode,
+			struct PROCESS_CONTEXT *pr_ctxt);
 
 /*
  *  ======== NODE_DeleteMgr ========
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/proc.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/proc.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/proc.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/proc.h	2012-12-16 13:13:01.540330149 +0100
@@ -64,6 +64,30 @@
 
 #include <dspbridge/cfgdefs.h>
 #include <dspbridge/devdefs.h>
+#include <dspbridge/drv.h>
+
+/* The PROC_OBJECT structure.   */
+struct PROC_OBJECT {
+	struct LST_ELEM link;		/* Link to next PROC_OBJECT */
+	u32 dwSignature;		/* Used for object validation */
+	struct DEV_OBJECT *hDevObject;	/* Device this PROC represents */
+	u32 hProcess;			/* Process owning this Processor */
+	struct MGR_OBJECT *hMgrObject;	/* Manager Object Handle */
+	u32 uAttachCount;		/* Processor attach count */
+	u32 uProcessor;			/* Processor number */
+	u32 uTimeout;			/* Time out count */
+	enum DSP_PROCSTATE sState;	/* Processor state */
+	u32 ulUnit;			/* DDSP unit number */
+	bool bIsAlreadyAttached;	/*
+					 * True if the Device below has
+					 * GPP Client attached
+					 */
+	struct NTFY_OBJECT *hNtfy;	/* Manages  notifications */
+	struct WMD_DEV_CONTEXT *hWmdContext;	/* WMD Context Handle */
+	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
+	char *g_pszLastCoff;
+	struct list_head proc_object;
+};
 
 /*
  *  ======== PROC_Attach ========
@@ -94,7 +118,8 @@
 	extern DSP_STATUS PROC_Attach(u32 uProcessor,
 				      OPTIONAL CONST struct DSP_PROCESSORATTRIN
 				      *pAttrIn,
-				      OUT DSP_HPROCESSOR *phProcessor);
+				      OUT DSP_HPROCESSOR *phProcessor,
+				      struct PROCESS_CONTEXT *pr_ctxt);
 
 /*
  *  ======== PROC_AutoStart =========
@@ -161,7 +186,8 @@
  *  Ensures:
  *      PROC Object is destroyed.
  */
-	extern DSP_STATUS PROC_Detach(DSP_HPROCESSOR hProcessor);
+	extern DSP_STATUS PROC_Detach(DSP_HPROCESSOR hProcessor,
+			struct PROCESS_CONTEXT *pr_ctxt);
 
 /*
  *  ======== PROC_EnumNodes ========
@@ -578,7 +604,8 @@
 				   void *pMpuAddr,
 				   u32 ulSize,
 				   void *pReqAddr,
-				   void **ppMapAddr, u32 ulMapAttr);
+				   void **ppMapAddr, u32 ulMapAttr,
+				   struct PROCESS_CONTEXT *pr_ctxt);
 
 /*
  *  ======== PROC_ReserveMemory ========
@@ -621,7 +648,8 @@
  *  Ensures:
  *  Details:
  */
-	extern DSP_STATUS PROC_UnMap(DSP_HPROCESSOR hProcessor, void *pMapAddr);
+	extern DSP_STATUS PROC_UnMap(DSP_HPROCESSOR hProcessor, void *pMapAddr,
+			struct PROCESS_CONTEXT *pr_ctxt);
 
 /*
  *  ======== PROC_UnReserveMemory ========
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h	2012-12-16 13:13:01.540330149 +0100
@@ -35,15 +35,10 @@ extern DSP_STATUS DRV_ProcUpdatestate(HA
 
 extern DSP_STATUS DRV_ProcSetPID(HANDLE pCtxt, s32 hProcess);
 
-extern DSP_STATUS DRV_GetProcContext(u32 phProcess,
-				struct DRV_OBJECT *hDrvObject,
-				HANDLE hPCtxt, DSP_HNODE hNode,
-				u32 pMapAddr);
-
 extern DSP_STATUS DRV_RemoveAllResources(HANDLE pPctxt);
 
 extern DSP_STATUS DRV_RemoveProcContext(struct DRV_OBJECT *hDRVObject,
-				     HANDLE hPCtxt, HANDLE hProcess);
+				     HANDLE hPCtxt);
 
 extern DSP_STATUS DRV_GetNodeResElement(HANDLE hNode, HANDLE nodeRes,
 					HANDLE pCtxt);
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/strm.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/strm.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/strm.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/strm.h	2012-12-16 13:13:01.540330149 +0100
@@ -59,6 +59,7 @@
 #include <dspbridge/dev.h>
 
 #include <dspbridge/strmdefs.h>
+#include <dspbridge/proc.h>
 
 /*
  *  ======== STRM_AllocateBuffer ========
@@ -83,7 +84,8 @@
 	extern DSP_STATUS STRM_AllocateBuffer(struct STRM_OBJECT *hStrm,
 					      u32 uSize,
 					      OUT u8 **apBuffer,
-					      u32 uNumBufs);
+					      u32 uNumBufs,
+					      struct PROCESS_CONTEXT *pr_ctxt);
 
 /*
  *  ======== STRM_Close ========
@@ -101,7 +103,8 @@
  *      STRM_Init(void) called.
  *  Ensures:
  */
-	extern DSP_STATUS STRM_Close(struct STRM_OBJECT *hStrm);
+	extern DSP_STATUS STRM_Close(struct STRM_OBJECT *hStrm,
+			struct PROCESS_CONTEXT *pr_ctxt);
 
 /*
  *  ======== STRM_Create ========
@@ -172,7 +175,8 @@
  *  Ensures:
  */
 	extern DSP_STATUS STRM_FreeBuffer(struct STRM_OBJECT *hStrm,
-					  u8 **apBuffer, u32 uNumBufs);
+					  u8 **apBuffer, u32 uNumBufs,
+					  struct PROCESS_CONTEXT *pr_ctxt);
 
 /*
  *  ======== STRM_GetEventHandle ========
@@ -307,7 +311,8 @@
  */
 	extern DSP_STATUS STRM_Open(struct NODE_OBJECT *hNode, u32 uDir,
 				    u32 uIndex, IN struct STRM_ATTR *pAttr,
-				    OUT struct STRM_OBJECT **phStrm);
+				    OUT struct STRM_OBJECT **phStrm,
+				    struct PROCESS_CONTEXT *pr_ctxt);
 
 /*
  *  ======== STRM_PrepareBuffer ========
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/wmddeh.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/wmddeh.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/dspbridge/wmddeh.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/dspbridge/wmddeh.h	2012-12-16 13:13:01.540330149 +0100
@@ -61,4 +61,6 @@
 
 	extern void WMD_DEH_Notify(struct DEH_MGR *hDehMgr,
 				   u32 ulEventMask, u32 dwErrInfo);
+
+	extern void WMD_DEH_ReleaseDummyMem(void);
 #endif				/* WMDDEH_ */
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/display.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/display.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/display.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/display.h	2012-12-16 13:13:01.540330149 +0100
@@ -78,6 +78,17 @@ enum omap_color_mode {
 	OMAP_DSS_COLOR_RGBA32	= 1 << 12, /* RGBA32 */
 	OMAP_DSS_COLOR_RGBX32	= 1 << 13, /* RGBx32 */
 
+	OMAP_DSS_COLOR_GFX_OMAP2 =
+		OMAP_DSS_COLOR_CLUT1 | OMAP_DSS_COLOR_CLUT2 |
+		OMAP_DSS_COLOR_CLUT4 | OMAP_DSS_COLOR_CLUT8 |
+		OMAP_DSS_COLOR_RGB12U | OMAP_DSS_COLOR_RGB16 |
+		OMAP_DSS_COLOR_RGB24U | OMAP_DSS_COLOR_RGB24P,
+
+	OMAP_DSS_COLOR_VID_OMAP2 =
+		OMAP_DSS_COLOR_RGB16 | OMAP_DSS_COLOR_RGB24U |
+		OMAP_DSS_COLOR_RGB24P | OMAP_DSS_COLOR_YUV2 |
+		OMAP_DSS_COLOR_UYVY,
+
 	OMAP_DSS_COLOR_GFX_OMAP3 =
 		OMAP_DSS_COLOR_CLUT1 | OMAP_DSS_COLOR_CLUT2 |
 		OMAP_DSS_COLOR_CLUT4 | OMAP_DSS_COLOR_CLUT8 |
@@ -86,12 +97,17 @@ enum omap_color_mode {
 		OMAP_DSS_COLOR_RGB24P | OMAP_DSS_COLOR_ARGB32 |
 		OMAP_DSS_COLOR_RGBA32 | OMAP_DSS_COLOR_RGBX32,
 
-	OMAP_DSS_COLOR_VID_OMAP3 =
+	OMAP_DSS_COLOR_VID1_OMAP3 =
+		OMAP_DSS_COLOR_RGB12U | OMAP_DSS_COLOR_RGB16 |
+		OMAP_DSS_COLOR_RGB24U | OMAP_DSS_COLOR_RGB24P |
+		OMAP_DSS_COLOR_YUV2 | OMAP_DSS_COLOR_UYVY,
+
+	OMAP_DSS_COLOR_VID2_OMAP3 =
 		OMAP_DSS_COLOR_RGB12U | OMAP_DSS_COLOR_ARGB16 |
 		OMAP_DSS_COLOR_RGB16 | OMAP_DSS_COLOR_RGB24U |
-		OMAP_DSS_COLOR_RGB24P | OMAP_DSS_COLOR_ARGB32 |
-		OMAP_DSS_COLOR_RGBA32 | OMAP_DSS_COLOR_RGBX32 |
-		OMAP_DSS_COLOR_YUV2 | OMAP_DSS_COLOR_UYVY,
+		OMAP_DSS_COLOR_RGB24P | OMAP_DSS_COLOR_YUV2 |
+		OMAP_DSS_COLOR_UYVY | OMAP_DSS_COLOR_ARGB32 |
+		OMAP_DSS_COLOR_RGBA32 | OMAP_DSS_COLOR_RGBX32,
 };
 
 enum omap_lcd_display_type {
@@ -191,6 +207,8 @@ struct omap_dss_display_config {
 
 		struct {
 			u8 datapairs;
+			unsigned pad_off_pe : 1; /* pull pads if disabled */
+			unsigned pad_off_pu : 1; /* pull up */
 		} sdi;
 
 		struct {
@@ -200,7 +218,11 @@ struct omap_dss_display_config {
 			u8 data1_pol;
 			u8 data2_lane;
 			u8 data2_pol;
+			unsigned long lp_clk_hz;
 			unsigned long ddr_clk_hz;
+
+			bool ext_te;
+			u8 ext_te_gpio;
 		} dsi;
 
 		struct {
@@ -234,9 +256,14 @@ struct device;
 
 /* Board specific data */
 struct  omap_dss_board_info {
-	unsigned (*get_last_off_on_transaction_id)(struct device *dev);
+	int (*get_last_off_on_transaction_id)(struct device *dev);
+	void (*set_min_bus_tput)(struct device *dev, u8 agent_id, unsigned long r);
 	int (*dsi_power_up)(void);
 	void (*dsi_power_down)(void);
+	struct {
+		u16 low;
+		u16 high;
+	} fifo_thresholds[3];
 	int num_displays;
 	struct omap_dss_display_config *displays[];
 };
@@ -256,6 +283,7 @@ struct omap_ctrl {
 			     u16 x, u16 y, u16 w, u16 h);
 
 	int (*enable_te)(struct omap_display *display, bool enable);
+	int (*wait_for_te)(struct omap_display *display);
 
 	u8 (*get_rotate)(struct omap_display *display);
 	int (*set_rotate)(struct omap_display *display, u8 rotate);
@@ -341,6 +369,19 @@ enum omap_dss_overlay_managers {
 
 struct omap_overlay_manager;
 
+enum omap_dss_rotation_type {
+	OMAP_DSS_ROT_DMA = 0,
+	OMAP_DSS_ROT_VRFB = 1,
+};
+
+/* clockwise rotation angle */
+enum omap_dss_rotation_angle {
+	OMAP_DSS_ROT_0   = 0,
+	OMAP_DSS_ROT_90  = 1,
+	OMAP_DSS_ROT_180 = 2,
+	OMAP_DSS_ROT_270 = 3,
+};
+
 struct omap_overlay_info {
 	bool enabled;
 
@@ -351,12 +392,16 @@ struct omap_overlay_info {
 	u16 height;
 	enum omap_color_mode color_mode;
 	u8 rotation;
+	enum omap_dss_rotation_type rotation_type;
 	bool mirror;
 
 	u16 pos_x;
 	u16 pos_y;
 	u16 out_width;	/* if 0, out_width == width */
 	u16 out_height;	/* if 0, out_height == height */
+	u8 global_alpha;
+	u16 fifo_threshold_low;
+	u16 fifo_threshold_high;
 };
 
 enum omap_overlay_caps {
@@ -408,11 +453,19 @@ struct omap_overlay_manager {
 	int (*apply)(struct omap_overlay_manager *mgr);
 
 	void (*set_default_color)(struct omap_overlay_manager *mgr, u32 color);
-	void (*set_trans_key)(struct omap_overlay_manager *mgr,
+	u32 (*get_default_color)(struct omap_overlay_manager *mgr);
+	bool (*get_alpha_blending_status)(struct omap_overlay_manager *mgr);
+	bool (*get_trans_key_status)(struct omap_overlay_manager *mgr);
+	void (*get_trans_key_type_and_value)(struct omap_overlay_manager *mgr,
+		enum omap_dss_color_key_type *type,
+		u32 *trans_key);
+	void (*set_trans_key_type_and_value)(struct omap_overlay_manager *mgr,
 		enum omap_dss_color_key_type type,
 		u32 trans_key);
 	void (*enable_trans_key)(struct omap_overlay_manager *mgr,
 		bool enable);
+	void (*enable_alpha_blending)(struct omap_overlay_manager *mgr,
+			bool enable);
 };
 
 enum omap_display_caps {
@@ -426,7 +479,8 @@ enum omap_dss_update_mode {
 };
 
 enum omap_dss_display_state {
-	OMAP_DSS_DISPLAY_DISABLED = 0,
+	OMAP_DSS_DISPLAY_UNINITIALIZED = 0,
+	OMAP_DSS_DISPLAY_DISABLED,
 	OMAP_DSS_DISPLAY_ACTIVE,
 	OMAP_DSS_DISPLAY_SUSPENDED,
 };
@@ -494,6 +548,9 @@ struct omap_display {
 			u16 x, u16 y, u16 w, u16 h);
 
 	void (*configure_overlay)(struct omap_overlay *overlay);
+
+	int (*set_wss)(struct omap_display *display, u32 wss);
+	u32 (*get_wss)(struct omap_display *display);
 };
 
 int omap_dss_get_num_displays(void);
@@ -522,4 +579,10 @@ int omap_dispc_wait_for_irq_timeout(u32
 int omap_dispc_wait_for_irq_interruptible_timeout(u32 irqmask,
 		unsigned long timeout);
 
+void omap_dss_maximize_min_bus_tput(void);
+void omap_dss_update_min_bus_tput(void);
+
+void omap_dss_lock(void);
+void omap_dss_unlock(void);
+
 #endif
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/dma.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/dma.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/dma.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/dma.h	2012-12-16 13:13:01.544330149 +0100
@@ -144,6 +144,7 @@
 #define OMAP_DMA4_CSSA_U(n)		0
 #define OMAP_DMA4_CDSA_L(n)		0
 #define OMAP_DMA4_CDSA_U(n)		0
+#define OMAP1_DMA_COLOR(n)		0
 
 /*----------------------------------------------------------------------------*/
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/dss_boottime.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/dss_boottime.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/dss_boottime.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/dss_boottime.h	2012-12-16 13:13:01.544330149 +0100
@@ -7,6 +7,7 @@ int	dss_boottime_enable_clocks(void);
 void	dss_boottime_disable_clocks(void);
 u32	dss_boottime_get_plane_base(int pidx);
 enum omapfb_color_format dss_boottime_get_plane_format(int pidx);
+int	dss_boottime_get_plane_bpp(int plane_idx);
 size_t	dss_boottime_get_plane_size(int pidx);
 int	dss_boottime_plane_is_enabled(int pdix);
 int	dss_boottime_reset(void);
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/gpio-switch.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/gpio-switch.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/gpio-switch.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/gpio-switch.h	2012-12-16 13:13:01.544330149 +0100
@@ -52,14 +52,8 @@ struct omap_gpio_switch {
 #ifdef CONFIG_OMAP_GPIO_SWITCH
 extern void omap_register_gpio_switches(const struct omap_gpio_switch *tbl,
 					int count);
-extern int omap_update_gpio_switch(const struct omap_gpio_switch *cfg);
 #else
 #define omap_register_gpio_switches(tbl, count)	do { } while (0)
-static inline int omap_update_gpio_switch(const struct omap_gpio_switch *cfg)
-{
-	return 0;
-}
-
 #endif
 
 #endif
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/io.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/io.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/io.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/io.h	2012-12-16 13:13:01.544330149 +0100
@@ -194,7 +194,8 @@ extern void omap1_map_common_io(void);
 extern void omap1_init_common_hw(void);
 
 extern void omap2_map_common_io(void);
-extern void omap2_init_common_hw(struct omap_sdrc_params *sp,
+extern void omap2_init_common_hw(struct omap_sdrc_params *sdrc_cs0,
+				 struct omap_sdrc_params *sdrc_cs1,
 				 struct omap_opp *mpu_opps,
 				 struct omap_opp *dsp_opps,
 				 struct omap_opp *l3_opps);
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/iommu.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/iommu.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/iommu.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/iommu.h	2012-12-16 13:13:01.544330149 +0100
@@ -135,13 +135,14 @@ struct iommu_platform_data {
  */
 extern u32 iommu_arch_version(void);
 
+extern void iotlb_cr_to_e(struct cr_regs *cr, struct iotlb_entry *e);
+extern u32 iotlb_cr_to_virt(struct cr_regs *cr);
+
 extern int load_iotlb_entry(struct iommu *obj, struct iotlb_entry *e);
 extern void flush_iotlb_page(struct iommu *obj, u32 da);
 extern void flush_iotlb_range(struct iommu *obj, u32 start, u32 end);
 extern void flush_iotlb_all(struct iommu *obj);
 
-ssize_t iotlb_dump_cr(struct iommu *obj, struct cr_regs *cr, char *buf);
-
 extern int iopgtable_store_entry(struct iommu *obj, struct iotlb_entry *e);
 extern size_t iopgtable_clear_entry(struct iommu *obj, u32 iova);
 
@@ -154,4 +155,10 @@ extern void iommu_restore_ctx(struct iom
 extern int install_iommu_arch(const struct iommu_functions *ops);
 extern void uninstall_iommu_arch(const struct iommu_functions *ops);
 
+extern int foreach_iommu_device(void *data,
+				int (*fn)(struct device *, void *));
+
+extern ssize_t iommu_dump_ctx(struct iommu *obj, char *buf);
+extern size_t dump_tlb_entries(struct iommu *obj, char *buf);
+
 #endif /* __MACH_IOMMU_H */
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/isp_user.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/isp_user.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/isp_user.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/isp_user.h	2012-12-16 13:13:01.544330149 +0100
@@ -157,41 +157,57 @@ struct isph3a_aewb_data {
 
 
 /* Histogram related structs */
+
 /* Flags for number of bins */
-#define BINS_32			0x0
-#define BINS_64			0x1
-#define BINS_128		0x2
-#define BINS_256		0x3
+#define HIST_BINS_32		0
+#define HIST_BINS_64		1
+#define HIST_BINS_128		2
+#define HIST_BINS_256		3
+#define HIST_MEM_SIZE_BINS(n)	((n)*16)
+
+#define HIST_MEM_SIZE		1024
+#define HIST_MIN_REGIONS	1
+#define HIST_MAX_REGIONS	4
+#define HIST_MAX_WB_GAIN	255
+#define HIST_MIN_WB_GAIN	0
+#define HIST_MAX_BIT_WIDTH	14
+#define HIST_MIN_BIT_WIDTH	8
+#define HIST_MAX_BUFF		5
+#define HIST_MAX_WG		4
+
+/* Source */
+#define HIST_SOURCE_CCDC	0
+#define HIST_SOURCE_MEM		1
+
+/* CFA pattern */
+#define HIST_CFA_BAYER		0
+#define HIST_CFA_FOVEONX3	1
 
 struct isp_hist_config {
-	__u8 hist_source;		/* CCDC or Memory */
+	__u8 enable;
+	__u8 source;		/* CCDC or memory */
 	__u8 input_bit_width;	/* Needed o know the size per pixel */
-	__u8 hist_frames;		/* Num of frames to be processed and
-				 * accumulated
-				 */
+	__u8 num_acc_frames;	/* Num of frames to be processed and accumulated
+				   for each generated histogram frame */
 	__u8 hist_h_v_info;	/* frame-input width and height if source is
-				 * memory
-				 */
-	__u16 hist_radd;		/* frame-input address in memory */
+				 * memory */
+	__u16 hist_radd;	/* frame-input address in memory */
 	__u16 hist_radd_off;	/* line-offset for frame-input */
 	__u16 hist_bins;	/* number of bins: 32, 64, 128, or 256 */
-	__u16 wb_gain_R;	/* White Balance Field-to-Pattern Assignments */
-	__u16 wb_gain_RG;	/* White Balance Field-to-Pattern Assignments */
-	__u16 wb_gain_B;	/* White Balance Field-to-Pattern Assignments */
-	__u16 wb_gain_BG;	/* White Balance Field-to-Pattern Assignments */
-	__u8 num_regions;		/* number of regions to be configured */
-	__u16 reg0_hor;		/* Region 0 size and position */
-	__u16 reg0_ver;		/* Region 0 size and position */
-	__u16 reg1_hor;		/* Region 1 size and position */
-	__u16 reg1_ver;		/* Region 1 size and position */
-	__u16 reg2_hor;		/* Region 2 size and position */
-	__u16 reg2_ver;		/* Region 2 size and position */
-	__u16 reg3_hor;		/* Region 3 size and position */
-	__u16 reg3_ver;		/* Region 3 size and position */
+	__u8 cfa;		/* BAYER or FOVEON X3 */
+	__u8 wg[HIST_MAX_WG];	/* White Balance Gain */
+	__u8 num_regions;	/* number of regions to be configured */
+	__u32 reg_hor[HIST_MAX_REGIONS];	/* Regions size and position */
+	__u32 reg_ver[HIST_MAX_REGIONS];	/* Regions size and position */
 };
 
 struct isp_hist_data {
 	__u32 *hist_statistics_buf;	/* Pointer to pass to user */
+	__u8 update;
+	__u16 frame_number;
+	__u16 curr_frame;
+	__u32 config_counter;
+	struct timeval ts;
 };
 
 /* Auto Focus related structs */
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/mcbsp.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/mcbsp.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/mcbsp.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/mcbsp.h	2012-12-16 13:13:01.544330149 +0100
@@ -300,6 +300,11 @@
 #define ST_COEFFWREN		0x0002
 #define ST_SIDETONEEN		0x0001
 
+/********************** McBSP DMA operating modes **************************/
+#define MCBSP_DMA_MODE_ELEMENT		0
+#define MCBSP_DMA_MODE_THRESHOLD	1
+#define MCBSP_DMA_MODE_FRAME		2
+
 /* we don't do multichannel for now */
 struct omap_mcbsp_reg_cfg {
 	u16 spcr2;
@@ -446,6 +451,7 @@ struct omap_mcbsp {
 
 #ifdef CONFIG_ARCH_OMAP34XX
 	struct omap_mcbsp_st_data *st_data;
+	int dma_op_mode;
 	u16 max_tx_thres;
 	u16 max_rx_thres;
 #endif
@@ -462,6 +468,7 @@ void omap_mcbsp_set_tx_threshold(unsigne
 void omap_mcbsp_set_rx_threshold(unsigned int id, u16 threshold);
 u16 omap_mcbsp_get_max_tx_threshold(unsigned int id);
 u16 omap_mcbsp_get_max_rx_threshold(unsigned int id);
+int omap_mcbsp_get_dma_op_mode(unsigned int id);
 #else
 static inline void omap_mcbsp_set_tx_threshold(unsigned int id, u16 threshold)
 { }
@@ -469,6 +476,7 @@ static inline void omap_mcbsp_set_rx_thr
 { }
 static inline u16 omap_mcbsp_get_max_tx_threshold(unsigned int id) { return 0; }
 static inline u16 omap_mcbsp_get_max_rx_threshold(unsigned int id) { return 0; }
+static inline int omap_mcbsp_get_dma_op_mode(unsigned int id) { return 0; }
 #endif
 int omap_mcbsp_request(unsigned int id);
 void omap_mcbsp_free(unsigned int id);
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/mmc.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/mmc.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/mmc.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/mmc.h	2012-12-16 13:13:01.544330149 +0100
@@ -57,6 +57,12 @@ struct omap_mmc_platform_data {
 	int (*suspend)(struct device *dev, int slot);
 	int (*resume)(struct device *dev, int slot);
 
+	/* Return context loss count due to PM states changing */
+	int (*get_context_loss_count)(struct device *dev);
+
+	/* set/drop DVFS/PM constraints */
+	void (*set_pm_constraints)(struct device *dev, int on);
+
 	u64 dma_mask;
 
 	struct omap_mmc_slot_data {
@@ -77,6 +83,13 @@ struct omap_mmc_platform_data {
 
 		/* use the internal clock */
 		unsigned internal_clock:1;
+
+		/* Try to sleep or power off when possible */
+		unsigned power_saving:1;
+
+		/* MMC host capabilities */
+		unsigned long caps;
+
 		s16 power_pin;
 
 		int switch_pin;			/* gpio (card detect) */
@@ -85,6 +98,8 @@ struct omap_mmc_platform_data {
 		int (* set_bus_mode)(struct device *dev, int slot, int bus_mode);
 		int (* set_power)(struct device *dev, int slot, int power_on, int vdd);
 		int (* get_ro)(struct device *dev, int slot);
+		int (*set_sleep)(struct device *dev, int slot, int sleep,
+				 int vdd, int cardsleep);
 
 		/* return MMC cover switch state, can be NULL if not supported.
 		 *
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/mux.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/mux.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/mux.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/mux.h	2012-12-16 13:13:01.544330149 +0100
@@ -795,7 +795,11 @@ enum omap34xx_index {
 	AF6_34XX_GPIO140_UP,
 	AE6_34XX_GPIO141,
 	AF5_34XX_GPIO142,
-	AE5_34XX_GPIO143
+	AE5_34XX_GPIO143,
+
+	/* OMAP3 SDRC CKE signals to SDR/DDR ram chips */
+	H16_34XX_SDRC_CKE0,
+	H17_34XX_SDRC_CKE1,
 };
 
 struct omap_mux_cfg {
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/omap-pm.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/omap-pm.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/omap-pm.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/omap-pm.h	2012-12-16 13:13:01.544330149 +0100
@@ -58,9 +58,15 @@ extern struct omap_opp *l3_opps;
  * framework starts.  The "_if_" is to avoid name collisions with the
  * PM idle-loop code.
  */
+#ifdef CONFIG_OMAP_PM_NONE
+static inline int __init omap_pm_if_early_init(struct omap_opp *mpu_opp_table,
+				 struct omap_opp *dsp_opp_table,
+				 struct omap_opp *l3_opp_table) { return 0; }
+#else
 int __init omap_pm_if_early_init(struct omap_opp *mpu_opp_table,
 				 struct omap_opp *dsp_opp_table,
 				 struct omap_opp *l3_opp_table);
+#endif
 
 /**
  * omap_pm_if_init - OMAP PM init code called after clock fw init
@@ -68,7 +74,11 @@ int __init omap_pm_if_early_init(struct
  * The main initialization code.  OPP tables are passed in here.  The
  * "_if_" is to avoid name collisions with the PM idle-loop code.
  */
+#ifdef CONFIG_OMAP_PM_NONE
+static inline int __init omap_pm_if_init(void) { return 0; }
+#else
 int __init omap_pm_if_init(void);
+#endif
 
 /**
  * omap_pm_if_exit - OMAP PM exit code
@@ -76,7 +86,11 @@ int __init omap_pm_if_init(void);
  * Exit code; currently unused.  The "_if_" is to avoid name
  * collisions with the PM idle-loop code.
  */
+#ifdef CONFIG_OMAP_PM_NONE
+static inline void omap_pm_if_exit(void) { }
+#else
 void omap_pm_if_exit(void);
+#endif
 
 /*
  * Device-driver-originated constraints (via board-*.c files, platform_data)
@@ -113,7 +127,11 @@ void omap_pm_if_exit(void);
  *
  * No return value.
  */
+#ifdef CONFIG_OMAP_PM_NONE
+static inline void omap_pm_set_max_mpu_wakeup_lat(struct device *dev, long t) { }
+#else
 void omap_pm_set_max_mpu_wakeup_lat(struct device *dev, long t);
+#endif
 
 
 /**
@@ -144,7 +162,31 @@ void omap_pm_set_max_mpu_wakeup_lat(stru
  *
  * No return value.
  */
+#ifdef CONFIG_OMAP_PM_NONE
+static inline void omap_pm_set_min_bus_tput(struct device *dev, u8 agent_id, unsigned long r) { }
+#else
 void omap_pm_set_min_bus_tput(struct device *dev, u8 agent_id, unsigned long r);
+#endif
+
+/**
+ * omap_pm_set_min_mpu_freq - set minimum MPU frequency needed by device
+ * @dev: struct device * requesting the constraint
+ * @r: minimum MPU frequency (in Hz)
+ *
+ * Request that the minimum MPU frequency be no less than 'r' Hz.
+ *
+ * Multiple calls to set_min_mpu_freq() will replace the previous rate value
+ * for this device. To remove the frequency restriction for this device,
+ * call with r = 0.
+ *
+ * No return value.
+ */
+#ifdef CONFIG_OMAP_PM_NONE
+static inline void omap_pm_set_min_mpu_freq(struct device *dev,
+		unsigned long r) { }
+#else
+void omap_pm_set_min_mpu_freq(struct device *dev, unsigned long r);
+#endif
 
 
 /**
@@ -171,7 +213,11 @@ void omap_pm_set_min_bus_tput(struct dev
  *
  * No return value.
  */
+#ifdef CONFIG_OMAP_PM_NONE
+static inline void omap_pm_set_max_dev_wakeup_lat(struct device *dev, long t) { }
+#else
 void omap_pm_set_max_dev_wakeup_lat(struct device *dev, long t);
+#endif
 
 
 /**
@@ -200,7 +246,11 @@ void omap_pm_set_max_dev_wakeup_lat(stru
  *
  * No return value.
  */
+#ifdef CONFIG_OMAP_PM_NONE
+static inline void omap_pm_set_max_sdma_lat(struct device *dev, long t) { }
+#else
 void omap_pm_set_max_sdma_lat(struct device *dev, long t);
+#endif
 
 
 /*
@@ -225,7 +275,11 @@ const struct omap_opp *omap_pm_dsp_get_o
  * information that code receives from the DSP/BIOS load estimator is the
  * target OPP ID; hence, this interface.  No return value.
  */
+#ifdef CONFIG_OMAP_PM_NONE
+static inline void omap_pm_dsp_set_min_opp(u8 opp_id) { }
+#else
 void omap_pm_dsp_set_min_opp(u8 opp_id);
+#endif
 
 /**
  * omap_pm_dsp_get_opp - report the current DSP OPP ID
@@ -237,7 +291,11 @@ void omap_pm_dsp_set_min_opp(u8 opp_id);
  *
  * Returns the current VDD1 OPP ID, or 0 upon error.
  */
+#ifdef CONFIG_OMAP_PM_NONE
+static inline u8 omap_pm_dsp_get_opp(void) { return 0; }
+#else
 u8 omap_pm_dsp_get_opp(void);
+#endif
 
 
 /*
@@ -265,14 +323,22 @@ struct cpufreq_frequency_table **omap_pm
  * Intended to be called by plat-omap/cpu_omap.c:omap_target().  No
  * return value.
  */
+#ifdef CONFIG_OMAP_PM_NONE
+static inline void omap_pm_cpu_set_freq(unsigned long f) { }
+#else
 void omap_pm_cpu_set_freq(unsigned long f);
+#endif
 
 /**
  * omap_pm_cpu_get_freq - report the current CPU frequency
  *
  * Returns the current MPU frequency, or 0 upon error.
  */
+#ifdef CONFIG_OMAP_PM_NONE
+static inline unsigned long omap_pm_cpu_get_freq(void) { return 0; }
+#else
 unsigned long omap_pm_cpu_get_freq(void);
+#endif
 
 
 /*
@@ -295,7 +361,11 @@ unsigned long omap_pm_cpu_get_freq(void)
  * continue counting.  Returns the number of context losses for this device,
  * or -EINVAL upon error.
  */
+#ifdef CONFIG_OMAP_PM_NONE
+static inline int omap_pm_get_dev_context_loss_count(struct device *dev) { return 0; }
+#else
 int omap_pm_get_dev_context_loss_count(struct device *dev);
+#endif
 
 
 /*
@@ -311,7 +381,11 @@ int omap_pm_get_dev_context_loss_count(s
  * function is intended to be called by the clockdomain code, not by drivers.
  * No return value.
  */
+#ifdef CONFIG_OMAP_PM_NONE
+static inline void omap_pm_pwrdm_active(struct powerdomain *pwrdm) { }
+#else
 void omap_pm_pwrdm_active(struct powerdomain *pwrdm);
+#endif
 
 
 /**
@@ -323,6 +397,10 @@ void omap_pm_pwrdm_active(struct powerdo
  * clock.  This function is intended to be called by the clockdomain
  * code, not by drivers.  No return value.
  */
+#ifdef CONFIG_OMAP_PM_NONE
+static inline void omap_pm_pwrdm_inactive(struct powerdomain *pwrdm) { }
+#else
 void omap_pm_pwrdm_inactive(struct powerdomain *pwrdm);
+#endif
 
 #endif
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/pm.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/pm.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/pm.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/pm.h	2012-12-16 13:13:01.544330149 +0100
@@ -136,14 +136,16 @@ void clk_allow_idle(struct clk *clk);
 extern void omap_pm_idle(void);
 extern void omap_pm_suspend(void);
 extern void omap_sram_idle(void);
+extern int pm_check_idle(void);
 #ifdef CONFIG_PM
 extern void omap2_block_sleep(void);
 extern void omap2_allow_sleep(void);
+int get_last_off_on_transaction_id(struct device *dev);
 #else
 static inline void omap2_block_sleep(void) { }
 static inline void omap2_allow_sleep(void) { }
+static inline int get_last_off_on_transaction_id(struct device *dev) { return 0; }
 #endif
-unsigned get_last_off_on_transaction_id(struct device *dev);
 extern int omap3_can_sleep(void);
 extern void omap730_cpu_suspend(unsigned short, unsigned short);
 extern void omap1510_cpu_suspend(unsigned short, unsigned short);
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/resource.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/resource.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/resource.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/resource.h	2012-12-16 13:13:01.544330149 +0100
@@ -76,6 +76,9 @@ int resource_unregister(struct shared_re
 int resource_request(const char *name, struct device *dev,
 						 unsigned long level);
 int resource_release(const char *name, struct device *dev);
+int resource_request_locked(const char *name, struct device *dev,
+						unsigned long level);
+int resource_release_locked(const char *name, struct device *dev);
 int resource_get_level(const char *name);
 
 #endif /* __ARCH_ARM_OMAP_RESOURCE_H */
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/sdrc.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/sdrc.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/sdrc.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/sdrc.h	2012-12-16 13:13:01.544330149 +0100
@@ -74,6 +74,12 @@
 #define SDRC_RFR_CTRL_110MHz	(0x0002da01 | 1) /* Need to calc */
 #define SDRC_RFR_CTRL_BYPASS	(0x00005000 | 1) /* Need to calc */
 
+/* SDRC POWER regbits */
+#define SDRC_POWER_AUTOCOUNT_SHIFT 8
+#define SDRC_POWER_AUTOCOUNT_MASK (0xffff << SDRC_POWER_AUTOCOUNT_SHIFT)
+#define SDRC_POWER_CLKCTRL_SHIFT 4
+#define SDRC_POWER_CLKCTRL_MASK (0x3 << SDRC_POWER_CLKCTRL_SHIFT)
+#define SDRC_SELF_REFRESH_ON_AUTOCOUNT (0x2 << SDRC_POWER_CLKCTRL_SHIFT)
 
 /*
  * SMS register access
@@ -112,9 +118,13 @@ struct omap_sdrc_params {
 	u32 mr;
 };
 
-void __init omap2_sdrc_init(struct omap_sdrc_params *);
-struct omap_sdrc_params *omap2_sdrc_get_params(unsigned long r);
-
+void omap2_sms_save_context(void);
+void omap2_sms_restore_context(void);
+void __init omap2_sdrc_init(struct omap_sdrc_params *sdrc_cs0,
+			    struct omap_sdrc_params *sdrc_cs1);
+int omap2_sdrc_get_params(unsigned long r,
+			  struct omap_sdrc_params **sdrc_cs0,
+			  struct omap_sdrc_params **sdrc_cs1);
 #ifdef CONFIG_ARCH_OMAP2
 
 struct memory_timings {
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/sram.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/sram.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/sram.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/sram.h	2012-12-16 13:13:01.544330149 +0100
@@ -21,11 +21,11 @@ extern void omap2_sram_reprogram_sdrc(u3
 				      u32 mem_type);
 extern u32 omap2_set_prcm(u32 dpll_ctrl_val, u32 sdrc_rfr_val, int bypass);
 
-extern u32 omap3_configure_core_dpll(u32 sdrc_rfr_ctrl,
-				     u32 sdrc_actim_ctrla,
-				     u32 sdrc_actim_ctrlb, u32 m2,
-				     u32 unlock_dll, u32 f, u32 sdrc_mr,
-				     u32 inc);
+extern u32 omap3_configure_core_dpll(
+			u32 m2, u32 unlock_dll, u32 f, u32 inc,
+			u32 sdrc_rfr_ctrl_0, u32 sdrc_mr_0,
+			u32 sdrc_rfr_ctrl_1, u32 sdrc_mr_1);
+
 extern void omap3_sram_restore_context(void);
 
 /* Do not use these */
@@ -61,11 +61,12 @@ extern void omap243x_sram_reprogram_sdrc
 extern unsigned long omap243x_sram_reprogram_sdrc_sz;
 
 
-extern u32 omap3_sram_configure_core_dpll(u32 sdrc_rfr_ctrl,
-					  u32 sdrc_actim_ctrla,
-					  u32 sdrc_actim_ctrlb, u32 m2,
-					  u32 unlock_dll, u32 f, u32 sdrc_mr,
-					  u32 inc);
+extern u32 omap3_sram_configure_core_dpll(
+			u32 m2, u32 unlock_dll, u32 f, u32 inc,
+			u32 sdrc_rfr_ctrl_0, u32 sdrc_actim_ctrl_a_0,
+			u32 sdrc_actim_ctrl_b_0, u32 sdrc_mr_0,
+			u32 sdrc_rfr_ctrl_1, u32 sdrc_actim_ctrl_a_1,
+			u32 sdrc_actim_ctrl_b_1, u32 sdrc_mr_1);
 extern unsigned long omap3_sram_configure_core_dpll_sz;
 
 #ifdef CONFIG_PM
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/ssi.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/ssi.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/ssi.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/ssi.h	2012-12-16 13:13:01.544330149 +0100
@@ -39,7 +39,7 @@
  *	port 2: 0x4805b000
  */
 #define SSI_SST_OFFSET			0x2000
-#define SSI_SST_BASE(port)		(SSI_SST_OFFSET + ((port - 1) *\
+#define SSI_SST_BASE(port)		(SSI_SST_OFFSET + (((port) - 1) *\
 							(SSI_PORT_OFFSET)))
 /*
  * SSR base addr:
@@ -47,7 +47,7 @@
  *	port 2: 0x4805b800
  */
 #define SSI_SSR_OFFSET			0x2800
-#define SSI_SSR_BASE(port)		(SSI_SSR_OFFSET + ((port - 1) *\
+#define SSI_SSR_BASE(port)		(SSI_SSR_OFFSET + (((port) - 1) *\
 							(SSI_PORT_OFFSET)))
 /*
  * SSI SYS registers
@@ -78,8 +78,8 @@
 
 #define SSI_SYS_MPU_STATUS_REG(port, irq) \
 			(SSI_SYS_MPU_STATUS_BASE +\
-			(((port - 1) * SSI_SYS_MPU_STATUS_PORT_OFFSET) +\
-			(irq * SSI_SYS_MPU_STATUS_IRQ_OFFSET)))
+			((((port) - 1) * SSI_SYS_MPU_STATUS_PORT_OFFSET) +\
+			((irq) * SSI_SYS_MPU_STATUS_IRQ_OFFSET)))
 
 #define SSI_SYS_MPU_ENABLE_BASE		0X080c
 #define SSI_SYS_MPU_ENABLE_PORT_OFFSET	0x10
@@ -87,30 +87,30 @@
 
 #define SSI_SYS_MPU_ENABLE_REG(port, irq) \
 			(SSI_SYS_MPU_ENABLE_BASE +\
-			(((port - 1) * SSI_SYS_MPU_ENABLE_PORT_OFFSET) +\
-			(irq * SSI_SYS_MPU_ENABLE_IRQ_OFFSET)))
+			((((port) - 1) * SSI_SYS_MPU_ENABLE_PORT_OFFSET) +\
+			((irq) * SSI_SYS_MPU_ENABLE_IRQ_OFFSET)))
 
-#	define SSI_SST_DATAACCEPT(channel)	(1 << channel)
-#	define SSI_SSR_DATAAVAILABLE(channel)	(1 << (channel + 8))
-#	define SSI_SSR_DATAOVERRUN(channel)	(1 << (channel + 16))
+#	define SSI_SST_DATAACCEPT(channel)	(1 << (channel))
+#	define SSI_SSR_DATAAVAILABLE(channel)	(1 << ((channel) + 8))
+#	define SSI_SSR_DATAOVERRUN(channel)	(1 << ((channel) + 16))
 #	define SSI_ERROROCCURED			(1 << 24)
 #	define SSI_BREAKDETECTED		(1 << 25)
 
 #define SSI_SYS_GDD_MPU_IRQ_STATUS_REG	0x0800
 #define SSI_SYS_GDD_MPU_IRQ_ENABLE_REG	0x0804
-#	define SSI_GDD_LCH(channel)	(1 << channel)
+#	define SSI_GDD_LCH(channel)	(1 << (channel))
 
 #define SSI_SYS_WAKE_OFFSET		0x10
 #define SSI_SYS_WAKE_BASE		0x0c00
 #define SSI_SYS_WAKE_REG(port)		(SSI_SYS_WAKE_BASE +\
-					((port - 1) * SSI_SYS_WAKE_OFFSET))
+					(((port) - 1) * SSI_SYS_WAKE_OFFSET))
 #define SSI_SYS_CLEAR_WAKE_BASE		0x0c04
 #define SSI_SYS_CLEAR_WAKE_REG(port)	(SSI_SYS_CLEAR_WAKE_BASE +\
-					((port - 1) * SSI_SYS_WAKE_OFFSET))
+					(((port) - 1) * SSI_SYS_WAKE_OFFSET))
 #define SSI_SYS_SET_WAKE_BASE		0x0c08
 #define SSI_SYS_SET_WAKE_REG(port)	(SSI_SYS_SET_WAKE_BASE +\
-					((port - 1) * SSI_SYS_WAKE_OFFSET))
-#	define SSI_WAKE(channel)	(1 << channel)
+					(((port) - 1) * SSI_SYS_WAKE_OFFSET))
+#	define SSI_WAKE(channel)	(1 << (channel))
 #	define SSI_WAKE_MASK		0xff
 
 /*
@@ -128,7 +128,7 @@
 #define SSI_SST_TXSTATE_REG(port)		(SSI_SST_BASE(port) + 0X000c)
 #	define	TXSTATE_IDLE			0
 #define SSI_SST_BUFSTATE_REG(port)		(SSI_SST_BASE(port) + 0x0010)
-#	define	NOTFULL(channel)		(1 << channel)
+#	define	NOTFULL(channel)		(1 << (channel))
 #define SSI_SST_DIVISOR_REG(port)		(SSI_SST_BASE(port) + 0x0018)
 #	define SSI_DIVISOR_DEFAULT		1
 
@@ -142,11 +142,11 @@
 
 #define SSI_SST_BUFFER_BASE(port)		(SSI_SST_BASE(port) + 0x0080)
 #define SSI_SST_BUFFER_CH_REG(port, channel)	(SSI_SST_BUFFER_BASE(port) +\
-						(channel * 4))
+						((channel) * 4))
 
 #define SSI_SST_SWAPBUF_BASE(port)		(SSI_SST_BASE(port) + 0X00c0)
 #define SSI_SST_SWAPBUF_CH_REG(port, channel)	(SSI_SST_SWAPBUF_BASE(port) +\
-						(channel * 4))
+						((channel) * 4))
 /*
  * SSI SSR registers
  */
@@ -155,7 +155,7 @@
 #define SSI_SSR_FRAMESIZE_REG(port)		(SSI_SSR_BASE(port) + 0x0008)
 #define SSI_SSR_RXSTATE_REG(port)		(SSI_SSR_BASE(port) + 0x000c)
 #define SSI_SSR_BUFSTATE_REG(port)		(SSI_SSR_BASE(port) + 0x0010)
-#	define NOTEMPTY(channel)		(1 << channel)
+#	define NOTEMPTY(channel)		(1 << (channel))
 #define SSI_SSR_BREAK_REG(port)			(SSI_SSR_BASE(port) + 0x001c)
 #define SSI_SSR_ERROR_REG(port)			(SSI_SSR_BASE(port) + 0x0020)
 #define SSI_SSR_ERRORACK_REG(port)		(SSI_SSR_BASE(port) + 0x0024)
@@ -167,11 +167,11 @@
 
 #define SSI_SSR_BUFFER_BASE(port)		(SSI_SSR_BASE(port) + 0x0080)
 #define SSI_SSR_BUFFER_CH_REG(port, channel)	(SSI_SSR_BUFFER_BASE(port) +\
-						(channel * 4))
+						((channel) * 4))
 
 #define SSI_SSR_SWAPBUF_BASE(port)		(SSI_SSR_BASE(port) + 0x00c0)
 #define SSI_SSR_SWAPBUF_CH_REG(port, channel)	(SSI_SSR_SWAPBUF_BASE +\
-						(channel * 4))
+						((channel) * 4))
 /*
  * SSI GDD registers
  */
@@ -199,7 +199,7 @@
 #define SSI_GDD_CSDP_BASE		(SSI_GDD_BASE + 0x0800)
 #define SSI_GDD_CSDP_OFFSET		0x40
 #define SSI_GDD_CSDP_REG(channel)	(SSI_GDD_CSDP_BASE +\
-					(channel * SSI_GDD_CSDP_OFFSET))
+					((channel) * SSI_GDD_CSDP_OFFSET))
 #	define SSI_DST_BURST_EN_MASK	0xC000
 #	define SSI_DST_SINGLE_ACCESS0	0
 #	define SSI_DST_SINGLE_ACCESS	(1 << 14)
@@ -226,7 +226,7 @@
 #define SSI_GDD_CCR_BASE		(SSI_GDD_BASE + 0x0802)
 #define SSI_GDD_CCR_OFFSET		0x40
 #define SSI_GDD_CCR_REG(channel)	(SSI_GDD_CCR_BASE +\
-					(channel * SSI_GDD_CCR_OFFSET))
+					((channel) * SSI_GDD_CCR_OFFSET))
 #	define SSI_DST_AMODE_MASK	(3 << 14)
 #	define SSI_DST_AMODE_CONST	0
 #	define SSI_DST_AMODE_POSTINC	(1 << 12)
@@ -242,7 +242,7 @@
 #define SSI_GDD_CICR_BASE		(SSI_GDD_BASE + 0x0804)
 #define SSI_GDD_CICR_OFFSET		0x40
 #define SSI_GDD_CICR_REG(channel)	(SSI_GDD_CICR_BASE +\
-					(channel * SSI_GDD_CICR_OFFSET))
+					((channel) * SSI_GDD_CICR_OFFSET))
 #	define SSI_BLOCK_IE		(1 << 5)
 #	define SSI_HALF_IE		(1 << 2)
 #	define SSI_TOUT_IE		(1 << 0)
@@ -250,7 +250,7 @@
 #define SSI_GDD_CSR_BASE		(SSI_GDD_BASE + 0x0806)
 #define SSI_GDD_CSR_OFFSET		0x40
 #define SSI_GDD_CSR_REG(channel)	(SSI_GDD_CSR_BASE +\
-					(channel * SSI_GDD_CSR_OFFSET))
+					((channel) * SSI_GDD_CSR_OFFSET))
 #	define SSI_CSR_SYNC		(1 << 6)
 #	define SSI_CSR_BLOCK		(1 << 5)
 #	define SSI_CSR_HALF		(1 << 2)
@@ -259,32 +259,32 @@
 #define SSI_GDD_CSSA_BASE		(SSI_GDD_BASE + 0x0808)
 #define SSI_GDD_CSSA_OFFSET		0x40
 #define SSI_GDD_CSSA_REG(channel)	(SSI_GDD_CSSA_BASE +\
-					(channel * SSI_GDD_CSSA_OFFSET))
+					((channel) * SSI_GDD_CSSA_OFFSET))
 
 #define SSI_GDD_CDSA_BASE		(SSI_GDD_BASE + 0x080c)
 #define SSI_GDD_CDSA_OFFSET		0x40
 #define SSI_GDD_CDSA_REG(channel)	(SSI_GDD_CDSA_BASE +\
-					(channel * SSI_GDD_CDSA_OFFSET))
+					((channel) * SSI_GDD_CDSA_OFFSET))
 
 #define SSI_GDD_CEN_BASE		(SSI_GDD_BASE + 0x0810)
 #define SSI_GDD_CEN_OFFSET		0x40
 #define SSI_GDD_CEN_REG(channel)	(SSI_GDD_CEN_BASE +\
-					(channel * SSI_GDD_CEN_OFFSET))
+					((channel) * SSI_GDD_CEN_OFFSET))
 
 #define SSI_GDD_CSAC_BASE		(SSI_GDD_BASE + 0x0818)
 #define SSI_GDD_CSAC_OFFSET		0x40
 #define SSI_GDD_CSAC_REG(channel)	(SSI_GDD_CSAC_BASE +\
-					(channel * SSI_GDD_CSAC_OFFSET))
+					((channel) * SSI_GDD_CSAC_OFFSET))
 
 #define SSI_GDD_CDAC_BASE		(SSI_GDD_BASE + 0x081a)
 #define SSI_GDD_CDAC_OFFSET		0x40
 #define SSI_GDD_CDAC_REG(channel)	(SSI_GDD_CDAC_BASE +\
-					(channel * SSI_GDD_CDAC_OFFSET))
+					((channel) * SSI_GDD_CDAC_OFFSET))
 
 #define SSI_GDD_CLNK_CTRL_BASE		(SSI_GDD_BASE + 0x0828)
 #define SSI_GDD_CLNK_CTRL_OFFSET	0x40
 #define SSI_GDD_CLNK_CTRL_REG(channel)	(SSI_GDD_CLNK_CTRL_BASE +\
-					(channel * SSI_GDD_CLNK_CTRL_OFFSET))
+					((channel) * SSI_GDD_CLNK_CTRL_OFFSET))
 #	define SSI_ENABLE_LNK		(1 << 15)
 #	define SSI_STOP_LNK		(1 << 14)
 #	define NEXT_CH_ID_MASK		0xf
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/usb.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/usb.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/usb.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/usb.h	2012-12-16 13:13:01.544330149 +0100
@@ -27,7 +27,8 @@
 #define UDC_BASE			OMAP2_UDC_BASE
 #define OMAP_OHCI_BASE			OMAP2_OHCI_BASE
 
-void __init usb_musb_init(void);
+struct musb_board_data;
+void __init usb_musb_init(struct musb_board_data *);
 void __init usb_ehci_init(void);
 
 #endif
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/usb-musb.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/usb-musb.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/usb-musb.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/usb-musb.h	2012-12-16 13:13:01.544330149 +0100
@@ -29,7 +29,8 @@
 #ifndef __ASM_ARCH_OMAP_USB_MUSB_H
 #define __ASM_ARCH_OMAP_USB_MUSB_H
 
-extern void usb_musb_init(void);
+struct musb_board_data;
+extern void usb_musb_init(struct musb_board_data *);
 
 #endif /* __ASM_ARCH_OMAP_USB_MUSB_H */
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/vram.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/vram.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/vram.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/vram.h	2012-12-16 13:13:01.544330149 +0100
@@ -24,9 +24,12 @@
 
 #include <asm/types.h>
 
+extern int omap_vram_add_region(unsigned long paddr, size_t size);
 extern int omap_vram_free(unsigned long paddr, size_t size);
 extern int omap_vram_alloc(int mtype, size_t size, unsigned long *paddr);
 extern int omap_vram_reserve(unsigned long paddr, size_t size);
+extern void omap_vram_get_info(unsigned long *vram, unsigned long *free_vram,
+		unsigned long *largest_free_block);
 extern void omap2_set_sdram_vram(u32 size, u32 start);
 extern void omap2_set_sram_vram(u32 size, u32 start);
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/vrfb.h kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/vrfb.h
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/include/mach/vrfb.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/include/mach/vrfb.h	2012-12-16 13:13:01.544330149 +0100
@@ -24,6 +24,7 @@
 #ifndef __VRFB_H
 #define __VRFB_H
 
+#include <mach/display.h>
 #define OMAP_VRFB_LINE_LEN 2048
 
 struct vrfb
@@ -31,6 +32,8 @@ struct vrfb
 	u8 context;
 	void __iomem *vaddr[4];
 	unsigned long paddr[4];
+	u16 xres;
+	u16 yres;
 	u16 xoffset;
 	u16 yoffset;
 	u8 bytespp;
@@ -38,10 +41,16 @@ struct vrfb
 
 extern int omap_vrfb_request_ctx(struct vrfb *vrfb);
 extern void omap_vrfb_release_ctx(struct vrfb *vrfb);
+extern void omap_vrfb_suspend_ctx(struct vrfb *vrfb);
+extern void omap_vrfb_resume_ctx(struct vrfb *vrfb);
 extern void omap_vrfb_adjust_size(u16 *width, u16 *height,
 		u8 bytespp);
+extern u32 omap_vrfb_min_phys_size(u16 width, u16 height, u8 bytespp);
+extern u16 omap_vrfb_max_height(u32 phys_size, u16 width, u8 bytespp);
 extern void omap_vrfb_setup(struct vrfb *vrfb, unsigned long paddr,
 		u16 width, u16 height,
-		u8 bytespp);
+		enum omap_color_mode color_mode);
+extern int omap_vrfb_map_angle(struct vrfb *vrfb, u16 height, u8 rot);
+extern void omap_vrfb_restore_context(void);
 
 #endif /* __VRFB_H */
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/iommu.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/iommu.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/iommu.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/iommu.c	2012-12-16 13:13:01.544330149 +0100
@@ -33,7 +33,7 @@ static struct platform_driver omap_iommu
 static struct kmem_cache *iopte_cachep;
 
 /**
- * install_iommu_arch() - Install archtecure specific iommu functions
+ * install_iommu_arch - Install archtecure specific iommu functions
  * @ops:	a pointer to architecture specific iommu functions
  *
  * There are several kind of iommu algorithm(tlb, pagetable) among
@@ -50,7 +50,7 @@ int install_iommu_arch(const struct iomm
 EXPORT_SYMBOL_GPL(install_iommu_arch);
 
 /**
- * uninstall_iommu_arch() - Uninstall archtecure specific iommu functions
+ * uninstall_iommu_arch - Uninstall archtecure specific iommu functions
  * @ops:	a pointer to architecture specific iommu functions
  *
  * This interface uninstalls the iommu algorighm installed previously.
@@ -65,7 +65,7 @@ void uninstall_iommu_arch(const struct i
 EXPORT_SYMBOL_GPL(uninstall_iommu_arch);
 
 /**
- * iommu_save_ctx() - Save registers for pm off-mode support
+ * iommu_save_ctx - Save registers for pm off-mode support
  * @obj:	target iommu
  **/
 void iommu_save_ctx(struct iommu *obj)
@@ -75,7 +75,7 @@ void iommu_save_ctx(struct iommu *obj)
 EXPORT_SYMBOL_GPL(iommu_save_ctx);
 
 /**
- * iommu_restore_ctx() - Restore registers for pm off-mode support
+ * iommu_restore_ctx - Restore registers for pm off-mode support
  * @obj:	target iommu
  **/
 void iommu_restore_ctx(struct iommu *obj)
@@ -85,7 +85,7 @@ void iommu_restore_ctx(struct iommu *obj
 EXPORT_SYMBOL_GPL(iommu_restore_ctx);
 
 /**
- * iommu_arch_version() - Return running iommu arch version
+ * iommu_arch_version - Return running iommu arch version
  **/
 u32 iommu_arch_version(void)
 {
@@ -120,25 +120,16 @@ static void iommu_disable(struct iommu *
 	clk_disable(obj->clk);
 }
 
-#ifdef DEBUG
-static ssize_t iommu_dump_ctx(struct iommu *obj, char *buf)
-{
-	if (!obj || !buf)
-		return -EINVAL;
-
-	return arch_iommu->dump_ctx(obj, buf);
-}
-#endif
-
 /*
  *	TLB operations
  */
-static inline void iotlb_cr_to_e(struct cr_regs *cr, struct iotlb_entry *e)
+void iotlb_cr_to_e(struct cr_regs *cr, struct iotlb_entry *e)
 {
 	BUG_ON(!cr || !e);
 
 	arch_iommu->cr_to_e(cr, e);
 }
+EXPORT_SYMBOL_GPL(iotlb_cr_to_e);
 
 static inline int iotlb_cr_valid(struct cr_regs *cr)
 {
@@ -157,10 +148,11 @@ static inline struct cr_regs *iotlb_allo
 	return arch_iommu->alloc_cr(obj, e);
 }
 
-static inline u32 iotlb_cr_to_virt(struct cr_regs *cr)
+u32 iotlb_cr_to_virt(struct cr_regs *cr)
 {
 	return arch_iommu->cr_to_virt(cr);
 }
+EXPORT_SYMBOL_GPL(iotlb_cr_to_virt);
 
 static u32 get_iopte_attr(struct iotlb_entry *e)
 {
@@ -210,21 +202,21 @@ static void iotlb_load_cr(struct iommu *
 }
 
 /**
- * iotlb_dump_cr() - Dump an iommu tlb entry into buf
+ * iotlb_dump_cr - Dump an iommu tlb entry into buf
  * @obj:	target iommu
  * @cr:		contents of cam and ram register
  * @buf:	output buffer
  **/
-ssize_t iotlb_dump_cr(struct iommu *obj, struct cr_regs *cr, char *buf)
+static inline ssize_t iotlb_dump_cr(struct iommu *obj, struct cr_regs *cr,
+				    char *buf)
 {
 	BUG_ON(!cr || !buf);
 
 	return arch_iommu->dump_cr(obj, cr, buf);
 }
-EXPORT_SYMBOL_GPL(iotlb_dump_cr);
 
 /**
- * load_iotlb_entry() - Set an iommu tlb entry
+ * load_iotlb_entry - Set an iommu tlb entry
  * @obj:	target iommu
  * @e:		an iommu tlb entry info
  **/
@@ -277,7 +269,7 @@ out:
 EXPORT_SYMBOL_GPL(load_iotlb_entry);
 
 /**
- * flush_iotlb_page() - Clear an iommu tlb entry
+ * flush_iotlb_page - Clear an iommu tlb entry
  * @obj:	target iommu
  * @da:		iommu device virtual address
  *
@@ -308,7 +300,7 @@ void flush_iotlb_page(struct iommu *obj,
 		if ((start <= da) && (da < start + bytes)) {
 			dev_dbg(obj->dev, "%s: %08x<=%08x(%x)\n",
 				__func__, start, da, bytes);
-
+			iotlb_load_cr(obj, &cr);
 			iommu_write_reg(obj, 1, MMU_FLUSH_ENTRY);
 		}
 	}
@@ -320,7 +312,7 @@ void flush_iotlb_page(struct iommu *obj,
 EXPORT_SYMBOL_GPL(flush_iotlb_page);
 
 /**
- * flush_iotlb_range() - Clear an iommu tlb entries
+ * flush_iotlb_range - Clear an iommu tlb entries
  * @obj:	target iommu
  * @start:	iommu device virtual address(start)
  * @end:	iommu device virtual address(end)
@@ -340,7 +332,7 @@ void flush_iotlb_range(struct iommu *obj
 EXPORT_SYMBOL_GPL(flush_iotlb_range);
 
 /**
- * flush_iotlb_all() - Clear all iommu tlb entries
+ * flush_iotlb_all - Clear all iommu tlb entries
  * @obj:	target iommu
  **/
 void flush_iotlb_all(struct iommu *obj)
@@ -359,6 +351,87 @@ void flush_iotlb_all(struct iommu *obj)
 }
 EXPORT_SYMBOL_GPL(flush_iotlb_all);
 
+#if defined(CONFIG_OMAP_IOMMU_DEBUG_MODULE)
+
+ssize_t iommu_dump_ctx(struct iommu *obj, char *buf)
+{
+	ssize_t bytes;
+
+	if (!obj || !buf)
+		return -EINVAL;
+
+	clk_enable(obj->clk);
+
+	bytes = arch_iommu->dump_ctx(obj, buf);
+
+	clk_disable(obj->clk);
+
+	return bytes;
+}
+EXPORT_SYMBOL_GPL(iommu_dump_ctx);
+
+static int __dump_tlb_entries(struct iommu *obj, struct cr_regs *crs)
+{
+	int i;
+	struct iotlb_lock saved, l;
+	struct cr_regs *p = crs;
+
+	clk_enable(obj->clk);
+
+	iotlb_lock_get(obj, &saved);
+	memcpy(&l, &saved, sizeof(saved));
+
+	for (i = 0; i < obj->nr_tlb_entries; i++) {
+		struct cr_regs tmp;
+
+		iotlb_lock_get(obj, &l);
+		l.vict = i;
+		iotlb_lock_set(obj, &l);
+		iotlb_read_cr(obj, &tmp);
+		if (!iotlb_cr_valid(&tmp))
+			continue;
+
+		*p++ = tmp;
+	}
+	iotlb_lock_set(obj, &saved);
+	clk_disable(obj->clk);
+
+	return  p - crs;
+}
+
+/**
+ * dump_tlb_entries - dump cr arrays to given buffer
+ * @obj:	target iommu
+ * @buf:	output buffer
+ **/
+size_t dump_tlb_entries(struct iommu *obj, char *buf)
+{
+	int i, n;
+	struct cr_regs *cr;
+	char *p = buf;
+
+	cr = kcalloc(obj->nr_tlb_entries, sizeof(*cr), GFP_KERNEL);
+	if (!cr)
+		return 0;
+
+	n = __dump_tlb_entries(obj, cr);
+	for (i = 0; i < n; i++)
+		p += iotlb_dump_cr(obj, cr + i, p);
+	kfree(cr);
+
+	return p - buf;
+}
+EXPORT_SYMBOL_GPL(dump_tlb_entries);
+
+int foreach_iommu_device(void *data, int (*fn)(struct device *, void *))
+{
+	return driver_for_each_device(&omap_iommu_driver.driver,
+				      NULL, data, fn);
+}
+EXPORT_SYMBOL_GPL(foreach_iommu_device);
+
+#endif /* CONFIG_OMAP_IOMMU_DEBUG_MODULE */
+
 /*
  *	H/W pagetable operations
  */
@@ -515,41 +588,8 @@ static int iopgtable_store_entry_core(st
 	return err;
 }
 
-#ifdef DEBUG
-static void dump_tlb_entries(struct iommu *obj)
-{
-	int i;
-	struct iotlb_lock l;
-
-	clk_enable(obj->clk);
-
-	pr_info("%8s %8s\n", "cam:", "ram:");
-	pr_info("-----------------------------------------\n");
-
-	for (i = 0; i < obj->nr_tlb_entries; i++) {
-		struct cr_regs cr;
-		static char buf[4096];
-
-		iotlb_lock_get(obj, &l);
-		l.vict = i;
-		iotlb_lock_set(obj, &l);
-		iotlb_read_cr(obj, &cr);
-		if (!iotlb_cr_valid(&cr))
-			continue;
-
-		memset(buf, 0, 4096);
-		iotlb_dump_cr(obj, &cr, buf);
-		pr_err("%s", buf);
-	}
-
-	clk_disable(obj->clk);
-}
-#else
-static inline void dump_tlb_entries(struct iommu *obj) {}
-#endif
-
 /**
- * iopgtable_store_entry() - Make an iommu pte entry
+ * iopgtable_store_entry - Make an iommu pte entry
  * @obj:	target iommu
  * @e:		an iommu tlb entry info
  **/
@@ -559,7 +599,7 @@ int iopgtable_store_entry(struct iommu *
 
 	flush_iotlb_page(obj, e->da);
 	err = iopgtable_store_entry_core(obj, e);
-#ifdef USE_IOTLB
+#ifdef PREFETCH_IOTLB
 	if (!err)
 		load_iotlb_entry(obj, e);
 #endif
@@ -568,7 +608,7 @@ int iopgtable_store_entry(struct iommu *
 EXPORT_SYMBOL_GPL(iopgtable_store_entry);
 
 /**
- * iopgtable_lookup_entry() - Lookup an iommu pte entry
+ * iopgtable_lookup_entry - Lookup an iommu pte entry
  * @obj:	target iommu
  * @da:		iommu device virtual address
  * @ppgd:	iommu pgd entry pointer to be returned
@@ -639,7 +679,7 @@ out:
 }
 
 /**
- * iopgtable_clear_entry() - Remove an iommu pte entry
+ * iopgtable_clear_entry - Remove an iommu pte entry
  * @obj:	target iommu
  * @da:		iommu device virtual address
  **/
@@ -696,6 +736,9 @@ static irqreturn_t iommu_fault_handler(i
 	int err = -EIO;
 	struct iommu *obj = data;
 
+	if (!obj->refcount)
+		return IRQ_NONE;
+
 	/* Dynamic loading TLB or PTE */
 	if (obj->isr)
 		err = obj->isr(obj);
@@ -703,7 +746,9 @@ static irqreturn_t iommu_fault_handler(i
 	if (!err)
 		return IRQ_HANDLED;
 
+	clk_enable(obj->clk);
 	stat = iommu_report_fault(obj, &da);
+	clk_disable(obj->clk);
 	if (!stat)
 		return IRQ_HANDLED;
 
@@ -720,8 +765,6 @@ static irqreturn_t iommu_fault_handler(i
 	dev_err(obj->dev, "%s: da:%08x pgd:%p *pgd:%08x pte:%p *pte:%08x\n",
 		__func__, da, iopgd, *iopgd, iopte, *iopte);
 
-	dump_tlb_entries(obj);
-
 	return IRQ_NONE;
 }
 
@@ -736,7 +779,7 @@ static int device_match_by_alias(struct
 }
 
 /**
- * iommu_put() - Get iommu handler
+ * iommu_get - Get iommu handler
  * @name:	target iommu name
  **/
 struct iommu *iommu_get(const char *name)
@@ -773,13 +816,14 @@ err_module:
 	if (obj->refcount == 1)
 		iommu_disable(obj);
 err_enable:
+	obj->refcount--;
 	mutex_unlock(&obj->iommu_lock);
 	return ERR_PTR(err);
 }
 EXPORT_SYMBOL_GPL(iommu_get);
 
 /**
- * iommu_put() - Put back iommu handler
+ * iommu_put - Put back iommu handler
  * @obj:	target iommu
  **/
 void iommu_put(struct iommu *obj)
@@ -928,8 +972,9 @@ static int __init omap_iommu_init(void)
 {
 	struct kmem_cache *p;
 	const unsigned long flags = SLAB_HWCACHE_ALIGN;
+	size_t align = 1 << 10; /* L2 pagetable alignement */
 
-	p = kmem_cache_create("iopte_cache", IOPTE_TABLE_SIZE, 0, flags,
+	p = kmem_cache_create("iopte_cache", IOPTE_TABLE_SIZE, align, flags,
 			      iopte_cachep_ctor);
 	if (!p)
 		return -ENOMEM;
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/iommu-debug.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/iommu-debug.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/iommu-debug.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/iommu-debug.c	2012-12-16 13:13:01.544330149 +0100
@@ -0,0 +1,334 @@
+/*
+ * omap iommu: debugfs interface
+ *
+ * Copyright (C) 2008-2009 Nokia Corporation
+ *
+ * Written by Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/platform_device.h>
+#include <linux/debugfs.h>
+
+#include <mach/iommu.h>
+#include <mach/iovmm.h>
+
+#include "iopgtable.h"
+
+#define MAXCOLUMN 100 /* for short messages */
+
+static DEFINE_MUTEX(iommu_debug_lock);
+static char local_buffer[SZ_4K];
+
+static struct dentry *iommu_debug_root;
+
+static ssize_t debug_read_ver(struct file *file, char __user *userbuf,
+			      size_t count, loff_t *ppos)
+{
+	u32 ver = iommu_arch_version();
+	char buf[MAXCOLUMN], *p = buf;
+
+	p += sprintf(p, "H/W version: %d.%d\n", (ver >> 4) & 0xf , ver & 0xf);
+
+	return simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);
+}
+
+static ssize_t debug_read_regs(struct file *file, char __user *userbuf,
+			       size_t count, loff_t *ppos)
+{
+	struct iommu *obj = file->private_data;
+	char *p = local_buffer;
+	ssize_t bytes;
+
+	mutex_lock(&iommu_debug_lock);
+	p += iommu_dump_ctx(obj, p);
+	bytes = simple_read_from_buffer(userbuf, count, ppos, local_buffer,
+					p - local_buffer);
+	mutex_unlock(&iommu_debug_lock);
+	return bytes;
+}
+
+static ssize_t debug_read_tlb(struct file *file, char __user *userbuf,
+			      size_t count, loff_t *ppos)
+{
+	struct iommu *obj = file->private_data;
+	char *p = local_buffer;
+	ssize_t bytes;
+
+	mutex_lock(&iommu_debug_lock);
+	p += sprintf(p, "%8s %8s\n", "cam:", "ram:");
+	p += sprintf(p, "-----------------------------------------\n");
+	p += dump_tlb_entries(obj, p);
+	bytes = simple_read_from_buffer(userbuf, count, ppos, local_buffer,
+					p - local_buffer);
+	mutex_unlock(&iommu_debug_lock);
+	return bytes;
+}
+
+static ssize_t debug_write_pagetable(struct file *file,
+		     const char __user *userbuf, size_t count, loff_t *ppos)
+{
+	struct iotlb_entry e;
+	struct cr_regs cr;
+	int err;
+	struct iommu *obj = file->private_data;
+	char buf[MAXCOLUMN], *p = buf;
+
+	count = min(count, sizeof(buf));
+
+	mutex_lock(&iommu_debug_lock);
+	if (copy_from_user(p, userbuf, count)) {
+		mutex_unlock(&iommu_debug_lock);
+		return -EFAULT;
+	}
+
+	sscanf(p, "%x %x", &cr.cam, &cr.ram);
+	if (!cr.cam || !cr.ram) {
+		mutex_unlock(&iommu_debug_lock);
+		return -EINVAL;
+	}
+
+	iotlb_cr_to_e(&cr, &e);
+	err = iopgtable_store_entry(obj, &e);
+	if (err)
+		dev_err(obj->dev, "%s: fail to store cr\n", __func__);
+
+	mutex_unlock(&iommu_debug_lock);
+	return count;
+}
+
+static ssize_t debug_read_pagetable(struct file *file, char __user *userbuf,
+				    size_t count, loff_t *ppos)
+{
+	int i;
+	u32 *iopgd;
+	struct iommu *obj = file->private_data;
+	char *p = local_buffer;
+	ssize_t bytes;
+
+	mutex_lock(&iommu_debug_lock);
+
+	p += sprintf(p, "L: %8s %8s\n", "da:", "pa:");
+	p += sprintf(p, "-----------------------------------------\n");
+
+	spin_lock(&obj->page_table_lock);
+
+	iopgd = iopgd_offset(obj, 0);
+	for (i = 0; i < PTRS_PER_IOPGD; i++, iopgd++) {
+		int j;
+		u32 *iopte;
+
+		if (!*iopgd)
+			continue;
+
+		if (!(*iopgd & IOPGD_TABLE)) {
+			u32 da;
+
+			da = i << IOPGD_SHIFT;
+			p += sprintf(p, "1: %08x %08x\n", da, *iopgd);
+			continue;
+		}
+
+		iopte = iopte_offset(iopgd, 0);
+
+		for (j = 0; j < PTRS_PER_IOPTE; j++, iopte++) {
+			u32 da;
+
+			if (!*iopte)
+				continue;
+
+			da = (i << IOPGD_SHIFT) + (j << IOPTE_SHIFT);
+			p += sprintf(p, "2: %08x %08x\n", da, *iopte);
+		}
+	}
+	spin_unlock(&obj->page_table_lock);
+
+	bytes = simple_read_from_buffer(userbuf, count, ppos, local_buffer,
+					p - local_buffer);
+	mutex_unlock(&iommu_debug_lock);
+	return bytes;
+}
+
+static ssize_t debug_read_mmap(struct file *file, char __user *userbuf,
+			       size_t count, loff_t *ppos)
+{
+	struct iommu *obj = file->private_data;
+	char *p = local_buffer;
+	struct iovm_struct *tmp;
+	int uninitialized_var(i);
+	ssize_t bytes;
+
+	mutex_lock(&iommu_debug_lock);
+
+	p += sprintf(p, "%-3s %-8s %-8s %6s %8s\n",
+		     "No", "start", "end", "size", "flags");
+	p += sprintf(p, "-------------------------------------------------\n");
+
+	list_for_each_entry(tmp, &obj->mmap, list) {
+		size_t len;
+
+		len = tmp->da_end - tmp->da_start;
+		p += sprintf(p, "%3d %08x-%08x %6x %8x\n",
+			     i, tmp->da_start, tmp->da_end, len, tmp->flags);
+		i++;
+	}
+	bytes = simple_read_from_buffer(userbuf, count, ppos, local_buffer,
+					p - local_buffer);
+	mutex_unlock(&iommu_debug_lock);
+	return bytes;
+}
+
+static ssize_t debug_read_mem(struct file *file, char __user *userbuf,
+			      size_t count, loff_t *ppos)
+{
+	struct iommu *obj = file->private_data;
+	char *p = local_buffer;
+	struct iovm_struct *area;
+	ssize_t bytes;
+
+	mutex_lock(&iommu_debug_lock);
+
+	area = find_iovm_area(obj, (u32)ppos);
+	if (IS_ERR(area)) {
+		mutex_unlock(&iommu_debug_lock);
+		return -EINVAL;
+	}
+	memcpy(p, area->va, count);
+	p += count;
+
+	bytes = simple_read_from_buffer(userbuf, count, ppos, local_buffer,
+					p - local_buffer);
+	mutex_unlock(&iommu_debug_lock);
+	return bytes;
+}
+
+static ssize_t debug_write_mem(struct file *file, const char __user *userbuf,
+			       size_t count, loff_t *ppos)
+{
+	struct iommu *obj = file->private_data;
+	struct iovm_struct *area;
+	char *p = local_buffer;
+
+	count = min(count, sizeof(local_buffer));
+
+	mutex_lock(&iommu_debug_lock);
+
+	if (copy_from_user(p, userbuf, count)) {
+		mutex_unlock(&iommu_debug_lock);
+		return -EFAULT;
+	}
+
+	area = find_iovm_area(obj, (u32)ppos);
+	if (IS_ERR(area)) {
+		mutex_unlock(&iommu_debug_lock);
+		return -EINVAL;
+	}
+	memcpy(area->va, p, count);
+	mutex_unlock(&iommu_debug_lock);
+	return count;
+}
+
+static int debug_open_generic(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+#define DEBUG_FOPS(name)						\
+	static const struct file_operations debug_##name##_fops = {	\
+		.open = debug_open_generic,				\
+		.read = debug_read_##name,				\
+		.write = debug_write_##name,				\
+	};
+
+#define DEBUG_FOPS_RO(name)						\
+	static const struct file_operations debug_##name##_fops = {	\
+		.open = debug_open_generic,				\
+		.read = debug_read_##name,				\
+	};
+
+DEBUG_FOPS_RO(ver);
+DEBUG_FOPS_RO(regs);
+DEBUG_FOPS_RO(tlb);
+DEBUG_FOPS(pagetable);
+DEBUG_FOPS_RO(mmap);
+DEBUG_FOPS(mem);
+
+#define __DEBUG_ADD_FILE(attr, mode)					\
+	{								\
+		struct dentry *dent;					\
+		dent = debugfs_create_file(#attr, mode, parent,		\
+					   obj, &debug_##attr##_fops);	\
+		if (!dent)						\
+			return -ENOMEM;					\
+	}
+
+#define DEBUG_ADD_FILE(name) __DEBUG_ADD_FILE(name, 600)
+#define DEBUG_ADD_FILE_RO(name) __DEBUG_ADD_FILE(name, 400)
+
+static int iommu_debug_register(struct device *dev, void *data)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct iommu *obj = platform_get_drvdata(pdev);
+	struct dentry *d, *parent;
+
+	if (!obj || !obj->dev)
+		return -EINVAL;
+
+	d = debugfs_create_dir(obj->name, iommu_debug_root);
+	if (!d)
+		return -ENOMEM;
+	parent = d;
+
+	d = debugfs_create_u8("nr_tlb_entries", 400, parent,
+			      (u8 *)&obj->nr_tlb_entries);
+	if (!d)
+		return -ENOMEM;
+
+	DEBUG_ADD_FILE_RO(ver);
+	DEBUG_ADD_FILE_RO(regs);
+	DEBUG_ADD_FILE_RO(tlb);
+	DEBUG_ADD_FILE(pagetable);
+	DEBUG_ADD_FILE_RO(mmap);
+	DEBUG_ADD_FILE(mem);
+
+	return 0;
+}
+
+static int __init iommu_debug_init(void)
+{
+	struct dentry *d;
+	int err;
+
+	d = debugfs_create_dir("iommu", NULL);
+	if (!d)
+		return -ENOMEM;
+	iommu_debug_root = d;
+
+	err = foreach_iommu_device(d, iommu_debug_register);
+	if (err)
+		goto err_out;
+	return 0;
+
+err_out:
+	debugfs_remove_recursive(iommu_debug_root);
+	return err;
+}
+module_init(iommu_debug_init)
+
+static void __exit iommu_debugfs_exit(void)
+{
+	debugfs_remove_recursive(iommu_debug_root);
+}
+module_exit(iommu_debugfs_exit)
+
+MODULE_DESCRIPTION("omap iommu: debugfs interface");
+MODULE_AUTHOR("Hiroshi DOYU <Hiroshi.DOYU@nokia.com>");
+MODULE_LICENSE("GPL v2");
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/iovmm.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/iovmm.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/iovmm.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/iovmm.c	2012-12-16 13:13:01.548330148 +0100
@@ -610,7 +610,7 @@ u32 iommu_vmap(struct iommu *obj, u32 da
 		 u32 flags)
 {
 	size_t bytes;
-	void *va;
+	void *va = NULL;
 
 	if (!obj || !obj->dev || !sgt)
 		return -EINVAL;
@@ -620,9 +620,11 @@ u32 iommu_vmap(struct iommu *obj, u32 da
 		return -EINVAL;
 	bytes = PAGE_ALIGN(bytes);
 
-	va = vmap_sg(sgt);
-	if (IS_ERR(va))
-		return PTR_ERR(va);
+	if (flags & IOVMF_MMIO) {
+		va = vmap_sg(sgt);
+		if (IS_ERR(va))
+			return PTR_ERR(va);
+	}
 
 	flags &= IOVMF_HW_MASK;
 	flags |= IOVMF_DISCONT;
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/Kconfig kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/Kconfig
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/Kconfig	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/Kconfig	2012-12-16 13:13:01.548330148 +0100
@@ -190,6 +190,13 @@ config OMAP_IOMMU
 	  Say Y here if you want to use OMAP IOMMU support for IVA2 and
 	  Camera in OMAP3.
 
+config OMAP_IOMMU_DEBUG
+	tristate "IOMMU debug support"
+	depends on ARCH_OMAP && DEBUG_FS && m
+	default n
+	help
+	  Use debugfs to investigate iommu
+
 choice
         prompt "System timer"
 	default OMAP_MPU_TIMER
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/Makefile kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/Makefile
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/Makefile	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/Makefile	2012-12-16 13:13:01.548330148 +0100
@@ -14,6 +14,7 @@ obj-$(CONFIG_ARCH_OMAP16XX) += ocpi.o
 
 obj-$(CONFIG_OMAP_MCBSP) += mcbsp.o
 obj-$(CONFIG_OMAP_IOMMU) += iommu.o iovmm.o
+obj-$(CONFIG_OMAP_IOMMU_DEBUG) += iommu-debug.o
 
 obj-$(CONFIG_CPU_FREQ) += cpu-omap.o
 obj-$(CONFIG_OMAP_DM_TIMER) += dmtimer.o
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/mcbsp.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/mcbsp.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/mcbsp.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/mcbsp.c	2012-12-16 13:13:01.548330148 +0100
@@ -26,6 +26,9 @@
 
 #include <mach/dma.h>
 #include <mach/mcbsp.h>
+#ifdef CONFIG_ARCH_OMAP34XX
+#include "../mach-omap2/cm-regbits-34xx.h"
+#endif
 
 struct omap_mcbsp **mcbsp_ptr;
 int omap_mcbsp_count;
@@ -290,6 +293,29 @@ u16 omap_mcbsp_get_max_rx_threshold(unsi
 	return mcbsp->max_rx_thres;
 }
 EXPORT_SYMBOL(omap_mcbsp_get_max_rx_threshold);
+
+/*
+ * omap_mcbsp_get_dma_op_mode just return the current configured
+ * operating mode for the mcbsp channel
+ */
+int omap_mcbsp_get_dma_op_mode(unsigned int id)
+{
+	struct omap_mcbsp *mcbsp;
+	int dma_op_mode;
+
+	if (!omap_mcbsp_check_valid_id(id)) {
+		printk(KERN_ERR "%s: Invalid id (%u)\n", __func__, id + 1);
+		return -ENODEV;
+	}
+	mcbsp = id_to_mcbsp_ptr(id);
+
+	spin_lock_irq(&mcbsp->lock);
+	dma_op_mode = mcbsp->dma_op_mode;
+	spin_unlock_irq(&mcbsp->lock);
+
+	return dma_op_mode;
+}
+EXPORT_SYMBOL(omap_mcbsp_get_dma_op_mode);
 #endif
 
 /*
@@ -361,10 +387,19 @@ int omap_mcbsp_request(unsigned int id)
 	if (cpu_is_omap34xx()) {
 		syscon = OMAP_MCBSP_READ(mcbsp->io_base, SYSCON);
 		syscon &= ~(ENAWAKEUP | SIDLEMODE(0x03) | CLOCKACTIVITY(0x03));
-		syscon |= (ENAWAKEUP | SIDLEMODE(0x02) | CLOCKACTIVITY(0x02));
-		OMAP_MCBSP_WRITE(mcbsp->io_base, SYSCON, syscon);
 
-		OMAP_MCBSP_WRITE(mcbsp->io_base, WAKEUPEN, WAKEUPEN_ALL);
+		spin_lock_irq(&mcbsp->lock);
+		if (mcbsp->dma_op_mode == MCBSP_DMA_MODE_THRESHOLD) {
+			syscon |= (ENAWAKEUP | SIDLEMODE(0x02) |
+					CLOCKACTIVITY(0x02));
+			OMAP_MCBSP_WRITE(mcbsp->io_base, WAKEUPEN,
+					WAKEUPEN_ALL);
+		} else {
+			syscon |= SIDLEMODE(0x01);
+		}
+		spin_unlock_irq(&mcbsp->lock);
+
+		OMAP_MCBSP_WRITE(mcbsp->io_base, SYSCON, syscon);
 	}
 
 	/*
@@ -407,7 +442,7 @@ void omap_mcbsp_free(unsigned int id)
 	struct omap_mcbsp *mcbsp;
 	unsigned long flags;
 	int i;
-	u16 syscon, wakeupen;
+	u16 syscon;
 
 	if (!omap_mcbsp_check_valid_id(id)) {
 		printk(KERN_ERR "%s: Invalid id (%d)\n", __func__, id + 1);
@@ -424,11 +459,18 @@ void omap_mcbsp_free(unsigned int id)
 	if (cpu_is_omap34xx()) {
 		syscon = OMAP_MCBSP_READ(mcbsp->io_base, SYSCON);
 		syscon &= ~(ENAWAKEUP | SIDLEMODE(0x03) | CLOCKACTIVITY(0x03));
+		/*
+		 * HW bug workaround - If no_idle mode is taken, we need to
+		 * go to smart_idle before going to always_idle, or the
+		 * device will not hit retention anymore.
+		 */
+		syscon |= SIDLEMODE(0x02);
 		OMAP_MCBSP_WRITE(mcbsp->io_base, SYSCON, syscon);
 
-		wakeupen = OMAP_MCBSP_READ(mcbsp->io_base, WAKEUPEN);
-		wakeupen &= ~WAKEUPEN_ALL;
-		OMAP_MCBSP_WRITE(mcbsp->io_base, WAKEUPEN, wakeupen);
+		syscon &= ~(SIDLEMODE(0x03));
+		OMAP_MCBSP_WRITE(mcbsp->io_base, SYSCON, syscon);
+
+		OMAP_MCBSP_WRITE(mcbsp->io_base, WAKEUPEN, 0);
 	}
 
 	spin_lock_irqsave(&mcbsp->lock, flags);
@@ -461,12 +503,20 @@ static void omap_st_enable(struct omap_m
 	struct omap_mcbsp_st_data *st_data;
 	void __iomem *io_base_mcbsp;
 	void __iomem *io_base_st;
-	u16 w;
+	unsigned int w;
 
 	io_base_mcbsp = mcbsp->io_base;
 	st_data = mcbsp->st_data;
 	io_base_st = st_data->io_base_st;
 
+	/*
+	 * Sidetone uses McBSP ICLK - which must not idle when sidetones
+	 * are enabled or sidetones start sounding ugly.
+	 */
+	w = cm_read_mod_reg(OMAP3430_PER_MOD, CM_AUTOIDLE);
+	w &= ~(mcbsp->id - 1);
+	cm_write_mod_reg(w, OMAP3430_PER_MOD, CM_AUTOIDLE);
+
 	/* Enable McBSP Sidetone */
 	w = OMAP_MCBSP_READ(io_base_mcbsp, SSELCR);
 	OMAP_MCBSP_WRITE(io_base_mcbsp, SSELCR, w | SIDETONEEN);
@@ -484,7 +534,7 @@ static void omap_st_disable(struct omap_
 	struct omap_mcbsp_st_data *st_data;
 	void __iomem *io_base_mcbsp;
 	void __iomem *io_base_st;
-	u16 w;
+	unsigned int w;
 
 	io_base_mcbsp = mcbsp->io_base;
 	st_data = mcbsp->st_data;
@@ -498,6 +548,23 @@ static void omap_st_disable(struct omap_
 
 	w = OMAP_MCBSP_READ(io_base_mcbsp, SSELCR);
 	OMAP_MCBSP_WRITE(io_base_mcbsp, SSELCR, w & ~(SIDETONEEN));
+
+	w = cm_read_mod_reg(OMAP3430_PER_MOD, CM_AUTOIDLE);
+	w |= (mcbsp->id - 1);
+	cm_write_mod_reg(w, OMAP3430_PER_MOD, CM_AUTOIDLE);
+}
+
+static void omap_st_enable_autoidle(struct omap_mcbsp *mcbsp)
+{
+	struct omap_mcbsp_st_data *st_data;
+	void __iomem *io_base_st;
+	unsigned int w;
+
+	st_data = mcbsp->st_data;
+	io_base_st = st_data->io_base_st;
+
+	w = OMAP_ST_READ(io_base_st, SYSCONFIG);
+	OMAP_ST_WRITE(io_base_st, SYSCONFIG, w | ST_AUTOIDLE);
 }
 
 static void omap_st_fir_write(struct omap_mcbsp *mcbsp, s16 *fir)
@@ -522,11 +589,16 @@ static void omap_st_fir_write(struct oma
 	for (i = 0; i < 128; i++)
 		OMAP_ST_WRITE(io_base, SFIRCR, fir[i]);
 
+	i = 0;
+
 	w = OMAP_ST_READ(io_base, SSELCR);
-	while (!(w & ST_COEFFWRDONE))
+	while (!(w & ST_COEFFWRDONE) && (++i < 1000))
 		w = OMAP_ST_READ(io_base, SSELCR);
 
 	OMAP_ST_WRITE(io_base, SSELCR, w & ~(ST_COEFFWREN));
+
+	if (i == 1000)
+		dev_err(mcbsp->dev, "McBSP FIR load error!\n");
 }
 
 static void omap_st_chgain(struct omap_mcbsp *mcbsp, s16 ch0gain, s16 ch1gain)
@@ -553,12 +625,15 @@ static void omap_st_start(struct omap_mc
 	unsigned long flags;
 
 	spin_lock_irqsave(&mcbsp->lock, flags);
-	if (st_data && st_data->enabled) {
+	if (st_data) {
 		omap_st_fir_write(mcbsp, mcbsp->st_data->taps);
 		omap_st_chgain(mcbsp,
 			       mcbsp->st_data->ch0gain,
 			       mcbsp->st_data->ch1gain);
-		omap_st_enable(mcbsp);
+		if (st_data->enabled)
+			omap_st_enable(mcbsp);
+		else
+			omap_st_enable_autoidle(mcbsp);
 		st_data->running = 1;
 	}
 	spin_unlock_irqrestore(&mcbsp->lock, flags);
@@ -1232,6 +1307,53 @@ static DEVICE_ATTR(prop, 0644, prop##_sh
 THRESHOLD_PROP_BUILDER(max_tx_thres);
 THRESHOLD_PROP_BUILDER(max_rx_thres);
 
+static ssize_t dma_op_mode_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct omap_mcbsp *mcbsp = dev_get_drvdata(dev);
+	int dma_op_mode;
+
+	spin_lock_irq(&mcbsp->lock);
+	dma_op_mode = mcbsp->dma_op_mode;
+	spin_unlock_irq(&mcbsp->lock);
+
+	return sprintf(buf, "%d\n", dma_op_mode);
+}
+
+static ssize_t dma_op_mode_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct omap_mcbsp *mcbsp = dev_get_drvdata(dev);
+	unsigned long val;
+	int status;
+
+	status = strict_strtoul(buf, 0, &val);
+	if (status)
+		return status;
+
+	spin_lock_irq(&mcbsp->lock);
+
+	if (!mcbsp->free) {
+		size = -EBUSY;
+		goto unlock;
+	}
+
+	if (val > MCBSP_DMA_MODE_FRAME || val < MCBSP_DMA_MODE_ELEMENT) {
+		size = -EINVAL;
+		goto unlock;
+	}
+
+	mcbsp->dma_op_mode = val;
+
+unlock:
+	spin_unlock_irq(&mcbsp->lock);
+
+	return size;
+}
+
+static DEVICE_ATTR(dma_op_mode, 0644, dma_op_mode_show, dma_op_mode_store);
+
 static ssize_t st_enable_show(struct device *dev,
 			      struct device_attribute *attr, char *buf)
 {
@@ -1254,7 +1376,17 @@ static ssize_t st_enable_store(struct de
 	if (status)
 		return status;
 
+	spin_lock_irq(&mcbsp->lock);
 	st_data->enabled = !!val;
+
+	if (st_data->running) {
+		if (st_data->enabled)
+			omap_st_enable(mcbsp);
+		else
+			omap_st_disable(mcbsp);
+	}
+	spin_unlock_irq(&mcbsp->lock);
+
 	return size;
 }
 
@@ -1363,24 +1495,25 @@ static ssize_t st_chgain_store(struct de
 static DEVICE_ATTR(st_ch0gain, 0644, st_chgain_show, st_chgain_store);
 static DEVICE_ATTR(st_ch1gain, 0644, st_chgain_show, st_chgain_store);
 
-static const struct attribute *threshold_attrs[] = {
+static const struct attribute *additional_attrs[] = {
 	&dev_attr_max_tx_thres.attr,
 	&dev_attr_max_rx_thres.attr,
+	&dev_attr_dma_op_mode.attr,
 	NULL,
 };
 
-static const struct attribute_group threshold_attr_group = {
-	.attrs = (struct attribute **)threshold_attrs,
+static const struct attribute_group additional_attr_group = {
+	.attrs = (struct attribute **)additional_attrs,
 };
 
-static inline int __devinit omap_thres_add(struct platform_device *pdev)
+static inline int __devinit omap_additional_add(struct platform_device *pdev)
 {
-	return sysfs_create_group(&pdev->dev.kobj, &threshold_attr_group);
+	return sysfs_create_group(&pdev->dev.kobj, &additional_attr_group);
 }
 
-static inline void __devexit omap_thres_remove(struct platform_device *pdev)
+static inline void __devexit omap_additional_rem(struct platform_device *pdev)
 {
-	sysfs_remove_group(&pdev->dev.kobj, &threshold_attr_group);
+	sysfs_remove_group(&pdev->dev.kobj, &additional_attr_group);
 }
 
 static const struct attribute *sidetone_attrs[] = {
@@ -1447,11 +1580,12 @@ static inline int __devinit omap_st_add(
 	return 0;
 }
 static inline void __devexit omap_st_remove(struct platform_device *pdev) {}
-static inline int __devinit omap_thres_add(struct platform_device *pdev)
+static inline int __devinit omap_additional_add(struct platform_device *pdev)
 {
 	return 0;
 }
-static inline void __devexit omap_thres_remove(struct platform_device *pdev) {}
+static inline void __devexit omap_additional_rem(struct platform_device *pdev)
+{ }
 #endif /* CONFIG_ARCH_OMAP34XX */
 
 /*
@@ -1536,9 +1670,11 @@ static int __devinit omap_mcbsp_probe(st
 	if (cpu_is_omap34xx()) {
 		mcbsp->max_tx_thres = max_thres(mcbsp);
 		mcbsp->max_rx_thres = max_thres(mcbsp);
+		mcbsp->dma_op_mode = MCBSP_DMA_MODE_THRESHOLD;
 	} else {
 		mcbsp->max_tx_thres = -EINVAL;
 		mcbsp->max_rx_thres = -EINVAL;
+		mcbsp->dma_op_mode = MCBSP_DMA_MODE_ELEMENT;
 	}
 #endif
 
@@ -1548,7 +1684,7 @@ static int __devinit omap_mcbsp_probe(st
 				dev_warn(&pdev->dev,
 				 "Unable to create sidetone controls\n");
 
-		if (omap_thres_add(pdev))
+		if (omap_additional_add(pdev))
 			dev_warn(&pdev->dev,
 				"Unable to create threshold controls\n");
 	}
@@ -1582,7 +1718,7 @@ static int __devexit omap_mcbsp_remove(s
 			if (mcbsp->id == 2 || mcbsp->id == 3)
 				omap_st_remove(pdev);
 
-			omap_thres_remove(pdev);
+			omap_additional_rem(pdev);
 		}
 
 		for (i = mcbsp->num_clks - 1; i >= 0; i--) {
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/omap-pm-noop.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/omap-pm-noop.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/omap-pm-noop.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/omap-pm-noop.c	2012-12-16 13:13:01.548330148 +0100
@@ -60,6 +60,23 @@ void omap_pm_set_max_mpu_wakeup_lat(stru
 	 */
 }
 
+void omap_pm_set_min_mpu_freq(struct device *dev, unsigned long r)
+{
+	if (!dev) {
+		WARN_ON(1);
+		return;
+	}
+	return;
+}
+
+void omap_pm_set_min_mpu_freq(struct device *dev, unsigned long r)
+{
+	if (!dev) {
+		WARN_ON(1);
+		return;
+	}
+}
+
 void omap_pm_set_min_bus_tput(struct device *dev, u8 agent_id, unsigned long r)
 {
 	if (!dev || (agent_id != OCP_INITIATOR_AGENT &&
@@ -84,6 +101,7 @@ void omap_pm_set_min_bus_tput(struct dev
 	 * TI CDP code can call constraint_set here on the VDD2 OPP.
 	 */
 }
+EXPORT_SYMBOL(omap_pm_set_min_bus_tput);
 
 void omap_pm_set_max_dev_wakeup_lat(struct device *dev, long t)
 {
@@ -181,6 +199,7 @@ void omap_pm_dsp_set_min_opp(u8 opp_id)
 	 *
 	 */
 }
+EXPORT_SYMBOL(omap_pm_dsp_set_min_opp);
 
 
 u8 omap_pm_dsp_get_opp(void)
@@ -197,6 +216,7 @@ u8 omap_pm_dsp_get_opp(void)
 
 	return 0;
 }
+EXPORT_SYMBOL(omap_pm_dsp_get_opp);
 
 /*
  * CPUFreq-originated constraint
@@ -237,6 +257,7 @@ void omap_pm_cpu_set_freq(unsigned long
 	 * CDP should just be able to set the VDD1 OPP clock rate here.
 	 */
 }
+EXPORT_SYMBOL(omap_pm_cpu_set_freq);
 
 unsigned long omap_pm_cpu_get_freq(void)
 {
@@ -248,6 +269,7 @@ unsigned long omap_pm_cpu_get_freq(void)
 
 	return 0;
 }
+EXPORT_SYMBOL(omap_pm_cpu_get_freq);
 
 /*
  * Device context loss tracking
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/omap-pm-srf.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/omap-pm-srf.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/omap-pm-srf.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/omap-pm-srf.c	2012-12-16 13:13:01.548330148 +0100
@@ -27,6 +27,7 @@
 #include <mach/powerdomain.h>
 #include <mach/resource.h>
 #include <mach/omapdev.h>
+#include <mach/pm.h>
 
 struct omap_opp *dsp_opps;
 struct omap_opp *mpu_opps;
@@ -74,6 +75,20 @@ void omap_pm_set_max_mpu_wakeup_lat(stru
 	}
 }
 
+void omap_pm_set_min_mpu_freq(struct device *dev, unsigned long r)
+{
+	if (!dev) {
+		WARN_ON(1);
+		return;
+	}
+
+	if (r == 0)
+		resource_release("mpu_freq", dev);
+	else
+		resource_request("mpu_freq", dev, r);
+}
+EXPORT_SYMBOL(omap_pm_set_min_mpu_freq);
+
 void omap_pm_set_min_bus_tput(struct device *dev, u8 agent_id, unsigned long r)
 {
 	if (!dev || (agent_id != OCP_INITIATOR_AGENT &&
@@ -277,7 +292,7 @@ int omap_pm_get_dev_context_loss_count(s
 	 * off counter.
 	 */
 
-	return 0;
+	return get_last_off_on_transaction_id(dev);
 }
 
 /*
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/resource.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/resource.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/resource.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/resource.c	2012-12-16 13:13:01.548330148 +0100
@@ -234,11 +234,13 @@ int resource_refresh(void)
 	struct shared_resource *resp = NULL;
 	int ret = 0;
 
+	down(&res_mutex);
 	list_for_each_entry(resp, &res_list, node) {
 		ret = update_resource_level(resp);
 		if (ret)
 			break;
 	}
+	up(&res_mutex);
 	return ret;
 }
 
@@ -319,26 +321,25 @@ EXPORT_SYMBOL(resource_unregister);
  * Else returns a non-zero error value returned by one of the failing
  * shared_resource_ops.
  */
-int resource_request(const char *name, struct device *dev,
+
+int resource_request_locked(const char *name, struct device *dev,
 					unsigned long level)
 {
 	struct shared_resource *resp;
 	struct  users_list *user;
 	int 	found = 0, ret = 0;
 
-	down(&res_mutex);
 	resp = _resource_lookup(name);
 	if (!resp) {
 		printk(KERN_ERR "resource_request: Invalid resource name\n");
-		ret = -EINVAL;
-		goto res_unlock;
+		return -EINVAL;
 	}
 
 	/* Call the resource specific validate function */
 	if (resp->ops->validate_level) {
 		ret = resp->ops->validate_level(resp, level);
 		if (ret)
-			goto res_unlock;
+			return ret;
 	}
 
 	list_for_each_entry(user, &resp->users_list, node) {
@@ -351,30 +352,37 @@ int resource_request(const char *name, s
 	if (!found) {
 		/* First time user */
 		user = get_user();
-		if (IS_ERR(user)) {
-			ret = -ENOMEM;
-			goto res_unlock;
-		}
+		if (IS_ERR(user))
+			return -ENOMEM;
 		user->dev = dev;
 		list_add(&user->node, &resp->users_list);
 		resp->no_of_users++;
 	}
 	user->level = level;
 
-res_unlock:
-	up(&res_mutex);
 	/*
 	 * Recompute and set the current level for the resource.
 	 * NOTE: update_resource level moved out of spin_lock, as it may call
 	 * pm_qos_add_requirement, which does a kzmalloc. This won't be allowed
 	 * in iterrupt context. The spin_lock still protects add/remove users.
 	 */
-	if (!ret)
-		ret = update_resource_level(resp);
+	return update_resource_level(resp);
+}
+
+int resource_request(const char *name, struct device *dev,
+						unsigned long level)
+{
+	int ret;
+	down(&res_mutex);
+	ret = resource_request_locked(name, dev, level);
+	up(&res_mutex);
 	return ret;
 }
+
 EXPORT_SYMBOL(resource_request);
 
+
+
 /**
  * resource_release - Release a previously requested level of a resource
  * @name: The name of the resource to be released
@@ -387,18 +395,16 @@ EXPORT_SYMBOL(resource_request);
  * Returns 0 on success, -EINVAL if the resource name or dev structure
  * is invalid.
  */
-int resource_release(const char *name, struct device *dev)
+int resource_release_locked(const char *name, struct device *dev)
 {
 	struct shared_resource *resp;
 	struct users_list *user;
-	int found = 0, ret = 0;
+	int found = 0;
 
-	down(&res_mutex);
 	resp = _resource_lookup(name);
 	if (!resp) {
 		printk(KERN_ERR "resource_release: Invalid resource name\n");
-		ret = -EINVAL;
-		goto res_unlock;
+		return -EINVAL;
 	}
 
 	list_for_each_entry(user, &resp->users_list, node) {
@@ -410,8 +416,7 @@ int resource_release(const char *name, s
 
 	if (!found) {
 		/* No such user exists */
-		ret = -EINVAL;
-		goto res_unlock;
+		return -EINVAL;
 	}
 
 	resp->no_of_users--;
@@ -419,8 +424,14 @@ int resource_release(const char *name, s
 	free_user(user);
 
 	/* Recompute and set the current level for the resource */
-	ret = update_resource_level(resp);
-res_unlock:
+	return update_resource_level(resp);
+}
+
+int resource_release(const char *name, struct device *dev)
+{
+	int ret;
+	down(&res_mutex);
+	ret = resource_release_locked(name, dev);
 	up(&res_mutex);
 	return ret;
 }
@@ -450,3 +461,32 @@ int resource_get_level(const char *name)
 	return ret;
 }
 EXPORT_SYMBOL(resource_get_level);
+#if defined(CONFIG_DEBUG_FS) && defined(CONFIG_PM_DEBUG)
+#include <linux/seq_file.h>
+#include <linux/kallsyms.h>
+int resource_dump_reqs(struct seq_file *s, void *unused)
+{
+	struct shared_resource *resp;
+	struct users_list *user;
+	char *buf;
+
+	buf = kmalloc(KSYM_NAME_LEN, GFP_KERNEL);
+	if (buf == NULL)
+		return -ENOMEM;
+
+	down(&res_mutex);
+	list_for_each_entry(resp, &res_list, node) {
+		seq_printf(s, "%s:\n", resp->name);
+		list_for_each_entry(user, &resp->users_list, node) {
+			sprint_symbol(buf, (u32)user->dev);
+			seq_printf(s, "  %s [%s] : %d\n",
+					user->dev->init_name,
+					buf,
+					user->level);
+		}
+	}
+	up(&res_mutex);
+	kfree(buf);
+	return 0;
+}
+#endif
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/sram.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/sram.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/sram.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/sram.c	2012-12-16 13:13:01.548330148 +0100
@@ -41,9 +41,9 @@
 #define OMAP2_SRAM_VA		0xe3000000
 #define OMAP2_SRAM_PUB_VA	(OMAP2_SRAM_VA + 0x800)
 #define OMAP3_SRAM_PA           0x40200000
-#define OMAP3_SRAM_VA           0xd7000000
+#define OMAP3_SRAM_VA           0xe3000000
 #define OMAP3_SRAM_PUB_PA       0x40208000
-#define OMAP3_SRAM_PUB_VA       0xd7008000
+#define OMAP3_SRAM_PUB_VA       (OMAP3_SRAM_VA + 0x8000)
 
 #if defined(CONFIG_ARCH_OMAP24XX) || defined(CONFIG_ARCH_OMAP34XX)
 #define SRAM_BOOTLOADER_SZ	0x00
@@ -368,23 +368,23 @@ static inline int omap243x_sram_init(voi
 
 #ifdef CONFIG_ARCH_OMAP3
 
-static u32 (*_omap3_sram_configure_core_dpll)(u32 sdrc_rfr_ctrl,
-					      u32 sdrc_actim_ctrla,
-					      u32 sdrc_actim_ctrlb,
-					      u32 m2, u32 unlock_dll,
-					      u32 f, u32 sdrc_mr, u32 inc);
-u32 omap3_configure_core_dpll(u32 sdrc_rfr_ctrl, u32 sdrc_actim_ctrla,
-			      u32 sdrc_actim_ctrlb, u32 m2, u32 unlock_dll,
-			      u32 f, u32 sdrc_mr, u32 inc)
- {
+static u32 (*_omap3_sram_configure_core_dpll)(
+				u32 m2, u32 unlock_dll, u32 f, u32 inc,
+				u32 sdrc_rfr_ctrl_0, u32 sdrc_mr_0,
+				u32 sdrc_rfr_ctrl_1, u32 sdrc_mr_1);
+
+u32 omap3_configure_core_dpll(u32 m2, u32 unlock_dll, u32 f, u32 inc,
+			      u32 sdrc_rfr_ctrl_0, u32 sdrc_mr_0,
+			      u32 sdrc_rfr_ctrl_1, u32 sdrc_mr_1)
+{
 	if (!_omap3_sram_configure_core_dpll)
 		omap_sram_error();
 
-	return _omap3_sram_configure_core_dpll(sdrc_rfr_ctrl,
-					       sdrc_actim_ctrla,
-					       sdrc_actim_ctrlb, m2,
-					       unlock_dll, f, sdrc_mr, inc);
- }
+	return _omap3_sram_configure_core_dpll(
+				m2, unlock_dll, f, inc,
+				sdrc_rfr_ctrl_0, sdrc_mr_0,
+				sdrc_rfr_ctrl_1, sdrc_mr_1);
+}
 
 #ifdef CONFIG_PM
 void omap3_sram_restore_context(void)
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/vram.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/vram.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/vram.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/vram.c	2012-12-16 13:13:01.548330148 +0100
@@ -31,13 +31,13 @@
 #include <linux/seq_file.h>
 #include <linux/bootmem.h>
 #include <linux/omapfb.h>
+#include <linux/completion.h>
 
 #include <asm/setup.h>
 
 #include <mach/sram.h>
 #include <mach/vram.h>
-
-#include <mach/dss_boottime.h>
+#include <mach/dma.h>
 
 #ifdef DEBUG
 #define DBG(format, ...) printk(KERN_DEBUG "VRAM: " format, ## __VA_ARGS__)
@@ -62,11 +62,12 @@
  * time when we cannot yet allocate the region list */
 #define MAX_POSTPONED_REGIONS 10
 
-static int postponed_cnt __initdata;
+static bool vram_initialized;
+static int postponed_cnt;
 static struct {
 	unsigned long paddr;
 	size_t size;
-} postponed_regions[MAX_POSTPONED_REGIONS] __initdata;
+} postponed_regions[MAX_POSTPONED_REGIONS];
 
 struct vram_alloc {
 	struct list_head list;
@@ -147,39 +148,32 @@ static void omap_vram_free_allocation(st
 	kfree(va);
 }
 
-static __init int omap_vram_add_region_postponed(unsigned long paddr,
-		size_t size)
-{
-	if (postponed_cnt == MAX_POSTPONED_REGIONS)
-		return -ENOMEM;
-
-	postponed_regions[postponed_cnt].paddr = paddr;
-	postponed_regions[postponed_cnt].size = size;
-
-	++postponed_cnt;
-
-	return 0;
-}
-
-/* add/remove_region can be exported if there's need to add/remove regions
- * runtime */
-static int omap_vram_add_region(unsigned long paddr, size_t size)
+int omap_vram_add_region(unsigned long paddr, size_t size)
 {
 	struct vram_region *rm;
 	unsigned pages;
 
-	DBG("adding region paddr %08lx size %d\n",
-			paddr, size);
+	if (vram_initialized) {
+		DBG("adding region paddr %08lx size %d\n",
+				paddr, size);
 
-	size &= PAGE_MASK;
-	pages = size >> PAGE_SHIFT;
+		size &= PAGE_MASK;
+		pages = size >> PAGE_SHIFT;
 
-	rm = omap_vram_create_region(paddr, pages);
-	if (rm == NULL)
-		return -ENOMEM;
+		rm = omap_vram_create_region(paddr, pages);
+		if (rm == NULL)
+			return -ENOMEM;
 
-	list_add(&rm->list, &region_list);
+		list_add(&rm->list, &region_list);
+	} else {
+		if (postponed_cnt == MAX_POSTPONED_REGIONS)
+			return -ENOMEM;
 
+		postponed_regions[postponed_cnt].paddr = paddr;
+		postponed_regions[postponed_cnt].size = size;
+
+		++postponed_cnt;
+	}
 	return 0;
 }
 
@@ -284,6 +278,59 @@ int omap_vram_reserve(unsigned long padd
 }
 EXPORT_SYMBOL(omap_vram_reserve);
 
+static void _omap_vram_dma_cb(int lch, u16 ch_status, void *data)
+{
+	struct completion *compl = data;
+	complete(compl);
+}
+
+static int _omap_vram_clear(u32 paddr, unsigned pages)
+{
+	struct completion compl;
+	unsigned elem_count;
+	unsigned frame_count;
+	int r;
+	int lch;
+
+	init_completion(&compl);
+
+	r = omap_request_dma(OMAP_DMA_NO_DEVICE, "VRAM DMA",
+			_omap_vram_dma_cb,
+			&compl, &lch);
+	if (r) {
+		pr_err("VRAM: request_dma failed for memory clear\n");
+		return -EBUSY;
+	}
+
+	elem_count = pages * PAGE_SIZE / 4;
+	frame_count = 1;
+
+	omap_set_dma_transfer_params(lch, OMAP_DMA_DATA_TYPE_S32,
+			elem_count, frame_count,
+			OMAP_DMA_SYNC_ELEMENT,
+			0, 0);
+
+	omap_set_dma_dest_params(lch, 0, OMAP_DMA_AMODE_POST_INC,
+			paddr, 0, 0);
+
+	omap_set_dma_color_mode(lch, OMAP_DMA_CONSTANT_FILL, 0x000000);
+
+	omap_start_dma(lch);
+
+	if (wait_for_completion_timeout(&compl, msecs_to_jiffies(1000)) == 0) {
+		omap_stop_dma(lch);
+		pr_err("VRAM: dma timeout while clearing memory\n");
+		r = -EIO;
+		goto err;
+	}
+
+	r = 0;
+err:
+	omap_free_dma(lch);
+
+	return r;
+}
+
 static int _omap_vram_alloc(int mtype, unsigned pages, unsigned long *paddr)
 {
 	struct vram_region *rm;
@@ -321,6 +368,8 @@ found:
 
 		*paddr = start;
 
+		_omap_vram_clear(start, pages);
+
 		return 0;
 	}
 
@@ -349,6 +398,44 @@ int omap_vram_alloc(int mtype, size_t si
 }
 EXPORT_SYMBOL(omap_vram_alloc);
 
+void omap_vram_get_info(unsigned long *vram,
+		unsigned long *free_vram,
+		unsigned long *largest_free_block)
+{
+	struct vram_region *vr;
+	struct vram_alloc *va;
+
+	*vram = 0;
+	*free_vram = 0;
+	*largest_free_block = 0;
+
+	mutex_lock(&region_mutex);
+
+	list_for_each_entry(vr, &region_list, list) {
+		unsigned free;
+		unsigned long pa;
+
+		pa = vr->paddr;
+		*vram += vr->pages << PAGE_SHIFT;
+
+		list_for_each_entry(va, &vr->alloc_list, list) {
+			free = va->paddr - pa;
+			*free_vram += free;
+			if (free > *largest_free_block)
+				*largest_free_block = free;
+			pa = va->paddr + (va->pages << PAGE_SHIFT);
+		}
+
+		free = vr->paddr + (vr->pages << PAGE_SHIFT) - pa;
+		*free_vram += free;
+		if (free > *largest_free_block)
+			*largest_free_block = free;
+	}
+
+	mutex_unlock(&region_mutex);
+}
+EXPORT_SYMBOL(omap_vram_get_info);
+
 #ifdef CONFIG_PROC_FS
 static void *r_next(struct seq_file *m, void *v, loff_t *pos)
 {
@@ -440,6 +527,8 @@ static __init int omap_vram_init(void)
 {
 	int i, r;
 
+	vram_initialized = 1;
+
 	for (i = 0; i < postponed_cnt; i++)
 		omap_vram_add_region(postponed_regions[i].paddr,
 				postponed_regions[i].size);
@@ -474,10 +563,6 @@ static void __init omapfb_early_vram(cha
 	omapfb_def_sdram_vram_size = memparse(*p, p);
 	if (**p == ',')
 		omapfb_def_sdram_vram_start = simple_strtoul((*p) + 1, p, 16);
-
-	printk("omapfb_early_vram, %d, 0x%x\n",
-			omapfb_def_sdram_vram_size,
-			omapfb_def_sdram_vram_start);
 }
 __early_param("vram=", omapfb_early_vram);
 
@@ -519,28 +604,6 @@ void __init omapfb_reserve_sdram(void)
 	sdram_start = bdata->node_min_pfn << PAGE_SHIFT;
 	sdram_size = (bdata->node_low_pfn << PAGE_SHIFT) - sdram_start;
 
-#ifdef CONFIG_FB_OMAP_BOOTLOADER_INIT
-	if (!paddr) {
-		unsigned long fb_paddr;
-		size_t fb_size;
-
-		fb_paddr = dss_boottime_get_plane_base(0);
-		fb_size = dss_boottime_get_plane_size(0);
-
-		if (fb_paddr != -1UL && fb_size > 0) {
-			size += fb_size;
-			if (fb_paddr + size <= sdram_start + sdram_size)
-				paddr = fb_paddr;
-			else
-				paddr = fb_paddr + fb_size - size;
-
-			pr_info("Bootloader framebuffer: %zd bytes at 0x%lx. "
-					"Setting VRAM start to 0x%x.\n",
-					fb_size, fb_paddr, paddr);
-		}
-	}
-#endif
-
 	if (paddr) {
 		if ((paddr & ~PAGE_MASK) || paddr < sdram_start ||
 				paddr + size > sdram_start + sdram_size) {
@@ -548,7 +611,10 @@ void __init omapfb_reserve_sdram(void)
 			return;
 		}
 
-		reserve_bootmem(paddr, size, BOOTMEM_DEFAULT);
+		if (reserve_bootmem(paddr, size, BOOTMEM_EXCLUSIVE) < 0) {
+			pr_err("FB: failed to reserve VRAM\n");
+			return;
+		}
 	} else {
 		if (size > sdram_size) {
 			printk(KERN_ERR "Illegal SDRAM size for VRAM\n");
@@ -559,7 +625,7 @@ void __init omapfb_reserve_sdram(void)
 		BUG_ON(paddr & ~PAGE_MASK);
 	}
 
-	omap_vram_add_region_postponed(paddr, size);
+	omap_vram_add_region(paddr, size);
 
 	pr_info("Reserving %u bytes SDRAM for VRAM\n", size);
 }
@@ -615,7 +681,7 @@ unsigned long __init omapfb_reserve_sram
 		reserved = pend_avail - paddr;
 	size_avail = pend_avail - reserved - pstart_avail;
 
-	omap_vram_add_region_postponed(paddr, size);
+	omap_vram_add_region(paddr, size);
 
 	if (reserved)
 		pr_info("Reserving %lu bytes SRAM for VRAM\n", reserved);
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/vrfb.c kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/vrfb.c
--- kernel-2.6.28-20091602+0m5/arch/arm/plat-omap/vrfb.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/plat-omap/vrfb.c	2012-12-16 13:13:01.548330148 +0100
@@ -1,7 +1,9 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/ioport.h>
+
 #include <asm/io.h>
+#include <asm/bitops.h>
 
 #include <mach/io.h>
 #include <mach/vrfb.h>
@@ -16,8 +18,8 @@
 
 #define SMS_ROT_VIRT_BASE(context, rot) \
 	(((context >= 4) ? 0xD0000000 : 0x70000000) \
-	 | 0x4000000 * (context) \
-	 | 0x1000000 * (rot))
+	 + (0x4000000 * (context)) \
+	 + (0x1000000 * (rot)))
 
 #define OMAP_VRFB_SIZE			(2048 * 2048 * 4)
 
@@ -38,7 +40,49 @@
 
 #define VRFB_NUM_CTXS 12
 /* bitmap of reserved contexts */
-static unsigned ctx_map;
+static unsigned long ctx_map;
+
+/*
+ * Access to this happens from client drivers or the PM core after wake-up.
+ * For the first case we require locking at the driver level, for the second
+ * we don't need locking, since no drivers will run until after the wake-up
+ * has finished.
+ */
+static struct {
+	u32 physical_ba;
+	u32 control;
+	u32 size;
+} vrfb_hw_context[VRFB_NUM_CTXS];
+
+static void inline restore_hw_context(int ctx)
+{
+	omap_writel(vrfb_hw_context[ctx].control, SMS_ROT_CONTROL(ctx));
+	omap_writel(vrfb_hw_context[ctx].size, SMS_ROT_SIZE(ctx));
+	omap_writel(vrfb_hw_context[ctx].physical_ba, SMS_ROT_PHYSICAL_BA(ctx));
+}
+
+/*
+ * This the extra space needed in the VRFB physical area for VRFB to safely wrap
+ * any memory accesses to the invisible part of the virtual view to the physical
+ * area.
+ */
+static inline u32 get_extra_physical_size(u16 width, u8 bytespp)
+{
+	return (OMAP_VRFB_LINE_LEN - width) * bytespp * VRFB_PAGE_HEIGHT;
+}
+
+void omap_vrfb_restore_context(void)
+{
+	int i;
+	unsigned long map = ctx_map;
+
+	for (i = ffs(map); i; i = ffs(map)) {
+		/* i=1..32 */
+		i--;
+		map &= ~(1 << i);
+		restore_hw_context(i);
+	}
+}
 
 void omap_vrfb_adjust_size(u16 *width, u16 *height,
 		u8 bytespp)
@@ -48,17 +92,95 @@ void omap_vrfb_adjust_size(u16 *width, u
 }
 EXPORT_SYMBOL(omap_vrfb_adjust_size);
 
+u32 omap_vrfb_min_phys_size(u16 width, u16 height, u8 bytespp)
+{
+	/* mmap() is page aligned */
+	height = ALIGN(OMAP_VRFB_LINE_LEN * bytespp * height, PAGE_SIZE) /
+		(OMAP_VRFB_LINE_LEN * bytespp);
+
+	omap_vrfb_adjust_size(&width, &height, bytespp);
+
+	if (width > OMAP_VRFB_LINE_LEN)
+		return 0;
+
+	if (height > 2048)
+		return 0;
+
+	return (width * height * bytespp) + get_extra_physical_size(width, bytespp);
+}
+EXPORT_SYMBOL(omap_vrfb_min_phys_size);
+
+u16 omap_vrfb_max_height(u32 phys_size, u16 width, u8 bytespp)
+{
+	unsigned long height;
+	unsigned long extra;
+
+	width = ALIGN(width * bytespp, VRFB_PAGE_WIDTH) / bytespp;
+
+	if (width > OMAP_VRFB_LINE_LEN)
+		return 0;
+
+	extra = get_extra_physical_size(width, bytespp);
+
+	if (phys_size < extra)
+		return 0;
+
+	height = (phys_size - extra) / (width * bytespp);
+
+	/* mmap() is page aligned */
+	height = (OMAP_VRFB_LINE_LEN * bytespp * height & ~PAGE_MASK) /
+		(OMAP_VRFB_LINE_LEN * bytespp);
+
+	/* Only full tiles */
+	height &= ~(VRFB_PAGE_HEIGHT - 1);
+
+	/* Virtual views provided by VRFB are limited to 2048x2048. */
+	return min(height, 2048UL);
+}
+EXPORT_SYMBOL(omap_vrfb_max_height);
+
 void omap_vrfb_setup(struct vrfb *vrfb, unsigned long paddr,
 		u16 width, u16 height,
-		u8 bytespp)
+		enum omap_color_mode color_mode)
 {
 	unsigned pixel_size_exp;
 	u16 vrfb_width;
 	u16 vrfb_height;
 	u8 ctx = vrfb->context;
+	u8 bytespp;
+	u32 size;
+	u32 control;
 
 	DBG("omapfb_set_vrfb(%d, %lx, %dx%d, %d)\n", ctx, paddr,
-			width, height, bytespp);
+			width, height, color_mode);
+
+	switch (color_mode) {
+	case OMAP_DSS_COLOR_RGB16:
+	case OMAP_DSS_COLOR_ARGB16:
+		bytespp = 2;
+		break;
+
+	case OMAP_DSS_COLOR_RGB24P:
+		bytespp = 3;
+		break;
+
+	case OMAP_DSS_COLOR_RGB24U:
+	case OMAP_DSS_COLOR_ARGB32:
+	case OMAP_DSS_COLOR_RGBA32:
+	case OMAP_DSS_COLOR_RGBX32:
+	case OMAP_DSS_COLOR_YUV2:
+	case OMAP_DSS_COLOR_UYVY:
+		bytespp = 4;
+		break;
+
+	default:
+		BUG();
+		return;
+	}
+
+	if (color_mode == OMAP_DSS_COLOR_YUV2 ||
+			color_mode == OMAP_DSS_COLOR_UYVY)
+		width >>= 1;
 
 	if (bytespp == 4)
 		pixel_size_exp = 2;
@@ -70,37 +192,67 @@ void omap_vrfb_setup(struct vrfb *vrfb,
 	vrfb_width = ALIGN(width * bytespp, VRFB_PAGE_WIDTH) / bytespp;
 	vrfb_height = ALIGN(height, VRFB_PAGE_HEIGHT);
 
-	DBG("vrfb w %u, h %u\n", vrfb_width, vrfb_height);
+	DBG("vrfb w %u, h %u bytespp %d\n", vrfb_width, vrfb_height, bytespp);
+
+	size  = vrfb_width << SMS_IMAGEWIDTH_OFFSET;
+	size |= vrfb_height << SMS_IMAGEHEIGHT_OFFSET;
+
+	control  = pixel_size_exp << SMS_PS_OFFSET;
+	control |= VRFB_PAGE_WIDTH_EXP  << SMS_PW_OFFSET;
+	control |= VRFB_PAGE_HEIGHT_EXP << SMS_PH_OFFSET;
+
+	vrfb_hw_context[ctx].physical_ba = paddr;
+	vrfb_hw_context[ctx].size = size;
+	vrfb_hw_context[ctx].control = control;
 
 	omap_writel(paddr, SMS_ROT_PHYSICAL_BA(ctx));
-	omap_writel((vrfb_width << SMS_IMAGEWIDTH_OFFSET) |
-			(vrfb_height << SMS_IMAGEHEIGHT_OFFSET),
-			SMS_ROT_SIZE(ctx));
-
-	omap_writel(pixel_size_exp << SMS_PS_OFFSET |
-			VRFB_PAGE_WIDTH_EXP  << SMS_PW_OFFSET |
-			VRFB_PAGE_HEIGHT_EXP << SMS_PH_OFFSET,
-			SMS_ROT_CONTROL(ctx));
+	omap_writel(size, SMS_ROT_SIZE(ctx));
+	omap_writel(control, SMS_ROT_CONTROL(ctx));
 
 	DBG("vrfb offset pixels %d, %d\n",
 			vrfb_width - width, vrfb_height - height);
 
+	vrfb->xres = width;
+	vrfb->yres = height;
 	vrfb->xoffset = vrfb_width - width;
 	vrfb->yoffset = vrfb_height - height;
 	vrfb->bytespp = bytespp;
 }
 EXPORT_SYMBOL(omap_vrfb_setup);
 
+int omap_vrfb_map_angle(struct vrfb *vrfb, u16 height, u8 rot)
+{
+	unsigned long size = height * OMAP_VRFB_LINE_LEN * vrfb->bytespp;
+
+	vrfb->vaddr[rot] = ioremap_wc(vrfb->paddr[rot], size);
+
+	if (!vrfb->vaddr[rot]) {
+		printk(KERN_ERR "vrfb: ioremap failed\n");
+		return -ENOMEM;
+	}
+
+	DBG("ioremapped vrfb area %d of size %lu into %p\n", rot, size,
+		vrfb->vaddr[rot]);
+
+	return 0;
+}
+EXPORT_SYMBOL(omap_vrfb_map_angle);
+
 void omap_vrfb_release_ctx(struct vrfb *vrfb)
 {
 	int rot;
+	int ctx = vrfb->context;
 
-	if (vrfb->context == 0xff)
+	if (ctx == 0xff)
 		return;
 
-	DBG("release ctx %d\n", vrfb->context);
+	DBG("release ctx %d\n", ctx);
 
-	ctx_map &= ~(1 << vrfb->context);
+	if (!(ctx_map & (1 << ctx))) {
+		BUG();
+		return;
+	}
+	clear_bit(ctx, &ctx_map);
 
 	for (rot = 0; rot < 4; ++rot) {
 		if(vrfb->paddr[rot]) {
@@ -132,7 +284,7 @@ int omap_vrfb_request_ctx(struct vrfb *v
 
 	DBG("found free ctx %d\n", ctx);
 
-	ctx_map |= 1 << ctx;
+	set_bit(ctx, &ctx_map);
 
 	memset(vrfb, 0, sizeof(*vrfb));
 
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/vfp/entry.S kernel-2.6.28-20093908+0m5/arch/arm/vfp/entry.S
--- kernel-2.6.28-20091602+0m5/arch/arm/vfp/entry.S	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/vfp/entry.S	2012-12-16 13:13:01.548330148 +0100
@@ -15,13 +15,16 @@
  *  r10 = thread_info structure
  *  lr  = failure return
  */
-#include <linux/linkage.h>
-#include <linux/init.h>
-#include <asm/asm-offsets.h>
-#include <asm/assembler.h>
+#include <asm/thread_info.h>
 #include <asm/vfpmacros.h>
+#include "../kernel/entry-header.S"
 
 ENTRY(do_vfp)
+#ifdef CONFIG_PREEMPT
+	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+	add	r11, r4, #1		@ increment it
+	str	r11, [r10, #TI_PREEMPT]
+#endif
 	enable_irq
  	ldr	r4, .LCvfp
 	ldr	r11, [r10, #TI_CPU]	@ CPU number
@@ -30,6 +33,12 @@ ENTRY(do_vfp)
 ENDPROC(do_vfp)
 
 ENTRY(vfp_null_entry)
+#ifdef CONFIG_PREEMPT
+	get_thread_info	r10
+	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+	sub	r11, r4, #1		@ decrement it
+	str	r11, [r10, #TI_PREEMPT]
+#endif
 	mov	pc, lr
 ENDPROC(vfp_null_entry)
 
@@ -41,6 +50,12 @@ ENDPROC(vfp_null_entry)
 
 	__INIT
 ENTRY(vfp_testing_entry)
+#ifdef CONFIG_PREEMPT
+	get_thread_info	r10
+	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+	sub	r11, r4, #1		@ decrement it
+	str	r11, [r10, #TI_PREEMPT]
+#endif
 	ldr	r0, VFP_arch_address
 	str	r5, [r0]		@ known non-zero value
 	mov	pc, r9			@ we have handled the fault
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/vfp/vfp.h kernel-2.6.28-20093908+0m5/arch/arm/vfp/vfp.h
--- kernel-2.6.28-20091602+0m5/arch/arm/vfp/vfp.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/vfp/vfp.h	2012-12-16 13:13:01.548330148 +0100
@@ -377,6 +377,11 @@ struct op {
 	u32 flags;
 };
 
-#ifdef CONFIG_SMP
 extern void vfp_save_state(void *location, u32 fpexc);
+#if defined(CONFIG_SMP) || defined(CONFIG_PM)
+extern void vfp_restore_state(void *location);
+extern void vfp_pm_save_context(void);
+extern void vfp_pm_restore_context(void);
+extern void vfp_save_regs(u32 *vfp_regs);
+extern void vfp_restore_regs(u32 *vfp_regs);
 #endif
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/vfp/vfphw.S kernel-2.6.28-20093908+0m5/arch/arm/vfp/vfphw.S
--- kernel-2.6.28-20091602+0m5/arch/arm/vfp/vfphw.S	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/vfp/vfphw.S	2012-12-16 13:13:01.548330148 +0100
@@ -101,9 +101,12 @@ ENTRY(vfp_support_entry)
 	VFPFSTMIA r4, r5		@ save the working registers
 	VFPFMRX	r5, FPSCR		@ current status
 	tst	r1, #FPEXC_EX		@ is there additional state to save?
-	VFPFMRX	r6, FPINST, NE		@ FPINST (only if FPEXC.EX is set)
-	tstne	r1, #FPEXC_FP2V		@ is there an FPINST2 to read?
-	VFPFMRX	r8, FPINST2, NE		@ FPINST2 if needed (and present)
+	beq	1f
+	VFPFMRX	r6, FPINST		@ FPINST (only if FPEXC.EX is set)
+	tst	r1, #FPEXC_FP2V		@ is there an FPINST2 to read?
+	beq	1f
+	VFPFMRX	r8, FPINST2		@ FPINST2 if needed (and present)
+1:
 	stmia	r4, {r1, r5, r6, r8}	@ save FPEXC, FPSCR, FPINST, FPINST2
 					@ and point r4 at the word at the
 					@ start of the register dump
@@ -117,9 +120,12 @@ no_old_VFP_process:
 					@ FPEXC is in a safe state
 	ldmia	r10, {r1, r5, r6, r8}	@ load FPEXC, FPSCR, FPINST, FPINST2
 	tst	r1, #FPEXC_EX		@ is there additional state to restore?
-	VFPFMXR	FPINST, r6, NE		@ restore FPINST (only if FPEXC.EX is set)
-	tstne	r1, #FPEXC_FP2V		@ is there an FPINST2 to write?
-	VFPFMXR	FPINST2, r8, NE		@ FPINST2 if needed (and present)
+	beq	1f
+	VFPFMXR	FPINST, r6		@ restore FPINST (only if FPEXC.EX is set)
+	tst	r1, #FPEXC_FP2V		@ is there an FPINST2 to write?
+	beq	1f
+	VFPFMXR	FPINST2, r8		@ FPINST2 if needed (and present)
+1:
 	VFPFMXR	FPSCR, r5		@ restore status
 
 check_for_exception:
@@ -131,6 +137,12 @@ check_for_exception:
 	VFPFMXR	FPEXC, r1		@ restore FPEXC last
 	sub	r2, r2, #4
 	str	r2, [sp, #S_PC]		@ retry the instruction
+#ifdef CONFIG_PREEMPT
+	get_thread_info	r10
+	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+	sub	r11, r4, #1		@ decrement it
+	str	r11, [r10, #TI_PREEMPT]
+#endif
 	mov	pc, r9			@ we think we have handled things
 
 
@@ -149,6 +161,12 @@ look_for_VFP_exceptions:
 	@ not recognised by VFP
 
 	DBGSTR	"not VFP"
+#ifdef CONFIG_PREEMPT
+	get_thread_info	r10
+	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+	sub	r11, r4, #1		@ decrement it
+	str	r11, [r10, #TI_PREEMPT]
+#endif
 	mov	pc, lr
 
 process_exception:
@@ -166,7 +184,6 @@ process_exception:
 					@ retry the faulted instruction
 ENDPROC(vfp_support_entry)
 
-#ifdef CONFIG_SMP
 ENTRY(vfp_save_state)
 	@ Save the current VFP state
 	@ r0 - save location
@@ -175,12 +192,50 @@ ENTRY(vfp_save_state)
 	VFPFSTMIA r0, r2		@ save the working registers
 	VFPFMRX	r2, FPSCR		@ current status
 	tst	r1, #FPEXC_EX		@ is there additional state to save?
-	VFPFMRX	r3, FPINST, NE		@ FPINST (only if FPEXC.EX is set)
-	tstne	r1, #FPEXC_FP2V		@ is there an FPINST2 to read?
-	VFPFMRX	r12, FPINST2, NE	@ FPINST2 if needed (and present)
+	beq	1f
+	VFPFMRX	r3, FPINST		@ FPINST (only if FPEXC.EX is set)
+	tst	r1, #FPEXC_FP2V		@ is there an FPINST2 to read?
+	beq	1f
+	VFPFMRX	r12, FPINST2		@ FPINST2 if needed (and present)
+1:
 	stmia	r0, {r1, r2, r3, r12}	@ save FPEXC, FPSCR, FPINST, FPINST2
 	mov	pc, lr
 ENDPROC(vfp_save_state)
+
+#if defined(CONFIG_SMP) || defined(CONFIG_PM)
+ENTRY(vfp_restore_state)
+	@ Restore the current VFP state
+	@ r0 - saved location
+	DBGSTR1	"Restore VFP state %p", r0
+	ldmia	r0, {r1, r2, r3, r12}	@ save FPEXC, FPSCR, FPINST, FPINST2
+	VFPFMXR	FPSCR, r2		@ current status
+	tst	r1, #FPEXC_EX		@ is there additional state to save?
+	beq	1f
+	VFPFMXR	FPINST, r3		@ FPINST (only if FPEXC.EX is set)
+	tst	r1, #FPEXC_FP2V		@ is there an FPINST2 to read?
+	beq	1f
+	VFPFMXR	FPINST2, r12		@ FPINST2 if needed (and present)
+1:
+	mov	pc, lr
+ENDPROC(vfp_restore_state)
+#endif
+
+#if defined(CONFIG_SMP) || defined(CONFIG_PM)
+ENTRY(vfp_save_regs)
+	@ Save the current VFP state
+	@ r0 - save location
+	VFPFSTMIA r0, r1
+	mov	pc, lr
+ENDPROC(vfp_save_regs)
+#endif
+
+#if defined(CONFIG_SMP) || defined(CONFIG_PM)
+ENTRY(vfp_restore_regs)
+	@ Save the current VFP state
+	@ r0 - save location
+	VFPFLDMIA r0, r1
+	mov	pc, lr
+ENDPROC(vfp_restore_regs)
 #endif
 
 last_VFP_context_address:
diff -Nurp kernel-2.6.28-20091602+0m5/arch/arm/vfp/vfpmodule.c kernel-2.6.28-20093908+0m5/arch/arm/vfp/vfpmodule.c
--- kernel-2.6.28-20091602+0m5/arch/arm/vfp/vfpmodule.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/arch/arm/vfp/vfpmodule.c	2012-12-16 13:13:01.548330148 +0100
@@ -266,7 +266,7 @@ void VFP_bounce(u32 trigger, u32 fpexc,
 		 * on VFP subarch 1.
 		 */
 		 vfp_raise_exceptions(VFP_EXCEPTION_ERROR, trigger, fpscr, regs);
-		 return;
+		goto exit;
 	}
 
 	/*
@@ -297,7 +297,7 @@ void VFP_bounce(u32 trigger, u32 fpexc,
 	 * the FPEXC.FP2V bit is valid only if FPEXC.EX is 1.
 	 */
 	if (fpexc ^ (FPEXC_EX | FPEXC_FP2V))
-		return;
+		goto exit;
 
 	/*
 	 * The barrier() here prevents fpinst2 being read
@@ -310,9 +310,11 @@ void VFP_bounce(u32 trigger, u32 fpexc,
 	exceptions = vfp_emulate_instruction(trigger, orig_fpscr, regs);
 	if (exceptions)
 		vfp_raise_exceptions(exceptions, trigger, orig_fpscr, regs);
+ exit:
+	preempt_enable();
 }
 
-static void vfp_enable(void *unused)
+void vfp_enable(void *unused)
 {
 	u32 access = get_copro_access();
 
@@ -322,6 +324,151 @@ static void vfp_enable(void *unused)
 	set_copro_access(access | CPACC_FULL(10) | CPACC_FULL(11));
 }
 
+#ifdef CONFIG_PM
+#include <linux/sysdev.h>
+
+void vfp_pm_save_context(void)
+{
+	struct thread_info *ti = current_thread_info();
+	u32 fpexc = fmrx(FPEXC);
+
+	/* if vfp is on, then save state for resumption */
+	if (fpexc & FPEXC_EN) {
+		printk(KERN_DEBUG "%s: saving vfp state\n", __func__);
+		vfp_save_state(&(ti->vfpstate.hard.fpexc), fpexc);
+		vfp_save_regs((u32 *)(ti->vfpstate.hard.fpregs));
+	} else {
+		vfp_enable(NULL); /* enable VFP for now to save context. */
+		vfp_save_regs((u32 *)(ti->vfpstate.hard.fpregs));
+		fmxr(FPEXC, fmrx(FPEXC) & ~FPEXC_EN);
+	}
+}
+
+static int vfp_pm_suspend(struct sys_device *dev, pm_message_t state)
+{
+	u32 fpexc = fmrx(FPEXC);
+	vfp_pm_save_context();
+
+	/* disable, just in case */
+	if (fpexc & FPEXC_EN)
+		fmxr(FPEXC, fmrx(FPEXC) & ~FPEXC_EN);
+
+	/* clear any information we had about last context state */
+	memset(last_VFP_context, 0, sizeof(last_VFP_context));
+
+	return 0;
+}
+
+void vfp_pm_restore_context(void)
+{
+	struct thread_info *ti = current_thread_info();
+	u32 fpexc = fmrx(FPEXC);
+	/* if vfp is on, then save state for resumption */
+	if (fpexc & FPEXC_EN) {
+		printk(KERN_DEBUG "%s: restoring vfp state\n", __func__);
+		vfp_restore_state(&(ti->vfpstate.hard.fpexc));
+		vfp_restore_regs((u32 *)(ti->vfpstate.hard.fpregs));
+	}
+}
+
+static int vfp_pm_resume(struct sys_device *dev)
+{
+	/* ensure we have access to the vfp */
+	vfp_enable(NULL);
+
+	vfp_pm_restore_context();
+	/* and disable it to ensure the next usage restores the state */
+	fmxr(FPEXC, fmrx(FPEXC) & ~FPEXC_EN);
+
+	return 0;
+}
+
+static struct sysdev_class vfp_pm_sysclass = {
+	.name		= "vfp",
+	.suspend	= vfp_pm_suspend,
+	.resume		= vfp_pm_resume,
+};
+
+static struct sys_device vfp_pm_sysdev = {
+	.cls	= &vfp_pm_sysclass,
+};
+
+static void vfp_pm_init(void)
+{
+	sysdev_class_register(&vfp_pm_sysclass);
+	sysdev_register(&vfp_pm_sysdev);
+}
+
+
+#else
+static inline void vfp_pm_init(void) { }
+#endif /* CONFIG_PM */
+
+/*
+ * Synchronise the hardware VFP state of a thread with the saved one.
+ * This function is used by the ptrace mechanism and the signal handler path.
+ */
+void vfp_sync_state(struct thread_info *thread)
+{
+	unsigned int cpu = get_cpu();
+	u32 fpexc = fmrx(FPEXC);
+	int vfp_enabled;
+	int self;
+
+	vfp_enabled = fpexc & FPEXC_EN;
+	self = thread == current_thread_info();
+#ifdef CONFIG_SMP
+	/*
+	 * On SMP systems, the VFP state is automatically saved at every
+	 * context switch. We mark the thread VFP state as belonging to a
+	 * non-existent CPU so that the saved one will be reloaded when
+	 * needed.
+	 */
+	thread->vfpstate.hard.cpu = NR_CPUS;
+	/*
+	 * Only the current thread's saved VFP context can be out-of-date.
+	 * For others there is nothing else to do, since we already ensured
+	 * force loading above.
+	 */
+	if (!self)
+		goto out;
+#endif
+	/*
+	 * If the VFP is enabled only the current thread's saved VFP
+	 * context can get out-of-date. For other threads the context
+	 * was updated when the current thread started to use the VFP.
+	 * This also means that the context will be reloaded next time
+	 * the thread uses the VFP, so no need to enforce it.
+	 */
+	if (vfp_enabled && !self)
+		goto out;
+
+	if (!last_VFP_context[cpu])
+		goto out;
+
+	/*
+	 * Save the last VFP state on this CPU.
+	 */
+	if (!vfp_enabled)
+		fmxr(FPEXC, fpexc | FPEXC_EN);
+	vfp_save_state(last_VFP_context[cpu], fpexc);
+	/*
+	 * Disable VFP in case it was enabled so that the force reload
+	 * can happen.
+	 */
+	fpexc &= ~FPEXC_EN;
+	fmxr(FPEXC, fpexc);
+
+	/*
+	 * Set the context to NULL to force a reload the next time the thread
+	 * uses the VFP.
+	 */
+	last_VFP_context[cpu] = NULL;
+
+out:
+	put_cpu();
+}
+
 #include <linux/smp.h>
 
 /*
@@ -365,12 +512,34 @@ static int __init vfp_init(void)
 		vfp_vector = vfp_support_entry;
 
 		thread_register_notifier(&vfp_notifier_block);
+		vfp_pm_init();
 
 		/*
 		 * We detected VFP, and the support code is
 		 * in place; report VFP support to userspace.
 		 */
 		elf_hwcap |= HWCAP_VFP;
+#ifdef CONFIG_VFPv3
+		if (VFP_arch >= 3) {
+			elf_hwcap |= HWCAP_VFPv3;
+
+			/*
+			 * Check for VFPv3 D16. CPUs in this configuration
+			 * only have 16 x 64bit registers.
+			 */
+			if (((fmrx(MVFR0) & MVFR0_A_SIMD_MASK)) == 1)
+				elf_hwcap |= HWCAP_VFPv3D16;
+		}
+#endif
+#ifdef CONFIG_NEON
+		/*
+		 * Check for the presence of the Advanced SIMD
+		 * load/store instructions, integer and single
+		 * precision floating point operations.
+		 */
+		if ((fmrx(MVFR1) & 0x000fff00) == 0x00011100)
+			elf_hwcap |= HWCAP_NEON;
+#endif
 	}
 	return 0;
 }
diff -Nurp kernel-2.6.28-20091602+0m5/block/blk-core.c kernel-2.6.28-20093908+0m5/block/blk-core.c
--- kernel-2.6.28-20091602+0m5/block/blk-core.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/block/blk-core.c	2012-12-16 13:13:01.548330148 +0100
@@ -1246,7 +1246,7 @@ get_rq:
 		blk_plug_device(q);
 	add_request(q, req);
 out:
-	if (sync)
+	if (sync || (blk_queue_nonrot(q) && rq_data_dir(req) == READ))
 		__generic_unplug_device(q);
 	spin_unlock_irq(q->queue_lock);
 	return 0;
diff -Nurp kernel-2.6.28-20091602+0m5/block/genhd.c kernel-2.6.28-20093908+0m5/block/genhd.c
--- kernel-2.6.28-20091602+0m5/block/genhd.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/block/genhd.c	2012-12-16 13:13:01.548330148 +0100
@@ -692,6 +692,20 @@ static void disk_seqf_stop(struct seq_fi
 	}
 }
 
+void mtd_diskstats(struct seq_file *seqf);
+
+static void diskstats_seqf_stop(struct seq_file *seqf, void *v)
+{
+	struct class_dev_iter *iter = seqf->private;
+
+	/* stop is called even after start failed :-( */
+	if (iter) {
+		mtd_diskstats(seqf);
+		class_dev_iter_exit(iter);
+		kfree(iter);
+	}
+}
+
 static void *show_partition_start(struct seq_file *seqf, loff_t *pos)
 {
 	static void *p;
@@ -1010,7 +1024,7 @@ static int diskstats_show(struct seq_fil
 static const struct seq_operations diskstats_op = {
 	.start	= disk_seqf_start,
 	.next	= disk_seqf_next,
-	.stop	= disk_seqf_stop,
+	.stop	= diskstats_seqf_stop,
 	.show	= diskstats_show
 };
 
diff -Nurp kernel-2.6.28-20091602+0m5/Documentation/arm/OMAP/DSS kernel-2.6.28-20093908+0m5/Documentation/arm/OMAP/DSS
--- kernel-2.6.28-20091602+0m5/Documentation/arm/OMAP/DSS	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/Documentation/arm/OMAP/DSS	2012-12-16 13:13:01.548330148 +0100
@@ -133,10 +133,16 @@ name
 output_size	width,height
 position	x,y
 screen_width	width
+global_alpha   	global alpha 0-255 0=transparent 255=opaque
 
 /sys/devices/platform/omapdss/manager? directory:
-display		Destination display
+display				Destination display
 name
+alpha_blending_enabled		0=off 1=on
+color_key_enabled		0=off 1=on
+color_key_type			gfx-destination video-source
+color_key_value			0 to 2^24
+default_color			default background color RGB24 0 to 2^24
 
 /sys/devices/platform/omapdss/display? directory:
 ctrl_name	Controller name
diff -Nurp kernel-2.6.28-20091602+0m5/Documentation/DocBook/mac80211.tmpl kernel-2.6.28-20093908+0m5/Documentation/DocBook/mac80211.tmpl
--- kernel-2.6.28-20091602+0m5/Documentation/DocBook/mac80211.tmpl	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/Documentation/DocBook/mac80211.tmpl	2012-12-16 13:13:01.548330148 +0100
@@ -223,6 +223,17 @@ usage should require reading the full do
 !Finclude/net/mac80211.h ieee80211_key_flags
     </chapter>
 
+    <chapter id="powersave">
+      <title>Powersave support</title>
+!Pinclude/net/mac80211.h Powersave support
+    </chapter>
+
+    <chapter id="beacon-filter">
+      <title>Beacon filter support</title>
+!Pinclude/net/mac80211.h Beacon filter support
+!Finclude/net/mac80211.h ieee80211_beacon_loss
+    </chapter>
+
     <chapter id="qos">
       <title>Multiple queues and QoS support</title>
       <para>TBD</para>
diff -Nurp kernel-2.6.28-20091602+0m5/Documentation/filesystems/vfat.txt kernel-2.6.28-20093908+0m5/Documentation/filesystems/vfat.txt
--- kernel-2.6.28-20091602+0m5/Documentation/filesystems/vfat.txt	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/Documentation/filesystems/vfat.txt	2012-12-16 13:13:01.548330148 +0100
@@ -132,6 +132,11 @@ rodir	      -- FAT has the ATTR_RO (read
 		 If you want to use ATTR_RO as read-only flag even for
 		 the directory, set this option.
 
+errors=panic|continue|remount-ro
+	      -- specify FAT behavior on critical errors: panic, continue
+		 without doing anything or remopunt the partition in
+		 read-only mode (default behavior).
+
 <bool>: 0,1,yes,no,true,false
 
 TODO
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/bluetooth/hci_h4p/core.c kernel-2.6.28-20093908+0m5/drivers/bluetooth/hci_h4p/core.c
--- kernel-2.6.28-20091602+0m5/drivers/bluetooth/hci_h4p/core.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/bluetooth/hci_h4p/core.c	2012-12-16 13:13:01.552330147 +0100
@@ -29,12 +29,12 @@
 #include <linux/spinlock.h>
 #include <linux/serial_reg.h>
 #include <linux/skbuff.h>
-#include <linux/timer.h>
 #include <linux/device.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
 #include <linux/interrupt.h>
 #include <linux/gpio.h>
+#include <linux/timer.h>
 
 #include <mach/hardware.h>
 #include <mach/irqs.h>
@@ -46,8 +46,6 @@
 
 #include "hci_h4p.h"
 
-#define PM_TIMEOUT 200
-
 /* This should be used in function that cannot release clocks */
 static void hci_h4p_set_clk(struct hci_h4p_info *info, int *clock, int enable)
 {
@@ -61,9 +59,15 @@ static void hci_h4p_set_clk(struct hci_h
 		if (cpu_is_omap24xx() || cpu_is_omap34xx())
 			clk_enable(info->uart_iclk);
 #endif
+		if (atomic_read(&info->clk_users) == 0)
+			hci_h4p_restore_regs(info);
+		atomic_inc(&info->clk_users);
 	}
+
 	if (!enable && *clock) {
 		NBT_DBG_POWER("Disabling %p\n", clock);
+		if (atomic_dec_and_test(&info->clk_users))
+			hci_h4p_store_regs(info);
 		clk_disable(info->uart_fclk);
 #if defined(CONFIG_ARCH_OMAP2) || defined(CONFIG_ARCH_OMAP3)
 		if (cpu_is_omap24xx() || cpu_is_omap34xx())
@@ -75,49 +79,70 @@ static void hci_h4p_set_clk(struct hci_h
 	spin_unlock_irqrestore(&info->clocks_lock, flags);
 }
 
+static void hci_h4p_lazy_clock_release(unsigned long data)
+{
+	struct hci_h4p_info *info = (struct hci_h4p_info *)data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&info->lock, flags);
+	if (!info->tx_enabled)
+		hci_h4p_set_clk(info, &info->tx_clocks_en, 0);
+	spin_unlock_irqrestore(&info->lock, flags);
+}
+
 /* Power management functions */
-static void hci_h4p_disable_tx(struct hci_h4p_info *info)
+void hci_h4p_smart_idle(struct hci_h4p_info *info, bool enable)
 {
-	NBT_DBG_POWER("\n");
+	u8 v;
 
-	if (!info->pm_enabled)
-		return;
+	v = hci_h4p_inb(info, UART_OMAP_SYSC);
+	v &= ~(UART_OMAP_SYSC_IDLEMASK);
 
-	mod_timer(&info->tx_pm_timer, jiffies + msecs_to_jiffies(PM_TIMEOUT));
+	if (enable)
+		v |= UART_OMAP_SYSC_SMART_IDLE;
+	else
+		v |= UART_OMAP_SYSC_NO_IDLE;
+
+	hci_h4p_outb(info, UART_OMAP_SYSC, v);
 }
 
-void hci_h4p_enable_tx(struct hci_h4p_info *info)
+static void hci_h4p_disable_tx(struct hci_h4p_info *info)
 {
 	NBT_DBG_POWER("\n");
 
 	if (!info->pm_enabled)
 		return;
 
-	del_timer_sync(&info->tx_pm_timer);
-	if (info->tx_pm_enabled) {
-		info->tx_pm_enabled = 0;
-		hci_h4p_set_clk(info, &info->tx_clocks_en, 1);
-		gpio_set_value(info->bt_wakeup_gpio, 1);
-	}
+	/* Re-enable smart-idle */
+	hci_h4p_smart_idle(info, 1);
+
+	gpio_set_value(info->bt_wakeup_gpio, 0);
+	mod_timer(&info->lazy_release, jiffies + msecs_to_jiffies(100));
+	info->tx_enabled = 0;
 }
 
-static void hci_h4p_tx_pm_timer(unsigned long data)
+void hci_h4p_enable_tx(struct hci_h4p_info *info)
 {
-	struct hci_h4p_info *info;
-
+	unsigned long flags;
 	NBT_DBG_POWER("\n");
 
-	info = (struct hci_h4p_info *)data;
+	if (!info->pm_enabled)
+		return;
 
-	if (hci_h4p_inb(info, UART_LSR) & UART_LSR_TEMT) {
-		gpio_set_value(info->bt_wakeup_gpio, 0);
-		hci_h4p_set_clk(info, &info->tx_clocks_en, 0);
-		info->tx_pm_enabled = 1;
-	}
-	else {
-		mod_timer(&info->tx_pm_timer, jiffies +
-			  msecs_to_jiffies(PM_TIMEOUT));
-	}
+	spin_lock_irqsave(&info->lock, flags);
+	del_timer(&info->lazy_release);
+	hci_h4p_set_clk(info, &info->tx_clocks_en, 1);
+	info->tx_enabled = 1;
+	gpio_set_value(info->bt_wakeup_gpio, 1);
+	hci_h4p_outb(info, UART_IER, hci_h4p_inb(info, UART_IER) |
+		     UART_IER_THRI);
+	/*
+	 * Disable smart-idle as UART TX interrupts
+	 * are not wake-up capable
+	 */
+	hci_h4p_smart_idle(info, 0);
+
+	spin_unlock_irqrestore(&info->lock, flags);
 }
 
 static void hci_h4p_disable_rx(struct hci_h4p_info *info)
@@ -125,47 +150,32 @@ static void hci_h4p_disable_rx(struct hc
 	if (!info->pm_enabled)
 		return;
 
-	hci_h4p_set_auto_ctsrts(info, 0, UART_EFR_RTS);
-	hci_h4p_set_rts(info, 0);
-	mod_timer(&info->rx_pm_timer, jiffies + msecs_to_jiffies(PM_TIMEOUT));
+	info->rx_enabled = 0;
+
+	if (hci_h4p_inb(info, UART_LSR) & UART_LSR_DR)
+		return;
+
+	if (!(hci_h4p_inb(info, UART_LSR) & UART_LSR_TEMT))
+		return;
+
+	__hci_h4p_set_auto_ctsrts(info, 0, UART_EFR_RTS);
+	info->autorts = 0;
+	hci_h4p_set_clk(info, &info->rx_clocks_en, 0);
 }
 
 static void hci_h4p_enable_rx(struct hci_h4p_info *info)
 {
-	unsigned long flags;
-
 	if (!info->pm_enabled)
 		return;
 
-	del_timer_sync(&info->rx_pm_timer);
-	spin_lock_irqsave(&info->lock, flags);
-	if (info->rx_pm_enabled) {
-		hci_h4p_set_clk(info, &info->rx_clocks_en, 1);
-		hci_h4p_outb(info, UART_IER, hci_h4p_inb(info, UART_IER) |
-			     UART_IER_RDI);
-		info->rx_pm_enabled = 0;
-	}
-	__hci_h4p_set_auto_ctsrts(info, 1, UART_EFR_RTS);
-	spin_unlock_irqrestore(&info->lock, flags);
-}
+	hci_h4p_set_clk(info, &info->rx_clocks_en, 1);
+	info->rx_enabled = 1;
 
-static void hci_h4p_rx_pm_timer(unsigned long data)
-{
-	unsigned long flags;
-	struct hci_h4p_info *info = (struct hci_h4p_info *)data;
+	if (!(hci_h4p_inb(info, UART_LSR) & UART_LSR_TEMT))
+		return;
 
-	spin_lock_irqsave(&info->lock, flags);
-	if (!(hci_h4p_inb(info, UART_LSR) & UART_LSR_DR)) {
-		hci_h4p_outb(info, UART_IER, hci_h4p_inb(info, UART_IER) &
-			     ~UART_IER_RDI);
-		hci_h4p_set_clk(info, &info->rx_clocks_en, 0);
-		info->rx_pm_enabled = 1;
-	}
-	else {
-		mod_timer(&info->rx_pm_timer, jiffies +
-			  msecs_to_jiffies(PM_TIMEOUT));
-	}
-	spin_unlock_irqrestore(&info->lock, flags);
+	__hci_h4p_set_auto_ctsrts(info, 1, UART_EFR_RTS);
+	info->autorts = 1;
 }
 
 /* Negotiation functions */
@@ -181,7 +191,6 @@ int hci_h4p_send_alive_packet(struct hci
 	/* Keep reference to buffer so we can reuse it */
 	info->alive_cmd_skb = skb_get(info->alive_cmd_skb);
 
-	hci_h4p_enable_tx(info);
 	skb_queue_tail(&info->txq, info->alive_cmd_skb);
 	spin_lock_irqsave(&info->lock, flags);
 	hci_h4p_outb(info, UART_IER, hci_h4p_inb(info, UART_IER) |
@@ -214,6 +223,7 @@ static int hci_h4p_send_negotiation(stru
 
 	hci_h4p_change_speed(info, INIT_SPEED);
 
+	hci_h4p_set_rts(info, 1);
 	info->init_error = 0;
 	init_completion(&info->init_completion);
 	skb_queue_tail(&info->txq, skb);
@@ -230,6 +240,7 @@ static int hci_h4p_send_negotiation(stru
 		return info->init_error;
 
 	/* Change to operational settings */
+	hci_h4p_set_auto_ctsrts(info, 0, UART_EFR_RTS);
 	hci_h4p_set_rts(info, 0);
 	hci_h4p_change_speed(info, MAX_BAUD_RATE);
 
@@ -237,11 +248,7 @@ static int hci_h4p_send_negotiation(stru
 	if (err < 0)
 		return err;
 
-	hci_h4p_set_auto_ctsrts(info, 1, UART_EFR_CTS | UART_EFR_RTS);
-	info->pm_enabled = 1;
-	info->tx_pm_enabled = 0;
-	info->rx_pm_enabled = 0;
-
+	hci_h4p_set_auto_ctsrts(info, 1, UART_EFR_RTS);
 	init_completion(&info->init_completion);
 	err = hci_h4p_send_alive_packet(info);
 
@@ -292,6 +299,9 @@ static int hci_h4p_get_hdr_len(struct hc
 	case H4_ALIVE_PKT:
 		retval = 3;
 		break;
+	case H4_RADIO_PKT:
+		retval = H4_RADIO_HDR_SIZE;
+		break;
 	default:
 		dev_err(info->dev, "Unknown H4 packet type 0x%.2x\n", pkt_type);
 		retval = -1;
@@ -308,6 +318,7 @@ static unsigned int hci_h4p_get_data_len
 	struct hci_event_hdr *evt_hdr;
 	struct hci_acl_hdr *acl_hdr;
 	struct hci_sco_hdr *sco_hdr;
+	struct hci_h4p_radio_hdr *radio_hdr;
 
 	switch (bt_cb(skb)->pkt_type) {
 	case H4_EVT_PKT:
@@ -322,9 +333,11 @@ static unsigned int hci_h4p_get_data_len
 		sco_hdr = (struct hci_sco_hdr *)skb->data;
 		retval = sco_hdr->dlen;
 		break;
-	case H4_NEG_PKT:
-		retval = 0;
+	case H4_RADIO_PKT:
+		radio_hdr = (struct hci_h4p_radio_hdr *)skb->data;
+		retval = radio_hdr->dlen;
 		break;
+	case H4_NEG_PKT:
 	case H4_ALIVE_PKT:
 		retval = 0;
 		break;
@@ -368,10 +381,10 @@ static inline void hci_h4p_handle_byte(s
 							      info->rx_skb);
 			if (info->rx_count > skb_tailroom(info->rx_skb)) {
 				dev_err(info->dev, "Too long frame.\n");
-				kfree_skb(info->rx_skb);
-				info->rx_skb = NULL;
 				info->garbage_bytes = info->rx_count -
 					skb_tailroom(info->rx_skb);
+				kfree_skb(info->rx_skb);
+				info->rx_skb = NULL;
 				break;
 			}
 			info->rx_state = WAIT_FOR_DATA;
@@ -429,7 +442,7 @@ static void hci_h4p_rx_tasklet(unsigned
 			if (!info->rx_skb) {
 				dev_err(info->dev,
 					"No memory for new packet\n");
-				goto finish_task;
+				goto finish_rx;
 			}
 			info->rx_state = WAIT_FOR_PKT_TYPE;
 			info->rx_skb->dev = (void *)info->hdev;
@@ -439,7 +452,18 @@ static void hci_h4p_rx_tasklet(unsigned
 		hci_h4p_handle_byte(info, byte);
 	}
 
-finish_task:
+	if (!info->rx_enabled) {
+		if (hci_h4p_inb(info, UART_LSR) & UART_LSR_TEMT &&
+						  info->autorts) {
+			__hci_h4p_set_auto_ctsrts(info, 0 , UART_EFR_RTS);
+			info->autorts = 0;
+		}
+		/* Flush posted write to avoid spurious interrupts */
+		hci_h4p_inb(info, UART_OMAP_SCR);
+		hci_h4p_set_clk(info, &info->rx_clocks_en, 0);
+	}
+
+finish_rx:
 	NBT_DBG_TRANSFER_NF("\n");
 	NBT_DBG("rx_ended\n");
 }
@@ -447,19 +471,48 @@ finish_task:
 static void hci_h4p_tx_tasklet(unsigned long data)
 {
 	unsigned int sent = 0;
-	unsigned long flags;
 	struct sk_buff *skb;
 	struct hci_h4p_info *info = (struct hci_h4p_info *)data;
 
 	NBT_DBG("tasklet woke up\n");
 	NBT_DBG_TRANSFER("tx_tasklet woke up\n data ");
 
+	if (info->autorts != info->rx_enabled) {
+		if (hci_h4p_inb(info, UART_LSR) & UART_LSR_TEMT) {
+			if (info->autorts && !info->rx_enabled) {
+				__hci_h4p_set_auto_ctsrts(info, 0,
+							  UART_EFR_RTS);
+				info->autorts = 0;
+			}
+			if (!info->autorts && info->rx_enabled) {
+				__hci_h4p_set_auto_ctsrts(info, 1,
+							  UART_EFR_RTS);
+				info->autorts = 1;
+			}
+		} else {
+			hci_h4p_outb(info, UART_OMAP_SCR,
+				     hci_h4p_inb(info, UART_OMAP_SCR) |
+				     UART_OMAP_SCR_EMPTY_THR);
+			goto finish_tx;
+		}
+	}
+
 	skb = skb_dequeue(&info->txq);
 	if (!skb) {
 		/* No data in buffer */
 		NBT_DBG("skb ready\n");
-		hci_h4p_disable_tx(info);
-		return;
+		if (hci_h4p_inb(info, UART_LSR) & UART_LSR_TEMT) {
+			hci_h4p_outb(info, UART_IER,
+				     hci_h4p_inb(info, UART_IER) &
+				     ~UART_IER_THRI);
+			hci_h4p_inb(info, UART_OMAP_SCR);
+			hci_h4p_disable_tx(info);
+			return;
+		} else
+			hci_h4p_outb(info, UART_OMAP_SCR,
+				     hci_h4p_inb(info, UART_OMAP_SCR) |
+				     UART_OMAP_SCR_EMPTY_THR);
+		goto finish_tx;
 	}
 
 	/* Copy data to tx fifo */
@@ -479,10 +532,15 @@ static void hci_h4p_tx_tasklet(unsigned
 		skb_queue_head(&info->txq, skb);
 	}
 
-	spin_lock_irqsave(&info->lock, flags);
+	hci_h4p_outb(info, UART_OMAP_SCR, hci_h4p_inb(info, UART_OMAP_SCR) &
+						     ~UART_OMAP_SCR_EMPTY_THR);
 	hci_h4p_outb(info, UART_IER, hci_h4p_inb(info, UART_IER) |
 						 UART_IER_THRI);
-	spin_unlock_irqrestore(&info->lock, flags);
+
+finish_tx:
+	/* Flush posted write to avoid spurious interrupts */
+	hci_h4p_inb(info, UART_OMAP_SCR);
+
 }
 
 static irqreturn_t hci_h4p_interrupt(int irq, void *data)
@@ -490,13 +548,11 @@ static irqreturn_t hci_h4p_interrupt(int
 	struct hci_h4p_info *info = (struct hci_h4p_info *)data;
 	u8 iir, msr;
 	int ret;
-	unsigned long flags;
 
 	ret = IRQ_NONE;
 
 	iir = hci_h4p_inb(info, UART_IIR);
 	if (iir & UART_IIR_NO_INT) {
-		dev_err(info->dev, "Interrupt but no reason irq 0x%.2x\n", iir);
 		return IRQ_HANDLED;
 	}
 
@@ -520,10 +576,6 @@ static irqreturn_t hci_h4p_interrupt(int
 	}
 
 	if (iir == UART_IIR_THRI) {
-		spin_lock_irqsave(&info->lock, flags);
-		hci_h4p_outb(info, UART_IER, hci_h4p_inb(info, UART_IER) &
-							 ~UART_IER_THRI);
-		spin_unlock_irqrestore(&info->lock, flags);
 		hci_h4p_tx_tasklet((unsigned long)data);
 		ret = IRQ_HANDLED;
 	}
@@ -549,10 +601,9 @@ static irqreturn_t hci_h4p_wakeup_interr
 	NBT_DBG_POWER("gpio interrupt %d\n", should_wakeup);
 
 	/* Check if wee have missed some interrupts */
-	if (info->host_wu == should_wakeup)
+	if (info->rx_enabled == should_wakeup)
 		return IRQ_HANDLED;
 
-	info->host_wu = should_wakeup;
 	if (should_wakeup) {
 		hci_h4p_enable_rx(info);
 	} else {
@@ -566,8 +617,12 @@ static int hci_h4p_reset(struct hci_h4p_
 {
 	int err;
 
+	err = hci_h4p_reset_uart(info);
+	if (err < 0) {
+		dev_err(info->dev, "Uart reset failed\n");
+		return err;
+	}
 	hci_h4p_init_uart(info);
-	hci_h4p_set_auto_ctsrts(info, 0, UART_EFR_CTS | UART_EFR_RTS);
 	hci_h4p_set_rts(info, 0);
 
 	gpio_set_value(info->reset_gpio, 0);
@@ -603,6 +658,7 @@ static int hci_h4p_hci_open(struct hci_d
 	int err;
 	struct sk_buff *neg_cmd_skb;
 	struct sk_buff_head fw_queue;
+	unsigned long flags;
 
 	info = hdev->driver_data;
 
@@ -626,26 +682,27 @@ static int hci_h4p_hci_open(struct hci_d
 		goto err_clean;
 	}
 
-	hci_h4p_set_clk(info, &info->tx_clocks_en, 1);
-	hci_h4p_set_clk(info, &info->rx_clocks_en, 1);
+	info->rx_enabled = 1;
 	info->rx_state = WAIT_FOR_PKT_TYPE;
 	info->rx_count = 0;
 	info->garbage_bytes = 0;
 	info->rx_skb = NULL;
 	info->pm_enabled = 0;
 	init_completion(&info->fw_completion);
+	hci_h4p_set_clk(info, &info->tx_clocks_en, 1);
+	hci_h4p_set_clk(info, &info->rx_clocks_en, 1);
 
 	err = hci_h4p_reset(info);
 	if (err < 0)
 		goto err_clean;
 
+	hci_h4p_set_auto_ctsrts(info, 1, UART_EFR_CTS | UART_EFR_RTS);
+	info->autorts = 1;
 	err = hci_h4p_send_negotiation(info, neg_cmd_skb);
 	neg_cmd_skb = NULL;
 	if (err < 0)
 		goto err_clean;
 
-	hci_h4p_set_auto_ctsrts(info, 1, UART_EFR_CTS | UART_EFR_RTS);
-	info->host_wu = gpio_get_value(info->host_wakeup_gpio);
 
 	err = hci_h4p_send_fw(info, &fw_queue);
 	if (err < 0) {
@@ -653,6 +710,15 @@ static int hci_h4p_hci_open(struct hci_d
 		goto err_clean;
 	}
 
+	info->pm_enabled = 1;
+
+	spin_lock_irqsave(&info->lock, flags);
+	info->rx_enabled = gpio_get_value(info->host_wakeup_gpio);
+	hci_h4p_set_clk(info, &info->rx_clocks_en, info->rx_enabled);
+	spin_unlock_irqrestore(&info->lock, flags);
+
+	hci_h4p_set_clk(info, &info->tx_clocks_en, 0);
+
 	kfree_skb(info->alive_cmd_skb);
 	info->alive_cmd_skb = NULL;
 	set_bit(HCI_RUNNING, &hdev->flags);
@@ -662,9 +728,8 @@ static int hci_h4p_hci_open(struct hci_d
 
 err_clean:
 	hci_h4p_hci_flush(hdev);
-	del_timer_sync(&info->tx_pm_timer);
-	del_timer_sync(&info->rx_pm_timer);
 	hci_h4p_reset_uart(info);
+	del_timer_sync(&info->lazy_release);
 	hci_h4p_set_clk(info, &info->tx_clocks_en, 0);
 	hci_h4p_set_clk(info, &info->rx_clocks_en, 0);
 	gpio_set_value(info->reset_gpio, 0);
@@ -687,11 +752,10 @@ static int hci_h4p_hci_close(struct hci_
 		return 0;
 
 	hci_h4p_hci_flush(hdev);
-	del_timer_sync(&info->tx_pm_timer);
-	del_timer_sync(&info->rx_pm_timer);
 	hci_h4p_set_clk(info, &info->tx_clocks_en, 1);
 	hci_h4p_set_clk(info, &info->rx_clocks_en, 1);
 	hci_h4p_reset_uart(info);
+	del_timer_sync(&info->lazy_release);
 	hci_h4p_set_clk(info, &info->tx_clocks_en, 0);
 	hci_h4p_set_clk(info, &info->rx_clocks_en, 0);
 	gpio_set_value(info->reset_gpio, 0);
@@ -709,7 +773,6 @@ static int hci_h4p_hci_send_frame(struct
 {
 	struct hci_h4p_info *info;
 	struct hci_dev *hdev = (struct hci_dev *)skb->dev;
-	unsigned long flags;
 	int err = 0;
 
 	if (!hdev) {
@@ -743,17 +806,14 @@ static int hci_h4p_hci_send_frame(struct
 	/* We should allways send word aligned data to h4+ devices */
 	if (skb->len % 2) {
 		err = skb_pad(skb, 1);
-		*skb_put(skb, 1) = 0x00;
+		if (!err)
+			*skb_put(skb, 1) = 0x00;
 	}
 	if (err)
 		return err;
 
-	hci_h4p_enable_tx(info);
 	skb_queue_tail(&info->txq, skb);
-	spin_lock_irqsave(&info->lock, flags);
-	hci_h4p_outb(info, UART_IER, hci_h4p_inb(info, UART_IER) |
-		     UART_IER_THRI);
-	spin_unlock_irqrestore(&info->lock, flags);
+	hci_h4p_enable_tx(info);
 
 	return 0;
 }
@@ -811,8 +871,8 @@ static int hci_h4p_probe(struct platform
 
 	info->dev = &pdev->dev;
 	info->pm_enabled = 0;
-	info->tx_pm_enabled = 0;
-	info->rx_pm_enabled = 0;
+	info->tx_enabled = 1;
+	info->rx_enabled = 1;
 	info->garbage_bytes = 0;
 	info->tx_clocks_en = 0;
 	info->rx_clocks_en = 0;
@@ -820,12 +880,6 @@ static int hci_h4p_probe(struct platform
 	spin_lock_init(&info->lock);
 	spin_lock_init(&info->clocks_lock);
 	skb_queue_head_init(&info->txq);
-	init_timer(&info->tx_pm_timer);
-	info->tx_pm_timer.function = hci_h4p_tx_pm_timer;
-	info->tx_pm_timer.data = (unsigned long)info;
-	init_timer(&info->rx_pm_timer);
-	info->rx_pm_timer.function = hci_h4p_rx_pm_timer;
-	info->rx_pm_timer.data = (unsigned long)info;
 
 	if (pdev->dev.platform_data == NULL) {
 		dev_err(&pdev->dev, "Could not get Bluetooth config data\n");
@@ -850,8 +904,7 @@ static int hci_h4p_probe(struct platform
 	if (err < 0) {
 		dev_err(&pdev->dev, "Cannot get GPIO line %d\n",
 			info->reset_gpio);
-		kfree(info);
-		goto cleanup;
+		goto cleanup_setup;
 	}
 
 	err = gpio_request(info->bt_wakeup_gpio, "bt_wakeup");
@@ -860,8 +913,7 @@ static int hci_h4p_probe(struct platform
 		dev_err(info->dev, "Cannot get GPIO line 0x%d",
 			info->bt_wakeup_gpio);
 		gpio_free(info->reset_gpio);
-		kfree(info);
-		goto cleanup;
+		goto cleanup_setup;
 	}
 
 	err = gpio_request(info->host_wakeup_gpio, "host_wakeup");
@@ -871,8 +923,7 @@ static int hci_h4p_probe(struct platform
 		       info->host_wakeup_gpio);
 		gpio_free(info->reset_gpio);
 		gpio_free(info->bt_wakeup_gpio);
-		kfree(info);
-		goto cleanup;
+		goto cleanup_setup;
 	}
 
 	gpio_direction_output(info->reset_gpio, 0);
@@ -919,7 +970,8 @@ static int hci_h4p_probe(struct platform
 	}
 
 	info->irq = irq;
-	err = request_irq(irq, hci_h4p_interrupt, 0, "hci_h4p", (void *)info);
+	err = request_irq(irq, hci_h4p_interrupt, IRQF_DISABLED, "hci_h4p",
+			  info);
 	if (err < 0) {
 		dev_err(info->dev, "hci_h4p: unable to get IRQ %d\n", irq);
 		goto cleanup;
@@ -927,7 +979,7 @@ static int hci_h4p_probe(struct platform
 
 	err = request_irq(gpio_to_irq(info->host_wakeup_gpio),
 			  hci_h4p_wakeup_interrupt,  IRQF_TRIGGER_FALLING |
-			  IRQF_TRIGGER_RISING,
+			  IRQF_TRIGGER_RISING | IRQF_DISABLED,
 			  "hci_h4p_wkup", info);
 	if (err < 0) {
 		dev_err(info->dev, "hci_h4p: unable to get wakeup IRQ %d\n",
@@ -945,16 +997,20 @@ static int hci_h4p_probe(struct platform
 		goto cleanup;
 	}
 
+	init_timer_deferrable(&info->lazy_release);
+	info->lazy_release.function = hci_h4p_lazy_clock_release;
+	info->lazy_release.data = (unsigned long)info;
 	hci_h4p_set_clk(info, &info->tx_clocks_en, 1);
-	err = hci_h4p_init_uart(info);
+	err = hci_h4p_reset_uart(info);
 	if (err < 0)
 		goto cleanup_irq;
-	hci_h4p_set_auto_ctsrts(info, 0, UART_EFR_CTS | UART_EFR_RTS);
+	hci_h4p_init_uart(info);
 	hci_h4p_set_rts(info, 0);
 	err = hci_h4p_reset(info);
 	hci_h4p_reset_uart(info);
 	if (err < 0)
 		goto cleanup_irq;
+	gpio_set_value(info->reset_gpio, 0);
 	hci_h4p_set_clk(info, &info->tx_clocks_en, 0);
 
 	platform_set_drvdata(pdev, info);
@@ -963,7 +1019,6 @@ static int hci_h4p_probe(struct platform
 		dev_err(info->dev, "failed to register hci_h4p hci device\n");
 		goto cleanup_irq;
 	}
-	gpio_set_value(info->reset_gpio, 0);
 
 	return 0;
 
@@ -975,8 +1030,10 @@ cleanup:
 	gpio_free(info->reset_gpio);
 	gpio_free(info->bt_wakeup_gpio);
 	gpio_free(info->host_wakeup_gpio);
-	kfree(info);
 
+cleanup_setup:
+
+	kfree(info);
 	return err;
 
 }
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/bluetooth/hci_h4p/fw-bcm.c kernel-2.6.28-20093908+0m5/drivers/bluetooth/hci_h4p/fw-bcm.c
--- kernel-2.6.28-20091602+0m5/drivers/bluetooth/hci_h4p/fw-bcm.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/bluetooth/hci_h4p/fw-bcm.c	2012-12-16 13:13:01.552330147 +0100
@@ -97,7 +97,6 @@ void hci_h4p_bcm_parse_fw_event(struct h
 		}
 	}
 
-	hci_h4p_enable_tx(info);
 	skb_queue_tail(&info->txq, fw_skb);
 	spin_lock_irqsave(&info->lock, flags);
 	hci_h4p_outb(info, UART_IER, hci_h4p_inb(info, UART_IER) |
@@ -124,9 +123,15 @@ int hci_h4p_bcm_send_fw(struct hci_h4p_i
 		return -ENODATA;
 
 	NBT_DBG_FW("Sending commands\n");
+
+	/*
+	 * Disable smart-idle as UART TX interrupts
+	 * are not wake-up capable
+	 */
+	hci_h4p_smart_idle(info, 0);
+
 	/* Check if this is bd_address packet */
 	init_completion(&info->fw_completion);
-	hci_h4p_enable_tx(info);
 	skb_queue_tail(&info->txq, skb);
 	spin_lock_irqsave(&info->lock, flags);
 	hci_h4p_outb(info, UART_IER, hci_h4p_inb(info, UART_IER) |
@@ -150,11 +155,6 @@ int hci_h4p_bcm_send_fw(struct hci_h4p_i
 	hci_h4p_set_auto_ctsrts(info, 0, UART_EFR_RTS);
 	hci_h4p_set_rts(info, 0);
 	hci_h4p_change_speed(info, BC4_MAX_BAUD_RATE);
-	if (hci_h4p_wait_for_cts(info, 1, 100)) {
-		dev_err(info->dev,
-			"cts didn't go down after final speed change\n");
-		return -ETIMEDOUT;
-	}
 	hci_h4p_set_auto_ctsrts(info, 1, UART_EFR_RTS);
 
 	return 0;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/bluetooth/hci_h4p/hci_h4p.h kernel-2.6.28-20093908+0m5/drivers/bluetooth/hci_h4p/hci_h4p.h
--- kernel-2.6.28-20091602+0m5/drivers/bluetooth/hci_h4p/hci_h4p.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/bluetooth/hci_h4p/hci_h4p.h	2012-12-16 13:13:01.552330147 +0100
@@ -37,6 +37,13 @@
 #define UART_OMAP_SSR_WAKEUP	0x02
 #define UART_OMAP_SSR_TXFULL	0x01
 
+#define UART_OMAP_SYSC_IDLEMODE		0x03
+#define UART_OMAP_SYSC_IDLEMASK		(3 << UART_OMAP_SYSC_IDLEMODE)
+
+#define UART_OMAP_SYSC_FORCE_IDLE	(0 << UART_OMAP_SYSC_IDLEMODE)
+#define UART_OMAP_SYSC_NO_IDLE		(1 << UART_OMAP_SYSC_IDLEMODE)
+#define UART_OMAP_SYSC_SMART_IDLE	(2 << UART_OMAP_SYSC_IDLEMODE)
+
 #if 0
 #define NBT_DBG(fmt, arg...)  printk("%s: " fmt "" , __FUNCTION__ , ## arg)
 #else
@@ -74,6 +81,7 @@
 #endif
 
 struct hci_h4p_info {
+	struct timer_list lazy_release;
 	struct hci_dev *hdev;
 	spinlock_t lock;
 
@@ -87,7 +95,6 @@ struct hci_h4p_info {
 	u8 reset_gpio;
 	u8 bt_sysclk;
 
-
 	struct sk_buff_head fw_queue;
 	struct sk_buff *alive_cmd_skb;
 	struct completion init_completion;
@@ -103,19 +110,28 @@ struct hci_h4p_info {
 	unsigned long garbage_bytes;
 
 	int pm_enabled;
-	int tx_pm_enabled;
-	int rx_pm_enabled;
-	int host_wu;
-	struct timer_list tx_pm_timer;
-	struct timer_list rx_pm_timer;
+	int tx_enabled;
+	int autorts;
+	int rx_enabled;
 
 	int tx_clocks_en;
 	int rx_clocks_en;
 	spinlock_t clocks_lock;
 	struct clk *uart_iclk;
 	struct clk *uart_fclk;
+	atomic_t clk_users;
+	u16 dll;
+	u16 dlh;
+	u16 ier;
+	u16 mdr1;
+	u16 efr;
 };
 
+struct hci_h4p_radio_hdr {
+	__u8 evt;
+	__u8 dlen;
+} __attribute__ ((packed));
+
 #define MAX_BAUD_RATE		921600
 #define BC4_MAX_BAUD_RATE	3692300
 #define UART_CLOCK		48000000
@@ -125,6 +141,7 @@ struct hci_h4p_info {
 #define INIT_SPEED		120000
 
 #define H4_TYPE_SIZE		1
+#define H4_RADIO_HDR_SIZE	2
 
 /* H4+ packet types */
 #define H4_CMD_PKT		0x01
@@ -133,6 +150,7 @@ struct hci_h4p_info {
 #define H4_EVT_PKT		0x04
 #define H4_NEG_PKT		0x06
 #define H4_ALIVE_PKT		0x07
+#define H4_RADIO_PKT		0x08
 
 /* TX states */
 #define WAIT_FOR_PKT_TYPE	1
@@ -182,7 +200,10 @@ void __hci_h4p_set_auto_ctsrts(struct hc
 void hci_h4p_set_auto_ctsrts(struct hci_h4p_info *info, int on, u8 which);
 void hci_h4p_change_speed(struct hci_h4p_info *info, unsigned long speed);
 int hci_h4p_reset_uart(struct hci_h4p_info *info);
-int hci_h4p_init_uart(struct hci_h4p_info *info);
+void hci_h4p_init_uart(struct hci_h4p_info *info);
 void hci_h4p_enable_tx(struct hci_h4p_info *info);
+void hci_h4p_store_regs(struct hci_h4p_info *info);
+void hci_h4p_restore_regs(struct hci_h4p_info *info);
+void hci_h4p_smart_idle(struct hci_h4p_info *info, bool enable);
 
 #endif /* __DRIVERS_BLUETOOTH_HCI_H4P_H */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/bluetooth/hci_h4p/uart.c kernel-2.6.28-20093908+0m5/drivers/bluetooth/hci_h4p/uart.c
--- kernel-2.6.28-20091602+0m5/drivers/bluetooth/hci_h4p/uart.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/bluetooth/hci_h4p/uart.c	2012-12-16 13:13:01.552330147 +0100
@@ -138,17 +138,44 @@ int hci_h4p_reset_uart(struct hci_h4p_in
 	return 0;
 }
 
-int hci_h4p_init_uart(struct hci_h4p_info *info)
+
+void hci_h4p_store_regs(struct hci_h4p_info *info)
 {
-	int err;
-	u8 mcr, efr;
+	u16 lcr = 0;
 
-	err = hci_h4p_reset_uart(info);
-	if (err < 0)
-		return err;
+	lcr = hci_h4p_inb(info, UART_LCR);
+	hci_h4p_outb(info, UART_LCR, 0xBF);
+	info->dll = hci_h4p_inb(info, UART_DLL);
+	info->dlh = hci_h4p_inb(info, UART_DLM);
+	info->efr = hci_h4p_inb(info, UART_EFR);
+	hci_h4p_outb(info, UART_LCR, lcr);
+	info->mdr1 = hci_h4p_inb(info, UART_OMAP_MDR1);
+	info->ier = hci_h4p_inb(info, UART_IER);
+}
+
+void hci_h4p_restore_regs(struct hci_h4p_info *info)
+{
+	u16 lcr = 0;
+
+	hci_h4p_init_uart(info);
+
+	hci_h4p_outb(info, UART_OMAP_MDR1, 7);
+	lcr = hci_h4p_inb(info, UART_LCR);
+	hci_h4p_outb(info, UART_LCR, 0xBF);
+	hci_h4p_outb(info, UART_DLL, info->dll);    /* Set speed */
+	hci_h4p_outb(info, UART_DLM, info->dlh);
+	hci_h4p_outb(info, UART_EFR, info->efr);
+	hci_h4p_outb(info, UART_LCR, lcr);
+	hci_h4p_outb(info, UART_OMAP_MDR1, info->mdr1);
+	hci_h4p_outb(info, UART_IER, info->ier);
+}
+
+void hci_h4p_init_uart(struct hci_h4p_info *info)
+{
+	u8 mcr, efr;
 
 	/* Enable and setup FIFO */
-	hci_h4p_outb(info, UART_OMAP_MDR1, 0x00); /* Make sure UART mode is enabled */
+	hci_h4p_outb(info, UART_OMAP_MDR1, 0x00);
 
 	hci_h4p_outb(info, UART_LCR, 0xbf);
 	efr = hci_h4p_inb(info, UART_EFR);
@@ -159,7 +186,7 @@ int hci_h4p_init_uart(struct hci_h4p_inf
 	hci_h4p_outb(info, UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR |
 			UART_FCR_CLEAR_XMIT | (3 << 6) | (0 << 4));
 	hci_h4p_outb(info, UART_LCR, 0xbf);
-	hci_h4p_outb(info, UART_TI752_TLR, 0xe1);
+	hci_h4p_outb(info, UART_TI752_TLR, 0xed);
 	hci_h4p_outb(info, UART_TI752_TCR, 0xef);
 	hci_h4p_outb(info, UART_EFR, efr);
 	hci_h4p_outb(info, UART_LCR, UART_LCR_DLAB);
@@ -167,6 +194,4 @@ int hci_h4p_init_uart(struct hci_h4p_inf
 	hci_h4p_outb(info, UART_LCR, UART_LCR_WLEN8);
 	hci_h4p_outb(info, UART_IER, UART_IER_RDI);
 	hci_h4p_outb(info, UART_OMAP_SYSC, (1 << 0) | (1 << 2) | (2 << 3));
-
-	return 0;
 }
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/cpuidle/governors/menu.c kernel-2.6.28-20093908+0m5/drivers/cpuidle/governors/menu.c
--- kernel-2.6.28-20091602+0m5/drivers/cpuidle/governors/menu.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/cpuidle/governors/menu.c	2012-12-16 13:13:01.552330147 +0100
@@ -13,6 +13,7 @@
 #include <linux/ktime.h>
 #include <linux/hrtimer.h>
 #include <linux/tick.h>
+#include <mach/pm.h>
 
 #define BREAK_FUZZ	4	/* 4 us */
 
@@ -36,6 +37,8 @@ static int menu_select(struct cpuidle_de
 	struct menu_device *data = &__get_cpu_var(menu_devices);
 	int latency_req = pm_qos_requirement(PM_QOS_CPU_DMA_LATENCY);
 	int i;
+	int device_not_idle;
+	struct timespec t;
 
 	/* Special case when user has set very strict latency requirement */
 	if (unlikely(latency_req == 0)) {
@@ -44,8 +47,11 @@ static int menu_select(struct cpuidle_de
 	}
 
 	/* determine the expected residency time */
+	t = ktime_to_timespec(tick_nohz_get_sleep_length());
 	data->expected_us =
-		(u32) ktime_to_ns(tick_nohz_get_sleep_length()) / 1000;
+		t.tv_sec * USEC_PER_SEC + t.tv_nsec / NSEC_PER_USEC;
+
+	device_not_idle = !pm_check_idle();
 
 	/* find the deepest idle state that satisfies our constraints */
 	for (i = CPUIDLE_DRIVER_STATE_START + 1; i < dev->state_count; i++) {
@@ -53,7 +59,8 @@ static int menu_select(struct cpuidle_de
 
 		if (s->target_residency > data->expected_us)
 			break;
-		if (s->target_residency > data->predicted_us)
+		if (device_not_idle &&
+		    s->target_residency > data->predicted_us)
 			break;
 		if (s->exit_latency > latency_req)
 			break;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/dynload/cload.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/dynload/cload.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/dynload/cload.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/dynload/cload.c	2012-12-16 13:13:01.552330147 +0100
@@ -177,18 +177,14 @@ int Dynamic_Load_Module(struct Dynamic_L
 
 		init_module_handle(&dl_state);
 
+		/* dl_state.myio is init or 0 at this point. */
 		if (dl_state.myio) {
 			if ((!dl_state.dload_errcount) &&
-			   (dl_state.dfile_hdr.df_entry_secn != DN_UNDEF)) {
-				if (init != NULL) {
-					if (!init->execute(init,
-					   dl_state.dfile_hdr.df_entrypt))
-						dload_error(&dl_state,
-						    "Init->Execute Failed");
-				} else {
-					dload_error(&dl_state, "init is NULL");
-				}
-			}
+			    (dl_state.dfile_hdr.df_entry_secn != DN_UNDEF) &&
+			    (!init->execute(init,
+					    dl_state.dfile_hdr.df_entrypt)))
+				dload_error(&dl_state,
+					    "Init->Execute Failed");
 			init->release(init);
 		}
 
@@ -287,12 +283,13 @@ Dynamic_Open_Module(struct Dynamic_Loade
 
 		init_module_handle(&dl_state);
 
+		/* dl_state.myio is either 0 or init at this point. */
 		if (dl_state.myio) {
-			if ((!dl_state.dload_errcount)
-			    && (dl_state.dfile_hdr.df_entry_secn != DN_UNDEF))
-				if (!init->execute(init,
-				   dl_state.dfile_hdr.df_entrypt))
-					dload_error(&dl_state,
+			if ((!dl_state.dload_errcount) &&
+			    (dl_state.dfile_hdr.df_entry_secn != DN_UNDEF) &&
+			    (!init->execute(init,
+					    dl_state.dfile_hdr.df_entrypt)))
+				dload_error(&dl_state,
 					    "Init->Execute Failed");
 			init->release(init);
 		}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/gen/gs.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/gen/gs.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/gen/gs.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/gen/gs.c	2012-12-16 13:13:01.556330147 +0100
@@ -101,8 +101,6 @@ void GS_init(void)
 	static bool curInit;
 
 	if (curInit == false) {
-		curInit = true;
-
-		MEM_Init();
+		curInit = MEM_Init(); /* which can't fail currently. */
 	}
 }
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/hw_dspssC64P.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/hw_dspssC64P.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/hw_dspssC64P.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/hw_dspssC64P.c	2012-12-16 13:13:01.556330147 +0100
@@ -27,13 +27,14 @@
 
 /* PROJECT SPECIFIC INCLUDE FILES */
 #include <GlobalTypes.h>
+#include <linux/io.h>
 #include <hw_defs.h>
 #include <hw_dspssC64P.h>
 #include <IVA2RegAcM.h>
 #include <IPIAccInt.h>
 
 /* HW FUNCTIONS */
-HW_STATUS HW_DSPSS_BootModeSet(const u32 baseAddress,
+HW_STATUS HW_DSPSS_BootModeSet(const void __iomem *baseAddress,
 		      enum HW_DSPSYSC_BootMode_t bootMode,
 		      const u32 bootAddress)
 {
@@ -43,13 +44,13 @@ HW_STATUS HW_DSPSS_BootModeSet(const u32
 
 	/* if Boot mode it DIRECT BOOT, check that the bootAddress is
 	 * aligned to atleast 1K :: TODO */
-	WR_MEM_32_VOLATILE((baseAddress) + offset, bootMode);
+	__raw_writel(bootMode, (baseAddress) + offset);
 
 	offset = SYSC_IVA2BOOTADDR_OFFSET;
 
 	alignedBootAddr = bootAddress & SYSC_IVA2BOOTADDR_MASK;
 
-	WR_MEM_32_VOLATILE((baseAddress) + offset, alignedBootAddr);
+	__raw_writel(alignedBootAddr, (baseAddress) + offset);
 
 	return status;
 }
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/hw_dspssC64P.h kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/hw_dspssC64P.h
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/hw_dspssC64P.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/hw_dspssC64P.h	2012-12-16 13:13:01.556330147 +0100
@@ -41,7 +41,7 @@
 
 #define HW_DSP_IDLEBOOT_ADDR   0x007E0000
 
-	extern HW_STATUS HW_DSPSS_BootModeSet(const u32 baseAddress,
+	extern HW_STATUS HW_DSPSS_BootModeSet(const void __iomem *baseAddress,
 					enum HW_DSPSYSC_BootMode_t bootMode,
 					const u32 bootAddress);
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/hw_mbox.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/hw_mbox.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/hw_mbox.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/hw_mbox.c	2012-12-16 13:13:01.556330147 +0100
@@ -33,10 +33,12 @@
 /* width in bits of MBOX Id */
 #define HW_MBOX_ID_WIDTH	   2
 
-struct MAILBOX_CONTEXT mboxsetting = {0x4, 0x1, 0x1};
+struct MAILBOX_CONTEXT mboxsetting = {
+	.sysconfig = 2 << 3 | 1, /* SMART/AUTO-IDLE */
+};
 
 /* Saves the mailbox context */
-HW_STATUS HW_MBOX_saveSettings(u32 baseAddress)
+HW_STATUS HW_MBOX_saveSettings(void __iomem *baseAddress)
 {
 	HW_STATUS status = RET_OK;
 
@@ -50,7 +52,7 @@ HW_STATUS HW_MBOX_saveSettings(u32 baseA
 }
 
 /* Restores the mailbox context */
-HW_STATUS HW_MBOX_restoreSettings(u32 baseAddress)
+HW_STATUS HW_MBOX_restoreSettings(void __iomem *baseAddress)
 {
 	 HW_STATUS status = RET_OK;
 	/* Restor IRQ enable status */
@@ -65,8 +67,8 @@ HW_STATUS HW_MBOX_restoreSettings(u32 ba
 
 /* Reads a u32 from the sub module message box Specified. if there are no
  * messages in the mailbox then and error is returned. */
-HW_STATUS HW_MBOX_MsgRead(const u32 baseAddress, const HW_MBOX_Id_t mailBoxId,
-				u32 *const pReadValue)
+HW_STATUS HW_MBOX_MsgRead(const void __iomem *baseAddress,
+	const HW_MBOX_Id_t mailBoxId, u32 *const pReadValue)
 {
 	HW_STATUS status = RET_OK;
 
@@ -86,8 +88,8 @@ HW_STATUS HW_MBOX_MsgRead(const u32 base
 }
 
 /* Writes a u32 from the sub module message box Specified. */
-HW_STATUS HW_MBOX_MsgWrite(const u32 baseAddress, const HW_MBOX_Id_t mailBoxId,
-			const u32 writeValue)
+HW_STATUS HW_MBOX_MsgWrite(const void __iomem *baseAddress,
+	const HW_MBOX_Id_t mailBoxId, const u32 writeValue)
 {
 	HW_STATUS status = RET_OK;
 
@@ -105,8 +107,8 @@ HW_STATUS HW_MBOX_MsgWrite(const u32 bas
 }
 
 /* Gets number of messages in a specified mailbox. */
-HW_STATUS HW_MBOX_NumMsgGet(const u32 baseAddress, const HW_MBOX_Id_t mailBoxId,
-				u32 *const pNumMsg)
+HW_STATUS HW_MBOX_NumMsgGet(const void __iomem *baseAddress,
+	const HW_MBOX_Id_t mailBoxId, u32 *const pNumMsg)
 {
 	HW_STATUS status = RET_OK;
 
@@ -127,7 +129,7 @@ HW_STATUS HW_MBOX_NumMsgGet(const u32 ba
 }
 
 /* Enables the specified IRQ. */
-HW_STATUS HW_MBOX_EventEnable(const u32	baseAddress,
+HW_STATUS HW_MBOX_EventEnable(const void __iomem *baseAddress,
 				const HW_MBOX_Id_t mailBoxId,
 				const HW_MBOX_UserId_t userId,
 				const u32 events)
@@ -167,7 +169,7 @@ HW_STATUS HW_MBOX_EventEnable(const u32
 }
 
 /* Disables the specified IRQ. */
-HW_STATUS HW_MBOX_EventDisable(const u32 baseAddress,
+HW_STATUS HW_MBOX_EventDisable(const void __iomem *baseAddress,
 				const HW_MBOX_Id_t mailBoxId,
 				const HW_MBOX_UserId_t userId,
 				const u32 events)
@@ -201,8 +203,9 @@ HW_STATUS HW_MBOX_EventDisable(const u32
 }
 
 /* Sets the status of the specified IRQ. */
-HW_STATUS HW_MBOX_EventAck(const u32 baseAddress, const HW_MBOX_Id_t mailBoxId,
-			const HW_MBOX_UserId_t userId, const u32 event)
+HW_STATUS HW_MBOX_EventAck(const void __iomem *baseAddress,
+	const HW_MBOX_Id_t mailBoxId, const HW_MBOX_UserId_t userId,
+	const u32 event)
 {
 	HW_STATUS status = RET_OK;
 	u32 irqStatusReg;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/hw_mbox.h kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/hw_mbox.h
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/hw_mbox.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/hw_mbox.h	2012-12-16 13:13:01.556330147 +0100
@@ -92,7 +92,7 @@ struct MAILBOX_CONTEXT {
 *		 box Specified. if there are no messages in the mailbox
 *		 then and error is returned.
 */
-extern HW_STATUS HW_MBOX_MsgRead(const u32 baseAddress,
+extern HW_STATUS HW_MBOX_MsgRead(const void __iomem *baseAddress,
 				const HW_MBOX_Id_t mailBoxId,
 				u32 *const pReadValue);
 
@@ -124,7 +124,7 @@ extern HW_STATUS HW_MBOX_MsgRead(const u
 *		 box Specified.
 */
 extern HW_STATUS HW_MBOX_MsgWrite(
-		      const u32	 baseAddress,
+		      const void __iomem *baseAddress,
 		      const HW_MBOX_Id_t   mailBoxId,
 		      const u32	 writeValue
 		  );
@@ -158,7 +158,7 @@ extern HW_STATUS HW_MBOX_MsgWrite(
 * PURPOSE:      : this function gets number of messages in a specified mailbox.
 */
 extern HW_STATUS HW_MBOX_NumMsgGet(
-		      const u32	 baseAddress,
+		      const void	 __iomem *baseAddress,
 		      const HW_MBOX_Id_t   mailBoxId,
 		      u32 *const	pNumMsg
 		  );
@@ -194,7 +194,7 @@ extern HW_STATUS HW_MBOX_NumMsgGet(
 * PURPOSE:      : this function enables the specified IRQ.
 */
 extern HW_STATUS HW_MBOX_EventEnable(
-		      const u32	     baseAddress,
+		      const void __iomem *baseAddress,
 		      const HW_MBOX_Id_t       mailBoxId,
 		      const HW_MBOX_UserId_t   userId,
 		      const u32	     events
@@ -231,7 +231,7 @@ extern HW_STATUS HW_MBOX_EventEnable(
 * PURPOSE:      : this function disables the specified IRQ.
 */
 extern HW_STATUS HW_MBOX_EventDisable(
-		      const u32	     baseAddress,
+		      const void __iomem *baseAddress,
 		      const HW_MBOX_Id_t       mailBoxId,
 		      const HW_MBOX_UserId_t   userId,
 		      const u32	     events
@@ -270,7 +270,7 @@ extern HW_STATUS HW_MBOX_EventDisable(
 * PURPOSE:      : this function sets the status of the specified IRQ.
 */
 extern HW_STATUS HW_MBOX_EventAck(
-		      const u32	      baseAddress,
+		      const void	__iomem *baseAddress,
 		      const HW_MBOX_Id_t	mailBoxId,
 		      const HW_MBOX_UserId_t    userId,
 		      const u32	      event
@@ -296,7 +296,7 @@ extern HW_STATUS HW_MBOX_EventAck(
 *
 * PURPOSE:      : this function saves the context of mailbox
 */
-extern HW_STATUS HW_MBOX_saveSettings(u32    baseAddres);
+extern HW_STATUS HW_MBOX_saveSettings(void __iomem *baseAddres);
 
 /*
 * FUNCTION      : HW_MBOX_restoreSettings
@@ -318,6 +318,11 @@ extern HW_STATUS HW_MBOX_saveSettings(u3
 *
 * PURPOSE:      : this function restores the context of mailbox
 */
-extern HW_STATUS HW_MBOX_restoreSettings(u32    baseAddres);
+extern HW_STATUS HW_MBOX_restoreSettings(void __iomem *baseAddres);
+
+static inline void HW_MBOX_initSettings(void __iomem *baseAddres)
+{
+	HW_MBOX_restoreSettings(baseAddres);
+}
 
 #endif  /* __MBOX_H */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/hw_mmu.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/hw_mmu.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/hw_mmu.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/hw_mmu.c	2012-12-16 13:13:01.556330147 +0100
@@ -30,6 +30,7 @@
  */
 
 #include <GlobalTypes.h>
+#include <linux/io.h>
 #include "MMURegAcM.h"
 #include <hw_defs.h>
 #include <hw_mmu.h>
@@ -79,7 +80,7 @@ enum HW_MMUPageSize_t {
 * METHOD:	       : Check the Input parameter and Flush a
 *			 single entry in the TLB.
 */
-static HW_STATUS MMU_FlushEntry(const u32 baseAddress);
+static HW_STATUS MMU_FlushEntry(const void __iomem *baseAddress);
 
 /*
 * FUNCTION	      : MMU_SetCAMEntry
@@ -121,7 +122,7 @@ static HW_STATUS MMU_FlushEntry(const u3
 *
 * METHOD:	       	: Check the Input parameters and set the CAM entry.
 */
-static HW_STATUS MMU_SetCAMEntry(const u32    baseAddress,
+static HW_STATUS MMU_SetCAMEntry(const void __iomem *baseAddress,
 				   const u32    pageSize,
 				   const u32    preservedBit,
 				   const u32    validBit,
@@ -166,7 +167,7 @@ static HW_STATUS MMU_SetCAMEntry(const u
 *
 * METHOD:	       : Check the Input parameters and set the RAM entry.
 */
-static HW_STATUS MMU_SetRAMEntry(const u32	baseAddress,
+static HW_STATUS MMU_SetRAMEntry(const void __iomem *baseAddress,
 				   const u32	physicalAddr,
 				   enum HW_Endianism_t      endianism,
 				   enum HW_ElementSize_t    elementSize,
@@ -174,7 +175,7 @@ static HW_STATUS MMU_SetRAMEntry(const u
 
 /* HW FUNCTIONS */
 
-HW_STATUS HW_MMU_Enable(const u32 baseAddress)
+HW_STATUS HW_MMU_Enable(const void __iomem *baseAddress)
 {
     HW_STATUS status = RET_OK;
 
@@ -183,7 +184,7 @@ HW_STATUS HW_MMU_Enable(const u32 baseAd
     return status;
 }
 
-HW_STATUS HW_MMU_Disable(const u32 baseAddress)
+HW_STATUS HW_MMU_Disable(const void __iomem *baseAddress)
 {
     HW_STATUS status = RET_OK;
 
@@ -192,7 +193,7 @@ HW_STATUS HW_MMU_Disable(const u32 baseA
     return status;
 }
 
-HW_STATUS HW_MMU_NumLockedSet(const u32 baseAddress,
+HW_STATUS HW_MMU_NumLockedSet(const void __iomem *baseAddress,
 				u32 numLockedEntries)
 {
     HW_STATUS status = RET_OK;
@@ -202,7 +203,7 @@ HW_STATUS HW_MMU_NumLockedSet(const u32
     return status;
 }
 
-HW_STATUS HW_MMU_VictimNumSet(const u32 baseAddress,
+HW_STATUS HW_MMU_VictimNumSet(const void __iomem *baseAddress,
 				u32 victimEntryNum)
 {
     HW_STATUS status = RET_OK;
@@ -212,7 +213,7 @@ HW_STATUS HW_MMU_VictimNumSet(const u32
     return status;
 }
 
-HW_STATUS HW_MMU_EventAck(const u32 baseAddress, u32 irqMask)
+HW_STATUS HW_MMU_EventAck(const void __iomem *baseAddress, u32 irqMask)
 {
     HW_STATUS status = RET_OK;
 
@@ -221,7 +222,7 @@ HW_STATUS HW_MMU_EventAck(const u32 base
     return status;
 }
 
-HW_STATUS HW_MMU_EventDisable(const u32 baseAddress,
+HW_STATUS HW_MMU_EventDisable(const void __iomem *baseAddress,
 				u32 irqMask)
 {
     HW_STATUS status = RET_OK;
@@ -234,7 +235,7 @@ HW_STATUS HW_MMU_EventDisable(const u32
     return status;
 }
 
-HW_STATUS HW_MMU_EventEnable(const u32 baseAddress, u32 irqMask)
+HW_STATUS HW_MMU_EventEnable(const void __iomem *baseAddress, u32 irqMask)
 {
     HW_STATUS status = RET_OK;
     u32 irqReg;
@@ -247,7 +248,7 @@ HW_STATUS HW_MMU_EventEnable(const u32 b
 }
 
 
-HW_STATUS HW_MMU_EventStatus(const u32 baseAddress, u32 *irqMask)
+HW_STATUS HW_MMU_EventStatus(const void __iomem *baseAddress, u32 *irqMask)
 {
     HW_STATUS status = RET_OK;
 
@@ -257,7 +258,7 @@ HW_STATUS HW_MMU_EventStatus(const u32 b
 }
 
 
-HW_STATUS HW_MMU_FaultAddrRead(const u32 baseAddress, u32 *addr)
+HW_STATUS HW_MMU_FaultAddrRead(const void __iomem *baseAddress, u32 *addr)
 {
     HW_STATUS status = RET_OK;
 
@@ -271,7 +272,7 @@ HW_STATUS HW_MMU_FaultAddrRead(const u32
     return status;
 }
 
-HW_STATUS HW_MMU_TTBSet(const u32 baseAddress, u32 TTBPhysAddr)
+HW_STATUS HW_MMU_TTBSet(const void __iomem *baseAddress, u32 TTBPhysAddr)
 {
     HW_STATUS status = RET_OK;
     u32 loadTTB;
@@ -287,7 +288,7 @@ HW_STATUS HW_MMU_TTBSet(const u32 baseAd
    return status;
 }
 
-HW_STATUS HW_MMU_TWLEnable(const u32 baseAddress)
+HW_STATUS HW_MMU_TWLEnable(const void __iomem *baseAddress)
 {
     HW_STATUS status = RET_OK;
 
@@ -296,7 +297,7 @@ HW_STATUS HW_MMU_TWLEnable(const u32 bas
     return status;
 }
 
-HW_STATUS HW_MMU_TWLDisable(const u32 baseAddress)
+HW_STATUS HW_MMU_TWLDisable(const void __iomem *baseAddress)
 {
     HW_STATUS status = RET_OK;
 
@@ -305,7 +306,7 @@ HW_STATUS HW_MMU_TWLDisable(const u32 ba
     return status;
 }
 
-HW_STATUS HW_MMU_TLBFlush(const u32 baseAddress, u32 virtualAddr,
+HW_STATUS HW_MMU_TLBFlush(const void __iomem *baseAddress, u32 virtualAddr,
 			     u32 pageSize)
 {
     HW_STATUS status = RET_OK;
@@ -343,7 +344,7 @@ HW_STATUS HW_MMU_TLBFlush(const u32 base
     return status;
 }
 
-HW_STATUS HW_MMU_TLBAdd(const u32	baseAddress,
+HW_STATUS HW_MMU_TLBAdd(const void __iomem *baseAddress,
 			   u32	      physicalAddr,
 			   u32	      virtualAddr,
 			   u32	      pageSize,
@@ -529,7 +530,7 @@ HW_STATUS HW_MMU_PteClear(const u32  pgT
 }
 
 /* MMU_FlushEntry */
-static HW_STATUS MMU_FlushEntry(const u32 baseAddress)
+static HW_STATUS MMU_FlushEntry(const void __iomem *baseAddress)
 {
    HW_STATUS status = RET_OK;
    u32 flushEntryData = 0x1;
@@ -545,7 +546,7 @@ static HW_STATUS MMU_FlushEntry(const u3
 }
 
 /* MMU_SetCAMEntry */
-static HW_STATUS MMU_SetCAMEntry(const u32    baseAddress,
+static HW_STATUS MMU_SetCAMEntry(const void __iomem *baseAddress,
 				   const u32    pageSize,
 				   const u32    preservedBit,
 				   const u32    validBit,
@@ -569,7 +570,7 @@ static HW_STATUS MMU_SetCAMEntry(const u
 }
 
 /* MMU_SetRAMEntry */
-static HW_STATUS MMU_SetRAMEntry(const u32       baseAddress,
+static HW_STATUS MMU_SetRAMEntry(const void __iomem *baseAddress,
 				   const u32       physicalAddr,
 				   enum HW_Endianism_t     endianism,
 				   enum HW_ElementSize_t   elementSize,
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/hw_mmu.h kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/hw_mmu.h
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/hw_mmu.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/hw_mmu.h	2012-12-16 13:13:01.556330147 +0100
@@ -51,47 +51,48 @@ struct HW_MMUMapAttrs_t {
 	enum HW_Endianism_t     endianism;
 	enum HW_ElementSize_t   elementSize;
 	enum HW_MMUMixedSize_t  mixedSize;
+	bool donotlockmpupage;
 } ;
 
-extern HW_STATUS HW_MMU_Enable(const u32 baseAddress);
+extern HW_STATUS HW_MMU_Enable(const void __iomem *baseAddress);
 
-extern HW_STATUS HW_MMU_Disable(const u32 baseAddress);
+extern HW_STATUS HW_MMU_Disable(const void __iomem *baseAddress);
 
-extern HW_STATUS HW_MMU_NumLockedSet(const u32 baseAddress,
+extern HW_STATUS HW_MMU_NumLockedSet(const void __iomem *baseAddress,
 					u32 numLockedEntries);
 
-extern HW_STATUS HW_MMU_VictimNumSet(const u32 baseAddress,
+extern HW_STATUS HW_MMU_VictimNumSet(const void __iomem *baseAddress,
 					u32 victimEntryNum);
 
 /* For MMU faults */
-extern HW_STATUS HW_MMU_EventAck(const u32 baseAddress,
+extern HW_STATUS HW_MMU_EventAck(const void __iomem *baseAddress,
 				    u32 irqMask);
 
-extern HW_STATUS HW_MMU_EventDisable(const u32 baseAddress,
+extern HW_STATUS HW_MMU_EventDisable(const void __iomem *baseAddress,
 					u32 irqMask);
 
-extern HW_STATUS HW_MMU_EventEnable(const u32 baseAddress,
+extern HW_STATUS HW_MMU_EventEnable(const void __iomem *baseAddress,
 				       u32 irqMask);
 
-extern HW_STATUS HW_MMU_EventStatus(const u32 baseAddress,
+extern HW_STATUS HW_MMU_EventStatus(const void __iomem *baseAddress,
 				       u32 *irqMask);
 
-extern HW_STATUS HW_MMU_FaultAddrRead(const u32 baseAddress,
+extern HW_STATUS HW_MMU_FaultAddrRead(const void __iomem *baseAddress,
 					 u32 *addr);
 
 /* Set the TT base address */
-extern HW_STATUS HW_MMU_TTBSet(const u32 baseAddress,
+extern HW_STATUS HW_MMU_TTBSet(const void __iomem *baseAddress,
 				  u32 TTBPhysAddr);
 
-extern HW_STATUS HW_MMU_TWLEnable(const u32 baseAddress);
+extern HW_STATUS HW_MMU_TWLEnable(const void __iomem *baseAddress);
 
-extern HW_STATUS HW_MMU_TWLDisable(const u32 baseAddress);
+extern HW_STATUS HW_MMU_TWLDisable(const void __iomem *baseAddress);
 
-extern HW_STATUS HW_MMU_TLBFlush(const u32 baseAddress,
+extern HW_STATUS HW_MMU_TLBFlush(const void __iomem *baseAddress,
 				    u32 virtualAddr,
 				    u32 pageSize);
 
-extern HW_STATUS HW_MMU_TLBAdd(const u32     baseAddress,
+extern HW_STATUS HW_MMU_TLBAdd(const void __iomem *baseAddress,
 				  u32	   physicalAddr,
 				  u32	   virtualAddr,
 				  u32	   pageSize,
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/hw_prcm.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/hw_prcm.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/hw_prcm.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/hw_prcm.c	2012-12-16 13:13:01.556330147 +0100
@@ -29,21 +29,21 @@
 #include <hw_defs.h>
 #include <hw_prcm.h>
 
-static HW_STATUS HW_RST_WriteVal(const u32 baseAddress,
+static HW_STATUS HW_RST_WriteVal(const void __iomem *baseAddress,
 				    enum HW_RstModule_t r,
 				    enum HW_SetClear_t val);
 
-HW_STATUS HW_RST_Reset(const u32 baseAddress, enum HW_RstModule_t r)
+HW_STATUS HW_RST_Reset(const void __iomem *baseAddress, enum HW_RstModule_t r)
 {
 	return HW_RST_WriteVal(baseAddress, r, HW_SET);
 }
 
-HW_STATUS HW_RST_UnReset(const u32 baseAddress, enum HW_RstModule_t r)
+HW_STATUS HW_RST_UnReset(const void __iomem *baseAddress, enum HW_RstModule_t r)
 {
 	return HW_RST_WriteVal(baseAddress, r, HW_CLEAR);
 }
 
-static HW_STATUS HW_RST_WriteVal(const u32 baseAddress,
+static HW_STATUS HW_RST_WriteVal(const void __iomem *baseAddress,
 				    enum HW_RstModule_t r,
 				    enum HW_SetClear_t val)
 {
@@ -66,8 +66,8 @@ static HW_STATUS HW_RST_WriteVal(const u
 	return status;
 }
 
-HW_STATUS HW_PWR_IVA2StateGet(const u32 baseAddress, enum HW_PwrModule_t p,
-				enum HW_PwrState_t *value)
+HW_STATUS HW_PWR_IVA2StateGet(const void __iomem *baseAddress,
+		enum HW_PwrModule_t p, enum HW_PwrState_t *value)
 {
 	HW_STATUS status = RET_OK;
 	u32 temp;
@@ -93,7 +93,7 @@ HW_STATUS HW_PWR_IVA2StateGet(const u32
 	return status;
 }
 
-HW_STATUS HW_PWRST_IVA2RegGet(const u32 baseAddress, u32 *value)
+HW_STATUS HW_PWRST_IVA2RegGet(const void __iomem *baseAddress, u32 *value)
 {
 	HW_STATUS status = RET_OK;
 
@@ -103,7 +103,7 @@ HW_STATUS HW_PWRST_IVA2RegGet(const u32
 }
 
 
-HW_STATUS HW_PWR_IVA2PowerStateSet(const u32 baseAddress,
+HW_STATUS HW_PWR_IVA2PowerStateSet(const void __iomem *baseAddress,
 				     enum HW_PwrModule_t p,
 				     enum HW_PwrState_t value)
 {
@@ -135,7 +135,7 @@ HW_STATUS HW_PWR_IVA2PowerStateSet(const
 	return status;
 }
 
-HW_STATUS HW_PWR_CLKCTRL_IVA2RegSet(const u32 baseAddress,
+HW_STATUS HW_PWR_CLKCTRL_IVA2RegSet(const void __iomem *baseAddress,
 				      enum HW_TransitionState_t val)
 {
 	HW_STATUS status = RET_OK;
@@ -146,8 +146,8 @@ HW_STATUS HW_PWR_CLKCTRL_IVA2RegSet(cons
 
 }
 
-HW_STATUS HW_RSTST_RegGet(const u32 baseAddress, enum HW_RstModule_t m,
-			    u32 *value)
+HW_STATUS HW_RSTST_RegGet(const void __iomem *baseAddress,
+		enum HW_RstModule_t m, u32 *value)
 {
 	HW_STATUS status = RET_OK;
 
@@ -156,8 +156,8 @@ HW_STATUS HW_RSTST_RegGet(const u32 base
 	return status;
 }
 
-HW_STATUS HW_RSTCTRL_RegGet(const u32 baseAddress, enum HW_RstModule_t m,
-			      u32 *value)
+HW_STATUS HW_RSTCTRL_RegGet(const void __iomem *baseAddress,
+		enum HW_RstModule_t m, u32 *value)
 {
 	HW_STATUS status = RET_OK;
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/hw_prcm.h kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/hw_prcm.h
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/hw_prcm.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/hw_prcm.h	2012-12-16 13:13:01.556330147 +0100
@@ -132,16 +132,16 @@ enum HW_TransitionState_t {
 } ;
 
 
-extern HW_STATUS HW_RST_Reset(const u32 baseAddress,
+extern HW_STATUS HW_RST_Reset(const void __iomem *baseAddress,
 				 enum HW_RstModule_t r);
 
-extern HW_STATUS HW_RST_UnReset(const u32 baseAddress,
+extern HW_STATUS HW_RST_UnReset(const void __iomem *baseAddress,
 				   enum HW_RstModule_t r);
 
-extern HW_STATUS HW_RSTCTRL_RegGet(const u32 baseAddress,
+extern HW_STATUS HW_RSTCTRL_RegGet(const void __iomem *baseAddress,
 					     enum HW_RstModule_t p,
 					     u32 *value);
-extern HW_STATUS HW_RSTST_RegGet(const u32 baseAddress,
+extern HW_STATUS HW_RSTST_RegGet(const void __iomem *baseAddress,
 					   enum HW_RstModule_t p, u32 *value);
 
 extern HW_STATUS HW_PWR_PowerStateSet(const u32 baseAddress,
@@ -152,17 +152,18 @@ extern HW_STATUS HW_CLK_SetInputClock(co
 					enum HW_GPtimer_t gpt,
 					enum HW_Clocktype_t c);
 
-extern HW_STATUS HW_PWR_IVA2StateGet(const u32 baseAddress,
+extern HW_STATUS HW_PWR_IVA2StateGet(const void __iomem *baseAddress,
 					enum HW_PwrModule_t p,
 					enum HW_PwrState_t *value);
 
-extern HW_STATUS HW_PWRST_IVA2RegGet(const u32 baseAddress, u32 *value);
+extern HW_STATUS HW_PWRST_IVA2RegGet(const void __iomem *baseAddress,
+						u32 *value);
 
-extern HW_STATUS HW_PWR_IVA2PowerStateSet(const u32 baseAddress,
+extern HW_STATUS HW_PWR_IVA2PowerStateSet(const void __iomem *baseAddress,
 					    enum HW_PwrModule_t p,
 					    enum HW_PwrState_t value);
 
-extern HW_STATUS HW_PWR_CLKCTRL_IVA2RegSet(const u32 baseAddress,
+extern HW_STATUS HW_PWR_CLKCTRL_IVA2RegSet(const void __iomem *baseAddress,
 					     enum HW_TransitionState_t val);
 
 #endif  /* __HW_PRCM_H */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/MLBRegAcM.h kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/MLBRegAcM.h
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/MLBRegAcM.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/MLBRegAcM.h	2012-12-16 13:13:01.556330147 +0100
@@ -18,6 +18,7 @@
 #define _MLB_REG_ACM_H
 
 #include <GlobalTypes.h>
+#include <linux/io.h>
 #include <EasiGlobal.h>
 #include "MLBAccInt.h"
 
@@ -25,7 +26,7 @@
 
 #define MLBMAILBOX_SYSCONFIGReadRegister32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGReadRegister32),\
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+ \
+      __raw_readl(((baseAddress))+ \
       MLB_MAILBOX_SYSCONFIG_OFFSET))
 
 
@@ -34,13 +35,13 @@
     const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGWriteRegister32);\
-    WR_MEM_32_VOLATILE(((u32)(baseAddress))+offset, newValue);\
+    __raw_writel(newValue, ((baseAddress))+offset);\
 }
 
 
 #define MLBMAILBOX_SYSCONFIGSIdleModeRead32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeRead32),\
-      (((RD_MEM_32_VOLATILE((((u32)(baseAddress))+\
+      (((__raw_readl((((u32)(baseAddress))+\
       (MLB_MAILBOX_SYSCONFIG_OFFSET)))) &\
       MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK) >>\
       MLB_MAILBOX_SYSCONFIG_SIdleMode_OFFSET))
@@ -49,7 +50,7 @@
 #define MLBMAILBOX_SYSCONFIGSIdleModeWrite32(baseAddress, value)\
 {\
     const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE(((u32)(baseAddress)) +\
+    register u32 data = __raw_readl(((u32)(baseAddress)) +\
 			    offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeWrite32);\
@@ -57,7 +58,7 @@
     newValue <<= MLB_MAILBOX_SYSCONFIG_SIdleMode_OFFSET;\
     newValue &= MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
 
@@ -65,20 +66,20 @@
 {\
     const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;\
     register u32 data =\
-    RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+    __raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSoftResetWrite32);\
     data &= ~(MLB_MAILBOX_SYSCONFIG_SoftReset_MASK);\
     newValue <<= MLB_MAILBOX_SYSCONFIG_SoftReset_OFFSET;\
     newValue &= MLB_MAILBOX_SYSCONFIG_SoftReset_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
 
 #define MLBMAILBOX_SYSCONFIGAutoIdleRead32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleRead32),\
-      (((RD_MEM_32_VOLATILE((((u32)(baseAddress))+\
+      (((__raw_readl((((u32)(baseAddress))+\
       (MLB_MAILBOX_SYSCONFIG_OFFSET)))) &\
       MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK) >>\
       MLB_MAILBOX_SYSCONFIG_AutoIdle_OFFSET))
@@ -88,20 +89,20 @@
 {\
     const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;\
     register u32 data =\
-    RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+    __raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleWrite32);\
     data &= ~(MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK);\
     newValue <<= MLB_MAILBOX_SYSCONFIG_AutoIdle_OFFSET;\
     newValue &= MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
 
 #define MLBMAILBOX_SYSSTATUSResetDoneRead32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSSTATUSResetDoneRead32),\
-      (((RD_MEM_32_VOLATILE((((u32)(baseAddress))+\
+      (((__raw_readl((((u32)(baseAddress))+\
       (MLB_MAILBOX_SYSSTATUS_OFFSET)))) &\
       MLB_MAILBOX_SYSSTATUS_ResetDone_MASK) >>\
       MLB_MAILBOX_SYSSTATUS_ResetDone_OFFSET))
@@ -109,7 +110,7 @@
 
 #define MLBMAILBOX_MESSAGE___0_15ReadRegister32(baseAddress, bank)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_MESSAGE___0_15ReadRegister32),\
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+\
+      __raw_readl(((baseAddress))+\
       (MLB_MAILBOX_MESSAGE___REGSET_0_15_OFFSET +\
       MLB_MAILBOX_MESSAGE___0_15_OFFSET+(\
       (bank)*MLB_MAILBOX_MESSAGE___REGSET_0_15_STEP))))
@@ -122,14 +123,14 @@
     ((bank)*MLB_MAILBOX_MESSAGE___REGSET_0_15_STEP);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_MESSAGE___0_15WriteRegister32);\
-    WR_MEM_32_VOLATILE(((u32)(baseAddress))+offset, newValue);\
+    __raw_writel(newValue, ((baseAddress))+offset);\
 }
 
 
 #define MLBMAILBOX_FIFOSTATUS___0_15ReadRegister32(baseAddress, bank)\
     (_DEBUG_LEVEL_1_EASI(\
       EASIL1_MLBMAILBOX_FIFOSTATUS___0_15ReadRegister32),\
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+\
+      __raw_readl(((u32)(baseAddress))+\
       (MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_OFFSET +\
       MLB_MAILBOX_FIFOSTATUS___0_15_OFFSET+\
       ((bank)*MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_STEP))))
@@ -138,7 +139,7 @@
 #define MLBMAILBOX_FIFOSTATUS___0_15FifoFullMBmRead32(baseAddress, bank)\
     (_DEBUG_LEVEL_1_EASI(\
       EASIL1_MLBMAILBOX_FIFOSTATUS___0_15FifoFullMBmRead32),\
-      (((RD_MEM_32_VOLATILE(((u32)(baseAddress))+\
+      (((__raw_readl(((baseAddress))+\
       (MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_OFFSET +\
       MLB_MAILBOX_FIFOSTATUS___0_15_OFFSET+\
       ((bank)*MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_STEP)))) &\
@@ -149,7 +150,7 @@
 #define MLBMAILBOX_MSGSTATUS___0_15NbOfMsgMBmRead32(baseAddress, bank)\
     (_DEBUG_LEVEL_1_EASI(\
       EASIL1_MLBMAILBOX_MSGSTATUS___0_15NbOfMsgMBmRead32),\
-      (((RD_MEM_32_VOLATILE(((u32)(baseAddress))+\
+      (((__raw_readl(((baseAddress))+\
       (MLB_MAILBOX_MSGSTATUS___REGSET_0_15_OFFSET +\
       MLB_MAILBOX_MSGSTATUS___0_15_OFFSET+\
       ((bank)*MLB_MAILBOX_MSGSTATUS___REGSET_0_15_STEP)))) &\
@@ -159,7 +160,7 @@
 
 #define MLBMAILBOX_IRQSTATUS___0_3ReadRegister32(baseAddress, bank)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQSTATUS___0_3ReadRegister32),\
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+\
+      __raw_readl(((baseAddress))+\
       (MLB_MAILBOX_IRQSTATUS___REGSET_0_3_OFFSET +\
       MLB_MAILBOX_IRQSTATUS___0_3_OFFSET+\
       ((bank)*MLB_MAILBOX_IRQSTATUS___REGSET_0_3_STEP))))
@@ -172,13 +173,13 @@
     ((bank)*MLB_MAILBOX_IRQSTATUS___REGSET_0_3_STEP);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQSTATUS___0_3WriteRegister32);\
-    WR_MEM_32_VOLATILE(((u32)(baseAddress))+offset, newValue);\
+    __raw_writel(newValue, ((baseAddress))+offset);\
 }
 
 
 #define MLBMAILBOX_IRQENABLE___0_3ReadRegister32(baseAddress, bank)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQENABLE___0_3ReadRegister32),\
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+\
+      __raw_readl(((baseAddress))+\
       (MLB_MAILBOX_IRQENABLE___REGSET_0_3_OFFSET +\
       MLB_MAILBOX_IRQENABLE___0_3_OFFSET+\
        ((bank)*MLB_MAILBOX_IRQENABLE___REGSET_0_3_STEP))))
@@ -191,7 +192,7 @@
       ((bank)*MLB_MAILBOX_IRQENABLE___REGSET_0_3_STEP);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQENABLE___0_3WriteRegister32);\
-    WR_MEM_32_VOLATILE(((u32)(baseAddress))+offset, newValue);\
+    __raw_writel(newValue, ((baseAddress))+offset);\
 }
 
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/MMURegAcM.h kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/MMURegAcM.h
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/MMURegAcM.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/MMURegAcM.h	2012-12-16 13:13:01.556330147 +0100
@@ -19,7 +19,7 @@
 #define _MMU_REG_ACM_H
 
 #include <GlobalTypes.h>
-
+#include <linux/io.h>
 #include <EasiGlobal.h>
 
 #include "MMUAccInt.h"
@@ -29,40 +29,40 @@
 
 #define MMUMMU_SYSCONFIGReadRegister32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGReadRegister32),\
-      RD_MEM_32_VOLATILE((baseAddress)+MMU_MMU_SYSCONFIG_OFFSET))
+      __raw_readl((baseAddress)+MMU_MMU_SYSCONFIG_OFFSET))
 
 
 #define MMUMMU_SYSCONFIGIdleModeWrite32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_SYSCONFIG_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((baseAddress)+offset);\
+    register u32 data = __raw_readl((baseAddress)+offset);\
     register u32 newValue = (value);\
     _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGIdleModeWrite32);\
     data &= ~(MMU_MMU_SYSCONFIG_IdleMode_MASK);\
     newValue <<= MMU_MMU_SYSCONFIG_IdleMode_OFFSET;\
     newValue &= MMU_MMU_SYSCONFIG_IdleMode_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE(baseAddress+offset, newValue);\
+    __raw_writel(newValue, baseAddress+offset);\
 }
 
 
 #define MMUMMU_SYSCONFIGAutoIdleWrite32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_SYSCONFIG_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((baseAddress)+offset);\
+    register u32 data = __raw_readl((baseAddress)+offset);\
     register u32 newValue = (value);\
     _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGAutoIdleWrite32);\
     data &= ~(MMU_MMU_SYSCONFIG_AutoIdle_MASK);\
     newValue <<= MMU_MMU_SYSCONFIG_AutoIdle_OFFSET;\
     newValue &= MMU_MMU_SYSCONFIG_AutoIdle_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE(baseAddress+offset, newValue);\
+    __raw_writel(newValue, baseAddress+offset);\
 }
 
 
 #define MMUMMU_IRQSTATUSReadRegister32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQSTATUSReadRegister32),\
-      RD_MEM_32_VOLATILE((baseAddress)+MMU_MMU_IRQSTATUS_OFFSET))
+      __raw_readl((baseAddress)+MMU_MMU_IRQSTATUS_OFFSET))
 
 
 #define MMUMMU_IRQSTATUSWriteRegister32(baseAddress, value)\
@@ -70,13 +70,13 @@
     const u32 offset = MMU_MMU_IRQSTATUS_OFFSET;\
     register u32 newValue = (value);\
     _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQSTATUSWriteRegister32);\
-    WR_MEM_32_VOLATILE((baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (baseAddress)+offset);\
 }
 
 
 #define MMUMMU_IRQENABLEReadRegister32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQENABLEReadRegister32),\
-      RD_MEM_32_VOLATILE((baseAddress)+MMU_MMU_IRQENABLE_OFFSET))
+      __raw_readl((baseAddress)+MMU_MMU_IRQENABLE_OFFSET))
 
 
 #define MMUMMU_IRQENABLEWriteRegister32(baseAddress, value)\
@@ -84,20 +84,20 @@
     const u32 offset = MMU_MMU_IRQENABLE_OFFSET;\
     register u32 newValue = (value);\
     _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQENABLEWriteRegister32);\
-    WR_MEM_32_VOLATILE((baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (baseAddress)+offset);\
 }
 
 
 #define MMUMMU_WALKING_STTWLRunningRead32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_WALKING_STTWLRunningRead32),\
-      (((RD_MEM_32_VOLATILE(((baseAddress)+(MMU_MMU_WALKING_ST_OFFSET))))\
+      (((__raw_readl(((baseAddress)+(MMU_MMU_WALKING_ST_OFFSET))))\
       & MMU_MMU_WALKING_ST_TWLRunning_MASK) >>\
       MMU_MMU_WALKING_ST_TWLRunning_OFFSET))
 
 
 #define MMUMMU_CNTLTWLEnableRead32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLTWLEnableRead32),\
-      (((RD_MEM_32_VOLATILE(((baseAddress)+(MMU_MMU_CNTL_OFFSET)))) &\
+      (((__raw_readl(((baseAddress)+(MMU_MMU_CNTL_OFFSET)))) &\
       MMU_MMU_CNTL_TWLEnable_MASK) >>\
       MMU_MMU_CNTL_TWLEnable_OFFSET))
 
@@ -105,34 +105,34 @@
 #define MMUMMU_CNTLTWLEnableWrite32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_CNTL_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((baseAddress)+offset);\
+    register u32 data = __raw_readl((baseAddress)+offset);\
     register u32 newValue = (value);\
     _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLTWLEnableWrite32);\
     data &= ~(MMU_MMU_CNTL_TWLEnable_MASK);\
     newValue <<= MMU_MMU_CNTL_TWLEnable_OFFSET;\
     newValue &= MMU_MMU_CNTL_TWLEnable_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE(baseAddress+offset, newValue);\
+    __raw_writel(newValue, baseAddress+offset);\
 }
 
 
 #define MMUMMU_CNTLMMUEnableWrite32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_CNTL_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((baseAddress)+offset);\
+    register u32 data = __raw_readl((baseAddress)+offset);\
     register u32 newValue = (value);\
     _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLMMUEnableWrite32);\
     data &= ~(MMU_MMU_CNTL_MMUEnable_MASK);\
     newValue <<= MMU_MMU_CNTL_MMUEnable_OFFSET;\
     newValue &= MMU_MMU_CNTL_MMUEnable_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE(baseAddress+offset, newValue);\
+    __raw_writel(newValue, baseAddress+offset);\
 }
 
 
 #define MMUMMU_FAULT_ADReadRegister32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_FAULT_ADReadRegister32),\
-      RD_MEM_32_VOLATILE((baseAddress)+MMU_MMU_FAULT_AD_OFFSET))
+      __raw_readl((baseAddress)+MMU_MMU_FAULT_AD_OFFSET))
 
 
 #define MMUMMU_TTBWriteRegister32(baseAddress, value)\
@@ -140,13 +140,13 @@
     const u32 offset = MMU_MMU_TTB_OFFSET;\
     register u32 newValue = (value);\
     _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_TTBWriteRegister32);\
-    WR_MEM_32_VOLATILE((baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (baseAddress)+offset);\
 }
 
 
 #define MMUMMU_LOCKReadRegister32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKReadRegister32),\
-      RD_MEM_32_VOLATILE((baseAddress)+MMU_MMU_LOCK_OFFSET))
+      __raw_readl((baseAddress)+MMU_MMU_LOCK_OFFSET))
 
 
 #define MMUMMU_LOCKWriteRegister32(baseAddress, value)\
@@ -154,13 +154,13 @@
     const u32 offset = MMU_MMU_LOCK_OFFSET;\
     register u32 newValue = (value);\
     _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKWriteRegister32);\
-    WR_MEM_32_VOLATILE((baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (baseAddress)+offset);\
 }
 
 
 #define MMUMMU_LOCKBaseValueRead32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKBaseValueRead32),\
-      (((RD_MEM_32_VOLATILE(((baseAddress)+(MMU_MMU_LOCK_OFFSET)))) &\
+      (((__raw_readl(((baseAddress)+(MMU_MMU_LOCK_OFFSET)))) &\
       MMU_MMU_LOCK_BaseValue_MASK) >>\
       MMU_MMU_LOCK_BaseValue_OFFSET))
 
@@ -168,20 +168,20 @@
 #define MMUMMU_LOCKBaseValueWrite32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_LOCK_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((baseAddress)+offset);\
+    register u32 data = __raw_readl((baseAddress)+offset);\
     register u32 newValue = (value);\
     _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKBaseValueWrite32);\
     data &= ~(MMU_MMU_LOCK_BaseValue_MASK);\
     newValue <<= MMU_MMU_LOCK_BaseValue_OFFSET;\
     newValue &= MMU_MMU_LOCK_BaseValue_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE(baseAddress+offset, newValue);\
+    __raw_writel(newValue, baseAddress+offset);\
 }
 
 
 #define MMUMMU_LOCKCurrentVictimRead32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKCurrentVictimRead32),\
-      (((RD_MEM_32_VOLATILE(((baseAddress)+(MMU_MMU_LOCK_OFFSET)))) &\
+      (((__raw_readl(((baseAddress)+(MMU_MMU_LOCK_OFFSET)))) &\
       MMU_MMU_LOCK_CurrentVictim_MASK) >>\
       MMU_MMU_LOCK_CurrentVictim_OFFSET))
 
@@ -189,14 +189,14 @@
 #define MMUMMU_LOCKCurrentVictimWrite32(baseAddress, value)\
 {\
     const u32 offset = MMU_MMU_LOCK_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((baseAddress)+offset);\
+    register u32 data = __raw_readl((baseAddress)+offset);\
     register u32 newValue = (value);\
     _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKCurrentVictimWrite32);\
     data &= ~(MMU_MMU_LOCK_CurrentVictim_MASK);\
     newValue <<= MMU_MMU_LOCK_CurrentVictim_OFFSET;\
     newValue &= MMU_MMU_LOCK_CurrentVictim_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE(baseAddress+offset, newValue);\
+    __raw_writel(newValue, baseAddress+offset);\
 }
 
 
@@ -209,7 +209,7 @@
 
 #define MMUMMU_LD_TLBReadRegister32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LD_TLBReadRegister32),\
-      RD_MEM_32_VOLATILE((baseAddress)+MMU_MMU_LD_TLB_OFFSET))
+      __raw_readl((baseAddress)+MMU_MMU_LD_TLB_OFFSET))
 
 
 #define MMUMMU_LD_TLBWriteRegister32(baseAddress, value)\
@@ -217,7 +217,7 @@
     const u32 offset = MMU_MMU_LD_TLB_OFFSET;\
     register u32 newValue = (value);\
     _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LD_TLBWriteRegister32);\
-    WR_MEM_32_VOLATILE((baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (baseAddress)+offset);\
 }
 
 
@@ -226,7 +226,7 @@
     const u32 offset = MMU_MMU_CAM_OFFSET;\
     register u32 newValue = (value);\
     _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CAMWriteRegister32);\
-    WR_MEM_32_VOLATILE((baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (baseAddress)+offset);\
 }
 
 
@@ -235,7 +235,7 @@
     const u32 offset = MMU_MMU_RAM_OFFSET;\
     register u32 newValue = (value);\
     _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_RAMWriteRegister32);\
-    WR_MEM_32_VOLATILE((baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (baseAddress)+offset);\
 }
 
 
@@ -244,7 +244,7 @@
     const u32 offset = MMU_MMU_FLUSH_ENTRY_OFFSET;\
     register u32 newValue = (value);\
     _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_FLUSH_ENTRYWriteRegister32);\
-    WR_MEM_32_VOLATILE((baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (baseAddress)+offset);\
 }
 
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/PRCMAccInt.h kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/PRCMAccInt.h
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/PRCMAccInt.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/PRCMAccInt.h	2012-12-16 13:13:01.560330147 +0100
@@ -117,8 +117,8 @@
 #define PRCM_CM_AUTOIDLE_DSP_OFFSET          (u32)(0x830)
 #define PRCM_CM_CLKSEL_DSP_OFFSET            (u32)(0x840)
 #define PRCM_CM_CLKSTCTRL_DSP_OFFSET         (u32)(0x848)
-#define PRCM_RM_RSTCTRL_DSP_OFFSET           (u32)(0x850)
-#define PRCM_RM_RSTST_DSP_OFFSET             (u32)(0x858)
+#define PRCM_RM_RSTCTRL_DSP_OFFSET           (u32)(0x050)
+#define PRCM_RM_RSTST_DSP_OFFSET             (u32)(0x058)
 #define PRCM_PM_PWSTCTRL_DSP_OFFSET          (u32)(0x8e0)
 #define PRCM_PM_PWSTST_DSP_OFFSET            (u32)(0x8e4)
 #define PRCM_PM_PWSTST_IVA2_OFFSET            (u32)(0xE4)
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/PRCMRegAcM.h kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/PRCMRegAcM.h
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/hw/PRCMRegAcM.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/hw/PRCMRegAcM.h	2012-12-16 13:13:01.560330147 +0100
@@ -18,6 +18,7 @@
 #define _PRCM_REG_ACM_H
 
 #include <GlobalTypes.h>
+#include <linux/io.h>
 
 #include <EasiGlobal.h>
 
@@ -31,37 +32,37 @@
     const u32 newValue = \
 	(u32)PRCMPRCM_CLKCFG_CTRLValid_configClk_valid <<\
       PRCM_PRCM_CLKCFG_CTRL_Valid_config_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((u32)(baseAddress)+offset);\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
     _DEBUG_LEVEL_1_EASI(\
       EASIL1_PRCMPRCM_CLKCFG_CTRLValid_configWriteClk_valid32);\
     data &= ~(PRCM_PRCM_CLKCFG_CTRL_Valid_config_MASK);\
     data |= newValue;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, data);\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
 
 #define CM_FCLKEN_PERReadRegister32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),\
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+CM_FCLKEN_PER_OFFSET))
+      __raw_readl(((u32)(baseAddress))+CM_FCLKEN_PER_OFFSET))
 
 
 #define CM_ICLKEN_PERReadRegister32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),\
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+CM_ICLKEN_PER_OFFSET))
+      __raw_readl(((u32)(baseAddress))+CM_ICLKEN_PER_OFFSET))
 
 
 #define CM_FCLKEN_PER_GPT5WriteRegister32(baseAddress,value)\
 {\
     const u32 offset = CM_FCLKEN_PER_OFFSET;\
     register u32 data = \
-	RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_CM_FCLKEN_PER_GPT5WriteRegister32);\
    data &= ~(CM_FCLKEN_PER_GPT5_MASK);\
    newValue <<= CM_FCLKEN_PER_GPT5_OFFSET;\
    newValue &= CM_FCLKEN_PER_GPT5_MASK;\
    newValue |= data;\
-    WR_MEM_32_VOLATILE(((u32)(baseAddress))+offset, newValue);\
+    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
 }
 
 
@@ -69,14 +70,14 @@
 {\
     const u32 offset = CM_FCLKEN_PER_OFFSET;\
     register u32 data =\
-	RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_CM_FCLKEN_PER_GPT5WriteRegister32);\
    data &= ~(CM_FCLKEN_PER_GPT6_MASK);\
    newValue <<= CM_FCLKEN_PER_GPT6_OFFSET;\
    newValue &= CM_FCLKEN_PER_GPT6_MASK;\
    newValue |= data;\
-    WR_MEM_32_VOLATILE(((u32)(baseAddress))+offset, newValue);\
+    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
 }
 
 
@@ -84,14 +85,14 @@
 {\
     const u32 offset = CM_ICLKEN_PER_OFFSET;\
     register u32 data = \
-	RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_CM_ICLKEN_PER_GPT5WriteRegister32);\
    data &= ~(CM_ICLKEN_PER_GPT5_MASK);\
    newValue <<= CM_ICLKEN_PER_GPT5_OFFSET;\
    newValue &= CM_ICLKEN_PER_GPT5_MASK;\
    newValue |= data;\
-    WR_MEM_32_VOLATILE(((u32)(baseAddress))+offset, newValue);\
+    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
 }
 
 
@@ -99,34 +100,34 @@
 {\
     const u32 offset = CM_ICLKEN_PER_OFFSET;\
     register u32 data = \
-	RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_CM_ICLKEN_PER_GPT5WriteRegister32);\
    data &= ~(CM_ICLKEN_PER_GPT6_MASK);\
    newValue <<= CM_ICLKEN_PER_GPT6_OFFSET;\
    newValue &= CM_ICLKEN_PER_GPT6_MASK;\
    newValue |= data;\
-    WR_MEM_32_VOLATILE(((u32)(baseAddress))+offset, newValue);\
+    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
 }
 
 
 #define CM_FCLKEN1_COREReadRegister32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),\
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+CM_FCLKEN1_CORE_OFFSET))
+      __raw_readl(((u32)(baseAddress))+CM_FCLKEN1_CORE_OFFSET))
 
 
 #define PRCMCM_FCLKEN1_COREEN_GPT8Write32(baseAddress,value)\
 {\
     const u32 offset = PRCM_CM_FCLKEN1_CORE_OFFSET;\
     register u32 data = \
-	RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT8Write32);\
     data &= ~(PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK);\
     newValue <<= PRCM_CM_FCLKEN1_CORE_EN_GPT8_OFFSET;\
     newValue &= PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
 
@@ -134,34 +135,34 @@
 {\
     const u32 offset = PRCM_CM_FCLKEN1_CORE_OFFSET;\
     register u32 data = \
-	RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT7Write32);\
     data &= ~(PRCM_CM_FCLKEN1_CORE_EN_GPT7_MASK);\
     newValue <<= PRCM_CM_FCLKEN1_CORE_EN_GPT7_OFFSET;\
     newValue &= PRCM_CM_FCLKEN1_CORE_EN_GPT7_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
 
 #define CM_ICLKEN1_COREReadRegister32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREReadRegister32),\
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+CM_ICLKEN1_CORE_OFFSET))
+      __raw_readl(((u32)(baseAddress))+CM_ICLKEN1_CORE_OFFSET))
 
 
 #define  CM_ICLKEN1_COREEN_MAILBOXESWrite32(baseAddress, value)\
 {\
     const u32 offset = CM_ICLKEN1_CORE_OFFSET;\
     register u32 data = \
-	RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_MAILBOXESWrite32);\
     data &= ~(CM_ICLKEN1_CORE_EN_MAILBOXES_MASK);\
     newValue <<= CM_ICLKEN1_CORE_EN_MAILBOXES_OFFSET;\
     newValue &= CM_ICLKEN1_CORE_EN_MAILBOXES_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
 
@@ -169,14 +170,14 @@
 {\
     const u32 offset = PRCM_CM_ICLKEN1_CORE_OFFSET;\
     register u32 data = \
-	RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT8Write32);\
     data &= ~(PRCM_CM_ICLKEN1_CORE_EN_GPT8_MASK);\
     newValue <<= PRCM_CM_ICLKEN1_CORE_EN_GPT8_OFFSET;\
     newValue &= PRCM_CM_ICLKEN1_CORE_EN_GPT8_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
 
@@ -184,14 +185,14 @@
 {\
     const u32 offset = PRCM_CM_ICLKEN1_CORE_OFFSET;\
     register u32 data =\
-	RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT7Write32);\
     data &= ~(PRCM_CM_ICLKEN1_CORE_EN_GPT7_MASK);\
     newValue <<= PRCM_CM_ICLKEN1_CORE_EN_GPT7_OFFSET;\
     newValue &= PRCM_CM_ICLKEN1_CORE_EN_GPT7_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
 
@@ -200,11 +201,11 @@
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
     const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT832k <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((u32)(baseAddress)+offset);\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8Write32k32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);\
     data |= newValue;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, data);\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
 
@@ -213,11 +214,11 @@
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
     const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8Sys <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((u32)(baseAddress)+offset);\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteSys32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);\
     data |= newValue;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, data);\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
 
@@ -226,11 +227,11 @@
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
     const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8Ext <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((u32)(baseAddress)+offset);\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteExt32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);\
     data |= newValue;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, data);\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
 
@@ -239,11 +240,11 @@
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
     const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT732k <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((u32)(baseAddress)+offset);\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7Write32k32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);\
     data |= newValue;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, data);\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
 
@@ -252,11 +253,11 @@
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
     const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7Sys <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((u32)(baseAddress)+offset);\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteSys32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);\
     data |= newValue;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, data);\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
 
@@ -265,11 +266,11 @@
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
     const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7Ext <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((u32)(baseAddress)+offset);\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteExt32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);\
     data |= newValue;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, data);\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
 
@@ -278,11 +279,11 @@
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
     const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6Sys <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((u32)(baseAddress)+offset);\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteSys32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_MASK);\
     data |= newValue;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, data);\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
 
@@ -291,11 +292,11 @@
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
     const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6Ext <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((u32)(baseAddress)+offset);\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteExt32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_MASK);\
     data |= newValue;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, data);\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
 
@@ -304,11 +305,11 @@
     const u32 offset = CM_CLKSEL_PER_OFFSET;\
     const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532k <<\
       CM_CLKSEL_PER_GPT5_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((u32)(baseAddress)+offset);\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
     _DEBUG_LEVEL_1_EASI(EASIL1_CM_CLKSEL_PER_GPT5Write32k32);\
     data &= ~(CM_CLKSEL_PER_GPT5_MASK);\
     data |= newValue;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, data);\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
 
@@ -317,11 +318,11 @@
     const u32 offset = CM_CLKSEL_PER_OFFSET;\
     const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532k <<\
       CM_CLKSEL_PER_GPT6_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((u32)(baseAddress)+offset);\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
     _DEBUG_LEVEL_1_EASI(EASIL1_CM_CLKSEL_PER_GPT6Write32k32);\
     data &= ~(CM_CLKSEL_PER_GPT6_MASK);\
     data |= newValue;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, data);\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
 
@@ -330,11 +331,11 @@
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
     const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5Sys <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((u32)(baseAddress)+offset);\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteSys32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK);\
     data |= newValue;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, data);\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
 
@@ -343,17 +344,17 @@
     const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
     const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5Ext <<\
       PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((u32)(baseAddress)+offset);\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteExt32);\
     data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK);\
     data |= newValue;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, data);\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
 }
 
 
 #define PRCMCM_CLKSEL1_PLLAPLLs_ClkinRead32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL1_PLLAPLLs_ClkinRead32),\
-      (((RD_MEM_32_VOLATILE((((u32)(baseAddress))+\
+      (((__raw_readl((((u32)(baseAddress))+\
 	(PRCM_CM_CLKSEL1_PLL_OFFSET)))) &\
       PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_MASK) >>\
       PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_OFFSET))
@@ -363,14 +364,14 @@
 {\
     const u32 offset = CM_FCLKEN_IVA2_OFFSET;\
     register u32 data = \
-	RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN_DSPEN_DSPWrite32);\
     data &= ~(CM_FCLKEN_IVA2_EN_MASK);\
     newValue <<= CM_FCLKEN_IVA2_EN_OFFSET;\
     newValue &= CM_FCLKEN_IVA2_EN_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
 
@@ -378,25 +379,25 @@
 {\
     const u32 offset = PRCM_CM_ICLKEN_DSP_OFFSET;\
     register u32 data = \
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+      __raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN_DSPEN_DSP_IPIWrite32);\
     data &= ~(PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK);\
     newValue <<= PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_OFFSET;\
     newValue &= PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
 
 #define PRCMCM_IDLEST_DSPReadRegister32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPReadRegister32),\
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+PRCM_CM_IDLEST_DSP_OFFSET))
+      __raw_readl(((u32)(baseAddress))+PRCM_CM_IDLEST_DSP_OFFSET))
 
 
 #define PRCMCM_IDLEST_DSPST_IPIRead32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_IPIRead32),\
-      (((RD_MEM_32_VOLATILE((((u32)(baseAddress))+\
+      (((__raw_readl((((u32)(baseAddress))+\
 	(PRCM_CM_IDLEST_DSP_OFFSET)))) &\
       PRCM_CM_IDLEST_DSP_ST_IPI_MASK) >>\
       PRCM_CM_IDLEST_DSP_ST_IPI_OFFSET))
@@ -404,7 +405,7 @@
 
 #define PRM_IDLEST_IVA2ST_IVA2Read32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_DSPRead32),\
-      (((RD_MEM_32_VOLATILE((((u32)(baseAddress))+\
+      (((__raw_readl((((u32)(baseAddress))+\
 	  (CM_IDLEST_IVA2_OFFSET)))) &\
       CM_IDLEST_IVA2_ST_IVA2_MASK) >>\
       CM_IDLEST_IVA2_ST_IVA2_OFFSET))
@@ -414,14 +415,14 @@
 {\
     const u32 offset = PRCM_CM_AUTOIDLE_DSP_OFFSET;\
     register u32 data =\
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+      __raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPIWrite32);\
     data &= ~(PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_MASK);\
     newValue <<= PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_OFFSET;\
     newValue &= PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
 
@@ -429,14 +430,14 @@
 {\
     const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;\
     register u32 data = \
-	RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPSYNC_DSPWrite32);\
     data &= ~(PRCM_CM_CLKSEL_DSP_SYNC_DSP_MASK);\
     newValue <<= PRCM_CM_CLKSEL_DSP_SYNC_DSP_OFFSET;\
     newValue &= PRCM_CM_CLKSEL_DSP_SYNC_DSP_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
 
@@ -444,14 +445,14 @@
 {\
     const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;\
     register u32 data = \
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+      __raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_IFWrite32);\
     data &= ~(PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_MASK);\
     newValue <<= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_OFFSET;\
     newValue &= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
 
@@ -459,14 +460,14 @@
 {\
     const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;\
     register u32 data = \
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+      __raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSPWrite32);\
     data &= ~(PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK);\
     newValue <<= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_OFFSET;\
     newValue &= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
 
@@ -474,20 +475,20 @@
 {\
     const u32 offset = PRCM_CM_CLKSTCTRL_IVA2_OFFSET;\
     register u32 data = \
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+      __raw_readl(((baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_IVA2WriteRegister32);\
     data &= ~(CM_CLKSTCTRL_IVA2_MASK);\
     newValue <<= CM_CLKSTCTRL_IVA2_OFFSET;\
     newValue &= CM_CLKSTCTRL_IVA2_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (baseAddress)+offset);\
 }
 
 
 #define PRCMCM_CLKSTCTRL_DSPAutostate_DSPRead32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPRead32),\
-      (((RD_MEM_32_VOLATILE((((u32)(baseAddress))+\
+      (((__raw_readl((((u32)(baseAddress))+\
 	(PRCM_CM_CLKSTCTRL_DSP_OFFSET)))) &\
       PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK) >>\
       PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_OFFSET))
@@ -497,34 +498,34 @@
 {\
     const u32 offset = PRCM_CM_CLKSTCTRL_DSP_OFFSET;\
     register u32 data = \
-	RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPWrite32);\
     data &= ~(PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK);\
     newValue <<= PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_OFFSET;\
     newValue &= PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
 
 #define PRCMRM_RSTCTRL_DSPReadRegister32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPReadRegister32),\
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+PRCM_RM_RSTCTRL_DSP_OFFSET))
+      __raw_readl(((baseAddress))+PRCM_RM_RSTCTRL_DSP_OFFSET))
 
 
 #define PRM_RSTCTRL_IVA2RST1_DSPWrite32(baseAddress,value)\
 {\
     const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;\
     register u32 data =\
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+    __raw_readl(((baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);\
     data &= ~(PRM_RSTCTRL_IVA2_RST1_MASK);\
     newValue <<= PRM_RSTCTRL_IVA2_RST1_OFFSET;\
     newValue &= PRM_RSTCTRL_IVA2_RST1_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (baseAddress)+offset);\
 }
 
 
@@ -532,14 +533,14 @@
 {\
     const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;\
     register u32 data =\
-	RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+	__raw_readl(((baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);\
     data &= ~(PRM_RSTCTRL_IVA2_RST2_MASK);\
     newValue <<= PRM_RSTCTRL_IVA2_RST2_OFFSET;\
     newValue &= PRM_RSTCTRL_IVA2_RST2_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (baseAddress)+offset);\
 }
 
 
@@ -547,20 +548,20 @@
 {\
     const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;\
     register u32 data =\
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+      __raw_readl(((baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);\
     data &= ~(PRM_RSTCTRL_IVA2_RST3_MASK);\
     newValue <<= PRM_RSTCTRL_IVA2_RST3_OFFSET;\
     newValue &= PRM_RSTCTRL_IVA2_RST3_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (baseAddress)+offset);\
 }
 
 
 #define PRCMRM_RSTST_DSPReadRegister32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTST_DSPReadRegister32),\
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+PRCM_RM_RSTST_DSP_OFFSET))
+      __raw_readl(((baseAddress))+PRCM_RM_RSTST_DSP_OFFSET))
 
 
 #define PRCMRM_RSTST_DSPWriteRegister32(baseAddress,value)\
@@ -568,7 +569,7 @@
     const u32 offset = PRCM_RM_RSTST_DSP_OFFSET;\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTST_DSPWriteRegister32);\
-    WR_MEM_32_VOLATILE(((u32)(baseAddress))+offset, newValue);\
+    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
 }
 
 
@@ -576,14 +577,14 @@
 {\
     const u32 offset = PRCM_PM_PWSTCTRL_DSP_OFFSET;\
     register u32 data = \
-	RD_MEM_32_VOLATILE(((u32)(baseAddress))+offset);\
+	__raw_readl(((u32)(baseAddress))+offset);\
     register u32 newValue = ((u32)(value));\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSPForceStateWrite32);\
     data &= ~(PRCM_PM_PWSTCTRL_DSP_ForceState_MASK);\
     newValue <<= PRCM_PM_PWSTCTRL_DSP_ForceState_OFFSET;\
     newValue &= PRCM_PM_PWSTCTRL_DSP_ForceState_MASK;\
     newValue |= data;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, newValue);\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
 }
 
 
@@ -592,11 +593,11 @@
     const u32 offset = PRCM_PM_PWSTCTRL_IVA2_OFFSET;\
     const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2PowerStateON <<\
       PRCM_PM_PWSTCTRL_IVA2_PowerState_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((u32)(baseAddress)+offset);\
+    register u32 data = __raw_readl((baseAddress)+offset);\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteON32);\
     data &= ~(PRCM_PM_PWSTCTRL_IVA2_PowerState_MASK);\
     data |= newValue;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, data);\
+    __raw_writel(data, (baseAddress)+offset);\
 }
 
 
@@ -605,11 +606,11 @@
     const u32 offset = PRCM_PM_PWSTCTRL_IVA2_OFFSET;\
     const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2PowerStateOFF <<\
       PRCM_PM_PWSTCTRL_IVA2_PowerState_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((u32)(baseAddress)+offset);\
+    register u32 data = __raw_readl((baseAddress)+offset);\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteOFF32);\
     data &= ~(PRCM_PM_PWSTCTRL_IVA2_PowerState_MASK);\
     data |= newValue;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, data);\
+    __raw_writel(data, (baseAddress)+offset);\
 }
 
 
@@ -618,27 +619,27 @@
     const u32 offset = PRCM_PM_PWSTCTRL_DSP_OFFSET;\
     const u32 newValue = (u32)PRCMPM_PWSTCTRL_DSPPowerStateRET <<\
       PRCM_PM_PWSTCTRL_DSP_PowerState_OFFSET;\
-    register u32 data = RD_MEM_32_VOLATILE((u32)(baseAddress)+offset);\
+    register u32 data = __raw_readl((baseAddress)+offset);\
     _DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSPPowerStateWriteRET32);\
     data &= ~(PRCM_PM_PWSTCTRL_DSP_PowerState_MASK);\
     data |= newValue;\
-    WR_MEM_32_VOLATILE((u32)(baseAddress)+offset, data);\
+    __raw_writel(data, (baseAddress)+offset);\
 }
 
 
 #define PRCMPM_PWSTST_DSPReadRegister32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_DSPReadRegister32),\
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+PRCM_PM_PWSTST_DSP_OFFSET))
+      __raw_readl(((u32)(baseAddress))+PRCM_PM_PWSTST_DSP_OFFSET))
 
 
 #define PRCMPM_PWSTST_IVA2ReadRegister32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_IVA2ReadRegister32),\
-      RD_MEM_32_VOLATILE(((u32)(baseAddress))+PRCM_PM_PWSTST_IVA2_OFFSET))
+      __raw_readl((baseAddress) + PRCM_PM_PWSTST_IVA2_OFFSET))
 
 
 #define PRCMPM_PWSTST_DSPInTransitionRead32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_DSPInTransitionRead32),\
-      (((RD_MEM_32_VOLATILE((((u32)(baseAddress))+\
+      (((__raw_readl((((u32)(baseAddress))+\
 	(PRCM_PM_PWSTST_DSP_OFFSET)))) &\
       PRCM_PM_PWSTST_DSP_InTransition_MASK) >>\
       PRCM_PM_PWSTST_DSP_InTransition_OFFSET))
@@ -646,7 +647,7 @@
 
 #define PRCMPM_PWSTST_IVA2InTransitionRead32(baseAddress)\
     (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_IVA2InTransitionRead32),\
-      (((RD_MEM_32_VOLATILE((((u32)(baseAddress))+\
+      (((__raw_readl((((baseAddress))+\
 	(PRCM_PM_PWSTST_IVA2_OFFSET)))) &\
       PRCM_PM_PWSTST_IVA2_InTransition_MASK) >>\
       PRCM_PM_PWSTST_IVA2_InTransition_OFFSET))
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/pmgr/cmm.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/pmgr/cmm.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/pmgr/cmm.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/pmgr/cmm.c	2012-12-16 13:13:01.560330147 +0100
@@ -284,8 +284,8 @@ void *CMM_CallocBuf(struct CMM_OBJECT *h
 			 * We'll need to free up a process's alloc'd SM if the
 			 * client process goes away.
 			 */
-                       /* Return PID instead of process handle */
-                       pNode->hClientProc = current->pid;
+			/* Return TGID instead of process handle */
+			pNode->hClientProc = current->tgid;
 
 			/* put our node on InUse list */
 			LST_PutTail(pAllocator->pInUseListHead,
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/pmgr/cod.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/pmgr/cod.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/pmgr/cod.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/pmgr/cod.c	2012-12-16 13:13:01.560330147 +0100
@@ -628,7 +628,8 @@ DSP_STATUS COD_OpenBase(struct COD_MANAG
 	} else {
 		/* hang onto the library for subsequent sym table usage */
 		hMgr->baseLib = lib;
-               strncpy(hMgr->szZLFile, pszCoffPath, COD_MAXPATHLENGTH);
+		strncpy(hMgr->szZLFile, pszCoffPath, COD_MAXPATHLENGTH - 1);
+		hMgr->szZLFile[COD_MAXPATHLENGTH - 1] = '\0';
 	}
 
 	return status;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/pmgr/dbll.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/pmgr/dbll.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/pmgr/dbll.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/pmgr/dbll.c	2012-12-16 13:13:01.560330147 +0100
@@ -459,6 +459,8 @@ DSP_STATUS DBLL_getSect(struct DBLL_Libr
 			(*(zlLib->pTarget->attrs.fseek))(zlLib->fp,
 			 zlLib->ulPos, SEEK_SET);
 		}
+	} else {
+		status = DSP_EHANDLE;
 	}
 	if (DSP_SUCCEEDED(status)) {
 		uByteSize = 1;
@@ -834,8 +836,9 @@ DSP_STATUS DBLL_readSect(struct DBLL_Lib
 			(*(zlLib->pTarget->attrs.fseek))(zlLib->fp,
 				zlLib->ulPos, SEEK_SET);
 		}
+	} else {
+		status = DSP_EHANDLE;
 	}
-
 	if (DSP_FAILED(status))
 		goto func_cont;
 
@@ -1478,6 +1481,7 @@ static int writeMem(struct Dynamic_Loade
 {
 	struct DBLLInit *pInit = (struct DBLLInit *)this;
 	struct DBLL_LibraryObj *lib;
+	struct DBLL_TarObj *pTarget;
 	struct DBLL_SectInfo sectInfo;
 	u32 memType;
 	bool retVal = true;
@@ -1488,20 +1492,24 @@ static int writeMem(struct Dynamic_Loade
 
 	memType = (DLOAD_SECTION_TYPE(info->type) == DLOAD_TEXT) ? DBLL_CODE :
 		  DBLL_DATA;
-	if (lib != NULL) {
-		retVal = (*lib->pTarget->attrs.write)(lib->pTarget->
-			attrs.wHandle, addr, buf, nBytes, memType);
-	}
-	if (lib->pTarget->attrs.logWrite) {
-		sectInfo.name = info->name;
-		sectInfo.runAddr = info->run_addr;
-		sectInfo.loadAddr = info->load_addr;
-		sectInfo.size = info->size;
-		sectInfo.type = memType;
-		/* Pass the information about what we've written to
-		 * another module */
-		(*lib->pTarget->attrs.logWrite)(lib->pTarget->
-			attrs.logWriteHandle, &sectInfo, addr, nBytes);
+	if ((lib != NULL) &&
+	    ((pTarget = lib->pTarget) != NULL) &&
+	    (pTarget->attrs.write != NULL)) {
+		retVal = (*pTarget->attrs.write)(pTarget->attrs.wHandle,
+						 addr, buf, nBytes, memType);
+
+		if (pTarget->attrs.logWrite) {
+			sectInfo.name = info->name;
+			sectInfo.runAddr = info->run_addr;
+			sectInfo.loadAddr = info->load_addr;
+			sectInfo.size = info->size;
+			sectInfo.type = memType;
+			/* Pass the information about what we've written to
+			 * another module */
+			(*pTarget->attrs.logWrite)(
+				pTarget->attrs.logWriteHandle,
+				&sectInfo, addr, nBytes);
+		}
 	}
 	return retVal;
 }
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/pmgr/dmm.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/pmgr/dmm.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/pmgr/dmm.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/pmgr/dmm.c	2012-12-16 13:13:01.560330147 +0100
@@ -113,7 +113,6 @@ struct MapPage {
 static struct MapPage *pVirtualMappingTable;
 static u32  iFreeRegion;	/* The index of free region */
 static u32  iFreeSize;
-static u32  *pPhysicalAddrTable;	/* Physical address of MPU buffer */
 static u32  dynMemMapBeg;	/* The Beginning of dynamic memory mapping */
 static u32  TableSize;/* The size of virtual and physical pages tables */
 
@@ -144,35 +143,18 @@ DSP_STATUS DMM_CreateTables(struct DMM_O
 	if (DSP_SUCCEEDED(status)) {
 		SYNC_EnterCS(pDmmObj->hDmmLock);
 		dynMemMapBeg = addr;
-		TableSize = (size/PG_SIZE_4K) + 1;
+		TableSize = PG_ALIGN_HIGH(size, PG_SIZE_4K)/PG_SIZE_4K;
 		/*  Create the free list */
 		pVirtualMappingTable = (struct MapPage *) MEM_Calloc
-		(TableSize*sizeof(struct MapPage), MEM_NONPAGED);
+			(TableSize * sizeof(struct MapPage), MEM_LARGEVIRTMEM);
 		if (pVirtualMappingTable == NULL)
 			status = DSP_EMEMORY;
 		else {
-			/* This table will be used
-			* to store the virtual to physical
-			* address translations
-			*/
-			pPhysicalAddrTable = (u32 *)MEM_Calloc
-				(TableSize*sizeof(u32), MEM_NONPAGED);
-			GT_1trace(DMM_debugMask, GT_4CLASS,
-			"DMM_CreateTables: Allocate"
-			"memory for pPhysicalAddrTable=%d entries\n",
-			TableSize);
-			if (pPhysicalAddrTable == NULL) {
-				status = DSP_EMEMORY;
-				GT_0trace(DMM_debugMask, GT_7CLASS,
-				    "DMM_CreateTables: Memory allocation for "
-				    "pPhysicalAddrTable failed\n");
-			} else {
 			/* On successful allocation,
 			* all entries are zero ('free') */
 			iFreeRegion = 0;
 			iFreeSize = TableSize*PG_SIZE_4K;
 			pVirtualMappingTable[0].RegionSize = TableSize;
-			}
 		}
 		SYNC_LeaveCS(pDmmObj->hDmmLock);
 	} else
@@ -273,10 +255,7 @@ DSP_STATUS DMM_DeleteTables(struct DMM_O
 		SYNC_EnterCS(pDmmObj->hDmmLock);
 
 		if (pVirtualMappingTable != NULL)
-			MEM_Free(pVirtualMappingTable);
-
-		if (pPhysicalAddrTable != NULL)
-			MEM_Free(pPhysicalAddrTable);
+			MEM_VFree(pVirtualMappingTable);
 
 		SYNC_LeaveCS(pDmmObj->hDmmLock);
 	} else
@@ -361,7 +340,6 @@ bool DMM_Init(void)
 	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
 
 	pVirtualMappingTable = NULL ;
-	pPhysicalAddrTable = NULL ;
 	TableSize = 0;
 
 	return fRetval;
@@ -635,19 +613,6 @@ static struct MapPage *GetMappedRegion(u
 	return currRegion;
 }
 
-/*
- *  ======== DMM_GetPhysicalAddrTable ========
- *  Purpose:
- *  Returns the physical table address
- */
-u32 *DMM_GetPhysicalAddrTable(void)
-{
-	GT_1trace(DMM_debugMask, GT_ENTER, "Entered "
-			"DMM_GetPhysicalAddrTable()- pPhysicalAddrTable 0x%x\n",
-			pPhysicalAddrTable);
-	return pPhysicalAddrTable;
-}
-
 #ifdef DSP_DMM_DEBUG
 u32 DMM_MemMapDump(struct DMM_OBJECT *hDmmMgr)
 {
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/pmgr/msg.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/pmgr/msg.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/pmgr/msg.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/pmgr/msg.c	2012-12-16 13:13:01.560330147 +0100
@@ -158,7 +158,7 @@ bool MSG_Init(void)
 
 	if (cRefs == 0) {
 		DBC_Assert(!MSG_debugMask.flags);
-		GT_create(&MSG_debugMask, "MG");	/* "MG" for MsG */
+		GT_create(&MSG_debugMask, "MS");	/* "MS" for MSg */
 	}
 
 	cRefs++;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/pmgr/wcd.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/pmgr/wcd.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/pmgr/wcd.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/pmgr/wcd.c	2012-12-16 13:13:01.564330147 +0100
@@ -145,31 +145,9 @@
 #define MAX_STREAMS     16
 #define MAX_BUFS	64
 
-/* Following two macros should ideally have do{}while(0) */
-
-#define cp_fm_usr(dest, src, status, elements)    \
-    if (DSP_SUCCEEDED(status)) {\
-	    if (unlikely(src == NULL) ||				\
-		unlikely(copy_from_user(dest, src, elements * sizeof(*(dest))))) { \
-		GT_1trace(WCD_debugMask, GT_7CLASS, \
-		"copy_from_user failed, src=0x%x\n", src);  \
-		status = DSP_EPOINTER ; \
-	} \
-    }
-
-#define cp_to_usr(dest, src, status, elements)    \
-    if (DSP_SUCCEEDED(status)) {\
-	    if (unlikely(dest == NULL) ||				\
-		unlikely(copy_to_user(dest, src, elements * sizeof(*(src))))) { \
-		GT_1trace(WCD_debugMask, GT_7CLASS, \
-		"copy_to_user failed, dest=0x%x\n", dest); \
-		status = DSP_EPOINTER ;\
-	} \
-    }
-
 /* Device IOCtl function pointer */
 struct WCD_Cmd {
-	u32(*fxn)(union Trapped_Args *args);
+	u32(*fxn)(union Trapped_Args *args, void *pr_ctxt);
 	u32 dwIndex;
 } ;
 
@@ -179,6 +157,46 @@ static struct GT_Mask WCD_debugMask = {
 #endif
 static u32 WCD_cRefs;
 
+static inline void __cp_fm_usr(void *to, const void __user *from,
+			       DSP_STATUS *err, unsigned long bytes)
+{
+	if (DSP_FAILED(*err))
+		return;
+
+	if (unlikely(!from)) {
+		*err = DSP_EPOINTER;
+		return;
+	}
+
+	if (unlikely(copy_from_user(to, from, bytes))) {
+		GT_2trace(WCD_debugMask, GT_7CLASS,
+			  "%s failed, from=0x%08x\n", __func__, from);
+		*err = DSP_EPOINTER;
+	}
+}
+#define cp_fm_usr(to, from, err, n)				\
+	__cp_fm_usr(to, from, &(err), (n) * sizeof(*(to)))
+
+static inline void __cp_to_usr(void __user *to, const void *from,
+			       DSP_STATUS *err, unsigned long bytes)
+{
+	if (DSP_FAILED(*err))
+		return;
+
+	if (unlikely(!to)) {
+		*err = DSP_EPOINTER;
+		return;
+	}
+
+	if (unlikely(copy_to_user(to, from, bytes))) {
+		GT_2trace(WCD_debugMask, GT_7CLASS,
+			  "%s failed, to=0x%08x\n", __func__, to);
+		*err = DSP_EPOINTER;
+	}
+}
+#define cp_to_usr(to, from, err, n)				\
+	__cp_to_usr(to, from, &(err), (n) * sizeof(*(from)))
+
 /*
  *  Function table.
  *  The order of these functions MUST be the same as the order of the command
@@ -254,11 +272,11 @@ static struct WCD_Cmd WCD_cmdTable[] = {
  *      Call the (wrapper) function for the corresponding WCD IOCTL.
  */
 inline DSP_STATUS WCD_CallDevIOCtl(u32 cmd, union Trapped_Args *args,
-				    u32 *pResult)
+				    u32 *pResult, void *pr_ctxt)
 {
 	if ((cmd < (sizeof(WCD_cmdTable) / sizeof(struct WCD_Cmd)))) {
 		/* make the fxn call via the cmd table */
-		*pResult = (*WCD_cmdTable[cmd].fxn) (args);
+		*pResult = (*WCD_cmdTable[cmd].fxn) (args, pr_ctxt);
 		return DSP_SOK;
 	} else {
 		return DSP_EINVALIDARG;
@@ -442,7 +460,7 @@ DSP_STATUS WCD_InitComplete2(void)
 /*
  * ======== MGRWRAP_EnumNode_Info ========
  */
-u32 MGRWRAP_EnumNode_Info(union Trapped_Args *args)
+u32 MGRWRAP_EnumNode_Info(union Trapped_Args *args, void *pr_ctxt)
 {
 	u8 *pNDBProps;
 	u32 uNumNodes;
@@ -478,7 +496,7 @@ u32 MGRWRAP_EnumNode_Info(union Trapped_
 /*
  * ======== MGRWRAP_EnumProc_Info ========
  */
-u32 MGRWRAP_EnumProc_Info(union Trapped_Args *args)
+u32 MGRWRAP_EnumProc_Info(union Trapped_Args *args, void *pr_ctxt)
 {
 	u8 *pProcessorInfo;
 	u32 uNumProcs;
@@ -517,43 +535,71 @@ u32 MGRWRAP_EnumProc_Info(union Trapped_
 /*
  * ======== MGRWRAP_RegisterObject ========
  */
-u32 MGRWRAP_RegisterObject(union Trapped_Args *args)
+u32 MGRWRAP_RegisterObject(union Trapped_Args *args, void *pr_ctxt)
 {
 	u32 retVal;
+	struct DSP_UUID pUuid;
+	u32 pathSize = 0;
+	char *pszPathName = NULL;
+	DSP_STATUS status = DSP_SOK;
+
+	cp_fm_usr(&pUuid, args->ARGS_MGR_REGISTEROBJECT.pUuid, status, 1);
+	if (DSP_FAILED(status))
+		goto func_end;
+	/* pathSize is increased by 1 to accommodate NULL */
+	pathSize = strlen_user((char *)
+			args->ARGS_MGR_REGISTEROBJECT.pszPathName) + 1;
+	pszPathName = MEM_Alloc(pathSize, MEM_NONPAGED);
+	if (!pszPathName)
+		goto func_end;
+	retVal = strncpy_from_user(pszPathName,
+			(char *)args->ARGS_MGR_REGISTEROBJECT.pszPathName,
+			pathSize);
+	if (!retVal) {
+		status = DSP_EPOINTER;
+		goto func_end;
+	}
 
 	GT_1trace(WCD_debugMask, GT_ENTER,
 		 "MGRWRAP_RegisterObject: entered pg2hMsg "
 		 "0x%x\n", args->ARGS_MGR_REGISTEROBJECT.pUuid);
-	retVal = DCD_RegisterObject(WRAP_MAP2CALLER
-		    (args->ARGS_MGR_REGISTEROBJECT.pUuid),
-		    args->ARGS_MGR_REGISTEROBJECT.objType,
-		    WRAP_MAP2CALLER(args->ARGS_MGR_REGISTEROBJECT.pszPathName));
-	return retVal;
+	status = DCD_RegisterObject(&pUuid,
+				args->ARGS_MGR_REGISTEROBJECT.objType,
+				(char *)pszPathName);
+func_end:
+	if (pszPathName)
+		MEM_Free(pszPathName);
+	return status;
 }
 
 /*
  * ======== MGRWRAP_UnregisterObject ========
  */
-u32 MGRWRAP_UnregisterObject(union Trapped_Args *args)
+u32 MGRWRAP_UnregisterObject(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	DSP_STATUS status = DSP_SOK;
+	struct DSP_UUID pUuid;
+
+	cp_fm_usr(&pUuid, args->ARGS_MGR_REGISTEROBJECT.pUuid, status, 1);
+	if (DSP_FAILED(status))
+		goto func_end;
 
 	GT_1trace(WCD_debugMask, GT_ENTER,
 		 "MGRWRAP_UnregisterObject: entered pg2hMsg"
 		 " 0x%x\n", args->ARGS_MGR_UNREGISTEROBJECT.pUuid);
-	retVal = DCD_UnregisterObject(WRAP_MAP2CALLER
-			(args->ARGS_MGR_UNREGISTEROBJECT.pUuid),
+	status = DCD_UnregisterObject(&pUuid,
 			args->ARGS_MGR_UNREGISTEROBJECT.objType);
+func_end:
+	return status;
 
-	return retVal;
 }
 
 /*
  * ======== MGRWRAP_WaitForBridgeEvents ========
  */
-u32 MGRWRAP_WaitForBridgeEvents(union Trapped_Args *args)
+u32 MGRWRAP_WaitForBridgeEvents(union Trapped_Args *args, void *pr_ctxt)
 {
-	DSP_STATUS status = DSP_SOK;
+	DSP_STATUS status = DSP_SOK, real_status = DSP_SOK;
 	struct DSP_NOTIFICATION *aNotifications[MAX_EVENTS];
 	struct DSP_NOTIFICATION notifications[MAX_EVENTS];
 	u32 uIndex, i;
@@ -577,11 +623,11 @@ u32 MGRWRAP_WaitForBridgeEvents(union Tr
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
-		status = MGR_WaitForBridgeEvents(aNotifications, uCount,
+		real_status = MGR_WaitForBridgeEvents(aNotifications, uCount,
 			 &uIndex, args->ARGS_MGR_WAIT.uTimeout);
 	}
 	cp_to_usr(args->ARGS_MGR_WAIT.puIndex, &uIndex, status, 1);
-	return status;
+	return real_status;
 }
 
 
@@ -589,7 +635,7 @@ u32 MGRWRAP_WaitForBridgeEvents(union Tr
 /*
  * ======== MGRWRAP_GetProcessResourceInfo ========
  */
-u32 MGRWRAP_GetProcessResourcesInfo(union Trapped_Args *args)
+u32 MGRWRAP_GetProcessResourcesInfo(union Trapped_Args *args, void *pr_ctxt)
 {
     DSP_STATUS status = DSP_SOK;
     u32 uSize = 0;
@@ -612,7 +658,7 @@ u32 MGRWRAP_GetProcessResourcesInfo(unio
 /*
  * ======== PROCWRAP_Attach ========
  */
-u32 PROCWRAP_Attach(union Trapped_Args *args)
+u32 PROCWRAP_Attach(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_HPROCESSOR processor;
 	DSP_STATUS status = DSP_SOK;
@@ -629,18 +675,22 @@ u32 PROCWRAP_Attach(union Trapped_Args *
 		cp_fm_usr(&attrIn, args->ARGS_PROC_ATTACH.pAttrIn, status, 1);
 		if (DSP_SUCCEEDED(status))
 			pAttrIn = &attrIn;
+		else
+			goto func_end;
+
 
 	}
 	status = PROC_Attach(args->ARGS_PROC_ATTACH.uProcessor, pAttrIn,
-			    &processor);
+			    &processor, pr_ctxt);
 	cp_to_usr(args->ARGS_PROC_ATTACH.phProcessor, &processor, status, 1);
+func_end:
 	return status;
 }
 
 /*
  * ======== PROCWRAP_Ctrl ========
  */
-u32 PROCWRAP_Ctrl(union Trapped_Args *args)
+u32 PROCWRAP_Ctrl(union Trapped_Args *args, void *pr_ctxt)
 {
 	u32 cbDataSize, __user *pSize = (u32 __user *)
 			args->ARGS_PROC_CTRL.pArgs;
@@ -654,16 +704,17 @@ u32 PROCWRAP_Ctrl(union Trapped_Args *ar
 		 args->ARGS_PROC_CTRL.dwCmd,
 		 args->ARGS_PROC_CTRL.pArgs);
 	if (pSize) {
-		if (get_user(cbDataSize, pSize))
+		if (get_user(cbDataSize, pSize)) {
 			status = DSP_EFAIL;
-
+			goto func_end;
+		}
 		cbDataSize += sizeof(u32);
-		if (DSP_SUCCEEDED(status)) {
-			pArgs = MEM_Alloc(cbDataSize, MEM_NONPAGED);
-			if (pArgs == NULL)
-				status = DSP_EMEMORY;
-
+		pArgs = MEM_Alloc(cbDataSize, MEM_NONPAGED);
+		if (pArgs == NULL) {
+			status = DSP_EMEMORY;
+			goto func_end;
 		}
+
 		cp_fm_usr(pArgs, args->ARGS_PROC_CTRL.pArgs, status,
 			 cbDataSize);
 	}
@@ -676,21 +727,21 @@ u32 PROCWRAP_Ctrl(union Trapped_Args *ar
 	/* cp_to_usr(args->ARGS_PROC_CTRL.pArgs, pArgs, status, 1);*/
 	if (pArgs)
 		MEM_Free(pArgs);
-
+func_end:
 	return status;
 }
 
 /*
  * ======== PROCWRAP_Detach ========
  */
-u32 PROCWRAP_Detach(union Trapped_Args *args)
+u32 PROCWRAP_Detach(union Trapped_Args *args, void *pr_ctxt)
 {
 	u32 retVal;
 
 	GT_1trace(WCD_debugMask, GT_ENTER,
 		 "PROCWRAP_Detach: entered args\n0x%x "
 		 "hProceesor \n", args->ARGS_PROC_DETACH.hProcessor);
-	retVal = PROC_Detach(args->ARGS_PROC_DETACH.hProcessor);
+	retVal = PROC_Detach(args->ARGS_PROC_DETACH.hProcessor, pr_ctxt);
 
 	return retVal;
 }
@@ -698,7 +749,7 @@ u32 PROCWRAP_Detach(union Trapped_Args *
 /*
  * ======== PROCWRAP_EnumNode_Info ========
  */
-u32 PROCWRAP_EnumNode_Info(union Trapped_Args *args)
+u32 PROCWRAP_EnumNode_Info(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
 	DSP_HNODE aNodeTab[MAX_NODES];
@@ -731,7 +782,7 @@ u32 PROCWRAP_EnumNode_Info(union Trapped
 /*
  * ======== PROCWRAP_FlushMemory ========
  */
-u32 PROCWRAP_FlushMemory(union Trapped_Args *args)
+u32 PROCWRAP_FlushMemory(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
 
@@ -748,7 +799,7 @@ u32 PROCWRAP_FlushMemory(union Trapped_A
 /*
  * ======== PROCWRAP_InvalidateMemory ========
  */
-u32 PROCWRAP_InvalidateMemory(union Trapped_Args *args)
+u32 PROCWRAP_InvalidateMemory(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
 
@@ -766,9 +817,13 @@ u32 PROCWRAP_InvalidateMemory(union Trap
 /*
  * ======== PROCWRAP_EnumResources ========
  */
-u32 PROCWRAP_EnumResources(union Trapped_Args *args)
+u32 PROCWRAP_EnumResources(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
+	DSP_STATUS status = DSP_SOK;
+	struct DSP_RESOURCEINFO pResourceInfo;
+
+	if (DSP_FAILED(status))
+		goto func_end;
 
 	GT_4trace(WCD_debugMask, GT_ENTER,
 		 "PROCWRAP_EnumResources: entered args:\n"
@@ -778,19 +833,23 @@ u32 PROCWRAP_EnumResources(union Trapped
 		 args->ARGS_PROC_ENUMRESOURCES.uResourceType,
 		 args->ARGS_PROC_ENUMRESOURCES.pResourceInfo,
 		 args->ARGS_PROC_ENUMRESOURCES.uResourceInfoSize);
-	retVal = PROC_GetResourceInfo(args->ARGS_PROC_ENUMRESOURCES.hProcessor,
+	status = PROC_GetResourceInfo(args->ARGS_PROC_ENUMRESOURCES.hProcessor,
 			args->ARGS_PROC_ENUMRESOURCES.uResourceType,
-			WRAP_MAP2CALLER(args->ARGS_PROC_ENUMRESOURCES.
-			pResourceInfo), args->ARGS_PROC_ENUMRESOURCES.
-			uResourceInfoSize);
+			&pResourceInfo,
+			args->ARGS_PROC_ENUMRESOURCES.uResourceInfoSize);
+	if (DSP_FAILED(status))
+		goto func_end;
+	cp_to_usr(args->ARGS_PROC_ENUMRESOURCES.pResourceInfo, &pResourceInfo,
+						status, 1);
+func_end:
+	return status;
 
-	return retVal;
 }
 
 /*
  * ======== PROCWRAP_GetState ========
  */
-u32 PROCWRAP_GetState(union Trapped_Args *args)
+u32 PROCWRAP_GetState(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
 	struct DSP_PROCESSORSTATE procStatus;
@@ -805,7 +864,7 @@ u32 PROCWRAP_GetState(union Trapped_Args
 /*
  * ======== PROCWRAP_GetTrace ========
  */
-u32 PROCWRAP_GetTrace(union Trapped_Args *args)
+u32 PROCWRAP_GetTrace(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
 	u8 *pBuf;
@@ -832,96 +891,126 @@ u32 PROCWRAP_GetTrace(union Trapped_Args
 /*
  * ======== PROCWRAP_Load ========
  */
-u32 PROCWRAP_Load(union Trapped_Args *args)
+u32 PROCWRAP_Load(union Trapped_Args *args, void *pr_ctxt)
 {
 	s32 i, len;
 	DSP_STATUS status = DSP_SOK;
-       char *temp;
-	s32 argc = args->ARGS_PROC_LOAD.iArgc;
+	char *temp;
+	s32 count = args->ARGS_PROC_LOAD.iArgc;
 	u8 **argv, **envp = NULL;
 
+	DBC_Require(count > 0);
+	DBC_Require(count <= MAX_LOADARGS);
 
-	DBC_Require(argc > 0);
-	DBC_Require(argc <= MAX_LOADARGS);
-
-	argv = MEM_Alloc(argc * sizeof(u8 *), MEM_NONPAGED);
-	if (argv == NULL)
+	argv = MEM_Alloc(count * sizeof(u8 *), MEM_NONPAGED);
+	if (!argv) {
 		status = DSP_EMEMORY;
+		goto func_cont;
+	}
+
+	cp_fm_usr(argv, args->ARGS_PROC_LOAD.aArgv, status, count);
+	if (DSP_FAILED(status)) {
+		MEM_Free(argv);
+		argv = NULL;
+		goto func_cont;
+	}
 
-	cp_fm_usr(argv, args->ARGS_PROC_LOAD.aArgv, status, argc);
-	for (i = 0; DSP_SUCCEEDED(status) && (i < argc); i++) {
-		if (argv[i] != NULL) {
-                        /* User space pointer to argument */
-                       temp = (char *) argv[i];
-                       len = strlen_user((char *)temp);
+	for (i = 0; i < count; i++) {
+		if (argv[i]) {
+			/* User space pointer to argument */
+			temp = (char *) argv[i];
+			/* len is increased by 1 to accommodate NULL */
+			len = strlen_user((char *)temp) + 1;
 			/* Kernel space pointer to argument */
 			argv[i] = MEM_Alloc(len, MEM_NONPAGED);
-			if (argv[i] == NULL) {
+			if (argv[i]) {
+				cp_fm_usr(argv[i], temp, status, len);
+				if (DSP_FAILED(status)) {
+					MEM_Free(argv[i]);
+					argv[i] = NULL;
+					goto func_cont;
+				}
+			} else {
 				status = DSP_EMEMORY;
-				break;
+				goto func_cont;
 			}
-			cp_fm_usr(argv[i], temp, status, len);
 		}
 	}
 	/* TODO: validate this */
-	if (args->ARGS_PROC_LOAD.aEnvp != NULL) {
+	if (args->ARGS_PROC_LOAD.aEnvp) {
 		/* number of elements in the envp array including NULL */
-		len = 0;
+		count = 0;
 		do {
-			len++;
-                       get_user(temp, args->ARGS_PROC_LOAD.aEnvp);
-               } while (temp);
-		envp = MEM_Alloc(len * sizeof(u8 *), MEM_NONPAGED);
-		if (envp == NULL)
+			get_user(temp, args->ARGS_PROC_LOAD.aEnvp + count);
+			count++;
+		} while (temp);
+		envp = MEM_Alloc(count * sizeof(u8 *), MEM_NONPAGED);
+		if (!envp) {
 			status = DSP_EMEMORY;
+			goto func_cont;
+		}
 
-		cp_fm_usr(envp, args->ARGS_PROC_LOAD.aEnvp, status, len);
-		for (i = 0; DSP_SUCCEEDED(status) && (envp[i] != NULL); i++) {
-                        /* User space pointer to argument */
-                       temp = (char *)envp[i];
-                       len = strlen_user((char *)temp);
+		cp_fm_usr(envp, args->ARGS_PROC_LOAD.aEnvp, status, count);
+		if (DSP_FAILED(status)) {
+			MEM_Free(envp);
+			envp = NULL;
+			goto func_cont;
+		}
+		for (i = 0; envp[i]; i++) {
+			/* User space pointer to argument */
+			temp = (char *)envp[i];
+			/* len is increased by 1 to accommodate NULL */
+			len = strlen_user((char *)temp) + 1;
 			/* Kernel space pointer to argument */
 			envp[i] = MEM_Alloc(len, MEM_NONPAGED);
-			if (envp[i] == NULL) {
+			if (envp[i]) {
+				cp_fm_usr(envp[i], temp, status, len);
+				if (DSP_FAILED(status)) {
+					MEM_Free(envp[i]);
+					envp[i] = NULL;
+					goto func_cont;
+				}
+			} else {
 				status = DSP_EMEMORY;
-				break;
+				goto func_cont;
 			}
-			cp_fm_usr(envp[i], temp, status, len);
 		}
 	}
 	GT_5trace(WCD_debugMask, GT_ENTER,
-		 "PROCWRAP_Load, hProcessor: 0x%x\n\tiArgc:"
-		 "0x%x\n\taArgv: 0x%x\n\taArgv[0]: %s\n\taEnvp: 0x%0x\n",
-		 args->ARGS_PROC_LOAD.hProcessor,
-		 args->ARGS_PROC_LOAD.iArgc, args->ARGS_PROC_LOAD.aArgv,
-		 argv[0], args->ARGS_PROC_LOAD.aEnvp);
+		"PROCWRAP_Load, hProcessor: 0x%x\n\tiArgc:"
+		"0x%x\n\taArgv: 0x%x\n\taArgv[0]: %s\n\taEnvp: 0x%0x\n",
+		args->ARGS_PROC_LOAD.hProcessor,
+		args->ARGS_PROC_LOAD.iArgc, args->ARGS_PROC_LOAD.aArgv,
+		argv[0], args->ARGS_PROC_LOAD.aEnvp);
 	if (DSP_SUCCEEDED(status)) {
 		status = PROC_Load(args->ARGS_PROC_LOAD.hProcessor,
-				  args->ARGS_PROC_LOAD.iArgc,
-				  (CONST char **)argv, (CONST char **)envp);
+				args->ARGS_PROC_LOAD.iArgc,
+				(CONST char **)argv, (CONST char **)envp);
 	}
-	if (envp != NULL) {
+func_cont:
+	if (envp) {
 		i = 0;
-		while (envp[i] != NULL)
+		while (envp[i])
 			MEM_Free(envp[i++]);
 
 		MEM_Free(envp);
 	}
-	if (argv != NULL) {
-		for (i = 0; i < argc; i++) {
-			if (argv[i] != NULL)
-				MEM_Free(argv[i]);
 
-		}
+	if (argv) {
+		count = args->ARGS_PROC_LOAD.iArgc;
+		for (i = 0; (i < count) && argv[i]; i++)
+			MEM_Free(argv[i]);
+
 		MEM_Free(argv);
 	}
+
 	return status;
 }
 
 /*
  * ======== PROCWRAP_Map ========
  */
-u32 PROCWRAP_Map(union Trapped_Args *args)
+u32 PROCWRAP_Map(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
 	void *pMapAddr;
@@ -931,7 +1020,7 @@ u32 PROCWRAP_Map(union Trapped_Args *arg
 			 args->ARGS_PROC_MAPMEM.pMpuAddr,
 			 args->ARGS_PROC_MAPMEM.ulSize,
 			 args->ARGS_PROC_MAPMEM.pReqAddr, &pMapAddr,
-			 args->ARGS_PROC_MAPMEM.ulMapAttr);
+			 args->ARGS_PROC_MAPMEM.ulMapAttr, pr_ctxt);
 	if (DSP_SUCCEEDED(status)) {
 		if (put_user(pMapAddr, args->ARGS_PROC_MAPMEM.ppMapAddr))
 			status = DSP_EINVALIDARG;
@@ -943,7 +1032,7 @@ u32 PROCWRAP_Map(union Trapped_Args *arg
 /*
  * ======== PROCWRAP_RegisterNotify ========
  */
-u32 PROCWRAP_RegisterNotify(union Trapped_Args *args)
+u32 PROCWRAP_RegisterNotify(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
 	struct DSP_NOTIFICATION notification;
@@ -967,7 +1056,7 @@ u32 PROCWRAP_RegisterNotify(union Trappe
 /*
  * ======== PROCWRAP_ReserveMemory ========
  */
-u32 PROCWRAP_ReserveMemory(union Trapped_Args *args)
+u32 PROCWRAP_ReserveMemory(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
 	void *pRsvAddr;
@@ -984,7 +1073,7 @@ u32 PROCWRAP_ReserveMemory(union Trapped
 /*
  * ======== PROCWRAP_Start ========
  */
-u32 PROCWRAP_Start(union Trapped_Args *args)
+u32 PROCWRAP_Start(union Trapped_Args *args, void *pr_ctxt)
 {
 	u32 retVal;
 
@@ -996,20 +1085,20 @@ u32 PROCWRAP_Start(union Trapped_Args *a
 /*
  * ======== PROCWRAP_UnMap ========
  */
-u32 PROCWRAP_UnMap(union Trapped_Args *args)
+u32 PROCWRAP_UnMap(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "PROCWRAP_UnMap: entered\n");
 	status = PROC_UnMap(args->ARGS_PROC_UNMAPMEM.hProcessor,
-			   args->ARGS_PROC_UNMAPMEM.pMapAddr);
+			   args->ARGS_PROC_UNMAPMEM.pMapAddr, pr_ctxt);
 	return status;
 }
 
 /*
  * ======== PROCWRAP_UnReserveMemory ========
  */
-u32 PROCWRAP_UnReserveMemory(union Trapped_Args *args)
+u32 PROCWRAP_UnReserveMemory(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
 
@@ -1023,7 +1112,7 @@ u32 PROCWRAP_UnReserveMemory(union Trapp
 /*
  * ======== PROCWRAP_Stop ========
  */
-u32 PROCWRAP_Stop(union Trapped_Args *args)
+u32 PROCWRAP_Stop(union Trapped_Args *args, void *pr_ctxt)
 {
 	u32 retVal;
 
@@ -1036,11 +1125,11 @@ u32 PROCWRAP_Stop(union Trapped_Args *ar
 /*
  * ======== NODEWRAP_Allocate ========
  */
-u32 NODEWRAP_Allocate(union Trapped_Args *args)
+u32 NODEWRAP_Allocate(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct DSP_UUID nodeId;
-	u32 cbDataSize;
+	u32 cbDataSize = 0;
 	u32 __user *pSize = (u32 __user *)args->ARGS_NODE_ALLOCATE.pArgs;
 	u8 *pArgs = NULL;
 	struct DSP_NODEATTRIN attrIn, *pAttrIn = NULL;
@@ -1064,19 +1153,24 @@ u32 NODEWRAP_Allocate(union Trapped_Args
 			 cbDataSize);
 	}
 	cp_fm_usr(&nodeId, args->ARGS_NODE_ALLOCATE.pNodeID, status, 1);
+	if (DSP_FAILED(status))
+		goto func_cont;
 	/* Optional argument */
 	if (args->ARGS_NODE_ALLOCATE.pAttrIn) {
 		cp_fm_usr(&attrIn, args->ARGS_NODE_ALLOCATE.pAttrIn, status, 1);
 		if (DSP_SUCCEEDED(status))
 			pAttrIn = &attrIn;
+		else
+			status = DSP_EMEMORY;
 
 	}
 	if (DSP_SUCCEEDED(status)) {
 		status = NODE_Allocate(args->ARGS_NODE_ALLOCATE.hProcessor,
 				      &nodeId, (struct DSP_CBDATA *)pArgs,
-				      pAttrIn, &hNode);
+				      pAttrIn, &hNode, pr_ctxt);
 	}
 	cp_to_usr(args->ARGS_NODE_ALLOCATE.phNode, &hNode, status, 1);
+func_cont:
 	if (pArgs)
 		MEM_Free(pArgs);
 
@@ -1086,7 +1180,7 @@ u32 NODEWRAP_Allocate(union Trapped_Args
 /*
  *  ======== NODEWRAP_AllocMsgBuf ========
  */
-u32 NODEWRAP_AllocMsgBuf(union Trapped_Args *args)
+u32 NODEWRAP_AllocMsgBuf(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct DSP_BUFFERATTR *pAttr = NULL;
@@ -1106,14 +1200,14 @@ u32 NODEWRAP_AllocMsgBuf(union Trapped_A
 					 args->ARGS_NODE_ALLOCMSGBUF.uSize,
 					 pAttr, &pBuffer);
 	}
-	cp_to_usr(args->ARGS_NODE_ALLOCMSGBUF.pBuffer, &pBuffer, status, 1)
+	cp_to_usr(args->ARGS_NODE_ALLOCMSGBUF.pBuffer, &pBuffer, status, 1);
 	return status;
 }
 
 /*
  * ======== NODEWRAP_ChangePriority ========
  */
-u32 NODEWRAP_ChangePriority(union Trapped_Args *args)
+u32 NODEWRAP_ChangePriority(union Trapped_Args *args, void *pr_ctxt)
 {
 	u32 retVal;
 
@@ -1128,7 +1222,7 @@ u32 NODEWRAP_ChangePriority(union Trappe
 /*
  * ======== NODEWRAP_Connect ========
  */
-u32 NODEWRAP_Connect(union Trapped_Args *args)
+u32 NODEWRAP_Connect(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct DSP_STRMATTR attrs;
@@ -1147,12 +1241,16 @@ u32 NODEWRAP_Connect(union Trapped_Args
 		cbDataSize += sizeof(u32);
 		if (DSP_SUCCEEDED(status)) {
 			pArgs = MEM_Alloc(cbDataSize, MEM_NONPAGED);
-			if (pArgs == NULL)
+			if (pArgs == NULL) {
 				status = DSP_EMEMORY;
+				goto func_cont;
+			}
 
 		}
 		cp_fm_usr(pArgs, args->ARGS_NODE_CONNECT.pConnParam, status,
 			 cbDataSize);
+		if (DSP_FAILED(status))
+			goto func_cont;
 	}
 	if (args->ARGS_NODE_CONNECT.pAttrs) {	/* Optional argument */
 		cp_fm_usr(&attrs, args->ARGS_NODE_CONNECT.pAttrs, status, 1);
@@ -1167,6 +1265,7 @@ u32 NODEWRAP_Connect(union Trapped_Args
 				     args->ARGS_NODE_CONNECT.uOtherStream,
 				     pAttrs, (struct DSP_CBDATA *)pArgs);
 	}
+func_cont:
 	if (pArgs)
 		MEM_Free(pArgs);
 
@@ -1176,7 +1275,7 @@ u32 NODEWRAP_Connect(union Trapped_Args
 /*
  * ======== NODEWRAP_Create ========
  */
-u32 NODEWRAP_Create(union Trapped_Args *args)
+u32 NODEWRAP_Create(union Trapped_Args *args, void *pr_ctxt)
 {
 	u32 retVal;
 
@@ -1189,12 +1288,12 @@ u32 NODEWRAP_Create(union Trapped_Args *
 /*
  * ======== NODEWRAP_Delete ========
  */
-u32 NODEWRAP_Delete(union Trapped_Args *args)
+u32 NODEWRAP_Delete(union Trapped_Args *args, void *pr_ctxt)
 {
 	u32 retVal;
 
 	GT_0trace(WCD_debugMask, GT_ENTER, "NODEWRAP_Delete: entered\n");
-	retVal = NODE_Delete(args->ARGS_NODE_DELETE.hNode);
+	retVal = NODE_Delete(args->ARGS_NODE_DELETE.hNode, pr_ctxt);
 
 	return retVal;
 }
@@ -1202,7 +1301,7 @@ u32 NODEWRAP_Delete(union Trapped_Args *
 /*
  *  ======== NODEWRAP_FreeMsgBuf ========
  */
-u32 NODEWRAP_FreeMsgBuf(union Trapped_Args *args)
+u32 NODEWRAP_FreeMsgBuf(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct DSP_BUFFERATTR *pAttr = NULL;
@@ -1225,7 +1324,7 @@ u32 NODEWRAP_FreeMsgBuf(union Trapped_Ar
 /*
  * ======== NODEWRAP_GetAttr ========
  */
-u32 NODEWRAP_GetAttr(union Trapped_Args *args)
+u32 NODEWRAP_GetAttr(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct DSP_NODEATTR attr;
@@ -1242,7 +1341,7 @@ u32 NODEWRAP_GetAttr(union Trapped_Args
 /*
  * ======== NODEWRAP_GetMessage ========
  */
-u32 NODEWRAP_GetMessage(union Trapped_Args *args)
+u32 NODEWRAP_GetMessage(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
 	struct DSP_MSG msg;
@@ -1260,7 +1359,7 @@ u32 NODEWRAP_GetMessage(union Trapped_Ar
 /*
  * ======== NODEWRAP_Pause ========
  */
-u32 NODEWRAP_Pause(union Trapped_Args *args)
+u32 NODEWRAP_Pause(union Trapped_Args *args, void *pr_ctxt)
 {
 	u32 retVal;
 
@@ -1273,7 +1372,7 @@ u32 NODEWRAP_Pause(union Trapped_Args *a
 /*
  * ======== NODEWRAP_PutMessage ========
  */
-u32 NODEWRAP_PutMessage(union Trapped_Args *args)
+u32 NODEWRAP_PutMessage(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct DSP_MSG msg;
@@ -1293,7 +1392,7 @@ u32 NODEWRAP_PutMessage(union Trapped_Ar
 /*
  * ======== NODEWRAP_RegisterNotify ========
  */
-u32 NODEWRAP_RegisterNotify(union Trapped_Args *args)
+u32 NODEWRAP_RegisterNotify(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct DSP_NOTIFICATION notification;
@@ -1317,7 +1416,7 @@ u32 NODEWRAP_RegisterNotify(union Trappe
 /*
  * ======== NODEWRAP_Run ========
  */
-u32 NODEWRAP_Run(union Trapped_Args *args)
+u32 NODEWRAP_Run(union Trapped_Args *args, void *pr_ctxt)
 {
 	u32 retVal;
 
@@ -1330,7 +1429,7 @@ u32 NODEWRAP_Run(union Trapped_Args *arg
 /*
  * ======== NODEWRAP_Terminate ========
  */
-u32 NODEWRAP_Terminate(union Trapped_Args *args)
+u32 NODEWRAP_Terminate(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
 	DSP_STATUS tempstatus;
@@ -1348,7 +1447,7 @@ u32 NODEWRAP_Terminate(union Trapped_Arg
 /*
  * ======== NODEWRAP_GetUUIDProps ========
  */
-u32 NODEWRAP_GetUUIDProps(union Trapped_Args *args)
+u32 NODEWRAP_GetUUIDProps(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct DSP_UUID nodeId;
@@ -1359,6 +1458,8 @@ u32 NODEWRAP_GetUUIDProps(union Trapped_
 
 
 	cp_fm_usr(&nodeId, args->ARGS_NODE_GETUUIDPROPS.pNodeID, status, 1);
+	if (DSP_FAILED(status))
+		goto func_cont;
 	pnodeProps = MEM_Alloc(sizeof(struct DSP_NDBPROPS), MEM_NONPAGED);
 	if (pnodeProps != NULL) {
 		status = NODE_GetUUIDProps(args->
@@ -1366,8 +1467,9 @@ u32 NODEWRAP_GetUUIDProps(union Trapped_
 					  &nodeId, pnodeProps);
 		cp_to_usr(args->ARGS_NODE_GETUUIDPROPS.pNodeProps, pnodeProps,
 			 status, 1);
-	}	else
+	} else
 		status = DSP_EMEMORY;
+func_cont:
 	if (pnodeProps)
 		MEM_Free(pnodeProps);
 	return status;
@@ -1376,7 +1478,7 @@ u32 NODEWRAP_GetUUIDProps(union Trapped_
 /*
  * ======== STRMWRAP_AllocateBuffer ========
  */
-u32 STRMWRAP_AllocateBuffer(union Trapped_Args *args)
+u32 STRMWRAP_AllocateBuffer(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status;
 	u8 **apBuffer = NULL;
@@ -1388,7 +1490,7 @@ u32 STRMWRAP_AllocateBuffer(union Trappe
 
 	status = STRM_AllocateBuffer(args->ARGS_STRM_ALLOCATEBUFFER.hStream,
 				     args->ARGS_STRM_ALLOCATEBUFFER.uSize,
-				     apBuffer, uNumBufs);
+				     apBuffer, uNumBufs, pr_ctxt);
 	cp_to_usr(args->ARGS_STRM_ALLOCATEBUFFER.apBuffer, apBuffer, status,
 		 uNumBufs);
 	if (apBuffer)
@@ -1400,19 +1502,15 @@ u32 STRMWRAP_AllocateBuffer(union Trappe
 /*
  * ======== STRMWRAP_Close ========
  */
-u32 STRMWRAP_Close(union Trapped_Args *args)
+u32 STRMWRAP_Close(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
-
-	retVal = STRM_Close(args->ARGS_STRM_CLOSE.hStream);
-
-	return retVal;
+	return STRM_Close(args->ARGS_STRM_CLOSE.hStream, pr_ctxt);
 }
 
 /*
  * ======== STRMWRAP_FreeBuffer ========
  */
-u32 STRMWRAP_FreeBuffer(union Trapped_Args *args)
+u32 STRMWRAP_FreeBuffer(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	u8 **apBuffer = NULL;
@@ -1427,7 +1525,7 @@ u32 STRMWRAP_FreeBuffer(union Trapped_Ar
 
 	if (DSP_SUCCEEDED(status)) {
 		status = STRM_FreeBuffer(args->ARGS_STRM_FREEBUFFER.hStream,
-					 apBuffer, uNumBufs);
+					 apBuffer, uNumBufs, pr_ctxt);
 	}
 	cp_to_usr(args->ARGS_STRM_FREEBUFFER.apBuffer, apBuffer, status,
 		 uNumBufs);
@@ -1440,7 +1538,7 @@ u32 STRMWRAP_FreeBuffer(union Trapped_Ar
 /*
  * ======== STRMWRAP_GetEventHandle ========
  */
-u32 STRMWRAP_GetEventHandle(union Trapped_Args *args)
+u32 STRMWRAP_GetEventHandle(union Trapped_Args *args, void *pr_ctxt)
 {
 	return DSP_ENOTIMPL;
 }
@@ -1448,7 +1546,7 @@ u32 STRMWRAP_GetEventHandle(union Trappe
 /*
  * ======== STRMWRAP_GetInfo ========
  */
-u32 STRMWRAP_GetInfo(union Trapped_Args *args)
+u32 STRMWRAP_GetInfo(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct STRM_INFO strmInfo;
@@ -1473,7 +1571,7 @@ u32 STRMWRAP_GetInfo(union Trapped_Args
 /*
  * ======== STRMWRAP_Idle ========
  */
-u32 STRMWRAP_Idle(union Trapped_Args *args)
+u32 STRMWRAP_Idle(union Trapped_Args *args, void *pr_ctxt)
 {
 	u32 retVal;
 
@@ -1486,24 +1584,25 @@ u32 STRMWRAP_Idle(union Trapped_Args *ar
 /*
  * ======== STRMWRAP_Issue ========
  */
-u32 STRMWRAP_Issue(union Trapped_Args *args)
+u32 STRMWRAP_Issue(union Trapped_Args *args, void *pr_ctxt)
 {
-	u32 retVal;
-
-	retVal = STRM_Issue(args->ARGS_STRM_ISSUE.hStream,
+	DSP_STATUS status = DSP_SOK;
+	/* No need of doing cp_fm_usr for the user buffer (pBuffer)
+	as this is done in Bridge internal function WMD_CHNL_AddIOReq
+	in chnl_sm.c */
+	status = STRM_Issue(args->ARGS_STRM_ISSUE.hStream,
 			args->ARGS_STRM_ISSUE.pBuffer,
 			args->ARGS_STRM_ISSUE.dwBytes,
 			args->ARGS_STRM_ISSUE.dwBufSize,
 			args->ARGS_STRM_ISSUE.dwArg);
 
-	/* This is a user space pointer */
-	return retVal;
+	return status;
 }
 
 /*
  * ======== STRMWRAP_Open ========
  */
-u32 STRMWRAP_Open(union Trapped_Args *args)
+u32 STRMWRAP_Open(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct STRM_ATTR attr;
@@ -1520,7 +1619,8 @@ u32 STRMWRAP_Open(union Trapped_Args *ar
 	}
 	status = STRM_Open(args->ARGS_STRM_OPEN.hNode,
 			  args->ARGS_STRM_OPEN.uDirection,
-			  args->ARGS_STRM_OPEN.uIndex, &attr, &pStrm);
+			  args->ARGS_STRM_OPEN.uIndex, &attr, &pStrm,
+			  pr_ctxt);
 	cp_to_usr(args->ARGS_STRM_OPEN.phStream, &pStrm, status, 1);
 	return status;
 }
@@ -1528,7 +1628,7 @@ u32 STRMWRAP_Open(union Trapped_Args *ar
 /*
  * ======== STRMWRAP_Reclaim ========
  */
-u32 STRMWRAP_Reclaim(union Trapped_Args *args)
+u32 STRMWRAP_Reclaim(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	u8 *pBufPtr;
@@ -1553,7 +1653,7 @@ u32 STRMWRAP_Reclaim(union Trapped_Args
 /*
  * ======== STRMWRAP_RegisterNotify ========
  */
-u32 STRMWRAP_RegisterNotify(union Trapped_Args *args)
+u32 STRMWRAP_RegisterNotify(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct DSP_NOTIFICATION notification;
@@ -1578,7 +1678,7 @@ u32 STRMWRAP_RegisterNotify(union Trappe
 /*
  * ======== STRMWRAP_Select ========
  */
-u32 STRMWRAP_Select(union Trapped_Args *args)
+u32 STRMWRAP_Select(union Trapped_Args *args, void *pr_ctxt)
 {
 	u32 mask;
 	struct STRM_OBJECT *aStrmTab[MAX_STREAMS];
@@ -1601,7 +1701,7 @@ u32 STRMWRAP_Select(union Trapped_Args *
 /*
  * ======== CMMWRAP_CallocBuf ========
  */
-u32 CMMWRAP_CallocBuf(union Trapped_Args *args)
+u32 CMMWRAP_CallocBuf(union Trapped_Args *args, void *pr_ctxt)
 {
 	/* This operation is done in kernel */
 	return DSP_ENOTIMPL;
@@ -1610,7 +1710,7 @@ u32 CMMWRAP_CallocBuf(union Trapped_Args
 /*
  * ======== CMMWRAP_FreeBuf ========
  */
-u32 CMMWRAP_FreeBuf(union Trapped_Args *args)
+u32 CMMWRAP_FreeBuf(union Trapped_Args *args, void *pr_ctxt)
 {
 	/* This operation is done in kernel */
 	return DSP_ENOTIMPL;
@@ -1619,7 +1719,7 @@ u32 CMMWRAP_FreeBuf(union Trapped_Args *
 /*
  * ======== CMMWRAP_GetHandle ========
  */
-u32 CMMWRAP_GetHandle(union Trapped_Args *args)
+u32 CMMWRAP_GetHandle(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct CMM_OBJECT *hCmmMgr;
@@ -1634,7 +1734,7 @@ u32 CMMWRAP_GetHandle(union Trapped_Args
 /*
  * ======== CMMWRAP_GetInfo ========
  */
-u32 CMMWRAP_GetInfo(union Trapped_Args *args)
+u32 CMMWRAP_GetInfo(union Trapped_Args *args, void *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct CMM_INFO cmmInfo;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/rmgr/drv.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/rmgr/drv.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/rmgr/drv.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/rmgr/drv.c	2012-12-16 13:13:01.564330147 +0100
@@ -198,77 +198,6 @@ DSP_STATUS DRV_GetProcCtxtList(struct PR
 	return status;
 }
 
-
-
-/* Get a particular process context based on process handle (phProcess) */
-DSP_STATUS DRV_GetProcContext(u32 phProcess,
-				struct DRV_OBJECT *hDrvObject,
-				HANDLE hPCtxt, DSP_HNODE hNode,
-				u32 pMapAddr)
-{
-	struct PROCESS_CONTEXT **pCtxt = (struct PROCESS_CONTEXT **)hPCtxt;
-	DSP_STATUS status = DSP_SOK;
-	struct PROCESS_CONTEXT *pCtxtList = NULL;
-	struct DRV_OBJECT *pDrvObject = (struct DRV_OBJECT *)hDrvObject;
-	struct NODE_RES_OBJECT *pTempNode2 = NULL;
-	struct NODE_RES_OBJECT *pTempNode = NULL;
-	struct DMM_RES_OBJECT *pTempDMM2 = NULL;
-	struct DMM_RES_OBJECT *pTempDMM = NULL;
-	s32 pCtxtFound = 0;
-
-	DBC_Assert(pDrvObject != NULL);
-	pCtxtList = pDrvObject->procCtxtList;
-	GT_0trace(curTrace, GT_ENTER, "2DRV_GetProcContext: 2");
-	while ((pCtxtList != NULL) && (pCtxtList->pid != phProcess)) {
-		pCtxtList = pCtxtList->next;
-		GT_0trace(curTrace, GT_ENTER, "2DRV_GetProcContext: 3");
-	}
-	if (pCtxtList == NULL) {
-		if (hNode != NULL) {
-			pCtxtList = pDrvObject->procCtxtList;
-			while ((pCtxtList != NULL) && (pCtxtFound == 0)) {
-				pTempNode = pCtxtList->pNodeList;
-				while ((pTempNode != NULL) &&
-				      (pTempNode->hNode != hNode)) {
-					pTempNode2 = pTempNode;
-					pTempNode = pTempNode->next;
-				}
-				if (pTempNode != NULL) {
-					pCtxtFound = 1;
-					status = DSP_SOK;
-				} else {
-					pCtxtList = pCtxtList->next;
-				}
-			}
-		} else if ((pMapAddr != 0) && (pCtxtFound == 0)) {
-			pCtxtList = pDrvObject->procCtxtList;
-			while ((pCtxtList != NULL) && (pCtxtFound == 0)) {
-				pTempDMM = pCtxtList->pDMMList;
-				while ((pTempDMM != NULL) &&
-				     (pTempDMM->ulDSPAddr != pMapAddr)) {
-					pTempDMM2 = pTempDMM;
-					pTempDMM = pTempDMM->next;
-				}
-				if (pTempDMM != NULL) {
-					pCtxtFound = 1;
-					status = DSP_SOK;
-				} else {
-					pCtxtList = pCtxtList->next;
-				}
-			}
-			if (pCtxtList == NULL)
-				status = DSP_ENOTFOUND;
-
-		}
-	} else{
-		status = DSP_SOK;
-	}
-	GT_0trace(curTrace, GT_ENTER, "2DRV_GetProcContext: 4");
-	*pCtxt = pCtxtList;
-	return status;
-}
-
-
 /* Add a new process context to process context list */
 DSP_STATUS DRV_InsertProcContext(struct DRV_OBJECT *hDrVObject, HANDLE hPCtxt)
 {
@@ -278,9 +207,19 @@ DSP_STATUS DRV_InsertProcContext(struct
 	struct DRV_OBJECT	     *hDRVObject;
 
 	GT_0trace(curTrace, GT_ENTER, "\n In DRV_InsertProcContext\n");
+
 	status = CFG_GetObject((u32 *)&hDRVObject, REG_DRV_OBJECT);
 	DBC_Assert(hDRVObject != NULL);
+
 	*pCtxt = MEM_Calloc(1 * sizeof(struct PROCESS_CONTEXT), MEM_PAGED);
+	if (!*pCtxt) {
+		pr_err("DSP: MEM_Calloc failed in DRV_InsertProcContext\n");
+		return DSP_EMEMORY;
+	}
+
+	spin_lock_init(&(*pCtxt)->proc_list_lock);
+	INIT_LIST_HEAD(&(*pCtxt)->processor_list);
+
 	GT_0trace(curTrace, GT_ENTER,
 		 "\n In DRV_InsertProcContext Calling "
 		 "DRV_GetProcCtxtList\n");
@@ -307,36 +246,40 @@ DSP_STATUS DRV_InsertProcContext(struct
 
 /* Delete a process context from process resource context list */
 DSP_STATUS DRV_RemoveProcContext(struct DRV_OBJECT *hDRVObject,
-				     HANDLE hPCtxt, HANDLE hProcess)
+		HANDLE pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
-	struct PROCESS_CONTEXT    *pCtxt2 = NULL;
-	struct PROCESS_CONTEXT    *pTmp = NULL;
-	struct PROCESS_CONTEXT    *pCtxtList = NULL;
+	struct PROCESS_CONTEXT *pr_ctxt_list = NULL;
+	struct PROCESS_CONTEXT *uninitialized_var(ptr_prev);
 
 	DBC_Assert(hDRVObject != NULL);
-	DRV_GetProcContext((u32)hProcess, hDRVObject, &pCtxt2, NULL, 0);
 
 	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveProcContext: 12");
-	DRV_GetProcCtxtList(&pCtxtList, hDRVObject);
+	DRV_GetProcCtxtList(&pr_ctxt_list, hDRVObject);
+
+	/* Special condition */
+	if (pr_ctxt_list == pr_ctxt) {
+		hDRVObject->procCtxtList = NULL;
+		goto func_cont;
+	}
+
 	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveProcContext: 13");
-	pTmp = pCtxtList;
-	while ((pCtxtList != NULL) && (pCtxtList != pCtxt2)) {
-		pTmp = pCtxtList;
-		pCtxtList = pCtxtList->next;
+	while (pr_ctxt_list && (pr_ctxt_list != pr_ctxt)) {
+		ptr_prev = pr_ctxt_list;
+		pr_ctxt_list = pr_ctxt_list->next;
 		GT_0trace(curTrace, GT_ENTER,
 			 "DRV_RemoveProcContext: 2");
 	}
+
 	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveProcContext: 3");
-	if (hDRVObject->procCtxtList == pCtxt2)
-		hDRVObject->procCtxtList = pCtxt2->next;
 
-	if (pCtxtList == NULL)
+	if (!pr_ctxt_list)
 		return DSP_ENOTFOUND;
-	else if (pTmp->next != NULL)
-		pTmp->next = pTmp->next->next;
+	else
+		ptr_prev->next = pr_ctxt_list->next;
 
-	MEM_Free(pCtxt2);
+func_cont:
+	MEM_Free(pr_ctxt);
 	GT_0trace(curTrace, GT_ENTER, "DRV_RemoveProcContext: 7");
 
 	return status;
@@ -453,16 +396,17 @@ static DSP_STATUS DRV_ProcFreeNodeRes(HA
 					GT_1trace(curTrace, GT_5CLASS,
 						 "Calling Node_Delete for Node:"
 						 " 0x%x\n", pNodeRes->hNode);
-					status = NODE_Delete(pNodeRes->hNode);
+					status = NODE_Delete(pNodeRes->hNode,
+							pCtxt);
 					GT_1trace(curTrace, GT_5CLASS,
 					"the status after the NodeDelete %x\n",
 					status);
 				} else if ((nState == NODE_ALLOCATED)
 					|| (nState == NODE_CREATED))
-					status = NODE_Delete(pNodeRes->hNode);
+					status = NODE_Delete(pNodeRes->hNode,
+							pCtxt);
 			}
 		}
-		pNodeRes->nodeAllocated = 0;
 	}
 	return status;
 }
@@ -572,7 +516,7 @@ DSP_STATUS  DRV_ProcFreeDMMRes(HANDLE hP
 		pDMMList = pDMMList->next;
 		if (pDMMRes->dmmAllocated) {
 			status = PROC_UnMap(pDMMRes->hProcessor,
-				 (void *)pDMMRes->ulDSPResAddr);
+				 (void *)pDMMRes->ulDSPResAddr, pCtxt);
 			status = PROC_UnReserveMemory(pDMMRes->hProcessor,
 				 (void *)pDMMRes->ulDSPResAddr);
 			pDMMRes->dmmAllocated = 0;
@@ -787,17 +731,18 @@ static DSP_STATUS  DRV_ProcFreeSTRMRes(H
 			apBuffer = MEM_Alloc((pSTRMRes->uNumBufs *
 					    sizeof(u8 *)), MEM_NONPAGED);
 			status = STRM_FreeBuffer(pSTRMRes->hStream, apBuffer,
-						pSTRMRes->uNumBufs);
+						pSTRMRes->uNumBufs, pCtxt);
 			MEM_Free(apBuffer);
 		}
-		status = STRM_Close(pSTRMRes->hStream);
+		status = STRM_Close(pSTRMRes->hStream, pCtxt);
 		if (DSP_FAILED(status)) {
 			if (status == DSP_EPENDING) {
 				status = STRM_Reclaim(pSTRMRes->hStream,
 						     &pBufPtr, &ulBytes,
 						     (u32 *)&ulBufSize, &dwArg);
 				if (DSP_SUCCEEDED(status))
-					status = STRM_Close(pSTRMRes->hStream);
+					status = STRM_Close(pSTRMRes->hStream,
+							pCtxt);
 
 			}
 		}
@@ -1004,6 +949,7 @@ static DSP_STATUS PrintProcessInformatio
 	struct DMM_RES_OBJECT *pDMMRes = NULL;
 	struct STRM_RES_OBJECT *pSTRMRes = NULL;
 	struct DSPHEAP_RES_OBJECT *pDSPHEAPRes = NULL;
+	struct PROC_OBJECT *proc_obj_ptr;
 	DSP_STATUS status = DSP_SOK;
 	u32 tempCount;
 	u32  procID;
@@ -1030,11 +976,11 @@ static DSP_STATUS PrintProcessInformatio
 			GT_0trace(curTrace, GT_4CLASS, "\nThe Process"
 					" is in DeAllocated state\n");
 		}
-		GT_1trace(curTrace, GT_4CLASS, "\nThe  hProcessor"
-				" handle is: 0X%x\n",
-				(u32)pCtxtList->hProcessor);
-		if (pCtxtList->hProcessor != NULL) {
-			PROC_GetProcessorId(pCtxtList->hProcessor, &procID);
+
+		spin_lock(&pCtxtList->proc_list_lock);
+		list_for_each_entry(proc_obj_ptr, &pCtxtList->processor_list,
+				proc_object) {
+			PROC_GetProcessorId(proc_obj_ptr, &procID);
 			if (procID == DSP_UNIT) {
 				GT_0trace(curTrace, GT_4CLASS,
 					"\nProcess connected to"
@@ -1048,6 +994,8 @@ static DSP_STATUS PrintProcessInformatio
 					"\n***ERROR:Invalid Processor Id***\n");
 			}
 		}
+		spin_unlock(&pCtxtList->proc_list_lock);
+
 		pNodeRes = pCtxtList->pNodeList;
 		tempCount = 1;
 		while (pNodeRes != NULL) {
@@ -1509,8 +1457,9 @@ DSP_STATUS DRV_RequestResources(u32 dwCo
 		pszdevNode = MEM_Calloc(sizeof(struct DRV_EXT), MEM_NONPAGED);
 		if (pszdevNode) {
 			LST_InitElem(&pszdevNode->link);
-                       strncpy((char *) pszdevNode->szString,
-				 (char *)dwContext, MAXREGPATHLENGTH);
+			strncpy(pszdevNode->szString,
+				 (char *)dwContext, MAXREGPATHLENGTH - 1);
+			pszdevNode->szString[MAXREGPATHLENGTH - 1] = '\0';
 			/* Update the Driver Object List */
 			*pDevNodeString = (u32)pszdevNode->szString;
 			LST_PutTail(pDRVObject->devNodeString,
@@ -1653,11 +1602,11 @@ static DSP_STATUS RequestBridgeResources
 			pResources->dwMemPhys[1] = 0;
 
 			if (pResources->dwPrmBase)
-				iounmap((void *)pResources->dwPrmBase);
+				iounmap(pResources->dwPrmBase);
 			if (pResources->dwCmBase)
-				iounmap((void *)pResources->dwCmBase);
+				iounmap(pResources->dwCmBase);
 			if (pResources->dwMboxBase)
-				iounmap((void *)pResources->dwMboxBase);
+				iounmap(pResources->dwMboxBase);
 			if (pResources->dwMemBase[0])
 				iounmap((void *)pResources->dwMemBase[0]);
 			if (pResources->dwMemBase[2])
@@ -1667,29 +1616,29 @@ static DSP_STATUS RequestBridgeResources
 			if (pResources->dwMemBase[4])
 				iounmap((void *)pResources->dwMemBase[4]);
 			if (pResources->dwWdTimerDspBase)
-				iounmap((void *)pResources->dwWdTimerDspBase);
+				iounmap(pResources->dwWdTimerDspBase);
 			if (pResources->dwDmmuBase)
-				iounmap((void *)pResources->dwDmmuBase);
+				iounmap(pResources->dwDmmuBase);
 			if (pResources->dwPerBase)
-				iounmap((void *)pResources->dwPerBase);
+				iounmap(pResources->dwPerBase);
                        if (pResources->dwPerPmBase)
                                iounmap((void *)pResources->dwPerPmBase);
                        if (pResources->dwCorePmBase)
                                iounmap((void *)pResources->dwCorePmBase);
 			if (pResources->dwSysCtrlBase) {
-				iounmap((void *)pResources->dwSysCtrlBase);
+				iounmap(pResources->dwSysCtrlBase);
 				/* don't set pResources->dwSysCtrlBase to null
 				 * as it is used in BOARD_Stop */
 			}
-			pResources->dwPrmBase = (u32) NULL;
-			pResources->dwCmBase = (u32) NULL;
-			pResources->dwMboxBase = (u32) NULL;
+			pResources->dwPrmBase = NULL;
+			pResources->dwCmBase = NULL;
+			pResources->dwMboxBase = NULL;
 			pResources->dwMemBase[0] = (u32) NULL;
 			pResources->dwMemBase[2] = (u32) NULL;
 			pResources->dwMemBase[3] = (u32) NULL;
 			pResources->dwMemBase[4] = (u32) NULL;
-			pResources->dwWdTimerDspBase = (u32) NULL;
-			pResources->dwDmmuBase = (u32) NULL;
+			pResources->dwWdTimerDspBase = NULL;
+			pResources->dwDmmuBase = NULL;
 
 			dwBuffSize = sizeof(struct CFG_HOSTRES);
 			status = REG_SetValue(NULL, (char *)driverExt->szString,
@@ -1708,13 +1657,13 @@ static DSP_STATUS RequestBridgeResources
 		pResources->wNumMemWindows = 2;
 		/* First window is for DSP internal memory */
 
-		pResources->dwPrmBase = (u32)ioremap(OMAP_IVA2_PRM_BASE,
+		pResources->dwPrmBase = ioremap(OMAP_IVA2_PRM_BASE,
 							OMAP_IVA2_PRM_SIZE);
-		pResources->dwCmBase = (u32)ioremap(OMAP_IVA2_CM_BASE,
+		pResources->dwCmBase = ioremap(OMAP_IVA2_CM_BASE,
 							OMAP_IVA2_CM_SIZE);
-		pResources->dwMboxBase = (u32)ioremap(OMAP_MBOX_BASE,
+		pResources->dwMboxBase = ioremap(OMAP_MBOX_BASE,
 							OMAP_MBOX_SIZE);
-		pResources->dwSysCtrlBase = (u32)ioremap(OMAP_SYSC_BASE,
+		pResources->dwSysCtrlBase = ioremap(OMAP_SYSC_BASE,
 							OMAP_SYSC_SIZE);
 		GT_1trace(curTrace, GT_2CLASS, "dwMemBase[0] 0x%x\n",
 			 pResources->dwMemBase[0]);
@@ -1736,7 +1685,6 @@ static DSP_STATUS RequestBridgeResources
 		/* Second window is for DSP external memory shared with MPU */
 		if (DSP_SUCCEEDED(status)) {
 			/* for Linux, these are hard-coded values */
-			pResources->dwBusType = 0;
 			pResources->bIRQRegisters = 0;
 			pResources->bIRQAttrib = 0;
 			pResources->dwOffsetForMonitor = 0;
@@ -1807,15 +1755,15 @@ static DSP_STATUS RequestBridgeResources
 							OMAP_DSP_MEM2_SIZE);
 		pResources->dwMemBase[4] = (u32)ioremap(OMAP_DSP_MEM3_BASE,
 							OMAP_DSP_MEM3_SIZE);
-		pResources->dwPerBase = (u32)ioremap(OMAP_PER_CM_BASE,
+		pResources->dwPerBase = ioremap(OMAP_PER_CM_BASE,
 							OMAP_PER_CM_SIZE);
                pResources->dwPerPmBase = (u32)ioremap(OMAP_PER_PRM_BASE,
                                                        OMAP_PER_PRM_SIZE);
                pResources->dwCorePmBase = (u32)ioremap(OMAP_CORE_PRM_BASE,
                                                        OMAP_CORE_PRM_SIZE);
-		pResources->dwDmmuBase = (u32)ioremap(OMAP_DMMU_BASE,
+		pResources->dwDmmuBase = ioremap(OMAP_DMMU_BASE,
 							OMAP_DMMU_SIZE);
-		pResources->dwWdTimerDspBase = 0;
+		pResources->dwWdTimerDspBase = NULL;
 
 		GT_1trace(curTrace, GT_2CLASS, "dwMemBase[0] 0x%x\n",
 						pResources->dwMemBase[0]);
@@ -1863,7 +1811,6 @@ static DSP_STATUS RequestBridgeResources
 		}
 		if (DSP_SUCCEEDED(status)) {
 			/* for Linux, these are hard-coded values */
-			pResources->dwBusType = 0;
 			pResources->bIRQRegisters = 0;
 			pResources->bIRQAttrib = 0;
 			pResources->dwOffsetForMonitor = 0;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/rmgr/drv_interface.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/rmgr/drv_interface.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/rmgr/drv_interface.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/rmgr/drv_interface.c	2012-12-16 13:13:01.564330147 +0100
@@ -134,6 +134,9 @@ static u32 phys_mempool_base;
 static u32 phys_mempool_size;
 static int tc_wordswapon;	/* Default value is always false */
 
+/* Minimum ACTIVE VDD1 OPP level for reliable DSP operation */
+unsigned short min_active_opp = 3;
+
 #ifdef CONFIG_PM
 struct omap34xx_bridge_suspend_data {
 	int suspended;
@@ -185,6 +188,9 @@ MODULE_PARM_DESC(phys_mempool_size,
 module_param(tc_wordswapon, int, 0);
 MODULE_PARM_DESC(tc_wordswapon, "TC Word Swap Option. default = 0");
 
+module_param(min_active_opp, ushort, S_IRUSR | S_IWUSR);
+MODULE_PARM_DESC(min_active_opp, "Minimum ACTIVE VDD1 OPP Level, default = 3");
+
 MODULE_AUTHOR("Texas Instruments");
 MODULE_LICENSE("GPL");
 
@@ -197,7 +203,7 @@ static struct GT_Mask driverTrace;
 static struct file_operations bridge_fops = {
 	.open		= bridge_open,
 	.release	= bridge_release,
-	.ioctl		= bridge_ioctl,
+	.unlocked_ioctl	= bridge_ioctl,
 	.mmap		= bridge_mmap,
 };
 
@@ -205,7 +211,7 @@ static struct file_operations bridge_fop
 static u32 timeOut = 1000;
 #ifdef CONFIG_BRIDGE_DVFS
 static struct clk *clk_handle;
-s32 dsp_max_opps = VDD1_OPP3;
+s32 dsp_max_opps = VDD1_OPP5;
 #endif
 
 /* Maximum Opps that can be requested by IVA*/
@@ -420,6 +426,13 @@ static int __devinit omap34xx_bridge_pro
 			GT_0trace(driverTrace, GT_7CLASS,
 			"clk_notifier_register FAIL for iva2_ck \n");
 		}
+
+		/*
+		 * When Smartreflex is ON, DSP requires at least OPP level 3
+		 * to operate reliably. So boost lower OPP levels to OPP3.
+		 */
+		if (pdata->dsp_set_min_opp)
+			(*pdata->dsp_set_min_opp)(min_active_opp);
 #endif
 		driverContext = DSP_Init(&initStatus);
 		if (DSP_FAILED(initStatus)) {
@@ -446,64 +459,50 @@ static int __devexit omap34xx_bridge_rem
 	HANDLE	     hDrvObject = NULL;
 	struct PROCESS_CONTEXT	*pTmp = NULL;
 	struct PROCESS_CONTEXT    *pCtxtclosed = NULL;
-	struct PROCESS_CONTEXT    *pCtxttraverse = NULL;
+	struct PROC_OBJECT *proc_obj_ptr, *temp;
 
 	GT_0trace(driverTrace, GT_ENTER, "-> driver_exit\n");
 
 	dsp_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	DRV_GetProcCtxtList(&pCtxtclosed, (struct DRV_OBJECT *)hDrvObject);
-	while (pCtxtclosed != NULL) {
-		DRV_RemoveAllResources(pCtxtclosed);
-		if (pCtxtclosed->hProcessor != NULL) {
-			DRV_GetProcCtxtList(&pCtxttraverse,
-					    (struct DRV_OBJECT *)hDrvObject);
-			if (pCtxttraverse->next == NULL) {
-				PROC_Detach(pCtxtclosed->hProcessor);
-				goto func_cont;
-			}
-			if ((pCtxtclosed->pid == pCtxttraverse->pid) &&
-			   (pCtxttraverse->next != NULL)) {
-				pCtxttraverse =	pCtxttraverse->next;
-			}
-			while ((pCtxttraverse != NULL) &&
-			      (pCtxtclosed->hProcessor
-			      != pCtxttraverse->hProcessor)) {
-				pCtxttraverse =	pCtxttraverse->next;
-				if ((pCtxttraverse != NULL) &&
-				   (pCtxtclosed->pid == pCtxttraverse->pid)) {
-					pCtxttraverse = pCtxttraverse->next;
-				}
-			}
-			if (pCtxttraverse == NULL)
-				PROC_Detach(pCtxtclosed->hProcessor);
-		}
-func_cont:
-		pTmp = pCtxtclosed->next;
-		DRV_RemoveProcContext((struct DRV_OBJECT *)hDrvObject,
-				     pCtxtclosed, (void *)pCtxtclosed->pid);
-		pCtxtclosed = pTmp;
-	}
+	if (DSP_FAILED(dsp_status))
+		goto func_cont;
 
-	/* unregister the clock notifier */
 #ifdef CONFIG_BRIDGE_DVFS
 	if (!clk_notifier_unregister(clk_handle, &iva_clk_notifier)) {
 		GT_0trace(driverTrace, GT_7CLASS,
 		"clk_notifier_unregister PASS for iva2_ck \n");
 	} else {
 		GT_0trace(driverTrace, GT_7CLASS,
-		"clk_notifier_unregister PASS for iva2_ck \n");
+		"clk_notifier_unregister FAILED for iva2_ck \n");
 	}
-
-	clk_put(clk_handle);
-	clk_handle = NULL;
 #endif /* #ifdef CONFIG_BRIDGE_DVFS */
 
+	DRV_GetProcCtxtList(&pCtxtclosed, (struct DRV_OBJECT *)hDrvObject);
+	while (pCtxtclosed != NULL) {
+		GT_1trace(driverTrace, GT_5CLASS, "***Cleanup of "
+			 "process***%d\n", pCtxtclosed->pid);
+		DRV_RemoveAllResources(pCtxtclosed);
+		list_for_each_entry_safe(proc_obj_ptr, temp,
+				&pCtxtclosed->processor_list, proc_object) {
+			PROC_Detach(proc_obj_ptr, pCtxtclosed);
+		}
+		pTmp = pCtxtclosed->next;
+		DRV_RemoveProcContext((struct DRV_OBJECT *)hDrvObject,
+				pCtxtclosed);
+		pCtxtclosed = pTmp;
+	}
+
 	if (driverContext) {
+		/* Put the DSP in reset state */
 		ret = DSP_Deinit(driverContext);
 		driverContext = 0;
-
 		DBC_Assert(ret == true);
 	}
+
+	clk_put(clk_handle);
+	clk_handle = NULL;
+
+func_cont:
 	SERVICES_Exit();
 	GT_exit();
 
@@ -574,119 +573,83 @@ static void __exit bridge_exit(void)
 	platform_driver_unregister(&bridge_driver);
 }
 
-/* This function is called when an application opens handle to the
- * bridge driver. */
-
+/*
+ * This function is called when an application opens handle to the
+ * bridge driver.
+ */
 static int bridge_open(struct inode *ip, struct file *filp)
 {
 	int status = 0;
-#ifndef RES_CLEANUP_DISABLE
-       u32     hProcess;
-	DSP_STATUS dsp_status = DSP_SOK;
-	HANDLE	     hDrvObject = NULL;
-	struct PROCESS_CONTEXT    *pPctxt = NULL;
-	struct PROCESS_CONTEXT	*next_node = NULL;
-	struct PROCESS_CONTEXT    *pCtxtclosed = NULL;
-	struct PROCESS_CONTEXT    *pCtxttraverse = NULL;
-	struct task_struct *tsk = NULL;
-	GT_0trace(driverTrace, GT_ENTER, "-> driver_open\n");
-	dsp_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
+	DSP_STATUS dsp_status;
+	HANDLE hDrvObject;
+	struct PROCESS_CONTEXT *pr_ctxt = NULL;
 
-	/* Checking weather task structure for all process existing
-	 * in the process context list If not removing those processes*/
-	if (DSP_FAILED(dsp_status))
-		goto func_cont;
+	GT_0trace(driverTrace, GT_ENTER, "-> bridge_open\n");
 
-	DRV_GetProcCtxtList(&pCtxtclosed, (struct DRV_OBJECT *)hDrvObject);
-	while (pCtxtclosed != NULL) {
-		tsk = find_task_by_vpid(pCtxtclosed->pid);
-		next_node = pCtxtclosed->next;
-
-		if ((tsk == NULL) || (tsk->exit_state == EXIT_ZOMBIE)) {
-
-			GT_1trace(driverTrace, GT_5CLASS,
-				 "***Task structure not existing for "
-				 "process***%d\n", pCtxtclosed->pid);
-			DRV_RemoveAllResources(pCtxtclosed);
-			if (pCtxtclosed->hProcessor != NULL) {
-				DRV_GetProcCtxtList(&pCtxttraverse,
-					    (struct DRV_OBJECT *)hDrvObject);
-				if (pCtxttraverse->next == NULL) {
-					PROC_Detach(pCtxtclosed->hProcessor);
-				} else {
-					if ((pCtxtclosed->pid ==
-					  pCtxttraverse->pid) &&
-					  (pCtxttraverse->next != NULL)) {
-						pCtxttraverse =
-							pCtxttraverse->next;
-					}
-					while ((pCtxttraverse != NULL) &&
-					     (pCtxtclosed->hProcessor
-					     != pCtxttraverse->hProcessor)) {
-						pCtxttraverse =
-							pCtxttraverse->next;
-						if ((pCtxttraverse != NULL) &&
-						  (pCtxtclosed->pid ==
-						  pCtxttraverse->pid)) {
-							pCtxttraverse =
-							   pCtxttraverse->next;
-						}
-					}
-					if (pCtxttraverse == NULL) {
-						PROC_Detach
-						     (pCtxtclosed->hProcessor);
-					}
-				}
-			}
-			DRV_RemoveProcContext((struct DRV_OBJECT *)hDrvObject,
-					     pCtxtclosed,
-					     (void *)pCtxtclosed->pid);
+	dsp_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
+	if (DSP_SUCCEEDED(dsp_status)) {
+		/*
+		 * Allocate a new process context and insert it into global
+		 * process context list.
+		 */
+		DRV_InsertProcContext(hDrvObject, &pr_ctxt);
+		if (pr_ctxt) {
+			DRV_ProcUpdatestate(pr_ctxt, PROC_RES_ALLOCATED);
+			DRV_ProcSetPID(pr_ctxt, current->tgid);
+		} else {
+			status = -ENOMEM;
 		}
-		pCtxtclosed = next_node;
+	} else {
+		status = -EIO;
 	}
-func_cont:
-	dsp_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	if (DSP_SUCCEEDED(dsp_status))
-		dsp_status = DRV_InsertProcContext(
-				(struct DRV_OBJECT *)hDrvObject, &pPctxt);
-
-	if (pPctxt != NULL) {
-			/* Return PID instead of process handle */
-			hProcess = current->pid;
 
-		DRV_ProcUpdatestate(pPctxt, PROC_RES_ALLOCATED);
-			DRV_ProcSetPID(pPctxt, hProcess);
-	}
-#endif
+	filp->private_data = pr_ctxt;
 
-	GT_0trace(driverTrace, GT_ENTER, " <- driver_open\n");
+	GT_0trace(driverTrace, GT_ENTER, "<- bridge_open\n");
 	return status;
 }
 
-/* This function is called when an application closes handle to the bridge
- * driver. */
+/*
+ * This function is called when an application closes handle to the bridge
+ * driver.
+ */
 static int bridge_release(struct inode *ip, struct file *filp)
 {
-	int status;
-       u32 pid;
-
-	GT_0trace(driverTrace, GT_ENTER, "-> driver_release\n");
-
-       /* Return PID instead of process handle */
-       pid = current->pid;
-
-       status = DSP_Close(pid);
-
+	int status = 0;
+	DSP_STATUS dsp_status;
+	HANDLE hDrvObject;
+	struct PROCESS_CONTEXT *pr_ctxt;
+	struct PROC_OBJECT *proc_obj_ptr, *temp;
 
-	(status == true) ? (status = 0) : (status = -1);
+	GT_0trace(driverTrace, GT_ENTER, "-> bridge_release\n");
 
-	GT_0trace(driverTrace, GT_ENTER, " <- driver_release\n");
+	if (!filp->private_data) {
+		status = -EIO;
+	} else {
+		pr_ctxt = filp->private_data;
+		dsp_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
+		if (DSP_SUCCEEDED(dsp_status)) {
+			flush_signals(current);
+			DRV_RemoveAllResources(pr_ctxt);
+			list_for_each_entry_safe(proc_obj_ptr, temp,
+					&pr_ctxt->processor_list,
+					proc_object) {
+				PROC_Detach(proc_obj_ptr, pr_ctxt);
+			}
+			DRV_RemoveProcContext((struct DRV_OBJECT *)hDrvObject,
+					pr_ctxt);
+		} else {
+			status = -EIO;
+		}
+		filp->private_data = NULL;
+	}
 
+	GT_0trace(driverTrace, GT_ENTER, "<- bridge_release\n");
 	return status;
 }
 
 /* This function provides IO interface to the bridge driver. */
-static int bridge_ioctl(struct inode *ip, struct file *filp, unsigned int code,
+static long bridge_ioctl(struct file *filp, unsigned int code,
 		unsigned long args)
 {
 	int status;
@@ -709,7 +672,8 @@ static int bridge_ioctl(struct inode *ip
 				sizeof(union Trapped_Args));
 
 	if (status >= 0) {
-		status = WCD_CallDevIOCtl(code, &pBufIn, &retval);
+		status = WCD_CallDevIOCtl(code, &pBufIn, &retval,
+				filp->private_data);
 
 		if (DSP_SUCCEEDED(status)) {
 			status = retval;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/rmgr/drv_interface.h kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/rmgr/drv_interface.h
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/rmgr/drv_interface.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/rmgr/drv_interface.h	2012-12-16 13:13:01.564330147 +0100
@@ -34,7 +34,7 @@ static int __init bridge_init(void);	/*
 static void __exit bridge_exit(void);	/* Opposite of initialize */
 static int bridge_open(struct inode *, struct file *);	/* Open */
 static int bridge_release(struct inode *, struct file *);	/* Release */
-static int bridge_ioctl(struct inode *, struct file *, unsigned int,
+static long bridge_ioctl(struct file *, unsigned int,
 			unsigned long);
 static int bridge_mmap(struct file *filp, struct vm_area_struct *vma);
 #endif				/* ifndef _DRV_INTERFACE_H_ */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/rmgr/dspdrv.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/rmgr/dspdrv.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/rmgr/dspdrv.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/rmgr/dspdrv.c	2012-12-16 13:13:01.564330147 +0100
@@ -248,29 +248,3 @@ bool DSP_Deinit(u32 deviceContext)
 
 	return retVal;
 }
-
-/*
- *  ======== DSP_Close ========
- *  	The Calling Process handle is passed to DEV_CleanupProcesState
- *      for cleaning up of any resources used by the application
- */
-bool DSP_Close(u32 dwOpenContext)
-{
-	bool retVal = false;
-
-	DBC_Require(dwOpenContext != 0);
-
-	GT_0trace(curTrace, GT_ENTER, "Entering DSP_Close\n");
-
-#ifdef RES_CLEANUP_DISABLE
-
-	if (DSP_SUCCEEDED(DEV_CleanupProcessState((HANDLE) dwOpenContext))) {
-		GT_0trace(curTrace, GT_1CLASS, "DSP_Close Succeeded \r\n");
-		retVal = true;
-	} else {
-		GT_0trace(curTrace, GT_7CLASS, "DSP_Close failed \r\n");
-	}
-#endif
-
-	return retVal;
-}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/rmgr/nldr.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/rmgr/nldr.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/rmgr/nldr.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/rmgr/nldr.c	2012-12-16 13:13:01.564330147 +0100
@@ -893,7 +893,7 @@ bool NLDR_Init(void)
 
 	if (cRefs == 0) {
 		DBC_Assert(!NLDR_debugMask.flags);
-		GT_create(&NLDR_debugMask, "DL");	/* "DL" for DLdr */
+		GT_create(&NLDR_debugMask, "NL");	/* "NL" for NLdr */
 
 		RMM_init();
 	}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/rmgr/node.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/rmgr/node.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/rmgr/node.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/rmgr/node.c	2012-12-16 13:13:01.568330147 +0100
@@ -322,7 +322,8 @@ static struct DSP_BUFFERATTR NODE_DFLTBU
 	0, 			/* uAlignment */
 };
 
-static void DeleteNode(struct NODE_OBJECT *hNode);
+static void DeleteNode(struct NODE_OBJECT *hNode,
+		struct PROCESS_CONTEXT *pr_ctxt);
 static void DeleteNodeMgr(struct NODE_MGR *hNodeMgr);
 static void FillStreamConnect(struct NODE_OBJECT *hNode1,
 			     struct NODE_OBJECT *hNode2, u32 uStream1,
@@ -389,7 +390,8 @@ DSP_STATUS NODE_Allocate(struct PROC_OBJ
 			IN CONST struct DSP_UUID *pNodeId,
 			OPTIONAL IN CONST struct DSP_CBDATA *pArgs,
 			OPTIONAL IN CONST struct DSP_NODEATTRIN *pAttrIn,
-			OUT struct NODE_OBJECT **phNode)
+			OUT struct NODE_OBJECT **phNode,
+			struct PROCESS_CONTEXT *pr_ctxt)
 {
 	struct NODE_MGR *hNodeMgr;
 	struct DEV_OBJECT *hDevObject;
@@ -418,11 +420,7 @@ DSP_STATUS NODE_Allocate(struct PROC_OBJ
 #endif
 
 #ifndef RES_CLEANUP_DISABLE
-	HANDLE	     hDrvObject;
 	HANDLE	     nodeRes;
-       u32                  hProcess;
-	struct PROCESS_CONTEXT   *pPctxt = NULL;
-	DSP_STATUS res_status = DSP_SOK;
 #endif
 
 	DBC_Require(cRefs > 0);
@@ -564,7 +562,7 @@ func_cont:
 	status = PROC_Map(hProcessor, (void *)pAttrIn->pGPPVirtAddr,
 			pNode->createArgs.asa.taskArgs.uHeapSize,
 			(void *)pNode->createArgs.asa.taskArgs.uDSPHeapResAddr,
-			(void **)&pMappedAddr, mapAttrs);
+			(void **)&pMappedAddr, mapAttrs, pr_ctxt);
 	if (DSP_FAILED(status)) {
 		GT_1trace(NODE_debugMask, GT_5CLASS,
 			 "NODE_Allocate: Failed to map memory"
@@ -731,7 +729,7 @@ func_cont2:
 				"0x%x\n", status);
 			}
 
-			ulGppMemBase = hostRes.dwMemBase[1];
+			ulGppMemBase = (u32)hostRes.dwMemBase[1];
 			offSet = pulValue - dynextBase;
 			ulStackSegAddr = ulGppMemBase + offSet;
 			ulStackSegVal = (u32)*((REG_UWORD32 *)
@@ -783,51 +781,15 @@ func_cont2:
 	} else {
 		/* Cleanup */
 		if (pNode)
-			DeleteNode(pNode);
+			DeleteNode(pNode, pr_ctxt);
 
 	}
 
 #ifndef RES_CLEANUP_DISABLE
 	if (DSP_SUCCEEDED(status)) {
-               /* Return PID instead of process handle */
-               hProcess = current->pid;
-
-		res_status = CFG_GetObject((u32 *)&hDrvObject,
-					  REG_DRV_OBJECT);
-		if (DSP_SUCCEEDED(res_status)) {
-                       DRV_GetProcContext(hProcess,
-					 (struct DRV_OBJECT *)hDrvObject,
-					 &pPctxt, *phNode, 0);
-			if (pPctxt == NULL) {
-				DRV_InsertProcContext(
-					(struct DRV_OBJECT *)hDrvObject,
-					&pPctxt);
-				if (pPctxt != NULL) {
-					DRV_ProcUpdatestate(pPctxt,
-							PROC_RES_ALLOCATED);
-                                       DRV_ProcSetPID(pPctxt, hProcess);
-					pPctxt->hProcessor =
-						 (DSP_HPROCESSOR)hProcessor;
-				}
-			}
-		}
-	}
-	if (DSP_SUCCEEDED(status)) {
-               /* Return PID instead of process handle */
-               hProcess = current->pid;
-		res_status = CFG_GetObject((u32 *)&hDrvObject,
-					REG_DRV_OBJECT);
-		if (DSP_SUCCEEDED(res_status)) {
-                       DRV_GetProcContext(hProcess,
-					 (struct DRV_OBJECT *)hDrvObject,
-					 &pPctxt, *phNode, 0);
-			if (pPctxt != NULL) {
-				DRV_InsertNodeResElement(*phNode, &nodeRes,
-							 pPctxt);
-				DRV_ProcNodeUpdateHeapStatus(nodeRes, true);
-				DRV_ProcNodeUpdateStatus(nodeRes, true);
-			}
-		}
+		DRV_InsertNodeResElement(*phNode, &nodeRes, pr_ctxt);
+		DRV_ProcNodeUpdateHeapStatus(nodeRes, true);
+		DRV_ProcNodeUpdateStatus(nodeRes, true);
 	}
 #endif
 	DBC_Ensure((DSP_FAILED(status) && (*phNode == NULL)) ||
@@ -864,8 +826,7 @@ DBAPI NODE_AllocMsgBuf(struct NODE_OBJEC
 
 	if (!MEM_IsValidHandle(pNode, NODE_SIGNATURE))
 		status = DSP_EHANDLE;
-
-	if (NODE_GetType(pNode) == NODE_DEVICE)
+	else if (NODE_GetType(pNode) == NODE_DEVICE)
 		status = DSP_ENODETYPE;
 
 	if (DSP_FAILED(status))
@@ -1337,6 +1298,10 @@ DSP_STATUS NODE_Create(struct NODE_OBJEC
 	DBC_Require(cRefs > 0);
 	GT_1trace(NODE_debugMask, GT_ENTER, "NODE_Create: hNode: 0x%x\n",
 		 hNode);
+	if (!MEM_IsValidHandle(pNode, NODE_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 	hProcessor = hNode->hProcessor;
 	status = PROC_GetState(hProcessor, &procStatus,
 					sizeof(struct DSP_PROCESSORSTATE));
@@ -1644,7 +1609,8 @@ DSP_STATUS NODE_CreateMgr(OUT struct NOD
  *      Loads the node's delete function if necessary. Free GPP side resources
  *      after node's delete function returns.
  */
-DSP_STATUS NODE_Delete(struct NODE_OBJECT *hNode)
+DSP_STATUS NODE_Delete(struct NODE_OBJECT *hNode,
+		struct PROCESS_CONTEXT *pr_ctxt)
 {
 	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
 	struct NODE_MGR *hNodeMgr;
@@ -1660,11 +1626,7 @@ DSP_STATUS NODE_Delete(struct NODE_OBJEC
 	struct WMD_DRV_INTERFACE *pIntfFxns;
 
 #ifndef RES_CLEANUP_DISABLE
-       u32                     hProcess;
 	HANDLE		nodeRes;
-	HANDLE		hDrvObject;
-	struct PROCESS_CONTEXT *pCtxt = NULL;
-	DSP_STATUS res_status = DSP_SOK;
 #endif
 	struct DSP_PROCESSORSTATE procStatus;
 	DBC_Require(cRefs > 0);
@@ -1790,27 +1752,20 @@ func_cont1:
 	 /*  Free host-side resources allocated by NODE_Create()
 	 *  DeleteNode() fails if SM buffers not freed by client!  */
 #ifndef RES_CLEANUP_DISABLE
-       /* Return PID instead of process handle */
-       hProcess = current->pid;
-	res_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	if (DSP_FAILED(res_status))
-		goto func_cont;
-	DRV_GetProcContext(0, (struct DRV_OBJECT *)hDrvObject,
-						&pCtxt, hNode, 0);
-	if (pCtxt == NULL)
+	if (!pr_ctxt)
 		goto func_cont;
-	if (DRV_GetNodeResElement(hNode, &nodeRes, pCtxt) != DSP_ENOTFOUND) {
+	if (DRV_GetNodeResElement(hNode, &nodeRes, pr_ctxt) != DSP_ENOTFOUND) {
 		GT_0trace(NODE_debugMask, GT_5CLASS, "\nNODE_Delete12:\n");
 		DRV_ProcNodeUpdateStatus(nodeRes, false);
 	}
 #endif
 func_cont:
 	GT_0trace(NODE_debugMask, GT_ENTER, "\nNODE_Delete13:\n ");
-	DeleteNode(hNode);
+	DeleteNode(hNode, pr_ctxt);
 #ifndef RES_CLEANUP_DISABLE
 	GT_0trace(NODE_debugMask, GT_5CLASS, "\nNODE_Delete2:\n ");
-	if (pCtxt != NULL)
-		DRV_RemoveNodeResElement(nodeRes, (HANDLE)pCtxt);
+	if (pr_ctxt)
+		DRV_RemoveNodeResElement(nodeRes, pr_ctxt);
 #endif
 	GT_0trace(NODE_debugMask, GT_ENTER, "\nNODE_Delete3:\n ");
 	/* Exit critical section */
@@ -1921,9 +1876,10 @@ DSP_STATUS NODE_FreeMsgBuf(struct NODE_O
 	DBC_Require(pNode->hXlator != NULL);
 	GT_3trace(NODE_debugMask, GT_ENTER, "NODE_FreeMsgBuf: hNode: 0x%x\t"
 		 "pBuffer: 0x%x\tpAttr: 0x%x\n", hNode, pBuffer, pAttr);
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE))
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
-
+		goto func_end;
+	}
 	status = PROC_GetProcessorId(pNode->hProcessor, &procId);
 	if (procId == DSP_UNIT) {
 		if (DSP_SUCCEEDED(status)) {
@@ -1946,6 +1902,7 @@ DSP_STATUS NODE_FreeMsgBuf(struct NODE_O
 	} else {
 		DBC_Assert(NULL);	/* BUG */
 	}
+func_end:
 	return status;
 }
 
@@ -2063,6 +2020,10 @@ DSP_STATUS NODE_GetMessage(struct NODE_O
 	GT_3trace(NODE_debugMask, GT_ENTER,
 		 "NODE_GetMessage: hNode: 0x%x\tpMsg: "
 		 "0x%x\tuTimeout: 0x%x\n", hNode, pMsg, uTimeout);
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 	hProcessor = hNode->hProcessor;
 	status = PROC_GetState(hProcessor, &procStatus,
 					sizeof(struct DSP_PROCESSORSTATE));
@@ -2076,10 +2037,6 @@ DSP_STATUS NODE_GetMessage(struct NODE_O
 		status = DSP_EFAIL;
 		goto func_end;
 	}
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-		status = DSP_EHANDLE;
-		goto func_end;
-	}
 	hNodeMgr = hNode->hNodeMgr;
 	nodeType = NODE_GetType(hNode);
 	if (nodeType != NODE_MESSAGE && nodeType != NODE_TASK &&
@@ -2295,12 +2252,14 @@ DSP_STATUS NODE_Pause(struct NODE_OBJECT
 
 	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
 		status = DSP_EHANDLE;
+		goto func_end;
 	} else {
 		nodeType = NODE_GetType(hNode);
 		if (nodeType != NODE_TASK && nodeType != NODE_DAISSOCKET)
 			status = DSP_ENODETYPE;
-
 	}
+	if (DSP_FAILED(status))
+		goto func_end;
 
 	status = PROC_GetProcessorId(pNode->hProcessor, &procId);
 
@@ -2387,6 +2346,10 @@ DSP_STATUS NODE_PutMessage(struct NODE_O
 	GT_3trace(NODE_debugMask, GT_ENTER,
 		 "NODE_PutMessage: hNode: 0x%x\tpMsg: "
 		 "0x%x\tuTimeout: 0x%x\n", hNode, pMsg, uTimeout);
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 	hProcessor = hNode->hProcessor;
 	status = PROC_GetState(hProcessor, &procStatus,
 					sizeof(struct DSP_PROCESSORSTATE));
@@ -2400,15 +2363,12 @@ DSP_STATUS NODE_PutMessage(struct NODE_O
 		status = DSP_EFAIL;
 		goto func_end;
 	}
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE))
-		status = DSP_EHANDLE;
-	else {
-		hNodeMgr = hNode->hNodeMgr;
-		nodeType = NODE_GetType(hNode);
-		if (nodeType != NODE_MESSAGE && nodeType != NODE_TASK &&
-		    nodeType != NODE_DAISSOCKET)
-			status = DSP_ENODETYPE;
-	}
+	hNodeMgr = hNode->hNodeMgr;
+	nodeType = NODE_GetType(hNode);
+	if (nodeType != NODE_MESSAGE && nodeType != NODE_TASK &&
+	    nodeType != NODE_DAISSOCKET)
+		status = DSP_ENODETYPE;
+
 	if (DSP_SUCCEEDED(status)) {
 		/*  Check node state. Can't send messages to a node after
 		 *  we've sent the RMS_EXIT command. There is still the
@@ -2545,6 +2505,10 @@ DSP_STATUS NODE_Run(struct NODE_OBJECT *
 
 	DBC_Require(cRefs > 0);
 	GT_1trace(NODE_debugMask, GT_ENTER, "NODE_Run: hNode: 0x%x\n", hNode);
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 	hProcessor = hNode->hProcessor;
 	status = PROC_GetState(hProcessor, &procStatus,
 					sizeof(struct DSP_PROCESSORSTATE));
@@ -2557,13 +2521,9 @@ DSP_STATUS NODE_Run(struct NODE_OBJECT *
 		status = DSP_EFAIL;
 		goto func_end;
 	}
-	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
-		status = DSP_EHANDLE;
-	} else {
-		nodeType = NODE_GetType(hNode);
-		if (nodeType == NODE_DEVICE)
-			status = DSP_ENODETYPE;
-	}
+	nodeType = NODE_GetType(hNode);
+	if (nodeType == NODE_DEVICE)
+		status = DSP_ENODETYPE;
 	if (DSP_FAILED(status))
 		goto func_end;
 
@@ -2666,7 +2626,10 @@ DSP_STATUS NODE_Terminate(struct NODE_OB
 
 	GT_1trace(NODE_debugMask, GT_ENTER,
 		 "NODE_Terminate: hNode: 0x%x\n", hNode);
-
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
 	if (pNode->hProcessor == NULL) {
 		GT_1trace(NODE_debugMask, GT_4CLASS,
 		"NODE_Terminate: pNode->hProcessor = 0x%x\n",
@@ -2677,15 +2640,10 @@ DSP_STATUS NODE_Terminate(struct NODE_OB
 
 	if (DSP_SUCCEEDED(status)) {
 		hNodeMgr = hNode->hNodeMgr;
-
-		if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE))
-			status = DSP_EHANDLE;
-		else {
-			nodeType = NODE_GetType(hNode);
-			if (nodeType != NODE_TASK && nodeType !=
+		nodeType = NODE_GetType(hNode);
+		if (nodeType != NODE_TASK && nodeType !=
 			   NODE_DAISSOCKET)
 				status = DSP_ENODETYPE;
-		}
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Check node state */
@@ -2803,7 +2761,8 @@ func_end:
  *  Purpose:
  *      Free GPP resources allocated in NODE_Allocate() or NODE_Connect().
  */
-static void DeleteNode(struct NODE_OBJECT *hNode)
+static void DeleteNode(struct NODE_OBJECT *hNode,
+		struct PROCESS_CONTEXT *pr_ctxt)
 {
 	struct NODE_MGR *hNodeMgr;
 	struct CMM_XLATOROBJECT *hXlator;
@@ -2882,7 +2841,8 @@ static void DeleteNode(struct NODE_OBJEC
 		}
 		if (taskArgs.uDSPHeapResAddr) {
 			status = PROC_UnMap(hNode->hProcessor,
-					   (void *)taskArgs.uDSPHeapAddr);
+					(void *)taskArgs.uDSPHeapAddr,
+					pr_ctxt);
 			if (DSP_SUCCEEDED(status)) {
 				GT_0trace(NODE_debugMask, GT_5CLASS,
 					 "DSPProcessor_UnMap succeeded.\n");
@@ -2981,7 +2941,7 @@ static void DeleteNodeMgr(struct NODE_MG
 			while ((hNode =
 				(struct NODE_OBJECT *)LST_GetHead(hNodeMgr->
 				nodeList)))
-					DeleteNode(hNode);
+					DeleteNode(hNode, NULL);
 
 			DBC_Assert(LST_IsEmpty(hNodeMgr->nodeList));
 			LST_Delete(hNodeMgr->nodeList);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/rmgr/proc.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/rmgr/proc.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/rmgr/proc.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/rmgr/proc.c	2012-12-16 13:13:01.568330147 +0100
@@ -121,7 +121,7 @@
 #include <dspbridge/sync.h>
 /*  ----------------------------------- Mini Driver */
 #include <dspbridge/wmd.h>
-
+#include <dspbridge/wmddeh.h>
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/cod.h>
 #include <dspbridge/dev.h>
@@ -160,27 +160,6 @@
 #define EXTEND	      "_EXT_END"	/* Extmem end addr in DSP binary */
 
 extern char *iva_img;
-/* The PROC_OBJECT structure.   */
-struct PROC_OBJECT {
-	struct LST_ELEM link;		/* Link to next PROC_OBJECT */
-	u32 dwSignature;	/* Used for object validation */
-	struct DEV_OBJECT *hDevObject;	/* Device this PROC represents */
-	u32 hProcess;   /* Process owning this Processor */
-	struct MGR_OBJECT *hMgrObject;	/* Manager Object Handle */
-	u32 uAttachCount;	/* Processor attach count */
-	u32 uProcessor;	/* Processor number */
-	u32 uTimeout;		/* Time out count */
-	enum DSP_PROCSTATE sState;	/* Processor state */
-	u32 ulUnit;		/* DDSP unit number */
-	bool bIsAlreadyAttached;	/*
-					 * True if the Device below has
-					 * GPP Client attached
-					 */
-	struct NTFY_OBJECT *hNtfy;	/* Manages  notifications */
-	struct WMD_DEV_CONTEXT *hWmdContext;	/* WMD Context Handle */
-	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
-	char *g_pszLastCoff;
-} ;
 
 /*  ----------------------------------- Globals */
 #if GT_TRACE
@@ -197,6 +176,46 @@ static s32 GetEnvpCount(char **envp);
 static char **PrependEnvp(char **newEnvp, char **envp, s32 cEnvp, s32 cNewEnvp,
 			 char *szVar);
 
+/*
+ *  ======== PROC_CleanupAllResources =====
+ *  Purpose:
+ *      Funtion to clean the process resources.
+ *      This function is intended to be called when the
+ *       processor is in error state
+ */
+DSP_STATUS PROC_CleanupAllResources(void)
+{
+	DSP_STATUS dsp_status = DSP_SOK;
+	HANDLE hDrvObject = NULL;
+	struct PROCESS_CONTEXT *pCtxtclosed = NULL;
+	struct PROC_OBJECT *proc_obj_ptr, *temp;
+
+	GT_0trace(PROC_DebugMask, GT_ENTER, "PROC_CleanupAllResources\n");
+
+	dsp_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
+	if (DSP_FAILED(dsp_status))
+		goto func_end;
+
+	DRV_GetProcCtxtList(&pCtxtclosed, (struct DRV_OBJECT *)hDrvObject);
+
+	while (pCtxtclosed != NULL) {
+		if (current->tgid != pCtxtclosed->pid) {
+			GT_1trace(PROC_DebugMask, GT_5CLASS,
+				 "***Cleanup of "
+				 "process***%d\n", pCtxtclosed->pid);
+			list_for_each_entry_safe(proc_obj_ptr, temp,
+					&pCtxtclosed->processor_list,
+					proc_object) {
+				PROC_Detach(proc_obj_ptr, pCtxtclosed);
+			}
+		}
+		pCtxtclosed = pCtxtclosed->next;
+	}
+
+	WMD_DEH_ReleaseDummyMem();
+func_end:
+	return dsp_status;
+}
 
 /*
  *  ======== PROC_Attach ========
@@ -206,7 +225,7 @@ static char **PrependEnvp(char **newEnvp
  */
 DSP_STATUS
 PROC_Attach(u32 uProcessor, OPTIONAL CONST struct DSP_PROCESSORATTRIN *pAttrIn,
-       OUT DSP_HPROCESSOR *phProcessor)
+       OUT DSP_HPROCESSOR *phProcessor, struct PROCESS_CONTEXT *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct DEV_OBJECT *hDevObject;
@@ -215,19 +234,13 @@ PROC_Attach(u32 uProcessor, OPTIONAL CON
 	struct DRV_OBJECT *hDrvObject = NULL;
 	u32 devType;
 
-#ifndef RES_CLEANUP_DISABLE
-	HANDLE	     hDRVObject;
-       u32                  hProcess;
-	DSP_STATUS res_status = DSP_SOK;
-	struct PROCESS_CONTEXT   *pPctxt = NULL;
-#endif
-
 	DBC_Require(cRefs > 0);
 	DBC_Require(phProcessor != NULL);
 
 	GT_3trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Attach, args:\n\t"
 		 "uProcessor:  0x%x\n\tpAttrIn:  0x%x\n\tphProcessor:"
 		 "0x%x\n", uProcessor, pAttrIn, phProcessor);
+
 	/* Get the Driver and Manager Object Handles */
 	status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
 	if (DSP_SUCCEEDED(status)) {
@@ -276,9 +289,10 @@ PROC_Attach(u32 uProcessor, OPTIONAL CON
 	pProcObject->hDevObject = hDevObject;
 	pProcObject->hMgrObject = hMgrObject;
 	pProcObject->uProcessor = devType;
-	/* Get Caller Process and store it */
-       /* Return PID instead of process handle */
-       pProcObject->hProcess = current->pid;
+	/* Store TGID of Caller Process */
+	pProcObject->hProcess = current->tgid;
+
+	INIT_LIST_HEAD(&pProcObject->proc_object);
 
 	if (pAttrIn)
 		pProcObject->uTimeout = pAttrIn->uTimeout;
@@ -349,41 +363,12 @@ PROC_Attach(u32 uProcessor, OPTIONAL CON
 			 "storage for notification \n");
 		MEM_FreeObject(pProcObject);
 	}
-func_end:
 #ifndef RES_CLEANUP_DISABLE
-	if (DSP_FAILED(status))
-		goto func_cont;
-
-       /* Return PID instead of process handle */
-       hProcess = current->pid;
-
-	res_status = CFG_GetObject((u32 *)&hDRVObject, REG_DRV_OBJECT);
-	if (DSP_FAILED(res_status))
-		goto func_cont;
-
-       DRV_GetProcContext(hProcess, (struct DRV_OBJECT *)hDRVObject,
-			 &pPctxt, NULL, 0);
-	if (pPctxt == NULL) {
-		DRV_InsertProcContext((struct DRV_OBJECT *)hDRVObject, &pPctxt);
-		if (pPctxt != NULL) {
-			DRV_ProcUpdatestate(pPctxt, PROC_RES_ALLOCATED);
-                       DRV_ProcSetPID(pPctxt, hProcess);
-		}
-	}
-func_cont:
-       /* Return PID instead of process handle */
-       hProcess = current->pid;
-
-	res_status = CFG_GetObject((u32 *)&hDRVObject, REG_DRV_OBJECT);
-	if (DSP_SUCCEEDED(res_status)) {
-                       DRV_GetProcContext(hProcess,
-				 (struct DRV_OBJECT *)hDRVObject, &pPctxt,
-				 NULL, 0);
-		if (pPctxt != NULL)
-			pPctxt->hProcessor = (DSP_HPROCESSOR)*phProcessor;
-
-	}
+	spin_lock(&pr_ctxt->proc_list_lock);
+	list_add(&pProcObject->proc_object, &pr_ctxt->processor_list);
+	spin_unlock(&pr_ctxt->proc_list_lock);
 #endif
+func_end:
 	DBC_Ensure((status == DSP_EFAIL && *phProcessor == NULL) ||
 		  (DSP_SUCCEEDED(status) &&
 		  MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) ||
@@ -604,21 +589,23 @@ DSP_STATUS PROC_Ctrl(DSP_HPROCESSOR hPro
  *      Destroys the  Processor Object. Removes the notification from the Dev
  *      List.
  */
-DSP_STATUS PROC_Detach(DSP_HPROCESSOR hProcessor)
+DSP_STATUS PROC_Detach(DSP_HPROCESSOR hProcessor,
+		struct PROCESS_CONTEXT *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
-#ifndef RES_CLEANUP_DISABLE
-	HANDLE hDRVObject;
-       u32 hProcess;
-	DSP_STATUS res_status = DSP_SOK;
-	struct PROCESS_CONTEXT   *pPctxt = NULL;
-#endif
 	DBC_Require(cRefs > 0);
 	GT_1trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Detach, args:\n\t"
 		 "hProcessor:  0x%x\n", hProcessor);
 
 	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+#ifndef RES_CLEANUP_DISABLE
+		if (pr_ctxt) {
+			spin_lock(&pr_ctxt->proc_list_lock);
+			list_del(&pProcObject->proc_object);
+			spin_unlock(&pr_ctxt->proc_list_lock);
+		}
+#endif
 		/* Notify the Client */
 		NTFY_Notify(pProcObject->hNtfy, DSP_PROCESSORDETACH);
 		/* Remove the notification memory */
@@ -629,23 +616,6 @@ DSP_STATUS PROC_Detach(DSP_HPROCESSOR hP
 			MEM_Free(pProcObject->g_pszLastCoff);
 			pProcObject->g_pszLastCoff = NULL;
 		}
-
-#ifndef RES_CLEANUP_DISABLE
-		/* Return PID instead of process handle */
-		hProcess = current->pid;
-
-		res_status = CFG_GetObject((u32 *)&hDRVObject, REG_DRV_OBJECT);
-		if (DSP_SUCCEEDED(res_status)) {
-			DRV_GetProcContext(hProcess,
-				(struct DRV_OBJECT *)hDRVObject, &pPctxt,
-					 NULL, 0);
-			if (pPctxt != NULL) {
-				DRV_ProcFreeDMMRes(pPctxt);
-				pPctxt->hProcessor = NULL;
-			}
-		}
-#endif
-
 		/* Remove the Proc from the DEV List */
 		(void)DEV_RemoveProcObject(pProcObject->hDevObject,
 			(u32)pProcObject);
@@ -709,33 +679,95 @@ DSP_STATUS PROC_EnumNodes(DSP_HPROCESSOR
 	return status;
 }
 
-/*
- *  ======== PROC_FlushMemory ========
- *  Purpose:
- *     Flush cache
- */
-DSP_STATUS PROC_FlushMemory(DSP_HPROCESSOR hProcessor, void *pMpuAddr,
-			   u32 ulSize, u32 ulFlags)
+/* Check if the given area blongs to process virtul memory address space */
+static int memory_check_vma(unsigned long start, u32 len)
+{
+	int err = 0;
+	unsigned long end;
+	struct vm_area_struct *vma;
+
+	end = start + len;
+	if (end <= start)
+		return -EINVAL;
+
+	down_read(&current->mm->mmap_sem);
+
+	while ((vma = find_vma(current->mm, start)) != NULL) {
+
+		if (vma->vm_start > start) {
+			err = -EINVAL;
+			break;
+		}
+
+		if (end <= vma->vm_end)
+			break;
+
+		start = vma->vm_end;
+	}
+
+	if (!vma)
+		err = -EINVAL;
+
+	up_read(&current->mm->mmap_sem);
+
+	return err;
+}
+
+static DSP_STATUS proc_memory_sync(DSP_HPROCESSOR hProcessor, void *pMpuAddr,
+				   u32 ulSize, u32 ulFlags,
+				   enum DSP_FLUSHTYPE FlushMemType)
 {
 	/* Keep STATUS here for future additions to this function */
 	DSP_STATUS status = DSP_SOK;
-	enum DSP_FLUSHTYPE FlushMemType = PROC_WRITEBACK_INVALIDATE_MEM;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+
 	DBC_Require(cRefs > 0);
+	GT_5trace(PROC_DebugMask, GT_ENTER,
+		  "Entered %s, args:\n\t"
+		  "hProcessor: 0x%x pMpuAddr: 0x%x ulSize 0x%x, ulFlags 0x%x\n",
+		  __func__, hProcessor, pMpuAddr, ulSize, ulFlags);
+
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		GT_1trace(PROC_DebugMask, GT_7CLASS,
+			  "%s: InValid Processor Handle\n", __func__);
+		status = DSP_EHANDLE;
+		goto err_out;
+	}
+
+	if (memory_check_vma((u32)pMpuAddr, ulSize)) {
+		GT_3trace(PROC_DebugMask, GT_7CLASS,
+			  "%s: InValid address parameters\n",
+			  __func__, pMpuAddr, ulSize);
+		status = DSP_EHANDLE;
+		goto err_out;
+	}
 
-	GT_4trace(PROC_DebugMask, GT_ENTER,
-		 "Entered PROC_FlushMemory, args:\n\t"
-		 "hProcessor: 0x%x pMpuAddr: 0x%x ulSize 0x%x, ulFlags 0x%x\n",
-		 hProcessor, pMpuAddr, ulSize, ulFlags);
-	/* Critical section */
 	(void)SYNC_EnterCS(hProcLock);
 	MEM_FlushCache(pMpuAddr, ulSize, FlushMemType);
 	(void)SYNC_LeaveCS(hProcLock);
 
-	GT_1trace(PROC_DebugMask, GT_ENTER, "Leaving PROC_FlushMemory [0x%x]",
-		 status);
+err_out:
+	GT_2trace(PROC_DebugMask, GT_ENTER,
+		  "Leaving %s [0x%x]", __func__, status);
+
 	return status;
 }
 
+/*
+ *  ======== PROC_FlushMemory ========
+ *  Purpose:
+ *     Flush cache
+ */
+DSP_STATUS PROC_FlushMemory(DSP_HPROCESSOR hProcessor, void *pMpuAddr,
+			    u32 ulSize, u32 ulFlags)
+{
+	enum DSP_FLUSHTYPE mtype = PROC_WRITEBACK_INVALIDATE_MEM;
+
+	if (ulFlags & 1)
+		mtype = PROC_WRITEBACK_MEM;
+
+	return proc_memory_sync(hProcessor, pMpuAddr, ulSize, ulFlags, mtype);
+}
 
 /*
  *  ======== PROC_InvalidateMemory ========
@@ -743,23 +775,11 @@ DSP_STATUS PROC_FlushMemory(DSP_HPROCESS
  *     Invalidates the memory specified
  */
 DSP_STATUS PROC_InvalidateMemory(DSP_HPROCESSOR hProcessor, void *pMpuAddr,
-				u32 ulSize)
+				 u32 ulSize)
 {
-	/* Keep STATUS here for future additions to this function */
-	DSP_STATUS status = DSP_SOK;
-	enum DSP_FLUSHTYPE FlushMemType = PROC_INVALIDATE_MEM;
-	DBC_Require(cRefs > 0);
-	GT_3trace(PROC_DebugMask, GT_ENTER,
-		 "Entered PROC_InvalidateMemory, args:\n\t"
-		 "hProcessor: 0x%x pMpuAddr: 0x%x ulSize 0x%x\n", hProcessor,
-		 pMpuAddr, ulSize);
-	(void)SYNC_EnterCS(hProcLock);
-	MEM_FlushCache(pMpuAddr, ulSize, FlushMemType);
-	(void)SYNC_LeaveCS(hProcLock);
+	enum DSP_FLUSHTYPE mtype = PROC_INVALIDATE_MEM;
 
-	GT_1trace(PROC_DebugMask, GT_ENTER,
-		 "Leaving PROC_InvalidateMemory [0x%x]", status);
-	return status;
+	return proc_memory_sync(hProcessor, pMpuAddr, ulSize, 0, mtype);
 }
 
 /*
@@ -874,6 +894,7 @@ DSP_STATUS PROC_GetDevObject(DSP_HPROCES
 		status = DSP_SOK;
 	} else {
 		*phDevObject = NULL;
+		status = DSP_EHANDLE;
 	}
 
 	DBC_Ensure((DSP_SUCCEEDED(status) && *phDevObject != NULL) ||
@@ -1061,11 +1082,9 @@ DSP_STATUS PROC_Load(DSP_HPROCESSOR hPro
 		goto func_end;
 	}
 	if (pProcObject->bIsAlreadyAttached) {
-		status = DSP_EATTACHED;
-		GT_1trace(PROC_DebugMask, GT_7CLASS,
-			 "PROC_Load  Abort becuase a GPP "
-			 "Client is already attached status 0x%x \n", status);
-		goto func_end;
+		GT_0trace(PROC_DebugMask, GT_7CLASS,
+			 "PROC_Load GPP "
+			 "Client is already attached status  \n");
 	}
 	if (DSP_FAILED(DEV_GetCodMgr(pProcObject->hDevObject, &hCodMgr))) {
 		status = DSP_EFAIL;
@@ -1340,7 +1359,8 @@ func_end:
  *      Maps a MPU buffer to DSP address space.
  */
 DSP_STATUS PROC_Map(DSP_HPROCESSOR hProcessor, void *pMpuAddr, u32 ulSize,
-		   void *pReqAddr, void **ppMapAddr, u32 ulMapAttr)
+		   void *pReqAddr, void **ppMapAddr, u32 ulMapAttr,
+		   struct PROCESS_CONTEXT *pr_ctxt)
 {
 	u32 vaAlign;
 	u32 paAlign;
@@ -1350,11 +1370,7 @@ DSP_STATUS PROC_Map(DSP_HPROCESSOR hProc
 	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
 
 #ifndef RES_CLEANUP_DISABLE
-       u32               hProcess;
-       HANDLE        pCtxt = NULL;
-       HANDLE        hDrvObject;
        HANDLE        dmmRes;
-       DSP_STATUS res_status = DSP_SOK;
 #endif
 
 	GT_6trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Map, args:\n\t"
@@ -1370,6 +1386,12 @@ DSP_STATUS PROC_Map(DSP_HPROCESSOR hProc
 	GT_3trace(PROC_DebugMask, GT_ENTER, "PROC_Map: vaAlign %x, paAlign %x, "
 		 "sizeAlign %x\n", vaAlign, paAlign, sizeAlign);
 
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_Map: "
+			 "InValid Processor Handle \n");
+		goto func_end;
+	}
 	/* Critical section */
 	(void)SYNC_EnterCS(hProcLock);
 	status = DMM_GetHandle(pProcObject, &hDmmMgr);
@@ -1398,24 +1420,12 @@ DSP_STATUS PROC_Map(DSP_HPROCESSOR hProc
 
 #ifndef RES_CLEANUP_DISABLE
 	if (DSP_SUCCEEDED(status)) {
-		/* Update the node and stream resource status */
-               /* Return PID instead of process handle */
-               hProcess = current->pid;
-
-		res_status = CFG_GetObject((u32 *)&hDrvObject,
-					  REG_DRV_OBJECT);
-		if (DSP_SUCCEEDED(res_status)) {
-                       if (DRV_GetProcContext(hProcess,
-                               (struct DRV_OBJECT *)hDrvObject, &pCtxt, NULL,
-                                       (u32)pMpuAddr) != DSP_ENOTFOUND) {
-				DRV_InsertDMMResElement(&dmmRes, pCtxt);
-				DRV_UpdateDMMResElement(dmmRes, (u32)pMpuAddr,
-						ulSize, (u32)pReqAddr,
-						(u32)*ppMapAddr, hProcessor);
-			}
-		}
+		DRV_InsertDMMResElement(&dmmRes, pr_ctxt);
+		DRV_UpdateDMMResElement(dmmRes, (u32)pMpuAddr, ulSize,
+				(u32)pReqAddr, (u32)*ppMapAddr, hProcessor);
 	}
 #endif
+func_end:
 	GT_1trace(PROC_DebugMask, GT_ENTER, "Leaving PROC_Map [0x%x]", status);
 	return status;
 }
@@ -1453,7 +1463,7 @@ DSP_STATUS PROC_RegisterNotify(DSP_HPROC
 	/* Check if event mask is a valid processor related event */
 	if (uEventMask & ~(DSP_PROCESSORSTATECHANGE | DSP_PROCESSORATTACH |
 	   DSP_PROCESSORDETACH | DSP_PROCESSORRESTART | DSP_MMUFAULT |
-	   DSP_SYSERROR))
+	   DSP_SYSERROR | DSP_PWRERROR))
 		status = DSP_EVALUE;
 
 	/* Check if notify type is valid */
@@ -1461,12 +1471,13 @@ DSP_STATUS PROC_RegisterNotify(DSP_HPROC
 		status = DSP_EVALUE;
 
 	if (DSP_SUCCEEDED(status)) {
-		/* * If event mask is not DSP_SYSERROR or DSP_MMUFAULT,
-		 * then register event immediately.  */
-		if (uEventMask & ~(DSP_SYSERROR | DSP_MMUFAULT)) {
+		/* If event mask is not DSP_SYSERROR, DSP_MMUFAULT,
+		 * or DSP_PWRERROR then register event immediately. */
+		if (uEventMask &
+		    ~(DSP_SYSERROR | DSP_MMUFAULT | DSP_PWRERROR)) {
 			status = NTFY_Register(pProcObject->hNtfy,
 				 hNotification,	uEventMask, uNotifyType);
-			/* * Special case alert, special case alert!
+			/* Special case alert, special case alert!
 			 * If we're trying to *deregister* (i.e. uEventMask
 			 * is 0), a DSP_SYSERROR or DSP_MMUFAULT notification,
 			 * we have to deregister with the DEH manager.
@@ -1518,6 +1529,12 @@ DSP_STATUS PROC_ReserveMemory(DSP_HPROCE
 		 "Entered PROC_ReserveMemory, args:\n\t"
 		 "hProcessor: 0x%x ulSize: 0x%x ppRsvAddr: 0x%x\n", hProcessor,
 		 ulSize, ppRsvAddr);
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_Map: "
+			 "InValid Processor Handle \n");
+		goto func_end;
+	}
 	status = DMM_GetHandle(pProcObject, &hDmmMgr);
 	if (DSP_FAILED(status)) {
 		GT_1trace(PROC_DebugMask, GT_7CLASS, "PROC_ReserveMemory: "
@@ -1527,6 +1544,7 @@ DSP_STATUS PROC_ReserveMemory(DSP_HPROCE
 
 	GT_1trace(PROC_DebugMask, GT_ENTER, "Leaving PROC_ReserveMemory [0x%x]",
 		 status);
+func_end:
 	return status;
 }
 
@@ -1642,9 +1660,8 @@ DSP_STATUS PROC_Stop(DSP_HPROCESSOR hPro
 	u32 uNodeTabSize = 1;
 	u32 uNumNodes = 0;
 	u32 uNodesAllocated = 0;
-#ifdef DEBUG
 	BRD_STATUS uBrdState;
-#endif
+
 	DBC_Require(cRefs > 0);
 	GT_1trace(PROC_DebugMask, GT_ENTER, "Entered PROC_Stop, args:\n\t"
 		 "hProcessor:  0x%x\n", hProcessor);
@@ -1654,6 +1671,13 @@ DSP_STATUS PROC_Stop(DSP_HPROCESSOR hPro
 			 "PROC_Stop :InValid Handle \n");
 		goto func_end;
 	}
+	if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
+	   (pProcObject->hWmdContext, &uBrdState))) {
+		/* Clean up all the resources except the current running
+		 * process resources */
+		if (uBrdState == BRD_ERROR)
+			PROC_CleanupAllResources();
+	}
 	/* check if there are any running nodes */
 	status = DEV_GetNodeManager(pProcObject->hDevObject, &hNodeMgr);
 	if (DSP_SUCCEEDED(status) && hNodeMgr) {
@@ -1712,7 +1736,8 @@ func_end:
  *  Purpose:
  *      Removes a MPU buffer mapping from the DSP address space.
  */
-DSP_STATUS PROC_UnMap(DSP_HPROCESSOR hProcessor, void *pMapAddr)
+DSP_STATUS PROC_UnMap(DSP_HPROCESSOR hProcessor, void *pMapAddr,
+		struct PROCESS_CONTEXT *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
@@ -1720,19 +1745,23 @@ DSP_STATUS PROC_UnMap(DSP_HPROCESSOR hPr
 	u32 vaAlign;
 	u32 sizeAlign;
 #ifndef RES_CLEANUP_DISABLE
-       u32                   hProcess;
-	HANDLE	      pCtxt = NULL;
-	HANDLE	      hDrvObject;
 	HANDLE	      dmmRes;
-	DSP_STATUS res_status = DSP_SOK;
 #endif
 	GT_2trace(PROC_DebugMask, GT_ENTER,
 		 "Entered PROC_UnMap, args:\n\thProcessor:"
 		 "0x%x pMapAddr: 0x%x\n", hProcessor, pMapAddr);
 
 	vaAlign = PG_ALIGN_LOW((u32) pMapAddr, PG_SIZE_4K);
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_UnMap: "
+			 "InValid Processor Handle \n");
+		goto func_end;
+	}
 
 	status = DMM_GetHandle(hProcessor, &hDmmMgr);
+	if (DSP_FAILED(status))
+		goto func_end;
 	/* Critical section */
 	(void)SYNC_EnterCS(hProcLock);
 	if (DSP_FAILED(status)) {
@@ -1756,23 +1785,11 @@ DSP_STATUS PROC_UnMap(DSP_HPROCESSOR hPr
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	/* Update the node and stream resource status */
-       /* Return PID instead of process handle */
-       hProcess = current->pid;
-
-	res_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	if (DSP_FAILED(res_status))
-		goto func_end;
-
-       DRV_GetProcContext(hProcess, (struct DRV_OBJECT *)hDrvObject,
-			 &pCtxt, NULL, (u32)pMapAddr);
-	if (pCtxt != NULL) {
-		if (DRV_GetDMMResElement((u32)pMapAddr, &dmmRes, pCtxt) !=
-		   DSP_ENOTFOUND)
-			DRV_RemoveDMMResElement(dmmRes, pCtxt);
-	}
-func_end:
+	if (pr_ctxt && DRV_GetDMMResElement((u32)pMapAddr, &dmmRes, pr_ctxt)
+							!= DSP_ENOTFOUND)
+		DRV_RemoveDMMResElement(dmmRes, pr_ctxt);
 #endif
+func_end:
 	GT_1trace(PROC_DebugMask, GT_ENTER,
 		 "Leaving PROC_UnMap [0x%x]", status);
 	return status;
@@ -1792,7 +1809,12 @@ DSP_STATUS PROC_UnReserveMemory(DSP_HPRO
 	GT_2trace(PROC_DebugMask, GT_ENTER,
 		 "Entered PROC_UnReserveMemory, args:\n\t"
 		 "hProcessor: 0x%x pRsvAddr: 0x%x\n", hProcessor, pRsvAddr);
-
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_UnMap: "
+			 "InValid Processor Handle \n");
+		goto func_end;
+	}
 	status = DMM_GetHandle(pProcObject, &hDmmMgr);
 	if (DSP_FAILED(status))
 		GT_1trace(PROC_DebugMask, GT_7CLASS,
@@ -1804,7 +1826,7 @@ DSP_STATUS PROC_UnReserveMemory(DSP_HPRO
 	GT_1trace(PROC_DebugMask, GT_ENTER,
 		 "Leaving PROC_UnReserveMemory [0x%x]",
 		 status);
-
+func_end:
 	return status;
 }
 
@@ -1938,11 +1960,17 @@ DSP_STATUS PROC_NotifyClients(DSP_HPROCE
 	DBC_Require(MEM_IsValidHandle(pProcObject, PROC_SIGNATURE));
 	DBC_Require(IsValidProcEvent(uEvents));
 	DBC_Require(cRefs > 0);
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_NotifyClients: "
+			 "InValid Processor Handle \n");
+		goto func_end;
+	}
 
 	NTFY_Notify(pProcObject->hNtfy, uEvents);
 	GT_0trace(PROC_DebugMask, GT_1CLASS,
 		 "PROC_NotifyClients :Signaled. \n");
-
+func_end:
 	return status;
 }
 
@@ -1979,8 +2007,13 @@ DSP_STATUS PROC_GetProcessorId(DSP_HPROC
 	DSP_STATUS status = DSP_SOK;
 	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProc;
 
-	*procID = pProcObject->uProcessor;
-
+	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE))
+		*procID = pProcObject->uProcessor;
+	else {
+		status = DSP_EHANDLE;
+		GT_0trace(PROC_DebugMask, GT_7CLASS, "PROC_GetProcessorId: "
+			 "InValid Processor Handle \n");
+	}
 	return status;
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/rmgr/strm.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/rmgr/strm.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/rmgr/strm.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/rmgr/strm.c	2012-12-16 13:13:01.568330147 +0100
@@ -154,18 +154,15 @@ static void DeleteStrmMgr(struct STRM_MG
  *      Allocates buffers for a stream.
  */
 DSP_STATUS STRM_AllocateBuffer(struct STRM_OBJECT *hStrm, u32 uSize,
-				OUT u8 **apBuffer, u32 uNumBufs)
+				OUT u8 **apBuffer, u32 uNumBufs,
+				struct PROCESS_CONTEXT *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	u32 uAllocated = 0;
 	u32 i;
-	#ifndef RES_CLEANUP_DISABLE
-	DSP_STATUS res_status = DSP_SOK;
-       u32                  hProcess;
-	HANDLE	     pCtxt = NULL;
-	HANDLE	     hDrvObject;
+#ifndef RES_CLEANUP_DISABLE
 	HANDLE hSTRMRes;
-	#endif
+#endif
 	DBC_Require(cRefs > 0);
 	DBC_Require(apBuffer != NULL);
 
@@ -197,26 +194,15 @@ DSP_STATUS STRM_AllocateBuffer(struct ST
 		}
 	}
 	if (DSP_FAILED(status))
-		STRM_FreeBuffer(hStrm, apBuffer, uAllocated);
+		STRM_FreeBuffer(hStrm, apBuffer, uAllocated, pr_ctxt);
 
 #ifndef RES_CLEANUP_DISABLE
 	if (DSP_FAILED(status))
 		goto func_end;
 
-       /* Return PID instead of process handle */
-       hProcess = current->pid;
-
-	res_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	if (DSP_FAILED(res_status))
-		goto func_end;
-
-       DRV_GetProcContext(hProcess, (struct DRV_OBJECT *)hDrvObject,
-			 &pCtxt, NULL, 0);
-	if (pCtxt != NULL) {
-		if (DRV_GetSTRMResElement(hStrm, &hSTRMRes, pCtxt) !=
-		   DSP_ENOTFOUND) {
-			DRV_ProcUpdateSTRMRes(uNumBufs, hSTRMRes, pCtxt);
-		}
+	if (DRV_GetSTRMResElement(hStrm, &hSTRMRes, pr_ctxt) !=
+			DSP_ENOTFOUND) {
+		DRV_ProcUpdateSTRMRes(uNumBufs, hSTRMRes, pr_ctxt);
 	}
 #endif
 func_end:
@@ -228,22 +214,17 @@ func_end:
  *  Purpose:
  *      Close a stream opened with STRM_Open().
  */
-DSP_STATUS STRM_Close(struct STRM_OBJECT *hStrm)
+DSP_STATUS STRM_Close(struct STRM_OBJECT *hStrm,
+		struct PROCESS_CONTEXT *pr_ctxt)
 {
 	struct WMD_DRV_INTERFACE *pIntfFxns;
 	struct CHNL_INFO chnlInfo;
 	DSP_STATUS status = DSP_SOK;
 
-
 #ifndef RES_CLEANUP_DISABLE
-    u32                      hProcess;
-    HANDLE	      pCtxt = NULL;
-    HANDLE	      hDrvObject;
     HANDLE	      hSTRMRes;
-    DSP_STATUS	  res_status = DSP_SOK;
 #endif
 
-
 	DBC_Require(cRefs > 0);
 
 	GT_1trace(STRM_debugMask, GT_ENTER, "STRM_Close: hStrm: 0x%x\n", hStrm);
@@ -276,21 +257,9 @@ DSP_STATUS STRM_Close(struct STRM_OBJECT
 	if (DSP_FAILED(status))
 		goto func_end;
 
-	/* Update the node and stream resource status */
-       /* Return PID instead of process handle */
-       hProcess = current->pid;
-
-	res_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	if (DSP_FAILED(res_status))
-		goto func_end;
-
-       DRV_GetProcContext(hProcess, (struct DRV_OBJECT *)hDrvObject,
-			 &pCtxt, NULL, 0);
-	if (pCtxt != NULL) {
-		if (DRV_GetSTRMResElement(hStrm, &hSTRMRes, pCtxt) !=
-		   DSP_ENOTFOUND) {
-			DRV_ProcRemoveSTRMResElement(hSTRMRes, pCtxt);
-		}
+	if (DRV_GetSTRMResElement(hStrm, &hSTRMRes, pr_ctxt) !=
+			DSP_ENOTFOUND) {
+		DRV_ProcRemoveSTRMResElement(hSTRMRes, pr_ctxt);
 	}
 func_end:
 #endif
@@ -394,18 +363,14 @@ void STRM_Exit(void)
  *      Frees the buffers allocated for a stream.
  */
 DSP_STATUS STRM_FreeBuffer(struct STRM_OBJECT *hStrm, u8 **apBuffer,
-			  u32 uNumBufs)
+		u32 uNumBufs, struct PROCESS_CONTEXT *pr_ctxt)
 {
 	DSP_STATUS status = DSP_SOK;
 	u32 i = 0;
 
-	#ifndef RES_CLEANUP_DISABLE
-	DSP_STATUS res_status = DSP_SOK;
-       u32                  hProcess;
-	HANDLE	     pCtxt = NULL;
-	HANDLE	     hDrvObject;
-	HANDLE 		    hSTRMRes = NULL;
-	#endif
+#ifndef RES_CLEANUP_DISABLE
+	HANDLE hSTRMRes = NULL;
+#endif
 	DBC_Require(cRefs > 0);
 	DBC_Require(apBuffer != NULL);
 
@@ -429,22 +394,9 @@ DSP_STATUS STRM_FreeBuffer(struct STRM_O
 		}
 	}
 #ifndef RES_CLEANUP_DISABLE
-	/* Update the node and stream resource status */
-       /* Return PID instead of process handle */
-       hProcess = current->pid;
-
-	res_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	if (DSP_SUCCEEDED(res_status)) {
-               DRV_GetProcContext(hProcess,
-				 (struct DRV_OBJECT *)hDrvObject, &pCtxt,
-				 NULL, 0);
-		if (pCtxt != NULL) {
-			if (DRV_GetSTRMResElement(hStrm, hSTRMRes, pCtxt) !=
-			   DSP_ENOTFOUND) {
-				DRV_ProcUpdateSTRMRes(uNumBufs-i, hSTRMRes,
-						     pCtxt);
-			}
-		}
+	if (DRV_GetSTRMResElement(hStrm, hSTRMRes, pr_ctxt) !=
+			DSP_ENOTFOUND) {
+		DRV_ProcUpdateSTRMRes(uNumBufs-i, hSTRMRes, pr_ctxt);
 	}
 #endif
 	return status;
@@ -626,7 +578,9 @@ DSP_STATUS STRM_Issue(struct STRM_OBJECT
  *      XDAIS socket node on the DSP.
  */
 DSP_STATUS STRM_Open(struct NODE_OBJECT *hNode, u32 uDir, u32 uIndex,
-		    IN struct STRM_ATTR *pAttr, OUT struct STRM_OBJECT **phStrm)
+		    IN struct STRM_ATTR *pAttr,
+		    OUT struct STRM_OBJECT **phStrm,
+		    struct PROCESS_CONTEXT *pr_ctxt)
 {
 	struct STRM_MGR *hStrmMgr;
 	struct WMD_DRV_INTERFACE *pIntfFxns;
@@ -637,13 +591,10 @@ DSP_STATUS STRM_Open(struct NODE_OBJECT
 	DSP_STATUS status = DSP_SOK;
 	struct CMM_OBJECT *hCmmMgr = NULL;	/* Shared memory manager hndl */
 
-	#ifndef RES_CLEANUP_DISABLE
-	DSP_STATUS res_status = DSP_SOK;
-       u32                  hProcess;
-	HANDLE	     pCtxt = NULL;
-	HANDLE	     hDrvObject;
-	HANDLE 		    hSTRMRes;
-	#endif
+#ifndef RES_CLEANUP_DISABLE
+	HANDLE              hSTRMRes;
+#endif
+
 	DBC_Require(cRefs > 0);
 	DBC_Require(phStrm != NULL);
 	DBC_Require(pAttr != NULL);
@@ -779,18 +730,7 @@ func_cont:
 		(void)DeleteStrm(pStrm);
 
 #ifndef RES_CLEANUP_DISABLE
-       /* Return PID instead of process handle */
-       hProcess = current->pid;
-
-	res_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
-	if (DSP_SUCCEEDED(res_status)) {
-               DRV_GetProcContext(hProcess,
-				 (struct DRV_OBJECT *)hDrvObject, &pCtxt,
-				 hNode, 0);
-		if (pCtxt != NULL)
-			DRV_ProcInsertSTRMResElement(*phStrm, &hSTRMRes, pCtxt);
-
-	}
+	DRV_ProcInsertSTRMResElement(*phStrm, &hSTRMRes, pr_ctxt);
 #endif
 
 	 /* ensure we return a documented error code */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/services/clk.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/services/clk.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/services/clk.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/services/clk.c	2012-12-16 13:13:01.568330147 +0100
@@ -188,7 +188,7 @@ DSP_STATUS CLK_Enable(IN enum SERVICES_C
 	struct clk *pClk;
 
 	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
-       GT_2trace(CLK_debugMask, GT_6CLASS, "CLK_Enable: CLK %s, "
+	GT_2trace(CLK_debugMask, GT_6CLASS, "CLK_Enable: CLK %s, "
 		"CLK dev id = %d\n", SERVICES_Clks[clk_id].clk_name,
 		SERVICES_Clks[clk_id].id);
 
@@ -197,18 +197,16 @@ DSP_STATUS CLK_Enable(IN enum SERVICES_C
 		if (clk_enable(pClk) == 0x0) {
 			/* Success ? */
 		} else {
-		       GT_2trace(CLK_debugMask, GT_7CLASS,
-				 "CLK_Enable: failed to Enable CLK %s, "
-				 "CLK dev id = %d\n",
-				 SERVICES_Clks[clk_id].clk_name,
-				 SERVICES_Clks[clk_id].id);
+			pr_err("CLK_Enable: failed to Enable CLK %s, "
+					"CLK dev id = %d\n",
+					SERVICES_Clks[clk_id].clk_name,
+					SERVICES_Clks[clk_id].id);
 			status = DSP_EFAIL;
 		}
 	} else {
-	       GT_2trace(CLK_debugMask, GT_7CLASS,
-			 "CLK_Enable: failed to get CLK %s, CLK dev id = %d\n",
-			 SERVICES_Clks[clk_id].clk_name,
-			 SERVICES_Clks[clk_id].id);
+		pr_err("CLK_Enable: failed to get CLK %s, CLK dev id = %d\n",
+					SERVICES_Clks[clk_id].clk_name,
+					SERVICES_Clks[clk_id].id);
 		status = DSP_EFAIL;
 	}
 	/* The SSI module need to configured not to have the Forced idle for
@@ -236,7 +234,7 @@ DSP_STATUS CLK_Set_32KHz(IN enum SERVICE
 	pClkParent =  SERVICES_Clks[sys_32k_id].clk_handle;
 
 	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
-       GT_2trace(CLK_debugMask, GT_6CLASS, "CLK_Set_32KHz: CLK %s, "
+	GT_2trace(CLK_debugMask, GT_6CLASS, "CLK_Set_32KHz: CLK %s, "
 		"CLK dev id = %d is setting to 32KHz \n",
 		SERVICES_Clks[clk_id].clk_name,
 		SERVICES_Clks[clk_id].id);
@@ -266,7 +264,7 @@ DSP_STATUS CLK_Disable(IN enum SERVICES_
 	s32 clkUseCnt;
 
 	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
-       GT_2trace(CLK_debugMask, GT_6CLASS, "CLK_Disable: CLK %s, "
+	GT_2trace(CLK_debugMask, GT_6CLASS, "CLK_Disable: CLK %s, "
 		"CLK dev id = %d\n", SERVICES_Clks[clk_id].clk_name,
 		SERVICES_Clks[clk_id].id);
 
@@ -274,16 +272,16 @@ DSP_STATUS CLK_Disable(IN enum SERVICES_
 
 	clkUseCnt = CLK_Get_UseCnt(clk_id);
 	if (clkUseCnt == -1) {
-	       GT_2trace(CLK_debugMask, GT_7CLASS, "CLK_Disable: failed to "
-			"get CLK Use count for CLK %s, CLK dev id = %d\n",
-			SERVICES_Clks[clk_id].clk_name,
-			SERVICES_Clks[clk_id].id);
+		pr_err("CLK_Disable: failed to get CLK Use count for CLK %s,"
+				"CLK dev id = %d\n",
+				SERVICES_Clks[clk_id].clk_name,
+				SERVICES_Clks[clk_id].id);
 	} else if (clkUseCnt == 0) {
-	       GT_2trace(CLK_debugMask, GT_7CLASS, "CLK_Disable: CLK %s, "
-			"CLK dev id= %d is already disabled\n",
-			SERVICES_Clks[clk_id].clk_name,
-			SERVICES_Clks[clk_id].id);
-		 return status;
+		GT_2trace(CLK_debugMask, GT_4CLASS, "CLK_Disable: CLK %s,"
+				"CLK dev id= %d is already disabled\n",
+				SERVICES_Clks[clk_id].clk_name,
+				SERVICES_Clks[clk_id].id);
+		return status;
 	}
 	if (clk_id == SERVICESCLK_ssi_ick)
 		SSI_Clk_Prepare(false);
@@ -291,10 +289,10 @@ DSP_STATUS CLK_Disable(IN enum SERVICES_
 		if (pClk) {
 			clk_disable(pClk);
 		} else {
-		       GT_2trace(CLK_debugMask, GT_7CLASS, "CLK_Disable: "
-				"failed to get CLK %s, CLK dev id = %d\n",
-				SERVICES_Clks[clk_id].clk_name,
-				SERVICES_Clks[clk_id].id);
+			pr_err("CLK_Disable: failed to get CLK %s,"
+					"CLK dev id = %d\n",
+					SERVICES_Clks[clk_id].clk_name,
+					SERVICES_Clks[clk_id].id);
 			status = DSP_EFAIL;
 		}
 	return status;
@@ -316,7 +314,7 @@ DSP_STATUS CLK_GetRate(IN enum SERVICES_
 	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
 	*speedKhz = 0x0;
 
-       GT_2trace(CLK_debugMask, GT_7CLASS, "CLK_GetRate: CLK %s, "
+	GT_2trace(CLK_debugMask, GT_7CLASS, "CLK_GetRate: CLK %s, "
 		"CLK dev Id = %d \n", SERVICES_Clks[clk_id].clk_name,
 		SERVICES_Clks[clk_id].id);
 	pClk = SERVICES_Clks[clk_id].clk_handle;
@@ -327,7 +325,7 @@ DSP_STATUS CLK_GetRate(IN enum SERVICES_
 			  "CLK_GetRate: clkSpeedHz = %d , "
 			 "speedinKhz=%d\n", clkSpeedHz, *speedKhz);
 	} else {
-	       GT_2trace(CLK_debugMask, GT_7CLASS,
+		GT_2trace(CLK_debugMask, GT_7CLASS,
 			 "CLK_GetRate: failed to get CLK %s, "
 			 "CLK dev Id = %d\n", SERVICES_Clks[clk_id].clk_name,
 			 SERVICES_Clks[clk_id].id);
@@ -348,7 +346,7 @@ s32 CLK_Get_UseCnt(IN enum SERVICES_ClkI
 	if (pClk) {
 		useCount =  pClk->usecount; /* FIXME: usecount shouldn't be used */
 	} else {
-	       GT_2trace(CLK_debugMask, GT_7CLASS,
+		GT_2trace(CLK_debugMask, GT_7CLASS,
 			 "CLK_GetRate: failed to get CLK %s, "
 			 "CLK dev Id = %d\n", SERVICES_Clks[clk_id].clk_name,
 			 SERVICES_Clks[clk_id].id);
@@ -362,14 +360,15 @@ void SSI_Clk_Prepare(bool FLAG)
 	u32 ssi_sysconfig;
 	ssi_sysconfig = __raw_readl((SSI_BASE) + 0x10);
 
-
 	if (FLAG) {
 		/* Set Autoidle, SIDLEMode to smart idle, and MIDLEmode to
-		 * no idle */
+		 * no idle
+		 */
 		ssi_sysconfig = 0x1011;
 	} else {
 		/* Set Autoidle, SIDLEMode to forced idle, and MIDLEmode to
-		 * forced idle*/
+		 * forced idle
+		 */
 		ssi_sysconfig = 0x1;
 	}
 	__raw_writel((u32)ssi_sysconfig, SSI_BASE + 0x10);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/services/kfile.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/services/kfile.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/services/kfile.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/services/kfile.c	2012-12-16 13:13:01.568330147 +0100
@@ -92,7 +92,6 @@ s32 KFILE_Close(struct KFILE_FileObj *hF
 {
 	s32 cRetVal = 0;	/* 0 indicates success */
 	s32 fRetVal = 0;
-	__kernel_pid_t curr_pid;
 
 	GT_1trace(KFILE_debugMask, GT_ENTER, "KFILE_Close: hFile 0x%x\n",
 		  hFile);
@@ -101,8 +100,6 @@ s32 KFILE_Close(struct KFILE_FileObj *hF
 	if (MEM_IsValidHandle(hFile, SIGNATURE)) {
 		/* Close file only if opened by the same process (id). Otherwise
 		 * Linux closes all open file handles when process exits.*/
-               /* Return PID instead of process handle */
-               curr_pid = (__kernel_pid_t)current->pid;
 		fRetVal = filp_close(hFile->fileDesc, NULL) ;
 		if (fRetVal) {
 			cRetVal = E_KFILE_ERROR;
@@ -181,8 +178,8 @@ struct KFILE_FileObj *KFILE_Open(CONST c
 			hFile->size = fileDesc->f_op->llseek(fileDesc, 0,
 							    SEEK_END);
 			fileDesc->f_op->llseek(fileDesc, 0, SEEK_SET);
-                       /* Return PID instead of process handle */
-                       hFile->owner_pid = current->pid;
+			/* Return TGID instead of process handle */
+			hFile->owner_pid = current->tgid;
 
 			status = DSP_SOK;
 		}
@@ -262,7 +259,7 @@ KFILE_Read(void __user*pBuffer, s32 cSiz
 s32 KFILE_Seek(struct KFILE_FileObj *hFile, s32 lOffset, s32 cOrigin)
 {
 	s32 cRetVal = 0;	/* 0 for success */
-	u32 dwCurPos = 0;
+	loff_t dwCurPos = 0;
 
 	struct file *fileDesc = NULL;
 
@@ -315,7 +312,7 @@ s32 KFILE_Seek(struct KFILE_FileObj *hFi
  */
 s32 KFILE_Tell(struct KFILE_FileObj *hFile)
 {
-	u32 dwCurPos = 0;
+	loff_t dwCurPos = 0;
 	s32 lRetVal = E_KFILE_ERROR;
 
 	GT_1trace(KFILE_debugMask, GT_ENTER, "KFILE_Tell: hFile 0x%x\n", hFile);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/services/mem.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/services/mem.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/services/mem.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/services/mem.c	2012-12-16 13:13:01.568330147 +0100
@@ -281,11 +281,11 @@ void *MEM_Alloc(u32 cBytes, enum MEM_POO
 		/* If non-paged memory required, see note at top of file. */
 		case MEM_PAGED:
 #ifndef MEM_CHECK
-                                  pMem = kmalloc(cBytes,
-                                              (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
+			pMem = kmalloc(cBytes,
+				(in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
 #else
 			pMem = kmalloc(cBytes + sizeof(struct memInfo),
-                                              (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
+				(in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
 			if (pMem) {
 				pMem->size = cBytes;
 				pMem->caller = __builtin_return_address(0);
@@ -303,13 +303,9 @@ void *MEM_Alloc(u32 cBytes, enum MEM_POO
 			break;
 		case MEM_LARGEVIRTMEM:
 #ifndef MEM_CHECK
-			/* FIXME - Replace with 'vmalloc' after BP fix */
-                                  pMem = __vmalloc(cBytes,
-                                  (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL, PAGE_KERNEL);
+			pMem = vmalloc(cBytes);
 #else
-			/* FIXME - Replace with 'vmalloc' after BP fix */
-			pMem = __vmalloc((cBytes + sizeof(struct memInfo)),
-                                  (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL, PAGE_KERNEL);
+			pMem = vmalloc(cBytes + sizeof(struct memInfo));
 			if (pMem) {
 				pMem->size = cBytes;
 				pMem->caller = __builtin_return_address(0);
@@ -359,7 +355,7 @@ void *MEM_AllocPhysMem(u32 cBytes, u32 u
 						    (u32 *)&paMem);
 		} else
 			pVaMem = dma_alloc_coherent(NULL, cBytes, &paMem,
-                                              (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
+				(in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
 		if (pVaMem == NULL) {
 			*pPhysicalAddress = 0;
 			GT_1trace(MEM_debugMask, GT_6CLASS,
@@ -391,14 +387,14 @@ void *MEM_Calloc(u32 cBytes, enum MEM_PO
 		/* If non-paged memory required, see note at top of file. */
 		case MEM_PAGED:
 #ifndef MEM_CHECK
-                                  pMem = kmalloc(cBytes,
-                                              (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
+			pMem = kmalloc(cBytes,
+				(in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
 			if (pMem)
 				memset(pMem, 0, cBytes);
 
 #else
 			pMem = kmalloc(cBytes + sizeof(struct memInfo),
-                                              (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
+				(in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
 			if (pMem) {
 				memset((void *)((u32)pMem +
 					sizeof(struct memInfo)), 0, cBytes);
@@ -416,16 +412,11 @@ void *MEM_Calloc(u32 cBytes, enum MEM_PO
 			break;
 		case MEM_LARGEVIRTMEM:
 #ifndef MEM_CHECK
-			/* FIXME - Replace with 'vmalloc' after BP fix */
-                                  pMem = __vmalloc(cBytes,
-                                  (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL, PAGE_KERNEL);
+			pMem = vmalloc(cBytes);
 			if (pMem)
 				memset(pMem, 0, cBytes);
-
 #else
-			/* FIXME - Replace with 'vmalloc' after BP fix */
-			pMem = __vmalloc(cBytes + sizeof(struct memInfo),
-                                  (in_atomic()) ? GFP_ATOMIC : GFP_KERNEL, PAGE_KERNEL);
+			pMem = vmalloc(cBytes + sizeof(struct memInfo));
 			if (pMem) {
 				memset((void *)((u32)pMem +
 					sizeof(struct memInfo)), 0, cBytes);
@@ -509,6 +500,44 @@ void MEM_FlushCache(void *pMemBuf, u32 c
 
 }
 
+/*
+ *  ======== MEM_VFree ========
+ *  Purpose:
+ *      Free the given block of system memory in virtual space.
+ */
+void MEM_VFree(IN void *pMemBuf)
+{
+#ifdef MEM_CHECK
+	struct memInfo *pMem = (void *)((u32)pMemBuf - sizeof(struct memInfo));
+#endif
+
+	DBC_Require(pMemBuf != NULL);
+
+	GT_1trace(MEM_debugMask, GT_ENTER, "MEM_VFree: pMemBufs 0x%x\n",
+		  pMemBuf);
+
+	if (pMemBuf) {
+#ifndef MEM_CHECK
+		vfree(pMemBuf);
+#else
+		if (pMem) {
+			if (pMem->dwSignature == memInfoSign) {
+				spin_lock(&mMan.lock);
+				MLST_RemoveElem(&mMan.lst,
+						(struct LST_ELEM *) pMem);
+				spin_unlock(&mMan.lock);
+				pMem->dwSignature = 0;
+				vfree(pMem);
+			} else {
+				GT_1trace(MEM_debugMask, GT_7CLASS,
+					"Invalid allocation or "
+					"Buffer underflow at %x\n",
+					(u32) pMem + sizeof(struct memInfo));
+			}
+		}
+#endif
+	}
+}
 
 /*
  *  ======== MEM_Free ========
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/services/regsup.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/services/regsup.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/services/regsup.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/services/regsup.c	2012-12-16 13:13:01.568330147 +0100
@@ -238,8 +238,10 @@ DSP_STATUS regsupSetValue(char *valName,
 		/*  No match, need to make a new entry  */
 		/*  First check to see if we can make any more entries.  */
 		if (pRegKey->numValueEntries < BRIDGE_MAX_NUM_REG_ENTRIES) {
-                       strncpy(pRegKey->values[pRegKey->numValueEntries].name,
-                               valName, BRIDGE_MAX_NAME_SIZE);
+			char *tmp_name =
+				pRegKey->values[pRegKey->numValueEntries].name;
+			strncpy(tmp_name, valName, BRIDGE_MAX_NAME_SIZE - 1);
+			tmp_name[BRIDGE_MAX_NAME_SIZE - 1] = '\0';
 			pRegKey->values[pRegKey->numValueEntries].pData =
 					MEM_Alloc(dataSize, MEM_NONPAGED);
 			if (pRegKey->values[pRegKey->numValueEntries].pData !=
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/services/sync.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/services/sync.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/services/sync.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/services/sync.c	2012-12-16 13:13:01.568330147 +0100
@@ -371,7 +371,13 @@ DSP_STATUS SYNC_WaitOnMultipleEvents(str
 		if (down_interruptible(&(Wp->sem))) {
 			GT_0trace(SYNC_debugMask, GT_7CLASS, "SYNC: "
 				"WaitOnMultipleEvents Interrupted by signal\n");
-			status = DSP_EFAIL;
+			/*
+			 * Most probably we are interrupted by a fake signal
+			 * from freezer. Return -ERESTARTSYS so that this
+			 * ioctl is restarted, and user space doesn't notice
+			 * it.
+			 */
+			status = -ERESTARTSYS;
 		}
 		if (dwTimeout != SYNC_INFINITE) {
 			if (in_interrupt()) {
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/wmd/chnl_sm.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/wmd/chnl_sm.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/wmd/chnl_sm.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/wmd/chnl_sm.c	2012-12-16 13:13:01.572330147 +0100
@@ -933,8 +933,8 @@ DSP_STATUS WMD_CHNL_Open(OUT struct CHNL
 			pChnl->uMode = uMode;
 			pChnl->hUserEvent = hSyncEvent;	/* for Linux */
 			pChnl->hSyncEvent = hSyncEvent;
-                       /* get the process handle */
-                       pChnl->hProcess = current->pid;
+			/* Return TGID instead of process handle */
+			pChnl->hProcess = current->tgid;
 			pChnl->pCBArg = 0;
 			pChnl->cBytesMoved = 0;
 			/* Default to proc-copy */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/wmd/io_sm.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/wmd/io_sm.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/wmd/io_sm.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/wmd/io_sm.c	2012-12-16 13:13:01.572330147 +0100
@@ -204,7 +204,7 @@ DSP_STATUS WMD_IO_Create(OUT struct IO_M
 	struct CFG_HOSTRES hostRes;
 	struct CFG_DEVNODE *hDevNode;
 	struct CHNL_MGR *hChnlMgr;
-       static int ref_count;
+	static int ref_count;
 	u32 devType;
 	/* Check DBC requirements:  */
 	DBC_Require(phIOMgr != NULL);
@@ -215,31 +215,30 @@ DSP_STATUS WMD_IO_Create(OUT struct IO_M
 	DBC_Require(status != DSP_EHANDLE);
 	DBC_Require(hChnlMgr != NULL);
 	DBC_Require(hChnlMgr->hIOMgr == NULL);
-	 /*  Message manager will be created when a file is loaded, since
-	 *  size of message buffer in shared memory is configurable in
-	 *  the base image.  */
+	/*
+	 * Message manager will be created when a file is loaded, since
+	 * size of message buffer in shared memory is configurable in
+	 * the base image.
+	 */
 	DEV_GetWMDContext(hDevObject, &hWmdContext);
 	DBC_Assert(hWmdContext);
 	DEV_GetDevType(hDevObject, &devType);
-	/*  DSP shared memory area will get set properly when
-	 *  a program is loaded. They are unknown until a COFF file is
-	 *  loaded. I chose the value -1 because it was less likely to be
-	 *  a valid address than 0.  */
+	/*
+	 * DSP shared memory area will get set properly when
+	 * a program is loaded. They are unknown until a COFF file is
+	 * loaded. I chose the value -1 because it was less likely to be
+	 * a valid address than 0.
+	 */
 	pSharedMem = (struct SHM *) -1;
 	if (DSP_FAILED(status))
 		goto func_cont;
 
-    /*
-     *  Create a Single Threaded Work Queue
-     */
-
-       if (ref_count == 0)
-               bridge_workqueue = create_workqueue("bridge_work-queue");
-
-       if (bridge_workqueue <= 0)
-               DBG_Trace(DBG_LEVEL1, "Workque Create"
-                       " failed 0x%d \n", bridge_workqueue);
+	/* Create a Single Threaded Work Queue */
+	if (ref_count == 0)
+		bridge_workqueue = create_workqueue("bridge_work-queue");
 
+	if (!bridge_workqueue)
+		DBG_Trace(DBG_LEVEL1, "Workqueue creation failed!\n");
 
 	/* Allocate IO manager object: */
 	MEM_AllocObject(pIOMgr, struct IO_MGR, IO_MGRSIGNATURE);
@@ -247,12 +246,13 @@ DSP_STATUS WMD_IO_Create(OUT struct IO_M
 		status = DSP_EMEMORY;
 		goto func_cont;
 	}
-       /*Intializing Work Element*/
-       if (ref_count == 0) {
-               INIT_WORK(&pIOMgr->io_workq, (void *)IO_DispatchPM);
-               ref_count = 1;
-       } else
-               PREPARE_WORK(&pIOMgr->io_workq, (void *)IO_DispatchPM);
+
+	/* Intializing Work Element */
+	if (ref_count == 0) {
+		INIT_WORK(&pIOMgr->io_workq, (void *)IO_DispatchPM);
+		ref_count = 1;
+	} else
+		PREPARE_WORK(&pIOMgr->io_workq, (void *)IO_DispatchPM);
 
 	/* Initialize CHNL_MGR object:    */
 #ifndef DSP_TRACEBUF_DISABLED
@@ -282,19 +282,20 @@ DSP_STATUS WMD_IO_Create(OUT struct IO_M
 		pIOMgr->fSharedIRQ = pMgrAttrs->fShared;
 		IO_DisableInterrupt(hWmdContext);
 		if (devType == DSP_UNIT) {
+			HW_MBOX_initSettings(hostRes.dwMboxBase);
 			/* Plug the channel ISR:. */
-                       if ((request_irq(INT_MAIL_MPU_IRQ, IO_ISR, 0,
-                               "DspBridge\tmailbox", (void *)pIOMgr)) == 0)
-                               status = DSP_SOK;
-                       else
-                               status = DSP_EFAIL;
+			if ((request_irq(INT_MAIL_MPU_IRQ, IO_ISR, 0,
+				"DspBridge\tmailbox", (void *)pIOMgr)) == 0)
+				status = DSP_SOK;
+			else
+				status = DSP_EFAIL;
 		}
-       if (DSP_SUCCEEDED(status))
-               DBG_Trace(DBG_LEVEL1, "ISR_IRQ Object 0x%x \n",
-                               pIOMgr);
-       else
-               status = CHNL_E_ISR;
-       } else
+		if (DSP_SUCCEEDED(status))
+			DBG_Trace(DBG_LEVEL1, "ISR_IRQ Object 0x%x \n",
+					pIOMgr);
+		else
+			status = CHNL_E_ISR;
+	} else
 		status = CHNL_E_ISR;
 func_cont:
 	if (DSP_FAILED(status)) {
@@ -533,6 +534,8 @@ func_cont1:
 	mapAttrs = DSP_MAPLITTLEENDIAN;
 	mapAttrs |= DSP_MAPPHYSICALADDR;
 	mapAttrs |= DSP_MAPELEMSIZE32;
+	mapAttrs |= DSP_MAPDONOTLOCK;
+
 	while (numBytes && DSP_SUCCEEDED(status)) {
 		/* To find the max. page size with which both PA & VA are
 		 * aligned */
@@ -670,18 +673,18 @@ func_cont:
 	mapAttrs = DSP_MAPLITTLEENDIAN;
 	mapAttrs |= DSP_MAPPHYSICALADDR;
 	mapAttrs |= DSP_MAPELEMSIZE32;
+	mapAttrs |= DSP_MAPDONOTLOCK;
+
 	/* Map the L4 peripherals */
-	{
-		i = 0;
-		while (L4PeripheralTable[i].physAddr && DSP_SUCCEEDED(status)) {
-				status = hIOMgr->pIntfFxns->pfnBrdMemMap
-					(hIOMgr->hWmdContext,
-					L4PeripheralTable[i].physAddr,
-					L4PeripheralTable[i].dspVirtAddr,
-					HW_PAGE_SIZE_4KB, mapAttrs);
-				DBC_Assert(DSP_SUCCEEDED(status));
-				i++;
-		}
+	i = 0;
+	while (L4PeripheralTable[i].physAddr && DSP_SUCCEEDED(status)) {
+		status = hIOMgr->pIntfFxns->pfnBrdMemMap
+			(hIOMgr->hWmdContext, L4PeripheralTable[i].physAddr,
+			L4PeripheralTable[i].dspVirtAddr, HW_PAGE_SIZE_4KB,
+			mapAttrs);
+		if (DSP_FAILED(status))
+			break;
+		i++;
 	}
 
 	if (DSP_SUCCEEDED(status)) {
@@ -1155,7 +1158,7 @@ static void InputChnl(struct IO_MGR *pIO
 			    pChnlMgr->uWordSize;
 	chnlId = IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm, inputId);
 	dwArg = IO_GetLong(pIOMgr->hWmdContext, struct SHM, sm, arg);
-	if (!(chnlId >= 0) || !(chnlId < CHNL_MAXCHANNELS)) {
+	if (chnlId >= CHNL_MAXCHANNELS) {
 		/* Shouldn't be here: would indicate corrupted SHM. */
 		DBC_Assert(chnlId);
 		goto func_end;
@@ -1740,9 +1743,6 @@ DSP_STATUS IO_SHMsetting(IN struct IO_MG
 		break;
 	default:
 		break;
-
-				queue_work(bridge_workqueue,
-							 &(hIOMgr->io_workq));
 	}
 #endif
 	return DSP_SOK;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/wmd/_tiomap.h kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/wmd/_tiomap.h
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/wmd/_tiomap.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/wmd/_tiomap.h	2012-12-16 13:13:01.572330147 +0100
@@ -340,7 +340,7 @@ struct WMD_DEV_CONTEXT {
 	 */
 	u32 dwDspExtBaseAddr;	/* See the comment above        */
 	u32 dwAPIRegBase;	/* API memory mapped registers  */
-	u32 dwDSPMmuBase;	/* DSP MMU Mapped registers     */
+	void __iomem *dwDSPMmuBase;	/* DSP MMU Mapped registers     */
 	u32 dwMailBoxBase;	/* Mail box mapped registers    */
 	u32 dwAPIClkBase;	/* CLK Registers                */
 	u32 dwDSPClkM2Base;	/* DSP Clock Module m2          */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/wmd/tiomap_sm.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/wmd/tiomap_sm.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/wmd/tiomap_sm.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/wmd/tiomap_sm.c	2012-12-16 13:13:01.572330147 +0100
@@ -28,6 +28,8 @@
 
 #define MAILBOX_FIFOSTATUS(m) (0x80 + 4 * (m))
 
+extern unsigned short min_active_opp;
+
 static inline unsigned int fifo_full(void __iomem *mbox_base, int mbox_id)
 {
 	return __raw_readl(mbox_base + MAILBOX_FIFOSTATUS(mbox_id)) & 0x1;
@@ -98,72 +100,72 @@ DSP_STATUS CHNLSM_DisableInterrupt(struc
 DSP_STATUS CHNLSM_InterruptDSP2(struct WMD_DEV_CONTEXT *pDevContext,
 				u16 wMbVal)
 {
-#ifdef CONFIG_BRIDGE_DVFS
-	struct dspbridge_platform_data *pdata =
-		omap_dspbridge_dev->dev.platform_data;
-	u32 opplevel = 0;
-#endif
 	struct CFG_HOSTRES resources;
 	DSP_STATUS status = DSP_SOK;
 	unsigned long timeout;
 	u32 temp;
 
-	status = CFG_GetHostResources((struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
-				      &resources);
+	status = CFG_GetHostResources((struct CFG_DEVNODE *)
+			DRV_GetFirstDevExtension(), &resources);
 	if (DSP_FAILED(status))
 		return DSP_EFAIL;
-#ifdef CONFIG_BRIDGE_DVFS
+
 	if (pDevContext->dwBrdState == BRD_DSP_HIBERNATION ||
 	    pDevContext->dwBrdState == BRD_HIBERNATION) {
-		if (pdata->dsp_get_opp)
-			opplevel = (*pdata->dsp_get_opp)();
-		if (opplevel == 1) {
-			if (pdata->dsp_set_min_opp)
-				(*pdata->dsp_set_min_opp)(opplevel+1);
-		}
-	}
+#ifdef CONFIG_BRIDGE_DVFS
+		struct dspbridge_platform_data *pdata =
+			omap_dspbridge_dev->dev.platform_data;
+		/*
+		 * When Smartreflex is ON, DSP requires at least OPP level 3
+		 * to operate reliably. So boost lower OPP levels to OPP3.
+		 */
+		if (pdata->dsp_set_min_opp)
+			(*pdata->dsp_set_min_opp)(min_active_opp);
 #endif
+		/* Restart the peripheral clocks */
+		DSP_PeripheralClocks_Enable(pDevContext, NULL);
 
-	if (pDevContext->dwBrdState == BRD_DSP_HIBERNATION ||
-	    pDevContext->dwBrdState == BRD_HIBERNATION) {
-		/* Restore mailbox settings */
-		/* Restart the peripheral clocks that were disabled only
-		 * in DSP initiated Hibernation case.*/
-		if (pDevContext->dwBrdState == BRD_DSP_HIBERNATION) {
-			DSP_PeripheralClocks_Enable(pDevContext, NULL);
-			/* Enabling Dpll in lock mode*/
-			temp = (u32) *((REG_UWORD32 *)
-				       ((u32) (resources.dwCmBase) + 0x34));
-			temp = (temp & 0xFFFFFFFE) | 0x1;
-			*((REG_UWORD32 *) ((u32) (resources.dwCmBase) + 0x34)) =
-				(u32) temp;
-			temp = (u32) *((REG_UWORD32 *)
-				       ((u32) (resources.dwCmBase) + 0x4));
-			temp = (temp & 0xFFFFFC8) | 0x37;
+		/*
+		 * 2:0 AUTO_IVA2_DPLL - Enabling IVA2 DPLL auto control
+		 *     in CM_AUTOIDLE_PLL_IVA2 register
+		 */
+		*(REG_UWORD32 *)(resources.dwCmBase + 0x34) = 0x1;
+
+		/*
+		 * 7:4 IVA2_DPLL_FREQSEL - IVA2 internal frq set to
+		 *     0.75 MHz - 1.0 MHz
+		 * 2:0 EN_IVA2_DPLL - Enable IVA2 DPLL in lock mode
+		 */
+		temp = *(REG_UWORD32 *)(resources.dwCmBase + 0x4);
+		temp = (temp & 0xFFFFFF08) | 0x37;
+		*(REG_UWORD32 *)(resources.dwCmBase + 0x4) = temp;
+
+		/*
+		 * This delay is needed to avoid mailbox timed out
+		 * issue experienced while SmartReflex is ON.
+		 * TODO: Instead of 1 ms calculate proper value.
+		 */
+		mdelay(1);
 
-			*((REG_UWORD32 *) ((u32) (resources.dwCmBase) + 0x4)) =
-				(u32) temp;
-		}
+		/* Restore mailbox settings */
 		HW_MBOX_restoreSettings(resources.dwMboxBase);
 
-		/*  Access MMU SYS CONFIG register to generate a short wakeup */
-		temp = (u32) *((REG_UWORD32 *) ((u32)
-						(resources.dwDmmuBase) + 0x10));
+		/* Access MMU SYS CONFIG register to generate a short wakeup */
+		temp = *(REG_UWORD32 *)(resources.dwDmmuBase + 0x10);
 
 		pDevContext->dwBrdState = BRD_RUNNING;
 	}
+
 	timeout = jiffies + msecs_to_jiffies(1);
 	while (fifo_full((void __iomem *) resources.dwMboxBase, 0)) {
 		if (time_after(jiffies, timeout)) {
-			printk(KERN_ERR "dspbridge: timed out waiting for mailbox\n");
+			pr_err("dspbridge: timed out waiting for mailbox\n");
 			return WMD_E_TIMEOUT;
 		}
 	}
-	DBG_Trace(DBG_LEVEL3, "writing %x to Mailbox\n",
-		  wMbVal);
 
-	HW_MBOX_MsgWrite(resources.dwMboxBase, MBOX_ARM2DSP,
-			 wMbVal);
+	DBG_Trace(DBG_LEVEL3, "writing %x to Mailbox\n", wMbVal);
+	HW_MBOX_MsgWrite(resources.dwMboxBase, MBOX_ARM2DSP, wMbVal);
 	return DSP_SOK;
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/wmd/tiomap3430.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/wmd/tiomap3430.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/wmd/tiomap3430.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/wmd/tiomap3430.c	2012-12-16 13:13:01.572330147 +0100
@@ -1,4 +1,3 @@
-
 /*
  * tiomap.c
  *
@@ -29,6 +28,8 @@
 
 /*  ----------------------------------- Host OS */
 #include <dspbridge/host_os.h>
+#include <linux/mm.h>
+#include <linux/mmzone.h>
 #include <mach-omap2/prm.h>
 #include <mach-omap2/cm.h>
 #include <mach-omap2/prm-regbits-34xx.h>
@@ -94,9 +95,12 @@
 #define MMU_LARGE_PAGE_MASK      0xFFFF0000
 #define MMU_SMALL_PAGE_MASK      0xFFFFF000
 #define PAGES_II_LVL_TABLE   512
+#define phys_to_page(phys)      pfn_to_page((phys) >> PAGE_SHIFT)
 
 #define MMU_GFLUSH 0x60
 
+extern unsigned short min_active_opp;
+
 /* Forward Declarations: */
 static DSP_STATUS WMD_BRD_Monitor(struct WMD_DEV_CONTEXT *pDevContext);
 static DSP_STATUS WMD_BRD_Read(struct WMD_DEV_CONTEXT *pDevContext,
@@ -130,9 +134,7 @@ static DSP_STATUS WMD_DEV_Create(OUT str
 static DSP_STATUS WMD_DEV_Ctrl(struct WMD_DEV_CONTEXT *pDevContext, u32 dwCmd,
 			IN OUT void *pArgs);
 static DSP_STATUS WMD_DEV_Destroy(struct WMD_DEV_CONTEXT *pDevContext);
-static DSP_STATUS TIOMAP_VirtToPhysical(struct mm_struct *mm, u32 ulMpuAddr,
-			u32 ulNumBytes, u32 *numOfTableEntries,
-			u32 *physicalAddrTable);
+static u32 user_va2pa(struct mm_struct *mm, u32 address);
 static DSP_STATUS PteUpdate(struct WMD_DEV_CONTEXT *hDevContext, u32 pa,
 			u32 va, u32 size,
 			struct HW_MMUMapAttrs_t *mapAttrs);
@@ -140,10 +142,38 @@ static DSP_STATUS PteSet(struct PgTableA
 			u32 size, struct HW_MMUMapAttrs_t *attrs);
 static DSP_STATUS MemMapVmalloc(struct WMD_DEV_CONTEXT *hDevContext,
 			u32 ulMpuAddr, u32 ulVirtAddr,
-			u32 ulNumBytes, u32 ulMapAttr);
-static DSP_STATUS run_IdleBoot(u32 prcm_base, u32 cm_base,
-			u32 sysctrl_base);
-void GetHWRegs(u32 prcm_base, u32 cm_base);
+			u32 ulNumBytes, struct HW_MMUMapAttrs_t *hwAttrs);
+
+#ifdef CONFIG_BRIDGE_DEBUG
+static void GetHWRegs(void __iomem *prm_base, void __iomem *cm_base)
+{
+	u32 temp;
+	temp = __raw_readl((cm_base) + 0x00);
+	DBG_Trace(DBG_LEVEL6, "CM_FCLKEN_IVA2 = 0x%x \n", temp);
+	temp = __raw_readl((cm_base) + 0x10);
+	DBG_Trace(DBG_LEVEL6, "CM_ICLKEN1_IVA2 = 0x%x \n", temp);
+	temp = __raw_readl((cm_base) + 0x20);
+	DBG_Trace(DBG_LEVEL6, "CM_IDLEST_IVA2 = 0x%x \n", temp);
+	temp = __raw_readl((cm_base) + 0x48);
+	DBG_Trace(DBG_LEVEL6, "CM_CLKSTCTRL_IVA2 = 0x%x \n", temp);
+	temp = __raw_readl((cm_base) + 0x4c);
+	DBG_Trace(DBG_LEVEL6, "CM_CLKSTST_IVA2 = 0x%x \n", temp);
+	temp = __raw_readl((prm_base) + 0x50);
+	DBG_Trace(DBG_LEVEL6, "RM_RSTCTRL_IVA2 = 0x%x \n", temp);
+	temp = __raw_readl((prm_base) + 0x58);
+	DBG_Trace(DBG_LEVEL6, "RM_RSTST_IVA2 = 0x%x \n", temp);
+	temp = __raw_readl((prm_base) + 0xE0);
+	DBG_Trace(DBG_LEVEL6, "PM_PWSTCTRL_IVA2 = 0x%x \n", temp);
+	temp = __raw_readl((prm_base) + 0xE4);
+	DBG_Trace(DBG_LEVEL6, "PM_PWSTST_IVA2 = 0x%x \n", temp);
+	temp = __raw_readl((cm_base) + 0xA10);
+	DBG_Trace(DBG_LEVEL6, "CM_ICLKEN1_CORE = 0x%x \n", temp);
+}
+#else
+static inline void GetHWRegs(void __iomem *prm_base, void __iomem *cm_base)
+{
+}
+#endif
 
 /*  ----------------------------------- Globals */
 
@@ -188,7 +218,6 @@ struct PgTableAttrs {
  */
 extern s32 dsp_debug;
 
-
 /*
  *  This mini driver's function interface table.
  */
@@ -244,27 +273,30 @@ static struct WMD_DRV_INTERFACE drvInter
 	WMD_MSG_SetQueueId,
 };
 
-static inline void tlb_flush_all(const u32 base)
+static inline void tlb_flush_all(const void __iomem *base)
 {
-    __raw_writeb(__raw_readb(base + MMU_GFLUSH) | 1, base + MMU_GFLUSH);
+	__raw_writeb(__raw_readb(base + MMU_GFLUSH) | 1, base + MMU_GFLUSH);
 }
 
 static inline void flush_all(struct WMD_DEV_CONTEXT *pDevContext)
 {
-	struct CFG_HOSTRES resources;
-	u32 temp = 0;
+	if (pDevContext->dwBrdState == BRD_DSP_HIBERNATION ||
+			pDevContext->dwBrdState == BRD_HIBERNATION)
+		WakeDSP(pDevContext, NULL);
 
-	CFG_GetHostResources((struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
-	HW_PWRST_IVA2RegGet(resources.dwPrmBase, &temp);
+	tlb_flush_all(pDevContext->dwDSPMmuBase);
+}
 
-	if ((temp & HW_PWR_STATE_ON) == HW_PWR_STATE_OFF ||
-	    (temp & HW_PWR_STATE_ON) == HW_PWR_STATE_RET) {
-		CLK_Enable(SERVICESCLK_iva2_ck);
-		WakeDSP(pDevContext, NULL);
-		tlb_flush_all(pDevContext->dwDSPMmuBase);
-		CLK_Disable(SERVICESCLK_iva2_ck);
-	} else
-		tlb_flush_all(pDevContext->dwDSPMmuBase);
+static void bad_page_dump(u32 pa, struct page *pg)
+{
+	pr_emerg("DSPBRIDGE: MAP function: COUNT 0 FOR PA 0x%x\n", pa);
+	pr_emerg("Bad page state in process '%s'\n"
+		"page:%p flags:0x%0*lx mapping:%p mapcount:%d count:%d\n"
+		"Backtrace:\n",
+		current->comm, pg, (int)(2*sizeof(unsigned long)),
+		(unsigned long)pg->flags, pg->mapping,
+		page_mapcount(pg), page_count(pg));
+	BUG();
 }
 
 /*
@@ -279,9 +311,9 @@ void WMD_DRV_Entry(OUT struct WMD_DRV_IN
 	DBC_Require(pstrWMDFileName != NULL);
 	DBG_Trace(DBG_ENTER, "In the WMD_DRV_Entry \n");
 
-       IO_SM_init(); /* Initialization of io_sm module */
+	IO_SM_init(); /* Initialization of io_sm module */
 
-       if (strcmp(pstrWMDFileName, "UMA") == 0)
+	if (strcmp(pstrWMDFileName, "UMA") == 0)
 		*ppDrvInterface = &drvInterfaceFxns;
 	else
 		DBG_Trace(DBG_LEVEL7, "WMD_DRV_Entry Unknown WMD file name");
@@ -313,29 +345,28 @@ static DSP_STATUS WMD_BRD_Monitor(struct
 
 	GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
 	HW_PWRST_IVA2RegGet(resources.dwPrmBase, &temp);
-    if ((temp & 0x03) != 0x03 || (temp & 0x03) != 0x02) {
+	if ((temp & 0x03) != 0x03 || (temp & 0x03) != 0x02) {
 		/* IVA2 is not in ON state */
 		/* Read and set PM_PWSTCTRL_IVA2  to ON */
 		HW_PWR_IVA2PowerStateSet(resources.dwPrmBase,
 					  HW_PWR_DOMAIN_DSP,
 					  HW_PWR_STATE_ON);
 		/* Set the SW supervised state transition */
-		HW_PWR_CLKCTRL_IVA2RegSet(resources.dwCmBase,
-					   HW_SW_SUP_WAKEUP);
+		HW_PWR_CLKCTRL_IVA2RegSet(resources.dwCmBase, HW_SW_SUP_WAKEUP);
 		/* Wait until the state has moved to ON */
 		HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
 				     &pwrState);
 		/* Disable Automatic transition */
-	HW_PWR_CLKCTRL_IVA2RegSet(resources.dwCmBase, HW_AUTOTRANS_DIS);
+		HW_PWR_CLKCTRL_IVA2RegSet(resources.dwCmBase, HW_AUTOTRANS_DIS);
 	}
 	DBG_Trace(DBG_LEVEL6, "WMD_BRD_Monitor - Middle ****** \n");
 	GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
-	status = run_IdleBoot(resources.dwPrmBase, resources.dwCmBase,
-			      resources.dwSysCtrlBase);
+	HW_RST_UnReset(resources.dwPrmBase, HW_RST2_IVA2);
+	CLK_Enable(SERVICESCLK_iva2_ck);
+
 	if (DSP_SUCCEEDED(status)) {
 		/* set the device state to IDLE */
 		pDevContext->dwBrdState = BRD_IDLE;
-
 	}
 error_return:
 	DBG_Trace(DBG_LEVEL6, "WMD_BRD_Monitor - End ****** \n");
@@ -437,7 +468,7 @@ static DSP_STATUS WMD_BRD_Start(struct W
 	DBG_Trace(DBG_ENTER, "Entering WMD_BRD_Start:\n hDevContext: 0x%x\n\t "
 			     "dwDSPAddr: 0x%x\n", hDevContext, dwDSPAddr);
 
-	 /* The device context contains all the mmu setup info from when the
+	/* The device context contains all the mmu setup info from when the
 	 * last dsp base image was loaded. The first entry is always
 	 * SHMMEM base. */
 	/* Get SHM_BEG - convert to byte address */
@@ -506,23 +537,23 @@ static DSP_STATUS WMD_BRD_Start(struct W
 		for (iEntryNdx = 0; iEntryNdx < WMDIOCTL_NUMOFMMUTLB;
 			iEntryNdx++) {
 			if ((pDevContext->aTLBEntry[iEntryNdx].ulGppPa != 0) &&
-                               (pDevContext->aTLBEntry[iEntryNdx].ulDspVa != 0)) {
+			   (pDevContext->aTLBEntry[iEntryNdx].ulDspVa != 0)) {
 				DBG_Trace(DBG_LEVEL4, "** (proc) MMU %d GppPa:"
-                                       " 0x%x DspVa 0x%x Size 0x%x\n",
-                                       itmpEntryNdx,
-                                       pDevContext->aTLBEntry[iEntryNdx].ulGppPa,
-                                       pDevContext->aTLBEntry[iEntryNdx].ulDspVa,
-                                       pDevContext->aTLBEntry[iEntryNdx].ulSize);
+				    " 0x%x DspVa 0x%x Size 0x%x\n",
+				    itmpEntryNdx,
+				    pDevContext->aTLBEntry[iEntryNdx].ulGppPa,
+				    pDevContext->aTLBEntry[iEntryNdx].ulDspVa,
+				    pDevContext->aTLBEntry[iEntryNdx].ulSize);
 				configureDspMmu(pDevContext,
-                                       pDevContext->aTLBEntry[iEntryNdx].ulGppPa,
-                                       pDevContext->aTLBEntry[iEntryNdx].ulDspVa *
-						DSPWORDSIZE,
-                                       pDevContext->aTLBEntry[iEntryNdx].ulSize,
-                                       itmpEntryNdx,
-                                       pDevContext->aTLBEntry[iEntryNdx].endianism,
-                                       pDevContext->aTLBEntry[iEntryNdx].elemSize,
-                                       pDevContext->aTLBEntry[iEntryNdx].
-						mixedMode);
+				    pDevContext->aTLBEntry[iEntryNdx].ulGppPa,
+				    pDevContext->aTLBEntry[iEntryNdx].ulDspVa *
+				    DSPWORDSIZE,
+				    pDevContext->aTLBEntry[iEntryNdx].ulSize,
+				    itmpEntryNdx,
+				    pDevContext->aTLBEntry[iEntryNdx].endianism,
+				    pDevContext->aTLBEntry[iEntryNdx].elemSize,
+				    pDevContext->aTLBEntry[iEntryNdx].
+				    mixedMode);
 				itmpEntryNdx++;
 			}
 		}		/* end for */
@@ -538,11 +569,10 @@ static DSP_STATUS WMD_BRD_Start(struct W
 		HW_MMU_TWLEnable(resources.dwDmmuBase);
 		/* Enable the SmartIdle and AutoIdle bit for MMU_SYSCONFIG */
 
-		temp = (u32) *((REG_UWORD32 *)
-				((u32) (resources.dwDmmuBase) + 0x10));
+
+		temp = __raw_readl((resources.dwDmmuBase) + 0x10);
 		temp = (temp & 0xFFFFFFEF) | 0x11;
-		*((REG_UWORD32 *) ((u32) (resources.dwDmmuBase) + 0x10)) =
-			(u32) temp;
+		__raw_writel(temp, (resources.dwDmmuBase) + 0x10);
 
 		/* Let the DSP MMU run */
 		HW_MMU_Enable(resources.dwDmmuBase);
@@ -564,13 +594,13 @@ static DSP_STATUS WMD_BRD_Start(struct W
 			uClkCmd = (BPWR_DisableClock << MBX_PM_CLK_CMDSHIFT) |
 						ulLoadMonitorTimer;
 			DBG_Trace(DBG_LEVEL7,
-                                       "encoded LoadMonitor cmd for Disable: 0x%x\n",
-                                       uClkCmd);
+			       "encoded LoadMonitor cmd for Disable: 0x%x\n",
+			       uClkCmd);
 			DSPPeripheralClkCtrl(pDevContext, &uClkCmd);
 
 			extClkId = uClkCmd & MBX_PM_CLK_IDMASK;
 			for (tmpIndex = 0; tmpIndex < MBX_PM_MAX_RESOURCES;
-                                       tmpIndex++) {
+				       tmpIndex++) {
 				if (extClkId == BPWR_CLKID[tmpIndex]) {
 					clkIdIndex = tmpIndex;
 					break;
@@ -638,7 +668,7 @@ static DSP_STATUS WMD_BRD_Start(struct W
 
 		} else {
 		DBG_Trace(DBG_LEVEL7,
-                               "Not able to get the symbol for BIOS Timer\n");
+			       "Not able to get the symbol for BIOS Timer\n");
 		}
 	}
 
@@ -646,12 +676,12 @@ static DSP_STATUS WMD_BRD_Start(struct W
 		/* Set the DSP clock rate */
 		(void)DEV_GetSymbol(pDevContext->hDevObject,
 					"_BRIDGEINIT_DSP_FREQ", &ulDspClkAddr);
-               /*Set Autoidle Mode for IVA2 PLL */
-               temp = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwCmBase) + 0x34));
-               temp = (temp & 0xFFFFFFFE) | 0x1;
-               *((REG_UWORD32 *) ((u32) (resources.dwCmBase) + 0x34)) =
-                       (u32) temp;
+		/*Set Autoidle Mode for IVA2 PLL */
+		temp = (u32) *((REG_UWORD32 *)
+			((u32) (resources.dwCmBase) + 0x34));
+		temp = (temp & 0xFFFFFFFE) | 0x1;
+		*((REG_UWORD32 *) ((u32) (resources.dwCmBase) + 0x34)) =
+			(u32) temp;
 		DBG_Trace(DBG_LEVEL5, "WMD_BRD_Start: _BRIDGE_DSP_FREQ Addr:"
 				"0x%x \n", ulDspClkAddr);
 		if ((unsigned int *)ulDspClkAddr != NULL) {
@@ -665,32 +695,31 @@ static DSP_STATUS WMD_BRD_Start(struct W
 				 ulDspClkAddr, sizeof(u32), 0);
 		}
 /*PM_IVA2GRPSEL_PER = 0xC0;*/
-               temp = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwPerPmBase) + 0xA8));
-               temp = (temp & 0xFFFFFF30) | 0xC0;
-               *((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8)) =
-                       (u32) temp;
+		temp = (u32) *((REG_UWORD32 *)
+			((u32) (resources.dwPerPmBase) + 0xA8));
+		temp = (temp & 0xFFFFFF30) | 0xC0;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8)) =
+			(u32) temp;
 
 /*PM_MPUGRPSEL_PER &= 0xFFFFFF3F;*/
-               temp = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwPerPmBase) + 0xA4));
-               temp = (temp & 0xFFFFFF3F);
-               *((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4)) =
-                       (u32) temp;
+		temp = (u32) *((REG_UWORD32 *)
+			((u32) (resources.dwPerPmBase) + 0xA4));
+		temp = (temp & 0xFFFFFF3F);
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4)) =
+			(u32) temp;
 /*CM_SLEEPDEP_PER |= 0x04;*/
-               temp = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwPerBase) + 0x44));
-               temp = (temp & 0xFFFFFFFB) | 0x04;
-               *((REG_UWORD32 *) ((u32) (resources.dwPerBase) + 0x44)) =
-                       (u32) temp;
+		temp = (u32) *((REG_UWORD32 *)
+			((u32) (resources.dwPerBase) + 0x44));
+		temp = (temp & 0xFFFFFFFB) | 0x04;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerBase) + 0x44)) =
+			(u32) temp;
 
 /*CM_CLKSTCTRL_IVA2 = 0x00000003 -To Allow automatic transitions*/
-               temp = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwCmBase) + 0x48));
-               temp = (temp & 0xFFFFFFFC) | 0x03;
-               *((REG_UWORD32 *) ((u32) (resources.dwCmBase) + 0x48)) =
-                       (u32) temp;
-
+		temp = (u32) *((REG_UWORD32 *)
+			((u32) (resources.dwCmBase) + 0x48));
+		temp = (temp & 0xFFFFFFFC) | 0x03;
+		*((REG_UWORD32 *) ((u32) (resources.dwCmBase) + 0x48)) =
+			(u32) temp;
 
 		/* Enable Mailbox events and also drain any pending
 		 * stale messages */
@@ -800,16 +829,9 @@ static DSP_STATUS WMD_BRD_Stop(struct WM
 
 	HW_PWRST_IVA2RegGet(resources.dwPrmBase, &dspPwrState);
 	if (dspPwrState != HW_PWR_STATE_OFF) {
-
-			CHNLSM_InterruptDSP2(pDevContext, MBX_PM_DSPIDLE);
-
-			mdelay(10);
-
-			GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
-
-		run_IdleBoot(resources.dwPrmBase, resources.dwCmBase,
-			     resources.dwSysCtrlBase);
-
+		CHNLSM_InterruptDSP2(pDevContext, MBX_PM_DSPIDLE);
+		mdelay(10);
+		GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
 		udelay(50);
 
 		clk_status = CLK_Disable(SERVICESCLK_iva2_ck);
@@ -817,15 +839,14 @@ static DSP_STATUS WMD_BRD_Stop(struct WM
 			DBG_Trace(DBG_LEVEL6,
 				 "\n WMD_BRD_Stop: CLK_Disable failed "
 				 "for iva2_fck\n");
-			}
+		}
 		/* IVA2 is not in OFF state */
 		/* Set PM_PWSTCTRL_IVA2  to OFF */
 		HW_PWR_IVA2PowerStateSet(resources.dwPrmBase,
 					  HW_PWR_DOMAIN_DSP,
 					  HW_PWR_STATE_OFF);
 		/* Set the SW supervised state transition for Sleep */
-		HW_PWR_CLKCTRL_IVA2RegSet(resources.dwCmBase,
-					   HW_SW_SUP_SLEEP);
+		HW_PWR_CLKCTRL_IVA2RegSet(resources.dwCmBase, HW_SW_SUP_SLEEP);
 	} else {
 		clk_status = CLK_Disable(SERVICESCLK_iva2_ck);
 		if (DSP_FAILED(clk_status)) {
@@ -850,8 +871,9 @@ static DSP_STATUS WMD_BRD_Stop(struct WM
 		memset((u8 *) pPtAttrs->pgInfo, 0x00,
 		       (pPtAttrs->L2NumPages * sizeof(struct PageInfo)));
 	}
-
-		DBG_Trace(DBG_LEVEL6, "WMD_BRD_Stop - End ****** \n");
+	DBG_Trace(DBG_LEVEL6, "WMD_BRD_Stop - End ****** \n");
+	HW_RST_Reset(resources.dwPrmBase, HW_RST1_IVA2);
+	HW_RST_Reset(resources.dwPrmBase, HW_RST2_IVA2);
 
 	return status;
 }
@@ -915,7 +937,10 @@ static DSP_STATUS WMD_BRD_Delete(struct
 		memset((u8 *)pPtAttrs->pgInfo, 0x00,
 			(pPtAttrs->L2NumPages * sizeof(struct PageInfo)));
 	}
-	DBG_Trace(DBG_LEVEL6, "WMD_BRD_Stop - End ****** \n");
+	DBG_Trace(DBG_LEVEL6, "WMD_BRD_Delete - End ****** \n");
+	HW_RST_Reset(resources.dwPrmBase, HW_RST1_IVA2);
+	HW_RST_Reset(resources.dwPrmBase, HW_RST2_IVA2);
+
 	return status;
 }
 
@@ -1035,33 +1060,36 @@ static DSP_STATUS WMD_DEV_Create(OUT str
 		/* we like to get aligned on L1 table size */
 		pg_tbl_va = (u32)MEM_AllocPhysMem(pPtAttrs->L1size,
 		    align_size, &pg_tbl_pa);
-	/* Check if the PA is aligned for us */
-	if ((pg_tbl_pa) & (align_size-1)) {
-                       /* PA not aligned to page table size ,
-                       * try with more allocation and align */
-                       MEM_FreePhysMem((void *)pg_tbl_va, pg_tbl_pa, pPtAttrs->L1size);
-                       /* we like to get aligned on L1 table size */
-                       pg_tbl_va = (u32) MEM_AllocPhysMem((pPtAttrs->L1size)*2,
-                       align_size, &pg_tbl_pa);
-                       /* We should be able to get aligned table now */
-                       pPtAttrs->L1TblAllocPa = pg_tbl_pa;
-                       pPtAttrs->L1TblAllocVa = pg_tbl_va;
-                       pPtAttrs->L1TblAllocSz = pPtAttrs->L1size * 2;
-                       /* Align the PA to the next 'align'  boundary */
-                       pPtAttrs->L1BasePa = ((pg_tbl_pa) + (align_size-1)) &
-				 (~(align_size-1));
-                       pPtAttrs->L1BaseVa = pg_tbl_va + (pPtAttrs->L1BasePa -
-				 pg_tbl_pa);
-	} else {
-                       /* We got aligned PA, cool */
-                       pPtAttrs->L1TblAllocPa = pg_tbl_pa;
-                       pPtAttrs->L1TblAllocVa = pg_tbl_va;
-                       pPtAttrs->L1TblAllocSz = pPtAttrs->L1size;
-                       pPtAttrs->L1BasePa = pg_tbl_pa;
-                       pPtAttrs->L1BaseVa = pg_tbl_va;
-	}
-       if (pPtAttrs->L1BaseVa)
-                       memset((u8 *)pPtAttrs->L1BaseVa, 0x00, pPtAttrs->L1size);
+
+		/* Check if the PA is aligned for us */
+		if ((pg_tbl_pa) & (align_size-1)) {
+			/* PA not aligned to page table size ,
+			 * try with more allocation and align */
+			MEM_FreePhysMem((void *)pg_tbl_va, pg_tbl_pa,
+					pPtAttrs->L1size);
+			/* we like to get aligned on L1 table size */
+			pg_tbl_va = (u32) MEM_AllocPhysMem((pPtAttrs->L1size)*2,
+					align_size, &pg_tbl_pa);
+			/* We should be able to get aligned table now */
+			pPtAttrs->L1TblAllocPa = pg_tbl_pa;
+			pPtAttrs->L1TblAllocVa = pg_tbl_va;
+			pPtAttrs->L1TblAllocSz = pPtAttrs->L1size * 2;
+			/* Align the PA to the next 'align'  boundary */
+			pPtAttrs->L1BasePa = ((pg_tbl_pa) + (align_size-1)) &
+				(~(align_size-1));
+			pPtAttrs->L1BaseVa = pg_tbl_va + (pPtAttrs->L1BasePa -
+				pg_tbl_pa);
+		} else {
+			/* We got aligned PA, cool */
+			pPtAttrs->L1TblAllocPa = pg_tbl_pa;
+			pPtAttrs->L1TblAllocVa = pg_tbl_va;
+			pPtAttrs->L1TblAllocSz = pPtAttrs->L1size;
+			pPtAttrs->L1BasePa = pg_tbl_pa;
+			pPtAttrs->L1BaseVa = pg_tbl_va;
+		}
+		if (pPtAttrs->L1BaseVa)
+			memset((u8 *)pPtAttrs->L1BaseVa, 0x00,
+				pPtAttrs->L1size);
 
 		/* number of L2 page tables = DMM pool used + SHMMEM +EXTMEM +
 		 * L4 pages */
@@ -1072,16 +1100,17 @@ static DSP_STATUS WMD_DEV_Create(OUT str
 		/* we like to get aligned on L1 table size */
 		pg_tbl_va = (u32)MEM_AllocPhysMem(pPtAttrs->L2size,
 			    align_size, &pg_tbl_pa);
-	pPtAttrs->L2TblAllocPa = pg_tbl_pa;
-	pPtAttrs->L2TblAllocVa = pg_tbl_va;
-	pPtAttrs->L2TblAllocSz = pPtAttrs->L2size;
-	pPtAttrs->L2BasePa = pg_tbl_pa;
-	pPtAttrs->L2BaseVa = pg_tbl_va;
+		pPtAttrs->L2TblAllocPa = pg_tbl_pa;
+		pPtAttrs->L2TblAllocVa = pg_tbl_va;
+		pPtAttrs->L2TblAllocSz = pPtAttrs->L2size;
+		pPtAttrs->L2BasePa = pg_tbl_pa;
+		pPtAttrs->L2BaseVa = pg_tbl_va;
+
+		if (pPtAttrs->L2BaseVa)
+			memset((u8 *)pPtAttrs->L2BaseVa, 0x00,
+				pPtAttrs->L2size);
 
-       if (pPtAttrs->L2BaseVa)
-                       memset((u8 *)pPtAttrs->L2BaseVa, 0x00, pPtAttrs->L2size);
-
-	pPtAttrs->pgInfo = MEM_Calloc(pPtAttrs->L2NumPages *
+		pPtAttrs->pgInfo = MEM_Calloc(pPtAttrs->L2NumPages *
 				sizeof(struct PageInfo), MEM_NONPAGED);
 		DBG_Trace(DBG_LEVEL1, "L1 pa %x, va %x, size %x\n L2 pa %x, va "
 			 "%x, size %x\n", pPtAttrs->L1BasePa,
@@ -1185,7 +1214,6 @@ static DSP_STATUS WMD_DEV_Ctrl(struct WM
 		/* store away dsp-mmu setup values for later use */
 		for (ndx = 0; ndx < WMDIOCTL_NUMOFMMUTLB; ndx++, paExtProc++)
 			pDevContext->aTLBEntry[ndx] = *paExtProc;
-
 		break;
 	case WMDIOCTL_DEEPSLEEP:
 	case WMDIOCTL_EMERGENCYSLEEP:
@@ -1349,11 +1377,10 @@ static DSP_STATUS WMD_BRD_MemMap(struct
 	DSP_STATUS status = DSP_SOK;
 	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
 	struct HW_MMUMapAttrs_t hwAttrs;
-	u32 numOfActualTabEntries = 0;
-	u32 *pPhysAddrPageTbl = NULL;
 	struct vm_area_struct *vma;
 	struct mm_struct *mm = current->mm;
-	u32 temp = 0;
+	u32 numUsrPgs = 0, nr_pages = 0;
+	u32 va = ulVirtAddr;
 
 	DBG_Trace(DBG_ENTER, "> WMD_BRD_MemMap hDevContext %x, pa %x, va %x, "
 		 "size %x, ulMapAttr %x\n", hDevContext, ulMpuAddr, ulVirtAddr,
@@ -1374,7 +1401,7 @@ static DSP_STATUS WMD_BRD_MemMap(struct
 		hwAttrs.endianism = HW_LITTLE_ENDIAN;
 
 	hwAttrs.mixedSize = (enum HW_MMUMixedSize_t)
-                               ((attrs & DSP_MAPMIXEDELEMSIZE) >> 2);
+			       ((attrs & DSP_MAPMIXEDELEMSIZE) >> 2);
 	/* Ignore elementSize if mixedSize is enabled */
 	if (hwAttrs.mixedSize == 0) {
 		if (attrs & DSP_MAPELEMSIZE8) {
@@ -1390,101 +1417,167 @@ static DSP_STATUS WMD_BRD_MemMap(struct
 			/* Size is 64 bit */
 			hwAttrs.elementSize = HW_ELEM_SIZE_64BIT;
 		} else {
-			/* Mixedsize isn't enabled, so size can't be
-			 * zero here */
+			/*
+			 * Mixedsize isn't enabled, so size can't be
+			 * zero here
+			 */
 			DBG_Trace(DBG_LEVEL7,
 				 "WMD_BRD_MemMap: MMU element size is zero\n");
 			return DSP_EINVALIDARG;
 		}
 	}
+	if (attrs & DSP_MAPDONOTLOCK)
+		hwAttrs.donotlockmpupage = 1;
+	else
+		hwAttrs.donotlockmpupage = 0;
+
 	if (attrs & DSP_MAPVMALLOCADDR) {
-		status = MemMapVmalloc(hDevContext, ulMpuAddr, ulVirtAddr,
-				       ulNumBytes, ulMapAttr);
-		return status;
+		return MemMapVmalloc(hDevContext, ulMpuAddr, ulVirtAddr,
+				       ulNumBytes, &hwAttrs);
 	}
-	 /* Do OS-specific user-va to pa translation.
+	/*
+	 * Do OS-specific user-va to pa translation.
 	 * Combine physically contiguous regions to reduce TLBs.
-	 * Pass the translated pa to PteUpdate.  */
+	 * Pass the translated pa to PteUpdate.
+	 */
 	if ((attrs & DSP_MAPPHYSICALADDR)) {
 		status = PteUpdate(pDevContext, ulMpuAddr, ulVirtAddr,
 			 ulNumBytes, &hwAttrs);
 		goto func_cont;
 	}
 
-	/* Important Note: ulMpuAddr is mapped from user application process
+	/*
+	 * Important Note: ulMpuAddr is mapped from user application process
 	 * to current process - it must lie completely within the current
-	 * virtual memory address space in order to be of use to us here!  */
+	 * virtual memory address space in order to be of use to us here!
+	 */
 	down_read(&mm->mmap_sem);
 	vma = find_vma(mm, ulMpuAddr);
-	up_read(&mm->mmap_sem);
 	if (vma)
 		DBG_Trace(DBG_LEVEL6, "VMAfor UserBuf: ulMpuAddr=%x, "
 			"ulNumBytes=%x, vm_start=%x vm_end=%x vm_flags=%x \n",
 			ulMpuAddr, ulNumBytes, vma->vm_start,
 			vma->vm_end, vma->vm_flags);
 
-	/* It is observed that under some circumstances, the user buffer is
+	/*
+	 * It is observed that under some circumstances, the user buffer is
 	 * spread across several VMAs. So loop through and check if the entire
-	 * user buffer is covered */
-	while ((vma != NULL) && (ulMpuAddr + ulNumBytes > vma->vm_end)) {
+	 * user buffer is covered
+	 */
+	while ((vma) && (ulMpuAddr + ulNumBytes > vma->vm_end)) {
 		/* jump to the next VMA region */
-		down_read(&mm->mmap_sem);
 		vma = find_vma(mm, vma->vm_end + 1);
-		up_read(&mm->mmap_sem);
 		DBG_Trace(DBG_LEVEL6, "VMAfor UserBuf ulMpuAddr=%x, "
-                       "ulNumBytes=%x, vm_start=%x vm_end=%x vm_flags=%x\n",
-                       ulMpuAddr, ulNumBytes, vma->vm_start,
-                       vma->vm_end, vma->vm_flags);
+		       "ulNumBytes=%x, vm_start=%x vm_end=%x vm_flags=%x\n",
+		       ulMpuAddr, ulNumBytes, vma->vm_start,
+		       vma->vm_end, vma->vm_flags);
 	}
-	if (vma == NULL) {
+	if (!vma) {
 		DBG_Trace(DBG_LEVEL7, "Failed to get the VMA region for "
 			  "MPU Buffer !!! \n");
 		status = DSP_EINVALIDARG;
-	}
-	if (DSP_FAILED(status))
+		up_read(&mm->mmap_sem);
 		goto func_cont;
-	pPhysAddrPageTbl = DMM_GetPhysicalAddrTable();
-	/* Build the array with virtual to physical translations */
-	status = TIOMAP_VirtToPhysical(mm, ulMpuAddr, ulNumBytes,
-				&numOfActualTabEntries, pPhysAddrPageTbl);
-	if (DSP_FAILED(status)) {
-		DBG_Trace(DBG_LEVEL7,
-			 "WMD_BRD_MemMap: TIOMAP_VirtToPhysical",
-			 " failed\n");
-		return DSP_EFAIL;
 	}
-	temp = 0;
-	DBG_Trace(DBG_LEVEL4, "WMD_BRD_MemMap: numOfActualTabEntries=%d, "
-		  "ulNumBytes= %d\n",  numOfActualTabEntries, ulNumBytes);
-	/* Update the DSP MMU table with the physical addresses received from
-       from translation function */
-	while (temp < numOfActualTabEntries) {
-		status = PteSet(pDevContext->pPtAttrs, pPhysAddrPageTbl[temp++],
-				ulVirtAddr, HW_PAGE_SIZE_4KB, &hwAttrs);
-		if (DSP_FAILED(status)) {
-			DBG_Trace(DBG_LEVEL7,
-				 "WMD_BRD_MemMap: FAILED IN PTESET \n");
-			return DSP_EFAIL;
+
+	numUsrPgs =  PAGE_ALIGN(ulNumBytes) / PG_SIZE_4K;
+
+	DBG_Trace(DBG_LEVEL4, "%s :numOfActualTabEntries=%d, ulNumBytes= %d\n",
+		  %s, numUsrPgs, ulNumBytes);
+
+	if (vma->vm_flags & (VM_IO | VM_PFNMAP | VM_RESERVED)) {
+		for (nr_pages = numUsrPgs; nr_pages > 0;) {
+			u32 pa;
+
+			pa = user_va2pa(mm, ulMpuAddr);
+			if (!pa) {
+				status = DSP_EFAIL;
+				pr_err("DSPBRIDGE: VM_IO mapping physical"
+				       "address is invalid\n");
+				break;
+			}
+
+			status = PteSet(pDevContext->pPtAttrs, pa,
+					va, HW_PAGE_SIZE_4KB, &hwAttrs);
+			if (DSP_FAILED(status)) {
+				DBG_Trace(DBG_LEVEL7,
+					  "WMD_BRD_MemMap: FAILED IN VM_IO"
+					  "PTESET \n");
+				break;
+			}
+
+			va += HW_PAGE_SIZE_4KB;
+			ulMpuAddr += HW_PAGE_SIZE_4KB;
+			nr_pages--;
+		}
+	} else {
+		int write = 0;
+
+		if (vma->vm_flags & (VM_WRITE | VM_MAYWRITE))
+			write = 1;
+
+		for (nr_pages = numUsrPgs; nr_pages > 0;) {
+			int i, ret;
+			struct page *pages[16]; /* for a reasonable batch */
+
+			ret = get_user_pages(current, mm, ulMpuAddr,
+					     min_t(int,  nr_pages, ARRAY_SIZE(pages)),
+					     write, 1, pages, NULL);
+			if (ret <= 0) {
+				pr_err("DSPBRIDGE: get_user_pages FAILED,"
+				       "MPU addr = 0x%x,"
+				       "vma->vm_flags = 0x%lx,"
+				       "get_user_pages ErrValue = %d,"
+				       "Buffersize=0x%x\n",
+				       ulMpuAddr, vma->vm_flags, ret,
+				       ulNumBytes);
+				status = DSP_EFAIL;
+				goto fail_mapping;
+			}
+
+			for (i = 0; i < ret; i++) {
+				struct page *page = pages[i];
+
+				status = PteSet(pDevContext->pPtAttrs,
+						page_to_phys(page), va,
+						HW_PAGE_SIZE_4KB, &hwAttrs);
+				if (DSP_FAILED(status)) {
+					pr_err("%s: FAILED IN PTESET\n",
+					       __func__);
+					goto fail_mapping;
+				}
+				SetPageMlocked(page);
+				va += HW_PAGE_SIZE_4KB;
+				ulMpuAddr += HW_PAGE_SIZE_4KB;
+				nr_pages--;
+			}
 		}
-		ulVirtAddr += HW_PAGE_SIZE_4KB;
 	}
-	if (DSP_FAILED(status))
-		DBG_Trace(DBG_LEVEL5, "WMD_BRD_MemMap: PteSet failed \n");
-	else
-		DBG_Trace(DBG_LEVEL5, "WMD_BRD_MemMap: PteSet passed \n");
 
+fail_mapping:
+	up_read(&mm->mmap_sem);
 func_cont:
 	/* Don't propogate Linux or HW status to upper layers */
 	if (DSP_SUCCEEDED(status)) {
 		status = DSP_SOK;
 	} else {
 		DBG_Trace(DBG_LEVEL7, "< WMD_BRD_MemMap status %x\n", status);
+		/*
+		 * Roll out the mapped pages incase it failed in middle of
+		 * mapping
+		 */
+		if (numUsrPgs - nr_pages) {
+			WMD_BRD_MemUnMap(pDevContext, ulVirtAddr,
+					 ((numUsrPgs - nr_pages) * PG_SIZE_4K));
+		}
 		status = DSP_EFAIL;
 	}
-	 /* In any case, flush the TLB
+	/*
+	 * In any case, flush the TLB
 	 * This is called from here instead from PteUpdate to avoid unnecessary
 	 * repetition while mapping non-contiguous physical regions of a virtual
-	 * region */
+	 * region
+	 */
 	flush_all(pDevContext);
 	DBG_Trace(DBG_ENTER, "< WMD_BRD_MemMap status %x\n", status);
 	return status;
@@ -1513,9 +1606,13 @@ static DSP_STATUS WMD_BRD_MemUnMap(struc
 	u32 remBytes;
 	u32 remBytesL2;
 	u32 vaCurr;
+	struct page *pg = NULL;
 	DSP_STATUS status = DSP_SOK;
 	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
 	struct PgTableAttrs *pt = pDevContext->pPtAttrs;
+	u32 temp;
+	u32 pAddr;
+	u32 numof4KPages = 0;
 
 	DBG_Trace(DBG_ENTER, "> WMD_BRD_MemUnMap hDevContext %x, va %x, "
 		  "NumBytes %x\n", hDevContext, ulVirtAddr, ulNumBytes);
@@ -1533,98 +1630,154 @@ static DSP_STATUS WMD_BRD_MemUnMap(struc
 		pteAddrL1 = HW_MMU_PteAddrL1(L1BaseVa, vaCurr);
 		pteVal = *(u32 *)pteAddrL1;
 		pteSize = HW_MMU_PteSizeL1(pteVal);
-		if (pteSize == HW_MMU_COARSE_PAGE_SIZE) {
-			/* Get the L2 PA from the L1 PTE, and find
-			 * corresponding L2 VA */
-			L2BasePa = HW_MMU_PteCoarseL1(pteVal);
-			L2BaseVa = L2BasePa - pt->L2BasePa + pt->L2BaseVa;
-			L2PageNum = (L2BasePa - pt->L2BasePa) /
-				    HW_MMU_COARSE_PAGE_SIZE;
-			 /* Find the L2 PTE address from which we will start
-			 * clearing, the number of PTEs to be cleared on this
-			 * page, and the size of VA space that needs to be
-			 * cleared on this L2 page */
-			pteAddrL2 = HW_MMU_PteAddrL2(L2BaseVa, vaCurr);
-			pteCount = pteAddrL2 & (HW_MMU_COARSE_PAGE_SIZE - 1);
-			pteCount = (HW_MMU_COARSE_PAGE_SIZE - pteCount) /
-				    sizeof(u32);
-			if (remBytes < (pteCount * PG_SIZE_4K))
-				pteCount = remBytes / PG_SIZE_4K;
-
-			remBytesL2 = pteCount * PG_SIZE_4K;
-			DBG_Trace(DBG_LEVEL1, "WMD_BRD_MemUnMap L2BasePa %x, "
-				  "L2BaseVa %x pteAddrL2 %x, remBytesL2 %x\n",
-				  L2BasePa, L2BaseVa, pteAddrL2, remBytesL2);
-			 /* Unmap the VA space on this L2 PT. A quicker way
-			 * would be to clear pteCount entries starting from
-			 * pteAddrL2. However, below code checks that we don't
-			 * clear invalid entries or less than 64KB for a 64KB
-			 * entry. Similar checking is done for L1 PTEs too
-			 * below */
-			while (remBytesL2 && (DSP_SUCCEEDED(status))) {
-				pteVal = *(u32 *)pteAddrL2;
-				pteSize = HW_MMU_PteSizeL2(pteVal);
-				/* vaCurr aligned to pteSize? */
-				if ((pteSize != 0) && (remBytesL2 >= pteSize) &&
-				   !(vaCurr & (pteSize - 1))) {
-					if (HW_MMU_PteClear(pteAddrL2,
-						vaCurr, pteSize) == RET_OK) {
-						status = DSP_SOK;
-						remBytesL2 -= pteSize;
-						vaCurr += pteSize;
-						pteAddrL2 += (pteSize >> 12) *
-								sizeof(u32);
-					} else {
-						status = DSP_EFAIL;
-						goto EXIT_LOOP;
-					}
-				} else {
-					status = DSP_EFAIL;
-				}
+
+		if (pteSize != HW_MMU_COARSE_PAGE_SIZE)
+			goto skip_coarse_page;
+
+		/*
+		 * Get the L2 PA from the L1 PTE, and find
+		 * corresponding L2 VA
+		 */
+		L2BasePa = HW_MMU_PteCoarseL1(pteVal);
+		L2BaseVa = L2BasePa - pt->L2BasePa + pt->L2BaseVa;
+		L2PageNum = (L2BasePa - pt->L2BasePa) / HW_MMU_COARSE_PAGE_SIZE;
+		/*
+		 * Find the L2 PTE address from which we will start
+		 * clearing, the number of PTEs to be cleared on this
+		 * page, and the size of VA space that needs to be
+		 * cleared on this L2 page
+		 */
+		pteAddrL2 = HW_MMU_PteAddrL2(L2BaseVa, vaCurr);
+		pteCount = pteAddrL2 & (HW_MMU_COARSE_PAGE_SIZE - 1);
+		pteCount = (HW_MMU_COARSE_PAGE_SIZE - pteCount) / sizeof(u32);
+		if (remBytes < (pteCount * PG_SIZE_4K))
+			pteCount = remBytes / PG_SIZE_4K;
+		remBytesL2 = pteCount * PG_SIZE_4K;
+		DBG_Trace(DBG_LEVEL1, "WMD_BRD_MemUnMap L2BasePa %x, "
+			  "L2BaseVa %x pteAddrL2 %x, remBytesL2 %x\n",
+			  L2BasePa, L2BaseVa, pteAddrL2, remBytesL2);
+		/*
+		 * Unmap the VA space on this L2 PT. A quicker way
+		 * would be to clear pteCount entries starting from
+		 * pteAddrL2. However, below code checks that we don't
+		 * clear invalid entries or less than 64KB for a 64KB
+		 * entry. Similar checking is done for L1 PTEs too
+		 * below
+		 */
+		while (remBytesL2 && (DSP_SUCCEEDED(status))) {
+			pteVal = *(u32 *)pteAddrL2;
+			pteSize = HW_MMU_PteSizeL2(pteVal);
+			/* vaCurr aligned to pteSize? */
+			if (pteSize == 0 || remBytesL2 < pteSize ||
+						vaCurr & (pteSize - 1)) {
+				status = DSP_EFAIL;
+				break;
 			}
-			SYNC_EnterCS(pt->hCSObj);
-			if (remBytesL2 == 0) {
-				pt->pgInfo[L2PageNum].numEntries -= pteCount;
-				if (pt->pgInfo[L2PageNum].numEntries == 0) {
-					/* Clear the L1 PTE pointing to the
-					 * L2 PT */
-					if (RET_OK == HW_MMU_PteClear(L1BaseVa,
-					vaCurrOrig, HW_MMU_COARSE_PAGE_SIZE))
-						status = DSP_SOK;
-					else {
-						status = DSP_EFAIL;
-						goto EXIT_LOOP;
-					}
+
+			/* Collect Physical addresses from VA */
+			pAddr = (pteVal & ~(pteSize - 1));
+			if (pteSize == HW_PAGE_SIZE_64KB)
+				numof4KPages = 16;
+			else
+				numof4KPages = 1;
+			temp = 0;
+			while (temp++ < numof4KPages) {
+				if (!pfn_valid(__phys_to_pfn(pAddr))) {
+					pAddr += HW_PAGE_SIZE_4KB;
+					continue;
 				}
-				remBytes -= pteCount * PG_SIZE_4K;
-			} else {
+				pg = phys_to_page(pAddr);
+				if (page_count(pg) < 1) {
+					pr_info("DSPBRIDGE: UNMAP function: "
+						"COUNT 0 FOR PA 0x%x, size = "
+						"0x%x\n", pAddr, ulNumBytes);
+					bad_page_dump(pAddr, pg);
+				}
+				ClearPageMlocked(pg);
+				SetPageDirty(pg);
+				page_cache_release(pg);
+				pAddr += HW_PAGE_SIZE_4KB;
+			}
+			if (HW_MMU_PteClear(pteAddrL2, vaCurr, pteSize)
+							 == RET_FAIL) {
 				status = DSP_EFAIL;
+				goto EXIT_LOOP;
 			}
-			DBG_Trace(DBG_LEVEL1, "WMD_BRD_MemUnMap L2PageNum %x, "
-				  "numEntries %x, pteCount %x, status: 0x%x\n",
-				  L2PageNum, pt->pgInfo[L2PageNum].numEntries,
-				  pteCount, status);
-			SYNC_LeaveCS(pt->hCSObj);
-		} else
-			/* vaCurr aligned to pteSize? */
-			/* pteSize = 1 MB or 16 MB */
-			if ((pteSize != 0) && (remBytes >= pteSize) &&
-			   !(vaCurr & (pteSize - 1))) {
-				if (HW_MMU_PteClear(L1BaseVa,
-					vaCurr, pteSize) == RET_OK) {
+
+			status = DSP_SOK;
+			remBytesL2 -= pteSize;
+			vaCurr += pteSize;
+			pteAddrL2 += (pteSize >> 12) * sizeof(u32);
+		}
+		SYNC_EnterCS(pt->hCSObj);
+		if (remBytesL2 == 0) {
+			pt->pgInfo[L2PageNum].numEntries -= pteCount;
+			if (pt->pgInfo[L2PageNum].numEntries == 0) {
+				/*
+				 * Clear the L1 PTE pointing to the L2 PT
+				 */
+				if (HW_MMU_PteClear(L1BaseVa, vaCurrOrig,
+					    HW_MMU_COARSE_PAGE_SIZE) == RET_OK)
 					status = DSP_SOK;
-					remBytes -= pteSize;
-					vaCurr += pteSize;
-				} else {
+				else {
 					status = DSP_EFAIL;
+					SYNC_LeaveCS(pt->hCSObj);
 					goto EXIT_LOOP;
 				}
+			}
+			remBytes -= pteCount * PG_SIZE_4K;
+		} else
+			status = DSP_EFAIL;
+		DBG_Trace(DBG_LEVEL1, "WMD_BRD_MemUnMap L2PageNum %x, "
+			  "numEntries %x, pteCount %x, status: 0x%x\n",
+			  L2PageNum, pt->pgInfo[L2PageNum].numEntries,
+			  pteCount, status);
+		SYNC_LeaveCS(pt->hCSObj);
+		continue;
+skip_coarse_page:
+		/* vaCurr aligned to pteSize? */
+		/* pteSize = 1 MB or 16 MB */
+		if (pteSize == 0 || remBytes < pteSize ||
+						 vaCurr & (pteSize - 1)) {
+			status = DSP_EFAIL;
+			break;
+		}
+
+		if (pteSize == HW_PAGE_SIZE_1MB)
+			numof4KPages = 256;
+		else
+			numof4KPages = 4096;
+		temp = 0;
+		/* Collect Physical addresses from VA */
+		pAddr = (pteVal & ~(pteSize - 1));
+		while (temp++ < numof4KPages) {
+			if (pfn_valid(__phys_to_pfn(pAddr))) {
+				pg = phys_to_page(pAddr);
+				if (page_count(pg) < 1) {
+					pr_info("DSPBRIDGE: UNMAP function: "
+						"COUNT 0 FOR PA 0x%x, size = "
+						"0x%x\n", pAddr, ulNumBytes);
+					bad_page_dump(pAddr, pg);
+				}
+				ClearPageMlocked(pg);
+				SetPageDirty(pg);
+				page_cache_release(pg);
+			}
+			pAddr += HW_PAGE_SIZE_4KB;
+		}
+		if (HW_MMU_PteClear(L1BaseVa, vaCurr, pteSize) == RET_OK) {
+			status = DSP_SOK;
+			remBytes -= pteSize;
+			vaCurr += pteSize;
 		} else {
 			status = DSP_EFAIL;
+			goto EXIT_LOOP;
 		}
 	}
-	 /* It is better to flush the TLB here, so that any stale old entries
-	 * get flushed */
+	/*
+	 * It is better to flush the TLB here, so that any stale old entries
+	 * get flushed
+	 */
 EXIT_LOOP:
 	flush_all(pDevContext);
 	DBG_Trace(DBG_LEVEL1, "WMD_BRD_MemUnMap vaCurr %x, pteAddrL1 %x "
@@ -1633,240 +1786,36 @@ EXIT_LOOP:
 		  "remBytesL2 %x\n", status, remBytes, remBytesL2);
 	return status;
 }
+
 /*
- * ========= TIOMAP_VirtToPhysical ==========
- * Purpose:
- * 		This function builds the array with virtual to physical
- *	    address translation
- */
-static DSP_STATUS TIOMAP_VirtToPhysical(struct mm_struct *mm, u32 ulMpuAddr,
-					u32 ulNumBytes,
-					u32 *numOfTableEntries,
-					u32 *physicalAddrTable)
+ *  ======== user_va2pa ========
+ *  Purpose:
+ *      This function walks through the Linux page tables to convert a userland
+ *      virtual address to physical address
+ */
+static u32 user_va2pa(struct mm_struct *mm, u32 address)
 {
-	u32 pAddr;
-	u32 chunkSz;
-	DSP_STATUS status = DSP_SOK;
-	volatile u32 pteVal;
-	u32 pteSize;
 	pgd_t *pgd;
 	pmd_t *pmd;
-	volatile pte_t *ptep;
-	u32 numEntries = 0;
-	u32 numof4KPages = 0;
-	u32 phyEntryCounter = 0;
-	u32 temp = 0;
-	u32 numUsrPgs;
-	struct task_struct *curr_task = current;
+	pte_t *ptep, pte;
 
-	DBG_Trace(DBG_ENTER, "TIOMAP_VirtToPhysical: START:ulMpuAddr=%x, "
-		  "ulNumBytes=%x\n", ulMpuAddr, ulNumBytes);
-	if (physicalAddrTable == NULL)
-		return DSP_EMEMORY;
-	while (ulNumBytes) {
-		DBG_Trace(DBG_LEVEL4, "TIOMAP_VirtToPhysical:Read the next PGD "
-			  "and PMD entry\n");
-		numEntries = 0;
-		/* Get the first level page table entry information */
-		/* Read the pointer to first level page table entry */
-		pgd = pgd_offset(mm, ulMpuAddr);
-		/* Read the value in the first level page table entry */
-		pteVal = *(u32 *)pgd;
-		/* Find the page size that is pointed by the first level page
-		 * table entry */
-		pteSize = HW_MMU_PteSizeL1(pteVal); /* update 16 or 1 */
-		/* If pteSize is zero, then call the get_user_pages to create
-		 * the page table entries for this buffer
-		 */
-		if (!pteSize) {
-			down_read(&mm->mmap_sem);
-			/* This call invokes handle_mmu _fault call, which
-			 *causes all pages to be created before we scan the
-			 * page tables
-			 */
-			numUsrPgs = get_user_pages(curr_task, mm, ulMpuAddr, 1,
-							true, 0, NULL, NULL);
-			up_read(&mm->mmap_sem);
-			/* Get the first level page table entry information */
-			/* Read the pointer to first level page table entry */
-			pgd = pgd_offset(mm, ulMpuAddr);
-			/* Read the value in the first level page table entry*/
-			pteVal = *(u32 *)pgd;
-			/* Find the page size that is pointed by the first level
-			 * page table entry
-			 */
-			pteSize = HW_MMU_PteSizeL1(pteVal);
-			DBG_Trace(DBG_LEVEL4, "First level  get_user_pages "
-							"called\n");
-		}
-		/* If the page size is 4K or 64K, then we have to traverse to
-		 * second level page table */
-		if (pteSize == HW_MMU_COARSE_PAGE_SIZE) {
-			DBG_Trace(DBG_LEVEL5, "Read the next PMD entry\n");
-			/* Get the second level page table information */
-			pmd = pmd_offset(pgd, ulMpuAddr);
-			ptep = pte_offset_map(pmd, ulMpuAddr);
-			do {
-				ptep = ptep+numEntries;
-				/* Read the value of second level page table
-				 * entry */
-				pteVal = *(u32 *)ptep;
-				/* Find the size of page the second level
-				 * table entry is pointing */
-				/* update 64 or 4 */
-				pteSize = HW_MMU_PteSizeL2(pteVal);
-				/* If pteSize is invalid, then call
-				 * get_user_pages to create the
-				 * page table entries
-				 */
-				if (!pteSize) {
-					numUsrPgs =
-						(ulNumBytes/HW_PAGE_SIZE_4KB);
-					down_read(&mm->mmap_sem);
-					/* This call invokes
-					 *handle_mmu _fault call, which causes
-					 *all pages to be created before we scan
-					 * the page tables */
-					if (numUsrPgs <= PAGES_II_LVL_TABLE) {
-						get_user_pages(curr_task, mm,
-						ulMpuAddr, numUsrPgs, true,  0,
-						NULL, NULL);
-						DBG_Trace(DBG_LEVEL4,
-						"get_user_pages, numUsrPgs"
-						"= %d\n", numUsrPgs);
-					} else {
-						get_user_pages(curr_task, mm,
-						ulMpuAddr, PAGES_II_LVL_TABLE,
-						true, 0, NULL, NULL);
-						DBG_Trace(DBG_LEVEL4,
-						"get_user_pages, numUsrPgs"
-						"= %d\n", PAGES_II_LVL_TABLE);
-					}
-					up_read(&mm->mmap_sem);
-					/* Read the value of second level page
-					 * table  entry */
-					pteVal = *(u32 *)ptep;
-					/* Find the size of page the second
-					 * level table entry is pointing */
-					pteSize = HW_MMU_PteSizeL2(pteVal);
-				}
-				DBG_Trace(DBG_LEVEL4, "TIOMAP_VirtToPhysical:"
-					"*pmd=%x, *pgd=%x, ptep = %x, pteVal="
-					" %x, pteSize=%x\n", *pmd,
-					*(u32 *)pgd, (u32)ptep, pteVal,
-					pteSize);
-
-				/* Extract the physical Addresses */
-				switch (pteSize) {
-				case HW_PAGE_SIZE_64KB:
-					pAddr = pteVal & MMU_LARGE_PAGE_MASK;
-					chunkSz = HW_PAGE_SIZE_64KB;
-					numEntries = 16;
-					numof4KPages = 16;
-					break;
-				case HW_PAGE_SIZE_4KB:
-					pAddr = pteVal & MMU_SMALL_PAGE_MASK;
-					chunkSz = HW_PAGE_SIZE_4KB;
-					numEntries = 1;
-					numof4KPages = 1;
-					break;
-				default:
-					DBG_Trace(DBG_LEVEL7,
-						"TIOMAP_VirtToPhysical:"
-						"Descriptor"
-						"Format Fault-II level,"
-						" PTE size = %x\n",
-						pteSize);
-					return DSP_EFAIL;
-				}
-				temp = 0;
-				while (temp++ < numof4KPages) {
-					physicalAddrTable[phyEntryCounter++] =
-									pAddr;
-					DBG_Trace(DBG_LEVEL4,
-						 "TIOMAP_VirtToPhysical:"
-						 "physicalAddrTable[%d]= %x\n",
-						 (phyEntryCounter-1), pAddr);
-					pAddr += HW_PAGE_SIZE_4KB;
-				}
-				if (DSP_SUCCEEDED(status)) {
-					/* Go to the next page */
-					ulMpuAddr += chunkSz;
-					/* Update the number of bytes that
-					 * are copied */
-					ulNumBytes -= chunkSz;
-					DBG_Trace(DBG_LEVEL4,
-						"TIOMAP_VirtToPhysical: mpuCurr"
-						" = %x, pagesize = %x, "
-						"numBytesRem=%x\n",
-						ulMpuAddr, chunkSz, ulNumBytes);
-				} else {
-					DBG_Trace(DBG_LEVEL7,
-					     " TIOMAP_VirtToPhysical:PTEupdate"
-					     "failed\n");
-				}
-			/* It is observed that the pgd value (first level page
-			 * table entry) is changed after reading the 512
-			 * entries in second level table. So, call the pgd
-			 * functions after reaching 512 entries in second
-			 * level table */
-			} while ((ulMpuAddr & 0x001ff000) && (ulNumBytes));
-		} else {
-			/* Extract the Address to update the IVA MMU table
-			 * with */
-			switch (pteSize) {
-			case HW_PAGE_SIZE_16MB:
-				pAddr = pteVal & MMU_SSECTION_ADDR_MASK;
-					chunkSz = HW_PAGE_SIZE_16MB;
-					numEntries = 16;
-					numof4KPages = 4096;
-					break;
-			case HW_PAGE_SIZE_1MB:
-				pAddr = pteVal & MMU_SECTION_ADDR_MASK;
-					chunkSz = HW_PAGE_SIZE_1MB;
-					numEntries = 1;
-					numof4KPages = 256;
-					break;
-			default:
-				DBG_Trace(DBG_LEVEL7,
-				     "TIOMAP_VirtToPhysical:Descriptor"
-				     "Format Faul-I level, PTE size = "
-				     "%x\n", pteSize);
-				return DSP_EFAIL;
-			}
-			temp = 0;
-			while (temp++ < numof4KPages) {
-					physicalAddrTable[phyEntryCounter++] =
-									 pAddr;
-					DBG_Trace(DBG_LEVEL4,
-						 "TIOMAP_VirtToPhysical:"
-						 "physicalAddrTable[%d]= %x\n",
-						 (phyEntryCounter-1), pAddr);
-					pAddr += HW_PAGE_SIZE_4KB;
-			}
-			if (DSP_SUCCEEDED(status)) {
-				/* Go to the next page */
-				ulMpuAddr += chunkSz;
-				/* Update the number of bytes that are copied */
-				ulNumBytes -= chunkSz;
-				DBG_Trace(DBG_LEVEL4,
-					 "TIOMAP_VirtToPhysical: mpuCurr = %x, "
-					 "pagesize = %x, numBytesRem=%x\n",
-					 ulMpuAddr, chunkSz, ulNumBytes);
-			} else {
-				DBG_Trace(DBG_LEVEL7,
-					 " TIOMAP_VirtToPhysical:PTEupdate"
-					 "failed\n");
+	pgd = pgd_offset(mm, address);
+	if (!(pgd_none(*pgd) || pgd_bad(*pgd))) {
+		pmd = pmd_offset(pgd, address);
+		if (!(pmd_none(*pmd) || pmd_bad(*pmd))) {
+			ptep = pte_offset_map(pmd, address);
+			if (ptep) {
+				pte = *ptep;
+				if (pte_present(pte))
+					return pte & PAGE_MASK;
 			}
-
 		}
 	}
-	*numOfTableEntries = phyEntryCounter;
-	DBG_Trace(DBG_LEVEL4, " TIOMAP_VirtToPhysical:numofTableEntries=%d\n",
-		  phyEntryCounter);
-	return status;
+
+	return 0;
 }
 
+
 /*
  *  ======== PteUpdate ========
  *      This function calculates the optimum page-aligned addresses and sizes
@@ -1928,7 +1877,7 @@ static DSP_STATUS PteSet(struct PgTableA
 	u32 pteSize;
 	u32 pgTblVa;      /* Base address of the PT that will be updated */
 	u32 L1BaseVa;
-	 /* Compiler warns that the next three variables might be used
+	/* Compiler warns that the next three variables might be used
 	 * uninitialized in this function. Doesn't seem so. Working around,
 	 * anyways.  */
 	u32 L2BaseVa = 0;
@@ -1987,7 +1936,6 @@ static DSP_STATUS PteSet(struct PgTableA
 				pt->pgInfo[L2PageNum].numEntries += 16;
 			else
 				pt->pgInfo[L2PageNum].numEntries++;
-
 			DBG_Trace(DBG_LEVEL1, "L2 BaseVa %x, BasePa %x, "
 				 "PageNum %x numEntries %x\n", L2BaseVa,
 				 L2BasePa, L2PageNum,
@@ -2008,14 +1956,11 @@ static DSP_STATUS PteSet(struct PgTableA
 }
 
 /* Memory map kernel VA -- memory allocated with vmalloc */
-static DSP_STATUS MemMapVmalloc(struct WMD_DEV_CONTEXT *hDevContext,
-				u32 ulMpuAddr, u32 ulVirtAddr,
-				u32 ulNumBytes, u32 ulMapAttr)
+static DSP_STATUS MemMapVmalloc(struct WMD_DEV_CONTEXT *pDevContext,
+				u32 ulMpuAddr, u32 ulVirtAddr, u32 ulNumBytes,
+				struct HW_MMUMapAttrs_t *hwAttrs)
 {
-	u32 attrs = ulMapAttr;
 	DSP_STATUS status = DSP_SOK;
-	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
-	struct HW_MMUMapAttrs_t hwAttrs;
 	struct page *pPage[1];
 	u32 i;
 	u32 paCurr;
@@ -2023,59 +1968,35 @@ static DSP_STATUS MemMapVmalloc(struct W
 	u32 vaCurr;
 	u32 sizeCurr;
 	u32 numPages;
+	u32 pa;
+	u32 numOf4KPages;
+	u32 temp = 0;
 
 	DBG_Trace(DBG_ENTER, "> MemMapVmalloc hDevContext %x, pa %x, va %x, "
-		  "size %x, ulMapAttr %x\n", hDevContext, ulMpuAddr,
-		  ulVirtAddr, ulNumBytes, ulMapAttr);
-	/* Take mapping properties */
-	if (attrs & DSP_MAPBIGENDIAN)
-		hwAttrs.endianism = HW_BIG_ENDIAN;
-	else
-		hwAttrs.endianism = HW_LITTLE_ENDIAN;
+		  "size %x\n", pDevContext, ulMpuAddr, ulVirtAddr, ulNumBytes);
 
-	hwAttrs.mixedSize = (enum HW_MMUMixedSize_t)
-			     ((attrs & DSP_MAPMIXEDELEMSIZE) >> 2);
-	/* Ignore elementSize if mixedSize is enabled */
-	if (hwAttrs.mixedSize == 0) {
-		if (attrs & DSP_MAPELEMSIZE8) {
-			/* Size is 8 bit */
-			hwAttrs.elementSize = HW_ELEM_SIZE_8BIT;
-		} else if (attrs & DSP_MAPELEMSIZE16) {
-			/* Size is 16 bit */
-			hwAttrs.elementSize = HW_ELEM_SIZE_16BIT;
-		} else if (attrs & DSP_MAPELEMSIZE32) {
-			/* Size is 32 bit */
-			hwAttrs.elementSize = HW_ELEM_SIZE_32BIT;
-		} else if (attrs & DSP_MAPELEMSIZE64) {
-			/* Size is 64 bit */
-			hwAttrs.elementSize = HW_ELEM_SIZE_64BIT;
-		} else {
-			/* Mixedsize isn't enabled, so size can't be zero
-			 * here */
-			DBG_Trace(DBG_LEVEL7, "WMD_BRD_MemMap: MMU element "
-				 "size is zero\n");
-			return DSP_EINVALIDARG;
-		}
-	}
-	 /* Do Kernel va to pa translation.
+	/*
+	 * Do Kernel va to pa translation.
 	 * Combine physically contiguous regions to reduce TLBs.
-	 * Pass the translated pa to PteUpdate.  */
+	 * Pass the translated pa to PteUpdate.
+	 */
 	numPages = ulNumBytes / PAGE_SIZE; /* PAGE_SIZE = OS page size */
-	if (DSP_FAILED(status))
-		goto func_cont;
-
 	i = 0;
 	vaCurr = ulMpuAddr;
 	pPage[0] = vmalloc_to_page((void *)vaCurr);
 	paNext = page_to_phys(pPage[0]);
 	while (DSP_SUCCEEDED(status) && (i < numPages)) {
-		/* Reuse paNext from the previous iteraion to avoid
-		 * an extra va2pa call */
+		/*
+		 * Reuse paNext from the previous iteraion to avoid
+		 * an extra va2pa call
+		 */
 		paCurr = paNext;
 		sizeCurr = PAGE_SIZE;
-		/* If the next page is physically contiguous,
+		/*
+		 * If the next page is physically contiguous,
 		 * map it with the current one by increasing
-		 * the size of the region to be mapped */
+		 * the size of the region to be mapped
+		 */
 		while (++i < numPages) {
 			pPage[0] = vmalloc_to_page((void *)(vaCurr + sizeCurr));
 			paNext = page_to_phys(pPage[0]);
@@ -2091,11 +2012,16 @@ static DSP_STATUS MemMapVmalloc(struct W
 			status = DSP_EMEMORY;
 			break;
 		}
+		pa = paCurr;
+		numOf4KPages = sizeCurr / HW_PAGE_SIZE_4KB;
+		while (temp++ < numOf4KPages) {
+			get_page(phys_to_page(pa));
+			pa += HW_PAGE_SIZE_4KB;
+		}
 		status = PteUpdate(pDevContext, paCurr, ulVirtAddr +
-				  (vaCurr - ulMpuAddr), sizeCurr, &hwAttrs);
+				  (vaCurr - ulMpuAddr), sizeCurr, hwAttrs);
 		vaCurr += sizeCurr;
 	}
-func_cont:
 	/* Don't propogate Linux or HW status to upper layers */
 	if (DSP_SUCCEEDED(status)) {
 		status = DSP_SOK;
@@ -2105,97 +2031,17 @@ func_cont:
 		DBG_Trace(DBG_LEVEL7, "< WMD_BRD_MemMap status %x\n", status);
 		status = DSP_EFAIL;
 	}
-	 /* In any case, flush the TLB
+	/*
+	 * In any case, flush the TLB
 	 * This is called from here instead from PteUpdate to avoid unnecessary
 	 * repetition while mapping non-contiguous physical regions of a virtual
-	 * region */
+	 * region
+	 */
 	flush_all(pDevContext);
-	DBG_Trace(DBG_LEVEL7, "< WMD_BRD_MemMap  at end status %x\n", status);
+	DBG_Trace(DBG_LEVEL7, "< WMD_BRD_MemMap at end status %x\n", status);
 	return status;
 }
 
-static DSP_STATUS run_IdleBoot(u32 prm_base, u32 cm_base,
-			       u32 sysctrl_base)
-{
-	u32 temp;
-	DSP_STATUS status = DSP_SOK;
-	DSP_STATUS clk_status = DSP_SOK;
-	enum HW_PwrState_t    pwrState;
-
-	/* Read PM_PWSTST_IVA2 */
-	HW_PWRST_IVA2RegGet(prm_base, &temp);
-	 if ((temp & 0x03) != 0x03 || (temp & 0x03) != 0x02) {
-		/* IVA2 is not in ON state */
-		/* Set PM_PWSTCTRL_IVA2  to ON */
-		HW_PWR_IVA2PowerStateSet(prm_base, HW_PWR_DOMAIN_DSP,
-					  HW_PWR_STATE_ON);
-		/* Set the SW supervised state transition */
-		HW_PWR_CLKCTRL_IVA2RegSet(cm_base, HW_SW_SUP_WAKEUP);
-		/* Wait until the state has moved to ON */
-		HW_PWR_IVA2StateGet(prm_base, HW_PWR_DOMAIN_DSP, &pwrState);
-	}
-	clk_status = CLK_Disable(SERVICESCLK_iva2_ck);
-	if (DSP_FAILED(clk_status)) {
-		DBG_Trace(DBG_LEVEL6, "CLK_Disbale failed for clk = 0x%x \n",
-			  SERVICESCLK_iva2_ck);
-	}
-	udelay(10);
-	/* Assert IVA2-RST1 and IVA2-RST2  */
-	*((REG_UWORD32 *)((u32)(prm_base) + 0x50)) = (u32)0x07;
-	udelay(30);
-	/* set the SYSC for Idle Boot */
-	*((REG_UWORD32 *)((u32)(sysctrl_base) + 0x404)) = (u32)0x01;
-               temp = (u32) *((REG_UWORD32 *)
-                               ((u32) (cm_base) + 0x34));
-               temp = (temp & 0xFFFFFFFE) | 0x1;
-               *((REG_UWORD32 *) ((u32) (cm_base) + 0x34)) =
-                       (u32) temp;
-               temp = (u32) *((REG_UWORD32 *)
-                       ((u32) (cm_base) + 0x4));
-               temp =  (temp & 0xFFFFFC8) | 0x37;
-               *((REG_UWORD32 *) ((u32) (cm_base) + 0x4)) =
-                       (u32) temp;
-	clk_status = CLK_Enable(SERVICESCLK_iva2_ck);
-	if (DSP_FAILED(clk_status)) {
-		DBG_Trace(DBG_LEVEL6, "CLK_Enable failed for clk = 0x%x \n",
-			  SERVICESCLK_iva2_ck);
-	}
-	udelay(20);
-	GetHWRegs(prm_base, cm_base);
-	/* Release Reset1 and Reset2 */
-	*((REG_UWORD32 *)((u32)(prm_base) + 0x50)) = (u32)0x05;
-	udelay(20);
-	*((REG_UWORD32 *)((u32)(prm_base) + 0x50)) = (u32)0x04;
-	udelay(30);
-	return status;
-}
-
-
-void GetHWRegs(u32 prm_base, u32 cm_base)
-{
-	u32 temp;
-       temp = (u32)*((REG_UWORD32 *)((u32)(cm_base) + 0x00));
-	   DBG_Trace(DBG_LEVEL6, "CM_FCLKEN_IVA2 = 0x%x \n", temp);
-       temp = (u32)*((REG_UWORD32 *)((u32)(cm_base) + 0x10));
-	   DBG_Trace(DBG_LEVEL6, "CM_ICLKEN1_IVA2 = 0x%x \n", temp);
-       temp = (u32)*((REG_UWORD32 *)((u32)(cm_base) + 0x20));
-	   DBG_Trace(DBG_LEVEL6, "CM_IDLEST_IVA2 = 0x%x \n", temp);
-       temp = (u32)*((REG_UWORD32 *)((u32)(cm_base) + 0x48));
-	   DBG_Trace(DBG_LEVEL6, "CM_CLKSTCTRL_IVA2 = 0x%x \n", temp);
-       temp = (u32)*((REG_UWORD32 *)((u32)(cm_base) + 0x4c));
-	   DBG_Trace(DBG_LEVEL6, "CM_CLKSTST_IVA2 = 0x%x \n", temp);
-       temp = (u32)*((REG_UWORD32 *)((u32)(prm_base) + 0x50));
-	   DBG_Trace(DBG_LEVEL6, "RM_RSTCTRL_IVA2 = 0x%x \n", temp);
-       temp = (u32)*((REG_UWORD32 *)((u32)(prm_base) + 0x58));
-	   DBG_Trace(DBG_LEVEL6, "RM_RSTST_IVA2 = 0x%x \n", temp);
-       temp = (u32)*((REG_UWORD32 *)((u32)(prm_base) + 0xE0));
-	   DBG_Trace(DBG_LEVEL6, "PM_PWSTCTRL_IVA2 = 0x%x \n", temp);
-       temp = (u32)*((REG_UWORD32 *)((u32)(prm_base) + 0xE4));
-	   DBG_Trace(DBG_LEVEL6, "PM_PWSTST_IVA2 = 0x%x \n", temp);
-       temp = (u32)*((REG_UWORD32 *)((u32)(cm_base) + 0xA10));
-	   DBG_Trace(DBG_LEVEL6, "CM_ICLKEN1_CORE = 0x%x \n", temp);
-}
-
 /*
  *  ======== configureDspMmu ========
  *      Make DSP MMU page table entries.
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/wmd/tiomap3430_pwr.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/wmd/tiomap3430_pwr.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/wmd/tiomap3430_pwr.c	2012-12-16 13:13:01.572330147 +0100
@@ -57,6 +57,9 @@
 
 #include <dspbridge/pwr_sh.h>
 
+/*  ----------------------------------- Mini Driver */
+#include <dspbridge/wmddeh.h>
+
 /*  ----------------------------------- specific to this file */
 #include "_tiomap.h"
 #include "_tiomap_pwr.h"
@@ -69,6 +72,7 @@
 #endif
 extern struct MAILBOX_CONTEXT mboxsetting;
 extern unsigned short enable_off_mode;
+extern unsigned short min_active_opp;
 /*
  *  ======== handle_constraints_set ========
  *  	Sets new DSP constraint
@@ -77,24 +81,33 @@ DSP_STATUS handle_constraints_set(struct
 				  IN void *pArgs)
 {
 #ifdef CONFIG_BRIDGE_DVFS
-	u32 *pConstraintVal;
-       DSP_STATUS status = DSP_SOK;
-       struct CFG_HOSTRES resources;
-       struct dspbridge_platform_data *pdata =
-	       omap_dspbridge_dev->dev.platform_data;
-       status = CFG_GetHostResources(
-                (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	u32 pConstraintVal;
+	DSP_STATUS status = DSP_SOK;
+	struct CFG_HOSTRES resources;
+	struct dspbridge_platform_data *pdata =
+		omap_dspbridge_dev->dev.platform_data;
+	status = CFG_GetHostResources(
+		(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
 
-	pConstraintVal = (u32 *)(pArgs);
+	pConstraintVal = *(((u32 *)pArgs) + 1);
 	/* Read the target value requested by DSP  */
-       DBG_Trace(DBG_LEVEL7, "handle_constraints_set:"
-               "opp requested = 0x%x\n", (u32)*(pConstraintVal+1));
-       status = HW_MBOX_saveSettings(resources.dwMboxBase);
+	DBG_Trace(DBG_LEVEL7, "handle_constraints_set:"
+		"opp requested = 0x%x\n", pConstraintVal);
+	status = HW_MBOX_saveSettings(resources.dwMboxBase);
 
 	/* Set the new opp value */
-	if (pdata->dsp_set_min_opp)
-                       (*pdata->dsp_set_min_opp)((u32)*(pConstraintVal+1));
-	return DSP_SOK;
+	if (pdata->dsp_set_min_opp) {
+		/*
+		 * When Smartreflex is ON, DSP requires at least OPP level 3
+		 * to operate reliably. So boost lower OPP levels to OPP3.
+		 */
+		if (pConstraintVal < min_active_opp) {
+			pr_debug("DSPBRIDGE: VDD1 OPP%x elevated to OPP%x\n",
+					pConstraintVal, min_active_opp);
+			(*pdata->dsp_set_min_opp)(min_active_opp);
+		} else
+			(*pdata->dsp_set_min_opp)(pConstraintVal);
+	}
 #endif /* #ifdef CONFIG_BRIDGE_DVFS */
 	return DSP_SOK;
 }
@@ -156,17 +169,19 @@ DSP_STATUS handle_hibernation_fromDSP(st
 			if (DSP_FAILED(status))
 				return status;
 			IO_SHMsetting(hIOMgr, SHM_GETOPP, &opplevel);
-			/* Set the OPP to low level before moving to OFF mode */
 			if (opplevel != VDD1_OPP1) {
 				DBG_Trace(DBG_LEVEL5,
-					"Tiomap_pwr.c - DSP requested"
-					" OPP = %d, MPU requesting low"
-					" OPP %d instead\n", opplevel,
-					VDD1_OPP1);
-				if (pdata->dsp_set_min_opp)
-					(*pdata->dsp_set_min_opp)(VDD1_OPP1);
-				status = DSP_SOK;
+					" DSP requested OPP = %d, MPU"
+					" requesting low OPP %d instead\n",
+					opplevel, VDD1_OPP1);
 			}
+			/*
+			 * Set the OPP to low level before moving to OFF
+			 * mode
+			 */
+			if (pdata->dsp_set_min_opp)
+				(*pdata->dsp_set_min_opp)(VDD1_OPP1);
+			status = DSP_SOK;
 #endif /* CONFIG_BRIDGE_DVFS */
 		} else {
 			DBG_Trace(DBG_LEVEL7,
@@ -187,21 +202,23 @@ DSP_STATUS SleepDSP(struct WMD_DEV_CONTE
 	DSP_STATUS status = DSP_SOK;
 #ifdef CONFIG_PM
 	struct CFG_HOSTRES resources;
+	struct DEH_MGR *hDehMgr;
 	u16 usCount = TIHELEN_ACKTIMEOUT;
-	enum HW_PwrState_t pwrState;
-	enum HW_PwrState_t targetPwrState;
+	enum HW_PwrState_t pwrState, targetPwrState;
 
-	status = CFG_GetHostResources(
-		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
-	if (DSP_FAILED(status))
-		return status;
 	DBG_Trace(DBG_LEVEL7, "SleepDSP- Enter function \n");
 
-		/* next, check if sleep code is valid... */
+	/* Check if sleep code is valid */
 	if ((dwCmd != PWR_DEEPSLEEP) && (dwCmd != PWR_EMERGENCYDEEPSLEEP)) {
 		DBG_Trace(DBG_LEVEL7, "SleepDSP- Illegal sleep command\n");
 		return DSP_EINVALIDARG;
 	}
+
+	status = CFG_GetHostResources(
+		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	if (DSP_FAILED(status))
+		return status;
+
 	switch (pDevContext->dwBrdState) {
 	case BRD_RUNNING:
 		status = HW_MBOX_saveSettings(resources.dwMboxBase);
@@ -229,7 +246,6 @@ DSP_STATUS SleepDSP(struct WMD_DEV_CONTE
 		break;
 	case BRD_HIBERNATION:
 	case BRD_DSP_HIBERNATION:
-               status = HW_MBOX_saveSettings(resources.dwMboxBase);
 		/* Already in Hibernation, so just return */
 		DBG_Trace(DBG_LEVEL7, "SleepDSP- DSP already in "
 			 "hibernation\n");
@@ -243,34 +259,56 @@ DSP_STATUS SleepDSP(struct WMD_DEV_CONTE
 			 "SleepDSP- Bridge in Illegal state\n");
 			return DSP_EFAIL;
 	}
+
 	/* Get the PRCM DSP power domain status */
 	HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
-			    &pwrState);
-	/* Wait for DSP to move into Standby state,  how much time
-	 * should we wait?*/
+			&pwrState);
+
+	/*
+	 * Wait for DSP to move into Standby state,  how much time
+	 * should we wait?
+	 */
 	while ((pwrState != targetPwrState) && --usCount) {
 		udelay(500);
 		HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
 				    &pwrState);
 	}
-	if (usCount == 0) {
+
+	if (!usCount) {
 		DBG_Trace(DBG_LEVEL7, "SleepDSP: Timed out Waiting for DSP"
 			 " STANDBY %x \n", pwrState);
+		DEV_GetDehMgr(pDevContext->hDevObject, &hDehMgr);
+		WMD_DEH_Notify(hDehMgr, DSP_PWRERROR, 0);
 		return WMD_E_TIMEOUT;
 	} else {
 		DBG_Trace(DBG_LEVEL7, "SleepDSP: DSP STANDBY Pwr state %x \n",
 			 pwrState);
+
 		/* Update the Bridger Driver state */
 		if (enable_off_mode)
 			pDevContext->dwBrdState = BRD_HIBERNATION;
 		else
 			pDevContext->dwBrdState = BRD_RETENTION;
+
 		/* Turn off DSP Peripheral clocks  */
 		status = DSP_PeripheralClocks_Disable(pDevContext, NULL);
-		if (DSP_FAILED(status))
+		if (DSP_FAILED(status)) {
 			DBG_Trace(DBG_LEVEL7, "SleepDSP- FAILED\n");
+			return status;
+		}
+#ifdef CONFIG_BRIDGE_DVFS
+		else if (targetPwrState == HW_PWR_STATE_OFF) {
+			struct dspbridge_platform_data *pdata =
+				omap_dspbridge_dev->dev.platform_data;
+			/*
+			 * Set the OPP to low level before moving to OFF mode
+			 */
+			if (pdata->dsp_set_min_opp)
+				(*pdata->dsp_set_min_opp)(VDD1_OPP1);
+		}
+#endif /* CONFIG_BRIDGE_DVFS */
 	}
-#endif
+#endif /* CONFIG_PM */
 	return status;
 }
 
@@ -281,59 +319,40 @@ DSP_STATUS SleepDSP(struct WMD_DEV_CONTE
  */
 DSP_STATUS WakeDSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs)
 {
-	DSP_STATUS status = DSP_SOK;
 #ifdef CONFIG_PM
-	struct CFG_HOSTRES resources;
+	DSP_STATUS status = DSP_SOK;
+#ifdef CONFIG_BRIDGE_DEBUG
 	enum HW_PwrState_t pwrState;
-       u32 temp;
+	struct CFG_HOSTRES resources;
 
 	status = CFG_GetHostResources(
 		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
 	if (DSP_FAILED(status))
 		return status;
-	/* check the BRD/WMD state, if it is not 'SLEEP' then return failure */
+#endif /* CONFIG_BRIDGE_DEBUG */
+
+	/* Check the BRD/WMD state, if it is not 'SLEEP' then return failure */
 	if (pDevContext->dwBrdState == BRD_RUNNING ||
-		pDevContext->dwBrdState == BRD_STOPPED ||
-		pDevContext->dwBrdState == BRD_DSP_HIBERNATION) {
+	    pDevContext->dwBrdState == BRD_STOPPED) {
 		/* The Device is in 'RET' or 'OFF' state and WMD state is not
 		 * 'SLEEP', this means state inconsistency, so return  */
-		status = DSP_SOK;
-		return status;
-	}
-	/* Enable the DSP peripheral clocks and load monitor timer
-	 * before waking the DSP */
-	DBG_Trace(DBG_LEVEL6, "WakeDSP: enable DSP Peripheral Clks = 0x%x \n",
-		 pDevContext->uDspPerClks);
-	status = DSP_PeripheralClocks_Enable(pDevContext, NULL);
-
-       /* Enablifg Dppll in lock mode*/
-               temp = (u32) *((REG_UWORD32 *)
-                       ((u32) (resources.dwCmBase) + 0x34));
-               temp = (temp & 0xFFFFFFFE) | 0x1;
-               *((REG_UWORD32 *) ((u32) (resources.dwCmBase) + 0x34)) =
-                                               (u32) temp;
-               temp = (u32) *((REG_UWORD32 *)
-                       ((u32) (resources.dwCmBase) + 0x4));
-               temp = (temp & 0xFFFFFC8) | 0x37;
-
-               *((REG_UWORD32 *) ((u32) (resources.dwCmBase) + 0x4)) =
-               (u32) temp;
-
-	udelay(10);
-	if (DSP_SUCCEEDED(status)) {
-		/* Send a message to DSP to wake up */
-		CHNLSM_InterruptDSP2(pDevContext, MBX_PM_DSPWAKEUP);
-		HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
-				    &pwrState);
-		DBG_Trace(DBG_LEVEL7,
-			 "\nWakeDSP: Power State After sending Interrupt "
-			 "to DSP %x\n", pwrState);
-		/* set the device state to RUNNIG */
-		pDevContext->dwBrdState = BRD_RUNNING;
-	} else {
-		DBG_Trace(DBG_LEVEL6, "WakeDSP: FAILED\n");
+		return DSP_SOK;
 	}
-#endif
+
+	/* Send a wakeup message to DSP */
+	CHNLSM_InterruptDSP2(pDevContext, MBX_PM_DSPWAKEUP);
+
+#ifdef CONFIG_BRIDGE_DEBUG
+	HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
+			&pwrState);
+	DBG_Trace(DBG_LEVEL7,
+			"\nWakeDSP: Power State After sending Interrupt "
+			"to DSP %x\n", pwrState);
+#endif /* CONFIG_BRIDGE_DEBUG */
+
+	/* Set the device state to RUNNIG */
+	pDevContext->dwBrdState = BRD_RUNNING;
+#endif /* CONFIG_PM */
 	return status;
 }
 
@@ -390,7 +409,7 @@ DSP_STATUS DSPPeripheralClkCtrl(struct W
 			 "DSPPeripheralClkCtrl : Disable CLK for \n");
 		status1 = CLK_Disable(BPWR_Clks[clkIdIndex].intClk);
 		status = CLK_Disable(BPWR_Clks[clkIdIndex].funClk);
-               DSPClkWakeupEventCtrl(BPWR_Clks[clkIdIndex].clkId, false);
+		DSPClkWakeupEventCtrl(BPWR_Clks[clkIdIndex].clkId, false);
 		if ((DSP_SUCCEEDED(status)) && (DSP_SUCCEEDED(status1))) {
 			(pDevContext->uDspPerClks) &=
 				(~((u32) (1 << clkIdIndex)));
@@ -404,7 +423,7 @@ DSP_STATUS DSPPeripheralClkCtrl(struct W
 			 "DSPPeripheralClkCtrl : Enable CLK for \n");
 		status1 = CLK_Enable(BPWR_Clks[clkIdIndex].intClk);
 		status = CLK_Enable(BPWR_Clks[clkIdIndex].funClk);
-               DSPClkWakeupEventCtrl(BPWR_Clks[clkIdIndex].clkId, true);
+		DSPClkWakeupEventCtrl(BPWR_Clks[clkIdIndex].clkId, true);
 		if ((DSP_SUCCEEDED(status)) && (DSP_SUCCEEDED(status1))) {
 			(pDevContext->uDspPerClks) |= (1 << clkIdIndex);
 		} else {
@@ -438,13 +457,13 @@ DSP_STATUS PreScale_DSP(struct WMD_DEV_C
 
 	DBG_Trace(DBG_LEVEL7, "PreScale_DSP: voltage_domain = %x, level = "
 		 "0x%x\n", voltage_domain, level);
-       if ((pDevContext->dwBrdState == BRD_HIBERNATION) ||
-               (pDevContext->dwBrdState == BRD_RETENTION) ||
-               (pDevContext->dwBrdState == BRD_DSP_HIBERNATION)) {
+	if ((pDevContext->dwBrdState == BRD_HIBERNATION) ||
+			(pDevContext->dwBrdState == BRD_RETENTION) ||
+			(pDevContext->dwBrdState == BRD_DSP_HIBERNATION)) {
 		DBG_Trace(DBG_LEVEL7, "PreScale_DSP: IVA in sleep. "
 			 "No notification to DSP\n");
 		return DSP_SOK;
-       } else if ((pDevContext->dwBrdState == BRD_RUNNING)) {
+	} else if ((pDevContext->dwBrdState == BRD_RUNNING)) {
 		/* Send a prenotificatio to DSP */
 		DBG_Trace(DBG_LEVEL7,
 			 "PreScale_DSP: Sent notification to DSP\n");
@@ -477,11 +496,11 @@ DSP_STATUS PostScale_DSP(struct WMD_DEV_
 	voltage_domain = *((u32 *)pArgs);
 	level = *((u32 *)pArgs + 1);
 	DBG_Trace(DBG_LEVEL7,
-               "PostScale_DSP: voltage_domain = %x, level = 0x%x\n",
-               voltage_domain, level);
-       if ((pDevContext->dwBrdState == BRD_HIBERNATION) ||
-                       (pDevContext->dwBrdState == BRD_RETENTION) ||
-                       (pDevContext->dwBrdState == BRD_DSP_HIBERNATION)) {
+		"PostScale_DSP: voltage_domain = %x, level = 0x%x\n",
+		voltage_domain, level);
+	if ((pDevContext->dwBrdState == BRD_HIBERNATION) ||
+			(pDevContext->dwBrdState == BRD_RETENTION) ||
+			(pDevContext->dwBrdState == BRD_DSP_HIBERNATION)) {
 		/* Update the OPP value in shared memory */
 		IO_SHMsetting(hIOMgr, SHM_CURROPP, &level);
 		DBG_Trace(DBG_LEVEL7,
@@ -494,12 +513,12 @@ DSP_STATUS PostScale_DSP(struct WMD_DEV_
 		/* Send a post notification to DSP */
 		CHNLSM_InterruptDSP2(pDevContext, MBX_PM_SETPOINT_POSTNOTIFY);
 		DBG_Trace(DBG_LEVEL7,
-                       "PostScale_DSP: Wrote to shared memory Sent post"
-                       " notification to DSP\n");
+			"PostScale_DSP: Wrote to shared memory Sent post"
+			" notification to DSP\n");
 		return DSP_SOK;
 	} else {
 		DBG_Trace(DBG_LEVEL7, "PostScale_DSP: Failed - DSP BRD state "
-                       "in wrong state");
+			"in wrong state");
 		return DSP_EFAIL;
 	}
 #endif /* #ifdef CONFIG_BRIDGE_DVFS */
@@ -546,194 +565,186 @@ DSP_STATUS DSP_PeripheralClocks_Enable(s
 				      IN void *pArgs)
 {
 	u32 clkIdx;
-	DSP_STATUS status = DSP_SOK;
+	DSP_STATUS int_clk_status = DSP_EFAIL, fun_clk_status = DSP_EFAIL;
 
 	for (clkIdx = 0; clkIdx < MBX_PM_MAX_RESOURCES; clkIdx++) {
 		if (((pDevContext->uDspPerClks) >> clkIdx) & 0x01) {
 			/* Enable the interface clock of the peripheral */
-			status = CLK_Enable(BPWR_Clks[clkIdx].intClk);
-			if (DSP_FAILED(status)) {
-				DBG_Trace(DBG_LEVEL7,
-					 "Failed to Enable the DSP Peripheral"
-					 "Clk 0x%x \n", BPWR_Clks[clkIdx]);
-			}
+			int_clk_status = CLK_Enable(BPWR_Clks[clkIdx].intClk);
 			/* Enable the functional clock of the periphearl */
-			status = CLK_Enable(BPWR_Clks[clkIdx].funClk);
-			if (DSP_FAILED(status)) {
-				DBG_Trace(DBG_LEVEL7,
-					 "Failed to Enable the DSP Peripheral"
-					 "Clk 0x%x \n", BPWR_Clks[clkIdx]);
-			}
+			fun_clk_status = CLK_Enable(BPWR_Clks[clkIdx].funClk);
 		}
 	}
-	return status;
+	if ((int_clk_status | fun_clk_status) != DSP_SOK)
+		return DSP_EFAIL;
+	return DSP_SOK;
 }
 
 void DSPClkWakeupEventCtrl(u32 ClkId, bool enable)
 {
-       struct CFG_HOSTRES resources;
-       DSP_STATUS status = DSP_SOK;
-       u32 iva2_grpsel;
-       u32 mpu_grpsel;
-
-       status = CFG_GetHostResources(
-                (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
-       if (DSP_FAILED(status))
-               return;
-
-       switch (ClkId) {
-       case BPWR_GPTimer5:
-               iva2_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwPerPmBase) + 0xA8));
-               mpu_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwPerPmBase) + 0xA4));
-               if (enable) {
-                       iva2_grpsel |= OMAP3430_GRPSEL_GPT5;
-                       mpu_grpsel &= ~OMAP3430_GRPSEL_GPT5;
-               } else {
-                       mpu_grpsel |= OMAP3430_GRPSEL_GPT5;
-                       iva2_grpsel &= ~OMAP3430_GRPSEL_GPT5;
-               }
-               *((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-                               = iva2_grpsel;
-               *((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-                               = mpu_grpsel;
-       break;
-       case BPWR_GPTimer6:
-               iva2_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwPerPmBase) + 0xA8));
-               mpu_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwPerPmBase) + 0xA4));
-               if (enable) {
-                       iva2_grpsel |= OMAP3430_GRPSEL_GPT6;
-                       mpu_grpsel &= ~OMAP3430_GRPSEL_GPT6;
-               } else {
-                       mpu_grpsel |= OMAP3430_GRPSEL_GPT6;
-                       iva2_grpsel &= ~OMAP3430_GRPSEL_GPT6;
-               }
-               *((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-                                                       = iva2_grpsel;
-               *((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-                                                       = mpu_grpsel;
-       break;
-       case BPWR_GPTimer7:
-               iva2_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwPerPmBase) + 0xA8));
-               mpu_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwPerPmBase) + 0xA4));
-               if (enable) {
-                       iva2_grpsel |= OMAP3430_GRPSEL_GPT7;
-                       mpu_grpsel &= ~OMAP3430_GRPSEL_GPT7;
-               } else {
-                       mpu_grpsel |= OMAP3430_GRPSEL_GPT7;
-                       iva2_grpsel &= ~OMAP3430_GRPSEL_GPT7;
-               }
-               *((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-                                                       = iva2_grpsel;
-               *((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-                                                       = mpu_grpsel;
-       break;
-       case BPWR_GPTimer8:
-               iva2_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwPerPmBase) + 0xA8));
-               mpu_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwPerPmBase) + 0xA4));
-               if (enable) {
-                       iva2_grpsel |= OMAP3430_GRPSEL_GPT8;
-                       mpu_grpsel &= ~OMAP3430_GRPSEL_GPT8;
-               } else {
-                       mpu_grpsel |= OMAP3430_GRPSEL_GPT8;
-                       iva2_grpsel &= ~OMAP3430_GRPSEL_GPT8;
-               }
-               *((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-                                                       = iva2_grpsel;
-               *((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-                                                       = mpu_grpsel;
-       break;
-       case BPWR_MCBSP1:
-               iva2_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwCorePmBase) + 0xA8));
-               mpu_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwCorePmBase) + 0xA4));
-               if (enable) {
-                       iva2_grpsel |= OMAP3430_GRPSEL_MCBSP1;
-                       mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP1;
-               } else {
-                       mpu_grpsel |= OMAP3430_GRPSEL_MCBSP1;
-                       iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP1;
-               }
-               *((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA8))
-                                                       = iva2_grpsel;
-               *((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA4))
-                                                       = mpu_grpsel;
-       break;
-       case BPWR_MCBSP2:
-               iva2_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwPerPmBase) + 0xA8));
-               mpu_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwPerPmBase) + 0xA4));
-               if (enable) {
-                       iva2_grpsel |= OMAP3430_GRPSEL_MCBSP2;
-                       mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP2;
-               } else {
-                       mpu_grpsel |= OMAP3430_GRPSEL_MCBSP2;
-                       iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP2;
-               }
-               *((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-                                                       = iva2_grpsel;
-               *((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-                                                       = mpu_grpsel;
-       break;
-       case BPWR_MCBSP3:
-               iva2_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwPerPmBase) + 0xA8));
-               mpu_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwPerPmBase) + 0xA4));
-               if (enable) {
-                       iva2_grpsel |= OMAP3430_GRPSEL_MCBSP3;
-                       mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP3;
-               } else {
-                       mpu_grpsel |= OMAP3430_GRPSEL_MCBSP3;
-                       iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP3;
-               }
-               *((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-                                                       = iva2_grpsel;
-               *((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-                                                       = mpu_grpsel;
-       break;
-       case BPWR_MCBSP4:
-               iva2_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwPerPmBase) + 0xA8));
-               mpu_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwPerPmBase) + 0xA4));
-               if (enable) {
-                       iva2_grpsel |= OMAP3430_GRPSEL_MCBSP4;
-                       mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP4;
-               } else {
-                       mpu_grpsel |= OMAP3430_GRPSEL_MCBSP4;
-                       iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP4;
-               }
-               *((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
-                                                       = iva2_grpsel;
-               *((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
-                                                       = mpu_grpsel;
-       break;
-       case BPWR_MCBSP5:
-               iva2_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwCorePmBase) + 0xA8));
-               mpu_grpsel = (u32) *((REG_UWORD32 *)
-                               ((u32) (resources.dwCorePmBase) + 0xA4));
-               if (enable) {
-                       iva2_grpsel |= OMAP3430_GRPSEL_MCBSP5;
-                       mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP5;
-               } else {
-                       mpu_grpsel |= OMAP3430_GRPSEL_MCBSP5;
-                       iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP5;
-               }
-               *((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA8))
-                                                       = iva2_grpsel;
-               *((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA4))
-                                                       = mpu_grpsel;
-       break;
-       }
+	struct CFG_HOSTRES resources;
+	DSP_STATUS status = DSP_SOK;
+	u32 iva2_grpsel;
+	u32 mpu_grpsel;
+
+	status = CFG_GetHostResources(
+		(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	if (DSP_FAILED(status))
+		return;
+
+	switch (ClkId) {
+	case BPWR_GPTimer5:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_GPT5;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_GPT5;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_GPT5;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_GPT5;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
+				= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
+				= mpu_grpsel;
+	break;
+	case BPWR_GPTimer6:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_GPT6;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_GPT6;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_GPT6;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_GPT6;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
+							= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
+							= mpu_grpsel;
+	break;
+	case BPWR_GPTimer7:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_GPT7;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_GPT7;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_GPT7;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_GPT7;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
+							= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
+							= mpu_grpsel;
+	break;
+	case BPWR_GPTimer8:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_GPT8;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_GPT8;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_GPT8;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_GPT8;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
+							= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
+							= mpu_grpsel;
+	break;
+	case BPWR_MCBSP1:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwCorePmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwCorePmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP1;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP1;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP1;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP1;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA8))
+							= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA4))
+							= mpu_grpsel;
+	break;
+	case BPWR_MCBSP2:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP2;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP2;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP2;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP2;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
+							= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
+							= mpu_grpsel;
+	break;
+	case BPWR_MCBSP3:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP3;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP3;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP3;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP3;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
+							= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
+							= mpu_grpsel;
+	break;
+	case BPWR_MCBSP4:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP4;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP4;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP4;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP4;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
+							= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
+							= mpu_grpsel;
+	break;
+	case BPWR_MCBSP5:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwCorePmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwCorePmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP5;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP5;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP5;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP5;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA8))
+							= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA4))
+							= mpu_grpsel;
+	break;
+	}
 }
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/wmd/ue_deh.c kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/wmd/ue_deh.c
--- kernel-2.6.28-20091602+0m5/drivers/dsp/bridge/wmd/ue_deh.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/dsp/bridge/wmd/ue_deh.c	2012-12-16 13:13:01.572330147 +0100
@@ -74,6 +74,8 @@ static struct HW_MMUMapAttrs_t  mapAttrs
 					HW_ELEM_SIZE_16BIT,
 					HW_MMU_CPUES} ;
 #define VirtToPhys(x)       ((x) - PAGE_OFFSET + PHYS_OFFSET)
+
+static u32 dummyVaAddr;
 /*
  *  ======== WMD_DEH_Create ========
  *      Creates DEH manager object.
@@ -94,6 +96,7 @@ DSP_STATUS WMD_DEH_Create(OUT struct DEH
 	/* Get WMD context info. */
 	DEV_GetWMDContext(hDevObject, &hWmdContext);
 	DBC_Assert(hWmdContext);
+	dummyVaAddr = 0;
 	/* Allocate IO manager object: */
 	MEM_AllocObject(pDehMgr, struct DEH_MGR, SIGNATURE);
 	if (pDehMgr == NULL) {
@@ -151,6 +154,8 @@ DSP_STATUS WMD_DEH_Destroy(struct DEH_MG
 
 	DBG_Trace(DBG_LEVEL1, "Entering DEH_Destroy: 0x%x\n", pDehMgr);
 	if (MEM_IsValidHandle(pDehMgr, SIGNATURE)) {
+		/* Release dummy VA buffer */
+		WMD_DEH_ReleaseDummyMem();
 		/* If notification object exists, delete it */
 		if (pDehMgr->hNtfy)
 			(void)NTFY_Delete(pDehMgr->hNtfy);
@@ -197,11 +202,11 @@ void WMD_DEH_Notify(struct DEH_MGR *hDeh
 	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)hDehMgr;
 	struct WMD_DEV_CONTEXT *pDevContext;
 	DSP_STATUS status = DSP_SOK;
+	DSP_STATUS status1 = DSP_EFAIL;
 	u32 memPhysical = 0;
 	u32 HW_MMU_MAX_TLB_COUNT = 31;
-	u32 extern faultAddr;
+	extern u32 faultAddr;
 	struct CFG_HOSTRES resources;
-	u32 dummyVaAddr;
 	HW_STATUS hwStatus;
 
 	status = CFG_GetHostResources(
@@ -245,12 +250,9 @@ void WMD_DEH_Notify(struct DEH_MGR *hDeh
 				"address = 0x%x\n", (unsigned int)faultAddr);
 			dummyVaAddr = (u32)MEM_Calloc(sizeof(char) * 0x1000,
 					MEM_PAGED);
-			memPhysical = (u32)MEM_Calloc(sizeof(char) * 0x1000,
-					MEM_PAGED);
-			dummyVaAddr = PG_ALIGN_LOW((u32)dummyVaAddr,
-					PG_SIZE_4K);
-			memPhysical  = VirtToPhys(dummyVaAddr);
-			DBG_Trace(DBG_LEVEL6, "WMD_DEH_Notify: DSP_MMUFAULT, "
+			memPhysical  = VirtToPhys(PG_ALIGN_LOW((u32)dummyVaAddr,
+								PG_SIZE_4K));
+DBG_Trace(DBG_LEVEL6, "WMD_DEH_Notify: DSP_MMUFAULT, "
 				 "mem Physical= 0x%x\n", memPhysical);
 			pDevContext = (struct WMD_DEV_CONTEXT *)
 						pDehMgr->hWmdContext;
@@ -279,12 +281,35 @@ void WMD_DEH_Notify(struct DEH_MGR *hDeh
 			HW_MMU_EventAck(resources.dwDmmuBase,
 					 HW_MMU_TRANSLATION_FAULT);
 			break;
+		case DSP_PWRERROR:
+			/* reset errInfo structure before use */
+			pDehMgr->errInfo.dwErrMask = DSP_PWRERROR;
+			pDehMgr->errInfo.dwVal1 = 0L;
+			pDehMgr->errInfo.dwVal2 = 0L;
+			pDehMgr->errInfo.dwVal3 = 0L;
+			pDehMgr->errInfo.dwVal1 = dwErrInfo;
+			printk(KERN_ERR "WMD_DEH_Notify: DSP_PWRERROR, errInfo "
+					"= 0x%x\n", dwErrInfo);
+			break;
 		default:
 			DBG_Trace(DBG_LEVEL6,
 				 "WMD_DEH_Notify: Unknown Error, errInfo = "
 				 "0x%x\n", dwErrInfo);
 			break;
 		}
+
+		/* Filter subsequent notifications when an error occurs */
+		if (pDevContext->dwBrdState != BRD_ERROR) {
+			/* Use it as a flag to send notifications the
+			 * first time and error occurred, next time
+			 * state will be BRD_ERROR */
+			status1 = DSP_EFAIL;
+		}
+
+		/* Filter subsequent notifications when an error occurs */
+		if (pDevContext->dwBrdState != BRD_ERROR)
+			status1 = DSP_SOK;
+
 		/* Set the Board state as ERROR */
 		pDevContext->dwBrdState = BRD_ERROR;
 		/* Disable all the clocks that were enabled by DSP */
@@ -292,8 +317,11 @@ void WMD_DEH_Notify(struct DEH_MGR *hDeh
 		/* Call DSP Trace Buffer */
 		PrintDspTraceBuffer(hDehMgr->hWmdContext);
 
-		/* Signal DSP error/exception event. */
-		NTFY_Notify(pDehMgr->hNtfy, ulEventMask);
+		if (DSP_SUCCEEDED(status1)) {
+			/* Signal DSP error/exception event. */
+			NTFY_Notify(pDehMgr->hNtfy, ulEventMask);
+		}
+
 	}
 	DBG_Trace(DBG_LEVEL1, "Exiting WMD_DEH_Notify\n");
 
@@ -327,3 +355,17 @@ DSP_STATUS WMD_DEH_GetInfo(struct DEH_MG
 
 	return status;
 }
+
+
+/*
+ *  ======== WMD_DEH_ReleaseDummyMem ========
+ *      Releases memory allocated for dummy page
+ */
+void WMD_DEH_ReleaseDummyMem(void)
+{
+	if (dummyVaAddr) {
+		MEM_Free((void *)dummyVaAddr);
+		dummyVaAddr = 0;
+	}
+}
+
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/drm-tungsten/drm_bo.c kernel-2.6.28-20093908+0m5/drivers/gpu/drm-tungsten/drm_bo.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/drm-tungsten/drm_bo.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/drm-tungsten/drm_bo.c	2012-12-16 13:13:01.576330147 +0100
@@ -157,14 +157,14 @@ static int drm_bo_add_ttm(struct drm_buf
 		bo->ttm = drm_ttm_create(dev, bo->num_pages << PAGE_SHIFT,
 					 page_flags | DRM_TTM_PAGE_USER,
 					 dev->bm.dummy_read_page);
-		if (!bo->ttm)
+		if (!bo->ttm) {
 			ret = -ENOMEM;
+			break;
+		}
 
 		ret = drm_ttm_set_user(bo->ttm, current,
 				       bo->buffer_start,
 				       bo->num_pages);
-		if (ret)
-			return ret;
 
 		break;
 	default:
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/drm-tungsten/drm_memory.c kernel-2.6.28-20093908+0m5/drivers/gpu/drm-tungsten/drm_memory.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/drm-tungsten/drm_memory.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/drm-tungsten/drm_memory.c	2012-12-16 13:13:01.580330147 +0100
@@ -34,7 +34,7 @@
  */
 
 #include <linux/highmem.h>
-#include <asm-generic/iomap.h>
+#include <asm/io.h>
 #include "drmP.h"
 
 static struct {
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/eurasiacon/build/linux/omap3430_linux/makefile.shared_conf kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/eurasiacon/build/linux/omap3430_linux/makefile.shared_conf
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/eurasiacon/build/linux/omap3430_linux/makefile.shared_conf	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/eurasiacon/build/linux/omap3430_linux/makefile.shared_conf	2012-12-16 13:13:01.624330146 +0100
@@ -42,7 +42,7 @@ DISPLAY_CONTROLLER =	omaplfb
 ARCH_CFLAGS		= -march=armv7-a
 
 # SYS_FLAGS contains any flags specific to this system
-SYS_CFLAGS		= 
+SYS_CFLAGS		= -DSGX_DYNAMIC_TIMING_INFO
 
 # The version of the kernel that is required for compilation
 REQUIREDKERNELVERSION = 2.6.24
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/include4/servicesext.h kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/include4/servicesext.h
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/include4/servicesext.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/include4/servicesext.h	2012-12-16 13:13:01.624330146 +0100
@@ -103,8 +103,8 @@ typedef enum _PVRSRV_POWER_STATE_
 typedef PVRSRV_ERROR (*PFN_PRE_POWER) (IMG_HANDLE, PVR_POWER_STATE, PVR_POWER_STATE);
 typedef PVRSRV_ERROR (*PFN_POST_POWER) (IMG_HANDLE, PVR_POWER_STATE, PVR_POWER_STATE);
 
-typedef PVRSRV_ERROR (*PFN_PRE_CLOCKSPEED_CHANGE) (IMG_HANDLE, IMG_BOOL);
-typedef PVRSRV_ERROR (*PFN_POST_CLOCKSPEED_CHANGE) (IMG_HANDLE, IMG_BOOL);
+typedef PVRSRV_ERROR (*PFN_PRE_CLOCKSPEED_CHANGE) (IMG_HANDLE, IMG_BOOL, PVR_POWER_STATE);
+typedef PVRSRV_ERROR (*PFN_POST_CLOCKSPEED_CHANGE) (IMG_HANDLE, IMG_BOOL, PVR_POWER_STATE);
 
 
 typedef enum _PVRSRV_PIXEL_FORMAT_ {
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/include4/services.h kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/include4/services.h
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/include4/services.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/include4/services.h	2012-12-16 13:13:01.624330146 +0100
@@ -183,11 +183,8 @@ typedef struct _PVRSRV_MEMBLK_
 {
 	IMG_DEV_VIRTADDR	sDevVirtAddr;			
 	IMG_HANDLE			hOSMemHandle;			
-	IMG_HANDLE			hOSWrapMem;					
 	IMG_HANDLE			hBuffer;				
 	IMG_HANDLE			hResItem;				
-	IMG_SYS_PHYADDR	 	*psIntSysPAddr;
-
 } PVRSRV_MEMBLK;
 
 typedef struct _PVRSRV_KERNEL_MEM_INFO_ *PPVRSRV_KERNEL_MEM_INFO;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/Kconfig kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/Kconfig
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/Kconfig	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/Kconfig	2012-12-16 13:13:01.624330146 +0100
@@ -1,2 +1,4 @@
 menuconfig PVR
 	tristate "PowerVR Services"
+	depends on OMAP2_DSS
+
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/Makefile kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/Makefile
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/Makefile	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/Makefile	2012-12-16 13:13:01.624330146 +0100
@@ -109,7 +109,7 @@ CBUILD.release	= -DRELEASE
 _CFLAGS.debug	= -g -O0 -DDLL_METRIC=1
 _CFLAGS.timing	= $(OPTIM) -g -DDLL_METRIC=1 -DTIMING
 _CFLAGS.release	= $(OPTIM) -g
-_CFLAGS          = $(_CFLAGS.$(BUILD))
+_CFLAGS          = $(_CFLAGS.$(BUILD)) -DSGX_DYNAMIC_TIMING_INFO
 
 # Defaults for useful things.
 #
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/include/pvr_bridge.h kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/include/pvr_bridge.h
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/include/pvr_bridge.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/include/pvr_bridge.h	2012-12-16 13:13:01.628330146 +0100
@@ -83,7 +83,8 @@ extern "C" {
 #define PVRSRV_BRIDGE_UNMAP_DEVICECLASS_MEMORY	PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+23)
 #define PVRSRV_BRIDGE_MAP_MEM_INFO_TO_USER		PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+24)
 #define PVRSRV_BRIDGE_UNMAP_MEM_INFO_FROM_USER	PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+25)
-#define PVRSRV_BRIDGE_CORE_CMD_LAST				(PVRSRV_BRIDGE_CORE_CMD_FIRST+25)
+#define PVRSRV_BRIDGE_CACHE_FLUSH_DRM			PVRSRV_IOWR(PVRSRV_BRIDGE_CORE_CMD_FIRST+26)
+#define PVRSRV_BRIDGE_CORE_CMD_LAST				(PVRSRV_BRIDGE_CORE_CMD_FIRST+26)
 
 #define PVRSRV_BRIDGE_SIM_CMD_FIRST				(PVRSRV_BRIDGE_CORE_CMD_LAST+1)
 #define PVRSRV_BRIDGE_PROCESS_SIMISR_EVENT		PVRSRV_IOWR(PVRSRV_BRIDGE_SIM_CMD_FIRST+0)	
@@ -367,7 +368,20 @@ typedef struct PVRSRV_BRIDGE_IN_UNMAPMEM
 
 }PVRSRV_BRIDGE_IN_UNMAPMEMINFOFROMUSER;
 
+
+#define DRM_PVR2D_CFLUSH_FROM_GPU	1
+#define DRM_PVR2D_CFLUSH_TO_GPU		2
  
+typedef struct PVRSRV_BRIDGE_IN_CACHEFLUSHDRMFROMUSER_TAG
+{
+	IMG_UINT32				ui32BridgeFlags;
+	IMG_UINT32				ui32Type;
+	IMG_UINT32				ui32Virt;
+	IMG_UINT32				ui32Length;
+
+}PVRSRV_BRIDGE_IN_CACHEFLUSHDRMFROMUSER;
+
+
 typedef struct PVRSRV_BRIDGE_IN_FREEDEVICEMEM_TAG
 {
 	IMG_UINT32				ui32BridgeFlags; 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/include/servicesint.h kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/include/servicesint.h
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/include/servicesint.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/include/servicesint.h	2012-12-16 13:13:01.628330146 +0100
@@ -56,12 +56,7 @@ typedef struct _PVRSRV_KERNEL_MEM_INFO_
 
 													
 	PVRSRV_MEMBLK			sMemBlk;
-	
-	
-	IMG_PVOID				pvSysBackupBuffer;	
 
-
-	
 	struct _PVRSRV_KERNEL_SYNC_INFO_	*psKernelSyncInfo;
 
 } PVRSRV_KERNEL_MEM_INFO;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/bridged/bridged_pvr_bridge.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/bridged/bridged_pvr_bridge.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/bridged/bridged_pvr_bridge.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/bridged/bridged_pvr_bridge.c	2012-12-16 13:13:01.628330146 +0100
@@ -50,6 +50,10 @@
 #define PVRMMapKVIndexAddressToMMapData(A,B,C,D,E) PVRSRV_OK
 #endif
 
+#ifdef __KERNEL__
+#include <linux/pagemap.h> /* for cache flush */
+#endif	/* __KERNEL__ */
+
 #ifndef ENOMEM
 #define ENOMEM	12
 #endif
@@ -859,6 +863,50 @@ PVRSRVUnmapDeviceMemoryBW(IMG_UINT32 ui3
 }
 
 
+static int
+FlushCacheDRI(IMG_UINT32 ui32Type, IMG_UINT32 ui32Virt, IMG_UINT32 ui32Length)
+{
+	switch (ui32Type) {
+	case DRM_PVR2D_CFLUSH_FROM_GPU:
+		PVR_DPF((PVR_DBG_MESSAGE, "DRM_PVR2D_CFLUSH_FROM_GPU 0x%08x, length 0x%08x\n",
+			  ui32Virt, ui32Length));
+#ifdef CONFIG_ARM
+		dmac_inv_range((const void *)ui32Virt,
+			       (const void *)(ui32Virt + ui32Length));
+#endif
+		return 0;
+	case DRM_PVR2D_CFLUSH_TO_GPU:
+		PVR_DPF((PVR_DBG_MESSAGE, "DRM_PVR2D_CFLUSH_TO_GPU 0x%08x, length 0x%08x\n",
+			  ui32Virt, ui32Length));
+#ifdef CONFIG_ARM
+		dmac_clean_range((const void *)ui32Virt,
+				 (const void *)(ui32Virt + ui32Length));
+#endif
+		return 0;
+	default:
+		PVR_DPF((PVR_DBG_ERROR, "Invalid cflush type 0x%x\n", ui32Type));
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int
+PVRSRVCacheFlushDRIBW(IMG_UINT32 ui32BridgeID,
+							 PVRSRV_BRIDGE_IN_CACHEFLUSHDRMFROMUSER *psCacheFlushIN,
+							 PVRSRV_BRIDGE_RETURN *psRetOUT,
+							 PVRSRV_PER_PROCESS_DATA *psPerProc)
+{
+	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_CACHE_FLUSH_DRM);
+
+	psRetOUT->eError = FlushCacheDRI(psCacheFlushIN->ui32Type,
+										psCacheFlushIN->ui32Virt,
+										psCacheFlushIN->ui32Length);
+
+	return 0;
+}
+
 
 static int
 PVRSRVMapDeviceClassMemoryBW(IMG_UINT32 ui32BridgeID,
@@ -1073,14 +1121,13 @@ PVRSRVWrapExtMemoryBW(IMG_UINT32 ui32Bri
 							  psSysPAddr,
 							  psWrapExtMemIN->pvLinAddr,
 							  &psMemInfo);
-	if(psWrapExtMemIN->ui32NumPageTableEntries)
-	{
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
-			  ui32PageTableSize,
-			  (IMG_VOID *)psSysPAddr, 0);
-	}
 	if(psWrapExtMemOUT->eError != PVRSRV_OK)
 	{
+		/* PVRSRVWrapExtMemoryKM failed, so clean up page list */
+		if (psWrapExtMemIN->ui32NumPageTableEntries)
+			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+					ui32PageTableSize,
+					(IMG_VOID *)psSysPAddr, 0);
 		return 0;
 	}
 
@@ -1126,7 +1173,7 @@ PVRSRVWrapExtMemoryBW(IMG_UINT32 ui32Bri
 					  &psWrapExtMemOUT->sClientSyncInfo.hKernelSyncInfo, 
 					  (IMG_HANDLE)psMemInfo->psKernelSyncInfo,
 					  PVRSRV_HANDLE_TYPE_SYNC_INFO,
-					  PVRSRV_HANDLE_ALLOC_FLAG_NONE,
+					  PVRSRV_HANDLE_ALLOC_FLAG_MULTI,
 					  psWrapExtMemOUT->sClientMemInfo.hKernelMemInfo);
 
 	COMMIT_HANDLE_BATCH_OR_ERROR(psWrapExtMemOUT->eError, psPerProc);
@@ -4714,6 +4761,7 @@ CommonBridgeInit(IMG_VOID)
 	SetDispatchTableEntry(PVRSRV_BRIDGE_UNMAP_DEVICECLASS_MEMORY, PVRSRVUnmapDeviceClassMemoryBW);
 	SetDispatchTableEntry(PVRSRV_BRIDGE_MAP_MEM_INFO_TO_USER, DummyBW);
 	SetDispatchTableEntry(PVRSRV_BRIDGE_UNMAP_MEM_INFO_FROM_USER, DummyBW);
+	SetDispatchTableEntry(PVRSRV_BRIDGE_CACHE_FLUSH_DRM, PVRSRVCacheFlushDRIBW);
 
 	
 	SetDispatchTableEntry(PVRSRV_BRIDGE_PROCESS_SIMISR_EVENT, DummyBW);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/buffer_manager.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/buffer_manager.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/buffer_manager.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/buffer_manager.c	2012-12-16 13:13:01.628330146 +0100
@@ -23,7 +23,6 @@
  * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
  *
  ******************************************************************************/
-
 #include "services_headers.h"
 
 #include "sysconfig.h"
@@ -679,7 +678,8 @@ static PVRSRV_ERROR BM_DestroyContextCal
 		psBMHeap = psBMHeap->psNext;
 
 		
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psTmpBMHeap, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_HEAP),
+				psTmpBMHeap, IMG_NULL);
 	}
 
 	
@@ -718,7 +718,7 @@ static PVRSRV_ERROR BM_DestroyContextCal
 		}
 	}
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, pBMContext, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_CONTEXT), pBMContext, IMG_NULL);
 
 	return PVRSRV_OK;
 }
@@ -990,7 +990,7 @@ ErrorExit:
 	}
 
 	
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psBMHeap, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_HEAP), psBMHeap, IMG_NULL);
 
 	return IMG_NULL;
 }
@@ -1034,7 +1034,8 @@ BM_DestroyHeap (IMG_HANDLE hDevMemHeap)
 			{
 				
 				*ppsBMHeap = psBMHeap->psNext;
-				OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psBMHeap, IMG_NULL);
+				OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_HEAP),
+						psBMHeap, IMG_NULL);
 				break;
 			}
 			ppsBMHeap = &((*ppsBMHeap)->psNext);
@@ -1131,6 +1132,22 @@ BM_Alloc (  IMG_HANDLE			hDevMemHeap,
 }
 
 
+IMG_BOOL
+BM_IsWrapped(IMG_HANDLE hDevMemHeap,
+		IMG_UINT32 ui32Offset,
+		IMG_SYS_PHYADDR sSysAddr)
+{
+	BM_BUF *pBuf;
+	BM_CONTEXT *psBMContext;
+	BM_HEAP *psBMHeap;
+
+	psBMHeap = (BM_HEAP *)hDevMemHeap;
+	psBMContext = psBMHeap->pBMContext;
+	sSysAddr.uiAddr += ui32Offset;
+	pBuf = (BM_BUF *)HASH_Retrieve(psBMContext->pBufferHash,
+			(IMG_UINTPTR_T) sSysAddr.uiAddr);
+	return pBuf != IMG_NULL;
+}
 
 IMG_BOOL
 BM_Wrap (	IMG_HANDLE hDevMemHeap,
@@ -1138,6 +1155,7 @@ BM_Wrap (	IMG_HANDLE hDevMemHeap,
 			IMG_UINT32 ui32Offset,
 			IMG_BOOL bPhysContig,
 			IMG_SYS_PHYADDR *psSysAddr,
+			IMG_BOOL bFreePageList,
 			IMG_VOID *pvCPUVAddr,
 			IMG_UINT32 *pui32Flags,
 			BM_HANDLE *phBuf)
@@ -1177,9 +1195,9 @@ BM_Wrap (	IMG_HANDLE hDevMemHeap,
 	{
 		IMG_UINT32 ui32MappingSize = HOST_PAGEALIGN (ui32Size + ui32Offset);
 
-		
-		if(pBuf->pMapping->uSize == ui32MappingSize && (pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped ||
-														pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped_virtaddr))
+		if (pBuf->pMapping->uSize == ui32MappingSize && (pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped ||
+					pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped_virtaddr ||
+					pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped_scatter))
 		{
 			PVR_DPF((PVR_DBG_MESSAGE,
 					"BM_Wrap (Matched previous Wrap! uSize=0x%x, uOffset=0x%x, SysAddr=%08X)",
@@ -1190,6 +1208,11 @@ BM_Wrap (	IMG_HANDLE hDevMemHeap,
 			if(pui32Flags)
 				*pui32Flags = uFlags;
 
+			/* reusing previous mapping, free the page list */
+			if (bFreePageList && psSysAddr)
+				OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+						ui32MappingSize/HOST_PAGESIZE()*sizeof(IMG_SYS_PHYADDR),
+						(IMG_VOID *)psSysAddr, 0);
 			return IMG_TRUE;
 		}
 	}
@@ -1213,15 +1236,13 @@ BM_Wrap (	IMG_HANDLE hDevMemHeap,
 	}
 
 	
-	if(pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped || pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped_virtaddr)
+	if (pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped || pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped_virtaddr
+			|| pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped_scatter)
 	{
-		
-		PVR_ASSERT(SysSysPAddrToCpuPAddr(sHashAddress).uiAddr == pBuf->CpuPAddr.uiAddr);
-
-		if (!HASH_Insert (psBMContext->pBufferHash, (IMG_UINTPTR_T) sHashAddress.uiAddr, (IMG_UINTPTR_T)pBuf))
+		pBuf->uHashKey =  (IMG_UINTPTR_T) sHashAddress.uiAddr;
+		if (!HASH_Insert (psBMContext->pBufferHash, pBuf->uHashKey, (IMG_UINTPTR_T)pBuf))
 		{
 			FreeBuf (pBuf, uFlags);
-			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof (BM_BUF), pBuf, IMG_NULL);
 			PVR_DPF((PVR_DBG_ERROR, "BM_Wrap: HASH_Insert FAILED"));
 			return IMG_FALSE;
 		}
@@ -1237,6 +1258,9 @@ BM_Wrap (	IMG_HANDLE hDevMemHeap,
 	if(pui32Flags)
 		*pui32Flags = uFlags;
 
+	/* take ownership of the list if requested so */
+	if (bFreePageList && psSysAddr)
+		pBuf->pvPageList = (void *)psSysAddr;
 	return IMG_TRUE;
 }
 
@@ -1247,7 +1271,6 @@ BM_Free (BM_HANDLE hBuf,
 {
 	BM_BUF *pBuf = (BM_BUF *)hBuf;
 	SYS_DATA *psSysData;
-	IMG_SYS_PHYADDR sHashAddr;
 
 	PVR_DPF ((PVR_DBG_MESSAGE, "BM_Free (h=%08X)", hBuf));
 	/* Calling BM_Free with NULL hBuf is either a bug or out-of-memory condition.
@@ -1267,13 +1290,18 @@ BM_Free (BM_HANDLE hBuf,
 
 	if(pBuf->ui32RefCount == 0)
 	{
-		if(pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped || pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped_virtaddr)
+		void *pPageList = pBuf->pvPageList;
+		IMG_UINT32 ui32ListSize =
+			pBuf->pMapping->uSize/HOST_PAGESIZE()*sizeof(IMG_SYS_PHYADDR);
+		if (pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped || pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped_virtaddr
+				|| pBuf->pMapping->eCpuMemoryOrigin == hm_wrapped_scatter)
 		{
-			sHashAddr = SysCpuPAddrToSysPAddr(pBuf->CpuPAddr);
-
-			HASH_Remove (pBuf->pMapping->pBMHeap->pBMContext->pBufferHash,	(IMG_UINTPTR_T)sHashAddr.uiAddr);
+			HASH_Remove(pBuf->pMapping->pBMHeap->pBMContext->pBufferHash, pBuf->uHashKey);
 		}
 		FreeBuf (pBuf, ui32Flags);
+		if (pPageList)
+			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32ListSize,
+					pPageList, 0);
 	}
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/deviceclass.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/deviceclass.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/deviceclass.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/deviceclass.c	2012-12-16 13:13:01.632330146 +0100
@@ -264,10 +264,12 @@ ErrorExit:
 
 	if(psDCInfo->psFuncTable)
 	{
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psDCInfo->psFuncTable, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE),
+				psDCInfo->psFuncTable, IMG_NULL);
 	}
 	
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psDCInfo, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DISPLAYCLASS_INFO),
+			psDCInfo, IMG_NULL);
 
 	return PVRSRV_ERROR_OUT_OF_MEMORY;
 }
@@ -324,9 +326,12 @@ FoundDevice:
 	psDCInfo = (PVRSRV_DISPLAYCLASS_INFO*)psDeviceNode->pvDevice;
 	PVR_ASSERT(psDCInfo->ui32RefCount == 0);
 	FreeDeviceID(psSysData, ui32DevIndex);
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psDCInfo->psFuncTable, IMG_NULL);
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psDCInfo, IMG_NULL);
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psDeviceNode, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE),
+			psDCInfo->psFuncTable, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DISPLAYCLASS_INFO),
+			psDCInfo, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DEVICE_NODE),
+			psDeviceNode, IMG_NULL);
 	return PVRSRV_OK;
 }
 
@@ -418,10 +423,12 @@ ErrorExit:
 
 	if(psBCInfo->psFuncTable)
 	{
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psBCInfo->psFuncTable, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_BC_SRV2BUFFER_KMJTABLE),
+				psBCInfo->psFuncTable, IMG_NULL);
 	}
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psBCInfo, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_BUFFERCLASS_INFO),
+			psBCInfo, IMG_NULL);
 
 	return PVRSRV_ERROR_OUT_OF_MEMORY;	
 }
@@ -474,9 +481,12 @@ FoundDevice:
 
 	FreeDeviceID(psSysData, ui32DevIndex);
 	psBCInfo = (PVRSRV_BUFFERCLASS_INFO*)psDevNode->pvDevice;
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psBCInfo->psFuncTable, IMG_NULL);
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psBCInfo, IMG_NULL);
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psDevNode, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_BC_SRV2BUFFER_KMJTABLE),
+			psBCInfo->psFuncTable, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_BUFFERCLASS_INFO),
+			psBCInfo, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DEVICE_NODE),
+			psDevNode, IMG_NULL);
 	return PVRSRV_OK;
 }
 
@@ -523,7 +533,8 @@ static PVRSRV_ERROR CloseDCDeviceCallBac
 		psDCInfo->hExtDevice = IMG_NULL;
 	}
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psDCPerContextInfo, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DISPLAYCLASS_PERCONTEXT_INFO),
+			psDCPerContextInfo, IMG_NULL);
 
 	return PVRSRV_OK;
 }
@@ -796,7 +807,8 @@ static PVRSRV_ERROR DestroyDCSwapChainCa
 		}
 	}
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psSwapChain, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DC_SWAPCHAIN),
+			psSwapChain, IMG_NULL);
 
 	return eError;
 }
@@ -942,7 +954,8 @@ ErrorExit:
 
 	if(psSwapChain)
 	{
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psSwapChain, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_DC_SWAPCHAIN),
+				psSwapChain, IMG_NULL);
 	}
 
 	return eError;
@@ -1485,11 +1498,14 @@ static PVRSRV_ERROR CloseBCDeviceCallBac
 		
 		if(psBCInfo->psBuffer)
 		{
-			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psBCInfo->psBuffer, IMG_NULL);
+			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+					sizeof(PVRSRV_BC_BUFFER) * psBCInfo->ui32BufferCount,
+					psBCInfo->psBuffer, IMG_NULL);
 		}
 	}
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psBCPerContextInfo, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_BUFFERCLASS_PERCONTEXT_INFO),
+			psBCPerContextInfo, IMG_NULL);
 
 	return PVRSRV_OK;
 }
@@ -1507,6 +1523,7 @@ PVRSRV_ERROR PVRSRVOpenBCDeviceKM (PVRSR
 	SYS_DATA 				*psSysData;
 	IMG_UINT32 				i;
 	PVRSRV_ERROR			eError;
+	BUFFER_INFO sBufferInfo;
 
 	if(!phDeviceKM)
 	{
@@ -1556,8 +1573,6 @@ FoundDevice:
 
 	if(psBCInfo->ui32RefCount++ == 0)
 	{
-		BUFFER_INFO sBufferInfo;
-
 		psDeviceNode = (PVRSRV_DEVICE_NODE *)hDevCookie;
 		PVR_ASSERT(psDeviceNode != IMG_NULL);
 
@@ -1656,7 +1671,9 @@ ErrorExit:
 	
 	if(psBCInfo->psBuffer)
 	{
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psBCInfo->psBuffer, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
+				sizeof(PVRSRV_BC_BUFFER) * sBufferInfo.ui32BufferCount,
+				psBCInfo->psBuffer, IMG_NULL);
 	}
 
 	return eError;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/devicemem.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/devicemem.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/devicemem.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/devicemem.c	2012-12-16 13:13:01.632330146 +0100
@@ -302,7 +302,8 @@ static PVRSRV_ERROR AllocDeviceMem(IMG_H
 	if (!bBMError)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"AllocDeviceMem: BM_Alloc Failed"));
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psMemInfo, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_KERNEL_MEM_INFO),
+				psMemInfo, IMG_NULL);
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
@@ -320,10 +321,6 @@ static PVRSRV_ERROR AllocDeviceMem(IMG_H
 	psMemInfo->sDevVAddr = psMemBlock->sDevVirtAddr;
 
 	psMemInfo->ui32AllocSize = ui32Size;
-
-	
-	psMemInfo->pvSysBackupBuffer = IMG_NULL;
-
 	
 	*ppsMemInfo = psMemInfo;
 
@@ -346,13 +343,8 @@ static PVRSRV_ERROR FreeDeviceMem(PVRSRV
 	
 	BM_Free(hBuffer, psMemInfo->ui32Flags);
 
-	if(psMemInfo->pvSysBackupBuffer)
-	{
-		
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psMemInfo->pvSysBackupBuffer, IMG_NULL);
-	}
-
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psMemInfo, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_KERNEL_MEM_INFO),
+			psMemInfo, IMG_NULL);
 
 	return(PVRSRV_OK);
 }
@@ -397,7 +389,8 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVAllocSyn
 	{
 
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVAllocSyncInfoKM: Failed to alloc memory"));
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psKernelSyncInfo, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_KERNEL_SYNC_INFO),
+				psKernelSyncInfo, IMG_NULL);
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 
@@ -429,7 +422,8 @@ IMG_EXPORT
 PVRSRV_ERROR IMG_CALLCONV PVRSRVFreeSyncInfoKM(PVRSRV_KERNEL_SYNC_INFO	*psKernelSyncInfo)
 {
 	FreeDeviceMem(psKernelSyncInfo->psSyncDataMemInfoKM);
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psKernelSyncInfo, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_KERNEL_SYNC_INFO),
+		psKernelSyncInfo, IMG_NULL);
 
 	return PVRSRV_OK;
 }
@@ -625,23 +619,20 @@ static PVRSRV_ERROR UnwrapExtMemoryCallB
 {
 	PVRSRV_ERROR eError = PVRSRV_OK;
 	PVRSRV_KERNEL_MEM_INFO *psMemInfo = pvParam;
-	IMG_HANDLE hOSWrapMem;
+	IMG_HANDLE hOSWrapMem = IMG_NULL;
+	BM_BUF *psBMBuf;
 
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
-	hOSWrapMem = psMemInfo->sMemBlk.hOSWrapMem;
+	psBMBuf = (BM_BUF *)psMemInfo->sMemBlk.hBuffer;
 
-	if (psMemInfo->psKernelSyncInfo)
+	if ((psBMBuf->ui32RefCount == 1) && (psMemInfo->psKernelSyncInfo))
 	{
 		eError = PVRSRVFreeSyncInfoKM(psMemInfo->psKernelSyncInfo);
+		hOSWrapMem = psBMBuf->hOSWrapMem;
 	}
 
 	
-	if(psMemInfo->sMemBlk.psIntSysPAddr)
-	{
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psMemInfo->sMemBlk.psIntSysPAddr, IMG_NULL);
-	}	
-
 	if (eError == PVRSRV_OK)
 	{
 		eError = FreeDeviceMem(psMemInfo);
@@ -679,20 +670,23 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtM
 	IMG_VOID 			*pvPageAlignedCPUVAddr;
 	IMG_SYS_PHYADDR	 	*psIntSysPAddr = IMG_NULL;
 	IMG_HANDLE			hOSWrapMem = IMG_NULL;
+	BM_BUF	*psBMBuf;
+	IMG_SYS_PHYADDR *pPageList = psExtSysPAddr;
+	IMG_UINT32 ui32PageCount;
 
 
 	psDeviceNode = (PVRSRV_DEVICE_NODE*)hDevCookie;
 	PVR_ASSERT(psDeviceNode != IMG_NULL);
+	psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
+	hDevMemHeap = psDevMemoryInfo->psDeviceMemoryHeap[psDevMemoryInfo->ui32MappingHeapID].hDevMemHeap;
+
+
+	ui32PageCount = HOST_PAGEALIGN(ui32ByteSize + ui32PageOffset) / ui32HostPageSize;
 
 	if(pvLinAddr)
 	{
-		IMG_UINT32 ui32PageCount;
-
-		
-		ui32PageCount = HOST_PAGEALIGN(ui32ByteSize + ui32PageOffset) / ui32HostPageSize;
 		pvPageAlignedCPUVAddr = (IMG_VOID *)((IMG_UINT8 *)pvLinAddr - ui32PageOffset);
-	
-		
+
 		if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 						ui32PageCount*sizeof(IMG_SYS_PHYADDR),
 						(IMG_VOID **)&psIntSysPAddr, IMG_NULL) != PVRSRV_OK)
@@ -701,8 +695,9 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtM
 			return PVRSRV_ERROR_OUT_OF_MEMORY;
 		}
 
+		/* let's start by getting the address of the first page */
 		eError = OSAcquirePhysPageAddr(pvPageAlignedCPUVAddr,
-										ui32PageCount * ui32HostPageSize,
+										ui32HostPageSize,
 										psIntSysPAddr,
 										&hOSWrapMem);
 		if(eError != PVRSRV_OK)
@@ -711,6 +706,26 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtM
 			eError = PVRSRV_ERROR_OUT_OF_MEMORY;
 			goto ErrorExitPhase1;
 		}
+		/* now check if this memory address is already wrapped */
+		if (BM_IsWrapped(hDevMemHeap, ui32PageOffset, psIntSysPAddr[0])) {
+			/* already wrapped */
+			OSReleasePhysPageAddr(hOSWrapMem);
+			hOSWrapMem = IMG_NULL;
+		} else if (ui32PageCount > 1) {
+			OSReleasePhysPageAddr(hOSWrapMem);
+			hOSWrapMem = IMG_NULL;
+			/* the memory is going to wrapped for the first time,
+			 * so we need full page list */
+			eError = OSAcquirePhysPageAddr(pvPageAlignedCPUVAddr,
+					ui32PageCount * ui32HostPageSize,
+					psIntSysPAddr,
+					&hOSWrapMem);
+			if (eError != PVRSRV_OK) {
+				PVR_DPF((PVR_DBG_ERROR, "PVRSRVWrapExtMemoryKM: Failed to alloc memory for block"));
+				eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+				goto ErrorExitPhase1;
+			}
+		}
 
 		
 		psExtSysPAddr = psIntSysPAddr;
@@ -720,10 +735,6 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtM
 		
 	}
 
-	
-	psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
-	hDevMemHeap = psDevMemoryInfo->psDeviceMemoryHeap[psDevMemoryInfo->ui32MappingHeapID].hDevMemHeap;
-
 	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,
 					sizeof(PVRSRV_KERNEL_MEM_INFO ),
 					(IMG_VOID **)&psMemInfo, IMG_NULL) != PVRSRV_OK)
@@ -742,6 +753,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtM
 					   ui32PageOffset,
 					   bPhysContig,
 					   psExtSysPAddr,
+					   IMG_TRUE,
 					   IMG_NULL,
 					   &psMemInfo->ui32Flags,
 					   &hBuffer);
@@ -758,6 +770,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtM
 					ui32PageOffset,
 					bPhysContig,
 					psExtSysPAddr,
+					IMG_TRUE,
 					IMG_NULL,
 					&psMemInfo->ui32Flags,
 					&hBuffer);
@@ -768,13 +781,13 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtM
 			goto ErrorExitPhase2;
 		}		
 	}
+	/* wrap was successful and BM_Wrap has taken ownership of the page list,
+	 * clear psIntSysPAddr here, so we don't double free the memory */
+	psIntSysPAddr = IMG_NULL;
 
 	
 	psMemBlock->sDevVirtAddr = BM_HandleToDevVaddr(hBuffer);
 	psMemBlock->hOSMemHandle = BM_HandleToOSMemHandle(hBuffer);
-	psMemBlock->hOSWrapMem = hOSWrapMem;
-	psMemBlock->psIntSysPAddr = psIntSysPAddr;
-
 	
 	psMemBlock->hBuffer = (IMG_HANDLE)hBuffer;
 
@@ -783,21 +796,20 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtM
 	psMemInfo->sDevVAddr = psMemBlock->sDevVirtAddr;
 	psMemInfo->ui32AllocSize = ui32ByteSize;
 
-	
-
-	psMemInfo->pvSysBackupBuffer = IMG_NULL;
-
-	
-
-
 	psBMHeap = (BM_HEAP*)hDevMemHeap;
 	hDevMemContext = (IMG_HANDLE)psBMHeap->pBMContext;
-	eError = PVRSRVAllocSyncInfoKM(hDevCookie,
-									hDevMemContext,
-									&psMemInfo->psKernelSyncInfo);
-	if(eError != PVRSRV_OK)
-	{
-		goto ErrorExitPhase2;
+	psBMBuf = (BM_BUF *)hBuffer;
+	if (psBMBuf->ui32RefCount == 1) {
+		eError = PVRSRVAllocSyncInfoKM(hDevCookie,
+				hDevMemContext,
+				&psMemInfo->psKernelSyncInfo);
+		if (eError != PVRSRV_OK) {
+			goto ErrorExitPhase2;
+		}
+		psBMBuf->pvKernelSyncInfo = psMemInfo->psKernelSyncInfo;
+		psBMBuf->hOSWrapMem = hOSWrapMem;
+	} else {
+		psMemInfo->psKernelSyncInfo = psBMBuf->pvKernelSyncInfo;
 	}
 
 	
@@ -806,6 +818,13 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtM
 													psMemInfo,
 													0,
 													UnwrapExtMemoryCallBack);
+	/* check if we were passed a page list
+	 * but we didn't use use it */
+	if (pPageList &&
+		(pPageList != psExtSysPAddr)) {
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32PageCount*sizeof(IMG_SYS_PHYADDR),
+				(IMG_VOID *)pPageList, 0);
+	}
 
 	
 	*ppsMemInfo = psMemInfo;
@@ -820,15 +839,13 @@ ErrorExitPhase2:
 		FreeDeviceMem(psMemInfo);
 	}
 
-	if(psIntSysPAddr)
-	{
+	if (hOSWrapMem)
 		OSReleasePhysPageAddr(hOSWrapMem);
-	}
-	
 ErrorExitPhase1:
 	if(psIntSysPAddr)
 	{
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psIntSysPAddr, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32PageCount*sizeof(IMG_SYS_PHYADDR),
+				psIntSysPAddr, IMG_NULL);
 	}
 
 	return eError;
@@ -854,11 +871,6 @@ static PVRSRV_ERROR UnmapDeviceMemoryCal
 
 	PVR_UNREFERENCED_PARAMETER(ui32Param);
 
-	if(psMemInfo->sMemBlk.psIntSysPAddr)
-	{
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psMemInfo->sMemBlk.psIntSysPAddr, IMG_NULL);
-	}
-
 	return FreeDeviceMem(psMemInfo);
 }
 
@@ -951,6 +963,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDevic
 					   ui32PageOffset,
 					   IMG_FALSE,
 					   psSysPAddr,
+					   IMG_TRUE,
 					   pvPageAlignedCPUVAddr,
 					   &psMemInfo->ui32Flags,
 					   &hBuffer);
@@ -969,10 +982,6 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDevic
 	
 	psMemBlock->hBuffer = (IMG_HANDLE)hBuffer;
 
-	
-	psMemBlock->psIntSysPAddr = psSysPAddr;
-	
-	
 	psMemInfo->pvLinAddrKM = psSrcMemInfo->pvLinAddrKM;
 
 	
@@ -980,11 +989,6 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDevic
 	psMemInfo->ui32AllocSize = psSrcMemInfo->ui32AllocSize;
 	psMemInfo->psKernelSyncInfo = psSrcMemInfo->psKernelSyncInfo;
 
-	
-
-	psMemInfo->pvSysBackupBuffer = IMG_NULL;
-
-	
 	psMemInfo->sMemBlk.hResItem = ResManRegisterRes(psPerProc->hResManContext,
 													RESMAN_TYPE_DEVICEMEM_MAPPING,
 													psMemInfo,
@@ -1002,13 +1006,15 @@ ErrorExit:
 	if(psSysPAddr)
 	{
 		
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psSysPAddr, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, ui32PageCount*sizeof(IMG_SYS_PHYADDR),
+				psSysPAddr, IMG_NULL);
 	}
 
 	if(psMemInfo)
 	{
 		
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psMemInfo, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_KERNEL_MEM_INFO),
+				psMemInfo, IMG_NULL);
 	}
 
 	return eError;
@@ -1103,7 +1109,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDevic
 	
 	psBMContext = (BM_CONTEXT*)psDeviceClassBuffer->hDevMemContext;
 	psDevMemoryInfo = &psBMContext->psDeviceNode->sDevMemoryInfo;
-	hDevMemHeap = psDevMemoryInfo->psDeviceMemoryHeap[psDevMemoryInfo->ui32MappingHeapID].hDevMemHeap;
+	hDevMemHeap = psDevMemoryInfo->psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].hDevMemHeap;
 
 	
 	ui32Offset = ((IMG_UINT32)pvCPUVAddr) & (ui32PageSize - 1);
@@ -1126,6 +1132,7 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDevic
 					   ui32Offset,
 					   bPhysContig,
 					   psSysPAddr,
+					   IMG_FALSE,
 					   pvPageAlignedCPUVAddr,
 					   &psMemInfo->ui32Flags,
 					   &hBuffer);
@@ -1133,7 +1140,8 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDevic
 	if (!bBMError)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVMapDeviceClassMemoryKM: BM_Wrap Failed"));
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psMemInfo, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_KERNEL_MEM_INFO),
+				psMemInfo, IMG_NULL);
 		return PVRSRV_ERROR_BAD_MAPPING;
 	}
 
@@ -1153,11 +1161,6 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVMapDevic
 	psMemInfo->ui32AllocSize = ui32ByteSize;
 	psMemInfo->psKernelSyncInfo = psDeviceClassBuffer->psKernelSyncInfo;
 
-	
-
-	psMemInfo->pvSysBackupBuffer = IMG_NULL;
-
-	
 	psMemInfo->sMemBlk.hResItem = ResManRegisterRes(psPerProc->hResManContext,
 													RESMAN_TYPE_DEVICECLASSMEM_MAPPING,
 													psMemInfo,
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/hash.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/hash.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/hash.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/hash.c	2012-12-16 13:13:01.632330146 +0100
@@ -180,7 +180,8 @@ _Resize (HASH_TABLE *pHash, IMG_UINT32 u
         for (uIndex=0; uIndex<uNewSize; uIndex++)
             ppNewTable[uIndex] = IMG_NULL;
         _Rehash (pHash, pHash->ppBucketTable, pHash->uSize, ppNewTable, uNewSize);
-        OSFreeMem (PVRSRV_OS_PAGEABLE_HEAP, 0, pHash->ppBucketTable, IMG_NULL);
+        OSFreeMem (PVRSRV_OS_PAGEABLE_HEAP, sizeof(BUCKET *) * pHash->uSize,
+		   pHash->ppBucketTable, IMG_NULL);
         pHash->ppBucketTable = ppNewTable;
         pHash->uSize = uNewSize;
     }
@@ -238,7 +239,8 @@ HASH_Delete (HASH_TABLE *pHash)
 		PVR_DPF ((PVR_DBG_MESSAGE, "HASH_Delete"));
 		
 		PVR_ASSERT (pHash->uCount==0);
-		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, pHash->ppBucketTable, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BUCKET *) * pHash->uSize,
+				pHash->ppBucketTable, IMG_NULL);
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(HASH_TABLE), pHash, IMG_NULL);
     }
 }
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/power.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/power.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/power.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/power.c	2012-12-16 13:13:01.632330146 +0100
@@ -23,12 +23,18 @@
  * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
  *
  ******************************************************************************/
-
 #include "services_headers.h"
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
 
 static IMG_BOOL gbInitServerRunning = IMG_FALSE;
 static IMG_BOOL gbInitServerRan = IMG_FALSE;
 static IMG_BOOL gbInitSuccessful = IMG_FALSE;
+static DEFINE_MUTEX(hPowerAndFreqLock);
+static DECLARE_WAIT_QUEUE_HEAD(hDvfsWq);
+static IMG_BOOL gbDvfsActive;
 
 IMG_EXPORT
 PVRSRV_ERROR PVRSRVSetInitServerState(PVRSRV_INIT_SERVER_STATE eInitServerState, IMG_BOOL bState)
@@ -84,63 +90,47 @@ static IMG_BOOL _IsSystemStatePowered(PV
 	return (IMG_BOOL)(eSystemPowerState < PVRSRV_POWER_STATE_D2);
 }
 
+IMG_EXPORT
+IMG_VOID PVRSRVDvfsLock(IMG_VOID)
+{
+	mutex_lock(&hPowerAndFreqLock);
+	gbDvfsActive = 1;
+	mutex_unlock(&hPowerAndFreqLock);
+}
+
+IMG_EXPORT
+IMG_VOID PVRSRVDvfsUnlock(IMG_VOID)
+{
+	mutex_lock(&hPowerAndFreqLock);
+	gbDvfsActive = 0;
+	wake_up(&hDvfsWq);
+	mutex_unlock(&hPowerAndFreqLock);
+}
 
 IMG_EXPORT
 PVRSRV_ERROR PVRSRVPowerLock(IMG_UINT32	ui32CallerID,
 							 IMG_BOOL	bSystemPowerEvent)
 {
-	PVRSRV_ERROR	eError;
-	SYS_DATA		*psSysData;
-	IMG_UINT32		ui32Timeout = 1000000;
-
-#if defined(SUPPORT_LMA)
-	
-	ui32Timeout *= 60;
-#endif 
-
-	eError = SysAcquireData(&psSysData);
-	if(eError != PVRSRV_OK)
-	{
-		return eError;
+	if ((ui32CallerID == TIMER_ID) &&
+			(mutex_is_locked(&hPowerAndFreqLock) || gbDvfsActive))
+		return PVRSRV_ERROR_RETRY;
+	mutex_lock(&hPowerAndFreqLock);
+	while (gbDvfsActive) {
+		DEFINE_WAIT(__wait);
+		prepare_to_wait(&hDvfsWq, &__wait, TASK_UNINTERRUPTIBLE);
+		mutex_unlock(&hPowerAndFreqLock);
+		schedule();
+		mutex_lock(&hPowerAndFreqLock);
+		finish_wait(&hDvfsWq, &__wait);
 	}
-
-	do
-	{
-		eError = OSLockResource(&psSysData->sPowerStateChangeResource,
-								ui32CallerID);
-		if (eError == PVRSRV_OK)
-		{
-			break;
-		}
-		else if (ui32CallerID == ISR_ID)
-		{
-			
-
-			eError = PVRSRV_ERROR_RETRY;
-			break;
-		}
-
-		OSWaitus(1);
-		ui32Timeout--;
-	} while (ui32Timeout > 0);
-
-	if ((eError == PVRSRV_OK) &&
-		!bSystemPowerEvent &&
-		!_IsSystemStatePowered(psSysData->eCurrentPowerState))
-	{
-		
-		PVRSRVPowerUnlock(ui32CallerID);
-		eError = PVRSRV_ERROR_RETRY;
-	}
-
-	return eError;
+	return PVRSRV_OK;
 }
 
 
 IMG_EXPORT
 IMG_VOID PVRSRVPowerUnlock(IMG_UINT32	ui32CallerID)
 {
-	OSUnlockResource(&gpsSysData->sPowerStateChangeResource, ui32CallerID);
+	mutex_unlock(&hPowerAndFreqLock);
 }
 
 
@@ -179,6 +169,7 @@ PVRSRV_ERROR PVRSRVDevicePrePowerStateKM
 														psPowerDevice->eCurrentPowerState);
 					if (eError != PVRSRV_OK)
 					{
+						pr_err("pfnPrePower failed (%u)\n", eError);
 						return eError;
 					}
 				}
@@ -189,6 +180,7 @@ PVRSRV_ERROR PVRSRVDevicePrePowerStateKM
 												psPowerDevice->eCurrentPowerState);
 				if (eError != PVRSRV_OK)
 				{
+					pr_err("SysDevicePrePowerState failed (%u)\n", eError);
 					return eError;
 				}
 			}
@@ -234,6 +226,7 @@ PVRSRV_ERROR PVRSRVDevicePostPowerStateK
 												 psPowerDevice->eCurrentPowerState);
 				if (eError != PVRSRV_OK)
 				{
+					pr_err("SysDevicePostPowerState failed (%u)\n", eError);
 					return eError;
 				}
 
@@ -245,6 +238,7 @@ PVRSRV_ERROR PVRSRVDevicePostPowerStateK
 														 psPowerDevice->eCurrentPowerState);
 					if (eError != PVRSRV_OK)
 					{
+						pr_err("pfnPostPower failed (%u)\n", eError);
 						return eError;
 					}
 				}
@@ -259,22 +253,6 @@ PVRSRV_ERROR PVRSRVDevicePostPowerStateK
 	return PVRSRV_OK;
 }
 
-
-PVRSRV_ERROR PVRSRVSetDevicePowerStateCoreKM(IMG_UINT32			ui32DeviceIndex,
-                                             PVR_POWER_STATE	eNewPowerState)
-{
-	PVRSRV_ERROR	eError;
-	eError = PVRSRVDevicePrePowerStateKM(IMG_FALSE, ui32DeviceIndex, eNewPowerState);
-	if(eError != PVRSRV_OK)
-	{
-		return eError;
-	}
-
-	eError = PVRSRVDevicePostPowerStateKM(IMG_FALSE, ui32DeviceIndex, eNewPowerState);
-	return eError;
-}
-
-
 IMG_EXPORT
 PVRSRV_ERROR PVRSRVSetDevicePowerStateKM(IMG_UINT32			ui32DeviceIndex,
 										 PVR_POWER_STATE	eNewPowerState,
@@ -581,7 +559,8 @@ PVRSRV_ERROR PVRSRVRemovePowerDevice (IM
 				psSysData->psPowerDeviceList = psCurrent->psNext;
 			}
 
-			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psCurrent, IMG_NULL);
+			OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PVRSRV_POWER_DEV),
+					psCurrent, IMG_NULL);
 			
 			break;
 		}
@@ -631,11 +610,11 @@ IMG_BOOL PVRSRVIsDevicePowered(IMG_UINT3
 }
 
 
-IMG_VOID PVRSRVDevicePreClockSpeedChange(IMG_UINT32	ui32DeviceIndex,
-										 IMG_BOOL	bIdleDevice,
-										 IMG_VOID	*pvInfo)
+PVRSRV_ERROR PVRSRVDevicePreClockSpeedChange(IMG_UINT32	ui32DeviceIndex,
+											IMG_BOOL	bIdleDevice,
+											IMG_VOID	*pvInfo)
 {
-	PVRSRV_ERROR		eError;
+	PVRSRV_ERROR		eError = PVRSRV_OK;
 	SYS_DATA			*psSysData;
 	PVRSRV_POWER_DEV	*psPowerDevice;
 
@@ -643,7 +622,6 @@ IMG_VOID PVRSRVDevicePreClockSpeedChange
 
 	SysAcquireData(&psSysData);
 
-	
 	psPowerDevice = psSysData->psPowerDeviceList;
 	while (psPowerDevice)
 	{
@@ -651,9 +629,11 @@ IMG_VOID PVRSRVDevicePreClockSpeedChange
 		{
 			if (psPowerDevice->pfnPreClockSpeedChange)
 			{
-				eError = psPowerDevice->pfnPreClockSpeedChange(psPowerDevice->hDevCookie, bIdleDevice);
-				if (eError != PVRSRV_OK)
-				{
+				eError = psPowerDevice->pfnPreClockSpeedChange(psPowerDevice->hDevCookie,
+															   bIdleDevice,
+															   psPowerDevice->eCurrentPowerState);
+				if (eError != PVRSRV_OK) {
+					pr_err("pfnPreClockSpeedChange failed\n");
 					PVR_DPF((PVR_DBG_ERROR,
 							"PVRSRVDevicePreClockSpeedChange : Device %lu failed, error:0x%lx",
 							ui32DeviceIndex, eError));
@@ -663,6 +643,7 @@ IMG_VOID PVRSRVDevicePreClockSpeedChange
 		
 		psPowerDevice = psPowerDevice->psNext;
 	}
+	return eError;
 }
 
 
@@ -670,7 +651,7 @@ IMG_VOID PVRSRVDevicePostClockSpeedChang
 										  IMG_BOOL		bIdleDevice,
 										  IMG_VOID		*pvInfo)
 {
-	PVRSRV_ERROR		eError;
+	PVRSRV_ERROR		eError = PVRSRV_OK;
 	SYS_DATA			*psSysData;
 	PVRSRV_POWER_DEV	*psPowerDevice;
 
@@ -686,9 +667,11 @@ IMG_VOID PVRSRVDevicePostClockSpeedChang
 		{
 			if (psPowerDevice->pfnPostClockSpeedChange)
 			{
-				eError = psPowerDevice->pfnPostClockSpeedChange(psPowerDevice->hDevCookie, bIdleDevice);
-				if (eError != PVRSRV_OK)
-				{
+				eError = psPowerDevice->pfnPostClockSpeedChange(psPowerDevice->hDevCookie,
+																bIdleDevice,
+																psPowerDevice->eCurrentPowerState);
+				if (eError != PVRSRV_OK) {
+					pr_err("pfnPostClockSpeedChange failed\n");
 					PVR_DPF((PVR_DBG_ERROR,
 							"PVRSRVDevicePostClockSpeedChange : Device %lu failed, error:0x%lx",
 							ui32DeviceIndex, eError));
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/pvrsrv.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/pvrsrv.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/pvrsrv.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/pvrsrv.c	2012-12-16 13:13:01.632330146 +0100
@@ -289,8 +289,8 @@ PVRSRV_ERROR IMG_CALLCONV PVRSRVRegister
 	eError = pfnRegisterDevice(psDeviceNode);
 	if (eError != PVRSRV_OK)
 	{
-		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-					0, psDeviceNode, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, sizeof(PVRSRV_DEVICE_NODE),
+				psDeviceNode, IMG_NULL);
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterDevice : Failed to register device"));
 		return (PVRSRV_ERROR_DEVICE_REGISTER_FAILED);
 	}
@@ -565,8 +565,8 @@ FoundDevice:
 
 		
 	FreeDeviceID(psSysData, ui32DevIndex);	
-	OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
-				0, psDeviceNode, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, sizeof(PVRSRV_DEVICE_NODE),
+			psDeviceNode, IMG_NULL);
 	
 	return (PVRSRV_OK);
 }
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/queue.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/queue.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/queue.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/queue.c	2012-12-16 13:13:01.632330146 +0100
@@ -854,6 +854,9 @@ PVRSRV_ERROR PVRSRVRegisterCmdProcListKM
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVRegisterCmdProcListKM: Failed to alloc CC data"));
 		goto ErrorExit;
 	}
+	/* clear the list to ensure that we don't try to access uninitialised pointer
+	 * in the 'error' execution path */
+	OSMemSet(psSysData->ppsCmdCompleteData[ui32DevIndex], 0x00, ui32AllocSize);
 
 	for (i=0; i<ui32CmdCount; i++)
 	{
@@ -886,6 +889,7 @@ PVRSRV_ERROR PVRSRVRegisterCmdProcListKM
 		psCmdCompleteData->psSrcSync = (PVRSRV_SYNC_OBJECT*)
 										(((IMG_UINT32)psCmdCompleteData->psDstSync) 
 										+ (sizeof(PVRSRV_SYNC_OBJECT) * ui32MaxSyncsPerCmd[i][0]));
+		psCmdCompleteData->ui32AllocSize = ui32AllocSize;
 	}
 
 	return PVRSRV_OK;
@@ -900,16 +904,23 @@ ErrorExit:
 		{
 			if (psSysData->ppsCmdCompleteData[ui32DevIndex][i] != IMG_NULL)
 			{
-				OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, 0, psSysData->ppsCmdCompleteData[ui32DevIndex][i], IMG_NULL);
+				psCmdCompleteData = psSysData->ppsCmdCompleteData[ui32DevIndex][i];
+				OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+						psCmdCompleteData->ui32AllocSize,
+						psCmdCompleteData, IMG_NULL);
 			}
 		}
 
-		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, 0, psSysData->ppsCmdCompleteData[ui32DevIndex], IMG_NULL);
+		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+				ui32CmdCount * sizeof(COMMAND_COMPLETE_DATA *),
+				psSysData->ppsCmdCompleteData[ui32DevIndex], IMG_NULL);
 	}
 
 	if(psSysData->ppfnCmdProcList[ui32DevIndex] != IMG_NULL)
 	{
-		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, 0, psSysData->ppfnCmdProcList[ui32DevIndex], IMG_NULL);
+		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+				ui32CmdCount * sizeof(PFN_CMD_PROC),
+				psSysData->ppfnCmdProcList[ui32DevIndex], IMG_NULL);
 	}
 	
 	return eError;
@@ -948,18 +959,26 @@ PVRSRV_ERROR PVRSRVRemoveCmdProcListKM(I
 			
 			if(psSysData->ppsCmdCompleteData[ui32DevIndex][i] != IMG_NULL)
 			{
-				OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, 0, psSysData->ppsCmdCompleteData[ui32DevIndex][i], IMG_NULL);
+				COMMAND_COMPLETE_DATA *psCmdCompleteData =
+					psSysData->ppsCmdCompleteData[ui32DevIndex][i];
+				OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+						psCmdCompleteData->ui32AllocSize,
+						psCmdCompleteData, IMG_NULL);
 			}
 		}
 
 		
-		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, 0, psSysData->ppsCmdCompleteData[ui32DevIndex], IMG_NULL);
+		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+				ui32CmdCount * sizeof(COMMAND_COMPLETE_DATA *),
+				psSysData->ppsCmdCompleteData[ui32DevIndex], IMG_NULL);
 	}
 
 	
 	if(psSysData->ppfnCmdProcList[ui32DevIndex] != IMG_NULL)
 	{
-		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP, 0, psSysData->ppfnCmdProcList[ui32DevIndex], IMG_NULL);
+		OSFreeMem(PVRSRV_OS_NON_PAGEABLE_HEAP,
+				ui32CmdCount * sizeof(PFN_CMD_PROC),
+				psSysData->ppfnCmdProcList[ui32DevIndex], IMG_NULL);
 	}
 
 	return PVRSRV_OK;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/ra.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/ra.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/ra.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/ra.c	2012-12-16 13:13:01.632330146 +0100
@@ -697,7 +697,7 @@ RA_Create (IMG_CHAR *name,
   insert_fail:
 	HASH_Delete (pArena->pSegmentHash);
   hash_fail:
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, pArena, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(RA_ARENA), pArena, IMG_NULL);
   arena_fail:
 	return IMG_NULL;
 }
@@ -729,7 +729,7 @@ RA_Delete (RA_ARENA *pArena)
 	RemoveProcEntry(pArena->szProcSegsName);
 #endif
 	HASH_Delete (pArena->pSegmentHash);
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, pArena, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(RA_ARENA), pArena, IMG_NULL);
 }
 
 IMG_BOOL
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/resman.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/resman.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/common/resman.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/common/resman.c	2012-12-16 13:13:01.632330146 +0100
@@ -280,7 +280,8 @@ IMG_VOID PVRSRVResManDisconnect(PRESMAN_
 	}
 
 	
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psResManContext, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(RESMAN_CONTEXT),
+			psResManContext, IMG_NULL);
 
 
 	
@@ -549,7 +550,8 @@ static PVRSRV_ERROR FreeResourceByPtr(RE
 	ACQUIRE_SYNC_OBJ;
 
 	
-	if(OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0, psItem, IMG_NULL) != PVRSRV_OK)
+	if (OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(RESMAN_ITEM), psItem, IMG_NULL)
+			!= PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "FreeResourceByPtr: ERROR freeing resource list item memory"));
 		eError = PVRSRV_ERROR_GENERIC;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/devices/sgx/mmu.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/devices/sgx/mmu.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/devices/sgx/mmu.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/devices/sgx/mmu.c	2012-12-16 13:13:01.636330146 +0100
@@ -1203,7 +1203,8 @@ MMU_Create (MMU_CONTEXT *psMMUContext,
 	if (!bRes)
 	{
 		PVR_DPF((PVR_DBG_ERROR, "MMU_Create: ERROR call to _AllocPageTables failed"));
-		OSFreeMem (PVRSRV_OS_PAGEABLE_HEAP, 0, pMMUHeap, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(MMU_HEAP),
+				pMMUHeap, IMG_NULL);
 		return IMG_NULL;
 	}
 
@@ -1222,7 +1223,8 @@ MMU_Create (MMU_CONTEXT *psMMUContext,
 	{
 		PVR_DPF((PVR_DBG_ERROR, "MMU_Create: ERROR call to RA_Create failed"));
 		_DeferredFreePageTables (pMMUHeap);
-		OSFreeMem (PVRSRV_OS_PAGEABLE_HEAP, 0, pMMUHeap, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(MMU_HEAP),
+				pMMUHeap, IMG_NULL);
 		return IMG_NULL;
 	}
 
@@ -1279,7 +1281,8 @@ MMU_Delete (MMU_HEAP *pMMUHeap)
 		DisableHostAccess(pMMUHeap->psMMUContext);
 #endif
 
-		OSFreeMem (PVRSRV_OS_PAGEABLE_HEAP, 0, pMMUHeap, IMG_NULL);
+		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(MMU_HEAP),
+				pMMUHeap, IMG_NULL);
 	}
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/devices/sgx/sgxinfokm.h kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/devices/sgx/sgxinfokm.h
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/devices/sgx/sgxinfokm.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/devices/sgx/sgxinfokm.h	2012-12-16 13:13:01.636330146 +0100
@@ -39,10 +39,12 @@ extern "C" {
 
 #define		SGX_HOSTPORT_PRESENT			0x00000001UL
 
-#define PVRSRV_USSE_EDM_POWMAN_POWEROFF_REQUEST		(1UL << 0)	
-#define PVRSRV_USSE_EDM_POWMAN_POWEROFF_COMPLETE	(1UL << 1)	
-#define PVRSRV_USSE_EDM_POWMAN_POWEROFF_RESTART_IMMEDIATE	(1UL << 2)	
-#define PVRSRV_USSE_EDM_POWMAN_NO_WORK						(1UL << 3)	
+#define PVRSRV_USSE_EDM_POWMAN_IDLE_REQUEST					(1UL << 0)
+#define PVRSRV_USSE_EDM_POWMAN_POWEROFF_REQUEST				(1UL << 1)
+#define PVRSRV_USSE_EDM_POWMAN_IDLE_COMPLETE				(1UL << 2)
+#define PVRSRV_USSE_EDM_POWMAN_POWEROFF_COMPLETE			(1UL << 3)
+#define PVRSRV_USSE_EDM_POWMAN_POWEROFF_RESTART_IMMEDIATE	(1UL << 4)
+#define PVRSRV_USSE_EDM_POWMAN_NO_WORK						(1UL << 5)
 
 #define PVRSRV_USSE_EDM_INTERRUPT_HWR			(1UL << 0)	
 #define PVRSRV_USSE_EDM_INTERRUPT_ACTIVE_POWER	(1UL << 1)	
@@ -238,8 +240,10 @@ typedef struct _SGX_DEVICE_MAP_
 	
 	IMG_UINT32				ui32IRQ;
 
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
 	
 	SGX_TIMING_INFORMATION	sTimingInfo;
+#endif
 } SGX_DEVICE_MAP;
 
 
@@ -273,6 +277,10 @@ PVRSRV_ERROR SGXRegisterDevice (PVRSRV_D
 
 IMG_VOID SGXOSTimer(IMG_VOID *pvData);
 
+#if defined(SGX_DYNAMIC_TIMING_INFO)
+IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *psSGXTimingInfo);
+#endif
+
 #if defined(NO_HARDWARE)
 static INLINE IMG_VOID NoHardwareGenerateEvent(PVRSRV_SGXDEV_INFO		*psDevInfo,
 												IMG_UINT32 ui32StatusRegister,
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/devices/sgx/sgxinit.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/devices/sgx/sgxinit.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/devices/sgx/sgxinit.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/devices/sgx/sgxinit.c	2012-12-16 13:13:01.636330146 +0100
@@ -25,6 +25,8 @@
  ******************************************************************************/
 
 #include <stddef.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
 
 #include "sgxdefs.h"
 #include "sgxmmu.h"
@@ -60,6 +62,42 @@ static PVRSRV_ERROR SGXInitialise(PVRSRV
 								  IMG_BOOL				bHardwareRecovery);
 PVRSRV_ERROR SGXDeinitialise(IMG_HANDLE hDevCookie);
 
+typedef enum _PVR_DEVICE_POWER_STATE_ {
+	PVR_DEVICE_POWER_STATE_ON		= 0,
+	PVR_DEVICE_POWER_STATE_IDLE		= 1,
+	PVR_DEVICE_POWER_STATE_OFF		= 2,
+
+	PVR_DEVICE_POWER_STATE_FORCE_I32 = 0x7fffffff
+
+} PVR_DEVICE_POWER_STATE, *PPVR_DEVICE_POWER_STATE;
+
+
+static PVR_DEVICE_POWER_STATE MapDevicePowerState(PVR_POWER_STATE	ePowerState)
+{
+	PVR_DEVICE_POWER_STATE eDevicePowerState;
+
+	switch (ePowerState) {
+	case PVRSRV_POWER_STATE_D0:
+		{
+			eDevicePowerState = PVR_DEVICE_POWER_STATE_ON;
+			break;
+		}
+	case PVRSRV_POWER_STATE_D3:
+		{
+			eDevicePowerState = PVR_DEVICE_POWER_STATE_OFF;
+			break;
+		}
+	default:
+		{
+			PVR_DPF((PVR_DBG_ERROR, "MapDevicePowerState: Invalid state: %ld", ePowerState));
+			eDevicePowerState = PVR_DEVICE_POWER_STATE_FORCE_I32;
+			PVR_ASSERT(eDevicePowerState != PVR_DEVICE_POWER_STATE_FORCE_I32);
+		}
+	}
+
+	return eDevicePowerState;
+}
+
 
 static IMG_VOID SGXCommandComplete(PVRSRV_DEVICE_NODE *psDeviceNode)
 {
@@ -164,230 +202,318 @@ failed_allockernelccb:
 	return eError;
 }
 
+static IMG_VOID SGXGetTimingInfo(PVRSRV_DEVICE_NODE	*psDeviceNode)
+{
+	PVRSRV_SGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
+#if defined(SGX_DYNAMIC_TIMING_INFO)
+	SGX_TIMING_INFORMATION	sSGXTimingInfo = {0};
+#else
+	SGX_DEVICE_MAP		*psSGXDeviceMap;
+#endif
+	IMG_UINT32		ui32ActivePowManSampleRate;
+	SGX_TIMING_INFORMATION	*psSGXTimingInfo;
+
+
+#if defined(SGX_DYNAMIC_TIMING_INFO)
+	psSGXTimingInfo = &sSGXTimingInfo;
+	SysGetSGXTimingInformation(psSGXTimingInfo);
+#else
+	SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE_SGX,
+						(IMG_VOID **)&psSGXDeviceMap);
+	psSGXTimingInfo = &psSGXDeviceMap->sTimingInfo;
+#endif
+
+#if defined(SUPPORT_HW_RECOVERY)
+	{
+		PVRSRV_ERROR			eError;
+		IMG_UINT32	ui32OlduKernelFreq;
+
+		if (psDevInfo->hTimer != IMG_NULL) {
+			ui32OlduKernelFreq = psDevInfo->ui32CoreClockSpeed / psDevInfo->ui32uKernelTimerClock;
+			if (ui32OlduKernelFreq != psSGXTimingInfo->ui32uKernelFreq) {
+				eError = OSRemoveTimer(psDevInfo->hTimer);
+				if (eError != PVRSRV_OK) {
+					PVR_DPF((PVR_DBG_ERROR, "SGXGetTimingInfo: Failed to remove timer"));
+				}
+				psDevInfo->hTimer = IMG_NULL;
+			}
+		}
+		if (psDevInfo->hTimer == IMG_NULL) {
+
+			psDevInfo->hTimer = OSAddTimer(SGXOSTimer, psDeviceNode,
+										1000 * 50 / psSGXTimingInfo->ui32uKernelFreq);
+			if (psDevInfo->hTimer == IMG_NULL) {
+				PVR_DPF((PVR_DBG_ERROR, "SGXGetTimingInfo : Failed to register timer callback function"));
+			}
+		}
+
+		psDevInfo->psSGXHostCtl->ui32HWRecoverySampleRate =
+			psSGXTimingInfo->ui32uKernelFreq / psSGXTimingInfo->ui32HWRecoveryFreq;
+	}
+#endif
+
+
+	psDevInfo->ui32CoreClockSpeed = psSGXTimingInfo->ui32CoreClockSpeed;
+	psDevInfo->ui32uKernelTimerClock = psSGXTimingInfo->ui32CoreClockSpeed / psSGXTimingInfo->ui32uKernelFreq;
+
+	ui32ActivePowManSampleRate =
+		psSGXTimingInfo->ui32uKernelFreq * psSGXTimingInfo->ui32ActivePowManLatencyms / 1000;
+	ui32ActivePowManSampleRate += 1;
+	psDevInfo->psSGXHostCtl->ui32ActivePowManSampleRate = ui32ActivePowManSampleRate;
+}
+
+
 
-static IMG_VOID SGXStartTimer(PVRSRV_SGXDEV_INFO	*psDevInfo)
+static IMG_VOID SGXStartTimer(PVRSRV_SGXDEV_INFO	*psDevInfo,
+							  IMG_BOOL				bStartOSTimer)
 {
-	IMG_UINT32 ui32RegVal = EUR_CR_EVENT_TIMER_ENABLE_MASK | psDevInfo->ui32uKernelTimerClock;
+	IMG_UINT32		ui32RegVal;
+
+	#if !defined(SUPPORT_HW_RECOVERY)
+	PVR_UNREFERENCED_PARAMETER(bStartOSTimer);
+	#endif
+
+
+	ui32RegVal = EUR_CR_EVENT_TIMER_ENABLE_MASK | psDevInfo->ui32uKernelTimerClock;
 	OSWriteHWReg(psDevInfo->pvRegsBaseKM, EUR_CR_EVENT_TIMER, ui32RegVal);
 	PDUMPREGWITHFLAGS(EUR_CR_EVENT_TIMER, ui32RegVal, PDUMP_FLAGS_CONTINUOUS);
-}
 
+	#if defined(SUPPORT_HW_RECOVERY)
+	if (bStartOSTimer) {
+		PVRSRV_ERROR	eError;
+		eError = OSEnableTimer(psDevInfo->hTimer);
+		if (eError != PVRSRV_OK) {
+			PVR_DPF((PVR_DBG_ERROR, "SGXStartTimer : Failed to enable host timer"));
+		}
+	}
+	#endif
+}
 
-PVRSRV_ERROR SGXPrePowerState (IMG_HANDLE		hDevHandle, 
-							   PVR_POWER_STATE	eNewPowerState, 
-							   PVR_POWER_STATE	eCurrentPowerState)
+static PVRSRV_ERROR SGXPrePowerState(IMG_HANDLE				hDevHandle,
+									PVR_DEVICE_POWER_STATE	eNewPowerState,
+									PVR_DEVICE_POWER_STATE	eCurrentPowerState)
 {
-	if (eNewPowerState != eCurrentPowerState)
+	if ((eNewPowerState != eCurrentPowerState) &&
+		(eNewPowerState != PVR_DEVICE_POWER_STATE_ON))
 	{
-		PVRSRV_DEVICE_NODE *psDeviceNode = (PVRSRV_DEVICE_NODE *)hDevHandle;
-		PVRSRV_SGXDEV_INFO *psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
-
-		
-
+		PVRSRV_ERROR		eError;
+		PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
+		PVRSRV_SGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
+		PVRSRV_SGX_HOST_CTL *psSGXHostCtl = psDevInfo->psSGXHostCtl;
+		IMG_UINT32			ui32PowManRequest, ui32PowManComplete;
 
-		if (eNewPowerState == PVRSRV_POWER_STATE_D3)
+		#if defined(SUPPORT_HW_RECOVERY)
+		eError = OSDisableTimer(psDevInfo->hTimer);
+		if (eError != PVRSRV_OK)
 		{
-			PVRSRV_SGX_HOST_CTL *psSGXHostCtl = psDevInfo->psSGXHostCtl;
+			PVR_DPF((PVR_DBG_ERROR, "SGXPrePowerState: Failed to disable timer"));
+			return eError;
+		}
+		#endif
 
-            #if defined (SGX_FEATURE_AUTOCLOCKGATING) && (!defined(NO_HARDWARE) || defined(PDUMP))
-			IMG_UINT32 ui32ClockMask = psDevInfo->ui32ClkGateStatusMask;
-			#endif
+		if (eNewPowerState == PVR_DEVICE_POWER_STATE_OFF) {
+			ui32PowManRequest = PVRSRV_USSE_EDM_POWMAN_POWEROFF_REQUEST;
+			ui32PowManComplete = PVRSRV_USSE_EDM_POWMAN_POWEROFF_COMPLETE;
+			PDUMPCOMMENT("TA/3D CCB Control - SGX power off request");
+		} else {
+			ui32PowManRequest = PVRSRV_USSE_EDM_POWMAN_IDLE_REQUEST;
+			ui32PowManComplete = PVRSRV_USSE_EDM_POWMAN_IDLE_COMPLETE;
+			PDUMPCOMMENT("TA/3D CCB Control - SGX idle request");
+		}
 
-#if defined(SUPPORT_HW_RECOVERY)
-			
-			if (OSDisableTimer(psDevInfo->hTimer) != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,"SGXPrePowerState: Failed to disable timer"));
-				return 	PVRSRV_ERROR_GENERIC;
-			}
-#endif 
+		psSGXHostCtl->ui32PowManFlags |= ui32PowManRequest;
+		#if defined(PDUMP)
+		PDUMPMEM(IMG_NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
+				 offsetof(PVRSRV_SGX_HOST_CTL, ui32PowManFlags),
+				 sizeof(IMG_UINT32), PDUMP_FLAGS_CONTINUOUS,
+				 MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
+		#endif
+
+		#if !defined(NO_HARDWARE)
+		if (PollForValueKM(&psSGXHostCtl->ui32PowManFlags,
+							ui32PowManComplete,
+							ui32PowManComplete,
+							MAX_HW_TIME_US/WAIT_TRY_COUNT,
+							WAIT_TRY_COUNT) != PVRSRV_OK) {
+			PVR_DPF((PVR_DBG_ERROR, "SGXPrePowerState: Wait for SGX ukernel power transition failed."));
+		}
+		#endif
 
-			
-			psSGXHostCtl->ui32PowManFlags |= PVRSRV_USSE_EDM_POWMAN_POWEROFF_REQUEST;
+		#if defined(PDUMP)
+		PDUMPCOMMENT("TA/3D CCB Control - Wait for power event on uKernel.");
+		PDUMPMEMPOL(psDevInfo->psKernelSGXHostCtlMemInfo,
+					offsetof(PVRSRV_SGX_HOST_CTL, ui32PowManFlags),
+					ui32PowManComplete,
+					ui32PowManComplete,
+					PDUMP_POLL_OPERATOR_EQUAL,
+					IMG_FALSE, IMG_FALSE,
+					MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
+		#endif
 
-			
-			PDUMPCOMMENT("TA/3D CCB Control - Trigger power down event on uKernel...");
-			PDUMPMEM(IMG_NULL, psDevInfo->psKernelSGXHostCtlMemInfo, offsetof(PVRSRV_SGX_HOST_CTL, ui32PowManFlags), sizeof(IMG_UINT32), PDUMP_FLAGS_CONTINUOUS, MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
+		#if defined(SGX_FEATURE_AUTOCLOCKGATING)
 
-			
+		{
 			#if !defined(NO_HARDWARE)
-			if (PollForValueKM((volatile IMG_UINT32 *)(&psSGXHostCtl->ui32PowManFlags),
-								PVRSRV_USSE_EDM_POWMAN_POWEROFF_COMPLETE,
-								PVRSRV_USSE_EDM_POWMAN_POWEROFF_COMPLETE,
+			if (PollForValueKM((IMG_UINT32 *)psDevInfo->pvRegsBaseKM + (EUR_CR_CLKGATESTATUS >> 2),
+								0,
+								psDevInfo->ui32ClkGateStatusMask,
 								MAX_HW_TIME_US/WAIT_TRY_COUNT,
 								WAIT_TRY_COUNT) != PVRSRV_OK)
 			{
-				PVR_DPF((PVR_DBG_ERROR,"SGXPrePowerState: Wait for chip power off failed."));
+				PVR_DPF((PVR_DBG_ERROR, "SGXPrePowerState: Wait for SGX clock gating failed."));
 			}
 			#endif
-
-			#ifdef PDUMP
 			
-			PDUMPCOMMENT("TA/3D CCB Control - Wait for power down event on uKernel...");
-			PDUMPMEMPOL(psDevInfo->psKernelSGXHostCtlMemInfo,
-						offsetof(PVRSRV_SGX_HOST_CTL, ui32PowManFlags),
-						PVRSRV_USSE_EDM_POWMAN_POWEROFF_COMPLETE,
-						PVRSRV_USSE_EDM_POWMAN_POWEROFF_COMPLETE,
-						PDUMP_POLL_OPERATOR_EQUAL,
-						IMG_FALSE, IMG_FALSE,
-						MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
-			#endif
-
-			SGXDeinitialise(psDevInfo);
+			PDUMPCOMMENT("Wait for SGX clock gating.");
+			PDUMPREGPOL(EUR_CR_CLKGATESTATUS, 0, psDevInfo->ui32ClkGateStatusMask);
+		}
+		#endif
 
-			#if defined(SGX_FEATURE_AUTOCLOCKGATING)
-			
-			#if !defined(NO_HARDWARE)
-			if (PollForValueKM((volatile IMG_UINT32 *)((IMG_UINT8*)psDevInfo->pvRegsBaseKM + EUR_CR_CLKGATESTATUS),
-								0,
-								ui32ClockMask,
-								MAX_HW_TIME_US/WAIT_TRY_COUNT,
-								WAIT_TRY_COUNT) != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,"SGXPrePowerState: Wait for chip idle failed."));
+		if (eNewPowerState == PVR_DEVICE_POWER_STATE_OFF) {
+			eError = SGXDeinitialise(psDevInfo);
+			if (eError != PVRSRV_OK) {
+				PVR_DPF((PVR_DBG_ERROR, "SGXPrePowerState: SGXDeinitialise failed: %lu", eError));
+				return eError;
 			}
-			#endif
-			PDUMPREGPOL(EUR_CR_CLKGATESTATUS, 0, ui32ClockMask);
-			#endif
 		}
 	}
 
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR SGXPostPowerState (IMG_HANDLE		hDevHandle, 
-								PVR_POWER_STATE	eNewPowerState, 
-								PVR_POWER_STATE	eCurrentPowerState)
+static PVRSRV_ERROR SGXPostPowerState(IMG_HANDLE				hDevHandle,
+									PVR_DEVICE_POWER_STATE	eNewPowerState,
+									PVR_DEVICE_POWER_STATE	eCurrentPowerState)
 {
-	if (eNewPowerState != eCurrentPowerState)
+	if ((eNewPowerState != eCurrentPowerState) &&
+		(eCurrentPowerState != PVR_DEVICE_POWER_STATE_ON))
 	{
 		PVRSRV_ERROR		eError;
-		PVRSRV_DEVICE_NODE *psDeviceNode = (PVRSRV_DEVICE_NODE *)hDevHandle;
-		PVRSRV_SGXDEV_INFO *psDevInfo = (PVRSRV_SGXDEV_INFO*)psDeviceNode->pvDevice;
-		SYS_DATA			*psSysData;
+		PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
+		PVRSRV_SGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
+		PVRSRV_SGX_HOST_CTL *psSGXHostCtl = psDevInfo->psSGXHostCtl;
 
-		
 
-		eError = SysAcquireData(&psSysData);
-		if (eError != PVRSRV_OK)
-		{
-			return eError;
-		}
-		
+		psSGXHostCtl->ui32PowManFlags = 0;
+		PDUMPCOMMENT("TA/3D CCB Control - Reset Power Manager flags");
+		#if defined(PDUMP)
+		PDUMPMEM(IMG_NULL, psDevInfo->psKernelSGXHostCtlMemInfo,
+				 offsetof(PVRSRV_SGX_HOST_CTL, ui32PowManFlags),
+				 sizeof(IMG_UINT32), PDUMP_FLAGS_CONTINUOUS,
+				 MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
+		#endif
+
 		
 
-		if(eCurrentPowerState == PVRSRV_POWER_STATE_D3)
+		if (eCurrentPowerState == PVR_DEVICE_POWER_STATE_OFF)
 		{
-			PVRSRV_SGX_HOST_CTL *psSGXHostCtl = psDevInfo->psSGXHostCtl;
 			
-			psSGXHostCtl->ui32PowManFlags = 0;
+
+			SGXGetTimingInfo(psDeviceNode);
 
 			
-			PDUMPCOMMENT("TA/3D CCB Control - Reset Power Manager flags");
-			PDUMPMEM(IMG_NULL, psDevInfo->psKernelSGXHostCtlMemInfo, offsetof(PVRSRV_SGX_HOST_CTL, ui32PowManFlags), sizeof(IMG_UINT32), PDUMP_FLAGS_CONTINUOUS, MAKEUNIQUETAG(psDevInfo->psKernelSGXHostCtlMemInfo));
 
 			eError = SGXInitialise(psDevInfo, IMG_FALSE);
-
 			if (eError != PVRSRV_OK)
 			{
 				PVR_DPF((PVR_DBG_ERROR,"SGXPostPowerState: SGXInitialise failed"));
 				return eError;
 			}
-#if defined(SUPPORT_HW_RECOVERY)
-			eError = OSEnableTimer(psDevInfo->hTimer);
-			if (eError != PVRSRV_OK)
-			{
-				PVR_DPF((PVR_DBG_ERROR,"SGXPostPowerState : Failed to enable host timer"));
-				return PVRSRV_ERROR_GENERIC;
-			}
-#endif
 		}
-
-		PVR_DPF((PVR_DBG_WARNING,
-				"SGXPostPowerState : SGX Power Transition from %d to %d OK",
-				eCurrentPowerState, eNewPowerState));
 	}
 
 	return PVRSRV_OK;
 }
 
-
-static IMG_VOID SGXGetTimingInfo(PVRSRV_SGXDEV_INFO		*psDevInfo,
-								 SGX_TIMING_INFORMATION	*psSGXTimingInfo)
+PVRSRV_ERROR SGXPrePowerStateExt (IMG_HANDLE		hDevHandle,
+								PVR_POWER_STATE	eNewPowerState,
+								PVR_POWER_STATE	eCurrentPowerState)
 {
-	IMG_UINT32	ui32ActivePowManSampleRate;
-	
-	
-	psDevInfo->ui32CoreClockSpeed = psSGXTimingInfo->ui32CoreClockSpeed;
-	psDevInfo->ui32uKernelTimerClock = psSGXTimingInfo->ui32CoreClockSpeed / psSGXTimingInfo->ui32uKernelFreq;
-
-#if defined(SUPPORT_HW_RECOVERY)
-	psDevInfo->psSGXHostCtl->ui32HWRecoverySampleRate =
-		psSGXTimingInfo->ui32uKernelFreq / psSGXTimingInfo->ui32HWRecoveryFreq;
-#endif 
-
-	ui32ActivePowManSampleRate =
-		psSGXTimingInfo->ui32uKernelFreq * psSGXTimingInfo->ui32ActivePowManLatencyms / 1000;
-	
+	PVR_DEVICE_POWER_STATE	eNewDevicePowerState = MapDevicePowerState(eNewPowerState);
+	PVR_DEVICE_POWER_STATE	eCurrentDevicePowerState = MapDevicePowerState(eCurrentPowerState);
 
+	return SGXPrePowerState(hDevHandle, eNewDevicePowerState, eCurrentDevicePowerState);
+}
 
 
+PVRSRV_ERROR SGXPostPowerStateExt (IMG_HANDLE		hDevHandle,
+								PVR_POWER_STATE	eNewPowerState,
+								PVR_POWER_STATE	eCurrentPowerState)
+{
+	PVRSRV_ERROR			eError;
+	PVR_DEVICE_POWER_STATE	eNewDevicePowerState = MapDevicePowerState(eNewPowerState);
+	PVR_DEVICE_POWER_STATE	eCurrentDevicePowerState = MapDevicePowerState(eCurrentPowerState);
 
+	eError = SGXPostPowerState(hDevHandle, eNewDevicePowerState, eCurrentDevicePowerState);
+	if (eError != PVRSRV_OK) {
+		return eError;
+	}
 
+	PVR_DPF((PVR_DBG_WARNING,
+			"SGXPostPowerState : SGX Power Transition from %d to %d OK",
+			eCurrentPowerState, eNewPowerState));
 
-	
-	ui32ActivePowManSampleRate += 1;
-	
-	psDevInfo->psSGXHostCtl->ui32ActivePowManSampleRate = ui32ActivePowManSampleRate;
+	return eError;
 }
 
 
 static PVRSRV_ERROR SGXPreClockSpeedChange (IMG_HANDLE		hDevHandle,
-											IMG_BOOL		bIdleDevice)
+											IMG_BOOL		bIdleDevice,
+											PVR_POWER_STATE	eCurrentPowerState)
 {
 	PVRSRV_ERROR		eError;
 	PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
 	PVRSRV_SGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
-	SGX_DEVICE_MAP		*psSGXDeviceMap;
 
-	eError = SysGetDeviceMemoryMap(PVRSRV_DEVICE_TYPE_SGX,
-								   (IMG_VOID**)&psSGXDeviceMap);
-	if (eError != PVRSRV_OK)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM: Failed to get device memory map!"));
-		return PVRSRV_ERROR_INIT_FAILURE;
-	}
-	
-	if (bIdleDevice)
+	PVR_UNREFERENCED_PARAMETER(psDevInfo);
+
+	if (eCurrentPowerState == PVRSRV_POWER_STATE_D0)
 	{
-		
-	}
-	
-	
+		if (bIdleDevice) {
+
+			eError = SGXPrePowerState(hDevHandle, PVR_DEVICE_POWER_STATE_IDLE,
+									  PVR_DEVICE_POWER_STATE_ON);
 
-	SGXGetTimingInfo(psDevInfo, &psSGXDeviceMap->sTimingInfo);
+			if (eError != PVRSRV_OK) {
+				return eError;
+			}
+		}
+	}
 
-	PVR_DPF((PVR_DBG_MESSAGE,"SGXPreClockSpeedChange: SGX clock speed now %luHz",
+	PVR_DPF((PVR_DBG_MESSAGE, "SGXPreClockSpeedChange: SGX clock speed was %luHz",
 			psDevInfo->ui32CoreClockSpeed));
 
 	return PVRSRV_OK;
 }
 
 
-static PVRSRV_ERROR SGXPostClockSpeedChange (IMG_HANDLE		hDevHandle,
-											 IMG_BOOL		bIdleDevice)
+static PVRSRV_ERROR SGXPostClockSpeedChange(IMG_HANDLE			hDevHandle,
+											 IMG_BOOL			bIdleDevice,
+											 PVR_POWER_STATE	eCurrentPowerState)
 {
-	PVRSRV_DEVICE_NODE *psDeviceNode = hDevHandle;
-	PVRSRV_SGXDEV_INFO *psDevInfo = psDeviceNode->pvDevice;
+	PVRSRV_ERROR		eError = PVRSRV_OK;
+	PVRSRV_DEVICE_NODE	*psDeviceNode = hDevHandle;
+	PVRSRV_SGXDEV_INFO	*psDevInfo = psDeviceNode->pvDevice;
+	IMG_UINT32			ui32OldClockSpeed = psDevInfo->ui32CoreClockSpeed;
 
-	if (bIdleDevice)
-	{
-		
-	}
-	else
+	PVR_UNREFERENCED_PARAMETER(ui32OldClockSpeed);
+
+	if (eCurrentPowerState == PVRSRV_POWER_STATE_D0)
 	{
-		SGXStartTimer(psDevInfo);
+		SGXGetTimingInfo(psDeviceNode);
+		if (bIdleDevice) {
+			eError = SGXPostPowerState(hDevHandle, PVR_DEVICE_POWER_STATE_ON,
+									PVR_DEVICE_POWER_STATE_IDLE);
+
+			if (eError != PVRSRV_OK) {
+				return eError;
+			}
+		}
+		SGXStartTimer(psDevInfo, IMG_TRUE);
 	}
+
+	PVR_DPF((PVR_DBG_MESSAGE, "SGXPostClockSpeedChange: SGX clock speed changed from %luHz to %luHz",
+			ui32OldClockSpeed, psDevInfo->ui32CoreClockSpeed));
 	
 	return PVRSRV_OK;
 }
@@ -500,7 +626,7 @@ static PVRSRV_ERROR SGXInitialise(PVRSRV
 		return (PVRSRV_ERROR_GENERIC);
 	}
 	
-	SGXStartTimer(psDevInfo);
+	SGXStartTimer(psDevInfo, !bHardwareRecovery);
 	
 	if (bHardwareRecovery)
 	{
@@ -757,8 +883,6 @@ PVRSRV_ERROR DevInitSGXPart2KM (PVRSRV_P
 #endif
 
 
-	SGXGetTimingInfo(psDevInfo, &psSGXDeviceMap->sTimingInfo);
-
 #if defined (SYS_USING_INTERRUPTS)
 
 	
@@ -777,7 +901,7 @@ PVRSRV_ERROR DevInitSGXPart2KM (PVRSRV_P
 	eDefaultPowerState = PVRSRV_POWER_STATE_D0;
 #endif 
 	eError = PVRSRVRegisterPowerDevice (psDeviceNode->sDevId.ui32DeviceIndex,
-										SGXPrePowerState, SGXPostPowerState,
+										SGXPrePowerStateExt, SGXPostPowerStateExt,
 										SGXPreClockSpeedChange, SGXPostClockSpeedChange,
 										(IMG_HANDLE)psDeviceNode,
 										PVRSRV_POWER_STATE_D3,
@@ -802,19 +926,6 @@ PVRSRV_ERROR DevInitSGXPart2KM (PVRSRV_P
 	PDUMPCOMMENT("Kernel CCB Event Kicker");
 	PDUMPMEM(IMG_NULL, psDevInfo->psKernelCCBEventKickerMemInfo, 0, sizeof(*psDevInfo->pui32KernelCCBEventKicker), PDUMP_FLAGS_CONTINUOUS, MAKEUNIQUETAG(psDevInfo->psKernelCCBEventKickerMemInfo));
 
-#if defined(SUPPORT_HW_RECOVERY)
-	
-
-
-	psDevInfo->hTimer = OSAddTimer(SGXOSTimer, psDeviceNode,
-								   1000 * 50 / psSGXDeviceMap->sTimingInfo.ui32uKernelFreq);
-	if(psDevInfo->hTimer == IMG_NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR,"DevInitSGXPart2KM : Failed to register timer callback function"));
-		return PVRSRV_ERROR_GENERIC;
-	}
-#endif
-
 	return PVRSRV_OK;
 
 failed_init_dev_info:
@@ -1025,6 +1136,23 @@ IMG_VOID HWRecoveryResetSGX (PVRSRV_DEVI
 }
 #endif 
 
+static struct workdata
+{
+	PVRSRV_DEVICE_NODE *psDeviceNode;
+	IMG_UINT32 ui32Component;
+	IMG_UINT32 ui32CallerID;
+} gHWRecoveryParams;
+
+
+static void HWRecoveryWrapper(struct work_struct *work)
+{
+	HWRecoveryResetSGX(gHWRecoveryParams.psDeviceNode,
+			gHWRecoveryParams.ui32Component,
+			gHWRecoveryParams.ui32CallerID);
+}
+DECLARE_WORK(gWork, HWRecoveryWrapper);
+
+
 
 #if defined(SUPPORT_HW_RECOVERY)
 IMG_VOID SGXOSTimer(IMG_VOID *pvData)
@@ -1084,8 +1212,14 @@ IMG_VOID SGXOSTimer(IMG_VOID *pvData)
 		
 		psSGXHostCtl->ui32HostDetectedLockups ++;
 
-		
-		HWRecoveryResetSGX(psDeviceNode, 0, KERNEL_ID);
+		/*
+		 * schedule HWRecoveryResetSGX from a work
+		 * in the shared queue
+		 */
+		gHWRecoveryParams.psDeviceNode = psDeviceNode;
+		gHWRecoveryParams.ui32Component = 0;
+		gHWRecoveryParams.ui32CallerID = TIMER_ID;
+		schedule_work(&gWork);
 	}
 }
 #endif 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/env_data.h kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/env_data.h
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/env_data.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/env_data.h	2012-12-16 13:13:01.636330146 +0100
@@ -29,6 +29,7 @@
 
 #include <linux/interrupt.h>
 #include <linux/pci.h>
+#include <linux/workqueue.h>
 
 #define PVRSRV_MAX_BRIDGE_IN_SIZE	0x1000
 #define PVRSRV_MAX_BRIDGE_OUT_SIZE	0x1000
@@ -48,7 +49,11 @@ typedef struct _ENV_DATA_TAG
 	IMG_BOOL		bMISRInstalled;
 	IMG_UINT32		ui32IRQ;
 	IMG_VOID		*pvISRCookie;
-	struct tasklet_struct	sMISRTasklet;
+	struct workqueue_struct	*psMISRWorkqueue;
+	struct work_struct	sMISRWork;
+	struct workqueue_struct *psPerfWorkqueue;
+	struct delayed_work	sPerfWork;
+	IMG_VOID		*pvSysData; /*for MISR work*/
 } ENV_DATA;
 
 #endif 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/event.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/event.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/event.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/event.c	2012-12-16 13:13:01.636330146 +0100
@@ -72,7 +72,7 @@ typedef struct PVRSRV_LINUX_EVENT_OBJECT
 {
    	atomic_t	sTimeStamp;
    	IMG_UINT32  ui32TimeStampPrevious;
-#if DEBUG
+#ifdef DEBUG
 	unsigned int ui32Stats;
 #endif
     wait_queue_head_t sWait;	
@@ -126,7 +126,7 @@ PVRSRV_ERROR LinuxEventObjectDelete(IMG_
 		if(hOSEventObject)
 		{
 			PVRSRV_LINUX_EVENT_OBJECT *psLinuxEventObject = (PVRSRV_LINUX_EVENT_OBJECT *)hOSEventObject; 
-#if DEBUG
+#ifdef DEBUG
 			PVR_DPF((PVR_DBG_MESSAGE, "LinuxEventObjectListDelete: Event object waits: %lu", psLinuxEventObject->ui32Stats));
 #endif
 			if(ResManFreeResByPtr(psLinuxEventObject->hResItem) != PVRSRV_OK)
@@ -150,7 +150,7 @@ static PVRSRV_ERROR LinuxEventObjectDele
 	list_del(&psLinuxEventObject->sList);
 	write_unlock_bh(&psLinuxEventObjectList->sLock);
 
-#if DEBUG
+#ifdef DEBUG
 	PVR_DPF((PVR_DBG_MESSAGE, "LinuxEventObjectDeleteCallback: Event object waits: %lu", psLinuxEventObject->ui32Stats));
 #endif	
 
@@ -185,7 +185,7 @@ PVRSRV_ERROR LinuxEventObjectAdd(IMG_HAN
 	atomic_set(&psLinuxEventObject->sTimeStamp, 0);
 	psLinuxEventObject->ui32TimeStampPrevious = 0;
 
-#if DEBUG	
+#ifdef DEBUG	
 	psLinuxEventObject->ui32Stats = 0;
 #endif
     init_waitqueue_head(&psLinuxEventObject->sWait);
@@ -248,7 +248,7 @@ PVRSRV_ERROR LinuxEventObjectWait(IMG_HA
 
 		ui32TimeOutJiffies = schedule_timeout(ui32TimeOutJiffies);
 		
-#if DEBUG			
+#ifdef DEBUG			
 		psLinuxEventObject->ui32Stats++;
 #endif			
 		LinuxLockMutex(&gPVRSRVLock);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/mmap.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/mmap.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/mmap.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/mmap.c	2012-12-16 13:13:01.636330146 +0100
@@ -53,7 +53,6 @@
 #include "pvr_debug.h"
 #include "osfunc.h"
 #include "proc.h"
-#include "mutex.h"
 
 
 static PKV_OFFSET_STRUCT FindOffsetStructFromLinuxMemArea(LinuxMemArea *psLinuxMemArea);
@@ -69,6 +68,8 @@ static IMG_BOOL DoMapToUser(LinuxMemArea
                             struct vm_area_struct* ps_vma,
                             IMG_UINT32 ui32ByteOffset,
                             IMG_UINT32 ui32Size);
+static IMG_BOOL CheckSize(LinuxMemArea *psLinuxMemArea,
+		IMG_UINT32 ui32Size);
 
 #if defined(DEBUG_LINUX_MMAP_AREAS)
 static off_t PrintMMapRegistrations(char * buffer, size_t size, off_t off);
@@ -85,7 +86,6 @@ static struct vm_operations_struct MMapI
 };
 
 
-extern PVRSRV_LINUX_MUTEX gPVRSRVLock;
 
 static PKV_OFFSET_STRUCT g_psKVOffsetTable = 0;
 static LinuxKMemCache *g_psMemmapCache = 0;
@@ -94,6 +94,7 @@ static IMG_UINT32 g_ui32RegisteredAreas
 static IMG_UINT32 g_ui32TotalByteSize = 0;
 #endif
 
+static struct rw_semaphore g_mmap_sem;
 
 
 IMG_VOID
@@ -112,6 +113,7 @@ PVRMMapInit(IMG_VOID)
     {
         PVR_DPF((PVR_DBG_ERROR,"%s: failed to allocate kmem_cache", __FUNCTION__));
     }
+	init_rwsem(&g_mmap_sem);
 }
 
 
@@ -152,25 +154,27 @@ PVRMMapRegisterArea(const IMG_CHAR *pszN
                     IMG_UINT32 ui32AllocFlags)
 {
     PKV_OFFSET_STRUCT psOffsetStruct;
-    
+	PVRSRV_ERROR iError = PVRSRV_OK;
     PVR_DPF((PVR_DBG_MESSAGE,
              "%s(%s, psLinuxMemArea=%p, ui32AllocFlags=0x%8lx)",
              __FUNCTION__, pszName, psLinuxMemArea, ui32AllocFlags));
 
-    
+	down_write(&g_mmap_sem);
     psOffsetStruct = FindOffsetStructFromLinuxMemArea(psLinuxMemArea);
     if(psOffsetStruct)
     {
         PVR_DPF((PVR_DBG_ERROR, "PVRMMapRegisterArea: psLinuxMemArea=%p is already registered",
                 psOffsetStruct->psLinuxMemArea));
-        return PVRSRV_ERROR_INVALID_PARAMS;
+	iError = PVRSRV_ERROR_INVALID_PARAMS;
+	goto register_exit;
     }
 
     psOffsetStruct = KMemCacheAllocWrapper(g_psMemmapCache, GFP_KERNEL);
     if(!psOffsetStruct)
     {
         PVR_DPF((PVR_DBG_ERROR,"PVRMMapRegisterArea: Couldn't alloc another mapping record from cache"));
-        return PVRSRV_ERROR_OUT_OF_MEMORY;
+	iError = PVRSRV_ERROR_OUT_OF_MEMORY;
+	goto register_exit;
     }
     
     
@@ -208,8 +212,9 @@ PVRMMapRegisterArea(const IMG_CHAR *pszN
     psOffsetStruct->psNext					= g_psKVOffsetTable;
     
     g_psKVOffsetTable                         = psOffsetStruct;
-
-    return PVRSRV_OK;
+register_exit:
+	up_write(&g_mmap_sem);
+	return iError;
 }
 
 
@@ -217,7 +222,9 @@ PVRSRV_ERROR
 PVRMMapRemoveRegisteredArea(LinuxMemArea *psLinuxMemArea)
 {
     PKV_OFFSET_STRUCT *ppsOffsetStruct, psOffsetStruct;
-    
+	PVRSRV_ERROR iError = PVRSRV_OK;
+
+	down_write(&g_mmap_sem);
     for(ppsOffsetStruct=&g_psKVOffsetTable;
         (psOffsetStruct = *ppsOffsetStruct);
         ppsOffsetStruct=&(*ppsOffsetStruct)->psNext)
@@ -233,7 +240,8 @@ PVRMMapRemoveRegisteredArea(LinuxMemArea
         PVR_DPF((PVR_DBG_ERROR, "%s: Registration for psLinuxMemArea = 0x%p not found",
                 __FUNCTION__,
                 psLinuxMemArea));
-        return PVRSRV_ERROR_BAD_MAPPING;
+	iError = PVRSRV_ERROR_BAD_MAPPING;
+	goto unregister_exit;
     }
 
 #if defined(DEBUG_LINUX_MMAP_AREAS)
@@ -242,7 +250,8 @@ PVRMMapRemoveRegisteredArea(LinuxMemArea
     {
         PVR_DPF((PVR_DBG_ERROR, "%s: Unregistering still-mapped area! (psLinuxMemArea=0x%p)\n",
                 __FUNCTION__, psOffsetStruct->psLinuxMemArea));
-        return PVRSRV_ERROR_BAD_MAPPING;
+	iError = PVRSRV_ERROR_BAD_MAPPING;
+	goto unregister_exit;
     }
 
     g_ui32RegisteredAreas--;
@@ -262,7 +271,9 @@ PVRMMapRemoveRegisteredArea(LinuxMemArea
  
     KMemCacheFreeWrapper(g_psMemmapCache, psOffsetStruct);
 
-    return PVRSRV_OK;
+unregister_exit:
+	up_write(&g_mmap_sem);
+	return iError;
 }
 
 
@@ -321,11 +332,14 @@ PVRMMapKVIndexAddressToMMapData(IMG_VOID
                                 IMG_UINT32 *pui32RealByteSize)
 {
     PKV_OFFSET_STRUCT psOffsetStruct;
-    
+	PVRSRV_ERROR iError = PVRSRV_OK;
+
+	down_read(&g_mmap_sem);
     psOffsetStruct = FindOffsetStructByKVIndexAddress(pvKVIndexAddress, ui32Size);
     if (!psOffsetStruct)
     {
-        return PVRSRV_ERROR_BAD_MAPPING;
+       iError = PVRSRV_ERROR_BAD_MAPPING;
+       goto indexaddress_exit;
     }
 
     *pui32MMapOffset = psOffsetStruct->ui32MMapOffset;
@@ -335,7 +349,9 @@ PVRMMapKVIndexAddressToMMapData(IMG_VOID
                                    pui32RealByteSize,
                                    pui32ByteOffset);
 
-    return PVRSRV_OK;
+indexaddress_exit:
+	up_read(&g_mmap_sem);
+	return iError;
 }
 
 
@@ -432,12 +448,11 @@ PVRMMap(struct file* pFile, struct vm_ar
 {
 	unsigned long ulBytes;
 	PKV_OFFSET_STRUCT psCurrentRec = NULL;
-    int iRetVal=0;
+	int iRetVal = 0;
 
-    LinuxLockMutex(&gPVRSRVLock);
     
 	ulBytes = ps_vma->vm_end - ps_vma->vm_start;
-    
+	down_read(&g_mmap_sem);
     PVR_DPF((PVR_DBG_MESSAGE, "%s: Recieved mmap(2) request with a ui32MMapOffset=0x%08lx,"
                               " and ui32ByteSize=%ld(0x%08lx)\n",
             __FUNCTION__,
@@ -451,8 +466,8 @@ PVRMMap(struct file* pFile, struct vm_ar
       )
     {
         PVR_DPF((PVR_DBG_ERROR,"PVRMMap: Error - Cannot mmap non-shareable writable areas."));
-        iRetVal = -EINVAL;
-        goto unlock_and_return;
+	iRetVal = -EINVAL;
+	goto pvrmmap_exit;
     }
    
     psCurrentRec=FindOffsetStructByMMapOffset(PFN_TO_PHYS(ps_vma->vm_pgoff));
@@ -461,11 +476,15 @@ PVRMMap(struct file* pFile, struct vm_ar
         PVR_DPF((PVR_DBG_ERROR,
                  "PVRMMap: Error - Attempted to mmap unregistered area at vm_pgoff=%ld",
                  ps_vma->vm_pgoff));
-        iRetVal = -EINVAL;
-        goto unlock_and_return;
+	iRetVal = -EINVAL;
+	goto pvrmmap_exit;
     }
     PVR_DPF((PVR_DBG_MESSAGE, "%s: > psCurrentRec->psLinuxMemArea=%p\n",
              __FUNCTION__, psCurrentRec->psLinuxMemArea));
+    if (!CheckSize(psCurrentRec->psLinuxMemArea, ulBytes)) {
+	iRetVal = -EINVAL;
+	goto pvrmmap_exit;
+    }
     
     ps_vma->vm_flags |= VM_RESERVED;
     ps_vma->vm_flags |= VM_IO;
@@ -516,8 +535,8 @@ PVRMMap(struct file* pFile, struct vm_ar
     
     if(!DoMapToUser(psCurrentRec->psLinuxMemArea, ps_vma, 0, ulBytes))
     {
-        iRetVal = -EAGAIN;
-        goto unlock_and_return;
+	iRetVal = -EAGAIN;
+	goto pvrmmap_exit;
     }
     
     
@@ -525,12 +544,10 @@ PVRMMap(struct file* pFile, struct vm_ar
     
     PVR_DPF((PVR_DBG_MESSAGE, "%s: Mapped area at offset 0x%08lx\n",
              __FUNCTION__, ps_vma->vm_pgoff));
-    
-unlock_and_return:
-    
-    LinuxUnLockMutex(&gPVRSRVLock);
-    
-    return iRetVal;
+
+pvrmmap_exit:
+	up_read(&g_mmap_sem);
+	return iRetVal;
 }
 
 
@@ -607,6 +624,31 @@ DoMapToUser(LinuxMemArea *psLinuxMemArea
     return IMG_TRUE;
 }
 
+static IMG_BOOL
+CheckSize(LinuxMemArea *psLinuxMemArea,
+		IMG_UINT32 ui32ByteSize)
+{
+	IMG_CPU_PHYADDR CpuPAddr;
+	IMG_UINT32 ui32PageAlignmentOffset;
+	IMG_UINT32 ui32RealByteSize;
+	CpuPAddr = LinuxMemAreaToCpuPAddr(psLinuxMemArea, 0);
+	ui32PageAlignmentOffset = ADDR_TO_PAGE_OFFSET(CpuPAddr.uiAddr);
+	ui32RealByteSize =
+		PAGE_ALIGN(psLinuxMemArea->ui32ByteSize + ui32PageAlignmentOffset);
+	if (ui32RealByteSize < ui32ByteSize) {
+		PVR_DPF((PVR_DBG_ERROR,
+			"Cannot mmap %ld bytes from: %-8p %-8p %08lx %-8ld %-24s\n",
+			ui32ByteSize,
+			psLinuxMemArea,
+			LinuxMemAreaToCpuVAddr(psLinuxMemArea),
+			LinuxMemAreaToCpuPAddr(psLinuxMemArea, 0).uiAddr,
+			psLinuxMemArea->ui32ByteSize,
+			LinuxMemAreaTypeToString(psLinuxMemArea->eAreaType)));
+		return IMG_FALSE;
+	}
+	return IMG_TRUE;
+}
+
 
 static void
 MMapVOpen(struct vm_area_struct* ps_vma)
@@ -662,8 +704,7 @@ PrintMMapRegistrations(char * buffer, si
 	PKV_OFFSET_STRUCT psOffsetStruct;
     off_t Ret;
 	
-    LinuxLockMutex(&gPVRSRVLock);
-
+	down_read(&g_mmap_sem);
 	if(!off)
     {
 		Ret = printAppend(buffer, size, 0,
@@ -735,8 +776,7 @@ PrintMMapRegistrations(char * buffer, si
                         HAPFlagsToString(psOffsetStruct->ui32AllocFlags));
 
 unlock_and_return:
-
-    LinuxUnLockMutex(&gPVRSRVLock);
+	up_read(&g_mmap_sem);
     return Ret;
 }
 #endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/module.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/module.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/module.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/module.c	2012-12-16 13:13:01.640330146 +0100
@@ -443,6 +443,8 @@ static int __init PVRCore_Init(void)
 		goto init_failed;
 	}
 
+	powervr_device.dev.devt = MKDEV(AssignedMajorNumber, 0);
+
 	if ((error = platform_device_register(&powervr_device)) != 0)
 	{
 		platform_driver_unregister(&powervr_driver);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/osfunc.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/osfunc.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/osfunc.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/env/linux/osfunc.c	2012-12-16 13:13:01.640330146 +0100
@@ -67,80 +67,83 @@ extern PVRSRV_LINUX_MUTEX gPVRSRVLock;
 #define HOST_ALLOC_MEM_USING_KMALLOC ((IMG_HANDLE)0)
 #define HOST_ALLOC_MEM_USING_VMALLOC ((IMG_HANDLE)1)
 
+#define LINUX_KMALLOC_LIMIT	PAGE_SIZE		/* 4k */
+
 #if !defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-PVRSRV_ERROR OSAllocMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID *ppvCpuVAddr, IMG_HANDLE *phBlockAlloc)
+PVRSRV_ERROR OSAllocMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size,
+			IMG_PVOID *ppvCpuVAddr, IMG_HANDLE *phBlockAlloc)
 #else
-PVRSRV_ERROR _OSAllocMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID *ppvCpuVAddr, IMG_HANDLE *phBlockAlloc, IMG_CHAR *pszFilename, IMG_UINT32 ui32Line)
+PVRSRV_ERROR _OSAllocMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size,
+			 IMG_PVOID *ppvCpuVAddr, IMG_HANDLE *phBlockAlloc,
+			 IMG_CHAR *pszFilename, IMG_UINT32 ui32Line)
 #endif
 {
-    PVR_UNREFERENCED_PARAMETER(ui32Flags);
+	IMG_UINT32 ui32Threshold;
+
+	PVR_UNREFERENCED_PARAMETER(ui32Flags);
+
+	/* determine whether to go straight to vmalloc */
+	ui32Threshold = LINUX_KMALLOC_LIMIT;
 
+	if (ui32Size > ui32Threshold) {
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-    *ppvCpuVAddr = _KMallocWrapper(ui32Size, pszFilename, ui32Line);
+		*ppvCpuVAddr = _VMallocWrapper(ui32Size, PVRSRV_HAP_CACHED,
+					       pszFilename, ui32Line);
 #else
-    *ppvCpuVAddr = KMallocWrapper(ui32Size);
+		*ppvCpuVAddr = VMallocWrapper(ui32Size, PVRSRV_HAP_CACHED);
 #endif
-    if(*ppvCpuVAddr)
-    {
-	if (phBlockAlloc)
-	{
-		
-		*phBlockAlloc = HOST_ALLOC_MEM_USING_KMALLOC;
-	}
-    }
-    else
-    {
-	if (!phBlockAlloc)
-	{
-		return PVRSRV_ERROR_OUT_OF_MEMORY;
-	}
+		if (!*ppvCpuVAddr)
+			return PVRSRV_ERROR_OUT_OF_MEMORY;
+
+		if (phBlockAlloc)
+			*phBlockAlloc = HOST_ALLOC_MEM_USING_VMALLOC;
+	} else {
+		/* default - try kmalloc first */
 
-	
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-	*ppvCpuVAddr = _VMallocWrapper(ui32Size, PVRSRV_HAP_CACHED, pszFilename, ui32Line);
+		*ppvCpuVAddr = _KMallocWrapper(ui32Size, pszFilename, ui32Line);
 #else
-	*ppvCpuVAddr = VMallocWrapper(ui32Size, PVRSRV_HAP_CACHED);
+		*ppvCpuVAddr = KMallocWrapper(ui32Size);
 #endif
-	if (!*ppvCpuVAddr)
-	{
-		 return PVRSRV_ERROR_OUT_OF_MEMORY;
-	}
 
-	
-	*phBlockAlloc = HOST_ALLOC_MEM_USING_VMALLOC;
-    }
+		if (!*ppvCpuVAddr)
+			return PVRSRV_ERROR_OUT_OF_MEMORY;
 
-    return PVRSRV_OK;
+		if (phBlockAlloc)
+			*phBlockAlloc = HOST_ALLOC_MEM_USING_KMALLOC;
+
+	}
+
+	return PVRSRV_OK;
 }
 
 
 #if !defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-PVRSRV_ERROR OSFreeMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID pvCpuVAddr, IMG_HANDLE hBlockAlloc)
+PVRSRV_ERROR OSFreeMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size,
+		       IMG_PVOID pvCpuVAddr, IMG_HANDLE hBlockAlloc)
 #else
-PVRSRV_ERROR _OSFreeMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size, IMG_PVOID pvCpuVAddr, IMG_HANDLE hBlockAlloc, IMG_CHAR *pszFilename, IMG_UINT32 ui32Line)
+PVRSRV_ERROR _OSFreeMem(IMG_UINT32 ui32Flags, IMG_UINT32 ui32Size,
+			IMG_PVOID pvCpuVAddr, IMG_HANDLE hBlockAlloc,
+			IMG_CHAR *pszFilename, IMG_UINT32 ui32Line)
 #endif
-{	
-    PVR_UNREFERENCED_PARAMETER(ui32Flags);
-    PVR_UNREFERENCED_PARAMETER(ui32Size);
+{
+	PVR_UNREFERENCED_PARAMETER(ui32Flags);
 
-    if (hBlockAlloc == HOST_ALLOC_MEM_USING_VMALLOC)
-    {
+	if (ui32Size > LINUX_KMALLOC_LIMIT) {
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-	_VFreeWrapper(pvCpuVAddr, pszFilename, ui32Line);
+		_VFreeWrapper(pvCpuVAddr, pszFilename, ui32Line);
 #else
-	VFreeWrapper(pvCpuVAddr);
+		VFreeWrapper(pvCpuVAddr);
 #endif
-    }
-    else
-    {
+	} else {
 #if defined(DEBUG_LINUX_MEMORY_ALLOCATIONS)
-	_KFreeWrapper(pvCpuVAddr, pszFilename, ui32Line);
+		_KFreeWrapper(pvCpuVAddr, pszFilename, ui32Line);
 #else
-        KFreeWrapper(pvCpuVAddr);
+		KFreeWrapper(pvCpuVAddr);
 #endif
-    }
+	}
 
-    return PVRSRV_OK;
+	return PVRSRV_OK;
 }
 
 
@@ -447,6 +450,8 @@ PVRSRV_ERROR OSInitEnvData(IMG_PVOID *pp
 		return PVRSRV_ERROR_GENERIC;
 	}
 
+	memset(psEnvData, 0, sizeof(*psEnvData));
+
 	if(OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, PVRSRV_MAX_BRIDGE_IN_SIZE + PVRSRV_MAX_BRIDGE_OUT_SIZE, 
 					&psEnvData->pvBridgeData, IMG_NULL) != PVRSRV_OK)
 	{
@@ -473,7 +478,8 @@ PVRSRV_ERROR OSDeInitEnvData(IMG_PVOID p
 	PVR_ASSERT(!psEnvData->bMISRInstalled);
 	PVR_ASSERT(!psEnvData->bLISRInstalled);
 
-	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, 0x1000, psEnvData->pvBridgeData, IMG_NULL);
+	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, PVRSRV_MAX_BRIDGE_IN_SIZE + PVRSRV_MAX_BRIDGE_OUT_SIZE,
+		  psEnvData->pvBridgeData, IMG_NULL);
 
 	OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(ENV_DATA), pvEnvSpecificData, IMG_NULL);
 
@@ -563,7 +569,7 @@ static irqreturn_t DeviceISRWrapper(int
 		SYS_DATA *psSysData = psDeviceNode->psSysData;
 		ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
 
-		tasklet_schedule(&psEnvData->sMISRTasklet);
+		queue_work(psEnvData->psMISRWorkqueue, &psEnvData->sMISRWork);
 	}
 
 out:
@@ -599,7 +605,7 @@ static irqreturn_t SystemISRWrapper(int
 	{
 		ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
 
-		tasklet_schedule(&psEnvData->sMISRTasklet);
+		queue_work(psEnvData->psMISRWorkqueue, &psEnvData->sMISRWork);
 	}
 
 out:
@@ -718,13 +724,10 @@ PVRSRV_ERROR OSUninstallSystemLISR(IMG_V
 	return PVRSRV_OK;
 }
 
-
-static void MISRWrapper(unsigned long data)
+static void MISRWrapper(struct work_struct *work)
 {
-	SYS_DATA *psSysData;
-
-	psSysData = (SYS_DATA *)data;
-	
+	ENV_DATA *psEnvData = container_of(work, ENV_DATA, sMISRWork);
+	SYS_DATA *psSysData = (SYS_DATA *)psEnvData->pvSysData;
 	PVRSRVMISR(psSysData);
 }
 
@@ -742,7 +745,9 @@ PVRSRV_ERROR OSInstallMISR(IMG_VOID *pvS
 
 	PVR_TRACE(("Installing MISR with cookie %x", pvSysData));
 
-	tasklet_init(&psEnvData->sMISRTasklet, MISRWrapper, (unsigned long)pvSysData);
+	psEnvData->pvSysData = pvSysData;
+	psEnvData->psMISRWorkqueue = create_singlethread_workqueue("sgx_misr");
+	INIT_WORK(&psEnvData->sMISRWork, MISRWrapper);
 
 	psEnvData->bMISRInstalled = IMG_TRUE;
 
@@ -763,7 +768,8 @@ PVRSRV_ERROR OSUninstallMISR(IMG_VOID *p
 
 	PVR_TRACE(("Uninstalling MISR"));
 
-	tasklet_kill(&psEnvData->sMISRTasklet);
+	flush_workqueue(psEnvData->psMISRWorkqueue);
+	destroy_workqueue(psEnvData->psMISRWorkqueue);
 
 	psEnvData->bMISRInstalled = IMG_FALSE;
 
@@ -777,7 +783,7 @@ PVRSRV_ERROR OSScheduleMISR(IMG_VOID *pv
 
 	if (psEnvData->bMISRInstalled)
 	{
-		tasklet_schedule(&psEnvData->sMISRTasklet);
+		queue_work(psEnvData->psMISRWorkqueue, &psEnvData->sMISRWork);
 	}
 
 	return PVRSRV_OK;	
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/include/buffer_manager.h kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/include/buffer_manager.h
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/include/buffer_manager.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/include/buffer_manager.h	2012-12-16 13:13:01.644330146 +0100
@@ -70,6 +70,10 @@ typedef struct _BM_BUF_
 
 	BM_MAPPING			*pMapping;
 	IMG_UINT32			ui32RefCount;
+	IMG_UINTPTR_T	uHashKey;
+	void	*pvKernelSyncInfo;
+	void	*pvPageList;
+	IMG_HANDLE hOSWrapMem;
 } BM_BUF;
 
 struct _BM_HEAP_
@@ -153,11 +157,17 @@ BM_Alloc (IMG_HANDLE			hDevMemHeap,
 			BM_HANDLE			*phBuf);
 
 IMG_BOOL
+BM_IsWrapped(IMG_HANDLE hDevMemHeap,
+		IMG_UINT32 ui32Offset,
+		IMG_SYS_PHYADDR sSysAddr);
+
+IMG_BOOL
 BM_Wrap (	IMG_HANDLE hDevMemHeap,
 		    IMG_UINT32 ui32Size,
 			IMG_UINT32 ui32Offset,
 			IMG_BOOL bPhysContig,
 			IMG_SYS_PHYADDR *psSysAddr,
+			IMG_BOOL bFreePageList,
 			IMG_VOID *pvCPUVAddr,
 			IMG_UINT32 *pui32Flags,
 			BM_HANDLE *phBuf);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/include/osfunc.h kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/include/osfunc.h
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/include/osfunc.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/include/osfunc.h	2012-12-16 13:13:01.644330146 +0100
@@ -69,6 +69,8 @@ PVRSRV_ERROR OSInstallSystemLISR(IMG_VOI
 PVRSRV_ERROR OSUninstallSystemLISR(IMG_VOID *pvSysData);
 PVRSRV_ERROR OSInstallMISR(IMG_VOID *pvSysData);
 PVRSRV_ERROR OSUninstallMISR(IMG_VOID *pvSysData);
+PVRSRV_ERROR OSInitPerf(IMG_VOID *pvSysData);
+PVRSRV_ERROR OSCleanupPerf(IMG_VOID *pvSysData);
 IMG_CPU_PHYADDR OSMapLinToCPUPhys(IMG_VOID* pvLinAddr);
 IMG_VOID OSMemCopy(IMG_VOID *pvDst, IMG_VOID *pvSrc, IMG_UINT32 ui32Size);
 IMG_VOID *OSMapPhysToLin(IMG_CPU_PHYADDR BasePAddr, IMG_UINT32 ui32Bytes, IMG_UINT32 ui32Flags, IMG_HANDLE *phOSMemHandle);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/include/power.h kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/include/power.h
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/include/power.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/include/power.h	2012-12-16 13:13:01.644330146 +0100
@@ -72,6 +72,12 @@ IMG_IMPORT
 IMG_VOID PVRSRVPowerUnlock(IMG_UINT32	ui32CallerID);
 
 IMG_IMPORT
+IMG_VOID PVRSRVDvfsLock(IMG_VOID);
+
+IMG_IMPORT
+IMG_VOID PVRSRVDvfsUnlock(IMG_VOID);
+
+IMG_IMPORT
 PVRSRV_ERROR PVRSRVSetDevicePowerStateKM(IMG_UINT32			ui32DeviceIndex,
 										 PVR_POWER_STATE	eNewPowerState,
 										 IMG_UINT32			ui32CallerID,
@@ -102,7 +108,7 @@ IMG_IMPORT
 IMG_BOOL PVRSRVIsDevicePowered(IMG_UINT32 ui32DeviceIndex);
 
 IMG_IMPORT
-IMG_VOID PVRSRVDevicePreClockSpeedChange(IMG_UINT32	ui32DeviceIndex,
+PVRSRV_ERROR PVRSRVDevicePreClockSpeedChange(IMG_UINT32	ui32DeviceIndex,
 										 IMG_BOOL	bIdleDevice,
 										 IMG_VOID	*pvInfo);
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/include/queue.h kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/include/queue.h
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/srvkm/include/queue.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/srvkm/include/queue.h	2012-12-16 13:13:01.644330146 +0100
@@ -44,6 +44,7 @@ extern "C" {
 	IMG_UINT32			ui32SrcSyncCount;	
 	PVRSRV_SYNC_OBJECT	*psDstSync;			
 	PVRSRV_SYNC_OBJECT	*psSrcSync;			
+	IMG_UINT32	ui32AllocSize;
  }COMMAND_COMPLETE_DATA, *PCOMMAND_COMPLETE_DATA;
 
 #if !defined(USE_CODE)
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/system/omap3430/sysconfig.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/system/omap3430/sysconfig.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/system/omap3430/sysconfig.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/system/omap3430/sysconfig.c	2012-12-16 13:13:01.648330146 +0100
@@ -37,6 +37,7 @@ SYS_DATA* gpsSysData = (SYS_DATA*)IMG_NU
 SYS_DATA  gsSysData;
 
 static SYS_SPECIFIC_DATA gsSysSpecificData;
+SYS_SPECIFIC_DATA *gpsSysSpecificData;
 
 static IMG_UINT32	gui32SGXDeviceID;
 static SGX_DEVICE_MAP	gsSGXDeviceMap;
@@ -174,13 +175,17 @@ PVRSRV_ERROR SysInitialise(IMG_VOID)
 	PVRSRV_ERROR 		eError;
 	PVRSRV_DEVICE_NODE	*psDeviceNode;
 	IMG_CPU_PHYADDR		TimerRegPhysBase;
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
 	SGX_TIMING_INFORMATION*	psTimingInfo;
+#endif
 
 	gpsSysData = &gsSysData;
 	OSMemSet(gpsSysData, 0, sizeof(SYS_DATA));
 
-	gpsSysData->pvSysSpecificData = &gsSysSpecificData;
-	gsSysSpecificData.ui32SysSpecificData = 0;
+	gpsSysSpecificData =  &gsSysSpecificData;
+	OSMemSet(gpsSysSpecificData, 0, sizeof(SYS_SPECIFIC_DATA));
+
+	gpsSysData->pvSysSpecificData = gpsSysSpecificData;
 
 	eError = OSInitEnvData(&gpsSysData->pvEnvSpecificData);
 	if (eError != PVRSRV_OK)
@@ -213,7 +218,8 @@ PVRSRV_ERROR SysInitialise(IMG_VOID)
 		return eError;
 	}
 
-	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_REGS_SYS_PHYS_BASE;
+	TimerRegPhysBase.uiAddr =
+		SYS_OMAP3430_GP11TIMER_PHYS_BASE + SYS_OMAP3430_GPTIMER_REGS;
 	gpsSysData->pvSOCTimerRegisterKM = IMG_NULL;
 	gpsSysData->hSOCTimerRegisterOSMemHandle = 0;
 	OSReservePhys(TimerRegPhysBase,
@@ -222,13 +228,14 @@ PVRSRV_ERROR SysInitialise(IMG_VOID)
 				  (IMG_VOID **)&gpsSysData->pvSOCTimerRegisterKM,
 				  &gpsSysData->hSOCTimerRegisterOSMemHandle);
 
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
 	
 	psTimingInfo = &gsSGXDeviceMap.sTimingInfo;
 	psTimingInfo->ui32CoreClockSpeed = SYS_SGX_CLOCK_SPEED;
 	psTimingInfo->ui32HWRecoveryFreq = SYS_SGX_HWRECOVERY_TIMEOUT_FREQ; 
 	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS; 
 	psTimingInfo->ui32uKernelFreq = SYS_SGX_PDS_TIMER_FREQ; 
-
+#endif
 	
 
 
@@ -304,7 +311,16 @@ PVRSRV_ERROR SysInitialise(IMG_VOID)
 	PDUMPINIT();
 	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT);
 
-	eError = EnableSystemClocks(gpsSysData, &gsSGXDeviceMap.sTimingInfo);
+	eError = InitSystemClocks(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to init system clocks (%d)", eError));
+		SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+
+	eError = EnableSystemClocks(gpsSysData);
 	if (eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to Enable system clocks (%d)", eError));
@@ -313,6 +329,16 @@ PVRSRV_ERROR SysInitialise(IMG_VOID)
 		return eError;
 	}
 	SYS_SPECIFIC_DATA_SET(&gsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS);
+
+	eError = OSInitPerf(gpsSysData);
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"SysInitialise: Failed to init DVFS (%d)", eError));
+		SysDeinitialise(gpsSysData);
+		gpsSysData = IMG_NULL;
+		return eError;
+	}
+
 #if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
 	eError = EnableSGXClocks(gpsSysData);
 	if (eError != PVRSRV_OK)
@@ -398,6 +424,8 @@ PVRSRV_ERROR SysFinalise(IMG_VOID)
 	DisableSGXClocks(gpsSysData);
 #endif	
 
+	gpsSysSpecificData->bSGXInitComplete = IMG_TRUE;
+
 	return eError;
 }
 
@@ -406,12 +434,10 @@ PVRSRV_ERROR SysDeinitialise (SYS_DATA *
 {
 	PVRSRV_ERROR eError;
 	
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-
 	PVR_UNREFERENCED_PARAMETER(psSysData);
 
 #if defined(SYS_USING_INTERRUPTS)
-	if (SYS_SPECIFIC_DATA_TEST(psSysSpecData, SYS_SPECIFIC_DATA_ENABLE_LISR))
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LISR))
 	{
 		eError = OSUninstallDeviceLISR(psSysData);
 		if (eError != PVRSRV_OK)
@@ -421,7 +447,7 @@ PVRSRV_ERROR SysDeinitialise (SYS_DATA *
 		}
 	}
 
-	if (SYS_SPECIFIC_DATA_TEST(psSysSpecData, SYS_SPECIFIC_DATA_ENABLE_MISR))
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_MISR))
 	{
 		eError = OSUninstallMISR(psSysData);
 		if (eError != PVRSRV_OK)
@@ -430,12 +456,18 @@ PVRSRV_ERROR SysDeinitialise (SYS_DATA *
 			return eError;
 		}
 	}
-#endif 
+#endif
 
-	if (SYS_SPECIFIC_DATA_TEST(psSysSpecData, SYS_SPECIFIC_DATA_ENABLE_INITDEV))
+	eError = OSCleanupPerf(gpsSysSpecificData);
+	if (eError != PVRSRV_OK) {
+		PVR_DPF((PVR_DBG_ERROR, "SysDeinitialise: OSCleanupDvfs failed"));
+		return eError;
+	}
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_INITDEV))
 	{
 #if defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-		PVR_ASSERT(SYS_SPECIFIC_DATA_TEST(psSysSpecData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS));
+		PVR_ASSERT(SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS));
 		
 		eError = EnableSGXClocks(gpsSysData);
 		if (eError != PVRSRV_OK)
@@ -454,14 +486,14 @@ PVRSRV_ERROR SysDeinitialise (SYS_DATA *
 		}
 	}
 	
-	
-
-	if (SYS_SPECIFIC_DATA_TEST(psSysSpecData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_SYSCLOCKS))
 	{
 		DisableSystemClocks(gpsSysData);
 	}
 
-	if (SYS_SPECIFIC_DATA_TEST(psSysSpecData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA))
+	CleanupSystemClocks(gpsSysData);
+
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_ENVDATA))
 	{	
 		eError = OSDeInitEnvData(gpsSysData->pvEnvSpecificData);
 		if (eError != PVRSRV_OK)
@@ -482,7 +514,7 @@ PVRSRV_ERROR SysDeinitialise (SYS_DATA *
 	SysDeinitialiseCommon(gpsSysData);
 
 #if defined(NO_HARDWARE)
-	if(SYS_SPECIFIC_DATA_TEST(psSysSpecData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV))
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_LOCATEDEV))
 	{
 		
 		OSBaseFreeContigMemory(SYS_OMAP3430_SGX_REGS_SIZE, gsSGXRegsCPUVAddr, gsSGXDeviceMap.sRegsCpuPBase);
@@ -490,12 +522,14 @@ PVRSRV_ERROR SysDeinitialise (SYS_DATA *
 #endif
 
 	
-	if(SYS_SPECIFIC_DATA_TEST(psSysSpecData, SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT))
+	if (SYS_SPECIFIC_DATA_TEST(gpsSysSpecificData, SYS_SPECIFIC_DATA_ENABLE_PDUMPINIT))
 	{
 		PDUMPDEINIT();
 	}
 
-	psSysSpecData->ui32SysSpecificData = 0;
+	gpsSysSpecificData->ui32SysSpecificData = 0;
+	gpsSysSpecificData->bSGXInitComplete = IMG_FALSE;
+
 	gpsSysData = IMG_NULL;
 
 	return PVRSRV_OK;
@@ -664,7 +698,7 @@ PVRSRV_ERROR SysSystemPostPowerState(PVR
 
 		if (SYS_SPECIFIC_DATA_TEST(&gsSysSpecificData, SYS_SPECIFIC_DATA_PM_DISABLE_SYSCLOCKS))
 		{
-			eError = EnableSystemClocks(gpsSysData, &gsSGXDeviceMap.sTimingInfo);
+			eError = EnableSystemClocks(gpsSysData);
 			if (eError != PVRSRV_OK)
 			{
 				PVR_DPF((PVR_DBG_ERROR,"SysSystemPostPowerState: EnableSystemClocks failed (%d)", eError));
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/system/omap3430/sysconfig.h kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/system/omap3430/sysconfig.h
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/system/omap3430/sysconfig.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/system/omap3430/sysconfig.h	2012-12-16 13:13:01.648330146 +0100
@@ -45,9 +45,11 @@
 
 #define SYS_OMAP3430_SGX_IRQ				 21
 
-#define SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE  0x48088024
-#define SYS_OMAP3430_GP11TIMER_REGS_SYS_PHYS_BASE	 0x48088028
-#define SYS_OMAP3430_GP11TIMER_TSICR_SYS_PHYS_BASE	 0x48088040
+#define SYS_OMAP3430_GP11TIMER_PHYS_BASE		0x48088000
+#define SYS_OMAP3430_GPTIMER_ENABLE			0x24
+#define SYS_OMAP3430_GPTIMER_REGS			0x28
+#define SYS_OMAP3430_GPTIMER_TSICR			0x40
+#define SYS_OMAP3430_GPTIMER_SIZE			1024
 
  
 #endif	
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/system/omap3430/syslocal.h kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/system/omap3430/syslocal.h
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/system/omap3430/syslocal.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/system/omap3430/syslocal.h	2012-12-16 13:13:01.648330146 +0100
@@ -44,8 +44,10 @@ extern "C" {
  
 IMG_CHAR *SysCreateVersionString(IMG_CPU_PHYADDR sRegRegion);
 
+PVRSRV_ERROR InitSystemClocks(SYS_DATA *psSysData);
+IMG_VOID CleanupSystemClocks(SYS_DATA *psSysData);
 IMG_VOID DisableSystemClocks(SYS_DATA *psSysData);
-PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData, SGX_TIMING_INFORMATION *psSGXTimingInfo);
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData);
 
 IMG_VOID DisableSGXClocks(SYS_DATA *psSysData);
 PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData);
@@ -72,11 +74,10 @@ PVRSRV_ERROR EnableSGXClocks(SYS_DATA *p
 typedef struct _SYS_SPECIFIC_DATA_TAG_
 {
 	IMG_UINT32	ui32SysSpecificData;
-	IMG_BOOL	bSGXClocksEnabled;
 	PVRSRV_DEVICE_NODE *psSGXDevNode;
+	IMG_BOOL	bSGXInitComplete;
+	IMG_BOOL	bSGXClocksEnabled;
 #if defined(__linux__)
-	IMG_BOOL	bSysClocksOneTimeInit;
-
 	struct clk	*psCORE_CK;
 	struct clk	*psSGX_FCK;
 	struct clk	*psSGX_ICK;
@@ -84,16 +85,16 @@ typedef struct _SYS_SPECIFIC_DATA_TAG_
 #if defined(DEBUG) || defined(TIMING)
 	struct clk	*psGPT11_FCK;
 	struct clk	*psGPT11_ICK;
+	void __iomem	*gpt_base;
 #endif
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))		
-	SGX_TIMING_INFORMATION	*psSGXTimingInfo;
-
 	struct constraint_handle *pVdd2Handle;
 #endif	
-	struct semaphore sConstraintNotifierLock;
 #endif	
 } SYS_SPECIFIC_DATA;
 
+extern SYS_SPECIFIC_DATA *gpsSysSpecificData;
+
 #if defined(__cplusplus)
 }
 #endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/system/omap3430/sysutils_linux.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/system/omap3430/sysutils_linux.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/system/omap3430/sysutils_linux.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/system/omap3430/sysutils_linux.c	2012-12-16 13:13:01.648330146 +0100
@@ -28,8 +28,8 @@
 #include <linux/clk.h>
 #include <linux/err.h>
 #include <linux/hardirq.h>
+#include <mach/omap-pm.h>
 #include <asm/bug.h>
-#include <linux/semaphore.h>
 #include <clock.h>
 #include "sgxdefs.h"
 #include "services_headers.h"
@@ -38,17 +38,11 @@
 #include "sysconfig.h"
 #include "sgxinfokm.h"
 #include "syslocal.h"
+#include "env_data.h"
 
 #define	HZ_TO_MHZ(m) ((m) / 1000000)
 
-#define	MUTEX_INIT(pl)  	init_MUTEX(pl)
-#define	MUTEX_LOCK(pl)		down(pl)
-#define	MUTEX_UNLOCK(pl)	up(pl)
-
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))	
-
-static SYS_SPECIFIC_DATA *psNotifierSysSpecData;
-
+#if defined(SGX_DYNAMIC_TIMING_INFO)
 static inline unsigned long scale_by_rate(unsigned long val, unsigned long rate1, unsigned long rate2)
 {
 	if (rate1 >= rate2)
@@ -69,40 +63,63 @@ static inline unsigned long scale_inv_pr
 	return scale_by_rate(val, SYS_SGX_CLOCK_SPEED, rate);
 }
 
-static void post_clock_rate_change(unsigned long incoming_rate)
+IMG_VOID SysGetSGXTimingInformation(SGX_TIMING_INFORMATION *psTimingInfo)
 {
-	unsigned long rate = 0;
-	SGX_TIMING_INFORMATION *psTimingInfo = psNotifierSysSpecData->psSGXTimingInfo;
+	unsigned long rate;
 
-	if (0 == incoming_rate)
-	{
-		rate = clk_get_rate(psNotifierSysSpecData->psSGX_FCK);	
-	}
-	else
-	{	
-		rate = incoming_rate;
-	}
-	
-	PVR_ASSERT(rate != 0);
+#if defined(NO_HARDWARE)
+	rate = SYS_SGX_CLOCK_SPEED;
+#else
+	PVR_ASSERT(gpsSysSpecificData->bSGXClocksEnabled);
 
+	rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
+	PVR_ASSERT(rate != 0);
+#endif
 	psTimingInfo->ui32CoreClockSpeed = rate;
 	psTimingInfo->ui32HWRecoveryFreq = scale_prop_to_SGX_clock(SYS_SGX_HWRECOVERY_TIMEOUT_FREQ, rate);
-	psTimingInfo->ui32uKernelFreq = scale_prop_to_SGX_clock(SYS_SGX_PDS_TIMER_FREQ, rate); 
-
-	PVR_TRACE(("post_clock_rate_change: SGX clock rate: %dMHz", HZ_TO_MHZ(psTimingInfo->ui32CoreClockSpeed)));
+	psTimingInfo->ui32uKernelFreq = scale_prop_to_SGX_clock(SYS_SGX_PDS_TIMER_FREQ, rate);
+	psTimingInfo->ui32ActivePowManLatencyms = SYS_SGX_ACTIVE_POWER_LATENCY_MS;
+}
+#endif
 
-#if 0
-	PVR_TRACE(("post_clock_rate_change: HW Recovery frequency: %dHz", psTimingInfo->ui32HWRecoveryFreq));
-	PVR_TRACE(("post_clock_rate_change: PDS Timer frequency: %dHz", psTimingInfo->ui32uKernelFreq));
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22))
+#if !defined(SGX_DYNAMIC_TIMING_INFO)
+#error "SGX_DYNAMIC_TIMING_INFO must be defined for this platform"
 #endif
 
-	PVRSRVDevicePostClockSpeedChange(psNotifierSysSpecData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_FALSE, IMG_NULL);
+static int vdd2_post_func(struct notifier_block *n, unsigned long event, void *ptr)
+{
+	PVR_UNREFERENCED_PARAMETER(n);
+	PVR_UNREFERENCED_PARAMETER(event);
+	PVR_UNREFERENCED_PARAMETER(ptr);
+
+	if (gpsSysSpecificData->bSGXClocksEnabled && gpsSysSpecificData->bSGXInitComplete) {
+#if defined(DEBUG)
+		unsigned long rate;
+
+		rate = clk_get_rate(gpsSysSpecificData->psSGX_FCK);
+
+		PVR_ASSERT(rate != 0);
+
+		PVR_TRACE(("%s: SGX clock rate: %dMHz", __FUNCTION__, HZ_TO_MHZ(rate)));
+#endif
+		PVRSRVDevicePostClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
+	}
+	return 0;
 }
 
-static void pre_clock_rate_change(void)
+static int vdd2_pre_func(struct notifier_block *n, unsigned long event, void *ptr)
 {
-	PVRSRVDevicePreClockSpeedChange(psNotifierSysSpecData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_FALSE, IMG_NULL);
+	PVR_UNREFERENCED_PARAMETER(n);
+	PVR_UNREFERENCED_PARAMETER(event);
+	PVR_UNREFERENCED_PARAMETER(ptr);
+
+	if (gpsSysSpecificData->bSGXClocksEnabled && gpsSysSpecificData->bSGXInitComplete) {
+		BUG_ON(gpsSysData->eCurrentPowerState > PVRSRV_POWER_STATE_D1);
+		PVRSRVDevicePreClockSpeedChange(gpsSysSpecificData->psSGXDevNode->sDevId.ui32DeviceIndex, IMG_TRUE, IMG_NULL);
+	}
 
+	return 0;
 }
 
 static int vdd2_pre_post_func(struct notifier_block *n, unsigned long event, void *ptr)
@@ -115,37 +132,27 @@ static int vdd2_pre_post_func(struct not
 
 	PVR_TRACE(("vdd2_pre_post_func: old clock rate = %lu", cnd->old_rate));
 	PVR_TRACE(("vdd2_pre_post_func: new clock rate = %lu", cnd->new_rate));
-	
+
 	if (CLK_PRE_RATE_CHANGE == event)
 	{
+		PVRSRVDvfsLock();
 		PVR_TRACE(("vdd2_pre_post_func: CLK_PRE_RATE_CHANGE event"));
-		
-		BUG_ON(in_irq());		
-		MUTEX_LOCK(&psNotifierSysSpecData->sConstraintNotifierLock);
-
-		if (psNotifierSysSpecData->bSGXClocksEnabled)
-		{
-			pre_clock_rate_change();
-		}		
+		vdd2_pre_func(n, event, ptr);
 	}
 	else if (CLK_POST_RATE_CHANGE == event)
 	{
-		PVR_TRACE(("vdd2_pre_post_func: CLK_POST_RATE_CHANGE event"));				
-		
-		BUG_ON(in_irq());
-
-		if (psNotifierSysSpecData->bSGXClocksEnabled)
-		{
-			post_clock_rate_change(cnd->new_rate);
-		}
-
-		MUTEX_UNLOCK(&psNotifierSysSpecData->sConstraintNotifierLock);				
-	}
-	else
-	{	
-		PVR_DPF((PVR_DBG_ERROR, "vdd2_pre_post_func: unexpected event (%ul)", event));
+		PVR_TRACE(("vdd2_pre_post_func: CLK_POST_RATE_CHANGE event"));
+		vdd2_post_func(n, event, ptr);
+		PVRSRVDvfsUnlock();
+	} else if (CLK_ABORT_RATE_CHANGE == event)
+	{
+		PVR_TRACE(("vdd2_pre_post_func: CLK_ABORT_RATE_CHANGE event"));
+		PVRSRVDvfsUnlock();
+	} else {
+		printk("vdd2_pre_post_func: unexpected event (%lu)\n", event);
+		PVR_DPF((PVR_DBG_ERROR, "vdd2_pre_post_func: unexpected event (%lu)", event));
 	}
-	
+	PVR_TRACE(("vdd2_pre_post_func end."));
 	return 0;
 }
 
@@ -154,38 +161,169 @@ static struct notifier_block vdd2_pre_po
 	 NULL
 };
 
-static IMG_VOID RegisterConstraintNotifications(SYS_DATA *psSysData, SGX_TIMING_INFORMATION *psSGXTimingInfo)
+static IMG_VOID RegisterConstraintNotifications(SYS_SPECIFIC_DATA *psSysSpecData)
 {
 	PVR_TRACE(("Registering constraint notifications"));
 
-	PVR_ASSERT(psNotifierSysSpecData == IMG_NULL);
+	clk_notifier_register(psSysSpecData->psSGX_FCK, &vdd2_pre_post);
+	PVR_TRACE(("VDD2 constraint notifications registered"));
+}
 
-	psNotifierSysSpecData = (SYS_SPECIFIC_DATA *)psSysData->pvSysSpecificData;
-	psNotifierSysSpecData->psSGXTimingInfo = psSGXTimingInfo;
+static IMG_VOID UnRegisterConstraintNotifications(SYS_SPECIFIC_DATA *psSysSpecData)
+{
+	PVR_TRACE(("Unregistering constraint notifications"));
 
-	clk_notifier_register(psNotifierSysSpecData->psSGX_FCK, &vdd2_pre_post);
+	clk_notifier_unregister(psSysSpecData->psSGX_FCK, &vdd2_pre_post);
 }
+#endif 
+
+static struct device sgx_dev;
+static int sgx_clock_enabled;
 
-static IMG_VOID UnRegisterConstraintNotifications(IMG_VOID)
+/* return value: current sgx load
+ * 0 - not busy
+ * 100 - busy
+ */
+static unsigned int sgx_current_load(void)
+{
+	PVRSRV_ERROR	eError;
+	SYS_DATA		*psSysData;
+	SYS_SPECIFIC_DATA *psSysSpecData;
+	PVRSRV_DEVICE_NODE	*psDeviceNode;
+	static unsigned int kicks_prev;
+	static long	time_prev;
+
+	eError = SysAcquireData(&psSysData);
+	if (eError != PVRSRV_OK)
+		return 0;
+	psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	if ((!psSysSpecData) || (!psSysSpecData->bSGXClocksEnabled))
+		return 0;
+#if defined(SUPPORT_SGX_HWPERF)
+	psDeviceNode = psSysData->psDeviceNodeList;
+	while (psDeviceNode) {
+		if ((psDeviceNode->sDevId.eDeviceType == PVRSRV_DEVICE_TYPE_SGX)
+				&& (psDeviceNode->pvDevice)) {
+			PVRSRV_SGXDEV_INFO *psDevInfo = (PVRSRV_SGXDEV_INFO *)psDeviceNode->pvDevice;
+			unsigned int kicks = psDevInfo->ui32KickTACounter;
+			unsigned int load;
+			long time_elapsed;
+
+			time_elapsed = jiffies - time_prev;
+			if (likely(time_elapsed))
+				load = 1000*(kicks-kicks_prev)/time_elapsed;
+			else
+				load = 0;
+			kicks_prev = kicks;
+			time_prev += time_elapsed;
+			/* if the period between calls to this function was too long,
+			 * then load stats are invalid
+			 */
+			if (time_elapsed > 5*HZ)
+				return 0;
+			/*pr_err("SGX load %u\n", load);*/
+
+			/* 'load' shows how many times sgx was kicked per 1000 jiffies
+			 * 150 is arbitrarily chosen threshold.
+			 * If the number of kicks is below threshold then sgx is doing
+			 * some small jobs and we can keep the clock freq low.
+			 */
+			if (load < 150)
+				return 0;
+			else
+				return 100;
+		}
+		psDeviceNode = psDeviceNode->psNext;
+	}
+	return 0;
+#else
+	return 100;
+#endif
+}
+
+
+static void sgx_lock_perf(struct work_struct *work)
 {
-	if (psNotifierSysSpecData == IMG_NULL)
-	{
-		return;
+	int vdd1, vdd2;
+	static int bHigh;
+	int high;
+	unsigned int load;
+	struct delayed_work *d_work = container_of(work, struct delayed_work, work);
+	ENV_DATA	*psEnvData = container_of(d_work, ENV_DATA, sPerfWork);
+
+	load = sgx_current_load();
+	if (load) {
+		vdd1 = 500000000;
+		vdd2 = 400000;
+		high = 1;
+	} else {
+		vdd1 = 0;
+		vdd2 = 0;
+		high = 0;
 	}
+	if (high != bHigh) {
+		omap_pm_set_min_bus_tput(&sgx_dev, OCP_INITIATOR_AGENT, vdd2);
+		omap_pm_set_min_mpu_freq(&sgx_dev, vdd1);
+		bHigh = high;
+	}
+	if (sgx_clock_enabled || load)
+		queue_delayed_work(psEnvData->psPerfWorkqueue, &psEnvData->sPerfWork, HZ/5);
+}
 
-	PVR_TRACE(("Unregistering constraint notifications"));
-	
-	clk_notifier_unregister(psNotifierSysSpecData->psSGX_FCK, &vdd2_pre_post);
+static void sgx_need_perf(SYS_DATA *psSysData, int ena)
+{
+	ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
 
-	psNotifierSysSpecData = IMG_NULL;
+	sgx_clock_enabled = ena;
+	cancel_delayed_work(&psEnvData->sPerfWork);
+	queue_delayed_work(psEnvData->psPerfWorkqueue, &psEnvData->sPerfWork, 0);
 }
-#endif 
+
+PVRSRV_ERROR OSInitPerf(IMG_VOID *pvSysData)
+{
+	SYS_DATA *psSysData = (SYS_DATA*)pvSysData;
+	ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
+
+	if (psEnvData->psPerfWorkqueue) {
+		PVR_DPF((PVR_DBG_ERROR, "OSInitPerf: already inited"));
+		return PVRSRV_ERROR_GENERIC;
+	}
+
+	PVR_TRACE(("Initing DVFS %x", pvSysData));
+
+	psEnvData->psPerfWorkqueue = create_singlethread_workqueue("sgx_perf");
+	INIT_DELAYED_WORK(&psEnvData->sPerfWork, sgx_lock_perf);
+
+	return PVRSRV_OK;
+}
+
+PVRSRV_ERROR OSCleanupPerf(IMG_VOID *pvSysData)
+{
+	SYS_DATA *psSysData = (SYS_DATA*)pvSysData;
+	ENV_DATA *psEnvData = (ENV_DATA *)psSysData->pvEnvSpecificData;
+
+	if (!psEnvData->psPerfWorkqueue) {
+		PVR_DPF((PVR_DBG_ERROR, "OSCleanupPerf: not inited"));
+		return PVRSRV_ERROR_GENERIC;
+	}
+
+	PVR_TRACE(("Cleaning up DVFS"));
+
+	flush_workqueue(psEnvData->psPerfWorkqueue);
+	destroy_workqueue(psEnvData->psPerfWorkqueue);
+
+	return PVRSRV_OK;
+}
+
+
 
 PVRSRV_ERROR EnableSGXClocks(SYS_DATA *psSysData)
 {
 #if !defined(NO_HARDWARE)
 	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+#if defined(DEBUG)
 	unsigned long rate;
+#endif
 	int res;
 
 	
@@ -235,22 +373,11 @@ PVRSRV_ERROR EnableSGXClocks(SYS_DATA *p
 	BUG_ON(in_irq());
 #endif
 
-	MUTEX_LOCK(&psSysSpecData->sConstraintNotifierLock);
-
-	
 	psSysSpecData->bSGXClocksEnabled = IMG_TRUE;
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))	
-
-	pre_clock_rate_change();
-
-	post_clock_rate_change(0);
-#endif 
-
-	MUTEX_UNLOCK(&psSysSpecData->sConstraintNotifierLock);
-
 #else	
 	PVR_UNREFERENCED_PARAMETER(psSysData);
 #endif	
+	sgx_need_perf(psSysData, 1);
 	return PVRSRV_OK;
 }
 
@@ -278,263 +405,283 @@ IMG_VOID DisableSGXClocks(SYS_DATA *psSy
 		clk_disable(psSysSpecData->psSGX_FCK);
 	}
 
-	MUTEX_LOCK(&psSysSpecData->sConstraintNotifierLock);
-
-	
 	psSysSpecData->bSGXClocksEnabled = IMG_FALSE;
-
-	MUTEX_UNLOCK(&psSysSpecData->sConstraintNotifierLock);
 #else	
 	PVR_UNREFERENCED_PARAMETER(psSysData);
 #endif	
+	sgx_need_perf(psSysData, 0);
 }
 
-PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData, SGX_TIMING_INFORMATION *psSGXTimingInfo)
+static PVRSRV_ERROR InitSgxClocks(SYS_DATA *psSysData)
 {
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
+	SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
 	struct clk *psCLK;
-	int res;
-#if !defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	PVRSRV_ERROR eError;
-#endif
-#if defined(DEBUG) || defined(TIMING)
-	int rate;
-	struct clk *sys_ck;
-	IMG_CPU_PHYADDR     TimerRegPhysBase;
-	IMG_HANDLE hTimerEnable;
-	IMG_UINT32 *pui32TimerEnable;
+	struct clk *core_ck = NULL;
 
-#endif	
+	psCLK = clk_get(NULL, "sgx_fck");
+	if (IS_ERR(psCLK))
+		goto err0;
+	psSysSpecData->psSGX_FCK = psCLK;
 
-	PVR_TRACE(("EnableSystemClocks: Enabling System Clocks"));
+	psCLK = clk_get(NULL, "sgx_ick");
+	if (IS_ERR(psCLK))
+		goto err1;
+	psSysSpecData->psSGX_ICK = psCLK;
 
-	if (!psSysSpecData->bSysClocksOneTimeInit)
-	{
-		MUTEX_INIT(&psSysSpecData->sConstraintNotifierLock);
+	core_ck = clk_get(NULL, "core_ck");
+	if (IS_ERR(core_ck))
+		goto err2;
+	if (clk_set_parent(psSysSpecData->psSGX_FCK, core_ck) < 0) {
+		clk_put(core_ck);
+		goto err2;
+	}
+	clk_put(core_ck);
 
-		psCLK = clk_get(NULL, "core_ck");
-		if (IS_ERR(psCLK))
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get Core Clock"));
-			goto ExitError;
-		}
-		psSysSpecData->psCORE_CK = psCLK;
+	RegisterConstraintNotifications(psSysSpecData);
 
-		psCLK = clk_get(NULL, "sgx_fck");
-		if (IS_ERR(psCLK))
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSsystemClocks: Couldn't get SGX Functional Clock"));
-			goto ExitError;
-		}
-		psSysSpecData->psSGX_FCK = psCLK;
+	return PVRSRV_OK;
 
-		psCLK = clk_get(NULL, "sgx_ick");
-		if (IS_ERR(psCLK))
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get SGX Interface Clock"));
-			goto ExitError;
-		}
-		psSysSpecData->psSGX_ICK = psCLK;
+err2:
+	clk_put(psSysSpecData->psSGX_ICK);
+err1:
+	clk_put(psSysSpecData->psSGX_FCK);
+err0:
+	PVR_DPF((PVR_DBG_ERROR, "%s: couldn't init clocks fck %p ick %p core %p",
+		 __func__, psSysSpecData->psSGX_FCK, psSysSpecData->psSGX_ICK,
+		 core_ck));
+	psSysSpecData->psSGX_FCK = NULL;
+	psSysSpecData->psSGX_ICK = NULL;
 
-#if defined(DEBUG)
-		psCLK = clk_get(NULL, "mpu_ck");
-		if (IS_ERR(psCLK))
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get MPU Clock"));
-			goto ExitError;
-		}
-		psSysSpecData->psMPU_CK = psCLK;
-#endif
-		res = clk_set_parent(psSysSpecData->psSGX_FCK, psSysSpecData->psCORE_CK);
-		if (res < 0)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set SGX parent clock (%d)", res));
-			goto ExitError;
-		}
-	
-		psSysSpecData->bSysClocksOneTimeInit = IMG_TRUE;
-	}
+	return PVRSRV_ERROR_GENERIC;
+}
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
-	RegisterConstraintNotifications(psSysData, psSGXTimingInfo);
-#endif
+static void CleanupSgxClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
 
-#if !defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	
-	eError = EnableSGXClocks(psSysData);
-	if (eError != PVRSRV_OK)
-	{
-		goto ExitUnRegisterConstraintNotifications;
+	UnRegisterConstraintNotifications(psSysSpecData);
+
+	if (psSysSpecData->psSGX_ICK) {
+		clk_put(psSysSpecData->psSGX_ICK);
+		psSysSpecData->psSGX_ICK = NULL;
 	}
-#endif
+
+	if (psSysSpecData->psSGX_FCK) {
+		clk_put(psSysSpecData->psSGX_FCK);
+		psSysSpecData->psSGX_FCK = NULL;
+	}
+}
 
 #if defined(DEBUG) || defined(TIMING)
-	
+static u32 inline gpt_read_reg(SYS_DATA *psSysData, u32 reg)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
+
+	return __raw_readl(psSysSpecData->gpt_base + reg);
+}
+
+static void inline gpt_write_reg(SYS_DATA *psSysData, u32 reg, u32 val)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
+
+	__raw_writel(val, psSysSpecData->gpt_base + reg);
+}
+
+static PVRSRV_ERROR InitDebugClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
+	struct clk *psCLK;
+	struct clk *sys_ck = NULL;
+	u32 rate;
+
+	psCLK = clk_get(NULL, "mpu_ck");
+	if (IS_ERR(psCLK))
+		goto err0;
+	psSysSpecData->psMPU_CK = psCLK;
+
 	psCLK = clk_get(NULL, "gpt11_fck");
 	if (IS_ERR(psCLK))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 functional clock"));
-		goto ExitDisableSGXClocks;
-	}
+		goto err1;
 	psSysSpecData->psGPT11_FCK = psCLK;
-	
+
 	psCLK = clk_get(NULL, "gpt11_ick");
 	if (IS_ERR(psCLK))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get GPTIMER11 interface clock"));
-		goto ExitDisableSGXClocks;
-	}
+		goto err2;
 	psSysSpecData->psGPT11_ICK = psCLK;
 
 	sys_ck = clk_get(NULL, "sys_ck");
 	if (IS_ERR(sys_ck))
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't get System clock"));
-		goto ExitDisableSGXClocks;
-	}
-
-	if(clk_get_parent(psSysSpecData->psGPT11_FCK) != sys_ck)
-	{
-		PVR_TRACE(("Setting GPTIMER11 parent to System Clock"));
-		res = clk_set_parent(psSysSpecData->psGPT11_FCK, sys_ck);
-		if (res < 0)
-		{
-			PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't set GPTIMER11 parent clock (%d)", res));
-		goto ExitDisableSGXClocks;
+		goto err3;
+	if (clk_get_parent(psSysSpecData->psGPT11_FCK) != sys_ck) {
+		if (clk_set_parent(psSysSpecData->psGPT11_FCK, sys_ck) < 0) {
+			clk_put(sys_ck);
+			goto err3;
 		}
 	}
+	clk_put(sys_ck);
 
-	rate = clk_get_rate(psSysSpecData->psGPT11_FCK);
-	PVR_TRACE(("GPTIMER11 clock is %dMHz", HZ_TO_MHZ(rate)));
-	
-	res = clk_enable(psSysSpecData->psGPT11_FCK);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 functional clock (%d)", res));
-		goto ExitDisableSGXClocks;
-	}
+	PVR_TRACE(("GPTIMER11 clock is %dMHz",
+		  HZ_TO_MHZ(clk_get_rate(psSysSpecData->psGPT11_FCK))));
 
-	res = clk_enable(psSysSpecData->psGPT11_ICK);
-	if (res < 0)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: Couldn't enable GPTIMER11 interface clock (%d)", res));
-		goto ExitDisableGPT11FCK;
-	}
-	
-	
-	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_TSICR_SYS_PHYS_BASE;
-	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
-                  4,
-                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-                  &hTimerEnable);
 
-	if (pui32TimerEnable == IMG_NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
-		goto ExitDisableGPT11ICK;
-	}
+	psSysSpecData->gpt_base = ioremap(SYS_OMAP3430_GP11TIMER_PHYS_BASE,
+					  SYS_OMAP3430_GPTIMER_SIZE);
+	if (!psSysSpecData->gpt_base)
+		goto err3;
 
-	rate = *pui32TimerEnable;
-	if(!(rate & 4))
-	{
+	clk_enable(psSysSpecData->psGPT11_ICK);
+	clk_enable(psSysSpecData->psGPT11_FCK);
+
+	rate = gpt_read_reg(psSysData, SYS_OMAP3430_GPTIMER_TSICR);
+	if (!(rate & 4)) {
 		PVR_TRACE(("Setting GPTIMER11 mode to posted (currently is non-posted)"));
-		
-		
-		*pui32TimerEnable = rate | 4;
+		gpt_write_reg(psSysData, SYS_OMAP3430_GPTIMER_TSICR, rate | 4);
 	}
 
-	OSUnMapPhysToLin(pui32TimerEnable,
-		    4,
-		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-		    hTimerEnable);
+	clk_disable(psSysSpecData->psGPT11_FCK);
+	clk_disable(psSysSpecData->psGPT11_ICK);
 
-	
-	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
-	pui32TimerEnable = OSMapPhysToLin(TimerRegPhysBase,
-                  4,
-                  PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-                  &hTimerEnable);
+	return PVRSRV_OK;
 
-	if (pui32TimerEnable == IMG_NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "EnableSystemClocks: OSMapPhysToLin failed"));
-		goto ExitDisableGPT11ICK;
+err3:
+	clk_put(psSysSpecData->psGPT11_ICK);
+err2:
+	clk_put(psSysSpecData->psGPT11_FCK);
+err1:
+	clk_put(psSysSpecData->psMPU_CK);
+err0:
+	PVR_DPF((PVR_DBG_ERROR,
+		 "%s: couldn't init clocks: mpu %p sys %p fck %p ick %p",
+		__func__, psSysSpecData->psMPU_CK, sys_ck,
+		psSysSpecData->psGPT11_FCK, psSysSpecData->psGPT11_ICK));
+
+	psSysSpecData->psMPU_CK = NULL;
+	psSysSpecData->psGPT11_FCK = NULL;
+	psSysSpecData->psGPT11_ICK = NULL;
+
+	return PVRSRV_ERROR_GENERIC;
+}
+
+static void CleanupDebugClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
+
+	if (psSysSpecData->psMPU_CK) {
+		clk_put(psSysSpecData->psMPU_CK);
+		psSysSpecData->psMPU_CK = NULL;
 	}
+	if (psSysSpecData->psGPT11_FCK) {
+		clk_put(psSysSpecData->psGPT11_FCK);
+		psSysSpecData->psGPT11_FCK = NULL;
+	}
+	if (psSysSpecData->psGPT11_ICK) {
+		clk_put(psSysSpecData->psGPT11_ICK);
+		psSysSpecData->psGPT11_ICK = NULL;
+	}
+}
 
-	
-	*pui32TimerEnable = 3;
+static PVRSRV_ERROR EnableDebugClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
 
-	OSUnMapPhysToLin(pui32TimerEnable,
-		    4,
-		    PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-		    hTimerEnable);
+	if (clk_enable(psSysSpecData->psGPT11_FCK) < 0)
+		goto err0;
 
-#endif 
+	if (clk_enable(psSysSpecData->psGPT11_ICK) < 0)
+		goto err1;
+
+	gpt_write_reg(psSysData, SYS_OMAP3430_GPTIMER_ENABLE, 3);
 
 	return PVRSRV_OK;
 
-#if defined(DEBUG) || defined(TIMING)
-ExitDisableGPT11ICK:
+err1:
+	clk_disable(psSysSpecData->psGPT11_FCK);
+err0:
+	PVR_DPF((PVR_DBG_ERROR, "%s: can't enable clocks", __func__));
+
+	return PVRSRV_ERROR_GENERIC;
+}
+
+static inline void DisableDebugClocks(SYS_DATA *psSysData)
+{
+	SYS_SPECIFIC_DATA *psSysSpecData = psSysData->pvSysSpecificData;
+
+	gpt_write_reg(psSysData, SYS_OMAP3430_GPTIMER_ENABLE, 0);
+
 	clk_disable(psSysSpecData->psGPT11_ICK);
-ExitDisableGPT11FCK:
 	clk_disable(psSysSpecData->psGPT11_FCK);
-ExitDisableSGXClocks:
-#if !defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-	DisableSGXClocks(psSysData);
-#endif
-#endif	
-#if !defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
-ExitUnRegisterConstraintNotifications:
+}
+
+#else
+
+PVRSRV_ERROR inline InitDebugClocks(SYS_DATA *psSysData)
+{
+	return PVRSRV_OK;
+}
+
+static void inline CleanupDebugClocks(SYS_DATA *psSysData)
+{
+}
+
+static inline PVRSRV_ERROR EnableDebugClocks(SYS_DATA *psSysData)
+{
+	return PVRSRV_OK;
+}
+
+static inline void DisableDebugClocks(SYS_DATA *psSysData)
+{
+}
 #endif
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))	
-	UnRegisterConstraintNotifications();
-#endif	
-ExitError:
+
+PVRSRV_ERROR InitSystemClocks(SYS_DATA *psSysData)
+{
+	if (InitSgxClocks(psSysData) != PVRSRV_OK)
+		goto err0;
+
+	if (InitDebugClocks(psSysData) != PVRSRV_OK)
+		goto err1;
+
+	return PVRSRV_OK;
+
+err1:
+	CleanupSgxClocks(psSysData);
+err0:
 	return PVRSRV_ERROR_GENERIC;
 }
 
-IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
+void CleanupSystemClocks(SYS_DATA *psSysData)
 {
-	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
-#if defined(DEBUG) || defined(TIMING)
-	IMG_CPU_PHYADDR TimerRegPhysBase;
-	IMG_HANDLE hTimerDisable;
-	IMG_UINT32 *pui32TimerDisable;
-#endif	
+	CleanupDebugClocks(psSysData);
+	CleanupSgxClocks(psSysData);
+}
 
-	PVR_TRACE(("DisableSystemClocks: Disabling System Clocks"));
+PVRSRV_ERROR EnableSystemClocks(SYS_DATA *psSysData)
+{
+	PVR_TRACE(("EnableSystemClocks: Enabling System Clocks"));
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
-	UnRegisterConstraintNotifications();
+#if !defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	if (EnableSGXClocks(psSysData) != PVRSRV_OK)
+		goto err0;
 #endif
-	
-	DisableSGXClocks(psSysData);
 
-#if defined(DEBUG) || defined(TIMING)
-	
-	TimerRegPhysBase.uiAddr = SYS_OMAP3430_GP11TIMER_ENABLE_SYS_PHYS_BASE;
-	pui32TimerDisable = OSMapPhysToLin(TimerRegPhysBase,
-				4,
-				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-				&hTimerDisable);
-	
-	if (pui32TimerDisable == IMG_NULL)
-	{
-		PVR_DPF((PVR_DBG_ERROR, "DisableSystemClocks: OSMapPhysToLin failed"));
-	}
-	else
-	{
-		*pui32TimerDisable = 0;
-		
-		OSUnMapPhysToLin(pui32TimerDisable,
-				4,
-				PVRSRV_HAP_KERNEL_ONLY|PVRSRV_HAP_UNCACHED,
-				hTimerDisable);
-	}
+	if (EnableDebugClocks(psSysData) != PVRSRV_OK)
+		goto err1;
 
-	clk_disable(psSysSpecData->psGPT11_ICK);
+	return PVRSRV_OK;
 
-	clk_disable(psSysSpecData->psGPT11_FCK);
+err1:
+#if !defined(SUPPORT_ACTIVE_POWER_MANAGEMENT)
+	DisableSGXClocks(psSysData);
+err0:
+#endif
+	return PVRSRV_ERROR_GENERIC;
+}
 
-#endif 
+IMG_VOID DisableSystemClocks(SYS_DATA *psSysData)
+{
+	PVR_TRACE(("DisableSystemClocks: Disabling System Clocks"));
+
+	DisableSGXClocks(psSysData);
+	DisableDebugClocks(psSysData);
 }
+
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/3rdparty/dc_omap3430_linux/omaplfb_displayclass.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/3rdparty/dc_omap3430_linux/omaplfb_displayclass.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/3rdparty/dc_omap3430_linux/omaplfb_displayclass.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/3rdparty/dc_omap3430_linux/omaplfb_displayclass.c	2012-12-16 13:13:01.648330146 +0100
@@ -1065,50 +1065,12 @@ ExitTrueUnlock:
 	return IMG_TRUE;	
 }
 
-
-static PVRSRV_ERROR InitDev(OMAPLFB_DEVINFO *psDevInfo)
+static void SetDevinfo(OMAPLFB_DEVINFO *psDevInfo)
 {
-	struct fb_info *psLINFBInfo;
-	struct module *psLINFBOwner;
 	OMAPLFB_FBINFO *psPVRFBInfo = &psDevInfo->sFBInfo;
-	PVRSRV_ERROR eError = PVRSRV_ERROR_GENERIC;
+	struct fb_info *psLINFBInfo = psDevInfo->psLINFBInfo;
 	unsigned long FBSize;
 
-	acquire_console_sem();
-
-	if (fb_idx < 0 || fb_idx >= num_registered_fb)
-	{
-		eError = PVRSRV_ERROR_INVALID_DEVICE;
-		goto errRelSem;
-	}
-
-	psLINFBInfo = registered_fb[fb_idx];
-
-	psLINFBOwner = psLINFBInfo->fbops->owner;
-	if (!try_module_get(psLINFBOwner))
-	{
-		printk(KERN_INFO DRIVER_PREFIX
-			": Couldn't get framebuffer module\n");
-
-		goto errRelSem;
-	}
-
-	if (psLINFBInfo->fbops->fb_open != NULL)
-	{
-		int res;
-
-		res = psLINFBInfo->fbops->fb_open(psLINFBInfo, 0);
-		if (res != 0)
-		{
-			printk(KERN_INFO DRIVER_PREFIX
-				": Couldn't open framebuffer: %d\n", res);
-
-			goto errModPut;
-		}
-	}
-
-	psDevInfo->psLINFBInfo = psLINFBInfo;
-
 	FBSize = (psLINFBInfo->screen_size) != 0 ?
 					psLINFBInfo->screen_size :
 					psLINFBInfo->fix.smem_len;
@@ -1145,7 +1107,9 @@ static PVRSRV_ERROR InitDev(OMAPLFB_DEVI
 	psPVRFBInfo->ui32Height = psLINFBInfo->var.yres;
 	psPVRFBInfo->ui32ByteStride =  psLINFBInfo->fix.line_length;
 	psPVRFBInfo->ui32FBSize = FBSize;
-	psPVRFBInfo->ui32BufferSize = max(psPVRFBInfo->ui32Width, psPVRFBInfo->ui32Height) * psPVRFBInfo->ui32ByteStride;
+	psPVRFBInfo->ui32BufferSize =
+		max(psPVRFBInfo->ui32Height, psPVRFBInfo->ui32Width)
+		* psPVRFBInfo->ui32ByteStride;
 	
 	psPVRFBInfo->ui32RoundedBufferSize = OMAPLFB_PAGE_ROUNDUP(psPVRFBInfo->ui32BufferSize);
 
@@ -1187,6 +1151,81 @@ static PVRSRV_ERROR InitDev(OMAPLFB_DEVI
 	{
 		printk("Unknown FB format\n");
 	}
+		psDevInfo->sDisplayFormat.pixelformat =
+			psDevInfo->sFBInfo.ePixelFormat;
+		psDevInfo->sDisplayDim.ui32Width = psDevInfo->sFBInfo.ui32Width;
+		psDevInfo->sDisplayDim.ui32Height =
+			psDevInfo->sFBInfo.ui32Height;
+		psDevInfo->sDisplayDim.ui32ByteStride =
+			psDevInfo->sFBInfo.ui32ByteStride;
+		psDevInfo->sSystemBuffer.sSysAddr = psDevInfo->sFBInfo.sSysAddr;
+		psDevInfo->sSystemBuffer.sCPUVAddr =
+			psDevInfo->sFBInfo.sCPUVAddr;
+		psDevInfo->sSystemBuffer.ui32BufferSize =
+			psDevInfo->sFBInfo.ui32RoundedBufferSize;
+}
+
+static struct FB_EVENTS
+{
+	struct notifier_block notif;
+	OMAPLFB_DEVINFO *psDevInfo;
+} gFBEventsData;
+
+static int FBEvents(struct notifier_block *psNotif,
+		unsigned long event, void *data)
+{
+	if (event == FB_EVENT_MODE_CHANGE) {
+		struct FB_EVENTS *psEvents =
+			container_of(psNotif, struct FB_EVENTS, notif);
+		SetDevinfo(psEvents->psDevInfo);
+	}
+	return 0;
+}
+
+static PVRSRV_ERROR InitDev(OMAPLFB_DEVINFO *psDevInfo)
+{
+	struct fb_info *psLINFBInfo;
+	struct module *psLINFBOwner;
+	OMAPLFB_FBINFO *psPVRFBInfo = &psDevInfo->sFBInfo;
+	PVRSRV_ERROR eError = PVRSRV_ERROR_GENERIC;
+
+	acquire_console_sem();
+
+	if (fb_idx < 0 || fb_idx >= num_registered_fb) {
+		eError = PVRSRV_ERROR_INVALID_DEVICE;
+		goto errRelSem;
+	}
+
+	psLINFBInfo = registered_fb[fb_idx];
+
+	psLINFBOwner = psLINFBInfo->fbops->owner;
+	if (!try_module_get(psLINFBOwner)) {
+		printk(KERN_INFO DRIVER_PREFIX
+			": Couldn't get framebuffer module\n");
+
+		goto errRelSem;
+	}
+
+	if (psLINFBInfo->fbops->fb_open != NULL) {
+		int res;
+
+		res = psLINFBInfo->fbops->fb_open(psLINFBInfo, 0);
+		if (res != 0) {
+			printk(KERN_INFO DRIVER_PREFIX
+				": Couldn't open framebuffer: %d\n", res);
+
+			goto errModPut;
+		}
+	}
+
+	psDevInfo->psLINFBInfo = psLINFBInfo;
+
+	SetDevinfo(psDevInfo);
+
+	gFBEventsData.notif.notifier_call = FBEvents;
+	gFBEventsData.psDevInfo = psDevInfo;
+	fb_register_client(&gFBEventsData.notif);
+
 
 	
 	psDevInfo->sFBInfo.sSysAddr.uiAddr = psPVRFBInfo->sSysAddr.uiAddr;
@@ -1287,19 +1326,12 @@ PVRSRV_ERROR OMAPLFBInit(IMG_VOID)
 
 		strncpy(psDevInfo->sDisplayInfo.szDisplayName, DISPLAY_DEVICE_NAME, MAX_DISPLAY_NAME_SIZE);
 	
-		psDevInfo->sDisplayFormat.pixelformat = psDevInfo->sFBInfo.ePixelFormat;
-		psDevInfo->sDisplayDim.ui32Width =  psDevInfo->sFBInfo.ui32Width;
-		psDevInfo->sDisplayDim.ui32Height =  psDevInfo->sFBInfo.ui32Height;
-		psDevInfo->sDisplayDim.ui32ByteStride =  psDevInfo->sFBInfo.ui32ByteStride;
 
 		DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
 			": Maximum number of swap chain buffers: %lu\n",
 			psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers));
 
 		
-		psDevInfo->sSystemBuffer.sSysAddr = psDevInfo->sFBInfo.sSysAddr;
-		psDevInfo->sSystemBuffer.sCPUVAddr = psDevInfo->sFBInfo.sCPUVAddr;
-		psDevInfo->sSystemBuffer.ui32BufferSize = (psDevInfo->sFBInfo.ui32RoundedBufferSize);
 
 		
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/3rdparty/dc_omap3430_linux/omaplfb_linux.c kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/3rdparty/dc_omap3430_linux/omaplfb_linux.c
--- kernel-2.6.28-20091602+0m5/drivers/gpu/pvr/services4/3rdparty/dc_omap3430_linux/omaplfb_linux.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/gpu/pvr/services4/3rdparty/dc_omap3430_linux/omaplfb_linux.c	2012-12-16 13:13:01.648330146 +0100
@@ -43,8 +43,6 @@
 
 #include <asm/io.h>
 
-#define TG_PATCHES 1
-
 /*#include <asm/arch-omap/display.h>*/
 
 #include "img_defs.h"
@@ -53,7 +51,6 @@
 #include "omaplfb.h"
 #include "pvrmodule.h"
 
-#if defined(TG_PATCHES)
 #if defined(CONFIG_FB_OMAP) || defined(CONFIG_FB_OMAP_MODULE)
 extern void omap_dispc_set_plane_base(int plane, IMG_UINT32 phys_addr);
 #elif defined(CONFIG_FB_OMAP2) || defined(CONFIG_FB_OMAP2_MODULE) 
@@ -61,7 +58,6 @@ extern void omap_dispc_set_plane_base(in
 #else
 #error "PVR needs OMAPFB, but it's disabled"
 #endif
-#endif
 
 MODULE_SUPPORTED_DEVICE(DEVNAME);
 
@@ -92,68 +88,23 @@ PVRSRV_ERROR OMAPLFBGetLibFuncAddr (IMG_
 	return PVRSRV_OK;
 }
 
-static IMG_VOID OMAPLFBVSyncWriteReg(OMAPLFB_SWAPCHAIN *psSwapChain, IMG_UINT32 ui32Offset, IMG_UINT32 ui32Value)
-{
-	IMG_VOID *pvRegAddr = (IMG_VOID *)((IMG_UINT8 *)psSwapChain->pvRegs + ui32Offset);
-
-	
-	writel(ui32Value, pvRegAddr);
-}
-
-static IMG_UINT32 OMAPLFBVSyncReadReg(OMAPLFB_SWAPCHAIN *psSwapChain, IMG_UINT32 ui32Offset)
-{
-	return readl((IMG_UINT8 *)psSwapChain->pvRegs + ui32Offset);
-}
-
 IMG_VOID OMAPLFBEnableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain)
 {
-#if defined(TG_PATCHES)
-#else
-	#if defined(SYS_USING_INTERRUPTS)
-	
-	IMG_UINT32 ui32InterruptEnable  = OMAPLFBVSyncReadReg(psSwapChain, OMAPLCD_IRQENABLE);
-	ui32InterruptEnable |= OMAPLCD_INTMASK_VSYNC;
-	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_IRQENABLE, ui32InterruptEnable );
-	#endif
-#endif
 }
 
 IMG_VOID OMAPLFBDisableVSyncInterrupt(OMAPLFB_SWAPCHAIN *psSwapChain)
 {
-#if defined(TG_PATCHES)
-#else
-	#if defined(SYS_USING_INTERRUPTS)
-	
-	IMG_UINT32 ui32InterruptEnable = OMAPLFBVSyncReadReg(psSwapChain, OMAPLCD_IRQENABLE);
-	ui32InterruptEnable &= ~(OMAPLCD_INTMASK_VSYNC);
-	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_IRQENABLE, ui32InterruptEnable);
-	#endif
-#endif
 }
 
 #if defined(SYS_USING_INTERRUPTS)
-	#if defined(TG_PATCHES)
-#if defined(CONFIG_FB_OMAP) || defined(CONFIG_FB_OMAP_MODULE) 
-static void
-OMAPLFBVSyncISR(void *arg)
+#if defined(CONFIG_FB_OMAP) || defined(CONFIG_FB_OMAP_MODULE)
+static void OMAPLFBVSyncISR(void *arg)
 #else
-static void
-OMAPLFBVSyncISR(void *arg, u32 mask)
+static void OMAPLFBVSyncISR(void *arg, u32 mask)
 #endif
 {
-	(void) OMAPLFBVSyncIHandler((OMAPLFB_SWAPCHAIN *)arg);
-}
-	#else
-static void
-OMAPLFBVSyncISR(void *arg, struct pt_regs unref__ *regs)
-{
-	
-	
-	OMAPLFB_SWAPCHAIN *psSwapChain= (OMAPLFB_SWAPCHAIN *)arg;
-	
-	(void) OMAPLFBVSyncIHandler(psSwapChain);
+	(void)OMAPLFBVSyncIHandler((OMAPLFB_SWAPCHAIN *) arg);
 }
-	#endif
 #endif
 
 #if defined(CONFIG_FB_OMAP) || defined(CONFIG_FB_OMAP_MODULE)
@@ -162,54 +113,26 @@ OMAPLFBVSyncISR(void *arg, struct pt_reg
 
 PVRSRV_ERROR OMAPLFBInstallVSyncISR(OMAPLFB_SWAPCHAIN *psSwapChain)
 {
-#if defined(TG_PATCHES)
-
 #if defined(CONFIG_FB_OMAP) || defined(CONFIG_FB_OMAP_MODULE)
 	if (omap_dispc_request_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain) != 0)
-    	return PVRSRV_ERROR_OUT_OF_MEMORY; /* not worth a proper mapping */
+		return PVRSRV_ERROR_OUT_OF_MEMORY;
 #else
 	if (omap_dispc_register_isr(OMAPLFBVSyncISR, psSwapChain, DISPC_IRQ_VSYNC) != 0)
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 #endif
 
-#else
-
-	#if defined(SYS_USING_INTERRUPTS)
-	OMAPLFBDisableVSyncInterrupt(psSwapChain);
-
-	if (omap2_disp_register_isr(OMAPLFBVSyncISR, psSwapChain,
-				    DISPC_IRQSTATUS_VSYNC))
-	{
-		printk(KERN_INFO DRIVER_PREFIX ": OMAPLFBInstallVSyncISR: Request OMAPLCD IRQ failed\n");
-		return PVRSRV_ERROR_INIT_FAILURE;
-	}
-		
-	#endif	
-#endif    	
-    return PVRSRV_OK;
+	return PVRSRV_OK;
 }
 
 
 PVRSRV_ERROR OMAPLFBUninstallVSyncISR (OMAPLFB_SWAPCHAIN *psSwapChain)
 {
-#if defined(TG_PATCHES)
-
 #if defined(CONFIG_FB_OMAP) || defined(CONFIG_FB_OMAP_MODULE)
 	omap_dispc_free_irq(DISPC_IRQ_VSYNC, OMAPLFBVSyncISR, psSwapChain);
 #else
 	omap_dispc_unregister_isr(OMAPLFBVSyncISR, psSwapChain, DISPC_IRQ_VSYNC);
 #endif
- 	return PVRSRV_OK;
- 	
-#else 	
- 	
-	#if defined(SYS_USING_INTERRUPTS)
-	OMAPLFBDisableVSyncInterrupt(psSwapChain);
-
-	omap2_disp_unregister_isr(OMAPLFBVSyncISR);
-		
-	#endif 	
-#endif 	
+	return PVRSRV_OK;
 }
 
 IMG_VOID OMAPLFBEnableDisplayRegisterAccess(IMG_VOID)
@@ -224,8 +147,7 @@ IMG_VOID OMAPLFBDisableDisplayRegisterAc
 	/*omap2_disp_put_dss();*/
 }
 
-#if defined(TG_PATCHES)
-static void set_plane_base(IMG_UINT32 aPhyAddr)
+IMG_VOID OMAPLFBFlip(OMAPLFB_SWAPCHAIN * psSwapChain, IMG_UINT32 aPhyAddr)
 {
 #if defined(CONFIG_FB_OMAP) || defined(CONFIG_FB_OMAP_MODULE)
 	omap_dispc_set_plane_base(0, aPhyAddr);
@@ -233,36 +155,6 @@ static void set_plane_base(IMG_UINT32 aP
 	omap_dispc_set_plane_ba0(OMAP_DSS_CHANNEL_LCD, OMAP_DSS_GFX, aPhyAddr);
 #endif
 }
-#endif
-
-IMG_VOID OMAPLFBFlip(OMAPLFB_SWAPCHAIN *psSwapChain, IMG_UINT32 aPhyAddr)
-{
-#if defined(TG_PATCHES)
- 	if (1 /* omap2_disp_get_output_dev(OMAP2_GRAPHICS) == OMAP2_OUTPUT_LCD */)
-  	{
-		set_plane_base(aPhyAddr);
-  		return PVRSRV_OK;
-  	}
-  	else
- 	if (0 /*omap2_disp_get_output_dev(OMAP2_GRAPHICS) == OMAP2_OUTPUT_TV*/)
-  	{
-		set_plane_base(aPhyAddr);
-  		return PVRSRV_OK;
-  	}
-
-#else	
-	
-	IMG_UINT32 control;
-
-	
-	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_GFX_BA0, aPhyAddr);
-	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_GFX_BA1, aPhyAddr);
-
-	control = OMAPLFBVSyncReadReg(psSwapChain, OMAPLCD_CONTROL);
-	control |= OMAP_CONTROL_GOLCD;
-	OMAPLFBVSyncWriteReg(psSwapChain, OMAPLCD_CONTROL, control);
-#endif
-}
 
 #if defined(LDM_PLATFORM)
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/char/hw_random/Kconfig kernel-2.6.28-20093908+0m5/drivers/char/hw_random/Kconfig
--- kernel-2.6.28-20091602+0m5/drivers/char/hw_random/Kconfig	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/char/hw_random/Kconfig	2012-12-16 13:13:01.652330146 +0100
@@ -134,3 +134,16 @@ config HW_RANDOM_VIRTIO
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called virtio-rng.  If unsure, say N.
+
+config HW_RANDOM_OMAP3_ROM
+	tristate "OMAP3 ROM Random Number Generator support"
+	depends on HW_RANDOM && ARCH_OMAP34XX
+	default HW_RANDOM
+	---help---
+	  This driver provides kernel-side support for the Random Number
+	  Generator hardware found on OMAP34xx processors.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called omap3-rom-rng.
+
+	  If unsure, say Y.
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/char/hw_random/Makefile kernel-2.6.28-20093908+0m5/drivers/char/hw_random/Makefile
--- kernel-2.6.28-20091602+0m5/drivers/char/hw_random/Makefile	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/char/hw_random/Makefile	2012-12-16 13:13:01.652330146 +0100
@@ -14,3 +14,5 @@ obj-$(CONFIG_HW_RANDOM_IXP4XX) += ixp4xx
 obj-$(CONFIG_HW_RANDOM_OMAP) += omap-rng.o
 obj-$(CONFIG_HW_RANDOM_PASEMI) += pasemi-rng.o
 obj-$(CONFIG_HW_RANDOM_VIRTIO) += virtio-rng.o
+obj-$(CONFIG_HW_RANDOM_OMAP3_ROM) += omap3-rom-rng.o
+omap3-rom-rng-y := omap3-rom-drv.o omap3-rom-asm.o
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/char/hw_random/omap3-rom-asm.S kernel-2.6.28-20093908+0m5/drivers/char/hw_random/omap3-rom-asm.S
--- kernel-2.6.28-20091602+0m5/drivers/char/hw_random/omap3-rom-asm.S	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/char/hw_random/omap3-rom-asm.S	2012-12-16 13:13:01.652330146 +0100
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+
+ENTRY(omap3_rng_call_rom_asm)
+	stmfd	sp!, {r4-r12, lr}
+	stmfd	sp!, {r0-r3}
+	bl	v7_flush_dcache_all
+	ldmfd	sp!, {r0-r3}
+	mov	r6, #0xff
+	mov	r12, r0
+	smc	#1
+	mov	r12, r0
+	bl	v7_flush_dcache_all
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c5, 0
+	mov	r0, r12
+	ldmfd	sp!, {r4-r12, pc}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/char/hw_random/omap3-rom-drv.c kernel-2.6.28-20093908+0m5/drivers/char/hw_random/omap3-rom-drv.c
--- kernel-2.6.28-20091602+0m5/drivers/char/hw_random/omap3-rom-drv.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/char/hw_random/omap3-rom-drv.c	2012-12-16 13:13:01.652330146 +0100
@@ -0,0 +1,156 @@
+/*
+ * omap3-rom-drv.c - RNG driver for TI OMAP3 CPU family
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ * Author: Juha Yrjola <juha.yrjola@solidboot.com>
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/random.h>
+#include <linux/hw_random.h>
+#include <linux/timer.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+
+#include <mach/cpu.h>
+
+#define SEC_HAL_RNG_GENERATE		29
+#define RNG_RESET			0x01
+#define RNG_GEN_PRNG_HW_INIT		0x02
+#define RNG_GEN_HW			0x08
+
+static const char *omap3_rom_rng_name = "OMAP3 ROM RNG";
+
+extern u32 omap3_rng_call_rom_asm(u32 id, u32 proc, u32 flags, u32 va_ptr);
+
+static int call_sec_rom(u32 appl_id, u32 proc_id, u32 flag, ...)
+{
+	va_list ap;
+	u32 ret;
+	u32 val;
+
+	va_start(ap, flag);
+	val = *(u32 *) &ap;
+	local_irq_disable();
+	local_fiq_disable();
+	ret = omap3_rng_call_rom_asm(appl_id, proc_id, flag,
+				     (u32) virt_to_phys((void *) val));
+	local_fiq_enable();
+	local_irq_enable();
+	va_end(ap);
+
+	return ret;
+}
+
+static struct timer_list idle_timer;
+static int rng_idle;
+static struct clk *rng_clk;
+
+static void omap3_rom_idle_rng(unsigned long data)
+{
+	int r;
+
+	r = call_sec_rom(SEC_HAL_RNG_GENERATE, 0, 0, 3, NULL, 0,
+			 RNG_RESET);
+	if (r != 0) {
+		printk(KERN_ERR "%s: reset failed: %d\n",
+		       omap3_rom_rng_name, r);
+		return;
+	}
+	clk_disable(rng_clk);
+	rng_idle = 1;
+}
+
+static int omap3_rom_get_random(void *buf, unsigned int count)
+{
+	u32 r;
+	u32 ptr;
+
+	del_timer_sync(&idle_timer);
+	if (rng_idle) {
+		clk_enable(rng_clk);
+		r = call_sec_rom(SEC_HAL_RNG_GENERATE, 0, 0, 3, NULL, 0,
+				 RNG_GEN_PRNG_HW_INIT);
+		if (r != 0) {
+			clk_disable(rng_clk);
+			printk(KERN_ERR "%s: HW init failed: %d\n",
+			       omap3_rom_rng_name, r);
+			return -EIO;
+		}
+		rng_idle = 0;
+	}
+
+	ptr = virt_to_phys(buf);
+	r = call_sec_rom(SEC_HAL_RNG_GENERATE, 0, 0, 3, ptr,
+			 count, RNG_GEN_HW);
+	mod_timer(&idle_timer, jiffies + msecs_to_jiffies(500));
+	if (r != 0)
+		return -EINVAL;
+	return 0;
+}
+
+static int omap3_rom_rng_data_present(struct hwrng *rng, int wait)
+{
+	return 1;
+}
+
+static int omap3_rom_rng_data_read(struct hwrng *rng, u32 *data)
+{
+	int r;
+
+	r = omap3_rom_get_random(data, 4);
+	if (r < 0)
+		return r;
+	return 4;
+}
+
+static struct hwrng omap3_rom_rng_ops = {
+	.name		= "omap3-rom",
+	.data_present	= omap3_rom_rng_data_present,
+	.data_read	= omap3_rom_rng_data_read,
+};
+
+static int __init omap3_rom_rng_init(void)
+{
+	printk(KERN_INFO "%s: initializing\n", omap3_rom_rng_name);
+	if (!cpu_is_omap34xx()) {
+		printk(KERN_ERR "%s: currently supports only OMAP34xx CPUs\n",
+		       omap3_rom_rng_name);
+		return -ENODEV;
+	}
+	if (omap_type() == OMAP2_DEVICE_TYPE_GP) {
+		printk(KERN_ERR "%s: GP OMAPs not supported\n",
+		       omap3_rom_rng_name);
+		return -ENODEV;
+	}
+
+	setup_timer(&idle_timer, omap3_rom_idle_rng, 0);
+	rng_clk = clk_get(NULL, "rng_ick");
+	if (IS_ERR(rng_clk)) {
+		printk(KERN_ERR "%s: unable to get RNG clock\n",
+		       omap3_rom_rng_name);
+		return IS_ERR(rng_clk);
+	}
+
+	/* Leave the RNG in reset state. */
+	clk_enable(rng_clk);
+	omap3_rom_idle_rng(0);
+
+	return hwrng_register(&omap3_rom_rng_ops);
+}
+
+static void __exit omap3_rom_rng_exit(void)
+{
+	hwrng_unregister(&omap3_rom_rng_ops);
+}
+
+module_init(omap3_rom_rng_init);
+module_exit(omap3_rom_rng_exit);
+
+MODULE_AUTHOR("Juha Yrjola");
+MODULE_LICENSE("GPL");
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/char/keyboard.c kernel-2.6.28-20093908+0m5/drivers/char/keyboard.c
--- kernel-2.6.28-20091602+0m5/drivers/char/keyboard.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/char/keyboard.c	2012-12-16 13:13:01.652330146 +0100
@@ -1035,6 +1035,7 @@ DECLARE_TASKLET_DISABLED(keyboard_taskle
     defined(CONFIG_MIPS) || defined(CONFIG_PPC) || defined(CONFIG_SPARC) ||\
     defined(CONFIG_PARISC) || defined(CONFIG_SUPERH) ||\
     (defined(CONFIG_ARM) && defined(CONFIG_KEYBOARD_ATKBD) && !defined(CONFIG_ARCH_RPC)) ||\
+    (defined(CONFIG_ARM) && defined(CONFIG_KEYBOARD_TWL4030) && !defined(CONFIG_ARCH_RPC)) ||\
     defined(CONFIG_AVR32)
 
 #define HW_RAW(dev) (test_bit(EV_MSC, dev->evbit) && test_bit(MSC_RAW, dev->mscbit) &&\
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/char/random.c kernel-2.6.28-20093908+0m5/drivers/char/random.c
--- kernel-2.6.28-20091602+0m5/drivers/char/random.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/char/random.c	2012-12-16 13:13:01.652330146 +0100
@@ -1469,7 +1469,8 @@ static void rekey_seq_generator(struct w
 	keyptr->count = (ip_cnt & COUNT_MASK) << HASH_BITS;
 	smp_wmb();
 	ip_cnt++;
-	schedule_delayed_work(&rekey_work, REKEY_INTERVAL);
+	schedule_delayed_work(&rekey_work,
+			      round_jiffies_relative(REKEY_INTERVAL));
 }
 
 static inline struct keydata *get_keyptr(void)
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/input/keyboard/omap-twl4030keypad.c kernel-2.6.28-20093908+0m5/drivers/input/keyboard/omap-twl4030keypad.c
--- kernel-2.6.28-20091602+0m5/drivers/input/keyboard/omap-twl4030keypad.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/input/keyboard/omap-twl4030keypad.c	2012-12-16 13:13:01.652330146 +0100
@@ -201,6 +201,7 @@ static void twl4030_kp_report_changes(st
 		}
 		kp->kp_state[row] = new_state[row];
 	}
+	input_sync(kp->omap_twl4030kp);
 }
 
 static inline int twl4030_kp_disabled(struct omap_keypad *kp)
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/input/touchscreen/tsc2005.c kernel-2.6.28-20093908+0m5/drivers/input/touchscreen/tsc2005.c
--- kernel-2.6.28-20091602+0m5/drivers/input/touchscreen/tsc2005.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/input/touchscreen/tsc2005.c	2012-12-16 13:13:01.652330146 +0100
@@ -27,7 +27,6 @@
 #include <linux/input.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
-#include <linux/gpio.h>
 #include <linux/spi/spi.h>
 
 #include <linux/spi/tsc2005.h>
@@ -194,7 +193,7 @@ struct tsc2005 {
 	char			phys[32];
 	struct timer_list	penup_timer;
 
-	/* ESD recovery via a hardware reset (GPIO) if the tsc2005
+	/* ESD recovery via a hardware reset if the tsc2005
 	 * doesn't respond after a configurable period (in ms) of
 	 * IRQ/SPI inactivity. If esd_timeout is 0, timer and work
 	 * fields are used.
@@ -202,7 +201,6 @@ struct tsc2005 {
 	u32			esd_timeout;
 	struct timer_list	esd_timer;
 	struct work_struct	esd_work;
-	s16			reset_gpio;
 
 	spinlock_t		lock;
 	struct mutex		mutex;
@@ -242,6 +240,8 @@ struct tsc2005 {
 	u8			disabled;
 	u8			disable_depth;
 	u8			spi_pending;
+
+	void (*set_reset)(bool enable);
 };
 
 static void tsc2005_cmd(struct tsc2005 *ts, u8 cmd)
@@ -434,18 +434,17 @@ out:
 	} else
 		ts->spi_pending = 0;
 
-	spin_unlock_irqrestore(&ts->lock, flags);
-
 	/* kick pen up timer - to make sure it expires again(!) */
 	if (ts->sample_sent) {
 		mod_timer(&ts->penup_timer,
 			  jiffies + msecs_to_jiffies(TSC2005_TS_PENUP_TIME));
 		/* Also kick the watchdog, as we still think we're alive */
-		if (ts->esd_timeout) {
+		if (ts->esd_timeout && ts->disable_depth == 0) {
 			unsigned long wdj = msecs_to_jiffies(ts->esd_timeout);
 			mod_timer(&ts->esd_timer, round_jiffies(jiffies+wdj));
 		}
 	}
+	spin_unlock_irqrestore(&ts->lock, flags);
 }
 
 /* This penup timer is very forgiving of delayed SPI reads. The
@@ -473,11 +472,13 @@ static void tsc2005_ts_penup_timer_handl
 static irqreturn_t tsc2005_ts_irq_handler(int irq, void *dev_id)
 {
 	struct tsc2005 *ts = dev_id;
+	if (ts->disable_depth)
+		goto out;
 
 	if (!ts->spi_pending) {
 		if (spi_async(ts->spi, &ts->read_msg)) {
 			dev_err(&ts->spi->dev, "ts: spi_async() failed");
-			return IRQ_HANDLED;
+			goto out;
 		}
 	}
 	/* By shifting in 1s we can never wrap */
@@ -494,6 +495,7 @@ static irqreturn_t tsc2005_ts_irq_handle
 		ts->penup_timer.expires = jiffies + pu;
 		add_timer(&ts->penup_timer);
 	}
+out:
 	return IRQ_HANDLED;
 }
 
@@ -569,17 +571,18 @@ static void tsc2005_disable(struct tsc20
 
 static void tsc2005_enable(struct tsc2005 *ts)
 {
-	if (--ts->disable_depth != 0)
-		return;
+	if (ts->disable_depth != 1)
+		goto out;
 
 	if (ts->esd_timeout) {
 		unsigned long wdj = msecs_to_jiffies(ts->esd_timeout);
 		ts->esd_timer.expires = round_jiffies(jiffies+wdj);
 		add_timer(&ts->esd_timer);
 	}
-	enable_irq(ts->spi->irq);
-
 	tsc2005_start_scan(ts);
+	enable_irq(ts->spi->irq);
+out:
+	--ts->disable_depth;
 }
 
 static ssize_t tsc2005_disable_show(struct device *dev,
@@ -619,6 +622,64 @@ out:
 static DEVICE_ATTR(disable_ts, 0664, tsc2005_disable_show,
 		   tsc2005_disable_store);
 
+static ssize_t tsc2005_ctrl_selftest_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	u16 temp_high_orig, temp_high_test, temp_high;
+	unsigned int result = 1;
+	struct tsc2005 *ts = dev_get_drvdata(dev);
+
+	if (!ts->set_reset) {
+		dev_warn(&ts->spi->dev,
+			 "unable to selftest: reset not configured\n");
+		result = 0;
+		goto out;
+	}
+
+	mutex_lock(&ts->mutex);
+	tsc2005_disable(ts);
+
+	/* Test ctrl communications via temp high / low registers */
+	tsc2005_read(ts, TSC2005_REG_TEMP_HIGH, &temp_high_orig);
+
+	temp_high_test = (temp_high_orig - 1) & 0x0FFF;
+
+	tsc2005_write(ts, TSC2005_REG_TEMP_HIGH, temp_high_test);
+
+	tsc2005_read(ts, TSC2005_REG_TEMP_HIGH, &temp_high);
+
+	if (temp_high != temp_high_test) {
+		result = 0;
+		dev_warn(dev, "selftest failed: %d != %d\n",
+			 temp_high, temp_high_test);
+	}
+
+	/* HW Reset */
+	ts->set_reset(0);
+	msleep(1); /* only 10us required */
+	ts->set_reset(1);
+
+	tsc2005_enable(ts);
+
+	/* Test that reset really happened */
+	tsc2005_read(ts, TSC2005_REG_TEMP_HIGH, &temp_high);
+
+	if (temp_high != temp_high_orig) {
+		result = 0;
+		dev_warn(dev, "selftest failed after reset: "
+			 "%d != %d\n",
+			 temp_high, temp_high_orig);
+	}
+
+	mutex_unlock(&ts->mutex);
+
+out:
+	return sprintf(buf, "%u\n", result);
+}
+
+static DEVICE_ATTR(ts_ctrl_selftest, S_IRUGO, tsc2005_ctrl_selftest_show, NULL);
+
 static void tsc2005_esd_timer_handler(unsigned long data)
 {
 	struct tsc2005 *ts = (struct tsc2005 *)data;
@@ -651,14 +712,14 @@ static void tsc2005_rst_handler(struct w
 		/* If this timer kicked in, the penup timer, if ever active
 		 * at all, must have expired ages ago, so no need to del it.
 		 */
-		gpio_set_value(ts->reset_gpio, 0);
+		ts->set_reset(0);
 		if (ts->sample_sent) {
 			tsc2005_ts_update_pen_state(ts, 0, 0, 0);
 			ts->sample_sent = 0;
 		}
 		ts->spi_pending = 0;
 		msleep(1); /* only 10us required */
-		gpio_set_value(ts->reset_gpio, 1);
+		ts->set_reset(1);
 		tsc2005_start_scan(ts);
 	}
 	wdj = msecs_to_jiffies(ts->esd_timeout);
@@ -693,6 +754,8 @@ static int __devinit tsc2005_ts_init(str
 	ts->touch_pressure	= pdata->ts_touch_pressure ? : ts->p_max;
 	ts->fudge_p		= pdata->ts_pressure_fudge ? : 2;
 
+	ts->set_reset		= pdata->set_reset;
+
 	idev = input_allocate_device();
 	if (idev == NULL) {
 		r = -ENOMEM;
@@ -737,15 +800,25 @@ static int __devinit tsc2005_ts_init(str
 	}
 
 	/* We can tolerate these failing */
-	if (device_create_file(&ts->spi->dev, &dev_attr_pen_down));
-	if (device_create_file(&ts->spi->dev, &dev_attr_disable_ts));
+	r = device_create_file(&ts->spi->dev, &dev_attr_ts_ctrl_selftest);
+	if (r < 0)
+		dev_warn(&ts->spi->dev, "can't create sysfs file for %s: %d\n",
+			 dev_attr_ts_ctrl_selftest.attr.name, r);
+
+	r = device_create_file(&ts->spi->dev, &dev_attr_pen_down);
+	if (r < 0)
+		dev_warn(&ts->spi->dev, "can't create sysfs file for %s: %d\n",
+			 dev_attr_pen_down.attr.name, r);
+
+	r = device_create_file(&ts->spi->dev, &dev_attr_disable_ts);
+	if (r < 0)
+		dev_warn(&ts->spi->dev, "can't create sysfs file for %s: %d\n",
+			 dev_attr_disable_ts.attr.name, r);
 
 	/* Finally, configure and start the optional EDD watchdog. */
 	ts->esd_timeout = pdata->esd_timeout;
-	if (ts->esd_timeout) {
+	if (ts->esd_timeout && ts->set_reset) {
 		unsigned long wdj;
-		ts->reset_gpio = pdata->reset_gpio;
-		/* Presume the platform has already set up reset GPIO */
 		setup_timer(&ts->esd_timer, tsc2005_esd_timer_handler,
 			    (unsigned long)ts);
 		INIT_WORK(&ts->esd_work, tsc2005_rst_handler);
@@ -817,6 +890,7 @@ static int __devexit tsc2005_remove(stru
 
 	device_remove_file(&ts->spi->dev, &dev_attr_disable_ts);
 	device_remove_file(&ts->spi->dev, &dev_attr_pen_down);
+	device_remove_file(&ts->spi->dev, &dev_attr_ts_ctrl_selftest);
 
 	free_irq(ts->spi->irq, ts);
 	input_unregister_device(ts->idev);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/i2c/busses/i2c-omap.c kernel-2.6.28-20093908+0m5/drivers/i2c/busses/i2c-omap.c
--- kernel-2.6.28-20091602+0m5/drivers/i2c/busses/i2c-omap.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/i2c/busses/i2c-omap.c	2012-12-16 13:13:01.652330146 +0100
@@ -37,6 +37,7 @@
 #include <linux/platform_device.h>
 #include <linux/clk.h>
 #include <linux/io.h>
+#include <mach/omap-pm.h>
 
 /* I2C controller revisions */
 #define OMAP_I2C_REV_2			0x20
@@ -373,13 +374,17 @@ static int omap_i2c_init(struct omap_i2c
 
 		/* If configured for High Speed */
 		if (dev->speed > 400) {
+			unsigned long scl;
+
 			/* For first phase of HS mode */
-			fsscll = internal_clk / (400 * 2) - 6;
-			fssclh = internal_clk / (400 * 2) - 6;
+			scl = internal_clk / 400;
+			fsscll = scl - (scl / 3) - 7;
+			fssclh = (scl / 3) - 5;
 
 			/* For second phase of HS mode */
-			hsscll = fclk_rate / (dev->speed * 2) - 6;
-			hssclh = fclk_rate / (dev->speed * 2) - 6;
+			scl = fclk_rate / dev->speed;
+			hsscll = scl - (scl / 3) - 7;
+			hssclh = (scl / 3) - 9;
 		} else {
 			/* To handle F/S modes */
 			fsscll = internal_clk / (dev->speed * 2) - 3;
@@ -528,8 +533,15 @@ static int omap_i2c_xfer_msg(struct i2c_
 	 * REVISIT: We should abort the transfer on signals, but the bus goes
 	 * into arbitration and we're currently unable to recover from it.
 	 */
+	/*
+	 * REVISIT: Add a mpu wake-up latency constraint to let us wake
+	 * quickly enough for i2c transfers to work properly. Should change
+	 * the code to use a latency constraint function passed from pdata.
+	 */
+	omap_pm_set_max_mpu_wakeup_lat(dev->dev, 500);
 	r = wait_for_completion_timeout(&dev->cmd_complete,
 					OMAP_I2C_TIMEOUT);
+	omap_pm_set_max_mpu_wakeup_lat(dev->dev, -1);
 	dev->buf_len = 0;
 	if (r < 0)
 		return r;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/i2c/chips/lis302dl.c kernel-2.6.28-20093908+0m5/drivers/i2c/chips/lis302dl.c
--- kernel-2.6.28-20091602+0m5/drivers/i2c/chips/lis302dl.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/i2c/chips/lis302dl.c	2012-12-16 13:13:01.656330147 +0100
@@ -21,8 +21,6 @@
  * 02110-1301 USA
  */
 
-#define DEBUG
-
 #include <linux/module.h>
 #include <linux/i2c.h>
 #include <linux/interrupt.h>
@@ -33,7 +31,6 @@
 #include <linux/lis302dl.h>
 #include <mach/board.h>
 
-
 #define DRIVER_NAME  "lis302dl"
 
 #define LIS302_WHOAMI			0x0f
@@ -82,11 +79,15 @@
 /* Default values */
 #define LIS302_THS		810	/* mg    */
 #define LIS302_DURATION		500	/* ms    */
-#define LIS302_400HZ		0	/* 0 / 1 */
-#define LIS302_FS		0	/* 0 / 1 */
+#define LIS302_400HZ		1	/* sample rate 400Hz */
+#define LIS302_100HZ		0	/* sample rate 100Hz */
+#define LIS302_FS		0	/* full scale 0 / 1 */
 #define LIS302_SAMPLES		1
 #define LIS302_SMALL_UNIT	18	/* Typical value 18 mg/digit */
 #define LIS302_BIG_UNIT		72	/* Typical value 72 mg/digit */
+#define LIS302_TURN_ON_TIME	3000	/* Turn on time 3000ms / data rate */
+
+#define LIS302_POWEROFF_DELAY	(5 * HZ)
 
 /* A lis302dl chip will contain this value in LIS302_WHOAMI register */
 #define LIS302_WHOAMI_VALUE	0x3b
@@ -96,6 +97,7 @@ struct lis302dl_chip {
 	struct mutex		lock;
 	struct i2c_client	*client;
 	struct work_struct	work1, work2;
+	struct delayed_work	poweroff_work;
 	int			irq1, irq2;
 	uint8_t			power;
 	int			threshold;
@@ -153,7 +155,7 @@ static int lis302dl_configure(struct i2c
 	/* REG 1*/
 	/* Controls power, scale, data rate, and enabled axis */
 	r |= lis->sample_rate ? LIS302_CTRL1_DR : 0;
-	r |= lis->fs ? LIS302_CTRL1_PD : 0;
+	r |= lis->fs ? LIS302_CTRL1_FS : 0;
 	r |= LIS302_CTRL1_PD | LIS302_CTRL1_X | LIS302_CTRL1_Y | LIS302_CTRL1_Z;
 	ret = lis302dl_write(c, LIS302_CTRL_1, r);
 	if (ret < 0)
@@ -285,29 +287,51 @@ static void set_ths(struct i2c_client *c
 
 static int lis302dl_power(struct lis302dl_chip *chip, int on)
 {
-	u8 reg;
-	int result;
+	u8 reg, regwant;
+	int result, delay;
 
 	reg = lis302dl_read(chip->client, LIS302_CTRL_1);
 	if (on)
-		reg |= LIS302_CTRL1_PD;
+		regwant = reg | LIS302_CTRL1_PD;
 	else
-		reg &= ~LIS302_CTRL1_PD;
-
-	result = lis302dl_write(chip->client, LIS302_CTRL_1, reg);
+		regwant = reg & ~LIS302_CTRL1_PD;
 
+	/* Avoid unnecessary writes */
+	if (reg == regwant)
+		return 0;
+
+	result = lis302dl_write(chip->client, LIS302_CTRL_1, regwant);
+
+	/* turn on time delay depends on data rate */
+	if (on) {
+		delay = (chip->sample_rate ? (LIS302_TURN_ON_TIME / 400) :
+			 (LIS302_TURN_ON_TIME / 100)) + 1;
+		msleep(delay);
+	}
 	if (!result)
 		chip->power = !!on;
 
 	return !!result;
 }
 
+static void lis302dl_poweroff_work(struct work_struct *work)
+{
+	struct lis302dl_chip *chip =
+		container_of(work, struct lis302dl_chip, poweroff_work.work);
+	mutex_lock(&chip->lock);
+	lis302dl_power(chip, 0);
+	mutex_unlock(&chip->lock);
+}
+
 static int lis302dl_selftest(struct lis302dl_chip *chip)
 {
 	u8 reg;
 	s8 x, y, z;
+	s8 powerbit;
 
 	reg = lis302dl_read(chip->client, LIS302_CTRL_1);
+	powerbit = reg & LIS302_CTRL1_PD;
+	reg |= LIS302_CTRL1_PD;
 	lis302dl_write(chip->client, LIS302_CTRL_1, (reg | LIS302_CTRL1_STP));
 	msleep(30);
 	x = (s8)lis302dl_read(chip->client, LIS302_X);
@@ -320,12 +344,18 @@ static int lis302dl_selftest(struct lis3
 	y -= (s8)lis302dl_read(chip->client, LIS302_Y);
 	z -= (s8)lis302dl_read(chip->client, LIS302_Z);
 
+	/* Return to passive state if we were in it. */
+	if (!powerbit)
+		lis302dl_write(chip->client,
+			       LIS302_CTRL_1,
+			       reg & ~LIS302_CTRL1_PD);
+
 	/* Now check that delta is within specified range for each axis */
-	if (x < -16 || x > -3)
+	if (x < -32 || x > -3)
 		return -1;
-	if (y < 3 || y > 16)
+	if (y < 3 || y > 32)
 		return -1;
-	if (z < 3 || y > 16)
+	if (z < 3 || z > 32)
 		return -1;
 
 	/* test passed */
@@ -581,13 +611,14 @@ static ssize_t lis302dl_show_coord(struc
 
 	x = y = z = 0;
 
+	/* Cannot cancel synchronously within the mutex */
+	cancel_delayed_work_sync(&chip->poweroff_work);
+
 	mutex_lock(&chip->lock);
-	if (!chip->power) {
-		/* Chip is turned off */
-		ret = snprintf(buf, PAGE_SIZE, "\n");
-		mutex_unlock(&chip->lock);
-		return ret;
-	}
+
+	if (!chip->power)
+		ret = lis302dl_power(chip, 1);
+
 	for (i = 0; i < chip->samples; i++) {
 		x += (s8)lis302dl_read(chip->client, LIS302_X);
 		y += (s8)lis302dl_read(chip->client, LIS302_Y);
@@ -604,6 +635,8 @@ static ssize_t lis302dl_show_coord(struc
 	ret = snprintf(buf, PAGE_SIZE, "%d %d %d\n", x, y, z);
 	mutex_unlock(&chip->lock);
 
+	schedule_delayed_work(&chip->poweroff_work, LIS302_POWEROFF_DELAY);
+
 	return ret;
 }
 
@@ -702,7 +735,7 @@ static int lis302dl_probe(struct i2c_cli
 	lis->threshold	= LIS302_THS;
 	lis->duration	= LIS302_DURATION;
 	lis->fs		= LIS302_FS;
-	lis->sample_rate = LIS302_400HZ;
+	lis->sample_rate = LIS302_100HZ;
 	lis->samples	= LIS302_SAMPLES;
 
 	mutex_init(&lis->lock);
@@ -731,6 +764,8 @@ static int lis302dl_probe(struct i2c_cli
 	}
 	gpio_direction_input(lis->irq1);
 	INIT_WORK(&lis->work1, lis302dl_work1);
+	INIT_DELAYED_WORK(&lis->poweroff_work, lis302dl_poweroff_work);
+
 	err = request_irq(gpio_to_irq(lis->irq1), lis302dl_irq1,
 			  LIS302_IRQ_FLAGS, DRIVER_NAME, lis);
 	if (err) {
@@ -738,6 +773,7 @@ static int lis302dl_probe(struct i2c_cli
 			gpio_to_irq(lis->irq1));
 		goto fail3;
 	}
+	schedule_delayed_work(&lis->poweroff_work, LIS302_POWEROFF_DELAY);
 
 	return 0;
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/i2c/chips/tpa6130a2.c kernel-2.6.28-20093908+0m5/drivers/i2c/chips/tpa6130a2.c
--- kernel-2.6.28-20091602+0m5/drivers/i2c/chips/tpa6130a2.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/i2c/chips/tpa6130a2.c	2012-12-16 13:13:01.656330147 +0100
@@ -25,25 +25,23 @@
 
 #include <linux/module.h>
 #include <linux/errno.h>
+#include <linux/string.h>
 #include <linux/device.h>
 #include <linux/i2c.h>
 #include <linux/sysfs.h>
 #include <linux/i2c/tpa6130a2.h>
 #include <mach/gpio.h>
 
-#define TPA6130A2_I2C_ADDRESS	0x60
-
 #define TPA6130A2_REG_ENABLE	0x1
 #define TPA6130A2_REG_VOLUME	0x2
 #define TPA6130A2_REG_HI_Z	0x3
 #define TPA6130A2_REG_VERSION	0x4
 #define TPA6130A2_REGS		4
 
-#define TPA6130A2_BIT_HI_Z_R	(1 << 0)
-#define TPA6130A2_BIT_HI_Z_L	(1 << 1)
 #define TPA6130A2_MASK_CHANNEL	(3 << 6)
 #define TPA6130A2_MASK_VOLUME	0x3f
 #define TPA6130A2_MASK_HI_Z	0x03
+#define TPA6130A2_SWS		0x01
 
 #define TPA6130A2_CHANNEL_LEFT	(1 << 7)
 #define TPA6130A2_CHANNEL_RIGHT	(1 << 6)
@@ -53,6 +51,7 @@ static long int initialized;
 
 /* This struct is used to save the context */
 struct tpa6130a2_data {
+	struct mutex mutex;
 	unsigned char regs[TPA6130A2_REGS];
 	unsigned char power_state;
 	int (*set_power)(int state);
@@ -73,9 +72,9 @@ static int tpa6130a2_read(int reg)
 		if (val < 0)
 			dev_err(&tpa6130a2_client->dev, "Read failed\n");
 		else
-			data->regs[reg] = val;
+			data->regs[reg - 1] = val;
 	} else {
-		val = data->regs[reg];
+		val = data->regs[reg - 1];
 	}
 
 	return val;
@@ -97,101 +96,136 @@ static int tpa6130a2_write(int reg, u8 v
 	}
 
 	/* Either powered on or off, we save the context */
-	data->regs[reg] = value;
+	data->regs[reg - 1] = value;
 
 	return val;
 }
 
-static int tpa6130a2_print_channel(char *buf, int channel)
+/* Control interface */
+static int tpa6130a2_get_mute(void)
 {
-	int i = 0;
-	buf[0] = buf[1] = ' ';
-	buf[2] = '\n';
-	buf[3] = 0;
-
-	if (channel & TPA6130A2_CHANNEL_LEFT)
-		buf[i++] = 'l';
-	if (channel & TPA6130A2_CHANNEL_RIGHT)
-		buf[i] = 'r';
-	return 4;
-}
-
-static int tpa6130a2_parse_channel(const char *buf, int len)
-{
-	int val = 0, i;
-	for (i = 0; (i < 2) && (i < len); i++) {
-		if ((buf[i] == 'l') || (buf[i] == 'L'))
-			val |= TPA6130A2_CHANNEL_LEFT;
-		if ((buf[i] == 'r') || (buf[i] == 'R'))
-			val |= TPA6130A2_CHANNEL_RIGHT;
-	}
-	return val;
-}
+	struct tpa6130a2_data *data;
+	int ret;
 
-static struct i2c_driver tpa6130a2_i2c_driver;
+	data = i2c_get_clientdata(tpa6130a2_client);
 
-/*
- * Control interface
- */
+	mutex_lock(&data->mutex);
+	ret = tpa6130a2_read(TPA6130A2_REG_VOLUME) & TPA6130A2_MASK_CHANNEL;
+	mutex_unlock(&data->mutex);
 
-static int tpa6130a2_get_mute(void)
-{
-	return tpa6130a2_read(TPA6130A2_REG_VOLUME) & TPA6130A2_MASK_CHANNEL;
+	return ret;
 }
 
-static int tpa6130a2_set_mute(int channel)
+static void tpa6130a2_set_mute(int channel)
 {
+	struct tpa6130a2_data *data;
 	int val;
+
+	data = i2c_get_clientdata(tpa6130a2_client);
+
+	mutex_lock(&data->mutex);
 	val = tpa6130a2_read(TPA6130A2_REG_VOLUME) & ~TPA6130A2_MASK_CHANNEL;
 	val |= channel & TPA6130A2_MASK_CHANNEL;
 
-	return tpa6130a2_write(TPA6130A2_REG_VOLUME, val);
+	tpa6130a2_write(TPA6130A2_REG_VOLUME, val);
+	mutex_unlock(&data->mutex);
 }
 
-static int tpa6130a2_get_hpen(void)
+static int tpa6130a2_get_hp_en(void)
 {
-	return tpa6130a2_read(TPA6130A2_REG_ENABLE) & TPA6130A2_MASK_CHANNEL;
+	struct tpa6130a2_data *data;
+	int ret;
+
+	data = i2c_get_clientdata(tpa6130a2_client);
+
+	mutex_lock(&data->mutex);
+	ret = tpa6130a2_read(TPA6130A2_REG_ENABLE) & TPA6130A2_MASK_CHANNEL;
+	mutex_unlock(&data->mutex);
+
+	return ret;
 }
 
-static int tpa6130a2_set_hpen(int channel)
+static void tpa6130a2_set_hp_en(int channel)
 {
+	struct tpa6130a2_data *data;
 	int val;
+
+	data = i2c_get_clientdata(tpa6130a2_client);
+
+	mutex_lock(&data->mutex);
 	val = tpa6130a2_read(TPA6130A2_REG_ENABLE) & ~TPA6130A2_MASK_CHANNEL;
 	val |= channel & TPA6130A2_MASK_CHANNEL;
 
-	return tpa6130a2_write(TPA6130A2_REG_ENABLE, val);
+	if (channel)
+		val &= ~TPA6130A2_SWS;
+	else
+		val |= TPA6130A2_SWS;
+
+	tpa6130a2_write(TPA6130A2_REG_ENABLE, val);
+	mutex_unlock(&data->mutex);
 }
 
 static int tpa6130a2_get_hi_z(void)
 {
-	return (tpa6130a2_read(TPA6130A2_REG_HI_Z) & TPA6130A2_MASK_HI_Z) << 6;
+	struct tpa6130a2_data *data;
+	int ret;
+
+	data = i2c_get_clientdata(tpa6130a2_client);
+
+	mutex_lock(&data->mutex);
+	ret = (tpa6130a2_read(TPA6130A2_REG_HI_Z) & TPA6130A2_MASK_HI_Z) << 6;
+	mutex_unlock(&data->mutex);
+
+	return ret;
 }
 
-static int tpa6130a2_set_hi_z(int channel)
+static void tpa6130a2_set_hi_z(int channel)
 {
+	struct tpa6130a2_data *data;
 	int val;
+
+	data = i2c_get_clientdata(tpa6130a2_client);
+
+	mutex_lock(&data->mutex);
 	val = tpa6130a2_read(TPA6130A2_REG_HI_Z) & ~TPA6130A2_MASK_HI_Z;
 	val |= (channel & TPA6130A2_MASK_CHANNEL) >> 6;
-
-	return tpa6130a2_write(TPA6130A2_REG_HI_Z, val);
+	tpa6130a2_write(TPA6130A2_REG_HI_Z, val);
+	mutex_unlock(&data->mutex);
 }
 
 int tpa6130a2_get_volume(void)
 {
-	int vol = tpa6130a2_read(TPA6130A2_REG_VOLUME);
+	struct tpa6130a2_data *data;
+	int vol;
+
+	data = i2c_get_clientdata(tpa6130a2_client);
+
+	mutex_lock(&data->mutex);
+	vol = tpa6130a2_read(TPA6130A2_REG_VOLUME);
+	mutex_unlock(&data->mutex);
 	vol &= TPA6130A2_MASK_VOLUME;
+
 	return vol;
 }
 
 int tpa6130a2_set_volume(int vol)
 {
+	struct tpa6130a2_data *data;
+	int ret;
+
 	if (vol < 0)
 		vol = 0;
 	if (vol > 0x3f)
 		vol = 0x3f;
 
+	data = i2c_get_clientdata(tpa6130a2_client);
+
+	mutex_lock(&data->mutex);
 	vol |= tpa6130a2_read(TPA6130A2_REG_VOLUME) & ~TPA6130A2_MASK_VOLUME;
-	return tpa6130a2_write(TPA6130A2_REG_VOLUME, vol);
+	ret = tpa6130a2_write(TPA6130A2_REG_VOLUME, vol);
+	mutex_unlock(&data->mutex);
+
+	return ret;
 }
 
 static void tpa6130a2_power_on(void)
@@ -199,63 +233,78 @@ static void tpa6130a2_power_on(void)
 	struct tpa6130a2_data *data;
 	int i;
 
-	BUG_ON(tpa6130a2_client == NULL);
 	data = i2c_get_clientdata(tpa6130a2_client);
 
+	mutex_lock(&data->mutex);
 	data->set_power(1);
 	data->power_state = 1;
 
 	/* Rewrite all except the read only register */
-	for (i = 0; i < TPA6130A2_REGS - 1; i++)
-		tpa6130a2_write(i, data->regs[i]);
+	for (i = TPA6130A2_REG_ENABLE; i < TPA6130A2_REGS; i++)
+		tpa6130a2_write(i, data->regs[i - 1]);
+	mutex_unlock(&data->mutex);
 }
 
 static void tpa6130a2_power_off(void)
 {
 	struct tpa6130a2_data *data;
 
-	BUG_ON(tpa6130a2_client == NULL);
 	data = i2c_get_clientdata(tpa6130a2_client);
 
-	data->set_power(0);
+	mutex_lock(&data->mutex);
 	data->power_state = 0;
+	data->set_power(0);
+	mutex_unlock(&data->mutex);
 }
 
 void tpa6130a2_set_enabled(int enabled)
 {
+	BUG_ON(tpa6130a2_client == NULL);
+
 	if (enabled) {
-		tpa6130a2_set_hpen(TPA6130A2_CHANNEL_LEFT |
+		tpa6130a2_set_hp_en(TPA6130A2_CHANNEL_LEFT |
 				TPA6130A2_CHANNEL_RIGHT);
 		tpa6130a2_power_on();
 	} else {
 		/* Disable the HPs prior to powering down the chip */
-		tpa6130a2_set_hpen(0);
+		tpa6130a2_set_hp_en(0);
 		tpa6130a2_power_off();
 	}
 }
 
-/*
- * Sysfs interface
- */
-
-static ssize_t tpa6130a2_mute_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
-{
-	int val = tpa6130a2_get_mute();
-
-	return tpa6130a2_print_channel(buf, val);
-}
-
-static ssize_t tpa6130a2_mute_store(struct device *dev,
-				    struct device_attribute *attr,
-				    const char *buf, size_t len)
-{
-	int val;
-	val = tpa6130a2_parse_channel(buf, len);
-	tpa6130a2_set_mute(val);
-
-	return len;
-}
+/* Sysfs interface */
+#define tpa6130a2_sys_property(name)					\
+static ssize_t tpa6130a2_##name##_show(struct device *dev,		\
+			   struct device_attribute *attr, char *buf)	\
+{									\
+	int val = tpa6130a2_get_##name();				\
+									\
+	return snprintf(buf, PAGE_SIZE, "%c%c\n",			\
+		(val & TPA6130A2_CHANNEL_LEFT) ? 'l' : ' ',		\
+		(val & TPA6130A2_CHANNEL_RIGHT) ? 'r' : ' ');		\
+}									\
+									\
+static ssize_t tpa6130a2_##name##_store(struct device *dev,		\
+				    struct device_attribute *attr,	\
+				    const char *buf, size_t len)	\
+{									\
+	int val = 0;							\
+									\
+	if (strpbrk(buf, "lL") != NULL)					\
+		val |= TPA6130A2_CHANNEL_LEFT;				\
+	if (strpbrk(buf, "rR") != NULL)					\
+		val |= TPA6130A2_CHANNEL_RIGHT;				\
+	tpa6130a2_set_##name(val);					\
+									\
+	return len;							\
+}									\
+									\
+static DEVICE_ATTR(name, S_IRUGO | S_IWUSR, tpa6130a2_##name##_show,	\
+					tpa6130a2_##name##_store);
+
+tpa6130a2_sys_property(mute)
+tpa6130a2_sys_property(hp_en)
+tpa6130a2_sys_property(hi_z)
 
 static ssize_t tpa6130a2_volume_show(struct device *dev,
 				     struct device_attribute *attr, char *buf)
@@ -282,81 +331,20 @@ static ssize_t tpa6130a2_volume_store(st
 	return len;
 }
 
-static ssize_t tpa6130a2_hp_en_show(struct device *dev,
-				    struct device_attribute *attr, char *buf)
-{
-	int val = tpa6130a2_get_hpen();
-
-	return tpa6130a2_print_channel(buf, val);
-}
-
-static ssize_t tpa6130a2_hp_en_store(struct device *dev,
-				     struct device_attribute *attr,
-				     const char *buf, size_t len)
-{
-	int val = 0;
-
-	val = tpa6130a2_parse_channel(buf, len);
-	tpa6130a2_set_hpen(val);
-
-	return len;
-}
+static DEVICE_ATTR(volume, S_IRUGO | S_IWUSR, tpa6130a2_volume_show,
+					tpa6130a2_volume_store);
 
-static ssize_t tpa6130a2_hi_z_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
-{
-	int val = tpa6130a2_get_hi_z();
-
-	return tpa6130a2_print_channel(buf, val);
-}
-
-static ssize_t tpa6130a2_hi_z_store(struct device *dev,
-				    struct device_attribute *attr,
-				    const char *buf, size_t len)
-{
-	int val = 0;
-
-	val = tpa6130a2_parse_channel(buf, len);
-	tpa6130a2_set_hi_z(val);
-
-	return len;
-}
-
-static struct device_attribute tpa6130a2_attrs[] = {
-	__ATTR(volume, S_IRUGO | S_IWUSR, tpa6130a2_volume_show,
-	       tpa6130a2_volume_store),
-	__ATTR(mute, S_IRUGO | S_IWUSR, tpa6130a2_mute_show,
-	       tpa6130a2_mute_store),
-	__ATTR(hi_z, S_IRUGO | S_IWUSR, tpa6130a2_hi_z_show,
-	       tpa6130a2_hi_z_store),
-	__ATTR(hp_en, S_IRUGO | S_IWUSR, tpa6130a2_hp_en_show,
-	       tpa6130a2_hp_en_store),
+static struct attribute *attrs[] = {
+	&dev_attr_volume.attr,
+	&dev_attr_mute.attr,
+	&dev_attr_hi_z.attr,
+	&dev_attr_hp_en.attr,
+	NULL,
 };
 
-static int tpa6130a2_register_sysfs(struct device *dev)
-{
-	int err, i;
-
-	for (i = 0; i < ARRAY_SIZE(tpa6130a2_attrs); i++) {
-		err = device_create_file(dev, &tpa6130a2_attrs[i]);
-		if (err)
-			goto fail;
-	}
-	return 0;
-
-fail:
-	while (i--)
-		device_remove_file(dev, &tpa6130a2_attrs[i]);
-	return err;
-}
-
-static void tpa6130a2_unregister_sysfs(struct device *dev)
-{
-	int i = ARRAY_SIZE(tpa6130a2_attrs);
-
-	while (i--)
-		device_remove_file(dev, &tpa6130a2_attrs[i]);
-}
+static const struct attribute_group attr_group = {
+	.attrs = attrs,
+};
 
 static int tpa6130a2_probe(struct i2c_client *client,
 			   const struct i2c_device_id *id)
@@ -393,18 +381,19 @@ static int tpa6130a2_probe(struct i2c_cl
 	data->set_power = pdata->set_power;
 	data->set_power(1);
 	data->power_state = 1;
+	mutex_init(&data->mutex);
 
 	/* Read version */
-	err = tpa6130a2_read(TPA6130A2_REG_VERSION);
-	if ((err & 0xf) != 2) {
+	err = tpa6130a2_read(TPA6130A2_REG_VERSION) & 0x0f;
+	if ((err != 1) && (err != 2)) {
 		dev_err(dev, "Unexpected headphone amplifier chip version "
-		       "of 0x%02x, was expecting 0x02\n", err);
+		       "of 0x%02x, was expecting 0x01 or 0x02\n", err);
 		err = -ENODEV;
 
 		goto fail2;
 	}
 
-	err = tpa6130a2_register_sysfs(dev);
+	err = sysfs_create_group(&dev->kobj, &attr_group);
 	if (err) {
 		dev_err(dev, "Sysfs node creation failed\n");
 		goto fail2;
@@ -413,15 +402,15 @@ static int tpa6130a2_probe(struct i2c_cl
 	dev_info(dev, "Headphone amplifier initialized successfully\n");
 
 	/* enable both channels */
-	tpa6130a2_set_hpen(TPA6130A2_CHANNEL_LEFT | TPA6130A2_CHANNEL_RIGHT);
+	tpa6130a2_set_hp_en(TPA6130A2_CHANNEL_LEFT | TPA6130A2_CHANNEL_RIGHT);
 	/* Some sort of default volume that doesn't kill your ears.. */
 	tpa6130a2_set_volume(20);
 	tpa6130a2_set_mute(0); /* Mute off */
-	tpa6130a2_set_hpen(0); /* Disable the chip until we actually need it */
+	tpa6130a2_set_hp_en(0); /* Disable the chip until we actually need it */
 
 	/* Disable the chip */
-	data->set_power(0);
 	data->power_state = 0;
+	data->set_power(0);
 	return 0;
 
 fail2:
@@ -439,7 +428,7 @@ static int tpa6130a2_remove(struct i2c_c
 	struct tpa6130a2_data *data = i2c_get_clientdata(client);
 
 	data->set_power(0);
-	tpa6130a2_unregister_sysfs(dev);
+	sysfs_remove_group(&dev->kobj, &attr_group);
 	kfree(data);
 	tpa6130a2_client = 0;
 	initialized = 0;
@@ -504,5 +493,5 @@ MODULE_AUTHOR("Nokia Corporation");
 MODULE_DESCRIPTION("TPA6130A2 Headphone amplifier driver");
 MODULE_LICENSE("GPL");
 
-module_init(tpa6130a2_init);
+late_initcall(tpa6130a2_init);
 module_exit(tpa6130a2_exit);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/i2c/chips/tsl2563.c kernel-2.6.28-20093908+0m5/drivers/i2c/chips/tsl2563.c
--- kernel-2.6.28-20091602+0m5/drivers/i2c/chips/tsl2563.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/i2c/chips/tsl2563.c	2012-12-16 13:13:01.656330147 +0100
@@ -31,6 +31,7 @@
 #include <linux/pm.h>
 #include <linux/hwmon.h>
 #include <linux/err.h>
+#include <linux/i2c/tsl2563.h>
 #include <mach/board.h>
 
 #define DRIVER_NAME  "tsl2563"
@@ -111,6 +112,7 @@ struct tsl2563_chip {
 	struct mutex		lock;
 	struct i2c_client	*client;
 	struct device		*hwmon_dev;
+	struct delayed_work	poweroff_work;
 
 	/* Remember state for suspend and resume functions */
 	pm_message_t		state;
@@ -125,6 +127,7 @@ struct tsl2563_chip {
 	/* Calibration coefficients */
 	u32			calib0;
 	u32			calib1;
+	int			cover_comp_gain;
 
 	/* Cache current values, to be returned while suspended */
 	u32			data0;
@@ -197,6 +200,13 @@ out:
 	return ret;
 }
 
+static void tsl2563_poweroff_work(struct work_struct *work)
+{
+	struct tsl2563_chip *chip =
+		container_of(work, struct tsl2563_chip, poweroff_work.work);
+	tsl2563_set_power(chip, 0);
+}
+
 static int tsl2563_detect(struct tsl2563_chip *chip)
 {
 	int ret;
@@ -310,6 +320,18 @@ static int tsl2563_get_adc(struct tsl256
 	if (chip->state.event != PM_EVENT_ON)
 		goto out;
 
+	cancel_delayed_work(&chip->poweroff_work);
+
+	if (!tsl2563_get_power(chip)) {
+		ret = tsl2563_set_power(chip, 1);
+		if (ret)
+			goto out;
+		ret = tsl2563_configure(chip);
+		if (ret)
+			goto out;
+		tsl2563_wait_adc(chip);
+	}
+
 	while (retry) {
 		ret = tsl2563_read(client,
 				   TSL2563_REG_DATA0LOW | TSL2563_CLEARINT,
@@ -331,6 +353,8 @@ static int tsl2563_get_adc(struct tsl256
 	chip->data0 = normalize_adc(adc0, chip->gainlevel->gaintime);
 	chip->data1 = normalize_adc(adc1, chip->gainlevel->gaintime);
 
+	schedule_delayed_work(&chip->poweroff_work, 5 * HZ);
+
 	ret = 0;
 out:
 	return ret;
@@ -482,8 +506,8 @@ static ssize_t tsl2563_lux_show(struct d
 	if (ret)
 		goto out;
 
-	calib0 = calib_adc(chip->data0, chip->calib0);
-	calib1 = calib_adc(chip->data1, chip->calib1);
+	calib0 = calib_adc(chip->data0, chip->calib0) * chip->cover_comp_gain;
+	calib1 = calib_adc(chip->data1, chip->calib1) * chip->cover_comp_gain;
 
 	ret = snprintf(buf, PAGE_SIZE, "%d\n", adc_to_lux(calib0, calib1));
 
@@ -599,6 +623,7 @@ static int tsl2563_probe(struct i2c_clie
 		const struct i2c_device_id *device_id)
 {
 	struct tsl2563_chip *chip;
+	struct tsl2563_platform_data *pdata = client->dev.platform_data;
 	int err = 0;
 	u8 id;
 
@@ -629,6 +654,11 @@ static int tsl2563_probe(struct i2c_clie
 	chip->calib0 = calib_from_sysfs(CALIB_BASE_SYSFS);
 	chip->calib1 = calib_from_sysfs(CALIB_BASE_SYSFS);
 
+	if (pdata)
+		chip->cover_comp_gain = pdata->cover_comp_gain;
+	else
+		chip->cover_comp_gain = 1;
+
 	dev_info(&client->dev, "model %d, rev. %d\n", id >> 4, id & 0x0f);
 
 	err = tsl2563_configure(chip);
@@ -645,6 +675,9 @@ static int tsl2563_probe(struct i2c_clie
 		goto fail2;
 	}
 
+	INIT_DELAYED_WORK(&chip->poweroff_work, tsl2563_poweroff_work);
+	schedule_delayed_work(&chip->poweroff_work, 5 * HZ);
+
 	return 0;
 fail2:
 	hwmon_device_unregister(chip->hwmon_dev);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/i2c/chips/twl4030-madc.c kernel-2.6.28-20093908+0m5/drivers/i2c/chips/twl4030-madc.c
--- kernel-2.6.28-20091602+0m5/drivers/i2c/chips/twl4030-madc.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/i2c/chips/twl4030-madc.c	2012-12-16 13:13:01.656330147 +0100
@@ -255,9 +255,11 @@ static int twl4030_madc_wait_conversion_
 
 	timeout = jiffies + msecs_to_jiffies(timeout_ms);
 	do {
-		u8 reg;
+		int reg;
 
 		reg = twl4030_madc_read(madc, status_reg);
+		if (unlikely(reg < 0))
+			return reg;
 		if (!(reg & TWL4030_MADC_BUSY) && (reg & TWL4030_MADC_EOC_SW))
 			return 0;
 	} while (!time_after(jiffies, timeout));
@@ -265,6 +267,7 @@ static int twl4030_madc_wait_conversion_
 	return -EAGAIN;
 }
 
+static int twl4030_madc_set_power(struct twl4030_madc_data *madc, int on);
 int twl4030_madc_conversion(struct twl4030_madc_request *req)
 {
 	const struct twl4030_madc_conversion_method *method;
@@ -276,20 +279,14 @@ int twl4030_madc_conversion(struct twl40
 
 	mutex_lock(&the_madc->lock);
 
+	twl4030_madc_set_power(the_madc, 1);
+
 	/* Do we have a conversion request ongoing */
 	if (the_madc->requests[req->method].active) {
 		ret = -EBUSY;
 		goto out;
 	}
 
-	/*
-	 * Due to an HW bug which TI did not explain yet, the current generator
-	 * seems to be disabled, while it reports that it is ebabled (e.g.,
-	 * when inserting a USB cable while the HFOSC is disabled.
-	 */
-	twl4030_madc_set_current_generator(the_madc, 0, 0);
-	twl4030_madc_set_current_generator(the_madc, 0, 1);
-
 	ch_msb = (req->channels >> 8) & 0xff;
 	ch_lsb = req->channels & 0xff;
 
@@ -335,6 +332,8 @@ int twl4030_madc_conversion(struct twl40
 
 	the_madc->requests[req->method].active = 0;
 
+	twl4030_madc_set_power(the_madc, 0);
+
 out:
 	mutex_unlock(&the_madc->lock);
 
@@ -355,10 +354,15 @@ static int twl4030_madc_set_current_gene
 
 	ret = twl4030_i2c_read_u8(TWL4030_MODULE_MAIN_CHARGE,
 				  &regval, TWL4030_BCI_BCICTL1);
-	if (on)
+	if (on) {
 		regval |= (chan) ? TWL4030_BCI_ITHEN : TWL4030_BCI_TYPEN;
-	else
+		regval |= TWL4030_BCI_MESBAT;
+	}
+	else {
 		regval &= (chan) ? ~TWL4030_BCI_ITHEN : ~TWL4030_BCI_TYPEN;
+		regval &= ~TWL4030_BCI_MESBAT;
+	}
+
 	ret = twl4030_i2c_write_u8(TWL4030_MODULE_MAIN_CHARGE,
 				   regval, TWL4030_BCI_BCICTL1);
 
@@ -367,16 +371,24 @@ static int twl4030_madc_set_current_gene
 
 static int twl4030_madc_set_power(struct twl4030_madc_data *madc, int on)
 {
+	int ret = 0;
 	u8 regval;
 
-	regval = twl4030_madc_read(madc, TWL4030_MADC_CTRL1);
-	if (on)
+	if (on) {
+		regval = twl4030_madc_read(madc, TWL4030_MADC_CTRL1);
 		regval |= TWL4030_MADC_MADCON;
-	else
-		regval &= ~TWL4030_MADC_MADCON;
-	twl4030_madc_write(madc, TWL4030_MADC_CTRL1, regval);
+		twl4030_madc_write(madc, TWL4030_MADC_CTRL1, regval);
 
-	return 0;
+		ret |= twl4030_madc_set_current_generator(madc, 0, 1);
+
+	} else {
+		ret |= twl4030_madc_set_current_generator(madc, 0, 0);
+
+		regval = twl4030_madc_read(madc, TWL4030_MADC_CTRL1);
+		regval &= ~TWL4030_MADC_MADCON;
+		twl4030_madc_write(madc, TWL4030_MADC_CTRL1, regval);
+	}
+	return ret;
 }
 
 static long twl4030_madc_ioctl(struct file *filp, unsigned int cmd,
@@ -401,13 +413,16 @@ static long twl4030_madc_ioctl(struct fi
 		req.do_avg	= par.average;
 		req.method	= TWL4030_MADC_SW1;
 		req.func_cb	= NULL;
+		req.type	= TWL4030_MADC_WAIT;
 
 		val = twl4030_madc_conversion(&req);
-		if (val <= 0) {
-			par.status = -1;
-		} else {
+		if (likely(val > 0)) {
 			par.status = 0;
 			par.result = (u16)req.rbuf[par.channel];
+		} else if (val == 0) {
+			par.status = -ENODATA;
+		} else {
+			par.status = val;
 		}
 		break;
 					     }
@@ -460,16 +475,6 @@ static int __init twl4030_madc_probe(str
 		dev_dbg(&pdev->dev, "could not register misc_device\n");
 		goto err_misc;
 	}
-	twl4030_madc_set_power(madc, 1);
-	twl4030_madc_set_current_generator(madc, 0, 1);
-
-	ret = twl4030_i2c_read_u8(TWL4030_MODULE_MAIN_CHARGE,
-				  &regval, TWL4030_BCI_BCICTL1);
-
-	regval |= TWL4030_BCI_MESBAT;
-
-	ret = twl4030_i2c_write_u8(TWL4030_MODULE_MAIN_CHARGE,
-				   regval, TWL4030_BCI_BCICTL1);
 
 	ret = request_irq(platform_get_irq(pdev, 0), twl4030_madc_irq_handler,
 			  0, "twl4030_madc", madc);
@@ -500,8 +505,6 @@ static int __exit twl4030_madc_remove(st
 {
 	struct twl4030_madc_data *madc = platform_get_drvdata(pdev);
 
-	twl4030_madc_set_power(madc, 0);
-	twl4030_madc_set_current_generator(madc, 0, 0);
 	free_irq(platform_get_irq(pdev, 0), madc);
 	cancel_work_sync(&madc->ws);
 	misc_deregister(&twl4030_madc_device);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/i2c/chips/twl4030-poweroff.c kernel-2.6.28-20093908+0m5/drivers/i2c/chips/twl4030-poweroff.c
--- kernel-2.6.28-20091602+0m5/drivers/i2c/chips/twl4030-poweroff.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/i2c/chips/twl4030-poweroff.c	2012-12-16 13:13:01.656330147 +0100
@@ -25,15 +25,36 @@
 #include <linux/pm.h>
 #include <linux/i2c/twl4030.h>
 
+#define STS_HW_CONDITIONS      0x0f
+#define STS_VBUS (1<<7)
+
 #define PWR_P1_SW_EVENTS	0x10
 #define PWR_DEVOFF	(1<<0)
 
+#define TWL4030_WATCHDOG_CFG_REG_OFFS   0x3
+
 static void twl4030_poweroff(void)
 {
 	u8 val;
 	int err;
 
 	err = twl4030_i2c_read_u8(TWL4030_MODULE_PM_MASTER, &val,
+				  STS_HW_CONDITIONS);
+	if (err)
+		printk(KERN_WARNING "I2C error %d while reading TWL4030"
+				    " PM_MASTER HW_CONDITIONS\n", err);
+
+	if (val & STS_VBUS) {
+		printk(KERN_EMERG "twl4030-poweroff: VBUS on,"
+				  " forcing restart!\n");
+		/* Set watchdog, Triton goes to WAIT-ON state.
+		   VBUS will cause start up */
+		twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, 1,
+				     TWL4030_WATCHDOG_CFG_REG_OFFS);
+		while (1);
+	}
+
+	err = twl4030_i2c_read_u8(TWL4030_MODULE_PM_MASTER, &val,
 				  PWR_P1_SW_EVENTS);
 	if (err) {
 		printk(KERN_WARNING "I2C error %d while reading TWL4030"
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/leds/leds-lp5523.c kernel-2.6.28-20093908+0m5/drivers/leds/leds-lp5523.c
--- kernel-2.6.28-20091602+0m5/drivers/leds/leds-lp5523.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/leds/leds-lp5523.c	2012-12-16 13:13:01.656330147 +0100
@@ -75,6 +75,7 @@
 #define LP5523_ENABLE			0x40
 #define LP5523_AUTO_INC			0x40
 #define LP5523_PWR_SAVE			0x20
+#define LP5523_PWM_PWR_SAVE		0x04
 #define LP5523_CP_1			0x08
 #define LP5523_CP_1_5			0x10
 #define LP5523_CP_AUTO			0x18
@@ -224,7 +225,8 @@ static int lp5523_configure(struct i2c_c
 
 	ret |= lp5523_write(client, LP5523_REG_CONFIG,
 			    LP5523_AUTO_INC | LP5523_PWR_SAVE |
-			    LP5523_CP_AUTO | LP5523_INT_CLK);
+			    LP5523_CP_AUTO | LP5523_AUTO_CLK |
+			    LP5523_PWM_PWR_SAVE);
 
 	/* turn on all leds */
 	ret |= lp5523_write(client, LP5523_REG_ENABLE_LEDS_MSB, 0x01);
@@ -347,43 +349,34 @@ static int lp5523_run_program(struct lp5
 	struct lp5523_chip *chip = engine_to_lp5523(engine);
 	struct i2c_client *client = chip->client;
 	int ret;
-	u8 mask = engine->engine_mask;
-	u8 exec_state = 0;
-	u8 enable_reg;
 
-	ret = lp5523_read(client, LP5523_REG_ENABLE, &enable_reg);
+	ret = lp5523_write(client, LP5523_REG_ENABLE, LP5523_CMD_RUN | LP5523_ENABLE);
 	if (ret)
 		goto fail;
 
-	enable_reg &= ~mask;
-	exec_state = mask & LP5523_CMD_RUN;
-	enable_reg |= exec_state;
-
-	ret |= lp5523_write(client, LP5523_REG_ENABLE, enable_reg);
-
-	/* set mode to run for this channel */
-	ret |= lp5523_set_engine_mode(engine, LP5523_CMD_RUN);
+	ret = lp5523_set_engine_mode(engine, LP5523_CMD_RUN);
 fail:
 	return ret;
 }
 
 static int lp5523_mux_parse(const char *buf, u16 *mux, size_t len)
 {
-	char c;
-	int i = 0;
-	int ret;
-	unsigned tmp;
-	u16 tmp_mux = 0;;
-	while ((i < len - 1) && (i < LP5523_LEDS)) {
-		/* two sscanfs because length option is not working for %x */
-		ret = sscanf(buf + i, "%c", &c);
-		ret = sscanf(&c, "%1x", &tmp);
-
-		if ((ret != 1) || (tmp > 1))
-			return -1;
-		if (tmp)
+	int i;
+	u16 tmp_mux = 0;
+	len = len < LP5523_LEDS ? len : LP5523_LEDS;
+	for (i = 0; i < len; i++) {
+		switch (buf[i]) {
+		case '1':
 			tmp_mux |= (1 << i);
-		i++;
+			break;
+		case '0':
+			break;
+		case '\n':
+			i = len;
+			break;
+		default:
+			return -1;
+		}
 	}
 	*mux = tmp_mux;
 
@@ -454,6 +447,8 @@ static ssize_t lp5523_selftest(struct de
 
 	for (i = 0; i < LP5523_LEDS; i++) {
 		lp5523_write(chip->client, LP5523_REG_LED_PWM_BASE + i, 0xff);
+		/* let current stabilize 2ms before measurements start */
+		msleep(2);
 		lp5523_write(chip->client,
 			     LP5523_REG_LED_TEST_CTRL,
 			     LP5523_EN_LEDTEST | i);
@@ -742,6 +737,7 @@ static int lp5523_set_mode(struct lp5523
 
 	else if (mode == LP5523_CMD_LOAD) {
 
+		lp5523_set_engine_mode(engine, LP5523_CMD_DISABLED);
 		lp5523_set_engine_mode(engine, LP5523_CMD_LOAD);
 
 		if ((ret = sysfs_create_group(&dev->kobj, engine->attributes)))
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/leds/leds-twl4030-vibra.c kernel-2.6.28-20093908+0m5/drivers/leds/leds-twl4030-vibra.c
--- kernel-2.6.28-20091602+0m5/drivers/leds/leds-twl4030-vibra.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/leds/leds-twl4030-vibra.c	2012-12-16 13:13:01.656330147 +0100
@@ -46,10 +46,19 @@
 /* MODULE ID3 */
 #define VIBRA_CFG		0x60
 
+#define MAX_SEQ_LEN		5
+
+struct pulse_info {
+	unsigned int		dir:1;
+	unsigned int		pwm:31;
+	unsigned long		duration;
+};
+
 struct vibra_info {
 	struct mutex		lock;
 	struct device		*dev;
 
+	struct workqueue_struct *workqueue;
 	struct delayed_work	work;
 	struct work_struct	led_work;
 
@@ -58,6 +67,10 @@ struct vibra_info {
 	unsigned long		duration;
 	int			enabled;
 	int			speed;
+
+	struct pulse_info	seq[MAX_SEQ_LEN];
+	unsigned int		iseq;
+	unsigned int		nseq;
 };
 
 /* Powers H-Bridge and enables audio clk */
@@ -111,40 +124,74 @@ static void vibra_disable(struct vibra_i
 	info->enabled = 0;
 }
 
+static int vibra_seq(struct vibra_info *info, const struct pulse_info *seq,
+		unsigned int n)
+{
+	if (n == 0 || n > ARRAY_SIZE(info->seq))
+		return -EINVAL;
+
+	/* stop previous sequence, if any */
+	cancel_delayed_work_sync(&info->work);
+
+	mutex_lock(&info->lock);
+
+	info->iseq = 0;
+	info->nseq = n;
+	memcpy(info->seq, seq, n * sizeof(*seq));
+
+	queue_delayed_work(info->workqueue, &info->work, 0);
+
+	mutex_unlock(&info->lock);
+
+	return 0;
+}
+
 static void vibra_pwm(struct vibra_info *info, int dir, int pwm)
 {
-	u8 reg;
+	struct pulse_info seq[2] = {
+		{ .dir = dir, .pwm = pwm, .duration = info->duration },
+	};
+
+	vibra_seq(info, seq, ARRAY_SIZE(seq));
+}
+
+static void vibra_next_pulse(struct vibra_info *info)
+{
+	unsigned int pwm;
+	unsigned int dir;
+	unsigned long duration;
 
 	mutex_lock(&info->lock);
-	if (pwm == 0) {
+
+	pwm = info->seq[info->iseq].pwm;
+	dir = info->seq[info->iseq].dir;
+	duration = info->seq[info->iseq].duration;
+
+	if (pwm) {
+		u8 reg;
+
+		if (!info->enabled)
+			vibra_enable(info);
+
+		/* set vibra rotation direction */
+		twl4030_i2c_read_u8(TWL4030_MODULE_AUDIO_VOICE,
+				&reg, VIBRA_CTL);
+		reg = (dir) ? (reg | VIBRA_DIR) : (reg & ~VIBRA_DIR);
+		twl4030_i2c_write_u8(TWL4030_MODULE_AUDIO_VOICE,
+				reg, VIBRA_CTL);
+
+		/* set PWM, 1 = max, 255 = min */
+		twl4030_i2c_write_u8(TWL4030_MODULE_AUDIO_VOICE,
+				256 - pwm, VIBRA_SET);
+	} else {
 		vibra_disable(info);
-		mutex_unlock(&info->lock);
-		return;
 	}
-	if (!info->enabled)
-		vibra_enable(info);
 
-	/* set vibra rotation direction */
-	twl4030_i2c_read_u8(TWL4030_MODULE_AUDIO_VOICE,
-			    &reg, VIBRA_CTL);
-	reg = (dir) ? (reg | VIBRA_DIR) : (reg & ~VIBRA_DIR);
-	twl4030_i2c_write_u8(TWL4030_MODULE_AUDIO_VOICE,
-			     reg, VIBRA_CTL);
-
-	/* set PWM, 1 = max, 255 = min */
-	twl4030_i2c_write_u8(TWL4030_MODULE_AUDIO_VOICE,
-			     256 - pwm, VIBRA_SET);
+	info->iseq++;
+	if (info->iseq < info->nseq && duration)
+		queue_delayed_work(info->workqueue, &info->work,
+				msecs_to_jiffies(duration));
 
-	/* If previous work is scheduled cancel it */
-	if (delayed_work_pending(&info->work))
-		cancel_delayed_work(&info->work);
-
-	/* if duration is zero it means continous action.  */
-	/* Otherwise schedule vibra_disable to the future  */
-	if (info->duration) {
-		schedule_delayed_work(&info->work,
-				      msecs_to_jiffies(info->duration));
-	}
 	mutex_unlock(&info->lock);
 }
 
@@ -152,7 +199,8 @@ static void vibra_work(struct work_struc
 {
 	struct vibra_info *info = container_of(work,
 			struct vibra_info, work.work);
-	vibra_disable(info);
+
+	vibra_next_pulse(info);
 }
 
 static void vibra_led_work(struct work_struct *work)
@@ -176,6 +224,58 @@ static void vibra_led_set(struct led_cla
 /*******************************************************************************
  * SYSFS                                                                       *
  ******************************************************************************/
+
+static ssize_t vibra_set_seq(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char *p;
+	unsigned int i;
+	struct vibra_info *info = dev_get_drvdata(dev);
+	struct pulse_info seq[ARRAY_SIZE(info->seq)];
+
+	for (p = buf, i = 0;
+	     *p != '\0' && *p != '\n' && i < ARRAY_SIZE(seq); i++) {
+		long val;
+		char *endp;
+
+		/* speed and direction */
+		val = simple_strtol(p, &endp, 0);
+		if (p == endp || *endp != ' ')
+			return -EINVAL;
+		for (p = endp; *p == ' '; p++)
+			;
+
+		seq[i].dir = val < 0 ? 1 : 0;
+		seq[i].pwm = min(abs(val), 255);
+
+		/* duration */
+		val = simple_strtol(p, &endp, 0);
+		if (p == endp ||
+			(*endp != ' ' && *endp != '\0' && *endp != '\n'))
+			return -EINVAL;
+		for (p = endp; *p == ' '; p++)
+			;
+
+		if (val < 0)
+			return -EINVAL;
+
+		seq[i].duration = val;
+	}
+
+	/* no room for end of sequence */
+	if (i == ARRAY_SIZE(seq))
+		return -EINVAL;
+
+	/* end of sequence */
+	seq[i].pwm = 0;
+	seq[i].dir = 0;
+	seq[i++].duration = 0;
+
+	vibra_seq(info, seq, i);
+
+	return len;
+}
+
 static ssize_t vibra_set_pwm(struct device *dev, struct device_attribute *attr,
 			     const char *buf, size_t len)
 {
@@ -243,6 +343,8 @@ static struct device_attribute vibra_att
 	       vibra_show_pwm, vibra_set_pwm),
 	__ATTR(duration, S_IRUGO | S_IWUSR,
 	       vibra_show_duration, vibra_set_duration),
+	__ATTR(pulse, S_IWUSR,
+	       NULL, vibra_set_seq),
 };
 
 static int vibra_register_sysfs(struct vibra_info *info)
@@ -281,9 +383,18 @@ static int __init twl4030_vibra_probe(st
 	info->dev = &pdev->dev;
 	info->enabled = 0;
 	info->duration = 0;
+	info->iseq = 0;
+	info->nseq = 0;
 
 	platform_set_drvdata(pdev, info);
 
+	info->workqueue = create_singlethread_workqueue("vibra");
+	if (info->workqueue == NULL) {
+		dev_err(&pdev->dev, "couldn't create workqueue\n");
+		kfree(info);
+		return -ENOMEM;
+	}
+
 	mutex_init(&info->lock);
 	INIT_DELAYED_WORK(&info->work, vibra_work);
 	INIT_WORK(&info->led_work, vibra_led_work);
@@ -307,6 +418,9 @@ static int __exit twl4030_vibra_remove(s
 {
 	struct vibra_info *info = platform_get_drvdata(pdev);
 
+	cancel_delayed_work_sync(&info->work);
+	destroy_workqueue(info->workqueue);
+
 	vibra_unregister_sysfs(info);
 	led_classdev_unregister(&info->vibra);
 	kfree(info);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/radio/radio-bcm2048.c kernel-2.6.28-20093908+0m5/drivers/media/radio/radio-bcm2048.c
--- kernel-2.6.28-20091602+0m5/drivers/media/radio/radio-bcm2048.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/radio/radio-bcm2048.c	2012-12-16 13:13:01.656330147 +0100
@@ -164,6 +164,7 @@
 				 RDS_FLAG_SYNC_LOST | RDS_FLAG_PI_MATCH)
 
 #define BCM2048_DEFAULT_TIMEOUT		1500
+#define BCM2048_AUTO_SEARCH_TIMEOUT	3000
 
 
 #define BCM2048_FREQDEV_UNIT		10000
@@ -178,7 +179,7 @@
 #define BCM2048_DEFAULT_POWERING_DELAY	20
 #define BCM2048_DEFAULT_REGION		0x02
 #define BCM2048_DEFAULT_MUTE		0x01
-#define BCM2048_DEFAULT_RSSI_THRESHOLD	0x46
+#define BCM2048_DEFAULT_RSSI_THRESHOLD	0x64
 #define BCM2048_DEFAULT_RDS_WLINE	0x7E
 
 #define BCM2048_FM_SEARCH_INACTIVE	0x00
@@ -451,13 +452,11 @@ static int bcm2048_get_power_state(struc
 	return err;
 }
 
-static int bcm2048_set_rds(struct bcm2048_device *bdev, u8 rds_on)
+static int bcm2048_set_rds_no_lock(struct bcm2048_device *bdev, u8 rds_on)
 {
 	int err;
 	u8 flags;
 
-	mutex_lock(&bdev->mutex);
-
 	bdev->cache_fm_rds_system &= ~BCM2048_RDS_ON;
 
 	if (rds_on) {
@@ -477,24 +476,43 @@ static int bcm2048_set_rds(struct bcm204
 	err = bcm2048_send_command(bdev, BCM2048_I2C_FM_RDS_SYSTEM,
 					bdev->cache_fm_rds_system);
 
-	mutex_unlock(&bdev->mutex);
 	return err;
 }
 
-static int bcm2048_get_rds(struct bcm2048_device *bdev)
+static int bcm2048_get_rds_no_lock(struct bcm2048_device *bdev)
 {
 	int err;
 	u8 value;
 
+	err = bcm2048_recv_command(bdev, BCM2048_I2C_FM_RDS_SYSTEM, &value);
+
+	if (!err && (value & BCM2048_RDS_ON))
+		return BCM2048_ITEM_ENABLED;
+
+	return err;
+}
+
+static int bcm2048_set_rds(struct bcm2048_device *bdev, u8 rds_on)
+{
+	int err;
+
 	mutex_lock(&bdev->mutex);
 
-	err = bcm2048_recv_command(bdev, BCM2048_I2C_FM_RDS_SYSTEM, &value);
+	err = bcm2048_set_rds_no_lock(bdev, rds_on);
 
 	mutex_unlock(&bdev->mutex);
+	return err;
+}
 
-	if (!err && (value & BCM2048_RDS_ON))
-		return BCM2048_ITEM_ENABLED;
+static int bcm2048_get_rds(struct bcm2048_device *bdev)
+{
+	int err;
 
+	mutex_lock(&bdev->mutex);
+
+	err = bcm2048_get_rds_no_lock(bdev);
+
+	mutex_unlock(&bdev->mutex);
 	return err;
 }
 
@@ -699,7 +717,7 @@ static int bcm2048_set_region(struct bcm
 	int err;
 	u32 new_frequency = 0;
 
-	if (region > ARRAY_SIZE(region_configs))
+	if (region >= ARRAY_SIZE(region_configs))
 		return -EINVAL;
 
 	mutex_lock(&bdev->mutex);
@@ -923,7 +941,7 @@ static int bcm2048_get_fm_search_mode_di
 static int bcm2048_set_fm_search_tune_mode(struct bcm2048_device *bdev,
 						u8 mode)
 {
-	int err;
+	int err, timeout, restart_rds = 0;
 	u8 value, flags;
 
 	value = mode & BCM2048_FM_AUTO_SEARCH;
@@ -933,6 +951,20 @@ static int bcm2048_set_fm_search_tune_mo
 
 	mutex_lock(&bdev->mutex);
 
+	/*
+	 * If RDS is enabled, and frequency is changed, RDS quits working.
+	 * Thus, always restart RDS if it's enabled. Moreover, RDS must
+	 * not be enabled while changing the frequency because it can
+	 * provide a race to the mutex from the workqueue handler if RDS
+	 * IRQ occurs while waiting for frequency changed IRQ.
+	 */
+	if (bcm2048_get_rds_no_lock(bdev)) {
+		err = bcm2048_set_rds_no_lock(bdev, 0);
+		if (err)
+			goto unlock;
+		restart_rds = 1;
+	}
+
 	err = bcm2048_send_command(bdev, BCM2048_I2C_FM_RDS_MASK0, flags);
 
 	if (err)
@@ -940,8 +972,13 @@ static int bcm2048_set_fm_search_tune_mo
 
 	bcm2048_send_command(bdev, BCM2048_I2C_FM_SEARCH_TUNE_MODE, value);
 
+	if (mode != BCM2048_FM_AUTO_SEARCH_MODE)
+		timeout = BCM2048_DEFAULT_TIMEOUT;
+	else
+		timeout = BCM2048_AUTO_SEARCH_TIMEOUT;
+
 	if (!wait_for_completion_timeout(&bdev->compl,
-			msecs_to_jiffies(BCM2048_DEFAULT_TIMEOUT)))
+			msecs_to_jiffies(timeout)))
 			dev_err(&bdev->client->dev, "IRQ timeout.\n");
 
 	if (value)
@@ -949,7 +986,11 @@ static int bcm2048_set_fm_search_tune_mo
 			err = -EIO;
 
 unlock:
+	if (restart_rds)
+		err |= bcm2048_set_rds_no_lock(bdev, 1);
+
 	mutex_unlock(&bdev->mutex);
+
 	return err;
 }
 
@@ -2154,7 +2195,8 @@ static int bcm2048_vidioc_querycap(struc
 		sizeof(capability->card));
 	snprintf(capability->bus_info, 32, "I2C: 0x%X", bdev->client->addr);
 	capability->version = BCM2048_DRIVER_VERSION;
-	capability->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO;
+	capability->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO |
+					V4L2_CAP_HW_FREQ_SEEK;
 
 	return 0;
 }
@@ -2352,7 +2394,7 @@ static int bcm2048_vidioc_s_frequency(st
 		struct v4l2_frequency *freq)
 {
 	struct bcm2048_device *bdev = video_get_drvdata(video_devdata(file));
-	int err = 0, restart_rds = 0;
+	int err;
 
 	if (freq->type != V4L2_TUNER_RADIO)
 		return -EINVAL;
@@ -2360,15 +2402,27 @@ static int bcm2048_vidioc_s_frequency(st
 	if (!bdev->power_state)
 		return -ENODEV;
 
-	/* If RDS is enabled, and frequency is changed, RDS quits working */
-	if (bdev->rds_state) {
-		err |= bcm2048_set_rds(bdev, 0);
-		restart_rds = 1;
-	}
-	err |= bcm2048_set_fm_frequency(bdev, v4l2_to_dev(freq->frequency));
+	err = bcm2048_set_fm_frequency(bdev, v4l2_to_dev(freq->frequency));
 	err |= bcm2048_set_fm_search_tune_mode(bdev, BCM2048_FM_PRE_SET_MODE);
-	if (restart_rds)
-		err |= bcm2048_set_rds(bdev, 1);
+
+	return err;
+}
+
+static int bcm2048_vidioc_s_hw_freq_seek(struct file *file, void *priv,
+						struct v4l2_hw_freq_seek *seek)
+{
+	struct bcm2048_device *bdev = video_get_drvdata(video_devdata(file));
+	int err;
+
+	if (!bdev->power_state)
+		return -ENODEV;
+
+	if ((seek->tuner != 0) || (seek->type != V4L2_TUNER_RADIO))
+		return -EINVAL;
+
+	err = bcm2048_set_fm_search_mode_direction(bdev, seek->seek_upward);
+	err |= bcm2048_set_fm_search_tune_mode(bdev,
+			BCM2048_FM_AUTO_SEARCH_MODE);
 
 	return err;
 }
@@ -2386,6 +2440,7 @@ static struct v4l2_ioctl_ops bcm2048_ioc
 	.vidioc_s_tuner		= bcm2048_vidioc_s_tuner,
 	.vidioc_g_frequency	= bcm2048_vidioc_g_frequency,
 	.vidioc_s_frequency	= bcm2048_vidioc_s_frequency,
+	.vidioc_s_hw_freq_seek  = bcm2048_vidioc_s_hw_freq_seek,
 };
 
 /*
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/radio/radio-si4713.c kernel-2.6.28-20093908+0m5/drivers/media/radio/radio-si4713.c
--- kernel-2.6.28-20091602+0m5/drivers/media/radio/radio-si4713.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/radio/radio-si4713.c	2012-12-16 13:13:01.656330147 +0100
@@ -303,6 +303,22 @@ DEFINE_SYSFS_PROPERTY(region_preemphasis
 					(value != PREEMPHASIS_DISABLED)))
 DEFINE_SYSFS_PROPERTY(region, unsigned, int, "%u", 0)
 
+/*
+ * Tone properties
+ */
+/* tone_frequency (rw) 0 - 19000 */
+DEFINE_SYSFS_PROPERTY(tone_frequency, unsigned, int, "%u",
+			value > MAX_TONE_FREQUENCY)
+/* tone_deviation (rw) 0 - 90000 */
+DEFINE_SYSFS_PROPERTY(tone_deviation, unsigned, long, "%lu",
+			value > MAX_TONE_DEVIATION)
+/* tone_on_time (rw) 0 - 65535 */
+DEFINE_SYSFS_PROPERTY(tone_on_time, unsigned, int, "%u",
+			value > MAX_TONE_ON_TIME)
+/* tone_off_time (rw) 0 - 65535 */
+DEFINE_SYSFS_PROPERTY(tone_off_time, unsigned, int, "%u",
+			value > MAX_TONE_OFF_TIME)
+
 static struct attribute *attrs[] = {
 	&dev_attr_power_level.attr,
 	&dev_attr_antenna_capacitor.attr,
@@ -329,6 +345,10 @@ static struct attribute *attrs[] = {
 	&dev_attr_region_channel_spacing.attr,
 	&dev_attr_region.attr,
 	&dev_attr_tune_measure.attr,
+	&dev_attr_tone_frequency.attr,
+	&dev_attr_tone_deviation.attr,
+	&dev_attr_tone_on_time.attr,
+	&dev_attr_tone_off_time.attr,
 	NULL,
 };
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/radio/si4713.c kernel-2.6.28-20093908+0m5/drivers/media/radio/si4713.c
--- kernel-2.6.28-20091602+0m5/drivers/media/radio/si4713.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/radio/si4713.c	2012-12-16 13:13:01.660330147 +0100
@@ -78,6 +78,10 @@
 #define DEFAULT_MUTE			0x00
 #define DEFAULT_POWER_LEVEL		88
 #define DEFAULT_TUNE_RSSI		0xFF
+#define DEFAULT_TONE_FREQUENCY	 	0x00
+#define DEFAULT_TONE_DEVIATION		0x00
+#define DEFAULT_TONE_ON_TIME 		0x00
+#define DEFAULT_TONE_OFF_TIME		0x00
 
 #define POWER_OFF			0x00
 #define POWER_ON			0x01
@@ -864,6 +868,22 @@ int si4713_init(struct si4713_device *sd
 	if (rval < 0)
 		goto exit;
 
+	rval = si4713_set_tone_frequency(sdev, DEFAULT_TONE_FREQUENCY);
+	if (rval < 0)
+		goto exit;
+
+	rval = si4713_set_tone_deviation(sdev, DEFAULT_TONE_DEVIATION);
+	if (rval < 0)
+		goto exit;
+
+	rval = si4713_set_tone_on_time(sdev, DEFAULT_TONE_ON_TIME);
+	if (rval < 0)
+		goto exit;
+
+	rval = si4713_set_tone_off_time(sdev, DEFAULT_TONE_OFF_TIME);
+	if (rval < 0)
+		goto exit;
+
 exit:
 	return rval;
 }
@@ -964,6 +984,22 @@ int si4713_setup(struct si4713_device *s
 	if (rval < 0)
 		goto exit;
 
+	rval = si4713_set_tone_frequency(sdev, tmp->tone_info.frequency);
+	if (rval < 0)
+		goto exit;
+
+	rval = si4713_set_tone_deviation(sdev, tmp->tone_info.deviation);
+	if (rval < 0)
+		goto exit;
+
+	rval = si4713_set_tone_on_time(sdev, tmp->tone_info.on_time);
+	if (rval < 0)
+		goto exit;
+
+	rval = si4713_set_tone_off_time(sdev, tmp->tone_info.off_time);
+	if (rval < 0)
+		goto exit;
+
 	rval = si4713_set_frequency(sdev, tmp->frequency ? tmp->frequency :
 					tmp->region_info.bottom_frequency);
 	if (rval < 0)
@@ -1094,11 +1130,11 @@ int si4713_probe(struct si4713_device *s
 	if (rval < 0)
 		goto exit;
 
-	rval = si4713_init(sdev);
+	rval = si4713_set_power_state(sdev, POWER_OFF);
 	if (rval < 0)
 		goto exit;
 
-	rval = si4713_set_power_state(sdev, POWER_OFF);
+	rval = si4713_init(sdev);
 
 exit:
 	return rval;
@@ -1579,7 +1615,7 @@ int si4713_set_region(struct si4713_devi
 	int rval = 0;
 	u16 new_frequency = 0;
 
-	if (region > ARRAY_SIZE(region_configs))
+	if (region >= ARRAY_SIZE(region_configs))
 		return -EINVAL;
 
 	mutex_lock(&sdev->mutex);
@@ -1967,6 +2003,182 @@ int si4713_get_pilot_frequency(struct si
 
 unlock:
 	mutex_unlock(&sdev->mutex);
+	return rval;
+}
+
+int si4713_set_tone_deviation(struct si4713_device *sdev,
+					unsigned long deviation)
+{
+	int rval = 0;
+
+	/* Device receives in 10Hz units */
+	deviation /= 10;
+
+	mutex_lock(&sdev->mutex);
+
+	if (sdev->power_state)
+		rval = si4713_write_property(sdev, SI4713_TX_TONE_DEVIATION,
+						deviation);
+
+	/* Device returns in 10Hz units */
+	if (rval >= 0)
+		sdev->tone_info.deviation = deviation * 10;
+
+	mutex_unlock(&sdev->mutex);
+
+	return rval;
+}
+
+long si4713_get_tone_deviation(struct si4713_device *sdev)
+{
+	int rval;
+
+	mutex_lock(&sdev->mutex);
+
+	if (sdev->power_state) {
+		rval = si4713_read_property(sdev, SI4713_TX_TONE_DEVIATION);
+
+		if (rval < 0)
+			goto unlock;
+
+		/* Device returns in 10Hz units */
+		sdev->tone_info.deviation = rval * 10;
+	}
+
+	rval = sdev->tone_info.deviation;
+
+unlock:
+	mutex_unlock(&sdev->mutex);
+	return rval;
+}
+
+int si4713_set_tone_frequency(struct si4713_device *sdev, u16 freq)
+{
+	int rval = 0;
+
+	mutex_lock(&sdev->mutex);
+
+	if (sdev->power_state)
+		rval = si4713_write_property(sdev, SI4713_TX_TONE_FREQUENCY,
+						freq);
+
+	if (rval >= 0)
+		sdev->tone_info.frequency = freq;
+
+	mutex_unlock(&sdev->mutex);
+
+	return rval;
+}
+
+int si4713_get_tone_frequency(struct si4713_device *sdev)
+{
+	int rval;
+
+	mutex_lock(&sdev->mutex);
+
+	if (sdev->power_state) {
+		rval = si4713_read_property(sdev, SI4713_TX_TONE_FREQUENCY);
+
+		if (rval < 0)
+			goto unlock;
+
+		sdev->tone_info.frequency = rval;
+	}
+
+	rval = sdev->tone_info.frequency;
+
+unlock:
+	mutex_unlock(&sdev->mutex);
+	return rval;
+}
+
+int si4713_set_tone_on_time(struct si4713_device *sdev, u16 on_time)
+{
+	int rval = 0;
+
+	/* Device receives in 2ms units */
+	on_time >>= 1;
+
+	mutex_lock(&sdev->mutex);
+
+	if (sdev->power_state)
+		rval = si4713_write_property(sdev, SI4713_TX_TONE_ON_TIME,
+						on_time);
+
+	/* Device returns in 2ms units */
+	if (rval >= 0)
+		sdev->tone_info.on_time = on_time << 1;
+
+	mutex_unlock(&sdev->mutex);
+
+	return rval;
+}
+
+int si4713_get_tone_on_time(struct si4713_device *sdev)
+{
+	int rval;
+
+	mutex_lock(&sdev->mutex);
+
+	if (sdev->power_state) {
+		rval = si4713_read_property(sdev, SI4713_TX_TONE_ON_TIME);
+
+		if (rval < 0)
+			goto unlock;
+
+		/* Device returns in 2ms units */
+		sdev->tone_info.on_time = rval << 1;
+	}
+
+	rval = sdev->tone_info.on_time;
+
+unlock:
+	mutex_unlock(&sdev->mutex);
+	return rval;
+}
+
+int si4713_set_tone_off_time(struct si4713_device *sdev, u16 off_time)
+{
+	int rval = 0;
+
+	/* Device receives in 2ms units */
+	off_time >>= 1;
+
+	mutex_lock(&sdev->mutex);
+
+	if (sdev->power_state)
+		rval = si4713_write_property(sdev, SI4713_TX_TONE_OFF_TIME,
+						off_time);
+
+	/* Device returns in 2ms units */
+	if (rval >= 0)
+		sdev->tone_info.off_time = off_time << 1;
+
+	mutex_unlock(&sdev->mutex);
+
+	return rval;
+}
+
+int si4713_get_tone_off_time(struct si4713_device *sdev)
+{
+	int rval;
+
+	mutex_lock(&sdev->mutex);
+
+	if (sdev->power_state) {
+		rval = si4713_read_property(sdev, SI4713_TX_TONE_OFF_TIME);
+
+		if (rval < 0)
+			goto unlock;
+
+		/* Device returns in 2ms units */
+		sdev->tone_info.off_time = rval << 1;
+	}
+
+	rval = sdev->tone_info.off_time;
+
+unlock:
+	mutex_unlock(&sdev->mutex);
 	return rval;
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/radio/si4713.h kernel-2.6.28-20093908+0m5/drivers/media/radio/si4713.h
--- kernel-2.6.28-20091602+0m5/drivers/media/radio/si4713.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/radio/si4713.h	2012-12-16 13:13:01.660330147 +0100
@@ -129,6 +129,8 @@
 #define SI4713_TX_LINE_INPUT_MUTE	0x2105
 #define SI4713_TX_PREEMPHASIS		0x2106
 #define SI4713_TX_PILOT_FREQUENCY	0x2107
+#define SI4713_TX_TONE_DEVIATION	0x2108
+#define SI4713_TX_TONE_FREQUENCY	0x2109
 #define SI4713_TX_ACOMP_ENABLE		0x2200
 #define SI4713_TX_ACOMP_THRESHOLD	0x2201
 #define SI4713_TX_ACOMP_ATTACK_TIME	0x2202
@@ -148,6 +150,8 @@
 #define SI4713_TX_RDS_PS_MESSAGE_COUNT	0x2C05
 #define SI4713_TX_RDS_PS_AF		0x2C06
 #define SI4713_TX_RDS_FIFO_SIZE		0x2C07
+#define SI4713_TX_TONE_ON_TIME		0xF000
+#define SI4713_TX_TONE_OFF_TIME		0xF001
 
 #define PREEMPHASIS_USA			75
 #define PREEMPHASIS_EU			50
@@ -207,6 +211,17 @@ struct region_info {
 	u8 region;
 };
 
+struct tone_info {
+#define MAX_TONE_DEVIATION		90000
+	unsigned long deviation;
+#define MAX_TONE_FREQUENCY		19000
+	u16 frequency;
+#define MAX_TONE_ON_TIME		0xFFFF
+	u16 on_time;
+#define MAX_TONE_OFF_TIME		0xFFFF
+	u16 off_time;
+};
+
 /*
  * si4713_device - private data
  */
@@ -223,6 +238,7 @@ struct si4713_device {
 	struct pilot_info pilot_info;
 	struct acomp_info acomp_info;
 	struct region_info region_info;
+	struct tone_info tone_info;
 	u16 frequency;
 	u8 mute;
 	u8 power_level;
@@ -291,4 +307,13 @@ int si4713_set_region(struct si4713_devi
 int si4713_get_region(struct si4713_device *sdev);
 int si4713_set_tune_measure(struct si4713_device *sdev, u32 frequency);
 int si4713_get_tune_measure(struct si4713_device *sdev);
+int si4713_set_tone_frequency(struct si4713_device *sdev, u16 freq);
+int si4713_get_tone_frequency(struct si4713_device *sdev);
+int si4713_set_tone_deviation(struct si4713_device *sdev,
+					unsigned long deviation);
+long si4713_get_tone_deviation(struct si4713_device *sdev);
+int si4713_set_tone_on_time(struct si4713_device *sdev, u16 on_time);
+int si4713_get_tone_on_time(struct si4713_device *sdev);
+int si4713_set_tone_off_time(struct si4713_device *sdev, u16 off_time);
+int si4713_get_tone_off_time(struct si4713_device *sdev);
 #endif /* ifndef SI4713_H */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/adp1653.c kernel-2.6.28-20093908+0m5/drivers/media/video/adp1653.c
--- kernel-2.6.28-20091602+0m5/drivers/media/video/adp1653.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/adp1653.c	2012-12-16 13:13:01.660330147 +0100
@@ -355,7 +355,7 @@ static int adp1653_init_device(struct v4
 	return 0;
 }
 
-static void adp1653_init_controls(struct v4l2_int_device *s)
+static int adp1653_ioctl_dev_init(struct v4l2_int_device *s)
 {
 	struct adp1653_flash *flash = s->priv;
 
@@ -377,6 +377,7 @@ static void adp1653_init_controls(struct
 			[CTRL_CAMERA_FLASH_TORCH_INTENSITY].default_value;
 	flash->indicator_intensity = adp1653_ctrls
 			[CTRL_CAMERA_FLASH_INDICATOR_INTENSITY].default_value;
+	return 0;
 }
 
 static int adp1653_ioctl_s_power(struct v4l2_int_device *s,
@@ -385,13 +386,14 @@ static int adp1653_ioctl_s_power(struct
 	struct adp1653_flash *flash = s->priv;
 	int rval = 0;
 
+	if (state == V4L2_POWER_STANDBY)
+		state = V4L2_POWER_ON;
+	if (state == flash->power)
+		return 0;
+
 	switch (state) {
+	case V4L2_POWER_STANDBY:
 	case V4L2_POWER_ON:
-		if (!flash->dev_init_done) {
-			flash->dev_init_done = true;
-			adp1653_init_controls(s);
-		}
-
 		rval = flash->platform_data->power_on(s);
 		if (rval)
 			return rval;
@@ -404,7 +406,6 @@ static int adp1653_ioctl_s_power(struct
 		break;
 
 	case V4L2_POWER_OFF:
-	case V4L2_POWER_STANDBY:
 		rval = flash->platform_data->power_off(s);
 		flash->power = V4L2_POWER_OFF;
 		break;
@@ -424,18 +425,6 @@ static int adp1653_ioctl_g_priv(struct v
 	return flash->platform_data->g_priv(s, priv);
 }
 
-static int adp1653_ioctl_enum_slaves(struct v4l2_int_device *s,
-			     struct v4l2_slave_info *si)
-{
-/* 	struct adp1653_flash *flash = s->priv; */
-
-	strlcpy(si->driver, ADP1653_NAME, sizeof(si->driver));
-	strlcpy(si->bus_info, "NULL", sizeof(si->bus_info));
-	snprintf(si->version, sizeof(si->version), "%x", 0);
-
-	return 0;
-}
-
 static struct v4l2_int_ioctl_desc adp1653_ioctl_desc[] = {
 	{ vidioc_int_queryctrl_num,
 	  (v4l2_int_ioctl_func *)adp1653_ioctl_queryctrl },
@@ -447,8 +436,8 @@ static struct v4l2_int_ioctl_desc adp165
 	  (v4l2_int_ioctl_func *)adp1653_ioctl_s_power },
 	{ vidioc_int_g_priv_num,
 	  (v4l2_int_ioctl_func *)adp1653_ioctl_g_priv },
-	{ vidioc_int_enum_slaves_num,
-	  (v4l2_int_ioctl_func *)adp1653_ioctl_enum_slaves },
+	{ vidioc_int_dev_init_num,
+	  (v4l2_int_ioctl_func *)adp1653_ioctl_dev_init },
 };
 
 static struct v4l2_int_slave adp1653_slave = {
@@ -515,8 +504,6 @@ static int adp1653_probe(struct i2c_clie
 	if (flash->platform_data == NULL)
 		return -ENODEV;
 
-	flash->dev_init_done = false;
-
 	flash->v4l2_int_device = &adp1653_int_device;
 
 	flash->i2c_client = client;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/ad5820.c kernel-2.6.28-20093908+0m5/drivers/media/video/ad5820.c
--- kernel-2.6.28-20091602+0m5/drivers/media/video/ad5820.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/ad5820.c	2012-12-16 13:13:01.660330147 +0100
@@ -256,46 +256,69 @@ static int ad5820_ioctl_s_ctrl(struct v4
 	return r;
 }
 
-/* Power must not be OFF when this function is called */
-static int ad5820_configure(struct v4l2_int_device *s)
+static int ad5820_ioctl_dev_init(struct v4l2_int_device *s)
 {
+	/* Detect that the chip is there */
+
 	struct ad5820_device *coil = s->priv;
+	static const int CHECK_VALUE = 0x3FF0;
+	u16 status = BIT_POWER_DOWN | CHECK_VALUE;
 	int rval;
 
-	if (!coil->dev_init_done) {
-		/* Detect that the chip is there */
-		static const int CHECK_VALUE = 0x3FF0;
-		u16 status = BIT_POWER_DOWN | CHECK_VALUE;
-
-		rval = ad5820_write(s, status);
-		if (rval)
-			goto not_detected;
-		rval = ad5820_read(s);
-		if (rval != status)
-			goto not_detected;
-		coil->dev_init_done = true;
-	}
+	rval = coil->platform_data->s_power(s, V4L2_POWER_ON);
+	if (rval)
+		goto not_detected;
+	rval = ad5820_write(s, status);
+	if (rval)
+		goto not_detected;
+	rval = ad5820_read(s);
+	if (rval != status)
+		goto not_detected;
 
-	return ad5820_update_hw(s);
+	coil->platform_data->s_power(s, V4L2_POWER_OFF);
+	return 0;
 
 not_detected:
-	printk(KERN_ERR AD5820_NAME ": not detected\n");
+	dev_err(&coil->i2c_client->dev, "not detected\n");
 	return -ENODEV;
 }
 
 static int ad5820_ioctl_s_power(struct v4l2_int_device *s,
-				enum v4l2_power state)
+				enum v4l2_power new_state)
 {
 	struct ad5820_device *coil = s->priv;
+	enum v4l2_power orig_state = coil->power;
 	int rval;
 
-	rval = coil->platform_data->s_power(s, state);
-	if (rval)
-		return rval;
-	coil->power = state;
+	if (new_state == V4L2_POWER_STANDBY)
+		new_state = V4L2_POWER_ON;
 
-	if (state == V4L2_POWER_ON) {
-		rval = ad5820_configure(s);
+	if (orig_state == new_state)
+		return 0;
+	if (orig_state == V4L2_POWER_OFF) {
+		/* Requested STANDBY or ON -- enable power */
+		rval = coil->platform_data->s_power(s, V4L2_POWER_ON);
+		if (rval)
+			return rval;
+	}
+	coil->power = new_state;
+	if (new_state == V4L2_POWER_OFF) {
+		/* Requested OFF -- before disabling power, set to standby */
+		coil->power = V4L2_POWER_STANDBY;
+	}
+	/*
+	 * Here power is on. If OFF is requested, the chip
+	 * is first set into STANDBY mode. This is necessary
+	 * because sensor driver might keep power enabled even
+	 * if lens driver requests it off.
+	 */
+	rval = ad5820_update_hw(s);
+	if (rval)
+		goto fail;
+	coil->power = new_state;
+	if (new_state == V4L2_POWER_OFF) {
+		/* Requested OFF -- disable power */
+		rval = coil->platform_data->s_power(s, V4L2_POWER_OFF);
 		if (rval)
 			goto fail;
 	}
@@ -303,8 +326,11 @@ static int ad5820_ioctl_s_power(struct v
 	return 0;
 
 fail:
-	coil->power = V4L2_POWER_OFF;
-	coil->platform_data->s_power(s, V4L2_POWER_OFF);
+	/* Try to restore original state and return error code */
+	coil->platform_data->s_power(s, orig_state == V4L2_POWER_OFF ?
+				     V4L2_POWER_OFF : V4L2_POWER_ON);
+	coil->power = orig_state;
+	ad5820_update_hw(s);
 	return rval;
 }
 
@@ -328,6 +354,8 @@ static struct v4l2_int_ioctl_desc ad5820
 	  (v4l2_int_ioctl_func *)ad5820_ioctl_s_power },
 	{ vidioc_int_g_priv_num,
 	  (v4l2_int_ioctl_func *)ad5820_ioctl_g_priv },
+	{ vidioc_int_dev_init_num,
+	  (v4l2_int_ioctl_func *)ad5820_ioctl_dev_init },
 };
 
 static struct v4l2_int_slave ad5820_slave = {
@@ -398,7 +426,6 @@ static int ad5820_probe(struct i2c_clien
 			ad5820_ctrls[CTRL_FOCUS_RAMP_TIME].default_value;
 	coil->focus_ramp_mode =
 			ad5820_ctrls[CTRL_FOCUS_RAMP_MODE].default_value;
-	coil->dev_init_done   = false;
 
 	coil->v4l2_int_device = &ad5820_int_device;
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/et8ek8.c kernel-2.6.28-20093908+0m5/drivers/media/video/et8ek8.c
--- kernel-2.6.28-20091602+0m5/drivers/media/video/et8ek8.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/et8ek8.c	2012-12-16 13:13:01.660330147 +0100
@@ -134,7 +134,7 @@ static int et8ek8_set_gain(struct et8ek8
 		sensor->controls[CTRL_GAIN].minimum,
 		sensor->controls[CTRL_GAIN].maximum);
 
-	if (sensor->power != V4L2_POWER_ON)
+	if (sensor->power == V4L2_POWER_OFF)
 		return 0;
 
 	new = et8ek8_gain_table[sensor->controls[CTRL_GAIN].value];
@@ -189,7 +189,7 @@ static int et8ek8_set_exposure(struct et
 	/* Set the V4L2 control for exposure time to the rounded value */
 	sensor->controls[CTRL_EXPOSURE].value = (rt * rows + (1 << 7)) >> 8;
 
-	if (sensor->power != V4L2_POWER_ON)
+	if (sensor->power == V4L2_POWER_OFF)
 		return 0;
 
 	return smia_i2c_write_reg(sensor->i2c_client, SMIA_REG_16BIT, 0x1243,
@@ -205,7 +205,7 @@ static int et8ek8_set_test_pattern(struc
 
 	sensor->controls[CTRL_TEST_PATTERN].value = mode;
 
-	if (sensor->power != V4L2_POWER_ON)
+	if (sensor->power == V4L2_POWER_OFF)
 		return 0;
 
 	/* Values for normal mode */
@@ -260,21 +260,13 @@ out:
 
 }
 
-static int et8ek8_configure(struct v4l2_int_device *s)
+static int et8ek8_update_controls(struct v4l2_int_device *s)
 {
 	struct et8ek8_sensor *sensor = s->priv;
-	int rval, val, i;
+	int i;
 	unsigned int rt;	/* Row time in us */
 	unsigned int clock;	/* Pixel clock in Hz>>2 fixed point */
 
-	rval = smia_i2c_reglist_find_write(sensor->i2c_client,
-					   sensor->meta_reglist,
-					   SMIA_REGLIST_POWERON);
-	if (rval)
-		return rval;
-
-	/* Update V4L2 exposure controls to the current mode */
-
 	if (sensor->current_reglist->mode.pixel_clock <= 0 ||
 	    sensor->current_reglist->mode.width <= 0) {
 		dev_err(&sensor->i2c_client->dev, "bad firmware\n");
@@ -299,61 +291,52 @@ static int et8ek8_configure(struct v4l2_
 	/* Adjust V4L2 control values and write them to the sensor */
 
 	for (i=0; i<ARRAY_SIZE(sensor->controls); i++) {
-		rval = sensor->controls[i].set(sensor,
+		int rval = sensor->controls[i].set(sensor,
 			sensor->controls[i].value);
 		if (rval)
-			goto fail;
+			return rval;
 	}
+	return 0;
+}
 
-#ifdef USE_CRC
-	rval = smia_i2c_read_reg(sensor->i2c_client,
-				 SMIA_REG_8BIT, 0x1263, &val);
-	if (rval)
-		goto fail;
-#if USE_CRC
-	val |= (1<<4);
-#else
-	val &= ~(1<<4);
-#endif
-	rval = smia_i2c_write_reg(sensor->i2c_client,
-				  SMIA_REG_8BIT, 0x1263, val);
+static int et8ek8_configure(struct v4l2_int_device *s)
+{
+	struct et8ek8_sensor *sensor = s->priv;
+	int rval;
+
+	rval = et8ek8_update_controls(s);
 	if (rval)
 		goto fail;
-#endif
 
 	rval = smia_i2c_write_regs(sensor->i2c_client,
 				   sensor->current_reglist->regs);
 	if (rval)
 		goto fail;
 
-	return rval;
+	rval = sensor->platform_data->configure_interface(
+		s, &sensor->current_reglist->mode);
+	if (rval)
+		goto fail;
+
+	return 0;
 
 fail:
 	dev_err(&sensor->i2c_client->dev, "sensor configuration failed\n");
 	return rval;
-
 }
 
-static int et8ek8_setup_if(struct v4l2_int_device *s)
+static int et8ek8_stream_on(struct v4l2_int_device *s)
 {
 	struct et8ek8_sensor *sensor = s->priv;
-	int rval;
-	unsigned int hz;
-
-	if (sensor->current_reglist) {
-		rval = sensor->platform_data->configure_interface(
-			s, &sensor->current_reglist->mode);
-		if (rval)
-			return rval;
-		hz = sensor->current_reglist->mode.ext_clock;
-	} else {
-		hz = ET8EK8_XCLK_HZ;
-	}
-
-	sensor->platform_data->set_xclk(s, hz);
-	msleep(5000*1000/ET8EK8_XCLK_HZ+1);		/* Wait 5000 cycles */
+	return smia_i2c_write_reg(sensor->i2c_client,
+				  SMIA_REG_8BIT, 0x1252, 0xB0);
+}
 
-	return 0;
+static int et8ek8_stream_off(struct v4l2_int_device *s)
+{
+	struct et8ek8_sensor *sensor = s->priv;
+	return smia_i2c_write_reg(sensor->i2c_client,
+				  SMIA_REG_8BIT, 0x1252, 0x30);
 }
 
 static int et8ek8_power_off(struct v4l2_int_device *s)
@@ -361,29 +344,62 @@ static int et8ek8_power_off(struct v4l2_
 	struct et8ek8_sensor *sensor = s->priv;
 	int rval;
 
-	rval = sensor->platform_data->set_xclk(s, 0);
+	rval = sensor->platform_data->power_off(s);
 	if (rval)
 		return rval;
-
-	return sensor->platform_data->power_off(s);
+	udelay(1);
+	rval = sensor->platform_data->set_xclk(s, 0);
+	return rval;
 }
 
 static int et8ek8_power_on(struct v4l2_int_device *s)
 {
 	struct et8ek8_sensor *sensor = s->priv;
-	int rval;
+	unsigned int hz = ET8EK8_XCLK_HZ;
+	int val, rval;
+
+	if (sensor->current_reglist)
+		hz = sensor->current_reglist->mode.ext_clock;
+
+	rval = sensor->platform_data->set_xclk(s, hz);
+	if (rval)
+		goto out;
+
+	udelay(10);			/* I wish this is a good value */
 
 	rval = sensor->platform_data->power_on(s);
 	if (rval)
 		goto out;
 
-	/*
-	 * At least one ms is required between xshutdown up and clock
-	 * start.
-	 */
-	msleep(1);
+	msleep(5000*1000/hz+1);				/* Wait 5000 cycles */
+
+	if (sensor->meta_reglist) {
+		rval = smia_i2c_reglist_find_write(sensor->i2c_client,
+						   sensor->meta_reglist,
+						   SMIA_REGLIST_POWERON);
+		if (rval)
+			goto out;
+	}
 
-	rval = et8ek8_setup_if(s);
+	rval = et8ek8_stream_off(s);
+	if (rval)
+		goto out;
+
+#ifdef USE_CRC
+	rval = smia_i2c_read_reg(sensor->i2c_client,
+				 SMIA_REG_8BIT, 0x1263, &val);
+	if (rval)
+		goto out;
+#if USE_CRC
+	val |= (1<<4);
+#else
+	val &= ~(1<<4);
+#endif
+	rval = smia_i2c_write_reg(sensor->i2c_client,
+				  SMIA_REG_8BIT, 0x1263, val);
+	if (rval)
+		goto out;
+#endif
 
 out:
 	if (rval)
@@ -540,9 +556,13 @@ static int et8ek8_ioctl_s_fmt_cap(struct
 	if (!reglist)
 		return -EINVAL;
 
+	if (sensor->power != V4L2_POWER_OFF &&
+	    sensor->current_reglist->mode.ext_clock != reglist->mode.ext_clock)
+		return -EINVAL;
+
 	sensor->current_reglist = reglist;
 
-	return 0;
+	return et8ek8_update_controls(s);
 }
 
 static int et8ek8_ioctl_g_parm(struct v4l2_int_device *s,
@@ -575,9 +595,13 @@ static int et8ek8_ioctl_s_parm(struct v4
 	if (!reglist)
 		return -EINVAL;
 
+	if (sensor->power != V4L2_POWER_OFF &&
+	    sensor->current_reglist->mode.ext_clock != reglist->mode.ext_clock)
+		return -EINVAL;
+
 	sensor->current_reglist = reglist;
 
-	return 0;
+	return et8ek8_update_controls(s);
 }
 
 static int et8ek8_g_priv_mem(struct v4l2_int_device *s)
@@ -657,23 +681,26 @@ out:
 	return rval;
 }
 
-static int et8ek8_dev_init(struct v4l2_int_device *s)
+static int et8ek8_ioctl_dev_init(struct v4l2_int_device *s)
 {
 	struct et8ek8_sensor *sensor = s->priv;
 	char name[FIRMWARE_NAME_MAX];
 	int rval, rev_l, rev_h;
 
+	rval = et8ek8_power_on(s);
+	if (rval)
+		return -ENODEV;
+
 	if (smia_i2c_read_reg(sensor->i2c_client, SMIA_REG_8BIT,
 			      REG_REVISION_NUMBER_L, &rev_l) != 0
 	    || smia_i2c_read_reg(sensor->i2c_client, SMIA_REG_8BIT,
 				 REG_REVISION_NUMBER_H, &rev_h) != 0) {
 		dev_err(&sensor->i2c_client->dev,
 			"no et8ek8 sensor detected\n");
-		return -ENODEV;
+		rval = -ENODEV;
+		goto out_poweroff;
 	}
-
 	sensor->version = (rev_h << 8) + rev_l;
-
 	if (sensor->version != ET8EK8_REV_1
 	    && sensor->version != ET8EK8_REV_2)
 		dev_info(&sensor->i2c_client->dev,
@@ -682,17 +709,15 @@ static int et8ek8_dev_init(struct v4l2_i
 
 	snprintf(name, FIRMWARE_NAME_MAX, "%s-%4.4x.bin", ET8EK8_NAME,
 		 sensor->version);
-
 	if (request_firmware(&sensor->fw, name,
 			     &sensor->i2c_client->dev)) {
 		dev_err(&sensor->i2c_client->dev,
 			"can't load firmware %s\n", name);
-		return -ENODEV;
+		rval = -ENODEV;
+		goto out_poweroff;
 	}
-
 	sensor->meta_reglist =
 		(struct smia_meta_reglist *)sensor->fw->data;
-
 	rval = smia_reglist_import(sensor->meta_reglist);
 	if (rval) {
 		dev_err(&sensor->i2c_client->dev,
@@ -712,61 +737,91 @@ static int et8ek8_dev_init(struct v4l2_i
 		goto out_release;
 	}
 
-	sensor->dev_init_done = true;
+	rval = smia_i2c_reglist_find_write(sensor->i2c_client,
+					   sensor->meta_reglist,
+					   SMIA_REGLIST_POWERON);
+	if (rval) {
+		dev_err(&sensor->i2c_client->dev,
+			"invalid register list %s, no POWERON mode found\n",
+			name);
+		goto out_release;
+	}
+	rval = et8ek8_stream_on(s);	/* Needed to be able to read EEPROM */
+	if (rval)
+		goto out_release;
+	rval = et8ek8_g_priv_mem(s);
+	if (rval)
+		dev_warn(&sensor->i2c_client->dev,
+			"can not read OTP (EEPROM) memory from sensor\n");
+	rval = et8ek8_stream_off(s);
+	if (rval)
+		goto out_release;
+
+	rval = et8ek8_power_off(s);
+	if (rval)
+		goto out_release;
 
 	return 0;
 
 out_release:
 	release_firmware(sensor->fw);
+out_poweroff:
 	sensor->meta_reglist = NULL;
 	sensor->fw = NULL;
+	et8ek8_power_off(s);
 
 	return rval;
 }
 
 static int et8ek8_ioctl_s_power(struct v4l2_int_device *s,
-				enum v4l2_power state)
+				enum v4l2_power new_state)
 {
 	struct et8ek8_sensor *sensor = s->priv;
-	int initialized = sensor->dev_init_done;
 	int rval = 0;
-	enum v4l2_power old_state;
 
-	if (state != V4L2_POWER_ON)
-		state = V4L2_POWER_OFF;
-
-	old_state = sensor->power;
-	sensor->power = state;
+	/* If we are already in this mode, do nothing */
+	if (sensor->power == new_state)
+		return 0;
 
-	switch (state) {
-	case V4L2_POWER_STANDBY:
-	case V4L2_POWER_OFF:
+	/* Disable power if so requested (it was enabled) */
+	if (new_state == V4L2_POWER_OFF) {
+		rval = et8ek8_stream_off(s);
+		if (rval)
+			dev_err(&sensor->i2c_client->dev,
+				"can not stop streaming\n");
 		rval = et8ek8_power_off(s);
-		break;
-	case V4L2_POWER_ON:
+		goto out;
+	}
+
+	/* Either STANDBY or ON requested */
+
+	/* Enable power and move to standby if it was off */
+	if (sensor->power == V4L2_POWER_OFF) {
 		rval = et8ek8_power_on(s);
 		if (rval)
-			break;
-		if (!initialized) {
-			rval = et8ek8_dev_init(s);
-			if (rval)
-				goto out_on;
-		}
+			goto out;
+	}
+
+	/* Now sensor is powered (standby or streaming) */
+
+	if (new_state == V4L2_POWER_ON) {
+		/* Standby -> streaming */
 		rval = et8ek8_configure(s);
-		if (rval)
-			goto out_on;
-		if (!initialized)
-			rval = et8ek8_g_priv_mem(s);
-	out_on:
-		if (rval)
-			et8ek8_power_off(s);
-		break;
-	default:
-		return -EINVAL;
+		if (rval) {
+			et8ek8_stream_off(s);
+			if (sensor->power == V4L2_POWER_OFF)
+				et8ek8_power_off(s);
+			goto out;
+		}
+		rval = et8ek8_stream_on(s);
+	} else {
+		/* Streaming -> standby */
+		rval = et8ek8_stream_off(s);
 	}
 
-	if (rval)
-		sensor->power = old_state;
+out:
+	if (rval == 0)
+		sensor->power = new_state;
 
 	return rval;
 }
@@ -794,18 +849,6 @@ static int et8ek8_ioctl_enum_frameinterv
 	return smia_reglist_enum_frameintervals(sensor->meta_reglist, frm);
 }
 
-static int et8ek8_ioctl_enum_slaves(struct v4l2_int_device *s,
-				    struct v4l2_slave_info *si)
-{
-	struct et8ek8_sensor *sensor = s->priv;
-
-	strlcpy(si->driver, ET8EK8_NAME, sizeof(si->driver));
-	strlcpy(si->bus_info, "ccp2", sizeof(si->bus_info));
-	snprintf(si->version, sizeof(si->version), "%x", sensor->version);
-
-	return 0;
-}
-
 static ssize_t
 et8ek8_priv_mem_read(struct device *dev, struct device_attribute *attr,
 		     char *buf)
@@ -815,8 +858,6 @@ et8ek8_priv_mem_read(struct device *dev,
 #if PAGE_SIZE < ET8EK8_PRIV_MEM_SIZE
 #error PAGE_SIZE too small!
 #endif
-	if (!sensor->dev_init_done)
-		return -EBUSY;
 
 	memcpy(buf, sensor->priv_mem, ET8EK8_PRIV_MEM_SIZE);
 
@@ -853,8 +894,8 @@ static struct v4l2_int_ioctl_desc et8ek8
 	  (v4l2_int_ioctl_func *)et8ek8_ioctl_enum_framesizes },
 	{ vidioc_int_enum_frameintervals_num,
 	  (v4l2_int_ioctl_func *)et8ek8_ioctl_enum_frameintervals },
-	{ vidioc_int_enum_slaves_num,
-	  (v4l2_int_ioctl_func *)et8ek8_ioctl_enum_slaves },
+	{ vidioc_int_dev_init_num,
+	  (v4l2_int_ioctl_func *)et8ek8_ioctl_dev_init },
 };
 
 static struct v4l2_int_slave et8ek8_slave = {
@@ -879,24 +920,21 @@ static struct v4l2_int_device et8ek8_int
 static int et8ek8_suspend(struct i2c_client *client, pm_message_t mesg)
 {
 	struct et8ek8_sensor *sensor = dev_get_drvdata(&client->dev);
+	enum v4l2_power resume_state = sensor->power;
+	int rval;
 
-	if (sensor->power == V4L2_POWER_OFF)
-		return 0;
-
-	return et8ek8_power_off(sensor->v4l2_int_device);
+	rval = et8ek8_ioctl_s_power(sensor->v4l2_int_device, V4L2_POWER_OFF);
+	if (rval == 0)
+		sensor->power = resume_state;
+	return rval;
 }
 
 static int et8ek8_resume(struct i2c_client *client)
 {
 	struct et8ek8_sensor *sensor = dev_get_drvdata(&client->dev);
-	enum v4l2_power resume_state;
+	enum v4l2_power resume_state = sensor->power;
 
-	if (sensor->power == V4L2_POWER_OFF)
-		return 0;
-
-	resume_state = sensor->power;
 	sensor->power = V4L2_POWER_OFF;
-
 	return et8ek8_ioctl_s_power(sensor->v4l2_int_device, resume_state);
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/et8ek8.h kernel-2.6.28-20093908+0m5/drivers/media/video/et8ek8.h
--- kernel-2.6.28-20091602+0m5/drivers/media/video/et8ek8.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/et8ek8.h	2012-12-16 13:13:01.660330147 +0100
@@ -73,7 +73,6 @@ struct et8ek8_sensor {
 	struct smia_meta_reglist *meta_reglist;
 	u8 priv_mem[ET8EK8_PRIV_MEM_SIZE];
 
-	bool dev_init_done;
 	enum v4l2_power power;
 };
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isp_af.c kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isp_af.c
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isp_af.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isp_af.c	2012-12-16 13:13:01.660330147 +0100
@@ -8,6 +8,7 @@
  * Contributors:
  *	Sergio Aguirre <saaguirre@ti.com>
  *	Troy Laramy
+ * 	David Cohen <david.cohen@nokia.com>
  *
  * This package is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -19,665 +20,436 @@
  */
 
 /* Linux specific include files */
-#include <asm/cacheflush.h>
-
-#include <linux/uaccess.h>
-#include <linux/dma-mapping.h>
-#include <asm/atomic.h>
+#include <linux/device.h>
 
 #include "isp.h"
 #include "ispreg.h"
 #include "isph3a.h"
 #include "isp_af.h"
-#include "ispmmu.h"
-
-/**
- * isp_af_setxtrastats - Receives extra statistics from prior frames.
- * @xtrastats: Pointer to structure containing extra statistics fields like
- *             field count and timestamp of frame.
- *
- * Called from update_vbq in camera driver
- **/
-void isp_af_setxtrastats(struct isp_af_device *isp_af,
-			 struct isp_af_xtrastats *xtrastats, u8 updateflag)
-{
-	int i, past_i;
-
-	if (isp_af->active_buff == NULL)
-		return;
-
-	for (i = 0; i < H3A_MAX_BUFF; i++) {
-		if (isp_af->af_buff[i].frame_num ==
-				isp_af->active_buff->frame_num)
-			break;
-	}
-
-	if (i == H3A_MAX_BUFF)
-		return;
-
-	if (i == 0) {
-		if (isp_af->af_buff[H3A_MAX_BUFF - 1].locked == 0)
-			past_i = H3A_MAX_BUFF - 1;
-		else
-			past_i = H3A_MAX_BUFF - 2;
-	} else if (i == 1) {
-		if (isp_af->af_buff[0].locked == 0)
-			past_i = 0;
-		else
-			past_i = H3A_MAX_BUFF - 1;
-	} else {
-		if (isp_af->af_buff[i - 1].locked == 0)
-			past_i = i - 1;
-		else
-			past_i = i - 2;
-	}
-
-	if (updateflag & AF_UPDATEXS_TS)
-		isp_af->af_buff[past_i].xtrastats.ts = xtrastats->ts;
-
-	if (updateflag & AF_UPDATEXS_FIELDCOUNT)
-		isp_af->af_buff[past_i].xtrastats.field_count =
-			xtrastats->field_count;
-}
-EXPORT_SYMBOL(isp_af_setxtrastats);
-
-/*
- * Helper function to update buffer cache pages
- */
-static void isp_af_update_req_buffer(struct isp_af_device *isp_af,
-				     struct isp_af_buffer *buffer)
-{
-	int size = isp_af->stats_buf_size;
-
-	size = PAGE_ALIGN(size);
-	/* Update the kernel pages of the requested buffer */
-	dmac_inv_range((void *)buffer->addr_align, (void *)buffer->addr_align +
-		       size);
-}
 
 #define IS_OUT_OF_BOUNDS(value, min, max)		\
 	(((value) < (min)) || ((value) > (max)))
 
 /* Function to check paxel parameters */
-int isp_af_check_paxel(struct isp_af_device *isp_af)
+static int isp_af_check_params(struct isp_af_device *isp_af,
+			       struct af_configuration *afconfig)
 {
-	struct af_paxel *paxel_cfg = &isp_af->config.paxel_config;
-	struct af_iir *iir_cfg = &isp_af->config.iir_config;
+	struct af_paxel *paxel_cfg = &afconfig->paxel_config;
+	struct af_iir *iir_cfg = &afconfig->iir_config;
+	int index;
 
 	/* Check horizontal Count */
 	if (IS_OUT_OF_BOUNDS(paxel_cfg->hz_cnt, AF_PAXEL_HORIZONTAL_COUNT_MIN,
-			     AF_PAXEL_HORIZONTAL_COUNT_MAX)) {
-		DPRINTK_ISP_AF("Error : Horizontal Count is incorrect");
+			     AF_PAXEL_HORIZONTAL_COUNT_MAX))
 		return -AF_ERR_HZ_COUNT;
-	}
 
-	/*Check Vertical Count */
+	/* Check Vertical Count */
 	if (IS_OUT_OF_BOUNDS(paxel_cfg->vt_cnt, AF_PAXEL_VERTICAL_COUNT_MIN,
-			     AF_PAXEL_VERTICAL_COUNT_MAX)) {
-		DPRINTK_ISP_AF("Error : Vertical Count is incorrect");
+			     AF_PAXEL_VERTICAL_COUNT_MAX))
 		return -AF_ERR_VT_COUNT;
-	}
 
-	/*Check Height */
+	/* Check Height */
 	if (IS_OUT_OF_BOUNDS(paxel_cfg->height, AF_PAXEL_HEIGHT_MIN,
-			     AF_PAXEL_HEIGHT_MAX)) {
-		DPRINTK_ISP_AF("Error : Height is incorrect");
+			     AF_PAXEL_HEIGHT_MAX))
 		return -AF_ERR_HEIGHT;
-	}
 
-	/*Check width */
+	/* Check width */
 	if (IS_OUT_OF_BOUNDS(paxel_cfg->width, AF_PAXEL_WIDTH_MIN,
-			     AF_PAXEL_WIDTH_MAX)) {
-		DPRINTK_ISP_AF("Error : Width is incorrect");
+			     AF_PAXEL_WIDTH_MAX))
 		return -AF_ERR_WIDTH;
-	}
 
-	/*Check Line Increment */
+	/* Check Line Increment */
 	if (IS_OUT_OF_BOUNDS(paxel_cfg->line_incr, AF_PAXEL_INCREMENT_MIN,
-			     AF_PAXEL_INCREMENT_MAX)) {
-		DPRINTK_ISP_AF("Error : Line Increment is incorrect");
+			     AF_PAXEL_INCREMENT_MAX))
 		return -AF_ERR_INCR;
-	}
 
-	/*Check Horizontal Start */
+	/* Check Horizontal Start */
 	if ((paxel_cfg->hz_start % 2 != 0) ||
 	    (paxel_cfg->hz_start < (iir_cfg->hz_start_pos + 2)) ||
 	    IS_OUT_OF_BOUNDS(paxel_cfg->hz_start,
-			     AF_PAXEL_HZSTART_MIN, AF_PAXEL_HZSTART_MAX)) {
-		DPRINTK_ISP_AF("Error : Horizontal Start is incorrect");
+			     AF_PAXEL_HZSTART_MIN, AF_PAXEL_HZSTART_MAX))
 		return -AF_ERR_HZ_START;
-	}
 
-	/*Check Vertical Start */
+	/* Check Vertical Start */
 	if (IS_OUT_OF_BOUNDS(paxel_cfg->vt_start, AF_PAXEL_VTSTART_MIN,
-			     AF_PAXEL_VTSTART_MAX)) {
-		DPRINTK_ISP_AF("Error : Vertical Start is incorrect");
+			     AF_PAXEL_VTSTART_MAX))
 		return -AF_ERR_VT_START;
-	}
-	return 0;
-}
-
-/**
- * isp_af_check_iir - Function to check IIR Coefficient.
- **/
-int isp_af_check_iir(struct isp_af_device *isp_af)
-{
-	struct af_iir *iir_cfg = &isp_af->config.iir_config;
-	int index;
 
+	/* Check IIR */
 	for (index = 0; index < AF_NUMBER_OF_COEF; index++) {
-		if ((iir_cfg->coeff_set0[index]) > AF_COEF_MAX) {
-			DPRINTK_ISP_AF("Error : Coefficient for set 0 is "
-				       "incorrect");
+		if ((iir_cfg->coeff_set0[index]) > AF_COEF_MAX)
 			return -AF_ERR_IIR_COEF;
-		}
 
-		if ((iir_cfg->coeff_set1[index]) > AF_COEF_MAX) {
-			DPRINTK_ISP_AF("Error : Coefficient for set 1 is "
-				       "incorrect");
+		if ((iir_cfg->coeff_set1[index]) > AF_COEF_MAX)
 			return -AF_ERR_IIR_COEF;
-		}
 	}
 
 	if (IS_OUT_OF_BOUNDS(iir_cfg->hz_start_pos, AF_IIRSH_MIN,
-			     AF_IIRSH_MAX)) {
-		DPRINTK_ISP_AF("Error : IIRSH is incorrect");
+			     AF_IIRSH_MAX))
 		return -AF_ERR_IIRSH;
-	}
-
-	return 0;
-}
-/**
- * isp_af_unlock_buffers - Helper function to unlock all buffers.
- **/
-static void isp_af_unlock_buffers(struct isp_af_device *isp_af)
-{
-	int i;
-	unsigned long irqflags;
-
-	spin_lock_irqsave(&isp_af->buffer_lock, irqflags);
-	for (i = 0; i < H3A_MAX_BUFF; i++)
-		isp_af->af_buff[i].locked = 0;
-
-	spin_unlock_irqrestore(&isp_af->buffer_lock, irqflags);
-}
-
-/*
- * Helper function to link allocated buffers
- */
-static void isp_af_link_buffers(struct isp_af_device *isp_af)
-{
-	int i;
-
-	for (i = 0; i < H3A_MAX_BUFF; i++) {
-		if ((i + 1) < H3A_MAX_BUFF)
-			isp_af->af_buff[i].next = &isp_af->af_buff[i + 1];
-		else
-			isp_af->af_buff[i].next = &isp_af->af_buff[0];
-	}
-}
-
-/* Function to perform hardware set up */
-int isp_af_configure(struct isp_af_device *isp_af,
-		     struct af_configuration *afconfig)
-{
-	int result;
-	int buff_size, i;
-	unsigned int busyaf;
-	struct af_configuration *af_curr_cfg = &isp_af->config;
-
-	if (NULL == afconfig) {
-		dev_err(isp_af->dev, "af: Null argument in configuration. \n");
-		return -EINVAL;
-	}
-
-	memcpy(af_curr_cfg, afconfig, sizeof(struct af_configuration));
-	/* Get the value of PCR register */
-	busyaf = isp_reg_readl(isp_af->dev, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR);
-
-	if ((busyaf & AF_BUSYAF) == AF_BUSYAF) {
-		DPRINTK_ISP_AF("AF_register_setup_ERROR : Engine Busy");
-		DPRINTK_ISP_AF("\n Configuration cannot be done ");
-		return -AF_ERR_ENGINE_BUSY;
-	}
-
-	/* Check IIR Coefficient and start Values */
-	result = isp_af_check_iir(isp_af);
-	if (result < 0)
-		return result;
-
-	/* Check Paxel Values */
-	result = isp_af_check_paxel(isp_af);
-	if (result < 0)
-		return result;
 
 	/* Check HMF Threshold Values */
-	if (af_curr_cfg->hmf_config.threshold > AF_THRESHOLD_MAX) {
-		DPRINTK_ISP_AF("Error : HMF Threshold is incorrect");
+	if (afconfig->hmf_config.threshold > AF_THRESHOLD_MAX)
 		return -AF_ERR_THRESHOLD;
-	}
-
-	/* Compute buffer size */
-	buff_size = (af_curr_cfg->paxel_config.hz_cnt + 1) *
-		(af_curr_cfg->paxel_config.vt_cnt + 1) * AF_PAXEL_SIZE;
-
-	isp_af->curr_cfg_buf_size = buff_size;
-	/* Deallocate the previous buffers */
-	if (isp_af->stats_buf_size && buff_size > isp_af->stats_buf_size) {
-		isp_af_enable(isp_af, 0);
-		for (i = 0; i < H3A_MAX_BUFF; i++) {
-			ispmmu_kunmap(isp_af->af_buff[i].ispmmu_addr);
-			dma_free_coherent(
-				NULL, isp_af->min_buf_size,
-				(void *)isp_af->af_buff[i].virt_addr,
-				(dma_addr_t)isp_af->af_buff[i].phy_addr);
-			isp_af->af_buff[i].virt_addr = 0;
-		}
-		isp_af->stats_buf_size = 0;
-	}
-
-	if (!isp_af->af_buff[0].virt_addr) {
-		isp_af->stats_buf_size = buff_size;
-		isp_af->min_buf_size = PAGE_ALIGN(isp_af->stats_buf_size);
-
-		for (i = 0; i < H3A_MAX_BUFF; i++) {
-			isp_af->af_buff[i].virt_addr =
-				(unsigned long)dma_alloc_coherent(
-					NULL,
-					isp_af->min_buf_size,
-					(dma_addr_t *)
-					&isp_af->af_buff[i].phy_addr,
-					GFP_KERNEL | GFP_DMA);
-			if (isp_af->af_buff[i].virt_addr == 0) {
-				dev_err(isp_af->dev,
-					"af: Can't acquire memory for "
-					"buffer[%d]\n", i);
-				return -ENOMEM;
-			}
-			isp_af->af_buff[i].addr_align =
-				isp_af->af_buff[i].virt_addr;
-			while ((isp_af->af_buff[i].addr_align & 0xFFFFFFC0) !=
-			       isp_af->af_buff[i].addr_align)
-				isp_af->af_buff[i].addr_align++;
-			isp_af->af_buff[i].ispmmu_addr =
-				ispmmu_kmap(isp_af->af_buff[i].phy_addr,
-					    isp_af->min_buf_size);
-		}
-		isp_af_unlock_buffers(isp_af);
-		isp_af_link_buffers(isp_af);
-
-		/* First active buffer */
-		if (isp_af->active_buff == NULL)
-			isp_af->active_buff = &isp_af->af_buff[0];
-		isp_af_set_address(isp_af, isp_af->active_buff->ispmmu_addr);
-	}
-
-	result = isp_af_register_setup(isp_af);
-	if (result < 0)
-		return result;
-	isp_af->size_paxel = buff_size;
-	atomic_inc(&isp_af->config_counter);
-	isp_af->initialized = 1;
-	isp_af->frame_count = 1;
-	isp_af->active_buff->frame_num = 1;
-	/* Set configuration flag to indicate HW setup done */
-	if (af_curr_cfg->af_config)
-		isp_af_enable(isp_af, 1);
-	else
-		isp_af_enable(isp_af, 0);
 
-	/* Success */
 	return 0;
 }
-EXPORT_SYMBOL(isp_af_configure);
 
-int isp_af_register_setup(struct isp_af_device *isp_af)
+void isp_af_config_registers(struct isp_af_device *isp_af)
 {
+	struct device *dev = to_device(isp_af);
 	unsigned int pcr = 0, pax1 = 0, pax2 = 0, paxstart = 0;
 	unsigned int coef = 0;
 	unsigned int base_coef_set0 = 0;
 	unsigned int base_coef_set1 = 0;
 	int index;
+	unsigned long irqflags;
 
-	/* Configure Hardware Registers */
-	/* Read PCR Register */
-	pcr = isp_reg_readl(isp_af->dev, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR);
-
-	/* Set Accumulator Mode */
-	if (isp_af->config.mode == ACCUMULATOR_PEAK)
-		pcr |= FVMODE;
-	else
-		pcr &= ~FVMODE;
-
-	/* Set A-law */
-	if (isp_af->config.alaw_enable == H3A_AF_ALAW_ENABLE)
-		pcr |= AF_ALAW_EN;
-	else
-		pcr &= ~AF_ALAW_EN;
-
-	/* Set RGB Position */
-	pcr &= ~RGBPOS;
-	pcr |= isp_af->config.rgb_pos << AF_RGBPOS_SHIFT;
+	if (!isp_af->config.af_config)
+		return;
 
-	/* HMF Configurations */
-	if (isp_af->config.hmf_config.enable == H3A_AF_HMF_ENABLE) {
-		pcr &= ~AF_MED_EN;
-		/* Enable HMF */
-		pcr |= AF_MED_EN;
+	spin_lock_irqsave(isp_af->lock, irqflags);
 
-		/* Set Median Threshold */
-		pcr &= ~MED_TH;
-		pcr |= isp_af->config.hmf_config.threshold << AF_MED_TH_SHIFT;
-	} else
-		pcr &= ~AF_MED_EN;
+	isp_reg_writel(dev, isp_af->buf_next->iommu_addr, OMAP3_ISP_IOMEM_H3A,
+		       ISPH3A_AFBUFST);
 
-	/* Set PCR Register */
-	isp_reg_writel(isp_af->dev, pcr, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR);
+	if (!isp_af->update) {
+		spin_unlock_irqrestore(isp_af->lock, irqflags);
+		return;
+	}
 
-	pax1 &= ~PAXW;
+	/* Configure Hardware Registers */
 	pax1 |= isp_af->config.paxel_config.width << AF_PAXW_SHIFT;
-
 	/* Set height in AFPAX1 */
-	pax1 &= ~PAXH;
 	pax1 |= isp_af->config.paxel_config.height;
-
-	isp_reg_writel(isp_af->dev, pax1, OMAP3_ISP_IOMEM_H3A, ISPH3A_AFPAX1);
+	isp_reg_writel(dev, pax1, OMAP3_ISP_IOMEM_H3A, ISPH3A_AFPAX1);
 
 	/* Configure AFPAX2 Register */
 	/* Set Line Increment in AFPAX2 Register */
-	pax2 &= ~AFINCV;
 	pax2 |= isp_af->config.paxel_config.line_incr << AF_LINE_INCR_SHIFT;
 	/* Set Vertical Count */
-	pax2 &= ~PAXVC;
 	pax2 |= isp_af->config.paxel_config.vt_cnt << AF_VT_COUNT_SHIFT;
 	/* Set Horizontal Count */
-	pax2 &= ~PAXHC;
 	pax2 |= isp_af->config.paxel_config.hz_cnt;
-	isp_reg_writel(isp_af->dev, pax2, OMAP3_ISP_IOMEM_H3A, ISPH3A_AFPAX2);
+	isp_reg_writel(dev, pax2, OMAP3_ISP_IOMEM_H3A, ISPH3A_AFPAX2);
 
 	/* Configure PAXSTART Register */
 	/*Configure Horizontal Start */
-	paxstart &= ~PAXSH;
 	paxstart |= isp_af->config.paxel_config.hz_start << AF_HZ_START_SHIFT;
 	/* Configure Vertical Start */
-	paxstart &= ~PAXSV;
 	paxstart |= isp_af->config.paxel_config.vt_start;
-	isp_reg_writel(isp_af->dev, paxstart, OMAP3_ISP_IOMEM_H3A,
+	isp_reg_writel(dev, paxstart, OMAP3_ISP_IOMEM_H3A,
 		       ISPH3A_AFPAXSTART);
 
 	/*SetIIRSH Register */
-	isp_reg_writel(isp_af->dev, isp_af->config.iir_config.hz_start_pos,
+	isp_reg_writel(dev, isp_af->config.iir_config.hz_start_pos,
 		       OMAP3_ISP_IOMEM_H3A, ISPH3A_AFIIRSH);
 
-	/*Set IIR Filter0 Coefficients */
 	base_coef_set0 = ISPH3A_AFCOEF010;
+	base_coef_set1 = ISPH3A_AFCOEF110;
 	for (index = 0; index <= 8; index += 2) {
-		coef &= ~COEF_MASK0;
+		/*Set IIR Filter0 Coefficients */
+		coef = 0;
 		coef |= isp_af->config.iir_config.coeff_set0[index];
-		coef &= ~COEF_MASK1;
 		coef |= isp_af->config.iir_config.coeff_set0[index + 1] <<
 			AF_COEF_SHIFT;
-		isp_reg_writel(isp_af->dev, coef, OMAP3_ISP_IOMEM_H3A,
+		isp_reg_writel(dev, coef, OMAP3_ISP_IOMEM_H3A,
 			       base_coef_set0);
-		base_coef_set0 = base_coef_set0 + AFCOEF_OFFSET;
-	}
-
-	/* set AFCOEF0010 Register */
-	isp_reg_writel(isp_af->dev, isp_af->config.iir_config.coeff_set0[10],
-		       OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF010);
-
-	/*Set IIR Filter1 Coefficients */
+		base_coef_set0 += AFCOEF_OFFSET;
 
-	base_coef_set1 = ISPH3A_AFCOEF110;
-	for (index = 0; index <= 8; index += 2) {
-		coef &= ~COEF_MASK0;
+		/*Set IIR Filter1 Coefficients */
+		coef = 0;
 		coef |= isp_af->config.iir_config.coeff_set1[index];
-		coef &= ~COEF_MASK1;
 		coef |= isp_af->config.iir_config.coeff_set1[index + 1] <<
 			AF_COEF_SHIFT;
-		isp_reg_writel(isp_af->dev, coef, OMAP3_ISP_IOMEM_H3A,
+		isp_reg_writel(dev, coef, OMAP3_ISP_IOMEM_H3A,
 			       base_coef_set1);
-
-		base_coef_set1 = base_coef_set1 + AFCOEF_OFFSET;
+		base_coef_set1 += AFCOEF_OFFSET;
 	}
-	isp_reg_writel(isp_af->dev, isp_af->config.iir_config.coeff_set1[10],
+	/* set AFCOEF0010 Register */
+	isp_reg_writel(dev, isp_af->config.iir_config.coeff_set0[10],
+		       OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF0010);
+	/* set AFCOEF1010 Register */
+	isp_reg_writel(dev, isp_af->config.iir_config.coeff_set1[10],
 		       OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF1010);
 
-	return 0;
+	/* PCR Register */
+	/* Set Accumulator Mode */
+	if (isp_af->config.mode == ACCUMULATOR_PEAK)
+		pcr |= FVMODE;
+	/* Set A-law */
+	if (isp_af->config.alaw_enable == H3A_AF_ALAW_ENABLE)
+		pcr |= AF_ALAW_EN;
+	/* Set RGB Position */
+	pcr |= isp_af->config.rgb_pos << AF_RGBPOS_SHIFT;
+	/* HMF Configurations */
+	if (isp_af->config.hmf_config.enable == H3A_AF_HMF_ENABLE) {
+		/* Enable HMF */
+		pcr |= AF_MED_EN;
+		/* Set Median Threshold */
+		pcr |= isp_af->config.hmf_config.threshold << AF_MED_TH_SHIFT;
+	}
+	/* Set PCR Register */
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR,
+		       ~AF_PCR_MASK, pcr);
+
+	isp_af->update = 0;
+
+	spin_unlock_irqrestore(isp_af->lock, irqflags);
 }
 
-/* Function to set address */
-void isp_af_set_address(struct isp_af_device *isp_af, unsigned long address)
+/* Update local parameters */
+static void isp_af_update_params(struct isp_af_device *isp_af,
+				 struct af_configuration *afconfig)
 {
-	isp_reg_writel(isp_af->dev, address, OMAP3_ISP_IOMEM_H3A,
-		       ISPH3A_AFBUFST);
+	int update = 0;
+	int index;
+
+	/* alaw */
+	if (isp_af->config.alaw_enable != afconfig->alaw_enable) {
+		update = 1;
+		goto out;
+	}
+
+	/* hmf */
+	if (isp_af->config.hmf_config.enable != afconfig->hmf_config.enable) {
+		update = 1;
+		goto out;
+	}
+	if (isp_af->config.hmf_config.threshold !=
+					afconfig->hmf_config.threshold) {
+		update = 1;
+		goto out;
+	}
+
+	/* rgbpos */
+	if (isp_af->config.rgb_pos != afconfig->rgb_pos) {
+		update = 1;
+		goto out;
+	}
+
+	/* iir */
+	if (isp_af->config.iir_config.hz_start_pos !=
+					afconfig->iir_config.hz_start_pos) {
+		update = 1;
+		goto out;
+	}
+	for (index = 0; index < AF_NUMBER_OF_COEF; index++) {
+		if (isp_af->config.iir_config.coeff_set0[index] !=
+				afconfig->iir_config.coeff_set0[index]) {
+			update = 1;
+			goto out;
+		}
+		if (isp_af->config.iir_config.coeff_set1[index] !=
+				afconfig->iir_config.coeff_set1[index]) {
+			update = 1;
+			goto out;
+		}
+	}
+
+	/* paxel */
+	if ((isp_af->config.paxel_config.width !=
+				afconfig->paxel_config.width) ||
+	    (isp_af->config.paxel_config.height !=
+				afconfig->paxel_config.height) ||
+	    (isp_af->config.paxel_config.hz_start !=
+				afconfig->paxel_config.hz_start) ||
+	    (isp_af->config.paxel_config.vt_start !=
+				afconfig->paxel_config.vt_start) ||
+	    (isp_af->config.paxel_config.hz_cnt !=
+				afconfig->paxel_config.hz_cnt) ||
+	    (isp_af->config.paxel_config.line_incr !=
+				afconfig->paxel_config.line_incr)) {
+		update = 1;
+		goto out;
+	}
+
+	/* af_mode */
+	if (isp_af->config.mode != afconfig->mode) {
+		update = 1;
+		goto out;
+	}
+
+	isp_af->config.af_config = afconfig->af_config;
+
+out:
+	if (update) {
+		memcpy(&isp_af->config, afconfig, sizeof(*afconfig));
+		isp_af->update = 1;
+	}
 }
 
-static int isp_af_stats_available(struct isp_af_device *isp_af,
-				  struct isp_af_data *afdata)
+void isp_af_try_enable(struct isp_af_device *isp_af)
 {
-	int i, ret;
 	unsigned long irqflags;
 
-	spin_lock_irqsave(&isp_af->buffer_lock, irqflags);
-	for (i = 0; i < H3A_MAX_BUFF; i++) {
-		DPRINTK_ISP_AF("Checking Stats buff[%d] (%d) for %d\n",
-			       i, isp_af->af_buff[i].frame_num,
-			       afdata->frame_number);
-		if (afdata->frame_number == isp_af->af_buff[i].frame_num
-		    && isp_af->af_buff[i].frame_num !=
-					isp_af->active_buff->frame_num) {
-			isp_af->af_buff[i].locked = 1;
-			spin_unlock_irqrestore(&isp_af->buffer_lock, irqflags);
-			isp_af_update_req_buffer(isp_af, &isp_af->af_buff[i]);
-			isp_af->af_buff[i].frame_num = 0;
-			ret = copy_to_user((void *)afdata->af_statistics_buf,
-					   (void *)isp_af->af_buff[i].virt_addr,
-					   isp_af->curr_cfg_buf_size);
-			if (ret) {
-				dev_err(isp_af->dev,
-					"af: Failed copy_to_user for "
-					"H3A stats buff, %d\n", ret);
-			}
-			afdata->xtrastats.ts = isp_af->af_buff[i].xtrastats.ts;
-			afdata->xtrastats.field_count =
-				isp_af->af_buff[i].xtrastats.field_count;
-			return 0;
-		}
-	}
-	spin_unlock_irqrestore(&isp_af->buffer_lock, irqflags);
-	/* Stats unavailable */
+	if (!isp_af->config.af_config)
+		return;
 
-	return -1;
+	spin_lock_irqsave(isp_af->lock, irqflags);
+	if (unlikely(!isp_af->enabled && isp_af->config.af_config)) {
+		isp_af->update = 1;
+		isp_af->buf_next = ispstat_buf_next(&isp_af->stat);
+		spin_unlock_irqrestore(isp_af->lock, irqflags);
+		isp_af_config_registers(isp_af);
+		isp_af_enable(isp_af, 1);
+	} else
+		spin_unlock_irqrestore(isp_af->lock, irqflags);
 }
 
-void isp_af_notify(struct isp_af_device *isp_af, int notify)
+/* Function to perform hardware set up */
+int omap34xx_isp_af_config(struct isp_af_device *isp_af,
+			   struct af_configuration *afconfig)
 {
-	isp_af->camnotify = notify;
-	if (isp_af->camnotify && isp_af->initialized) {
-		printk(KERN_DEBUG "Warning Camera Off \n");
-		isp_af->stats_req = 0;
-		isp_af->stats_done = 1;
-		wake_up_interruptible(&isp_af->stats_wait);
+	struct device *dev = to_device(isp_af);
+	int result;
+	int buf_size;
+	unsigned long irqflags;
+
+	if (!afconfig) {
+		dev_dbg(dev, "af: Null argument in configuration.\n");
+		return -EINVAL;
+	}
+
+	/* Check Parameters */
+	spin_lock_irqsave(isp_af->lock, irqflags);
+	result = isp_af_check_params(isp_af, afconfig);
+	spin_unlock_irqrestore(isp_af->lock, irqflags);
+	if (result) {
+		dev_dbg(dev, "af: wrong configure params received.\n");
+		return result;
 	}
+
+	/* Compute buffer size */
+	buf_size = (afconfig->paxel_config.hz_cnt + 1) *
+		   (afconfig->paxel_config.vt_cnt + 1) * AF_PAXEL_SIZE;
+
+	result = ispstat_bufs_alloc(&isp_af->stat, buf_size, 0);
+	if (result)
+		return result;
+
+	spin_lock_irqsave(isp_af->lock, irqflags);
+	isp_af_update_params(isp_af, afconfig);
+	spin_unlock_irqrestore(isp_af->lock, irqflags);
+
+	/* Success */
+	return 0;
 }
-EXPORT_SYMBOL(isp_af_notify);
+EXPORT_SYMBOL(omap34xx_isp_af_config);
+
 /*
  * This API allows the user to update White Balance gains, as well as
  * exposure time and analog gain. It is also used to request frame
  * statistics.
  */
-int isp_af_request_statistics(struct isp_af_device *isp_af,
+int omap34xx_isp_af_request_statistics(struct isp_af_device *isp_af,
 			      struct isp_af_data *afdata)
 {
-	int ret = 0;
-	u16 frame_diff = 0;
-	u16 frame_cnt = isp_af->frame_count;
-	wait_queue_t wqt;
+	struct device *dev = to_device(isp_af);
+	struct ispstat_buffer *buf;
 
 	if (!isp_af->config.af_config) {
-		dev_err(isp_af->dev, "af: engine not enabled\n");
+		dev_dbg(dev, "af: statistics requested while af engine"
+			     " is not configured\n");
 		return -EINVAL;
 	}
 
-	if (!(afdata->update & REQUEST_STATISTICS)) {
-		afdata->af_statistics_buf = NULL;
-		goto out;
-	}
-
-	isp_af_unlock_buffers(isp_af);
-	/* Stats available? */
-	DPRINTK_ISP_AF("Stats available?\n");
-	ret = isp_af_stats_available(isp_af, afdata);
-	if (!ret)
-		goto out;
-
-	/* Stats in near future? */
-	DPRINTK_ISP_AF("Stats in near future?\n");
-	if (afdata->frame_number > frame_cnt)
-		frame_diff = afdata->frame_number - frame_cnt;
-	else if (afdata->frame_number < frame_cnt) {
-		if (frame_cnt > MAX_FRAME_COUNT - MAX_FUTURE_FRAMES
-		    && afdata->frame_number < MAX_FRAME_COUNT) {
-			frame_diff = afdata->frame_number + MAX_FRAME_COUNT -
-				frame_cnt;
-		} else {
-			/* Frame unavailable */
-			frame_diff = MAX_FUTURE_FRAMES + 1;
-		}
-	}
+	if (afdata->update & REQUEST_STATISTICS) {
+		buf = ispstat_buf_get(&isp_af->stat,
+			      (void *)afdata->af_statistics_buf,
+			      afdata->frame_number);
+		if (IS_ERR(buf))
+			return PTR_ERR(buf);
 
-	if (frame_diff > MAX_FUTURE_FRAMES) {
-		dev_err(isp_af->dev,
-			"af: Invalid frame requested, returning current"
-			" frame stats\n");
-		afdata->frame_number = frame_cnt;
-	}
-	if (!isp_af->camnotify) {
-		/* Block until frame in near future completes */
-		isp_af->frame_req = afdata->frame_number;
-		isp_af->stats_req = 1;
-		isp_af->stats_done = 0;
-		init_waitqueue_entry(&wqt, current);
-		ret = wait_event_interruptible(isp_af->stats_wait,
-					       isp_af->stats_done == 1);
-		if (ret < 0) {
-			afdata->af_statistics_buf = NULL;
-			return ret;
-		}
-		DPRINTK_ISP_AF("ISP AF request status interrupt raised\n");
+		afdata->xtrastats.ts = buf->ts;
+		afdata->config_counter = buf->config_counter;
+		afdata->frame_number = buf->frame_number;
 
-		/* Stats now available */
-		ret = isp_af_stats_available(isp_af, afdata);
-		if (ret) {
-			dev_err(isp_af->dev,
-				"af: After waiting for stats, stats not"
-				" available!!\n");
-			afdata->af_statistics_buf = NULL;
-		}
+		ispstat_buf_release(&isp_af->stat);
 	}
 
-out:
-	afdata->curr_frame = isp_af->frame_count;
+	afdata->curr_frame = isp_af->stat.frame_number;
 
 	return 0;
 }
-EXPORT_SYMBOL(isp_af_request_statistics);
+EXPORT_SYMBOL(omap34xx_isp_af_request_statistics);
 
-/* This function will handle the H3A interrupt. */
-static void isp_af_isr(unsigned long status, isp_vbq_callback_ptr arg1,
-		       void *arg2)
+/* This function will handle the AF buffer. */
+int isp_af_buf_process(struct isp_af_device *isp_af)
 {
-	struct isp_af_device *isp_af = (struct isp_af_device *)arg2;
-	u16 frame_align;
-
-	if ((H3A_AF_DONE & status) != H3A_AF_DONE)
-		return;
+	if (likely(!isp_af->buf_err && isp_af->config.af_config)) {
+		int ret;
 
-	/* timestamp stats buffer */
-	do_gettimeofday(&isp_af->active_buff->xtrastats.ts);
-	isp_af->active_buff->config_counter =
-				atomic_read(&isp_af->config_counter);
-
-	/* Exchange buffers */
-	isp_af->active_buff = isp_af->active_buff->next;
-	if (isp_af->active_buff->locked == 1)
-		isp_af->active_buff = isp_af->active_buff->next;
-	isp_af_set_address(isp_af, isp_af->active_buff->ispmmu_addr);
-
-	/* Update frame counter */
-	isp_af->frame_count++;
-	frame_align = isp_af->frame_count;
-	if (isp_af->frame_count > MAX_FRAME_COUNT) {
-		isp_af->frame_count = 1;
-		frame_align++;
-	}
-	isp_af->active_buff->frame_num = isp_af->frame_count;
-
-	/* Future Stats requested? */
-	if (isp_af->stats_req) {
-		/* Is the frame we want already done? */
-		if (frame_align >= isp_af->frame_req + 1) {
-			isp_af->stats_req = 0;
-			isp_af->stats_done = 1;
-			wake_up_interruptible(&isp_af->stats_wait);
-		}
+		ret = ispstat_buf_queue(&isp_af->stat);
+		isp_af->buf_next = ispstat_buf_next(&isp_af->stat);
+		return ret;
+	} else {
+		isp_af->buf_err = 0;
+		return -1;
 	}
 }
 
-int __isp_af_enable(struct isp_af_device *isp_af, int enable)
+static void __isp_af_enable(struct isp_af_device *isp_af, int enable)
 {
+	struct device *dev = to_device(isp_af);
 	unsigned int pcr;
 
-	pcr = isp_reg_readl(isp_af->dev, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR);
+	pcr = isp_reg_readl(dev, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR);
 
 	/* Set AF_EN bit in PCR Register */
-	if (enable) {
-		if (isp_set_callback(isp_af->dev, CBK_H3A_AF_DONE, isp_af_isr,
-				     (void *)NULL, isp_af)) {
-			dev_err(isp_af->dev, "af: No callback for AF\n");
-			return -EINVAL;
-		}
-
+	if (enable)
 		pcr |= AF_EN;
-	} else {
-		isp_unset_callback(isp_af->dev, CBK_H3A_AF_DONE);
+	else
 		pcr &= ~AF_EN;
-	}
-	isp_reg_writel(isp_af->dev, pcr, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR);
-	return 0;
+
+	isp_reg_writel(dev, pcr, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR);
 }
 
 /* Function to Enable/Disable AF Engine */
-int isp_af_enable(struct isp_af_device *isp_af, int enable)
+void isp_af_enable(struct isp_af_device *isp_af, int enable)
 {
-	int rval;
+	unsigned long irqflags;
 
-	rval = __isp_af_enable(isp_af, enable);
+	spin_lock_irqsave(isp_af->lock, irqflags);
 
-	if (!rval)
-		isp_af->pm_state = enable;
+	if (!isp_af->config.af_config && enable) {
+		spin_unlock_irqrestore(isp_af->lock, irqflags);
+		return;
+	}
+
+	__isp_af_enable(isp_af, enable);
+	isp_af->enabled = enable;
 
-	return rval;
+	spin_unlock_irqrestore(isp_af->lock, irqflags);
 }
 
 /* Function to Suspend AF Engine */
 void isp_af_suspend(struct isp_af_device *isp_af)
 {
-	if (isp_af->pm_state)
+	unsigned long irqflags;
+
+	spin_lock_irqsave(isp_af->lock, irqflags);
+	if (isp_af->enabled)
 		__isp_af_enable(isp_af, 0);
+	spin_unlock_irqrestore(isp_af->lock, irqflags);
 }
 
 /* Function to Resume AF Engine */
 void isp_af_resume(struct isp_af_device *isp_af)
 {
-	if (isp_af->pm_state)
+	unsigned long irqflags;
+
+	spin_lock_irqsave(isp_af->lock, irqflags);
+	if (isp_af->enabled)
 		__isp_af_enable(isp_af, 1);
+	spin_unlock_irqrestore(isp_af->lock, irqflags);
 }
 
 int isp_af_busy(struct isp_af_device *isp_af)
 {
-	return isp_reg_readl(isp_af->dev, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR)
+	struct device *dev = to_device(isp_af);
+
+	return isp_reg_readl(dev, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR)
 		& ISPH3A_PCR_BUSYAF;
 }
 
@@ -687,11 +459,8 @@ int __init isp_af_init(struct device *de
 	struct isp_device *isp = dev_get_drvdata(dev);
 	struct isp_af_device *isp_af = &isp->isp_af;
 
-	isp_af->active_buff = NULL;
-	isp_af->dev = dev;
-
-	init_waitqueue_head(&isp_af->stats_wait);
-	spin_lock_init(&isp_af->buffer_lock);
+	isp_af->lock = &isp->h3a_lock;
+	ispstat_init(dev, "AF", &isp_af->stat, H3A_MAX_BUFF, MAX_FRAME_COUNT);
 
 	return 0;
 }
@@ -699,19 +468,7 @@ int __init isp_af_init(struct device *de
 void isp_af_exit(struct device *dev)
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
-	struct isp_af_device *isp_af = &isp->isp_af;
-	int i;
 
 	/* Free buffers */
-	for (i = 0; i < H3A_MAX_BUFF; i++) {
-		if (!isp_af->af_buff[i].phy_addr)
-			continue;
-
-		ispmmu_kunmap(isp_af->af_buff[i].ispmmu_addr);
-
-		dma_free_coherent(NULL,
-				  isp_af->min_buf_size,
-				  (void *)isp_af->af_buff[i].virt_addr,
-				  (dma_addr_t)isp_af->af_buff[i].phy_addr);
-	}
+	ispstat_free(&isp->isp_af.stat);
 }
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isp_af.h kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isp_af.h
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isp_af.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isp_af.h	2012-12-16 13:13:01.660330147 +0100
@@ -25,6 +25,7 @@
 #include <mach/isp_user.h>
 
 #include "isph3a.h"
+#include "ispstat.h"
 
 #define AF_MAJOR_NUMBER			0
 #define ISPAF_NAME			"OMAPISP_AF"
@@ -66,6 +67,8 @@
 #define AF_MED_EN			(1 << 2)
 #define AF_ALAW_EN			(1 << 1)
 #define AF_EN				(1 << 0)
+#define AF_PCR_MASK			(FVMODE | RGBPOS | MED_TH | \
+					 AF_MED_EN | AF_ALAW_EN)
 
 /*
  * AFPAX1 fields
@@ -107,84 +110,29 @@
 #define AF_UPDATEXS_LENSPOS		(1 << 2)
 
 /**
- * struct isp_af_buffer - AF frame stats buffer.
- * @virt_addr: Virtual address to mmap the buffer.
- * @phy_addr: Physical address of the buffer.
- * @addr_align: Virtual Address 32 bytes aligned.
- * @ispmmu_addr: Address of the buffer mapped by the ISPMMU.
- * @mmap_addr: Mapped memory area of buffer. For userspace access.
- * @locked: 1 - Buffer locked from write. 0 - Buffer can be overwritten.
- * @frame_num: Frame number from which the statistics are taken.
- * @lens_position: Lens position currently set in the DW9710 Coil motor driver.
- * @next: Pointer to link next buffer.
- */
-struct isp_af_buffer {
-	unsigned long virt_addr;
-	unsigned long phy_addr;
-	unsigned long addr_align;
-	unsigned long ispmmu_addr;
-	unsigned long mmap_addr;
-
-	u8 locked;
-	u16 frame_num;
-	u32 config_counter;
-	struct isp_af_xtrastats xtrastats;
-	struct isp_af_buffer *next;
-};
-
-/**
  * struct isp_af_status - AF status.
- * @initialized: 1 - Buffers initialized.
  * @update: 1 - Update registers.
- * @stats_req: 1 - Future stats requested.
- * @stats_done: 1 - Stats ready for user.
- * @frame_req: Number of frame requested for statistics.
- * @af_buff: Array of statistics buffers to access.
- * @stats_buf_size: Statistics buffer size.
- * @curr_cfg_buf_size: Current user configured stats buff size.
- * @min_buf_size: Minimum statisitics buffer size.
- * @frame_count: Frame Count.
- * @stats_wait: Wait primitive for locking/unlocking the stats request.
- * @buffer_lock: Spinlock for statistics buffers access.
  */
 struct isp_af_device {
-	u8 initialized;
 	u8 update;
-	u8 stats_req;
-	u8 stats_done;
-	u16 frame_req;
-
-	struct isp_af_buffer af_buff[H3A_MAX_BUFF];
-	unsigned int active_buffer;
-	unsigned int stats_buf_size;
-	unsigned int min_buf_size;
-	unsigned int curr_cfg_buf_size;
-	struct isp_af_buffer *active_buff;
-
-	int pm_state;
-	u32 frame_count;
-	wait_queue_head_t stats_wait;
-	atomic_t config_counter;
-	spinlock_t buffer_lock;		/* For stats buffers read/write sync */
-	struct device *dev;
-	int camnotify;
-
+	u8 buf_err;
+	int enabled;
+	struct ispstat stat;
 	struct af_configuration config; /*Device configuration structure */
-	int size_paxel;         /*Paxel size in bytes */
+	struct ispstat_buffer *buf_next;
+	spinlock_t *lock;
 };
 
-int isp_af_check_paxel(struct isp_af_device *);
-int isp_af_check_iir(struct isp_af_device *);
-int isp_af_register_setup(struct isp_af_device *);
-int isp_af_enable(struct isp_af_device *, int);
+int isp_af_buf_process(struct isp_af_device *isp_af);
+void isp_af_enable(struct isp_af_device *, int);
+void isp_af_try_enable(struct isp_af_device *isp_af);
 void isp_af_suspend(struct isp_af_device *);
 void isp_af_resume(struct isp_af_device *);
 int isp_af_busy(struct isp_af_device *);
-void isp_af_notify(struct isp_af_device *, int notify);
-int isp_af_request_statistics(struct isp_af_device *,
-			      struct isp_af_data *afdata);
-int isp_af_configure(struct isp_af_device *, struct af_configuration *afconfig);
-void isp_af_set_address(struct isp_af_device *, unsigned long);
-void isp_af_setxtrastats(struct isp_af_device *,
-			 struct isp_af_xtrastats *xtrastats, u8 updateflag);
+void isp_af_config_registers(struct isp_af_device *isp_af);
+int omap34xx_isp_af_request_statistics(struct isp_af_device *,
+				       struct isp_af_data *afdata);
+int omap34xx_isp_af_config(struct isp_af_device *,
+			   struct af_configuration *afconfig);
+
 #endif	/* OMAP_ISP_AF_H */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isp.c kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isp.c
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isp.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isp.c	2012-12-16 13:13:01.664330147 +0100
@@ -35,7 +35,6 @@
 #include <linux/device.h>
 
 #include "isp.h"
-#include "ispmmu.h"
 #include "ispreg.h"
 #include "ispccdc.h"
 #include "isph3a.h"
@@ -47,9 +46,6 @@
 
 static struct platform_device *omap3isp_pdev;
 
-static int isp_try_size(struct device *dev, struct v4l2_pix_format *pix_input,
-			struct v4l2_pix_format *pix_output);
-
 static void isp_save_ctx(struct device *dev);
 
 static void isp_restore_ctx(struct device *dev);
@@ -166,50 +162,11 @@ static struct isp_reg isp_reg_list[] = {
 	{0, ISP_TOK_TERM, 0}
 };
 
-u32 isp_reg_readl(struct device *dev, enum isp_mem_resources isp_mmio_range,
-		  u32 reg_offset)
-{
-	struct isp_device *isp = dev_get_drvdata(dev);
-
-	return __raw_readl(isp->mmio_base[isp_mmio_range] + reg_offset);
-}
-EXPORT_SYMBOL(isp_reg_readl);
-
-void isp_reg_writel(struct device *dev, u32 reg_value,
-		    enum isp_mem_resources isp_mmio_range, u32 reg_offset)
-{
-	struct isp_device *isp = dev_get_drvdata(dev);
-
-	__raw_writel(reg_value, isp->mmio_base[isp_mmio_range] + reg_offset);
-}
-EXPORT_SYMBOL(isp_reg_writel);
-
-void isp_reg_and(struct device *dev, enum isp_mem_resources mmio_range, u32 reg,
-		 u32 and_bits)
+void isp_flush(struct device *dev)
 {
-	u32 v = isp_reg_readl(dev, mmio_range, reg);
-
-	isp_reg_writel(dev, v & and_bits, mmio_range, reg);
+	isp_reg_writel(dev, 0, OMAP3_ISP_IOMEM_MAIN, ISP_REVISION);
+	isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN, ISP_REVISION);
 }
-EXPORT_SYMBOL(isp_reg_and);
-
-void isp_reg_or(struct device *dev, enum isp_mem_resources mmio_range, u32 reg,
-		u32 or_bits)
-{
-	u32 v = isp_reg_readl(dev, mmio_range, reg);
-
-	isp_reg_writel(dev, v | or_bits, mmio_range, reg);
-}
-EXPORT_SYMBOL(isp_reg_or);
-
-void isp_reg_and_or(struct device *dev, enum isp_mem_resources mmio_range,
-		    u32 reg, u32 and_bits, u32 or_bits)
-{
-	u32 v = isp_reg_readl(dev, mmio_range, reg);
-
-	isp_reg_writel(dev, (v & and_bits) | or_bits, mmio_range, reg);
-}
-EXPORT_SYMBOL(isp_reg_and_or);
 
 /*
  *
@@ -292,13 +249,13 @@ static void isp_release_resources(struct
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
 
-	if (isp->module.isp_pipeline & OMAP_ISP_CCDC)
+	if (isp->pipeline.modules & OMAP_ISP_CCDC)
 		ispccdc_free(&isp->isp_ccdc);
 
-	if (isp->module.isp_pipeline & OMAP_ISP_PREVIEW)
+	if (isp->pipeline.modules & OMAP_ISP_PREVIEW)
 		isppreview_free(&isp->isp_prev);
 
-	if (isp->module.isp_pipeline & OMAP_ISP_RESIZER)
+	if (isp->pipeline.modules & OMAP_ISP_RESIZER)
 		ispresizer_free(&isp->isp_res);
 	return;
 }
@@ -316,10 +273,8 @@ static int isp_wait(struct device *dev,
 		rmb();
 		udelay(1);
 		wait++;
-		if (wait > max_wait) {
-			dev_alert(dev, "%s: wait is too much\n", __func__);
+		if (wait > max_wait)
 			return -EBUSY;
-		}
 	}
 	DPRINTK_ISPCTRL(KERN_ALERT "%s: wait %d\n", __func__, wait);
 
@@ -328,38 +283,34 @@ static int isp_wait(struct device *dev,
 
 static int ispccdc_sbl_wait_idle(struct isp_ccdc_device *isp_ccdc, int max_wait)
 {
-	return isp_wait(isp_ccdc->dev, ispccdc_sbl_busy, 0, max_wait, isp_ccdc);
+	struct device *dev = to_device(isp_ccdc);
+
+	return isp_wait(dev, ispccdc_sbl_busy, 0, max_wait, isp_ccdc);
 }
 
 static void isp_enable_interrupts(struct device *dev, int is_raw)
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
+	u32 irq0enable;
 
-	isp->module.enable = 1;
-
-	isp_reg_writel(dev, -1, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);
-	isp_reg_writel(dev,
-		       IRQ0ENABLE_CCDC_LSC_PREF_ERR_IRQ
-		       | IRQ0ENABLE_HS_VS_IRQ
-		       | IRQ0ENABLE_CCDC_VD0_IRQ | IRQ0ENABLE_CCDC_VD1_IRQ
-		       | isp->module.interrupts,
-		       OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE);
+	irq0enable = IRQ0ENABLE_CCDC_LSC_PREF_ERR_IRQ
+		| IRQ0ENABLE_CCDC_VD0_IRQ
+		| IRQ0ENABLE_CSIA_IRQ
+		| IRQ0ENABLE_CSIB_IRQ | IRQ0ENABLE_HIST_DONE_IRQ
+		| IRQ0ENABLE_H3A_AWB_DONE_IRQ | IRQ0ENABLE_H3A_AF_DONE_IRQ
+		| isp->interrupts;
 
-	if (is_raw)
-		return;
+	if (!is_raw)
+		irq0enable |= IRQ0ENABLE_PRV_DONE_IRQ | IRQ0ENABLE_RSZ_DONE_IRQ;
 
-	isp_reg_or(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE,
-		   IRQ0ENABLE_PRV_DONE_IRQ | IRQ0ENABLE_RSZ_DONE_IRQ);
+	isp_reg_writel(dev, -1, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);
+	isp_reg_writel(dev, irq0enable, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE);
 
 	return;
 }
 
 static void isp_disable_interrupts(struct device *dev)
 {
-	struct isp_device *isp = dev_get_drvdata(dev);
-
-	isp->module.enable = 0;
-
 	isp_reg_writel(dev, 0, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE);
 }
 
@@ -392,33 +343,6 @@ int isp_set_callback(struct device *dev,
 	spin_unlock_irqrestore(&isp->lock, irqflags);
 
 	switch (type) {
-	case CBK_H3A_AWB_DONE:
-		isp->module.interrupts |= IRQ0ENABLE_H3A_AWB_DONE_IRQ;
-		if (!isp->module.enable)
-			break;
-		isp_reg_writel(dev, IRQ0ENABLE_H3A_AWB_DONE_IRQ,
-			       OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);
-		isp_reg_or(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE,
-			   IRQ0ENABLE_H3A_AWB_DONE_IRQ);
-		break;
-	case CBK_H3A_AF_DONE:
-		isp->module.interrupts |= IRQ0ENABLE_H3A_AF_DONE_IRQ;
-		if (!isp->module.enable)
-			break;
-		isp_reg_writel(dev, IRQ0ENABLE_H3A_AF_DONE_IRQ,
-			       OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);
-		isp_reg_or(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE,
-			   IRQ0ENABLE_H3A_AF_DONE_IRQ);
-		break;
-	case CBK_HIST_DONE:
-		isp->module.interrupts |= IRQ0ENABLE_HIST_DONE_IRQ;
-		if (!isp->module.enable)
-			break;
-		isp_reg_writel(dev, IRQ0ENABLE_HIST_DONE_IRQ,
-			       OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);
-		isp_reg_or(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE,
-			   IRQ0ENABLE_HIST_DONE_IRQ);
-		break;
 	case CBK_PREV_DONE:
 		isp_reg_writel(dev, IRQ0ENABLE_PRV_DONE_IRQ,
 			       OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);
@@ -452,36 +376,6 @@ int isp_unset_callback(struct device *de
 	spin_unlock_irqrestore(&isp->lock, irqflags);
 
 	switch (type) {
-	case CBK_H3A_AWB_DONE:
-		isp->module.interrupts &= ~IRQ0ENABLE_H3A_AWB_DONE_IRQ;
-		if (!isp->module.enable)
-			break;
-		isp_reg_and(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE,
-			    ~IRQ0ENABLE_H3A_AWB_DONE_IRQ);
-		break;
-	case CBK_H3A_AF_DONE:
-		isp->module.interrupts &= ~IRQ0ENABLE_H3A_AF_DONE_IRQ;
-		if (!isp->module.enable)
-			break;
-		isp_reg_and(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE,
-			    ~IRQ0ENABLE_H3A_AF_DONE_IRQ);
-		break;
-	case CBK_HIST_DONE:
-		isp->module.interrupts &= ~IRQ0ENABLE_HIST_DONE_IRQ;
-		if (!isp->module.enable)
-			break;
-		isp_reg_and(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE,
-			    ~IRQ0ENABLE_HIST_DONE_IRQ);
-		break;
-	case CBK_CSIA:
-		isp_csi2_irq_set(0);
-		break;
-	case CBK_CSIB:
-		isp_reg_writel(dev, IRQ0ENABLE_CSIB_IRQ, OMAP3_ISP_IOMEM_MAIN,
-			       ISP_IRQ0STATUS);
-		isp_reg_or(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE,
-			   IRQ0ENABLE_CSIB_IRQ);
-		break;
 	case CBK_PREV_DONE:
 		isp_reg_and(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE,
 			    ~IRQ0ENABLE_PRV_DONE_IRQ);
@@ -558,7 +452,7 @@ EXPORT_SYMBOL(isp_set_xclk);
 static void isp_power_settings(struct device *dev, int idle)
 {
 	if (idle) {
-		isp_reg_writel(dev, ISP_SYSCONFIG_AUTOIDLE |
+		isp_reg_writel(dev,
 			       (ISP_SYSCONFIG_MIDLEMODE_SMARTSTANDBY <<
 				ISP_SYSCONFIG_MIDLEMODE_SHIFT),
 			       OMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG);
@@ -578,7 +472,7 @@ static void isp_power_settings(struct de
 			       ISP_CTRL);
 
 	} else {
-		isp_reg_writel(dev, ISP_SYSCONFIG_AUTOIDLE |
+		isp_reg_writel(dev,
 			       (ISP_SYSCONFIG_MIDLEMODE_FORCESTANDBY <<
 				ISP_SYSCONFIG_MIDLEMODE_SHIFT),
 			       OMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG);
@@ -607,6 +501,13 @@ static void isp_power_settings(struct de
 			| (val << shift);	\
 	} while (0)
 
+static void isp_csi_enable(struct device *dev, u8 enable)
+{
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCP2, ISPCSI1_CTRL,
+		       ~(BIT(0) | BIT(4)),
+		       enable ? (BIT(0) | BIT(4)) : 0);
+}
+
 static int isp_init_csi(struct device *dev, struct isp_interface_config *config)
 {
 	u32 i = 0, val, reg;
@@ -681,19 +582,30 @@ static int isp_init_csi(struct device *d
 	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_CCP2, reg);
 
 	/* Clear status bits for logical channel #0 */
-	isp_reg_writel(dev, 0xFFF & ~BIT(6), OMAP3_ISP_IOMEM_CCP2,
+	val = ISPCSI1_LC01_IRQSTATUS_LC0_FIFO_OVF_IRQ |
+	      ISPCSI1_LC01_IRQSTATUS_LC0_CRC_IRQ |
+	      ISPCSI1_LC01_IRQSTATUS_LC0_FSP_IRQ |
+	      ISPCSI1_LC01_IRQSTATUS_LC0_FW_IRQ |
+	      ISPCSI1_LC01_IRQSTATUS_LC0_FSC_IRQ |
+	      ISPCSI1_LC01_IRQSTATUS_LC0_SSC_IRQ;
+
+	/* Clear IRQ status bits for logical channel #0 */
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_CCP2,
 		       ISPCSI1_LC01_IRQSTATUS);
 
+	/* Enable IRQs for logical channel #0 */
+	isp_reg_or(dev, OMAP3_ISP_IOMEM_CCP2, ISPCSI1_LC01_IRQENABLE, val);
+
 	/* Enable CSI1 */
-	val = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCP2, ISPCSI1_CTRL);
-	val |= BIT(0) | BIT(4);
-	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_CCP2, ISPCSI1_CTRL);
+	isp_csi_enable(dev, 1);
 
 	if (!(isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCP2,
 			    ISPCSI1_CTRL) & BIT(4))) {
 		dev_warn(dev, "OMAP3 CSI1 bus not available\n");
-		if (config->u.csi.signalling)	/* Strobe mode requires CSI1 */
+		if (config->u.csi.signalling) {
+			/* Strobe mode requires CCP2 */
 			return -EIO;
+		}
 	}
 
 	return 0;
@@ -756,7 +668,6 @@ int isp_configure_interface(struct devic
 
 		isp_csi2_irq_complexio1_set(1);
 		isp_csi2_irq_status_set(1);
-		isp_csi2_irq_set(1);
 
 		isp_csi2_enable(1);
 		mdelay(3);
@@ -800,7 +711,27 @@ int isp_configure_interface(struct devic
 }
 EXPORT_SYMBOL(isp_configure_interface);
 
-static int isp_buf_process(struct device *dev, struct isp_bufs *bufs);
+void omap34xx_isp_hist_dma_done(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	struct isp_irq *irqdis = &isp->irq;
+
+	isp_hist_enable(&isp->isp_hist, 1);
+	if (ispccdc_busy(&isp->isp_ccdc)) {
+		/* Histogram cannot be enabled in this frame anymore */
+		isp_hist_enable(&isp->isp_hist, 0);
+		if (isp_hist_busy(&isp->isp_hist))
+			isp_hist_mark_invalid_buf(&isp->isp_hist);
+	}
+	if (irqdis->isp_callbk[CBK_CATCHALL]) {
+		irqdis->isp_callbk[CBK_CATCHALL](
+			HIST_DONE,
+			irqdis->isp_callbk_arg1[CBK_CATCHALL],
+			irqdis->isp_callbk_arg2[CBK_CATCHALL]);
+	}
+}
+
+static void isp_buf_process(struct device *dev, struct isp_bufs *bufs);
 
 /**
  * omap34xx_isp_isr - Interrupt Service Routine for Camera ISP module.
@@ -820,34 +751,120 @@ static irqreturn_t omap34xx_isp_isr(int
 	struct isp_device *isp = dev_get_drvdata(dev);
 	struct isp_irq *irqdis = &isp->irq;
 	struct isp_bufs *bufs = &isp->bufs;
+	struct isp_buf *buf;
 	unsigned long flags;
 	u32 irqstatus = 0;
 	u32 sbl_pcr;
-	unsigned long irqflags = 0;
 	int wait_hs_vs = 0;
+	int ret;
+
+	if (isp->running == ISP_STOPPED)
+		return IRQ_NONE;
 
 	irqstatus = isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);
 	isp_reg_writel(dev, irqstatus, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);
 
-	spin_lock_irqsave(&bufs->lock, flags);
+	if (isp->running == ISP_STOPPING) {
+		isp_flush(dev);
+		return IRQ_HANDLED;
+	}
+
+	spin_lock_irqsave(&isp->lock, flags);
 	wait_hs_vs = bufs->wait_hs_vs;
-	if (irqstatus & HS_VS && bufs->wait_hs_vs)
+	if (irqstatus & CCDC_VD0 && bufs->wait_hs_vs)
 		bufs->wait_hs_vs--;
-	spin_unlock_irqrestore(&bufs->lock, flags);
-
-	spin_lock_irqsave(&isp->lock, irqflags);
 	/*
 	 * We need to wait for the first HS_VS interrupt from CCDC.
 	 * Otherwise our frame (and everything else) might be bad.
 	 */
-	if (wait_hs_vs)
+	switch (wait_hs_vs) {
+	case 1:
+		/*
+		 * Enable preview for the first time. We just have
+		 * missed the start-of-frame so we can do it now.
+		 */
+		if (irqstatus & CCDC_VD0 &&
+		    !RAW_CAPTURE(isp) &&
+		    !(isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR) &
+		      (ISPPRV_PCR_BUSY | ISPPRV_PCR_EN))) {
+			isppreview_config_shadow_registers(&isp->isp_prev);
+			isppreview_enable(&isp->isp_prev, 1);
+		}
+	default:
+		/*
+		 * For some sensors (like stingray), after a _restart_
+		 * from sw standby state, starting couple of frames
+		 * are erroneous. From stingray datasheet:
+		 *  "When sensor restarts, Normal image can get 2 frames after"
+		 *
+		 * So while we wait for HS_VS, check cnd clear the CSIB
+		 * error interrupts, if any
+		 */
+		if (irqstatus & IRQ0STATUS_CSIB_IRQ) {
+			u32 csib;
+
+			csib = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCP2,
+					     ISPCSI1_LC01_IRQSTATUS);
+			isp_reg_writel(dev, csib, OMAP3_ISP_IOMEM_CCP2,
+				       ISPCSI1_LC01_IRQSTATUS);
+		}
+
 		goto out_ignore_buff;
+	case 0:
+		break;
+	}
+
+	buf = ISP_BUF_DONE(bufs);
+
+	if (irqstatus & LSC_PRE_ERR) {
+		/* Mark buffer faulty. */
+		buf->vb_state = VIDEOBUF_ERROR;
+		ispccdc_lsc_error_handler(&isp->isp_ccdc);
+		dev_dbg(dev, "lsc prefetch error\n");
+	}
+
+	if (irqstatus & CSIA) {
+		int ret = isp_csi2_isr();
+		if (ret)
+			buf->vb_state = VIDEOBUF_ERROR;
+	}
+
+	if (irqstatus & IRQ0STATUS_CSIB_IRQ) {
+		static const u32 ISPCSI1_LC01_ERROR =
+			ISPCSI1_LC01_IRQSTATUS_LC0_FIFO_OVF_IRQ |
+			ISPCSI1_LC01_IRQSTATUS_LC0_CRC_IRQ |
+			ISPCSI1_LC01_IRQSTATUS_LC0_FSP_IRQ |
+			ISPCSI1_LC01_IRQSTATUS_LC0_FW_IRQ |
+			ISPCSI1_LC01_IRQSTATUS_LC0_FSC_IRQ |
+			ISPCSI1_LC01_IRQSTATUS_LC0_SSC_IRQ;
+		u32 ispcsi1_irqstatus;
+
+		ispcsi1_irqstatus = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCP2,
+						  ISPCSI1_LC01_IRQSTATUS);
+		isp_reg_writel(dev, ispcsi1_irqstatus, OMAP3_ISP_IOMEM_CCP2,
+			       ISPCSI1_LC01_IRQSTATUS);
+		if (ispcsi1_irqstatus & ISPCSI1_LC01_ERROR) {
+			buf->vb_state = VIDEOBUF_ERROR;
+			dev_dbg(dev, "CCP2 err:%x\n", ispcsi1_irqstatus);
+		}
+	}
+
+	if (irqstatus & RESZ_DONE && !RAW_CAPTURE(isp))
+		isp_buf_process(dev, bufs);
 
 	if (irqstatus & CCDC_VD0) {
 		if (RAW_CAPTURE(isp))
 			isp_buf_process(dev, bufs);
 		if (!ispccdc_busy(&isp->isp_ccdc))
 			ispccdc_config_shadow_registers(&isp->isp_ccdc);
+
+		/* Enabling configured statistic modules */
+		if (!(irqstatus & H3A_AWB_DONE))
+			isph3a_aewb_try_enable(&isp->isp_h3a);
+		if (!(irqstatus & H3A_AF_DONE))
+			isp_af_try_enable(&isp->isp_af);
+		if (!(irqstatus & HIST_DONE))
+			isp_hist_try_enable(&isp->isp_hist);
 	}
 
 	if (irqstatus & PREV_DONE) {
@@ -856,61 +873,27 @@ static irqreturn_t omap34xx_isp_isr(int
 				PREV_DONE,
 				irqdis->isp_callbk_arg1[CBK_PREV_DONE],
 				irqdis->isp_callbk_arg2[CBK_PREV_DONE]);
-		else if (!RAW_CAPTURE(isp) && !ispresizer_busy(&isp->isp_res)) {
-			ispresizer_applycrop(&isp->isp_res);
-			if (!isppreview_busy(&isp->isp_prev)) {
+		else if (!RAW_CAPTURE(isp)) {
+			if (ispresizer_busy(&isp->isp_res)) {
+				buf->vb_state = VIDEOBUF_ERROR;
+				dev_dbg(dev, "resizer busy.\n");
+			} else {
+				ispresizer_config_shadow_registers(
+					&isp->isp_res);
 				ispresizer_enable(&isp->isp_res, 1);
-				if (isppreview_busy(&isp->isp_prev)) {
-					/* FIXME: locking! */
-					ISP_BUF_DONE(bufs)->vb_state =
-						VIDEOBUF_ERROR;
-					dev_err(dev, "%s: can't stop"
-					       " preview\n", __func__);
-				}
 			}
-			if (!isppreview_busy(&isp->isp_prev))
+			if (!ISP_BUFS_IS_EMPTY(bufs)) {
 				isppreview_config_shadow_registers(
-								&isp->isp_prev);
-			if (!isppreview_busy(&isp->isp_prev))
-				isph3a_update_wb(&isp->isp_h3a);
-		}
-	}
-
-	if (irqstatus & RESZ_DONE) {
-		if (!RAW_CAPTURE(isp)) {
-			if (!ispresizer_busy(&isp->isp_res))
-				ispresizer_config_shadow_registers(
-								&isp->isp_res);
-			isp_buf_process(dev, bufs);
+					&isp->isp_prev);
+				isppreview_enable(&isp->isp_prev, 1);
+			}
 		}
 	}
 
-	if (irqstatus & H3A_AWB_DONE) {
-		if (irqdis->isp_callbk[CBK_H3A_AWB_DONE])
-			irqdis->isp_callbk[CBK_H3A_AWB_DONE](
-				H3A_AWB_DONE,
-				irqdis->isp_callbk_arg1[CBK_H3A_AWB_DONE],
-				irqdis->isp_callbk_arg2[CBK_H3A_AWB_DONE]);
-	}
-
-	if (irqstatus & HIST_DONE) {
-		if (irqdis->isp_callbk[CBK_HIST_DONE])
-			irqdis->isp_callbk[CBK_HIST_DONE](
-				HIST_DONE,
-				irqdis->isp_callbk_arg1[CBK_HIST_DONE],
-				irqdis->isp_callbk_arg2[CBK_HIST_DONE]);
-	}
-
-	if (irqstatus & H3A_AF_DONE) {
-		if (irqdis->isp_callbk[CBK_H3A_AF_DONE])
-			irqdis->isp_callbk[CBK_H3A_AF_DONE](
-				H3A_AF_DONE,
-				irqdis->isp_callbk_arg1[CBK_H3A_AF_DONE],
-				irqdis->isp_callbk_arg2[CBK_H3A_AF_DONE]);
-	}
-
-	/* Handle shared buffer logic overflows for video buffers. */
-	/* ISPSBL_PCR_CCDCPRV_2_RSZ_OVF can be safely ignored. */
+	/*
+	 * Handle shared buffer logic overflows for video buffers.
+	 * ISPSBL_PCR_CCDCPRV_2_RSZ_OVF can be safely ignored.
+	 */
 	sbl_pcr = isp_reg_readl(dev, OMAP3_ISP_IOMEM_SBL, ISPSBL_PCR) &
 		~ISPSBL_PCR_CCDCPRV_2_RSZ_OVF;
 	isp_reg_writel(dev, sbl_pcr, OMAP3_ISP_IOMEM_SBL, ISPSBL_PCR);
@@ -922,33 +905,73 @@ static irqreturn_t omap34xx_isp_isr(int
 		       | ISPSBL_PCR_CCDC_WBL_OVF
 		       | ISPSBL_PCR_CSIA_WBL_OVF
 		       | ISPSBL_PCR_CSIB_WBL_OVF)) {
-		struct isp_buf *buf = ISP_BUF_DONE(bufs);
 		buf->vb_state = VIDEOBUF_ERROR;
-		dev_info(dev, "%s: sbl overflow, sbl_pcr = %8.8x\n",
-		       __func__, sbl_pcr);
+		isp->isp_af.buf_err = 1;
+		isp->isp_h3a.buf_err = 1;
+		isp_hist_mark_invalid_buf(&isp->isp_hist);
+		dev_dbg(dev, "sbl overflow, sbl_pcr = %8.8x\n", sbl_pcr);
 	}
 
-out_ignore_buff:
-	if (irqstatus & LSC_PRE_ERR) {
-		struct isp_buf *buf = ISP_BUF_DONE(bufs);
-		/* Mark buffer faulty. */
-		buf->vb_state = VIDEOBUF_ERROR;
-		ispccdc_lsc_error_handler(&isp->isp_ccdc);
-		dev_err(dev, "%s: lsc prefetch error\n", __func__);
+	if (sbl_pcr & ISPSBL_PCR_H3A_AF_WBL_OVF) {
+		dev_dbg(dev, "af: sbl overflow detected.\n");
+		isp->isp_af.buf_err = 1;
 	}
 
-	if (irqstatus & CSIA) {
-		struct isp_buf *buf = ISP_BUF_DONE(bufs);
-		isp_csi2_isr();
-		buf->vb_state = VIDEOBUF_ERROR;
+	if (sbl_pcr & ISPSBL_PCR_H3A_AEAWB_WBL_OVF) {
+		dev_dbg(dev, "h3a: sbl overflow detected.\n");
+		isp->isp_h3a.buf_err = 1;
 	}
 
-	if (irqstatus & IRQ0STATUS_CSIB_IRQ) {
-		u32 ispcsi1_irqstatus;
+	if (irqstatus & H3A_AWB_DONE) {
+		isph3a_aewb_enable(&isp->isp_h3a, 0);
+		/* If it's busy we can't process this buffer anymore */
+		if (!isph3a_aewb_busy(&isp->isp_h3a)) {
+			ret = isph3a_aewb_buf_process(&isp->isp_h3a);
+			isph3a_aewb_config_registers(&isp->isp_h3a);
+		} else {
+			ret = -1;
+			dev_dbg(dev, "h3a: cannot process buffer, device is "
+				     "busy.\n");
+		}
+		if (ret)
+			irqstatus &= ~H3A_AWB_DONE;
+		isph3a_aewb_enable(&isp->isp_h3a, 1);
+	}
 
-		ispcsi1_irqstatus = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCP2,
-						  ISPCSI1_LC01_IRQSTATUS);
-		DPRINTK_ISPCTRL("%x\n", ispcsi1_irqstatus);
+	if (irqstatus & H3A_AF_DONE) {
+		isp_af_enable(&isp->isp_af, 0);
+		/* If it's busy we can't process this buffer anymore */
+		if (!isp_af_busy(&isp->isp_af)) {
+			ret = isp_af_buf_process(&isp->isp_af);
+			isp_af_config_registers(&isp->isp_af);
+		} else {
+			ret = -1;
+			dev_dbg(dev, "af: cannot process buffer, device is "
+				     "busy.\n");
+		}
+		if (ret)
+			irqstatus &= ~H3A_AF_DONE;
+		isp_af_enable(&isp->isp_af, 1);
+	}
+
+	if (irqstatus & HIST_DONE) {
+		isp_hist_enable(&isp->isp_hist, 0);
+		/* If it's busy we can't process this buffer anymore */
+		if (!isp_hist_busy(&isp->isp_hist)) {
+			ret = isp_hist_buf_process(&isp->isp_hist);
+			isp_hist_config_registers(&isp->isp_hist);
+		} else {
+			dev_dbg(dev, "hist: cannot process buffer, device is "
+				     "busy.\n");
+			/* current and next buffer might have invalid data */
+			isp_hist_mark_invalid_buf(&isp->isp_hist);
+			irqstatus &= ~HIST_DONE;
+			ret = HIST_NO_BUF;
+		}
+		if (ret != HIST_BUF_WAITING_DMA)
+			isp_hist_enable(&isp->isp_hist, 1);
+		if (ret != HIST_BUF_DONE)
+			irqstatus &= ~HIST_DONE;
 	}
 
 	if (irqdis->isp_callbk[CBK_CATCHALL]) {
@@ -958,7 +981,10 @@ out_ignore_buff:
 			irqdis->isp_callbk_arg2[CBK_CATCHALL]);
 	}
 
-	spin_unlock_irqrestore(&isp->lock, irqflags);
+out_ignore_buff:
+	spin_unlock_irqrestore(&isp->lock, flags);
+
+	isp_flush(dev);
 
 #if 1
 	{
@@ -1029,7 +1055,7 @@ static void isp_tmp_buf_free(struct devi
 	struct isp_device *isp = dev_get_drvdata(dev);
 
 	if (isp->tmp_buf) {
-		ispmmu_vfree(isp->tmp_buf);
+		iommu_vfree(isp->iommu, isp->tmp_buf);
 		isp->tmp_buf = 0;
 		isp->tmp_buf_size = 0;
 	}
@@ -1042,16 +1068,16 @@ static void isp_tmp_buf_free(struct devi
 static u32 isp_tmp_buf_alloc(struct device *dev, size_t size)
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
+	u32 da;
 
 	isp_tmp_buf_free(dev);
 
-	dev_dbg(dev, "%s: allocating %d bytes\n", __func__, size);
-
-	isp->tmp_buf = ispmmu_vmalloc(size);
-	if (IS_ERR((void *)isp->tmp_buf)) {
-		dev_err(dev, "ispmmu_vmap mapping failed ");
+	da = iommu_vmalloc(isp->iommu, 0, size, IOMMU_FLAG);
+	if (IS_ERR_VALUE(da)) {
+		dev_err(dev, "iommu_vmap mapping failed\n");
 		return -ENOMEM;
 	}
+	isp->tmp_buf = da;
 	isp->tmp_buf_size = size;
 
 	isppreview_set_outaddr(&isp->isp_prev, isp->tmp_buf);
@@ -1070,9 +1096,7 @@ void isp_start(struct device *dev)
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
 
-	if (isp->module.isp_pipeline & OMAP_ISP_PREVIEW
-	    && is_isppreview_enabled())
-		isppreview_enable(&isp->isp_prev, 1);
+	isp->running = ISP_RUNNING;
 
 	return;
 }
@@ -1100,8 +1124,8 @@ static int __isp_disable_modules(struct
 		isph3a_aewb_enable(&isp->isp_h3a, 0);
 		isp_hist_enable(&isp->isp_hist, 0);
 	}
-	isppreview_enable(&isp->isp_prev, 0);
 	ispresizer_enable(&isp->isp_res, 0);
+	isppreview_enable(&isp->isp_prev, 0);
 
 	timeout = jiffies + ISP_STOP_TIMEOUT;
 	while (isp_af_busy(&isp->isp_af)
@@ -1110,8 +1134,7 @@ static int __isp_disable_modules(struct
 	       || isppreview_busy(&isp->isp_prev)
 	       || ispresizer_busy(&isp->isp_res)) {
 		if (time_after(jiffies, timeout)) {
-			dev_err(dev, "%s: can't stop non-ccdc modules\n",
-			       __func__);
+			dev_info(dev, "can't stop non-ccdc modules.\n");
 			reset = 1;
 			break;
 		}
@@ -1124,13 +1147,15 @@ static int __isp_disable_modules(struct
 	timeout = jiffies + ISP_STOP_TIMEOUT;
 	while (ispccdc_busy(&isp->isp_ccdc)) {
 		if (time_after(jiffies, timeout)) {
-			dev_err(dev, "%s: can't stop ccdc\n", __func__);
+			dev_info(dev, "can't stop ccdc module.\n");
 			reset = 1;
 			break;
 		}
 		msleep(1);
 	}
 
+	isp_csi_enable(dev, 0);
+	isp_csi2_enable(0);
 	isp_buf_init(dev);
 
 	return reset;
@@ -1166,7 +1191,7 @@ static void isp_reset(struct device *dev
 	while (!(isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
 			       ISP_SYSSTATUS) & 0x1)) {
 		if (timeout++ > 10000) {
-			dev_alert(dev, "%s: cannot reset ISP\n", __func__);
+			dev_alert(dev, "cannot reset ISP\n");
 			break;
 		}
 		udelay(1);
@@ -1178,10 +1203,13 @@ static void isp_reset(struct device *dev
  **/
 void isp_stop(struct device *dev)
 {
+	struct isp_device *isp = dev_get_drvdata(dev);
 	int reset;
 
+	isp->running = ISP_STOPPING;
 	isp_disable_interrupts(dev);
-	synchronize_irq(((struct isp *)dev_get_drvdata(dev))->irq_num);
+	synchronize_irq(((struct isp_device *)dev_get_drvdata(dev))->irq_num);
+	isp->running = ISP_STOPPED;
 	reset = isp_stop_modules(dev);
 	if (!reset)
 		return;
@@ -1196,108 +1224,193 @@ static void isp_set_buf(struct device *d
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
 
-	if (isp->module.isp_pipeline & OMAP_ISP_RESIZER
+	if (isp->pipeline.modules & OMAP_ISP_RESIZER
 	    && is_ispresizer_enabled())
 		ispresizer_set_outaddr(&isp->isp_res, buf->isp_addr);
-	else if (isp->module.isp_pipeline & OMAP_ISP_CCDC)
+	else if (isp->pipeline.modules & OMAP_ISP_CCDC)
 		ispccdc_set_outaddr(&isp->isp_ccdc, buf->isp_addr);
 
 }
 
-/**
- * isp_calc_pipeline - Sets pipeline depending of input and output pixel format
- * @pix_input: Pointer to V4L2 pixel format structure for input image.
- * @pix_output: Pointer to V4L2 pixel format structure for output image.
- **/
-static u32 isp_calc_pipeline(struct device *dev,
-			     struct v4l2_pix_format *pix_input,
-			     struct v4l2_pix_format *pix_output)
+static int isp_try_pipeline(struct device *dev,
+			    struct v4l2_pix_format *pix_input,
+			    struct isp_pipeline *pipe)
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
+	struct v4l2_pix_format *pix_output = &pipe->pix;
+	unsigned int wanted_width = pix_output->width;
+	unsigned int wanted_height = pix_output->height;
+	int ifmt;
+	int rval;
 
-	isp_release_resources(dev);
 	if ((pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10
 	     || pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10DPCM8)
 	    && pix_output->pixelformat != V4L2_PIX_FMT_SGRBG10) {
-		isp->module.isp_pipeline =
-			OMAP_ISP_CCDC | OMAP_ISP_PREVIEW | OMAP_ISP_RESIZER;
-		ispccdc_request(&isp->isp_ccdc);
-		isppreview_request(&isp->isp_prev);
-		ispresizer_request(&isp->isp_res);
-		ispccdc_config_datapath(&isp->isp_ccdc, CCDC_RAW,
-					CCDC_OTHERS_VP);
-		isppreview_config_datapath(&isp->isp_prev, PRV_RAW_CCDC,
-					   PREVIEW_MEM);
-		ispresizer_config_datapath(&isp->isp_res, RSZ_MEM_YUV);
+		pipe->modules = OMAP_ISP_CCDC | OMAP_ISP_PREVIEW
+			| OMAP_ISP_RESIZER;
+		pipe->ccdc_in = CCDC_RAW;
+		pipe->ccdc_out = CCDC_OTHERS_VP;
 	} else {
-		isp->module.isp_pipeline = OMAP_ISP_CCDC;
-		ispccdc_request(&isp->isp_ccdc);
+		pipe->modules = OMAP_ISP_CCDC;
 		if (pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10
-		    || pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10DPCM8)
-			ispccdc_config_datapath(&isp->isp_ccdc, CCDC_RAW,
-						CCDC_OTHERS_VP_MEM);
-		else
-			ispccdc_config_datapath(&isp->isp_ccdc, CCDC_YUV_SYNC,
-						CCDC_OTHERS_MEM);
+		    || pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10DPCM8) {
+			pipe->ccdc_in = CCDC_RAW;
+			pipe->ccdc_out = CCDC_OTHERS_VP_MEM;
+		} else {
+			pipe->ccdc_in = CCDC_YUV_SYNC;
+			pipe->ccdc_out = CCDC_OTHERS_MEM;
+		}
+	}
+
+	if (pipe->modules & OMAP_ISP_CCDC) {
+		pipe->ccdc_in_w = pix_input->width;
+		pipe->ccdc_in_h = pix_input->height;
+		rval = ispccdc_try_pipeline(&isp->isp_ccdc, pipe);
+		if (rval) {
+			dev_dbg(dev, "the dimensions %dx%d are not"
+				" supported\n", pix_input->width,
+				pix_input->height);
+			return rval;
+		}
+		pix_output->width = pipe->ccdc_out_w_img;
+		pix_output->height = pipe->ccdc_out_h;
+		pix_output->bytesperline =
+			pipe->ccdc_out_w * ISP_BYTES_PER_PIXEL;
+	}
+
+	if (pipe->modules & OMAP_ISP_PREVIEW) {
+		rval = isppreview_try_pipeline(&isp->isp_prev, pipe);
+		if (rval) {
+			dev_dbg(dev, "the dimensions %dx%d are not"
+				" supported\n", pix_input->width,
+				pix_input->height);
+			return rval;
+		}
+		pix_output->width = pipe->prv_out_w;
+		pix_output->height = pipe->prv_out_h;
+	}
+
+	if (pipe->modules & OMAP_ISP_RESIZER) {
+		pipe->rsz_out_w = wanted_width;
+		pipe->rsz_out_h = wanted_height;
+
+		pipe->rsz_crop.left = pipe->rsz_crop.top = 0;
+		pipe->rsz_crop.width = pipe->prv_out_w_img;
+		pipe->rsz_crop.height = pipe->prv_out_h_img;
+
+		rval = ispresizer_try_pipeline(&isp->isp_res, pipe);
+		if (rval) {
+			dev_dbg(dev, "The dimensions %dx%d are not"
+				" supported\n", pix_input->width,
+				pix_input->height);
+			return rval;
+		}
+
+		pix_output->width = pipe->rsz_out_w;
+		pix_output->height = pipe->rsz_out_h;
+		pix_output->bytesperline =
+			pipe->rsz_out_w * ISP_BYTES_PER_PIXEL;
+	}
+
+	pix_output->field = V4L2_FIELD_NONE;
+	pix_output->sizeimage =
+		PAGE_ALIGN(pix_output->bytesperline * pix_output->height);
+	pix_output->priv = 0;
+
+	for (ifmt = 0; ifmt < NUM_ISP_CAPTURE_FORMATS; ifmt++) {
+		if (pix_output->pixelformat == isp_formats[ifmt].pixelformat)
+			break;
+	}
+	if (ifmt == NUM_ISP_CAPTURE_FORMATS)
+		pix_output->pixelformat = V4L2_PIX_FMT_YUYV;
+
+	switch (pix_output->pixelformat) {
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+		pix_output->colorspace = V4L2_COLORSPACE_JPEG;
+		break;
+	default:
+		pix_output->colorspace = V4L2_COLORSPACE_SRGB;
 	}
+
 	return 0;
 }
 
-/**
- * isp_config_pipeline - Configures the image size and ycpos for ISP submodules
- * @pix_input: Pointer to V4L2 pixel format structure for input image.
- * @pix_output: Pointer to V4L2 pixel format structure for output image.
- *
- * The configuration of ycpos depends on the output pixel format for both the
- * Preview and Resizer submodules.
- **/
-static void isp_config_pipeline(struct device *dev,
-				struct v4l2_pix_format *pix_input,
-				struct v4l2_pix_format *pix_output)
+static int isp_s_pipeline(struct device *dev,
+			  struct v4l2_pix_format *pix_input,
+			  struct v4l2_pix_format *pix_output)
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
+	struct isp_pipeline pipe;
+	int rval;
 
-	ispccdc_config_size(&isp->isp_ccdc, isp->module.ccdc_input_width,
-			    isp->module.ccdc_input_height,
-			    isp->module.ccdc_output_width,
-			    isp->module.ccdc_output_height);
+	isp_release_resources(dev);
 
-	if (isp->module.isp_pipeline & OMAP_ISP_PREVIEW) {
-		isppreview_config_size(&isp->isp_prev,
-				       isp->module.preview_input_width,
-				       isp->module.preview_input_height,
-				       isp->module.preview_output_width,
-				       isp->module.preview_output_height);
-	}
+	pipe.pix = *pix_output;
+
+	rval = isp_try_pipeline(dev, pix_input, &pipe);
+	if (rval)
+		return rval;
+
+	ispccdc_request(&isp->isp_ccdc);
+	ispccdc_s_pipeline(&isp->isp_ccdc, &pipe);
 
-	if (isp->module.isp_pipeline & OMAP_ISP_RESIZER) {
-		ispresizer_config_size(&isp->isp_res,
-				       isp->module.resizer_input_width,
-				       isp->module.resizer_input_height,
-				       isp->module.resizer_output_width,
-				       isp->module.resizer_output_height);
+	if (pipe.modules & OMAP_ISP_PREVIEW) {
+		isppreview_request(&isp->isp_prev);
+		pipe.prv_in = PRV_RAW_CCDC;
+		pipe.prv_out = PREVIEW_MEM;
+		isppreview_s_pipeline(&isp->isp_prev, &pipe);
 	}
 
-	if (pix_output->pixelformat == V4L2_PIX_FMT_UYVY) {
-		isppreview_config_ycpos(&isp->isp_prev, YCPOS_YCrYCb);
-		if (is_ispresizer_enabled())
-			ispresizer_config_ycpos(&isp->isp_res, 0);
-	} else {
-		isppreview_config_ycpos(&isp->isp_prev, YCPOS_CrYCbY);
-		if (is_ispresizer_enabled())
-			ispresizer_config_ycpos(&isp->isp_res, 1);
+	if (pipe.modules & OMAP_ISP_RESIZER) {
+		ispresizer_request(&isp->isp_res);
+		pipe.rsz_in = RSZ_MEM_YUV;
+		ispresizer_s_pipeline(&isp->isp_res, &pipe);
 	}
 
-	return;
+	isp->pipeline = pipe;
+	*pix_output = isp->pipeline.pix;
+
+	return 0;
 }
 
 /**
- * isp_vbq_sync - Walks the pages table and flushes the cache for
- *                each page.
+ * isp_vbq_sync - keep the video buffers coherent between cpu and isp
+ *
+ * The typical operation required here is Cache Invalidation across
+ * the (user space) buffer address range. And this _must_ be done
+ * at QBUF stage (and *only* at QBUF).
+ *
+ * We try to use optimal cache invalidation function:
+ * - dmac_inv_range:
+ *    - used when the number of pages are _low_.
+ *    - it becomes quite slow as the number of pages increase.
+ *       - for 648x492 viewfinder (150 pages) it takes 1.3 ms.
+ *       - for 5 Mpix buffer (2491 pages) it takes between 25-50 ms.
+ *
+ * - flush_cache_all:
+ *    - used when the number of pages are _high_.
+ *    - time taken in the range of 500-900 us.
+ *    - has a higher penalty but, as whole dcache + icache is invalidated
  **/
-static int isp_vbq_sync(struct videobuf_buffer *vb, int when)
+/**
+ * FIXME: dmac_inv_range crashes randomly on the user space buffer
+ *        address. Fall back to flush_cache_all for now.
+ */
+#define ISP_CACHE_FLUSH_PAGES_MAX       0
+
+static int isp_vbq_sync(struct videobuf_buffer *vb)
 {
-	flush_cache_all();
+	struct videobuf_dmabuf *dma = videobuf_to_dma(vb);
+
+	if (!vb->baddr || !dma || !dma->nr_pages ||
+	    dma->nr_pages > ISP_CACHE_FLUSH_PAGES_MAX)
+		flush_cache_all();
+	else {
+		dmac_inv_range((void *)vb->baddr,
+			       (void *)vb->baddr + vb->bsize);
+		outer_inv_range(vb->baddr, vb->baddr + vb->bsize);
+	}
 
 	return 0;
 }
@@ -1313,7 +1426,6 @@ static void isp_buf_init(struct device *
 	bufs->wait_hs_vs = isp->config->wait_hs_vs;
 	for (sg = 0; sg < NUM_BUFS; sg++) {
 		if (bufs->buf[sg].vb) {
-			isp_vbq_sync(bufs->buf[sg].vb, DMA_FROM_DEVICE);
 			bufs->buf[sg].vb->state = VIDEOBUF_ERROR;
 			bufs->buf[sg].complete(bufs->buf[sg].vb,
 					       bufs->buf[sg].priv);
@@ -1324,22 +1436,22 @@ static void isp_buf_init(struct device *
 	}
 }
 
-static int isp_buf_process(struct device *dev, struct isp_bufs *bufs)
+static void isp_buf_process(struct device *dev, struct isp_bufs *bufs)
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
-	struct isp_buf *buf = NULL;
-	unsigned long flags;
+	struct isp_buf *buf;
 	int last;
 
-	spin_lock_irqsave(&bufs->lock, flags);
-
 	if (ISP_BUFS_IS_EMPTY(bufs))
-		goto out;
+		return;
 
-	if (RAW_CAPTURE(isp) && ispccdc_sbl_wait_idle(&isp->isp_ccdc, 1000)) {
-		dev_err(dev, "ccdc %d won't become idle!\n",
-		       RAW_CAPTURE(isp));
-		goto out;
+	if (RAW_CAPTURE(isp)) {
+		ispccdc_enable(&isp->isp_ccdc, 0);
+		if (ispccdc_sbl_wait_idle(&isp->isp_ccdc, 1000)) {
+			ispccdc_enable(&isp->isp_ccdc, 1);
+			dev_info(dev, "ccdc won't become idle!\n");
+			return;
+		}
 	}
 
 	/* We had at least one buffer in queue. */
@@ -1349,40 +1461,11 @@ static int isp_buf_process(struct device
 	if (!last) {
 		/* Set new buffer address. */
 		isp_set_buf(dev, ISP_BUF_NEXT_DONE(bufs));
+		if (RAW_CAPTURE(isp))
+			ispccdc_enable(&isp->isp_ccdc, 1);
 	} else {
 		/* Tell ISP not to write any of our buffers. */
 		isp_disable_interrupts(dev);
-		if (RAW_CAPTURE(isp))
-			ispccdc_enable(&isp->isp_ccdc, 0);
-		else
-			ispresizer_enable(&isp->isp_res, 0);
-		/*
-		 * We must wait for the HS_VS since before that the
-		 * CCDC may trigger interrupts even if it's not
-		 * receiving a frame.
-		 */
-		bufs->wait_hs_vs = isp->config->wait_hs_vs;
-	}
-	if ((RAW_CAPTURE(isp) && ispccdc_busy(&isp->isp_ccdc))
-	    || (!RAW_CAPTURE(isp) && ispresizer_busy(&isp->isp_res))) {
-		/*
-		 * Next buffer available: for the transfer to succeed, the
-		 * CCDC (RAW capture) or resizer (YUV capture) must be idle
-		 * for the duration of transfer setup. Bad things happen
-		 * otherwise!
-		 *
-		 * Next buffer not available: if we fail to stop the
-		 * ISP the buffer is probably going to be bad.
-		 */
-		/* Mark this buffer faulty. */
-		buf->vb_state = VIDEOBUF_ERROR;
-		/* Mark next faulty, too, in case we have one. */
-		if (!last) {
-			ISP_BUF_NEXT_DONE(bufs)->vb_state = VIDEOBUF_ERROR;
-			dev_alert(dev, "OUCH!!!\n");
-		} else {
-			dev_alert(dev, "Ouch!\n");
-		}
 	}
 
 	/* Mark the current buffer as done. */
@@ -1393,21 +1476,13 @@ static int isp_buf_process(struct device
 			(bufs->buf+((bufs->done - 1 + NUM_BUFS)
 				    % NUM_BUFS))->isp_addr);
 
-out:
-	spin_unlock_irqrestore(&bufs->lock, flags);
-
-	if (buf && buf->vb) {
-		/*
-		 * We want to dequeue a buffer from the video buffer
-		 * queue. Let's do it!
-		 */
-		isp_vbq_sync(buf->vb, DMA_FROM_DEVICE);
-		buf->vb->state = buf->vb_state;
-		buf->complete(buf->vb, buf->priv);
-		buf->vb = NULL;
-	}
-
-	return 0;
+	/*
+	 * We want to dequeue a buffer from the video buffer
+	 * queue. Let's do it!
+	 */
+	buf->vb->state = buf->vb_state;
+	buf->complete(buf->vb, buf->priv);
+	buf->vb = NULL;
 }
 
 int isp_buf_queue(struct device *dev, struct videobuf_buffer *vb,
@@ -1422,11 +1497,18 @@ int isp_buf_queue(struct device *dev, st
 	struct isp_bufs *bufs = &isp->bufs;
 	int sglen = dma->sglen;
 
+	if (isp->running != ISP_RUNNING) {
+		vb->state = VIDEOBUF_ERROR;
+		complete(vb, priv);
+
+		return 0;
+	}
+
 	BUG_ON(sglen < 0 || !sglist);
 
-	isp_vbq_sync(vb, DMA_TO_DEVICE);
+	isp_vbq_sync(vb);
 
-	spin_lock_irqsave(&bufs->lock, flags);
+	spin_lock_irqsave(&isp->lock, flags);
 
 	BUG_ON(ISP_BUFS_IS_FULL(bufs));
 
@@ -1440,15 +1522,23 @@ int isp_buf_queue(struct device *dev, st
 	buf->vb->state = VIDEOBUF_ACTIVE;
 
 	if (ISP_BUFS_IS_EMPTY(bufs)) {
+		/*
+		 * We must wait for the HS_VS since before that the
+		 * CCDC may trigger interrupts even if it's not
+		 * receiving a frame.
+		 */
+		bufs->wait_hs_vs++;
 		isp_enable_interrupts(dev, RAW_CAPTURE(isp));
 		isp_set_buf(dev, buf);
+		isp_af_try_enable(&isp->isp_af);
+		isph3a_aewb_try_enable(&isp->isp_h3a);
+		isp_hist_try_enable(&isp->isp_hist);
 		ispccdc_enable(&isp->isp_ccdc, 1);
-		isp_start(dev);
 	}
 
 	ISP_BUF_MARK_QUEUED(bufs);
 
-	spin_unlock_irqrestore(&bufs->lock, flags);
+	spin_unlock_irqrestore(&isp->lock, flags);
 
 	DPRINTK_ISPCTRL(KERN_ALERT "%s: queue %d vb %d, mmu %p\n", __func__,
 			(bufs->queue - 1 + NUM_BUFS) % NUM_BUFS, vb->i,
@@ -1462,19 +1552,70 @@ int isp_vbq_setup(struct device *dev, st
 		  unsigned int *cnt, unsigned int *size)
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
-	int rval = 0;
-	size_t tmp_size = PAGE_ALIGN(isp->module.preview_output_width
-				     * isp->module.preview_output_height
+	size_t tmp_size = PAGE_ALIGN(isp->pipeline.prv_out_w
+				     * isp->pipeline.prv_out_h
 				     * ISP_BYTES_PER_PIXEL);
 
-	if (isp->module.isp_pipeline & OMAP_ISP_PREVIEW
+	if (isp->pipeline.modules & OMAP_ISP_PREVIEW
 	    && isp->tmp_buf_size < tmp_size)
-		rval = isp_tmp_buf_alloc(dev, tmp_size);
+		return isp_tmp_buf_alloc(dev, tmp_size);
 
-	return rval;
+	return 0;
 }
 EXPORT_SYMBOL(isp_vbq_setup);
 
+dma_addr_t ispmmu_vmap(struct device *dev, const struct scatterlist *sglist,
+		       int sglen)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	int err;
+	u32 da;
+	struct sg_table *sgt;
+	unsigned int i;
+	struct scatterlist *sg, *src = (struct scatterlist *)sglist;
+
+	/*
+	 * convert isp sglist to iommu sgt
+	 * FIXME: should be fixed in the upper layer?
+	 */
+	sgt = kmalloc(sizeof(*sgt), GFP_KERNEL);
+	if (!sgt)
+		return -ENOMEM;
+	err = sg_alloc_table(sgt, sglen, GFP_KERNEL);
+	if (err)
+		goto err_sg_alloc;
+
+	for_each_sg(sgt->sgl, sg, sgt->nents, i)
+		sg_set_buf(sg, phys_to_virt(sg_dma_address(src + i)),
+			   sg_dma_len(src + i));
+
+	da = iommu_vmap(isp->iommu, 0, sgt, IOMMU_FLAG);
+	if (IS_ERR_VALUE(da))
+		goto err_vmap;
+
+	return (dma_addr_t)da;
+
+err_vmap:
+	sg_free_table(sgt);
+err_sg_alloc:
+	kfree(sgt);
+	return -ENOMEM;
+}
+EXPORT_SYMBOL_GPL(ispmmu_vmap);
+
+void ispmmu_vunmap(struct device *dev, dma_addr_t da)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	struct sg_table *sgt;
+
+	sgt = iommu_vunmap(isp->iommu, (u32)da);
+	if (!sgt)
+		return;
+	sg_free_table(sgt);
+	kfree(sgt);
+}
+EXPORT_SYMBOL_GPL(ispmmu_vunmap);
+
 /**
  * isp_vbq_prepare - Videobuffer queue prepare.
  * @vbq: Pointer to videobuf_queue structure.
@@ -1496,7 +1637,7 @@ int isp_vbq_prepare(struct device *dev,
 
 	vdma = videobuf_to_dma(vb);
 
-	isp_addr = ispmmu_vmap(vdma->sglist, vdma->sglen);
+	isp_addr = ispmmu_vmap(dev, vdma->sglist, vdma->sglen);
 
 	if (IS_ERR_VALUE(isp_addr))
 		err = -EIO;
@@ -1518,7 +1659,7 @@ void isp_vbq_release(struct device *dev,
 	struct isp_device *isp = dev_get_drvdata(dev);
 	struct isp_bufs *bufs = &isp->bufs;
 
-	ispmmu_vunmap(bufs->isp_addr_capture[vb->i]);
+	ispmmu_vunmap(dev, bufs->isp_addr_capture[vb->i]);
 	bufs->isp_addr_capture[vb->i] = (dma_addr_t)NULL;
 	return;
 }
@@ -1626,20 +1767,20 @@ int isp_s_ctrl(struct device *dev, struc
 
 	switch (a->id) {
 	case V4L2_CID_BRIGHTNESS:
-		if (new_value > ISPPRV_BRIGHT_HIGH)
+		if (a->value > ISPPRV_BRIGHT_HIGH)
 			rval = -EINVAL;
 		else
 			isppreview_update_brightness(&isp->isp_prev,
 						     &new_value);
 		break;
 	case V4L2_CID_CONTRAST:
-		if (new_value > ISPPRV_CONTRAST_HIGH)
+		if (a->value > ISPPRV_CONTRAST_HIGH)
 			rval = -EINVAL;
 		else
 			isppreview_update_contrast(&isp->isp_prev, &new_value);
 		break;
 	case V4L2_CID_COLORFX:
-		if (new_value > V4L2_COLORFX_SEPIA)
+		if (a->value > V4L2_COLORFX_SEPIA)
 			rval = -EINVAL;
 		else
 			isppreview_set_color(&isp->isp_prev, &new_value);
@@ -1681,37 +1822,40 @@ int isp_handle_private(struct device *de
 	case VIDIOC_PRIVATE_ISP_AEWB_CFG: {
 		struct isph3a_aewb_config *params;
 		params = (struct isph3a_aewb_config *)arg;
-		rval = isph3a_aewb_configure(&isp->isp_h3a, params);
+		rval = omap34xx_isph3a_aewb_config(&isp->isp_h3a, params);
 	}
 		break;
 	case VIDIOC_PRIVATE_ISP_AEWB_REQ: {
 		struct isph3a_aewb_data *data;
 		data = (struct isph3a_aewb_data *)arg;
-		rval = isph3a_aewb_request_statistics(&isp->isp_h3a, data);
+		rval = omap34xx_isph3a_aewb_request_statistics(&isp->isp_h3a,
+							       data);
 	}
 		break;
 	case VIDIOC_PRIVATE_ISP_HIST_CFG: {
 		struct isp_hist_config *params;
 		params = (struct isp_hist_config *)arg;
-		rval = isp_hist_configure(&isp->isp_hist, params);
+		rval = omap34xx_isp_hist_config(&isp->isp_hist, params);
 	}
 		break;
 	case VIDIOC_PRIVATE_ISP_HIST_REQ: {
 		struct isp_hist_data *data;
 		data = (struct isp_hist_data *)arg;
-		rval = isp_hist_request_statistics(&isp->isp_hist, data);
+		rval = omap34xx_isp_hist_request_statistics(&isp->isp_hist,
+							    data);
 	}
 		break;
 	case VIDIOC_PRIVATE_ISP_AF_CFG: {
 		struct af_configuration *params;
 		params = (struct af_configuration *)arg;
-		rval = isp_af_configure(&isp->isp_af, params);
+		rval = omap34xx_isp_af_config(&isp->isp_af, params);
+
 	}
 		break;
 	case VIDIOC_PRIVATE_ISP_AF_REQ: {
 		struct isp_af_data *data;
 		data = (struct isp_af_data *)arg;
-		rval = isp_af_request_statistics(&isp->isp_af, data);
+		rval = omap34xx_isp_af_request_statistics(&isp->isp_af, data);
 	}
 		break;
 	default:
@@ -1767,7 +1911,7 @@ void isp_g_fmt_cap(struct device *dev, s
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
 
-	*pix = isp->module.pix;
+	*pix = isp->pipeline.pix;
 	return;
 }
 EXPORT_SYMBOL(isp_g_fmt_cap);
@@ -1783,27 +1927,11 @@ int isp_s_fmt_cap(struct device *dev, st
 		  struct v4l2_pix_format *pix_output)
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
-	int rval = 0;
 
 	if (!isp->ref_count)
 		return -EINVAL;
 
-	rval = isp_calc_pipeline(dev, pix_input, pix_output);
-	if (rval)
-		goto out;
-
-	rval = isp_try_size(dev, pix_input, pix_output);
-	if (rval)
-		goto out;
-
-	rval = isp_try_fmt(dev, pix_input, pix_output);
-	if (rval)
-		goto out;
-
-	isp_config_pipeline(dev, pix_input, pix_output);
-
-out:
-	return rval;
+	return isp_s_pipeline(dev, pix_input, pix_output);
 }
 EXPORT_SYMBOL(isp_s_fmt_cap);
 
@@ -1817,7 +1945,14 @@ int isp_g_crop(struct device *dev, struc
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
 
-	crop->c = isp->isp_res.croprect;
+	if (isp->pipeline.modules & OMAP_ISP_RESIZER) {
+		crop->c = isp->pipeline.rsz_crop;
+	} else {
+		crop->c.left = 0;
+		crop->c.top = 0;
+		crop->c.width = isp->pipeline.ccdc_out_w_img;
+		crop->c.height = isp->pipeline.ccdc_out_h;
+	}
 
 	return 0;
 }
@@ -1833,6 +1968,20 @@ EXPORT_SYMBOL(isp_g_crop);
 int isp_s_crop(struct device *dev, struct v4l2_crop *a)
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
+	struct isp_pipeline *pipe = &isp->pipeline;
+
+	/*
+	 * Reset resizer output size.
+	 * FIXME: resizer should not touch the output size in the first place,
+	 * it should always correspond to the size set by S_FMT or S_FMT
+	 * should fail if not possible. If necessary, resizer should adjust
+	 * the source rectangle in ispresizer_try_pipeline instead.
+	 * When the resizer is fixed, its output size does not need to be
+	 * adjusted anymore here.
+	 */
+	pipe->rsz_out_w_img = pipe->pix.width;
+	pipe->rsz_out_w = pipe->pix.width;
+	pipe->rsz_out_h = pipe->pix.height;
 
 	ispresizer_config_crop(&isp->isp_res, a);
 
@@ -1851,157 +2000,20 @@ EXPORT_SYMBOL(isp_s_crop);
 int isp_try_fmt_cap(struct device *dev, struct v4l2_pix_format *pix_input,
 		    struct v4l2_pix_format *pix_output)
 {
-	int rval = 0;
+	struct isp_pipeline pipe;
+	int rval;
 
-	rval = isp_calc_pipeline(dev, pix_input, pix_output);
-	if (rval)
-		goto out;
-
-	rval = isp_try_size(dev, pix_input, pix_output);
-	if (rval)
-		goto out;
+	pipe.pix = *pix_output;
 
-	rval = isp_try_fmt(dev, pix_input, pix_output);
+	rval = isp_try_pipeline(dev, pix_input, &pipe);
 	if (rval)
-		goto out;
+		return rval;
 
-out:
-	return rval;
-}
-EXPORT_SYMBOL(isp_try_fmt_cap);
-
-/**
- * isp_try_size - Tries size configuration for I/O images of each ISP submodule
- * @pix_input: Pointer to V4L2 pixel format structure for input image.
- * @pix_output: Pointer to V4L2 pixel format structure for output image.
- *
- * Returns 0 if successful, or return value of ispccdc_try_size,
- * isppreview_try_size, or ispresizer_try_size (depending on the pipeline
- * configuration) if there is an error.
- **/
-static int isp_try_size(struct device *dev, struct v4l2_pix_format *pix_input,
-			struct v4l2_pix_format *pix_output)
-{
-	struct isp_device *isp = dev_get_drvdata(dev);
-	int rval = 0;
-
-	if (pix_output->width <= ISPRSZ_MIN_OUTPUT
-	    || pix_output->height <= ISPRSZ_MIN_OUTPUT)
-		return -EINVAL;
-
-	if (pix_output->width >= ISPRSZ_MAX_OUTPUT
-	    || pix_output->height > ISPRSZ_MAX_OUTPUT)
-		return -EINVAL;
-
-	isp->module.ccdc_input_width = pix_input->width;
-	isp->module.ccdc_input_height = pix_input->height;
-	isp->module.resizer_output_width = pix_output->width;
-	isp->module.resizer_output_height = pix_output->height;
-
-	if (isp->module.isp_pipeline & OMAP_ISP_CCDC) {
-		rval = ispccdc_try_size(&isp->isp_ccdc,
-					isp->module.ccdc_input_width,
-					isp->module.ccdc_input_height,
-					&isp->module.ccdc_output_width,
-					&isp->module.ccdc_output_height);
-		if (rval) {
-			dev_err(dev, "the dimensions %dx%d are not"
-			       " supported\n", pix_input->width,
-			       pix_input->height);
-			return rval;
-		}
-		pix_output->width = isp->module.ccdc_output_width;
-		pix_output->height = isp->module.ccdc_output_height;
-	}
-
-	if (isp->module.isp_pipeline & OMAP_ISP_PREVIEW) {
-		isp->module.preview_input_width = isp->module.ccdc_output_width;
-		isp->module.preview_input_height =
-			isp->module.ccdc_output_height;
-		rval = isppreview_try_size(&isp->isp_prev,
-					   isp->module.preview_input_width,
-					   isp->module.preview_input_height,
-					   &isp->module.preview_output_width,
-					   &isp->module.preview_output_height);
-		if (rval) {
-			dev_err(dev, "the dimensions %dx%d are not"
-			       " supported\n", pix_input->width,
-			       pix_input->height);
-			return rval;
-		}
-		pix_output->width = isp->module.preview_output_width;
-		pix_output->height = isp->module.preview_output_height;
-	}
-
-	if (isp->module.isp_pipeline & OMAP_ISP_RESIZER) {
-		isp->module.resizer_input_width =
-			isp->module.preview_output_width;
-		isp->module.resizer_input_height =
-			isp->module.preview_output_height;
-		rval = ispresizer_try_size(&isp->isp_res,
-					   &isp->module.resizer_input_width,
-					   &isp->module.resizer_input_height,
-					   &isp->module.resizer_output_width,
-					   &isp->module.resizer_output_height);
-		if (rval) {
-			dev_err(dev, "The dimensions %dx%d are not"
-			       " supported\n", pix_input->width,
-			       pix_input->height);
-			return rval;
-		}
-		pix_output->width = isp->module.resizer_output_width;
-		pix_output->height = isp->module.resizer_output_height;
-	}
-
-	return rval;
-}
-
-/**
- * isp_try_fmt - Validates input/output format parameters.
- * @pix_input: Pointer to V4L2 pixel format structure for input image.
- * @pix_output: Pointer to V4L2 pixel format structure for output image.
- *
- * Always returns 0.
- **/
-int isp_try_fmt(struct device *dev, struct v4l2_pix_format *pix_input,
-		struct v4l2_pix_format *pix_output)
-{
-	struct isp_device *isp = dev_get_drvdata(dev);
-	int ifmt;
-
-	for (ifmt = 0; ifmt < NUM_ISP_CAPTURE_FORMATS; ifmt++) {
-		if (pix_output->pixelformat == isp_formats[ifmt].pixelformat)
-			break;
-	}
-	if (ifmt == NUM_ISP_CAPTURE_FORMATS)
-		ifmt = 1;
-	pix_output->pixelformat = isp_formats[ifmt].pixelformat;
-	pix_output->field = V4L2_FIELD_NONE;
-	pix_output->bytesperline = pix_output->width * ISP_BYTES_PER_PIXEL;
-	pix_output->sizeimage =
-		PAGE_ALIGN(pix_output->bytesperline * pix_output->height);
-	pix_output->priv = 0;
-	switch (pix_output->pixelformat) {
-	case V4L2_PIX_FMT_YUYV:
-	case V4L2_PIX_FMT_UYVY:
-		pix_output->colorspace = V4L2_COLORSPACE_JPEG;
-		break;
-	default:
-		pix_output->colorspace = V4L2_COLORSPACE_SRGB;
-	}
-
-	isp->module.pix.pixelformat = pix_output->pixelformat;
-	isp->module.pix.width = pix_output->width;
-	isp->module.pix.height = pix_output->height;
-	isp->module.pix.field = pix_output->field;
-	isp->module.pix.bytesperline = pix_output->bytesperline;
-	isp->module.pix.sizeimage = pix_output->sizeimage;
-	isp->module.pix.priv = pix_output->priv;
-	isp->module.pix.colorspace = pix_output->colorspace;
+	*pix_output = pipe.pix;
 
 	return 0;
 }
-EXPORT_SYMBOL(isp_try_fmt);
+EXPORT_SYMBOL(isp_try_fmt_cap);
 
 /**
  * isp_save_ctx - Saves ISP, CCDC, HIST, H3A, PREV, RESZ & MMU context.
@@ -2011,9 +2023,12 @@ EXPORT_SYMBOL(isp_try_fmt);
  **/
 static void isp_save_ctx(struct device *dev)
 {
+	struct isp_device *isp = dev_get_drvdata(dev);
+
 	isp_save_context(dev, isp_reg_list);
 	ispccdc_save_context(dev);
-	ispmmu_save_context();
+	if (isp->iommu)
+		iommu_save_ctx(isp->iommu);
 	isphist_save_context(dev);
 	isph3a_save_context(dev);
 	isppreview_save_context(dev);
@@ -2028,9 +2043,12 @@ static void isp_save_ctx(struct device *
  **/
 static void isp_restore_ctx(struct device *dev)
 {
+	struct isp_device *isp = dev_get_drvdata(dev);
+
 	isp_restore_context(dev, isp_reg_list);
 	ispccdc_restore_context(dev);
-	ispmmu_restore_context();
+	if (isp->iommu)
+		iommu_restore_ctx(isp->iommu);
 	isphist_restore_context(dev);
 	isph3a_restore_context(dev);
 	isppreview_restore_context(dev);
@@ -2044,17 +2062,22 @@ static int isp_enable_clocks(struct devi
 
 	r = clk_enable(isp->cam_ick);
 	if (r) {
-		DPRINTK_ISPCTRL("ISP_ERR: clk_en for ick failed\n");
+		dev_err(dev, "clk_enable cam_ick failed\n");
 		goto out_clk_enable_ick;
 	}
+	r = clk_set_rate(isp->dpll4_m5_ck, CM_CAM_MCLK_HZ/2);
+	if (r) {
+		dev_err(dev, "clk_set_rate for dpll4_m5_ck failed\n");
+		goto out_clk_enable_mclk;
+	}
 	r = clk_enable(isp->cam_mclk);
 	if (r) {
-		DPRINTK_ISPCTRL("ISP_ERR: clk_en for mclk failed\n");
+		dev_err(dev, "clk_enable cam_mclk failed\n");
 		goto out_clk_enable_mclk;
 	}
 	r = clk_enable(isp->csi2_fck);
 	if (r) {
-		DPRINTK_ISPCTRL("ISP_ERR: clk_en for csi2_fclk failed\n");
+		dev_err(dev, "clk_enable csi2_fck failed\n");
 		goto out_clk_enable_csi2_fclk;
 	}
 	return 0;
@@ -2140,7 +2163,6 @@ int isp_put(void)
 			isp_save_ctx(&pdev->dev);
 			isp_tmp_buf_free(&pdev->dev);
 			isp_release_resources(&pdev->dev);
-			isp->module.isp_pipeline = 0;
 			isp_disable_clocks(&pdev->dev);
 		}
 	}
@@ -2162,7 +2184,6 @@ void isp_save_context(struct device *dev
 	for (; next->reg != ISP_TOK_TERM; next++)
 		next->val = isp_reg_readl(dev, next->mmio_range, next->reg);
 }
-EXPORT_SYMBOL(isp_save_context);
 
 /**
  * isp_restore_context - Restores the values of the ISP module registers.
@@ -2176,7 +2197,6 @@ void isp_restore_context(struct device *
 	for (; next->reg != ISP_TOK_TERM; next++)
 		isp_reg_writel(dev, next->val, next->mmio_range, next->reg);
 }
-EXPORT_SYMBOL(isp_restore_context);
 
 static int isp_remove(struct platform_device *pdev)
 {
@@ -2189,14 +2209,17 @@ static int isp_remove(struct platform_de
 	isp_csi2_cleanup(&pdev->dev);
 	isp_af_exit(&pdev->dev);
 	isp_resizer_cleanup(&pdev->dev);
-	isp_preview_cleanup(&pdev->dev);
-	ispmmu_cleanup();
+	isp_get();
+	if (isp->iommu)
+		iommu_put(isp->iommu);
+	isp_put();
 	isph3a_aewb_cleanup(&pdev->dev);
 	isp_hist_cleanup(&pdev->dev);
 	isp_ccdc_cleanup(&pdev->dev);
 
 	clk_put(isp->cam_ick);
 	clk_put(isp->cam_mclk);
+	clk_put(isp->dpll4_m5_ck);
 	clk_put(isp->csi2_fck);
 	clk_put(isp->l3_ick);
 
@@ -2230,8 +2253,7 @@ static int isp_suspend(struct platform_d
 
 	DPRINTK_ISPCTRL("isp_suspend: starting\n");
 
-	if (mutex_is_locked(&isp->isp_mutex))
-		dev_err(&pdev->dev, "%s: bug: isp_mutex is locked\n", __func__);
+	WARN_ON(mutex_is_locked(&isp->isp_mutex));
 
 	if (isp->ref_count == 0)
 		goto out;
@@ -2257,9 +2279,6 @@ static int isp_resume(struct platform_de
 
 	DPRINTK_ISPCTRL("isp_resume: starting\n");
 
-	if (mutex_is_locked(&isp->isp_mutex))
-		dev_err(&pdev->dev, "%s: bug: isp_mutex is locked\n", __func__);
-
 	if (isp->ref_count == 0)
 		goto out;
 
@@ -2282,6 +2301,7 @@ out:
 
 #endif /* CONFIG_PM */
 
+static u64 raw_dmamask = DMA_32BIT_MASK;
 
 static int isp_probe(struct platform_device *pdev)
 {
@@ -2305,15 +2325,16 @@ static int isp_probe(struct platform_dev
 		mem = platform_get_resource(pdev, IORESOURCE_MEM, i);
 		if (!mem) {
 			dev_err(isp->dev, "no mem resource?\n");
-			return -ENODEV;
+			ret_err = -ENODEV;
+			goto out_free_mmio;
 		}
 
 		if (!request_mem_region(mem->start, mem->end - mem->start + 1,
 					pdev->name)) {
 			dev_err(isp->dev,
 				"cannot reserve camera register I/O region\n");
-			return -ENODEV;
-
+			ret_err = -ENODEV;
+			goto out_free_mmio;
 		}
 		isp->mmio_base_phys[i] = mem->start;
 		isp->mmio_size[i] = mem->end - mem->start + 1;
@@ -2325,43 +2346,52 @@ static int isp_probe(struct platform_dev
 		if (!isp->mmio_base[i]) {
 			dev_err(isp->dev,
 				"cannot map camera register I/O region\n");
-			return -ENODEV;
+			ret_err = -ENODEV;
+			goto out_free_mmio;
 		}
 	}
 
 	isp->irq_num = platform_get_irq(pdev, 0);
 	if (isp->irq_num <= 0) {
 		dev_err(isp->dev, "no irq for camera?\n");
-		return -ENODEV;
+		ret_err = -ENODEV;
+		goto out_free_mmio;
 	}
 
 	isp->cam_ick = clk_get(&camera_dev, "cam_ick");
 	if (IS_ERR(isp->cam_ick)) {
-		DPRINTK_ISPCTRL("ISP_ERR: clk_get for cam_ick failed\n");
-		return PTR_ERR(isp->cam_ick);
+		dev_err(isp->dev, "clk_get cam_ick failed\n");
+		ret_err = PTR_ERR(isp->cam_ick);
+		goto out_free_mmio;
 	}
 	isp->cam_mclk = clk_get(&camera_dev, "cam_mclk");
 	if (IS_ERR(isp->cam_mclk)) {
-		DPRINTK_ISPCTRL("ISP_ERR: clk_get for cam_mclk failed\n");
+		dev_err(isp->dev, "clk_get cam_mclk failed\n");
 		ret_err = PTR_ERR(isp->cam_mclk);
 		goto out_clk_get_mclk;
 	}
+	isp->dpll4_m5_ck = clk_get(&camera_dev, "dpll4_m5_ck");
+	if (IS_ERR(isp->dpll4_m5_ck)) {
+		dev_err(isp->dev, "clk_get dpll4_m5_ck failed\n");
+		ret_err = PTR_ERR(isp->dpll4_m5_ck);
+		goto out_clk_get_dpll4_m5_ck;
+	}
 	isp->csi2_fck = clk_get(&camera_dev, "csi2_96m_fck");
 	if (IS_ERR(isp->csi2_fck)) {
-		DPRINTK_ISPCTRL("ISP_ERR: clk_get for csi2_fclk failed\n");
+		dev_err(isp->dev, "clk_get csi2_96m_fck failed\n");
 		ret_err = PTR_ERR(isp->csi2_fck);
 		goto out_clk_get_csi2_fclk;
 	}
 	isp->l3_ick = clk_get(&camera_dev, "l3_ick");
 	if (IS_ERR(isp->l3_ick)) {
-		DPRINTK_ISPCTRL("ISP_ERR: clk_get for l3_ick failed\n");
+		dev_err(isp->dev, "clk_get l3_ick failed\n");
 		ret_err = PTR_ERR(isp->l3_ick);
 		goto out_clk_get_l3_ick;
 	}
 
 	if (request_irq(isp->irq_num, omap34xx_isp_isr, IRQF_SHARED,
 			"Omap 3 Camera ISP", pdev)) {
-		DPRINTK_ISPCTRL("Could not install ISR\n");
+		dev_err(isp->dev, "could not install isr\n");
 		ret_err = -EINVAL;
 		goto out_request_irq;
 	}
@@ -2371,11 +2401,20 @@ static int isp_probe(struct platform_dev
 
 	mutex_init(&(isp->isp_mutex));
 	spin_lock_init(&isp->lock);
-	spin_lock_init(&isp->bufs.lock);
+	spin_lock_init(&isp->h3a_lock);
 
-	ret_err = ispmmu_init();
-	if (ret_err)
-		goto out_ispmmu_init;
+	isp->dev->dma_mask = &raw_dmamask;
+	isp->dev->coherent_dma_mask = DMA_32BIT_MASK;
+
+	isp_get();
+	isp->iommu = iommu_get("isp");
+	if (IS_ERR(isp->iommu)) {
+		ret_err = PTR_ERR(isp->iommu);
+		isp->iommu = NULL;
+	}
+	isp_put();
+	if (!isp->iommu)
+		goto out_iommu_get;
 
 	isp_ccdc_init(&pdev->dev);
 	isp_hist_init(&pdev->dev);
@@ -2389,22 +2428,36 @@ static int isp_probe(struct platform_dev
 	isp_power_settings(&pdev->dev, 1);
 	isp_put();
 
-	isph3a_notify(&isp->isp_h3a, 1);
-	isp_af_notify(&isp->isp_af, 1);
-
 	return 0;
 
-out_ispmmu_init:
+out_iommu_get:
 	free_irq(isp->irq_num, isp);
+	omap3isp_pdev = NULL;
 out_request_irq:
 	clk_put(isp->l3_ick);
 out_clk_get_l3_ick:
 	clk_put(isp->csi2_fck);
 out_clk_get_csi2_fclk:
+	clk_put(isp->dpll4_m5_ck);
+out_clk_get_dpll4_m5_ck:
 	clk_put(isp->cam_mclk);
 out_clk_get_mclk:
 	clk_put(isp->cam_ick);
+out_free_mmio:
+	for (i = 0; i <= OMAP3_ISP_IOMEM_CSI2PHY; i++) {
+		if (isp->mmio_base[i]) {
+			iounmap((void *)isp->mmio_base[i]);
+			isp->mmio_base[i] = 0;
+		}
 
+		if (isp->mmio_base_phys[i]) {
+			release_mem_region(isp->mmio_base_phys[i],
+					   isp->mmio_size[i]);
+			isp->mmio_base_phys[i] = 0;
+		}
+	}
+
+	kfree(isp);
 	return ret_err;
 }
 
@@ -2462,7 +2515,6 @@ void isp_print_status(struct device *dev
 			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
 				      ISP_IRQ0STATUS));
 }
-EXPORT_SYMBOL(isp_print_status);
 
 module_init(isp_init);
 module_exit(isp_cleanup);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispccdc.c kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispccdc.c
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispccdc.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispccdc.c	2012-12-16 13:13:01.664330147 +0100
@@ -27,7 +27,6 @@
 #include "isp.h"
 #include "ispreg.h"
 #include "ispccdc.h"
-#include "ispmmu.h"
 
 #define LSC_TABLE_INIT_SIZE	50052
 
@@ -47,8 +46,8 @@ static struct isp_reg ispccdc_reg_list[]
 	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_DCSUB, 0},
 	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_COLPTN, 0},
 	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_BLKCMP, 0},
-	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC, 0},
 	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC_ADDR, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC, 0},
 	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_VDINT, 0},
 	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_ALAW, 0},
 	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_REC656IF, 0},
@@ -87,6 +86,7 @@ static struct isp_reg ispccdc_reg_list[]
 int omap34xx_isp_ccdc_config(struct isp_ccdc_device *isp_ccdc,
 			     void *userspace_add)
 {
+	struct isp_device *isp = to_isp_device(isp_ccdc);
 	struct ispccdc_bclamp bclamp_t;
 	struct ispccdc_blcomp blcomp_t;
 	struct ispccdc_fpc fpc_t;
@@ -151,7 +151,7 @@ int omap34xx_isp_ccdc_config(struct isp_
 			isp_ccdc->fpc_table_add = kmalloc(64 + fpc_t.fpnum * 4,
 						GFP_KERNEL | GFP_DMA);
 			if (!isp_ccdc->fpc_table_add) {
-				dev_err(isp_ccdc->dev,
+				dev_err(to_device(isp_ccdc),
 					"ccdc: Cannot allocate memory for"
 					" FPC table");
 				return -ENOMEM;
@@ -161,9 +161,14 @@ int omap34xx_isp_ccdc_config(struct isp_
 			       != (unsigned long)isp_ccdc->fpc_table_add)
 				isp_ccdc->fpc_table_add++;
 
-			isp_ccdc->fpc_table_add_m = ispmmu_kmap(virt_to_phys
-						      (isp_ccdc->fpc_table_add),
-						      fpc_t.fpnum * 4);
+			isp_ccdc->fpc_table_add_m = iommu_kmap(
+				isp->iommu,
+				0,
+				virt_to_phys(isp_ccdc->fpc_table_add),
+				fpc_t.fpnum * 4,
+				IOMMU_FLAG);
+			/* FIXME: Correct unwinding */
+			BUG_ON(IS_ERR_VALUE(isp_ccdc->fpc_table_add_m));
 
 			if (copy_from_user(isp_ccdc->fpc_table_add,
 					   (u32 *)fpc_t.fpcaddr,
@@ -217,10 +222,9 @@ int omap34xx_isp_ccdc_config(struct isp_
 	return 0;
 
 copy_from_user_err:
-	dev_err(isp_ccdc->dev, "ccdc: Config: copy from user error");
+	dev_err(isp->dev, "ccdc: Config: copy from user error");
 	return -EINVAL ;
 }
-EXPORT_SYMBOL(omap34xx_isp_ccdc_config);
 
 /**
  * Set the value to be used for CCDC_CFG.WENLOG.
@@ -230,7 +234,6 @@ void ispccdc_set_wenlog(struct isp_ccdc_
 {
 	isp_ccdc->wenlog = wenlog;
 }
-EXPORT_SYMBOL(ispccdc_set_wenlog);
 
 /**
  * ispccdc_request - Reserves the CCDC module.
@@ -241,6 +244,8 @@ EXPORT_SYMBOL(ispccdc_set_wenlog);
  **/
 int ispccdc_request(struct isp_ccdc_device *isp_ccdc)
 {
+	struct device *dev = to_device(isp_ccdc);
+
 	mutex_lock(&isp_ccdc->mutexlock);
 	if (isp_ccdc->ccdc_inuse) {
 		mutex_unlock(&isp_ccdc->mutexlock);
@@ -250,14 +255,13 @@ int ispccdc_request(struct isp_ccdc_devi
 
 	isp_ccdc->ccdc_inuse = 1;
 	mutex_unlock(&isp_ccdc->mutexlock);
-	isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,
+	isp_reg_or(dev, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,
 		   ISPCTRL_CCDC_RAM_EN | ISPCTRL_CCDC_CLK_EN |
 		   ISPCTRL_SBL_WR1_RAM_EN);
-	isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,
+	isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,
 		   ISPCCDC_CFG_VDLC);
 	return 0;
 }
-EXPORT_SYMBOL(ispccdc_request);
 
 /**
  * ispccdc_free - Frees the CCDC module.
@@ -277,13 +281,12 @@ int ispccdc_free(struct isp_ccdc_device
 
 	isp_ccdc->ccdc_inuse = 0;
 	mutex_unlock(&isp_ccdc->mutexlock);
-	isp_reg_and(isp_ccdc->dev, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,
-		    ~(ISPCTRL_CCDC_CLK_EN |
-		      ISPCTRL_CCDC_RAM_EN |
-		      ISPCTRL_SBL_WR1_RAM_EN));
+	isp_reg_and(to_device(isp_ccdc), OMAP3_ISP_IOMEM_MAIN,
+		    ISP_CTRL, ~(ISPCTRL_CCDC_CLK_EN |
+				ISPCTRL_CCDC_RAM_EN |
+				ISPCTRL_SBL_WR1_RAM_EN));
 	return 0;
 }
-EXPORT_SYMBOL(ispccdc_free);
 
 /**
  * ispccdc_free_lsc - Frees Lens Shading Compensation table
@@ -292,15 +295,17 @@ EXPORT_SYMBOL(ispccdc_free);
  **/
 static int ispccdc_free_lsc(struct isp_ccdc_device *isp_ccdc)
 {
+	struct isp_device *isp = to_isp_device(isp_ccdc);
+
 	if (!isp_ccdc->lsc_ispmmu_addr)
 		return 0;
 
 	ispccdc_enable_lsc(isp_ccdc, 0);
 	isp_ccdc->lsc_initialized = 0;
-	isp_reg_writel(isp_ccdc->dev, 0, OMAP3_ISP_IOMEM_CCDC,
+	isp_reg_writel(to_device(isp_ccdc), 0, OMAP3_ISP_IOMEM_CCDC,
 		       ISPCCDC_LSC_TABLE_BASE);
-	ispmmu_kunmap(isp_ccdc->lsc_ispmmu_addr);
-	kfree(isp_ccdc->lsc_gain_table);
+	iommu_vfree(isp->iommu, isp_ccdc->lsc_ispmmu_addr);
+	isp_ccdc->lsc_gain_table = NULL;
 	return 0;
 }
 
@@ -314,6 +319,8 @@ static int ispccdc_free_lsc(struct isp_c
 static int ispccdc_allocate_lsc(struct isp_ccdc_device *isp_ccdc,
 				u32 table_size)
 {
+	struct isp_device *isp = to_isp_device(isp_ccdc);
+
 	if (table_size == 0)
 		return -EINVAL;
 
@@ -323,23 +330,16 @@ static int ispccdc_allocate_lsc(struct i
 
 	ispccdc_free_lsc(isp_ccdc);
 
-	isp_ccdc->lsc_gain_table = kmalloc(table_size, GFP_KERNEL | GFP_DMA);
-
-	if (!isp_ccdc->lsc_gain_table) {
-		dev_err(isp_ccdc->dev,
+	isp_ccdc->lsc_ispmmu_addr = iommu_vmalloc(isp->iommu, 0, table_size,
+						  IOMMU_FLAG);
+	if (IS_ERR_VALUE(isp_ccdc->lsc_ispmmu_addr)) {
+		dev_err(to_device(isp_ccdc),
 			"ccdc: Cannot allocate memory for gain tables\n");
+		isp_ccdc->lsc_ispmmu_addr = 0;
 		return -ENOMEM;
 	}
-
-	isp_ccdc->lsc_ispmmu_addr =
-			ispmmu_kmap(virt_to_phys(isp_ccdc->lsc_gain_table),
-				    table_size);
-	if (isp_ccdc->lsc_ispmmu_addr <= 0) {
-		dev_err(isp_ccdc->dev,
-			"ccdc: Cannot map memory for gain tables\n");
-		kfree(isp_ccdc->lsc_gain_table);
-		return -ENOMEM;
-	}
+	isp_ccdc->lsc_gain_table = da_to_va(isp->iommu,
+					    (u32)isp_ccdc->lsc_ispmmu_addr);
 
 	return 0;
 }
@@ -359,7 +359,7 @@ static int ispccdc_program_lsc(struct is
 	if (isp_ccdc->lsc_initialized)
 		return 0;
 
-	isp_reg_writel(isp_ccdc->dev, isp_ccdc->lsc_ispmmu_addr,
+	isp_reg_writel(to_device(isp_ccdc), isp_ccdc->lsc_ispmmu_addr,
 		       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_TABLE_BASE);
 	isp_ccdc->lsc_initialized = 1;
 	return 0;
@@ -395,7 +395,6 @@ int ispccdc_load_lsc(struct isp_ccdc_dev
 		return ret;
 	return 0;
 }
-EXPORT_SYMBOL(ispccdc_load_lsc);
 
 /**
  * ispccdc_config_lsc - Configures the lens shading compensation module
@@ -404,78 +403,63 @@ EXPORT_SYMBOL(ispccdc_load_lsc);
 void ispccdc_config_lsc(struct isp_ccdc_device *isp_ccdc,
 			struct ispccdc_lsc_config *lsc_cfg)
 {
+	struct device *dev = to_device(isp_ccdc);
 	int reg;
 
 	if (!is_isplsc_activated())
 		return;
 
 	ispccdc_enable_lsc(isp_ccdc, 0);
-	isp_reg_writel(isp_ccdc->dev, lsc_cfg->offset, OMAP3_ISP_IOMEM_CCDC,
+	isp_reg_writel(dev, lsc_cfg->offset, OMAP3_ISP_IOMEM_CCDC,
 		       ISPCCDC_LSC_TABLE_OFFSET);
 
 	reg = 0;
 	reg |= lsc_cfg->gain_mode_n << ISPCCDC_LSC_GAIN_MODE_N_SHIFT;
 	reg |= lsc_cfg->gain_mode_m << ISPCCDC_LSC_GAIN_MODE_M_SHIFT;
 	reg |= lsc_cfg->gain_format << ISPCCDC_LSC_GAIN_FORMAT_SHIFT;
-	isp_reg_writel(isp_ccdc->dev, reg, OMAP3_ISP_IOMEM_CCDC,
-		       ISPCCDC_LSC_CONFIG);
+	isp_reg_writel(dev, reg, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_CONFIG);
 
 	reg = 0;
 	reg &= ~ISPCCDC_LSC_INITIAL_X_MASK;
 	reg |= lsc_cfg->initial_x << ISPCCDC_LSC_INITIAL_X_SHIFT;
 	reg &= ~ISPCCDC_LSC_INITIAL_Y_MASK;
 	reg |= lsc_cfg->initial_y << ISPCCDC_LSC_INITIAL_Y_SHIFT;
-	isp_reg_writel(isp_ccdc->dev, reg, OMAP3_ISP_IOMEM_CCDC,
+	isp_reg_writel(dev, reg, OMAP3_ISP_IOMEM_CCDC,
 		       ISPCCDC_LSC_INITIAL);
 }
-EXPORT_SYMBOL(ispccdc_config_lsc);
 
-int __ispccdc_enable_lsc(struct isp_ccdc_device *isp_ccdc, u8 enable)
+/**
+ * ispccdc_enable_lsc - Enables/Disables the Lens Shading Compensation module.
+ * @enable: 0 Disables LSC, 1 Enables LSC.
+ **/
+void ispccdc_enable_lsc(struct isp_ccdc_device *isp_ccdc, u8 enable)
 {
+	struct device *dev = to_device(isp_ccdc);
+
 	if (!is_isplsc_activated())
-		return -ENODEV;
+		return;
 
 	if (enable) {
 		if (!ispccdc_busy(isp_ccdc)) {
-			isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_MAIN,
+			isp_reg_or(dev, OMAP3_ISP_IOMEM_MAIN,
 				   ISP_CTRL, ISPCTRL_SBL_SHARED_RPORTB
 				   | ISPCTRL_SBL_RD_RAM_EN);
 
-			isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC,
 				   ISPCCDC_LSC_CONFIG, 0x1);
 
 			isp_ccdc->lsc_state = 1;
 		} else {
 			/* Postpone enabling LSC */
 			isp_ccdc->lsc_enable = 1;
-			return -EBUSY;
 		}
 	} else {
-		isp_reg_and(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_CCDC,
 			    ISPCCDC_LSC_CONFIG, 0xFFFE);
 		isp_ccdc->lsc_state = 0;
 		isp_ccdc->lsc_enable = 0;
 	}
-
-	return 0;
-}
-
-/**
- * ispccdc_enable_lsc - Enables/Disables the Lens Shading Compensation module.
- * @enable: 0 Disables LSC, 1 Enables LSC.
- **/
-void ispccdc_enable_lsc(struct isp_ccdc_device *isp_ccdc, u8 enable)
-{
-	if (__ispccdc_enable_lsc(isp_ccdc, enable)) {
-		if (enable)
-			isp_ccdc->lsc_state = 1;
-		else {
-			isp_ccdc->lsc_state = 0;
-			isp_ccdc->lsc_enable = 0;
-		}
-	}
 }
-EXPORT_SYMBOL(ispccdc_enable_lsc);
 
 void ispccdc_lsc_error_handler(struct isp_ccdc_device *isp_ccdc)
 {
@@ -534,9 +518,11 @@ void ispccdc_config_crop(struct isp_ccdc
  * Returns 0 if successful, or -EINVAL if wrong I/O combination or wrong input
  * or output values.
  **/
-int ispccdc_config_datapath(struct isp_ccdc_device *isp_ccdc,
-			    enum ccdc_input input, enum ccdc_output output)
+static int ispccdc_config_datapath(struct isp_ccdc_device *isp_ccdc,
+				   struct isp_pipeline *pipe)
 {
+	struct device *dev = to_device(isp_ccdc);
+
 	u32 syn_mode = 0;
 	struct ispccdc_vp vpcfg;
 	struct ispccdc_syncif syncif;
@@ -559,17 +545,9 @@ int ispccdc_config_datapath(struct isp_c
 		ISPCCDC_COLPTN_B_Mg << ISPCCDC_COLPTN_CP3PLC2_SHIFT |
 		ISPCCDC_COLPTN_Gb_G << ISPCCDC_COLPTN_CP3PLC3_SHIFT;
 
-	/* CCDC does not convert the image format */
-	if ((input == CCDC_RAW || input == CCDC_OTHERS) &&
-	    output == CCDC_YUV_RSZ) {
-		DPRINTK_ISPCCDC("ISP_ERR: Wrong CCDC I/O Combination\n");
-		return -EINVAL;
-	}
-
-	syn_mode = isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
-				 ISPCCDC_SYN_MODE);
+	syn_mode = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE);
 
-	switch (output) {
+	switch (pipe->ccdc_out) {
 	case CCDC_YUV_RSZ:
 		syn_mode |= ISPCCDC_SYN_MODE_SDR2RSZ;
 		syn_mode &= ~ISPCCDC_SYN_MODE_WEN;
@@ -596,7 +574,7 @@ int ispccdc_config_datapath(struct isp_c
 		syn_mode &= ~ISPCCDC_SYN_MODE_SDR2RSZ;
 		syn_mode |= ISPCCDC_SYN_MODE_WEN;
 		syn_mode &= ~ISPCCDC_SYN_MODE_EXWEN;
-		isp_reg_and(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,
 			    ~ISPCCDC_CFG_WENLOG);
 		vpcfg.bitshift_sel = BIT11_2;
 		vpcfg.freq_sel = PIXCLKBY2;
@@ -610,9 +588,8 @@ int ispccdc_config_datapath(struct isp_c
 		syn_mode |= ISPCCDC_SYN_MODE_WEN;
 		syn_mode &= ~ISPCCDC_SYN_MODE_EXWEN;
 
-		isp_reg_and_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
-			       ISPCCDC_CFG, ~ISPCCDC_CFG_WENLOG,
-			       isp_ccdc->wenlog);
+		isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,
+			       ~ISPCCDC_CFG_WENLOG, isp_ccdc->wenlog);
 		vpcfg.bitshift_sel = BIT9_0;
 		vpcfg.freq_sel = PIXCLKBY2;
 		ispccdc_config_vp(isp_ccdc, vpcfg);
@@ -623,10 +600,9 @@ int ispccdc_config_datapath(struct isp_c
 		return -EINVAL;
 	};
 
-	isp_reg_writel(isp_ccdc->dev, syn_mode, OMAP3_ISP_IOMEM_CCDC,
-		       ISPCCDC_SYN_MODE);
+	isp_reg_writel(dev, syn_mode, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE);
 
-	switch (input) {
+	switch (pipe->ccdc_in) {
 	case CCDC_RAW:
 		syncif.ccdc_mastermode = 0;
 		syncif.datapol = 0;
@@ -640,6 +616,7 @@ int ispccdc_config_datapath(struct isp_c
 		syncif.vdpol = 0;
 		ispccdc_config_sync_if(isp_ccdc, syncif);
 		ispccdc_config_imgattr(isp_ccdc, colptn);
+		blkcfg.oblen = 0;
 		blkcfg.dcsubval = 64;
 		ispccdc_config_black_clamp(isp_ccdc, blkcfg);
 		if (is_isplsc_activated()) {
@@ -662,6 +639,7 @@ int ispccdc_config_datapath(struct isp_c
 		syncif.vdpol = 1;
 		ispccdc_config_imgattr(isp_ccdc, 0);
 		ispccdc_config_sync_if(isp_ccdc, syncif);
+		blkcfg.oblen = 0;
 		blkcfg.dcsubval = 0;
 		ispccdc_config_black_clamp(isp_ccdc, blkcfg);
 		break;
@@ -674,13 +652,10 @@ int ispccdc_config_datapath(struct isp_c
 		return -EINVAL;
 	}
 
-	isp_ccdc->ccdc_inpfmt = input;
-	isp_ccdc->ccdc_outfmt = output;
-	ispccdc_print_status(isp_ccdc);
-	isp_print_status(isp_ccdc->dev);
+	ispccdc_print_status(isp_ccdc, pipe);
+	isp_print_status(dev);
 	return 0;
 }
-EXPORT_SYMBOL(ispccdc_config_datapath);
 
 /**
  * ispccdc_config_sync_if - Sets the sync i/f params between sensor and CCDC.
@@ -691,7 +666,8 @@ EXPORT_SYMBOL(ispccdc_config_datapath);
 void ispccdc_config_sync_if(struct isp_ccdc_device *isp_ccdc,
 			    struct ispccdc_syncif syncif)
 {
-	u32 syn_mode = isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+	struct device *dev = to_device(isp_ccdc);
+	u32 syn_mode = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				     ISPCCDC_SYN_MODE);
 
 	syn_mode |= ISPCCDC_SYN_MODE_VDHDEN;
@@ -758,13 +734,13 @@ void ispccdc_config_sync_if(struct isp_c
 
 	if (syncif.ccdc_mastermode) {
 		syn_mode |= ISPCCDC_SYN_MODE_FLDOUT | ISPCCDC_SYN_MODE_VDHDOUT;
-		isp_reg_writel(isp_ccdc->dev,
+		isp_reg_writel(dev,
 			       syncif.hs_width << ISPCCDC_HD_VD_WID_HDW_SHIFT
 			       | syncif.vs_width << ISPCCDC_HD_VD_WID_VDW_SHIFT,
 			       OMAP3_ISP_IOMEM_CCDC,
 			       ISPCCDC_HD_VD_WID);
 
-		isp_reg_writel(isp_ccdc->dev,
+		isp_reg_writel(dev,
 			       syncif.ppln << ISPCCDC_PIX_LINES_PPLN_SHIFT
 			       | syncif.hlprf << ISPCCDC_PIX_LINES_HLPRF_SHIFT,
 			       OMAP3_ISP_IOMEM_CCDC,
@@ -773,15 +749,13 @@ void ispccdc_config_sync_if(struct isp_c
 		syn_mode &= ~(ISPCCDC_SYN_MODE_FLDOUT |
 			      ISPCCDC_SYN_MODE_VDHDOUT);
 
-	isp_reg_writel(isp_ccdc->dev, syn_mode, OMAP3_ISP_IOMEM_CCDC,
-		       ISPCCDC_SYN_MODE);
+	isp_reg_writel(dev, syn_mode, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE);
 
 	if (!(syncif.bt_r656_en)) {
-		isp_reg_and(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_CCDC,
 			    ISPCCDC_REC656IF, ~ISPCCDC_REC656IF_R656ON);
 	}
 }
-EXPORT_SYMBOL(ispccdc_config_sync_if);
 
 /**
  * ispccdc_config_black_clamp - Configures the clamp parameters in CCDC.
@@ -797,6 +771,7 @@ EXPORT_SYMBOL(ispccdc_config_sync_if);
 int ispccdc_config_black_clamp(struct isp_ccdc_device *isp_ccdc,
 			       struct ispccdc_bclamp bclamp)
 {
+	struct device *dev = to_device(isp_ccdc);
 	u32 bclamp_val = 0;
 
 	if (isp_ccdc->obclamp_en) {
@@ -804,22 +779,21 @@ int ispccdc_config_black_clamp(struct is
 		bclamp_val |= bclamp.oblen << ISPCCDC_CLAMP_OBSLEN_SHIFT;
 		bclamp_val |= bclamp.oblines << ISPCCDC_CLAMP_OBSLN_SHIFT;
 		bclamp_val |= bclamp.obstpixel << ISPCCDC_CLAMP_OBST_SHIFT;
-		isp_reg_writel(isp_ccdc->dev, bclamp_val,
+		isp_reg_writel(dev, bclamp_val,
 			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CLAMP);
 	} else {
 		if (omap_rev() < OMAP3430_REV_ES2_0)
 			if (isp_ccdc->syncif_ipmod == YUV16 ||
 			    isp_ccdc->syncif_ipmod == YUV8 ||
-			    isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			    isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 					  ISPCCDC_REC656IF) &
 			    ISPCCDC_REC656IF_R656ON)
 				bclamp.dcsubval = 0;
-		isp_reg_writel(isp_ccdc->dev, bclamp.dcsubval,
+		isp_reg_writel(dev, bclamp.dcsubval,
 			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_DCSUB);
 	}
 	return 0;
 }
-EXPORT_SYMBOL(ispccdc_config_black_clamp);
 
 /**
  * ispccdc_enable_black_clamp - Enables/Disables the optical black clamp.
@@ -830,12 +804,13 @@ EXPORT_SYMBOL(ispccdc_config_black_clamp
  **/
 void ispccdc_enable_black_clamp(struct isp_ccdc_device *isp_ccdc, u8 enable)
 {
-	isp_reg_and_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CLAMP,
+	struct device *dev = to_device(isp_ccdc);
+
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CLAMP,
 		       ~ISPCCDC_CLAMP_CLAMPEN,
 		       enable ? ISPCCDC_CLAMP_CLAMPEN : 0);
 	isp_ccdc->obclamp_en = enable;
 }
-EXPORT_SYMBOL(ispccdc_enable_black_clamp);
 
 /**
  * ispccdc_config_fpc - Configures the Faulty Pixel Correction parameters.
@@ -847,26 +822,24 @@ EXPORT_SYMBOL(ispccdc_enable_black_clamp
  **/
 int ispccdc_config_fpc(struct isp_ccdc_device *isp_ccdc, struct ispccdc_fpc fpc)
 {
+	struct device *dev = to_device(isp_ccdc);
 	u32 fpc_val = 0;
 
-	fpc_val = isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
-				ISPCCDC_FPC);
+	fpc_val = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC);
 
 	if ((fpc.fpcaddr & 0xFFFFFFC0) == fpc.fpcaddr) {
-		isp_reg_writel(isp_ccdc->dev, fpc_val & (~ISPCCDC_FPC_FPCEN),
+		isp_reg_writel(dev, fpc_val & (~ISPCCDC_FPC_FPCEN),
 			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC);
-		isp_reg_writel(isp_ccdc->dev, fpc.fpcaddr,
+		isp_reg_writel(dev, fpc.fpcaddr,
 			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC_ADDR);
 	} else {
 		DPRINTK_ISPCCDC("FPC Address should be on 64byte boundary\n");
 		return -EINVAL;
 	}
-	isp_reg_writel(isp_ccdc->dev, fpc_val |
-		       (fpc.fpnum << ISPCCDC_FPC_FPNUM_SHIFT),
+	isp_reg_writel(dev, fpc_val | (fpc.fpnum << ISPCCDC_FPC_FPNUM_SHIFT),
 		       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC);
 	return 0;
 }
-EXPORT_SYMBOL(ispccdc_config_fpc);
 
 /**
  * ispccdc_enable_fpc - Enables the Faulty Pixel Correction.
@@ -874,11 +847,11 @@ EXPORT_SYMBOL(ispccdc_config_fpc);
  **/
 void ispccdc_enable_fpc(struct isp_ccdc_device *isp_ccdc, u8 enable)
 {
-	isp_reg_and_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC,
-		       ~ISPCCDC_FPC_FPCEN,
-		       enable ? ISPCCDC_FPC_FPCEN : 0);
+	struct device *dev = to_device(isp_ccdc);
+
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC,
+		       ~ISPCCDC_FPC_FPCEN, enable ? ISPCCDC_FPC_FPCEN : 0);
 }
-EXPORT_SYMBOL(ispccdc_enable_fpc);
 
 /**
  * ispccdc_config_black_comp - Configures Black Level Compensation parameters.
@@ -888,6 +861,7 @@ EXPORT_SYMBOL(ispccdc_enable_fpc);
 void ispccdc_config_black_comp(struct isp_ccdc_device *isp_ccdc,
 			       struct ispccdc_blcomp blcomp)
 {
+	struct device *dev = to_device(isp_ccdc);
 	u32 blcomp_val = 0;
 
 	blcomp_val |= blcomp.b_mg << ISPCCDC_BLKCMP_B_MG_SHIFT;
@@ -895,10 +869,9 @@ void ispccdc_config_black_comp(struct is
 	blcomp_val |= blcomp.gr_cy << ISPCCDC_BLKCMP_GR_CY_SHIFT;
 	blcomp_val |= blcomp.r_ye << ISPCCDC_BLKCMP_R_YE_SHIFT;
 
-	isp_reg_writel(isp_ccdc->dev, blcomp_val, OMAP3_ISP_IOMEM_CCDC,
+	isp_reg_writel(dev, blcomp_val, OMAP3_ISP_IOMEM_CCDC,
 		       ISPCCDC_BLKCMP);
 }
-EXPORT_SYMBOL(ispccdc_config_black_comp);
 
 /**
  * ispccdc_config_vp - Configures the Video Port Configuration parameters.
@@ -908,7 +881,8 @@ EXPORT_SYMBOL(ispccdc_config_black_comp)
 void ispccdc_config_vp(struct isp_ccdc_device *isp_ccdc,
 		       struct ispccdc_vp vpcfg)
 {
-	u32 fmtcfg_vp = isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+	struct device *dev = to_device(isp_ccdc);
+	u32 fmtcfg_vp = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_FMTCFG);
 
 	fmtcfg_vp &= ISPCCDC_FMTCFG_VPIN_MASK & ISPCCDC_FMTCFG_VPIF_FRQ_MASK;
@@ -944,10 +918,8 @@ void ispccdc_config_vp(struct isp_ccdc_d
 		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIF_FRQ_BY6;
 		break;
 	};
-	isp_reg_writel(isp_ccdc->dev, fmtcfg_vp, OMAP3_ISP_IOMEM_CCDC,
-		       ISPCCDC_FMTCFG);
+	isp_reg_writel(dev, fmtcfg_vp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG);
 }
-EXPORT_SYMBOL(ispccdc_config_vp);
 
 /**
  * ispccdc_enable_vp - Enables the Video Port.
@@ -955,11 +927,12 @@ EXPORT_SYMBOL(ispccdc_config_vp);
  **/
 void ispccdc_enable_vp(struct isp_ccdc_device *isp_ccdc, u8 enable)
 {
-	isp_reg_and_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG,
+	struct device *dev = to_device(isp_ccdc);
+
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG,
 		       ~ISPCCDC_FMTCFG_VPEN,
 		       enable ? ISPCCDC_FMTCFG_VPEN : 0);
 }
-EXPORT_SYMBOL(ispccdc_enable_vp);
 
 /**
  * ispccdc_config_reformatter - Configures the Reformatter.
@@ -972,10 +945,10 @@ EXPORT_SYMBOL(ispccdc_enable_vp);
 void ispccdc_config_reformatter(struct isp_ccdc_device *isp_ccdc,
 				struct ispccdc_refmt refmt)
 {
+	struct device *dev = to_device(isp_ccdc);
 	u32 fmtcfg_val = 0;
 
-	fmtcfg_val = isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
-				   ISPCCDC_FMTCFG);
+	fmtcfg_val = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG);
 
 	if (refmt.lnalt)
 		fmtcfg_val |= ISPCCDC_FMTCFG_LNALT;
@@ -987,35 +960,33 @@ void ispccdc_config_reformatter(struct i
 			ISPCCDC_FMTCFG_PLEN_EVEN_SHIFT;
 		fmtcfg_val |= refmt.plen_odd << ISPCCDC_FMTCFG_PLEN_ODD_SHIFT;
 
-		isp_reg_writel(isp_ccdc->dev, refmt.prgeven0,
+		isp_reg_writel(dev, refmt.prgeven0,
 			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PRGEVEN0);
-		isp_reg_writel(isp_ccdc->dev, refmt.prgeven1,
+		isp_reg_writel(dev, refmt.prgeven1,
 			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PRGEVEN1);
-		isp_reg_writel(isp_ccdc->dev, refmt.prgodd0,
+		isp_reg_writel(dev, refmt.prgodd0,
 			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PRGODD0);
-		isp_reg_writel(isp_ccdc->dev, refmt.prgodd1,
+		isp_reg_writel(dev, refmt.prgodd1,
 			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PRGODD1);
-		isp_reg_writel(isp_ccdc->dev, refmt.fmtaddr0,
+		isp_reg_writel(dev, refmt.fmtaddr0,
 			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR0);
-		isp_reg_writel(isp_ccdc->dev, refmt.fmtaddr1,
+		isp_reg_writel(dev, refmt.fmtaddr1,
 			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR1);
-		isp_reg_writel(isp_ccdc->dev, refmt.fmtaddr2,
+		isp_reg_writel(dev, refmt.fmtaddr2,
 			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR2);
-		isp_reg_writel(isp_ccdc->dev, refmt.fmtaddr3,
+		isp_reg_writel(dev, refmt.fmtaddr3,
 			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR3);
-		isp_reg_writel(isp_ccdc->dev, refmt.fmtaddr4,
+		isp_reg_writel(dev, refmt.fmtaddr4,
 			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR4);
-		isp_reg_writel(isp_ccdc->dev, refmt.fmtaddr5,
+		isp_reg_writel(dev, refmt.fmtaddr5,
 			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR5);
-		isp_reg_writel(isp_ccdc->dev, refmt.fmtaddr6,
+		isp_reg_writel(dev, refmt.fmtaddr6,
 			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR6);
-		isp_reg_writel(isp_ccdc->dev, refmt.fmtaddr7,
+		isp_reg_writel(dev, refmt.fmtaddr7,
 			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR7);
 	}
-	isp_reg_writel(isp_ccdc->dev, fmtcfg_val, OMAP3_ISP_IOMEM_CCDC,
-		       ISPCCDC_FMTCFG);
+	isp_reg_writel(dev, fmtcfg_val, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG);
 }
-EXPORT_SYMBOL(ispccdc_config_reformatter);
 
 /**
  * ispccdc_enable_reformatter - Enables the Reformatter.
@@ -1023,12 +994,13 @@ EXPORT_SYMBOL(ispccdc_config_reformatter
  **/
 void ispccdc_enable_reformatter(struct isp_ccdc_device *isp_ccdc, u8 enable)
 {
-	isp_reg_and_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG,
+	struct device *dev = to_device(isp_ccdc);
+
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG,
 		       ~ISPCCDC_FMTCFG_FMTEN,
 		       enable ? ISPCCDC_FMTCFG_FMTEN : 0);
 	isp_ccdc->refmt_en = enable;
 }
-EXPORT_SYMBOL(ispccdc_enable_reformatter);
 
 /**
  * ispccdc_config_culling - Configures the culling parameters.
@@ -1038,16 +1010,17 @@ EXPORT_SYMBOL(ispccdc_enable_reformatter
 void ispccdc_config_culling(struct isp_ccdc_device *isp_ccdc,
 			    struct ispccdc_culling cull)
 {
+	struct device *dev = to_device(isp_ccdc);
+
 	u32 culling_val = 0;
 
 	culling_val |= cull.v_pattern << ISPCCDC_CULLING_CULV_SHIFT;
 	culling_val |= cull.h_even << ISPCCDC_CULLING_CULHEVN_SHIFT;
 	culling_val |= cull.h_odd << ISPCCDC_CULLING_CULHODD_SHIFT;
 
-	isp_reg_writel(isp_ccdc->dev, culling_val, OMAP3_ISP_IOMEM_CCDC,
+	isp_reg_writel(dev, culling_val, OMAP3_ISP_IOMEM_CCDC,
 		       ISPCCDC_CULLING);
 }
-EXPORT_SYMBOL(ispccdc_config_culling);
 
 /**
  * ispccdc_enable_lpf - Enables the Low-Pass Filter (LPF).
@@ -1055,11 +1028,12 @@ EXPORT_SYMBOL(ispccdc_config_culling);
  **/
 void ispccdc_enable_lpf(struct isp_ccdc_device *isp_ccdc, u8 enable)
 {
-	isp_reg_and_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE,
+	struct device *dev = to_device(isp_ccdc);
+
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE,
 		       ~ISPCCDC_SYN_MODE_LPF,
 		       enable ? ISPCCDC_SYN_MODE_LPF : 0);
 }
-EXPORT_SYMBOL(ispccdc_enable_lpf);
 
 /**
  * ispccdc_config_alaw - Configures the input width for A-law.
@@ -1068,10 +1042,11 @@ EXPORT_SYMBOL(ispccdc_enable_lpf);
 void ispccdc_config_alaw(struct isp_ccdc_device *isp_ccdc,
 			 enum alaw_ipwidth ipwidth)
 {
-	isp_reg_writel(isp_ccdc->dev, ipwidth << ISPCCDC_ALAW_GWDI_SHIFT,
+	struct device *dev = to_device(isp_ccdc);
+
+	isp_reg_writel(dev, ipwidth << ISPCCDC_ALAW_GWDI_SHIFT,
 		       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_ALAW);
 }
-EXPORT_SYMBOL(ispccdc_config_alaw);
 
 /**
  * ispccdc_enable_alaw - Enables the A-law compression.
@@ -1079,11 +1054,12 @@ EXPORT_SYMBOL(ispccdc_config_alaw);
  **/
 void ispccdc_enable_alaw(struct isp_ccdc_device *isp_ccdc, u8 enable)
 {
-	isp_reg_and_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_ALAW,
+	struct device *dev = to_device(isp_ccdc);
+
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_ALAW,
 		       ~ISPCCDC_ALAW_CCDTBL,
 		       enable ? ISPCCDC_ALAW_CCDTBL : 0);
 }
-EXPORT_SYMBOL(ispccdc_enable_alaw);
 
 /**
  * ispccdc_config_imgattr - Configures the sensor image specific attributes.
@@ -1091,10 +1067,10 @@ EXPORT_SYMBOL(ispccdc_enable_alaw);
  **/
 void ispccdc_config_imgattr(struct isp_ccdc_device *isp_ccdc, u32 colptn)
 {
-	isp_reg_writel(isp_ccdc->dev, colptn, OMAP3_ISP_IOMEM_CCDC,
-		       ISPCCDC_COLPTN);
+	struct device *dev = to_device(isp_ccdc);
+
+	isp_reg_writel(dev, colptn, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_COLPTN);
 }
-EXPORT_SYMBOL(ispccdc_config_imgattr);
 
 void ispccdc_config_shadow_registers(struct isp_ccdc_device *isp_ccdc)
 {
@@ -1116,53 +1092,38 @@ void ispccdc_config_shadow_registers(str
  *
  * Returns 0 if successful, or -EINVAL if the input width is less than 2 pixels
  **/
-int ispccdc_try_size(struct isp_ccdc_device *isp_ccdc, u32 input_w, u32 input_h,
-		     u32 *output_w, u32 *output_h)
+int ispccdc_try_pipeline(struct isp_ccdc_device *isp_ccdc,
+			 struct isp_pipeline *pipe)
 {
-	if (input_w < 32 || input_h < 32) {
+	struct device *dev = to_device(isp_ccdc);
+
+	if (pipe->ccdc_in_w < 32 || pipe->ccdc_in_h < 32) {
 		DPRINTK_ISPCCDC("ISP_ERR: CCDC cannot handle input width less"
 				" than 32 pixels or height less than 32\n");
 		return -EINVAL;
 	}
 
-	if (isp_ccdc->crop_w)
-		*output_w = isp_ccdc->crop_w;
-	else
-		*output_w = input_w;
-
-	if (isp_ccdc->crop_h)
-		*output_h = isp_ccdc->crop_h;
-	else
-		*output_h = input_h;
-
-	if (!isp_ccdc->refmt_en
-	    && isp_ccdc->ccdc_outfmt != CCDC_OTHERS_MEM
-	    && isp_ccdc->ccdc_outfmt != CCDC_OTHERS_VP_MEM)
-		*output_h -= 1;
-
-	if (isp_ccdc->ccdc_outfmt == CCDC_OTHERS_MEM
-	    || isp_ccdc->ccdc_outfmt == CCDC_OTHERS_VP_MEM) {
-		if (*output_w % 16) {
-			*output_w -= (*output_w % 16);
-			*output_w += 16;
-		}
+	/* CCDC does not convert the image format */
+	if ((pipe->ccdc_in == CCDC_RAW || pipe->ccdc_in == CCDC_OTHERS)
+	    && pipe->ccdc_out == CCDC_YUV_RSZ) {
+		dev_info(dev, "wrong CCDC I/O Combination\n");
+		return -EINVAL;
 	}
 
-	isp_ccdc->ccdcout_w = *output_w;
-	isp_ccdc->ccdcout_h = *output_h;
-	isp_ccdc->ccdcin_w = input_w;
-	isp_ccdc->ccdcin_h = input_h;
+	pipe->ccdc_out_w = pipe->ccdc_in_w;
+	pipe->ccdc_out_h = pipe->ccdc_in_h;
 
-	DPRINTK_ISPCCDC("try size: ccdcin_w=%u,ccdcin_h=%u,ccdcout_w=%u,"
-			" ccdcout_h=%u\n",
-			isp_ccdc->ccdcin_w,
-			isp_ccdc->ccdcin_h,
-			isp_ccdc->ccdcout_w,
-			isp_ccdc->ccdcout_h);
+	if (!isp_ccdc->refmt_en
+	    && pipe->ccdc_out != CCDC_OTHERS_MEM
+	    && pipe->ccdc_out != CCDC_OTHERS_VP_MEM)
+		pipe->ccdc_out_h -= 1;
+
+	pipe->ccdc_out_w_img = pipe->ccdc_out_w;
+	/* Round up to nearest 16 pixels. */
+	pipe->ccdc_out_w = ALIGN(pipe->ccdc_out_w, 0x10);
 
 	return 0;
 }
-EXPORT_SYMBOL(ispccdc_try_size);
 
 /**
  * ispccdc_config_size - Configure the dimensions of the CCDC input/output
@@ -1178,129 +1139,68 @@ EXPORT_SYMBOL(ispccdc_try_size);
  * Returns 0 if successful, or -EINVAL if try_size was not called before to
  * validate the requested dimensions.
  **/
-int ispccdc_config_size(struct isp_ccdc_device *isp_ccdc, u32 input_w,
-			u32 input_h, u32 output_w, u32 output_h)
+int ispccdc_s_pipeline(struct isp_ccdc_device *isp_ccdc,
+		       struct isp_pipeline *pipe)
 {
-	DPRINTK_ISPCCDC("config size: input_w=%u, input_h=%u, output_w=%u,"
-			" output_h=%u\n",
-			input_w, input_h,
-			output_w, output_h);
-	if (output_w != isp_ccdc->ccdcout_w
-	    || output_h != isp_ccdc->ccdcout_h) {
-		DPRINTK_ISPCCDC("ISP_ERR : ispccdc_try_size should"
-				" be called before config size\n");
-		return -EINVAL;
-	}
+	struct device *dev = to_device(isp_ccdc);
+	int rval;
 
-	if (isp_ccdc->ccdc_outfmt == CCDC_OTHERS_VP) {
-		isp_reg_writel(isp_ccdc->dev, (isp_ccdc->ccdcin_woffset <<
-				ISPCCDC_FMT_HORZ_FMTSPH_SHIFT) |
-			       (isp_ccdc->ccdcin_w <<
-				ISPCCDC_FMT_HORZ_FMTLNH_SHIFT),
-			       OMAP3_ISP_IOMEM_CCDC,
-			       ISPCCDC_FMT_HORZ);
-		isp_reg_writel(isp_ccdc->dev, (isp_ccdc->ccdcin_hoffset <<
-				ISPCCDC_FMT_VERT_FMTSLV_SHIFT) |
-			       (isp_ccdc->ccdcin_h <<
-				ISPCCDC_FMT_VERT_FMTLNV_SHIFT),
-			       OMAP3_ISP_IOMEM_CCDC,
-			       ISPCCDC_FMT_VERT);
-		isp_reg_writel(isp_ccdc->dev, (isp_ccdc->ccdcout_w <<
-				ISPCCDC_VP_OUT_HORZ_NUM_SHIFT) |
-			       (isp_ccdc->ccdcout_h - 1) <<
-			       ISPCCDC_VP_OUT_VERT_NUM_SHIFT,
-			       OMAP3_ISP_IOMEM_CCDC,
-			       ISPCCDC_VP_OUT);
-		isp_reg_writel(isp_ccdc->dev, (((isp_ccdc->ccdcout_h - 25) &
-				 ISPCCDC_VDINT_0_MASK) <<
-				ISPCCDC_VDINT_0_SHIFT) |
-			       ((50 & ISPCCDC_VDINT_1_MASK) <<
-				ISPCCDC_VDINT_1_SHIFT),
-			       OMAP3_ISP_IOMEM_CCDC,
-			       ISPCCDC_VDINT);
+	rval = ispccdc_config_datapath(isp_ccdc, pipe);
+	if (rval)
+		return rval;
+
+	isp_reg_writel(dev,
+		       (0 << ISPCCDC_FMT_HORZ_FMTSPH_SHIFT) |
+		       (pipe->ccdc_in_w <<
+			ISPCCDC_FMT_HORZ_FMTLNH_SHIFT),
+		       OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_FMT_HORZ);
+	isp_reg_writel(dev,
+		       (0 << ISPCCDC_FMT_VERT_FMTSLV_SHIFT) |
+		       (pipe->ccdc_in_h <<
+			ISPCCDC_FMT_VERT_FMTLNV_SHIFT),
+		       OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_FMT_VERT);
+	isp_reg_writel(dev,
+		       0 << ISPCCDC_VERT_START_SLV0_SHIFT,
+		       OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_VERT_START);
+	isp_reg_writel(dev, (pipe->ccdc_out_h - 1) <<
+		       ISPCCDC_VERT_LINES_NLV_SHIFT,
+		       OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_VERT_LINES);
+	isp_reg_writel(dev,
+		       0 << ISPCCDC_HORZ_INFO_SPH_SHIFT
+		       | ((pipe->ccdc_out_w - 1)
+			  << ISPCCDC_HORZ_INFO_NPH_SHIFT),
+		       OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_HORZ_INFO);
+	ispccdc_config_outlineoffset(isp_ccdc,
+				     pipe->ccdc_out_w * ISP_BYTES_PER_PIXEL,
+				     0, 0);
+	isp_reg_writel(dev,
+		       (((pipe->ccdc_out_h - 2) &
+			 ISPCCDC_VDINT_0_MASK) <<
+			ISPCCDC_VDINT_0_SHIFT) |
+		       ((0 & ISPCCDC_VDINT_1_MASK) <<
+			ISPCCDC_VDINT_1_SHIFT),
+		       OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_VDINT);
 
-	} else if (isp_ccdc->ccdc_outfmt == CCDC_OTHERS_MEM) {
-		isp_reg_writel(isp_ccdc->dev, 0, OMAP3_ISP_IOMEM_CCDC,
+	if (pipe->ccdc_out == CCDC_OTHERS_MEM)
+		isp_reg_writel(dev, 0, OMAP3_ISP_IOMEM_CCDC,
 			       ISPCCDC_VP_OUT);
-		if (isp_ccdc->ccdc_inpfmt == CCDC_RAW) {
-			isp_reg_writel(isp_ccdc->dev,
-				       0 << ISPCCDC_HORZ_INFO_SPH_SHIFT
-				       | ((isp_ccdc->ccdcout_w - 1)
-					  << ISPCCDC_HORZ_INFO_NPH_SHIFT),
-				       OMAP3_ISP_IOMEM_CCDC,
-				       ISPCCDC_HORZ_INFO);
-		} else {
-			isp_reg_writel(isp_ccdc->dev,
-				       0 << ISPCCDC_HORZ_INFO_SPH_SHIFT
-				       | ((isp_ccdc->ccdcout_w - 1)
-					  << ISPCCDC_HORZ_INFO_NPH_SHIFT),
-				       OMAP3_ISP_IOMEM_CCDC,
-				       ISPCCDC_HORZ_INFO);
-		}
-		isp_reg_writel(isp_ccdc->dev,
-			       0 << ISPCCDC_VERT_START_SLV0_SHIFT,
-			       OMAP3_ISP_IOMEM_CCDC,
-			       ISPCCDC_VERT_START);
-		isp_reg_writel(isp_ccdc->dev, (isp_ccdc->ccdcout_h - 1) <<
-			       ISPCCDC_VERT_LINES_NLV_SHIFT,
-			       OMAP3_ISP_IOMEM_CCDC,
-			       ISPCCDC_VERT_LINES);
-
-		ispccdc_config_outlineoffset(isp_ccdc, isp_ccdc->ccdcout_w * 2,
-					     0, 0);
-		isp_reg_writel(isp_ccdc->dev, (((isp_ccdc->ccdcout_h - 2) &
-				 ISPCCDC_VDINT_0_MASK) <<
-				ISPCCDC_VDINT_0_SHIFT) |
-			       ((100 & ISPCCDC_VDINT_1_MASK) <<
-				ISPCCDC_VDINT_1_SHIFT),
-			       OMAP3_ISP_IOMEM_CCDC,
-			       ISPCCDC_VDINT);
-	} else if (isp_ccdc->ccdc_outfmt == CCDC_OTHERS_VP_MEM) {
-		isp_reg_writel(isp_ccdc->dev,
-			       (0 << ISPCCDC_FMT_HORZ_FMTSPH_SHIFT) |
-			       (isp_ccdc->ccdcin_w <<
-				ISPCCDC_FMT_HORZ_FMTLNH_SHIFT),
-			       OMAP3_ISP_IOMEM_CCDC,
-			       ISPCCDC_FMT_HORZ);
-		isp_reg_writel(isp_ccdc->dev,
-			       (0 << ISPCCDC_FMT_VERT_FMTSLV_SHIFT) |
-			       ((isp_ccdc->ccdcin_h) <<
-				ISPCCDC_FMT_VERT_FMTLNV_SHIFT),
-			       OMAP3_ISP_IOMEM_CCDC,
-			       ISPCCDC_FMT_VERT);
-		isp_reg_writel(isp_ccdc->dev, (isp_ccdc->ccdcout_w
+	else
+		isp_reg_writel(dev,
+			       (pipe->ccdc_out_w
 				<< ISPCCDC_VP_OUT_HORZ_NUM_SHIFT) |
-			       ((isp_ccdc->ccdcout_h - 1) <<
+			       ((pipe->ccdc_out_h - 1) <<
 				ISPCCDC_VP_OUT_VERT_NUM_SHIFT),
 			       OMAP3_ISP_IOMEM_CCDC,
 			       ISPCCDC_VP_OUT);
-		isp_reg_writel(isp_ccdc->dev,
-			       0 << ISPCCDC_HORZ_INFO_SPH_SHIFT |
-			       ((isp_ccdc->ccdcout_w - 1) <<
-				ISPCCDC_HORZ_INFO_NPH_SHIFT),
-			       OMAP3_ISP_IOMEM_CCDC,
-			       ISPCCDC_HORZ_INFO);
-		isp_reg_writel(isp_ccdc->dev,
-			       0 << ISPCCDC_VERT_START_SLV0_SHIFT,
-			       OMAP3_ISP_IOMEM_CCDC,
-			       ISPCCDC_VERT_START);
-		isp_reg_writel(isp_ccdc->dev, (isp_ccdc->ccdcout_h - 1) <<
-			       ISPCCDC_VERT_LINES_NLV_SHIFT,
-			       OMAP3_ISP_IOMEM_CCDC,
-			       ISPCCDC_VERT_LINES);
-		ispccdc_config_outlineoffset(isp_ccdc, isp_ccdc->ccdcout_w * 2,
-					     0, 0);
-		isp_reg_writel(isp_ccdc->dev, (((isp_ccdc->ccdcout_h - 2) &
-				 ISPCCDC_VDINT_0_MASK) <<
-				ISPCCDC_VDINT_0_SHIFT) |
-			       ((100 & ISPCCDC_VDINT_1_MASK) <<
-				ISPCCDC_VDINT_1_SHIFT),
-			       OMAP3_ISP_IOMEM_CCDC,
-			       ISPCCDC_VDINT);
-	}
 
 	if (is_isplsc_activated()) {
-		if (isp_ccdc->ccdc_inpfmt == CCDC_RAW) {
+		if (pipe->ccdc_in == CCDC_RAW) {
 			ispccdc_config_lsc(isp_ccdc, &isp_ccdc->lsc_config);
 			ispccdc_load_lsc(isp_ccdc, isp_ccdc->lsc_gain_table,
 					 isp_ccdc->lsc_config.size);
@@ -1309,7 +1209,6 @@ int ispccdc_config_size(struct isp_ccdc_
 
 	return 0;
 }
-EXPORT_SYMBOL(ispccdc_config_size);
 
 /**
  * ispccdc_config_outlineoffset - Configures the output line offset
@@ -1330,8 +1229,10 @@ EXPORT_SYMBOL(ispccdc_config_size);
 int ispccdc_config_outlineoffset(struct isp_ccdc_device *isp_ccdc, u32 offset,
 				 u8 oddeven, u8 numlines)
 {
+	struct device *dev = to_device(isp_ccdc);
+
 	if ((offset & ISP_32B_BOUNDARY_OFFSET) == offset) {
-		isp_reg_writel(isp_ccdc->dev, (offset & 0xFFFF),
+		isp_reg_writel(dev, (offset & 0xFFFF),
 			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_HSIZE_OFF);
 	} else {
 		DPRINTK_ISPCCDC("ISP_ERR : Offset should be in 32 byte"
@@ -1339,31 +1240,27 @@ int ispccdc_config_outlineoffset(struct
 		return -EINVAL;
 	}
 
-	isp_reg_and(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
+	isp_reg_and(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
 		    ~ISPCCDC_SDOFST_FINV);
 
-	isp_reg_and(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
+	isp_reg_and(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
 		    ~ISPCCDC_SDOFST_FOFST_4L);
 
 	switch (oddeven) {
 	case EVENEVEN:
-		isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
-			   ISPCCDC_SDOFST,
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
 			   (numlines & 0x7) << ISPCCDC_SDOFST_LOFST0_SHIFT);
 		break;
 	case ODDEVEN:
-		isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
-			   ISPCCDC_SDOFST,
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
 			   (numlines & 0x7) << ISPCCDC_SDOFST_LOFST1_SHIFT);
 		break;
 	case EVENODD:
-		isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
-			   ISPCCDC_SDOFST,
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
 			   (numlines & 0x7) << ISPCCDC_SDOFST_LOFST2_SHIFT);
 		break;
 	case ODDODD:
-		isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
-			   ISPCCDC_SDOFST,
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
 			   (numlines & 0x7) << ISPCCDC_SDOFST_LOFST3_SHIFT);
 		break;
 	default:
@@ -1371,7 +1268,6 @@ int ispccdc_config_outlineoffset(struct
 	}
 	return 0;
 }
-EXPORT_SYMBOL(ispccdc_config_outlineoffset);
 
 /**
  * ispccdc_set_outaddr - Sets the memory address where the output will be saved
@@ -1384,8 +1280,10 @@ EXPORT_SYMBOL(ispccdc_config_outlineoffs
  **/
 int ispccdc_set_outaddr(struct isp_ccdc_device *isp_ccdc, u32 addr)
 {
+	struct device *dev = to_device(isp_ccdc);
+
 	if ((addr & ISP_32B_BOUNDARY_BUF) == addr) {
-		isp_reg_writel(isp_ccdc->dev, addr, OMAP3_ISP_IOMEM_CCDC,
+		isp_reg_writel(dev, addr, OMAP3_ISP_IOMEM_CCDC,
 			       ISPCCDC_SDR_ADDR);
 		return 0;
 	} else {
@@ -1395,13 +1293,20 @@ int ispccdc_set_outaddr(struct isp_ccdc_
 	}
 
 }
-EXPORT_SYMBOL(ispccdc_set_outaddr);
 
-void __ispccdc_enable(struct isp_ccdc_device *isp_ccdc, u8 enable)
+/**
+ * ispccdc_enable - Enables the CCDC module.
+ * @enable: 0 Disables CCDC, 1 Enables CCDC
+ *
+ * Client should configure all the sub modules in CCDC before this.
+ **/
+void ispccdc_enable(struct isp_ccdc_device *isp_ccdc, u8 enable)
 {
+	struct isp_device *isp = to_isp_device(isp_ccdc);
+
 	if (enable) {
 		if (isp_ccdc->lsc_enable
-		    && isp_ccdc->ccdc_inpfmt == CCDC_RAW)
+		    && isp->pipeline.ccdc_in == CCDC_RAW)
 			ispccdc_enable_lsc(isp_ccdc, 1);
 
 	} else {
@@ -1411,53 +1316,10 @@ void __ispccdc_enable(struct isp_ccdc_de
 		isp_ccdc->lsc_enable = lsc_enable;
 	}
 
-	isp_reg_and_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PCR,
+	isp_reg_and_or(isp->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PCR,
 		       ~ISPCCDC_PCR_EN, enable ? ISPCCDC_PCR_EN : 0);
 }
 
-/**
- * ispccdc_enable - Enables the CCDC module.
- * @enable: 0 Disables CCDC, 1 Enables CCDC
- *
- * Client should configure all the sub modules in CCDC before this.
- **/
-void ispccdc_enable(struct isp_ccdc_device *isp_ccdc, u8 enable)
-{
-	__ispccdc_enable(isp_ccdc, enable);
-	isp_ccdc->pm_state = enable;
-}
-EXPORT_SYMBOL(ispccdc_enable);
-
-/**
- * ispccdc_suspend - Suspend the CCDC module.
- **/
-void ispccdc_suspend(struct isp_ccdc_device *isp_ccdc)
-{
-	if (isp_ccdc->pm_state) {
-		if (isp_ccdc->lsc_state)
-			__ispccdc_enable_lsc(isp_ccdc, 0);
-		else if (isp_ccdc->lsc_enable) {
-			isp_ccdc->lsc_state = 1;
-			isp_ccdc->lsc_enable = 0;
-		}
-		__ispccdc_enable(isp_ccdc, 0);
-	}
-}
-EXPORT_SYMBOL(ispccdc_suspend);
-
-/**
- * ispccdc_resume - Resume the CCDC module.
- **/
-void ispccdc_resume(struct isp_ccdc_device *isp_ccdc)
-{
-	if (isp_ccdc->pm_state) {
-		if (isp_ccdc->lsc_state)
-			__ispccdc_enable_lsc(isp_ccdc, 1);
-		__ispccdc_enable(isp_ccdc, 1);
-	}
-}
-EXPORT_SYMBOL(ispccdc_resume);
-
 /*
  * Returns zero if the CCDC is idle and the image has been written to
  * memory, too.
@@ -1465,33 +1327,29 @@ EXPORT_SYMBOL(ispccdc_resume);
 int ispccdc_sbl_busy(void *_isp_ccdc)
 {
 	struct isp_ccdc_device *isp_ccdc = _isp_ccdc;
+	struct device *dev = to_device(isp_ccdc);
 
 	return ispccdc_busy(isp_ccdc)
-		| (isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_SBL,
-				 ISPSBL_CCDC_WR_0) &
+		| (isp_reg_readl(dev, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_0) &
 		   ISPSBL_CCDC_WR_0_DATA_READY)
-		| (isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_SBL,
-				 ISPSBL_CCDC_WR_1) &
+		| (isp_reg_readl(dev, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_1) &
 		   ISPSBL_CCDC_WR_0_DATA_READY)
-		| (isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_SBL,
-				 ISPSBL_CCDC_WR_2) &
+		| (isp_reg_readl(dev, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_2) &
 		   ISPSBL_CCDC_WR_0_DATA_READY)
-		| (isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_SBL,
-				 ISPSBL_CCDC_WR_3) &
+		| (isp_reg_readl(dev, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_3) &
 		   ISPSBL_CCDC_WR_0_DATA_READY);
 }
-EXPORT_SYMBOL(ispccdc_sbl_busy);
 
 /**
  * ispccdc_busy - Gets busy state of the CCDC.
  **/
 int ispccdc_busy(struct isp_ccdc_device *isp_ccdc)
 {
-	return isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
-			     ISPCCDC_PCR) &
+	struct device *dev = to_device(isp_ccdc);
+
+	return isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PCR) &
 		ISPCCDC_PCR_BUSY;
 }
-EXPORT_SYMBOL(ispccdc_busy);
 
 /**
  * ispccdc_save_context - Saves the values of the CCDC module registers
@@ -1501,7 +1359,6 @@ void ispccdc_save_context(struct device
 	DPRINTK_ISPCCDC("Saving context\n");
 	isp_save_context(dev, ispccdc_reg_list);
 }
-EXPORT_SYMBOL(ispccdc_save_context);
 
 /**
  * ispccdc_restore_context - Restores the values of the CCDC module registers
@@ -1511,14 +1368,14 @@ void ispccdc_restore_context(struct devi
 	DPRINTK_ISPCCDC("Restoring context\n");
 	isp_restore_context(dev, ispccdc_reg_list);
 }
-EXPORT_SYMBOL(ispccdc_restore_context);
 
 /**
  * ispccdc_print_status - Prints the values of the CCDC Module registers
  *
  * Also prints other debug information stored in the CCDC module.
  **/
-void ispccdc_print_status(struct isp_ccdc_device *isp_ccdc)
+void ispccdc_print_status(struct isp_ccdc_device *isp_ccdc,
+			  struct isp_pipeline *pipe)
 {
 	if (!is_ispccdc_debug_enabled())
 		return;
@@ -1531,12 +1388,12 @@ void ispccdc_print_status(struct isp_ccd
 			isp_ccdc->ccdcout_w,
 			isp_ccdc->ccdcout_h);
 	DPRINTK_ISPCCDC("###CCDC PCR=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_PCR));
 	DPRINTK_ISPCCDC("ISP_CTRL =0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_MAIN,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
 				      ISP_CTRL));
-	switch (isp_ccdc->ccdc_inpfmt) {
+	switch (pipe->ccdc_in) {
 	case CCDC_RAW:
 		DPRINTK_ISPCCDC("ccdc input format is CCDC_RAW\n");
 		break;
@@ -1546,9 +1403,11 @@ void ispccdc_print_status(struct isp_ccd
 	case CCDC_YUV_BT:
 		DPRINTK_ISPCCDC("ccdc input format is CCDC_YUV_BT\n");
 		break;
+	default:
+		break;
 	}
 
-	switch (isp_ccdc->ccdc_outfmt) {
+	switch (pipe->ccdc_out) {
 	case CCDC_OTHERS_VP:
 		DPRINTK_ISPCCDC("ccdc output format is CCDC_OTHERS_VP\n");
 		break;
@@ -1558,79 +1417,80 @@ void ispccdc_print_status(struct isp_ccd
 	case CCDC_YUV_RSZ:
 		DPRINTK_ISPCCDC("ccdc output format is CCDC_YUV_RSZ\n");
 		break;
+	default:
+		break;
 	}
 
 	DPRINTK_ISPCCDC("###ISP_CTRL in ccdc =0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_MAIN,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
 				      ISP_CTRL));
 	DPRINTK_ISPCCDC("###ISP_IRQ0ENABLE in ccdc =0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_MAIN,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
 				      ISP_IRQ0ENABLE));
 	DPRINTK_ISPCCDC("###ISP_IRQ0STATUS in ccdc =0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_MAIN,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
 				      ISP_IRQ0STATUS));
 	DPRINTK_ISPCCDC("###CCDC SYN_MODE=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_SYN_MODE));
 	DPRINTK_ISPCCDC("###CCDC HORZ_INFO=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_HORZ_INFO));
 	DPRINTK_ISPCCDC("###CCDC VERT_START=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_VERT_START));
 	DPRINTK_ISPCCDC("###CCDC VERT_LINES=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_VERT_LINES));
 	DPRINTK_ISPCCDC("###CCDC CULLING=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_CULLING));
 	DPRINTK_ISPCCDC("###CCDC HSIZE_OFF=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_HSIZE_OFF));
 	DPRINTK_ISPCCDC("###CCDC SDOFST=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_SDOFST));
 	DPRINTK_ISPCCDC("###CCDC SDR_ADDR=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_SDR_ADDR));
 	DPRINTK_ISPCCDC("###CCDC CLAMP=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_CLAMP));
 	DPRINTK_ISPCCDC("###CCDC COLPTN=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_COLPTN));
 	DPRINTK_ISPCCDC("###CCDC CFG=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_CFG));
 	DPRINTK_ISPCCDC("###CCDC VP_OUT=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_VP_OUT));
 	DPRINTK_ISPCCDC("###CCDC_SDR_ADDR= 0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_SDR_ADDR));
 	DPRINTK_ISPCCDC("###CCDC FMTCFG=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_FMTCFG));
 	DPRINTK_ISPCCDC("###CCDC FMT_HORZ=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_FMT_HORZ));
 	DPRINTK_ISPCCDC("###CCDC FMT_VERT=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_FMT_VERT));
 	DPRINTK_ISPCCDC("###CCDC LSC_CONFIG=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_LSC_CONFIG));
 	DPRINTK_ISPCCDC("###CCDC LSC_INIT=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_LSC_INITIAL));
 	DPRINTK_ISPCCDC("###CCDC LSC_TABLE BASE=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_LSC_TABLE_BASE));
 	DPRINTK_ISPCCDC("###CCDC LSC TABLE OFFSET=0x%x\n",
-			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
 				      ISPCCDC_LSC_TABLE_OFFSET));
 }
-EXPORT_SYMBOL(ispccdc_print_status);
 
 /**
  * isp_ccdc_init - CCDC module initialization.
@@ -1645,7 +1505,6 @@ int __init isp_ccdc_init(struct device *
 	isp_ccdc->ccdc_inuse = 0;
 	ispccdc_config_crop(isp_ccdc, 0, 0, 0, 0);
 	mutex_init(&isp_ccdc->mutexlock);
-	isp_ccdc->dev = dev;
 
 	if (is_isplsc_activated()) {
 		isp_ccdc->lsc_gain_table_tmp = kmalloc(LSC_TABLE_INIT_SIZE,
@@ -1678,7 +1537,7 @@ void isp_ccdc_cleanup(struct device *dev
 	}
 
 	if (isp_ccdc->fpc_table_add_m != 0) {
-		ispmmu_kunmap(isp_ccdc->fpc_table_add_m);
+		iommu_kunmap(isp->iommu, isp_ccdc->fpc_table_add_m);
 		kfree(isp_ccdc->fpc_table_add);
 	}
 }
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispccdc.h kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispccdc.h
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispccdc.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispccdc.h	2012-12-16 13:13:01.664330147 +0100
@@ -155,16 +155,10 @@ struct ispccdc_refmt {
  */
 struct isp_ccdc_device {
 	u8 ccdc_inuse;
-	u32 ccdcout_w;
-	u32 ccdcout_h;
-	u32 ccdcin_w;
-	u32 ccdcin_h;
 	u32 ccdcin_woffset;
 	u32 ccdcin_hoffset;
 	u32 crop_w;
 	u32 crop_h;
-	u8 ccdc_inpfmt;
-	u8 ccdc_outfmt;
 	u8 vpout_en;
 	u8 wen;
 	u8 exwen;
@@ -172,7 +166,6 @@ struct isp_ccdc_device {
 	u8 ccdcslave;
 	u8 syncif_ipmod;
 	u8 obclamp_en;
-	u8 pm_state;
 	u8 lsc_enable;
 	u8 lsc_initialized;
 	int lsc_state;
@@ -184,16 +177,12 @@ struct isp_ccdc_device {
 	struct ispccdc_lsc_config lsc_config;
 	unsigned long fpc_table_add_m;
 	u32 *fpc_table_add;
-	struct device *dev;
 };
 
 int ispccdc_request(struct isp_ccdc_device *isp_ccdc);
 
 int ispccdc_free(struct isp_ccdc_device *isp_ccdc);
 
-int ispccdc_config_datapath(struct isp_ccdc_device *isp_ccdc,
-			    enum ccdc_input input, enum ccdc_output output);
-
 void ispccdc_config_crop(struct isp_ccdc_device *isp_ccdc, u32 left, u32 top,
 			 u32 height, u32 width);
 
@@ -246,11 +235,11 @@ void ispccdc_config_imgattr(struct isp_c
 
 void ispccdc_config_shadow_registers(struct isp_ccdc_device *isp_ccdc);
 
-int ispccdc_try_size(struct isp_ccdc_device *isp_ccdc, u32 input_w, u32 input_h,
-		     u32 *output_w, u32 *output_h);
+int ispccdc_try_pipeline(struct isp_ccdc_device *isp_ccdc,
+			 struct isp_pipeline *pipe);
 
-int ispccdc_config_size(struct isp_ccdc_device *isp_ccdc, u32 input_w,
-			u32 input_h, u32 output_w, u32 output_h);
+int ispccdc_s_pipeline(struct isp_ccdc_device *isp_ccdc,
+		       struct isp_pipeline *pipe);
 
 int ispccdc_config_outlineoffset(struct isp_ccdc_device *isp_ccdc, u32 offset,
 				 u8 oddeven, u8 numlines);
@@ -259,10 +248,6 @@ int ispccdc_set_outaddr(struct isp_ccdc_
 
 void ispccdc_enable(struct isp_ccdc_device *isp_ccdc, u8 enable);
 
-void ispccdc_suspend(struct isp_ccdc_device *isp_ccdc);
-
-void ispccdc_resume(struct isp_ccdc_device *isp_ccdc);
-
 int ispccdc_sbl_busy(void *_isp_ccdc);
 
 int ispccdc_busy(struct isp_ccdc_device *isp_ccdc);
@@ -271,7 +256,8 @@ void ispccdc_save_context(struct device
 
 void ispccdc_restore_context(struct device *dev);
 
-void ispccdc_print_status(struct isp_ccdc_device *isp_ccdc);
+void ispccdc_print_status(struct isp_ccdc_device *isp_ccdc,
+			  struct isp_pipeline *pipe);
 
 int omap34xx_isp_ccdc_config(struct isp_ccdc_device *isp_ccdc,
 			     void *userspace_add);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispcsi2.c kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispcsi2.c
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispcsi2.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispcsi2.c	2012-12-16 13:13:01.664330147 +0100
@@ -1760,9 +1760,12 @@ int isp_csi2_timings_get_all(void)
 
 /**
  * isp_csi2_isr - CSI2 interrupt handling.
+ *
+ * Return -EIO on Transmission error
  **/
-void isp_csi2_isr(void)
+int isp_csi2_isr(void)
 {
+	int retval = 0;
 	u32 csi2_irqstatus, cpxio1_irqstatus, ctxirqstatus;
 
 	csi2_irqstatus = isp_reg_readl(current_csi2_cfg.dev,
@@ -1771,6 +1774,7 @@ void isp_csi2_isr(void)
 	isp_reg_writel(current_csi2_cfg.dev, csi2_irqstatus,
 		       OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_IRQSTATUS);
 
+	/* Failure Cases */
 	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_COMPLEXIO1_ERR_IRQ) {
 		cpxio1_irqstatus = isp_reg_readl(current_csi2_cfg.dev,
 						 OMAP3_ISP_IOMEM_CSI2A,
@@ -1778,10 +1782,37 @@ void isp_csi2_isr(void)
 		isp_reg_writel(current_csi2_cfg.dev, cpxio1_irqstatus,
 			       OMAP3_ISP_IOMEM_CSI2A,
 			       ISPCSI2_COMPLEXIO1_IRQSTATUS);
-		printk(KERN_ERR "CSI2: ComplexIO Error IRQ %x\n",
-		       cpxio1_irqstatus);
+		dev_dbg(current_csi2_cfg.dev, "CSI2: ComplexIO Error IRQ %x\n",
+			cpxio1_irqstatus);
+		retval = -EIO;
 	}
 
+	if (csi2_irqstatus & (ISPCSI2_IRQSTATUS_OCP_ERR_IRQ |
+			      ISPCSI2_IRQSTATUS_SHORT_PACKET_IRQ |
+			      ISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ |
+			      ISPCSI2_IRQSTATUS_COMPLEXIO2_ERR_IRQ |
+			      ISPCSI2_IRQSTATUS_FIFO_OVF_IRQ)) {
+		dev_dbg(current_csi2_cfg.dev, "CSI2 Err:"
+			" OCP:%d,"
+			" Short_pack:%d,"
+			" ECC:%d,"
+			" CPXIO2:%d,"
+			" FIFO_OVF:%d,"
+			"\n",
+			(csi2_irqstatus &
+			 ISPCSI2_IRQSTATUS_OCP_ERR_IRQ) ? 1 : 0,
+			(csi2_irqstatus &
+			 ISPCSI2_IRQSTATUS_SHORT_PACKET_IRQ) ? 1 : 0,
+			(csi2_irqstatus &
+			 ISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ) ? 1 : 0,
+			(csi2_irqstatus &
+			 ISPCSI2_IRQSTATUS_COMPLEXIO2_ERR_IRQ) ? 1 : 0,
+			(csi2_irqstatus &
+			 ISPCSI2_IRQSTATUS_FIFO_OVF_IRQ) ? 1 : 0);
+		retval = -EIO;
+	}
+
+	/* Successful cases */
 	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_CONTEXT(0)) {
 		ctxirqstatus = isp_reg_readl(current_csi2_cfg.dev,
 					     OMAP3_ISP_IOMEM_CSI2A,
@@ -1791,25 +1822,10 @@ void isp_csi2_isr(void)
 			       ISPCSI2_CTX_IRQSTATUS(0));
 	}
 
-	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_OCP_ERR_IRQ)
-		printk(KERN_ERR "CSI2: OCP Transmission Error\n");
-
-	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_SHORT_PACKET_IRQ)
-		printk(KERN_ERR "CSI2: Short packet receive error\n");
-
 	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_ECC_CORRECTION_IRQ)
-		printk(KERN_DEBUG "CSI2: ECC correction done\n");
-
-	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ)
-		printk(KERN_ERR "CSI2: ECC correction failed\n");
-
-	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_COMPLEXIO2_ERR_IRQ)
-		printk(KERN_ERR "CSI2: ComplexIO #2 failed\n");
+		dev_dbg(current_csi2_cfg.dev, "CSI2: ECC correction done\n");
 
-	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_FIFO_OVF_IRQ)
-		printk(KERN_ERR "CSI2: FIFO overflow error\n");
-
-	return;
+	return retval;
 }
 EXPORT_SYMBOL(isp_csi2_isr);
 
@@ -1916,21 +1932,6 @@ void isp_csi2_irq_status_set(int enable)
 EXPORT_SYMBOL(isp_csi2_irq_status_set);
 
 /**
- * isp_csi2_irq_status_set - Enables main CSI2 IRQ.
- * @enable: Enable/disable main CSI2 interrupt
- **/
-void isp_csi2_irq_set(int enable)
-{
-	isp_reg_writel(current_csi2_cfg.dev, IRQ0STATUS_CSIA_IRQ,
-		       OMAP3_ISP_IOMEM_MAIN,
-		       ISP_IRQ0STATUS);
-	isp_reg_and_or(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_MAIN,
-		       ISP_IRQ0ENABLE, ~IRQ0ENABLE_CSIA_IRQ,
-		       (enable ? IRQ0ENABLE_CSIA_IRQ : 0));
-}
-EXPORT_SYMBOL(isp_csi2_irq_set);
-
-/**
  * isp_csi2_irq_all_set - Enable/disable CSI2 interrupts.
  * @enable: 0-Disable, 1-Enable.
  **/
@@ -1940,9 +1941,7 @@ void isp_csi2_irq_all_set(int enable)
 		isp_csi2_irq_complexio1_set(enable);
 		isp_csi2_irq_ctx_set(enable);
 		isp_csi2_irq_status_set(enable);
-		isp_csi2_irq_set(enable);
 	} else {
-		isp_csi2_irq_set(enable);
 		isp_csi2_irq_status_set(enable);
 		isp_csi2_irq_ctx_set(enable);
 		isp_csi2_irq_complexio1_set(enable);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispcsi2.h kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispcsi2.h
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispcsi2.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispcsi2.h	2012-12-16 13:13:01.664330147 +0100
@@ -221,10 +221,9 @@ int isp_csi2_timings_get_all(void);
 void isp_csi2_irq_complexio1_set(int enable);
 void isp_csi2_irq_ctx_set(int enable);
 void isp_csi2_irq_status_set(int enable);
-void isp_csi2_irq_set(int enable);
 void isp_csi2_irq_all_set(int enable);
 
-void isp_csi2_isr(void);
+int isp_csi2_isr(void);
 int isp_csi2_reset(void);
 void isp_csi2_enable(int enable);
 void isp_csi2_regdump(void);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isp.h kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isp.h
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isp.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isp.h	2012-12-16 13:13:01.664330147 +0100
@@ -29,15 +29,24 @@
 #include <media/videobuf-dma-sg.h>
 #include <linux/videodev2.h>
 
+#include <asm/io.h>
+
+#include <mach/iommu.h>
+#include <mach/iovmm.h>
+
+struct isp_pipeline;
+
+#include "ispstat.h"
 #include "isp_af.h"
 #include "isphist.h"
 #include "ispccdc.h"
 #include "ispreg.h"
 #include "isph3a.h"
-#include "ispmmu.h"
 #include "ispresizer.h"
 #include "isppreview.h"
 
+#define IOMMU_FLAG (IOVMF_ENDIAN_LITTLE | IOVMF_ELSZ_8)
+
 #define OMAP_ISP_CCDC		(1 << 0)
 #define OMAP_ISP_PREVIEW	(1 << 1)
 #define OMAP_ISP_RESIZER	(1 << 2)
@@ -64,6 +73,12 @@
 #define ISP_BYTES_PER_PIXEL		2
 #define NUM_ISP_CAPTURE_FORMATS 	(sizeof(isp_formats) /		\
 					 sizeof(isp_formats[0]))
+
+#define to_isp_device(ptr_module)				\
+	container_of(ptr_module, struct isp_device, ptr_module)
+#define to_device(ptr_module)						\
+	(to_isp_device(ptr_module)->dev)
+
 typedef int (*isp_vbq_callback_ptr) (struct videobuf_buffer *vb);
 typedef void (*isp_callback_t) (unsigned long status,
 				isp_vbq_callback_ptr arg1, void *arg2);
@@ -116,17 +131,21 @@ enum isp_callback_type {
 	CBK_PREV_DONE,
 	CBK_RESZ_DONE,
 	CBK_MMU_ERR,
-	CBK_H3A_AWB_DONE,
 	CBK_HIST_DONE,
 	CBK_HS_VS,
 	CBK_LSC_ISR,
-	CBK_H3A_AF_DONE,
 	CBK_CATCHALL,
 	CBK_CSIA,
 	CBK_CSIB,
 	CBK_END,
 };
 
+enum isp_running {
+	ISP_STOPPED,
+	ISP_RUNNING,
+	ISP_STOPPING,
+};
+
 /**
  * struct isp_reg - Structure for ISP register values.
  * @reg: 32-bit Register address.
@@ -221,7 +240,6 @@ struct isp_buf {
 
 struct isp_bufs {
 	dma_addr_t isp_addr_capture[VIDEO_MAX_FRAME];
-	spinlock_t lock;	/* For handling current buffer */
 	/* queue full: (ispsg.queue + 1) % NUM_BUFS == ispsg.done
 	   queue empty: ispsg.queue == ispsg.done */
 	struct isp_buf buf[NUM_BUFS];
@@ -253,44 +271,32 @@ struct isp_irq {
 	void *isp_callbk_arg2[CBK_END];
 };
 
-/**
- * struct ispmodule - Structure for storing ISP sub-module information.
- * @isp_pipeline: Bit mask for submodules enabled within the ISP.
- * @pix: Structure containing the format and layout of the output image.
- * @ccdc_input_width: ISP CCDC module input image width.
- * @ccdc_input_height: ISP CCDC module input image height.
- * @ccdc_output_width: ISP CCDC module output image width.
- * @ccdc_output_height: ISP CCDC module output image height.
- * @preview_input_width: ISP Preview module input image width.
- * @preview_input_height: ISP Preview module input image height.
- * @preview_output_width: ISP Preview module output image width.
- * @preview_output_height: ISP Preview module output image height.
- * @resizer_input_width: ISP Resizer module input image width.
- * @resizer_input_height: ISP Resizer module input image height.
- * @resizer_output_width: ISP Resizer module output image width.
- * @resizer_output_height: ISP Resizer module output image height.
- */
-struct isp_module {
-	u32 interrupts;
-	int enable;
-	unsigned int isp_pipeline;
-	struct v4l2_pix_format pix;
-	unsigned int ccdc_input_width;
-	unsigned int ccdc_input_height;
-	unsigned int ccdc_output_width;
-	unsigned int ccdc_output_height;
-	unsigned int preview_input_width;
-	unsigned int preview_input_height;
-	unsigned int preview_output_width;
-	unsigned int preview_output_height;
-	unsigned int resizer_input_width;
-	unsigned int resizer_input_height;
-	unsigned int resizer_output_width;
-	unsigned int resizer_output_height;
+struct isp_pipeline {
+	unsigned int modules;		/* modules in use */
+	struct v4l2_pix_format pix;	/* output pix */
+	unsigned int ccdc_in_w;
+	unsigned int ccdc_in_h;
+	unsigned int ccdc_out_w;	/* ccdc output data width (pixels) */
+	unsigned int ccdc_out_h;	/* ccdc output data height */
+	unsigned int ccdc_out_w_img;	/* ccdc output visible image width */
+	enum ccdc_input ccdc_in;
+	enum ccdc_output ccdc_out;
+	unsigned int prv_out_w;
+	unsigned int prv_out_h;
+	unsigned int prv_out_w_img;
+	unsigned int prv_out_h_img;
+	unsigned int prv_fmt_avg;
+	enum preview_input prv_in;
+	enum preview_output prv_out;
+	struct v4l2_rect rsz_crop;
+	unsigned int rsz_out_w;
+	unsigned int rsz_out_h;
+	unsigned int rsz_out_w_img;
+	enum resizer_input rsz_in;
 };
 
 #define RAW_CAPTURE(isp)					\
-	(!((isp)->module.isp_pipeline & OMAP_ISP_PREVIEW))
+	(!((isp)->pipeline.modules & OMAP_ISP_PREVIEW))
 
 /**
  * struct isp - Structure for storing ISP Control module information
@@ -326,10 +332,12 @@ struct isp_device {
 
 	/* ISP Obj */
 	spinlock_t lock;	/* For handling registered ISP callbacks */
+	spinlock_t h3a_lock;
 	struct mutex isp_mutex;	/* For handling ref_count field */
 	int ref_count;
 	struct clk *cam_ick;
 	struct clk *cam_mclk;
+	struct clk *dpll4_m5_ck;
 	struct clk *csi2_fck;
 	struct clk *l3_ick;
 	struct isp_interface_config *config;
@@ -338,7 +346,9 @@ struct isp_device {
 	unsigned long tmp_buf_offset;
 	struct isp_bufs bufs;
 	struct isp_irq irq;
-	struct isp_module module;
+	struct isp_pipeline pipeline;
+	u32 interrupts;
+	enum isp_running running;
 
 	/* ISP modules */
 	struct isp_af_device isp_af;
@@ -347,22 +357,13 @@ struct isp_device {
 	struct isp_res_device isp_res;
 	struct isp_prev_device isp_prev;
 	struct isp_ccdc_device isp_ccdc;
-};
-
-u32 isp_reg_readl(struct device *dev, enum isp_mem_resources isp_mmio_range,
-		  u32 reg_offset);
 
-void isp_reg_writel(struct device *dev, u32 reg_value,
-		    enum isp_mem_resources isp_mmio_range, u32 reg_offset);
+	struct iommu *iommu;
+};
 
-void isp_reg_and(struct device *dev, enum isp_mem_resources mmio_range, u32 reg,
-		 u32 and_bits);
+void omap34xx_isp_hist_dma_done(struct device *dev);
 
-void isp_reg_or(struct device *dev, enum isp_mem_resources mmio_range, u32 reg,
-		u32 or_bits);
-
-void isp_reg_and_or(struct device *dev, enum isp_mem_resources mmio_range,
-		    u32 reg, u32 and_bits, u32 or_bits);
+void isp_flush(struct device *dev);
 
 void isp_start(struct device *dev);
 
@@ -440,9 +441,58 @@ int __init isp_csi2_init(struct device *
 void isp_ccdc_cleanup(struct device *dev);
 void isp_hist_cleanup(struct device *dev);
 void isph3a_aewb_cleanup(struct device *dev);
-void isp_preview_cleanup(struct device *dev);
 void isp_resizer_cleanup(struct device *dev);
 void isp_af_exit(struct device *dev);
 void isp_csi2_cleanup(struct device *dev);
 
+/* FIXME: Remove these when iommu supports these directly. */
+dma_addr_t ispmmu_vmap(struct device *dev, const struct scatterlist *sglist,
+		       int sglen);
+void ispmmu_vunmap(struct device *dev, dma_addr_t da);
+
+static inline
+u32 isp_reg_readl(struct device *dev, enum isp_mem_resources isp_mmio_range,
+		  u32 reg_offset)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	return __raw_readl(isp->mmio_base[isp_mmio_range] + reg_offset);
+}
+
+static inline
+void isp_reg_writel(struct device *dev, u32 reg_value,
+		    enum isp_mem_resources isp_mmio_range, u32 reg_offset)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	__raw_writel(reg_value, isp->mmio_base[isp_mmio_range] + reg_offset);
+}
+
+static inline
+void isp_reg_and(struct device *dev, enum isp_mem_resources mmio_range, u32 reg,
+		 u32 and_bits)
+{
+	u32 v = isp_reg_readl(dev, mmio_range, reg);
+
+	isp_reg_writel(dev, v & and_bits, mmio_range, reg);
+}
+
+static inline
+void isp_reg_or(struct device *dev, enum isp_mem_resources mmio_range, u32 reg,
+		u32 or_bits)
+{
+	u32 v = isp_reg_readl(dev, mmio_range, reg);
+
+	isp_reg_writel(dev, v | or_bits, mmio_range, reg);
+}
+
+static inline
+void isp_reg_and_or(struct device *dev, enum isp_mem_resources mmio_range,
+		    u32 reg, u32 and_bits, u32 or_bits)
+{
+	u32 v = isp_reg_readl(dev, mmio_range, reg);
+
+	isp_reg_writel(dev, (v & and_bits) | or_bits, mmio_range, reg);
+}
+
 #endif	/* OMAP_ISP_TOP_H */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isphist.c kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isphist.c
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isphist.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isphist.c	2012-12-16 13:13:01.664330147 +0100
@@ -6,6 +6,7 @@
  * Copyright (C) 2009 Texas Instruments, Inc.
  *
  * Contributors:
+ *	David Cohen <david.cohen@nokia.com>
  *	Sergio Aguirre <saaguirre@ti.com>
  *	Troy Laramy
  *
@@ -18,16 +19,15 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#include <asm/cacheflush.h>
-
 #include <linux/delay.h>
-#include <linux/dma-mapping.h>
 #include <linux/uaccess.h>
+#include <linux/device.h>
 
 #include "isp.h"
 #include "ispreg.h"
 #include "isphist.h"
-#include "ispmmu.h"
+
+#define HIST_USE_DMA	1
 
 /* Structure for saving/restoring histogram module registers */
 struct isp_reg isphist_reg_list[] = {
@@ -50,16 +50,20 @@ struct isp_reg isphist_reg_list[] = {
 
 static void isp_hist_print_status(struct isp_hist_device *isp_hist);
 
-void __isp_hist_enable(struct isp_hist_device *isp_hist, u8 enable)
+static void __isp_hist_enable(struct isp_hist_device *isp_hist, u8 enable)
 {
+	struct device *dev = to_device(isp_hist);
+	unsigned int pcr;
+
+	pcr = isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_PCR);
+
+	/* Set AF_EN bit in PCR Register */
 	if (enable)
-		DPRINTK_ISPHIST("   histogram enabled \n");
+		pcr |= ISPHIST_PCR_EN;
 	else
-		DPRINTK_ISPHIST("   histogram disabled \n");
+		pcr &= ~ISPHIST_PCR_EN;
 
-	isp_reg_and_or(isp_hist->dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_PCR,
-		       ~ISPHIST_PCR_EN,	(enable ? ISPHIST_PCR_EN : 0));
-	isp_hist->hist_enable = enable;
+	isp_reg_writel(dev, pcr, OMAP3_ISP_IOMEM_HIST, ISPHIST_PCR);
 }
 
 /**
@@ -71,8 +75,19 @@ void __isp_hist_enable(struct isp_hist_d
  **/
 void isp_hist_enable(struct isp_hist_device *isp_hist, u8 enable)
 {
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&isp_hist->lock, irqflags);
+
+	if (!isp_hist->config.enable) {
+		spin_unlock_irqrestore(&isp_hist->lock, irqflags);
+		return;
+	}
+
 	__isp_hist_enable(isp_hist, enable);
-	isp_hist->pm_state = enable;
+	isp_hist->enabled = enable;
+
+	spin_unlock_irqrestore(&isp_hist->lock, irqflags);
 }
 
 /**
@@ -80,8 +95,28 @@ void isp_hist_enable(struct isp_hist_dev
  **/
 void isp_hist_suspend(struct isp_hist_device *isp_hist)
 {
-	if (isp_hist->pm_state)
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&isp_hist->lock, irqflags);
+	if (isp_hist->enabled)
 		__isp_hist_enable(isp_hist, 0);
+	spin_unlock_irqrestore(&isp_hist->lock, irqflags);
+}
+
+void isp_hist_try_enable(struct isp_hist_device *isp_hist)
+{
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&isp_hist->lock, irqflags);
+	if (unlikely(!isp_hist->enabled && isp_hist->config.enable &&
+						!isp_hist->waiting_dma)) {
+		isp_hist->update = 1;
+		isp_hist->active_buf = ispstat_buf_next(&isp_hist->stat);
+		spin_unlock_irqrestore(&isp_hist->lock, irqflags);
+		isp_hist_config_registers(isp_hist);
+		isp_hist_enable(isp_hist, 1);
+	} else
+		spin_unlock_irqrestore(&isp_hist->lock, irqflags);
 }
 
 /**
@@ -89,315 +124,442 @@ void isp_hist_suspend(struct isp_hist_de
  **/
 void isp_hist_resume(struct isp_hist_device *isp_hist)
 {
-	if (isp_hist->pm_state)
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&isp_hist->lock, irqflags);
+	if (isp_hist->enabled)
 		__isp_hist_enable(isp_hist, 1);
+	spin_unlock_irqrestore(&isp_hist->lock, irqflags);
 }
 
 int isp_hist_busy(struct isp_hist_device *isp_hist)
 {
-	return isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_PCR)
+	struct device *dev = to_device(isp_hist);
+
+	return isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_PCR)
 			     & ISPHIST_PCR_BUSY;
 }
 
+/**
+ * isp_hist_reset_mem - clear Histogram memory before start stats engine.
+ **/
+static void isp_hist_reset_mem(struct isp_hist_device *isp_hist)
+{
+	struct device *dev = to_device(isp_hist);
+	unsigned int i;
+
+	isp_reg_writel(dev, 0, OMAP3_ISP_IOMEM_HIST, ISPHIST_ADDR);
+
+	/*
+	 * By setting it, the histogram internal buffer is being cleared at the
+	 * same time it's being read. This bit must be cleared afterwards.
+	 */
+	isp_reg_or(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT, ISPHIST_CNT_CLR_EN);
+
+	/*
+	 * We'll clear 4 words at each iteration for optimization. It avoids
+	 * 3/4 of the jumps. We also know HIST_MEM_SIZE is divisible by 4.
+	 */
+	for (i = HIST_MEM_SIZE / 4; i > 0; i--) {
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);
+	}
+	isp_reg_and(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,
+		    ~ISPHIST_CNT_CLR_EN);
+}
+
+static void isp_hist_dma_config(struct isp_hist_device *isp_hist)
+{
+	struct omap_dma_channel_params *dma_config = &isp_hist->dma_config;
+
+	dma_config->data_type = OMAP_DMA_DATA_TYPE_S32;
+	dma_config->sync_mode = OMAP_DMA_SYNC_ELEMENT;
+	dma_config->elem_count = (isp_hist->buf_size / sizeof(u32));
+	dma_config->frame_count = 1;
+	dma_config->src_amode = OMAP_DMA_AMODE_CONSTANT;
+	dma_config->src_start = OMAP3ISP_HIST_REG_BASE + ISPHIST_DATA;
+	dma_config->dst_amode = OMAP_DMA_AMODE_POST_INC;
+	dma_config->src_or_dst_synch = OMAP_DMA_SRC_SYNC;
+}
 
 /**
- * isp_hist_update_regs - Helper function to update Histogram registers.
+ * isp_hist_set_regs - Helper function to update Histogram registers.
  **/
-static void isp_hist_update_regs(struct isp_hist_device *isp_hist)
+void isp_hist_config_registers(struct isp_hist_device *isp_hist)
 {
-	isp_reg_writel(isp_hist->dev, isp_hist->regs.pcr, OMAP3_ISP_IOMEM_HIST,
-		       ISPHIST_PCR);
-	isp_reg_writel(isp_hist->dev, isp_hist->regs.cnt, OMAP3_ISP_IOMEM_HIST,
+	struct device *dev = to_device(isp_hist);
+	unsigned long irqflags;
+
+	if (!isp_hist->update || !isp_hist->config.enable)
+		return;
+
+	spin_lock_irqsave(&isp_hist->lock, irqflags);
+	isp_hist->num_acc_frames = isp_hist->config.num_acc_frames;
+	isp_hist_reset_mem(isp_hist);
+
+	isp_reg_writel(dev, isp_hist->regs.cnt, OMAP3_ISP_IOMEM_HIST,
 		       ISPHIST_CNT);
-	isp_reg_writel(isp_hist->dev, isp_hist->regs.wb_gain,
+	isp_reg_writel(dev, isp_hist->regs.wb_gain,
 		       OMAP3_ISP_IOMEM_HIST, ISPHIST_WB_GAIN);
-	isp_reg_writel(isp_hist->dev, isp_hist->regs.r0_h, OMAP3_ISP_IOMEM_HIST,
+	isp_reg_writel(dev, isp_hist->regs.reg_hor[0], OMAP3_ISP_IOMEM_HIST,
 		       ISPHIST_R0_HORZ);
-	isp_reg_writel(isp_hist->dev, isp_hist->regs.r0_v, OMAP3_ISP_IOMEM_HIST,
+	isp_reg_writel(dev, isp_hist->regs.reg_ver[0], OMAP3_ISP_IOMEM_HIST,
 		       ISPHIST_R0_VERT);
-	isp_reg_writel(isp_hist->dev, isp_hist->regs.r1_h, OMAP3_ISP_IOMEM_HIST,
+	isp_reg_writel(dev, isp_hist->regs.reg_hor[1], OMAP3_ISP_IOMEM_HIST,
 		       ISPHIST_R1_HORZ);
-	isp_reg_writel(isp_hist->dev, isp_hist->regs.r1_v, OMAP3_ISP_IOMEM_HIST,
+	isp_reg_writel(dev, isp_hist->regs.reg_ver[1], OMAP3_ISP_IOMEM_HIST,
 		       ISPHIST_R1_VERT);
-	isp_reg_writel(isp_hist->dev, isp_hist->regs.r2_h, OMAP3_ISP_IOMEM_HIST,
+	isp_reg_writel(dev, isp_hist->regs.reg_hor[2], OMAP3_ISP_IOMEM_HIST,
 		       ISPHIST_R2_HORZ);
-	isp_reg_writel(isp_hist->dev, isp_hist->regs.r2_v, OMAP3_ISP_IOMEM_HIST,
+	isp_reg_writel(dev, isp_hist->regs.reg_ver[2], OMAP3_ISP_IOMEM_HIST,
 		       ISPHIST_R2_VERT);
-	isp_reg_writel(isp_hist->dev, isp_hist->regs.r3_h, OMAP3_ISP_IOMEM_HIST,
+	isp_reg_writel(dev, isp_hist->regs.reg_hor[3], OMAP3_ISP_IOMEM_HIST,
 		       ISPHIST_R3_HORZ);
-	isp_reg_writel(isp_hist->dev, isp_hist->regs.r3_v, OMAP3_ISP_IOMEM_HIST,
+	isp_reg_writel(dev, isp_hist->regs.reg_ver[3], OMAP3_ISP_IOMEM_HIST,
 		       ISPHIST_R3_VERT);
-	isp_reg_writel(isp_hist->dev, isp_hist->regs.hist_addr,
-		       OMAP3_ISP_IOMEM_HIST, ISPHIST_ADDR);
-	isp_reg_writel(isp_hist->dev, isp_hist->regs.hist_data,
-		       OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);
-	isp_reg_writel(isp_hist->dev, isp_hist->regs.hist_radd,
+	isp_reg_writel(dev, isp_hist->regs.hist_radd,
 		       OMAP3_ISP_IOMEM_HIST, ISPHIST_RADD);
-	isp_reg_writel(isp_hist->dev, isp_hist->regs.hist_radd_off,
+	isp_reg_writel(dev, isp_hist->regs.hist_radd_off,
 		       OMAP3_ISP_IOMEM_HIST, ISPHIST_RADD_OFF);
-	isp_reg_writel(isp_hist->dev, isp_hist->regs.h_v_info,
+	isp_reg_writel(dev, isp_hist->regs.h_v_info,
 		       OMAP3_ISP_IOMEM_HIST, ISPHIST_H_V_INFO);
+
+	isp_hist_dma_config(isp_hist);
+
+	isp_hist->update = 0;
+	spin_unlock_irqrestore(&isp_hist->lock, irqflags);
+
+	isp_hist_print_status(isp_hist);
 }
 
-/**
- * isp_hist_isr - Callback from ISP driver for HIST interrupt.
- * @status: IRQ0STATUS in case of MMU error, 0 for hist interrupt.
- *          arg1 and arg2 Not used as of now.
- **/
-static void isp_hist_isr(unsigned long status, isp_vbq_callback_ptr arg1,
-			 void *arg2)
+static void isp_hist_dma_cb(int lch, u16 ch_status, void *data)
 {
-	struct isp_hist_device *isp_hist = arg2;
+	struct isp_hist_device *isp_hist = data;
+	struct device *dev = to_device(isp_hist);
 
-	isp_hist_enable(isp_hist, 0);
+	if (ch_status & ~OMAP_DMA_BLOCK_IRQ) {
+		dev_dbg(dev, "hist: DMA error. status = %02x\n", ch_status);
+		omap_stop_dma(lch);
+		isp_hist_reset_mem(isp_hist);
+	} else {
+		int ret;
 
-	if (!(status & HIST_DONE))
-		return;
+		ret = ispstat_buf_queue(&isp_hist->stat);
+		isp_hist->active_buf = ispstat_buf_next(&isp_hist->stat);
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,
+			    ~ISPHIST_CNT_CLR_EN);
+		if (!ret)
+			omap34xx_isp_hist_dma_done(dev);
+	}
+	isp_hist->waiting_dma = 0;
+}
 
-	if (!isp_hist->completed) {
-		if (isp_hist->frame_req == isp_hist->frame_cnt) {
-			isp_hist->frame_cnt = 0;
-			isp_hist->frame_req = 0;
-			isp_hist->completed = 1;
-		} else {
-			isp_hist_enable(isp_hist, 1);
-			isp_hist->frame_cnt++;
-		}
+static int isp_hist_buf_dma(struct isp_hist_device *isp_hist)
+{
+	struct device *dev = to_device(isp_hist);
+	dma_addr_t dma_addr = isp_hist->active_buf->dma_addr;
+
+	if (!dma_addr) {
+		dev_dbg(dev, "hist: invalid DMA buffer address\n");
+		isp_hist_reset_mem(isp_hist);
+		return HIST_NO_BUF;
 	}
+
+	isp_hist->waiting_dma = 1;
+	isp_reg_writel(dev, 0, OMAP3_ISP_IOMEM_HIST, ISPHIST_ADDR);
+	isp_reg_or(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,
+		   ISPHIST_CNT_CLR_EN);
+	isp_flush(dev);
+	isp_hist->dma_config.dst_start = dma_addr;
+	omap_set_dma_params(isp_hist->dma_ch, &isp_hist->dma_config);
+	omap_start_dma(isp_hist->dma_ch);
+
+	return HIST_BUF_WAITING_DMA;
+}
+
+static int isp_hist_buf_pio(struct isp_hist_device *isp_hist)
+{
+	struct device *dev = to_device(isp_hist);
+	u32 *buf = isp_hist->active_buf->virt_addr;
+	unsigned int i;
+	int ret;
+
+	if (!buf) {
+		dev_dbg(dev, "hist: invalid PIO buffer address\n");
+		isp_hist_reset_mem(isp_hist);
+		return HIST_NO_BUF;
+	}
+
+	isp_reg_writel(dev, 0, OMAP3_ISP_IOMEM_HIST, ISPHIST_ADDR);
+
+	/*
+	 * By setting it, the histogram internal buffer is being cleared at the
+	 * same time it's being read. This bit must be cleared just after all
+	 * data is acquired.
+	 */
+	isp_reg_or(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,
+		   ISPHIST_CNT_CLR_EN);
+
+	/*
+	 * We'll read 4 times a 4-bytes-word at each iteration for
+	 * optimization. It avoids 3/4 of the jumps. We also know buf_size is
+	 * divisible by 16.
+	 */
+	for (i = isp_hist->buf_size / 16; i > 0; i--) {
+		*buf++ = isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);
+		*buf++ = isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);
+		*buf++ = isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);
+		*buf++ = isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);
+	}
+	isp_reg_and(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,
+		    ~ISPHIST_CNT_CLR_EN);
+
+	ret = ispstat_buf_queue(&isp_hist->stat);
+	isp_hist->active_buf = ispstat_buf_next(&isp_hist->stat);
+
+	if (ret)
+		return HIST_NO_BUF;
+	else
+		return HIST_BUF_DONE;
 }
 
 /**
- * isp_hist_reset_mem - clear Histogram memory before start stats engine.
- *
- * Returns 0 after histogram memory was cleared.
+ * isp_hist_isr - Callback from ISP driver for HIST interrupt.
  **/
-static int isp_hist_reset_mem(struct isp_hist_device *isp_hist)
+int isp_hist_buf_process(struct isp_hist_device *isp_hist)
 {
-	int i;
+	unsigned long irqflags;
+	int ret = HIST_NO_BUF;
 
-	isp_reg_or(isp_hist->dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,
-		   ISPHIST_CNT_CLR_EN);
+	spin_lock_irqsave(&isp_hist->lock, irqflags);
 
-	for (i = 0; i < HIST_MEM_SIZE; i++)
-		isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
-			      ISPHIST_DATA);
+	if (isp_hist->invalid_buf || !isp_hist->config.enable) {
+		isp_hist->invalid_buf = 0;
+		isp_hist_reset_mem(isp_hist);
+		goto out_invalid;
+	}
 
-	isp_reg_and(isp_hist->dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,
-		    ~ISPHIST_CNT_CLR_EN);
+	if (--(isp_hist->num_acc_frames))
+		goto out_acc;
 
-	return 0;
+	if (isp_hist->use_dma)
+		ret = isp_hist_buf_dma(isp_hist);
+	else
+		ret = isp_hist_buf_pio(isp_hist);
+
+out_invalid:
+	isp_hist->num_acc_frames = isp_hist->config.num_acc_frames;
+out_acc:
+	spin_unlock_irqrestore(&isp_hist->lock, irqflags);
+
+	return ret;
+}
+
+void isp_hist_mark_invalid_buf(struct isp_hist_device *isp_hist)
+{
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&isp_hist->lock, irqflags);
+	isp_hist->invalid_buf = 1;
+	spin_unlock_irqrestore(&isp_hist->lock, irqflags);
 }
 
 /**
- * isp_hist_set_params - Helper function to check and store user given params.
+ * isp_hist_validate_params - Helper function to check user given params.
  * @user_cfg: Pointer to user configuration structure.
  *
  * Returns 0 on success configuration.
  **/
-static int isp_hist_set_params(struct isp_hist_device *isp_hist,
-			       struct isp_hist_config *user_cfg)
+static int isp_hist_validate_params(struct isp_hist_config *user_cfg)
 {
+	int c;
 
-	int reg_num = 0;
-	int bit_shift = 0;
+	if (user_cfg->source > HIST_SOURCE_MEM)
+		return -EINVAL;
 
+	if (user_cfg->source == HIST_SOURCE_MEM) {
+		if ((user_cfg->input_bit_width < HIST_MIN_BIT_WIDTH) ||
+			(user_cfg->input_bit_width > HIST_MAX_BIT_WIDTH))
+			return -EINVAL;
 
-	if (isp_hist_busy(isp_hist))
+		/* Should be in 32 byte boundary if source is mem */
+		if ((user_cfg->hist_radd & ~ISP_32B_BOUNDARY_BUF) ||
+		    (user_cfg->hist_radd_off & ~ISP_32B_BOUNDARY_OFFSET))
+			return -EINVAL;
+	} else if (user_cfg->input_bit_width != 10) /* CCDC must be 10bits */
 		return -EINVAL;
 
-	if (user_cfg->input_bit_width > MIN_BIT_WIDTH)
-		WRITE_DATA_SIZE(isp_hist->regs.cnt, 0);
-	else
-		WRITE_DATA_SIZE(isp_hist->regs.cnt, 1);
+	if (user_cfg->cfa > HIST_CFA_FOVEONX3)
+		return -EINVAL;
 
-	WRITE_SOURCE(isp_hist->regs.cnt, user_cfg->hist_source);
+	/* Regions size and position */
 
-	if (user_cfg->hist_source) {
-		WRITE_HV_INFO(isp_hist->regs.h_v_info, user_cfg->hist_h_v_info);
+	if ((user_cfg->num_regions < HIST_MIN_REGIONS) ||
+	    (user_cfg->num_regions > HIST_MAX_REGIONS))
+		return -EINVAL;
 
-		if ((user_cfg->hist_radd & ISP_32B_BOUNDARY_BUF) ==
-		    user_cfg->hist_radd) {
-			WRITE_RADD(isp_hist->regs.hist_radd,
-				   user_cfg->hist_radd);
-		} else {
-			dev_err(isp_hist->dev,
-				"hist: Address should be in 32 byte boundary"
-				"\n");
+	/* Regions */
+	for (c = 0; c < user_cfg->num_regions; c++) {
+		if (user_cfg->reg_hor[c] & ~ISPHIST_REGHORIZ_HEND_MASK &
+		    ~ISPHIST_REGHORIZ_HSTART_MASK)
 			return -EINVAL;
-		}
-
-		if ((user_cfg->hist_radd_off & ISP_32B_BOUNDARY_OFFSET) ==
-		    user_cfg->hist_radd_off) {
-			WRITE_RADD_OFF(isp_hist->regs.hist_radd_off,
-				       user_cfg->hist_radd_off);
-		} else {
-			dev_err(isp_hist->dev,
-				"hist: Offset should be in 32 byte boundary\n");
+		if ((user_cfg->reg_hor[c] & ISPHIST_REGHORIZ_HEND_MASK) <=
+		    ((user_cfg->reg_hor[c] & ISPHIST_REGHORIZ_HSTART_MASK) >>
+		     ISPHIST_REGHORIZ_HSTART_SHIFT))
 			return -EINVAL;
-		}
+		if (user_cfg->reg_ver[c] & ~ISPHIST_REGVERT_VEND_MASK &
+		    ~ISPHIST_REGVERT_VSTART_MASK)
+			return -EINVAL;
+		if ((user_cfg->reg_ver[c] & ISPHIST_REGVERT_VEND_MASK) <=
+		    ((user_cfg->reg_ver[c] & ISPHIST_REGVERT_VSTART_MASK) >>
+		     ISPHIST_REGVERT_VSTART_SHIFT))
+			return -EINVAL;
+	}
 
+	switch (user_cfg->num_regions) {
+	case 1:
+		if (user_cfg->hist_bins > HIST_BINS_256)
+			return -EINVAL;
+		break;
+	case 2:
+		if (user_cfg->hist_bins > HIST_BINS_128)
+			return -EINVAL;
+		break;
+	default: /* 3 or 4 */
+		if (user_cfg->hist_bins > HIST_BINS_64)
+			return -EINVAL;
+		break;
 	}
 
-	isp_hist_reset_mem(isp_hist);
-	DPRINTK_ISPHIST("ISPHIST: Memory Cleared\n");
-	isp_hist->frame_req = user_cfg->hist_frames;
+	return 0;
+}
 
-	if (unlikely(user_cfg->wb_gain_R > MAX_WB_GAIN ||
-		     user_cfg->wb_gain_RG > MAX_WB_GAIN ||
-		     user_cfg->wb_gain_B > MAX_WB_GAIN ||
-		     user_cfg->wb_gain_BG > MAX_WB_GAIN)) {
-		dev_err(isp_hist->dev, "hist: Invalid WB gain\n");
-		return -EINVAL;
-	} else {
-		WRITE_WB_R(isp_hist->regs.wb_gain, user_cfg->wb_gain_R);
-		WRITE_WB_RG(isp_hist->regs.wb_gain, user_cfg->wb_gain_RG);
-		WRITE_WB_B(isp_hist->regs.wb_gain, user_cfg->wb_gain_B);
-		WRITE_WB_BG(isp_hist->regs.wb_gain, user_cfg->wb_gain_BG);
+static int isp_hist_comp_params(struct isp_hist_device *isp_hist,
+				struct isp_hist_config *user_cfg)
+{
+	struct isp_hist_config *cur_cfg = &isp_hist->config;
+	int c;
+
+	if ((cur_cfg->source && !user_cfg->source) ||
+	    (!cur_cfg->source && user_cfg->source))
+		return 1;
+
+	if (cur_cfg->input_bit_width != user_cfg->input_bit_width)
+		return 1;
+
+	if (user_cfg->source) {
+		if (cur_cfg->hist_h_v_info != user_cfg->hist_h_v_info)
+			return 1;
+		if (cur_cfg->hist_radd != user_cfg->hist_radd)
+			return 1;
+		if (cur_cfg->hist_radd_off != user_cfg->hist_radd_off)
+			return 1;
 	}
 
-	/* Regions size and position */
+	if (cur_cfg->cfa != user_cfg->cfa)
+		return 1;
 
-	if (user_cfg->num_regions > MAX_REGIONS)
-		return -EINVAL;
+	if (cur_cfg->num_acc_frames != user_cfg->num_acc_frames)
+		return 1;
 
-	if (likely((user_cfg->reg0_hor & ISPHIST_REGHORIZ_HEND_MASK) -
-		   ((user_cfg->reg0_hor & ISPHIST_REGHORIZ_HSTART_MASK) >>
-		    ISPHIST_REGHORIZ_HSTART_SHIFT))) {
-		WRITE_REG_HORIZ(isp_hist->regs.r0_h, user_cfg->reg0_hor);
-		reg_num++;
-	} else {
-		dev_err(isp_hist->dev, "hist: Invalid Region parameters\n");
-		return -EINVAL;
+	if (cur_cfg->hist_bins != user_cfg->hist_bins)
+		return 1;
+
+	for (c = 0; c < HIST_MAX_WG; c++) {
+		if (c == 3 && user_cfg->cfa == HIST_CFA_FOVEONX3)
+			break;
+		else if (cur_cfg->wg[c] != user_cfg->wg[c])
+			return 1;
 	}
 
-	if (likely((user_cfg->reg0_ver & ISPHIST_REGVERT_VEND_MASK) -
-		   ((user_cfg->reg0_ver & ISPHIST_REGVERT_VSTART_MASK) >>
-		    ISPHIST_REGVERT_VSTART_SHIFT))) {
-		WRITE_REG_VERT(isp_hist->regs.r0_v, user_cfg->reg0_ver);
-	} else {
-		dev_err(isp_hist->dev, "hist: Invalid Region parameters\n");
-		return -EINVAL;
+	if (cur_cfg->num_regions != user_cfg->num_regions)
+		return 1;
+
+	/* Regions */
+	for (c = 0; c < user_cfg->num_regions; c++) {
+		if (cur_cfg->reg_hor[c] != user_cfg->reg_hor[c])
+			return 1;
+		if (cur_cfg->reg_ver[c] != user_cfg->reg_ver[c])
+			return 1;
 	}
 
-	if (user_cfg->num_regions >= 1) {
-		if (likely((user_cfg->reg1_hor & ISPHIST_REGHORIZ_HEND_MASK) -
-			   ((user_cfg->reg1_hor &
-			     ISPHIST_REGHORIZ_HSTART_MASK) >>
-			    ISPHIST_REGHORIZ_HSTART_SHIFT))) {
-			WRITE_REG_HORIZ(isp_hist->regs.r1_h,
-					user_cfg->reg1_hor);
-		} else {
-			dev_err(isp_hist->dev,
-				"hist: Invalid Region parameters\n");
-			return -EINVAL;
-		}
+	return 0;
+}
 
-		if (likely((user_cfg->reg1_ver & ISPHIST_REGVERT_VEND_MASK) -
-			   ((user_cfg->reg1_ver &
-			     ISPHIST_REGVERT_VSTART_MASK) >>
-			    ISPHIST_REGVERT_VSTART_SHIFT))) {
-			WRITE_REG_VERT(isp_hist->regs.r1_v,
-				       user_cfg->reg1_ver);
-		} else {
-			dev_err(isp_hist->dev,
-				"hist: Invalid Region parameters\n");
-			return -EINVAL;
-		}
+/**
+ * isp_hist_update_params - Helper function to check and store user given params.
+ * @user_cfg: Pointer to user configuration structure.
+ *
+ * Returns 0 on success configuration.
+ **/
+static void isp_hist_update_params(struct isp_hist_device *isp_hist,
+				   struct isp_hist_config *user_cfg)
+{
+	int bit_shift;
+	int c;
+
+	if (!isp_hist_comp_params(isp_hist, user_cfg)) {
+		isp_hist->config.enable = user_cfg->enable;
+		return;
 	}
 
-	if (user_cfg->num_regions >= 2) {
-		if (likely((user_cfg->reg2_hor & ISPHIST_REGHORIZ_HEND_MASK) -
-			   ((user_cfg->reg2_hor &
-			     ISPHIST_REGHORIZ_HSTART_MASK) >>
-			    ISPHIST_REGHORIZ_HSTART_SHIFT))) {
-			WRITE_REG_HORIZ(isp_hist->regs.r2_h,
-					user_cfg->reg2_hor);
-		} else {
-			dev_err(isp_hist->dev,
-				"hist: Invalid Region parameters\n");
-			return -EINVAL;
-		}
+	memcpy(&isp_hist->config, user_cfg, sizeof(*user_cfg));
 
-		if (likely((user_cfg->reg2_ver & ISPHIST_REGVERT_VEND_MASK) -
-			   ((user_cfg->reg2_ver &
-			     ISPHIST_REGVERT_VSTART_MASK) >>
-			    ISPHIST_REGVERT_VSTART_SHIFT))) {
-			WRITE_REG_VERT(isp_hist->regs.r2_v,
-				       user_cfg->reg2_ver);
-		} else {
-			dev_err(isp_hist->dev,
-				"hist: Invalid Region parameters\n");
-			return -EINVAL;
-		}
+	if (user_cfg->input_bit_width > HIST_MIN_BIT_WIDTH)
+		WRITE_DATA_SIZE(isp_hist->regs.cnt, 0);
+	else
+		WRITE_DATA_SIZE(isp_hist->regs.cnt, 1);
+
+	WRITE_SOURCE(isp_hist->regs.cnt, user_cfg->source);
+
+	if (user_cfg->source == HIST_SOURCE_MEM) {
+		WRITE_HV_INFO(isp_hist->regs.h_v_info, user_cfg->hist_h_v_info);
+		WRITE_RADD(isp_hist->regs.hist_radd, user_cfg->hist_radd);
+		WRITE_RADD_OFF(isp_hist->regs.hist_radd_off,
+			       user_cfg->hist_radd_off);
 	}
 
-	if (user_cfg->num_regions >= 3) {
-		if (likely((user_cfg->reg3_hor & ISPHIST_REGHORIZ_HEND_MASK) -
-			   ((user_cfg->reg3_hor &
-			     ISPHIST_REGHORIZ_HSTART_MASK) >>
-			    ISPHIST_REGHORIZ_HSTART_SHIFT))) {
-			WRITE_REG_HORIZ(isp_hist->regs.r3_h,
-					user_cfg->reg3_hor);
-		} else {
-			dev_err(isp_hist->dev,
-				"hist: Invalid Region parameters\n");
-			return -EINVAL;
-		}
+	WRITE_CFA(isp_hist->regs.cnt, user_cfg->cfa);
+
+	WRITE_WG0(isp_hist->regs.wb_gain, user_cfg->wg[0]);
+	WRITE_WG1(isp_hist->regs.wb_gain, user_cfg->wg[1]);
+	WRITE_WG2(isp_hist->regs.wb_gain, user_cfg->wg[2]);
+	if (user_cfg->cfa == HIST_CFA_BAYER)
+		WRITE_WG3(isp_hist->regs.wb_gain, user_cfg->wg[3]);
 
-		if (likely((user_cfg->reg3_ver & ISPHIST_REGVERT_VEND_MASK) -
-			   ((user_cfg->reg3_ver &
-			     ISPHIST_REGVERT_VSTART_MASK) >>
-			    ISPHIST_REGVERT_VSTART_SHIFT))) {
-			WRITE_REG_VERT(isp_hist->regs.r3_v,
-				       user_cfg->reg3_ver);
+	/* Regions size and position */
+	for (c = 0; c < HIST_MAX_REGIONS; c++) {
+		if (c < user_cfg->num_regions) {
+			WRITE_REG_HORIZ(isp_hist->regs.reg_hor[c],
+					user_cfg->reg_hor[c]);
+			WRITE_REG_VERT(isp_hist->regs.reg_ver[c],
+				       user_cfg->reg_ver[c]);
 		} else {
-			dev_err(isp_hist->dev,
-				"hist: Invalid Region parameters\n");
-			return -EINVAL;
+			isp_hist->regs.reg_hor[c] = 0;
+			isp_hist->regs.reg_ver[c] = 0;
 		}
 	}
-	reg_num = user_cfg->num_regions;
-	if (unlikely(((user_cfg->hist_bins > BINS_256) &&
-		      (user_cfg->hist_bins != BINS_32)) ||
-		     ((user_cfg->hist_bins == BINS_256) &&
-		      reg_num != 0) || ((user_cfg->hist_bins ==
-					 BINS_128) && reg_num >= 2))) {
-		dev_err(isp_hist->dev, "hist: Invalid Bins Number: %d\n",
-		       user_cfg->hist_bins);
-		return -EINVAL;
-	} else {
-		WRITE_NUM_BINS(isp_hist->regs.cnt, user_cfg->hist_bins);
-	}
 
-	if (user_cfg->input_bit_width > MAX_BIT_WIDTH ||
-	    user_cfg->input_bit_width < MIN_BIT_WIDTH) {
-		dev_err(isp_hist->dev, "hist: Invalid Bit Width: %d\n",
-		       user_cfg->input_bit_width);
-		return -EINVAL;
-	} else {
-		switch (user_cfg->hist_bins) {
-		case BINS_256:
-			bit_shift = user_cfg->input_bit_width - 8;
-			break;
-		case BINS_128:
-			bit_shift = user_cfg->input_bit_width - 7;
-			break;
-		case BINS_64:
-			bit_shift = user_cfg->input_bit_width - 6;
-			break;
-		case BINS_32:
-			bit_shift = user_cfg->input_bit_width - 5;
-			break;
-		default:
-			return -EINVAL;
-		}
-		WRITE_BIT_SHIFT(isp_hist->regs.cnt, bit_shift);
+	WRITE_NUM_BINS(isp_hist->regs.cnt, user_cfg->hist_bins);
+	switch (user_cfg->hist_bins) {
+	case HIST_BINS_256:
+		bit_shift = user_cfg->input_bit_width - 8;
+		break;
+	case HIST_BINS_128:
+		bit_shift = user_cfg->input_bit_width - 7;
+		break;
+	case HIST_BINS_64:
+		bit_shift = user_cfg->input_bit_width - 6;
+		break;
+	default: /* HIST_BINS_32 */
+		bit_shift = user_cfg->input_bit_width - 5;
+		break;
 	}
+	WRITE_BIT_SHIFT(isp_hist->regs.cnt, bit_shift);
 
-	isp_hist_update_regs(isp_hist);
-	isp_hist->initialized = 1;
-
-	return 0;
+	isp_hist->update = 1;
 }
 
 /**
@@ -406,83 +568,107 @@ static int isp_hist_set_params(struct is
  *
  * Returns 0 on success configuration.
  **/
-int isp_hist_configure(struct isp_hist_device *isp_hist,
-		       struct isp_hist_config *histcfg)
+int omap34xx_isp_hist_config(struct isp_hist_device *isp_hist,
+			     struct isp_hist_config *histcfg)
 {
-
+	struct device *dev = to_device(isp_hist);
+	unsigned long irqflags;
 	int ret = 0;
+	unsigned int size;
+	int use_dma = HIST_USE_DMA;
+	const unsigned int size_bins[] =
+			{ HIST_MEM_SIZE_BINS(32), HIST_MEM_SIZE_BINS(64),
+			  HIST_MEM_SIZE_BINS(128), HIST_MEM_SIZE_BINS(256) };
 
-	if (NULL == histcfg) {
-		dev_err(isp_hist->dev,
-			"hist: Null argument in configuration. \n");
+	if (!histcfg) {
+		dev_dbg(dev, "hist: Null argument in configuration.\n");
 		return -EINVAL;
 	}
 
-	if (!isp_hist->initialized) {
-		DPRINTK_ISPHIST("Setting callback for HISTOGRAM\n");
-		ret = isp_set_callback(isp_hist->dev, CBK_HIST_DONE,
-				       isp_hist_isr, (void *)NULL,
-				       isp_hist);
-		if (ret) {
-			dev_err(isp_hist->dev, "hist: No callback for HIST\n");
-			return ret;
-		}
+	/* Check Parameters */
+	ret = isp_hist_validate_params(histcfg);
+	if (ret) {
+		dev_dbg(dev, "hist: wrong configure params received.\n");
+		return ret;
 	}
 
-	ret = isp_hist_set_params(isp_hist, histcfg);
+	size = size_bins[histcfg->hist_bins] * histcfg->num_regions;
+
+	/* Cannot use DMA if no channel is available */
+	if (unlikely(HIST_USE_DMA && (isp_hist->dma_ch < 0)))
+		use_dma = 0;
+
+	/* Alloc buffers */
+	spin_lock_irqsave(&isp_hist->lock, irqflags);
+	if (isp_hist->waiting_dma) {
+		omap_stop_dma(isp_hist->dma_ch);
+		isp_hist->waiting_dma = 0;
+	}
+	spin_unlock_irqrestore(&isp_hist->lock, irqflags);
+
+	ret = ispstat_bufs_alloc(&isp_hist->stat, size, use_dma);
 	if (ret) {
-		dev_err(isp_hist->dev, "hist: Invalid parameters! \n");
-		return ret;
+		if (use_dma)
+			ret = ispstat_bufs_alloc(&isp_hist->stat, size, 0);
+
+		if (ret) {
+			dev_err(dev, "hist: unable to alloc buffers.\n");
+			isp_hist->config.enable = 0;
+			return ret;
+		} else {
+			use_dma = 0;
+			dev_dbg(dev, "hist: unable to alloc buffers for DMA. "
+				      "PIO will be used.\n");
+		}
 	}
 
-	isp_hist->frame_cnt = 0;
-	isp_hist->completed = 0;
-	isp_hist_enable(isp_hist, 1);
-	isp_hist_print_status(isp_hist);
+	spin_lock_irqsave(&isp_hist->lock, irqflags);
+	isp_hist->buf_size = size;
+	isp_hist->use_dma = use_dma;
+	isp_hist_update_params(isp_hist, histcfg);
+	spin_unlock_irqrestore(&isp_hist->lock, irqflags);
 
 	return 0;
 }
-EXPORT_SYMBOL(isp_hist_configure);
 
 /**
- * isp_hist_request_statistics - Request statistics in Histogram.
+ * omap34xx_isp_hist_request_statistics - Request statistics in Histogram.
  * @histdata: Pointer to data structure.
  *
  * This API allows the user to request for histogram statistics.
  *
  * Returns 0 on successful request.
  **/
-int isp_hist_request_statistics(struct isp_hist_device *isp_hist,
-				struct isp_hist_data *histdata)
+int omap34xx_isp_hist_request_statistics(struct isp_hist_device *isp_hist,
+					 struct isp_hist_data *histdata)
 {
-	int i, ret;
-	u32 curr;
-
-	if (isp_hist_busy(isp_hist))
-		return -EBUSY;
+	struct device *dev = to_device(isp_hist);
+	struct ispstat_buffer *buf;
 
-	if (!isp_hist->completed && isp_hist->initialized)
+	if (!isp_hist->config.enable) {
+		dev_dbg(dev, "hist: statistics requested while engine is not "
+			     "configured\n");
 		return -EINVAL;
+	}
 
-	isp_reg_or(isp_hist->dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,
-		   ISPHIST_CNT_CLR_EN);
+	if (histdata->update & REQUEST_STATISTICS) {
+		buf = ispstat_buf_get(&isp_hist->stat,
+				      (void *)histdata->hist_statistics_buf,
+				      histdata->frame_number);
+		if (IS_ERR(buf))
+			return PTR_ERR(buf);
 
-	for (i = 0; i < HIST_MEM_SIZE; i++) {
-		curr = isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
-				     ISPHIST_DATA);
-		ret = put_user(curr, histdata->hist_statistics_buf + i);
-		if (ret) {
-			dev_err(isp_hist->dev, "hist: Failed copy_to_user for "
-			       "HIST stats buff, %d\n", ret);
-		}
+		histdata->ts = buf->ts;
+		histdata->config_counter = buf->config_counter;
+		histdata->frame_number = buf->frame_number;
+
+		ispstat_buf_release(&isp_hist->stat);
 	}
 
-	isp_reg_and(isp_hist->dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,
-		    ~ISPHIST_CNT_CLR_EN);
-	isp_hist->completed = 0;
+	histdata->curr_frame = isp_hist->stat.frame_number;
+
 	return 0;
 }
-EXPORT_SYMBOL(isp_hist_request_statistics);
 
 /**
  * isp_hist_init - Module Initialization.
@@ -492,10 +678,30 @@ EXPORT_SYMBOL(isp_hist_request_statistic
 int __init isp_hist_init(struct device *dev)
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
+	struct isp_hist_device *isp_hist = &isp->isp_hist;
+	int ret = -1;
+
+	if (HIST_USE_DMA)
+		ret = omap_request_dma(OMAP24XX_DMA_NO_DEVICE, "DMA_ISP_HIST",
+				       isp_hist_dma_cb, isp_hist,
+				       &isp_hist->dma_ch);
+	if (ret) {
+		if (HIST_USE_DMA)
+			dev_info(dev, "hist: DMA request channel failed. Using "
+				      "PIO only.\n");
+		isp_hist->dma_ch = -1;
+	} else {
+		dev_dbg(dev, "hist: DMA channel = %d\n", isp_hist->dma_ch);
+		omap_enable_dma_irq(isp_hist->dma_ch, OMAP_DMA_BLOCK_IRQ);
+	}
 
-	isp->isp_hist.dev = dev;
+	spin_lock_init(&isp_hist->lock);
+	ret = ispstat_init(dev, "HIST", &isp_hist->stat, HIST_MAX_BUFF,
+			    MAX_FRAME_COUNT);
+	if (ret && (isp_hist->dma_ch >= 0))
+		omap_free_dma(isp_hist->dma_ch);
 
-	return 0;
+	return ret;
 }
 
 /**
@@ -503,6 +709,12 @@ int __init isp_hist_init(struct device *
  **/
 void isp_hist_cleanup(struct device *dev)
 {
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	isp->isp_hist.active_buf = NULL;
+	ispstat_free(&isp->isp_hist.stat);
+	if (isp->isp_hist.dma_ch >= 0)
+		omap_free_dma(isp->isp_hist.dma_ch);
 }
 
 /**
@@ -510,69 +722,52 @@ void isp_hist_cleanup(struct device *dev
  **/
 void isphist_save_context(struct device *dev)
 {
-	DPRINTK_ISPHIST(" Saving context\n");
 	isp_save_context(dev, isphist_reg_list);
 }
-EXPORT_SYMBOL(isphist_save_context);
 
 /**
  * isphist_restore_context - Restores the values of the histogram module regs.
  **/
 void isphist_restore_context(struct device *dev)
 {
-	DPRINTK_ISPHIST(" Restoring context\n");
 	isp_restore_context(dev, isphist_reg_list);
 }
-EXPORT_SYMBOL(isphist_restore_context);
 
 /**
  * isp_hist_print_status - Debug print
  **/
 static void isp_hist_print_status(struct isp_hist_device *isp_hist)
 {
-	DPRINTK_ISPHIST("ISPHIST_PCR = 0x%08x\n",
-			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
-				      ISPHIST_PCR));
-	DPRINTK_ISPHIST("ISPHIST_CNT = 0x%08x\n",
-			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
-				      ISPHIST_CNT));
-	DPRINTK_ISPHIST("ISPHIST_WB_GAIN = 0x%08x\n",
-			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
-				      ISPHIST_WB_GAIN));
-	DPRINTK_ISPHIST("ISPHIST_R0_HORZ = 0x%08x\n",
-			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
-				      ISPHIST_R0_HORZ));
-	DPRINTK_ISPHIST("ISPHIST_R0_VERT = 0x%08x\n",
-			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
-				      ISPHIST_R0_VERT));
-	DPRINTK_ISPHIST("ISPHIST_R1_HORZ = 0x%08x\n",
-			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
-				      ISPHIST_R1_HORZ));
-	DPRINTK_ISPHIST("ISPHIST_R1_VERT = 0x%08x\n",
-			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
-				      ISPHIST_R1_VERT));
-	DPRINTK_ISPHIST("ISPHIST_R2_HORZ = 0x%08x\n",
-			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
-				      ISPHIST_R2_HORZ));
-	DPRINTK_ISPHIST("ISPHIST_R2_VERT = 0x%08x\n",
-			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
-				      ISPHIST_R2_VERT));
-	DPRINTK_ISPHIST("ISPHIST_R3_HORZ = 0x%08x\n",
-			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
-				      ISPHIST_R3_HORZ));
-	DPRINTK_ISPHIST("ISPHIST_R3_VERT = 0x%08x\n",
-			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
-				      ISPHIST_R3_VERT));
-	DPRINTK_ISPHIST("ISPHIST_ADDR = 0x%08x\n",
-			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
-				      ISPHIST_ADDR));
-	DPRINTK_ISPHIST("ISPHIST_RADD = 0x%08x\n",
-			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
-				      ISPHIST_RADD));
-	DPRINTK_ISPHIST("ISPHIST_RADD_OFF = 0x%08x\n",
-			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
-				      ISPHIST_RADD_OFF));
-	DPRINTK_ISPHIST("ISPHIST_H_V_INFO = 0x%08x\n",
-			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
-				      ISPHIST_H_V_INFO));
+#ifdef ISP_HIST_DEBUG
+	struct device *dev = to_device(isp_hist);
+
+	dev_dbg(dev, "hist: ISPHIST_PCR = 0x%08x\n",
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_PCR));
+	dev_dbg(dev, "hist: ISPHIST_CNT = 0x%08x\n",
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT));
+	dev_dbg(dev, "hist: ISPHIST_WB_GAIN = 0x%08x\n",
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_WB_GAIN));
+	dev_dbg(dev, "hist: ISPHIST_R0_HORZ = 0x%08x\n",
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_R0_HORZ));
+	dev_dbg(dev, "hist: ISPHIST_R0_VERT = 0x%08x\n",
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_R0_VERT));
+	dev_dbg(dev, "hist: ISPHIST_R1_HORZ = 0x%08x\n",
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_R1_HORZ));
+	dev_dbg(dev, "hist: ISPHIST_R1_VERT = 0x%08x\n",
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_R1_VERT));
+	dev_dbg(dev, "hist: ISPHIST_R2_HORZ = 0x%08x\n",
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_R2_HORZ));
+	dev_dbg(dev, "hist: ISPHIST_R2_VERT = 0x%08x\n",
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_R2_VERT));
+	dev_dbg(dev, "hist: ISPHIST_R3_HORZ = 0x%08x\n",
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_R3_HORZ));
+	dev_dbg(dev, "hist: ISPHIST_R3_VERT = 0x%08x\n",
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_R3_VERT));
+	dev_dbg(dev, "hist: ISPHIST_RADD = 0x%08x\n",
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_RADD));
+	dev_dbg(dev, "hist: ISPHIST_RADD_OFF = 0x%08x\n",
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_RADD_OFF));
+	dev_dbg(dev, "hist: ISPHIST_H_V_INFO = 0x%08x\n",
+		isp_reg_readl(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_H_V_INFO));
+#endif
 }
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isphist.h kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isphist.h
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isphist.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isphist.h	2012-12-16 13:13:01.664330147 +0100
@@ -6,6 +6,7 @@
  * Copyright (C) 2009 Texas Instruments, Inc.
  *
  * Contributors:
+ * 	David Cohen <david.cohen@nokia.com>
  *	Sergio Aguirre <saaguirre@ti.com>
  *	Troy Laramy
  *
@@ -22,15 +23,11 @@
 #define OMAP_ISP_HIST_H
 
 #include <mach/isp_user.h>
+#include <mach/dma.h>
 
-#define MAX_REGIONS		0x4
-#define MAX_WB_GAIN		255
-#define MIN_WB_GAIN		0x0
-#define MAX_BIT_WIDTH		14
-#define MIN_BIT_WIDTH		8
+#include "ispstat.h"
 
 #define ISPHIST_PCR_EN		(1 << 0)
-#define HIST_MEM_SIZE		1024
 #define ISPHIST_CNT_CLR_EN	(1 << 7)
 
 #define WRITE_SOURCE(reg, source)			\
@@ -61,19 +58,23 @@
 	(reg = (reg & ~(ISPHIST_CNT_BINS_MASK))		\
 	 | (num_bins << ISPHIST_CNT_BINS_SHIFT))
 
-#define WRITE_WB_R(reg, reg_wb_gain)				\
+#define WRITE_CFA(reg, cfa)				\
+	(reg = (reg & ~(ISPHIST_CNT_CFA_MASK))		\
+	 | (cfa << ISPHIST_CNT_CFA_SHIFT))
+
+#define WRITE_WG0(reg, reg_wb_gain)				\
 	reg = ((reg & ~(ISPHIST_WB_GAIN_WG00_MASK))		\
 	       | (reg_wb_gain << ISPHIST_WB_GAIN_WG00_SHIFT))
 
-#define WRITE_WB_RG(reg, reg_wb_gain)			\
+#define WRITE_WG1(reg, reg_wb_gain)			\
 	(reg = (reg & ~(ISPHIST_WB_GAIN_WG01_MASK))	\
 	 | (reg_wb_gain << ISPHIST_WB_GAIN_WG01_SHIFT))
 
-#define WRITE_WB_B(reg, reg_wb_gain)			\
+#define WRITE_WG2(reg, reg_wb_gain)			\
 	(reg = (reg & ~(ISPHIST_WB_GAIN_WG02_MASK))	\
 	 | (reg_wb_gain << ISPHIST_WB_GAIN_WG02_SHIFT))
 
-#define WRITE_WB_BG(reg, reg_wb_gain)			\
+#define WRITE_WG3(reg, reg_wb_gain)			\
 	(reg = (reg & ~(ISPHIST_WB_GAIN_WG03_MASK))	\
 	 | (reg_wb_gain << ISPHIST_WB_GAIN_WG03_SHIFT))
 
@@ -90,16 +91,8 @@
  * @pcr: Peripheral control register.
  * @cnt: Histogram control register.
  * @wb_gain: Histogram white balance gain register.
- * @r0_h: Region 0 horizontal register.
- * @r0_v: Region 0 vertical register.
- * @r1_h: Region 1 horizontal register.
- * @r1_v: Region 1 vertical register.
- * @r2_h: Region 2 horizontal register.
- * @r2_v: Region 2 vertical register.
- * @r3_h: Region 3 horizontal register.
- * @r3_v: Region 3 vertical register.
- * @hist_addr: Histogram address register.
- * @hist_data: Histogram data.
+ * @reg_hor[]: Region N horizontal register.
+ * @reg_ver[]: Region N vertical register.
  * @hist_radd: Address register. When input data comes from mem.
  * @hist_radd_off: Address offset register. When input data comes from mem.
  * @h_v_info: Image size register. When input data comes from mem.
@@ -108,16 +101,8 @@ struct isp_hist_regs {
 	u32 pcr;
 	u32 cnt;
 	u32 wb_gain;
-	u32 r0_h;
-	u32 r0_v;
-	u32 r1_h;
-	u32 r1_v;
-	u32 r2_h;
-	u32 r2_v;
-	u32 r3_h;
-	u32 r3_v;
-	u32 hist_addr;
-	u32 hist_data;
+	u32 reg_hor[HIST_MAX_REGIONS];
+	u32 reg_ver[HIST_MAX_REGIONS];
 	u32 hist_radd;
 	u32 hist_radd_off;
 	u32 h_v_info;
@@ -126,38 +111,49 @@ struct isp_hist_regs {
 /**
  * struct isp_hist_status - Histogram status.
  * @hist_enable: Enables the histogram module.
- * @initialized: Flag to indicate that the module is correctly initializated.
+ * @initialized: Flag to indicate that the module is correctly initialized.
  * @frame_cnt: Actual frame count.
- * @frame_req: Frame requested by user.
+ * @num_acc_frames: Num accumulated image frames per hist frame
  * @completed: Flag to indicate if a frame request is completed.
  */
 struct isp_hist_device {
-	u8 hist_enable;
-	u8 pm_state;
-	u8 initialized;
-	u8 frame_cnt;
-	u8 frame_req;
-	u8 completed;
+	u8 enabled;
+	u8 update;
+	u8 num_acc_frames;
+	u8 waiting_dma;
+	u8 invalid_buf;
+	u8 use_dma;
+	int dma_ch;
+	struct timeval ts;
+
+	struct omap_dma_channel_params dma_config;
 	struct isp_hist_regs regs;
-	struct device *dev;
+	struct isp_hist_config config;
+	struct ispstat_buffer *active_buf;
+	unsigned int buf_size;
+	struct ispstat stat;
+
+	spinlock_t lock;	/* serialize access to hist device's fields */
 };
 
-void isp_hist_enable(struct isp_hist_device *isp_hist, u8 enable);
+#define HIST_BUF_DONE		0
+#define HIST_NO_BUF		1
+#define HIST_BUF_WAITING_DMA	2
 
 int isp_hist_busy(struct isp_hist_device *isp_hist);
-
-int isp_hist_configure(struct isp_hist_device *isp_hist,
-		       struct isp_hist_config *histcfg);
-
-int isp_hist_request_statistics(struct isp_hist_device *isp_hist,
-				struct isp_hist_data *histdata);
-
-void isphist_save_context(struct device *dev);
-
+void isp_hist_enable(struct isp_hist_device *isp_hist, u8 enable);
+void isp_hist_try_enable(struct isp_hist_device *isp_hist);
+int isp_hist_busy(struct isp_hist_device *isp_hist);
+int isp_hist_buf_process(struct isp_hist_device *isp_hist);
+void isp_hist_mark_invalid_buf(struct isp_hist_device *isp_hist);
+void isp_hist_config_registers(struct isp_hist_device *isp_hist);
 void isp_hist_suspend(struct isp_hist_device *isp_hist);
-
 void isp_hist_resume(struct isp_hist_device *isp_hist);
-
+void isphist_save_context(struct device *dev);
 void isphist_restore_context(struct device *dev);
+int omap34xx_isp_hist_config(struct isp_hist_device *isp_hist,
+			     struct isp_hist_config *histcfg);
+int omap34xx_isp_hist_request_statistics(struct isp_hist_device *isp_hist,
+					 struct isp_hist_data *histdata);
 
 #endif				/* OMAP_ISP_HIST */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isph3a.c kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isph3a.c
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isph3a.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isph3a.c	2012-12-16 13:13:01.664330147 +0100
@@ -18,16 +18,10 @@
  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#include <asm/cacheflush.h>
-
 #include <linux/dma-mapping.h>
 #include <linux/uaccess.h>
 
 #include "isp.h"
-#include "ispreg.h"
-#include "isph3a.h"
-#include "ispmmu.h"
-#include "isppreview.h"
 
 /* Structure for saving/restoring h3a module registers */
 static struct isp_reg isph3a_reg_list[] = {
@@ -59,67 +53,16 @@ static struct isp_reg isph3a_reg_list[]
 
 static void isph3a_print_status(struct isp_h3a_device *isp_h3a);
 
-/**
- * isph3a_aewb_setxtrastats - Receives extra statistics from prior frames.
- * @xtrastats: Pointer to structure containing extra statistics fields like
- *             field count and timestamp of frame.
- *
- * Called from update_vbq in camera driver
- **/
-void isph3a_aewb_setxtrastats(struct isp_h3a_device *isp_h3a,
-			      struct isph3a_aewb_xtrastats *xtrastats)
-{
-	int i;
-
-	if (isp_h3a->active_buff == NULL)
-		return;
-
-	for (i = 0; i < H3A_MAX_BUFF; i++) {
-		if (isp_h3a->buff[i].frame_num !=
-					isp_h3a->active_buff->frame_num)
-			continue;
-
-		if (i == 0) {
-			if (isp_h3a->buff[H3A_MAX_BUFF - 1].locked == 0) {
-				isp_h3a->xtrastats[H3A_MAX_BUFF - 1] =
-					*xtrastats;
-			} else {
-				isp_h3a->xtrastats[H3A_MAX_BUFF - 2] =
-					*xtrastats;
-			}
-		} else if (i == 1) {
-			if (isp_h3a->buff[0].locked == 0)
-				isp_h3a->xtrastats[0] = *xtrastats;
-			else {
-				isp_h3a->xtrastats[H3A_MAX_BUFF - 1] =
-					*xtrastats;
-			}
-		} else {
-			if (isp_h3a->buff[i - 1].locked == 0)
-				isp_h3a->xtrastats[i - 1] = *xtrastats;
-			else
-				isp_h3a->xtrastats[i - 2] = *xtrastats;
-		}
-		return;
-	}
-}
-EXPORT_SYMBOL(isph3a_aewb_setxtrastats);
-
 void __isph3a_aewb_enable(struct isp_h3a_device *isp_h3a, u8 enable)
 {
-	isp_reg_writel(isp_h3a->dev, IRQ0STATUS_H3A_AWB_DONE_IRQ,
-		       OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);
+	struct device *dev = to_device(isp_h3a);
+	u32 pcr = isp_reg_readl(dev, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR);
 
-	if (enable) {
-		isp_h3a->regs.pcr |= ISPH3A_PCR_AEW_EN;
-		DPRINTK_ISPH3A("    H3A enabled \n");
-	} else {
-		isp_h3a->regs.pcr &= ~ISPH3A_PCR_AEW_EN;
-		DPRINTK_ISPH3A("    H3A disabled \n");
-	}
-	isp_reg_and_or(isp_h3a->dev, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR,
-		       ~ISPH3A_PCR_AEW_EN, (enable ? ISPH3A_PCR_AEW_EN : 0));
-	isp_h3a->aewb_config_local.aewb_enable = enable;
+	if (enable)
+		pcr |= ISPH3A_PCR_AEW_EN;
+	else
+		pcr &= ~ISPH3A_PCR_AEW_EN;
+	isp_reg_writel(dev, pcr, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR);
 }
 
 /**
@@ -130,8 +73,19 @@ void __isph3a_aewb_enable(struct isp_h3a
  **/
 void isph3a_aewb_enable(struct isp_h3a_device *isp_h3a, u8 enable)
 {
+	unsigned long irqflags;
+
+	spin_lock_irqsave(isp_h3a->lock, irqflags);
+
+	if (!isp_h3a->aewb_config_local.aewb_enable && enable) {
+		spin_unlock_irqrestore(isp_h3a->lock, irqflags);
+		return;
+	}
+
 	__isph3a_aewb_enable(isp_h3a, enable);
-	isp_h3a->pm_state = enable;
+	isp_h3a->enabled = enable;
+
+	spin_unlock_irqrestore(isp_h3a->lock, irqflags);
 }
 
 /**
@@ -139,8 +93,14 @@ void isph3a_aewb_enable(struct isp_h3a_d
  **/
 void isph3a_aewb_suspend(struct isp_h3a_device *isp_h3a)
 {
-	if (isp_h3a->pm_state)
+	unsigned long flags;
+
+	spin_lock_irqsave(isp_h3a->lock, flags);
+
+	if (isp_h3a->enabled)
 		__isph3a_aewb_enable(isp_h3a, 0);
+
+	spin_unlock_irqrestore(isp_h3a->lock, flags);
 }
 
 /**
@@ -148,16 +108,39 @@ void isph3a_aewb_suspend(struct isp_h3a_
  **/
 void isph3a_aewb_resume(struct isp_h3a_device *isp_h3a)
 {
-	if (isp_h3a->pm_state)
+	unsigned long flags;
+
+	spin_lock_irqsave(isp_h3a->lock, flags);
+
+	if (isp_h3a->enabled)
 		__isph3a_aewb_enable(isp_h3a, 1);
+
+	spin_unlock_irqrestore(isp_h3a->lock, flags);
 }
 
 int isph3a_aewb_busy(struct isp_h3a_device *isp_h3a)
 {
-	return isp_reg_readl(isp_h3a->dev, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR)
+	struct device *dev = to_device(isp_h3a);
+
+	return isp_reg_readl(dev, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR)
 		& ISPH3A_PCR_BUSYAEAWB;
 }
 
+void isph3a_aewb_try_enable(struct isp_h3a_device *isp_h3a)
+{
+	unsigned long irqflags;
+
+	spin_lock_irqsave(isp_h3a->lock, irqflags);
+	if (!isp_h3a->enabled && isp_h3a->aewb_config_local.aewb_enable) {
+		isp_h3a->update = 1;
+		isp_h3a->buf_next = ispstat_buf_next(&isp_h3a->stat);
+		spin_unlock_irqrestore(isp_h3a->lock, irqflags);
+		isph3a_aewb_config_registers(isp_h3a);
+		isph3a_aewb_enable(isp_h3a, 1);
+	} else
+		spin_unlock_irqrestore(isp_h3a->lock, irqflags);
+}
+
 /**
  * isph3a_update_wb - Updates WB parameters.
  *
@@ -165,9 +148,10 @@ int isph3a_aewb_busy(struct isp_h3a_devi
  **/
 void isph3a_update_wb(struct isp_h3a_device *isp_h3a)
 {
-	struct isp_device *isp = dev_get_drvdata(isp_h3a->dev);
+	struct isp_device *isp = to_isp_device(isp_h3a);
 
 	if (isp_h3a->wb_update) {
+		/* FIXME: Get the preview crap out of here!!! */
 		isppreview_config_whitebalance(&isp->isp_prev,
 					       isp_h3a->h3awb_update);
 		isp_h3a->wb_update = 0;
@@ -179,35 +163,38 @@ EXPORT_SYMBOL(isph3a_update_wb);
 /**
  * isph3a_aewb_update_regs - Helper function to update h3a registers.
  **/
-static void isph3a_aewb_update_regs(struct isp_h3a_device *isp_h3a)
+void isph3a_aewb_config_registers(struct isp_h3a_device *isp_h3a)
 {
-	isp_reg_writel(isp_h3a->dev, isp_h3a->regs.pcr, OMAP3_ISP_IOMEM_H3A,
-		       ISPH3A_PCR);
-	isp_reg_writel(isp_h3a->dev, isp_h3a->regs.win1, OMAP3_ISP_IOMEM_H3A,
+	struct device *dev = to_device(isp_h3a);
+	unsigned long irqflags;
+
+	if (!isp_h3a->aewb_config_local.aewb_enable)
+		return;
+
+	spin_lock_irqsave(isp_h3a->lock, irqflags);
+
+	isp_reg_writel(dev, isp_h3a->buf_next->iommu_addr,
+		       OMAP3_ISP_IOMEM_H3A, ISPH3A_AEWBUFST);
+
+	if (!isp_h3a->update) {
+		spin_unlock_irqrestore(isp_h3a->lock, irqflags);
+		return;
+	}
+
+	isp_reg_writel(dev, isp_h3a->regs.win1, OMAP3_ISP_IOMEM_H3A,
 		       ISPH3A_AEWWIN1);
-	isp_reg_writel(isp_h3a->dev, isp_h3a->regs.start, OMAP3_ISP_IOMEM_H3A,
+	isp_reg_writel(dev, isp_h3a->regs.start, OMAP3_ISP_IOMEM_H3A,
 		       ISPH3A_AEWINSTART);
-	isp_reg_writel(isp_h3a->dev, isp_h3a->regs.blk, OMAP3_ISP_IOMEM_H3A,
+	isp_reg_writel(dev, isp_h3a->regs.blk, OMAP3_ISP_IOMEM_H3A,
 		       ISPH3A_AEWINBLK);
-	isp_reg_writel(isp_h3a->dev, isp_h3a->regs.subwin, OMAP3_ISP_IOMEM_H3A,
+	isp_reg_writel(dev, isp_h3a->regs.subwin, OMAP3_ISP_IOMEM_H3A,
 		       ISPH3A_AEWSUBWIN);
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR,
+		       ~ISPH3A_PCR_AEW_MASK, isp_h3a->regs.pcr);
 
 	isp_h3a->update = 0;
-	isp_h3a->frame_count = 1;
-}
 
-/**
- * isph3a_aewb_update_req_buffer - Helper function to update buffer cache pages
- * @buffer: Pointer to structure
- **/
-static void isph3a_aewb_update_req_buffer(struct isp_h3a_device *isp_h3a,
-					  struct isph3a_aewb_buffer *buffer)
-{
-	int size = isp_h3a->stats_buf_size;
-
-	size = PAGE_ALIGN(size);
-	dmac_inv_range((void *)buffer->addr_align,
-		       (void *)buffer->addr_align + size);
+	spin_unlock_irqrestore(isp_h3a->lock, irqflags);
 }
 
 /**
@@ -216,119 +203,95 @@ static void isph3a_aewb_update_req_buffe
  *
  * Returns 0 if successful, or -1 if statistics are unavailable.
  **/
-static int isph3a_aewb_stats_available(struct isp_h3a_device *isp_h3a,
-				       struct isph3a_aewb_data *aewbdata)
+static int isph3a_aewb_get_stats(struct isp_h3a_device *isp_h3a,
+				 struct isph3a_aewb_data *aewbdata)
 {
-	int i, ret;
-	unsigned long irqflags;
+	struct ispstat_buffer *buf;
 
-	spin_lock_irqsave(&isp_h3a->buffer_lock, irqflags);
-	for (i = 0; i < H3A_MAX_BUFF; i++) {
-		DPRINTK_ISPH3A("Checking Stats buff[%d] (%d) for %d\n",
-			       i, isp_h3a->buff[i].frame_num,
-			       aewbdata->frame_number);
-		if ((aewbdata->frame_number !=
-		     isp_h3a->buff[i].frame_num) ||
-		    (isp_h3a->buff[i].frame_num ==
-		     isp_h3a->active_buff->frame_num))
-			continue;
-		isp_h3a->buff[i].locked = 1;
-		spin_unlock_irqrestore(&isp_h3a->buffer_lock, irqflags);
-		isph3a_aewb_update_req_buffer(isp_h3a, &isp_h3a->buff[i]);
-		isp_h3a->buff[i].frame_num = 0;
-		ret = copy_to_user((void *)aewbdata->h3a_aewb_statistics_buf,
-				   (void *)isp_h3a->buff[i].virt_addr,
-				   isp_h3a->curr_cfg_buf_size);
-		if (ret) {
-			dev_err(isp_h3a->dev, "h3a: Failed copy_to_user for "
-			       "H3A stats buff, %d\n", ret);
-		}
-		aewbdata->ts = isp_h3a->buff[i].ts;
-		aewbdata->config_counter = isp_h3a->buff[i].config_counter;
-		aewbdata->field_count = isp_h3a->xtrastats[i].field_count;
-		return 0;
-	}
-	spin_unlock_irqrestore(&isp_h3a->buffer_lock, irqflags);
+	buf = ispstat_buf_get(&isp_h3a->stat,
+			      (void *)aewbdata->h3a_aewb_statistics_buf,
+			      aewbdata->frame_number);
+
+	if (IS_ERR(buf))
+		return PTR_ERR(buf);
 
-	return -1;
+	aewbdata->ts = buf->ts;
+	aewbdata->config_counter = buf->config_counter;
+	aewbdata->frame_number = buf->frame_number;
+
+	ispstat_buf_release(&isp_h3a->stat);
+
+	return 0;
 }
 
 /**
- * isph3a_aewb_link_buffers - Helper function to link allocated buffers.
- **/
-static void isph3a_aewb_link_buffers(struct isp_h3a_device *isp_h3a)
+ * isph3a_aewb_buf_process - Process H3A AEWB buffer.
+ */
+int isph3a_aewb_buf_process(struct isp_h3a_device *isp_h3a)
 {
-	int i;
+	isph3a_update_wb(isp_h3a);
+	if (likely(!isp_h3a->buf_err &&
+				isp_h3a->aewb_config_local.aewb_enable)) {
+		int ret;
 
-	for (i = 0; i < H3A_MAX_BUFF; i++) {
-		if ((i + 1) < H3A_MAX_BUFF) {
-			isp_h3a->buff[i].next = &isp_h3a->buff[i + 1];
-			isp_h3a->xtrastats[i].next = &isp_h3a->xtrastats[i + 1];
-		} else {
-			isp_h3a->buff[i].next = &isp_h3a->buff[0];
-			isp_h3a->xtrastats[i].next = &isp_h3a->xtrastats[0];
-		}
+		ret = ispstat_buf_queue(&isp_h3a->stat);
+		isp_h3a->buf_next = ispstat_buf_next(&isp_h3a->stat);
+		return ret;
+	} else {
+		isp_h3a->buf_err = 0;
+		return -1;
 	}
 }
 
-/**
- * isph3a_aewb_unlock_buffers - Helper function to unlock all buffers.
- **/
-static void isph3a_aewb_unlock_buffers(struct isp_h3a_device *isp_h3a)
+static int isph3a_aewb_validate_params(struct isp_h3a_device *isp_h3a,
+				       struct isph3a_aewb_config *user_cfg)
 {
-	int i;
-	unsigned long irqflags;
+	if (unlikely(user_cfg->saturation_limit > MAX_SATURATION_LIM))
+		return -EINVAL;
 
-	spin_lock_irqsave(&isp_h3a->buffer_lock, irqflags);
-	for (i = 0; i < H3A_MAX_BUFF; i++)
-		isp_h3a->buff[i].locked = 0;
+	if (unlikely(user_cfg->win_height < MIN_WIN_H ||
+		     user_cfg->win_height > MAX_WIN_H ||
+		     user_cfg->win_height & 0x01))
+		return -EINVAL;
 
-	spin_unlock_irqrestore(&isp_h3a->buffer_lock, irqflags);
-}
+	if (unlikely(user_cfg->win_width < MIN_WIN_W ||
+		     user_cfg->win_width > MAX_WIN_W ||
+		     user_cfg->win_width & 0x01))
+		return -EINVAL;
 
-/**
- * isph3a_aewb_isr - Callback from ISP driver for H3A AEWB interrupt.
- * @status: IRQ0STATUS in case of MMU error, 0 for H3A interrupt.
- * @arg1: Not used as of now.
- * @arg2: Not used as of now.
- */
-static void isph3a_aewb_isr(unsigned long status, isp_vbq_callback_ptr arg1,
-			    void *arg2)
-{
-	struct isp_h3a_device *isp_h3a = arg2;
-	u16 frame_align;
+	if (unlikely(user_cfg->ver_win_count < 1 ||
+		     user_cfg->ver_win_count > MAX_WINVC))
+		return -EINVAL;
 
-	if ((H3A_AWB_DONE & status) != H3A_AWB_DONE)
-		return;
+	if (unlikely(user_cfg->hor_win_count < 1 ||
+		     user_cfg->hor_win_count > MAX_WINHC))
+		return -EINVAL;
 
-	do_gettimeofday(&isp_h3a->active_buff->ts);
-	isp_h3a->active_buff->config_counter =
-					atomic_read(&isp_h3a->config_counter);
-	isp_h3a->active_buff = isp_h3a->active_buff->next;
-	if (isp_h3a->active_buff->locked == 1)
-		isp_h3a->active_buff = isp_h3a->active_buff->next;
-	isp_reg_writel(isp_h3a->dev, isp_h3a->active_buff->ispmmu_addr,
-		       OMAP3_ISP_IOMEM_H3A, ISPH3A_AEWBUFST);
+	if (unlikely(user_cfg->ver_win_start > MAX_WINSTART))
+		return -EINVAL;
 
-	isp_h3a->frame_count++;
-	frame_align = isp_h3a->frame_count;
-	if (isp_h3a->frame_count > MAX_FRAME_COUNT) {
-		isp_h3a->frame_count = 1;
-		frame_align++;
-	}
-	isp_h3a->active_buff->frame_num = isp_h3a->frame_count;
-
-	if (isp_h3a->stats_req) {
-		DPRINTK_ISPH3A("waiting for frame %d\n", isp_h3a->frame_req);
-		if (frame_align >= isp_h3a->frame_req + 1) {
-			isp_h3a->stats_req = 0;
-			isp_h3a->stats_done = 1;
-			wake_up_interruptible(&isp_h3a->stats_wait);
-		}
-	}
+	if (unlikely(user_cfg->hor_win_start > MAX_WINSTART))
+		return -EINVAL;
 
-	if (isp_h3a->update)
-		isph3a_aewb_update_regs(isp_h3a);
+	if (unlikely(user_cfg->blk_ver_win_start > MAX_WINSTART))
+		return -EINVAL;
+
+	if (unlikely(user_cfg->blk_win_height < MIN_WIN_H ||
+		     user_cfg->blk_win_height > MAX_WIN_H ||
+		     user_cfg->blk_win_height & 0x01))
+		return -EINVAL;
+
+	if (unlikely(user_cfg->subsample_ver_inc < MIN_SUB_INC ||
+		     user_cfg->subsample_ver_inc > MAX_SUB_INC ||
+		     user_cfg->subsample_ver_inc & 0x01))
+		return -EINVAL;
+
+	if (unlikely(user_cfg->subsample_hor_inc < MIN_SUB_INC ||
+		     user_cfg->subsample_hor_inc > MAX_SUB_INC ||
+		     user_cfg->subsample_hor_inc & 0x01))
+		return -EINVAL;
+
+	return 0;
 }
 
 /**
@@ -340,14 +303,9 @@ static void isph3a_aewb_isr(unsigned lon
  *
  * Returns 0 if successful, or -EINVAL if any of the parameters are invalid.
  **/
-static int isph3a_aewb_set_params(struct isp_h3a_device *isp_h3a,
-				  struct isph3a_aewb_config *user_cfg)
+static void isph3a_aewb_set_params(struct isp_h3a_device *isp_h3a,
+				   struct isph3a_aewb_config *user_cfg)
 {
-	if (unlikely(user_cfg->saturation_limit > MAX_SATURATION_LIM)) {
-		dev_err(isp_h3a->dev, "h3a: Invalid Saturation_limit: %d\n",
-		       user_cfg->saturation_limit);
-		return -EINVAL;
-	}
 	if (isp_h3a->aewb_config_local.saturation_limit !=
 						user_cfg->saturation_limit) {
 		WRITE_SAT_LIM(isp_h3a->regs.pcr, user_cfg->saturation_limit);
@@ -362,39 +320,18 @@ static int isph3a_aewb_set_params(struct
 		isp_h3a->update = 1;
 	}
 
-	if (unlikely(user_cfg->win_height < MIN_WIN_H ||
-		     user_cfg->win_height > MAX_WIN_H ||
-		     user_cfg->win_height & 0x01)) {
-		dev_err(isp_h3a->dev, "h3a: Invalid window height: %d\n",
-		       user_cfg->win_height);
-		return -EINVAL;
-	}
 	if (isp_h3a->aewb_config_local.win_height != user_cfg->win_height) {
 		WRITE_WIN_H(isp_h3a->regs.win1, user_cfg->win_height);
 		isp_h3a->aewb_config_local.win_height = user_cfg->win_height;
 		isp_h3a->update = 1;
 	}
 
-	if (unlikely(user_cfg->win_width < MIN_WIN_W ||
-		     user_cfg->win_width > MAX_WIN_W ||
-		     user_cfg->win_width & 0x01)) {
-		dev_err(isp_h3a->dev, "h3a: Invalid window width: %d\n",
-		       user_cfg->win_width);
-		return -EINVAL;
-	}
 	if (isp_h3a->aewb_config_local.win_width != user_cfg->win_width) {
 		WRITE_WIN_W(isp_h3a->regs.win1, user_cfg->win_width);
 		isp_h3a->aewb_config_local.win_width = user_cfg->win_width;
 		isp_h3a->update = 1;
 	}
 
-	if (unlikely(user_cfg->ver_win_count < 1 ||
-		     user_cfg->ver_win_count > MAX_WINVC)) {
-		dev_err(isp_h3a->dev,
-			"h3a: Invalid vertical window count: %d\n",
-			user_cfg->ver_win_count);
-		return -EINVAL;
-	}
 	if (isp_h3a->aewb_config_local.ver_win_count !=
 						user_cfg->ver_win_count) {
 		WRITE_VER_C(isp_h3a->regs.win1, user_cfg->ver_win_count);
@@ -403,13 +340,6 @@ static int isph3a_aewb_set_params(struct
 		isp_h3a->update = 1;
 	}
 
-	if (unlikely(user_cfg->hor_win_count < 1 ||
-		     user_cfg->hor_win_count > MAX_WINHC)) {
-		dev_err(isp_h3a->dev,
-			"h3a: Invalid horizontal window count: %d\n",
-			user_cfg->hor_win_count);
-		return -EINVAL;
-	}
 	if (isp_h3a->aewb_config_local.hor_win_count !=
 						user_cfg->hor_win_count) {
 		WRITE_HOR_C(isp_h3a->regs.win1, user_cfg->hor_win_count);
@@ -418,12 +348,6 @@ static int isph3a_aewb_set_params(struct
 		isp_h3a->update = 1;
 	}
 
-	if (unlikely(user_cfg->ver_win_start > MAX_WINSTART)) {
-		dev_err(isp_h3a->dev,
-			"h3a: Invalid vertical window start: %d\n",
-			user_cfg->ver_win_start);
-		return -EINVAL;
-	}
 	if (isp_h3a->aewb_config_local.ver_win_start !=
 						user_cfg->ver_win_start) {
 		WRITE_VER_WIN_ST(isp_h3a->regs.start, user_cfg->ver_win_start);
@@ -432,12 +356,6 @@ static int isph3a_aewb_set_params(struct
 		isp_h3a->update = 1;
 	}
 
-	if (unlikely(user_cfg->hor_win_start > MAX_WINSTART)) {
-		dev_err(isp_h3a->dev,
-			"h3a: Invalid horizontal window start: %d\n",
-			user_cfg->hor_win_start);
-		return -EINVAL;
-	}
 	if (isp_h3a->aewb_config_local.hor_win_start !=
 						user_cfg->hor_win_start) {
 		WRITE_HOR_WIN_ST(isp_h3a->regs.start, user_cfg->hor_win_start);
@@ -446,12 +364,6 @@ static int isph3a_aewb_set_params(struct
 		isp_h3a->update = 1;
 	}
 
-	if (unlikely(user_cfg->blk_ver_win_start > MAX_WINSTART)) {
-		dev_err(isp_h3a->dev,
-			"h3a: Invalid black vertical window start: %d\n",
-			user_cfg->blk_ver_win_start);
-		return -EINVAL;
-	}
 	if (isp_h3a->aewb_config_local.blk_ver_win_start !=
 	    user_cfg->blk_ver_win_start) {
 		WRITE_BLK_VER_WIN_ST(isp_h3a->regs.blk,
@@ -461,13 +373,6 @@ static int isph3a_aewb_set_params(struct
 		isp_h3a->update = 1;
 	}
 
-	if (unlikely(user_cfg->blk_win_height < MIN_WIN_H ||
-		     user_cfg->blk_win_height > MAX_WIN_H ||
-		     user_cfg->blk_win_height & 0x01)) {
-		dev_err(isp_h3a->dev, "h3a: Invalid black window height: %d\n",
-		       user_cfg->blk_win_height);
-		return -EINVAL;
-	}
 	if (isp_h3a->aewb_config_local.blk_win_height !=
 						user_cfg->blk_win_height) {
 		WRITE_BLK_WIN_H(isp_h3a->regs.blk, user_cfg->blk_win_height);
@@ -476,14 +381,6 @@ static int isph3a_aewb_set_params(struct
 		isp_h3a->update = 1;
 	}
 
-	if (unlikely(user_cfg->subsample_ver_inc < MIN_SUB_INC ||
-		     user_cfg->subsample_ver_inc > MAX_SUB_INC ||
-		     user_cfg->subsample_ver_inc & 0x01)) {
-		dev_err(isp_h3a->dev,
-			"h3a: Invalid vertical subsample increment: %d\n",
-			user_cfg->subsample_ver_inc);
-		return -EINVAL;
-	}
 	if (isp_h3a->aewb_config_local.subsample_ver_inc !=
 	    user_cfg->subsample_ver_inc) {
 		WRITE_SUB_VER_INC(isp_h3a->regs.subwin,
@@ -493,14 +390,6 @@ static int isph3a_aewb_set_params(struct
 		isp_h3a->update = 1;
 	}
 
-	if (unlikely(user_cfg->subsample_hor_inc < MIN_SUB_INC ||
-		     user_cfg->subsample_hor_inc > MAX_SUB_INC ||
-		     user_cfg->subsample_hor_inc & 0x01)) {
-		dev_err(isp_h3a->dev,
-			"h3a: Invalid horizontal subsample increment: %d\n",
-			user_cfg->subsample_hor_inc);
-		return -EINVAL;
-	}
 	if (isp_h3a->aewb_config_local.subsample_hor_inc !=
 	    user_cfg->subsample_hor_inc) {
 		WRITE_SUB_HOR_INC(isp_h3a->regs.subwin,
@@ -510,138 +399,60 @@ static int isph3a_aewb_set_params(struct
 		isp_h3a->update = 1;
 	}
 
-	if (!isp_h3a->initialized || !isp_h3a->aewb_config_local.aewb_enable) {
-		isph3a_aewb_update_regs(isp_h3a);
-		isp_h3a->initialized = 1;
-	}
-	return 0;
+	isp_h3a->aewb_config_local.aewb_enable = user_cfg->aewb_enable;;
 }
 
 /**
- * isph3a_aewb_configure - Configure AEWB regs, enable/disable H3A engine.
+ * omap34xx_isph3a_aewb_config - Configure AEWB regs, enable/disable H3A engine.
  * @aewbcfg: Pointer to AEWB config structure.
  *
  * Returns 0 if successful, -EINVAL if aewbcfg pointer is NULL, -ENOMEM if
  * was unable to allocate memory for the buffer, of other errors if H3A
  * callback is not set or the parameters for AEWB are invalid.
  **/
-int isph3a_aewb_configure(struct isp_h3a_device *isp_h3a,
-			  struct isph3a_aewb_config *aewbcfg)
+int omap34xx_isph3a_aewb_config(struct isp_h3a_device *isp_h3a,
+				struct isph3a_aewb_config *aewbcfg)
 {
+	struct device *dev = to_device(isp_h3a);
 	int ret = 0;
-	int i;
 	int win_count = 0;
+	unsigned int buf_size;
+	unsigned long irqflags;
 
 	if (NULL == aewbcfg) {
-		dev_err(isp_h3a->dev,
-			"h3a: Null argument in configuration. \n");
+		dev_dbg(dev, "h3a: Null argument in configuration\n");
 		return -EINVAL;
 	}
 
-	if (!isp_h3a->initialized) {
-		DPRINTK_ISPH3A("Setting callback for H3A\n");
-		ret = isp_set_callback(isp_h3a->dev, CBK_H3A_AWB_DONE,
-				       isph3a_aewb_isr, (void *)NULL,
-				       isp_h3a);
-		if (ret) {
-			dev_err(isp_h3a->dev, "h3a: No callback\n");
-			return ret;
-		}
-	}
-
-	ret = isph3a_aewb_set_params(isp_h3a, aewbcfg);
-	if (ret) {
-		dev_err(isp_h3a->dev, "h3a: Invalid parameters! \n");
+	ret = isph3a_aewb_validate_params(isp_h3a, aewbcfg);
+	if (ret)
 		return ret;
-	}
 
+	/* FIXME: This win_count handling looks really fishy. */
 	win_count = aewbcfg->ver_win_count * aewbcfg->hor_win_count;
 	win_count += aewbcfg->hor_win_count;
 	ret = win_count / 8;
 	win_count += win_count % 8 ? 1 : 0;
 	win_count += ret;
 
-	isp_h3a->win_count = win_count;
-	isp_h3a->curr_cfg_buf_size = win_count * AEWB_PACKET_SIZE;
+	buf_size = win_count * AEWB_PACKET_SIZE;
 
-	if (isp_h3a->stats_buf_size
-	    && win_count * AEWB_PACKET_SIZE > isp_h3a->stats_buf_size) {
-		DPRINTK_ISPH3A("There was a previous buffer... "
-			       "Freeing/unmapping current stat busffs\n");
-		isph3a_aewb_enable(isp_h3a, 0);
-		for (i = 0; i < H3A_MAX_BUFF; i++) {
-			ispmmu_kunmap(isp_h3a->buff[i].ispmmu_addr);
-			dma_free_coherent(
-				NULL,
-				isp_h3a->min_buf_size,
-				(void *)isp_h3a->buff[i].virt_addr,
-				(dma_addr_t)isp_h3a->buff[i].phy_addr);
-			isp_h3a->buff[i].virt_addr = 0;
-		}
-		isp_h3a->stats_buf_size = 0;
-	}
-
-	if (!isp_h3a->buff[0].virt_addr) {
-		isp_h3a->stats_buf_size = win_count * AEWB_PACKET_SIZE;
-		isp_h3a->min_buf_size = PAGE_ALIGN(isp_h3a->stats_buf_size);
-
-		DPRINTK_ISPH3A("Allocating/mapping new stat buffs\n");
-		for (i = 0; i < H3A_MAX_BUFF; i++) {
-			isp_h3a->buff[i].virt_addr =
-				(unsigned long)dma_alloc_coherent(
-					NULL,
-					isp_h3a->min_buf_size,
-					(dma_addr_t *)
-					&isp_h3a->buff[i].phy_addr,
-					GFP_KERNEL | GFP_DMA);
-			if (isp_h3a->buff[i].virt_addr == 0) {
-				dev_err(isp_h3a->dev,
-					"h3a: Can't acquire memory for "
-					"buffer[%d]\n", i);
-				return -ENOMEM;
-			}
-			isp_h3a->buff[i].addr_align =
-				isp_h3a->buff[i].virt_addr;
-			while ((isp_h3a->buff[i].addr_align & 0xFFFFFFC0) !=
-			       isp_h3a->buff[i].addr_align)
-				isp_h3a->buff[i].addr_align++;
-			isp_h3a->buff[i].ispmmu_addr =
-				ispmmu_kmap(isp_h3a->buff[i].phy_addr,
-					    isp_h3a->min_buf_size);
-		}
-		isph3a_aewb_unlock_buffers(isp_h3a);
-		isph3a_aewb_link_buffers(isp_h3a);
-
-		if (isp_h3a->active_buff == NULL)
-			isp_h3a->active_buff = &isp_h3a->buff[0];
-
-		isp_reg_writel(isp_h3a->dev, isp_h3a->active_buff->ispmmu_addr,
-			       OMAP3_ISP_IOMEM_H3A, ISPH3A_AEWBUFST);
-	}
-	for (i = 0; i < H3A_MAX_BUFF; i++) {
-		DPRINTK_ISPH3A("buff[%d] addr is:\n    virt    0x%lX\n"
-			       "    aligned 0x%lX\n"
-			       "    phys    0x%lX\n"
-			       "    ispmmu  0x%08lX\n"
-			       "    mmapped 0x%lX\n"
-			       "    frame_num %d\n", i,
-			       isp_h3a->buff[i].virt_addr,
-			       isp_h3a->buff[i].addr_align,
-			       isp_h3a->buff[i].phy_addr,
-			       isp_h3a->buff[i].ispmmu_addr,
-			       isp_h3a->buff[i].mmap_addr,
-			       isp_h3a->buff[i].frame_num);
-	}
+	ret = ispstat_bufs_alloc(&isp_h3a->stat, buf_size, 0);
+	if (ret)
+		return ret;
+
+	spin_lock_irqsave(isp_h3a->lock, irqflags);
+
+	isp_h3a->win_count = win_count;
+	isph3a_aewb_set_params(isp_h3a, aewbcfg);
 
-	isp_h3a->active_buff->frame_num = 1;
+	spin_unlock_irqrestore(isp_h3a->lock, irqflags);
 
-	atomic_inc(&isp_h3a->config_counter);
-	isph3a_aewb_enable(isp_h3a, aewbcfg->aewb_enable);
 	isph3a_print_status(isp_h3a);
 
 	return 0;
 }
-EXPORT_SYMBOL(isph3a_aewb_configure);
+EXPORT_SYMBOL(omap34xx_isph3a_aewb_config);
 
 /**
  * isph3a_aewb_request_statistics - REquest statistics and update gains in AEWB
@@ -654,23 +465,23 @@ EXPORT_SYMBOL(isph3a_aewb_configure);
  * Returns 0 if successful, -EINVAL when H3A engine is not enabled, or other
  * errors when setting gains.
  **/
-int isph3a_aewb_request_statistics(struct isp_h3a_device *isp_h3a,
-				   struct isph3a_aewb_data *aewbdata)
+int omap34xx_isph3a_aewb_request_statistics(struct isp_h3a_device *isp_h3a,
+					    struct isph3a_aewb_data *aewbdata)
 {
+	struct device *dev = to_device(isp_h3a);
+	unsigned long irqflags;
 	int ret = 0;
-	u16 frame_diff = 0;
-	u16 frame_cnt = isp_h3a->frame_count;
-	wait_queue_t wqt;
 
 	if (!isp_h3a->aewb_config_local.aewb_enable) {
-		dev_err(isp_h3a->dev, "h3a: engine not enabled\n");
+		dev_dbg(dev, "h3a: engine not enabled\n");
 		return -EINVAL;
 	}
 
 	DPRINTK_ISPH3A("isph3a_aewb_request_statistics: Enter "
 		       "(frame req. => %d, current frame => %d,"
 		       "update => %d)\n",
-		       aewbdata->frame_number, frame_cnt, aewbdata->update);
+		       aewbdata->frame_number, isp_h3a->stat.frame_number,
+		       aewbdata->update);
 	DPRINTK_ISPH3A("User data received: \n");
 	DPRINTK_ISPH3A("Digital gain = 0x%04x\n", aewbdata->dgain);
 	DPRINTK_ISPH3A("WB gain b *=   0x%04x\n", aewbdata->wb_gain_b);
@@ -678,10 +489,8 @@ int isph3a_aewb_request_statistics(struc
 	DPRINTK_ISPH3A("WB gain gb =   0x%04x\n", aewbdata->wb_gain_gb);
 	DPRINTK_ISPH3A("WB gain gr =   0x%04x\n", aewbdata->wb_gain_gr);
 
-	if (!aewbdata->update) {
-		aewbdata->h3a_aewb_statistics_buf = NULL;
-		goto out;
-	}
+	spin_lock_irqsave(isp_h3a->lock, irqflags);
+
 	if (aewbdata->update & SET_DIGITAL_GAIN)
 		isp_h3a->h3awb_update.dgain = (u16)aewbdata->dgain;
 	if (aewbdata->update & SET_COLOR_GAINS) {
@@ -693,81 +502,20 @@ int isph3a_aewb_request_statistics(struc
 	if (aewbdata->update & (SET_COLOR_GAINS | SET_DIGITAL_GAIN))
 		isp_h3a->wb_update = 1;
 
-	if (!(aewbdata->update & REQUEST_STATISTICS)) {
-		aewbdata->h3a_aewb_statistics_buf = NULL;
-		goto out;
-	}
-
-	if (aewbdata->frame_number < 1) {
-		dev_err(isp_h3a->dev, "h3a: Illeagal frame number "
-		       "requested (%d)\n",
-		       aewbdata->frame_number);
-		return -EINVAL;
-	}
+	spin_unlock_irqrestore(isp_h3a->lock, irqflags);
 
-	isph3a_aewb_unlock_buffers(isp_h3a);
-
-	DPRINTK_ISPH3A("Stats available?\n");
-	ret = isph3a_aewb_stats_available(isp_h3a, aewbdata);
-	if (!ret)
-		goto out;
-
-	DPRINTK_ISPH3A("Stats in near future?\n");
-	if (aewbdata->frame_number > frame_cnt)
-		frame_diff = aewbdata->frame_number - frame_cnt;
-	else if (aewbdata->frame_number < frame_cnt) {
-		if ((frame_cnt > (MAX_FRAME_COUNT - MAX_FUTURE_FRAMES)) &&
-		    (aewbdata->frame_number < MAX_FRAME_COUNT)) {
-			frame_diff = aewbdata->frame_number + MAX_FRAME_COUNT -
-				frame_cnt;
-		} else
-			frame_diff = MAX_FUTURE_FRAMES + 1;
-	}
-
-	if (frame_diff > MAX_FUTURE_FRAMES) {
-		dev_err(isp_h3a->dev,
-			"h3a: Invalid frame requested, returning current"
-			" frame stats\n");
-		aewbdata->frame_number = frame_cnt;
-	}
-	if (isp_h3a->camnotify) {
-		DPRINTK_ISPH3A("NOT Waiting on stats IRQ for frame %d "
-			       "because camnotify set\n",
-			       aewbdata->frame_number);
-		aewbdata->h3a_aewb_statistics_buf = NULL;
-		goto out;
-	}
-	DPRINTK_ISPH3A("Waiting on stats IRQ for frame %d\n",
-		       aewbdata->frame_number);
-	isp_h3a->frame_req = aewbdata->frame_number;
-	isp_h3a->stats_req = 1;
-	isp_h3a->stats_done = 0;
-	init_waitqueue_entry(&wqt, current);
-	ret = wait_event_interruptible(isp_h3a->stats_wait,
-				       isp_h3a->stats_done == 1);
-	if (ret < 0) {
-		dev_err(isp_h3a->dev, "h3a: isph3a_aewb_request_statistics"
-		       " Error on wait event %d\n", ret);
-		aewbdata->h3a_aewb_statistics_buf = NULL;
-		return ret;
-	}
+	if (aewbdata->update & REQUEST_STATISTICS)
+		ret = isph3a_aewb_get_stats(isp_h3a, aewbdata);
+
+	aewbdata->curr_frame = isp_h3a->stat.frame_number;
 
-	DPRINTK_ISPH3A("ISP AEWB request status interrupt raised\n");
-	ret = isph3a_aewb_stats_available(isp_h3a, aewbdata);
-	if (ret) {
-		DPRINTK_ISPH3A("After waiting for stats,"
-			       " stats not available!!\n");
-		aewbdata->h3a_aewb_statistics_buf = NULL;
-	}
-out:
 	DPRINTK_ISPH3A("isph3a_aewb_request_statistics: "
 		       "aewbdata->h3a_aewb_statistics_buf => %p\n",
 		       aewbdata->h3a_aewb_statistics_buf);
-	aewbdata->curr_frame = isp_h3a->frame_count;
 
-	return 0;
+	return ret;
 }
-EXPORT_SYMBOL(isph3a_aewb_request_statistics);
+EXPORT_SYMBOL(omap34xx_isph3a_aewb_request_statistics);
 
 /**
  * isph3a_aewb_init - Module Initialisation.
@@ -779,11 +527,9 @@ int __init isph3a_aewb_init(struct devic
 	struct isp_device *isp = dev_get_drvdata(dev);
 	struct isp_h3a_device *isp_h3a = &isp->isp_h3a;
 
-	isp_h3a->dev = dev;
-	init_waitqueue_head(&isp_h3a->stats_wait);
-	spin_lock_init(&isp_h3a->buffer_lock);
-
+	isp_h3a->lock = &isp->h3a_lock;
 	isp_h3a->aewb_config_local.saturation_limit = AEWB_SATURATION_LIMIT;
+	ispstat_init(dev, "H3A", &isp_h3a->stat, H3A_MAX_BUFF, MAX_FRAME_COUNT);
 
 	return 0;
 }
@@ -794,19 +540,8 @@ int __init isph3a_aewb_init(struct devic
 void isph3a_aewb_cleanup(struct device *dev)
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
-	struct isp_h3a_device *isp_h3a = &isp->isp_h3a;
-	int i;
 
-	for (i = 0; i < H3A_MAX_BUFF; i++) {
-		if (!isp_h3a->buff[i].phy_addr)
-			continue;
-
-		ispmmu_kunmap(isp_h3a->buff[i].ispmmu_addr);
-		dma_free_coherent(NULL,
-				  isp_h3a->min_buf_size,
-				  (void *)isp_h3a->buff[i].virt_addr,
-				  (dma_addr_t)isp_h3a->buff[i].phy_addr);
-	}
+	ispstat_free(&isp->isp_h3a.stat);
 }
 
 /**
@@ -815,48 +550,32 @@ void isph3a_aewb_cleanup(struct device *
 static void isph3a_print_status(struct isp_h3a_device *isp_h3a)
 {
 	DPRINTK_ISPH3A("ISPH3A_PCR = 0x%08x\n",
-		       isp_reg_readl(isp_h3a->dev, OMAP3_ISP_IOMEM_H3A,
+		       isp_reg_readl(to_device(isp_h3a),
+				     OMAP3_ISP_IOMEM_H3A,
 				     ISPH3A_PCR));
 	DPRINTK_ISPH3A("ISPH3A_AEWWIN1 = 0x%08x\n",
-		       isp_reg_readl(isp_h3a->dev, OMAP3_ISP_IOMEM_H3A,
+		       isp_reg_readl(to_device(isp_h3a),
+				     OMAP3_ISP_IOMEM_H3A,
 				     ISPH3A_AEWWIN1));
 	DPRINTK_ISPH3A("ISPH3A_AEWINSTART = 0x%08x\n",
-		       isp_reg_readl(isp_h3a->dev, OMAP3_ISP_IOMEM_H3A,
+		       isp_reg_readl(to_device(isp_h3a),
+				     OMAP3_ISP_IOMEM_H3A,
 				     ISPH3A_AEWINSTART));
 	DPRINTK_ISPH3A("ISPH3A_AEWINBLK = 0x%08x\n",
-		       isp_reg_readl(isp_h3a->dev, OMAP3_ISP_IOMEM_H3A,
+		       isp_reg_readl(to_device(isp_h3a),
+				     OMAP3_ISP_IOMEM_H3A,
 				     ISPH3A_AEWINBLK));
 	DPRINTK_ISPH3A("ISPH3A_AEWSUBWIN = 0x%08x\n",
-		       isp_reg_readl(isp_h3a->dev, OMAP3_ISP_IOMEM_H3A,
+		       isp_reg_readl(to_device(isp_h3a),
+				     OMAP3_ISP_IOMEM_H3A,
 				     ISPH3A_AEWSUBWIN));
 	DPRINTK_ISPH3A("ISPH3A_AEWBUFST = 0x%08x\n",
-		       isp_reg_readl(isp_h3a->dev, OMAP3_ISP_IOMEM_H3A,
+		       isp_reg_readl(to_device(isp_h3a),
+				     OMAP3_ISP_IOMEM_H3A,
 				     ISPH3A_AEWBUFST));
 	DPRINTK_ISPH3A("stats windows = %d\n", isp_h3a->win_count);
-	DPRINTK_ISPH3A("stats buff size = %d\n", isp_h3a->stats_buf_size);
-	DPRINTK_ISPH3A("currently configured stats buff size = %d\n",
-		       isp_h3a->curr_cfg_buf_size);
-}
-
-/**
- * isph3a_notify - Unblocks user request for statistics when camera is off
- * @notify: 1 - Camera is turned off
- *
- * Used when the user has requested statistics about a future frame, but the
- * camera is turned off before it happens, and this function unblocks the
- * request so the user can continue in its program.
- **/
-void isph3a_notify(struct isp_h3a_device *isp_h3a, int notify)
-{
-	isp_h3a->camnotify = notify;
-	if (isp_h3a->camnotify && isp_h3a->initialized) {
-		dev_dbg(isp_h3a->dev, "h3a: Warning Camera Off \n");
-		isp_h3a->stats_req = 0;
-		isp_h3a->stats_done = 1;
-		wake_up_interruptible(&isp_h3a->stats_wait);
-	}
+	DPRINTK_ISPH3A("stats buf size = %d\n", isp_h3a->stat.buf_size);
 }
-EXPORT_SYMBOL(isph3a_notify);
 
 /**
  * isph3a_save_context - Saves the values of the h3a module registers.
@@ -866,7 +585,7 @@ void isph3a_save_context(struct device *
 	DPRINTK_ISPH3A(" Saving context\n");
 	isp_save_context(dev, isph3a_reg_list);
 	/* Avoid enable during restore ctx */
-	isph3a_reg_list[0].val &= ~ISPH3A_PCR_AEW_EN;
+	isph3a_reg_list[0].val &= ~(ISPH3A_PCR_AEW_EN | ISPH3A_PCR_AF_EN);
 }
 EXPORT_SYMBOL(isph3a_save_context);
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isph3a.h kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isph3a.h
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isph3a.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isph3a.h	2012-12-16 13:13:01.664330147 +0100
@@ -44,6 +44,8 @@
 #define ISPH3A_PCR_AEW_EN	(1 << 16)
 #define ISPH3A_PCR_AEW_ALAW_EN	(1 << 17)
 #define ISPH3A_PCR_AEW_BUSY	(1 << 18)
+#define ISPH3A_PCR_AEW_MASK 	(ISPH3A_PCR_AEW_ALAW_EN | \
+				 ISPH3A_PCR_AEW_AVE2LMT_MASK)
 
 #define WRITE_SAT_LIM(reg, sat_limit)			\
 	(reg = (reg & (~(ISPH3A_PCR_AEW_AVE2LMT_MASK))) \
@@ -95,41 +97,6 @@
 	 | (((sub_hor_inc >> 1) - 1) << ISPH3A_AEWSUBWIN_AEWINCH_SHIFT))
 
 /**
- * struct isph3a_aewb_xtrastats - Structure with extra statistics sent by cam.
- * @field_count: Sequence number of returned framestats.
- * @isph3a_aewb_xtrastats: Pointer to next buffer with extra stats.
- */
-struct isph3a_aewb_xtrastats {
-	unsigned long field_count;
-	struct isph3a_aewb_xtrastats *next;
-};
-
-/**
- * struct isph3a_aewb_buffer - AE, AWB frame stats buffer.
- * @virt_addr: Virtual address to mmap the buffer.
- * @phy_addr: Physical address of the buffer.
- * @addr_align: Virtual Address 32 bytes aligned.
- * @ispmmu_addr: Address of the buffer mapped by the ISPMMU.
- * @mmap_addr: Mapped memory area of buffer. For userspace access.
- * @locked: 1 - Buffer locked from write. 0 - Buffer can be overwritten.
- * @frame_num: Frame number from which the statistics are taken.
- * @next: Pointer to link next buffer.
- */
-struct isph3a_aewb_buffer {
-	unsigned long virt_addr;
-	unsigned long phy_addr;
-	unsigned long addr_align;
-	unsigned long ispmmu_addr;
-	unsigned long mmap_addr;	/* For userspace */
-	struct timeval ts;
-	u32 config_counter;
-
-	u8 locked;
-	u16 frame_num;
-	struct isph3a_aewb_buffer *next;
-};
-
-/**
  * struct isph3a_aewb_regs - Current value of AE, AWB configuration registers.
  * pcr: Peripheral control register.
  * win1: Control register.
@@ -145,58 +112,28 @@ struct isph3a_aewb_regs {
 	u32 subwin;
 };
 
-/**
- * struct isp_h3a_device - AE, AWB status.
- * @initialized: 1 - Buffers initialized.
- * @update: 1 - Update registers.
- * @stats_req: 1 - Future stats requested.
- * @stats_done: 1 - Stats ready for user.
- * @frame_req: Number of frame requested for statistics.
- * @h3a_buff: Array of statistics buffers to access.
- * @stats_buf_size: Statistics buffer size.
- * @min_buf_size: Minimum statisitics buffer size.
- * @win_count: Window Count.
- * @frame_count: Frame Count.
- * @stats_wait: Wait primitive for locking/unlocking the stats request.
- * @buffer_lock: Spinlock for statistics buffers access.
- */
 struct isp_h3a_device {
-	u8 initialized;
+	spinlock_t *lock;		/* Lock for this struct */
+
 	u8 update;
-	u8 stats_req;
-	u8 stats_done;
-	u16 frame_req;
-	int pm_state;
-	int camnotify;
+	u8 buf_err;
+	int enabled;
 	int wb_update;
 
-	struct isph3a_aewb_buffer buff[H3A_MAX_BUFF];
-	unsigned int stats_buf_size;
-	unsigned int min_buf_size;
-	unsigned int curr_cfg_buf_size;
-	struct isph3a_aewb_buffer *active_buff;
-
-	atomic_t config_counter;
 	struct isph3a_aewb_regs regs;
 	struct ispprev_wbal h3awb_update;
-	struct isph3a_aewb_xtrastats xtrastats[H3A_MAX_BUFF];
 	struct isph3a_aewb_config aewb_config_local;
+	struct ispstat_buffer *buf_next;
 	u16 win_count;
-	u32 frame_count;
-	wait_queue_head_t stats_wait;
-	spinlock_t buffer_lock;		/* For stats buffers read/write sync */
 
-	struct device *dev;
+	struct ispstat stat;
 };
 
-void isph3a_aewb_setxtrastats(struct isp_h3a_device *isp_h3a,
-			      struct isph3a_aewb_xtrastats *xtrastats);
+int omap34xx_isph3a_aewb_config(struct isp_h3a_device *isp_h3a,
+				struct isph3a_aewb_config *aewbcfg);
 
-int isph3a_aewb_configure(struct isp_h3a_device *isp_h3a,
-			  struct isph3a_aewb_config *aewbcfg);
-
-int isph3a_aewb_request_statistics(struct isp_h3a_device *isp_h3a,
-				   struct isph3a_aewb_data *aewbdata);
+int omap34xx_isph3a_aewb_request_statistics(struct isp_h3a_device *isp_h3a,
+					    struct isph3a_aewb_data *aewbdata);
 
 void isph3a_save_context(struct device *dev);
 
@@ -204,6 +141,8 @@ void isph3a_restore_context(struct devic
 
 void isph3a_aewb_enable(struct isp_h3a_device *isp_h3a, u8 enable);
 
+void isph3a_aewb_try_enable(struct isp_h3a_device *isp_h3a);
+
 int isph3a_aewb_busy(struct isp_h3a_device *isp_h3a);
 
 void isph3a_aewb_suspend(struct isp_h3a_device *isp_h3a);
@@ -212,5 +151,8 @@ void isph3a_aewb_resume(struct isp_h3a_d
 
 void isph3a_update_wb(struct isp_h3a_device *isp_h3a);
 
-void isph3a_notify(struct isp_h3a_device *isp_h3a, int notify);
+int isph3a_aewb_buf_process(struct isp_h3a_device *isp_h3a);
+
+void isph3a_aewb_config_registers(struct isp_h3a_device *isp_h3a);
+
 #endif		/* OMAP_ISP_H3A_H */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispmmu.c kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispmmu.c
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispmmu.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispmmu.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,141 +0,0 @@
-/*
- * omap iommu wrapper for TI's OMAP3430 Camera ISP
- *
- * Copyright (C) 2008--2009 Nokia.
- *
- * Contributors:
- *	Hiroshi Doyu <hiroshi.doyu@nokia.com>
- *	Sakari Ailus <sakari.ailus@nokia.com>
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#include <linux/module.h>
-
-#include "ispmmu.h"
-#include "isp.h"
-
-#include <mach/iommu.h>
-#include <mach/iovmm.h>
-
-#define IOMMU_FLAG (IOVMF_ENDIAN_LITTLE | IOVMF_ELSZ_8)
-
-static struct iommu *isp_iommu;
-
-dma_addr_t ispmmu_vmalloc(size_t bytes)
-{
-	return (dma_addr_t)iommu_vmalloc(isp_iommu, 0, bytes, IOMMU_FLAG);
-}
-
-void ispmmu_vfree(const dma_addr_t da)
-{
-	iommu_vfree(isp_iommu, (u32)da);
-}
-
-dma_addr_t ispmmu_kmap(u32 pa, int size)
-{
-	void *da;
-
-	da = (void *)iommu_kmap(isp_iommu, 0, pa, size, IOMMU_FLAG);
-	if (IS_ERR(da))
-		return PTR_ERR(da);
-
-	return (dma_addr_t)da;
-}
-
-void ispmmu_kunmap(dma_addr_t da)
-{
-	iommu_kunmap(isp_iommu, (u32)da);
-}
-
-dma_addr_t ispmmu_vmap(const struct scatterlist *sglist,
-		       int sglen)
-{
-	int err;
-	void *da;
-	struct sg_table *sgt;
-	unsigned int i;
-	struct scatterlist *sg, *src = (struct scatterlist *)sglist;
-
-	/*
-	 * convert isp sglist to iommu sgt
-	 * FIXME: should be fixed in the upper layer?
-	 */
-	sgt = kmalloc(sizeof(*sgt), GFP_KERNEL);
-	if (!sgt)
-		return -ENOMEM;
-	err = sg_alloc_table(sgt, sglen, GFP_KERNEL);
-	if (err)
-		goto err_sg_alloc;
-
-	for_each_sg(sgt->sgl, sg, sgt->nents, i)
-		sg_set_buf(sg, phys_to_virt(sg_dma_address(src + i)),
-			   sg_dma_len(src + i));
-
-	da = (void *)iommu_vmap(isp_iommu, 0, sgt, IOMMU_FLAG);
-	if (IS_ERR(da))
-		goto err_vmap;
-
-	return (dma_addr_t)da;
-
-err_vmap:
-	sg_free_table(sgt);
-err_sg_alloc:
-	kfree(sgt);
-	return -ENOMEM;
-}
-EXPORT_SYMBOL_GPL(ispmmu_vmap);
-
-void ispmmu_vunmap(dma_addr_t da)
-{
-	struct sg_table *sgt;
-
-	sgt = iommu_vunmap(isp_iommu, (u32)da);
-	if (!sgt)
-		return;
-	sg_free_table(sgt);
-	kfree(sgt);
-}
-EXPORT_SYMBOL_GPL(ispmmu_vunmap);
-
-void ispmmu_save_context(void)
-{
-	if (isp_iommu)
-		iommu_save_ctx(isp_iommu);
-}
-
-void ispmmu_restore_context(void)
-{
-	if (isp_iommu)
-		iommu_restore_ctx(isp_iommu);
-}
-
-int __init ispmmu_init(void)
-{
-	int err = 0;
-
-	isp_get();
-	isp_iommu = iommu_get("isp");
-	if (IS_ERR(isp_iommu)) {
-		err = PTR_ERR(isp_iommu);
-		isp_iommu = NULL;
-	}
-	isp_put();
-
-	return err;
-}
-
-void ispmmu_cleanup(void)
-{
-	isp_get();
-	if (isp_iommu)
-		iommu_put(isp_iommu);
-	isp_put();
-	isp_iommu = NULL;
-}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispmmu.h kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispmmu.h
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispmmu.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispmmu.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,36 +0,0 @@
-/*
- * omap iommu wrapper for TI's OMAP3430 Camera ISP
- *
- * Copyright (C) 2008--2009 Nokia.
- *
- * Contributors:
- *	Hiroshi Doyu <hiroshi.doyu@nokia.com>
- *	Sakari Ailus <sakari.ailus@nokia.com>
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#ifndef OMAP_ISP_MMU_H
-#define OMAP_ISP_MMU_H
-
-#include <linux/err.h>
-#include <linux/scatterlist.h>
-
-dma_addr_t ispmmu_vmalloc(size_t bytes);
-void ispmmu_vfree(const dma_addr_t da);
-dma_addr_t ispmmu_kmap(u32 pa, int size);
-void ispmmu_kunmap(dma_addr_t da);
-dma_addr_t ispmmu_vmap(const struct scatterlist *sglist, int sglen);
-void ispmmu_vunmap(dma_addr_t da);
-void ispmmu_save_context(void);
-void ispmmu_restore_context(void);
-int ispmmu_init(void);
-void ispmmu_cleanup(void);
-
-#endif /* OMAP_ISP_MMU_H */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isppreview.c kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isppreview.c
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isppreview.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isppreview.c	2012-12-16 13:13:01.664330147 +0100
@@ -30,6 +30,7 @@
 
 /* Structure for saving/restoring preview module registers */
 static struct isp_reg ispprev_reg_list[] = {
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR, 0x0000}, /* See context saving. */
 	{OMAP3_ISP_IOMEM_PREV, ISPPRV_HORZ_INFO, 0x0000},
 	{OMAP3_ISP_IOMEM_PREV, ISPPRV_VERT_INFO, 0x0000},
 	{OMAP3_ISP_IOMEM_PREV, ISPPRV_RSDR_ADDR, 0x0000},
@@ -64,7 +65,6 @@ static struct isp_reg ispprev_reg_list[]
 	{OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR1, 0x0000},
 	{OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR2, 0x0000},
 	{OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR3, 0x0000},
-	{OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR, 0x0000},
 	{0, ISP_TOK_TERM, 0x0000}
 };
 
@@ -184,6 +184,10 @@ static u32 luma_enhance_table[] = {
 #include "luma_enhance_table.h"
 };
 
+static int omap34xx_isp_tables_update(struct isp_prev_device *isp_prev,
+				struct isptables_update *isptables_struct);
+
+
 /**
  * omap34xx_isp_preview_config - Abstraction layer Preview configuration.
  * @userspace_add: Pointer from Userspace to structure with flags and data to
@@ -192,173 +196,173 @@ static u32 luma_enhance_table[] = {
 int omap34xx_isp_preview_config(struct isp_prev_device *isp_prev,
 				void *userspace_add)
 {
+	struct isp_device *isp = to_isp_device(isp_prev);
+	struct device *dev = to_device(isp_prev);
 	struct ispprev_hmed prev_hmed_t;
-	struct ispprev_cfa prev_cfa_t;
 	struct ispprev_csup csup_t;
-	struct ispprev_wbal prev_wbal_t;
 	struct ispprev_blkadj prev_blkadj_t;
-	struct ispprev_csc prev_csc_t;
 	struct ispprev_yclimit yclimit_t;
 	struct ispprev_dcor prev_dcor_t;
-	struct ispprv_update_config *preview_struct;
+	struct ispprv_update_config *config;
 	struct isptables_update isp_table_update;
 	int yen_t[ISPPRV_YENH_TBL_SIZE];
+	unsigned long flags;
 
 	if (userspace_add == NULL)
 		return -EINVAL;
 
-	preview_struct = userspace_add;
-
-	if (ISP_ABS_PREV_LUMAENH & preview_struct->flag) {
-		if (ISP_ABS_PREV_LUMAENH & preview_struct->update) {
-			if (copy_from_user(yen_t, preview_struct->yen,
+	spin_lock_irqsave(&isp_prev->lock, flags);
+	isp_prev->shadow_update = 1;
+	spin_unlock_irqrestore(&isp_prev->lock, flags);
+
+	config = userspace_add;
+
+	if (isp->running != ISP_STOPPED)
+		goto out_config_shadow;
+
+	if (ISP_ABS_PREV_LUMAENH & config->flag) {
+		if (ISP_ABS_PREV_LUMAENH & config->update) {
+			if (copy_from_user(yen_t, config->yen,
 					   sizeof(yen_t)))
 				goto err_copy_from_user;
 			isppreview_config_luma_enhancement(isp_prev, yen_t);
 		}
-		isp_prev->params->features |= PREV_LUMA_ENHANCE;
-	} else if (ISP_ABS_PREV_LUMAENH & preview_struct->update)
-		isp_prev->params->features &= ~PREV_LUMA_ENHANCE;
+		isp_prev->params.features |= PREV_LUMA_ENHANCE;
+	} else if (ISP_ABS_PREV_LUMAENH & config->update)
+		isp_prev->params.features &= ~PREV_LUMA_ENHANCE;
 
-	if (ISP_ABS_PREV_INVALAW & preview_struct->flag) {
+	if (ISP_ABS_PREV_INVALAW & config->flag) {
 		isppreview_enable_invalaw(isp_prev, 1);
-		isp_prev->params->features |= PREV_INVERSE_ALAW;
+		isp_prev->params.features |= PREV_INVERSE_ALAW;
 	} else {
 		isppreview_enable_invalaw(isp_prev, 0);
-		isp_prev->params->features &= ~PREV_INVERSE_ALAW;
+		isp_prev->params.features &= ~PREV_INVERSE_ALAW;
 	}
 
-	if (ISP_ABS_PREV_HRZ_MED & preview_struct->flag) {
-		if (ISP_ABS_PREV_HRZ_MED & preview_struct->update) {
+	if (ISP_ABS_PREV_HRZ_MED & config->flag) {
+		if (ISP_ABS_PREV_HRZ_MED & config->update) {
 			if (copy_from_user(&prev_hmed_t,
 					   (struct ispprev_hmed *)
-					   preview_struct->prev_hmed,
+					   config->prev_hmed,
 					   sizeof(struct ispprev_hmed)))
 				goto err_copy_from_user;
 			isppreview_config_hmed(isp_prev, prev_hmed_t);
 		}
 		isppreview_enable_hmed(isp_prev, 1);
-		isp_prev->params->features |= PREV_HORZ_MEDIAN_FILTER;
-	} else if (ISP_ABS_PREV_HRZ_MED & preview_struct->update) {
+		isp_prev->params.features |= PREV_HORZ_MEDIAN_FILTER;
+	} else if (ISP_ABS_PREV_HRZ_MED & config->update) {
 		isppreview_enable_hmed(isp_prev, 0);
-		isp_prev->params->features &= ~PREV_HORZ_MEDIAN_FILTER;
-	}
-
-	if (ISP_ABS_PREV_CFA & preview_struct->flag) {
-		if (ISP_ABS_PREV_CFA & preview_struct->update) {
-			if (copy_from_user(&prev_cfa_t,
-					   (struct ispprev_cfa *)
-					   preview_struct->prev_cfa,
-					   sizeof(struct ispprev_cfa)))
-				goto err_copy_from_user;
-
-			isppreview_config_cfa(isp_prev, prev_cfa_t);
-		}
-		isppreview_enable_cfa(isp_prev, 1);
-		isp_prev->params->features |= PREV_CFA;
-	} else if (ISP_ABS_PREV_CFA & preview_struct->update) {
-		isppreview_enable_cfa(isp_prev, 0);
-		isp_prev->params->features &= ~PREV_CFA;
+		isp_prev->params.features &= ~PREV_HORZ_MEDIAN_FILTER;
 	}
 
-	if (ISP_ABS_PREV_CHROMA_SUPP & preview_struct->flag) {
-		if (ISP_ABS_PREV_CHROMA_SUPP & preview_struct->update) {
+	if (ISP_ABS_PREV_CHROMA_SUPP & config->flag) {
+		if (ISP_ABS_PREV_CHROMA_SUPP & config->update) {
 			if (copy_from_user(&csup_t,
 					   (struct ispprev_csup *)
-					   preview_struct->csup,
+					   config->csup,
 					   sizeof(struct ispprev_csup)))
 				goto err_copy_from_user;
 			isppreview_config_chroma_suppression(isp_prev, csup_t);
 		}
 		isppreview_enable_chroma_suppression(isp_prev, 1);
-		isp_prev->params->features |= PREV_CHROMA_SUPPRESS;
-	} else if (ISP_ABS_PREV_CHROMA_SUPP & preview_struct->update) {
+		isp_prev->params.features |= PREV_CHROMA_SUPPRESS;
+	} else if (ISP_ABS_PREV_CHROMA_SUPP & config->update) {
 		isppreview_enable_chroma_suppression(isp_prev, 0);
-		isp_prev->params->features &= ~PREV_CHROMA_SUPPRESS;
+		isp_prev->params.features &= ~PREV_CHROMA_SUPPRESS;
 	}
 
-	if (ISP_ABS_PREV_WB & preview_struct->update) {
-		if (copy_from_user(&prev_wbal_t, (struct ispprev_wbal *)
-				   preview_struct->prev_wbal,
-				   sizeof(struct ispprev_wbal)))
-			goto err_copy_from_user;
-		isppreview_config_whitebalance(isp_prev, prev_wbal_t);
-	}
-
-	if (ISP_ABS_PREV_BLKADJ & preview_struct->update) {
+	if (ISP_ABS_PREV_BLKADJ & config->update) {
 		if (copy_from_user(&prev_blkadj_t, (struct ispprev_blkadjl *)
-				   preview_struct->prev_blkadj,
+				   config->prev_blkadj,
 				   sizeof(struct ispprev_blkadj)))
 			goto err_copy_from_user;
 		isppreview_config_blkadj(isp_prev, prev_blkadj_t);
 	}
 
-	if (ISP_ABS_PREV_RGB2RGB & preview_struct->update) {
-		if (copy_from_user(&isp_prev->params->rgb2rgb,
-				   (struct ispprev_rgbtorgb *)
-				   preview_struct->rgb2rgb,
-				   sizeof(struct ispprev_rgbtorgb)))
-			goto err_copy_from_user;
-		isppreview_config_rgb_blending(isp_prev,
-					       isp_prev->params->rgb2rgb);
-		wmb();
-		isp_prev->update_rgb_blending = 1;
-	}
-
-	if (ISP_ABS_PREV_COLOR_CONV & preview_struct->update) {
-		if (copy_from_user(&prev_csc_t, (struct ispprev_csc *)
-				   preview_struct->prev_csc,
-				   sizeof(struct ispprev_csc)))
-			goto err_copy_from_user;
-		isppreview_config_rgb_to_ycbcr(isp_prev, prev_csc_t);
-	}
-
-	if (ISP_ABS_PREV_YC_LIMIT & preview_struct->update) {
+	if (ISP_ABS_PREV_YC_LIMIT & config->update) {
 		if (copy_from_user(&yclimit_t, (struct ispprev_yclimit *)
-				   preview_struct->yclimit,
+				   config->yclimit,
 				   sizeof(struct ispprev_yclimit)))
 			goto err_copy_from_user;
 		isppreview_config_yc_range(isp_prev, yclimit_t);
 	}
 
-	if (ISP_ABS_PREV_DEFECT_COR & preview_struct->flag) {
-		if (ISP_ABS_PREV_DEFECT_COR & preview_struct->update) {
+	if (ISP_ABS_PREV_DEFECT_COR & config->flag) {
+		if (ISP_ABS_PREV_DEFECT_COR & config->update) {
 			if (copy_from_user(&prev_dcor_t,
 					   (struct ispprev_dcor *)
-					   preview_struct->prev_dcor,
+					   config->prev_dcor,
 					   sizeof(struct ispprev_dcor)))
 				goto err_copy_from_user;
 			isppreview_config_dcor(isp_prev, prev_dcor_t);
 		}
 		isppreview_enable_dcor(isp_prev, 1);
-		isp_prev->params->features |= PREV_DEFECT_COR;
-	} else if (ISP_ABS_PREV_DEFECT_COR & preview_struct->update) {
+		isp_prev->params.features |= PREV_DEFECT_COR;
+	} else if (ISP_ABS_PREV_DEFECT_COR & config->update) {
 		isppreview_enable_dcor(isp_prev, 0);
-		isp_prev->params->features &= ~PREV_DEFECT_COR;
+		isp_prev->params.features &= ~PREV_DEFECT_COR;
 	}
 
-	if (ISP_ABS_PREV_GAMMABYPASS & preview_struct->flag) {
+	if (ISP_ABS_PREV_GAMMABYPASS & config->flag) {
 		isppreview_enable_gammabypass(isp_prev, 1);
-		isp_prev->params->features |= PREV_GAMMA_BYPASS;
+		isp_prev->params.features |= PREV_GAMMA_BYPASS;
 	} else {
 		isppreview_enable_gammabypass(isp_prev, 0);
-		isp_prev->params->features &= ~PREV_GAMMA_BYPASS;
+		isp_prev->params.features &= ~PREV_GAMMA_BYPASS;
+	}
+
+out_config_shadow:
+	if (ISP_ABS_PREV_RGB2RGB & config->update) {
+		if (copy_from_user(&isp_prev->params.rgb2rgb,
+				   (struct ispprev_rgbtorgb *)
+				   config->rgb2rgb,
+				   sizeof(struct ispprev_rgbtorgb)))
+			goto err_copy_from_user;
+		isppreview_config_rgb_blending(isp_prev,
+					       isp_prev->params.rgb2rgb);
+		/* The function call above prevents compiler from reordering
+		 * writes so that the flag below is always set after
+		 * isp_prev->params.rgb2rgb is written to. */
+		isp_prev->update_rgb_blending = 1;
 	}
 
-	isp_table_update.update = preview_struct->update;
-	isp_table_update.flag = preview_struct->flag;
-	isp_table_update.prev_nf = preview_struct->prev_nf;
-	isp_table_update.red_gamma = preview_struct->red_gamma;
-	isp_table_update.green_gamma = preview_struct->green_gamma;
-	isp_table_update.blue_gamma = preview_struct->blue_gamma;
+	if (ISP_ABS_PREV_COLOR_CONV & config->update) {
+		if (copy_from_user(&isp_prev->params.rgb2ycbcr,
+				   (struct ispprev_csc *)
+					config->prev_csc,
+				   sizeof(struct ispprev_csc)))
+			goto err_copy_from_user;
+		isppreview_config_rgb_to_ycbcr(isp_prev,
+					       isp_prev->params.rgb2ycbcr);
+		/* Same here... this flag has to be set after rgb2ycbcr
+		 * structure is written to. */
+		isp_prev->update_rgb_to_ycbcr = 1;
+	}
+
+	isp_table_update.update = config->update;
+	isp_table_update.flag = config->flag;
+	isp_table_update.prev_nf = config->prev_nf;
+	isp_table_update.red_gamma = config->red_gamma;
+	isp_table_update.green_gamma = config->green_gamma;
+	isp_table_update.blue_gamma = config->blue_gamma;
+	isp_table_update.prev_cfa = config->prev_cfa;
+	isp_table_update.prev_wbal = config->prev_wbal;
 
 	if (omap34xx_isp_tables_update(isp_prev, &isp_table_update))
 		goto err_copy_from_user;
 
+	spin_lock_irqsave(&isp_prev->lock, flags);
+	isp_prev->shadow_update = 0;
+	spin_unlock_irqrestore(&isp_prev->lock, flags);
+
 	return 0;
 
 err_copy_from_user:
-	dev_err(isp_prev->dev, "preview: Config: Copy From User Error\n");
+	spin_lock_irqsave(&isp_prev->lock, flags);
+	isp_prev->shadow_update = 0;
+	spin_unlock_irqrestore(&isp_prev->lock, flags);
+
+	dev_err(dev, "preview: Config: Copy From User Error\n");
 	return -EFAULT;
 }
 EXPORT_SYMBOL_GPL(omap34xx_isp_preview_config);
@@ -368,13 +372,23 @@ EXPORT_SYMBOL_GPL(omap34xx_isp_preview_c
  * @isptables_struct: Pointer from Userspace to structure with flags and table
  *                 data to update.
  **/
-int omap34xx_isp_tables_update(struct isp_prev_device *isp_prev,
+static int omap34xx_isp_tables_update(struct isp_prev_device *isp_prev,
 			       struct isptables_update *isptables_struct)
 {
+	struct device *dev = to_device(isp_prev);
+
+	if (ISP_ABS_PREV_WB & isptables_struct->update) {
+		if (copy_from_user(&isp_prev->params.wbal,
+				isptables_struct->prev_wbal,
+				sizeof(struct ispprev_wbal)))
+			goto err_copy_from_user;
+
+		isp_prev->wbal_update = 1;
+	}
 
 	if (ISP_ABS_TBL_NF & isptables_struct->flag) {
 		isp_prev->nf_enable = 1;
-		isp_prev->params->features |= PREV_NOISE_FILTER;
+		isp_prev->params.features |= PREV_NOISE_FILTER;
 		if (ISP_ABS_TBL_NF & isptables_struct->update) {
 			if (copy_from_user(&isp_prev->prev_nf_t,
 					   (struct ispprev_nf *)
@@ -387,7 +401,7 @@ int omap34xx_isp_tables_update(struct is
 			isp_prev->nf_update = 0;
 	} else {
 		isp_prev->nf_enable = 0;
-		isp_prev->params->features &= ~PREV_NOISE_FILTER;
+		isp_prev->params.features &= ~PREV_NOISE_FILTER;
 		if (ISP_ABS_TBL_NF & isptables_struct->update)
 			isp_prev->nf_update = 1;
 		else
@@ -422,10 +436,36 @@ int omap34xx_isp_tables_update(struct is
 	} else
 		isp_prev->bg_update = 0;
 
+	if (ISP_ABS_PREV_CFA & isptables_struct->update) {
+		struct ispprev_cfa cfa;
+		if (isptables_struct->prev_cfa) {
+			if (copy_from_user(&cfa,
+					   isptables_struct->prev_cfa,
+					   sizeof(struct ispprev_cfa)))
+				goto err_copy_from_user;
+			if (cfa.cfa_table != NULL) {
+				if (copy_from_user(cfa_coef_table,
+						   cfa.cfa_table,
+						   sizeof(cfa_coef_table)))
+					goto err_copy_from_user;
+			}
+			cfa.cfa_table = cfa_coef_table;
+			isp_prev->params.cfa = cfa;
+		}
+		if (ISP_ABS_PREV_CFA & isptables_struct->flag) {
+			isp_prev->cfa_en = 1;
+			isp_prev->params.features |= PREV_CFA;
+		} else {
+			isp_prev->cfa_en = 0;
+			isp_prev->params.features &= ~PREV_CFA;
+		}
+		isp_prev->cfa_update = 1;
+	}
+
 	return 0;
 
 err_copy_from_user:
-	dev_err(isp_prev->dev, "preview tables: Copy From User Error\n");
+	dev_err(dev, "preview tables: Copy From User Error\n");
 	return -EFAULT;
 }
 
@@ -436,8 +476,16 @@ err_copy_from_user:
  **/
 void isppreview_config_shadow_registers(struct isp_prev_device *isp_prev)
 {
+	struct device *dev = to_device(isp_prev);
 	u8 current_brightness_contrast;
-	int ctr, prv_disabled;
+	int ctr;
+	unsigned long flags;
+
+	spin_lock_irqsave(&isp_prev->lock, flags);
+	if (isp_prev->shadow_update) {
+		spin_unlock_irqrestore(&isp_prev->lock, flags);
+		return;
+	}
 
 	isppreview_query_brightness(isp_prev, &current_brightness_contrast);
 	if (current_brightness_contrast !=
@@ -456,6 +504,10 @@ void isppreview_config_shadow_registers(
 		isppreview_config_contrast(isp_prev, isp_prev->contrast *
 					   ISPPRV_CONTRAST_UNITS);
 	}
+	if (isp_prev->wbal_update) {
+		isppreview_config_whitebalance(isp_prev, isp_prev->params.wbal);
+		isp_prev->wbal_update = 0;
+	}
 	if (isp_prev->update_color_matrix) {
 		isppreview_config_rgb_to_ycbcr(isp_prev,
 					       flr_prev_csc[isp_prev->color]);
@@ -463,22 +515,21 @@ void isppreview_config_shadow_registers(
 	}
 	if (isp_prev->update_rgb_blending) {
 		isp_prev->update_rgb_blending = 0;
-		wmb();
 		isppreview_config_rgb_blending(isp_prev,
-					       isp_prev->params->rgb2rgb);
+					       isp_prev->params.rgb2rgb);
 	}
-	if (isp_prev->gg_update || isp_prev->rg_update
-	    || isp_prev->bg_update || isp_prev->nf_update) {
-		isppreview_enable(isp_prev, 0);
-		prv_disabled = 1;
+	if (isp_prev->update_rgb_to_ycbcr) {
+		isp_prev->update_rgb_to_ycbcr = 0;
+		isppreview_config_rgb_to_ycbcr(isp_prev,
+					       isp_prev->params.rgb2ycbcr);
 	}
 
 	if (isp_prev->gg_update) {
-		isp_reg_writel(isp_prev->dev, ISPPRV_TBL_ADDR_GREEN_G_START,
+		isp_reg_writel(dev, ISPPRV_TBL_ADDR_GREEN_G_START,
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
 
 		for (ctr = 0; ctr < ISP_GAMMA_TABLE_SIZE; ctr++) {
-			isp_reg_writel(isp_prev->dev, greengamma_table[ctr],
+			isp_reg_writel(dev, greengamma_table[ctr],
 				       OMAP3_ISP_IOMEM_PREV,
 				       ISPPRV_SET_TBL_DATA);
 		}
@@ -486,11 +537,11 @@ void isppreview_config_shadow_registers(
 	}
 
 	if (isp_prev->rg_update) {
-		isp_reg_writel(isp_prev->dev, ISPPRV_TBL_ADDR_RED_G_START,
+		isp_reg_writel(dev, ISPPRV_TBL_ADDR_RED_G_START,
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
 
 		for (ctr = 0; ctr < ISP_GAMMA_TABLE_SIZE; ctr++) {
-			isp_reg_writel(isp_prev->dev, redgamma_table[ctr],
+			isp_reg_writel(dev, redgamma_table[ctr],
 				       OMAP3_ISP_IOMEM_PREV,
 				       ISPPRV_SET_TBL_DATA);
 		}
@@ -498,24 +549,30 @@ void isppreview_config_shadow_registers(
 	}
 
 	if (isp_prev->bg_update) {
-		isp_reg_writel(isp_prev->dev, ISPPRV_TBL_ADDR_BLUE_G_START,
+		isp_reg_writel(dev, ISPPRV_TBL_ADDR_BLUE_G_START,
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
 
 		for (ctr = 0; ctr < ISP_GAMMA_TABLE_SIZE; ctr++) {
-			isp_reg_writel(isp_prev->dev, bluegamma_table[ctr],
+			isp_reg_writel(dev, bluegamma_table[ctr],
 				       OMAP3_ISP_IOMEM_PREV,
 				       ISPPRV_SET_TBL_DATA);
 		}
 		isp_prev->bg_update = 0;
 	}
 
+	if (isp_prev->cfa_update) {
+		isp_prev->cfa_update = 0;
+		isppreview_config_cfa(isp_prev, &isp_prev->params.cfa);
+		isppreview_enable_cfa(isp_prev, isp_prev->cfa_en);
+	}
+
 	if (isp_prev->nf_update && isp_prev->nf_enable) {
-		isp_reg_writel(isp_prev->dev, 0xC00,
+		isp_reg_writel(dev, 0xC00,
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
-		isp_reg_writel(isp_prev->dev, isp_prev->prev_nf_t.spread,
+		isp_reg_writel(dev, isp_prev->prev_nf_t.spread,
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_NF);
 		for (ctr = 0; ctr < ISPPRV_NF_TBL_SIZE; ctr++) {
-			isp_reg_writel(isp_prev->dev,
+			isp_reg_writel(dev,
 				       isp_prev->prev_nf_t.table[ctr],
 				       OMAP3_ISP_IOMEM_PREV,
 				       ISPPRV_SET_TBL_DATA);
@@ -530,12 +587,8 @@ void isppreview_config_shadow_registers(
 	if (isp_prev->nf_update && ~isp_prev->nf_enable)
 		isppreview_enable_noisefilter(isp_prev, 0);
 
-	if (prv_disabled) {
-		isppreview_enable(isp_prev, 1);
-		prv_disabled = 0;
-	}
+	spin_unlock_irqrestore(&isp_prev->lock, flags);
 }
-EXPORT_SYMBOL_GPL(isppreview_config_shadow_registers);
 
 /**
  * isppreview_request - Reserves the preview module.
@@ -544,15 +597,9 @@ EXPORT_SYMBOL_GPL(isppreview_config_shad
  **/
 int isppreview_request(struct isp_prev_device *isp_prev)
 {
-	mutex_lock(&isp_prev->ispprev_mutex);
-	if (isp_prev->prev_inuse) {
-		mutex_unlock(&isp_prev->ispprev_mutex);
-		dev_err(isp_prev->dev, "preview: Module Busy\n");
-		return -EBUSY;
-	}
-	isp_prev->prev_inuse = 1;
-	mutex_unlock(&isp_prev->ispprev_mutex);
-	isp_reg_or(isp_prev->dev,
+	struct device *dev = to_device(isp_prev);
+
+	isp_reg_or(dev,
 		   OMAP3_ISP_IOMEM_MAIN, ISP_CTRL, ISPCTRL_PREV_RAM_EN |
 		   ISPCTRL_PREV_CLK_EN | ISPCTRL_SBL_WR1_RAM_EN);
 	return 0;
@@ -566,21 +613,14 @@ EXPORT_SYMBOL_GPL(isppreview_request);
  **/
 int isppreview_free(struct isp_prev_device *isp_prev)
 {
-	mutex_lock(&isp_prev->ispprev_mutex);
-	if (isp_prev->prev_inuse) {
-		isp_prev->prev_inuse = 0;
-		mutex_unlock(&isp_prev->ispprev_mutex);
-		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,
+	struct device *dev = to_device(isp_prev);
+
+	isp_reg_and(dev, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,
 			    ~(ISPCTRL_PREV_CLK_EN |
 			      ISPCTRL_PREV_RAM_EN |
 			      ISPCTRL_SBL_WR1_RAM_EN));
-		return 0;
-	} else {
-		mutex_unlock(&isp_prev->ispprev_mutex);
-		DPRINTK_ISPPREV("ISP_ERR : Preview Module already freed\n");
-		return -EINVAL;
-	}
 
+	return 0;
 }
 EXPORT_SYMBOL_GPL(isppreview_free);
 
@@ -599,47 +639,38 @@ EXPORT_SYMBOL_GPL(isppreview_free);
  * specified.
  **/
 int isppreview_config_datapath(struct isp_prev_device *isp_prev,
-			       enum preview_input input,
-			       enum preview_output output)
+			       struct isp_pipeline *pipe)
 {
+	struct device *dev = to_device(isp_prev);
 	u32 pcr = 0;
 	u8 enable = 0;
-	struct prev_params *params = isp_prev->prev_params;
+	struct prev_params *params = &isp_prev->params;
 	struct ispprev_yclimit yclimit;
 
-	pcr = isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
+	pcr = isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
 
-	switch (input) {
+	switch (pipe->prv_in) {
 	case PRV_RAW_CCDC:
 		pcr &= ~ISPPRV_PCR_SOURCE;
-		pcr &= ~ISPPRV_PCR_ONESHOT;
-		isp_prev->prev_inpfmt = PRV_RAW_CCDC;
 		break;
 	case PRV_RAW_MEM:
 		pcr |= ISPPRV_PCR_SOURCE;
-		pcr |= ISPPRV_PCR_ONESHOT;
-		isp_prev->prev_inpfmt = PRV_RAW_MEM;
 		break;
 	case PRV_CCDC_DRKF:
 		pcr |= ISPPRV_PCR_DRKFCAP;
-		pcr |= ISPPRV_PCR_ONESHOT;
-		isp_prev->prev_inpfmt = PRV_CCDC_DRKF;
 		break;
 	case PRV_COMPCFA:
-		isp_prev->prev_inpfmt = PRV_COMPCFA;
 		break;
 	case PRV_OTHERS:
-		isp_prev->prev_inpfmt = PRV_OTHERS;
 		break;
 	case PRV_RGBBAYERCFA:
-		isp_prev->prev_inpfmt = PRV_RGBBAYERCFA;
 		break;
 	default:
-		dev_err(isp_prev->dev, "preview: Wrong Input\n");
+		dev_err(dev, "preview: Wrong Input\n");
 		return -EINVAL;
 	};
 
-	switch (output) {
+	switch (pipe->prv_out) {
 	case PREVIEW_RSZ:
 		pcr |= ISPPRV_PCR_RSZPORT;
 		pcr &= ~ISPPRV_PCR_SDRPORT;
@@ -649,17 +680,12 @@ int isppreview_config_datapath(struct is
 		pcr |= ISPPRV_PCR_SDRPORT;
 		break;
 	default:
-		dev_err(isp_prev->dev, "preview: Wrong Output\n");
+		dev_err(dev, "preview: Wrong Output\n");
 		return -EINVAL;
 	}
-	isp_prev->prev_outfmt = output;
-
-	isp_reg_writel(isp_prev->dev, pcr, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
 
-	isppreview_config_ycpos(isp_prev, params->pix_fmt);
+	isp_reg_writel(dev, pcr, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
 
-	if (params->cfa.cfa_table != NULL)
-		isppreview_config_cfa(isp_prev, params->cfa);
 	if (params->csup.hypf_en == 1)
 		isppreview_config_chroma_suppression(isp_prev, params->csup);
 	if (params->ytable != NULL)
@@ -668,6 +694,8 @@ int isppreview_config_datapath(struct is
 	if (params->gtable.redtable != NULL)
 		isppreview_config_gammacorrn(isp_prev, params->gtable);
 
+	isp_prev->cfa_update = 0;
+	isppreview_config_cfa(isp_prev, &params->cfa);
 	enable = (params->features & PREV_CFA) ? 1 : 0;
 	isppreview_enable_cfa(isp_prev, enable);
 
@@ -691,6 +719,8 @@ int isppreview_config_datapath(struct is
 	isppreview_enable_gammabypass(isp_prev, enable);
 
 	isppreview_config_whitebalance(isp_prev, params->wbal);
+	isp_prev->wbal_update = 0;
+
 	isppreview_config_blkadj(isp_prev, params->blk_adj);
 	isppreview_config_rgb_blending(isp_prev, params->rgb2rgb);
 	isppreview_config_rgb_to_ycbcr(isp_prev, params->rgb2ycbcr);
@@ -729,11 +759,12 @@ EXPORT_SYMBOL_GPL(isppreview_set_skip);
 void isppreview_config_ycpos(struct isp_prev_device *isp_prev,
 			     enum preview_ycpos_mode mode)
 {
-	u32 pcr = isp_reg_readl(isp_prev->dev,
+	struct device *dev = to_device(isp_prev);
+	u32 pcr = isp_reg_readl(dev,
 				OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
 	pcr &= ~ISPPRV_PCR_YCPOS_CrYCbY;
 	pcr |= (mode << ISPPRV_PCR_YCPOS_SHIFT);
-	isp_reg_writel(isp_prev->dev, pcr, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
+	isp_reg_writel(dev, pcr, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
 }
 EXPORT_SYMBOL_GPL(isppreview_config_ycpos);
 
@@ -743,10 +774,11 @@ EXPORT_SYMBOL_GPL(isppreview_config_ycpo
  **/
 void isppreview_config_averager(struct isp_prev_device *isp_prev, u8 average)
 {
+	struct device *dev = to_device(isp_prev);
 	int reg = 0;
 
 	reg = AVE_ODD_PIXEL_DIST | AVE_EVEN_PIXEL_DIST | average;
-	isp_reg_writel(isp_prev->dev, reg, OMAP3_ISP_IOMEM_PREV, ISPPRV_AVE);
+	isp_reg_writel(dev, reg, OMAP3_ISP_IOMEM_PREV, ISPPRV_AVE);
 }
 EXPORT_SYMBOL_GPL(isppreview_config_averager);
 
@@ -756,16 +788,18 @@ EXPORT_SYMBOL_GPL(isppreview_config_aver
  **/
 void isppreview_enable_invalaw(struct isp_prev_device *isp_prev, u8 enable)
 {
+	struct device *dev = to_device(isp_prev);
 	u32 pcr_val = 0;
-	pcr_val = isp_reg_readl(isp_prev->dev,
+
+	pcr_val = isp_reg_readl(dev,
 				OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
 
 	if (enable) {
-		isp_reg_writel(isp_prev->dev,
+		isp_reg_writel(dev,
 			       pcr_val | ISPPRV_PCR_WIDTH | ISPPRV_PCR_INVALAW,
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
 	} else {
-		isp_reg_writel(isp_prev->dev, pcr_val &
+		isp_reg_writel(dev, pcr_val &
 			       ~(ISPPRV_PCR_WIDTH | ISPPRV_PCR_INVALAW),
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
 	}
@@ -781,11 +815,13 @@ EXPORT_SYMBOL_GPL(isppreview_enable_inva
  **/
 void isppreview_enable_drkframe(struct isp_prev_device *isp_prev, u8 enable)
 {
+	struct device *dev = to_device(isp_prev);
+
 	if (enable)
-		isp_reg_or(isp_prev->dev,
+		isp_reg_or(dev,
 			   OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR, ISPPRV_PCR_DRKFEN);
 	else {
-		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			    ~ISPPRV_PCR_DRKFEN);
 	}
 }
@@ -800,13 +836,14 @@ EXPORT_SYMBOL_GPL(isppreview_enable_drkf
  **/
 void isppreview_enable_shadcomp(struct isp_prev_device *isp_prev, u8 enable)
 {
+	struct device *dev = to_device(isp_prev);
 
 	if (enable) {
-		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			   ISPPRV_PCR_SCOMP_EN);
 		isppreview_enable_drkframe(isp_prev, 1);
 	} else {
-		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			    ~ISPPRV_PCR_SCOMP_EN);
 	}
 }
@@ -819,11 +856,12 @@ EXPORT_SYMBOL_GPL(isppreview_enable_shad
 void isppreview_config_drkf_shadcomp(struct isp_prev_device *isp_prev,
 				     u8 scomp_shtval)
 {
-	u32 pcr_val = isp_reg_readl(isp_prev->dev,
+	struct device *dev = to_device(isp_prev);
+	u32 pcr_val = isp_reg_readl(dev,
 				    OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
 
 	pcr_val &= ISPPRV_PCR_SCOMP_SFT_MASK;
-	isp_reg_writel(isp_prev->dev,
+	isp_reg_writel(dev,
 		       pcr_val | (scomp_shtval << ISPPRV_PCR_SCOMP_SFT_SHIFT),
 		       OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
 }
@@ -835,11 +873,13 @@ EXPORT_SYMBOL_GPL(isppreview_config_drkf
  **/
 void isppreview_enable_hmed(struct isp_prev_device *isp_prev, u8 enable)
 {
+	struct device *dev = to_device(isp_prev);
+
 	if (enable)
-		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			   ISPPRV_PCR_HMEDEN);
 	else {
-		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			    ~ISPPRV_PCR_HMEDEN);
 	}
 	isp_prev->hmed_en = enable ? 1 : 0;
@@ -854,6 +894,7 @@ EXPORT_SYMBOL_GPL(isppreview_enable_hmed
 void isppreview_config_hmed(struct isp_prev_device *isp_prev,
 			    struct ispprev_hmed prev_hmed)
 {
+	struct device *dev = to_device(isp_prev);
 
 	u32 odddist = 0;
 	u32 evendist = 0;
@@ -868,7 +909,7 @@ void isppreview_config_hmed(struct isp_p
 	else
 		evendist = ISPPRV_HMED_EVENDIST;
 
-	isp_reg_writel(isp_prev->dev, odddist | evendist | (prev_hmed.thres <<
+	isp_reg_writel(dev, odddist | evendist | (prev_hmed.thres <<
 					     ISPPRV_HMED_THRESHOLD_SHIFT),
 		       OMAP3_ISP_IOMEM_PREV, ISPPRV_HMED);
 
@@ -883,14 +924,15 @@ EXPORT_SYMBOL_GPL(isppreview_config_hmed
 void isppreview_config_noisefilter(struct isp_prev_device *isp_prev,
 				   struct ispprev_nf prev_nf)
 {
+	struct device *dev = to_device(isp_prev);
 	int i = 0;
 
-	isp_reg_writel(isp_prev->dev, prev_nf.spread, OMAP3_ISP_IOMEM_PREV,
+	isp_reg_writel(dev, prev_nf.spread, OMAP3_ISP_IOMEM_PREV,
 		       ISPPRV_NF);
-	isp_reg_writel(isp_prev->dev, ISPPRV_NF_TABLE_ADDR,
+	isp_reg_writel(dev, ISPPRV_NF_TABLE_ADDR,
 		       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
 	for (i = 0; i < ISPPRV_NF_TBL_SIZE; i++) {
-		isp_reg_writel(isp_prev->dev, prev_nf.table[i],
+		isp_reg_writel(dev, prev_nf.table[i],
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);
 	}
 }
@@ -903,19 +945,21 @@ EXPORT_SYMBOL_GPL(isppreview_config_nois
 void isppreview_config_dcor(struct isp_prev_device *isp_prev,
 			    struct ispprev_dcor prev_dcor)
 {
+	struct device *dev = to_device(isp_prev);
+
 	if (prev_dcor.couplet_mode_en) {
-		isp_reg_writel(isp_prev->dev, prev_dcor.detect_correct[0],
+		isp_reg_writel(dev, prev_dcor.detect_correct[0],
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR0);
-		isp_reg_writel(isp_prev->dev, prev_dcor.detect_correct[1],
+		isp_reg_writel(dev, prev_dcor.detect_correct[1],
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR1);
-		isp_reg_writel(isp_prev->dev, prev_dcor.detect_correct[2],
+		isp_reg_writel(dev, prev_dcor.detect_correct[2],
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR2);
-		isp_reg_writel(isp_prev->dev, prev_dcor.detect_correct[3],
+		isp_reg_writel(dev, prev_dcor.detect_correct[3],
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR3);
-		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			   ISPPRV_PCR_DCCOUP);
 	} else {
-		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			    ~ISPPRV_PCR_DCCOUP);
 	}
 }
@@ -927,25 +971,27 @@ EXPORT_SYMBOL_GPL(isppreview_config_dcor
  *            in the image, vertical and horizontal gradient threshold.
  **/
 void isppreview_config_cfa(struct isp_prev_device *isp_prev,
-			   struct ispprev_cfa prev_cfa)
+			   struct ispprev_cfa *prev_cfa)
 {
+	struct device *dev = to_device(isp_prev);
 	int i = 0;
 
-	isp_prev->cfafmt = prev_cfa.cfafmt;
-
-	isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
-		   (prev_cfa.cfafmt << ISPPRV_PCR_CFAFMT_SHIFT));
+	isp_prev->cfafmt = prev_cfa->cfafmt;
 
-	isp_reg_writel(isp_prev->dev,
-		(prev_cfa.cfa_gradthrs_vert << ISPPRV_CFA_GRADTH_VER_SHIFT) |
-		(prev_cfa.cfa_gradthrs_horz << ISPPRV_CFA_GRADTH_HOR_SHIFT),
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		       ~ISPPRV_PCR_CFAFMT_MASK,
+		       (prev_cfa->cfafmt << ISPPRV_PCR_CFAFMT_SHIFT));
+
+	isp_reg_writel(dev,
+		(prev_cfa->cfa_gradthrs_vert << ISPPRV_CFA_GRADTH_VER_SHIFT) |
+		(prev_cfa->cfa_gradthrs_horz << ISPPRV_CFA_GRADTH_HOR_SHIFT),
 		OMAP3_ISP_IOMEM_PREV, ISPPRV_CFA);
 
-	isp_reg_writel(isp_prev->dev, ISPPRV_CFA_TABLE_ADDR,
+	isp_reg_writel(dev, ISPPRV_CFA_TABLE_ADDR,
 		       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
 
 	for (i = 0; i < ISPPRV_CFA_TBL_SIZE; i++) {
-		isp_reg_writel(isp_prev->dev, prev_cfa.cfa_table[i],
+		isp_reg_writel(dev, prev_cfa->cfa_table[i],
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);
 	}
 }
@@ -958,26 +1004,27 @@ EXPORT_SYMBOL_GPL(isppreview_config_cfa)
 void isppreview_config_gammacorrn(struct isp_prev_device *isp_prev,
 				  struct ispprev_gtable gtable)
 {
+	struct device *dev = to_device(isp_prev);
 	int i = 0;
 
-	isp_reg_writel(isp_prev->dev, ISPPRV_REDGAMMA_TABLE_ADDR,
+	isp_reg_writel(dev, ISPPRV_REDGAMMA_TABLE_ADDR,
 		       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
 	for (i = 0; i < ISPPRV_GAMMA_TBL_SIZE; i++) {
-		isp_reg_writel(isp_prev->dev, gtable.redtable[i],
+		isp_reg_writel(dev, gtable.redtable[i],
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);
 	}
 
-	isp_reg_writel(isp_prev->dev, ISPPRV_GREENGAMMA_TABLE_ADDR,
+	isp_reg_writel(dev, ISPPRV_GREENGAMMA_TABLE_ADDR,
 		       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
 	for (i = 0; i < ISPPRV_GAMMA_TBL_SIZE; i++) {
-		isp_reg_writel(isp_prev->dev, gtable.greentable[i],
+		isp_reg_writel(dev, gtable.greentable[i],
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);
 	}
 
-	isp_reg_writel(isp_prev->dev, ISPPRV_BLUEGAMMA_TABLE_ADDR,
+	isp_reg_writel(dev, ISPPRV_BLUEGAMMA_TABLE_ADDR,
 		       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
 	for (i = 0; i < ISPPRV_GAMMA_TBL_SIZE; i++) {
-		isp_reg_writel(isp_prev->dev, gtable.bluetable[i],
+		isp_reg_writel(dev, gtable.bluetable[i],
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);
 	}
 }
@@ -990,12 +1037,13 @@ EXPORT_SYMBOL_GPL(isppreview_config_gamm
 void isppreview_config_luma_enhancement(struct isp_prev_device *isp_prev,
 					u32 *ytable)
 {
+	struct device *dev = to_device(isp_prev);
 	int i = 0;
 
-	isp_reg_writel(isp_prev->dev, ISPPRV_YENH_TABLE_ADDR,
+	isp_reg_writel(dev, ISPPRV_YENH_TABLE_ADDR,
 		       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
 	for (i = 0; i < ISPPRV_YENH_TBL_SIZE; i++) {
-		isp_reg_writel(isp_prev->dev, ytable[i],
+		isp_reg_writel(dev, ytable[i],
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);
 	}
 }
@@ -1009,7 +1057,9 @@ EXPORT_SYMBOL_GPL(isppreview_config_luma
 void isppreview_config_chroma_suppression(struct isp_prev_device *isp_prev,
 					  struct ispprev_csup csup)
 {
-	isp_reg_writel(isp_prev->dev,
+	struct device *dev = to_device(isp_prev);
+
+	isp_reg_writel(dev,
 		       csup.gain | (csup.thres << ISPPRV_CSUP_THRES_SHIFT) |
 		       (csup.hypf_en << ISPPRV_CSUP_HPYF_SHIFT),
 		       OMAP3_ISP_IOMEM_PREV, ISPPRV_CSUP);
@@ -1022,11 +1072,13 @@ EXPORT_SYMBOL_GPL(isppreview_config_chro
  **/
 void isppreview_enable_noisefilter(struct isp_prev_device *isp_prev, u8 enable)
 {
+	struct device *dev = to_device(isp_prev);
+
 	if (enable)
-		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			   ISPPRV_PCR_NFEN);
 	else
-		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			    ~ISPPRV_PCR_NFEN);
 	isp_prev->nf_en = enable ? 1 : 0;
 }
@@ -1038,11 +1090,13 @@ EXPORT_SYMBOL_GPL(isppreview_enable_nois
  **/
 void isppreview_enable_dcor(struct isp_prev_device *isp_prev, u8 enable)
 {
+	struct device *dev = to_device(isp_prev);
+
 	if (enable)
-		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			   ISPPRV_PCR_DCOREN);
 	else {
-		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			    ~ISPPRV_PCR_DCOREN);
 	}
 	isp_prev->dcor_en = enable ? 1 : 0;
@@ -1055,11 +1109,13 @@ EXPORT_SYMBOL_GPL(isppreview_enable_dcor
  **/
 void isppreview_enable_cfa(struct isp_prev_device *isp_prev, u8 enable)
 {
+	struct device *dev = to_device(isp_prev);
+
 	if (enable)
-		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			   ISPPRV_PCR_CFAEN);
 	else {
-		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			    ~ISPPRV_PCR_CFAEN);
 	}
 	isp_prev->cfa_en = enable ? 1 : 0;
@@ -1073,11 +1129,13 @@ EXPORT_SYMBOL_GPL(isppreview_enable_cfa)
  **/
 void isppreview_enable_gammabypass(struct isp_prev_device *isp_prev, u8 enable)
 {
+	struct device *dev = to_device(isp_prev);
+
 	if (enable) {
-		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			   ISPPRV_PCR_GAMMA_BYPASS);
 	} else {
-		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			    ~ISPPRV_PCR_GAMMA_BYPASS);
 	}
 }
@@ -1090,11 +1148,13 @@ EXPORT_SYMBOL_GPL(isppreview_enable_gamm
 void isppreview_enable_luma_enhancement(struct isp_prev_device *isp_prev,
 					u8 enable)
 {
+	struct device *dev = to_device(isp_prev);
+
 	if (enable) {
-		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			   ISPPRV_PCR_YNENHEN);
 	} else {
-		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			    ~ISPPRV_PCR_YNENHEN);
 	}
 	isp_prev->yenh_en = enable ? 1 : 0;
@@ -1108,11 +1168,13 @@ EXPORT_SYMBOL_GPL(isppreview_enable_luma
 void isppreview_enable_chroma_suppression(struct isp_prev_device *isp_prev,
 					  u8 enable)
 {
+	struct device *dev = to_device(isp_prev);
+
 	if (enable)
-		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			   ISPPRV_PCR_SUPEN);
 	else {
-		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
 			    ~ISPPRV_PCR_SUPEN);
 	}
 	isp_prev->csup_en = enable ? 1 : 0;
@@ -1129,19 +1191,20 @@ EXPORT_SYMBOL_GPL(isppreview_enable_chro
 void isppreview_config_whitebalance(struct isp_prev_device *isp_prev,
 				    struct ispprev_wbal prev_wbal)
 {
+	struct device *dev = to_device(isp_prev);
 	u32 val;
 
-	isp_reg_writel(isp_prev->dev, prev_wbal.dgain, OMAP3_ISP_IOMEM_PREV,
+	isp_reg_writel(dev, prev_wbal.dgain, OMAP3_ISP_IOMEM_PREV,
 		       ISPPRV_WB_DGAIN);
 
 	val = prev_wbal.coef0 << ISPPRV_WBGAIN_COEF0_SHIFT;
 	val |= prev_wbal.coef1 << ISPPRV_WBGAIN_COEF1_SHIFT;
 	val |= prev_wbal.coef2 << ISPPRV_WBGAIN_COEF2_SHIFT;
 	val |= prev_wbal.coef3 << ISPPRV_WBGAIN_COEF3_SHIFT;
-	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_PREV,
 		       ISPPRV_WBGAIN);
 
-	isp_reg_writel(isp_prev->dev,
+	isp_reg_writel(dev,
 		       ISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N0_0_SHIFT |
 		       ISPPRV_WBSEL_COEF1 << ISPPRV_WBSEL_N0_1_SHIFT |
 		       ISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N0_2_SHIFT |
@@ -1172,15 +1235,17 @@ EXPORT_SYMBOL_GPL(isppreview_config_whit
 void isppreview_config_whitebalance2(struct isp_prev_device *isp_prev,
 				     struct prev_white_balance prev_wbal)
 {
-	isp_reg_writel(isp_prev->dev, prev_wbal.wb_dgain,
+	struct device *dev = to_device(isp_prev);
+
+	isp_reg_writel(dev, prev_wbal.wb_dgain,
 		       OMAP3_ISP_IOMEM_PREV, ISPPRV_WB_DGAIN);
-	isp_reg_writel(isp_prev->dev, prev_wbal.wb_gain[0] |
+	isp_reg_writel(dev, prev_wbal.wb_gain[0] |
 		       prev_wbal.wb_gain[1] << ISPPRV_WBGAIN_COEF1_SHIFT |
 		       prev_wbal.wb_gain[2] << ISPPRV_WBGAIN_COEF2_SHIFT |
 		       prev_wbal.wb_gain[3] << ISPPRV_WBGAIN_COEF3_SHIFT,
 		       OMAP3_ISP_IOMEM_PREV, ISPPRV_WBGAIN);
 
-	isp_reg_writel(isp_prev->dev,
+	isp_reg_writel(dev,
 		prev_wbal.wb_coefmatrix[0][0] << ISPPRV_WBSEL_N0_0_SHIFT |
 		prev_wbal.wb_coefmatrix[0][1] << ISPPRV_WBSEL_N0_1_SHIFT |
 		prev_wbal.wb_coefmatrix[0][2] << ISPPRV_WBSEL_N0_2_SHIFT |
@@ -1209,7 +1274,9 @@ EXPORT_SYMBOL_GPL(isppreview_config_whit
 void isppreview_config_blkadj(struct isp_prev_device *isp_prev,
 			      struct ispprev_blkadj prev_blkadj)
 {
-	isp_reg_writel(isp_prev->dev, prev_blkadj.blue |
+	struct device *dev = to_device(isp_prev);
+
+	isp_reg_writel(dev, prev_blkadj.blue |
 		       (prev_blkadj.green << ISPPRV_BLKADJOFF_G_SHIFT) |
 		       (prev_blkadj.red << ISPPRV_BLKADJOFF_R_SHIFT),
 		       OMAP3_ISP_IOMEM_PREV, ISPPRV_BLKADJOFF);
@@ -1224,39 +1291,40 @@ EXPORT_SYMBOL_GPL(isppreview_config_blka
 void isppreview_config_rgb_blending(struct isp_prev_device *isp_prev,
 				    struct ispprev_rgbtorgb rgb2rgb)
 {
+	struct device *dev = to_device(isp_prev);
 	u32 val = 0;
 
 	val = (rgb2rgb.matrix[0][0] & 0xfff) << ISPPRV_RGB_MAT1_MTX_RR_SHIFT;
 	val |= (rgb2rgb.matrix[0][1] & 0xfff) << ISPPRV_RGB_MAT1_MTX_GR_SHIFT;
-	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_PREV,
 		       ISPPRV_RGB_MAT1);
 
 	val = (rgb2rgb.matrix[0][2] & 0xfff) << ISPPRV_RGB_MAT2_MTX_BR_SHIFT;
 	val |= (rgb2rgb.matrix[1][0] & 0xfff) << ISPPRV_RGB_MAT2_MTX_RG_SHIFT;
-	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_PREV,
 		       ISPPRV_RGB_MAT2);
 
 	val = (rgb2rgb.matrix[1][1] & 0xfff) << ISPPRV_RGB_MAT3_MTX_GG_SHIFT;
 	val |= (rgb2rgb.matrix[1][2] & 0xfff) << ISPPRV_RGB_MAT3_MTX_BG_SHIFT;
-	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_PREV,
 		       ISPPRV_RGB_MAT3);
 
 	val = (rgb2rgb.matrix[2][0] & 0xfff) << ISPPRV_RGB_MAT4_MTX_RB_SHIFT;
 	val |= (rgb2rgb.matrix[2][1] & 0xfff) << ISPPRV_RGB_MAT4_MTX_GB_SHIFT;
-	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_PREV,
 		       ISPPRV_RGB_MAT4);
 
 	val = (rgb2rgb.matrix[2][2] & 0xfff) << ISPPRV_RGB_MAT5_MTX_BB_SHIFT;
-	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_PREV,
 		       ISPPRV_RGB_MAT5);
 
-	val = (rgb2rgb.offset[0] & 0x3ff) << ISPPRV_RGB_OFF1_MTX_OFFG_SHIFT;
-	val |= (rgb2rgb.offset[1] & 0x3ff) << ISPPRV_RGB_OFF1_MTX_OFFR_SHIFT;
-	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+	val = (rgb2rgb.offset[0] & 0x3ff) << ISPPRV_RGB_OFF1_MTX_OFFR_SHIFT;
+	val |= (rgb2rgb.offset[1] & 0x3ff) << ISPPRV_RGB_OFF1_MTX_OFFG_SHIFT;
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_PREV,
 		       ISPPRV_RGB_OFF1);
 
 	val = (rgb2rgb.offset[2] & 0x3ff) << ISPPRV_RGB_OFF2_MTX_OFFB_SHIFT;
-	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_PREV,
 		       ISPPRV_RGB_OFF2);
 }
 EXPORT_SYMBOL_GPL(isppreview_config_rgb_blending);
@@ -1269,27 +1337,28 @@ EXPORT_SYMBOL_GPL(isppreview_config_rgb_
 void isppreview_config_rgb_to_ycbcr(struct isp_prev_device *isp_prev,
 				    struct ispprev_csc prev_csc)
 {
+	struct device *dev = to_device(isp_prev);
 	u32 val = 0;
 
 	val = (prev_csc.matrix[0][0] & 0x3ff) << ISPPRV_CSC0_RY_SHIFT;
 	val |= (prev_csc.matrix[0][1] & 0x3ff) << ISPPRV_CSC0_GY_SHIFT;
 	val |= (prev_csc.matrix[0][2] & 0x3ff) << ISPPRV_CSC0_BY_SHIFT;
-	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC0);
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC0);
 
 	val = (prev_csc.matrix[1][0] & 0x3ff) << ISPPRV_CSC1_RCB_SHIFT;
 	val |= (prev_csc.matrix[1][1] & 0x3ff) << ISPPRV_CSC1_GCB_SHIFT;
 	val |= (prev_csc.matrix[1][2] & 0x3ff) << ISPPRV_CSC1_BCB_SHIFT;
-	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC1);
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC1);
 
 	val = (prev_csc.matrix[2][0] & 0x3ff) << ISPPRV_CSC2_RCR_SHIFT;
 	val |= (prev_csc.matrix[2][1] & 0x3ff) << ISPPRV_CSC2_GCR_SHIFT;
 	val |= (prev_csc.matrix[2][2] & 0x3ff) << ISPPRV_CSC2_BCR_SHIFT;
-	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC2);
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC2);
 
-	val = (prev_csc.offset[0] & 0xff) << ISPPRV_CSC_OFFSET_CR_SHIFT;
+	val = (prev_csc.offset[0] & 0xff) << ISPPRV_CSC_OFFSET_Y_SHIFT;
 	val |= (prev_csc.offset[1] & 0xff) << ISPPRV_CSC_OFFSET_CB_SHIFT;
-	val |= (prev_csc.offset[2] & 0xff) << ISPPRV_CSC_OFFSET_Y_SHIFT;
-	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+	val |= (prev_csc.offset[2] & 0xff) << ISPPRV_CSC_OFFSET_CR_SHIFT;
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_PREV,
 		       ISPPRV_CSC_OFFSET);
 }
 EXPORT_SYMBOL_GPL(isppreview_config_rgb_to_ycbcr);
@@ -1300,10 +1369,10 @@ EXPORT_SYMBOL_GPL(isppreview_config_rgb_
  **/
 void isppreview_query_contrast(struct isp_prev_device *isp_prev, u8 *contrast)
 {
+	struct device *dev = to_device(isp_prev);
 	u32 brt_cnt_val = 0;
 
-	brt_cnt_val = isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
-				    ISPPRV_CNT_BRT);
+	brt_cnt_val = isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_CNT_BRT);
 	*contrast = (brt_cnt_val >> ISPPRV_CNT_BRT_CNT_SHIFT) & 0xff;
 	DPRINTK_ISPPREV(" Current brt cnt value in hw is %x\n", brt_cnt_val);
 }
@@ -1329,13 +1398,14 @@ EXPORT_SYMBOL_GPL(isppreview_update_cont
  **/
 void isppreview_config_contrast(struct isp_prev_device *isp_prev, u8 contrast)
 {
+	struct device *dev = to_device(isp_prev);
 	u32 brt_cnt_val = 0;
 
-	brt_cnt_val = isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+	brt_cnt_val = isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				    ISPPRV_CNT_BRT);
 	brt_cnt_val &= ~(0xff << ISPPRV_CNT_BRT_CNT_SHIFT);
 	contrast &= 0xff;
-	isp_reg_writel(isp_prev->dev,
+	isp_reg_writel(dev,
 		       brt_cnt_val | contrast << ISPPRV_CNT_BRT_CNT_SHIFT,
 		       OMAP3_ISP_IOMEM_PREV, ISPPRV_CNT_BRT);
 }
@@ -1372,14 +1442,15 @@ EXPORT_SYMBOL_GPL(isppreview_update_brig
 void isppreview_config_brightness(struct isp_prev_device *isp_prev,
 				  u8 brightness)
 {
+	struct device *dev = to_device(isp_prev);
 	u32 brt_cnt_val = 0;
 
 	DPRINTK_ISPPREV("\tConfiguring brightness in ISP: %d\n", brightness);
-	brt_cnt_val = isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+	brt_cnt_val = isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				    ISPPRV_CNT_BRT);
 	brt_cnt_val &= ~(0xff << ISPPRV_CNT_BRT_BRT_SHIFT);
 	brightness &= 0xff;
-	isp_reg_writel(isp_prev->dev,
+	isp_reg_writel(dev,
 		       brt_cnt_val | brightness << ISPPRV_CNT_BRT_BRT_SHIFT,
 		       OMAP3_ISP_IOMEM_PREV, ISPPRV_CNT_BRT);
 }
@@ -1392,7 +1463,9 @@ EXPORT_SYMBOL_GPL(isppreview_config_brig
 void isppreview_query_brightness(struct isp_prev_device *isp_prev,
 				 u8 *brightness)
 {
-	*brightness = isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+	struct device *dev = to_device(isp_prev);
+
+	*brightness = isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				    ISPPRV_CNT_BRT);
 }
 EXPORT_SYMBOL_GPL(isppreview_query_brightness);
@@ -1437,7 +1510,9 @@ EXPORT_SYMBOL_GPL(isppreview_get_color);
 void isppreview_config_yc_range(struct isp_prev_device *isp_prev,
 				struct ispprev_yclimit yclimit)
 {
-	isp_reg_writel(isp_prev->dev,
+	struct device *dev = to_device(isp_prev);
+
+	isp_reg_writel(dev,
 		       yclimit.maxC << ISPPRV_SETUP_YC_MAXC_SHIFT |
 		       yclimit.maxY << ISPPRV_SETUP_YC_MAXY_SHIFT |
 		       yclimit.minC << ISPPRV_SETUP_YC_MINC_SHIFT |
@@ -1456,19 +1531,15 @@ EXPORT_SYMBOL_GPL(isppreview_config_yc_r
  * Calculates the number of pixels cropped in the submodules that are enabled,
  * Fills up the output width height variables in the isp_prev structure.
  **/
-int isppreview_try_size(struct isp_prev_device *isp_prev, u32 input_w,
-			u32 input_h, u32 *output_w, u32 *output_h)
+int isppreview_try_pipeline(struct isp_prev_device *isp_prev,
+			    struct isp_pipeline *pipe)
 {
-	u32 prevout_w = input_w;
-	u32 prevout_h = input_h;
+	struct device *dev = to_device(isp_prev);
 	u32 div = 0;
 	int max_out;
 
-	isp_prev->previn_w = input_w;
-	isp_prev->previn_h = input_h;
-
-	if (input_w < 32 || input_h < 32) {
-		dev_err(isp_prev->dev, "preview does not support "
+	if (pipe->ccdc_out_w_img < 32 || pipe->ccdc_out_h < 32) {
+		dev_err(dev, "preview does not support "
 		       "width < 16 or height < 32 \n");
 		return -EINVAL;
 	}
@@ -1477,75 +1548,69 @@ int isppreview_try_size(struct isp_prev_
 	else
 		max_out = ISPPRV_MAXOUTPUT_WIDTH_ES2;
 
-	isp_prev->fmtavg = 0;
-
-	if (input_w > max_out) {
-		div = (input_w/max_out);
-		if (div >= 2 && div < 4) {
-			isp_prev->fmtavg = 1;
-			prevout_w /= 2;
-		} else if (div >= 4 && div < 8) {
-			isp_prev->fmtavg = 2;
-			prevout_w /= 4;
-		} else if (div >= 8) {
-			isp_prev->fmtavg = 3;
-			prevout_w /= 8;
-		}
-	}
-
-	if (isp_prev->hmed_en)
-		prevout_w -= 4;
-	if (isp_prev->nf_en) {
-		prevout_w -= 4;
-		prevout_h -= 4;
-	}
-	if (isp_prev->cfa_en) {
-		switch (isp_prev->cfafmt) {
-		case CFAFMT_BAYER:
-		case CFAFMT_SONYVGA:
-			prevout_w -= 4;
-			prevout_h -= 4;
-			break;
-		case CFAFMT_RGBFOVEON:
-		case CFAFMT_RRGGBBFOVEON:
-		case CFAFMT_DNSPL:
-		case CFAFMT_HONEYCOMB:
-			prevout_h -= 2;
-			break;
-		};
-	}
-	if (isp_prev->yenh_en || isp_prev->csup_en)
-		prevout_w -= 2;
+	pipe->prv_out_w = pipe->ccdc_out_w;
+	pipe->prv_out_h = pipe->ccdc_out_h;
+	pipe->prv_out_w_img = pipe->ccdc_out_w_img;
+	pipe->prv_out_h_img = pipe->ccdc_out_h;
+
+/* 	if (isp_prev->hmed_en) */
+	pipe->prv_out_w_img -= 4;
+/* 	if (isp_prev->nf_en) */
+	pipe->prv_out_w_img -= 4;
+	pipe->prv_out_h_img -= 4;
+/* 	if (isp_prev->cfa_en) */
+	switch (isp_prev->cfafmt) {
+	case CFAFMT_BAYER:
+	case CFAFMT_SONYVGA:
+		pipe->prv_out_w_img -= 4;
+		pipe->prv_out_h_img -= 4;
+		break;
+	case CFAFMT_RGBFOVEON:
+	case CFAFMT_RRGGBBFOVEON:
+	case CFAFMT_DNSPL:
+	case CFAFMT_HONEYCOMB:
+		pipe->prv_out_h_img -= 2;
+		break;
+	};
+/* 	if (isp_prev->yenh_en || isp_prev->csup_en) */
+	pipe->prv_out_w_img -= 2;
 
 	/* Start at the correct row/column by skipping
 	 * a Sensor specific amount.
 	 */
-	prevout_w -= isp_prev->sph;
-	prevout_h -= isp_prev->slv;
+	pipe->prv_out_w_img -= isp_prev->sph;
+	pipe->prv_out_h_img -= isp_prev->slv;
 
+	div = DIV_ROUND_UP(pipe->ccdc_out_w_img, max_out);
+	if (div == 1) {
+		pipe->prv_fmt_avg = 0;
+	} else if (div <= 2) {
+		pipe->prv_fmt_avg = 1;
+		pipe->prv_out_w_img /= 2;
+	} else if (div <= 4) {
+		pipe->prv_fmt_avg = 2;
+		pipe->prv_out_w_img /= 4;
+	} else if (div <= 8) {
+		pipe->prv_fmt_avg = 3;
+		pipe->prv_out_w_img /= 8;
+	} else {
+		return -EINVAL;
+	}
 
-	if (prevout_w % 2)
-		prevout_w -= 1;
+	/* output width must be even */
+	pipe->prv_out_w_img &= ~1;
+
+	/* FIXME: This doesn't apply for prv -> rsz. */
+	pipe->prv_out_w = ALIGN(pipe->prv_out_w, 0x20);
 
-	if (isp_prev->prev_outfmt == PREVIEW_MEM) {
-		if (((prevout_w * 2) & ISP_32B_BOUNDARY_OFFSET) !=
-		    (prevout_w * 2)) {
-			prevout_w = ((prevout_w * 2) &
-				     ISP_32B_BOUNDARY_OFFSET) / 2;
-		}
-	}
-	*output_w = prevout_w;
-	isp_prev->prevout_w = prevout_w;
-	*output_h = prevout_h;
-	isp_prev->prevout_h = prevout_h;
 	return 0;
 }
-EXPORT_SYMBOL_GPL(isppreview_try_size);
+EXPORT_SYMBOL_GPL(isppreview_try_pipeline);
 
 /**
  * isppreview_config_size - Sets the size of ISP preview output.
- * @input_w: input width for the preview in number of pixels per line
- * @input_h: input height for the preview in number of lines
+ * @pipe->ccdc_out_w: input width for the preview in number of pixels per line
+ * @pipe->ccdc_out_h: input height for the preview in number of lines
  * @output_w: output width from the preview in number of pixels per line
  * @output_h: output height for the preview in number of lines
  *
@@ -1553,37 +1618,36 @@ EXPORT_SYMBOL_GPL(isppreview_try_size);
  * HORZ/VERT_INFO. Configures PRV_AVE if needed for downsampling as calculated
  * in trysize.
  **/
-int isppreview_config_size(struct isp_prev_device *isp_prev, u32 input_w,
-			   u32 input_h, u32 output_w, u32 output_h)
+int isppreview_s_pipeline(struct isp_prev_device *isp_prev,
+			  struct isp_pipeline *pipe)
 {
+	struct device *dev = to_device(isp_prev);
 	u32 prevsdroff;
+	int rval;
 
-	if ((output_w != isp_prev->prevout_w) ||
-	    (output_h != isp_prev->prevout_h)) {
-		dev_err(isp_prev->dev, "preview: isppreview_try_size should "
-		       "be called before config size\n");
-		return -EINVAL;
-	}
+	rval = isppreview_config_datapath(isp_prev, pipe);
+	if (rval)
+		return rval;
 
-	isp_reg_writel(isp_prev->dev,
+	isp_reg_writel(dev,
 		       (isp_prev->sph << ISPPRV_HORZ_INFO_SPH_SHIFT) |
-		       (isp_prev->previn_w - 1),
+		       (pipe->ccdc_out_w - 1),
 		       OMAP3_ISP_IOMEM_PREV, ISPPRV_HORZ_INFO);
-	isp_reg_writel(isp_prev->dev,
+	isp_reg_writel(dev,
 		       (isp_prev->slv << ISPPRV_VERT_INFO_SLV_SHIFT) |
-		       (isp_prev->previn_h - 2),
+		       (pipe->ccdc_out_h - 2),
 		       OMAP3_ISP_IOMEM_PREV, ISPPRV_VERT_INFO);
 
 	if (isp_prev->cfafmt == CFAFMT_BAYER)
-		isp_reg_writel(isp_prev->dev, ISPPRV_AVE_EVENDIST_2 <<
+		isp_reg_writel(dev, ISPPRV_AVE_EVENDIST_2 <<
 			       ISPPRV_AVE_EVENDIST_SHIFT |
 			       ISPPRV_AVE_ODDDIST_2 <<
 			       ISPPRV_AVE_ODDDIST_SHIFT |
-			       isp_prev->fmtavg,
+			       pipe->prv_fmt_avg,
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_AVE);
 
-	if (isp_prev->prev_outfmt == PREVIEW_MEM) {
-		prevsdroff = isp_prev->prevout_w * 2;
+	if (pipe->prv_out == PREVIEW_MEM) {
+		prevsdroff = pipe->prv_out_w * ISP_BYTES_PER_PIXEL;
 		if ((prevsdroff & ISP_32B_BOUNDARY_OFFSET) != prevsdroff) {
 			DPRINTK_ISPPREV("ISP_WARN: Preview output buffer line"
 					" size is truncated"
@@ -1592,9 +1656,15 @@ int isppreview_config_size(struct isp_pr
 		}
 		isppreview_config_outlineoffset(isp_prev, prevsdroff);
 	}
+
+	if (pipe->pix.pixelformat == V4L2_PIX_FMT_UYVY)
+		isppreview_config_ycpos(isp_prev, YCPOS_YCrYCb);
+	else
+		isppreview_config_ycpos(isp_prev, YCPOS_CrYCbY);
+
 	return 0;
 }
-EXPORT_SYMBOL_GPL(isppreview_config_size);
+EXPORT_SYMBOL_GPL(isppreview_s_pipeline);
 
 /**
  * isppreview_config_inlineoffset - Configures the Read address line offset.
@@ -1602,11 +1672,13 @@ EXPORT_SYMBOL_GPL(isppreview_config_size
  **/
 int isppreview_config_inlineoffset(struct isp_prev_device *isp_prev, u32 offset)
 {
+	struct device *dev = to_device(isp_prev);
+
 	if ((offset & ISP_32B_BOUNDARY_OFFSET) == offset) {
-		isp_reg_writel(isp_prev->dev, offset & 0xffff,
+		isp_reg_writel(dev, offset & 0xffff,
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_RADR_OFFSET);
 	} else {
-		dev_err(isp_prev->dev, "preview: Offset should be in 32 byte "
+		dev_err(dev, "preview: Offset should be in 32 byte "
 		       "boundary\n");
 		return -EINVAL;
 	}
@@ -1622,11 +1694,13 @@ EXPORT_SYMBOL_GPL(isppreview_config_inli
  **/
 int isppreview_set_inaddr(struct isp_prev_device *isp_prev, u32 addr)
 {
+	struct device *dev = to_device(isp_prev);
+
 	if ((addr & ISP_32B_BOUNDARY_BUF) == addr)
-		isp_reg_writel(isp_prev->dev, addr,
+		isp_reg_writel(dev, addr,
 			       OMAP3_ISP_IOMEM_PREV, ISPPRV_RSDR_ADDR);
 	else {
-		dev_err(isp_prev->dev, "preview: Address should be in 32 byte "
+		dev_err(dev, "preview: Address should be in 32 byte "
 		       "boundary\n");
 		return -EINVAL;
 	}
@@ -1641,12 +1715,14 @@ EXPORT_SYMBOL_GPL(isppreview_set_inaddr)
 int isppreview_config_outlineoffset(struct isp_prev_device *isp_prev,
 				    u32 offset)
 {
+	struct device *dev = to_device(isp_prev);
+
 	if ((offset & ISP_32B_BOUNDARY_OFFSET) != offset) {
-		dev_err(isp_prev->dev, "preview: Offset should be in 32 byte "
+		dev_err(dev, "preview: Offset should be in 32 byte "
 		       "boundary\n");
 		return -EINVAL;
 	}
-	isp_reg_writel(isp_prev->dev, offset & 0xffff, OMAP3_ISP_IOMEM_PREV,
+	isp_reg_writel(dev, offset & 0xffff, OMAP3_ISP_IOMEM_PREV,
 		       ISPPRV_WADD_OFFSET);
 	return 0;
 }
@@ -1660,12 +1736,14 @@ EXPORT_SYMBOL_GPL(isppreview_config_outl
  **/
 int isppreview_set_outaddr(struct isp_prev_device *isp_prev, u32 addr)
 {
+	struct device *dev = to_device(isp_prev);
+
 	if ((addr & ISP_32B_BOUNDARY_BUF) != addr) {
-		dev_err(isp_prev->dev, "preview: Address should be in 32 byte "
+		dev_err(dev, "preview: Address should be in 32 byte "
 		       "boundary\n");
 		return -EINVAL;
 	}
-	isp_reg_writel(isp_prev->dev, addr, OMAP3_ISP_IOMEM_PREV,
+	isp_reg_writel(dev, addr, OMAP3_ISP_IOMEM_PREV,
 		       ISPPRV_WSDR_ADDR);
 	return 0;
 }
@@ -1678,12 +1756,14 @@ EXPORT_SYMBOL_GPL(isppreview_set_outaddr
 int isppreview_config_darklineoffset(struct isp_prev_device *isp_prev,
 				     u32 offset)
 {
+	struct device *dev = to_device(isp_prev);
+
 	if ((offset & ISP_32B_BOUNDARY_OFFSET) != offset) {
-		dev_err(isp_prev->dev, "preview: Offset should be in 32 byte "
+		dev_err(dev, "preview: Offset should be in 32 byte "
 		       "boundary\n");
 		return -EINVAL;
 	}
-	isp_reg_writel(isp_prev->dev, offset & 0xffff, OMAP3_ISP_IOMEM_PREV,
+	isp_reg_writel(dev, offset & 0xffff, OMAP3_ISP_IOMEM_PREV,
 		       ISPPRV_DRKF_OFFSET);
 	return 0;
 }
@@ -1695,27 +1775,19 @@ EXPORT_SYMBOL_GPL(isppreview_config_dark
  **/
 int isppreview_set_darkaddr(struct isp_prev_device *isp_prev, u32 addr)
 {
+	struct device *dev = to_device(isp_prev);
+
 	if ((addr & ISP_32B_BOUNDARY_BUF) != addr) {
-		dev_err(isp_prev->dev, "preview: Address should be in 32 byte "
+		dev_err(dev, "preview: Address should be in 32 byte "
 		       "boundary\n");
 		return -EINVAL;
 	}
-	isp_reg_writel(isp_prev->dev, addr, OMAP3_ISP_IOMEM_PREV,
+	isp_reg_writel(dev, addr, OMAP3_ISP_IOMEM_PREV,
 		       ISPPRV_DSDR_ADDR);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(isppreview_set_darkaddr);
 
-void __isppreview_enable(struct isp_prev_device *isp_prev, int enable)
-{
-	if (enable)
-		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
-			   ISPPRV_PCR_EN);
-	else
-		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
-			    ~ISPPRV_PCR_EN);
-}
-
 /**
  * isppreview_enable - Enables the Preview module.
  * @enable: 1 - Enables the preview module.
@@ -1724,58 +1796,38 @@ void __isppreview_enable(struct isp_prev
  **/
 void isppreview_enable(struct isp_prev_device *isp_prev, int enable)
 {
-	__isppreview_enable(isp_prev, enable);
-	isp_prev->pm_state = enable;
-}
-EXPORT_SYMBOL_GPL(isppreview_enable);
-
-/**
- * isppreview_suspend - Suspend Preview module.
- **/
-void isppreview_suspend(struct isp_prev_device *isp_prev)
-{
-	if (isp_prev->pm_state)
-		__isppreview_enable(isp_prev, 0);
-}
-EXPORT_SYMBOL_GPL(isppreview_suspend);
+	struct device *dev = to_device(isp_prev);
 
-/**
- * isppreview_resume - Resume Preview module.
- **/
-void isppreview_resume(struct isp_prev_device *isp_prev)
-{
-	if (isp_prev->pm_state)
-		__isppreview_enable(isp_prev, 1);
+	if (enable)
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			   ISPPRV_PCR_EN | ISPPRV_PCR_ONESHOT);
+	else
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			    ~(ISPPRV_PCR_EN | ISPPRV_PCR_ONESHOT));
 }
-EXPORT_SYMBOL_GPL(isppreview_resume);
-
+EXPORT_SYMBOL_GPL(isppreview_enable);
 
 /**
  * isppreview_busy - Gets busy state of preview module.
  **/
 int isppreview_busy(struct isp_prev_device *isp_prev)
 {
-	return isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR)
+	struct device *dev = to_device(isp_prev);
+
+	return isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR)
 		& ISPPRV_PCR_BUSY;
 }
 EXPORT_SYMBOL_GPL(isppreview_busy);
 
 /**
- * isppreview_get_config - Gets parameters of preview module.
- **/
-struct prev_params *isppreview_get_config(struct isp_prev_device *isp_prev)
-{
-	return isp_prev->prev_params;
-}
-EXPORT_SYMBOL_GPL(isppreview_get_config);
-
-/**
  * isppreview_save_context - Saves the values of the preview module registers.
  **/
 void isppreview_save_context(struct device *dev)
 {
 	DPRINTK_ISPPREV("Saving context\n");
 	isp_save_context(dev, ispprev_reg_list);
+	/* Avoid unwanted enabling when restoring the context. */
+	ispprev_reg_list[0].val &= ~ISPPRV_PCR_EN;
 }
 EXPORT_SYMBOL_GPL(isppreview_save_context);
 
@@ -1794,12 +1846,15 @@ EXPORT_SYMBOL_GPL(isppreview_restore_con
  *
  * Also prints other debug information stored in the preview moduel.
  **/
-void isppreview_print_status(struct isp_prev_device *isp_prev)
+void isppreview_print_status(struct isp_prev_device *isp_prev,
+			     struct isp_pipeline *pipe)
 {
-	DPRINTK_ISPPREV("Module in use =%d\n", isp_prev->prev_inuse);
+#ifdef OMAP_ISPPREV_DEBUG
+	struct device *dev = to_device(isp_prev);
+#endif
+
 	DPRINTK_ISPPREV("Preview Input format =%d, Output Format =%d\n",
-			isp_prev->prev_inpfmt,
-			isp_prev->prev_outfmt);
+			pipe->prv_inp, pipe->prv_out);
 	DPRINTK_ISPPREV("Accepted Preview Input (width = %d,Height = %d)\n",
 			isp_prev->previn_w,
 			isp_prev->previn_h);
@@ -1807,94 +1862,94 @@ void isppreview_print_status(struct isp_
 			isp_prev->prevout_w,
 			isp_prev->prevout_h);
 	DPRINTK_ISPPREV("###ISP_CTRL in preview =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_MAIN,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
 				      ISP_CTRL));
 	DPRINTK_ISPPREV("###ISP_IRQ0ENABLE in preview =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_MAIN,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
 				      ISP_IRQ0ENABLE));
 	DPRINTK_ISPPREV("###ISP_IRQ0STATUS in preview =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_MAIN,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
 				      ISP_IRQ0STATUS));
 	DPRINTK_ISPPREV("###PRV PCR =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_PCR));
 	DPRINTK_ISPPREV("###PRV HORZ_INFO =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_HORZ_INFO));
 	DPRINTK_ISPPREV("###PRV VERT_INFO =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_VERT_INFO));
 	DPRINTK_ISPPREV("###PRV WSDR_ADDR =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_WSDR_ADDR));
 	DPRINTK_ISPPREV("###PRV WADD_OFFSET =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_WADD_OFFSET));
 	DPRINTK_ISPPREV("###PRV AVE =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_AVE));
 	DPRINTK_ISPPREV("###PRV HMED =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_HMED));
 	DPRINTK_ISPPREV("###PRV NF =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_NF));
 	DPRINTK_ISPPREV("###PRV WB_DGAIN =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_WB_DGAIN));
 	DPRINTK_ISPPREV("###PRV WBGAIN =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_WBGAIN));
 	DPRINTK_ISPPREV("###PRV WBSEL =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_WBSEL));
 	DPRINTK_ISPPREV("###PRV CFA =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_CFA));
 	DPRINTK_ISPPREV("###PRV BLKADJOFF =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_BLKADJOFF));
 	DPRINTK_ISPPREV("###PRV RGB_MAT1 =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_RGB_MAT1));
 	DPRINTK_ISPPREV("###PRV RGB_MAT2 =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_RGB_MAT2));
 	DPRINTK_ISPPREV("###PRV RGB_MAT3 =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_RGB_MAT3));
 	DPRINTK_ISPPREV("###PRV RGB_MAT4 =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_RGB_MAT4));
 	DPRINTK_ISPPREV("###PRV RGB_MAT5 =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_RGB_MAT5));
 	DPRINTK_ISPPREV("###PRV RGB_OFF1 =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_RGB_OFF1));
 	DPRINTK_ISPPREV("###PRV RGB_OFF2 =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_RGB_OFF2));
 	DPRINTK_ISPPREV("###PRV CSC0 =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_CSC0));
 	DPRINTK_ISPPREV("###PRV CSC1 =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_CSC1));
 	DPRINTK_ISPPREV("###PRV CSC2 =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_CSC2));
 	DPRINTK_ISPPREV("###PRV CSC_OFFSET =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_CSC_OFFSET));
 	DPRINTK_ISPPREV("###PRV CNT_BRT =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_CNT_BRT));
 	DPRINTK_ISPPREV("###PRV CSUP =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_CSUP));
 	DPRINTK_ISPPREV("###PRV SETUP_YC =0x%x\n",
-			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
 				      ISPPRV_SETUP_YC));
 }
 EXPORT_SYMBOL_GPL(isppreview_print_status);
@@ -1906,19 +1961,9 @@ int __init isp_preview_init(struct devic
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
 	struct isp_prev_device *isp_prev = &isp->isp_prev;
-	struct prev_params *params;
+	struct prev_params *params = &isp_prev->params;
 	int i = 0;
 
-	params = kmalloc(sizeof(*isp_prev->prev_params), GFP_KERNEL);
-	if (!params) {
-		dev_err(isp_prev->dev,
-			"preview: Can't get memory for isp_preview params!\n");
-		return -ENOMEM;
-	}
-	isp_prev->dev = dev;
-	isp_prev->prev_inuse = 0;
-	mutex_init(&isp_prev->ispprev_mutex);
-
 	/* Init values */
 	isp_prev->sph = 2;
 	isp_prev->slv = 0;
@@ -1929,7 +1974,6 @@ int __init isp_preview_init(struct devic
 	params->brightness = ISPPRV_BRIGHT_DEF;
 	params->average = NO_AVE;
 	params->lens_shading_shift = 0;
-	params->pix_fmt = YCPOS_YCrYCb;
 	params->cfa.cfafmt = CFAFMT_BAYER;
 	params->cfa.cfa_table = cfa_coef_table;
 	params->cfa.cfa_gradthrs_horz = FLR_CFA_GRADTHRS_HORZ;
@@ -1974,18 +2018,7 @@ int __init isp_preview_init(struct devic
 			      PREV_CHROMA_SUPPRESS |
 			      PREV_LUMA_ENHANCE);
 
-	isp_prev->prev_params = params;
-	isp_prev->params = params;
+	spin_lock_init(&isp_prev->lock);
 
 	return 0;
 }
-
-/**
- * isp_preview_cleanup - Module Cleanup.
- **/
-void isp_preview_cleanup(struct device *dev)
-{
-	struct isp_device *isp = dev_get_drvdata(dev);
-
-	kfree(isp->isp_prev.prev_params);
-}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isppreview.h kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isppreview.h
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/isppreview.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/isppreview.h	2012-12-16 13:13:01.664330147 +0100
@@ -28,14 +28,14 @@
 #define ISPPRV_BRIGHT_STEP		0x1
 #define ISPPRV_BRIGHT_DEF		0x0
 #define ISPPRV_BRIGHT_LOW		0x0
-#define ISPPRV_BRIGHT_HIGH		0xF
-#define ISPPRV_BRIGHT_UNITS		0x7
+#define ISPPRV_BRIGHT_HIGH		0xFF
+#define ISPPRV_BRIGHT_UNITS		0x1
 
 #define ISPPRV_CONTRAST_STEP		0x1
-#define ISPPRV_CONTRAST_DEF		0x4
+#define ISPPRV_CONTRAST_DEF		0x10
 #define ISPPRV_CONTRAST_LOW		0x0
-#define ISPPRV_CONTRAST_HIGH		0xF
-#define ISPPRV_CONTRAST_UNITS		0x4
+#define ISPPRV_CONTRAST_HIGH		0xFF
+#define ISPPRV_CONTRAST_UNITS		0x1
 
 #define NO_AVE				0x0
 #define AVE_2_PIX			0x1
@@ -162,7 +162,6 @@ struct prev_darkfrm_params {
 /**
  * struct prev_params - Structure for all configuration
  * @features: Set of features enabled.
- * @pix_fmt: Output pixel format.
  * @cfa: CFA coefficients.
  * @csup: Chroma suppression coefficients.
  * @ytable: Pointer to Luma enhancement coefficients.
@@ -212,6 +211,8 @@ struct prev_params {
  * @red_gamma: Pointer to red gamma correction table.
  * @green_gamma: Pointer to green gamma correction table.
  * @blue_gamma: Pointer to blue gamma correction table.
+ * @prev_cfa: Pointer to color filter array configuration.
+ * @prev_wbal: Pointer to colour and digital gain configuration.
  */
 struct isptables_update {
 	u16 update;
@@ -221,11 +222,12 @@ struct isptables_update {
 	u32 *red_gamma;
 	u32 *green_gamma;
 	u32 *blue_gamma;
+	struct ispprev_cfa *prev_cfa;
+	struct ispprev_wbal *prev_wbal;
 };
 
 /**
  * struct isp_prev_device - Structure for storing ISP Preview module information
- * @prev_inuse: Flag to determine if CCDC has been reserved or not (0 or 1).
  * @prevout_w: Preview output width.
  * @prevout_h: Preview output height.
  * @previn_w: Preview input width.
@@ -244,21 +246,14 @@ struct isptables_update {
  * @contrast: Contrast in preview module.
  * @color: Color effect in preview module.
  * @cfafmt: Color Filter Array (CFA) Format.
- * @ispprev_mutex: Mutex for isp preview.
+ * @wbal_update: Update digital and colour gains in Previewer
  *
  * This structure is used to store the OMAP ISP Preview module Information.
  */
 struct isp_prev_device {
-	int pm_state;
-	u8 prev_inuse;
-	u32 prevout_w;
-	u32 prevout_h;
-	u32 previn_w;
-	u32 previn_h;
-	enum preview_input prev_inpfmt;
-	enum preview_output prev_outfmt;
 	u8 update_color_matrix;
 	u8 update_rgb_blending;
+	u8 update_rgb_to_ycbcr;
 	u8 hmed_en;
 	u8 nf_en;
 	u8 dcor_en;
@@ -268,20 +263,21 @@ struct isp_prev_device {
 	u8 rg_update;
 	u8 gg_update;
 	u8 bg_update;
+	u8 cfa_update;
 	u8 nf_enable;
 	u8 nf_update;
+	u8 wbal_update;
 	u8 fmtavg;
 	u8 brightness;
 	u8 contrast;
 	enum v4l2_colorfx color;
 	enum cfa_fmt cfafmt;
-	struct mutex ispprev_mutex; /* For checking/modifying prev_inuse */
 	struct ispprev_nf prev_nf_t;
-	struct prev_params *prev_params;
-	struct prev_params *params;
+	struct prev_params params;
+	int shadow_update;
 	u32 sph;
 	u32 slv;
-	struct device *dev;
+	spinlock_t lock;
 };
 
 void isppreview_config_shadow_registers(struct isp_prev_device *isp_prev);
@@ -291,8 +287,7 @@ int isppreview_request(struct isp_prev_d
 int isppreview_free(struct isp_prev_device *isp_prev);
 
 int isppreview_config_datapath(struct isp_prev_device *isp_prev,
-			       enum preview_input input,
-			       enum preview_output output);
+			       struct isp_pipeline *pipe);
 
 void isppreview_config_ycpos(struct isp_prev_device *isp_prev,
 			     enum preview_ycpos_mode mode);
@@ -327,7 +322,7 @@ void isppreview_config_dcor(struct isp_p
 
 
 void isppreview_config_cfa(struct isp_prev_device *isp_prev,
-			   struct ispprev_cfa);
+			   struct ispprev_cfa *cfa);
 
 void isppreview_config_gammacorrn(struct isp_prev_device *isp_prev,
 				  struct ispprev_gtable);
@@ -384,11 +379,11 @@ void isppreview_query_brightness(struct
 void isppreview_config_yc_range(struct isp_prev_device *isp_prev,
 				struct ispprev_yclimit yclimit);
 
-int isppreview_try_size(struct isp_prev_device *isp_prev, u32 input_w,
-			u32 input_h, u32 *output_w, u32 *output_h);
+int isppreview_try_pipeline(struct isp_prev_device *isp_prev,
+			    struct isp_pipeline *pipe);
 
-int isppreview_config_size(struct isp_prev_device *isp_prev, u32 input_w,
-			   u32 input_h, u32 output_w, u32 output_h);
+int isppreview_s_pipeline(struct isp_prev_device *isp_prev,
+			  struct isp_pipeline *pipe);
 
 int isppreview_config_inlineoffset(struct isp_prev_device *isp_prev,
 				   u32 offset);
@@ -407,15 +402,10 @@ int isppreview_set_darkaddr(struct isp_p
 
 void isppreview_enable(struct isp_prev_device *isp_prev, int enable);
 
-void isppreview_suspend(struct isp_prev_device *isp_prev);
-
-void isppreview_resume(struct isp_prev_device *isp_prev);
-
 int isppreview_busy(struct isp_prev_device *isp_prev);
 
-struct prev_params *isppreview_get_config(struct isp_prev_device *isp_prev);
-
-void isppreview_print_status(struct isp_prev_device *isp_prev);
+void isppreview_print_status(struct isp_prev_device *isp_prev,
+			     struct isp_pipeline *pipe);
 
 #ifndef CONFIG_ARCH_OMAP3410
 void isppreview_save_context(struct device *dev);
@@ -432,9 +422,6 @@ static inline void isppreview_restore_co
 int omap34xx_isp_preview_config(struct isp_prev_device *isp_prev,
 				void *userspace_add);
 
-int omap34xx_isp_tables_update(struct isp_prev_device *isp_prev,
-			       struct isptables_update *isptables_struct);
-
 void isppreview_set_skip(struct isp_prev_device *isp_prev, u32 h, u32 v);
 
 #endif/* OMAP_ISP_PREVIEW_H */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispreg.h kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispreg.h
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispreg.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispreg.h	2012-12-16 13:13:01.668330147 +0100
@@ -116,7 +116,7 @@
 #define ISP_32B_BOUNDARY_BUF		0xFFFFFFE0
 #define ISP_32B_BOUNDARY_OFFSET		0x0000FFE0
 
-#define CM_CAM_MCLK_HZ			216000000
+#define CM_CAM_MCLK_HZ			172800000	/* Hz */
 
 /* ISP Submodules offset */
 
@@ -209,6 +209,18 @@
 #define ISPCSI1_SYSSTATUS		(0x008)
 #define ISPCSI1_LC01_IRQENABLE		(0x00C)
 #define ISPCSI1_LC01_IRQSTATUS		(0x010)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_FS_IRQ	(1 << 11)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_LE_IRQ	(1 << 10)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_LS_IRQ	(1 << 9)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_FE_IRQ	(1 << 8)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_COUNT_IRQ	(1 << 7)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_FIFO_OVF_IRQ	(1 << 5)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_CRC_IRQ	(1 << 4)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_FSP_IRQ	(1 << 3)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_FW_IRQ	(1 << 2)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_FSC_IRQ	(1 << 1)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_SSC_IRQ	(1 << 0)
+
 #define ISPCSI1_LC23_IRQENABLE		(0x014)
 #define ISPCSI1_LC23_IRQSTATUS		(0x018)
 #define ISPCSI1_LCM_IRQENABLE		(0x02C)
@@ -323,6 +335,14 @@
 #define ISPSBL_CCDC_WR_2		(0x030)
 #define ISPSBL_CCDC_WR_3		(0x034)
 
+#define ISPSBL_SDR_REQ_EXP		0xF8
+#define ISPSBL_SDR_REQ_HIST_EXP_SHIFT	0
+#define ISPSBL_SDR_REQ_HIST_EXP_MASK	(0x3FF)
+#define ISPSBL_SDR_REQ_RSZ_EXP_SHIFT	10
+#define ISPSBL_SDR_REQ_RSZ_EXP_MASK	(0x3FF << ISPSBL_SDR_REQ_RSZ_EXP_SHIFT)
+#define ISPSBL_SDR_REQ_PRV_EXP_SHIFT	20
+#define ISPSBL_SDR_REQ_PRV_EXP_MASK	(0x3FF << ISPSBL_SDR_REQ_PRV_EXP_SHIFT)
+
 /* Histogram registers */
 #define ISPHIST_PID			(0x000)
 #define ISPHIST_PCR			(0x004)
@@ -636,7 +656,7 @@
 /* Define bit fields within selected registers */
 #define ISP_REVISION_SHIFT			0
 
-#define ISP_SYSCONFIG_AUTOIDLE			0
+#define ISP_SYSCONFIG_AUTOIDLE			(1 << 0)
 #define ISP_SYSCONFIG_SOFTRESET			(1 << 1)
 #define ISP_SYSCONFIG_MIDLEMODE_SHIFT		12
 #define ISP_SYSCONFIG_MIDLEMODE_FORCESTANDBY	0x0
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispresizer.c kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispresizer.c
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispresizer.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispresizer.c	2012-12-16 13:13:01.668330147 +0100
@@ -29,14 +29,14 @@
 /* Default configuration of resizer,filter coefficients,yenh for camera isp */
 static struct isprsz_coef ispreszdefcoef = {
 	{
-		0x0027, 0x00B2, 0x00B2, 0x0027,
-		0x0027, 0x00B2, 0x0027, 0x00B2,
-		0x0027, 0x00B2, 0x0027, 0x00B2,
-		0x0027, 0x00B2, 0x0027, 0x00B2,
-		0x0027, 0x00B2, 0x0027, 0x00B2,
-		0x0027, 0x00B2, 0x0027, 0x00B2,
-		0x0027, 0x00B2, 0x0027, 0x00B2,
-		0x0027, 0x00B2, 0x0027, 0x00B2,
+		0x0000, 0x0100, 0x0000, 0x0000,
+		0x03FA, 0x00F6, 0x0010, 0x0000,
+		0x03F9, 0x00DB, 0x002C, 0x0000,
+		0x03FB, 0x00B3, 0x0053, 0x03FF,
+		0x03FD, 0x0082, 0x0084, 0x03FD,
+		0x03FF, 0x0053, 0x00B3, 0x03FB,
+		0x0000, 0x002C, 0x00DB, 0x03F9,
+		0x0000, 0x0010, 0x00F6, 0x03FA
 	},
 	{
 		0x0000, 0x0100, 0x0000, 0x0000,
@@ -49,13 +49,13 @@ static struct isprsz_coef ispreszdefcoef
 		0x0000, 0x0010, 0x00F6, 0x03FA
 	},
 	{
-		0x0004, 0x0023, 0x0023, 0x005A,
-		0x005A, 0x0058, 0x0058, 0x0004,
-		0x0023, 0x0023, 0x005A, 0x005A,
-		0x0058, 0x0058, 0x0004, 0x0023,
-		0x0023, 0x005A, 0x005A, 0x0058,
-		0x0058, 0x0004, 0x0023, 0x0023,
-		0x005A, 0x005A, 0x0058, 0x0058
+		0x0004, 0x0023, 0x005A, 0x0058,
+		0x0023, 0x0004, 0x0000, 0x0002,
+		0x0018, 0x004d, 0x0060, 0x0031,
+		0x0008, 0x0000, 0x0001, 0x000f,
+		0x003f, 0x0062, 0x003f, 0x000f,
+		0x0001, 0x0000, 0x0008, 0x0031,
+		0x0060, 0x004d, 0x0018, 0x0002
 	},
 	{
 		0x0004, 0x0023, 0x005A, 0x0058,
@@ -115,62 +115,38 @@ static struct isp_reg isprsz_reg_list[]
 };
 
 /**
- * ispresizer_config_shadow_registers - Configure shadow registers.
- **/
-void ispresizer_config_shadow_registers(struct isp_res_device *isp_res)
-{
-	return;
-}
-EXPORT_SYMBOL(ispresizer_config_shadow_registers);
-
-/**
- * ispresizer_trycrop - Validate crop dimensions.
- * @left: Left distance to start position of crop.
- * @top: Top distance to start position of crop.
- * @width: Width of input image.
- * @height: Height of input image.
- * @ow: Width of output image.
- * @oh: Height of output image.
- **/
-void ispresizer_trycrop(struct isp_res_device *isp_res, u32 left, u32 top,
-			    u32 width, u32 height, u32 ow, u32 oh)
-{
-	isp_res->cropwidth = width + 6;
-	isp_res->cropheight = height + 6;
-	ispresizer_try_size(isp_res, &isp_res->cropwidth, &isp_res->cropheight,
-			    &ow, &oh);
-	isp_res->ipht_crop = top;
-	isp_res->ipwd_crop = left;
-}
-EXPORT_SYMBOL(ispresizer_trycrop);
-
-/**
  * ispresizer_applycrop - Apply crop to input image.
  **/
 void ispresizer_applycrop(struct isp_res_device *isp_res)
 {
+	struct isp_device *isp = to_isp_device(isp_res);
+
 	if (!isp_res->applycrop)
 		return;
 
-	ispresizer_config_size(isp_res, isp_res->cropwidth, isp_res->cropheight,
-			       isp_res->outputwidth,
-			       isp_res->outputheight);
+	ispresizer_s_pipeline(isp_res, &isp->pipeline);
 
 	isp_res->applycrop = 0;
 
 	return;
 }
-EXPORT_SYMBOL(ispresizer_applycrop);
 
-void ispresizer_config_crop(struct isp_res_device *isp_res,
-			    struct v4l2_crop *a)
+/**
+ * ispresizer_config_shadow_registers - Configure shadow registers.
+ **/
+void ispresizer_config_shadow_registers(struct isp_res_device *isp_res)
 {
-	struct isp_device *isp =
-		container_of(isp_res, struct isp_device, isp_res);
-	struct v4l2_crop *crop = a;
+	ispresizer_applycrop(isp_res);
 
-	crop->c.left &= ~0xf;
-	crop->c.width &= ~0xf;
+	return;
+}
+
+int ispresizer_config_crop(struct isp_res_device *isp_res,
+			   struct v4l2_crop *a)
+{
+	struct isp_device *isp = to_isp_device(isp_res);
+	struct v4l2_crop *crop = a;
+	int rval;
 
 	if (crop->c.left < 0)
 		crop->c.left = 0;
@@ -181,37 +157,38 @@ void ispresizer_config_crop(struct isp_r
 	if (crop->c.height < 0)
 		crop->c.height = 0;
 
-	if (crop->c.left >= isp->module.preview_output_width)
-		crop->c.left = isp->module.preview_output_width - 1;
-	if (crop->c.top >= isp->module.preview_output_height)
-		crop->c.top = isp->module.preview_output_height - 1;
-
-	if (crop->c.left + crop->c.width > isp->module.preview_output_width)
-		crop->c.width = isp->module.preview_output_width - crop->c.left;
-	if (crop->c.top + crop->c.height > isp->module.preview_output_height)
-		crop->c.height =
-			isp->module.preview_output_height - crop->c.top;
-
-	isp_res->croprect.left = crop->c.left;
-	isp_res->croprect.top = crop->c.top;
-	isp_res->croprect.width = crop->c.width;
-	isp_res->croprect.height = crop->c.height;
-
-	ispresizer_trycrop(isp_res,
-			   isp_res->croprect.left, isp_res->croprect.top,
-			   isp_res->croprect.width, isp_res->croprect.height,
-			   isp->module.resizer_output_width,
-			   isp->module.resizer_output_height);
+	if (crop->c.left >= isp->pipeline.prv_out_w_img)
+		crop->c.left = isp->pipeline.prv_out_w_img - 1;
+	if (crop->c.top >= isp->pipeline.rsz_out_h)
+		crop->c.top = isp->pipeline.rsz_out_h - 1;
+
+	/* Make sure the crop rectangle is never smaller than width
+	 * and height divided by 4, since the resizer cannot upscale it
+	 * by more than 4x. */
+
+	if (crop->c.width < (isp->pipeline.rsz_out_w + 3) / 4)
+		crop->c.width = (isp->pipeline.rsz_out_w + 3) / 4;
+	if (crop->c.height < (isp->pipeline.rsz_out_h + 3) / 4)
+		crop->c.height = (isp->pipeline.rsz_out_h + 3) / 4;
+
+	if (crop->c.left + crop->c.width > isp->pipeline.prv_out_w_img)
+		crop->c.width = isp->pipeline.prv_out_w_img - crop->c.left;
+	if (crop->c.top + crop->c.height > isp->pipeline.prv_out_h_img)
+		crop->c.height = isp->pipeline.prv_out_h_img - crop->c.top;
+
+	isp->pipeline.rsz_crop = crop->c;
+
+	rval = ispresizer_try_pipeline(isp_res, &isp->pipeline);
+	if (rval)
+		return rval;
 
 	isp_res->applycrop = 1;
 
-	/* FIXME: ugly hack. */
-	if (!ispresizer_busy(isp_res))
+	if (isp->running == ISP_STOPPED)
 		ispresizer_applycrop(isp_res);
 
-	return;
+	return 0;
 }
-EXPORT_SYMBOL(ispresizer_config_crop);
 
 /**
  * ispresizer_request - Reserves the Resizer module.
@@ -222,12 +199,14 @@ EXPORT_SYMBOL(ispresizer_config_crop);
  **/
 int ispresizer_request(struct isp_res_device *isp_res)
 {
+	struct device *dev = to_device(isp_res);
+
 	mutex_lock(&isp_res->ispres_mutex);
 	if (!isp_res->res_inuse) {
 		isp_res->res_inuse = 1;
 		mutex_unlock(&isp_res->ispres_mutex);
-		isp_reg_writel(isp_res->dev,
-			       isp_reg_readl(isp_res->dev,
+		isp_reg_writel(dev,
+			       isp_reg_readl(dev,
 					     OMAP3_ISP_IOMEM_MAIN, ISP_CTRL) |
 			       ISPCTRL_SBL_WR0_RAM_EN |
 			       ISPCTRL_RSZ_CLK_EN,
@@ -235,11 +214,10 @@ int ispresizer_request(struct isp_res_de
 		return 0;
 	} else {
 		mutex_unlock(&isp_res->ispres_mutex);
-		dev_err(isp_res->dev, "resizer: Module Busy\n");
+		dev_err(dev, "resizer: Module Busy\n");
 		return -EBUSY;
 	}
 }
-EXPORT_SYMBOL(ispresizer_request);
 
 /**
  * ispresizer_free - Makes Resizer module free.
@@ -248,11 +226,13 @@ EXPORT_SYMBOL(ispresizer_request);
  **/
 int ispresizer_free(struct isp_res_device *isp_res)
 {
+	struct device *dev = to_device(isp_res);
+
 	mutex_lock(&isp_res->ispres_mutex);
 	if (isp_res->res_inuse) {
 		isp_res->res_inuse = 0;
 		mutex_unlock(&isp_res->ispres_mutex);
-		isp_reg_and(isp_res->dev, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,
 			    ~(ISPCTRL_RSZ_CLK_EN | ISPCTRL_SBL_WR0_RAM_EN));
 		return 0;
 	} else {
@@ -261,7 +241,6 @@ int ispresizer_free(struct isp_res_devic
 		return -EINVAL;
 	}
 }
-EXPORT_SYMBOL(ispresizer_free);
 
 /**
  * ispresizer_config_datapath - Specifies which input to use in resizer module
@@ -272,12 +251,14 @@ EXPORT_SYMBOL(ispresizer_free);
  * Returns 0 if successful, or -EINVAL if an unsupported input was requested.
  **/
 int ispresizer_config_datapath(struct isp_res_device *isp_res,
-			       enum ispresizer_input input)
+			       struct isp_pipeline *pipe)
 {
+	struct device *dev = to_device(isp_res);
 	u32 cnt = 0;
+
 	DPRINTK_ISPRESZ("ispresizer_config_datapath()+\n");
-	isp_res->resinput = input;
-	switch (input) {
+
+	switch (pipe->rsz_in) {
 	case RSZ_OTFLY_YUV:
 		cnt &= ~ISPRSZ_CNT_INPTYP;
 		cnt &= ~ISPRSZ_CNT_INPSRC;
@@ -293,10 +274,10 @@ int ispresizer_config_datapath(struct is
 		cnt |= ISPRSZ_CNT_INPTYP;
 		break;
 	default:
-		dev_err(isp_res->dev, "resizer: Wrong Input\n");
+		dev_err(dev, "resizer: Wrong Input\n");
 		return -EINVAL;
 	}
-	isp_reg_or(isp_res->dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT, cnt);
+	isp_reg_or(dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT, cnt);
 	ispresizer_config_ycpos(isp_res, 0);
 	ispresizer_config_filter_coef(isp_res, &ispreszdefcoef);
 	ispresizer_enable_cbilin(isp_res, 0);
@@ -304,7 +285,6 @@ int ispresizer_config_datapath(struct is
 	DPRINTK_ISPRESZ("ispresizer_config_datapath()-\n");
 	return 0;
 }
-EXPORT_SYMBOL(ispresizer_config_datapath);
 
 /**
  * ispresizer_try_size - Validates input and output images size.
@@ -312,7 +292,8 @@ EXPORT_SYMBOL(ispresizer_config_datapath
  * @input_h: input height for the resizer in number of lines
  * @output_w: output width from the resizer in number of pixels per line
  *            resizer when writing to memory needs this to be multiple of 16.
- * @output_h: output height for the resizer in number of lines, must be even.
+ * @pipe->rsz_out_h: output height for the resizer in number of lines, must be
+ *		     even.
  *
  * Calculates the horizontal and vertical resize ratio, number of pixels to
  * be cropped in the resizer module and checks the validity of various
@@ -341,34 +322,28 @@ EXPORT_SYMBOL(ispresizer_config_datapath
  * Fills up the output/input widht/height, horizontal/vertical resize ratio,
  * horizontal/vertical crop variables in the isp_res structure.
  **/
-int ispresizer_try_size(struct isp_res_device *isp_res, u32 *input_width,
-			u32 *input_height, u32 *output_w, u32 *output_h)
+int ispresizer_try_pipeline(struct isp_res_device *isp_res,
+			    struct isp_pipeline *pipe)
 {
 	u32 rsz, rsz_7, rsz_4;
 	u32 sph;
-	u32 input_w, input_h;
 	int max_in_otf, max_out_7tap;
 
-	input_w = *input_width;
-	input_h = *input_height;
-
-	if (input_w < 32 || input_h < 32) {
+	if (pipe->rsz_crop.width < 32 || pipe->rsz_crop.height < 32) {
 		DPRINTK_ISPCCDC("ISP_ERR: RESIZER cannot handle input width"
 				" less than 32 pixels or height less than"
 				" 32\n");
 		return -EINVAL;
 	}
-	input_w -= 6;
-	input_h -= 6;
 
-	if (input_h > MAX_IN_HEIGHT)
+	if (pipe->rsz_crop.height > MAX_IN_HEIGHT)
 		return -EINVAL;
 
-	if (*output_w < 16)
-		*output_w = 16;
+	if (pipe->rsz_out_w < 16)
+		pipe->rsz_out_w = 16;
 
-	if (*output_h < 2)
-		*output_h = 2;
+	if (pipe->rsz_out_h < 2)
+		pipe->rsz_out_h = 2;
 
 	if (omap_rev() == OMAP3430_REV_ES1_0) {
 		max_in_otf = MAX_IN_WIDTH_ONTHEFLY_MODE;
@@ -378,115 +353,106 @@ int ispresizer_try_size(struct isp_res_d
 		max_out_7tap = MAX_7TAP_VRSZ_OUTWIDTH_ES2;
 	}
 
-	if (isp_res->resinput == RSZ_OTFLY_YUV) {
-		if (input_w > max_in_otf)
+	if (pipe->rsz_in == RSZ_OTFLY_YUV) {
+		if (pipe->rsz_crop.width > max_in_otf)
 			return -EINVAL;
 	} else {
-		if (input_w > MAX_IN_WIDTH_MEMORY_MODE)
+		if (pipe->rsz_crop.width > MAX_IN_WIDTH_MEMORY_MODE)
 			return -EINVAL;
 	}
 
-	*output_h &= 0xfffffffe;
+	pipe->rsz_out_h &= 0xfffffffe;
 	sph = DEFAULTSTPHASE;
 
-	rsz_7 = ((input_h - 7) * 256) / (*output_h - 1);
-	rsz_4 = ((input_h - 4) * 256) / (*output_h - 1);
+	rsz_7 = ((pipe->rsz_crop.height - 7) * 256) / (pipe->rsz_out_h - 1);
+	rsz_4 = ((pipe->rsz_crop.height - 4) * 256) / (pipe->rsz_out_h - 1);
 
-	rsz = (input_h * 256) / *output_h;
+	rsz = (pipe->rsz_crop.height * 256) / pipe->rsz_out_h;
 
 	if (rsz <= MID_RESIZE_VALUE) {
 		rsz = rsz_4;
 		if (rsz < MINIMUM_RESIZE_VALUE) {
 			rsz = MINIMUM_RESIZE_VALUE;
-			*output_h = (((input_h - 4) * 256) / rsz) + 1;
-			dev_dbg(isp_res->dev,
-				"resizer: %s: using output_h %d instead\n",
-				__func__, *output_h);
+			pipe->rsz_out_h =
+				(((pipe->rsz_crop.height - 4) * 256) / rsz) + 1;
 		}
 	} else {
 		rsz = rsz_7;
-		if (*output_w > max_out_7tap)
-			*output_w = max_out_7tap;
+		if (pipe->rsz_out_w > max_out_7tap)
+			pipe->rsz_out_w = max_out_7tap;
 		if (rsz > MAXIMUM_RESIZE_VALUE) {
 			rsz = MAXIMUM_RESIZE_VALUE;
-			*output_h = (((input_h - 7) * 256) / rsz) + 1;
-			dev_dbg(isp_res->dev,
-				"resizer: %s: using output_h %d instead\n",
-				__func__, *output_h);
+			pipe->rsz_out_h =
+				(((pipe->rsz_crop.height - 7) * 256) / rsz) + 1;
 		}
 	}
 
 	if (rsz > MID_RESIZE_VALUE) {
-		input_h =
-			(((64 * sph) + ((*output_h - 1) * rsz) + 32) / 256) + 7;
-	} else {
-		input_h =
-			(((32 * sph) + ((*output_h - 1) * rsz) + 16) / 256) + 4;
+		pipe->rsz_crop.height =
+			(((64 * sph) + ((pipe->rsz_out_h - 1) * rsz) + 32)
+			 / 256) + 7;
+	} else {
+		pipe->rsz_crop.height =
+			(((32 * sph) + ((pipe->rsz_out_h - 1) * rsz) + 16)
+			 / 256) + 4;
 	}
 
-	isp_res->outputheight = *output_h;
 	isp_res->v_resz = rsz;
-	isp_res->inputheight = input_h;
-	isp_res->ipht_crop = DEFAULTSTPIXEL;
+	/* FIXME: pipe->rsz_crop.height here is the real input height! */
 	isp_res->v_startphase = sph;
 
-	*output_w &= 0xfffffff0;
+	pipe->rsz_out_w &= 0xfffffff0;
 	sph = DEFAULTSTPHASE;
 
-	rsz_7 = ((input_w - 7) * 256) / (*output_w - 1);
-	rsz_4 = ((input_w - 4) * 256) / (*output_w - 1);
+	rsz_7 = ((pipe->rsz_crop.width - 7) * 256) / (pipe->rsz_out_w - 1);
+	rsz_4 = ((pipe->rsz_crop.width - 4) * 256) / (pipe->rsz_out_w - 1);
 
-	rsz = (input_w * 256) / *output_w;
+	rsz = (pipe->rsz_crop.width * 256) / pipe->rsz_out_w;
 	if (rsz > MID_RESIZE_VALUE) {
 		rsz = rsz_7;
 		if (rsz > MAXIMUM_RESIZE_VALUE) {
 			rsz = MAXIMUM_RESIZE_VALUE;
-			*output_w = (((input_w - 7) * 256) / rsz) + 1;
-			*output_w = (*output_w + 0xf) & 0xfffffff0;
-			dev_dbg(isp_res->dev,
-				"resizer: %s: using output_w %d instead\n",
-				__func__, *output_w);
+			pipe->rsz_out_w =
+				(((pipe->rsz_crop.width - 7) * 256) / rsz) + 1;
+			pipe->rsz_out_w = (pipe->rsz_out_w + 0xf) & 0xfffffff0;
 		}
 	} else {
 		rsz = rsz_4;
 		if (rsz < MINIMUM_RESIZE_VALUE) {
 			rsz = MINIMUM_RESIZE_VALUE;
-			*output_w = (((input_w - 4) * 256) / rsz) + 1;
-			*output_w = (*output_w + 0xf) & 0xfffffff0;
-			dev_dbg(isp_res->dev,
-				"resizer: %s: using output_w %d instead\n",
-				__func__, *output_w);
+			pipe->rsz_out_w =
+				(((pipe->rsz_crop.width - 4) * 256) / rsz) + 1;
+			pipe->rsz_out_w = (pipe->rsz_out_w + 0xf) & 0xfffffff0;
 		}
 	}
 
 	/* Recalculate input based on TRM equations */
 	if (rsz > MID_RESIZE_VALUE) {
-		input_w =
-			(((64 * sph) + ((*output_w - 1) * rsz) + 32) / 256) + 7;
-	} else {
-		input_w =
-			(((32 * sph) + ((*output_w - 1) * rsz) + 16) / 256) + 7;
+		pipe->rsz_crop.width =
+			(((64 * sph) + ((pipe->rsz_out_w - 1) * rsz) + 32)
+			 / 256) + 7;
+	} else {
+		pipe->rsz_crop.width =
+			(((32 * sph) + ((pipe->rsz_out_w - 1) * rsz) + 16)
+			 / 256) + 7;
 	}
 
-	isp_res->outputwidth = *output_w;
 	isp_res->h_resz = rsz;
-	isp_res->inputwidth = input_w;
-	isp_res->ipwd_crop = DEFAULTSTPIXEL;
+	/* FIXME: pipe->rsz_crop.width here is the real input width! */
 	isp_res->h_startphase = sph;
 
-	*input_height = input_h;
-	*input_width = input_w;
+	pipe->rsz_out_w_img = pipe->rsz_out_w;
 
 	return 0;
 }
-EXPORT_SYMBOL(ispresizer_try_size);
 
 /**
  * ispresizer_config_size - Configures input and output image size.
- * @input_w: input width for the resizer in number of pixels per line.
- * @input_h: input height for the resizer in number of lines.
- * @output_w: output width from the resizer in number of pixels per line.
- * @output_h: output height for the resizer in number of lines.
+ * @pipe->rsz_crop.width: input width for the resizer in number of pixels per
+ *			  line.
+ * @pipe->rsz_crop.height: input height for the resizer in number of lines.
+ * @pipe->rsz_out_w: output width from the resizer in number of pixels per line.
+ * @pipe->rsz_out_h: output height for the resizer in number of lines.
  *
  * Configures the appropriate values stored in the isp_res structure in the
  * resizer registers.
@@ -494,44 +460,25 @@ EXPORT_SYMBOL(ispresizer_try_size);
  * Returns 0 if successful, or -EINVAL if passed values haven't been verified
  * with ispresizer_try_size() previously.
  **/
-int ispresizer_config_size(struct isp_res_device *isp_res, u32 input_w,
-			   u32 input_h, u32 output_w, u32 output_h)
+int ispresizer_s_pipeline(struct isp_res_device *isp_res,
+			  struct isp_pipeline *pipe)
 {
+	struct device *dev = to_device(isp_res);
 	int i, j;
 	u32 res;
-	DPRINTK_ISPRESZ("ispresizer_config_size()+, input_w = %d,input_h ="
-			" %d, output_w = %d, output_h"
-			" = %d,hresz = %d,vresz = %d,"
-			" hcrop = %d, vcrop = %d,"
-			" hstph = %d, vstph = %d\n",
-			isp_res->inputwidth,
-			isp_res->inputheight,
-			isp_res->outputwidth,
-			isp_res->outputheight,
-			isp_res->h_resz,
-			isp_res->v_resz,
-			isp_res->ipwd_crop,
-			isp_res->ipht_crop,
-			isp_res->h_startphase,
-			isp_res->v_startphase);
-	if ((output_w != isp_res->outputwidth)
-	    || (output_h != isp_res->outputheight)) {
-		dev_err(isp_res->dev,
-			"resizer: Output parameters passed do not match the"
-			" values calculated by the trysize passed w %d, h %d"
-			" \n", output_w , output_h);
-		return -EINVAL;
-	}
+	int rval;
+
+	rval = ispresizer_config_datapath(isp_res, pipe);
+	if (rval)
+		return rval;
 
 	/* Set Resizer input address and offset adderss */
 	ispresizer_config_inlineoffset(isp_res,
-				       isp_reg_readl(isp_res->dev,
-						     OMAP3_ISP_IOMEM_PREV,
-						     ISPPRV_WADD_OFFSET));
+				       pipe->prv_out_w * ISP_BYTES_PER_PIXEL);
 
-	res = isp_reg_readl(isp_res->dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT) &
+	res = isp_reg_readl(dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT) &
 		~(ISPRSZ_CNT_HSTPH_MASK | ISPRSZ_CNT_VSTPH_MASK);
-	isp_reg_writel(isp_res->dev, res |
+	isp_reg_writel(dev, res |
 		       (isp_res->h_startphase << ISPRSZ_CNT_HSTPH_SHIFT) |
 		       (isp_res->v_startphase << ISPRSZ_CNT_VSTPH_SHIFT),
 		       OMAP3_ISP_IOMEM_RESZ,
@@ -539,39 +486,30 @@ int ispresizer_config_size(struct isp_re
 	/* Set start address for cropping */
 	ispresizer_set_inaddr(isp_res, isp_res->tmp_buf);
 
-	isp_reg_writel(isp_res->dev,
-		(0 << ISPRSZ_IN_START_HORZ_ST_SHIFT) |
-		(0x00 << ISPRSZ_IN_START_VERT_ST_SHIFT),
-		OMAP3_ISP_IOMEM_RESZ, ISPRSZ_IN_START);
-
-	isp_reg_writel(isp_res->dev, (0x00 << ISPRSZ_IN_START_HORZ_ST_SHIFT) |
-		       (0x00 << ISPRSZ_IN_START_VERT_ST_SHIFT),
-		       OMAP3_ISP_IOMEM_RESZ,
-		       ISPRSZ_IN_START);
-
-	isp_reg_writel(isp_res->dev,
-		       (isp_res->croprect.width << ISPRSZ_IN_SIZE_HORZ_SHIFT) |
-		       (isp_res->croprect.height <<
+	isp_reg_writel(dev,
+		       (pipe->rsz_crop.width << ISPRSZ_IN_SIZE_HORZ_SHIFT) |
+		       (pipe->rsz_crop.height <<
 			ISPRSZ_IN_SIZE_VERT_SHIFT),
 		       OMAP3_ISP_IOMEM_RESZ,
 		       ISPRSZ_IN_SIZE);
 	if (!isp_res->algo) {
-		isp_reg_writel(isp_res->dev,
-			       (output_w << ISPRSZ_OUT_SIZE_HORZ_SHIFT) |
-			       (output_h << ISPRSZ_OUT_SIZE_VERT_SHIFT),
+		isp_reg_writel(dev,
+			       (pipe->rsz_out_w << ISPRSZ_OUT_SIZE_HORZ_SHIFT) |
+			       (pipe->rsz_out_h << ISPRSZ_OUT_SIZE_VERT_SHIFT),
 			       OMAP3_ISP_IOMEM_RESZ,
 			       ISPRSZ_OUT_SIZE);
 	} else {
-		isp_reg_writel(isp_res->dev,
-			       ((output_w - 4) << ISPRSZ_OUT_SIZE_HORZ_SHIFT) |
-			       (output_h << ISPRSZ_OUT_SIZE_VERT_SHIFT),
+		isp_reg_writel(dev,
+			       ((pipe->rsz_out_w - 4)
+				<< ISPRSZ_OUT_SIZE_HORZ_SHIFT) |
+			       (pipe->rsz_out_h << ISPRSZ_OUT_SIZE_VERT_SHIFT),
 			       OMAP3_ISP_IOMEM_RESZ,
 			       ISPRSZ_OUT_SIZE);
 	}
 
-	res = isp_reg_readl(isp_res->dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT) &
+	res = isp_reg_readl(dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT) &
 		~(ISPRSZ_CNT_HRSZ_MASK | ISPRSZ_CNT_VRSZ_MASK);
-	isp_reg_writel(isp_res->dev, res |
+	isp_reg_writel(dev, res |
 		       ((isp_res->h_resz - 1) << ISPRSZ_CNT_HRSZ_SHIFT) |
 		       ((isp_res->v_resz - 1) << ISPRSZ_CNT_VRSZ_SHIFT),
 		       OMAP3_ISP_IOMEM_RESZ,
@@ -579,7 +517,7 @@ int ispresizer_config_size(struct isp_re
 	if (isp_res->h_resz <= MID_RESIZE_VALUE) {
 		j = 0;
 		for (i = 0; i < 16; i++) {
-			isp_reg_writel(isp_res->dev,
+			isp_reg_writel(dev,
 				(isp_res->coeflist.h_filter_coef_4tap[j]
 				 << ISPRSZ_HFILT10_COEF0_SHIFT) |
 				(isp_res->coeflist.h_filter_coef_4tap[j + 1]
@@ -592,7 +530,7 @@ int ispresizer_config_size(struct isp_re
 		j = 0;
 		for (i = 0; i < 16; i++) {
 			if ((i + 1) % 4 == 0) {
-				isp_reg_writel(isp_res->dev,
+				isp_reg_writel(dev,
 					       (isp_res->coeflist.
 						h_filter_coef_7tap[j] <<
 						ISPRSZ_HFILT10_COEF0_SHIFT),
@@ -600,7 +538,7 @@ int ispresizer_config_size(struct isp_re
 					       ISPRSZ_HFILT10 + (i * 0x04));
 				j += 1;
 			} else {
-				isp_reg_writel(isp_res->dev,
+				isp_reg_writel(dev,
 					       (isp_res->coeflist.
 						h_filter_coef_7tap[j] <<
 						ISPRSZ_HFILT10_COEF0_SHIFT) |
@@ -616,7 +554,7 @@ int ispresizer_config_size(struct isp_re
 	if (isp_res->v_resz <= MID_RESIZE_VALUE) {
 		j = 0;
 		for (i = 0; i < 16; i++) {
-			isp_reg_writel(isp_res->dev, (isp_res->coeflist.
+			isp_reg_writel(dev, (isp_res->coeflist.
 					v_filter_coef_4tap[j] <<
 					ISPRSZ_VFILT10_COEF0_SHIFT) |
 				       (isp_res->coeflist.
@@ -630,7 +568,7 @@ int ispresizer_config_size(struct isp_re
 		j = 0;
 		for (i = 0; i < 16; i++) {
 			if ((i + 1) % 4 == 0) {
-				isp_reg_writel(isp_res->dev,
+				isp_reg_writel(dev,
 					       (isp_res->coeflist.
 						v_filter_coef_7tap[j] <<
 						ISPRSZ_VFILT10_COEF0_SHIFT),
@@ -638,7 +576,7 @@ int ispresizer_config_size(struct isp_re
 					       ISPRSZ_VFILT10 + (i * 0x04));
 				j += 1;
 			} else {
-				isp_reg_writel(isp_res->dev,
+				isp_reg_writel(dev,
 					       (isp_res->coeflist.
 						v_filter_coef_7tap[j] <<
 						ISPRSZ_VFILT10_COEF0_SHIFT) |
@@ -652,73 +590,54 @@ int ispresizer_config_size(struct isp_re
 		}
 	}
 
-	ispresizer_config_outlineoffset(isp_res, output_w*2);
+	ispresizer_config_outlineoffset(isp_res, pipe->rsz_out_w*2);
+
+	if (pipe->pix.pixelformat == V4L2_PIX_FMT_UYVY)
+		ispresizer_config_ycpos(isp_res, 0);
+	else
+		ispresizer_config_ycpos(isp_res, 1);
+
 	DPRINTK_ISPRESZ("ispresizer_config_size()-\n");
 	return 0;
 }
-EXPORT_SYMBOL(ispresizer_config_size);
 
-void __ispresizer_enable(struct isp_res_device *isp_res, int enable)
+/**
+ * ispresizer_enable - Enables the resizer module.
+ * @enable: 1 - Enable, 0 - Disable
+ *
+ * Client should configure all the sub modules in resizer before this.
+ **/
+void ispresizer_enable(struct isp_res_device *isp_res, int enable)
 {
+	struct device *dev = to_device(isp_res);
 	int val;
+
 	DPRINTK_ISPRESZ("+ispresizer_enable()+\n");
 	if (enable) {
-		val = (isp_reg_readl(isp_res->dev,
+		val = (isp_reg_readl(dev,
 				     OMAP3_ISP_IOMEM_RESZ, ISPRSZ_PCR) & 0x2) |
 			ISPRSZ_PCR_ENABLE;
 	} else {
-		val = isp_reg_readl(isp_res->dev,
+		val = isp_reg_readl(dev,
 				    OMAP3_ISP_IOMEM_RESZ, ISPRSZ_PCR) &
 			~ISPRSZ_PCR_ENABLE;
 	}
-	isp_reg_writel(isp_res->dev, val, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_PCR);
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_PCR);
 	DPRINTK_ISPRESZ("+ispresizer_enable()-\n");
 }
 
 /**
- * ispresizer_enable - Enables the resizer module.
- * @enable: 1 - Enable, 0 - Disable
- *
- * Client should configure all the sub modules in resizer before this.
- **/
-void ispresizer_enable(struct isp_res_device *isp_res, int enable)
-{
-	__ispresizer_enable(isp_res, enable);
-	isp_res->pm_state = enable;
-}
-EXPORT_SYMBOL(ispresizer_enable);
-
-/**
- * ispresizer_suspend - Suspend resizer module.
- **/
-void ispresizer_suspend(struct isp_res_device *isp_res)
-{
-	if (isp_res->pm_state)
-		__ispresizer_enable(isp_res, 0);
-}
-EXPORT_SYMBOL(ispresizer_suspend);
-
-/**
- * ispresizer_resume - Resume resizer module.
- **/
-void ispresizer_resume(struct isp_res_device *isp_res)
-{
-	if (isp_res->pm_state)
-		__ispresizer_enable(isp_res, 1);
-}
-EXPORT_SYMBOL(ispresizer_resume);
-
-/**
  * ispresizer_busy - Checks if ISP resizer is busy.
  *
  * Returns busy field from ISPRSZ_PCR register.
  **/
 int ispresizer_busy(struct isp_res_device *isp_res)
 {
-	return isp_reg_readl(isp_res->dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_PCR) &
+	struct device *dev = to_device(isp_res);
+
+	return isp_reg_readl(dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_PCR) &
 		ISPPRV_PCR_BUSY;
 }
-EXPORT_SYMBOL(ispresizer_busy);
 
 /**
  * ispresizer_config_startphase - Sets the horizontal and vertical start phase.
@@ -736,7 +655,6 @@ void ispresizer_config_startphase(struct
 	isp_res->v_startphase = vstartphase;
 	DPRINTK_ISPRESZ("ispresizer_config_startphase()-\n");
 }
-EXPORT_SYMBOL(ispresizer_config_startphase);
 
 /**
  * ispresizer_config_ycpos - Specifies if output should be in YC or CY format.
@@ -744,12 +662,13 @@ EXPORT_SYMBOL(ispresizer_config_startpha
  **/
 void ispresizer_config_ycpos(struct isp_res_device *isp_res, u8 yc)
 {
+	struct device *dev = to_device(isp_res);
+
 	DPRINTK_ISPRESZ("ispresizer_config_ycpos()+\n");
-	isp_reg_and_or(isp_res->dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,
 		       ~ISPRSZ_CNT_YCPOS, (yc ? ISPRSZ_CNT_YCPOS : 0));
 	DPRINTK_ISPRESZ("ispresizer_config_ycpos()-\n");
 }
-EXPORT_SYMBOL(ispresizer_config_ycpos);
 
 /**
  * Sets the chrominance algorithm
@@ -758,12 +677,13 @@ EXPORT_SYMBOL(ispresizer_config_ycpos);
  **/
 void ispresizer_enable_cbilin(struct isp_res_device *isp_res, u8 enable)
 {
+	struct device *dev = to_device(isp_res);
+
 	DPRINTK_ISPRESZ("ispresizer_enable_cbilin()+\n");
-	isp_reg_and_or(isp_res->dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,
 		       ~ISPRSZ_CNT_CBILIN, (enable ? ISPRSZ_CNT_CBILIN : 0));
 	DPRINTK_ISPRESZ("ispresizer_enable_cbilin()-\n");
 }
-EXPORT_SYMBOL(ispresizer_enable_cbilin);
 
 /**
  * ispresizer_config_luma_enhance - Configures luminance enhancer parameters.
@@ -773,9 +693,11 @@ EXPORT_SYMBOL(ispresizer_enable_cbilin);
 void ispresizer_config_luma_enhance(struct isp_res_device *isp_res,
 				    struct isprsz_yenh *yenh)
 {
+	struct device *dev = to_device(isp_res);
+
 	DPRINTK_ISPRESZ("ispresizer_config_luma_enhance()+\n");
 	isp_res->algo = yenh->algo;
-	isp_reg_writel(isp_res->dev, (yenh->algo << ISPRSZ_YENH_ALGO_SHIFT) |
+	isp_reg_writel(dev, (yenh->algo << ISPRSZ_YENH_ALGO_SHIFT) |
 		       (yenh->gain << ISPRSZ_YENH_GAIN_SHIFT) |
 		       (yenh->slope << ISPRSZ_YENH_SLOP_SHIFT) |
 		       (yenh->coreoffset << ISPRSZ_YENH_CORE_SHIFT),
@@ -783,7 +705,6 @@ void ispresizer_config_luma_enhance(stru
 		       ISPRSZ_YENH);
 	DPRINTK_ISPRESZ("ispresizer_config_luma_enhance()-\n");
 }
-EXPORT_SYMBOL(ispresizer_config_luma_enhance);
 
 /**
  * ispresizer_config_filter_coef - Sets filter coefficients for 4 & 7-tap mode.
@@ -811,7 +732,6 @@ void ispresizer_config_filter_coef(struc
 	}
 	DPRINTK_ISPRESZ("ispresizer_config_filter_coef()-\n");
 }
-EXPORT_SYMBOL(ispresizer_config_filter_coef);
 
 /**
  * ispresizer_config_inlineoffset - Configures the read address line offset.
@@ -821,15 +741,16 @@ EXPORT_SYMBOL(ispresizer_config_filter_c
  **/
 int ispresizer_config_inlineoffset(struct isp_res_device *isp_res, u32 offset)
 {
+	struct device *dev = to_device(isp_res);
+
 	DPRINTK_ISPRESZ("ispresizer_config_inlineoffset()+\n");
 	if (offset % 32)
 		return -EINVAL;
-	isp_reg_writel(isp_res->dev, offset << ISPRSZ_SDR_INOFF_OFFSET_SHIFT,
+	isp_reg_writel(dev, offset << ISPRSZ_SDR_INOFF_OFFSET_SHIFT,
 		       OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_INOFF);
 	DPRINTK_ISPRESZ("ispresizer_config_inlineoffset()-\n");
 	return 0;
 }
-EXPORT_SYMBOL(ispresizer_config_inlineoffset);
 
 /**
  * ispresizer_set_inaddr - Sets the memory address of the input frame.
@@ -839,23 +760,30 @@ EXPORT_SYMBOL(ispresizer_config_inlineof
  **/
 int ispresizer_set_inaddr(struct isp_res_device *isp_res, u32 addr)
 {
-	struct isp_device *isp =
-		container_of(isp_res, struct isp_device, isp_res);
+	struct device *dev = to_device(isp_res);
+	struct isp_device *isp = to_isp_device(isp_res);
 
 	DPRINTK_ISPRESZ("ispresizer_set_inaddr()+\n");
+
 	if (addr % 32)
 		return -EINVAL;
 	isp_res->tmp_buf = addr;
-	isp_reg_writel(isp_res->dev,
+	/* FIXME: is this the right place to put crop-related junk? */
+	isp_reg_writel(dev,
 		       isp_res->tmp_buf + ISP_BYTES_PER_PIXEL
-		       * (isp_res->croprect.left +
-			  isp->module.preview_output_width
-			  * isp_res->croprect.top),
+		       * ((isp->pipeline.rsz_crop.left & ~0xf) +
+			  isp->pipeline.prv_out_w
+			  * isp->pipeline.rsz_crop.top),
 		       OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_INADD);
+	/* Set the fractional part of the starting address. Needed for crop */
+	isp_reg_writel(dev, ((isp->pipeline.rsz_crop.left & 0xf) <<
+		       ISPRSZ_IN_START_HORZ_ST_SHIFT) |
+		       (0x00 << ISPRSZ_IN_START_VERT_ST_SHIFT),
+		       OMAP3_ISP_IOMEM_RESZ, ISPRSZ_IN_START);
+
 	DPRINTK_ISPRESZ("ispresizer_set_inaddr()-\n");
 	return 0;
 }
-EXPORT_SYMBOL(ispresizer_set_inaddr);
 
 /**
  * ispresizer_config_outlineoffset - Configures the write address line offset.
@@ -865,15 +793,16 @@ EXPORT_SYMBOL(ispresizer_set_inaddr);
  **/
 int ispresizer_config_outlineoffset(struct isp_res_device *isp_res, u32 offset)
 {
+	struct device *dev = to_device(isp_res);
+
 	DPRINTK_ISPRESZ("ispresizer_config_outlineoffset()+\n");
 	if (offset % 32)
 		return -EINVAL;
-	isp_reg_writel(isp_res->dev, offset << ISPRSZ_SDR_OUTOFF_OFFSET_SHIFT,
+	isp_reg_writel(dev, offset << ISPRSZ_SDR_OUTOFF_OFFSET_SHIFT,
 		       OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_OUTOFF);
 	DPRINTK_ISPRESZ("ispresizer_config_outlineoffset()-\n");
 	return 0;
 }
-EXPORT_SYMBOL(ispresizer_config_outlineoffset);
 
 /**
  * Configures the memory address to which the output frame is written.
@@ -881,15 +810,16 @@ EXPORT_SYMBOL(ispresizer_config_outlineo
  **/
 int ispresizer_set_outaddr(struct isp_res_device *isp_res, u32 addr)
 {
+	struct device *dev = to_device(isp_res);
+
 	DPRINTK_ISPRESZ("ispresizer_set_outaddr()+\n");
 	if (addr % 32)
 		return -EINVAL;
-	isp_reg_writel(isp_res->dev, addr << ISPRSZ_SDR_OUTADD_ADDR_SHIFT,
+	isp_reg_writel(dev, addr << ISPRSZ_SDR_OUTADD_ADDR_SHIFT,
 		       OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_OUTADD);
 	DPRINTK_ISPRESZ("ispresizer_set_outaddr()-\n");
 	return 0;
 }
-EXPORT_SYMBOL(ispresizer_set_outaddr);
 
 /**
  * ispresizer_save_context - Saves the values of the resizer module registers.
@@ -899,7 +829,6 @@ void ispresizer_save_context(struct devi
 	DPRINTK_ISPRESZ("Saving context\n");
 	isp_save_context(dev, isprsz_reg_list);
 }
-EXPORT_SYMBOL(ispresizer_save_context);
 
 /**
  * ispresizer_restore_context - Restores resizer module register values.
@@ -909,56 +838,58 @@ void ispresizer_restore_context(struct d
 	DPRINTK_ISPRESZ("Restoring context\n");
 	isp_restore_context(dev, isprsz_reg_list);
 }
-EXPORT_SYMBOL(ispresizer_restore_context);
 
 /**
  * ispresizer_print_status - Prints the values of the resizer module registers.
  **/
 void ispresizer_print_status(struct isp_res_device *isp_res)
 {
+#ifdef OMAP_ISPRESZ_DEBUG
+	struct device *dev = to_device(isp_res);
+#endif
+
 	if (!is_ispresz_debug_enabled())
 		return;
 	DPRINTK_ISPRESZ("###ISP_CTRL inresizer =0x%x\n",
-			isp_reg_readl(isp_res->dev,
+			isp_reg_readl(dev,
 				      OMAP3_ISP_IOMEM_MAIN, ISP_CTRL));
 	DPRINTK_ISPRESZ("###ISP_IRQ0ENABLE in resizer =0x%x\n",
-			isp_reg_readl(isp_res->dev,
+			isp_reg_readl(dev,
 				      OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE));
 	DPRINTK_ISPRESZ("###ISP_IRQ0STATUS in resizer =0x%x\n",
-			isp_reg_readl(isp_res->dev,
+			isp_reg_readl(dev,
 				      OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS));
 	DPRINTK_ISPRESZ("###RSZ PCR =0x%x\n",
-			isp_reg_readl(isp_res->dev,
+			isp_reg_readl(dev,
 				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_PCR));
 	DPRINTK_ISPRESZ("###RSZ CNT =0x%x\n",
-			isp_reg_readl(isp_res->dev,
+			isp_reg_readl(dev,
 				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT));
 	DPRINTK_ISPRESZ("###RSZ OUT SIZE =0x%x\n",
-			isp_reg_readl(isp_res->dev,
+			isp_reg_readl(dev,
 				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_OUT_SIZE));
 	DPRINTK_ISPRESZ("###RSZ IN START =0x%x\n",
-			isp_reg_readl(isp_res->dev,
+			isp_reg_readl(dev,
 				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_IN_START));
 	DPRINTK_ISPRESZ("###RSZ IN SIZE =0x%x\n",
-			isp_reg_readl(isp_res->dev,
+			isp_reg_readl(dev,
 				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_IN_SIZE));
 	DPRINTK_ISPRESZ("###RSZ SDR INADD =0x%x\n",
-			isp_reg_readl(isp_res->dev,
+			isp_reg_readl(dev,
 				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_INADD));
 	DPRINTK_ISPRESZ("###RSZ SDR INOFF =0x%x\n",
-			isp_reg_readl(isp_res->dev,
+			isp_reg_readl(dev,
 				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_INOFF));
 	DPRINTK_ISPRESZ("###RSZ SDR OUTADD =0x%x\n",
-			isp_reg_readl(isp_res->dev,
+			isp_reg_readl(dev,
 				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_OUTADD));
 	DPRINTK_ISPRESZ("###RSZ SDR OTOFF =0x%x\n",
-			isp_reg_readl(isp_res->dev,
+			isp_reg_readl(dev,
 				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_OUTOFF));
 	DPRINTK_ISPRESZ("###RSZ YENH =0x%x\n",
-			isp_reg_readl(isp_res->dev,
+			isp_reg_readl(dev,
 				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_YENH));
 }
-EXPORT_SYMBOL(ispresizer_print_status);
 
 /**
  * isp_resizer_init - Module Initialisation.
@@ -971,7 +902,6 @@ int __init isp_resizer_init(struct devic
 	struct isp_res_device *isp_res = &isp->isp_res;
 
 	mutex_init(&isp_res->ispres_mutex);
-	isp_res->dev = dev;
 
 	return 0;
 }
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispresizer.h kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispresizer.h
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispresizer.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispresizer.h	2012-12-16 13:13:01.668330147 +0100
@@ -66,7 +66,7 @@
  * 	- free()
  */
 
-enum ispresizer_input {
+enum resizer_input {
 	RSZ_OTFLY_YUV,
 	RSZ_MEM_YUV,
 	RSZ_MEM_COL8
@@ -128,40 +128,27 @@ struct isprsz_yenh {
  * @ispres_mutex: Mutex for isp resizer.
  */
 struct isp_res_device {
-	int pm_state;
 	u8 res_inuse;
 	u8 h_startphase;
 	u8 v_startphase;
 	u16 h_resz;
 	u16 v_resz;
-	u32 outputwidth;
-	u32 outputheight;
-	u32 inputwidth;
-	u32 inputheight;
 	u8 algo;
-	u32 ipht_crop;
-	u32 ipwd_crop;
-	u32 cropwidth;
-	u32 cropheight;
 	dma_addr_t tmp_buf;
-	enum ispresizer_input resinput;
 	struct isprsz_coef coeflist;
 	struct mutex ispres_mutex; /* For checking/modifying res_inuse */
 	struct isprsz_yenh defaultyenh;
-	struct device *dev;
 	int applycrop;
-	struct v4l2_rect croprect;
 };
 
+int ispresizer_config_crop(struct isp_res_device *isp_res,
+			   struct v4l2_crop *a);
 void ispresizer_config_shadow_registers(struct isp_res_device *isp_res);
 
 int ispresizer_request(struct isp_res_device *isp_res);
 
 int ispresizer_free(struct isp_res_device *isp_res);
 
-int ispresizer_config_datapath(struct isp_res_device *isp_res,
-			       enum ispresizer_input input);
-
 void ispresizer_enable_cbilin(struct isp_res_device *isp_res, u8 enable);
 
 void ispresizer_config_ycpos(struct isp_res_device *isp_res, u8 yc);
@@ -175,19 +162,11 @@ void ispresizer_config_filter_coef(struc
 void ispresizer_config_luma_enhance(struct isp_res_device *isp_res,
 				    struct isprsz_yenh *yenh);
 
-int ispresizer_try_size(struct isp_res_device *isp_res, u32 *input_w,
-			u32 *input_h, u32 *output_w, u32 *output_h);
-
-void ispresizer_applycrop(struct isp_res_device *isp_res);
-
-void ispresizer_config_crop(struct isp_res_device *isp_res,
-			    struct v4l2_crop *a);
+int ispresizer_try_pipeline(struct isp_res_device *isp_res,
+			    struct isp_pipeline *pipe);
 
-void ispresizer_trycrop(struct isp_res_device *isp_res, u32 left, u32 top,
-			u32 width, u32 height, u32 ow, u32 oh);
-
-int ispresizer_config_size(struct isp_res_device *isp_res, u32 input_w,
-			   u32 input_h, u32 output_w, u32 output_h);
+int ispresizer_s_pipeline(struct isp_res_device *isp_res,
+			  struct isp_pipeline *pipe);
 
 int ispresizer_config_inlineoffset(struct isp_res_device *isp_res, u32 offset);
 
@@ -199,10 +178,6 @@ int ispresizer_set_outaddr(struct isp_re
 
 void ispresizer_enable(struct isp_res_device *isp_res, int enable);
 
-void ispresizer_suspend(struct isp_res_device *isp_res);
-
-void ispresizer_resume(struct isp_res_device *isp_res);
-
 int ispresizer_busy(struct isp_res_device *isp_res);
 
 void ispresizer_save_context(struct device *dev);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispstat.c kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispstat.c
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispstat.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispstat.c	2012-12-16 13:13:01.668330147 +0100
@@ -0,0 +1,342 @@
+/*
+ * ispstat.c
+ *
+ * STAT module for TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *	Troy Laramy
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/uaccess.h>
+
+#include "isp.h"
+
+inline int greater_overflow(int a, int b, int limit)
+{
+	int limit2 = limit / 2;
+
+	if (b - a > limit2)
+		return 1;
+	else if (a - b > limit2)
+		return 0;
+	else
+		return a > b;
+}
+
+int ispstat_buf_queue(struct ispstat *stat)
+{
+	unsigned long flags;
+
+	if (!stat->active_buf)
+		return -1;
+
+	do_gettimeofday(&stat->active_buf->ts);
+
+	spin_lock_irqsave(&stat->lock, flags);
+
+	stat->active_buf->config_counter = stat->config_counter;
+	stat->active_buf->frame_number = stat->frame_number;
+
+	stat->frame_number++;
+	if (stat->frame_number == stat->max_frame)
+		stat->frame_number = 0;
+
+	stat->active_buf = NULL;
+
+	spin_unlock_irqrestore(&stat->lock, flags);
+
+	return 0;
+}
+
+/* Get next free buffer to write the statistics to and mark it active. */
+struct ispstat_buffer *ispstat_buf_next(struct ispstat *stat)
+{
+	unsigned long flags;
+	struct ispstat_buffer *found = NULL;
+	int i;
+
+	spin_lock_irqsave(&stat->lock, flags);
+
+	if (stat->active_buf)
+		dev_dbg(stat->dev, "%s: new buffer requested without queuing "
+				   "active one.\n", stat->tag);
+
+	for (i = 0; i < stat->nbufs; i++) {
+		struct ispstat_buffer *curr = &stat->buf[i];
+
+		/*
+		 * Don't select the buffer which is being copied to
+		 * userspace.
+		 */
+		if (curr == stat->locked_buf)
+			continue;
+
+		/* Uninitialised buffer -- pick that one over anything else. */
+		if (curr->frame_number == stat->max_frame) {
+			found = curr;
+			break;
+		}
+
+		if (!found ||
+		    !greater_overflow(curr->frame_number, found->frame_number,
+				      stat->max_frame))
+			found = curr;
+	}
+
+	stat->active_buf = found;
+
+	spin_unlock_irqrestore(&stat->lock, flags);
+
+	return found;
+}
+
+/* Get buffer to userspace. */
+static struct ispstat_buffer *ispstat_buf_find(
+	struct ispstat *stat, u32 frame_number)
+{
+	int i;
+
+	for (i = 0; i < stat->nbufs; i++) {
+		struct ispstat_buffer *curr = &stat->buf[i];
+
+		/* We cannot deal with the active buffer. */
+		if (curr == stat->active_buf)
+			continue;
+
+		/* Don't take uninitialised buffers. */
+		if (curr->frame_number == stat->max_frame)
+			continue;
+
+		/* Found correct number. */
+		if (curr->frame_number == frame_number)
+			return curr;
+	}
+
+	return NULL;
+}
+
+/**
+ * ispstat_stats_available - Check for stats available of specified frame.
+ * @aewbdata: Pointer to return AE AWB statistics data
+ *
+ * Returns 0 if successful, or -1 if statistics are unavailable.
+ **/
+struct ispstat_buffer *ispstat_buf_get(struct ispstat *stat,
+				       void __user *ptr,
+				       unsigned int frame_number)
+{
+	int rval = 0;
+	unsigned long flags;
+	struct ispstat_buffer *buf;
+
+	spin_lock_irqsave(&stat->lock, flags);
+
+	buf = ispstat_buf_find(stat, frame_number);
+	if (!buf) {
+		spin_unlock_irqrestore(&stat->lock, flags);
+		dev_dbg(stat->dev, "%s: cannot find requested buffer. "
+				"frame_number = %d\n", stat->tag, frame_number);
+		return ERR_PTR(-EBUSY);
+	}
+
+	stat->locked_buf = buf;
+
+	spin_unlock_irqrestore(&stat->lock, flags);
+
+	rval = copy_to_user((void *)ptr,
+			    buf->virt_addr,
+			    stat->buf_size);
+
+	if (rval) {
+		dev_info(stat->dev,
+			 "%s: failed copying %d bytes of stat data\n",
+			 stat->tag, rval);
+		buf = ERR_PTR(-EFAULT);
+		ispstat_buf_release(stat);
+	}
+
+	return buf;
+}
+
+void ispstat_buf_release(struct ispstat *stat)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&stat->lock, flags);
+	stat->locked_buf = NULL;
+	spin_unlock_irqrestore(&stat->lock, flags);
+}
+
+void ispstat_bufs_free(struct ispstat *stat)
+{
+	struct isp_device *isp = dev_get_drvdata(stat->dev);
+	int i;
+
+	for (i = 0; i < stat->nbufs; i++) {
+		struct ispstat_buffer *buf = &stat->buf[i];
+
+		if (!stat->dma_buf) {
+			if (!buf->iommu_addr)
+				continue;
+
+			iommu_vfree(isp->iommu, buf->iommu_addr);
+		} else {
+			if (!buf->virt_addr)
+				continue;
+
+			dma_free_coherent(stat->dev, stat->buf_alloc_size,
+					  buf->virt_addr, buf->dma_addr);
+		}
+		buf->iommu_addr = 0;
+		buf->dma_addr = 0;
+		buf->virt_addr = NULL;
+	}
+
+	stat->buf_alloc_size = 0;
+}
+
+static int ispstat_bufs_alloc_iommu(struct ispstat *stat, unsigned int size)
+{
+	struct isp_device *isp = dev_get_drvdata(stat->dev);
+	int i;
+
+	stat->buf_alloc_size = size;
+
+	for (i = 0; i < stat->nbufs; i++) {
+		struct ispstat_buffer *buf = &stat->buf[i];
+
+		WARN_ON(buf->dma_addr);
+		buf->iommu_addr = iommu_vmalloc(isp->iommu, 0, size,
+						IOMMU_FLAG);
+		if (buf->iommu_addr == 0) {
+			dev_err(stat->dev,
+				 "%s stat: Can't acquire memory for "
+				 "buffer %d\n", stat->tag, i);
+			ispstat_bufs_free(stat);
+			return -ENOMEM;
+		}
+		buf->virt_addr = da_to_va(isp->iommu, (u32)buf->iommu_addr);
+		buf->frame_number = stat->max_frame;
+	}
+	stat->dma_buf = 0;
+
+	return 0;
+}
+
+static int ispstat_bufs_alloc_dma(struct ispstat *stat, unsigned int size)
+{
+	int i;
+
+	/* dma_alloc_coherent() size is PAGE_ALIGNED */
+	size = PAGE_ALIGN(size);
+	stat->buf_alloc_size = size;
+
+	for (i = 0; i < stat->nbufs; i++) {
+		struct ispstat_buffer *buf = &stat->buf[i];
+
+		WARN_ON(buf->iommu_addr);
+		buf->virt_addr = dma_alloc_coherent(stat->dev, size,
+					&buf->dma_addr, GFP_KERNEL | GFP_DMA);
+
+		if (!buf->virt_addr || !buf->dma_addr) {
+			dev_info(stat->dev,
+				 "%s stat: Can't acquire memory for "
+				 "DMA buffer %d\n", stat->tag, i);
+			ispstat_bufs_free(stat);
+			return -ENOMEM;
+		}
+		buf->frame_number = stat->max_frame;
+	}
+	stat->dma_buf = 1;
+
+	return 0;
+}
+
+int ispstat_bufs_alloc(struct ispstat *stat,
+		       unsigned int size, int dma_buf)
+{
+	struct isp_device *isp = dev_get_drvdata(stat->dev);
+	unsigned long flags;
+	int ret = 0;
+	int i;
+
+	spin_lock_irqsave(&stat->lock, flags);
+
+	BUG_ON(stat->locked_buf != NULL);
+
+	dma_buf = dma_buf ? 1 : 0;
+
+	/* Are the old buffers big enough? */
+	if ((stat->buf_alloc_size >= size) && (stat->dma_buf == dma_buf)) {
+		for (i = 0; i < stat->nbufs; i++)
+			stat->buf[i].frame_number = stat->max_frame;
+		spin_unlock_irqrestore(&stat->lock, flags);
+		goto out;
+	}
+
+	if (isp->running != ISP_STOPPED) {
+		dev_info(stat->dev,
+			 "%s stat: trying to configure when busy\n",
+			 stat->tag);
+		spin_unlock_irqrestore(&stat->lock, flags);
+		return -EBUSY;
+	}
+
+	spin_unlock_irqrestore(&stat->lock, flags);
+
+	ispstat_bufs_free(stat);
+
+	if (dma_buf)
+		ret = ispstat_bufs_alloc_dma(stat, size);
+	else
+		ret = ispstat_bufs_alloc_iommu(stat, size);
+	if (ret)
+		size = 0;
+
+out:
+	stat->buf_size = size;
+	stat->active_buf = NULL;
+
+	return ret;
+}
+
+int ispstat_init(struct device *dev, char *tag, struct ispstat *stat,
+		 unsigned int nbufs, unsigned int max_frame)
+{
+	BUG_ON(nbufs < 2);
+	BUG_ON(max_frame < 2);
+	BUG_ON(nbufs >= max_frame);
+
+	memset(stat, 0, sizeof(*stat));
+
+	stat->buf = kcalloc(nbufs, sizeof(*stat->buf), GFP_KERNEL);
+	if (!stat->buf)
+		return -ENOMEM;
+
+	spin_lock_init(&stat->lock);
+	stat->nbufs = nbufs;
+	stat->dev = dev;
+	stat->tag = tag;
+	stat->max_frame = max_frame;
+	stat->frame_number = 1;
+
+	return 0;
+}
+
+void ispstat_free(struct ispstat *stat)
+{
+	ispstat_bufs_free(stat);
+	kfree(stat->buf);
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispstat.h kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispstat.h
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/ispstat.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/ispstat.h	2012-12-16 13:13:01.668330147 +0100
@@ -0,0 +1,69 @@
+/*
+ * ispstat.h
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Sakari Ailus <sakari.ailus@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef ISPSTAT_H
+#define ISPSTAT_H
+
+#include "isp.h"
+
+struct ispstat_buffer {
+	unsigned long iommu_addr;
+	void *virt_addr;
+	dma_addr_t dma_addr;
+	struct timeval ts;
+	u32 config_counter;
+	u32 frame_number;
+};
+
+struct ispstat {
+	spinlock_t lock;		/* Lock for this struct */
+
+	u8 dma_buf;
+	unsigned int nbufs;
+	struct ispstat_buffer *buf;
+	unsigned int buf_size;
+	unsigned int buf_alloc_size;
+	struct ispstat_buffer *active_buf;
+	struct ispstat_buffer *locked_buf;
+	unsigned int frame_number;
+	unsigned int max_frame;
+	unsigned int config_counter;
+
+	struct device *dev;
+	char *tag;		/* ispstat instantiation tag */
+};
+
+int ispstat_buf_queue(struct ispstat *stat);
+struct ispstat_buffer *ispstat_buf_next(struct ispstat *stat);
+struct ispstat_buffer *ispstat_buf_get(struct ispstat *stat,
+				       void __user *ptr,
+				       unsigned int frame_number);
+void ispstat_buf_release(struct ispstat *stat);
+void ispstat_bufs_free(struct ispstat *stat);
+int ispstat_bufs_alloc(struct ispstat *stat,
+		       unsigned int size, int dma_buf);
+int ispstat_init(struct device *dev, char *tag, struct ispstat *stat,
+		 unsigned int nbufs, unsigned int max_frame);
+void ispstat_free(struct ispstat *stat);
+
+#endif /* ISPSTAT_H */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/Makefile kernel-2.6.28-20093908+0m5/drivers/media/video/isp/Makefile
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/Makefile	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/Makefile	2012-12-16 13:13:01.668330147 +0100
@@ -5,8 +5,9 @@ isp-mod-objs += \
 	isp.o ispccdc.o
 else
 isp-mod-objs += \
-	isp.o ispccdc.o ispmmu.o \
-	isppreview.o ispresizer.o isph3a.o isphist.o isp_af.o ispcsi2.o
+	isp.o ispccdc.o \
+	isppreview.o ispresizer.o isph3a.o isphist.o isp_af.o ispcsi2.o \
+	ispstat.o
 endif
 
 obj-$(CONFIG_VIDEO_OMAP3) += isp-mod.o
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/omap_previewer_hack.c kernel-2.6.28-20093908+0m5/drivers/media/video/isp/omap_previewer_hack.c
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/omap_previewer_hack.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/omap_previewer_hack.c	2012-12-16 13:13:01.668330147 +0100
@@ -23,16 +23,66 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <media/v4l2-dev.h>
-#include <asm/cacheflush.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 
 #include "isp.h"
-#include "ispmmu.h"
 #include "ispreg.h"
-#include "omap_previewer_hack.h"
+#include "isppreview.h"
 
-#define OMAP_PREV_NAME		"omap-previewer"
+#define PREV_IOC_BASE			'P'
+#define PREV_REQBUF			_IOWR(PREV_IOC_BASE, 1,\
+						struct v4l2_requestbuffers)
+#define PREV_QUERYBUF			_IOWR(PREV_IOC_BASE, 2,\
+							struct v4l2_buffer)
+#define PREV_SET_PARAM			_IOW(PREV_IOC_BASE, 3,\
+							struct prev_params)
+#define PREV_PREVIEW			_IOR(PREV_IOC_BASE, 5, int)
+#define PREV_GET_CROPSIZE		_IOR(PREV_IOC_BASE, 7,\
+							struct prev_cropsize)
+#define PREV_QUEUEBUF			_IOWR(PREV_IOC_BASE, 8,\
+							struct v4l2_buffer)
+#define PREV_IOC_MAXNR			8
+
+#define MAX_IMAGE_WIDTH			3300
+
+#define PREV_INWIDTH_8BIT		0	/* pixel width of 8 bitS */
+#define PREV_INWIDTH_10BIT		1	/* pixel width of 10 bits */
+
+#define PREV_32BYTES_ALIGN_MASK		0xFFFFFFE0
+#define PREV_16PIX_ALIGN_MASK		0xFFFFFFF0
+
+/* list of structures */
+
+/* device structure keeps track of global information */
+struct prev_device {
+	unsigned char opened;			/* state of the device */
+	struct completion wfc;
+	struct mutex prevwrap_mutex;
+	/* spinlock for in/out videbuf queue */
+	spinlock_t inout_vbq_lock;
+	/* spinlock for lsc videobuf queues */
+	spinlock_t lsc_vbq_lock;
+	struct videobuf_queue_ops vbq_ops;	/* videobuf queue operations */
+	dma_addr_t isp_addr_read;		/* Input/Output address */
+	dma_addr_t isp_addr_lsc;  /* lsc address */
+	struct device *isp;
+	struct prev_size_params size_params;
+};
+
+/* per-filehandle data structure */
+struct prev_fh {
+	/* in/out videobuf queue */
+	enum v4l2_buf_type inout_type;
+	struct videobuf_queue inout_vbq;
+	/* lsc videobuf queue */
+	enum v4l2_buf_type lsc_type;
+	struct videobuf_queue lsc_vbq;
+	/* device structure */
+	struct prev_device *device;
+};
+
+#define OMAP_PREV_NAME		"omap-previewer" /* "omap3hack"  */
 
 #define BIT_SET(var,shift,mask,val)		\
 	do {					\
@@ -40,24 +90,18 @@
 			| (val << shift);	\
 	} while (0)
 
-#if 0
-#define OMAP_ISP_PREVIEWER_DEBUG
-#else
-#undef OMAP_ISP_PREVIEWER_DEBUG
-#endif
-
-#ifdef OMAP_ISP_PREVIEWER_DEBUG
-#define DPRINTK_PREVIEWER(format,...) \
-	printk("PREV: " format, ## __VA_ARGS__)
-#else
-	#define DPRINTK_PREVIEWER(format,...)
-#endif
 
 #define ISP_CTRL_SBL_SHARED_RPORTB	(1 << 28)
 #define ISP_CTRL_SBL_SHARED_RPORTA	(1 << 27)
 #define SBL_SHARED_RPORTB			28
 #define SBL_RD_RAM_EN				18
 
+/* structure to know crop size */
+struct prev_cropsize {
+	int hcrop;
+	int vcrop;
+};
+
 static struct isp_interface_config prevwrap_config = {
 	.ccdc_par_ser = ISP_NONE,
 	.dataline_shift = 0,
@@ -90,48 +134,21 @@ static int prev_calculate_crop(struct pr
 {
 	struct isp_device *isp = dev_get_drvdata(device->isp);
 	int ret;
+	struct isp_pipeline pipe;
 
-	dev_dbg(prev_dev, "prev_calculate_crop E\n");
-
-	if (!device || !crop) {
-		dev_err(prev_dev, "Erron in argument\n");
-		return -EINVAL;
-	}
-
-	ret = isppreview_try_size(&isp->isp_prev,
-					device->params->size_params.hsize,
-					device->params->size_params.vsize,
-					&crop->hcrop, &crop->vcrop);
+	pipe.ccdc_out_w = pipe.ccdc_out_w_img =
+		device->size_params.hsize;
+	pipe.ccdc_out_h = device->size_params.vsize;
 
-	crop->hcrop &= PREV_16PIX_ALIGN_MASK;
+	ret = isppreview_try_pipeline(&isp->isp_prev, &pipe);
 
-	dev_dbg(prev_dev, "prev_calculate_crop L\n");
+	crop->hcrop = pipe.prv_out_w;
+	crop->vcrop = pipe.prv_out_h;
 
 	return ret;
 }
 
 /**
- * prev_get_status - Get status of ISP preview module
- * @status: Structure containing the busy state.
- *
- * Checks if the ISP preview module is busy.
- *
- * Returns 0 if successful, or -EINVAL if the status parameter is invalid.
- **/
-static int prev_get_status(struct prev_status *status)
-{
-	struct prev_device *device = prevdevice;
-	struct isp_device *isp = dev_get_drvdata(device->isp);
-
-	if (!status) {
-		dev_err(prev_dev, "get_status: invalid parameter\n");
-		return -EINVAL;
-	}
-	status->hw_busy = (char)isppreview_busy(&isp->isp_prev);
-	return 0;
-}
-
-/**
  * prev_hw_setup - Stores the desired configuration in the proper HW registers
  * @config: Structure containing the desired configuration for ISP preview
  *          module.
@@ -146,8 +163,6 @@ static int prev_hw_setup(struct prev_par
 	struct isp_device *isp = dev_get_drvdata(device->isp);
 	struct isp_prev_device *isp_prev = &isp->isp_prev;
 
-	dev_dbg(prev_dev, "prev_hw_setup E\n");
-
 	if (config->features & PREV_AVERAGER)
 		isppreview_config_averager(isp_prev, config->average);
 	else
@@ -165,10 +180,6 @@ static int prev_hw_setup(struct prev_par
 		isppreview_enable_hmed(isp_prev, 0);
 
 	if (config->features & PREV_DARK_FRAME_SUBTRACT) {
-		DPRINTK_PREVIEWER("[%s] darkaddr %08x, darklineoffset %d\n", __func__,
-			config->drkf_params.addr,
-			config->drkf_params.offset);
-
 		isppreview_set_darkaddr(isp_prev, config->drkf_params.addr);
 		isppreview_config_darklineoffset(isp_prev,
 						 config->drkf_params.offset);
@@ -183,7 +194,6 @@ static int prev_hw_setup(struct prev_par
 	} else
 		isppreview_enable_shadcomp(isp_prev, 0);
 
-	dev_dbg(prev_dev, "prev_hw_setup L\n");
 	return 0;
 }
 
@@ -349,6 +359,12 @@ static void prev_unset_isp_ctrl(void)
 	isp_reg_writel(device->isp, val, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL);
 }
 
+static void isp_enable_interrupts(struct device *dev, int is_raw)
+{
+	isp_reg_writel(dev, IRQ0ENABLE_PRV_DONE_IRQ,
+		       OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE);
+}
+
 /**
  * prev_do_preview - Performs the Preview process
  * @device: Structure containing ISP preview wrapper global information
@@ -356,71 +372,65 @@ static void prev_unset_isp_ctrl(void)
  *
  * Returns 0 if successful, or -EINVAL if the sent parameters are invalid.
  **/
-static int prev_do_preview(struct prev_device *device, int *arg)
+static int prev_do_preview(struct prev_device *device)
 {
 	struct isp_device *isp = dev_get_drvdata(device->isp);
 	struct isp_prev_device *isp_prev = &isp->isp_prev;
+	struct prev_params *config = &isp_prev->params;
 	int bpp, size;
 	int ret = 0;
-	u32 out_hsize, out_vsize, out_line_offset;
+	struct isp_pipeline pipe;
 
-	dev_dbg(prev_dev, "prev_do_preview E\n");
-
-	if (!device) {
-		dev_err(prev_dev, "preview: invalid parameters\n");
-		return -EINVAL;
-	}
+	memset(&pipe, 0, sizeof(pipe));
+	pipe.pix.pixelformat = V4L2_PIX_FMT_UYVY;
 
-	prev_set_isp_ctrl(device->params->features);
+	prev_set_isp_ctrl(config->features);
 
-	if (device->params->size_params.pixsize == PREV_INWIDTH_8BIT)
+	if (device->size_params.pixsize == PREV_INWIDTH_8BIT)
 		bpp = 1;
 	else
 		bpp = 2;
 
-	size = device->params->size_params.hsize *
-			device->params->size_params.vsize * bpp;
+	size = device->size_params.hsize *
+			device->size_params.vsize * bpp;
 
-	isppreview_config_datapath(isp_prev, PRV_RAW_MEM, PREVIEW_MEM);
+	pipe.prv_in = PRV_RAW_MEM;
+	pipe.prv_out = PREVIEW_MEM;
 
 	isppreview_set_skip(isp_prev, 2, 0);
 
-	ret = isppreview_try_size(isp_prev, device->params->size_params.hsize,
-				  device->params->size_params.vsize,
-				  &out_hsize, &out_vsize);
+	pipe.ccdc_out_w = pipe.ccdc_out_w_img
+		= device->size_params.hsize;
+	pipe.ccdc_out_h = device->size_params.vsize & ~0xf;
+
+	ret = isppreview_try_pipeline(&isp->isp_prev, &pipe);
 	if (ret) {
 		dev_err(prev_dev, "ERROR while try size!\n");
 		goto out;
 	}
 
-	ret = isppreview_config_inlineoffset(isp_prev,
-					     device->params->size_params.hsize
-					     * bpp);
+	ret = isppreview_s_pipeline(isp_prev, &pipe);
 	if (ret) {
-		dev_err(prev_dev, "ERROR while config inline offset!\n");
+		dev_err(prev_dev, "ERROR while config size!\n");
 		goto out;
 	}
 
-	out_line_offset = (out_hsize * bpp) & PREV_32BYTES_ALIGN_MASK;
-
-	ret = isppreview_config_outlineoffset(isp_prev, out_line_offset);
+	ret = isppreview_config_inlineoffset(isp_prev, pipe.prv_out_w * bpp);
 	if (ret) {
-		dev_err(prev_dev, "ERROR while config outline offset!\n");
+		dev_err(prev_dev, "ERROR while config inline offset!\n");
 		goto out;
 	}
 
-	ret = isppreview_config_size(isp_prev,
-				     device->params->size_params.hsize,
-				     device->params->size_params.vsize,
-				     out_hsize, out_vsize);
+	ret = isppreview_config_outlineoffset(isp_prev,
+					      pipe.prv_out_w * bpp - 32);
 	if (ret) {
-		dev_err(prev_dev, "ERROR while config size!\n");
+		dev_err(prev_dev, "ERROR while config outline offset!\n");
 		goto out;
 	}
 
-	device->params->drkf_params.addr = device->isp_addr_lsc;
+	config->drkf_params.addr = device->isp_addr_lsc;
 
-	prev_hw_setup(device->params);
+	prev_hw_setup(config);
 
 	ret = isppreview_set_inaddr(isp_prev, device->isp_addr_read);
 	if (ret) {
@@ -440,9 +450,12 @@ static int prev_do_preview(struct prev_d
 		dev_err(prev_dev, "ERROR while setting Previewer callback!\n");
 		goto out;
 	}
-
 	isp_configure_interface(device->isp, &prevwrap_config);
 
+	isp_start(device->isp);
+
+	isp_enable_interrupts(device->isp, 0);
+
 	isppreview_enable(isp_prev, 1);
 
 	wait_for_completion_interruptible(&device->wfc);
@@ -458,11 +471,52 @@ static int prev_do_preview(struct prev_d
 
 	prev_unset_isp_ctrl();
 
-	dev_dbg(prev_dev, "prev_do_preview L\n");
+	isp_stop(device->isp);
+
 out:
 	return ret;
 }
 
+static int previewer_vb_lock_vma(struct videobuf_buffer *vb, int lock)
+{
+	unsigned long start, end;
+	struct vm_area_struct *vma;
+	int rval = 0;
+
+	if (vb->memory == V4L2_MEMORY_MMAP)
+		return 0;
+
+	end = vb->baddr + vb->bsize;
+
+	down_write(&current->mm->mmap_sem);
+	spin_lock(&current->mm->page_table_lock);
+	for (start = vb->baddr; ; ) {
+		unsigned int newflags;
+
+		vma = find_vma(current->mm, start);
+		if (!vma || vma->vm_start > start) {
+			rval = -ENOMEM;
+			goto out;
+		}
+
+		newflags = vma->vm_flags | VM_LOCKED;
+		if (!lock)
+			newflags &= ~VM_LOCKED;
+
+		vma->vm_flags = newflags;
+
+		if (vma->vm_end >= end)
+			break;
+
+		start = vma->vm_end;
+	}
+
+out:
+	spin_unlock(&current->mm->page_table_lock);
+	up_write(&current->mm->mmap_sem);
+	return rval;
+}
+
 /**
  * previewer_vbq_release - Videobuffer queue release
  * @q: Structure containing the videobuffer queue.
@@ -475,25 +529,25 @@ static void previewer_vbq_release(struct
 	struct prev_device *device = fh->device;
 
 	if (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-		ispmmu_vunmap(device->isp_addr_read);
+		ispmmu_vunmap(device->isp, device->isp_addr_read);
 		device->isp_addr_read = 0;
 		spin_lock(&device->inout_vbq_lock);
 		vb->state = VIDEOBUF_NEEDS_INIT;
 		spin_unlock(&device->inout_vbq_lock);
 	} else if (q->type == V4L2_BUF_TYPE_PRIVATE) {
-		ispmmu_vunmap(device->isp_addr_lsc);
+		ispmmu_vunmap(device->isp, device->isp_addr_lsc);
 		device->isp_addr_lsc = 0;
 		spin_lock(&device->lsc_vbq_lock);
 		vb->state = VIDEOBUF_NEEDS_INIT;
 		spin_unlock(&device->lsc_vbq_lock);
 	}
 
+	previewer_vb_lock_vma(vb, 0);
 	if (vb->memory != V4L2_MEMORY_MMAP) {
 		videobuf_dma_unmap(q, videobuf_to_dma(vb));
 		videobuf_dma_free(videobuf_to_dma(vb));
 	}
 
-	dev_dbg(prev_dev, "previewer_vbq_release\n");
 }
 
 /**
@@ -521,18 +575,18 @@ static int previewer_vbq_setup(struct vi
 		if (*cnt > VIDEO_MAX_FRAME)
 			*cnt = VIDEO_MAX_FRAME;
 
-		if (!device->params->size_params.hsize ||
-				!device->params->size_params.vsize) {
+		if (!device->size_params.hsize ||
+				!device->size_params.vsize) {
 			dev_err(prev_dev, "Can't setup inout buffer size\n");
 			spin_unlock(&device->inout_vbq_lock);
 			return -EINVAL;
 		}
 
-		if (device->params->size_params.pixsize == PREV_INWIDTH_10BIT)
+		if (device->size_params.pixsize == PREV_INWIDTH_10BIT)
 			bpp = 2;
 
-		*size = prev_bufsize = bpp * device->params->size_params.hsize
-					* device->params->size_params.vsize;
+		*size = prev_bufsize = bpp * device->size_params.hsize
+					* device->size_params.vsize;
 		spin_unlock(&device->inout_vbq_lock);
 
 	} else if (q->type == V4L2_BUF_TYPE_PRIVATE) {
@@ -543,8 +597,8 @@ static int previewer_vbq_setup(struct vi
 		if (*cnt > 1)
 			*cnt = 1;
 
-		if (!device->params->size_params.hsize ||
-				!device->params->size_params.vsize) {
+		if (!device->size_params.hsize ||
+				!device->size_params.vsize) {
 			dev_err(prev_dev, "Can't setup lsc buffer size\n");
 			spin_unlock(&device->lsc_vbq_lock);
 			return -EINVAL;
@@ -552,15 +606,14 @@ static int previewer_vbq_setup(struct vi
 
 		/* upsampled lsc table size - for now bpp = 2 */
 		bpp = 2;
-		*size = lsc_bufsize = bpp * device->params->size_params.hsize *
-								device->params->size_params.vsize;
+		*size = lsc_bufsize = bpp * device->size_params.hsize *
+					    device->size_params.vsize;
 
 		spin_unlock(&device->lsc_vbq_lock);
 	} else {
 		return -EINVAL;
 	}
 
-	dev_dbg(prev_dev, "previewer_vbq_setup\n");
 	return 0;
 }
 
@@ -583,8 +636,6 @@ static int previewer_vbq_prepare(struct
 	unsigned int isp_addr;
 	struct videobuf_dmabuf *dma = videobuf_to_dma(vb);
 
-	dev_dbg(prev_dev, "previewer_vbq_prepare E\n");
-
 	if (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
 
 		spin_lock(&device->inout_vbq_lock);
@@ -592,40 +643,39 @@ static int previewer_vbq_prepare(struct
 		if (vb->baddr) {
 			vb->size = prev_bufsize;
 			vb->bsize = prev_bufsize;
-			DPRINTK_PREVIEWER("%s: bsize = %d\n", __func__, vb->bsize);
 		} else {
 			spin_unlock(&device->inout_vbq_lock);
 			dev_err(prev_dev, "No user buffer allocated\n");
 			goto out;
 		}
 
-		vb->width = device->params->size_params.hsize;
-		vb->height = device->params->size_params.vsize;
+		vb->width = device->size_params.hsize;
+		vb->height = device->size_params.vsize;
 		vb->field = field;
 		spin_unlock(&device->inout_vbq_lock);
 
 		if (vb->state == VIDEOBUF_NEEDS_INIT) {
-			DPRINTK_PREVIEWER("%s: baddr = %08x\n", __func__, (int)vb->baddr);
+			err = previewer_vb_lock_vma(vb, 1);
+			if (err)
+				goto buf_init_err1;
+
 			err = videobuf_iolock(q, vb, NULL);
-			if (!err) {
-				isp_addr = ispmmu_vmap(dma->sglist, dma->sglen);
+			if (err)
+				goto buf_init_err1;
 
-				if (!isp_addr) {
-				    err = -EIO;
-				} else {
-					device->isp_addr_read = isp_addr;
-					DPRINTK_PREVIEWER("%s: isp_addr_read = %08x\n",
-								__func__, isp_addr);
-				}
-			}
+			isp_addr = ispmmu_vmap(device->isp,
+					       dma->sglist, dma->sglen);
+			if (!isp_addr)
+				err = -EIO;
+			else
+				device->isp_addr_read = isp_addr;
 		}
 
-		if (!err) {
+buf_init_err1:
+		if (!err)
 			vb->state = VIDEOBUF_PREPARED;
-			flush_cache_user_range(NULL, vb->baddr, (vb->baddr + vb->bsize));
-		} else {
+		else
 			previewer_vbq_release(q, vb);
-		}
 
 	} else if (q->type == V4L2_BUF_TYPE_PRIVATE) {
 
@@ -634,51 +684,50 @@ static int previewer_vbq_prepare(struct
 		if (vb->baddr) {
 			vb->size = lsc_bufsize;
 			vb->bsize = lsc_bufsize;
-			DPRINTK_PREVIEWER("%s: bsize = %d\n", __func__, vb->bsize);
 		} else {
 			spin_unlock(&device->lsc_vbq_lock);
 			dev_err(prev_dev, "No user buffer allocated\n");
 			goto out;
 		}
 
-		vb->width = device->params->size_params.hsize;
-		vb->height = device->params->size_params.vsize;
+		vb->width = device->size_params.hsize;
+		vb->height = device->size_params.vsize;
 		vb->field = field;
 		spin_unlock(&device->lsc_vbq_lock);
 
 		if (vb->state == VIDEOBUF_NEEDS_INIT) {
-			DPRINTK_PREVIEWER("%s: baddr = %08x\n", __func__, (int)vb->baddr);
+			err = previewer_vb_lock_vma(vb, 1);
+			if (err)
+				goto buf_init_err2;
+
 			err = videobuf_iolock(q, vb, NULL);
-			if (!err) {
-				isp_addr = ispmmu_vmap(dma->sglist, dma->sglen);
-				if (!isp_addr) {
-					err = -EIO;
-				} else {
-					device->isp_addr_lsc = isp_addr;
-					DPRINTK_PREVIEWER("%s: isp_addr_lsc = %08x\n",
-								__func__, isp_addr);
-				}
-			}
+			if (err)
+				goto buf_init_err2;
+
+			isp_addr = ispmmu_vmap(device->isp,
+					       dma->sglist, dma->sglen);
+			if (!isp_addr)
+				err = -EIO;
+			else
+				device->isp_addr_lsc = isp_addr;
 		}
 
-		if (!err) {
+buf_init_err2:
+		if (!err)
 			vb->state = VIDEOBUF_PREPARED;
-			flush_cache_user_range(NULL, vb->baddr, (vb->baddr + vb->bsize));
-		} else {
+		else
 			previewer_vbq_release(q, vb);
-		}
 
 	} else {
 		return -EINVAL;
 	}
 
-	dev_dbg(prev_dev, "previewer_vbq_prepare L\n");
 out:
 	return err;
 }
 
 static void previewer_vbq_queue(struct videobuf_queue *q,
-						        struct videobuf_buffer *vb)
+					struct videobuf_buffer *vb)
 {
 	return;
 }
@@ -696,14 +745,13 @@ static int previewer_open(struct inode *
 {
 	int ret = 0;
 	struct prev_device *device = prevdevice;
-	struct prev_params *config;
 	struct prev_fh *fh;
 	struct device *isp;
 	struct isp_device *isp_dev;
 
 	if (device->opened || (filp->f_flags & O_NONBLOCK)) {
 		dev_err(prev_dev, "previewer_open: device is already "
-								"opened\n");
+					"opened\n");
 		return -EBUSY;
 	}
 
@@ -722,21 +770,12 @@ static int previewer_open(struct inode *
 	device->isp = isp;
 	isp_dev = dev_get_drvdata(isp);
 
-	config = isppreview_get_config(&isp_dev->isp_prev);
-	if (!config) {
-		dev_err(prev_dev, "Unable to initialize default config "
-			"from isppreviewer\n\n");
-		ret = -EACCES;
-		goto err_prev;
-	}
-
 	ret = isppreview_request(&isp_dev->isp_prev);
 	if (ret) {
 		dev_err(prev_dev, "Can't acquire isppreview\n");
 		goto err_prev;
 	}
 
-	device->params = config;
 	device->opened = 1;
 
 	filp->private_data = fh;
@@ -784,7 +823,6 @@ static int previewer_release(struct inod
 	struct isp_device *isp = dev_get_drvdata(device->isp);
 
 	device->opened = 0;
-	device->params = NULL;
 	videobuf_mmap_free(q1);
 	videobuf_mmap_free(q2);
 	isppreview_free(&isp->isp_prev);
@@ -794,7 +832,6 @@ static int previewer_release(struct inod
 	filp->private_data = NULL;
 	kfree(fh);
 
-	dev_dbg(prev_dev, "previewer_release\n");
 	return 0;
 }
 
@@ -818,6 +855,106 @@ static int previewer_mmap(struct file *f
 	return -EINVAL;
 }
 
+#define COPY_USERTABLE(dst, src, size)					\
+	if (src) {							\
+		if (!dst)						\
+			return -EACCES;					\
+		if (copy_from_user(dst, src, (size) * sizeof(*(dst))))	\
+			return -EFAULT;					\
+	}
+
+/* Copy preview module configuration into use */
+static int previewer_set_param(struct prev_device *device,
+			       struct prev_params __user *uparams)
+{
+	struct isp_device *isp_dev = dev_get_drvdata(device->isp);
+	struct prev_params *config = &isp_dev->isp_prev.params;
+	/* Here it should be safe to allocate 420 bytes from stack */
+	struct prev_params p;
+	struct prev_params *params = &p;
+	int ret;
+
+	if (copy_from_user(params, uparams, sizeof(*params)))
+		return -EFAULT;
+	ret = prev_validate_params(params);
+	if (ret < 0)
+		return -EINVAL;
+
+	config->features = params->features;
+	config->pix_fmt = params->pix_fmt;
+	config->cfa.cfafmt = params->cfa.cfafmt;
+
+	/* struct ispprev_cfa */
+	config->cfa.cfa_gradthrs_vert = params->cfa.cfa_gradthrs_vert;
+	config->cfa.cfa_gradthrs_horz = params->cfa.cfa_gradthrs_horz;
+	COPY_USERTABLE(config->cfa.cfa_table, params->cfa.cfa_table,
+			ISPPRV_CFA_TBL_SIZE);
+
+	/* struct ispprev_csup csup */
+	config->csup.gain = params->csup.gain;
+	config->csup.thres = params->csup.thres;
+	config->csup.hypf_en = params->csup.hypf_en;
+
+	COPY_USERTABLE(config->ytable, params->ytable, ISPPRV_YENH_TBL_SIZE);
+
+	/* struct ispprev_nf nf */
+	config->nf.spread = params->nf.spread;
+	memcpy(&config->nf.table, &params->nf.table, sizeof(config->nf.table));
+
+	/* struct ispprev_dcor dcor */
+	config->dcor.couplet_mode_en = params->dcor.couplet_mode_en;
+	memcpy(&config->dcor.detect_correct, &params->dcor.detect_correct,
+		sizeof(config->dcor.detect_correct));
+
+	/* struct ispprev_gtable gtable */
+	COPY_USERTABLE(config->gtable.redtable, params->gtable.redtable,
+		ISPPRV_GAMMA_TBL_SIZE);
+	COPY_USERTABLE(config->gtable.greentable, params->gtable.greentable,
+		ISPPRV_GAMMA_TBL_SIZE);
+	COPY_USERTABLE(config->gtable.bluetable, params->gtable.bluetable,
+		ISPPRV_GAMMA_TBL_SIZE);
+
+	/* struct ispprev_wbal wbal */
+	config->wbal.dgain = params->wbal.dgain;
+	config->wbal.coef3 = params->wbal.coef3;
+	config->wbal.coef2 = params->wbal.coef2;
+	config->wbal.coef1 = params->wbal.coef1;
+	config->wbal.coef0 = params->wbal.coef0;
+
+	/* struct ispprev_blkadj blk_adj */
+	config->blk_adj.red = params->blk_adj.red;
+	config->blk_adj.green = params->blk_adj.green;
+	config->blk_adj.blue = params->blk_adj.blue;
+
+	/* struct ispprev_rgbtorgb rgb2rgb */
+	memcpy(&config->rgb2rgb.matrix, &params->rgb2rgb.matrix,
+		sizeof(config->rgb2rgb.matrix));
+	memcpy(&config->rgb2rgb.offset, &params->rgb2rgb.offset,
+		sizeof(config->rgb2rgb.offset));
+
+	/* struct ispprev_csc rgb2ycbcr */
+	memcpy(&config->rgb2ycbcr.matrix, &params->rgb2ycbcr.matrix,
+		sizeof(config->rgb2ycbcr.matrix));
+	memcpy(&config->rgb2ycbcr.offset, &params->rgb2ycbcr.offset,
+		sizeof(config->rgb2ycbcr.offset));
+
+	/* struct ispprev_hmed hmf_params */
+	config->hmf_params.odddist = params->hmf_params.odddist;
+	config->hmf_params.evendist = params->hmf_params.evendist;
+	config->hmf_params.thres = params->hmf_params.thres;
+
+	/* struct prev_darkfrm_params drkf_params not set here */
+
+	config->lens_shading_shift = params->lens_shading_shift;
+	config->average = params->average;
+	config->contrast = params->contrast;
+	config->brightness = params->brightness;
+
+	device->size_params = params->size_params;
+
+	return 0;
+}
+
 /**
  * previewer_ioctl - I/O control function for Preview Wrapper
  * @inode: Inode structure associated with the Preview Wrapper.
@@ -833,129 +970,109 @@ static int previewer_ioctl(struct inode
 					unsigned int cmd, unsigned long arg)
 {
 	int ret = 0;
-	struct prev_params params;
 	struct prev_fh *fh = file->private_data;
 	struct prev_device *device = fh->device;
 
-	dev_dbg(prev_dev, "Entering previewer_ioctl()\n");
-
-	if ((_IOC_TYPE(cmd) != PREV_IOC_BASE)
-					|| (_IOC_NR(cmd) > PREV_IOC_MAXNR)) {
-		dev_err(prev_dev, "Bad command Value \n");
-		goto err_minusone;
-	}
-
-	if (_IOC_DIR(cmd) & _IOC_READ)
-		ret = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));
-	else if (_IOC_DIR(cmd) & _IOC_WRITE)
-		ret = !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));
-	if (ret) {
-		dev_err(prev_dev, "access denied\n");
-		goto err_minusone;
-	}
-
 	switch (cmd) {
 	case PREV_REQBUF: {
-		struct v4l2_requestbuffers *req;
+		struct v4l2_requestbuffers req;
+
+		if (copy_from_user(&req, (void *)arg, sizeof(req)))
+			goto err_efault;
 
 		if (mutex_lock_interruptible(&device->prevwrap_mutex))
 			goto err_eintr;
 
-		req = (struct v4l2_requestbuffers *) arg;
-
-		if (req->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-			ret = videobuf_reqbufs(&fh->inout_vbq, (void *) arg);
-		else if (req->type == V4L2_BUF_TYPE_PRIVATE)
-			ret = videobuf_reqbufs(&fh->lsc_vbq, (void *) arg);
+		if (req.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+			ret = videobuf_reqbufs(&fh->inout_vbq, &req);
+		else if (req.type == V4L2_BUF_TYPE_PRIVATE)
+			ret = videobuf_reqbufs(&fh->lsc_vbq, &req);
 		else
 			ret = -EINVAL;
 
 		mutex_unlock(&device->prevwrap_mutex);
+
+		if (ret)
+			goto out;
+
+		if (copy_to_user((void *)arg, &req, sizeof(req)))
+			goto err_efault;
+
 		break;
 	}
 
 	case PREV_QUERYBUF: {
-		struct v4l2_buffer *b;
+		struct v4l2_buffer b;
+
+		if (copy_from_user(&b, (void *)arg, sizeof(b)))
+			goto err_efault;
 
 		if (mutex_lock_interruptible(&device->prevwrap_mutex))
 			goto err_eintr;
-		b = (struct v4l2_buffer *) arg;
 
-		if (b->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-			ret = videobuf_querybuf(&fh->inout_vbq, (void *) arg);
-		else if (b->type == V4L2_BUF_TYPE_PRIVATE)
-			ret = videobuf_querybuf(&fh->lsc_vbq, (void *) arg);
+		if (b.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+			ret = videobuf_querybuf(&fh->inout_vbq, &b);
+		else if (b.type == V4L2_BUF_TYPE_PRIVATE)
+			ret = videobuf_querybuf(&fh->lsc_vbq, &b);
 		else
 			ret = -EINVAL;
 
 		mutex_unlock(&device->prevwrap_mutex);
+
+		if (ret)
+			goto out;
+
+		if (copy_to_user((void *)arg, &b, sizeof(b)))
+			goto err_efault;
+
 		break;
 	}
 
 	case PREV_QUEUEBUF: {
-		struct v4l2_buffer *b;
+		struct v4l2_buffer b;
+
+		if (copy_from_user(&b, (void *)arg, sizeof(b)))
+			goto err_efault;
 
 		if (mutex_lock_interruptible(&device->prevwrap_mutex))
 			goto err_eintr;
 
-		b = (struct v4l2_buffer *) arg;
-		if (b->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-			ret = videobuf_qbuf(&fh->inout_vbq, (void *) arg);
-		else if (b->type == V4L2_BUF_TYPE_PRIVATE)
-			ret = videobuf_qbuf(&fh->lsc_vbq, (void *) arg);
+		if (b.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+			ret = videobuf_qbuf(&fh->inout_vbq, &b);
+		else if (b.type == V4L2_BUF_TYPE_PRIVATE)
+			ret = videobuf_qbuf(&fh->lsc_vbq, &b);
 		else
 			ret = -EINVAL;
 
 		mutex_unlock(&device->prevwrap_mutex);
+
+		if (ret)
+			goto out;
+
+		if (copy_to_user((void *)arg, &b, sizeof(b)))
+			goto err_efault;
+
 		break;
 	}
 
 	case PREV_SET_PARAM:
 		if (mutex_lock_interruptible(&device->prevwrap_mutex))
 			goto err_eintr;
-		if (copy_from_user(&params, (struct prev_params *)arg,
-						sizeof(struct prev_params))) {
-			mutex_unlock(&device->prevwrap_mutex);
-			return -EFAULT;
-		}
-		ret = prev_validate_params(&params);
-		if (ret < 0) {
-			dev_err(prev_dev, "Error validating parameters!\n");
-			mutex_unlock(&device->prevwrap_mutex);
-			goto out;
-		}
-		if (device->params)
-			memcpy(device->params, &params,
-						sizeof(struct prev_params));
-		else {
-			mutex_unlock(&device->prevwrap_mutex);
-			return -EINVAL;
-		}
-
-/*		ret = prev_hw_setup(device->params); */
+		ret = previewer_set_param(device, (struct prev_params *)arg);
 		mutex_unlock(&device->prevwrap_mutex);
 		break;
 
-	case PREV_GET_PARAM:
-		if (copy_to_user((struct prev_params *)arg, device->params,
-						sizeof(struct prev_params)))
-			ret = -EFAULT;
-		break;
-
-	case PREV_GET_STATUS:
-		ret = prev_get_status((struct prev_status *)arg);
-		break;
-
 	case PREV_PREVIEW:
 		if (mutex_lock_interruptible(&device->prevwrap_mutex))
 			goto err_eintr;
-		ret = prev_do_preview(device, (int *)arg);
+		ret = prev_do_preview(device);
 		mutex_unlock(&device->prevwrap_mutex);
 		break;
 
 	case PREV_GET_CROPSIZE: {
 		struct prev_cropsize outputsize;
 
+		memset(&outputsize, 0, sizeof(outputsize));
 		ret = prev_calculate_crop(device, &outputsize);
 		if (ret)
 			break;
@@ -972,8 +1089,8 @@ static int previewer_ioctl(struct inode
 	}
 out:
 	return ret;
-err_minusone:
-	return -1;
+err_efault:
+	return -EFAULT;
 err_eintr:
 	return -EINTR;
 }
@@ -986,7 +1103,6 @@ err_eintr:
  **/
 static void previewer_platform_release(struct device *device)
 {
-	dev_dbg(prev_dev, "previewer_platform_release()\n");
 }
 
 static struct file_operations prev_fops = {
@@ -1050,28 +1166,30 @@ static int __init omap_previewer_init(vo
 
 	device = kzalloc(sizeof(struct prev_device), GFP_KERNEL);
 	if (!device) {
-		dev_err(prev_dev, OMAP_PREV_NAME ": could not allocate memory\n");
+		printk(KERN_ERR OMAP_PREV_NAME
+				" could not allocate memory\n");
 		return -ENOMEM;
 	}
 	prev_major = register_chrdev(0, OMAP_PREV_NAME, &prev_fops);
 
 	if (prev_major < 0) {
-		dev_err(prev_dev, OMAP_PREV_NAME ": initialization "
+		printk(KERN_ERR OMAP_PREV_NAME " initialization "
 				"failed. could not register character "
 				"device\n");
+		kfree(device);
 		return -ENODEV;
 	}
 
 	ret = platform_driver_register(&omap_previewer_driver);
 	if (ret) {
-		dev_err(prev_dev, OMAP_PREV_NAME
-			": failed to register platform driver!\n");
+		printk(KERN_ERR OMAP_PREV_NAME
+				"failed to register platform driver!\n");
 		goto fail2;
 	}
 	ret = platform_device_register(&omap_previewer_device);
 	if (ret) {
-		dev_err(prev_dev, OMAP_PREV_NAME
-			": failed to register platform device!\n");
+		printk(KERN_ERR OMAP_PREV_NAME
+			" failed to register platform device!\n");
 		goto fail3;
 	}
 
@@ -1082,7 +1200,6 @@ static int __init omap_previewer_init(vo
 	prev_dev = device_create(prev_class, prev_dev, MKDEV(prev_major, 0),
 				NULL, OMAP_PREV_NAME);
 
-	dev_dbg(prev_dev, OMAP_PREV_NAME ": Registered Previewer Wrapper\n");
 	device->opened = 0;
 
 	device->vbq_ops.buf_setup = previewer_vbq_setup;
@@ -1101,6 +1218,8 @@ fail3:
 fail2:
 	unregister_chrdev(prev_major, OMAP_PREV_NAME);
 
+	kfree(device);
+
 	return ret;
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/isp/omap_previewer_hack.h kernel-2.6.28-20093908+0m5/drivers/media/video/isp/omap_previewer_hack.h
--- kernel-2.6.28-20091602+0m5/drivers/media/video/isp/omap_previewer_hack.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/isp/omap_previewer_hack.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,142 +0,0 @@
-/*
- * drivers/media/video/isp/omap_previewer.h
- *
- * Include file for Preview module wrapper in TI's OMAP3430 ISP
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#include "isppreview.h"
-
-#ifndef OMAP_ISP_PREVIEW_WRAP_H
-#define OMAP_ISP_PREVIEW_WRAP_H
-
-#define PREV_IOC_BASE			'P'
-#define PREV_REQBUF			_IOWR(PREV_IOC_BASE, 1,\
-						struct v4l2_requestbuffers)
-#define PREV_QUERYBUF			_IOWR(PREV_IOC_BASE, 2,\
-							struct v4l2_buffer)
-#define PREV_SET_PARAM			_IOW(PREV_IOC_BASE, 3,\
-							struct prev_params)
-#define PREV_GET_PARAM			_IOWR(PREV_IOC_BASE, 4,\
-							struct prev_params)
-#define PREV_PREVIEW			_IOR(PREV_IOC_BASE, 5, int)
-#define PREV_GET_STATUS			_IOR(PREV_IOC_BASE, 6, char)
-#define PREV_GET_CROPSIZE		_IOR(PREV_IOC_BASE, 7,\
-							struct prev_cropsize)
-#define PREV_QUEUEBUF			_IOWR(PREV_IOC_BASE, 8,\
-							struct v4l2_buffer)
-#define PREV_IOC_MAXNR    8
-
-#define LUMA_TABLE_SIZE			128
-#define GAMMA_TABLE_SIZE		1024
-#define CFA_COEFF_TABLE_SIZE		576
-#define NOISE_FILTER_TABLE_SIZE		256
-
-#define MAX_IMAGE_WIDTH			3300
-
-#define PREV_INWIDTH_8BIT		0	/* pixel width of 8 bitS */
-#define PREV_INWIDTH_10BIT		1	/* pixel width of 10 bits */
-
-#define PREV_32BYTES_ALIGN_MASK		0xFFFFFFE0
-#define PREV_16PIX_ALIGN_MASK		0xFFFFFFF0
-
-/* list of structures */
-
-/* structure for RGB2RGB blending parameters */
-struct prev_rgbblending {
-	short blending[RGB_MAX][RGB_MAX];	/* color correlation 3x3
-						 * matrix.
-						 */
-	short offset[RGB_MAX];			/* color correlation offsets */
-};
-
-/* structure for CFA coefficients */
-struct prev_cfa_coeffs {
-	char hthreshold, vthreshold;		/* horizontal an vertical
-						 * threshold.
-						 */
-	int coeffs[CFA_COEFF_TABLE_SIZE];	/* cfa coefficients */
-};
-/* structure for Gamma Coefficients */
-struct prev_gamma_coeffs {
-	unsigned char red[GAMMA_TABLE_SIZE];	/* table of gamma correction
-						 * values for red color.
-						 */
-	unsigned char green[GAMMA_TABLE_SIZE];	/* table of gamma correction
-						 * values for green color.
-						 */
-	unsigned char blue[GAMMA_TABLE_SIZE];	/* table of gamma correction
-						 * values for blue color.
-						 */
-};
-/* Structure for Noise Filter Coefficients */
-struct prev_noiseflt_coeffs {
-	unsigned char noise[NOISE_FILTER_TABLE_SIZE];	/* noise filter
-							 * table.
-							 */
-	unsigned char strength;				/* to find out
-							 * weighted average.
-							 */
-};
-
-/* Structure for Chroma Suppression */
-struct prev_chroma_spr {
-	unsigned char hpfy;			/* whether to use high passed
-						 * version of Y or normal Y
-						 */
-	char threshold;				/* threshold for chroma
-						 * suppress.
-						 */
-	unsigned char gain;			/* chroma suppression gain */
-};
-
-/* structure to know status of the hardware */
-struct prev_status {
-	char hw_busy;
-};
-/* structure to knwo crop size */
-struct prev_cropsize {
-	int hcrop;
-	int vcrop;
-};
-
-
-/* device structure keeps track of global information */
-struct prev_device {
-	struct prev_params *params;
-	unsigned char opened;			/* state of the device */
-	struct completion wfc;
-	struct mutex prevwrap_mutex;
-	/* spinlock for in/out videbuf queue */
-	spinlock_t inout_vbq_lock;
-	/* spinlock for lsc videobuf queues */
-	spinlock_t lsc_vbq_lock;
-	struct videobuf_queue_ops vbq_ops;	/* videobuf queue operations */
-	dma_addr_t isp_addr_read;		/* Input/Output address */
-	dma_addr_t isp_addr_lsc;  /* lsc address */
-	struct device *isp;
-};
-
-/* per-filehandle data structure */
-struct prev_fh {
-	/* in/out videobuf queue */
-	enum v4l2_buf_type inout_type;
-	struct videobuf_queue inout_vbq;
-	/* lsc videobuf queue */
-	enum v4l2_buf_type lsc_type;
-	struct videobuf_queue lsc_vbq;
-	/* device structure */
-	struct prev_device *device;
-};
-
-#endif
-
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/omap34xxcam.c kernel-2.6.28-20093908+0m5/drivers/media/video/omap34xxcam.c
--- kernel-2.6.28-20091602+0m5/drivers/media/video/omap34xxcam.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/omap34xxcam.c	2012-12-16 13:13:01.668330147 +0100
@@ -32,29 +32,15 @@
  *
  */
 
-#include <linux/io.h>
-#include <linux/clk.h>
-#include <linux/pci.h>		/* needed for videobufs */
-#include <linux/delay.h>
-#include <linux/kernel.h>
-#include <linux/interrupt.h>
 #include <linux/videodev2.h>
 #include <linux/version.h>
-#include <linux/platform_device.h>
+#include <asm/pgalloc.h>
 
 #include <media/v4l2-common.h>
 #include <media/v4l2-ioctl.h>
 
 #include "omap34xxcam.h"
 #include "isp/isp.h"
-#include "isp/ispmmu.h"
-#include "isp/ispreg.h"
-#include "isp/ispccdc.h"
-#include "isp/isph3a.h"
-#include "isp/isp_af.h"
-#include "isp/isphist.h"
-#include "isp/isppreview.h"
-#include "isp/ispresizer.h"
 
 #define OMAP34XXCAM_VERSION KERNEL_VERSION(0, 0, 0)
 
@@ -76,14 +62,23 @@ int omap34xxcam_slave_power_set(struct o
 				enum v4l2_power power, int mask)
 {
 	int rval = 0, i = 0;
+	int start, end, dir;
 
 	BUG_ON(!mutex_is_locked(&vdev->mutex));
 
-#ifdef OMAP34XXCAM_POWEROFF_DELAY
-	vdev->power_state_wish = -1;
-#endif
+	if (power != V4L2_POWER_OFF) {
+		/* Sensor has to be powered on first */
+		start = 0;
+		end = OMAP34XXCAM_SLAVE_FLASH;
+		dir = 1;
+	} else {
+		/* Sensor has to be powered off last */
+		start = OMAP34XXCAM_SLAVE_FLASH;
+		end = 0;
+		dir = -1;
+	}
 
-	for (i = 0; i <= OMAP34XXCAM_SLAVE_FLASH; i++) {
+	for (i = start; i != end + dir; i += dir) {
 		if (vdev->slave[i] == v4l2_int_device_dummy())
 			continue;
 
@@ -104,7 +99,7 @@ int omap34xxcam_slave_power_set(struct o
 	return 0;
 
 out:
-	for (i--; i >= 0; i--) {
+	for (i -= dir; i != start - dir; i -= dir) {
 		if (vdev->slave[i] == v4l2_int_device_dummy())
 			continue;
 
@@ -118,51 +113,6 @@ out:
 	return rval;
 }
 
-#ifdef OMAP34XXCAM_POWEROFF_DELAY
-static void omap34xxcam_slave_power_work(struct work_struct *work)
-{
-	struct omap34xxcam_videodev *vdev =
-		container_of(work, struct omap34xxcam_videodev, poweroff_work);
-
-	mutex_lock(&vdev->mutex);
-
-	if (vdev->power_state_wish != -1)
-		omap34xxcam_slave_power_set(vdev, vdev->power_state_wish,
-					    vdev->power_state_mask);
-
-	mutex_unlock(&vdev->mutex);
-}
-
-static void omap34xxcam_slave_power_timer(unsigned long ptr)
-{
-	struct omap34xxcam_videodev *vdev = (void *)ptr;
-
-	schedule_work(&vdev->poweroff_work);
-}
-
-/**
- * omap34xxcam_slave_power_suggest - delayed power state change
- *
- * @vdev: per-video device data structure
- * @power: new power state
- */
-static void omap34xxcam_slave_power_suggest(struct omap34xxcam_videodev *vdev,
-					    enum v4l2_power power,
-					    int mask)
-{
-	BUG_ON(!mutex_is_locked(&vdev->mutex));
-
-	del_timer(&vdev->poweroff_timer);
-
-	vdev->power_state_wish = power;
-	vdev->power_state_mask = mask;
-
-	mod_timer(&vdev->poweroff_timer, jiffies + OMAP34XXCAM_POWEROFF_DELAY);
-}
-#else /* OMAP34XXCAM_POWEROFF_DELAY */
-#define omap34xxcam_slave_power_suggest(a, b, c) do {} while (0)
-#endif /* OMAP34XXCAM_POWEROFF_DELAY */
-
 /**
  * omap34xxcam_update_vbq - Updates VBQ with completed input buffer
  * @vb: ptr. to standard V4L2 video buffer structure
@@ -210,6 +160,62 @@ static int omap34xxcam_vbq_setup(struct
 	return isp_vbq_setup(vdev->cam->isp, vbq, cnt, size);
 }
 
+static int omap34xxcam_vb_lock_vma(struct videobuf_buffer *vb, int lock)
+{
+	unsigned long start, end;
+	struct vm_area_struct *vma;
+	int rval = 0;
+
+	if (vb->memory == V4L2_MEMORY_MMAP)
+		return 0;
+
+	if (current->flags & PF_EXITING) {
+		/**
+		 * task is getting shutdown.
+		 * current->mm could have been released.
+		 *
+		 * For locking, we return error.
+		 * For unlocking, the subsequent release of
+		 * buffer should set things right
+		 */
+		if (lock)
+			return -EINVAL;
+		else
+			return 0;
+	}
+
+	end = vb->baddr + vb->bsize;
+
+	down_write(&current->mm->mmap_sem);
+	spin_lock(&current->mm->page_table_lock);
+
+	for (start = vb->baddr; ; ) {
+		unsigned int newflags;
+
+		vma = find_vma(current->mm, start);
+		if (!vma || vma->vm_start > start) {
+				rval = -ENOMEM;
+			goto out;
+		}
+
+		newflags = vma->vm_flags | VM_LOCKED;
+		if (!lock)
+			newflags &= ~VM_LOCKED;
+
+		vma->vm_flags = newflags;
+
+		if (vma->vm_end >= end)
+			break;
+
+		start = vma->vm_end;
+	}
+
+out:
+	spin_unlock(&current->mm->page_table_lock);
+	up_write(&current->mm->mmap_sem);
+	return rval;
+}
+
 /**
  * omap34xxcam_vbq_release - Free resources for input VBQ and VB
  * @vbq: ptr. to standard V4L2 video buffer queue structure
@@ -227,6 +233,7 @@ static void omap34xxcam_vbq_release(stru
 
 	if (!vbq->streaming) {
 		isp_vbq_release(isp, vbq, vb);
+		omap34xxcam_vb_lock_vma(vb, 0);
 		videobuf_dma_unmap(vbq, videobuf_to_dma(vb));
 		videobuf_dma_free(videobuf_to_dma(vb));
 		vb->state = VIDEOBUF_NEEDS_INIT;
@@ -279,13 +286,19 @@ static int omap34xxcam_vbq_prepare(struc
 	vb->field = field;
 
 	if (vb->state == VIDEOBUF_NEEDS_INIT) {
+		err = omap34xxcam_vb_lock_vma(vb, 1);
+		if (err)
+			goto buf_init_err;
+
 		err = videobuf_iolock(vbq, vb, NULL);
-		if (!err) {
-			/* isp_addr will be stored locally inside isp code */
-			err = isp_vbq_prepare(isp, vbq, vb, field);
-		}
+		if (err)
+			goto buf_init_err;
+
+		/* isp_addr will be stored locally inside isp code */
+		err = isp_vbq_prepare(isp, vbq, vb, field);
 	}
 
+buf_init_err:
 	if (!err)
 		vb->state = VIDEOBUF_PREPARED;
 	else
@@ -310,8 +323,6 @@ static void omap34xxcam_vbq_queue(struct
 	struct omap34xxcam_videodev *vdev = fh->vdev;
 	struct device *isp = vdev->cam->isp;
 
-	vb->state = VIDEOBUF_ACTIVE;
-
 	isp_buf_queue(isp, vb, omap34xxcam_vbq_complete, (void *)fh);
 }
 
@@ -420,6 +431,8 @@ static int try_pix_parm(struct omap34xxc
 
 	fps = best_ival->denominator / best_ival->numerator;
 
+	memset(best_pix_in, 0, sizeof(*best_pix_in));
+
 	best_ival->denominator = 0;
 	best_pix_out.height = INT_MAX >> 1;
 	best_pix_out.width = best_pix_out.height;
@@ -532,6 +545,9 @@ static int try_pix_parm(struct omap34xxc
 				if (best_ival->denominator == 0)
 					goto do_it_now;
 
+				if (best_pix_in->width == 0)
+					goto do_it_now;
+
 				/*
 				 * We aim to use maximum resolution
 				 * from the sensor, provided that the
@@ -601,7 +617,7 @@ do_it_now:
 		best_pix_in->pixelformat,
 		best_pix_out.width, best_pix_out.height);
 
-	return isp_try_fmt_cap(isp, best_pix_in, wanted_pix_out);
+	return 0;
 }
 
 static int s_pix_parm(struct omap34xxcam_videodev *vdev,
@@ -634,21 +650,6 @@ static int s_pix_parm(struct omap34xxcam
 	a.parm.capture.timeperframe = *best_ival;
 	rval = vidioc_int_s_parm(vdev->vdev_sensor, &a);
 
-	/*
-	 * FIXME: the crop parameters are reset here. That
-	 * shouldn't be done. How to do this for different
-	 * sensor resolutions?
-	 */
-	if (memcmp(&old_fmt.fmt.pix, &fmt.fmt.pix, sizeof(old_fmt.fmt.pix))) {
-		struct v4l2_crop crop;
-
-		crop.c.left = crop.c.top = 0;
-		crop.c.width = fmt.fmt.pix.width;
-		crop.c.height = fmt.fmt.pix.height;
-
-		isp_s_crop(isp, &crop);
-	}
-
 	return rval;
 }
 
@@ -866,22 +867,25 @@ static int vidioc_streamon(struct file *
 	}
 
 	rval = omap34xxcam_slave_power_set(vdev, V4L2_POWER_ON,
-					   OMAP34XXCAM_SLAVE_POWER_SENSOR_LENS);
+					   OMAP34XXCAM_SLAVE_POWER_ALL);
 	if (rval) {
 		dev_dbg(&vdev->vfd->dev,
 			"omap34xxcam_slave_power_set failed\n");
 		goto out;
 	}
 
+	isp_start(isp);
+
 	isp_set_callback(isp, CBK_CATCHALL, omap34xxcam_daemon_event_cb,
 			 (void *)vdev, NULL);
 
 	rval = videobuf_streamon(&ofh->vbq);
-	if (rval)
+	if (rval) {
+		isp_stop(isp);
 		omap34xxcam_slave_power_set(
-			vdev, V4L2_POWER_OFF,
-			OMAP34XXCAM_SLAVE_POWER_SENSOR_LENS);
-	else
+			vdev, V4L2_POWER_STANDBY,
+			OMAP34XXCAM_SLAVE_POWER_ALL);
+	} else
 		vdev->streaming = file;
 
 out:
@@ -927,9 +931,7 @@ static int vidioc_streamoff(struct file
 		vdev->streaming = NULL;
 
 		omap34xxcam_slave_power_set(vdev, V4L2_POWER_STANDBY,
-					    OMAP34XXCAM_SLAVE_POWER_SENSOR);
-		omap34xxcam_slave_power_suggest(vdev, V4L2_POWER_STANDBY,
-						OMAP34XXCAM_SLAVE_POWER_LENS);
+					    OMAP34XXCAM_SLAVE_POWER_ALL);
 		isp_unset_callback(isp, CBK_CATCHALL);
 	}
 
@@ -1352,20 +1354,45 @@ static int vidioc_enum_framesizes(struct
 {
 	struct omap34xxcam_fh *ofh = fh;
 	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	struct v4l2_pix_format pix_in;
+	struct v4l2_pix_format pix_out;
+	struct v4l2_fract ival;
 	u32 pixel_format;
 	int rval;
 
+	if (vdev->vdev_sensor == v4l2_int_device_dummy())
+		return -EINVAL;
+
 	mutex_lock(&vdev->mutex);
 
 	if (vdev->vdev_sensor_config.sensor_isp) {
 		rval = vidioc_int_enum_framesizes(vdev->vdev_sensor, frms);
-	} else {
-		pixel_format = frms->pixel_format;
-		frms->pixel_format = -1;	/* ISP does format conversion */
-		rval = vidioc_int_enum_framesizes(vdev->vdev_sensor, frms);
-		frms->pixel_format = pixel_format;
+		goto done;
 	}
 
+	pixel_format = frms->pixel_format;
+	frms->pixel_format = -1;	/* ISP does format conversion */
+	rval = vidioc_int_enum_framesizes(vdev->vdev_sensor, frms);
+	frms->pixel_format = pixel_format;
+
+	if (rval < 0)
+		goto done;
+
+	/* Let the ISP pipeline mangle the frame size as it sees fit. */
+	memset(&pix_out, 0, sizeof(pix_out));
+	pix_out.width = frms->discrete.width;
+	pix_out.height = frms->discrete.height;
+	pix_out.pixelformat = frms->pixel_format;
+
+	ival = vdev->want_timeperframe;
+	rval = try_pix_parm(vdev, &pix_in, &pix_out, &ival);
+	if (rval < 0)
+		goto done;
+
+	frms->discrete.width = pix_out.width;
+	frms->discrete.height = pix_out.height;
+
+done:
 	mutex_unlock(&vdev->mutex);
 	return rval;
 }
@@ -1375,20 +1402,76 @@ static int vidioc_enum_frameintervals(st
 {
 	struct omap34xxcam_fh *ofh = fh;
 	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	struct v4l2_frmsizeenum frms;
+	unsigned int frmi_width;
+	unsigned int frmi_height;
+	unsigned int width;
+	unsigned int height;
+	unsigned int max_dist;
+	unsigned int dist;
 	u32 pixel_format;
+	unsigned int i;
 	int rval;
 
 	mutex_lock(&vdev->mutex);
 
 	if (vdev->vdev_sensor_config.sensor_isp) {
 		rval = vidioc_int_enum_frameintervals(vdev->vdev_sensor, frmi);
-	} else {
-		pixel_format = frmi->pixel_format;
-		frmi->pixel_format = -1;	/* ISP does format conversion */
-		rval = vidioc_int_enum_frameintervals(vdev->vdev_sensor, frmi);
-		frmi->pixel_format = pixel_format;
+		goto done;
+	}
+
+	/*
+	 * Frame size enumeration returned sizes mangled by the ISP.
+	 * We can't pass the size directly to the sensor for frame
+	 * interval enumeration, as they will not be recognized by the
+	 * sensor driver. Enumerate the native sensor sizes and select
+	 * the one closest to the requested size.
+	 */
+
+	for (i = 0, max_dist = (unsigned int)-1; ; ++i) {
+		frms.index = i;
+		frms.pixel_format = -1;
+		rval = vidioc_int_enum_framesizes(vdev->vdev_sensor,
+			&frms);
+		if (rval < 0)
+			break;
+
+		/*
+		 * The distance between frame sizes is the size in
+		 * pixels of the non-overlapping regions.
+		 */
+		dist = min(frms.discrete.width, frmi->width)
+		     * min(frms.discrete.height, frmi->height);
+		dist = frms.discrete.width * frms.discrete.width
+		     + frmi->width * frmi->height
+		     - 2*dist;
+
+		if (dist < max_dist) {
+			width = frms.discrete.width;
+			height = frms.discrete.height;
+			max_dist = dist;
+		}
 	}
 
+	if (max_dist == (unsigned int)-1) {
+		rval = -EINVAL;
+		goto done;
+	}
+
+	pixel_format = frmi->pixel_format;
+	frmi_width = frmi->width;
+	frmi_height = frmi->height;
+
+	frmi->pixel_format = -1;	/* ISP does format conversion */
+	frmi->width = width;
+	frmi->height = height;
+	rval = vidioc_int_enum_frameintervals(vdev->vdev_sensor, frmi);
+
+	frmi->pixel_format = pixel_format;
+	frmi->height = frmi_height;
+	frmi->width = frmi_width;
+
+done:
 	mutex_unlock(&vdev->mutex);
 	return rval;
 }
@@ -1609,7 +1692,7 @@ static int omap34xxcam_open(struct inode
 	struct omap34xxcam_device *cam = omap34xxcam;
 	struct device *isp;
 	struct omap34xxcam_fh *fh;
-	struct v4l2_format format;
+	struct v4l2_format sensor_format;
 	int first_user = 0;
 	int i;
 
@@ -1629,6 +1712,8 @@ static int omap34xxcam_open(struct inode
 	if (fh == NULL)
 		return -ENOMEM;
 
+	fh->vdev = vdev;
+
 	mutex_lock(&vdev->mutex);
 	for (i = 0; i <= OMAP34XXCAM_SLAVE_FLASH; i++) {
 		if (vdev->slave[i] != v4l2_int_device_dummy()
@@ -1650,47 +1735,50 @@ static int omap34xxcam_open(struct inode
 			goto out_isp_get;
 		}
 		cam->isp = isp;
-		if (omap34xxcam_slave_power_set(vdev, V4L2_POWER_ON,
+		if (omap34xxcam_slave_power_set(vdev, V4L2_POWER_STANDBY,
 						OMAP34XXCAM_SLAVE_POWER_ALL)) {
 			dev_err(&vdev->vfd->dev, "can't power up slaves\n");
 			rval = -EBUSY;
 			goto out_slave_power_set_standby;
 		}
-		omap34xxcam_slave_power_set(
-			vdev, V4L2_POWER_STANDBY,
-			OMAP34XXCAM_SLAVE_POWER_SENSOR);
-		omap34xxcam_slave_power_suggest(
-			vdev, V4L2_POWER_STANDBY,
-			OMAP34XXCAM_SLAVE_POWER_LENS);
 	}
 
-	fh->vdev = vdev;
+	if (vdev->vdev_sensor == v4l2_int_device_dummy() || !first_user)
+		goto out_no_pix;
+
+	/* Get the format the sensor is using. */
+	rval = vidioc_int_g_fmt_cap(vdev->vdev_sensor, &sensor_format);
+	if (rval) {
+		dev_err(&vdev->vfd->dev,
+			"can't get current pix from sensor!\n");
+		goto out_vidioc_int_g_fmt_cap;
+	}
+
+	if (!vdev->pix.width)
+		vdev->pix = sensor_format.fmt.pix;
 
-	if (!vdev->pix.width
-	    && vdev->vdev_sensor != v4l2_int_device_dummy()) {
-		memset(&format, 0, sizeof(format));
-		if (vidioc_int_g_fmt_cap(vdev->vdev_sensor, &format)) {
+	if (!vdev->vdev_sensor_config.sensor_isp) {
+		struct v4l2_pix_format pix;
+		struct v4l2_fract timeperframe =
+			vdev->want_timeperframe;
+
+		rval = s_pix_parm(vdev, &pix, &vdev->pix, &timeperframe);
+		if (rval) {
 			dev_err(&vdev->vfd->dev,
-				"can't get current pix from sensor!\n");
-			goto out_vidioc_int_g_fmt_cap;
-		}
-		if (!vdev->vdev_sensor_config.sensor_isp) {
-			struct v4l2_pix_format pix = format.fmt.pix;
-			if (isp_s_fmt_cap(cam->isp, &pix, &format.fmt.pix)) {
-				dev_err(&vdev->vfd->dev,
-					"isp doesn't like the sensor!\n");
-				goto out_isp_s_fmt_cap;
-			}
+				"isp doesn't like the sensor!\n");
+			goto out_isp_s_fmt_cap;
 		}
-		vdev->pix = format.fmt.pix;
 	}
 
+out_no_pix:
 	mutex_unlock(&vdev->mutex);
 
-	if (first_user && vdev->daemon.file
-	    && omap34xxcam_daemon_req_hw_init(vdev)) {
-		mutex_lock(&vdev->mutex);
-		goto out_slave_power_set_standby;
+	if (first_user && vdev->daemon.file) {
+		rval = omap34xxcam_daemon_req_hw_init(vdev);
+		if (rval) {
+			mutex_lock(&vdev->mutex);
+			goto out_slave_power_set_standby;
+		}
 	}
 
 	file->private_data = fh;
@@ -1752,12 +1840,8 @@ static int omap34xxcam_release(struct in
 	if (vdev->streaming == file) {
 		isp_stop(isp);
 		videobuf_streamoff(&fh->vbq);
-		omap34xxcam_slave_power_set(
-			vdev, V4L2_POWER_STANDBY,
-			OMAP34XXCAM_SLAVE_POWER_SENSOR);
-		omap34xxcam_slave_power_suggest(
-			vdev, V4L2_POWER_STANDBY,
-			OMAP34XXCAM_SLAVE_POWER_LENS);
+		omap34xxcam_slave_power_set(vdev, V4L2_POWER_STANDBY,
+					    OMAP34XXCAM_SLAVE_POWER_ALL);
 		vdev->streaming = NULL;
 	}
 
@@ -1928,10 +2012,9 @@ static int omap34xxcam_device_register(s
 		}
 		vdev->cam->isp = isp;
 	}
-	rval = omap34xxcam_slave_power_set(vdev, V4L2_POWER_ON,
-					   1 << hwc.dev_type);
+	rval = vidioc_int_dev_init(s);
 	if (rval)
-		goto err_omap34xxcam_slave_power_set;
+		goto err_omap34xxcam_slave_init;
 	if (hwc.dev_type == OMAP34XXCAM_SLAVE_SENSOR) {
 		struct v4l2_format format;
 
@@ -1946,9 +2029,6 @@ static int omap34xxcam_device_register(s
 	if (hwc.dev_type == OMAP34XXCAM_SLAVE_SENSOR)
 		isp_put();
 
-	if (rval)
-		goto err;
-
 	/* Are we the first slave? */
 	if (vdev->slaves == 1) {
 		/* initialize the video_device struct */
@@ -1983,7 +2063,7 @@ static int omap34xxcam_device_register(s
 
 	return 0;
 
-err_omap34xxcam_slave_power_set:
+err_omap34xxcam_slave_init:
 	if (hwc.dev_type == OMAP34XXCAM_SLAVE_SENSOR)
 		isp_put();
 
@@ -2060,11 +2140,6 @@ static int __init omap34xxcam_init(void)
 		vdev->vdev_sensor =
 			vdev->vdev_lens =
 			vdev->vdev_flash = v4l2_int_device_dummy();
-#ifdef OMAP34XXCAM_POWEROFF_DELAY
-		setup_timer(&vdev->poweroff_timer,
-			    omap34xxcam_slave_power_timer, (unsigned long)vdev);
-		INIT_WORK(&vdev->poweroff_work, omap34xxcam_slave_power_work);
-#endif /* OMAP34XXCAM_POWEROFF_DELAY */
 
 		if (v4l2_int_device_register(m))
 			goto err;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/omap34xxcam.h kernel-2.6.28-20093908+0m5/drivers/media/video/omap34xxcam.h
--- kernel-2.6.28-20091602+0m5/drivers/media/video/omap34xxcam.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/omap34xxcam.h	2012-12-16 13:13:01.668330147 +0100
@@ -60,8 +60,6 @@
 
 #define OMAP34XXCAM_VIDEODEVS		4
 
-/* #define OMAP34XXCAM_POWEROFF_DELAY (2 * HZ) */
-
 struct omap34xxcam_device;
 struct omap34xxcam_videodev;
 
@@ -142,13 +140,6 @@ struct omap34xxcam_videodev {
 	int index;
 	atomic_t users;
 	enum v4l2_power power_state[OMAP34XXCAM_SLAVE_FLASH + 1];
-#ifdef OMAP34XXCAM_POWEROFF_DELAY
-	enum v4l2_power power_state_wish;
-	int power_state_mask;
-	struct timer_list poweroff_timer;
-	struct work_struct poweroff_work;
-#endif /* OMAP34XXCAM_POWEROFF_DELAY */
-
 #define vdev_sensor_config slave_config[OMAP34XXCAM_SLAVE_SENSOR].u.sensor
 #define vdev_lens_config slave_config[OMAP34XXCAM_SLAVE_LENS].u.lens
 #define vdev_flash_config slave_config[OMAP34XXCAM_SLAVE_FLASH].u.flash
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/smia-sensor.c kernel-2.6.28-20093908+0m5/drivers/media/video/smia-sensor.c
--- kernel-2.6.28-20091602+0m5/drivers/media/video/smia-sensor.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/smia-sensor.c	2012-12-16 13:13:01.672330147 +0100
@@ -75,8 +75,7 @@ static int smia_ioctl_enum_framesizes(st
 				      struct v4l2_frmsizeenum *frm);
 static int smia_ioctl_enum_frameintervals(struct v4l2_int_device *s,
 					  struct v4l2_frmivalenum *frm);
-static int smia_ioctl_enum_slaves(struct v4l2_int_device *s,
-				  struct v4l2_slave_info *si);
+static int smia_ioctl_dev_init(struct v4l2_int_device *s);
 
 static struct v4l2_int_ioctl_desc smia_ioctl_desc[] = {
 	{ vidioc_int_enum_fmt_cap_num,
@@ -105,8 +104,8 @@ static struct v4l2_int_ioctl_desc smia_i
 	  (v4l2_int_ioctl_func *)smia_ioctl_enum_framesizes },
 	{ vidioc_int_enum_frameintervals_num,
 	  (v4l2_int_ioctl_func *)smia_ioctl_enum_frameintervals },
-	{ vidioc_int_enum_slaves_num,
-	  (v4l2_int_ioctl_func *)smia_ioctl_enum_slaves },
+	{ vidioc_int_dev_init_num,
+	  (v4l2_int_ioctl_func *)smia_ioctl_dev_init },
 };
 
 static struct v4l2_int_slave smia_slave = {
@@ -199,15 +198,28 @@ static int smia_exposure_rows_to_us(stru
 	return (smia_get_row_time(sensor) * rows + (1 << 7)) >> 8;
 }
 
+static int smia_stream_on(struct v4l2_int_device *s)
+{
+	struct smia_sensor *sensor = s->priv;
+	return smia_i2c_write_reg(sensor->i2c_client,
+				  SMIA_REG_8BIT, 0x0100, 0x01);
+}
+
+static int smia_stream_off(struct v4l2_int_device *s)
+{
+	struct smia_sensor *sensor = s->priv;
+	return smia_i2c_write_reg(sensor->i2c_client,
+				  SMIA_REG_8BIT, 0x0100, 0x00);
+}
+
 /* Must be called with power already enabled on the sensor */
 static int smia_configure(struct v4l2_int_device *s)
 {
 	struct smia_sensor *sensor = s->priv;
 	int rval;
 
-	rval = smia_i2c_reglist_find_write(sensor->i2c_client,
-					   sensor->meta_reglist,
-					   SMIA_REGLIST_POWERON);
+	rval = smia_i2c_write_regs(sensor->i2c_client,
+				   sensor->current_reglist->regs);
 	if (rval)
 		goto fail;
 
@@ -222,12 +234,22 @@ static int smia_configure(struct v4l2_in
 	if (rval)
 		goto fail;
 
-	rval = smia_i2c_write_regs(sensor->i2c_client,
-				   sensor->current_reglist->regs);
+	/*
+	 * FIXME: remove stream_off from here as soon as camera-firmware
+	 * is modified to not enable streaming automatically.
+	 */
+	rval = smia_stream_off(s);
 	if (rval)
 		goto fail;
 
-	return rval;
+	rval = sensor->platform_data->configure_interface(
+		s,
+		sensor->current_reglist->mode.window_width,
+		sensor->current_reglist->mode.window_height);
+	if (rval)
+		goto fail;
+
+	return 0;
 
 fail:
 	dev_err(&sensor->i2c_client->dev, "sensor configuration failed\n");
@@ -235,30 +257,6 @@ fail:
 
 }
 
-static int smia_setup_if(struct v4l2_int_device *s)
-{
-	struct smia_sensor *sensor = s->priv;
-	int rval;
-	unsigned int hz;
-
-	if (sensor->current_reglist) {
-		rval = sensor->platform_data->configure_interface(
-			s,
-			sensor->current_reglist->mode.window_width,
-			sensor->current_reglist->mode.window_height);
-		if (rval)
-			return rval;
-		hz = sensor->current_reglist->mode.ext_clock;
-	} else {
-		hz = DEFAULT_XCLK;
-	}
-
-	sensor->platform_data->set_xclk(s, hz);
-	udelay(16*1000000/hz+1);		/* Wait 16 clocks */
-
-	return 0;
-}
-
 static int smia_power_off(struct v4l2_int_device *s)
 {
 	struct smia_sensor *sensor = s->priv;
@@ -274,15 +272,21 @@ static int smia_power_off(struct v4l2_in
 static int smia_power_on(struct v4l2_int_device *s)
 {
 	struct smia_sensor *sensor = s->priv;
+	struct smia_reglist *reglist = NULL;
 	int rval;
+	unsigned int hz = DEFAULT_XCLK;
+
+	if (sensor->meta_reglist) {
+		reglist = smia_reglist_find_type(sensor->meta_reglist,
+						 SMIA_REGLIST_POWERON);
+		hz = reglist->mode.ext_clock;
+	}
 
 	rval = sensor->platform_data->power_on(s);
 	if (rval)
 		goto out;
 
-	rval = smia_setup_if(s);
-	if (rval)
-		goto out;
+	sensor->platform_data->set_xclk(s, hz);
 
 	/*
 	 * At least 10 ms is required between xshutdown up and first
@@ -291,6 +295,13 @@ static int smia_power_on(struct v4l2_int
 	 */
 	msleep(10);
 
+	if (reglist) {
+		rval = smia_i2c_write_regs(sensor->i2c_client,
+					   reglist->regs);
+		if (rval)
+			goto out;
+	}
+
 out:
 	if (rval)
 		smia_power_off(s);
@@ -473,13 +484,17 @@ static int smia_ioctl_s_parm(struct v4l2
 	return -EINVAL;
 }
 
-static int smia_dev_init(struct v4l2_int_device *s)
+static int smia_ioctl_dev_init(struct v4l2_int_device *s)
 {
 	struct smia_sensor *sensor = s->priv;
 	char name[FIRMWARE_NAME_MAX];
 	int model_id, revision_number, manufacturer_id, smia_version;
 	int i, rval;
 
+	rval = smia_power_on(s);
+	if (rval)
+		return -ENODEV;
+
 	/* Read and check sensor identification registers */
 	if (smia_i2c_read_reg(sensor->i2c_client, SMIA_REG_16BIT,
 			      REG_MODEL_ID, &model_id)
@@ -489,7 +504,8 @@ static int smia_dev_init(struct v4l2_int
 				 REG_MANUFACTURER_ID, &manufacturer_id)
 	    || smia_i2c_read_reg(sensor->i2c_client, SMIA_REG_8BIT,
 				 REG_SMIA_VERSION, &smia_version)) {
-		return -ENODEV;
+		rval = -ENODEV;
+		goto out_poweroff;
 	}
 
 	sensor->model_id        = model_id;
@@ -503,7 +519,8 @@ static int smia_dev_init(struct v4l2_int
 			"unknown sensor 0x%04x detected (smia ver %i.%i)\n",
 			sensor->model_id,
 			sensor->smia_version / 10, sensor->smia_version % 10);
-		return -ENODEV;
+		rval = -ENODEV;
+		goto out_poweroff;
 	}
 
 	/* Update identification string */
@@ -525,7 +542,8 @@ static int smia_dev_init(struct v4l2_int
 			     &sensor->i2c_client->dev)) {
 		dev_err(&sensor->i2c_client->dev,
 			"can't load firmware %s\n", name);
-		return -ENODEV;
+		rval = -ENODEV;
+		goto out_poweroff;
 	}
 
 	sensor->meta_reglist =
@@ -551,54 +569,79 @@ static int smia_dev_init(struct v4l2_int
 		goto out_release;
 	}
 
-	sensor->dev_init_done = true;
+	rval = smia_power_off(s);
+	if (rval)
+		goto out_release;
 
 	return 0;
 
 out_release:
 	release_firmware(sensor->fw);
+out_poweroff:
 	sensor->meta_reglist = NULL;
 	sensor->fw = NULL;
+	smia_power_off(s);
 
 	return rval;
 }
 
-static int smia_ioctl_s_power(struct v4l2_int_device *s, enum v4l2_power state)
+static int smia_ioctl_s_power(struct v4l2_int_device *s,
+				enum v4l2_power new_state)
 {
 	struct smia_sensor *sensor = s->priv;
 	int rval = 0;
 
-	if (state != V4L2_POWER_ON)
-		state = V4L2_POWER_OFF;
+	/*
+	 * Map STANDBY to OFF mode: there is no reason to keep the sensor
+	 * powered if not streaming.
+	 */
+	if (new_state == V4L2_POWER_STANDBY)
+		new_state = V4L2_POWER_OFF;
 
-	if (sensor->power == state)
+	/* If we are already in this mode, do nothing */
+	if (sensor->power == new_state)
 		return 0;
 
-	if (state == V4L2_POWER_ON) {
+	/* Disable power if so requested (it was enabled) */
+	if (new_state == V4L2_POWER_OFF) {
+		rval = smia_stream_off(s);
+		if (rval)
+			dev_err(&sensor->i2c_client->dev,
+				"can not stop streaming\n");
+		rval = smia_power_off(s);
+		goto out;
+	}
+
+	/* Either STANDBY or ON requested */
+
+	/* Enable power and move to standby if it was off */
+	if (sensor->power == V4L2_POWER_OFF) {
 		rval = smia_power_on(s);
 		if (rval)
-			return rval;
-		if (!sensor->dev_init_done) {
-			rval = smia_dev_init(s);
-			if (rval)
-				goto out_poweroff;
-		}
+			goto out;
+	}
+
+	/* Now sensor is powered (standby or streaming) */
+
+	if (new_state == V4L2_POWER_ON) {
+		/* Standby -> streaming */
 		rval = smia_configure(s);
-		if (rval)
-			goto out_poweroff;
+		if (rval) {
+			smia_stream_off(s);
+			if (sensor->power == V4L2_POWER_OFF)
+				smia_power_off(s);
+			goto out;
+		}
+		rval = smia_stream_on(s);
 	} else {
-		/* V4L2_POWER_OFF */
-		rval = smia_power_off(s);
-		if (rval)
-			return rval;
+		/* Streaming -> standby */
+		rval = smia_stream_off(s);
 	}
 
-	sensor->power = state;
-	return 0;
+out:
+	if (rval == 0)
+		sensor->power = new_state;
 
-out_poweroff:
-	sensor->power = V4L2_POWER_OFF;
-	smia_power_off(s);
 	return rval;
 }
 
@@ -625,43 +668,27 @@ static int smia_ioctl_enum_frameinterval
 	return smia_reglist_enum_frameintervals(sensor->meta_reglist, frm);
 }
 
-static int smia_ioctl_enum_slaves(struct v4l2_int_device *s,
-			     struct v4l2_slave_info *si)
-{
-	struct smia_sensor *sensor = s->priv;
-
-	strlcpy(si->driver, SMIA_SENSOR_NAME, sizeof(si->driver));
-	strlcpy(si->bus_info, "ccp2", sizeof(si->bus_info));
-	snprintf(si->version, sizeof(si->version), "%02x",
-		 sensor->revision_number);
-
-	return 0;
-}
-
 #ifdef CONFIG_PM
 
 static int smia_suspend(struct i2c_client *client, pm_message_t mesg)
 {
-	struct smia_sensor *sensor = i2c_get_clientdata(client);
-
-	if (sensor->power == V4L2_POWER_OFF)
-		return 0;
+	struct smia_sensor *sensor = dev_get_drvdata(&client->dev);
+	enum v4l2_power resume_state = sensor->power;
+	int rval;
 
-	return smia_power_off(sensor->v4l2_int_device);
+	rval = smia_ioctl_s_power(sensor->v4l2_int_device, V4L2_POWER_OFF);
+	if (rval == 0)
+		sensor->power = resume_state;
+	return rval;
 }
 
 static int smia_resume(struct i2c_client *client)
 {
-	struct smia_sensor *sensor = i2c_get_clientdata(client);
-	enum v4l2_power resume_power;
+	struct smia_sensor *sensor = dev_get_drvdata(&client->dev);
+	enum v4l2_power resume_state = sensor->power;
 
-	if (sensor->power == V4L2_POWER_OFF)
-		return 0;
-
-	resume_power = sensor->power;
 	sensor->power = V4L2_POWER_OFF;
-
-	return smia_ioctl_s_power(sensor->v4l2_int_device, resume_power);
+	return smia_ioctl_s_power(sensor->v4l2_int_device, resume_state);
 }
 
 #else
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/smia-sensor.h kernel-2.6.28-20093908+0m5/drivers/media/video/smia-sensor.h
--- kernel-2.6.28-20091602+0m5/drivers/media/video/smia-sensor.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/smia-sensor.h	2012-12-16 13:13:01.672330147 +0100
@@ -62,7 +62,6 @@ struct smia_sensor {
 	const struct firmware *fw;
 	struct smia_meta_reglist *meta_reglist;
 
-	bool dev_init_done;
 	enum v4l2_power power;
 };
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/media/video/videobuf-dma-sg.c kernel-2.6.28-20093908+0m5/drivers/media/video/videobuf-dma-sg.c
--- kernel-2.6.28-20091602+0m5/drivers/media/video/videobuf-dma-sg.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/media/video/videobuf-dma-sg.c	2012-12-16 13:13:01.672330147 +0100
@@ -58,9 +58,10 @@ videobuf_vmalloc_to_sg(unsigned char *vi
 	struct page *pg;
 	int i;
 
-	sglist = kcalloc(nr_pages, sizeof(struct scatterlist), GFP_KERNEL);
+	sglist = vmalloc(nr_pages * sizeof(*sglist));
 	if (NULL == sglist)
 		return NULL;
+	memset(sglist, 0, nr_pages * sizeof(*sglist));
 	sg_init_table(sglist, nr_pages);
 	for (i = 0; i < nr_pages; i++, virt += PAGE_SIZE) {
 		pg = vmalloc_to_page(virt);
@@ -72,7 +73,7 @@ videobuf_vmalloc_to_sg(unsigned char *vi
 	return sglist;
 
  err:
-	kfree(sglist);
+	vfree(sglist);
 	return NULL;
 }
 
@@ -84,7 +85,7 @@ videobuf_pages_to_sg(struct page **pages
 
 	if (NULL == pages[0])
 		return NULL;
-	sglist = kmalloc(nr_pages * sizeof(*sglist), GFP_KERNEL);
+	sglist = vmalloc(nr_pages * sizeof(*sglist));
 	if (NULL == sglist)
 		return NULL;
 	sg_init_table(sglist, nr_pages);
@@ -104,12 +105,12 @@ videobuf_pages_to_sg(struct page **pages
 
  nopage:
 	dprintk(2,"sgl: oops - no page\n");
-	kfree(sglist);
+	vfree(sglist);
 	return NULL;
 
  highmem:
 	dprintk(2,"sgl: oops - highmem page\n");
-	kfree(sglist);
+	vfree(sglist);
 	return NULL;
 }
 
@@ -230,7 +231,7 @@ int videobuf_dma_map(struct videobuf_que
 						(dma->vmalloc,dma->nr_pages);
 	}
 	if (dma->bus_addr) {
-		dma->sglist = kmalloc(sizeof(struct scatterlist), GFP_KERNEL);
+		dma->sglist = vmalloc(sizeof(*dma->sglist));
 		if (NULL != dma->sglist) {
 			dma->sglen  = 1;
 			sg_dma_address(&dma->sglist[0]) = dma->bus_addr & PAGE_MASK;
@@ -248,7 +249,7 @@ int videobuf_dma_map(struct videobuf_que
 		if (0 == dma->sglen) {
 			printk(KERN_WARNING
 			       "%s: videobuf_map_sg failed\n",__func__);
-			kfree(dma->sglist);
+			vfree(dma->sglist);
 			dma->sglist = NULL;
 			dma->sglen = 0;
 			return -EIO;
@@ -274,7 +275,7 @@ int videobuf_dma_unmap(struct videobuf_q
 
 	dma_unmap_sg(q->dev, dma->sglist, dma->nr_pages, dma->direction);
 
-	kfree(dma->sglist);
+	vfree(dma->sglist);
 	dma->sglist = NULL;
 	dma->sglen = 0;
 	return 0;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mfd/twl4030-core.c kernel-2.6.28-20093908+0m5/drivers/mfd/twl4030-core.c
--- kernel-2.6.28-20091602+0m5/drivers/mfd/twl4030-core.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mfd/twl4030-core.c	2012-12-16 13:13:01.672330147 +0100
@@ -362,7 +362,7 @@ EXPORT_SYMBOL(twl4030_i2c_read);
 int twl4030_i2c_write_u8(u8 mod_no, u8 value, u8 reg)
 {
 
-	/* 2 bytes offset 1 contains the data offset 0 is used by i2c_write */
+	/* 2 bytes: offset 1 contains the data, offset 0 is used by i2c_write */
 	u8 temp_buffer[2] = { 0 };
 	/* offset 1 contains the data */
 	temp_buffer[1] = value;
@@ -786,7 +786,7 @@ twl4030_probe(struct i2c_client *client,
 			twl->client = i2c_new_dummy(client->adapter,
 					twl->address);
 			if (!twl->client) {
-				dev_err(&twl->client->dev,
+				dev_err(&client->dev,
 					"can't attach client %d\n", i);
 				status = -ENOMEM;
 				goto fail;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mfd/twl4030-power.c kernel-2.6.28-20093908+0m5/drivers/mfd/twl4030-power.c
--- kernel-2.6.28-20091602+0m5/drivers/mfd/twl4030-power.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mfd/twl4030-power.c	2012-12-16 13:13:01.672330147 +0100
@@ -25,6 +25,7 @@
 
 #include <linux/module.h>
 #include <linux/pm.h>
+#include <linux/delay.h>
 #include <linux/i2c/twl4030.h>
 #include <linux/platform_device.h>
 
@@ -72,36 +73,37 @@ static u8 triton_next_free_address = 0x2
 
 #define DEVGROUP_OFFSET		0
 #define TYPE_OFFSET		1
+#define REMAP_OFFSET		2
 
-static int __initdata res_config_addrs[] = {
-	[1] = 0x17,
-	[2] = 0x1b,
-	[3] = 0x1f,
-	[4] = 0x23,
-	[5] = 0x27,
-	[6] = 0x2b,
-	[7] = 0x2f,
-	[8] = 0x33,
-	[9] = 0x37,
-	[10] = 0x3b,
-	[11] = 0x3f,
-	[12] = 0x43,
-	[13] = 0x47,
-	[14] = 0x4b,
-	[15] = 0x55,
-	[16] = 0x63,
-	[17] = 0x71,
-	[18] = 0x74,
-	[19] = 0x77,
-	[20] = 0x7a,
-	[21] = 0x7f,
-	[22] = 0x82,
-	[23] = 0x85,
-	[24] = 0x88,
-	[25] = 0x8b,
-	[26] = 0x8e,
-	[27] = 0x91,
-	[28] = 0x94,
+static int res_config_addrs[] = {
+	[RES_VAUX1] 	= 0x17,
+	[RES_VAUX2] 	= 0x1b,
+	[RES_VAUX3] 	= 0x1f,
+	[RES_VAUX4] 	= 0x23,
+	[RES_VMMC1] 	= 0x27,
+	[RES_VMMC2] 	= 0x2b,
+	[RES_VPLL1] 	= 0x2f,
+	[RES_VPLL2] 	= 0x33,
+	[RES_VSIM] 	= 0x37,
+	[RES_VDAC] 	= 0x3b,
+	[RES_VINTANA1] 	= 0x3f,
+	[RES_VINTANA2] 	= 0x43,
+	[RES_VINTDIG] 	= 0x47,
+	[RES_VIO] 	= 0x4b,
+	[RES_VDD1] 	= 0x55,
+	[RES_VDD2] 	= 0x63,
+	[RES_VUSB_1v5] 	= 0x71,
+	[RES_VUSB_1v8] 	= 0x74,
+	[RES_VUSB_3v1] 	= 0x77,
+	[RES_VUSBCP] 	= 0x7a,
+	[RES_REGEN] 	= 0x7f,
+	[RES_NRES_PWRON] = 0x82,
+	[RES_CLKEN] 	= 0x85,
+	[RES_SYSEN] 	= 0x88,
+	[RES_HFCLKOUT] 	= 0x8b,
+	[RES_32KCLKOUT] = 0x8e,
+	[RES_RESET] 	= 0x91,
+	[RES_Main_Ref] 	= 0x94,
 };
 
 static int __init twl4030_write_script_byte(u8 address, u8 byte)
@@ -155,12 +157,16 @@ static int __init config_wakeup3_sequenc
 {
 
 	int err = 0;
+	u8 data;
 
 	/* Set SLEEP to ACTIVE SEQ address for P3 */
 	err |= twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER, address,
 				  R_SEQ_ADD_S2A3);
 
-	err |= twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER, LVL_WAKEUP,
+	err |= twl4030_i2c_read_u8(TWL4030_MODULE_PM_MASTER, &data,
+					R_P3_SW_EVENTS);
+	data |= LVL_WAKEUP;
+	err |= twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER, data,
 					R_P3_SW_EVENTS);
 	if (err)
 		printk(KERN_ERR "TWL4030 wakeup sequence for P3" \
@@ -172,19 +178,26 @@ static int __init config_wakeup3_sequenc
 static int __init config_wakeup12_sequence(u8 address)
 {
 	int err = 0;
+	u8 data;
 
 	/* Set SLEEP to ACTIVE SEQ address for P1 and P2 */
 	err |= twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER, address,
 				  R_SEQ_ADD_SA12);
 
-	/* P1/P2/P3 LVL_WAKEUP should be on LEVEL */
-	err |= twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER, LVL_WAKEUP,
+	/* P1/P2 LVL_WAKEUP should be on LEVEL */
+	err |= twl4030_i2c_read_u8(TWL4030_MODULE_PM_MASTER, &data,
+					R_P1_SW_EVENTS);
+	data |= LVL_WAKEUP;
+	err |= twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER, data,
 					R_P1_SW_EVENTS);
-	err |= twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER, LVL_WAKEUP,
+
+	err |= twl4030_i2c_read_u8(TWL4030_MODULE_PM_MASTER, &data,
+					R_P2_SW_EVENTS);
+	data |= LVL_WAKEUP;
+	err |= twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER, data,
 					R_P2_SW_EVENTS);
 
 	if (machine_is_omap_3430sdp() || machine_is_omap_ldp()) {
-		u8 data;
 		/* Disabling AC charger effect on sleep-active transitions */
 		err |= twl4030_i2c_read_u8(TWL4030_MODULE_PM_MASTER, &data,
 						R_CFG_P1_TRANSITION);
@@ -204,14 +217,6 @@ static int __init config_sleep_sequence(
 {
 	int err = 0;
 
-	/*
-	 * CLKREQ is pulled high on the 2430SDP, therefore, we need to take
-	 * it out of the HFCLKOUT DEV_GRP for P1 else HFCLKOUT can't be stopped.
-	 */
-
-	err |= twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
-				  0x20, R_HFCLKOUT_DEV_GRP);
-
 	/* Set ACTIVE to SLEEP SEQ address in T2 memory*/
 	err |= twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER, address,
 				  R_SEQ_ADD_A2S);
@@ -261,6 +266,7 @@ static int __init load_triton_script(str
 {
 	u8 address = triton_next_free_address;
 	int err;
+	int i;
 
 	err = twl4030_write_script(address, tscript->script, tscript->size);
 	if (err)
@@ -268,51 +274,89 @@ static int __init load_triton_script(str
 
 	triton_next_free_address += tscript->size;
 
-	if (tscript->flags & TRITON_WRST_SCRIPT)
-		err |= config_warmreset_sequence(address);
+	for (i = 0; i < tscript->number_of_events; i++) {
 
-	if (tscript->flags & TRITON_WAKEUP12_SCRIPT)
-		err |= config_wakeup12_sequence(address);
+		/* Check if script is going beyond last valid address */
+		if (address + tscript->size > END_OF_SCRIPT) {
 
-	if (tscript->flags & TRITON_WAKEUP3_SCRIPT)
-		err |= config_wakeup3_sequence(address);
+			WARN(1, "TWL4030 script event %d" \
+				 " do not fit in memory\n"
+				, tscript->events[i].event);
+			return -EINVAL;
+		}
+
+		/* Check if event pointer is in script area */
+		if (tscript->events[i].offset >= tscript->size) {
 
-	if (tscript->flags & TRITON_SLEEP_SCRIPT)
-		err |= config_sleep_sequence(address);
+			WARN(1,	"TWL4030 script event %d has invalid start" \
+				" at 0x%x in the script ending at 0x%x\n",
+				 tscript->events[i].event,
+				 address + tscript->events[i].offset,
+				 address + tscript->size);
+			return -EINVAL;
+		}
 
+		switch (tscript->events[i].event) {
+		case TRITON_WRST:
+			err |= config_warmreset_sequence(address
+						+ tscript->events[i].offset);
+			break;
+		case TRITON_WAKEUP12:
+			err |= config_wakeup12_sequence(address
+						+ tscript->events[i].offset);
+			break;
+		case TRITON_WAKEUP3:
+			err |= config_wakeup3_sequence(address
+						+ tscript->events[i].offset);
+			break;
+		case TRITON_SLEEP:
+			err |= config_sleep_sequence(address
+						+ tscript->events[i].offset);
+			break;
+		default:
+			WARN(1, "Event number %d unknown\n"
+				, tscript->events[i].event);
+			return  -EINVAL;
+		}
+	}
 	return err;
 }
 
-static void __init twl4030_configure_resource(struct twl4030_resconfig *rconfig)
+static int __init twl4030_configure_resource(struct twl4030_resconfig *rconfig)
 {
 	int rconfig_addr;
+	int err;
 	u8 type;
 
 	if (rconfig->resource > NUM_OF_RESOURCES) {
 		printk(KERN_ERR
 			"TWL4030 Resource %d does not exist\n",
 			rconfig->resource);
-		return;
+		return -EINVAL;
 	}
 
 	rconfig_addr = res_config_addrs[rconfig->resource];
 
 	/* Set resource group */
-
-	if (rconfig->devgroup >= 0)
-		twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
+	if (rconfig->devgroup >= 0) {
+		err = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
 					rconfig->devgroup << 5,
 					rconfig_addr + DEVGROUP_OFFSET);
+		if (err < 0) {
+			printk(KERN_ERR
+				"TWL4030 failed to program devgroup");
+			return err;
+		}
+	}
 
 	/* Set resource types */
-
-	if (twl4030_i2c_read_u8(TWL4030_MODULE_PM_RECEIVER,
-					&type,
-					rconfig_addr + TYPE_OFFSET) < 0) {
+	err = twl4030_i2c_read_u8(TWL4030_MODULE_PM_RECEIVER, &type,
+				       rconfig_addr + TYPE_OFFSET);
+	if (err < 0) {
 		printk(KERN_ERR
-			"TWL4030 Resource %d type could not read\n",
-			rconfig->resource);
-		return;
+		       "TWL4030 Resource %d type could not read\n",
+		       rconfig->resource);
+		return err;
 	}
 
 	if (rconfig->type >= 0) {
@@ -325,9 +369,103 @@ static void __init twl4030_configure_res
 		type |= rconfig->type2 << 3;
 	}
 
-	twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
+	err = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
 				type, rconfig_addr + TYPE_OFFSET);
+	if (err < 0) {
+		printk(KERN_ERR
+		       "TWL4030 failed to program resource type");
+		return err;
+	}
+
+	if (rconfig->remap >= 0) {
+		err = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
+				rconfig->remap,
+				rconfig_addr + REMAP_OFFSET);
+		if (err < 0) {
+			printk(KERN_ERR "TWL4030 failed to program remap");
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+struct twl4030_reg_data {
+	int usecount;
+	u8 resource;
+	u8 base;
+	u8 offstate;
+	u8 initdone;
+	int delay;
+};
+struct twl4030_reg_data twl4030_custom_regs[] = {
+	{ 0, RES_VAUX1, TWL4030_VAUX1_DEV_GRP, 0x88, 0, 500 },
+	{ 0, RES_VMMC2, TWL4030_VMMC2_DEV_GRP, 0x88, 0, 100 },
+	{ 0, 0, 0, 0, 0 },
+};
+static DEFINE_MUTEX(reg_mutex);
+
+static int twl4030_set_regulator_state(int res, int enable)
+{
+	u8 val;
+	int ret;
+	struct twl4030_reg_data *reg_data = twl4030_custom_regs;
+
+	while (1) {
+		if (!reg_data->resource)
+			return -EINVAL;
+		if (reg_data->resource == res)
+			break;
+		reg_data++;
+	}
+	if (enable && !(reg_data->usecount++))
+		val = 0xee;
+	else if (!enable && !(--reg_data->usecount))
+		val = reg_data->offstate;
+	else
+		return 0;
+
+	ret = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
+			val, reg_data->base + 2);
+
+	if (!ret && !reg_data->initdone) {
+		ret = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
+			0, reg_data->base);
+		if (!ret)
+			reg_data->initdone = 1;
+	}
+
+	if (ret) {
+		if (enable)
+			reg_data->usecount--;
+		else
+			reg_data->usecount++;
+	}
+	/* Wait until voltage stabilizes */
+	if (enable)
+		udelay(reg_data->delay);
+	return ret;
+}
+
+int twl4030_enable_regulator(int res)
+{
+	int ret;
+	mutex_lock(&reg_mutex);
+	ret = twl4030_set_regulator_state(res, 1);
+	mutex_unlock(&reg_mutex);
+	return ret;
+}
+EXPORT_SYMBOL(twl4030_enable_regulator);
+
+int twl4030_disable_regulator(int res)
+{
+	int ret;
+	mutex_lock(&reg_mutex);
+	ret = twl4030_set_regulator_state(res, 0);
+	mutex_unlock(&reg_mutex);
+	return ret;
 }
+EXPORT_SYMBOL(twl4030_disable_regulator);
 
 void __init twl4030_power_init(struct twl4030_power_data *triton2_scripts)
 {
@@ -345,15 +483,22 @@ void __init twl4030_power_init(struct tw
 
 	for (i = 0; i < triton2_scripts->scripts_size; i++) {
 		err = load_triton_script(triton2_scripts->scripts[i]);
-		if (err)
+		if (err < 0) {
+			printk(KERN_ERR "TWL4030 failed to load scripts");
 			break;
+		}
 	}
 
 	resconfig = triton2_scripts->resource_config;
 	if (resconfig) {
 		while (resconfig->resource) {
-			twl4030_configure_resource(resconfig);
+			err = twl4030_configure_resource(resconfig);
 			resconfig++;
+			if (err < 0) {
+				printk(KERN_ERR
+				       "TWL4030 failed to configure resource");
+				break;
+			}
 		}
 	}
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/misc/cmt-speech/cs-core.c kernel-2.6.28-20093908+0m5/drivers/misc/cmt-speech/cs-core.c
--- kernel-2.6.28-20091602+0m5/drivers/misc/cmt-speech/cs-core.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/misc/cmt-speech/cs-core.c	2012-12-16 13:13:01.672330147 +0100
@@ -45,7 +45,7 @@
 #include "cs-core.h"
 #include "cs-ssi.h"
 
-#define CS_MMAP_SIZE	4096
+#define CS_MMAP_SIZE	PAGE_SIZE
 
 struct char_queue {
 	struct list_head	list;
@@ -319,8 +319,7 @@ static int cs_char_open(struct inode *in
 		goto out;
 	}
 
-	cs_char_data.mmap_base  = (unsigned long)
-				kmalloc(CS_MMAP_SIZE, GFP_ATOMIC);
+	cs_char_data.mmap_base = get_zeroed_page(GFP_ATOMIC);
 	if (!cs_char_data.mmap_base) {
 		pr_err("CS_SSI: Shared memory allocation failed.\n");
 		ret = -ENOMEM;
@@ -351,7 +350,7 @@ static int cs_char_release(struct inode
 
 	spin_lock_bh(&cs_char_data.lock);
 
-	kfree((void *)cs_char_data.mmap_base);
+	free_page(cs_char_data.mmap_base);
 	cs_char_data.mmap_base = 0;
 	cs_char_data.mmap_size = 0;
 	cs_char_data.opened = 0;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/misc/cmt-speech/cs-ssi.c kernel-2.6.28-20093908+0m5/drivers/misc/cmt-speech/cs-ssi.c
--- kernel-2.6.28-20091602+0m5/drivers/misc/cmt-speech/cs-ssi.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/misc/cmt-speech/cs-ssi.c	2012-12-16 13:13:01.672330147 +0100
@@ -500,8 +500,11 @@ int cs_ssi_buf_config(struct cs_buffer_c
 
 	spin_unlock_bh(&ssi_iface.lock);
 
-	if (ssi_iface.buf_size)
+	if (ssi_iface.buf_size) {
+		local_bh_disable();
 		cs_ssi_read_on_data();
+		local_bh_enable();
+	}
 
 error:
 	DLEAVE(r);
@@ -540,7 +543,9 @@ int cs_ssi_start(unsigned long mmap_base
 
 	spin_unlock_bh(&ssi_iface.lock);
 
+	local_bh_disable();
 	cs_ssi_read_on_control();
+	local_bh_enable();
 
 error:
 	DLEAVE(err);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/misc/mcsaab/Kconfig kernel-2.6.28-20093908+0m5/drivers/misc/mcsaab/Kconfig
--- kernel-2.6.28-20091602+0m5/drivers/misc/mcsaab/Kconfig	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/misc/mcsaab/Kconfig	2012-12-16 13:13:01.672330147 +0100
@@ -8,12 +8,3 @@ config SSI_MCSAAB_IMP
 	  If you say Y here, you will enable the SSI McSAAB improved protocol.
 
 	  If unsure, say Y, or else you will not be able to connect to the CMT.
-
-config SSI_MCSAAB_DEBUG
-	bool "Debug on the SSI McSAAB improved protocol"
-	depends on SSI_MCSAAB_IMP && DEBUG_KERNEL
-	default n
-	---help---
-	  Enable the debug information in the SSI McSAAB improved protocol.
-
-          If unsure, say N.
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/misc/mcsaab/ssi_mcsaab_imp.c kernel-2.6.28-20093908+0m5/drivers/misc/mcsaab/ssi_mcsaab_imp.c
--- kernel-2.6.28-20091602+0m5/drivers/misc/mcsaab/ssi_mcsaab_imp.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/misc/mcsaab/ssi_mcsaab_imp.c	2012-12-16 13:13:01.672330147 +0100
@@ -31,8 +31,8 @@
 #include <linux/if_arp.h>
 #include <linux/if_phonet.h>
 #include <linux/ssi_driver_if.h>
-
-#define __HANDSHAKE_FQ_CHANGE__	/* FIXME: HACK to be removed */
+#include <linux/gpio.h>
+#include <linux/irq.h>
 
 #define	MCSAAB_IMP_VERSION	"2.0-rc1"
 #define MCSAAB_IMP_DESC		"SSI McSAAB Improved protocol implementeation"
@@ -52,7 +52,6 @@
  * If this is not done clock management in the HW driver will fail.
  */
 #define WAKEDOWN_TEST	0x04
-#define READY_SENT	0x08
 
 /* end ssi_proto flags */
 
@@ -65,32 +64,16 @@
 #define SSI_MAX_MTU	65535
 #define SSI_DEFAULT_MTU	4000
 
-#define CMT_DEFAULT_TX_SPEED	110	/* 110 Mbits/s */
-
 #define WD_TIMEOUT	2000	/* 500 msecs */
+#define KA_TIMEOUT	15	/* 15 msecs */
 
 #define PN_MEDIA_SOS	21
-/*
- * McSAAB DEBUG
- */
-#ifdef SSI_DEBUG
-#define DBG(fmt, args...)	printk(KERN_DEBUG LOG_NAME "%s: " fmt "\n",\
-							__func__, ##args)
-#define DBG_DEV(dev, fmt, args...) dev_dbg(dev, LOG_NAME "%s: " fmt "\n",\
-							__func__, ##args)
-#define DBG_DUMP(buf, len)      print_hex_dump_bytes(LOG_NAME,\
-					DUMP_PREFIX_ADDRESS, buf, len)
-#else
-#define DBG(fmt, args...)		do {} while (0)
-#define DBG_DEV(dev, fmt, args...)	do {} while (0)
-#define DBG_DUMP(buf, len)		do {} while (0)
-#endif /* SSI_DEBUG */
 
 /*
  * McSAAB command definitions
  */
-#define COMMAND(data)	(data >> 28)
-#define PAYLOAD(data)	(data & 0x0fffffff)
+#define COMMAND(data)	((data) >> 28)
+#define PAYLOAD(data)	((data) & 0x0fffffff)
 
 /* Commands */
 #define SW_BREAK	0x0
@@ -99,45 +82,40 @@
 #define WAKE_TEST_RES	0x3
 #define START_TRANS	0x4
 #define READY		0x5
-#define FQ_CHANGE_REQ	0x8
-#define FQ_CHANGE_DONE	0x9
-#define ACK		0xa
 #define DUMMY		0xc
 
 /* Payloads */
 #define RESERVED		0X0000000
 #define DATA_VERSION_MASK	0xff
-#define DATA_VERSION(data)	(data & DATA_VERSION_MASK)
+#define DATA_VERSION(data)	((data) & DATA_VERSION_MASK)
 #define DATA_RESULT_MASK	0X0f
-#define DATA_RESULT(data)	(data & DATA_RESULT_MASK)
+#define DATA_RESULT(data)	((data) & DATA_RESULT_MASK)
 #define WAKE_TEST_OK		0x0
 #define WAKE_TEST_FAILED	0x1
 #define PDU_LENGTH_MASK		0xffff
-#define PDU_LENGTH(data)	((data >> 8) & PDU_LENGTH_MASK)
+#define PDU_LENGTH(data)	(((data) >> 8) & PDU_LENGTH_MASK)
 #define MSG_ID_MASK		0xff
-#define MSG_ID(data)		(data & MSG_ID_MASK)
+#define MSG_ID(data)		((data) & MSG_ID_MASK)
 #define ACK_TO_CMD_MASK		0x0f
-#define ACK_TO_CMD(data)	(data & ACK_TO_CMD_MASK)
+#define ACK_TO_CMD(data)	((data) & ACK_TO_CMD_MASK)
 
 #define DUMMY_PAYLOAD		0xaaccaaa
 
-#define CMD(command, payload) ((command<<28) | (payload & 0x0fffffff))
+#define CMD(command, payload) (((command) << 28) | ((payload) & 0x0fffffff))
 
 /* Commands for the control channel (channel number 0) */
 #define SWBREAK_CMD			CMD(SW_BREAK, 0x000000)
 #define BOOT_INFO_REQ_CMD(verid) \
-				CMD(BOOT_INFO_REQ, verid & DATA_VERSION_MASK)
+				CMD(BOOT_INFO_REQ, (verid) & DATA_VERSION_MASK)
 #define BOOT_INFO_RESP_CMD(verid) \
-				CMD(BOOT_INFO_RESP, verid & DATA_VERSION_MASK)
+				CMD(BOOT_INFO_RESP, (verid) & DATA_VERSION_MASK)
 #define START_TRANS_CMD(pdu_len, message_id) \
-				CMD(START_TRANS, ((pdu_len << 8) | message_id))
+			CMD(START_TRANS, (((pdu_len) << 8) | (message_id)))
 #define READY_CMD			CMD(READY, RESERVED)
 #define FQ_CHANGE_REQ_CMD(max_tx_speed)	CMD(FQ_CHANGE_REQ, max_tx_speed)
 #define FQ_CHANGE_DONE_CMD		CMD(FQ_CHANGE_DONE, RESERVED)
-#define ACK_CMD(ack_cmd)		CMD(ACK, cmd)
+#define ACK_CMD(ack_cmd)		CMD(ACK, ack_cmd)
 
-/* Special hardcoded message */
-#define SKIP	0xf0030006
 /*
  * End McSAAB command definitions
  */
@@ -152,6 +130,7 @@ enum {
 
 /* Send state machine states */
 enum {
+	SEND_IDLE,
 	WAIT4READY,
 	SEND_READY,
 	SENDING,
@@ -161,12 +140,39 @@ enum {
 
 /* Recevice state machine states */
 enum {
+	RECV_IDLE,
 	RECV_READY,
 	RECEIVING,
 	RECV_BUSY,
 	RECV_NUM_STATES,	/* NOTE: Must be always the last one */
 };
 
+
+/**
+ * struct mcsaab_imp - McSAAB improved protocol data
+ * @main_state: State of the general state machine
+ * @send_state: State of the TX state machine
+ * @recv_state: State of the RX state machine
+ * @flags: Keeps tracks of several events, mainly used for workarounds
+ * @rcv_c_msg: Control channel RX buffer
+ * @c_queue: Control channel TX queue.
+ * @head: First frame in control channel TX queue
+ * @tail: Last frame in the control channel TX queue
+ * @rcv_msg_id: Expeceted next RX message id
+ * @send_msg_id: Next TX messaged id
+ * @dev_d_ch: Data channel
+ * @dev_c_ch: Control channel
+ * @boot_wd: Boot handshake watchdog
+ * @tx_wd: TX path watchdog
+ * @rx_wd: RX path watchdog
+ * @keep_alive: Workaround timer to wakeup the MPU from inactive state
+ * @tx_queue: TX packets queue
+ * @rx_queue: RX packets queue
+ * @netdev: Phonet network interface
+ * @cmt_rst_gpio: CMT reset gpio line
+ * @cmt_rst_gpio_irq: IRQ associted to the CMT reset gpio line
+ * @cmt_rst_tasklet: Bottom half for CMT reset line events
+ */
 struct mcsaab_imp {
 	unsigned int main_state;
 	unsigned int send_state;
@@ -182,15 +188,13 @@ struct mcsaab_imp {
 	u8 rcv_msg_id;
 	u8 send_msg_id;
 
-	u16 cmt_default_tx_speed;
-	u16 cmt_tx_speed;
-
 	struct ssi_device *dev_d_ch;
 	struct ssi_device *dev_c_ch;
 
 	struct timer_list boot_wd;
 	struct timer_list tx_wd;
 	struct timer_list rx_wd;
+	struct timer_list keep_alive;
 
 	struct clk *ssi_clk;
 
@@ -201,6 +205,10 @@ struct mcsaab_imp {
 	struct sk_buff_head rx_queue;
 
 	struct net_device *netdev;
+
+	int cmt_rst_gpio;
+	int cmt_rst_gpio_irq;
+	struct tasklet_struct cmt_rst_tasklet;
 };
 
 static struct mcsaab_imp ssi_protocol;
@@ -227,14 +235,17 @@ static void reset_mcsaab(void)
 	del_timer(&ssi_protocol.boot_wd);
 	del_timer(&ssi_protocol.rx_wd);
 	del_timer(&ssi_protocol.tx_wd);
+	del_timer(&ssi_protocol.keep_alive);
 	ssi_protocol.main_state = INIT;
 	ssi_protocol.send_msg_id = 0;
 	ssi_protocol.rcv_msg_id = 0;
-	ssi_protocol.send_state = RECV_READY;
-	ssi_protocol.recv_state = SEND_READY;
+	ssi_protocol.send_state = SEND_IDLE;
+	ssi_protocol.recv_state = RECV_IDLE;
 	ssi_protocol.flags = 0;
 	ssi_protocol.head = 0;
 	ssi_protocol.tail = 0;
+	ssi_ioctl(ssi_protocol.dev_c_ch, SSI_IOCTL_FLUSH_TX, NULL);
+	ssi_ioctl(ssi_protocol.dev_c_ch, SSI_IOCTL_FLUSH_RX, NULL);
 	if (ssi_protocol.dev_d_ch) {
 		ssi_read_cancel(ssi_protocol.dev_d_ch);
 		ssi_write_cancel(ssi_protocol.dev_d_ch);
@@ -243,9 +254,36 @@ static void reset_mcsaab(void)
 		ssi_write_cancel(ssi_protocol.dev_c_ch);
 	skb_queue_purge(&ssi_protocol.tx_queue);
 	skb_queue_purge(&ssi_protocol.rx_queue);
-	DBG("CMT is OFFLINE");
+	pr_debug(LOG_NAME "CMT is OFFLINE\n");
 	netif_carrier_off(ssi_protocol.netdev);
+}
+
+static int mcsaab_need_keep_alive(void)
+{
+	if (ssi_protocol.recv_state == RECV_IDLE) {
+		switch (ssi_protocol.send_state) {
+		case SEND_IDLE:
+			return 0;
+		case SEND_READY: /* Check needed cause cmtspeech workaround */
+			if (!skb_queue_len(&ssi_protocol.tx_queue))
+				return 0;
+			break;
+		}
+	}
+	return 1;
+}
+
+static void mcsaab_stop_keep_alive(void)
+{
+	if (!mcsaab_need_keep_alive())
+		del_timer(&ssi_protocol.keep_alive);
+}
 
+static void mcsaab_restart_keep_alive(void)
+{
+	if (mcsaab_need_keep_alive())
+		mod_timer(&ssi_protocol.keep_alive,
+				jiffies + msecs_to_jiffies(KA_TIMEOUT));
 }
 
 static void send_c_msg(u32 c_msg)
@@ -255,10 +293,10 @@ static void send_c_msg(u32 c_msg)
 	size = (C_QUEUE_LEN + ssi_protocol.tail - ssi_protocol.head)
 							% C_QUEUE_LEN;
 	if (size >= (C_QUEUE_LEN - 1)) {
-		printk(KERN_DEBUG LOG_NAME "Control message queue OVERRUN !\n");
+		pr_debug(LOG_NAME "Control message queue OVERRUN !\n");
 		return;
 	}
-	DBG("Queue head %d tail %d size %d",
+	pr_debug(LOG_NAME "Queue head %d tail %d size %d\n",
 				ssi_protocol.head, ssi_protocol.tail, size);
 	ssi_protocol.c_queue[ssi_protocol.tail] = c_msg;
 	ssi_protocol.tail = (ssi_protocol.tail + 1) % C_QUEUE_LEN;
@@ -269,27 +307,6 @@ static void send_c_msg(u32 c_msg)
 
 }
 
-static void mcsaab_start_rx(int len)
-{
-	struct sk_buff *skb;
-
-	skb = netdev_alloc_skb(ssi_protocol.netdev, len * 4);
-	if (unlikely(!skb)) {
-		printk(KERN_DEBUG LOG_NAME "Out of memory RX skb.\n");
-		reset_mcsaab();
-		return;
-	}
-
-	skb_put(skb, len * 4);
-	skb_queue_tail(&ssi_protocol.rx_queue, skb);
-	if (skb_queue_len(&ssi_protocol.rx_queue) == 1) {
-		mod_timer(&ssi_protocol.rx_wd,
-					jiffies + msecs_to_jiffies(WD_TIMEOUT));
-		ssi_protocol.recv_state = RECEIVING;
-		ssi_read(ssi_protocol.dev_d_ch, (u32 *)skb->data, len);
-	}
-}
-
 static void mcsaab_start_tx(void)
 {
 	struct sk_buff *skb;
@@ -311,51 +328,45 @@ static void mcsaab_watchdog_dump(struct
 
 	ssi_ioctl(prot->dev_c_ch, SSI_IOCTL_WAKE, &acwake);
 	ssi_ioctl(prot->dev_c_ch, SSI_IOCTL_CAWAKE, &cawake);
-
 	last = (C_QUEUE_LEN - 1 + ssi_protocol.head) % C_QUEUE_LEN;
-	printk(KERN_DEBUG LOG_NAME "ACWake line %08X\n", acwake);
-	printk(KERN_DEBUG LOG_NAME "CAWake line %d\n", cawake);
-	printk(KERN_DEBUG LOG_NAME "Main state: %d\n", prot->main_state);
-	printk(KERN_DEBUG LOG_NAME "RX state:%02X\n", prot->recv_state);
-	printk(KERN_DEBUG LOG_NAME "TX state:%02X\n", prot->send_state);
-	printk(KERN_DEBUG LOG_NAME "CMT was %s\n",
+
+	pr_err(LOG_NAME "ACWake line %08X\n", acwake);
+	pr_err(LOG_NAME "CAWake line %d\n", cawake);
+	pr_err(LOG_NAME "Main state: %d\n", prot->main_state);
+	pr_err(LOG_NAME "RX state:%02X\n", prot->recv_state);
+	pr_err(LOG_NAME "TX state:%02X\n", prot->send_state);
+	pr_err(LOG_NAME "CMT was %s\n",
 			(prot->flags & CMT_ONLINE) ? "ONLINE" : "OFFLINE");
-	printk(KERN_DEBUG LOG_NAME "FLAGS: %04X\n", prot->flags);
-	printk(KERN_DEBUG LOG_NAME "Last RX control msg %08X\n",
-							prot->rcv_c_msg);
-	printk(KERN_DEBUG LOG_NAME "Last TX control msg %08X\n",
-							prot->c_queue[last]);
-	printk(KERN_DEBUG LOG_NAME "TX C queue head %d tail %d\n", prot->head,
-								prot->tail);
-	printk(KERN_DEBUG LOG_NAME "Data RX ID: %d\n", prot->rcv_msg_id);
-	printk(KERN_DEBUG LOG_NAME "Data TX ID: %d\n", prot->send_msg_id);
-	printk(KERN_DEBUG LOG_NAME "TX queue len: %d\n",
-						skb_queue_len(&prot->tx_queue));
+	pr_err(LOG_NAME "FLAGS: %04X\n", prot->flags);
+	pr_err(LOG_NAME "Last RX control msg %08X\n", prot->rcv_c_msg);
+	pr_err(LOG_NAME "Last TX control msg %08X\n", prot->c_queue[last]);
+	pr_err(LOG_NAME "TX C queue head %d tail %d\n", prot->head, prot->tail);
+	pr_err(LOG_NAME "Data RX ID: %d\n", prot->rcv_msg_id);
+	pr_err(LOG_NAME "Data TX ID: %d\n", prot->send_msg_id);
+	pr_err(LOG_NAME "TX queue len: %d\n", skb_queue_len(&prot->tx_queue));
 	if (skb_queue_len(&prot->tx_queue) > 0) {
 		skb = skb_peek(&prot->tx_queue);
-		printk(KERN_DEBUG LOG_NAME "TX HEAD packet:\n");
+		pr_err(LOG_NAME "TX HEAD packet:\n");
 		print_hex_dump_bytes(LOG_NAME, DUMP_PREFIX_ADDRESS, skb->data,
 					min(skb->len, (unsigned int)32));
-		printk(KERN_DEBUG LOG_NAME "END TX HEAD packet.\n");
+		pr_err(LOG_NAME "END TX HEAD packet.\n");
 	}
-	printk(KERN_DEBUG LOG_NAME "RX queue len: %d\n",
-						skb_queue_len(&prot->rx_queue));
+	pr_err(LOG_NAME "RX queue len: %d\n", skb_queue_len(&prot->rx_queue));
 	if (skb_queue_len(&prot->rx_queue) > 0) {
 		skb = skb_peek(&prot->rx_queue);
-		printk(KERN_DEBUG LOG_NAME "RX HEAD packet:\n");
+		pr_err(LOG_NAME "RX HEAD packet:\n");
 		print_hex_dump_bytes(LOG_NAME, DUMP_PREFIX_ADDRESS, skb->data,
 					min(skb->len, (unsigned int)32));
-		printk(KERN_DEBUG LOG_NAME "END RX HEAD packet.\n");
-
+		pr_err(LOG_NAME "END RX HEAD packet.\n");
 	}
 }
 
 static void mcsaab_watchdog(unsigned long data)
 {
 	struct mcsaab_imp *prot = (struct mcsaab_imp *)data;
-	DBG("------ WATCHDOG TIMER trigerred ------\n");
+	pr_debug(LOG_NAME "------ WATCHDOG TIMER trigerred ------\n");
 	mcsaab_watchdog_dump(prot);
-	DBG("--------------------------------------\n");
+	pr_debug(LOG_NAME "--------------------------------------\n");
 
 	reset_mcsaab();
 	ssi_ioctl(ssi_protocol.dev_c_ch, SSI_IOCTL_WAKE_DOWN, NULL);
@@ -363,21 +374,27 @@ static void mcsaab_watchdog(unsigned lon
 
 static void mcsaab_watchdog_rx(unsigned long data)
 {
-	DBG("------- RX WATCHDOG TIMER trigerred -----\n");
-
-	ssi_ioctl(ssi_protocol.dev_c_ch, SSI_IOCTL_FLUSH_RX, NULL);
-	ssi_ioctl(ssi_protocol.dev_c_ch, SSI_IOCTL_FLUSH_TX, NULL);
+	pr_err(LOG_NAME "------- RX WATCHDOG TIMER trigerred -----\n");
 	mcsaab_watchdog(data);
 }
 
 static void mcsaab_watchdog_tx(unsigned long data)
 {
-	DBG("------- TX WATCHDOG TIMER trigerred -----\n");
-	ssi_ioctl(ssi_protocol.dev_c_ch, SSI_IOCTL_FLUSH_RX, NULL);
-	ssi_ioctl(ssi_protocol.dev_c_ch, SSI_IOCTL_FLUSH_TX, NULL);
+	pr_err(LOG_NAME "------- TX WATCHDOG TIMER trigerred -----\n");
 	mcsaab_watchdog(data);
 }
 
+static void keep_alive_timer(unsigned long data)
+{
+	spin_lock(&ssi_protocol.lock);
+
+	pr_debug("Keep alive states r(%d) s(%d)\n",
+			ssi_protocol.recv_state, ssi_protocol.send_state);
+
+	mcsaab_restart_keep_alive();
+	spin_unlock(&ssi_protocol.lock);
+}
+
 /* End watchdog functions */
 
 /*
@@ -421,11 +438,11 @@ static int ssi_pn_xmit(struct sk_buff *s
 	qlen = skb_queue_len(&ssi_protocol.tx_queue);
 
 	if ((dev->tx_queue_len > 1) && (qlen >= dev->tx_queue_len)) {
-		DBG("TX queue full %d", qlen);
+		pr_debug(LOG_NAME "TX queue full %d\n", qlen);
 		netif_stop_queue(dev);
 		goto out;
 	} else if (qlen > 1) {
-		DBG("Pending frame on TX queue %d", qlen);
+		pr_debug(LOG_NAME "Pending frame on TX queue %d\n", qlen);
 		goto out;
 	}
 
@@ -435,7 +452,9 @@ static int ssi_pn_xmit(struct sk_buff *s
 	 * READY command when McSAAB sets it up.
 	 */
 	ssi_ioctl(ssi_protocol.dev_c_ch, SSI_IOCTL_WAKE, &acwake);
-	DBG("ACWAKE %d", acwake);
+	mod_timer(&ssi_protocol.keep_alive,
+					jiffies + msecs_to_jiffies(KA_TIMEOUT));
+	pr_debug(LOG_NAME "ACWAKE %d\n", acwake);
 	if (!acwake)
 		ssi_protocol.send_state = WAIT4READY;
 
@@ -444,7 +463,7 @@ static int ssi_pn_xmit(struct sk_buff *s
 	if (ssi_protocol.send_state == SEND_READY)
 		mcsaab_start_tx();
 	else {
-		DBG("TX pending of READY cmd");
+		pr_debug(LOG_NAME "TX pending of READY cmd\n");
 		mod_timer(&ssi_protocol.tx_wd,
 					jiffies + msecs_to_jiffies(WD_TIMEOUT));
 	}
@@ -506,20 +525,20 @@ static int ssi_pn_rx(struct sk_buff *skb
 #ifdef __LITTLE_ENDIAN
 	if (likely(skb->len >= 6))
 		((u16 *)skb->data)[2] = swab16(((u16 *)skb->data)[2]);
-	DBG("RX length fixed (%04x -> %u)", ((u16 *)skb->data)[2],
-		ntohs(((u16 *)skb->data)[2]));
+	pr_debug(LOG_NAME "RX length fixed (%04x -> %u)\n",
+			((u16 *)skb->data)[2], ntohs(((u16 *)skb->data)[2]));
 #endif
 
 	skb->protocol = htons(ETH_P_PHONET);
 	skb_reset_mac_header(skb);
 	__skb_pull(skb, 1);
 
-	DBG("RX done");
+	pr_debug(LOG_NAME "RX done\n");
 	netif_rx(skb);
 	return 0;
 
 drop:
-	DBG("Drop RX packet");
+	pr_debug(LOG_NAME "Drop RX packet\n");
 	dev_kfree_skb(skb);
 	return 0;
 }
@@ -533,14 +552,18 @@ static void boot_info_req_h(u32 msg)
 	switch (ssi_protocol.main_state) {
 	case INIT:
 		mcsaab_clk_enable();
+		ssi_ioctl(ssi_protocol.dev_c_ch, SSI_IOCTL_WAKE_UP, NULL);
 		send_c_msg(BOOT_INFO_RESP_CMD(LOCAL_D_VER_ID));
+		ssi_protocol.flags &= ~WAKEDOWN_TEST;
 		ssi_protocol.main_state = HANDSHAKE;
 		/* Start BOOT HANDSHAKE timer */
 		mod_timer(&ssi_protocol.boot_wd,
 					jiffies + msecs_to_jiffies(WD_TIMEOUT));
 		break;
 	case HANDSHAKE:
+		ssi_ioctl(ssi_protocol.dev_c_ch, SSI_IOCTL_WAKE_UP, NULL);
 		send_c_msg(BOOT_INFO_RESP_CMD(LOCAL_D_VER_ID));
+		ssi_protocol.flags &= ~WAKEDOWN_TEST;
 		/* Start BOOT HANDSHAKE timer */
 		mod_timer(&ssi_protocol.boot_wd,
 					jiffies + msecs_to_jiffies(WD_TIMEOUT));
@@ -558,7 +581,8 @@ static void boot_info_req_h(u32 msg)
 					jiffies + msecs_to_jiffies(WD_TIMEOUT));
 		break;
 	default:
-		DBG("UNKNOWN PROTOCOL STATE %d", ssi_protocol.main_state);
+		pr_debug(LOG_NAME "Wrong protocol state %d\n",
+						ssi_protocol.main_state);
 		break;
 	}
 }
@@ -566,8 +590,9 @@ static void boot_info_req_h(u32 msg)
 static void boot_info_resp_h(u32 msg)
 {
 	if (ssi_protocol.main_state != INIT) {
-		DBG("BOOT_INFO_RESP in bad state:");
-		DBG("	MAIN_STATE %d", ssi_protocol.main_state);
+		pr_debug(LOG_NAME "BOOT_INFO_RESP in wrong state:\n");
+		pr_debug(LOG_NAME "	MAIN_STATE %d\n",
+						ssi_protocol.main_state);
 		return;
 	}
 
@@ -578,8 +603,9 @@ static void boot_info_resp_h(u32 msg)
 static void wakelines_test_result_h(u32 msg)
 {
 	if (ssi_protocol.main_state != HANDSHAKE) {
-		DBG("WAKELINES_TEST in bad state:");
-		DBG("	MAIN_STATE %d", ssi_protocol.main_state);
+		pr_debug(LOG_NAME "WAKELINES_TEST in wrong state:\n");
+		pr_debug(LOG_NAME "	MAIN_STATE %d\n",
+						ssi_protocol.main_state);
 		return;
 	}
 
@@ -590,17 +616,12 @@ static void wakelines_test_result_h(u32
 		mcsaab_watchdog_dump(&ssi_protocol);
 		reset_mcsaab();
 	} else {
-#ifdef __HANDSHAKE_FQ_CHANGE__
-		send_c_msg(FQ_CHANGE_REQ_CMD(ssi_protocol.cmt_tx_speed));
-		return;
-#else
 		ssi_protocol.main_state = ACTIVE;
 		ssi_protocol.flags &= ~WAKEDOWN_TEST;
 		ssi_protocol.flags |= CMT_ONLINE;
-		DBG("CMT is ONLINE");
-		netif_carrier_on(ssi_protocol.netdev);
+		pr_debug(LOG_NAME "CMT is ONLINE\n");
 		netif_wake_queue(ssi_protocol.netdev);
-#endif
+		netif_carrier_on(ssi_protocol.netdev);
 	}
 	ssi_ioctl(ssi_protocol.dev_c_ch, SSI_IOCTL_WAKE_DOWN, NULL);
 	mcsaab_clk_disable(); /* Drop clk usecount */
@@ -608,61 +629,62 @@ static void wakelines_test_result_h(u32
 	del_timer(&ssi_protocol.boot_wd);
 }
 
-static void ack_to_cmd_h(u32 msg)
-{
-	u8 cmd_id;
-
-	cmd_id = ACK_TO_CMD(msg);
-	pr_debug(LOG_NAME "ACK to command %d\n", cmd_id);
-
-	switch (cmd_id) {
-	case FQ_CHANGE_REQ:
-#ifdef __HANDSHAKE_FQ_CHANGE__
-		if (ssi_protocol.main_state == HANDSHAKE)
-			send_c_msg(FQ_CHANGE_DONE_CMD);
-#endif
-		break;
-	default:
-		break;
-	}
-}
-
 static void start_trans_h(u32 msg)
 {
+	struct sk_buff *skb;
+	int len = PDU_LENGTH(msg);
 	u8 r_msg_id = 0;
 
 	r_msg_id = msg & MSG_ID_MASK;
-	DBG("Receiving START_TRANS len %d", PDU_LENGTH(msg));
-	DBG("START_TRANS msg id %d expected msg id %d",
+	pr_debug(LOG_NAME "Receiving START_TRANS len %d\n", PDU_LENGTH(msg));
+	pr_debug(LOG_NAME "START_TRANS msg id %d expected msg id %d\n",
 					r_msg_id, ssi_protocol.rcv_msg_id);
 
 	if (unlikely(ssi_protocol.main_state != ACTIVE)) {
-		DBG("START_TRANS in bad state:\n");
-		DBG("	SEND STATE %d", ssi_protocol.send_state);
-		DBG("	MAIN_STATE %d", ssi_protocol.main_state);
+		pr_debug(LOG_NAME "START_TRANS in wrong state:\n");
+		pr_debug(LOG_NAME "	SEND STATE %d\n",
+						ssi_protocol.send_state);
+		pr_debug(LOG_NAME "	MAIN_STATE %d\n",
+						ssi_protocol.main_state);
 		return;
 	}
 
 	if (unlikely(r_msg_id != ssi_protocol.rcv_msg_id)) {
-		printk(KERN_DEBUG LOG_NAME "RX msg id mismatch (MSG ID: %d "
+		pr_debug(LOG_NAME "RX msg id mismatch (MSG ID: %d "
 		"McSAAB RX ID: %d)\n", r_msg_id, ssi_protocol.rcv_msg_id);
 		mcsaab_watchdog_dump(&ssi_protocol);
 		reset_mcsaab();
 		return;
 	}
 	ssi_protocol.rcv_msg_id = (ssi_protocol.rcv_msg_id + 1) & 0xff;
-	ssi_protocol.flags &= ~READY_SENT;
-	mcsaab_start_rx(PDU_LENGTH(msg));
+
+	skb = netdev_alloc_skb(ssi_protocol.netdev, len * 4);
+	if (unlikely(!skb)) {
+		printk(KERN_DEBUG LOG_NAME "Out of memory RX skb.\n");
+		reset_mcsaab();
+		return;
+	}
+
+	skb_put(skb, len * 4);
+	skb_queue_tail(&ssi_protocol.rx_queue, skb);
+	if (skb_queue_len(&ssi_protocol.rx_queue) == 1) {
+		mod_timer(&ssi_protocol.rx_wd,
+					jiffies + msecs_to_jiffies(WD_TIMEOUT));
+		ssi_protocol.recv_state = RECEIVING;
+		ssi_read(ssi_protocol.dev_d_ch, (u32 *)skb->data, len);
+	}
 }
 
 static void ready_h(u32 msg)
 {
 	if (unlikely((ssi_protocol.main_state != ACTIVE) ||
 					(ssi_protocol.send_state >= SENDING))) {
-		DBG("READY CMD on bad state:");
-		DBG("	SEND STATE %d", ssi_protocol.send_state);
-		DBG("	MAIN_STATE %d", ssi_protocol.main_state);
-		DBG("	FLAGS %02X", ssi_protocol.flags);
+		pr_debug(LOG_NAME "READY CMD on wrong state:\n");
+		pr_debug(LOG_NAME "	SEND STATE %d\n",
+						ssi_protocol.send_state);
+		pr_debug(LOG_NAME "	MAIN_STATE %d\n",
+						ssi_protocol.main_state);
+		pr_debug(LOG_NAME "	FLAGS %02X\n", ssi_protocol.flags);
 		return;
 	}
 	if (skb_queue_len(&ssi_protocol.tx_queue) > 0)
@@ -674,12 +696,14 @@ static void ready_h(u32 msg)
 static void swbreak_h(void)
 {
 	if (ssi_protocol.main_state != ACTIVE) {
-		DBG("SW BREAK in bad state:\n");
-		DBG("	SEND STATE %d", ssi_protocol.send_state);
-		DBG("	MAIN_STATE %d", ssi_protocol.main_state);
+		pr_debug(LOG_NAME "SW BREAK in wrong state:\n");
+		pr_debug(LOG_NAME "	SEND STATE %d\n",
+					ssi_protocol.send_state);
+		pr_debug(LOG_NAME "	MAIN_STATE %d\n",
+					ssi_protocol.main_state);
 		return;
 	}
-	DBG("SWBREAK Ignored");
+	pr_debug(LOG_NAME "SWBREAK Ignored\n");
 	mcsaab_clk_disable();
 }
 /* End incoming commands */
@@ -694,8 +718,10 @@ static void c_send_done_cb(struct ssi_de
 
 	spin_lock(&ssi_protocol.lock);
 
+	mcsaab_restart_keep_alive();
+
 	cmd = ssi_protocol.c_queue[ssi_protocol.head];
-	DBG("Control message 0x%08X sent", cmd);
+	pr_debug(LOG_NAME "Control message 0x%08X sent\n", cmd);
 
 	if ((COMMAND(cmd) == START_TRANS) &&
 			(ssi_protocol.send_state == SENDING)) {
@@ -705,10 +731,11 @@ static void c_send_done_cb(struct ssi_de
 	} else if ((COMMAND(cmd) == SW_BREAK) &&
 			(ssi_protocol.send_state == SENDING_SWBREAK)) {
 		if (skb_queue_len(&ssi_protocol.tx_queue) > 0) {
-			DBG("We got SKB while sending SW_BREAK");
+			pr_debug(LOG_NAME "Got SKB while sending SW_BREAK\n");
 			mcsaab_start_tx();
 		} else {
-			DBG("SW BREAK: Trying to set ACWake line DOWN");
+			pr_debug(LOG_NAME "SW BREAK: Trying to set ACWake "
+								"line DOWN\n");
 			ssi_ioctl(ssi_protocol.dev_c_ch, SSI_IOCTL_WAKE_DOWN,
 									NULL);
 			/*
@@ -716,37 +743,24 @@ static void c_send_done_cb(struct ssi_de
 			 * still the wakeup line.
 			 */
 			ssi_ioctl(c_dev, SSI_IOCTL_WAKE, &acwake);
-			DBG("ACWAKE %d", acwake);
+			pr_debug(LOG_NAME "ACWAKE %d\n", acwake);
 			if (!acwake)
-				ssi_protocol.send_state = WAIT4READY;
+				ssi_protocol.send_state = SEND_IDLE;
 			else
 				ssi_protocol.send_state = SEND_READY;
+			mcsaab_stop_keep_alive();
 		}
 		netif_wake_queue(ssi_protocol.netdev);
-#ifdef __HANDSHAKE_FQ_CHANGE__
-	} else if ((COMMAND(cmd) == FQ_CHANGE_DONE) &&
-				(ssi_protocol.main_state == HANDSHAKE)) {
-		ssi_protocol.main_state = ACTIVE;
-		ssi_protocol.flags &= ~WAKEDOWN_TEST;
-		ssi_protocol.flags |= CMT_ONLINE;
-		DBG("CMT is ONLINE");
-		netif_carrier_on(ssi_protocol.netdev);
-		netif_wake_queue(ssi_protocol.netdev);
-		ssi_ioctl(ssi_protocol.dev_c_ch, SSI_IOCTL_WAKE_DOWN, NULL);
-		mcsaab_clk_disable(); /* Drop clk usecount */
-		/* Stop BOOT HANDSHAKE timer */
-		del_timer(&ssi_protocol.boot_wd);
-	}
-#else
 	}
-#endif
+
 	/* Check for pending TX commands */
 	++ssi_protocol.head;
 	ssi_protocol.head %= C_QUEUE_LEN;
 
 	if (ssi_protocol.tail != ssi_protocol.head) {
-		DBG("Dequeue message on pos %d", ssi_protocol.head);
-		DBG("Sending queued msg 0x%08x",
+		pr_debug(LOG_NAME "Dequeue message on pos %d\n",
+							ssi_protocol.head);
+		pr_debug(LOG_NAME "Sending queued msg 0x%08x\n",
 				ssi_protocol.c_queue[ssi_protocol.head]);
 		ssi_write(ssi_protocol.dev_c_ch,
 				&ssi_protocol.c_queue[ssi_protocol.head], 1);
@@ -755,11 +769,48 @@ static void c_send_done_cb(struct ssi_de
 	spin_unlock(&ssi_protocol.lock);
 }
 
+/* Forward declaration */
+static void d_send_done_cb(struct ssi_device *d_dev);
+
+/*
+ * d_tx_complete_cb - Callback called when a TX has completed in the wire.
+ * @d_dev - the channel were the TX has completed.
+ */
+static void d_tx_complete_cb(struct ssi_device *d_dev)
+{
+	unsigned int busy;
+
+	spin_lock(&ssi_protocol.lock);
+
+	ssi_ioctl(d_dev, SSI_IOCTL_TX_CH_FULL, &busy);
+	if (busy) {
+		ssi_ioctl(d_dev, SSI_IOCTL_CH_DATAACCEPT, NULL);
+		goto out;
+	}
+
+	ssi_set_write_cb(d_dev, d_send_done_cb);
+
+	if (skb_queue_len(&ssi_protocol.tx_queue) <= 0) {
+		pr_debug(LOG_NAME "Delayed Sending SWBREAK\n");
+		send_c_msg(SWBREAK_CMD);
+		ssi_protocol.send_state = SENDING_SWBREAK;
+	} else {
+		mcsaab_start_tx();
+	}
+
+out:
+	spin_unlock(&ssi_protocol.lock);
+}
+
 static void d_send_done_cb(struct ssi_device *d_dev)
 {
 	struct sk_buff *skb;
+	unsigned int busy;
 
 	spin_lock(&ssi_protocol.lock);
+
+	mcsaab_restart_keep_alive();
+
 	skb = skb_dequeue(&ssi_protocol.tx_queue);
 	if (!skb)
 		goto out;
@@ -768,7 +819,18 @@ static void d_send_done_cb(struct ssi_de
 	ssi_protocol.send_msg_id++;
 	ssi_protocol.send_msg_id &= 0xff;
 	if (skb_queue_len(&ssi_protocol.tx_queue) <= 0) {
-		DBG("Sending SWBREAK");
+		ssi_ioctl(d_dev, SSI_IOCTL_TX_CH_FULL, &busy);
+		if (busy) {
+			/*
+			 * Program DATAACCEPT interrupt to know when ch 3
+			 * has completed TX last frame.
+			 */
+			ssi_set_write_cb(d_dev, d_tx_complete_cb);
+			ssi_ioctl(d_dev, SSI_IOCTL_CH_DATAACCEPT, NULL);
+			pr_debug(LOG_NAME "Waiting for last frame\n");
+			goto out;
+		}
+		pr_debug(LOG_NAME "Sending SWBREAK\n");
 		send_c_msg(SWBREAK_CMD);
 		ssi_protocol.send_state = SENDING_SWBREAK;
 	} else {
@@ -785,10 +847,12 @@ static void c_rcv_done_cb(struct ssi_dev
 
 	spin_lock(&ssi_protocol.lock);
 
+	mcsaab_restart_keep_alive();
+
 	ssi_read(c_dev, &ssi_protocol.rcv_c_msg, 1);
 
-	DBG("Protocol state %d", ssi_protocol.main_state);
-	DBG("CMT Message 0x%08X CMD %01X", message, COMMAND(message));
+	pr_debug(LOG_NAME "Protocol state %d\n", ssi_protocol.main_state);
+	pr_debug(LOG_NAME "CMT Message 0x%08x\n", message);
 
 	switch (command) {
 	case SW_BREAK:
@@ -809,9 +873,6 @@ static void c_rcv_done_cb(struct ssi_dev
 	case READY:
 		ready_h(message);
 		break;
-	case ACK:
-		ack_to_cmd_h(message);
-		break;
 	case DUMMY:
 		pr_warning(LOG_NAME "Received dummy sync 0x%08x\n", message);
 		pr_warning(LOG_NAME "OLD McSAAB Protocol DETECTED\n");
@@ -831,12 +892,13 @@ static void d_rcv_done_cb(struct ssi_dev
 
 	spin_lock(&ssi_protocol.lock);
 
+	mcsaab_restart_keep_alive();
+
 	skb = skb_dequeue(&ssi_protocol.rx_queue);
 	if (!skb)
 		goto out;
 	skb->dev = ssi_protocol.netdev;
 	del_timer(&ssi_protocol.rx_wd); /* Stop RX timer */
-	ssi_protocol.recv_state = RECV_READY;
 	ssi_pn_rx(skb);
 	if (skb_queue_len(&ssi_protocol.rx_queue) > 0) {
 		skb = skb_peek(&ssi_protocol.rx_queue);
@@ -852,6 +914,9 @@ out:
 
 static void wake_up_event(struct ssi_device *c_dev)
 {
+
+	spin_lock(&ssi_protocol.lock);
+
 	switch (ssi_protocol.main_state) {
 	case INIT:
 		ssi_ioctl(c_dev, SSI_IOCTL_WAKE_UP, NULL);
@@ -864,33 +929,37 @@ static void wake_up_event(struct ssi_dev
 		}
 		break;
 	case ACTIVE:
-		if (ssi_protocol.flags & READY_SENT) {
-			/*
-			 * We can have two UP events in a row due to a short low
-			 * high transition. Therefore we need to ignore the
-			 * sencond UP event.
-			 */
-			DBG("IGNORE 2nd CAWAKE UP");
-			ssi_protocol.flags &= ~READY_SENT;
-		} else {
-			ssi_protocol.flags |= READY_SENT;
-			mcsaab_clk_enable();
-			send_c_msg(READY_CMD);
-			/* Start RX timer */
-			mod_timer(&ssi_protocol.rx_wd,
-					jiffies + msecs_to_jiffies(WD_TIMEOUT));
-		}
+		/*
+		 * We can have two UP events in a row due to a short low
+		 * high transition. Therefore we need to ignore the
+		 * sencond UP event.
+		 */
+		if (ssi_protocol.recv_state == RECV_READY)
+			break;
+
+		ssi_protocol.recv_state = RECV_READY;
+		mcsaab_clk_enable();
+		send_c_msg(READY_CMD);
+		/* Start RX timer */
+		mod_timer(&ssi_protocol.rx_wd,
+				jiffies + msecs_to_jiffies(WD_TIMEOUT));
+		/* Wake MPU workaround */
+		mod_timer(&ssi_protocol.keep_alive,
+				jiffies + msecs_to_jiffies(KA_TIMEOUT));
 		break;
 	default:
-		DBG(LOG_NAME "UNKNOWN PROTOCOL STATE %d\n",
+		pr_debug(LOG_NAME "Wrong protocol state %d\n",
 						ssi_protocol.main_state);
 		break;
 	}
+
+	spin_unlock(&ssi_protocol.lock);
 }
 
 static void wake_down_event(struct ssi_device *c_dev)
 {
-	DBG("WAKE DOWN in state %d", ssi_protocol.main_state);
+	spin_lock(&ssi_protocol.lock);
+	pr_debug(LOG_NAME "WAKE DOWN in state %d\n", ssi_protocol.main_state);
 
 	switch (ssi_protocol.main_state) {
 	case INIT:
@@ -904,31 +973,29 @@ static void wake_down_event(struct ssi_d
 		}
 		break;
 	case ACTIVE:
+		ssi_protocol.recv_state = RECV_IDLE;
+		mcsaab_stop_keep_alive();
 		break;
 	default:
-		DBG("UNKNOWN PROTOCOL STATE %d\n",
+		pr_debug(LOG_NAME "Wrong protocol state %d\n",
 						ssi_protocol.main_state);
 		break;
 	}
+
+	spin_unlock(&ssi_protocol.lock);
 }
 
 static void port_event_cb(struct ssi_device *ssi_dev, unsigned int event,
 								void *arg)
 {
-	DBG("Event %d: ", event);
-	DBG("	on controller %d on port %d", c_id, port);
-	DBG("	on protocol state %d", ssi_protocol.main_state);
-
 	switch (event) {
 	case SSI_EVENT_BREAK_DETECTED:
-		pr_notice(LOG_NAME "BREAK DETECTED.\n");
-		pr_warning(LOG_NAME "Rebooting sequence started...\n");
-		mcsaab_watchdog_dump(&ssi_protocol);
+		pr_debug(LOG_NAME "HWBREAK detected.\n");
+		break;
+	case SSI_EVENT_ERROR:
+		pr_err(LOG_NAME "HW ERROR detected\n");
 		reset_mcsaab();
-		ssi_ioctl(ssi_protocol.dev_c_ch, SSI_IOCTL_WAKE_UP, NULL);
-		send_c_msg(SKIP);
 		break;
-	/* FIXME: Handle ERRORs */
 	case SSI_EVENT_CAWAKE_UP:
 		wake_up_event(ssi_protocol.dev_c_ch);
 		break;
@@ -936,12 +1003,71 @@ static void port_event_cb(struct ssi_dev
 		wake_down_event(ssi_protocol.dev_c_ch);
 		break;
 	default:
-		DBG("Recevived an UNKNOWN  event");
+		pr_debug(LOG_NAME "Recevived an UNKNOWN  event\n");
 		break;
 	}
 }
 /* End OMAP SSI callabcks */
 
+/* CMT reset support */
+static void do_cmt_rst_tasklet(unsigned long ssi_proto)
+{
+	struct mcsaab_imp *ssi_protocol = (struct mcsaab_imp *)ssi_proto;
+	int v;
+
+	v = gpio_get_value(ssi_protocol->cmt_rst_gpio);
+	pr_warning("******\n* CMT rst line change detected (%d)\n*****\n", v);
+	spin_lock(&ssi_protocol->lock);
+	if (!v) {
+		mcsaab_watchdog_dump(ssi_protocol);
+		reset_mcsaab();
+	}
+	spin_unlock(&ssi_protocol->lock);
+}
+
+static irqreturn_t cmt_rst_isr(int irq, void *ssi_proto)
+{
+	struct mcsaab_imp *ssi_protocol = (struct mcsaab_imp *)ssi_proto;
+
+	tasklet_hi_schedule(&ssi_protocol->cmt_rst_tasklet);
+
+	return IRQ_HANDLED;
+}
+
+int __init cmt_rst_init(struct mcsaab_imp *p, const char *gpio_name)
+{
+
+	if (gpio_request(p->cmt_rst_gpio, gpio_name) < 0) {
+		pr_err(LOG_NAME "FAILED to request %s GPIO %d\n",
+						gpio_name, p->cmt_rst_gpio);
+			return -EBUSY;
+	}
+	gpio_direction_input(p->cmt_rst_gpio);
+	tasklet_init(&p->cmt_rst_tasklet, do_cmt_rst_tasklet, (unsigned long)p);
+	if (request_irq(p->cmt_rst_gpio_irq, cmt_rst_isr,
+			IRQF_SHARED | IRQF_TRIGGER_FALLING, gpio_name, p) < 0) {
+		gpio_free(p->cmt_rst_gpio);
+		pr_err(LOG_NAME "FAILED to request %s GPIO IRQ %d\n",
+						gpio_name, p->cmt_rst_gpio_irq);
+		return -EBUSY;
+	}
+	enable_irq_wake(p->cmt_rst_gpio_irq);
+
+	return 0;
+}
+
+void cmt_rst_exit(struct mcsaab_imp *p)
+{
+	if (p->cmt_rst_gpio < 0)
+		return;	/* Nothing to do */
+
+	disable_irq_wake(p->cmt_rst_gpio_irq);
+	tasklet_kill(&p->cmt_rst_tasklet);
+	free_irq(p->cmt_rst_gpio_irq, p);
+	gpio_free(p->cmt_rst_gpio);
+}
+/* End CMT reset support */
+
 static int __devinit open_ssi_hw_drv(struct mcsaab_imp *prot)
 {
 	int err = 0;
@@ -958,7 +1084,7 @@ static int __devinit open_ssi_hw_drv(str
 		goto rback2;
 	}
 
-	DBG("Submitting read on the control channel");
+	pr_debug(LOG_NAME "Submitting read on the control channel\n");
 	err = ssi_read(prot->dev_c_ch, &prot->rcv_c_msg, 1);
 	if (err < 0) {
 		pr_err(LOG_NAME "Error when submiting first control read\n");
@@ -1020,8 +1146,8 @@ static int __devexit mcsaab_remove(struc
 
 	if (ssi_dev == ssi_protocol.dev_c_ch) {
 		ssi_protocol.main_state = INIT;
-		ssi_protocol.send_state = SEND_READY;
-		ssi_protocol.recv_state = RECV_READY;
+		ssi_protocol.send_state = SEND_IDLE;
+		ssi_protocol.recv_state = RECV_IDLE;
 		ssi_protocol.flags = 0;
 		ssi_protocol.head = 0;
 		ssi_protocol.tail = 0;
@@ -1059,14 +1185,13 @@ static int __init ssi_proto_init(void)
 	pr_info(MCSAAB_IMP_NAME " Version: " MCSAAB_IMP_VERSION "\n");
 
 	spin_lock_init(&ssi_protocol.lock);
-	init_timer(&ssi_protocol.boot_wd);
-	init_timer(&ssi_protocol.rx_wd);
-	init_timer(&ssi_protocol.tx_wd);
-	ssi_protocol.cmt_default_tx_speed = CMT_DEFAULT_TX_SPEED;
-	ssi_protocol.cmt_tx_speed = 55; /* FIXME */
+	init_timer_deferrable(&ssi_protocol.boot_wd);
+	init_timer_deferrable(&ssi_protocol.rx_wd);
+	init_timer_deferrable(&ssi_protocol.tx_wd);
+	init_timer(&ssi_protocol.keep_alive);
 	ssi_protocol.main_state = INIT;
-	ssi_protocol.send_state = SEND_READY;
-	ssi_protocol.recv_state = RECV_READY;
+	ssi_protocol.send_state = SEND_IDLE;
+	ssi_protocol.recv_state = RECV_IDLE;
 	ssi_protocol.flags = 0;
 	ssi_protocol.head = 0;
 	ssi_protocol.tail = 0;
@@ -1078,7 +1203,12 @@ static int __init ssi_proto_init(void)
 	ssi_protocol.rx_wd.function = mcsaab_watchdog_rx;
 	ssi_protocol.tx_wd.data = (unsigned long)&ssi_protocol;
 	ssi_protocol.tx_wd.function = mcsaab_watchdog_tx;
+	ssi_protocol.keep_alive.data = (unsigned long)&ssi_protocol;
+	ssi_protocol.keep_alive.function = keep_alive_timer;
 	ssi_protocol.ssi_clk = NULL;
+	ssi_protocol.cmt_rst_gpio = 72; /* FIXME */
+	ssi_protocol.cmt_rst_gpio_irq = gpio_to_irq(72); /* FIXME */
+
 	skb_queue_head_init(&ssi_protocol.tx_queue);
 	skb_queue_head_init(&ssi_protocol.rx_queue);
 
@@ -1097,7 +1227,7 @@ static int __init ssi_proto_init(void)
 
 	ssi_protocol.ssi_clk = clk_get(NULL, "ssi_clk");
 	if (IS_ERR(ssi_protocol.ssi_clk)) {
-		printk(KERN_DEBUG LOG_NAME "Could not claim SSI fck clock\n");
+		pr_err(LOG_NAME "Could not claim SSI fck clock\n");
 		err = PTR_ERR(ssi_protocol.ssi_clk);
 		goto rback1;
 	}
@@ -1108,7 +1238,15 @@ static int __init ssi_proto_init(void)
 		goto rback2;
 	}
 
+	err = cmt_rst_init(&ssi_protocol, "ape_rst_rq");
+	if (err < 0) {
+		pr_err(LOG_NAME "Error setting CMT reset support (%d)\n", err);
+		goto rback3;
+	}
+
 	return 0;
+rback3:
+	unregister_ssi_driver(&ssi_mcsaab_driver);
 rback2:
 	clk_put(ssi_protocol.ssi_clk);
 rback1:
@@ -1119,6 +1257,7 @@ rback1:
 static void __exit ssi_proto_exit(void)
 {
 	reset_mcsaab();
+	cmt_rst_exit(&ssi_protocol);
 	unregister_ssi_driver(&ssi_mcsaab_driver);
 	clk_put(ssi_protocol.ssi_clk);
 	unregister_netdev(ssi_protocol.netdev);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/misc/nokia-av.c kernel-2.6.28-20093908+0m5/drivers/misc/nokia-av.c
--- kernel-2.6.28-20091602+0m5/drivers/misc/nokia-av.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/misc/nokia-av.c	2012-12-16 13:13:01.672330147 +0100
@@ -45,15 +45,21 @@
 
 #define HS_BTN_KEY		KEY_PHONE
 #define HS_BTN_IRQ_FLAGS	(IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)
-#define HS_BTN_DEBOUNCE_FALLING	50 /* press */
-#define HS_BTN_DEBOUNCE_RISING	50 /* release */
+#define HS_BTN_DEBOUNCE_PRESS	100
+#define HS_BTN_DEBOUNCE_RELEASE	100
 #define HS_BTN_REPORT_DELAY	1000
 
+#define HEADPH_IRQ_FLAGS	(IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |\
+				IRQF_SHARED)
+#define HEADPH_DEBOUNCE		300
+
 #define DET_OPEN_CABLE_DELAY	100
 #define DET_REPEAT_DELAY	50
 #define DET_PLUG_DELAY		10
 #define DET_PROBE_DELAY		10
+#define DET_ECI_RESET_DELAY	600
 #define DET_REPEAT_COUNT	5
+#define DET_COUNT_MAX		10
 
 enum {
 	UNKNOWN,
@@ -69,37 +75,36 @@ struct nokia_av_drvdata {
 	struct mutex detection_lock;
 
 	struct workqueue_struct *workqueue;
+	struct work_struct headph_work;
+	struct timer_list headph_timer;
 	struct delayed_work detection_work;
 
 	struct input_dev *input;
 	struct work_struct hs_btn_work;
 	struct timer_list hs_btn_timer;
 	struct delayed_work hs_btn_report_work;
-
-	int debounce_rising;
-	int debounce_falling;
+	int hs_btn_pressed;
 
 	int autodetect;
 	int type;
 	int dettype;
 	int detcount;
+	int dettotal;
 
 	int eci0_gpio;
 	int eci1_gpio;
 	int headph_gpio;
+	int headph_plugged;
 };
 
 /* Delayed reporting of button press-release cycle */
 static void hs_btn_report(struct work_struct *work)
 {
-	struct delayed_work *dwork =
-		container_of(work, struct delayed_work, work);
-	struct nokia_av_drvdata *drvdata =
-		container_of(dwork, struct nokia_av_drvdata,
-			hs_btn_report_work);
+	struct nokia_av_drvdata *drvdata = container_of(work,
+		struct nokia_av_drvdata, hs_btn_report_work.work);
 
 	/* Don't report if unplugged */
-	if (drvdata->input && !gpio_get_value(drvdata->headph_gpio)) {
+	if (drvdata->input && drvdata->headph_plugged) {
 		input_report_key(drvdata->input, HS_BTN_KEY, 1);
 		input_sync(drvdata->input);
 		input_report_key(drvdata->input, HS_BTN_KEY, 0);
@@ -120,11 +125,19 @@ static void hs_btn_handler(struct work_s
 {
 	struct nokia_av_drvdata *drvdata =
 		container_of(work, struct nokia_av_drvdata, hs_btn_work);
+	int pressed;
 
-	/* Only report on key release */
-	if (drvdata->type == BASIC_HEADSET &&
-		gpio_get_value(drvdata->eci0_gpio)) {
+	if (!allow_button_press())
+		return;
+
+	pressed = !gpio_get_value(drvdata->eci0_gpio);
+	if (drvdata->hs_btn_pressed == pressed)
+		return;
+
+	drvdata->hs_btn_pressed = pressed;
 
+	/* Only report on key release */
+	if (drvdata->type == BASIC_HEADSET && !pressed) {
 		/* Delay reporting to avoid false events on unplug */
 		queue_delayed_work(drvdata->workqueue,
 				&drvdata->hs_btn_report_work,
@@ -136,13 +149,16 @@ static void hs_btn_handler(struct work_s
 static irqreturn_t hs_btn_irq(int irq, void *_drvdata)
 {
 	struct nokia_av_drvdata *drvdata = _drvdata;
-	int state, timeout;
+	int pressed, timeout;
+
+	pressed = !gpio_get_value(drvdata->eci0_gpio);
+	if (drvdata->hs_btn_pressed == pressed)
+		return IRQ_HANDLED;
 
-	state = gpio_get_value(drvdata->eci0_gpio);
-	if (state)
-		timeout = drvdata->debounce_rising;
+	if (pressed)
+		timeout = HS_BTN_DEBOUNCE_PRESS;
 	else
-		timeout = drvdata->debounce_falling;
+		timeout = HS_BTN_DEBOUNCE_RELEASE;
 
 	if (!timeout)
 		schedule_work(&drvdata->hs_btn_work);
@@ -153,13 +169,15 @@ static irqreturn_t hs_btn_irq(int irq, v
 	return IRQ_HANDLED;
 }
 
-static int input_init(struct nokia_av_drvdata *drvdata)
+static int hs_btn_input_init(struct nokia_av_drvdata *drvdata)
 {
 	int ret;
 
 	if (drvdata->input)
 		return -EEXIST;
 
+	drvdata->hs_btn_pressed = 0;
+
 	drvdata->input = input_allocate_device();
 	if (!drvdata->input) {
 		dev_err(drvdata->dev, "Could not allocate input device\n");
@@ -174,6 +192,7 @@ static int input_init(struct nokia_av_dr
 	if (ret) {
 		dev_err(drvdata->dev, "Could not register input device\n");
 		input_free_device(drvdata->input);
+		drvdata->input = NULL;
 		return ret;
 	}
 
@@ -183,18 +202,23 @@ static int input_init(struct nokia_av_dr
 		dev_err(drvdata->dev, "Could not request irq %d\n",
 			gpio_to_irq(drvdata->eci0_gpio));
 		input_unregister_device(drvdata->input);
+		drvdata->input = NULL;
 		return ret;
 	}
 
 	return 0;
 }
 
-static void input_free(struct nokia_av_drvdata *drvdata)
+static void hs_btn_input_free(struct nokia_av_drvdata *drvdata)
 {
 	if (!drvdata->input)
 		return;
 
 	free_irq(gpio_to_irq(drvdata->eci0_gpio), drvdata);
+
+	del_timer(&drvdata->hs_btn_timer);
+	cancel_delayed_work(&drvdata->hs_btn_report_work);
+
 	input_unregister_device(drvdata->input);
 	drvdata->input = NULL;
 }
@@ -242,12 +266,16 @@ static int madc_stable_voltage(int d, in
 	return mv2;
 }
 
-#define NEED_BIAS_CORRECTION(hwid)	((hwid) <= 0x1700) /* < pre-B3 */
+/* < pre-B3 */
+#define NEED_BIAS_CORRECTION(hwid)	(((hwid) > 0x0013 && \
+					(hwid) <= 0x1700) || ((hwid) < 0x0008))
 #define BIAS_CORRECTION		80
 
 #define THRESHOLD_GROUNDED	40
-#define THRESHOLD_VIDEO_HI	110
+#define THRESHOLD_VIDEO_HI	150
 #define THRESHOLD_HEADSET_HI	200
+#define THRESHOLD_ECI_LO	1950
+#define THRESHOLD_ECI_HI	2200
 
 static int detect(struct nokia_av_drvdata *drvdata)
 {
@@ -304,14 +332,45 @@ done:
 	return type;
 }
 
-/* Note: unplug-replug during detection won't be detected */
+/* HACK: Try to detect ECI headsets */
+static int detect_eci(struct nokia_av_drvdata *drvdata)
+{
+	int t = DET_ECI_RESET_DELAY;
+	int mv;
+	int type = UNKNOWN;
+
+	mutex_lock(&drvdata->detection_lock);
+
+	rx51_set_eci_mode(4);
+
+	/* Give the ECI headset sufficient time (more than 500 ms) to
+	 * reset and stabilize the mic line, bail out on unplug */
+	while (t > 0) {
+		if (!drvdata->headph_plugged) {
+			type = -1;
+			goto out;
+		}
+
+		msleep(t < 100 ? t : 100);
+		t -= 100;
+	}
+
+	mv = madc_stable_voltage(50, 5, 100);
+	if (mv > THRESHOLD_ECI_LO && mv < THRESHOLD_ECI_HI)
+		type = BASIC_HEADSET;
+
+	rx51_set_eci_mode(1);
+out:
+	mutex_unlock(&drvdata->detection_lock);
+
+	return type;
+}
+
+/* Main accessory detection routine. */
 static void detection_handler(struct work_struct *work)
 {
-	struct delayed_work *dwork =
-		container_of(work, struct delayed_work, work);
-	struct nokia_av_drvdata *drvdata =
-		container_of(dwork, struct nokia_av_drvdata, detection_work);
-	int status = 0;
+	struct nokia_av_drvdata *drvdata = container_of(work,
+		struct nokia_av_drvdata, detection_work.work);
 	int type;
 
 	/* This is a shortcut detection for connecting open cable */
@@ -324,25 +383,13 @@ static void detection_handler(struct wor
 	drvdata->type = UNKNOWN;
 
 	type = detect(drvdata);
-	switch (type) {
-	case BASIC_HEADSET:
-		status = SND_JACK_HEADSET;
-		break;
-	case HEADPHONES:
-		status = SND_JACK_HEADPHONE;
-		break;
-	case VIDEO_CABLE:
-		status = SND_JACK_AVOUT;
-		break;
-	}
-	status |= SND_JACK_MECHANICAL;
-
-	/* Unplug in the middle of detection will have been reported
-	 * immediately */
-	if (gpio_get_value(drvdata->headph_gpio))
-		return;
 
 	mutex_lock(&drvdata->lock);
+
+	/* Unplug in the middle of detection */
+	if (!drvdata->headph_plugged)
+		goto out;
+
 	if (type == drvdata->dettype) {
 		drvdata->detcount++;
 	} else {
@@ -350,26 +397,49 @@ static void detection_handler(struct wor
 		drvdata->dettype = type;
 	}
 
-	if (drvdata->detcount >= DET_REPEAT_COUNT) {
+	drvdata->dettotal++;
+
+	if (drvdata->detcount >= DET_REPEAT_COUNT ||
+		drvdata->dettotal >= DET_COUNT_MAX) {
+		int status = 0;
+
+		/* HACK: Try to detect the accessory as an ECI headset
+		 * only if unable to detect it as anything else. */
+		if (type == UNKNOWN || drvdata->dettotal >= DET_COUNT_MAX) {
+			/* Unlock to allow headph_handler to work */
+			mutex_unlock(&drvdata->lock);
+			type = detect_eci(drvdata);
+			mutex_lock(&drvdata->lock);
+
+			/* Unplug in the middle of ECI detection. */
+			if (type < 0 || !drvdata->headph_plugged)
+				goto out;
+		}
+
 		drvdata->type = type;
 		drvdata->dettype = UNKNOWN;
 		drvdata->detcount = 0;
+		drvdata->dettotal = 0;
 
-		if (type == BASIC_HEADSET) {
-			/* REVISIT: Button needs bias to work, but
-			 * ALSA should have bias control. However,
-			 * switching bias off and on causes a button
-			 * event. */
-			rx51_set_eci_mode(4); /* Detect button */
-			input_init(drvdata);
-		}
-
-		if (type == OPEN_CABLE) {
+		switch (type) {
+		case BASIC_HEADSET:
+			status = SND_JACK_HEADSET;
+			hs_btn_input_init(drvdata);
+			break;
+		case HEADPHONES:
+			status = SND_JACK_HEADPHONE;
+			break;
+		case VIDEO_CABLE:
+			status = SND_JACK_AVOUT;
+			break;
+		case OPEN_CABLE:
 			rx51_set_eci_mode(3); /* Detect connection */
 			queue_delayed_work(drvdata->workqueue,
 					&drvdata->detection_work,
 					msecs_to_jiffies(DET_OPEN_CABLE_DELAY));
+			break;
 		}
+		status |= SND_JACK_MECHANICAL;
 
 		rx51_jack_report(status);
 
@@ -378,45 +448,68 @@ static void detection_handler(struct wor
 				&drvdata->detection_work,
 				msecs_to_jiffies(DET_REPEAT_DELAY));
 	}
+out:
 	mutex_unlock(&drvdata->lock);
 }
 
-#if defined(CONFIG_SND_JACK)
-static void headphone_notify(void *data, int state)
+/* Debounced headphone plug handler */
+static void headph_handler(struct work_struct *work)
 {
-	struct nokia_av_drvdata *drvdata = data;
-
-	dev_dbg(drvdata->dev, "headphone_notify(): state %d, autodetect %d\n",
-		state, drvdata->autodetect);
+	struct nokia_av_drvdata *drvdata =
+		container_of(work, struct nokia_av_drvdata, headph_work);
+	int plugged;
 
 	if (!drvdata->autodetect) {
 		return;
 	}
 
+	plugged = !gpio_get_value(drvdata->headph_gpio);
+	if (drvdata->headph_plugged == plugged)
+		return;
+
 	mutex_lock(&drvdata->lock);
 
+	drvdata->headph_plugged = plugged;
+
 	drvdata->type = UNKNOWN;
 	drvdata->dettype = UNKNOWN;
 	drvdata->detcount = 0;
+	drvdata->dettotal = 0;
 
-	mutex_unlock(&drvdata->lock);
+	hs_btn_input_free(drvdata);
 
-	input_free(drvdata);
+	mutex_unlock(&drvdata->lock);
 
-	if (state) {
+	if (drvdata->headph_plugged) {
 		queue_delayed_work(drvdata->workqueue,
 				&drvdata->detection_work,
 				msecs_to_jiffies(DET_PLUG_DELAY));
 	} else {
+		cancel_delayed_work_sync(&drvdata->detection_work);
+
 		rx51_set_eci_mode(1);
 		rx51_jack_report(0);
 	}
 }
-#else
-static void headphone_notify(void *data, int state)
+
+/* Headphone plug debounce timer */
+static void headph_timer(unsigned long arg)
+{
+	struct nokia_av_drvdata *drvdata = (struct nokia_av_drvdata *) arg;
+
+	schedule_work(&drvdata->headph_work);
+}
+
+/* Headphone plug irq */
+static irqreturn_t headph_irq(int irq, void *_drvdata)
 {
+	struct nokia_av_drvdata *drvdata = _drvdata;
+
+	mod_timer(&drvdata->headph_timer,
+		jiffies + msecs_to_jiffies(HEADPH_DEBOUNCE));
+
+	return IRQ_HANDLED;
 }
-#endif
 
 static ssize_t detect_show(struct device *dev,
 			struct device_attribute *attr, char *buf)
@@ -531,13 +624,6 @@ static int __init nokia_av_probe(struct
 	struct nokia_av_drvdata *drvdata;
 	int ret;
 
-	struct omap_gpio_switch headphone_switch = {
-		.debounce_rising	= 400, /* Plug */
-		.debounce_falling	= 200, /* Unplug */
-		.notify			= headphone_notify,
-		.notify_data		= NULL,
-	};
-
 	drvdata = kzalloc(sizeof(*drvdata), GFP_KERNEL);
 	if (!drvdata) {
 		dev_err(&pdev->dev, "could not allocate memory\n");
@@ -570,8 +656,6 @@ static int __init nokia_av_probe(struct
 	mutex_init(&drvdata->detection_lock);
 	INIT_DELAYED_WORK(&drvdata->detection_work, detection_handler);
 
-	drvdata->debounce_rising = HS_BTN_DEBOUNCE_RISING;
-	drvdata->debounce_falling = HS_BTN_DEBOUNCE_FALLING;
 	INIT_WORK(&drvdata->hs_btn_work, hs_btn_handler);
 	init_timer(&drvdata->hs_btn_timer);
 	drvdata->hs_btn_timer.function = hs_btn_timer;
@@ -604,25 +688,32 @@ static int __init nokia_av_probe(struct
 	gpio_direction_input(drvdata->eci0_gpio);
 	gpio_direction_input(drvdata->eci1_gpio);
 
-	/* Add headphone switch callback */
-	headphone_switch.notify_data = drvdata;
-	headphone_switch.gpio = drvdata->headph_gpio;
-	ret = omap_update_gpio_switch(&headphone_switch);
+	/* Plug/unplug detection */
+	drvdata->headph_plugged = !gpio_get_value(drvdata->headph_gpio);
+
+	INIT_WORK(&drvdata->headph_work, headph_handler);
+	init_timer(&drvdata->headph_timer);
+	drvdata->headph_timer.function = headph_timer;
+	drvdata->headph_timer.data = (unsigned long)drvdata;
+
+	ret = request_irq(gpio_to_irq(drvdata->headph_gpio), headph_irq,
+			HEADPH_IRQ_FLAGS, "headph", drvdata);
 	if (ret) {
-		dev_err(&pdev->dev, "gpio switch update failed, %d\n", ret);
-		goto err_omap_gpio;
+		dev_err(&pdev->dev, "gpio %d irq request failed, %d\n",
+			drvdata->headph_gpio, ret);
+		goto err_headph;
 	}
 
 	dev_info(&pdev->dev, "accessory detect module initialized\n");
 
-	if (!gpio_get_value(drvdata->headph_gpio))
+	if (drvdata->headph_plugged)
 		queue_delayed_work(drvdata->workqueue,
 				&drvdata->detection_work,
 				msecs_to_jiffies(DET_PROBE_DELAY));
 
 	return 0;
 
-err_omap_gpio:
+err_headph:
 	gpio_free(drvdata->eci1_gpio);
 
 err_eci1:
@@ -649,19 +740,16 @@ static int __exit nokia_av_remove(struct
 {
 	struct nokia_av_drvdata *drvdata = platform_get_drvdata(pdev);
 
-	struct omap_gpio_switch headphone_switch = {
-		.gpio			= drvdata->headph_gpio,
-	};
+	free_irq(gpio_to_irq(drvdata->headph_gpio), drvdata);
 
-	/* Remove headphone switch callback */
-	omap_update_gpio_switch(&headphone_switch);
+	hs_btn_input_free(drvdata);
 
-	input_free(drvdata);
+	nokia_av_unregister_sysfs(pdev);
 
 	gpio_free(drvdata->eci0_gpio);
 	gpio_free(drvdata->eci1_gpio);
 
-	nokia_av_unregister_sysfs(pdev);
+	cancel_delayed_work_sync(&drvdata->detection_work);
 
 	destroy_workqueue(drvdata->workqueue);
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/misc/ssi/ssi_driver.c kernel-2.6.28-20093908+0m5/drivers/misc/ssi/ssi_driver.c
--- kernel-2.6.28-20091602+0m5/drivers/misc/ssi/ssi_driver.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/misc/ssi/ssi_driver.c	2012-12-16 13:13:01.672330147 +0100
@@ -52,8 +52,6 @@ int ssi_port_event_handler(struct ssi_po
 static int ssi_clk_event(struct notifier_block *nb, unsigned long event,
 								void *data)
 {
-	struct ssi_dev *ssi_ctrl = container_of(nb, struct ssi_dev, ssi_nb);
-
 	switch (event) {
 	case CLK_PRE_RATE_CHANGE:
 		break;
@@ -456,16 +454,21 @@ rollback1:
 	return err;
 }
 
-static void __exit close_all_ch(struct ssi_dev *ssi_ctrl)
+static void __exit unregister_ssi_devices(struct ssi_dev *ssi_ctrl)
 {
 	struct ssi_port *ssi_p;
+	struct ssi_device *device;
 	unsigned int port;
 	unsigned int ch;
 
 	for (port = 0; port < ssi_ctrl->max_p; port++) {
 		ssi_p = &ssi_ctrl->ssi_port[port];
-		for (ch = 0; ch < ssi_p->max_ch; ch++)
-			ssi_close(ssi_p->ssi_channel[ch].dev);
+		for (ch = 0; ch < ssi_p->max_ch; ch++) {
+			device = ssi_p->ssi_channel[ch].dev;
+			ssi_close(device);
+			device_unregister(&device->device);
+			kfree(device);
+		}
 	}
 }
 
@@ -476,7 +479,7 @@ static int __exit ssi_remove(struct plat
 	if (!ssi_ctrl)
 		return 0;
 
-	close_all_ch(ssi_ctrl);
+	unregister_ssi_devices(ssi_ctrl);
 	ssi_debug_remove_ctrl(ssi_ctrl);
 	ssi_controller_exit(ssi_ctrl);
 	kfree(ssi_ctrl);
@@ -521,9 +524,9 @@ rback1:
 
 static void __exit ssi_driver_exit(void)
 {
-	ssi_bus_exit();
-	ssi_debug_exit();
 	platform_driver_unregister(&ssi_pdriver);
+	ssi_debug_exit();
+	ssi_bus_exit();
 
 	pr_info("SSI DRIVER removed\n");
 }
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/misc/ssi/ssi_driver_gpio.c kernel-2.6.28-20093908+0m5/drivers/misc/ssi/ssi_driver_gpio.c
--- kernel-2.6.28-20091602+0m5/drivers/misc/ssi/ssi_driver_gpio.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/misc/ssi/ssi_driver_gpio.c	2012-12-16 13:13:01.672330147 +0100
@@ -57,14 +57,15 @@ int __init ssi_cawake_init(struct ssi_po
 {
 	tasklet_init(&port->cawake_tasklet, do_ssi_cawake_tasklet,
 							(unsigned long)port);
-
-	if (request_irq(port->cawake_gpio_irq, ssi_cawake_isr, IRQF_DISABLED,
+	if (request_irq(port->cawake_gpio_irq, ssi_cawake_isr,
+		IRQF_DISABLED | IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
 							irq_name, port) < 0) {
 		dev_err(port->ssi_controller->dev,
-			"FAILED to request CAWAKE GPIO IRQ %d on port %d\n",
-			port->cawake_gpio_irq, port->port_number);
+			"FAILED to request %s GPIO IRQ %d on port %d\n",
+			irq_name, port->cawake_gpio_irq, port->port_number);
 		return -EBUSY;
 	}
+	enable_irq_wake(port->cawake_gpio_irq);
 
 	return 0;
 }
@@ -74,5 +75,7 @@ void ssi_cawake_exit(struct ssi_port *po
 	if (port->cawake_gpio < 0)
 		return;	/* Nothing to do */
 
+	disable_irq_wake(port->cawake_gpio_irq);
+	tasklet_kill(&port->cawake_tasklet);
 	free_irq(port->cawake_gpio_irq, port);
 }
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/misc/ssi/ssi_driver.h kernel-2.6.28-20093908+0m5/drivers/misc/ssi/ssi_driver.h
--- kernel-2.6.28-20091602+0m5/drivers/misc/ssi/ssi_driver.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/misc/ssi/ssi_driver.h	2012-12-16 13:13:01.672330147 +0100
@@ -149,7 +149,7 @@ struct ssi_dev {
 	struct clk *ssi_clk;
 	void __iomem *base;
 	spinlock_t lock;
-	unsigned cawake_clk_enable:1;
+	unsigned int cawake_clk_enable:1;
 	int gdd_irq;
 	unsigned int gdd_usecount;
 	unsigned int last_gdd_lch;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/misc/ssi/ssi_driver_if.c kernel-2.6.28-20093908+0m5/drivers/misc/ssi/ssi_driver_if.c
--- kernel-2.6.28-20091602+0m5/drivers/misc/ssi/ssi_driver_if.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/misc/ssi/ssi_driver_if.c	2012-12-16 13:13:01.672330147 +0100
@@ -241,6 +241,7 @@ int ssi_ioctl(struct ssi_device *dev, un
 	void __iomem *base;
 	unsigned int port, channel;
 	u32 wake;
+	u32 v;
 	int err = 0;
 
 	if (unlikely((!dev) ||
@@ -304,6 +305,17 @@ int ssi_ioctl(struct ssi_device *dev, un
 		}
 		*(unsigned int *)arg = ssi_cawake(dev->ch->ssi_port);
 		break;
+	case SSI_IOCTL_TX_CH_FULL:
+		if (!arg) {
+			err = -EINVAL;
+			goto out;
+		}
+		v = ssi_inl(base, SSI_SST_BUFSTATE_REG(port));
+		*(unsigned int *)arg = v & (1 << channel);
+		break;
+	case SSI_IOCTL_CH_DATAACCEPT:
+		ssi_driver_write_interrupt(dev->ch, NULL);
+		break;
 	default:
 		err = -ENOIOCTLCMD;
 		break;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/misc/ssi/ssi_driver_int.c kernel-2.6.28-20093908+0m5/drivers/misc/ssi/ssi_driver_int.c
--- kernel-2.6.28-20091602+0m5/drivers/misc/ssi/ssi_driver_int.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/misc/ssi/ssi_driver_int.c	2012-12-16 13:13:01.676330146 +0100
@@ -169,38 +169,34 @@ static void do_ssi_tasklet(unsigned long
 	struct ssi_dev *ssi_ctrl = pport->ssi_controller;
 	void __iomem *base = ssi_ctrl->base;
 	unsigned int port = pport->port_number;
-	unsigned int channel = 0;
+	unsigned int channel;
 	unsigned int irq = pport->n_irq;
+	u32 channels_served = 0;
 	u32 status_reg;
-	u32 enable_reg;
 	u32 ssr_err_reg;
-	u32 channels_served;
 
 	clk_enable(ssi_ctrl->ssi_clk);
 
-	channels_served = 0;
 	status_reg = ssi_inl(base, SSI_SYS_MPU_STATUS_REG(port, irq));
-	enable_reg = ssi_inl(base, SSI_SYS_MPU_ENABLE_REG(port, irq));
+	status_reg &= ssi_inl(base, SSI_SYS_MPU_ENABLE_REG(port, irq));
 
 	for (channel = 0; channel < pport->max_ch; channel++) {
-		if ((status_reg & SSI_SST_DATAACCEPT(channel)) &&
-		    (enable_reg & SSI_SST_DATAACCEPT(channel))) {
+		if (status_reg & SSI_SST_DATAACCEPT(channel)) {
 			do_channel_tx(&pport->ssi_channel[channel]);
 			channels_served |= SSI_SST_DATAACCEPT(channel);
 		}
 
-		if ((status_reg & SSI_SSR_DATAAVAILABLE(channel)) &&
-		    (enable_reg & SSI_SSR_DATAAVAILABLE(channel))) {
+		if (status_reg & SSI_SSR_DATAAVAILABLE(channel)) {
 			do_channel_rx(&pport->ssi_channel[channel]);
 			channels_served |= SSI_SSR_DATAAVAILABLE(channel);
 		}
 	}
 
-	if ((status_reg & SSI_BREAKDETECTED) &&
-	    (enable_reg & SSI_BREAKDETECTED)) {
+	if (status_reg & SSI_BREAKDETECTED) {
 		dev_info(ssi_ctrl->dev, "Hardware BREAK on port %d\n", port);
 		ssi_outl(0, base, SSI_SSR_BREAK_REG(port));
 		ssi_port_event_handler(pport, SSI_EVENT_BREAK_DETECTED, NULL);
+		channels_served |= SSI_BREAKDETECTED;
 	}
 
 	if (status_reg & SSI_ERROROCCURED) {
@@ -208,17 +204,22 @@ static void do_ssi_tasklet(unsigned long
 		dev_err(ssi_ctrl->dev, "SSI ERROR Port %d: 0x%02x\n",
 							port, ssr_err_reg);
 		ssi_outl(ssr_err_reg, base, SSI_SSR_ERRORACK_REG(port));
-		ssi_port_event_handler(pport, SSI_EVENT_ERROR, NULL);
+		if (ssr_err_reg) /* Ignore spurios errors */
+			ssi_port_event_handler(pport, SSI_EVENT_ERROR, NULL);
+		else
+			dev_dbg(ssi_ctrl->dev, "spurious SSI error!\n");
+
+		channels_served |= SSI_ERROROCCURED;
 	}
 
-	ssi_outl((channels_served | SSI_ERROROCCURED | SSI_BREAKDETECTED), base,
-					SSI_SYS_MPU_STATUS_REG(port, irq));
+	ssi_outl(channels_served, base, SSI_SYS_MPU_STATUS_REG(port, irq));
 
 	status_reg = ssi_inl(base, SSI_SYS_MPU_STATUS_REG(port, irq));
-	enable_reg = ssi_inl(base, SSI_SYS_MPU_ENABLE_REG(port, irq));
+	status_reg &= ssi_inl(base, SSI_SYS_MPU_ENABLE_REG(port, irq));
+
 	clk_disable(ssi_ctrl->ssi_clk);
 
-	if (status_reg & enable_reg)
+	if (status_reg)
 		tasklet_hi_schedule(&pport->ssi_tasklet);
 	else
 		enable_irq(pport->irq);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mmc/core/core.c kernel-2.6.28-20093908+0m5/drivers/mmc/core/core.c
--- kernel-2.6.28-20091602+0m5/drivers/mmc/core/core.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mmc/core/core.c	2012-12-16 13:13:01.676330146 +0100
@@ -327,6 +327,98 @@ unsigned int mmc_align_data_size(struct
 EXPORT_SYMBOL(mmc_align_data_size);
 
 /**
+ *	mmc_host_enable - enable a host.
+ *	@host: mmc host to enable
+ *
+ *	Hosts that support power saving can use the 'enable' and 'disable'
+ *	methods to exit and enter power saving states. For more information
+ *	see comments for struct mmc_host_ops.
+ */
+int mmc_host_enable(struct mmc_host *host)
+{
+	if (!(host->caps & MMC_CAP_DISABLE))
+		return 0;
+
+	if (host->en_dis_recurs)
+		return 0;
+
+	if (host->nesting_cnt++)
+		return 0;
+
+	cancel_delayed_work_sync(&host->disable);
+
+	if (host->enabled)
+		return 0;
+
+	if (host->ops->enable) {
+		int err;
+
+		host->en_dis_recurs = 1;
+		err = host->ops->enable(host);
+		host->en_dis_recurs = 0;
+
+		if (err) {
+			pr_debug("%s: enable error %d\n",
+				 mmc_hostname(host), err);
+			return err;
+		}
+	}
+	host->enabled = 1;
+	return 0;
+}
+EXPORT_SYMBOL(mmc_host_enable);
+
+static int mmc_host_do_disable(struct mmc_host *host, int lazy)
+{
+	if (host->ops->disable) {
+		int err;
+
+		host->en_dis_recurs = 1;
+		err = host->ops->disable(host, lazy);
+		host->en_dis_recurs = 0;
+
+		if (err < 0) {
+			pr_debug("%s: disable error %d\n",
+				 mmc_hostname(host), err);
+			return err;
+		}
+		if (err > 0)
+			mmc_schedule_delayed_work(&host->disable, err);
+	}
+	host->enabled = 0;
+	return 0;
+}
+
+/**
+ *	mmc_host_disable - disable a host.
+ *	@host: mmc host to disable
+ *
+ *	Hosts that support power saving can use the 'enable' and 'disable'
+ *	methods to exit and enter power saving states. For more information
+ *	see comments for struct mmc_host_ops.
+ */
+int mmc_host_disable(struct mmc_host *host)
+{
+	int err;
+
+	if (!(host->caps & MMC_CAP_DISABLE))
+		return 0;
+
+	if (host->en_dis_recurs)
+		return 0;
+
+	if (--host->nesting_cnt)
+		return 0;
+
+	if (!host->enabled)
+		return 0;
+
+	err = mmc_host_do_disable(host, 0);
+	return err;
+}
+EXPORT_SYMBOL(mmc_host_disable);
+
+/**
  *	__mmc_claim_host - exclusively claim a host
  *	@host: mmc host to claim
  *	@abort: whether or not the operation should be aborted
@@ -349,25 +441,111 @@ int __mmc_claim_host(struct mmc_host *ho
 	while (1) {
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		stop = abort ? atomic_read(abort) : 0;
-		if (stop || !host->claimed)
+		if (stop || !host->claimed || host->claimer == current)
 			break;
 		spin_unlock_irqrestore(&host->lock, flags);
 		schedule();
 		spin_lock_irqsave(&host->lock, flags);
 	}
 	set_current_state(TASK_RUNNING);
-	if (!stop)
+	if (!stop) {
 		host->claimed = 1;
-	else
+		host->claimer = current;
+		host->claim_cnt += 1;
+	} else
 		wake_up(&host->wq);
 	spin_unlock_irqrestore(&host->lock, flags);
 	remove_wait_queue(&host->wq, &wait);
+	if (!stop)
+		mmc_host_enable(host);
 	return stop;
 }
 
 EXPORT_SYMBOL(__mmc_claim_host);
 
 /**
+ *	mmc_try_claim_host - try exclusively to claim a host
+ *	@host: mmc host to claim
+ *
+ *	Returns %1 if the host is claimed, %0 otherwise.
+ */
+int mmc_try_claim_host(struct mmc_host *host)
+{
+	int claimed_host = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	if (!host->claimed || host->claimer == current) {
+		host->claimed = 1;
+		host->claimer = current;
+		host->claim_cnt += 1;
+		claimed_host = 1;
+	}
+	spin_unlock_irqrestore(&host->lock, flags);
+	return claimed_host;
+}
+EXPORT_SYMBOL(mmc_try_claim_host);
+
+static void mmc_do_release_host(struct mmc_host *host)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	if (--host->claim_cnt) {
+		/* Release for nested claim */
+		spin_unlock_irqrestore(&host->lock, flags);
+	} else {
+		host->claimed = 0;
+		host->claimer = NULL;
+		spin_unlock_irqrestore(&host->lock, flags);
+		wake_up(&host->wq);
+	}
+}
+
+void mmc_host_deeper_disable(struct work_struct *work)
+{
+	struct mmc_host *host =
+		container_of(work, struct mmc_host, disable.work);
+
+	/* If the host is claimed then we do not want to disable it anymore */
+	if (!mmc_try_claim_host(host))
+		return;
+	mmc_host_do_disable(host, 1);
+	mmc_do_release_host(host);
+}
+
+/**
+ *	mmc_host_lazy_disable - lazily disable a host.
+ *	@host: mmc host to disable
+ *
+ *	Hosts that support power saving can use the 'enable' and 'disable'
+ *	methods to exit and enter power saving states. For more information
+ *	see comments for struct mmc_host_ops.
+ */
+int mmc_host_lazy_disable(struct mmc_host *host)
+{
+	if (!(host->caps & MMC_CAP_DISABLE))
+		return 0;
+
+	if (host->en_dis_recurs)
+		return 0;
+
+	if (--host->nesting_cnt)
+		return 0;
+
+	if (!host->enabled)
+		return 0;
+
+	if (host->disable_delay) {
+		mmc_schedule_delayed_work(&host->disable,
+				msecs_to_jiffies(host->disable_delay));
+		return 0;
+	} else
+		return mmc_host_do_disable(host, 1);
+}
+EXPORT_SYMBOL(mmc_host_lazy_disable);
+
+/**
  *	mmc_release_host - release a host
  *	@host: mmc host to release
  *
@@ -376,15 +554,11 @@ EXPORT_SYMBOL(__mmc_claim_host);
  */
 void mmc_release_host(struct mmc_host *host)
 {
-	unsigned long flags;
-
 	WARN_ON(!host->claimed);
 
-	spin_lock_irqsave(&host->lock, flags);
-	host->claimed = 0;
-	spin_unlock_irqrestore(&host->lock, flags);
+	mmc_host_lazy_disable(host);
 
-	wake_up(&host->wq);
+	mmc_do_release_host(host);
 }
 
 EXPORT_SYMBOL(mmc_release_host);
@@ -694,7 +868,11 @@ void mmc_rescan(struct work_struct *work
 		mmc_power_up(host);
 		mmc_go_idle(host);
 
-		mmc_send_if_cond(host, host->ocr_avail);
+		if (!(host->caps & MMC_CAP_NOT_SDIO) || !(host->caps & MMC_CAP_NOT_SD))
+			mmc_send_if_cond(host, host->ocr_avail);
+
+		if (host->caps & MMC_CAP_NOT_SDIO)
+			goto not_sdio;
 
 		/*
 		 * First we search for SDIO...
@@ -706,6 +884,9 @@ void mmc_rescan(struct work_struct *work
 			goto out;
 		}
 
+not_sdio:	if (host->caps & MMC_CAP_NOT_SD)
+			goto not_sd;
+
 		/*
 		 * ...then normal SD...
 		 */
@@ -716,6 +897,9 @@ void mmc_rescan(struct work_struct *work
 			goto out;
 		}
 
+not_sd:		if (host->caps & MMC_CAP_NOT_MMC)
+			goto not_mmc;
+
 		/*
 		 * ...and finally MMC.
 		 */
@@ -725,7 +909,7 @@ void mmc_rescan(struct work_struct *work
 				mmc_power_off(host);
 			goto out;
 		}
-
+not_mmc:
 		mmc_release_host(host);
 		mmc_power_off(host);
 	} else
@@ -750,6 +934,8 @@ void mmc_stop_host(struct mmc_host *host
 	spin_unlock_irqrestore(&host->lock, flags);
 #endif
 
+	if (host->caps & MMC_CAP_DISABLE)
+		cancel_delayed_work(&host->disable);
 	cancel_delayed_work(&host->detect);
 	mmc_flush_scheduled_work();
 
@@ -761,6 +947,8 @@ void mmc_stop_host(struct mmc_host *host
 		mmc_claim_host(host);
 		mmc_detach_bus(host);
 		mmc_release_host(host);
+		mmc_bus_put(host);
+		return;
 	}
 	mmc_bus_put(host);
 
@@ -769,6 +957,80 @@ void mmc_stop_host(struct mmc_host *host
 	mmc_power_off(host);
 }
 
+void mmc_power_save_host(struct mmc_host *host)
+{
+	mmc_bus_get(host);
+
+	if (!host->bus_ops || host->bus_dead || !host->bus_ops->power_restore) {
+		mmc_bus_put(host);
+		return;
+	}
+
+	if (host->bus_ops->power_save)
+		host->bus_ops->power_save(host);
+
+	mmc_bus_put(host);
+
+	mmc_power_off(host);
+}
+EXPORT_SYMBOL(mmc_power_save_host);
+
+void mmc_power_restore_host(struct mmc_host *host)
+{
+	mmc_bus_get(host);
+
+	if (!host->bus_ops || host->bus_dead || !host->bus_ops->power_restore) {
+		mmc_bus_put(host);
+		return;
+	}
+
+	mmc_power_up(host);
+	host->bus_ops->power_restore(host);
+
+	mmc_bus_put(host);
+}
+EXPORT_SYMBOL(mmc_power_restore_host);
+
+int mmc_card_awake(struct mmc_host *host)
+{
+	int err = -ENOSYS;
+
+	mmc_bus_get(host);
+
+	if (host->bus_ops && !host->bus_dead && host->bus_ops->awake)
+		err = host->bus_ops->awake(host);
+
+	mmc_bus_put(host);
+
+	return err;
+}
+EXPORT_SYMBOL(mmc_card_awake);
+
+int mmc_card_sleep(struct mmc_host *host)
+{
+	int err = -ENOSYS;
+
+	mmc_bus_get(host);
+
+	if (host->bus_ops && !host->bus_dead && host->bus_ops->awake)
+		err = host->bus_ops->sleep(host);
+
+	mmc_bus_put(host);
+
+	return err;
+}
+EXPORT_SYMBOL(mmc_card_sleep);
+
+int mmc_card_can_sleep(struct mmc_host *host)
+{
+	struct mmc_card *card = host->card;
+
+	if (card && mmc_card_mmc(card) && card->ext_csd.rev >= 3)
+		return 1;
+	return 0;
+}
+EXPORT_SYMBOL(mmc_card_can_sleep);
+
 #ifdef CONFIG_PM
 
 /**
@@ -778,6 +1040,8 @@ void mmc_stop_host(struct mmc_host *host
  */
 int mmc_suspend_host(struct mmc_host *host, pm_message_t state)
 {
+	if (host->caps & MMC_CAP_DISABLE)
+		cancel_delayed_work(&host->disable);
 	cancel_delayed_work(&host->detect);
 	mmc_flush_scheduled_work();
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mmc/core/core.h kernel-2.6.28-20093908+0m5/drivers/mmc/core/core.h
--- kernel-2.6.28-20091602+0m5/drivers/mmc/core/core.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mmc/core/core.h	2012-12-16 13:13:01.676330146 +0100
@@ -16,10 +16,14 @@
 #define MMC_CMD_RETRIES        3
 
 struct mmc_bus_ops {
+	int (*awake)(struct mmc_host *);
+	int (*sleep)(struct mmc_host *);
 	void (*remove)(struct mmc_host *);
 	void (*detect)(struct mmc_host *);
 	void (*suspend)(struct mmc_host *);
 	void (*resume)(struct mmc_host *);
+	void (*power_save)(struct mmc_host *);
+	void (*power_restore)(struct mmc_host *);
 };
 
 void mmc_attach_bus(struct mmc_host *host, const struct mmc_bus_ops *ops);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mmc/core/debugfs.c kernel-2.6.28-20093908+0m5/drivers/mmc/core/debugfs.c
--- kernel-2.6.28-20091602+0m5/drivers/mmc/core/debugfs.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mmc/core/debugfs.c	2012-12-16 13:13:01.676330146 +0100
@@ -184,6 +184,68 @@ static int mmc_dbg_card_status_get(void
 DEFINE_SIMPLE_ATTRIBUTE(mmc_dbg_card_status_fops, mmc_dbg_card_status_get,
 		NULL, "%08llx\n");
 
+#define EXT_CSD_STR_LEN 1025
+
+static int mmc_ext_csd_open(struct inode *inode, struct file *filp)
+{
+	struct mmc_card *card = inode->i_private;
+	char *buf;
+	ssize_t n = 0;
+	u8 *ext_csd;
+	int err, i;
+
+	buf = kmalloc(EXT_CSD_STR_LEN + 1, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ext_csd = kmalloc(512, GFP_KERNEL);
+	if (!ext_csd) {
+		err = -ENOMEM;
+		goto out_free;
+	}
+
+	mmc_claim_host(card->host);
+	err = mmc_send_ext_csd(card, ext_csd);
+	mmc_release_host(card->host);
+	if (err)
+		goto out_free;
+
+	for (i = 511; i >= 0; i--)
+		n += sprintf(buf + n, "%02x", ext_csd[i]);
+	n += sprintf(buf + n, "\n");
+	BUG_ON(n != EXT_CSD_STR_LEN);
+
+	filp->private_data = buf;
+	kfree(ext_csd);
+	return 0;
+
+out_free:
+	kfree(buf);
+	kfree(ext_csd);
+	return err;
+}
+
+static ssize_t mmc_ext_csd_read(struct file *filp, char __user *ubuf,
+				size_t cnt, loff_t *ppos)
+{
+	char *buf = filp->private_data;
+
+	return simple_read_from_buffer(ubuf, cnt, ppos,
+				       buf, EXT_CSD_STR_LEN);
+}
+
+static int mmc_ext_csd_release(struct inode *inode, struct file *file)
+{
+	kfree(file->private_data);
+	return 0;
+}
+
+static struct file_operations mmc_dbg_ext_csd_fops = {
+	.open		= mmc_ext_csd_open,
+	.read		= mmc_ext_csd_read,
+	.release	= mmc_ext_csd_release,
+};
+
 void mmc_add_card_debugfs(struct mmc_card *card)
 {
 	struct mmc_host	*host = card->host;
@@ -211,6 +273,11 @@ void mmc_add_card_debugfs(struct mmc_car
 					&mmc_dbg_card_status_fops))
 			goto err;
 
+	if (mmc_card_mmc(card))
+		if (!debugfs_create_file("ext_csd", S_IRUSR, root, card,
+					&mmc_dbg_ext_csd_fops))
+			goto err;
+
 	return;
 
 err:
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mmc/core/host.c kernel-2.6.28-20093908+0m5/drivers/mmc/core/host.c
--- kernel-2.6.28-20091602+0m5/drivers/mmc/core/host.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mmc/core/host.c	2012-12-16 13:13:01.676330146 +0100
@@ -83,6 +83,7 @@ struct mmc_host *mmc_alloc_host(int extr
 	spin_lock_init(&host->lock);
 	init_waitqueue_head(&host->wq);
 	INIT_DELAYED_WORK(&host->detect, mmc_rescan);
+	INIT_DELAYED_WORK(&host->disable, mmc_host_deeper_disable);
 
 	/*
 	 * By default, hosts do not support SGIO or large requests.
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mmc/core/host.h kernel-2.6.28-20093908+0m5/drivers/mmc/core/host.h
--- kernel-2.6.28-20091602+0m5/drivers/mmc/core/host.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mmc/core/host.h	2012-12-16 13:13:01.676330146 +0100
@@ -14,5 +14,7 @@
 int mmc_register_host_class(void);
 void mmc_unregister_host_class(void);
 
+void mmc_host_deeper_disable(struct work_struct *work);
+
 #endif
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mmc/core/mmc.c kernel-2.6.28-20093908+0m5/drivers/mmc/core/mmc.c
--- kernel-2.6.28-20091602+0m5/drivers/mmc/core/mmc.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mmc/core/mmc.c	2012-12-16 13:13:01.676330146 +0100
@@ -160,7 +160,6 @@ static int mmc_read_ext_csd(struct mmc_c
 {
 	int err;
 	u8 *ext_csd;
-	unsigned int ext_csd_struct;
 
 	BUG_ON(!card);
 
@@ -207,16 +206,16 @@ static int mmc_read_ext_csd(struct mmc_c
 		goto out;
 	}
 
-	ext_csd_struct = ext_csd[EXT_CSD_REV];
-	if (ext_csd_struct > 3) {
+	card->ext_csd.rev = ext_csd[EXT_CSD_REV];
+	if (card->ext_csd.rev > 3) {
 		printk(KERN_ERR "%s: unrecognised EXT_CSD structure "
 			"version %d\n", mmc_hostname(card->host),
-			ext_csd_struct);
+			card->ext_csd.rev);
 		err = -EINVAL;
 		goto out;
 	}
 
-	if (ext_csd_struct >= 2) {
+	if (card->ext_csd.rev >= 2) {
 		card->ext_csd.sectors =
 			ext_csd[EXT_CSD_SEC_CNT + 0] << 0 |
 			ext_csd[EXT_CSD_SEC_CNT + 1] << 8 |
@@ -241,6 +240,15 @@ static int mmc_read_ext_csd(struct mmc_c
 		goto out;
 	}
 
+	if (card->ext_csd.rev >= 3) {
+		u8 sa_shift = ext_csd[EXT_CSD_S_A_TIMEOUT];
+
+		/* Sleep / awake timeout in 100ns units */
+		if (sa_shift > 0 && sa_shift <= 0x17)
+			card->ext_csd.sa_timeout =
+					1 << ext_csd[EXT_CSD_S_A_TIMEOUT];
+	}
+
 out:
 	kfree(ext_csd);
 
@@ -408,12 +416,17 @@ static int mmc_init_card(struct mmc_host
 		(host->caps & MMC_CAP_MMC_HIGHSPEED)) {
 		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 			EXT_CSD_HS_TIMING, 1);
-		if (err)
+		if (err && err != -EBADMSG)
 			goto free_card;
 
-		mmc_card_set_highspeed(card);
-
-		mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
+		if (err) {
+			printk(KERN_WARNING "%s: switch to highspeed failed\n",
+			       mmc_hostname(card->host));
+			err = 0;
+		} else {
+			mmc_card_set_highspeed(card);
+			mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
+		}
 	}
 
 	/*
@@ -448,10 +461,17 @@ static int mmc_init_card(struct mmc_host
 		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 				 EXT_CSD_BUS_WIDTH, ext_csd_bit);
 
-		if (err)
+		if (err && err != -EBADMSG)
 			goto free_card;
 
-		mmc_set_bus_width(card->host, bus_width);
+		if (err) {
+			printk(KERN_WARNING "%s: switch to bus width %d "
+			       "failed\n", mmc_hostname(card->host),
+			       1 << bus_width);
+			err = 0;
+		} else {
+			mmc_set_bus_width(card->host, bus_width);
+		}
 	}
 
 	if (!oldcard)
@@ -507,8 +527,6 @@ static void mmc_detect(struct mmc_host *
 	}
 }
 
-#ifdef CONFIG_MMC_UNSAFE_RESUME
-
 /*
  * Suspend callback from host.
  */
@@ -551,20 +569,96 @@ static void mmc_resume(struct mmc_host *
 
 }
 
-#else
+static void mmc_power_restore(struct mmc_host *host)
+{
+	host->card->state &= ~MMC_STATE_HIGHSPEED;
+	mmc_claim_host(host);
+	mmc_init_card(host, host->ocr, host->card);
+	mmc_release_host(host);
+}
 
-#define mmc_suspend NULL
-#define mmc_resume NULL
+static int mmc_sleep(struct mmc_host *host)
+{
+	struct mmc_card *card = host->card;
+	int err = -ENOSYS;
 
-#endif
+	if (card && card->ext_csd.rev >= 3) {
+		err = mmc_card_sleepawake(host, 1);
+		if (err < 0)
+			pr_debug("%s: Error %d while putting card into sleep",
+				 mmc_hostname(host), err);
+	}
+
+	return err;
+}
+
+static int mmc_awake(struct mmc_host *host)
+{
+	struct mmc_card *card = host->card;
+	int err = -ENOSYS;
+
+	if (card && card->ext_csd.rev >= 3) {
+		err = mmc_card_sleepawake(host, 0);
+		if (err < 0)
+			pr_debug("%s: Error %d while awaking sleeping card",
+				 mmc_hostname(host), err);
+	}
+
+	return err;
+}
+
+#ifdef CONFIG_MMC_UNSAFE_RESUME
+
+static const struct mmc_bus_ops mmc_ops = {
+	.awake = mmc_awake,
+	.sleep = mmc_sleep,
+	.remove = mmc_remove,
+	.detect = mmc_detect,
+	.suspend = mmc_suspend,
+	.resume = mmc_resume,
+	.power_restore = mmc_power_restore,
+};
+
+static void mmc_attach_bus_ops(struct mmc_host *host)
+{
+	mmc_attach_bus(host, &mmc_ops);
+}
+
+#else
 
 static const struct mmc_bus_ops mmc_ops = {
+	.awake = mmc_awake,
+	.sleep = mmc_sleep,
+	.remove = mmc_remove,
+	.detect = mmc_detect,
+	.suspend = NULL,
+	.resume = NULL,
+	.power_restore = mmc_power_restore,
+};
+
+static const struct mmc_bus_ops mmc_ops_unsafe = {
+	.awake = mmc_awake,
+	.sleep = mmc_sleep,
 	.remove = mmc_remove,
 	.detect = mmc_detect,
 	.suspend = mmc_suspend,
 	.resume = mmc_resume,
+	.power_restore = mmc_power_restore,
 };
 
+static void mmc_attach_bus_ops(struct mmc_host *host)
+{
+	const struct mmc_bus_ops *bus_ops;
+
+	if (host->caps & MMC_CAP_NONREMOVABLE)
+		bus_ops = &mmc_ops_unsafe;
+	else
+		bus_ops = &mmc_ops;
+	mmc_attach_bus(host, bus_ops);
+}
+
+#endif
+
 /*
  * Starting point for MMC card init.
  */
@@ -575,7 +669,7 @@ int mmc_attach_mmc(struct mmc_host *host
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
-	mmc_attach_bus(host, &mmc_ops);
+	mmc_attach_bus_ops(host);
 
 	/*
 	 * We need to get OCR a different way for SPI.
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mmc/core/mmc_ops.c kernel-2.6.28-20093908+0m5/drivers/mmc/core/mmc_ops.c
--- kernel-2.6.28-20091602+0m5/drivers/mmc/core/mmc_ops.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mmc/core/mmc_ops.c	2012-12-16 13:13:01.676330146 +0100
@@ -57,6 +57,34 @@ int mmc_deselect_cards(struct mmc_host *
 	return _mmc_select_card(host, NULL);
 }
 
+int mmc_card_sleepawake(struct mmc_host *host, int sleep)
+{
+	struct mmc_command cmd;
+	struct mmc_card *card = host->card;
+	int err;
+
+	if (sleep)
+		mmc_deselect_cards(host);
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_SLEEP_AWAKE;
+	cmd.arg = card->rca << 16;
+	if (sleep)
+		cmd.arg |= 1 << 15;
+
+	cmd.flags = MMC_RSP_R1B | MMC_CMD_AC;
+	err = mmc_wait_for_cmd(host, &cmd, 0);
+
+	if (err)
+		return err;
+
+	if (!sleep)
+		err = mmc_select_card(card);
+
+	return err;
+}
+
 int mmc_go_idle(struct mmc_host *host)
 {
 	int err;
@@ -355,6 +383,7 @@ int mmc_switch(struct mmc_card *card, u8
 {
 	int err;
 	struct mmc_command cmd;
+	u32 status;
 
 	BUG_ON(!card);
 	BUG_ON(!card->host);
@@ -372,6 +401,21 @@ int mmc_switch(struct mmc_card *card, u8
 	if (err)
 		return err;
 
+	err = mmc_send_status(card, &status);
+	if (err)
+		return err;
+
+	if (mmc_host_is_spi(card->host)) {
+		if (status & R1_SPI_ILLEGAL_COMMAND)
+			return -EBADMSG;
+	} else {
+		if (status & 0xFDFFA000)
+			printk(KERN_WARNING "%s: unexpected status %#x after "
+			       "switch", mmc_hostname(card->host), status);
+		if (status & R1_SWITCH_ERROR)
+			return -EBADMSG;
+	}
+
 	return 0;
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mmc/core/mmc_ops.h kernel-2.6.28-20093908+0m5/drivers/mmc/core/mmc_ops.h
--- kernel-2.6.28-20091602+0m5/drivers/mmc/core/mmc_ops.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mmc/core/mmc_ops.h	2012-12-16 13:13:01.676330146 +0100
@@ -25,6 +25,7 @@ int mmc_send_status(struct mmc_card *car
 int mmc_send_cid(struct mmc_host *host, u32 *cid);
 int mmc_spi_read_ocr(struct mmc_host *host, int highcap, u32 *ocrp);
 int mmc_spi_set_crc(struct mmc_host *host, int use_crc);
+int mmc_card_sleepawake(struct mmc_host *host, int sleep);
 
 #endif
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mmc/core/sd.c kernel-2.6.28-20093908+0m5/drivers/mmc/core/sd.c
--- kernel-2.6.28-20091602+0m5/drivers/mmc/core/sd.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mmc/core/sd.c	2012-12-16 13:13:01.676330146 +0100
@@ -558,8 +558,6 @@ static void mmc_sd_detect(struct mmc_hos
 	}
 }
 
-#ifdef CONFIG_MMC_UNSAFE_RESUME
-
 /*
  * Suspend callback from host.
  */
@@ -602,20 +600,60 @@ static void mmc_sd_resume(struct mmc_hos
 
 }
 
-#else
+static void mmc_sd_power_restore(struct mmc_host *host)
+{
+	host->card->state &= ~MMC_STATE_HIGHSPEED;
+	mmc_claim_host(host);
+	mmc_sd_init_card(host, host->ocr, host->card);
+	mmc_release_host(host);
+}
 
-#define mmc_sd_suspend NULL
-#define mmc_sd_resume NULL
+#ifdef CONFIG_MMC_UNSAFE_RESUME
 
-#endif
+static const struct mmc_bus_ops mmc_sd_ops = {
+	.remove = mmc_sd_remove,
+	.detect = mmc_sd_detect,
+	.suspend = mmc_sd_suspend,
+	.resume = mmc_sd_resume,
+	.power_restore = mmc_sd_power_restore,
+};
+
+static void mmc_sd_attach_bus_ops(struct mmc_host *host)
+{
+	mmc_attach_bus(host, &mmc_sd_ops);
+}
+
+#else
 
 static const struct mmc_bus_ops mmc_sd_ops = {
 	.remove = mmc_sd_remove,
 	.detect = mmc_sd_detect,
+	.suspend = NULL,
+	.resume = NULL,
+	.power_restore = mmc_sd_power_restore,
+};
+
+static const struct mmc_bus_ops mmc_sd_ops_unsafe = {
+	.remove = mmc_sd_remove,
+	.detect = mmc_sd_detect,
 	.suspend = mmc_sd_suspend,
 	.resume = mmc_sd_resume,
+	.power_restore = mmc_sd_power_restore,
 };
 
+static void mmc_sd_attach_bus_ops(struct mmc_host *host)
+{
+	const struct mmc_bus_ops *bus_ops;
+
+	if (host->caps & MMC_CAP_NONREMOVABLE)
+		bus_ops = &mmc_sd_ops_unsafe;
+	else
+		bus_ops = &mmc_sd_ops;
+	mmc_attach_bus(host, bus_ops);
+}
+
+#endif
+
 /*
  * Starting point for SD card init.
  */
@@ -626,7 +664,7 @@ int mmc_attach_sd(struct mmc_host *host,
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
-	mmc_attach_bus(host, &mmc_sd_ops);
+	mmc_sd_attach_bus_ops(host);
 
 	/*
 	 * We need to get OCR a different way for SPI.
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mmc/host/omap_hsmmc.c kernel-2.6.28-20093908+0m5/drivers/mmc/host/omap_hsmmc.c
--- kernel-2.6.28-20091602+0m5/drivers/mmc/host/omap_hsmmc.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mmc/host/omap_hsmmc.c	2012-12-16 13:13:01.676330146 +0100
@@ -17,6 +17,8 @@
 
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
 #include <linux/dma-mapping.h>
@@ -25,6 +27,7 @@
 #include <linux/timer.h>
 #include <linux/clk.h>
 #include <linux/mmc/host.h>
+#include <linux/mmc/core.h>
 #include <linux/io.h>
 #include <linux/semaphore.h>
 #include <asm/dma.h>
@@ -35,6 +38,7 @@
 
 /* OMAP HSMMC Host Controller Registers */
 #define OMAP_HSMMC_SYSCONFIG	0x0010
+#define OMAP_HSMMC_SYSSTATUS	0x0014
 #define OMAP_HSMMC_CON		0x002C
 #define OMAP_HSMMC_BLK		0x0104
 #define OMAP_HSMMC_ARG		0x0108
@@ -90,6 +94,8 @@
 #define DUAL_VOLT_OCR_BIT	7
 #define SRC			(1 << 25)
 #define SRD			(1 << 26)
+#define SOFTRESET		(1 << 1)
+#define RESETDONE		(1 << 0)
 
 /*
  * FIXME: Most likely all the data using these _DEVID defines should come
@@ -103,6 +109,11 @@
 #define OMAP_MMC_MASTER_CLOCK	96000000
 #define DRIVER_NAME		"mmci-omap-hs"
 
+/* Timeouts for entering power saving states on inactivity, msec */
+#define OMAP_MMC_DISABLED_TIMEOUT	100
+#define OMAP_MMC_SLEEP_TIMEOUT		1000
+#define OMAP_MMC_OFF_TIMEOUT		8000
+
 /*
  * One controller can have multiple slots, like on some omap boards using
  * omap.c controller driver. Luckily this is not currently done on any known
@@ -119,10 +130,7 @@
 #define OMAP_HSMMC_WRITE(base, reg, val) \
 	__raw_writel((val), (base) + OMAP_HSMMC_##reg)
 
-enum {OFF = 0, ON};
-#define IDLE_TIMEOUT (jiffies_to_msecs(10))
-
-struct mmc_omap_host {
+struct omap_hsmmc_host {
 	struct	device		*dev;
 	struct	mmc_host	*mmc;
 	struct	mmc_request	*mrq;
@@ -139,81 +147,207 @@ struct mmc_omap_host {
 	unsigned int		dma_len;
 	unsigned int		dma_sg_idx;
 	unsigned char		bus_mode;
+	unsigned char		power_mode;
 	u32			*buffer;
 	u32			bytesleft;
 	int			suspended;
 	int			irq;
-	int			carddetect;
 	int			use_dma, dma_ch;
 	int			slot_id;
 	int			dbclk_enabled;
 	int			response_busy;
-
-	struct timer_list       idle_timer;
-	spinlock_t		clk_lock;     /* for changing enabled state */
-	unsigned int		fclk_enabled:1;
+	int			context_loss;
+	int			dpm_state;
+	int			vdd;
+	int			protect_card;
+	int			reqs_blocked;
 
 	struct	omap_mmc_platform_data	*pdata;
 };
 
-static int mmc_omap_fclk_state(struct mmc_omap_host *host, unsigned int state)
+/*
+ * Stop clock to the card
+ */
+static void omap_hsmmc_stop_clock(struct omap_hsmmc_host *host)
 {
-	unsigned long flags;
-	int ret = 0;
+	OMAP_HSMMC_WRITE(host->base, SYSCTL,
+		OMAP_HSMMC_READ(host->base, SYSCTL) & ~CEN);
+	if ((OMAP_HSMMC_READ(host->base, SYSCTL) & CEN) != 0x0)
+		dev_dbg(mmc_dev(host->mmc), "MMC Clock is not stoped\n");
+}
 
-	spin_lock_irqsave(&host->clk_lock, flags);
-	del_timer(&host->idle_timer);
-	if (host->fclk_enabled != state) {
-		if (state == ON) {
-			ret = clk_enable(host->fclk);
-			if (ret != 0)
-				goto err_out;
+#ifdef CONFIG_PM
 
-			dev_dbg(mmc_dev(host->mmc), "mmc_fclk: enabled\n");
-		} else {
-			clk_disable(host->fclk);
-			dev_dbg(mmc_dev(host->mmc), "mmc_fclk: disabled\n");
-		}
-		host->fclk_enabled = state;
+/*
+ * Restore the MMC host context, if it was lost as result of a
+ * power state change.
+ */
+static int omap_hsmmc_context_restore(struct omap_hsmmc_host *host)
+{
+	struct mmc_ios *ios = &host->mmc->ios;
+	struct omap_mmc_platform_data *pdata = host->pdata;
+	int context_loss = 0;
+	u32 hctl, capa, con;
+	u16 dsor = 0;
+	unsigned long timeout;
+
+	if (pdata->get_context_loss_count) {
+		context_loss = pdata->get_context_loss_count(host->dev);
+		if (context_loss < 0)
+			return 1;
 	}
 
-err_out:
-	spin_unlock_irqrestore(&host->clk_lock, flags);
-	return ret;
+	dev_dbg(mmc_dev(host->mmc), "context was %slost\n",
+		context_loss == host->context_loss ? "not " : "");
+	if (host->context_loss == context_loss)
+		return 1;
+
+	/* Wait for hardware reset */
+	timeout = jiffies + msecs_to_jiffies(MMC_TIMEOUT_MS);
+	while ((OMAP_HSMMC_READ(host->base, SYSSTATUS) & RESETDONE) != RESETDONE
+		&& time_before(jiffies, timeout))
+		;
+
+	/* Do software reset */
+	OMAP_HSMMC_WRITE(host->base, SYSCONFIG, SOFTRESET);
+	timeout = jiffies + msecs_to_jiffies(MMC_TIMEOUT_MS);
+	while ((OMAP_HSMMC_READ(host->base, SYSSTATUS) & RESETDONE) != RESETDONE
+		&& time_before(jiffies, timeout))
+		;
+
+	OMAP_HSMMC_WRITE(host->base, SYSCONFIG,
+			OMAP_HSMMC_READ(host->base, SYSCONFIG) | AUTOIDLE);
+
+	if (host->id == OMAP_MMC1_DEVID) {
+		if (host->power_mode != MMC_POWER_OFF &&
+		    (1 << ios->vdd) <= MMC_VDD_23_24)
+			hctl = SDVS18;
+		else
+			hctl = SDVS30;
+		capa = VS30 | VS18;
+	} else {
+		hctl = SDVS18;
+		capa = VS18;
+	}
+
+	OMAP_HSMMC_WRITE(host->base, HCTL,
+			OMAP_HSMMC_READ(host->base, HCTL) | hctl);
+
+	OMAP_HSMMC_WRITE(host->base, CAPA,
+			OMAP_HSMMC_READ(host->base, CAPA) | capa);
+
+	OMAP_HSMMC_WRITE(host->base, HCTL,
+			OMAP_HSMMC_READ(host->base, HCTL) | SDBP);
+
+	timeout = jiffies + msecs_to_jiffies(MMC_TIMEOUT_MS);
+	while ((OMAP_HSMMC_READ(host->base, HCTL) & SDBP) != SDBP
+		&& time_before(jiffies, timeout))
+		;
+
+	OMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);
+	OMAP_HSMMC_WRITE(host->base, ISE, INT_EN_MASK);
+	OMAP_HSMMC_WRITE(host->base, IE, INT_EN_MASK);
+
+	/* Do not initialize card-specific things if the power is off */
+	if (host->power_mode == MMC_POWER_OFF)
+		goto out;
+
+	con = OMAP_HSMMC_READ(host->base, CON);
+	switch (ios->bus_width) {
+	case MMC_BUS_WIDTH_8:
+		OMAP_HSMMC_WRITE(host->base, CON, con | DW8);
+		break;
+	case MMC_BUS_WIDTH_4:
+		OMAP_HSMMC_WRITE(host->base, CON, con & ~DW8);
+		OMAP_HSMMC_WRITE(host->base, HCTL,
+			OMAP_HSMMC_READ(host->base, HCTL) | FOUR_BIT);
+		break;
+	case MMC_BUS_WIDTH_1:
+		OMAP_HSMMC_WRITE(host->base, CON, con & ~DW8);
+		OMAP_HSMMC_WRITE(host->base, HCTL,
+			OMAP_HSMMC_READ(host->base, HCTL) & ~FOUR_BIT);
+		break;
+	}
+
+	if (ios->clock) {
+		dsor = OMAP_MMC_MASTER_CLOCK / ios->clock;
+		if (dsor < 1)
+			dsor = 1;
+
+		if (OMAP_MMC_MASTER_CLOCK / dsor > ios->clock)
+			dsor++;
+
+		if (dsor > 250)
+			dsor = 250;
+	}
+
+	OMAP_HSMMC_WRITE(host->base, SYSCTL,
+		OMAP_HSMMC_READ(host->base, SYSCTL) & ~CEN);
+	OMAP_HSMMC_WRITE(host->base, SYSCTL, (dsor << 6) | (DTO << 16));
+	OMAP_HSMMC_WRITE(host->base, SYSCTL,
+		OMAP_HSMMC_READ(host->base, SYSCTL) | ICE);
+
+	timeout = jiffies + msecs_to_jiffies(MMC_TIMEOUT_MS);
+	while ((OMAP_HSMMC_READ(host->base, SYSCTL) & ICS) != ICS
+		&& time_before(jiffies, timeout))
+		;
+
+	OMAP_HSMMC_WRITE(host->base, SYSCTL,
+		OMAP_HSMMC_READ(host->base, SYSCTL) | CEN);
+
+	con = OMAP_HSMMC_READ(host->base, CON);
+	if (ios->bus_mode == MMC_BUSMODE_OPENDRAIN)
+		OMAP_HSMMC_WRITE(host->base, CON, con | OD);
+	else
+		OMAP_HSMMC_WRITE(host->base, CON, con & ~OD);
+out:
+	host->context_loss = context_loss;
+
+	dev_dbg(mmc_dev(host->mmc), "context is restored\n");
+	return 0;
 }
 
-static void mmc_omap_idle_timer(unsigned long data)
+/*
+ * Save the MMC host context (store the number of power state changes so far).
+ */
+static void omap_hsmmc_context_save(struct omap_hsmmc_host *host)
 {
-	struct mmc_omap_host *host = (struct mmc_omap_host *) data;
+	struct omap_mmc_platform_data *pdata = host->pdata;
+	int context_loss;
 
-	mmc_omap_fclk_state(host, OFF);
+	if (pdata->get_context_loss_count) {
+		context_loss = pdata->get_context_loss_count(host->dev);
+		if (context_loss < 0)
+			return;
+		host->context_loss = context_loss;
+	}
 }
 
-static void mmc_omap_fclk_lazy_disable(struct mmc_omap_host *host)
+#else
+
+static int omap_hsmmc_context_restore(struct omap_hsmmc_host *host)
 {
-	mod_timer(&host->idle_timer, jiffies + IDLE_TIMEOUT);
+	return 0;
 }
 
-/*
- * Stop clock to the card
- */
-static void omap_mmc_stop_clock(struct mmc_omap_host *host)
+static void omap_hsmmc_context_save(struct omap_hsmmc_host *host)
 {
-	OMAP_HSMMC_WRITE(host->base, SYSCTL,
-		OMAP_HSMMC_READ(host->base, SYSCTL) & ~CEN);
-	if ((OMAP_HSMMC_READ(host->base, SYSCTL) & CEN) != 0x0)
-		dev_dbg(mmc_dev(host->mmc), "MMC Clock is not stoped\n");
 }
 
+#endif
+
 /*
  * Send init stream sequence to card
  * before sending IDLE command
  */
-static void send_init_stream(struct mmc_omap_host *host)
+static void send_init_stream(struct omap_hsmmc_host *host)
 {
 	int reg = 0;
 	unsigned long timeout;
 
+	if (host->protect_card)
+		return;
+
 	disable_irq(host->irq);
 	OMAP_HSMMC_WRITE(host->base, CON,
 		OMAP_HSMMC_READ(host->base, CON) | INIT_STREAM);
@@ -225,51 +359,53 @@ static void send_init_stream(struct mmc_
 
 	OMAP_HSMMC_WRITE(host->base, CON,
 		OMAP_HSMMC_READ(host->base, CON) & ~INIT_STREAM);
+
+	OMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);
+	OMAP_HSMMC_READ(host->base, STAT);
+
 	enable_irq(host->irq);
 }
 
 static inline
-int mmc_omap_cover_is_closed(struct mmc_omap_host *host)
+int omap_hsmmc_cover_is_closed(struct omap_hsmmc_host *host)
 {
 	int r = 1;
 
-	if (host->pdata->slots[host->slot_id].get_cover_state)
-		r = host->pdata->slots[host->slot_id].get_cover_state(host->dev,
-			host->slot_id);
+	if (mmc_slot(host).get_cover_state)
+		r = mmc_slot(host).get_cover_state(host->dev, host->slot_id);
 	return r;
 }
 
 static ssize_t
-mmc_omap_show_cover_switch(struct device *dev, struct device_attribute *attr,
+omap_hsmmc_show_cover_switch(struct device *dev, struct device_attribute *attr,
 			   char *buf)
 {
 	struct mmc_host *mmc = container_of(dev, struct mmc_host, class_dev);
-	struct mmc_omap_host *host = mmc_priv(mmc);
+	struct omap_hsmmc_host *host = mmc_priv(mmc);
 
-	return sprintf(buf, "%s\n", mmc_omap_cover_is_closed(host) ? "closed" :
-		       "open");
+	return sprintf(buf, "%s\n",
+			omap_hsmmc_cover_is_closed(host) ? "closed" : "open");
 }
 
-static DEVICE_ATTR(cover_switch, S_IRUGO, mmc_omap_show_cover_switch, NULL);
+static DEVICE_ATTR(cover_switch, S_IRUGO, omap_hsmmc_show_cover_switch, NULL);
 
 static ssize_t
-mmc_omap_show_slot_name(struct device *dev, struct device_attribute *attr,
+omap_hsmmc_show_slot_name(struct device *dev, struct device_attribute *attr,
 			char *buf)
 {
 	struct mmc_host *mmc = container_of(dev, struct mmc_host, class_dev);
-	struct mmc_omap_host *host = mmc_priv(mmc);
-	struct omap_mmc_slot_data slot = host->pdata->slots[host->slot_id];
+	struct omap_hsmmc_host *host = mmc_priv(mmc);
 
-	return sprintf(buf, "%s\n", slot.name);
+	return sprintf(buf, "%s\n", mmc_slot(host).name);
 }
 
-static DEVICE_ATTR(slot_name, S_IRUGO, mmc_omap_show_slot_name, NULL);
+static DEVICE_ATTR(slot_name, S_IRUGO, omap_hsmmc_show_slot_name, NULL);
 
 /*
  * Configure the response type and send the cmd.
  */
 static void
-mmc_omap_start_command(struct mmc_omap_host *host, struct mmc_command *cmd,
+omap_hsmmc_start_command(struct omap_hsmmc_host *host, struct mmc_command *cmd,
 	struct mmc_data *data)
 {
 	int cmdreg = 0, resptype = 0, cmdtype = 0;
@@ -317,12 +453,19 @@ mmc_omap_start_command(struct mmc_omap_h
 	if (host->use_dma)
 		cmdreg |= DMA_EN;
 
+	/*
+	 * In an interrupt context (i.e. STOP command), the interrupt is already
+	 * enabled, otherwise it is not (i.e. new request).
+	 */
+	if (!in_interrupt())
+		enable_irq(host->irq);
+
 	OMAP_HSMMC_WRITE(host->base, ARG, cmd->arg);
 	OMAP_HSMMC_WRITE(host->base, CMD, cmdreg);
 }
 
 static int
-mmc_omap_get_dma_dir(struct mmc_omap_host *host, struct mmc_data *data)
+omap_hsmmc_get_dma_dir(struct omap_hsmmc_host *host, struct mmc_data *data)
 {
 	if (data->flags & MMC_DATA_WRITE)
 		return DMA_TO_DEVICE;
@@ -334,13 +477,19 @@ mmc_omap_get_dma_dir(struct mmc_omap_hos
  * Notify the transfer complete to MMC core
  */
 static void
-mmc_omap_xfer_done(struct mmc_omap_host *host, struct mmc_data *data)
+omap_hsmmc_xfer_done(struct omap_hsmmc_host *host, struct mmc_data *data)
 {
 	if (!data) {
 		struct mmc_request *mrq = host->mrq;
 
+		/* TC before CC from CMD6 - don't know why, but it happens */
+		if (host->cmd && host->cmd->opcode == 6 &&
+		    host->response_busy) {
+			host->response_busy = 0;
+			return;
+		}
+
 		host->mrq = NULL;
-		mmc_omap_fclk_lazy_disable(host);
 		mmc_request_done(host->mmc, mrq);
 		return;
 	}
@@ -349,7 +498,7 @@ mmc_omap_xfer_done(struct mmc_omap_host
 
 	if (host->use_dma && host->dma_ch != -1)
 		dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->dma_len,
-			mmc_omap_get_dma_dir(host, data));
+			omap_hsmmc_get_dma_dir(host, data));
 
 	if (!data->error)
 		data->bytes_xfered += data->blocks * (data->blksz);
@@ -358,18 +507,17 @@ mmc_omap_xfer_done(struct mmc_omap_host
 
 	if (!data->stop) {
 		host->mrq = NULL;
-		mmc_omap_fclk_lazy_disable(host);
 		mmc_request_done(host->mmc, data->mrq);
 		return;
 	}
-	mmc_omap_start_command(host, data->stop, NULL);
+	omap_hsmmc_start_command(host, data->stop, NULL);
 }
 
 /*
  * Notify the core about command completion
  */
 static void
-mmc_omap_cmd_done(struct mmc_omap_host *host, struct mmc_command *cmd)
+omap_hsmmc_cmd_done(struct omap_hsmmc_host *host, struct mmc_command *cmd)
 {
 	host->cmd = NULL;
 
@@ -387,7 +535,6 @@ mmc_omap_cmd_done(struct mmc_omap_host *
 	}
 	if ((host->data == NULL && !host->response_busy) || cmd->error) {
 		host->mrq = NULL;
-		mmc_omap_fclk_lazy_disable(host);
 		mmc_request_done(host->mmc, cmd->mrq);
 	}
 }
@@ -395,13 +542,13 @@ mmc_omap_cmd_done(struct mmc_omap_host *
 /*
  * DMA clean up for command errors
  */
-static void mmc_dma_cleanup(struct mmc_omap_host *host, int errno)
+static void omap_hsmmc_dma_cleanup(struct omap_hsmmc_host *host, int errno)
 {
 	host->data->error = errno;
 
 	if (host->use_dma && host->dma_ch != -1) {
 		dma_unmap_sg(mmc_dev(host->mmc), host->data->sg, host->dma_len,
-			mmc_omap_get_dma_dir(host, host->data));
+			omap_hsmmc_get_dma_dir(host, host->data));
 		omap_free_dma(host->dma_ch);
 		host->dma_ch = -1;
 		up(&host->sem);
@@ -413,10 +560,10 @@ static void mmc_dma_cleanup(struct mmc_o
  * Readable error output
  */
 #ifdef CONFIG_MMC_DEBUG
-static void mmc_omap_report_irq(struct mmc_omap_host *host, u32 status)
+static void omap_hsmmc_report_irq(struct omap_hsmmc_host *host, u32 status)
 {
 	/* --- means reserved bit without definition at documentation */
-	static const char *mmc_omap_status_bits[] = {
+	static const char *omap_hsmmc_status_bits[] = {
 		"CC", "TC", "BGE", "---", "BWR", "BRR", "---", "---", "CIRQ",
 		"OBI", "---", "---", "---", "---", "---", "ERRI", "CTO", "CCRC",
 		"CEB", "CIE", "DTO", "DCRC", "DEB", "---", "ACE", "---",
@@ -429,9 +576,9 @@ static void mmc_omap_report_irq(struct m
 	len = sprintf(buf, "MMC IRQ 0x%x :", status);
 	buf += len;
 
-	for (i = 0; i < ARRAY_SIZE(mmc_omap_status_bits); i++)
+	for (i = 0; i < ARRAY_SIZE(omap_hsmmc_status_bits); i++)
 		if (status & (1 << i)) {
-			len = sprintf(buf, " %s", mmc_omap_status_bits[i]);
+			len = sprintf(buf, " %s", omap_hsmmc_status_bits[i]);
 			buf += len;
 		}
 
@@ -443,9 +590,9 @@ static void mmc_omap_report_irq(struct m
 /*
  * MMC controller IRQ handler
  */
-static irqreturn_t mmc_omap_irq(int irq, void *dev_id)
+static irqreturn_t omap_hsmmc_irq(int irq, void *dev_id)
 {
-	struct mmc_omap_host *host = dev_id;
+	struct omap_hsmmc_host *host = dev_id;
 	struct mmc_data *data;
 	int end_cmd = 0, end_trans = 0, status;
 
@@ -462,7 +609,7 @@ static irqreturn_t mmc_omap_irq(int irq,
 
 	if (status & ERR) {
 #ifdef CONFIG_MMC_DEBUG
-		mmc_omap_report_irq(host, status);
+		omap_hsmmc_report_irq(host, status);
 #endif
 		if ((status & CMD_TIMEOUT) ||
 			(status & CMD_CRC)) {
@@ -483,7 +630,8 @@ static irqreturn_t mmc_omap_irq(int irq,
 			}
 			if (host->data || host->response_busy) {
 				if (host->data)
-					mmc_dma_cleanup(host, -ETIMEDOUT);
+					omap_hsmmc_dma_cleanup(host,
+								-ETIMEDOUT);
 				host->response_busy = 0;
 
 				OMAP_HSMMC_WRITE(host->base, SYSCTL,
@@ -499,7 +647,7 @@ static irqreturn_t mmc_omap_irq(int irq,
 						-ETIMEDOUT : -EILSEQ;
 
 				if (host->data)
-					mmc_dma_cleanup(host, err);
+					omap_hsmmc_dma_cleanup(host, err);
 				else
 					host->mrq->cmd->error = err;
 				host->response_busy = 0;
@@ -527,9 +675,9 @@ static irqreturn_t mmc_omap_irq(int irq,
 	OMAP_HSMMC_READ(host->base, STAT);
 
 	if (end_cmd || ((status & CC) && host->cmd))
-		mmc_omap_cmd_done(host, host->cmd);
-	if (end_trans || (status & TC))
-		mmc_omap_xfer_done(host, data);
+		omap_hsmmc_cmd_done(host, host->cmd);
+	if ((end_trans || (status & TC)) && host->mrq)
+		omap_hsmmc_xfer_done(host, data);
 
 	return IRQ_HANDLED;
 }
@@ -537,29 +685,31 @@ static irqreturn_t mmc_omap_irq(int irq,
 /*
  * Switch MMC operating voltage
  */
-static int omap_mmc_switch_opcond(struct mmc_omap_host *host, int vdd)
+static int omap_hsmmc_switch_opcond(struct omap_hsmmc_host *host, int vdd)
 {
 	u32 reg_val = 0;
 	int ret;
 
 	/* Disable the clocks */
-	mmc_omap_fclk_state(host, OFF);
+	clk_disable(host->fclk);
 	clk_disable(host->iclk);
-	clk_disable(host->dbclk);
+	if (host->dbclk_enabled)
+		clk_disable(host->dbclk);
 
 	/* Turn the power off */
 	ret = mmc_slot(host).set_power(host->dev, host->slot_id, 0, 0);
-	if (ret != 0)
-		goto err;
 
 	/* Turn the power ON with given VDD 1.8 or 3.0v */
-	ret = mmc_slot(host).set_power(host->dev, host->slot_id, 1, vdd);
-	if (ret != 0)
-		goto err;
+	if (!ret)
+		ret = mmc_slot(host).set_power(host->dev, host->slot_id, 1, vdd);
 
-	mmc_omap_fclk_state(host, ON);
 	clk_enable(host->iclk);
-	clk_enable(host->dbclk);
+	if (host->dbclk_enabled)
+		clk_enable(host->dbclk);
+	clk_enable(host->fclk);
+
+	if (ret != 0)
+		goto err;
 
 	OMAP_HSMMC_WRITE(host->base, HCTL,
 		OMAP_HSMMC_READ(host->base, HCTL) & SDVSCLR);
@@ -567,7 +717,7 @@ static int omap_mmc_switch_opcond(struct
 	/*
 	 * If a MMC dual voltage card is detected, the set_ios fn calls
 	 * this fn with VDD bit set for 1.8V. Upon card removal from the
-	 * slot, omap_mmc_set_ios sets the VDD back to 3V on MMC_POWER_OFF.
+	 * slot, omap_hsmmc_set_ios sets the VDD back to 3V on MMC_POWER_OFF.
 	 *
 	 * Only MMC1 supports 3.0V.  MMC2 will not function if SDVS30 is
 	 * set in HCTL.
@@ -591,46 +741,77 @@ err:
 	return ret;
 }
 
+/* Protect the card while the cover is open */
+static void omap_hsmmc_protect_card(struct omap_hsmmc_host *host)
+{
+	if (!mmc_slot(host).get_cover_state)
+		return;
+
+	host->reqs_blocked = 0;
+	if (mmc_slot(host).get_cover_state(host->dev, host->slot_id)) {
+		if (host->protect_card) {
+			printk(KERN_INFO "%s: cover is closed, "
+					 "card is now accessible\n",
+					 mmc_hostname(host->mmc));
+			host->protect_card = 0;
+		}
+	} else {
+		if (!host->protect_card) {
+			printk(KERN_INFO "%s: cover is open, "
+					 "card is now inaccessible\n",
+					 mmc_hostname(host->mmc));
+			host->protect_card = 1;
+		}
+	}
+}
+
 /*
  * Work Item to notify the core about card insertion/removal
  */
-static void mmc_omap_detect(struct work_struct *work)
+static void omap_hsmmc_detect(struct work_struct *work)
 {
-	struct mmc_omap_host *host = container_of(work, struct mmc_omap_host,
-						mmc_carddetect_work);
+	struct omap_hsmmc_host *host =
+		container_of(work, struct omap_hsmmc_host, mmc_carddetect_work);
+	int carddetect;
 
+	if (host->suspended)
+		return;
 	sysfs_notify(&host->mmc->class_dev.kobj, NULL, "cover_switch");
-	mmc_omap_fclk_state(host, ON);
-	if (host->carddetect) {
+	if (mmc_slot(host).card_detect)
+		carddetect = mmc_slot(host).card_detect(mmc_slot(host).card_detect_irq);
+	else {
+		omap_hsmmc_protect_card(host);
+		carddetect = -ENOSYS;
+	}
+	if (carddetect) {
 		mmc_detect_change(host->mmc, (HZ * 200) / 1000);
 	} else {
+		mmc_host_enable(host->mmc);
 		OMAP_HSMMC_WRITE(host->base, SYSCTL,
 			OMAP_HSMMC_READ(host->base, SYSCTL) | SRD);
 		while (OMAP_HSMMC_READ(host->base, SYSCTL) & SRD)
 			;
+		mmc_host_lazy_disable(host->mmc);
 
 		mmc_detect_change(host->mmc, (HZ * 50) / 1000);
 	}
-	mmc_omap_fclk_lazy_disable(host);
 }
 
 /*
  * ISR for handling card insertion and removal
  */
-static irqreturn_t omap_mmc_cd_handler(int irq, void *dev_id)
+static irqreturn_t omap_hsmmc_cd_handler(int irq, void *dev_id)
 {
-	struct mmc_omap_host *host = (struct mmc_omap_host *)dev_id;
+	struct omap_hsmmc_host *host = (struct omap_hsmmc_host *)dev_id;
 
-	if (mmc_slot(host).card_detect)
-		host->carddetect = mmc_slot(host).card_detect(irq);
-	else
-		host->carddetect = -ENOSYS;
+	if (host->suspended)
+		return IRQ_HANDLED;
 	schedule_work(&host->mmc_carddetect_work);
 
 	return IRQ_HANDLED;
 }
 
-static int mmc_omap_get_dma_sync_dev(struct mmc_omap_host *host,
+static int omap_hsmmc_get_dma_sync_dev(struct omap_hsmmc_host *host,
 				     struct mmc_data *data)
 {
 	int sync_dev;
@@ -649,7 +830,7 @@ static int mmc_omap_get_dma_sync_dev(str
 	return sync_dev;
 }
 
-static void mmc_omap_config_dma_params(struct mmc_omap_host *host,
+static void omap_hsmmc_config_dma_params(struct omap_hsmmc_host *host,
 				       struct mmc_data *data,
 				       struct scatterlist *sgl)
 {
@@ -673,7 +854,7 @@ static void mmc_omap_config_dma_params(s
 
 	omap_set_dma_transfer_params(dma_ch, OMAP_DMA_DATA_TYPE_S32,
 			blksz / 4, nblk, OMAP_DMA_SYNC_FRAME,
-			mmc_omap_get_dma_sync_dev(host, data),
+			omap_hsmmc_get_dma_sync_dev(host, data),
 			!(data->flags & MMC_DATA_WRITE));
 
 	omap_start_dma(dma_ch);
@@ -682,9 +863,9 @@ static void mmc_omap_config_dma_params(s
 /*
  * DMA call back function
  */
-static void mmc_omap_dma_cb(int lch, u16 ch_status, void *data)
+static void omap_hsmmc_dma_cb(int lch, u16 ch_status, void *data)
 {
-	struct mmc_omap_host *host = data;
+	struct omap_hsmmc_host *host = data;
 
 	if (ch_status & OMAP2_DMA_MISALIGNED_ERR_IRQ)
 		dev_dbg(mmc_dev(host->mmc), "MISALIGNED_ADRS_ERR\n");
@@ -695,7 +876,7 @@ static void mmc_omap_dma_cb(int lch, u16
 	host->dma_sg_idx++;
 	if (host->dma_sg_idx < host->dma_len) {
 		/* Fire up the next transfer. */
-		mmc_omap_config_dma_params(host, host->data,
+		omap_hsmmc_config_dma_params(host, host->data,
 					   host->data->sg + host->dma_sg_idx);
 		return;
 	}
@@ -712,14 +893,14 @@ static void mmc_omap_dma_cb(int lch, u16
 /*
  * Routine to configure and start DMA for the MMC card
  */
-static int
-mmc_omap_start_dma_transfer(struct mmc_omap_host *host, struct mmc_request *req)
+static int omap_hsmmc_start_dma_transfer(struct omap_hsmmc_host *host,
+					struct mmc_request *req)
 {
 	int dma_ch = 0, ret = 0, err = 1, i;
 	struct mmc_data *data = req->data;
 
 	/* Sanity check: all the SG entries must be aligned by block size. */
-	for (i = 0; i < host->dma_len; i++) {
+	for (i = 0; i < data->sg_len; i++) {
 		struct scatterlist *sgl;
 
 		sgl = data->sg + i;
@@ -750,8 +931,8 @@ mmc_omap_start_dma_transfer(struct mmc_o
 			return err;
 	}
 
-	ret = omap_request_dma(mmc_omap_get_dma_sync_dev(host, data), "MMC/SD",
-			       mmc_omap_dma_cb,host, &dma_ch);
+	ret = omap_request_dma(omap_hsmmc_get_dma_sync_dev(host, data),
+				"MMC/SD", omap_hsmmc_dma_cb, host, &dma_ch);
 	if (ret != 0) {
 		dev_err(mmc_dev(host->mmc),
 			"%s: omap_request_dma() failed with %d\n",
@@ -760,17 +941,18 @@ mmc_omap_start_dma_transfer(struct mmc_o
 	}
 
 	host->dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg,
-			data->sg_len, mmc_omap_get_dma_dir(host, data));
+			data->sg_len, omap_hsmmc_get_dma_dir(host, data));
 	host->dma_ch = dma_ch;
 	host->dma_sg_idx = 0;
 
-	mmc_omap_config_dma_params(host, data, data->sg);
+	omap_hsmmc_config_dma_params(host, data, data->sg);
 
 	return 0;
 }
 
-static void set_data_timeout(struct mmc_omap_host *host,
-			     struct mmc_request *req)
+static void set_data_timeout(struct omap_hsmmc_host *host,
+			     unsigned int timeout_ns,
+			     unsigned int timeout_clks)
 {
 	unsigned int timeout, cycle_ns;
 	uint32_t reg, clkd, dto = 0;
@@ -781,8 +963,8 @@ static void set_data_timeout(struct mmc_
 		clkd = 1;
 
 	cycle_ns = 1000000000 / (clk_get_rate(host->fclk) / clkd);
-	timeout = req->data->timeout_ns / cycle_ns;
-	timeout += req->data->timeout_clks;
+	timeout = timeout_ns / cycle_ns;
+	timeout += timeout_clks;
 	if (timeout) {
 		while ((timeout & 0x80000000) == 0) {
 			dto += 1;
@@ -809,22 +991,28 @@ static void set_data_timeout(struct mmc_
  * Configure block length for MMC/SD cards and initiate the transfer.
  */
 static int
-mmc_omap_prepare_data(struct mmc_omap_host *host, struct mmc_request *req)
+omap_hsmmc_prepare_data(struct omap_hsmmc_host *host, struct mmc_request *req)
 {
 	int ret;
 	host->data = req->data;
 
 	if (req->data == NULL) {
 		OMAP_HSMMC_WRITE(host->base, BLK, 0);
+		/*
+		 * Set an arbitrary 100ms data timeout for commands with
+		 * busy signal.
+		 */
+		if (req->cmd->flags & MMC_RSP_BUSY)
+			set_data_timeout(host, 100000000U, 0);
 		return 0;
 	}
 
 	OMAP_HSMMC_WRITE(host->base, BLK, (req->data->blksz)
 					| (req->data->blocks << 16));
-	set_data_timeout(host, req);
+	set_data_timeout(host, req->data->timeout_ns, req->data->timeout_clks);
 
 	if (host->use_dma) {
-		ret = mmc_omap_start_dma_transfer(host, req);
+		ret = omap_hsmmc_start_dma_transfer(host, req);
 		if (ret != 0) {
 			dev_dbg(mmc_dev(host->mmc), "MMC start dma failure\n");
 			return ret;
@@ -836,37 +1024,99 @@ mmc_omap_prepare_data(struct mmc_omap_ho
 /*
  * Request function. for read/write operation
  */
-static void omap_mmc_request(struct mmc_host *mmc, struct mmc_request *req)
+static void omap_hsmmc_request(struct mmc_host *mmc, struct mmc_request *req)
 {
-	struct mmc_omap_host *host = mmc_priv(mmc);
+	struct omap_hsmmc_host *host = mmc_priv(mmc);
+	int err;
 
+	/*
+	 * Prevent races with the interrupt handler because of unexpected
+	 * interrupts, but not if we are already in interrupt context i.e.
+	 * retries.
+	 */
+	if (!in_interrupt()) {
+		disable_irq(host->irq);
+		/*
+		 * Protect the card from I/O if there is a possibility
+		 * it can be removed.
+		 */
+		if (host->protect_card) {
+			if (host->reqs_blocked < 3) {
+				u32 reg;
+
+				/*
+				 * Ensure the controller is left in a consistent state by resetting the
+				 * command and data state machines.
+				 */
+				reg = OMAP_HSMMC_READ(host->base, SYSCTL);
+				OMAP_HSMMC_WRITE(host->base, SYSCTL, reg | SRD);
+                                while (OMAP_HSMMC_READ(host->base, SYSCTL) & SRD)
+					;
+				reg = OMAP_HSMMC_READ(host->base, SYSCTL);
+				OMAP_HSMMC_WRITE(host->base, SYSCTL, reg | SRC);
+				while (OMAP_HSMMC_READ(host->base, SYSCTL) & SRC)
+					;
+				host->reqs_blocked += 1;
+			}
+			req->cmd->error = -EBADF;
+			if (req->data)
+				req->data->error = -EBADF;
+			enable_irq(host->irq);
+			mmc_request_done(mmc, req);
+			return;
+		} else if (host->reqs_blocked)
+			host->reqs_blocked = 0;
+	}
 	WARN_ON(host->mrq != NULL);
 	host->mrq = req;
-	mmc_omap_fclk_state(host, ON);
-	mmc_omap_prepare_data(host, req);
-	mmc_omap_start_command(host, req->cmd, req->data);
+	err = omap_hsmmc_prepare_data(host, req);
+	if (err) {
+		req->cmd->error = err;
+		if (req->data)
+			req->data->error = err;
+		host->mrq = NULL;
+		if (!in_interrupt())
+			enable_irq(host->irq);
+		mmc_request_done(mmc, req);
+		return;
+	}
+
+	omap_hsmmc_start_command(host, req->cmd, req->data);
 }
 
 /* Routine to configure clock values. Exposed API to core */
-static void omap_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+static void omap_hsmmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 {
-	struct mmc_omap_host *host = mmc_priv(mmc);
+	struct omap_hsmmc_host *host = mmc_priv(mmc);
 	u16 dsor = 0;
 	unsigned long regval;
 	unsigned long timeout;
 	u32 con;
+	int do_send_init_stream = 0;
 
-	mmc_omap_fclk_state(host, ON);
+	mmc_host_enable(host->mmc);
 
-	switch (ios->power_mode) {
-	case MMC_POWER_OFF:
-		mmc_slot(host).set_power(host->dev, host->slot_id, 0, 0);
-		break;
-	case MMC_POWER_UP:
-		mmc_slot(host).set_power(host->dev, host->slot_id, 1, ios->vdd);
-		break;
+	if (ios->power_mode != host->power_mode) {
+		switch (ios->power_mode) {
+		case MMC_POWER_OFF:
+			mmc_slot(host).set_power(host->dev, host->slot_id,
+						 0, 0);
+			host->vdd = 0;
+			break;
+		case MMC_POWER_UP:
+			mmc_slot(host).set_power(host->dev, host->slot_id,
+						 1, ios->vdd);
+			host->vdd = ios->vdd;
+			break;
+		case MMC_POWER_ON:
+			do_send_init_stream = 1;
+			break;
+		}
+		host->power_mode = ios->power_mode;
 	}
 
+	/* FIXME: set registers based only on changes to ios */
+
 	con = OMAP_HSMMC_READ(host->base, CON);
 	switch (mmc->ios.bus_width) {
 	case MMC_BUS_WIDTH_8:
@@ -894,8 +1144,8 @@ static void omap_mmc_set_ios(struct mmc_
 				 * MMC_POWER_UP upon recalculating the voltage.
 				 * vdd 1.8v.
 				 */
-				if (omap_mmc_switch_opcond(host, ios->vdd) != 0)
-					dev_dbg(mmc_dev(host->mmc),
+			if (omap_hsmmc_switch_opcond(host, ios->vdd) != 0)
+				dev_dbg(mmc_dev(host->mmc),
 						"Switch operation failed\n");
 		}
 	}
@@ -911,7 +1161,7 @@ static void omap_mmc_set_ios(struct mmc_
 		if (dsor > 250)
 			dsor = 250;
 	}
-	omap_mmc_stop_clock(host);
+	omap_hsmmc_stop_clock(host);
 	regval = OMAP_HSMMC_READ(host->base, SYSCTL);
 	regval = regval & ~(CLKD_MASK);
 	regval = regval | (dsor << 6) | (DTO << 16);
@@ -921,52 +1171,47 @@ static void omap_mmc_set_ios(struct mmc_
 
 	/* Wait till the ICS bit is set */
 	timeout = jiffies + msecs_to_jiffies(MMC_TIMEOUT_MS);
-	while ((OMAP_HSMMC_READ(host->base, SYSCTL) & ICS) != 0x2
+	while ((OMAP_HSMMC_READ(host->base, SYSCTL) & ICS) != ICS
 		&& time_before(jiffies, timeout))
 		msleep(1);
 
 	OMAP_HSMMC_WRITE(host->base, SYSCTL,
 		OMAP_HSMMC_READ(host->base, SYSCTL) | CEN);
 
-	if (ios->power_mode == MMC_POWER_ON)
+	if (do_send_init_stream)
 		send_init_stream(host);
 
+	con = OMAP_HSMMC_READ(host->base, CON);
 	if (ios->bus_mode == MMC_BUSMODE_OPENDRAIN)
-		OMAP_HSMMC_WRITE(host->base, CON,
-				OMAP_HSMMC_READ(host->base, CON) | OD);
+		OMAP_HSMMC_WRITE(host->base, CON, con | OD);
+	else
+		OMAP_HSMMC_WRITE(host->base, CON, con & ~OD);
 
-	mmc_omap_fclk_lazy_disable(host);
+	if (host->power_mode == MMC_POWER_OFF)
+		mmc_host_disable(host->mmc);
+	else
+		mmc_host_lazy_disable(host->mmc);
 }
 
 static int omap_hsmmc_get_cd(struct mmc_host *mmc)
 {
-	struct mmc_omap_host *host = mmc_priv(mmc);
-	struct omap_mmc_platform_data *pdata = host->pdata;
+	struct omap_hsmmc_host *host = mmc_priv(mmc);
 
-	if (!pdata->slots[0].card_detect)
+	if (!mmc_slot(host).card_detect)
 		return -ENOSYS;
-	return pdata->slots[0].card_detect(pdata->slots[0].card_detect_irq);
+	return mmc_slot(host).card_detect(mmc_slot(host).card_detect_irq);
 }
 
 static int omap_hsmmc_get_ro(struct mmc_host *mmc)
 {
-	struct mmc_omap_host *host = mmc_priv(mmc);
-	struct omap_mmc_platform_data *pdata = host->pdata;
+	struct omap_hsmmc_host *host = mmc_priv(mmc);
 
-	if (!pdata->slots[0].get_ro)
+	if (!mmc_slot(host).get_ro)
 		return -ENOSYS;
-	return pdata->slots[0].get_ro(host->dev, 0);
+	return mmc_slot(host).get_ro(host->dev, 0);
 }
 
-static struct mmc_host_ops mmc_omap_ops = {
-	.request = omap_mmc_request,
-	.set_ios = omap_mmc_set_ios,
-	.get_cd = omap_hsmmc_get_cd,
-	.get_ro = omap_hsmmc_get_ro,
-	/* NYET -- enable_sdio_irq */
-};
-
-static void omap_mmc_conf_bus_power(struct mmc_omap_host *host)
+static void omap_hsmmc_conf_bus_power(struct omap_hsmmc_host *host)
 {
 	int i;
 	u32 hctl, capa;
@@ -986,6 +1231,10 @@ static void omap_mmc_conf_bus_power(stru
 	OMAP_HSMMC_WRITE(host->base, CAPA,
 			OMAP_HSMMC_READ(host->base, CAPA) | capa);
 
+	/* Set the controller to AUTO IDLE mode */
+	OMAP_HSMMC_WRITE(host->base, SYSCONFIG,
+			OMAP_HSMMC_READ(host->base, SYSCONFIG) | AUTOIDLE);
+
 	/* Set SD bus power bit */
 	OMAP_HSMMC_WRITE(host->base, HCTL,
 			OMAP_HSMMC_READ(host->base, HCTL) | SDBP);
@@ -995,11 +1244,359 @@ static void omap_mmc_conf_bus_power(stru
 			break;
 }
 
-static int __init omap_mmc_probe(struct platform_device *pdev)
+/*
+ * Dynamic power saving handling, FSM:
+ *   ENABLED -> DISABLED -> CARDSLEEP / REGSLEEP -> OFF
+ *     ^___________|          |                      |
+ *     |______________________|______________________|
+ *
+ * ENABLED:   mmc host is fully functional
+ * DISABLED:  fclk is off
+ * CARDSLEEP: fclk is off, card is asleep, voltage regulator is asleep
+ * REGSLEEP:  fclk is off, voltage regulator is asleep
+ * OFF:       fclk is off, voltage regulator is off
+ *
+ * Transition handlers return the timeout for the next state transition
+ * or negative error.
+ */
+
+enum {ENABLED = 0, DISABLED, CARDSLEEP, REGSLEEP, OFF};
+
+/* Handler for [ENABLED -> DISABLED] transition */
+static int omap_hsmmc_enabled_to_disabled(struct omap_hsmmc_host *host)
+{
+	omap_hsmmc_context_save(host);
+
+	clk_disable(host->fclk);
+
+	/* drop PM/DVFS constraints */
+	if (host->pdata->set_pm_constraints)
+		host->pdata->set_pm_constraints(host->dev, 0);
+
+	host->dpm_state = DISABLED;
+
+	dev_dbg(mmc_dev(host->mmc), "ENABLED -> DISABLED\n");
+
+	if (host->power_mode == MMC_POWER_OFF)
+		return 0;
+
+	return msecs_to_jiffies(OMAP_MMC_SLEEP_TIMEOUT);
+}
+
+/* Handler for [DISABLED -> REGSLEEP / CARDSLEEP] transition */
+static int omap_hsmmc_disabled_to_sleep(struct omap_hsmmc_host *host)
+{
+	int err, new_state;
+
+	if (!mmc_try_claim_host(host->mmc))
+		return 0;
+
+	clk_enable(host->fclk);
+	omap_hsmmc_context_restore(host);
+	if (mmc_card_can_sleep(host->mmc)) {
+		err = mmc_card_sleep(host->mmc);
+		if (err < 0) {
+			clk_disable(host->fclk);
+			mmc_release_host(host->mmc);
+			return err;
+		}
+		new_state = CARDSLEEP;
+	} else {
+		new_state = REGSLEEP;
+	}
+	if (mmc_slot(host).set_sleep)
+		mmc_slot(host).set_sleep(host->dev, host->slot_id, 1, 0,
+					 new_state == CARDSLEEP);
+	/* FIXME: turn off bus power and perhaps interrupts too */
+	clk_disable(host->fclk);
+	host->dpm_state = new_state;
+
+	mmc_release_host(host->mmc);
+
+	dev_dbg(mmc_dev(host->mmc), "DISABLED -> %s\n",
+		host->dpm_state == CARDSLEEP ? "CARDSLEEP" : "REGSLEEP");
+
+	if ((host->mmc->caps & MMC_CAP_NONREMOVABLE) ||
+	    mmc_slot(host).card_detect ||
+	    (mmc_slot(host).get_cover_state &&
+	     mmc_slot(host).get_cover_state(host->dev, host->slot_id)))
+		return msecs_to_jiffies(OMAP_MMC_OFF_TIMEOUT);
+
+	return 0;
+}
+
+/* Handler for [REGSLEEP / CARDSLEEP -> OFF] transition */
+static int omap_hsmmc_sleep_to_off(struct omap_hsmmc_host *host)
+{
+	if (!mmc_try_claim_host(host->mmc))
+		return 0;
+
+	if (!((host->mmc->caps & MMC_CAP_NONREMOVABLE) ||
+	      mmc_slot(host).card_detect ||
+	      (mmc_slot(host).get_cover_state &&
+	       mmc_slot(host).get_cover_state(host->dev, host->slot_id)))) {
+		mmc_release_host(host->mmc);
+		return 0;
+	}
+
+	mmc_slot(host).set_power(host->dev, host->slot_id, 0, 0);
+	host->vdd = 0;
+	host->power_mode = MMC_POWER_OFF;
+
+	dev_dbg(mmc_dev(host->mmc), "%s -> OFF\n",
+		host->dpm_state == CARDSLEEP ? "CARDSLEEP" : "REGSLEEP");
+
+	host->dpm_state = OFF;
+
+	mmc_release_host(host->mmc);
+
+	return 0;
+}
+
+/* Handler for [DISABLED -> ENABLED] transition */
+static int omap_hsmmc_disabled_to_enabled(struct omap_hsmmc_host *host)
+{
+	int err;
+
+	err = clk_enable(host->fclk);
+	if (err < 0)
+		return err;
+
+	omap_hsmmc_context_restore(host);
+
+	if (host->pdata->set_pm_constraints)
+		host->pdata->set_pm_constraints(host->dev, 1);
+
+	host->dpm_state = ENABLED;
+
+	dev_dbg(mmc_dev(host->mmc), "DISABLED -> ENABLED\n");
+
+	return 0;
+}
+
+static int omap_hsmmc_sleep_to_enabled(struct omap_hsmmc_host *host)
+{
+	if (!mmc_try_claim_host(host->mmc))
+		return 0;
+
+	clk_enable(host->fclk);
+	omap_hsmmc_context_restore(host);
+	if (mmc_slot(host).set_sleep)
+		mmc_slot(host).set_sleep(host->dev, host->slot_id, 0,
+			 host->vdd, host->dpm_state == CARDSLEEP);
+	if (mmc_card_can_sleep(host->mmc))
+		mmc_card_awake(host->mmc);
+
+	dev_dbg(mmc_dev(host->mmc), "%s -> ENABLED\n",
+		host->dpm_state == CARDSLEEP ? "CARDSLEEP" : "REGSLEEP");
+
+	if (host->pdata->set_pm_constraints)
+		host->pdata->set_pm_constraints(host->dev, 1);
+
+	host->dpm_state = ENABLED;
+
+	mmc_release_host(host->mmc);
+
+	return 0;
+}
+
+
+/* Handler for [OFF -> ENABLED] transition */
+static int omap_hsmmc_off_to_enabled(struct omap_hsmmc_host *host)
+{
+	clk_enable(host->fclk);
+
+	omap_hsmmc_context_restore(host);
+	omap_hsmmc_conf_bus_power(host);
+	mmc_power_restore_host(host->mmc);
+
+	if (host->pdata->set_pm_constraints)
+		host->pdata->set_pm_constraints(host->dev, 1);
+
+	host->dpm_state = ENABLED;
+
+	dev_dbg(mmc_dev(host->mmc), "OFF -> ENABLED\n");
+
+	return 0;
+}
+
+/*
+ * Bring MMC host to ENABLED from any other PM state.
+ */
+static int omap_hsmmc_enable(struct mmc_host *mmc)
+{
+	struct omap_hsmmc_host *host = mmc_priv(mmc);
+
+	switch (host->dpm_state) {
+	case DISABLED:
+		return omap_hsmmc_disabled_to_enabled(host);
+	case CARDSLEEP:
+	case REGSLEEP:
+		return omap_hsmmc_sleep_to_enabled(host);
+	case OFF:
+		return omap_hsmmc_off_to_enabled(host);
+	default:
+		dev_dbg(mmc_dev(host->mmc), "UNKNOWN state\n");
+		return -EINVAL;
+	}
+
+}
+
+/*
+ * Bring MMC host in PM state (one level deeper).
+ */
+static int omap_hsmmc_disable(struct mmc_host *mmc, int lazy)
+{
+	struct omap_hsmmc_host *host = mmc_priv(mmc);
+
+	switch (host->dpm_state) {
+	case ENABLED: {
+		int delay;
+
+		delay = omap_hsmmc_enabled_to_disabled(host);
+		if (lazy || delay < 0)
+			return delay;
+		return 0;
+	}
+	case DISABLED:
+		return omap_hsmmc_disabled_to_sleep(host);
+	case CARDSLEEP:
+	case REGSLEEP:
+		return omap_hsmmc_sleep_to_off(host);
+	default:
+		dev_dbg(mmc_dev(host->mmc), "UNKNOWN state\n");
+		return -EINVAL;
+	}
+}
+
+static int omap_hsmmc_enable_fclk(struct mmc_host *mmc)
+{
+	struct omap_hsmmc_host *host = mmc_priv(mmc);
+	int err;
+
+	err = clk_enable(host->fclk);
+	if (err)
+		return err;
+	dev_dbg(mmc_dev(host->mmc), "mmc_fclk: enabled\n");
+	omap_hsmmc_context_restore(host);
+	return 0;
+}
+
+static int omap_hsmmc_disable_fclk(struct mmc_host *mmc, int lazy)
+{
+	struct omap_hsmmc_host *host = mmc_priv(mmc);
+
+	omap_hsmmc_context_save(host);
+	clk_disable(host->fclk);
+	dev_dbg(mmc_dev(host->mmc), "mmc_fclk: disabled\n");
+	return 0;
+}
+
+static const struct mmc_host_ops omap_hsmmc_ops = {
+	.enable = omap_hsmmc_enable_fclk,
+	.disable = omap_hsmmc_disable_fclk,
+	.request = omap_hsmmc_request,
+	.set_ios = omap_hsmmc_set_ios,
+	.get_cd = omap_hsmmc_get_cd,
+	.get_ro = omap_hsmmc_get_ro,
+	/* NYET -- enable_sdio_irq */
+};
+
+static const struct mmc_host_ops omap_hsmmc_ps_ops = {
+	.enable = omap_hsmmc_enable,
+	.disable = omap_hsmmc_disable,
+	.request = omap_hsmmc_request,
+	.set_ios = omap_hsmmc_set_ios,
+	.get_cd = omap_hsmmc_get_cd,
+	.get_ro = omap_hsmmc_get_ro,
+	/* NYET -- enable_sdio_irq */
+};
+
+#ifdef CONFIG_DEBUG_FS
+
+static int omap_hsmmc_regs_show(struct seq_file *s, void *data)
+{
+	struct mmc_host *mmc = s->private;
+	struct omap_hsmmc_host *host = mmc_priv(mmc);
+	int context_loss = 0;
+
+#ifdef CONFIG_PM
+	if (host->pdata->get_context_loss_count)
+		context_loss = host->pdata->get_context_loss_count(host->dev);
+#endif
+
+	seq_printf(s, "mmc%d:\n"
+			" enabled:\t%d\n"
+			" dpm_state:\t%d\n"
+			" nesting_cnt:\t%d\n"
+			" ctx_loss:\t%d:%d\n"
+			"\nregs:\n",
+			mmc->index, mmc->enabled ? 1 : 0,
+			host->dpm_state, mmc->nesting_cnt,
+			host->context_loss, context_loss);
+
+	if (host->suspended || host->dpm_state == OFF) {
+		seq_printf(s, "host suspended, can't read registers\n");
+		return 0;
+	}
+
+	if (clk_enable(host->fclk) != 0) {
+		seq_printf(s, "can't read the regs\n");
+		return 0;
+	}
+
+	seq_printf(s, "SYSCONFIG:\t0x%08x\n",
+			OMAP_HSMMC_READ(host->base, SYSCONFIG));
+	seq_printf(s, "CON:\t\t0x%08x\n",
+			OMAP_HSMMC_READ(host->base, CON));
+	seq_printf(s, "HCTL:\t\t0x%08x\n",
+			OMAP_HSMMC_READ(host->base, HCTL));
+	seq_printf(s, "SYSCTL:\t\t0x%08x\n",
+			OMAP_HSMMC_READ(host->base, SYSCTL));
+	seq_printf(s, "IE:\t\t0x%08x\n",
+			OMAP_HSMMC_READ(host->base, IE));
+	seq_printf(s, "ISE:\t\t0x%08x\n",
+			OMAP_HSMMC_READ(host->base, ISE));
+	seq_printf(s, "CAPA:\t\t0x%08x\n",
+			OMAP_HSMMC_READ(host->base, CAPA));
+
+	clk_disable(host->fclk);
+
+	return 0;
+}
+
+static int omap_hsmmc_regs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, omap_hsmmc_regs_show, inode->i_private);
+}
+
+static const struct file_operations mmc_regs_fops = {
+	.open           = omap_hsmmc_regs_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+static void omap_hsmmc_debugfs(struct mmc_host *mmc)
+{
+	if (mmc->debugfs_root)
+		debugfs_create_file("regs", S_IRUSR, mmc->debugfs_root,
+			mmc, &mmc_regs_fops);
+}
+
+#else
+
+static void omap_hsmmc_debugfs(struct mmc_host *mmc)
+{
+}
+
+#endif
+
+static int __init omap_hsmmc_probe(struct platform_device *pdev)
 {
 	struct omap_mmc_platform_data *pdata = pdev->dev.platform_data;
 	struct mmc_host *mmc;
-	struct mmc_omap_host *host = NULL;
+	struct omap_hsmmc_host *host = NULL;
 	struct resource *res;
 	int ret = 0, irq;
 
@@ -1023,7 +1620,7 @@ static int __init omap_mmc_probe(struct
 	if (res == NULL)
 		return -EBUSY;
 
-	mmc = mmc_alloc_host(sizeof(struct mmc_omap_host), &pdev->dev);
+	mmc = mmc_alloc_host(sizeof(struct omap_hsmmc_host), &pdev->dev);
 	if (!mmc) {
 		ret = -ENOMEM;
 		goto err;
@@ -1041,11 +1638,16 @@ static int __init omap_mmc_probe(struct
 	host->slot_id	= 0;
 	host->mapbase	= res->start;
 	host->base	= ioremap(host->mapbase, SZ_4K);
+	host->power_mode = -1;
 
 	platform_set_drvdata(pdev, host);
-	INIT_WORK(&host->mmc_carddetect_work, mmc_omap_detect);
+	INIT_WORK(&host->mmc_carddetect_work, omap_hsmmc_detect);
+
+	if (mmc_slot(host).power_saving)
+		mmc->ops	= &omap_hsmmc_ps_ops;
+	else
+		mmc->ops	= &omap_hsmmc_ops;
 
-	mmc->ops	= &mmc_omap_ops;
 	mmc->f_min	= 400000;
 	mmc->f_max	= 52000000;
 
@@ -1065,17 +1667,20 @@ static int __init omap_mmc_probe(struct
 		goto err1;
 	}
 
-	spin_lock_init(&host->clk_lock);
-	setup_timer(&host->idle_timer, mmc_omap_idle_timer,
-		    (unsigned long) host);
+	omap_hsmmc_context_save(host);
 
-	if (mmc_omap_fclk_state(host, ON) != 0) {
+	mmc->caps |= MMC_CAP_DISABLE;
+	mmc_set_disable_delay(mmc, OMAP_MMC_DISABLED_TIMEOUT);
+	/* we start off in DISABLED state */
+	host->dpm_state = DISABLED;
+
+	if (mmc_host_enable(host->mmc) != 0) {
 		clk_put(host->iclk);
 		clk_put(host->fclk);
 		goto err1;
 	}
 	if (clk_enable(host->iclk) != 0) {
-		mmc_omap_fclk_state(host, OFF);
+		mmc_host_disable(host->mmc);
 		clk_put(host->iclk);
 		clk_put(host->fclk);
 		goto err1;
@@ -1107,18 +1712,17 @@ static int __init omap_mmc_probe(struct
 	mmc->ocr_avail = mmc_slot(host).ocr_mask;
 	mmc->caps |= MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED;
 
-	if (pdata->slots[host->slot_id].wires >= 8)
+	if (mmc_slot(host).wires >= 8)
 		mmc->caps |= MMC_CAP_8_BIT_DATA;
-	else if (pdata->slots[host->slot_id].wires >= 4)
+	else if (mmc_slot(host).wires >= 4)
 		mmc->caps |= MMC_CAP_4_BIT_DATA;
 
-	/* Set the controller to AUTO IDLE mode */
-	OMAP_HSMMC_WRITE(host->base, SYSCONFIG,
-			OMAP_HSMMC_READ(host->base, SYSCONFIG) | AUTOIDLE);
-	omap_mmc_conf_bus_power(host);
+	mmc->caps |= mmc_slot(host).caps;
+
+	omap_hsmmc_conf_bus_power(host);
 
 	/* Request IRQ for MMC operations */
-	ret = request_irq(host->irq, mmc_omap_irq, IRQF_DISABLED,
+	ret = request_irq(host->irq, omap_hsmmc_irq, IRQF_DISABLED,
 			mmc_hostname(mmc), host);
 	if (ret) {
 		dev_dbg(mmc_dev(host->mmc), "Unable to grab HSMMC IRQ\n");
@@ -1136,7 +1740,7 @@ static int __init omap_mmc_probe(struct
 	/* Request IRQ for card detect */
 	if ((mmc_slot(host).card_detect_irq)) {
 		ret = request_irq(mmc_slot(host).card_detect_irq,
-				  omap_mmc_cd_handler,
+				  omap_hsmmc_cd_handler,
 				  IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING
 					  | IRQF_DISABLED,
 				  mmc_hostname(mmc), host);
@@ -1150,21 +1754,25 @@ static int __init omap_mmc_probe(struct
 	OMAP_HSMMC_WRITE(host->base, ISE, INT_EN_MASK);
 	OMAP_HSMMC_WRITE(host->base, IE, INT_EN_MASK);
 
+	mmc_host_lazy_disable(host->mmc);
+
+	omap_hsmmc_protect_card(host);
+
 	mmc_add_host(mmc);
 
-	if (host->pdata->slots[host->slot_id].name != NULL) {
+	if (mmc_slot(host).name != NULL) {
 		ret = device_create_file(&mmc->class_dev, &dev_attr_slot_name);
 		if (ret < 0)
 			goto err_slot_name;
 	}
-	if (mmc_slot(host).card_detect_irq &&
-	    host->pdata->slots[host->slot_id].get_cover_state) {
+	if (mmc_slot(host).card_detect_irq && mmc_slot(host).get_cover_state) {
 		ret = device_create_file(&mmc->class_dev,
 					&dev_attr_cover_switch);
 		if (ret < 0)
 			goto err_cover_switch;
 	}
-	mmc_omap_fclk_lazy_disable(host);
+
+	omap_hsmmc_debugfs(mmc);
 
 	return 0;
 
@@ -1177,7 +1785,7 @@ err_irq_cd:
 err_irq_cd_init:
 	free_irq(host->irq, host);
 err_irq:
-	mmc_omap_fclk_state(host, OFF);
+	mmc_host_disable(host->mmc);
 	clk_disable(host->iclk);
 	clk_put(host->fclk);
 	clk_put(host->iclk);
@@ -1196,12 +1804,13 @@ err:
 	return ret;
 }
 
-static int omap_mmc_remove(struct platform_device *pdev)
+static int omap_hsmmc_remove(struct platform_device *pdev)
 {
-	struct mmc_omap_host *host = platform_get_drvdata(pdev);
+	struct omap_hsmmc_host *host = platform_get_drvdata(pdev);
 	struct resource *res;
 
 	if (host) {
+		mmc_host_enable(host->mmc);
 		mmc_remove_host(host->mmc);
 		if (host->pdata->cleanup)
 			host->pdata->cleanup(&pdev->dev);
@@ -1209,8 +1818,7 @@ static int omap_mmc_remove(struct platfo
 		if (mmc_slot(host).card_detect_irq)
 			free_irq(mmc_slot(host).card_detect_irq, host);
 		flush_scheduled_work();
-
-		mmc_omap_fclk_state(host, OFF);
+		mmc_host_disable(host->mmc);
 		clk_disable(host->iclk);
 		clk_put(host->fclk);
 		clk_put(host->iclk);
@@ -1232,37 +1840,51 @@ static int omap_mmc_remove(struct platfo
 }
 
 #ifdef CONFIG_PM
-static int omap_mmc_suspend(struct platform_device *pdev, pm_message_t state)
+static int omap_hsmmc_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	int ret = 0;
-	struct mmc_omap_host *host = platform_get_drvdata(pdev);
+	struct omap_hsmmc_host *host = platform_get_drvdata(pdev);
 
 	if (host && host->suspended)
 		return 0;
 
 	if (host) {
+		host->suspended = 1;
+		if (host->pdata->suspend) {
+			ret = host->pdata->suspend(&pdev->dev,
+							host->slot_id);
+			if (ret) {
+				dev_dbg(mmc_dev(host->mmc),
+					"Unable to handle MMC board"
+					" level suspend\n");
+				host->suspended = 0;
+				return ret;
+			}
+		}
+		cancel_work_sync(&host->mmc_carddetect_work);
+		mmc_host_enable(host->mmc);
 		ret = mmc_suspend_host(host->mmc, state);
 		if (ret == 0) {
-			host->suspended = 1;
-
-			mmc_omap_fclk_state(host, ON);
 			OMAP_HSMMC_WRITE(host->base, ISE, 0);
 			OMAP_HSMMC_WRITE(host->base, IE, 0);
 
-			if (host->pdata->suspend) {
-				ret = host->pdata->suspend(&pdev->dev,
-								host->slot_id);
-				if (ret)
-					dev_dbg(mmc_dev(host->mmc),
-						"Unable to handle MMC board"
-						" level suspend\n");
-			}
 
 			OMAP_HSMMC_WRITE(host->base, HCTL,
-					 OMAP_HSMMC_READ(host->base, HCTL) & ~SDBP);
-			mmc_omap_fclk_state(host, OFF);
+				 OMAP_HSMMC_READ(host->base, HCTL) & ~SDBP);
+			mmc_host_disable(host->mmc);
 			clk_disable(host->iclk);
-			clk_disable(host->dbclk);
+			if (host->dbclk_enabled)
+				clk_disable(host->dbclk);
+		} else {
+			host->suspended = 0;
+			if (host->pdata->resume) {
+				ret = host->pdata->resume(&pdev->dev,
+							host->slot_id);
+				if (ret)
+					dev_dbg(mmc_dev(host->mmc),
+						"Unmask interrupt failed\n");
+			}
+			mmc_host_disable(host->mmc);
 		}
 
 	}
@@ -1270,30 +1892,28 @@ static int omap_mmc_suspend(struct platf
 }
 
 /* Routine to resume the MMC device */
-static int omap_mmc_resume(struct platform_device *pdev)
+static int omap_hsmmc_resume(struct platform_device *pdev)
 {
 	int ret = 0;
-	struct mmc_omap_host *host = platform_get_drvdata(pdev);
+	struct omap_hsmmc_host *host = platform_get_drvdata(pdev);
 
 	if (host && !host->suspended)
 		return 0;
 
 	if (host) {
-		if (mmc_omap_fclk_state(host, ON) != 0)
+		ret = clk_enable(host->iclk);
+		if (ret)
 			goto clk_en_err;
 
-		ret = clk_enable(host->iclk);
-		if (ret) {
-			mmc_omap_fclk_state(host, OFF);
-			clk_put(host->fclk);
+		if (host->dbclk_enabled)
+			clk_enable(host->dbclk);
+
+		if (mmc_host_enable(host->mmc) != 0) {
+			clk_disable(host->iclk);
 			goto clk_en_err;
 		}
 
-		if (clk_enable(host->dbclk) != 0)
-			dev_dbg(mmc_dev(host->mmc),
-					"Enabling debounce clk failed\n");
-
-		omap_mmc_conf_bus_power(host);
+		omap_hsmmc_conf_bus_power(host);
 
 		if (host->pdata->resume) {
 			ret = host->pdata->resume(&pdev->dev, host->slot_id);
@@ -1302,12 +1922,14 @@ static int omap_mmc_resume(struct platfo
 					"Unmask interrupt failed\n");
 		}
 
+		omap_hsmmc_protect_card(host);
+
 		/* Notify the core to resume the host */
 		ret = mmc_resume_host(host->mmc);
 		if (ret == 0)
 			host->suspended = 0;
 
-		mmc_omap_fclk_lazy_disable(host);
+		mmc_host_lazy_disable(host->mmc);
 	}
 
 	return ret;
@@ -1319,35 +1941,35 @@ clk_en_err:
 }
 
 #else
-#define omap_mmc_suspend	NULL
-#define omap_mmc_resume		NULL
+#define omap_hsmmc_suspend	NULL
+#define omap_hsmmc_resume		NULL
 #endif
 
-static struct platform_driver omap_mmc_driver = {
-	.probe		= omap_mmc_probe,
-	.remove		= omap_mmc_remove,
-	.suspend	= omap_mmc_suspend,
-	.resume		= omap_mmc_resume,
+static struct platform_driver omap_hsmmc_driver = {
+	.probe		= omap_hsmmc_probe,
+	.remove		= omap_hsmmc_remove,
+	.suspend	= omap_hsmmc_suspend,
+	.resume		= omap_hsmmc_resume,
 	.driver		= {
 		.name = DRIVER_NAME,
 		.owner = THIS_MODULE,
 	},
 };
 
-static int __init omap_mmc_init(void)
+static int __init omap_hsmmc_init(void)
 {
 	/* Register the MMC driver */
-	return platform_driver_register(&omap_mmc_driver);
+	return platform_driver_register(&omap_hsmmc_driver);
 }
 
-static void __exit omap_mmc_cleanup(void)
+static void __exit omap_hsmmc_cleanup(void)
 {
 	/* Unregister MMC driver */
-	platform_driver_unregister(&omap_mmc_driver);
+	platform_driver_unregister(&omap_hsmmc_driver);
 }
 
-module_init(omap_mmc_init);
-module_exit(omap_mmc_cleanup);
+module_init(omap_hsmmc_init);
+module_exit(omap_hsmmc_cleanup);
 
 MODULE_DESCRIPTION("OMAP High Speed Multimedia Card driver");
 MODULE_LICENSE("GPL");
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mtd/mtdpart.c kernel-2.6.28-20093908+0m5/drivers/mtd/mtdpart.c
--- kernel-2.6.28-20091602+0m5/drivers/mtd/mtdpart.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mtd/mtdpart.c	2012-12-16 13:13:01.676330146 +0100
@@ -18,6 +18,7 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 #include <linux/mtd/compatmac.h>
+#include <linux/seq_file.h>
 
 /* Our partition linked list */
 static LIST_HEAD(mtd_partitions);
@@ -54,6 +55,8 @@ static int part_read(struct mtd_info *mt
 		len = 0;
 	else if (from + len > mtd->size)
 		len = mtd->size - from;
+	mtd->read_cnt += 1;
+	mtd->read_sz += len;
 	res = part->master->read(part->master, from + part->offset,
 				   len, retlen, buf);
 	if (unlikely(res)) {
@@ -73,6 +76,7 @@ static int part_point(struct mtd_info *m
 		len = 0;
 	else if (from + len > mtd->size)
 		len = mtd->size - from;
+	mtd->other_cnt += 1;
 	return part->master->point (part->master, from + part->offset,
 				    len, retlen, virt, phys);
 }
@@ -81,6 +85,7 @@ static void part_unpoint(struct mtd_info
 {
 	struct mtd_part *part = PART(mtd);
 
+	mtd->other_cnt += 1;
 	part->master->unpoint(part->master, from + part->offset, len);
 }
 
@@ -94,6 +99,7 @@ static int part_read_oob(struct mtd_info
 		return -EINVAL;
 	if (ops->datbuf && from + ops->len > mtd->size)
 		return -EINVAL;
+	mtd->other_cnt += 1;
 	res = part->master->read_oob(part->master, from + part->offset, ops);
 
 	if (unlikely(res)) {
@@ -109,6 +115,7 @@ static int part_read_user_prot_reg(struc
 		size_t len, size_t *retlen, u_char *buf)
 {
 	struct mtd_part *part = PART(mtd);
+	mtd->other_cnt += 1;
 	return part->master->read_user_prot_reg(part->master, from,
 					len, retlen, buf);
 }
@@ -117,6 +124,7 @@ static int part_get_user_prot_info(struc
 		struct otp_info *buf, size_t len)
 {
 	struct mtd_part *part = PART(mtd);
+	mtd->other_cnt += 1;
 	return part->master->get_user_prot_info(part->master, buf, len);
 }
 
@@ -124,6 +132,7 @@ static int part_read_fact_prot_reg(struc
 		size_t len, size_t *retlen, u_char *buf)
 {
 	struct mtd_part *part = PART(mtd);
+	mtd->other_cnt += 1;
 	return part->master->read_fact_prot_reg(part->master, from,
 					len, retlen, buf);
 }
@@ -132,6 +141,7 @@ static int part_get_fact_prot_info(struc
 		size_t len)
 {
 	struct mtd_part *part = PART(mtd);
+	mtd->other_cnt += 1;
 	return part->master->get_fact_prot_info(part->master, buf, len);
 }
 
@@ -145,6 +155,8 @@ static int part_write(struct mtd_info *m
 		len = 0;
 	else if (to + len > mtd->size)
 		len = mtd->size - to;
+	mtd->write_cnt += 1;
+	mtd->write_sz += len;
 	return part->master->write(part->master, to + part->offset,
 				    len, retlen, buf);
 }
@@ -159,6 +171,8 @@ static int part_panic_write(struct mtd_i
 		len = 0;
 	else if (to + len > mtd->size)
 		len = mtd->size - to;
+	mtd->write_cnt += 1;
+	mtd->write_sz += len;
 	return part->master->panic_write(part->master, to + part->offset,
 				    len, retlen, buf);
 }
@@ -175,6 +189,7 @@ static int part_write_oob(struct mtd_inf
 		return -EINVAL;
 	if (ops->datbuf && to + ops->len > mtd->size)
 		return -EINVAL;
+	mtd->other_cnt += 1;
 	return part->master->write_oob(part->master, to + part->offset, ops);
 }
 
@@ -182,6 +197,7 @@ static int part_write_user_prot_reg(stru
 		size_t len, size_t *retlen, u_char *buf)
 {
 	struct mtd_part *part = PART(mtd);
+	mtd->other_cnt += 1;
 	return part->master->write_user_prot_reg(part->master, from,
 					len, retlen, buf);
 }
@@ -190,6 +206,7 @@ static int part_lock_user_prot_reg(struc
 		size_t len)
 {
 	struct mtd_part *part = PART(mtd);
+	mtd->other_cnt += 1;
 	return part->master->lock_user_prot_reg(part->master, from, len);
 }
 
@@ -197,8 +214,13 @@ static int part_writev(struct mtd_info *
 		unsigned long count, loff_t to, size_t *retlen)
 {
 	struct mtd_part *part = PART(mtd);
+	unsigned long i;
 	if (!(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
+	for (i = 0; i < count; i++) {
+		mtd->write_cnt += 1;
+		mtd->write_sz += vecs[i].iov_len;
+	}
 	return part->master->writev(part->master, vecs, count,
 					to + part->offset, retlen);
 }
@@ -212,6 +234,8 @@ static int part_erase(struct mtd_info *m
 	if (instr->addr >= mtd->size)
 		return -EINVAL;
 	instr->addr += part->offset;
+	mtd->erase_cnt += 1;
+	mtd->erase_sz += instr->len;
 	ret = part->master->erase(part->master, instr);
 	if (ret) {
 		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
@@ -240,6 +264,7 @@ static int part_lock(struct mtd_info *mt
 	struct mtd_part *part = PART(mtd);
 	if ((len + ofs) > mtd->size)
 		return -EINVAL;
+	mtd->other_cnt += 1;
 	return part->master->lock(part->master, ofs + part->offset, len);
 }
 
@@ -248,6 +273,7 @@ static int part_unlock(struct mtd_info *
 	struct mtd_part *part = PART(mtd);
 	if ((len + ofs) > mtd->size)
 		return -EINVAL;
+	mtd->other_cnt += 1;
 	return part->master->unlock(part->master, ofs + part->offset, len);
 }
 
@@ -287,6 +313,7 @@ static int part_block_markbad(struct mtd
 		return -EROFS;
 	if (ofs >= mtd->size)
 		return -EINVAL;
+	mtd->other_cnt += 1;
 	ofs += part->offset;
 	res = part->master->block_markbad(part->master, ofs);
 	if (!res)
@@ -581,3 +608,32 @@ int parse_mtd_partitions(struct mtd_info
 	return ret;
 }
 EXPORT_SYMBOL_GPL(parse_mtd_partitions);
+
+void mtd_diskstats(struct seq_file *seqf)
+{
+	struct mtd_part *part;
+
+	list_for_each_entry(part, &mtd_partitions, list) {
+		struct mtd_info *mtd = &part->mtd;
+
+		seq_printf(seqf, "%4d %7d %s %u %u %u "
+			   "%u %u %u %u %u %u %u %u %u %u %u\n",
+			   MTD_CHAR_MAJOR, mtd->index << 1,
+			   mtd->name,
+			   mtd->read_cnt,
+			   0, /* reads merged */
+			   mtd->read_sz >> 9,
+			   0, /* read time */
+			   mtd->write_cnt,
+			   0, /* writes merged */
+			   mtd->write_sz >> 9,
+			   0, /* write time */
+			   0, /* I/Os in progress */
+			   0, /* I/O time */
+			   0, /* weighted I/O time */
+			   mtd->erase_cnt,
+			   mtd->erase_sz,
+			   mtd->other_cnt
+			);
+	}
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mtd/onenand/onenand_base.c kernel-2.6.28-20093908+0m5/drivers/mtd/onenand/onenand_base.c
--- kernel-2.6.28-20091602+0m5/drivers/mtd/onenand/onenand_base.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mtd/onenand/onenand_base.c	2012-12-16 13:13:01.676330146 +0100
@@ -2576,6 +2576,7 @@ static void onenand_print_device_info(in
 
 static const struct onenand_manufacturers onenand_manuf_ids[] = {
         {ONENAND_MFR_SAMSUNG, "Samsung"},
+	{ONENAND_MFR_NUMONYX, "Numonyx"},
 };
 
 /**
@@ -2621,7 +2622,7 @@ static int onenand_probe(struct mtd_info
 	/* Save system configuration 1 */
 	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
 	/* Clear Sync. Burst Read mode to read BootRAM */
-	this->write_word((syscfg & ~ONENAND_SYS_CFG1_SYNC_READ), this->base + ONENAND_REG_SYS_CFG1);
+	this->write_word((syscfg & ~ONENAND_SYS_CFG1_SYNC_READ & ~ONENAND_SYS_CFG1_SYNC_WRITE), this->base + ONENAND_REG_SYS_CFG1);
 
 	/* Send the command for reading device ID from BootRAM */
 	this->write_word(ONENAND_CMD_READID, this->base + ONENAND_BOOTRAM);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mtd/ubi/build.c kernel-2.6.28-20093908+0m5/drivers/mtd/ubi/build.c
--- kernel-2.6.28-20091602+0m5/drivers/mtd/ubi/build.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mtd/ubi/build.c	2012-12-16 13:13:01.676330146 +0100
@@ -632,6 +632,15 @@ static int io_init(struct ubi_device *ub
 	}
 
 	/*
+	 * Set maximum amount of physical erroneous eraseblocks to be 10%.
+	 * Erroneous PEB are those which have read errors.
+	 */
+	ubi->max_erroneous = ubi->peb_count / 10;
+	if (ubi->max_erroneous < 16)
+		ubi->max_erroneous = 16;
+	dbg_msg("max_erroneous    %d", ubi->max_erroneous);
+
+	/*
 	 * It may happen that EC and VID headers are situated in one minimal
 	 * I/O unit. In this case we can only accept this UBI image in
 	 * read-only mode.
@@ -870,6 +879,7 @@ int ubi_attach_mtd_dev(struct mtd_info *
 	ubi_msg("number of PEBs reserved for bad PEB handling: %d",
 		ubi->beb_rsvd_pebs);
 	ubi_msg("max/mean erase counter: %d/%d", ubi->max_ec, ubi->mean_ec);
+	ubi_msg("image sequence number: %d", ubi->image_seq);
 
 	if (!DBG_DISABLE_BGT)
 		ubi->thread_enabled = 1;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mtd/ubi/debug.c kernel-2.6.28-20093908+0m5/drivers/mtd/ubi/debug.c
--- kernel-2.6.28-20091602+0m5/drivers/mtd/ubi/debug.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mtd/ubi/debug.c	2012-12-16 13:13:01.676330146 +0100
@@ -44,6 +44,8 @@ void ubi_dbg_dump_ec_hdr(const struct ub
 	       be32_to_cpu(ec_hdr->vid_hdr_offset));
 	printk(KERN_DEBUG "\tdata_offset    %d\n",
 	       be32_to_cpu(ec_hdr->data_offset));
+	printk(KERN_DEBUG "\timage_seq      %d\n",
+	       be32_to_cpu(ec_hdr->image_seq));
 	printk(KERN_DEBUG "\thdr_crc        %#08x\n",
 	       be32_to_cpu(ec_hdr->hdr_crc));
 	printk(KERN_DEBUG "erase counter header hexdump:\n");
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mtd/ubi/eba.c kernel-2.6.28-20093908+0m5/drivers/mtd/ubi/eba.c
--- kernel-2.6.28-20091602+0m5/drivers/mtd/ubi/eba.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mtd/ubi/eba.c	2012-12-16 13:13:01.680330145 +0100
@@ -419,8 +419,9 @@ retry:
 				 * not implemented.
 				 */
 				if (err == UBI_IO_BAD_VID_HDR) {
-					ubi_warn("bad VID header at PEB %d, LEB"
-						 "%d:%d", pnum, vol_id, lnum);
+					ubi_warn("corrupted VID header at PEB "
+						 "%d, LEB %d:%d", pnum, vol_id,
+						 lnum);
 					err = -EBADMSG;
 				} else
 					ubi_ro_mode(ubi);
@@ -940,6 +941,33 @@ write_error:
 }
 
 /**
+ * is_error_sane - check whether a read error is sane.
+ * @err: code of the error happened during reading
+ *
+ * This is a helper function for 'ubi_eba_copy_leb()' which is called when we
+ * cannot read data from the target PEB (an error @err happened). If the error
+ * code is sane, then we treat this error as non-fatal. Otherwise the error is
+ * fatal and UBI will be switched to R/O mode later.
+ *
+ * The idea is that we try not to switch to R/O mode if the read error is
+ * something which suggests there was a real read problem. E.g., %-EIO. Or a
+ * memory allocation failed (-%ENOMEM). Otherwise, it is safer to switch to R/O
+ * mode, simply because we do not know what happened at the MTD level, and we
+ * cannot handle this. E.g., the underlying driver may have become crazy, and
+ * it is safer to switch to R/O mode to preserve the data.
+ *
+ * And bear in mind, this is about reading from the target PEB, i.e. the PEB
+ * which we have just written.
+ */
+static int is_error_sane(int err)
+{
+	if (err == -EIO || err == -ENOMEM || err == UBI_IO_BAD_VID_HDR ||
+	    err == -ETIMEDOUT)
+		return 0;
+	return 1;
+}
+
+/**
  * ubi_eba_copy_leb - copy logical eraseblock.
  * @ubi: UBI device description object
  * @from: physical eraseblock number from where to copy
@@ -950,12 +978,7 @@ write_error:
  * physical eraseblock @to. The @vid_hdr buffer may be changed by this
  * function. Returns:
  *   o %0 in case of success;
- *   o %1 if the operation was canceled because the volume is being deleted
- *        or because the PEB was put meanwhile;
- *   o %2 if the operation was canceled because there was a write error to the
- *        target PEB;
- *   o %-EAGAIN if the operation was canceled because a bit-flip was detected
- *     in the target PEB;
+ *   o %MOVE_CANCEL_RACE, %MOVE_TARGET_WR_ERR, %MOVE_CANCEL_BITFLIPS, etc;
  *   o a negative error code in case of failure.
  */
 int ubi_eba_copy_leb(struct ubi_device *ubi, int from, int to,
@@ -968,7 +991,7 @@ int ubi_eba_copy_leb(struct ubi_device *
 	vol_id = be32_to_cpu(vid_hdr->vol_id);
 	lnum = be32_to_cpu(vid_hdr->lnum);
 
-	dbg_eba("copy LEB %d:%d, PEB %d to PEB %d", vol_id, lnum, from, to);
+	dbg_wl("copy LEB %d:%d, PEB %d to PEB %d", vol_id, lnum, from, to);
 
 	if (vid_hdr->vol_type == UBI_VID_STATIC) {
 		data_size = be32_to_cpu(vid_hdr->data_size);
@@ -986,13 +1009,12 @@ int ubi_eba_copy_leb(struct ubi_device *
 	 * be locked in 'ubi_wl_put_peb()' and wait for the WL worker to finish.
 	 */
 	vol = ubi->volumes[idx];
+	spin_unlock(&ubi->volumes_lock);
 	if (!vol) {
 		/* No need to do further work, cancel */
-		dbg_eba("volume %d is being removed, cancel", vol_id);
-		spin_unlock(&ubi->volumes_lock);
-		return 1;
+		dbg_wl("volume %d is being removed, cancel", vol_id);
+		return MOVE_CANCEL_RACE;
 	}
-	spin_unlock(&ubi->volumes_lock);
 
 	/*
 	 * We do not want anybody to write to this logical eraseblock while we
@@ -1004,12 +1026,13 @@ int ubi_eba_copy_leb(struct ubi_device *
 	 * (@from). This task locks the LEB and goes sleep in the
 	 * 'ubi_wl_put_peb()' function on the @ubi->move_mutex. In turn, we are
 	 * holding @ubi->move_mutex and go sleep on the LEB lock. So, if the
-	 * LEB is already locked, we just do not move it and return %1.
+	 * LEB is already locked, we just do not move it and return
+	 * %MOVE_CANCEL_RACE, which means that UBI will re-try, but later.
 	 */
 	err = leb_write_trylock(ubi, vol_id, lnum);
 	if (err) {
-		dbg_eba("contention on LEB %d:%d, cancel", vol_id, lnum);
-		return err;
+		dbg_wl("contention on LEB %d:%d, cancel", vol_id, lnum);
+		return MOVE_CANCEL_RACE;
 	}
 
 	/*
@@ -1018,25 +1041,26 @@ int ubi_eba_copy_leb(struct ubi_device *
 	 * cancel it.
 	 */
 	if (vol->eba_tbl[lnum] != from) {
-		dbg_eba("LEB %d:%d is no longer mapped to PEB %d, mapped to "
-			"PEB %d, cancel", vol_id, lnum, from,
-			vol->eba_tbl[lnum]);
-		err = 1;
+		dbg_wl("LEB %d:%d is no longer mapped to PEB %d, mapped to "
+		       "PEB %d, cancel", vol_id, lnum, from,
+		       vol->eba_tbl[lnum]);
+		err = MOVE_CANCEL_RACE;
 		goto out_unlock_leb;
 	}
 
 	/*
 	 * OK, now the LEB is locked and we can safely start moving it. Since
-	 * this function utilizes the @ubi->peb1_buf buffer which is shared
-	 * with some other functions, so lock the buffer by taking the
+	 * this function utilizes the @ubi->peb_buf1 buffer which is shared
+	 * with some other functions - we lock the buffer by taking the
 	 * @ubi->buf_mutex.
 	 */
 	mutex_lock(&ubi->buf_mutex);
-	dbg_eba("read %d bytes of data", aldata_size);
+	dbg_wl("read %d bytes of data", aldata_size);
 	err = ubi_io_read_data(ubi, ubi->peb_buf1, from, 0, aldata_size);
 	if (err && err != UBI_IO_BITFLIPS) {
 		ubi_warn("error %d while reading data from PEB %d",
 			 err, from);
+		err = MOVE_SOURCE_RD_ERR;
 		goto out_unlock_buf;
 	}
 
@@ -1059,7 +1083,7 @@ int ubi_eba_copy_leb(struct ubi_device *
 	cond_resched();
 
 	/*
-	 * It may turn out to me that the whole @from physical eraseblock
+	 * It may turn out to be that the whole @from physical eraseblock
 	 * contains only 0xFF bytes. Then we have to only write the VID header
 	 * and do not write any data. This also means we should not set
 	 * @vid_hdr->copy_flag, @vid_hdr->data_size, and @vid_hdr->data_crc.
@@ -1074,7 +1098,7 @@ int ubi_eba_copy_leb(struct ubi_device *
 	err = ubi_io_write_vid_hdr(ubi, to, vid_hdr);
 	if (err) {
 		if (err == -EIO)
-			err = 2;
+			err = MOVE_TARGET_WR_ERR;
 		goto out_unlock_buf;
 	}
 
@@ -1083,10 +1107,13 @@ int ubi_eba_copy_leb(struct ubi_device *
 	/* Read the VID header back and check if it was written correctly */
 	err = ubi_io_read_vid_hdr(ubi, to, vid_hdr, 1);
 	if (err) {
-		if (err != UBI_IO_BITFLIPS)
-			ubi_warn("cannot read VID header back from PEB %d", to);
-		else
-			err = -EAGAIN;
+		if (err != UBI_IO_BITFLIPS) {
+			ubi_warn("error %d while reading VID header back from "
+				  "PEB %d", err, to);
+			if (is_error_sane(err))
+				err = MOVE_TARGET_RD_ERR;
+		} else
+			err = MOVE_CANCEL_BITFLIPS;
 		goto out_unlock_buf;
 	}
 
@@ -1094,7 +1121,7 @@ int ubi_eba_copy_leb(struct ubi_device *
 		err = ubi_io_write_data(ubi, ubi->peb_buf1, to, 0, aldata_size);
 		if (err) {
 			if (err == -EIO)
-				err = 2;
+				err = MOVE_TARGET_WR_ERR;
 			goto out_unlock_buf;
 		}
 
@@ -1107,11 +1134,13 @@ int ubi_eba_copy_leb(struct ubi_device *
 
 		err = ubi_io_read_data(ubi, ubi->peb_buf2, to, 0, aldata_size);
 		if (err) {
-			if (err != UBI_IO_BITFLIPS)
-				ubi_warn("cannot read data back from PEB %d",
-					 to);
-			else
-				err = -EAGAIN;
+			if (err != UBI_IO_BITFLIPS) {
+				ubi_warn("error %d while reading data back "
+					 "from PEB %d", err, to);
+				if (is_error_sane(err))
+					err = MOVE_TARGET_RD_ERR;
+			} else
+				err = MOVE_CANCEL_BITFLIPS;
 			goto out_unlock_buf;
 		}
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mtd/ubi/io.c kernel-2.6.28-20093908+0m5/drivers/mtd/ubi/io.c
--- kernel-2.6.28-20091602+0m5/drivers/mtd/ubi/io.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mtd/ubi/io.c	2012-12-16 13:13:01.680330145 +0100
@@ -566,15 +566,16 @@ int ubi_io_mark_bad(const struct ubi_dev
  * This function returns zero if the erase counter header is OK, and %1 if
  * not.
  */
-static int validate_ec_hdr(const struct ubi_device *ubi,
+static int validate_ec_hdr(struct ubi_device *ubi,
 			   const struct ubi_ec_hdr *ec_hdr)
 {
 	long long ec;
-	int vid_hdr_offset, leb_start;
+	int vid_hdr_offset, leb_start, image_seq;
 
 	ec = be64_to_cpu(ec_hdr->ec);
 	vid_hdr_offset = be32_to_cpu(ec_hdr->vid_hdr_offset);
 	leb_start = be32_to_cpu(ec_hdr->data_offset);
+	image_seq = be32_to_cpu(ec_hdr->image_seq);
 
 	if (ec_hdr->version != UBI_VERSION) {
 		ubi_err("node with incompatible UBI version found: "
@@ -600,6 +601,15 @@ static int validate_ec_hdr(const struct
 		goto bad;
 	}
 
+	if (!ubi->image_seq_set) {
+		ubi->image_seq = image_seq;
+		ubi->image_seq_set = 1;
+	} else if (ubi->image_seq && image_seq && ubi->image_seq != image_seq) {
+		ubi_err("bad image sequence number %d, expected %d",
+			image_seq, ubi->image_seq);
+		goto bad;
+	}
+
 	return 0;
 
 bad:
@@ -755,6 +765,7 @@ int ubi_io_write_ec_hdr(struct ubi_devic
 	ec_hdr->version = UBI_VERSION;
 	ec_hdr->vid_hdr_offset = cpu_to_be32(ubi->vid_hdr_offset);
 	ec_hdr->data_offset = cpu_to_be32(ubi->leb_start);
+	ec_hdr->image_seq = cpu_to_be32(ubi->image_seq);
 	crc = crc32(UBI_CRC32_INIT, ec_hdr, UBI_EC_HDR_SIZE_CRC);
 	ec_hdr->hdr_crc = cpu_to_be32(crc);
 
@@ -902,7 +913,7 @@ bad:
  * o %UBI_IO_BITFLIPS if the CRC is correct, but bit-flips were detected
  *   and corrected by the flash driver; this is harmless but may indicate that
  *   this eraseblock may become bad soon;
- * o %UBI_IO_BAD_VID_HRD if the volume identifier header is corrupted (a CRC
+ * o %UBI_IO_BAD_VID_HDR if the volume identifier header is corrupted (a CRC
  *   error detected);
  * o %UBI_IO_PEB_FREE if the physical eraseblock is free (i.e., there is no VID
  *   header there);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mtd/ubi/scan.c kernel-2.6.28-20093908+0m5/drivers/mtd/ubi/scan.c
--- kernel-2.6.28-20091602+0m5/drivers/mtd/ubi/scan.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mtd/ubi/scan.c	2012-12-16 13:13:01.680330145 +0100
@@ -912,6 +912,8 @@ struct ubi_scan_info *ubi_scan(struct ub
 	if (si->is_empty)
 		ubi_msg("empty MTD device detected");
 
+	ubi->image_seq_set = 1;
+
 	/*
 	 * In case of unknown erase counter we use the mean erase counter
 	 * value.
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mtd/ubi/ubi.h kernel-2.6.28-20093908+0m5/drivers/mtd/ubi/ubi.h
--- kernel-2.6.28-20091602+0m5/drivers/mtd/ubi/ubi.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mtd/ubi/ubi.h	2012-12-16 13:13:01.680330145 +0100
@@ -100,6 +100,28 @@ enum {
 	UBI_IO_BITFLIPS
 };
 
+/*
+ * Return codes of the 'ubi_eba_copy_leb()' function.
+ *
+ * MOVE_CANCEL_RACE: canceled because the volume is being deleted, the source
+ *                   PEB was put meanwhile, or there is I/O on the source PEB
+ * MOVE_SOURCE_RD_ERR: canceled because there was a read error from the source
+ *                     PEB
+ * MOVE_TARGET_RD_ERR: canceled because there was a read error from the target
+ *                     PEB
+ * MOVE_TARGET_WR_ERR: canceled because there was a write error to the target
+ *                     PEB
+ * MOVE_CANCEL_BITFLIPS: canceled because a bit-flip was detected in the
+ *                       target PEB
+ */
+enum {
+	MOVE_CANCEL_RACE = 1,
+	MOVE_SOURCE_RD_ERR,
+	MOVE_TARGET_RD_ERR,
+	MOVE_TARGET_WR_ERR,
+	MOVE_CANCEL_BITFLIPS,
+};
+
 /**
  * struct ubi_wl_entry - wear-leveling entry.
  * @u.rb: link in the corresponding (free/used) RB-tree
@@ -291,6 +313,8 @@ struct ubi_wl_entry;
  *                @vol->readers, @vol->writers, @vol->exclusive,
  *                @vol->ref_count, @vol->mapping and @vol->eba_tbl.
  * @ref_count: count of references on the UBI device
+ * @image_seq: image sequence number recorded on EC headers
+ * @image_seq_set: indicates @image_seq is known
  *
  * @rsvd_pebs: count of reserved physical eraseblocks
  * @avail_pebs: count of available physical eraseblocks
@@ -315,14 +339,15 @@ struct ubi_wl_entry;
  * @alc_mutex: serializes "atomic LEB change" operations
  *
  * @used: RB-tree of used physical eraseblocks
+ * @erroneous: RB-tree of erroneous used physical eraseblocks
  * @free: RB-tree of free physical eraseblocks
  * @scrub: RB-tree of physical eraseblocks which need scrubbing
  * @pq: protection queue (contain physical eraseblocks which are temporarily
  *      protected from the wear-leveling worker)
  * @pq_head: protection queue head
  * @wl_lock: protects the @used, @free, @pq, @pq_head, @lookuptbl, @move_from,
- * 	     @move_to, @move_to_put @erase_pending, @wl_scheduled and @works
- * 	     fields
+ * 	     @move_to, @move_to_put @erase_pending, @wl_scheduled, @works,
+ * 	     @erroneous, and @erroneous_peb_count fields
  * @move_mutex: serializes eraseblock moves
  * @work_sem: synchronizes the WL worker with use tasks
  * @wl_scheduled: non-zero if the wear-leveling was scheduled
@@ -342,6 +367,8 @@ struct ubi_wl_entry;
  * @peb_size: physical eraseblock size
  * @bad_peb_count: count of bad physical eraseblocks
  * @good_peb_count: count of good physical eraseblocks
+ * @erroneous_peb_count: count of erroneous physical eraseblocks in @erroneous
+ * @max_erroneous: maximum allowed amount of erroneous physical eraseblocks
  * @min_io_size: minimal input/output unit size of the underlying MTD device
  * @hdrs_min_io_size: minimal I/O unit size used for VID and EC headers
  * @ro_mode: if the UBI device is in read-only mode
@@ -376,6 +403,8 @@ struct ubi_device {
 	struct ubi_volume *volumes[UBI_MAX_VOLUMES+UBI_INT_VOL_COUNT];
 	spinlock_t volumes_lock;
 	int ref_count;
+	int image_seq;
+	int image_seq_set;
 
 	int rsvd_pebs;
 	int avail_pebs;
@@ -400,6 +429,7 @@ struct ubi_device {
 
 	/* Wear-leveling sub-system's stuff */
 	struct rb_root used;
+	struct rb_root erroneous;
 	struct rb_root free;
 	struct rb_root scrub;
 	struct list_head pq[UBI_PROT_QUEUE_LEN];
@@ -424,6 +454,8 @@ struct ubi_device {
 	int peb_size;
 	int bad_peb_count;
 	int good_peb_count;
+	int erroneous_peb_count;
+	int max_erroneous;
 	int min_io_size;
 	int hdrs_min_io_size;
 	int ro_mode;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mtd/ubi/ubi-media.h kernel-2.6.28-20093908+0m5/drivers/mtd/ubi/ubi-media.h
--- kernel-2.6.28-20091602+0m5/drivers/mtd/ubi/ubi-media.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mtd/ubi/ubi-media.h	2012-12-16 13:13:01.680330145 +0100
@@ -129,6 +129,7 @@ enum {
  * @ec: the erase counter
  * @vid_hdr_offset: where the VID header starts
  * @data_offset: where the user data start
+ * @image_seq: image sequence number
  * @padding2: reserved for future, zeroes
  * @hdr_crc: erase counter header CRC checksum
  *
@@ -144,6 +145,14 @@ enum {
  * volume identifier header and user data, relative to the beginning of the
  * physical eraseblock. These values have to be the same for all physical
  * eraseblocks.
+ *
+ * The @image_seq field is used to validate a UBI image that has been prepared
+ * for a UBI device. The @image_seq value can be any value, but it must be the
+ * same on all eraseblocks. UBI will ensure that all new erase counter headers
+ * also contain this value, and will check the value when scanning at start-up.
+ * One way to make use of @image_seq is to increase its value by one every time
+ * an image is flashed over an existing image, then, if the flashing does not
+ * complete, UBI will detect the error when scanning.
  */
 struct ubi_ec_hdr {
 	__be32  magic;
@@ -152,7 +161,8 @@ struct ubi_ec_hdr {
 	__be64  ec; /* Warning: the current limit is 31-bit anyway! */
 	__be32  vid_hdr_offset;
 	__be32  data_offset;
-	__u8    padding2[36];
+	__be32  image_seq;
+	__u8    padding2[32];
 	__be32  hdr_crc;
 } __attribute__ ((packed));
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/mtd/ubi/wl.c kernel-2.6.28-20093908+0m5/drivers/mtd/ubi/wl.c
--- kernel-2.6.28-20091602+0m5/drivers/mtd/ubi/wl.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/mtd/ubi/wl.c	2012-12-16 13:13:01.680330145 +0100
@@ -55,8 +55,8 @@
  *
  * As it was said, for the UBI sub-system all physical eraseblocks are either
  * "free" or "used". Free eraseblock are kept in the @wl->free RB-tree, while
- * used eraseblocks are kept in @wl->used or @wl->scrub RB-trees, or
- * (temporarily) in the @wl->pq queue.
+ * used eraseblocks are kept in @wl->used, @wl->erroneous, or @wl->scrub
+ * RB-trees, as well as (temporarily) in the @wl->pq queue.
  *
  * When the WL sub-system returns a physical eraseblock, the physical
  * eraseblock is protected from being moved for some "time". For this reason,
@@ -83,6 +83,8 @@
  * used. The former state corresponds to the @wl->free tree. The latter state
  * is split up on several sub-states:
  * o the WL movement is allowed (@wl->used tree);
+ * o the WL movement is disallowed (@wl->erroneous) because the PEB is
+ *   erroneous - e.g., there was a read error;
  * o the WL movement is temporarily prohibited (@wl->pq queue);
  * o scrubbing is needed (@wl->scrub tree).
  *
@@ -653,7 +655,7 @@ static int schedule_erase(struct ubi_dev
 static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,
 				int cancel)
 {
-	int err, scrubbing = 0, torture = 0;
+	int err, scrubbing = 0, torture = 0, protect = 0, erroneous = 0;
 	struct ubi_wl_entry *e1, *e2;
 	struct ubi_vid_hdr *vid_hdr;
 
@@ -738,65 +740,70 @@ static int wear_leveling_worker(struct u
 			/*
 			 * We are trying to move PEB without a VID header. UBI
 			 * always write VID headers shortly after the PEB was
-			 * given, so we have a situation when it did not have
-			 * chance to write it down because it was preempted.
-			 * Just re-schedule the work, so that next time it will
-			 * likely have the VID header in place.
+			 * given, so we have a situation when it has not yet
+			 * had a chance to write it, because it was preempted.
+			 * So add this PEB to the protection queue so far,
+			 * because presumably more data will be written there
+			 * (including the missing VID header), and then we'll
+			 * move it.
 			 */
 			dbg_wl("PEB %d has no VID header", e1->pnum);
+			protect = 1;
 			goto out_not_moved;
 		}
 
 		ubi_err("error %d while reading VID header from PEB %d",
 			err, e1->pnum);
-		if (err > 0)
-			err = -EIO;
 		goto out_error;
 	}
 
 	err = ubi_eba_copy_leb(ubi, e1->pnum, e2->pnum, vid_hdr);
 	if (err) {
-		if (err == -EAGAIN)
+		if (err == MOVE_CANCEL_RACE) {
+			/*
+			 * The LEB has not been moved because the volume is
+			 * being deleted or the PEB has been put meanwhile. We
+			 * should prevent this PEB from being selected for
+			 * wear-leveling movement again, so put it to the
+			 * protection queue.
+			 */
+			protect = 1;
 			goto out_not_moved;
-		if (err < 0)
-			goto out_error;
-		if (err == 2) {
-			/* Target PEB write error, torture it */
+		}
+
+		if (err == MOVE_CANCEL_BITFLIPS || err == MOVE_TARGET_WR_ERR ||
+		    err == MOVE_TARGET_RD_ERR) {
+			/* Target PEB bit-flips or write error, torture it */
 			torture = 1;
 			goto out_not_moved;
 		}
 
-		/*
-		 * The LEB has not been moved because the volume is being
-		 * deleted or the PEB has been put meanwhile. We should prevent
-		 * this PEB from being selected for wear-leveling movement
-		 * again, so put it to the protection queue.
-		 */
-
-		dbg_wl("canceled moving PEB %d", e1->pnum);
-		ubi_assert(err == 1);
-
-		ubi_free_vid_hdr(ubi, vid_hdr);
-		vid_hdr = NULL;
-
-		spin_lock(&ubi->wl_lock);
-		prot_queue_add(ubi, e1);
-		ubi_assert(!ubi->move_to_put);
-		ubi->move_from = ubi->move_to = NULL;
-		ubi->wl_scheduled = 0;
-		spin_unlock(&ubi->wl_lock);
+		if (err == MOVE_SOURCE_RD_ERR) {
+			/*
+			 * An error happened while reading the source PEB. Do
+			 * not switch to R/O mode in this case, and give the
+			 * upper layers a possibility to recover from this,
+			 * e.g. by unmapping corresponding LEB. Instead, just
+			 * put this PEB to the @ubi->erroneous list to prevent
+			 * UBI from trying to move it over and over again.
+			 */
+			if (ubi->erroneous_peb_count > ubi->max_erroneous) {
+				ubi_err("too many erroneous eraseblocks (%d)",
+					ubi->erroneous_peb_count);
+				goto out_error;
+			}
+			erroneous = 1;
+			goto out_not_moved;
+		}
 
-		e1 = NULL;
-		err = schedule_erase(ubi, e2, 0);
-		if (err)
+		if (err < 0)
 			goto out_error;
-		mutex_unlock(&ubi->move_mutex);
-		return 0;
+
+		ubi_assert(0);
 	}
 
 	/* The PEB has been successfully moved */
 	ubi_free_vid_hdr(ubi, vid_hdr);
-	vid_hdr = NULL;
 	if (scrubbing)
 		ubi_msg("scrubbed PEB %d, data moved to PEB %d",
 			e1->pnum, e2->pnum);
@@ -812,8 +819,10 @@ static int wear_leveling_worker(struct u
 
 	err = schedule_erase(ubi, e1, 0);
 	if (err) {
-		e1 = NULL;
-		goto out_error;
+		kmem_cache_free(ubi_wl_entry_slab, e1);
+		if (e2)
+			kmem_cache_free(ubi_wl_entry_slab, e2);
+		goto out_ro;
 	}
 
 	if (e2) {
@@ -823,8 +832,10 @@ static int wear_leveling_worker(struct u
 		 */
 		dbg_wl("PEB %d was put meanwhile, erase", e2->pnum);
 		err = schedule_erase(ubi, e2, 0);
-		if (err)
-			goto out_error;
+		if (err) {
+			kmem_cache_free(ubi_wl_entry_slab, e2);
+			goto out_ro;
+		}
 	}
 
 	dbg_wl("done");
@@ -837,11 +848,15 @@ static int wear_leveling_worker(struct u
 	 * have been changed, schedule it for erasure.
 	 */
 out_not_moved:
-	dbg_wl("canceled moving PEB %d", e1->pnum);
-	ubi_free_vid_hdr(ubi, vid_hdr);
-	vid_hdr = NULL;
+	dbg_wl("cancel moving PEB %d to PEB %d (%d)",
+	       e1->pnum, e2->pnum, err);
 	spin_lock(&ubi->wl_lock);
-	if (scrubbing)
+	if (protect)
+		prot_queue_add(ubi, e1);
+	else if (erroneous) {
+		wl_tree_add(e1, &ubi->erroneous);
+		ubi->erroneous_peb_count += 1;
+	} else if (scrubbing)
 		wl_tree_add(e1, &ubi->scrub);
 	else
 		wl_tree_add(e1, &ubi->used);
@@ -850,32 +865,32 @@ out_not_moved:
 	ubi->wl_scheduled = 0;
 	spin_unlock(&ubi->wl_lock);
 
-	e1 = NULL;
+	ubi_free_vid_hdr(ubi, vid_hdr);
 	err = schedule_erase(ubi, e2, torture);
-	if (err)
-		goto out_error;
-
+	if (err) {
+		kmem_cache_free(ubi_wl_entry_slab, e2);
+		goto out_ro;
+	}
 	mutex_unlock(&ubi->move_mutex);
 	return 0;
 
 out_error:
 	ubi_err("error %d while moving PEB %d to PEB %d",
 		err, e1->pnum, e2->pnum);
-
-	ubi_free_vid_hdr(ubi, vid_hdr);
 	spin_lock(&ubi->wl_lock);
 	ubi->move_from = ubi->move_to = NULL;
 	ubi->move_to_put = ubi->wl_scheduled = 0;
 	spin_unlock(&ubi->wl_lock);
 
-	if (e1)
-		kmem_cache_free(ubi_wl_entry_slab, e1);
-	if (e2)
-		kmem_cache_free(ubi_wl_entry_slab, e2);
-	ubi_ro_mode(ubi);
+	ubi_free_vid_hdr(ubi, vid_hdr);
+	kmem_cache_free(ubi_wl_entry_slab, e1);
+	kmem_cache_free(ubi_wl_entry_slab, e2);
 
+out_ro:
+	ubi_ro_mode(ubi);
 	mutex_unlock(&ubi->move_mutex);
-	return err;
+	ubi_assert(err != 0);
+	return err < 0 ? err : -EIO;
 
 out_cancel:
 	ubi->wl_scheduled = 0;
@@ -1015,7 +1030,7 @@ static int erase_worker(struct ubi_devic
 		/*
 		 * If this is not %-EIO, we have no idea what to do. Scheduling
 		 * this physical eraseblock for erasure again would cause
-		 * errors again and again. Well, lets switch to RO mode.
+		 * errors again and again. Well, lets switch to R/O mode.
 		 */
 		goto out_ro;
 	}
@@ -1125,6 +1140,13 @@ retry:
 		} else if (in_wl_tree(e, &ubi->scrub)) {
 			paranoid_check_in_wl_tree(e, &ubi->scrub);
 			rb_erase(&e->u.rb, &ubi->scrub);
+		} else if (in_wl_tree(e, &ubi->erroneous)) {
+			paranoid_check_in_wl_tree(e, &ubi->erroneous);
+			rb_erase(&e->u.rb, &ubi->erroneous);
+			ubi->erroneous_peb_count -= 1;
+			ubi_assert(ubi->erroneous_peb_count >= 0);
+			/* Erroneous PEBs should be tortured */
+			torture = 1;
 		} else {
 			err = prot_queue_del(ubi, e->pnum);
 			if (err) {
@@ -1373,7 +1395,7 @@ int ubi_wl_init_scan(struct ubi_device *
 	struct ubi_scan_leb *seb, *tmp;
 	struct ubi_wl_entry *e;
 
-	ubi->used = ubi->free = ubi->scrub = RB_ROOT;
+	ubi->used = ubi->erroneous = ubi->free = ubi->scrub = RB_ROOT;
 	spin_lock_init(&ubi->wl_lock);
 	mutex_init(&ubi->move_mutex);
 	init_rwsem(&ubi->work_sem);
@@ -1511,6 +1533,7 @@ void ubi_wl_close(struct ubi_device *ubi
 	cancel_pending(ubi);
 	protection_queue_destroy(ubi);
 	tree_destroy(&ubi->used);
+	tree_destroy(&ubi->erroneous);
 	tree_destroy(&ubi->free);
 	tree_destroy(&ubi->scrub);
 	kfree(ubi->lookuptbl);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/acx.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/acx.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/acx.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/acx.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,662 +0,0 @@
-#include "acx.h"
-
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/crc7.h>
-#include <linux/spi/spi.h>
-
-#include "wl12xx.h"
-#include "wl12xx_80211.h"
-#include "reg.h"
-#include "spi.h"
-#include "ps.h"
-
-int wl12xx_acx_frame_rates(struct wl12xx *wl, u8 ctrl_rate, u8 ctrl_mod,
-			   u8 mgt_rate, u8 mgt_mod)
-{
-	int ret;
-	struct acx_fw_gen_frame_rates rates;
-
-	wl12xx_debug(DEBUG_ACX, "acx frame rates");
-
-	rates.header.id = ACX_FW_GEN_FRAME_RATES;
-	rates.header.len = sizeof(struct acx_fw_gen_frame_rates) -
-		sizeof(struct acx_header);
-
-	rates.tx_ctrl_frame_rate = ctrl_rate;
-	rates.tx_ctrl_frame_mod = ctrl_mod;
-	rates.tx_mgt_frame_rate = mgt_rate;
-	rates.tx_mgt_frame_mod = mgt_mod;
-
-	ret = wl12xx_cmd_configure(wl, &rates, sizeof(rates));
-	if (ret < 0) {
-		wl12xx_error("Failed to set FW rates and modulation");
-		return ret;
-	}
-
-	return 0;
-}
-
-
-int wl12xx_acx_station_id(struct wl12xx *wl)
-{
-	int ret, i;
-	struct dot11_station_id mac;
-
-	wl12xx_debug(DEBUG_ACX, "acx dot11_station_id");
-
-	mac.header.id = DOT11_STATION_ID;
-	mac.header.len = sizeof(mac) - sizeof(struct acx_header);
-
-	for (i = 0; i < ETH_ALEN; i++)
-		mac.mac[i] = wl->mac_addr[ETH_ALEN - 1 - i];
-
-	ret = wl12xx_cmd_configure(wl, &mac, sizeof(mac));
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-int wl12xx_acx_default_key(struct wl12xx *wl, u8 key_id)
-{
-	struct acx_dot11_default_key default_key;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx dot11_default_key (%d)", key_id);
-
-	default_key.header.id = DOT11_DEFAULT_KEY;
-	default_key.header.len = sizeof(default_key) -
-		sizeof(struct acx_header);
-
-	default_key.id = key_id;
-
-	ret = wl12xx_cmd_configure(wl, &default_key, sizeof(default_key));
-	if (ret < 0) {
-		wl12xx_error("Couldnt set default key");
-		return ret;
-	}
-
-	wl->default_key = key_id;
-
-	return 0;
-}
-
-int wl12xx_acx_wake_up_conditions(struct wl12xx *wl, u8 listen_interval)
-{
-	struct acx_wake_up_condition wake_up;
-
-	wl12xx_debug(DEBUG_ACX, "acx wake up conditions");
-
-	wake_up.header.id = ACX_WAKE_UP_CONDITIONS;
-	wake_up.header.len = sizeof(wake_up) - sizeof(struct acx_header);
-
-	wake_up.wake_up_event = WAKE_UP_EVENT_DTIM_BITMAP;
-	wake_up.listen_interval = listen_interval;
-
-	return wl12xx_cmd_configure(wl, &wake_up, sizeof(wake_up));
-}
-
-int wl12xx_acx_sleep_auth(struct wl12xx *wl, u8 sleep_auth)
-{
-	int ret;
-	struct acx_sleep_auth auth;
-
-	wl12xx_debug(DEBUG_ACX, "acx sleep auth");
-
-	auth.header.id = ACX_SLEEP_AUTH;
-	auth.header.len = sizeof(auth) - sizeof(struct acx_header);
-
-	auth.sleep_auth = sleep_auth;
-
-	ret = wl12xx_cmd_configure(wl, &auth, sizeof(auth));
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-int wl12xx_acx_fw_version(struct wl12xx *wl, char *buf, size_t len)
-{
-	struct wl12xx_command cmd;
-	struct acx_revision *rev;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx fw rev");
-
-	memset(&cmd, 0, sizeof(cmd));
-
-	ret = wl12xx_cmd_interrogate(wl, ACX_FW_REV, sizeof(*rev), &cmd);
-	if (ret < 0) {
-		wl12xx_warning("ACX_FW_REV interrogate failed");
-		return ret;
-	}
-
-	rev = (struct acx_revision *) &cmd.parameters;
-
-	/* be careful with the buffer sizes */
-	strncpy(buf, rev->fw_version, min(len, sizeof(rev->fw_version)));
-
-	/*
-	 * if the firmware version string is exactly
-	 * sizeof(rev->fw_version) long or fw_len is less than
-	 * sizeof(rev->fw_version) it won't be null terminated
-	 */
-	buf[min(len, sizeof(rev->fw_version)) - 1] = '\0';
-
-	return 0;
-}
-
-int wl12xx_acx_tx_power(struct wl12xx *wl, int power)
-{
-	struct acx_current_tx_power ie;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx dot11_cur_tx_pwr");
-
-	if (power < 0 || power > 25)
-		return -EINVAL;
-
-	memset(&ie, 0, sizeof(ie));
-
-	ie.header.id = DOT11_CUR_TX_PWR;
-	ie.header.len = sizeof(ie) - sizeof(struct acx_header);
-	ie.current_tx_power = power * 10;
-
-	ret = wl12xx_cmd_configure(wl, &ie, sizeof(ie));
-	if (ret < 0) {
-		wl12xx_warning("configure of tx power failed: %d", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_acx_feature_cfg(struct wl12xx *wl)
-{
-	struct acx_feature_config feature;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx feature cfg");
-
-	memset(&feature, 0, sizeof(feature));
-
-	feature.header.id = ACX_FEATURE_CFG;
-	feature.header.len = sizeof(feature) - sizeof(struct acx_header);
-
-	/* DF_ENCRYPTION_DISABLE and DF_SNIFF_MODE_ENABLE are disabled */
-	feature.data_flow_options = 0;
-	feature.options = 0;
-
-	ret = wl12xx_cmd_configure(wl, &feature, sizeof(feature));
-	if (ret < 0)
-		wl12xx_error("Couldnt set HW encryption");
-
-	return ret;
-}
-
-int wl12xx_acx_mem_map(struct wl12xx *wl, void *mem_map, size_t len)
-{
-	struct wl12xx_command cmd;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx mem map");
-
-	ret = wl12xx_cmd_interrogate(wl, ACX_MEM_MAP, len, &cmd);
-	if (ret < 0)
-		return ret;
-	else if (cmd.status != CMD_STATUS_SUCCESS)
-		return -EIO;
-
-	memcpy(mem_map, &cmd.parameters, len);
-
-	return 0;
-}
-
-int wl12xx_acx_data_path_params(struct wl12xx *wl,
-				struct acx_data_path_params_resp *data_path)
-{
-	struct acx_data_path_params params;
-	struct wl12xx_command cmd;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx data path params");
-
-	params.rx_packet_ring_chunk_size = DP_RX_PACKET_RING_CHUNK_SIZE;
-	params.tx_packet_ring_chunk_size = DP_TX_PACKET_RING_CHUNK_SIZE;
-
-	params.rx_packet_ring_chunk_num = DP_RX_PACKET_RING_CHUNK_NUM;
-	params.tx_packet_ring_chunk_num = DP_TX_PACKET_RING_CHUNK_NUM;
-
-	params.tx_complete_threshold = 1;
-
-	params.tx_complete_ring_depth = FW_TX_CMPLT_BLOCK_SIZE;
-
-	params.tx_complete_timeout = DP_TX_COMPLETE_TIME_OUT;
-
-	params.header.id = ACX_DATA_PATH_PARAMS;
-	params.header.len = sizeof(params) - sizeof(struct acx_header);
-
-	ret = wl12xx_cmd_configure(wl, &params, sizeof(params));
-	if (ret < 0)
-		return ret;
-
-
-	ret = wl12xx_cmd_interrogate(wl, ACX_DATA_PATH_PARAMS,
-				     sizeof(struct acx_data_path_params_resp),
-				     &cmd);
-
-	if (ret < 0) {
-		wl12xx_warning("failed to read data path parameters: %d", ret);
-		return ret;
-	} else if (cmd.status != CMD_STATUS_SUCCESS) {
-		wl12xx_warning("data path parameter acx status failed");
-		return -EIO;
-	}
-
-	memcpy(data_path, &cmd.parameters, sizeof(*data_path));
-
-	return 0;
-}
-
-int wl12xx_acx_rx_msdu_life_time(struct wl12xx *wl, u32 life_time)
-{
-	struct rx_msdu_lifetime msdu_lifetime;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx rx msdu life time");
-
-	msdu_lifetime.header.id = DOT11_RX_MSDU_LIFE_TIME;
-	msdu_lifetime.header.len = sizeof(msdu_lifetime) -
-		sizeof(struct acx_header);
-	msdu_lifetime.lifetime = life_time;
-
-	ret = wl12xx_cmd_configure(wl, &msdu_lifetime, sizeof(msdu_lifetime));
-	if (ret < 0) {
-		wl12xx_warning("failed to set rx msdu life time: %d", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_acx_rx_config(struct wl12xx *wl, u32 config, u32 filter)
-{
-	struct acx_rx_config rx_config;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx rx config");
-
-	rx_config.header.id = ACX_RX_CFG;
-	rx_config.header.len = sizeof(rx_config) - sizeof(struct acx_header);
-	rx_config.config_options = config;
-	rx_config.filter_options = filter;
-
-	ret = wl12xx_cmd_configure(wl, &rx_config, sizeof(rx_config));
-	if (ret < 0) {
-		wl12xx_warning("failed to set rx config: %d", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_acx_pd_threshold(struct wl12xx *wl)
-{
-	struct acx_packet_detection packet_detection;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx data pd threshold");
-
-	/* FIXME: threshold value not set */
-	packet_detection.header.id = ACX_PD_THRESHOLD;
-	packet_detection.header.len = sizeof(packet_detection) -
-		sizeof(struct acx_header);
-
-	ret = wl12xx_cmd_configure(wl, &packet_detection,
-				   sizeof(packet_detection));
-	if (ret < 0) {
-		wl12xx_warning("failed to set pd threshold: %d", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_acx_slot(struct wl12xx *wl, enum acx_slot_type slot_time)
-{
-	struct acx_slot slot;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx slot");
-
-	slot.header.id = ACX_SLOT;
-	slot.header.len = sizeof(slot) - sizeof(struct acx_header);
-
-	slot.wone_index = STATION_WONE_INDEX;
-	slot.slot_time = slot_time;
-
-	ret = wl12xx_cmd_configure(wl, &slot, sizeof(slot));
-	if (ret < 0) {
-		wl12xx_warning("failed to set slot time: %d", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_acx_group_address_tbl(struct wl12xx *wl)
-{
-	struct multicast_grp_addr_start multicast;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx group address tbl");
-
-	/* MAC filtering */
-	multicast.header.id = DOT11_GROUP_ADDRESS_TBL;
-	multicast.header.len = sizeof(multicast) - sizeof(struct acx_header);
-
-	multicast.enabled = 0;
-	multicast.num_groups = 0;
-	memset(multicast.mac_table, 0, ADDRESS_GROUP_MAX_LEN);
-
-	ret = wl12xx_cmd_configure(wl, &multicast, sizeof(multicast));
-	if (ret < 0) {
-		wl12xx_warning("failed to set group addr table: %d", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_acx_service_period_timeout(struct wl12xx *wl)
-{
-	struct acx_rx_timeout rx_timeout;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx service period timeout");
-
-	/* RX timeout */
-	rx_timeout.header.id = ACX_SERVICE_PERIOD_TIMEOUT;
-	rx_timeout.header.len = sizeof(rx_timeout) - sizeof(struct acx_header);
-
-	rx_timeout.ps_poll_timeout = RX_TIMEOUT_PS_POLL_DEF;
-	rx_timeout.upsd_timeout = RX_TIMEOUT_UPSD_DEF;
-
-	ret = wl12xx_cmd_configure(wl, &rx_timeout, sizeof(rx_timeout));
-	if (ret < 0) {
-		wl12xx_warning("failed to set service period timeout: %d",
-			       ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_acx_rts_threshold(struct wl12xx *wl, u16 rts_threshold)
-{
-	struct acx_rts_threshold rts;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx rts threshold");
-
-	rts.header.id = DOT11_RTS_THRESHOLD;
-	rts.header.len = sizeof(rts) - sizeof(struct acx_header);
-
-	rts.threshold = rts_threshold;
-
-	ret = wl12xx_cmd_configure(wl, &rts, sizeof(rts));
-	if (ret < 0) {
-		wl12xx_warning("failed to set rts threshold: %d", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_acx_beacon_filter_opt(struct wl12xx *wl)
-{
-	struct acx_beacon_filter_option beacon_filter;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx beacon filter opt");
-
-	beacon_filter.header.id = ACX_BEACON_FILTER_OPT;
-	beacon_filter.header.len = sizeof(beacon_filter) -
-		sizeof(struct acx_header);
-
-	beacon_filter.enable = 0;
-	beacon_filter.max_num_beacons = 0;
-
-	ret = wl12xx_cmd_configure(wl, &beacon_filter, sizeof(beacon_filter));
-	if (ret < 0) {
-		wl12xx_warning("failed to set beacon filter opt: %d", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_acx_beacon_filter_table(struct wl12xx *wl)
-{
-	struct acx_beacon_filter_ie_table ie_table;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx beacon filter table");
-
-	ie_table.header.id = ACX_BEACON_FILTER_TABLE;
-	ie_table.header.len = sizeof(ie_table) - sizeof(struct acx_header);
-
-	ie_table.num_ie = 0;
-	memset(ie_table.table, 0, BEACON_FILTER_TABLE_MAX_SIZE);
-
-	ret = wl12xx_cmd_configure(wl, &ie_table, sizeof(ie_table));
-	if (ret < 0) {
-		wl12xx_warning("failed to set beacon filter table: %d", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_acx_sg_enable(struct wl12xx *wl)
-{
-	struct acx_bt_wlan_coex pta;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx sg enable");
-
-	pta.header.id = ACX_SG_ENABLE;
-	pta.header.len = sizeof(pta) - sizeof(struct acx_header);
-
-	pta.enable = SG_ENABLE;
-
-	ret = wl12xx_cmd_configure(wl, &pta, sizeof(pta));
-	if (ret < 0) {
-		wl12xx_warning("failed to set softgemini enable: %d", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_acx_sg_cfg(struct wl12xx *wl)
-{
-	struct acx_bt_wlan_coex_param param;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx sg cfg");
-
-	/* BT-WLAN coext parameters */
-	param.header.id = ACX_SG_CFG;
-	param.header.len = sizeof(param) - sizeof(struct acx_header);
-
-	param.min_rate = RATE_INDEX_24MBPS;
-	param.bt_hp_max_time = PTA_BT_HP_MAXTIME_DEF;
-	param.wlan_hp_max_time = PTA_WLAN_HP_MAX_TIME_DEF;
-	param.sense_disable_timer = PTA_SENSE_DISABLE_TIMER_DEF;
-	param.rx_time_bt_hp = PTA_PROTECTIVE_RX_TIME_DEF;
-	param.tx_time_bt_hp = PTA_PROTECTIVE_TX_TIME_DEF;
-	param.rx_time_bt_hp_fast = PTA_PROTECTIVE_RX_TIME_FAST_DEF;
-	param.tx_time_bt_hp_fast = PTA_PROTECTIVE_TX_TIME_FAST_DEF;
-	param.wlan_cycle_fast = PTA_CYCLE_TIME_FAST_DEF;
-	param.bt_anti_starvation_period = PTA_ANTI_STARVE_PERIOD_DEF;
-	param.next_bt_lp_packet = PTA_TIMEOUT_NEXT_BT_LP_PACKET_DEF;
-	param.wake_up_beacon = PTA_TIME_BEFORE_BEACON_DEF;
-	param.hp_dm_max_guard_time = PTA_HPDM_MAX_TIME_DEF;
-	param.next_wlan_packet = PTA_TIME_OUT_NEXT_WLAN_DEF;
-	param.antenna_type = PTA_ANTENNA_TYPE_DEF;
-	param.signal_type = PTA_SIGNALING_TYPE_DEF;
-	param.afh_leverage_on = PTA_AFH_LEVERAGE_ON_DEF;
-	param.quiet_cycle_num = PTA_NUMBER_QUIET_CYCLE_DEF;
-	param.max_cts = PTA_MAX_NUM_CTS_DEF;
-	param.wlan_packets_num = PTA_NUMBER_OF_WLAN_PACKETS_DEF;
-	param.bt_packets_num = PTA_NUMBER_OF_BT_PACKETS_DEF;
-	param.missed_rx_avalanche = PTA_RX_FOR_AVALANCHE_DEF;
-	param.wlan_elp_hp = PTA_ELP_HP_DEF;
-	param.bt_anti_starvation_cycles = PTA_ANTI_STARVE_NUM_CYCLE_DEF;
-	param.ack_mode_dual_ant = PTA_ACK_MODE_DEF;
-	param.pa_sd_enable = PTA_ALLOW_PA_SD_DEF;
-	param.pta_auto_mode_enable = PTA_AUTO_MODE_NO_CTS_DEF;
-	param.bt_hp_respected_num = PTA_BT_HP_RESPECTED_DEF;
-
-	ret = wl12xx_cmd_configure(wl, &param, sizeof(param));
-	if (ret < 0) {
-		wl12xx_warning("failed to set sg config: %d", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_acx_cca_threshold(struct wl12xx *wl)
-{
-	struct acx_energy_detection detection;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx cca threshold");
-
-	detection.header.id = ACX_CCA_THRESHOLD;
-	detection.header.len = sizeof(detection) - sizeof(struct acx_header);
-
-	detection.rx_cca_threshold = CCA_THRSH_DISABLE_ENERGY_D;
-	detection.tx_energy_detection = 0;
-
-	ret = wl12xx_cmd_configure(wl, &detection, sizeof(detection));
-	if (ret < 0) {
-		wl12xx_warning("failed to set cca threshold: %d", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_acx_bcn_dtim_options(struct wl12xx *wl)
-{
-	struct acx_beacon_broadcast bb;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx bcn dtim options");
-
-	bb.header.id = ACX_BCN_DTIM_OPTIONS;
-	bb.header.len = sizeof(bb) - sizeof(struct acx_header);
-
-	bb.beacon_rx_timeout = BCN_RX_TIMEOUT_DEF_VALUE;
-	bb.broadcast_timeout = BROADCAST_RX_TIMEOUT_DEF_VALUE;
-	bb.rx_broadcast_in_ps = RX_BROADCAST_IN_PS_DEF_VALUE;
-	bb.ps_poll_threshold = CONSECUTIVE_PS_POLL_FAILURE_DEF;
-
-	ret = wl12xx_cmd_configure(wl, &bb, sizeof(bb));
-	if (ret < 0) {
-		wl12xx_warning("failed to set rx config: %d", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_acx_aid(struct wl12xx *wl, u16 aid)
-{
-	struct acx_aid acx_aid;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx aid");
-
-	acx_aid.header.id = ACX_AID;
-	acx_aid.header.len = sizeof(acx_aid) - sizeof(struct acx_header);
-
-	acx_aid.aid = aid;
-
-	ret = wl12xx_cmd_configure(wl, &acx_aid, sizeof(acx_aid));
-	if (ret < 0) {
-		wl12xx_warning("failed to set aid: %d", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_acx_event_mbox_mask(struct wl12xx *wl, u32 event_mask)
-{
-	struct acx_event_mask mask;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx event mbox mask");
-
-	mask.header.id = ACX_EVENT_MBOX_MASK;
-	mask.header.len = sizeof(mask) - sizeof(struct acx_header);
-
-	/* high event mask is unused */
-	mask.high_event_mask = 0xffffffff;
-
-	mask.event_mask = event_mask;
-
-	ret = wl12xx_cmd_configure(wl, &mask, sizeof(mask));
-	if (ret < 0) {
-		wl12xx_warning("failed to set aid: %d", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_acx_set_preamble(struct wl12xx *wl, enum acx_preamble_type preamble)
-{
-	struct acx_preamble ie;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx_set_preamble");
-
-	memset(&ie, 0, sizeof(ie));
-
-	ie.header.id = ACX_PREAMBLE_TYPE;
-	ie.header.len = sizeof(ie) - sizeof(struct acx_header);
-	ie.preamble = preamble;
-	ret = wl12xx_cmd_configure(wl, &ie, sizeof(ie));
-	if (ret < 0) {
-		wl12xx_warning("Setting of preamble failed: %d", ret);
-		return ret;
-	}
-	return 0;
-}
-
-int wl12xx_acx_cts_protect(struct wl12xx *wl,
-			   enum acx_ctsprotect_type ctsprotect)
-{
-	struct acx_ctsprotect ie;
-	int ret;
-
-	wl12xx_debug(DEBUG_ACX, "acx_set_ctsprotect");
-
-	memset(&ie, 0, sizeof(ie));
-
-	ie.header.id = ACX_CTS_PROTECTION;
-	ie.header.len = sizeof(ie) - sizeof(struct acx_header);
-	ie.ctsprotect = ctsprotect;
-	ret = wl12xx_cmd_configure(wl, &ie, sizeof(ie));
-	if (ret < 0) {
-		wl12xx_warning("Setting of ctsprotect failed: %d", ret);
-		return ret;
-	}
-	return 0;
-}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/acx.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/acx.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/acx.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/acx.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,1022 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (c) 1998-2007 Texas Instruments Incorporated
- * Copyright (C) 2008 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#ifndef __WL12XX_ACX_H__
-#define __WL12XX_ACX_H__
-
-#include "wl12xx.h"
-
-/* Target's information element */
-struct acx_header {
-	u16 id;
-	u16 len;
-};
-
-struct acx_error_counter {
-	struct acx_header header;
-
-	/* The number of PLCP errors since the last time this */
-	/* information element was interrogated. This field is */
-	/* automatically cleared when it is interrogated.*/
-	u32 PLCP_error;
-
-	/* The number of FCS errors since the last time this */
-	/* information element was interrogated. This field is */
-	/* automatically cleared when it is interrogated.*/
-	u32 FCS_error;
-
-	/* The number of MPDUs without PLCP header errors received*/
-	/* since the last time this information element was interrogated. */
-	/* This field is automatically cleared when it is interrogated.*/
-	u32 valid_frame;
-
-	/* the number of missed sequence numbers in the squentially */
-	/* values of frames seq numbers */
-	u32 seq_num_miss;
-} __attribute__ ((packed));
-
-struct acx_revision {
-	struct acx_header header;
-
-	/*
-	 * The WiLink firmware version, an ASCII string x.x.x.x,
-	 * that uniquely identifies the current firmware.
-	 * The left most digit is incremented each time a
-	 * significant change is made to the firmware, such as
-	 * code redesign or new platform support.
-	 * The second digit is incremented when major enhancements
-	 * are added or major fixes are made.
-	 * The third digit is incremented for each GA release.
-	 * The fourth digit is incremented for each build.
-	 * The first two digits identify a firmware release version,
-	 * in other words, a unique set of features.
-	 * The first three digits identify a GA release.
-	 */
-	char fw_version[20];
-
-	/*
-	 * This 4 byte field specifies the WiLink hardware version.
-	 * bits 0  - 15: Reserved.
-	 * bits 16 - 23: Version ID - The WiLink version ID
-	 *              (1 = first spin, 2 = second spin, and so on).
-	 * bits 24 - 31: Chip ID - The WiLink chip ID.
-	 */
-	u32 hw_version;
-} __attribute__ ((packed));
-
-enum wl12xx_psm_mode {
-	/* Active mode */
-	WL12XX_PSM_CAM = 0,
-
-	/* Power save mode */
-	WL12XX_PSM_PS = 1,
-
-	/* Extreme low power */
-	WL12XX_PSM_ELP = 2,
-};
-
-struct acx_sleep_auth {
-	struct acx_header header;
-
-	/* The sleep level authorization of the device. */
-	/* 0 - Always active*/
-	/* 1 - Power down mode: light / fast sleep*/
-	/* 2 - ELP mode: Deep / Max sleep*/
-	u8  sleep_auth;
-	u8  padding[3];
-} __attribute__ ((packed));
-
-#define TIM_ELE_ID    5
-#define PARTIAL_VBM_MAX    251
-
-struct tim {
-	u8 identity;
-	u8 length;
-	u8 dtim_count;
-	u8 dtim_period;
-	u8 bitmap_ctrl;
-	u8 pvb_field[PARTIAL_VBM_MAX]; /* Partial Virtual Bitmap */
-} __attribute__ ((packed));
-
-/* Virtual Bit Map update */
-struct vbm_update_request {
-	__le16 len;
-	u8  padding[2];
-	struct tim tim;
-} __attribute__ ((packed));
-
-enum {
-	HOSTIF_PCI_MASTER_HOST_INDIRECT,
-	HOSTIF_PCI_MASTER_HOST_DIRECT,
-	HOSTIF_SLAVE,
-	HOSTIF_PKT_RING,
-	HOSTIF_DONTCARE = 0xFF
-};
-
-#define DEFAULT_UCAST_PRIORITY          0
-#define DEFAULT_RX_Q_PRIORITY           0
-#define DEFAULT_NUM_STATIONS            1
-#define DEFAULT_RXQ_PRIORITY            0 /* low 0 .. 15 high  */
-#define DEFAULT_RXQ_TYPE                0x07    /* All frames, Data/Ctrl/Mgmt */
-#define TRACE_BUFFER_MAX_SIZE           256
-
-#define  DP_RX_PACKET_RING_CHUNK_SIZE 1600
-#define  DP_TX_PACKET_RING_CHUNK_SIZE 1600
-#define  DP_RX_PACKET_RING_CHUNK_NUM 2
-#define  DP_TX_PACKET_RING_CHUNK_NUM 2
-#define  DP_TX_COMPLETE_TIME_OUT 20
-#define  FW_TX_CMPLT_BLOCK_SIZE 16
-
-struct acx_data_path_params {
-	struct acx_header header;
-
-	u16 rx_packet_ring_chunk_size;
-	u16 tx_packet_ring_chunk_size;
-
-	u8 rx_packet_ring_chunk_num;
-	u8 tx_packet_ring_chunk_num;
-
-	/*
-	 * Maximum number of packets that can be gathered
-	 * in the TX complete ring before an interrupt
-	 * is generated.
-	 */
-	u8 tx_complete_threshold;
-
-	/* Number of pending TX complete entries in cyclic ring.*/
-	u8 tx_complete_ring_depth;
-
-	/*
-	 * Max num microseconds since a packet enters the TX
-	 * complete ring until an interrupt is generated.
-	 */
-	u32 tx_complete_timeout;
-} __attribute__ ((packed));
-
-
-struct acx_data_path_params_resp {
-	struct acx_header header;
-
-	u16 rx_packet_ring_chunk_size;
-	u16 tx_packet_ring_chunk_size;
-
-	u8 rx_packet_ring_chunk_num;
-	u8 tx_packet_ring_chunk_num;
-
-	u8 pad[2];
-
-	u32 rx_packet_ring_addr;
-	u32 tx_packet_ring_addr;
-
-	u32 rx_control_addr;
-	u32 tx_control_addr;
-
-	u32 tx_complete_addr;
-} __attribute__ ((packed));
-
-#define TX_MSDU_LIFETIME_MIN       0
-#define TX_MSDU_LIFETIME_MAX       3000
-#define TX_MSDU_LIFETIME_DEF       512
-#define RX_MSDU_LIFETIME_MIN       0
-#define RX_MSDU_LIFETIME_MAX       0xFFFFFFFF
-#define RX_MSDU_LIFETIME_DEF       512000
-
-struct rx_msdu_lifetime {
-	struct acx_header header;
-
-	/*
-	 * The maximum amount of time, in TU, before the
-	 * firmware discards the MSDU.
-	 */
-	u32 lifetime;
-} __attribute__ ((packed));
-
-/*
- * RX Config Options Table
- * Bit		Definition
- * ===		==========
- * 31:14		Reserved
- * 13		Copy RX Status - when set, write three receive status words
- * 	 	to top of rx'd MPDUs.
- * 		When cleared, do not write three status words (added rev 1.5)
- * 12		Reserved
- * 11		RX Complete upon FCS error - when set, give rx complete
- *	 	interrupt for FCS errors, after the rx filtering, e.g. unicast
- *	 	frames not to us with FCS error will not generate an interrupt.
- * 10		SSID Filter Enable - When set, the WiLink discards all beacon,
- *	        probe request, and probe response frames with an SSID that does
- *		not match the SSID specified by the host in the START/JOIN
- *		command.
- *		When clear, the WiLink receives frames with any SSID.
- * 9		Broadcast Filter Enable - When set, the WiLink discards all
- * 	 	broadcast frames. When clear, the WiLink receives all received
- *		broadcast frames.
- * 8:6		Reserved
- * 5		BSSID Filter Enable - When set, the WiLink discards any frames
- * 	 	with a BSSID that does not match the BSSID specified by the
- *		host.
- *		When clear, the WiLink receives frames from any BSSID.
- * 4		MAC Addr Filter - When set, the WiLink discards any frames
- * 	 	with a destination address that does not match the MAC address
- *		of the adaptor.
- *		When clear, the WiLink receives frames destined to any MAC
- *		address.
- * 3		Promiscuous - When set, the WiLink receives all valid frames
- * 	 	(i.e., all frames that pass the FCS check).
- *		When clear, only frames that pass the other filters specified
- *		are received.
- * 2		FCS - When set, the WiLink includes the FCS with the received
- *	 	frame.
- *		When cleared, the FCS is discarded.
- * 1		PLCP header - When set, write all data from baseband to frame
- * 	 	buffer including PHY header.
- * 0		Reserved - Always equal to 0.
- *
- * RX Filter Options Table
- * Bit		Definition
- * ===		==========
- * 31:12		Reserved - Always equal to 0.
- * 11		Association - When set, the WiLink receives all association
- * 	 	related frames (association request/response, reassocation
- *		request/response, and disassociation). When clear, these frames
- *		are discarded.
- * 10		Auth/De auth - When set, the WiLink receives all authentication
- * 	 	and de-authentication frames. When clear, these frames are
- *		discarded.
- * 9		Beacon - When set, the WiLink receives all beacon frames.
- * 	 	When clear, these frames are discarded.
- * 8		Contention Free - When set, the WiLink receives all contention
- * 	 	free frames.
- *		When clear, these frames are discarded.
- * 7		Control - When set, the WiLink receives all control frames.
- * 	 	When clear, these frames are discarded.
- * 6		Data - When set, the WiLink receives all data frames.
- * 	 	When clear, these frames are discarded.
- * 5		FCS Error - When set, the WiLink receives frames that have FCS
- *	 	errors.
- *		When clear, these frames are discarded.
- * 4		Management - When set, the WiLink receives all management
- *		frames.
- * 	 	When clear, these frames are discarded.
- * 3		Probe Request - When set, the WiLink receives all probe request
- * 	 	frames.
- *		When clear, these frames are discarded.
- * 2		Probe Response - When set, the WiLink receives all probe
- * 		response frames.
- *		When clear, these frames are discarded.
- * 1		RTS/CTS/ACK - When set, the WiLink receives all RTS, CTS and ACK
- * 	 	frames.
- *		When clear, these frames are discarded.
- * 0		Rsvd Type/Sub Type - When set, the WiLink receives all frames
- * 	 	that have reserved frame types and sub types as defined by the
- *		802.11 specification.
- *		When clear, these frames are discarded.
- */
-struct acx_rx_config {
-	struct acx_header header;
-
-	u32 config_options;
-	u32 filter_options;
-} __attribute__ ((packed));
-
-enum {
-	QOS_AC_BE = 0,
-	QOS_AC_BK,
-	QOS_AC_VI,
-	QOS_AC_VO,
-	QOS_HIGHEST_AC_INDEX = QOS_AC_VO,
-};
-
-#define MAX_NUM_OF_AC             (QOS_HIGHEST_AC_INDEX+1)
-#define FIRST_AC_INDEX            QOS_AC_BE
-#define MAX_NUM_OF_802_1d_TAGS    8
-#define AC_PARAMS_MAX_TSID        15
-#define MAX_APSD_CONF             0xffff
-
-#define  QOS_TX_HIGH_MIN      (0)
-#define  QOS_TX_HIGH_MAX      (100)
-
-#define  QOS_TX_HIGH_BK_DEF   (25)
-#define  QOS_TX_HIGH_BE_DEF   (35)
-#define  QOS_TX_HIGH_VI_DEF   (35)
-#define  QOS_TX_HIGH_VO_DEF   (35)
-
-#define  QOS_TX_LOW_BK_DEF    (15)
-#define  QOS_TX_LOW_BE_DEF    (25)
-#define  QOS_TX_LOW_VI_DEF    (25)
-#define  QOS_TX_LOW_VO_DEF    (25)
-
-struct acx_tx_queue_qos_config {
-	struct acx_header header;
-
-	u8 qid;
-	u8 pad[3];
-
-	/* Max number of blocks allowd in the queue */
-	u16 high_threshold;
-
-	/* Lowest memory blocks guaranteed for this queue */
-	u16 low_threshold;
-} __attribute__ ((packed));
-
-struct acx_packet_detection {
-	struct acx_header header;
-
-	u32 threshold;
-} __attribute__ ((packed));
-
-
-enum acx_slot_type {
-	SLOT_TIME_LONG = 0,
-	SLOT_TIME_SHORT = 1,
-	DEFAULT_SLOT_TIME = SLOT_TIME_SHORT,
-	MAX_SLOT_TIMES = 0xFF
-};
-
-#define STATION_WONE_INDEX 0
-
-struct acx_slot {
-	struct acx_header header;
-
-	u8 wone_index; /* Reserved */
-	u8 slot_time;
-	u8 reserved[6];
-} __attribute__ ((packed));
-
-
-#define ADDRESS_GROUP_MAX	(8)
-#define ADDRESS_GROUP_MAX_LEN	(ETH_ALEN * ADDRESS_GROUP_MAX)
-
-struct multicast_grp_addr_start {
-	struct acx_header header;
-
-	u8 enabled;
-	u8 num_groups;
-	u8 pad[2];
-	u8 mac_table[ADDRESS_GROUP_MAX_LEN];
-} __attribute__ ((packed));
-
-
-#define  RX_TIMEOUT_PS_POLL_MIN    0
-#define  RX_TIMEOUT_PS_POLL_MAX    (200000)
-#define  RX_TIMEOUT_PS_POLL_DEF    (15)
-#define  RX_TIMEOUT_UPSD_MIN       0
-#define  RX_TIMEOUT_UPSD_MAX       (200000)
-#define  RX_TIMEOUT_UPSD_DEF       (15)
-
-struct acx_rx_timeout {
-	struct acx_header header;
-
-	/*
-	 * The longest time the STA will wait to receive
-	 * traffic from the AP after a PS-poll has been
-	 * transmitted.
-	 */
-	u16 ps_poll_timeout;
-
-	/*
-	 * The longest time the STA will wait to receive
-	 * traffic from the AP after a frame has been sent
-	 * from an UPSD enabled queue.
-	 */
-	u16 upsd_timeout;
-} __attribute__ ((packed));
-
-#define RTS_THRESHOLD_MIN              0
-#define RTS_THRESHOLD_MAX              4096
-#define RTS_THRESHOLD_DEF              2347
-
-struct acx_rts_threshold {
-	struct acx_header header;
-
-	u16 threshold;
-	u8 pad[2];
-} __attribute__ ((packed));
-
-struct acx_beacon_filter_option {
-	struct acx_header header;
-
-	u8 enable;
-
-	/*
-	 * The number of beacons without the unicast TIM
-	 * bit set that the firmware buffers before
-	 * signaling the host about ready frames.
-	 * When set to 0 and the filter is enabled, beacons
-	 * without the unicast TIM bit set are dropped.
-	 */
-	u8 max_num_beacons;
-	u8 pad[2];
-} __attribute__ ((packed));
-
-/*
- * ACXBeaconFilterEntry (not 221)
- * Byte Offset     Size (Bytes)    Definition
- * ===========     ============    ==========
- * 0				1               IE identifier
- * 1               1               Treatment bit mask
- *
- * ACXBeaconFilterEntry (221)
- * Byte Offset     Size (Bytes)    Definition
- * ===========     ============    ==========
- * 0               1               IE identifier
- * 1               1               Treatment bit mask
- * 2               3               OUI
- * 5               1               Type
- * 6               2               Version
- *
- *
- * Treatment bit mask - The information element handling:
- * bit 0 - The information element is compared and transferred
- * in case of change.
- * bit 1 - The information element is transferred to the host
- * with each appearance or disappearance.
- * Note that both bits can be set at the same time.
- */
-#define	BEACON_FILTER_TABLE_MAX_IE_NUM		       (32)
-#define BEACON_FILTER_TABLE_MAX_VENDOR_SPECIFIC_IE_NUM (6)
-#define BEACON_FILTER_TABLE_IE_ENTRY_SIZE	       (2)
-#define BEACON_FILTER_TABLE_EXTRA_VENDOR_SPECIFIC_IE_SIZE (6)
-#define BEACON_FILTER_TABLE_MAX_SIZE ((BEACON_FILTER_TABLE_MAX_IE_NUM * \
-			    BEACON_FILTER_TABLE_IE_ENTRY_SIZE) + \
-			   (BEACON_FILTER_TABLE_MAX_VENDOR_SPECIFIC_IE_NUM * \
-			    BEACON_FILTER_TABLE_EXTRA_VENDOR_SPECIFIC_IE_SIZE))
-
-struct acx_beacon_filter_ie_table {
-	struct acx_header header;
-
-	u8 num_ie;
-	u8 table[BEACON_FILTER_TABLE_MAX_SIZE];
-	u8 pad[3];
-} __attribute__ ((packed));
-
-enum {
-	SG_ENABLE = 0,
-	SG_DISABLE,
-	SG_SENSE_NO_ACTIVITY,
-	SG_SENSE_ACTIVE
-};
-
-struct acx_bt_wlan_coex {
-	struct acx_header header;
-
-	/*
-	 * 0 -> PTA enabled
-	 * 1 -> PTA disabled
-	 * 2 -> sense no active mode, i.e.
-	 *      an interrupt is sent upon
-	 *      BT activity.
-	 * 3 -> PTA is switched on in response
-	 *      to the interrupt sending.
-	 */
-	u8 enable;
-	u8 pad[3];
-} __attribute__ ((packed));
-
-#define PTA_ANTENNA_TYPE_DEF		  (0)
-#define PTA_BT_HP_MAXTIME_DEF		  (2000)
-#define PTA_WLAN_HP_MAX_TIME_DEF	  (5000)
-#define PTA_SENSE_DISABLE_TIMER_DEF	  (1350)
-#define PTA_PROTECTIVE_RX_TIME_DEF	  (1500)
-#define PTA_PROTECTIVE_TX_TIME_DEF	  (1500)
-#define PTA_TIMEOUT_NEXT_BT_LP_PACKET_DEF (3000)
-#define PTA_SIGNALING_TYPE_DEF		  (1)
-#define PTA_AFH_LEVERAGE_ON_DEF		  (0)
-#define PTA_NUMBER_QUIET_CYCLE_DEF	  (0)
-#define PTA_MAX_NUM_CTS_DEF		  (3)
-#define PTA_NUMBER_OF_WLAN_PACKETS_DEF	  (2)
-#define PTA_NUMBER_OF_BT_PACKETS_DEF	  (2)
-#define PTA_PROTECTIVE_RX_TIME_FAST_DEF	  (1500)
-#define PTA_PROTECTIVE_TX_TIME_FAST_DEF	  (3000)
-#define PTA_CYCLE_TIME_FAST_DEF		  (8700)
-#define PTA_RX_FOR_AVALANCHE_DEF	  (5)
-#define PTA_ELP_HP_DEF			  (0)
-#define PTA_ANTI_STARVE_PERIOD_DEF	  (500)
-#define PTA_ANTI_STARVE_NUM_CYCLE_DEF	  (4)
-#define PTA_ALLOW_PA_SD_DEF		  (1)
-#define PTA_TIME_BEFORE_BEACON_DEF	  (6300)
-#define PTA_HPDM_MAX_TIME_DEF		  (1600)
-#define PTA_TIME_OUT_NEXT_WLAN_DEF	  (2550)
-#define PTA_AUTO_MODE_NO_CTS_DEF	  (0)
-#define PTA_BT_HP_RESPECTED_DEF		  (3)
-#define PTA_WLAN_RX_MIN_RATE_DEF	  (24)
-#define PTA_ACK_MODE_DEF		  (1)
-
-struct acx_bt_wlan_coex_param {
-	struct acx_header header;
-
-	/*
-	 * The minimum rate of a received WLAN packet in the STA,
-	 * during protective mode, of which a new BT-HP request
-	 * during this Rx will always be respected and gain the antenna.
-	 */
-	u32 min_rate;
-
-	/* Max time the BT HP will be respected. */
-	u16 bt_hp_max_time;
-
-	/* Max time the WLAN HP will be respected. */
-	u16 wlan_hp_max_time;
-
-	/*
-	 * The time between the last BT activity
-	 * and the moment when the sense mode returns
-	 * to SENSE_INACTIVE.
-	 */
-	u16 sense_disable_timer;
-
-	/* Time before the next BT HP instance */
-	u16 rx_time_bt_hp;
-	u16 tx_time_bt_hp;
-
-	/* range: 10-20000    default: 1500 */
-	u16 rx_time_bt_hp_fast;
-	u16 tx_time_bt_hp_fast;
-
-	/* range: 2000-65535  default: 8700 */
-	u16 wlan_cycle_fast;
-
-	/* range: 0 - 15000 (Msec) default: 1000 */
-	u16 bt_anti_starvation_period;
-
-	/* range 400-10000(Usec) default: 3000 */
-	u16 next_bt_lp_packet;
-
-	/* Deafult: worst case for BT DH5 traffic */
-	u16 wake_up_beacon;
-
-	/* range: 0-50000(Usec) default: 1050 */
-	u16 hp_dm_max_guard_time;
-
-	/*
-	 * This is to prevent both BT & WLAN antenna
-	 * starvation.
-	 * Range: 100-50000(Usec) default:2550
-	 */
-	u16 next_wlan_packet;
-
-	/* 0 -> shared antenna */
-	u8 antenna_type;
-
-	/*
-	 * 0 -> TI legacy
-	 * 1 -> Palau
-	 */
-	u8 signal_type;
-
-	/*
-	 * BT AFH status
-	 * 0 -> no AFH
-	 * 1 -> from dedicated GPIO
-	 * 2 -> AFH on (from host)
-	 */
-	u8 afh_leverage_on;
-
-	/*
-	 * The number of cycles during which no
-	 * TX will be sent after 1 cycle of RX
-	 * transaction in protective mode
-	 */
-	u8 quiet_cycle_num;
-
-	/*
-	 * The maximum number of CTSs that will
-	 * be sent for receiving RX packet in
-	 * protective mode
-	 */
-	u8 max_cts;
-
-	/*
-	 * The number of WLAN packets
-	 * transferred in common mode before
-	 * switching to BT.
-	 */
-	u8 wlan_packets_num;
-
-	/*
-	 * The number of BT packets
-	 * transferred in common mode before
-	 * switching to WLAN.
-	 */
-	u8 bt_packets_num;
-
-	/* range: 1-255  default: 5 */
-	u8 missed_rx_avalanche;
-
-	/* range: 0-1    default: 1 */
-	u8 wlan_elp_hp;
-
-	/* range: 0 - 15  default: 4 */
-	u8 bt_anti_starvation_cycles;
-
-	u8 ack_mode_dual_ant;
-
-	/*
-	 * Allow PA_SD assertion/de-assertion
-	 * during enabled BT activity.
-	 */
-	u8 pa_sd_enable;
-
-	/*
-	 * Enable/Disable PTA in auto mode:
-	 * Support Both Active & P.S modes
-	 */
-	u8 pta_auto_mode_enable;
-
-	/* range: 0 - 20  default: 1 */
-	u8 bt_hp_respected_num;
-} __attribute__ ((packed));
-
-#define CCA_THRSH_ENABLE_ENERGY_D       0x140A
-#define CCA_THRSH_DISABLE_ENERGY_D      0xFFEF
-
-struct acx_energy_detection {
-	struct acx_header header;
-
-	/* The RX Clear Channel Assessment threshold in the PHY */
-	u16 rx_cca_threshold;
-	u8 tx_energy_detection;
-	u8 pad;
-} __attribute__ ((packed));
-
-#define BCN_RX_TIMEOUT_DEF_VALUE        10000
-#define BROADCAST_RX_TIMEOUT_DEF_VALUE  20000
-#define RX_BROADCAST_IN_PS_DEF_VALUE    1
-#define CONSECUTIVE_PS_POLL_FAILURE_DEF 4
-
-struct acx_beacon_broadcast {
-	struct acx_header header;
-
-	u16 beacon_rx_timeout;
-	u16 broadcast_timeout;
-
-	/* Enables receiving of broadcast packets in PS mode */
-	u8 rx_broadcast_in_ps;
-
-	/* Consecutive PS Poll failures before updating the host */
-	u8 ps_poll_threshold;
-	u8 pad[2];
-} __attribute__ ((packed));
-
-struct acx_event_mask {
-	struct acx_header header;
-
-	u32 event_mask;
-	u32 high_event_mask; /* Unused */
-} __attribute__ ((packed));
-
-#define CFG_RX_FCS		BIT(2)
-#define CFG_RX_ALL_GOOD		BIT(3)
-#define CFG_UNI_FILTER_EN	BIT(4)
-#define CFG_BSSID_FILTER_EN	BIT(5)
-#define CFG_MC_FILTER_EN	BIT(6)
-#define CFG_MC_ADDR0_EN		BIT(7)
-#define CFG_MC_ADDR1_EN		BIT(8)
-#define CFG_BC_REJECT_EN	BIT(9)
-#define CFG_SSID_FILTER_EN	BIT(10)
-#define CFG_RX_INT_FCS_ERROR	BIT(11)
-#define CFG_RX_INT_ENCRYPTED	BIT(12)
-#define CFG_RX_WR_RX_STATUS	BIT(13)
-#define CFG_RX_FILTER_NULTI	BIT(14)
-#define CFG_RX_RESERVE		BIT(15)
-#define CFG_RX_TIMESTAMP_TSF	BIT(16)
-
-#define CFG_RX_RSV_EN		BIT(0)
-#define CFG_RX_RCTS_ACK		BIT(1)
-#define CFG_RX_PRSP_EN		BIT(2)
-#define CFG_RX_PREQ_EN		BIT(3)
-#define CFG_RX_MGMT_EN		BIT(4)
-#define CFG_RX_FCS_ERROR	BIT(5)
-#define CFG_RX_DATA_EN		BIT(6)
-#define CFG_RX_CTL_EN		BIT(7)
-#define CFG_RX_CF_EN		BIT(8)
-#define CFG_RX_BCN_EN		BIT(9)
-#define CFG_RX_AUTH_EN		BIT(10)
-#define CFG_RX_ASSOC_EN		BIT(11)
-
-#define SCAN_PASSIVE		BIT(0)
-#define SCAN_5GHZ_BAND		BIT(1)
-#define SCAN_TRIGGERED		BIT(2)
-#define SCAN_PRIORITY_HIGH	BIT(3)
-
-struct acx_fw_gen_frame_rates {
-	struct acx_header header;
-
-	u8 tx_ctrl_frame_rate; /* RATE_* */
-	u8 tx_ctrl_frame_mod; /* CCK_* or PBCC_* */
-	u8 tx_mgt_frame_rate;
-	u8 tx_mgt_frame_mod;
-} __attribute__ ((packed));
-
-/* STA MAC */
-struct dot11_station_id {
-	struct acx_header header;
-
-	u8 mac[ETH_ALEN];
-	u8 pad[2];
-} __attribute__ ((packed));
-
-/* HW encryption keys */
-#define NUM_ACCESS_CATEGORIES_COPY 4
-#define MAX_KEY_SIZE 32
-
-/* When set, disable HW encryption */
-#define DF_ENCRYPTION_DISABLE      0x01
-/* When set, disable HW decryption */
-#define DF_SNIFF_MODE_ENABLE       0x80
-
-struct acx_feature_config {
-	struct acx_header header;
-
-	u32 options;
-	u32 data_flow_options;
-} __attribute__ ((packed));
-
-enum acx_key_action {
-	KEY_ADD_OR_REPLACE = 1,
-	KEY_REMOVE         = 2,
-	KEY_SET_ID         = 3,
-	MAX_KEY_ACTION     = 0xffff,
-};
-
-enum acx_key_type {
-	KEY_WEP_DEFAULT       = 0,
-	KEY_WEP_ADDR          = 1,
-	KEY_AES_GROUP         = 4,
-	KEY_AES_PAIRWISE      = 5,
-	KEY_WEP_GROUP         = 6,
-	KEY_TKIP_MIC_GROUP    = 10,
-	KEY_TKIP_MIC_PAIRWISE = 11,
-};
-
-/*
- *
- * key_type_e   key size    key format
- * ----------   ---------   ----------
- * 0x00         5, 13, 29   Key data
- * 0x01         5, 13, 29   Key data
- * 0x04         16          16 bytes of key data
- * 0x05         16          16 bytes of key data
- * 0x0a         32          16 bytes of TKIP key data
- *                          8 bytes of RX MIC key data
- *                          8 bytes of TX MIC key data
- * 0x0b         32          16 bytes of TKIP key data
- *                          8 bytes of RX MIC key data
- *                          8 bytes of TX MIC key data
- *
- */
-
-struct acx_set_key {
-	/* Ignored for default WEP key */
-	u8 addr[ETH_ALEN];
-
-	/* key_action_e */
-	u16 key_action;
-
-	u16 reserved_1;
-
-	/* key size in bytes */
-	u8 key_size;
-
-	/* key_type_e */
-	u8 key_type;
-	u8 ssid_profile;
-
-	/*
-	 * TKIP, AES: frame's key id field.
-	 * For WEP default key: key id;
-	 */
-	u8 id;
-	u8 reserved_2[6];
-	u8 key[MAX_KEY_SIZE];
-	u16 ac_seq_num16[NUM_ACCESS_CATEGORIES_COPY];
-	u32 ac_seq_num32[NUM_ACCESS_CATEGORIES_COPY];
-} __attribute__ ((packed));
-
-struct acx_current_tx_power {
-	struct acx_header header;
-
-	u8  current_tx_power;
-	u8  padding[3];
-} __attribute__ ((packed));
-
-struct acx_dot11_default_key {
-	struct acx_header header;
-
-	u8 id;
-	u8 pad[3];
-} __attribute__ ((packed));
-
-struct acx_tsf_info {
-	struct acx_header header;
-
-	u32 current_tsf_msb;
-	u32 current_tsf_lsb;
-	u32 last_TBTT_msb;
-	u32 last_TBTT_lsb;
-	u8 last_dtim_count;
-	u8 pad[3];
-} __attribute__ ((packed));
-
-/* 802.11 PS */
-enum acx_ps_mode {
-	STATION_ACTIVE_MODE,
-	STATION_POWER_SAVE_MODE
-};
-
-struct acx_ps_params {
-	u8 ps_mode; /* STATION_* */
-	u8 send_null_data; /* Do we have to send NULL data packet ? */
-	u8 retries; /* Number of retires for the initial NULL data packet */
-
-	 /*
-	  * TUs during which the target stays awake after switching
-	  * to power save mode.
-	  */
-	u8 hang_over_period;
-	u16 null_data_rate;
-	u8 pad[2];
-} __attribute__ ((packed));
-
-enum acx_wake_up_event {
-	WAKE_UP_EVENT_BEACON_BITMAP	= 0x01, /* Wake on every Beacon*/
-	WAKE_UP_EVENT_DTIM_BITMAP	= 0x02,	/* Wake on every DTIM*/
-	WAKE_UP_EVENT_N_DTIM_BITMAP	= 0x04, /* Wake on every Nth DTIM */
-	WAKE_UP_EVENT_N_BEACONS_BITMAP	= 0x08, /* Wake on every Nth Beacon */
-	WAKE_UP_EVENT_BITS_MASK		= 0x0F
-};
-
-struct acx_wake_up_condition {
-	struct acx_header header;
-
-	u8 wake_up_event; /* Only one bit can be set */
-	u8 listen_interval;
-	u8 pad[2];
-} __attribute__ ((packed));
-
-struct acx_aid {
-	struct acx_header header;
-
-	/*
-	 * To be set when associated with an AP.
-	 */
-	u16 aid;
-	u8 pad[2];
-} __attribute__ ((packed));
-
-enum acx_preamble_type {
-	ACX_PREAMBLE_LONG = 0,
-	ACX_PREAMBLE_SHORT = 1
-};
-
-struct acx_preamble {
-	struct acx_header header;
-	/*
-	 * When set, the WiLink transmits the frames with a short preamble and
-	 * when cleared, the WiLink transmits the frames with a long preamble.
-	 */
-	u8 preamble;
-	u8 padding[3];
-} __attribute__ ((packed));
-
-enum acx_ctsprotect_type {
-	CTSPROTECT_DISABLE = 0,
-	CTSPROTECT_ENABLE = 1
-};
-
-struct acx_ctsprotect {
-	struct acx_header header;
-	u8 ctsprotect;
-	u8 padding[3];
-} __attribute__ ((packed));
-
-enum {
-	ACX_WAKE_UP_CONDITIONS      = 0x0002,
-	ACX_MEM_CFG                 = 0x0003,
-	ACX_SLOT                    = 0x0004,
-	ACX_QUEUE_HEAD              = 0x0005, /* for MASTER mode only */
-	ACX_AC_CFG                  = 0x0007,
-	ACX_MEM_MAP                 = 0x0008,
-	ACX_AID                     = 0x000A,
-	ACX_RADIO_PARAM             = 0x000B, /* Not used */
-	ACX_CFG                     = 0x000C, /* Not used */
-	ACX_FW_REV                  = 0x000D,
-	ACX_MEDIUM_USAGE            = 0x000F,
-	ACX_RX_CFG                  = 0x0010,
-	ACX_TX_QUEUE_CFG            = 0x0011, /* FIXME: only used by wl1251 */
-	ACX_BSS_IN_PS               = 0x0012, /* for AP only */
-	ACX_STATISTICS              = 0x0013, /* Debug API */
-	ACX_FEATURE_CFG             = 0x0015,
-	ACX_MISC_CFG                = 0x0017, /* Not used */
-	ACX_TID_CFG                 = 0x001A,
-	ACX_BEACON_FILTER_OPT       = 0x001F,
-	ACX_LOW_RSSI                = 0x0020,
-	ACX_NOISE_HIST              = 0x0021,
-	ACX_HDK_VERSION             = 0x0022, /* ??? */
-	ACX_PD_THRESHOLD            = 0x0023,
-	ACX_DATA_PATH_PARAMS        = 0x0024, /* WO */
-	ACX_DATA_PATH_RESP_PARAMS   = 0x0024, /* RO */
-	ACX_CCA_THRESHOLD           = 0x0025,
-	ACX_EVENT_MBOX_MASK         = 0x0026,
-#ifdef FW_RUNNING_AS_AP
-	ACX_DTIM_PERIOD             = 0x0027, /* for AP only */
-#else
-	ACX_WR_TBTT_AND_DTIM        = 0x0027, /* STA only */
-#endif
-	ACX_ACI_OPTION_CFG          = 0x0029, /* OBSOLETE (for 1251)*/
-	ACX_GPIO_CFG                = 0x002A, /* Not used */
-	ACX_GPIO_SET                = 0x002B, /* Not used */
-	ACX_PM_CFG                  = 0x002C, /* To Be Documented */
-	ACX_CONN_MONIT_PARAMS       = 0x002D,
-	ACX_AVERAGE_RSSI            = 0x002E, /* Not used */
-	ACX_CONS_TX_FAILURE         = 0x002F,
-	ACX_BCN_DTIM_OPTIONS        = 0x0031,
-	ACX_SG_ENABLE               = 0x0032,
-	ACX_SG_CFG                  = 0x0033,
-	ACX_ANTENNA_DIVERSITY_CFG   = 0x0035, /* To Be Documented */
-	ACX_LOW_SNR		    = 0x0037, /* To Be Documented */
-	ACX_BEACON_FILTER_TABLE     = 0x0038,
-	ACX_ARP_IP_FILTER           = 0x0039,
-	ACX_ROAMING_STATISTICS_TBL  = 0x003B,
-	ACX_RATE_POLICY             = 0x003D,
-	ACX_CTS_PROTECTION          = 0x003E,
-	ACX_SLEEP_AUTH              = 0x003F,
-	ACX_PREAMBLE_TYPE	    = 0x0040,
-	ACX_ERROR_CNT               = 0x0041,
-	ACX_FW_GEN_FRAME_RATES      = 0x0042,
-	ACX_IBSS_FILTER		    = 0x0044,
-	ACX_SERVICE_PERIOD_TIMEOUT  = 0x0045,
-	ACX_TSF_INFO                = 0x0046,
-	ACX_CONFIG_PS_WMM           = 0x0049,
-	ACX_ENABLE_RX_DATA_FILTER   = 0x004A,
-	ACX_SET_RX_DATA_FILTER      = 0x004B,
-	ACX_GET_DATA_FILTER_STATISTICS = 0x004C,
-	ACX_POWER_LEVEL_TABLE       = 0x004D,
-	ACX_BET_ENABLE              = 0x0050,
-	DOT11_STATION_ID            = 0x1001,
-	DOT11_RX_MSDU_LIFE_TIME     = 0x1004,
-	DOT11_CUR_TX_PWR            = 0x100D,
-	DOT11_DEFAULT_KEY           = 0x1010,
-	DOT11_RX_DOT11_MODE         = 0x1012,
-	DOT11_RTS_THRESHOLD         = 0x1013,
-	DOT11_GROUP_ADDRESS_TBL     = 0x1014,
-
-	MAX_DOT11_IE = DOT11_GROUP_ADDRESS_TBL,
-
-	MAX_IE = 0xFFFF
-};
-
-
-int wl12xx_acx_frame_rates(struct wl12xx *wl, u8 ctrl_rate, u8 ctrl_mod,
-			   u8 mgt_rate, u8 mgt_mod);
-int wl12xx_acx_station_id(struct wl12xx *wl);
-int wl12xx_acx_default_key(struct wl12xx *wl, u8 key_id);
-int wl12xx_acx_wake_up_conditions(struct wl12xx *wl, u8 listen_interval);
-int wl12xx_acx_sleep_auth(struct wl12xx *wl, u8 sleep_auth);
-int wl12xx_acx_fw_version(struct wl12xx *wl, char *buf, size_t len);
-int wl12xx_acx_tx_power(struct wl12xx *wl, int power);
-int wl12xx_acx_feature_cfg(struct wl12xx *wl);
-int wl12xx_acx_mem_map(struct wl12xx *wl, void *mem_map, size_t len);
-int wl12xx_acx_data_path_params(struct wl12xx *wl,
-				struct acx_data_path_params_resp *data_path);
-int wl12xx_acx_rx_msdu_life_time(struct wl12xx *wl, u32 life_time);
-int wl12xx_acx_rx_config(struct wl12xx *wl, u32 config, u32 filter);
-int wl12xx_acx_pd_threshold(struct wl12xx *wl);
-int wl12xx_acx_slot(struct wl12xx *wl, enum acx_slot_type slot_time);
-int wl12xx_acx_group_address_tbl(struct wl12xx *wl);
-int wl12xx_acx_service_period_timeout(struct wl12xx *wl);
-int wl12xx_acx_rts_threshold(struct wl12xx *wl, u16 rts_threshold);
-int wl12xx_acx_beacon_filter_opt(struct wl12xx *wl);
-int wl12xx_acx_beacon_filter_table(struct wl12xx *wl);
-int wl12xx_acx_sg_enable(struct wl12xx *wl);
-int wl12xx_acx_sg_cfg(struct wl12xx *wl);
-int wl12xx_acx_cca_threshold(struct wl12xx *wl);
-int wl12xx_acx_bcn_dtim_options(struct wl12xx *wl);
-int wl12xx_acx_aid(struct wl12xx *wl, u16 aid);
-int wl12xx_acx_event_mbox_mask(struct wl12xx *wl, u32 event_mask);
-int wl12xx_acx_set_preamble(struct wl12xx *wl, enum acx_preamble_type preamble);
-int wl12xx_acx_cts_protect(struct wl12xx *wl,
-			    enum acx_ctsprotect_type ctsprotect);
-
-#endif /* __WL12XX_ACX_H__ */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/boot.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/boot.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/boot.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/boot.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,295 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (C) 2008 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#include <linux/gpio.h>
-
-#include "reg.h"
-#include "boot.h"
-#include "spi.h"
-#include "event.h"
-
-static void wl12xx_boot_enable_interrupts(struct wl12xx *wl)
-{
-	enable_irq(wl->irq);
-}
-
-void wl12xx_boot_target_enable_interrupts(struct wl12xx *wl)
-{
-	wl12xx_reg_write32(wl, ACX_REG_INTERRUPT_MASK, ~(wl->intr_mask));
-	wl12xx_reg_write32(wl, HI_CFG, HI_CFG_DEF_VAL);
-}
-
-int wl12xx_boot_soft_reset(struct wl12xx *wl)
-{
-	unsigned long timeout;
-	u32 boot_data;
-
-	/* perform soft reset */
-	wl12xx_reg_write32(wl, ACX_REG_SLV_SOFT_RESET, ACX_SLV_SOFT_RESET_BIT);
-
-	/* SOFT_RESET is self clearing */
-	timeout = jiffies + usecs_to_jiffies(SOFT_RESET_MAX_TIME);
-	while (1) {
-		boot_data = wl12xx_reg_read32(wl, ACX_REG_SLV_SOFT_RESET);
-		wl12xx_debug(DEBUG_BOOT, "soft reset bootdata 0x%x", boot_data);
-		if ((boot_data & ACX_SLV_SOFT_RESET_BIT) == 0)
-			break;
-
-		if (time_after(jiffies, timeout)) {
-			/* 1.2 check pWhalBus->uSelfClearTime if the
-			 * timeout was reached */
-			wl12xx_error("soft reset timeout");
-			return -1;
-		}
-
-		udelay(SOFT_RESET_STALL_TIME);
-	}
-
-	/* disable Rx/Tx */
-	wl12xx_reg_write32(wl, ENABLE, 0x0);
-
-	/* disable auto calibration on start*/
-	wl12xx_reg_write32(wl, SPARE_A2, 0xffff);
-
-	return 0;
-}
-
-int wl12xx_boot_init_seq(struct wl12xx *wl)
-{
-	u32 scr_pad6, init_data, tmp, elp_cmd, ref_freq;
-
-	/*
-	 * col #1: INTEGER_DIVIDER
-	 * col #2: FRACTIONAL_DIVIDER
-	 * col #3: ATTN_BB
-	 * col #4: ALPHA_BB
-	 * col #5: STOP_TIME_BB
-	 * col #6: BB_PLL_LOOP_FILTER
-	 */
-	static const u32 LUT[REF_FREQ_NUM][LUT_PARAM_NUM] = {
-
-		{   83, 87381,  0xB, 5, 0xF00,  3}, /* REF_FREQ_19_2*/
-		{   61, 141154, 0xB, 5, 0x1450, 2}, /* REF_FREQ_26_0*/
-		{   41, 174763, 0xC, 6, 0x2D00, 1}, /* REF_FREQ_38_4*/
-		{   40, 0,      0xC, 6, 0x2EE0, 1}, /* REF_FREQ_40_0*/
-		{   47, 162280, 0xC, 6, 0x2760, 1}  /* REF_FREQ_33_6        */
-	};
-
-	/* read NVS params */
-	scr_pad6 = wl12xx_reg_read32(wl, SCR_PAD6);
-	wl12xx_debug(DEBUG_BOOT, "scr_pad6 0x%x", scr_pad6);
-
-	/* read ELP_CMD */
-	elp_cmd = wl12xx_reg_read32(wl, ELP_CMD);
-	wl12xx_debug(DEBUG_BOOT, "elp_cmd 0x%x", elp_cmd);
-
-	/* set the BB calibration time to be 300 usec (PLL_CAL_TIME) */
-	ref_freq = scr_pad6 & 0x000000FF;
-	wl12xx_debug(DEBUG_BOOT, "ref_freq 0x%x", ref_freq);
-
-	wl12xx_reg_write32(wl, PLL_CAL_TIME, 0x9);
-
-	/*
-	 * PG 1.2: set the clock buffer time to be 210 usec (CLK_BUF_TIME)
-	 */
-	wl12xx_reg_write32(wl, CLK_BUF_TIME, 0x6);
-
-	/*
-	 * set the clock detect feature to work in the restart wu procedure
-	 * (ELP_CFG_MODE[14]) and Select the clock source type
-	 * (ELP_CFG_MODE[13:12])
-	 */
-	tmp = ((scr_pad6 & 0x0000FF00) << 4) | 0x00004000;
-	wl12xx_reg_write32(wl, ELP_CFG_MODE, tmp);
-
-	/* PG 1.2: enable the BB PLL fix. Enable the PLL_LIMP_CLK_EN_CMD */
-	elp_cmd |= 0x00000040;
-	wl12xx_reg_write32(wl, ELP_CMD, elp_cmd);
-
-	/* PG 1.2: Set the BB PLL stable time to be 1000usec
-	 * (PLL_STABLE_TIME) */
-	wl12xx_reg_write32(wl, CFG_PLL_SYNC_CNT, 0x20);
-
-	/* PG 1.2: read clock request time */
-	init_data = wl12xx_reg_read32(wl, CLK_REQ_TIME);
-
-	/*
-	 * PG 1.2: set the clock request time to be ref_clk_settling_time -
-	 * 1ms = 4ms
-	 */
-	if (init_data > 0x21)
-		tmp = init_data - 0x21;
-	else
-		tmp = 0;
-	wl12xx_reg_write32(wl, CLK_REQ_TIME, tmp);
-
-	/* set BB PLL configurations in RF AFE */
-	wl12xx_reg_write32(wl, 0x003058cc, 0x4B5);
-
-	/* set RF_AFE_REG_5 */
-	wl12xx_reg_write32(wl, 0x003058d4, 0x50);
-
-	/* set RF_AFE_CTRL_REG_2 */
-	wl12xx_reg_write32(wl, 0x00305948, 0x11c001);
-
-	/*
-	 * change RF PLL and BB PLL divider for VCO clock and adjust VCO
-	 * bais current(RF_AFE_REG_13)
-	 */
-	wl12xx_reg_write32(wl, 0x003058f4, 0x1e);
-
-	/* set BB PLL configurations */
-	tmp = LUT[ref_freq][LUT_PARAM_INTEGER_DIVIDER] | 0x00017000;
-	wl12xx_reg_write32(wl, 0x00305840, tmp);
-
-	/* set fractional divider according to Appendix C-BB PLL
-	 * Calculations
-	 */
-	tmp = LUT[ref_freq][LUT_PARAM_FRACTIONAL_DIVIDER];
-	wl12xx_reg_write32(wl, 0x00305844, tmp);
-
-	/* set the initial data for the sigma delta */
-	wl12xx_reg_write32(wl, 0x00305848, 0x3039);
-
-	/*
-	 * set the accumulator attenuation value, calibration loop1
-	 * (alpha), calibration loop2 (beta), calibration loop3 (gamma) and
-	 * the VCO gain
-	 */
-	tmp = (LUT[ref_freq][LUT_PARAM_ATTN_BB] << 16) |
-		(LUT[ref_freq][LUT_PARAM_ALPHA_BB] << 12) | 0x1;
-	wl12xx_reg_write32(wl, 0x00305854, tmp);
-
-	/*
-	 * set the calibration stop time after holdoff time expires and set
-	 * settling time HOLD_OFF_TIME_BB
-	 */
-	tmp = LUT[ref_freq][LUT_PARAM_STOP_TIME_BB] | 0x000A0000;
-	wl12xx_reg_write32(wl, 0x00305858, tmp);
-
-	/*
-	 * set BB PLL Loop filter capacitor3- BB_C3[2:0] and set BB PLL
-	 * constant leakage current to linearize PFD to 0uA -
-	 * BB_ILOOPF[7:3]
-	 */
-	tmp = LUT[ref_freq][LUT_PARAM_BB_PLL_LOOP_FILTER] | 0x00000030;
-	wl12xx_reg_write32(wl, 0x003058f8, tmp);
-
-	/*
-	 * set regulator output voltage for n divider to
-	 * 1.35-BB_REFDIV[1:0], set charge pump current- BB_CPGAIN[4:2],
-	 * set BB PLL Loop filter capacitor2- BB_C2[7:5], set gain of BB
-	 * PLL auto-call to normal mode- BB_CALGAIN_3DB[8]
-	 */
-	wl12xx_reg_write32(wl, 0x003058f0, 0x29);
-
-	/* enable restart wakeup sequence (ELP_CMD[0]) */
-	wl12xx_reg_write32(wl, ELP_CMD, elp_cmd | 0x1);
-
-	/* restart sequence completed */
-	udelay(2000);
-
-	return 0;
-}
-
-int wl12xx_boot_run_firmware(struct wl12xx *wl)
-{
-	int loop, ret;
-	u32 chip_id, interrupt;
-
-	wl->chip.op_set_ecpu_ctrl(wl, ECPU_CONTROL_HALT);
-
-	chip_id = wl12xx_reg_read32(wl, CHIP_ID_B);
-
-	wl12xx_debug(DEBUG_BOOT, "chip id after firmware boot: 0x%x", chip_id);
-
-	if (chip_id != wl->chip.id) {
-		wl12xx_error("chip id doesn't match after firmware boot");
-		return -EIO;
-	}
-
-	/* wait for init to complete */
-	loop = 0;
-	while (loop++ < INIT_LOOP) {
-		udelay(INIT_LOOP_DELAY);
-		interrupt = wl12xx_reg_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);
-
-		if (interrupt == 0xffffffff) {
-			wl12xx_error("error reading hardware complete "
-				     "init indication");
-			return -EIO;
-		}
-		/* check that ACX_INTR_INIT_COMPLETE is enabled */
-		else if (interrupt & wl->chip.intr_init_complete) {
-			wl12xx_reg_write32(wl, ACX_REG_INTERRUPT_ACK,
-					   wl->chip.intr_init_complete);
-			break;
-		}
-	}
-
-	if (loop >= INIT_LOOP) {
-		wl12xx_error("timeout waiting for the hardware to "
-			     "complete initialization");
-		return -EIO;
-	}
-
-	/* get hardware config command mail box */
-	wl->cmd_box_addr = wl12xx_reg_read32(wl, REG_COMMAND_MAILBOX_PTR);
-
-	/* get hardware config event mail box */
-	wl->event_box_addr = wl12xx_reg_read32(wl, REG_EVENT_MAILBOX_PTR);
-
-	/* set the working partition to its "running" mode offset */
-	wl12xx_set_partition(wl,
-			     wl->chip.p_table[PART_WORK].mem.start,
-			     wl->chip.p_table[PART_WORK].mem.size,
-			     wl->chip.p_table[PART_WORK].reg.start,
-			     wl->chip.p_table[PART_WORK].reg.size);
-
-	wl12xx_debug(DEBUG_MAILBOX, "cmd_box_addr 0x%x event_box_addr 0x%x",
-		     wl->cmd_box_addr, wl->event_box_addr);
-
-	/*
-	 * in case of full asynchronous mode the firmware event must be
-	 * ready to receive event from the command mailbox
-	 */
-
-	/* enable gpio interrupts */
-	wl12xx_boot_enable_interrupts(wl);
-
-	wl->chip.op_target_enable_interrupts(wl);
-
-	/* unmask all mbox events  */
-	wl->event_mask = 0xffffffff;
-
-	ret = wl12xx_event_unmask(wl);
-	if (ret < 0) {
-		wl12xx_error("EVENT mask setting failed");
-		return ret;
-	}
-
-	wl12xx_event_mbox_config(wl);
-
-	/* firmware startup completed */
-	return 0;
-}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/boot.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/boot.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/boot.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/boot.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,40 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (C) 2008 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#ifndef __BOOT_H__
-#define __BOOT_H__
-
-#include "wl12xx.h"
-
-int wl12xx_boot_soft_reset(struct wl12xx *wl);
-int wl12xx_boot_init_seq(struct wl12xx *wl);
-int wl12xx_boot_run_firmware(struct wl12xx *wl);
-void wl12xx_boot_target_enable_interrupts(struct wl12xx *wl);
-
-/* number of times we try to read the INIT interrupt */
-#define INIT_LOOP 20000
-
-/* delay between retries */
-#define INIT_LOOP_DELAY 50
-
-#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/cmd.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/cmd.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/cmd.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/cmd.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,356 +0,0 @@
-#include "cmd.h"
-
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/crc7.h>
-#include <linux/spi/spi.h>
-
-#include "wl12xx.h"
-#include "wl12xx_80211.h"
-#include "reg.h"
-#include "spi.h"
-#include "ps.h"
-
-int wl12xx_cmd_send(struct wl12xx *wl, u16 type, void *buf, size_t buf_len)
-{
-	struct wl12xx_command cmd;
-	unsigned long timeout;
-	size_t cmd_len;
-	u32 intr;
-	int ret = 0;
-
-	memset(&cmd, 0, sizeof(cmd));
-	cmd.id = type;
-	cmd.status = 0;
-	memcpy(cmd.parameters, buf, buf_len);
-	cmd_len = ALIGN(buf_len, 4) + CMDMBOX_HEADER_LEN;
-
-	wl12xx_ps_elp_wakeup(wl);
-
-	wl12xx_spi_mem_write(wl, wl->cmd_box_addr, &cmd, cmd_len);
-
-	wl12xx_reg_write32(wl, ACX_REG_INTERRUPT_TRIG, INTR_TRIG_CMD);
-
-	timeout = jiffies + msecs_to_jiffies(WL12XX_COMMAND_TIMEOUT);
-
-	intr = wl12xx_reg_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);
-	while (!(intr & wl->chip.intr_cmd_complete)) {
-		if (time_after(jiffies, timeout)) {
-			wl12xx_error("command complete timeout");
-			ret = -ETIMEDOUT;
-			goto out;
-		}
-
-		msleep(1);
-
-		intr = wl12xx_reg_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);
-	}
-
-	wl12xx_reg_write32(wl, ACX_REG_INTERRUPT_ACK,
-			   wl->chip.intr_cmd_complete);
-
-out:
-	wl12xx_ps_elp_sleep(wl);
-
-	return ret;
-}
-
-int wl12xx_cmd_test(struct wl12xx *wl, void *buf, size_t buf_len, u8 answer)
-{
-	int ret;
-
-	wl12xx_debug(DEBUG_CMD, "cmd test");
-
-	ret = wl12xx_cmd_send(wl, CMD_TEST, buf, buf_len);
-	if (ret < 0) {
-		wl12xx_warning("TEST command failed");
-		return ret;
-	}
-
-	if (answer) {
-		struct wl12xx_command *cmd_answer;
-
-		/*
-		 * The test command got in, we can read the answer.
-		 * The answer would be a wl12xx_command, where the
-		 * parameter array contains the actual answer.
-		 */
-
-		wl12xx_ps_elp_wakeup(wl);
-
-		wl12xx_spi_mem_read(wl, wl->cmd_box_addr, buf, buf_len);
-
-		wl12xx_ps_elp_sleep(wl);
-
-		cmd_answer = buf;
-		if (cmd_answer->status != CMD_STATUS_SUCCESS)
-			wl12xx_error("TEST command answer error: %d",
-				     cmd_answer->status);
-	}
-
-	return 0;
-}
-
-
-int wl12xx_cmd_interrogate(struct wl12xx *wl, u16 ie_id, u16 ie_len,
-			   void *answer)
-{
-	struct wl12xx_command *cmd;
-	struct acx_header header;
-	int ret;
-
-	wl12xx_debug(DEBUG_CMD, "cmd interrogate");
-
-	header.id = ie_id;
-	header.len = ie_len - sizeof(header);
-
-	ret = wl12xx_cmd_send(wl, CMD_INTERROGATE, &header, sizeof(header));
-	if (ret < 0) {
-		wl12xx_error("INTERROGATE command failed");
-		return ret;
-	}
-
-	wl12xx_ps_elp_wakeup(wl);
-
-	/* the interrogate command got in, we can read the answer */
-	wl12xx_spi_mem_read(wl, wl->cmd_box_addr, answer,
-			    CMDMBOX_HEADER_LEN + ie_len);
-
-	wl12xx_ps_elp_sleep(wl);
-
-	cmd = answer;
-	if (cmd->status != CMD_STATUS_SUCCESS)
-		wl12xx_error("INTERROGATE command error: %d",
-			     cmd->status);
-
-	return 0;
-
-}
-
-int wl12xx_cmd_configure(struct wl12xx *wl, void *ie, int ie_len)
-{
-	int ret;
-
-	wl12xx_debug(DEBUG_CMD, "cmd configure");
-
-	ret = wl12xx_cmd_send(wl, CMD_CONFIGURE, ie,
-			      ie_len);
-	if (ret < 0) {
-		wl12xx_warning("CONFIGURE command NOK");
-		return ret;
-	}
-
-	return 0;
-
-}
-
-int wl12xx_cmd_vbm(struct wl12xx *wl, u8 identity,
-		   void *bitmap, u16 bitmap_len, u8 bitmap_control)
-{
-	struct vbm_update_request vbm;
-	int ret;
-
-	wl12xx_debug(DEBUG_CMD, "cmd vbm");
-
-	/* Count and period will be filled by the target */
-	vbm.tim.bitmap_ctrl = bitmap_control;
-	if (bitmap_len > PARTIAL_VBM_MAX) {
-		wl12xx_warning("cmd vbm len is %d B, truncating to %d",
-			       bitmap_len, PARTIAL_VBM_MAX);
-		bitmap_len = PARTIAL_VBM_MAX;
-	}
-	memcpy(vbm.tim.pvb_field, bitmap, bitmap_len);
-	vbm.tim.identity = identity;
-	vbm.tim.length = bitmap_len + 3;
-
-	vbm.len = cpu_to_le16(bitmap_len + 5);
-
-	ret = wl12xx_cmd_send(wl, CMD_VBM, &vbm, sizeof(vbm));
-	if (ret < 0) {
-		wl12xx_error("VBM command failed");
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_cmd_data_path(struct wl12xx *wl, u8 channel, u8 enable)
-{
-	int ret;
-	u16 cmd_rx, cmd_tx;
-
-	wl12xx_debug(DEBUG_CMD, "cmd data path");
-
-	if (enable) {
-		cmd_rx = CMD_ENABLE_RX;
-		cmd_tx = CMD_ENABLE_TX;
-	} else {
-		cmd_rx = CMD_DISABLE_RX;
-		cmd_tx = CMD_DISABLE_TX;
-	}
-
-	ret = wl12xx_cmd_send(wl, cmd_rx, &channel, sizeof(channel));
-	if (ret < 0) {
-		wl12xx_error("rx %s cmd for channel %d failed",
-			     enable ? "start" : "stop", channel);
-		return ret;
-	}
-
-	wl12xx_debug(DEBUG_BOOT, "rx %s cmd channel %d",
-		     enable ? "start" : "stop", channel);
-
-	ret = wl12xx_cmd_send(wl, cmd_tx, &channel, sizeof(channel));
-	if (ret < 0) {
-		wl12xx_error("tx %s cmd for channel %d failed",
-			     enable ? "start" : "stop", channel);
-		return ret;
-	}
-
-	wl12xx_debug(DEBUG_BOOT, "tx %s cmd channel %d",
-		     enable ? "start" : "stop", channel);
-
-	return 0;
-}
-
-int wl12xx_cmd_join(struct wl12xx *wl, u8 bss_type, u8 dtim_interval,
-		    u16 beacon_interval, u8 wait)
-{
-	unsigned long timeout;
-	struct cmd_join join;
-	int ret, i;
-	u8 *bssid;
-
-	/* FIXME: this should be in main.c */
-	ret = wl12xx_acx_frame_rates(wl, DEFAULT_HW_GEN_TX_RATE,
-				     DEFAULT_HW_GEN_MODULATION_TYPE,
-				     wl->tx_mgmt_frm_rate,
-				     wl->tx_mgmt_frm_mod);
-	if (ret < 0)
-		return ret;
-
-	wl12xx_debug(DEBUG_CMD, "cmd join");
-
-	/* Reverse order BSSID */
-	bssid = (u8 *)&join.bssid_lsb;
-	for (i = 0; i < ETH_ALEN; i++)
-		bssid[i] = wl->bssid[ETH_ALEN - i - 1];
-
-	join.rx_config_options = wl->rx_config;
-	join.rx_filter_options = wl->rx_filter;
-
-	join.basic_rate_set = RATE_MASK_1MBPS | RATE_MASK_2MBPS |
-		RATE_MASK_5_5MBPS | RATE_MASK_11MBPS;
-
-	join.beacon_interval = beacon_interval;
-	join.dtim_interval = dtim_interval;
-	join.bss_type = bss_type;
-	join.channel = wl->channel;
-	join.ssid_len = wl->ssid_len;
-	memcpy(join.ssid, wl->ssid, wl->ssid_len);
-	join.ctrl = JOIN_CMD_CTRL_TX_FLUSH;
-
-	ret = wl12xx_cmd_send(wl, CMD_START_JOIN, &join, sizeof(join));
-	if (ret < 0) {
-		wl12xx_error("failed to initiate cmd join");
-		return ret;
-	}
-
-	timeout = msecs_to_jiffies(JOIN_TIMEOUT);
-
-	/*
-	 * ugly hack: we should wait for JOIN_EVENT_COMPLETE_ID but to
-	 * simplify locking we just sleep instead, for now
-	 */
-	if (wait)
-		msleep(10);
-
-	return 0;
-}
-
-int wl12xx_cmd_ps_mode(struct wl12xx *wl, u8 ps_mode)
-{
-	int ret;
-	struct acx_ps_params ps_params;
-
-	/* FIXME: this should be in ps.c */
-	ret = wl12xx_acx_wake_up_conditions(wl, wl->listen_int);
-	if (ret < 0) {
-		wl12xx_error("Couldnt set wake up conditions");
-		return ret;
-	}
-
-	wl12xx_debug(DEBUG_CMD, "cmd set ps mode");
-
-	ps_params.ps_mode = ps_mode;
-	ps_params.send_null_data = 1;
-	ps_params.retries = 5;
-	ps_params.hang_over_period = 128;
-	ps_params.null_data_rate = 1; /* 1 Mbps */
-
-	ret = wl12xx_cmd_send(wl, CMD_SET_PS_MODE, &ps_params,
-			      sizeof(ps_params));
-	if (ret < 0) {
-		wl12xx_error("cmd set_ps_mode failed");
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_cmd_read_memory(struct wl12xx *wl, u32 addr, u32 len, void *answer)
-{
-	struct cmd_read_write_memory mem_cmd, *mem_answer;
-	struct wl12xx_command cmd;
-	int ret;
-
-	wl12xx_debug(DEBUG_CMD, "cmd read memory");
-
-	memset(&mem_cmd, 0, sizeof(mem_cmd));
-	mem_cmd.addr = addr;
-	mem_cmd.size = len;
-
-	ret = wl12xx_cmd_send(wl, CMD_READ_MEMORY, &mem_cmd, sizeof(mem_cmd));
-	if (ret < 0) {
-		wl12xx_error("read memory command failed: %d", ret);
-		return ret;
-	}
-
-	/* the read command got in, we can now read the answer */
-	wl12xx_spi_mem_read(wl, wl->cmd_box_addr, &cmd,
-			    CMDMBOX_HEADER_LEN + sizeof(mem_cmd));
-
-	if (cmd.status != CMD_STATUS_SUCCESS)
-		wl12xx_error("error in read command result: %d", cmd.status);
-
-	mem_answer = (struct cmd_read_write_memory *) cmd.parameters;
-	memcpy(answer, mem_answer->value, len);
-
-	return 0;
-}
-
-int wl12xx_cmd_template_set(struct wl12xx *wl, u16 cmd_id,
-			    void *buf, size_t buf_len)
-{
-	struct wl12xx_cmd_packet_template template;
-	int ret;
-
-	wl12xx_debug(DEBUG_CMD, "cmd template %d", cmd_id);
-
-	memset(&template, 0, sizeof(template));
-
-	WARN_ON(buf_len > WL12XX_MAX_TEMPLATE_SIZE);
-	buf_len = min_t(size_t, buf_len, WL12XX_MAX_TEMPLATE_SIZE);
-	template.size = cpu_to_le16(buf_len);
-
-	if (buf)
-		memcpy(template.template, buf, buf_len);
-
-	ret = wl12xx_cmd_send(wl, cmd_id, &template,
-			      sizeof(template.size) + buf_len);
-	if (ret < 0) {
-		wl12xx_warning("cmd set_template failed: %d", ret);
-		return ret;
-	}
-
-	return 0;
-}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/cmd.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/cmd.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/cmd.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/cmd.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,265 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (c) 1998-2007 Texas Instruments Incorporated
- * Copyright (C) 2008 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#ifndef __WL12XX_CMD_H__
-#define __WL12XX_CMD_H__
-
-#include "wl12xx.h"
-
-int wl12xx_cmd_send(struct wl12xx *wl, u16 type, void *buf, size_t buf_len);
-int wl12xx_cmd_test(struct wl12xx *wl, void *buf, size_t buf_len, u8 answer);
-int wl12xx_cmd_interrogate(struct wl12xx *wl, u16 ie_id, u16 ie_len,
-			   void *answer);
-int wl12xx_cmd_configure(struct wl12xx *wl, void *ie, int ie_len);
-int wl12xx_cmd_vbm(struct wl12xx *wl, u8 identity,
-		   void *bitmap, u16 bitmap_len, u8 bitmap_control);
-int wl12xx_cmd_data_path(struct wl12xx *wl, u8 channel, u8 enable);
-int wl12xx_cmd_join(struct wl12xx *wl, u8 bss_type, u8 dtim_interval,
-		    u16 beacon_interval, u8 wait);
-int wl12xx_cmd_ps_mode(struct wl12xx *wl, u8 ps_mode);
-int wl12xx_cmd_read_memory(struct wl12xx *wl, u32 addr, u32 len, void *answer);
-int wl12xx_cmd_template_set(struct wl12xx *wl, u16 cmd_id,
-			    void *buf, size_t buf_len);
-
-/* unit ms */
-#define WL12XX_COMMAND_TIMEOUT 2000
-
-#define WL12XX_MAX_TEMPLATE_SIZE 300
-
-struct wl12xx_cmd_packet_template {
-	__le16 size;
-	u8 template[WL12XX_MAX_TEMPLATE_SIZE];
-} __attribute__ ((packed));
-
-enum wl12xx_commands {
-	CMD_RESET           = 0,
-	CMD_INTERROGATE     = 1,    /*use this to read information elements*/
-	CMD_CONFIGURE       = 2,    /*use this to write information elements*/
-	CMD_ENABLE_RX       = 3,
-	CMD_ENABLE_TX       = 4,
-	CMD_DISABLE_RX      = 5,
-	CMD_DISABLE_TX      = 6,
-	CMD_SCAN            = 8,
-	CMD_STOP_SCAN       = 9,
-	CMD_VBM             = 10,
-	CMD_START_JOIN      = 11,
-	CMD_SET_KEYS        = 12,
-	CMD_READ_MEMORY     = 13,
-	CMD_WRITE_MEMORY    = 14,
-	CMD_BEACON          = 19,
-	CMD_PROBE_RESP      = 20,
-	CMD_NULL_DATA       = 21,
-	CMD_PROBE_REQ       = 22,
-	CMD_TEST            = 23,
-	CMD_RADIO_CALIBRATE     = 25,   /* OBSOLETE */
-	CMD_ENABLE_RX_PATH      = 27,   /* OBSOLETE */
-	CMD_NOISE_HIST      = 28,
-	CMD_RX_RESET        = 29,
-	CMD_PS_POLL         = 30,
-	CMD_QOS_NULL_DATA   = 31,
-	CMD_LNA_CONTROL     = 32,
-	CMD_SET_BCN_MODE    = 33,
-	CMD_MEASUREMENT      = 34,
-	CMD_STOP_MEASUREMENT = 35,
-	CMD_DISCONNECT       = 36,
-	CMD_SET_PS_MODE      = 37,
-	CMD_CHANNEL_SWITCH   = 38,
-	CMD_STOP_CHANNEL_SWICTH = 39,
-	CMD_AP_DISCOVERY     = 40,
-	CMD_STOP_AP_DISCOVERY = 41,
-	CMD_SPS_SCAN = 42,
-	CMD_STOP_SPS_SCAN = 43,
-	CMD_HEALTH_CHECK     = 45,
-	CMD_DEBUG            = 46,
-	CMD_TRIGGER_SCAN_TO  = 47,
-
-	NUM_COMMANDS,
-	MAX_COMMAND_ID = 0xFFFF,
-};
-
-#define MAX_CMD_PARAMS 572
-
-struct  wl12xx_command {
-	u16 id;
-	u16 status;
-	u8  parameters[MAX_CMD_PARAMS];
-};
-
-enum {
-	CMD_MAILBOX_IDLE              		=  0,
-	CMD_STATUS_SUCCESS            		=  1,
-	CMD_STATUS_UNKNOWN_CMD        		=  2,
-	CMD_STATUS_UNKNOWN_IE         		=  3,
-	CMD_STATUS_REJECT_MEAS_SG_ACTIVE 	= 11,
-	CMD_STATUS_RX_BUSY            		= 13,
-	CMD_STATUS_INVALID_PARAM      		= 14,
-	CMD_STATUS_TEMPLATE_TOO_LARGE 		= 15,
-	CMD_STATUS_OUT_OF_MEMORY      		= 16,
-	CMD_STATUS_STA_TABLE_FULL     		= 17,
-	CMD_STATUS_RADIO_ERROR        		= 18,
-	CMD_STATUS_WRONG_NESTING      		= 19,
-	CMD_STATUS_TIMEOUT            		= 21, /* Driver internal use.*/
-	CMD_STATUS_FW_RESET           		= 22, /* Driver internal use.*/
-	MAX_COMMAND_STATUS            		= 0xff
-};
-
-
-/*
- * CMD_READ_MEMORY
- *
- * The host issues this command to read the WiLink device memory/registers.
- *
- * Note: The Base Band address has special handling (16 bits registers and
- * addresses). For more information, see the hardware specification.
- */
-/*
- * CMD_WRITE_MEMORY
- *
- * The host issues this command to write the WiLink device memory/registers.
- *
- * The Base Band address has special handling (16 bits registers and
- * addresses). For more information, see the hardware specification.
- */
-#define MAX_READ_SIZE 256
-
-struct cmd_read_write_memory {
-	/* The address of the memory to read from or write to.*/
-	u32 addr;
-
-	/* The amount of data in bytes to read from or write to the WiLink
-	 * device.*/
-	u32 size;
-
-	/* The actual value read from or written to the Wilink. The source
-	   of this field is the Host in WRITE command or the Wilink in READ
-	   command. */
-	u8 value[MAX_READ_SIZE];
-};
-
-#define CMDMBOX_HEADER_LEN 4
-#define CMDMBOX_INFO_ELEM_HEADER_LEN 4
-
-
-struct basic_scan_parameters {
-	u32 rx_config_options;
-	u32 rx_filter_options;
-
-	/*
-	 * Scan options:
-	 * bit 0: When this bit is set, passive scan.
-	 * bit 1: Band, when this bit is set we scan
-	 * in the 5Ghz band.
-	 * bit 2: voice mode, 0 for normal scan.
-	 * bit 3: scan priority, 1 for high priority.
-	 */
-	u16 scan_options;
-
-	/* Number of channels to scan */
-	u8 num_channels;
-
-	/* Number opf probe requests to send, per channel */
-	u8 num_probe_requests;
-
-	/* Rate and modulation for probe requests */
-	u16 tx_rate;
-
-	u8 tid_trigger;
-	u8 ssid_len;
-	u32 ssid[8];
-
-} __attribute__ ((packed));
-
-struct basic_scan_channel_parameters {
-	u32 min_duration; /* in TU */
-	u32 max_duration; /* in TU */
-	u32 bssid_lsb;
-	u16 bssid_msb;
-
-	/*
-	 * bits 0-3: Early termination count.
-	 * bits 4-5: Early termination condition.
-	 */
-	u8 early_termination;
-
-	u8 tx_power_att;
-	u8 channel;
-	u8 pad[3];
-} __attribute__ ((packed));
-
-/* SCAN parameters */
-#define SCAN_MAX_NUM_OF_CHANNELS 16
-
-struct cmd_scan {
-	struct basic_scan_parameters params;
-	struct basic_scan_channel_parameters channels[SCAN_MAX_NUM_OF_CHANNELS];
-} __attribute__ ((packed));
-
-enum {
-	BSS_TYPE_IBSS = 0,
-	BSS_TYPE_STA_BSS = 2,
-	BSS_TYPE_AP_BSS = 3,
-	MAX_BSS_TYPE = 0xFF
-};
-
-#define JOIN_CMD_CTRL_TX_FLUSH             0x80 /* Firmware flushes all Tx */
-#define JOIN_CMD_CTRL_EARLY_WAKEUP_ENABLE  0x01 /* Early wakeup time */
-
-
-struct cmd_join {
-	u32 bssid_lsb;
-	u16 bssid_msb;
-	u16 beacon_interval; /* in TBTTs */
-	u32 rx_config_options;
-	u32 rx_filter_options;
-
-	/*
-	 * The target uses this field to determine the rate at
-	 * which to transmit control frame responses (such as
-	 * ACK or CTS frames).
-	 */
-	u16 basic_rate_set;
-	u8 dtim_interval;
-	u8 tx_ctrl_frame_rate; /* OBSOLETE */
-	u8 tx_ctrl_frame_mod;  /* OBSOLETE */
-	/*
-	 * bits 0-2: This bitwise field specifies the type
-	 * of BSS to start or join (BSS_TYPE_*).
-	 * bit 4: Band - The radio band in which to join
-	 * or start.
-	 *  0 - 2.4GHz band
-	 *  1 - 5GHz band
-	 * bits 3, 5-7: Reserved
-	 */
-	u8 bss_type;
-	u8 channel;
-	u8 ssid_len;
-	u8 ssid[IW_ESSID_MAX_SIZE];
-	u8 ctrl; /* JOIN_CMD_CTRL_* */
-	u8 tx_mgt_frame_rate; /* OBSOLETE */
-	u8 tx_mgt_frame_mod;  /* OBSOLETE */
-	u8 reserved;
-} __attribute__ ((packed));
-
-
-#endif /* __WL12XX_CMD_H__ */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/event.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/event.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/event.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/event.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,127 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (c) 1998-2007 Texas Instruments Incorporated
- * Copyright (C) 2008 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#include "wl12xx.h"
-#include "reg.h"
-#include "spi.h"
-#include "event.h"
-#include "ps.h"
-
-static int wl12xx_event_scan_complete(struct wl12xx *wl,
-				      struct event_mailbox *mbox)
-{
-	wl12xx_debug(DEBUG_EVENT, "status: 0x%x, channels: %d",
-		     mbox->scheduled_scan_status,
-		     mbox->scheduled_scan_channels);
-
-	if (wl->scanning) {
-		mutex_unlock(&wl->mutex);
-		ieee80211_scan_completed(wl->hw);
-		mutex_lock(&wl->mutex);
-		wl->scanning = false;
-	}
-
-	return 0;
-}
-
-static void wl12xx_event_mbox_dump(struct event_mailbox *mbox)
-{
-	wl12xx_debug(DEBUG_EVENT, "MBOX DUMP:");
-	wl12xx_debug(DEBUG_EVENT, "\tvector: 0x%x", mbox->events_vector);
-	wl12xx_debug(DEBUG_EVENT, "\tmask: 0x%x", mbox->events_mask);
-}
-
-static int wl12xx_event_process(struct wl12xx *wl, struct event_mailbox *mbox)
-{
-	int ret;
-	u32 vector;
-
-	wl12xx_event_mbox_dump(mbox);
-
-	vector = mbox->events_vector & ~(mbox->events_mask);
-	wl12xx_debug(DEBUG_EVENT, "vector: 0x%x", vector);
-
-	if (vector & SCAN_COMPLETE_EVENT_ID) {
-		ret = wl12xx_event_scan_complete(wl, mbox);
-		if (ret < 0)
-			return ret;
-	}
-
-	if (vector & BSS_LOSE_EVENT_ID) {
-		wl12xx_debug(DEBUG_EVENT, "BSS_LOSE_EVENT");
-
-		if (wl->psm_requested && wl->psm) {
-			ret = wl12xx_ps_set_mode(wl, STATION_ACTIVE_MODE);
-			if (ret < 0)
-				return ret;
-		}
-	}
-
-	return 0;
-}
-
-int wl12xx_event_unmask(struct wl12xx *wl)
-{
-	int ret;
-
-	ret = wl12xx_acx_event_mbox_mask(wl, ~(wl->event_mask));
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-void wl12xx_event_mbox_config(struct wl12xx *wl)
-{
-	wl->mbox_ptr[0] = wl12xx_reg_read32(wl, REG_EVENT_MAILBOX_PTR);
-	wl->mbox_ptr[1] = wl->mbox_ptr[0] + sizeof(struct event_mailbox);
-
-	wl12xx_debug(DEBUG_EVENT, "MBOX ptrs: 0x%x 0x%x",
-		     wl->mbox_ptr[0], wl->mbox_ptr[1]);
-}
-
-int wl12xx_event_handle(struct wl12xx *wl, u8 mbox_num)
-{
-	struct event_mailbox mbox;
-	int ret;
-
-	wl12xx_debug(DEBUG_EVENT, "EVENT on mbox %d", mbox_num);
-
-	if (mbox_num > 1)
-		return -EINVAL;
-
-	/* first we read the mbox descriptor */
-	wl12xx_spi_mem_read(wl, wl->mbox_ptr[mbox_num], &mbox,
-			    sizeof(struct event_mailbox));
-
-	/* process the descriptor */
-	ret = wl12xx_event_process(wl, &mbox);
-	if (ret < 0)
-		return ret;
-
-	/* then we let the firmware know it can go on...*/
-	wl12xx_reg_write32(wl, ACX_REG_INTERRUPT_TRIG, INTR_TRIG_EVENT_ACK);
-
-	return 0;
-}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/event.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/event.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/event.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/event.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,121 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (c) 1998-2007 Texas Instruments Incorporated
- * Copyright (C) 2008 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#ifndef __WL12XX_EVENT_H__
-#define __WL12XX_EVENT_H__
-
-/*
- * Mbox events
- *
- * The event mechanism is based on a pair of event buffers (buffers A and
- * B) at fixed locations in the target's memory. The host processes one
- * buffer while the other buffer continues to collect events. If the host
- * is not processing events, an interrupt is issued to signal that a buffer
- * is ready. Once the host is done with processing events from one buffer,
- * it signals the target (with an ACK interrupt) that the event buffer is
- * free.
- */
-
-enum {
-	RESERVED1_EVENT_ID                       = BIT(0),
-	RESERVED2_EVENT_ID                       = BIT(1),
-	MEASUREMENT_START_EVENT_ID               = BIT(2),
-	SCAN_COMPLETE_EVENT_ID                   = BIT(3),
-	CALIBRATION_COMPLETE_EVENT_ID            = BIT(4),
-	ROAMING_TRIGGER_LOW_RSSI_EVENT_ID        = BIT(5),
-	PS_REPORT_EVENT_ID                       = BIT(6),
-	SYNCHRONIZATION_TIMEOUT_EVENT_ID         = BIT(7),
-	HEALTH_REPORT_EVENT_ID                   = BIT(8),
-	ACI_DETECTION_EVENT_ID                   = BIT(9),
-	DEBUG_REPORT_EVENT_ID                    = BIT(10),
-	MAC_STATUS_EVENT_ID                      = BIT(11),
-	DISCONNECT_EVENT_COMPLETE_ID             = BIT(12),
-	JOIN_EVENT_COMPLETE_ID                   = BIT(13),
-	CHANNEL_SWITCH_COMPLETE_EVENT_ID         = BIT(14),
-	BSS_LOSE_EVENT_ID                        = BIT(15),
-	ROAMING_TRIGGER_MAX_TX_RETRY_EVENT_ID    = BIT(16),
-	MEASUREMENT_COMPLETE_EVENT_ID            = BIT(17),
-	AP_DISCOVERY_COMPLETE_EVENT_ID           = BIT(18),
-	SCHEDULED_SCAN_COMPLETE_EVENT_ID         = BIT(19),
-	PSPOLL_DELIVERY_FAILURE_EVENT_ID 	 = BIT(20),
-	RESET_BSS_EVENT_ID                       = BIT(21),
-	REGAINED_BSS_EVENT_ID                    = BIT(22),
-	ROAMING_TRIGGER_REGAINED_RSSI_EVENT_ID   = BIT(23),
-	ROAMING_TRIGGER_LOW_SNR_EVENT_ID         = BIT(24),
-	ROAMING_TRIGGER_REGAINED_SNR_EVENT_ID    = BIT(25),
-
-	DBG_EVENT_ID                             = BIT(26),
-	BT_PTA_SENSE_EVENT_ID                    = BIT(27),
-	BT_PTA_PREDICTION_EVENT_ID               = BIT(28),
-	BT_PTA_AVALANCHE_EVENT_ID                = BIT(29),
-
-	PLT_RX_CALIBRATION_COMPLETE_EVENT_ID     = BIT(30),
-
-	EVENT_MBOX_ALL_EVENT_ID                  = 0x7fffffff,
-};
-
-struct event_debug_report {
-	u8 debug_event_id;
-	u8 num_params;
-	u16 pad;
-	u32 report_1;
-	u32 report_2;
-	u32 report_3;
-} __attribute__ ((packed));
-
-struct event_mailbox {
-	u32 events_vector;
-	u32 events_mask;
-	u32 reserved_1;
-	u32 reserved_2;
-
-	char average_rssi_level;
-	u8 ps_status;
-	u8 channel_switch_status;
-	u8 scheduled_scan_status;
-
-	/* Channels scanned by the scheduled scan */
-	u16 scheduled_scan_channels;
-
-	/* If bit 0 is set -> target's fatal error */
-	u16 health_report;
-	u16 bad_fft_counter;
-	u8 bt_pta_sense_info;
-	u8 bt_pta_protective_info;
-	u32 reserved;
-	u32 debug_report[2];
-
-	/* Number of FCS errors since last event */
-	u32 fcs_err_counter;
-
-	struct event_debug_report report;
-	u8 average_snr_level;
-	u8 padding[19];
-} __attribute__ ((packed));
-
-int wl12xx_event_unmask(struct wl12xx *wl);
-void wl12xx_event_mbox_config(struct wl12xx *wl);
-int wl12xx_event_handle(struct wl12xx *wl, u8 mbox);
-
-#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/init.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/init.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/init.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/init.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,200 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (C) 2009 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-
-#include "init.h"
-#include "wl12xx_80211.h"
-#include "acx.h"
-#include "cmd.h"
-
-int wl12xx_hw_init_hwenc_config(struct wl12xx *wl)
-{
-	int ret;
-
-	ret = wl12xx_acx_feature_cfg(wl);
-	if (ret < 0) {
-		wl12xx_warning("couldn't set feature config");
-		return ret;
-	}
-
-	ret = wl12xx_acx_default_key(wl, wl->default_key);
-	if (ret < 0) {
-		wl12xx_warning("couldn't set default key");
-		return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_hw_init_templates_config(struct wl12xx *wl)
-{
-	int ret;
-	u8 partial_vbm[PARTIAL_VBM_MAX];
-
-	/* send empty templates for fw memory reservation */
-	ret = wl12xx_cmd_template_set(wl, CMD_PROBE_REQ, NULL,
-				      sizeof(struct wl12xx_probe_req_template));
-	if (ret < 0)
-		return ret;
-
-	ret = wl12xx_cmd_template_set(wl, CMD_NULL_DATA, NULL,
-				      sizeof(struct wl12xx_null_data_template));
-	if (ret < 0)
-		return ret;
-
-	ret = wl12xx_cmd_template_set(wl, CMD_PS_POLL, NULL,
-				      sizeof(struct wl12xx_ps_poll_template));
-	if (ret < 0)
-		return ret;
-
-	ret = wl12xx_cmd_template_set(wl, CMD_QOS_NULL_DATA, NULL,
-				      sizeof
-				      (struct wl12xx_qos_null_data_template));
-	if (ret < 0)
-		return ret;
-
-	ret = wl12xx_cmd_template_set(wl, CMD_PROBE_RESP, NULL,
-				      sizeof
-				      (struct wl12xx_probe_resp_template));
-	if (ret < 0)
-		return ret;
-
-	ret = wl12xx_cmd_template_set(wl, CMD_BEACON, NULL,
-				      sizeof
-				      (struct wl12xx_beacon_template));
-	if (ret < 0)
-		return ret;
-
-	/* tim templates, first reserve space then allocate an empty one */
-	memset(partial_vbm, 0, PARTIAL_VBM_MAX);
-	ret = wl12xx_cmd_vbm(wl, TIM_ELE_ID, partial_vbm, PARTIAL_VBM_MAX, 0);
-	if (ret < 0)
-		return ret;
-
-	ret = wl12xx_cmd_vbm(wl, TIM_ELE_ID, partial_vbm, 1, 0);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-int wl12xx_hw_init_rx_config(struct wl12xx *wl, u32 config, u32 filter)
-{
-	int ret;
-
-	ret = wl12xx_acx_rx_msdu_life_time(wl, RX_MSDU_LIFETIME_DEF);
-	if (ret < 0)
-		return ret;
-
-	ret = wl12xx_acx_rx_config(wl, config, filter);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-int wl12xx_hw_init_phy_config(struct wl12xx *wl)
-{
-	int ret;
-
-	ret = wl12xx_acx_pd_threshold(wl);
-	if (ret < 0)
-		return ret;
-
-	ret = wl12xx_acx_slot(wl, DEFAULT_SLOT_TIME);
-	if (ret < 0)
-		return ret;
-
-	ret = wl12xx_acx_group_address_tbl(wl);
-	if (ret < 0)
-		return ret;
-
-	ret = wl12xx_acx_service_period_timeout(wl);
-	if (ret < 0)
-		return ret;
-
-	ret = wl12xx_acx_rts_threshold(wl, RTS_THRESHOLD_DEF);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-int wl12xx_hw_init_beacon_filter(struct wl12xx *wl)
-{
-	int ret;
-
-	ret = wl12xx_acx_beacon_filter_opt(wl);
-	if (ret < 0)
-		return ret;
-
-	ret = wl12xx_acx_beacon_filter_table(wl);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-int wl12xx_hw_init_pta(struct wl12xx *wl)
-{
-	int ret;
-
-	ret = wl12xx_acx_sg_enable(wl);
-	if (ret < 0)
-		return ret;
-
-	ret = wl12xx_acx_sg_cfg(wl);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-int wl12xx_hw_init_energy_detection(struct wl12xx *wl)
-{
-	int ret;
-
-	ret = wl12xx_acx_cca_threshold(wl);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-int wl12xx_hw_init_beacon_broadcast(struct wl12xx *wl)
-{
-	int ret;
-
-	ret = wl12xx_acx_bcn_dtim_options(wl);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-int wl12xx_hw_init_power_auth(struct wl12xx *wl)
-{
-	return wl12xx_acx_sleep_auth(wl, WL12XX_PSM_CAM);
-}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/init.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/init.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/init.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/init.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,40 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (C) 2009 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#ifndef __WL12XX_INIT_H__
-#define __WL12XX_INIT_H__
-
-#include "wl12xx.h"
-
-int wl12xx_hw_init_hwenc_config(struct wl12xx *wl);
-int wl12xx_hw_init_templates_config(struct wl12xx *wl);
-int wl12xx_hw_init_mem_config(struct wl12xx *wl);
-int wl12xx_hw_init_rx_config(struct wl12xx *wl, u32 config, u32 filter);
-int wl12xx_hw_init_phy_config(struct wl12xx *wl);
-int wl12xx_hw_init_beacon_filter(struct wl12xx *wl);
-int wl12xx_hw_init_pta(struct wl12xx *wl);
-int wl12xx_hw_init_energy_detection(struct wl12xx *wl);
-int wl12xx_hw_init_beacon_broadcast(struct wl12xx *wl);
-int wl12xx_hw_init_power_auth(struct wl12xx *wl);
-
-#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/Kconfig kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/Kconfig
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/Kconfig	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/Kconfig	2012-12-16 13:13:01.680330145 +0100
@@ -1,11 +1,31 @@
-config WL12XX
-	tristate "TI wl1251/wl1271 support"
-	depends on MAC80211 && WLAN_80211 && SPI_MASTER && EXPERIMENTAL
+menuconfig WL12XX
+	boolean "TI wl12xx driver support"
+	depends on MAC80211 && WLAN_80211 && EXPERIMENTAL
+	---help---
+	  This will enable TI wl12xx driver support. The drivers make 
+	  use of the mac80211 stack.
+
+config WL1251
+	tristate "TI wl1251 support"
+	depends on WL12XX && SPI_MASTER && GENERIC_HARDIRQS
+	select FW_LOADER
+	select CRC7
+	---help---
+	  This module adds support for wireless adapters based on
+	  TI wl1251 chipset.
+
+	  If you choose to build a module, it'll be called wl1251. Say N if
+	  unsure.
+
+config WL1271
+	tristate "TI wl1271 support"
+	depends on WL12XX && SPI_MASTER && GENERIC_HARDIRQS
 	select FW_LOADER
 	select CRC7
 	---help---
 	  This module adds support for wireless adapters based on
-	  TI wl1251/wl1271 chipsets.
+	  TI wl1271 chipset.
 
-	  If you choose to build a module, it'll be called wl12xx. Say N if
+	  If you choose to build a module, it'll be called wl1271. Say N if
 	  unsure.
+
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/main.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/main.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/main.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/main.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1559 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (C) 2008-2009 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/firmware.h>
-#include <linux/delay.h>
-#include <linux/irq.h>
-#include <linux/spi/spi.h>
-#include <linux/crc32.h>
-#include <linux/etherdevice.h>
-#include <linux/spi/wl12xx.h>
-
-#include "wl12xx.h"
-#include "wl12xx_80211.h"
-#include "reg.h"
-#include "wl1251.h"
-#include "wl1271.h"
-#include "spi.h"
-#include "event.h"
-#include "tx.h"
-#include "rx.h"
-#include "ps.h"
-#include "init.h"
-#include "netlink.h"
-
-static ssize_t wl12xx_sysfs_show_tx_mgmt_frm_rate(struct device *dev,
-						  struct device_attribute *attr,
-						  char *buf)
-{
-	struct wl12xx *wl = dev_get_drvdata(dev);
-	ssize_t len;
-	int val;
-
-	/* FIXME: what's the maximum length of buf? page size?*/
-	len = 500;
-
-	switch (wl->tx_mgmt_frm_rate) {
-		/* skip 1 and 12 Mbps because they have same value 0x0a */
-	case RATE_2MBPS:
-		val = 20;
-		break;
-	case RATE_5_5MBPS:
-		val = 55;
-		break;
-	case RATE_11MBPS:
-		val = 110;
-		break;
-	case RATE_6MBPS:
-		val = 60;
-		break;
-	case RATE_9MBPS:
-		val = 90;
-		break;
-	case RATE_12MBPS:
-		val = 120;
-		break;
-	case RATE_18MBPS:
-		val = 180;
-		break;
-	case RATE_24MBPS:
-		val = 240;
-		break;
-	case RATE_36MBPS:
-		val = 360;
-		break;
-	case RATE_48MBPS:
-		val = 480;
-		break;
-	case RATE_54MBPS:
-		val = 540;
-		break;
-	default:
-		val = 10;
-	}
-
-	/* for 1 and 12 Mbps we have to check the modulation */
-	if (wl->tx_mgmt_frm_rate == RATE_1MBPS) {
-		switch (wl->tx_mgmt_frm_rate) {
-		case CCK_LONG:
-			val = 10;
-			break;
-		case OFDM:
-			val = 120;
-			break;
-		default:
-			val = 10;
-			break;
-		}
-	}
-	len = snprintf(buf, len, "%d", val);
-
-	return len;
-}
-
-static ssize_t wl12xx_sysfs_store_tx_mgmt_frm_rate(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	struct wl12xx *wl = dev_get_drvdata(dev);
-	unsigned long res;
-	int ret;
-
-	ret = strict_strtoul(buf, 10, &res);
-
-	if (ret < 0) {
-		wl12xx_warning("incorrect value written to tx_mgmt_frm_rate");
-		return 0;
-	}
-
-	switch (res) {
-	case 10:
-		wl->tx_mgmt_frm_rate = RATE_1MBPS;
-		wl->tx_mgmt_frm_mod = CCK_LONG;
-		break;
-	case 20:
-		wl->tx_mgmt_frm_rate = RATE_2MBPS;
-		wl->tx_mgmt_frm_mod = CCK_LONG;
-		break;
-	case 55:
-		wl->tx_mgmt_frm_rate = RATE_5_5MBPS;
-		wl->tx_mgmt_frm_mod = CCK_LONG;
-		break;
-	case 110:
-		wl->tx_mgmt_frm_rate = RATE_11MBPS;
-		wl->tx_mgmt_frm_mod = CCK_LONG;
-		break;
-	case 60:
-		wl->tx_mgmt_frm_rate = RATE_6MBPS;
-		wl->tx_mgmt_frm_mod = OFDM;
-		break;
-	case 90:
-		wl->tx_mgmt_frm_rate = RATE_9MBPS;
-		wl->tx_mgmt_frm_mod = OFDM;
-		break;
-	case 120:
-		wl->tx_mgmt_frm_rate = RATE_12MBPS;
-		wl->tx_mgmt_frm_mod = OFDM;
-		break;
-	case 180:
-		wl->tx_mgmt_frm_rate = RATE_18MBPS;
-		wl->tx_mgmt_frm_mod = OFDM;
-		break;
-	case 240:
-		wl->tx_mgmt_frm_rate = RATE_24MBPS;
-		wl->tx_mgmt_frm_mod = OFDM;
-		break;
-	case 360:
-		wl->tx_mgmt_frm_rate = RATE_36MBPS;
-		wl->tx_mgmt_frm_mod = OFDM;
-		break;
-	case 480:
-		wl->tx_mgmt_frm_rate = RATE_48MBPS;
-		wl->tx_mgmt_frm_mod = OFDM;
-		break;
-	case 540:
-		wl->tx_mgmt_frm_rate = RATE_54MBPS;
-		wl->tx_mgmt_frm_mod = OFDM;
-		break;
-	default:
-		wl12xx_warning("incorrect value written to tx_mgmt_frm_rate");
-		return 0;
-	}
-
-	return count;
-}
-
-static DEVICE_ATTR(tx_mgmt_frm_rate, S_IRUGO | S_IWUSR,
-		   wl12xx_sysfs_show_tx_mgmt_frm_rate,
-		   wl12xx_sysfs_store_tx_mgmt_frm_rate);
-
-static void wl12xx_disable_interrupts(struct wl12xx *wl)
-{
-	disable_irq(wl->irq);
-}
-
-static void wl12xx_power_off(struct wl12xx *wl)
-{
-	wl->set_power(false);
-}
-
-static void wl12xx_power_on(struct wl12xx *wl)
-{
-	wl->set_power(true);
-}
-
-static irqreturn_t wl12xx_irq(int irq, void *cookie)
-{
-	struct wl12xx *wl;
-
-	wl12xx_debug(DEBUG_IRQ, "IRQ");
-
-	wl = cookie;
-
-	schedule_work(&wl->irq_work);
-
-	return IRQ_HANDLED;
-}
-
-static int wl12xx_fetch_firmware(struct wl12xx *wl)
-{
-	const struct firmware *fw;
-	int ret;
-
-	ret = request_firmware(&fw, wl->chip.fw_filename, &wl->spi->dev);
-
-	if (ret < 0) {
-		wl12xx_error("could not get firmware: %d", ret);
-		return ret;
-	}
-
-	if (fw->size % 4) {
-		wl12xx_error("firmware size is not multiple of 32 bits: %d",
-			     fw->size);
-		ret = -EILSEQ;
-		goto out;
-	}
-
-	wl->fw_len = fw->size;
-	wl->fw = kmalloc(wl->fw_len, GFP_KERNEL);
-
-	if (!wl->fw) {
-		wl12xx_error("could not allocate memory for the firmware");
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	memcpy(wl->fw, fw->data, wl->fw_len);
-
-	ret = 0;
-
-out:
-	release_firmware(fw);
-
-	return ret;
-}
-
-static int wl12xx_fetch_nvs(struct wl12xx *wl)
-{
-	const struct firmware *fw;
-	int ret;
-
-	ret = request_firmware(&fw, wl->chip.nvs_filename, &wl->spi->dev);
-
-	if (ret < 0) {
-		wl12xx_error("could not get nvs file: %d", ret);
-		return ret;
-	}
-
-	if (fw->size % 4) {
-		wl12xx_error("nvs size is not multiple of 32 bits: %d",
-			     fw->size);
-		ret = -EILSEQ;
-		goto out;
-	}
-
-	wl->nvs_len = fw->size;
-	wl->nvs = kmalloc(wl->nvs_len, GFP_KERNEL);
-
-	if (!wl->nvs) {
-		wl12xx_error("could not allocate memory for the nvs file");
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	memcpy(wl->nvs, fw->data, wl->nvs_len);
-
-	ret = 0;
-
-out:
-	release_firmware(fw);
-
-	return ret;
-}
-
-static void wl12xx_fw_wakeup(struct wl12xx *wl)
-{
-	u32 elp_reg;
-
-	elp_reg = ELPCTRL_WAKE_UP;
-	wl12xx_write32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, elp_reg);
-	elp_reg = wl12xx_read32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR);
-
-	if (!(elp_reg & ELPCTRL_WLAN_READY)) {
-		wl12xx_warning("WLAN not ready");
-		elp_reg = ELPCTRL_WAKE_UP_WLAN_READY;
-		wl12xx_write32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, elp_reg);
-	}
-}
-
-static int wl12xx_chip_wakeup(struct wl12xx *wl)
-{
-	int ret = 0;
-
-	wl12xx_power_on(wl);
-	msleep(wl->chip.power_on_sleep);
-	wl12xx_spi_reset(wl);
-	wl12xx_spi_init(wl);
-
-	/* We don't need a real memory partition here, because we only want
-	 * to use the registers at this point. */
-	wl12xx_set_partition(wl,
-			     0x00000000,
-			     0x00000000,
-			     REGISTERS_BASE,
-			     REGISTERS_DOWN_SIZE);
-
-	/* ELP module wake up */
-	wl12xx_fw_wakeup(wl);
-
-	/* whal_FwCtrl_BootSm() */
-
-	/* 0. read chip id from CHIP_ID */
-	wl->chip.id = wl12xx_reg_read32(wl, CHIP_ID_B);
-
-	/* 1. check if chip id is valid */
-
-	switch (wl->chip.id) {
-	case CHIP_ID_1251_PG12:
-		wl12xx_debug(DEBUG_BOOT, "chip id 0x%x (1251 PG12)",
-			     wl->chip.id);
-
-		wl1251_setup(wl);
-
-		break;
-	case CHIP_ID_1271_PG10:
-		wl12xx_debug(DEBUG_BOOT, "chip id 0x%x (1271 PG10)",
-			     wl->chip.id);
-
-		wl1271_setup(wl);
-
-		break;
-	case CHIP_ID_1251_PG10:
-	case CHIP_ID_1251_PG11:
-	default:
-		wl12xx_error("unsupported chip id: 0x%x", wl->chip.id);
-		ret = -ENODEV;
-		goto out;
-	}
-
-	if (wl->fw == NULL) {
-		ret = wl12xx_fetch_firmware(wl);
-		if (ret < 0)
-			goto out;
-	}
-
-	/* No NVS from netlink, try to get it from the filesystem */
-	if (wl->nvs == NULL) {
-		ret = wl12xx_fetch_nvs(wl);
-		if (ret < 0)
-			goto out;
-	}
-
-out:
-	if (ret < 0)
-		wl12xx_power_off(wl);
-
-	return ret;
-}
-
-static void wl12xx_filter_work(struct work_struct *work)
-{
-	struct wl12xx *wl =
-		container_of(work, struct wl12xx, filter_work);
-	int ret;
-
-	mutex_lock(&wl->mutex);
-
-	if (wl->state == WL12XX_STATE_OFF)
-		goto out;
-
-	ret = wl12xx_cmd_join(wl, wl->bss_type, 1, 100, 0);
-	if (ret < 0)
-		goto out;
-
-out:
-	mutex_unlock(&wl->mutex);
-}
-
-int wl12xx_plt_start(struct wl12xx *wl)
-{
-	int ret;
-
-	wl12xx_notice("power up");
-
-	if (wl->state != WL12XX_STATE_OFF) {
-		wl12xx_error("cannot go into PLT state because not "
-			     "in off state: %d", wl->state);
-		return -EBUSY;
-	}
-
-	wl->state = WL12XX_STATE_PLT;
-
-	ret = wl12xx_chip_wakeup(wl);
-	if (ret < 0)
-		return ret;
-
-	ret = wl->chip.op_boot(wl);
-	if (ret < 0)
-		return ret;
-
-	wl12xx_notice("firmware booted in PLT mode (%s)", wl->chip.fw_ver);
-
-	ret = wl->chip.op_plt_init(wl);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-int wl12xx_plt_stop(struct wl12xx *wl)
-{
-	wl12xx_notice("power down");
-
-	if (wl->state != WL12XX_STATE_PLT) {
-		wl12xx_error("cannot power down because not in PLT "
-			     "state: %d", wl->state);
-		return -EBUSY;
-	}
-
-	wl12xx_disable_interrupts(wl);
-	wl12xx_power_off(wl);
-
-	wl->state = WL12XX_STATE_OFF;
-
-	return 0;
-}
-
-
-static int wl12xx_op_tx(struct ieee80211_hw *hw, struct sk_buff *skb)
-{
-	struct wl12xx *wl = hw->priv;
-
-	skb_queue_tail(&wl->tx_queue, skb);
-
-	schedule_work(&wl->tx_work);
-
-	/*
-	 * The workqueue is slow to process the tx_queue and we need stop
-	 * the queue here, otherwise the queue will get too long.
-	 */
-	if (skb_queue_len(&wl->tx_queue) >= WL12XX_TX_QUEUE_MAX_LENGTH) {
-		ieee80211_stop_queues(wl->hw);
-
-		/*
-		 * FIXME: this is racy, the variable is not properly
-		 * protected. Maybe fix this by removing the stupid
-		 * variable altogether and checking the real queue state?
-		 */
-		wl->tx_queue_stopped = true;
-	}
-
-	return NETDEV_TX_OK;
-}
-
-static int wl12xx_op_start(struct ieee80211_hw *hw)
-{
-	struct wl12xx *wl = hw->priv;
-	int ret = 0;
-
-	wl12xx_debug(DEBUG_MAC80211, "mac80211 start");
-
-	mutex_lock(&wl->mutex);
-
-	if (wl->state != WL12XX_STATE_OFF) {
-		wl12xx_error("cannot start because not in off state: %d",
-			     wl->state);
-		ret = -EBUSY;
-		goto out;
-	}
-
-	ret = wl12xx_chip_wakeup(wl);
-	if (ret < 0)
-		return ret;
-
-	ret = wl->chip.op_boot(wl);
-	if (ret < 0)
-		goto out;
-
-	ret = wl->chip.op_hw_init(wl);
-	if (ret < 0)
-		goto out;
-
-	ret = wl12xx_acx_station_id(wl);
-	if (ret < 0)
-		goto out;
-
-	wl->state = WL12XX_STATE_ON;
-
-	wl12xx_info("firmware booted (%s)", wl->chip.fw_ver);
-
-out:
-	mutex_unlock(&wl->mutex);
-	return ret;
-}
-
-static void wl12xx_op_stop(struct ieee80211_hw *hw)
-{
-	struct wl12xx *wl = hw->priv;
-
-	wl12xx_info("down");
-
-	wl12xx_debug(DEBUG_MAC80211, "mac80211 stop");
-
-	mutex_lock(&wl->mutex);
-
-	WARN_ON(wl->state != WL12XX_STATE_ON);
-
-	if (wl->scanning) {
-		mutex_unlock(&wl->mutex);
-		ieee80211_scan_completed(wl->hw);
-		mutex_lock(&wl->mutex);
-		wl->scanning = false;
-	}
-
-	wl->state = WL12XX_STATE_OFF;
-
-	wl12xx_disable_interrupts(wl);
-
-	mutex_unlock(&wl->mutex);
-
-	cancel_work_sync(&wl->irq_work);
-	cancel_work_sync(&wl->tx_work);
-	cancel_work_sync(&wl->filter_work);
-
-	mutex_lock(&wl->mutex);
-
-	/* let's notify MAC80211 about the remaining pending TX frames */
-	wl12xx_tx_flush(wl);
-
-	wl12xx_power_off(wl);
-
-	memset(wl->bssid, 0, ETH_ALEN);
-	memset(wl->ssid, 0, IW_ESSID_MAX_SIZE + 1);
-	wl->ssid_len = 0;
-	wl->listen_int = 1;
-	wl->bss_type = MAX_BSS_TYPE;
-
-	wl->data_in_count = 0;
-	wl->rx_counter = 0;
-	wl->rx_handled = 0;
-	wl->rx_current_buffer = 0;
-	wl->rx_last_id = 0;
-	wl->next_tx_complete = 0;
-	wl->elp = false;
-	wl->psm = 0;
-	wl->tx_queue_stopped = false;
-	wl->power_level = WL12XX_DEFAULT_POWER_LEVEL;
-
-	mutex_unlock(&wl->mutex);
-}
-
-static int wl12xx_op_add_interface(struct ieee80211_hw *hw,
-				   struct ieee80211_if_init_conf *conf)
-{
-	struct wl12xx *wl = hw->priv;
-	DECLARE_MAC_BUF(mac);
-	int ret = 0;
-
-	wl12xx_debug(DEBUG_MAC80211, "mac80211 add interface type %d mac %s",
-		     conf->type, print_mac(mac, conf->mac_addr));
-
-	mutex_lock(&wl->mutex);
-
-	switch (conf->type) {
-	case NL80211_IFTYPE_STATION:
-		wl->bss_type = BSS_TYPE_STA_BSS;
-		break;
-	case NL80211_IFTYPE_ADHOC:
-		wl->bss_type = BSS_TYPE_IBSS;
-		break;
-	default:
-		ret = -EOPNOTSUPP;
-		goto out;
-	}
-
-	if (memcmp(wl->mac_addr, conf->mac_addr, ETH_ALEN)) {
-		memcpy(wl->mac_addr, conf->mac_addr, ETH_ALEN);
-		SET_IEEE80211_PERM_ADDR(wl->hw, wl->mac_addr);
-		ret = wl12xx_acx_station_id(wl);
-		if (ret < 0)
-			goto out;
-	}
-
-out:
-	mutex_unlock(&wl->mutex);
-	return ret;
-}
-
-static void wl12xx_op_remove_interface(struct ieee80211_hw *hw,
-					 struct ieee80211_if_init_conf *conf)
-{
-	wl12xx_debug(DEBUG_MAC80211, "mac80211 remove interface");
-}
-
-static int wl12xx_build_null_data(struct wl12xx *wl)
-{
-	struct wl12xx_null_data_template template;
-
-	if (!is_zero_ether_addr(wl->bssid)) {
-		memcpy(template.header.da, wl->bssid, ETH_ALEN);
-		memcpy(template.header.bssid, wl->bssid, ETH_ALEN);
-	} else {
-		memset(template.header.da, 0xff, ETH_ALEN);
-		memset(template.header.bssid, 0xff, ETH_ALEN);
-	}
-
-	memcpy(template.header.sa, wl->mac_addr, ETH_ALEN);
-	template.header.frame_ctl = cpu_to_le16(IEEE80211_FTYPE_DATA |
-						IEEE80211_STYPE_NULLFUNC);
-
-	return wl12xx_cmd_template_set(wl, CMD_NULL_DATA, &template,
-				       sizeof(template));
-
-}
-
-static int wl12xx_build_ps_poll(struct wl12xx *wl, u16 aid)
-{
-	struct wl12xx_ps_poll_template template;
-
-	memcpy(template.bssid, wl->bssid, ETH_ALEN);
-	memcpy(template.ta, wl->mac_addr, ETH_ALEN);
-	template.aid = aid;
-	template.fc = cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_PSPOLL);
-
-	return wl12xx_cmd_template_set(wl, CMD_PS_POLL, &template,
-				       sizeof(template));
-
-}
-
-static int wl12xx_op_config_interface(struct ieee80211_hw *hw,
-				      struct ieee80211_vif *vif,
-				      struct ieee80211_if_conf *conf)
-{
-	struct wl12xx *wl = hw->priv;
-	struct sk_buff *beacon;
-	DECLARE_MAC_BUF(mac);
-	int ret;
-
-	wl12xx_debug(DEBUG_MAC80211, "mac80211 config_interface bssid %s",
-		     print_mac(mac, conf->bssid));
-	wl12xx_dump_ascii(DEBUG_MAC80211, "ssid: ", conf->ssid,
-			  conf->ssid_len);
-
-	mutex_lock(&wl->mutex);
-
-	memcpy(wl->bssid, conf->bssid, ETH_ALEN);
-
-	ret = wl12xx_build_null_data(wl);
-	if (ret < 0)
-		goto out;
-
-	wl->ssid_len = conf->ssid_len;
-	if (wl->ssid_len)
-		memcpy(wl->ssid, conf->ssid, wl->ssid_len);
-
-	if (wl->bss_type != BSS_TYPE_IBSS) {
-		ret = wl12xx_cmd_join(wl, wl->bss_type, 5, 100, 1);
-		if (ret < 0)
-			goto out;
-	}
-
-	if (conf->changed & IEEE80211_IFCC_BEACON) {
-		beacon = ieee80211_beacon_get(hw, vif);
-		ret = wl12xx_cmd_template_set(wl, CMD_BEACON, beacon->data,
-					      beacon->len);
-
-		if (ret < 0) {
-			dev_kfree_skb(beacon);
-			goto out;
-		}
-
-		ret = wl12xx_cmd_template_set(wl, CMD_PROBE_RESP, beacon->data,
-					      beacon->len);
- 
-		dev_kfree_skb(beacon);
-
-		if (ret < 0)
-			goto out;
-
-		ret = wl12xx_cmd_join(wl, wl->bss_type, 1, 100, 0);
-
-		if (ret < 0)
-			goto out;
-	}
-
-out:
-	mutex_unlock(&wl->mutex);
-	return ret;
-}
-
-static int wl12xx_op_config(struct ieee80211_hw *hw,
-			    struct ieee80211_conf *conf)
-{
-	struct wl12xx *wl = hw->priv;
-	int channel, ret = 0;
-
-	channel = ieee80211_frequency_to_channel(conf->channel->center_freq);
-
-	wl12xx_debug(DEBUG_MAC80211, "mac80211 config ch %d psm %s power %d",
-		     channel,
-		     conf->flags & IEEE80211_CONF_PS ? "on" : "off",
-		     conf->power_level);
-
-	mutex_lock(&wl->mutex);
-
-	if (channel != wl->channel) {
-		/* FIXME: use beacon interval provided by mac80211 */
-		ret = wl12xx_cmd_join(wl, wl->bss_type, 1, 100, 0);
-		if (ret < 0)
-			goto out;
-
-		wl->channel = channel;
-	}
-
-	ret = wl12xx_build_null_data(wl);
-	if (ret < 0)
-		goto out;
-
-	if (conf->flags & IEEE80211_CONF_PS && !wl->psm_requested) {
-		wl12xx_info("psm enabled");
-
-		wl->psm_requested = true;
-
-		/*
-		 * We enter PSM only if we're already associated.
-		 * If we're not, we'll enter it when joining an SSID,
-		 * through the bss_info_changed() hook.
-		 */
-		ret = wl12xx_ps_set_mode(wl, STATION_POWER_SAVE_MODE);
-	} else if (!(conf->flags & IEEE80211_CONF_PS) &&
-		   wl->psm_requested) {
-		wl12xx_info("psm disabled");
-
-		wl->psm_requested = false;
-
-		if (wl->psm) {
-			ret = wl12xx_ps_set_mode(wl, STATION_ACTIVE_MODE);
-		}
-	}
-
-	if (conf->power_level != wl->power_level) {
-		ret = wl12xx_acx_tx_power(wl, conf->power_level);
-		if (ret < 0)
-			goto out;
-
-		wl->power_level = conf->power_level;
-	}
-
-out:
-	mutex_unlock(&wl->mutex);
-	return ret;
-}
-
-#define WL12XX_SUPPORTED_FILTERS (FIF_PROMISC_IN_BSS | \
-				  FIF_ALLMULTI | \
-				  FIF_FCSFAIL | \
-				  FIF_BCN_PRBRESP_PROMISC | \
-				  FIF_CONTROL | \
-				  FIF_OTHER_BSS)
-
-static void wl12xx_op_configure_filter(struct ieee80211_hw *hw,
-				       unsigned int changed,
-				       unsigned int *total,
-				       int mc_count,
-				       struct dev_addr_list *mc_list)
-{
-	struct wl12xx *wl = hw->priv;
-
-	wl12xx_debug(DEBUG_MAC80211, "mac80211 configure filter");
-
-	*total &= WL12XX_SUPPORTED_FILTERS;
-	changed &= WL12XX_SUPPORTED_FILTERS;
-
-	if (changed == 0)
-		/* no filters which we support changed */
-		return;
-
-	/* FIXME: wl->rx_config and wl->rx_filter are not protected */
-
-	wl->rx_config = WL12XX_DEFAULT_RX_CONFIG;
-	wl->rx_filter = WL12XX_DEFAULT_RX_FILTER;
-
-	if (*total & FIF_PROMISC_IN_BSS) {
-		wl->rx_config |= CFG_BSSID_FILTER_EN;
-		wl->rx_config |= CFG_RX_ALL_GOOD;
-	}
-	if (*total & FIF_ALLMULTI)
-		/*
-		 * CFG_MC_FILTER_EN in rx_config needs to be 0 to receive
-		 * all multicast frames
-		 */
-		wl->rx_config &= ~CFG_MC_FILTER_EN;
-	if (*total & FIF_FCSFAIL)
-		wl->rx_filter |= CFG_RX_FCS_ERROR;
-	if (*total & FIF_BCN_PRBRESP_PROMISC) {
-		wl->rx_config &= ~CFG_BSSID_FILTER_EN;
-		wl->rx_config &= ~CFG_SSID_FILTER_EN;
-	}
-	if (*total & FIF_CONTROL)
-		wl->rx_filter |= CFG_RX_CTL_EN;
-	if (*total & FIF_OTHER_BSS)
-		wl->rx_filter &= ~CFG_BSSID_FILTER_EN;
-
-	/*
-	 * FIXME: workqueues need to be properly cancelled on stop(), for
-	 * now let's just disable changing the filter settings. They will
-	 * be updated any on config().
-	 */
-	/* schedule_work(&wl->filter_work); */
-}
-
-/* HW encryption */
-static int wl12xx_set_key_type(struct wl12xx *wl, struct acx_set_key *key,
-			       enum set_key_cmd cmd,
-			       struct ieee80211_key_conf *mac80211_key,
-			       const u8 *addr)
-{
-	switch (mac80211_key->alg) {
-	case ALG_WEP:
-		if (is_broadcast_ether_addr(addr))
-			key->key_type = KEY_WEP_DEFAULT;
-		else
-			key->key_type = KEY_WEP_ADDR;
-
-		mac80211_key->hw_key_idx = mac80211_key->keyidx;
-		break;
-	case ALG_TKIP:
-		if (is_broadcast_ether_addr(addr))
-			key->key_type = KEY_TKIP_MIC_GROUP;
-		else
-			key->key_type = KEY_TKIP_MIC_PAIRWISE;
-
-		mac80211_key->hw_key_idx = mac80211_key->keyidx;
-		break;
-	case ALG_CCMP:
-		if (is_broadcast_ether_addr(addr))
-			key->key_type = KEY_AES_GROUP;
-		else
-			key->key_type = KEY_AES_PAIRWISE;
-		mac80211_key->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;
-		break;
-	default:
-		wl12xx_error("Unknown key algo 0x%x", mac80211_key->alg);
-		return -EOPNOTSUPP;
-	}
-
-	return 0;
-}
-
-static int wl12xx_op_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
-			     const u8 *local_addr, const u8 *addr,
-			     struct ieee80211_key_conf *key)
-{
-	struct wl12xx *wl = hw->priv;
-	struct acx_set_key wl_key;
-	int ret;
-
-	wl12xx_debug(DEBUG_MAC80211, "mac80211 set key");
-
-	memset(&wl_key, 0, sizeof(wl_key));
-
-	wl12xx_debug(DEBUG_CRYPT, "CMD: 0x%x", cmd);
-	wl12xx_dump(DEBUG_CRYPT, "ADDR: ", addr, ETH_ALEN);
-	wl12xx_dump(DEBUG_CRYPT, "LOCAL_ADDR: ", local_addr, ETH_ALEN);
-	wl12xx_debug(DEBUG_CRYPT, "Key: algo:0x%x, id:%d, len:%d flags 0x%x",
-		     key->alg, key->keyidx, key->keylen, key->flags);
-	wl12xx_dump(DEBUG_CRYPT, "KEY: ", key->key, key->keylen);
-
-	if (is_zero_ether_addr(addr))
-		/* We dont support TX only encryption */
-		return -EOPNOTSUPP;
-
-	mutex_lock(&wl->mutex);
-
-	switch (cmd) {
-	case SET_KEY:
-		wl_key.key_action = KEY_ADD_OR_REPLACE;
-		break;
-	case DISABLE_KEY:
-		wl_key.key_action = KEY_REMOVE;
-		break;
-	default:
-		wl12xx_error("Unsupported key cmd 0x%x", cmd);
-		break;
-	}
-
-	ret = wl12xx_set_key_type(wl, &wl_key, cmd, key, addr);
-	if (ret < 0) {
-		wl12xx_error("Set KEY type failed");
-		goto out;
-	}
-
-	if (wl_key.key_type != KEY_WEP_DEFAULT)
-		memcpy(wl_key.addr, addr, ETH_ALEN);
-
-	if ((wl_key.key_type == KEY_TKIP_MIC_GROUP) ||
-	    (wl_key.key_type == KEY_TKIP_MIC_PAIRWISE)) {
-		/*
-		 * We get the key in the following form:
-		 * TKIP (16 bytes) - TX MIC (8 bytes) - RX MIC (8 bytes)
-		 * but the target is expecting:
-		 * TKIP - RX MIC - TX MIC
-		 */
-		memcpy(wl_key.key, key->key, 16);
-		memcpy(wl_key.key + 16, key->key + 24, 8);
-		memcpy(wl_key.key + 24, key->key + 16, 8);
-
-	} else {
-		memcpy(wl_key.key, key->key, key->keylen);
-	}
-	wl_key.key_size = key->keylen;
-
-	wl_key.id = key->keyidx;
-	wl_key.ssid_profile = 0;
-
-	wl12xx_dump(DEBUG_CRYPT, "TARGET KEY: ", &wl_key, sizeof(wl_key));
-
-	if (wl12xx_cmd_send(wl, CMD_SET_KEYS, &wl_key, sizeof(wl_key)) < 0) {
-		wl12xx_error("Set KEY failed");
-		ret = -EOPNOTSUPP;
-		goto out;
-	}
-
-out:
-	mutex_unlock(&wl->mutex);
-	return ret;
-}
-
-static int wl12xx_build_basic_rates(char *rates)
-{
-	u8 index = 0;
-
-	rates[index++] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_1MB;
-	rates[index++] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_2MB;
-	rates[index++] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_5MB;
-	rates[index++] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_11MB;
-
-	return index;
-}
-
-static int wl12xx_build_extended_rates(char *rates)
-{
-	u8 index = 0;
-
-	rates[index++] = IEEE80211_OFDM_RATE_6MB;
-	rates[index++] = IEEE80211_OFDM_RATE_9MB;
-	rates[index++] = IEEE80211_OFDM_RATE_12MB;
-	rates[index++] = IEEE80211_OFDM_RATE_18MB;
-	rates[index++] = IEEE80211_OFDM_RATE_24MB;
-	rates[index++] = IEEE80211_OFDM_RATE_36MB;
-	rates[index++] = IEEE80211_OFDM_RATE_48MB;
-	rates[index++] = IEEE80211_OFDM_RATE_54MB;
-
-	return index;
-}
-
-
-static int wl12xx_build_probe_req(struct wl12xx *wl, u8 *ssid, size_t ssid_len)
-{
-	struct wl12xx_probe_req_template template;
-	struct wl12xx_ie_rates *rates;
-	char *ptr;
-	u16 size;
-
-	ptr = (char *)&template;
-	size = sizeof(struct ieee80211_header);
-
-	memset(template.header.da, 0xff, ETH_ALEN);
-	memset(template.header.bssid, 0xff, ETH_ALEN);
-	memcpy(template.header.sa, wl->mac_addr, ETH_ALEN);
-	template.header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_PROBE_REQ);
-
-	/* IEs */
-	/* SSID */
-	template.ssid.header.id = WLAN_EID_SSID;
-	template.ssid.header.len = ssid_len;
-	if (ssid_len && ssid)
-		memcpy(template.ssid.ssid, ssid, ssid_len);
-	size += sizeof(struct wl12xx_ie_header) + ssid_len;
-	ptr += size;
-
-	/* Basic Rates */
-	rates = (struct wl12xx_ie_rates *)ptr;
-	rates->header.id = WLAN_EID_SUPP_RATES;
-	rates->header.len = wl12xx_build_basic_rates(rates->rates);
-	size += sizeof(struct wl12xx_ie_header) + rates->header.len;
-	ptr += sizeof(struct wl12xx_ie_header) + rates->header.len;
-
-	/* Extended rates */
-	rates = (struct wl12xx_ie_rates *)ptr;
-	rates->header.id = WLAN_EID_EXT_SUPP_RATES;
-	rates->header.len = wl12xx_build_extended_rates(rates->rates);
-	size += sizeof(struct wl12xx_ie_header) + rates->header.len;
-
-	wl12xx_dump(DEBUG_SCAN, "PROBE REQ: ", &template, size);
-
-	return wl12xx_cmd_template_set(wl, CMD_PROBE_REQ, &template,
-				      size);
-}
-
-static int wl12xx_hw_scan(struct wl12xx *wl, u8 *ssid, size_t len,
-			  u8 active_scan, u8 high_prio, u8 num_channels,
-			  u8 probe_requests)
-{
-	int i, ret;
-	u32 split_scan = 0;
-	u16 scan_options = 0;
-	struct cmd_scan *params;
-	struct wl12xx_command *cmd_answer;
-
-	if (wl->scanning)
-		return -EINVAL;
-
-	params = kzalloc(sizeof(*params), GFP_KERNEL);
-	if (!params)
-		return -ENOMEM;
-
-	params->params.rx_config_options = cpu_to_le32(CFG_RX_ALL_GOOD);
-	params->params.rx_filter_options =
-		cpu_to_le32(CFG_RX_PRSP_EN | CFG_RX_MGMT_EN | CFG_RX_BCN_EN);
-
-	/* High priority scan */
-	if (!active_scan)
-		scan_options |= SCAN_PASSIVE;
-	if (high_prio)
-		scan_options |= SCAN_PRIORITY_HIGH;
-	params->params.scan_options = scan_options;
-
-	params->params.num_channels = num_channels;
-	params->params.num_probe_requests = probe_requests;
-	params->params.tx_rate = cpu_to_le16(1 << 1); /* 2 Mbps */
-	params->params.tid_trigger = 0;
-
-	for (i = 0; i < num_channels; i++) {
-		params->channels[i].min_duration = cpu_to_le32(30000);
-		params->channels[i].max_duration = cpu_to_le32(60000);
-		memset(&params->channels[i].bssid_lsb, 0xff, 4);
-		memset(&params->channels[i].bssid_msb, 0xff, 2);
-		params->channels[i].early_termination = 0;
-		params->channels[i].tx_power_att = 0;
-		params->channels[i].channel = i + 1;
-		memset(params->channels[i].pad, 0, 3);
-	}
-
-	for (i = num_channels; i < SCAN_MAX_NUM_OF_CHANNELS; i++)
-		memset(&params->channels[i], 0,
-		       sizeof(struct basic_scan_channel_parameters));
-
-	if (len && ssid) {
-		params->params.ssid_len = len;
-		memcpy(params->params.ssid, ssid, len);
-	} else {
-		params->params.ssid_len = 0;
-		memset(params->params.ssid, 0, 32);
-	}
-
-	ret = wl12xx_build_probe_req(wl, ssid, len);
-	if (ret < 0) {
-		wl12xx_error("PROBE request template failed");
-		goto out;
-	}
-
-	ret = wl12xx_cmd_send(wl, CMD_TRIGGER_SCAN_TO, &split_scan,
-			      sizeof(u32));
-	if (ret < 0) {
-		wl12xx_error("Split SCAN failed");
-		goto out;
-	}
-
-	wl12xx_dump(DEBUG_SCAN, "SCAN: ", params, sizeof(*params));
-
-	wl->scanning = true;
-
-	ret = wl12xx_cmd_send(wl, CMD_SCAN, params, sizeof(*params));
-	if (ret < 0)
-		wl12xx_error("SCAN failed");
-
-	wl12xx_spi_mem_read(wl, wl->cmd_box_addr, params, sizeof(*params));
-
-	cmd_answer = (struct wl12xx_command *) params;
-	if (cmd_answer->status != CMD_STATUS_SUCCESS) {
-		wl12xx_error("TEST command answer error: %d",
-			     cmd_answer->status);
-		wl->scanning = false;
-		ret = -EIO;
-		goto out;
-	}
-
-out:
-	kfree(params);
-	return ret;
-
-}
-
-static int wl12xx_op_hw_scan(struct ieee80211_hw *hw, u8 *ssid, size_t len)
-{
-	struct wl12xx *wl = hw->priv;
-	int ret;
-
-	wl12xx_debug(DEBUG_MAC80211, "mac80211 hw scan");
-
-	mutex_lock(&wl->mutex);
-	ret = wl12xx_hw_scan(hw->priv, ssid, len, 1, 0, 13, 3);
-	mutex_unlock(&wl->mutex);
-
-	return ret;
-}
-
-static int wl12xx_op_set_rts_threshold(struct ieee80211_hw *hw, u32 value)
-{
-	struct wl12xx *wl = hw->priv;
-	int ret;
-
-	ret = wl12xx_acx_rts_threshold(wl, (u16) value);
-
-	if (ret < 0)
-		wl12xx_warning("wl12xx_op_set_rts_threshold failed: %d", ret);
-
-	return ret;
-}
-
-static void wl12xx_op_bss_info_changed(struct ieee80211_hw *hw,
-				       struct ieee80211_vif *vif,
-				       struct ieee80211_bss_conf *bss_conf,
-				       u32 changed)
-{
-	enum acx_ps_mode mode;
-	struct wl12xx *wl = hw->priv;
-	int ret;
-
-	wl12xx_debug(DEBUG_MAC80211, "mac80211 bss info changed");
-
-	mutex_lock(&wl->mutex);
-
-	if (changed & BSS_CHANGED_ASSOC) {
-		if (bss_conf->assoc) {
-			wl->aid = bss_conf->aid;
-
-			ret = wl12xx_build_ps_poll(wl, wl->aid);
-			if (ret < 0)
-				goto out;
-
-			ret = wl12xx_acx_aid(wl, wl->aid);
-			if (ret < 0)
-				goto out;
-
-			/* If we want to go in PSM but we're not there yet */
-			if (wl->psm_requested && !wl->psm) {
-				mode = STATION_POWER_SAVE_MODE;
-				ret = wl12xx_ps_set_mode(wl, mode);
-				if (ret < 0)
-					goto out;
-			}
-		}
-	}
-	if (changed & BSS_CHANGED_ERP_SLOT) {
-		if (bss_conf->use_short_slot)
-			ret = wl12xx_acx_slot(wl, SLOT_TIME_SHORT);
-		else
-			ret = wl12xx_acx_slot(wl, SLOT_TIME_LONG);
-		if (ret < 0) {
-			wl12xx_warning("Set slot time failed %d", ret);
-			goto out;
-		}
-	}
-
-	if (changed & BSS_CHANGED_ERP_PREAMBLE) {
-		if (bss_conf->use_short_preamble)
-			wl12xx_acx_set_preamble(wl, ACX_PREAMBLE_SHORT);
-		else
-			wl12xx_acx_set_preamble(wl, ACX_PREAMBLE_LONG);
-	}
-
-	if (changed & BSS_CHANGED_ERP_CTS_PROT) {
-		if (bss_conf->use_cts_prot)
-			ret = wl12xx_acx_cts_protect(wl, CTSPROTECT_ENABLE);
-		else
-			ret = wl12xx_acx_cts_protect(wl, CTSPROTECT_DISABLE);
-		if (ret < 0) {
-			wl12xx_warning("Set ctsprotect failed %d", ret);
-			goto out;
-		}
-	}
-
-out:
-	mutex_unlock(&wl->mutex);
-}
-
-
-/* can't be const, mac80211 writes to this */
-static struct ieee80211_rate wl12xx_rates[] = {
-	{ .bitrate = 10,
-	  .hw_value = 0x1,
-	  .hw_value_short = 0x1, },
-	{ .bitrate = 20,
-	  .hw_value = 0x2,
-	  .hw_value_short = 0x2,
-	  .flags = IEEE80211_RATE_SHORT_PREAMBLE },
-	{ .bitrate = 55,
-	  .hw_value = 0x4,
-	  .hw_value_short = 0x4,
-	  .flags = IEEE80211_RATE_SHORT_PREAMBLE },
-	{ .bitrate = 110,
-	  .hw_value = 0x20,
-	  .hw_value_short = 0x20,
-	  .flags = IEEE80211_RATE_SHORT_PREAMBLE },
-	{ .bitrate = 60,
-	  .hw_value = 0x8,
-	  .hw_value_short = 0x8, },
-	{ .bitrate = 90,
-	  .hw_value = 0x10,
-	  .hw_value_short = 0x10, },
-	{ .bitrate = 120,
-	  .hw_value = 0x40,
-	  .hw_value_short = 0x40, },
-	{ .bitrate = 180,
-	  .hw_value = 0x80,
-	  .hw_value_short = 0x80, },
-	{ .bitrate = 240,
-	  .hw_value = 0x200,
-	  .hw_value_short = 0x200, },
-	{ .bitrate = 360,
-	 .hw_value = 0x400,
-	 .hw_value_short = 0x400, },
-	{ .bitrate = 480,
-	  .hw_value = 0x800,
-	  .hw_value_short = 0x800, },
-	{ .bitrate = 540,
-	  .hw_value = 0x1000,
-	  .hw_value_short = 0x1000, },
-};
-
-/* can't be const, mac80211 writes to this */
-static struct ieee80211_channel wl12xx_channels[] = {
-	{ .hw_value = 1, .center_freq = 2412},
-	{ .hw_value = 2, .center_freq = 2417},
-	{ .hw_value = 3, .center_freq = 2422},
-	{ .hw_value = 4, .center_freq = 2427},
-	{ .hw_value = 5, .center_freq = 2432},
-	{ .hw_value = 6, .center_freq = 2437},
-	{ .hw_value = 7, .center_freq = 2442},
-	{ .hw_value = 8, .center_freq = 2447},
-	{ .hw_value = 9, .center_freq = 2452},
-	{ .hw_value = 10, .center_freq = 2457},
-	{ .hw_value = 11, .center_freq = 2462},
-	{ .hw_value = 12, .center_freq = 2467},
-	{ .hw_value = 13, .center_freq = 2472},
-};
-
-/* can't be const, mac80211 writes to this */
-static struct ieee80211_supported_band wl12xx_band_2ghz = {
-	.channels = wl12xx_channels,
-	.n_channels = ARRAY_SIZE(wl12xx_channels),
-	.bitrates = wl12xx_rates,
-	.n_bitrates = ARRAY_SIZE(wl12xx_rates),
-};
-
-static const struct ieee80211_ops wl12xx_ops = {
-	.start = wl12xx_op_start,
-	.stop = wl12xx_op_stop,
-	.add_interface = wl12xx_op_add_interface,
-	.remove_interface = wl12xx_op_remove_interface,
-	.config = wl12xx_op_config,
-	.config_interface = wl12xx_op_config_interface,
-	.configure_filter = wl12xx_op_configure_filter,
-	.tx = wl12xx_op_tx,
-	.set_key = wl12xx_op_set_key,
-	.hw_scan = wl12xx_op_hw_scan,
- 	.bss_info_changed = wl12xx_op_bss_info_changed,
-	.set_rts_threshold = wl12xx_op_set_rts_threshold,
-};
-
-static int wl12xx_register_hw(struct wl12xx *wl)
-{
-	int ret;
-
-	if (wl->mac80211_registered)
-		return 0;
-
-	SET_IEEE80211_PERM_ADDR(wl->hw, wl->mac_addr);
-
-	ret = ieee80211_register_hw(wl->hw);
-	if (ret < 0) {
-		wl12xx_error("unable to register mac80211 hw: %d", ret);
-		return ret;
-	}
-
-	wl->mac80211_registered = true;
-
-	wl12xx_notice("loaded");
-
-	return 0;
-}
-
-static int wl12xx_init_ieee80211(struct wl12xx *wl)
-{
-	/* The tx descriptor buffer and the TKIP space */
-	wl->hw->extra_tx_headroom = sizeof(struct tx_double_buffer_desc)
-		+ WL12XX_TKIP_IV_SPACE;
-
-	/* unit us */
-	/* FIXME: find a proper value */
-	wl->hw->channel_change_time = 10000;
-
-	wl->hw->flags = IEEE80211_HW_SIGNAL_DBM |
-		IEEE80211_HW_NOISE_DBM;
-
-	wl->hw->wiphy->bands[IEEE80211_BAND_2GHZ] = &wl12xx_band_2ghz;
-
-	SET_IEEE80211_DEV(wl->hw, &wl->spi->dev);
-
-	return 0;
-}
-
-static void wl12xx_device_release(struct device *dev)
-{
-
-}
-
-static struct platform_device wl12xx_device = {
-	.name		= "wl12xx",
-	.id		= -1,
-
-	/* device model insists to have a release function */
-	.dev            = {
-		.release = wl12xx_device_release,
-	},
-};
-
-#define WL12XX_DEFAULT_CHANNEL 1
-static int __devinit wl12xx_probe(struct spi_device *spi)
-{
-	struct wl12xx_platform_data *pdata;
-	struct ieee80211_hw *hw;
-	struct wl12xx *wl;
-	int ret, i;
-	static const u8 nokia_oui[3] = {0x00, 0x1f, 0xdf};
-
-	pdata = spi->dev.platform_data;
-	if (!pdata) {
-		wl12xx_error("no platform data");
-		return -ENODEV;
-	}
-
-	hw = ieee80211_alloc_hw(sizeof(*wl), &wl12xx_ops);
-	if (!hw) {
-		wl12xx_error("could not alloc ieee80211_hw");
-		return -ENOMEM;
-	}
-
-	wl = hw->priv;
-	memset(wl, 0, sizeof(*wl));
-
-	wl->hw = hw;
-	dev_set_drvdata(&spi->dev, wl);
-	wl->spi = spi;
-
-	wl->data_in_count = 0;
-
-	skb_queue_head_init(&wl->tx_queue);
-
-	INIT_WORK(&wl->tx_work, wl12xx_tx_work);
-	INIT_WORK(&wl->filter_work, wl12xx_filter_work);
-	wl->channel = WL12XX_DEFAULT_CHANNEL;
-	wl->scanning = false;
-	wl->default_key = 0;
-	wl->listen_int = 1;
-	wl->rx_counter = 0;
-	wl->rx_handled = 0;
-	wl->rx_current_buffer = 0;
-	wl->rx_last_id = 0;
-	wl->rx_config = WL12XX_DEFAULT_RX_CONFIG;
-	wl->rx_filter = WL12XX_DEFAULT_RX_FILTER;
-	wl->elp = false;
-	wl->psm = 0;
-	wl->psm_requested = false;
-	wl->tx_queue_stopped = false;
-	wl->power_level = WL12XX_DEFAULT_POWER_LEVEL;
-
-	/* We use the default power on sleep time until we know which chip
-	 * we're using */
-	wl->chip.power_on_sleep = WL12XX_DEFAULT_POWER_ON_SLEEP;
-
-	for (i = 0; i < FW_TX_CMPLT_BLOCK_SIZE; i++)
-		wl->tx_frames[i] = NULL;
-
-	wl->next_tx_complete = 0;
-
-	/*
-	 * In case our MAC address is not correctly set,
-	 * we use a random but Nokia MAC.
-	 */
-	memcpy(wl->mac_addr, nokia_oui, 3);
-	get_random_bytes(wl->mac_addr + 3, 3);
-
-	wl->state = WL12XX_STATE_OFF;
-	mutex_init(&wl->mutex);
-
-	wl->tx_mgmt_frm_rate = DEFAULT_HW_GEN_TX_RATE;
-	wl->tx_mgmt_frm_mod = DEFAULT_HW_GEN_MODULATION_TYPE;
-
-	/* This is the only SPI value that we need to set here, the rest
-	 * comes from the board-peripherals file */
-	spi->bits_per_word = 32;
-
-	ret = spi_setup(spi);
-	if (ret < 0) {
-		wl12xx_error("spi_setup failed");
-		goto out_free;
-	}
-
-	wl->set_power = pdata->set_power;
-	if (!wl->set_power) {
-		wl12xx_error("set power function missing in platform data");
-		return -ENODEV;
-	}
-
-	wl->irq = spi->irq;
-	if (wl->irq < 0) {
-		wl12xx_error("irq missing in platform data");
-		return -ENODEV;
-	}
-
-	ret = request_irq(wl->irq, wl12xx_irq, 0, DRIVER_NAME, wl);
-	if (ret < 0) {
-		wl12xx_error("request_irq() failed: %d", ret);
-		goto out_free;
-	}
-
-	set_irq_type(wl->irq, IRQ_TYPE_EDGE_RISING);
-
-	disable_irq(wl->irq);
-
-	ret = platform_device_register(&wl12xx_device);
-	if (ret) {
-		wl12xx_error("couldn't register platform device");
-		goto out_irq;
-	}
-	dev_set_drvdata(&wl12xx_device.dev, wl);
-
-	ret = wl12xx_init_ieee80211(wl);
-	if (ret)
-		goto out_platform;
-
-	ret = wl12xx_register_hw(wl);
-	if (ret)
-		goto out_platform;
-
-	ret = wl12xx_nl_register();
-	if (ret)
-		goto out_register_hw;
-
-	ret = device_create_file(&wl12xx_device.dev,
-				 &dev_attr_tx_mgmt_frm_rate);
-	if (ret < 0) {
-		wl12xx_error("failed to create sysfs file tx_mgmt_frm_rate");
-		goto out_register_hw;
-	}
-
-	wl12xx_notice("initialized");
-
-	return 0;
-
- out_register_hw:
-	ieee80211_unregister_hw(hw);
-	wl->mac80211_registered = false;
-
- out_platform:
-	platform_device_unregister(&wl12xx_device);
-
- out_irq:
-	free_irq(wl->irq, wl);
-
- out_free:
-	ieee80211_free_hw(hw);
-
-	return ret;
-}
-
-static int __devexit wl12xx_remove(struct spi_device *spi)
-{
-	struct wl12xx *wl = dev_get_drvdata(&spi->dev);
-
-	ieee80211_unregister_hw(wl->hw);
-	platform_device_unregister(&wl12xx_device);
-	free_irq(wl->irq, wl);
-	kfree(wl->target_mem_map);
-	kfree(wl->data_path);
-	kfree(wl->fw);
-	wl->fw = NULL;
-	kfree(wl->nvs);
-	wl->nvs = NULL;
-	ieee80211_free_hw(wl->hw);
-	wl12xx_nl_unregister();
-
-	return 0;
-}
-
-
-static struct spi_driver wl12xx_spi_driver = {
-	.driver = {
-		.name		= "wl12xx",
-		.bus		= &spi_bus_type,
-		.owner		= THIS_MODULE,
-	},
-
-	.probe		= wl12xx_probe,
-	.remove		= __devexit_p(wl12xx_remove),
-};
-
-static int __init wl12xx_init(void)
-{
-	int ret;
-
-	ret = spi_register_driver(&wl12xx_spi_driver);
-	if (ret < 0) {
-		wl12xx_error("failed to register spi driver: %d", ret);
-		goto out;
-	}
-
-out:
-	return ret;
-}
-
-static void __exit wl12xx_exit(void)
-{
-	spi_unregister_driver(&wl12xx_spi_driver);
-
-	wl12xx_notice("unloaded");
-}
-
-module_init(wl12xx_init);
-module_exit(wl12xx_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Kalle Valo <Kalle.Valo@nokia.com>, "
-		"Luciano Coelho <luciano.coelho@nokia.com>");
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/Makefile kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/Makefile
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/Makefile	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/Makefile	2012-12-16 13:13:01.680330145 +0100
@@ -1,3 +1,13 @@
-wl12xx-objs		= main.o spi.o netlink.o event.o tx.o rx.o \
-			  ps.o cmd.o acx.o boot.o init.o wl1251.o wl1271.o
-obj-$(CONFIG_WL12XX)	+= wl12xx.o
+# FIXME: use wl12xx.ko for now to not break the user space
+wl12xx-objs		= wl1251_main.o wl1251_netlink.o wl1251_event.o \
+			  wl1251_tx.o wl1251_rx.o wl1251_ps.o wl1251_cmd.o \
+			  wl1251_acx.o wl1251_boot.o wl1251_init.o \
+			  wl1251_debugfs.o wl1251_spi.o
+obj-$(CONFIG_WL1251)	+= wl12xx.o
+
+wl1271-objs		= wl1271_main.o wl1271_spi.o wl1271_cmd.o \
+			  wl1271_netlink.o wl1271_event.o \
+			  wl1271_tx.o wl1271_rx.o wl1271_ps.o \
+			  wl1271_acx.o wl1271_boot.o wl1271_init.o \
+			  wl1271_debugfs.o
+obj-$(CONFIG_WL1271)	+= wl1271.o
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/netlink.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/netlink.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/netlink.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/netlink.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,607 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (C) 2008 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-#include "netlink.h"
-
-#include <linux/socket.h>
-#include <net/net_namespace.h>
-#include <net/sock.h>
-#include <net/genetlink.h>
-#include <net/wireless.h>
-#include <net/mac80211.h>
-
-#include "wl12xx.h"
-#include "spi.h"
-
-/* FIXME: this should be changed as soon as user space catches up */
-#define WL12XX_NL_NAME "wl1251"
-#define WL12XX_NL_VERSION 1
-
-#define WL12XX_MAX_TEST_LENGTH 1024
-#define WL12XX_MAX_NVS_LENGTH 1024
-
-enum wl12xx_nl_commands {
-	WL12XX_NL_CMD_UNSPEC,
-	WL12XX_NL_CMD_TEST,
-	WL12XX_NL_CMD_INTERROGATE,
-	WL12XX_NL_CMD_CONFIGURE,
-	WL12XX_NL_CMD_PHY_REG_READ,
-	WL12XX_NL_CMD_NVS_PUSH,
-	WL12XX_NL_CMD_REG_WRITE,
-	WL12XX_NL_CMD_REG_READ,
-	WL12XX_NL_CMD_SET_PLT_MODE,
-
-	__WL12XX_NL_CMD_AFTER_LAST
-};
-#define WL12XX_NL_CMD_MAX (__WL12XX_NL_CMD_AFTER_LAST - 1)
-
-enum wl12xx_nl_attrs {
-	WL12XX_NL_ATTR_UNSPEC,
-	WL12XX_NL_ATTR_IFNAME,
-	WL12XX_NL_ATTR_CMD_TEST_PARAM,
-	WL12XX_NL_ATTR_CMD_TEST_ANSWER,
-	WL12XX_NL_ATTR_CMD_IE,
-	WL12XX_NL_ATTR_CMD_IE_LEN,
-	WL12XX_NL_ATTR_CMD_IE_BUFFER,
-	WL12XX_NL_ATTR_CMD_IE_ANSWER,
-	WL12XX_NL_ATTR_REG_ADDR,
-	WL12XX_NL_ATTR_REG_VAL,
-	WL12XX_NL_ATTR_NVS_BUFFER,
-	WL12XX_NL_ATTR_NVS_LEN,
-	WL12XX_NL_ATTR_PLT_MODE,
-
-	__WL12XX_NL_ATTR_AFTER_LAST
-};
-#define WL12XX_NL_ATTR_MAX (__WL12XX_NL_ATTR_AFTER_LAST - 1)
-
-static struct genl_family wl12xx_nl_family = {
-	.id = GENL_ID_GENERATE,
-	.name = WL12XX_NL_NAME,
-	.hdrsize = 0,
-	.version = WL12XX_NL_VERSION,
-	.maxattr = WL12XX_NL_ATTR_MAX,
-};
-
-static struct net_device *ifname_to_netdev(struct net *net,
-					   struct genl_info *info)
-{
-	char *ifname;
-
-	if (!info->attrs[WL12XX_NL_ATTR_IFNAME])
-		return NULL;
-
-	ifname = nla_data(info->attrs[WL12XX_NL_ATTR_IFNAME]);
-
-	wl12xx_debug(DEBUG_NETLINK, "Looking for %s", ifname);
-
-	return dev_get_by_name(net, ifname);
-}
-
-static struct wl12xx *ifname_to_wl12xx(struct net *net, struct genl_info *info)
-{
-	struct net_device *netdev;
-	struct wireless_dev *wdev;
-	struct wiphy *wiphy;
-	struct ieee80211_hw *hw;
-
-	netdev = ifname_to_netdev(net, info);
-	if (netdev == NULL) {
-		wl12xx_error("Wrong interface");
-		return NULL;
-	}
-
-	wdev = netdev->ieee80211_ptr;
-	if (wdev == NULL) {
-		wl12xx_error("ieee80211_ptr is NULL");
-		return NULL;
-	}
-
-	wiphy = wdev->wiphy;
-	if (wiphy == NULL) {
-		wl12xx_error("wiphy is NULL");
-		return NULL;
-	}
-
-	hw = wiphy_priv(wiphy);
-	if (hw == NULL) {
-		wl12xx_error("hw is NULL");
-		return NULL;
-	}
-
-	dev_put(netdev);
-
-	return hw->priv;
-}
-
-static int wl12xx_nl_test_cmd(struct sk_buff *skb, struct genl_info *info)
-{
-	struct wl12xx *wl;
-	char *cmd;
-	int cmd_len, ret;
-	u8 answer;
-
-	if (!info->attrs[WL12XX_NL_ATTR_CMD_TEST_PARAM])
-		return -EINVAL;
-
-	wl = ifname_to_wl12xx(&init_net, info);
-	if (wl == NULL) {
-		wl12xx_error("wl12xx not found");
-		return -EINVAL;
-	}
-
-	cmd = nla_data(info->attrs[WL12XX_NL_ATTR_CMD_TEST_PARAM]);
-	cmd_len = nla_len(info->attrs[WL12XX_NL_ATTR_CMD_TEST_PARAM]);
-	answer = nla_get_u8(info->attrs[WL12XX_NL_ATTR_CMD_TEST_ANSWER]);
-
-	ret = wl12xx_cmd_test(wl, cmd, cmd_len, answer);
-	if (ret < 0) {
-		wl12xx_error("%s() failed", __func__);
-		return ret;
-	}
-
-	if (answer) {
-		struct sk_buff *msg;
-		void *hdr;
-
-		msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
-		if (!msg)
-			return -ENOMEM;
-
-		hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq,
-				  &wl12xx_nl_family, 0, WL12XX_NL_CMD_TEST);
-		if (IS_ERR(hdr)) {
-			ret = PTR_ERR(hdr);
-			goto nla_put_failure;
-		}
-
-		NLA_PUT_STRING(msg, WL12XX_NL_ATTR_IFNAME,
-			       nla_data(info->attrs[WL12XX_NL_ATTR_IFNAME]));
-		NLA_PUT(msg, WL12XX_NL_ATTR_CMD_TEST_ANSWER,
-			cmd_len, cmd);
-
-		ret = genlmsg_end(msg, hdr);
-		if (ret < 0) {
-			wl12xx_error("%s() failed", __func__);
-			goto nla_put_failure;
-		}
-
-		wl12xx_debug(DEBUG_NETLINK, "TEST cmd sent, answer");
-		return genlmsg_reply(msg, info);
-
- nla_put_failure:
-		nlmsg_free(msg);
-
-		return ret;
-	}
-
-	wl12xx_debug(DEBUG_NETLINK, "TEST cmd sent");
-
-	return 0;
-}
-
-static int wl12xx_nl_interrogate(struct sk_buff *skb, struct genl_info *info)
-{
-	struct wl12xx *wl;
-	struct sk_buff *msg;
-	int ret = -ENOBUFS, cmd_ie, cmd_ie_len;
-	struct wl12xx_command cmd;
-	void *hdr;
-
-	if (!info->attrs[WL12XX_NL_ATTR_CMD_IE])
-		return -EINVAL;
-
-	if (!info->attrs[WL12XX_NL_ATTR_CMD_IE_LEN])
-		return -EINVAL;
-
-	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
-	if (!msg)
-		return -ENOMEM;
-
-	wl = ifname_to_wl12xx(&init_net, info);
-	if (wl == NULL) {
-		wl12xx_error("wl12xx not found");
-		ret = -EINVAL;
-		goto nla_put_failure;
-	}
-
-	cmd_ie = nla_get_u32(info->attrs[WL12XX_NL_ATTR_CMD_IE]);
-	cmd_ie_len = nla_get_u32(info->attrs[WL12XX_NL_ATTR_CMD_IE_LEN]);
-
-	wl12xx_debug(DEBUG_NETLINK, "Getting IE 0x%x (len %d)",
-		     cmd_ie, cmd_ie_len);
-
-	ret = wl12xx_cmd_interrogate(wl, cmd_ie, cmd_ie_len,
-				     &cmd);
-	if (ret < 0) {
-		wl12xx_error("%s() failed", __func__);
-		return ret;
-	}
-
-	hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq,
-			  &wl12xx_nl_family, 0, WL12XX_NL_CMD_INTERROGATE);
-	if (IS_ERR(hdr)) {
-		ret = PTR_ERR(hdr);
-		goto nla_put_failure;
-	}
-
-	NLA_PUT_STRING(msg, WL12XX_NL_ATTR_IFNAME,
-		       nla_data(info->attrs[WL12XX_NL_ATTR_IFNAME]));
-	NLA_PUT(msg, WL12XX_NL_ATTR_CMD_IE_ANSWER, sizeof(cmd), &cmd);
-
-	ret = genlmsg_end(msg, hdr);
-	if (ret < 0) {
-		wl12xx_error("%s() failed", __func__);
-		goto nla_put_failure;
-	}
-
-	return genlmsg_reply(msg, info);
-
- nla_put_failure:
-	nlmsg_free(msg);
-
-	return ret;
-}
-
-static int wl12xx_nl_configure(struct sk_buff *skb, struct genl_info *info)
-{
-	struct wl12xx *wl;
-	struct sk_buff *msg;
-	int ret = 0, cmd_ie_len;
-	char *cmd_ie_buffer;
-
-	if (!info->attrs[WL12XX_NL_ATTR_CMD_IE_BUFFER])
-		return -EINVAL;
-
-	if (!info->attrs[WL12XX_NL_ATTR_CMD_IE_LEN])
-		return -EINVAL;
-
-	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
-	if (!msg)
-		return -ENOMEM;
-
-	wl = ifname_to_wl12xx(&init_net, info);
-	if (wl == NULL) {
-		wl12xx_error("wl12xx not found");
-		ret = -EINVAL;
-		goto nla_put_failure;
-	}
-
-	cmd_ie_buffer = nla_data(info->attrs[WL12XX_NL_ATTR_CMD_IE_BUFFER]);
-	cmd_ie_len = nla_get_u32(info->attrs[WL12XX_NL_ATTR_CMD_IE_LEN]);
-
-	ret = wl12xx_cmd_configure(wl, cmd_ie_buffer, cmd_ie_len);
-	if (ret < 0) {
-		wl12xx_error("%s() failed", __func__);
-		goto nla_put_failure;
-	}
-
-	wl12xx_debug(DEBUG_NETLINK, "CONFIGURE cmd sent");
-
- nla_put_failure:
-	nlmsg_free(msg);
-
-	return ret;
-}
-
-static int wl12xx_nl_phy_reg_read(struct sk_buff *skb, struct genl_info *info)
-{
-	struct wl12xx *wl;
-	struct sk_buff *msg;
-	u32 reg_addr, reg_value;
-	int ret = 0;
-	void *hdr;
-
-	if (!info->attrs[WL12XX_NL_ATTR_REG_ADDR])
-		return -EINVAL;
-
-	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
-	if (!msg)
-		return -ENOMEM;
-
-	wl = ifname_to_wl12xx(&init_net, info);
-	if (wl == NULL) {
-		wl12xx_error("wl12xx not found");
-		ret = -EINVAL;
-		goto nla_put_failure;
-	}
-
-	reg_addr = nla_get_u32(info->attrs[WL12XX_NL_ATTR_REG_ADDR]);
-
-	wl12xx_debug(DEBUG_NETLINK, "Reading PHY reg 0x%x", reg_addr);
-
-	ret = wl12xx_cmd_read_memory(wl, reg_addr, sizeof(reg_value),
-				     &reg_value);
-	if (ret < 0) {
-		wl12xx_error("%s() failed", __func__);
-		goto nla_put_failure;
-	}
-
-
-	hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq,
-			  &wl12xx_nl_family, 0, WL12XX_NL_CMD_PHY_REG_READ);
-	if (IS_ERR(hdr)) {
-		ret = PTR_ERR(hdr);
-		goto nla_put_failure;
-	}
-
-	NLA_PUT_STRING(msg, WL12XX_NL_ATTR_IFNAME,
-		       nla_data(info->attrs[WL12XX_NL_ATTR_IFNAME]));
-
-	NLA_PUT_U32(msg, WL12XX_NL_ATTR_REG_VAL, reg_value);
-
-	ret = genlmsg_end(msg, hdr);
-	if (ret < 0) {
-		wl12xx_error("%s() failed", __func__);
-		goto nla_put_failure;
-	}
-
-	return genlmsg_reply(msg, info);
-
- nla_put_failure:
-	nlmsg_free(msg);
-
-	return ret;
-}
-
-static int wl12xx_nl_nvs_push(struct sk_buff *skb, struct genl_info *info)
-{
-	struct wl12xx *wl;
-
-	if (!info->attrs[WL12XX_NL_ATTR_NVS_BUFFER])
-		return -EINVAL;
-
-	if (!info->attrs[WL12XX_NL_ATTR_NVS_LEN])
-		return -EINVAL;
-
-	wl = ifname_to_wl12xx(&init_net, info);
-	if (wl == NULL) {
-		wl12xx_error("wl12xx not found");
-		return -EINVAL;
-	}
-
-	wl->nvs_len = nla_get_u32(info->attrs[WL12XX_NL_ATTR_NVS_LEN]);
-	if (wl->nvs_len % 4) {
-		wl12xx_error("NVS size is not multiple of 32: %d", wl->nvs_len);
-		return -EILSEQ;
-	}
-
-	/* If we already have an NVS, we should free it */
-	kfree(wl->nvs);
-
-	wl->nvs = kzalloc(wl->nvs_len, GFP_KERNEL);
-	if (wl->nvs == NULL) {
-		wl12xx_error("Can't allocate NVS");
-		return -ENOMEM;
-	}
-
-	memcpy(wl->nvs,
-	       nla_data(info->attrs[WL12XX_NL_ATTR_NVS_BUFFER]),
-	       wl->nvs_len);
-
-	wl12xx_debug(DEBUG_NETLINK, "got NVS from userspace, %d bytes",
-		     wl->nvs_len);
-
-	return 0;
-}
-
-static int wl12xx_nl_reg_read(struct sk_buff *skb, struct genl_info *info)
-{
-	struct wl12xx *wl;
-	u32 addr, val;
-	int ret = 0;
-	struct sk_buff *msg;
-	void *hdr;
-
-	if (!info->attrs[WL12XX_NL_ATTR_REG_ADDR])
-		return -EINVAL;
-
-	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
-	if (!msg)
-		return -ENOMEM;
-
-	wl = ifname_to_wl12xx(&init_net, info);
-	if (wl == NULL) {
-		wl12xx_error("wl12xx not found");
-		return -EINVAL;
-	}
-
-	addr = nla_get_u32(info->attrs[WL12XX_NL_ATTR_REG_ADDR]);
-
-	val = wl12xx_reg_read32(wl, addr);
-
-	hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq,
-			  &wl12xx_nl_family, 0, WL12XX_NL_CMD_PHY_REG_READ);
-	if (IS_ERR(hdr)) {
-		ret = PTR_ERR(hdr);
-		goto nla_put_failure;
-	}
-
-	NLA_PUT_STRING(msg, WL12XX_NL_ATTR_IFNAME,
-		       nla_data(info->attrs[WL12XX_NL_ATTR_IFNAME]));
-
-	NLA_PUT_U32(msg, WL12XX_NL_ATTR_REG_VAL, val);
-
-	ret = genlmsg_end(msg, hdr);
-	if (ret < 0) {
-		wl12xx_error("%s() failed", __func__);
-		goto nla_put_failure;
-	}
-
-	return genlmsg_reply(msg, info);
-
- nla_put_failure:
-	nlmsg_free(msg);
-
-	return ret;
-}
-
-static int wl12xx_nl_reg_write(struct sk_buff *skb, struct genl_info *info)
-{
-	struct wl12xx *wl;
-	u32 addr, val;
-
-	if (!info->attrs[WL12XX_NL_ATTR_REG_ADDR])
-		return -EINVAL;
-
-	if (!info->attrs[WL12XX_NL_ATTR_REG_VAL])
-		return -EINVAL;
-
-	wl = ifname_to_wl12xx(&init_net, info);
-	if (wl == NULL) {
-		wl12xx_error("wl12xx not found");
-		return -EINVAL;
-	}
-
-	addr = nla_get_u32(info->attrs[WL12XX_NL_ATTR_REG_ADDR]);
-	val = nla_get_u32(info->attrs[WL12XX_NL_ATTR_REG_VAL]);
-
-	wl12xx_reg_write32(wl, addr, val);
-
-	return 0;
-}
-
-static int wl12xx_nl_set_plt_mode(struct sk_buff *skb, struct genl_info *info)
-{
-	struct wl12xx *wl;
-	u32 val;
-	int ret;
-
-	if (!info->attrs[WL12XX_NL_ATTR_PLT_MODE])
-		return -EINVAL;
-
-	wl = ifname_to_wl12xx(&init_net, info);
-	if (wl == NULL) {
-		wl12xx_error("wl12xx not found");
-		return -EINVAL;
-	}
-
-	val = nla_get_u32(info->attrs[WL12XX_NL_ATTR_PLT_MODE]);
-
-	switch (val) {
-	case 0:
-		ret = wl12xx_plt_stop(wl);
-		break;
-	case 1:
-		ret = wl12xx_plt_start(wl);
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-
-	return ret;
-}
-
-static struct nla_policy wl12xx_nl_policy[WL12XX_NL_ATTR_MAX + 1] = {
-	[WL12XX_NL_ATTR_IFNAME] =            { .type = NLA_NUL_STRING,
-					       .len = IFNAMSIZ-1 },
-	[WL12XX_NL_ATTR_CMD_TEST_PARAM] =    { .type = NLA_BINARY,
-					       .len = WL12XX_MAX_TEST_LENGTH },
-	[WL12XX_NL_ATTR_CMD_TEST_ANSWER] =   { .type = NLA_U8 },
-	[WL12XX_NL_ATTR_CMD_IE] =            { .type = NLA_U32 },
-	[WL12XX_NL_ATTR_CMD_IE_LEN] =        { .type = NLA_U32 },
-	[WL12XX_NL_ATTR_CMD_IE_BUFFER] =     { .type = NLA_BINARY,
-					       .len = WL12XX_MAX_TEST_LENGTH },
-	[WL12XX_NL_ATTR_CMD_IE_ANSWER] =     { .type = NLA_BINARY,
-					       .len = WL12XX_MAX_TEST_LENGTH },
-	[WL12XX_NL_ATTR_REG_ADDR] =          { .type = NLA_U32 },
-	[WL12XX_NL_ATTR_REG_VAL] =           { .type = NLA_U32 },
-	[WL12XX_NL_ATTR_NVS_BUFFER] =        { .type = NLA_BINARY,
-					       .len = WL12XX_MAX_NVS_LENGTH },
-	[WL12XX_NL_ATTR_NVS_LEN] =           { .type = NLA_U32 },
-	[WL12XX_NL_ATTR_PLT_MODE] =          { .type = NLA_U32 },
-};
-
-static struct genl_ops wl12xx_nl_ops[] = {
-	{
-		.cmd = WL12XX_NL_CMD_TEST,
-		.doit = wl12xx_nl_test_cmd,
-		.policy = wl12xx_nl_policy,
-		.flags = GENL_ADMIN_PERM,
-	},
-	{
-		.cmd = WL12XX_NL_CMD_INTERROGATE,
-		.doit = wl12xx_nl_interrogate,
-		.policy = wl12xx_nl_policy,
-		.flags = GENL_ADMIN_PERM,
-	},
-	{
-		.cmd = WL12XX_NL_CMD_CONFIGURE,
-		.doit = wl12xx_nl_configure,
-		.policy = wl12xx_nl_policy,
-		.flags = GENL_ADMIN_PERM,
-	},
-	{
-		.cmd = WL12XX_NL_CMD_PHY_REG_READ,
-		.doit = wl12xx_nl_phy_reg_read,
-		.policy = wl12xx_nl_policy,
-		.flags = GENL_ADMIN_PERM,
-	},
-	{
-		.cmd = WL12XX_NL_CMD_NVS_PUSH,
-		.doit = wl12xx_nl_nvs_push,
-		.policy = wl12xx_nl_policy,
-		.flags = GENL_ADMIN_PERM,
-	},
-	{
-		.cmd = WL12XX_NL_CMD_REG_WRITE,
-		.doit = wl12xx_nl_reg_write,
-		.policy = wl12xx_nl_policy,
-		.flags = GENL_ADMIN_PERM,
-	},
-	{
-		.cmd = WL12XX_NL_CMD_REG_READ,
-		.doit = wl12xx_nl_reg_read,
-		.policy = wl12xx_nl_policy,
-		.flags = GENL_ADMIN_PERM,
-	},
-	{
-		.cmd = WL12XX_NL_CMD_SET_PLT_MODE,
-		.doit = wl12xx_nl_set_plt_mode,
-		.policy = wl12xx_nl_policy,
-		.flags = GENL_ADMIN_PERM,
-	},
-};
-
-int wl12xx_nl_register(void)
-{
-	int err, i;
-
-	err = genl_register_family(&wl12xx_nl_family);
-	if (err)
-		return err;
-
-	for (i = 0; i < ARRAY_SIZE(wl12xx_nl_ops); i++) {
-		err = genl_register_ops(&wl12xx_nl_family, &wl12xx_nl_ops[i]);
-		if (err)
-			goto err_out;
-	}
-	return 0;
- err_out:
-	genl_unregister_family(&wl12xx_nl_family);
-	return err;
-}
-
-void wl12xx_nl_unregister(void)
-{
-	genl_unregister_family(&wl12xx_nl_family);
-}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/netlink.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/netlink.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/netlink.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/netlink.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (C) 2009 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#ifndef __WL12XX_NETLINK_H__
-#define __WL12XX_NETLINK_H__
-
-int wl12xx_nl_register(void);
-void wl12xx_nl_unregister(void);
-
-#endif /* __WL12XX_NETLINK_H__ */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/ps.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/ps.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/ps.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/ps.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,151 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (C) 2008 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#include "reg.h"
-#include "ps.h"
-#include "spi.h"
-
-#define WL12XX_WAKEUP_TIMEOUT 2000
-
-/* Routines to toggle sleep mode while in ELP */
-void wl12xx_ps_elp_sleep(struct wl12xx *wl)
-{
-	if (wl->elp || !wl->psm)
-		return;
-
-	wl12xx_debug(DEBUG_PSM, "chip to elp");
-
-	wl12xx_write32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, ELPCTRL_SLEEP);
-
-	wl->elp = true;
-}
-
-int wl12xx_ps_elp_wakeup(struct wl12xx *wl)
-{
-	unsigned long timeout;
-	u32 elp_reg;
-
-	if (!wl->elp)
-		return 0;
-
-	wl12xx_debug(DEBUG_PSM, "waking up chip from elp");
-
-	timeout = jiffies + msecs_to_jiffies(WL12XX_WAKEUP_TIMEOUT);
-
-	wl12xx_write32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, ELPCTRL_WAKE_UP);
-
-	elp_reg = wl12xx_read32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR);
-
-	/*
-	 * FIXME: we should wait for irq from chip but, as a temporary
-	 * solution to simplify locking, let's poll instead
-	 */
-	while (!(elp_reg & ELPCTRL_WLAN_READY)) {
-		if (time_after(jiffies, timeout)) {
-			wl12xx_error("elp wakeup timeout");
-			return -ETIMEDOUT;
-		}
-		msleep(1);
-		elp_reg = wl12xx_read32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR);
-	}
-
-	wl12xx_debug(DEBUG_PSM, "wakeup time: %u ms",
-		     jiffies_to_msecs(jiffies) -
-		     (jiffies_to_msecs(timeout) - WL12XX_WAKEUP_TIMEOUT));
-
-	wl->elp = false;
-
-	return 0;
-}
-
-static int wl12xx_ps_set_elp(struct wl12xx *wl, bool enable)
-{
-	int ret;
-
-	if (enable) {
-		wl12xx_debug(DEBUG_PSM, "sleep auth psm/elp");
-
-		/*
-		 * FIXME: we should PSM_ELP, but because of firmware wakeup
-		 * problems let's use only PSM_PS
-		 */
-		ret = wl12xx_acx_sleep_auth(wl, WL12XX_PSM_PS);
-		if (ret < 0)
-			return ret;
-
-		wl12xx_ps_elp_sleep(wl);
-	} else {
-		wl12xx_debug(DEBUG_PSM, "sleep auth cam");
-
-		/*
-		 * When the target is in ELP, we can only
-		 * access the ELP control register. Thus,
-		 * we have to wake the target up before
-		 * changing the power authorization.
-		 */
-
-		wl12xx_ps_elp_wakeup(wl);
-
-		ret = wl12xx_acx_sleep_auth(wl, WL12XX_PSM_CAM);
-		if (ret < 0)
-			return ret;
-	}
-
-	return 0;
-}
-
-int wl12xx_ps_set_mode(struct wl12xx *wl, enum acx_ps_mode mode)
-{
-	int ret;
-
-	switch (mode) {
-	case STATION_POWER_SAVE_MODE:
-		wl12xx_debug(DEBUG_PSM, "entering psm");
-		ret = wl12xx_cmd_ps_mode(wl, STATION_POWER_SAVE_MODE);
-		if (ret < 0)
-			return ret;
-
-		ret = wl12xx_ps_set_elp(wl, true);
-		if (ret < 0)
-			return ret;
-
-		wl->psm = 1;
-		break;
-	case STATION_ACTIVE_MODE:
-	default:
-		wl12xx_debug(DEBUG_PSM, "leaving psm");
-		ret = wl12xx_ps_set_elp(wl, false);
-		if (ret < 0)
-			return ret;
-
-		ret = wl12xx_cmd_ps_mode(wl, STATION_ACTIVE_MODE);
-		if (ret < 0)
-			return ret;
-
-		wl->psm = 0;
-		break;
-	}
-
-	return ret;
-}
-
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/ps.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/ps.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/ps.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/ps.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,36 +0,0 @@
-#ifndef __WL12XX_PS_H__
-#define __WL12XX_PS_H__
-
-/*
- * This file is part of wl12xx
- *
- * Copyright (c) 1998-2007 Texas Instruments Incorporated
- * Copyright (C) 2008 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#include "wl12xx.h"
-#include "acx.h"
-
-int wl12xx_ps_set_mode(struct wl12xx *wl, enum acx_ps_mode mode);
-void wl12xx_ps_elp_sleep(struct wl12xx *wl);
-int wl12xx_ps_elp_wakeup(struct wl12xx *wl);
-
-
-#endif /* __WL12XX_PS_H__ */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/reg.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/reg.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/reg.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/reg.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,745 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (c) 1998-2007 Texas Instruments Incorporated
- * Copyright (C) 2008 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#ifndef __REG_H__
-#define __REG_H__
-
-#include <linux/bitops.h>
-#include "wl12xx.h"
-
-#define REGISTERS_BASE 0x00300000
-#define DRPW_BASE      0x00310000
-
-#define REGISTERS_DOWN_SIZE 0x00008800
-#define REGISTERS_WORK_SIZE 0x0000b000
-
-#define HW_ACCESS_ELP_CTRL_REG_ADDR         0x1FFFC
-
-/* ELP register commands */
-#define ELPCTRL_WAKE_UP             0x1
-#define ELPCTRL_WAKE_UP_WLAN_READY  0x5
-#define ELPCTRL_SLEEP               0x0
-/* ELP WLAN_READY bit */
-#define ELPCTRL_WLAN_READY          0x2
-
-/*
- * Interrupt registers.
- * 64 bit interrupt sources registers ws ced.
- * sme interupts were removed and new ones were added.
- * Order was changed.
- */
-#define FIQ_MASK                       (REGISTERS_BASE + 0x0400)
-#define FIQ_MASK_L                     (REGISTERS_BASE + 0x0400)
-#define FIQ_MASK_H                     (REGISTERS_BASE + 0x0404)
-#define FIQ_MASK_SET                   (REGISTERS_BASE + 0x0408)
-#define FIQ_MASK_SET_L                 (REGISTERS_BASE + 0x0408)
-#define FIQ_MASK_SET_H                 (REGISTERS_BASE + 0x040C)
-#define FIQ_MASK_CLR                   (REGISTERS_BASE + 0x0410)
-#define FIQ_MASK_CLR_L                 (REGISTERS_BASE + 0x0410)
-#define FIQ_MASK_CLR_H                 (REGISTERS_BASE + 0x0414)
-#define IRQ_MASK                       (REGISTERS_BASE + 0x0418)
-#define IRQ_MASK_L                     (REGISTERS_BASE + 0x0418)
-#define IRQ_MASK_H                     (REGISTERS_BASE + 0x041C)
-#define IRQ_MASK_SET                   (REGISTERS_BASE + 0x0420)
-#define IRQ_MASK_SET_L                 (REGISTERS_BASE + 0x0420)
-#define IRQ_MASK_SET_H                 (REGISTERS_BASE + 0x0424)
-#define IRQ_MASK_CLR                   (REGISTERS_BASE + 0x0428)
-#define IRQ_MASK_CLR_L                 (REGISTERS_BASE + 0x0428)
-#define IRQ_MASK_CLR_H                 (REGISTERS_BASE + 0x042C)
-#define ECPU_MASK                      (REGISTERS_BASE + 0x0448)
-#define FIQ_STS_L                      (REGISTERS_BASE + 0x044C)
-#define FIQ_STS_H                      (REGISTERS_BASE + 0x0450)
-#define IRQ_STS_L                      (REGISTERS_BASE + 0x0454)
-#define IRQ_STS_H                      (REGISTERS_BASE + 0x0458)
-#define INT_STS_ND                     (REGISTERS_BASE + 0x0464)
-#define INT_STS_RAW_L                  (REGISTERS_BASE + 0x0464)
-#define INT_STS_RAW_H                  (REGISTERS_BASE + 0x0468)
-#define INT_STS_CLR                    (REGISTERS_BASE + 0x04B4)
-#define INT_STS_CLR_L                  (REGISTERS_BASE + 0x04B4)
-#define INT_STS_CLR_H                  (REGISTERS_BASE + 0x04B8)
-#define INT_ACK                        (REGISTERS_BASE + 0x046C)
-#define INT_ACK_L                      (REGISTERS_BASE + 0x046C)
-#define INT_ACK_H                      (REGISTERS_BASE + 0x0470)
-#define INT_TRIG                       (REGISTERS_BASE + 0x0474)
-#define INT_TRIG_L                     (REGISTERS_BASE + 0x0474)
-#define INT_TRIG_H                     (REGISTERS_BASE + 0x0478)
-#define HOST_STS_L                     (REGISTERS_BASE + 0x045C)
-#define HOST_STS_H                     (REGISTERS_BASE + 0x0460)
-#define HOST_MASK                      (REGISTERS_BASE + 0x0430)
-#define HOST_MASK_L                    (REGISTERS_BASE + 0x0430)
-#define HOST_MASK_H                    (REGISTERS_BASE + 0x0434)
-#define HOST_MASK_SET                  (REGISTERS_BASE + 0x0438)
-#define HOST_MASK_SET_L                (REGISTERS_BASE + 0x0438)
-#define HOST_MASK_SET_H                (REGISTERS_BASE + 0x043C)
-#define HOST_MASK_CLR                  (REGISTERS_BASE + 0x0440)
-#define HOST_MASK_CLR_L                (REGISTERS_BASE + 0x0440)
-#define HOST_MASK_CLR_H                (REGISTERS_BASE + 0x0444)
-
-/* Host Interrupts*/
-#define HINT_MASK                      (REGISTERS_BASE + 0x0494)
-#define HINT_MASK_SET                  (REGISTERS_BASE + 0x0498)
-#define HINT_MASK_CLR                  (REGISTERS_BASE + 0x049C)
-#define HINT_STS_ND_MASKED             (REGISTERS_BASE + 0x04A0)
-/*1150 spec calls this HINT_STS_RAW*/
-#define HINT_STS_ND		       (REGISTERS_BASE + 0x04B0)
-#define HINT_STS_CLR                   (REGISTERS_BASE + 0x04A4)
-#define HINT_ACK                       (REGISTERS_BASE + 0x04A8)
-#define HINT_TRIG                      (REGISTERS_BASE + 0x04AC)
-
-/* Device Configuration registers*/
-#define SOR_CFG                        (REGISTERS_BASE + 0x0800)
-#define ECPU_CTRL                      (REGISTERS_BASE + 0x0804)
-#define HI_CFG                         (REGISTERS_BASE + 0x0808)
-#define EE_START                       (REGISTERS_BASE + 0x080C)
-
-#define CHIP_ID_B                      (REGISTERS_BASE + 0x5674)
-
-#define CHIP_ID_1251_PG10	           (0x7010101)
-#define CHIP_ID_1251_PG11	           (0x7020101)
-#define CHIP_ID_1251_PG12	           (0x7030101)
-
-#define ENABLE                         (REGISTERS_BASE + 0x5450)
-
-/* Power Management registers */
-#define ELP_CFG_MODE                   (REGISTERS_BASE + 0x5804)
-#define ELP_CMD                        (REGISTERS_BASE + 0x5808)
-#define PLL_CAL_TIME                   (REGISTERS_BASE + 0x5810)
-#define CLK_REQ_TIME                   (REGISTERS_BASE + 0x5814)
-#define CLK_BUF_TIME                   (REGISTERS_BASE + 0x5818)
-
-#define CFG_PLL_SYNC_CNT               (REGISTERS_BASE + 0x5820)
-
-/* Scratch Pad registers*/
-#define SCR_PAD0                       (REGISTERS_BASE + 0x5608)
-#define SCR_PAD1                       (REGISTERS_BASE + 0x560C)
-#define SCR_PAD2                       (REGISTERS_BASE + 0x5610)
-#define SCR_PAD3                       (REGISTERS_BASE + 0x5614)
-#define SCR_PAD4                       (REGISTERS_BASE + 0x5618)
-#define SCR_PAD4_SET                   (REGISTERS_BASE + 0x561C)
-#define SCR_PAD4_CLR                   (REGISTERS_BASE + 0x5620)
-#define SCR_PAD5                       (REGISTERS_BASE + 0x5624)
-#define SCR_PAD5_SET                   (REGISTERS_BASE + 0x5628)
-#define SCR_PAD5_CLR                   (REGISTERS_BASE + 0x562C)
-#define SCR_PAD6                       (REGISTERS_BASE + 0x5630)
-#define SCR_PAD7                       (REGISTERS_BASE + 0x5634)
-#define SCR_PAD8                       (REGISTERS_BASE + 0x5638)
-#define SCR_PAD9                       (REGISTERS_BASE + 0x563C)
-
-/* Spare registers*/
-#define SPARE_A1                       (REGISTERS_BASE + 0x0994)
-#define SPARE_A2                       (REGISTERS_BASE + 0x0998)
-#define SPARE_A3                       (REGISTERS_BASE + 0x099C)
-#define SPARE_A4                       (REGISTERS_BASE + 0x09A0)
-#define SPARE_A5                       (REGISTERS_BASE + 0x09A4)
-#define SPARE_A6                       (REGISTERS_BASE + 0x09A8)
-#define SPARE_A7                       (REGISTERS_BASE + 0x09AC)
-#define SPARE_A8                       (REGISTERS_BASE + 0x09B0)
-#define SPARE_B1                       (REGISTERS_BASE + 0x5420)
-#define SPARE_B2                       (REGISTERS_BASE + 0x5424)
-#define SPARE_B3                       (REGISTERS_BASE + 0x5428)
-#define SPARE_B4                       (REGISTERS_BASE + 0x542C)
-#define SPARE_B5                       (REGISTERS_BASE + 0x5430)
-#define SPARE_B6                       (REGISTERS_BASE + 0x5434)
-#define SPARE_B7                       (REGISTERS_BASE + 0x5438)
-#define SPARE_B8                       (REGISTERS_BASE + 0x543C)
-
-enum wl12xx_acx_int_reg {
-	ACX_REG_INTERRUPT_TRIG,
-	ACX_REG_INTERRUPT_TRIG_H,
-
-/*=============================================
-  Host Interrupt Mask Register - 32bit (RW)
-  ------------------------------------------
-  Setting a bit in this register masks the
-  corresponding interrupt to the host.
-  0 - RX0		- Rx first dubble buffer Data Interrupt
-  1 - TXD		- Tx Data Interrupt
-  2 - TXXFR		- Tx Transfer Interrupt
-  3 - RX1		- Rx second dubble buffer Data Interrupt
-  4 - RXXFR		- Rx Transfer Interrupt
-  5 - EVENT_A	- Event Mailbox interrupt
-  6 - EVENT_B	- Event Mailbox interrupt
-  7 - WNONHST	- Wake On Host Interrupt
-  8 - TRACE_A	- Debug Trace interrupt
-  9 - TRACE_B	- Debug Trace interrupt
- 10 - CDCMP		- Command Complete Interrupt
- 11 -
- 12 -
- 13 -
- 14 - ICOMP		- Initialization Complete Interrupt
- 16 - SG SE		- Soft Gemini - Sense enable interrupt
- 17 - SG SD		- Soft Gemini - Sense disable interrupt
- 18 -			-
- 19 -			-
- 20 -			-
- 21-			-
- Default: 0x0001
-*==============================================*/
-	ACX_REG_INTERRUPT_MASK,
-
-/*=============================================
-  Host Interrupt Mask Set 16bit, (Write only)
-  ------------------------------------------
- Setting a bit in this register sets
- the corresponding bin in ACX_HINT_MASK register
- without effecting the mask
- state of other bits (0 = no effect).
-==============================================*/
-	ACX_REG_HINT_MASK_SET,
-
-/*=============================================
-  Host Interrupt Mask Clear 16bit,(Write only)
-  ------------------------------------------
- Setting a bit in this register clears
- the corresponding bin in ACX_HINT_MASK register
- without effecting the mask
- state of other bits (0 = no effect).
-=============================================*/
-	ACX_REG_HINT_MASK_CLR,
-
-/*=============================================
-  Host Interrupt Status Nondestructive Read
-  16bit,(Read only)
-  ------------------------------------------
- The host can read this register to determine
- which interrupts are active.
- Reading this register doesn't
- effect its content.
-=============================================*/
-	ACX_REG_INTERRUPT_NO_CLEAR,
-
-/*=============================================
-  Host Interrupt Status Clear on Read  Register
-  16bit,(Read only)
-  ------------------------------------------
- The host can read this register to determine
- which interrupts are active.
- Reading this register clears it,
- thus making all interrupts inactive.
-==============================================*/
-	ACX_REG_INTERRUPT_CLEAR,
-
-/*=============================================
-  Host Interrupt Acknowledge Register
-  16bit,(Write only)
-  ------------------------------------------
- The host can set individual bits in this
- register to clear (acknowledge) the corresp.
- interrupt status bits in the HINT_STS_CLR and
- HINT_STS_ND registers, thus making the
- assotiated interrupt inactive. (0-no effect)
-==============================================*/
-	ACX_REG_INTERRUPT_ACK,
-
-/*===============================================
-   Host Software Reset - 32bit RW
- ------------------------------------------
-    [31:1] Reserved
-    0  SOFT_RESET Soft Reset  - When this bit is set,
-    it holds the Wlan hardware in a soft reset state.
-    This reset disables all MAC and baseband processor
-    clocks except the CardBus/PCI interface clock.
-    It also initializes all MAC state machines except
-    the host interface. It does not reload the
-    contents of the EEPROM. When this bit is cleared
-    (not self-clearing), the Wlan hardware
-    exits the software reset state.
-===============================================*/
-	ACX_REG_SLV_SOFT_RESET,
-
-/*===============================================
- EEPROM Burst Read Start  - 32bit RW
- ------------------------------------------
- [31:1] Reserved
- 0  ACX_EE_START -  EEPROM Burst Read Start 0
- Setting this bit starts a burst read from
- the external EEPROM.
- If this bit is set (after reset) before an EEPROM read/write,
- the burst read starts at EEPROM address 0.
- Otherwise, it starts at the address
- following the address of the previous access.
- TheWlan hardware hardware clears this bit automatically.
-
- Default: 0x00000000
-*================================================*/
-	ACX_REG_EE_START,
-
-/* Embedded ARM CPU Control */
-
-/*===============================================
- Halt eCPU   - 32bit RW
- ------------------------------------------
- 0 HALT_ECPU Halt Embedded CPU - This bit is the
- compliment of bit 1 (MDATA2) in the SOR_CFG register.
- During a hardware reset, this bit holds
- the inverse of MDATA2.
- When downloading firmware from the host,
- set this bit (pull down MDATA2).
- The host clears this bit after downloading the firmware into
- zero-wait-state SSRAM.
- When loading firmware from Flash, clear this bit (pull up MDATA2)
- so that the eCPU can run the bootloader code in Flash
- HALT_ECPU eCPU State
- --------------------
- 1 halt eCPU
- 0 enable eCPU
- ===============================================*/
-	ACX_REG_ECPU_CONTROL,
-
-	ACX_REG_TABLE_LEN
-};
-
-#define ACX_SLV_SOFT_RESET_BIT   BIT(1)
-#define ACX_REG_EEPROM_START_BIT BIT(1)
-
-/* Command/Information Mailbox Pointers */
-
-/*===============================================
-  Command Mailbox Pointer - 32bit RW
- ------------------------------------------
- This register holds the start address of
- the command mailbox located in the Wlan hardware memory.
- The host must read this pointer after a reset to
- find the location of the command mailbox.
- The Wlan hardware initializes the command mailbox
- pointer with the default address of the command mailbox.
- The command mailbox pointer is not valid until after
- the host receives the Init Complete interrupt from
- the Wlan hardware.
- ===============================================*/
-#define REG_COMMAND_MAILBOX_PTR				(SCR_PAD0)
-
-/*===============================================
-  Information Mailbox Pointer - 32bit RW
- ------------------------------------------
- This register holds the start address of
- the information mailbox located in the Wlan hardware memory.
- The host must read this pointer after a reset to find
- the location of the information mailbox.
- The Wlan hardware initializes the information mailbox pointer
- with the default address of the information mailbox.
- The information mailbox pointer is not valid
- until after the host receives the Init Complete interrupt from
- the Wlan hardware.
- ===============================================*/
-#define REG_EVENT_MAILBOX_PTR				(SCR_PAD1)
-
-
-/* Misc */
-
-#define REG_ENABLE_TX_RX				(ENABLE)
-/*
- * Rx configuration (filter) information element
- * ---------------------------------------------
- */
-#define REG_RX_CONFIG				(RX_CFG)
-#define REG_RX_FILTER				(RX_FILTER_CFG)
-
-
-#define RX_CFG_ENABLE_PHY_HEADER_PLCP	 0x0002
-
-/* promiscuous - receives all valid frames */
-#define RX_CFG_PROMISCUOUS		 0x0008
-
-/* receives frames from any BSSID */
-#define RX_CFG_BSSID			 0x0020
-
-/* receives frames destined to any MAC address */
-#define RX_CFG_MAC			 0x0010
-
-#define RX_CFG_ENABLE_ONLY_MY_DEST_MAC	 0x0010
-#define RX_CFG_ENABLE_ANY_DEST_MAC	 0x0000
-#define RX_CFG_ENABLE_ONLY_MY_BSSID	 0x0020
-#define RX_CFG_ENABLE_ANY_BSSID		 0x0000
-
-/* discards all broadcast frames */
-#define RX_CFG_DISABLE_BCAST		 0x0200
-
-#define RX_CFG_ENABLE_ONLY_MY_SSID	 0x0400
-#define RX_CFG_ENABLE_RX_CMPLT_FCS_ERROR 0x0800
-#define RX_CFG_COPY_RX_STATUS		 0x2000
-#define RX_CFG_TSF			 0x10000
-
-#define RX_CONFIG_OPTION_ANY_DST_MY_BSS	 (RX_CFG_ENABLE_ANY_DEST_MAC | \
-					  RX_CFG_ENABLE_ONLY_MY_BSSID)
-
-#define RX_CONFIG_OPTION_MY_DST_ANY_BSS	 (RX_CFG_ENABLE_ONLY_MY_DEST_MAC\
-					  | RX_CFG_ENABLE_ANY_BSSID)
-
-#define RX_CONFIG_OPTION_ANY_DST_ANY_BSS (RX_CFG_ENABLE_ANY_DEST_MAC | \
-					  RX_CFG_ENABLE_ANY_BSSID)
-
-#define RX_CONFIG_OPTION_MY_DST_MY_BSS	 (RX_CFG_ENABLE_ONLY_MY_DEST_MAC\
-					  | RX_CFG_ENABLE_ONLY_MY_BSSID)
-
-#define RX_CONFIG_OPTION_FOR_SCAN  (RX_CFG_ENABLE_PHY_HEADER_PLCP \
-				    | RX_CFG_ENABLE_RX_CMPLT_FCS_ERROR \
-				    | RX_CFG_COPY_RX_STATUS | RX_CFG_TSF)
-
-#define RX_CONFIG_OPTION_FOR_MEASUREMENT (RX_CFG_ENABLE_ANY_DEST_MAC)
-
-#define RX_CONFIG_OPTION_FOR_JOIN	 (RX_CFG_ENABLE_ONLY_MY_BSSID | \
-					  RX_CFG_ENABLE_ONLY_MY_DEST_MAC)
-
-#define RX_CONFIG_OPTION_FOR_IBSS_JOIN   (RX_CFG_ENABLE_ONLY_MY_SSID | \
-					  RX_CFG_ENABLE_ONLY_MY_DEST_MAC)
-
-#define RX_FILTER_OPTION_DEF	      (CFG_RX_MGMT_EN | CFG_RX_DATA_EN\
-				       | CFG_RX_CTL_EN | CFG_RX_BCN_EN\
-				       | CFG_RX_AUTH_EN | CFG_RX_ASSOC_EN)
-
-#define RX_FILTER_OPTION_FILTER_ALL	 0
-
-#define RX_FILTER_OPTION_DEF_PRSP_BCN  (CFG_RX_PRSP_EN | CFG_RX_MGMT_EN\
-					| CFG_RX_RCTS_ACK | CFG_RX_BCN_EN)
-
-#define RX_FILTER_OPTION_JOIN	     (CFG_RX_MGMT_EN | CFG_RX_DATA_EN\
-				      | CFG_RX_BCN_EN | CFG_RX_AUTH_EN\
-				      | CFG_RX_ASSOC_EN | CFG_RX_RCTS_ACK\
-				      | CFG_RX_PRSP_EN)
-
-
-/*===============================================
-  Phy regs
- ===============================================*/
-#define ACX_PHY_ADDR_REG                SBB_ADDR
-#define ACX_PHY_DATA_REG                SBB_DATA
-#define ACX_PHY_CTRL_REG                SBB_CTL
-#define ACX_PHY_REG_WR_MASK             0x00000001ul
-#define ACX_PHY_REG_RD_MASK             0x00000002ul
-
-
-/*===============================================
- EEPROM Read/Write Request 32bit RW
- ------------------------------------------
- 1 EE_READ - EEPROM Read Request 1 - Setting this bit
- loads a single byte of data into the EE_DATA
- register from the EEPROM location specified in
- the EE_ADDR register.
- The Wlan hardware hardware clears this bit automatically.
- EE_DATA is valid when this bit is cleared.
-
- 0 EE_WRITE  - EEPROM Write Request  - Setting this bit
- writes a single byte of data from the EE_DATA register into the
- EEPROM location specified in the EE_ADDR register.
- The Wlan hardware hardware clears this bit automatically.
-*===============================================*/
-#define ACX_EE_CTL_REG                      EE_CTL
-#define EE_WRITE                            0x00000001ul
-#define EE_READ                             0x00000002ul
-
-/*===============================================
-  EEPROM Address  - 32bit RW
-  ------------------------------------------
-  This register specifies the address
-  within the EEPROM from/to which to read/write data.
-  ===============================================*/
-#define ACX_EE_ADDR_REG                     EE_ADDR
-
-/*===============================================
-  EEPROM Data  - 32bit RW
-  ------------------------------------------
-  This register either holds the read 8 bits of
-  data from the EEPROM or the write data
-  to be written to the EEPROM.
-  ===============================================*/
-#define ACX_EE_DATA_REG                     EE_DATA
-
-/*===============================================
-  EEPROM Base Address  - 32bit RW
-  ------------------------------------------
-  This register holds the upper nine bits
-  [23:15] of the 24-bit Wlan hardware memory
-  address for burst reads from EEPROM accesses.
-  The EEPROM provides the lower 15 bits of this address.
-  The MSB of the address from the EEPROM is ignored.
-  ===============================================*/
-#define ACX_EE_CFG                          EE_CFG
-
-/*===============================================
-  GPIO Output Values  -32bit, RW
-  ------------------------------------------
-  [31:16]  Reserved
-  [15: 0]  Specify the output values (at the output driver inputs) for
-  GPIO[15:0], respectively.
-  ===============================================*/
-#define ACX_GPIO_OUT_REG            GPIO_OUT
-#define ACX_MAX_GPIO_LINES          15
-
-/*===============================================
-  Contention window  -32bit, RW
-  ------------------------------------------
-  [31:26]  Reserved
-  [25:16]  Max (0x3ff)
-  [15:07]  Reserved
-  [06:00]  Current contention window value - default is 0x1F
-  ===============================================*/
-#define ACX_CONT_WIND_CFG_REG    CONT_WIND_CFG
-#define ACX_CONT_WIND_MIN_MASK   0x0000007f
-#define ACX_CONT_WIND_MAX        0x03ff0000
-
-/*
- * Indirect slave register/memory registers
- * ----------------------------------------
- */
-#define HW_SLAVE_REG_ADDR_REG		0x00000004
-#define HW_SLAVE_REG_DATA_REG		0x00000008
-#define HW_SLAVE_REG_CTRL_REG		0x0000000c
-
-#define SLAVE_AUTO_INC				0x00010000
-#define SLAVE_NO_AUTO_INC			0x00000000
-#define SLAVE_HOST_LITTLE_ENDIAN	0x00000000
-
-#define HW_SLAVE_MEM_ADDR_REG		SLV_MEM_ADDR
-#define HW_SLAVE_MEM_DATA_REG		SLV_MEM_DATA
-#define HW_SLAVE_MEM_CTRL_REG		SLV_MEM_CTL
-#define HW_SLAVE_MEM_ENDIAN_REG		SLV_END_CTL
-
-#define HW_FUNC_EVENT_INT_EN		0x8000
-#define HW_FUNC_EVENT_MASK_REG		0x00000034
-
-#define ACX_MAC_TIMESTAMP_REG	(MAC_TIMESTAMP)
-
-/*===============================================
-  HI_CFG Interface Configuration Register Values
-  ------------------------------------------
-  ===============================================*/
-#define HI_CFG_UART_ENABLE          0x00000004
-#define HI_CFG_RST232_ENABLE        0x00000008
-#define HI_CFG_CLOCK_REQ_SELECT     0x00000010
-#define HI_CFG_HOST_INT_ENABLE      0x00000020
-#define HI_CFG_VLYNQ_OUTPUT_ENABLE  0x00000040
-#define HI_CFG_HOST_INT_ACTIVE_LOW  0x00000080
-#define HI_CFG_UART_TX_OUT_GPIO_15  0x00000100
-#define HI_CFG_UART_TX_OUT_GPIO_14  0x00000200
-#define HI_CFG_UART_TX_OUT_GPIO_7   0x00000400
-
-/*
- * NOTE: USE_ACTIVE_HIGH compilation flag should be defined in makefile
- *       for platforms using active high interrupt level
- */
-#ifdef USE_ACTIVE_HIGH
-#define HI_CFG_DEF_VAL              \
-	(HI_CFG_UART_ENABLE |        \
-	HI_CFG_RST232_ENABLE |      \
-	HI_CFG_CLOCK_REQ_SELECT |   \
-	HI_CFG_HOST_INT_ENABLE)
-#else
-#define HI_CFG_DEF_VAL              \
-	(HI_CFG_UART_ENABLE |        \
-	HI_CFG_RST232_ENABLE |      \
-	HI_CFG_CLOCK_REQ_SELECT |   \
-	HI_CFG_HOST_INT_ENABLE)
-
-#endif
-
-#define REF_FREQ_19_2                       0
-#define REF_FREQ_26_0                       1
-#define REF_FREQ_38_4                       2
-#define REF_FREQ_40_0                       3
-#define REF_FREQ_33_6                       4
-#define REF_FREQ_NUM                        5
-
-#define LUT_PARAM_INTEGER_DIVIDER           0
-#define LUT_PARAM_FRACTIONAL_DIVIDER        1
-#define LUT_PARAM_ATTN_BB                   2
-#define LUT_PARAM_ALPHA_BB                  3
-#define LUT_PARAM_STOP_TIME_BB              4
-#define LUT_PARAM_BB_PLL_LOOP_FILTER        5
-#define LUT_PARAM_NUM                       6
-
-#define ACX_EEPROMLESS_IND_REG              (SCR_PAD4)
-#define USE_EEPROM                          0
-#define SOFT_RESET_MAX_TIME                 1000000
-#define SOFT_RESET_STALL_TIME               1000
-#define NVS_DATA_BUNDARY_ALIGNMENT          4
-
-
-/* Firmware image load chunk size */
-#define CHUNK_SIZE          512
-
-/* Firmware image header size */
-#define FW_HDR_SIZE 8
-
-#define ECPU_CONTROL_HALT					0x00000101
-
-
-/******************************************************************************
-
-    CHANNELS, BAND & REG DOMAINS definitions
-
-******************************************************************************/
-
-
-enum {
-	RADIO_BAND_2_4GHZ = 0,  /* 2.4 Ghz band */
-	RADIO_BAND_5GHZ = 1,    /* 5 Ghz band */
-	RADIO_BAND_JAPAN_4_9_GHZ = 2,
-	DEFAULT_BAND = RADIO_BAND_2_4GHZ,
-	INVALID_BAND = 0xFE,
-	MAX_RADIO_BANDS = 0xFF
-};
-
-enum {
-	NO_RATE      = 0,
-	RATE_1MBPS   = 0x0A,
-	RATE_2MBPS   = 0x14,
-	RATE_5_5MBPS = 0x37,
-	RATE_6MBPS   = 0x0B,
-	RATE_9MBPS   = 0x0F,
-	RATE_11MBPS  = 0x6E,
-	RATE_12MBPS  = 0x0A,
-	RATE_18MBPS  = 0x0E,
-	RATE_22MBPS  = 0xDC,
-	RATE_24MBPS  = 0x09,
-	RATE_36MBPS  = 0x0D,
-	RATE_48MBPS  = 0x08,
-	RATE_54MBPS  = 0x0C
-};
-
-enum {
-	RATE_INDEX_1MBPS   =  0,
-	RATE_INDEX_2MBPS   =  1,
-	RATE_INDEX_5_5MBPS =  2,
-	RATE_INDEX_6MBPS   =  3,
-	RATE_INDEX_9MBPS   =  4,
-	RATE_INDEX_11MBPS  =  5,
-	RATE_INDEX_12MBPS  =  6,
-	RATE_INDEX_18MBPS  =  7,
-	RATE_INDEX_22MBPS  =  8,
-	RATE_INDEX_24MBPS  =  9,
-	RATE_INDEX_36MBPS  =  10,
-	RATE_INDEX_48MBPS  =  11,
-	RATE_INDEX_54MBPS  =  12,
-	RATE_INDEX_MAX     =  RATE_INDEX_54MBPS,
-	MAX_RATE_INDEX,
-	INVALID_RATE_INDEX = MAX_RATE_INDEX,
-	RATE_INDEX_ENUM_MAX_SIZE = 0x7FFFFFFF
-};
-
-enum {
-	RATE_MASK_1MBPS = 0x1,
-	RATE_MASK_2MBPS = 0x2,
-	RATE_MASK_5_5MBPS = 0x4,
-	RATE_MASK_11MBPS = 0x20,
-};
-
-#define SHORT_PREAMBLE_BIT   BIT(0) /* CCK or Barker depending on the rate */
-#define OFDM_RATE_BIT        BIT(6)
-#define PBCC_RATE_BIT        BIT(7)
-
-enum {
-	CCK_LONG = 0,
-	CCK_SHORT = SHORT_PREAMBLE_BIT,
-	PBCC_LONG = PBCC_RATE_BIT,
-	PBCC_SHORT = PBCC_RATE_BIT | SHORT_PREAMBLE_BIT,
-	OFDM = OFDM_RATE_BIT
-};
-
-/******************************************************************************
-
-Transmit-Descriptor RATE-SET field definitions...
-
-Define a new "Rate-Set" for TX path that incorporates the
-Rate & Modulation info into a single 16-bit field.
-
-TxdRateSet_t:
-b15   - Indicates Preamble type (1=SHORT, 0=LONG).
-	Notes:
-	Must be LONG (0) for 1Mbps rate.
-	Does not apply (set to 0) for RevG-OFDM rates.
-b14   - Indicates PBCC encoding (1=PBCC, 0=not).
-	Notes:
-	Does not apply (set to 0) for rates 1 and 2 Mbps.
-	Does not apply (set to 0) for RevG-OFDM rates.
-b13    - Unused (set to 0).
-b12-b0 - Supported Rate indicator bits as defined below.
-
-******************************************************************************/
-
-
-#define TNETW1251_CHIP_ID_PG1_0         0x07010101
-#define TNETW1251_CHIP_ID_PG1_1         0x07020101
-#define TNETW1251_CHIP_ID_PG1_2	        0x07030101
-
-/*************************************************************************
-
-    Interrupt Trigger Register (Host -> WiLink)
-
-**************************************************************************/
-
-/* Hardware to Embedded CPU Interrupts - first 32-bit register set */
-
-/*
- * Host Command Interrupt. Setting this bit masks
- * the interrupt that the host issues to inform
- * the FW that it has sent a command
- * to the Wlan hardware Command Mailbox.
- */
-#define INTR_TRIG_CMD       BIT(0)
-
-/*
- * Host Event Acknowlegde Interrupt. The host
- * sets this bit to acknowledge that it received
- * the unsolicited information from the event
- * mailbox.
- */
-#define INTR_TRIG_EVENT_ACK BIT(1)
-
-/*
- * The host sets this bit to inform the Wlan
- * FW that a TX packet is in the XFER
- * Buffer #0.
- */
-#define INTR_TRIG_TX_PROC0 BIT(2)
-
-/*
- * The host sets this bit to inform the FW
- * that it read a packet from RX XFER
- * Buffer #0.
- */
-#define INTR_TRIG_RX_PROC0 BIT(3)
-
-#define INTR_TRIG_DEBUG_ACK BIT(4)
-
-#define INTR_TRIG_STATE_CHANGED BIT(5)
-
-
-/* Hardware to Embedded CPU Interrupts - second 32-bit register set */
-
-/*
- * The host sets this bit to inform the FW
- * that it read a packet from RX XFER
- * Buffer #1.
- */
-#define INTR_TRIG_RX_PROC1 BIT(17)
-
-/*
- * The host sets this bit to inform the Wlan
- * hardware that a TX packet is in the XFER
- * Buffer #1.
- */
-#define INTR_TRIG_TX_PROC1 BIT(18)
-
-#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/rx.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/rx.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/rx.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/rx.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,208 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (c) 1998-2007 Texas Instruments Incorporated
- * Copyright (C) 2008 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#include <linux/skbuff.h>
-#include <net/mac80211.h>
-
-#include "wl12xx.h"
-#include "reg.h"
-#include "spi.h"
-#include "rx.h"
-
-static void wl12xx_rx_header(struct wl12xx *wl,
-			     struct wl12xx_rx_descriptor *desc)
-{
-	u32 rx_packet_ring_addr;
-
-	rx_packet_ring_addr = wl->data_path->rx_packet_ring_addr;
-	if (wl->rx_current_buffer)
-		rx_packet_ring_addr += wl->data_path->rx_packet_ring_chunk_size;
-
-	wl12xx_spi_mem_read(wl, rx_packet_ring_addr, desc,
-			    sizeof(struct wl12xx_rx_descriptor));
-}
-
-static void wl12xx_rx_status(struct wl12xx *wl,
-			     struct wl12xx_rx_descriptor *desc,
-			     struct ieee80211_rx_status *status,
-			     u8 beacon)
-{
-	memset(status, 0, sizeof(struct ieee80211_rx_status));
-
-	status->band = IEEE80211_BAND_2GHZ;
-	status->mactime = desc->timestamp;
-
-	/*
-	 * The rx status timestamp is a 32 bits value while the TSF is a
-	 * 64 bits one.
-	 * For IBSS merging, TSF is mandatory, so we have to get it
-	 * somehow, so we ask for ACX_TSF_INFO.
-	 * That could be moved to the get_tsf() hook, but unfortunately,
-	 * this one must be atomic, while our SPI routines can sleep.
-	 */
-	if ((wl->bss_type == BSS_TYPE_IBSS) && beacon) {
-		u64 mactime;
-		int ret;
-		struct wl12xx_command cmd;
-		struct acx_tsf_info *tsf_info;
-
-		memset(&cmd, 0, sizeof(cmd));
-
-		ret = wl12xx_cmd_interrogate(wl, ACX_TSF_INFO,
-					     sizeof(struct acx_tsf_info),
-					     &cmd);
-		if (ret < 0) {
-			wl12xx_warning("ACX_FW_REV interrogate failed");
-			return;
-		}
-
-		tsf_info = (struct acx_tsf_info *)&(cmd.parameters);
-
-		mactime = tsf_info->current_tsf_lsb |
-			(tsf_info->current_tsf_msb << 31);
-
-		status->mactime = mactime;
-	}
-
-	status->signal = desc->rssi;
-	status->qual = (desc->rssi - WL12XX_RX_MIN_RSSI) * 100 /
-		(WL12XX_RX_MAX_RSSI - WL12XX_RX_MIN_RSSI);
-	status->qual = min(status->qual, 100);
-	status->qual = max(status->qual, 0);
-
-	/*
-	 * FIXME: guessing that snr needs to be divided by two, otherwise
-	 * the values don't make any sense
-	 */
-	status->noise = desc->rssi - desc->snr / 2;
-
-	status->freq = ieee80211_channel_to_frequency(desc->channel);
-
-	status->flag |= RX_FLAG_TSFT;
-
-	if (desc->flags & RX_DESC_ENCRYPTION_MASK) {
-		status->flag |= RX_FLAG_IV_STRIPPED | RX_FLAG_MMIC_STRIPPED;
-
-		if (likely(!(desc->flags & RX_DESC_DECRYPT_FAIL)))
-			status->flag |= RX_FLAG_DECRYPTED;
-
-		if (unlikely(desc->flags & RX_DESC_MIC_FAIL))
-			status->flag |= RX_FLAG_MMIC_ERROR;
-	}
-
-	if (unlikely(!(desc->flags & RX_DESC_VALID_FCS)))
-		status->flag |= RX_FLAG_FAILED_FCS_CRC;
-
-
-	/* FIXME: set status->rate_idx */
-}
-
-static void wl12xx_rx_body(struct wl12xx *wl,
-			   struct wl12xx_rx_descriptor *desc)
-{
-	struct sk_buff *skb;
-	struct ieee80211_rx_status status;
-	u8 *rx_buffer, beacon = 0;
-	u16 length, *fc;
-	u32 curr_id, last_id_inc, rx_packet_ring_addr;
-
-	length = WL12XX_RX_ALIGN(desc->length  - PLCP_HEADER_LENGTH);
-	curr_id = (desc->flags & RX_DESC_SEQNUM_MASK) >> RX_DESC_PACKETID_SHIFT;
-	last_id_inc = (wl->rx_last_id + 1) % (RX_MAX_PACKET_ID + 1);
-
-	if (last_id_inc != curr_id) {
-		wl12xx_warning("curr ID:%d, last ID inc:%d",
-			       curr_id, last_id_inc);
-		wl->rx_last_id = curr_id;
-	} else {
-		wl->rx_last_id = last_id_inc;
-	}
-
-	rx_packet_ring_addr = wl->data_path->rx_packet_ring_addr +
-		sizeof(struct wl12xx_rx_descriptor) + 20;
-	if (wl->rx_current_buffer)
-		rx_packet_ring_addr += wl->data_path->rx_packet_ring_chunk_size;
-
-	skb = dev_alloc_skb(length);
-	if (!skb) {
-		wl12xx_error("Couldn't allocate RX frame");
-		return;
-	}
-
-	rx_buffer = skb_put(skb, length);
-	wl12xx_spi_mem_read(wl, rx_packet_ring_addr, rx_buffer, length);
-
-	/* The actual lenght doesn't include the target's alignment */
-	skb->len = desc->length  - PLCP_HEADER_LENGTH;
-
-	fc = (u16 *)skb->data;
-
-	if ((*fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_BEACON)
-		beacon = 1;
-
-	wl12xx_rx_status(wl, desc, &status, beacon);
-
-	wl12xx_debug(DEBUG_RX, "rx skb 0x%p: %d B %s", skb, skb->len,
-		     beacon ? "beacon" : "");
-
-	ieee80211_rx(wl->hw, skb, &status);
-}
-
-static void wl12xx_rx_ack(struct wl12xx *wl)
-{
-	u32 data, addr;
-
-	if (wl->rx_current_buffer) {
-		addr = ACX_REG_INTERRUPT_TRIG_H;
-		data = INTR_TRIG_RX_PROC1;
-	} else {
-		addr = ACX_REG_INTERRUPT_TRIG;
-		data = INTR_TRIG_RX_PROC0;
-	}
-
-	wl12xx_reg_write32(wl, addr, data);
-
-	/* Toggle buffer ring */
-	wl->rx_current_buffer = !wl->rx_current_buffer;
-}
-
-
-void wl12xx_rx(struct wl12xx *wl)
-{
-	struct wl12xx_rx_descriptor rx_desc;
-
-	if (wl->state != WL12XX_STATE_ON)
-		return;
-
-	/* We first read the frame's header */
-	wl12xx_rx_header(wl, &rx_desc);
-
-	/* Now we can read the body */
-	wl12xx_rx_body(wl, &rx_desc);
-
-	/* Finally, we need to ACK the RX */
-	wl12xx_rx_ack(wl);
-
-	return;
-}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/rx.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/rx.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/rx.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/rx.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,122 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (c) 1998-2007 Texas Instruments Incorporated
- * Copyright (C) 2008 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#ifndef __WL12XX_RX_H__
-#define __WL12XX_RX_H__
-
-#include <linux/bitops.h>
-
-/*
- * RX PATH
- *
- * The Rx path uses a double buffer and an rx_contro structure, each located
- * at a fixed address in the device memory. The host keeps track of which
- * buffer is available and alternates between them on a per packet basis.
- * The size of each of the two buffers is large enough to hold the longest
- * 802.3 packet.
- * The RX path goes like that:
- * 1) The target generates an interrupt each time a new packet is received.
- *   There are 2 RX interrupts, one for each buffer.
- * 2) The host reads the received packet from one of the double buffers.
- * 3) The host triggers a target interrupt.
- * 4) The target prepares the next RX packet.
- */
-
-#define WL12XX_RX_MAX_RSSI -30
-#define WL12XX_RX_MIN_RSSI -95
-
-#define WL12XX_RX_ALIGN_TO 4
-#define WL12XX_RX_ALIGN(len) (((len) + WL12XX_RX_ALIGN_TO - 1) & \
-			     ~(WL12XX_RX_ALIGN_TO - 1))
-
-#define SHORT_PREAMBLE_BIT   BIT(0)
-#define OFDM_RATE_BIT        BIT(6)
-#define PBCC_RATE_BIT        BIT(7)
-
-#define PLCP_HEADER_LENGTH 8
-#define RX_DESC_PACKETID_SHIFT 11
-#define RX_MAX_PACKET_ID 3
-
-#define RX_DESC_VALID_FCS         0x0001
-#define RX_DESC_MATCH_RXADDR1     0x0002
-#define RX_DESC_MCAST             0x0004
-#define RX_DESC_STAINTIM          0x0008
-#define RX_DESC_VIRTUAL_BM        0x0010
-#define RX_DESC_BCAST             0x0020
-#define RX_DESC_MATCH_SSID        0x0040
-#define RX_DESC_MATCH_BSSID       0x0080
-#define RX_DESC_ENCRYPTION_MASK   0x0300
-#define RX_DESC_MEASURMENT        0x0400
-#define RX_DESC_SEQNUM_MASK       0x1800
-#define	RX_DESC_MIC_FAIL	  0x2000
-#define	RX_DESC_DECRYPT_FAIL	  0x4000
-
-struct wl12xx_rx_descriptor {
-	u32 timestamp; /* In microseconds */
-	u16 length; /* Paylod length, including headers */
-	u16 flags;
-
-	/*
-	 * 0 - 802.11
-	 * 1 - 802.3
-	 * 2 - IP
-	 * 3 - Raw Codec
-	 */
-	u8 type;
-
-	/*
-	 * Recevied Rate:
-	 * 0x0A - 1MBPS
-	 * 0x14 - 2MBPS
-	 * 0x37 - 5_5MBPS
-	 * 0x0B - 6MBPS
-	 * 0x0F - 9MBPS
-	 * 0x6E - 11MBPS
-	 * 0x0A - 12MBPS
-	 * 0x0E - 18MBPS
-	 * 0xDC - 22MBPS
-	 * 0x09 - 24MBPS
-	 * 0x0D - 36MBPS
-	 * 0x08 - 48MBPS
-	 * 0x0C - 54MBPS
-	 */
-	u8 rate;
-
-	u8 mod_pre; /* Modulation and preamble */
-	u8 channel;
-
-	/*
-	 * 0 - 2.4 Ghz
-	 * 1 - 5 Ghz
-	 */
-	u8 band;
-
-	s8 rssi; /* in dB */
-	u8 rcpi; /* in dB */
-	u8 snr; /* in dB */
-} __attribute__ ((packed));
-
-void wl12xx_rx(struct wl12xx *wl);
-
-#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/spi.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/spi.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/spi.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/spi.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,356 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (C) 2008 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/crc7.h>
-#include <linux/spi/spi.h>
-
-#include "wl12xx.h"
-#include "wl12xx_80211.h"
-#include "reg.h"
-#include "spi.h"
-#include "ps.h"
-
-static int wl12xx_translate_reg_addr(struct wl12xx *wl, int addr)
-{
-	/* If the address is lower than REGISTERS_BASE, it means that this is
-	 * a chip-specific register address, so look it up in the registers
-	 * table */
-	if (addr < REGISTERS_BASE) {
-		/* Make sure we don't go over the table */
-		if (addr >= ACX_REG_TABLE_LEN) {
-			wl12xx_error("address out of range (%d)", addr);
-			return -EINVAL;
-		}
-		addr = wl->chip.acx_reg_table[addr];
-	}
-
-	return addr - wl->physical_reg_addr + wl->virtual_reg_addr;
-}
-
-static int wl12xx_translate_mem_addr(struct wl12xx *wl, int addr)
-{
-	return addr - wl->physical_mem_addr + wl->virtual_mem_addr;
-}
-
-
-void wl12xx_spi_reset(struct wl12xx *wl)
-{
-	u8 *cmd;
-	struct spi_transfer t;
-	struct spi_message m;
-
-	cmd = kzalloc(WSPI_INIT_CMD_LEN, GFP_KERNEL);
-	if (!cmd) {
-		wl12xx_error("could not allocate cmd for spi reset");
-		return;
-	}
-
-	memset(&t, 0, sizeof(t));
-	spi_message_init(&m);
-
-	memset(cmd, 0xff, WSPI_INIT_CMD_LEN);
-
-	t.tx_buf = cmd;
-	t.len = WSPI_INIT_CMD_LEN;
-	spi_message_add_tail(&t, &m);
-
-	spi_sync(wl->spi, &m);
-
-	wl12xx_dump(DEBUG_SPI, "spi reset -> ", cmd, WSPI_INIT_CMD_LEN);
-}
-
-void wl12xx_spi_init(struct wl12xx *wl)
-{
-	u8 crc[WSPI_INIT_CMD_CRC_LEN], *cmd;
-	struct spi_transfer t;
-	struct spi_message m;
-
-	cmd = kzalloc(WSPI_INIT_CMD_LEN, GFP_KERNEL);
-	if (!cmd) {
-		wl12xx_error("could not allocate cmd for spi init");
-		return;
-	}
-
-	memset(crc, 0, sizeof(crc));
-	memset(&t, 0, sizeof(t));
-	spi_message_init(&m);
-
-	/*
-	 * Set WSPI_INIT_COMMAND
-	 * the data is being send from the MSB to LSB
-	 */
-	cmd[2] = 0xff;
-	cmd[3] = 0xff;
-	cmd[1] = WSPI_INIT_CMD_START | WSPI_INIT_CMD_TX;
-	cmd[0] = 0;
-	cmd[7] = 0;
-	cmd[6] |= HW_ACCESS_WSPI_INIT_CMD_MASK << 3;
-	cmd[6] |= HW_ACCESS_WSPI_FIXED_BUSY_LEN & WSPI_INIT_CMD_FIXEDBUSY_LEN;
-
-	if (HW_ACCESS_WSPI_FIXED_BUSY_LEN == 0)
-		cmd[5] |=  WSPI_INIT_CMD_DIS_FIXEDBUSY;
-	else
-		cmd[5] |= WSPI_INIT_CMD_EN_FIXEDBUSY;
-
-	cmd[5] |= WSPI_INIT_CMD_IOD | WSPI_INIT_CMD_IP | WSPI_INIT_CMD_CS
-		| WSPI_INIT_CMD_WSPI | WSPI_INIT_CMD_WS;
-
-	crc[0] = cmd[1];
-	crc[1] = cmd[0];
-	crc[2] = cmd[7];
-	crc[3] = cmd[6];
-	crc[4] = cmd[5];
-
-	cmd[4] |= crc7(0, crc, WSPI_INIT_CMD_CRC_LEN) << 1;
-	cmd[4] |= WSPI_INIT_CMD_END;
-
-	t.tx_buf = cmd;
-	t.len = WSPI_INIT_CMD_LEN;
-	spi_message_add_tail(&t, &m);
-
-	spi_sync(wl->spi, &m);
-
-	wl12xx_dump(DEBUG_SPI, "spi init -> ", cmd, WSPI_INIT_CMD_LEN);
-}
-
-/* Set the SPI partitions to access the chip addresses
- *
- * There are two VIRTUAL (SPI) partitions (the memory partition and the
- * registers partition), which are mapped to two different areas of the
- * PHYSICAL (hardware) memory.  This function also makes other checks to
- * ensure that the partitions are not overlapping.  In the diagram below, the
- * memory partition comes before the register partition, but the opposite is
- * also supported.
- *
- *                               PHYSICAL address
- *                                     space
- *
- *                                    |    |
- *                                 ...+----+--> mem_start
- *          VIRTUAL address     ...   |    |
- *               space       ...      |    | [PART_0]
- *                        ...         |    |
- * 0x00000000 <--+----+...         ...+----+--> mem_start + mem_size
- *               |    |         ...   |    |
- *               |MEM |      ...      |    |
- *               |    |   ...         |    |
- *  part_size <--+----+...            |    | {unused area)
- *               |    |   ...         |    |
- *               |REG |      ...      |    |
- *  part_size    |    |         ...   |    |
- *      +     <--+----+...         ...+----+--> reg_start
- *  reg_size              ...         |    |
- *                           ...      |    | [PART_1]
- *                              ...   |    |
- *                                 ...+----+--> reg_start + reg_size
- *                                    |    |
- *
- */
-void wl12xx_set_partition(struct wl12xx *wl,
-			  u32 mem_start, u32 mem_size,
-			  u32 reg_start, u32 reg_size)
-{
-	u8 tx_buf[sizeof(u32) + 2 * sizeof(struct wl12xx_partition)];
-	struct wl12xx_partition *partition;
-	struct spi_transfer t;
-	struct spi_message m;
-	u32 *cmd;
-	size_t len;
-	int addr;
-
-	spi_message_init(&m);
-	memset(&t, 0, sizeof(t));
-	memset(tx_buf, 0, sizeof(tx_buf));
-
-	cmd = (u32 *) tx_buf;
-	partition = (struct wl12xx_partition *) (tx_buf + sizeof(u32));
-	addr = HW_ACCESS_PART0_SIZE_ADDR;
-	len = 2 * sizeof(struct wl12xx_partition);
-
-	*cmd |= WSPI_CMD_WRITE;
-	*cmd |= (len << WSPI_CMD_BYTE_LENGTH_OFFSET) & WSPI_CMD_BYTE_LENGTH;
-	*cmd |= addr & WSPI_CMD_BYTE_ADDR;
-
-	wl12xx_debug(DEBUG_SPI, "mem_start %08X mem_size %08X",
-		     mem_start, mem_size);
-	wl12xx_debug(DEBUG_SPI, "reg_start %08X reg_size %08X",
-		     reg_start, reg_size);
-
-	/* Make sure that the two partitions together don't exceed the
-	 * address range */
-	if ((mem_size + reg_size) > HW_ACCESS_MEMORY_MAX_RANGE) {
-		wl12xx_debug(DEBUG_SPI, "Total size exceeds maximum virtual"
-			     " address range.  Truncating partition[0].");
-		mem_size = HW_ACCESS_MEMORY_MAX_RANGE - reg_size;
-		wl12xx_debug(DEBUG_SPI, "mem_start %08X mem_size %08X",
-			     mem_start, mem_size);
-		wl12xx_debug(DEBUG_SPI, "reg_start %08X reg_size %08X",
-			     reg_start, reg_size);
-	}
-
-	if ((mem_start < reg_start) &&
-	    ((mem_start + mem_size) > reg_start)) {
-		/* Guarantee that the memory partition doesn't overlap the
-		 * registers partition */
-		wl12xx_debug(DEBUG_SPI, "End of partition[0] is "
-			     "overlapping partition[1].  Adjusted.");
-		mem_size = reg_start - mem_start;
-		wl12xx_debug(DEBUG_SPI, "mem_start %08X mem_size %08X",
-			     mem_start, mem_size);
-		wl12xx_debug(DEBUG_SPI, "reg_start %08X reg_size %08X",
-			     reg_start, reg_size);
-	} else if ((reg_start < mem_start) &&
-		   ((reg_start + reg_size) > mem_start)) {
-		/* Guarantee that the register partition doesn't overlap the
-		 * memory partition */
-		wl12xx_debug(DEBUG_SPI, "End of partition[1] is"
-			     " overlapping partition[0].  Adjusted.");
-		reg_size = mem_start - reg_start;
-		wl12xx_debug(DEBUG_SPI, "mem_start %08X mem_size %08X",
-			     mem_start, mem_size);
-		wl12xx_debug(DEBUG_SPI, "reg_start %08X reg_size %08X",
-			     reg_start, reg_size);
-	}
-
-	partition[0].start = mem_start;
-	partition[0].size  = mem_size;
-	partition[1].start = reg_start;
-	partition[1].size  = reg_size;
-
-	wl->physical_mem_addr = mem_start;
-	wl->physical_reg_addr = reg_start;
-
-	wl->virtual_mem_addr = 0;
-	wl->virtual_reg_addr = mem_size;
-
-	t.tx_buf = tx_buf;
-	t.len = sizeof(tx_buf);
-	spi_message_add_tail(&t, &m);
-
-	spi_sync(wl->spi, &m);
-}
-
-void wl12xx_spi_read(struct wl12xx *wl, int addr, void *buf,
-		     size_t len)
-{
-	struct spi_transfer t[3];
-	struct spi_message m;
-	char busy_buf[TNETWIF_READ_OFFSET_BYTES];
-	u32 cmd;
-
-	cmd = 0;
-	cmd |= WSPI_CMD_READ;
-	cmd |= (len << WSPI_CMD_BYTE_LENGTH_OFFSET) & WSPI_CMD_BYTE_LENGTH;
-	cmd |= addr & WSPI_CMD_BYTE_ADDR;
-
-	spi_message_init(&m);
-	memset(t, 0, sizeof(t));
-
-	t[0].tx_buf = &cmd;
-	t[0].len = 4;
-	spi_message_add_tail(&t[0], &m);
-
-	/* Busy and non busy words read */
-	t[1].rx_buf = busy_buf;
-	t[1].len = TNETWIF_READ_OFFSET_BYTES;
-	spi_message_add_tail(&t[1], &m);
-
-	t[2].rx_buf = buf;
-	t[2].len = len;
-	spi_message_add_tail(&t[2], &m);
-
-	spi_sync(wl->spi, &m);
-
-	/* FIXME: check busy words */
-}
-
-void wl12xx_spi_write(struct wl12xx *wl, int addr, void *buf,
-		      size_t len)
-{
-	struct spi_transfer t[2];
-	struct spi_message m;
-	u32 cmd;
-
-	cmd = 0;
-	cmd |= WSPI_CMD_WRITE;
-	cmd |= (len << WSPI_CMD_BYTE_LENGTH_OFFSET) & WSPI_CMD_BYTE_LENGTH;
-	cmd |= addr & WSPI_CMD_BYTE_ADDR;
-
-	spi_message_init(&m);
-	memset(t, 0, sizeof(t));
-
-	t[0].tx_buf = &cmd;
-	t[0].len = sizeof(cmd);
-	spi_message_add_tail(&t[0], &m);
-
-	t[1].tx_buf = buf;
-	t[1].len = len;
-	spi_message_add_tail(&t[1], &m);
-
-	spi_sync(wl->spi, &m);
-
-	wl12xx_dump(DEBUG_SPI, "spi_write cmd -> ", &cmd, sizeof(cmd));
-	wl12xx_dump(DEBUG_SPI, "spi_write buf -> ", buf, len);
-}
-
-void wl12xx_spi_mem_read(struct wl12xx *wl, int addr, void *buf,
-			 size_t len)
-{
-	int physical;
-
-	physical = wl12xx_translate_mem_addr(wl, addr);
-
-	wl12xx_spi_read(wl, physical, buf, len);
-}
-
-void wl12xx_spi_mem_write(struct wl12xx *wl, int addr, void *buf,
-			  size_t len)
-{
-	int physical;
-
-	physical = wl12xx_translate_mem_addr(wl, addr);
-
-	wl12xx_spi_write(wl, physical, buf, len);
-}
-
-u32 wl12xx_mem_read32(struct wl12xx *wl, int addr)
-{
-	return wl12xx_read32(wl, wl12xx_translate_mem_addr(wl, addr));
-}
-
-void wl12xx_mem_write32(struct wl12xx *wl, int addr, u32 val)
-{
-	wl12xx_write32(wl, wl12xx_translate_mem_addr(wl, addr), val);
-}
-
-u32 wl12xx_reg_read32(struct wl12xx *wl, int addr)
-{
-	return wl12xx_read32(wl, wl12xx_translate_reg_addr(wl, addr));
-}
-
-void wl12xx_reg_write32(struct wl12xx *wl, int addr, u32 val)
-{
-	wl12xx_write32(wl, wl12xx_translate_reg_addr(wl, addr), val);
-}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/spi.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/spi.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/spi.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/spi.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,109 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (c) 1998-2007 Texas Instruments Incorporated
- * Copyright (C) 2008 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#ifndef __WL12XX_SPI_H__
-#define __WL12XX_SPI_H__
-
-#include "cmd.h"
-#include "acx.h"
-#include "reg.h"
-
-#define HW_ACCESS_MEMORY_MAX_RANGE		0x1FFC0
-
-#define HW_ACCESS_PART0_SIZE_ADDR           0x1FFC0
-#define HW_ACCESS_PART0_START_ADDR          0x1FFC4
-#define HW_ACCESS_PART1_SIZE_ADDR           0x1FFC8
-#define HW_ACCESS_PART1_START_ADDR          0x1FFCC
-
-#define HW_ACCESS_REGISTER_SIZE             4
-
-#define HW_ACCESS_PRAM_MAX_RANGE		0x3c000
-
-#define WSPI_CMD_READ                 0x40000000
-#define WSPI_CMD_WRITE                0x00000000
-#define WSPI_CMD_FIXED                0x20000000
-#define WSPI_CMD_BYTE_LENGTH          0x1FFE0000
-#define WSPI_CMD_BYTE_LENGTH_OFFSET   17
-#define WSPI_CMD_BYTE_ADDR            0x0001FFFF
-
-#define WSPI_INIT_CMD_CRC_LEN       5
-
-#define WSPI_INIT_CMD_START         0x00
-#define WSPI_INIT_CMD_TX            0x40
-/* the extra bypass bit is sampled by the TNET as '1' */
-#define WSPI_INIT_CMD_BYPASS_BIT    0x80
-#define WSPI_INIT_CMD_FIXEDBUSY_LEN 0x07
-#define WSPI_INIT_CMD_EN_FIXEDBUSY  0x80
-#define WSPI_INIT_CMD_DIS_FIXEDBUSY 0x00
-#define WSPI_INIT_CMD_IOD           0x40
-#define WSPI_INIT_CMD_IP            0x20
-#define WSPI_INIT_CMD_CS            0x10
-#define WSPI_INIT_CMD_WS            0x08
-#define WSPI_INIT_CMD_WSPI          0x01
-#define WSPI_INIT_CMD_END           0x01
-
-#define WSPI_INIT_CMD_LEN           8
-
-#define TNETWIF_READ_OFFSET_BYTES  8
-#define HW_ACCESS_WSPI_FIXED_BUSY_LEN \
-		((TNETWIF_READ_OFFSET_BYTES - 4) / sizeof(u32))
-#define HW_ACCESS_WSPI_INIT_CMD_MASK  0
-
-
-/* Raw target IO, address is not translated */
-void wl12xx_spi_read(struct wl12xx *wl, int addr, void *buf, size_t len);
-void wl12xx_spi_write(struct wl12xx *wl, int addr, void *buf, size_t len);
-
-/* Memory target IO, address is tranlated to partition 0 */
-void wl12xx_spi_mem_read(struct wl12xx *wl, int addr, void *buf, size_t len);
-void wl12xx_spi_mem_write(struct wl12xx *wl, int addr, void *buf, size_t len);
-u32 wl12xx_mem_read32(struct wl12xx *wl, int addr);
-void wl12xx_mem_write32(struct wl12xx *wl, int addr, u32 val);
-
-/* Registers IO */
-u32 wl12xx_reg_read32(struct wl12xx *wl, int addr);
-void wl12xx_reg_write32(struct wl12xx *wl, int addr, u32 val);
-
-/* INIT and RESET words */
-void wl12xx_spi_reset(struct wl12xx *wl);
-void wl12xx_spi_init(struct wl12xx *wl);
-void wl12xx_set_partition(struct wl12xx *wl,
-			  u32 part_start, u32 part_size,
-			  u32 reg_start,  u32 reg_size);
-
-static inline u32 wl12xx_read32(struct wl12xx *wl, int addr)
-{
-	u32 response;
-
-	wl12xx_spi_read(wl, addr, &response, sizeof(u32));
-
-	return response;
-}
-
-static inline void wl12xx_write32(struct wl12xx *wl, int addr, u32 val)
-{
-	wl12xx_spi_write(wl, addr, &val, sizeof(u32));
-}
-
-#endif /* __WL12XX_SPI_H__ */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/tx.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/tx.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/tx.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/tx.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,559 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (c) 1998-2007 Texas Instruments Incorporated
- * Copyright (C) 2008 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-
-#include "wl12xx.h"
-#include "reg.h"
-#include "spi.h"
-#include "tx.h"
-#include "ps.h"
-
-static bool wl12xx_tx_double_buffer_busy(struct wl12xx *wl, u32 data_out_count)
-{
-	int used, data_in_count;
-
-	data_in_count = wl->data_in_count;
-
-	if (data_in_count < data_out_count)
-		/* data_in_count has wrapped */
-		data_in_count += TX_STATUS_DATA_OUT_COUNT_MASK + 1;
-
-	used = data_in_count - data_out_count;
-
-	WARN_ON(used < 0);
-	WARN_ON(used > DP_TX_PACKET_RING_CHUNK_NUM);
-
-	if (used >= DP_TX_PACKET_RING_CHUNK_NUM)
-		return true;
-	else
-		return false;
-}
-
-static int wl12xx_tx_path_status(struct wl12xx *wl)
-{
-	u32 status, addr, data_out_count;
-	bool busy;
-
-	addr = wl->data_path->tx_control_addr;
-	status = wl12xx_mem_read32(wl, addr);
-	data_out_count = status & TX_STATUS_DATA_OUT_COUNT_MASK;
-	busy = wl12xx_tx_double_buffer_busy(wl, data_out_count);
-
-	if (busy)
-		return -EBUSY;
-
-	return 0;
-}
-
-static int wl12xx_tx_id(struct wl12xx *wl, struct sk_buff *skb)
-{
-	int i;
-
-	for (i = 0; i < FW_TX_CMPLT_BLOCK_SIZE; i++)
-		if (wl->tx_frames[i] == NULL) {
-			wl->tx_frames[i] = skb;
-			return i;
-		}
-
-	return -EBUSY;
-}
-
-static void wl12xx_tx_control(struct tx_double_buffer_desc *tx_hdr,
-			      struct ieee80211_tx_info *control, u16 fc)
-{
-	*(u16 *)&tx_hdr->control = 0;
-
-	tx_hdr->control.rate_policy = 0;
-
-	/* 802.11 packets */
-	tx_hdr->control.packet_type = 0;
-
-	if (control->flags & IEEE80211_TX_CTL_NO_ACK)
-		tx_hdr->control.ack_policy = 1;
-
-	tx_hdr->control.tx_complete = 1;
-
-	if ((fc & IEEE80211_FTYPE_DATA) &&
-	    ((fc & IEEE80211_STYPE_QOS_DATA) ||
-	     (fc & IEEE80211_STYPE_QOS_NULLFUNC)))
-		tx_hdr->control.qos = 1;
-}
-
-/* RSN + MIC = 8 + 8 = 16 bytes (worst case - AES). */
-#define MAX_MSDU_SECURITY_LENGTH      16
-#define MAX_MPDU_SECURITY_LENGTH      16
-#define WLAN_QOS_HDR_LEN              26
-#define MAX_MPDU_HEADER_AND_SECURITY  (MAX_MPDU_SECURITY_LENGTH + \
-				       WLAN_QOS_HDR_LEN)
-#define HW_BLOCK_SIZE                 252
-static void wl12xx_tx_frag_block_num(struct tx_double_buffer_desc *tx_hdr)
-{
-	u16 payload_len, frag_threshold, mem_blocks;
-	u16 num_mpdus, mem_blocks_per_frag;
-
-	frag_threshold = IEEE80211_MAX_FRAG_THRESHOLD;
-	tx_hdr->frag_threshold = cpu_to_le16(frag_threshold);
-
-	payload_len = tx_hdr->length + MAX_MSDU_SECURITY_LENGTH;
-
-	if (payload_len > frag_threshold) {
-		mem_blocks_per_frag =
-			((frag_threshold + MAX_MPDU_HEADER_AND_SECURITY) /
-			 HW_BLOCK_SIZE) + 1;
-		num_mpdus = payload_len / frag_threshold;
-		mem_blocks = num_mpdus * mem_blocks_per_frag;
-		payload_len -= num_mpdus * frag_threshold;
-		num_mpdus++;
-
-	} else {
-		mem_blocks_per_frag = 0;
-		mem_blocks = 0;
-		num_mpdus = 1;
-	}
-
-	mem_blocks += (payload_len / HW_BLOCK_SIZE) + 1;
-
-	if (num_mpdus > 1)
-		mem_blocks += min(num_mpdus, mem_blocks_per_frag);
-
-	tx_hdr->num_mem_blocks = mem_blocks;
-}
-
-static int wl12xx_tx_fill_hdr(struct wl12xx *wl, struct sk_buff *skb,
-			      struct ieee80211_tx_info *control)
-{
-	struct tx_double_buffer_desc *tx_hdr;
-	struct ieee80211_rate *rate;
-	int id;
-	u16 fc;
-
-	if (!skb)
-		return -EINVAL;
-
-	id = wl12xx_tx_id(wl, skb);
-	if (id < 0)
-		return id;
-
-	fc = *(u16 *)skb->data;
-	tx_hdr = (struct tx_double_buffer_desc *) skb_push(skb,
-							   sizeof(*tx_hdr));
-
-	tx_hdr->length = cpu_to_le16(skb->len - sizeof(*tx_hdr));
-	rate = ieee80211_get_tx_rate(wl->hw, control);
-	tx_hdr->rate = cpu_to_le16(rate->hw_value);
-	tx_hdr->expiry_time = cpu_to_le32(1 << 16);
-	tx_hdr->id = id;
-
-	/* FIXME: how to get the correct queue id? */
-	tx_hdr->xmit_queue = 0;
-
-	wl12xx_tx_control(tx_hdr, control, fc);
-	wl12xx_tx_frag_block_num(tx_hdr);
-
-	return 0;
-}
-
-/* We copy the packet to the target */
-static int wl12xx_tx_send_packet(struct wl12xx *wl, struct sk_buff *skb,
-				 struct ieee80211_tx_info *control)
-{
-	struct tx_double_buffer_desc *tx_hdr;
-	int len;
-	u32 addr;
-
-	if (!skb)
-		return -EINVAL;
-
-	tx_hdr = (struct tx_double_buffer_desc *) skb->data;
-
-	if (control->control.hw_key &&
-	    control->control.hw_key->alg == ALG_TKIP) {
-		int hdrlen;
-		u16 fc;
-		u8 *pos;
-
-		fc = *(u16 *)(skb->data + sizeof(*tx_hdr));
-		tx_hdr->length += WL12XX_TKIP_IV_SPACE;
-
-		hdrlen = ieee80211_hdrlen(fc);
-
-		pos = skb_push(skb, WL12XX_TKIP_IV_SPACE);
-		memmove(pos, pos + WL12XX_TKIP_IV_SPACE,
-			sizeof(*tx_hdr) + hdrlen);
-	}
-
-	/* Revisit. This is a workaround for getting non-aligned packets.
-	   This happens at least with EAPOL packets from the user space.
-	   Our DMA requires packets to be aligned on a 4-byte boundary.
-	*/
-	if (unlikely((long)skb->data & 0x03)) {
-		int offset = (4 - (long)skb->data) & 0x03;
-		wl12xx_debug(DEBUG_TX, "skb offset %d", offset);
-
-		/* check whether the current skb can be used */
-		if (!skb_cloned(skb) && (skb_tailroom(skb) >= offset)) {
-			unsigned char *src = skb->data;
-
-			/* align the buffer on a 4-byte boundary */
-			skb_reserve(skb, offset);
-			memmove(skb->data, src, skb->len);
-		} else {
-			wl12xx_info("No handler, fixme!");
-			return -EINVAL;
-		}
-	}
-
-	/* Our skb->data at this point includes the HW header */
-	len = WL12XX_TX_ALIGN(skb->len);
-
-	if (wl->data_in_count & 0x1)
-		addr = wl->data_path->tx_packet_ring_addr +
-			wl->data_path->tx_packet_ring_chunk_size;
-	else
-		addr = wl->data_path->tx_packet_ring_addr;
-
-	wl12xx_spi_mem_write(wl, addr, skb->data, len);
-
-	wl12xx_debug(DEBUG_TX, "tx id %u skb 0x%p payload %u rate 0x%x",
-		     tx_hdr->id, skb, tx_hdr->length, tx_hdr->rate);
-
-	return 0;
-}
-
-static void wl12xx_tx_trigger(struct wl12xx *wl)
-{
-	u32 data, addr;
-
-	if (wl->data_in_count & 0x1) {
-		addr = ACX_REG_INTERRUPT_TRIG_H;
-		data = INTR_TRIG_TX_PROC1;
-	} else {
-		addr = ACX_REG_INTERRUPT_TRIG;
-		data = INTR_TRIG_TX_PROC0;
-	}
-
-	wl12xx_reg_write32(wl, addr, data);
-
-	/* Bumping data in */
-	wl->data_in_count = (wl->data_in_count + 1) &
-		TX_STATUS_DATA_OUT_COUNT_MASK;
-}
-
-/* caller must hold wl->mutex */
-static int wl12xx_tx_frame(struct wl12xx *wl, struct sk_buff *skb)
-{
-	struct ieee80211_tx_info *info;
-	int ret = 0;
-	u8 idx;
-
-	info = IEEE80211_SKB_CB(skb);
-
-	if (info->control.hw_key) {
-		idx = info->control.hw_key->hw_key_idx;
-		if (unlikely(wl->default_key != idx)) {
-			ret = wl12xx_acx_default_key(wl, idx);
-			if (ret < 0)
-				return ret;
-		}
-	}
-
-	ret = wl12xx_tx_path_status(wl);
-	if (ret < 0)
-		return ret;
-
-	ret = wl12xx_tx_fill_hdr(wl, skb, info);
-	if (ret < 0)
-		return ret;
-
-	ret = wl12xx_tx_send_packet(wl, skb, info);
-	if (ret < 0)
-		return ret;
-
-	wl12xx_tx_trigger(wl);
-
-	return ret;
-}
-
-void wl12xx_tx_work(struct work_struct *work)
-{
-	struct wl12xx *wl = container_of(work, struct wl12xx, tx_work);
-	struct sk_buff *skb;
-	bool woken_up = false;
-	int ret;
-
-	mutex_lock(&wl->mutex);
-
-	if (unlikely(wl->state == WL12XX_STATE_OFF))
-		goto out;
-
-	while ((skb = skb_dequeue(&wl->tx_queue))) {
-		if (!woken_up) {
-			wl12xx_ps_elp_wakeup(wl);
-			woken_up = true;
-		}
-
-		ret = wl12xx_tx_frame(wl, skb);
-		if (ret == -EBUSY) {
-			/* firmware buffer is full, stop queues */
-			wl12xx_debug(DEBUG_TX, "tx_work: fw buffer full, "
-				     "stop queues");
-			ieee80211_stop_queues(wl->hw);
-			wl->tx_queue_stopped = true;
-			skb_queue_head(&wl->tx_queue, skb);
-			goto out;
-		} else if (ret < 0) {
-			dev_kfree_skb(skb);
-			goto out;
-		}
-	}
-
-out:
-	if (woken_up)
-		wl12xx_ps_elp_sleep(wl);
-
-	mutex_unlock(&wl->mutex);
-}
-
-static const char *wl12xx_tx_parse_status(u8 status)
-{
-	/* 8 bit status field, one character per bit plus null */
-	static char buf[9];
-	int i = 0;
-
-	memset(buf, 0, sizeof(buf));
-
-	if (status & TX_DMA_ERROR)
-		buf[i++] = 'm';
-	if (status & TX_DISABLED)
-		buf[i++] = 'd';
-	if (status & TX_RETRY_EXCEEDED)
-		buf[i++] = 'r';
-	if (status & TX_TIMEOUT)
-		buf[i++] = 't';
-	if (status & TX_KEY_NOT_FOUND)
-		buf[i++] = 'k';
-	if (status & TX_ENCRYPT_FAIL)
-		buf[i++] = 'e';
-	if (status & TX_UNAVAILABLE_PRIORITY)
-		buf[i++] = 'p';
-
-	/* bit 0 is unused apparently */
-
-	return buf;
-}
-
-static void wl12xx_tx_packet_cb(struct wl12xx *wl,
-				struct tx_result *result)
-{
-	struct ieee80211_tx_info *info;
-	struct sk_buff *skb;
-	int hdrlen, ret;
-	u8 *frame;
-
-	skb = wl->tx_frames[result->id];
-	if (skb == NULL) {
-		wl12xx_error("SKB for packet %d is NULL", result->id);
-		return;
-	}
-
-	info = IEEE80211_SKB_CB(skb);
-
-	if (!(info->flags & IEEE80211_TX_CTL_NO_ACK)) {
-		if (result->status == TX_SUCCESS)
-			info->flags |= IEEE80211_TX_STAT_ACK;
-		if (result->status & TX_RETRY_EXCEEDED)
-			info->status.excessive_retries = 1;
-	}
-
-	info->status.retry_count = result->ack_failures;
-
-	/*
-	 * We have to remove our private TX header before pushing
-	 * the skb back to mac80211.
-	 */
-	frame = skb_pull(skb, sizeof(struct tx_double_buffer_desc));
-	if (info->control.hw_key &&
-	    info->control.hw_key->alg == ALG_TKIP) {
-		hdrlen = ieee80211_get_hdrlen_from_skb(skb);
-		memmove(frame + WL12XX_TKIP_IV_SPACE, frame, hdrlen);
-		skb_pull(skb, WL12XX_TKIP_IV_SPACE);
-	}
-
-	wl12xx_debug(DEBUG_TX, "tx status id %u skb 0x%p failures %u rate 0x%x"
-		     " status 0x%x (%s)",
-		     result->id, skb, result->ack_failures, result->rate,
-		     result->status, wl12xx_tx_parse_status(result->status));
-
-
-	ieee80211_tx_status(wl->hw, skb);
-
-	wl->tx_frames[result->id] = NULL;
-
-	if (wl->tx_queue_stopped) {
-		wl12xx_debug(DEBUG_TX, "cb: queue was stopped");
-
-		skb = skb_dequeue(&wl->tx_queue);
-
-		/* The skb can be NULL because tx_work might have been
-		   scheduled before the queue was stopped making the
-		   queue empty */
-
-		if (skb) {
-			ret = wl12xx_tx_frame(wl, skb);
-			if (ret == -EBUSY) {
-				/* firmware buffer is still full */
-				wl12xx_debug(DEBUG_TX, "cb: fw buffer "
-					     "still full");
-				skb_queue_head(&wl->tx_queue, skb);
-				return;
-			} else if (ret < 0) {
-				dev_kfree_skb(skb);
-				return;
-			}
-		}
-
-		wl12xx_debug(DEBUG_TX, "cb: waking queues");
-		ieee80211_wake_queues(wl->hw);
-		wl->tx_queue_stopped = false;
-	}
-}
-
-/* Called upon reception of a TX complete interrupt */
-void wl12xx_tx_complete(struct wl12xx *wl)
-{
-	int i, result_index, num_complete = 0;
-	struct tx_result result[FW_TX_CMPLT_BLOCK_SIZE], *result_ptr;
-
-	if (unlikely(wl->state != WL12XX_STATE_ON))
-		return;
-
-	/* First we read the result */
-	wl12xx_spi_mem_read(wl, wl->data_path->tx_complete_addr,
-			    result, sizeof(result));
-
-	result_index = wl->next_tx_complete;
-
-	for (i = 0; i < ARRAY_SIZE(result); i++) {
-		result_ptr = &result[result_index];
-
-		if (result_ptr->done_1 == 1 &&
-		    result_ptr->done_2 == 1) {
-			wl12xx_tx_packet_cb(wl, result_ptr);
-
-			result_ptr->done_1 = 0;
-			result_ptr->done_2 = 0;
-
-			result_index = (result_index + 1) &
-				(FW_TX_CMPLT_BLOCK_SIZE - 1);
-			num_complete++;
-		} else {
-			break;
-		}
-	}
-
-	/* Every completed frame needs to be acknowledged */
-	if (num_complete) {
-		/*
-		 * If we've wrapped, we have to clear
-		 * the results in 2 steps.
-		 */
-		if (result_index > wl->next_tx_complete) {
-			/* Only 1 write is needed */
-			wl12xx_spi_mem_write(wl,
-					     wl->data_path->tx_complete_addr +
-					     (wl->next_tx_complete *
-					      sizeof(struct tx_result)),
-					     &result[wl->next_tx_complete],
-					     num_complete *
-					     sizeof(struct tx_result));
-
-
-		} else if (result_index < wl->next_tx_complete) {
-			/* 2 writes are needed */
-			wl12xx_spi_mem_write(wl,
-					     wl->data_path->tx_complete_addr +
-					     (wl->next_tx_complete *
-					      sizeof(struct tx_result)),
-					     &result[wl->next_tx_complete],
-					     (FW_TX_CMPLT_BLOCK_SIZE -
-					      wl->next_tx_complete) *
-					     sizeof(struct tx_result));
-
-			wl12xx_spi_mem_write(wl,
-					     wl->data_path->tx_complete_addr,
-					     result,
-					     (num_complete -
-					      FW_TX_CMPLT_BLOCK_SIZE +
-					      wl->next_tx_complete) *
-					     sizeof(struct tx_result));
-
-		} else {
-			/* We have to write the whole array */
-			wl12xx_spi_mem_write(wl,
-					     wl->data_path->tx_complete_addr,
-					     result,
-					     FW_TX_CMPLT_BLOCK_SIZE *
-					     sizeof(struct tx_result));
-		}
-
-	}
-
-	wl->next_tx_complete = result_index;
-}
-
-/* caller must hold wl->mutex */
-void wl12xx_tx_flush(struct wl12xx *wl)
-{
-	int i;
-	struct sk_buff *skb;
-	struct ieee80211_tx_info *info;
-
-	/* TX failure */
-/* 	control->flags = 0; FIXME */
-
-	while ((skb = skb_dequeue(&wl->tx_queue))) {
-		info = IEEE80211_SKB_CB(skb);
-
-		wl12xx_debug(DEBUG_TX, "flushing skb 0x%p", skb);
-
-		if (!(info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS))
-				continue;
-
-		ieee80211_tx_status(wl->hw, skb);
-	}
-
-	for (i = 0; i < FW_TX_CMPLT_BLOCK_SIZE; i++)
-		if (wl->tx_frames[i] != NULL) {
-			skb = wl->tx_frames[i];
-			info = IEEE80211_SKB_CB(skb);
-
-			if (!(info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS))
-				continue;
-
-			ieee80211_tx_status(wl->hw, skb);
-			wl->tx_frames[i] = NULL;
-		}
-}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/tx.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/tx.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/tx.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/tx.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,215 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (c) 1998-2007 Texas Instruments Incorporated
- * Copyright (C) 2008 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#ifndef __WL12XX_TX_H__
-#define __WL12XX_TX_H__
-
-#include <linux/bitops.h>
-
-/*
- *
- * TX PATH
- *
- * The Tx path uses a double buffer and a tx_control structure, each located
- * at a fixed address in the device's memory. On startup, the host retrieves
- * the pointers to these addresses. A double buffer allows for continuous data
- * flow towards the device. The host keeps track of which buffer is available
- * and alternates between these two buffers on a per packet basis.
- *
- * The size of each of the two buffers is large enough to hold the longest
- * 802.3 packet - maximum size Ethernet packet + header + descriptor.
- * TX complete indication will be received a-synchronously in a TX done cyclic
- * buffer which is composed of 16 tx_result descriptors structures and is used
- * in a cyclic manner.
- *
- * The TX (HOST) procedure is as follows:
- * 1. Read the Tx path status, that will give the data_out_count.
- * 2. goto 1, if not possible.
- *    i.e. if data_in_count - data_out_count >= HwBuffer size (2 for double
- *    buffer).
- * 3. Copy the packet (preceded by double_buffer_desc), if possible.
- *    i.e. if data_in_count - data_out_count < HwBuffer size (2 for double
- *    buffer).
- * 4. increment data_in_count.
- * 5. Inform the firmware by generating a firmware internal interrupt.
- * 6. FW will increment data_out_count after it reads the buffer.
- *
- * The TX Complete procedure:
- * 1. To get a TX complete indication the host enables the tx_complete flag in
- *    the TX descriptor Structure.
- * 2. For each packet with a Tx Complete field set, the firmware adds the
- *    transmit results to the cyclic buffer (txDoneRing) and sets both done_1
- *    and done_2 to 1 to indicate driver ownership.
- * 3. The firmware sends a Tx Complete interrupt to the host to trigger the
- *    host to process the new data. Note: interrupt will be send per packet if
- *    TX complete indication was requested in tx_control or per crossing
- *    aggregation threshold.
- * 4. After receiving the Tx Complete interrupt, the host reads the
- *    TxDescriptorDone information in a cyclic manner and clears both done_1
- *    and done_2 fields.
- *
- */
-
-#define TX_COMPLETE_REQUIRED_BIT	0x80
-#define TX_STATUS_DATA_OUT_COUNT_MASK   0xf
-#define WL12XX_TX_ALIGN_TO 4
-#define WL12XX_TX_ALIGN(len) (((len) + WL12XX_TX_ALIGN_TO - 1) & \
-			     ~(WL12XX_TX_ALIGN_TO - 1))
-#define WL12XX_TKIP_IV_SPACE 4
-
-struct tx_control {
-	/* Rate Policy (class) index */
-	unsigned rate_policy:3;
-
-	/* When set, no ack policy is expected */
-	unsigned ack_policy:1;
-
-	/*
-	 * Packet type:
-	 * 0 -> 802.11
-	 * 1 -> 802.3
-	 * 2 -> IP
-	 * 3 -> raw codec
-	 */
-	unsigned packet_type:2;
-
-	/* If set, this is a QoS-Null or QoS-Data frame */
-	unsigned qos:1;
-
-	/*
-	 * If set, the target triggers the tx complete INT
-	 * upon frame sending completion.
-	 */
-	unsigned tx_complete:1;
-
-	/* 2 bytes padding before packet header */
-	unsigned xfer_pad:1;
-
-	unsigned reserved:7;
-} __attribute__ ((packed));
-
-
-struct tx_double_buffer_desc {
-	/* Length of payload, including headers. */
-	u16 length;
-
-	/*
-	 * A bit mask that specifies the initial rate to be used
-	 * Possible values are:
-	 * 0x0001 - 1Mbits
-	 * 0x0002 - 2Mbits
-	 * 0x0004 - 5.5Mbits
-	 * 0x0008 - 6Mbits
-	 * 0x0010 - 9Mbits
-	 * 0x0020 - 11Mbits
-	 * 0x0040 - 12Mbits
-	 * 0x0080 - 18Mbits
-	 * 0x0100 - 22Mbits
-	 * 0x0200 - 24Mbits
-	 * 0x0400 - 36Mbits
-	 * 0x0800 - 48Mbits
-	 * 0x1000 - 54Mbits
-	 */
-	u16 rate;
-
-	/* Time in us that a packet can spend in the target */
-	u32 expiry_time;
-
-	/* index of the TX queue used for this packet */
-	u8 xmit_queue;
-
-	/* Used to identify a packet */
-	u8 id;
-
-	struct tx_control control;
-
-	/*
-	 * The FW should cut the packet into fragments
-	 * of this size.
-	 */
-	u16 frag_threshold;
-
-	/* Numbers of HW queue blocks to be allocated */
-	u8 num_mem_blocks;
-
-	u8 reserved;
-} __attribute__ ((packed));
-
-enum {
-	TX_SUCCESS              = 0,
-	TX_DMA_ERROR            = BIT(7),
-	TX_DISABLED             = BIT(6),
-	TX_RETRY_EXCEEDED       = BIT(5),
-	TX_TIMEOUT              = BIT(4),
-	TX_KEY_NOT_FOUND        = BIT(3),
-	TX_ENCRYPT_FAIL         = BIT(2),
-	TX_UNAVAILABLE_PRIORITY = BIT(1),
-};
-
-struct tx_result {
-	/*
-	 * Ownership synchronization between the host and
-	 * the firmware. If done_1 and done_2 are cleared,
-	 * owned by the FW (no info ready).
-	 */
-	u8 done_1;
-
-	/* same as double_buffer_desc->id */
-	u8 id;
-
-	/*
-	 * Total air access duration consumed by this
-	 * packet, including all retries and overheads.
-	 */
-	u16 medium_usage;
-
-	/* Total media delay (from 1st EDCA AIFS counter until TX Complete). */
-	u32 medium_delay;
-
-	/* Time between host xfer and tx complete */
-	u32 fw_hnadling_time;
-
-	/* The LS-byte of the last TKIP sequence number. */
-	u8 lsb_seq_num;
-
-	/* Retry count */
-	u8 ack_failures;
-
-	/* At which rate we got a ACK */
-	u16 rate;
-
-	u16 reserved;
-
-	/* TX_* */
-	u8 status;
-
-	/* See done_1 */
-	u8 done_2;
-} __attribute__ ((packed));
-
-void wl12xx_tx_work(struct work_struct *work);
-void wl12xx_tx_complete(struct wl12xx *wl);
-void wl12xx_tx_flush(struct wl12xx *wl);
-
-#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl12xx.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl12xx.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl12xx.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl12xx.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,301 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (c) 1998-2007 Texas Instruments Incorporated
- * Copyright (C) 2008-2009 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#ifndef __WL12XX_H__
-#define __WL12XX_H__
-
-#include <linux/mutex.h>
-#include <linux/list.h>
-#include <linux/bitops.h>
-#include <net/mac80211.h>
-#include <mach/board.h>
-#include <mach/board-nokia.h>
-
-#define DRIVER_NAME "wl12xx"
-#define DRIVER_PREFIX DRIVER_NAME ": "
-
-enum {
-	DEBUG_NONE	= 0,
-	DEBUG_IRQ	= BIT(0),
-	DEBUG_SPI	= BIT(1),
-	DEBUG_BOOT	= BIT(2),
-	DEBUG_MAILBOX	= BIT(3),
-	DEBUG_NETLINK	= BIT(4),
-	DEBUG_EVENT	= BIT(5),
-	DEBUG_TX	= BIT(6),
-	DEBUG_RX	= BIT(7),
-	DEBUG_SCAN	= BIT(8),
-	DEBUG_CRYPT	= BIT(9),
-	DEBUG_PSM	= BIT(10),
-	DEBUG_MAC80211	= BIT(11),
-	DEBUG_CMD	= BIT(12),
-	DEBUG_ACX	= BIT(13),
-	DEBUG_ALL	= ~0,
-};
-
-#define DEBUG_LEVEL (DEBUG_NONE)
-
-#define DEBUG_DUMP_LIMIT 1024
-
-#define wl12xx_error(fmt, arg...) \
-	WARN(1, DRIVER_PREFIX "ERROR " fmt "\n", ##arg)
-
-#define wl12xx_warning(fmt, arg...) \
-	printk(KERN_WARNING DRIVER_PREFIX "WARNING " fmt "\n", ##arg)
-
-#define wl12xx_notice(fmt, arg...) \
-	printk(KERN_INFO DRIVER_PREFIX fmt "\n", ##arg)
-
-#define wl12xx_info(fmt, arg...) \
-	printk(KERN_DEBUG DRIVER_PREFIX fmt "\n", ##arg)
-
-#define wl12xx_debug(level, fmt, arg...) \
-	do { \
-		if (level & DEBUG_LEVEL) \
-			printk(KERN_DEBUG DRIVER_PREFIX fmt "\n", ##arg); \
-	} while (0)
-
-#define wl12xx_dump(level, prefix, buf, len)	\
-	do { \
-		if (level & DEBUG_LEVEL) \
-			print_hex_dump(KERN_INFO, DRIVER_PREFIX prefix, \
-				       DUMP_PREFIX_OFFSET, 16, 1,	\
-				       buf,				\
-				       min_t(size_t, len, DEBUG_DUMP_LIMIT), \
-				       0);				\
-	} while (0)
-
-#define wl12xx_dump_ascii(level, prefix, buf, len)	\
-	do { \
-		if (level & DEBUG_LEVEL) \
-			print_hex_dump(KERN_INFO, DRIVER_PREFIX prefix, \
-				       DUMP_PREFIX_OFFSET, 16, 1,	\
-				       buf,				\
-				       min_t(size_t, len, DEBUG_DUMP_LIMIT), \
-				       true);				\
-	} while (0)
-
-#define WL12XX_DEFAULT_RX_CONFIG (CFG_UNI_FILTER_EN |	\
-				  CFG_BSSID_FILTER_EN)
-
-#define WL12XX_DEFAULT_RX_FILTER (CFG_RX_PRSP_EN |  \
-				  CFG_RX_MGMT_EN |  \
-				  CFG_RX_DATA_EN |  \
-				  CFG_RX_CTL_EN |   \
-				  CFG_RX_BCN_EN |   \
-				  CFG_RX_AUTH_EN |  \
-				  CFG_RX_ASSOC_EN)
-
-
-struct boot_attr {
-	u32 radio_type;
-	u8 mac_clock;
-	u8 arm_clock;
-	int firmware_debug;
-	u32 minor;
-	u32 major;
-	u32 bugfix;
-};
-
-enum wl12xx_state {
-	WL12XX_STATE_OFF,
-	WL12XX_STATE_ON,
-	WL12XX_STATE_PLT,
-};
-
-enum wl12xx_partition_type {
-	PART_DOWN,
-	PART_WORK,
-	PART_DRPW,
-
-	PART_TABLE_LEN
-};
-
-struct wl12xx_partition {
-	u32 size;
-	u32 start;
-};
-
-struct wl12xx_partition_set {
-	struct wl12xx_partition mem;
-	struct wl12xx_partition reg;
-};
-
-struct wl12xx;
-
-/* FIXME: I'm not sure about this structure name */
-struct wl12xx_chip {
-	u32 id;
-
-	const char *fw_filename;
-	const char *nvs_filename;
-
-	char fw_ver[21];
-
-	unsigned int power_on_sleep;
-	int intr_cmd_complete;
-	int intr_init_complete;
-
-	int (*op_upload_fw)(struct wl12xx *wl);
-	int (*op_upload_nvs)(struct wl12xx *wl);
-	int (*op_boot)(struct wl12xx *wl);
-	void (*op_set_ecpu_ctrl)(struct wl12xx *wl, u32 flag);
-	void (*op_target_enable_interrupts)(struct wl12xx *wl);
-	int (*op_hw_init)(struct wl12xx *wl);
-	int (*op_plt_init)(struct wl12xx *wl);
-
-	struct wl12xx_partition_set *p_table;
-	enum wl12xx_acx_int_reg *acx_reg_table;
-};
-
-struct wl12xx {
-	struct ieee80211_hw *hw;
-	bool mac80211_registered;
-
-	struct spi_device *spi;
-
-	void (*set_power)(bool enable);
-	int irq;
-
-	enum wl12xx_state state;
-	struct mutex mutex;
-
-	int physical_mem_addr;
-	int physical_reg_addr;
-	int virtual_mem_addr;
-	int virtual_reg_addr;
-
-	struct wl12xx_chip chip;
-
-	int cmd_box_addr;
-	int event_box_addr;
-	struct boot_attr boot_attr;
-
-	u8 *fw;
-	size_t fw_len;
-	u8 *nvs;
-	size_t nvs_len;
-
-	u8 bssid[ETH_ALEN];
-	u8 mac_addr[ETH_ALEN];
-	u8 bss_type;
-	u8 ssid[IW_ESSID_MAX_SIZE + 1];
-	u8 ssid_len;
-	u8 listen_int;
-	int channel;
-
-	void *target_mem_map;
-	struct acx_data_path_params_resp *data_path;
-
-	/* Number of TX packets transferred to the FW, modulo 16 */
-	u32 data_in_count;
-
-	/* Frames scheduled for transmission, not handled yet */
-	struct sk_buff_head tx_queue;
-	bool tx_queue_stopped;
-
-	struct work_struct tx_work;
-	struct work_struct filter_work;
-
-	/* Pending TX frames */
-	struct sk_buff *tx_frames[16];
-
-	/*
-	 * Index pointing to the next TX complete entry
-	 * in the cyclic XT complete array we get from
-	 * the FW.
-	 */
-	u32 next_tx_complete;
-
-	/* FW Rx counter */
-	u32 rx_counter;
-
-	/* Rx frames handled */
-	u32 rx_handled;
-
-	/* Current double buffer */
-	u32 rx_current_buffer;
-	u32 rx_last_id;
-
-	/* The target interrupt mask */
-	u32 intr_mask;
-	struct work_struct irq_work;
-
-	/* The mbox event mask */
-	u32 event_mask;
-
-	/* Mailbox pointers */
-	u32 mbox_ptr[2];
-
-	/* Are we currently scanning */
-	bool scanning;
-
-	/* Our association ID */
-	u16 aid;
-
-	/* Default key (for WEP) */
-	u32 default_key;
-
-	unsigned int tx_mgmt_frm_rate;
-	unsigned int tx_mgmt_frm_mod;
-
-	unsigned int rx_config;
-	unsigned int rx_filter;
-
-	/* is firmware in elp mode */
-	bool elp;
-
-	/* we can be in psm, but not in elp, we have to differentiate */
-	bool psm;
-
-	/* PSM mode requested */
-	bool psm_requested;
-
-	/* in dBm */
-	int power_level;
-};
-
-int wl12xx_plt_start(struct wl12xx *wl);
-int wl12xx_plt_stop(struct wl12xx *wl);
-
-#define DEFAULT_HW_GEN_MODULATION_TYPE    CCK_LONG /* Long Preamble */
-#define DEFAULT_HW_GEN_TX_RATE          RATE_2MBPS
-#define JOIN_TIMEOUT 5000 /* 5000 milliseconds to join */
-
-#define WL12XX_DEFAULT_POWER_LEVEL 20
-
-#define WL12XX_TX_QUEUE_MAX_LENGTH 20
-
-/* Different chips need different sleep times after power on.  WL1271 needs
- * 200ms, WL1251 needs only 10ms.  By default we use 200ms, but as soon as we
- * know the chip ID, we change the sleep value in the wl12xx chip structure,
- * so in subsequent power ons, we don't waste more time then needed.  */
-#define WL12XX_DEFAULT_POWER_ON_SLEEP 200
-
-#define CHIP_ID_1251_PG10	           (0x7010101)
-#define CHIP_ID_1251_PG11	           (0x7020101)
-#define CHIP_ID_1251_PG12	           (0x7030101)
-#define CHIP_ID_1271_PG10	           (0x4030101)
-
-#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_acx.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_acx.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_acx.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_acx.c	2012-12-16 13:13:01.680330145 +0100
@@ -0,0 +1,1078 @@
+#include "wl1251_acx.h"
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/crc7.h>
+#include <linux/spi/spi.h>
+
+#include "wl1251.h"
+#include "wl1251_reg.h"
+#include "wl1251_spi.h"
+#include "wl1251_ps.h"
+
+int wl1251_acx_frame_rates(struct wl1251 *wl, u8 ctrl_rate, u8 ctrl_mod,
+			   u8 mgt_rate, u8 mgt_mod)
+{
+	struct acx_fw_gen_frame_rates *rates;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx frame rates");
+
+	rates = kzalloc(sizeof(*rates), GFP_KERNEL);
+	if (!rates) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	rates->tx_ctrl_frame_rate = ctrl_rate;
+	rates->tx_ctrl_frame_mod = ctrl_mod;
+	rates->tx_mgt_frame_rate = mgt_rate;
+	rates->tx_mgt_frame_mod = mgt_mod;
+
+	ret = wl1251_cmd_configure(wl, ACX_FW_GEN_FRAME_RATES,
+				   rates, sizeof(*rates));
+	if (ret < 0) {
+		wl1251_error("Failed to set FW rates and modulation");
+		goto out;
+	}
+
+out:
+	kfree(rates);
+	return ret;
+}
+
+
+int wl1251_acx_station_id(struct wl1251 *wl)
+{
+	struct acx_dot11_station_id *mac;
+	int ret, i;
+
+	wl1251_debug(DEBUG_ACX, "acx dot11_station_id");
+
+	mac = kzalloc(sizeof(*mac), GFP_KERNEL);
+	if (!mac) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	for (i = 0; i < ETH_ALEN; i++)
+		mac->mac[i] = wl->mac_addr[ETH_ALEN - 1 - i];
+
+	ret = wl1251_cmd_configure(wl, DOT11_STATION_ID, mac, sizeof(*mac));
+	if (ret < 0)
+		goto out;
+
+out:
+	kfree(mac);
+	return ret;
+}
+
+int wl1251_acx_default_key(struct wl1251 *wl, u8 key_id)
+{
+	struct acx_dot11_default_key *default_key;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx dot11_default_key (%d)", key_id);
+
+	default_key = kzalloc(sizeof(*default_key), GFP_KERNEL);
+	if (!default_key) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	default_key->id = key_id;
+
+	ret = wl1251_cmd_configure(wl, DOT11_DEFAULT_KEY,
+				   default_key, sizeof(*default_key));
+	if (ret < 0) {
+		wl1251_error("Couldnt set default key");
+		goto out;
+	}
+
+	wl->default_key = key_id;
+
+out:
+	kfree(default_key);
+	return ret;
+}
+
+int wl1251_acx_wake_up_conditions(struct wl1251 *wl, u8 wake_up_event,
+				  u8 listen_interval)
+{
+	struct acx_wake_up_condition *wake_up;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx wake up conditions");
+
+	wake_up = kzalloc(sizeof(*wake_up), GFP_KERNEL);
+	if (!wake_up) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	wake_up->wake_up_event = wake_up_event;
+	wake_up->listen_interval = listen_interval;
+
+	ret = wl1251_cmd_configure(wl, ACX_WAKE_UP_CONDITIONS,
+				   wake_up, sizeof(*wake_up));
+	if (ret < 0) {
+		wl1251_warning("could not set wake up conditions: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(wake_up);
+	return ret;
+}
+
+int wl1251_acx_sleep_auth(struct wl1251 *wl, u8 sleep_auth)
+{
+	struct acx_sleep_auth *auth;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx sleep auth");
+
+	auth = kzalloc(sizeof(*auth), GFP_KERNEL);
+	if (!auth) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	auth->sleep_auth = sleep_auth;
+
+	ret = wl1251_cmd_configure(wl, ACX_SLEEP_AUTH, auth, sizeof(*auth));
+	if (ret < 0)
+		return ret;
+
+out:
+	kfree(auth);
+	return ret;
+}
+
+int wl1251_acx_fw_version(struct wl1251 *wl, char *buf, size_t len)
+{
+	struct acx_revision *rev;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx fw rev");
+
+	rev = kzalloc(sizeof(*rev), GFP_KERNEL);
+	if (!rev) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = wl1251_cmd_interrogate(wl, ACX_FW_REV, rev, sizeof(*rev));
+	if (ret < 0) {
+		wl1251_warning("ACX_FW_REV interrogate failed");
+		goto out;
+	}
+
+	/* be careful with the buffer sizes */
+	strncpy(buf, rev->fw_version, min(len, sizeof(rev->fw_version)));
+
+	/*
+	 * if the firmware version string is exactly
+	 * sizeof(rev->fw_version) long or fw_len is less than
+	 * sizeof(rev->fw_version) it won't be null terminated
+	 */
+	buf[min(len, sizeof(rev->fw_version)) - 1] = '\0';
+
+out:
+	kfree(rev);
+	return ret;
+}
+
+int wl1251_acx_tx_power(struct wl1251 *wl, int power)
+{
+	struct acx_current_tx_power *acx;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx dot11_cur_tx_pwr");
+
+	if (power < 0 || power > 25)
+		return -EINVAL;
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx->current_tx_power = power * 10;
+
+	ret = wl1251_cmd_configure(wl, DOT11_CUR_TX_PWR, acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1251_warning("configure of tx power failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1251_acx_feature_cfg(struct wl1251 *wl)
+{
+	struct acx_feature_config *feature;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx feature cfg");
+
+	feature = kzalloc(sizeof(*feature), GFP_KERNEL);
+	if (!feature) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* DF_ENCRYPTION_DISABLE and DF_SNIFF_MODE_ENABLE are disabled */
+	feature->data_flow_options = 0;
+	feature->options = 0;
+
+	ret = wl1251_cmd_configure(wl, ACX_FEATURE_CFG,
+				   feature, sizeof(*feature));
+	if (ret < 0) {
+		wl1251_error("Couldnt set HW encryption");
+		goto out;
+	}
+
+out:
+	kfree(feature);
+	return ret;
+}
+
+int wl1251_acx_mem_map(struct wl1251 *wl, struct acx_header *mem_map,
+		       size_t len)
+{
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx mem map");
+
+	ret = wl1251_cmd_interrogate(wl, ACX_MEM_MAP, mem_map, len);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+int wl1251_acx_data_path_params(struct wl1251 *wl,
+				struct acx_data_path_params_resp *resp)
+{
+	struct acx_data_path_params *params;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx data path params");
+
+	params = kzalloc(sizeof(*params), GFP_KERNEL);
+	if (!params) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	params->rx_packet_ring_chunk_size = DP_RX_PACKET_RING_CHUNK_SIZE;
+	params->tx_packet_ring_chunk_size = DP_TX_PACKET_RING_CHUNK_SIZE;
+
+	params->rx_packet_ring_chunk_num = DP_RX_PACKET_RING_CHUNK_NUM;
+	params->tx_packet_ring_chunk_num = DP_TX_PACKET_RING_CHUNK_NUM;
+
+	params->tx_complete_threshold = 1;
+
+	params->tx_complete_ring_depth = FW_TX_CMPLT_BLOCK_SIZE;
+
+	params->tx_complete_timeout = DP_TX_COMPLETE_TIME_OUT;
+
+	ret = wl1251_cmd_configure(wl, ACX_DATA_PATH_PARAMS,
+				   params, sizeof(*params));
+	if (ret < 0)
+		goto out;
+
+	/* FIXME: shouldn't this be ACX_DATA_PATH_RESP_PARAMS? */
+	ret = wl1251_cmd_interrogate(wl, ACX_DATA_PATH_PARAMS,
+				     resp, sizeof(*resp));
+
+	if (ret < 0) {
+		wl1251_warning("failed to read data path parameters: %d", ret);
+		goto out;
+	} else if (resp->header.cmd.status != CMD_STATUS_SUCCESS) {
+		wl1251_warning("data path parameter acx status failed");
+		ret = -EIO;
+		goto out;
+	}
+
+out:
+	kfree(params);
+	return ret;
+}
+
+int wl1251_acx_rx_msdu_life_time(struct wl1251 *wl, u32 life_time)
+{
+	struct acx_rx_msdu_lifetime *acx;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx rx msdu life time");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx->lifetime = life_time;
+	ret = wl1251_cmd_configure(wl, DOT11_RX_MSDU_LIFE_TIME,
+				   acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1251_warning("failed to set rx msdu life time: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1251_acx_rx_config(struct wl1251 *wl, u32 config, u32 filter)
+{
+	struct acx_rx_config *rx_config;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx rx config");
+
+	rx_config = kzalloc(sizeof(*rx_config), GFP_KERNEL);
+	if (!rx_config) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	rx_config->config_options = config;
+	rx_config->filter_options = filter;
+
+	ret = wl1251_cmd_configure(wl, ACX_RX_CFG,
+				   rx_config, sizeof(*rx_config));
+	if (ret < 0) {
+		wl1251_warning("failed to set rx config: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(rx_config);
+	return ret;
+}
+
+int wl1251_acx_pd_threshold(struct wl1251 *wl)
+{
+	struct acx_packet_detection *pd;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx data pd threshold");
+
+	pd = kzalloc(sizeof(*pd), GFP_KERNEL);
+	if (!pd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* FIXME: threshold value not set */
+
+	ret = wl1251_cmd_configure(wl, ACX_PD_THRESHOLD, pd, sizeof(*pd));
+	if (ret < 0) {
+		wl1251_warning("failed to set pd threshold: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(pd);
+	return 0;
+}
+
+int wl1251_acx_slot(struct wl1251 *wl, enum acx_slot_type slot_time)
+{
+	struct acx_slot *slot;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx slot");
+
+	slot = kzalloc(sizeof(*slot), GFP_KERNEL);
+	if (!slot) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	slot->wone_index = STATION_WONE_INDEX;
+	slot->slot_time = slot_time;
+
+	ret = wl1251_cmd_configure(wl, ACX_SLOT, slot, sizeof(*slot));
+	if (ret < 0) {
+		wl1251_warning("failed to set slot time: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(slot);
+	return ret;
+}
+
+int wl1251_acx_group_address_tbl(struct wl1251 *wl, void *mc_list,
+				 u32 mc_list_len, bool enable)
+{
+	struct acx_dot11_grp_addr_tbl *acx;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx group address tbl");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* MAC filtering */
+	acx->enabled = enable;
+	acx->num_groups = mc_list_len;
+	memcpy(acx->mac_table, mc_list, mc_list_len * ETH_ALEN);
+
+	ret = wl1251_cmd_configure(wl, DOT11_GROUP_ADDRESS_TBL,
+				   acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1251_warning("failed to set group addr table: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1251_acx_service_period_timeout(struct wl1251 *wl)
+{
+	struct acx_rx_timeout *rx_timeout;
+	int ret;
+
+	rx_timeout = kzalloc(sizeof(*rx_timeout), GFP_KERNEL);
+	if (!rx_timeout) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	wl1251_debug(DEBUG_ACX, "acx service period timeout");
+
+	rx_timeout->ps_poll_timeout = RX_TIMEOUT_PS_POLL_DEF;
+	rx_timeout->upsd_timeout = RX_TIMEOUT_UPSD_DEF;
+
+	ret = wl1251_cmd_configure(wl, ACX_SERVICE_PERIOD_TIMEOUT,
+				   rx_timeout, sizeof(*rx_timeout));
+	if (ret < 0) {
+		wl1251_warning("failed to set service period timeout: %d",
+			       ret);
+		goto out;
+	}
+
+out:
+	kfree(rx_timeout);
+	return ret;
+}
+
+int wl1251_acx_rts_threshold(struct wl1251 *wl, u16 rts_threshold)
+{
+	struct acx_rts_threshold *rts;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx rts threshold");
+
+	rts = kzalloc(sizeof(*rts), GFP_KERNEL);
+	if (!rts) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	rts->threshold = rts_threshold;
+
+	ret = wl1251_cmd_configure(wl, DOT11_RTS_THRESHOLD, rts, sizeof(*rts));
+	if (ret < 0) {
+		wl1251_warning("failed to set rts threshold: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(rts);
+	return ret;
+}
+
+int wl1251_acx_beacon_filter_opt(struct wl1251 *wl, bool enable_filter)
+{
+	struct acx_beacon_filter_option *beacon_filter;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx beacon filter opt");
+
+	beacon_filter = kzalloc(sizeof(*beacon_filter), GFP_KERNEL);
+	if (!beacon_filter) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	beacon_filter->enable = enable_filter;
+	beacon_filter->max_num_beacons = 0;
+
+	ret = wl1251_cmd_configure(wl, ACX_BEACON_FILTER_OPT,
+				   beacon_filter, sizeof(*beacon_filter));
+	if (ret < 0) {
+		wl1251_warning("failed to set beacon filter opt: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(beacon_filter);
+	return ret;
+}
+
+int wl1251_acx_beacon_filter_table(struct wl1251 *wl)
+{
+	struct acx_beacon_filter_ie_table *ie_table;
+	int idx = 0;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx beacon filter table");
+
+	ie_table = kzalloc(sizeof(*ie_table), GFP_KERNEL);
+	if (!ie_table) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* configure default beacon pass-through rules */
+	ie_table->num_ie = 1;
+	ie_table->table[idx++] = BEACON_FILTER_IE_ID_CHANNEL_SWITCH_ANN;
+	ie_table->table[idx++] = BEACON_RULE_PASS_ON_APPEARANCE;
+
+	ret = wl1251_cmd_configure(wl, ACX_BEACON_FILTER_TABLE,
+				   ie_table, sizeof(*ie_table));
+	if (ret < 0) {
+		wl1251_warning("failed to set beacon filter table: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(ie_table);
+	return ret;
+}
+
+int wl1251_acx_conn_monit_params(struct wl1251 *wl)
+{
+	struct acx_conn_monit_params *acx;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx connection monitor parameters");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx->synch_fail_thold = SYNCH_FAIL_DEFAULT_THRESHOLD;
+	acx->bss_lose_timeout = NO_BEACON_DEFAULT_TIMEOUT;
+
+	ret = wl1251_cmd_configure(wl, ACX_CONN_MONIT_PARAMS,
+				   acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1251_warning("failed to set connection monitor "
+			       "parameters: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1251_acx_sg_enable(struct wl1251 *wl, u8 mode)
+{
+	struct acx_bt_wlan_coex *pta;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx sg enable");
+
+	pta = kzalloc(sizeof(*pta), GFP_KERNEL);
+	if (!pta) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	pta->enable = mode;
+
+	ret = wl1251_cmd_configure(wl, ACX_SG_ENABLE, pta, sizeof(*pta));
+	if (ret < 0) {
+		wl1251_warning("failed to set softgemini enable: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(pta);
+	return ret;
+}
+
+int wl1251_acx_sg_cfg(struct wl1251 *wl, u16 wake_up_beacon)
+{
+	struct acx_bt_wlan_coex_param *param;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx sg cfg");
+
+	param = kzalloc(sizeof(*param), GFP_KERNEL);
+	if (!param) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* BT-WLAN coext parameters */
+	param->min_rate = RATE_INDEX_24MBPS;
+	param->bt_hp_max_time = PTA_BT_HP_MAXTIME_DEF;
+	param->wlan_hp_max_time = PTA_WLAN_HP_MAX_TIME_DEF;
+	param->sense_disable_timer = PTA_SENSE_DISABLE_TIMER_DEF;
+	param->rx_time_bt_hp = PTA_PROTECTIVE_RX_TIME_DEF;
+	param->tx_time_bt_hp = PTA_PROTECTIVE_TX_TIME_DEF;
+	param->rx_time_bt_hp_fast = PTA_PROTECTIVE_RX_TIME_FAST_DEF;
+	param->tx_time_bt_hp_fast = PTA_PROTECTIVE_TX_TIME_FAST_DEF;
+	param->wlan_cycle_fast = PTA_CYCLE_TIME_FAST_DEF;
+	param->bt_anti_starvation_period = PTA_ANTI_STARVE_PERIOD_DEF;
+	param->next_bt_lp_packet = PTA_TIMEOUT_NEXT_BT_LP_PACKET_DEF;
+	param->wake_up_beacon = wake_up_beacon;
+	param->hp_dm_max_guard_time = PTA_HPDM_MAX_TIME_DEF;
+	param->next_wlan_packet = PTA_TIME_OUT_NEXT_WLAN_DEF;
+	param->antenna_type = PTA_ANTENNA_TYPE_DEF;
+	param->signal_type = PTA_SIGNALING_TYPE_DEF;
+	param->afh_leverage_on = PTA_AFH_LEVERAGE_ON_DEF;
+	param->quiet_cycle_num = PTA_NUMBER_QUIET_CYCLE_DEF;
+	param->max_cts = PTA_MAX_NUM_CTS_DEF;
+	param->wlan_packets_num = PTA_NUMBER_OF_WLAN_PACKETS_DEF;
+	param->bt_packets_num = PTA_NUMBER_OF_BT_PACKETS_DEF;
+	param->missed_rx_avalanche = PTA_RX_FOR_AVALANCHE_DEF;
+	param->wlan_elp_hp = PTA_ELP_HP_DEF;
+	param->bt_anti_starvation_cycles = PTA_ANTI_STARVE_NUM_CYCLE_DEF;
+	param->ack_mode_dual_ant = PTA_ACK_MODE_DEF;
+	param->pa_sd_enable = PTA_ALLOW_PA_SD_DEF;
+	param->pta_auto_mode_enable = PTA_AUTO_MODE_NO_CTS_DEF;
+	param->bt_hp_respected_num = PTA_BT_HP_RESPECTED_DEF;
+
+	ret = wl1251_cmd_configure(wl, ACX_SG_CFG, param, sizeof(*param));
+	if (ret < 0) {
+		wl1251_warning("failed to set sg config: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(param);
+	return ret;
+}
+
+int wl1251_acx_sg_configure(struct wl1251 *wl, bool force)
+{
+	int ret;
+
+	if (wl->state == WL1251_STATE_OFF && !force)
+		return 0;
+
+	switch (wl->bt_coex_mode) {
+	case WL1251_BT_COEX_OFF:
+		ret = wl1251_acx_sg_enable(wl, SG_DISABLE);
+		if (ret)
+			break;
+		ret = wl1251_acx_sg_cfg(wl, PTA_TIME_BEFORE_BEACON_DEF);
+		break;
+	case WL1251_BT_COEX_ENABLE:
+		ret = wl1251_acx_sg_enable(wl, SG_ENABLE);
+		if (ret)
+			break;
+		ret = wl1251_acx_sg_cfg(wl, PTA_TIME_BEFORE_BEACON_DEF);
+		break;
+	case WL1251_BT_COEX_MONOAUDIO:
+		ret = wl1251_acx_sg_enable(wl, SG_ENABLE);
+		if (ret)
+			break;
+		ret = wl1251_acx_sg_cfg(wl, PTA_TIME_BEFORE_BEACON_MONO_AUDIO);
+		break;
+	default:
+		wl1251_error("Invalid BT co-ex mode!");
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	return ret;
+}
+
+int wl1251_acx_cca_threshold(struct wl1251 *wl)
+{
+	struct acx_energy_detection *detection;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx cca threshold");
+
+	detection = kzalloc(sizeof(*detection), GFP_KERNEL);
+	if (!detection) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	detection->rx_cca_threshold = CCA_THRSH_DISABLE_ENERGY_D;
+	detection->tx_energy_detection = 0;
+
+	ret = wl1251_cmd_configure(wl, ACX_CCA_THRESHOLD,
+				   detection, sizeof(*detection));
+	if (ret < 0) {
+		wl1251_warning("failed to set cca threshold: %d", ret);
+		return ret;
+	}
+
+out:
+	kfree(detection);
+	return ret;
+}
+
+int wl1251_acx_bcn_dtim_options(struct wl1251 *wl)
+{
+	struct acx_beacon_broadcast *bb;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx bcn dtim options");
+
+	bb = kzalloc(sizeof(*bb), GFP_KERNEL);
+	if (!bb) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	bb->beacon_rx_timeout = BCN_RX_TIMEOUT_DEF_VALUE;
+	bb->broadcast_timeout = BROADCAST_RX_TIMEOUT_DEF_VALUE;
+	bb->rx_broadcast_in_ps = RX_BROADCAST_IN_PS_DEF_VALUE;
+	bb->ps_poll_threshold = CONSECUTIVE_PS_POLL_FAILURE_DEF;
+
+	ret = wl1251_cmd_configure(wl, ACX_BCN_DTIM_OPTIONS, bb, sizeof(*bb));
+	if (ret < 0) {
+		wl1251_warning("failed to set rx config: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(bb);
+	return ret;
+}
+
+int wl1251_acx_aid(struct wl1251 *wl, u16 aid)
+{
+	struct acx_aid *acx_aid;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx aid");
+
+	acx_aid = kzalloc(sizeof(*acx_aid), GFP_KERNEL);
+	if (!acx_aid) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx_aid->aid = aid;
+
+	ret = wl1251_cmd_configure(wl, ACX_AID, acx_aid, sizeof(*acx_aid));
+	if (ret < 0) {
+		wl1251_warning("failed to set aid: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx_aid);
+	return ret;
+}
+
+int wl1251_acx_event_mbox_mask(struct wl1251 *wl, u32 event_mask)
+{
+	struct acx_event_mask *mask;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx event mbox mask");
+
+	mask = kzalloc(sizeof(*mask), GFP_KERNEL);
+	if (!mask) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* high event mask is unused */
+	mask->high_event_mask = 0xffffffff;
+
+	mask->event_mask = event_mask;
+
+	ret = wl1251_cmd_configure(wl, ACX_EVENT_MBOX_MASK,
+				   mask, sizeof(*mask));
+	if (ret < 0) {
+		wl1251_warning("failed to set acx_event_mbox_mask: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(mask);
+	return ret;
+}
+
+int wl1251_acx_low_rssi(struct wl1251 *wl, s8 threshold, u8 weight,
+			u8 depth, enum wl12xx_acx_low_rssi_type type)
+{
+	struct acx_low_rssi *rssi;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx low rssi");
+
+	rssi = kzalloc(sizeof(*rssi), GFP_KERNEL);
+	if (!rssi)
+		return -ENOMEM;
+
+	rssi->threshold = threshold;
+	rssi->weight = weight;
+	rssi->depth = depth;
+	rssi->type = type;
+
+	ret = wl1251_cmd_configure(wl, ACX_LOW_RSSI, rssi, sizeof(*rssi));
+	if (ret < 0)
+		wl1251_warning("failed to set low rssi threshold: %d", ret);
+
+	kfree(rssi);
+	return ret;
+}
+
+int wl1251_acx_set_preamble(struct wl1251 *wl, enum acx_preamble_type preamble)
+{
+	struct acx_preamble *acx;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx_set_preamble");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx->preamble = preamble;
+
+	ret = wl1251_cmd_configure(wl, ACX_PREAMBLE_TYPE, acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1251_warning("Setting of preamble failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1251_acx_cts_protect(struct wl1251 *wl,
+			   enum acx_ctsprotect_type ctsprotect)
+{
+	struct acx_ctsprotect *acx;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx_set_ctsprotect");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx->ctsprotect = ctsprotect;
+
+	ret = wl1251_cmd_configure(wl, ACX_CTS_PROTECTION, acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1251_warning("Setting of ctsprotect failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1251_acx_tsf_info(struct wl1251 *wl, u64 *mactime)
+{
+	struct acx_tsf_info *tsf_info;
+	int ret;
+
+	tsf_info = kzalloc(sizeof(*tsf_info), GFP_KERNEL);
+	if (!tsf_info) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = wl1251_cmd_interrogate(wl, ACX_TSF_INFO,
+				     tsf_info, sizeof(*tsf_info));
+	if (ret < 0) {
+		wl1251_warning("ACX_FW_REV interrogate failed");
+		goto out;
+	}
+
+	*mactime = tsf_info->current_tsf_lsb |
+		(tsf_info->current_tsf_msb << 31);
+
+out:
+	kfree(tsf_info);
+	return ret;
+}
+
+int wl1251_acx_statistics(struct wl1251 *wl, struct acx_statistics *stats)
+{
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx statistics");
+
+	ret = wl1251_cmd_interrogate(wl, ACX_STATISTICS, stats,
+				     sizeof(*stats));
+	if (ret < 0) {
+		wl1251_warning("acx statistics failed: %d", ret);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+int wl1251_acx_rate_policies(struct wl1251 *wl)
+{
+	struct acx_rate_policy *acx;
+	int ret = 0;
+
+	wl1251_debug(DEBUG_ACX, "acx rate policies");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* configure one default (one-size-fits-all) rate class */
+	acx->rate_class_cnt = 1;
+	acx->rate_class[0].enabled_rates = ACX_RATE_MASK_UNSPECIFIED;
+	acx->rate_class[0].short_retry_limit = ACX_RATE_RETRY_LIMIT;
+	acx->rate_class[0].long_retry_limit = ACX_RATE_RETRY_LIMIT;
+	acx->rate_class[0].aflags = 0;
+
+	ret = wl1251_cmd_configure(wl, ACX_RATE_POLICY, acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1251_warning("Setting of rate policies failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1251_acx_mem_cfg(struct wl1251 *wl)
+{
+	struct wl1251_acx_config_memory *mem_conf;
+	int ret, i;
+
+	wl1251_debug(DEBUG_ACX, "acx mem cfg");
+
+	mem_conf = kzalloc(sizeof(*mem_conf), GFP_KERNEL);
+	if (!mem_conf) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* memory config */
+	mem_conf->mem_config.num_stations = cpu_to_le16(DEFAULT_NUM_STATIONS);
+	mem_conf->mem_config.rx_mem_block_num = 35;
+	mem_conf->mem_config.tx_min_mem_block_num = 64;
+	mem_conf->mem_config.num_tx_queues = MAX_TX_QUEUES;
+	mem_conf->mem_config.host_if_options = HOSTIF_PKT_RING;
+	mem_conf->mem_config.num_ssid_profiles = 1;
+	mem_conf->mem_config.debug_buffer_size =
+		cpu_to_le16(TRACE_BUFFER_MAX_SIZE);
+
+	/* RX queue config */
+	mem_conf->rx_queue_config.dma_address = 0;
+	mem_conf->rx_queue_config.num_descs = ACX_RX_DESC_DEF;
+	mem_conf->rx_queue_config.priority = DEFAULT_RXQ_PRIORITY;
+	mem_conf->rx_queue_config.type = DEFAULT_RXQ_TYPE;
+
+	/* TX queue config */
+	for (i = 0; i < MAX_TX_QUEUES; i++) {
+		mem_conf->tx_queue_config[i].num_descs = ACX_TX_DESC_DEF;
+		mem_conf->tx_queue_config[i].attributes = i;
+	}
+
+	ret = wl1251_cmd_configure(wl, ACX_MEM_CFG, mem_conf,
+				   sizeof(*mem_conf));
+	if (ret < 0) {
+		wl1251_warning("wl1251 mem config failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(mem_conf);
+	return ret;
+}
+
+int wl1251_acx_wr_tbtt_and_dtim(struct wl1251 *wl, u16 tbtt, u8 dtim)
+{
+	struct wl1251_acx_wr_tbtt_and_dtim *acx;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx tbtt and dtim");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx->tbtt = tbtt;
+	acx->dtim = dtim;
+
+	ret = wl1251_cmd_configure(wl, ACX_WR_TBTT_AND_DTIM,
+				   acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1251_warning("failed to set tbtt and dtim: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1251_acx_ip_config(struct wl1251 *wl, bool enable, u8 *address,
+			 u8 version)
+{
+	struct wl1251_acx_arp_filter *acx;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx arp ip filter, enable: %d", enable);
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx->version = version;
+	acx->enable = enable;
+
+	if (enable == true) {
+		if (version == IPV4_VERSION)
+			memcpy(acx->address, address, IPV4_ADDR_SIZE);
+		else if (version == IPV6_VERSION)
+			memcpy(acx->address, address, sizeof(acx->address));
+		else
+			wl1251_error("Invalid IP version");
+	}
+	ret = wl1251_cmd_configure(wl, ACX_ARP_IP_FILTER,
+				   acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1251_warning("failed to set arp filter: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_acx.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_acx.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_acx.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_acx.h	2012-12-16 13:13:01.680330145 +0100
@@ -0,0 +1,1387 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __WL1251_ACX_H__
+#define __WL1251_ACX_H__
+
+#include "wl1251.h"
+#include "wl1251_cmd.h"
+
+/* Target's information element */
+struct acx_header {
+	struct wl1251_cmd_header cmd;
+
+	/* acx (or information element) header */
+	u16 id;
+
+	/* payload length (not including headers */
+	u16 len;
+};
+
+struct acx_error_counter {
+	struct acx_header header;
+
+	/* The number of PLCP errors since the last time this */
+	/* information element was interrogated. This field is */
+	/* automatically cleared when it is interrogated.*/
+	u32 PLCP_error;
+
+	/* The number of FCS errors since the last time this */
+	/* information element was interrogated. This field is */
+	/* automatically cleared when it is interrogated.*/
+	u32 FCS_error;
+
+	/* The number of MPDUs without PLCP header errors received*/
+	/* since the last time this information element was interrogated. */
+	/* This field is automatically cleared when it is interrogated.*/
+	u32 valid_frame;
+
+	/* the number of missed sequence numbers in the squentially */
+	/* values of frames seq numbers */
+	u32 seq_num_miss;
+} __attribute__ ((packed));
+
+struct acx_revision {
+	struct acx_header header;
+
+	/*
+	 * The WiLink firmware version, an ASCII string x.x.x.x,
+	 * that uniquely identifies the current firmware.
+	 * The left most digit is incremented each time a
+	 * significant change is made to the firmware, such as
+	 * code redesign or new platform support.
+	 * The second digit is incremented when major enhancements
+	 * are added or major fixes are made.
+	 * The third digit is incremented for each GA release.
+	 * The fourth digit is incremented for each build.
+	 * The first two digits identify a firmware release version,
+	 * in other words, a unique set of features.
+	 * The first three digits identify a GA release.
+	 */
+	char fw_version[20];
+
+	/*
+	 * This 4 byte field specifies the WiLink hardware version.
+	 * bits 0  - 15: Reserved.
+	 * bits 16 - 23: Version ID - The WiLink version ID
+	 *              (1 = first spin, 2 = second spin, and so on).
+	 * bits 24 - 31: Chip ID - The WiLink chip ID.
+	 */
+	u32 hw_version;
+} __attribute__ ((packed));
+
+enum wl1251_psm_mode {
+	/* Active mode */
+	WL1251_PSM_CAM = 0,
+
+	/* Power save mode */
+	WL1251_PSM_PS = 1,
+
+	/* Extreme low power */
+	WL1251_PSM_ELP = 2,
+};
+
+struct acx_sleep_auth {
+	struct acx_header header;
+
+	/* The sleep level authorization of the device. */
+	/* 0 - Always active*/
+	/* 1 - Power down mode: light / fast sleep*/
+	/* 2 - ELP mode: Deep / Max sleep*/
+	u8  sleep_auth;
+	u8  padding[3];
+} __attribute__ ((packed));
+
+enum {
+	HOSTIF_PCI_MASTER_HOST_INDIRECT,
+	HOSTIF_PCI_MASTER_HOST_DIRECT,
+	HOSTIF_SLAVE,
+	HOSTIF_PKT_RING,
+	HOSTIF_DONTCARE = 0xFF
+};
+
+#define DEFAULT_UCAST_PRIORITY          0
+#define DEFAULT_RX_Q_PRIORITY           0
+#define DEFAULT_NUM_STATIONS            1
+#define DEFAULT_RXQ_PRIORITY            0 /* low 0 .. 15 high  */
+#define DEFAULT_RXQ_TYPE                0x07    /* All frames, Data/Ctrl/Mgmt */
+#define TRACE_BUFFER_MAX_SIZE           256
+
+#define  DP_RX_PACKET_RING_CHUNK_SIZE 1600
+#define  DP_TX_PACKET_RING_CHUNK_SIZE 1600
+#define  DP_RX_PACKET_RING_CHUNK_NUM 2
+#define  DP_TX_PACKET_RING_CHUNK_NUM 2
+#define  DP_TX_COMPLETE_TIME_OUT 20
+#define  FW_TX_CMPLT_BLOCK_SIZE 16
+
+struct acx_data_path_params {
+	struct acx_header header;
+
+	u16 rx_packet_ring_chunk_size;
+	u16 tx_packet_ring_chunk_size;
+
+	u8 rx_packet_ring_chunk_num;
+	u8 tx_packet_ring_chunk_num;
+
+	/*
+	 * Maximum number of packets that can be gathered
+	 * in the TX complete ring before an interrupt
+	 * is generated.
+	 */
+	u8 tx_complete_threshold;
+
+	/* Number of pending TX complete entries in cyclic ring.*/
+	u8 tx_complete_ring_depth;
+
+	/*
+	 * Max num microseconds since a packet enters the TX
+	 * complete ring until an interrupt is generated.
+	 */
+	u32 tx_complete_timeout;
+} __attribute__ ((packed));
+
+
+struct acx_data_path_params_resp {
+	struct acx_header header;
+
+	u16 rx_packet_ring_chunk_size;
+	u16 tx_packet_ring_chunk_size;
+
+	u8 rx_packet_ring_chunk_num;
+	u8 tx_packet_ring_chunk_num;
+
+	u8 pad[2];
+
+	u32 rx_packet_ring_addr;
+	u32 tx_packet_ring_addr;
+
+	u32 rx_control_addr;
+	u32 tx_control_addr;
+
+	u32 tx_complete_addr;
+} __attribute__ ((packed));
+
+#define TX_MSDU_LIFETIME_MIN       0
+#define TX_MSDU_LIFETIME_MAX       3000
+#define TX_MSDU_LIFETIME_DEF       512
+#define RX_MSDU_LIFETIME_MIN       0
+#define RX_MSDU_LIFETIME_MAX       0xFFFFFFFF
+#define RX_MSDU_LIFETIME_DEF       512000
+
+struct acx_rx_msdu_lifetime {
+	struct acx_header header;
+
+	/*
+	 * The maximum amount of time, in TU, before the
+	 * firmware discards the MSDU.
+	 */
+	u32 lifetime;
+} __attribute__ ((packed));
+
+/*
+ * RX Config Options Table
+ * Bit		Definition
+ * ===		==========
+ * 31:14		Reserved
+ * 13		Copy RX Status - when set, write three receive status words
+ * 	 	to top of rx'd MPDUs.
+ * 		When cleared, do not write three status words (added rev 1.5)
+ * 12		Reserved
+ * 11		RX Complete upon FCS error - when set, give rx complete
+ *	 	interrupt for FCS errors, after the rx filtering, e.g. unicast
+ *	 	frames not to us with FCS error will not generate an interrupt.
+ * 10		SSID Filter Enable - When set, the WiLink discards all beacon,
+ *	        probe request, and probe response frames with an SSID that does
+ *		not match the SSID specified by the host in the START/JOIN
+ *		command.
+ *		When clear, the WiLink receives frames with any SSID.
+ * 9		Broadcast Filter Enable - When set, the WiLink discards all
+ * 	 	broadcast frames. When clear, the WiLink receives all received
+ *		broadcast frames.
+ * 8:6		Reserved
+ * 5		BSSID Filter Enable - When set, the WiLink discards any frames
+ * 	 	with a BSSID that does not match the BSSID specified by the
+ *		host.
+ *		When clear, the WiLink receives frames from any BSSID.
+ * 4		MAC Addr Filter - When set, the WiLink discards any frames
+ * 	 	with a destination address that does not match the MAC address
+ *		of the adaptor.
+ *		When clear, the WiLink receives frames destined to any MAC
+ *		address.
+ * 3		Promiscuous - When set, the WiLink receives all valid frames
+ * 	 	(i.e., all frames that pass the FCS check).
+ *		When clear, only frames that pass the other filters specified
+ *		are received.
+ * 2		FCS - When set, the WiLink includes the FCS with the received
+ *	 	frame.
+ *		When cleared, the FCS is discarded.
+ * 1		PLCP header - When set, write all data from baseband to frame
+ * 	 	buffer including PHY header.
+ * 0		Reserved - Always equal to 0.
+ *
+ * RX Filter Options Table
+ * Bit		Definition
+ * ===		==========
+ * 31:12		Reserved - Always equal to 0.
+ * 11		Association - When set, the WiLink receives all association
+ * 	 	related frames (association request/response, reassocation
+ *		request/response, and disassociation). When clear, these frames
+ *		are discarded.
+ * 10		Auth/De auth - When set, the WiLink receives all authentication
+ * 	 	and de-authentication frames. When clear, these frames are
+ *		discarded.
+ * 9		Beacon - When set, the WiLink receives all beacon frames.
+ * 	 	When clear, these frames are discarded.
+ * 8		Contention Free - When set, the WiLink receives all contention
+ * 	 	free frames.
+ *		When clear, these frames are discarded.
+ * 7		Control - When set, the WiLink receives all control frames.
+ * 	 	When clear, these frames are discarded.
+ * 6		Data - When set, the WiLink receives all data frames.
+ * 	 	When clear, these frames are discarded.
+ * 5		FCS Error - When set, the WiLink receives frames that have FCS
+ *	 	errors.
+ *		When clear, these frames are discarded.
+ * 4		Management - When set, the WiLink receives all management
+ *		frames.
+ * 	 	When clear, these frames are discarded.
+ * 3		Probe Request - When set, the WiLink receives all probe request
+ * 	 	frames.
+ *		When clear, these frames are discarded.
+ * 2		Probe Response - When set, the WiLink receives all probe
+ * 		response frames.
+ *		When clear, these frames are discarded.
+ * 1		RTS/CTS/ACK - When set, the WiLink receives all RTS, CTS and ACK
+ * 	 	frames.
+ *		When clear, these frames are discarded.
+ * 0		Rsvd Type/Sub Type - When set, the WiLink receives all frames
+ * 	 	that have reserved frame types and sub types as defined by the
+ *		802.11 specification.
+ *		When clear, these frames are discarded.
+ */
+struct acx_rx_config {
+	struct acx_header header;
+
+	u32 config_options;
+	u32 filter_options;
+} __attribute__ ((packed));
+
+enum {
+	QOS_AC_BE = 0,
+	QOS_AC_BK,
+	QOS_AC_VI,
+	QOS_AC_VO,
+	QOS_HIGHEST_AC_INDEX = QOS_AC_VO,
+};
+
+#define MAX_NUM_OF_AC             (QOS_HIGHEST_AC_INDEX+1)
+#define FIRST_AC_INDEX            QOS_AC_BE
+#define MAX_NUM_OF_802_1d_TAGS    8
+#define AC_PARAMS_MAX_TSID        15
+#define MAX_APSD_CONF             0xffff
+
+#define  QOS_TX_HIGH_MIN      (0)
+#define  QOS_TX_HIGH_MAX      (100)
+
+#define  QOS_TX_HIGH_BK_DEF   (25)
+#define  QOS_TX_HIGH_BE_DEF   (35)
+#define  QOS_TX_HIGH_VI_DEF   (35)
+#define  QOS_TX_HIGH_VO_DEF   (35)
+
+#define  QOS_TX_LOW_BK_DEF    (15)
+#define  QOS_TX_LOW_BE_DEF    (25)
+#define  QOS_TX_LOW_VI_DEF    (25)
+#define  QOS_TX_LOW_VO_DEF    (25)
+
+struct acx_tx_queue_qos_config {
+	struct acx_header header;
+
+	u8 qid;
+	u8 pad[3];
+
+	/* Max number of blocks allowd in the queue */
+	u16 high_threshold;
+
+	/* Lowest memory blocks guaranteed for this queue */
+	u16 low_threshold;
+} __attribute__ ((packed));
+
+struct acx_packet_detection {
+	struct acx_header header;
+
+	u32 threshold;
+} __attribute__ ((packed));
+
+
+enum acx_slot_type {
+	SLOT_TIME_LONG = 0,
+	SLOT_TIME_SHORT = 1,
+	DEFAULT_SLOT_TIME = SLOT_TIME_SHORT,
+	MAX_SLOT_TIMES = 0xFF
+};
+
+#define STATION_WONE_INDEX 0
+
+struct acx_slot {
+	struct acx_header header;
+
+	u8 wone_index; /* Reserved */
+	u8 slot_time;
+	u8 reserved[6];
+} __attribute__ ((packed));
+
+
+#define ACX_MC_ADDRESS_GROUP_MAX	(8)
+#define ADDRESS_GROUP_MAX_LEN	        (ETH_ALEN * ACX_MC_ADDRESS_GROUP_MAX)
+
+struct acx_dot11_grp_addr_tbl {
+	struct acx_header header;
+
+	u8 enabled;
+	u8 num_groups;
+	u8 pad[2];
+	u8 mac_table[ADDRESS_GROUP_MAX_LEN];
+} __attribute__ ((packed));
+
+
+#define  RX_TIMEOUT_PS_POLL_MIN    0
+#define  RX_TIMEOUT_PS_POLL_MAX    (200000)
+#define  RX_TIMEOUT_PS_POLL_DEF    (15)
+#define  RX_TIMEOUT_UPSD_MIN       0
+#define  RX_TIMEOUT_UPSD_MAX       (200000)
+#define  RX_TIMEOUT_UPSD_DEF       (15)
+
+struct acx_rx_timeout {
+	struct acx_header header;
+
+	/*
+	 * The longest time the STA will wait to receive
+	 * traffic from the AP after a PS-poll has been
+	 * transmitted.
+	 */
+	u16 ps_poll_timeout;
+
+	/*
+	 * The longest time the STA will wait to receive
+	 * traffic from the AP after a frame has been sent
+	 * from an UPSD enabled queue.
+	 */
+	u16 upsd_timeout;
+} __attribute__ ((packed));
+
+#define RTS_THRESHOLD_MIN              0
+#define RTS_THRESHOLD_MAX              4096
+#define RTS_THRESHOLD_DEF              2347
+
+struct acx_rts_threshold {
+	struct acx_header header;
+
+	u16 threshold;
+	u8 pad[2];
+} __attribute__ ((packed));
+
+enum wl12xx_acx_low_rssi_type {
+	/* The event is a "Level" indication which keeps */
+	/* triggering as long as the average RSSI is below*/
+	/* the threshold.*/
+	WL12XX_ACX_LOW_RSSI_TYPE_LEVEL = 0,
+
+	/* The event is an "Edge" indication which triggers*/
+	/* only when the RSSI threshold is crossed from above.*/
+	WL12XX_ACX_LOW_RSSI_TYPE_EDGE = 1,
+};
+
+
+struct acx_low_rssi {
+	struct acx_header header;
+
+	/*
+	 * The threshold (in dBm) below (or above after low rssi
+	 * indication) which the firmware generates an interrupt to the
+	 * host. This parameter is signed.
+	 */
+	s8 threshold;
+
+	/*
+	 * The weight of the current RSSI sample, before adding the new
+	 * sample, that is used to calculate the average RSSI.
+	 */
+	u8 weight;
+
+	/*
+	 * The number of Beacons/Probe response frames that will be
+	 * received before issuing the Low or Regained RSSI event.
+	 */
+	u8 depth;
+
+	/*
+	 * Configures how the Low RSSI Event is triggered. Refer to
+	 * enum wl12xx_acx_low_rssi_type for more.
+	 */
+	u8 type;
+};
+
+struct acx_beacon_filter_option {
+	struct acx_header header;
+
+	u8 enable;
+
+	/*
+	 * The number of beacons without the unicast TIM
+	 * bit set that the firmware buffers before
+	 * signaling the host about ready frames.
+	 * When set to 0 and the filter is enabled, beacons
+	 * without the unicast TIM bit set are dropped.
+	 */
+	u8 max_num_beacons;
+	u8 pad[2];
+} __attribute__ ((packed));
+
+/*
+ * ACXBeaconFilterEntry (not 221)
+ * Byte Offset     Size (Bytes)    Definition
+ * ===========     ============    ==========
+ * 0				1               IE identifier
+ * 1               1               Treatment bit mask
+ *
+ * ACXBeaconFilterEntry (221)
+ * Byte Offset     Size (Bytes)    Definition
+ * ===========     ============    ==========
+ * 0               1               IE identifier
+ * 1               1               Treatment bit mask
+ * 2               3               OUI
+ * 5               1               Type
+ * 6               2               Version
+ *
+ *
+ * Treatment bit mask - The information element handling:
+ * bit 0 - The information element is compared and transferred
+ * in case of change.
+ * bit 1 - The information element is transferred to the host
+ * with each appearance or disappearance.
+ * Note that both bits can be set at the same time.
+ */
+#define	BEACON_FILTER_TABLE_MAX_IE_NUM		       (32)
+#define BEACON_FILTER_TABLE_MAX_VENDOR_SPECIFIC_IE_NUM (6)
+#define BEACON_FILTER_TABLE_IE_ENTRY_SIZE	       (2)
+#define BEACON_FILTER_TABLE_EXTRA_VENDOR_SPECIFIC_IE_SIZE (6)
+#define BEACON_FILTER_TABLE_MAX_SIZE ((BEACON_FILTER_TABLE_MAX_IE_NUM * \
+			    BEACON_FILTER_TABLE_IE_ENTRY_SIZE) + \
+			   (BEACON_FILTER_TABLE_MAX_VENDOR_SPECIFIC_IE_NUM * \
+			    BEACON_FILTER_TABLE_EXTRA_VENDOR_SPECIFIC_IE_SIZE))
+
+#define BEACON_RULE_PASS_ON_CHANGE                     BIT(0)
+#define BEACON_RULE_PASS_ON_APPEARANCE                 BIT(1)
+
+#define BEACON_FILTER_IE_ID_CHANNEL_SWITCH_ANN         (37)
+
+struct acx_beacon_filter_ie_table {
+	struct acx_header header;
+
+	u8 num_ie;
+	u8 table[BEACON_FILTER_TABLE_MAX_SIZE];
+	u8 pad[3];
+} __attribute__ ((packed));
+
+#define SYNCH_FAIL_DEFAULT_THRESHOLD    10     /* number of beacons */
+#define NO_BEACON_DEFAULT_TIMEOUT       (500) /* in microseconds */
+
+struct acx_conn_monit_params {
+	struct acx_header header;
+
+	u32 synch_fail_thold; /* number of beacons missed */
+	u32 bss_lose_timeout; /* number of TU's from synch fail */
+};
+
+enum {
+	SG_ENABLE = 0,
+	SG_DISABLE,
+	SG_SENSE_NO_ACTIVITY,
+	SG_SENSE_ACTIVE
+};
+
+struct acx_bt_wlan_coex {
+	struct acx_header header;
+
+	/*
+	 * 0 -> PTA enabled
+	 * 1 -> PTA disabled
+	 * 2 -> sense no active mode, i.e.
+	 *      an interrupt is sent upon
+	 *      BT activity.
+	 * 3 -> PTA is switched on in response
+	 *      to the interrupt sending.
+	 */
+	u8 enable;
+	u8 pad[3];
+} __attribute__ ((packed));
+
+#define PTA_ANTENNA_TYPE_DEF		  (0)
+#define PTA_BT_HP_MAXTIME_DEF		  (2000)
+#define PTA_WLAN_HP_MAX_TIME_DEF	  (5000)
+#define PTA_SENSE_DISABLE_TIMER_DEF	  (1350)
+#define PTA_PROTECTIVE_RX_TIME_DEF	  (1500)
+#define PTA_PROTECTIVE_TX_TIME_DEF	  (1500)
+#define PTA_TIMEOUT_NEXT_BT_LP_PACKET_DEF (3000)
+#define PTA_SIGNALING_TYPE_DEF		  (1)
+#define PTA_AFH_LEVERAGE_ON_DEF		  (0)
+#define PTA_NUMBER_QUIET_CYCLE_DEF	  (0)
+#define PTA_MAX_NUM_CTS_DEF		  (3)
+#define PTA_NUMBER_OF_WLAN_PACKETS_DEF	  (2)
+#define PTA_NUMBER_OF_BT_PACKETS_DEF	  (2)
+#define PTA_PROTECTIVE_RX_TIME_FAST_DEF	  (1500)
+#define PTA_PROTECTIVE_TX_TIME_FAST_DEF	  (3000)
+#define PTA_CYCLE_TIME_FAST_DEF		  (8700)
+#define PTA_RX_FOR_AVALANCHE_DEF	  (5)
+#define PTA_ELP_HP_DEF			  (0)
+#define PTA_ANTI_STARVE_PERIOD_DEF	  (500)
+#define PTA_ANTI_STARVE_NUM_CYCLE_DEF	  (4)
+#define PTA_ALLOW_PA_SD_DEF		  (1)
+#define PTA_TIME_BEFORE_BEACON_DEF	  (500)
+#define PTA_TIME_BEFORE_BEACON_MONO_AUDIO (6300)
+#define PTA_HPDM_MAX_TIME_DEF		  (1600)
+#define PTA_TIME_OUT_NEXT_WLAN_DEF	  (2550)
+#define PTA_AUTO_MODE_NO_CTS_DEF	  (0)
+#define PTA_BT_HP_RESPECTED_DEF		  (3)
+#define PTA_WLAN_RX_MIN_RATE_DEF	  (24)
+#define PTA_ACK_MODE_DEF		  (1)
+
+struct acx_bt_wlan_coex_param {
+	struct acx_header header;
+
+	/*
+	 * The minimum rate of a received WLAN packet in the STA,
+	 * during protective mode, of which a new BT-HP request
+	 * during this Rx will always be respected and gain the antenna.
+	 */
+	u32 min_rate;
+
+	/* Max time the BT HP will be respected. */
+	u16 bt_hp_max_time;
+
+	/* Max time the WLAN HP will be respected. */
+	u16 wlan_hp_max_time;
+
+	/*
+	 * The time between the last BT activity
+	 * and the moment when the sense mode returns
+	 * to SENSE_INACTIVE.
+	 */
+	u16 sense_disable_timer;
+
+	/* Time before the next BT HP instance */
+	u16 rx_time_bt_hp;
+	u16 tx_time_bt_hp;
+
+	/* range: 10-20000    default: 1500 */
+	u16 rx_time_bt_hp_fast;
+	u16 tx_time_bt_hp_fast;
+
+	/* range: 2000-65535  default: 8700 */
+	u16 wlan_cycle_fast;
+
+	/* range: 0 - 15000 (Msec) default: 1000 */
+	u16 bt_anti_starvation_period;
+
+	/* range 400-10000(Usec) default: 3000 */
+	u16 next_bt_lp_packet;
+
+	/* Deafult: worst case for BT DH5 traffic */
+	u16 wake_up_beacon;
+
+	/* range: 0-50000(Usec) default: 1050 */
+	u16 hp_dm_max_guard_time;
+
+	/*
+	 * This is to prevent both BT & WLAN antenna
+	 * starvation.
+	 * Range: 100-50000(Usec) default:2550
+	 */
+	u16 next_wlan_packet;
+
+	/* 0 -> shared antenna */
+	u8 antenna_type;
+
+	/*
+	 * 0 -> TI legacy
+	 * 1 -> Palau
+	 */
+	u8 signal_type;
+
+	/*
+	 * BT AFH status
+	 * 0 -> no AFH
+	 * 1 -> from dedicated GPIO
+	 * 2 -> AFH on (from host)
+	 */
+	u8 afh_leverage_on;
+
+	/*
+	 * The number of cycles during which no
+	 * TX will be sent after 1 cycle of RX
+	 * transaction in protective mode
+	 */
+	u8 quiet_cycle_num;
+
+	/*
+	 * The maximum number of CTSs that will
+	 * be sent for receiving RX packet in
+	 * protective mode
+	 */
+	u8 max_cts;
+
+	/*
+	 * The number of WLAN packets
+	 * transferred in common mode before
+	 * switching to BT.
+	 */
+	u8 wlan_packets_num;
+
+	/*
+	 * The number of BT packets
+	 * transferred in common mode before
+	 * switching to WLAN.
+	 */
+	u8 bt_packets_num;
+
+	/* range: 1-255  default: 5 */
+	u8 missed_rx_avalanche;
+
+	/* range: 0-1    default: 1 */
+	u8 wlan_elp_hp;
+
+	/* range: 0 - 15  default: 4 */
+	u8 bt_anti_starvation_cycles;
+
+	u8 ack_mode_dual_ant;
+
+	/*
+	 * Allow PA_SD assertion/de-assertion
+	 * during enabled BT activity.
+	 */
+	u8 pa_sd_enable;
+
+	/*
+	 * Enable/Disable PTA in auto mode:
+	 * Support Both Active & P.S modes
+	 */
+	u8 pta_auto_mode_enable;
+
+	/* range: 0 - 20  default: 1 */
+	u8 bt_hp_respected_num;
+} __attribute__ ((packed));
+
+#define CCA_THRSH_ENABLE_ENERGY_D       0x140A
+#define CCA_THRSH_DISABLE_ENERGY_D      0xFFEF
+
+struct acx_energy_detection {
+	struct acx_header header;
+
+	/* The RX Clear Channel Assessment threshold in the PHY */
+	u16 rx_cca_threshold;
+	u8 tx_energy_detection;
+	u8 pad;
+} __attribute__ ((packed));
+
+#define BCN_RX_TIMEOUT_DEF_VALUE        10000
+#define BROADCAST_RX_TIMEOUT_DEF_VALUE  20000
+#define RX_BROADCAST_IN_PS_DEF_VALUE    1
+#define CONSECUTIVE_PS_POLL_FAILURE_DEF 4
+
+struct acx_beacon_broadcast {
+	struct acx_header header;
+
+	u16 beacon_rx_timeout;
+	u16 broadcast_timeout;
+
+	/* Enables receiving of broadcast packets in PS mode */
+	u8 rx_broadcast_in_ps;
+
+	/* Consecutive PS Poll failures before updating the host */
+	u8 ps_poll_threshold;
+	u8 pad[2];
+} __attribute__ ((packed));
+
+struct acx_event_mask {
+	struct acx_header header;
+
+	u32 event_mask;
+	u32 high_event_mask; /* Unused */
+} __attribute__ ((packed));
+
+#define CFG_RX_FCS		BIT(2)
+#define CFG_RX_ALL_GOOD		BIT(3)
+#define CFG_UNI_FILTER_EN	BIT(4)
+#define CFG_BSSID_FILTER_EN	BIT(5)
+#define CFG_MC_FILTER_EN	BIT(6)
+#define CFG_MC_ADDR0_EN		BIT(7)
+#define CFG_MC_ADDR1_EN		BIT(8)
+#define CFG_BC_REJECT_EN	BIT(9)
+#define CFG_SSID_FILTER_EN	BIT(10)
+#define CFG_RX_INT_FCS_ERROR	BIT(11)
+#define CFG_RX_INT_ENCRYPTED	BIT(12)
+#define CFG_RX_WR_RX_STATUS	BIT(13)
+#define CFG_RX_FILTER_NULTI	BIT(14)
+#define CFG_RX_RESERVE		BIT(15)
+#define CFG_RX_TIMESTAMP_TSF	BIT(16)
+
+#define CFG_RX_RSV_EN		BIT(0)
+#define CFG_RX_RCTS_ACK		BIT(1)
+#define CFG_RX_PRSP_EN		BIT(2)
+#define CFG_RX_PREQ_EN		BIT(3)
+#define CFG_RX_MGMT_EN		BIT(4)
+#define CFG_RX_FCS_ERROR	BIT(5)
+#define CFG_RX_DATA_EN		BIT(6)
+#define CFG_RX_CTL_EN		BIT(7)
+#define CFG_RX_CF_EN		BIT(8)
+#define CFG_RX_BCN_EN		BIT(9)
+#define CFG_RX_AUTH_EN		BIT(10)
+#define CFG_RX_ASSOC_EN		BIT(11)
+
+#define SCAN_PASSIVE		BIT(0)
+#define SCAN_5GHZ_BAND		BIT(1)
+#define SCAN_TRIGGERED		BIT(2)
+#define SCAN_PRIORITY_HIGH	BIT(3)
+
+struct acx_fw_gen_frame_rates {
+	struct acx_header header;
+
+	u8 tx_ctrl_frame_rate; /* RATE_* */
+	u8 tx_ctrl_frame_mod; /* CCK_* or PBCC_* */
+	u8 tx_mgt_frame_rate;
+	u8 tx_mgt_frame_mod;
+} __attribute__ ((packed));
+
+/* STA MAC */
+struct acx_dot11_station_id {
+	struct acx_header header;
+
+	u8 mac[ETH_ALEN];
+	u8 pad[2];
+} __attribute__ ((packed));
+
+struct acx_feature_config {
+	struct acx_header header;
+
+	u32 options;
+	u32 data_flow_options;
+} __attribute__ ((packed));
+
+struct acx_current_tx_power {
+	struct acx_header header;
+
+	u8  current_tx_power;
+	u8  padding[3];
+} __attribute__ ((packed));
+
+struct acx_dot11_default_key {
+	struct acx_header header;
+
+	u8 id;
+	u8 pad[3];
+} __attribute__ ((packed));
+
+struct acx_tsf_info {
+	struct acx_header header;
+
+	u32 current_tsf_msb;
+	u32 current_tsf_lsb;
+	u32 last_TBTT_msb;
+	u32 last_TBTT_lsb;
+	u8 last_dtim_count;
+	u8 pad[3];
+} __attribute__ ((packed));
+
+enum acx_wake_up_event {
+	WAKE_UP_EVENT_BEACON_BITMAP	= 0x01, /* Wake on every Beacon*/
+	WAKE_UP_EVENT_DTIM_BITMAP	= 0x02,	/* Wake on every DTIM*/
+	WAKE_UP_EVENT_N_DTIM_BITMAP	= 0x04, /* Wake on every Nth DTIM */
+	WAKE_UP_EVENT_N_BEACONS_BITMAP	= 0x08, /* Wake on every Nth Beacon */
+	WAKE_UP_EVENT_BITS_MASK		= 0x0F
+};
+
+struct acx_wake_up_condition {
+	struct acx_header header;
+
+	u8 wake_up_event; /* Only one bit can be set */
+	u8 listen_interval;
+	u8 pad[2];
+} __attribute__ ((packed));
+
+struct acx_aid {
+	struct acx_header header;
+
+	/*
+	 * To be set when associated with an AP.
+	 */
+	u16 aid;
+	u8 pad[2];
+} __attribute__ ((packed));
+
+enum acx_preamble_type {
+	ACX_PREAMBLE_LONG = 0,
+	ACX_PREAMBLE_SHORT = 1
+};
+
+struct acx_preamble {
+	struct acx_header header;
+
+	/*
+	 * When set, the WiLink transmits the frames with a short preamble and
+	 * when cleared, the WiLink transmits the frames with a long preamble.
+	 */
+	u8 preamble;
+	u8 padding[3];
+} __attribute__ ((packed));
+
+enum acx_ctsprotect_type {
+	CTSPROTECT_DISABLE = 0,
+	CTSPROTECT_ENABLE = 1
+};
+
+struct acx_ctsprotect {
+	struct acx_header header;
+	u8 ctsprotect;
+	u8 padding[3];
+} __attribute__ ((packed));
+
+struct acx_tx_statistics {
+	u32 internal_desc_overflow;
+}  __attribute__ ((packed));
+
+struct acx_rx_statistics {
+	u32 out_of_mem;
+	u32 hdr_overflow;
+	u32 hw_stuck;
+	u32 dropped;
+	u32 fcs_err;
+	u32 xfr_hint_trig;
+	u32 path_reset;
+	u32 reset_counter;
+} __attribute__ ((packed));
+
+struct acx_dma_statistics {
+	u32 rx_requested;
+	u32 rx_errors;
+	u32 tx_requested;
+	u32 tx_errors;
+}  __attribute__ ((packed));
+
+struct acx_isr_statistics {
+	/* host command complete */
+	u32 cmd_cmplt;
+
+	/* fiqisr() */
+	u32 fiqs;
+
+	/* (INT_STS_ND & INT_TRIG_RX_HEADER) */
+	u32 rx_headers;
+
+	/* (INT_STS_ND & INT_TRIG_RX_CMPLT) */
+	u32 rx_completes;
+
+	/* (INT_STS_ND & INT_TRIG_NO_RX_BUF) */
+	u32 rx_mem_overflow;
+
+	/* (INT_STS_ND & INT_TRIG_S_RX_RDY) */
+	u32 rx_rdys;
+
+	/* irqisr() */
+	u32 irqs;
+
+	/* (INT_STS_ND & INT_TRIG_TX_PROC) */
+	u32 tx_procs;
+
+	/* (INT_STS_ND & INT_TRIG_DECRYPT_DONE) */
+	u32 decrypt_done;
+
+	/* (INT_STS_ND & INT_TRIG_DMA0) */
+	u32 dma0_done;
+
+	/* (INT_STS_ND & INT_TRIG_DMA1) */
+	u32 dma1_done;
+
+	/* (INT_STS_ND & INT_TRIG_TX_EXC_CMPLT) */
+	u32 tx_exch_complete;
+
+	/* (INT_STS_ND & INT_TRIG_COMMAND) */
+	u32 commands;
+
+	/* (INT_STS_ND & INT_TRIG_RX_PROC) */
+	u32 rx_procs;
+
+	/* (INT_STS_ND & INT_TRIG_PM_802) */
+	u32 hw_pm_mode_changes;
+
+	/* (INT_STS_ND & INT_TRIG_ACKNOWLEDGE) */
+	u32 host_acknowledges;
+
+	/* (INT_STS_ND & INT_TRIG_PM_PCI) */
+	u32 pci_pm;
+
+	/* (INT_STS_ND & INT_TRIG_ACM_WAKEUP) */
+	u32 wakeups;
+
+	/* (INT_STS_ND & INT_TRIG_LOW_RSSI) */
+	u32 low_rssi;
+} __attribute__ ((packed));
+
+struct acx_wep_statistics {
+	/* WEP address keys configured */
+	u32 addr_key_count;
+
+	/* default keys configured */
+	u32 default_key_count;
+
+	u32 reserved;
+
+	/* number of times that WEP key not found on lookup */
+	u32 key_not_found;
+
+	/* number of times that WEP key decryption failed */
+	u32 decrypt_fail;
+
+	/* WEP packets decrypted */
+	u32 packets;
+
+	/* WEP decrypt interrupts */
+	u32 interrupt;
+} __attribute__ ((packed));
+
+#define ACX_MISSED_BEACONS_SPREAD 10
+
+struct acx_pwr_statistics {
+	/* the amount of enters into power save mode (both PD & ELP) */
+	u32 ps_enter;
+
+	/* the amount of enters into ELP mode */
+	u32 elp_enter;
+
+	/* the amount of missing beacon interrupts to the host */
+	u32 missing_bcns;
+
+	/* the amount of wake on host-access times */
+	u32 wake_on_host;
+
+	/* the amount of wake on timer-expire */
+	u32 wake_on_timer_exp;
+
+	/* the number of packets that were transmitted with PS bit set */
+	u32 tx_with_ps;
+
+	/* the number of packets that were transmitted with PS bit clear */
+	u32 tx_without_ps;
+
+	/* the number of received beacons */
+	u32 rcvd_beacons;
+
+	/* the number of entering into PowerOn (power save off) */
+	u32 power_save_off;
+
+	/* the number of entries into power save mode */
+	u16 enable_ps;
+
+	/*
+	 * the number of exits from power save, not including failed PS
+	 * transitions
+	 */
+	u16 disable_ps;
+
+	/*
+	 * the number of times the TSF counter was adjusted because
+	 * of drift
+	 */
+	u32 fix_tsf_ps;
+
+	/* Gives statistics about the spread continuous missed beacons.
+	 * The 16 LSB are dedicated for the PS mode.
+	 * The 16 MSB are dedicated for the PS mode.
+	 * cont_miss_bcns_spread[0] - single missed beacon.
+	 * cont_miss_bcns_spread[1] - two continuous missed beacons.
+	 * cont_miss_bcns_spread[2] - three continuous missed beacons.
+	 * ...
+	 * cont_miss_bcns_spread[9] - ten and more continuous missed beacons.
+	*/
+	u32 cont_miss_bcns_spread[ACX_MISSED_BEACONS_SPREAD];
+
+	/* the number of beacons in awake mode */
+	u32 rcvd_awake_beacons;
+} __attribute__ ((packed));
+
+struct acx_mic_statistics {
+	u32 rx_pkts;
+	u32 calc_failure;
+} __attribute__ ((packed));
+
+struct acx_aes_statistics {
+	u32 encrypt_fail;
+	u32 decrypt_fail;
+	u32 encrypt_packets;
+	u32 decrypt_packets;
+	u32 encrypt_interrupt;
+	u32 decrypt_interrupt;
+} __attribute__ ((packed));
+
+struct acx_event_statistics {
+	u32 heart_beat;
+	u32 calibration;
+	u32 rx_mismatch;
+	u32 rx_mem_empty;
+	u32 rx_pool;
+	u32 oom_late;
+	u32 phy_transmit_error;
+	u32 tx_stuck;
+} __attribute__ ((packed));
+
+struct acx_ps_statistics {
+	u32 pspoll_timeouts;
+	u32 upsd_timeouts;
+	u32 upsd_max_sptime;
+	u32 upsd_max_apturn;
+	u32 pspoll_max_apturn;
+	u32 pspoll_utilization;
+	u32 upsd_utilization;
+} __attribute__ ((packed));
+
+struct acx_rxpipe_statistics {
+	u32 rx_prep_beacon_drop;
+	u32 descr_host_int_trig_rx_data;
+	u32 beacon_buffer_thres_host_int_trig_rx_data;
+	u32 missed_beacon_host_int_trig_rx_data;
+	u32 tx_xfr_host_int_trig_rx_data;
+} __attribute__ ((packed));
+
+struct acx_statistics {
+	struct acx_header header;
+
+	struct acx_tx_statistics tx;
+	struct acx_rx_statistics rx;
+	struct acx_dma_statistics dma;
+	struct acx_isr_statistics isr;
+	struct acx_wep_statistics wep;
+	struct acx_pwr_statistics pwr;
+	struct acx_aes_statistics aes;
+	struct acx_mic_statistics mic;
+	struct acx_event_statistics event;
+	struct acx_ps_statistics ps;
+	struct acx_rxpipe_statistics rxpipe;
+} __attribute__ ((packed));
+
+#define ACX_MAX_RATE_CLASSES       8
+#define ACX_RATE_MASK_UNSPECIFIED  0
+#define ACX_RATE_RETRY_LIMIT      10
+
+struct acx_rate_class {
+	u32 enabled_rates;
+	u8 short_retry_limit;
+	u8 long_retry_limit;
+	u8 aflags;
+	u8 reserved;
+};
+
+struct acx_rate_policy {
+	struct acx_header header;
+
+	u32 rate_class_cnt;
+	struct acx_rate_class rate_class[ACX_MAX_RATE_CLASSES];
+} __attribute__ ((packed));
+
+struct wl1251_acx_memory {
+	__le16 num_stations; /* number of STAs to be supported. */
+	u16 reserved_1;
+
+	/*
+	 * Nmber of memory buffers for the RX mem pool.
+	 * The actual number may be less if there are
+	 * not enough blocks left for the minimum num
+	 * of TX ones.
+	 */
+	u8 rx_mem_block_num;
+	u8 reserved_2;
+	u8 num_tx_queues; /* From 1 to 16 */
+	u8 host_if_options; /* HOST_IF* */
+	u8 tx_min_mem_block_num;
+	u8 num_ssid_profiles;
+	__le16 debug_buffer_size;
+} __attribute__ ((packed));
+
+
+#define ACX_RX_DESC_MIN                1
+#define ACX_RX_DESC_MAX                127
+#define ACX_RX_DESC_DEF                32
+struct wl1251_acx_rx_queue_config {
+	u8 num_descs;
+	u8 pad;
+	u8 type;
+	u8 priority;
+	__le32 dma_address;
+} __attribute__ ((packed));
+
+#define ACX_TX_DESC_MIN                1
+#define ACX_TX_DESC_MAX                127
+#define ACX_TX_DESC_DEF                16
+struct wl1251_acx_tx_queue_config {
+    u8 num_descs;
+    u8 pad[2];
+    u8 attributes;
+} __attribute__ ((packed));
+
+#define MAX_TX_QUEUE_CONFIGS 5
+#define MAX_TX_QUEUES 4
+struct wl1251_acx_config_memory {
+	struct acx_header header;
+
+	struct wl1251_acx_memory mem_config;
+	struct wl1251_acx_rx_queue_config rx_queue_config;
+	struct wl1251_acx_tx_queue_config tx_queue_config[MAX_TX_QUEUE_CONFIGS];
+} __attribute__ ((packed));
+
+struct wl1251_acx_mem_map {
+	struct acx_header header;
+
+	void *code_start;
+	void *code_end;
+
+	void *wep_defkey_start;
+	void *wep_defkey_end;
+
+	void *sta_table_start;
+	void *sta_table_end;
+
+	void *packet_template_start;
+	void *packet_template_end;
+
+	void *queue_memory_start;
+	void *queue_memory_end;
+
+	void *packet_memory_pool_start;
+	void *packet_memory_pool_end;
+
+	void *debug_buffer1_start;
+	void *debug_buffer1_end;
+
+	void *debug_buffer2_start;
+	void *debug_buffer2_end;
+
+	/* Number of blocks FW allocated for TX packets */
+	u32 num_tx_mem_blocks;
+
+	/* Number of blocks FW allocated for RX packets */
+	u32 num_rx_mem_blocks;
+} __attribute__ ((packed));
+
+
+struct wl1251_acx_wr_tbtt_and_dtim {
+
+	struct acx_header header;
+
+	/* Time in TUs between two consecutive beacons */
+	u16 tbtt;
+
+	/*
+	 * DTIM period
+	 * For BSS: Number of TBTTs in a DTIM period (range: 1-10)
+	 * For IBSS: value shall be set to 1
+	*/
+	u8  dtim;
+	u8  padding;
+} __attribute__ ((packed));
+
+#define IPV4_VERSION 4
+#define IPV6_VERSION 6
+#define IPV4_ADDR_SIZE 4
+struct wl1251_acx_arp_filter {
+	struct acx_header header;
+	u8 version;       /* The IP version: 4 - IPv4, 6 - IPv6.*/
+	u8 enable;        /* 1 - ARP filtering is enabled, 0 - disabled */
+	u8 padding[2];
+	u8 address[16];     /* The IP address used to filter ARP packets.
+			       ARP packets that do not match this address are
+			       dropped. When the IP Version is 4, the last 12
+			       bytes of the the address are ignored.*/
+} __attribute__((packed));
+
+/*************************************************************************
+
+    Host Interrupt Register (WiLink -> Host)
+
+**************************************************************************/
+
+/* RX packet is ready in Xfer buffer #0 */
+#define WL1251_ACX_INTR_RX0_DATA      BIT(0)
+
+/* TX result(s) are in the TX complete buffer */
+#define WL1251_ACX_INTR_TX_RESULT	BIT(1)
+
+/* OBSOLETE */
+#define WL1251_ACX_INTR_TX_XFR		BIT(2)
+
+/* RX packet is ready in Xfer buffer #1 */
+#define WL1251_ACX_INTR_RX1_DATA	BIT(3)
+
+/* Event was entered to Event MBOX #A */
+#define WL1251_ACX_INTR_EVENT_A		BIT(4)
+
+/* Event was entered to Event MBOX #B */
+#define WL1251_ACX_INTR_EVENT_B		BIT(5)
+
+/* OBSOLETE */
+#define WL1251_ACX_INTR_WAKE_ON_HOST	BIT(6)
+
+/* Trace meassge on MBOX #A */
+#define WL1251_ACX_INTR_TRACE_A		BIT(7)
+
+/* Trace meassge on MBOX #B */
+#define WL1251_ACX_INTR_TRACE_B		BIT(8)
+
+/* Command processing completion */
+#define WL1251_ACX_INTR_CMD_COMPLETE	BIT(9)
+
+/* Init sequence is done */
+#define WL1251_ACX_INTR_INIT_COMPLETE	BIT(14)
+
+#define WL1251_ACX_INTR_ALL           0xFFFFFFFF
+
+enum {
+	ACX_WAKE_UP_CONDITIONS      = 0x0002,
+	ACX_MEM_CFG                 = 0x0003,
+	ACX_SLOT                    = 0x0004,
+	ACX_QUEUE_HEAD              = 0x0005, /* for MASTER mode only */
+	ACX_AC_CFG                  = 0x0007,
+	ACX_MEM_MAP                 = 0x0008,
+	ACX_AID                     = 0x000A,
+	ACX_RADIO_PARAM             = 0x000B, /* Not used */
+	ACX_CFG                     = 0x000C, /* Not used */
+	ACX_FW_REV                  = 0x000D,
+	ACX_MEDIUM_USAGE            = 0x000F,
+	ACX_RX_CFG                  = 0x0010,
+	ACX_TX_QUEUE_CFG            = 0x0011, /* FIXME: only used by wl1251 */
+	ACX_BSS_IN_PS               = 0x0012, /* for AP only */
+	ACX_STATISTICS              = 0x0013, /* Debug API */
+	ACX_FEATURE_CFG             = 0x0015,
+	ACX_MISC_CFG                = 0x0017, /* Not used */
+	ACX_TID_CFG                 = 0x001A,
+	ACX_BEACON_FILTER_OPT       = 0x001F,
+	ACX_LOW_RSSI                = 0x0020,
+	ACX_NOISE_HIST              = 0x0021,
+	ACX_HDK_VERSION             = 0x0022, /* ??? */
+	ACX_PD_THRESHOLD            = 0x0023,
+	ACX_DATA_PATH_PARAMS        = 0x0024, /* WO */
+	ACX_DATA_PATH_RESP_PARAMS   = 0x0024, /* RO */
+	ACX_CCA_THRESHOLD           = 0x0025,
+	ACX_EVENT_MBOX_MASK         = 0x0026,
+#ifdef FW_RUNNING_AS_AP
+	ACX_DTIM_PERIOD             = 0x0027, /* for AP only */
+#else
+	ACX_WR_TBTT_AND_DTIM        = 0x0027, /* STA only */
+#endif
+	ACX_ACI_OPTION_CFG          = 0x0029, /* OBSOLETE (for 1251)*/
+	ACX_GPIO_CFG                = 0x002A, /* Not used */
+	ACX_GPIO_SET                = 0x002B, /* Not used */
+	ACX_PM_CFG                  = 0x002C, /* To Be Documented */
+	ACX_CONN_MONIT_PARAMS       = 0x002D,
+	ACX_AVERAGE_RSSI            = 0x002E, /* Not used */
+	ACX_CONS_TX_FAILURE         = 0x002F,
+	ACX_BCN_DTIM_OPTIONS        = 0x0031,
+	ACX_SG_ENABLE               = 0x0032,
+	ACX_SG_CFG                  = 0x0033,
+	ACX_ANTENNA_DIVERSITY_CFG   = 0x0035, /* To Be Documented */
+	ACX_LOW_SNR		    = 0x0037, /* To Be Documented */
+	ACX_BEACON_FILTER_TABLE     = 0x0038,
+	ACX_ARP_IP_FILTER           = 0x0039,
+	ACX_ROAMING_STATISTICS_TBL  = 0x003B,
+	ACX_RATE_POLICY             = 0x003D,
+	ACX_CTS_PROTECTION          = 0x003E,
+	ACX_SLEEP_AUTH              = 0x003F,
+	ACX_PREAMBLE_TYPE	    = 0x0040,
+	ACX_ERROR_CNT               = 0x0041,
+	ACX_FW_GEN_FRAME_RATES      = 0x0042,
+	ACX_IBSS_FILTER		    = 0x0044,
+	ACX_SERVICE_PERIOD_TIMEOUT  = 0x0045,
+	ACX_TSF_INFO                = 0x0046,
+	ACX_CONFIG_PS_WMM           = 0x0049,
+	ACX_ENABLE_RX_DATA_FILTER   = 0x004A,
+	ACX_SET_RX_DATA_FILTER      = 0x004B,
+	ACX_GET_DATA_FILTER_STATISTICS = 0x004C,
+	ACX_POWER_LEVEL_TABLE       = 0x004D,
+	ACX_BET_ENABLE              = 0x0050,
+	DOT11_STATION_ID            = 0x1001,
+	DOT11_RX_MSDU_LIFE_TIME     = 0x1004,
+	DOT11_CUR_TX_PWR            = 0x100D,
+	DOT11_DEFAULT_KEY           = 0x1010,
+	DOT11_RX_DOT11_MODE         = 0x1012,
+	DOT11_RTS_THRESHOLD         = 0x1013,
+	DOT11_GROUP_ADDRESS_TBL     = 0x1014,
+
+	MAX_DOT11_IE = DOT11_GROUP_ADDRESS_TBL,
+
+	MAX_IE = 0xFFFF
+};
+
+
+int wl1251_acx_frame_rates(struct wl1251 *wl, u8 ctrl_rate, u8 ctrl_mod,
+			   u8 mgt_rate, u8 mgt_mod);
+int wl1251_acx_station_id(struct wl1251 *wl);
+int wl1251_acx_default_key(struct wl1251 *wl, u8 key_id);
+int wl1251_acx_wake_up_conditions(struct wl1251 *wl, u8 wake_up_event,
+				  u8 listen_interval);
+int wl1251_acx_sleep_auth(struct wl1251 *wl, u8 sleep_auth);
+int wl1251_acx_fw_version(struct wl1251 *wl, char *buf, size_t len);
+int wl1251_acx_tx_power(struct wl1251 *wl, int power);
+int wl1251_acx_feature_cfg(struct wl1251 *wl);
+int wl1251_acx_mem_map(struct wl1251 *wl,
+		       struct acx_header *mem_map, size_t len);
+int wl1251_acx_data_path_params(struct wl1251 *wl,
+				struct acx_data_path_params_resp *data_path);
+int wl1251_acx_rx_msdu_life_time(struct wl1251 *wl, u32 life_time);
+int wl1251_acx_rx_config(struct wl1251 *wl, u32 config, u32 filter);
+int wl1251_acx_pd_threshold(struct wl1251 *wl);
+int wl1251_acx_slot(struct wl1251 *wl, enum acx_slot_type slot_time);
+int wl1251_acx_group_address_tbl(struct wl1251 *wl, void *mc_list,
+				 u32 mc_list_len, bool enable);
+int wl1251_acx_service_period_timeout(struct wl1251 *wl);
+int wl1251_acx_rts_threshold(struct wl1251 *wl, u16 rts_threshold);
+int wl1251_acx_beacon_filter_opt(struct wl1251 *wl, bool enable_filter);
+int wl1251_acx_beacon_filter_table(struct wl1251 *wl);
+int wl1251_acx_conn_monit_params(struct wl1251 *wl);
+int wl1251_acx_sg_enable(struct wl1251 *wl, u8 mode);
+int wl1251_acx_sg_cfg(struct wl1251 *wl, u16 wake_up_beacon);
+int wl1251_acx_sg_configure(struct wl1251 *wl, bool force);
+int wl1251_acx_cca_threshold(struct wl1251 *wl);
+int wl1251_acx_bcn_dtim_options(struct wl1251 *wl);
+int wl1251_acx_aid(struct wl1251 *wl, u16 aid);
+int wl1251_acx_event_mbox_mask(struct wl1251 *wl, u32 event_mask);
+int wl1251_acx_low_rssi(struct wl1251 *wl, s8 threshold, u8 weight,
+			u8 depth, enum wl12xx_acx_low_rssi_type type);
+int wl1251_acx_set_preamble(struct wl1251 *wl, enum acx_preamble_type preamble);
+int wl1251_acx_cts_protect(struct wl1251 *wl,
+			    enum acx_ctsprotect_type ctsprotect);
+int wl1251_acx_statistics(struct wl1251 *wl, struct acx_statistics *stats);
+int wl1251_acx_tsf_info(struct wl1251 *wl, u64 *mactime);
+int wl1251_acx_rate_policies(struct wl1251 *wl);
+int wl1251_acx_mem_cfg(struct wl1251 *wl);
+int wl1251_acx_wr_tbtt_and_dtim(struct wl1251 *wl, u16 tbtt, u8 dtim);
+int wl1251_acx_ip_config(struct wl1251 *wl, bool enable, u8 *address,
+			 u8 version);
+#endif /* __WL1251_ACX_H__ */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_boot.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_boot.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_boot.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_boot.c	2012-12-16 13:13:01.680330145 +0100
@@ -0,0 +1,552 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/gpio.h>
+
+#include "wl1251_reg.h"
+#include "wl1251_boot.h"
+#include "wl1251_spi.h"
+#include "wl1251_event.h"
+#include "wl1251_acx.h"
+
+static void wl1251_boot_enable_interrupts(struct wl1251 *wl)
+{
+	enable_irq(wl->irq);
+}
+
+void wl1251_boot_target_enable_interrupts(struct wl1251 *wl)
+{
+	wl1251_reg_write32(wl, ACX_REG_INTERRUPT_MASK, ~(wl->intr_mask));
+	wl1251_reg_write32(wl, HI_CFG, HI_CFG_DEF_VAL);
+}
+
+int wl1251_boot_soft_reset(struct wl1251 *wl)
+{
+	unsigned long timeout;
+	u32 boot_data;
+
+	/* perform soft reset */
+	wl1251_reg_write32(wl, ACX_REG_SLV_SOFT_RESET, ACX_SLV_SOFT_RESET_BIT);
+
+	/* SOFT_RESET is self clearing */
+	timeout = jiffies + usecs_to_jiffies(SOFT_RESET_MAX_TIME);
+	while (1) {
+		boot_data = wl1251_reg_read32(wl, ACX_REG_SLV_SOFT_RESET);
+		wl1251_debug(DEBUG_BOOT, "soft reset bootdata 0x%x", boot_data);
+		if ((boot_data & ACX_SLV_SOFT_RESET_BIT) == 0)
+			break;
+
+		if (time_after(jiffies, timeout)) {
+			/* 1.2 check pWhalBus->uSelfClearTime if the
+			 * timeout was reached */
+			wl1251_error("soft reset timeout");
+			return -1;
+		}
+
+		udelay(SOFT_RESET_STALL_TIME);
+	}
+
+	/* disable Rx/Tx */
+	wl1251_reg_write32(wl, ENABLE, 0x0);
+
+	/* disable auto calibration on start*/
+	wl1251_reg_write32(wl, SPARE_A2, 0xffff);
+
+	return 0;
+}
+
+int wl1251_boot_init_seq(struct wl1251 *wl)
+{
+	u32 scr_pad6, init_data, tmp, elp_cmd, ref_freq;
+
+	/*
+	 * col #1: INTEGER_DIVIDER
+	 * col #2: FRACTIONAL_DIVIDER
+	 * col #3: ATTN_BB
+	 * col #4: ALPHA_BB
+	 * col #5: STOP_TIME_BB
+	 * col #6: BB_PLL_LOOP_FILTER
+	 */
+	static const u32 LUT[REF_FREQ_NUM][LUT_PARAM_NUM] = {
+
+		{   83, 87381,  0xB, 5, 0xF00,  3}, /* REF_FREQ_19_2*/
+		{   61, 141154, 0xB, 5, 0x1450, 2}, /* REF_FREQ_26_0*/
+		{   41, 174763, 0xC, 6, 0x2D00, 1}, /* REF_FREQ_38_4*/
+		{   40, 0,      0xC, 6, 0x2EE0, 1}, /* REF_FREQ_40_0*/
+		{   47, 162280, 0xC, 6, 0x2760, 1}  /* REF_FREQ_33_6        */
+	};
+
+	/* read NVS params */
+	scr_pad6 = wl1251_reg_read32(wl, SCR_PAD6);
+	wl1251_debug(DEBUG_BOOT, "scr_pad6 0x%x", scr_pad6);
+
+	/* read ELP_CMD */
+	elp_cmd = wl1251_reg_read32(wl, ELP_CMD);
+	wl1251_debug(DEBUG_BOOT, "elp_cmd 0x%x", elp_cmd);
+
+	/* set the BB calibration time to be 300 usec (PLL_CAL_TIME) */
+	ref_freq = scr_pad6 & 0x000000FF;
+	wl1251_debug(DEBUG_BOOT, "ref_freq 0x%x", ref_freq);
+
+	wl1251_reg_write32(wl, PLL_CAL_TIME, 0x9);
+
+	/*
+	 * PG 1.2: set the clock buffer time to be 210 usec (CLK_BUF_TIME)
+	 */
+	wl1251_reg_write32(wl, CLK_BUF_TIME, 0x6);
+
+	/*
+	 * set the clock detect feature to work in the restart wu procedure
+	 * (ELP_CFG_MODE[14]) and Select the clock source type
+	 * (ELP_CFG_MODE[13:12])
+	 */
+	tmp = ((scr_pad6 & 0x0000FF00) << 4) | 0x00004000;
+	wl1251_reg_write32(wl, ELP_CFG_MODE, tmp);
+
+	/* PG 1.2: enable the BB PLL fix. Enable the PLL_LIMP_CLK_EN_CMD */
+	elp_cmd |= 0x00000040;
+	wl1251_reg_write32(wl, ELP_CMD, elp_cmd);
+
+	/* PG 1.2: Set the BB PLL stable time to be 1000usec
+	 * (PLL_STABLE_TIME) */
+	wl1251_reg_write32(wl, CFG_PLL_SYNC_CNT, 0x20);
+
+	/* PG 1.2: read clock request time */
+	init_data = wl1251_reg_read32(wl, CLK_REQ_TIME);
+
+	/*
+	 * PG 1.2: set the clock request time to be ref_clk_settling_time -
+	 * 1ms = 4ms
+	 */
+	if (init_data > 0x21)
+		tmp = init_data - 0x21;
+	else
+		tmp = 0;
+	wl1251_reg_write32(wl, CLK_REQ_TIME, tmp);
+
+	/* set BB PLL configurations in RF AFE */
+	wl1251_reg_write32(wl, 0x003058cc, 0x4B5);
+
+	/* set RF_AFE_REG_5 */
+	wl1251_reg_write32(wl, 0x003058d4, 0x50);
+
+	/* set RF_AFE_CTRL_REG_2 */
+	wl1251_reg_write32(wl, 0x00305948, 0x11c001);
+
+	/*
+	 * change RF PLL and BB PLL divider for VCO clock and adjust VCO
+	 * bais current(RF_AFE_REG_13)
+	 */
+	wl1251_reg_write32(wl, 0x003058f4, 0x1e);
+
+	/* set BB PLL configurations */
+	tmp = LUT[ref_freq][LUT_PARAM_INTEGER_DIVIDER] | 0x00017000;
+	wl1251_reg_write32(wl, 0x00305840, tmp);
+
+	/* set fractional divider according to Appendix C-BB PLL
+	 * Calculations
+	 */
+	tmp = LUT[ref_freq][LUT_PARAM_FRACTIONAL_DIVIDER];
+	wl1251_reg_write32(wl, 0x00305844, tmp);
+
+	/* set the initial data for the sigma delta */
+	wl1251_reg_write32(wl, 0x00305848, 0x3039);
+
+	/*
+	 * set the accumulator attenuation value, calibration loop1
+	 * (alpha), calibration loop2 (beta), calibration loop3 (gamma) and
+	 * the VCO gain
+	 */
+	tmp = (LUT[ref_freq][LUT_PARAM_ATTN_BB] << 16) |
+		(LUT[ref_freq][LUT_PARAM_ALPHA_BB] << 12) | 0x1;
+	wl1251_reg_write32(wl, 0x00305854, tmp);
+
+	/*
+	 * set the calibration stop time after holdoff time expires and set
+	 * settling time HOLD_OFF_TIME_BB
+	 */
+	tmp = LUT[ref_freq][LUT_PARAM_STOP_TIME_BB] | 0x000A0000;
+	wl1251_reg_write32(wl, 0x00305858, tmp);
+
+	/*
+	 * set BB PLL Loop filter capacitor3- BB_C3[2:0] and set BB PLL
+	 * constant leakage current to linearize PFD to 0uA -
+	 * BB_ILOOPF[7:3]
+	 */
+	tmp = LUT[ref_freq][LUT_PARAM_BB_PLL_LOOP_FILTER] | 0x00000030;
+	wl1251_reg_write32(wl, 0x003058f8, tmp);
+
+	/*
+	 * set regulator output voltage for n divider to
+	 * 1.35-BB_REFDIV[1:0], set charge pump current- BB_CPGAIN[4:2],
+	 * set BB PLL Loop filter capacitor2- BB_C2[7:5], set gain of BB
+	 * PLL auto-call to normal mode- BB_CALGAIN_3DB[8]
+	 */
+	wl1251_reg_write32(wl, 0x003058f0, 0x29);
+
+	/* enable restart wakeup sequence (ELP_CMD[0]) */
+	wl1251_reg_write32(wl, ELP_CMD, elp_cmd | 0x1);
+
+	/* restart sequence completed */
+	udelay(2000);
+
+	return 0;
+}
+
+static void wl1251_boot_set_ecpu_ctrl(struct wl1251 *wl, u32 flag)
+{
+	u32 cpu_ctrl;
+
+	/* 10.5.0 run the firmware (I) */
+	cpu_ctrl = wl1251_reg_read32(wl, ACX_REG_ECPU_CONTROL);
+
+	/* 10.5.1 run the firmware (II) */
+	cpu_ctrl &= ~flag;
+	wl1251_reg_write32(wl, ACX_REG_ECPU_CONTROL, cpu_ctrl);
+}
+
+int wl1251_boot_run_firmware(struct wl1251 *wl)
+{
+	int loop, ret;
+	u32 chip_id, interrupt;
+
+	wl1251_boot_set_ecpu_ctrl(wl, ECPU_CONTROL_HALT);
+
+	chip_id = wl1251_reg_read32(wl, CHIP_ID_B);
+
+	wl1251_debug(DEBUG_BOOT, "chip id after firmware boot: 0x%x", chip_id);
+
+	if (chip_id != wl->chip_id) {
+		wl1251_error("chip id doesn't match after firmware boot");
+		return -EIO;
+	}
+
+	/* wait for init to complete */
+	loop = 0;
+	while (loop++ < INIT_LOOP) {
+		udelay(INIT_LOOP_DELAY);
+		interrupt = wl1251_reg_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);
+
+		if (interrupt == 0xffffffff) {
+			wl1251_error("error reading hardware complete "
+				     "init indication");
+			return -EIO;
+		}
+		/* check that ACX_INTR_INIT_COMPLETE is enabled */
+		else if (interrupt & WL1251_ACX_INTR_INIT_COMPLETE) {
+			wl1251_reg_write32(wl, ACX_REG_INTERRUPT_ACK,
+					   WL1251_ACX_INTR_INIT_COMPLETE);
+			break;
+		}
+	}
+
+	if (loop >= INIT_LOOP) {
+		wl1251_error("timeout waiting for the hardware to "
+			     "complete initialization");
+		return -EIO;
+	}
+
+	/* get hardware config command mail box */
+	wl->cmd_box_addr = wl1251_reg_read32(wl, REG_COMMAND_MAILBOX_PTR);
+
+	/* get hardware config event mail box */
+	wl->event_box_addr = wl1251_reg_read32(wl, REG_EVENT_MAILBOX_PTR);
+
+	/* set the working partition to its "running" mode offset */
+	wl1251_set_partition(wl, WL1251_PART_WORK_MEM_START,
+			     WL1251_PART_WORK_MEM_SIZE,
+			     WL1251_PART_WORK_REG_START,
+			     WL1251_PART_WORK_REG_SIZE);
+
+	wl1251_debug(DEBUG_MAILBOX, "cmd_box_addr 0x%x event_box_addr 0x%x",
+		     wl->cmd_box_addr, wl->event_box_addr);
+
+	wl1251_acx_fw_version(wl, wl->fw_ver, sizeof(wl->fw_ver));
+
+	/*
+	 * in case of full asynchronous mode the firmware event must be
+	 * ready to receive event from the command mailbox
+	 */
+
+	/* enable gpio interrupts */
+	wl1251_boot_enable_interrupts(wl);
+
+	/* Enable target's interrupts */
+	wl->intr_mask = WL1251_ACX_INTR_RX0_DATA |
+		WL1251_ACX_INTR_RX1_DATA |
+		WL1251_ACX_INTR_TX_RESULT |
+		WL1251_ACX_INTR_EVENT_A |
+		WL1251_ACX_INTR_EVENT_B |
+		WL1251_ACX_INTR_INIT_COMPLETE;
+	wl1251_boot_target_enable_interrupts(wl);
+
+	wl->event_mask = SCAN_COMPLETE_EVENT_ID | BSS_LOSE_EVENT_ID |
+		SYNCHRONIZATION_TIMEOUT_EVENT_ID |
+		ROAMING_TRIGGER_LOW_RSSI_EVENT_ID |
+		ROAMING_TRIGGER_REGAINED_RSSI_EVENT_ID |
+		REGAINED_BSS_EVENT_ID | BT_PTA_SENSE_EVENT_ID |
+		BT_PTA_PREDICTION_EVENT_ID;
+
+	ret = wl1251_event_unmask(wl);
+	if (ret < 0) {
+		wl1251_error("EVENT mask setting failed");
+		return ret;
+	}
+
+	wl1251_event_mbox_config(wl);
+
+	/* firmware startup completed */
+	return 0;
+}
+
+static int wl1251_boot_upload_firmware(struct wl1251 *wl)
+{
+	int addr, chunk_num, partition_limit;
+	size_t fw_data_len, len;
+	u8 *p, *buf;
+
+	/* whal_FwCtrl_LoadFwImageSm() */
+
+	wl1251_debug(DEBUG_BOOT, "chip id before fw upload: 0x%x",
+		     wl1251_reg_read32(wl, CHIP_ID_B));
+
+	/* 10.0 check firmware length and set partition */
+	fw_data_len =  (wl->fw[4] << 24) | (wl->fw[5] << 16) |
+		(wl->fw[6] << 8) | (wl->fw[7]);
+
+	wl1251_debug(DEBUG_BOOT, "fw_data_len %zu chunk_size %d", fw_data_len,
+		CHUNK_SIZE);
+
+	if ((fw_data_len % 4) != 0) {
+		wl1251_error("firmware length not multiple of four");
+		return -EIO;
+	}
+
+	buf = kmalloc(CHUNK_SIZE, GFP_KERNEL);
+	if (!buf) {
+		wl1251_error("allocation for firmware upload chunk failed");
+		return -ENOMEM;
+	}
+
+	wl1251_set_partition(wl, WL1251_PART_DOWN_MEM_START,
+			     WL1251_PART_DOWN_MEM_SIZE,
+			     WL1251_PART_DOWN_REG_START,
+			     WL1251_PART_DOWN_REG_SIZE);
+
+	/* 10.1 set partition limit and chunk num */
+	chunk_num = 0;
+	partition_limit = WL1251_PART_DOWN_MEM_SIZE;
+
+	while (chunk_num < fw_data_len / CHUNK_SIZE) {
+		/* 10.2 update partition, if needed */
+		addr = WL1251_PART_DOWN_MEM_START +
+			(chunk_num + 2) * CHUNK_SIZE;
+		if (addr > partition_limit) {
+			addr = WL1251_PART_DOWN_MEM_START +
+				chunk_num * CHUNK_SIZE;
+			partition_limit = chunk_num * CHUNK_SIZE +
+				WL1251_PART_DOWN_MEM_SIZE;
+			wl1251_set_partition(wl,
+					     addr,
+					     WL1251_PART_DOWN_MEM_SIZE,
+					     WL1251_PART_DOWN_REG_START,
+					     WL1251_PART_DOWN_REG_SIZE);
+		}
+
+		/* 10.3 upload the chunk */
+		addr = WL1251_PART_DOWN_MEM_START + chunk_num * CHUNK_SIZE;
+		p = wl->fw + FW_HDR_SIZE + chunk_num * CHUNK_SIZE;
+		wl1251_debug(DEBUG_BOOT, "uploading fw chunk 0x%p to 0x%x",
+			     p, addr);
+
+		/* need to copy the chunk for dma */
+		len = CHUNK_SIZE;
+		memcpy(buf, p, len);
+		wl1251_spi_mem_write(wl, addr, buf, len);
+
+		chunk_num++;
+	}
+
+	/* 10.4 upload the last chunk */
+	addr = WL1251_PART_DOWN_MEM_START + chunk_num * CHUNK_SIZE;
+	p = wl->fw + FW_HDR_SIZE + chunk_num * CHUNK_SIZE;
+
+	/* need to copy the chunk for dma */
+	len = fw_data_len % CHUNK_SIZE;
+	memcpy(buf, p, len);
+
+	wl1251_debug(DEBUG_BOOT, "uploading fw last chunk (%zu B) 0x%p to 0x%x",
+		     len, p, addr);
+	wl1251_spi_mem_write(wl, addr, buf, len);
+
+	kfree(buf);
+
+	return 0;
+}
+
+static int wl1251_boot_upload_nvs(struct wl1251 *wl)
+{
+	size_t nvs_len, nvs_bytes_written, burst_len;
+	int nvs_start, i;
+	u32 dest_addr, val;
+	u8 *nvs_ptr, *nvs;
+
+	nvs = wl->nvs;
+	if (nvs == NULL)
+		return -ENODEV;
+
+	nvs_ptr = nvs;
+
+	nvs_len = wl->nvs_len;
+	nvs_start = wl->fw_len;
+
+	/*
+	 * Layout before the actual NVS tables:
+	 * 1 byte : burst length.
+	 * 2 bytes: destination address.
+	 * n bytes: data to burst copy.
+	 *
+	 * This is ended by a 0 length, then the NVS tables.
+	 */
+
+	while (nvs_ptr[0]) {
+		burst_len = nvs_ptr[0];
+		dest_addr = (nvs_ptr[1] & 0xfe) | ((u32)(nvs_ptr[2] << 8));
+
+		/* We move our pointer to the data */
+		nvs_ptr += 3;
+
+		for (i = 0; i < burst_len; i++) {
+			val = (nvs_ptr[0] | (nvs_ptr[1] << 8)
+			       | (nvs_ptr[2] << 16) | (nvs_ptr[3] << 24));
+
+			wl1251_debug(DEBUG_BOOT,
+				     "nvs burst write 0x%x: 0x%x",
+				     dest_addr, val);
+			wl1251_mem_write32(wl, dest_addr, val);
+
+			nvs_ptr += 4;
+			dest_addr += 4;
+		}
+	}
+
+	/*
+	 * We've reached the first zero length, the first NVS table
+	 * is 7 bytes further.
+	 */
+	nvs_ptr += 7;
+	nvs_len -= nvs_ptr - nvs;
+	nvs_len = ALIGN(nvs_len, 4);
+
+	/* Now we must set the partition correctly */
+	wl1251_set_partition(wl, nvs_start,
+			     WL1251_PART_DOWN_MEM_SIZE,
+			     WL1251_PART_DOWN_REG_START,
+			     WL1251_PART_DOWN_REG_SIZE);
+
+	/* And finally we upload the NVS tables */
+	nvs_bytes_written = 0;
+	while (nvs_bytes_written < nvs_len) {
+		val = (nvs_ptr[0] | (nvs_ptr[1] << 8)
+		       | (nvs_ptr[2] << 16) | (nvs_ptr[3] << 24));
+
+		val = cpu_to_le32(val);
+
+		wl1251_debug(DEBUG_BOOT,
+			     "nvs write table 0x%x: 0x%x",
+			     nvs_start, val);
+		wl1251_mem_write32(wl, nvs_start, val);
+
+		nvs_ptr += 4;
+		nvs_bytes_written += 4;
+		nvs_start += 4;
+	}
+
+	return 0;
+}
+
+int wl1251_boot(struct wl1251 *wl)
+{
+	int ret = 0, minor_minor_e2_ver;
+	u32 tmp, boot_data;
+
+	ret = wl1251_boot_soft_reset(wl);
+	if (ret < 0)
+		goto out;
+
+	/* 2. start processing NVS file */
+	ret = wl1251_boot_upload_nvs(wl);
+	if (ret < 0)
+		goto out;
+
+	/* write firmware's last address (ie. it's length) to
+	 * ACX_EEPROMLESS_IND_REG */
+	wl1251_reg_write32(wl, ACX_EEPROMLESS_IND_REG, wl->fw_len);
+
+	/* 6. read the EEPROM parameters */
+	tmp = wl1251_reg_read32(wl, SCR_PAD2);
+
+	/* 7. read bootdata */
+	wl->boot_attr.radio_type = (tmp & 0x0000FF00) >> 8;
+	wl->boot_attr.major = (tmp & 0x00FF0000) >> 16;
+	tmp = wl1251_reg_read32(wl, SCR_PAD3);
+
+	/* 8. check bootdata and call restart sequence */
+	wl->boot_attr.minor = (tmp & 0x00FF0000) >> 16;
+	minor_minor_e2_ver = (tmp & 0xFF000000) >> 24;
+
+	wl1251_debug(DEBUG_BOOT, "radioType 0x%x majorE2Ver 0x%x "
+		     "minorE2Ver 0x%x minor_minor_e2_ver 0x%x",
+		     wl->boot_attr.radio_type, wl->boot_attr.major,
+		     wl->boot_attr.minor, minor_minor_e2_ver);
+
+	ret = wl1251_boot_init_seq(wl);
+	if (ret < 0)
+		goto out;
+
+	/* 9. NVS processing done */
+	boot_data = wl1251_reg_read32(wl, ACX_REG_ECPU_CONTROL);
+
+	wl1251_debug(DEBUG_BOOT, "halt boot_data 0x%x", boot_data);
+
+	/* 10. check that ECPU_CONTROL_HALT bits are set in
+	 * pWhalBus->uBootData and start uploading firmware
+	 */
+	if ((boot_data & ECPU_CONTROL_HALT) == 0) {
+		wl1251_error("boot failed, ECPU_CONTROL_HALT not set");
+		ret = -EIO;
+		goto out;
+	}
+
+	ret = wl1251_boot_upload_firmware(wl);
+	if (ret < 0)
+		goto out;
+
+	/* 10.5 start firmware */
+	ret = wl1251_boot_run_firmware(wl);
+	if (ret < 0)
+		goto out;
+
+out:
+	return ret;
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_boot.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_boot.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_boot.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_boot.h	2012-12-16 13:13:01.680330145 +0100
@@ -0,0 +1,41 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __BOOT_H__
+#define __BOOT_H__
+
+#include "wl1251.h"
+
+int wl1251_boot_soft_reset(struct wl1251 *wl);
+int wl1251_boot_init_seq(struct wl1251 *wl);
+int wl1251_boot_run_firmware(struct wl1251 *wl);
+void wl1251_boot_target_enable_interrupts(struct wl1251 *wl);
+int wl1251_boot(struct wl1251 *wl);
+
+/* number of times we try to read the INIT interrupt */
+#define INIT_LOOP 20000
+
+/* delay between retries */
+#define INIT_LOOP_DELAY 50
+
+#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,709 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (C) 2008-2009 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-
-#include "wl1251.h"
-#include "reg.h"
-#include "spi.h"
-#include "boot.h"
-#include "event.h"
-#include "acx.h"
-#include "tx.h"
-#include "rx.h"
-#include "ps.h"
-#include "init.h"
-
-static struct wl12xx_partition_set wl1251_part_table[PART_TABLE_LEN] = {
-	[PART_DOWN] = {
-		.mem = {
-			.start = 0x00000000,
-			.size  = 0x00016800
-		},
-		.reg = {
-			.start = REGISTERS_BASE,
-			.size  = REGISTERS_DOWN_SIZE
-		},
-	},
-
-	[PART_WORK] = {
-		.mem = {
-			.start = 0x00028000,
-			.size  = 0x00014000
-		},
-		.reg = {
-			.start = REGISTERS_BASE,
-			.size  = REGISTERS_WORK_SIZE
-		},
-	},
-
-	/* WL1251 doesn't use the DRPW partition, so we don't set it here */
-};
-
-static enum wl12xx_acx_int_reg wl1251_acx_reg_table[ACX_REG_TABLE_LEN] = {
-	[ACX_REG_INTERRUPT_TRIG]     = (REGISTERS_BASE + 0x0474),
-	[ACX_REG_INTERRUPT_TRIG_H]   = (REGISTERS_BASE + 0x0478),
-	[ACX_REG_INTERRUPT_MASK]     = (REGISTERS_BASE + 0x0494),
-	[ACX_REG_HINT_MASK_SET]      = (REGISTERS_BASE + 0x0498),
-	[ACX_REG_HINT_MASK_CLR]      = (REGISTERS_BASE + 0x049C),
-	[ACX_REG_INTERRUPT_NO_CLEAR] = (REGISTERS_BASE + 0x04B0),
-	[ACX_REG_INTERRUPT_CLEAR]    = (REGISTERS_BASE + 0x04A4),
-	[ACX_REG_INTERRUPT_ACK]      = (REGISTERS_BASE + 0x04A8),
-	[ACX_REG_SLV_SOFT_RESET]     = (REGISTERS_BASE + 0x0000),
-	[ACX_REG_EE_START]           = (REGISTERS_BASE + 0x080C),
-	[ACX_REG_ECPU_CONTROL]       = (REGISTERS_BASE + 0x0804)
-};
-
-static int wl1251_upload_firmware(struct wl12xx *wl)
-{
-	struct wl12xx_partition_set *p_table = wl->chip.p_table;
-	int addr, chunk_num, partition_limit;
-	size_t fw_data_len;
-	u8 *p;
-
-	/* whal_FwCtrl_LoadFwImageSm() */
-
-	wl12xx_debug(DEBUG_BOOT, "chip id before fw upload: 0x%x",
-		     wl12xx_reg_read32(wl, CHIP_ID_B));
-
-	/* 10.0 check firmware length and set partition */
-	fw_data_len =  (wl->fw[4] << 24) | (wl->fw[5] << 16) |
-		(wl->fw[6] << 8) | (wl->fw[7]);
-
-	wl12xx_debug(DEBUG_BOOT, "fw_data_len %d chunk_size %d", fw_data_len,
-		CHUNK_SIZE);
-
-	if ((fw_data_len % 4) != 0) {
-		wl12xx_error("firmware length not multiple of four");
-		return -EIO;
-	}
-
-	wl12xx_set_partition(wl,
-			     p_table[PART_DOWN].mem.start,
-			     p_table[PART_DOWN].mem.size,
-			     p_table[PART_DOWN].reg.start,
-			     p_table[PART_DOWN].reg.size);
-
-	/* 10.1 set partition limit and chunk num */
-	chunk_num = 0;
-	partition_limit = p_table[PART_DOWN].mem.size;
-
-	while (chunk_num < fw_data_len / CHUNK_SIZE) {
-		/* 10.2 update partition, if needed */
-		addr = p_table[PART_DOWN].mem.start +
-			(chunk_num + 2) * CHUNK_SIZE;
-		if (addr > partition_limit) {
-			addr = p_table[PART_DOWN].mem.start +
-				chunk_num * CHUNK_SIZE;
-			partition_limit = chunk_num * CHUNK_SIZE +
-				p_table[PART_DOWN].mem.size;
-			wl12xx_set_partition(wl,
-					     addr,
-					     p_table[PART_DOWN].mem.size,
-					     p_table[PART_DOWN].reg.start,
-					     p_table[PART_DOWN].reg.size);
-		}
-
-		/* 10.3 upload the chunk */
-		addr = p_table[PART_DOWN].mem.start + chunk_num * CHUNK_SIZE;
-		p = wl->fw + FW_HDR_SIZE + chunk_num * CHUNK_SIZE;
-		wl12xx_debug(DEBUG_BOOT, "uploading fw chunk 0x%p to 0x%x",
-			     p, addr);
-		wl12xx_spi_mem_write(wl, addr, p, CHUNK_SIZE);
-
-		chunk_num++;
-	}
-
-	/* 10.4 upload the last chunk */
-	addr = p_table[PART_DOWN].mem.start + chunk_num * CHUNK_SIZE;
-	p = wl->fw + FW_HDR_SIZE + chunk_num * CHUNK_SIZE;
-	wl12xx_debug(DEBUG_BOOT, "uploading fw last chunk (%d B) 0x%p to 0x%x",
-		     fw_data_len % CHUNK_SIZE, p, addr);
-	wl12xx_spi_mem_write(wl, addr, p, fw_data_len % CHUNK_SIZE);
-
-	return 0;
-}
-
-static int wl1251_upload_nvs(struct wl12xx *wl)
-{
-	size_t nvs_len, nvs_bytes_written, burst_len;
-	int nvs_start, i;
-	u32 dest_addr, val;
-	u8 *nvs_ptr, *nvs;
-
-	nvs = wl->nvs;
-	if (nvs == NULL)
-		return -ENODEV;
-
-	nvs_ptr = nvs;
-
-	nvs_len = wl->nvs_len;
-	nvs_start = wl->fw_len;
-
-	/*
-	 * Layout before the actual NVS tables:
-	 * 1 byte : burst length.
-	 * 2 bytes: destination address.
-	 * n bytes: data to burst copy.
-	 *
-	 * This is ended by a 0 length, then the NVS tables.
-	 */
-
-	while (nvs_ptr[0]) {
-		burst_len = nvs_ptr[0];
-		dest_addr = (nvs_ptr[1] & 0xfe) | ((u32)(nvs_ptr[2] << 8));
-
-		/* We move our pointer to the data */
-		nvs_ptr += 3;
-
-		for (i = 0; i < burst_len; i++) {
-			val = (nvs_ptr[0] | (nvs_ptr[1] << 8)
-			       | (nvs_ptr[2] << 16) | (nvs_ptr[3] << 24));
-
-			wl12xx_debug(DEBUG_BOOT,
-				     "nvs burst write 0x%x: 0x%x",
-				     dest_addr, val);
-			wl12xx_mem_write32(wl, dest_addr, val);
-
-			nvs_ptr += 4;
-			dest_addr += 4;
-		}
-	}
-
-	/*
-	 * We've reached the first zero length, the first NVS table
-	 * is 7 bytes further.
-	 */
-	nvs_ptr += 7;
-	nvs_len -= nvs_ptr - nvs;
-	nvs_len = ALIGN(nvs_len, 4);
-
-	/* Now we must set the partition correctly */
-	wl12xx_set_partition(wl, nvs_start,
-			     wl->chip.p_table[PART_DOWN].mem.size,
-			     wl->chip.p_table[PART_DOWN].reg.start,
-			     wl->chip.p_table[PART_DOWN].reg.size);
-
-	/* And finally we upload the NVS tables */
-	nvs_bytes_written = 0;
-	while (nvs_bytes_written < nvs_len) {
-		val = (nvs_ptr[0] | (nvs_ptr[1] << 8)
-		       | (nvs_ptr[2] << 16) | (nvs_ptr[3] << 24));
-
-		val = cpu_to_le32(val);
-
-		wl12xx_debug(DEBUG_BOOT,
-			     "nvs write table 0x%x: 0x%x",
-			     nvs_start, val);
-		wl12xx_mem_write32(wl, nvs_start, val);
-
-		nvs_ptr += 4;
-		nvs_bytes_written += 4;
-		nvs_start += 4;
-	}
-
-	return 0;
-}
-
-static int wl1251_boot(struct wl12xx *wl)
-{
-	int ret = 0, minor_minor_e2_ver;
-	u32 tmp, boot_data;
-
-	ret = wl12xx_boot_soft_reset(wl);
-	if (ret < 0)
-		goto out;
-
-	/* 2. start processing NVS file */
-	ret = wl->chip.op_upload_nvs(wl);
-	if (ret < 0)
-		goto out;
-
-	/* write firmware's last address (ie. it's length) to
-	 * ACX_EEPROMLESS_IND_REG */
-	wl12xx_reg_write32(wl, ACX_EEPROMLESS_IND_REG, wl->fw_len);
-
-	/* 6. read the EEPROM parameters */
-	tmp = wl12xx_reg_read32(wl, SCR_PAD2);
-
-	/* 7. read bootdata */
-	wl->boot_attr.radio_type = (tmp & 0x0000FF00) >> 8;
-	wl->boot_attr.major = (tmp & 0x00FF0000) >> 16;
-	tmp = wl12xx_reg_read32(wl, SCR_PAD3);
-
-	/* 8. check bootdata and call restart sequence */
-	wl->boot_attr.minor = (tmp & 0x00FF0000) >> 16;
-	minor_minor_e2_ver = (tmp & 0xFF000000) >> 24;
-
-	wl12xx_debug(DEBUG_BOOT, "radioType 0x%x majorE2Ver 0x%x "
-		     "minorE2Ver 0x%x minor_minor_e2_ver 0x%x",
-		     wl->boot_attr.radio_type, wl->boot_attr.major,
-		     wl->boot_attr.minor, minor_minor_e2_ver);
-
-	ret = wl12xx_boot_init_seq(wl);
-	if (ret < 0)
-		goto out;
-
-	/* 9. NVS processing done */
-	boot_data = wl12xx_reg_read32(wl, ACX_REG_ECPU_CONTROL);
-
-	wl12xx_debug(DEBUG_BOOT, "halt boot_data 0x%x", boot_data);
-
-	/* 10. check that ECPU_CONTROL_HALT bits are set in
-	 * pWhalBus->uBootData and start uploading firmware
-	 */
-	if ((boot_data & ECPU_CONTROL_HALT) == 0) {
-		wl12xx_error("boot failed, ECPU_CONTROL_HALT not set");
-		ret = -EIO;
-		goto out;
-	}
-
-	ret = wl->chip.op_upload_fw(wl);
-	if (ret < 0)
-		goto out;
-
-	/* 10.5 start firmware */
-	ret = wl12xx_boot_run_firmware(wl);
-	if (ret < 0)
-		goto out;
-
-	/* Get and save the firmware version */
-	wl12xx_acx_fw_version(wl, wl->chip.fw_ver, sizeof(wl->chip.fw_ver));
-
-out:
-	return ret;
-}
-
-static int wl1251_mem_cfg(struct wl12xx *wl)
-{
-	struct wl1251_acx_config_memory mem_conf;
-	int ret, i;
-
-	wl12xx_debug(DEBUG_ACX, "wl1251 mem cfg");
-
-	/* memory config */
-	mem_conf.mem_config.num_stations = cpu_to_le16(DEFAULT_NUM_STATIONS);
-	mem_conf.mem_config.rx_mem_block_num = 35;
-	mem_conf.mem_config.tx_min_mem_block_num = 64;
-	mem_conf.mem_config.num_tx_queues = MAX_TX_QUEUES;
-	mem_conf.mem_config.host_if_options = HOSTIF_PKT_RING;
-	mem_conf.mem_config.num_ssid_profiles = 1;
-	mem_conf.mem_config.debug_buffer_size =
-		cpu_to_le16(TRACE_BUFFER_MAX_SIZE);
-
-	/* RX queue config */
-	mem_conf.rx_queue_config.dma_address = 0;
-	mem_conf.rx_queue_config.num_descs = ACX_RX_DESC_DEF;
-	mem_conf.rx_queue_config.priority = DEFAULT_RXQ_PRIORITY;
-	mem_conf.rx_queue_config.type = DEFAULT_RXQ_TYPE;
-
-	/* TX queue config */
-	for (i = 0; i < MAX_TX_QUEUES; i++) {
-		mem_conf.tx_queue_config[i].num_descs = ACX_TX_DESC_DEF;
-		mem_conf.tx_queue_config[i].attributes = i;
-	}
-
-	mem_conf.header.id = ACX_MEM_CFG;
-	mem_conf.header.len = sizeof(struct wl1251_acx_config_memory) -
-		sizeof(struct acx_header);
-	mem_conf.header.len -=
-		(MAX_TX_QUEUE_CONFIGS - mem_conf.mem_config.num_tx_queues) *
-		sizeof(struct wl1251_acx_tx_queue_config);
-
-	ret = wl12xx_cmd_configure(wl, &mem_conf,
-				   sizeof(struct wl1251_acx_config_memory));
-	if (ret < 0)
-		wl12xx_warning("wl1251 mem config failed: %d", ret);
-
-	return ret;
-}
-
-static int wl1251_hw_init_mem_config(struct wl12xx *wl)
-{
-	int ret;
-
-	ret = wl1251_mem_cfg(wl);
-	if (ret < 0)
-		return ret;
-
-	wl->target_mem_map = kzalloc(sizeof(struct wl1251_acx_mem_map),
-					  GFP_KERNEL);
-	if (!wl->target_mem_map) {
-		wl12xx_error("couldn't allocate target memory map");
-		return -ENOMEM;
-	}
-
-	/* we now ask for the firmware built memory map */
-	ret = wl12xx_acx_mem_map(wl, wl->target_mem_map,
-				 sizeof(struct wl1251_acx_mem_map));
-	if (ret < 0) {
-		wl12xx_error("couldn't retrieve firmware memory map");
-		kfree(wl->target_mem_map);
-		wl->target_mem_map = NULL;
-		return ret;
-	}
-
-	return 0;
-}
-
-static void wl1251_set_ecpu_ctrl(struct wl12xx *wl, u32 flag)
-{
-	u32 cpu_ctrl;
-
-	/* 10.5.0 run the firmware (I) */
-	cpu_ctrl = wl12xx_reg_read32(wl, ACX_REG_ECPU_CONTROL);
-
-	/* 10.5.1 run the firmware (II) */
-	cpu_ctrl &= ~flag;
-	wl12xx_reg_write32(wl, ACX_REG_ECPU_CONTROL, cpu_ctrl);
-}
-
-static void wl1251_target_enable_interrupts(struct wl12xx *wl)
-{
-	/* Enable target's interrupts */
-	wl->intr_mask = WL1251_ACX_INTR_RX0_DATA |
-		WL1251_ACX_INTR_RX1_DATA |
-		WL1251_ACX_INTR_TX_RESULT |
-		WL1251_ACX_INTR_EVENT_A |
-		WL1251_ACX_INTR_EVENT_B |
-		WL1251_ACX_INTR_INIT_COMPLETE;
-	wl12xx_boot_target_enable_interrupts(wl);
-}
-
-static void wl1251_irq_work(struct work_struct *work)
-{
-	u32 intr;
-	struct wl12xx *wl =
-		container_of(work, struct wl12xx, irq_work);
-
-	mutex_lock(&wl->mutex);
-
-	wl12xx_debug(DEBUG_IRQ, "IRQ work");
-
-	if (wl->state == WL12XX_STATE_OFF)
-		goto out;
-
-	wl12xx_ps_elp_wakeup(wl);
-
-	wl12xx_reg_write32(wl, ACX_REG_INTERRUPT_MASK, WL1251_ACX_INTR_ALL);
-
-	intr = wl12xx_reg_read32(wl, ACX_REG_INTERRUPT_CLEAR);
-	wl12xx_debug(DEBUG_IRQ, "intr: 0x%x", intr);
-
-	if (wl->data_path) {
-		wl12xx_spi_mem_read(wl, wl->data_path->rx_control_addr,
-				    &wl->rx_counter, sizeof(u32));
-
-		/* We handle a frmware bug here */
-		switch ((wl->rx_counter - wl->rx_handled) & 0xf) {
-		case 0:
-			wl12xx_debug(DEBUG_IRQ, "RX: FW and host in sync");
-			intr &= ~WL1251_ACX_INTR_RX0_DATA;
-			intr &= ~WL1251_ACX_INTR_RX1_DATA;
-			break;
-		case 1:
-			wl12xx_debug(DEBUG_IRQ, "RX: FW +1");
-			intr |= WL1251_ACX_INTR_RX0_DATA;
-			intr &= ~WL1251_ACX_INTR_RX1_DATA;
-			break;
-		case 2:
-			wl12xx_debug(DEBUG_IRQ, "RX: FW +2");
-			intr |= WL1251_ACX_INTR_RX0_DATA;
-			intr |= WL1251_ACX_INTR_RX1_DATA;
-			break;
-		default:
-			wl12xx_warning("RX: FW and host out of sync: %d",
-				       wl->rx_counter - wl->rx_handled);
-			break;
-		}
-
-		wl->rx_handled = wl->rx_counter;
-
-
-		wl12xx_debug(DEBUG_IRQ, "RX counter: %d", wl->rx_counter);
-	}
-
-	intr &= wl->intr_mask;
-
-	if (intr == 0) {
-		wl12xx_debug(DEBUG_IRQ, "INTR is 0");
-		wl12xx_reg_write32(wl, ACX_REG_INTERRUPT_MASK,
-				   ~(wl->intr_mask));
-
-		goto out_sleep;
-	}
-
-	if (intr & WL1251_ACX_INTR_RX0_DATA) {
-		wl12xx_debug(DEBUG_IRQ, "WL1251_ACX_INTR_RX0_DATA");
-		wl12xx_rx(wl);
-	}
-
-	if (intr & WL1251_ACX_INTR_RX1_DATA) {
-		wl12xx_debug(DEBUG_IRQ, "WL1251_ACX_INTR_RX1_DATA");
-		wl12xx_rx(wl);
-	}
-
-	if (intr & WL1251_ACX_INTR_TX_RESULT) {
-		wl12xx_debug(DEBUG_IRQ, "WL1251_ACX_INTR_TX_RESULT");
-		wl12xx_tx_complete(wl);
-	}
-
-	if (intr & (WL1251_ACX_INTR_EVENT_A | WL1251_ACX_INTR_EVENT_B)) {
-		wl12xx_debug(DEBUG_IRQ, "WL1251_ACX_INTR_EVENT (0x%x)", intr);
-		if (intr & WL1251_ACX_INTR_EVENT_A)
-			wl12xx_event_handle(wl, 0);
-		else
-			wl12xx_event_handle(wl, 1);
-	}
-
-	if (intr & WL1251_ACX_INTR_INIT_COMPLETE)
-		wl12xx_debug(DEBUG_IRQ, "WL1251_ACX_INTR_INIT_COMPLETE");
-
-	wl12xx_reg_write32(wl, ACX_REG_INTERRUPT_MASK, ~(wl->intr_mask));
-
-out_sleep:
-	wl12xx_ps_elp_sleep(wl);
-out:
-	mutex_unlock(&wl->mutex);
-}
-
-static int wl1251_hw_init_txq_fill(u8 qid,
-				   struct acx_tx_queue_qos_config *config,
-				   u32 num_blocks)
-{
-	config->qid = qid;
-
-	switch (qid) {
-	case QOS_AC_BE:
-		config->high_threshold =
-			(QOS_TX_HIGH_BE_DEF * num_blocks) / 100;
-		config->low_threshold =
-			(QOS_TX_LOW_BE_DEF * num_blocks) / 100;
-		break;
-	case QOS_AC_BK:
-		config->high_threshold =
-			(QOS_TX_HIGH_BK_DEF * num_blocks) / 100;
-		config->low_threshold =
-			(QOS_TX_LOW_BK_DEF * num_blocks) / 100;
-		break;
-	case QOS_AC_VI:
-		config->high_threshold =
-			(QOS_TX_HIGH_VI_DEF * num_blocks) / 100;
-		config->low_threshold =
-			(QOS_TX_LOW_VI_DEF * num_blocks) / 100;
-		break;
-	case QOS_AC_VO:
-		config->high_threshold =
-			(QOS_TX_HIGH_VO_DEF * num_blocks) / 100;
-		config->low_threshold =
-			(QOS_TX_LOW_VO_DEF * num_blocks) / 100;
-		break;
-	default:
-		wl12xx_error("Invalid TX queue id: %d", qid);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int wl1251_hw_init_tx_queue_config(struct wl12xx *wl)
-{
-	struct acx_tx_queue_qos_config config;
-	struct wl1251_acx_mem_map *wl_mem_map = wl->target_mem_map;
-	int ret, i;
-
-	wl12xx_debug(DEBUG_ACX, "acx tx queue config");
-
-	config.header.id = ACX_TX_QUEUE_CFG;
-	config.header.len = sizeof(struct acx_tx_queue_qos_config) -
-		sizeof(struct acx_header);
-
-	for (i = 0; i < MAX_NUM_OF_AC; i++) {
-		ret = wl1251_hw_init_txq_fill(i, &config,
-					      wl_mem_map->num_tx_mem_blocks);
-		if (ret < 0)
-			return ret;
-
-		ret = wl12xx_cmd_configure(wl, &config, sizeof(config));
-		if (ret < 0)
-			return ret;
-	}
-
-	return 0;
-}
-
-static int wl1251_hw_init_data_path_config(struct wl12xx *wl)
-{
-	int ret;
-
-	/* asking for the data path parameters */
-	wl->data_path = kzalloc(sizeof(struct acx_data_path_params_resp),
-				GFP_KERNEL);
-	if (!wl->data_path) {
-		wl12xx_error("Couldnt allocate data path parameters");
-		return -ENOMEM;
-	}
-
-	ret = wl12xx_acx_data_path_params(wl, wl->data_path);
-	if (ret < 0) {
-		kfree(wl->data_path);
-		wl->data_path = NULL;
-		return ret;
-	}
-
-	return 0;
-}
-
-static int wl1251_hw_init(struct wl12xx *wl)
-{
-	struct wl1251_acx_mem_map *wl_mem_map;
-	int ret;
-
-	ret = wl12xx_hw_init_hwenc_config(wl);
-	if (ret < 0)
-		return ret;
-
-	/* Template settings */
-	ret = wl12xx_hw_init_templates_config(wl);
-	if (ret < 0)
-		return ret;
-
-	/* Default memory configuration */
-	ret = wl1251_hw_init_mem_config(wl);
-	if (ret < 0)
-		return ret;
-
-	/* Default data path configuration  */
-	ret = wl1251_hw_init_data_path_config(wl);
-	if (ret < 0)
-		goto out_free_memmap;
-
-	/* RX config */
-	ret = wl12xx_hw_init_rx_config(wl,
-				       RX_CFG_PROMISCUOUS | RX_CFG_TSF,
-				       RX_FILTER_OPTION_DEF);
-	/* RX_CONFIG_OPTION_ANY_DST_ANY_BSS,
-	   RX_FILTER_OPTION_FILTER_ALL); */
-	if (ret < 0)
-		goto out_free_data_path;
-
-	/* TX queues config */
-	ret = wl1251_hw_init_tx_queue_config(wl);
-	if (ret < 0)
-		goto out_free_data_path;
-
-	/* PHY layer config */
-	ret = wl12xx_hw_init_phy_config(wl);
-	if (ret < 0)
-		goto out_free_data_path;
-
-	/* Beacon filtering */
-	ret = wl12xx_hw_init_beacon_filter(wl);
-	if (ret < 0)
-		goto out_free_data_path;
-
-	/* Bluetooth WLAN coexistence */
-	ret = wl12xx_hw_init_pta(wl);
-	if (ret < 0)
-		goto out_free_data_path;
-
-	/* Energy detection */
-	ret = wl12xx_hw_init_energy_detection(wl);
-	if (ret < 0)
-		goto out_free_data_path;
-
-	/* Beacons and boradcast settings */
-	ret = wl12xx_hw_init_beacon_broadcast(wl);
-	if (ret < 0)
-		goto out_free_data_path;
-
-	/* Enable data path */
-	ret = wl12xx_cmd_data_path(wl, wl->channel, 1);
-	if (ret < 0)
-		goto out_free_data_path;
-
-	/* Default power state */
-	ret = wl12xx_hw_init_power_auth(wl);
-	if (ret < 0)
-		goto out_free_data_path;
-
-	wl_mem_map = wl->target_mem_map;
-	wl12xx_info("%d tx blocks at 0x%x, %d rx blocks at 0x%x",
-		    wl_mem_map->num_tx_mem_blocks,
-		    wl->data_path->tx_control_addr,
-		    wl_mem_map->num_rx_mem_blocks,
-		    wl->data_path->rx_control_addr);
-
-	return 0;
-
- out_free_data_path:
-	kfree(wl->data_path);
-
- out_free_memmap:
-	kfree(wl->target_mem_map);
-
-	return ret;
-}
-
-static int wl1251_plt_init(struct wl12xx *wl)
-{
-	int ret;
-
-	ret = wl1251_hw_init_mem_config(wl);
-	if (ret < 0)
-		return ret;
-
-	ret = wl12xx_cmd_data_path(wl, wl->channel, 1);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-void wl1251_setup(struct wl12xx *wl)
-{
-	/* FIXME: Is it better to use strncpy here or is this ok? */
-	wl->chip.fw_filename = WL1251_FW_NAME;
-	wl->chip.nvs_filename = WL1251_NVS_NAME;
-
-	/* Now we know what chip we're using, so adjust the power on sleep
-	 * time accordingly */
-	wl->chip.power_on_sleep = WL1251_POWER_ON_SLEEP;
-
-	wl->chip.intr_cmd_complete = WL1251_ACX_INTR_CMD_COMPLETE;
-	wl->chip.intr_init_complete = WL1251_ACX_INTR_INIT_COMPLETE;
-
-	wl->chip.op_upload_nvs = wl1251_upload_nvs;
-	wl->chip.op_upload_fw = wl1251_upload_firmware;
-	wl->chip.op_boot = wl1251_boot;
-	wl->chip.op_set_ecpu_ctrl = wl1251_set_ecpu_ctrl;
-	wl->chip.op_target_enable_interrupts = wl1251_target_enable_interrupts;
-	wl->chip.op_hw_init = wl1251_hw_init;
-	wl->chip.op_plt_init = wl1251_plt_init;
-
-	wl->chip.p_table = wl1251_part_table;
-	wl->chip.acx_reg_table = wl1251_acx_reg_table;
-
-	INIT_WORK(&wl->irq_work, wl1251_irq_work);
-}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_cmd.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_cmd.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_cmd.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_cmd.c	2012-12-16 13:13:01.680330145 +0100
@@ -0,0 +1,412 @@
+#include "wl1251_cmd.h"
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/crc7.h>
+#include <linux/spi/spi.h>
+
+#include "wl1251.h"
+#include "wl1251_reg.h"
+#include "wl1251_spi.h"
+#include "wl1251_ps.h"
+#include "wl1251_acx.h"
+
+/**
+ * send command to firmware
+ *
+ * @wl: wl struct
+ * @id: command id
+ * @buf: buffer containing the command, must work with dma
+ * @len: length of the buffer
+ */
+int wl1251_cmd_send(struct wl1251 *wl, u16 id, void *buf, size_t len)
+{
+	struct wl1251_cmd_header *cmd;
+	unsigned long timeout;
+	u32 intr;
+	int ret = 0;
+
+	cmd = buf;
+	cmd->id = id;
+	cmd->status = 0;
+
+	WARN_ON(len % 4 != 0);
+
+	wl1251_spi_mem_write(wl, wl->cmd_box_addr, buf, len);
+
+	wl1251_reg_write32(wl, ACX_REG_INTERRUPT_TRIG, INTR_TRIG_CMD);
+
+	timeout = jiffies + msecs_to_jiffies(WL1251_COMMAND_TIMEOUT);
+
+	intr = wl1251_reg_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);
+	while (!(intr & WL1251_ACX_INTR_CMD_COMPLETE)) {
+		if (time_after(jiffies, timeout)) {
+			wl1251_error("command complete timeout");
+			ret = -ETIMEDOUT;
+			goto out;
+		}
+
+		msleep(1);
+
+		intr = wl1251_reg_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);
+	}
+
+	wl1251_reg_write32(wl, ACX_REG_INTERRUPT_ACK,
+			   WL1251_ACX_INTR_CMD_COMPLETE);
+
+out:
+	return ret;
+}
+
+/**
+ * send test command to firmware
+ *
+ * @wl: wl struct
+ * @buf: buffer containing the command, with all headers, must work with dma
+ * @len: length of the buffer
+ * @answer: is answer needed
+ */
+int wl1251_cmd_test(struct wl1251 *wl, void *buf, size_t buf_len, u8 answer)
+{
+	int ret;
+
+	wl1251_debug(DEBUG_CMD, "cmd test");
+
+	ret = wl1251_cmd_send(wl, CMD_TEST, buf, buf_len);
+
+	if (ret < 0) {
+		wl1251_warning("TEST command failed");
+		return ret;
+	}
+
+	if (answer) {
+		struct wl1251_command *cmd_answer;
+
+		/*
+		 * The test command got in, we can read the answer.
+		 * The answer would be a wl1251_command, where the
+		 * parameter array contains the actual answer.
+		 */
+		wl1251_spi_mem_read(wl, wl->cmd_box_addr, buf, buf_len);
+
+		cmd_answer = buf;
+
+		if (cmd_answer->header.status != CMD_STATUS_SUCCESS)
+			wl1251_error("TEST command answer error: %d",
+				     cmd_answer->header.status);
+	}
+
+	return 0;
+}
+
+/**
+ * read acx from firmware
+ *
+ * @wl: wl struct
+ * @id: acx id
+ * @buf: buffer for the response, including all headers, must work with dma
+ * @len: lenght of buf
+ */
+int wl1251_cmd_interrogate(struct wl1251 *wl, u16 id, void *buf, size_t len)
+{
+	struct acx_header *acx = buf;
+	int ret;
+
+	wl1251_debug(DEBUG_CMD, "cmd interrogate");
+
+	acx->id = id;
+
+	/* payload length, does not include any headers */
+	acx->len = len - sizeof(*acx);
+
+	ret = wl1251_cmd_send(wl, CMD_INTERROGATE, acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1251_error("INTERROGATE command failed");
+		goto out;
+	}
+
+	/* the interrogate command got in, we can read the answer */
+	wl1251_spi_mem_read(wl, wl->cmd_box_addr, buf, len);
+
+	acx = buf;
+	if (acx->cmd.status != CMD_STATUS_SUCCESS)
+		wl1251_error("INTERROGATE command error: %d",
+			     acx->cmd.status);
+
+out:
+	return ret;
+}
+
+/**
+ * write acx value to firmware
+ *
+ * @wl: wl struct
+ * @id: acx id
+ * @buf: buffer containing acx, including all headers, must work with dma
+ * @len: length of buf
+ */
+int wl1251_cmd_configure(struct wl1251 *wl, u16 id, void *buf, size_t len)
+{
+	struct acx_header *acx = buf;
+	int ret;
+
+	wl1251_debug(DEBUG_CMD, "cmd configure");
+
+	acx->id = id;
+
+	/* payload length, does not include any headers */
+	acx->len = len - sizeof(*acx);
+
+	ret = wl1251_cmd_send(wl, CMD_CONFIGURE, acx, len);
+	if (ret < 0) {
+		wl1251_warning("CONFIGURE command NOK");
+		return ret;
+	}
+
+	return 0;
+}
+
+int wl1251_cmd_vbm(struct wl1251 *wl, u8 identity,
+		   void *bitmap, u16 bitmap_len, u8 bitmap_control)
+{
+	struct wl1251_cmd_vbm_update *vbm;
+	int ret;
+
+	wl1251_debug(DEBUG_CMD, "cmd vbm");
+
+	vbm = kzalloc(sizeof(*vbm), GFP_KERNEL);
+	if (!vbm) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* Count and period will be filled by the target */
+	vbm->tim.bitmap_ctrl = bitmap_control;
+	if (bitmap_len > PARTIAL_VBM_MAX) {
+		wl1251_warning("cmd vbm len is %d B, truncating to %d",
+			       bitmap_len, PARTIAL_VBM_MAX);
+		bitmap_len = PARTIAL_VBM_MAX;
+	}
+	memcpy(vbm->tim.pvb_field, bitmap, bitmap_len);
+	vbm->tim.identity = identity;
+	vbm->tim.length = bitmap_len + 3;
+
+	vbm->len = cpu_to_le16(bitmap_len + 5);
+
+	ret = wl1251_cmd_send(wl, CMD_VBM, vbm, sizeof(*vbm));
+	if (ret < 0) {
+		wl1251_error("VBM command failed");
+		goto out;
+	}
+
+out:
+	kfree(vbm);
+	return 0;
+}
+
+int wl1251_cmd_data_path(struct wl1251 *wl, u8 channel, bool enable)
+{
+	struct cmd_enabledisable_path *cmd;
+	int ret;
+	u16 cmd_rx, cmd_tx;
+
+	wl1251_debug(DEBUG_CMD, "cmd data path");
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (!cmd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	cmd->channel = channel;
+
+	if (enable) {
+		cmd_rx = CMD_ENABLE_RX;
+		cmd_tx = CMD_ENABLE_TX;
+	} else {
+		cmd_rx = CMD_DISABLE_RX;
+		cmd_tx = CMD_DISABLE_TX;
+	}
+
+	ret = wl1251_cmd_send(wl, cmd_rx, cmd, sizeof(*cmd));
+	if (ret < 0) {
+		wl1251_error("rx %s cmd for channel %d failed",
+			     enable ? "start" : "stop", channel);
+		goto out;
+	}
+
+	wl1251_debug(DEBUG_BOOT, "rx %s cmd channel %d",
+		     enable ? "start" : "stop", channel);
+
+	ret = wl1251_cmd_send(wl, cmd_tx, cmd, sizeof(*cmd));
+	if (ret < 0) {
+		wl1251_error("tx %s cmd for channel %d failed",
+			     enable ? "start" : "stop", channel);
+		return ret;
+	}
+
+	wl1251_debug(DEBUG_BOOT, "tx %s cmd channel %d",
+		     enable ? "start" : "stop", channel);
+
+out:
+	kfree(cmd);
+	return ret;
+}
+
+int wl1251_cmd_join(struct wl1251 *wl, u8 bss_type, u8 channel,
+		    u16 beacon_interval, u8 dtim_interval)
+{
+	struct cmd_join *join;
+	int ret, i;
+	u8 *bssid;
+
+	join = kzalloc(sizeof(*join), GFP_KERNEL);
+	if (!join) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	wl1251_debug(DEBUG_CMD, "cmd join%s ch %d %d/%d",
+		     bss_type == BSS_TYPE_IBSS ? " ibss" : "",
+		     channel, beacon_interval, dtim_interval);
+
+	/* Reverse order BSSID */
+	bssid = (u8 *) &join->bssid_lsb;
+	for (i = 0; i < ETH_ALEN; i++)
+		bssid[i] = wl->bssid[ETH_ALEN - i - 1];
+
+	join->rx_config_options = wl->rx_config;
+	join->rx_filter_options = wl->rx_filter;
+
+	join->basic_rate_set = RATE_MASK_1MBPS | RATE_MASK_2MBPS |
+		RATE_MASK_5_5MBPS | RATE_MASK_11MBPS;
+
+	join->beacon_interval = beacon_interval;
+	join->dtim_interval = dtim_interval;
+	join->bss_type = bss_type;
+	join->channel = channel;
+	join->ssid_len = wl->ssid_len;
+	memcpy(join->ssid, wl->ssid, wl->ssid_len);
+	join->ctrl = JOIN_CMD_CTRL_TX_FLUSH;
+
+	/* increment the session counter */
+	wl->session_counter++;
+	if (wl->session_counter >= SESSION_COUNTER_MAX)
+		wl->session_counter = 0;
+
+	ret = wl1251_cmd_send(wl, CMD_START_JOIN, join, sizeof(*join));
+	if (ret < 0) {
+		wl1251_error("failed to initiate cmd join");
+		goto out;
+	}
+
+out:
+	kfree(join);
+	return ret;
+}
+
+int wl1251_cmd_ps_mode(struct wl1251 *wl, u8 ps_mode)
+{
+	struct wl1251_cmd_ps_params *ps_params = NULL;
+	int ret = 0;
+
+	wl1251_debug(DEBUG_CMD, "cmd set ps mode");
+
+	ps_params = kzalloc(sizeof(*ps_params), GFP_KERNEL);
+	if (!ps_params) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ps_params->ps_mode = ps_mode;
+	ps_params->send_null_data = 1;
+	ps_params->retries = 5;
+	ps_params->hang_over_period = 128;
+	ps_params->null_data_rate = 1; /* 1 Mbps */
+
+	ret = wl1251_cmd_send(wl, CMD_SET_PS_MODE, ps_params,
+			      sizeof(*ps_params));
+	if (ret < 0) {
+		wl1251_error("cmd set_ps_mode failed");
+		goto out;
+	}
+
+out:
+	kfree(ps_params);
+	return ret;
+}
+
+int wl1251_cmd_read_memory(struct wl1251 *wl, u32 addr, void *answer,
+			   size_t len)
+{
+	struct cmd_read_write_memory *cmd;
+	int ret = 0;
+
+	wl1251_debug(DEBUG_CMD, "cmd read memory");
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (!cmd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	WARN_ON(len > MAX_READ_SIZE);
+	len = min_t(size_t, len, MAX_READ_SIZE);
+
+	cmd->addr = addr;
+	cmd->size = len;
+
+	ret = wl1251_cmd_send(wl, CMD_READ_MEMORY, cmd, sizeof(*cmd));
+	if (ret < 0) {
+		wl1251_error("read memory command failed: %d", ret);
+		goto out;
+	}
+
+	/* the read command got in, we can now read the answer */
+	wl1251_spi_mem_read(wl, wl->cmd_box_addr, cmd, sizeof(*cmd));
+
+	if (cmd->header.status != CMD_STATUS_SUCCESS)
+		wl1251_error("error in read command result: %d",
+			     cmd->header.status);
+
+	memcpy(answer, cmd->value, len);
+
+out:
+	kfree(cmd);
+	return ret;
+}
+
+int wl1251_cmd_template_set(struct wl1251 *wl, u16 cmd_id,
+			    void *buf, size_t buf_len)
+{
+	struct wl1251_cmd_packet_template *cmd;
+	size_t cmd_len;
+	int ret = 0;
+
+	wl1251_debug(DEBUG_CMD, "cmd template %d", cmd_id);
+
+	WARN_ON(buf_len > WL1251_MAX_TEMPLATE_SIZE);
+	buf_len = min_t(size_t, buf_len, WL1251_MAX_TEMPLATE_SIZE);
+	cmd_len = ALIGN(sizeof(*cmd) + buf_len, 4);
+
+	cmd = kzalloc(cmd_len, GFP_KERNEL);
+	if (!cmd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	cmd->size = cpu_to_le16(buf_len);
+
+	if (buf)
+		memcpy(cmd->data, buf, buf_len);
+
+	ret = wl1251_cmd_send(wl, cmd_id, cmd, cmd_len);
+	if (ret < 0) {
+		wl1251_warning("cmd set_template failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(cmd);
+	return ret;
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_cmd.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_cmd.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_cmd.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_cmd.h	2012-12-16 13:13:01.680330145 +0100
@@ -0,0 +1,407 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __WL1251_CMD_H__
+#define __WL1251_CMD_H__
+
+#include "wl1251.h"
+
+struct acx_header;
+
+int wl1251_cmd_send(struct wl1251 *wl, u16 type, void *buf, size_t buf_len);
+int wl1251_cmd_test(struct wl1251 *wl, void *buf, size_t buf_len, u8 answer);
+int wl1251_cmd_interrogate(struct wl1251 *wl, u16 id, void *buf, size_t len);
+int wl1251_cmd_configure(struct wl1251 *wl, u16 id, void *buf, size_t len);
+int wl1251_cmd_vbm(struct wl1251 *wl, u8 identity,
+		   void *bitmap, u16 bitmap_len, u8 bitmap_control);
+int wl1251_cmd_data_path(struct wl1251 *wl, u8 channel, bool enable);
+int wl1251_cmd_join(struct wl1251 *wl, u8 bss_type, u8 channel,
+		    u16 beacon_interval, u8 dtim_interval);
+int wl1251_cmd_ps_mode(struct wl1251 *wl, u8 ps_mode);
+int wl1251_cmd_read_memory(struct wl1251 *wl, u32 addr, void *answer,
+			   size_t len);
+int wl1251_cmd_template_set(struct wl1251 *wl, u16 cmd_id,
+			    void *buf, size_t buf_len);
+
+/* unit ms */
+#define WL1251_COMMAND_TIMEOUT 2000
+
+enum wl1251_commands {
+	CMD_RESET           = 0,
+	CMD_INTERROGATE     = 1,    /*use this to read information elements*/
+	CMD_CONFIGURE       = 2,    /*use this to write information elements*/
+	CMD_ENABLE_RX       = 3,
+	CMD_ENABLE_TX       = 4,
+	CMD_DISABLE_RX      = 5,
+	CMD_DISABLE_TX      = 6,
+	CMD_SCAN            = 8,
+	CMD_STOP_SCAN       = 9,
+	CMD_VBM             = 10,
+	CMD_START_JOIN      = 11,
+	CMD_SET_KEYS        = 12,
+	CMD_READ_MEMORY     = 13,
+	CMD_WRITE_MEMORY    = 14,
+	CMD_BEACON          = 19,
+	CMD_PROBE_RESP      = 20,
+	CMD_NULL_DATA       = 21,
+	CMD_PROBE_REQ       = 22,
+	CMD_TEST            = 23,
+	CMD_RADIO_CALIBRATE     = 25,   /* OBSOLETE */
+	CMD_ENABLE_RX_PATH      = 27,   /* OBSOLETE */
+	CMD_NOISE_HIST      = 28,
+	CMD_RX_RESET        = 29,
+	CMD_PS_POLL         = 30,
+	CMD_QOS_NULL_DATA   = 31,
+	CMD_LNA_CONTROL     = 32,
+	CMD_SET_BCN_MODE    = 33,
+	CMD_MEASUREMENT      = 34,
+	CMD_STOP_MEASUREMENT = 35,
+	CMD_DISCONNECT       = 36,
+	CMD_SET_PS_MODE      = 37,
+	CMD_CHANNEL_SWITCH   = 38,
+	CMD_STOP_CHANNEL_SWICTH = 39,
+	CMD_AP_DISCOVERY     = 40,
+	CMD_STOP_AP_DISCOVERY = 41,
+	CMD_SPS_SCAN = 42,
+	CMD_STOP_SPS_SCAN = 43,
+	CMD_HEALTH_CHECK     = 45,
+	CMD_DEBUG            = 46,
+	CMD_TRIGGER_SCAN_TO  = 47,
+
+	NUM_COMMANDS,
+	MAX_COMMAND_ID = 0xFFFF,
+};
+
+#define MAX_CMD_PARAMS 572
+
+struct wl1251_cmd_header {
+	u16 id;
+	u16 status;
+	/* payload */
+	u8 data[0];
+} __attribute__ ((packed));
+
+struct  wl1251_command {
+	struct wl1251_cmd_header header;
+	u8  parameters[MAX_CMD_PARAMS];
+};
+
+enum {
+	CMD_MAILBOX_IDLE              		=  0,
+	CMD_STATUS_SUCCESS            		=  1,
+	CMD_STATUS_UNKNOWN_CMD        		=  2,
+	CMD_STATUS_UNKNOWN_IE         		=  3,
+	CMD_STATUS_REJECT_MEAS_SG_ACTIVE 	= 11,
+	CMD_STATUS_RX_BUSY            		= 13,
+	CMD_STATUS_INVALID_PARAM      		= 14,
+	CMD_STATUS_TEMPLATE_TOO_LARGE 		= 15,
+	CMD_STATUS_OUT_OF_MEMORY      		= 16,
+	CMD_STATUS_STA_TABLE_FULL     		= 17,
+	CMD_STATUS_RADIO_ERROR        		= 18,
+	CMD_STATUS_WRONG_NESTING      		= 19,
+	CMD_STATUS_TIMEOUT            		= 21, /* Driver internal use.*/
+	CMD_STATUS_FW_RESET           		= 22, /* Driver internal use.*/
+	MAX_COMMAND_STATUS            		= 0xff
+};
+
+
+/*
+ * CMD_READ_MEMORY
+ *
+ * The host issues this command to read the WiLink device memory/registers.
+ *
+ * Note: The Base Band address has special handling (16 bits registers and
+ * addresses). For more information, see the hardware specification.
+ */
+/*
+ * CMD_WRITE_MEMORY
+ *
+ * The host issues this command to write the WiLink device memory/registers.
+ *
+ * The Base Band address has special handling (16 bits registers and
+ * addresses). For more information, see the hardware specification.
+ */
+#define MAX_READ_SIZE 256
+
+struct cmd_read_write_memory {
+	struct wl1251_cmd_header header;
+
+	/* The address of the memory to read from or write to.*/
+	u32 addr;
+
+	/* The amount of data in bytes to read from or write to the WiLink
+	 * device.*/
+	u32 size;
+
+	/* The actual value read from or written to the Wilink. The source
+	   of this field is the Host in WRITE command or the Wilink in READ
+	   command. */
+	u8 value[MAX_READ_SIZE];
+};
+
+#define CMDMBOX_HEADER_LEN 4
+#define CMDMBOX_INFO_ELEM_HEADER_LEN 4
+
+
+struct basic_scan_parameters {
+	u32 rx_config_options;
+	u32 rx_filter_options;
+
+	/*
+	 * Scan options:
+	 * bit 0: When this bit is set, passive scan.
+	 * bit 1: Band, when this bit is set we scan
+	 * in the 5Ghz band.
+	 * bit 2: voice mode, 0 for normal scan.
+	 * bit 3: scan priority, 1 for high priority.
+	 */
+	u16 scan_options;
+
+	/* Number of channels to scan */
+	u8 num_channels;
+
+	/* Number opf probe requests to send, per channel */
+	u8 num_probe_requests;
+
+	/* Rate and modulation for probe requests */
+	u16 tx_rate;
+
+	u8 tid_trigger;
+	u8 ssid_len;
+	u32 ssid[8];
+
+} __attribute__ ((packed));
+
+struct basic_scan_channel_parameters {
+	u32 min_duration; /* in TU */
+	u32 max_duration; /* in TU */
+	u32 bssid_lsb;
+	u16 bssid_msb;
+
+	/*
+	 * bits 0-3: Early termination count.
+	 * bits 4-5: Early termination condition.
+	 */
+	u8 early_termination;
+
+	u8 tx_power_att;
+	u8 channel;
+	u8 pad[3];
+} __attribute__ ((packed));
+
+/* SCAN parameters */
+#define SCAN_MAX_NUM_OF_CHANNELS 16
+
+struct cmd_scan {
+	struct wl1251_cmd_header header;
+
+	struct basic_scan_parameters params;
+	struct basic_scan_channel_parameters channels[SCAN_MAX_NUM_OF_CHANNELS];
+} __attribute__ ((packed));
+
+enum {
+	BSS_TYPE_IBSS = 0,
+	BSS_TYPE_STA_BSS = 2,
+	BSS_TYPE_AP_BSS = 3,
+	MAX_BSS_TYPE = 0xFF
+};
+
+#define JOIN_CMD_CTRL_TX_FLUSH             0x80 /* Firmware flushes all Tx */
+#define JOIN_CMD_CTRL_EARLY_WAKEUP_ENABLE  0x01 /* Early wakeup time */
+
+
+struct cmd_join {
+	struct wl1251_cmd_header header;
+
+	u32 bssid_lsb;
+	u16 bssid_msb;
+	u16 beacon_interval; /* in TBTTs */
+	u32 rx_config_options;
+	u32 rx_filter_options;
+
+	/*
+	 * The target uses this field to determine the rate at
+	 * which to transmit control frame responses (such as
+	 * ACK or CTS frames).
+	 */
+	u16 basic_rate_set;
+	u8 dtim_interval;
+	u8 tx_ctrl_frame_rate; /* OBSOLETE */
+	u8 tx_ctrl_frame_mod;  /* OBSOLETE */
+	/*
+	 * bits 0-2: This bitwise field specifies the type
+	 * of BSS to start or join (BSS_TYPE_*).
+	 * bit 4: Band - The radio band in which to join
+	 * or start.
+	 *  0 - 2.4GHz band
+	 *  1 - 5GHz band
+	 * bits 3, 5-7: Reserved
+	 */
+	u8 bss_type;
+	u8 channel;
+	u8 ssid_len;
+	u8 ssid[IW_ESSID_MAX_SIZE];
+	u8 ctrl; /* JOIN_CMD_CTRL_* */
+	u8 tx_mgt_frame_rate; /* OBSOLETE */
+	u8 tx_mgt_frame_mod;  /* OBSOLETE */
+	u8 reserved;
+} __attribute__ ((packed));
+
+struct cmd_enabledisable_path {
+	struct wl1251_cmd_header header;
+
+	u8 channel;
+	u8 padding[3];
+} __attribute__ ((packed));
+
+#define WL1251_MAX_TEMPLATE_SIZE 300
+
+struct wl1251_cmd_packet_template {
+	struct wl1251_cmd_header header;
+
+	__le16 size;
+	u8 data[0];
+} __attribute__ ((packed));
+
+#define TIM_ELE_ID    5
+#define PARTIAL_VBM_MAX    251
+
+struct wl1251_tim {
+	u8 identity;
+	u8 length;
+	u8 dtim_count;
+	u8 dtim_period;
+	u8 bitmap_ctrl;
+	u8 pvb_field[PARTIAL_VBM_MAX]; /* Partial Virtual Bitmap */
+} __attribute__ ((packed));
+
+/* Virtual Bit Map update */
+struct wl1251_cmd_vbm_update {
+	struct wl1251_cmd_header header;
+	__le16 len;
+	u8  padding[2];
+	struct wl1251_tim tim;
+} __attribute__ ((packed));
+
+enum wl1251_cmd_ps_mode {
+	STATION_ACTIVE_MODE,
+	STATION_POWER_SAVE_MODE
+};
+
+struct wl1251_cmd_ps_params {
+	struct wl1251_cmd_header header;
+
+	u8 ps_mode; /* STATION_* */
+	u8 send_null_data; /* Do we have to send NULL data packet ? */
+	u8 retries; /* Number of retires for the initial NULL data packet */
+
+	 /*
+	  * TUs during which the target stays awake after switching
+	  * to power save mode.
+	  */
+	u8 hang_over_period;
+	u16 null_data_rate;
+	u8 pad[2];
+} __attribute__ ((packed));
+
+struct wl1251_cmd_trigger_scan_to {
+	struct wl1251_cmd_header header;
+
+	u32 timeout;
+};
+
+/* HW encryption keys */
+#define NUM_ACCESS_CATEGORIES_COPY 4
+#define MAX_KEY_SIZE 32
+
+/* When set, disable HW encryption */
+#define DF_ENCRYPTION_DISABLE      0x01
+/* When set, disable HW decryption */
+#define DF_SNIFF_MODE_ENABLE       0x80
+
+enum wl1251_cmd_key_action {
+	KEY_ADD_OR_REPLACE = 1,
+	KEY_REMOVE         = 2,
+	KEY_SET_ID         = 3,
+	MAX_KEY_ACTION     = 0xffff,
+};
+
+enum wl1251_cmd_key_type {
+	KEY_WEP_DEFAULT       = 0,
+	KEY_WEP_ADDR          = 1,
+	KEY_AES_GROUP         = 4,
+	KEY_AES_PAIRWISE      = 5,
+	KEY_WEP_GROUP         = 6,
+	KEY_TKIP_MIC_GROUP    = 10,
+	KEY_TKIP_MIC_PAIRWISE = 11,
+};
+
+/*
+ *
+ * key_type_e   key size    key format
+ * ----------   ---------   ----------
+ * 0x00         5, 13, 29   Key data
+ * 0x01         5, 13, 29   Key data
+ * 0x04         16          16 bytes of key data
+ * 0x05         16          16 bytes of key data
+ * 0x0a         32          16 bytes of TKIP key data
+ *                          8 bytes of RX MIC key data
+ *                          8 bytes of TX MIC key data
+ * 0x0b         32          16 bytes of TKIP key data
+ *                          8 bytes of RX MIC key data
+ *                          8 bytes of TX MIC key data
+ *
+ */
+
+struct wl1251_cmd_set_keys {
+	struct wl1251_cmd_header header;
+
+	/* Ignored for default WEP key */
+	u8 addr[ETH_ALEN];
+
+	/* key_action_e */
+	u16 key_action;
+
+	u16 reserved_1;
+
+	/* key size in bytes */
+	u8 key_size;
+
+	/* key_type_e */
+	u8 key_type;
+	u8 ssid_profile;
+
+	/*
+	 * TKIP, AES: frame's key id field.
+	 * For WEP default key: key id;
+	 */
+	u8 id;
+	u8 reserved_2[6];
+	u8 key[MAX_KEY_SIZE];
+	u16 ac_seq_num16[NUM_ACCESS_CATEGORIES_COPY];
+	u32 ac_seq_num32[NUM_ACCESS_CATEGORIES_COPY];
+} __attribute__ ((packed));
+
+
+#endif /* __WL1251_CMD_H__ */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_debugfs.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_debugfs.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_debugfs.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_debugfs.c	2012-12-16 13:13:01.680330145 +0100
@@ -0,0 +1,518 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include "wl1251_debugfs.h"
+
+#include <linux/skbuff.h>
+
+#include "wl1251.h"
+#include "wl1251_acx.h"
+#include "wl1251_ps.h"
+
+/* ms */
+#define WL1251_DEBUGFS_STATS_LIFETIME 1000
+
+/* debugfs macros idea from mac80211 */
+
+#define DEBUGFS_READONLY_FILE(name, buflen, fmt, value...)		\
+static ssize_t name## _read(struct file *file, char __user *userbuf,	\
+			    size_t count, loff_t *ppos)			\
+{									\
+	struct wl1251 *wl = file->private_data;				\
+	char buf[buflen];						\
+	int res;							\
+									\
+	res = scnprintf(buf, buflen, fmt "\n", ##value);		\
+	return simple_read_from_buffer(userbuf, count, ppos, buf, res);	\
+}									\
+									\
+static const struct file_operations name## _ops = {			\
+	.read = name## _read,						\
+	.open = wl1251_open_file_generic,				\
+};
+
+#define DEBUGFS_ADD(name, parent)					\
+	wl->debugfs.name = debugfs_create_file(#name, 0400, parent,	\
+					       wl, &name## _ops);	\
+	if (IS_ERR(wl->debugfs.name)) {					\
+		ret = PTR_ERR(wl->debugfs.name);			\
+		wl->debugfs.name = NULL;				\
+		goto out;						\
+	}
+
+#define DEBUGFS_DEL(name)						\
+	do {								\
+		debugfs_remove(wl->debugfs.name);			\
+		wl->debugfs.name = NULL;				\
+	} while (0)
+
+#define DEBUGFS_FWSTATS_FILE(sub, name, buflen, fmt)			\
+static ssize_t sub## _ ##name## _read(struct file *file,		\
+				      char __user *userbuf,		\
+				      size_t count, loff_t *ppos)	\
+{									\
+	struct wl1251 *wl = file->private_data;				\
+	char buf[buflen];						\
+	int res;							\
+									\
+	wl1251_debugfs_update_stats(wl);				\
+									\
+	res = scnprintf(buf, buflen, fmt "\n",				\
+			wl->stats.fw_stats->sub.name);			\
+	return simple_read_from_buffer(userbuf, count, ppos, buf, res);	\
+}									\
+									\
+static const struct file_operations sub## _ ##name## _ops = {		\
+	.read = sub## _ ##name## _read,					\
+	.open = wl1251_open_file_generic,				\
+};
+
+#define DEBUGFS_FWSTATS_ADD(sub, name)				\
+	DEBUGFS_ADD(sub## _ ##name, wl->debugfs.fw_statistics)
+
+#define DEBUGFS_FWSTATS_DEL(sub, name)				\
+	DEBUGFS_DEL(sub## _ ##name)
+
+static void wl1251_debugfs_update_stats(struct wl1251 *wl)
+{
+	int ret;
+
+	mutex_lock(&wl->mutex);
+
+	ret = wl1251_ps_elp_wakeup(wl);
+	if (ret < 0)
+		goto out;
+
+	if (wl->state == WL1251_STATE_ON &&
+	    time_after(jiffies, wl->stats.fw_stats_update +
+		       msecs_to_jiffies(WL1251_DEBUGFS_STATS_LIFETIME))) {
+		wl1251_acx_statistics(wl, wl->stats.fw_stats);
+		wl->stats.fw_stats_update = jiffies;
+	}
+
+	wl1251_ps_elp_sleep(wl);
+
+out:
+	mutex_unlock(&wl->mutex);
+}
+
+static int wl1251_open_file_generic(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+DEBUGFS_FWSTATS_FILE(tx, internal_desc_overflow, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(rx, out_of_mem, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rx, hdr_overflow, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rx, hw_stuck, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rx, dropped, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rx, fcs_err, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rx, xfr_hint_trig, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rx, path_reset, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rx, reset_counter, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(dma, rx_requested, 20, "%u");
+DEBUGFS_FWSTATS_FILE(dma, rx_errors, 20, "%u");
+DEBUGFS_FWSTATS_FILE(dma, tx_requested, 20, "%u");
+DEBUGFS_FWSTATS_FILE(dma, tx_errors, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(isr, cmd_cmplt, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, fiqs, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, rx_headers, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, rx_mem_overflow, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, rx_rdys, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, irqs, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, tx_procs, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, decrypt_done, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, dma0_done, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, dma1_done, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, tx_exch_complete, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, commands, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, rx_procs, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, hw_pm_mode_changes, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, host_acknowledges, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, pci_pm, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, wakeups, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, low_rssi, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(wep, addr_key_count, 20, "%u");
+DEBUGFS_FWSTATS_FILE(wep, default_key_count, 20, "%u");
+/* skipping wep.reserved */
+DEBUGFS_FWSTATS_FILE(wep, key_not_found, 20, "%u");
+DEBUGFS_FWSTATS_FILE(wep, decrypt_fail, 20, "%u");
+DEBUGFS_FWSTATS_FILE(wep, packets, 20, "%u");
+DEBUGFS_FWSTATS_FILE(wep, interrupt, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(pwr, ps_enter, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, elp_enter, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, missing_bcns, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, wake_on_host, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, wake_on_timer_exp, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, tx_with_ps, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, tx_without_ps, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, rcvd_beacons, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, power_save_off, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, enable_ps, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, disable_ps, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, fix_tsf_ps, 20, "%u");
+/* skipping cont_miss_bcns_spread for now */
+DEBUGFS_FWSTATS_FILE(pwr, rcvd_awake_beacons, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(mic, rx_pkts, 20, "%u");
+DEBUGFS_FWSTATS_FILE(mic, calc_failure, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(aes, encrypt_fail, 20, "%u");
+DEBUGFS_FWSTATS_FILE(aes, decrypt_fail, 20, "%u");
+DEBUGFS_FWSTATS_FILE(aes, encrypt_packets, 20, "%u");
+DEBUGFS_FWSTATS_FILE(aes, decrypt_packets, 20, "%u");
+DEBUGFS_FWSTATS_FILE(aes, encrypt_interrupt, 20, "%u");
+DEBUGFS_FWSTATS_FILE(aes, decrypt_interrupt, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(event, heart_beat, 20, "%u");
+DEBUGFS_FWSTATS_FILE(event, calibration, 20, "%u");
+DEBUGFS_FWSTATS_FILE(event, rx_mismatch, 20, "%u");
+DEBUGFS_FWSTATS_FILE(event, rx_mem_empty, 20, "%u");
+DEBUGFS_FWSTATS_FILE(event, rx_pool, 20, "%u");
+DEBUGFS_FWSTATS_FILE(event, oom_late, 20, "%u");
+DEBUGFS_FWSTATS_FILE(event, phy_transmit_error, 20, "%u");
+DEBUGFS_FWSTATS_FILE(event, tx_stuck, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(ps, pspoll_timeouts, 20, "%u");
+DEBUGFS_FWSTATS_FILE(ps, upsd_timeouts, 20, "%u");
+DEBUGFS_FWSTATS_FILE(ps, upsd_max_sptime, 20, "%u");
+DEBUGFS_FWSTATS_FILE(ps, upsd_max_apturn, 20, "%u");
+DEBUGFS_FWSTATS_FILE(ps, pspoll_max_apturn, 20, "%u");
+DEBUGFS_FWSTATS_FILE(ps, pspoll_utilization, 20, "%u");
+DEBUGFS_FWSTATS_FILE(ps, upsd_utilization, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(rxpipe, rx_prep_beacon_drop, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rxpipe, descr_host_int_trig_rx_data, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rxpipe, beacon_buffer_thres_host_int_trig_rx_data,
+		     20, "%u");
+DEBUGFS_FWSTATS_FILE(rxpipe, missed_beacon_host_int_trig_rx_data, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rxpipe, tx_xfr_host_int_trig_rx_data, 20, "%u");
+
+DEBUGFS_READONLY_FILE(retry_count, 20, "%u", wl->stats.retry_count);
+DEBUGFS_READONLY_FILE(excessive_retries, 20, "%u",
+		      wl->stats.excessive_retries);
+
+static ssize_t tx_queue_len_read(struct file *file, char __user *userbuf,
+				 size_t count, loff_t *ppos)
+{
+	struct wl1251 *wl = file->private_data;
+	u32 queue_len;
+	char buf[20];
+	int res;
+
+	queue_len = skb_queue_len(&wl->tx_queue);
+
+	res = scnprintf(buf, sizeof(buf), "%u\n", queue_len);
+	return simple_read_from_buffer(userbuf, count, ppos, buf, res);
+}
+
+static const struct file_operations tx_queue_len_ops = {
+	.read = tx_queue_len_read,
+	.open = wl1251_open_file_generic,
+};
+
+static void wl1251_debugfs_delete_files(struct wl1251 *wl)
+{
+	DEBUGFS_FWSTATS_DEL(tx, internal_desc_overflow);
+
+	DEBUGFS_FWSTATS_DEL(rx, out_of_mem);
+	DEBUGFS_FWSTATS_DEL(rx, hdr_overflow);
+	DEBUGFS_FWSTATS_DEL(rx, hw_stuck);
+	DEBUGFS_FWSTATS_DEL(rx, dropped);
+	DEBUGFS_FWSTATS_DEL(rx, fcs_err);
+	DEBUGFS_FWSTATS_DEL(rx, xfr_hint_trig);
+	DEBUGFS_FWSTATS_DEL(rx, path_reset);
+	DEBUGFS_FWSTATS_DEL(rx, reset_counter);
+
+	DEBUGFS_FWSTATS_DEL(dma, rx_requested);
+	DEBUGFS_FWSTATS_DEL(dma, rx_errors);
+	DEBUGFS_FWSTATS_DEL(dma, tx_requested);
+	DEBUGFS_FWSTATS_DEL(dma, tx_errors);
+
+	DEBUGFS_FWSTATS_DEL(isr, cmd_cmplt);
+	DEBUGFS_FWSTATS_DEL(isr, fiqs);
+	DEBUGFS_FWSTATS_DEL(isr, rx_headers);
+	DEBUGFS_FWSTATS_DEL(isr, rx_mem_overflow);
+	DEBUGFS_FWSTATS_DEL(isr, rx_rdys);
+	DEBUGFS_FWSTATS_DEL(isr, irqs);
+	DEBUGFS_FWSTATS_DEL(isr, tx_procs);
+	DEBUGFS_FWSTATS_DEL(isr, decrypt_done);
+	DEBUGFS_FWSTATS_DEL(isr, dma0_done);
+	DEBUGFS_FWSTATS_DEL(isr, dma1_done);
+	DEBUGFS_FWSTATS_DEL(isr, tx_exch_complete);
+	DEBUGFS_FWSTATS_DEL(isr, commands);
+	DEBUGFS_FWSTATS_DEL(isr, rx_procs);
+	DEBUGFS_FWSTATS_DEL(isr, hw_pm_mode_changes);
+	DEBUGFS_FWSTATS_DEL(isr, host_acknowledges);
+	DEBUGFS_FWSTATS_DEL(isr, pci_pm);
+	DEBUGFS_FWSTATS_DEL(isr, wakeups);
+	DEBUGFS_FWSTATS_DEL(isr, low_rssi);
+
+	DEBUGFS_FWSTATS_DEL(wep, addr_key_count);
+	DEBUGFS_FWSTATS_DEL(wep, default_key_count);
+	/* skipping wep.reserved */
+	DEBUGFS_FWSTATS_DEL(wep, key_not_found);
+	DEBUGFS_FWSTATS_DEL(wep, decrypt_fail);
+	DEBUGFS_FWSTATS_DEL(wep, packets);
+	DEBUGFS_FWSTATS_DEL(wep, interrupt);
+
+	DEBUGFS_FWSTATS_DEL(pwr, ps_enter);
+	DEBUGFS_FWSTATS_DEL(pwr, elp_enter);
+	DEBUGFS_FWSTATS_DEL(pwr, missing_bcns);
+	DEBUGFS_FWSTATS_DEL(pwr, wake_on_host);
+	DEBUGFS_FWSTATS_DEL(pwr, wake_on_timer_exp);
+	DEBUGFS_FWSTATS_DEL(pwr, tx_with_ps);
+	DEBUGFS_FWSTATS_DEL(pwr, tx_without_ps);
+	DEBUGFS_FWSTATS_DEL(pwr, rcvd_beacons);
+	DEBUGFS_FWSTATS_DEL(pwr, power_save_off);
+	DEBUGFS_FWSTATS_DEL(pwr, enable_ps);
+	DEBUGFS_FWSTATS_DEL(pwr, disable_ps);
+	DEBUGFS_FWSTATS_DEL(pwr, fix_tsf_ps);
+	/* skipping cont_miss_bcns_spread for now */
+	DEBUGFS_FWSTATS_DEL(pwr, rcvd_awake_beacons);
+
+	DEBUGFS_FWSTATS_DEL(mic, rx_pkts);
+	DEBUGFS_FWSTATS_DEL(mic, calc_failure);
+
+	DEBUGFS_FWSTATS_DEL(aes, encrypt_fail);
+	DEBUGFS_FWSTATS_DEL(aes, decrypt_fail);
+	DEBUGFS_FWSTATS_DEL(aes, encrypt_packets);
+	DEBUGFS_FWSTATS_DEL(aes, decrypt_packets);
+	DEBUGFS_FWSTATS_DEL(aes, encrypt_interrupt);
+	DEBUGFS_FWSTATS_DEL(aes, decrypt_interrupt);
+
+	DEBUGFS_FWSTATS_DEL(event, heart_beat);
+	DEBUGFS_FWSTATS_DEL(event, calibration);
+	DEBUGFS_FWSTATS_DEL(event, rx_mismatch);
+	DEBUGFS_FWSTATS_DEL(event, rx_mem_empty);
+	DEBUGFS_FWSTATS_DEL(event, rx_pool);
+	DEBUGFS_FWSTATS_DEL(event, oom_late);
+	DEBUGFS_FWSTATS_DEL(event, phy_transmit_error);
+	DEBUGFS_FWSTATS_DEL(event, tx_stuck);
+
+	DEBUGFS_FWSTATS_DEL(ps, pspoll_timeouts);
+	DEBUGFS_FWSTATS_DEL(ps, upsd_timeouts);
+	DEBUGFS_FWSTATS_DEL(ps, upsd_max_sptime);
+	DEBUGFS_FWSTATS_DEL(ps, upsd_max_apturn);
+	DEBUGFS_FWSTATS_DEL(ps, pspoll_max_apturn);
+	DEBUGFS_FWSTATS_DEL(ps, pspoll_utilization);
+	DEBUGFS_FWSTATS_DEL(ps, upsd_utilization);
+
+	DEBUGFS_FWSTATS_DEL(rxpipe, rx_prep_beacon_drop);
+	DEBUGFS_FWSTATS_DEL(rxpipe, descr_host_int_trig_rx_data);
+	DEBUGFS_FWSTATS_DEL(rxpipe, beacon_buffer_thres_host_int_trig_rx_data);
+	DEBUGFS_FWSTATS_DEL(rxpipe, missed_beacon_host_int_trig_rx_data);
+	DEBUGFS_FWSTATS_DEL(rxpipe, tx_xfr_host_int_trig_rx_data);
+
+	DEBUGFS_DEL(tx_queue_len);
+	DEBUGFS_DEL(retry_count);
+	DEBUGFS_DEL(excessive_retries);
+}
+
+static int wl1251_debugfs_add_files(struct wl1251 *wl)
+{
+	int ret = 0;
+
+	DEBUGFS_FWSTATS_ADD(tx, internal_desc_overflow);
+
+	DEBUGFS_FWSTATS_ADD(rx, out_of_mem);
+	DEBUGFS_FWSTATS_ADD(rx, hdr_overflow);
+	DEBUGFS_FWSTATS_ADD(rx, hw_stuck);
+	DEBUGFS_FWSTATS_ADD(rx, dropped);
+	DEBUGFS_FWSTATS_ADD(rx, fcs_err);
+	DEBUGFS_FWSTATS_ADD(rx, xfr_hint_trig);
+	DEBUGFS_FWSTATS_ADD(rx, path_reset);
+	DEBUGFS_FWSTATS_ADD(rx, reset_counter);
+
+	DEBUGFS_FWSTATS_ADD(dma, rx_requested);
+	DEBUGFS_FWSTATS_ADD(dma, rx_errors);
+	DEBUGFS_FWSTATS_ADD(dma, tx_requested);
+	DEBUGFS_FWSTATS_ADD(dma, tx_errors);
+
+	DEBUGFS_FWSTATS_ADD(isr, cmd_cmplt);
+	DEBUGFS_FWSTATS_ADD(isr, fiqs);
+	DEBUGFS_FWSTATS_ADD(isr, rx_headers);
+	DEBUGFS_FWSTATS_ADD(isr, rx_mem_overflow);
+	DEBUGFS_FWSTATS_ADD(isr, rx_rdys);
+	DEBUGFS_FWSTATS_ADD(isr, irqs);
+	DEBUGFS_FWSTATS_ADD(isr, tx_procs);
+	DEBUGFS_FWSTATS_ADD(isr, decrypt_done);
+	DEBUGFS_FWSTATS_ADD(isr, dma0_done);
+	DEBUGFS_FWSTATS_ADD(isr, dma1_done);
+	DEBUGFS_FWSTATS_ADD(isr, tx_exch_complete);
+	DEBUGFS_FWSTATS_ADD(isr, commands);
+	DEBUGFS_FWSTATS_ADD(isr, rx_procs);
+	DEBUGFS_FWSTATS_ADD(isr, hw_pm_mode_changes);
+	DEBUGFS_FWSTATS_ADD(isr, host_acknowledges);
+	DEBUGFS_FWSTATS_ADD(isr, pci_pm);
+	DEBUGFS_FWSTATS_ADD(isr, wakeups);
+	DEBUGFS_FWSTATS_ADD(isr, low_rssi);
+
+	DEBUGFS_FWSTATS_ADD(wep, addr_key_count);
+	DEBUGFS_FWSTATS_ADD(wep, default_key_count);
+	/* skipping wep.reserved */
+	DEBUGFS_FWSTATS_ADD(wep, key_not_found);
+	DEBUGFS_FWSTATS_ADD(wep, decrypt_fail);
+	DEBUGFS_FWSTATS_ADD(wep, packets);
+	DEBUGFS_FWSTATS_ADD(wep, interrupt);
+
+	DEBUGFS_FWSTATS_ADD(pwr, ps_enter);
+	DEBUGFS_FWSTATS_ADD(pwr, elp_enter);
+	DEBUGFS_FWSTATS_ADD(pwr, missing_bcns);
+	DEBUGFS_FWSTATS_ADD(pwr, wake_on_host);
+	DEBUGFS_FWSTATS_ADD(pwr, wake_on_timer_exp);
+	DEBUGFS_FWSTATS_ADD(pwr, tx_with_ps);
+	DEBUGFS_FWSTATS_ADD(pwr, tx_without_ps);
+	DEBUGFS_FWSTATS_ADD(pwr, rcvd_beacons);
+	DEBUGFS_FWSTATS_ADD(pwr, power_save_off);
+	DEBUGFS_FWSTATS_ADD(pwr, enable_ps);
+	DEBUGFS_FWSTATS_ADD(pwr, disable_ps);
+	DEBUGFS_FWSTATS_ADD(pwr, fix_tsf_ps);
+	/* skipping cont_miss_bcns_spread for now */
+	DEBUGFS_FWSTATS_ADD(pwr, rcvd_awake_beacons);
+
+	DEBUGFS_FWSTATS_ADD(mic, rx_pkts);
+	DEBUGFS_FWSTATS_ADD(mic, calc_failure);
+
+	DEBUGFS_FWSTATS_ADD(aes, encrypt_fail);
+	DEBUGFS_FWSTATS_ADD(aes, decrypt_fail);
+	DEBUGFS_FWSTATS_ADD(aes, encrypt_packets);
+	DEBUGFS_FWSTATS_ADD(aes, decrypt_packets);
+	DEBUGFS_FWSTATS_ADD(aes, encrypt_interrupt);
+	DEBUGFS_FWSTATS_ADD(aes, decrypt_interrupt);
+
+	DEBUGFS_FWSTATS_ADD(event, heart_beat);
+	DEBUGFS_FWSTATS_ADD(event, calibration);
+	DEBUGFS_FWSTATS_ADD(event, rx_mismatch);
+	DEBUGFS_FWSTATS_ADD(event, rx_mem_empty);
+	DEBUGFS_FWSTATS_ADD(event, rx_pool);
+	DEBUGFS_FWSTATS_ADD(event, oom_late);
+	DEBUGFS_FWSTATS_ADD(event, phy_transmit_error);
+	DEBUGFS_FWSTATS_ADD(event, tx_stuck);
+
+	DEBUGFS_FWSTATS_ADD(ps, pspoll_timeouts);
+	DEBUGFS_FWSTATS_ADD(ps, upsd_timeouts);
+	DEBUGFS_FWSTATS_ADD(ps, upsd_max_sptime);
+	DEBUGFS_FWSTATS_ADD(ps, upsd_max_apturn);
+	DEBUGFS_FWSTATS_ADD(ps, pspoll_max_apturn);
+	DEBUGFS_FWSTATS_ADD(ps, pspoll_utilization);
+	DEBUGFS_FWSTATS_ADD(ps, upsd_utilization);
+
+	DEBUGFS_FWSTATS_ADD(rxpipe, rx_prep_beacon_drop);
+	DEBUGFS_FWSTATS_ADD(rxpipe, descr_host_int_trig_rx_data);
+	DEBUGFS_FWSTATS_ADD(rxpipe, beacon_buffer_thres_host_int_trig_rx_data);
+	DEBUGFS_FWSTATS_ADD(rxpipe, missed_beacon_host_int_trig_rx_data);
+	DEBUGFS_FWSTATS_ADD(rxpipe, tx_xfr_host_int_trig_rx_data);
+
+	DEBUGFS_ADD(tx_queue_len, wl->debugfs.rootdir);
+	DEBUGFS_ADD(retry_count, wl->debugfs.rootdir);
+	DEBUGFS_ADD(excessive_retries, wl->debugfs.rootdir);
+
+out:
+	if (ret < 0)
+		wl1251_debugfs_delete_files(wl);
+
+	return ret;
+}
+
+void wl1251_debugfs_reset(struct wl1251 *wl)
+{
+	memset(wl->stats.fw_stats, 0, sizeof(*wl->stats.fw_stats));
+	wl->stats.retry_count = 0;
+	wl->stats.excessive_retries = 0;
+}
+
+int wl1251_debugfs_init(struct wl1251 *wl)
+{
+	int ret;
+
+	wl->debugfs.rootdir = debugfs_create_dir(KBUILD_MODNAME, NULL);
+
+	if (IS_ERR(wl->debugfs.rootdir)) {
+		ret = PTR_ERR(wl->debugfs.rootdir);
+		wl->debugfs.rootdir = NULL;
+		goto err;
+	}
+
+	wl->debugfs.fw_statistics = debugfs_create_dir("fw-statistics",
+						       wl->debugfs.rootdir);
+
+	if (IS_ERR(wl->debugfs.fw_statistics)) {
+		ret = PTR_ERR(wl->debugfs.fw_statistics);
+		wl->debugfs.fw_statistics = NULL;
+		goto err_root;
+	}
+
+	wl->stats.fw_stats = kzalloc(sizeof(*wl->stats.fw_stats),
+				      GFP_KERNEL);
+
+	if (!wl->stats.fw_stats) {
+		ret = -ENOMEM;
+		goto err_fw;
+	}
+
+	wl->stats.fw_stats_update = jiffies;
+
+	ret = wl1251_debugfs_add_files(wl);
+
+	if (ret < 0)
+		goto err_file;
+
+	return 0;
+
+err_file:
+	kfree(wl->stats.fw_stats);
+	wl->stats.fw_stats = NULL;
+
+err_fw:
+	debugfs_remove(wl->debugfs.fw_statistics);
+	wl->debugfs.fw_statistics = NULL;
+
+err_root:
+	debugfs_remove(wl->debugfs.rootdir);
+	wl->debugfs.rootdir = NULL;
+
+err:
+	return ret;
+}
+
+void wl1251_debugfs_exit(struct wl1251 *wl)
+{
+	wl1251_debugfs_delete_files(wl);
+
+	kfree(wl->stats.fw_stats);
+	wl->stats.fw_stats = NULL;
+
+	debugfs_remove(wl->debugfs.fw_statistics);
+	wl->debugfs.fw_statistics = NULL;
+
+	debugfs_remove(wl->debugfs.rootdir);
+	wl->debugfs.rootdir = NULL;
+
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_debugfs.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_debugfs.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_debugfs.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_debugfs.h	2012-12-16 13:13:01.680330145 +0100
@@ -0,0 +1,33 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef WL1251_DEBUGFS_H
+#define WL1251_DEBUGFS_H
+
+#include "wl1251.h"
+
+int wl1251_debugfs_init(struct wl1251 *wl);
+void wl1251_debugfs_exit(struct wl1251 *wl);
+void wl1251_debugfs_reset(struct wl1251 *wl);
+
+#endif /* WL1251_DEBUGFS_H */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_event.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_event.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_event.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_event.c	2012-12-16 13:13:01.680330145 +0100
@@ -0,0 +1,152 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include "wl1251.h"
+#include "wl1251_reg.h"
+#include "wl1251_spi.h"
+#include "wl1251_event.h"
+#include "wl1251_ps.h"
+
+static int wl1251_event_scan_complete(struct wl1251 *wl,
+				      struct event_mailbox *mbox)
+{
+	wl1251_debug(DEBUG_EVENT, "status: 0x%x, channels: %d",
+		     mbox->scheduled_scan_status,
+		     mbox->scheduled_scan_channels);
+
+	if (wl->scanning) {
+		mutex_unlock(&wl->mutex);
+		ieee80211_scan_completed(wl->hw);
+		mutex_lock(&wl->mutex);
+		wl1251_debug(DEBUG_MAC80211, "mac80211 hw scan completed");
+		wl->scanning = false;
+	}
+
+	return 0;
+}
+
+static void wl1251_event_mbox_dump(struct event_mailbox *mbox)
+{
+	wl1251_debug(DEBUG_EVENT, "MBOX DUMP:");
+	wl1251_debug(DEBUG_EVENT, "\tvector: 0x%x", mbox->events_vector);
+	wl1251_debug(DEBUG_EVENT, "\tmask: 0x%x", mbox->events_mask);
+}
+
+static int wl1251_event_process(struct wl1251 *wl, struct event_mailbox *mbox)
+{
+	int ret;
+	u32 vector;
+
+	wl1251_event_mbox_dump(mbox);
+
+	vector = mbox->events_vector & ~(mbox->events_mask);
+	wl1251_debug(DEBUG_EVENT, "vector: 0x%x", vector);
+
+	if (vector & SCAN_COMPLETE_EVENT_ID) {
+		ret = wl1251_event_scan_complete(wl, mbox);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (vector & BSS_LOSE_EVENT_ID) {
+		wl1251_debug(DEBUG_EVENT, "BSS_LOSE_EVENT");
+
+		if (wl->psm_requested && wl->psm) {
+			ret = wl1251_ps_set_mode(wl, STATION_ACTIVE_MODE);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	if (vector & SYNCHRONIZATION_TIMEOUT_EVENT_ID && wl->psm) {
+		wl1251_debug(DEBUG_EVENT, "SYNCHRONIZATION_TIMEOUT_EVENT");
+		/* need to unlock mutex to avoid deadlocking with rtnl */
+		mutex_unlock(&wl->mutex);
+
+		/* indicate to the stack, that beacons have been lost */
+		ieee80211_beacon_loss(wl->vif);
+		mutex_lock(&wl->mutex);
+	}
+
+	if (vector & REGAINED_BSS_EVENT_ID) {
+		if (wl->psm_requested) {
+			ret = wl1251_ps_set_mode(wl, STATION_POWER_SAVE_MODE);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	if (vector & ROAMING_TRIGGER_LOW_RSSI_EVENT_ID)
+		ieee80211_rssi_changed(wl->vif, IEEE80211_RSSI_STATE_LOW);
+
+	if (vector & ROAMING_TRIGGER_REGAINED_RSSI_EVENT_ID)
+		ieee80211_rssi_changed(wl->vif, IEEE80211_RSSI_STATE_HIGH);
+
+	return 0;
+}
+
+int wl1251_event_unmask(struct wl1251 *wl)
+{
+	int ret;
+
+	ret = wl1251_acx_event_mbox_mask(wl, ~(wl->event_mask));
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+void wl1251_event_mbox_config(struct wl1251 *wl)
+{
+	wl->mbox_ptr[0] = wl1251_reg_read32(wl, REG_EVENT_MAILBOX_PTR);
+	wl->mbox_ptr[1] = wl->mbox_ptr[0] + sizeof(struct event_mailbox);
+
+	wl1251_debug(DEBUG_EVENT, "MBOX ptrs: 0x%x 0x%x",
+		     wl->mbox_ptr[0], wl->mbox_ptr[1]);
+}
+
+int wl1251_event_handle(struct wl1251 *wl, u8 mbox_num)
+{
+	struct event_mailbox mbox;
+	int ret;
+
+	wl1251_debug(DEBUG_EVENT, "EVENT on mbox %d", mbox_num);
+
+	if (mbox_num > 1)
+		return -EINVAL;
+
+	/* first we read the mbox descriptor */
+	wl1251_spi_mem_read(wl, wl->mbox_ptr[mbox_num], &mbox,
+			    sizeof(struct event_mailbox));
+
+	/* process the descriptor */
+	ret = wl1251_event_process(wl, &mbox);
+	if (ret < 0)
+		return ret;
+
+	/* then we let the firmware know it can go on...*/
+	wl1251_reg_write32(wl, ACX_REG_INTERRUPT_TRIG, INTR_TRIG_EVENT_ACK);
+
+	return 0;
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_event.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_event.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_event.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_event.h	2012-12-16 13:13:01.680330145 +0100
@@ -0,0 +1,121 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __WL1251_EVENT_H__
+#define __WL1251_EVENT_H__
+
+/*
+ * Mbox events
+ *
+ * The event mechanism is based on a pair of event buffers (buffers A and
+ * B) at fixed locations in the target's memory. The host processes one
+ * buffer while the other buffer continues to collect events. If the host
+ * is not processing events, an interrupt is issued to signal that a buffer
+ * is ready. Once the host is done with processing events from one buffer,
+ * it signals the target (with an ACK interrupt) that the event buffer is
+ * free.
+ */
+
+enum {
+	RESERVED1_EVENT_ID                       = BIT(0),
+	RESERVED2_EVENT_ID                       = BIT(1),
+	MEASUREMENT_START_EVENT_ID               = BIT(2),
+	SCAN_COMPLETE_EVENT_ID                   = BIT(3),
+	CALIBRATION_COMPLETE_EVENT_ID            = BIT(4),
+	ROAMING_TRIGGER_LOW_RSSI_EVENT_ID        = BIT(5),
+	PS_REPORT_EVENT_ID                       = BIT(6),
+	SYNCHRONIZATION_TIMEOUT_EVENT_ID         = BIT(7),
+	HEALTH_REPORT_EVENT_ID                   = BIT(8),
+	ACI_DETECTION_EVENT_ID                   = BIT(9),
+	DEBUG_REPORT_EVENT_ID                    = BIT(10),
+	MAC_STATUS_EVENT_ID                      = BIT(11),
+	DISCONNECT_EVENT_COMPLETE_ID             = BIT(12),
+	JOIN_EVENT_COMPLETE_ID                   = BIT(13),
+	CHANNEL_SWITCH_COMPLETE_EVENT_ID         = BIT(14),
+	BSS_LOSE_EVENT_ID                        = BIT(15),
+	ROAMING_TRIGGER_MAX_TX_RETRY_EVENT_ID    = BIT(16),
+	MEASUREMENT_COMPLETE_EVENT_ID            = BIT(17),
+	AP_DISCOVERY_COMPLETE_EVENT_ID           = BIT(18),
+	SCHEDULED_SCAN_COMPLETE_EVENT_ID         = BIT(19),
+	PSPOLL_DELIVERY_FAILURE_EVENT_ID 	 = BIT(20),
+	RESET_BSS_EVENT_ID                       = BIT(21),
+	REGAINED_BSS_EVENT_ID                    = BIT(22),
+	ROAMING_TRIGGER_REGAINED_RSSI_EVENT_ID   = BIT(23),
+	ROAMING_TRIGGER_LOW_SNR_EVENT_ID         = BIT(24),
+	ROAMING_TRIGGER_REGAINED_SNR_EVENT_ID    = BIT(25),
+
+	DBG_EVENT_ID                             = BIT(26),
+	BT_PTA_SENSE_EVENT_ID                    = BIT(27),
+	BT_PTA_PREDICTION_EVENT_ID               = BIT(28),
+	BT_PTA_AVALANCHE_EVENT_ID                = BIT(29),
+
+	PLT_RX_CALIBRATION_COMPLETE_EVENT_ID     = BIT(30),
+
+	EVENT_MBOX_ALL_EVENT_ID                  = 0x7fffffff,
+};
+
+struct event_debug_report {
+	u8 debug_event_id;
+	u8 num_params;
+	u16 pad;
+	u32 report_1;
+	u32 report_2;
+	u32 report_3;
+} __attribute__ ((packed));
+
+struct event_mailbox {
+	u32 events_vector;
+	u32 events_mask;
+	u32 reserved_1;
+	u32 reserved_2;
+
+	char average_rssi_level;
+	u8 ps_status;
+	u8 channel_switch_status;
+	u8 scheduled_scan_status;
+
+	/* Channels scanned by the scheduled scan */
+	u16 scheduled_scan_channels;
+
+	/* If bit 0 is set -> target's fatal error */
+	u16 health_report;
+	u16 bad_fft_counter;
+	u8 bt_pta_sense_info;
+	u8 bt_pta_protective_info;
+	u32 reserved;
+	u32 debug_report[2];
+
+	/* Number of FCS errors since last event */
+	u32 fcs_err_counter;
+
+	struct event_debug_report report;
+	u8 average_snr_level;
+	u8 padding[19];
+} __attribute__ ((packed));
+
+int wl1251_event_unmask(struct wl1251 *wl);
+void wl1251_event_mbox_config(struct wl1251 *wl);
+int wl1251_event_handle(struct wl1251 *wl, u8 mbox);
+
+#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251.h	2012-12-16 13:13:01.684330145 +0100
@@ -1,7 +1,8 @@
 /*
- * This file is part of wl12xx
+ * This file is part of wl1251
  *
- * Copyright (C) 2008 Nokia Corporation
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008-2009 Nokia Corporation
  *
  * Contact: Kalle Valo <kalle.valo@nokia.com>
  *
@@ -24,142 +25,425 @@
 #ifndef __WL1251_H__
 #define __WL1251_H__
 
+#include <linux/mutex.h>
+#include <linux/list.h>
 #include <linux/bitops.h>
+#include <net/mac80211.h>
+#include <mach/board.h>
+#include <mach/board-nokia.h>
+
+#define DRIVER_NAME "wl1251"
+#define DRIVER_PREFIX DRIVER_NAME ": "
+
+enum {
+	DEBUG_NONE	= 0,
+	DEBUG_IRQ	= BIT(0),
+	DEBUG_SPI	= BIT(1),
+	DEBUG_BOOT	= BIT(2),
+	DEBUG_MAILBOX	= BIT(3),
+	DEBUG_NETLINK	= BIT(4),
+	DEBUG_EVENT	= BIT(5),
+	DEBUG_TX	= BIT(6),
+	DEBUG_RX	= BIT(7),
+	DEBUG_SCAN	= BIT(8),
+	DEBUG_CRYPT	= BIT(9),
+	DEBUG_PSM	= BIT(10),
+	DEBUG_MAC80211	= BIT(11),
+	DEBUG_CMD	= BIT(12),
+	DEBUG_ACX	= BIT(13),
+	DEBUG_ALL	= ~0,
+};
+
+#define DEBUG_LEVEL (DEBUG_NONE)
+
+#define DEBUG_DUMP_LIMIT 1024
+
+#define wl1251_error(fmt, arg...) \
+	printk(KERN_ERR DRIVER_PREFIX "ERROR " fmt "\n", ##arg)
+
+#define wl1251_warning(fmt, arg...) \
+	printk(KERN_WARNING DRIVER_PREFIX "WARNING " fmt "\n", ##arg)
+
+#define wl1251_notice(fmt, arg...) \
+	printk(KERN_INFO DRIVER_PREFIX fmt "\n", ##arg)
+
+#define wl1251_info(fmt, arg...) \
+	printk(KERN_DEBUG DRIVER_PREFIX fmt "\n", ##arg)
+
+#define wl1251_debug(level, fmt, arg...) \
+	do { \
+		if (level & DEBUG_LEVEL) \
+			printk(KERN_DEBUG DRIVER_PREFIX fmt "\n", ##arg); \
+	} while (0)
+
+#define wl1251_dump(level, prefix, buf, len)	\
+	do { \
+		if (level & DEBUG_LEVEL) \
+			print_hex_dump(KERN_DEBUG, DRIVER_PREFIX prefix, \
+				       DUMP_PREFIX_OFFSET, 16, 1,	\
+				       buf,				\
+				       min_t(size_t, len, DEBUG_DUMP_LIMIT), \
+				       0);				\
+	} while (0)
+
+#define wl1251_dump_ascii(level, prefix, buf, len)	\
+	do { \
+		if (level & DEBUG_LEVEL) \
+			print_hex_dump(KERN_DEBUG, DRIVER_PREFIX prefix, \
+				       DUMP_PREFIX_OFFSET, 16, 1,	\
+				       buf,				\
+				       min_t(size_t, len, DEBUG_DUMP_LIMIT), \
+				       true);				\
+	} while (0)
+
+#define WL1251_DEFAULT_RX_CONFIG (CFG_UNI_FILTER_EN |	\
+				  CFG_BSSID_FILTER_EN | \
+				  CFG_MC_FILTER_EN)
+
+#define WL1251_DEFAULT_RX_FILTER (CFG_RX_PRSP_EN |  \
+				  CFG_RX_MGMT_EN |  \
+				  CFG_RX_DATA_EN |  \
+				  CFG_RX_CTL_EN |   \
+				  CFG_RX_BCN_EN |   \
+				  CFG_RX_AUTH_EN |  \
+				  CFG_RX_ASSOC_EN)
+
+#define WL1251_BUSY_WORD_LEN 8
+
+struct boot_attr {
+	u32 radio_type;
+	u8 mac_clock;
+	u8 arm_clock;
+	int firmware_debug;
+	u32 minor;
+	u32 major;
+	u32 bugfix;
+};
+
+enum wl1251_state {
+	WL1251_STATE_OFF,
+	WL1251_STATE_ON,
+	WL1251_STATE_PLT,
+};
+
+enum wl1251_partition_type {
+	PART_DOWN,
+	PART_WORK,
+	PART_DRPW,
+
+	PART_TABLE_LEN
+};
+
+struct wl1251_partition {
+	u32 size;
+	u32 start;
+};
+
+struct wl1251_partition_set {
+	struct wl1251_partition mem;
+	struct wl1251_partition reg;
+};
+
+struct wl1251_stats {
+	struct acx_statistics *fw_stats;
+	unsigned long fw_stats_update;
+
+	unsigned int retry_count;
+	unsigned int excessive_retries;
+};
+
+struct wl1251_debugfs {
+	struct dentry *rootdir;
+	struct dentry *fw_statistics;
+
+	struct dentry *tx_internal_desc_overflow;
+
+	struct dentry *rx_out_of_mem;
+	struct dentry *rx_hdr_overflow;
+	struct dentry *rx_hw_stuck;
+	struct dentry *rx_dropped;
+	struct dentry *rx_fcs_err;
+	struct dentry *rx_xfr_hint_trig;
+	struct dentry *rx_path_reset;
+	struct dentry *rx_reset_counter;
+
+	struct dentry *dma_rx_requested;
+	struct dentry *dma_rx_errors;
+	struct dentry *dma_tx_requested;
+	struct dentry *dma_tx_errors;
+
+	struct dentry *isr_cmd_cmplt;
+	struct dentry *isr_fiqs;
+	struct dentry *isr_rx_headers;
+	struct dentry *isr_rx_mem_overflow;
+	struct dentry *isr_rx_rdys;
+	struct dentry *isr_irqs;
+	struct dentry *isr_tx_procs;
+	struct dentry *isr_decrypt_done;
+	struct dentry *isr_dma0_done;
+	struct dentry *isr_dma1_done;
+	struct dentry *isr_tx_exch_complete;
+	struct dentry *isr_commands;
+	struct dentry *isr_rx_procs;
+	struct dentry *isr_hw_pm_mode_changes;
+	struct dentry *isr_host_acknowledges;
+	struct dentry *isr_pci_pm;
+	struct dentry *isr_wakeups;
+	struct dentry *isr_low_rssi;
+
+	struct dentry *wep_addr_key_count;
+	struct dentry *wep_default_key_count;
+	/* skipping wep.reserved */
+	struct dentry *wep_key_not_found;
+	struct dentry *wep_decrypt_fail;
+	struct dentry *wep_packets;
+	struct dentry *wep_interrupt;
+
+	struct dentry *pwr_ps_enter;
+	struct dentry *pwr_elp_enter;
+	struct dentry *pwr_missing_bcns;
+	struct dentry *pwr_wake_on_host;
+	struct dentry *pwr_wake_on_timer_exp;
+	struct dentry *pwr_tx_with_ps;
+	struct dentry *pwr_tx_without_ps;
+	struct dentry *pwr_rcvd_beacons;
+	struct dentry *pwr_power_save_off;
+	struct dentry *pwr_enable_ps;
+	struct dentry *pwr_disable_ps;
+	struct dentry *pwr_fix_tsf_ps;
+	/* skipping cont_miss_bcns_spread for now */
+	struct dentry *pwr_rcvd_awake_beacons;
+
+	struct dentry *mic_rx_pkts;
+	struct dentry *mic_calc_failure;
+
+	struct dentry *aes_encrypt_fail;
+	struct dentry *aes_decrypt_fail;
+	struct dentry *aes_encrypt_packets;
+	struct dentry *aes_decrypt_packets;
+	struct dentry *aes_encrypt_interrupt;
+	struct dentry *aes_decrypt_interrupt;
+
+	struct dentry *event_heart_beat;
+	struct dentry *event_calibration;
+	struct dentry *event_rx_mismatch;
+	struct dentry *event_rx_mem_empty;
+	struct dentry *event_rx_pool;
+	struct dentry *event_oom_late;
+	struct dentry *event_phy_transmit_error;
+	struct dentry *event_tx_stuck;
+
+	struct dentry *ps_pspoll_timeouts;
+	struct dentry *ps_upsd_timeouts;
+	struct dentry *ps_upsd_max_sptime;
+	struct dentry *ps_upsd_max_apturn;
+	struct dentry *ps_pspoll_max_apturn;
+	struct dentry *ps_pspoll_utilization;
+	struct dentry *ps_upsd_utilization;
+
+	struct dentry *rxpipe_rx_prep_beacon_drop;
+	struct dentry *rxpipe_descr_host_int_trig_rx_data;
+	struct dentry *rxpipe_beacon_buffer_thres_host_int_trig_rx_data;
+	struct dentry *rxpipe_missed_beacon_host_int_trig_rx_data;
+	struct dentry *rxpipe_tx_xfr_host_int_trig_rx_data;
+
+	struct dentry *tx_queue_len;
+
+	struct dentry *retry_count;
+	struct dentry *excessive_retries;
+};
+
+enum wl1251_bt_coex_mode {
+	WL1251_BT_COEX_OFF,
+	WL1251_BT_COEX_ENABLE,
+	WL1251_BT_COEX_MONOAUDIO
+};
+
+struct wl1251 {
+	struct ieee80211_hw *hw;
+	bool mac80211_registered;
+
+	struct spi_device *spi;
+
+	void (*set_power)(bool enable);
+	int irq;
+
+	spinlock_t wl_lock;
+
+	enum wl1251_state state;
+	struct mutex mutex;
+
+	int physical_mem_addr;
+	int physical_reg_addr;
+	int virtual_mem_addr;
+	int virtual_reg_addr;
+
+	int cmd_box_addr;
+	int event_box_addr;
+	struct boot_attr boot_attr;
+
+	u8 *fw;
+	size_t fw_len;
+	u8 *nvs;
+	size_t nvs_len;
+
+	u8 bssid[ETH_ALEN];
+	u8 mac_addr[ETH_ALEN];
+	u8 bss_type;
+	u8 ssid[IW_ESSID_MAX_SIZE + 1];
+	u8 ssid_len;
+	u8 listen_int;
+	int channel;
+
+	void *target_mem_map;
+	struct acx_data_path_params_resp *data_path;
+
+	/* Accounting for allocated / available TX blocks on HW */
+	u32 tx_blocks_available;
+	u32 tx_descriptors_available;
+	u32 tx_results_count;
+
+	/* Transmitted TX packets counter for chipset interface */
+	int tx_packets_count;
+
+	/* Time-offset between host and chipset clocks */
+	int time_offset;
+
+	/* Session counter for the chipset */
+	int session_counter;
+
+	/* Number of TX packets transferred to the FW, modulo 16 */
+	u32 data_in_count;
+
+	/* Frames scheduled for transmission, not handled yet */
+	struct sk_buff_head tx_queue;
+	bool tx_queue_stopped;
+
+	struct work_struct tx_work;
+	struct work_struct filter_work;
+	struct wl1251_filter_params *filter_params;
 
-#include "wl12xx.h"
-#include "acx.h"
+	/* Pending TX frames */
+	struct sk_buff *tx_frames[16];
 
-#define WL1251_FW_NAME "wl1251-fw.bin"
-#define WL1251_NVS_NAME "wl1251-nvs.bin"
-
-#define WL1251_POWER_ON_SLEEP 10 /* in miliseconds */
-
-void wl1251_setup(struct wl12xx *wl);
+	/*
+	 * Index pointing to the next TX complete entry
+	 * in the cyclic XT complete array we get from
+	 * the FW.
+	 */
+	u32 next_tx_complete;
 
+	/* FW Rx counter */
+	u32 rx_counter;
 
-struct wl1251_acx_memory {
-	__le16 num_stations; /* number of STAs to be supported. */
-	u16 reserved_1;
+	/* Rx frames handled */
+	u32 rx_handled;
 
-	/*
-	 * Nmber of memory buffers for the RX mem pool.
-	 * The actual number may be less if there are
-	 * not enough blocks left for the minimum num
-	 * of TX ones.
-	 */
-	u8 rx_mem_block_num;
-	u8 reserved_2;
-	u8 num_tx_queues; /* From 1 to 16 */
-	u8 host_if_options; /* HOST_IF* */
-	u8 tx_min_mem_block_num;
-	u8 num_ssid_profiles;
-	__le16 debug_buffer_size;
-} __attribute__ ((packed));
+	/* Current double buffer */
+	u32 rx_current_buffer;
+	u32 rx_last_id;
 
+	/* The target interrupt mask */
+	u32 intr_mask;
+	struct work_struct irq_work;
 
-#define ACX_RX_DESC_MIN                1
-#define ACX_RX_DESC_MAX                127
-#define ACX_RX_DESC_DEF                32
-struct wl1251_acx_rx_queue_config {
-	u8 num_descs;
-	u8 pad;
-	u8 type;
-	u8 priority;
-	__le32 dma_address;
-} __attribute__ ((packed));
+	/* The mbox event mask */
+	u32 event_mask;
 
-#define ACX_TX_DESC_MIN                1
-#define ACX_TX_DESC_MAX                127
-#define ACX_TX_DESC_DEF                16
-struct wl1251_acx_tx_queue_config {
-    u8 num_descs;
-    u8 pad[2];
-    u8 attributes;
-} __attribute__ ((packed));
+	/* Mailbox pointers */
+	u32 mbox_ptr[2];
 
-#define MAX_TX_QUEUE_CONFIGS 5
-#define MAX_TX_QUEUES 4
-struct wl1251_acx_config_memory {
-	struct acx_header header;
+	/* Are we currently scanning */
+	bool scanning;
 
-	struct wl1251_acx_memory mem_config;
-	struct wl1251_acx_rx_queue_config rx_queue_config;
-	struct wl1251_acx_tx_queue_config tx_queue_config[MAX_TX_QUEUE_CONFIGS];
-} __attribute__ ((packed));
+	/* Our association ID */
+	u16 aid;
 
-struct wl1251_acx_mem_map {
-	struct acx_header header;
+	/* Default key (for WEP) */
+	u32 default_key;
 
-	void *code_start;
-	void *code_end;
+	unsigned int tx_mgmt_frm_rate;
+	unsigned int tx_mgmt_frm_mod;
 
-	void *wep_defkey_start;
-	void *wep_defkey_end;
+	unsigned int rx_config;
+	unsigned int rx_filter;
 
-	void *sta_table_start;
-	void *sta_table_end;
+	/* is firmware in elp mode */
+	bool elp;
 
-	void *packet_template_start;
-	void *packet_template_end;
+	struct delayed_work elp_work;
 
-	void *queue_memory_start;
-	void *queue_memory_end;
+	/* we can be in psm, but not in elp, we have to differentiate */
+	bool psm;
 
-	void *packet_memory_pool_start;
-	void *packet_memory_pool_end;
+	/* PSM mode requested */
+	bool psm_requested;
 
-	void *debug_buffer1_start;
-	void *debug_buffer1_end;
+	u16 beacon_int;
+	u8 dtim_period;
 
-	void *debug_buffer2_start;
-	void *debug_buffer2_end;
+	/* in dBm */
+	int power_level;
 
-	/* Number of blocks FW allocated for TX packets */
-	u32 num_tx_mem_blocks;
+	struct wl1251_stats stats;
+	struct wl1251_debugfs debugfs;
 
-	/* Number of blocks FW allocated for RX packets */
-	u32 num_rx_mem_blocks;
-} __attribute__ ((packed));
+	u32 buffer_32;
+	u32 buffer_cmd;
+	u8 buffer_busyword[WL1251_BUSY_WORD_LEN];
+	struct wl1251_rx_descriptor *rx_descriptor;
 
-/*************************************************************************
+	struct wl1271_fw_status *fw_status;
 
-    Host Interrupt Register (WiLink -> Host)
+	struct ieee80211_vif *vif;
 
-**************************************************************************/
+	enum wl1251_bt_coex_mode bt_coex_mode;
 
-/* RX packet is ready in Xfer buffer #0 */
-#define WL1251_ACX_INTR_RX0_DATA      BIT(0)
+	u32 chip_id;
+	char fw_ver[21];
+};
 
-/* TX result(s) are in the TX complete buffer */
-#define WL1251_ACX_INTR_TX_RESULT	BIT(1)
+int wl1251_plt_start(struct wl1251 *wl);
+int wl1251_plt_stop(struct wl1251 *wl);
 
-/* OBSOLETE */
-#define WL1251_ACX_INTR_TX_XFR		BIT(2)
+#define DEFAULT_HW_GEN_MODULATION_TYPE    CCK_LONG /* Long Preamble */
+#define DEFAULT_HW_GEN_TX_RATE          RATE_2MBPS
+#define JOIN_TIMEOUT 5000 /* 5000 milliseconds to join */
 
-/* RX packet is ready in Xfer buffer #1 */
-#define WL1251_ACX_INTR_RX1_DATA	BIT(3)
+#define SESSION_COUNTER_MAX 7 /* maximum value for the session counter */
 
-/* Event was entered to Event MBOX #A */
-#define WL1251_ACX_INTR_EVENT_A		BIT(4)
+#define WL1251_DEFAULT_POWER_LEVEL 20
 
-/* Event was entered to Event MBOX #B */
-#define WL1251_ACX_INTR_EVENT_B		BIT(5)
+#define WL1251_TX_QUEUE_MAX_LENGTH 20
 
-/* OBSOLETE */
-#define WL1251_ACX_INTR_WAKE_ON_HOST	BIT(6)
+#define WL1251_DEFAULT_BEACON_INT 100
+#define WL1251_DEFAULT_DTIM_PERIOD 1
 
-/* Trace meassge on MBOX #A */
-#define WL1251_ACX_INTR_TRACE_A		BIT(7)
+#define WL1251_DEFAULT_CHANNEL 0
 
-/* Trace meassge on MBOX #B */
-#define WL1251_ACX_INTR_TRACE_B		BIT(8)
+#define CHIP_ID_1251_PG10	           (0x7010101)
+#define CHIP_ID_1251_PG11	           (0x7020101)
+#define CHIP_ID_1251_PG12	           (0x7030101)
+#define CHIP_ID_1271_PG10	           (0x4030101)
+#define CHIP_ID_1271_PG20	           (0x4030111)
 
-/* Command processing completion */
-#define WL1251_ACX_INTR_CMD_COMPLETE	BIT(9)
+#define WL1251_FW_NAME "wl1251-fw.bin"
+#define WL1251_NVS_NAME "wl1251-nvs.bin"
 
-/* Init sequence is done */
-#define WL1251_ACX_INTR_INIT_COMPLETE	BIT(14)
+#define WL1251_POWER_ON_SLEEP 10 /* in miliseconds */
 
-#define WL1251_ACX_INTR_ALL           0xFFFFFFFF
+#define WL1251_PART_DOWN_MEM_START	0x0
+#define WL1251_PART_DOWN_MEM_SIZE	0x16800
+#define WL1251_PART_DOWN_REG_START	REGISTERS_BASE
+#define WL1251_PART_DOWN_REG_SIZE	REGISTERS_DOWN_SIZE
+
+#define WL1251_PART_WORK_MEM_START	0x28000
+#define WL1251_PART_WORK_MEM_SIZE	0x14000
+#define WL1251_PART_WORK_REG_START	REGISTERS_BASE
+#define WL1251_PART_WORK_REG_SIZE	REGISTERS_WORK_SIZE
+
+#define WL12XX_DEFAULT_LOW_RSSI_THRESHOLD       -75
+#define WL12XX_DEFAULT_LOW_RSSI_WEIGHT          10
+#define WL12XX_DEFAULT_LOW_RSSI_DEPTH           10
 
 #endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_init.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_init.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_init.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_init.c	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,423 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include "wl1251_init.h"
+#include "wl1251.h"
+#include "wl12xx_80211.h"
+#include "wl1251_acx.h"
+#include "wl1251_cmd.h"
+#include "wl1251_reg.h"
+
+int wl1251_hw_init_hwenc_config(struct wl1251 *wl)
+{
+	int ret;
+
+	ret = wl1251_acx_feature_cfg(wl);
+	if (ret < 0) {
+		wl1251_warning("couldn't set feature config");
+		return ret;
+	}
+
+	ret = wl1251_acx_default_key(wl, wl->default_key);
+	if (ret < 0) {
+		wl1251_warning("couldn't set default key");
+		return ret;
+	}
+
+	return 0;
+}
+
+int wl1251_hw_init_templates_config(struct wl1251 *wl)
+{
+	int ret;
+	u8 partial_vbm[PARTIAL_VBM_MAX];
+
+	/* send empty templates for fw memory reservation */
+	ret = wl1251_cmd_template_set(wl, CMD_PROBE_REQ, NULL,
+				      sizeof(struct wl12xx_probe_req_template));
+	if (ret < 0)
+		return ret;
+
+	ret = wl1251_cmd_template_set(wl, CMD_NULL_DATA, NULL,
+				      sizeof(struct wl12xx_null_data_template));
+	if (ret < 0)
+		return ret;
+
+	ret = wl1251_cmd_template_set(wl, CMD_PS_POLL, NULL,
+				      sizeof(struct wl12xx_ps_poll_template));
+	if (ret < 0)
+		return ret;
+
+	ret = wl1251_cmd_template_set(wl, CMD_QOS_NULL_DATA, NULL,
+				      sizeof
+				      (struct wl12xx_qos_null_data_template));
+	if (ret < 0)
+		return ret;
+
+	ret = wl1251_cmd_template_set(wl, CMD_PROBE_RESP, NULL,
+				      sizeof
+				      (struct wl12xx_probe_resp_template));
+	if (ret < 0)
+		return ret;
+
+	ret = wl1251_cmd_template_set(wl, CMD_BEACON, NULL,
+				      sizeof
+				      (struct wl12xx_beacon_template));
+	if (ret < 0)
+		return ret;
+
+	/* tim templates, first reserve space then allocate an empty one */
+	memset(partial_vbm, 0, PARTIAL_VBM_MAX);
+	ret = wl1251_cmd_vbm(wl, TIM_ELE_ID, partial_vbm, PARTIAL_VBM_MAX, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1251_cmd_vbm(wl, TIM_ELE_ID, partial_vbm, 1, 0);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+int wl1251_hw_init_rx_config(struct wl1251 *wl, u32 config, u32 filter)
+{
+	int ret;
+
+	ret = wl1251_acx_rx_msdu_life_time(wl, RX_MSDU_LIFETIME_DEF);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1251_acx_rx_config(wl, config, filter);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+int wl1251_hw_init_phy_config(struct wl1251 *wl)
+{
+	int ret;
+
+	ret = wl1251_acx_pd_threshold(wl);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1251_acx_slot(wl, DEFAULT_SLOT_TIME);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1251_acx_group_address_tbl(wl, NULL, 0, true);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1251_acx_service_period_timeout(wl);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1251_acx_rts_threshold(wl, RTS_THRESHOLD_DEF);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1251_acx_low_rssi(wl, WL12XX_DEFAULT_LOW_RSSI_THRESHOLD,
+				  WL12XX_DEFAULT_LOW_RSSI_WEIGHT,
+				  WL12XX_DEFAULT_LOW_RSSI_DEPTH,
+				  WL12XX_ACX_LOW_RSSI_TYPE_EDGE);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+int wl1251_hw_init_beacon_filter(struct wl1251 *wl)
+{
+	int ret;
+
+	/* disable beacon filtering at this stage */
+	ret = wl1251_acx_beacon_filter_opt(wl, false);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1251_acx_beacon_filter_table(wl);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+int wl1251_hw_init_pta(struct wl1251 *wl)
+{
+	int ret;
+
+	ret = wl1251_acx_sg_configure(wl, true);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+int wl1251_hw_init_energy_detection(struct wl1251 *wl)
+{
+	int ret;
+
+	ret = wl1251_acx_cca_threshold(wl);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+int wl1251_hw_init_beacon_broadcast(struct wl1251 *wl)
+{
+	int ret;
+
+	ret = wl1251_acx_bcn_dtim_options(wl);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+int wl1251_hw_init_power_auth(struct wl1251 *wl)
+{
+	return wl1251_acx_sleep_auth(wl, WL1251_PSM_CAM);
+}
+
+int wl1251_hw_init_mem_config(struct wl1251 *wl)
+{
+	int ret;
+
+	ret = wl1251_acx_mem_cfg(wl);
+	if (ret < 0)
+		return ret;
+
+	wl->target_mem_map = kzalloc(sizeof(struct wl1251_acx_mem_map),
+					  GFP_KERNEL);
+	if (!wl->target_mem_map) {
+		wl1251_error("couldn't allocate target memory map");
+		return -ENOMEM;
+	}
+
+	/* we now ask for the firmware built memory map */
+	ret = wl1251_acx_mem_map(wl, wl->target_mem_map,
+				 sizeof(struct wl1251_acx_mem_map));
+	if (ret < 0) {
+		wl1251_error("couldn't retrieve firmware memory map");
+		kfree(wl->target_mem_map);
+		wl->target_mem_map = NULL;
+		return ret;
+	}
+
+	return 0;
+}
+
+static int wl1251_hw_init_txq_fill(u8 qid,
+				   struct acx_tx_queue_qos_config *config,
+				   u32 num_blocks)
+{
+	config->qid = qid;
+
+	switch (qid) {
+	case QOS_AC_BE:
+		config->high_threshold =
+			(QOS_TX_HIGH_BE_DEF * num_blocks) / 100;
+		config->low_threshold =
+			(QOS_TX_LOW_BE_DEF * num_blocks) / 100;
+		break;
+	case QOS_AC_BK:
+		config->high_threshold =
+			(QOS_TX_HIGH_BK_DEF * num_blocks) / 100;
+		config->low_threshold =
+			(QOS_TX_LOW_BK_DEF * num_blocks) / 100;
+		break;
+	case QOS_AC_VI:
+		config->high_threshold =
+			(QOS_TX_HIGH_VI_DEF * num_blocks) / 100;
+		config->low_threshold =
+			(QOS_TX_LOW_VI_DEF * num_blocks) / 100;
+		break;
+	case QOS_AC_VO:
+		config->high_threshold =
+			(QOS_TX_HIGH_VO_DEF * num_blocks) / 100;
+		config->low_threshold =
+			(QOS_TX_LOW_VO_DEF * num_blocks) / 100;
+		break;
+	default:
+		wl1251_error("Invalid TX queue id: %d", qid);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int wl1251_hw_init_tx_queue_config(struct wl1251 *wl)
+{
+	struct acx_tx_queue_qos_config *config;
+	struct wl1251_acx_mem_map *wl_mem_map = wl->target_mem_map;
+	int ret, i;
+
+	wl1251_debug(DEBUG_ACX, "acx tx queue config");
+
+	config = kzalloc(sizeof(*config), GFP_KERNEL);
+	if (!config) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	for (i = 0; i < MAX_NUM_OF_AC; i++) {
+		ret = wl1251_hw_init_txq_fill(i, config,
+					      wl_mem_map->num_tx_mem_blocks);
+		if (ret < 0)
+			goto out;
+
+		ret = wl1251_cmd_configure(wl, ACX_TX_QUEUE_CFG,
+					   config, sizeof(*config));
+		if (ret < 0)
+			goto out;
+	}
+
+out:
+	kfree(config);
+	return ret;
+}
+
+static int wl1251_hw_init_data_path_config(struct wl1251 *wl)
+{
+	int ret;
+
+	/* asking for the data path parameters */
+	wl->data_path = kzalloc(sizeof(struct acx_data_path_params_resp),
+				GFP_KERNEL);
+	if (!wl->data_path) {
+		wl1251_error("Couldnt allocate data path parameters");
+		return -ENOMEM;
+	}
+
+	ret = wl1251_acx_data_path_params(wl, wl->data_path);
+	if (ret < 0) {
+		kfree(wl->data_path);
+		wl->data_path = NULL;
+		return ret;
+	}
+
+	return 0;
+}
+
+
+int wl1251_hw_init(struct wl1251 *wl)
+{
+	struct wl1251_acx_mem_map *wl_mem_map;
+	int ret;
+
+	ret = wl1251_hw_init_hwenc_config(wl);
+	if (ret < 0)
+		return ret;
+
+	/* Template settings */
+	ret = wl1251_hw_init_templates_config(wl);
+	if (ret < 0)
+		return ret;
+
+	/* Default memory configuration */
+	ret = wl1251_hw_init_mem_config(wl);
+	if (ret < 0)
+		return ret;
+
+	/* Default data path configuration  */
+	ret = wl1251_hw_init_data_path_config(wl);
+	if (ret < 0)
+		goto out_free_memmap;
+
+	/* RX config */
+	ret = wl1251_hw_init_rx_config(wl,
+				       RX_CFG_PROMISCUOUS | RX_CFG_TSF,
+				       RX_FILTER_OPTION_DEF);
+	/* RX_CONFIG_OPTION_ANY_DST_ANY_BSS,
+	   RX_FILTER_OPTION_FILTER_ALL); */
+	if (ret < 0)
+		goto out_free_data_path;
+
+	/* TX queues config */
+	ret = wl1251_hw_init_tx_queue_config(wl);
+	if (ret < 0)
+		goto out_free_data_path;
+
+	/* PHY layer config */
+	ret = wl1251_hw_init_phy_config(wl);
+	if (ret < 0)
+		goto out_free_data_path;
+
+	/* Initialize connection monitoring thresholds */
+	ret = wl1251_acx_conn_monit_params(wl);
+	if (ret < 0)
+		goto out_free_data_path;
+
+	/* Beacon filtering */
+	ret = wl1251_hw_init_beacon_filter(wl);
+	if (ret < 0)
+		goto out_free_data_path;
+
+	/* Bluetooth WLAN coexistence */
+	ret = wl1251_hw_init_pta(wl);
+	if (ret < 0)
+		goto out_free_data_path;
+
+	/* Energy detection */
+	ret = wl1251_hw_init_energy_detection(wl);
+	if (ret < 0)
+		goto out_free_data_path;
+
+	/* Beacons and boradcast settings */
+	ret = wl1251_hw_init_beacon_broadcast(wl);
+	if (ret < 0)
+		goto out_free_data_path;
+
+	/* Enable data path */
+	ret = wl1251_cmd_data_path(wl, wl->channel, 1);
+	if (ret < 0)
+		goto out_free_data_path;
+
+	/* Default power state */
+	ret = wl1251_hw_init_power_auth(wl);
+	if (ret < 0)
+		goto out_free_data_path;
+
+	wl_mem_map = wl->target_mem_map;
+	wl1251_info("%d tx blocks at 0x%x, %d rx blocks at 0x%x",
+		    wl_mem_map->num_tx_mem_blocks,
+		    wl->data_path->tx_control_addr,
+		    wl_mem_map->num_rx_mem_blocks,
+		    wl->data_path->rx_control_addr);
+
+	return 0;
+
+ out_free_data_path:
+	kfree(wl->data_path);
+
+ out_free_memmap:
+	kfree(wl->target_mem_map);
+
+	return ret;
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_init.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_init.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_init.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_init.h	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,41 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __WL1251_INIT_H__
+#define __WL1251_INIT_H__
+
+#include "wl1251.h"
+
+int wl1251_hw_init_hwenc_config(struct wl1251 *wl);
+int wl1251_hw_init_templates_config(struct wl1251 *wl);
+int wl1251_hw_init_rx_config(struct wl1251 *wl, u32 config, u32 filter);
+int wl1251_hw_init_phy_config(struct wl1251 *wl);
+int wl1251_hw_init_beacon_filter(struct wl1251 *wl);
+int wl1251_hw_init_pta(struct wl1251 *wl);
+int wl1251_hw_init_energy_detection(struct wl1251 *wl);
+int wl1251_hw_init_beacon_broadcast(struct wl1251 *wl);
+int wl1251_hw_init_power_auth(struct wl1251 *wl);
+int wl1251_hw_init_mem_config(struct wl1251 *wl);
+int wl1251_hw_init(struct wl1251 *wl);
+
+#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_main.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_main.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_main.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_main.c	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,2111 @@
+
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (C) 2008-2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/spi/spi.h>
+#include <linux/crc32.h>
+#include <linux/etherdevice.h>
+#include <linux/vmalloc.h>
+#include <linux/spi/wl12xx.h>
+#include <linux/inetdevice.h>
+
+#include "wl1251.h"
+#include "wl12xx_80211.h"
+#include "wl1251_reg.h"
+#include "wl1251_spi.h"
+#include "wl1251_event.h"
+#include "wl1251_tx.h"
+#include "wl1251_rx.h"
+#include "wl1251_ps.h"
+#include "wl1251_init.h"
+#include "wl1251_netlink.h"
+#include "wl1251_debugfs.h"
+#include "wl1251_boot.h"
+
+static ssize_t wl1251_sysfs_show_tx_mgmt_frm_rate(struct device *dev,
+						  struct device_attribute *attr,
+						  char *buf)
+{
+	struct wl1251 *wl = dev_get_drvdata(dev);
+	ssize_t len;
+	int val;
+
+	/* FIXME: what's the maximum length of buf? page size?*/
+	len = 500;
+
+	switch (wl->tx_mgmt_frm_rate) {
+		/* skip 1 and 12 Mbps because they have same value 0x0a */
+	case RATE_2MBPS:
+		val = 20;
+		break;
+	case RATE_5_5MBPS:
+		val = 55;
+		break;
+	case RATE_11MBPS:
+		val = 110;
+		break;
+	case RATE_6MBPS:
+		val = 60;
+		break;
+	case RATE_9MBPS:
+		val = 90;
+		break;
+	case RATE_12MBPS:
+		val = 120;
+		break;
+	case RATE_18MBPS:
+		val = 180;
+		break;
+	case RATE_24MBPS:
+		val = 240;
+		break;
+	case RATE_36MBPS:
+		val = 360;
+		break;
+	case RATE_48MBPS:
+		val = 480;
+		break;
+	case RATE_54MBPS:
+		val = 540;
+		break;
+	default:
+		val = 10;
+	}
+
+	/* for 1 and 12 Mbps we have to check the modulation */
+	if (wl->tx_mgmt_frm_rate == RATE_1MBPS) {
+		switch (wl->tx_mgmt_frm_rate) {
+		case CCK_LONG:
+			val = 10;
+			break;
+		case OFDM:
+			val = 120;
+			break;
+		default:
+			val = 10;
+			break;
+		}
+	}
+	len = snprintf(buf, len, "%d", val);
+
+	return len;
+}
+
+static ssize_t wl1251_sysfs_store_tx_mgmt_frm_rate(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct wl1251 *wl = dev_get_drvdata(dev);
+	unsigned long res;
+	int ret;
+
+	ret = strict_strtoul(buf, 10, &res);
+
+	if (ret < 0) {
+		wl1251_warning("incorrect value written to tx_mgmt_frm_rate");
+		return 0;
+	}
+
+	switch (res) {
+	case 10:
+		wl->tx_mgmt_frm_rate = RATE_1MBPS;
+		wl->tx_mgmt_frm_mod = CCK_LONG;
+		break;
+	case 20:
+		wl->tx_mgmt_frm_rate = RATE_2MBPS;
+		wl->tx_mgmt_frm_mod = CCK_LONG;
+		break;
+	case 55:
+		wl->tx_mgmt_frm_rate = RATE_5_5MBPS;
+		wl->tx_mgmt_frm_mod = CCK_LONG;
+		break;
+	case 110:
+		wl->tx_mgmt_frm_rate = RATE_11MBPS;
+		wl->tx_mgmt_frm_mod = CCK_LONG;
+		break;
+	case 60:
+		wl->tx_mgmt_frm_rate = RATE_6MBPS;
+		wl->tx_mgmt_frm_mod = OFDM;
+		break;
+	case 90:
+		wl->tx_mgmt_frm_rate = RATE_9MBPS;
+		wl->tx_mgmt_frm_mod = OFDM;
+		break;
+	case 120:
+		wl->tx_mgmt_frm_rate = RATE_12MBPS;
+		wl->tx_mgmt_frm_mod = OFDM;
+		break;
+	case 180:
+		wl->tx_mgmt_frm_rate = RATE_18MBPS;
+		wl->tx_mgmt_frm_mod = OFDM;
+		break;
+	case 240:
+		wl->tx_mgmt_frm_rate = RATE_24MBPS;
+		wl->tx_mgmt_frm_mod = OFDM;
+		break;
+	case 360:
+		wl->tx_mgmt_frm_rate = RATE_36MBPS;
+		wl->tx_mgmt_frm_mod = OFDM;
+		break;
+	case 480:
+		wl->tx_mgmt_frm_rate = RATE_48MBPS;
+		wl->tx_mgmt_frm_mod = OFDM;
+		break;
+	case 540:
+		wl->tx_mgmt_frm_rate = RATE_54MBPS;
+		wl->tx_mgmt_frm_mod = OFDM;
+		break;
+	default:
+		wl1251_warning("incorrect value written to tx_mgmt_frm_rate");
+		return 0;
+	}
+
+	return count;
+}
+
+static ssize_t wl1251_sysfs_show_bt_coex_mode(struct device *dev,
+					      struct device_attribute *attr,
+					      char *buf)
+{
+	struct wl1251 *wl = dev_get_drvdata(dev);
+	ssize_t len;
+
+	/* FIXME: what's the maximum length of buf? page size?*/
+	len = 500;
+
+	mutex_lock(&wl->mutex);
+	len = snprintf(buf, len, "%d\n\n%d - off\n%d - on\n%d - monoaudio\n",
+		       wl->bt_coex_mode,
+		       WL1251_BT_COEX_OFF,
+		       WL1251_BT_COEX_ENABLE,
+		       WL1251_BT_COEX_MONOAUDIO);
+	mutex_unlock(&wl->mutex);
+
+	return len;
+
+}
+
+static ssize_t wl1251_sysfs_store_bt_coex_mode(struct device *dev,
+					       struct device_attribute *attr,
+					       const char *buf, size_t count)
+{
+	struct wl1251 *wl = dev_get_drvdata(dev);
+	unsigned long res;
+	int ret;
+
+	ret = strict_strtoul(buf, 10, &res);
+
+	if (ret < 0) {
+		wl1251_warning("incorrect value written to bt_coex_mode");
+		return count;
+	}
+
+	mutex_lock(&wl->mutex);
+
+	switch (res) {
+	case WL1251_BT_COEX_OFF:
+	case WL1251_BT_COEX_ENABLE:
+	case WL1251_BT_COEX_MONOAUDIO:
+		wl->bt_coex_mode = res;
+		break;
+	default:
+		wl1251_warning("incorrect value written to bt_coex_mode");
+		goto out;
+	}
+
+	ret = wl1251_ps_elp_wakeup(wl);
+	if (ret < 0)
+		goto out;
+
+	wl1251_acx_sg_configure(wl, false);
+	wl1251_ps_elp_sleep(wl);
+
+ out:
+	mutex_unlock(&wl->mutex);
+	return count;
+}
+
+static DEVICE_ATTR(tx_mgmt_frm_rate, S_IRUGO | S_IWUSR,
+		   wl1251_sysfs_show_tx_mgmt_frm_rate,
+		   wl1251_sysfs_store_tx_mgmt_frm_rate);
+
+static DEVICE_ATTR(bt_coex_mode, S_IRUGO | S_IWUSR,
+		   wl1251_sysfs_show_bt_coex_mode,
+		   wl1251_sysfs_store_bt_coex_mode);
+
+static void wl1251_disable_interrupts(struct wl1251 *wl)
+{
+	disable_irq(wl->irq);
+}
+
+static void wl1251_power_off(struct wl1251 *wl)
+{
+	wl->set_power(false);
+}
+
+static void wl1251_power_on(struct wl1251 *wl)
+{
+	wl->set_power(true);
+}
+
+static irqreturn_t wl1251_irq(int irq, void *cookie)
+{
+	struct wl1251 *wl;
+
+	wl1251_debug(DEBUG_IRQ, "IRQ");
+
+	wl = cookie;
+
+	queue_work(wl->hw->workqueue, &wl->irq_work);
+
+	return IRQ_HANDLED;
+}
+
+static int wl1251_fetch_firmware(struct wl1251 *wl)
+{
+	const struct firmware *fw;
+	int ret;
+
+	ret = request_firmware(&fw, WL1251_FW_NAME, &wl->spi->dev);
+
+	if (ret < 0) {
+		wl1251_error("could not get firmware: %d", ret);
+		return ret;
+	}
+
+	if (fw->size % 4) {
+		wl1251_error("firmware size is not multiple of 32 bits: %zu",
+			     fw->size);
+		ret = -EILSEQ;
+		goto out;
+	}
+
+	wl->fw_len = fw->size;
+	wl->fw = vmalloc(wl->fw_len);
+
+	if (!wl->fw) {
+		wl1251_error("could not allocate memory for the firmware");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	memcpy(wl->fw, fw->data, wl->fw_len);
+
+	ret = 0;
+
+out:
+	release_firmware(fw);
+
+	return ret;
+}
+
+static int wl1251_fetch_nvs(struct wl1251 *wl)
+{
+	const struct firmware *fw;
+	int ret;
+
+	ret = request_firmware(&fw, WL1251_NVS_NAME, &wl->spi->dev);
+
+	if (ret < 0) {
+		wl1251_error("could not get nvs file: %d", ret);
+		return ret;
+	}
+
+	if (fw->size % 4) {
+		wl1251_error("nvs size is not multiple of 32 bits: %zu",
+			     fw->size);
+		ret = -EILSEQ;
+		goto out;
+	}
+
+	wl->nvs_len = fw->size;
+	wl->nvs = kmalloc(wl->nvs_len, GFP_KERNEL);
+
+	if (!wl->nvs) {
+		wl1251_error("could not allocate memory for the nvs file");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	memcpy(wl->nvs, fw->data, wl->nvs_len);
+
+	ret = 0;
+
+out:
+	release_firmware(fw);
+
+	return ret;
+}
+
+static void wl1251_fw_wakeup(struct wl1251 *wl)
+{
+	u32 elp_reg;
+
+	elp_reg = ELPCTRL_WAKE_UP;
+	wl1251_write32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, elp_reg);
+	elp_reg = wl1251_read32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR);
+
+	if (!(elp_reg & ELPCTRL_WLAN_READY))
+		wl1251_warning("WLAN not ready");
+}
+
+static int wl1251_chip_wakeup(struct wl1251 *wl)
+{
+	int ret = 0;
+
+	wl1251_power_on(wl);
+	msleep(WL1251_POWER_ON_SLEEP);
+	wl1251_spi_reset(wl);
+	wl1251_spi_init(wl);
+
+	/* We don't need a real memory partition here, because we only want
+	 * to use the registers at this point. */
+	wl1251_set_partition(wl,
+			     0x00000000,
+			     0x00000000,
+			     REGISTERS_BASE,
+			     REGISTERS_DOWN_SIZE);
+
+	/* ELP module wake up */
+	wl1251_fw_wakeup(wl);
+
+	/* whal_FwCtrl_BootSm() */
+
+	/* 0. read chip id from CHIP_ID */
+	wl->chip_id = wl1251_reg_read32(wl, CHIP_ID_B);
+
+	/* 1. check if chip id is valid */
+
+	switch (wl->chip_id) {
+	case CHIP_ID_1251_PG12:
+		wl1251_debug(DEBUG_BOOT, "chip id 0x%x (1251 PG12)",
+			     wl->chip_id);
+		break;
+	case CHIP_ID_1251_PG10:
+	case CHIP_ID_1251_PG11:
+	default:
+		wl1251_error("unsupported chip id: 0x%x", wl->chip_id);
+		ret = -ENODEV;
+		goto out;
+	}
+
+	if (wl->fw == NULL) {
+		ret = wl1251_fetch_firmware(wl);
+		if (ret < 0)
+			goto out;
+	}
+
+	/* No NVS from netlink, try to get it from the filesystem */
+	if (wl->nvs == NULL) {
+		ret = wl1251_fetch_nvs(wl);
+		if (ret < 0)
+			goto out;
+	}
+
+out:
+	return ret;
+}
+
+#define WL1251_IRQ_LOOP_COUNT 10
+static void wl1251_irq_work(struct work_struct *work)
+{
+	u32 intr, ctr = WL1251_IRQ_LOOP_COUNT;
+	struct wl1251 *wl =
+		container_of(work, struct wl1251, irq_work);
+	int ret;
+
+	mutex_lock(&wl->mutex);
+
+	wl1251_debug(DEBUG_IRQ, "IRQ work");
+
+	if (wl->state == WL1251_STATE_OFF)
+		goto out;
+
+	ret = wl1251_ps_elp_wakeup(wl);
+	if (ret < 0)
+		goto out;
+
+	wl1251_reg_write32(wl, ACX_REG_INTERRUPT_MASK, WL1251_ACX_INTR_ALL);
+
+	intr = wl1251_reg_read32(wl, ACX_REG_INTERRUPT_CLEAR);
+	wl1251_debug(DEBUG_IRQ, "intr: 0x%x", intr);
+
+	do {
+		if (wl->data_path) {
+			wl->rx_counter = wl1251_mem_read32(
+				wl, wl->data_path->rx_control_addr);
+
+			/* We handle a frmware bug here */
+			switch ((wl->rx_counter - wl->rx_handled) & 0xf) {
+			case 0:
+				wl1251_debug(DEBUG_IRQ,
+					     "RX: FW and host in sync");
+				intr &= ~WL1251_ACX_INTR_RX0_DATA;
+				intr &= ~WL1251_ACX_INTR_RX1_DATA;
+				break;
+			case 1:
+				wl1251_debug(DEBUG_IRQ, "RX: FW +1");
+				intr |= WL1251_ACX_INTR_RX0_DATA;
+				intr &= ~WL1251_ACX_INTR_RX1_DATA;
+				break;
+			case 2:
+				wl1251_debug(DEBUG_IRQ, "RX: FW +2");
+				intr |= WL1251_ACX_INTR_RX0_DATA;
+				intr |= WL1251_ACX_INTR_RX1_DATA;
+				break;
+			default:
+				wl1251_warning(
+					"RX: FW and host out of sync: %d",
+					wl->rx_counter - wl->rx_handled);
+				break;
+			}
+
+			wl->rx_handled = wl->rx_counter;
+
+			wl1251_debug(DEBUG_IRQ, "RX counter: %d",
+				     wl->rx_counter);
+		}
+
+		intr &= wl->intr_mask;
+
+		if (intr == 0) {
+			wl1251_debug(DEBUG_IRQ, "INTR is 0");
+			goto out_sleep;
+		}
+
+		if (intr & WL1251_ACX_INTR_RX0_DATA) {
+			wl1251_debug(DEBUG_IRQ, "WL1251_ACX_INTR_RX0_DATA");
+			wl1251_rx(wl);
+		}
+
+		if (intr & WL1251_ACX_INTR_RX1_DATA) {
+			wl1251_debug(DEBUG_IRQ, "WL1251_ACX_INTR_RX1_DATA");
+			wl1251_rx(wl);
+		}
+
+		if (intr & WL1251_ACX_INTR_TX_RESULT) {
+			wl1251_debug(DEBUG_IRQ, "WL1251_ACX_INTR_TX_RESULT");
+			wl1251_tx_complete(wl);
+		}
+
+		if (intr & (WL1251_ACX_INTR_EVENT_A |
+			    WL1251_ACX_INTR_EVENT_B)) {
+			wl1251_debug(DEBUG_IRQ, "WL1251_ACX_INTR_EVENT (0x%x)",
+				     intr);
+			if (intr & WL1251_ACX_INTR_EVENT_A)
+				wl1251_event_handle(wl, 0);
+			else
+				wl1251_event_handle(wl, 1);
+		}
+
+		if (intr & WL1251_ACX_INTR_INIT_COMPLETE)
+			wl1251_debug(DEBUG_IRQ,
+				     "WL1251_ACX_INTR_INIT_COMPLETE");
+
+		if (--ctr == 0)
+			break;
+
+		intr = wl1251_reg_read32(wl, ACX_REG_INTERRUPT_CLEAR);
+	} while (intr);
+
+out_sleep:
+	wl1251_reg_write32(wl, ACX_REG_INTERRUPT_MASK, ~(wl->intr_mask));
+	wl1251_ps_elp_sleep(wl);
+
+out:
+	mutex_unlock(&wl->mutex);
+}
+
+static int wl1251_join(struct wl1251 *wl, u8 bss_type, u8 channel,
+		       u16 beacon_interval, u8 dtim_period)
+{
+	int ret;
+
+	ret = wl1251_acx_frame_rates(wl, DEFAULT_HW_GEN_TX_RATE,
+				     DEFAULT_HW_GEN_MODULATION_TYPE,
+				     wl->tx_mgmt_frm_rate,
+				     wl->tx_mgmt_frm_mod);
+	if (ret < 0)
+		goto out;
+
+
+	ret = wl1251_cmd_join(wl, bss_type, channel, beacon_interval,
+			      dtim_period);
+	if (ret < 0)
+		goto out;
+
+	/*
+	 * FIXME: we should wait for JOIN_EVENT_COMPLETE_ID but to simplify
+	 * locking we just sleep instead, for now
+	 */
+	msleep(10);
+
+out:
+	return ret;
+}
+struct wl1251_filter_params {
+	unsigned int filters;
+	unsigned int changed;
+	int mc_list_length;
+	u8 mc_list[ACX_MC_ADDRESS_GROUP_MAX][ETH_ALEN];
+};
+
+#define WL1251_SUPPORTED_FILTERS (FIF_PROMISC_IN_BSS | \
+				  FIF_ALLMULTI | \
+				  FIF_FCSFAIL | \
+				  FIF_BCN_PRBRESP_PROMISC | \
+				  FIF_CONTROL | \
+				  FIF_OTHER_BSS)
+
+static void wl1251_filter_work(struct work_struct *work)
+{
+	struct wl1251 *wl =
+		container_of(work, struct wl1251, filter_work);
+	struct wl1251_filter_params *fp;
+	unsigned long flags;
+	bool enabled = true;
+	int ret;
+
+	/* first, get the filter parameters */
+	spin_lock_irqsave(&wl->wl_lock, flags);
+	fp = wl->filter_params;
+	wl->filter_params = NULL;
+	spin_unlock_irqrestore(&wl->wl_lock, flags);
+
+	if (!fp)
+		return;
+
+	/* then, lock the mutex without risk of lock-up */
+	mutex_lock(&wl->mutex);
+
+	if (wl->state == WL1251_STATE_OFF)
+		goto out;
+
+	ret = wl1251_ps_elp_wakeup(wl);
+	if (ret < 0)
+		goto out;
+
+	/* configure the mc filter regardless of the changed flags */
+	if (fp->filters & FIF_ALLMULTI)
+		enabled = false;
+
+	ret = wl1251_acx_group_address_tbl(wl, fp->mc_list, fp->mc_list_length,
+					   enabled);
+	if (ret < 0)
+		goto out_sleep;
+
+	/* determine, whether supported filter values have changed */
+	if (fp->changed == 0)
+		goto out;
+
+	/* apply configured filters */
+	ret = wl1251_acx_rx_config(wl, wl->rx_config, wl->rx_filter);
+	if (ret < 0)
+		goto out_sleep;
+
+out_sleep:
+	wl1251_ps_elp_sleep(wl);
+
+out:
+	mutex_unlock(&wl->mutex);
+	kfree(fp);
+}
+
+static int wl1251_plt_init(struct wl1251 *wl)
+{
+	int ret;
+
+	ret = wl1251_hw_init_mem_config(wl);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1251_cmd_data_path(wl, wl->channel, 1);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+int wl1251_plt_start(struct wl1251 *wl)
+{
+	int ret;
+
+	mutex_lock(&wl->mutex);
+
+	wl1251_notice("power up");
+
+	if (wl->state != WL1251_STATE_OFF) {
+		wl1251_error("cannot go into PLT state because not "
+			     "in off state: %d", wl->state);
+		ret = -EBUSY;
+		goto out;
+	}
+
+	wl->state = WL1251_STATE_PLT;
+
+	ret = wl1251_chip_wakeup(wl);
+	if (ret < 0)
+		goto out;
+
+	ret = wl1251_boot(wl);
+	if (ret < 0)
+		goto out;
+
+	wl1251_notice("firmware booted in PLT mode (%s)", wl->fw_ver);
+
+	ret = wl1251_plt_init(wl);
+	if (ret < 0)
+		goto out;
+
+out:
+	mutex_unlock(&wl->mutex);
+
+	return ret;
+}
+
+int wl1251_plt_stop(struct wl1251 *wl)
+{
+	int ret = 0;
+
+	mutex_lock(&wl->mutex);
+
+	wl1251_notice("power down");
+
+	if (wl->state != WL1251_STATE_PLT) {
+		wl1251_error("cannot power down because not in PLT "
+			     "state: %d", wl->state);
+		ret = -EBUSY;
+		goto out;
+	}
+
+	wl1251_disable_interrupts(wl);
+	wl1251_power_off(wl);
+
+	wl->state = WL1251_STATE_OFF;
+
+out:
+	mutex_unlock(&wl->mutex);
+
+	return ret;
+}
+
+
+static int wl1251_op_tx(struct ieee80211_hw *hw, struct sk_buff *skb)
+{
+	struct wl1251 *wl = hw->priv;
+
+	skb_queue_tail(&wl->tx_queue, skb);
+
+	/*
+	 * The chip specific setup must run before the first TX packet -
+	 * before that, the tx_work will not be initialized!
+	 */
+
+	queue_work(wl->hw->workqueue, &wl->tx_work);
+
+	/*
+	 * The workqueue is slow to process the tx_queue and we need stop
+	 * the queue here, otherwise the queue will get too long.
+	 */
+	if (skb_queue_len(&wl->tx_queue) >= WL1251_TX_QUEUE_MAX_LENGTH) {
+		ieee80211_stop_queues(wl->hw);
+
+		/*
+		 * FIXME: this is racy, the variable is not properly
+		 * protected. Maybe fix this by removing the stupid
+		 * variable altogether and checking the real queue state?
+		 */
+		wl->tx_queue_stopped = true;
+	}
+
+	return NETDEV_TX_OK;
+}
+
+static int wl1251_dev_notify(struct notifier_block *me, unsigned long what,
+			     void *arg)
+{
+	struct net_device *dev;
+	struct wireless_dev *wdev;
+	struct wiphy *wiphy;
+	struct ieee80211_hw *hw;
+	struct wl1251 *wl;
+	struct in_ifaddr *ifa = arg;
+	int ret = 0;
+
+	dev = ifa->ifa_dev->dev;
+
+	wdev = dev->ieee80211_ptr;
+	if (wdev == NULL)
+		return -ENODEV;
+
+	wiphy = wdev->wiphy;
+	if (wiphy == NULL)
+		return -ENODEV;
+
+	hw = wiphy_priv(wiphy);
+	if (hw == NULL)
+		return -ENODEV;
+
+	/* FIXME, we assume here that the notification was for wl12xx.
+	   That is not true if there are multiple WLAN adapters in the device.
+	   FIXME, we should probably not install ARP filter if the interface
+	   has multiple addresses.
+	*/
+	wl = hw->priv;
+
+	mutex_lock(&wl->mutex);
+
+	if (wl->state == WL1251_STATE_OFF)
+		goto out;
+
+	/* FIXME, add support for IPv6 */
+	if (what == NETDEV_UP) {
+		ret = wl1251_ps_elp_wakeup(wl);
+		if (ret < 0)
+			goto out;
+
+		ret = wl1251_acx_ip_config(wl, true, (u8 *)&ifa->ifa_address,
+					   IPV4_VERSION);
+		wl1251_ps_elp_sleep(wl);
+
+	} else if (what == NETDEV_DOWN) {
+		ret = wl1251_ps_elp_wakeup(wl);
+		if (ret < 0)
+			goto out;
+		ret = wl1251_acx_ip_config(wl, false, NULL, IPV4_VERSION);
+		wl1251_ps_elp_sleep(wl);
+	}
+out:
+	mutex_unlock(&wl->mutex);
+
+	return ret;
+}
+
+static struct notifier_block wl1251_dev_notifier = {
+	.notifier_call = wl1251_dev_notify,
+};
+
+static int wl1251_op_start(struct ieee80211_hw *hw)
+{
+	struct wl1251 *wl = hw->priv;
+	int ret = 0;
+
+	wl1251_debug(DEBUG_MAC80211, "mac80211 start");
+
+	mutex_lock(&wl->mutex);
+
+	if (wl->state != WL1251_STATE_OFF) {
+		wl1251_error("cannot start because not in off state: %d",
+			     wl->state);
+		ret = -EBUSY;
+		goto out;
+	}
+
+	ret = wl1251_chip_wakeup(wl);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1251_boot(wl);
+	if (ret < 0)
+		goto out;
+
+	ret = wl1251_hw_init(wl);
+	if (ret < 0)
+		goto out;
+
+	ret = wl1251_acx_station_id(wl);
+	if (ret < 0)
+		goto out;
+
+	wl->state = WL1251_STATE_ON;
+
+	wl1251_info("firmware booted (%s)", wl->fw_ver);
+
+out:
+	if (ret < 0)
+		wl1251_power_off(wl);
+
+	mutex_unlock(&wl->mutex);
+
+	register_inetaddr_notifier(&wl1251_dev_notifier);
+
+	return ret;
+}
+
+static void wl1251_op_stop(struct ieee80211_hw *hw)
+{
+	struct wl1251 *wl = hw->priv;
+	unsigned long flags;
+
+	wl1251_info("down");
+
+	wl1251_debug(DEBUG_MAC80211, "mac80211 stop");
+
+	/* complete/cancel ongoing work */
+	cancel_work_sync(&wl->filter_work);
+	spin_lock_irqsave(&wl->wl_lock, flags);
+	kfree(wl->filter_params);
+	wl->filter_params = NULL;
+	spin_unlock_irqrestore(&wl->wl_lock, flags);
+
+	unregister_inetaddr_notifier(&wl1251_dev_notifier);
+
+	mutex_lock(&wl->mutex);
+
+	WARN_ON(wl->state != WL1251_STATE_ON);
+
+	if (wl->scanning) {
+		mutex_unlock(&wl->mutex);
+		ieee80211_scan_completed(wl->hw);
+		mutex_lock(&wl->mutex);
+		wl->scanning = false;
+	}
+
+	wl->state = WL1251_STATE_OFF;
+
+	wl1251_disable_interrupts(wl);
+
+	mutex_unlock(&wl->mutex);
+
+	cancel_work_sync(&wl->irq_work);
+	cancel_work_sync(&wl->tx_work);
+	cancel_work_sync(&wl->filter_work);
+
+	mutex_lock(&wl->mutex);
+
+	/* let's notify MAC80211 about the remaining pending TX frames */
+	wl1251_tx_flush(wl);
+	wl1251_power_off(wl);
+
+	memset(wl->bssid, 0, ETH_ALEN);
+	memset(wl->ssid, 0, IW_ESSID_MAX_SIZE + 1);
+	wl->ssid_len = 0;
+	wl->listen_int = 1;
+	wl->bss_type = MAX_BSS_TYPE;
+
+	wl->data_in_count = 0;
+	wl->rx_counter = 0;
+	wl->rx_handled = 0;
+	wl->rx_current_buffer = 0;
+	wl->rx_last_id = 0;
+	wl->next_tx_complete = 0;
+	wl->elp = false;
+	wl->psm = 0;
+	wl->tx_queue_stopped = false;
+	wl->power_level = WL1251_DEFAULT_POWER_LEVEL;
+	wl->channel = WL1251_DEFAULT_CHANNEL;
+
+	wl1251_debugfs_reset(wl);
+
+	mutex_unlock(&wl->mutex);
+}
+
+static int wl1251_op_add_interface(struct ieee80211_hw *hw,
+				   struct ieee80211_if_init_conf *conf)
+{
+	struct wl1251 *wl = hw->priv;
+	DECLARE_MAC_BUF(mac);
+	int ret = 0;
+
+	wl1251_debug(DEBUG_MAC80211, "mac80211 add interface type %d mac %s",
+		     conf->type, print_mac(mac, conf->mac_addr));
+
+	mutex_lock(&wl->mutex);
+	if (wl->vif) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	wl->vif = conf->vif;
+
+	switch (conf->type) {
+	case NL80211_IFTYPE_STATION:
+		wl->bss_type = BSS_TYPE_STA_BSS;
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		wl->bss_type = BSS_TYPE_IBSS;
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+		goto out;
+	}
+
+	if (memcmp(wl->mac_addr, conf->mac_addr, ETH_ALEN)) {
+		memcpy(wl->mac_addr, conf->mac_addr, ETH_ALEN);
+		SET_IEEE80211_PERM_ADDR(wl->hw, wl->mac_addr);
+		ret = wl1251_acx_station_id(wl);
+		if (ret < 0)
+			goto out;
+	}
+
+out:
+	mutex_unlock(&wl->mutex);
+	return ret;
+}
+
+static void wl1251_op_remove_interface(struct ieee80211_hw *hw,
+					 struct ieee80211_if_init_conf *conf)
+{
+	struct wl1251 *wl = hw->priv;
+
+	mutex_lock(&wl->mutex);
+	wl1251_debug(DEBUG_MAC80211, "mac80211 remove interface");
+	wl->vif = NULL;
+	mutex_unlock(&wl->mutex);
+}
+
+static int wl1251_build_null_data(struct wl1251 *wl)
+{
+	struct wl12xx_null_data_template template;
+
+	if (!is_zero_ether_addr(wl->bssid)) {
+		memcpy(template.header.da, wl->bssid, ETH_ALEN);
+		memcpy(template.header.bssid, wl->bssid, ETH_ALEN);
+	} else {
+		memset(template.header.da, 0xff, ETH_ALEN);
+		memset(template.header.bssid, 0xff, ETH_ALEN);
+	}
+
+	memcpy(template.header.sa, wl->mac_addr, ETH_ALEN);
+	template.header.frame_ctl = cpu_to_le16(IEEE80211_FTYPE_DATA |
+						IEEE80211_STYPE_NULLFUNC);
+
+	return wl1251_cmd_template_set(wl, CMD_NULL_DATA, &template,
+				       sizeof(template));
+
+}
+
+static int wl1251_build_ps_poll(struct wl1251 *wl, u16 aid)
+{
+	struct wl12xx_ps_poll_template template;
+
+	memcpy(template.bssid, wl->bssid, ETH_ALEN);
+	memcpy(template.ta, wl->mac_addr, ETH_ALEN);
+
+	/* aid in PS-Poll has its two MSBs each set to 1 */
+	template.aid = cpu_to_le16(1 << 15 | 1 << 14 | aid);
+
+	template.fc = cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_PSPOLL);
+
+	return wl1251_cmd_template_set(wl, CMD_PS_POLL, &template,
+				       sizeof(template));
+
+}
+
+static void wl1251_update_support_rates(struct wl12xx_beacon_template *beacon)
+{
+	int index, rate_len;
+	u16 size;
+	struct wl12xx_ie_rates *rates;
+	struct wl12xx_ie_ssid *ssid;
+	u8 *ptr;
+
+	ptr = (u8 *)beacon;
+	size = sizeof(struct ieee80211_header);
+
+	ptr += size;
+	/* Pass through time stamp, beacon interval and capability */
+	ptr += (6 * sizeof(u16));
+
+	ssid = (struct wl12xx_ie_ssid *)ptr;
+	size = sizeof(struct wl12xx_ie_header) + ssid->header.len;
+	ptr += size;
+
+	rates = (struct wl12xx_ie_rates *)ptr;
+	rate_len = rates->header.len;
+	size = sizeof(struct wl12xx_ie_header) + rate_len;
+	for (index = 0; index < rate_len; index++) {
+		if (rates->rates[index] == IEEE80211_CCK_RATE_1MB) {
+			rates->rates[index] = IEEE80211_BASIC_RATE_MASK |
+					      IEEE80211_CCK_RATE_1MB;
+		}
+		if (rates->rates[index] == IEEE80211_CCK_RATE_2MB) {
+			rates->rates[index] = IEEE80211_BASIC_RATE_MASK |
+					      IEEE80211_CCK_RATE_2MB;
+		}
+		if (rates->rates[index] == IEEE80211_CCK_RATE_5MB) {
+			rates->rates[index] = IEEE80211_BASIC_RATE_MASK |
+					      IEEE80211_CCK_RATE_5MB;
+		}
+		if (rates->rates[index] == IEEE80211_CCK_RATE_11MB) {
+			rates->rates[index] = IEEE80211_BASIC_RATE_MASK |
+					      IEEE80211_CCK_RATE_11MB;
+		}
+	}
+}
+
+
+static int wl1251_op_config_interface(struct ieee80211_hw *hw,
+				      struct ieee80211_vif *vif,
+				      struct ieee80211_if_conf *conf)
+{
+	struct wl1251 *wl = hw->priv;
+	struct sk_buff *beacon;
+	DECLARE_MAC_BUF(mac);
+	int ret;
+
+	wl1251_debug(DEBUG_MAC80211, "mac80211 config_interface bssid %s",
+		     print_mac(mac, conf->bssid));
+	wl1251_dump_ascii(DEBUG_MAC80211, "ssid: ", conf->ssid,
+			  conf->ssid_len);
+
+	mutex_lock(&wl->mutex);
+
+	ret = wl1251_ps_elp_wakeup(wl);
+	if (ret < 0)
+		goto out;
+
+	memcpy(wl->bssid, conf->bssid, ETH_ALEN);
+
+	ret = wl1251_build_null_data(wl);
+	if (ret < 0)
+		goto out_sleep;
+
+	wl->ssid_len = conf->ssid_len;
+	if (wl->ssid_len)
+		memcpy(wl->ssid, conf->ssid, wl->ssid_len);
+
+	if (wl->bss_type != BSS_TYPE_IBSS) {
+		ret = wl1251_join(wl, wl->bss_type, wl->channel,
+				  wl->beacon_int, wl->dtim_period);
+		if (ret < 0)
+			goto out_sleep;
+	}
+
+	if (conf->changed & IEEE80211_IFCC_BEACON) {
+		beacon = ieee80211_beacon_get(hw, vif);
+		wl1251_update_support_rates((struct wl12xx_beacon_template *)
+					     beacon->data);
+
+		ret = wl1251_cmd_template_set(wl, CMD_BEACON, beacon->data,
+					      beacon->len);
+
+		if (ret < 0) {
+			dev_kfree_skb(beacon);
+			goto out_sleep;
+		}
+
+		ret = wl1251_cmd_template_set(wl, CMD_PROBE_RESP, beacon->data,
+					      beacon->len);
+
+		dev_kfree_skb(beacon);
+
+		if (ret < 0)
+			goto out_sleep;
+
+		ret = wl1251_join(wl, wl->bss_type, wl->channel,
+				  wl->beacon_int, wl->dtim_period);
+		if (ret < 0)
+			goto out_sleep;
+	}
+
+out_sleep:
+	wl1251_ps_elp_sleep(wl);
+
+out:
+	mutex_unlock(&wl->mutex);
+
+	return ret;
+}
+
+static int wl1251_op_config(struct ieee80211_hw *hw,
+			    struct ieee80211_conf *conf)
+{
+	struct wl1251 *wl = hw->priv;
+	int channel, ret = 0;
+
+	channel = ieee80211_frequency_to_channel(conf->channel->center_freq);
+
+	wl1251_debug(DEBUG_MAC80211, "mac80211 config ch %d psm %s power %d",
+		     channel,
+		     conf->flags & IEEE80211_CONF_PS ? "on" : "off",
+		     conf->power_level);
+
+	mutex_lock(&wl->mutex);
+
+	ret = wl1251_ps_elp_wakeup(wl);
+	if (ret < 0)
+		goto out;
+
+	if (channel != wl->channel) {
+		wl->channel = channel;
+
+		ret = wl1251_join(wl, wl->bss_type, wl->channel,
+				  wl->beacon_int, wl->dtim_period);
+		if (ret < 0)
+			goto out_sleep;
+	}
+
+	ret = wl1251_build_null_data(wl);
+	if (ret < 0)
+		goto out_sleep;
+
+	if (conf->flags & IEEE80211_CONF_PS && !wl->psm_requested) {
+		wl1251_debug(DEBUG_PSM, "psm enabled");
+
+		wl->psm_requested = true;
+
+		/*
+		 * We enter PSM only if we're already associated.
+		 * If we're not, we'll enter it when joining an SSID,
+		 * through the bss_info_changed() hook.
+		 */
+
+		ret = wl1251_ps_set_mode(wl, STATION_POWER_SAVE_MODE);
+	} else if (!(conf->flags & IEEE80211_CONF_PS) &&
+		   wl->psm_requested) {
+		wl1251_debug(DEBUG_PSM, "psm disabled");
+
+		wl->psm_requested = false;
+
+		if (wl->psm)
+			ret = wl1251_ps_set_mode(wl, STATION_ACTIVE_MODE);
+	}
+
+	if (conf->power_level != wl->power_level) {
+		ret = wl1251_acx_tx_power(wl, conf->power_level);
+		if (ret < 0)
+			goto out;
+
+		wl->power_level = conf->power_level;
+	}
+
+out_sleep:
+	wl1251_ps_elp_sleep(wl);
+
+out:
+	mutex_unlock(&wl->mutex);
+
+	return ret;
+}
+
+static void wl1251_op_configure_filter(struct ieee80211_hw *hw,
+				       unsigned int changed,
+				       unsigned int *total,
+				       int mc_count,
+				       struct dev_addr_list *mc_list)
+{
+	struct wl1251 *wl = hw->priv;
+	struct wl1251_filter_params *fp;
+	struct dev_addr_list *mc;
+	unsigned long flags;
+	int i;
+	DECLARE_MAC_BUF(mac);
+
+	wl1251_debug(DEBUG_MAC80211, "mac80211 configure filter");
+
+	*total &= WL1251_SUPPORTED_FILTERS;
+	changed &= WL1251_SUPPORTED_FILTERS;
+
+	fp = kzalloc(sizeof(*fp), GFP_ATOMIC);
+	if (!fp) {
+		wl1251_error("Out of memory setting filters.");
+		return;
+	}
+
+	/* store current filter config */
+	fp->filters = *total;
+	fp->changed = changed;
+
+	/* update multicast filtering parameters */
+	if (mc_count > ACX_MC_ADDRESS_GROUP_MAX) {
+		mc_count = 0;
+		fp->filters |= FIF_ALLMULTI;
+	}
+
+	fp->mc_list_length = 0;
+	mc = mc_list;
+	for (i = 0; i < mc_count; i++) {
+		if (mc->da_addrlen == ETH_ALEN) {
+			wl1251_debug(DEBUG_MAC80211, "multicast mac %s",
+				     print_mac(mac, mc->da_addr));
+			memcpy(fp->mc_list[fp->mc_list_length],
+			       mc->da_addr, ETH_ALEN);
+			fp->mc_list_length++;
+		} else {
+			wl1251_warning("Unknown mc address length.");
+		}
+		mc = mc->next;
+	}
+
+	spin_lock_irqsave(&wl->wl_lock, flags);
+	kfree(wl->filter_params);
+	wl->filter_params = fp;
+	spin_unlock_irqrestore(&wl->wl_lock, flags);
+
+	if (changed == 0)
+		/* no filters which we support changed */
+		goto out;
+
+	/* FIXME: wl->rx_config and wl->rx_filter are not protected */
+
+	wl->rx_config = WL1251_DEFAULT_RX_CONFIG;
+	wl->rx_filter = WL1251_DEFAULT_RX_FILTER;
+
+	if (*total & FIF_PROMISC_IN_BSS) {
+		wl->rx_config |= CFG_BSSID_FILTER_EN;
+		wl->rx_config |= CFG_RX_ALL_GOOD;
+	}
+	if (*total & FIF_ALLMULTI)
+		/*
+		 * CFG_MC_FILTER_EN in rx_config needs to be 0 to receive
+		 * all multicast frames
+		 */
+		wl->rx_config &= ~CFG_MC_FILTER_EN;
+	if (*total & FIF_FCSFAIL)
+		wl->rx_filter |= CFG_RX_FCS_ERROR;
+	if (*total & FIF_BCN_PRBRESP_PROMISC) {
+		wl->rx_config &= ~CFG_BSSID_FILTER_EN;
+		wl->rx_config &= ~CFG_SSID_FILTER_EN;
+	}
+	if (*total & FIF_CONTROL)
+		wl->rx_filter |= CFG_RX_CTL_EN;
+	if (*total & FIF_OTHER_BSS)
+		wl->rx_filter &= ~CFG_BSSID_FILTER_EN;
+
+out:
+	queue_work(wl->hw->workqueue, &wl->filter_work);
+}
+
+/* HW encryption */
+static int wl1251_set_key_type(struct wl1251 *wl,
+			       struct wl1251_cmd_set_keys *key,
+			       enum set_key_cmd cmd,
+			       struct ieee80211_key_conf *mac80211_key,
+			       const u8 *addr)
+{
+	switch (mac80211_key->alg) {
+	case ALG_WEP:
+		if (is_broadcast_ether_addr(addr))
+			key->key_type = KEY_WEP_DEFAULT;
+		else
+			key->key_type = KEY_WEP_ADDR;
+
+		mac80211_key->hw_key_idx = mac80211_key->keyidx;
+		break;
+	case ALG_TKIP:
+		if (is_broadcast_ether_addr(addr))
+			key->key_type = KEY_TKIP_MIC_GROUP;
+		else
+			key->key_type = KEY_TKIP_MIC_PAIRWISE;
+
+		mac80211_key->hw_key_idx = mac80211_key->keyidx;
+		break;
+	case ALG_CCMP:
+		if (is_broadcast_ether_addr(addr))
+			key->key_type = KEY_AES_GROUP;
+		else
+			key->key_type = KEY_AES_PAIRWISE;
+		mac80211_key->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;
+		break;
+	default:
+		wl1251_error("Unknown key algo 0x%x", mac80211_key->alg);
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int wl1251_op_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
+			     const u8 *local_addr, const u8 *addr,
+			     struct ieee80211_key_conf *key)
+{
+	struct wl1251 *wl = hw->priv;
+	struct wl1251_cmd_set_keys *wl_cmd;
+	int ret;
+
+	wl1251_debug(DEBUG_MAC80211, "mac80211 set key");
+
+	wl_cmd = kzalloc(sizeof(*wl_cmd), GFP_KERNEL);
+	if (!wl_cmd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	wl1251_debug(DEBUG_CRYPT, "CMD: 0x%x", cmd);
+	wl1251_dump(DEBUG_CRYPT, "ADDR: ", addr, ETH_ALEN);
+	wl1251_dump(DEBUG_CRYPT, "LOCAL_ADDR: ", local_addr, ETH_ALEN);
+	wl1251_debug(DEBUG_CRYPT, "Key: algo:0x%x, id:%d, len:%d flags 0x%x",
+		     key->alg, key->keyidx, key->keylen, key->flags);
+	wl1251_dump(DEBUG_CRYPT, "KEY: ", key->key, key->keylen);
+
+	if (is_zero_ether_addr(addr)) {
+		/* We dont support TX only encryption */
+		ret = -EOPNOTSUPP;
+		goto out;
+	}
+
+	mutex_lock(&wl->mutex);
+
+	ret = wl1251_ps_elp_wakeup(wl);
+	if (ret < 0)
+		goto out_unlock;
+
+	switch (cmd) {
+	case SET_KEY:
+		wl_cmd->key_action = KEY_ADD_OR_REPLACE;
+		break;
+	case DISABLE_KEY:
+		wl_cmd->key_action = KEY_REMOVE;
+		break;
+	default:
+		wl1251_error("Unsupported key cmd 0x%x", cmd);
+		break;
+	}
+
+	ret = wl1251_set_key_type(wl, wl_cmd, cmd, key, addr);
+	if (ret < 0) {
+		wl1251_error("Set KEY type failed");
+		goto out_sleep;
+	}
+
+	if (wl_cmd->key_type != KEY_WEP_DEFAULT)
+		memcpy(wl_cmd->addr, addr, ETH_ALEN);
+
+	if ((wl_cmd->key_type == KEY_TKIP_MIC_GROUP) ||
+	    (wl_cmd->key_type == KEY_TKIP_MIC_PAIRWISE)) {
+		/*
+		 * We get the key in the following form:
+		 * TKIP (16 bytes) - TX MIC (8 bytes) - RX MIC (8 bytes)
+		 * but the target is expecting:
+		 * TKIP - RX MIC - TX MIC
+		 */
+		memcpy(wl_cmd->key, key->key, 16);
+		memcpy(wl_cmd->key + 16, key->key + 24, 8);
+		memcpy(wl_cmd->key + 24, key->key + 16, 8);
+
+	} else {
+		memcpy(wl_cmd->key, key->key, key->keylen);
+	}
+	wl_cmd->key_size = key->keylen;
+
+	wl_cmd->id = key->keyidx;
+	wl_cmd->ssid_profile = 0;
+
+	wl1251_dump(DEBUG_CRYPT, "TARGET KEY: ", wl_cmd, sizeof(*wl_cmd));
+
+	ret = wl1251_cmd_send(wl, CMD_SET_KEYS, wl_cmd, sizeof(*wl_cmd));
+	if (ret < 0) {
+		wl1251_warning("could not set keys");
+		goto out_sleep;
+	}
+
+out_sleep:
+	wl1251_ps_elp_sleep(wl);
+
+out_unlock:
+	mutex_unlock(&wl->mutex);
+
+out:
+	kfree(wl_cmd);
+
+	return ret;
+}
+
+static int wl1251_build_basic_rates(char *rates)
+{
+	u8 index = 0;
+
+	rates[index++] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_1MB;
+	rates[index++] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_2MB;
+	rates[index++] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_5MB;
+	rates[index++] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_11MB;
+
+	return index;
+}
+
+static int wl1251_build_extended_rates(char *rates)
+{
+	u8 index = 0;
+
+	rates[index++] = IEEE80211_OFDM_RATE_6MB;
+	rates[index++] = IEEE80211_OFDM_RATE_9MB;
+	rates[index++] = IEEE80211_OFDM_RATE_12MB;
+	rates[index++] = IEEE80211_OFDM_RATE_18MB;
+	rates[index++] = IEEE80211_OFDM_RATE_24MB;
+	rates[index++] = IEEE80211_OFDM_RATE_36MB;
+	rates[index++] = IEEE80211_OFDM_RATE_48MB;
+	rates[index++] = IEEE80211_OFDM_RATE_54MB;
+
+	return index;
+}
+
+
+static int wl1251_build_probe_req(struct wl1251 *wl, u8 *ssid, size_t ssid_len)
+{
+	struct wl12xx_probe_req_template template;
+	struct wl12xx_ie_rates *rates;
+	char *ptr;
+	u16 size;
+
+	ptr = (char *)&template;
+	size = sizeof(struct ieee80211_header);
+
+	memset(template.header.da, 0xff, ETH_ALEN);
+	memset(template.header.bssid, 0xff, ETH_ALEN);
+	memcpy(template.header.sa, wl->mac_addr, ETH_ALEN);
+	template.header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_PROBE_REQ);
+
+	/* IEs */
+	/* SSID */
+	template.ssid.header.id = WLAN_EID_SSID;
+	template.ssid.header.len = ssid_len;
+	if (ssid_len && ssid)
+		memcpy(template.ssid.ssid, ssid, ssid_len);
+	size += sizeof(struct wl12xx_ie_header) + ssid_len;
+	ptr += size;
+
+	/* Basic Rates */
+	rates = (struct wl12xx_ie_rates *)ptr;
+	rates->header.id = WLAN_EID_SUPP_RATES;
+	rates->header.len = wl1251_build_basic_rates(rates->rates);
+	size += sizeof(struct wl12xx_ie_header) + rates->header.len;
+	ptr += sizeof(struct wl12xx_ie_header) + rates->header.len;
+
+	/* Extended rates */
+	rates = (struct wl12xx_ie_rates *)ptr;
+	rates->header.id = WLAN_EID_EXT_SUPP_RATES;
+	rates->header.len = wl1251_build_extended_rates(rates->rates);
+	size += sizeof(struct wl12xx_ie_header) + rates->header.len;
+
+	wl1251_dump(DEBUG_SCAN, "PROBE REQ: ", &template, size);
+
+	return wl1251_cmd_template_set(wl, CMD_PROBE_REQ, &template,
+				      size);
+}
+
+static int wl1251_hw_scan(struct wl1251 *wl, u8 *ssid, size_t len,
+			  u8 active_scan, u8 high_prio, u8 num_channels,
+			  u8 probe_requests)
+{
+	struct wl1251_cmd_trigger_scan_to *trigger = NULL;
+	struct cmd_scan *params = NULL;
+	int i, ret;
+	u16 scan_options = 0;
+
+	if (wl->scanning)
+		return -EINVAL;
+
+	params = kzalloc(sizeof(*params), GFP_KERNEL);
+	if (!params)
+		return -ENOMEM;
+
+	params->params.rx_config_options = cpu_to_le32(CFG_RX_ALL_GOOD);
+	params->params.rx_filter_options =
+		cpu_to_le32(CFG_RX_PRSP_EN | CFG_RX_MGMT_EN | CFG_RX_BCN_EN);
+
+	/* High priority scan */
+	if (!active_scan)
+		scan_options |= SCAN_PASSIVE;
+	if (high_prio)
+		scan_options |= SCAN_PRIORITY_HIGH;
+	params->params.scan_options = scan_options;
+
+	params->params.num_channels = num_channels;
+	params->params.num_probe_requests = probe_requests;
+	params->params.tx_rate = cpu_to_le16(1 << 1); /* 2 Mbps */
+	params->params.tid_trigger = 0;
+
+	for (i = 0; i < num_channels; i++) {
+		params->channels[i].min_duration = cpu_to_le32(30000);
+		params->channels[i].max_duration = cpu_to_le32(60000);
+		memset(&params->channels[i].bssid_lsb, 0xff, 4);
+		memset(&params->channels[i].bssid_msb, 0xff, 2);
+		params->channels[i].early_termination = 0;
+		params->channels[i].tx_power_att = 0;
+		params->channels[i].channel = i + 1;
+		memset(params->channels[i].pad, 0, 3);
+	}
+
+	for (i = num_channels; i < SCAN_MAX_NUM_OF_CHANNELS; i++)
+		memset(&params->channels[i], 0,
+		       sizeof(struct basic_scan_channel_parameters));
+
+	if (len && ssid) {
+		params->params.ssid_len = len;
+		memcpy(params->params.ssid, ssid, len);
+	} else {
+		params->params.ssid_len = 0;
+		memset(params->params.ssid, 0, 32);
+	}
+
+	ret = wl1251_build_probe_req(wl, ssid, len);
+	if (ret < 0) {
+		wl1251_error("PROBE request template failed");
+		goto out;
+	}
+
+	trigger = kzalloc(sizeof(*trigger), GFP_KERNEL);
+	if (!trigger)
+		goto out;
+
+	trigger->timeout = 0;
+
+	ret = wl1251_cmd_send(wl, CMD_TRIGGER_SCAN_TO, trigger,
+			      sizeof(*trigger));
+	if (ret < 0) {
+		wl1251_error("trigger scan to failed for hw scan");
+		goto out;
+	}
+
+	wl1251_dump(DEBUG_SCAN, "SCAN: ", params, sizeof(*params));
+
+	wl->scanning = true;
+
+	ret = wl1251_cmd_send(wl, CMD_SCAN, params, sizeof(*params));
+	if (ret < 0)
+		wl1251_error("SCAN failed");
+
+	wl1251_spi_mem_read(wl, wl->cmd_box_addr, params, sizeof(*params));
+
+	if (params->header.status != CMD_STATUS_SUCCESS) {
+		wl1251_error("TEST command answer error: %d",
+			     params->header.status);
+		wl->scanning = false;
+		ret = -EIO;
+		goto out;
+	}
+
+out:
+	kfree(params);
+	return ret;
+
+}
+
+static int wl1251_op_hw_scan(struct ieee80211_hw *hw, u8 *ssid, size_t len)
+{
+	struct wl1251 *wl = hw->priv;
+	int ret;
+
+	wl1251_debug(DEBUG_MAC80211, "mac80211 hw scan");
+
+	mutex_lock(&wl->mutex);
+
+	ret = wl1251_ps_elp_wakeup(wl);
+	if (ret < 0)
+		goto out;
+
+	ret = wl1251_hw_scan(hw->priv, ssid, len, 1, 0, 13, 3);
+
+	wl1251_ps_elp_sleep(wl);
+
+out:
+	mutex_unlock(&wl->mutex);
+
+	return ret;
+}
+
+static int wl1251_op_set_rts_threshold(struct ieee80211_hw *hw, u32 value)
+{
+	struct wl1251 *wl = hw->priv;
+	int ret;
+
+	mutex_lock(&wl->mutex);
+
+	ret = wl1251_ps_elp_wakeup(wl);
+	if (ret < 0)
+		goto out;
+
+	ret = wl1251_acx_rts_threshold(wl, (u16) value);
+	if (ret < 0)
+		wl1251_warning("wl1251_op_set_rts_threshold failed: %d", ret);
+
+	wl1251_ps_elp_sleep(wl);
+
+out:
+	mutex_unlock(&wl->mutex);
+
+	return ret;
+}
+
+static void wl1251_op_bss_info_changed(struct ieee80211_hw *hw,
+				       struct ieee80211_vif *vif,
+				       struct ieee80211_bss_conf *bss_conf,
+				       u32 changed)
+{
+	enum wl1251_cmd_ps_mode mode;
+	struct wl1251 *wl = hw->priv;
+	int ret;
+
+	wl1251_debug(DEBUG_MAC80211, "mac80211 bss info changed");
+
+	mutex_lock(&wl->mutex);
+
+	ret = wl1251_ps_elp_wakeup(wl);
+	if (ret < 0)
+		goto out;
+
+	if (changed & BSS_CHANGED_ASSOC) {
+		if (bss_conf->assoc) {
+			wl->beacon_int = bss_conf->beacon_int;
+			wl->dtim_period = bss_conf->dtim_period;
+
+			ret = wl1251_acx_wr_tbtt_and_dtim(wl, wl->beacon_int,
+							  wl->dtim_period);
+			wl->aid = bss_conf->aid;
+
+			ret = wl1251_build_ps_poll(wl, wl->aid);
+			if (ret < 0)
+				goto out_sleep;
+
+			ret = wl1251_acx_aid(wl, wl->aid);
+			if (ret < 0)
+				goto out_sleep;
+
+			/* If we want to go in PSM but we're not there yet */
+			if (wl->psm_requested && !wl->psm) {
+				mode = STATION_POWER_SAVE_MODE;
+				ret = wl1251_ps_set_mode(wl, mode);
+				if (ret < 0)
+					goto out_sleep;
+			}
+		} else {
+			/* use defaults when not associated */
+			wl->beacon_int = WL1251_DEFAULT_BEACON_INT;
+			wl->dtim_period = WL1251_DEFAULT_DTIM_PERIOD;
+		}
+	}
+	if (changed & BSS_CHANGED_ERP_SLOT) {
+		if (bss_conf->use_short_slot)
+			ret = wl1251_acx_slot(wl, SLOT_TIME_SHORT);
+		else
+			ret = wl1251_acx_slot(wl, SLOT_TIME_LONG);
+		if (ret < 0) {
+			wl1251_warning("Set slot time failed %d", ret);
+			goto out_sleep;
+		}
+	}
+
+	if (changed & BSS_CHANGED_ERP_PREAMBLE) {
+		if (bss_conf->use_short_preamble)
+			wl1251_acx_set_preamble(wl, ACX_PREAMBLE_SHORT);
+		else
+			wl1251_acx_set_preamble(wl, ACX_PREAMBLE_LONG);
+	}
+
+	if (changed & BSS_CHANGED_ERP_CTS_PROT) {
+		if (bss_conf->use_cts_prot)
+			ret = wl1251_acx_cts_protect(wl, CTSPROTECT_ENABLE);
+		else
+			ret = wl1251_acx_cts_protect(wl, CTSPROTECT_DISABLE);
+		if (ret < 0) {
+			wl1251_warning("Set ctsprotect failed %d", ret);
+			goto out_sleep;
+		}
+	}
+
+out_sleep:
+	wl1251_ps_elp_sleep(wl);
+
+out:
+	mutex_unlock(&wl->mutex);
+}
+
+/* can't be const, mac80211 writes to this */
+static struct ieee80211_rate wl1251_rates[] = {
+	{ .bitrate = 10,
+	  .hw_value = 0x1,
+	  .hw_value_short = 0x1, },
+	{ .bitrate = 20,
+	  .hw_value = 0x2,
+	  .hw_value_short = 0x2,
+	  .flags = IEEE80211_RATE_SHORT_PREAMBLE },
+	{ .bitrate = 55,
+	  .hw_value = 0x4,
+	  .hw_value_short = 0x4,
+	  .flags = IEEE80211_RATE_SHORT_PREAMBLE },
+	{ .bitrate = 110,
+	  .hw_value = 0x20,
+	  .hw_value_short = 0x20,
+	  .flags = IEEE80211_RATE_SHORT_PREAMBLE },
+	{ .bitrate = 60,
+	  .hw_value = 0x8,
+	  .hw_value_short = 0x8, },
+	{ .bitrate = 90,
+	  .hw_value = 0x10,
+	  .hw_value_short = 0x10, },
+	{ .bitrate = 120,
+	  .hw_value = 0x40,
+	  .hw_value_short = 0x40, },
+	{ .bitrate = 180,
+	  .hw_value = 0x80,
+	  .hw_value_short = 0x80, },
+	{ .bitrate = 240,
+	  .hw_value = 0x200,
+	  .hw_value_short = 0x200, },
+	{ .bitrate = 360,
+	 .hw_value = 0x400,
+	 .hw_value_short = 0x400, },
+	{ .bitrate = 480,
+	  .hw_value = 0x800,
+	  .hw_value_short = 0x800, },
+	{ .bitrate = 540,
+	  .hw_value = 0x1000,
+	  .hw_value_short = 0x1000, },
+};
+
+/* can't be const, mac80211 writes to this */
+static struct ieee80211_channel wl1251_channels[] = {
+	{ .hw_value = 1, .center_freq = 2412},
+	{ .hw_value = 2, .center_freq = 2417},
+	{ .hw_value = 3, .center_freq = 2422},
+	{ .hw_value = 4, .center_freq = 2427},
+	{ .hw_value = 5, .center_freq = 2432},
+	{ .hw_value = 6, .center_freq = 2437},
+	{ .hw_value = 7, .center_freq = 2442},
+	{ .hw_value = 8, .center_freq = 2447},
+	{ .hw_value = 9, .center_freq = 2452},
+	{ .hw_value = 10, .center_freq = 2457},
+	{ .hw_value = 11, .center_freq = 2462},
+	{ .hw_value = 12, .center_freq = 2467},
+	{ .hw_value = 13, .center_freq = 2472},
+};
+
+/* can't be const, mac80211 writes to this */
+static struct ieee80211_supported_band wl1251_band_2ghz = {
+	.channels = wl1251_channels,
+	.n_channels = ARRAY_SIZE(wl1251_channels),
+	.bitrates = wl1251_rates,
+	.n_bitrates = ARRAY_SIZE(wl1251_rates),
+};
+
+static const struct ieee80211_ops wl1251_ops = {
+	.start = wl1251_op_start,
+	.stop = wl1251_op_stop,
+	.add_interface = wl1251_op_add_interface,
+	.remove_interface = wl1251_op_remove_interface,
+	.config = wl1251_op_config,
+	.config_interface = wl1251_op_config_interface,
+	.configure_filter = wl1251_op_configure_filter,
+	.tx = wl1251_op_tx,
+	.set_key = wl1251_op_set_key,
+	.hw_scan = wl1251_op_hw_scan,
+	.bss_info_changed = wl1251_op_bss_info_changed,
+	.set_rts_threshold = wl1251_op_set_rts_threshold,
+};
+
+static int wl1251_register_hw(struct wl1251 *wl)
+{
+	int ret;
+
+	if (wl->mac80211_registered)
+		return 0;
+
+	SET_IEEE80211_PERM_ADDR(wl->hw, wl->mac_addr);
+
+	ret = ieee80211_register_hw(wl->hw);
+	if (ret < 0) {
+		wl1251_error("unable to register mac80211 hw: %d", ret);
+		return ret;
+	}
+
+	wl->mac80211_registered = true;
+
+	wl1251_notice("loaded");
+
+	return 0;
+}
+
+static int wl1251_init_ieee80211(struct wl1251 *wl)
+{
+	/* The tx descriptor buffer and the TKIP space */
+	wl->hw->extra_tx_headroom = sizeof(struct tx_double_buffer_desc)
+		+ WL1251_TKIP_IV_SPACE;
+
+	/* unit us */
+	/* FIXME: find a proper value */
+	wl->hw->channel_change_time = 10000;
+
+	wl->hw->flags = IEEE80211_HW_SIGNAL_DBM |
+		IEEE80211_HW_NOISE_DBM |
+		IEEE80211_HW_BEACON_FILTER;
+
+	wl->hw->wiphy->bands[IEEE80211_BAND_2GHZ] = &wl1251_band_2ghz;
+
+	SET_IEEE80211_DEV(wl->hw, &wl->spi->dev);
+
+	return 0;
+}
+
+static void wl1251_device_release(struct device *dev)
+{
+
+}
+
+static struct platform_device wl1251_device = {
+	/* FIXME: use wl12xx name to not break the user space */
+	.name		= "wl12xx",
+	.id		= -1,
+
+	/* device model insists to have a release function */
+	.dev            = {
+		.release = wl1251_device_release,
+	},
+};
+
+static int __devinit wl1251_probe(struct spi_device *spi)
+{
+	struct wl12xx_platform_data *pdata;
+	struct ieee80211_hw *hw;
+	struct wl1251 *wl;
+	int ret, i;
+	static const u8 nokia_oui[3] = {0x00, 0x1f, 0xdf};
+
+	pdata = spi->dev.platform_data;
+	if (!pdata) {
+		wl1251_error("no platform data");
+		return -ENODEV;
+	}
+
+	hw = ieee80211_alloc_hw(sizeof(*wl), &wl1251_ops);
+	if (!hw) {
+		wl1251_error("could not alloc ieee80211_hw");
+		return -ENOMEM;
+	}
+
+	wl = hw->priv;
+	memset(wl, 0, sizeof(*wl));
+
+	wl->hw = hw;
+	dev_set_drvdata(&spi->dev, wl);
+	wl->spi = spi;
+
+	wl->data_in_count = 0;
+
+	skb_queue_head_init(&wl->tx_queue);
+
+	INIT_WORK(&wl->filter_work, wl1251_filter_work);
+	INIT_DELAYED_WORK(&wl->elp_work, wl1251_elp_work);
+	wl->channel = WL1251_DEFAULT_CHANNEL;
+	wl->scanning = false;
+	wl->default_key = 0;
+	wl->listen_int = 1;
+	wl->rx_counter = 0;
+	wl->rx_handled = 0;
+	wl->rx_current_buffer = 0;
+	wl->rx_last_id = 0;
+	wl->rx_config = WL1251_DEFAULT_RX_CONFIG;
+	wl->rx_filter = WL1251_DEFAULT_RX_FILTER;
+	wl->elp = false;
+	wl->psm = 0;
+	wl->psm_requested = false;
+	wl->tx_queue_stopped = false;
+	wl->power_level = WL1251_DEFAULT_POWER_LEVEL;
+	wl->beacon_int = WL1251_DEFAULT_BEACON_INT;
+	wl->dtim_period = WL1251_DEFAULT_DTIM_PERIOD;
+	wl->vif = NULL;
+	wl->bt_coex_mode = WL1251_BT_COEX_OFF;
+
+	for (i = 0; i < FW_TX_CMPLT_BLOCK_SIZE; i++)
+		wl->tx_frames[i] = NULL;
+
+	wl->next_tx_complete = 0;
+
+	INIT_WORK(&wl->irq_work, wl1251_irq_work);
+	INIT_WORK(&wl->tx_work, wl1251_tx_work);
+
+	spin_lock_init(&wl->wl_lock);
+
+	/*
+	 * In case our MAC address is not correctly set,
+	 * we use a random but Nokia MAC.
+	 */
+	memcpy(wl->mac_addr, nokia_oui, 3);
+	get_random_bytes(wl->mac_addr + 3, 3);
+
+	wl->state = WL1251_STATE_OFF;
+	mutex_init(&wl->mutex);
+
+	wl->tx_mgmt_frm_rate = DEFAULT_HW_GEN_TX_RATE;
+	wl->tx_mgmt_frm_mod = DEFAULT_HW_GEN_MODULATION_TYPE;
+
+	wl->rx_descriptor = kmalloc(sizeof(*wl->rx_descriptor), GFP_KERNEL);
+	if (!wl->rx_descriptor) {
+		wl1251_error("could not allocate memory for rx descriptor");
+		ret = -ENOMEM;
+		goto out_free;
+	}
+
+	/* This is the only SPI value that we need to set here, the rest
+	 * comes from the board-peripherals file */
+	spi->bits_per_word = 32;
+
+	ret = spi_setup(spi);
+	if (ret < 0) {
+		wl1251_error("spi_setup failed");
+		goto out_free;
+	}
+
+	wl->set_power = pdata->set_power;
+	if (!wl->set_power) {
+		wl1251_error("set power function missing in platform data");
+		ret = -ENODEV;
+		goto out_free;
+	}
+
+	wl->irq = spi->irq;
+	if (wl->irq < 0) {
+		wl1251_error("irq missing in platform data");
+		ret = -ENODEV;
+		goto out_free;
+	}
+
+	ret = request_irq(wl->irq, wl1251_irq, 0, DRIVER_NAME, wl);
+	if (ret < 0) {
+		wl1251_error("request_irq() failed: %d", ret);
+		goto out_free;
+	}
+
+	set_irq_type(wl->irq, IRQ_TYPE_EDGE_RISING);
+
+	disable_irq(wl->irq);
+
+	ret = platform_device_register(&wl1251_device);
+	if (ret) {
+		wl1251_error("couldn't register platform device");
+		goto out_irq;
+	}
+	dev_set_drvdata(&wl1251_device.dev, wl);
+
+	ret = wl1251_init_ieee80211(wl);
+	if (ret)
+		goto out_platform;
+
+	ret = wl1251_register_hw(wl);
+	if (ret)
+		goto out_platform;
+
+	ret = wl1251_nl_register();
+	if (ret)
+		goto out_register_hw;
+
+	ret = device_create_file(&wl1251_device.dev,
+				 &dev_attr_tx_mgmt_frm_rate);
+	if (ret < 0) {
+		wl1251_error("failed to create sysfs file tx_mgmt_frm_rate");
+		goto out_register_hw;
+	}
+
+	ret = device_create_file(&wl1251_device.dev, &dev_attr_bt_coex_mode);
+	if (ret < 0) {
+		wl1251_error("failed to create sysfs file bt_coex_mode");
+		goto out_register_hw;
+	}
+
+	wl1251_debugfs_init(wl);
+
+	wl1251_notice("initialized");
+
+	return 0;
+
+ out_register_hw:
+	ieee80211_unregister_hw(hw);
+	wl->mac80211_registered = false;
+
+ out_platform:
+	platform_device_unregister(&wl1251_device);
+
+ out_irq:
+	free_irq(wl->irq, wl);
+
+ out_free:
+	kfree(wl->rx_descriptor);
+	wl->rx_descriptor = NULL;
+
+	ieee80211_free_hw(hw);
+
+	return ret;
+}
+
+static int __devexit wl1251_remove(struct spi_device *spi)
+{
+	struct wl1251 *wl = dev_get_drvdata(&spi->dev);
+
+	ieee80211_unregister_hw(wl->hw);
+
+	wl1251_debugfs_exit(wl);
+	platform_device_unregister(&wl1251_device);
+	free_irq(wl->irq, wl);
+	kfree(wl->target_mem_map);
+	kfree(wl->data_path);
+	vfree(wl->fw);
+	wl->fw = NULL;
+	kfree(wl->nvs);
+	wl->nvs = NULL;
+
+	kfree(wl->rx_descriptor);
+	wl->rx_descriptor = NULL;
+
+	kfree(wl->fw_status);
+
+	ieee80211_free_hw(wl->hw);
+	wl1251_nl_unregister();
+
+	return 0;
+}
+
+
+static struct spi_driver wl1251_spi_driver = {
+	.driver = {
+		/* FIXME: use wl12xx name to not break the user space */
+		.name		= "wl12xx",
+		.bus		= &spi_bus_type,
+		.owner		= THIS_MODULE,
+	},
+
+	.probe		= wl1251_probe,
+	.remove		= __devexit_p(wl1251_remove),
+};
+
+static int __init wl1251_init(void)
+{
+	int ret;
+
+	ret = spi_register_driver(&wl1251_spi_driver);
+	if (ret < 0) {
+		wl1251_error("failed to register spi driver: %d", ret);
+		goto out;
+	}
+
+out:
+	return ret;
+}
+
+static void __exit wl1251_exit(void)
+{
+	spi_unregister_driver(&wl1251_spi_driver);
+
+	wl1251_notice("unloaded");
+}
+
+module_init(wl1251_init);
+module_exit(wl1251_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Kalle Valo <kalle.valo@nokia.com>");
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_netlink.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_netlink.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_netlink.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_netlink.c	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,679 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+#include "wl1251_netlink.h"
+
+#include <linux/mutex.h>
+#include <linux/socket.h>
+#include <net/net_namespace.h>
+#include <net/sock.h>
+#include <net/genetlink.h>
+#include <net/wireless.h>
+#include <net/mac80211.h>
+
+#include "wl1251.h"
+#include "wl1251_spi.h"
+#include "wl1251_acx.h"
+
+/* FIXME: this should be changed as soon as user space catches up */
+#define WL1251_NL_NAME "wl1251"
+#define WL1251_NL_VERSION 1
+
+#define WL1251_MAX_TEST_LENGTH 1024
+#define WL1251_MAX_NVS_LENGTH 1024
+
+enum wl1251_nl_commands {
+	WL1251_NL_CMD_UNSPEC,
+	WL1251_NL_CMD_TEST,
+	WL1251_NL_CMD_INTERROGATE,
+	WL1251_NL_CMD_CONFIGURE,
+	WL1251_NL_CMD_PHY_REG_READ,
+	WL1251_NL_CMD_NVS_PUSH,
+	WL1251_NL_CMD_REG_WRITE,
+	WL1251_NL_CMD_REG_READ,
+	WL1251_NL_CMD_SET_PLT_MODE,
+
+	__WL1251_NL_CMD_AFTER_LAST
+};
+#define WL1251_NL_CMD_MAX (__WL1251_NL_CMD_AFTER_LAST - 1)
+
+enum wl1251_nl_attrs {
+	WL1251_NL_ATTR_UNSPEC,
+	WL1251_NL_ATTR_IFNAME,
+	WL1251_NL_ATTR_CMD_TEST_PARAM,
+	WL1251_NL_ATTR_CMD_TEST_ANSWER,
+	WL1251_NL_ATTR_CMD_IE,
+	WL1251_NL_ATTR_CMD_IE_LEN,
+	WL1251_NL_ATTR_CMD_IE_BUFFER,
+	WL1251_NL_ATTR_CMD_IE_ANSWER,
+	WL1251_NL_ATTR_REG_ADDR,
+	WL1251_NL_ATTR_REG_VAL,
+	WL1251_NL_ATTR_NVS_BUFFER,
+	WL1251_NL_ATTR_NVS_LEN,
+	WL1251_NL_ATTR_PLT_MODE,
+
+	__WL1251_NL_ATTR_AFTER_LAST
+};
+#define WL1251_NL_ATTR_MAX (__WL1251_NL_ATTR_AFTER_LAST - 1)
+
+static struct genl_family wl1251_nl_family = {
+	.id = GENL_ID_GENERATE,
+	.name = WL1251_NL_NAME,
+	.hdrsize = 0,
+	.version = WL1251_NL_VERSION,
+	.maxattr = WL1251_NL_ATTR_MAX,
+};
+
+static struct net_device *ifname_to_netdev(struct net *net,
+					   struct genl_info *info)
+{
+	char *ifname;
+
+	if (!info->attrs[WL1251_NL_ATTR_IFNAME])
+		return NULL;
+
+	ifname = nla_data(info->attrs[WL1251_NL_ATTR_IFNAME]);
+
+	wl1251_debug(DEBUG_NETLINK, "Looking for %s", ifname);
+
+	return dev_get_by_name(net, ifname);
+}
+
+static struct wl1251 *ifname_to_wl1251(struct net *net, struct genl_info *info)
+{
+	struct net_device *netdev;
+	struct wireless_dev *wdev;
+	struct wiphy *wiphy;
+	struct ieee80211_hw *hw;
+
+	netdev = ifname_to_netdev(net, info);
+	if (netdev == NULL) {
+		wl1251_error("Wrong interface");
+		return NULL;
+	}
+
+	wdev = netdev->ieee80211_ptr;
+	if (wdev == NULL) {
+		wl1251_error("ieee80211_ptr is NULL");
+		return NULL;
+	}
+
+	wiphy = wdev->wiphy;
+	if (wiphy == NULL) {
+		wl1251_error("wiphy is NULL");
+		return NULL;
+	}
+
+	hw = wiphy_priv(wiphy);
+	if (hw == NULL) {
+		wl1251_error("hw is NULL");
+		return NULL;
+	}
+
+	dev_put(netdev);
+
+	return hw->priv;
+}
+
+static int wl1251_nl_test_cmd(struct sk_buff *skb, struct genl_info *info)
+{
+	struct wl1251 *wl;
+	struct wl1251_command *cmd;
+	char *buf;
+	int buf_len, ret, cmd_len;
+	u8 answer;
+
+	if (!info->attrs[WL1251_NL_ATTR_CMD_TEST_PARAM])
+		return -EINVAL;
+
+	wl = ifname_to_wl1251(&init_net, info);
+	if (wl == NULL) {
+		wl1251_error("wl1251 not found");
+		return -EINVAL;
+	}
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	buf = nla_data(info->attrs[WL1251_NL_ATTR_CMD_TEST_PARAM]);
+	buf_len = nla_len(info->attrs[WL1251_NL_ATTR_CMD_TEST_PARAM]);
+	answer = nla_get_u8(info->attrs[WL1251_NL_ATTR_CMD_TEST_ANSWER]);
+
+	cmd->header.id = CMD_TEST;
+	memcpy(cmd->parameters, buf, buf_len);
+	cmd_len = sizeof(struct wl1251_cmd_header) + buf_len;
+
+	mutex_lock(&wl->mutex);
+	ret = wl1251_cmd_test(wl, cmd, cmd_len, answer);
+	mutex_unlock(&wl->mutex);
+
+	if (ret < 0) {
+		wl1251_error("%s() failed", __func__);
+		goto out;
+	}
+
+	if (answer) {
+		struct sk_buff *msg;
+		void *hdr;
+
+		msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+		if (!msg) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq,
+				  &wl1251_nl_family, 0, WL1251_NL_CMD_TEST);
+		if (IS_ERR(hdr)) {
+			ret = PTR_ERR(hdr);
+			goto nla_put_failure;
+		}
+
+		NLA_PUT_STRING(msg, WL1251_NL_ATTR_IFNAME,
+			       nla_data(info->attrs[WL1251_NL_ATTR_IFNAME]));
+		NLA_PUT(msg, WL1251_NL_ATTR_CMD_TEST_ANSWER,
+			sizeof(*cmd), cmd);
+
+		ret = genlmsg_end(msg, hdr);
+		if (ret < 0) {
+			wl1251_error("%s() failed", __func__);
+			goto nla_put_failure;
+		}
+
+		wl1251_debug(DEBUG_NETLINK, "TEST cmd sent, answer");
+		ret = genlmsg_reply(msg, info);
+		goto out;
+
+ nla_put_failure:
+		nlmsg_free(msg);
+	} else
+		wl1251_debug(DEBUG_NETLINK, "TEST cmd sent");
+
+out:
+	kfree(cmd);
+	return ret;
+}
+
+static int wl1251_nl_interrogate(struct sk_buff *skb, struct genl_info *info)
+{
+	struct wl1251 *wl;
+	struct sk_buff *msg;
+	int ret = -ENOBUFS, cmd_ie, cmd_ie_len;
+	struct wl1251_command *cmd;
+	void *hdr;
+
+	if (!info->attrs[WL1251_NL_ATTR_CMD_IE])
+		return -EINVAL;
+
+	if (!info->attrs[WL1251_NL_ATTR_CMD_IE_LEN])
+		return -EINVAL;
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!msg)
+		return -ENOMEM;
+
+	wl = ifname_to_wl1251(&init_net, info);
+	if (wl == NULL) {
+		wl1251_error("wl1251 not found");
+		ret = -EINVAL;
+		goto nla_put_failure;
+	}
+
+	/* acx id */
+	cmd_ie = nla_get_u32(info->attrs[WL1251_NL_ATTR_CMD_IE]);
+
+	/* maximum length of acx, including all headers */
+	cmd_ie_len = nla_get_u32(info->attrs[WL1251_NL_ATTR_CMD_IE_LEN]);
+
+	wl1251_debug(DEBUG_NETLINK, "Getting IE 0x%x (len %d)",
+		     cmd_ie, cmd_ie_len);
+
+	mutex_lock(&wl->mutex);
+	ret = wl1251_cmd_interrogate(wl, cmd_ie, cmd, cmd_ie_len);
+	mutex_unlock(&wl->mutex);
+
+	if (ret < 0) {
+		wl1251_error("%s() failed", __func__);
+		goto nla_put_failure;
+	}
+
+	hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq,
+			  &wl1251_nl_family, 0, WL1251_NL_CMD_INTERROGATE);
+	if (IS_ERR(hdr)) {
+		ret = PTR_ERR(hdr);
+		goto nla_put_failure;
+	}
+
+	NLA_PUT_STRING(msg, WL1251_NL_ATTR_IFNAME,
+		       nla_data(info->attrs[WL1251_NL_ATTR_IFNAME]));
+	NLA_PUT(msg, WL1251_NL_ATTR_CMD_IE_ANSWER, cmd_ie_len, cmd);
+
+	ret = genlmsg_end(msg, hdr);
+	if (ret < 0) {
+		wl1251_error("%s() failed", __func__);
+		goto nla_put_failure;
+	}
+
+	kfree(cmd);
+	return genlmsg_reply(msg, info);
+
+ nla_put_failure:
+	kfree(cmd);
+	nlmsg_free(msg);
+
+	return ret;
+}
+
+static int wl1251_nl_configure(struct sk_buff *skb, struct genl_info *info)
+{
+	int ret = 0, cmd_ie_len, acx_len;
+	struct acx_header *acx = NULL;
+	struct sk_buff *msg;
+	struct wl1251 *wl;
+	void *cmd_ie;
+	u16 *id;
+
+	if (!info->attrs[WL1251_NL_ATTR_CMD_IE_BUFFER])
+		return -EINVAL;
+
+	if (!info->attrs[WL1251_NL_ATTR_CMD_IE_LEN])
+		return -EINVAL;
+
+	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!msg)
+		return -ENOMEM;
+
+	wl = ifname_to_wl1251(&init_net, info);
+	if (wl == NULL) {
+		wl1251_error("wl1251 not found");
+		ret = -EINVAL;
+		goto nla_put_failure;
+	}
+
+	/* contains the acx header but not the cmd header */
+	cmd_ie = nla_data(info->attrs[WL1251_NL_ATTR_CMD_IE_BUFFER]);
+
+	cmd_ie_len = nla_get_u32(info->attrs[WL1251_NL_ATTR_CMD_IE_LEN]);
+
+	/* acx id is in the first two bytes */
+	id = cmd_ie;
+
+	/* need to add acx_header before cmd_ie, so create a new command */
+	acx_len = sizeof(struct acx_header) + cmd_ie_len;
+	acx = kzalloc(acx_len, GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto nla_put_failure;
+	}
+
+	/* copy the acx header and the payload */
+	memcpy(&acx->id, cmd_ie, cmd_ie_len);
+
+	mutex_lock(&wl->mutex);
+	ret = wl1251_cmd_configure(wl, *id, acx, acx_len);
+	mutex_unlock(&wl->mutex);
+
+	if (ret < 0) {
+		wl1251_error("%s() failed", __func__);
+		goto nla_put_failure;
+	}
+
+	wl1251_debug(DEBUG_NETLINK, "CONFIGURE cmd sent");
+
+ nla_put_failure:
+	kfree(acx);
+	nlmsg_free(msg);
+
+	return ret;
+}
+
+static int wl1251_nl_phy_reg_read(struct sk_buff *skb, struct genl_info *info)
+{
+	struct wl1251 *wl;
+	struct sk_buff *msg;
+	u32 reg_addr, *reg_value = NULL;
+	int ret = 0;
+	void *hdr;
+
+	if (!info->attrs[WL1251_NL_ATTR_REG_ADDR])
+		return -EINVAL;
+
+	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!msg)
+		return -ENOMEM;
+
+	wl = ifname_to_wl1251(&init_net, info);
+	if (wl == NULL) {
+		wl1251_error("wl1251 not found");
+		ret = -EINVAL;
+		goto nla_put_failure;
+	}
+
+	reg_value = kmalloc(sizeof(*reg_value), GFP_KERNEL);
+	if (!reg_value) {
+		ret = -ENOMEM;
+		goto nla_put_failure;
+	}
+
+	reg_addr = nla_get_u32(info->attrs[WL1251_NL_ATTR_REG_ADDR]);
+
+	wl1251_debug(DEBUG_NETLINK, "Reading PHY reg 0x%x", reg_addr);
+
+	mutex_lock(&wl->mutex);
+	ret = wl1251_cmd_read_memory(wl, reg_addr, reg_value,
+				     sizeof(*reg_value));
+	mutex_unlock(&wl->mutex);
+
+	if (ret < 0) {
+		wl1251_error("%s() failed", __func__);
+		goto nla_put_failure;
+	}
+
+
+	hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq,
+			  &wl1251_nl_family, 0, WL1251_NL_CMD_PHY_REG_READ);
+	if (IS_ERR(hdr)) {
+		ret = PTR_ERR(hdr);
+		goto nla_put_failure;
+	}
+
+	NLA_PUT_STRING(msg, WL1251_NL_ATTR_IFNAME,
+		       nla_data(info->attrs[WL1251_NL_ATTR_IFNAME]));
+
+	NLA_PUT_U32(msg, WL1251_NL_ATTR_REG_VAL, *reg_value);
+
+	ret = genlmsg_end(msg, hdr);
+	if (ret < 0) {
+		wl1251_error("%s() failed", __func__);
+		goto nla_put_failure;
+	}
+
+	kfree(reg_value);
+
+	return genlmsg_reply(msg, info);
+
+ nla_put_failure:
+	nlmsg_free(msg);
+	kfree(reg_value);
+
+	return ret;
+}
+
+static int wl1251_nl_nvs_push(struct sk_buff *skb, struct genl_info *info)
+{
+	struct wl1251 *wl;
+	int ret = 0;
+
+	if (!info->attrs[WL1251_NL_ATTR_NVS_BUFFER])
+		return -EINVAL;
+
+	if (!info->attrs[WL1251_NL_ATTR_NVS_LEN])
+		return -EINVAL;
+
+	wl = ifname_to_wl1251(&init_net, info);
+	if (wl == NULL) {
+		wl1251_error("wl1251 not found");
+		return -EINVAL;
+	}
+
+	mutex_lock(&wl->mutex);
+	wl->nvs_len = nla_get_u32(info->attrs[WL1251_NL_ATTR_NVS_LEN]);
+	if (wl->nvs_len % 4) {
+		wl1251_error("NVS size is not multiple of 32: %d", wl->nvs_len);
+		ret = -EILSEQ;
+		goto out;
+	}
+
+	/* If we already have an NVS, we should free it */
+	kfree(wl->nvs);
+
+	wl->nvs = kzalloc(wl->nvs_len, GFP_KERNEL);
+	if (wl->nvs == NULL) {
+		wl1251_error("Can't allocate NVS");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	memcpy(wl->nvs,
+	       nla_data(info->attrs[WL1251_NL_ATTR_NVS_BUFFER]),
+	       wl->nvs_len);
+
+	wl1251_debug(DEBUG_NETLINK, "got NVS from userspace, %d bytes",
+		     wl->nvs_len);
+
+out:
+	mutex_unlock(&wl->mutex);
+
+	return ret;
+}
+
+static int wl1251_nl_reg_read(struct sk_buff *skb, struct genl_info *info)
+{
+	struct wl1251 *wl;
+	u32 addr, val;
+	int ret = 0;
+	struct sk_buff *msg;
+	void *hdr;
+
+	if (!info->attrs[WL1251_NL_ATTR_REG_ADDR])
+		return -EINVAL;
+
+	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!msg)
+		return -ENOMEM;
+
+	wl = ifname_to_wl1251(&init_net, info);
+	if (wl == NULL) {
+		wl1251_error("wl1251 not found");
+		return -EINVAL;
+	}
+
+	addr = nla_get_u32(info->attrs[WL1251_NL_ATTR_REG_ADDR]);
+
+	mutex_lock(&wl->mutex);
+	val = wl1251_reg_read32(wl, addr);
+	mutex_unlock(&wl->mutex);
+
+	hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq,
+			  &wl1251_nl_family, 0, WL1251_NL_CMD_PHY_REG_READ);
+	if (IS_ERR(hdr)) {
+		ret = PTR_ERR(hdr);
+		goto nla_put_failure;
+	}
+
+	NLA_PUT_STRING(msg, WL1251_NL_ATTR_IFNAME,
+		       nla_data(info->attrs[WL1251_NL_ATTR_IFNAME]));
+
+	NLA_PUT_U32(msg, WL1251_NL_ATTR_REG_VAL, val);
+
+	ret = genlmsg_end(msg, hdr);
+	if (ret < 0) {
+		wl1251_error("%s() failed", __func__);
+		goto nla_put_failure;
+	}
+
+	return genlmsg_reply(msg, info);
+
+ nla_put_failure:
+	nlmsg_free(msg);
+
+	return ret;
+}
+
+static int wl1251_nl_reg_write(struct sk_buff *skb, struct genl_info *info)
+{
+	struct wl1251 *wl;
+	u32 addr, val;
+
+	if (!info->attrs[WL1251_NL_ATTR_REG_ADDR])
+		return -EINVAL;
+
+	if (!info->attrs[WL1251_NL_ATTR_REG_VAL])
+		return -EINVAL;
+
+	wl = ifname_to_wl1251(&init_net, info);
+	if (wl == NULL) {
+		wl1251_error("wl1251 not found");
+		return -EINVAL;
+	}
+
+	addr = nla_get_u32(info->attrs[WL1251_NL_ATTR_REG_ADDR]);
+	val = nla_get_u32(info->attrs[WL1251_NL_ATTR_REG_VAL]);
+
+	mutex_lock(&wl->mutex);
+	wl1251_reg_write32(wl, addr, val);
+	mutex_unlock(&wl->mutex);
+
+	return 0;
+}
+
+static int wl1251_nl_set_plt_mode(struct sk_buff *skb, struct genl_info *info)
+{
+	struct wl1251 *wl;
+	u32 val;
+	int ret;
+
+	if (!info->attrs[WL1251_NL_ATTR_PLT_MODE])
+		return -EINVAL;
+
+	wl = ifname_to_wl1251(&init_net, info);
+	if (wl == NULL) {
+		wl1251_error("wl1251 not found");
+		return -EINVAL;
+	}
+
+	val = nla_get_u32(info->attrs[WL1251_NL_ATTR_PLT_MODE]);
+
+	switch (val) {
+	case 0:
+		ret = wl1251_plt_stop(wl);
+		break;
+	case 1:
+		ret = wl1251_plt_start(wl);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static struct nla_policy wl1251_nl_policy[WL1251_NL_ATTR_MAX + 1] = {
+	[WL1251_NL_ATTR_IFNAME] =            { .type = NLA_NUL_STRING,
+					       .len = IFNAMSIZ-1 },
+	[WL1251_NL_ATTR_CMD_TEST_PARAM] =    { .type = NLA_BINARY,
+					       .len = WL1251_MAX_TEST_LENGTH },
+	[WL1251_NL_ATTR_CMD_TEST_ANSWER] =   { .type = NLA_U8 },
+	[WL1251_NL_ATTR_CMD_IE] =            { .type = NLA_U32 },
+	[WL1251_NL_ATTR_CMD_IE_LEN] =        { .type = NLA_U32 },
+	[WL1251_NL_ATTR_CMD_IE_BUFFER] =     { .type = NLA_BINARY,
+					       .len = WL1251_MAX_TEST_LENGTH },
+	[WL1251_NL_ATTR_CMD_IE_ANSWER] =     { .type = NLA_BINARY,
+					       .len = WL1251_MAX_TEST_LENGTH },
+	[WL1251_NL_ATTR_REG_ADDR] =          { .type = NLA_U32 },
+	[WL1251_NL_ATTR_REG_VAL] =           { .type = NLA_U32 },
+	[WL1251_NL_ATTR_NVS_BUFFER] =        { .type = NLA_BINARY,
+					       .len = WL1251_MAX_NVS_LENGTH },
+	[WL1251_NL_ATTR_NVS_LEN] =           { .type = NLA_U32 },
+	[WL1251_NL_ATTR_PLT_MODE] =          { .type = NLA_U32 },
+};
+
+static struct genl_ops wl1251_nl_ops[] = {
+	{
+		.cmd = WL1251_NL_CMD_TEST,
+		.doit = wl1251_nl_test_cmd,
+		.policy = wl1251_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = WL1251_NL_CMD_INTERROGATE,
+		.doit = wl1251_nl_interrogate,
+		.policy = wl1251_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = WL1251_NL_CMD_CONFIGURE,
+		.doit = wl1251_nl_configure,
+		.policy = wl1251_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = WL1251_NL_CMD_PHY_REG_READ,
+		.doit = wl1251_nl_phy_reg_read,
+		.policy = wl1251_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = WL1251_NL_CMD_NVS_PUSH,
+		.doit = wl1251_nl_nvs_push,
+		.policy = wl1251_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = WL1251_NL_CMD_REG_WRITE,
+		.doit = wl1251_nl_reg_write,
+		.policy = wl1251_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = WL1251_NL_CMD_REG_READ,
+		.doit = wl1251_nl_reg_read,
+		.policy = wl1251_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = WL1251_NL_CMD_SET_PLT_MODE,
+		.doit = wl1251_nl_set_plt_mode,
+		.policy = wl1251_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+};
+
+int wl1251_nl_register(void)
+{
+	int err, i;
+
+	err = genl_register_family(&wl1251_nl_family);
+	if (err)
+		return err;
+
+	for (i = 0; i < ARRAY_SIZE(wl1251_nl_ops); i++) {
+		err = genl_register_ops(&wl1251_nl_family, &wl1251_nl_ops[i]);
+		if (err)
+			goto err_out;
+	}
+	return 0;
+ err_out:
+	genl_unregister_family(&wl1251_nl_family);
+	return err;
+}
+
+void wl1251_nl_unregister(void)
+{
+	genl_unregister_family(&wl1251_nl_family);
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_netlink.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_netlink.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_netlink.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_netlink.h	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,30 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __WL1251_NETLINK_H__
+#define __WL1251_NETLINK_H__
+
+int wl1251_nl_register(void);
+void wl1251_nl_unregister(void);
+
+#endif /* __WL1251_NETLINK_H__ */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_ps.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_ps.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_ps.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_ps.c	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,192 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include "wl1251_reg.h"
+#include "wl1251_ps.h"
+#include "wl1251_spi.h"
+
+#define WL1251_WAKEUP_TIMEOUT 2000
+
+void wl1251_elp_work(struct work_struct *work)
+{
+	struct delayed_work *dwork;
+	struct wl1251 *wl;
+
+	dwork = container_of(work, struct delayed_work, work);
+	wl = container_of(dwork, struct wl1251, elp_work);
+
+	wl1251_debug(DEBUG_PSM, "elp work");
+
+	mutex_lock(&wl->mutex);
+
+	if (wl->elp || !wl->psm)
+		goto out;
+
+	wl1251_debug(DEBUG_PSM, "chip to elp");
+	wl1251_write32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, ELPCTRL_SLEEP);
+	wl->elp = true;
+
+out:
+	mutex_unlock(&wl->mutex);
+}
+
+#define ELP_ENTRY_DELAY  5
+
+/* Routines to toggle sleep mode while in ELP */
+void wl1251_ps_elp_sleep(struct wl1251 *wl)
+{
+	if (wl->psm) {
+		cancel_delayed_work(&wl->elp_work);
+		queue_delayed_work(wl->hw->workqueue, &wl->elp_work,
+				   msecs_to_jiffies(ELP_ENTRY_DELAY));
+	}
+}
+
+int wl1251_ps_elp_wakeup(struct wl1251 *wl)
+{
+	unsigned long timeout;
+	u32 elp_reg;
+
+	if (!wl->elp)
+		return 0;
+
+	wl1251_debug(DEBUG_PSM, "waking up chip from elp");
+
+	timeout = jiffies + msecs_to_jiffies(WL1251_WAKEUP_TIMEOUT);
+
+	wl1251_write32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, ELPCTRL_WAKE_UP);
+
+	elp_reg = wl1251_read32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR);
+
+	/*
+	 * FIXME: we should wait for irq from chip but, as a temporary
+	 * solution to simplify locking, let's poll instead
+	 */
+	while (!(elp_reg & ELPCTRL_WLAN_READY)) {
+		if (time_after(jiffies, timeout)) {
+			wl1251_error("elp wakeup timeout");
+			return -ETIMEDOUT;
+		}
+		msleep(1);
+		elp_reg = wl1251_read32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR);
+	}
+
+	wl1251_debug(DEBUG_PSM, "wakeup time: %u ms",
+		     jiffies_to_msecs(jiffies) -
+		     (jiffies_to_msecs(timeout) - WL1251_WAKEUP_TIMEOUT));
+
+	wl->elp = false;
+
+	return 0;
+}
+
+static int wl1251_ps_set_elp(struct wl1251 *wl, bool enable)
+{
+	int ret;
+
+	if (enable) {
+		wl1251_debug(DEBUG_PSM, "sleep auth psm/elp");
+
+		ret = wl1251_acx_sleep_auth(wl, WL1251_PSM_ELP);
+		if (ret < 0)
+			return ret;
+
+		wl1251_ps_elp_sleep(wl);
+	} else {
+		wl1251_debug(DEBUG_PSM, "sleep auth cam");
+
+		/*
+		 * When the target is in ELP, we can only
+		 * access the ELP control register. Thus,
+		 * we have to wake the target up before
+		 * changing the power authorization.
+		 */
+
+		wl1251_ps_elp_wakeup(wl);
+
+		ret = wl1251_acx_sleep_auth(wl, WL1251_PSM_CAM);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+int wl1251_ps_set_mode(struct wl1251 *wl, enum wl1251_cmd_ps_mode mode)
+{
+	int ret;
+
+	switch (mode) {
+	case STATION_POWER_SAVE_MODE:
+		wl1251_debug(DEBUG_PSM, "entering psm");
+
+		/* enable beacon filtering */
+		ret = wl1251_acx_beacon_filter_opt(wl, true);
+		if (ret < 0)
+			return ret;
+
+		ret = wl1251_acx_wake_up_conditions(wl,
+						    WAKE_UP_EVENT_DTIM_BITMAP,
+						    wl->listen_int);
+		if (ret < 0)
+			return ret;
+
+		ret = wl1251_cmd_ps_mode(wl, STATION_POWER_SAVE_MODE);
+		if (ret < 0)
+			return ret;
+
+		ret = wl1251_ps_set_elp(wl, true);
+		if (ret < 0)
+			return ret;
+
+		wl->psm = 1;
+		break;
+	case STATION_ACTIVE_MODE:
+	default:
+		wl1251_debug(DEBUG_PSM, "leaving psm");
+		ret = wl1251_ps_set_elp(wl, false);
+		if (ret < 0)
+			return ret;
+
+		/* disable beacon filtering */
+		ret = wl1251_acx_beacon_filter_opt(wl, false);
+		if (ret < 0)
+			return ret;
+
+		ret = wl1251_acx_wake_up_conditions(wl,
+						    WAKE_UP_EVENT_DTIM_BITMAP,
+						    wl->listen_int);
+		if (ret < 0)
+			return ret;
+
+		ret = wl1251_cmd_ps_mode(wl, STATION_ACTIVE_MODE);
+		if (ret < 0)
+			return ret;
+
+		wl->psm = 0;
+		break;
+	}
+
+	return ret;
+}
+
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_ps.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_ps.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_ps.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_ps.h	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,37 @@
+#ifndef __WL1251_PS_H__
+#define __WL1251_PS_H__
+
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include "wl1251.h"
+#include "wl1251_acx.h"
+
+int wl1251_ps_set_mode(struct wl1251 *wl, enum wl1251_cmd_ps_mode mode);
+void wl1251_ps_elp_sleep(struct wl1251 *wl);
+int wl1251_ps_elp_wakeup(struct wl1251 *wl);
+void wl1251_elp_work(struct work_struct *work);
+
+
+#endif /* __WL1251_PS_H__ */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_reg.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_reg.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_reg.h	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,744 @@
+/*
+ * This file is part of wl12xx
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __REG_H__
+#define __REG_H__
+
+#include <linux/bitops.h>
+
+#define REGISTERS_BASE 0x00300000
+#define DRPW_BASE      0x00310000
+
+#define REGISTERS_DOWN_SIZE 0x00008800
+#define REGISTERS_WORK_SIZE 0x0000b000
+
+#define HW_ACCESS_ELP_CTRL_REG_ADDR         0x1FFFC
+
+/* ELP register commands */
+#define ELPCTRL_WAKE_UP             0x1
+#define ELPCTRL_WAKE_UP_WLAN_READY  0x5
+#define ELPCTRL_SLEEP               0x0
+/* ELP WLAN_READY bit */
+#define ELPCTRL_WLAN_READY          0x2
+
+/*
+ * Interrupt registers.
+ * 64 bit interrupt sources registers ws ced.
+ * sme interupts were removed and new ones were added.
+ * Order was changed.
+ */
+#define FIQ_MASK                       (REGISTERS_BASE + 0x0400)
+#define FIQ_MASK_L                     (REGISTERS_BASE + 0x0400)
+#define FIQ_MASK_H                     (REGISTERS_BASE + 0x0404)
+#define FIQ_MASK_SET                   (REGISTERS_BASE + 0x0408)
+#define FIQ_MASK_SET_L                 (REGISTERS_BASE + 0x0408)
+#define FIQ_MASK_SET_H                 (REGISTERS_BASE + 0x040C)
+#define FIQ_MASK_CLR                   (REGISTERS_BASE + 0x0410)
+#define FIQ_MASK_CLR_L                 (REGISTERS_BASE + 0x0410)
+#define FIQ_MASK_CLR_H                 (REGISTERS_BASE + 0x0414)
+#define IRQ_MASK                       (REGISTERS_BASE + 0x0418)
+#define IRQ_MASK_L                     (REGISTERS_BASE + 0x0418)
+#define IRQ_MASK_H                     (REGISTERS_BASE + 0x041C)
+#define IRQ_MASK_SET                   (REGISTERS_BASE + 0x0420)
+#define IRQ_MASK_SET_L                 (REGISTERS_BASE + 0x0420)
+#define IRQ_MASK_SET_H                 (REGISTERS_BASE + 0x0424)
+#define IRQ_MASK_CLR                   (REGISTERS_BASE + 0x0428)
+#define IRQ_MASK_CLR_L                 (REGISTERS_BASE + 0x0428)
+#define IRQ_MASK_CLR_H                 (REGISTERS_BASE + 0x042C)
+#define ECPU_MASK                      (REGISTERS_BASE + 0x0448)
+#define FIQ_STS_L                      (REGISTERS_BASE + 0x044C)
+#define FIQ_STS_H                      (REGISTERS_BASE + 0x0450)
+#define IRQ_STS_L                      (REGISTERS_BASE + 0x0454)
+#define IRQ_STS_H                      (REGISTERS_BASE + 0x0458)
+#define INT_STS_ND                     (REGISTERS_BASE + 0x0464)
+#define INT_STS_RAW_L                  (REGISTERS_BASE + 0x0464)
+#define INT_STS_RAW_H                  (REGISTERS_BASE + 0x0468)
+#define INT_STS_CLR                    (REGISTERS_BASE + 0x04B4)
+#define INT_STS_CLR_L                  (REGISTERS_BASE + 0x04B4)
+#define INT_STS_CLR_H                  (REGISTERS_BASE + 0x04B8)
+#define INT_ACK                        (REGISTERS_BASE + 0x046C)
+#define INT_ACK_L                      (REGISTERS_BASE + 0x046C)
+#define INT_ACK_H                      (REGISTERS_BASE + 0x0470)
+#define INT_TRIG                       (REGISTERS_BASE + 0x0474)
+#define INT_TRIG_L                     (REGISTERS_BASE + 0x0474)
+#define INT_TRIG_H                     (REGISTERS_BASE + 0x0478)
+#define HOST_STS_L                     (REGISTERS_BASE + 0x045C)
+#define HOST_STS_H                     (REGISTERS_BASE + 0x0460)
+#define HOST_MASK                      (REGISTERS_BASE + 0x0430)
+#define HOST_MASK_L                    (REGISTERS_BASE + 0x0430)
+#define HOST_MASK_H                    (REGISTERS_BASE + 0x0434)
+#define HOST_MASK_SET                  (REGISTERS_BASE + 0x0438)
+#define HOST_MASK_SET_L                (REGISTERS_BASE + 0x0438)
+#define HOST_MASK_SET_H                (REGISTERS_BASE + 0x043C)
+#define HOST_MASK_CLR                  (REGISTERS_BASE + 0x0440)
+#define HOST_MASK_CLR_L                (REGISTERS_BASE + 0x0440)
+#define HOST_MASK_CLR_H                (REGISTERS_BASE + 0x0444)
+
+/* Host Interrupts*/
+#define HINT_MASK                      (REGISTERS_BASE + 0x0494)
+#define HINT_MASK_SET                  (REGISTERS_BASE + 0x0498)
+#define HINT_MASK_CLR                  (REGISTERS_BASE + 0x049C)
+#define HINT_STS_ND_MASKED             (REGISTERS_BASE + 0x04A0)
+/*1150 spec calls this HINT_STS_RAW*/
+#define HINT_STS_ND		       (REGISTERS_BASE + 0x04B0)
+#define HINT_STS_CLR                   (REGISTERS_BASE + 0x04A4)
+#define HINT_ACK                       (REGISTERS_BASE + 0x04A8)
+#define HINT_TRIG                      (REGISTERS_BASE + 0x04AC)
+
+/* Device Configuration registers*/
+#define SOR_CFG                        (REGISTERS_BASE + 0x0800)
+#define ECPU_CTRL                      (REGISTERS_BASE + 0x0804)
+#define HI_CFG                         (REGISTERS_BASE + 0x0808)
+#define EE_START                       (REGISTERS_BASE + 0x080C)
+
+#define CHIP_ID_B                      (REGISTERS_BASE + 0x5674)
+
+#define CHIP_ID_1251_PG10	           (0x7010101)
+#define CHIP_ID_1251_PG11	           (0x7020101)
+#define CHIP_ID_1251_PG12	           (0x7030101)
+
+#define ENABLE                         (REGISTERS_BASE + 0x5450)
+
+/* Power Management registers */
+#define ELP_CFG_MODE                   (REGISTERS_BASE + 0x5804)
+#define ELP_CMD                        (REGISTERS_BASE + 0x5808)
+#define PLL_CAL_TIME                   (REGISTERS_BASE + 0x5810)
+#define CLK_REQ_TIME                   (REGISTERS_BASE + 0x5814)
+#define CLK_BUF_TIME                   (REGISTERS_BASE + 0x5818)
+
+#define CFG_PLL_SYNC_CNT               (REGISTERS_BASE + 0x5820)
+
+/* Scratch Pad registers*/
+#define SCR_PAD0                       (REGISTERS_BASE + 0x5608)
+#define SCR_PAD1                       (REGISTERS_BASE + 0x560C)
+#define SCR_PAD2                       (REGISTERS_BASE + 0x5610)
+#define SCR_PAD3                       (REGISTERS_BASE + 0x5614)
+#define SCR_PAD4                       (REGISTERS_BASE + 0x5618)
+#define SCR_PAD4_SET                   (REGISTERS_BASE + 0x561C)
+#define SCR_PAD4_CLR                   (REGISTERS_BASE + 0x5620)
+#define SCR_PAD5                       (REGISTERS_BASE + 0x5624)
+#define SCR_PAD5_SET                   (REGISTERS_BASE + 0x5628)
+#define SCR_PAD5_CLR                   (REGISTERS_BASE + 0x562C)
+#define SCR_PAD6                       (REGISTERS_BASE + 0x5630)
+#define SCR_PAD7                       (REGISTERS_BASE + 0x5634)
+#define SCR_PAD8                       (REGISTERS_BASE + 0x5638)
+#define SCR_PAD9                       (REGISTERS_BASE + 0x563C)
+
+/* Spare registers*/
+#define SPARE_A1                       (REGISTERS_BASE + 0x0994)
+#define SPARE_A2                       (REGISTERS_BASE + 0x0998)
+#define SPARE_A3                       (REGISTERS_BASE + 0x099C)
+#define SPARE_A4                       (REGISTERS_BASE + 0x09A0)
+#define SPARE_A5                       (REGISTERS_BASE + 0x09A4)
+#define SPARE_A6                       (REGISTERS_BASE + 0x09A8)
+#define SPARE_A7                       (REGISTERS_BASE + 0x09AC)
+#define SPARE_A8                       (REGISTERS_BASE + 0x09B0)
+#define SPARE_B1                       (REGISTERS_BASE + 0x5420)
+#define SPARE_B2                       (REGISTERS_BASE + 0x5424)
+#define SPARE_B3                       (REGISTERS_BASE + 0x5428)
+#define SPARE_B4                       (REGISTERS_BASE + 0x542C)
+#define SPARE_B5                       (REGISTERS_BASE + 0x5430)
+#define SPARE_B6                       (REGISTERS_BASE + 0x5434)
+#define SPARE_B7                       (REGISTERS_BASE + 0x5438)
+#define SPARE_B8                       (REGISTERS_BASE + 0x543C)
+
+enum wl12xx_acx_int_reg {
+	ACX_REG_INTERRUPT_TRIG,
+	ACX_REG_INTERRUPT_TRIG_H,
+
+/*=============================================
+  Host Interrupt Mask Register - 32bit (RW)
+  ------------------------------------------
+  Setting a bit in this register masks the
+  corresponding interrupt to the host.
+  0 - RX0		- Rx first dubble buffer Data Interrupt
+  1 - TXD		- Tx Data Interrupt
+  2 - TXXFR		- Tx Transfer Interrupt
+  3 - RX1		- Rx second dubble buffer Data Interrupt
+  4 - RXXFR		- Rx Transfer Interrupt
+  5 - EVENT_A	- Event Mailbox interrupt
+  6 - EVENT_B	- Event Mailbox interrupt
+  7 - WNONHST	- Wake On Host Interrupt
+  8 - TRACE_A	- Debug Trace interrupt
+  9 - TRACE_B	- Debug Trace interrupt
+ 10 - CDCMP		- Command Complete Interrupt
+ 11 -
+ 12 -
+ 13 -
+ 14 - ICOMP		- Initialization Complete Interrupt
+ 16 - SG SE		- Soft Gemini - Sense enable interrupt
+ 17 - SG SD		- Soft Gemini - Sense disable interrupt
+ 18 -			-
+ 19 -			-
+ 20 -			-
+ 21-			-
+ Default: 0x0001
+*==============================================*/
+	ACX_REG_INTERRUPT_MASK,
+
+/*=============================================
+  Host Interrupt Mask Set 16bit, (Write only)
+  ------------------------------------------
+ Setting a bit in this register sets
+ the corresponding bin in ACX_HINT_MASK register
+ without effecting the mask
+ state of other bits (0 = no effect).
+==============================================*/
+	ACX_REG_HINT_MASK_SET,
+
+/*=============================================
+  Host Interrupt Mask Clear 16bit,(Write only)
+  ------------------------------------------
+ Setting a bit in this register clears
+ the corresponding bin in ACX_HINT_MASK register
+ without effecting the mask
+ state of other bits (0 = no effect).
+=============================================*/
+	ACX_REG_HINT_MASK_CLR,
+
+/*=============================================
+  Host Interrupt Status Nondestructive Read
+  16bit,(Read only)
+  ------------------------------------------
+ The host can read this register to determine
+ which interrupts are active.
+ Reading this register doesn't
+ effect its content.
+=============================================*/
+	ACX_REG_INTERRUPT_NO_CLEAR,
+
+/*=============================================
+  Host Interrupt Status Clear on Read  Register
+  16bit,(Read only)
+  ------------------------------------------
+ The host can read this register to determine
+ which interrupts are active.
+ Reading this register clears it,
+ thus making all interrupts inactive.
+==============================================*/
+	ACX_REG_INTERRUPT_CLEAR,
+
+/*=============================================
+  Host Interrupt Acknowledge Register
+  16bit,(Write only)
+  ------------------------------------------
+ The host can set individual bits in this
+ register to clear (acknowledge) the corresp.
+ interrupt status bits in the HINT_STS_CLR and
+ HINT_STS_ND registers, thus making the
+ assotiated interrupt inactive. (0-no effect)
+==============================================*/
+	ACX_REG_INTERRUPT_ACK,
+
+/*===============================================
+   Host Software Reset - 32bit RW
+ ------------------------------------------
+    [31:1] Reserved
+    0  SOFT_RESET Soft Reset  - When this bit is set,
+    it holds the Wlan hardware in a soft reset state.
+    This reset disables all MAC and baseband processor
+    clocks except the CardBus/PCI interface clock.
+    It also initializes all MAC state machines except
+    the host interface. It does not reload the
+    contents of the EEPROM. When this bit is cleared
+    (not self-clearing), the Wlan hardware
+    exits the software reset state.
+===============================================*/
+	ACX_REG_SLV_SOFT_RESET,
+
+/*===============================================
+ EEPROM Burst Read Start  - 32bit RW
+ ------------------------------------------
+ [31:1] Reserved
+ 0  ACX_EE_START -  EEPROM Burst Read Start 0
+ Setting this bit starts a burst read from
+ the external EEPROM.
+ If this bit is set (after reset) before an EEPROM read/write,
+ the burst read starts at EEPROM address 0.
+ Otherwise, it starts at the address
+ following the address of the previous access.
+ TheWlan hardware hardware clears this bit automatically.
+
+ Default: 0x00000000
+*================================================*/
+	ACX_REG_EE_START,
+
+/* Embedded ARM CPU Control */
+
+/*===============================================
+ Halt eCPU   - 32bit RW
+ ------------------------------------------
+ 0 HALT_ECPU Halt Embedded CPU - This bit is the
+ compliment of bit 1 (MDATA2) in the SOR_CFG register.
+ During a hardware reset, this bit holds
+ the inverse of MDATA2.
+ When downloading firmware from the host,
+ set this bit (pull down MDATA2).
+ The host clears this bit after downloading the firmware into
+ zero-wait-state SSRAM.
+ When loading firmware from Flash, clear this bit (pull up MDATA2)
+ so that the eCPU can run the bootloader code in Flash
+ HALT_ECPU eCPU State
+ --------------------
+ 1 halt eCPU
+ 0 enable eCPU
+ ===============================================*/
+	ACX_REG_ECPU_CONTROL,
+
+	ACX_REG_TABLE_LEN
+};
+
+#define ACX_SLV_SOFT_RESET_BIT   BIT(1)
+#define ACX_REG_EEPROM_START_BIT BIT(1)
+
+/* Command/Information Mailbox Pointers */
+
+/*===============================================
+  Command Mailbox Pointer - 32bit RW
+ ------------------------------------------
+ This register holds the start address of
+ the command mailbox located in the Wlan hardware memory.
+ The host must read this pointer after a reset to
+ find the location of the command mailbox.
+ The Wlan hardware initializes the command mailbox
+ pointer with the default address of the command mailbox.
+ The command mailbox pointer is not valid until after
+ the host receives the Init Complete interrupt from
+ the Wlan hardware.
+ ===============================================*/
+#define REG_COMMAND_MAILBOX_PTR				(SCR_PAD0)
+
+/*===============================================
+  Information Mailbox Pointer - 32bit RW
+ ------------------------------------------
+ This register holds the start address of
+ the information mailbox located in the Wlan hardware memory.
+ The host must read this pointer after a reset to find
+ the location of the information mailbox.
+ The Wlan hardware initializes the information mailbox pointer
+ with the default address of the information mailbox.
+ The information mailbox pointer is not valid
+ until after the host receives the Init Complete interrupt from
+ the Wlan hardware.
+ ===============================================*/
+#define REG_EVENT_MAILBOX_PTR				(SCR_PAD1)
+
+
+/* Misc */
+
+#define REG_ENABLE_TX_RX				(ENABLE)
+/*
+ * Rx configuration (filter) information element
+ * ---------------------------------------------
+ */
+#define REG_RX_CONFIG				(RX_CFG)
+#define REG_RX_FILTER				(RX_FILTER_CFG)
+
+
+#define RX_CFG_ENABLE_PHY_HEADER_PLCP	 0x0002
+
+/* promiscuous - receives all valid frames */
+#define RX_CFG_PROMISCUOUS		 0x0008
+
+/* receives frames from any BSSID */
+#define RX_CFG_BSSID			 0x0020
+
+/* receives frames destined to any MAC address */
+#define RX_CFG_MAC			 0x0010
+
+#define RX_CFG_ENABLE_ONLY_MY_DEST_MAC	 0x0010
+#define RX_CFG_ENABLE_ANY_DEST_MAC	 0x0000
+#define RX_CFG_ENABLE_ONLY_MY_BSSID	 0x0020
+#define RX_CFG_ENABLE_ANY_BSSID		 0x0000
+
+/* discards all broadcast frames */
+#define RX_CFG_DISABLE_BCAST		 0x0200
+
+#define RX_CFG_ENABLE_ONLY_MY_SSID	 0x0400
+#define RX_CFG_ENABLE_RX_CMPLT_FCS_ERROR 0x0800
+#define RX_CFG_COPY_RX_STATUS		 0x2000
+#define RX_CFG_TSF			 0x10000
+
+#define RX_CONFIG_OPTION_ANY_DST_MY_BSS	 (RX_CFG_ENABLE_ANY_DEST_MAC | \
+					  RX_CFG_ENABLE_ONLY_MY_BSSID)
+
+#define RX_CONFIG_OPTION_MY_DST_ANY_BSS	 (RX_CFG_ENABLE_ONLY_MY_DEST_MAC\
+					  | RX_CFG_ENABLE_ANY_BSSID)
+
+#define RX_CONFIG_OPTION_ANY_DST_ANY_BSS (RX_CFG_ENABLE_ANY_DEST_MAC | \
+					  RX_CFG_ENABLE_ANY_BSSID)
+
+#define RX_CONFIG_OPTION_MY_DST_MY_BSS	 (RX_CFG_ENABLE_ONLY_MY_DEST_MAC\
+					  | RX_CFG_ENABLE_ONLY_MY_BSSID)
+
+#define RX_CONFIG_OPTION_FOR_SCAN  (RX_CFG_ENABLE_PHY_HEADER_PLCP \
+				    | RX_CFG_ENABLE_RX_CMPLT_FCS_ERROR \
+				    | RX_CFG_COPY_RX_STATUS | RX_CFG_TSF)
+
+#define RX_CONFIG_OPTION_FOR_MEASUREMENT (RX_CFG_ENABLE_ANY_DEST_MAC)
+
+#define RX_CONFIG_OPTION_FOR_JOIN	 (RX_CFG_ENABLE_ONLY_MY_BSSID | \
+					  RX_CFG_ENABLE_ONLY_MY_DEST_MAC)
+
+#define RX_CONFIG_OPTION_FOR_IBSS_JOIN   (RX_CFG_ENABLE_ONLY_MY_SSID | \
+					  RX_CFG_ENABLE_ONLY_MY_DEST_MAC)
+
+#define RX_FILTER_OPTION_DEF	      (CFG_RX_MGMT_EN | CFG_RX_DATA_EN\
+				       | CFG_RX_CTL_EN | CFG_RX_BCN_EN\
+				       | CFG_RX_AUTH_EN | CFG_RX_ASSOC_EN)
+
+#define RX_FILTER_OPTION_FILTER_ALL	 0
+
+#define RX_FILTER_OPTION_DEF_PRSP_BCN  (CFG_RX_PRSP_EN | CFG_RX_MGMT_EN\
+					| CFG_RX_RCTS_ACK | CFG_RX_BCN_EN)
+
+#define RX_FILTER_OPTION_JOIN	     (CFG_RX_MGMT_EN | CFG_RX_DATA_EN\
+				      | CFG_RX_BCN_EN | CFG_RX_AUTH_EN\
+				      | CFG_RX_ASSOC_EN | CFG_RX_RCTS_ACK\
+				      | CFG_RX_PRSP_EN)
+
+
+/*===============================================
+  Phy regs
+ ===============================================*/
+#define ACX_PHY_ADDR_REG                SBB_ADDR
+#define ACX_PHY_DATA_REG                SBB_DATA
+#define ACX_PHY_CTRL_REG                SBB_CTL
+#define ACX_PHY_REG_WR_MASK             0x00000001ul
+#define ACX_PHY_REG_RD_MASK             0x00000002ul
+
+
+/*===============================================
+ EEPROM Read/Write Request 32bit RW
+ ------------------------------------------
+ 1 EE_READ - EEPROM Read Request 1 - Setting this bit
+ loads a single byte of data into the EE_DATA
+ register from the EEPROM location specified in
+ the EE_ADDR register.
+ The Wlan hardware hardware clears this bit automatically.
+ EE_DATA is valid when this bit is cleared.
+
+ 0 EE_WRITE  - EEPROM Write Request  - Setting this bit
+ writes a single byte of data from the EE_DATA register into the
+ EEPROM location specified in the EE_ADDR register.
+ The Wlan hardware hardware clears this bit automatically.
+*===============================================*/
+#define ACX_EE_CTL_REG                      EE_CTL
+#define EE_WRITE                            0x00000001ul
+#define EE_READ                             0x00000002ul
+
+/*===============================================
+  EEPROM Address  - 32bit RW
+  ------------------------------------------
+  This register specifies the address
+  within the EEPROM from/to which to read/write data.
+  ===============================================*/
+#define ACX_EE_ADDR_REG                     EE_ADDR
+
+/*===============================================
+  EEPROM Data  - 32bit RW
+  ------------------------------------------
+  This register either holds the read 8 bits of
+  data from the EEPROM or the write data
+  to be written to the EEPROM.
+  ===============================================*/
+#define ACX_EE_DATA_REG                     EE_DATA
+
+/*===============================================
+  EEPROM Base Address  - 32bit RW
+  ------------------------------------------
+  This register holds the upper nine bits
+  [23:15] of the 24-bit Wlan hardware memory
+  address for burst reads from EEPROM accesses.
+  The EEPROM provides the lower 15 bits of this address.
+  The MSB of the address from the EEPROM is ignored.
+  ===============================================*/
+#define ACX_EE_CFG                          EE_CFG
+
+/*===============================================
+  GPIO Output Values  -32bit, RW
+  ------------------------------------------
+  [31:16]  Reserved
+  [15: 0]  Specify the output values (at the output driver inputs) for
+  GPIO[15:0], respectively.
+  ===============================================*/
+#define ACX_GPIO_OUT_REG            GPIO_OUT
+#define ACX_MAX_GPIO_LINES          15
+
+/*===============================================
+  Contention window  -32bit, RW
+  ------------------------------------------
+  [31:26]  Reserved
+  [25:16]  Max (0x3ff)
+  [15:07]  Reserved
+  [06:00]  Current contention window value - default is 0x1F
+  ===============================================*/
+#define ACX_CONT_WIND_CFG_REG    CONT_WIND_CFG
+#define ACX_CONT_WIND_MIN_MASK   0x0000007f
+#define ACX_CONT_WIND_MAX        0x03ff0000
+
+/*
+ * Indirect slave register/memory registers
+ * ----------------------------------------
+ */
+#define HW_SLAVE_REG_ADDR_REG		0x00000004
+#define HW_SLAVE_REG_DATA_REG		0x00000008
+#define HW_SLAVE_REG_CTRL_REG		0x0000000c
+
+#define SLAVE_AUTO_INC				0x00010000
+#define SLAVE_NO_AUTO_INC			0x00000000
+#define SLAVE_HOST_LITTLE_ENDIAN	0x00000000
+
+#define HW_SLAVE_MEM_ADDR_REG		SLV_MEM_ADDR
+#define HW_SLAVE_MEM_DATA_REG		SLV_MEM_DATA
+#define HW_SLAVE_MEM_CTRL_REG		SLV_MEM_CTL
+#define HW_SLAVE_MEM_ENDIAN_REG		SLV_END_CTL
+
+#define HW_FUNC_EVENT_INT_EN		0x8000
+#define HW_FUNC_EVENT_MASK_REG		0x00000034
+
+#define ACX_MAC_TIMESTAMP_REG	(MAC_TIMESTAMP)
+
+/*===============================================
+  HI_CFG Interface Configuration Register Values
+  ------------------------------------------
+  ===============================================*/
+#define HI_CFG_UART_ENABLE          0x00000004
+#define HI_CFG_RST232_ENABLE        0x00000008
+#define HI_CFG_CLOCK_REQ_SELECT     0x00000010
+#define HI_CFG_HOST_INT_ENABLE      0x00000020
+#define HI_CFG_VLYNQ_OUTPUT_ENABLE  0x00000040
+#define HI_CFG_HOST_INT_ACTIVE_LOW  0x00000080
+#define HI_CFG_UART_TX_OUT_GPIO_15  0x00000100
+#define HI_CFG_UART_TX_OUT_GPIO_14  0x00000200
+#define HI_CFG_UART_TX_OUT_GPIO_7   0x00000400
+
+/*
+ * NOTE: USE_ACTIVE_HIGH compilation flag should be defined in makefile
+ *       for platforms using active high interrupt level
+ */
+#ifdef USE_ACTIVE_HIGH
+#define HI_CFG_DEF_VAL              \
+	(HI_CFG_UART_ENABLE |        \
+	HI_CFG_RST232_ENABLE |      \
+	HI_CFG_CLOCK_REQ_SELECT |   \
+	HI_CFG_HOST_INT_ENABLE)
+#else
+#define HI_CFG_DEF_VAL              \
+	(HI_CFG_UART_ENABLE |        \
+	HI_CFG_RST232_ENABLE |      \
+	HI_CFG_CLOCK_REQ_SELECT |   \
+	HI_CFG_HOST_INT_ENABLE)
+
+#endif
+
+#define REF_FREQ_19_2                       0
+#define REF_FREQ_26_0                       1
+#define REF_FREQ_38_4                       2
+#define REF_FREQ_40_0                       3
+#define REF_FREQ_33_6                       4
+#define REF_FREQ_NUM                        5
+
+#define LUT_PARAM_INTEGER_DIVIDER           0
+#define LUT_PARAM_FRACTIONAL_DIVIDER        1
+#define LUT_PARAM_ATTN_BB                   2
+#define LUT_PARAM_ALPHA_BB                  3
+#define LUT_PARAM_STOP_TIME_BB              4
+#define LUT_PARAM_BB_PLL_LOOP_FILTER        5
+#define LUT_PARAM_NUM                       6
+
+#define ACX_EEPROMLESS_IND_REG              (SCR_PAD4)
+#define USE_EEPROM                          0
+#define SOFT_RESET_MAX_TIME                 1000000
+#define SOFT_RESET_STALL_TIME               1000
+#define NVS_DATA_BUNDARY_ALIGNMENT          4
+
+
+/* Firmware image load chunk size */
+#define CHUNK_SIZE          512
+
+/* Firmware image header size */
+#define FW_HDR_SIZE 8
+
+#define ECPU_CONTROL_HALT					0x00000101
+
+
+/******************************************************************************
+
+    CHANNELS, BAND & REG DOMAINS definitions
+
+******************************************************************************/
+
+
+enum {
+	RADIO_BAND_2_4GHZ = 0,  /* 2.4 Ghz band */
+	RADIO_BAND_5GHZ = 1,    /* 5 Ghz band */
+	RADIO_BAND_JAPAN_4_9_GHZ = 2,
+	DEFAULT_BAND = RADIO_BAND_2_4GHZ,
+	INVALID_BAND = 0xFE,
+	MAX_RADIO_BANDS = 0xFF
+};
+
+enum {
+	NO_RATE      = 0,
+	RATE_1MBPS   = 0x0A,
+	RATE_2MBPS   = 0x14,
+	RATE_5_5MBPS = 0x37,
+	RATE_6MBPS   = 0x0B,
+	RATE_9MBPS   = 0x0F,
+	RATE_11MBPS  = 0x6E,
+	RATE_12MBPS  = 0x0A,
+	RATE_18MBPS  = 0x0E,
+	RATE_22MBPS  = 0xDC,
+	RATE_24MBPS  = 0x09,
+	RATE_36MBPS  = 0x0D,
+	RATE_48MBPS  = 0x08,
+	RATE_54MBPS  = 0x0C
+};
+
+enum {
+	RATE_INDEX_1MBPS   =  0,
+	RATE_INDEX_2MBPS   =  1,
+	RATE_INDEX_5_5MBPS =  2,
+	RATE_INDEX_6MBPS   =  3,
+	RATE_INDEX_9MBPS   =  4,
+	RATE_INDEX_11MBPS  =  5,
+	RATE_INDEX_12MBPS  =  6,
+	RATE_INDEX_18MBPS  =  7,
+	RATE_INDEX_22MBPS  =  8,
+	RATE_INDEX_24MBPS  =  9,
+	RATE_INDEX_36MBPS  =  10,
+	RATE_INDEX_48MBPS  =  11,
+	RATE_INDEX_54MBPS  =  12,
+	RATE_INDEX_MAX     =  RATE_INDEX_54MBPS,
+	MAX_RATE_INDEX,
+	INVALID_RATE_INDEX = MAX_RATE_INDEX,
+	RATE_INDEX_ENUM_MAX_SIZE = 0x7FFFFFFF
+};
+
+enum {
+	RATE_MASK_1MBPS = 0x1,
+	RATE_MASK_2MBPS = 0x2,
+	RATE_MASK_5_5MBPS = 0x4,
+	RATE_MASK_11MBPS = 0x20,
+};
+
+#define SHORT_PREAMBLE_BIT   BIT(0) /* CCK or Barker depending on the rate */
+#define OFDM_RATE_BIT        BIT(6)
+#define PBCC_RATE_BIT        BIT(7)
+
+enum {
+	CCK_LONG = 0,
+	CCK_SHORT = SHORT_PREAMBLE_BIT,
+	PBCC_LONG = PBCC_RATE_BIT,
+	PBCC_SHORT = PBCC_RATE_BIT | SHORT_PREAMBLE_BIT,
+	OFDM = OFDM_RATE_BIT
+};
+
+/******************************************************************************
+
+Transmit-Descriptor RATE-SET field definitions...
+
+Define a new "Rate-Set" for TX path that incorporates the
+Rate & Modulation info into a single 16-bit field.
+
+TxdRateSet_t:
+b15   - Indicates Preamble type (1=SHORT, 0=LONG).
+	Notes:
+	Must be LONG (0) for 1Mbps rate.
+	Does not apply (set to 0) for RevG-OFDM rates.
+b14   - Indicates PBCC encoding (1=PBCC, 0=not).
+	Notes:
+	Does not apply (set to 0) for rates 1 and 2 Mbps.
+	Does not apply (set to 0) for RevG-OFDM rates.
+b13    - Unused (set to 0).
+b12-b0 - Supported Rate indicator bits as defined below.
+
+******************************************************************************/
+
+
+#define TNETW1251_CHIP_ID_PG1_0         0x07010101
+#define TNETW1251_CHIP_ID_PG1_1         0x07020101
+#define TNETW1251_CHIP_ID_PG1_2	        0x07030101
+
+/*************************************************************************
+
+    Interrupt Trigger Register (Host -> WiLink)
+
+**************************************************************************/
+
+/* Hardware to Embedded CPU Interrupts - first 32-bit register set */
+
+/*
+ * Host Command Interrupt. Setting this bit masks
+ * the interrupt that the host issues to inform
+ * the FW that it has sent a command
+ * to the Wlan hardware Command Mailbox.
+ */
+#define INTR_TRIG_CMD       BIT(0)
+
+/*
+ * Host Event Acknowlegde Interrupt. The host
+ * sets this bit to acknowledge that it received
+ * the unsolicited information from the event
+ * mailbox.
+ */
+#define INTR_TRIG_EVENT_ACK BIT(1)
+
+/*
+ * The host sets this bit to inform the Wlan
+ * FW that a TX packet is in the XFER
+ * Buffer #0.
+ */
+#define INTR_TRIG_TX_PROC0 BIT(2)
+
+/*
+ * The host sets this bit to inform the FW
+ * that it read a packet from RX XFER
+ * Buffer #0.
+ */
+#define INTR_TRIG_RX_PROC0 BIT(3)
+
+#define INTR_TRIG_DEBUG_ACK BIT(4)
+
+#define INTR_TRIG_STATE_CHANGED BIT(5)
+
+
+/* Hardware to Embedded CPU Interrupts - second 32-bit register set */
+
+/*
+ * The host sets this bit to inform the FW
+ * that it read a packet from RX XFER
+ * Buffer #1.
+ */
+#define INTR_TRIG_RX_PROC1 BIT(17)
+
+/*
+ * The host sets this bit to inform the Wlan
+ * hardware that a TX packet is in the XFER
+ * Buffer #1.
+ */
+#define INTR_TRIG_TX_PROC1 BIT(18)
+
+#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_rx.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_rx.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_rx.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_rx.c	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,195 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/skbuff.h>
+#include <net/mac80211.h>
+
+#include "wl1251.h"
+#include "wl1251_reg.h"
+#include "wl1251_spi.h"
+#include "wl1251_rx.h"
+#include "wl1251_acx.h"
+
+static void wl1251_rx_header(struct wl1251 *wl,
+			     struct wl1251_rx_descriptor *desc)
+{
+	u32 rx_packet_ring_addr;
+
+	rx_packet_ring_addr = wl->data_path->rx_packet_ring_addr;
+	if (wl->rx_current_buffer)
+		rx_packet_ring_addr += wl->data_path->rx_packet_ring_chunk_size;
+
+	wl1251_spi_mem_read(wl, rx_packet_ring_addr, desc, sizeof(*desc));
+}
+
+static void wl1251_rx_status(struct wl1251 *wl,
+			     struct wl1251_rx_descriptor *desc,
+			     struct ieee80211_rx_status *status,
+			     u8 beacon)
+{
+	u64 mactime;
+	int ret;
+
+	memset(status, 0, sizeof(struct ieee80211_rx_status));
+
+	status->band = IEEE80211_BAND_2GHZ;
+	status->mactime = desc->timestamp;
+
+	/*
+	 * The rx status timestamp is a 32 bits value while the TSF is a
+	 * 64 bits one.
+	 * For IBSS merging, TSF is mandatory, so we have to get it
+	 * somehow, so we ask for ACX_TSF_INFO.
+	 * That could be moved to the get_tsf() hook, but unfortunately,
+	 * this one must be atomic, while our SPI routines can sleep.
+	 */
+	if ((wl->bss_type == BSS_TYPE_IBSS) && beacon) {
+		ret = wl1251_acx_tsf_info(wl, &mactime);
+		if (ret == 0)
+			status->mactime = mactime;
+	}
+
+	status->signal = desc->rssi;
+	status->qual = (desc->rssi - WL1251_RX_MIN_RSSI) * 100 /
+		(WL1251_RX_MAX_RSSI - WL1251_RX_MIN_RSSI);
+	status->qual = min(status->qual, 100);
+	status->qual = max(status->qual, 0);
+
+	/*
+	 * FIXME: guessing that snr needs to be divided by two, otherwise
+	 * the values don't make any sense
+	 */
+	status->noise = desc->rssi - desc->snr / 2;
+
+	status->freq = ieee80211_channel_to_frequency(desc->channel);
+
+	status->flag |= RX_FLAG_TSFT;
+
+	if (desc->flags & RX_DESC_ENCRYPTION_MASK) {
+		status->flag |= RX_FLAG_IV_STRIPPED | RX_FLAG_MMIC_STRIPPED;
+
+		if (likely(!(desc->flags & RX_DESC_DECRYPT_FAIL)))
+			status->flag |= RX_FLAG_DECRYPTED;
+
+		if (unlikely(desc->flags & RX_DESC_MIC_FAIL))
+			status->flag |= RX_FLAG_MMIC_ERROR;
+	}
+
+	if (unlikely(!(desc->flags & RX_DESC_VALID_FCS)))
+		status->flag |= RX_FLAG_FAILED_FCS_CRC;
+
+
+	/* FIXME: set status->rate_idx */
+}
+
+static void wl1251_rx_body(struct wl1251 *wl,
+			   struct wl1251_rx_descriptor *desc)
+{
+	struct sk_buff *skb;
+	struct ieee80211_rx_status status;
+	u8 *rx_buffer, beacon = 0;
+	u16 length, *fc;
+	u32 curr_id, last_id_inc, rx_packet_ring_addr;
+
+	length = WL1251_RX_ALIGN(desc->length  - PLCP_HEADER_LENGTH);
+	curr_id = (desc->flags & RX_DESC_SEQNUM_MASK) >> RX_DESC_PACKETID_SHIFT;
+	last_id_inc = (wl->rx_last_id + 1) % (RX_MAX_PACKET_ID + 1);
+
+	if (last_id_inc != curr_id) {
+		wl1251_warning("curr ID:%d, last ID inc:%d",
+			       curr_id, last_id_inc);
+		wl->rx_last_id = curr_id;
+	} else {
+		wl->rx_last_id = last_id_inc;
+	}
+
+	rx_packet_ring_addr = wl->data_path->rx_packet_ring_addr +
+		sizeof(struct wl1251_rx_descriptor) + 20;
+	if (wl->rx_current_buffer)
+		rx_packet_ring_addr += wl->data_path->rx_packet_ring_chunk_size;
+
+	skb = dev_alloc_skb(length);
+	if (!skb) {
+		wl1251_error("Couldn't allocate RX frame");
+		return;
+	}
+
+	rx_buffer = skb_put(skb, length);
+	wl1251_spi_mem_read(wl, rx_packet_ring_addr, rx_buffer, length);
+
+	/* The actual lenght doesn't include the target's alignment */
+	skb->len = desc->length  - PLCP_HEADER_LENGTH;
+
+	fc = (u16 *)skb->data;
+
+	if ((*fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_BEACON)
+		beacon = 1;
+
+	wl1251_rx_status(wl, desc, &status, beacon);
+
+	wl1251_debug(DEBUG_RX, "rx skb 0x%p: %d B %s", skb, skb->len,
+		     beacon ? "beacon" : "");
+
+	ieee80211_rx(wl->hw, skb, &status);
+}
+
+static void wl1251_rx_ack(struct wl1251 *wl)
+{
+	u32 data, addr;
+
+	if (wl->rx_current_buffer) {
+		addr = ACX_REG_INTERRUPT_TRIG_H;
+		data = INTR_TRIG_RX_PROC1;
+	} else {
+		addr = ACX_REG_INTERRUPT_TRIG;
+		data = INTR_TRIG_RX_PROC0;
+	}
+
+	wl1251_reg_write32(wl, addr, data);
+
+	/* Toggle buffer ring */
+	wl->rx_current_buffer = !wl->rx_current_buffer;
+}
+
+
+void wl1251_rx(struct wl1251 *wl)
+{
+	struct wl1251_rx_descriptor *rx_desc;
+
+	if (wl->state != WL1251_STATE_ON)
+		return;
+
+	rx_desc = wl->rx_descriptor;
+
+	/* We first read the frame's header */
+	wl1251_rx_header(wl, rx_desc);
+
+	/* Now we can read the body */
+	wl1251_rx_body(wl, rx_desc);
+
+	/* Finally, we need to ACK the RX */
+	wl1251_rx_ack(wl);
+
+	return;
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_rx.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_rx.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_rx.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_rx.h	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,124 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __WL1251_RX_H__
+#define __WL1251_RX_H__
+
+#include <linux/bitops.h>
+
+#include "wl1251.h"
+
+/*
+ * RX PATH
+ *
+ * The Rx path uses a double buffer and an rx_contro structure, each located
+ * at a fixed address in the device memory. The host keeps track of which
+ * buffer is available and alternates between them on a per packet basis.
+ * The size of each of the two buffers is large enough to hold the longest
+ * 802.3 packet.
+ * The RX path goes like that:
+ * 1) The target generates an interrupt each time a new packet is received.
+ *   There are 2 RX interrupts, one for each buffer.
+ * 2) The host reads the received packet from one of the double buffers.
+ * 3) The host triggers a target interrupt.
+ * 4) The target prepares the next RX packet.
+ */
+
+#define WL1251_RX_MAX_RSSI -30
+#define WL1251_RX_MIN_RSSI -95
+
+#define WL1251_RX_ALIGN_TO 4
+#define WL1251_RX_ALIGN(len) (((len) + WL1251_RX_ALIGN_TO - 1) & \
+			     ~(WL1251_RX_ALIGN_TO - 1))
+
+#define SHORT_PREAMBLE_BIT   BIT(0)
+#define OFDM_RATE_BIT        BIT(6)
+#define PBCC_RATE_BIT        BIT(7)
+
+#define PLCP_HEADER_LENGTH 8
+#define RX_DESC_PACKETID_SHIFT 11
+#define RX_MAX_PACKET_ID 3
+
+#define RX_DESC_VALID_FCS         0x0001
+#define RX_DESC_MATCH_RXADDR1     0x0002
+#define RX_DESC_MCAST             0x0004
+#define RX_DESC_STAINTIM          0x0008
+#define RX_DESC_VIRTUAL_BM        0x0010
+#define RX_DESC_BCAST             0x0020
+#define RX_DESC_MATCH_SSID        0x0040
+#define RX_DESC_MATCH_BSSID       0x0080
+#define RX_DESC_ENCRYPTION_MASK   0x0300
+#define RX_DESC_MEASURMENT        0x0400
+#define RX_DESC_SEQNUM_MASK       0x1800
+#define	RX_DESC_MIC_FAIL	  0x2000
+#define	RX_DESC_DECRYPT_FAIL	  0x4000
+
+struct wl1251_rx_descriptor {
+	u32 timestamp; /* In microseconds */
+	u16 length; /* Paylod length, including headers */
+	u16 flags;
+
+	/*
+	 * 0 - 802.11
+	 * 1 - 802.3
+	 * 2 - IP
+	 * 3 - Raw Codec
+	 */
+	u8 type;
+
+	/*
+	 * Recevied Rate:
+	 * 0x0A - 1MBPS
+	 * 0x14 - 2MBPS
+	 * 0x37 - 5_5MBPS
+	 * 0x0B - 6MBPS
+	 * 0x0F - 9MBPS
+	 * 0x6E - 11MBPS
+	 * 0x0A - 12MBPS
+	 * 0x0E - 18MBPS
+	 * 0xDC - 22MBPS
+	 * 0x09 - 24MBPS
+	 * 0x0D - 36MBPS
+	 * 0x08 - 48MBPS
+	 * 0x0C - 54MBPS
+	 */
+	u8 rate;
+
+	u8 mod_pre; /* Modulation and preamble */
+	u8 channel;
+
+	/*
+	 * 0 - 2.4 Ghz
+	 * 1 - 5 Ghz
+	 */
+	u8 band;
+
+	s8 rssi; /* in dB */
+	u8 rcpi; /* in dB */
+	u8 snr; /* in dB */
+} __attribute__ ((packed));
+
+void wl1251_rx(struct wl1251 *wl);
+
+#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_spi.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_spi.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_spi.c	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,409 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/crc7.h>
+#include <linux/spi/spi.h>
+
+#include "wl1251.h"
+#include "wl1251_reg.h"
+#include "wl1251_spi.h"
+
+/* FIXME: this is static data nowadays and the table can be removed */
+static enum wl12xx_acx_int_reg wl1251_acx_reg_table[ACX_REG_TABLE_LEN] = {
+	[ACX_REG_INTERRUPT_TRIG]     = (REGISTERS_BASE + 0x0474),
+	[ACX_REG_INTERRUPT_TRIG_H]   = (REGISTERS_BASE + 0x0478),
+	[ACX_REG_INTERRUPT_MASK]     = (REGISTERS_BASE + 0x0494),
+	[ACX_REG_HINT_MASK_SET]      = (REGISTERS_BASE + 0x0498),
+	[ACX_REG_HINT_MASK_CLR]      = (REGISTERS_BASE + 0x049C),
+	[ACX_REG_INTERRUPT_NO_CLEAR] = (REGISTERS_BASE + 0x04B0),
+	[ACX_REG_INTERRUPT_CLEAR]    = (REGISTERS_BASE + 0x04A4),
+	[ACX_REG_INTERRUPT_ACK]      = (REGISTERS_BASE + 0x04A8),
+	[ACX_REG_SLV_SOFT_RESET]     = (REGISTERS_BASE + 0x0000),
+	[ACX_REG_EE_START]           = (REGISTERS_BASE + 0x080C),
+	[ACX_REG_ECPU_CONTROL]       = (REGISTERS_BASE + 0x0804)
+};
+
+static int wl1251_translate_reg_addr(struct wl1251 *wl, int addr)
+{
+	/* If the address is lower than REGISTERS_BASE, it means that this is
+	 * a chip-specific register address, so look it up in the registers
+	 * table */
+	if (addr < REGISTERS_BASE) {
+		/* Make sure we don't go over the table */
+		if (addr >= ACX_REG_TABLE_LEN) {
+			wl1251_error("address out of range (%d)", addr);
+			return -EINVAL;
+		}
+		addr = wl1251_acx_reg_table[addr];
+	}
+
+	return addr - wl->physical_reg_addr + wl->virtual_reg_addr;
+}
+
+static int wl1251_translate_mem_addr(struct wl1251 *wl, int addr)
+{
+	return addr - wl->physical_mem_addr + wl->virtual_mem_addr;
+}
+
+
+void wl1251_spi_reset(struct wl1251 *wl)
+{
+	u8 *cmd;
+	struct spi_transfer t;
+	struct spi_message m;
+
+	cmd = kzalloc(WSPI_INIT_CMD_LEN, GFP_KERNEL);
+	if (!cmd) {
+		wl1251_error("could not allocate cmd for spi reset");
+		return;
+	}
+
+	memset(&t, 0, sizeof(t));
+	spi_message_init(&m);
+
+	memset(cmd, 0xff, WSPI_INIT_CMD_LEN);
+
+	t.tx_buf = cmd;
+	t.len = WSPI_INIT_CMD_LEN;
+	spi_message_add_tail(&t, &m);
+
+	spi_sync(wl->spi, &m);
+
+	wl1251_dump(DEBUG_SPI, "spi reset -> ", cmd, WSPI_INIT_CMD_LEN);
+}
+
+void wl1251_spi_init(struct wl1251 *wl)
+{
+	u8 crc[WSPI_INIT_CMD_CRC_LEN], *cmd;
+	struct spi_transfer t;
+	struct spi_message m;
+
+	cmd = kzalloc(WSPI_INIT_CMD_LEN, GFP_KERNEL);
+	if (!cmd) {
+		wl1251_error("could not allocate cmd for spi init");
+		return;
+	}
+
+	memset(crc, 0, sizeof(crc));
+	memset(&t, 0, sizeof(t));
+	spi_message_init(&m);
+
+	/*
+	 * Set WSPI_INIT_COMMAND
+	 * the data is being send from the MSB to LSB
+	 */
+	cmd[2] = 0xff;
+	cmd[3] = 0xff;
+	cmd[1] = WSPI_INIT_CMD_START | WSPI_INIT_CMD_TX;
+	cmd[0] = 0;
+	cmd[7] = 0;
+	cmd[6] |= HW_ACCESS_WSPI_INIT_CMD_MASK << 3;
+	cmd[6] |= HW_ACCESS_WSPI_FIXED_BUSY_LEN & WSPI_INIT_CMD_FIXEDBUSY_LEN;
+
+	if (HW_ACCESS_WSPI_FIXED_BUSY_LEN == 0)
+		cmd[5] |=  WSPI_INIT_CMD_DIS_FIXEDBUSY;
+	else
+		cmd[5] |= WSPI_INIT_CMD_EN_FIXEDBUSY;
+
+	cmd[5] |= WSPI_INIT_CMD_IOD | WSPI_INIT_CMD_IP | WSPI_INIT_CMD_CS
+		| WSPI_INIT_CMD_WSPI | WSPI_INIT_CMD_WS;
+
+	crc[0] = cmd[1];
+	crc[1] = cmd[0];
+	crc[2] = cmd[7];
+	crc[3] = cmd[6];
+	crc[4] = cmd[5];
+
+	cmd[4] |= crc7(0, crc, WSPI_INIT_CMD_CRC_LEN) << 1;
+	cmd[4] |= WSPI_INIT_CMD_END;
+
+	t.tx_buf = cmd;
+	t.len = WSPI_INIT_CMD_LEN;
+	spi_message_add_tail(&t, &m);
+
+	spi_sync(wl->spi, &m);
+
+	wl1251_dump(DEBUG_SPI, "spi init -> ", cmd, WSPI_INIT_CMD_LEN);
+}
+
+/* Set the SPI partitions to access the chip addresses
+ *
+ * There are two VIRTUAL (SPI) partitions (the memory partition and the
+ * registers partition), which are mapped to two different areas of the
+ * PHYSICAL (hardware) memory.  This function also makes other checks to
+ * ensure that the partitions are not overlapping.  In the diagram below, the
+ * memory partition comes before the register partition, but the opposite is
+ * also supported.
+ *
+ *                               PHYSICAL address
+ *                                     space
+ *
+ *                                    |    |
+ *                                 ...+----+--> mem_start
+ *          VIRTUAL address     ...   |    |
+ *               space       ...      |    | [PART_0]
+ *                        ...         |    |
+ * 0x00000000 <--+----+...         ...+----+--> mem_start + mem_size
+ *               |    |         ...   |    |
+ *               |MEM |      ...      |    |
+ *               |    |   ...         |    |
+ *  part_size <--+----+...            |    | {unused area)
+ *               |    |   ...         |    |
+ *               |REG |      ...      |    |
+ *  part_size    |    |         ...   |    |
+ *      +     <--+----+...         ...+----+--> reg_start
+ *  reg_size              ...         |    |
+ *                           ...      |    | [PART_1]
+ *                              ...   |    |
+ *                                 ...+----+--> reg_start + reg_size
+ *                                    |    |
+ *
+ */
+int wl1251_set_partition(struct wl1251 *wl,
+			  u32 mem_start, u32 mem_size,
+			  u32 reg_start, u32 reg_size)
+{
+	struct wl1251_partition *partition;
+	struct spi_transfer t;
+	struct spi_message m;
+	size_t len, cmd_len;
+	u32 *cmd;
+	int addr;
+
+	cmd_len = sizeof(u32) + 2 * sizeof(struct wl1251_partition);
+	cmd = kzalloc(cmd_len, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	spi_message_init(&m);
+	memset(&t, 0, sizeof(t));
+
+	partition = (struct wl1251_partition *) (cmd + 1);
+	addr = HW_ACCESS_PART0_SIZE_ADDR;
+	len = 2 * sizeof(struct wl1251_partition);
+
+	*cmd |= WSPI_CMD_WRITE;
+	*cmd |= (len << WSPI_CMD_BYTE_LENGTH_OFFSET) & WSPI_CMD_BYTE_LENGTH;
+	*cmd |= addr & WSPI_CMD_BYTE_ADDR;
+
+	wl1251_debug(DEBUG_SPI, "mem_start %08X mem_size %08X",
+		     mem_start, mem_size);
+	wl1251_debug(DEBUG_SPI, "reg_start %08X reg_size %08X",
+		     reg_start, reg_size);
+
+	/* Make sure that the two partitions together don't exceed the
+	 * address range */
+	if ((mem_size + reg_size) > HW_ACCESS_MEMORY_MAX_RANGE) {
+		wl1251_debug(DEBUG_SPI, "Total size exceeds maximum virtual"
+			     " address range.  Truncating partition[0].");
+		mem_size = HW_ACCESS_MEMORY_MAX_RANGE - reg_size;
+		wl1251_debug(DEBUG_SPI, "mem_start %08X mem_size %08X",
+			     mem_start, mem_size);
+		wl1251_debug(DEBUG_SPI, "reg_start %08X reg_size %08X",
+			     reg_start, reg_size);
+	}
+
+	if ((mem_start < reg_start) &&
+	    ((mem_start + mem_size) > reg_start)) {
+		/* Guarantee that the memory partition doesn't overlap the
+		 * registers partition */
+		wl1251_debug(DEBUG_SPI, "End of partition[0] is "
+			     "overlapping partition[1].  Adjusted.");
+		mem_size = reg_start - mem_start;
+		wl1251_debug(DEBUG_SPI, "mem_start %08X mem_size %08X",
+			     mem_start, mem_size);
+		wl1251_debug(DEBUG_SPI, "reg_start %08X reg_size %08X",
+			     reg_start, reg_size);
+	} else if ((reg_start < mem_start) &&
+		   ((reg_start + reg_size) > mem_start)) {
+		/* Guarantee that the register partition doesn't overlap the
+		 * memory partition */
+		wl1251_debug(DEBUG_SPI, "End of partition[1] is"
+			     " overlapping partition[0].  Adjusted.");
+		reg_size = mem_start - reg_start;
+		wl1251_debug(DEBUG_SPI, "mem_start %08X mem_size %08X",
+			     mem_start, mem_size);
+		wl1251_debug(DEBUG_SPI, "reg_start %08X reg_size %08X",
+			     reg_start, reg_size);
+	}
+
+	partition[0].start = mem_start;
+	partition[0].size  = mem_size;
+	partition[1].start = reg_start;
+	partition[1].size  = reg_size;
+
+	wl->physical_mem_addr = mem_start;
+	wl->physical_reg_addr = reg_start;
+
+	wl->virtual_mem_addr = 0;
+	wl->virtual_reg_addr = mem_size;
+
+	t.tx_buf = cmd;
+	t.len = cmd_len;
+	spi_message_add_tail(&t, &m);
+
+	spi_sync(wl->spi, &m);
+
+	kfree(cmd);
+
+	return 0;
+}
+
+void wl1251_spi_read(struct wl1251 *wl, int addr, void *buf,
+		     size_t len, bool fixed)
+{
+	struct spi_transfer t[3];
+	struct spi_message m;
+	u8 *busy_buf;
+	u32 *cmd;
+
+	cmd = &wl->buffer_cmd;
+	busy_buf = wl->buffer_busyword;
+
+	*cmd = 0;
+	*cmd |= WSPI_CMD_READ;
+	*cmd |= (len << WSPI_CMD_BYTE_LENGTH_OFFSET) & WSPI_CMD_BYTE_LENGTH;
+	*cmd |= addr & WSPI_CMD_BYTE_ADDR;
+
+	if (fixed)
+		*cmd |= WSPI_CMD_FIXED;
+
+	spi_message_init(&m);
+	memset(t, 0, sizeof(t));
+
+	t[0].tx_buf = cmd;
+	t[0].len = 4;
+	spi_message_add_tail(&t[0], &m);
+
+	/* Busy and non busy words read */
+	t[1].rx_buf = busy_buf;
+	t[1].len = WL1251_BUSY_WORD_LEN;
+	spi_message_add_tail(&t[1], &m);
+
+	t[2].rx_buf = buf;
+	t[2].len = len;
+	spi_message_add_tail(&t[2], &m);
+
+	spi_sync(wl->spi, &m);
+
+	/* FIXME: check busy words */
+
+	wl1251_dump(DEBUG_SPI, "spi_read cmd -> ", cmd, sizeof(*cmd));
+	wl1251_dump(DEBUG_SPI, "spi_read buf <- ", buf, len);
+}
+
+void wl1251_spi_write(struct wl1251 *wl, int addr, void *buf,
+		      size_t len, bool fixed)
+{
+	struct spi_transfer t[2];
+	struct spi_message m;
+	u32 *cmd;
+
+	cmd = &wl->buffer_cmd;
+
+	*cmd = 0;
+	*cmd |= WSPI_CMD_WRITE;
+	*cmd |= (len << WSPI_CMD_BYTE_LENGTH_OFFSET) & WSPI_CMD_BYTE_LENGTH;
+	*cmd |= addr & WSPI_CMD_BYTE_ADDR;
+
+	if (fixed)
+		*cmd |= WSPI_CMD_FIXED;
+
+	spi_message_init(&m);
+	memset(t, 0, sizeof(t));
+
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(*cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].tx_buf = buf;
+	t[1].len = len;
+	spi_message_add_tail(&t[1], &m);
+
+	spi_sync(wl->spi, &m);
+
+	wl1251_dump(DEBUG_SPI, "spi_write cmd -> ", cmd, sizeof(*cmd));
+	wl1251_dump(DEBUG_SPI, "spi_write buf -> ", buf, len);
+}
+
+void wl1251_spi_mem_read(struct wl1251 *wl, int addr, void *buf,
+			 size_t len)
+{
+	int physical;
+
+	physical = wl1251_translate_mem_addr(wl, addr);
+
+	wl1251_spi_read(wl, physical, buf, len, false);
+}
+
+void wl1251_spi_mem_write(struct wl1251 *wl, int addr, void *buf,
+			  size_t len)
+{
+	int physical;
+
+	physical = wl1251_translate_mem_addr(wl, addr);
+
+	wl1251_spi_write(wl, physical, buf, len, false);
+}
+
+void wl1251_spi_reg_read(struct wl1251 *wl, int addr, void *buf, size_t len,
+			 bool fixed)
+{
+	int physical;
+
+	physical = wl1251_translate_reg_addr(wl, addr);
+
+	wl1251_spi_read(wl, physical, buf, len, fixed);
+}
+
+void wl1251_spi_reg_write(struct wl1251 *wl, int addr, void *buf, size_t len,
+			  bool fixed)
+{
+	int physical;
+
+	physical = wl1251_translate_reg_addr(wl, addr);
+
+	wl1251_spi_write(wl, physical, buf, len, fixed);
+}
+
+u32 wl1251_mem_read32(struct wl1251 *wl, int addr)
+{
+	return wl1251_read32(wl, wl1251_translate_mem_addr(wl, addr));
+}
+
+void wl1251_mem_write32(struct wl1251 *wl, int addr, u32 val)
+{
+	wl1251_write32(wl, wl1251_translate_mem_addr(wl, addr), val);
+}
+
+u32 wl1251_reg_read32(struct wl1251 *wl, int addr)
+{
+	return wl1251_read32(wl, wl1251_translate_reg_addr(wl, addr));
+}
+
+void wl1251_reg_write32(struct wl1251 *wl, int addr, u32 val)
+{
+	wl1251_write32(wl, wl1251_translate_reg_addr(wl, addr), val);
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_spi.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_spi.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_spi.h	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,111 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __WL1251_SPI_H__
+#define __WL1251_SPI_H__
+
+#define HW_ACCESS_MEMORY_MAX_RANGE		0x1FFC0
+
+#define HW_ACCESS_PART0_SIZE_ADDR           0x1FFC0
+#define HW_ACCESS_PART0_START_ADDR          0x1FFC4
+#define HW_ACCESS_PART1_SIZE_ADDR           0x1FFC8
+#define HW_ACCESS_PART1_START_ADDR          0x1FFCC
+
+#define HW_ACCESS_REGISTER_SIZE             4
+
+#define HW_ACCESS_PRAM_MAX_RANGE		0x3c000
+
+#define WSPI_CMD_READ                 0x40000000
+#define WSPI_CMD_WRITE                0x00000000
+#define WSPI_CMD_FIXED                0x20000000
+#define WSPI_CMD_BYTE_LENGTH          0x1FFE0000
+#define WSPI_CMD_BYTE_LENGTH_OFFSET   17
+#define WSPI_CMD_BYTE_ADDR            0x0001FFFF
+
+#define WSPI_INIT_CMD_CRC_LEN       5
+
+#define WSPI_INIT_CMD_START         0x00
+#define WSPI_INIT_CMD_TX            0x40
+/* the extra bypass bit is sampled by the TNET as '1' */
+#define WSPI_INIT_CMD_BYPASS_BIT    0x80
+#define WSPI_INIT_CMD_FIXEDBUSY_LEN 0x07
+#define WSPI_INIT_CMD_EN_FIXEDBUSY  0x80
+#define WSPI_INIT_CMD_DIS_FIXEDBUSY 0x00
+#define WSPI_INIT_CMD_IOD           0x40
+#define WSPI_INIT_CMD_IP            0x20
+#define WSPI_INIT_CMD_CS            0x10
+#define WSPI_INIT_CMD_WS            0x08
+#define WSPI_INIT_CMD_WSPI          0x01
+#define WSPI_INIT_CMD_END           0x01
+
+#define WSPI_INIT_CMD_LEN           8
+
+#define HW_ACCESS_WSPI_FIXED_BUSY_LEN \
+		((WL1251_BUSY_WORD_LEN - 4) / sizeof(u32))
+#define HW_ACCESS_WSPI_INIT_CMD_MASK  0
+
+
+/* Raw target IO, address is not translated */
+void wl1251_spi_write(struct wl1251 *wl, int addr, void *buf,
+		      size_t len, bool fixed);
+void wl1251_spi_read(struct wl1251 *wl, int addr, void *buf,
+		     size_t len, bool fixed);
+
+/* Memory target IO, address is tranlated to partition 0 */
+void wl1251_spi_mem_read(struct wl1251 *wl, int addr, void *buf, size_t len);
+void wl1251_spi_mem_write(struct wl1251 *wl, int addr, void *buf, size_t len);
+u32 wl1251_mem_read32(struct wl1251 *wl, int addr);
+void wl1251_mem_write32(struct wl1251 *wl, int addr, u32 val);
+
+/* Registers IO */
+void wl1251_spi_reg_read(struct wl1251 *wl, int addr, void *buf, size_t len,
+			 bool fixed);
+void wl1251_spi_reg_write(struct wl1251 *wl, int addr, void *buf, size_t len,
+			  bool fixed);
+u32 wl1251_reg_read32(struct wl1251 *wl, int addr);
+void wl1251_reg_write32(struct wl1251 *wl, int addr, u32 val);
+
+/* INIT and RESET words */
+void wl1251_spi_reset(struct wl1251 *wl);
+void wl1251_spi_init(struct wl1251 *wl);
+int wl1251_set_partition(struct wl1251 *wl,
+			 u32 part_start, u32 part_size,
+			 u32 reg_start,  u32 reg_size);
+
+static inline u32 wl1251_read32(struct wl1251 *wl, int addr)
+{
+	wl1251_spi_read(wl, addr, &wl->buffer_32,
+			sizeof(wl->buffer_32), false);
+
+	return wl->buffer_32;
+}
+
+static inline void wl1251_write32(struct wl1251 *wl, int addr, u32 val)
+{
+	wl->buffer_32 = val;
+	wl1251_spi_write(wl, addr, &wl->buffer_32,
+			 sizeof(wl->buffer_32), false);
+}
+
+#endif /* __WL1251_SPI_H__ */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_tx.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_tx.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_tx.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_tx.c	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,564 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include "wl1251.h"
+#include "wl1251_reg.h"
+#include "wl1251_spi.h"
+#include "wl1251_tx.h"
+#include "wl1251_ps.h"
+
+static bool wl1251_tx_double_buffer_busy(struct wl1251 *wl, u32 data_out_count)
+{
+	int used, data_in_count;
+
+	data_in_count = wl->data_in_count;
+
+	if (data_in_count < data_out_count)
+		/* data_in_count has wrapped */
+		data_in_count += TX_STATUS_DATA_OUT_COUNT_MASK + 1;
+
+	used = data_in_count - data_out_count;
+
+	WARN_ON(used < 0);
+	WARN_ON(used > DP_TX_PACKET_RING_CHUNK_NUM);
+
+	if (used >= DP_TX_PACKET_RING_CHUNK_NUM)
+		return true;
+	else
+		return false;
+}
+
+static int wl1251_tx_path_status(struct wl1251 *wl)
+{
+	u32 status, addr, data_out_count;
+	bool busy;
+
+	addr = wl->data_path->tx_control_addr;
+	status = wl1251_mem_read32(wl, addr);
+	data_out_count = status & TX_STATUS_DATA_OUT_COUNT_MASK;
+	busy = wl1251_tx_double_buffer_busy(wl, data_out_count);
+
+	if (busy)
+		return -EBUSY;
+
+	return 0;
+}
+
+static int wl1251_tx_id(struct wl1251 *wl, struct sk_buff *skb)
+{
+	int i;
+
+	for (i = 0; i < FW_TX_CMPLT_BLOCK_SIZE; i++)
+		if (wl->tx_frames[i] == NULL) {
+			wl->tx_frames[i] = skb;
+			return i;
+		}
+
+	return -EBUSY;
+}
+
+static void wl1251_tx_control(struct tx_double_buffer_desc *tx_hdr,
+			      struct ieee80211_tx_info *control, u16 fc)
+{
+	*(u16 *)&tx_hdr->control = 0;
+
+	tx_hdr->control.rate_policy = 0;
+
+	/* 802.11 packets */
+	tx_hdr->control.packet_type = 0;
+
+	if (control->flags & IEEE80211_TX_CTL_NO_ACK)
+		tx_hdr->control.ack_policy = 1;
+
+	tx_hdr->control.tx_complete = 1;
+
+	if ((fc & IEEE80211_FTYPE_DATA) &&
+	    ((fc & IEEE80211_STYPE_QOS_DATA) ||
+	     (fc & IEEE80211_STYPE_QOS_NULLFUNC)))
+		tx_hdr->control.qos = 1;
+}
+
+/* RSN + MIC = 8 + 8 = 16 bytes (worst case - AES). */
+#define MAX_MSDU_SECURITY_LENGTH      16
+#define MAX_MPDU_SECURITY_LENGTH      16
+#define WLAN_QOS_HDR_LEN              26
+#define MAX_MPDU_HEADER_AND_SECURITY  (MAX_MPDU_SECURITY_LENGTH + \
+				       WLAN_QOS_HDR_LEN)
+#define HW_BLOCK_SIZE                 252
+static void wl1251_tx_frag_block_num(struct tx_double_buffer_desc *tx_hdr)
+{
+	u16 payload_len, frag_threshold, mem_blocks;
+	u16 num_mpdus, mem_blocks_per_frag;
+
+	frag_threshold = IEEE80211_MAX_FRAG_THRESHOLD;
+	tx_hdr->frag_threshold = cpu_to_le16(frag_threshold);
+
+	payload_len = tx_hdr->length + MAX_MSDU_SECURITY_LENGTH;
+
+	if (payload_len > frag_threshold) {
+		mem_blocks_per_frag =
+			((frag_threshold + MAX_MPDU_HEADER_AND_SECURITY) /
+			 HW_BLOCK_SIZE) + 1;
+		num_mpdus = payload_len / frag_threshold;
+		mem_blocks = num_mpdus * mem_blocks_per_frag;
+		payload_len -= num_mpdus * frag_threshold;
+		num_mpdus++;
+
+	} else {
+		mem_blocks_per_frag = 0;
+		mem_blocks = 0;
+		num_mpdus = 1;
+	}
+
+	mem_blocks += (payload_len / HW_BLOCK_SIZE) + 1;
+
+	if (num_mpdus > 1)
+		mem_blocks += min(num_mpdus, mem_blocks_per_frag);
+
+	tx_hdr->num_mem_blocks = mem_blocks;
+}
+
+static int wl1251_tx_fill_hdr(struct wl1251 *wl, struct sk_buff *skb,
+			      struct ieee80211_tx_info *control)
+{
+	struct tx_double_buffer_desc *tx_hdr;
+	struct ieee80211_rate *rate;
+	int id;
+	u16 fc;
+
+	if (!skb)
+		return -EINVAL;
+
+	id = wl1251_tx_id(wl, skb);
+	if (id < 0)
+		return id;
+
+	fc = *(u16 *)skb->data;
+	tx_hdr = (struct tx_double_buffer_desc *) skb_push(skb,
+							   sizeof(*tx_hdr));
+
+	tx_hdr->length = cpu_to_le16(skb->len - sizeof(*tx_hdr));
+	rate = ieee80211_get_tx_rate(wl->hw, control);
+	tx_hdr->rate = cpu_to_le16(rate->hw_value);
+	tx_hdr->expiry_time = cpu_to_le32(1 << 16);
+	tx_hdr->id = id;
+
+	/* FIXME: how to get the correct queue id? */
+	tx_hdr->xmit_queue = 0;
+
+	wl1251_tx_control(tx_hdr, control, fc);
+	wl1251_tx_frag_block_num(tx_hdr);
+
+	return 0;
+}
+
+/* We copy the packet to the target */
+static int wl1251_tx_send_packet(struct wl1251 *wl, struct sk_buff *skb,
+				 struct ieee80211_tx_info *control)
+{
+	struct tx_double_buffer_desc *tx_hdr;
+	int len;
+	u32 addr;
+
+	if (!skb)
+		return -EINVAL;
+
+	tx_hdr = (struct tx_double_buffer_desc *) skb->data;
+
+	if (control->control.hw_key &&
+	    control->control.hw_key->alg == ALG_TKIP) {
+		int hdrlen;
+		u16 fc;
+		u8 *pos;
+
+		fc = *(u16 *)(skb->data + sizeof(*tx_hdr));
+		tx_hdr->length += WL1251_TKIP_IV_SPACE;
+
+		hdrlen = ieee80211_hdrlen(fc);
+
+		pos = skb_push(skb, WL1251_TKIP_IV_SPACE);
+		memmove(pos, pos + WL1251_TKIP_IV_SPACE,
+			sizeof(*tx_hdr) + hdrlen);
+	}
+
+	/* Revisit. This is a workaround for getting non-aligned packets.
+	   This happens at least with EAPOL packets from the user space.
+	   Our DMA requires packets to be aligned on a 4-byte boundary.
+	*/
+	if (unlikely((long)skb->data & 0x03)) {
+		int offset = (4 - (long)skb->data) & 0x03;
+		wl1251_debug(DEBUG_TX, "skb offset %d", offset);
+
+		/* check whether the current skb can be used */
+		if (!skb_cloned(skb) && (skb_tailroom(skb) >= offset)) {
+			unsigned char *src = skb->data;
+
+			/* align the buffer on a 4-byte boundary */
+			skb_reserve(skb, offset);
+			memmove(skb->data, src, skb->len);
+		} else {
+			wl1251_info("No handler, fixme!");
+			return -EINVAL;
+		}
+	}
+
+	/* Our skb->data at this point includes the HW header */
+	len = WL1251_TX_ALIGN(skb->len);
+
+	if (wl->data_in_count & 0x1)
+		addr = wl->data_path->tx_packet_ring_addr +
+			wl->data_path->tx_packet_ring_chunk_size;
+	else
+		addr = wl->data_path->tx_packet_ring_addr;
+
+	wl1251_spi_mem_write(wl, addr, skb->data, len);
+
+	wl1251_debug(DEBUG_TX, "tx id %u skb 0x%p payload %u rate 0x%x",
+		     tx_hdr->id, skb, tx_hdr->length, tx_hdr->rate);
+
+	return 0;
+}
+
+static void wl1251_tx_trigger(struct wl1251 *wl)
+{
+	u32 data, addr;
+
+	if (wl->data_in_count & 0x1) {
+		addr = ACX_REG_INTERRUPT_TRIG_H;
+		data = INTR_TRIG_TX_PROC1;
+	} else {
+		addr = ACX_REG_INTERRUPT_TRIG;
+		data = INTR_TRIG_TX_PROC0;
+	}
+
+	wl1251_reg_write32(wl, addr, data);
+
+	/* Bumping data in */
+	wl->data_in_count = (wl->data_in_count + 1) &
+		TX_STATUS_DATA_OUT_COUNT_MASK;
+}
+
+/* caller must hold wl->mutex */
+static int wl1251_tx_frame(struct wl1251 *wl, struct sk_buff *skb)
+{
+	struct ieee80211_tx_info *info;
+	int ret = 0;
+	u8 idx;
+
+	info = IEEE80211_SKB_CB(skb);
+
+	if (info->control.hw_key) {
+		idx = info->control.hw_key->hw_key_idx;
+		if (unlikely(wl->default_key != idx)) {
+			ret = wl1251_acx_default_key(wl, idx);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	ret = wl1251_tx_path_status(wl);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1251_tx_fill_hdr(wl, skb, info);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1251_tx_send_packet(wl, skb, info);
+	if (ret < 0)
+		return ret;
+
+	wl1251_tx_trigger(wl);
+
+	return ret;
+}
+
+void wl1251_tx_work(struct work_struct *work)
+{
+	struct wl1251 *wl = container_of(work, struct wl1251, tx_work);
+	struct sk_buff *skb;
+	bool woken_up = false;
+	int ret;
+
+	mutex_lock(&wl->mutex);
+
+	if (unlikely(wl->state == WL1251_STATE_OFF))
+		goto out;
+
+	while ((skb = skb_dequeue(&wl->tx_queue))) {
+		if (!woken_up) {
+			ret = wl1251_ps_elp_wakeup(wl);
+			if (ret < 0)
+				goto out;
+			woken_up = true;
+		}
+
+		ret = wl1251_tx_frame(wl, skb);
+		if (ret == -EBUSY) {
+			/* firmware buffer is full, stop queues */
+			wl1251_debug(DEBUG_TX, "tx_work: fw buffer full, "
+				     "stop queues");
+			ieee80211_stop_queues(wl->hw);
+			wl->tx_queue_stopped = true;
+			skb_queue_head(&wl->tx_queue, skb);
+			goto out;
+		} else if (ret < 0) {
+			dev_kfree_skb(skb);
+			goto out;
+		}
+	}
+
+out:
+	if (woken_up)
+		wl1251_ps_elp_sleep(wl);
+
+	mutex_unlock(&wl->mutex);
+}
+
+static const char *wl1251_tx_parse_status(u8 status)
+{
+	/* 8 bit status field, one character per bit plus null */
+	static char buf[9];
+	int i = 0;
+
+	memset(buf, 0, sizeof(buf));
+
+	if (status & TX_DMA_ERROR)
+		buf[i++] = 'm';
+	if (status & TX_DISABLED)
+		buf[i++] = 'd';
+	if (status & TX_RETRY_EXCEEDED)
+		buf[i++] = 'r';
+	if (status & TX_TIMEOUT)
+		buf[i++] = 't';
+	if (status & TX_KEY_NOT_FOUND)
+		buf[i++] = 'k';
+	if (status & TX_ENCRYPT_FAIL)
+		buf[i++] = 'e';
+	if (status & TX_UNAVAILABLE_PRIORITY)
+		buf[i++] = 'p';
+
+	/* bit 0 is unused apparently */
+
+	return buf;
+}
+
+static void wl1251_tx_packet_cb(struct wl1251 *wl,
+				struct tx_result *result)
+{
+	struct ieee80211_tx_info *info;
+	struct sk_buff *skb;
+	int hdrlen, ret;
+	u8 *frame;
+
+	skb = wl->tx_frames[result->id];
+	if (skb == NULL) {
+		wl1251_error("SKB for packet %d is NULL", result->id);
+		return;
+	}
+
+	info = IEEE80211_SKB_CB(skb);
+
+	if (!(info->flags & IEEE80211_TX_CTL_NO_ACK)) {
+		if (result->status == TX_SUCCESS)
+			info->flags |= IEEE80211_TX_STAT_ACK;
+		if (result->status & TX_RETRY_EXCEEDED) {
+			info->status.excessive_retries = 1;
+			wl->stats.excessive_retries++;
+		}
+	}
+
+	info->status.retry_count = result->ack_failures;
+	wl->stats.retry_count += result->ack_failures;
+
+	/*
+	 * We have to remove our private TX header before pushing
+	 * the skb back to mac80211.
+	 */
+	frame = skb_pull(skb, sizeof(struct tx_double_buffer_desc));
+	if (info->control.hw_key &&
+	    info->control.hw_key->alg == ALG_TKIP) {
+		hdrlen = ieee80211_get_hdrlen_from_skb(skb);
+		memmove(frame + WL1251_TKIP_IV_SPACE, frame, hdrlen);
+		skb_pull(skb, WL1251_TKIP_IV_SPACE);
+	}
+
+	wl1251_debug(DEBUG_TX, "tx status id %u skb 0x%p failures %u rate 0x%x"
+		     " status 0x%x (%s)",
+		     result->id, skb, result->ack_failures, result->rate,
+		     result->status, wl1251_tx_parse_status(result->status));
+
+
+	ieee80211_tx_status(wl->hw, skb);
+
+	wl->tx_frames[result->id] = NULL;
+
+	if (wl->tx_queue_stopped) {
+		wl1251_debug(DEBUG_TX, "cb: queue was stopped");
+
+		skb = skb_dequeue(&wl->tx_queue);
+
+		/* The skb can be NULL because tx_work might have been
+		   scheduled before the queue was stopped making the
+		   queue empty */
+
+		if (skb) {
+			ret = wl1251_tx_frame(wl, skb);
+			if (ret == -EBUSY) {
+				/* firmware buffer is still full */
+				wl1251_debug(DEBUG_TX, "cb: fw buffer "
+					     "still full");
+				skb_queue_head(&wl->tx_queue, skb);
+				return;
+			} else if (ret < 0) {
+				dev_kfree_skb(skb);
+				return;
+			}
+		}
+
+		wl1251_debug(DEBUG_TX, "cb: waking queues");
+		ieee80211_wake_queues(wl->hw);
+		wl->tx_queue_stopped = false;
+	}
+}
+
+/* Called upon reception of a TX complete interrupt */
+void wl1251_tx_complete(struct wl1251 *wl)
+{
+	int i, result_index, num_complete = 0;
+	struct tx_result result[FW_TX_CMPLT_BLOCK_SIZE], *result_ptr;
+
+	if (unlikely(wl->state != WL1251_STATE_ON))
+		return;
+
+	/* First we read the result */
+	wl1251_spi_mem_read(wl, wl->data_path->tx_complete_addr,
+			    result, sizeof(result));
+
+	result_index = wl->next_tx_complete;
+
+	for (i = 0; i < ARRAY_SIZE(result); i++) {
+		result_ptr = &result[result_index];
+
+		if (result_ptr->done_1 == 1 &&
+		    result_ptr->done_2 == 1) {
+			wl1251_tx_packet_cb(wl, result_ptr);
+
+			result_ptr->done_1 = 0;
+			result_ptr->done_2 = 0;
+
+			result_index = (result_index + 1) &
+				(FW_TX_CMPLT_BLOCK_SIZE - 1);
+			num_complete++;
+		} else {
+			break;
+		}
+	}
+
+	/* Every completed frame needs to be acknowledged */
+	if (num_complete) {
+		/*
+		 * If we've wrapped, we have to clear
+		 * the results in 2 steps.
+		 */
+		if (result_index > wl->next_tx_complete) {
+			/* Only 1 write is needed */
+			wl1251_spi_mem_write(wl,
+					     wl->data_path->tx_complete_addr +
+					     (wl->next_tx_complete *
+					      sizeof(struct tx_result)),
+					     &result[wl->next_tx_complete],
+					     num_complete *
+					     sizeof(struct tx_result));
+
+
+		} else if (result_index < wl->next_tx_complete) {
+			/* 2 writes are needed */
+			wl1251_spi_mem_write(wl,
+					     wl->data_path->tx_complete_addr +
+					     (wl->next_tx_complete *
+					      sizeof(struct tx_result)),
+					     &result[wl->next_tx_complete],
+					     (FW_TX_CMPLT_BLOCK_SIZE -
+					      wl->next_tx_complete) *
+					     sizeof(struct tx_result));
+
+			wl1251_spi_mem_write(wl,
+					     wl->data_path->tx_complete_addr,
+					     result,
+					     (num_complete -
+					      FW_TX_CMPLT_BLOCK_SIZE +
+					      wl->next_tx_complete) *
+					     sizeof(struct tx_result));
+
+		} else {
+			/* We have to write the whole array */
+			wl1251_spi_mem_write(wl,
+					     wl->data_path->tx_complete_addr,
+					     result,
+					     FW_TX_CMPLT_BLOCK_SIZE *
+					     sizeof(struct tx_result));
+		}
+
+	}
+
+	wl->next_tx_complete = result_index;
+}
+
+/* caller must hold wl->mutex */
+void wl1251_tx_flush(struct wl1251 *wl)
+{
+	int i;
+	struct sk_buff *skb;
+	struct ieee80211_tx_info *info;
+
+	/* TX failure */
+/* 	control->flags = 0; FIXME */
+
+	while ((skb = skb_dequeue(&wl->tx_queue))) {
+		info = IEEE80211_SKB_CB(skb);
+
+		wl1251_debug(DEBUG_TX, "flushing skb 0x%p", skb);
+
+		if (!(info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS))
+				continue;
+
+		ieee80211_tx_status(wl->hw, skb);
+	}
+
+	for (i = 0; i < FW_TX_CMPLT_BLOCK_SIZE; i++)
+		if (wl->tx_frames[i] != NULL) {
+			skb = wl->tx_frames[i];
+			info = IEEE80211_SKB_CB(skb);
+
+			if (!(info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS))
+				continue;
+
+			ieee80211_tx_status(wl->hw, skb);
+			wl->tx_frames[i] = NULL;
+		}
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_tx.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_tx.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1251_tx.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1251_tx.h	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,216 @@
+/*
+ * This file is part of wl1251
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __WL1251_TX_H__
+#define __WL1251_TX_H__
+
+#include <linux/bitops.h>
+
+/*
+ *
+ * TX PATH
+ *
+ * The Tx path uses a double buffer and a tx_control structure, each located
+ * at a fixed address in the device's memory. On startup, the host retrieves
+ * the pointers to these addresses. A double buffer allows for continuous data
+ * flow towards the device. The host keeps track of which buffer is available
+ * and alternates between these two buffers on a per packet basis.
+ *
+ * The size of each of the two buffers is large enough to hold the longest
+ * 802.3 packet - maximum size Ethernet packet + header + descriptor.
+ * TX complete indication will be received a-synchronously in a TX done cyclic
+ * buffer which is composed of 16 tx_result descriptors structures and is used
+ * in a cyclic manner.
+ *
+ * The TX (HOST) procedure is as follows:
+ * 1. Read the Tx path status, that will give the data_out_count.
+ * 2. goto 1, if not possible.
+ *    i.e. if data_in_count - data_out_count >= HwBuffer size (2 for double
+ *    buffer).
+ * 3. Copy the packet (preceded by double_buffer_desc), if possible.
+ *    i.e. if data_in_count - data_out_count < HwBuffer size (2 for double
+ *    buffer).
+ * 4. increment data_in_count.
+ * 5. Inform the firmware by generating a firmware internal interrupt.
+ * 6. FW will increment data_out_count after it reads the buffer.
+ *
+ * The TX Complete procedure:
+ * 1. To get a TX complete indication the host enables the tx_complete flag in
+ *    the TX descriptor Structure.
+ * 2. For each packet with a Tx Complete field set, the firmware adds the
+ *    transmit results to the cyclic buffer (txDoneRing) and sets both done_1
+ *    and done_2 to 1 to indicate driver ownership.
+ * 3. The firmware sends a Tx Complete interrupt to the host to trigger the
+ *    host to process the new data. Note: interrupt will be send per packet if
+ *    TX complete indication was requested in tx_control or per crossing
+ *    aggregation threshold.
+ * 4. After receiving the Tx Complete interrupt, the host reads the
+ *    TxDescriptorDone information in a cyclic manner and clears both done_1
+ *    and done_2 fields.
+ *
+ */
+
+#define TX_COMPLETE_REQUIRED_BIT	0x80
+#define TX_STATUS_DATA_OUT_COUNT_MASK   0xf
+
+#define WL1251_TX_ALIGN_TO 4
+#define WL1251_TX_ALIGN(len) (((len) + WL1251_TX_ALIGN_TO - 1) & \
+			     ~(WL1251_TX_ALIGN_TO - 1))
+#define WL1251_TKIP_IV_SPACE 4
+
+struct tx_control {
+	/* Rate Policy (class) index */
+	unsigned rate_policy:3;
+
+	/* When set, no ack policy is expected */
+	unsigned ack_policy:1;
+
+	/*
+	 * Packet type:
+	 * 0 -> 802.11
+	 * 1 -> 802.3
+	 * 2 -> IP
+	 * 3 -> raw codec
+	 */
+	unsigned packet_type:2;
+
+	/* If set, this is a QoS-Null or QoS-Data frame */
+	unsigned qos:1;
+
+	/*
+	 * If set, the target triggers the tx complete INT
+	 * upon frame sending completion.
+	 */
+	unsigned tx_complete:1;
+
+	/* 2 bytes padding before packet header */
+	unsigned xfer_pad:1;
+
+	unsigned reserved:7;
+} __attribute__ ((packed));
+
+
+struct tx_double_buffer_desc {
+	/* Length of payload, including headers. */
+	u16 length;
+
+	/*
+	 * A bit mask that specifies the initial rate to be used
+	 * Possible values are:
+	 * 0x0001 - 1Mbits
+	 * 0x0002 - 2Mbits
+	 * 0x0004 - 5.5Mbits
+	 * 0x0008 - 6Mbits
+	 * 0x0010 - 9Mbits
+	 * 0x0020 - 11Mbits
+	 * 0x0040 - 12Mbits
+	 * 0x0080 - 18Mbits
+	 * 0x0100 - 22Mbits
+	 * 0x0200 - 24Mbits
+	 * 0x0400 - 36Mbits
+	 * 0x0800 - 48Mbits
+	 * 0x1000 - 54Mbits
+	 */
+	u16 rate;
+
+	/* Time in us that a packet can spend in the target */
+	u32 expiry_time;
+
+	/* index of the TX queue used for this packet */
+	u8 xmit_queue;
+
+	/* Used to identify a packet */
+	u8 id;
+
+	struct tx_control control;
+
+	/*
+	 * The FW should cut the packet into fragments
+	 * of this size.
+	 */
+	u16 frag_threshold;
+
+	/* Numbers of HW queue blocks to be allocated */
+	u8 num_mem_blocks;
+
+	u8 reserved;
+} __attribute__ ((packed));
+
+enum {
+	TX_SUCCESS              = 0,
+	TX_DMA_ERROR            = BIT(7),
+	TX_DISABLED             = BIT(6),
+	TX_RETRY_EXCEEDED       = BIT(5),
+	TX_TIMEOUT              = BIT(4),
+	TX_KEY_NOT_FOUND        = BIT(3),
+	TX_ENCRYPT_FAIL         = BIT(2),
+	TX_UNAVAILABLE_PRIORITY = BIT(1),
+};
+
+struct tx_result {
+	/*
+	 * Ownership synchronization between the host and
+	 * the firmware. If done_1 and done_2 are cleared,
+	 * owned by the FW (no info ready).
+	 */
+	u8 done_1;
+
+	/* same as double_buffer_desc->id */
+	u8 id;
+
+	/*
+	 * Total air access duration consumed by this
+	 * packet, including all retries and overheads.
+	 */
+	u16 medium_usage;
+
+	/* Total media delay (from 1st EDCA AIFS counter until TX Complete). */
+	u32 medium_delay;
+
+	/* Time between host xfer and tx complete */
+	u32 fw_hnadling_time;
+
+	/* The LS-byte of the last TKIP sequence number. */
+	u8 lsb_seq_num;
+
+	/* Retry count */
+	u8 ack_failures;
+
+	/* At which rate we got a ACK */
+	u16 rate;
+
+	u16 reserved;
+
+	/* TX_* */
+	u8 status;
+
+	/* See done_1 */
+	u8 done_2;
+} __attribute__ ((packed));
+
+void wl1251_tx_work(struct work_struct *work);
+void wl1251_tx_complete(struct wl1251 *wl);
+void wl1251_tx_flush(struct wl1251 *wl);
+
+#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_acx.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_acx.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_acx.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_acx.c	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,938 @@
+#include "wl1271_acx.h"
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/crc7.h>
+#include <linux/spi/spi.h>
+
+#include "wl1271.h"
+#include "wl12xx_80211.h"
+#include "wl1271_reg.h"
+#include "wl1271_spi.h"
+#include "wl1271_ps.h"
+
+int wl1271_acx_wake_up_conditions(struct wl1271 *wl, u8 wake_up_event,
+				  u8 listen_interval)
+{
+	struct acx_wake_up_condition *wake_up;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx wake up conditions");
+
+	wake_up = kzalloc(sizeof(*wake_up), GFP_KERNEL);
+	if (!wake_up) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	wake_up->wake_up_event = wake_up_event;
+	wake_up->listen_interval = listen_interval;
+
+	ret = wl1271_cmd_configure(wl, ACX_WAKE_UP_CONDITIONS,
+				   wake_up, sizeof(*wake_up));
+	if (ret < 0) {
+		wl1271_warning("could not set wake up conditions: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(wake_up);
+	return ret;
+}
+
+int wl1271_acx_sleep_auth(struct wl1271 *wl, u8 sleep_auth)
+{
+	struct acx_sleep_auth *auth;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx sleep auth");
+
+	auth = kzalloc(sizeof(*auth), GFP_KERNEL);
+	if (!auth) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	auth->sleep_auth = sleep_auth;
+
+	ret = wl1271_cmd_configure(wl, ACX_SLEEP_AUTH, auth, sizeof(*auth));
+	if (ret < 0)
+		return ret;
+
+out:
+	kfree(auth);
+	return ret;
+}
+
+int wl1271_acx_fw_version(struct wl1271 *wl, char *buf, size_t len)
+{
+	struct acx_revision *rev;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx fw rev");
+
+	rev = kzalloc(sizeof(*rev), GFP_KERNEL);
+	if (!rev) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = wl1271_cmd_interrogate(wl, ACX_FW_REV, rev, sizeof(*rev));
+	if (ret < 0) {
+		wl1271_warning("ACX_FW_REV interrogate failed");
+		goto out;
+	}
+
+	/* be careful with the buffer sizes */
+	strncpy(buf, rev->fw_version, min(len, sizeof(rev->fw_version)));
+
+	/*
+	 * if the firmware version string is exactly
+	 * sizeof(rev->fw_version) long or fw_len is less than
+	 * sizeof(rev->fw_version) it won't be null terminated
+	 */
+	buf[min(len, sizeof(rev->fw_version)) - 1] = '\0';
+
+out:
+	kfree(rev);
+	return ret;
+}
+
+int wl1271_acx_tx_power(struct wl1271 *wl, int power)
+{
+	struct acx_current_tx_power *acx;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx dot11_cur_tx_pwr");
+
+	if (power < 0 || power > 25)
+		return -EINVAL;
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx->current_tx_power = power * 10;
+
+	ret = wl1271_cmd_configure(wl, DOT11_CUR_TX_PWR, acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1271_warning("configure of tx power failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1271_acx_feature_cfg(struct wl1271 *wl)
+{
+	struct acx_feature_config *feature;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx feature cfg");
+
+	feature = kzalloc(sizeof(*feature), GFP_KERNEL);
+	if (!feature) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* DF_ENCRYPTION_DISABLE and DF_SNIFF_MODE_ENABLE are disabled */
+	feature->data_flow_options = 0;
+	feature->options = 0;
+
+	ret = wl1271_cmd_configure(wl, ACX_FEATURE_CFG,
+				   feature, sizeof(*feature));
+	if (ret < 0) {
+		wl1271_error("Couldnt set HW encryption");
+		goto out;
+	}
+
+out:
+	kfree(feature);
+	return ret;
+}
+
+int wl1271_acx_mem_map(struct wl1271 *wl, struct acx_header *mem_map,
+		       size_t len)
+{
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx mem map");
+
+	ret = wl1271_cmd_interrogate(wl, ACX_MEM_MAP, mem_map, len);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+int wl1271_acx_rx_msdu_life_time(struct wl1271 *wl, u32 life_time)
+{
+	struct acx_rx_msdu_lifetime *acx;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx rx msdu life time");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx->lifetime = life_time;
+	ret = wl1271_cmd_configure(wl, DOT11_RX_MSDU_LIFE_TIME,
+				   acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1271_warning("failed to set rx msdu life time: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1271_acx_rx_config(struct wl1271 *wl, u32 config, u32 filter)
+{
+	struct acx_rx_config *rx_config;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx rx config");
+
+	rx_config = kzalloc(sizeof(*rx_config), GFP_KERNEL);
+	if (!rx_config) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	rx_config->config_options = config;
+	rx_config->filter_options = filter;
+
+	ret = wl1271_cmd_configure(wl, ACX_RX_CFG,
+				   rx_config, sizeof(*rx_config));
+	if (ret < 0) {
+		wl1271_warning("failed to set rx config: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(rx_config);
+	return ret;
+}
+
+int wl1271_acx_pd_threshold(struct wl1271 *wl)
+{
+	struct acx_packet_detection *pd;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx data pd threshold");
+
+	pd = kzalloc(sizeof(*pd), GFP_KERNEL);
+	if (!pd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* FIXME: threshold value not set */
+
+	ret = wl1271_cmd_configure(wl, ACX_PD_THRESHOLD, pd, sizeof(*pd));
+	if (ret < 0) {
+		wl1271_warning("failed to set pd threshold: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(pd);
+	return 0;
+}
+
+int wl1271_acx_slot(struct wl1271 *wl, enum acx_slot_type slot_time)
+{
+	struct acx_slot *slot;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx slot");
+
+	slot = kzalloc(sizeof(*slot), GFP_KERNEL);
+	if (!slot) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	slot->wone_index = STATION_WONE_INDEX;
+	slot->slot_time = slot_time;
+
+	ret = wl1271_cmd_configure(wl, ACX_SLOT, slot, sizeof(*slot));
+	if (ret < 0) {
+		wl1271_warning("failed to set slot time: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(slot);
+	return ret;
+}
+
+int wl1271_acx_group_address_tbl(struct wl1271 *wl)
+{
+	struct acx_dot11_grp_addr_tbl *acx;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx group address tbl");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* MAC filtering */
+	acx->enabled = 0;
+	acx->num_groups = 0;
+	memset(acx->mac_table, 0, ADDRESS_GROUP_MAX_LEN);
+
+	ret = wl1271_cmd_configure(wl, DOT11_GROUP_ADDRESS_TBL,
+				   acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1271_warning("failed to set group addr table: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1271_acx_service_period_timeout(struct wl1271 *wl)
+{
+	struct acx_rx_timeout *rx_timeout;
+	int ret;
+
+	rx_timeout = kzalloc(sizeof(*rx_timeout), GFP_KERNEL);
+	if (!rx_timeout) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	wl1271_debug(DEBUG_ACX, "acx service period timeout");
+
+	rx_timeout->ps_poll_timeout = RX_TIMEOUT_PS_POLL_DEF;
+	rx_timeout->upsd_timeout = RX_TIMEOUT_UPSD_DEF;
+
+	ret = wl1271_cmd_configure(wl, ACX_SERVICE_PERIOD_TIMEOUT,
+				   rx_timeout, sizeof(*rx_timeout));
+	if (ret < 0) {
+		wl1271_warning("failed to set service period timeout: %d",
+			       ret);
+		goto out;
+	}
+
+out:
+	kfree(rx_timeout);
+	return ret;
+}
+
+int wl1271_acx_rts_threshold(struct wl1271 *wl, u16 rts_threshold)
+{
+	struct acx_rts_threshold *rts;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx rts threshold");
+
+	rts = kzalloc(sizeof(*rts), GFP_KERNEL);
+	if (!rts) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	rts->threshold = rts_threshold;
+
+	ret = wl1271_cmd_configure(wl, DOT11_RTS_THRESHOLD, rts, sizeof(*rts));
+	if (ret < 0) {
+		wl1271_warning("failed to set rts threshold: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(rts);
+	return ret;
+}
+
+int wl1271_acx_beacon_filter_opt(struct wl1271 *wl)
+{
+	struct acx_beacon_filter_option *beacon_filter;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx beacon filter opt");
+
+	beacon_filter = kzalloc(sizeof(*beacon_filter), GFP_KERNEL);
+	if (!beacon_filter) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	beacon_filter->enable = 0;
+	beacon_filter->max_num_beacons = 0;
+
+	ret = wl1271_cmd_configure(wl, ACX_BEACON_FILTER_OPT,
+				   beacon_filter, sizeof(*beacon_filter));
+	if (ret < 0) {
+		wl1271_warning("failed to set beacon filter opt: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(beacon_filter);
+	return ret;
+}
+
+int wl1271_acx_beacon_filter_table(struct wl1271 *wl)
+{
+	struct acx_beacon_filter_ie_table *ie_table;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx beacon filter table");
+
+	ie_table = kzalloc(sizeof(*ie_table), GFP_KERNEL);
+	if (!ie_table) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ie_table->num_ie = 0;
+	memset(ie_table->table, 0, BEACON_FILTER_TABLE_MAX_SIZE);
+
+	ret = wl1271_cmd_configure(wl, ACX_BEACON_FILTER_TABLE,
+				   ie_table, sizeof(*ie_table));
+	if (ret < 0) {
+		wl1271_warning("failed to set beacon filter table: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(ie_table);
+	return ret;
+}
+
+int wl1271_acx_sg_enable(struct wl1271 *wl)
+{
+	struct acx_bt_wlan_coex *pta;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx sg enable");
+
+	pta = kzalloc(sizeof(*pta), GFP_KERNEL);
+	if (!pta) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	pta->enable = SG_ENABLE;
+
+	ret = wl1271_cmd_configure(wl, ACX_SG_ENABLE, pta, sizeof(*pta));
+	if (ret < 0) {
+		wl1271_warning("failed to set softgemini enable: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(pta);
+	return ret;
+}
+
+int wl1271_acx_sg_cfg(struct wl1271 *wl)
+{
+	struct acx_bt_wlan_coex_param *param;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx sg cfg");
+
+	param = kzalloc(sizeof(*param), GFP_KERNEL);
+	if (!param) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* BT-WLAN coext parameters */
+	param->min_rate = RATE_INDEX_24MBPS;
+	param->bt_hp_max_time = PTA_BT_HP_MAXTIME_DEF;
+	param->wlan_hp_max_time = PTA_WLAN_HP_MAX_TIME_DEF;
+	param->sense_disable_timer = PTA_SENSE_DISABLE_TIMER_DEF;
+	param->rx_time_bt_hp = PTA_PROTECTIVE_RX_TIME_DEF;
+	param->tx_time_bt_hp = PTA_PROTECTIVE_TX_TIME_DEF;
+	param->rx_time_bt_hp_fast = PTA_PROTECTIVE_RX_TIME_FAST_DEF;
+	param->tx_time_bt_hp_fast = PTA_PROTECTIVE_TX_TIME_FAST_DEF;
+	param->wlan_cycle_fast = PTA_CYCLE_TIME_FAST_DEF;
+	param->bt_anti_starvation_period = PTA_ANTI_STARVE_PERIOD_DEF;
+	param->next_bt_lp_packet = PTA_TIMEOUT_NEXT_BT_LP_PACKET_DEF;
+	param->wake_up_beacon = PTA_TIME_BEFORE_BEACON_DEF;
+	param->hp_dm_max_guard_time = PTA_HPDM_MAX_TIME_DEF;
+	param->next_wlan_packet = PTA_TIME_OUT_NEXT_WLAN_DEF;
+	param->antenna_type = PTA_ANTENNA_TYPE_DEF;
+	param->signal_type = PTA_SIGNALING_TYPE_DEF;
+	param->afh_leverage_on = PTA_AFH_LEVERAGE_ON_DEF;
+	param->quiet_cycle_num = PTA_NUMBER_QUIET_CYCLE_DEF;
+	param->max_cts = PTA_MAX_NUM_CTS_DEF;
+	param->wlan_packets_num = PTA_NUMBER_OF_WLAN_PACKETS_DEF;
+	param->bt_packets_num = PTA_NUMBER_OF_BT_PACKETS_DEF;
+	param->missed_rx_avalanche = PTA_RX_FOR_AVALANCHE_DEF;
+	param->wlan_elp_hp = PTA_ELP_HP_DEF;
+	param->bt_anti_starvation_cycles = PTA_ANTI_STARVE_NUM_CYCLE_DEF;
+	param->ack_mode_dual_ant = PTA_ACK_MODE_DEF;
+	param->pa_sd_enable = PTA_ALLOW_PA_SD_DEF;
+	param->pta_auto_mode_enable = PTA_AUTO_MODE_NO_CTS_DEF;
+	param->bt_hp_respected_num = PTA_BT_HP_RESPECTED_DEF;
+
+	ret = wl1271_cmd_configure(wl, ACX_SG_CFG, param, sizeof(*param));
+	if (ret < 0) {
+		wl1271_warning("failed to set sg config: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(param);
+	return ret;
+}
+
+int wl1271_acx_cca_threshold(struct wl1271 *wl)
+{
+	struct acx_energy_detection *detection;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx cca threshold");
+
+	detection = kzalloc(sizeof(*detection), GFP_KERNEL);
+	if (!detection) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	detection->rx_cca_threshold = CCA_THRSH_DISABLE_ENERGY_D;
+	detection->tx_energy_detection = 0;
+
+	ret = wl1271_cmd_configure(wl, ACX_CCA_THRESHOLD,
+				   detection, sizeof(*detection));
+	if (ret < 0) {
+		wl1271_warning("failed to set cca threshold: %d", ret);
+		return ret;
+	}
+
+out:
+	kfree(detection);
+	return ret;
+}
+
+int wl1271_acx_bcn_dtim_options(struct wl1271 *wl)
+{
+	struct acx_beacon_broadcast *bb;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx bcn dtim options");
+
+	bb = kzalloc(sizeof(*bb), GFP_KERNEL);
+	if (!bb) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	bb->beacon_rx_timeout = BCN_RX_TIMEOUT_DEF_VALUE;
+	bb->broadcast_timeout = BROADCAST_RX_TIMEOUT_DEF_VALUE;
+	bb->rx_broadcast_in_ps = RX_BROADCAST_IN_PS_DEF_VALUE;
+	bb->ps_poll_threshold = CONSECUTIVE_PS_POLL_FAILURE_DEF;
+
+	ret = wl1271_cmd_configure(wl, ACX_BCN_DTIM_OPTIONS, bb, sizeof(*bb));
+	if (ret < 0) {
+		wl1271_warning("failed to set rx config: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(bb);
+	return ret;
+}
+
+int wl1271_acx_aid(struct wl1271 *wl, u16 aid)
+{
+	struct acx_aid *acx_aid;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx aid");
+
+	acx_aid = kzalloc(sizeof(*acx_aid), GFP_KERNEL);
+	if (!acx_aid) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx_aid->aid = aid;
+
+	ret = wl1271_cmd_configure(wl, ACX_AID, acx_aid, sizeof(*acx_aid));
+	if (ret < 0) {
+		wl1271_warning("failed to set aid: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx_aid);
+	return ret;
+}
+
+int wl1271_acx_event_mbox_mask(struct wl1271 *wl, u32 event_mask)
+{
+	struct acx_event_mask *mask;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx event mbox mask");
+
+	mask = kzalloc(sizeof(*mask), GFP_KERNEL);
+	if (!mask) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* high event mask is unused */
+	mask->high_event_mask = 0xffffffff;
+
+	mask->event_mask = event_mask;
+
+	ret = wl1271_cmd_configure(wl, ACX_EVENT_MBOX_MASK,
+				   mask, sizeof(*mask));
+	if (ret < 0) {
+		wl1271_warning("failed to set acx_event_mbox_mask: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(mask);
+	return ret;
+}
+
+int wl1271_acx_set_preamble(struct wl1271 *wl, enum acx_preamble_type preamble)
+{
+	struct acx_preamble *acx;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx_set_preamble");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx->preamble = preamble;
+
+	ret = wl1271_cmd_configure(wl, ACX_PREAMBLE_TYPE, acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1271_warning("Setting of preamble failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1271_acx_cts_protect(struct wl1271 *wl,
+			   enum acx_ctsprotect_type ctsprotect)
+{
+	struct acx_ctsprotect *acx;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx_set_ctsprotect");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx->ctsprotect = ctsprotect;
+
+	ret = wl1271_cmd_configure(wl, ACX_CTS_PROTECTION, acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1271_warning("Setting of ctsprotect failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1271_acx_statistics(struct wl1271 *wl, struct acx_statistics *stats)
+{
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "acx statistics");
+
+	ret = wl1271_cmd_interrogate(wl, ACX_STATISTICS, stats,
+				     sizeof(*stats));
+	if (ret < 0) {
+		wl1271_warning("acx statistics failed: %d", ret);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+int wl1271_acx_rate_policies(struct wl1271 *wl)
+{
+	struct acx_rate_policy *acx;
+	int ret = 0;
+
+	wl1271_debug(DEBUG_ACX, "acx rate policies");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* configure one default (one-size-fits-all) rate class */
+	acx->rate_class_cnt = 1;
+	acx->rate_class[0].enabled_rates = ACX_RATE_MASK_ALL;
+	acx->rate_class[0].short_retry_limit = ACX_RATE_RETRY_LIMIT;
+	acx->rate_class[0].long_retry_limit = ACX_RATE_RETRY_LIMIT;
+	acx->rate_class[0].aflags = 0;
+
+	ret = wl1271_cmd_configure(wl, ACX_RATE_POLICY, acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1271_warning("Setting of rate policies failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1271_acx_ac_cfg(struct wl1271 *wl)
+{
+	struct acx_ac_cfg *acx;
+	int i, ret = 0;
+
+	wl1271_debug(DEBUG_ACX, "acx access category config");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/*
+	 * FIXME: Configure each AC with appropriate values (most suitable
+	 * values will probably be different for each AC.
+	 */
+	for (i = 0; i < WL1271_ACX_AC_COUNT; i++) {
+		acx->ac = i;
+
+		/*
+		 * FIXME: The following default values originate from
+		 * the TI reference driver. What do they mean?
+		 */
+		acx->cw_min = 15;
+		acx->cw_max = 63;
+		acx->aifsn = 3;
+		acx->reserved = 0;
+		acx->tx_op_limit = 0;
+
+		ret = wl1271_cmd_configure(wl, ACX_AC_CFG, acx, sizeof(*acx));
+		if (ret < 0) {
+			wl1271_warning("Setting of access category "
+				       "config: %d", ret);
+			goto out;
+		}
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1271_acx_tid_cfg(struct wl1271 *wl)
+{
+	struct acx_tid_config *acx;
+	int i, ret = 0;
+
+	wl1271_debug(DEBUG_ACX, "acx tid config");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* FIXME: configure each TID with a different AC reference */
+	for (i = 0; i < WL1271_ACX_TID_COUNT; i++) {
+		acx->queue_id = i;
+		acx->tsid = WL1271_ACX_AC_BE;
+		acx->ps_scheme = WL1271_ACX_PS_SCHEME_LEGACY;
+		acx->ack_policy = WL1271_ACX_ACK_POLICY_LEGACY;
+
+		ret = wl1271_cmd_configure(wl, ACX_TID_CFG, acx, sizeof(*acx));
+		if (ret < 0) {
+			wl1271_warning("Setting of tid config failed: %d", ret);
+			goto out;
+		}
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1271_acx_frag_threshold(struct wl1271 *wl)
+{
+	struct acx_frag_threshold *acx;
+	int ret = 0;
+
+	wl1271_debug(DEBUG_ACX, "acx frag threshold");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx->frag_threshold = IEEE80211_MAX_FRAG_THRESHOLD;
+	ret = wl1271_cmd_configure(wl, ACX_FRAG_CFG, acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1271_warning("Setting of frag threshold failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1271_acx_tx_config_options(struct wl1271 *wl)
+{
+	struct acx_tx_config_options *acx;
+	int ret = 0;
+
+	wl1271_debug(DEBUG_ACX, "acx tx config options");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx->tx_compl_timeout = WL1271_ACX_TX_COMPL_TIMEOUT;
+	acx->tx_compl_threshold = WL1271_ACX_TX_COMPL_THRESHOLD;
+	ret = wl1271_cmd_configure(wl, ACX_TX_CONFIG_OPT, acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1271_warning("Setting of tx options failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
+int wl1271_acx_mem_cfg(struct wl1271 *wl)
+{
+	struct wl1271_acx_config_memory *mem_conf;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "wl1271 mem cfg");
+
+	mem_conf = kzalloc(sizeof(*mem_conf), GFP_KERNEL);
+	if (!mem_conf) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* memory config */
+	mem_conf->num_stations = cpu_to_le16(DEFAULT_NUM_STATIONS);
+	mem_conf->rx_mem_block_num = ACX_RX_MEM_BLOCKS;
+	mem_conf->tx_min_mem_block_num = ACX_TX_MIN_MEM_BLOCKS;
+	mem_conf->num_ssid_profiles = ACX_NUM_SSID_PROFILES;
+	mem_conf->total_tx_descriptors = ACX_TX_DESCRIPTORS;
+
+	ret = wl1271_cmd_configure(wl, ACX_MEM_CFG, mem_conf,
+				   sizeof(*mem_conf));
+	if (ret < 0) {
+		wl1271_warning("wl1271 mem config failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(mem_conf);
+	return ret;
+}
+
+int wl1271_acx_init_mem_config(struct wl1271 *wl)
+{
+	int ret;
+
+	ret = wl1271_acx_mem_cfg(wl);
+	if (ret < 0)
+		return ret;
+
+	wl->target_mem_map = kzalloc(sizeof(struct wl1271_acx_mem_map),
+					  GFP_KERNEL);
+	if (!wl->target_mem_map) {
+		wl1271_error("couldn't allocate target memory map");
+		return -ENOMEM;
+	}
+
+	/* we now ask for the firmware built memory map */
+	ret = wl1271_acx_mem_map(wl, (void *)wl->target_mem_map,
+				 sizeof(struct wl1271_acx_mem_map));
+	if (ret < 0) {
+		wl1271_error("couldn't retrieve firmware memory map");
+		kfree(wl->target_mem_map);
+		wl->target_mem_map = NULL;
+		return ret;
+	}
+
+	/* initialize TX block book keeping */
+	wl->tx_blocks_available = wl->target_mem_map->num_tx_mem_blocks;
+	wl1271_debug(DEBUG_TX, "available tx blocks: %d",
+		     wl->tx_blocks_available);
+
+	return 0;
+}
+
+int wl1271_acx_init_rx_interrupt(struct wl1271 *wl)
+{
+	struct wl1271_acx_rx_config_opt *rx_conf;
+	int ret;
+
+	wl1271_debug(DEBUG_ACX, "wl1271 rx interrupt config");
+
+	rx_conf = kzalloc(sizeof(*rx_conf), GFP_KERNEL);
+	if (!rx_conf) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	rx_conf->threshold = WL1271_RX_INTR_THRESHOLD_DEF;
+	rx_conf->timeout = WL1271_RX_INTR_TIMEOUT_DEF;
+	rx_conf->mblk_threshold = USHORT_MAX; /* Disabled */
+	rx_conf->queue_type = RX_QUEUE_TYPE_RX_LOW_PRIORITY;
+
+	ret = wl1271_cmd_configure(wl, ACX_RX_CONFIG_OPT, rx_conf,
+				   sizeof(*rx_conf));
+	if (ret < 0) {
+		wl1271_warning("wl1271 rx config opt failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(rx_conf);
+	return ret;
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_acx.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_acx.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_acx.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_acx.h	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,1221 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __WL1271_ACX_H__
+#define __WL1271_ACX_H__
+
+#include "wl1271.h"
+#include "wl1271_cmd.h"
+
+/*************************************************************************
+
+    Host Interrupt Register (WiLink -> Host)
+
+**************************************************************************/
+/* HW Initiated interrupt Watchdog timer expiration */
+#define WL1271_ACX_INTR_WATCHDOG           BIT(0)
+/* Init sequence is done (masked interrupt, detection through polling only ) */
+#define WL1271_ACX_INTR_INIT_COMPLETE      BIT(1)
+/* Event was entered to Event MBOX #A*/
+#define WL1271_ACX_INTR_EVENT_A            BIT(2)
+/* Event was entered to Event MBOX #B*/
+#define WL1271_ACX_INTR_EVENT_B            BIT(3)
+/* Command processing completion*/
+#define WL1271_ACX_INTR_CMD_COMPLETE       BIT(4)
+/* Signaling the host on HW wakeup */
+#define WL1271_ACX_INTR_HW_AVAILABLE       BIT(5)
+/* The MISC bit is used for aggregation of RX, TxComplete and TX rate update */
+#define WL1271_ACX_INTR_DATA               BIT(6)
+/* Trace meassge on MBOX #A */
+#define WL1271_ACX_INTR_TRACE_A            BIT(7)
+/* Trace meassge on MBOX #B */
+#define WL1271_ACX_INTR_TRACE_B            BIT(8)
+
+#define WL1271_ACX_INTR_ALL		   0xFFFFFFFF
+#define WL1271_ACX_ALL_EVENTS_VECTOR       (WL1271_ACX_INTR_WATCHDOG      | \
+					    WL1271_ACX_INTR_INIT_COMPLETE | \
+					    WL1271_ACX_INTR_EVENT_A       | \
+					    WL1271_ACX_INTR_EVENT_B       | \
+					    WL1271_ACX_INTR_CMD_COMPLETE  | \
+					    WL1271_ACX_INTR_HW_AVAILABLE  | \
+					    WL1271_ACX_INTR_DATA)
+
+#define WL1271_INTR_MASK                   (WL1271_ACX_INTR_EVENT_A |	\
+					    WL1271_ACX_INTR_EVENT_B | \
+					    WL1271_ACX_INTR_DATA)
+
+/* Target's information element */
+struct acx_header {
+	struct wl1271_cmd_header cmd;
+
+	/* acx (or information element) header */
+	u16 id;
+
+	/* payload length (not including headers */
+	u16 len;
+};
+
+struct acx_error_counter {
+	struct acx_header header;
+
+	/* The number of PLCP errors since the last time this */
+	/* information element was interrogated. This field is */
+	/* automatically cleared when it is interrogated.*/
+	u32 PLCP_error;
+
+	/* The number of FCS errors since the last time this */
+	/* information element was interrogated. This field is */
+	/* automatically cleared when it is interrogated.*/
+	u32 FCS_error;
+
+	/* The number of MPDUs without PLCP header errors received*/
+	/* since the last time this information element was interrogated. */
+	/* This field is automatically cleared when it is interrogated.*/
+	u32 valid_frame;
+
+	/* the number of missed sequence numbers in the squentially */
+	/* values of frames seq numbers */
+	u32 seq_num_miss;
+} __attribute__ ((packed));
+
+struct acx_revision {
+	struct acx_header header;
+
+	/*
+	 * The WiLink firmware version, an ASCII string x.x.x.x,
+	 * that uniquely identifies the current firmware.
+	 * The left most digit is incremented each time a
+	 * significant change is made to the firmware, such as
+	 * code redesign or new platform support.
+	 * The second digit is incremented when major enhancements
+	 * are added or major fixes are made.
+	 * The third digit is incremented for each GA release.
+	 * The fourth digit is incremented for each build.
+	 * The first two digits identify a firmware release version,
+	 * in other words, a unique set of features.
+	 * The first three digits identify a GA release.
+	 */
+	char fw_version[20];
+
+	/*
+	 * This 4 byte field specifies the WiLink hardware version.
+	 * bits 0  - 15: Reserved.
+	 * bits 16 - 23: Version ID - The WiLink version ID
+	 *              (1 = first spin, 2 = second spin, and so on).
+	 * bits 24 - 31: Chip ID - The WiLink chip ID.
+	 */
+	u32 hw_version;
+} __attribute__ ((packed));
+
+enum wl1271_psm_mode {
+	/* Active mode */
+	WL1271_PSM_CAM = 0,
+
+	/* Power save mode */
+	WL1271_PSM_PS = 1,
+
+	/* Extreme low power */
+	WL1271_PSM_ELP = 2,
+};
+
+struct acx_sleep_auth {
+	struct acx_header header;
+
+	/* The sleep level authorization of the device. */
+	/* 0 - Always active*/
+	/* 1 - Power down mode: light / fast sleep*/
+	/* 2 - ELP mode: Deep / Max sleep*/
+	u8  sleep_auth;
+	u8  padding[3];
+} __attribute__ ((packed));
+
+enum {
+	HOSTIF_PCI_MASTER_HOST_INDIRECT,
+	HOSTIF_PCI_MASTER_HOST_DIRECT,
+	HOSTIF_SLAVE,
+	HOSTIF_PKT_RING,
+	HOSTIF_DONTCARE = 0xFF
+};
+
+#define DEFAULT_UCAST_PRIORITY          0
+#define DEFAULT_RX_Q_PRIORITY           0
+#define DEFAULT_NUM_STATIONS            1
+#define DEFAULT_RXQ_PRIORITY            0 /* low 0 .. 15 high  */
+#define DEFAULT_RXQ_TYPE                0x07    /* All frames, Data/Ctrl/Mgmt */
+#define TRACE_BUFFER_MAX_SIZE           256
+
+#define  DP_RX_PACKET_RING_CHUNK_SIZE 1600
+#define  DP_TX_PACKET_RING_CHUNK_SIZE 1600
+#define  DP_RX_PACKET_RING_CHUNK_NUM 2
+#define  DP_TX_PACKET_RING_CHUNK_NUM 2
+#define  DP_TX_COMPLETE_TIME_OUT 20
+#define  FW_TX_CMPLT_BLOCK_SIZE 16
+
+#define TX_MSDU_LIFETIME_MIN       0
+#define TX_MSDU_LIFETIME_MAX       3000
+#define TX_MSDU_LIFETIME_DEF       512
+#define RX_MSDU_LIFETIME_MIN       0
+#define RX_MSDU_LIFETIME_MAX       0xFFFFFFFF
+#define RX_MSDU_LIFETIME_DEF       512000
+
+struct acx_rx_msdu_lifetime {
+	struct acx_header header;
+
+	/*
+	 * The maximum amount of time, in TU, before the
+	 * firmware discards the MSDU.
+	 */
+	u32 lifetime;
+} __attribute__ ((packed));
+
+/*
+ * RX Config Options Table
+ * Bit		Definition
+ * ===		==========
+ * 31:14		Reserved
+ * 13		Copy RX Status - when set, write three receive status words
+ * 	 	to top of rx'd MPDUs.
+ * 		When cleared, do not write three status words (added rev 1.5)
+ * 12		Reserved
+ * 11		RX Complete upon FCS error - when set, give rx complete
+ *	 	interrupt for FCS errors, after the rx filtering, e.g. unicast
+ *	 	frames not to us with FCS error will not generate an interrupt.
+ * 10		SSID Filter Enable - When set, the WiLink discards all beacon,
+ *	        probe request, and probe response frames with an SSID that does
+ *		not match the SSID specified by the host in the START/JOIN
+ *		command.
+ *		When clear, the WiLink receives frames with any SSID.
+ * 9		Broadcast Filter Enable - When set, the WiLink discards all
+ * 	 	broadcast frames. When clear, the WiLink receives all received
+ *		broadcast frames.
+ * 8:6		Reserved
+ * 5		BSSID Filter Enable - When set, the WiLink discards any frames
+ * 	 	with a BSSID that does not match the BSSID specified by the
+ *		host.
+ *		When clear, the WiLink receives frames from any BSSID.
+ * 4		MAC Addr Filter - When set, the WiLink discards any frames
+ * 	 	with a destination address that does not match the MAC address
+ *		of the adaptor.
+ *		When clear, the WiLink receives frames destined to any MAC
+ *		address.
+ * 3		Promiscuous - When set, the WiLink receives all valid frames
+ * 	 	(i.e., all frames that pass the FCS check).
+ *		When clear, only frames that pass the other filters specified
+ *		are received.
+ * 2		FCS - When set, the WiLink includes the FCS with the received
+ *	 	frame.
+ *		When cleared, the FCS is discarded.
+ * 1		PLCP header - When set, write all data from baseband to frame
+ * 	 	buffer including PHY header.
+ * 0		Reserved - Always equal to 0.
+ *
+ * RX Filter Options Table
+ * Bit		Definition
+ * ===		==========
+ * 31:12		Reserved - Always equal to 0.
+ * 11		Association - When set, the WiLink receives all association
+ * 	 	related frames (association request/response, reassocation
+ *		request/response, and disassociation). When clear, these frames
+ *		are discarded.
+ * 10		Auth/De auth - When set, the WiLink receives all authentication
+ * 	 	and de-authentication frames. When clear, these frames are
+ *		discarded.
+ * 9		Beacon - When set, the WiLink receives all beacon frames.
+ * 	 	When clear, these frames are discarded.
+ * 8		Contention Free - When set, the WiLink receives all contention
+ * 	 	free frames.
+ *		When clear, these frames are discarded.
+ * 7		Control - When set, the WiLink receives all control frames.
+ * 	 	When clear, these frames are discarded.
+ * 6		Data - When set, the WiLink receives all data frames.
+ * 	 	When clear, these frames are discarded.
+ * 5		FCS Error - When set, the WiLink receives frames that have FCS
+ *	 	errors.
+ *		When clear, these frames are discarded.
+ * 4		Management - When set, the WiLink receives all management
+ *		frames.
+ * 	 	When clear, these frames are discarded.
+ * 3		Probe Request - When set, the WiLink receives all probe request
+ * 	 	frames.
+ *		When clear, these frames are discarded.
+ * 2		Probe Response - When set, the WiLink receives all probe
+ * 		response frames.
+ *		When clear, these frames are discarded.
+ * 1		RTS/CTS/ACK - When set, the WiLink receives all RTS, CTS and ACK
+ * 	 	frames.
+ *		When clear, these frames are discarded.
+ * 0		Rsvd Type/Sub Type - When set, the WiLink receives all frames
+ * 	 	that have reserved frame types and sub types as defined by the
+ *		802.11 specification.
+ *		When clear, these frames are discarded.
+ */
+struct acx_rx_config {
+	struct acx_header header;
+
+	u32 config_options;
+	u32 filter_options;
+} __attribute__ ((packed));
+
+struct acx_packet_detection {
+	struct acx_header header;
+
+	u32 threshold;
+} __attribute__ ((packed));
+
+
+enum acx_slot_type {
+	SLOT_TIME_LONG = 0,
+	SLOT_TIME_SHORT = 1,
+	DEFAULT_SLOT_TIME = SLOT_TIME_SHORT,
+	MAX_SLOT_TIMES = 0xFF
+};
+
+#define STATION_WONE_INDEX 0
+
+struct acx_slot {
+	struct acx_header header;
+
+	u8 wone_index; /* Reserved */
+	u8 slot_time;
+	u8 reserved[6];
+} __attribute__ ((packed));
+
+
+#define ADDRESS_GROUP_MAX	(8)
+#define ADDRESS_GROUP_MAX_LEN	(ETH_ALEN * ADDRESS_GROUP_MAX)
+
+struct acx_dot11_grp_addr_tbl {
+	struct acx_header header;
+
+	u8 enabled;
+	u8 num_groups;
+	u8 pad[2];
+	u8 mac_table[ADDRESS_GROUP_MAX_LEN];
+} __attribute__ ((packed));
+
+
+#define  RX_TIMEOUT_PS_POLL_MIN    0
+#define  RX_TIMEOUT_PS_POLL_MAX    (200000)
+#define  RX_TIMEOUT_PS_POLL_DEF    (15)
+#define  RX_TIMEOUT_UPSD_MIN       0
+#define  RX_TIMEOUT_UPSD_MAX       (200000)
+#define  RX_TIMEOUT_UPSD_DEF       (15)
+
+struct acx_rx_timeout {
+	struct acx_header header;
+
+	/*
+	 * The longest time the STA will wait to receive
+	 * traffic from the AP after a PS-poll has been
+	 * transmitted.
+	 */
+	u16 ps_poll_timeout;
+
+	/*
+	 * The longest time the STA will wait to receive
+	 * traffic from the AP after a frame has been sent
+	 * from an UPSD enabled queue.
+	 */
+	u16 upsd_timeout;
+} __attribute__ ((packed));
+
+#define RTS_THRESHOLD_MIN              0
+#define RTS_THRESHOLD_MAX              4096
+#define RTS_THRESHOLD_DEF              2347
+
+struct acx_rts_threshold {
+	struct acx_header header;
+
+	u16 threshold;
+	u8 pad[2];
+} __attribute__ ((packed));
+
+struct acx_beacon_filter_option {
+	struct acx_header header;
+
+	u8 enable;
+
+	/*
+	 * The number of beacons without the unicast TIM
+	 * bit set that the firmware buffers before
+	 * signaling the host about ready frames.
+	 * When set to 0 and the filter is enabled, beacons
+	 * without the unicast TIM bit set are dropped.
+	 */
+	u8 max_num_beacons;
+	u8 pad[2];
+} __attribute__ ((packed));
+
+/*
+ * ACXBeaconFilterEntry (not 221)
+ * Byte Offset     Size (Bytes)    Definition
+ * ===========     ============    ==========
+ * 0				1               IE identifier
+ * 1               1               Treatment bit mask
+ *
+ * ACXBeaconFilterEntry (221)
+ * Byte Offset     Size (Bytes)    Definition
+ * ===========     ============    ==========
+ * 0               1               IE identifier
+ * 1               1               Treatment bit mask
+ * 2               3               OUI
+ * 5               1               Type
+ * 6               2               Version
+ *
+ *
+ * Treatment bit mask - The information element handling:
+ * bit 0 - The information element is compared and transferred
+ * in case of change.
+ * bit 1 - The information element is transferred to the host
+ * with each appearance or disappearance.
+ * Note that both bits can be set at the same time.
+ */
+#define	BEACON_FILTER_TABLE_MAX_IE_NUM		       (32)
+#define BEACON_FILTER_TABLE_MAX_VENDOR_SPECIFIC_IE_NUM (6)
+#define BEACON_FILTER_TABLE_IE_ENTRY_SIZE	       (2)
+#define BEACON_FILTER_TABLE_EXTRA_VENDOR_SPECIFIC_IE_SIZE (6)
+#define BEACON_FILTER_TABLE_MAX_SIZE ((BEACON_FILTER_TABLE_MAX_IE_NUM * \
+			    BEACON_FILTER_TABLE_IE_ENTRY_SIZE) + \
+			   (BEACON_FILTER_TABLE_MAX_VENDOR_SPECIFIC_IE_NUM * \
+			    BEACON_FILTER_TABLE_EXTRA_VENDOR_SPECIFIC_IE_SIZE))
+
+struct acx_beacon_filter_ie_table {
+	struct acx_header header;
+
+	u8 num_ie;
+	u8 table[BEACON_FILTER_TABLE_MAX_SIZE];
+	u8 pad[3];
+} __attribute__ ((packed));
+
+enum {
+	SG_ENABLE = 0,
+	SG_DISABLE,
+	SG_SENSE_NO_ACTIVITY,
+	SG_SENSE_ACTIVE
+};
+
+struct acx_bt_wlan_coex {
+	struct acx_header header;
+
+	/*
+	 * 0 -> PTA enabled
+	 * 1 -> PTA disabled
+	 * 2 -> sense no active mode, i.e.
+	 *      an interrupt is sent upon
+	 *      BT activity.
+	 * 3 -> PTA is switched on in response
+	 *      to the interrupt sending.
+	 */
+	u8 enable;
+	u8 pad[3];
+} __attribute__ ((packed));
+
+#define PTA_ANTENNA_TYPE_DEF		  (0)
+#define PTA_BT_HP_MAXTIME_DEF		  (2000)
+#define PTA_WLAN_HP_MAX_TIME_DEF	  (5000)
+#define PTA_SENSE_DISABLE_TIMER_DEF	  (1350)
+#define PTA_PROTECTIVE_RX_TIME_DEF	  (1500)
+#define PTA_PROTECTIVE_TX_TIME_DEF	  (1500)
+#define PTA_TIMEOUT_NEXT_BT_LP_PACKET_DEF (3000)
+#define PTA_SIGNALING_TYPE_DEF		  (1)
+#define PTA_AFH_LEVERAGE_ON_DEF		  (0)
+#define PTA_NUMBER_QUIET_CYCLE_DEF	  (0)
+#define PTA_MAX_NUM_CTS_DEF		  (3)
+#define PTA_NUMBER_OF_WLAN_PACKETS_DEF	  (2)
+#define PTA_NUMBER_OF_BT_PACKETS_DEF	  (2)
+#define PTA_PROTECTIVE_RX_TIME_FAST_DEF	  (1500)
+#define PTA_PROTECTIVE_TX_TIME_FAST_DEF	  (3000)
+#define PTA_CYCLE_TIME_FAST_DEF		  (8700)
+#define PTA_RX_FOR_AVALANCHE_DEF	  (5)
+#define PTA_ELP_HP_DEF			  (0)
+#define PTA_ANTI_STARVE_PERIOD_DEF	  (500)
+#define PTA_ANTI_STARVE_NUM_CYCLE_DEF	  (4)
+#define PTA_ALLOW_PA_SD_DEF		  (1)
+#define PTA_TIME_BEFORE_BEACON_DEF	  (6300)
+#define PTA_HPDM_MAX_TIME_DEF		  (1600)
+#define PTA_TIME_OUT_NEXT_WLAN_DEF	  (2550)
+#define PTA_AUTO_MODE_NO_CTS_DEF	  (0)
+#define PTA_BT_HP_RESPECTED_DEF		  (3)
+#define PTA_WLAN_RX_MIN_RATE_DEF	  (24)
+#define PTA_ACK_MODE_DEF		  (1)
+
+struct acx_bt_wlan_coex_param {
+	struct acx_header header;
+
+	/*
+	 * The minimum rate of a received WLAN packet in the STA,
+	 * during protective mode, of which a new BT-HP request
+	 * during this Rx will always be respected and gain the antenna.
+	 */
+	u32 min_rate;
+
+	/* Max time the BT HP will be respected. */
+	u16 bt_hp_max_time;
+
+	/* Max time the WLAN HP will be respected. */
+	u16 wlan_hp_max_time;
+
+	/*
+	 * The time between the last BT activity
+	 * and the moment when the sense mode returns
+	 * to SENSE_INACTIVE.
+	 */
+	u16 sense_disable_timer;
+
+	/* Time before the next BT HP instance */
+	u16 rx_time_bt_hp;
+	u16 tx_time_bt_hp;
+
+	/* range: 10-20000    default: 1500 */
+	u16 rx_time_bt_hp_fast;
+	u16 tx_time_bt_hp_fast;
+
+	/* range: 2000-65535  default: 8700 */
+	u16 wlan_cycle_fast;
+
+	/* range: 0 - 15000 (Msec) default: 1000 */
+	u16 bt_anti_starvation_period;
+
+	/* range 400-10000(Usec) default: 3000 */
+	u16 next_bt_lp_packet;
+
+	/* Deafult: worst case for BT DH5 traffic */
+	u16 wake_up_beacon;
+
+	/* range: 0-50000(Usec) default: 1050 */
+	u16 hp_dm_max_guard_time;
+
+	/*
+	 * This is to prevent both BT & WLAN antenna
+	 * starvation.
+	 * Range: 100-50000(Usec) default:2550
+	 */
+	u16 next_wlan_packet;
+
+	/* 0 -> shared antenna */
+	u8 antenna_type;
+
+	/*
+	 * 0 -> TI legacy
+	 * 1 -> Palau
+	 */
+	u8 signal_type;
+
+	/*
+	 * BT AFH status
+	 * 0 -> no AFH
+	 * 1 -> from dedicated GPIO
+	 * 2 -> AFH on (from host)
+	 */
+	u8 afh_leverage_on;
+
+	/*
+	 * The number of cycles during which no
+	 * TX will be sent after 1 cycle of RX
+	 * transaction in protective mode
+	 */
+	u8 quiet_cycle_num;
+
+	/*
+	 * The maximum number of CTSs that will
+	 * be sent for receiving RX packet in
+	 * protective mode
+	 */
+	u8 max_cts;
+
+	/*
+	 * The number of WLAN packets
+	 * transferred in common mode before
+	 * switching to BT.
+	 */
+	u8 wlan_packets_num;
+
+	/*
+	 * The number of BT packets
+	 * transferred in common mode before
+	 * switching to WLAN.
+	 */
+	u8 bt_packets_num;
+
+	/* range: 1-255  default: 5 */
+	u8 missed_rx_avalanche;
+
+	/* range: 0-1    default: 1 */
+	u8 wlan_elp_hp;
+
+	/* range: 0 - 15  default: 4 */
+	u8 bt_anti_starvation_cycles;
+
+	u8 ack_mode_dual_ant;
+
+	/*
+	 * Allow PA_SD assertion/de-assertion
+	 * during enabled BT activity.
+	 */
+	u8 pa_sd_enable;
+
+	/*
+	 * Enable/Disable PTA in auto mode:
+	 * Support Both Active & P.S modes
+	 */
+	u8 pta_auto_mode_enable;
+
+	/* range: 0 - 20  default: 1 */
+	u8 bt_hp_respected_num;
+} __attribute__ ((packed));
+
+#define CCA_THRSH_ENABLE_ENERGY_D       0x140A
+#define CCA_THRSH_DISABLE_ENERGY_D      0xFFEF
+
+struct acx_energy_detection {
+	struct acx_header header;
+
+	/* The RX Clear Channel Assessment threshold in the PHY */
+	u16 rx_cca_threshold;
+	u8 tx_energy_detection;
+	u8 pad;
+} __attribute__ ((packed));
+
+#define BCN_RX_TIMEOUT_DEF_VALUE        10000
+#define BROADCAST_RX_TIMEOUT_DEF_VALUE  20000
+#define RX_BROADCAST_IN_PS_DEF_VALUE    1
+#define CONSECUTIVE_PS_POLL_FAILURE_DEF 4
+
+struct acx_beacon_broadcast {
+	struct acx_header header;
+
+	u16 beacon_rx_timeout;
+	u16 broadcast_timeout;
+
+	/* Enables receiving of broadcast packets in PS mode */
+	u8 rx_broadcast_in_ps;
+
+	/* Consecutive PS Poll failures before updating the host */
+	u8 ps_poll_threshold;
+	u8 pad[2];
+} __attribute__ ((packed));
+
+struct acx_event_mask {
+	struct acx_header header;
+
+	u32 event_mask;
+	u32 high_event_mask; /* Unused */
+} __attribute__ ((packed));
+
+#define CFG_RX_FCS		BIT(2)
+#define CFG_RX_ALL_GOOD		BIT(3)
+#define CFG_UNI_FILTER_EN	BIT(4)
+#define CFG_BSSID_FILTER_EN	BIT(5)
+#define CFG_MC_FILTER_EN	BIT(6)
+#define CFG_MC_ADDR0_EN		BIT(7)
+#define CFG_MC_ADDR1_EN		BIT(8)
+#define CFG_BC_REJECT_EN	BIT(9)
+#define CFG_SSID_FILTER_EN	BIT(10)
+#define CFG_RX_INT_FCS_ERROR	BIT(11)
+#define CFG_RX_INT_ENCRYPTED	BIT(12)
+#define CFG_RX_WR_RX_STATUS	BIT(13)
+#define CFG_RX_FILTER_NULTI	BIT(14)
+#define CFG_RX_RESERVE		BIT(15)
+#define CFG_RX_TIMESTAMP_TSF	BIT(16)
+
+#define CFG_RX_RSV_EN		BIT(0)
+#define CFG_RX_RCTS_ACK		BIT(1)
+#define CFG_RX_PRSP_EN		BIT(2)
+#define CFG_RX_PREQ_EN		BIT(3)
+#define CFG_RX_MGMT_EN		BIT(4)
+#define CFG_RX_FCS_ERROR	BIT(5)
+#define CFG_RX_DATA_EN		BIT(6)
+#define CFG_RX_CTL_EN		BIT(7)
+#define CFG_RX_CF_EN		BIT(8)
+#define CFG_RX_BCN_EN		BIT(9)
+#define CFG_RX_AUTH_EN		BIT(10)
+#define CFG_RX_ASSOC_EN		BIT(11)
+
+#define SCAN_PASSIVE		BIT(0)
+#define SCAN_5GHZ_BAND		BIT(1)
+#define SCAN_TRIGGERED		BIT(2)
+#define SCAN_PRIORITY_HIGH	BIT(3)
+
+struct acx_feature_config {
+	struct acx_header header;
+
+	u32 options;
+	u32 data_flow_options;
+} __attribute__ ((packed));
+
+struct acx_current_tx_power {
+	struct acx_header header;
+
+	u8  current_tx_power;
+	u8  padding[3];
+} __attribute__ ((packed));
+
+enum acx_wake_up_event {
+	WAKE_UP_EVENT_BEACON_BITMAP	= 0x01, /* Wake on every Beacon*/
+	WAKE_UP_EVENT_DTIM_BITMAP	= 0x02,	/* Wake on every DTIM*/
+	WAKE_UP_EVENT_N_DTIM_BITMAP	= 0x04, /* Wake on every Nth DTIM */
+	WAKE_UP_EVENT_N_BEACONS_BITMAP	= 0x08, /* Wake on every Nth Beacon */
+	WAKE_UP_EVENT_BITS_MASK		= 0x0F
+};
+
+struct acx_wake_up_condition {
+	struct acx_header header;
+
+	u8 wake_up_event; /* Only one bit can be set */
+	u8 listen_interval;
+	u8 pad[2];
+} __attribute__ ((packed));
+
+struct acx_aid {
+	struct acx_header header;
+
+	/*
+	 * To be set when associated with an AP.
+	 */
+	u16 aid;
+	u8 pad[2];
+} __attribute__ ((packed));
+
+enum acx_preamble_type {
+	ACX_PREAMBLE_LONG = 0,
+	ACX_PREAMBLE_SHORT = 1
+};
+
+struct acx_preamble {
+	struct acx_header header;
+
+	/*
+	 * When set, the WiLink transmits the frames with a short preamble and
+	 * when cleared, the WiLink transmits the frames with a long preamble.
+	 */
+	u8 preamble;
+	u8 padding[3];
+} __attribute__ ((packed));
+
+enum acx_ctsprotect_type {
+	CTSPROTECT_DISABLE = 0,
+	CTSPROTECT_ENABLE = 1
+};
+
+struct acx_ctsprotect {
+	struct acx_header header;
+	u8 ctsprotect;
+	u8 padding[3];
+} __attribute__ ((packed));
+
+struct acx_tx_statistics {
+	u32 internal_desc_overflow;
+}  __attribute__ ((packed));
+
+struct acx_rx_statistics {
+	u32 out_of_mem;
+	u32 hdr_overflow;
+	u32 hw_stuck;
+	u32 dropped;
+	u32 fcs_err;
+	u32 xfr_hint_trig;
+	u32 path_reset;
+	u32 reset_counter;
+} __attribute__ ((packed));
+
+struct acx_dma_statistics {
+	u32 rx_requested;
+	u32 rx_errors;
+	u32 tx_requested;
+	u32 tx_errors;
+}  __attribute__ ((packed));
+
+struct acx_isr_statistics {
+	/* host command complete */
+	u32 cmd_cmplt;
+
+	/* fiqisr() */
+	u32 fiqs;
+
+	/* (INT_STS_ND & INT_TRIG_RX_HEADER) */
+	u32 rx_headers;
+
+	/* (INT_STS_ND & INT_TRIG_RX_CMPLT) */
+	u32 rx_completes;
+
+	/* (INT_STS_ND & INT_TRIG_NO_RX_BUF) */
+	u32 rx_mem_overflow;
+
+	/* (INT_STS_ND & INT_TRIG_S_RX_RDY) */
+	u32 rx_rdys;
+
+	/* irqisr() */
+	u32 irqs;
+
+	/* (INT_STS_ND & INT_TRIG_TX_PROC) */
+	u32 tx_procs;
+
+	/* (INT_STS_ND & INT_TRIG_DECRYPT_DONE) */
+	u32 decrypt_done;
+
+	/* (INT_STS_ND & INT_TRIG_DMA0) */
+	u32 dma0_done;
+
+	/* (INT_STS_ND & INT_TRIG_DMA1) */
+	u32 dma1_done;
+
+	/* (INT_STS_ND & INT_TRIG_TX_EXC_CMPLT) */
+	u32 tx_exch_complete;
+
+	/* (INT_STS_ND & INT_TRIG_COMMAND) */
+	u32 commands;
+
+	/* (INT_STS_ND & INT_TRIG_RX_PROC) */
+	u32 rx_procs;
+
+	/* (INT_STS_ND & INT_TRIG_PM_802) */
+	u32 hw_pm_mode_changes;
+
+	/* (INT_STS_ND & INT_TRIG_ACKNOWLEDGE) */
+	u32 host_acknowledges;
+
+	/* (INT_STS_ND & INT_TRIG_PM_PCI) */
+	u32 pci_pm;
+
+	/* (INT_STS_ND & INT_TRIG_ACM_WAKEUP) */
+	u32 wakeups;
+
+	/* (INT_STS_ND & INT_TRIG_LOW_RSSI) */
+	u32 low_rssi;
+} __attribute__ ((packed));
+
+struct acx_wep_statistics {
+	/* WEP address keys configured */
+	u32 addr_key_count;
+
+	/* default keys configured */
+	u32 default_key_count;
+
+	u32 reserved;
+
+	/* number of times that WEP key not found on lookup */
+	u32 key_not_found;
+
+	/* number of times that WEP key decryption failed */
+	u32 decrypt_fail;
+
+	/* WEP packets decrypted */
+	u32 packets;
+
+	/* WEP decrypt interrupts */
+	u32 interrupt;
+} __attribute__ ((packed));
+
+#define ACX_MISSED_BEACONS_SPREAD 10
+
+struct acx_pwr_statistics {
+	/* the amount of enters into power save mode (both PD & ELP) */
+	u32 ps_enter;
+
+	/* the amount of enters into ELP mode */
+	u32 elp_enter;
+
+	/* the amount of missing beacon interrupts to the host */
+	u32 missing_bcns;
+
+	/* the amount of wake on host-access times */
+	u32 wake_on_host;
+
+	/* the amount of wake on timer-expire */
+	u32 wake_on_timer_exp;
+
+	/* the number of packets that were transmitted with PS bit set */
+	u32 tx_with_ps;
+
+	/* the number of packets that were transmitted with PS bit clear */
+	u32 tx_without_ps;
+
+	/* the number of received beacons */
+	u32 rcvd_beacons;
+
+	/* the number of entering into PowerOn (power save off) */
+	u32 power_save_off;
+
+	/* the number of entries into power save mode */
+	u16 enable_ps;
+
+	/*
+	 * the number of exits from power save, not including failed PS
+	 * transitions
+	 */
+	u16 disable_ps;
+
+	/*
+	 * the number of times the TSF counter was adjusted because
+	 * of drift
+	 */
+	u32 fix_tsf_ps;
+
+	/* Gives statistics about the spread continuous missed beacons.
+	 * The 16 LSB are dedicated for the PS mode.
+	 * The 16 MSB are dedicated for the PS mode.
+	 * cont_miss_bcns_spread[0] - single missed beacon.
+	 * cont_miss_bcns_spread[1] - two continuous missed beacons.
+	 * cont_miss_bcns_spread[2] - three continuous missed beacons.
+	 * ...
+	 * cont_miss_bcns_spread[9] - ten and more continuous missed beacons.
+	*/
+	u32 cont_miss_bcns_spread[ACX_MISSED_BEACONS_SPREAD];
+
+	/* the number of beacons in awake mode */
+	u32 rcvd_awake_beacons;
+} __attribute__ ((packed));
+
+struct acx_mic_statistics {
+	u32 rx_pkts;
+	u32 calc_failure;
+} __attribute__ ((packed));
+
+struct acx_aes_statistics {
+	u32 encrypt_fail;
+	u32 decrypt_fail;
+	u32 encrypt_packets;
+	u32 decrypt_packets;
+	u32 encrypt_interrupt;
+	u32 decrypt_interrupt;
+} __attribute__ ((packed));
+
+struct acx_event_statistics {
+	u32 heart_beat;
+	u32 calibration;
+	u32 rx_mismatch;
+	u32 rx_mem_empty;
+	u32 rx_pool;
+	u32 oom_late;
+	u32 phy_transmit_error;
+	u32 tx_stuck;
+} __attribute__ ((packed));
+
+struct acx_ps_statistics {
+	u32 pspoll_timeouts;
+	u32 upsd_timeouts;
+	u32 upsd_max_sptime;
+	u32 upsd_max_apturn;
+	u32 pspoll_max_apturn;
+	u32 pspoll_utilization;
+	u32 upsd_utilization;
+} __attribute__ ((packed));
+
+struct acx_rxpipe_statistics {
+	u32 rx_prep_beacon_drop;
+	u32 descr_host_int_trig_rx_data;
+	u32 beacon_buffer_thres_host_int_trig_rx_data;
+	u32 missed_beacon_host_int_trig_rx_data;
+	u32 tx_xfr_host_int_trig_rx_data;
+} __attribute__ ((packed));
+
+struct acx_statistics {
+	struct acx_header header;
+
+	struct acx_tx_statistics tx;
+	struct acx_rx_statistics rx;
+	struct acx_dma_statistics dma;
+	struct acx_isr_statistics isr;
+	struct acx_wep_statistics wep;
+	struct acx_pwr_statistics pwr;
+	struct acx_aes_statistics aes;
+	struct acx_mic_statistics mic;
+	struct acx_event_statistics event;
+	struct acx_ps_statistics ps;
+	struct acx_rxpipe_statistics rxpipe;
+} __attribute__ ((packed));
+
+#define ACX_MAX_RATE_CLASSES       8
+#define ACX_RATE_MASK_UNSPECIFIED  0
+#define ACX_RATE_MASK_ALL          0x1eff
+#define ACX_RATE_RETRY_LIMIT       10
+
+struct acx_rate_class {
+	u32 enabled_rates;
+	u8 short_retry_limit;
+	u8 long_retry_limit;
+	u8 aflags;
+	u8 reserved;
+};
+
+struct acx_rate_policy {
+	struct acx_header header;
+
+	u32 rate_class_cnt;
+	struct acx_rate_class rate_class[ACX_MAX_RATE_CLASSES];
+} __attribute__ ((packed));
+
+#define WL1271_ACX_AC_COUNT 4
+
+struct acx_ac_cfg {
+	struct acx_header header;
+	u8 ac;
+	u8 cw_min;
+	u16 cw_max;
+	u8 aifsn;
+	u8 reserved;
+	u16 tx_op_limit;
+} __attribute__ ((packed));
+
+enum wl1271_acx_ac {
+	WL1271_ACX_AC_BE = 0,
+	WL1271_ACX_AC_BK = 1,
+	WL1271_ACX_AC_VI = 2,
+	WL1271_ACX_AC_VO = 3,
+	WL1271_ACX_AC_CTS2SELF = 4,
+	WL1271_ACX_AC_ANY_TID = 0x1F,
+	WL1271_ACX_AC_INVALID = 0xFF,
+};
+
+enum wl1271_acx_ps_scheme {
+	WL1271_ACX_PS_SCHEME_LEGACY = 0,
+	WL1271_ACX_PS_SCHEME_UPSD_TRIGGER = 1,
+	WL1271_ACX_PS_SCHEME_LEGACY_PSPOLL = 2,
+	WL1271_ACX_PS_SCHEME_SAPSD = 3,
+};
+
+enum wl1271_acx_ack_policy {
+	WL1271_ACX_ACK_POLICY_LEGACY = 0,
+	WL1271_ACX_ACK_POLICY_NO_ACK = 1,
+	WL1271_ACX_ACK_POLICY_BLOCK = 2,
+};
+
+#define WL1271_ACX_TID_COUNT 7
+
+struct acx_tid_config {
+	struct acx_header header;
+	u8 queue_id;
+	u8 channel_type;
+	u8 tsid;
+	u8 ps_scheme;
+	u8 ack_policy;
+	u8 padding[3];
+	u32 apsd_conf[2];
+} __attribute__ ((packed));
+
+struct acx_frag_threshold {
+	struct acx_header header;
+	u16 frag_threshold;
+	u8 padding[2];
+} __attribute__ ((packed));
+
+#define WL1271_ACX_TX_COMPL_TIMEOUT   5
+#define WL1271_ACX_TX_COMPL_THRESHOLD 5
+
+struct acx_tx_config_options {
+	struct acx_header header;
+	u16 tx_compl_timeout;     /* msec */
+	u16 tx_compl_threshold;   /* number of packets */
+} __attribute__ ((packed));
+
+#define ACX_RX_MEM_BLOCKS     64
+#define ACX_TX_MIN_MEM_BLOCKS 64
+#define ACX_TX_DESCRIPTORS    32
+#define ACX_NUM_SSID_PROFILES 1
+
+struct wl1271_acx_config_memory {
+	struct acx_header header;
+
+	u8 rx_mem_block_num;
+	u8 tx_min_mem_block_num;
+	u8 num_stations;
+	u8 num_ssid_profiles;
+	u32 total_tx_descriptors;
+} __attribute__ ((packed));
+
+struct wl1271_acx_mem_map {
+	struct acx_header header;
+
+	void *code_start;
+	void *code_end;
+
+	void *wep_defkey_start;
+	void *wep_defkey_end;
+
+	void *sta_table_start;
+	void *sta_table_end;
+
+	void *packet_template_start;
+	void *packet_template_end;
+
+	/* Address of the TX result interface (control block) */
+	u32 tx_result;
+	u32 tx_result_queue_start;
+
+	void *queue_memory_start;
+	void *queue_memory_end;
+
+	u32 packet_memory_pool_start;
+	u32 packet_memory_pool_end;
+
+	void *debug_buffer1_start;
+	void *debug_buffer1_end;
+
+	void *debug_buffer2_start;
+	void *debug_buffer2_end;
+
+	/* Number of blocks FW allocated for TX packets */
+	u32 num_tx_mem_blocks;
+
+	/* Number of blocks FW allocated for RX packets */
+	u32 num_rx_mem_blocks;
+
+	/* the following 4 fields are valid in SLAVE mode only */
+	u8 *tx_cbuf;
+	u8 *rx_cbuf;
+	void *rx_ctrl;
+	void *tx_ctrl;
+} __attribute__ ((packed));
+
+enum wl1271_acx_rx_queue_type {
+	RX_QUEUE_TYPE_RX_LOW_PRIORITY,    /* All except the high priority */
+	RX_QUEUE_TYPE_RX_HIGH_PRIORITY,   /* Management and voice packets */
+	RX_QUEUE_TYPE_NUM,
+	RX_QUEUE_TYPE_MAX = USHORT_MAX
+};
+
+#define WL1271_RX_INTR_THRESHOLD_DEF  0       /* no pacing, send interrupt on
+					       * every event */
+#define WL1271_RX_INTR_THRESHOLD_MIN  0
+#define WL1271_RX_INTR_THRESHOLD_MAX  15
+
+#define WL1271_RX_INTR_TIMEOUT_DEF    5
+#define WL1271_RX_INTR_TIMEOUT_MIN    1
+#define WL1271_RX_INTR_TIMEOUT_MAX    100
+
+struct wl1271_acx_rx_config_opt {
+	struct acx_header header;
+
+	u16 mblk_threshold;
+	u16 threshold;
+	u16 timeout;
+	u8 queue_type;
+	u8 reserved;
+} __attribute__ ((packed));
+
+enum {
+	ACX_WAKE_UP_CONDITIONS      = 0x0002,
+	ACX_MEM_CFG                 = 0x0003,
+	ACX_SLOT                    = 0x0004,
+	ACX_AC_CFG                  = 0x0007,
+	ACX_MEM_MAP                 = 0x0008,
+	ACX_AID                     = 0x000A,
+	/* ACX_FW_REV is missing in the ref driver, but seems to work */
+	ACX_FW_REV                  = 0x000D,
+	ACX_MEDIUM_USAGE            = 0x000F,
+	ACX_RX_CFG                  = 0x0010,
+	ACX_TX_QUEUE_CFG            = 0x0011, /* FIXME: only used by wl1251 */
+	ACX_STATISTICS              = 0x0013, /* Debug API */
+	ACX_PWR_CONSUMPTION_STATISTICS = 0x0014,
+	ACX_FEATURE_CFG             = 0x0015,
+	ACX_TID_CFG                 = 0x001A,
+	ACX_PS_RX_STREAMING         = 0x001B,
+	ACX_BEACON_FILTER_OPT       = 0x001F,
+	ACX_NOISE_HIST              = 0x0021,
+	ACX_HDK_VERSION             = 0x0022, /* ??? */
+	ACX_PD_THRESHOLD            = 0x0023,
+	ACX_TX_CONFIG_OPT           = 0x0024,
+	ACX_CCA_THRESHOLD           = 0x0025,
+	ACX_EVENT_MBOX_MASK         = 0x0026,
+	ACX_CONN_MONIT_PARAMS       = 0x002D,
+	ACX_CONS_TX_FAILURE         = 0x002F,
+	ACX_BCN_DTIM_OPTIONS        = 0x0031,
+	ACX_SG_ENABLE               = 0x0032,
+	ACX_SG_CFG                  = 0x0033,
+	ACX_BEACON_FILTER_TABLE     = 0x0038,
+	ACX_ARP_IP_FILTER           = 0x0039,
+	ACX_ROAMING_STATISTICS_TBL  = 0x003B,
+	ACX_RATE_POLICY             = 0x003D,
+	ACX_CTS_PROTECTION          = 0x003E,
+	ACX_SLEEP_AUTH              = 0x003F,
+	ACX_PREAMBLE_TYPE	    = 0x0040,
+	ACX_ERROR_CNT               = 0x0041,
+	ACX_IBSS_FILTER		    = 0x0044,
+	ACX_SERVICE_PERIOD_TIMEOUT  = 0x0045,
+	ACX_TSF_INFO                = 0x0046,
+	ACX_CONFIG_PS_WMM           = 0x0049,
+	ACX_ENABLE_RX_DATA_FILTER   = 0x004A,
+	ACX_SET_RX_DATA_FILTER      = 0x004B,
+	ACX_GET_DATA_FILTER_STATISTICS = 0x004C,
+	ACX_RX_CONFIG_OPT           = 0x004E,
+	ACX_FRAG_CFG                = 0x004F,
+	ACX_BET_ENABLE              = 0x0050,
+	ACX_RSSI_SNR_TRIGGER        = 0x0051,
+	ACX_RSSI_SNR_WEIGHTS        = 0x0051,
+	ACX_KEEP_ALIVE_MODE         = 0x0052,
+	ACX_SET_KEEP_ALIVE_CONFIG   = 0x0054,
+	ACX_BA_SESSION_RESPONDER_POLICY = 0x0055,
+	ACX_BA_SESSION_INITIATOR_POLICY = 0x0056,
+	ACX_PEER_HT_CAP             = 0x0057,
+	ACX_HT_BSS_OPERATION        = 0x0058,
+	ACX_COEX_ACTIVITY           = 0x0059,
+	DOT11_RX_MSDU_LIFE_TIME     = 0x1004,
+	DOT11_CUR_TX_PWR            = 0x100D,
+	DOT11_RX_DOT11_MODE         = 0x1012,
+	DOT11_RTS_THRESHOLD         = 0x1013,
+	DOT11_GROUP_ADDRESS_TBL     = 0x1014,
+
+	MAX_DOT11_IE = DOT11_GROUP_ADDRESS_TBL,
+
+	MAX_IE = 0xFFFF
+};
+
+
+int wl1271_acx_wake_up_conditions(struct wl1271 *wl, u8 wake_up_event,
+				  u8 listen_interval);
+int wl1271_acx_sleep_auth(struct wl1271 *wl, u8 sleep_auth);
+int wl1271_acx_fw_version(struct wl1271 *wl, char *buf, size_t len);
+int wl1271_acx_tx_power(struct wl1271 *wl, int power);
+int wl1271_acx_feature_cfg(struct wl1271 *wl);
+int wl1271_acx_mem_map(struct wl1271 *wl,
+		       struct acx_header *mem_map, size_t len);
+int wl1271_acx_rx_msdu_life_time(struct wl1271 *wl, u32 life_time);
+int wl1271_acx_rx_config(struct wl1271 *wl, u32 config, u32 filter);
+int wl1271_acx_pd_threshold(struct wl1271 *wl);
+int wl1271_acx_slot(struct wl1271 *wl, enum acx_slot_type slot_time);
+int wl1271_acx_group_address_tbl(struct wl1271 *wl);
+int wl1271_acx_service_period_timeout(struct wl1271 *wl);
+int wl1271_acx_rts_threshold(struct wl1271 *wl, u16 rts_threshold);
+int wl1271_acx_beacon_filter_opt(struct wl1271 *wl);
+int wl1271_acx_beacon_filter_table(struct wl1271 *wl);
+int wl1271_acx_sg_enable(struct wl1271 *wl);
+int wl1271_acx_sg_cfg(struct wl1271 *wl);
+int wl1271_acx_cca_threshold(struct wl1271 *wl);
+int wl1271_acx_bcn_dtim_options(struct wl1271 *wl);
+int wl1271_acx_aid(struct wl1271 *wl, u16 aid);
+int wl1271_acx_event_mbox_mask(struct wl1271 *wl, u32 event_mask);
+int wl1271_acx_set_preamble(struct wl1271 *wl, enum acx_preamble_type preamble);
+int wl1271_acx_cts_protect(struct wl1271 *wl,
+			    enum acx_ctsprotect_type ctsprotect);
+int wl1271_acx_statistics(struct wl1271 *wl, struct acx_statistics *stats);
+int wl1271_acx_rate_policies(struct wl1271 *wl);
+int wl1271_acx_ac_cfg(struct wl1271 *wl);
+int wl1271_acx_tid_cfg(struct wl1271 *wl);
+int wl1271_acx_frag_threshold(struct wl1271 *wl);
+int wl1271_acx_tx_config_options(struct wl1271 *wl);
+int wl1271_acx_mem_cfg(struct wl1271 *wl);
+int wl1271_acx_init_mem_config(struct wl1271 *wl);
+int wl1271_acx_init_rx_interrupt(struct wl1271 *wl);
+
+#endif /* __WL1271_ACX_H__ */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_boot.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_boot.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_boot.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_boot.c	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,540 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/gpio.h>
+
+#include "wl1271_acx.h"
+#include "wl1271_reg.h"
+#include "wl1271_boot.h"
+#include "wl1271_spi.h"
+#include "wl1271_event.h"
+
+static struct wl1271_partition_set part_table[PART_TABLE_LEN] = {
+	[PART_DOWN] = {
+		.mem = {
+			.start = 0x00000000,
+			.size  = 0x000177c0
+		},
+		.reg = {
+			.start = REGISTERS_BASE,
+			.size  = 0x00008800
+		},
+	},
+
+	[PART_WORK] = {
+		.mem = {
+			.start = 0x00040000,
+			.size  = 0x00014fc0
+		},
+		.reg = {
+			.start = REGISTERS_BASE,
+			.size  = 0x0000b000
+		},
+	},
+
+	[PART_DRPW] = {
+		.mem = {
+			.start = 0x00040000,
+			.size  = 0x00014fc0
+		},
+		.reg = {
+			.start = DRPW_BASE,
+			.size  = 0x00006000
+		}
+	}
+};
+
+static void wl1271_boot_set_ecpu_ctrl(struct wl1271 *wl, u32 flag)
+{
+	u32 cpu_ctrl;
+
+	/* 10.5.0 run the firmware (I) */
+	cpu_ctrl = wl1271_reg_read32(wl, ACX_REG_ECPU_CONTROL);
+
+	/* 10.5.1 run the firmware (II) */
+	cpu_ctrl |= flag;
+	wl1271_reg_write32(wl, ACX_REG_ECPU_CONTROL, cpu_ctrl);
+}
+
+static void wl1271_boot_fw_version(struct wl1271 *wl)
+{
+	struct wl1271_static_data static_data;
+
+	wl1271_spi_mem_read(wl, wl->cmd_box_addr,
+			    &static_data, sizeof(static_data));
+
+	strncpy(wl->chip.fw_ver, static_data.fw_version,
+		sizeof(wl->chip.fw_ver));
+
+	/* make sure the string is NULL-terminated */
+	wl->chip.fw_ver[sizeof(wl->chip.fw_ver) - 1] = '\0';
+}
+
+static int wl1271_boot_upload_firmware_chunk(struct wl1271 *wl, void *buf,
+					     size_t fw_data_len, u32 dest)
+{
+	int addr, chunk_num, partition_limit;
+	u8 *p;
+
+	/* whal_FwCtrl_LoadFwImageSm() */
+
+	wl1271_debug(DEBUG_BOOT, "starting firmware upload");
+
+	wl1271_debug(DEBUG_BOOT, "fw_data_len %d chunk_size %d", fw_data_len,
+		CHUNK_SIZE);
+
+
+	if ((fw_data_len % 4) != 0) {
+		wl1271_error("firmware length not multiple of four");
+		return -EIO;
+	}
+
+	wl1271_set_partition(wl, dest,
+			     part_table[PART_DOWN].mem.size,
+			     part_table[PART_DOWN].reg.start,
+			     part_table[PART_DOWN].reg.size);
+
+	/* 10.1 set partition limit and chunk num */
+	chunk_num = 0;
+	partition_limit = part_table[PART_DOWN].mem.size;
+
+	while (chunk_num < fw_data_len / CHUNK_SIZE) {
+		/* 10.2 update partition, if needed */
+		addr = dest + (chunk_num + 2) * CHUNK_SIZE;
+		if (addr > partition_limit) {
+			addr = dest + chunk_num * CHUNK_SIZE;
+			partition_limit = chunk_num * CHUNK_SIZE +
+				part_table[PART_DOWN].mem.size;
+
+			/* FIXME: Over 80 chars! */
+			wl1271_set_partition(wl,
+					     addr,
+					     part_table[PART_DOWN].mem.size,
+					     part_table[PART_DOWN].reg.start,
+					     part_table[PART_DOWN].reg.size);
+		}
+
+		/* 10.3 upload the chunk */
+		addr = dest + chunk_num * CHUNK_SIZE;
+		p = buf + chunk_num * CHUNK_SIZE;
+		wl1271_debug(DEBUG_BOOT, "uploading fw chunk 0x%p to 0x%x",
+			     p, addr);
+		wl1271_spi_mem_write(wl, addr, p, CHUNK_SIZE);
+
+		chunk_num++;
+	}
+
+	/* 10.4 upload the last chunk */
+	addr = dest + chunk_num * CHUNK_SIZE;
+	p = buf + chunk_num * CHUNK_SIZE;
+	wl1271_debug(DEBUG_BOOT, "uploading fw last chunk (%d B) 0x%p to 0x%x",
+		     fw_data_len % CHUNK_SIZE, p, addr);
+	wl1271_spi_mem_write(wl, addr, p, fw_data_len % CHUNK_SIZE);
+
+	return 0;
+}
+
+static int wl1271_boot_upload_firmware(struct wl1271 *wl)
+{
+	u32 chunks, addr, len;
+	u8 *fw;
+
+	fw = wl->fw;
+	chunks = be32_to_cpup((u32 *) fw);
+	fw += sizeof(u32);
+
+	wl1271_debug(DEBUG_BOOT, "firmware chunks to be uploaded: %u", chunks);
+
+	while (chunks--) {
+		addr = be32_to_cpup((u32 *) fw);
+		fw += sizeof(u32);
+		len = be32_to_cpup((u32 *) fw);
+		fw += sizeof(u32);
+
+		if (len > 300000) {
+			wl1271_info("firmware chunk too long: %u", len);
+			return -EINVAL;
+		}
+		wl1271_debug(DEBUG_BOOT, "chunk %d addr 0x%x len %u",
+			     chunks, addr, len);
+		wl1271_boot_upload_firmware_chunk(wl, fw, len, addr);
+		fw += len;
+	}
+
+	return 0;
+}
+
+static int wl1271_boot_upload_nvs(struct wl1271 *wl)
+{
+	size_t nvs_len, burst_len;
+	int i;
+	u32 dest_addr, val;
+	u8 *nvs_ptr, *nvs, *nvs_aligned;
+
+	nvs = wl->nvs;
+	if (nvs == NULL)
+		return -ENODEV;
+
+	nvs_ptr = nvs;
+
+	nvs_len = wl->nvs_len;
+
+	/* Update the device MAC address into the nvs */
+	nvs[11] = wl->mac_addr[0];
+	nvs[10] = wl->mac_addr[1];
+	nvs[6] = wl->mac_addr[2];
+	nvs[5] = wl->mac_addr[3];
+	nvs[4] = wl->mac_addr[4];
+	nvs[3] = wl->mac_addr[5];
+
+	/*
+	 * Layout before the actual NVS tables:
+	 * 1 byte : burst length.
+	 * 2 bytes: destination address.
+	 * n bytes: data to burst copy.
+	 *
+	 * This is ended by a 0 length, then the NVS tables.
+	 */
+
+	/* FIXME: Do we need to check here whether the LSB is 1? */
+	while (nvs_ptr[0]) {
+		burst_len = nvs_ptr[0];
+		dest_addr = (nvs_ptr[1] & 0xfe) | ((u32)(nvs_ptr[2] << 8));
+
+		/* FIXME: Due to our new wl1271_translate_reg_addr function,
+		   we need to add the REGISTER_BASE to the destination */
+		dest_addr += REGISTERS_BASE;
+
+		/* We move our pointer to the data */
+		nvs_ptr += 3;
+
+		for (i = 0; i < burst_len; i++) {
+			val = (nvs_ptr[0] | (nvs_ptr[1] << 8)
+			       | (nvs_ptr[2] << 16) | (nvs_ptr[3] << 24));
+
+			wl1271_debug(DEBUG_BOOT,
+				     "nvs burst write 0x%x: 0x%x",
+				     dest_addr, val);
+			wl1271_reg_write32(wl, dest_addr, val);
+
+			nvs_ptr += 4;
+			dest_addr += 4;
+		}
+	}
+
+	/*
+	 * We've reached the first zero length, the first NVS table
+	 * is 7 bytes further.
+	 */
+	nvs_ptr += 7;
+	nvs_len -= nvs_ptr - nvs;
+	nvs_len = ALIGN(nvs_len, 4);
+
+	/* FIXME: The driver sets the partition here, but this is not needed,
+	   since it sets to the same one as currently in use */
+	/* Now we must set the partition correctly */
+	wl1271_set_partition(wl,
+			     part_table[PART_WORK].mem.start,
+			     part_table[PART_WORK].mem.size,
+			     part_table[PART_WORK].reg.start,
+			     part_table[PART_WORK].reg.size);
+
+	/* Copy the NVS tables to a new block to ensure alignment */
+	nvs_aligned = kmemdup(nvs_ptr, nvs_len, GFP_KERNEL);
+
+	/* And finally we upload the NVS tables */
+	/* FIXME: In wl1271, we upload everything at once.
+	   No endianness handling needed here?! The ref driver doesn't do
+	   anything about it at this point */
+	wl1271_spi_mem_write(wl, CMD_MBOX_ADDRESS, nvs_aligned, nvs_len);
+
+	kfree(nvs_aligned);
+	return 0;
+}
+
+static void wl1271_boot_enable_interrupts(struct wl1271 *wl)
+{
+	enable_irq(wl->irq);
+	wl1271_reg_write32(wl, ACX_REG_INTERRUPT_MASK, ~(WL1271_INTR_MASK));
+	wl1271_reg_write32(wl, HI_CFG, HI_CFG_DEF_VAL);
+}
+
+static int wl1271_boot_soft_reset(struct wl1271 *wl)
+{
+	unsigned long timeout;
+	u32 boot_data;
+
+	/* perform soft reset */
+	wl1271_reg_write32(wl, ACX_REG_SLV_SOFT_RESET, ACX_SLV_SOFT_RESET_BIT);
+
+	/* SOFT_RESET is self clearing */
+	timeout = jiffies + usecs_to_jiffies(SOFT_RESET_MAX_TIME);
+	while (1) {
+		boot_data = wl1271_reg_read32(wl, ACX_REG_SLV_SOFT_RESET);
+		wl1271_debug(DEBUG_BOOT, "soft reset bootdata 0x%x", boot_data);
+		if ((boot_data & ACX_SLV_SOFT_RESET_BIT) == 0)
+			break;
+
+		if (time_after(jiffies, timeout)) {
+			/* 1.2 check pWhalBus->uSelfClearTime if the
+			 * timeout was reached */
+			wl1271_error("soft reset timeout");
+			return -1;
+		}
+
+		udelay(SOFT_RESET_STALL_TIME);
+	}
+
+	/* disable Rx/Tx */
+	wl1271_reg_write32(wl, ENABLE, 0x0);
+
+	/* disable auto calibration on start*/
+	wl1271_reg_write32(wl, SPARE_A2, 0xffff);
+
+	return 0;
+}
+
+static int wl1271_boot_run_firmware(struct wl1271 *wl)
+{
+	int loop, ret;
+	u32 chip_id, interrupt;
+
+	wl1271_boot_set_ecpu_ctrl(wl, ECPU_CONTROL_HALT);
+
+	chip_id = wl1271_reg_read32(wl, CHIP_ID_B);
+
+	wl1271_debug(DEBUG_BOOT, "chip id after firmware boot: 0x%x", chip_id);
+
+	if (chip_id != wl->chip.id) {
+		wl1271_error("chip id doesn't match after firmware boot");
+		return -EIO;
+	}
+
+	/* wait for init to complete */
+	loop = 0;
+	while (loop++ < INIT_LOOP) {
+		udelay(INIT_LOOP_DELAY);
+		interrupt = wl1271_reg_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);
+
+		if (interrupt == 0xffffffff) {
+			wl1271_error("error reading hardware complete "
+				     "init indication");
+			return -EIO;
+		}
+		/* check that ACX_INTR_INIT_COMPLETE is enabled */
+		else if (interrupt & WL1271_ACX_INTR_INIT_COMPLETE) {
+			wl1271_reg_write32(wl, ACX_REG_INTERRUPT_ACK,
+					   WL1271_ACX_INTR_INIT_COMPLETE);
+			break;
+		}
+	}
+
+	if (loop >= INIT_LOOP) {
+		wl1271_error("timeout waiting for the hardware to "
+			     "complete initialization");
+		return -EIO;
+	}
+
+	/* get hardware config command mail box */
+	wl->cmd_box_addr = wl1271_reg_read32(wl, REG_COMMAND_MAILBOX_PTR);
+
+	/* get hardware config event mail box */
+	wl->event_box_addr = wl1271_reg_read32(wl, REG_EVENT_MAILBOX_PTR);
+
+	/* set the working partition to its "running" mode offset */
+	wl1271_set_partition(wl,
+			     part_table[PART_WORK].mem.start,
+			     part_table[PART_WORK].mem.size,
+			     part_table[PART_WORK].reg.start,
+			     part_table[PART_WORK].reg.size);
+
+	wl1271_debug(DEBUG_MAILBOX, "cmd_box_addr 0x%x event_box_addr 0x%x",
+		     wl->cmd_box_addr, wl->event_box_addr);
+
+	wl1271_boot_fw_version(wl);
+
+	/*
+	 * in case of full asynchronous mode the firmware event must be
+	 * ready to receive event from the command mailbox
+	 */
+
+	/* enable gpio interrupts */
+	wl1271_boot_enable_interrupts(wl);
+
+	/* unmask all mbox events  */
+	wl->event_mask = 0xffffffff;
+
+	ret = wl1271_event_unmask(wl);
+	if (ret < 0) {
+		wl1271_error("EVENT mask setting failed");
+		return ret;
+	}
+
+	wl1271_event_mbox_config(wl);
+
+	/* firmware startup completed */
+	return 0;
+}
+
+static int wl1271_boot_write_irq_polarity(struct wl1271 *wl)
+{
+	u32 polarity, status, i;
+
+	wl1271_reg_write32(wl, OCP_POR_CTR, OCP_REG_POLARITY);
+	wl1271_reg_write32(wl, OCP_CMD, OCP_CMD_READ);
+
+	/* Wait until the command is complete (ie. bit 18 is set) */
+	for (i = 0; i < OCP_CMD_LOOP; i++) {
+		polarity = wl1271_reg_read32(wl, OCP_DATA_READ);
+		if (polarity & OCP_READY_MASK)
+			break;
+	}
+	if (i == OCP_CMD_LOOP) {
+		wl1271_error("OCP command timeout!");
+		return -EIO;
+	}
+
+	status = polarity & OCP_STATUS_MASK;
+	if (status != OCP_STATUS_OK) {
+		wl1271_error("OCP command failed (%d)", status);
+		return -EIO;
+	}
+
+	/* We use HIGH polarity, so unset the LOW bit */
+	polarity &= ~POLARITY_LOW;
+
+	wl1271_reg_write32(wl, OCP_POR_CTR, OCP_REG_POLARITY);
+	wl1271_reg_write32(wl, OCP_DATA_WRITE, polarity);
+	wl1271_reg_write32(wl, OCP_CMD, OCP_CMD_WRITE);
+
+	return 0;
+}
+
+int wl1271_boot(struct wl1271 *wl)
+{
+	int ret = 0;
+	u32 tmp, clk, pause;
+
+	if (REF_CLOCK == 0 || REF_CLOCK == 2)
+		/* ref clk: 19.2/38.4 */
+		clk = 0x3;
+	else if (REF_CLOCK == 1 || REF_CLOCK == 3)
+		/* ref clk: 26/52 */
+		clk = 0x5;
+
+	wl1271_reg_write32(wl, PLL_PARAMETERS, clk);
+
+	pause = wl1271_reg_read32(wl, PLL_PARAMETERS);
+
+	wl1271_debug(DEBUG_BOOT, "pause1 0x%x", pause);
+
+	pause &= ~(WU_COUNTER_PAUSE_VAL); /* FIXME: This should probably be
+					   * WU_COUNTER_PAUSE_VAL instead of
+					   * 0x3ff (magic number ).  How does
+					   * this work?! */
+	pause |= WU_COUNTER_PAUSE_VAL;
+	wl1271_reg_write32(wl, WU_COUNTER_PAUSE, pause);
+
+	/* Continue the ELP wake up sequence */
+	wl1271_reg_write32(wl, WELP_ARM_COMMAND, WELP_ARM_COMMAND_VAL);
+	udelay(500);
+
+	wl1271_set_partition(wl,
+			     part_table[PART_DRPW].mem.start,
+			     part_table[PART_DRPW].mem.size,
+			     part_table[PART_DRPW].reg.start,
+			     part_table[PART_DRPW].reg.size);
+
+	/* Read-modify-write DRPW_SCRATCH_START register (see next state)
+	   to be used by DRPw FW. The RTRIM value will be added by the FW
+	   before taking DRPw out of reset */
+
+	wl1271_debug(DEBUG_BOOT, "DRPW_SCRATCH_START %08x", DRPW_SCRATCH_START);
+	clk = wl1271_reg_read32(wl, DRPW_SCRATCH_START);
+
+	wl1271_debug(DEBUG_BOOT, "clk2 0x%x", clk);
+
+	/* 2 */
+	clk |= (REF_CLOCK << 1) << 4;
+	wl1271_reg_write32(wl, DRPW_SCRATCH_START, clk);
+
+	wl1271_set_partition(wl,
+			     part_table[PART_WORK].mem.start,
+			     part_table[PART_WORK].mem.size,
+			     part_table[PART_WORK].reg.start,
+			     part_table[PART_WORK].reg.size);
+
+	/* Disable interrupts */
+	wl1271_reg_write32(wl, ACX_REG_INTERRUPT_MASK, WL1271_ACX_INTR_ALL);
+
+	ret = wl1271_boot_soft_reset(wl);
+	if (ret < 0)
+		goto out;
+
+	/* 2. start processing NVS file */
+	ret = wl1271_boot_upload_nvs(wl);
+	if (ret < 0)
+		goto out;
+
+	/* write firmware's last address (ie. it's length) to
+	 * ACX_EEPROMLESS_IND_REG */
+	wl1271_debug(DEBUG_BOOT, "ACX_EEPROMLESS_IND_REG");
+
+	wl1271_reg_write32(wl, ACX_EEPROMLESS_IND_REG, ACX_EEPROMLESS_IND_REG);
+
+	tmp = wl1271_reg_read32(wl, CHIP_ID_B);
+
+	wl1271_debug(DEBUG_BOOT, "chip id 0x%x", tmp);
+
+	/* 6. read the EEPROM parameters */
+	tmp = wl1271_reg_read32(wl, SCR_PAD2);
+
+	ret = wl1271_boot_write_irq_polarity(wl);
+	if (ret < 0)
+		goto out;
+
+	/* FIXME: Need to check whether this is really what we want */
+	wl1271_reg_write32(wl, ACX_REG_INTERRUPT_MASK,
+			   WL1271_ACX_ALL_EVENTS_VECTOR);
+
+	/* WL1271: The reference driver skips steps 7 to 10 (jumps directly
+	 * to upload_fw) */
+
+	ret = wl1271_boot_upload_firmware(wl);
+	if (ret < 0)
+		goto out;
+
+	/* 10.5 start firmware */
+	ret = wl1271_boot_run_firmware(wl);
+	if (ret < 0)
+		goto out;
+
+	/* set the wl1271 default filters */
+	wl->rx_config = WL1271_DEFAULT_RX_CONFIG;
+	wl->rx_filter = WL1271_DEFAULT_RX_FILTER;
+
+	wl1271_event_mbox_config(wl);
+
+out:
+	return ret;
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_boot.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_boot.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_boot.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_boot.h	2012-12-16 13:13:01.684330145 +0100
@@ -0,0 +1,72 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __BOOT_H__
+#define __BOOT_H__
+
+#include "wl1271.h"
+
+int wl1271_boot(struct wl1271 *wl);
+
+#define WL1271_NO_SUBBANDS 8
+#define WL1271_NO_POWER_LEVELS 4
+#define WL1271_FW_VERSION_MAX_LEN 20
+
+struct wl1271_static_data {
+	u8 mac_address[ETH_ALEN];
+	u8 padding[2];
+	u8 fw_version[WL1271_FW_VERSION_MAX_LEN];
+	u32 hw_version;
+	u8 tx_power_table[WL1271_NO_SUBBANDS][WL1271_NO_POWER_LEVELS];
+};
+
+/* number of times we try to read the INIT interrupt */
+#define INIT_LOOP 20000
+
+/* delay between retries */
+#define INIT_LOOP_DELAY 50
+
+#define REF_CLOCK            2
+#define WU_COUNTER_PAUSE_VAL 0x3FF
+#define WELP_ARM_COMMAND_VAL 0x4
+
+#define OCP_CMD_LOOP  32
+
+#define OCP_CMD_WRITE 0x1
+#define OCP_CMD_READ  0x2
+
+#define OCP_READY_MASK  BIT(18)
+#define OCP_STATUS_MASK (BIT(16) | BIT(17))
+
+#define OCP_STATUS_NO_RESP    0x00000
+#define OCP_STATUS_OK         0x10000
+#define OCP_STATUS_REQ_FAILED 0x20000
+#define OCP_STATUS_RESP_ERROR 0x30000
+
+#define OCP_REG_POLARITY 0x30032
+
+#define CMD_MBOX_ADDRESS 0x407B4
+
+#define POLARITY_LOW BIT(1)
+
+#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,623 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (C) 2008-2009 Nokia Corporation
- *
- * Contact: Kalle Valo <kalle.valo@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-
-#include "wl1271.h"
-#include "spi.h"
-#include "boot.h"
-#include "acx.h"
-#include "init.h"
-
-static struct wl12xx_partition_set wl1271_part_table[PART_TABLE_LEN] = {
-	[PART_DOWN] = {
-		.mem = {
-			.start = 0x00000000,
-			.size  = 0x000177c0
-		},
-		.reg = {
-			.start = REGISTERS_BASE,
-			.size  = 0x00008800
-		},
-	},
-
-	[PART_WORK] = {
-		.mem = {
-			.start = 0x00040000,
-			.size  = 0x00014fc0
-		},
-		.reg = {
-			.start = REGISTERS_BASE,
-			.size  = 0x0000b000
-		},
-	},
-
-	[PART_DRPW] = {
-		.mem = {
-			.start = 0x00040000,
-			.size  = 0x00014fc0
-		},
-		.reg = {
-			.start = DRPW_BASE,
-			.size  = 0x00006000
-		}
-	}
-};
-
-static enum wl12xx_acx_int_reg wl1271_acx_reg_table[ACX_REG_TABLE_LEN] = {
-	[ACX_REG_INTERRUPT_TRIG]     = (REGISTERS_BASE + 0x0474),
-	[ACX_REG_INTERRUPT_TRIG_H]   = (REGISTERS_BASE + 0x0478),
-	[ACX_REG_INTERRUPT_MASK]     = (REGISTERS_BASE + 0x04DC),
-	[ACX_REG_HINT_MASK_SET]      = (REGISTERS_BASE + 0x04E0),
-	[ACX_REG_HINT_MASK_CLR]      = (REGISTERS_BASE + 0x04E4),
-	[ACX_REG_INTERRUPT_NO_CLEAR] = (REGISTERS_BASE + 0x04E8),
-	[ACX_REG_INTERRUPT_CLEAR]    = (REGISTERS_BASE + 0x04F8),
-	[ACX_REG_INTERRUPT_ACK]      = (REGISTERS_BASE + 0x04F0),
-	[ACX_REG_SLV_SOFT_RESET]     = (REGISTERS_BASE + 0x0000),
-	[ACX_REG_EE_START]           = (REGISTERS_BASE + 0x080C),
-	[ACX_REG_ECPU_CONTROL]       = (REGISTERS_BASE + 0x0804)
-};
-
-static int wl1271_upload_firmware_chunk(struct wl12xx *wl, void *buf,
-					size_t fw_data_len, u32 dest)
-{
-	int addr, chunk_num, partition_limit;
-	u8 *p;
-
-	/* whal_FwCtrl_LoadFwImageSm() */
-
-	wl12xx_debug(DEBUG_BOOT, "starting firmware upload");
-
-	wl12xx_debug(DEBUG_BOOT, "fw_data_len %d chunk_size %d", fw_data_len,
-		CHUNK_SIZE);
-
-
-	if ((fw_data_len % 4) != 0) {
-		wl12xx_error("firmware length not multiple of four");
-		return -EIO;
-	}
-
-	wl12xx_set_partition(wl, dest,
-			     wl->chip.p_table[PART_DOWN].mem.size,
-			     wl->chip.p_table[PART_DOWN].reg.start,
-			     wl->chip.p_table[PART_DOWN].reg.size);
-
-	/* 10.1 set partition limit and chunk num */
-	chunk_num = 0;
-	partition_limit = wl->chip.p_table[PART_DOWN].mem.size;
-
-	while (chunk_num < fw_data_len / CHUNK_SIZE) {
-		/* 10.2 update partition, if needed */
-		addr = dest + (chunk_num + 2) * CHUNK_SIZE;
-		if (addr > partition_limit) {
-			addr = dest + chunk_num * CHUNK_SIZE;
-			partition_limit = chunk_num * CHUNK_SIZE +
-				wl->chip.p_table[PART_DOWN].mem.size;
-
-			/* FIXME: Over 80 chars! */
-			wl12xx_set_partition(wl,
-					     addr,
-					     wl->chip.p_table[PART_DOWN].mem.size,
-					     wl->chip.p_table[PART_DOWN].reg.start,
-					     wl->chip.p_table[PART_DOWN].reg.size);
-		}
-
-		/* 10.3 upload the chunk */
-		addr = dest + chunk_num * CHUNK_SIZE;
-		p = buf + chunk_num * CHUNK_SIZE;
-		wl12xx_debug(DEBUG_BOOT, "uploading fw chunk 0x%p to 0x%x",
-			     p, addr);
-		wl12xx_spi_mem_write(wl, addr, p, CHUNK_SIZE);
-
-		chunk_num++;
-	}
-
-	/* 10.4 upload the last chunk */
-	addr = dest + chunk_num * CHUNK_SIZE;
-	p = buf + chunk_num * CHUNK_SIZE;
-	wl12xx_debug(DEBUG_BOOT, "uploading fw last chunk (%d B) 0x%p to 0x%x",
-		     fw_data_len % CHUNK_SIZE, p, addr);
-	wl12xx_spi_mem_write(wl, addr, p, fw_data_len % CHUNK_SIZE);
-
-	return 0;
-}
-
-static int wl1271_upload_firmware(struct wl12xx *wl)
-{
-	u32 chunks, addr, len;
-	u8 *fw;
-
-	fw = wl->fw;
-	chunks = be32_to_cpup((u32 *) fw);
-	fw += sizeof(u32);
-
-	wl12xx_debug(DEBUG_BOOT, "firmware chunks to be uploaded: %u", chunks);
-
-	while (chunks--) {
-		addr = be32_to_cpup((u32 *) fw);
-		fw += sizeof(u32);
-		len = be32_to_cpup((u32 *) fw);
-		fw += sizeof(u32);
-
-		if (len > 300000) {
-			wl12xx_info("firmware chunk too long: %u", len);
-			return -EINVAL;
-		}
-		wl12xx_debug(DEBUG_BOOT, "chunk %d addr 0x%x len %u",
-			     chunks, addr, len);
-		wl1271_upload_firmware_chunk(wl, fw, len, addr);
-		fw += len;
-	}
-
-	return 0;
-}
-
-static int wl1271_upload_nvs(struct wl12xx *wl)
-{
-	size_t nvs_len, burst_len;
-	int i;
-	u32 dest_addr, val;
-	u8 *nvs_ptr, *nvs, *nvs_aligned;
-
-	nvs = wl->nvs;
-	if (nvs == NULL)
-		return -ENODEV;
-
-	nvs_ptr = nvs;
-
-	nvs_len = wl->nvs_len;
-
-	/*
-	 * Layout before the actual NVS tables:
-	 * 1 byte : burst length.
-	 * 2 bytes: destination address.
-	 * n bytes: data to burst copy.
-	 *
-	 * This is ended by a 0 length, then the NVS tables.
-	 */
-
-	/* FIXME: Do we need to check here whether the LSB is 1? */
-	while (nvs_ptr[0]) {
-		burst_len = nvs_ptr[0];
-		dest_addr = (nvs_ptr[1] & 0xfe) | ((u32)(nvs_ptr[2] << 8));
-
-		/* FIXME: Due to our new wl12xx_translate_reg_addr function,
-		   we need to add the REGISTER_BASE to the destination */
-		dest_addr += REGISTERS_BASE;
-
-		/* We move our pointer to the data */
-		nvs_ptr += 3;
-
-		for (i = 0; i < burst_len; i++) {
-			val = (nvs_ptr[0] | (nvs_ptr[1] << 8)
-			       | (nvs_ptr[2] << 16) | (nvs_ptr[3] << 24));
-
-			wl12xx_debug(DEBUG_BOOT,
-				     "nvs burst write 0x%x: 0x%x",
-				     dest_addr, val);
-			wl12xx_reg_write32(wl, dest_addr, val);
-
-			nvs_ptr += 4;
-			dest_addr += 4;
-		}
-	}
-
-	/*
-	 * We've reached the first zero length, the first NVS table
-	 * is 7 bytes further.
-	 */
-	nvs_ptr += 7;
-	nvs_len -= nvs_ptr - nvs;
-	nvs_len = ALIGN(nvs_len, 4);
-
-	/* FIXME: The driver sets the partition here, but this is not needed,
-	   since it sets to the same one as currently in use */
-	/* Now we must set the partition correctly */
-	wl12xx_set_partition(wl,
-			     wl->chip.p_table[PART_WORK].mem.start,
-			     wl->chip.p_table[PART_WORK].mem.size,
-			     wl->chip.p_table[PART_WORK].reg.start,
-			     wl->chip.p_table[PART_WORK].reg.size);
-
-	/* Copy the NVS tables to a new block to ensure alignment */
-	nvs_aligned = kmemdup(nvs_ptr, nvs_len, GFP_KERNEL);
-
-	/* And finally we upload the NVS tables */
-	/* FIXME: In wl1271, we upload everything at once.
-	   No endianness handling needed here?! The ref driver doesn't do
-	   anything about it at this point */
-	wl12xx_spi_mem_write(wl, CMD_MBOX_ADDRESS, nvs_aligned, nvs_len);
-
-	kfree(nvs_aligned);
-	return 0;
-}
-
-static int wl1271_boot(struct wl12xx *wl)
-{
-	int ret = 0;
-	u32 tmp, clk, pause;
-
-	if (REF_CLOCK == 0 || REF_CLOCK == 2)
-		/* ref clk: 19.2/38.4 */
-		clk = 0x3;
-	else if (REF_CLOCK == 1 || REF_CLOCK == 3)
-		/* ref clk: 26/52 */
-		clk = 0x5;
-
-	wl12xx_reg_write32(wl, PLL_PARAMETERS, clk);
-
-	pause = wl12xx_reg_read32(wl, PLL_PARAMETERS);
-
-	wl12xx_debug(DEBUG_BOOT, "pause1 0x%x", pause);
-
-	pause &= ~(WU_COUNTER_PAUSE_VAL); /* FIXME: This should probably be
-					   * WU_COUNTER_PAUSE_VAL instead of
-					   * 0x3ff (magic number ).  How does
-					   * this work?! */
-	pause |= WU_COUNTER_PAUSE_VAL;
-	wl12xx_reg_write32(wl, WU_COUNTER_PAUSE, pause);
-
-	/* Continue the ELP wake up sequence */
-	wl12xx_reg_write32(wl, WELP_ARM_COMMAND, WELP_ARM_COMMAND_VAL);
-	udelay(500);
-	/* FIXME: Magic numbers! Argh! */
-	wl12xx_reg_write32(wl, REGISTERS_BASE + 0x9b4, 0x30222);
-	wl12xx_reg_write32(wl, REGISTERS_BASE + 0x9b8, 0x201);
-	wl12xx_reg_write32(wl, REGISTERS_BASE + 0x9c0, 0x1);
-
-#define WORKAROUND_FOR_VNWA
-#ifdef WORKAROUND_FOR_VNWA
-	/*
-	 * workaround fix for VNWA control signal short with floating pin
-	 * in TRIO PMS The PRCM register address is 0x454 and the
-	 * prcm_dig_ldo_tload_en is bit 8. In order to write '1' to this
-	 * field do the following:
-	 *
-	 * write to 0x3009b4 -> 0x30000 | (0x454/2)
-	 *   - Address
-	 * write to 0x3009b8 -> 0x300
-	 *   - Data to be written (bit 8 is the fix and 9 is reset value)
-	 * write to 0x3009c0 -> 0x1
-	 */
-	wl12xx_reg_write32(wl, REGISTERS_BASE + 0x9b4, 0x3022a);
-	wl12xx_reg_write32(wl, REGISTERS_BASE + 0x9b8, 0x300);
-	wl12xx_reg_write32(wl, REGISTERS_BASE + 0x9c0, 0x1);
-#endif
-
-	wl12xx_set_partition(wl,
-			     wl->chip.p_table[PART_DRPW].mem.start,
-			     wl->chip.p_table[PART_DRPW].mem.size,
-			     wl->chip.p_table[PART_DRPW].reg.start,
-			     wl->chip.p_table[PART_DRPW].reg.size);
-
-	/* Read-modify-write DRPW_SCRATCH_START register (see next state)
-	   to be used by DRPw FW. The RTRIM value will be added by the FW
-	   before taking DRPw out of reset */
-
-	wl12xx_debug(DEBUG_BOOT, "DRPW_SCRATCH_START %08x", DRPW_SCRATCH_START);
-	clk = wl12xx_reg_read32(wl, DRPW_SCRATCH_START);
-
-	wl12xx_debug(DEBUG_BOOT, "clk2 0x%x", clk);
-
-	/* 2 */
-	clk |= (REF_CLOCK << 1) << 4;
-	wl12xx_reg_write32(wl, DRPW_SCRATCH_START, clk);
-
-	wl12xx_set_partition(wl,
-			     wl->chip.p_table[PART_WORK].mem.start,
-			     wl->chip.p_table[PART_WORK].mem.size,
-			     wl->chip.p_table[PART_WORK].reg.start,
-			     wl->chip.p_table[PART_WORK].reg.size);
-
-	/* Disable interrupts */
-	wl12xx_reg_write32(wl, ACX_REG_INTERRUPT_MASK, WL1271_ACX_INTR_ALL);
-
-	ret = wl12xx_boot_soft_reset(wl);
-	if (ret < 0)
-		goto out;
-
-	/* 2. start processing NVS file */
-	ret = wl->chip.op_upload_nvs(wl);
-	if (ret < 0)
-		goto out;
-
-	/* write firmware's last address (ie. it's length) to
-	 * ACX_EEPROMLESS_IND_REG */
-	wl12xx_debug(DEBUG_BOOT, "ACX_EEPROMLESS_IND_REG");
-
-	wl12xx_reg_write32(wl, ACX_EEPROMLESS_IND_REG, ACX_EEPROMLESS_IND_REG);
-
-	tmp = wl12xx_reg_read32(wl, CHIP_ID_B);
-
-	wl12xx_debug(DEBUG_BOOT, "chip id 0x%x", tmp);
-
-	/* 6. read the EEPROM parameters */
-	tmp = wl12xx_reg_read32(wl, SCR_PAD2);
-
-	/* WL1271: The reference driver skips steps 7 to 10 (jumps directly
-	 * to upload_fw) */
-
-	ret = wl->chip.op_upload_fw(wl);
-	if (ret < 0)
-		goto out;
-
-	/* 10.5 start firmware */
-	ret = wl12xx_boot_run_firmware(wl);
-	if (ret < 0)
-		goto out;
-
-out:
-	return ret;
-}
-
-static int wl1271_mem_cfg(struct wl12xx *wl)
-{
-	struct wl1271_acx_config_memory mem_conf;
-	int ret = 0;
-
-	wl12xx_debug(DEBUG_ACX, "wl1271 mem cfg");
-
-	/* memory config */
-	mem_conf.num_stations = cpu_to_le16(DEFAULT_NUM_STATIONS);
-	mem_conf.rx_mem_block_num = ACX_RX_MEM_BLOCKS;
-	mem_conf.tx_min_mem_block_num = ACX_TX_MIN_MEM_BLOCKS;
-	mem_conf.num_ssid_profiles = ACX_NUM_SSID_PROFILES;
-	mem_conf.total_tx_descriptors = ACX_TX_DESCRIPTORS;
-
-	mem_conf.header.id = ACX_MEM_CFG;
-	mem_conf.header.len = sizeof(struct wl1271_acx_config_memory) -
-		sizeof(struct acx_header);
-
-	ret = wl12xx_cmd_configure(wl, &mem_conf,
-				   sizeof(struct wl1271_acx_config_memory));
-	if (ret < 0)
-		wl12xx_warning("wl1271 mem config failed: %d", ret);
-
-	return ret;
-}
-
-static int wl1271_hw_init_mem_config(struct wl12xx *wl)
-{
-	int ret;
-
-	ret = wl1271_mem_cfg(wl);
-	if (ret < 0)
-		return ret;
-
-	wl->target_mem_map = kzalloc(sizeof(struct wl1271_acx_mem_map),
-					  GFP_KERNEL);
-	if (!wl->target_mem_map) {
-		wl12xx_error("couldn't allocate target memory map");
-		return -ENOMEM;
-	}
-
-	/* we now ask for the firmware built memory map */
-	ret = wl12xx_acx_mem_map(wl, wl->target_mem_map,
-				 sizeof(struct wl1271_acx_mem_map));
-	if (ret < 0) {
-		wl12xx_error("couldn't retrieve firmware memory map");
-		kfree(wl->target_mem_map);
-		wl->target_mem_map = NULL;
-		return ret;
-	}
-
-	return 0;
-}
-
-static int wl1271_hw_init_tx_interrupt(struct wl12xx *wl)
-{
-	struct wl1271_tx_config_opt tx_conf;
-	int ret = 0;
-
-	wl12xx_debug(DEBUG_ACX, "wl1271 tx interrupt config");
-
-	tx_conf.threshold = WL1271_TX_CMPLT_THRESHOLD_DEF;
-	tx_conf.timeout = WL1271_TX_CMPLT_TIMEOUT_DEF;
-
-	tx_conf.header.id = ACX_TX_CONFIG_OPT;
-	tx_conf.header.len = sizeof(struct wl1271_tx_config_opt) -
-		sizeof(struct acx_header);
-
-	ret = wl12xx_cmd_configure(wl, &tx_conf,
-				   sizeof(struct wl1271_tx_config_opt));
-	if (ret < 0)
-		wl12xx_warning("wl1271 tx config opt failed: %d", ret);
-
-	return ret;
-}
-
-static int wl1271_hw_init_rx_interrupt(struct wl12xx *wl)
-{
-	struct wl1271_rx_config_opt rx_conf;
-	int ret = 0;
-
-	wl12xx_debug(DEBUG_ACX, "wl1271 rx interrupt config");
-
-	rx_conf.threshold = WL1271_RX_INTR_THRESHOLD_DEF;
-	rx_conf.timeout = WL1271_RX_INTR_TIMEOUT_DEF;
-	rx_conf.mblk_threshold = USHORT_MAX; /* Disabled */
-	rx_conf.queue_type = RX_QUEUE_TYPE_RX_LOW_PRIORITY;
-
-	rx_conf.header.id = ACX_RX_CONFIG_OPT;
-	rx_conf.header.len = sizeof(struct wl1271_rx_config_opt) -
-		sizeof(struct acx_header);
-
-	ret = wl12xx_cmd_configure(wl, &rx_conf,
-				   sizeof(struct wl1271_rx_config_opt));
-	if (ret < 0)
-		wl12xx_warning("wl1271 rx config opt failed: %d", ret);
-
-	return ret;
-}
-
-static void wl1271_set_ecpu_ctrl(struct wl12xx *wl, u32 flag)
-{
-	u32 cpu_ctrl;
-
-	/* 10.5.0 run the firmware (I) */
-	cpu_ctrl = wl12xx_reg_read32(wl, ACX_REG_ECPU_CONTROL);
-
-	/* 10.5.1 run the firmware (II) */
-	cpu_ctrl |= flag;
-	wl12xx_reg_write32(wl, ACX_REG_ECPU_CONTROL, cpu_ctrl);
-}
-
-static void wl1271_target_enable_interrupts(struct wl12xx *wl)
-{
-	/* Enable target's interrupts */
-	wl->intr_mask = WL1271_ACX_INTR_CMD_COMPLETE |
-		WL1271_ACX_INTR_EVENT_A |
-		WL1271_ACX_INTR_EVENT_B;
-	wl12xx_boot_target_enable_interrupts(wl);
-}
-
-static void wl1271_irq_work(struct work_struct *work)
-{
-	wl12xx_debug(DEBUG_IRQ, "IRQ work -- not implemented yet");
-}
-
-static int wl1271_hw_init(struct wl12xx *wl)
-{
-	int ret;
-	struct wl1271_acx_mem_map *wl_mem_map;
-
-	ret = wl12xx_hw_init_hwenc_config(wl);
-	if (ret < 0)
-		return ret;
-
-	/* Template settings */
-	ret = wl12xx_hw_init_templates_config(wl);
-	if (ret < 0)
-		return ret;
-
-	/* Default memory configuration */
-	ret = wl1271_hw_init_mem_config(wl);
-	if (ret < 0)
-		return ret;
-
-	/* RX config */
-	ret = wl12xx_hw_init_rx_config(wl,
-				       RX_CFG_PROMISCUOUS | RX_CFG_TSF,
-				       RX_FILTER_OPTION_DEF);
-	/* RX_CONFIG_OPTION_ANY_DST_ANY_BSS,
-	   RX_FILTER_OPTION_FILTER_ALL); */
-	if (ret < 0)
-		goto out_free_memmap;
-
-	/* PHY layer config */
-	ret = wl12xx_hw_init_phy_config(wl);
-	if (ret < 0)
-		goto out_free_memmap;
-
-	/* Beacon filtering */
-	ret = wl12xx_hw_init_beacon_filter(wl);
-	if (ret < 0)
-		goto out_free_memmap;
-
-	/* TX complete interrupt pacing */
-	ret = wl1271_hw_init_tx_interrupt(wl);
-	if (ret < 0)
-		goto out_free_memmap;
-
-	/* RX complete interrupt pacing */
-	ret = wl1271_hw_init_rx_interrupt(wl);
-	if (ret < 0)
-		goto out_free_memmap;
-
-	/* Bluetooth WLAN coexistence */
-	ret = wl12xx_hw_init_pta(wl);
-	if (ret < 0)
-		goto out_free_memmap;
-
-	/* Energy detection */
-	ret = wl12xx_hw_init_energy_detection(wl);
-	if (ret < 0)
-		goto out_free_memmap;
-
-	/* Beacons and boradcast settings */
-	ret = wl12xx_hw_init_beacon_broadcast(wl);
-	if (ret < 0)
-		goto out_free_memmap;
-
-	/* Enable data path */
-	ret = wl12xx_cmd_data_path(wl, wl->channel, 1);
-	if (ret < 0)
-		goto out_free_memmap;
-
-	/* Default power state */
-	ret = wl12xx_hw_init_power_auth(wl);
-	if (ret < 0)
-		goto out_free_memmap;
-
-	wl_mem_map = wl->target_mem_map;
-
-	return 0;
-
- out_free_memmap:
-	kfree(wl->target_mem_map);
-
-	return ret;
-}
-
-static int wl1271_plt_init(struct wl12xx *wl)
-{
-	int ret;
-
-	ret = wl1271_hw_init_mem_config(wl);
-	if (ret < 0)
-		return ret;
-
-	ret = wl12xx_cmd_data_path(wl, wl->channel, 1);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-void wl1271_setup(struct wl12xx *wl)
-{
-	/* FIXME: Is it better to use strncpy here or is this ok? */
-	wl->chip.fw_filename = WL1271_FW_NAME;
-	wl->chip.nvs_filename = WL1271_NVS_NAME;
-
-	/* Now we know what chip we're using, so adjust the power on sleep
-	 * time accordingly */
-	wl->chip.power_on_sleep = WL1271_POWER_ON_SLEEP;
-
-	wl->chip.intr_cmd_complete = WL1271_ACX_INTR_CMD_COMPLETE;
-	wl->chip.intr_init_complete = WL1271_ACX_INTR_INIT_COMPLETE;
-
-	wl->chip.op_upload_nvs = wl1271_upload_nvs;
-	wl->chip.op_upload_fw = wl1271_upload_firmware;
-	wl->chip.op_boot = wl1271_boot;
-	wl->chip.op_set_ecpu_ctrl = wl1271_set_ecpu_ctrl;
-	wl->chip.op_target_enable_interrupts = wl1271_target_enable_interrupts;
-	wl->chip.op_hw_init = wl1271_hw_init;
-	wl->chip.op_plt_init = wl1271_plt_init;
-
-	wl->chip.p_table = wl1271_part_table;
-	wl->chip.acx_reg_table = wl1271_acx_reg_table;
-
-	INIT_WORK(&wl->irq_work, wl1271_irq_work);
-}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_cmd.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_cmd.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_cmd.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_cmd.c	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,813 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/crc7.h>
+#include <linux/spi/spi.h>
+#include <linux/etherdevice.h>
+
+#include "wl1271.h"
+#include "wl1271_reg.h"
+#include "wl1271_spi.h"
+#include "wl1271_acx.h"
+#include "wl12xx_80211.h"
+#include "wl1271_cmd.h"
+
+/*
+ * send command to firmware
+ *
+ * @wl: wl struct
+ * @id: command id
+ * @buf: buffer containing the command, must work with dma
+ * @len: length of the buffer
+ */
+int wl1271_cmd_send(struct wl1271 *wl, u16 id, void *buf, size_t len)
+{
+	struct wl1271_cmd_header *cmd;
+	unsigned long timeout;
+	u32 intr;
+	int ret = 0;
+
+	cmd = buf;
+	cmd->id = id;
+	cmd->status = 0;
+
+	WARN_ON(len % 4 != 0);
+
+	wl1271_spi_mem_write(wl, wl->cmd_box_addr, buf, len);
+
+	wl1271_reg_write32(wl, ACX_REG_INTERRUPT_TRIG, INTR_TRIG_CMD);
+
+	timeout = jiffies + msecs_to_jiffies(WL1271_COMMAND_TIMEOUT);
+
+	intr = wl1271_reg_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);
+	while (!(intr & WL1271_ACX_INTR_CMD_COMPLETE)) {
+		if (time_after(jiffies, timeout)) {
+			wl1271_error("command complete timeout");
+			ret = -ETIMEDOUT;
+			goto out;
+		}
+
+		msleep(1);
+
+		intr = wl1271_reg_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);
+	}
+
+	wl1271_reg_write32(wl, ACX_REG_INTERRUPT_ACK,
+			   WL1271_ACX_INTR_CMD_COMPLETE);
+
+out:
+	return ret;
+}
+
+int wl1271_cmd_cal_channel_tune(struct wl1271 *wl)
+{
+	struct wl1271_cmd_cal_channel_tune *cmd;
+	int ret = 0;
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	cmd->test.id = TEST_CMD_CHANNEL_TUNE;
+
+	cmd->band = WL1271_CHANNEL_TUNE_BAND_2_4;
+	/* set up any channel, 7 is in the middle of the range */
+	cmd->channel = 7;
+
+	ret = wl1271_cmd_test(wl, cmd, sizeof(*cmd), 0);
+	if (ret < 0)
+		wl1271_warning("TEST_CMD_CHANNEL_TUNE failed");
+
+	kfree(cmd);
+	return ret;
+}
+
+int wl1271_cmd_cal_update_ref_point(struct wl1271 *wl)
+{
+	struct wl1271_cmd_cal_update_ref_point *cmd;
+	int ret = 0;
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	cmd->test.id = TEST_CMD_UPDATE_PD_REFERENCE_POINT;
+
+	/* FIXME: still waiting for the correct values */
+	cmd->ref_power    = 0;
+	cmd->ref_detector = 0;
+
+	cmd->sub_band     = WL1271_PD_REFERENCE_POINT_BAND_B_G;
+
+	ret = wl1271_cmd_test(wl, cmd, sizeof(*cmd), 0);
+	if (ret < 0)
+		wl1271_warning("TEST_CMD_UPDATE_PD_REFERENCE_POINT failed");
+
+	kfree(cmd);
+	return ret;
+}
+
+int wl1271_cmd_cal_p2g(struct wl1271 *wl)
+{
+	struct wl1271_cmd_cal_p2g *cmd;
+	int ret = 0;
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	cmd->test.id = TEST_CMD_P2G_CAL;
+
+	cmd->sub_band_mask = WL1271_CAL_P2G_BAND_B_G;
+
+	ret = wl1271_cmd_test(wl, cmd, sizeof(*cmd), 0);
+	if (ret < 0)
+		wl1271_warning("TEST_CMD_P2G_CAL failed");
+
+	kfree(cmd);
+	return ret;
+}
+
+int wl1271_cmd_cal(struct wl1271 *wl)
+{
+	/*
+	 * FIXME: we must make sure that we're not sleeping when calibration
+	 * is done
+	 */
+	int ret;
+
+	wl1271_notice("performing tx calibration");
+
+	ret = wl1271_cmd_cal_channel_tune(wl);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_cmd_cal_update_ref_point(wl);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_cmd_cal_p2g(wl);
+	if (ret < 0)
+		return ret;
+
+	return ret;
+}
+
+int wl1271_cmd_join(struct wl1271 *wl, u8 bss_type, u8 dtim_interval,
+		    u16 beacon_interval, u8 wait)
+{
+	static bool do_cal = true;
+	unsigned long timeout;
+	struct wl1271_cmd_join *join;
+	int ret, i;
+	u8 *bssid;
+
+	/* FIXME: remove when we get calibration from the factory */
+	if (do_cal) {
+		ret = wl1271_cmd_cal(wl);
+		if (ret < 0)
+			wl1271_warning("couldn't calibrate");
+		else
+			do_cal = false;
+	}
+
+
+	join = kzalloc(sizeof(*join), GFP_KERNEL);
+	if (!join) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	wl1271_debug(DEBUG_CMD, "cmd join");
+
+	/* Reverse order BSSID */
+	bssid = (u8 *) &join->bssid_lsb;
+	for (i = 0; i < ETH_ALEN; i++)
+		bssid[i] = wl->bssid[ETH_ALEN - i - 1];
+
+	join->rx_config_options = wl->rx_config;
+	join->rx_filter_options = wl->rx_filter;
+
+	join->basic_rate_set = RATE_MASK_1MBPS | RATE_MASK_2MBPS |
+		RATE_MASK_5_5MBPS | RATE_MASK_11MBPS;
+
+	join->beacon_interval = beacon_interval;
+	join->dtim_interval = dtim_interval;
+	join->bss_type = bss_type;
+	join->channel = wl->channel;
+	join->ssid_len = wl->ssid_len;
+	memcpy(join->ssid, wl->ssid, wl->ssid_len);
+	join->ctrl = WL1271_JOIN_CMD_CTRL_TX_FLUSH;
+
+	/* increment the session counter */
+	wl->session_counter++;
+	if (wl->session_counter >= SESSION_COUNTER_MAX)
+		wl->session_counter = 0;
+
+	join->ctrl |= wl->session_counter << WL1271_JOIN_CMD_TX_SESSION_OFFSET;
+
+
+	ret = wl1271_cmd_send(wl, CMD_START_JOIN, join, sizeof(*join));
+	if (ret < 0) {
+		wl1271_error("failed to initiate cmd join");
+		goto out_free;
+	}
+
+	timeout = msecs_to_jiffies(JOIN_TIMEOUT);
+
+	/*
+	 * ugly hack: we should wait for JOIN_EVENT_COMPLETE_ID but to
+	 * simplify locking we just sleep instead, for now
+	 */
+	if (wait)
+		msleep(10);
+
+out_free:
+	kfree(join);
+
+out:
+	return ret;
+}
+
+/**
+ * send test command to firmware
+ *
+ * @wl: wl struct
+ * @buf: buffer containing the command, with all headers, must work with dma
+ * @len: length of the buffer
+ * @answer: is answer needed
+ */
+int wl1271_cmd_test(struct wl1271 *wl, void *buf, size_t buf_len, u8 answer)
+{
+	int ret;
+
+	wl1271_debug(DEBUG_CMD, "cmd test");
+
+	ret = wl1271_cmd_send(wl, CMD_TEST, buf, buf_len);
+
+	if (ret < 0) {
+		wl1271_warning("TEST command failed");
+		return ret;
+	}
+
+	if (answer) {
+		struct wl1271_command *cmd_answer;
+
+		/*
+		 * The test command got in, we can read the answer.
+		 * The answer would be a wl1271_command, where the
+		 * parameter array contains the actual answer.
+		 */
+		wl1271_spi_mem_read(wl, wl->cmd_box_addr, buf, buf_len);
+
+		cmd_answer = buf;
+
+		if (cmd_answer->header.status != CMD_STATUS_SUCCESS)
+			wl1271_error("TEST command answer error: %d",
+				     cmd_answer->header.status);
+	}
+
+	return 0;
+}
+
+/**
+ * read acx from firmware
+ *
+ * @wl: wl struct
+ * @id: acx id
+ * @buf: buffer for the response, including all headers, must work with dma
+ * @len: lenght of buf
+ */
+int wl1271_cmd_interrogate(struct wl1271 *wl, u16 id, void *buf, size_t len)
+{
+	struct acx_header *acx = buf;
+	int ret;
+
+	wl1271_debug(DEBUG_CMD, "cmd interrogate");
+
+	acx->id = id;
+
+	/* payload length, does not include any headers */
+	acx->len = len - sizeof(*acx);
+
+	ret = wl1271_cmd_send(wl, CMD_INTERROGATE, acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1271_error("INTERROGATE command failed");
+		goto out;
+	}
+
+	/* the interrogate command got in, we can read the answer */
+	wl1271_spi_mem_read(wl, wl->cmd_box_addr, buf, len);
+
+	acx = buf;
+	if (acx->cmd.status != CMD_STATUS_SUCCESS)
+		wl1271_error("INTERROGATE command error: %d",
+			     acx->cmd.status);
+
+out:
+	return ret;
+}
+
+/**
+ * write acx value to firmware
+ *
+ * @wl: wl struct
+ * @id: acx id
+ * @buf: buffer containing acx, including all headers, must work with dma
+ * @len: length of buf
+ */
+int wl1271_cmd_configure(struct wl1271 *wl, u16 id, void *buf, size_t len)
+{
+	struct acx_header *acx = buf;
+	int ret;
+
+	wl1271_debug(DEBUG_CMD, "cmd configure");
+
+	acx->id = id;
+
+	/* payload length, does not include any headers */
+	acx->len = len - sizeof(*acx);
+
+	ret = wl1271_cmd_send(wl, CMD_CONFIGURE, acx, len);
+	if (ret < 0) {
+		wl1271_warning("CONFIGURE command NOK");
+		return ret;
+	}
+
+	return 0;
+}
+
+int wl1271_cmd_data_path(struct wl1271 *wl, u8 channel, bool enable)
+{
+	struct cmd_enabledisable_path *cmd;
+	int ret;
+	u16 cmd_rx, cmd_tx;
+
+	wl1271_debug(DEBUG_CMD, "cmd data path");
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (!cmd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	cmd->channel = channel;
+
+	if (enable) {
+		cmd_rx = CMD_ENABLE_RX;
+		cmd_tx = CMD_ENABLE_TX;
+	} else {
+		cmd_rx = CMD_DISABLE_RX;
+		cmd_tx = CMD_DISABLE_TX;
+	}
+
+	ret = wl1271_cmd_send(wl, cmd_rx, cmd, sizeof(*cmd));
+	if (ret < 0) {
+		wl1271_error("rx %s cmd for channel %d failed",
+			     enable ? "start" : "stop", channel);
+		goto out;
+	}
+
+	wl1271_debug(DEBUG_BOOT, "rx %s cmd channel %d",
+		     enable ? "start" : "stop", channel);
+
+	ret = wl1271_cmd_send(wl, cmd_tx, cmd, sizeof(*cmd));
+	if (ret < 0) {
+		wl1271_error("tx %s cmd for channel %d failed",
+			     enable ? "start" : "stop", channel);
+		return ret;
+	}
+
+	wl1271_debug(DEBUG_BOOT, "tx %s cmd channel %d",
+		     enable ? "start" : "stop", channel);
+
+out:
+	kfree(cmd);
+	return ret;
+}
+
+int wl1271_cmd_ps_mode(struct wl1271 *wl, u8 ps_mode)
+{
+	struct wl1271_cmd_ps_params *ps_params = NULL;
+	int ret = 0;
+
+	/* FIXME: this should be in ps.c */
+	ret = wl1271_acx_wake_up_conditions(wl, WAKE_UP_EVENT_DTIM_BITMAP,
+					    wl->listen_int);
+	if (ret < 0) {
+		wl1271_error("couldn't set wake up conditions");
+		goto out;
+	}
+
+	wl1271_debug(DEBUG_CMD, "cmd set ps mode");
+
+	ps_params = kzalloc(sizeof(*ps_params), GFP_KERNEL);
+	if (!ps_params) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ps_params->ps_mode = ps_mode;
+	ps_params->send_null_data = 1;
+	ps_params->retries = 5;
+	ps_params->hang_over_period = 128;
+	ps_params->null_data_rate = 1; /* 1 Mbps */
+
+	ret = wl1271_cmd_send(wl, CMD_SET_PS_MODE, ps_params,
+			      sizeof(*ps_params));
+	if (ret < 0) {
+		wl1271_error("cmd set_ps_mode failed");
+		goto out;
+	}
+
+out:
+	kfree(ps_params);
+	return ret;
+}
+
+int wl1271_cmd_read_memory(struct wl1271 *wl, u32 addr, void *answer,
+			   size_t len)
+{
+	struct cmd_read_write_memory *cmd;
+	int ret = 0;
+
+	wl1271_debug(DEBUG_CMD, "cmd read memory");
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (!cmd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	WARN_ON(len > MAX_READ_SIZE);
+	len = min_t(size_t, len, MAX_READ_SIZE);
+
+	cmd->addr = addr;
+	cmd->size = len;
+
+	ret = wl1271_cmd_send(wl, CMD_READ_MEMORY, cmd, sizeof(*cmd));
+	if (ret < 0) {
+		wl1271_error("read memory command failed: %d", ret);
+		goto out;
+	}
+
+	/* the read command got in, we can now read the answer */
+	wl1271_spi_mem_read(wl, wl->cmd_box_addr, cmd, sizeof(*cmd));
+
+	if (cmd->header.status != CMD_STATUS_SUCCESS)
+		wl1271_error("error in read command result: %d",
+			     cmd->header.status);
+
+	memcpy(answer, cmd->value, len);
+
+out:
+	kfree(cmd);
+	return ret;
+}
+
+int wl1271_cmd_scan(struct wl1271 *wl, u8 *ssid, size_t len,
+		    u8 active_scan, u8 high_prio, u8 num_channels,
+		    u8 probe_requests)
+{
+
+	struct wl1271_cmd_trigger_scan_to *trigger = NULL;
+	struct wl1271_cmd_scan *params = NULL;
+	int i, ret;
+	u16 scan_options = 0;
+
+	if (wl->scanning)
+		return -EINVAL;
+
+	params = kzalloc(sizeof(*params), GFP_KERNEL);
+	if (!params)
+		return -ENOMEM;
+
+	params->params.rx_config_options = cpu_to_le32(CFG_RX_ALL_GOOD);
+	params->params.rx_filter_options =
+		cpu_to_le32(CFG_RX_PRSP_EN | CFG_RX_MGMT_EN | CFG_RX_BCN_EN);
+
+	if (!active_scan)
+		scan_options |= WL1271_SCAN_OPT_PASSIVE;
+	if (high_prio)
+		scan_options |= WL1271_SCAN_OPT_PRIORITY_HIGH;
+	params->params.scan_options = scan_options;
+
+	params->params.num_channels = num_channels;
+	params->params.num_probe_requests = probe_requests;
+	params->params.tx_rate = cpu_to_le32(RATE_MASK_2MBPS);
+	params->params.tid_trigger = 0;
+	params->params.scan_tag = WL1271_SCAN_DEFAULT_TAG;
+
+	for (i = 0; i < num_channels; i++) {
+		params->channels[i].min_duration =
+			cpu_to_le32(WL1271_SCAN_CHAN_MIN_DURATION);
+		params->channels[i].max_duration =
+			cpu_to_le32(WL1271_SCAN_CHAN_MAX_DURATION);
+		memset(&params->channels[i].bssid_lsb, 0xff, 4);
+		memset(&params->channels[i].bssid_msb, 0xff, 2);
+		params->channels[i].early_termination = 0;
+		params->channels[i].tx_power_att = WL1271_SCAN_CURRENT_TX_PWR;
+		params->channels[i].channel = i + 1;
+	}
+
+	if (len && ssid) {
+		params->params.ssid_len = len;
+		memcpy(params->params.ssid, ssid, len);
+	}
+
+	ret = wl1271_cmd_build_probe_req(wl, ssid, len);
+	if (ret < 0) {
+		wl1271_error("PROBE request template failed");
+		goto out;
+	}
+
+	trigger = kzalloc(sizeof(*trigger), GFP_KERNEL);
+	if (!trigger) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* disable the timeout */
+	trigger->timeout = 0;
+
+	ret = wl1271_cmd_send(wl, CMD_TRIGGER_SCAN_TO, trigger,
+			      sizeof(*trigger));
+	if (ret < 0) {
+		wl1271_error("trigger scan to failed for hw scan");
+		goto out;
+	}
+
+	wl1271_dump(DEBUG_SCAN, "SCAN: ", params, sizeof(*params));
+
+	wl->scanning = true;
+
+	ret = wl1271_cmd_send(wl, CMD_SCAN, params, sizeof(*params));
+	if (ret < 0) {
+		wl1271_error("SCAN failed");
+		goto out;
+	}
+
+	wl1271_spi_mem_read(wl, wl->cmd_box_addr, params, sizeof(*params));
+
+	if (params->header.status != CMD_STATUS_SUCCESS) {
+		wl1271_error("Scan command error: %d",
+			     params->header.status);
+		wl->scanning = false;
+		ret = -EIO;
+		goto out;
+	}
+
+out:
+	kfree(params);
+	return ret;
+}
+
+int wl1271_cmd_template_set(struct wl1271 *wl, u16 template_id,
+			    void *buf, size_t buf_len)
+{
+	struct wl1271_cmd_template_set *cmd;
+	int ret = 0;
+
+	wl1271_debug(DEBUG_CMD, "cmd template_set %d", template_id);
+
+	WARN_ON(buf_len > WL1271_CMD_TEMPL_MAX_SIZE);
+	buf_len = min_t(size_t, buf_len, WL1271_CMD_TEMPL_MAX_SIZE);
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (!cmd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	cmd->len = cpu_to_le16(buf_len);
+	cmd->template_type = template_id;
+	cmd->enabled_rates = ACX_RATE_MASK_UNSPECIFIED;
+	cmd->short_retry_limit = ACX_RATE_RETRY_LIMIT;
+	cmd->long_retry_limit = ACX_RATE_RETRY_LIMIT;
+
+	if (buf)
+		memcpy(cmd->template_data, buf, buf_len);
+
+	ret = wl1271_cmd_send(wl, CMD_SET_TEMPLATE, cmd, sizeof(*cmd));
+	if (ret < 0) {
+		wl1271_warning("cmd set_template failed: %d", ret);
+		goto out_free;
+	}
+
+out_free:
+	kfree(cmd);
+
+out:
+	return ret;
+}
+
+static int wl1271_build_basic_rates(char *rates)
+{
+	u8 index = 0;
+
+	rates[index++] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_1MB;
+	rates[index++] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_2MB;
+	rates[index++] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_5MB;
+	rates[index++] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_11MB;
+
+	return index;
+}
+
+static int wl1271_build_extended_rates(char *rates)
+{
+	u8 index = 0;
+
+	rates[index++] = IEEE80211_OFDM_RATE_6MB;
+	rates[index++] = IEEE80211_OFDM_RATE_9MB;
+	rates[index++] = IEEE80211_OFDM_RATE_12MB;
+	rates[index++] = IEEE80211_OFDM_RATE_18MB;
+	rates[index++] = IEEE80211_OFDM_RATE_24MB;
+	rates[index++] = IEEE80211_OFDM_RATE_36MB;
+	rates[index++] = IEEE80211_OFDM_RATE_48MB;
+	rates[index++] = IEEE80211_OFDM_RATE_54MB;
+
+	return index;
+}
+
+int wl1271_cmd_build_null_data(struct wl1271 *wl)
+{
+	struct wl12xx_null_data_template template;
+
+	if (!is_zero_ether_addr(wl->bssid)) {
+		memcpy(template.header.da, wl->bssid, ETH_ALEN);
+		memcpy(template.header.bssid, wl->bssid, ETH_ALEN);
+	} else {
+		memset(template.header.da, 0xff, ETH_ALEN);
+		memset(template.header.bssid, 0xff, ETH_ALEN);
+	}
+
+	memcpy(template.header.sa, wl->mac_addr, ETH_ALEN);
+	template.header.frame_ctl = cpu_to_le16(IEEE80211_FTYPE_DATA |
+						IEEE80211_STYPE_NULLFUNC);
+
+	return wl1271_cmd_template_set(wl, CMD_TEMPL_NULL_DATA, &template,
+				       sizeof(template));
+
+}
+
+int wl1271_cmd_build_ps_poll(struct wl1271 *wl, u16 aid)
+{
+	struct wl12xx_ps_poll_template template;
+
+	memcpy(template.bssid, wl->bssid, ETH_ALEN);
+	memcpy(template.ta, wl->mac_addr, ETH_ALEN);
+	template.aid = aid;
+	template.fc = cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_PSPOLL);
+
+	return wl1271_cmd_template_set(wl, CMD_TEMPL_PS_POLL, &template,
+				       sizeof(template));
+
+}
+
+int wl1271_cmd_build_probe_req(struct wl1271 *wl, u8 *ssid, size_t ssid_len)
+{
+	struct wl12xx_probe_req_template template;
+	struct wl12xx_ie_rates *rates;
+	char *ptr;
+	u16 size;
+
+	ptr = (char *)&template;
+	size = sizeof(struct ieee80211_header);
+
+	memset(template.header.da, 0xff, ETH_ALEN);
+	memset(template.header.bssid, 0xff, ETH_ALEN);
+	memcpy(template.header.sa, wl->mac_addr, ETH_ALEN);
+	template.header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_PROBE_REQ);
+
+	/* IEs */
+	/* SSID */
+	template.ssid.header.id = WLAN_EID_SSID;
+	template.ssid.header.len = ssid_len;
+	if (ssid_len && ssid)
+		memcpy(template.ssid.ssid, ssid, ssid_len);
+	size += sizeof(struct wl12xx_ie_header) + ssid_len;
+	ptr += size;
+
+	/* Basic Rates */
+	rates = (struct wl12xx_ie_rates *)ptr;
+	rates->header.id = WLAN_EID_SUPP_RATES;
+	rates->header.len = wl1271_build_basic_rates(rates->rates);
+	size += sizeof(struct wl12xx_ie_header) + rates->header.len;
+	ptr += sizeof(struct wl12xx_ie_header) + rates->header.len;
+
+	/* Extended rates */
+	rates = (struct wl12xx_ie_rates *)ptr;
+	rates->header.id = WLAN_EID_EXT_SUPP_RATES;
+	rates->header.len = wl1271_build_extended_rates(rates->rates);
+	size += sizeof(struct wl12xx_ie_header) + rates->header.len;
+
+	wl1271_dump(DEBUG_SCAN, "PROBE REQ: ", &template, size);
+
+	return wl1271_cmd_template_set(wl, CMD_TEMPL_CFG_PROBE_REQ_2_4,
+				       &template, size);
+}
+
+int wl1271_cmd_set_default_wep_key(struct wl1271 *wl, u8 id)
+{
+	struct wl1271_cmd_set_keys *cmd;
+	int ret = 0;
+
+	wl1271_debug(DEBUG_CMD, "cmd set_default_wep_key %d", id);
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (!cmd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	cmd->id = id;
+	cmd->key_action = KEY_SET_ID;
+	cmd->key_type = KEY_WEP;
+
+	ret = wl1271_cmd_send(wl, CMD_SET_KEYS, cmd, sizeof(*cmd));
+	if (ret < 0) {
+		wl1271_warning("cmd set_default_wep_key failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(cmd);
+
+	return ret;
+}
+
+int wl1271_cmd_set_key(struct wl1271 *wl, u16 action, u8 id, u8 key_type,
+		       u8 key_size, const u8 *key, const u8 *addr)
+{
+	struct wl1271_cmd_set_keys *cmd;
+	int ret = 0;
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (!cmd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (key_type != KEY_WEP)
+		memcpy(cmd->addr, addr, ETH_ALEN);
+
+	cmd->key_action = action;
+	cmd->key_size = key_size;
+	cmd->key_type = key_type;
+
+	/* we have only one SSID profile */
+	cmd->ssid_profile = 0;
+
+	cmd->id = id;
+
+	/* FIXME: this is from wl1251, needs to be checked */
+	if (key_type == KEY_TKIP) {
+		/*
+		 * We get the key in the following form:
+		 * TKIP (16 bytes) - TX MIC (8 bytes) - RX MIC (8 bytes)
+		 * but the target is expecting:
+		 * TKIP - RX MIC - TX MIC
+		 */
+		memcpy(cmd->key, key, 16);
+		memcpy(cmd->key + 16, key + 24, 8);
+		memcpy(cmd->key + 24, key + 16, 8);
+
+	} else {
+		memcpy(cmd->key, key, key_size);
+	}
+
+	wl1271_dump(DEBUG_CRYPT, "TARGET KEY: ", cmd, sizeof(*cmd));
+
+	ret = wl1271_cmd_send(wl, CMD_SET_KEYS, cmd, sizeof(*cmd));
+	if (ret < 0) {
+		wl1271_warning("could not set keys");
+		goto out;
+	}
+
+out:
+	kfree(cmd);
+
+	return ret;
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_cmd.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_cmd.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_cmd.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_cmd.h	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,463 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __WL1271_CMD_H__
+#define __WL1271_CMD_H__
+
+#include "wl1271.h"
+
+struct acx_header;
+
+int wl1271_cmd_send(struct wl1271 *wl, u16 type, void *buf, size_t buf_len);
+int wl1271_cmd_join(struct wl1271 *wl, u8 bss_type, u8 dtim_interval,
+		    u16 beacon_interval, u8 wait);
+int wl1271_cmd_test(struct wl1271 *wl, void *buf, size_t buf_len, u8 answer);
+int wl1271_cmd_interrogate(struct wl1271 *wl, u16 id, void *buf, size_t len);
+int wl1271_cmd_configure(struct wl1271 *wl, u16 id, void *buf, size_t len);
+int wl1271_cmd_data_path(struct wl1271 *wl, u8 channel, bool enable);
+int wl1271_cmd_ps_mode(struct wl1271 *wl, u8 ps_mode);
+int wl1271_cmd_read_memory(struct wl1271 *wl, u32 addr, void *answer,
+			   size_t len);
+int wl1271_cmd_scan(struct wl1271 *wl, u8 *ssid, size_t len,
+		    u8 active_scan, u8 high_prio, u8 num_channels,
+		    u8 probe_requests);
+int wl1271_cmd_template_set(struct wl1271 *wl, u16 template_id,
+			    void *buf, size_t buf_len);
+int wl1271_cmd_build_null_data(struct wl1271 *wl);
+int wl1271_cmd_build_ps_poll(struct wl1271 *wl, u16 aid);
+int wl1271_cmd_build_probe_req(struct wl1271 *wl, u8 *ssid, size_t ssid_len);
+int wl1271_cmd_set_default_wep_key(struct wl1271 *wl, u8 id);
+int wl1271_cmd_set_key(struct wl1271 *wl, u16 action, u8 id, u8 key_type,
+		       u8 key_size, const u8 *key, const u8 *addr);
+
+enum wl1271_commands {
+	CMD_INTERROGATE     = 1,    /*use this to read information elements*/
+	CMD_CONFIGURE       = 2,    /*use this to write information elements*/
+	CMD_ENABLE_RX       = 3,
+	CMD_ENABLE_TX       = 4,
+	CMD_DISABLE_RX      = 5,
+	CMD_DISABLE_TX      = 6,
+	CMD_SCAN            = 8,
+	CMD_STOP_SCAN       = 9,
+	CMD_START_JOIN      = 11,
+	CMD_SET_KEYS        = 12,
+	CMD_READ_MEMORY     = 13,
+	CMD_WRITE_MEMORY    = 14,
+	CMD_SET_TEMPLATE    = 19,
+	CMD_TEST            = 23,
+	CMD_NOISE_HIST      = 28,
+	CMD_LNA_CONTROL     = 32,
+	CMD_SET_BCN_MODE    = 33,
+	CMD_MEASUREMENT      = 34,
+	CMD_STOP_MEASUREMENT = 35,
+	CMD_DISCONNECT       = 36,
+	CMD_SET_PS_MODE      = 37,
+	CMD_CHANNEL_SWITCH   = 38,
+	CMD_STOP_CHANNEL_SWICTH = 39,
+	CMD_AP_DISCOVERY     = 40,
+	CMD_STOP_AP_DISCOVERY = 41,
+	CMD_SPS_SCAN = 42,
+	CMD_STOP_SPS_SCAN = 43,
+	CMD_HEALTH_CHECK     = 45,
+	CMD_DEBUG            = 46,
+	CMD_TRIGGER_SCAN_TO  = 47,
+	CMD_CONNECTION_SCAN_CFG      = 48,
+	CMD_CONNECTION_SCAN_SSID_CFG = 49,
+	CMD_START_PERIODIC_SCAN      = 50,
+	CMD_STOP_PERIODIC_SCAN       = 51,
+	CMD_SET_STA_STATE            = 52,
+
+	NUM_COMMANDS,
+	MAX_COMMAND_ID = 0xFFFF,
+};
+
+#define MAX_CMD_PARAMS 572
+
+enum cmd_templ {
+	CMD_TEMPL_NULL_DATA = 0,
+	CMD_TEMPL_BEACON,
+	CMD_TEMPL_CFG_PROBE_REQ_2_4,
+	CMD_TEMPL_CFG_PROBE_REQ_5,
+	CMD_TEMPL_PROBE_RESPONSE,
+	CMD_TEMPL_QOS_NULL_DATA,
+	CMD_TEMPL_PS_POLL,
+	CMD_TEMPL_KLV,
+	CMD_TEMPL_DISCONNECT,
+	CMD_TEMPL_PROBE_REQ_2_4, /* for firmware internal use only */
+	CMD_TEMPL_PROBE_REQ_5,   /* for firmware internal use only */
+	CMD_TEMPL_BAR,           /* for firmware internal use only */
+	CMD_TEMPL_CTS,           /*
+				  * For CTS-to-self (FastCTS) mechanism
+				  * for BT/WLAN coexistence (SoftGemini). */
+	CMD_TEMPL_MAX = 0xff
+};
+
+/* unit ms */
+#define WL1271_COMMAND_TIMEOUT     2000
+#define WL1271_CMD_TEMPL_MAX_SIZE  252
+
+struct wl1271_cmd_header {
+	u16 id;
+	u16 status;
+	/* payload */
+	u8 data[0];
+} __attribute__ ((packed));
+
+#define WL1271_CMD_MAX_PARAMS 572
+
+struct wl1271_command {
+	struct wl1271_cmd_header header;
+	u8  parameters[WL1271_CMD_MAX_PARAMS];
+} __attribute__ ((packed));
+
+enum {
+	CMD_MAILBOX_IDLE              		=  0,
+	CMD_STATUS_SUCCESS            		=  1,
+	CMD_STATUS_UNKNOWN_CMD        		=  2,
+	CMD_STATUS_UNKNOWN_IE         		=  3,
+	CMD_STATUS_REJECT_MEAS_SG_ACTIVE 	= 11,
+	CMD_STATUS_RX_BUSY            		= 13,
+	CMD_STATUS_INVALID_PARAM      		= 14,
+	CMD_STATUS_TEMPLATE_TOO_LARGE 		= 15,
+	CMD_STATUS_OUT_OF_MEMORY      		= 16,
+	CMD_STATUS_STA_TABLE_FULL     		= 17,
+	CMD_STATUS_RADIO_ERROR        		= 18,
+	CMD_STATUS_WRONG_NESTING      		= 19,
+	CMD_STATUS_TIMEOUT            		= 21, /* Driver internal use.*/
+	CMD_STATUS_FW_RESET           		= 22, /* Driver internal use.*/
+	MAX_COMMAND_STATUS            		= 0xff
+};
+
+
+/*
+ * CMD_READ_MEMORY
+ *
+ * The host issues this command to read the WiLink device memory/registers.
+ *
+ * Note: The Base Band address has special handling (16 bits registers and
+ * addresses). For more information, see the hardware specification.
+ */
+/*
+ * CMD_WRITE_MEMORY
+ *
+ * The host issues this command to write the WiLink device memory/registers.
+ *
+ * The Base Band address has special handling (16 bits registers and
+ * addresses). For more information, see the hardware specification.
+ */
+#define MAX_READ_SIZE 256
+
+struct cmd_read_write_memory {
+	struct wl1271_cmd_header header;
+
+	/* The address of the memory to read from or write to.*/
+	u32 addr;
+
+	/* The amount of data in bytes to read from or write to the WiLink
+	 * device.*/
+	u32 size;
+
+	/* The actual value read from or written to the Wilink. The source
+	   of this field is the Host in WRITE command or the Wilink in READ
+	   command. */
+	u8 value[MAX_READ_SIZE];
+};
+
+#define CMDMBOX_HEADER_LEN 4
+#define CMDMBOX_INFO_ELEM_HEADER_LEN 4
+
+enum {
+	BSS_TYPE_IBSS = 0,
+	BSS_TYPE_STA_BSS = 2,
+	BSS_TYPE_AP_BSS = 3,
+	MAX_BSS_TYPE = 0xFF
+};
+
+#define WL1271_JOIN_CMD_CTRL_TX_FLUSH     0x80 /* Firmware flushes all Tx */
+#define WL1271_JOIN_CMD_TX_SESSION_OFFSET 1
+
+struct wl1271_cmd_join {
+	struct wl1271_cmd_header header;
+
+	u32 bssid_lsb;
+	u16 bssid_msb;
+	u16 beacon_interval; /* in TBTTs */
+	u32 rx_config_options;
+	u32 rx_filter_options;
+
+	/*
+	 * The target uses this field to determine the rate at
+	 * which to transmit control frame responses (such as
+	 * ACK or CTS frames).
+	 */
+	u32 basic_rate_set;
+	u8 dtim_interval;
+	/*
+	 * bits 0-2: This bitwise field specifies the type
+	 * of BSS to start or join (BSS_TYPE_*).
+	 * bit 4: Band - The radio band in which to join
+	 * or start.
+	 *  0 - 2.4GHz band
+	 *  1 - 5GHz band
+	 * bits 3, 5-7: Reserved
+	 */
+	u8 bss_type;
+	u8 channel;
+	u8 ssid_len;
+	u8 ssid[IW_ESSID_MAX_SIZE];
+	u8 ctrl; /* JOIN_CMD_CTRL_* */
+	u8 reserved[3];
+} __attribute__ ((packed));
+
+struct cmd_enabledisable_path {
+	struct wl1271_cmd_header header;
+
+	u8 channel;
+	u8 padding[3];
+} __attribute__ ((packed));
+
+struct wl1271_cmd_template_set {
+	struct wl1271_cmd_header header;
+
+	u16 len;
+	u8 template_type;
+	u8 index;  /* relevant only for KLV_TEMPLATE type */
+	u32 enabled_rates;
+	u8 short_retry_limit;
+	u8 long_retry_limit;
+	u8 aflags;
+	u8 reserved;
+	u8 template_data[WL1271_CMD_TEMPL_MAX_SIZE];
+} __attribute__ ((packed));
+
+#define TIM_ELE_ID    5
+#define PARTIAL_VBM_MAX    251
+
+struct wl1271_tim {
+	u8 identity;
+	u8 length;
+	u8 dtim_count;
+	u8 dtim_period;
+	u8 bitmap_ctrl;
+	u8 pvb_field[PARTIAL_VBM_MAX]; /* Partial Virtual Bitmap */
+} __attribute__ ((packed));
+
+enum wl1271_cmd_ps_mode {
+	STATION_ACTIVE_MODE,
+	STATION_POWER_SAVE_MODE
+};
+
+struct wl1271_cmd_ps_params {
+	struct wl1271_cmd_header header;
+
+	u8 ps_mode; /* STATION_* */
+	u8 send_null_data; /* Do we have to send NULL data packet ? */
+	u8 retries; /* Number of retires for the initial NULL data packet */
+
+	 /*
+	  * TUs during which the target stays awake after switching
+	  * to power save mode.
+	  */
+	u8 hang_over_period;
+	u32 null_data_rate;
+} __attribute__ ((packed));
+
+/* HW encryption keys */
+#define NUM_ACCESS_CATEGORIES_COPY 4
+#define MAX_KEY_SIZE 32
+
+/* When set, disable HW encryption */
+#define DF_ENCRYPTION_DISABLE      0x01
+/* When set, disable HW decryption */
+#define DF_SNIFF_MODE_ENABLE       0x80
+
+enum wl1271_cmd_key_action {
+	KEY_ADD_OR_REPLACE = 1,
+	KEY_REMOVE         = 2,
+	KEY_SET_ID         = 3,
+	MAX_KEY_ACTION     = 0xffff,
+};
+
+enum wl1271_cmd_key_type {
+	KEY_NONE = 0,
+	KEY_WEP  = 1,
+	KEY_TKIP = 2,
+	KEY_AES  = 3,
+	KEY_GEM  = 4
+};
+
+/* FIXME: Add description for key-types */
+
+struct wl1271_cmd_set_keys {
+	struct wl1271_cmd_header header;
+
+	/* Ignored for default WEP key */
+	u8 addr[ETH_ALEN];
+
+	/* key_action_e */
+	u16 key_action;
+
+	u16 reserved_1;
+
+	/* key size in bytes */
+	u8 key_size;
+
+	/* key_type_e */
+	u8 key_type;
+	u8 ssid_profile;
+
+	/*
+	 * TKIP, AES: frame's key id field.
+	 * For WEP default key: key id;
+	 */
+	u8 id;
+	u8 reserved_2[6];
+	u8 key[MAX_KEY_SIZE];
+	u16 ac_seq_num16[NUM_ACCESS_CATEGORIES_COPY];
+	u32 ac_seq_num32[NUM_ACCESS_CATEGORIES_COPY];
+} __attribute__ ((packed));
+
+
+#define WL1271_SCAN_MAX_CHANNELS       24
+#define WL1271_SCAN_DEFAULT_TAG        1
+#define WL1271_SCAN_CURRENT_TX_PWR     0
+#define WL1271_SCAN_OPT_ACTIVE         0
+#define WL1271_SCAN_OPT_PASSIVE	       1
+#define WL1271_SCAN_OPT_PRIORITY_HIGH  4
+#define WL1271_SCAN_CHAN_MIN_DURATION  30000  /* TU */
+#define WL1271_SCAN_CHAN_MAX_DURATION  60000  /* TU */
+
+struct basic_scan_params {
+	u32 rx_config_options;
+	u32 rx_filter_options;
+	/* Scan option flags (WL1271_SCAN_OPT_*) */
+	u16 scan_options;
+	/* Number of scan channels in the list (maximum 30) */
+	u8 num_channels;
+	/* This field indicates the number of probe requests to send
+	   per channel for an active scan */
+	u8 num_probe_requests;
+	/* Rate bit field for sending the probes */
+	u32 tx_rate;
+	u8 tid_trigger;
+	u8 ssid_len;
+	/* in order to align */
+	u8 padding1[2];
+	u8 ssid[IW_ESSID_MAX_SIZE];
+	/* Band to scan */
+	u8 band;
+	u8 use_ssid_list;
+	u8 scan_tag;
+	u8 padding2;
+} __attribute__ ((packed));
+
+struct basic_scan_channel_params {
+	/* Duration in TU to wait for frames on a channel for active scan */
+	u32 min_duration;
+	u32 max_duration;
+	u32 bssid_lsb;
+	u16 bssid_msb;
+	u8 early_termination;
+	u8 tx_power_att;
+	u8 channel;
+	/* FW internal use only! */
+	u8 dfs_candidate;
+	u8 activity_detected;
+	u8 pad;
+} __attribute__ ((packed));
+
+struct wl1271_cmd_scan {
+	struct wl1271_cmd_header header;
+
+	struct basic_scan_params params;
+	struct basic_scan_channel_params channels[WL1271_SCAN_MAX_CHANNELS];
+} __attribute__ ((packed));
+
+struct wl1271_cmd_trigger_scan_to {
+	struct wl1271_cmd_header header;
+
+	u32 timeout;
+};
+
+struct wl1271_cmd_test_header {
+	u8 id;
+	u8 padding[3];
+};
+
+enum wl1271_channel_tune_bands {
+	WL1271_CHANNEL_TUNE_BAND_2_4,
+	WL1271_CHANNEL_TUNE_BAND_5,
+	WL1271_CHANNEL_TUNE_BAND_4_9
+};
+
+#define WL1271_PD_REFERENCE_POINT_BAND_B_G 0
+
+#define TEST_CMD_P2G_CAL                   0x02
+#define TEST_CMD_CHANNEL_TUNE              0x0d
+#define TEST_CMD_UPDATE_PD_REFERENCE_POINT 0x1d
+
+struct wl1271_cmd_cal_channel_tune {
+	struct wl1271_cmd_header header;
+
+	struct wl1271_cmd_test_header test;
+
+	u8 band;
+	u8 channel;
+
+	u16 radio_status;
+} __attribute__ ((packed));
+
+struct wl1271_cmd_cal_update_ref_point {
+	struct wl1271_cmd_header header;
+
+	struct wl1271_cmd_test_header test;
+
+	s32 ref_power;
+	s32 ref_detector;
+	u8  sub_band;
+	u8  padding[3];
+} __attribute__ ((packed));
+
+#define MAX_TLV_LENGTH         400
+#define	MAX_NVS_VERSION_LENGTH 12
+
+#define WL1271_CAL_P2G_BAND_B_G BIT(0)
+
+struct wl1271_cmd_cal_p2g {
+	struct wl1271_cmd_header header;
+
+	struct wl1271_cmd_test_header test;
+
+	u16 len;
+	u8  buf[MAX_TLV_LENGTH];
+	u8  type;
+	u8  padding;
+
+	s16 radio_status;
+	u8  nvs_version[MAX_NVS_VERSION_LENGTH];
+
+	u8  sub_band_mask;
+	u8  padding2;
+} __attribute__ ((packed));
+
+#endif /* __WL1271_CMD_H__ */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_debugfs.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_debugfs.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_debugfs.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_debugfs.c	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,518 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include "wl1271_debugfs.h"
+
+#include <linux/skbuff.h>
+
+#include "wl1271.h"
+#include "wl1271_acx.h"
+#include "wl1271_ps.h"
+
+/* ms */
+#define WL1271_DEBUGFS_STATS_LIFETIME 1000
+
+/* debugfs macros idea from mac80211 */
+
+#define DEBUGFS_READONLY_FILE(name, buflen, fmt, value...)		\
+static ssize_t name## _read(struct file *file, char __user *userbuf,	\
+			    size_t count, loff_t *ppos)			\
+{									\
+	struct wl1271 *wl = file->private_data;				\
+	char buf[buflen];						\
+	int res;							\
+									\
+	res = scnprintf(buf, buflen, fmt "\n", ##value);		\
+	return simple_read_from_buffer(userbuf, count, ppos, buf, res);	\
+}									\
+									\
+static const struct file_operations name## _ops = {			\
+	.read = name## _read,						\
+	.open = wl1271_open_file_generic,				\
+};
+
+#define DEBUGFS_ADD(name, parent)					\
+	wl->debugfs.name = debugfs_create_file(#name, 0400, parent,	\
+					       wl, &name## _ops);	\
+	if (IS_ERR(wl->debugfs.name)) {					\
+		ret = PTR_ERR(wl->debugfs.name);			\
+		wl->debugfs.name = NULL;				\
+		goto out;						\
+	}
+
+#define DEBUGFS_DEL(name)						\
+	do {								\
+		debugfs_remove(wl->debugfs.name);			\
+		wl->debugfs.name = NULL;				\
+	} while (0)
+
+#define DEBUGFS_FWSTATS_FILE(sub, name, buflen, fmt)			\
+static ssize_t sub## _ ##name## _read(struct file *file,		\
+				      char __user *userbuf,		\
+				      size_t count, loff_t *ppos)	\
+{									\
+	struct wl1271 *wl = file->private_data;				\
+	char buf[buflen];						\
+	int res;							\
+									\
+	wl1271_debugfs_update_stats(wl);				\
+									\
+	res = scnprintf(buf, buflen, fmt "\n",				\
+			wl->stats.fw_stats->sub.name);			\
+	return simple_read_from_buffer(userbuf, count, ppos, buf, res);	\
+}									\
+									\
+static const struct file_operations sub## _ ##name## _ops = {		\
+	.read = sub## _ ##name## _read,					\
+	.open = wl1271_open_file_generic,				\
+};
+
+#define DEBUGFS_FWSTATS_ADD(sub, name)				\
+	DEBUGFS_ADD(sub## _ ##name, wl->debugfs.fw_statistics)
+
+#define DEBUGFS_FWSTATS_DEL(sub, name)				\
+	DEBUGFS_DEL(sub## _ ##name)
+
+static void wl1271_debugfs_update_stats(struct wl1271 *wl)
+{
+	int ret;
+
+	mutex_lock(&wl->mutex);
+
+	ret = wl1271_ps_elp_wakeup(wl, false);
+	if (ret < 0)
+		goto out;
+
+	if (wl->state == WL1271_STATE_ON &&
+	    time_after(jiffies, wl->stats.fw_stats_update +
+		       msecs_to_jiffies(WL1271_DEBUGFS_STATS_LIFETIME))) {
+		wl1271_acx_statistics(wl, wl->stats.fw_stats);
+		wl->stats.fw_stats_update = jiffies;
+	}
+
+	wl1271_ps_elp_sleep(wl);
+
+out:
+	mutex_unlock(&wl->mutex);
+}
+
+static int wl1271_open_file_generic(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+DEBUGFS_FWSTATS_FILE(tx, internal_desc_overflow, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(rx, out_of_mem, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rx, hdr_overflow, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rx, hw_stuck, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rx, dropped, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rx, fcs_err, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rx, xfr_hint_trig, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rx, path_reset, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rx, reset_counter, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(dma, rx_requested, 20, "%u");
+DEBUGFS_FWSTATS_FILE(dma, rx_errors, 20, "%u");
+DEBUGFS_FWSTATS_FILE(dma, tx_requested, 20, "%u");
+DEBUGFS_FWSTATS_FILE(dma, tx_errors, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(isr, cmd_cmplt, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, fiqs, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, rx_headers, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, rx_mem_overflow, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, rx_rdys, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, irqs, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, tx_procs, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, decrypt_done, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, dma0_done, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, dma1_done, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, tx_exch_complete, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, commands, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, rx_procs, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, hw_pm_mode_changes, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, host_acknowledges, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, pci_pm, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, wakeups, 20, "%u");
+DEBUGFS_FWSTATS_FILE(isr, low_rssi, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(wep, addr_key_count, 20, "%u");
+DEBUGFS_FWSTATS_FILE(wep, default_key_count, 20, "%u");
+/* skipping wep.reserved */
+DEBUGFS_FWSTATS_FILE(wep, key_not_found, 20, "%u");
+DEBUGFS_FWSTATS_FILE(wep, decrypt_fail, 20, "%u");
+DEBUGFS_FWSTATS_FILE(wep, packets, 20, "%u");
+DEBUGFS_FWSTATS_FILE(wep, interrupt, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(pwr, ps_enter, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, elp_enter, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, missing_bcns, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, wake_on_host, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, wake_on_timer_exp, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, tx_with_ps, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, tx_without_ps, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, rcvd_beacons, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, power_save_off, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, enable_ps, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, disable_ps, 20, "%u");
+DEBUGFS_FWSTATS_FILE(pwr, fix_tsf_ps, 20, "%u");
+/* skipping cont_miss_bcns_spread for now */
+DEBUGFS_FWSTATS_FILE(pwr, rcvd_awake_beacons, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(mic, rx_pkts, 20, "%u");
+DEBUGFS_FWSTATS_FILE(mic, calc_failure, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(aes, encrypt_fail, 20, "%u");
+DEBUGFS_FWSTATS_FILE(aes, decrypt_fail, 20, "%u");
+DEBUGFS_FWSTATS_FILE(aes, encrypt_packets, 20, "%u");
+DEBUGFS_FWSTATS_FILE(aes, decrypt_packets, 20, "%u");
+DEBUGFS_FWSTATS_FILE(aes, encrypt_interrupt, 20, "%u");
+DEBUGFS_FWSTATS_FILE(aes, decrypt_interrupt, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(event, heart_beat, 20, "%u");
+DEBUGFS_FWSTATS_FILE(event, calibration, 20, "%u");
+DEBUGFS_FWSTATS_FILE(event, rx_mismatch, 20, "%u");
+DEBUGFS_FWSTATS_FILE(event, rx_mem_empty, 20, "%u");
+DEBUGFS_FWSTATS_FILE(event, rx_pool, 20, "%u");
+DEBUGFS_FWSTATS_FILE(event, oom_late, 20, "%u");
+DEBUGFS_FWSTATS_FILE(event, phy_transmit_error, 20, "%u");
+DEBUGFS_FWSTATS_FILE(event, tx_stuck, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(ps, pspoll_timeouts, 20, "%u");
+DEBUGFS_FWSTATS_FILE(ps, upsd_timeouts, 20, "%u");
+DEBUGFS_FWSTATS_FILE(ps, upsd_max_sptime, 20, "%u");
+DEBUGFS_FWSTATS_FILE(ps, upsd_max_apturn, 20, "%u");
+DEBUGFS_FWSTATS_FILE(ps, pspoll_max_apturn, 20, "%u");
+DEBUGFS_FWSTATS_FILE(ps, pspoll_utilization, 20, "%u");
+DEBUGFS_FWSTATS_FILE(ps, upsd_utilization, 20, "%u");
+
+DEBUGFS_FWSTATS_FILE(rxpipe, rx_prep_beacon_drop, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rxpipe, descr_host_int_trig_rx_data, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rxpipe, beacon_buffer_thres_host_int_trig_rx_data,
+		     20, "%u");
+DEBUGFS_FWSTATS_FILE(rxpipe, missed_beacon_host_int_trig_rx_data, 20, "%u");
+DEBUGFS_FWSTATS_FILE(rxpipe, tx_xfr_host_int_trig_rx_data, 20, "%u");
+
+DEBUGFS_READONLY_FILE(retry_count, 20, "%u", wl->stats.retry_count);
+DEBUGFS_READONLY_FILE(excessive_retries, 20, "%u",
+		      wl->stats.excessive_retries);
+
+static ssize_t tx_queue_len_read(struct file *file, char __user *userbuf,
+				 size_t count, loff_t *ppos)
+{
+	struct wl1271 *wl = file->private_data;
+	u32 queue_len;
+	char buf[20];
+	int res;
+
+	queue_len = skb_queue_len(&wl->tx_queue);
+
+	res = scnprintf(buf, sizeof(buf), "%u\n", queue_len);
+	return simple_read_from_buffer(userbuf, count, ppos, buf, res);
+}
+
+static const struct file_operations tx_queue_len_ops = {
+	.read = tx_queue_len_read,
+	.open = wl1271_open_file_generic,
+};
+
+static void wl1271_debugfs_delete_files(struct wl1271 *wl)
+{
+	DEBUGFS_FWSTATS_DEL(tx, internal_desc_overflow);
+
+	DEBUGFS_FWSTATS_DEL(rx, out_of_mem);
+	DEBUGFS_FWSTATS_DEL(rx, hdr_overflow);
+	DEBUGFS_FWSTATS_DEL(rx, hw_stuck);
+	DEBUGFS_FWSTATS_DEL(rx, dropped);
+	DEBUGFS_FWSTATS_DEL(rx, fcs_err);
+	DEBUGFS_FWSTATS_DEL(rx, xfr_hint_trig);
+	DEBUGFS_FWSTATS_DEL(rx, path_reset);
+	DEBUGFS_FWSTATS_DEL(rx, reset_counter);
+
+	DEBUGFS_FWSTATS_DEL(dma, rx_requested);
+	DEBUGFS_FWSTATS_DEL(dma, rx_errors);
+	DEBUGFS_FWSTATS_DEL(dma, tx_requested);
+	DEBUGFS_FWSTATS_DEL(dma, tx_errors);
+
+	DEBUGFS_FWSTATS_DEL(isr, cmd_cmplt);
+	DEBUGFS_FWSTATS_DEL(isr, fiqs);
+	DEBUGFS_FWSTATS_DEL(isr, rx_headers);
+	DEBUGFS_FWSTATS_DEL(isr, rx_mem_overflow);
+	DEBUGFS_FWSTATS_DEL(isr, rx_rdys);
+	DEBUGFS_FWSTATS_DEL(isr, irqs);
+	DEBUGFS_FWSTATS_DEL(isr, tx_procs);
+	DEBUGFS_FWSTATS_DEL(isr, decrypt_done);
+	DEBUGFS_FWSTATS_DEL(isr, dma0_done);
+	DEBUGFS_FWSTATS_DEL(isr, dma1_done);
+	DEBUGFS_FWSTATS_DEL(isr, tx_exch_complete);
+	DEBUGFS_FWSTATS_DEL(isr, commands);
+	DEBUGFS_FWSTATS_DEL(isr, rx_procs);
+	DEBUGFS_FWSTATS_DEL(isr, hw_pm_mode_changes);
+	DEBUGFS_FWSTATS_DEL(isr, host_acknowledges);
+	DEBUGFS_FWSTATS_DEL(isr, pci_pm);
+	DEBUGFS_FWSTATS_DEL(isr, wakeups);
+	DEBUGFS_FWSTATS_DEL(isr, low_rssi);
+
+	DEBUGFS_FWSTATS_DEL(wep, addr_key_count);
+	DEBUGFS_FWSTATS_DEL(wep, default_key_count);
+	/* skipping wep.reserved */
+	DEBUGFS_FWSTATS_DEL(wep, key_not_found);
+	DEBUGFS_FWSTATS_DEL(wep, decrypt_fail);
+	DEBUGFS_FWSTATS_DEL(wep, packets);
+	DEBUGFS_FWSTATS_DEL(wep, interrupt);
+
+	DEBUGFS_FWSTATS_DEL(pwr, ps_enter);
+	DEBUGFS_FWSTATS_DEL(pwr, elp_enter);
+	DEBUGFS_FWSTATS_DEL(pwr, missing_bcns);
+	DEBUGFS_FWSTATS_DEL(pwr, wake_on_host);
+	DEBUGFS_FWSTATS_DEL(pwr, wake_on_timer_exp);
+	DEBUGFS_FWSTATS_DEL(pwr, tx_with_ps);
+	DEBUGFS_FWSTATS_DEL(pwr, tx_without_ps);
+	DEBUGFS_FWSTATS_DEL(pwr, rcvd_beacons);
+	DEBUGFS_FWSTATS_DEL(pwr, power_save_off);
+	DEBUGFS_FWSTATS_DEL(pwr, enable_ps);
+	DEBUGFS_FWSTATS_DEL(pwr, disable_ps);
+	DEBUGFS_FWSTATS_DEL(pwr, fix_tsf_ps);
+	/* skipping cont_miss_bcns_spread for now */
+	DEBUGFS_FWSTATS_DEL(pwr, rcvd_awake_beacons);
+
+	DEBUGFS_FWSTATS_DEL(mic, rx_pkts);
+	DEBUGFS_FWSTATS_DEL(mic, calc_failure);
+
+	DEBUGFS_FWSTATS_DEL(aes, encrypt_fail);
+	DEBUGFS_FWSTATS_DEL(aes, decrypt_fail);
+	DEBUGFS_FWSTATS_DEL(aes, encrypt_packets);
+	DEBUGFS_FWSTATS_DEL(aes, decrypt_packets);
+	DEBUGFS_FWSTATS_DEL(aes, encrypt_interrupt);
+	DEBUGFS_FWSTATS_DEL(aes, decrypt_interrupt);
+
+	DEBUGFS_FWSTATS_DEL(event, heart_beat);
+	DEBUGFS_FWSTATS_DEL(event, calibration);
+	DEBUGFS_FWSTATS_DEL(event, rx_mismatch);
+	DEBUGFS_FWSTATS_DEL(event, rx_mem_empty);
+	DEBUGFS_FWSTATS_DEL(event, rx_pool);
+	DEBUGFS_FWSTATS_DEL(event, oom_late);
+	DEBUGFS_FWSTATS_DEL(event, phy_transmit_error);
+	DEBUGFS_FWSTATS_DEL(event, tx_stuck);
+
+	DEBUGFS_FWSTATS_DEL(ps, pspoll_timeouts);
+	DEBUGFS_FWSTATS_DEL(ps, upsd_timeouts);
+	DEBUGFS_FWSTATS_DEL(ps, upsd_max_sptime);
+	DEBUGFS_FWSTATS_DEL(ps, upsd_max_apturn);
+	DEBUGFS_FWSTATS_DEL(ps, pspoll_max_apturn);
+	DEBUGFS_FWSTATS_DEL(ps, pspoll_utilization);
+	DEBUGFS_FWSTATS_DEL(ps, upsd_utilization);
+
+	DEBUGFS_FWSTATS_DEL(rxpipe, rx_prep_beacon_drop);
+	DEBUGFS_FWSTATS_DEL(rxpipe, descr_host_int_trig_rx_data);
+	DEBUGFS_FWSTATS_DEL(rxpipe, beacon_buffer_thres_host_int_trig_rx_data);
+	DEBUGFS_FWSTATS_DEL(rxpipe, missed_beacon_host_int_trig_rx_data);
+	DEBUGFS_FWSTATS_DEL(rxpipe, tx_xfr_host_int_trig_rx_data);
+
+	DEBUGFS_DEL(tx_queue_len);
+	DEBUGFS_DEL(retry_count);
+	DEBUGFS_DEL(excessive_retries);
+}
+
+static int wl1271_debugfs_add_files(struct wl1271 *wl)
+{
+	int ret = 0;
+
+	DEBUGFS_FWSTATS_ADD(tx, internal_desc_overflow);
+
+	DEBUGFS_FWSTATS_ADD(rx, out_of_mem);
+	DEBUGFS_FWSTATS_ADD(rx, hdr_overflow);
+	DEBUGFS_FWSTATS_ADD(rx, hw_stuck);
+	DEBUGFS_FWSTATS_ADD(rx, dropped);
+	DEBUGFS_FWSTATS_ADD(rx, fcs_err);
+	DEBUGFS_FWSTATS_ADD(rx, xfr_hint_trig);
+	DEBUGFS_FWSTATS_ADD(rx, path_reset);
+	DEBUGFS_FWSTATS_ADD(rx, reset_counter);
+
+	DEBUGFS_FWSTATS_ADD(dma, rx_requested);
+	DEBUGFS_FWSTATS_ADD(dma, rx_errors);
+	DEBUGFS_FWSTATS_ADD(dma, tx_requested);
+	DEBUGFS_FWSTATS_ADD(dma, tx_errors);
+
+	DEBUGFS_FWSTATS_ADD(isr, cmd_cmplt);
+	DEBUGFS_FWSTATS_ADD(isr, fiqs);
+	DEBUGFS_FWSTATS_ADD(isr, rx_headers);
+	DEBUGFS_FWSTATS_ADD(isr, rx_mem_overflow);
+	DEBUGFS_FWSTATS_ADD(isr, rx_rdys);
+	DEBUGFS_FWSTATS_ADD(isr, irqs);
+	DEBUGFS_FWSTATS_ADD(isr, tx_procs);
+	DEBUGFS_FWSTATS_ADD(isr, decrypt_done);
+	DEBUGFS_FWSTATS_ADD(isr, dma0_done);
+	DEBUGFS_FWSTATS_ADD(isr, dma1_done);
+	DEBUGFS_FWSTATS_ADD(isr, tx_exch_complete);
+	DEBUGFS_FWSTATS_ADD(isr, commands);
+	DEBUGFS_FWSTATS_ADD(isr, rx_procs);
+	DEBUGFS_FWSTATS_ADD(isr, hw_pm_mode_changes);
+	DEBUGFS_FWSTATS_ADD(isr, host_acknowledges);
+	DEBUGFS_FWSTATS_ADD(isr, pci_pm);
+	DEBUGFS_FWSTATS_ADD(isr, wakeups);
+	DEBUGFS_FWSTATS_ADD(isr, low_rssi);
+
+	DEBUGFS_FWSTATS_ADD(wep, addr_key_count);
+	DEBUGFS_FWSTATS_ADD(wep, default_key_count);
+	/* skipping wep.reserved */
+	DEBUGFS_FWSTATS_ADD(wep, key_not_found);
+	DEBUGFS_FWSTATS_ADD(wep, decrypt_fail);
+	DEBUGFS_FWSTATS_ADD(wep, packets);
+	DEBUGFS_FWSTATS_ADD(wep, interrupt);
+
+	DEBUGFS_FWSTATS_ADD(pwr, ps_enter);
+	DEBUGFS_FWSTATS_ADD(pwr, elp_enter);
+	DEBUGFS_FWSTATS_ADD(pwr, missing_bcns);
+	DEBUGFS_FWSTATS_ADD(pwr, wake_on_host);
+	DEBUGFS_FWSTATS_ADD(pwr, wake_on_timer_exp);
+	DEBUGFS_FWSTATS_ADD(pwr, tx_with_ps);
+	DEBUGFS_FWSTATS_ADD(pwr, tx_without_ps);
+	DEBUGFS_FWSTATS_ADD(pwr, rcvd_beacons);
+	DEBUGFS_FWSTATS_ADD(pwr, power_save_off);
+	DEBUGFS_FWSTATS_ADD(pwr, enable_ps);
+	DEBUGFS_FWSTATS_ADD(pwr, disable_ps);
+	DEBUGFS_FWSTATS_ADD(pwr, fix_tsf_ps);
+	/* skipping cont_miss_bcns_spread for now */
+	DEBUGFS_FWSTATS_ADD(pwr, rcvd_awake_beacons);
+
+	DEBUGFS_FWSTATS_ADD(mic, rx_pkts);
+	DEBUGFS_FWSTATS_ADD(mic, calc_failure);
+
+	DEBUGFS_FWSTATS_ADD(aes, encrypt_fail);
+	DEBUGFS_FWSTATS_ADD(aes, decrypt_fail);
+	DEBUGFS_FWSTATS_ADD(aes, encrypt_packets);
+	DEBUGFS_FWSTATS_ADD(aes, decrypt_packets);
+	DEBUGFS_FWSTATS_ADD(aes, encrypt_interrupt);
+	DEBUGFS_FWSTATS_ADD(aes, decrypt_interrupt);
+
+	DEBUGFS_FWSTATS_ADD(event, heart_beat);
+	DEBUGFS_FWSTATS_ADD(event, calibration);
+	DEBUGFS_FWSTATS_ADD(event, rx_mismatch);
+	DEBUGFS_FWSTATS_ADD(event, rx_mem_empty);
+	DEBUGFS_FWSTATS_ADD(event, rx_pool);
+	DEBUGFS_FWSTATS_ADD(event, oom_late);
+	DEBUGFS_FWSTATS_ADD(event, phy_transmit_error);
+	DEBUGFS_FWSTATS_ADD(event, tx_stuck);
+
+	DEBUGFS_FWSTATS_ADD(ps, pspoll_timeouts);
+	DEBUGFS_FWSTATS_ADD(ps, upsd_timeouts);
+	DEBUGFS_FWSTATS_ADD(ps, upsd_max_sptime);
+	DEBUGFS_FWSTATS_ADD(ps, upsd_max_apturn);
+	DEBUGFS_FWSTATS_ADD(ps, pspoll_max_apturn);
+	DEBUGFS_FWSTATS_ADD(ps, pspoll_utilization);
+	DEBUGFS_FWSTATS_ADD(ps, upsd_utilization);
+
+	DEBUGFS_FWSTATS_ADD(rxpipe, rx_prep_beacon_drop);
+	DEBUGFS_FWSTATS_ADD(rxpipe, descr_host_int_trig_rx_data);
+	DEBUGFS_FWSTATS_ADD(rxpipe, beacon_buffer_thres_host_int_trig_rx_data);
+	DEBUGFS_FWSTATS_ADD(rxpipe, missed_beacon_host_int_trig_rx_data);
+	DEBUGFS_FWSTATS_ADD(rxpipe, tx_xfr_host_int_trig_rx_data);
+
+	DEBUGFS_ADD(tx_queue_len, wl->debugfs.rootdir);
+	DEBUGFS_ADD(retry_count, wl->debugfs.rootdir);
+	DEBUGFS_ADD(excessive_retries, wl->debugfs.rootdir);
+
+out:
+	if (ret < 0)
+		wl1271_debugfs_delete_files(wl);
+
+	return ret;
+}
+
+void wl1271_debugfs_reset(struct wl1271 *wl)
+{
+	memset(wl->stats.fw_stats, 0, sizeof(*wl->stats.fw_stats));
+	wl->stats.retry_count = 0;
+	wl->stats.excessive_retries = 0;
+}
+
+int wl1271_debugfs_init(struct wl1271 *wl)
+{
+	int ret;
+
+	wl->debugfs.rootdir = debugfs_create_dir(KBUILD_MODNAME, NULL);
+
+	if (IS_ERR(wl->debugfs.rootdir)) {
+		ret = PTR_ERR(wl->debugfs.rootdir);
+		wl->debugfs.rootdir = NULL;
+		goto err;
+	}
+
+	wl->debugfs.fw_statistics = debugfs_create_dir("fw-statistics",
+						       wl->debugfs.rootdir);
+
+	if (IS_ERR(wl->debugfs.fw_statistics)) {
+		ret = PTR_ERR(wl->debugfs.fw_statistics);
+		wl->debugfs.fw_statistics = NULL;
+		goto err_root;
+	}
+
+	wl->stats.fw_stats = kzalloc(sizeof(*wl->stats.fw_stats),
+				      GFP_KERNEL);
+
+	if (!wl->stats.fw_stats) {
+		ret = -ENOMEM;
+		goto err_fw;
+	}
+
+	wl->stats.fw_stats_update = jiffies;
+
+	ret = wl1271_debugfs_add_files(wl);
+
+	if (ret < 0)
+		goto err_file;
+
+	return 0;
+
+err_file:
+	kfree(wl->stats.fw_stats);
+	wl->stats.fw_stats = NULL;
+
+err_fw:
+	debugfs_remove(wl->debugfs.fw_statistics);
+	wl->debugfs.fw_statistics = NULL;
+
+err_root:
+	debugfs_remove(wl->debugfs.rootdir);
+	wl->debugfs.rootdir = NULL;
+
+err:
+	return ret;
+}
+
+void wl1271_debugfs_exit(struct wl1271 *wl)
+{
+	wl1271_debugfs_delete_files(wl);
+
+	kfree(wl->stats.fw_stats);
+	wl->stats.fw_stats = NULL;
+
+	debugfs_remove(wl->debugfs.fw_statistics);
+	wl->debugfs.fw_statistics = NULL;
+
+	debugfs_remove(wl->debugfs.rootdir);
+	wl->debugfs.rootdir = NULL;
+
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_debugfs.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_debugfs.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_debugfs.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_debugfs.h	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,33 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef WL1271_DEBUGFS_H
+#define WL1271_DEBUGFS_H
+
+#include "wl1271.h"
+
+int wl1271_debugfs_init(struct wl1271 *wl);
+void wl1271_debugfs_exit(struct wl1271 *wl);
+void wl1271_debugfs_reset(struct wl1271 *wl);
+
+#endif /* WL1271_DEBUGFS_H */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_event.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_event.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_event.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_event.c	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,126 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include "wl1271.h"
+#include "wl1271_reg.h"
+#include "wl1271_spi.h"
+#include "wl1271_event.h"
+#include "wl1271_ps.h"
+
+static int wl1271_event_scan_complete(struct wl1271 *wl,
+				      struct event_mailbox *mbox)
+{
+	wl1271_debug(DEBUG_EVENT, "status: 0x%x",
+		     mbox->scheduled_scan_status);
+
+	if (wl->scanning) {
+		mutex_unlock(&wl->mutex);
+		ieee80211_scan_completed(wl->hw);
+		mutex_lock(&wl->mutex);
+		wl->scanning = false;
+	}
+
+	return 0;
+}
+
+static void wl1271_event_mbox_dump(struct event_mailbox *mbox)
+{
+	wl1271_debug(DEBUG_EVENT, "MBOX DUMP:");
+	wl1271_debug(DEBUG_EVENT, "\tvector: 0x%x", mbox->events_vector);
+	wl1271_debug(DEBUG_EVENT, "\tmask: 0x%x", mbox->events_mask);
+}
+
+static int wl1271_event_process(struct wl1271 *wl, struct event_mailbox *mbox)
+{
+	int ret;
+	u32 vector;
+
+	wl1271_event_mbox_dump(mbox);
+
+	vector = mbox->events_vector & ~(mbox->events_mask);
+	wl1271_debug(DEBUG_EVENT, "vector: 0x%x", vector);
+
+	if (vector & SCAN_COMPLETE_EVENT_ID) {
+		ret = wl1271_event_scan_complete(wl, mbox);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (vector & BSS_LOSE_EVENT_ID) {
+		wl1271_debug(DEBUG_EVENT, "BSS_LOSE_EVENT");
+
+		if (wl->psm_requested && wl->psm) {
+			ret = wl1271_ps_set_mode(wl, STATION_ACTIVE_MODE);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+int wl1271_event_unmask(struct wl1271 *wl)
+{
+	int ret;
+
+	ret = wl1271_acx_event_mbox_mask(wl, ~(wl->event_mask));
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+void wl1271_event_mbox_config(struct wl1271 *wl)
+{
+	wl->mbox_ptr[0] = wl1271_reg_read32(wl, REG_EVENT_MAILBOX_PTR);
+	wl->mbox_ptr[1] = wl->mbox_ptr[0] + sizeof(struct event_mailbox);
+
+	wl1271_debug(DEBUG_EVENT, "MBOX ptrs: 0x%x 0x%x",
+		     wl->mbox_ptr[0], wl->mbox_ptr[1]);
+}
+
+int wl1271_event_handle(struct wl1271 *wl, u8 mbox_num)
+{
+	struct event_mailbox mbox;
+	int ret;
+
+	wl1271_debug(DEBUG_EVENT, "EVENT on mbox %d", mbox_num);
+
+	if (mbox_num > 1)
+		return -EINVAL;
+
+	/* first we read the mbox descriptor */
+	wl1271_spi_mem_read(wl, wl->mbox_ptr[mbox_num], &mbox,
+			    sizeof(struct event_mailbox));
+
+	/* process the descriptor */
+	ret = wl1271_event_process(wl, &mbox);
+	if (ret < 0)
+		return ret;
+
+	/* then we let the firmware know it can go on...*/
+	wl1271_reg_write32(wl, ACX_REG_INTERRUPT_TRIG, INTR_TRIG_EVENT_ACK);
+
+	return 0;
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_event.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_event.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_event.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_event.h	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,110 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __WL1271_EVENT_H__
+#define __WL1271_EVENT_H__
+
+/*
+ * Mbox events
+ *
+ * The event mechanism is based on a pair of event buffers (buffers A and
+ * B) at fixed locations in the target's memory. The host processes one
+ * buffer while the other buffer continues to collect events. If the host
+ * is not processing events, an interrupt is issued to signal that a buffer
+ * is ready. Once the host is done with processing events from one buffer,
+ * it signals the target (with an ACK interrupt) that the event buffer is
+ * free.
+ */
+
+enum {
+	MEASUREMENT_START_EVENT_ID		 = BIT(8),
+	MEASUREMENT_COMPLETE_EVENT_ID		 = BIT(9),
+	SCAN_COMPLETE_EVENT_ID			 = BIT(10),
+	SCHEDULED_SCAN_COMPLETE_EVENT_ID	 = BIT(11),
+	AP_DISCOVERY_COMPLETE_EVENT_ID		 = BIT(12),
+	PS_REPORT_EVENT_ID			 = BIT(13),
+	PSPOLL_DELIVERY_FAILURE_EVENT_ID	 = BIT(14),
+	DISCONNECT_EVENT_COMPLETE_ID		 = BIT(15),
+	JOIN_EVENT_COMPLETE_ID			 = BIT(16),
+	CHANNEL_SWITCH_COMPLETE_EVENT_ID	 = BIT(17),
+	BSS_LOSE_EVENT_ID			 = BIT(18),
+	REGAINED_BSS_EVENT_ID			 = BIT(19),
+	ROAMING_TRIGGER_MAX_TX_RETRY_EVENT_ID	 = BIT(20),
+	SOFT_GEMINI_SENSE_EVENT_ID		 = BIT(22),
+	SOFT_GEMINI_PREDICTION_EVENT_ID		 = BIT(23),
+	SOFT_GEMINI_AVALANCHE_EVENT_ID		 = BIT(24),
+	PLT_RX_CALIBRATION_COMPLETE_EVENT_ID	 = BIT(25),
+	DBG_EVENT_ID				 = BIT(26),
+	HEALTH_CHECK_REPLY_EVENT_ID		 = BIT(27),
+	PERIODIC_SCAN_COMPLETE_EVENT_ID		 = BIT(28),
+	PERIODIC_SCAN_REPORT_EVENT_ID		 = BIT(29),
+	BA_SESSION_TEAR_DOWN_EVENT_ID		 = BIT(30),
+	EVENT_MBOX_ALL_EVENT_ID			 = 0x7fffffff,
+};
+
+struct event_debug_report {
+	u8 debug_event_id;
+	u8 num_params;
+	u16 pad;
+	u32 report_1;
+	u32 report_2;
+	u32 report_3;
+} __attribute__ ((packed));
+
+#define NUM_OF_RSSI_SNR_TRIGGERS 8
+
+struct event_mailbox {
+	u32 events_vector;
+	u32 events_mask;
+	u32 reserved_1;
+	u32 reserved_2;
+
+	u8 dbg_event_id;
+	u8 num_relevant_params;
+	u16 reserved_3;
+	u32 event_report_p1;
+	u32 event_report_p2;
+	u32 event_report_p3;
+
+	u8 number_of_scan_results;
+	u8 scan_tag;
+	u8 reserved_4[2];
+	u32 compl_scheduled_scan_status;
+
+	u16 scheduled_scan_attended_channels;
+	u8 soft_gemini_sense_info;
+	u8 soft_gemini_protective_info;
+	s8 rssi_snr_trigger_metric[NUM_OF_RSSI_SNR_TRIGGERS];
+	u8 channel_switch_status;
+	u8 scheduled_scan_status;
+	u8 ps_status;
+
+	u8 reserved_5[29];
+} __attribute__ ((packed));
+
+int wl1271_event_unmask(struct wl1271 *wl);
+void wl1271_event_mbox_config(struct wl1271 *wl);
+int wl1271_event_handle(struct wl1271 *wl, u8 mbox);
+
+#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271.h	2012-12-16 13:13:01.688330145 +0100
@@ -1,6 +1,7 @@
 /*
- * This file is part of wl12xx
+ * This file is part of wl1271
  *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
  * Copyright (C) 2008-2009 Nokia Corporation
  *
  * Contact: Kalle Valo <kalle.valo@nokia.com>
@@ -24,169 +25,385 @@
 #ifndef __WL1271_H__
 #define __WL1271_H__
 
+#include <linux/mutex.h>
+#include <linux/completion.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
 #include <linux/bitops.h>
+#include <net/mac80211.h>
+#include <mach/board.h>
+#include <mach/board-nokia.h>
+
+#define DRIVER_NAME "wl1271"
+#define DRIVER_PREFIX DRIVER_NAME ": "
+
+enum {
+	DEBUG_NONE	= 0,
+	DEBUG_IRQ	= BIT(0),
+	DEBUG_SPI	= BIT(1),
+	DEBUG_BOOT	= BIT(2),
+	DEBUG_MAILBOX	= BIT(3),
+	DEBUG_NETLINK	= BIT(4),
+	DEBUG_EVENT	= BIT(5),
+	DEBUG_TX	= BIT(6),
+	DEBUG_RX	= BIT(7),
+	DEBUG_SCAN	= BIT(8),
+	DEBUG_CRYPT	= BIT(9),
+	DEBUG_PSM	= BIT(10),
+	DEBUG_MAC80211	= BIT(11),
+	DEBUG_CMD	= BIT(12),
+	DEBUG_ACX	= BIT(13),
+	DEBUG_ALL	= ~0,
+};
+
+#define DEBUG_LEVEL (DEBUG_NONE)
+
+#define DEBUG_DUMP_LIMIT 1024
 
-#include "wl12xx.h"
-#include "acx.h"
+#define wl1271_error(fmt, arg...) \
+	printk(KERN_ERR DRIVER_PREFIX "ERROR " fmt "\n", ##arg)
+
+#define wl1271_warning(fmt, arg...) \
+	printk(KERN_WARNING DRIVER_PREFIX "WARNING " fmt "\n", ##arg)
+
+#define wl1271_notice(fmt, arg...) \
+	printk(KERN_INFO DRIVER_PREFIX fmt "\n", ##arg)
+
+#define wl1271_info(fmt, arg...) \
+	printk(KERN_DEBUG DRIVER_PREFIX fmt "\n", ##arg)
+
+#define wl1271_debug(level, fmt, arg...) \
+	do { \
+		if (level & DEBUG_LEVEL) \
+			printk(KERN_DEBUG DRIVER_PREFIX fmt "\n", ##arg); \
+	} while (0)
+
+#define wl1271_dump(level, prefix, buf, len)	\
+	do { \
+		if (level & DEBUG_LEVEL) \
+			print_hex_dump(KERN_DEBUG, DRIVER_PREFIX prefix, \
+				       DUMP_PREFIX_OFFSET, 16, 1,	\
+				       buf,				\
+				       min_t(size_t, len, DEBUG_DUMP_LIMIT), \
+				       0);				\
+	} while (0)
+
+#define wl1271_dump_ascii(level, prefix, buf, len)	\
+	do { \
+		if (level & DEBUG_LEVEL) \
+			print_hex_dump(KERN_DEBUG, DRIVER_PREFIX prefix, \
+				       DUMP_PREFIX_OFFSET, 16, 1,	\
+				       buf,				\
+				       min_t(size_t, len, DEBUG_DUMP_LIMIT), \
+				       true);				\
+	} while (0)
+
+#define WL1271_DEFAULT_RX_CONFIG (CFG_UNI_FILTER_EN |	\
+				  CFG_BSSID_FILTER_EN)
+
+#define WL1271_DEFAULT_RX_FILTER (CFG_RX_RCTS_ACK | CFG_RX_PRSP_EN |  \
+				  CFG_RX_MGMT_EN | CFG_RX_DATA_EN |   \
+				  CFG_RX_CTL_EN | CFG_RX_BCN_EN |     \
+				  CFG_RX_AUTH_EN | CFG_RX_ASSOC_EN)
 
 #define WL1271_FW_NAME "wl1271-fw.bin"
 #define WL1271_NVS_NAME "wl1271-nvs.bin"
 
-#define WL1271_POWER_ON_SLEEP 200 /* in miliseconds */
+#define WL1271_BUSY_WORD_LEN 8
+
+#define WL1271_ELP_HW_STATE_ASLEEP 0
+#define WL1271_ELP_HW_STATE_IRQ    1
+
+enum wl1271_state {
+	WL1271_STATE_OFF,
+	WL1271_STATE_ON,
+	WL1271_STATE_PLT,
+};
+
+enum wl1271_partition_type {
+	PART_DOWN,
+	PART_WORK,
+	PART_DRPW,
+
+	PART_TABLE_LEN
+};
+
+struct wl1271_partition {
+	u32 size;
+	u32 start;
+};
+
+struct wl1271_partition_set {
+	struct wl1271_partition mem;
+	struct wl1271_partition reg;
+};
+
+struct wl1271;
+
+/* FIXME: I'm not sure about this structure name */
+struct wl1271_chip {
+	u32 id;
+	char fw_ver[21];
+};
 
-#define REGISTERS_BASE 0x00300000
-#define DRPW_BASE      0x00310000
+struct wl1271_stats {
+	struct acx_statistics *fw_stats;
+	unsigned long fw_stats_update;
 
-void wl1271_setup(struct wl12xx *wl);
+	unsigned int retry_count;
+	unsigned int excessive_retries;
+};
+
+struct wl1271_debugfs {
+	struct dentry *rootdir;
+	struct dentry *fw_statistics;
+
+	struct dentry *tx_internal_desc_overflow;
+
+	struct dentry *rx_out_of_mem;
+	struct dentry *rx_hdr_overflow;
+	struct dentry *rx_hw_stuck;
+	struct dentry *rx_dropped;
+	struct dentry *rx_fcs_err;
+	struct dentry *rx_xfr_hint_trig;
+	struct dentry *rx_path_reset;
+	struct dentry *rx_reset_counter;
+
+	struct dentry *dma_rx_requested;
+	struct dentry *dma_rx_errors;
+	struct dentry *dma_tx_requested;
+	struct dentry *dma_tx_errors;
+
+	struct dentry *isr_cmd_cmplt;
+	struct dentry *isr_fiqs;
+	struct dentry *isr_rx_headers;
+	struct dentry *isr_rx_mem_overflow;
+	struct dentry *isr_rx_rdys;
+	struct dentry *isr_irqs;
+	struct dentry *isr_tx_procs;
+	struct dentry *isr_decrypt_done;
+	struct dentry *isr_dma0_done;
+	struct dentry *isr_dma1_done;
+	struct dentry *isr_tx_exch_complete;
+	struct dentry *isr_commands;
+	struct dentry *isr_rx_procs;
+	struct dentry *isr_hw_pm_mode_changes;
+	struct dentry *isr_host_acknowledges;
+	struct dentry *isr_pci_pm;
+	struct dentry *isr_wakeups;
+	struct dentry *isr_low_rssi;
+
+	struct dentry *wep_addr_key_count;
+	struct dentry *wep_default_key_count;
+	/* skipping wep.reserved */
+	struct dentry *wep_key_not_found;
+	struct dentry *wep_decrypt_fail;
+	struct dentry *wep_packets;
+	struct dentry *wep_interrupt;
+
+	struct dentry *pwr_ps_enter;
+	struct dentry *pwr_elp_enter;
+	struct dentry *pwr_missing_bcns;
+	struct dentry *pwr_wake_on_host;
+	struct dentry *pwr_wake_on_timer_exp;
+	struct dentry *pwr_tx_with_ps;
+	struct dentry *pwr_tx_without_ps;
+	struct dentry *pwr_rcvd_beacons;
+	struct dentry *pwr_power_save_off;
+	struct dentry *pwr_enable_ps;
+	struct dentry *pwr_disable_ps;
+	struct dentry *pwr_fix_tsf_ps;
+	/* skipping cont_miss_bcns_spread for now */
+	struct dentry *pwr_rcvd_awake_beacons;
+
+	struct dentry *mic_rx_pkts;
+	struct dentry *mic_calc_failure;
+
+	struct dentry *aes_encrypt_fail;
+	struct dentry *aes_decrypt_fail;
+	struct dentry *aes_encrypt_packets;
+	struct dentry *aes_decrypt_packets;
+	struct dentry *aes_encrypt_interrupt;
+	struct dentry *aes_decrypt_interrupt;
+
+	struct dentry *event_heart_beat;
+	struct dentry *event_calibration;
+	struct dentry *event_rx_mismatch;
+	struct dentry *event_rx_mem_empty;
+	struct dentry *event_rx_pool;
+	struct dentry *event_oom_late;
+	struct dentry *event_phy_transmit_error;
+	struct dentry *event_tx_stuck;
+
+	struct dentry *ps_pspoll_timeouts;
+	struct dentry *ps_upsd_timeouts;
+	struct dentry *ps_upsd_max_sptime;
+	struct dentry *ps_upsd_max_apturn;
+	struct dentry *ps_pspoll_max_apturn;
+	struct dentry *ps_pspoll_utilization;
+	struct dentry *ps_upsd_utilization;
+
+	struct dentry *rxpipe_rx_prep_beacon_drop;
+	struct dentry *rxpipe_descr_host_int_trig_rx_data;
+	struct dentry *rxpipe_beacon_buffer_thres_host_int_trig_rx_data;
+	struct dentry *rxpipe_missed_beacon_host_int_trig_rx_data;
+	struct dentry *rxpipe_tx_xfr_host_int_trig_rx_data;
 
-struct wl1271_acx_config_memory {
-	struct acx_header header;
+	struct dentry *tx_queue_len;
 
-	u8 rx_mem_block_num;
-	u8 tx_min_mem_block_num;
-	u8 num_stations;
-	u8 num_ssid_profiles;
-	u32 total_tx_descriptors;
+	struct dentry *retry_count;
+	struct dentry *excessive_retries;
 };
 
-struct wl1271_tx_result_pointers {
-	u32 *control_block; /* Points to an array with two u32 entries:
-			       [0] result entries written by the FW
-			       [1] result entries read by the host */
+#define NUM_TX_QUEUES              4
+#define NUM_RX_PKT_DESC            8
 
-	void *tx_results_queue_start; /* points t first descriptor in TRQ */
+/* FW status registers */
+struct wl1271_fw_status {
+	u32 intr;
+	u8  fw_rx_counter;
+	u8  drv_rx_counter;
+	u8  reserved;
+	u8  tx_results_counter;
+	u32 rx_pkt_descs[NUM_RX_PKT_DESC];
+	u32 tx_released_blks[NUM_TX_QUEUES];
+	u32 fw_localtime;
+	u32 padding[2];
 } __attribute__ ((packed));
 
-struct wl1271_acx_mem_map {
-	struct acx_header header;
+struct wl1271_rx_mem_pool_addr {
+	u32 addr;
+	u32 addr_extra;
+};
+
+struct wl1271 {
+	struct ieee80211_hw *hw;
+	bool mac80211_registered;
 
-	void *code_start;
-	void *code_end;
+	struct spi_device *spi;
 
-	void *wep_defkey_start;
-	void *wep_defkey_end;
+	void (*set_power)(bool enable);
+	int irq;
 
-	void *sta_table_start;
-	void *sta_table_end;
+	spinlock_t wl_lock;
 
-	void *packet_template_start;
-	void *packet_template_end;
+	enum wl1271_state state;
+	struct mutex mutex;
 
-	struct wl1271_tx_result_pointers tx_result;
+	int physical_mem_addr;
+	int physical_reg_addr;
+	int virtual_mem_addr;
+	int virtual_reg_addr;
 
-	void *queue_memory_start;
-	void *queue_memory_end;
+	struct wl1271_chip chip;
 
-	void *packet_memory_pool_start;
-	void *packet_memory_pool_end;
+	int cmd_box_addr;
+	int event_box_addr;
 
-	void *debug_buffer1_start;
-	void *debug_buffer1_end;
+	u8 *fw;
+	size_t fw_len;
+	u8 *nvs;
+	size_t nvs_len;
 
-	void *debug_buffer2_start;
-	void *debug_buffer2_end;
+	u8 bssid[ETH_ALEN];
+	u8 mac_addr[ETH_ALEN];
+	u8 bss_type;
+	u8 ssid[IW_ESSID_MAX_SIZE + 1];
+	u8 ssid_len;
+	u8 listen_int;
+	int channel;
 
-	/* Number of blocks FW allocated for TX packets */
-	u32 num_tx_mem_blocks;
+	struct wl1271_acx_mem_map *target_mem_map;
 
-	/* Number of blocks FW allocated for RX packets */
-	u32 num_rx_mem_blocks;
+	/* Accounting for allocated / available TX blocks on HW */
+	u32 tx_blocks_freed[NUM_TX_QUEUES];
+	u32 tx_blocks_available;
+	u8 tx_results_count;
 
-	/* the following 4 fields are valid in SLAVE mode only */
-	u8 *tx_cbuf;
-	u8 *rx_cbuf;
-	void *rx_ctrl;
-	void *tx_ctrl;
-} __attribute__ ((packed));
+	/* Transmitted TX packets counter for chipset interface */
+	int tx_packets_count;
+
+	/* Time-offset between host and chipset clocks */
+	int time_offset;
 
-struct wl1271_tx_config_opt {
-	struct acx_header header;
+	/* Session counter for the chipset */
+	int session_counter;
 
-	u16 threshold;
-	u16 timeout;
+	/* Frames scheduled for transmission, not handled yet */
+	struct sk_buff_head tx_queue;
+	bool tx_queue_stopped;
+
+	struct work_struct tx_work;
+	struct work_struct filter_work;
+
+	/* Pending TX frames */
+	struct sk_buff *tx_frames[16];
+
+	/* FW Rx counter */
+	u32 rx_counter;
+
+	/* Rx memory pool address */
+	struct wl1271_rx_mem_pool_addr rx_mem_pool_addr;
+
+	/* The target interrupt mask */
+	struct work_struct irq_work;
+
+	/* The mbox event mask */
+	u32 event_mask;
+
+	/* Mailbox pointers */
+	u32 mbox_ptr[2];
+
+	/* Are we currently scanning */
+	bool scanning;
+
+	/* Our association ID */
+	u16 aid;
+
+	/* Default key (for WEP) */
+	u32 default_key;
+
+	unsigned int rx_config;
+	unsigned int rx_filter;
+
+	/* is firmware in elp mode */
+	bool elp;
+
+	struct completion *elp_compl;
+
+	/* we can be in psm, but not in elp, we have to differentiate */
+	bool psm;
+
+	/* PSM mode requested */
+	bool psm_requested;
+
+	/* in dBm */
+	int power_level;
+
+	struct wl1271_stats stats;
+	struct wl1271_debugfs debugfs;
+
+	u32 buffer_32;
+	u32 buffer_cmd;
+	u8 buffer_busyword[WL1271_BUSY_WORD_LEN];
+	struct wl1271_rx_descriptor *rx_descriptor;
+
+	struct wl1271_fw_status *fw_status;
+	struct wl1271_tx_hw_res_if *tx_res_if;
 };
 
-enum wl1271_rx_queue_type {
-	RX_QUEUE_TYPE_RX_LOW_PRIORITY,    /* All except the high priority */
-	RX_QUEUE_TYPE_RX_HIGH_PRIORITY,   /* Management and voice packets */
-	RX_QUEUE_TYPE_NUM,
-	RX_QUEUE_TYPE_MAX = USHORT_MAX
-};
-
-struct wl1271_rx_config_opt {
-	struct acx_header header;
-
-	u16 mblk_threshold;
-	u16 threshold;
-	u16 timeout;
-	enum wl1271_rx_queue_type queue_type;
-	u8 reserved;
-};
-
-/* WL1271-specific registers and other defines */
-#define CMD_MBOX_ADDRESS     0x407B4
-#define REF_CLOCK            2
-#define PLL_PARAMETERS       (REGISTERS_BASE + 0x6040)
-#define WU_COUNTER_PAUSE     (REGISTERS_BASE + 0x6008)
-#define WELP_ARM_COMMAND     (REGISTERS_BASE + 0x6100)
-#define WU_COUNTER_PAUSE_VAL 0x3FF
-#define WELP_ARM_COMMAND_VAL 0x4
-#define DRPW_SCRATCH_START   (DRPW_BASE + 0x002C)
-
-#define ACX_TX_CONFIG_OPT    0x24
-#define ACX_RX_CONFIG_OPT    0x4E
-
-#define ACX_RX_MEM_BLOCKS     64
-#define ACX_TX_MIN_MEM_BLOCKS 64
-#define ACX_TX_DESCRIPTORS    32
-#define ACX_NUM_SSID_PROFILES 1
+int wl1271_plt_start(struct wl1271 *wl);
+int wl1271_plt_stop(struct wl1271 *wl);
 
-/*
- * Tx and Rx interrupts pacing (threshold in packets, timeouts in milliseconds)
- */
-#define WL1271_TX_CMPLT_THRESHOLD_DEF 0       /* no pacing, send interrupt on
-					       * every event */
-#define WL1271_TX_CMPLT_THRESHOLD_MIN 0
-#define WL1271_TX_CMPLT_THRESHOLD_MAX 15
-
-#define WL1271_TX_CMPLT_TIMEOUT_DEF   5
-#define WL1271_TX_CMPLT_TIMEOUT_MIN   1
-#define WL1271_TX_CMPLT_TIMEOUT_MAX   100
-
-#define WL1271_RX_INTR_THRESHOLD_DEF  0       /* no pacing, send interrupt on
-					       * every event */
-#define WL1271_RX_INTR_THRESHOLD_MIN  0
-#define WL1271_RX_INTR_THRESHOLD_MAX  15
-
-#define WL1271_RX_INTR_TIMEOUT_DEF    5
-#define WL1271_RX_INTR_TIMEOUT_MIN    1
-#define WL1271_RX_INTR_TIMEOUT_MAX    100
-
-/*************************************************************************
-
-    Host Interrupt Register (WiLink -> Host)
-
-**************************************************************************/
-/* HW Initiated interrupt Watchdog timer expiration */
-#define WL1271_ACX_INTR_WATCHDOG           BIT(0)
-/* Init sequence is done (masked interrupt, detection through polling only ) */
-#define WL1271_ACX_INTR_INIT_COMPLETE      BIT(1)
-/* Event was entered to Event MBOX #A*/
-#define WL1271_ACX_INTR_EVENT_A            BIT(2)
-/* Event was entered to Event MBOX #B*/
-#define WL1271_ACX_INTR_EVENT_B            BIT(3)
-/* Command processing completion*/
-#define WL1271_ACX_INTR_CMD_COMPLETE       BIT(4)
-/* Signaling the host on HW wakeup */
-#define WL1271_ACX_INTR_HW_AVAILABLE       BIT(5)
-/* The MISC bit is used for aggregation of RX, TxComplete and TX rate update */
-#define WL1271_ACX_INTR_DATA               BIT(6)
-/* Trace meassge on MBOX #A */
-#define WL1271_ACX_INTR_TRACE_A            BIT(7)
-/* Trace meassge on MBOX #B */
-#define WL1271_ACX_INTR_TRACE_B            BIT(8)
+#define JOIN_TIMEOUT 5000 /* 5000 milliseconds to join */
 
-#define WL1271_ACX_INTR_ALL                0xFFFFFFFF
+#define SESSION_COUNTER_MAX 7 /* maximum value for the session counter */
 
+#define WL1271_DEFAULT_POWER_LEVEL 0
+
+#define WL1271_TX_QUEUE_MAX_LENGTH 20
+
+/* WL1271 needs a 200ms sleep after power on */
+#define WL1271_POWER_ON_SLEEP 200 /* in miliseconds */
 
 #endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_init.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_init.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_init.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_init.c	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,397 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include "wl1271_init.h"
+#include "wl12xx_80211.h"
+#include "wl1271_acx.h"
+#include "wl1271_cmd.h"
+#include "wl1271_reg.h"
+
+static int wl1271_init_hwenc_config(struct wl1271 *wl)
+{
+	int ret;
+
+	ret = wl1271_acx_feature_cfg(wl);
+	if (ret < 0) {
+		wl1271_warning("couldn't set feature config");
+		return ret;
+	}
+
+	ret = wl1271_cmd_set_default_wep_key(wl, wl->default_key);
+	if (ret < 0) {
+		wl1271_warning("couldn't set default key");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int wl1271_init_templates_config(struct wl1271 *wl)
+{
+	int ret;
+
+	/* send empty templates for fw memory reservation */
+	ret = wl1271_cmd_template_set(wl, CMD_TEMPL_CFG_PROBE_REQ_2_4, NULL,
+				      sizeof(struct wl12xx_probe_req_template));
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_cmd_template_set(wl, CMD_TEMPL_NULL_DATA, NULL,
+				      sizeof(struct wl12xx_null_data_template));
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_cmd_template_set(wl, CMD_TEMPL_PS_POLL, NULL,
+				      sizeof(struct wl12xx_ps_poll_template));
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_cmd_template_set(wl, CMD_TEMPL_QOS_NULL_DATA, NULL,
+				      sizeof
+				      (struct wl12xx_qos_null_data_template));
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_cmd_template_set(wl, CMD_TEMPL_PROBE_RESPONSE, NULL,
+				      sizeof
+				      (struct wl12xx_probe_resp_template));
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_cmd_template_set(wl, CMD_TEMPL_BEACON, NULL,
+				      sizeof
+				      (struct wl12xx_beacon_template));
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int wl1271_init_rx_config(struct wl1271 *wl, u32 config, u32 filter)
+{
+	int ret;
+
+	ret = wl1271_acx_rx_msdu_life_time(wl, RX_MSDU_LIFETIME_DEF);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_acx_rx_config(wl, config, filter);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int wl1271_init_phy_config(struct wl1271 *wl)
+{
+	int ret;
+
+	ret = wl1271_acx_pd_threshold(wl);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_acx_slot(wl, DEFAULT_SLOT_TIME);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_acx_group_address_tbl(wl);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_acx_service_period_timeout(wl);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_acx_rts_threshold(wl, RTS_THRESHOLD_DEF);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int wl1271_init_beacon_filter(struct wl1271 *wl)
+{
+	int ret;
+
+	ret = wl1271_acx_beacon_filter_opt(wl);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_acx_beacon_filter_table(wl);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int wl1271_init_pta(struct wl1271 *wl)
+{
+	int ret;
+
+	ret = wl1271_acx_sg_enable(wl);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_acx_sg_cfg(wl);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int wl1271_init_energy_detection(struct wl1271 *wl)
+{
+	int ret;
+
+	ret = wl1271_acx_cca_threshold(wl);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int wl1271_init_beacon_broadcast(struct wl1271 *wl)
+{
+	int ret;
+
+	ret = wl1271_acx_bcn_dtim_options(wl);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int wl1271_init_general_parms(struct wl1271 *wl)
+{
+	struct wl1271_general_parms *gen_parms;
+	int ret;
+
+	gen_parms = kzalloc(sizeof(*gen_parms), GFP_KERNEL);
+	if (!gen_parms)
+		return -ENOMEM;
+
+	gen_parms->id = TEST_CMD_INI_FILE_GENERAL_PARAM;
+
+	gen_parms->ref_clk = REF_CLK_38_4_E;
+	/* FIXME: magic numbers */
+	gen_parms->settling_time = 5;
+	gen_parms->clk_valid_on_wakeup = 0;
+	gen_parms->dc2dcmode = 0;
+	gen_parms->single_dual_band = 0;
+	gen_parms->tx_bip_fem_autodetect = 1;
+	gen_parms->tx_bip_fem_manufacturer = 1;
+	gen_parms->settings = 1;
+
+	ret = wl1271_cmd_test(wl, gen_parms, sizeof(*gen_parms), 0);
+	if (ret < 0) {
+		wl1271_warning("CMD_INI_FILE_GENERAL_PARAM failed");
+		return ret;
+	}
+
+	kfree(gen_parms);
+	return 0;
+}
+
+static int wl1271_init_radio_parms(struct wl1271 *wl)
+{
+	/*
+	 * FIXME: All these magic numbers should be moved to some place where
+	 * they can be configured (separate file?)
+	 */
+
+	struct wl1271_radio_parms *radio_parms;
+	int ret;
+	u8 compensation[] = { 0xec, 0xf6, 0x00, 0x0c, 0x18, 0xf8, 0xfc, 0x00,
+			      0x08, 0x10, 0xf0, 0xf8, 0x00, 0x0a, 0x14 };
+
+	u8 tx_rate_limits_normal[]   = { 0x1e, 0x1f, 0x22, 0x24, 0x28, 0x29 };
+	u8 tx_rate_limits_degraded[] = { 0x1b, 0x1c, 0x1e, 0x20, 0x24, 0x25 };
+
+	u8 tx_channel_limits_11b[] = { 0x22, 0x50, 0x50, 0x50,
+				       0x50, 0x50, 0x50, 0x50,
+				       0x50, 0x50, 0x22, 0x50,
+				       0x22, 0x50 };
+
+	u8 tx_channel_limits_ofdm[] = { 0x20, 0x50, 0x50, 0x50,
+					0x50, 0x50, 0x50, 0x50,
+					0x50, 0x50, 0x20, 0x50,
+					0x20, 0x50 };
+
+	u8 tx_pdv_rate_offsets[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+	u8 tx_ibias[] = { 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x27 };
+
+	radio_parms = kzalloc(sizeof(*radio_parms), GFP_KERNEL);
+	if (!radio_parms)
+		return -ENOMEM;
+
+	radio_parms->id = TEST_CMD_INI_FILE_RADIO_PARAM;
+
+	/* Static radio parameters */
+	radio_parms->rx_trace_loss = 10;
+	radio_parms->tx_trace_loss = 10;
+	memcpy(radio_parms->rx_rssi_and_proc_compens, compensation,
+	       sizeof(compensation));
+
+	/* We don't set the 5GHz -- N/A */
+
+	/* Dynamic radio parameters */
+	radio_parms->tx_ref_pd_voltage = cpu_to_le16(0x24e);
+	radio_parms->tx_ref_power = 0x78;
+	radio_parms->tx_offset_db = 0x0;
+
+	memcpy(radio_parms->tx_rate_limits_normal, tx_rate_limits_normal,
+	       sizeof(tx_rate_limits_normal));
+	memcpy(radio_parms->tx_rate_limits_degraded, tx_rate_limits_degraded,
+	       sizeof(tx_rate_limits_degraded));
+
+	memcpy(radio_parms->tx_channel_limits_11b, tx_channel_limits_11b,
+	       sizeof(tx_channel_limits_11b));
+	memcpy(radio_parms->tx_channel_limits_ofdm, tx_channel_limits_ofdm,
+	       sizeof(tx_channel_limits_ofdm));
+	memcpy(radio_parms->tx_pdv_rate_offsets, tx_pdv_rate_offsets,
+	       sizeof(tx_pdv_rate_offsets));
+	memcpy(radio_parms->tx_ibias, tx_ibias,
+	       sizeof(tx_ibias));
+
+	radio_parms->rx_fem_insertion_loss = 0x14;
+
+	ret = wl1271_cmd_test(wl, radio_parms, sizeof(*radio_parms), 0);
+	if (ret < 0)
+		wl1271_warning("CMD_INI_FILE_RADIO_PARAM failed");
+
+	kfree(radio_parms);
+	return ret;
+}
+
+int wl1271_hw_init(struct wl1271 *wl)
+{
+	int ret;
+
+	ret = wl1271_init_general_parms(wl);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_init_radio_parms(wl);
+	if (ret < 0)
+		return ret;
+
+	/* Template settings */
+	ret = wl1271_init_templates_config(wl);
+	if (ret < 0)
+		return ret;
+
+	/* Default memory configuration */
+	ret = wl1271_acx_init_mem_config(wl);
+	if (ret < 0)
+		return ret;
+
+	/* RX config */
+	ret = wl1271_init_rx_config(wl,
+				       RX_CFG_PROMISCUOUS | RX_CFG_TSF,
+				       RX_FILTER_OPTION_DEF);
+	/* RX_CONFIG_OPTION_ANY_DST_ANY_BSS,
+	   RX_FILTER_OPTION_FILTER_ALL); */
+	if (ret < 0)
+		goto out_free_memmap;
+
+	/* PHY layer config */
+	ret = wl1271_init_phy_config(wl);
+	if (ret < 0)
+		goto out_free_memmap;
+
+	/* Beacon filtering */
+	ret = wl1271_init_beacon_filter(wl);
+	if (ret < 0)
+		goto out_free_memmap;
+
+	/* Configure TX patch complete interrupt behavior */
+	ret = wl1271_acx_tx_config_options(wl);
+	if (ret < 0)
+		goto out_free_memmap;
+
+	/* RX complete interrupt pacing */
+	ret = wl1271_acx_init_rx_interrupt(wl);
+	if (ret < 0)
+		goto out_free_memmap;
+
+	/* Bluetooth WLAN coexistence */
+	ret = wl1271_init_pta(wl);
+	if (ret < 0)
+		goto out_free_memmap;
+
+	/* Energy detection */
+	ret = wl1271_init_energy_detection(wl);
+	if (ret < 0)
+		goto out_free_memmap;
+
+	/* Beacons and boradcast settings */
+	ret = wl1271_init_beacon_broadcast(wl);
+	if (ret < 0)
+		goto out_free_memmap;
+
+	/* Default fragmentation threshold */
+	ret = wl1271_acx_frag_threshold(wl);
+	if (ret < 0)
+		goto out_free_memmap;
+
+	/* Default TID configuration */
+	ret = wl1271_acx_tid_cfg(wl);
+	if (ret < 0)
+		goto out_free_memmap;
+
+	/* Default AC configuration */
+	ret = wl1271_acx_ac_cfg(wl);
+	if (ret < 0)
+		goto out_free_memmap;
+
+	/* Configure TX rate classes */
+	ret = wl1271_acx_rate_policies(wl);
+	if (ret < 0)
+		goto out_free_memmap;
+
+	/* Enable data path */
+	ret = wl1271_cmd_data_path(wl, wl->channel, 1);
+	if (ret < 0)
+		goto out_free_memmap;
+
+	/* Configure for ELP power saving */
+	ret = wl1271_acx_sleep_auth(wl, WL1271_PSM_ELP);
+	if (ret < 0)
+		goto out_free_memmap;
+
+	/* Configure HW encryption */
+	ret = wl1271_init_hwenc_config(wl);
+	if (ret < 0)
+		goto out_free_memmap;
+
+	return 0;
+
+ out_free_memmap:
+	kfree(wl->target_mem_map);
+
+	return ret;
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_init.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_init.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_init.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_init.h	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,115 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __WL1271_INIT_H__
+#define __WL1271_INIT_H__
+
+#include "wl1271.h"
+
+int wl1271_hw_init_power_auth(struct wl1271 *wl);
+int wl1271_hw_init(struct wl1271 *wl);
+
+/* These are not really a TEST_CMD, but the ref driver uses them as such */
+#define TEST_CMD_INI_FILE_RADIO_PARAM   0x19
+#define TEST_CMD_INI_FILE_GENERAL_PARAM 0x1E
+
+struct wl1271_general_parms {
+	u8 id;
+	u8 padding[3];
+
+	u8 ref_clk;
+	u8 settling_time;
+	u8 clk_valid_on_wakeup;
+	u8 dc2dcmode;
+	u8 single_dual_band;
+
+	u8 tx_bip_fem_autodetect;
+	u8 tx_bip_fem_manufacturer;
+	u8 settings;
+} __attribute__ ((packed));
+
+enum ref_clk_enum {
+	REF_CLK_19_2_E,
+	REF_CLK_26_E,
+	REF_CLK_38_4_E,
+	REF_CLK_52_E
+};
+
+#define RSSI_AND_PROCESS_COMPENSATION_SIZE 15
+#define NUMBER_OF_SUB_BANDS_5  7
+#define NUMBER_OF_RATE_GROUPS  6
+#define NUMBER_OF_CHANNELS_2_4 14
+#define NUMBER_OF_CHANNELS_5   35
+
+struct wl1271_radio_parms {
+	u8 id;
+	u8 padding[3];
+
+	/* Static radio parameters */
+	/* 2.4GHz */
+	u8 rx_trace_loss;
+	u8 tx_trace_loss;
+	s8 rx_rssi_and_proc_compens[RSSI_AND_PROCESS_COMPENSATION_SIZE];
+
+	/* 5GHz */
+	u8 rx_trace_loss_5[NUMBER_OF_SUB_BANDS_5];
+	u8 tx_trace_loss_5[NUMBER_OF_SUB_BANDS_5];
+	s8 rx_rssi_and_proc_compens_5[RSSI_AND_PROCESS_COMPENSATION_SIZE];
+
+	/* Dynamic radio parameters */
+	/* 2.4GHz */
+	s16 tx_ref_pd_voltage;
+	s8  tx_ref_power;
+	s8  tx_offset_db;
+
+	s8  tx_rate_limits_normal[NUMBER_OF_RATE_GROUPS];
+	s8  tx_rate_limits_degraded[NUMBER_OF_RATE_GROUPS];
+
+	s8  tx_channel_limits_11b[NUMBER_OF_CHANNELS_2_4];
+	s8  tx_channel_limits_ofdm[NUMBER_OF_CHANNELS_2_4];
+	s8  tx_pdv_rate_offsets[NUMBER_OF_RATE_GROUPS];
+
+	u8  tx_ibias[NUMBER_OF_RATE_GROUPS];
+	u8  rx_fem_insertion_loss;
+
+	u8 padding2;
+
+	/* 5GHz */
+	s16 tx_ref_pd_voltage_5[NUMBER_OF_SUB_BANDS_5];
+	s8  tx_ref_power_5[NUMBER_OF_SUB_BANDS_5];
+	s8  tx_offset_db_5[NUMBER_OF_SUB_BANDS_5];
+
+	s8  tx_rate_limits_normal_5[NUMBER_OF_RATE_GROUPS];
+	s8  tx_rate_limits_degraded_5[NUMBER_OF_RATE_GROUPS];
+
+	s8  tx_channel_limits_ofdm_5[NUMBER_OF_CHANNELS_5];
+	s8  tx_pdv_rate_offsets_5[NUMBER_OF_RATE_GROUPS];
+
+	/* FIXME: this is inconsistent with the types for 2.4GHz */
+	s8  tx_ibias_5[NUMBER_OF_RATE_GROUPS];
+	s8  rx_fem_insertion_loss_5[NUMBER_OF_SUB_BANDS_5];
+
+	u8 padding3[2];
+} __attribute__ ((packed));
+
+#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_main.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_main.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_main.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_main.c	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,1390 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (C) 2008-2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/spi/spi.h>
+#include <linux/crc32.h>
+#include <linux/etherdevice.h>
+#include <linux/spi/wl12xx.h>
+
+#include "wl1271.h"
+#include "wl12xx_80211.h"
+#include "wl1271_reg.h"
+#include "wl1271_spi.h"
+#include "wl1271_event.h"
+#include "wl1271_tx.h"
+#include "wl1271_rx.h"
+#include "wl1271_ps.h"
+#include "wl1271_init.h"
+#include "wl1271_netlink.h"
+#include "wl1271_debugfs.h"
+#include "wl1271_cmd.h"
+#include "wl1271_boot.h"
+
+static int wl1271_plt_init(struct wl1271 *wl)
+{
+	int ret;
+
+	ret = wl1271_acx_init_mem_config(wl);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_cmd_data_path(wl, wl->channel, 1);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void wl1271_disable_interrupts(struct wl1271 *wl)
+{
+	disable_irq(wl->irq);
+}
+
+static void wl1271_power_off(struct wl1271 *wl)
+{
+	wl->set_power(false);
+}
+
+static void wl1271_power_on(struct wl1271 *wl)
+{
+	wl->set_power(true);
+}
+
+static void wl1271_fw_status(struct wl1271 *wl, struct wl1271_fw_status *status)
+{
+	u32 total = 0;
+	int i;
+
+	/*
+	 * FIXME: Reading the FW status directly from the registers seems to
+	 * be the right thing to do, but it doesn't work.  And in the
+	 * reference driver, there is a workaround called
+	 * USE_SDIO_24M_WORKAROUND, which reads the status from memory
+	 * instead, so we do the same here.
+	 */
+
+	wl1271_spi_mem_read(wl, STATUS_MEM_ADDRESS, status, sizeof(*status));
+
+	wl1271_debug(DEBUG_IRQ, "intr: 0x%x (fw_rx_counter = %d, "
+		     "drv_rx_counter = %d, tx_results_counter = %d)",
+		     status->intr,
+		     status->fw_rx_counter,
+		     status->drv_rx_counter,
+		     status->tx_results_counter);
+
+	/* update number of available TX blocks */
+	for (i = 0; i < NUM_TX_QUEUES; i++) {
+		u32 cnt = status->tx_released_blks[i] - wl->tx_blocks_freed[i];
+		wl->tx_blocks_freed[i] = status->tx_released_blks[i];
+		wl->tx_blocks_available += cnt;
+		total += cnt;
+	}
+
+	/* if more blocks are available now, schedule some tx work */
+	if (total && !skb_queue_empty(&wl->tx_queue))
+		schedule_work(&wl->tx_work);
+
+	/* update the host-chipset time offset */
+	wl->time_offset = jiffies_to_usecs(jiffies) - status->fw_localtime;
+}
+
+#define WL1271_IRQ_MAX_LOOPS 10
+static void wl1271_irq_work(struct work_struct *work)
+{
+	u32 intr, ctr = WL1271_IRQ_MAX_LOOPS;
+	int ret;
+	struct wl1271 *wl =
+		container_of(work, struct wl1271, irq_work);
+
+	mutex_lock(&wl->mutex);
+
+	wl1271_debug(DEBUG_IRQ, "IRQ work");
+
+	if (wl->state == WL1271_STATE_OFF)
+		goto out;
+
+	ret = wl1271_ps_elp_wakeup(wl, true);
+	if (ret < 0)
+		goto out;
+
+	wl1271_reg_write32(wl, ACX_REG_INTERRUPT_MASK, WL1271_ACX_INTR_ALL);
+
+	intr = wl1271_reg_read32(wl, ACX_REG_INTERRUPT_CLEAR);
+	if (!intr) {
+		wl1271_debug(DEBUG_IRQ, "Zero interrupt received.");
+		goto out_sleep;
+	}
+
+	intr &= WL1271_INTR_MASK;
+
+	do {
+		wl1271_fw_status(wl, wl->fw_status);
+
+
+		if (intr & (WL1271_ACX_INTR_EVENT_A |
+			    WL1271_ACX_INTR_EVENT_B)) {
+			wl1271_debug(DEBUG_IRQ,
+				     "WL1271_ACX_INTR_EVENT (0x%x)", intr);
+			if (intr & WL1271_ACX_INTR_EVENT_A)
+				wl1271_event_handle(wl, 0);
+			else
+				wl1271_event_handle(wl, 1);
+		}
+
+		if (intr & WL1271_ACX_INTR_INIT_COMPLETE)
+			wl1271_debug(DEBUG_IRQ,
+				     "WL1271_ACX_INTR_INIT_COMPLETE");
+
+		if (intr & WL1271_ACX_INTR_HW_AVAILABLE)
+			wl1271_debug(DEBUG_IRQ, "WL1271_ACX_INTR_HW_AVAILABLE");
+
+		if (intr & WL1271_ACX_INTR_DATA) {
+			u8 tx_res_cnt = wl->fw_status->tx_results_counter -
+				wl->tx_results_count;
+
+			wl1271_debug(DEBUG_IRQ, "WL1271_ACX_INTR_DATA");
+
+			/* check for tx results */
+			if (tx_res_cnt)
+				wl1271_tx_complete(wl, tx_res_cnt);
+
+			wl1271_rx(wl, wl->fw_status);
+		}
+
+		intr = wl1271_reg_read32(wl, ACX_REG_INTERRUPT_CLEAR);
+		intr &= WL1271_INTR_MASK;
+	} while (intr && --ctr);
+
+out_sleep:
+	wl1271_reg_write32(wl, ACX_REG_INTERRUPT_MASK, ~(WL1271_INTR_MASK));
+	wl1271_ps_elp_sleep(wl);
+
+out:
+	mutex_unlock(&wl->mutex);
+}
+
+static irqreturn_t wl1271_irq(int irq, void *cookie)
+{
+	struct wl1271 *wl;
+	unsigned long flags;
+
+	wl1271_debug(DEBUG_IRQ, "IRQ");
+
+	wl = cookie;
+
+	/* complete the ELP completion */
+	spin_lock_irqsave(&wl->wl_lock, flags);
+	if (wl->elp_compl) {
+		complete(wl->elp_compl);
+		wl->elp_compl = NULL;
+	}
+
+	schedule_work(&wl->irq_work);
+	spin_unlock_irqrestore(&wl->wl_lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static int wl1271_fetch_firmware(struct wl1271 *wl)
+{
+	const struct firmware *fw;
+	int ret;
+
+	ret = request_firmware(&fw, WL1271_FW_NAME, &wl->spi->dev);
+
+	if (ret < 0) {
+		wl1271_error("could not get firmware: %d", ret);
+		return ret;
+	}
+
+	if (fw->size % 4) {
+		wl1271_error("firmware size is not multiple of 32 bits: %zu",
+			     fw->size);
+		ret = -EILSEQ;
+		goto out;
+	}
+
+	wl->fw_len = fw->size;
+	wl->fw = kmalloc(wl->fw_len, GFP_KERNEL);
+
+	if (!wl->fw) {
+		wl1271_error("could not allocate memory for the firmware");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	memcpy(wl->fw, fw->data, wl->fw_len);
+
+	ret = 0;
+
+out:
+	release_firmware(fw);
+
+	return ret;
+}
+
+static int wl1271_fetch_nvs(struct wl1271 *wl)
+{
+	const struct firmware *fw;
+	int ret;
+
+	ret = request_firmware(&fw, WL1271_NVS_NAME, &wl->spi->dev);
+
+	if (ret < 0) {
+		wl1271_error("could not get nvs file: %d", ret);
+		return ret;
+	}
+
+	if (fw->size % 4) {
+		wl1271_error("nvs size is not multiple of 32 bits: %zu",
+			     fw->size);
+		ret = -EILSEQ;
+		goto out;
+	}
+
+	wl->nvs_len = fw->size;
+	wl->nvs = kmalloc(wl->nvs_len, GFP_KERNEL);
+
+	if (!wl->nvs) {
+		wl1271_error("could not allocate memory for the nvs file");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	memcpy(wl->nvs, fw->data, wl->nvs_len);
+
+	ret = 0;
+
+out:
+	release_firmware(fw);
+
+	return ret;
+}
+
+static void wl1271_fw_wakeup(struct wl1271 *wl)
+{
+	u32 elp_reg;
+
+	elp_reg = ELPCTRL_WAKE_UP;
+	wl1271_write32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, elp_reg);
+}
+
+static int wl1271_setup(struct wl1271 *wl)
+{
+	wl->fw_status = kmalloc(sizeof(*wl->fw_status), GFP_KERNEL);
+	if (!wl->fw_status)
+		return -ENOMEM;
+
+	wl->tx_res_if = kmalloc(sizeof(*wl->tx_res_if), GFP_KERNEL);
+	if (!wl->tx_res_if) {
+		kfree(wl->fw_status);
+		return -ENOMEM;
+	}
+
+	INIT_WORK(&wl->irq_work, wl1271_irq_work);
+	INIT_WORK(&wl->tx_work, wl1271_tx_work);
+	return 0;
+}
+
+static int wl1271_chip_wakeup(struct wl1271 *wl)
+{
+	int ret = 0;
+
+	wl1271_power_on(wl);
+	msleep(WL1271_POWER_ON_SLEEP);
+	wl1271_spi_reset(wl);
+	wl1271_spi_init(wl);
+
+	/* We don't need a real memory partition here, because we only want
+	 * to use the registers at this point. */
+	wl1271_set_partition(wl,
+			     0x00000000,
+			     0x00000000,
+			     REGISTERS_BASE,
+			     REGISTERS_DOWN_SIZE);
+
+	/* ELP module wake up */
+	wl1271_fw_wakeup(wl);
+
+	/* whal_FwCtrl_BootSm() */
+
+	/* 0. read chip id from CHIP_ID */
+	wl->chip.id = wl1271_reg_read32(wl, CHIP_ID_B);
+
+	/* 1. check if chip id is valid */
+
+	switch (wl->chip.id) {
+	case CHIP_ID_1271_PG10:
+		wl1271_warning("chip id 0x%x (1271 PG10) support is obsolete",
+			       wl->chip.id);
+
+		ret = wl1271_setup(wl);
+		if (ret < 0)
+			goto out;
+		break;
+	case CHIP_ID_1271_PG20:
+		wl1271_debug(DEBUG_BOOT, "chip id 0x%x (1271 PG20)",
+			     wl->chip.id);
+
+		ret = wl1271_setup(wl);
+		if (ret < 0)
+			goto out;
+		break;
+	default:
+		wl1271_error("unsupported chip id: 0x%x", wl->chip.id);
+		ret = -ENODEV;
+		goto out;
+	}
+
+	if (wl->fw == NULL) {
+		ret = wl1271_fetch_firmware(wl);
+		if (ret < 0)
+			goto out;
+	}
+
+	/* No NVS from netlink, try to get it from the filesystem */
+	if (wl->nvs == NULL) {
+		ret = wl1271_fetch_nvs(wl);
+		if (ret < 0)
+			goto out;
+	}
+
+out:
+	return ret;
+}
+
+static void wl1271_filter_work(struct work_struct *work)
+{
+	struct wl1271 *wl =
+		container_of(work, struct wl1271, filter_work);
+	int ret;
+
+	mutex_lock(&wl->mutex);
+
+	if (wl->state == WL1271_STATE_OFF)
+		goto out;
+
+	ret = wl1271_ps_elp_wakeup(wl, false);
+	if (ret < 0)
+		goto out;
+
+	/* FIXME: replace the magic numbers with proper definitions */
+	ret = wl1271_cmd_join(wl, wl->bss_type, 1, 100, 0);
+	if (ret < 0)
+		goto out_sleep;
+
+out_sleep:
+	wl1271_ps_elp_sleep(wl);
+
+out:
+	mutex_unlock(&wl->mutex);
+}
+
+int wl1271_plt_start(struct wl1271 *wl)
+{
+	int ret;
+
+	mutex_lock(&wl->mutex);
+
+	wl1271_notice("power up");
+
+	if (wl->state != WL1271_STATE_OFF) {
+		wl1271_error("cannot go into PLT state because not "
+			     "in off state: %d", wl->state);
+		ret = -EBUSY;
+		goto out;
+	}
+
+	wl->state = WL1271_STATE_PLT;
+
+	ret = wl1271_chip_wakeup(wl);
+	if (ret < 0)
+		goto out;
+
+	ret = wl1271_boot(wl);
+	if (ret < 0)
+		goto out;
+
+	wl1271_notice("firmware booted in PLT mode (%s)", wl->chip.fw_ver);
+
+	ret = wl1271_plt_init(wl);
+	if (ret < 0)
+		goto out;
+
+out:
+	mutex_unlock(&wl->mutex);
+
+	return ret;
+}
+
+int wl1271_plt_stop(struct wl1271 *wl)
+{
+	int ret = 0;
+
+	mutex_lock(&wl->mutex);
+
+	wl1271_notice("power down");
+
+	if (wl->state != WL1271_STATE_PLT) {
+		wl1271_error("cannot power down because not in PLT "
+			     "state: %d", wl->state);
+		ret = -EBUSY;
+		goto out;
+	}
+
+	wl1271_disable_interrupts(wl);
+	wl1271_power_off(wl);
+
+	wl->state = WL1271_STATE_OFF;
+
+out:
+	mutex_unlock(&wl->mutex);
+
+	return ret;
+}
+
+
+static int wl1271_op_tx(struct ieee80211_hw *hw, struct sk_buff *skb)
+{
+	struct wl1271 *wl = hw->priv;
+
+	skb_queue_tail(&wl->tx_queue, skb);
+
+	/*
+	 * The chip specific setup must run before the first TX packet -
+	 * before that, the tx_work will not be initialized!
+	 */
+
+	schedule_work(&wl->tx_work);
+
+	/*
+	 * The workqueue is slow to process the tx_queue and we need stop
+	 * the queue here, otherwise the queue will get too long.
+	 */
+	if (skb_queue_len(&wl->tx_queue) >= WL1271_TX_QUEUE_MAX_LENGTH) {
+		ieee80211_stop_queues(wl->hw);
+
+		/*
+		 * FIXME: this is racy, the variable is not properly
+		 * protected. Maybe fix this by removing the stupid
+		 * variable altogether and checking the real queue state?
+		 */
+		wl->tx_queue_stopped = true;
+	}
+
+	return NETDEV_TX_OK;
+}
+
+static int wl1271_op_start(struct ieee80211_hw *hw)
+{
+	struct wl1271 *wl = hw->priv;
+	int ret = 0;
+
+	wl1271_debug(DEBUG_MAC80211, "mac80211 start");
+
+	mutex_lock(&wl->mutex);
+
+	if (wl->state != WL1271_STATE_OFF) {
+		wl1271_error("cannot start because not in off state: %d",
+			     wl->state);
+		ret = -EBUSY;
+		goto out;
+	}
+
+	ret = wl1271_chip_wakeup(wl);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_boot(wl);
+	if (ret < 0)
+		goto out;
+
+	ret = wl1271_hw_init(wl);
+	if (ret < 0)
+		goto out;
+
+	wl->state = WL1271_STATE_ON;
+
+	wl1271_info("firmware booted (%s)", wl->chip.fw_ver);
+
+out:
+	if (ret < 0)
+		wl1271_power_off(wl);
+
+	mutex_unlock(&wl->mutex);
+
+	return ret;
+}
+
+static void wl1271_op_stop(struct ieee80211_hw *hw)
+{
+	struct wl1271 *wl = hw->priv;
+	int i;
+
+	wl1271_info("down");
+
+	wl1271_debug(DEBUG_MAC80211, "mac80211 stop");
+
+	mutex_lock(&wl->mutex);
+
+	WARN_ON(wl->state != WL1271_STATE_ON);
+
+	if (wl->scanning) {
+		mutex_unlock(&wl->mutex);
+		ieee80211_scan_completed(wl->hw);
+		mutex_lock(&wl->mutex);
+		wl->scanning = false;
+	}
+
+	wl->state = WL1271_STATE_OFF;
+
+	wl1271_disable_interrupts(wl);
+
+	mutex_unlock(&wl->mutex);
+
+	cancel_work_sync(&wl->irq_work);
+	cancel_work_sync(&wl->tx_work);
+	cancel_work_sync(&wl->filter_work);
+
+	mutex_lock(&wl->mutex);
+
+	/* let's notify MAC80211 about the remaining pending TX frames */
+	wl1271_tx_flush(wl);
+	wl1271_power_off(wl);
+
+	memset(wl->bssid, 0, ETH_ALEN);
+	memset(wl->ssid, 0, IW_ESSID_MAX_SIZE + 1);
+	wl->ssid_len = 0;
+	wl->listen_int = 1;
+	wl->bss_type = MAX_BSS_TYPE;
+
+	wl->rx_counter = 0;
+	wl->elp = false;
+	wl->psm = 0;
+	wl->tx_queue_stopped = false;
+	wl->power_level = WL1271_DEFAULT_POWER_LEVEL;
+	wl->tx_blocks_available = 0;
+	wl->tx_results_count = 0;
+	wl->tx_packets_count = 0;
+	wl->time_offset = 0;
+	wl->session_counter = 0;
+	for (i = 0; i < NUM_TX_QUEUES; i++)
+		wl->tx_blocks_freed[i] = 0;
+
+	wl1271_debugfs_reset(wl);
+	mutex_unlock(&wl->mutex);
+}
+
+static int wl1271_op_add_interface(struct ieee80211_hw *hw,
+				   struct ieee80211_if_init_conf *conf)
+{
+	struct wl1271 *wl = hw->priv;
+	DECLARE_MAC_BUF(mac);
+	int ret = 0;
+
+	wl1271_debug(DEBUG_MAC80211, "mac80211 add interface type %d mac %s",
+		     conf->type, print_mac(mac, conf->mac_addr));
+
+	mutex_lock(&wl->mutex);
+
+	switch (conf->type) {
+	case NL80211_IFTYPE_STATION:
+		wl->bss_type = BSS_TYPE_STA_BSS;
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		wl->bss_type = BSS_TYPE_IBSS;
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+		goto out;
+	}
+
+	/* FIXME: what if conf->mac_addr changes? */
+
+out:
+	mutex_unlock(&wl->mutex);
+	return ret;
+}
+
+static void wl1271_op_remove_interface(struct ieee80211_hw *hw,
+					 struct ieee80211_if_init_conf *conf)
+{
+	wl1271_debug(DEBUG_MAC80211, "mac80211 remove interface");
+}
+
+static int wl1271_op_config_interface(struct ieee80211_hw *hw,
+				      struct ieee80211_vif *vif,
+				      struct ieee80211_if_conf *conf)
+{
+	struct wl1271 *wl = hw->priv;
+	struct sk_buff *beacon;
+	DECLARE_MAC_BUF(mac);
+	int ret;
+
+	wl1271_debug(DEBUG_MAC80211, "mac80211 config_interface bssid %s",
+		     print_mac(mac, conf->bssid));
+	wl1271_dump_ascii(DEBUG_MAC80211, "ssid: ", conf->ssid,
+			  conf->ssid_len);
+
+	mutex_lock(&wl->mutex);
+
+	ret = wl1271_ps_elp_wakeup(wl, false);
+	if (ret < 0)
+		goto out;
+
+	memcpy(wl->bssid, conf->bssid, ETH_ALEN);
+
+	ret = wl1271_cmd_build_null_data(wl);
+	if (ret < 0)
+		goto out_sleep;
+
+	wl->ssid_len = conf->ssid_len;
+	if (wl->ssid_len)
+		memcpy(wl->ssid, conf->ssid, wl->ssid_len);
+
+	if (wl->bss_type != BSS_TYPE_IBSS) {
+		/* FIXME: replace the magic numbers with proper definitions */
+		ret = wl1271_cmd_join(wl, wl->bss_type, 5, 100, 1);
+		if (ret < 0)
+			goto out_sleep;
+	}
+
+	if (conf->changed & IEEE80211_IFCC_BEACON) {
+		beacon = ieee80211_beacon_get(hw, vif);
+		ret = wl1271_cmd_template_set(wl, CMD_TEMPL_BEACON,
+					      beacon->data, beacon->len);
+
+		if (ret < 0) {
+			dev_kfree_skb(beacon);
+			goto out_sleep;
+		}
+
+		ret = wl1271_cmd_template_set(wl, CMD_TEMPL_PROBE_RESPONSE,
+					      beacon->data, beacon->len);
+
+		dev_kfree_skb(beacon);
+
+		if (ret < 0)
+			goto out_sleep;
+
+		/* FIXME: replace the magic numbers with proper definitions */
+		ret = wl1271_cmd_join(wl, wl->bss_type, 1, 100, 0);
+
+		if (ret < 0)
+			goto out_sleep;
+	}
+
+out_sleep:
+	wl1271_ps_elp_sleep(wl);
+
+out:
+	mutex_unlock(&wl->mutex);
+
+	return ret;
+}
+
+static int wl1271_op_config(struct ieee80211_hw *hw,
+			    struct ieee80211_conf *conf)
+{
+	struct wl1271 *wl = hw->priv;
+	int channel, ret = 0;
+
+	channel = ieee80211_frequency_to_channel(conf->channel->center_freq);
+
+	wl1271_debug(DEBUG_MAC80211, "mac80211 config ch %d psm %s power %d",
+		     channel,
+		     conf->flags & IEEE80211_CONF_PS ? "on" : "off",
+		     conf->power_level);
+
+	mutex_lock(&wl->mutex);
+
+	ret = wl1271_ps_elp_wakeup(wl, false);
+	if (ret < 0)
+		goto out;
+
+	if (channel != wl->channel) {
+		u8 old_channel = wl->channel;
+		wl->channel = channel;
+
+		/* FIXME: use beacon interval provided by mac80211 */
+		ret = wl1271_cmd_join(wl, wl->bss_type, 1, 100, 0);
+		if (ret < 0) {
+			wl->channel = old_channel;
+			goto out_sleep;
+		}
+	}
+
+	ret = wl1271_cmd_build_null_data(wl);
+	if (ret < 0)
+		goto out_sleep;
+
+	if (conf->flags & IEEE80211_CONF_PS && !wl->psm_requested) {
+		wl1271_info("psm enabled");
+
+		wl->psm_requested = true;
+
+		/*
+		 * We enter PSM only if we're already associated.
+		 * If we're not, we'll enter it when joining an SSID,
+		 * through the bss_info_changed() hook.
+		 */
+		ret = wl1271_ps_set_mode(wl, STATION_POWER_SAVE_MODE);
+	} else if (!(conf->flags & IEEE80211_CONF_PS) &&
+		   wl->psm_requested) {
+		wl1271_info("psm disabled");
+
+		wl->psm_requested = false;
+
+		if (wl->psm) {
+			ret = wl1271_ps_set_mode(wl, STATION_ACTIVE_MODE);
+		}
+	}
+
+	if (conf->power_level != wl->power_level) {
+		ret = wl1271_acx_tx_power(wl, conf->power_level);
+		if (ret < 0)
+			goto out;
+
+		wl->power_level = conf->power_level;
+	}
+
+out_sleep:
+	wl1271_ps_elp_sleep(wl);
+
+out:
+	mutex_unlock(&wl->mutex);
+
+	return ret;
+}
+
+#define WL1271_SUPPORTED_FILTERS (FIF_PROMISC_IN_BSS | \
+				  FIF_ALLMULTI | \
+				  FIF_FCSFAIL | \
+				  FIF_BCN_PRBRESP_PROMISC | \
+				  FIF_CONTROL | \
+				  FIF_OTHER_BSS)
+
+static void wl1271_op_configure_filter(struct ieee80211_hw *hw,
+				       unsigned int changed,
+				       unsigned int *total,
+				       int mc_count,
+				       struct dev_addr_list *mc_list)
+{
+	struct wl1271 *wl = hw->priv;
+
+	wl1271_debug(DEBUG_MAC80211, "mac80211 configure filter");
+
+	*total &= WL1271_SUPPORTED_FILTERS;
+	changed &= WL1271_SUPPORTED_FILTERS;
+
+	if (changed == 0)
+		return;
+
+	/* FIXME: wl->rx_config and wl->rx_filter are not protected */
+	wl->rx_config = WL1271_DEFAULT_RX_CONFIG;
+	wl->rx_filter = WL1271_DEFAULT_RX_FILTER;
+
+	/*
+	 * FIXME: workqueues need to be properly cancelled on stop(), for
+	 * now let's just disable changing the filter settings. They will
+	 * be updated any on config().
+	 */
+	/* schedule_work(&wl->filter_work); */
+}
+
+static int wl1271_op_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
+			     const u8 *local_addr, const u8 *addr,
+			     struct ieee80211_key_conf *key_conf)
+{
+	struct wl1271 *wl = hw->priv;
+	int ret;
+	u8 key_type;
+
+	wl1271_debug(DEBUG_MAC80211, "mac80211 set key");
+
+	wl1271_debug(DEBUG_CRYPT, "CMD: 0x%x", cmd);
+	wl1271_dump(DEBUG_CRYPT, "ADDR: ", addr, ETH_ALEN);
+	wl1271_dump(DEBUG_CRYPT, "LOCAL_ADDR: ", local_addr, ETH_ALEN);
+	wl1271_debug(DEBUG_CRYPT, "Key: algo:0x%x, id:%d, len:%d flags 0x%x",
+		     key_conf->alg, key_conf->keyidx,
+		     key_conf->keylen, key_conf->flags);
+	wl1271_dump(DEBUG_CRYPT, "KEY: ", key_conf->key, key_conf->keylen);
+
+	if (is_zero_ether_addr(addr)) {
+		/* We dont support TX only encryption */
+		ret = -EOPNOTSUPP;
+		goto out;
+	}
+
+	mutex_lock(&wl->mutex);
+
+	ret = wl1271_ps_elp_wakeup(wl, false);
+	if (ret < 0)
+		goto out_unlock;
+
+	switch (key_conf->alg) {
+	case ALG_WEP:
+		key_type = KEY_WEP;
+
+		key_conf->hw_key_idx = key_conf->keyidx;
+		break;
+	case ALG_TKIP:
+		key_type = KEY_TKIP;
+
+		key_conf->hw_key_idx = key_conf->keyidx;
+		break;
+	case ALG_CCMP:
+		key_type = KEY_AES;
+
+		key_conf->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;
+		break;
+	default:
+		wl1271_error("Unknown key algo 0x%x", key_conf->alg);
+
+		ret = -EOPNOTSUPP;
+		goto out_sleep;
+	}
+
+	switch (cmd) {
+	case SET_KEY:
+		ret = wl1271_cmd_set_key(wl, KEY_ADD_OR_REPLACE,
+					 key_conf->keyidx, key_type,
+					 key_conf->keylen, key_conf->key,
+					 addr);
+		if (ret < 0) {
+			wl1271_error("Could not add or replace key");
+			goto out_sleep;
+		}
+		break;
+
+	case DISABLE_KEY:
+		ret = wl1271_cmd_set_key(wl, KEY_REMOVE,
+					 key_conf->keyidx, key_type,
+					 key_conf->keylen, key_conf->key,
+					 addr);
+		if (ret < 0) {
+			wl1271_error("Could not remove key");
+			goto out_sleep;
+		}
+		break;
+
+	default:
+		wl1271_error("Unsupported key cmd 0x%x", cmd);
+		ret = -EOPNOTSUPP;
+		goto out_sleep;
+
+		break;
+	}
+
+out_sleep:
+	wl1271_ps_elp_sleep(wl);
+
+out_unlock:
+	mutex_unlock(&wl->mutex);
+
+out:
+	return ret;
+}
+
+static int wl1271_op_hw_scan(struct ieee80211_hw *hw, u8 *ssid, size_t len)
+{
+	struct wl1271 *wl = hw->priv;
+	int ret;
+
+	wl1271_debug(DEBUG_MAC80211, "mac80211 hw scan");
+
+	mutex_lock(&wl->mutex);
+
+	ret = wl1271_ps_elp_wakeup(wl, false);
+	if (ret < 0)
+		goto out;
+
+	ret = wl1271_cmd_scan(hw->priv, ssid, len, 1, 0, 13, 3);
+
+	wl1271_ps_elp_sleep(wl);
+
+out:
+	mutex_unlock(&wl->mutex);
+
+	return ret;
+}
+
+static int wl1271_op_set_rts_threshold(struct ieee80211_hw *hw, u32 value)
+{
+	struct wl1271 *wl = hw->priv;
+	int ret;
+
+	mutex_lock(&wl->mutex);
+
+	ret = wl1271_ps_elp_wakeup(wl, false);
+	if (ret < 0)
+		goto out;
+
+	ret = wl1271_acx_rts_threshold(wl, (u16) value);
+	if (ret < 0)
+		wl1271_warning("wl1271_op_set_rts_threshold failed: %d", ret);
+
+	wl1271_ps_elp_sleep(wl);
+
+out:
+	mutex_unlock(&wl->mutex);
+
+	return ret;
+}
+
+static void wl1271_op_bss_info_changed(struct ieee80211_hw *hw,
+				       struct ieee80211_vif *vif,
+				       struct ieee80211_bss_conf *bss_conf,
+				       u32 changed)
+{
+	enum wl1271_cmd_ps_mode mode;
+	struct wl1271 *wl = hw->priv;
+	int ret;
+
+	wl1271_debug(DEBUG_MAC80211, "mac80211 bss info changed");
+
+	mutex_lock(&wl->mutex);
+
+	ret = wl1271_ps_elp_wakeup(wl, false);
+	if (ret < 0)
+		goto out;
+
+	if (changed & BSS_CHANGED_ASSOC) {
+		if (bss_conf->assoc) {
+			wl->aid = bss_conf->aid;
+
+			ret = wl1271_cmd_build_ps_poll(wl, wl->aid);
+			if (ret < 0)
+				goto out_sleep;
+
+			ret = wl1271_acx_aid(wl, wl->aid);
+			if (ret < 0)
+				goto out_sleep;
+
+			/* If we want to go in PSM but we're not there yet */
+			if (wl->psm_requested && !wl->psm) {
+				mode = STATION_POWER_SAVE_MODE;
+				ret = wl1271_ps_set_mode(wl, mode);
+				if (ret < 0)
+					goto out_sleep;
+			}
+		}
+	}
+	if (changed & BSS_CHANGED_ERP_SLOT) {
+		if (bss_conf->use_short_slot)
+			ret = wl1271_acx_slot(wl, SLOT_TIME_SHORT);
+		else
+			ret = wl1271_acx_slot(wl, SLOT_TIME_LONG);
+		if (ret < 0) {
+			wl1271_warning("Set slot time failed %d", ret);
+			goto out_sleep;
+		}
+	}
+
+	if (changed & BSS_CHANGED_ERP_PREAMBLE) {
+		if (bss_conf->use_short_preamble)
+			wl1271_acx_set_preamble(wl, ACX_PREAMBLE_SHORT);
+		else
+			wl1271_acx_set_preamble(wl, ACX_PREAMBLE_LONG);
+	}
+
+	if (changed & BSS_CHANGED_ERP_CTS_PROT) {
+		if (bss_conf->use_cts_prot)
+			ret = wl1271_acx_cts_protect(wl, CTSPROTECT_ENABLE);
+		else
+			ret = wl1271_acx_cts_protect(wl, CTSPROTECT_DISABLE);
+		if (ret < 0) {
+			wl1271_warning("Set ctsprotect failed %d", ret);
+			goto out_sleep;
+		}
+	}
+
+out_sleep:
+	wl1271_ps_elp_sleep(wl);
+
+out:
+	mutex_unlock(&wl->mutex);
+}
+
+
+/* can't be const, mac80211 writes to this */
+static struct ieee80211_rate wl1271_rates[] = {
+	{ .bitrate = 10,
+	  .hw_value = 0x1,
+	  .hw_value_short = 0x1, },
+	{ .bitrate = 20,
+	  .hw_value = 0x2,
+	  .hw_value_short = 0x2,
+	  .flags = IEEE80211_RATE_SHORT_PREAMBLE },
+	{ .bitrate = 55,
+	  .hw_value = 0x4,
+	  .hw_value_short = 0x4,
+	  .flags = IEEE80211_RATE_SHORT_PREAMBLE },
+	{ .bitrate = 110,
+	  .hw_value = 0x20,
+	  .hw_value_short = 0x20,
+	  .flags = IEEE80211_RATE_SHORT_PREAMBLE },
+	{ .bitrate = 60,
+	  .hw_value = 0x8,
+	  .hw_value_short = 0x8, },
+	{ .bitrate = 90,
+	  .hw_value = 0x10,
+	  .hw_value_short = 0x10, },
+	{ .bitrate = 120,
+	  .hw_value = 0x40,
+	  .hw_value_short = 0x40, },
+	{ .bitrate = 180,
+	  .hw_value = 0x80,
+	  .hw_value_short = 0x80, },
+	{ .bitrate = 240,
+	  .hw_value = 0x200,
+	  .hw_value_short = 0x200, },
+	{ .bitrate = 360,
+	 .hw_value = 0x400,
+	 .hw_value_short = 0x400, },
+	{ .bitrate = 480,
+	  .hw_value = 0x800,
+	  .hw_value_short = 0x800, },
+	{ .bitrate = 540,
+	  .hw_value = 0x1000,
+	  .hw_value_short = 0x1000, },
+};
+
+/* can't be const, mac80211 writes to this */
+static struct ieee80211_channel wl1271_channels[] = {
+	{ .hw_value = 1, .center_freq = 2412},
+	{ .hw_value = 2, .center_freq = 2417},
+	{ .hw_value = 3, .center_freq = 2422},
+	{ .hw_value = 4, .center_freq = 2427},
+	{ .hw_value = 5, .center_freq = 2432},
+	{ .hw_value = 6, .center_freq = 2437},
+	{ .hw_value = 7, .center_freq = 2442},
+	{ .hw_value = 8, .center_freq = 2447},
+	{ .hw_value = 9, .center_freq = 2452},
+	{ .hw_value = 10, .center_freq = 2457},
+	{ .hw_value = 11, .center_freq = 2462},
+	{ .hw_value = 12, .center_freq = 2467},
+	{ .hw_value = 13, .center_freq = 2472},
+};
+
+/* can't be const, mac80211 writes to this */
+static struct ieee80211_supported_band wl1271_band_2ghz = {
+	.channels = wl1271_channels,
+	.n_channels = ARRAY_SIZE(wl1271_channels),
+	.bitrates = wl1271_rates,
+	.n_bitrates = ARRAY_SIZE(wl1271_rates),
+};
+
+static const struct ieee80211_ops wl1271_ops = {
+	.start = wl1271_op_start,
+	.stop = wl1271_op_stop,
+	.add_interface = wl1271_op_add_interface,
+	.remove_interface = wl1271_op_remove_interface,
+	.config = wl1271_op_config,
+	.config_interface = wl1271_op_config_interface,
+	.configure_filter = wl1271_op_configure_filter,
+	.tx = wl1271_op_tx,
+	.set_key = wl1271_op_set_key,
+	.hw_scan = wl1271_op_hw_scan,
+	.bss_info_changed = wl1271_op_bss_info_changed,
+	.set_rts_threshold = wl1271_op_set_rts_threshold,
+};
+
+static int wl1271_register_hw(struct wl1271 *wl)
+{
+	int ret;
+
+	if (wl->mac80211_registered)
+		return 0;
+
+	SET_IEEE80211_PERM_ADDR(wl->hw, wl->mac_addr);
+
+	ret = ieee80211_register_hw(wl->hw);
+	if (ret < 0) {
+		wl1271_error("unable to register mac80211 hw: %d", ret);
+		return ret;
+	}
+
+	wl->mac80211_registered = true;
+
+	wl1271_notice("loaded");
+
+	return 0;
+}
+
+static int wl1271_init_ieee80211(struct wl1271 *wl)
+{
+	/*
+	 * The tx descriptor buffer and the TKIP space.
+	 *
+	 * FIXME: add correct 1271 descriptor size
+	 */
+	wl->hw->extra_tx_headroom = WL1271_TKIP_IV_SPACE;
+
+	/* unit us */
+	/* FIXME: find a proper value */
+	wl->hw->channel_change_time = 10000;
+
+	wl->hw->flags = IEEE80211_HW_SIGNAL_DBM |
+		IEEE80211_HW_NOISE_DBM;
+
+	wl->hw->wiphy->bands[IEEE80211_BAND_2GHZ] = &wl1271_band_2ghz;
+
+	SET_IEEE80211_DEV(wl->hw, &wl->spi->dev);
+
+	return 0;
+}
+
+static void wl1271_device_release(struct device *dev)
+{
+
+}
+
+static struct platform_device wl1271_device = {
+	.name           = "wl1271",
+	.id             = -1,
+
+	/* device model insists to have a release function */
+	.dev            = {
+		.release = wl1271_device_release,
+	},
+};
+
+#define WL1271_DEFAULT_CHANNEL 0
+static int __devinit wl1271_probe(struct spi_device *spi)
+{
+	struct wl12xx_platform_data *pdata;
+	struct ieee80211_hw *hw;
+	struct wl1271 *wl;
+	int ret, i;
+	static const u8 nokia_oui[3] = {0x00, 0x1f, 0xdf};
+
+	pdata = spi->dev.platform_data;
+	if (!pdata) {
+		wl1271_error("no platform data");
+		return -ENODEV;
+	}
+
+	hw = ieee80211_alloc_hw(sizeof(*wl), &wl1271_ops);
+	if (!hw) {
+		wl1271_error("could not alloc ieee80211_hw");
+		return -ENOMEM;
+	}
+
+	wl = hw->priv;
+	memset(wl, 0, sizeof(*wl));
+
+	wl->hw = hw;
+	dev_set_drvdata(&spi->dev, wl);
+	wl->spi = spi;
+
+	skb_queue_head_init(&wl->tx_queue);
+
+	INIT_WORK(&wl->filter_work, wl1271_filter_work);
+	wl->channel = WL1271_DEFAULT_CHANNEL;
+	wl->scanning = false;
+	wl->default_key = 0;
+	wl->listen_int = 1;
+	wl->rx_counter = 0;
+	wl->rx_config = WL1271_DEFAULT_RX_CONFIG;
+	wl->rx_filter = WL1271_DEFAULT_RX_FILTER;
+	wl->elp = false;
+	wl->psm = 0;
+	wl->psm_requested = false;
+	wl->tx_queue_stopped = false;
+	wl->power_level = WL1271_DEFAULT_POWER_LEVEL;
+
+	/* We use the default power on sleep time until we know which chip
+	 * we're using */
+	for (i = 0; i < FW_TX_CMPLT_BLOCK_SIZE; i++)
+		wl->tx_frames[i] = NULL;
+
+	spin_lock_init(&wl->wl_lock);
+
+	/*
+	 * In case our MAC address is not correctly set,
+	 * we use a random but Nokia MAC.
+	 */
+	memcpy(wl->mac_addr, nokia_oui, 3);
+	get_random_bytes(wl->mac_addr + 3, 3);
+
+	wl->state = WL1271_STATE_OFF;
+	mutex_init(&wl->mutex);
+
+	wl->rx_descriptor = kmalloc(sizeof(*wl->rx_descriptor), GFP_KERNEL);
+	if (!wl->rx_descriptor) {
+		wl1271_error("could not allocate memory for rx descriptor");
+		ret = -ENOMEM;
+		goto out_free;
+	}
+
+	/* This is the only SPI value that we need to set here, the rest
+	 * comes from the board-peripherals file */
+	spi->bits_per_word = 32;
+
+	ret = spi_setup(spi);
+	if (ret < 0) {
+		wl1271_error("spi_setup failed");
+		goto out_free;
+	}
+
+	wl->set_power = pdata->set_power;
+	if (!wl->set_power) {
+		wl1271_error("set power function missing in platform data");
+		ret = -ENODEV;
+		goto out_free;
+	}
+
+	wl->irq = spi->irq;
+	if (wl->irq < 0) {
+		wl1271_error("irq missing in platform data");
+		ret = -ENODEV;
+		goto out_free;
+	}
+
+	ret = request_irq(wl->irq, wl1271_irq, 0, DRIVER_NAME, wl);
+	if (ret < 0) {
+		wl1271_error("request_irq() failed: %d", ret);
+		goto out_free;
+	}
+
+	set_irq_type(wl->irq, IRQ_TYPE_EDGE_RISING);
+
+	disable_irq(wl->irq);
+
+	ret = platform_device_register(&wl1271_device);
+	if (ret) {
+		wl1271_error("couldn't register platform device");
+		goto out_irq;
+	}
+	dev_set_drvdata(&wl1271_device.dev, wl);
+
+	ret = wl1271_init_ieee80211(wl);
+	if (ret)
+		goto out_platform;
+
+	ret = wl1271_register_hw(wl);
+	if (ret)
+		goto out_platform;
+
+	ret = wl1271_nl_register();
+	if (ret)
+		goto out_register_hw;
+
+	wl1271_debugfs_init(wl);
+
+	wl1271_notice("initialized");
+
+	return 0;
+
+ out_register_hw:
+	ieee80211_unregister_hw(hw);
+	wl->mac80211_registered = false;
+
+ out_platform:
+	platform_device_unregister(&wl1271_device);
+
+ out_irq:
+	free_irq(wl->irq, wl);
+
+ out_free:
+	kfree(wl->rx_descriptor);
+	wl->rx_descriptor = NULL;
+
+	ieee80211_free_hw(hw);
+
+	return ret;
+}
+
+static int __devexit wl1271_remove(struct spi_device *spi)
+{
+	struct wl1271 *wl = dev_get_drvdata(&spi->dev);
+
+	ieee80211_unregister_hw(wl->hw);
+
+	wl1271_debugfs_exit(wl);
+	platform_device_unregister(&wl1271_device);
+	free_irq(wl->irq, wl);
+	kfree(wl->target_mem_map);
+	kfree(wl->fw);
+	wl->fw = NULL;
+	kfree(wl->nvs);
+	wl->nvs = NULL;
+
+	kfree(wl->rx_descriptor);
+	wl->rx_descriptor = NULL;
+
+	kfree(wl->fw_status);
+	kfree(wl->tx_res_if);
+
+	ieee80211_free_hw(wl->hw);
+	wl1271_nl_unregister();
+
+	return 0;
+}
+
+
+static struct spi_driver wl1271_spi_driver = {
+	.driver = {
+		.name		= "wl1271",
+		.bus		= &spi_bus_type,
+		.owner		= THIS_MODULE,
+	},
+
+	.probe		= wl1271_probe,
+	.remove		= __devexit_p(wl1271_remove),
+};
+
+static int __init wl1271_init(void)
+{
+	int ret;
+
+	ret = spi_register_driver(&wl1271_spi_driver);
+	if (ret < 0) {
+		wl1271_error("failed to register spi driver: %d", ret);
+		goto out;
+	}
+
+out:
+	return ret;
+}
+
+static void __exit wl1271_exit(void)
+{
+	spi_unregister_driver(&wl1271_spi_driver);
+
+	wl1271_notice("unloaded");
+}
+
+module_init(wl1271_init);
+module_exit(wl1271_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Kalle Valo <Kalle.Valo@nokia.com>, "
+		"Luciano Coelho <luciano.coelho@nokia.com>");
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_netlink.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_netlink.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_netlink.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_netlink.c	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,679 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+#include "wl1271_netlink.h"
+
+#include <linux/mutex.h>
+#include <linux/socket.h>
+#include <net/net_namespace.h>
+#include <net/sock.h>
+#include <net/genetlink.h>
+#include <net/wireless.h>
+#include <net/mac80211.h>
+
+#include "wl1271.h"
+#include "wl1271_spi.h"
+#include "wl1271_acx.h"
+
+/* FIXME: this should be changed as soon as user space catches up */
+#define WL1271_NL_NAME "wl1251"
+#define WL1271_NL_VERSION 1
+
+#define WL1271_MAX_TEST_LENGTH 1024
+#define WL1271_MAX_NVS_LENGTH 1024
+
+enum wl1271_nl_commands {
+	WL1271_NL_CMD_UNSPEC,
+	WL1271_NL_CMD_TEST,
+	WL1271_NL_CMD_INTERROGATE,
+	WL1271_NL_CMD_CONFIGURE,
+	WL1271_NL_CMD_PHY_REG_READ,
+	WL1271_NL_CMD_NVS_PUSH,
+	WL1271_NL_CMD_REG_WRITE,
+	WL1271_NL_CMD_REG_READ,
+	WL1271_NL_CMD_SET_PLT_MODE,
+
+	__WL1271_NL_CMD_AFTER_LAST
+};
+#define WL1271_NL_CMD_MAX (__WL1271_NL_CMD_AFTER_LAST - 1)
+
+enum wl1271_nl_attrs {
+	WL1271_NL_ATTR_UNSPEC,
+	WL1271_NL_ATTR_IFNAME,
+	WL1271_NL_ATTR_CMD_TEST_PARAM,
+	WL1271_NL_ATTR_CMD_TEST_ANSWER,
+	WL1271_NL_ATTR_CMD_IE,
+	WL1271_NL_ATTR_CMD_IE_LEN,
+	WL1271_NL_ATTR_CMD_IE_BUFFER,
+	WL1271_NL_ATTR_CMD_IE_ANSWER,
+	WL1271_NL_ATTR_REG_ADDR,
+	WL1271_NL_ATTR_REG_VAL,
+	WL1271_NL_ATTR_NVS_BUFFER,
+	WL1271_NL_ATTR_NVS_LEN,
+	WL1271_NL_ATTR_PLT_MODE,
+
+	__WL1271_NL_ATTR_AFTER_LAST
+};
+#define WL1271_NL_ATTR_MAX (__WL1271_NL_ATTR_AFTER_LAST - 1)
+
+static struct genl_family wl1271_nl_family = {
+	.id = GENL_ID_GENERATE,
+	.name = WL1271_NL_NAME,
+	.hdrsize = 0,
+	.version = WL1271_NL_VERSION,
+	.maxattr = WL1271_NL_ATTR_MAX,
+};
+
+static struct net_device *ifname_to_netdev(struct net *net,
+					   struct genl_info *info)
+{
+	char *ifname;
+
+	if (!info->attrs[WL1271_NL_ATTR_IFNAME])
+		return NULL;
+
+	ifname = nla_data(info->attrs[WL1271_NL_ATTR_IFNAME]);
+
+	wl1271_debug(DEBUG_NETLINK, "Looking for %s", ifname);
+
+	return dev_get_by_name(net, ifname);
+}
+
+static struct wl1271 *ifname_to_wl1271(struct net *net, struct genl_info *info)
+{
+	struct net_device *netdev;
+	struct wireless_dev *wdev;
+	struct wiphy *wiphy;
+	struct ieee80211_hw *hw;
+
+	netdev = ifname_to_netdev(net, info);
+	if (netdev == NULL) {
+		wl1271_error("Wrong interface");
+		return NULL;
+	}
+
+	wdev = netdev->ieee80211_ptr;
+	if (wdev == NULL) {
+		wl1271_error("ieee80211_ptr is NULL");
+		return NULL;
+	}
+
+	wiphy = wdev->wiphy;
+	if (wiphy == NULL) {
+		wl1271_error("wiphy is NULL");
+		return NULL;
+	}
+
+	hw = wiphy_priv(wiphy);
+	if (hw == NULL) {
+		wl1271_error("hw is NULL");
+		return NULL;
+	}
+
+	dev_put(netdev);
+
+	return hw->priv;
+}
+
+static int wl1271_nl_test_cmd(struct sk_buff *skb, struct genl_info *info)
+{
+	struct wl1271 *wl;
+	struct wl1271_command *cmd;
+	char *buf;
+	int buf_len, ret, cmd_len;
+	u8 answer;
+
+	if (!info->attrs[WL1271_NL_ATTR_CMD_TEST_PARAM])
+		return -EINVAL;
+
+	wl = ifname_to_wl1271(&init_net, info);
+	if (wl == NULL) {
+		wl1271_error("wl1271 not found");
+		return -EINVAL;
+	}
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	buf = nla_data(info->attrs[WL1271_NL_ATTR_CMD_TEST_PARAM]);
+	buf_len = nla_len(info->attrs[WL1271_NL_ATTR_CMD_TEST_PARAM]);
+	answer = nla_get_u8(info->attrs[WL1271_NL_ATTR_CMD_TEST_ANSWER]);
+
+	cmd->header.id = CMD_TEST;
+	memcpy(cmd->parameters, buf, buf_len);
+	cmd_len = sizeof(struct wl1271_cmd_header) + buf_len;
+
+	mutex_lock(&wl->mutex);
+	ret = wl1271_cmd_test(wl, cmd, cmd_len, answer);
+	mutex_unlock(&wl->mutex);
+
+	if (ret < 0) {
+		wl1271_error("%s() failed", __func__);
+		goto out;
+	}
+
+	if (answer) {
+		struct sk_buff *msg;
+		void *hdr;
+
+		msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+		if (!msg) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq,
+				  &wl1271_nl_family, 0, WL1271_NL_CMD_TEST);
+		if (IS_ERR(hdr)) {
+			ret = PTR_ERR(hdr);
+			goto nla_put_failure;
+		}
+
+		NLA_PUT_STRING(msg, WL1271_NL_ATTR_IFNAME,
+			       nla_data(info->attrs[WL1271_NL_ATTR_IFNAME]));
+		NLA_PUT(msg, WL1271_NL_ATTR_CMD_TEST_ANSWER,
+			sizeof(*cmd), cmd);
+
+		ret = genlmsg_end(msg, hdr);
+		if (ret < 0) {
+			wl1271_error("%s() failed", __func__);
+			goto nla_put_failure;
+		}
+
+		wl1271_debug(DEBUG_NETLINK, "TEST cmd sent, answer");
+		ret = genlmsg_reply(msg, info);
+		goto out;
+
+ nla_put_failure:
+		nlmsg_free(msg);
+	} else
+		wl1271_debug(DEBUG_NETLINK, "TEST cmd sent");
+
+out:
+	kfree(cmd);
+	return ret;
+}
+
+static int wl1271_nl_interrogate(struct sk_buff *skb, struct genl_info *info)
+{
+	struct wl1271 *wl;
+	struct sk_buff *msg;
+	int ret = -ENOBUFS, cmd_ie, cmd_ie_len;
+	struct wl1271_command *cmd;
+	void *hdr;
+
+	if (!info->attrs[WL1271_NL_ATTR_CMD_IE])
+		return -EINVAL;
+
+	if (!info->attrs[WL1271_NL_ATTR_CMD_IE_LEN])
+		return -EINVAL;
+
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!msg)
+		return -ENOMEM;
+
+	wl = ifname_to_wl1271(&init_net, info);
+	if (wl == NULL) {
+		wl1271_error("wl1271 not found");
+		ret = -EINVAL;
+		goto nla_put_failure;
+	}
+
+	/* acx id */
+	cmd_ie = nla_get_u32(info->attrs[WL1271_NL_ATTR_CMD_IE]);
+
+	/* maximum length of acx, including all headers */
+	cmd_ie_len = nla_get_u32(info->attrs[WL1271_NL_ATTR_CMD_IE_LEN]);
+
+	wl1271_debug(DEBUG_NETLINK, "Getting IE 0x%x (len %d)",
+		     cmd_ie, cmd_ie_len);
+
+	mutex_lock(&wl->mutex);
+	ret = wl1271_cmd_interrogate(wl, cmd_ie, cmd, cmd_ie_len);
+	mutex_unlock(&wl->mutex);
+
+	if (ret < 0) {
+		wl1271_error("%s() failed", __func__);
+		goto nla_put_failure;
+	}
+
+	hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq,
+			  &wl1271_nl_family, 0, WL1271_NL_CMD_INTERROGATE);
+	if (IS_ERR(hdr)) {
+		ret = PTR_ERR(hdr);
+		goto nla_put_failure;
+	}
+
+	NLA_PUT_STRING(msg, WL1271_NL_ATTR_IFNAME,
+		       nla_data(info->attrs[WL1271_NL_ATTR_IFNAME]));
+	NLA_PUT(msg, WL1271_NL_ATTR_CMD_IE_ANSWER, cmd_ie_len, cmd);
+
+	ret = genlmsg_end(msg, hdr);
+	if (ret < 0) {
+		wl1271_error("%s() failed", __func__);
+		goto nla_put_failure;
+	}
+
+	kfree(cmd);
+	return genlmsg_reply(msg, info);
+
+ nla_put_failure:
+	kfree(cmd);
+	nlmsg_free(msg);
+
+	return ret;
+}
+
+static int wl1271_nl_configure(struct sk_buff *skb, struct genl_info *info)
+{
+	int ret = 0, cmd_ie_len, acx_len;
+	struct acx_header *acx = NULL;
+	struct sk_buff *msg;
+	struct wl1271 *wl;
+	void *cmd_ie;
+	u16 *id;
+
+	if (!info->attrs[WL1271_NL_ATTR_CMD_IE_BUFFER])
+		return -EINVAL;
+
+	if (!info->attrs[WL1271_NL_ATTR_CMD_IE_LEN])
+		return -EINVAL;
+
+	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!msg)
+		return -ENOMEM;
+
+	wl = ifname_to_wl1271(&init_net, info);
+	if (wl == NULL) {
+		wl1271_error("wl1271 not found");
+		ret = -EINVAL;
+		goto nla_put_failure;
+	}
+
+	/* contains the acx header but not the cmd header */
+	cmd_ie = nla_data(info->attrs[WL1271_NL_ATTR_CMD_IE_BUFFER]);
+
+	cmd_ie_len = nla_get_u32(info->attrs[WL1271_NL_ATTR_CMD_IE_LEN]);
+
+	/* acx id is in the first two bytes */
+	id = cmd_ie;
+
+	/* need to add acx_header before cmd_ie, so create a new command */
+	acx_len = sizeof(struct acx_header) + cmd_ie_len;
+	acx = kzalloc(acx_len, GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto nla_put_failure;
+	}
+
+	/* copy the acx header and the payload */
+	memcpy(&acx->id, cmd_ie, cmd_ie_len);
+
+	mutex_lock(&wl->mutex);
+	ret = wl1271_cmd_configure(wl, *id, acx, acx_len);
+	mutex_unlock(&wl->mutex);
+
+	if (ret < 0) {
+		wl1271_error("%s() failed", __func__);
+		goto nla_put_failure;
+	}
+
+	wl1271_debug(DEBUG_NETLINK, "CONFIGURE cmd sent");
+
+ nla_put_failure:
+	kfree(acx);
+	nlmsg_free(msg);
+
+	return ret;
+}
+
+static int wl1271_nl_phy_reg_read(struct sk_buff *skb, struct genl_info *info)
+{
+	struct wl1271 *wl;
+	struct sk_buff *msg;
+	u32 reg_addr, *reg_value = NULL;
+	int ret = 0;
+	void *hdr;
+
+	if (!info->attrs[WL1271_NL_ATTR_REG_ADDR])
+		return -EINVAL;
+
+	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!msg)
+		return -ENOMEM;
+
+	wl = ifname_to_wl1271(&init_net, info);
+	if (wl == NULL) {
+		wl1271_error("wl1271 not found");
+		ret = -EINVAL;
+		goto nla_put_failure;
+	}
+
+	reg_value = kmalloc(sizeof(*reg_value), GFP_KERNEL);
+	if (!reg_value) {
+		ret = -ENOMEM;
+		goto nla_put_failure;
+	}
+
+	reg_addr = nla_get_u32(info->attrs[WL1271_NL_ATTR_REG_ADDR]);
+
+	wl1271_debug(DEBUG_NETLINK, "Reading PHY reg 0x%x", reg_addr);
+
+	mutex_lock(&wl->mutex);
+	ret = wl1271_cmd_read_memory(wl, reg_addr, reg_value,
+				     sizeof(*reg_value));
+	mutex_unlock(&wl->mutex);
+
+	if (ret < 0) {
+		wl1271_error("%s() failed", __func__);
+		goto nla_put_failure;
+	}
+
+
+	hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq,
+			  &wl1271_nl_family, 0, WL1271_NL_CMD_PHY_REG_READ);
+	if (IS_ERR(hdr)) {
+		ret = PTR_ERR(hdr);
+		goto nla_put_failure;
+	}
+
+	NLA_PUT_STRING(msg, WL1271_NL_ATTR_IFNAME,
+		       nla_data(info->attrs[WL1271_NL_ATTR_IFNAME]));
+
+	NLA_PUT_U32(msg, WL1271_NL_ATTR_REG_VAL, *reg_value);
+
+	ret = genlmsg_end(msg, hdr);
+	if (ret < 0) {
+		wl1271_error("%s() failed", __func__);
+		goto nla_put_failure;
+	}
+
+	kfree(reg_value);
+
+	return genlmsg_reply(msg, info);
+
+ nla_put_failure:
+	nlmsg_free(msg);
+	kfree(reg_value);
+
+	return ret;
+}
+
+static int wl1271_nl_nvs_push(struct sk_buff *skb, struct genl_info *info)
+{
+	struct wl1271 *wl;
+	int ret = 0;
+
+	if (!info->attrs[WL1271_NL_ATTR_NVS_BUFFER])
+		return -EINVAL;
+
+	if (!info->attrs[WL1271_NL_ATTR_NVS_LEN])
+		return -EINVAL;
+
+	wl = ifname_to_wl1271(&init_net, info);
+	if (wl == NULL) {
+		wl1271_error("wl1271 not found");
+		return -EINVAL;
+	}
+
+	mutex_lock(&wl->mutex);
+	wl->nvs_len = nla_get_u32(info->attrs[WL1271_NL_ATTR_NVS_LEN]);
+	if (wl->nvs_len % 4) {
+		wl1271_error("NVS size is not multiple of 32: %d", wl->nvs_len);
+		ret = -EILSEQ;
+		goto out;
+	}
+
+	/* If we already have an NVS, we should free it */
+	kfree(wl->nvs);
+
+	wl->nvs = kzalloc(wl->nvs_len, GFP_KERNEL);
+	if (wl->nvs == NULL) {
+		wl1271_error("Can't allocate NVS");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	memcpy(wl->nvs,
+	       nla_data(info->attrs[WL1271_NL_ATTR_NVS_BUFFER]),
+	       wl->nvs_len);
+
+	wl1271_debug(DEBUG_NETLINK, "got NVS from userspace, %d bytes",
+		     wl->nvs_len);
+
+out:
+	mutex_unlock(&wl->mutex);
+
+	return ret;
+}
+
+static int wl1271_nl_reg_read(struct sk_buff *skb, struct genl_info *info)
+{
+	struct wl1271 *wl;
+	u32 addr, val;
+	int ret = 0;
+	struct sk_buff *msg;
+	void *hdr;
+
+	if (!info->attrs[WL1271_NL_ATTR_REG_ADDR])
+		return -EINVAL;
+
+	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!msg)
+		return -ENOMEM;
+
+	wl = ifname_to_wl1271(&init_net, info);
+	if (wl == NULL) {
+		wl1271_error("wl1271 not found");
+		return -EINVAL;
+	}
+
+	addr = nla_get_u32(info->attrs[WL1271_NL_ATTR_REG_ADDR]);
+
+	mutex_lock(&wl->mutex);
+	val = wl1271_reg_read32(wl, addr);
+	mutex_unlock(&wl->mutex);
+
+	hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq,
+			  &wl1271_nl_family, 0, WL1271_NL_CMD_PHY_REG_READ);
+	if (IS_ERR(hdr)) {
+		ret = PTR_ERR(hdr);
+		goto nla_put_failure;
+	}
+
+	NLA_PUT_STRING(msg, WL1271_NL_ATTR_IFNAME,
+		       nla_data(info->attrs[WL1271_NL_ATTR_IFNAME]));
+
+	NLA_PUT_U32(msg, WL1271_NL_ATTR_REG_VAL, val);
+
+	ret = genlmsg_end(msg, hdr);
+	if (ret < 0) {
+		wl1271_error("%s() failed", __func__);
+		goto nla_put_failure;
+	}
+
+	return genlmsg_reply(msg, info);
+
+ nla_put_failure:
+	nlmsg_free(msg);
+
+	return ret;
+}
+
+static int wl1271_nl_reg_write(struct sk_buff *skb, struct genl_info *info)
+{
+	struct wl1271 *wl;
+	u32 addr, val;
+
+	if (!info->attrs[WL1271_NL_ATTR_REG_ADDR])
+		return -EINVAL;
+
+	if (!info->attrs[WL1271_NL_ATTR_REG_VAL])
+		return -EINVAL;
+
+	wl = ifname_to_wl1271(&init_net, info);
+	if (wl == NULL) {
+		wl1271_error("wl1271 not found");
+		return -EINVAL;
+	}
+
+	addr = nla_get_u32(info->attrs[WL1271_NL_ATTR_REG_ADDR]);
+	val = nla_get_u32(info->attrs[WL1271_NL_ATTR_REG_VAL]);
+
+	mutex_lock(&wl->mutex);
+	wl1271_reg_write32(wl, addr, val);
+	mutex_unlock(&wl->mutex);
+
+	return 0;
+}
+
+static int wl1271_nl_set_plt_mode(struct sk_buff *skb, struct genl_info *info)
+{
+	struct wl1271 *wl;
+	u32 val;
+	int ret;
+
+	if (!info->attrs[WL1271_NL_ATTR_PLT_MODE])
+		return -EINVAL;
+
+	wl = ifname_to_wl1271(&init_net, info);
+	if (wl == NULL) {
+		wl1271_error("wl1271 not found");
+		return -EINVAL;
+	}
+
+	val = nla_get_u32(info->attrs[WL1271_NL_ATTR_PLT_MODE]);
+
+	switch (val) {
+	case 0:
+		ret = wl1271_plt_stop(wl);
+		break;
+	case 1:
+		ret = wl1271_plt_start(wl);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static struct nla_policy wl1271_nl_policy[WL1271_NL_ATTR_MAX + 1] = {
+	[WL1271_NL_ATTR_IFNAME] =            { .type = NLA_NUL_STRING,
+					       .len = IFNAMSIZ-1 },
+	[WL1271_NL_ATTR_CMD_TEST_PARAM] =    { .type = NLA_BINARY,
+					       .len = WL1271_MAX_TEST_LENGTH },
+	[WL1271_NL_ATTR_CMD_TEST_ANSWER] =   { .type = NLA_U8 },
+	[WL1271_NL_ATTR_CMD_IE] =            { .type = NLA_U32 },
+	[WL1271_NL_ATTR_CMD_IE_LEN] =        { .type = NLA_U32 },
+	[WL1271_NL_ATTR_CMD_IE_BUFFER] =     { .type = NLA_BINARY,
+					       .len = WL1271_MAX_TEST_LENGTH },
+	[WL1271_NL_ATTR_CMD_IE_ANSWER] =     { .type = NLA_BINARY,
+					       .len = WL1271_MAX_TEST_LENGTH },
+	[WL1271_NL_ATTR_REG_ADDR] =          { .type = NLA_U32 },
+	[WL1271_NL_ATTR_REG_VAL] =           { .type = NLA_U32 },
+	[WL1271_NL_ATTR_NVS_BUFFER] =        { .type = NLA_BINARY,
+					       .len = WL1271_MAX_NVS_LENGTH },
+	[WL1271_NL_ATTR_NVS_LEN] =           { .type = NLA_U32 },
+	[WL1271_NL_ATTR_PLT_MODE] =          { .type = NLA_U32 },
+};
+
+static struct genl_ops wl1271_nl_ops[] = {
+	{
+		.cmd = WL1271_NL_CMD_TEST,
+		.doit = wl1271_nl_test_cmd,
+		.policy = wl1271_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = WL1271_NL_CMD_INTERROGATE,
+		.doit = wl1271_nl_interrogate,
+		.policy = wl1271_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = WL1271_NL_CMD_CONFIGURE,
+		.doit = wl1271_nl_configure,
+		.policy = wl1271_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = WL1271_NL_CMD_PHY_REG_READ,
+		.doit = wl1271_nl_phy_reg_read,
+		.policy = wl1271_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = WL1271_NL_CMD_NVS_PUSH,
+		.doit = wl1271_nl_nvs_push,
+		.policy = wl1271_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = WL1271_NL_CMD_REG_WRITE,
+		.doit = wl1271_nl_reg_write,
+		.policy = wl1271_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = WL1271_NL_CMD_REG_READ,
+		.doit = wl1271_nl_reg_read,
+		.policy = wl1271_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = WL1271_NL_CMD_SET_PLT_MODE,
+		.doit = wl1271_nl_set_plt_mode,
+		.policy = wl1271_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+};
+
+int wl1271_nl_register(void)
+{
+	int err, i;
+
+	err = genl_register_family(&wl1271_nl_family);
+	if (err)
+		return err;
+
+	for (i = 0; i < ARRAY_SIZE(wl1271_nl_ops); i++) {
+		err = genl_register_ops(&wl1271_nl_family, &wl1271_nl_ops[i]);
+		if (err)
+			goto err_out;
+	}
+	return 0;
+ err_out:
+	genl_unregister_family(&wl1271_nl_family);
+	return err;
+}
+
+void wl1271_nl_unregister(void)
+{
+	genl_unregister_family(&wl1271_nl_family);
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_netlink.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_netlink.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_netlink.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_netlink.h	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,30 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __WL1271_NETLINK_H__
+#define __WL1271_NETLINK_H__
+
+int wl1271_nl_register(void);
+void wl1271_nl_unregister(void);
+
+#endif /* __WL1271_NETLINK_H__ */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_ps.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_ps.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_ps.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_ps.c	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,127 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include "wl1271_reg.h"
+#include "wl1271_ps.h"
+#include "wl1271_spi.h"
+
+#define WL1271_WAKEUP_TIMEOUT 500
+
+/* Routines to toggle sleep mode while in ELP */
+void wl1271_ps_elp_sleep(struct wl1271 *wl)
+{
+	if (wl->elp || !wl->psm)
+		return;
+
+	/*
+	 * Go to ELP unless there is work already pending - pending work
+	 * will immediately wakeup the chipset anyway.
+	 */
+	if (!work_pending(&wl->irq_work) && !work_pending(&wl->tx_work)) {
+		wl1271_debug(DEBUG_PSM, "chip to elp");
+		wl1271_write32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, ELPCTRL_SLEEP);
+		wl->elp = true;
+	}
+}
+
+int wl1271_ps_elp_wakeup(struct wl1271 *wl, bool chip_awake)
+{
+	DECLARE_COMPLETION_ONSTACK(compl);
+	unsigned long flags;
+	int ret;
+	u32 start_time = jiffies;
+	bool pending = false;
+
+	if (!wl->elp)
+		return 0;
+
+	wl1271_debug(DEBUG_PSM, "waking up chip from elp");
+
+	/*
+	 * The spinlock is required here to synchronize both the work and
+	 * the completion variable in one entity.
+	 */
+	spin_lock_irqsave(&wl->wl_lock, flags);
+	if (work_pending(&wl->irq_work) || chip_awake)
+		pending = true;
+	else
+		wl->elp_compl = &compl;
+	spin_unlock_irqrestore(&wl->wl_lock, flags);
+
+	wl1271_write32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, ELPCTRL_WAKE_UP);
+
+	if (!pending) {
+		ret = wait_for_completion_timeout(
+			&compl, msecs_to_jiffies(WL1271_WAKEUP_TIMEOUT));
+		if (ret == 0)
+			wl1271_error("ELP wakeup timeout!");
+		else if (ret < 0) {
+			wl1271_error("ELP wakeup completion error.");
+			return -EIO;
+		}
+	}
+
+	wl->elp = false;
+
+	wl1271_debug(DEBUG_PSM, "wakeup time: %u ms",
+		     jiffies_to_msecs(jiffies - start_time));
+
+	return 0;
+}
+
+int wl1271_ps_set_mode(struct wl1271 *wl, enum wl1271_cmd_ps_mode mode)
+{
+	int ret;
+
+	switch (mode) {
+	case STATION_POWER_SAVE_MODE:
+		wl1271_debug(DEBUG_PSM, "entering psm");
+		ret = wl1271_cmd_ps_mode(wl, STATION_POWER_SAVE_MODE);
+		if (ret < 0)
+			return ret;
+
+		wl1271_ps_elp_sleep(wl);
+		if (ret < 0)
+			return ret;
+
+		wl->psm = 1;
+		break;
+	case STATION_ACTIVE_MODE:
+	default:
+		wl1271_debug(DEBUG_PSM, "leaving psm");
+		ret = wl1271_ps_elp_wakeup(wl, false);
+		if (ret < 0)
+			return ret;
+
+		ret = wl1271_cmd_ps_mode(wl, STATION_ACTIVE_MODE);
+		if (ret < 0)
+			return ret;
+
+		wl->psm = 0;
+		break;
+	}
+
+	return ret;
+}
+
+
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_ps.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_ps.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_ps.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_ps.h	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,36 @@
+#ifndef __WL1271_PS_H__
+#define __WL1271_PS_H__
+
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include "wl1271.h"
+#include "wl1271_acx.h"
+
+int wl1271_ps_set_mode(struct wl1271 *wl, enum wl1271_cmd_ps_mode mode);
+void wl1271_ps_elp_sleep(struct wl1271 *wl);
+int wl1271_ps_elp_wakeup(struct wl1271 *wl, bool chip_awake);
+
+
+#endif /* __WL1271_PS_H__ */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_reg.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_reg.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_reg.h	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,758 @@
+/*
+ * This file is part of wl12xx
+ *
+ * Copyright (C) 1998-2009 Texas Instruments Incorporated
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __REG_H__
+#define __REG_H__
+
+#include <linux/bitops.h>
+
+#define REGISTERS_BASE 0x00300000
+#define DRPW_BASE      0x00310000
+
+#define REGISTERS_DOWN_SIZE 0x00008800
+#define REGISTERS_WORK_SIZE 0x0000b000
+
+#define HW_ACCESS_ELP_CTRL_REG_ADDR         0x1FFFC
+#define STATUS_MEM_ADDRESS                  0x40400
+
+/* ELP register commands */
+#define ELPCTRL_WAKE_UP             0x1
+#define ELPCTRL_WAKE_UP_WLAN_READY  0x5
+#define ELPCTRL_SLEEP               0x0
+/* ELP WLAN_READY bit */
+#define ELPCTRL_WLAN_READY          0x2
+
+/*===============================================
+   Host Software Reset - 32bit RW
+ ------------------------------------------
+    [31:1] Reserved
+    0  SOFT_RESET Soft Reset  - When this bit is set,
+    it holds the Wlan hardware in a soft reset state.
+    This reset disables all MAC and baseband processor
+    clocks except the CardBus/PCI interface clock.
+    It also initializes all MAC state machines except
+    the host interface. It does not reload the
+    contents of the EEPROM. When this bit is cleared
+    (not self-clearing), the Wlan hardware
+    exits the software reset state.
+===============================================*/
+#define ACX_REG_SLV_SOFT_RESET         (REGISTERS_BASE + 0x0000)
+
+#define WL1271_SLV_REG_DATA            (REGISTERS_BASE + 0x0008)
+#define WL1271_SLV_REG_ADATA           (REGISTERS_BASE + 0x000c)
+#define WL1271_SLV_MEM_DATA            (REGISTERS_BASE + 0x0018)
+/*
+ * Interrupt registers.
+ * 64 bit interrupt sources registers ws ced.
+ * sme interupts were removed and new ones were added.
+ * Order was changed.
+ */
+#define FIQ_MASK                       (REGISTERS_BASE + 0x0400)
+#define FIQ_MASK_L                     (REGISTERS_BASE + 0x0400)
+#define FIQ_MASK_H                     (REGISTERS_BASE + 0x0404)
+#define FIQ_MASK_SET                   (REGISTERS_BASE + 0x0408)
+#define FIQ_MASK_SET_L                 (REGISTERS_BASE + 0x0408)
+#define FIQ_MASK_SET_H                 (REGISTERS_BASE + 0x040C)
+#define FIQ_MASK_CLR                   (REGISTERS_BASE + 0x0410)
+#define FIQ_MASK_CLR_L                 (REGISTERS_BASE + 0x0410)
+#define FIQ_MASK_CLR_H                 (REGISTERS_BASE + 0x0414)
+#define IRQ_MASK                       (REGISTERS_BASE + 0x0418)
+#define IRQ_MASK_L                     (REGISTERS_BASE + 0x0418)
+#define IRQ_MASK_H                     (REGISTERS_BASE + 0x041C)
+#define IRQ_MASK_SET                   (REGISTERS_BASE + 0x0420)
+#define IRQ_MASK_SET_L                 (REGISTERS_BASE + 0x0420)
+#define IRQ_MASK_SET_H                 (REGISTERS_BASE + 0x0424)
+#define IRQ_MASK_CLR                   (REGISTERS_BASE + 0x0428)
+#define IRQ_MASK_CLR_L                 (REGISTERS_BASE + 0x0428)
+#define IRQ_MASK_CLR_H                 (REGISTERS_BASE + 0x042C)
+#define ECPU_MASK                      (REGISTERS_BASE + 0x0448)
+#define FIQ_STS_L                      (REGISTERS_BASE + 0x044C)
+#define FIQ_STS_H                      (REGISTERS_BASE + 0x0450)
+#define IRQ_STS_L                      (REGISTERS_BASE + 0x0454)
+#define IRQ_STS_H                      (REGISTERS_BASE + 0x0458)
+#define INT_STS_ND                     (REGISTERS_BASE + 0x0464)
+#define INT_STS_RAW_L                  (REGISTERS_BASE + 0x0464)
+#define INT_STS_RAW_H                  (REGISTERS_BASE + 0x0468)
+#define INT_STS_CLR                    (REGISTERS_BASE + 0x04B4)
+#define INT_STS_CLR_L                  (REGISTERS_BASE + 0x04B4)
+#define INT_STS_CLR_H                  (REGISTERS_BASE + 0x04B8)
+#define INT_ACK                        (REGISTERS_BASE + 0x046C)
+#define INT_ACK_L                      (REGISTERS_BASE + 0x046C)
+#define INT_ACK_H                      (REGISTERS_BASE + 0x0470)
+#define INT_TRIG                       (REGISTERS_BASE + 0x0474)
+#define INT_TRIG_L                     (REGISTERS_BASE + 0x0474)
+#define INT_TRIG_H                     (REGISTERS_BASE + 0x0478)
+#define HOST_STS_L                     (REGISTERS_BASE + 0x045C)
+#define HOST_STS_H                     (REGISTERS_BASE + 0x0460)
+#define HOST_MASK                      (REGISTERS_BASE + 0x0430)
+#define HOST_MASK_L                    (REGISTERS_BASE + 0x0430)
+#define HOST_MASK_H                    (REGISTERS_BASE + 0x0434)
+#define HOST_MASK_SET                  (REGISTERS_BASE + 0x0438)
+#define HOST_MASK_SET_L                (REGISTERS_BASE + 0x0438)
+#define HOST_MASK_SET_H                (REGISTERS_BASE + 0x043C)
+#define HOST_MASK_CLR                  (REGISTERS_BASE + 0x0440)
+#define HOST_MASK_CLR_L                (REGISTERS_BASE + 0x0440)
+#define HOST_MASK_CLR_H                (REGISTERS_BASE + 0x0444)
+
+#define ACX_REG_INTERRUPT_TRIG         (REGISTERS_BASE + 0x0474)
+#define ACX_REG_INTERRUPT_TRIG_H       (REGISTERS_BASE + 0x0478)
+
+/* Host Interrupts*/
+#define HINT_MASK                      (REGISTERS_BASE + 0x0494)
+#define HINT_MASK_SET                  (REGISTERS_BASE + 0x0498)
+#define HINT_MASK_CLR                  (REGISTERS_BASE + 0x049C)
+#define HINT_STS_ND_MASKED             (REGISTERS_BASE + 0x04A0)
+/*1150 spec calls this HINT_STS_RAW*/
+#define HINT_STS_ND		       (REGISTERS_BASE + 0x04B0)
+#define HINT_STS_CLR                   (REGISTERS_BASE + 0x04A4)
+#define HINT_ACK                       (REGISTERS_BASE + 0x04A8)
+#define HINT_TRIG                      (REGISTERS_BASE + 0x04AC)
+
+/*=============================================
+  Host Interrupt Mask Register - 32bit (RW)
+  ------------------------------------------
+  Setting a bit in this register masks the
+  corresponding interrupt to the host.
+  0 - RX0		- Rx first dubble buffer Data Interrupt
+  1 - TXD		- Tx Data Interrupt
+  2 - TXXFR		- Tx Transfer Interrupt
+  3 - RX1		- Rx second dubble buffer Data Interrupt
+  4 - RXXFR		- Rx Transfer Interrupt
+  5 - EVENT_A	- Event Mailbox interrupt
+  6 - EVENT_B	- Event Mailbox interrupt
+  7 - WNONHST	- Wake On Host Interrupt
+  8 - TRACE_A	- Debug Trace interrupt
+  9 - TRACE_B	- Debug Trace interrupt
+ 10 - CDCMP		- Command Complete Interrupt
+ 11 -
+ 12 -
+ 13 -
+ 14 - ICOMP		- Initialization Complete Interrupt
+ 16 - SG SE		- Soft Gemini - Sense enable interrupt
+ 17 - SG SD		- Soft Gemini - Sense disable interrupt
+ 18 -			-
+ 19 -			-
+ 20 -			-
+ 21-			-
+ Default: 0x0001
+*==============================================*/
+#define ACX_REG_INTERRUPT_MASK         (REGISTERS_BASE + 0x04DC)
+
+/*=============================================
+  Host Interrupt Mask Set 16bit, (Write only)
+  ------------------------------------------
+ Setting a bit in this register sets
+ the corresponding bin in ACX_HINT_MASK register
+ without effecting the mask
+ state of other bits (0 = no effect).
+==============================================*/
+#define ACX_REG_HINT_MASK_SET          (REGISTERS_BASE + 0x04E0)
+
+/*=============================================
+  Host Interrupt Mask Clear 16bit,(Write only)
+  ------------------------------------------
+ Setting a bit in this register clears
+ the corresponding bin in ACX_HINT_MASK register
+ without effecting the mask
+ state of other bits (0 = no effect).
+=============================================*/
+#define ACX_REG_HINT_MASK_CLR          (REGISTERS_BASE + 0x04E4)
+
+/*=============================================
+  Host Interrupt Status Nondestructive Read
+  16bit,(Read only)
+  ------------------------------------------
+ The host can read this register to determine
+ which interrupts are active.
+ Reading this register doesn't
+ effect its content.
+=============================================*/
+#define ACX_REG_INTERRUPT_NO_CLEAR     (REGISTERS_BASE + 0x04E8)
+
+/*=============================================
+  Host Interrupt Status Clear on Read  Register
+  16bit,(Read only)
+  ------------------------------------------
+ The host can read this register to determine
+ which interrupts are active.
+ Reading this register clears it,
+ thus making all interrupts inactive.
+==============================================*/
+#define ACX_REG_INTERRUPT_CLEAR        (REGISTERS_BASE + 0x04F8)
+
+/*=============================================
+  Host Interrupt Acknowledge Register
+  16bit,(Write only)
+  ------------------------------------------
+ The host can set individual bits in this
+ register to clear (acknowledge) the corresp.
+ interrupt status bits in the HINT_STS_CLR and
+ HINT_STS_ND registers, thus making the
+ assotiated interrupt inactive. (0-no effect)
+==============================================*/
+#define ACX_REG_INTERRUPT_ACK          (REGISTERS_BASE + 0x04F0)
+
+#define RX_DRIVER_DUMMY_WRITE_ADDRESS  (REGISTERS_BASE + 0x0534)
+#define RX_DRIVER_COUNTER_ADDRESS      (REGISTERS_BASE + 0x0538)
+
+/* Device Configuration registers*/
+#define SOR_CFG                        (REGISTERS_BASE + 0x0800)
+
+/* Embedded ARM CPU Control */
+
+/*===============================================
+ Halt eCPU   - 32bit RW
+ ------------------------------------------
+ 0 HALT_ECPU Halt Embedded CPU - This bit is the
+ compliment of bit 1 (MDATA2) in the SOR_CFG register.
+ During a hardware reset, this bit holds
+ the inverse of MDATA2.
+ When downloading firmware from the host,
+ set this bit (pull down MDATA2).
+ The host clears this bit after downloading the firmware into
+ zero-wait-state SSRAM.
+ When loading firmware from Flash, clear this bit (pull up MDATA2)
+ so that the eCPU can run the bootloader code in Flash
+ HALT_ECPU eCPU State
+ --------------------
+ 1 halt eCPU
+ 0 enable eCPU
+ ===============================================*/
+#define ACX_REG_ECPU_CONTROL           (REGISTERS_BASE + 0x0804)
+
+#define HI_CFG                         (REGISTERS_BASE + 0x0808)
+
+/*===============================================
+ EEPROM Burst Read Start  - 32bit RW
+ ------------------------------------------
+ [31:1] Reserved
+ 0  ACX_EE_START -  EEPROM Burst Read Start 0
+ Setting this bit starts a burst read from
+ the external EEPROM.
+ If this bit is set (after reset) before an EEPROM read/write,
+ the burst read starts at EEPROM address 0.
+ Otherwise, it starts at the address
+ following the address of the previous access.
+ TheWlan hardware hardware clears this bit automatically.
+
+ Default: 0x00000000
+*================================================*/
+#define ACX_REG_EE_START               (REGISTERS_BASE + 0x080C)
+
+#define OCP_POR_CTR                    (REGISTERS_BASE + 0x09B4)
+#define OCP_DATA_WRITE                 (REGISTERS_BASE + 0x09B8)
+#define OCP_DATA_READ                  (REGISTERS_BASE + 0x09BC)
+#define OCP_CMD                        (REGISTERS_BASE + 0x09C0)
+
+#define WL1271_HOST_WR_ACCESS          (REGISTERS_BASE + 0x09F8)
+
+#define CHIP_ID_B                      (REGISTERS_BASE + 0x5674)
+
+#define CHIP_ID_1271_PG10              (0x4030101)
+#define CHIP_ID_1271_PG20              (0x4030111)
+
+#define ENABLE                         (REGISTERS_BASE + 0x5450)
+
+/* Power Management registers */
+#define ELP_CFG_MODE                   (REGISTERS_BASE + 0x5804)
+#define ELP_CMD                        (REGISTERS_BASE + 0x5808)
+#define PLL_CAL_TIME                   (REGISTERS_BASE + 0x5810)
+#define CLK_REQ_TIME                   (REGISTERS_BASE + 0x5814)
+#define CLK_BUF_TIME                   (REGISTERS_BASE + 0x5818)
+
+#define CFG_PLL_SYNC_CNT               (REGISTERS_BASE + 0x5820)
+
+/* Scratch Pad registers*/
+#define SCR_PAD0                       (REGISTERS_BASE + 0x5608)
+#define SCR_PAD1                       (REGISTERS_BASE + 0x560C)
+#define SCR_PAD2                       (REGISTERS_BASE + 0x5610)
+#define SCR_PAD3                       (REGISTERS_BASE + 0x5614)
+#define SCR_PAD4                       (REGISTERS_BASE + 0x5618)
+#define SCR_PAD4_SET                   (REGISTERS_BASE + 0x561C)
+#define SCR_PAD4_CLR                   (REGISTERS_BASE + 0x5620)
+#define SCR_PAD5                       (REGISTERS_BASE + 0x5624)
+#define SCR_PAD5_SET                   (REGISTERS_BASE + 0x5628)
+#define SCR_PAD5_CLR                   (REGISTERS_BASE + 0x562C)
+#define SCR_PAD6                       (REGISTERS_BASE + 0x5630)
+#define SCR_PAD7                       (REGISTERS_BASE + 0x5634)
+#define SCR_PAD8                       (REGISTERS_BASE + 0x5638)
+#define SCR_PAD9                       (REGISTERS_BASE + 0x563C)
+
+/* Spare registers*/
+#define SPARE_A1                       (REGISTERS_BASE + 0x0994)
+#define SPARE_A2                       (REGISTERS_BASE + 0x0998)
+#define SPARE_A3                       (REGISTERS_BASE + 0x099C)
+#define SPARE_A4                       (REGISTERS_BASE + 0x09A0)
+#define SPARE_A5                       (REGISTERS_BASE + 0x09A4)
+#define SPARE_A6                       (REGISTERS_BASE + 0x09A8)
+#define SPARE_A7                       (REGISTERS_BASE + 0x09AC)
+#define SPARE_A8                       (REGISTERS_BASE + 0x09B0)
+#define SPARE_B1                       (REGISTERS_BASE + 0x5420)
+#define SPARE_B2                       (REGISTERS_BASE + 0x5424)
+#define SPARE_B3                       (REGISTERS_BASE + 0x5428)
+#define SPARE_B4                       (REGISTERS_BASE + 0x542C)
+#define SPARE_B5                       (REGISTERS_BASE + 0x5430)
+#define SPARE_B6                       (REGISTERS_BASE + 0x5434)
+#define SPARE_B7                       (REGISTERS_BASE + 0x5438)
+#define SPARE_B8                       (REGISTERS_BASE + 0x543C)
+
+#define PLL_PARAMETERS                 (REGISTERS_BASE + 0x6040)
+#define WU_COUNTER_PAUSE               (REGISTERS_BASE + 0x6008)
+#define WELP_ARM_COMMAND               (REGISTERS_BASE + 0x6100)
+#define DRPW_SCRATCH_START             (DRPW_BASE + 0x002C)
+
+
+#define ACX_SLV_SOFT_RESET_BIT   BIT(1)
+#define ACX_REG_EEPROM_START_BIT BIT(1)
+
+/* Command/Information Mailbox Pointers */
+
+/*===============================================
+  Command Mailbox Pointer - 32bit RW
+ ------------------------------------------
+ This register holds the start address of
+ the command mailbox located in the Wlan hardware memory.
+ The host must read this pointer after a reset to
+ find the location of the command mailbox.
+ The Wlan hardware initializes the command mailbox
+ pointer with the default address of the command mailbox.
+ The command mailbox pointer is not valid until after
+ the host receives the Init Complete interrupt from
+ the Wlan hardware.
+ ===============================================*/
+#define REG_COMMAND_MAILBOX_PTR				(SCR_PAD0)
+
+/*===============================================
+  Information Mailbox Pointer - 32bit RW
+ ------------------------------------------
+ This register holds the start address of
+ the information mailbox located in the Wlan hardware memory.
+ The host must read this pointer after a reset to find
+ the location of the information mailbox.
+ The Wlan hardware initializes the information mailbox pointer
+ with the default address of the information mailbox.
+ The information mailbox pointer is not valid
+ until after the host receives the Init Complete interrupt from
+ the Wlan hardware.
+ ===============================================*/
+#define REG_EVENT_MAILBOX_PTR				(SCR_PAD1)
+
+
+/* Misc */
+
+#define REG_ENABLE_TX_RX				(ENABLE)
+/*
+ * Rx configuration (filter) information element
+ * ---------------------------------------------
+ */
+#define REG_RX_CONFIG				(RX_CFG)
+#define REG_RX_FILTER				(RX_FILTER_CFG)
+
+
+#define RX_CFG_ENABLE_PHY_HEADER_PLCP	 0x0002
+
+/* promiscuous - receives all valid frames */
+#define RX_CFG_PROMISCUOUS		 0x0008
+
+/* receives frames from any BSSID */
+#define RX_CFG_BSSID			 0x0020
+
+/* receives frames destined to any MAC address */
+#define RX_CFG_MAC			 0x0010
+
+#define RX_CFG_ENABLE_ONLY_MY_DEST_MAC	 0x0010
+#define RX_CFG_ENABLE_ANY_DEST_MAC	 0x0000
+#define RX_CFG_ENABLE_ONLY_MY_BSSID	 0x0020
+#define RX_CFG_ENABLE_ANY_BSSID		 0x0000
+
+/* discards all broadcast frames */
+#define RX_CFG_DISABLE_BCAST		 0x0200
+
+#define RX_CFG_ENABLE_ONLY_MY_SSID	 0x0400
+#define RX_CFG_ENABLE_RX_CMPLT_FCS_ERROR 0x0800
+#define RX_CFG_COPY_RX_STATUS		 0x2000
+#define RX_CFG_TSF			 0x10000
+
+#define RX_CONFIG_OPTION_ANY_DST_MY_BSS	 (RX_CFG_ENABLE_ANY_DEST_MAC | \
+					  RX_CFG_ENABLE_ONLY_MY_BSSID)
+
+#define RX_CONFIG_OPTION_MY_DST_ANY_BSS	 (RX_CFG_ENABLE_ONLY_MY_DEST_MAC\
+					  | RX_CFG_ENABLE_ANY_BSSID)
+
+#define RX_CONFIG_OPTION_ANY_DST_ANY_BSS (RX_CFG_ENABLE_ANY_DEST_MAC | \
+					  RX_CFG_ENABLE_ANY_BSSID)
+
+#define RX_CONFIG_OPTION_MY_DST_MY_BSS	 (RX_CFG_ENABLE_ONLY_MY_DEST_MAC\
+					  | RX_CFG_ENABLE_ONLY_MY_BSSID)
+
+#define RX_CONFIG_OPTION_FOR_SCAN  (RX_CFG_ENABLE_PHY_HEADER_PLCP \
+				    | RX_CFG_ENABLE_RX_CMPLT_FCS_ERROR \
+				    | RX_CFG_COPY_RX_STATUS | RX_CFG_TSF)
+
+#define RX_CONFIG_OPTION_FOR_MEASUREMENT (RX_CFG_ENABLE_ANY_DEST_MAC)
+
+#define RX_CONFIG_OPTION_FOR_JOIN	 (RX_CFG_ENABLE_ONLY_MY_BSSID | \
+					  RX_CFG_ENABLE_ONLY_MY_DEST_MAC)
+
+#define RX_CONFIG_OPTION_FOR_IBSS_JOIN   (RX_CFG_ENABLE_ONLY_MY_SSID | \
+					  RX_CFG_ENABLE_ONLY_MY_DEST_MAC)
+
+#define RX_FILTER_OPTION_DEF	      (CFG_RX_MGMT_EN | CFG_RX_DATA_EN\
+				       | CFG_RX_CTL_EN | CFG_RX_BCN_EN\
+				       | CFG_RX_AUTH_EN | CFG_RX_ASSOC_EN)
+
+#define RX_FILTER_OPTION_FILTER_ALL	 0
+
+#define RX_FILTER_OPTION_DEF_PRSP_BCN  (CFG_RX_PRSP_EN | CFG_RX_MGMT_EN\
+					| CFG_RX_RCTS_ACK | CFG_RX_BCN_EN)
+
+#define RX_FILTER_OPTION_JOIN	     (CFG_RX_MGMT_EN | CFG_RX_DATA_EN\
+				      | CFG_RX_BCN_EN | CFG_RX_AUTH_EN\
+				      | CFG_RX_ASSOC_EN | CFG_RX_RCTS_ACK\
+				      | CFG_RX_PRSP_EN)
+
+
+/*===============================================
+  Phy regs
+ ===============================================*/
+#define ACX_PHY_ADDR_REG                SBB_ADDR
+#define ACX_PHY_DATA_REG                SBB_DATA
+#define ACX_PHY_CTRL_REG                SBB_CTL
+#define ACX_PHY_REG_WR_MASK             0x00000001ul
+#define ACX_PHY_REG_RD_MASK             0x00000002ul
+
+
+/*===============================================
+ EEPROM Read/Write Request 32bit RW
+ ------------------------------------------
+ 1 EE_READ - EEPROM Read Request 1 - Setting this bit
+ loads a single byte of data into the EE_DATA
+ register from the EEPROM location specified in
+ the EE_ADDR register.
+ The Wlan hardware hardware clears this bit automatically.
+ EE_DATA is valid when this bit is cleared.
+
+ 0 EE_WRITE  - EEPROM Write Request  - Setting this bit
+ writes a single byte of data from the EE_DATA register into the
+ EEPROM location specified in the EE_ADDR register.
+ The Wlan hardware hardware clears this bit automatically.
+*===============================================*/
+#define ACX_EE_CTL_REG                      EE_CTL
+#define EE_WRITE                            0x00000001ul
+#define EE_READ                             0x00000002ul
+
+/*===============================================
+  EEPROM Address  - 32bit RW
+  ------------------------------------------
+  This register specifies the address
+  within the EEPROM from/to which to read/write data.
+  ===============================================*/
+#define ACX_EE_ADDR_REG                     EE_ADDR
+
+/*===============================================
+  EEPROM Data  - 32bit RW
+  ------------------------------------------
+  This register either holds the read 8 bits of
+  data from the EEPROM or the write data
+  to be written to the EEPROM.
+  ===============================================*/
+#define ACX_EE_DATA_REG                     EE_DATA
+
+/*===============================================
+  EEPROM Base Address  - 32bit RW
+  ------------------------------------------
+  This register holds the upper nine bits
+  [23:15] of the 24-bit Wlan hardware memory
+  address for burst reads from EEPROM accesses.
+  The EEPROM provides the lower 15 bits of this address.
+  The MSB of the address from the EEPROM is ignored.
+  ===============================================*/
+#define ACX_EE_CFG                          EE_CFG
+
+/*===============================================
+  GPIO Output Values  -32bit, RW
+  ------------------------------------------
+  [31:16]  Reserved
+  [15: 0]  Specify the output values (at the output driver inputs) for
+  GPIO[15:0], respectively.
+  ===============================================*/
+#define ACX_GPIO_OUT_REG            GPIO_OUT
+#define ACX_MAX_GPIO_LINES          15
+
+/*===============================================
+  Contention window  -32bit, RW
+  ------------------------------------------
+  [31:26]  Reserved
+  [25:16]  Max (0x3ff)
+  [15:07]  Reserved
+  [06:00]  Current contention window value - default is 0x1F
+  ===============================================*/
+#define ACX_CONT_WIND_CFG_REG    CONT_WIND_CFG
+#define ACX_CONT_WIND_MIN_MASK   0x0000007f
+#define ACX_CONT_WIND_MAX        0x03ff0000
+
+/*
+ * Indirect slave register/memory registers
+ * ----------------------------------------
+ */
+#define HW_SLAVE_REG_ADDR_REG		0x00000004
+#define HW_SLAVE_REG_DATA_REG		0x00000008
+#define HW_SLAVE_REG_CTRL_REG		0x0000000c
+
+#define SLAVE_AUTO_INC				0x00010000
+#define SLAVE_NO_AUTO_INC			0x00000000
+#define SLAVE_HOST_LITTLE_ENDIAN	0x00000000
+
+#define HW_SLAVE_MEM_ADDR_REG		SLV_MEM_ADDR
+#define HW_SLAVE_MEM_DATA_REG		SLV_MEM_DATA
+#define HW_SLAVE_MEM_CTRL_REG		SLV_MEM_CTL
+#define HW_SLAVE_MEM_ENDIAN_REG		SLV_END_CTL
+
+#define HW_FUNC_EVENT_INT_EN		0x8000
+#define HW_FUNC_EVENT_MASK_REG		0x00000034
+
+#define ACX_MAC_TIMESTAMP_REG	(MAC_TIMESTAMP)
+
+/*===============================================
+  HI_CFG Interface Configuration Register Values
+  ------------------------------------------
+  ===============================================*/
+#define HI_CFG_UART_ENABLE          0x00000004
+#define HI_CFG_RST232_ENABLE        0x00000008
+#define HI_CFG_CLOCK_REQ_SELECT     0x00000010
+#define HI_CFG_HOST_INT_ENABLE      0x00000020
+#define HI_CFG_VLYNQ_OUTPUT_ENABLE  0x00000040
+#define HI_CFG_HOST_INT_ACTIVE_LOW  0x00000080
+#define HI_CFG_UART_TX_OUT_GPIO_15  0x00000100
+#define HI_CFG_UART_TX_OUT_GPIO_14  0x00000200
+#define HI_CFG_UART_TX_OUT_GPIO_7   0x00000400
+
+/*
+ * NOTE: USE_ACTIVE_HIGH compilation flag should be defined in makefile
+ *       for platforms using active high interrupt level
+ */
+#ifdef USE_ACTIVE_HIGH
+#define HI_CFG_DEF_VAL              \
+	(HI_CFG_UART_ENABLE |        \
+	HI_CFG_RST232_ENABLE |      \
+	HI_CFG_CLOCK_REQ_SELECT |   \
+	HI_CFG_HOST_INT_ENABLE)
+#else
+#define HI_CFG_DEF_VAL              \
+	(HI_CFG_UART_ENABLE |        \
+	HI_CFG_RST232_ENABLE |      \
+	HI_CFG_CLOCK_REQ_SELECT |   \
+	HI_CFG_HOST_INT_ENABLE)
+
+#endif
+
+#define REF_FREQ_19_2                       0
+#define REF_FREQ_26_0                       1
+#define REF_FREQ_38_4                       2
+#define REF_FREQ_40_0                       3
+#define REF_FREQ_33_6                       4
+#define REF_FREQ_NUM                        5
+
+#define LUT_PARAM_INTEGER_DIVIDER           0
+#define LUT_PARAM_FRACTIONAL_DIVIDER        1
+#define LUT_PARAM_ATTN_BB                   2
+#define LUT_PARAM_ALPHA_BB                  3
+#define LUT_PARAM_STOP_TIME_BB              4
+#define LUT_PARAM_BB_PLL_LOOP_FILTER        5
+#define LUT_PARAM_NUM                       6
+
+#define ACX_EEPROMLESS_IND_REG              (SCR_PAD4)
+#define USE_EEPROM                          0
+#define SOFT_RESET_MAX_TIME                 1000000
+#define SOFT_RESET_STALL_TIME               1000
+#define NVS_DATA_BUNDARY_ALIGNMENT          4
+
+
+/* Firmware image load chunk size */
+#define CHUNK_SIZE          512
+
+/* Firmware image header size */
+#define FW_HDR_SIZE 8
+
+#define ECPU_CONTROL_HALT					0x00000101
+
+
+/******************************************************************************
+
+    CHANNELS, BAND & REG DOMAINS definitions
+
+******************************************************************************/
+
+
+enum {
+	RADIO_BAND_2_4GHZ = 0,  /* 2.4 Ghz band */
+	RADIO_BAND_5GHZ = 1,    /* 5 Ghz band */
+	RADIO_BAND_JAPAN_4_9_GHZ = 2,
+	DEFAULT_BAND = RADIO_BAND_2_4GHZ,
+	INVALID_BAND = 0xFE,
+	MAX_RADIO_BANDS = 0xFF
+};
+
+enum {
+	NO_RATE      = 0,
+	RATE_1MBPS   = 0x0A,
+	RATE_2MBPS   = 0x14,
+	RATE_5_5MBPS = 0x37,
+	RATE_6MBPS   = 0x0B,
+	RATE_9MBPS   = 0x0F,
+	RATE_11MBPS  = 0x6E,
+	RATE_12MBPS  = 0x0A,
+	RATE_18MBPS  = 0x0E,
+	RATE_22MBPS  = 0xDC,
+	RATE_24MBPS  = 0x09,
+	RATE_36MBPS  = 0x0D,
+	RATE_48MBPS  = 0x08,
+	RATE_54MBPS  = 0x0C
+};
+
+enum {
+	RATE_INDEX_1MBPS   =  0,
+	RATE_INDEX_2MBPS   =  1,
+	RATE_INDEX_5_5MBPS =  2,
+	RATE_INDEX_6MBPS   =  3,
+	RATE_INDEX_9MBPS   =  4,
+	RATE_INDEX_11MBPS  =  5,
+	RATE_INDEX_12MBPS  =  6,
+	RATE_INDEX_18MBPS  =  7,
+	RATE_INDEX_22MBPS  =  8,
+	RATE_INDEX_24MBPS  =  9,
+	RATE_INDEX_36MBPS  =  10,
+	RATE_INDEX_48MBPS  =  11,
+	RATE_INDEX_54MBPS  =  12,
+	RATE_INDEX_MAX     =  RATE_INDEX_54MBPS,
+	MAX_RATE_INDEX,
+	INVALID_RATE_INDEX = MAX_RATE_INDEX,
+	RATE_INDEX_ENUM_MAX_SIZE = 0x7FFFFFFF
+};
+
+enum {
+	RATE_MASK_1MBPS = 0x1,
+	RATE_MASK_2MBPS = 0x2,
+	RATE_MASK_5_5MBPS = 0x4,
+	RATE_MASK_11MBPS = 0x20,
+};
+
+#define SHORT_PREAMBLE_BIT   BIT(0) /* CCK or Barker depending on the rate */
+#define OFDM_RATE_BIT        BIT(6)
+#define PBCC_RATE_BIT        BIT(7)
+
+enum {
+	CCK_LONG = 0,
+	CCK_SHORT = SHORT_PREAMBLE_BIT,
+	PBCC_LONG = PBCC_RATE_BIT,
+	PBCC_SHORT = PBCC_RATE_BIT | SHORT_PREAMBLE_BIT,
+	OFDM = OFDM_RATE_BIT
+};
+
+/******************************************************************************
+
+Transmit-Descriptor RATE-SET field definitions...
+
+Define a new "Rate-Set" for TX path that incorporates the
+Rate & Modulation info into a single 16-bit field.
+
+TxdRateSet_t:
+b15   - Indicates Preamble type (1=SHORT, 0=LONG).
+	Notes:
+	Must be LONG (0) for 1Mbps rate.
+	Does not apply (set to 0) for RevG-OFDM rates.
+b14   - Indicates PBCC encoding (1=PBCC, 0=not).
+	Notes:
+	Does not apply (set to 0) for rates 1 and 2 Mbps.
+	Does not apply (set to 0) for RevG-OFDM rates.
+b13    - Unused (set to 0).
+b12-b0 - Supported Rate indicator bits as defined below.
+
+******************************************************************************/
+
+
+#define TNETW1251_CHIP_ID_PG1_0         0x07010101
+#define TNETW1251_CHIP_ID_PG1_1         0x07020101
+#define TNETW1251_CHIP_ID_PG1_2	        0x07030101
+
+/*************************************************************************
+
+    Interrupt Trigger Register (Host -> WiLink)
+
+**************************************************************************/
+
+/* Hardware to Embedded CPU Interrupts - first 32-bit register set */
+
+/*
+ * Host Command Interrupt. Setting this bit masks
+ * the interrupt that the host issues to inform
+ * the FW that it has sent a command
+ * to the Wlan hardware Command Mailbox.
+ */
+#define INTR_TRIG_CMD       BIT(0)
+
+/*
+ * Host Event Acknowlegde Interrupt. The host
+ * sets this bit to acknowledge that it received
+ * the unsolicited information from the event
+ * mailbox.
+ */
+#define INTR_TRIG_EVENT_ACK BIT(1)
+
+/*
+ * The host sets this bit to inform the Wlan
+ * FW that a TX packet is in the XFER
+ * Buffer #0.
+ */
+#define INTR_TRIG_TX_PROC0 BIT(2)
+
+/*
+ * The host sets this bit to inform the FW
+ * that it read a packet from RX XFER
+ * Buffer #0.
+ */
+#define INTR_TRIG_RX_PROC0 BIT(3)
+
+#define INTR_TRIG_DEBUG_ACK BIT(4)
+
+#define INTR_TRIG_STATE_CHANGED BIT(5)
+
+
+/* Hardware to Embedded CPU Interrupts - second 32-bit register set */
+
+/*
+ * The host sets this bit to inform the FW
+ * that it read a packet from RX XFER
+ * Buffer #1.
+ */
+#define INTR_TRIG_RX_PROC1 BIT(17)
+
+/*
+ * The host sets this bit to inform the Wlan
+ * hardware that a TX packet is in the XFER
+ * Buffer #1.
+ */
+#define INTR_TRIG_TX_PROC1 BIT(18)
+
+#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_rx.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_rx.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_rx.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_rx.c	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,199 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include "wl1271.h"
+#include "wl1271_acx.h"
+#include "wl1271_reg.h"
+#include "wl1271_rx.h"
+#include "wl1271_spi.h"
+
+static u8 wl1271_rx_get_mem_block(struct wl1271_fw_status *status,
+				  u32 drv_rx_counter)
+{
+	return status->rx_pkt_descs[drv_rx_counter] & RX_MEM_BLOCK_MASK;
+}
+
+static u32 wl1271_rx_get_buf_size(struct wl1271_fw_status *status,
+				 u32 drv_rx_counter)
+{
+	return (status->rx_pkt_descs[drv_rx_counter] & RX_BUF_SIZE_MASK) >>
+		RX_BUF_SIZE_SHIFT_DIV;
+}
+
+/* The values of this table must match the wl1271_rates[] array */
+static u8 wl1271_rx_rate_to_idx[] = {
+	/* MCS rates are used only with 11n */
+	WL1271_RX_RATE_UNSUPPORTED, /* WL1271_RATE_MCS7 */
+	WL1271_RX_RATE_UNSUPPORTED, /* WL1271_RATE_MCS6 */
+	WL1271_RX_RATE_UNSUPPORTED, /* WL1271_RATE_MCS5 */
+	WL1271_RX_RATE_UNSUPPORTED, /* WL1271_RATE_MCS4 */
+	WL1271_RX_RATE_UNSUPPORTED, /* WL1271_RATE_MCS3 */
+	WL1271_RX_RATE_UNSUPPORTED, /* WL1271_RATE_MCS2 */
+	WL1271_RX_RATE_UNSUPPORTED, /* WL1271_RATE_MCS1 */
+	WL1271_RX_RATE_UNSUPPORTED, /* WL1271_RATE_MCS0 */
+
+	11,                         /* WL1271_RATE_54   */
+	10,                         /* WL1271_RATE_48   */
+	9,                          /* WL1271_RATE_36   */
+	8,                          /* WL1271_RATE_24   */
+
+	/* TI-specific rate */
+	WL1271_RX_RATE_UNSUPPORTED, /* WL1271_RATE_22   */
+
+	7,                          /* WL1271_RATE_18   */
+	6,                          /* WL1271_RATE_12   */
+	3,                          /* WL1271_RATE_11   */
+	5,                          /* WL1271_RATE_9    */
+	4,                          /* WL1271_RATE_6    */
+	2,                          /* WL1271_RATE_5_5  */
+	1,                          /* WL1271_RATE_2    */
+	0                           /* WL1271_RATE_1    */
+};
+
+static void wl1271_rx_status(struct wl1271 *wl,
+			     struct wl1271_rx_descriptor *desc,
+			     struct ieee80211_rx_status *status,
+			     u8 beacon)
+{
+	memset(status, 0, sizeof(struct ieee80211_rx_status));
+
+	if ((desc->flags & WL1271_RX_DESC_BAND_MASK) == WL1271_RX_DESC_BAND_BG)
+		status->band = IEEE80211_BAND_2GHZ;
+	else
+		wl1271_warning("unsupported band 0x%x",
+			       desc->flags & WL1271_RX_DESC_BAND_MASK);
+
+	/*
+	 * FIXME: Add mactime handling.  For IBSS (ad-hoc) we need to get the
+	 * timestamp from the beacon (acx_tsf_info).  In BSS mode (infra) we
+	 * only need the mactime for monitor mode.  For now the mactime is
+	 * not valid, so RX_FLAG_TSFT should not be set
+	 */
+	status->signal = desc->rssi;
+
+	/* FIXME: Should this be optimized? */
+	status->qual = (desc->rssi - WL1271_RX_MIN_RSSI) * 100 /
+		(WL1271_RX_MAX_RSSI - WL1271_RX_MIN_RSSI);
+	status->qual = min(status->qual, 100);
+	status->qual = max(status->qual, 0);
+
+	/*
+	 * FIXME: In wl1251, the SNR should be divided by two.  In wl1271 we
+	 * need to divide by two for now, but TI has been discussing about
+	 * changing it.  This needs to be rechecked.
+	 */
+	status->noise = desc->rssi - (desc->snr >> 1);
+
+	status->freq = ieee80211_channel_to_frequency(desc->channel);
+
+	if (desc->flags & WL1271_RX_DESC_ENCRYPT_MASK) {
+		status->flag |= RX_FLAG_IV_STRIPPED | RX_FLAG_MMIC_STRIPPED;
+
+		if (likely(!(desc->flags & WL1271_RX_DESC_DECRYPT_FAIL)))
+			status->flag |= RX_FLAG_DECRYPTED;
+
+		if (unlikely(desc->flags & WL1271_RX_DESC_MIC_FAIL))
+			status->flag |= RX_FLAG_MMIC_ERROR;
+	}
+
+	status->rate_idx = wl1271_rx_rate_to_idx[desc->rate];
+
+	if (status->rate_idx == WL1271_RX_RATE_UNSUPPORTED)
+		wl1271_warning("unsupported rate");
+}
+
+static void wl1271_rx_handle_data(struct wl1271 *wl, u32 length)
+{
+	struct ieee80211_rx_status rx_status;
+	struct wl1271_rx_descriptor *desc;
+	struct sk_buff *skb;
+	u16 *fc;
+	u8 *buf;
+	u8 beacon = 0;
+
+	skb = dev_alloc_skb(length);
+	if (!skb) {
+		wl1271_error("Couldn't allocate RX frame");
+		return;
+	}
+
+	buf = skb_put(skb, length);
+	wl1271_spi_reg_read(wl, WL1271_SLV_MEM_DATA, buf, length, true);
+
+	/* the data read starts with the descriptor */
+	desc = (struct wl1271_rx_descriptor *) buf;
+
+	/* now we pull the descriptor out of the buffer */
+	skb_pull(skb, sizeof(*desc));
+
+	fc = (u16 *)skb->data;
+	if ((*fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_BEACON)
+		beacon = 1;
+
+	wl1271_rx_status(wl, desc, &rx_status, beacon);
+
+	wl1271_debug(DEBUG_RX, "rx skb 0x%p: %d B %s", skb, skb->len,
+		     beacon ? "beacon" : "");
+
+	ieee80211_rx(wl->hw, skb, &rx_status);
+}
+
+void wl1271_rx(struct wl1271 *wl, struct wl1271_fw_status *status)
+{
+	struct wl1271_acx_mem_map *wl_mem_map = wl->target_mem_map;
+	u32 buf_size;
+	u32 fw_rx_counter  = status->fw_rx_counter & NUM_RX_PKT_DESC_MOD_MASK;
+	u32 drv_rx_counter = wl->rx_counter & NUM_RX_PKT_DESC_MOD_MASK;
+	u32 mem_block;
+
+	while (drv_rx_counter != fw_rx_counter) {
+		mem_block = wl1271_rx_get_mem_block(status, drv_rx_counter);
+		buf_size = wl1271_rx_get_buf_size(status, drv_rx_counter);
+
+		if (buf_size == 0) {
+			wl1271_warning("received empty data");
+			break;
+		}
+
+		wl->rx_mem_pool_addr.addr =
+			(mem_block << 8) + wl_mem_map->packet_memory_pool_start;
+		wl->rx_mem_pool_addr.addr_extra =
+			wl->rx_mem_pool_addr.addr + 4;
+
+		/* Choose the block we want to read */
+		wl1271_spi_reg_write(wl, WL1271_SLV_REG_DATA,
+				     &wl->rx_mem_pool_addr,
+				     sizeof(wl->rx_mem_pool_addr), false);
+
+		wl1271_rx_handle_data(wl, buf_size);
+
+		wl->rx_counter++;
+		drv_rx_counter = wl->rx_counter & NUM_RX_PKT_DESC_MOD_MASK;
+	}
+
+	wl1271_reg_write32(wl, RX_DRIVER_COUNTER_ADDRESS, wl->rx_counter);
+
+	/* This is a workaround for some problems in the chip */
+	wl1271_reg_write32(wl, RX_DRIVER_DUMMY_WRITE_ADDRESS, 0x1);
+
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_rx.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_rx.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_rx.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_rx.h	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,121 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __WL1271_RX_H__
+#define __WL1271_RX_H__
+
+#include <linux/bitops.h>
+
+#define WL1271_RX_MAX_RSSI -30
+#define WL1271_RX_MIN_RSSI -95
+
+#define WL1271_RX_ALIGN_TO 4
+#define WL1271_RX_ALIGN(len) (((len) + WL1271_RX_ALIGN_TO - 1) & \
+			     ~(WL1271_RX_ALIGN_TO - 1))
+
+#define SHORT_PREAMBLE_BIT   BIT(0)
+#define OFDM_RATE_BIT        BIT(6)
+#define PBCC_RATE_BIT        BIT(7)
+
+#define PLCP_HEADER_LENGTH 8
+#define RX_DESC_PACKETID_SHIFT 11
+#define RX_MAX_PACKET_ID 3
+
+#define NUM_RX_PKT_DESC_MOD_MASK   7
+#define WL1271_RX_RATE_UNSUPPORTED 0xFF
+
+#define RX_DESC_VALID_FCS         0x0001
+#define RX_DESC_MATCH_RXADDR1     0x0002
+#define RX_DESC_MCAST             0x0004
+#define RX_DESC_STAINTIM          0x0008
+#define RX_DESC_VIRTUAL_BM        0x0010
+#define RX_DESC_BCAST             0x0020
+#define RX_DESC_MATCH_SSID        0x0040
+#define RX_DESC_MATCH_BSSID       0x0080
+#define RX_DESC_ENCRYPTION_MASK   0x0300
+#define RX_DESC_MEASURMENT        0x0400
+#define RX_DESC_SEQNUM_MASK       0x1800
+#define	RX_DESC_MIC_FAIL	  0x2000
+#define	RX_DESC_DECRYPT_FAIL	  0x4000
+
+/*
+ * RX Descriptor flags:
+ *
+ * Bits 0-1 - band
+ * Bit  2   - STBC
+ * Bit  3   - A-MPDU
+ * Bit  4   - HT
+ * Bits 5-7 - encryption
+ */
+#define WL1271_RX_DESC_BAND_MASK    0x03
+#define WL1271_RX_DESC_ENCRYPT_MASK 0xE0
+
+#define WL1271_RX_DESC_BAND_BG      0x00
+#define WL1271_RX_DESC_BAND_J       0x01
+#define WL1271_RX_DESC_BAND_A       0x02
+
+#define WL1271_RX_DESC_STBC         BIT(2)
+#define WL1271_RX_DESC_A_MPDU       BIT(3)
+#define WL1271_RX_DESC_HT           BIT(4)
+
+#define WL1271_RX_DESC_ENCRYPT_WEP  0x20
+#define WL1271_RX_DESC_ENCRYPT_TKIP 0x40
+#define WL1271_RX_DESC_ENCRYPT_AES  0x60
+#define WL1271_RX_DESC_ENCRYPT_GEM  0x80
+
+/*
+ * RX Descriptor status
+ *
+ * Bits 0-2 - status
+ * Bits 3-7 - reserved
+ */
+#define WL1271_RX_DESC_STATUS_MASK      0x07
+
+#define WL1271_RX_DESC_SUCCESS          0x00
+#define WL1271_RX_DESC_DECRYPT_FAIL     0x01
+#define WL1271_RX_DESC_MIC_FAIL         0x02
+#define WL1271_RX_DESC_DRIVER_RX_Q_FAIL 0x03
+
+#define RX_MEM_BLOCK_MASK     0xFF
+#define RX_BUF_SIZE_MASK      0xFFF00
+#define RX_BUF_SIZE_SHIFT_DIV 6
+
+struct wl1271_rx_descriptor {
+	u16 length;
+	u8  status;
+	u8  flags;
+	u8  rate;
+	u8  channel;
+	s8  rssi;
+	u8  snr;
+	u32 timestamp;
+	u8  packet_class;
+	u8  process_id;
+	u8  pad_len;
+	u8  reserved;
+} __attribute__ ((packed));
+
+void wl1271_rx(struct wl1271 *wl, struct wl1271_fw_status *status);
+
+#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_spi.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_spi.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_spi.c	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,382 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/crc7.h>
+#include <linux/spi/spi.h>
+
+#include "wl1271.h"
+#include "wl12xx_80211.h"
+#include "wl1271_spi.h"
+
+static int wl1271_translate_reg_addr(struct wl1271 *wl, int addr)
+{
+	return addr - wl->physical_reg_addr + wl->virtual_reg_addr;
+}
+
+static int wl1271_translate_mem_addr(struct wl1271 *wl, int addr)
+{
+	return addr - wl->physical_mem_addr + wl->virtual_mem_addr;
+}
+
+
+void wl1271_spi_reset(struct wl1271 *wl)
+{
+	u8 *cmd;
+	struct spi_transfer t;
+	struct spi_message m;
+
+	cmd = kzalloc(WSPI_INIT_CMD_LEN, GFP_KERNEL);
+	if (!cmd) {
+		wl1271_error("could not allocate cmd for spi reset");
+		return;
+	}
+
+	memset(&t, 0, sizeof(t));
+	spi_message_init(&m);
+
+	memset(cmd, 0xff, WSPI_INIT_CMD_LEN);
+
+	t.tx_buf = cmd;
+	t.len = WSPI_INIT_CMD_LEN;
+	spi_message_add_tail(&t, &m);
+
+	spi_sync(wl->spi, &m);
+
+	wl1271_dump(DEBUG_SPI, "spi reset -> ", cmd, WSPI_INIT_CMD_LEN);
+}
+
+void wl1271_spi_init(struct wl1271 *wl)
+{
+	u8 crc[WSPI_INIT_CMD_CRC_LEN], *cmd;
+	struct spi_transfer t;
+	struct spi_message m;
+
+	cmd = kzalloc(WSPI_INIT_CMD_LEN, GFP_KERNEL);
+	if (!cmd) {
+		wl1271_error("could not allocate cmd for spi init");
+		return;
+	}
+
+	memset(crc, 0, sizeof(crc));
+	memset(&t, 0, sizeof(t));
+	spi_message_init(&m);
+
+	/*
+	 * Set WSPI_INIT_COMMAND
+	 * the data is being send from the MSB to LSB
+	 */
+	cmd[2] = 0xff;
+	cmd[3] = 0xff;
+	cmd[1] = WSPI_INIT_CMD_START | WSPI_INIT_CMD_TX;
+	cmd[0] = 0;
+	cmd[7] = 0;
+	cmd[6] |= HW_ACCESS_WSPI_INIT_CMD_MASK << 3;
+	cmd[6] |= HW_ACCESS_WSPI_FIXED_BUSY_LEN & WSPI_INIT_CMD_FIXEDBUSY_LEN;
+
+	if (HW_ACCESS_WSPI_FIXED_BUSY_LEN == 0)
+		cmd[5] |=  WSPI_INIT_CMD_DIS_FIXEDBUSY;
+	else
+		cmd[5] |= WSPI_INIT_CMD_EN_FIXEDBUSY;
+
+	cmd[5] |= WSPI_INIT_CMD_IOD | WSPI_INIT_CMD_IP | WSPI_INIT_CMD_CS
+		| WSPI_INIT_CMD_WSPI | WSPI_INIT_CMD_WS;
+
+	crc[0] = cmd[1];
+	crc[1] = cmd[0];
+	crc[2] = cmd[7];
+	crc[3] = cmd[6];
+	crc[4] = cmd[5];
+
+	cmd[4] |= crc7(0, crc, WSPI_INIT_CMD_CRC_LEN) << 1;
+	cmd[4] |= WSPI_INIT_CMD_END;
+
+	t.tx_buf = cmd;
+	t.len = WSPI_INIT_CMD_LEN;
+	spi_message_add_tail(&t, &m);
+
+	spi_sync(wl->spi, &m);
+
+	wl1271_dump(DEBUG_SPI, "spi init -> ", cmd, WSPI_INIT_CMD_LEN);
+}
+
+/* Set the SPI partitions to access the chip addresses
+ *
+ * There are two VIRTUAL (SPI) partitions (the memory partition and the
+ * registers partition), which are mapped to two different areas of the
+ * PHYSICAL (hardware) memory.  This function also makes other checks to
+ * ensure that the partitions are not overlapping.  In the diagram below, the
+ * memory partition comes before the register partition, but the opposite is
+ * also supported.
+ *
+ *                               PHYSICAL address
+ *                                     space
+ *
+ *                                    |    |
+ *                                 ...+----+--> mem_start
+ *          VIRTUAL address     ...   |    |
+ *               space       ...      |    | [PART_0]
+ *                        ...         |    |
+ * 0x00000000 <--+----+...         ...+----+--> mem_start + mem_size
+ *               |    |         ...   |    |
+ *               |MEM |      ...      |    |
+ *               |    |   ...         |    |
+ *  part_size <--+----+...            |    | {unused area)
+ *               |    |   ...         |    |
+ *               |REG |      ...      |    |
+ *  part_size    |    |         ...   |    |
+ *      +     <--+----+...         ...+----+--> reg_start
+ *  reg_size              ...         |    |
+ *                           ...      |    | [PART_1]
+ *                              ...   |    |
+ *                                 ...+----+--> reg_start + reg_size
+ *                                    |    |
+ *
+ */
+int wl1271_set_partition(struct wl1271 *wl,
+			  u32 mem_start, u32 mem_size,
+			  u32 reg_start, u32 reg_size)
+{
+	struct wl1271_partition *partition;
+	struct spi_transfer t;
+	struct spi_message m;
+	size_t len, cmd_len;
+	u32 *cmd;
+	int addr;
+
+	cmd_len = sizeof(u32) + 2 * sizeof(struct wl1271_partition);
+	cmd = kzalloc(cmd_len, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	spi_message_init(&m);
+	memset(&t, 0, sizeof(t));
+
+	partition = (struct wl1271_partition *) (cmd + 1);
+	addr = HW_ACCESS_PART0_SIZE_ADDR;
+	len = 2 * sizeof(struct wl1271_partition);
+
+	*cmd |= WSPI_CMD_WRITE;
+	*cmd |= (len << WSPI_CMD_BYTE_LENGTH_OFFSET) & WSPI_CMD_BYTE_LENGTH;
+	*cmd |= addr & WSPI_CMD_BYTE_ADDR;
+
+	wl1271_debug(DEBUG_SPI, "mem_start %08X mem_size %08X",
+		     mem_start, mem_size);
+	wl1271_debug(DEBUG_SPI, "reg_start %08X reg_size %08X",
+		     reg_start, reg_size);
+
+	/* Make sure that the two partitions together don't exceed the
+	 * address range */
+	if ((mem_size + reg_size) > HW_ACCESS_MEMORY_MAX_RANGE) {
+		wl1271_debug(DEBUG_SPI, "Total size exceeds maximum virtual"
+			     " address range.  Truncating partition[0].");
+		mem_size = HW_ACCESS_MEMORY_MAX_RANGE - reg_size;
+		wl1271_debug(DEBUG_SPI, "mem_start %08X mem_size %08X",
+			     mem_start, mem_size);
+		wl1271_debug(DEBUG_SPI, "reg_start %08X reg_size %08X",
+			     reg_start, reg_size);
+	}
+
+	if ((mem_start < reg_start) &&
+	    ((mem_start + mem_size) > reg_start)) {
+		/* Guarantee that the memory partition doesn't overlap the
+		 * registers partition */
+		wl1271_debug(DEBUG_SPI, "End of partition[0] is "
+			     "overlapping partition[1].  Adjusted.");
+		mem_size = reg_start - mem_start;
+		wl1271_debug(DEBUG_SPI, "mem_start %08X mem_size %08X",
+			     mem_start, mem_size);
+		wl1271_debug(DEBUG_SPI, "reg_start %08X reg_size %08X",
+			     reg_start, reg_size);
+	} else if ((reg_start < mem_start) &&
+		   ((reg_start + reg_size) > mem_start)) {
+		/* Guarantee that the register partition doesn't overlap the
+		 * memory partition */
+		wl1271_debug(DEBUG_SPI, "End of partition[1] is"
+			     " overlapping partition[0].  Adjusted.");
+		reg_size = mem_start - reg_start;
+		wl1271_debug(DEBUG_SPI, "mem_start %08X mem_size %08X",
+			     mem_start, mem_size);
+		wl1271_debug(DEBUG_SPI, "reg_start %08X reg_size %08X",
+			     reg_start, reg_size);
+	}
+
+	partition[0].start = mem_start;
+	partition[0].size  = mem_size;
+	partition[1].start = reg_start;
+	partition[1].size  = reg_size;
+
+	wl->physical_mem_addr = mem_start;
+	wl->physical_reg_addr = reg_start;
+
+	wl->virtual_mem_addr = 0;
+	wl->virtual_reg_addr = mem_size;
+
+	t.tx_buf = cmd;
+	t.len = cmd_len;
+	spi_message_add_tail(&t, &m);
+
+	spi_sync(wl->spi, &m);
+
+	kfree(cmd);
+
+	return 0;
+}
+
+void wl1271_spi_read(struct wl1271 *wl, int addr, void *buf,
+		     size_t len, bool fixed)
+{
+	struct spi_transfer t[3];
+	struct spi_message m;
+	u8 *busy_buf;
+	u32 *cmd;
+
+	cmd = &wl->buffer_cmd;
+	busy_buf = wl->buffer_busyword;
+
+	*cmd = 0;
+	*cmd |= WSPI_CMD_READ;
+	*cmd |= (len << WSPI_CMD_BYTE_LENGTH_OFFSET) & WSPI_CMD_BYTE_LENGTH;
+	*cmd |= addr & WSPI_CMD_BYTE_ADDR;
+
+	if (fixed)
+		*cmd |= WSPI_CMD_FIXED;
+
+	spi_message_init(&m);
+	memset(t, 0, sizeof(t));
+
+	t[0].tx_buf = cmd;
+	t[0].len = 4;
+	spi_message_add_tail(&t[0], &m);
+
+	/* Busy and non busy words read */
+	t[1].rx_buf = busy_buf;
+	t[1].len = WL1271_BUSY_WORD_LEN;
+	spi_message_add_tail(&t[1], &m);
+
+	t[2].rx_buf = buf;
+	t[2].len = len;
+	spi_message_add_tail(&t[2], &m);
+
+	spi_sync(wl->spi, &m);
+
+	/* FIXME: check busy words */
+
+	wl1271_dump(DEBUG_SPI, "spi_read cmd -> ", cmd, sizeof(*cmd));
+	wl1271_dump(DEBUG_SPI, "spi_read buf <- ", buf, len);
+}
+
+void wl1271_spi_write(struct wl1271 *wl, int addr, void *buf,
+		      size_t len, bool fixed)
+{
+	struct spi_transfer t[2];
+	struct spi_message m;
+	u32 *cmd;
+
+	cmd = &wl->buffer_cmd;
+
+	*cmd = 0;
+	*cmd |= WSPI_CMD_WRITE;
+	*cmd |= (len << WSPI_CMD_BYTE_LENGTH_OFFSET) & WSPI_CMD_BYTE_LENGTH;
+	*cmd |= addr & WSPI_CMD_BYTE_ADDR;
+
+	if (fixed)
+		*cmd |= WSPI_CMD_FIXED;
+
+	spi_message_init(&m);
+	memset(t, 0, sizeof(t));
+
+	t[0].tx_buf = cmd;
+	t[0].len = sizeof(*cmd);
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].tx_buf = buf;
+	t[1].len = len;
+	spi_message_add_tail(&t[1], &m);
+
+	spi_sync(wl->spi, &m);
+
+	wl1271_dump(DEBUG_SPI, "spi_write cmd -> ", cmd, sizeof(*cmd));
+	wl1271_dump(DEBUG_SPI, "spi_write buf -> ", buf, len);
+}
+
+void wl1271_spi_mem_read(struct wl1271 *wl, int addr, void *buf,
+			 size_t len)
+{
+	int physical;
+
+	physical = wl1271_translate_mem_addr(wl, addr);
+
+	wl1271_spi_read(wl, physical, buf, len, false);
+}
+
+void wl1271_spi_mem_write(struct wl1271 *wl, int addr, void *buf,
+			  size_t len)
+{
+	int physical;
+
+	physical = wl1271_translate_mem_addr(wl, addr);
+
+	wl1271_spi_write(wl, physical, buf, len, false);
+}
+
+void wl1271_spi_reg_read(struct wl1271 *wl, int addr, void *buf, size_t len,
+			 bool fixed)
+{
+	int physical;
+
+	physical = wl1271_translate_reg_addr(wl, addr);
+
+	wl1271_spi_read(wl, physical, buf, len, fixed);
+}
+
+void wl1271_spi_reg_write(struct wl1271 *wl, int addr, void *buf, size_t len,
+			  bool fixed)
+{
+	int physical;
+
+	physical = wl1271_translate_reg_addr(wl, addr);
+
+	wl1271_spi_write(wl, physical, buf, len, fixed);
+}
+
+u32 wl1271_mem_read32(struct wl1271 *wl, int addr)
+{
+	return wl1271_read32(wl, wl1271_translate_mem_addr(wl, addr));
+}
+
+void wl1271_mem_write32(struct wl1271 *wl, int addr, u32 val)
+{
+	wl1271_write32(wl, wl1271_translate_mem_addr(wl, addr), val);
+}
+
+u32 wl1271_reg_read32(struct wl1271 *wl, int addr)
+{
+	return wl1271_read32(wl, wl1271_translate_reg_addr(wl, addr));
+}
+
+void wl1271_reg_write32(struct wl1271 *wl, int addr, u32 val)
+{
+	wl1271_write32(wl, wl1271_translate_reg_addr(wl, addr), val);
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_spi.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_spi.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_spi.h	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,113 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (c) 1998-2007 Texas Instruments Incorporated
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __WL1271_SPI_H__
+#define __WL1271_SPI_H__
+
+#include "wl1271_reg.h"
+
+#define HW_ACCESS_MEMORY_MAX_RANGE		0x1FFC0
+
+#define HW_ACCESS_PART0_SIZE_ADDR           0x1FFC0
+#define HW_ACCESS_PART0_START_ADDR          0x1FFC4
+#define HW_ACCESS_PART1_SIZE_ADDR           0x1FFC8
+#define HW_ACCESS_PART1_START_ADDR          0x1FFCC
+
+#define HW_ACCESS_REGISTER_SIZE             4
+
+#define HW_ACCESS_PRAM_MAX_RANGE		0x3c000
+
+#define WSPI_CMD_READ                 0x40000000
+#define WSPI_CMD_WRITE                0x00000000
+#define WSPI_CMD_FIXED                0x20000000
+#define WSPI_CMD_BYTE_LENGTH          0x1FFE0000
+#define WSPI_CMD_BYTE_LENGTH_OFFSET   17
+#define WSPI_CMD_BYTE_ADDR            0x0001FFFF
+
+#define WSPI_INIT_CMD_CRC_LEN       5
+
+#define WSPI_INIT_CMD_START         0x00
+#define WSPI_INIT_CMD_TX            0x40
+/* the extra bypass bit is sampled by the TNET as '1' */
+#define WSPI_INIT_CMD_BYPASS_BIT    0x80
+#define WSPI_INIT_CMD_FIXEDBUSY_LEN 0x07
+#define WSPI_INIT_CMD_EN_FIXEDBUSY  0x80
+#define WSPI_INIT_CMD_DIS_FIXEDBUSY 0x00
+#define WSPI_INIT_CMD_IOD           0x40
+#define WSPI_INIT_CMD_IP            0x20
+#define WSPI_INIT_CMD_CS            0x10
+#define WSPI_INIT_CMD_WS            0x08
+#define WSPI_INIT_CMD_WSPI          0x01
+#define WSPI_INIT_CMD_END           0x01
+
+#define WSPI_INIT_CMD_LEN           8
+
+#define HW_ACCESS_WSPI_FIXED_BUSY_LEN \
+		((WL1271_BUSY_WORD_LEN - 4) / sizeof(u32))
+#define HW_ACCESS_WSPI_INIT_CMD_MASK  0
+
+
+/* Raw target IO, address is not translated */
+void wl1271_spi_write(struct wl1271 *wl, int addr, void *buf,
+		      size_t len, bool fixed);
+void wl1271_spi_read(struct wl1271 *wl, int addr, void *buf,
+		     size_t len, bool fixed);
+
+/* Memory target IO, address is tranlated to partition 0 */
+void wl1271_spi_mem_read(struct wl1271 *wl, int addr, void *buf, size_t len);
+void wl1271_spi_mem_write(struct wl1271 *wl, int addr, void *buf, size_t len);
+u32 wl1271_mem_read32(struct wl1271 *wl, int addr);
+void wl1271_mem_write32(struct wl1271 *wl, int addr, u32 val);
+
+/* Registers IO */
+void wl1271_spi_reg_read(struct wl1271 *wl, int addr, void *buf, size_t len,
+			 bool fixed);
+void wl1271_spi_reg_write(struct wl1271 *wl, int addr, void *buf, size_t len,
+			  bool fixed);
+u32 wl1271_reg_read32(struct wl1271 *wl, int addr);
+void wl1271_reg_write32(struct wl1271 *wl, int addr, u32 val);
+
+/* INIT and RESET words */
+void wl1271_spi_reset(struct wl1271 *wl);
+void wl1271_spi_init(struct wl1271 *wl);
+int wl1271_set_partition(struct wl1271 *wl,
+			 u32 part_start, u32 part_size,
+			 u32 reg_start,  u32 reg_size);
+
+static inline u32 wl1271_read32(struct wl1271 *wl, int addr)
+{
+	wl1271_spi_read(wl, addr, &wl->buffer_32,
+			sizeof(wl->buffer_32), false);
+
+	return wl->buffer_32;
+}
+
+static inline void wl1271_write32(struct wl1271 *wl, int addr, u32 val)
+{
+	wl->buffer_32 = val;
+	wl1271_spi_write(wl, addr, &wl->buffer_32,
+			 sizeof(wl->buffer_32), false);
+}
+
+#endif /* __WL1271_SPI_H__ */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_tx.c kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_tx.c
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_tx.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_tx.c	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,376 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include "wl1271.h"
+#include "wl1271_spi.h"
+#include "wl1271_reg.h"
+#include "wl1271_ps.h"
+#include "wl1271_tx.h"
+
+static int wl1271_tx_id(struct wl1271 *wl, struct sk_buff *skb)
+{
+	int i;
+
+	for (i = 0; i < FW_TX_CMPLT_BLOCK_SIZE; i++)
+		if (wl->tx_frames[i] == NULL) {
+			wl->tx_frames[i] = skb;
+			return i;
+		}
+
+	return -EBUSY;
+}
+
+static int wl1271_tx_allocate(struct wl1271 *wl, struct sk_buff *skb, u32 extra)
+{
+	struct wl1271_tx_hw_descr *desc;
+	u32 total_len = skb->len + sizeof(struct wl1271_tx_hw_descr) + extra;
+	u32 total_blocks, excluded;
+	int id, ret = -EBUSY;
+
+	/* allocate free identifier for the packet */
+	id = wl1271_tx_id(wl, skb);
+	if (id < 0)
+		return id;
+
+	/* approximate the number of blocks required for this packet
+	   in the firmware */
+	/* FIXME: try to figure out what is done here and make it cleaner */
+	total_blocks = (skb->len) >> TX_HW_BLOCK_SHIFT_DIV;
+	excluded = (total_blocks << 2) + (skb->len & 0xff) + 34;
+	total_blocks += (excluded > 252) ? 2 : 1;
+	total_blocks += TX_HW_BLOCK_SPARE;
+
+	if (total_blocks <= wl->tx_blocks_available) {
+		desc = (struct wl1271_tx_hw_descr *)skb_push(
+			skb, total_len - skb->len);
+
+		desc->extra_mem_blocks = TX_HW_BLOCK_SPARE;
+		desc->total_mem_blocks = total_blocks;
+		desc->id = id;
+
+		wl->tx_blocks_available -= total_blocks;
+
+		ret = 0;
+
+		wl1271_debug(DEBUG_TX,
+			     "tx_allocate: size: %d, blocks: %d, id: %d",
+			     total_len, total_blocks, id);
+	} else
+		wl->tx_frames[id] = NULL;
+
+	return ret;
+}
+
+static int wl1271_tx_fill_hdr(struct wl1271 *wl, struct sk_buff *skb,
+			      u32 extra, struct ieee80211_tx_info *control)
+{
+	struct wl1271_tx_hw_descr *desc;
+	int pad;
+
+	desc = (struct wl1271_tx_hw_descr *) skb->data;
+
+	/* configure packet life time */
+	desc->start_time = jiffies_to_usecs(jiffies) - wl->time_offset;
+	desc->life_time = TX_HW_MGMT_PKT_LIFETIME_TU;
+
+	/* configure the tx attributes */
+	desc->tx_attr = wl->session_counter << TX_HW_ATTR_OFST_SESSION_COUNTER;
+	/* FIXME: do we know the packet priority? can we identify mgmt
+	   packets, and use max prio for them at least? */
+	desc->tid = 0;
+	desc->aid = TX_HW_DEFAULT_AID;
+	desc->reserved = 0;
+
+	/* align the length (and store in terms of words) */
+	pad = WL1271_TX_ALIGN(skb->len);
+	desc->length = pad >> 2;
+
+	/* calculate number of padding bytes */
+	pad = pad - skb->len;
+	desc->tx_attr |= pad << TX_HW_ATTR_OFST_LAST_WORD_PAD;
+
+	wl1271_debug(DEBUG_TX, "tx_fill_hdr: pad: %d", pad);
+	return 0;
+}
+
+static int wl1271_tx_send_packet(struct wl1271 *wl, struct sk_buff *skb,
+				 struct ieee80211_tx_info *control)
+{
+
+	struct wl1271_tx_hw_descr *desc;
+	int len;
+
+	/* FIXME: This is a workaround for getting non-aligned packets.
+	   This happens at least with EAPOL packets from the user space.
+	   Our DMA requires packets to be aligned on a 4-byte boundary.
+	*/
+	if (unlikely((long)skb->data & 0x03)) {
+		int offset = (4 - (long)skb->data) & 0x03;
+		wl1271_debug(DEBUG_TX, "skb offset %d", offset);
+
+		/* check whether the current skb can be used */
+		if (!skb_cloned(skb) && (skb_tailroom(skb) >= offset)) {
+			unsigned char *src = skb->data;
+
+			/* align the buffer on a 4-byte boundary */
+			skb_reserve(skb, offset);
+			memmove(skb->data, src, skb->len);
+		} else {
+			wl1271_info("No handler, fixme!");
+			return -EINVAL;
+		}
+	}
+
+	len = WL1271_TX_ALIGN(skb->len);
+
+	/* perform a fixed address block write with the packet */
+	wl1271_spi_reg_write(wl, WL1271_SLV_MEM_DATA, skb->data, len, true);
+
+	/* write packet new counter into the write access register */
+	wl->tx_packets_count++;
+	wl1271_reg_write32(wl, WL1271_HOST_WR_ACCESS, wl->tx_packets_count);
+
+	desc = (struct wl1271_tx_hw_descr *) skb->data;
+	wl1271_debug(DEBUG_TX, "tx id %u skb 0x%p payload %u (%u words)",
+		     desc->id, skb, len, desc->length);
+
+	return 0;
+}
+
+/* caller must hold wl->mutex */
+static int wl1271_tx_frame(struct wl1271 *wl, struct sk_buff *skb)
+{
+	struct ieee80211_tx_info *info;
+	u32 extra = 0;
+	int ret = 0;
+	u8 idx;
+
+	if (!skb)
+		return -EINVAL;
+
+	info = IEEE80211_SKB_CB(skb);
+
+	if (info->control.hw_key &&
+	    info->control.hw_key->alg == ALG_TKIP)
+		extra = WL1271_TKIP_IV_SPACE;
+
+	if (info->control.hw_key) {
+		idx = info->control.hw_key->hw_key_idx;
+
+		/* FIXME: do we have to do this if we're not using WEP? */
+		if (unlikely(wl->default_key != idx)) {
+			ret = wl1271_cmd_set_default_wep_key(wl, idx);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	ret = wl1271_tx_allocate(wl, skb, extra);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_tx_fill_hdr(wl, skb, extra, info);
+	if (ret < 0)
+		return ret;
+
+	ret = wl1271_tx_send_packet(wl, skb, info);
+	if (ret < 0)
+		return ret;
+
+	return ret;
+}
+
+void wl1271_tx_work(struct work_struct *work)
+{
+	struct wl1271 *wl = container_of(work, struct wl1271, tx_work);
+	struct sk_buff *skb;
+	bool woken_up = false;
+	int ret;
+
+	mutex_lock(&wl->mutex);
+
+	if (unlikely(wl->state == WL1271_STATE_OFF))
+		goto out;
+
+	while ((skb = skb_dequeue(&wl->tx_queue))) {
+		if (!woken_up) {
+			ret = wl1271_ps_elp_wakeup(wl, false);
+			if (ret < 0)
+				goto out;
+			woken_up = true;
+		}
+
+		ret = wl1271_tx_frame(wl, skb);
+		if (ret == -EBUSY) {
+			/* firmware buffer is full, stop queues */
+			wl1271_debug(DEBUG_TX, "tx_work: fw buffer full, "
+				     "stop queues");
+			ieee80211_stop_queues(wl->hw);
+			wl->tx_queue_stopped = true;
+			skb_queue_head(&wl->tx_queue, skb);
+			goto out;
+		} else if (ret < 0) {
+			dev_kfree_skb(skb);
+			goto out;
+		} else if (wl->tx_queue_stopped) {
+			/* firmware buffer has space, restart queues */
+			wl1271_debug(DEBUG_TX,
+				     "complete_packet: waking queues");
+			ieee80211_wake_queues(wl->hw);
+			wl->tx_queue_stopped = false;
+		}
+	}
+
+out:
+	if (woken_up)
+		wl1271_ps_elp_sleep(wl);
+
+	mutex_unlock(&wl->mutex);
+}
+
+static void wl1271_tx_complete_packet(struct wl1271 *wl,
+				      struct wl1271_tx_hw_res_descr *result)
+{
+
+	struct ieee80211_tx_info *info;
+	struct sk_buff *skb;
+	u32 header_len;
+	int id = result->id;
+
+	/* check for id legality */
+	if (id >= TX_HW_RESULT_QUEUE_LEN || wl->tx_frames[id] == NULL) {
+		wl1271_warning("TX result illegal id: %d", id);
+		return;
+	}
+
+	skb = wl->tx_frames[id];
+	info = IEEE80211_SKB_CB(skb);
+
+	/* update packet status */
+	if (!(info->flags & IEEE80211_TX_CTL_NO_ACK)) {
+		if (result->status == TX_SUCCESS)
+			info->flags |= IEEE80211_TX_STAT_ACK;
+		if (result->status & TX_RETRY_EXCEEDED) {
+			info->status.excessive_retries = 1;
+			wl->stats.excessive_retries++;
+		}
+	}
+
+	info->status.retry_count = result->ack_failures;
+	wl->stats.retry_count += result->ack_failures;
+
+	/* get header len */
+	if (info->control.hw_key &&
+	    info->control.hw_key->alg == ALG_TKIP)
+		header_len = WL1271_TKIP_IV_SPACE +
+			sizeof(struct wl1271_tx_hw_descr);
+	else
+		header_len = sizeof(struct wl1271_tx_hw_descr);
+
+	wl1271_debug(DEBUG_TX, "tx status id %u skb 0x%p failures %u rate 0x%x"
+		     " status 0x%x",
+		     result->id, skb, result->ack_failures,
+		     result->rate_class_index, result->status);
+
+	/* remove private header from packet */
+	skb_pull(skb, header_len);
+
+	/* return the packet to the stack */
+	ieee80211_tx_status(wl->hw, skb);
+	wl->tx_frames[result->id] = NULL;
+}
+
+/* Called upon reception of a TX complete interrupt */
+void wl1271_tx_complete(struct wl1271 *wl, u32 count)
+{
+	struct wl1271_acx_mem_map *memmap =
+		(struct wl1271_acx_mem_map *)wl->target_mem_map;
+	u32 i;
+
+	wl1271_debug(DEBUG_TX, "tx_complete received, packets: %d", count);
+
+	/* read the tx results from the chipset */
+	wl1271_spi_mem_read(wl, memmap->tx_result,
+			    wl->tx_res_if, sizeof(*wl->tx_res_if));
+
+	/* verify that the result buffer is not getting overrun */
+	if (count > TX_HW_RESULT_QUEUE_LEN) {
+		wl1271_warning("TX result overflow from chipset: %d", count);
+		count = TX_HW_RESULT_QUEUE_LEN;
+	}
+
+	/* process the results */
+	for (i = 0; i < count; i++) {
+		struct wl1271_tx_hw_res_descr *result;
+		u8 offset = wl->tx_results_count & TX_HW_RESULT_QUEUE_LEN_MASK;
+
+		/* process the packet */
+		result =  &(wl->tx_res_if->tx_results_queue[offset]);
+		wl1271_tx_complete_packet(wl, result);
+
+		wl->tx_results_count++;
+	}
+
+	/* write host counter to chipset (to ack) */
+	wl1271_mem_write32(wl, memmap->tx_result +
+			   offsetof(struct wl1271_tx_hw_res_if,
+				    tx_result_host_counter),
+			   wl->tx_res_if->tx_result_fw_counter);
+}
+
+/* caller must hold wl->mutex */
+void wl1271_tx_flush(struct wl1271 *wl)
+{
+	int i;
+	struct sk_buff *skb;
+	struct ieee80211_tx_info *info;
+
+	/* TX failure */
+/* 	control->flags = 0; FIXME */
+
+	while ((skb = skb_dequeue(&wl->tx_queue))) {
+		info = IEEE80211_SKB_CB(skb);
+
+		wl1271_debug(DEBUG_TX, "flushing skb 0x%p", skb);
+
+		if (!(info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS))
+				continue;
+
+		ieee80211_tx_status(wl->hw, skb);
+	}
+
+	for (i = 0; i < FW_TX_CMPLT_BLOCK_SIZE; i++)
+		if (wl->tx_frames[i] != NULL) {
+			skb = wl->tx_frames[i];
+			info = IEEE80211_SKB_CB(skb);
+
+			if (!(info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS))
+				continue;
+
+			ieee80211_tx_status(wl->hw, skb);
+			wl->tx_frames[i] = NULL;
+		}
+}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_tx.h kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_tx.h
--- kernel-2.6.28-20091602+0m5/drivers/net/wireless/wl12xx/wl1271_tx.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/net/wireless/wl12xx/wl1271_tx.h	2012-12-16 13:13:01.688330145 +0100
@@ -0,0 +1,129 @@
+/*
+ * This file is part of wl1271
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Kalle Valo <kalle.valo@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __WL1271_TX_H__
+#define __WL1271_TX_H__
+
+#define TX_HW_BLOCK_SPARE                2
+#define TX_HW_BLOCK_SHIFT_DIV            8
+
+#define TX_HW_MGMT_PKT_LIFETIME_TU       2000
+/* The chipset reference driver states, that the "aid" value 1
+ * is for infra-BSS, but is still always used */
+#define TX_HW_DEFAULT_AID                1
+
+#define TX_HW_ATTR_SAVE_RETRIES          BIT(0)
+#define TX_HW_ATTR_HEADER_PAD            BIT(1)
+#define TX_HW_ATTR_SESSION_COUNTER       (BIT(2) | BIT(3) | BIT(4))
+#define TX_HW_ATTR_RATE_POLICY           (BIT(5) | BIT(6) | BIT(7) | \
+					  BIT(8) | BIT(9))
+#define TX_HW_ATTR_LAST_WORD_PAD         (BIT(10) | BIT(11))
+#define TX_HW_ATTR_TX_CMPLT_REQ          BIT(12)
+
+#define TX_HW_ATTR_OFST_SAVE_RETRIES     0
+#define TX_HW_ATTR_OFST_HEADER_PAD       1
+#define TX_HW_ATTR_OFST_SESSION_COUNTER  2
+#define TX_HW_ATTR_OFST_RATE_POLICY      5
+#define TX_HW_ATTR_OFST_LAST_WORD_PAD    10
+#define TX_HW_ATTR_OFST_TX_CMPLT_REQ     12
+
+#define TX_HW_RESULT_QUEUE_LEN           16
+#define TX_HW_RESULT_QUEUE_LEN_MASK      0xf
+
+#define WL1271_TX_ALIGN_TO 4
+#define WL1271_TX_ALIGN(len) (((len) + WL1271_TX_ALIGN_TO - 1) & \
+			     ~(WL1271_TX_ALIGN_TO - 1))
+#define WL1271_TKIP_IV_SPACE 4
+
+struct wl1271_tx_hw_descr {
+	/* Length of packet in words, including descriptor+header+data */
+	u16 length;
+	/* Number of extra memory blocks to allocate for this packet in
+	   addition to the number of blocks derived from the packet length */
+	u8 extra_mem_blocks;
+	/* Total number of memory blocks allocated by the host for this packet.
+	   Must be equal or greater than the actual blocks number allocated by
+	   HW!! */
+	u8 total_mem_blocks;
+	/* Device time (in us) when the packet arrived to the driver */
+	u32 start_time;
+	/* Max delay in TUs until transmission. The last device time the
+	   packet can be transmitted is: startTime+(1024*LifeTime) */
+	u16 life_time;
+	/* Bitwise fields - see TX_ATTR... definitions above. */
+	u16 tx_attr;
+	/* Packet identifier used also in the Tx-Result. */
+	u8 id;
+	/* The packet TID value (as User-Priority) */
+	u8 tid;
+	/* Identifier of the remote STA in IBSS, 1 in infra-BSS */
+	u8 aid;
+	u8 reserved;
+} __attribute__ ((packed));
+
+enum wl1271_tx_hw_res_status {
+	TX_SUCCESS          = 0,
+	TX_HW_ERROR         = 1,
+	TX_DISABLED         = 2,
+	TX_RETRY_EXCEEDED   = 3,
+	TX_TIMEOUT          = 4,
+	TX_KEY_NOT_FOUND    = 5,
+	TX_PEER_NOT_FOUND   = 6,
+	TX_SESSION_MISMATCH = 7
+};
+
+struct wl1271_tx_hw_res_descr {
+	/* Packet Identifier - same value used in the Tx descriptor.*/
+	u8 id;
+	/* The status of the transmission, indicating success or one of
+	   several possible reasons for failure. */
+	u8 status;
+	/* Total air access duration including all retrys and overheads.*/
+	u16 medium_usage;
+	/* The time passed from host xfer to Tx-complete.*/
+	u32 fw_handling_time;
+	/* Total media delay
+	   (from 1st EDCA AIFS counter until TX Complete). */
+	u32 medium_delay;
+	/* LS-byte of last TKIP seq-num (saved per AC for recovery). */
+	u8 lsb_security_sequence_number;
+	/* Retry count - number of transmissions without successful ACK.*/
+	u8 ack_failures;
+	/* The rate that succeeded getting ACK
+	   (Valid only if status=SUCCESS). */
+	u8 rate_class_index;
+	/* for 4-byte alignment. */
+	u8 spare;
+} __attribute__ ((packed));
+
+struct wl1271_tx_hw_res_if {
+	u32 tx_result_fw_counter;
+	u32 tx_result_host_counter;
+	struct wl1271_tx_hw_res_descr tx_results_queue[TX_HW_RESULT_QUEUE_LEN];
+} __attribute__ ((packed));
+
+void wl1271_tx_work(struct work_struct *work);
+void wl1271_tx_complete(struct wl1271 *wl, u32 count);
+void wl1271_tx_flush(struct wl1271 *wl);
+
+#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/regulator/twl4030-regulator.c kernel-2.6.28-20093908+0m5/drivers/regulator/twl4030-regulator.c
--- kernel-2.6.28-20091602+0m5/drivers/regulator/twl4030-regulator.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/regulator/twl4030-regulator.c	2012-12-16 13:13:01.688330145 +0100
@@ -16,6 +16,7 @@
 #include <linux/regulator/driver.h>
 #include <linux/regulator/machine.h>
 #include <linux/i2c/twl4030.h>
+#include <linux/delay.h>
 
 
 /*
@@ -81,6 +82,69 @@ twl4030reg_write(struct twlreg_info *inf
 			value, info->base + offset);
 }
 
+static int twl4030_wait_pb_ready(void)
+{
+
+	u8 pb_status;
+	int status, timeout = 10;
+
+	do {
+		status = twl4030_i2c_read_u8(TWL4030_MODULE_PM_MASTER,
+						&pb_status, 0x14);
+		if (status < 0)
+			return status;
+
+		if (!(pb_status & 1))
+			return 0;
+
+		mdelay(1);
+		timeout--;
+
+	} while (timeout);
+
+	return -ETIMEDOUT;
+}
+
+static int twl4030_send_pb_msg(unsigned msg)
+{
+
+	u8 pb_state;
+	int status;
+
+	/* save powerbus configuration */
+	status = twl4030_i2c_read_u8(TWL4030_MODULE_PM_MASTER,
+					&pb_state, 0x14);
+	if (status < 0)
+		return status;
+
+	/* Enable I2C access to powerbus */
+	status = twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER,
+					pb_state | (1<<1), 0x14);
+	if (status < 0)
+		return status;
+
+	status = twl4030_wait_pb_ready();
+	if (status < 0)
+		return status;
+
+	status = twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER, msg >> 8,
+			0x15 /* PB_WORD_MSB */);
+	if (status < 0)
+		return status;
+
+	status = twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER, msg & 0xff,
+			0x16 /* PB_WORD_LSB */);
+	if (status < 0)
+		return status;
+
+	status = twl4030_wait_pb_ready();
+	if (status < 0)
+		return status;
+
+	/* Restore powerbus configuration */
+	return twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER, pb_state, 0x14);
+}
+
 /*----------------------------------------------------------------------*/
 
 /* generic power resource operations, which work on all regulators */
@@ -113,14 +177,21 @@ static int twl4030reg_is_enabled(struct
 static int twl4030reg_enable(struct regulator_dev *rdev)
 {
 	struct twlreg_info	*info = rdev_get_drvdata(rdev);
-	int			grp;
+	int			grp, status;
+	unsigned 		message;
 
 	grp = twl4030reg_read(info, VREG_GRP);
 	if (grp < 0)
 		return grp;
 
 	grp |= P1_GRP;
-	return twl4030reg_write(info, VREG_GRP, grp);
+	status =  twl4030reg_write(info, VREG_GRP, grp);
+	if (status < 0)
+		return status;
+
+	message = MSG_SINGULAR(DEV_GRP_P1, info->id, RES_STATE_ACTIVE);
+
+	return twl4030_send_pb_msg(message);
 }
 
 static int twl4030reg_disable(struct regulator_dev *rdev)
@@ -177,13 +248,7 @@ static int twl4030reg_set_mode(struct re
 	if (!(status & (P3_GRP | P2_GRP | P1_GRP)))
 		return -EACCES;
 
-	status = twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER,
-			message >> 8, 0x15 /* PB_WORD_MSB */ );
-	if (status >= 0)
-		return status;
-
-	return twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER,
-			message, 0x16 /* PB_WORD_LSB */ );
+	return twl4030_send_pb_msg(message);
 }
 
 /*----------------------------------------------------------------------*/
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/serial/8250.c kernel-2.6.28-20093908+0m5/drivers/serial/8250.c
--- kernel-2.6.28-20091602+0m5/drivers/serial/8250.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/serial/8250.c	2012-12-16 13:13:01.692330145 +0100
@@ -1456,6 +1456,16 @@ static void serial8250_handle_port(struc
 	if (status & UART_LSR_THRE)
 		transmit_chars(up);
 
+#ifdef CONFIG_ARCH_OMAP
+	/*
+	 * OMAP3 UART has a special RX_FIFO_STATUS bit that will stall
+	 * RX transfer on FIFO overflow until the RX fifo is cleared.
+	 */
+	if (cpu_is_omap34xx() && is_omap_port(up) &&
+					status & UART_LSR_RX_FIFO_STS)
+		serial_outp(up, UART_FCR, uart_config[up->port.type].fcr |
+					UART_FCR_CLEAR_RCVR);
+#endif
 	spin_unlock_irqrestore(&up->port.lock, flags);
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/spi/omap2_mcspi.c kernel-2.6.28-20093908+0m5/drivers/spi/omap2_mcspi.c
--- kernel-2.6.28-20091602+0m5/drivers/spi/omap2_mcspi.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/spi/omap2_mcspi.c	2012-12-16 13:13:01.692330145 +0100
@@ -134,6 +134,7 @@ struct omap2_mcspi_cs {
 	void __iomem		*base;
 	unsigned long		phys;
 	int			word_len;
+	struct list_head	node;
 	/* Context save and restore shadow register */
 	u32			chconf0;
 };
@@ -145,6 +146,7 @@ struct omap2_mcspi_regs {
 	u32 sysconfig;
 	u32 modulctrl;
 	u32 wakeupenable;
+	struct list_head cs;
 };
 
 static struct omap2_mcspi_regs omap2_mcspi_ctx[OMAP2_MCSPI_MAX_CTRL];
@@ -255,6 +257,7 @@ static void omap2_mcspi_set_master_mode(
 static void omap2_mcspi_restore_ctx(struct omap2_mcspi *mcspi)
 {
 	struct spi_master *spi_cntrl;
+	struct omap2_mcspi_cs *cs;
 	spi_cntrl = mcspi->master;
 
 	/* McSPI: context restore */
@@ -266,6 +269,10 @@ static void omap2_mcspi_restore_ctx(stru
 
 	mcspi_write_reg(spi_cntrl, OMAP2_MCSPI_WAKEUPENABLE,
 			omap2_mcspi_ctx[spi_cntrl->bus_num - 1].wakeupenable);
+
+	list_for_each_entry(cs, &omap2_mcspi_ctx[spi_cntrl->bus_num - 1].cs,
+			node)
+		__raw_writel(cs->chconf0, cs->base + OMAP2_MCSPI_CHCONF0);
 }
 static void omap2_mcspi_disable_clocks(struct omap2_mcspi *mcspi)
 {
@@ -706,6 +713,9 @@ static int omap2_mcspi_setup(struct spi_
 		cs->phys = mcspi->phys + spi->chip_select * 0x14;
 		cs->chconf0 = 0;
 		spi->controller_state = cs;
+		/* Link this to context save list */
+		list_add_tail(&cs->node,
+			&omap2_mcspi_ctx[mcspi->master->bus_num - 1].cs);
 	}
 
 	if (mcspi_dma->dma_rx_channel == -1
@@ -728,10 +738,15 @@ static void omap2_mcspi_cleanup(struct s
 {
 	struct omap2_mcspi	*mcspi;
 	struct omap2_mcspi_dma	*mcspi_dma;
+	struct omap2_mcspi_cs	*cs;
 
 	mcspi = spi_master_get_devdata(spi->master);
 	mcspi_dma = &mcspi->dma_channels[spi->chip_select];
 
+	/* Unlink controller state from context save list */
+	cs = spi->controller_state;
+	list_del(&cs->node);
+
 	kfree(spi->controller_state);
 
 	if (mcspi_dma->dma_rx_channel != -1) {
@@ -1093,6 +1108,7 @@ static int __init omap2_mcspi_probe(stru
 
 	spin_lock_init(&mcspi->lock);
 	INIT_LIST_HEAD(&mcspi->msg_queue);
+	INIT_LIST_HEAD(&omap2_mcspi_ctx[master->bus_num - 1].cs);
 
 	mcspi->ick = clk_get(&pdev->dev, "mcspi_ick");
 	if (IS_ERR(mcspi->ick)) {
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/core/Kconfig kernel-2.6.28-20093908+0m5/drivers/usb/core/Kconfig
--- kernel-2.6.28-20091602+0m5/drivers/usb/core/Kconfig	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/core/Kconfig	2012-12-16 13:13:01.692330145 +0100
@@ -103,15 +103,10 @@ config USB_SUSPEND
 	  If you are unsure about this, say N here.
 
 config USB_OTG
-	bool "OTG Support"
+	bool
 	depends on USB
 	select USB_SUSPEND
-	help
-	  The most notable feature of USB OTG is support for a
-	  "Dual-Role" device, which can act as either a device
-	  or a host.  The initial role choice can be changed
-	  later, when two dual-role devices talk to each other.
-
+	default n
 
 config USB_OTG_WHITELIST
 	bool "Rely on OTG Targeted Peripherals List"
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/gadget/composite.c kernel-2.6.28-20093908+0m5/drivers/usb/gadget/composite.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/gadget/composite.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/gadget/composite.c	2012-12-16 13:13:01.692330145 +0100
@@ -24,6 +24,7 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/device.h>
+#include <linux/delay.h>
 
 #include <linux/usb/composite.h>
 
@@ -69,6 +70,41 @@ static char *iSerialNumber;
 module_param(iSerialNumber, charp, 0);
 MODULE_PARM_DESC(iSerialNumber, "SerialNumber string");
 
+/** UGLY UGLY HACK: Windows problems with multiple
+ * configurations.
+ *
+ * Windows can only handle 1 usb configuration at a time.
+ *
+ * In order to work around that issue, we will have a retry
+ * method implemented in such a way that we try one configuration
+ * at a time until one works.
+ *
+ * What we do is that we connect with 500mA configuration, if that
+ * doesn't work, we disconnect from the bus, change to 100mA and try
+ * again, if that still doesn't work, we disconnect and try 8mA,
+ * if that doesn't work we give up.
+ */
+
+/* To determine whether a configuration worked or no, we use a timer.
+ * If the time required to get a SET_CONFIG request exceeds the timeout,
+ * it means the configuration failed. We then use the next config.
+ */
+
+static struct timer_list cdev_set_config_timer;
+
+static void cdev_set_config_timeout(unsigned long _gadget)
+{
+	struct usb_gadget	*gadget = (void *) _gadget;
+
+	/* Configuration failed, so disconnect from bus and use next config */
+	gadget->get_config = 0;
+	usb_gadget_disconnect(gadget);
+	/* sleep to allow host see our disconnect */
+	mdelay(500);
+	gadget->cindex++;
+	usb_gadget_connect(gadget);
+}
+
 /*-------------------------------------------------------------------------*/
 
 /**
@@ -281,12 +317,15 @@ static int config_buf(struct usb_configu
 	return len;
 }
 
+static int count_configs(struct usb_composite_dev *cdev, unsigned type);
+
 static int config_desc(struct usb_composite_dev *cdev, unsigned w_value)
 {
 	struct usb_gadget		*gadget = cdev->gadget;
 	struct usb_configuration	*c;
 	u8				type = w_value >> 8;
 	enum usb_device_speed		speed = USB_SPEED_UNKNOWN;
+	u8				index;
 
 	if (gadget_is_dualspeed(gadget)) {
 		int			hs = 0;
@@ -301,7 +340,27 @@ static int config_desc(struct usb_compos
 	}
 
 	/* This is a lookup by config *INDEX* */
-	w_value &= 0xff;
+	index = w_value & 0xFF;
+	if (!index) {
+		u8	num_configs;
+
+		/** UGLY UGLY HACK: Windows problems with multiple
+		 * configurations.
+		 *
+		 * This is us giving up, if this one doesn't work
+		 * then user will have to take action, we can't
+		 * got any further
+		 */
+		index = gadget->cindex;
+		num_configs = count_configs(cdev, USB_DT_DEVICE);
+		if (index >= num_configs - 1) {
+			del_timer(&cdev_set_config_timer);
+			gadget->set_config = 1;
+			/* Restrict to the last configuration */
+			index = num_configs - 1;
+		}
+	}
+
 	list_for_each_entry(c, &cdev->configs, list) {
 		/* ignore configs that won't work at this speed */
 		if (speed == USB_SPEED_HIGH) {
@@ -311,10 +370,17 @@ static int config_desc(struct usb_compos
 			if (!c->fullspeed)
 				continue;
 		}
-		if (w_value == 0)
+		/** UGLY UGLY HACK: Windows problems with multiple
+		 * configurations.
+		 *
+		 * We need to keep track of which configuration to try this
+		 * time in order to make Windows happy.
+		 */
+		if (index == 0)
 			return config_buf(c, speed, cdev->req->buf, type);
-		w_value--;
+		index--;
 	}
+
 	return -EINVAL;
 }
 
@@ -358,7 +424,7 @@ static void device_qual(struct usb_compo
 	qual->bDeviceProtocol = cdev->desc.bDeviceProtocol;
 	/* ASSUME same EP0 fifo size at both speeds */
 	qual->bMaxPacketSize0 = cdev->desc.bMaxPacketSize0;
-	qual->bNumConfigurations = count_configs(cdev, USB_DT_DEVICE_QUALIFIER);
+	qual->bNumConfigurations = count_configs(cdev, USB_DT_DEVICE);
 	qual->bRESERVED = 0;
 }
 
@@ -708,6 +774,7 @@ composite_setup(struct usb_gadget *gadge
 		case USB_DT_DEVICE:
 			cdev->desc.bNumConfigurations =
 				count_configs(cdev, USB_DT_DEVICE);
+
 			value = min(w_length, (u16) sizeof cdev->desc);
 			memcpy(req->buf, &cdev->desc, value);
 			break;
@@ -726,6 +793,13 @@ composite_setup(struct usb_gadget *gadge
 			value = config_desc(cdev, w_value);
 			if (value >= 0)
 				value = min(w_length, (u16) value);
+			/** UGLY UGLY HACK: Windows problems with multiple
+			 * configurations.
+			 *
+			 * Note that we got a get_config
+			 */
+			gadget->get_config = 1;
+			DBG(cdev, "get_config = 1\n");
 			break;
 		case USB_DT_STRING:
 			value = get_string(cdev, req->buf,
@@ -751,6 +825,15 @@ composite_setup(struct usb_gadget *gadge
 		spin_lock(&cdev->lock);
 		value = set_config(cdev, ctrl, w_value);
 		spin_unlock(&cdev->lock);
+		/** UGLY UGLY HACK: Windows problems with multiple
+		 * configurations.
+		 *
+		 * We got a SetConfiguration, meaning Windows accepted
+		 * our configuration descriptor, so stop the retry
+		 * timer and let device work.
+		 */
+		gadget->set_config = 1;
+		DBG(cdev, "set_config = 1\n");
 		break;
 	case USB_REQ_GET_CONFIGURATION:
 		if (ctrl->bRequestType != USB_DIR_IN)
@@ -843,11 +926,31 @@ done:
 	return value;
 }
 
+/** UGLY UGLY HACK: Windows problems with multiple
+ * configurations.
+ *
+ * This hook was introduced to differentiate between
+ * BUS RESET and DISCONNECT events. All we do here
+ * is delete our retry timer so we don't retry
+ * forever.
+ */
+static void composite_vbus_disconnect(struct usb_gadget *gadget)
+{
+	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+
+	DBG(cdev, "%s\n", __func__);
+	del_timer(&cdev_set_config_timer);
+	gadget->cindex = 0;
+	gadget->set_config = 0;
+	gadget->get_config = 0;
+}
+
 static void composite_disconnect(struct usb_gadget *gadget)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
 	unsigned long			flags;
 
+	DBG(cdev, "%s\n", __func__);
 	/* REVISIT:  should we have config and device level
 	 * disconnect callbacks?
 	 */
@@ -855,6 +958,16 @@ static void composite_disconnect(struct
 	if (cdev->config)
 		reset_config(cdev);
 	spin_unlock_irqrestore(&cdev->lock, flags);
+
+	/** UGLY UGLY HACK: Windows problems with multiple
+	 * configurations.
+	 *
+	 * Port RESET so maintain cindex but reset get_config
+	 * and set_config flags so we can try other configurations
+	 */
+
+	gadget->set_config = 0;
+	gadget->get_config = 0;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -943,6 +1056,9 @@ static int __init composite_bind(struct
 	cdev->gadget = gadget;
 	set_gadget_data(gadget, cdev);
 	INIT_LIST_HEAD(&cdev->configs);
+	cdev->gadget->cindex = 0;
+	cdev->gadget->set_config = 0;
+	cdev->gadget->get_config = 0;
 
 	/* preallocate control response and buffer */
 	cdev->req = usb_ep_alloc_request(gadget->ep0, GFP_KERNEL);
@@ -957,8 +1073,6 @@ static int __init composite_bind(struct
 	cdev->bufsiz = USB_BUFSIZ;
 	cdev->driver = composite;
 
-	usb_gadget_set_selfpowered(gadget);
-
 	/* interface and string IDs start at zero via kzalloc.
 	 * we force endpoints to start unassigned; few controller
 	 * drivers will zero ep->driver_data.
@@ -997,6 +1111,8 @@ static int __init composite_bind(struct
 		string_override(composite->strings,
 			cdev->desc.iSerialNumber, iSerialNumber);
 
+	setup_timer(&cdev_set_config_timer, cdev_set_config_timeout,
+				(unsigned long) gadget);
 	INFO(cdev, "%s ready\n", composite->name);
 	return 0;
 
@@ -1007,6 +1123,11 @@ fail:
 
 /*-------------------------------------------------------------------------*/
 
+/** UGLY UGLY HACK: Windows problems with multiple
+ * configurations.
+ *
+ * we use suspend to try another configuration
+ */
 static void
 composite_suspend(struct usb_gadget *gadget)
 {
@@ -1023,6 +1144,17 @@ composite_suspend(struct usb_gadget *gad
 				f->suspend(f);
 		}
 	}
+
+	/** UGLY UGLY HACK: Windows problems with multiple
+	 * configurations.
+	 *
+	 * we try another configuration if we have received
+	 * a get_config but not a set_config
+	 */
+	if (gadget->get_config && !gadget->set_config) {
+		mod_timer(&cdev_set_config_timer,
+				jiffies + msecs_to_jiffies(10));
+	}
 }
 
 static void
@@ -1053,6 +1185,7 @@ static struct usb_gadget_driver composit
 
 	.setup		= composite_setup,
 	.disconnect	= composite_disconnect,
+	.vbus_disconnect = composite_vbus_disconnect,
 
 	.suspend	= composite_suspend,
 	.resume		= composite_resume,
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/gadget/f_acm.c kernel-2.6.28-20093908+0m5/drivers/usb/gadget/f_acm.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/gadget/f_acm.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/gadget/f_acm.c	2012-12-16 13:13:01.692330145 +0100
@@ -340,10 +340,13 @@ static int acm_setup(struct usb_function
 
 		value = 0;
 
-		/* FIXME we should not allow data to flow until the
-		 * host sets the ACM_CTRL_DTR bit; and when it clears
-		 * that bit, we should return to that no-flow state.
+		/* REVISIT Hangup would be the right way, but since the hooks
+		 * are not there we need to connect/disconnect.
 		 */
+		if (w_value & ACM_CTRL_DTR)
+			gserial_connect(&acm->port, acm->port_num);
+		else
+			gserial_disconnect(&acm->port);
 		acm->port_handshake_bits = w_value;
 		break;
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/gadget/file_storage.c kernel-2.6.28-20093908+0m5/drivers/usb/gadget/file_storage.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/gadget/file_storage.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/gadget/file_storage.c	2012-12-16 13:13:01.692330145 +0100
@@ -87,6 +87,8 @@
  *	removable		Default false, boolean for removable media
  *	luns=N			Default N = number of filenames, number of
  *					LUNs to support
+ *	fua=N			Default N = 0, boolean for ignoring FUA flag
+ *					in SCSI WRITE(10,12) commands
  *	stall			Default determined according to the type of
  *					USB device controller (usually true),
  *					boolean to permit the driver to halt
@@ -103,14 +105,14 @@
  *					PAGE_CACHE_SIZE)
  *
  * If CONFIG_USB_FILE_STORAGE_TEST is not set, only the "file", "ro",
- * "removable", "luns", and "stall" options are available; default values
- * are used for everything else.
+ * "removable", "luns", "fua" and "stall" options are available; default
+ * values are used for everything else.
  *
  * The pathnames of the backing files and the ro settings are available in
- * the attribute files "file" and "ro" in the lun<n> subdirectory of the
- * gadget's sysfs directory.  If the "removable" option is set, writing to
- * these files will simulate ejecting/loading the medium (writing an empty
- * line means eject) and adjusting a write-enable tab.  Changes to the ro
+ * the attribute files "file", "ro" and "fua" in the lun<n> subdirectory of
+ * the gadget's sysfs directory.  If the "removable" option is set, writing
+ * to "file" will simulate ejecting/loading the medium (writing an empty
+ * line means eject) and adjusting a write-enable tab.  Changes to the "ro"
  * setting are not allowed when the medium is loaded.
  *
  * This gadget driver is heavily based on "Gadget Zero" by David Brownell.
@@ -238,6 +240,7 @@
 #include <linux/string.h>
 #include <linux/freezer.h>
 #include <linux/utsname.h>
+#include <linux/buffer_head.h>
 
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
@@ -273,7 +276,7 @@ static const char longname_770[] = "Noki
 static const char longname_n800[] = "Nokia N800 Internet Tablet";
 static const char longname_n810[] = "Nokia N810 Internet Tablet";
 static const char longname_n810_wimax[] = "Nokia N810 Internet Tablet WiMAX Edition";
-static const char longname_rx51[] = "Nokia Nxxx (RX51) Internet Tablet (Storage Mode)";
+static const char longname_rx51[] = "N900 (Storage Mode)";
 
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_AUTHOR("Alan Stern");
@@ -350,6 +353,7 @@ static struct {
 
 	int		removable;
 	int		can_stall;
+	int		fua;
 
 	char		*transport_parm;
 	char		*protocol_parm;
@@ -368,10 +372,11 @@ static struct {
 	.protocol_parm		= "SCSI",
 	.removable		= 1,
 	.can_stall		= 0,
+	.fua			= 0,
 	.vendor			= DRIVER_VENDOR_ID,
 	.product		= DRIVER_PRODUCT_ID,
 	.release		= 0xffff,	// Use controller chip type
-	.buflen			= 16384,
+	.buflen			= 64 * 1024,
 	};
 
 
@@ -391,6 +396,8 @@ MODULE_PARM_DESC(removable, "true to sim
 module_param_named(stall, mod_data.can_stall, bool, S_IRUGO);
 MODULE_PARM_DESC(stall, "false to prevent bulk stalls");
 
+module_param_named(fua, mod_data.fua, bool, S_IRUGO);
+MODULE_PARM_DESC(fua, "true to obey SCSI WRITE(6,10,12) FUA bit");
 
 /* In the non-TEST version, only the module parameters listed above
  * are available. */
@@ -562,6 +569,8 @@ struct lun {
 	unsigned int	prevent_medium_removal : 1;
 	unsigned int	registered : 1;
 	unsigned int	info_valid : 1;
+	unsigned int	fua:1;
+	unsigned int	direct:1;
 
 	u32		sense_data;
 	u32		sense_data_info;
@@ -583,7 +592,10 @@ static struct lun *dev_to_lun(struct dev
 #define DELAYED_STATUS	(EP0_BUFSIZE + 999)	// An impossibly large value
 
 /* Number of buffers we will use.  2 is enough for double-buffering */
-#define NUM_BUFFERS	2
+/* FIXME: fsg_buffhd's should be allocated dynamically */
+#define NUM_BUFFERS	256
+/* FIXME: MEMLIMIT should be a parameter */
+#define MEMLIMIT (1024 * 1024)
 
 enum fsg_buffer_state {
 	BUF_STATE_EMPTY = 0,
@@ -591,8 +603,11 @@ enum fsg_buffer_state {
 	BUF_STATE_BUSY
 };
 
+struct fsg_dev;
+
 struct fsg_buffhd {
 	void				*buf;
+	size_t				buflen;
 	enum fsg_buffer_state		state;
 	struct fsg_buffhd		*next;
 
@@ -605,6 +620,8 @@ struct fsg_buffhd {
 	int				inreq_busy;
 	struct usb_request		*outreq;
 	int				outreq_busy;
+
+	struct fsg_dev *fsg;
 };
 
 enum fsg_state {
@@ -675,6 +692,7 @@ struct fsg_dev {
 	struct fsg_buffhd	*next_buffhd_to_fill;
 	struct fsg_buffhd	*next_buffhd_to_drain;
 	struct fsg_buffhd	buffhds[NUM_BUFFERS];
+	int			num_buffers;
 
 	int			thread_wakeup_needed;
 	struct completion	thread_notifier;
@@ -727,7 +745,6 @@ static struct fsg_dev			*the_fsg;
 static struct usb_gadget_driver		fsg_driver;
 
 static void	close_backing_file(struct lun *curlun);
-static void	close_all_backing_files(struct fsg_dev *fsg);
 
 
 /*-------------------------------------------------------------------------*/
@@ -829,8 +846,8 @@ static void put_be32(u8 *buf, u32 val)
 #define STRING_CONFIG_SELFPOWERED	5
 #define STRING_INTERFACE	6
 
-/* There is only one configuration. */
-#define	CONFIG_VALUE_MAXPOWER	1
+/* The configurations */
+#define	CONFIG_VALUE_MAXPOWER		1
 #define	CONFIG_VALUE_SELFPOWERED	2
 
 static struct usb_device_descriptor
@@ -861,7 +878,7 @@ config_desc_500 = {
 	.bNumInterfaces =	1,
 	.bConfigurationValue =	CONFIG_VALUE_MAXPOWER,
 	.iConfiguration =	STRING_CONFIG_MAXPOWER,
-	.bmAttributes =		USB_CONFIG_ATT_ONE,
+	.bmAttributes =		USB_CONFIG_ATT_ONE,	/* Bus powered */
 	.bMaxPower =		250, /* 500mA */
 };
 
@@ -1038,6 +1055,41 @@ static struct usb_gadget_strings	stringt
 	.strings	= strings,
 };
 
+/** UGLY UGLY HACK: Windows problems with multiple
+ * configurations.
+ *
+ * Windows can only handle 1 usb configuration at a time.
+ *
+ * In order to work around that issue, we will have a retry
+ * method implemented in such a way that we try one configuration
+ * at a time until one works.
+ *
+ * What we do is that we connect with 500mA configuration, if that
+ * doesn't work, we disconnect from the bus, change to 100mA and try
+ * again, if that still doesn't work, we disconnect and try 8mA,
+ * if that doesn't work we give up.
+ */
+
+/* To determine whether a configuration worked or no, we use a timer.
+ * If the time required to get a SET_CONFIG request exceeds the timeout,
+ * it means the configuration failed. We then use the next config.
+ */
+static struct timer_list fsg_set_config_timer;
+
+static void fsg_set_config_timeout(unsigned long _gadget)
+{
+	struct usb_gadget	*gadget = (void *) _gadget;
+	struct fsg_dev          *fsg = get_gadget_data(gadget);
+
+	/* Configuration failed, so disconnect from bus and use next config */
+	fsg->gadget->get_config = 0;
+	usb_gadget_disconnect(gadget);
+	/* sleep to allow host see our disconnect */
+	mdelay(500);
+	gadget->cindex++;
+	usb_gadget_connect(gadget);
+	DBG(fsg, "%s cindex %d\n", __func__, gadget->cindex);
+}
 
 /*
  * Config descriptors must agree with the code that sets configurations
@@ -1055,6 +1107,31 @@ static int populate_config_buf(struct us
 	if (index > 1)
 		return -EINVAL;
 
+	/** UGLY UGLY HACK: Windows problems with multiple
+	 * configurations.
+	 *
+	 * We need to keep track of which configuration to try this
+	 * time in order to make Windows happy. we don't implement
+	 * the hack if host sends non zero index.
+	 */
+	if (!index) {
+		index = gadget->cindex;
+
+		/** UGLY UGLY HACK: Windows problems with multiple
+		 * configurations.
+		 *
+		 * This is us giving up, if this one doesn't work
+		 * then user will have to take action, we can't
+		 * got any further
+		 */
+		if (index >= 1) {
+			del_timer(&fsg_set_config_timer);
+			gadget->set_config = 1;
+			/* Restrict to the last configuration */
+			index = 1;
+		}
+	}
+
 	if (gadget_is_dualspeed(gadget) && type == USB_DT_OTHER_SPEED_CONFIG)
 		speed = (USB_SPEED_FULL + USB_SPEED_HIGH) - speed;
 	if (gadget_is_dualspeed(gadget) && speed == USB_SPEED_HIGH)
@@ -1062,13 +1139,19 @@ static int populate_config_buf(struct us
 	else
 		function = fs_function;
 
-	if (device_desc.bNumConfigurations == 2 && index == 0)
+	switch (index) {
+	case 0:
 		config = &config_desc_500;
-	else
+		break;
+	case 1:
+	default:
 		config = &config_desc_100;
+		break;
+	}
 
 	/* for now, don't advertise srp-only devices */
 	if (machine_is_nokia770() || machine_is_nokia_n800()
+			|| machine_is_nokia_rx51()
 			|| !gadget_is_otg(gadget))
 		function++;
 
@@ -1124,6 +1207,33 @@ static void fsg_disconnect(struct usb_ga
 
 	DBG(fsg, "disconnect or port reset\n");
 	raise_exception(fsg, FSG_STATE_DISCONNECT);
+	/** UGLY UGLY HACK: Windows problems with multiple
+	 * configurations.
+	 *
+	 * We need to know we're gonna enumerate so we can
+	 * apply our retry method.
+	 */
+	gadget->set_config = 0;
+	gadget->get_config = 0;
+}
+
+/** UGLY UGLY HACK: Windows problems with multiple
+ * configurations.
+ *
+ * This hook was introduced to differentiate between
+ * BUS RESET and DISCONNECT events. All we do here
+ * is delete our retry timer so we don't retry
+ * forever.
+ */
+static void fsg_vbus_disconnect(struct usb_gadget *gadget)
+{
+	struct fsg_dev	*fsg = get_gadget_data(gadget);
+
+	DBG(fsg, "%s\n", __func__);
+	del_timer(&fsg_set_config_timer);
+	gadget->cindex = 0;
+	gadget->set_config = 0;
+	gadget->get_config = 0;
 }
 
 
@@ -1411,6 +1521,13 @@ get_config:
 					req->buf,
 					w_value >> 8,
 					w_value & 0xff);
+			/** UGLY UGLY HACK: Windows problems with multiple
+			 * configurations.
+			 *
+			 * Note that we got a get_config
+			 */
+			fsg->gadget->get_config = 1;
+			DBG(fsg, "get_config = 1\n");
 			break;
 
 		case USB_DT_STRING:
@@ -1438,6 +1555,15 @@ get_config:
 			raise_exception(fsg, FSG_STATE_CONFIG_CHANGE);
 			value = DELAYED_STATUS;
 		}
+		/** UGLY UGLY HACK: Windows problems with multiple
+		 * configurations.
+		 *
+		 * We got a SetConfiguration, meaning Windows accepted
+		 * our configuration descriptor, so stop the retry
+		 * timer and let device work.
+		 */
+		fsg->gadget->set_config = 1;
+		DBG(fsg, "set_config = 1\n");
 		break;
 	case USB_REQ_GET_CONFIGURATION:
 		if (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_STANDARD |
@@ -1581,6 +1707,85 @@ static int sleep_thread(struct fsg_dev *
 
 /*-------------------------------------------------------------------------*/
 
+static void direct_read_end_io(struct bio *bio, int err)
+{
+	if (err)
+		clear_bit(BIO_UPTODATE, &bio->bi_flags);
+
+	complete(bio->bi_private);
+}
+
+/*
+ * FIXME: Caller expects entire 'amount' to be read which means either:
+ * a) the maximum buflen must be less-than-or-equal the maximum I/O size
+ * or b) more than one bio must be submitted
+ */
+/* FIXME: Needs an equivalent of readahead */
+static ssize_t direct_read(struct file *file, char *buf, size_t amount, loff_t *pos)
+{
+	DECLARE_COMPLETION_ONSTACK(wait);
+	unsigned max_pages = (amount >> PAGE_SHIFT) + 1;
+	unsigned remains = amount;
+	ssize_t totlen = 0;
+	struct page *page;
+	struct bio *bio;
+	char *p = buf;
+
+	if (!amount)
+		return 0;
+
+	if (*pos & 511 || amount & 511)
+		return -EINVAL;
+
+	bio = bio_alloc(GFP_KERNEL, max_pages);
+	if (!bio)
+		return -ENOMEM;
+
+	bio->bi_sector = *pos >> 9;
+	bio->bi_bdev = file->f_path.dentry->d_inode->i_bdev;
+	bio->bi_end_io = direct_read_end_io;
+	bio->bi_private = &wait;
+
+	while (remains) {
+		unsigned offset, len;
+
+		page = virt_to_page(p);
+		offset = offset_in_page(p);
+		len = PAGE_SIZE - offset;
+		if (len > remains)
+			len = remains;
+		len = bio_add_page(bio, page, len, offset);
+		if (!len)
+			break;
+		remains -= len;
+		totlen += len;
+		p += len;
+	}
+
+	if (!totlen) {
+		bio_put(bio);
+		return -EINVAL;
+	}
+
+	submit_bio(READ, bio);
+
+	wait_for_completion(&wait);
+
+	if (!test_bit(BIO_UPTODATE, &bio->bi_flags)) {
+		totlen = -EIO;
+		goto out;
+	}
+
+	*pos += totlen;
+out:
+	bio_put(bio);
+
+	return totlen;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
 static int do_read(struct fsg_dev *fsg)
 {
 	struct lun		*curlun = fsg->curlun;
@@ -1621,6 +1826,14 @@ static int do_read(struct fsg_dev *fsg)
 
 	for (;;) {
 
+		/* Wait for the next buffer to become available */
+		bh = fsg->next_buffhd_to_fill;
+		while (bh->state != BUF_STATE_EMPTY) {
+			rc = sleep_thread(fsg);
+			if (rc)
+				return rc;
+		}
+
 		/* Figure out how much we need to read:
 		 * Try to read the remaining amount.
 		 * But don't read more than the buffer size.
@@ -1629,7 +1842,7 @@ static int do_read(struct fsg_dev *fsg)
 		 *	the next page.
 		 * If this means reading 0 then we were asked to read past
 		 *	the end of file. */
-		amount = min((unsigned int) amount_left, mod_data.buflen);
+		amount = min((unsigned int) amount_left, bh->buflen);
 		amount = min((loff_t) amount,
 				curlun->file_length - file_offset);
 		partial_page = file_offset & (PAGE_CACHE_SIZE - 1);
@@ -1637,14 +1850,6 @@ static int do_read(struct fsg_dev *fsg)
 			amount = min(amount, (unsigned int) PAGE_CACHE_SIZE -
 					partial_page);
 
-		/* Wait for the next buffer to become available */
-		bh = fsg->next_buffhd_to_fill;
-		while (bh->state != BUF_STATE_EMPTY) {
-			rc = sleep_thread(fsg);
-			if (rc)
-				return rc;
-		}
-
 		/* If we were asked to read past the end of file,
 		 * end with an empty buffer. */
 		if (amount == 0) {
@@ -1659,9 +1864,13 @@ static int do_read(struct fsg_dev *fsg)
 
 		/* Perform the read */
 		file_offset_tmp = file_offset;
-		nread = vfs_read(curlun->filp,
-				(char __user *) bh->buf,
-				amount, &file_offset_tmp);
+		if (curlun->direct)
+			nread = direct_read(curlun->filp, bh->buf,
+					amount, &file_offset_tmp);
+		else
+			nread = vfs_read(curlun->filp,
+					(char __user *) bh->buf,
+					amount, &file_offset_tmp);
 		VLDBG(curlun, "file read %u @ %llu -> %d\n", amount,
 				(unsigned long long) file_offset,
 				(int) nread);
@@ -1707,6 +1916,88 @@ static int do_read(struct fsg_dev *fsg)
 
 /*-------------------------------------------------------------------------*/
 
+static void direct_write_end_io(struct bio *bio, int err)
+{
+	struct fsg_buffhd *bh = bio->bi_private;
+	struct fsg_dev *fsg = bh->fsg;
+
+	if (err) {
+		/* FIXME: how to let host know about this error */
+		printk(KERN_ERR "direct_write_end_io: err %d\n", err);
+		clear_bit(BIO_UPTODATE, &bio->bi_flags);
+	}
+
+	smp_wmb();
+	spin_lock(&fsg->lock);
+	bh->state = BUF_STATE_EMPTY;
+	wakeup_thread(fsg);
+	spin_unlock(&fsg->lock);
+
+	bio_put(bio);
+}
+
+/*
+ * FIXME: Caller expects entire 'amount' to be written which means either:
+ * a) the maximum buflen must be less-than-or-equal the maximum I/O size
+ * or b) more than one bio must be submitted
+ */
+static ssize_t direct_write(struct file *file, struct fsg_buffhd *bh, size_t amount, loff_t *pos)
+{
+	unsigned max_pages = (amount >> PAGE_SHIFT) + 1;
+	unsigned remains = amount;
+	ssize_t totlen = 0;
+	struct page *page;
+	struct bio *bio;
+	char *p = bh->buf;
+
+	if (!amount)
+		return 0;
+
+	if (*pos & 511 || amount & 511)
+		return -EINVAL;
+
+	bio = bio_alloc(GFP_KERNEL, max_pages);
+	if (!bio)
+		return -ENOMEM;
+
+	bio->bi_sector = *pos >> 9;
+	bio->bi_bdev = file->f_path.dentry->d_inode->i_bdev;
+	bio->bi_end_io = direct_write_end_io;
+	bio->bi_private = bh;
+
+	while (remains) {
+		unsigned offset, len;
+
+		page = virt_to_page(p);
+		offset = offset_in_page(p);
+		len = PAGE_SIZE - offset;
+		if (len > remains)
+			len = remains;
+		len = bio_add_page(bio, page, len, offset);
+		if (!len)
+			break;
+		remains -= len;
+		totlen += len;
+		p += len;
+	}
+
+	if (!totlen) {
+		bio_put(bio);
+		return -EINVAL;
+	}
+
+	bh->state = BUF_STATE_BUSY;
+
+	submit_bio(WRITE, bio);
+
+	*pos += totlen;
+
+	return totlen;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
 static int do_write(struct fsg_dev *fsg)
 {
 	struct lun		*curlun = fsg->curlun;
@@ -1741,7 +2032,8 @@ static int do_write(struct fsg_dev *fsg)
 			curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
 			return -EINVAL;
 		}
-		if (fsg->cmnd[1] & 0x08)	// FUA
+		/* FUA */
+		if ((fsg->cmnd[1] & 0x08) && curlun->fua)
 			curlun->filp->f_flags |= O_SYNC;
 	}
 	if (lba >= curlun->num_sectors) {
@@ -1769,7 +2061,7 @@ static int do_write(struct fsg_dev *fsg)
 			 * If this means getting 0, then we were asked
 			 *	to write past the end of file.
 			 * Finally, round down to a block boundary. */
-			amount = min(amount_left_to_req, mod_data.buflen);
+			amount = min(amount_left_to_req, bh->buflen);
 			amount = min((loff_t) amount, curlun->file_length -
 					usb_offset);
 			partial_page = usb_offset & (PAGE_CACHE_SIZE - 1);
@@ -1840,9 +2132,13 @@ static int do_write(struct fsg_dev *fsg)
 
 			/* Perform the write */
 			file_offset_tmp = file_offset;
-			nwritten = vfs_write(curlun->filp,
-					(char __user *) bh->buf,
-					amount, &file_offset_tmp);
+			if (curlun->direct)
+				nwritten = direct_write(curlun->filp, bh,
+						amount, &file_offset_tmp);
+			else
+				nwritten = vfs_write(curlun->filp,
+						(char __user *) bh->buf,
+						amount, &file_offset_tmp);
 			VLDBG(curlun, "file write %u @ %llu -> %d\n", amount,
 					(unsigned long long) file_offset,
 					(int) nwritten);
@@ -2004,7 +2300,7 @@ static int do_verify(struct fsg_dev *fsg
 		 * And don't try to read past the end of the file.
 		 * If this means reading 0 then we were asked to read
 		 * past the end of file. */
-		amount = min((unsigned int) amount_left, mod_data.buflen);
+		amount = min((unsigned int) amount_left, bh->buflen);
 		amount = min((loff_t) amount,
 				curlun->file_length - file_offset);
 		if (amount == 0) {
@@ -2070,7 +2366,7 @@ static int do_inquiry(struct fsg_dev *fs
 	else if (machine_is_nokia_n810_wimax())
 		sprintf(product_id, "N810 WiMAX       ");
 	else
-		sprintf(product_id, "Nxxx (RX51)      ");
+		sprintf(product_id, "N900             ");
 #endif
 	if (!fsg->curlun) {		// Unsupported LUNs are okay
 		fsg->bad_lun_okay = 1;
@@ -2201,7 +2497,7 @@ static int do_mode_sense(struct fsg_dev
 	} else {			// SC_MODE_SENSE_10
 		buf[3] = (curlun->ro ? 0x80 : 0x00);		// WP, DPOFUA
 		buf += 8;
-		limit = 65535;		// Should really be mod_data.buflen
+		limit = bh->buflen - 1;
 	}
 
 	/* No block descriptors */
@@ -2367,29 +2663,6 @@ static int halt_bulk_in_endpoint(struct
 	return rc;
 }
 
-static int wedge_bulk_in_endpoint(struct fsg_dev *fsg)
-{
-	int	rc;
-
-	DBG(fsg, "bulk-in set wedge\n");
-	rc = usb_ep_set_wedge(fsg->bulk_in);
-	if (rc == -EAGAIN)
-		VDBG(fsg, "delayed bulk-in endpoint wedge\n");
-	while (rc != 0) {
-		if (rc != -EAGAIN) {
-			WARNING(fsg, "usb_ep_set_wedge -> %d\n", rc);
-			rc = 0;
-			break;
-		}
-
-		/* Wait for a short time and then try again */
-		if (msleep_interruptible(100) != 0)
-			return -EINTR;
-		rc = usb_ep_set_wedge(fsg->bulk_in);
-	}
-	return rc;
-}
-
 static int pad_with_zeros(struct fsg_dev *fsg)
 {
 	struct fsg_buffhd	*bh = fsg->next_buffhd_to_fill;
@@ -2408,7 +2681,7 @@ static int pad_with_zeros(struct fsg_dev
 				return rc;
 		}
 
-		nsend = min(fsg->usb_amount_left, (u32) mod_data.buflen);
+		nsend = min(fsg->usb_amount_left, (u32) bh->buflen);
 		memset(bh->buf + nkeep, 0, nsend - nkeep);
 		bh->inreq->length = nsend;
 		bh->inreq->zero = 0;
@@ -2449,7 +2722,7 @@ static int throw_away_data(struct fsg_de
 		bh = fsg->next_buffhd_to_fill;
 		if (bh->state == BUF_STATE_EMPTY && fsg->usb_amount_left > 0) {
 			amount = min(fsg->usb_amount_left,
-					(u32) mod_data.buflen);
+					(u32) bh->buflen);
 
 			/* amount is always divisible by 512, hence by
 			 * the bulk-out maxpacket size */
@@ -3053,8 +3326,14 @@ static int received_cbw(struct fsg_dev *
 		 * We aren't required to halt the OUT endpoint; instead
 		 * we can simply accept and discard any data received
 		 * until the next reset. */
-		wedge_bulk_in_endpoint(fsg);
-		set_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags);
+
+		/* USBCV tool expects Clear-Feature(HALT) to be processed
+		 * so don't wedge the IN endpoint, just stall it
+		 */
+
+		if (mod_data.can_stall)
+			halt_bulk_in_endpoint(fsg);
+
 		return -EINVAL;
 	}
 
@@ -3192,7 +3471,7 @@ static int do_set_interface(struct fsg_d
 
 reset:
 	/* Deallocate the requests */
-	for (i = 0; i < NUM_BUFFERS; ++i) {
+	for (i = 0; i < fsg->num_buffers; ++i) {
 		struct fsg_buffhd *bh = &fsg->buffhds[i];
 
 		if (bh->inreq) {
@@ -3250,7 +3529,7 @@ reset:
 	}
 
 	/* Allocate the requests */
-	for (i = 0; i < NUM_BUFFERS; ++i) {
+	for (i = 0; i < fsg->num_buffers; ++i) {
 		struct fsg_buffhd	*bh = &fsg->buffhds[i];
 
 		if ((rc = alloc_request(fsg, fsg->bulk_in, &bh->inreq)) != 0)
@@ -3361,7 +3640,7 @@ static void handle_exception(struct fsg_
 	/* Cancel all the pending transfers */
 	if (fsg->intreq_busy)
 		usb_ep_dequeue(fsg->intr_in, fsg->intreq);
-	for (i = 0; i < NUM_BUFFERS; ++i) {
+	for (i = 0; i < fsg->num_buffers; ++i) {
 		bh = &fsg->buffhds[i];
 		if (bh->inreq_busy)
 			usb_ep_dequeue(fsg->bulk_in, bh->inreq);
@@ -3372,7 +3651,7 @@ static void handle_exception(struct fsg_
 	/* Wait until everything is idle */
 	for (;;) {
 		num_active = fsg->intreq_busy;
-		for (i = 0; i < NUM_BUFFERS; ++i) {
+		for (i = 0; i < fsg->num_buffers; ++i) {
 			bh = &fsg->buffhds[i];
 			num_active += bh->inreq_busy + bh->outreq_busy;
 		}
@@ -3394,7 +3673,7 @@ static void handle_exception(struct fsg_
 	 * state, and the exception.  Then invoke the handler. */
 	spin_lock_irq(&fsg->lock);
 
-	for (i = 0; i < NUM_BUFFERS; ++i) {
+	for (i = 0; i < fsg->num_buffers; ++i) {
 		bh = &fsg->buffhds[i];
 		bh->state = BUF_STATE_EMPTY;
 	}
@@ -3552,12 +3831,10 @@ static int fsg_main_thread(void *fsg_)
 	fsg->thread_task = NULL;
 	spin_unlock_irq(&fsg->lock);
 
-	/* In case we are exiting because of a signal, unregister the
-	 * gadget driver and close the backing file. */
-	if (test_and_clear_bit(REGISTERED, &fsg->atomic_bitflags)) {
+	/* If we are exiting because of a signal, unregister the
+	 * gadget driver. */
+	if (test_and_clear_bit(REGISTERED, &fsg->atomic_bitflags))
 		usb_gadget_unregister_driver(&fsg_driver);
-		close_all_backing_files(fsg);
-	}
 
 	/* Let the unbind and cleanup routines know the thread has exited */
 	complete_and_exit(&fsg->thread_notifier, 0);
@@ -3597,7 +3874,10 @@ static int open_backing_file(struct lun
 
 	if (filp->f_path.dentry)
 		inode = filp->f_path.dentry->d_inode;
+	curlun->direct = 0;
 	if (inode && S_ISBLK(inode->i_mode)) {
+		/* FIXME: memory-limiting mode should be optional */
+		curlun->direct = 1;
 		if (bdev_read_only(inode->i_bdev))
 			ro = 1;
 	} else if (!inode || !S_ISREG(inode->i_mode)) {
@@ -3627,12 +3907,35 @@ static int open_backing_file(struct lun
 		goto out;
 	}
 
+	if (curlun->direct) {
+		/*
+		 * We are going to go around the caches, so make sure they
+		 * are sync'ed and invalidated. Note that typically, the block
+		 * device had a file system on it, which has just been
+		 * unmounted and the unmount has already cleared the caches
+		 * anyway.
+		 */
+		curlun->ro = ro;
+		curlun->filp = filp;
+		rc = fsync_sub(curlun);
+		if (rc) {
+			LINFO(curlun, "could not fsync: %s\n", filename);
+			curlun->filp = NULL;
+			goto out;
+		}
+		invalidate_mapping_pages(inode->i_mapping, 0, -1);
+		invalidate_bdev(inode->i_bdev);
+	}
+
 	get_file(filp);
 	curlun->ro = ro;
 	curlun->filp = filp;
 	curlun->file_length = size;
 	curlun->num_sectors = num_sectors;
 	LDBG(curlun, "open backing file: %s\n", filename);
+	if (curlun->direct)
+		LDBG(curlun, "using direct I/O with %u bytes memory limit\n",
+		     MEMLIMIT);
 	rc = 0;
 
 out:
@@ -3650,20 +3953,20 @@ static void close_backing_file(struct lu
 	}
 }
 
-static void close_all_backing_files(struct fsg_dev *fsg)
+
+static ssize_t show_ro(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	int	i;
+	struct lun	*curlun = dev_to_lun(dev);
 
-	for (i = 0; i < fsg->nluns; ++i)
-		close_backing_file(&fsg->luns[i]);
+	return sprintf(buf, "%d\n", curlun->ro);
 }
 
-
-static ssize_t show_ro(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_fua(struct device *dev, struct device_attribute *attr,
+		char *buf)
 {
 	struct lun	*curlun = dev_to_lun(dev);
 
-	return sprintf(buf, "%d\n", curlun->ro);
+	return sprintf(buf, "%u\n", curlun->fua);
 }
 
 static ssize_t show_file(struct device *dev, struct device_attribute *attr,
@@ -3754,9 +4057,27 @@ static ssize_t store_file(struct device
 }
 
 
+static ssize_t store_fua(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct lun	*curlun = dev_to_lun(dev);
+	unsigned long 	attr_val = 0;
+
+	if (strict_strtoul(buf, 2, &attr_val))
+		return -EINVAL;
+
+	if (!(curlun->fua))
+		fsync_sub(curlun);
+
+	curlun->fua = attr_val ? 1 : 0;
+
+	return count;
+}
+
 /* The write permissions and store_xxx pointers are set in fsg_bind() */
 static DEVICE_ATTR(ro, 0444, show_ro, NULL);
 static DEVICE_ATTR(file, 0444, show_file, NULL);
+static DEVICE_ATTR(fua, 0644, show_fua, store_fua);
 
 
 /*-------------------------------------------------------------------------*/
@@ -3792,6 +4113,7 @@ static void /* __init_or_exit */ fsg_unb
 		if (curlun->registered) {
 			device_remove_file(&curlun->dev, &dev_attr_ro);
 			device_remove_file(&curlun->dev, &dev_attr_file);
+			close_backing_file(curlun);
 			device_unregister(&curlun->dev);
 			curlun->registered = 0;
 		}
@@ -3807,7 +4129,7 @@ static void /* __init_or_exit */ fsg_unb
 	}
 
 	/* Free the data buffers */
-	for (i = 0; i < NUM_BUFFERS; ++i)
+	for (i = 0; i < fsg->num_buffers; ++i)
 		kfree(fsg->buffhds[i].buf);
 
 	/* Free the request and buffer for endpoint 0 */
@@ -3914,12 +4236,23 @@ static int __init fsg_bind(struct usb_ga
 	struct usb_ep		*ep;
 	struct usb_request	*req;
 	char			*pathbuf, *p;
+	ssize_t			memlimit;
 
 	fsg->gadget = gadget;
 	set_gadget_data(gadget, fsg);
 	fsg->ep0 = gadget->ep0;
 	fsg->ep0->driver_data = fsg;
 
+	/** UGLY UGLY HACK: Windows problems with multiple
+	 * configurations.
+	 *
+	 * On bind time, init our variables to zero so we
+	 * know our starting point.
+	 */
+	fsg->gadget->cindex = 0;
+	fsg->gadget->set_config = 0;
+	fsg->gadget->get_config = 0;
+
 	if ((rc = check_parameters(fsg)) != 0)
 		goto out;
 
@@ -3951,6 +4284,7 @@ static int __init fsg_bind(struct usb_ga
 	for (i = 0; i < fsg->nluns; ++i) {
 		curlun = &fsg->luns[i];
 		curlun->ro = mod_data.ro[i];
+		curlun->fua = mod_data.fua;
 		curlun->dev.release = lun_release;
 		curlun->dev.parent = &gadget->dev;
 		curlun->dev.driver = &fsg_driver.driver;
@@ -3965,7 +4299,9 @@ static int __init fsg_bind(struct usb_ga
 		if ((rc = device_create_file(&curlun->dev,
 					&dev_attr_ro)) != 0 ||
 				(rc = device_create_file(&curlun->dev,
-					&dev_attr_file)) != 0) {
+					&dev_attr_file)) != 0 ||
+				(rc = device_create_file(&curlun->dev,
+					&dev_attr_fua)) != 0) {
 			device_unregister(&curlun->dev);
 			goto out;
 		}
@@ -4026,7 +4362,7 @@ static int __init fsg_bind(struct usb_ga
 		device_desc.idProduct	= 0x0189;	/* N810 WiMAX*/
 	} else {
 		strings[1].s		= longname_rx51;
-		device_desc.idProduct	= 0x01c7;	/* Nxxx (rx51) */
+		device_desc.idProduct	= 0x01c7;	/* N900 */
 	}
 #else
 	device_desc.idVendor = cpu_to_le16(mod_data.vendor);
@@ -4073,21 +4409,53 @@ static int __init fsg_bind(struct usb_ga
 	req->complete = ep0_complete;
 
 	/* Allocate the data buffers */
-	for (i = 0; i < NUM_BUFFERS; ++i) {
+	/* FIXME: memory-limiting should be optional */
+	/* FIXME: buffers should be allocated and freed
+	 * when the first / last backing file is opened / closed
+	 */
+	memlimit = MEMLIMIT;
+	fsg->num_buffers = 0;
+	for (i = 0; i < NUM_BUFFERS && memlimit > 0; ++i) {
 		struct fsg_buffhd	*bh = &fsg->buffhds[i];
+		unsigned int		buflen = mod_data.buflen;
 
 		/* Allocate for the bulk-in endpoint.  We assume that
 		 * the buffer will also work with the bulk-out (and
-		 * interrupt-in) endpoint. */
-		bh->buf = kmalloc(mod_data.buflen, GFP_KERNEL);
-		if (!bh->buf)
+		 * interrupt-in) endpoint.
+		 *
+		 * We try to workaround problems with memory fragmentation
+		 * but we're not miracle men, so we stop trying allocation
+		 * when it can't allocate 4k buffers
+		 */
+		while (buflen >= PAGE_SIZE) {
+			gfp_t flags = GFP_KERNEL;
+
+			if (buflen == PAGE_SIZE)
+				flags |= __GFP_NOWARN;
+
+			bh->buf = kmalloc(buflen, flags);
+			if (bh->buf)
+				break;
+
+			buflen >>= 1;
+		}
+
+		if (buflen == PAGE_SIZE && bh->buf)
+			dev_dbg(&gadget->dev, "unable to allocate large buffer"
+					" fall back to small transfers\n");
+
+		bh->buflen = buflen;
+		bh->fsg = fsg;
+
+		if (!bh->buf) {
+			dev_err(&gadget->dev, "unable to allocate memory\n");
 			goto out;
+		}
+		memlimit -= buflen;
+		fsg->num_buffers += 1;
 		bh->next = bh + 1;
 	}
-	fsg->buffhds[NUM_BUFFERS - 1].next = &fsg->buffhds[0];
-
-	/* This should reflect the actual gadget power source */
-	usb_gadget_set_selfpowered(gadget);
+	fsg->buffhds[fsg->num_buffers - 1].next = &fsg->buffhds[0];
 
 	snprintf(manufacturer, sizeof manufacturer, "%s %s with %s",
 			init_utsname()->sysname, init_utsname()->release,
@@ -4111,7 +4479,8 @@ static int __init fsg_bind(struct usb_ga
 	}
 
 	INFO(fsg, DRIVER_DESC ", version: " DRIVER_VERSION "\n");
-	INFO(fsg, "Number of LUNs=%d\n", fsg->nluns);
+	INFO(fsg, "Number of LUNs=%d Number of buffers=%d\n",
+	     fsg->nluns, fsg->num_buffers);
 
 	pathbuf = kmalloc(PATH_MAX, GFP_KERNEL);
 	for (i = 0; i < fsg->nluns; ++i) {
@@ -4124,8 +4493,8 @@ static int __init fsg_bind(struct usb_ga
 				if (IS_ERR(p))
 					p = NULL;
 			}
-			LINFO(curlun, "ro=%d, file: %s\n",
-					curlun->ro, (p ? p : "(error)"));
+			LINFO(curlun, "ro=%d, fua=%d file: %s\n",
+				curlun->ro, curlun->fua, (p ? p : "(error)"));
 		}
 	}
 	kfree(pathbuf);
@@ -4145,6 +4514,14 @@ static int __init fsg_bind(struct usb_ga
 
 	/* Tell the thread to start working */
 	wake_up_process(fsg->thread_task);
+
+	/** UGLY UGLY HACK: Windows problems with multiple
+	 * configurations.
+	 *
+	 * setup our retry timer.
+	 */
+	setup_timer(&fsg_set_config_timer, fsg_set_config_timeout,
+				(unsigned long) gadget);
 	return 0;
 
 autoconf_fail:
@@ -4154,7 +4531,6 @@ autoconf_fail:
 out:
 	fsg->state = FSG_STATE_TERMINATED;	// The thread is dead
 	fsg_unbind(gadget);
-	close_all_backing_files(fsg);
 	complete(&fsg->thread_notifier);
 	return rc;
 }
@@ -4162,12 +4538,28 @@ out:
 
 /*-------------------------------------------------------------------------*/
 
+/** UGLY UGLY HACK: Windows problems with multiple
+ * configurations.
+ *
+ * when we suspend, we disconnect and retry with another configuration
+ */
 static void fsg_suspend(struct usb_gadget *gadget)
 {
 	struct fsg_dev		*fsg = get_gadget_data(gadget);
 
 	DBG(fsg, "suspend\n");
 	set_bit(SUSPENDED, &fsg->atomic_bitflags);
+
+	/** UGLY UGLY HACK: Windows problems with multiple
+	 * configurations.
+	 *
+	 * we try another configuration if we have received
+	 * a get_config but not a set_config
+	 */
+	if (gadget->get_config && !gadget->set_config) {
+		mod_timer(&fsg_set_config_timer,
+				jiffies + msecs_to_jiffies(10));
+	}
 }
 
 static void fsg_resume(struct usb_gadget *gadget)
@@ -4191,6 +4583,7 @@ static struct usb_gadget_driver		fsg_dri
 	.bind		= fsg_bind,
 	.unbind		= fsg_unbind,
 	.disconnect	= fsg_disconnect,
+	.vbus_disconnect = fsg_vbus_disconnect,
 	.setup		= fsg_setup,
 	.suspend	= fsg_suspend,
 	.resume		= fsg_resume,
@@ -4248,7 +4641,6 @@ static void __exit fsg_cleanup(void)
 	/* Wait for the thread to finish up */
 	wait_for_completion(&fsg->thread_notifier);
 
-	close_all_backing_files(fsg);
 	kref_put(&fsg->ref, fsg_release);
 }
 module_exit(fsg_cleanup);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/gadget/f_obex.c kernel-2.6.28-20093908+0m5/drivers/usb/gadget/f_obex.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/gadget/f_obex.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/gadget/f_obex.c	2012-12-16 13:13:01.692330145 +0100
@@ -30,17 +30,6 @@
 #include "u_serial.h"
 #include "gadget_chips.h"
 
-/*
- * pc-suite keeps setting the alt-settings back and forth, causing a
- * storm of HUPs going to obex server. That causes some pc-suite messages to
- * not get received by our obex server and thus causing pc-suite to think
- * the device is not connected anymore.
- *
- * That sure should get fixed.
- */
-static int pcsuite_hack = true;
-module_param_named(pcsuite, pcsuite_hack, bool, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(pcsuite, "Enable/disable pc-suite workaround. Default 'true'");
 
 /*
  * This CDC OBEX function support just packages a TTY-ish byte stream.
@@ -62,7 +51,6 @@ struct f_obex {
 	u8				port_num;
 	u8				can_activate;
 	u8				connected;
-	u8				one_conn;
 
 	struct obex_ep_descs		fs;
 	struct obex_ep_descs		hs;
@@ -84,14 +72,12 @@ static inline struct f_obex *port_to_obe
 #define OBEX_DATA_IDX	1
 #define OBEX_CTRL0_IDX	2
 #define OBEX_CTRL1_IDX	3
-#define OBEX_CTRL2_IDX	4
 
 static struct usb_string obex_string_defs[] = {
 	[OBEX_CTRL_IDX].s	= "CDC Object Exchange (OBEX)",
 	[OBEX_DATA_IDX].s	= "CDC OBEX Data",
 	[OBEX_CTRL0_IDX].s	= "PC Suite Services",
 	[OBEX_CTRL1_IDX].s	= "SYNCML-SYNC",
-	[OBEX_CTRL2_IDX].s	= "SYNCML-DM",
 	{  },	/* end of list */
 };
 
@@ -243,8 +229,7 @@ static int obex_set_alt(struct usb_funct
 
 		if (obex->port.in->driver_data) {
 			DBG(cdev, "reset obex ttyGS%d\n", obex->port_num);
-			if (!pcsuite_hack)
-				gserial_disconnect(&obex->port);
+			gserial_disconnect(&obex->port);
 		}
 
 		if (!obex->port.in_desc) {
@@ -257,14 +242,11 @@ static int obex_set_alt(struct usb_funct
 
 		if (alt == 1) {
 			DBG(cdev, "activate obex ttyGS%d\n", obex->port_num);
-			if (!obex->one_conn) {
-				obex->port.in_desc = ep_choose(cdev->gadget,
-						obex->hs.obex_in, obex->fs.obex_in);
-				obex->port.out_desc = ep_choose(cdev->gadget,
-						obex->hs.obex_out, obex->fs.obex_out);
-				gserial_connect(&obex->port, obex->port_num);
-				obex->one_conn = pcsuite_hack;
-			}
+			obex->port.in_desc = ep_choose(cdev->gadget,
+					obex->hs.obex_in, obex->fs.obex_in);
+			obex->port.out_desc = ep_choose(cdev->gadget,
+					obex->hs.obex_out, obex->fs.obex_out);
+			gserial_connect(&obex->port, obex->port_num);
 		}
 
 	} else
@@ -293,43 +275,6 @@ static void obex_disable(struct usb_func
 
 	DBG(cdev, "obex ttyGS%d disable\n", obex->port_num);
 	gserial_disconnect(&obex->port);
-	obex->one_conn = false;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static void obex_connect(struct gserial *g)
-{
-	struct f_obex		*obex = port_to_obex(g);
-	struct usb_composite_dev *cdev = g->func.config->cdev;
-	int			status;
-
-	if (!obex->can_activate || obex->connected)
-		return;
-
-	status = usb_function_activate(&g->func);
-	if (status)
-		DBG(cdev, "obex ttyGS%d function activate --> %d\n",
-			obex->port_num, status);
-	else
-		obex->connected = true;
-}
-
-static void obex_disconnect(struct gserial *g)
-{
-	struct f_obex		*obex = port_to_obex(g);
-	struct usb_composite_dev *cdev = g->func.config->cdev;
-	int			status;
-
-	if (!obex->can_activate || !obex->connected)
-		return;
-
-	status = usb_function_deactivate(&g->func);
-	if (status)
-		DBG(cdev, "obex ttyGS%d function deactivate --> %d\n",
-			obex->port_num, status);
-	else
-		obex->connected = false;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -403,18 +348,6 @@ obex_bind(struct usb_configuration *c, s
 				f->hs_descriptors, &obex_hs_ep_out_desc);
 	}
 
-	/* Avoid letting this gadget enumerate until the userspace
-	 * OBEX server is active.
-	 */
-	status = usb_function_deactivate(f);
-	if (status < 0) {
-		WARNING(cdev, "obex ttyGS%d: can't prevent enumeration, %d\n",
-			obex->port_num, status);
-		obex->connected = true;
-	} else {
-		obex->can_activate = true;
-	}
-
 	DBG(cdev, "obex ttyGS%d: %s speed IN/%s OUT/%s\n",
 			obex->port_num,
 			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
@@ -499,11 +432,6 @@ int __init obex_bind_config(struct usb_c
 		if (status < 0)
 			return status;
 		obex_string_defs[OBEX_CTRL1_IDX].id = status;
-
-		status = usb_string_id(c->cdev);
-		if (status < 0)
-			return status;
-		obex_string_defs[OBEX_CTRL2_IDX].id = status;
 	}
 
 	obex_data_nop_intf.iInterface = obex_string_defs[OBEX_DATA_IDX].id;
@@ -516,9 +444,6 @@ int __init obex_bind_config(struct usb_c
 	case 1:
 		obex_control_intf.iInterface = obex_string_defs[OBEX_CTRL1_IDX].id;
 		break;
-	case 2:
-		obex_control_intf.iInterface = obex_string_defs[OBEX_CTRL2_IDX].id;
-		break;
 	default:
 		obex_control_intf.iInterface = obex_string_defs[OBEX_CTRL_IDX].id;
 		break;
@@ -531,9 +456,6 @@ int __init obex_bind_config(struct usb_c
 
 	obex->port_num = port_num;
 
-	obex->port.connect = obex_connect;
-	obex->port.disconnect = obex_disconnect;
-
 	obex->port.func.name = "obex";
 	obex->port.func.strings = obex_strings;
 	/* descriptors are per-instance copies */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/gadget/f_phonet.c kernel-2.6.28-20093908+0m5/drivers/usb/gadget/f_phonet.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/gadget/f_phonet.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/gadget/f_phonet.c	2012-12-16 13:13:01.692330145 +0100
@@ -35,10 +35,6 @@
 #include "u_phonet.h"
 
 #define PN_MEDIA_USB	0x1B
-#define MAXPACKET	512
-#if (PAGE_SIZE % MAXPACKET)
-#error MAXPACKET must divide PAGE_SIZE!
-#endif
 
 /*-------------------------------------------------------------------------*/
 
@@ -60,7 +56,7 @@ struct f_phonet {
 	struct usb_request		*out_reqv[0];
 };
 
-static int phonet_rxq_size = 2;
+static int phonet_rxq_size = 17;
 
 static inline struct f_phonet *func_to_pn(struct usb_function *f)
 {
@@ -146,7 +142,7 @@ pn_hs_sink_desc = {
 
 	.bEndpointAddress =	USB_DIR_OUT,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
-	.wMaxPacketSize =	__constant_cpu_to_le16(MAXPACKET),
+	.wMaxPacketSize =	__constant_cpu_to_le16(512),
 };
 
 static struct usb_endpoint_descriptor
@@ -269,20 +265,10 @@ out:
 
 static int pn_net_mtu(struct net_device *dev, int new_mtu)
 {
-	struct phonet_port *port = netdev_priv(dev);
-	unsigned long flags;
-	int err = -EBUSY;
-
 	if ((new_mtu < PHONET_MIN_MTU) || (new_mtu > PHONET_MAX_MTU))
 		return -EINVAL;
-
-	spin_lock_irqsave(&port->lock, flags);
-	if (!netif_carrier_ok(dev)) {
-		dev->mtu = new_mtu;
-		err = 0;
-	}
-	spin_unlock_irqrestore(&port->lock, flags);
-	return err;
+	dev->mtu = new_mtu;
+	return 0;
 }
 
 static void pn_net_setup(struct net_device *dev)
@@ -290,7 +276,7 @@ static void pn_net_setup(struct net_devi
 	dev->features		= 0;
 	dev->type		= ARPHRD_PHONET;
 	dev->flags		= IFF_POINTOPOINT | IFF_NOARP;
-	dev->mtu		= PHONET_DEV_MTU;
+	dev->mtu		= (60 * 1024),
 	dev->hard_header_len	= 1;
 	dev->dev_addr[0]	= PN_MEDIA_USB;
 	dev->addr_len		= 1;
@@ -396,7 +382,6 @@ static void __pn_reset(struct usb_functi
 	struct net_device *dev = fp->dev;
 	struct phonet_port *port = netdev_priv(dev);
 
-	netif_carrier_off(dev);
 	port->usb = NULL;
 
 	usb_ep_disable(fp->out_ep);
@@ -443,7 +428,6 @@ static int pn_set_alt(struct usb_functio
 			fp->out_ep->driver_data = fp;
 			fp->in_ep->driver_data = fp;
 
-			netif_carrier_on(dev);
 			for (i = 0; i < phonet_rxq_size; i++)
 				pn_rx_submit(fp, fp->out_reqv[i], GFP_ATOMIC);
 		}
@@ -624,7 +608,6 @@ int __init gphonet_setup(struct usb_gadg
 
 	port = netdev_priv(dev);
 	spin_lock_init(&port->lock);
-	netif_carrier_off(dev);
 	netif_stop_queue(dev);
 	SET_NETDEV_DEV(dev, &gadget->dev);
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/gadget/f_raw.c kernel-2.6.28-20093908+0m5/drivers/usb/gadget/f_raw.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/gadget/f_raw.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/gadget/f_raw.c	2012-12-16 13:13:01.692330145 +0100
@@ -0,0 +1,779 @@
+/*
+ * f_raw.c -- USB Raw Access Function Driver
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ * Contact: Felipe Balbi <felipe.balbi@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+/* #define VERBOSE_DEBUG */
+
+#include <linux/kernel.h>
+#include <linux/utsname.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/wait.h>
+#include <linux/list.h>
+#include <linux/cdev.h>
+#include <linux/poll.h>
+#include <linux/dma-mapping.h>
+#include <linux/uaccess.h>
+
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb/raw.h>
+
+#include "gadget_chips.h"
+
+struct graw {
+	struct cdev			chdev;
+
+	struct usb_gadget		*gadget;
+	struct usb_function		func;
+
+	unsigned			major;
+	dev_t				dev;
+};
+
+static struct graw *the_graw;
+static struct f_raw *the_raw;
+
+struct raw_request {
+	struct usb_request		*req;
+	struct list_head		list;
+	wait_queue_head_t		wait;
+	unsigned long			len;
+
+	unsigned			queued:1, completed:1;
+	int				nr;
+};
+
+struct raw_ep_descs {
+	struct usb_endpoint_descriptor	*raw_out;
+};
+
+struct f_raw {
+	/* pool of read requests */
+	struct list_head		read_pool;
+	int				nr_reqs;
+
+	/* synchronize with userland access */
+	struct mutex			mutex;
+
+	struct usb_ep			*out;
+	struct raw_request		*allocated_req;
+	struct class			*class;
+
+	struct raw_ep_descs		fs;
+	struct raw_ep_descs		hs;
+
+	struct graw			graw;
+
+	unsigned			vmas;
+	unsigned			connected:1;
+	unsigned			can_activate:1;
+
+	u8				intf_id;
+};
+
+static inline struct f_raw *func_to_raw(struct usb_function *f)
+{
+	return container_of(f, struct f_raw, graw.func);
+}
+
+static u64 raw_dmamask = DMA_BIT_MASK(64);
+
+/*-------------------------------------------------------------------------*/
+
+#define RAW_INTF_IDX	1
+
+static struct usb_string raw_string_defs[] = {
+	[RAW_INTF_IDX].s	= "Device Upgrade Interface",
+	{  },	/* end of list */
+};
+
+static struct usb_gadget_strings raw_string_table = {
+	.language		= 0x0409,	/* en-US */
+	.strings		= raw_string_defs,
+};
+
+static struct usb_gadget_strings *raw_strings[] = {
+	&raw_string_table,
+	NULL,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static struct usb_interface_descriptor raw_intf __initdata = {
+	.bLength		= sizeof(raw_intf),
+	.bDescriptorType	= USB_DT_INTERFACE,
+	.bInterfaceNumber	= 0,
+
+	.bAlternateSetting	= 0,
+	.bNumEndpoints		= 1,
+	.bInterfaceClass	= USB_CLASS_VENDOR_SPEC,
+};
+
+/* High-Speed Support */
+
+static struct usb_endpoint_descriptor raw_hs_ep_out_desc = {
+	.bLength		= USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType	= USB_DT_ENDPOINT,
+
+	.bEndpointAddress	= USB_DIR_OUT,
+	.bmAttributes		= USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize		= __constant_cpu_to_le16(512),
+};
+
+static struct usb_descriptor_header *hs_function[] __initdata = {
+	(struct usb_descriptor_header *) &raw_intf,
+	(struct usb_descriptor_header *) &raw_hs_ep_out_desc,
+	NULL,
+};
+
+/* Full-Speed Support */
+
+static struct usb_endpoint_descriptor raw_fs_ep_out_desc = {
+	.bLength		= USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType	= USB_DT_ENDPOINT,
+
+	.bEndpointAddress	= USB_DIR_OUT,
+	.bmAttributes		= USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_descriptor_header *fs_function[] __initdata = {
+	(struct usb_descriptor_header *) &raw_intf,
+	(struct usb_descriptor_header *) &raw_fs_ep_out_desc,
+	NULL,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static void raw_complete(struct usb_ep *ep, struct usb_request *req);
+
+static struct raw_request *raw_alloc_request(struct f_raw *raw, unsigned buflen)
+{
+	struct list_head	*pool = &raw->read_pool;
+	struct usb_request	*req;
+	struct raw_request	*raw_req;
+	void			*buf;
+
+	raw_req = kzalloc(sizeof(*raw_req), GFP_KERNEL);
+	if (raw_req == NULL)
+		goto fail1;
+
+	INIT_LIST_HEAD(&raw_req->list);
+
+	req = usb_ep_alloc_request(raw->out, GFP_KERNEL);
+	if (req == NULL)
+		goto fail2;
+
+	req->length = buflen;
+	req->complete = raw_complete;
+	req->context = raw_req;
+
+	buf = dma_alloc_coherent(&raw->graw.gadget->dev, buflen,
+				 &req->dma, GFP_KERNEL);
+	if (IS_ERR(buf))
+		goto fail3;
+	req->buf = buf;
+
+	raw_req->req = req;
+	raw_req->len = buflen;
+
+	if (raw->nr_reqs == MAX_NR_REQUESTS)
+		goto fail4;
+
+	raw_req->nr = raw->nr_reqs;
+	raw->nr_reqs++;
+	list_add_tail(&raw_req->list, pool);
+
+	return raw_req;
+
+fail4:
+	dma_free_coherent(&raw->graw.gadget->dev, buflen,
+			  buf, req->dma);
+
+fail3:
+	usb_ep_free_request(raw->out, req);
+
+fail2:
+	kfree(raw_req);
+
+fail1:
+	return NULL;
+}
+
+static void raw_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct f_raw			*raw = ep->driver_data;
+	struct raw_request		*raw_req = req->context;
+	struct usb_composite_dev	*cdev = raw->graw.func.config->cdev;
+	int				status = req->status;
+
+	switch (status) {
+	case 0:				/* normal completion */
+		break;
+	case -ECONNABORTED:		/* hardware forced ep reset */
+	case -ECONNRESET:		/* request dequeued */
+	case -ESHUTDOWN:		/* disconnected from host */
+		VDBG(cdev, "%s gone (%d), %d/%d\n", ep->name, status,
+				req->actual, req->length);
+		return;
+	case -EOVERFLOW:		/* not big enough buffer */
+	default:
+		DBG(cdev, "%s complete --> %d, %d/%d\n", ep->name,
+				status, req->actual, req->length);
+	case -EREMOTEIO:		/* short read */
+		break;
+	}
+
+	raw_req->queued = 0;
+	raw_req->completed = 1;
+	wake_up_interruptible(&raw_req->wait);
+}
+
+static struct raw_request *find_request(struct f_raw *raw, int value)
+{
+	struct raw_request *req;
+
+	list_for_each_entry(req, &raw->read_pool, list)
+		if (req->nr == value)
+			return req;
+
+	return NULL;
+}
+
+static inline int enable_raw(struct usb_composite_dev *cdev, struct f_raw *raw)
+{
+	const struct usb_endpoint_descriptor	*out_desc;
+	struct usb_ep				*ep;
+
+	int					status = 0;
+
+	/* choose endpoint */
+	out_desc = ep_choose(cdev->gadget, &raw_hs_ep_out_desc,
+			&raw_fs_ep_out_desc);
+
+	/* enable it */
+	ep = raw->out;
+	status = usb_ep_enable(ep, out_desc);
+	if (status < 0)
+		return status;
+	ep->driver_data = raw;
+
+	DBG(cdev, "%s enabled\n", raw->graw.func.name);
+
+	return 0;
+}
+
+static inline void disable_raw(struct f_raw *raw)
+{
+	struct usb_composite_dev	*cdev;
+	struct usb_ep			*ep;
+
+	int				status;
+
+	cdev = raw->graw.func.config->cdev;
+
+	ep = raw->out;
+	if (ep->driver_data) {
+		status = usb_ep_disable(ep);
+		if (status < 0)
+			DBG(cdev, "disable %s --> %d\n",
+					ep->name, status);
+		ep->driver_data = NULL;
+	}
+
+	VDBG(cdev, "%s disabled\n", raw->graw.func.name);
+}
+
+static int raw_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
+{
+	struct usb_composite_dev	*cdev = f->config->cdev;
+	struct f_raw			*raw = func_to_raw(f);
+
+	/* we konw alt is zero */
+	if (raw->out->driver_data)
+		disable_raw(raw);
+
+	return enable_raw(cdev, raw);
+}
+
+static void raw_disable(struct usb_function *f)
+{
+	struct f_raw	*raw = func_to_raw(f);
+
+	disable_raw(raw);
+}
+
+static int raw_queue_request(struct f_raw *raw, struct raw_queue_request *qr)
+{
+	struct usb_ep		*ep = raw->out;
+	struct raw_request	*raw_req;
+	int			status = 0;
+
+	raw_req = find_request(raw, qr->nr);
+	if (raw_req == NULL)
+		return -ENOENT;
+
+	if (qr->nr_bytes > raw_req->len)
+		return -EINVAL;
+
+	/* FIXME: lock with irqsave and check if transfer already in progress,
+	 * bail out if so. */
+
+	raw_req->req->length = qr->nr_bytes;
+
+	init_waitqueue_head(&raw_req->wait);
+	raw_req->completed = 0;
+	raw_req->queued = 1;
+	status = usb_ep_queue(ep, raw_req->req, GFP_KERNEL);
+	if (status) {
+		struct usb_composite_dev	*cdev;
+
+		cdev = raw->graw.func.config->cdev;
+		ERROR(cdev, "start %s %s --> %d\n", "OUT", ep->name, status);
+		raw_req->queued = 0;
+	}
+
+	return status;
+}
+
+static int raw_free_request(struct f_raw *raw, int nr)
+{
+	struct raw_request *raw_req;
+	struct usb_request *req;
+
+	raw_req = find_request(raw, nr);
+	if (raw_req == NULL)
+		return -ENOENT;
+
+	if (raw->allocated_req == raw_req)
+		raw->allocated_req = NULL;
+	/* FIXME: munmap? */
+
+	req = raw_req->req;
+	/* FIXME: spinlocking? */
+	if (raw_req->queued)
+		usb_ep_dequeue(raw->out, req);
+	raw_req->queued = 0;
+	dma_free_coherent(&raw->graw.gadget->dev, raw_req->len, req->buf,
+			req->dma);
+	usb_ep_free_request(raw->out, req);
+	list_del(&raw_req->list);
+	kfree(raw_req);
+
+	return 0;
+}
+
+static int raw_get_request_status(struct f_raw *raw,
+				  struct raw_request_status *st)
+{
+	struct raw_request	*raw_req;
+
+	raw_req = find_request(raw, st->nr);
+	if (raw_req == NULL)
+		return -ENOENT;
+
+	if (!raw_req->queued) {
+		st->status = raw_req->req->status;
+		st->nr_bytes = raw_req->req->actual;
+		raw_req->completed = 0;
+	} else {
+		st->status = -EBUSY;
+		st->nr_bytes = 0;
+	}
+
+	return 0;
+}
+
+static void get_completion_map(struct f_raw *raw, unsigned int *mask_out)
+{
+	struct raw_request *req;
+	unsigned int mask = 0;
+
+	list_for_each_entry(req, &raw->read_pool, list)
+		if (req->completed)
+			mask |= (1 << req->nr);
+
+	*mask_out = mask;
+}
+
+static long fraw_ioctl(struct file *filp, unsigned code, unsigned long value)
+{
+	struct f_raw			*raw = filp->private_data;
+	struct usb_ep			*ep = raw->out;
+	unsigned int			map;
+	int				status = 0;
+	struct raw_request_status	req_st;
+	struct raw_queue_request	que_req;
+
+	if (unlikely(!ep))
+		return -EINVAL;
+
+	mutex_lock(&raw->mutex);
+
+	switch (code) {
+	case RAW_FIFO_STATUS:
+		status = usb_ep_fifo_status(ep);
+		break;
+	case RAW_FIFO_FLUSH:
+		usb_ep_fifo_flush(ep);
+		break;
+	case RAW_CLEAR_HALT:
+		status = usb_ep_clear_halt(ep);
+		break;
+	case RAW_ALLOC_REQUEST:
+		if (raw->allocated_req != NULL) {
+			status = -EBUSY;
+			break;
+		}
+		if (value > MAX_REQUEST_LEN || (value % PAGE_SIZE) != 0) {
+			status = -EINVAL;
+			break;
+		}
+		raw->allocated_req = raw_alloc_request(raw, value);
+		if (raw->allocated_req == NULL) {
+			status = -ENOMEM;
+			break;
+		}
+		status = raw->allocated_req->nr;
+		break;
+	case RAW_QUEUE_REQUEST:
+		status = copy_from_user(&que_req, (void __user *) value,
+					sizeof(que_req));
+		if (status)
+			break;
+		status = raw_queue_request(raw, &que_req);
+		break;
+	case RAW_FREE_REQUEST:
+		status = raw_free_request(raw, value);
+		break;
+	case RAW_GET_COMPLETION_MAP:
+		get_completion_map(raw, &map);
+		status = put_user(map, (unsigned int __user *) value);
+		break;
+	case RAW_GET_REQUEST_STATUS:
+		status = copy_from_user(&req_st, (void __user *) value,
+					sizeof(req_st));
+		if (status)
+			break;
+		status = raw_get_request_status(raw, &req_st);
+		if (status)
+			break;
+		status = copy_to_user((void __user *) value, &req_st,
+				      sizeof(req_st));
+	}
+
+	mutex_unlock(&raw->mutex);
+
+	return status;
+}
+
+static int fraw_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	size_t			size = vma->vm_end - vma->vm_start;
+	struct f_raw		*raw = filp->private_data;
+	struct raw_request	*raw_req;
+	struct usb_request	*req;
+	int			ret;
+
+	mutex_lock(&raw->mutex);
+	raw_req = raw->allocated_req;
+	if (raw_req == NULL) {
+		ret = -ENXIO;
+		goto out;
+	}
+	req = raw_req->req;
+
+	if (size != raw_req->len) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	vma->vm_private_data = raw;
+
+	ret = dma_mmap_coherent(&raw->graw.gadget->dev, vma, req->buf,
+				req->dma, raw_req->len);
+	if (ret < 0)
+		goto out;
+
+	raw->allocated_req = NULL;
+
+out:
+	mutex_unlock(&raw->mutex);
+
+	return 0;
+}
+
+static int fraw_open(struct inode *inode, struct file *filp)
+{
+	struct f_raw			*raw;
+
+	raw = the_raw;
+	filp->private_data = the_raw;
+
+	return 0;
+}
+
+static int fraw_release(struct inode *inode, struct file *filp)
+{
+	struct f_raw			*raw = filp->private_data;
+
+	while (!list_empty(&raw->read_pool)) {
+		struct raw_request *req;
+
+		req = list_first_entry(&raw->read_pool, struct raw_request,
+				       list);
+		raw_free_request(raw, req->nr);
+	}
+	raw->nr_reqs = 0;
+	filp->private_data = NULL;
+
+	return 0;
+}
+
+static unsigned int fraw_poll(struct file *filp, struct poll_table_struct *pt)
+{
+	struct f_raw			*raw = filp->private_data;
+	struct raw_request		*req;
+	int				ret = 0;
+
+	mutex_lock(&raw->mutex);
+	list_for_each_entry(req, &raw->read_pool, list) {
+		poll_wait(filp, &req->wait, pt);
+
+		if (req->completed) {
+			ret = POLLIN | POLLRDNORM;
+			break;
+		}
+	}
+	mutex_unlock(&raw->mutex);
+
+	return ret;
+}
+
+static struct file_operations fraw_fops = {
+	.owner		= THIS_MODULE,
+	.open		= fraw_open,
+	.release	= fraw_release,
+	.unlocked_ioctl	= fraw_ioctl,
+	.mmap		= fraw_mmap,
+	.poll		= fraw_poll,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __init raw_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev	*cdev = c->cdev;
+	struct f_raw			*raw = func_to_raw(f);
+	struct usb_ep			*ep;
+
+	int				status;
+
+	/* allocate instance-specific interface IDs and patch descriptors */
+
+	status = usb_interface_id(c, f);
+	if (status < 0)
+		goto fail;
+	raw->intf_id = status;
+
+	raw_intf.bInterfaceNumber = status;
+
+	/* allocate instance-specific endpoints */
+
+	ep = usb_ep_autoconfig(cdev->gadget, &raw_fs_ep_out_desc);
+	if (!ep)
+		goto fail;
+	raw->out = ep;
+	ep->driver_data = cdev; /* claim */
+
+	/* copy descriptors and track endpoint copies */
+	f->descriptors = usb_copy_descriptors(fs_function);
+
+	raw->fs.raw_out = usb_find_endpoint(fs_function,
+			f->descriptors, &raw_fs_ep_out_desc);
+
+	/* support all relevant hardware speeds... we expect that when
+	 * hardware is dual speed, all bulk-capable endpoints work at
+	 * both speeds
+	 */
+	if (gadget_is_dualspeed(c->cdev->gadget)) {
+		raw_hs_ep_out_desc.bEndpointAddress =
+			raw_fs_ep_out_desc.bEndpointAddress;
+
+		/* copy descriptors and track endpoint copies */
+		f->hs_descriptors = usb_copy_descriptors(hs_function);
+
+		raw->hs.raw_out = usb_find_endpoint(hs_function,
+				f->hs_descriptors, &raw_hs_ep_out_desc);
+	}
+
+	INIT_LIST_HEAD(&raw->read_pool);
+	mutex_init(&raw->mutex);
+
+	/* create device nodes */
+	raw->class = class_create(THIS_MODULE, "fraw");
+	device_create(raw->class, &cdev->gadget->dev,
+			MKDEV(raw->graw.major, 0), raw, "%s", f->name);
+
+	cdev->gadget->dev.dma_mask = &raw_dmamask;
+	cdev->gadget->dev.coherent_dma_mask = DMA_64BIT_MASK;
+	raw->graw.gadget = cdev->gadget;
+	the_raw = raw;
+
+	DBG(cdev, "raw: %s speed OUT/%s\n",
+			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
+			raw->out->name);
+
+	return 0;
+
+fail:
+	if (raw->class)
+		class_destroy(raw->class);
+
+	if (raw->out)
+		raw->out->driver_data = NULL;
+
+	ERROR(cdev, "%s/%p: can't bind, err %d\n", f->name, f, status);
+
+	return status;
+}
+
+static void raw_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct f_raw *raw = func_to_raw(f);
+
+	if (gadget_is_dualspeed(c->cdev->gadget))
+		usb_free_descriptors(f->hs_descriptors);
+	usb_free_descriptors(f->descriptors);
+	device_destroy(raw->class, MKDEV(raw->graw.major, 0));
+	class_destroy(raw->class);
+	kfree(raw);
+}
+
+/**
+ * raw_bind_config - add a RAW function to a configuration
+ * @c: the configuration to support the RAW instance
+ * Context: single threaded during gadget setup
+ *
+ * Returns zero on success, else negative errno.
+ */
+static int __init raw_bind_config(struct usb_configuration *c)
+{
+	struct f_raw	*raw;
+	int		status;
+
+	if (raw_string_defs[RAW_INTF_IDX].id == 0) {
+		status = usb_string_id(c->cdev);
+		if (status < 0)
+			return status;
+
+		raw_string_defs[RAW_INTF_IDX].id = status;
+		raw_intf.iInterface = status;
+	}
+
+	/* allocate and initialize one new instance */
+	raw = kzalloc(sizeof(*raw), GFP_KERNEL);
+	if (!raw)
+		return -ENOMEM;
+
+	raw->graw.func.name	= "raw";
+	raw->graw.func.strings	= raw_strings;
+	/* descriptors are per-instance copies */
+	raw->graw.func.bind	= raw_bind;
+	raw->graw.func.unbind	= raw_unbind;
+	raw->graw.func.set_alt	= raw_set_alt;
+	raw->graw.func.disable	= raw_disable;
+
+	status = usb_add_function(c, &raw->graw.func);
+	if (status)
+		kfree(raw);
+
+	return status;
+}
+
+/**
+ * graw_setup - initialize character driver for one rx
+ * @g: gadget to associate with
+ * Contex: may sleep
+ *
+ * Returns negative errno or zero.
+ */
+static int __init graw_setup(struct usb_gadget *g)
+{
+	struct graw	*graw;
+
+	int		status;
+	int		major;
+
+	dev_t		dev;
+
+	if (the_graw)
+		return -EBUSY;
+
+	graw = kzalloc(sizeof(*graw), GFP_KERNEL);
+	if (!graw) {
+		status = -ENOMEM;
+		goto fail1;
+	}
+
+	status = alloc_chrdev_region(&dev, 0, 1, "fraw");
+	if (status)
+		goto fail2;
+
+	major = MAJOR(dev);
+
+	cdev_init(&graw->chdev, &fraw_fops);
+	graw->chdev.owner	= THIS_MODULE;
+	graw->dev		= dev;
+	graw->major		= major;
+
+	status = cdev_add(&graw->chdev, dev, 1);
+	if (status)
+		goto fail3;
+
+	the_graw = graw;
+
+	return 0;
+
+fail3:
+	/* cdev_put(&graw->cdev); */
+	unregister_chrdev_region(graw->dev, 1);
+
+fail2:
+	kfree(graw);
+
+fail1:
+	return status;
+}
+
+static void __exit graw_cleanup(void)
+{
+	struct graw	*graw = the_graw;
+
+	if (!graw)
+		return;
+
+	cdev_del(&graw->chdev);
+	/* cdev_put(&graw->chdev); */
+	unregister_chrdev_region(graw->dev, 1);
+	kfree(graw);
+}
+
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/gadget/Kconfig kernel-2.6.28-20093908+0m5/drivers/usb/gadget/Kconfig
--- kernel-2.6.28-20091602+0m5/drivers/usb/gadget/Kconfig	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/gadget/Kconfig	2012-12-16 13:13:01.692330145 +0100
@@ -672,6 +672,16 @@ config USB_G_NOKIA
 	  It's only really useful for RX51 hardware. If you're building
 	  a kernel for RX51, say Y or M here. If unsure, say N.
 
+config USB_G_SOFTUPD
+	tristate "Nokia Firmware Upgrade Composite Kernel Driver"
+	depends on PHONET
+	help
+	  The Nokia upgrade gadget provides support for Firmware upgrading
+	  using the userland application softupd.
+
+	  It's only really useful for RX51 hardware. If you're building
+	  a kernel for RX51, say Y or M here. If unsure, say N.
+
 # put drivers that need isochronous transfer support (for audio
 # or video class gadget drivers), or specific hardware, here.
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/gadget/Makefile kernel-2.6.28-20093908+0m5/drivers/usb/gadget/Makefile
--- kernel-2.6.28-20091602+0m5/drivers/usb/gadget/Makefile	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/gadget/Makefile	2012-12-16 13:13:01.692330145 +0100
@@ -32,6 +32,7 @@ g_file_storage-objs		:= file_storage.o
 g_printer-objs			:= printer.o
 g_cdc-objs			:= cdc2.o
 g_nokia-objs			+= nokia.o
+g_softupd-objs			+= softupd.o
 
 obj-$(CONFIG_USB_ZERO)		+= g_zero.o
 obj-$(CONFIG_USB_ETH)		+= g_ether.o
@@ -42,4 +43,5 @@ obj-$(CONFIG_USB_G_PRINTER)	+= g_printer
 obj-$(CONFIG_USB_MIDI_GADGET)	+= g_midi.o
 obj-$(CONFIG_USB_CDC_COMPOSITE) += g_cdc.o
 obj-$(CONFIG_USB_G_NOKIA)	+= g_nokia.o
+obj-$(CONFIG_USB_G_SOFTUPD)	+= g_softupd.o
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/gadget/nokia.c kernel-2.6.28-20093908+0m5/drivers/usb/gadget/nokia.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/gadget/nokia.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/gadget/nokia.c	2012-12-16 13:13:01.692330145 +0100
@@ -31,7 +31,7 @@
 /* Defines */
 
 #define NOKIA_VERSION_NUM		0x0211
-#define NOKIA_LONG_NAME			"Nxxx (RX51) PC-Suite Mode"
+#define NOKIA_LONG_NAME			"N900 (PC-Suite Mode)"
 
 /*-------------------------------------------------------------------------*/
 
@@ -67,7 +67,7 @@
 #define STRING_DESCRIPTION_IDX		2
 
 static char manufacturer_nokia[] = "Nokia";
-static const char product_nokia[] = "Nxxx (RX51) PC-Suite Mode";
+static const char product_nokia[] = NOKIA_LONG_NAME;
 static const char description_nokia[] = "PC-Suite Configuration";
 
 static struct usb_string strings_dev[] = {
@@ -99,21 +99,10 @@ static struct usb_device_descriptor devi
 	.bNumConfigurations =	1,
 };
 
-static struct usb_otg_descriptor otg_descriptor = {
-	.bLength		= sizeof otg_descriptor,
-	.bDescriptorType	= USB_DT_OTG,
-	.bmAttributes		= USB_OTG_SRP | USB_OTG_HNP,
-};
-
-static const struct usb_descriptor_header *otg_desc[] = {
-	(struct usb_descriptor_header *) &otg_descriptor,
-	NULL,
-};
-
 /*-------------------------------------------------------------------------*/
 
 /* Module */
-MODULE_DESCRIPTION("Nokia composite gadget driver for Nxxx");
+MODULE_DESCRIPTION("Nokia composite gadget driver for N900");
 MODULE_AUTHOR("Felipe Balbi");
 MODULE_LICENSE("GPL");
 
@@ -123,21 +112,21 @@ static u8 hostaddr[ETH_ALEN];
 
 static int __init nokia_bind_config(struct usb_configuration *c)
 {
-	unsigned i = 0;
 	int status = 0;
 
 	status = phonet_bind_config(c);
 	if (status)
 		printk(KERN_DEBUG "could not bind phonet config\n");
 
-	for (i = 0; i < 3 && status == 0; i++) {
-		status = obex_bind_config(c, i);
-		if (status)
-			printk(KERN_DEBUG "could not bind obex config %d\n",
-					i);
-	}
+	status = obex_bind_config(c, 0);
+	if (status)
+		printk(KERN_DEBUG "could not bind obex config %d\n", 0);
+
+	status = obex_bind_config(c, 1);
+	if (status)
+		printk(KERN_DEBUG "could not bind obex config %d\n", 0);
 
-	status = acm_bind_config(c, 3);
+	status = acm_bind_config(c, 2);
 	if (status)
 		printk(KERN_DEBUG "could not bind acm config\n");
 
@@ -153,8 +142,8 @@ static struct usb_configuration nokia_co
 	.bind		= nokia_bind_config,
 	.bConfigurationValue = 1,
 	/* .iConfiguration = DYNAMIC */
-	.bmAttributes	= USB_CONFIG_ATT_SELFPOWER,
-	.bMaxPower	= 250,
+	.bmAttributes	= USB_CONFIG_ATT_ONE,
+	.bMaxPower	= 250, /* 500mA */
 };
 
 static struct usb_configuration nokia_config_100ma_driver = {
@@ -162,8 +151,8 @@ static struct usb_configuration nokia_co
 	.bind		= nokia_bind_config,
 	.bConfigurationValue = 2,
 	/* .iConfiguration = DYNAMIC */
-	.bmAttributes	= USB_CONFIG_ATT_SELFPOWER,
-	.bMaxPower	= 50,
+	.bmAttributes	= USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,
+	.bMaxPower	= 50, /* 100 mA */
 };
 
 static int __init nokia_bind(struct usb_composite_dev *cdev)
@@ -176,7 +165,7 @@ static int __init nokia_bind(struct usb_
 	if (status < 0)
 		goto err_phonet;
 
-	status = gserial_setup(cdev->gadget, 4);
+	status = gserial_setup(cdev->gadget, 3);
 	if (status < 0)
 		goto err_serial;
 
@@ -220,13 +209,6 @@ static int __init nokia_bind(struct usb_
 		goto err_usb;
 	}
 
-	/* We know this device is always otg capable */
-	nokia_config_500ma_driver.descriptors = otg_desc;
-	nokia_config_500ma_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
-
-	nokia_config_100ma_driver.descriptors = otg_desc;
-	nokia_config_100ma_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
-
 	/* finaly register the configuration */
 	status = usb_add_config(cdev, &nokia_config_500ma_driver);
 	if (status < 0)
@@ -250,11 +232,21 @@ err_phonet:
 	return status;
 }
 
+static int __exit nokia_unbind(struct usb_composite_dev *cdev)
+{
+	gphonet_cleanup();
+	gserial_cleanup();
+	gether_cleanup();
+
+	return 0;
+}
+
 static struct usb_composite_driver nokia_driver = {
 	.name		= "g_nokia",
 	.dev		= &device_desc,
 	.strings	= dev_strings,
 	.bind		= nokia_bind,
+	.unbind		= __exit_p(nokia_unbind),
 };
 
 static int __init nokia_init(void)
@@ -266,9 +258,6 @@ module_init(nokia_init);
 static void __exit nokia_cleanup(void)
 {
 	usb_composite_unregister(&nokia_driver);
-	gphonet_cleanup();
-	gserial_cleanup();
-	gether_cleanup();
 }
 module_exit(nokia_cleanup);
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/gadget/softupd.c kernel-2.6.28-20093908+0m5/drivers/usb/gadget/softupd.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/gadget/softupd.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/gadget/softupd.c	2012-12-16 13:13:01.692330145 +0100
@@ -0,0 +1,243 @@
+/*
+ * softupd.c -- Nokia Software Update Gadget
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ * Contact: Felipe Balbi <felipe.balbi@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/utsname.h>
+#include <linux/device.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include "gadget_chips.h"
+
+/* Defines */
+
+#define NOKIA_VERSION_NUM		0x0100
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Kbuild is not very cooperative with respect to linking separately
+ * compiled library objects into one module.  So for now we won't use
+ * separate compilation ... ensuring init/exit sections work to shrink
+ * the runtime footprint, and giving us at least some parts of what
+ * a "gcc --combine ... part1.c part2.c part3.c ... " build would.
+ */
+#include "composite.c"
+#include "usbstring.c"
+#include "config.c"
+#include "epautoconf.c"
+
+#include "u_phonet.h"
+
+#include "f_raw.c"
+#include "f_phonet.c"
+
+/*-------------------------------------------------------------------------*/
+
+#define NOKIA_VENDOR_ID			0x0421	/* Nokia */
+#define NOKIA_PRODUCT_ID		0x01c8	/* Nokia Update Gadget */
+
+/* string IDs are assigned dynamically */
+
+#define STRING_MANUFACTURER_IDX		0
+#define STRING_PRODUCT_IDX		1
+#define STRING_DESCRIPTION_IDX		2
+#define STRING_SERIAL_IDX		3
+
+static char manufacturer_nokia[] = "Nokia";
+static const char product_nokia[] = "N900 (PC-Suite Mode)";
+static const char description_nokia[] = "Firmware Upgrade Configuration";
+
+static struct usb_string strings_dev[] = {
+	[STRING_MANUFACTURER_IDX].s = manufacturer_nokia,
+	[STRING_PRODUCT_IDX].s = product_nokia,
+	[STRING_DESCRIPTION_IDX].s = description_nokia,
+	[STRING_SERIAL_IDX].s = "",
+	{  } /* end of list */
+};
+
+static struct usb_gadget_strings stringtab_dev = {
+	.language	= 0x0409,	/* en-us */
+	.strings	= strings_dev,
+};
+
+static struct usb_gadget_strings *dev_strings[] = {
+	&stringtab_dev,
+	NULL,
+};
+
+static struct usb_device_descriptor device_desc = {
+	.bLength		= USB_DT_DEVICE_SIZE,
+	.bDescriptorType	= USB_DT_DEVICE,
+
+	.bcdUSB			= __constant_cpu_to_le16(0x0200),
+
+	.bDeviceClass		= USB_CLASS_COMM,
+	.idVendor		= __constant_cpu_to_le16(NOKIA_VENDOR_ID),
+	.idProduct		= __constant_cpu_to_le16(NOKIA_PRODUCT_ID),
+
+	/* .iManufacturer = DYNAMIC */
+	/* .iProduct = DYNAMIC */
+	/* .iSerialNumber = DYNAMIC */
+
+	.bNumConfigurations =	1,
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* Module */
+MODULE_DESCRIPTION("Nokia Firmware Upgrade Gadget Driver");
+MODULE_AUTHOR("Felipe Balbi");
+MODULE_LICENSE("GPL");
+
+/*-------------------------------------------------------------------------*/
+
+static int __init softupd_bind_config(struct usb_configuration *c)
+{
+	int status = 0;
+
+	status = phonet_bind_config(c);
+	if (status) {
+		struct usb_composite_dev *cdev = c->cdev;
+
+		dev_err(&cdev->gadget->dev, "could not bind phonet config\n");
+	}
+
+	status = raw_bind_config(c);
+	if (status)
+		dev_err(&c->cdev->gadget->dev, "could not bind raw config\n");
+
+	return status;
+}
+
+static struct usb_configuration softupd_config_driver = {
+	.label		= "softupd",
+	.bind		= softupd_bind_config,
+
+	.bmAttributes	= USB_CONFIG_ATT_ONE,
+	.bMaxPower	= 250,
+
+	/* .iConfiguration = DYNAMIC */
+	.bConfigurationValue = 1,
+};
+
+static int __init softupd_bind(struct usb_composite_dev *cdev)
+{
+	struct usb_gadget	*gadget = cdev->gadget;
+	int			status;
+	int			gcnum;
+
+	status = gphonet_setup(cdev->gadget);
+	if (status < 0)
+		goto err_phonet;
+
+	status = graw_setup(cdev->gadget);
+	if (status < 0)
+		goto err_raw;
+
+	status = usb_string_id(cdev);
+	if (status < 0)
+		goto err_usb;
+	strings_dev[STRING_MANUFACTURER_IDX].id = status;
+
+	device_desc.iManufacturer = status;
+
+	status = usb_string_id(cdev);
+	if (status < 0)
+		goto err_usb;
+	strings_dev[STRING_PRODUCT_IDX].id = status;
+
+	device_desc.iProduct = status;
+
+	status = usb_string_id(cdev);
+	if (status < 0)
+		goto err_usb;
+	strings_dev[STRING_SERIAL_IDX].id = status;
+
+	device_desc.iSerialNumber = status;
+
+	/* config description */
+	status = usb_string_id(cdev);
+	if (status < 0)
+		goto err_usb;
+	strings_dev[STRING_DESCRIPTION_IDX].id = status;
+
+	softupd_config_driver.iConfiguration = status;
+
+	/* set up other descriptors */
+	gcnum = usb_gadget_controller_number(gadget);
+	if (gcnum >= 0)
+		device_desc.bcdDevice = cpu_to_le16(NOKIA_VERSION_NUM);
+	else {
+		/* this should only work with hw that supports altsettings
+		 * and several endpoints, anything else, panic.
+		 */
+		pr_err("%s: controller '%s' not recognized\n",
+				__func__, gadget->name);
+		goto err_usb;
+	}
+
+	/* finaly register the configuration */
+	status = usb_add_config(cdev, &softupd_config_driver);
+	if (status < 0)
+		goto err_usb;
+
+	INFO(cdev, "%s\n", product_nokia);
+
+	return 0;
+
+err_usb:
+	graw_cleanup();
+
+err_raw:
+	gphonet_cleanup();
+
+err_phonet:
+	return status;
+}
+
+static int softupd_unbind(struct usb_composite_dev *cdev)
+{
+	graw_cleanup();
+	gphonet_cleanup();
+
+	return 0;
+}
+
+static struct usb_composite_driver softupd_driver = {
+	.name		= "g_softupd",
+	.dev		= &device_desc,
+	.strings	= dev_strings,
+	.bind		= softupd_bind,
+	.unbind		= softupd_unbind,
+};
+
+static int __init softupd_init(void)
+{
+	return usb_composite_register(&softupd_driver);
+}
+module_init(softupd_init);
+
+static void __exit softupd_cleanup(void)
+{
+	usb_composite_unregister(&softupd_driver);
+}
+module_exit(softupd_cleanup);
+
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/gadget/u_ether.c kernel-2.6.28-20093908+0m5/drivers/usb/gadget/u_ether.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/gadget/u_ether.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/gadget/u_ether.c	2012-12-16 13:13:01.692330145 +0100
@@ -808,6 +808,8 @@ void gether_cleanup(void)
 	if (!the_dev)
 		return;
 
+	netif_stop_queue(the_dev->net);
+	netif_carrier_off(the_dev->net);
 	unregister_netdev(the_dev->net);
 	free_netdev(the_dev->net);
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/gadget/u_serial.c kernel-2.6.28-20093908+0m5/drivers/usb/gadget/u_serial.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/gadget/u_serial.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/gadget/u_serial.c	2012-12-16 13:13:01.692330145 +0100
@@ -81,6 +81,7 @@
 /* circular buffer */
 struct gs_buf {
 	unsigned		buf_size;
+	unsigned		buf_full;
 	char			*buf_buf;
 	char			*buf_get;
 	char			*buf_put;
@@ -110,6 +111,7 @@ struct gs_port {
 	struct list_head	write_pool;
 	struct gs_buf		port_write_buf;
 	wait_queue_head_t	drain_wait;	/* wait while writes drain */
+	wait_queue_head_t	full_wait;	/* wait while buffer is full */
 
 	/* REVISIT this state ... */
 	struct usb_cdc_line_coding port_line_coding;	/* 8-N-1 etc */
@@ -124,6 +126,7 @@ static struct portmaster {
 static unsigned	n_ports;
 
 #define GS_CLOSE_TIMEOUT		15		/* seconds */
+#define GS_FULL_TIMEOUT			2		/* seconds */
 
 
 
@@ -151,6 +154,7 @@ static int gs_buf_alloc(struct gs_buf *g
 		return -ENOMEM;
 
 	gb->buf_size = size;
+	gb->buf_full = false;
 	gb->buf_put = gb->buf_buf;
 	gb->buf_get = gb->buf_buf;
 
@@ -166,6 +170,7 @@ static void gs_buf_free(struct gs_buf *g
 {
 	kfree(gb->buf_buf);
 	gb->buf_buf = NULL;
+	gb->buf_full = false;
 }
 
 /*
@@ -176,6 +181,7 @@ static void gs_buf_free(struct gs_buf *g
 static void gs_buf_clear(struct gs_buf *gb)
 {
 	gb->buf_get = gb->buf_put;
+	gb->buf_full = false;
 	/* equivalent to a get of all data available */
 }
 
@@ -187,6 +193,9 @@ static void gs_buf_clear(struct gs_buf *
  */
 static unsigned gs_buf_data_avail(struct gs_buf *gb)
 {
+	if (gb->buf_full)
+		return gb->buf_size;
+
 	return (gb->buf_size + gb->buf_put - gb->buf_get) % gb->buf_size;
 }
 
@@ -198,7 +207,13 @@ static unsigned gs_buf_data_avail(struct
  */
 static unsigned gs_buf_space_avail(struct gs_buf *gb)
 {
-	return (gb->buf_size + gb->buf_get - gb->buf_put - 1) % gb->buf_size;
+	if (gb->buf_full)
+		return 0;
+
+	if (gb->buf_get == gb->buf_put)
+		return gb->buf_size;
+
+	return (gb->buf_size + gb->buf_get - gb->buf_put) % gb->buf_size;
 }
 
 /*
@@ -215,8 +230,10 @@ gs_buf_put(struct gs_buf *gb, const char
 	unsigned len;
 
 	len  = gs_buf_space_avail(gb);
-	if (count > len)
+	if (count >= len) {
 		count = len;
+		gb->buf_full = true;
+	}
 
 	if (count == 0)
 		return 0;
@@ -269,6 +286,7 @@ gs_buf_get(struct gs_buf *gb, char *buf,
 		else /* count == len */
 			gb->buf_get = gb->buf_buf;
 	}
+	gb->buf_full = false;
 
 	return count;
 }
@@ -325,13 +343,10 @@ void gs_free_req(struct usb_ep *ep, stru
 static unsigned
 gs_send_packet(struct gs_port *port, char *packet, unsigned size)
 {
-	unsigned len;
 
-	len = gs_buf_data_avail(&port->port_write_buf);
-	if (len < size)
-		size = len;
-	if (size != 0)
-		size = gs_buf_get(&port->port_write_buf, packet, size);
+	size = gs_buf_get(&port->port_write_buf, packet, size);
+	wake_up_interruptible(&port->full_wait);
+
 	return size;
 }
 
@@ -371,6 +386,7 @@ __acquires(&port->port_lock)
 
 		req->length = len;
 		list_del(&req->list);
+		req->zero = (gs_buf_data_avail(&port->port_write_buf) == 0);
 
 		pr_vdebug(PREFIX "%d: tx len=%d, 0x%02x 0x%02x 0x%02x ...\n",
 				port->port_num, len, *((u8 *)req->buf),
@@ -889,7 +905,17 @@ static int gs_write(struct tty_struct *t
 	pr_vdebug("gs_write: ttyGS%d (%p) writing %d bytes\n",
 			port->port_num, tty, count);
 
+	if (port->port_write_buf.buf_full)
+		wait_event_interruptible_timeout(port->full_wait,
+					!port->port_write_buf.buf_full,
+					GS_FULL_TIMEOUT * HZ);
+
 	spin_lock_irqsave(&port->port_lock, flags);
+	if (unlikely(port->port_write_buf.buf_buf == NULL)) {
+		spin_unlock_irqrestore(&port->port_lock, flags);
+		return 0;
+	}
+
 	if (count)
 		count = gs_buf_put(&port->port_write_buf, buf, count);
 	/* treat count == 0 as flush_chars() */
@@ -1026,6 +1052,7 @@ gs_port_alloc(unsigned port_num, struct
 	spin_lock_init(&port->port_lock);
 	init_waitqueue_head(&port->close_wait);
 	init_waitqueue_head(&port->drain_wait);
+	init_waitqueue_head(&port->full_wait);
 
 	tasklet_init(&port->push, gs_rx_push, (unsigned long) port);
 
@@ -1326,5 +1353,6 @@ void gserial_disconnect(struct gserial *
 	gs_free_requests(gser->out, &port->read_pool);
 	gs_free_requests(gser->out, &port->read_queue);
 	gs_free_requests(gser->in, &port->write_pool);
+	wake_up_interruptible(&port->full_wait);
 	spin_unlock_irqrestore(&port->port_lock, flags);
 }
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/musb/isp1704.h kernel-2.6.28-20093908+0m5/drivers/usb/musb/isp1704.h
--- kernel-2.6.28-20091602+0m5/drivers/usb/musb/isp1704.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/musb/isp1704.h	2012-12-16 13:13:01.692330145 +0100
@@ -33,8 +33,42 @@
 #ifndef __ISP1704_H__
 #define __ISP1704_H__
 
+#define ISP1704_VENDOR_ID_LOW		0x00
+#define ISP1704_VENDOR_ID_HIGH		0x01
+#define ISP1704_PRODUCT_ID_LOW		0x02
+#define ISP1704_PRODUCT_ID_HIGH		0x03
+#define ISP1704_FUNC_CTRL		0x04
+#define ISP1704_OTG_CTRL		0x0a
+#define ISP1704_USB_INTRISE		0x0d
+#define ISP1704_USB_INTFALL		0x10
+#define ISP1704_DEBUG			0x15
+#define ISP1704_SCRATCH			0x16
 #define ISP1704_PWR_CTRL		0x3d
 
+/* Function control */
+#define ISP1704_FUNC_CTRL_FULL_SPEED	(1 << 0)
+#define ISP1704_FUNC_CTRL_XCVRSELECT	0x3
+#define ISP1704_FUNC_CTRL_XCVRSELECT_SHIFT	(1 << 0)
+#define ISP1704_FUNC_CTRL_TERMSELECT	(1 << 2)
+#define ISP1704_FUNC_CTRL_OPMODE	(1 << 3)
+#define ISP1704_FUNC_CTRL_OPMODE_SHIFT	3
+#define ISP1704_FUNC_CTRL_RESET		(1 << 5)
+#define ISP1704_FUNC_CTRL_SUSPENDM	(1 << 6)
+
+/* OTG Control */
+#define ISP1704_OTG_CTRL_IDPULLUP	(1 << 0)
+#define ISP1704_OTG_CTRL_DP_PULLDOWN	(1 << 1)
+#define ISP1704_OTG_CTRL_DM_PULLDOWN	(1 << 2)
+#define ISP1704_OTG_CTRL_DISCHRG_VBUS	(1 << 3)
+#define ISP1704_OTG_CTRL_CHRG_VBUS	(1 << 4)
+#define ISP1704_OTG_CTRL_DRV_VBUS_EXT	(1 << 6)
+#define ISP1704_OTG_CTRL_USB_EXT_VBUS	(1 << 7)
+
+/* Debug */
+#define ISP1704_DEBUG_LINESTATE0	(1 << 0)
+#define ISP1704_DEBUG_LINESTATE1	(1 << 1)
+
+/* Power control */
 #define ISP1704_PWR_CTRL_SWCTRL		(1 << 0)
 #define ISP1704_PWR_CTRL_DET_COMP	(1 << 1)
 #define ISP1704_PWR_CTRL_BVALID_RISE	(1 << 2)
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/musb/musb_core.c kernel-2.6.28-20093908+0m5/drivers/usb/musb/musb_core.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/musb/musb_core.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/musb/musb_core.c	2012-12-16 13:13:01.696330145 +0100
@@ -116,14 +116,14 @@ static struct musb *the_musb;
 static struct musb_ctx ctx;
 
 #ifndef CONFIG_MUSB_PIO_ONLY
-static int __initdata use_dma = 0;
+static int __initdata use_dma = 1;
 #else
 static int __initdata use_dma;
 #endif
 module_param(use_dma, bool, 0);
 MODULE_PARM_DESC(use_dma, "enable/disable use of DMA");
 
-unsigned musb_debug = 5;
+unsigned musb_debug = 0;
 module_param_named(debug, musb_debug, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(debug, "Debug message level. Default = 0");
 
@@ -142,11 +142,87 @@ MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:" MUSB_DRIVER_NAME);
 
+static inline int musb_verify_charger(void __iomem *addr)
+{
+	u8 r, ret = 0;
+
+	/* Reset the transceiver */
+	r = musb_ulpi_readb(addr, ISP1704_FUNC_CTRL);
+	r |= ISP1704_FUNC_CTRL_RESET;
+	musb_ulpi_writeb(addr, ISP1704_FUNC_CTRL, r);
+	msleep(1);
+
+	/* Set normal mode */
+	r &= ~(ISP1704_FUNC_CTRL_RESET | (3 << ISP1704_FUNC_CTRL_OPMODE));
+	musb_ulpi_writeb(addr, ISP1704_FUNC_CTRL, r);
+
+	/* Clear the DP and DM pull-down bits */
+	r = musb_ulpi_readb(addr, ISP1704_OTG_CTRL);
+	r &= ~(ISP1704_OTG_CTRL_DP_PULLDOWN | ISP1704_OTG_CTRL_DM_PULLDOWN);
+	musb_ulpi_writeb(addr, ISP1704_OTG_CTRL, r);
+
+	/* Enable strong pull-up on DP (1.5K) and reset */
+	r = musb_ulpi_readb(addr, ISP1704_FUNC_CTRL);
+	r |= ISP1704_FUNC_CTRL_TERMSELECT | ISP1704_FUNC_CTRL_RESET;
+	musb_ulpi_writeb(addr, ISP1704_FUNC_CTRL, r);
+	msleep(1);
+
+	/* Read the line state */
+	if (musb_ulpi_readb(addr, ISP1704_DEBUG)) {
+		/* Is it a charger or PS2 connection */
+
+		/* Enable weak pull-up resistor on DP */
+		r = musb_ulpi_readb(addr, ISP1704_PWR_CTRL);
+		r |= ISP1704_PWR_CTRL_DP_WKPU_EN;
+		musb_ulpi_writeb(addr, ISP1704_PWR_CTRL, r);
+
+		/* Disable strong pull-up on DP (1.5K) */
+		r = musb_ulpi_readb(addr, ISP1704_FUNC_CTRL);
+		r &= ~ISP1704_FUNC_CTRL_TERMSELECT;
+		musb_ulpi_writeb(addr, ISP1704_FUNC_CTRL, r);
+
+		/* Enable weak pull-down resistor on DM */
+		r = musb_ulpi_readb(addr, ISP1704_OTG_CTRL);
+		r |= ISP1704_OTG_CTRL_DM_PULLDOWN;
+		musb_ulpi_writeb(addr, ISP1704_OTG_CTRL, r);
+
+		/* It's a charger if the line states are clear */
+		if (!(musb_ulpi_readb(addr, ISP1704_DEBUG)))
+			ret = 1;
+
+		/* Disable weak pull-up resistor on DP */
+		r = musb_ulpi_readb(addr, ISP1704_PWR_CTRL);
+		r &= ~ISP1704_PWR_CTRL_DP_WKPU_EN;
+		musb_ulpi_writeb(addr, ISP1704_PWR_CTRL, r);
+	} else {
+		ret = 1;
+
+		/* Disable strong pull-up on DP (1.5K) */
+		r = musb_ulpi_readb(addr, ISP1704_FUNC_CTRL);
+		r &= ~ISP1704_FUNC_CTRL_TERMSELECT;
+		musb_ulpi_writeb(addr, ISP1704_FUNC_CTRL, r);
+	}
+
+	return ret;
+}
+
+/* Bad connections with the charger may lead into the transceiver
+ * thinking that a device was just connected. We can wait for 5 ms to
+ * ensure that these cases will generate SUSPEND interrupt and not
+ * RESET. Reading and writing to the transceiver may still cause
+ * RESET interrupts. We mask out RESET/RESUME interrupts to
+ * recover from this.
+ */
+static int check_charger;
 static int musb_charger_detect(struct musb *musb)
 {
+	unsigned long	timeout;
+
 	u8              vdat = 0;
 	u8              r;
 
+	msleep(5);
+
 	/* Using ulpi with musb is quite tricky. The following code
 	 * was written based on the ulpi application note.
 	 *
@@ -156,29 +232,82 @@ static int musb_charger_detect(struct mu
 
 	switch(musb->xceiv->state) {
 		case OTG_STATE_B_IDLE:
-			r = musb_ulpi_readb(musb->mregs, ISP1704_PWR_CTRL);
+			/* we always reset transceiver */
+			check_charger = 1;
+
+			/* disable RESET and RESUME interrupts */
+			r = musb_readb(musb->mregs, MUSB_INTRUSBE);
+			r &= ~(MUSB_INTR_RESUME | MUSB_INTR_RESET);
+			musb_writeb(musb->mregs, MUSB_INTRUSBE, r);
+
+			if (musb->board && musb->board->xceiv_reset)
+				musb->board->xceiv_reset();
+
+			/* then we resume to sync with controller */
+			r = musb_readb(musb->mregs, MUSB_POWER);
+			musb_writeb(musb->mregs, MUSB_POWER,
+					r | MUSB_POWER_RESUME);
+			msleep(10);
+			musb_writeb(musb->mregs, MUSB_POWER,
+					r & ~MUSB_POWER_RESUME);
+
+			/* now we set SW control bit in PWR_CTRL register */
+			musb_ulpi_writeb(musb->mregs, ISP1704_PWR_CTRL,
+					ISP1704_PWR_CTRL_SWCTRL);
 
+			r = musb_ulpi_readb(musb->mregs, ISP1704_PWR_CTRL);
 			r |= (ISP1704_PWR_CTRL_SWCTRL | ISP1704_PWR_CTRL_DPVSRC_EN);
 
-			/* Enable manual charger detection */
+			/* and finally enable manual charger detection */
 			musb_ulpi_writeb(musb->mregs, ISP1704_PWR_CTRL, r);
 			msleep(10);
 
-			/* Check if there is a charger */
-			if ((musb_ulpi_readb(musb->mregs, ISP1704_PWR_CTRL)
-						& ISP1704_PWR_CTRL_VDAT_DET))
-				vdat = 1;
+			timeout = jiffies + msecs_to_jiffies(300);
+			while (!time_after(jiffies, timeout)) {
+				/* Check if there is a charger */
+				vdat = !!(musb_ulpi_readb(musb->mregs, ISP1704_PWR_CTRL)
+							& ISP1704_PWR_CTRL_VDAT_DET);
+				if (vdat)
+					break;
+			}
+			if (vdat)
+				vdat = musb_verify_charger(musb->mregs);
 
 			r &= ~ISP1704_PWR_CTRL_DPVSRC_EN;
 
 			/* Clear DPVSRC_EN, otherwise usb communication doesn't work */
 			musb_ulpi_writeb(musb->mregs, ISP1704_PWR_CTRL, r);
 			break;
+
 		default:
 			vdat = 0;
 			break;
 	}
 
+	if (vdat) {
+		/* REVISIT: This code works only with dedicated chargers!
+		 * When support for HOST/HUB chargers is added, don't
+		 * forget this.
+		 */
+		musb_stop(musb);
+		/* Regulators off */
+		otg_set_suspend(musb->xceiv, 1);
+		musb->is_charger = 1;
+	} else {
+		/* enable interrupts */
+		musb_writeb(musb->mregs, MUSB_INTRUSBE, ctx.intrusbe);
+
+		/* Make sure the communication starts normally */
+		r = musb_readb(musb->mregs, MUSB_POWER);
+		musb_writeb(musb->mregs, MUSB_POWER,
+				r | MUSB_POWER_RESUME);
+		msleep(10);
+		musb_writeb(musb->mregs, MUSB_POWER,
+				r & ~MUSB_POWER_RESUME);
+	}
+
+	check_charger = 0;
+
 	return vdat;
 }
 
@@ -427,15 +556,12 @@ void musb_hnp_stop(struct musb *musb)
  * @param power
  */
 
-#define STAGE0_MASK (MUSB_INTR_RESUME | MUSB_INTR_SESSREQ \
-		| MUSB_INTR_VBUSERROR | MUSB_INTR_CONNECT \
-		| MUSB_INTR_RESET)
-
 static irqreturn_t musb_stage0_irq(struct musb *musb, u8 int_usb,
 				u8 devctl, u8 power)
 {
 	irqreturn_t handled = IRQ_NONE;
 	void __iomem *mbase = musb->mregs;
+	u8 r;
 
 	DBG(3, "<== Power=%02x, DevCtl=%02x, int_usb=0x%x\n", power, devctl,
 		int_usb);
@@ -535,12 +661,19 @@ static irqreturn_t musb_stage0_irq(struc
 		 *  - go through A_WAIT_VRISE
 		 *  - ... to A_WAIT_BCON.
 		 * a_wait_vrise_tmout triggers VBUS_ERROR transitions
+		 * NOTE : Spurious SESS_REQ int's detected, which should
+		 * be discarded silently.
 		 */
-		musb_writeb(mbase, MUSB_DEVCTL, MUSB_DEVCTL_SESSION);
-		musb->ep0_stage = MUSB_EP0_START;
-		musb->xceiv->state = OTG_STATE_A_IDLE;
-		MUSB_HST_MODE(musb);
-		musb_set_vbus(musb, 1);
+		if ((devctl & MUSB_DEVCTL_VBUS)
+		    && !(devctl & MUSB_DEVCTL_BDEVICE)) {
+			musb_writeb(mbase, MUSB_DEVCTL, MUSB_DEVCTL_SESSION);
+			musb->ep0_stage = MUSB_EP0_START;
+			musb->xceiv->state = OTG_STATE_A_IDLE;
+			MUSB_HST_MODE(musb);
+			musb_set_vbus(musb, 1);
+		} else {
+			DBG(5,"discarding SESSREQ INT: VBUS < SessEnd\n");
+		}
 
 		handled = IRQ_HANDLED;
 	}
@@ -613,6 +746,58 @@ static irqreturn_t musb_stage0_irq(struc
 		handled = IRQ_HANDLED;
 	}
 
+	if (int_usb & MUSB_INTR_SUSPEND) {
+		DBG(1, "SUSPEND (%s) devctl %02x power %02x\n",
+				otg_state_string(musb), devctl, power);
+		handled = IRQ_HANDLED;
+
+		switch (musb->xceiv->state) {
+#ifdef	CONFIG_USB_MUSB_OTG
+		case OTG_STATE_A_PERIPHERAL:
+			/*
+			 * We cannot stop HNP here, devctl BDEVICE might be
+			 * still set.
+			 */
+			break;
+#endif
+		case OTG_STATE_B_IDLE:
+			if (!musb->is_active)
+				break;
+		case OTG_STATE_B_PERIPHERAL:
+			musb_g_suspend(musb);
+			musb->is_active = is_otg_enabled(musb)
+					&& musb->xceiv->gadget->b_hnp_enable;
+			if (musb->is_active) {
+#ifdef	CONFIG_USB_MUSB_OTG
+				musb->xceiv->state = OTG_STATE_B_WAIT_ACON;
+				DBG(1, "HNP: Setting timer for b_ase0_brst\n");
+				musb_otg_timer.data = (unsigned long)musb;
+				mod_timer(&musb_otg_timer, jiffies
+					+ msecs_to_jiffies(TB_ASE0_BRST));
+#endif
+			}
+			break;
+		case OTG_STATE_A_WAIT_BCON:
+			if (musb->a_wait_bcon != 0)
+				musb_platform_try_idle(musb, jiffies
+					+ msecs_to_jiffies(musb->a_wait_bcon));
+			break;
+		case OTG_STATE_A_HOST:
+			musb->xceiv->state = OTG_STATE_A_SUSPEND;
+			musb->is_active = is_otg_enabled(musb)
+					&& musb->xceiv->host->b_hnp_enable;
+			break;
+		case OTG_STATE_B_HOST:
+			/* Transition to B_PERIPHERAL, see 6.8.2.6 p 44 */
+			DBG(1, "REVISIT: SUSPEND as B_HOST\n");
+			break;
+		default:
+			/* "should not happen" */
+			musb->is_active = 0;
+			break;
+		}
+	}
+
 	if (int_usb & MUSB_INTR_CONNECT) {
 		struct usb_hcd *hcd = musb_to_hcd(musb);
 
@@ -678,10 +863,78 @@ static irqreturn_t musb_stage0_irq(struc
 	}
 #endif	/* CONFIG_USB_MUSB_HDRC_HCD */
 
+	if ((int_usb & MUSB_INTR_DISCONNECT) && !musb->ignore_disconnect) {
+		DBG(1, "DISCONNECT (%s) as %s, devctl %02x\n",
+				otg_state_string(musb),
+				MUSB_MODE(musb), devctl);
+		handled = IRQ_HANDLED;
+
+		switch (musb->xceiv->state) {
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+		case OTG_STATE_A_HOST:
+		case OTG_STATE_A_SUSPEND:
+			usb_hcd_resume_root_hub(musb_to_hcd(musb));
+			musb_root_disconnect(musb);
+			if (musb->a_wait_bcon != 0 && is_otg_enabled(musb))
+				musb_platform_try_idle(musb, jiffies
+					+ msecs_to_jiffies(musb->a_wait_bcon));
+			break;
+#endif	/* HOST */
+#ifdef CONFIG_USB_MUSB_OTG
+		case OTG_STATE_B_HOST:
+			musb_hnp_stop(musb);
+			break;
+		case OTG_STATE_A_PERIPHERAL:
+			musb_hnp_stop(musb);
+			musb_root_disconnect(musb);
+			/* FALLTHROUGH */
+		case OTG_STATE_B_WAIT_ACON:
+			/* FALLTHROUGH */
+#endif	/* OTG */
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+		case OTG_STATE_B_PERIPHERAL:
+		case OTG_STATE_B_IDLE:
+			/* Workaround for a problem of Vbus quickly dropping
+			 * during Certification tests.
+			 *
+			 * Undo the workaround on disconnect
+			 */
+
+			/* Disable suspend so we can write to ULPI */
+			r = musb_readb(musb->mregs, MUSB_POWER);
+			musb_writeb(musb->mregs, MUSB_POWER,
+						r & ~MUSB_POWER_ENSUSPEND);
+			musb_ulpi_writeb(musb->mregs,
+						ISP1704_USB_INTFALL, 0x1f);
+			musb_ulpi_writeb(musb->mregs,
+						ISP1704_USB_INTRISE, 0x1f);
+			musb_writeb(musb->mregs, MUSB_POWER,
+						r | MUSB_POWER_ENSUSPEND);
+
+			musb_g_disconnect(musb);
+			/** UGLY UGLY HACK: Windows problems with multiple
+			 * configurations.
+			 *
+			 * This is necessary to notify gadget driver this was
+			 * a physical disconnection and not only a port reset.
+			 */
+			if (musb->gadget_driver->vbus_disconnect)
+				musb->gadget_driver->vbus_disconnect(&musb->g);
+
+			break;
+#endif	/* GADGET */
+		default:
+			WARNING("unhandled DISCONNECT transition (%s)\n",
+				otg_state_string(musb));
+			break;
+		}
+	}
+
 	/* mentor saves a bit: bus reset and babble share the same irq.
 	 * only host sees babble; only peripheral sees bus reset.
 	 */
 	if (int_usb & MUSB_INTR_RESET) {
+		handled = IRQ_HANDLED;
 		if (is_host_capable() && (devctl & MUSB_DEVCTL_HM) != 0) {
 			/*
 			 * Looks like non-HS BABBLE can be ignored, but
@@ -694,7 +947,7 @@ static irqreturn_t musb_stage0_irq(struc
 				DBG(1, "BABBLE devctl: %02x\n", devctl);
 			else {
 				ERR("Stopping host session -- babble\n");
-				musb_writeb(mbase, MUSB_DEVCTL, 0);
+				musb_writeb(musb->mregs, MUSB_DEVCTL, 0);
 			}
 		} else if (is_peripheral_capable()) {
 			DBG(1, "BUS RESET as %s\n", otg_state_string(musb));
@@ -726,9 +979,30 @@ static irqreturn_t musb_stage0_irq(struc
 				break;
 #endif
 			case OTG_STATE_B_IDLE:
+				/* Workaround the charger detection problems */
+				if ((devctl & MUSB_DEVCTL_VBUS)
+					!= (3 << MUSB_DEVCTL_VBUS_SHIFT))
+					break;
+				if (check_charger)
+					break;
 				musb->xceiv->state = OTG_STATE_B_PERIPHERAL;
 				/* FALLTHROUGH */
 			case OTG_STATE_B_PERIPHERAL:
+			/* Workaround for a problem of Vbus quickly dropping
+			 * during Certification tests.
+			 *
+			 * The guess is that vbus drops due to the circuitry
+			 * for overcurrent protection and that makes transceiver
+			 * think VBUS is not valid anymore. Transceiver will
+			 * then send an RXCMD to PHY which will cause it to
+			 * disconnect from the bus even though we disable the
+			 * DISCONNECT IRQ
+			 */
+				musb_ulpi_writeb(musb->mregs,
+						 ISP1704_USB_INTFALL, 0x1d);
+				musb_ulpi_writeb(musb->mregs,
+						 ISP1704_USB_INTRISE, 0x1d);
+
 				musb_g_reset(musb);
 				break;
 			default:
@@ -736,29 +1010,7 @@ static irqreturn_t musb_stage0_irq(struc
 					otg_state_string(musb));
 			}
 		}
-
-		handled = IRQ_HANDLED;
 	}
-	schedule_work(&musb->irq_work);
-
-	return handled;
-}
-
-/*
- * Interrupt Service Routine to record USB "global" interrupts.
- * Since these do not happen often and signify things of
- * paramount importance, it seems OK to check them individually;
- * the order of the tests is specified in the manual
- *
- * @param musb instance pointer
- * @param int_usb register contents
- * @param devctl
- * @param power
- */
-static irqreturn_t musb_stage2_irq(struct musb *musb, u8 int_usb,
-				u8 devctl, u8 power)
-{
-	irqreturn_t handled = IRQ_NONE;
 
 #if 0
 /* REVISIT ... this would be for multiplexing periodic endpoints, or
@@ -805,99 +1057,7 @@ static irqreturn_t musb_stage2_irq(struc
 	}
 #endif
 
-	if ((int_usb & MUSB_INTR_DISCONNECT) && !musb->ignore_disconnect) {
-		DBG(1, "DISCONNECT (%s) as %s, devctl %02x\n",
-				otg_state_string(musb),
-				MUSB_MODE(musb), devctl);
-		handled = IRQ_HANDLED;
-
-		switch (musb->xceiv->state) {
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-		case OTG_STATE_A_HOST:
-		case OTG_STATE_A_SUSPEND:
-			usb_hcd_resume_root_hub(musb_to_hcd(musb));
-			musb_root_disconnect(musb);
-			if (musb->a_wait_bcon != 0 && is_otg_enabled(musb))
-				musb_platform_try_idle(musb, jiffies
-					+ msecs_to_jiffies(musb->a_wait_bcon));
-			break;
-#endif	/* HOST */
-#ifdef CONFIG_USB_MUSB_OTG
-		case OTG_STATE_B_HOST:
-			musb_hnp_stop(musb);
-			break;
-		case OTG_STATE_A_PERIPHERAL:
-			musb_hnp_stop(musb);
-			musb_root_disconnect(musb);
-			/* FALLTHROUGH */
-		case OTG_STATE_B_WAIT_ACON:
-			/* FALLTHROUGH */
-#endif	/* OTG */
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
-		case OTG_STATE_B_PERIPHERAL:
-		case OTG_STATE_B_IDLE:
-			musb_g_disconnect(musb);
-			break;
-#endif	/* GADGET */
-		default:
-			WARNING("unhandled DISCONNECT transition (%s)\n",
-				otg_state_string(musb));
-			break;
-		}
-
-		schedule_work(&musb->irq_work);
-	}
-
-	if (int_usb & MUSB_INTR_SUSPEND) {
-		DBG(1, "SUSPEND (%s) devctl %02x power %02x\n",
-				otg_state_string(musb), devctl, power);
-		handled = IRQ_HANDLED;
-
-		switch (musb->xceiv->state) {
-#ifdef	CONFIG_USB_MUSB_OTG
-		case OTG_STATE_A_PERIPHERAL:
-			/*
-			 * We cannot stop HNP here, devctl BDEVICE might be
-			 * still set.
-			 */
-			break;
-#endif
-		case OTG_STATE_B_PERIPHERAL:
-			musb_g_suspend(musb);
-			musb->is_active = is_otg_enabled(musb)
-					&& musb->xceiv->gadget->b_hnp_enable;
-			if (musb->is_active) {
-#ifdef	CONFIG_USB_MUSB_OTG
-				musb->xceiv->state = OTG_STATE_B_WAIT_ACON;
-				DBG(1, "HNP: Setting timer for b_ase0_brst\n");
-				musb_otg_timer.data = (unsigned long)musb;
-				mod_timer(&musb_otg_timer, jiffies
-					+ msecs_to_jiffies(TB_ASE0_BRST));
-#endif
-			}
-			break;
-		case OTG_STATE_A_WAIT_BCON:
-			if (musb->a_wait_bcon != 0)
-				musb_platform_try_idle(musb, jiffies
-					+ msecs_to_jiffies(musb->a_wait_bcon));
-			break;
-		case OTG_STATE_A_HOST:
-			musb->xceiv->state = OTG_STATE_A_SUSPEND;
-			musb->is_active = is_otg_enabled(musb)
-					&& musb->xceiv->host->b_hnp_enable;
-			break;
-		case OTG_STATE_B_HOST:
-			/* Transition to B_PERIPHERAL, see 6.8.2.6 p 44 */
-			DBG(1, "REVISIT: SUSPEND as B_HOST\n");
-			break;
-		default:
-			/* "should not happen" */
-			musb->is_active = 0;
-			break;
-		}
-		schedule_work(&musb->irq_work);
-	}
-
+	schedule_work(&musb->irq_work);
 
 	return handled;
 }
@@ -915,6 +1075,12 @@ void musb_start(struct musb *musb)
 
 	DBG(2, "<== devctl %02x\n", devctl);
 
+	/* Ensure the clocks are on */
+	if (musb->set_clock)
+		musb->set_clock(musb->clock, 1);
+	else
+		clk_enable(musb->clock);
+
 	/*  Set INT enable registers, enable interrupts */
 	musb_writew(regs, MUSB_INTRTXE, musb->epmask);
 	musb_writew(regs, MUSB_INTRRXE, musb->epmask & 0xfffe);
@@ -965,6 +1131,12 @@ static void musb_generic_disable(struct
 	void __iomem	*mbase = musb->mregs;
 	u16	temp;
 
+	/* Clocks need to be turned on with OFF-mode */
+	if (musb->set_clock)
+		musb->set_clock(musb->clock, 1);
+	else
+		clk_enable(musb->clock);
+
 	/* disable interrupts */
 	musb_writeb(mbase, MUSB_INTRUSBE, 0);
 	musb_writew(mbase, MUSB_INTRTXE, 0);
@@ -1143,35 +1315,39 @@ static struct fifo_cfg __initdata mode_4
 /* mode 5 - fits in 16KB */
 static struct fifo_cfg __initdata mode_5_cfg[] = {
 /* phonet or mass storage */
-{ .hw_ep_num =  1, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num =  1, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
+{ .hw_ep_num =  1, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_SINGLE, },
+{ .hw_ep_num =  1, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_SINGLE, },
 
 /* obex 1 */
-{ .hw_ep_num =  2, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num =  2, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
+{ .hw_ep_num =  2, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_SINGLE, },
+{ .hw_ep_num =  2, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_SINGLE, },
 
 /* obex 2 */
-{ .hw_ep_num =  3, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num =  3, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-
-/* obex 3 */
-{ .hw_ep_num =  4, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num =  4, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
+{ .hw_ep_num =  3, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_SINGLE, },
+{ .hw_ep_num =  3, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_SINGLE, },
 
 /* acm 1 */
-{ .hw_ep_num =  5, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num =  5, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num =  6, .style = FIFO_TX,   .maxpacket = 16, },
-
-/* acm 2 */
-{ .hw_ep_num =  7, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num =  6, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num =  8, .style = FIFO_TX,   .maxpacket = 16, },
+{ .hw_ep_num =  4, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_SINGLE, },
+{ .hw_ep_num =  4, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_SINGLE, },
+{ .hw_ep_num =  5, .style = FIFO_TX,   .maxpacket = 16, },
 
 /* ecm */
-{ .hw_ep_num =  9, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num =  7, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num =  10, .style = FIFO_TX,   .maxpacket = 16, },
+{ .hw_ep_num =  6, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_SINGLE, },
+{ .hw_ep_num =  5, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_SINGLE, },
+{ .hw_ep_num =  7, .style = FIFO_TX,   .maxpacket = 16, },
+
+/* extras */
+{ .hw_ep_num =  8, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num =  6, .style = FIFO_RX,   .maxpacket = 512, },
+
+{ .hw_ep_num =  9, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num =  7, .style = FIFO_RX,   .maxpacket = 512, },
+
+{ .hw_ep_num =  10, .style = FIFO_TX,  .maxpacket = 512, },
+{ .hw_ep_num =  8, .style = FIFO_RX,   .maxpacket = 512, },
+
+{ .hw_ep_num =  11, .style = FIFO_TX,  .maxpacket = 512, },
+{ .hw_ep_num =  9, .style = FIFO_RX,   .maxpacket = 512, },
 };
 
 /*
@@ -1223,12 +1399,16 @@ fifo_setup(struct musb *musb, struct mus
 		musb_write_txfifoadd(mbase, c_off);
 		hw_ep->tx_double_buffered = !!(c_size & MUSB_FIFOSZ_DPB);
 		hw_ep->max_packet_sz_tx = maxpacket;
+		ctx.txfifosz[hw_ep->epnum] = c_size;
+		ctx.txfifoadd[hw_ep->epnum] = c_off;
 		break;
 	case FIFO_RX:
 		musb_write_rxfifosz(mbase, c_size);
 		musb_write_rxfifoadd(mbase, c_off);
 		hw_ep->rx_double_buffered = !!(c_size & MUSB_FIFOSZ_DPB);
 		hw_ep->max_packet_sz_rx = maxpacket;
+		ctx.rxfifosz[hw_ep->epnum] = c_size;
+		ctx.rxfifoadd[hw_ep->epnum] = c_off;
 		break;
 	case FIFO_RXTX:
 		musb_write_txfifosz(mbase, c_size);
@@ -1241,6 +1421,12 @@ fifo_setup(struct musb *musb, struct mus
 		hw_ep->tx_double_buffered = hw_ep->rx_double_buffered;
 		hw_ep->max_packet_sz_tx = maxpacket;
 
+		/* Save the context of endpoints. */
+		ctx.rxfifosz[hw_ep->epnum] = c_size;
+		ctx.txfifosz[hw_ep->epnum] = c_size;
+		ctx.txfifoadd[hw_ep->epnum] = c_off;
+		ctx.rxfifoadd[hw_ep->epnum] = c_off;
+
 		hw_ep->is_shared_fifo = true;
 		break;
 	}
@@ -1579,8 +1765,8 @@ static irqreturn_t generic_interrupt(int
 	musb->int_tx = musb_readw(musb->mregs, MUSB_INTRTX);
 	musb->int_rx = musb_readw(musb->mregs, MUSB_INTRRX);
 
-	if (musb->int_usb || musb->int_tx || musb->int_rx)
-		retval = musb_interrupt(musb);
+	while (musb->int_usb || musb->int_tx || musb->int_rx)
+		retval |= musb_interrupt(musb);
 
 	spin_unlock_irqrestore(&musb->lock, flags);
 
@@ -1607,7 +1793,7 @@ static irqreturn_t generic_interrupt(int
 irqreturn_t musb_interrupt(struct musb *musb)
 {
 	irqreturn_t	retval = IRQ_NONE;
-	u8		devctl, power;
+	u8		devctl, power, int_usb;
 	int		ep_num;
 	u32		reg;
 
@@ -1618,75 +1804,80 @@ irqreturn_t musb_interrupt(struct musb *
 		(devctl & MUSB_DEVCTL_HM) ? "host" : "peripheral",
 		musb->int_usb, musb->int_tx, musb->int_rx);
 
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
 	if (is_otg_enabled(musb)|| is_peripheral_enabled(musb))
 		if (!musb->gadget_driver) {
 			DBG(5, "No gadget driver loaded\n");
+			musb->int_usb = 0;
+			musb->int_tx = 0;
+			musb->int_rx = 0;
 			return IRQ_HANDLED;
 		}
+#endif
 
 	/* the core can interrupt us for multiple reasons; docs have
 	 * a generic interrupt flowchart to follow
 	 */
-	if (musb->int_usb & STAGE0_MASK)
-		retval |= musb_stage0_irq(musb, musb->int_usb,
-				devctl, power);
+	int_usb = musb->int_usb;
+	musb->int_usb = 0;
+	int_usb &= ~MUSB_INTR_SOF;
+	if (int_usb)
+		retval |= musb_stage0_irq(musb, int_usb, devctl, power);
 
 	/* "stage 1" is handling endpoint irqs */
 
 	/* handle endpoint 0 first */
 	if (musb->int_tx & 1) {
+		musb->int_tx &= ~1;
 		if (devctl & MUSB_DEVCTL_HM)
 			retval |= musb_h_ep0_irq(musb);
 		else
 			retval |= musb_g_ep0_irq(musb);
 	}
 
-	/* RX on endpoints 1-15 */
-	reg = musb->int_rx >> 1;
+	/* TX on endpoints 1-15 */
+	reg = musb->int_tx >> 1;
+	musb->int_tx = 0;
 	ep_num = 1;
 	while (reg) {
 		if (reg & 1) {
 			/* musb_ep_select(musb->mregs, ep_num); */
-			/* REVISIT just retval = ep->rx_irq(...) */
+			/* REVISIT just retval |= ep->tx_irq(...) */
 			retval = IRQ_HANDLED;
 			if (devctl & MUSB_DEVCTL_HM) {
 				if (is_host_capable())
-					musb_host_rx(musb, ep_num);
+					musb_host_tx(musb, ep_num);
 			} else {
 				if (is_peripheral_capable())
-					musb_g_rx(musb, ep_num);
+					musb_g_tx(musb, ep_num);
 			}
 		}
-
 		reg >>= 1;
 		ep_num++;
 	}
 
-	/* TX on endpoints 1-15 */
-	reg = musb->int_tx >> 1;
+	/* RX on endpoints 1-15 */
+	reg = musb->int_rx >> 1;
+	musb->int_rx = 0;
 	ep_num = 1;
 	while (reg) {
 		if (reg & 1) {
 			/* musb_ep_select(musb->mregs, ep_num); */
-			/* REVISIT just retval |= ep->tx_irq(...) */
+			/* REVISIT just retval = ep->rx_irq(...) */
 			retval = IRQ_HANDLED;
 			if (devctl & MUSB_DEVCTL_HM) {
 				if (is_host_capable())
-					musb_host_tx(musb, ep_num);
+					musb_host_rx(musb, ep_num);
 			} else {
 				if (is_peripheral_capable())
-					musb_g_tx(musb, ep_num);
+					musb_g_rx(musb, ep_num, false);
 			}
 		}
+
 		reg >>= 1;
 		ep_num++;
 	}
 
-	/* finish handling "global" interrupts after handling fifos */
-	if (musb->int_usb)
-		retval |= musb_stage2_irq(musb,
-				musb->int_usb, devctl, power);
-
 	return retval;
 }
 
@@ -1725,7 +1916,7 @@ void musb_dma_completion(struct musb *mu
 					musb_host_rx(musb, epnum);
 			} else {
 				if (is_peripheral_capable())
-					musb_g_rx(musb, epnum);
+					musb_g_rx(musb, epnum, true);
 			}
 		}
 	}
@@ -1741,7 +1932,8 @@ musb_charger_show(struct device *dev, st
 {
 	struct musb *musb = dev_to_musb(dev);
 
-	return sprintf(buf, "%d\n", musb_charger_detect(musb));
+	return sprintf(buf, "%d\n", (musb->is_charger ?
+			musb->is_charger : musb_charger_detect(musb)));
 }
 static DEVICE_ATTR(charger, 0444, musb_charger_show, NULL);
 
@@ -1768,6 +1960,54 @@ musb_mode_show(struct device *dev, struc
 }
 
 static ssize_t
+musb_connect_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct musb	*musb = dev_to_musb(dev);
+	unsigned long	flags;
+	int		ret = -EINVAL;
+
+	spin_lock_irqsave(&musb->lock, flags);
+	ret = sprintf(buf, "%d\n", musb->softconnect);
+	spin_unlock_irqrestore(&musb->lock, flags);
+
+	return ret;
+}
+
+static ssize_t
+musb_connect_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t n)
+{
+	struct musb	*musb = dev_to_musb(dev);
+	unsigned long	flags;
+	unsigned	val;
+	int		status;
+	u8		power;
+
+	status = sscanf(buf, "%u", &val);
+	if (status < 1) {
+		printk(KERN_ERR "invalid parameter, %d\n", status);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&musb->lock, flags);
+
+	power = musb_readb(musb->mregs, MUSB_POWER);
+
+	if (val)
+		power |= MUSB_POWER_SOFTCONN;
+	else
+		power &= ~MUSB_POWER_SOFTCONN;
+
+	musb->softconnect = !!val;
+	musb_writeb(musb->mregs, MUSB_POWER, power);
+
+	spin_unlock_irqrestore(&musb->lock, flags);
+
+	return n;
+}
+static DEVICE_ATTR(connect, 0644, musb_connect_show, musb_connect_store);
+
+static ssize_t
 musb_mode_store(struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t n)
 {
@@ -1830,6 +2070,8 @@ musb_vbus_show(struct device *dev, struc
 }
 static DEVICE_ATTR(vbus, 0644, musb_vbus_show, musb_vbus_store);
 
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+
 static ssize_t
 musb_suspend_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
@@ -1839,8 +2081,6 @@ musb_suspend_show(struct device *dev, st
 }
 static DEVICE_ATTR(suspend, 0444, musb_suspend_show, NULL);
 
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
-
 /* Gadget drivers can't know that a host is connected so they might want
  * to start SRP, but users can.  This allows userspace to trigger SRP.
  */
@@ -1872,19 +2112,33 @@ static DEVICE_ATTR(srp, 0644, NULL, musb
 static void musb_irq_work(struct work_struct *data)
 {
 	struct musb *musb = container_of(data, struct musb, irq_work);
-	static int old_state, old_ma;
+	static int old_state, old_ma, old_suspend;
+	u8 devctl;
 
 	if (musb->xceiv->state != old_state) {
+		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+		if (musb->xceiv->state == OTG_STATE_B_IDLE &&
+					(devctl & MUSB_DEVCTL_VBUS))
+			goto keep_limit;
+
+		/* clear/set requirements for musb to work with DPS on omap3 */
+		if (musb->board && musb->board->set_pm_limits)
+			musb->board->set_pm_limits(musb->controller,
+				(musb->xceiv->state == OTG_STATE_B_PERIPHERAL));
+keep_limit:
 		old_state = musb->xceiv->state;
 		sysfs_notify(&musb->controller->kobj, NULL, "mode");
 	}
 	if (musb->power_draw != old_ma) {
 		old_ma = musb->power_draw;
-		if (musb->power_draw > 8)
-			sysfs_notify(&musb->controller->kobj, NULL, "mA");
+		sysfs_notify(&musb->controller->kobj, NULL, "mA");
 	}
-	if (musb->is_suspended)
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+	if (old_suspend != musb->is_suspended) {
+		old_suspend = musb->is_suspended;
 		sysfs_notify(&musb->controller->kobj, NULL, "suspend");
+	}
+#endif
 }
 
 /* --------------------------------------------------------------------------
@@ -1944,11 +2198,12 @@ static void musb_free(struct musb *musb)
 
 #ifdef CONFIG_SYSFS
 	device_remove_file(musb->controller, &dev_attr_mA);
+	device_remove_file(musb->controller, &dev_attr_connect);
 	device_remove_file(musb->controller, &dev_attr_charger);
 	device_remove_file(musb->controller, &dev_attr_mode);
 	device_remove_file(musb->controller, &dev_attr_vbus);
-	device_remove_file(musb->controller, &dev_attr_suspend);
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
+	device_remove_file(musb->controller, &dev_attr_suspend);
 	device_remove_file(musb->controller, &dev_attr_srp);
 #endif
 #endif
@@ -2044,6 +2299,7 @@ bad_config:
 
 	spin_lock_init(&musb->lock);
 	mutex_init(&musb->mutex);
+	musb->board = plat->board;
 	musb->board_mode = plat->mode;
 	musb->board_set_power = plat->set_power;
 	musb->set_clock = plat->set_clock;
@@ -2188,11 +2444,12 @@ bad_config:
 
 #ifdef CONFIG_SYSFS
 	status = device_create_file(dev, &dev_attr_mA);
+	status = device_create_file(dev, &dev_attr_connect);
 	status = device_create_file(dev, &dev_attr_charger);
 	status = device_create_file(dev, &dev_attr_mode);
 	status = device_create_file(dev, &dev_attr_vbus);
-	status = device_create_file(dev, &dev_attr_suspend);
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
+	status = device_create_file(dev, &dev_attr_suspend);
 	status = device_create_file(dev, &dev_attr_srp);
 #endif /* CONFIG_USB_GADGET_MUSB_HDRC */
 	status = 0;
@@ -2205,11 +2462,12 @@ bad_config:
 fail2:
 #ifdef CONFIG_SYSFS
 	device_remove_file(dev, &dev_attr_mA);
+	device_remove_file(dev, &dev_attr_connect);
 	device_remove_file(dev, &dev_attr_charger);
 	device_remove_file(musb->controller, &dev_attr_mode);
 	device_remove_file(musb->controller, &dev_attr_vbus);
-	device_remove_file(musb->controller, &dev_attr_suspend);
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
+	device_remove_file(musb->controller, &dev_attr_suspend);
 	device_remove_file(musb->controller, &dev_attr_srp);
 #endif
 #endif
@@ -2258,6 +2516,9 @@ static int __init musb_probe(struct plat
 	/* clobbered by use_dma=n */
 	orig_dma_mask = dev->dma_mask;
 #endif
+	/* Store initial mask for USB interrupts */
+	ctx.intrusbe = 0xf7;
+
 	return musb_init_controller(dev, irq, base);
 }
 
@@ -2288,28 +2549,35 @@ static int __devexit musb_remove(struct
 
 #ifdef	CONFIG_PM
 
-static void musb_save_ctx(struct musb *musb)
+void musb_save_ctx(struct musb *musb)
 {
 	ctx.power = musb_readb(musb->mregs, MUSB_POWER);
-	ctx.intrtx = musb_readw(musb->mregs, MUSB_INTRTX);
 	ctx.intrtxe = musb_readw(musb->mregs, MUSB_INTRTXE);
-	ctx.intrrx = musb_readw(musb->mregs, MUSB_INTRRX);
 	ctx.intrrxe = musb_readw(musb->mregs, MUSB_INTRRXE);
-	ctx.intrusb = musb_readb(musb->mregs, MUSB_INTRUSB);
 	ctx.intrusbe = musb_readb(musb->mregs, MUSB_INTRUSBE);
 	ctx.devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 }
 
-static void musb_restore_ctx(struct musb *musb)
+void musb_restore_ctx(struct musb *musb)
 {
+	int i;
 	musb_writeb(musb->mregs, MUSB_POWER, ctx.power);
-	musb_writew(musb->mregs, MUSB_INTRTX, ctx.intrtx);
+	musb_writew(musb->mregs, MUSB_INTRTX, 0x00);
 	musb_writew(musb->mregs, MUSB_INTRTXE, ctx.intrtxe);
-	musb_writew(musb->mregs, MUSB_INTRRX, ctx.intrrx);
+	musb_writew(musb->mregs, MUSB_INTRRX, 0x00);
 	musb_writew(musb->mregs, MUSB_INTRRXE, ctx.intrrxe);
-	musb_writeb(musb->mregs, MUSB_INTRUSB, ctx.intrusb);
+	musb_writeb(musb->mregs, MUSB_INTRUSB, 0x00);
 	musb_writeb(musb->mregs, MUSB_INTRUSBE, ctx.intrusbe);
 	musb_writeb(musb->mregs, MUSB_DEVCTL, ctx.devctl);
+
+	/* iterate over every endpoint, select it and restore its context */
+	for (i = 0; i < musb->config->num_eps; i++) {
+		musb_writeb(musb->mregs, MUSB_INDEX, i);
+		musb_writeb(musb->mregs, MUSB_RXFIFOSZ, ctx.rxfifosz[i]);
+		musb_writeb(musb->mregs, MUSB_TXFIFOSZ, ctx.txfifosz[i]);
+		musb_writew(musb->mregs, MUSB_TXFIFOADD, ctx.txfifoadd[i]);
+		musb_writew(musb->mregs, MUSB_RXFIFOADD, ctx.rxfifoadd[i]);
+	};
 }
 
 static int musb_suspend(struct platform_device *pdev, pm_message_t message)
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/musb/musb_core.h kernel-2.6.28-20093908+0m5/drivers/usb/musb/musb_core.h
--- kernel-2.6.28-20091602+0m5/drivers/usb/musb/musb_core.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/musb/musb_core.h	2012-12-16 13:13:01.696330145 +0100
@@ -64,7 +64,6 @@ struct musb_ep;
 #include "musb_host.h"
 
 
-
 #ifdef CONFIG_USB_MUSB_OTG
 
 #define	is_peripheral_enabled(musb)	((musb)->board_mode != MUSB_HOST)
@@ -109,7 +108,7 @@ struct musb_ep;
 
 extern irqreturn_t musb_g_ep0_irq(struct musb *);
 extern void musb_g_tx(struct musb *, u8);
-extern void musb_g_rx(struct musb *, u8);
+extern void musb_g_rx(struct musb *, u8, bool);
 extern void musb_g_reset(struct musb *);
 extern void musb_g_suspend(struct musb *);
 extern void musb_g_resume(struct musb *);
@@ -310,12 +309,9 @@ static inline struct usb_request *next_o
 
 struct musb_ctx {
 	/* common register */
-	u16	intrtx;
-	u16	intrrx;
 	u16	intrtxe;
 	u16	intrrxe;
 
-	u8	intrusb;
 	u8	intrusbe;
 
 	u8	faddr;
@@ -344,6 +340,11 @@ struct musb_ctx {
 
 	u8	fifosize[MUSB_MAX_EPS];
 
+	u8	rxfifosz[MUSB_MAX_EPS];
+	u8	txfifosz[MUSB_MAX_EPS];
+	u16	txfifoadd[MUSB_MAX_EPS];
+	u16	rxfifoadd[MUSB_MAX_EPS];
+
 	u8	count0;
 	u8	type0;
 	u8	naklimit0;
@@ -416,6 +417,7 @@ struct musb {
 	u16 epmask;
 	u8 nr_endpoints;
 
+	struct musb_board_data	*board;
 	u8 board_mode;		/* enum musb_mode */
 	int			(*board_set_power)(int state);
 
@@ -470,12 +472,6 @@ struct musb {
 	unsigned		test_mode:1;
 	unsigned		softconnect:1;
 
-	/* true if this chip can enable SUSPENDM */
-	unsigned		suspendm:1;
-
-	/* true if we're using dma */
-	unsigned		use_dma:1;
-
 	u8			address;
 	u8			test_mode_nr;
 	u16			ackpend;		/* ep0 */
@@ -484,11 +480,18 @@ struct musb {
 	struct usb_gadget_driver *gadget_driver;	/* its driver */
 #endif
 
+	/* true if this chip can enable SUSPENDM */
+	unsigned		suspendm:1;
+
+	/* true if we're using dma */
+	unsigned		use_dma:1;
+
 	struct musb_hdrc_config	*config;
 
 #ifdef MUSB_CONFIG_PROC_FS
 	struct proc_dir_entry *proc_entry;
 #endif
+	unsigned		is_charger:1;
 };
 
 static inline void musb_set_vbus(struct musb *musb, int is_on)
@@ -602,6 +605,18 @@ extern int musb_platform_get_vbus_status
 #define musb_platform_get_vbus_status(x)	0
 #endif
 
+#ifdef CONFIG_PM
+extern void musb_save_ctx(struct musb *musb);
+extern void musb_restore_ctx(struct musb *musb);
+extern void musb_save_ctx_and_suspend(struct usb_gadget *, int);
+extern void musb_restore_ctx_and_resume(struct usb_gadget *);
+#else
+static inline void musb_save_ctx(struct musb *musb) {}
+static inline void musb_restore_ctx(struct musb *musb) {}
+static inline void musb_save_ctx_and_suspend(struct usb_gadget *, int) {}
+static inline void musb_restore_ctx_and_resume(struct usb_gadget *) {}
+#endif
+
 extern int __init musb_platform_init(struct musb *musb);
 extern int musb_platform_exit(struct musb *musb);
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/musb/musb_debug.h kernel-2.6.28-20093908+0m5/drivers/usb/musb/musb_debug.h
--- kernel-2.6.28-20091602+0m5/drivers/usb/musb/musb_debug.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/musb/musb_debug.h	2012-12-16 13:13:01.696330145 +0100
@@ -42,9 +42,13 @@
 #define INFO(fmt, args...) yprintk(KERN_INFO, fmt, ## args)
 #define ERR(fmt, args...) yprintk(KERN_ERR, fmt, ## args)
 
+extern const char *otg_state_string(struct musb *);
+
+#ifdef CONFIG_USB_MUSB_DEBUG
+
 #define xprintk(level, facility, format, args...) do { \
 	if (_dbg_level(level)) { \
-		printk(facility "%s %d: " format , \
+		printk(facility "%-20s %4d: " format , \
 				__func__, __LINE__ , ## args); \
 	} } while (0)
 
@@ -54,9 +58,10 @@ static inline int _dbg_level(unsigned l)
 {
 	return musb_debug >= l;
 }
-
 #define DBG(level, fmt, args...) xprintk(level, KERN_DEBUG, fmt, ## args)
+#else
+#define DBG(level, fmt, args...)	do {} while(0)
+#endif	/* CONFIG_USB_MUSB_DEBUG */
 
-extern const char *otg_state_string(struct musb *);
 
 #endif				/*  __MUSB_LINUX_DEBUG_H__ */
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/musb/musb_gadget.c kernel-2.6.28-20093908+0m5/drivers/usb/musb/musb_gadget.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/musb/musb_gadget.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/musb/musb_gadget.c	2012-12-16 13:13:01.696330145 +0100
@@ -108,6 +108,7 @@ __acquires(ep->musb->lock)
 	struct musb		*musb;
 
 	req = to_musb_request(request);
+	req->complete = false;
 
 	list_del(&request->list);
 	if (req->request.status == -EINPROGRESS)
@@ -115,39 +116,197 @@ __acquires(ep->musb->lock)
 	musb = req->musb;
 
 	spin_unlock(&musb->lock);
-	if (musb->use_dma && ep->dma) {
-		if (req->mapped) {
-			dma_unmap_single(musb->controller,
-					req->request.dma,
-					req->request.length,
-					req->tx
-						? DMA_TO_DEVICE
-						: DMA_FROM_DEVICE);
-			req->request.dma = DMA_ADDR_INVALID;
-			req->mapped = 0;
-		} else if (req->request.dma != DMA_ADDR_INVALID)
-			dma_sync_single_for_cpu(musb->controller,
-					req->request.dma,
-					req->request.length,
-					req->tx
-						? DMA_TO_DEVICE
-						: DMA_FROM_DEVICE);
-	}
-	if (request->status == 0)
+	if (request->status == 0) {
 		DBG(5, "%s done request %p,  %d/%d\n",
-				ep->end_point.name, request,
-				req->request.actual, req->request.length);
-	else
+		    ep->name, request, req->request.actual,
+		    req->request.length);
+	} else
 		DBG(2, "%s request %p, %d/%d fault %d\n",
-				ep->end_point.name, request,
+				ep->name, request,
 				req->request.actual, req->request.length,
 				request->status);
-	ep->busy = 0;
 	req->request.complete(&req->ep->end_point, &req->request);
 	spin_lock(&musb->lock);
 }
 
-/* ----------------------------------------------------------------------- */
+/**
+ * start_dma - starts dma for a transfer
+ * @musb:	musb controller pointer
+ * @epnum:	endpoint number to kick dma
+ * @req:	musb request to be received
+ *
+ * Context: controller locked, IRQs blocked, endpoint selected
+ */
+static int start_dma(struct musb *musb, struct musb_request *req)
+{
+	struct musb_ep		*musb_ep = req->ep;
+	struct dma_controller   *cntr = musb->dma_controller;
+	struct musb_hw_ep	*hw_ep = musb_ep->hw_ep;
+	struct dma_channel	*dma;
+	void __iomem		*epio;
+	size_t			transfer_size;
+	int			packet_sz;
+	u16			csr;
+
+	if (!musb->use_dma || musb->dma_controller == NULL)
+		return -1;
+
+	if (musb_ep->type == USB_ENDPOINT_XFER_INT) {
+		DBG(5, "not allocating dma for interrupt endpoint\n");
+		return -1;
+	}
+
+	if (((unsigned long) req->request.buf) & 0x01) {
+		DBG(5, "unaligned buffer %p for %s\n", req->request.buf,
+		    musb_ep->name);
+		return -1;
+	}
+
+	packet_sz = musb_ep->packet_sz;
+	transfer_size = req->request.length;
+
+	if (transfer_size < packet_sz ||
+	    (transfer_size == packet_sz && packet_sz < 512)) {
+		DBG(4, "small transfer, using pio\n");
+		return -1;
+	}
+
+	epio = musb->endpoints[musb_ep->current_epnum].regs;
+	if (!musb_ep->is_in) {
+		csr = musb_readw(epio, MUSB_RXCSR);
+
+		/* If RXPKTRDY we might have something already waiting
+		 * in the fifo. If that something is less than packet_sz
+		 * it means we only have a short packet waiting in the fifo
+		 * so we unload it with pio.
+		 */
+		if (csr & MUSB_RXCSR_RXPKTRDY) {
+			u16 count;
+
+			count = musb_readw(epio, MUSB_RXCOUNT);
+			if (count < packet_sz) {
+				DBG(4, "small packet in FIFO (%d bytes), "
+				    "using PIO\n", count);
+				return -1;
+			}
+		}
+	}
+
+	dma = cntr->channel_alloc(cntr, hw_ep, musb_ep->is_in);
+	if (dma == NULL) {
+		DBG(4, "unable to allocate dma channel for %s\n",
+		    musb_ep->name);
+		return -1;
+	}
+
+	if (transfer_size > dma->max_len)
+		transfer_size = dma->max_len;
+
+	if (req->request.dma == DMA_ADDR_INVALID) {
+		req->request.dma = dma_map_single(musb->controller,
+						  req->request.buf,
+						  transfer_size,
+						  musb_ep->is_in ?
+						  DMA_TO_DEVICE :
+						  DMA_FROM_DEVICE);
+		req->mapped = 1;
+	} else {
+		dma_sync_single_for_device(musb->controller,
+					   req->request.dma,
+					   transfer_size,
+					   musb_ep->is_in ? DMA_TO_DEVICE :
+					   DMA_FROM_DEVICE);
+		req->mapped = 0;
+	}
+
+	if (musb_ep->is_in) {
+		csr = musb_readw(epio, MUSB_TXCSR);
+		csr |= MUSB_TXCSR_DMAENAB | MUSB_TXCSR_DMAMODE;
+		csr |= MUSB_TXCSR_AUTOSET | MUSB_TXCSR_MODE;
+		csr &= ~MUSB_TXCSR_P_UNDERRUN;
+		musb_writew(epio, MUSB_TXCSR, csr);
+	} else {
+		/* We only use mode1 dma and assume we never know the size of
+		 * the data we're receiving. For anything else, we're gonna use
+		 * pio.
+		 */
+
+		/* this special sequence is necessary to get DMAReq to
+		 * activate
+		 */
+		csr = musb_readw(epio, MUSB_RXCSR);
+		csr |= MUSB_RXCSR_AUTOCLEAR;
+		musb_writew(epio, MUSB_RXCSR, csr);
+
+		csr |= MUSB_RXCSR_DMAENAB;
+		musb_writew(epio, MUSB_RXCSR, csr);
+
+		csr |= MUSB_RXCSR_DMAMODE;
+		musb_writew(epio, MUSB_RXCSR, csr);
+		musb_writew(epio, MUSB_RXCSR, csr);
+
+		csr = musb_readw(epio, MUSB_RXCSR);
+	}
+
+	musb_ep->dma = dma;
+
+	(void) cntr->channel_program(dma, packet_sz, true, req->request.dma,
+				     transfer_size);
+
+	DBG(4, "%s dma started (addr 0x%08x, len %u, CSR %04x)\n",
+	    musb_ep->name, req->request.dma, transfer_size, csr);
+
+	return 0;
+}
+
+/**
+ * stop_dma - stops a dma transfer and unmaps a buffer
+ * @musb:	the musb controller pointer
+ * @ep:		the enpoint being used
+ * @req:	the request to stop
+ */
+static void stop_dma(struct musb *musb, struct musb_ep *ep,
+			struct musb_request *req)
+{
+	void __iomem *epio;
+
+	DBG(4, "%s dma stopped (addr 0x%08x, len %d)\n", ep->name,
+			req->request.dma, req->request.actual);
+
+	if (req->mapped) {
+		dma_unmap_single(musb->controller, req->request.dma,
+				 req->request.actual, req->tx ?
+				 DMA_TO_DEVICE : DMA_FROM_DEVICE);
+		req->request.dma = DMA_ADDR_INVALID;
+		req->mapped = 0;
+	} else {
+		dma_sync_single_for_cpu(musb->controller, req->request.dma,
+					req->request.actual, req->tx ?
+					DMA_TO_DEVICE : DMA_FROM_DEVICE);
+	}
+
+	epio = musb->endpoints[ep->current_epnum].regs;
+	if (req->tx) {
+		u16 csr;
+
+		csr = musb_readw(epio, MUSB_TXCSR);
+		csr &= ~(MUSB_TXCSR_DMAENAB | MUSB_TXCSR_AUTOSET);
+		musb_writew(epio, MUSB_TXCSR, csr | MUSB_TXCSR_P_WZC_BITS);
+		csr &= ~MUSB_TXCSR_DMAMODE;
+		musb_writew(epio, MUSB_TXCSR, csr | MUSB_TXCSR_P_WZC_BITS);
+	} else {
+		u16 csr;
+
+		csr = musb_readw(epio, MUSB_RXCSR);
+		csr &= ~(MUSB_RXCSR_DMAENAB | MUSB_RXCSR_AUTOCLEAR);
+		musb_writew(epio, MUSB_RXCSR, csr | MUSB_RXCSR_P_WZC_BITS);
+		csr &= ~MUSB_RXCSR_DMAMODE;
+		musb_writew(epio, MUSB_RXCSR, csr | MUSB_RXCSR_P_WZC_BITS);
+	}
+
+	musb->dma_controller->channel_release(ep->dma);
+	ep->dma = NULL;
+}
 
 /*
  * Abort requests queued to an endpoint using the status. Synchronous.
@@ -155,33 +314,55 @@ __acquires(ep->musb->lock)
  */
 static void nuke(struct musb_ep *ep, const int status)
 {
+	void __iomem		*epio;
 	struct musb_request	*req = NULL;
-	void __iomem		*epio = ep->musb->endpoints[ep->current_epnum].regs;
-	struct musb		*musb = ep->musb;
+	struct musb		*musb;
 
+	musb = ep->musb;
+	epio = musb->endpoints[ep->current_epnum].regs;
 	ep->busy = 1;
 
-	if (musb->use_dma && ep->dma) {
+	DBG(2, "%s nuke, DMA %p RxCSR %04x TxCSR %04x\n", ep->name, ep->dma,
+	    musb_readw(epio, MUSB_RXCSR), musb_readw(epio, MUSB_TXCSR));
+	if (ep->dma) {
 		struct dma_controller	*c = musb->dma_controller;
-		int value;
+
+		BUG_ON(next_request(ep) == NULL);
+		req = to_musb_request(next_request(ep));
+		(void) c->channel_abort(ep->dma);
+		stop_dma(musb, ep, req);
 
 		if (ep->is_in) {
-			musb_writew(epio, MUSB_TXCSR,
-					0 | MUSB_TXCSR_FLUSHFIFO);
-			musb_writew(epio, MUSB_TXCSR,
-					0 | MUSB_TXCSR_FLUSHFIFO);
+			u16 csr;
+
+			csr = musb_readw(epio, MUSB_TXCSR);
+			musb_writew(epio, MUSB_TXCSR, MUSB_TXCSR_DMAENAB
+					| MUSB_TXCSR_FLUSHFIFO);
+			musb_writew(epio, MUSB_TXCSR, MUSB_TXCSR_FLUSHFIFO);
+			if (csr & MUSB_TXCSR_TXPKTRDY) {
+				/* If TxPktRdy was set, an extra IRQ was just
+				 * generated. This IRQ will confuse things if
+				 * a we don't handle it before a new TX request
+				 * is started. So we clear it here, in a bit
+				 * unsafe fashion (if nuke() is called outside
+				 * musb_interrupt(), we might have a delay in
+				 * handling other TX EPs.) */
+				musb->int_tx |= musb_readw(musb->mregs,
+							   MUSB_INTRTX);
+				musb->int_tx &= ~(1 << ep->current_epnum);
+			}
 		} else {
-			musb_writew(epio, MUSB_RXCSR,
-					0 | MUSB_RXCSR_FLUSHFIFO);
-			musb_writew(epio, MUSB_RXCSR,
-					0 | MUSB_RXCSR_FLUSHFIFO);
+			musb_writew(epio, MUSB_RXCSR, MUSB_RXCSR_DMAENAB
+					| MUSB_RXCSR_FLUSHFIFO);
+			musb_writew(epio, MUSB_RXCSR, MUSB_RXCSR_FLUSHFIFO);
 		}
-
-		value = c->channel_abort(ep->dma);
-		DBG(value ? 1 : 6, "%s: abort DMA --> %d\n", ep->name, value);
-		c->channel_release(ep->dma);
-		ep->dma = NULL;
 	}
+	if (ep->is_in)
+		musb_writew(epio, MUSB_TXCSR, 0);
+	else
+		musb_writew(epio, MUSB_RXCSR, 0);
+
+	ep->rx_pending = false;
 
 	while (!list_empty(&(ep->req_list))) {
 		req = container_of(ep->req_list.next, struct musb_request,
@@ -208,7 +389,7 @@ static inline int max_ep_writesize(struc
 }
 
 /**
- * txstate - kicks TX pio transfer
+ * do_pio_tx - kicks TX pio transfer
  * @musb:	musb controller pointer
  * @req:	the request to be transfered via pio
  *
@@ -217,7 +398,7 @@ static inline int max_ep_writesize(struc
  *
  * Context: controller locked, IRQs blocked, endpoint selected
  */
-static void txstate(struct musb *musb, struct musb_request *req)
+static void do_pio_tx(struct musb *musb, struct musb_request *req)
 {
 	u8			epnum = req->epnum;
 	struct musb_ep		*musb_ep;
@@ -232,100 +413,55 @@ static void txstate(struct musb *musb, s
 
 	request = &req->request;
 
-	while (request->actual < request->length) {
-		fifo_count = min(max_ep_writesize(musb, musb_ep),
-				(int)(request->length - request->actual));
-
-		if (csr & MUSB_TXCSR_TXPKTRDY) {
-			DBG(5, "%s old packet still ready , txcsr %03x\n",
-					musb_ep->end_point.name, csr);
-			break;
-		}
-
-		if (csr & MUSB_TXCSR_P_SENDSTALL) {
-			DBG(5, "%s stalling, txcsr %03x\n",
-					musb_ep->end_point.name, csr);
-			break;
-		}
-
-		DBG(4, "hw_ep%d, maxpacket %d, fifo count %d, txcsr %03x\n",
-				epnum, musb_ep->packet_sz, fifo_count,
-				csr);
-
-		musb_ep->busy = 1;
+	fifo_count = min(max_ep_writesize(musb, musb_ep),
+			(int)(request->length - request->actual));
 
-		musb_write_fifo(musb_ep->hw_ep, fifo_count,
-				(u8 *) (request->buf + request->actual));
-		request->actual += fifo_count;
-		csr |= MUSB_TXCSR_TXPKTRDY;
-		/* REVISIT wasn't this cleared by musb_g_tx() ? */
-		csr &= ~MUSB_TXCSR_P_UNDERRUN;
-		musb_writew(epio, MUSB_TXCSR, csr);
+	if (csr & MUSB_TXCSR_TXPKTRDY) {
+		DBG(5, "%s old packet still ready , txcsr %03x\n",
+				musb_ep->name, csr);
+		return;
+	}
 
-		musb_ep->busy = 0;
+	if (csr & MUSB_TXCSR_P_SENDSTALL) {
+		DBG(5, "%s stalling, txcsr %03x\n",
+				musb_ep->name, csr);
+		return;
 	}
 
+	DBG(4, "hw_ep%d, maxpacket %d, fifo count %d, txcsr %03x\n",
+			epnum, musb_ep->packet_sz, fifo_count,
+			csr);
+
+	musb_write_fifo(musb_ep->hw_ep, fifo_count,
+			(u8 *) (request->buf + request->actual));
+	request->actual += fifo_count;
+	csr |= MUSB_TXCSR_TXPKTRDY;
+	/* REVISIT wasn't this cleared by musb_g_tx() ? */
+	csr &= ~MUSB_TXCSR_P_UNDERRUN;
+	musb_writew(epio, MUSB_TXCSR, csr);
+
 	/* host may already have the data when this message shows... */
 	DBG(3, "%s TX/IN pio len %d/%d, txcsr %04x, fifo %d/%d\n",
-			musb_ep->end_point.name,
+			musb_ep->name,
 			request->actual, request->length,
 			musb_readw(epio, MUSB_TXCSR),
 			fifo_count,
 			musb_readw(epio, MUSB_TXMAXP));
 }
 
-/**
- * txstate_dma - kicks dma for a TX transfer
- * @musb:	musb controller pointer
- * @req:	the request to be transfered via dma
- *
- * Called with controller locked, IRQs blocked and endpoint selected
+/*
+ * Context: controller locked, IRQs blocked.
  */
-static void txstate_dma(struct musb *musb, struct musb_request *req)
+static void musb_ep_restart(struct musb *musb, struct musb_request *req)
 {
-	const u8		epnum = req->epnum;
-
-	struct usb_request	*request = &req->request;
-	struct musb_ep		*musb_ep = &musb->endpoints[epnum].ep_in;
-
-	struct dma_controller	*c = musb->dma_controller;
-	struct dma_channel	*channel = musb_ep->dma;
-
-	size_t			transfer_size;
-	u16			csr = 0;
-
-	void __iomem		*epio = musb->endpoints[epnum].regs;
-
-	csr = musb_readw(epio, MUSB_TXCSR);
-
-	if (!channel) {
-		DBG(4, "cannot use dma, no channel available; trying pio\n");
-		txstate(musb, req);
-		return;
-	}
-
-	transfer_size = min(request->length, channel->max_len);
-	channel->desired_mode = true;
-
-	if (transfer_size >= musb_ep->packet_sz) {
-		csr |= MUSB_TXCSR_DMAENAB
-			| MUSB_TXCSR_DMAMODE
-			| MUSB_TXCSR_AUTOSET
-			| MUSB_TXCSR_MODE;
-
-		csr &= ~MUSB_TXCSR_P_UNDERRUN;
-
-		musb_writew(epio, MUSB_TXCSR, csr);
+	DBG(3, "<== TX/IN request %p len %u on hw_ep%d%s\n",
+		&req->request, req->request.length, req->epnum,
+		req->ep->dma ? " (dma)" : "(pio)");
 
-		DBG(3, "%s TX/IN dma len %d/%d, txcsr %04x\n",
-				musb_ep->end_point.name,
-				request->actual, request->length, csr);
+	musb_ep_select(musb->mregs, req->epnum);
 
-		(void) c->channel_program(channel, musb_ep->packet_sz,
-				true, request->dma, transfer_size);
-	} else {
-		txstate(musb, req);
-	}
+	if (start_dma(musb, req) < 0)
+		do_pio_tx(musb, req);
 }
 
 /*
@@ -335,16 +471,26 @@ static void txstate_dma(struct musb *mus
 void musb_g_tx(struct musb *musb, u8 epnum)
 {
 	u16			csr;
+	struct musb_request	*req;
 	struct usb_request	*request;
 	u8 __iomem		*mbase = musb->mregs;
 	struct musb_ep		*musb_ep = &musb->endpoints[epnum].ep_in;
 	void __iomem		*epio = musb->endpoints[epnum].regs;
+	struct dma_channel	*dma;
+	int			count;
 
 	musb_ep_select(mbase, epnum);
 	request = next_request(musb_ep);
 
 	csr = musb_readw(epio, MUSB_TXCSR);
-	DBG(4, "<== %s, txcsr %04x\n", musb_ep->end_point.name, csr);
+	dma = musb_ep->dma;
+	DBG(4, "<== %s, TxCSR %04x, DMA %p\n", musb_ep->name, csr, dma);
+
+	if (csr & MUSB_TXCSR_P_SENDSTALL) {
+		DBG(5, "%s stalling, txcsr %04x\n",
+				musb_ep->name, csr);
+		return;
+	}
 
 	/* REVISIT for high bandwidth, MUSB_TXCSR_P_INCOMPTX
 	 * probably rates reporting as a host error
@@ -354,6 +500,13 @@ void musb_g_tx(struct musb *musb, u8 epn
 		csr |= MUSB_TXCSR_P_WZC_BITS;
 		csr &= ~MUSB_TXCSR_P_SENTSTALL;
 		musb_writew(epio, MUSB_TXCSR, csr);
+		if (dma != NULL) {
+			BUG_ON(request == NULL);
+			dma->status = MUSB_DMA_STATUS_CORE_ABORT;
+			musb->dma_controller->channel_abort(dma);
+			stop_dma(musb, musb_ep, to_musb_request(request));
+			dma = NULL;
+		}
 
 		if (request && musb_ep->stalled)
 			musb_g_giveback(musb_ep, request, -EPIPE);
@@ -364,94 +517,109 @@ void musb_g_tx(struct musb *musb, u8 epn
 	if (csr & MUSB_TXCSR_P_UNDERRUN) {
 		/* we NAKed, no big deal ... little reason to care */
 		csr |= MUSB_TXCSR_P_WZC_BITS;
-		csr &= ~(MUSB_TXCSR_P_UNDERRUN
-				| MUSB_TXCSR_TXPKTRDY);
+		csr &= ~MUSB_TXCSR_P_UNDERRUN;
 		musb_writew(epio, MUSB_TXCSR, csr);
-		DBG(2, "underrun on ep%d, req %p %d/%d\n", epnum, request, request->actual, request->length);
+		DBG(2, "underrun on ep%d, req %p\n", epnum, request);
 	}
 
-	if (request) {
-		if (musb->use_dma && (csr & MUSB_TXCSR_DMAENAB)) {
-			csr |= MUSB_TXCSR_P_WZC_BITS;
-			csr &= ~(MUSB_TXCSR_DMAENAB
-					| MUSB_TXCSR_P_UNDERRUN
-					| MUSB_TXCSR_TXPKTRDY);
-			musb_writew(epio, MUSB_TXCSR, csr);
-			/* ensure writebuffer is empty */
-			csr = musb_readw(epio, MUSB_TXCSR);
-			request->actual += musb_ep->dma->actual_len;
-			DBG(4, "TXCSR%d %04x, dma off, "
-					"len %zu, req %p\n",
-					epnum, csr,
-					musb_ep->dma->actual_len,
-					request);
+	/* The interrupt is generated when this bit gets cleared,
+	 * if we fall here while TXPKTRDY is still set, then that's
+	 * a really messed up case. One such case seems to be due to
+	 * the HW -- sometimes the IRQ is generated early.
+	 */
+	count = 0;
+	while (csr & MUSB_TXCSR_TXPKTRDY) {
+		count++;
+		if (count == 1000) {
+			DBG(1, "TX IRQ while TxPktRdy still set "
+			    "(CSR %04x)\n", csr);
+			return;
 		}
+		csr = musb_readw(epio, MUSB_TXCSR);
+	}
 
-		if (musb->use_dma || request->actual == request->length) {
-			/* First, maybe a terminating short packet.
-			 * Some DMA engines might handle this by
-			 * themselves.
-			 */
-			if ((request->zero
-					&& request->length
-					&& (request->length
-						% musb_ep->packet_sz)
-					== 0)) {
-				/* on dma completion, fifo may not
-				 * be available yet ...
-				 */
-				if (csr & MUSB_TXCSR_TXPKTRDY) {
-					DBG(4, "fifo is not available yet\n");
-					return;
-				}
+	if (dma != NULL && dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {
+		/* SHOULD NOT HAPPEN ... has with cppi though, after
+		 * changing SENDSTALL (and other cases); harmless?
+		 */
+		DBG(3, "%s dma still busy?\n", musb_ep->name);
+		return;
+	}
 
-				DBG(4, "sending zero pkt\n");
-				musb_writew(epio, MUSB_TXCSR,
-						MUSB_TXCSR_MODE
-						| MUSB_TXCSR_TXPKTRDY);
-				request->zero = 0;
-			}
+	if (request == NULL) {
+		DBG(2, "%s, spurious TX IRQ", musb_ep->name);
+		return;
+	}
 
-			/* ... or if not, then complete it */
-			musb_g_giveback(musb_ep, request, 0);
+	req = to_musb_request(request);
 
-			/* kickstart next transfer if appropriate;
-			 * the packet that just completed might not
-			 * be transmitted for hours or days.
-			 * REVISIT for double buffering...
-			 * FIXME revisit for stalls too...
-			 */
-			musb_ep_select(mbase, epnum);
+	if (dma) {
+		int short_packet = 0;
+
+		BUG_ON(!(csr & MUSB_TXCSR_DMAENAB));
+
+		request->actual += dma->actual_len;
+		DBG(4, "TxCSR%d %04x, dma finished, len %zu, req %p\n",
+		    epnum, csr, dma->actual_len, request);
+
+		stop_dma(musb, musb_ep, req);
+
+		WARN(request->actual != request->length,
+		     "actual %d length %d\n", request->actual,
+		     request->length);
+
+		if (request->length % musb_ep->packet_sz)
+			short_packet = 1;
+
+		req->complete = true;
+		if (request->zero || short_packet) {
 			csr = musb_readw(epio, MUSB_TXCSR);
-			if (csr & MUSB_TXCSR_FIFONOTEMPTY)
-				return;
-			request = musb_ep->desc
-				? next_request(musb_ep)
-				: NULL;
-			if (!request) {
-				DBG(4, "%s idle now\n",
-						musb_ep->end_point.name);
+			DBG(4, "sending zero pkt, DMA, TxCSR %04x\n", csr);
+			musb_writew(epio, MUSB_TXCSR,
+				    csr | MUSB_TXCSR_TXPKTRDY);
+			return;
+		}
+	}
+
+	if (request->actual == request->length) {
+		if (!req->complete) {
+			/* Maybe we have to send a zero length packet */
+			if (request->zero && request->length &&
+			    (request->length % musb_ep->packet_sz) == 0) {
+				csr = musb_readw(epio, MUSB_TXCSR);
+				DBG(4, "sending zero pkt, TxCSR %04x\n", csr);
+				musb_writew(epio, MUSB_TXCSR,
+					    csr | MUSB_TXCSR_TXPKTRDY);
+				req->complete = true;
 				return;
 			}
 		}
+		musb_ep->busy = 1;
+		musb_g_giveback(musb_ep, request, 0);
+		musb_ep->busy = 0;
 
-		if (musb->use_dma)
-			txstate_dma(musb, to_musb_request(request));
-		else
-			txstate(musb, to_musb_request(request));
+		request = musb_ep->desc ? next_request(musb_ep) : NULL;
+		if (!request) {
+			DBG(4, "%s idle now\n", musb_ep->name);
+			return;
+		}
+		musb_ep_restart(musb, to_musb_request(request));
+		return;
 	}
+
+	do_pio_tx(musb, to_musb_request(request));
 }
 
 /* ------------------------------------------------------------ */
 
 /**
- * rxstate - kicks RX pio transfer
+ * do_pio_rx - kicks RX pio transfer
  * @musb:	musb controller pointer
  * @req:	the request to be transfered via pio
  *
  * Context: controller locked, IRQs blocked, endpoint selected
  */
-static void rxstate(struct musb *musb, struct musb_request *req)
+static void do_pio_rx(struct musb *musb, struct musb_request *req)
 {
 	u16			csr = 0;
 	const u8		epnum = req->epnum;
@@ -460,136 +628,91 @@ static void rxstate(struct musb *musb, s
 	void __iomem		*epio = musb->endpoints[epnum].regs;
 	unsigned		fifo_count = 0;
 	u16			count = musb_ep->packet_sz;
+	int			retries = 1000;
 
 	csr = musb_readw(epio, MUSB_RXCSR);
 
-	musb_ep->busy = 1;
-
-	if (csr & MUSB_RXCSR_RXPKTRDY) {
-		count = musb_readw(epio, MUSB_RXCOUNT);
-		if (request->actual < request->length) {
-			fifo_count = request->length - request->actual;
-			DBG(3, "%s OUT/RX pio fifo %d/%d, maxpacket %d\n",
-					musb_ep->end_point.name,
-					count, fifo_count,
-					musb_ep->packet_sz);
-
-			fifo_count = min_t(unsigned, count, fifo_count);
-
-			musb_read_fifo(musb_ep->hw_ep, fifo_count, (u8 *)
-					(request->buf + request->actual));
-			request->actual += fifo_count;
-
-			/* REVISIT if we left anything in the fifo, flush
-			 * it and report -EOVERFLOW
-			 */
-
-			/* ack the read! */
-			csr |= MUSB_RXCSR_P_WZC_BITS;
-			csr &= ~MUSB_RXCSR_RXPKTRDY;
-			musb_writew(epio, MUSB_RXCSR, csr);
+	/* RxPktRdy should be the only possibility here.
+	 * Sometimes the IRQ is generated before
+	 * RxPktRdy gets set, so we'll wait a while. */
+	while (!(csr & MUSB_RXCSR_RXPKTRDY)) {
+		if (retries-- == 0) {
+			DBG(1, "RxPktRdy did not get set (CSR %04x)\n", csr);
+			BUG_ON(!(csr & MUSB_RXCSR_RXPKTRDY));
 		}
+		csr = musb_readw(epio, MUSB_RXCSR);
 	}
 
-	musb_ep->busy = 0;
-
-	/* reach the end or short packet detected */
-	if (request->actual == request->length || count < musb_ep->packet_sz)
-		musb_g_giveback(musb_ep, request, 0);
-}
-
-/**
- * rxstate_dma - kicks dma for a RX transfer
- * @musb:	musb controller pointer
- * @req:	the request to be transfered via dma
- *
- * Called with controller locked, IRQs blocked and endpoint selected
- */
-static void rxstate_dma(struct musb *musb, struct musb_request *req)
-{
-	const u8		epnum = req->epnum;
-
-	struct usb_request	*request = &req->request;
-	struct musb_ep		*musb_ep = &musb->endpoints[epnum].ep_out;
-
-	struct dma_controller	*c = musb->dma_controller;
-	struct dma_channel	*channel = musb_ep->dma;
-
-	size_t			transfer_size;
-	u16			count = 0;
-	u16			csr = 0;
-
-	void __iomem		*epio = musb->endpoints[epnum].regs;
-
-	csr = musb_readw(epio, MUSB_RXCSR);
-
-	/* If RXPKTRDY we might have something already waiting
-	 * in the fifo. If that something is less than packet_sz
-	 * it means we only have a short packet waiting in the fifo
-	 * so we unload it with pio.
-	 */
-	if (csr & MUSB_RXCSR_RXPKTRDY) {
-		count = musb_readw(epio, MUSB_RXCOUNT);
-		DBG(4, "count %d\n", count);
-		if (count < musb_ep->packet_sz) {
-			rxstate(musb, req);
-			return;
-		}
-	}
+	musb_ep->busy = 1;
 
-	if (!channel) {
-		DBG(4, "cannot use dma, no channel available; trying pio\n");
-		rxstate(musb, req);
-		return;
-	}
+	count = musb_readw(epio, MUSB_RXCOUNT);
+	if (request->actual < request->length) {
+		fifo_count = request->length - request->actual;
+		DBG(3, "%s OUT/RX pio fifo %d/%d, maxpacket %d\n",
+				musb_ep->name,
+				count, fifo_count,
+				musb_ep->packet_sz);
 
-	transfer_size = min(request->length, channel->max_len);
+		fifo_count = min_t(unsigned, count, fifo_count);
 
-	if (transfer_size > musb_ep->packet_sz) {
+		musb_read_fifo(musb_ep->hw_ep, fifo_count,
+			       (u8 *) (request->buf + request->actual));
+		request->actual += fifo_count;
 
-		/* We only use mode1 dma and assume we never know the size of the
-		 * data we're receiving. For anything else, we're gonna use
-		 * pio.
-		 *
-		 * That's good enough for file_storage gadget which doesn't have
-		 * that many short packets but other gadgets (like g_ether) might
-		 * face some slowness if we get a short packet storm. We accept
-		 * that since there aren't real end-user usecases for g_ether
-		 * with this controller. If we ever have that, we might need
-		 * to rethink the following logic a little bit.
+		/* REVISIT if we left anything in the fifo, flush
+		 * it and report -EOVERFLOW
 		 */
-		csr |= MUSB_RXCSR_AUTOCLEAR
-			| MUSB_RXCSR_DMAMODE
-			| MUSB_RXCSR_DMAENAB;
 
+		/* ack the read! */
+		csr |= MUSB_RXCSR_P_WZC_BITS;
+		csr &= ~MUSB_RXCSR_RXPKTRDY;
 		musb_writew(epio, MUSB_RXCSR, csr);
-
-		(void) c->channel_program(channel, musb_ep->packet_sz,
-				true, request->dma, transfer_size);
-	} else {
-		rxstate(musb, req);
 	}
+
+	musb_ep->busy = 0;
+
+	/* we just received a short packet, it's ok to
+	 * giveback() the request already
+	 */
+	if (request->actual == request->length || count < musb_ep->packet_sz)
+		musb_g_giveback(musb_ep, request, 0);
 }
 
 /*
  * Data ready for a request; called from IRQ
  */
-void musb_g_rx(struct musb *musb, u8 epnum)
+void musb_g_rx(struct musb *musb, u8 epnum, bool is_dma)
 {
 	u16			csr;
+	struct musb_request	*req;
 	struct usb_request	*request;
 	void __iomem		*mbase = musb->mregs;
 	struct musb_ep		*musb_ep = &musb->endpoints[epnum].ep_out;
 	void __iomem		*epio = musb->endpoints[epnum].regs;
+	struct dma_channel	*dma;
 
 	musb_ep_select(mbase, epnum);
 
+	csr = musb_readw(epio, MUSB_RXCSR);
+restart:
+	if (csr == 0) {
+		DBG(3, "spurious IRQ\n");
+		return;
+	}
+
 	request = next_request(musb_ep);
+	if (!request) {
+		DBG(1, "waiting for request for %s (csr %04x)\n",
+				musb_ep->name, csr);
+		musb_ep->rx_pending = true;
+		return;
+	}
 
-	csr = musb_readw(epio, MUSB_RXCSR);
+	dma = musb_ep->dma;
 
-	DBG(4, "<== %s, rxcsr %04x %p\n", musb_ep->end_point.name,
-			csr, request);
+	DBG(4, "<== %s, rxcsr %04x %p (dma %s, %s)\n", musb_ep->name,
+	    csr, request, dma ? "enabled" : "disabled",
+	    is_dma ? "true" : "false");
 
 	if (csr & MUSB_RXCSR_P_SENTSTALL) {
 		DBG(5, "ep%d is halted, cannot transfer\n", epnum);
@@ -597,7 +720,13 @@ void musb_g_rx(struct musb *musb, u8 epn
 		csr &= ~MUSB_RXCSR_P_SENTSTALL;
 		musb_writew(epio, MUSB_RXCSR, csr);
 
-		if (request && musb_ep->stalled)
+		if (dma != NULL &&
+		    dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {
+			dma->status = MUSB_DMA_STATUS_CORE_ABORT;
+			musb->dma_controller->channel_abort(dma);
+		}
+
+		if (musb_ep->stalled)
 			musb_g_giveback(musb_ep, request, -EPIPE);
 		return;
 	}
@@ -608,61 +737,63 @@ void musb_g_rx(struct musb *musb, u8 epn
 		musb_writew(epio, MUSB_RXCSR, csr);
 
 		DBG(3, "%s iso overrun on %p\n", musb_ep->name, request);
-		if (request && request->status == -EINPROGRESS)
+		if (request->status == -EINPROGRESS)
 			request->status = -EOVERFLOW;
 	}
 
 	if (csr & MUSB_RXCSR_INCOMPRX) {
 		/* REVISIT not necessarily an error */
-		DBG(4, "%s, incomprx\n", musb_ep->end_point.name);
+		DBG(4, "%s, incomprx\n", musb_ep->name);
 	}
 
-	if (musb->use_dma && (csr & MUSB_RXCSR_DMAENAB)
-			&& request) {
-		csr &= ~(MUSB_RXCSR_RXPKTRDY
-				| MUSB_RXCSR_DMAMODE
-				| MUSB_RXCSR_DMAENAB);
-		musb_writew(epio, MUSB_RXCSR,
-				MUSB_RXCSR_P_WZC_BITS | csr);
+	req = to_musb_request(request);
+
+	BUG_ON(dma == NULL && (csr & MUSB_RXCSR_DMAENAB));
+
+	if (dma != NULL) {
+		u32 len;
+
+		/* We don't handle stalls yet. */
+		BUG_ON(csr & MUSB_RXCSR_P_SENDSTALL);
 
-		musb->dma_controller->channel_abort(musb_ep->dma);
-		request->actual += musb_ep->dma->actual_len;
+		/* We abort() so dma->actual_len gets updated */
+		musb->dma_controller->channel_abort(dma);
+
+		/* We only expect full packets. */
+		BUG_ON(dma->actual_len & (musb_ep->packet_sz - 1));
+
+		request->actual += dma->actual_len;
+		len = dma->actual_len;
+
+		stop_dma(musb, musb_ep, req);
+		dma = NULL;
 
 		DBG(4, "RXCSR%d %04x, dma off, %04x, len %zu, req %p\n",
-			epnum, csr,
-			musb_readw(epio, MUSB_RXCSR),
-			musb_ep->dma->actual_len, request);
-
-		/* incomplete, and not short? wait for next IN packet */
-		if (request->actual < request->length
-				&& (musb_ep->dma->actual_len
-					== musb_ep->packet_sz))
-			return;
+		    epnum, csr, musb_readw(epio, MUSB_RXCSR), len, request);
 
-		/* if short unload with pio */
-		if (request->actual < request->length) {
-			rxstate(musb, to_musb_request(request));
-			return;
+		if (!is_dma) {
+			/* Unload with pio */
+			do_pio_rx(musb, req);
+		} else {
+			BUG_ON(request->actual != request->length);
+			musb_g_giveback(musb_ep, request, 0);
 		}
+		return;
+	}
 
-		/* don't start more i/o till the stall clears */
-		musb_ep_select(mbase, epnum);
-		csr = musb_readw(epio, MUSB_RXCSR);
-		if (csr & MUSB_RXCSR_P_SENDSTALL)
-			return;
+	if (dma == NULL && musb->use_dma) {
+		if (start_dma(musb, req) == 0)
+			dma = musb_ep->dma;
 	}
 
-	/* analyze request if the ep is hot */
-	request = next_request(musb_ep);
-	if (request) {
-		if (musb->use_dma)
-			rxstate_dma(musb, to_musb_request(request));
-		else
-			rxstate(musb, to_musb_request(request));
-	} else {
-		DBG(3, "packet waiting for %s%s request\n",
-				musb_ep->desc ? "" : "inactive ",
-				musb_ep->end_point.name);
+	if (dma == NULL) {
+		do_pio_rx(musb, req);
+		csr = musb_readw(epio, MUSB_RXCSR);
+		if (csr & MUSB_RXCSR_RXPKTRDY) {
+			DBG(2, "new packet in FIFO, restarting RX "
+			    "(CSR %04x)\n", csr);
+			goto restart;
+		}
 	}
 }
 
@@ -740,7 +871,7 @@ static int musb_gadget_enable(struct usb
 		if (musb_readw(regs, MUSB_TXCSR)
 				& MUSB_TXCSR_FIFONOTEMPTY)
 			csr |= MUSB_TXCSR_FLUSHFIFO;
-		if (musb_ep->type == USB_ENDPOINT_XFER_ISOC)
+		if (usb_endpoint_xfer_isoc(desc))
 			csr |= MUSB_TXCSR_P_ISO;
 		musb_writew(regs, MUSB_TXCSR, csr);
 	} else {
@@ -771,9 +902,9 @@ static int musb_gadget_enable(struct usb
 		/* clear DATAx toggle */
 		csr = MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_CLRDATATOG;
 
-		if (musb_ep->type == USB_ENDPOINT_XFER_ISOC)
+		if (usb_endpoint_xfer_isoc(desc))
 			csr |= MUSB_RXCSR_P_ISO;
-		else if (musb_ep->type == USB_ENDPOINT_XFER_INT)
+		else if (usb_endpoint_xfer_int(desc))
 			csr |= MUSB_RXCSR_DISNYET;
 		musb_writew(regs, MUSB_RXCSR, csr);
 	}
@@ -781,21 +912,13 @@ static int musb_gadget_enable(struct usb
 	/* NOTE:  all the I/O code _should_ work fine without DMA, in case
 	 * for some reason you run out of channels here.
 	 */
-	if (musb->use_dma && musb->dma_controller) {
-		struct dma_controller   *c = musb->dma_controller;
-
-		musb_ep->dma = c->channel_alloc(c, hw_ep,
-				(desc->bEndpointAddress & USB_DIR_IN));
-	} else {
-		musb_ep->dma = NULL;
-	}
-
+	musb_ep->dma = NULL;
 	musb_ep->desc = desc;
 	musb_ep->busy = 0;
 	status = 0;
 
 	pr_debug("%s periph: enabled %s for %s %s, %smaxpacket %d\n",
-			musb_driver_name, musb_ep->end_point.name,
+			musb_driver_name, musb_ep->name,
 			({ char *s; switch (musb_ep->type) {
 			case USB_ENDPOINT_XFER_BULK:	s = "bulk"; break;
 			case USB_ENDPOINT_XFER_INT:	s = "int"; break;
@@ -808,6 +931,7 @@ static int musb_gadget_enable(struct usb
 	schedule_work(&musb->irq_work);
 
 fail:
+	musb_ep_select(mbase, 0);
 	spin_unlock_irqrestore(&musb->lock, flags);
 	return status;
 }
@@ -825,6 +949,7 @@ static int musb_gadget_disable(struct us
 	int		status = 0;
 
 	musb_ep = to_musb_ep(ep);
+	DBG(4, "disabling %s\n", musb_ep->name);
 	musb = musb_ep->musb;
 	epnum = musb_ep->current_epnum;
 	epio = musb->endpoints[epnum].regs;
@@ -856,7 +981,7 @@ static int musb_gadget_disable(struct us
 
 	spin_unlock_irqrestore(&(musb->lock), flags);
 
-	DBG(2, "%s\n", musb_ep->end_point.name);
+	DBG(2, "%s\n", musb_ep->name);
 
 	return status;
 }
@@ -868,16 +993,20 @@ static int musb_gadget_disable(struct us
 struct usb_request *musb_alloc_request(struct usb_ep *ep, gfp_t gfp_flags)
 {
 	struct musb_ep		*musb_ep = to_musb_ep(ep);
+	struct musb		*musb = musb_ep->musb;
 	struct musb_request	*request = NULL;
 
 	request = kzalloc(sizeof *request, gfp_flags);
-	if (request) {
-		INIT_LIST_HEAD(&request->request.list);
-		request->request.dma = DMA_ADDR_INVALID;
-		request->epnum = musb_ep->current_epnum;
-		request->ep = musb_ep;
+	if (!request) {
+		dev_err(musb->controller, "not enough memory\n");
+		return NULL;
 	}
 
+	INIT_LIST_HEAD(&request->request.list);
+	request->request.dma = DMA_ADDR_INVALID;
+	request->epnum = musb_ep->current_epnum;
+	request->ep = musb_ep;
+
 	return &request->request;
 }
 
@@ -899,30 +1028,6 @@ struct free_record {
 	dma_addr_t		dma;
 };
 
-/*
- * Context: controller locked, IRQs blocked.
- */
-static void musb_ep_restart(struct musb *musb, struct musb_request *req)
-{
-	DBG(3, "<== %s request %p len %u on hw_ep%d%s\n",
-		req->tx ? "TX/IN" : "RX/OUT",
-		&req->request, req->request.length, req->epnum,
-		musb->use_dma ? " (dma)" : "");
-
-	musb_ep_select(musb->mregs, req->epnum);
-	if (musb->use_dma) {
-		if (req->tx)
-			txstate_dma(musb, req);
-		else
-			rxstate_dma(musb, req);
-	} else {
-		if (req->tx)
-			txstate(musb, req);
-		else
-			rxstate(musb, req);
-	}
-}
-
 static int musb_gadget_queue(struct usb_ep *ep, struct usb_request *req,
 			gfp_t gfp_flags)
 {
@@ -953,31 +1058,7 @@ static int musb_gadget_queue(struct usb_
 	request->request.status = -EINPROGRESS;
 	request->epnum = musb_ep->current_epnum;
 	request->tx = musb_ep->is_in;
-
-	if (musb->use_dma && musb_ep->dma) {
-		if (request->request.dma == DMA_ADDR_INVALID) {
-			request->request.dma = dma_map_single(
-					musb->controller,
-					request->request.buf,
-					request->request.length,
-					request->tx
-						? DMA_TO_DEVICE
-						: DMA_FROM_DEVICE);
-			request->mapped = 1;
-		} else {
-			dma_sync_single_for_device(musb->controller,
-					request->request.dma,
-					request->request.length,
-					request->tx
-						? DMA_TO_DEVICE
-						: DMA_FROM_DEVICE);
-			request->mapped = 0;
-		}
-	} else if (!req->buf) {
-		return -ENODATA;
-	} else {
-		request->mapped = 0;
-	}
+	request->mapped = 0;
 
 	spin_lock_irqsave(&musb->lock, lockflags);
 
@@ -995,12 +1076,21 @@ static int musb_gadget_queue(struct usb_
 	/* we can only start i/o if this is the head of the queue and
 	 * endpoint is not stalled (halted) or busy
 	 */
-	if (!musb_ep->stalled
-		&& &request->request.list == musb_ep->req_list.next) {
+	if (!musb_ep->stalled && !musb_ep->busy &&
+	    &request->request.list == musb_ep->req_list.next &&
+	    request->tx) {
 		DBG(1, "restarting\n");
 		musb_ep_restart(musb, request);
 	}
 
+	/* if we received an RX packet before the request was queued,
+	 * process it here. */
+	if (!request->tx && musb_ep->rx_pending) {
+		DBG(1, "processing pending RX\n");
+		musb_ep->rx_pending = false;
+		musb_g_rx(musb, musb_ep->current_epnum, false);
+	}
+
 cleanup:
 	spin_unlock_irqrestore(&musb->lock, lockflags);
 	return status;
@@ -1014,6 +1104,7 @@ static int musb_gadget_dequeue(struct us
 	int			status = 0;
 	struct musb		*musb = musb_ep->musb;
 
+	DBG(4, "%s, dequeueing request %p\n", ep->name, request);
 	if (!ep || !request || to_musb_request(request)->ep != musb_ep)
 		return -EINVAL;
 
@@ -1030,11 +1121,10 @@ static int musb_gadget_dequeue(struct us
 	}
 
 	/* if the hardware doesn't have the request, easy ... */
-	if (musb_ep->req_list.next != &request->list || !musb_ep->busy) {
+	if (musb_ep->req_list.next != &request->list) {
 		musb_g_giveback(musb_ep, request, -ECONNRESET);
-
 	/* ... else abort the dma transfer ... */
-	} else if (musb->use_dma && musb_ep->dma) {
+	} else if (musb_ep->dma) {
 		struct dma_controller	*c = musb->dma_controller;
 
 		musb_ep_select(musb->mregs, musb_ep->current_epnum);
@@ -1042,6 +1132,7 @@ static int musb_gadget_dequeue(struct us
 			status = c->channel_abort(musb_ep->dma);
 		else
 			status = -EBUSY;
+		stop_dma(musb, musb_ep, to_musb_request(request));
 		if (status == 0)
 			musb_g_giveback(musb_ep, request, -ECONNRESET);
 	} else {
@@ -1131,10 +1222,6 @@ int musb_gadget_set_halt(struct usb_ep *
 
 done:
 
-	DBG(1, "stalled %s, head %s\n", musb_ep->stalled ? "yes" : "no",
-			&request->request.list == musb_ep->req_list.next ?
-			"yes" : "no");
-
 	/* maybe start the first request in the queue */
 	if (!musb_ep->stalled && request) {
 		DBG(3, "restarting the request\n");
@@ -1311,10 +1398,39 @@ static void musb_pullup(struct musb *mus
 	u8 power;
 
 	power = musb_readb(musb->mregs, MUSB_POWER);
-	if (is_on)
+	/** UGLY UGLY HACK: Windows problems with multiple
+	 * configurations.
+	 *
+	 * This is necessary to prevent a RESET irq to
+	 * come when we fake a usb disconnection in order
+	 * to change the configuration on the gadget driver.
+	 */
+	if (is_on) {
+		u8 r;
 		power |= MUSB_POWER_SOFTCONN;
-	else
+
+		r = musb_readb(musb->mregs, MUSB_INTRUSBE);
+		/* disable RESET interrupt */
+		musb_writeb(musb->mregs, MUSB_INTRUSBE, ~(r & BIT(1)));
+
+		/* send resume */
+		r = musb_readb(musb->mregs, MUSB_POWER);
+		r |= MUSB_POWER_RESUME;
+		musb_writeb(musb->mregs, MUSB_POWER, r);
+
+		/* ...for 10 ms */
+		mdelay(10);
+		r &= ~MUSB_POWER_RESUME;
+		musb_writeb(musb->mregs, MUSB_POWER, r);
+
+		/* enable interrupts */
+		musb_writeb(musb->mregs, MUSB_INTRUSBE, 0xf7);
+
+		/* some delay required for this to work */
+		mdelay(10);
+	} else {
 		power &= ~MUSB_POWER_SOFTCONN;
+	}
 
 	/* FIXME if on, HdrcStart; if off, HdrcStop */
 
@@ -1560,6 +1676,12 @@ int usb_gadget_register_driver(struct us
 	spin_unlock_irqrestore(&musb->lock, flags);
 
 	if (retval == 0) {
+		/* Clocks need to be turned on with OFF mode */
+		if (musb->set_clock)
+			musb->set_clock(musb->clock, 1);
+		else
+			clk_enable(musb->clock);
+
 		retval = driver->bind(&musb->g);
 		if (retval != 0) {
 			DBG(3, "bind to driver %s failed --> %d\n",
@@ -1607,6 +1729,7 @@ int usb_gadget_register_driver(struct us
 			}
 		}
 	}
+	musb_save_ctx(musb);
 
 	return retval;
 }
@@ -1675,6 +1798,11 @@ int usb_gadget_unregister_driver(struct
 
 	spin_lock_irqsave(&musb->lock, flags);
 
+	if (musb->set_clock)
+		musb->set_clock(musb->clock, 1);
+	else
+		clk_enable(musb->clock);
+
 #ifdef	CONFIG_USB_MUSB_OTG
 	musb_hnp_stop(musb);
 #endif
@@ -1707,6 +1835,7 @@ int usb_gadget_unregister_driver(struct
 		 * that currently misbehaves.
 		 */
 	}
+	musb_save_ctx(musb);
 
 	return retval;
 }
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/musb/musb_gadget_ep0.c kernel-2.6.28-20093908+0m5/drivers/usb/musb/musb_gadget_ep0.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/musb/musb_gadget_ep0.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/musb/musb_gadget_ep0.c	2012-12-16 13:13:01.696330145 +0100
@@ -55,7 +55,7 @@
  * the gadget driver, or adjusting endpoint halt status.
  */
 
-static char *decode_ep0stage(u8 stage)
+static inline char *decode_ep0stage(u8 stage)
 {
 	switch (stage) {
 	case MUSB_EP0_STAGE_SETUP:	return "idle";
@@ -404,7 +404,7 @@ stall:
 					csr |= MUSB_RXCSR_P_SENDSTALL
 						| MUSB_RXCSR_FLUSHFIFO
 						| MUSB_RXCSR_CLRDATATOG
-						| MUSB_TXCSR_P_WZC_BITS;
+						| MUSB_RXCSR_P_WZC_BITS;
 					musb_writew(regs, MUSB_RXCSR,
 							csr);
 				}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/musb/musb_gadget.h kernel-2.6.28-20093908+0m5/drivers/usb/musb/musb_gadget.h
--- kernel-2.6.28-20091602+0m5/drivers/usb/musb/musb_gadget.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/musb/musb_gadget.h	2012-12-16 13:13:01.696330145 +0100
@@ -42,6 +42,7 @@ struct musb_request {
 	u8 tx;			/* endpoint direction */
 	u8 epnum;
 	u8 mapped;
+	u8 complete;		/* true when completed and zero-length needed */
 };
 
 static inline struct musb_request *to_musb_request(struct usb_request *req)
@@ -76,7 +77,8 @@ struct musb_ep {
 	struct list_head		req_list;
 
 	/* true if lock must be dropped but req_list may not be advanced */
-	u8				busy;
+	u8				busy:1;
+	u8				rx_pending:1;
 
 	/* true if endpoint is stalled */
 	unsigned			stalled:1;
@@ -97,7 +99,7 @@ static inline struct usb_request *next_r
 }
 
 extern void musb_g_tx(struct musb *musb, u8 epnum);
-extern void musb_g_rx(struct musb *musb, u8 epnum);
+extern void musb_g_rx(struct musb *musb, u8 epnum, bool);
 
 extern const struct usb_ep_ops musb_g_ep0_ops;
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/musb/musb_host.c kernel-2.6.28-20093908+0m5/drivers/usb/musb/musb_host.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/musb/musb_host.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/musb/musb_host.c	2012-12-16 13:13:01.696330145 +0100
@@ -176,8 +176,6 @@ musb_start_urb(struct musb *musb, int is
 	void __iomem		*mbase =  musb->mregs;
 	struct urb		*urb = next_urb(qh);
 	struct musb_hw_ep	*hw_ep = qh->hw_ep;
-	unsigned		pipe = urb->pipe;
-	u8			address = usb_pipedevice(pipe);
 	int			epnum = hw_ep->epnum;
 
 	/* initialize software qh state */
@@ -206,7 +204,7 @@ musb_start_urb(struct musb *musb, int is
 	}
 
 	DBG(4, "qh %p urb %p dev%d ep%d%s%s, hw_ep %d, %p/%d\n",
-			qh, urb, address, qh->epnum,
+			qh, urb, usb_pipedevice(urb->pipe), qh->epnum,
 			is_in ? "in" : "out",
 			({char *s; switch (qh->type) {
 			case USB_ENDPOINT_XFER_CONTROL:	s = ""; break;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/musb/musbhsdma.c kernel-2.6.28-20093908+0m5/drivers/usb/musb/musbhsdma.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/musb/musbhsdma.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/musb/musbhsdma.c	2012-12-16 13:13:01.696330145 +0100
@@ -79,23 +79,29 @@ static struct dma_channel *dma_channel_a
 	struct dma_channel *channel = NULL;
 	u8 bit;
 
-	for (bit = 0; bit < MUSB_HSDMA_CHANNELS; bit++) {
-		if (!(controller->used_channels & (1 << bit))) {
-			controller->used_channels |= (1 << bit);
-			musb_channel = &(controller->channel[bit]);
-			musb_channel->controller = controller;
-			musb_channel->idx = bit;
-			musb_channel->epnum = hw_ep->epnum;
-			musb_channel->transmit = transmit;
-			channel = &(musb_channel->channel);
-			channel->private_data = musb_channel;
-			channel->status = MUSB_DMA_STATUS_FREE;
-			channel->max_len = 0x7fffffff;
-			/* always use mode1 */
-			channel->desired_mode = true;
-			channel->actual_len = 0;
-			break;
-		}
+	/* musb on omap3 has a problem with using dma channels simultaneously
+	 * so we will only allocate 1 dma channel at a time to avoid problems
+	 * related to that bug
+	 */
+	for (bit = 0; bit < 1; bit++) {
+		if (controller->used_channels & (1 << bit))
+			continue;
+
+		controller->used_channels |= (1 << bit);
+		musb_channel = &(controller->channel[bit]);
+		musb_channel->controller = controller;
+		musb_channel->idx = bit;
+		musb_channel->epnum = hw_ep->epnum;
+		musb_channel->transmit = transmit;
+		channel = &(musb_channel->channel);
+		channel->private_data = musb_channel;
+		channel->status = MUSB_DMA_STATUS_FREE;
+		channel->max_len = 0x7fffffff;
+		/* always use mode1 */
+		channel->desired_mode = true;
+		channel->actual_len = 0;
+
+		break;
 	}
 
 	return channel;
@@ -128,6 +134,9 @@ static void configure_channel(struct dma
 	DBG(4, "%p, pkt_sz %d, addr 0x%x, len %d, mode %d\n",
 			channel, packet_sz, dma_addr, len, mode);
 
+	if (mode)
+		csr |= MUSB_HSDMA_MODE1;
+
 	if (packet_sz >= 64)
 		csr |= MUSB_HSDMA_BURSTMODE_INCR16;
 	else if (packet_sz >= 32)
@@ -136,7 +145,6 @@ static void configure_channel(struct dma
 		csr |= MUSB_HSDMA_BURSTMODE_INCR4;
 
 	csr |= (musb_channel->epnum << MUSB_HSDMA_ENDPOINT_SHIFT)
-		| MUSB_HSDMA_MODE1
 		| MUSB_HSDMA_ENABLE
 		| MUSB_HSDMA_IRQENABLE
 		| (musb_channel->transmit
@@ -194,8 +202,11 @@ static int dma_channel_abort(struct dma_
 				MUSB_EP_OFFSET(musb_channel->epnum,
 						MUSB_TXCSR));
 			csr &= ~(MUSB_TXCSR_AUTOSET |
-				 MUSB_TXCSR_DMAENAB |
-				 MUSB_TXCSR_DMAMODE);
+				 MUSB_TXCSR_DMAENAB);
+			musb_writew(mbase,
+				MUSB_EP_OFFSET(musb_channel->epnum, MUSB_TXCSR),
+				csr);
+			csr &= ~MUSB_TXCSR_DMAMODE;
 			musb_writew(mbase,
 				MUSB_EP_OFFSET(musb_channel->epnum, MUSB_TXCSR),
 				csr);
@@ -204,8 +215,11 @@ static int dma_channel_abort(struct dma_
 				MUSB_EP_OFFSET(musb_channel->epnum,
 						MUSB_RXCSR));
 			csr &= ~(MUSB_RXCSR_AUTOCLEAR |
-				 MUSB_RXCSR_DMAENAB |
-				 MUSB_RXCSR_DMAMODE);
+				 MUSB_RXCSR_DMAENAB);
+			musb_writew(mbase,
+				MUSB_EP_OFFSET(musb_channel->epnum, MUSB_RXCSR),
+				csr);
+			csr &= ~MUSB_RXCSR_DMAMODE;
 			musb_writew(mbase,
 				MUSB_EP_OFFSET(musb_channel->epnum, MUSB_RXCSR),
 				csr);
@@ -228,7 +242,7 @@ static irqreturn_t dma_controller_irq(in
 {
 	struct musb_dma_controller *controller = private_data;
 	struct musb *musb = controller->private_data;
-	struct musb_dma_channel *musb_channel;
+	struct musb_dma_channel *mchannel;
 	struct dma_channel *channel;
 
 	void __iomem *mbase = controller->base;
@@ -250,59 +264,55 @@ static irqreturn_t dma_controller_irq(in
 		goto done;
 
 	for (bchannel = 0; bchannel < MUSB_HSDMA_CHANNELS; bchannel++) {
-		if (int_hsdma & (1 << bchannel)) {
-			musb_channel = (struct musb_dma_channel *)
-					&(controller->channel[bchannel]);
-			channel = &musb_channel->channel;
+		u8 devctl;
 
-			csr = musb_readw(mbase,
-					MUSB_HSDMA_CHANNEL_OFFSET(bchannel,
-							MUSB_HSDMA_CONTROL));
+		if (!(int_hsdma & (1 << bchannel)))
+			continue;
+
+		mchannel = &(controller->channel[bchannel]);
+		channel = &mchannel->channel;
+
+		csr = musb_readw(mbase, MUSB_HSDMA_CHANNEL_OFFSET(bchannel,
+					MUSB_HSDMA_CONTROL));
+
+		if (csr & MUSB_HSDMA_BUSERROR) {
+			mchannel->channel.status = MUSB_DMA_STATUS_BUS_ABORT;
+			goto done;
+		}
 
-			if (csr & MUSB_HSDMA_BUSERROR) {
-				musb_channel->channel.status =
-					MUSB_DMA_STATUS_BUS_ABORT;
-			} else {
-				u8 devctl;
-
-				addr = musb_read_hsdma_addr(mbase,
-						bchannel);
-				channel->actual_len = addr
-					- musb_channel->start_addr;
-
-				DBG(2, "ch %p, 0x%x -> 0x%x (%d / %d) %s\n",
-					channel, musb_channel->start_addr,
-					addr, channel->actual_len,
-					musb_channel->len,
-					(channel->actual_len
-						< musb_channel->len) ?
-					"=> reconfig 0" : "=> complete");
-
-				devctl = musb_readb(mbase, MUSB_DEVCTL);
-
-				channel->status = MUSB_DMA_STATUS_FREE;
-
-				/* completed */
-				if ((devctl & MUSB_DEVCTL_HM)
-					&& (musb_channel->transmit)
-					&& ((channel->desired_mode == 0)
-					    || (channel->actual_len &
-					    (musb_channel->max_packet_sz - 1)))
-					 ) {
-					/* Send out the packet */
-					musb_ep_select(mbase,
-						musb_channel->epnum);
-					musb_writew(mbase, MUSB_EP_OFFSET(
-							musb_channel->epnum,
-							MUSB_TXCSR),
-						MUSB_TXCSR_TXPKTRDY);
-				} else {
-					musb_dma_completion(
-						musb,
-						musb_channel->epnum,
-						musb_channel->transmit);
-				}
-			}
+		addr = musb_read_hsdma_addr(mbase, bchannel);
+		channel->actual_len = addr - mchannel->start_addr;
+
+		DBG(2, "ch %p, 0x%x -> 0x%x (%d / %d) %s\n", channel,
+				mchannel->start_addr, addr,
+				channel->actual_len, mchannel->len,
+				(channel->actual_len < mchannel->len) ?
+				"=> reconfig 0" : "=> complete");
+
+		devctl = musb_readb(mbase, MUSB_DEVCTL);
+		channel->status = MUSB_DMA_STATUS_FREE;
+
+		/* completed */
+		if ((devctl & MUSB_DEVCTL_HM) && (mchannel->transmit)
+				&& ((channel->desired_mode == 0)
+				|| (channel->actual_len &
+				(mchannel->max_packet_sz - 1)))) {
+			u8 txcsr;
+
+			musb_ep_select(mbase, mchannel->epnum);
+			txcsr = musb_readw(mbase, MUSB_EP_OFFSET(
+						mchannel->epnum, MUSB_TXCSR));
+			txcsr &= ~(MUSB_TXCSR_DMAENAB | MUSB_TXCSR_AUTOSET);
+			musb_writew(mbase, MUSB_EP_OFFSET(mchannel->epnum,
+						MUSB_TXCSR), txcsr);
+			txcsr &= ~MUSB_TXCSR_DMAMODE;
+			txcsr |= MUSB_TXCSR_TXPKTRDY;
+			/* Send out the packet */
+			musb_writew(mbase, MUSB_EP_OFFSET(mchannel->epnum,
+						MUSB_TXCSR), txcsr);
+		} else {
+			musb_dma_completion(musb, mchannel->epnum,
+					mchannel->transmit);
 		}
 	}
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/musb/musb_procfs.c kernel-2.6.28-20093908+0m5/drivers/usb/musb/musb_procfs.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/musb/musb_procfs.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/musb/musb_procfs.c	2012-12-16 13:13:01.696330145 +0100
@@ -42,6 +42,8 @@
 
 #include "davinci.h"
 
+extern unsigned musb_debug;
+
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 
 static int dump_qh(struct musb_qh *qh, char *buf, unsigned max)
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/musb/omap2430.c kernel-2.6.28-20093908+0m5/drivers/usb/musb/omap2430.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/musb/omap2430.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/musb/omap2430.c	2012-12-16 13:13:01.696330145 +0100
@@ -249,7 +249,12 @@ int __init musb_platform_init(struct mus
 	l &= ~AUTOIDLE;		/* disable auto idle */
 	l &= ~NOIDLE;		/* remove possible noidle */
 	l |= SMARTIDLE;		/* enable smart idle */
-	l |= AUTOIDLE;		/* enable auto idle */
+	/*
+	 * MUSB AUTOIDLE don't work in 3430.
+	 * Workaround by Richard Woodruff/TI
+	 */
+	if (!cpu_is_omap3430())
+		l |= AUTOIDLE;	/* enable auto idle */
 	omap_writel(l, OTG_SYSCONFIG);
 
 	l = omap_readl(OTG_INTERFSEL);
@@ -341,3 +346,109 @@ int musb_platform_exit(struct musb *musb
 
 	return 0;
 }
+
+#ifdef CONFIG_PM
+
+void musb_save_ctx_and_suspend(struct usb_gadget *gadget, int overwrite)
+{
+	struct musb *musb = gadget_to_musb(gadget);
+	u32 l;
+	unsigned long	flags;
+	unsigned long	tmo;
+
+	spin_lock_irqsave(&musb->lock, flags);
+	if (overwrite)
+		/* Save register context */
+		musb_save_ctx(musb);
+	spin_unlock_irqrestore(&musb->lock, flags);
+
+	DBG(3, "allow sleep\n");
+	/* Do soft reset. This needs to be done with broken AUTOIDLE */
+	tmo = jiffies + msecs_to_jiffies(300);
+	omap_writel(SOFTRST, OTG_SYSCONFIG);
+	while (!omap_readl(OTG_SYSSTATUS)) {
+		if (time_after(jiffies, tmo)) {
+			WARN(1, "musb failed to recover from reset!");
+			break;
+		}
+	}
+
+	l = omap_readl(OTG_FORCESTDBY);
+	l |= ENABLEFORCE;	/* enable MSTANDBY */
+	omap_writel(l, OTG_FORCESTDBY);
+
+	l = ENABLEWAKEUP;	/* enable wakeup */
+	omap_writel(l, OTG_SYSCONFIG);
+	/* Use AUTOIDLE here or the device may fail to hit sleep */
+	l |= AUTOIDLE;
+	omap_writel(l, OTG_SYSCONFIG);
+
+	if (musb->board && musb->board->xceiv_power)
+		musb->board->xceiv_power(0);
+	/* Now it's safe to get rid of the buggy AUTOIDLE */
+	l &= ~AUTOIDLE;
+	omap_writel(l, OTG_SYSCONFIG);
+
+	musb->is_charger = 0;
+
+	/* clear constraints */
+	if (musb->board && musb->board->set_pm_limits)
+		musb->board->set_pm_limits(musb->controller, 0);
+}
+EXPORT_SYMBOL_GPL(musb_save_ctx_and_suspend);
+
+void musb_restore_ctx_and_resume(struct usb_gadget *gadget)
+{
+	struct musb *musb = gadget_to_musb(gadget);
+	u32 l;
+	u8 r;
+	unsigned long	flags;
+
+	DBG(3, "restoring register context\n");
+
+	if (musb->board && musb->board->xceiv_power)
+		musb->board->xceiv_power(1);
+
+	spin_lock_irqsave(&musb->lock, flags);
+	if (musb->set_clock)
+		musb->set_clock(musb->clock, 1);
+	else
+		clk_enable(musb->clock);
+
+	/* Recover OTG control */
+	r = musb_ulpi_readb(musb->mregs, ISP1704_OTG_CTRL);
+	r |= ISP1704_OTG_CTRL_IDPULLUP | ISP1704_OTG_CTRL_DP_PULLDOWN;
+	musb_ulpi_writeb(musb->mregs, ISP1704_OTG_CTRL, r);
+
+	/* Recover FUNC control */
+	r = ISP1704_FUNC_CTRL_FULL_SPEED;
+	r |= ISP1704_FUNC_CTRL_SUSPENDM | ISP1704_FUNC_CTRL_RESET;
+	musb_ulpi_writeb(musb->mregs, ISP1704_FUNC_CTRL, r);
+
+	l = omap_readl(OTG_SYSCONFIG);
+	l &= ~ENABLEWAKEUP;	/* disable wakeup */
+	omap_writel(l, OTG_SYSCONFIG);
+
+	l = omap_readl(OTG_FORCESTDBY);
+	l &= ~ENABLEFORCE;	/* disable MSTANDBY */
+	omap_writel(l, OTG_FORCESTDBY);
+
+	l = omap_readl(OTG_SYSCONFIG);
+	l &= ~ENABLEWAKEUP;	/* disable wakeup */
+	l &= ~NOSTDBY;		/* remove possible nostdby */
+	l |= SMARTSTDBY;	/* enable smart standby */
+	l &= ~AUTOIDLE;		/* disable auto idle */
+	l &= ~NOIDLE;		/* remove possible noidle */
+	l |= SMARTIDLE;		/* enable smart idle */
+	omap_writel(l, OTG_SYSCONFIG);
+
+	l = omap_readl(OTG_INTERFSEL);
+	l |= ULPI_12PIN;
+	omap_writel(l, OTG_INTERFSEL);
+
+	/* Restore register context */
+	musb_restore_ctx(musb);
+	spin_unlock_irqrestore(&musb->lock, flags);
+}
+EXPORT_SYMBOL_GPL(musb_restore_ctx_and_resume);
+#endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/usb/otg/twl4030-usb.c kernel-2.6.28-20093908+0m5/drivers/usb/otg/twl4030-usb.c
--- kernel-2.6.28-20091602+0m5/drivers/usb/otg/twl4030-usb.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/usb/otg/twl4030-usb.c	2012-12-16 13:13:01.696330145 +0100
@@ -475,13 +475,20 @@ static void twl4030_phy_power(struct twl
 	}
 }
 
+extern void musb_save_ctx_and_suspend(struct usb_gadget *gadget, int overwrite);
+extern void musb_restore_ctx_and_resume(struct usb_gadget *gadget);
+
 static void twl4030_phy_suspend(struct twl4030_usb *twl, int controller_off)
 {
 	if (twl->asleep)
 		return;
 
 	twl4030_phy_power(twl, 0);
-	twl->asleep = 1;
+	if (!controller_off)
+		twl->asleep = 1;
+
+	if (twl->otg.gadget)
+		musb_save_ctx_and_suspend(twl->otg.gadget, 0);
 }
 
 static void twl4030_phy_resume(struct twl4030_usb *twl)
@@ -495,6 +502,9 @@ static void twl4030_phy_resume(struct tw
 	if (twl->usb_mode == T2_USB_MODE_ULPI)
 		twl4030_i2c_access(twl, 0);
 	twl->asleep = 0;
+
+	if (twl->otg.gadget)
+		musb_restore_ctx_and_resume(twl->otg.gadget);
 }
 
 static int twl4030_usb_ldo_init(struct twl4030_usb *twl)
@@ -569,6 +579,34 @@ static ssize_t twl4030_usb_vbus_show(str
 }
 static DEVICE_ATTR(vbus, 0444, twl4030_usb_vbus_show, NULL);
 
+static ssize_t twl4030_usb_linkstat_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct twl4030_usb *twl = dev_get_drvdata(dev);
+	unsigned long flags;
+	char *link;
+
+	spin_lock_irqsave(&twl->lock, flags);
+	switch (twl->linkstat) {
+	case USB_LINK_VBUS:
+		link = "vbus";
+		break;
+	case USB_LINK_ID:
+		link = "idpin";
+		break;
+	case USB_LINK_NONE:
+		link = "none";
+		break;
+	default:
+		link = "unknown";
+		break;
+	}
+	spin_unlock_irqrestore(&twl->lock, flags);
+
+	return sprintf(buf, "%s\n", link);
+}
+static DEVICE_ATTR(linkstat, 0444, twl4030_usb_linkstat_show, NULL);
+
 static irqreturn_t twl4030_usb_irq(int irq, void *_twl)
 {
 	struct twl4030_usb *twl = _twl;
@@ -604,6 +642,7 @@ static irqreturn_t twl4030_usb_irq(int i
 			twl4030_phy_resume(twl);
 	}
 	sysfs_notify(&twl->dev->kobj, NULL, "vbus");
+	sysfs_notify(&twl->dev->kobj, NULL, "linkstat");
 
 	return IRQ_HANDLED;
 }
@@ -689,7 +728,10 @@ static int __init twl4030_usb_probe(stru
 
 	platform_set_drvdata(pdev, twl);
 	if (device_create_file(&pdev->dev, &dev_attr_vbus))
-		dev_warn(&pdev->dev, "could not create sysfs file\n");
+		dev_warn(&pdev->dev, "could not create vbus sysfs file\n");
+
+	if (device_create_file(&pdev->dev, &dev_attr_linkstat))
+		dev_warn(&pdev->dev, "could not create linkstat sysfs file\n");
 
 	/* Our job is to use irqs and status from the power module
 	 * to keep the transceiver disabled when nothing's connected.
@@ -731,6 +773,7 @@ static int __exit twl4030_usb_remove(str
 
 	free_irq(twl->irq, twl);
 	device_remove_file(twl->dev, &dev_attr_vbus);
+	device_remove_file(twl->dev, &dev_attr_linkstat);
 
 	/* set transceiver mode to power on defaults */
 	twl4030_usb_set_mode(twl, -1);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/displays/Kconfig kernel-2.6.28-20093908+0m5/drivers/video/omap2/displays/Kconfig
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/displays/Kconfig	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/displays/Kconfig	2012-12-16 13:13:01.704330145 +0100
@@ -25,4 +25,21 @@ config PANEL_ACX565AKM
         help
           LCD Panel used in Rover
 
+config PANEL_GENERIC
+        tristate "Generic Panel"
+        help
+	  Generic panel driver.
+	  Used for DVI output for Beagle and OMAP3 SDP.
+
+config PANEL_SAMSUNG_LTE430WQ_F0C
+        tristate "Samsung LTE430WQ-F0C LCD Panel"
+        depends on OMAP2_DSS
+        help
+          LCD Panel used on Overo Palo43
+
+config PANEL_SHARP_LS037V7DW01
+        tristate "Sharp LS037V7DW01 LCD Panel"
+        depends on OMAP2_DSS
+        help
+          LCD Panel used in TI's SDP3430 and EVM boards
 endmenu
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/displays/Makefile kernel-2.6.28-20093908+0m5/drivers/video/omap2/displays/Makefile
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/displays/Makefile	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/displays/Makefile	2012-12-16 13:13:01.704330145 +0100
@@ -3,3 +3,7 @@ obj-$(CONFIG_CTRL_ZONDA) += ctrl-zonda.o
 
 obj-$(CONFIG_PANEL_TAAL) += panel-taal.o
 obj-$(CONFIG_PANEL_ACX565AKM) += panel-acx565akm.o
+
+obj-$(CONFIG_PANEL_GENERIC) += panel-generic.o
+obj-$(CONFIG_PANEL_SAMSUNG_LTE430WQ_F0C) += panel-samsung-lte430wq-f0c.o
+obj-$(CONFIG_PANEL_SHARP_LS037V7DW01) += panel-sharp-ls037v7dw01.o
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/displays/panel-acx565akm.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/displays/panel-acx565akm.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/displays/panel-acx565akm.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/displays/panel-acx565akm.c	2012-12-16 13:13:01.704330145 +0100
@@ -48,9 +48,9 @@ struct acx565akm_device {
 	int		model;
 	int		revision;
 	u8		display_id[3];
-	int		has_bc:1;
-	int		has_cabc:1;
-	unsigned int	saved_bklight_level;
+	unsigned	has_bc:1;
+	unsigned	has_cabc:1;
+	unsigned	cabc_mode;
 	unsigned long	hw_guard_end;		/* next value of jiffies
 						   when we can issue the
 						   next sleep in/out command */
@@ -149,23 +149,19 @@ static void hw_guard_wait(struct acx565a
 
 static void set_sleep_mode(struct acx565akm_device *md, int on)
 {
-	int cmd, sleep_time = 50;
+	int cmd;
 
 	if (on)
 		cmd = MIPID_CMD_SLEEP_IN;
 	else
 		cmd = MIPID_CMD_SLEEP_OUT;
+	/*
+	 * We have to keep 120msec between sleep in/out commands.
+	 * (8.2.15, 8.2.16).
+	 */
 	hw_guard_wait(md);
 	acx565akm_cmd(md, cmd);
 	hw_guard_start(md, 120);
-	/*
-	 * When we enable the panel, it seems we _have_ to sleep
-	 * 120 ms before sending the init string. When disabling the
-	 * panel we'll sleep for the duration of 2 frames, so that the
-	 * controller can still provide the PCLK,HS,VS signals. */
-	if (!on)
-		sleep_time = 120;
-	msleep(sleep_time);
 }
 
 static void set_display_state(struct acx565akm_device *md, int enabled)
@@ -206,10 +202,13 @@ static void enable_backlight_ctrl(struct
 	acx565akm_write(md, MIPID_CMD_WRITE_CTRL_DISP, (u8 *)&ctrl, 2);
 }
 
-static void set_cabc_mode(struct acx565akm_device *md, int mode)
+static void set_cabc_mode(struct acx565akm_device *md, unsigned mode)
 {
 	u16 cabc_ctrl;
 
+	md->cabc_mode = mode;
+	if (!md->enabled)
+		return;
 	cabc_ctrl = 0;
 	acx565akm_read(md, MIPID_CMD_READ_CABC, (u8 *)&cabc_ctrl, 1);
 	cabc_ctrl &= ~3;
@@ -217,7 +216,12 @@ static void set_cabc_mode(struct acx565a
 	acx565akm_write(md, MIPID_CMD_WRITE_CABC, (u8 *)&cabc_ctrl, 2);
 }
 
-static int get_cabc_mode(struct acx565akm_device *md)
+static unsigned get_cabc_mode(struct acx565akm_device *md)
+{
+	return md->cabc_mode;
+}
+
+static unsigned get_hw_cabc_mode(struct acx565akm_device *md)
 {
 	u8 cabc_ctrl;
 
@@ -276,17 +280,29 @@ static int acx565akm_panel_enable(struct
 	if (display->hw_config.panel_enable != NULL)
 		display->hw_config.panel_enable(display);
 
-	md->enabled = panel_enabled(md);
-
 	if (md->enabled) {
 		dev_dbg(&md->spi->dev, "panel already enabled\n");
 		mutex_unlock(&md->mutex);
 		return 0;
 	}
 
+	/*
+	 * We have to meet all the following delay requirements:
+	 * 1. tRW: reset pulse width 10usec (7.12.1)
+	 * 2. tRT: reset cancel time 5msec (7.12.1)
+	 * 3. Providing PCLK,HS,VS signals for 2 frames = ~50msec worst
+	 *    case (7.6.2)
+	 * 4. 120msec before the sleep out command (7.12.1)
+	 */
+	msleep(120);
+
 	set_sleep_mode(md, 0);
 	md->enabled = 1;
+
+	/* 5msec between sleep out and the next command. (8.2.16) */
+	msleep(5);
 	set_display_state(md, 1);
+	set_cabc_mode(md, md->cabc_mode);
 
 	mutex_unlock(&md->mutex);
 
@@ -309,6 +325,13 @@ static void acx565akm_panel_disable(stru
 	set_display_state(md, 0);
 	set_sleep_mode(md, 1);
 	md->enabled = 0;
+	/*
+	 * We have to provide PCLK,HS,VS signals for 2 frames (worst case
+	 * ~50msec) after sending the sleep in command and asserting the
+	 * reset signal. We probably could assert the reset w/o the delay
+	 * but we still delay to avoid possible artifacts. (7.6.1)
+	 */
+	msleep(50);
 
 	if (display->hw_config.panel_disable != NULL)
 		display->hw_config.panel_disable(display);
@@ -548,6 +571,11 @@ static int acx565akm_panel_init(struct o
 
 	if (display->hw_config.panel_enable != NULL)
 		display->hw_config.panel_enable(display);
+	/*
+	 * After reset we have to wait 5 msec before the first
+	 * command can be sent.
+	 */
+	msleep(5);
 
 	md->enabled = panel_enabled(md);
 
@@ -583,6 +611,7 @@ static int acx565akm_panel_init(struct o
 			backlight_device_unregister(bldev);
 			return r;
 		}
+		md->cabc_mode = get_hw_cabc_mode(md);
 	}
 
 	bldev->props.fb_blank = FB_BLANK_UNBLANK;
@@ -622,15 +651,17 @@ static struct omap_panel acx565akm_panel
 		.pixel_clock	= 24000,
 
 		.hsw		= 4,
-		.hfp		= 16,
-		.hbp		= 12,
+		.hfp		= 28,
+		.hbp		= 24,
 
 		.vsw		= 3,
 		.vfp		= 3,
-		.vbp		= 3,
+		.vbp		= 4,
 	},
 
-	.config		= OMAP_DSS_LCD_TFT,
+	.config		= OMAP_DSS_LCD_TFT |
+			  OMAP_DSS_LCD_IVS |
+			  OMAP_DSS_LCD_IHS,
 
 	.recommended_bpp = 16,
 
@@ -644,7 +675,7 @@ static int acx565akm_spi_probe(struct sp
 {
 	struct acx565akm_device *md;
 
-	dev_dbg(&md->spi->dev, "%s\n", __func__);
+	dev_dbg(&spi->dev, "%s\n", __func__);
 
 	md = kzalloc(sizeof(*md), GFP_KERNEL);
 	if (md == NULL) {
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/displays/panel-generic.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/displays/panel-generic.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/displays/panel-generic.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/displays/panel-generic.c	2012-12-16 13:13:01.704330145 +0100
@@ -0,0 +1,96 @@
+/*
+ * Generic panel support
+ *
+ * Copyright (C) 2008 Nokia Corporation
+ * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+
+#include <mach/display.h>
+
+static int generic_panel_init(struct omap_display *display)
+{
+	return 0;
+}
+
+static int generic_panel_enable(struct omap_display *display)
+{
+	int r = 0;
+
+	if (display->hw_config.panel_enable)
+		r = display->hw_config.panel_enable(display);
+
+	return r;
+}
+
+static void generic_panel_disable(struct omap_display *display)
+{
+	if (display->hw_config.panel_disable)
+		display->hw_config.panel_disable(display);
+}
+
+static int generic_panel_suspend(struct omap_display *display)
+{
+	generic_panel_disable(display);
+	return 0;
+}
+
+static int generic_panel_resume(struct omap_display *display)
+{
+	return generic_panel_enable(display);
+}
+
+static struct omap_panel generic_panel = {
+	.owner		= THIS_MODULE,
+	.name		= "panel-generic",
+	.init		= generic_panel_init,
+	.enable		= generic_panel_enable,
+	.disable	= generic_panel_disable,
+	.suspend	= generic_panel_suspend,
+	.resume		= generic_panel_resume,
+
+	.timings = {
+		/* 640 x 480 @ 60 Hz  Reduced blanking VESA CVT 0.31M3-R */
+		.x_res		= 640,
+		.y_res		= 480,
+		.pixel_clock	= 23500,
+		.hfp		= 48,
+		.hsw		= 32,
+		.hbp		= 80,
+		.vfp		= 3,
+		.vsw		= 4,
+		.vbp		= 7,
+	},
+
+	.config		= OMAP_DSS_LCD_TFT,
+};
+
+
+static int __init generic_panel_drv_init(void)
+{
+	omap_dss_register_panel(&generic_panel);
+	return 0;
+}
+
+static void __exit generic_panel_drv_exit(void)
+{
+	omap_dss_unregister_panel(&generic_panel);
+}
+
+module_init(generic_panel_drv_init);
+module_exit(generic_panel_drv_exit);
+MODULE_LICENSE("GPL");
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/displays/panel-nevada.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/displays/panel-nevada.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/displays/panel-nevada.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/displays/panel-nevada.c	2012-12-16 13:13:01.704330145 +0100
@@ -485,8 +485,6 @@ static struct omap_panel nevada_panel =
 	},
 	.config		= OMAP_DSS_LCD_TFT,
 
-	.recommended_bpp = 16,
-
 	/* supported modes: 12bpp(444), 16bpp(565), 18bpp(666),  24bpp(888)
 	 * resolutions */
 };
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/displays/panel-samsung-lte430wq-f0c.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/displays/panel-samsung-lte430wq-f0c.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/displays/panel-samsung-lte430wq-f0c.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/displays/panel-samsung-lte430wq-f0c.c	2012-12-16 13:13:01.704330145 +0100
@@ -0,0 +1,108 @@
+/*
+ * LCD panel driver for Samsung LTE430WQ-F0C
+ *
+ * Author: Steve Sakoman <steve@sakoman.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+
+#include <mach/display.h>
+
+static int samsung_lte_panel_init(struct omap_display *display)
+{
+	return 0;
+}
+
+static void samsung_lte_panel_cleanup(struct omap_display *display)
+{
+}
+
+static int samsung_lte_panel_enable(struct omap_display *display)
+{
+	int r = 0;
+
+	/* wait couple of vsyncs until enabling the LCD */
+	msleep(50);
+
+	if (display->hw_config.panel_enable)
+		r = display->hw_config.panel_enable(display);
+
+	return r;
+}
+
+static void samsung_lte_panel_disable(struct omap_display *display)
+{
+	if (display->hw_config.panel_disable)
+		display->hw_config.panel_disable(display);
+
+	/* wait at least 5 vsyncs after disabling the LCD */
+	msleep(100);
+}
+
+static int samsung_lte_panel_suspend(struct omap_display *display)
+{
+	samsung_lte_panel_disable(display);
+	return 0;
+}
+
+static int samsung_lte_panel_resume(struct omap_display *display)
+{
+	return samsung_lte_panel_enable(display);
+}
+
+static struct omap_panel samsung_lte_panel = {
+	.owner		= THIS_MODULE,
+	.name		= "samsung-lte430wq-f0c",
+	.init		= samsung_lte_panel_init,
+	.cleanup	= samsung_lte_panel_cleanup,
+	.enable		= samsung_lte_panel_enable,
+	.disable	= samsung_lte_panel_disable,
+	.suspend	= samsung_lte_panel_suspend,
+	.resume		= samsung_lte_panel_resume,
+
+	.timings = {
+		.x_res = 480,
+		.y_res = 272,
+
+		.pixel_clock	= 9200,
+
+		.hsw		= 41,
+		.hfp		= 8,
+		.hbp		= 45-41,
+
+		.vsw		= 10,
+		.vfp		= 4,
+		.vbp		= 12-10,
+	},
+
+	.config = OMAP_DSS_LCD_TFT | OMAP_DSS_LCD_IHS | OMAP_DSS_LCD_IVS,
+};
+
+
+static int __init samsung_lte_panel_drv_init(void)
+{
+	omap_dss_register_panel(&samsung_lte_panel);
+	return 0;
+}
+
+static void __exit samsung_lte_panel_drv_exit(void)
+{
+	omap_dss_unregister_panel(&samsung_lte_panel);
+}
+
+module_init(samsung_lte_panel_drv_init);
+module_exit(samsung_lte_panel_drv_exit);
+MODULE_LICENSE("GPL");
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/displays/panel-sharp-ls037v7dw01.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/displays/panel-sharp-ls037v7dw01.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/displays/panel-sharp-ls037v7dw01.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/displays/panel-sharp-ls037v7dw01.c	2012-12-16 13:13:01.704330145 +0100
@@ -0,0 +1,112 @@
+/*
+ * LCD panel driver for Sharp LS037V7DW01
+ *
+ * Copyright (C) 2008 Nokia Corporation
+ * Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+
+#include <mach/display.h>
+
+static int sharp_ls_panel_init(struct omap_display *display)
+{
+	return 0;
+}
+
+static void sharp_ls_panel_cleanup(struct omap_display *display)
+{
+}
+
+static int sharp_ls_panel_enable(struct omap_display *display)
+{
+	int r = 0;
+
+	/* wait couple of vsyncs until enabling the LCD */
+	msleep(50);
+
+	if (display->hw_config.panel_enable)
+		r = display->hw_config.panel_enable(display);
+
+	return r;
+}
+
+static void sharp_ls_panel_disable(struct omap_display *display)
+{
+	if (display->hw_config.panel_disable)
+		display->hw_config.panel_disable(display);
+
+	/* wait at least 5 vsyncs after disabling the LCD */
+
+	msleep(100);
+}
+
+static int sharp_ls_panel_suspend(struct omap_display *display)
+{
+	sharp_ls_panel_disable(display);
+	return 0;
+}
+
+static int sharp_ls_panel_resume(struct omap_display *display)
+{
+	return sharp_ls_panel_enable(display);
+}
+
+static struct omap_panel sharp_ls_panel = {
+	.owner		= THIS_MODULE,
+	.name		= "sharp-ls037v7dw01",
+	.init		= sharp_ls_panel_init,
+	.cleanup	= sharp_ls_panel_cleanup,
+	.enable		= sharp_ls_panel_enable,
+	.disable	= sharp_ls_panel_disable,
+	.suspend	= sharp_ls_panel_suspend,
+	.resume		= sharp_ls_panel_resume,
+
+	.timings = {
+		.x_res = 480,
+		.y_res = 640,
+
+		.pixel_clock	= 19200,
+
+		.hsw		= 2,
+		.hfp		= 1,
+		.hbp		= 28,
+
+		.vsw		= 1,
+		.vfp		= 1,
+		.vbp		= 1,
+	},
+
+	.acb		= 0x28,
+
+	.config	= OMAP_DSS_LCD_TFT | OMAP_DSS_LCD_IVS |	OMAP_DSS_LCD_IHS,
+};
+
+
+static int __init sharp_ls_panel_drv_init(void)
+{
+	omap_dss_register_panel(&sharp_ls_panel);
+	return 0;
+}
+
+static void __exit sharp_ls_panel_drv_exit(void)
+{
+	omap_dss_unregister_panel(&sharp_ls_panel);
+}
+
+module_init(sharp_ls_panel_drv_init);
+module_exit(sharp_ls_panel_drv_exit);
+MODULE_LICENSE("GPL");
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/displays/panel-taal.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/displays/panel-taal.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/displays/panel-taal.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/displays/panel-taal.c	2012-12-16 13:13:01.704330145 +0100
@@ -592,8 +592,6 @@ static struct omap_panel taal_panel = {
 		.x_res = 864,
 		.y_res = 480,
 	},
-
-	.recommended_bpp = 16,
 };
 
 static int __init taal_init(void)
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/core.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/core.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/core.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/core.c	2012-12-16 13:13:01.704330145 +0100
@@ -30,15 +30,18 @@
 #include <linux/seq_file.h>
 #include <linux/debugfs.h>
 #include <linux/io.h>
+#include <linux/workqueue.h>
+#include <linux/spinlock.h>
 
 #include <mach/display.h>
 #include <mach/clock.h>
+#include <mach/omap-pm.h>
 
 #include "dss.h"
 
 static struct {
 	struct platform_device *pdev;
-	unsigned	ctx_id;
+	int		ctx_id;
 
 	struct clk      *dss_ick;
 	struct clk	*dss1_fck;
@@ -46,6 +49,15 @@ static struct {
 	struct clk      *dss_54m_fck;
 	struct clk	*dss_96m_fck;
 	unsigned	num_clks_enabled;
+
+	struct delayed_work bus_tput_work;
+	unsigned int bus_tput;
+
+	bool reset_pending;
+	spinlock_t reset_lock;
+	struct work_struct reset_work;
+
+	struct mutex dss_lock;
 } core;
 
 static void dss_clk_enable_all_no_ctx(void);
@@ -63,26 +75,39 @@ module_param_named(debug, dss_debug, boo
 #endif
 
 /* CONTEXT */
-static unsigned dss_get_ctx_id(void)
+static int dss_get_ctx_id(void)
 {
 	struct omap_dss_board_info *pdata = core.pdev->dev.platform_data;
+	int r;
 
 	if (!pdata->get_last_off_on_transaction_id)
 		return 0;
-
-	return pdata->get_last_off_on_transaction_id(&core.pdev->dev);
+	r = pdata->get_last_off_on_transaction_id(&core.pdev->dev);
+	if (r < 0) {
+		dev_err(&core.pdev->dev,
+			"getting transaction ID failed, will force context restore\n");
+		r = -1;
+	}
+	return r;
 }
 
 int dss_need_ctx_restore(void)
 {
 	int id = dss_get_ctx_id();
 
-	if (id != core.ctx_id) {
-		DSSDBG("ctx id %u -> id %u\n",
+	if (id < 0 || id != core.ctx_id) {
+		DSSDBG("ctx id %d -> id %d\n",
 				core.ctx_id, id);
 		core.ctx_id = id;
 		return 1;
 	} else {
+		/* Hack to workaround context loss */
+		if (dss_check_context()) {
+			DSSERR("unexpected HW context loss, will force context restore (id=%d)\n",
+			       id);
+			return 1;
+		}
+
 		return 0;
 	}
 }
@@ -93,12 +118,19 @@ static void save_all_ctx(void)
 
 	dss_clk_enable_no_ctx(DSS_CLK_ICK | DSS_CLK_FCK1);
 
+	/* Hack to workaround context loss */
+	if (dss_check_context()) {
+		DSSERR("HW context corrupted, skipping save\n");
+		goto out;
+	}
+
 	dss_save_context();
 	dispc_save_context();
 #ifdef CONFIG_OMAP2_DSS_DSI
 	dsi_save_context();
 #endif
 
+ out:
 	dss_clk_disable_no_ctx(DSS_CLK_ICK | DSS_CLK_FCK1);
 }
 
@@ -324,6 +356,16 @@ static void dss_clk_disable_all_no_ctx(v
 	dss_clk_disable_no_ctx(clks);
 }
 
+static void dss_clk_enable_all(void)
+{
+	enum dss_clock clks;
+
+	clks = DSS_CLK_ICK | DSS_CLK_FCK1 | DSS_CLK_FCK2 | DSS_CLK_54M;
+	if (cpu_is_omap34xx())
+		clks |= DSS_CLK_96M;
+	dss_clk_enable(clks);
+}
+
 static void dss_clk_disable_all(void)
 {
 	enum dss_clock clks;
@@ -390,6 +432,10 @@ static int dss_initialize_debugfs(void)
 	debugfs_create_file("dsi", S_IRUGO, dss_debugfs_dir,
 			&dsi_dump_regs, &dss_debug_fops);
 #endif
+#ifdef CONFIG_OMAP2_DSS_VENC
+	debugfs_create_file("venc", S_IRUGO, dss_debugfs_dir,
+			&venc_dump_regs, &dss_debug_fops);
+#endif
 	return 0;
 }
 
@@ -400,6 +446,139 @@ static void dss_uninitialize_debugfs(voi
 }
 #endif /* CONFIG_DEBUG_FS && CONFIG_OMAP2_DSS_DEBUG_SUPPORT */
 
+void omap_dss_lock(void)
+{
+	mutex_lock(&core.dss_lock);
+}
+EXPORT_SYMBOL(omap_dss_lock);
+
+void omap_dss_unlock(void)
+{
+	mutex_unlock(&core.dss_lock);
+}
+EXPORT_SYMBOL(omap_dss_unlock);
+
+/* RESET */
+
+void dss_schedule_reset(void)
+{
+	unsigned long flags;
+
+	DSSDBG("schduling a soft reset\n");
+
+	spin_lock_irqsave(&core.reset_lock, flags);
+	if (core.reset_pending) {
+		spin_unlock_irqrestore(&core.reset_lock, flags);
+		return;
+	}
+
+	core.reset_pending = true;
+	schedule_work(&core.reset_work);
+
+	spin_unlock_irqrestore(&core.reset_lock, flags);
+}
+
+static void reset_work_func(struct work_struct *work)
+{
+	DSSDBG("performing soft reset\n");
+
+	spin_lock_irq(&core.reset_lock);
+	if (!core.reset_pending) {
+		spin_unlock_irq(&core.reset_lock);
+		return;
+	}
+	spin_unlock_irq(&core.reset_lock);
+
+	omap_dss_lock();
+	dss_clk_enable_all();
+	dss_suspend_all_displays();
+	save_all_ctx();
+
+	dss_reset();
+
+	restore_all_ctx();
+	dss_resume_all_displays();
+	dss_clk_disable_all();
+	omap_dss_unlock();
+
+	spin_lock_irq(&core.reset_lock);
+	core.reset_pending = false;
+	spin_unlock_irq(&core.reset_lock);
+
+	DSSDBG("done with soft reset\n");
+}
+
+/* DVFS */
+
+static void bus_tput_work_func(struct work_struct *work)
+{
+	struct omap_dss_board_info *pdata = core.pdev->dev.platform_data;
+
+	DSSDBG("setting bus throughput to %d KiB/s\n", core.bus_tput);
+	pdata->set_min_bus_tput(&core.pdev->dev,
+			OCP_INITIATOR_AGENT, core.bus_tput);
+}
+
+static void set_min_bus_tput(unsigned int num_overlays)
+{
+	struct omap_dss_board_info *pdata = core.pdev->dev.platform_data;
+	/*
+	 * Magic value 400000 chosen so that on OMAP3 OPP3 is used.
+	 */
+	unsigned int tput_max = 400000;
+	unsigned int tput = num_overlays ? 400000 : 0;
+
+	if (!pdata->set_min_bus_tput || tput == core.bus_tput)
+		return;
+
+	cancel_delayed_work_sync(&core.bus_tput_work);
+
+	core.bus_tput = tput;
+
+	/* Switch to the maximum when the FIFOs are empty. */
+	DSSDBG("setting bus throughput to %d KiB/s\n", tput_max);
+	pdata->set_min_bus_tput(&core.pdev->dev, OCP_INITIATOR_AGENT, tput_max);
+
+	if (tput == tput_max)
+		return;
+
+	/* Switch to whatever was requested after things have stabilized. */
+	schedule_delayed_work(&core.bus_tput_work, msecs_to_jiffies(2000));
+}
+
+void omap_dss_maximize_min_bus_tput(void)
+{
+	set_min_bus_tput(omap_dss_get_num_overlays());
+}
+
+void omap_dss_update_min_bus_tput(void)
+{
+	int i;
+	struct omap_display *display;
+	struct omap_overlay *ovl;
+	int num_overlays = 0;
+
+	DSSDBG("dss_update_min_bus_tput()\n");
+
+	/* Determine how many overlays are actually fetching data */
+	for (i = 0; i < omap_dss_get_num_overlays(); ++i) {
+		ovl = omap_dss_get_overlay(i);
+
+		if (!(ovl->caps & OMAP_DSS_OVL_CAP_DISPC))
+			continue;
+
+		if (!ovl->info.enabled || !ovl->manager)
+			continue;
+
+		display = ovl->manager->display;
+		if (!display || display->state != OMAP_DSS_DISPLAY_ACTIVE)
+			continue;
+
+		num_overlays++;
+	}
+
+	set_min_bus_tput(num_overlays);
+}
 
 /* DSI powers */
 int dss_dsi_power_up(void)
@@ -422,6 +601,11 @@ void dss_dsi_power_down(void)
 	pdata->dsi_power_down();
 }
 
+const char *dss_get_def_disp_name(void)
+{
+	return def_disp_name ? def_disp_name : "";
+}
+
 
 
 /* PLATFORM DEVICE */
@@ -473,7 +657,7 @@ static int omap_dss_probe(struct platfor
 		goto fail0;
 	}
 #ifdef CONFIG_OMAP2_DSS_VENC
-	r = venc_init();
+	r = venc_init(core.pdev);
 	if (r) {
 		DSSERR("Failed to initialize venc\n");
 		goto fail0;
@@ -504,10 +688,18 @@ static int omap_dss_probe(struct platfor
 
 	dss_init_displays(pdev);
 	dss_init_overlay_managers(pdev);
-	dss_init_overlays(pdev, def_disp_name);
+	dss_init_overlays(pdev);
 
 	dss_clk_disable_all();
 
+	INIT_DELAYED_WORK(&core.bus_tput_work, bus_tput_work_func);
+
+	core.reset_pending = false;
+	spin_lock_init(&core.reset_lock);
+	INIT_WORK(&core.reset_work, reset_work_func);
+
+	mutex_init(&core.dss_lock);
+
 	return 0;
 
 	/* XXX fail correctly */
@@ -517,8 +709,16 @@ fail0:
 
 static int omap_dss_remove(struct platform_device *pdev)
 {
+	struct omap_dss_board_info *pdata = pdev->dev.platform_data;
 	int c;
 
+	cancel_work_sync(&core.reset_work);
+	core.reset_pending = false;
+
+	cancel_delayed_work_sync(&core.bus_tput_work);
+	if (pdata->set_min_bus_tput)
+		pdata->set_min_bus_tput(&core.pdev->dev, OCP_INITIATOR_AGENT, 0);
+
 	dss_uninit_overlays(pdev);
 	dss_uninit_overlay_managers(pdev);
 	dss_uninit_displays(pdev);
@@ -597,16 +797,29 @@ static void omap_dss_shutdown(struct pla
 
 static int omap_dss_suspend(struct platform_device *pdev, pm_message_t state)
 {
+	int ret;
+
 	DSSDBG("suspend %d\n", state.event);
 
-	return dss_suspend_all_displays();
+	omap_dss_lock();
+	ret = dss_suspend_all_displays();
+	omap_dss_unlock();
+
+	return ret;
+
 }
 
 static int omap_dss_resume(struct platform_device *pdev)
 {
+	int ret;
+
 	DSSDBG("resume\n");
 
-	return dss_resume_all_displays();
+	omap_dss_lock();
+	ret =  dss_resume_all_displays();
+	omap_dss_unlock();
+
+	return ret;
 }
 
 static struct platform_driver omap_dss_driver = {
@@ -631,7 +844,7 @@ static void __exit omap_dss_exit(void)
 	platform_driver_unregister(&omap_dss_driver);
 }
 
-subsys_initcall(omap_dss_init);
+device_initcall(omap_dss_init);
 module_exit(omap_dss_exit);
 
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/dispc.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/dispc.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/dispc.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/dispc.c	2012-12-16 13:13:01.704330145 +0100
@@ -154,23 +154,20 @@ static struct {
 
 	struct clk	*dpll4_m4_ck;
 
-	spinlock_t	irq_lock;
-
 	unsigned long	cache_req_pck;
 	unsigned long	cache_prate;
 	struct dispc_clock_info cache_cinfo;
 
-	u32		irq_error_mask;
+	spinlock_t irq_lock;
+	u32 irq_error_mask;
 	struct omap_dispc_isr_data registered_isr[DISPC_MAX_NR_ISRS];
-
-	spinlock_t error_lock;
 	u32 error_irqs;
 	struct work_struct error_work;
 
 	u32		ctx[DISPC_SZ_REGS / sizeof(u32)];
 } dispc;
 
-static void omap_dispc_set_irqs(void);
+static void _omap_dispc_set_irqs(void);
 
 static inline void dispc_write_reg(const struct dispc_reg idx, u32 val)
 {
@@ -788,6 +785,20 @@ static void _dispc_set_vid_size(enum oma
 	dispc_write_reg(vsi_reg[plane-1], val);
 }
 
+static void _dispc_setup_global_alpha(enum omap_plane plane, u8 global_alpha)
+{
+
+	BUG_ON(plane == OMAP_DSS_VIDEO1);
+
+	if (cpu_is_omap24xx())
+		return;
+
+	if (plane == OMAP_DSS_GFX)
+		REG_FLD_MOD(DISPC_GLOBAL_ALPHA, global_alpha, 7, 0);
+	else if (plane == OMAP_DSS_VIDEO2)
+		REG_FLD_MOD(DISPC_GLOBAL_ALPHA, global_alpha, 23, 16);
+}
+
 static void _dispc_set_pix_inc(enum omap_plane plane, s32 inc)
 {
 	const struct dispc_reg ri_reg[] = { DISPC_GFX_PIXEL_INC,
@@ -806,6 +817,24 @@ static void _dispc_set_row_inc(enum omap
 	dispc_write_reg(ri_reg[plane], inc);
 }
 
+static s32 _dispc_get_pix_inc(enum omap_plane plane)
+{
+	const struct dispc_reg ri_reg[] = { DISPC_GFX_PIXEL_INC,
+				     DISPC_VID_PIXEL_INC(0),
+				     DISPC_VID_PIXEL_INC(1) };
+
+	return dispc_read_reg(ri_reg[plane]);
+}
+
+static s32 _dispc_get_row_inc(enum omap_plane plane)
+{
+	const struct dispc_reg ri_reg[] = { DISPC_GFX_ROW_INC,
+				     DISPC_VID_ROW_INC(0),
+				     DISPC_VID_ROW_INC(1) };
+
+	return dispc_read_reg(ri_reg[plane]);
+}
+
 static void _dispc_set_color_mode(enum omap_plane plane,
 		enum omap_color_mode color_mode)
 {
@@ -847,6 +876,44 @@ static void _dispc_set_color_mode(enum o
 	REG_FLD_MOD(dispc_reg_att[plane], m, 4, 1);
 }
 
+static enum omap_color_mode _dispc_get_color_mode(enum omap_plane plane)
+{
+	u32 m = REG_GET(dispc_reg_att[plane], 4, 1);
+
+	switch (m) {
+	case 0x0:
+		return OMAP_DSS_COLOR_CLUT1;
+	case 0x1:
+		return OMAP_DSS_COLOR_CLUT2;
+	case 0x2:
+		return OMAP_DSS_COLOR_CLUT4;
+	case 0x3:
+		return OMAP_DSS_COLOR_CLUT8;
+	case 0x4:
+		return OMAP_DSS_COLOR_RGB12U;
+	case 0x5:
+		return OMAP_DSS_COLOR_ARGB16;
+	case 0x6:
+		return OMAP_DSS_COLOR_RGB16;
+	case 0x8:
+		return OMAP_DSS_COLOR_RGB24U;
+	case 0x9:
+		return OMAP_DSS_COLOR_RGB24P;
+	case 0xa:
+		return OMAP_DSS_COLOR_YUV2;
+	case 0xb:
+		return OMAP_DSS_COLOR_UYVY;
+	case 0xc:
+		return OMAP_DSS_COLOR_ARGB32;
+	case 0xd:
+		return OMAP_DSS_COLOR_RGBA32;
+	case 0xe:
+		return OMAP_DSS_COLOR_RGBX32;
+	default:
+		BUG();
+	}
+}
+
 static void _dispc_set_channel_out(enum omap_plane plane,
 		enum omap_channel channel)
 {
@@ -910,6 +977,20 @@ static void _dispc_set_vid_color_conv(en
 	dispc_write_reg(dispc_reg_att[plane], val);
 }
 
+void dispc_enable_replication(enum omap_plane plane, bool enable)
+{
+	int bit;
+
+	if (plane == OMAP_DSS_GFX)
+		bit = 5;
+	else
+		bit = 10;
+
+	enable_clocks(1);
+	REG_FLD_MOD(dispc_reg_att[plane], enable, bit, bit);
+	enable_clocks(0);
+}
+
 void dispc_set_lcd_size(u16 width, u16 height)
 {
 	u32 val;
@@ -1004,7 +1085,10 @@ static void _dispc_set_fir(enum omap_pla
 
 	BUG_ON(plane == OMAP_DSS_GFX);
 
-	val = FLD_VAL(vinc, 27, 16) | FLD_VAL(hinc, 11, 0);
+	if (cpu_is_omap24xx())
+		val = FLD_VAL(vinc, 27, 16) | FLD_VAL(hinc, 11, 0);
+	else
+		val = FLD_VAL(vinc, 28, 16) | FLD_VAL(hinc, 12, 0);
 	dispc_write_reg(fir_reg[plane-1], val);
 }
 
@@ -1036,12 +1120,12 @@ static void _dispc_set_vid_accu1(enum om
 static void _dispc_set_scaling(enum omap_plane plane,
 		u16 orig_width, u16 orig_height,
 		u16 out_width, u16 out_height,
-		bool ilace, bool five_taps)
+		bool ilace, bool five_taps,
+		bool fieldmode)
 {
 	int fir_hinc;
 	int fir_vinc;
 	int hscaleup, vscaleup;
-	int fieldmode = 0;
 	int accu0 = 0;
 	int accu1 = 0;
 	u32 l;
@@ -1079,17 +1163,16 @@ static void _dispc_set_scaling(enum omap
 
 	dispc_write_reg(dispc_reg_att[plane], l);
 
-	if (ilace) {
-		if (fieldmode) {
-			accu0 = fir_vinc / 2;
-			accu1 = 0;
-		} else {
-			accu0 = 0;
-			accu1 = fir_vinc / 2;
-			if (accu1 >= 1024/2) {
-				accu0 = 1024/2;
-				accu1 -= accu0;
-			}
+	/*
+	 * field 0 = even field = bottom field
+	 * field 1 = odd field = top field
+	 */
+	if (ilace && !fieldmode) {
+		accu1 = 0;
+		accu0 = (fir_vinc / 2) & 0x3ff;
+		if (accu0 >= 1024/2) {
+			accu1 = 1024/2;
+			accu0 -= accu1;
 		}
 	}
 
@@ -1106,23 +1189,39 @@ static void _dispc_set_rotation_attrs(en
 
 		if (mirroring) {
 			switch (rotation) {
-			case 0: vidrot = 2; break;
-			case 1: vidrot = 3; break;
-			case 2: vidrot = 0; break;
-			case 3: vidrot = 1; break;
+			case OMAP_DSS_ROT_0:
+				vidrot = 2;
+				break;
+			case OMAP_DSS_ROT_90:
+				vidrot = 1;
+				break;
+			case OMAP_DSS_ROT_180:
+				vidrot = 0;
+				break;
+			case OMAP_DSS_ROT_270:
+				vidrot = 3;
+				break;
 			}
 		} else {
 			switch (rotation) {
-			case 0: vidrot = 0; break;
-			case 1: vidrot = 1; break;
-			case 2: vidrot = 2; break;
-			case 3: vidrot = 1; break;
+			case OMAP_DSS_ROT_0:
+				vidrot = 0;
+				break;
+			case OMAP_DSS_ROT_90:
+				vidrot = 1;
+				break;
+			case OMAP_DSS_ROT_180:
+				vidrot = 2;
+				break;
+			case OMAP_DSS_ROT_270:
+				vidrot = 3;
+				break;
 			}
 		}
 
 		REG_FLD_MOD(dispc_reg_att[plane], vidrot, 13, 12);
 
-		if (rotation == 1 || rotation == 3)
+		if (rotation == OMAP_DSS_ROT_90 || rotation == OMAP_DSS_ROT_270)
 			REG_FLD_MOD(dispc_reg_att[plane], 0x1, 18, 18);
 		else
 			REG_FLD_MOD(dispc_reg_att[plane], 0x0, 18, 18);
@@ -1132,6 +1231,163 @@ static void _dispc_set_rotation_attrs(en
 	}
 }
 
+static int color_mode_to_bpp(enum omap_color_mode color_mode)
+{
+	switch (color_mode) {
+	case OMAP_DSS_COLOR_CLUT1:
+		return 1;
+	case OMAP_DSS_COLOR_CLUT2:
+		return 2;
+	case OMAP_DSS_COLOR_CLUT4:
+		return 4;
+	case OMAP_DSS_COLOR_CLUT8:
+		return 8;
+	case OMAP_DSS_COLOR_RGB12U:
+	case OMAP_DSS_COLOR_RGB16:
+	case OMAP_DSS_COLOR_ARGB16:
+	case OMAP_DSS_COLOR_YUV2:
+	case OMAP_DSS_COLOR_UYVY:
+		return 16;
+	case OMAP_DSS_COLOR_RGB24P:
+		return 24;
+	case OMAP_DSS_COLOR_RGB24U:
+	case OMAP_DSS_COLOR_ARGB32:
+	case OMAP_DSS_COLOR_RGBA32:
+	case OMAP_DSS_COLOR_RGBX32:
+		return 32;
+	default:
+		BUG();
+	}
+}
+
+static s32 calc_gfx_window_skip(void)
+{
+	enum omap_channel channel;
+	enum omap_color_mode color_mode;
+	unsigned int x0, x1, y0, y1, x, y;
+	unsigned int gfxx, gfxy, gfxw, gfxh;
+	unsigned int vid1x, vid1y, vid1w, vid1h;
+	s32 pix_inc, row_inc, skip;
+	u16 ps;
+
+	/* GFXENABLE */
+	if (REG_GET(dispc_reg_att[OMAP_DSS_GFX], 0, 0) == 0) {
+		DSSDBG("gfx_window_skip: GFX not enabled\n");
+		return 0;
+	}
+
+	/* VIDENABLE */
+	if (REG_GET(dispc_reg_att[OMAP_DSS_VIDEO1], 0, 0) == 0) {
+		DSSDBG("gfx_window_skip: VID1 not enabled\n");
+		return 0;
+	}
+
+	/* GFXCHANNELOUT and VIDCHANNELOUT */
+	channel = REG_GET(dispc_reg_att[OMAP_DSS_GFX], 8, 8);
+	if (channel != REG_GET(dispc_reg_att[OMAP_DSS_VIDEO1], 16, 16)) {
+		DSSDBG("gfx_window_skip: GFX and VID1 on different channels\n");
+		return 0;
+	}
+
+	if (dispc_trans_key_enabled(channel)) {
+		DSSDBG("gfx_window_skip: transparency color key enabled\n");
+		return 0;
+	}
+
+	if (dispc_alpha_blending_enabled(channel)) {
+		DSSDBG("gfx_window_skip: alpha blender enabled\n");
+		return 0;
+	}
+
+	/* FIXME RGB12U, RGBX32, ARGB16, ARGB32, RGBA32 formats OK? */
+	color_mode = _dispc_get_color_mode(OMAP_DSS_GFX);
+	switch (color_mode) {
+	case OMAP_DSS_COLOR_CLUT8:
+	case OMAP_DSS_COLOR_RGB16:
+	case OMAP_DSS_COLOR_YUV2:
+	case OMAP_DSS_COLOR_UYVY:
+	case OMAP_DSS_COLOR_RGB24P:
+	case OMAP_DSS_COLOR_RGB24U:
+	case OMAP_DSS_COLOR_RGB12U:
+	case OMAP_DSS_COLOR_RGBX32:
+	case OMAP_DSS_COLOR_ARGB16:
+	case OMAP_DSS_COLOR_ARGB32:
+	case OMAP_DSS_COLOR_RGBA32:
+		break;
+	default:
+		DSSDBG("gfx_window_skip: unsupported GFX format\n");
+		return 0;
+	}
+
+	/* FIXME RGB12U, RGBX32 formats OK? */
+	switch (_dispc_get_color_mode(OMAP_DSS_VIDEO1)) {
+	case OMAP_DSS_COLOR_RGB16:
+	case OMAP_DSS_COLOR_YUV2:
+	case OMAP_DSS_COLOR_UYVY:
+	case OMAP_DSS_COLOR_RGB24P:
+	case OMAP_DSS_COLOR_RGB24U:
+	case OMAP_DSS_COLOR_RGB12U:
+	case OMAP_DSS_COLOR_RGBX32:
+		break;
+	default:
+		DSSDBG("gfx_window_skip: unsupported VID1 format\n");
+		return 0;
+	}
+
+	gfxx = REG_GET(DISPC_GFX_POSITION, 10, 0);
+	gfxy = REG_GET(DISPC_GFX_POSITION, 26, 16);
+	gfxw = REG_GET(DISPC_GFX_SIZE, 10, 0) + 1;
+	gfxh = REG_GET(DISPC_GFX_SIZE, 26, 16) + 1;
+
+	vid1x = REG_GET(DISPC_VID_POSITION(0), 10, 0);
+	vid1y = REG_GET(DISPC_VID_POSITION(0), 26, 16);
+	vid1w = REG_GET(DISPC_VID_SIZE(0), 10, 0) + 1;
+	vid1h = REG_GET(DISPC_VID_SIZE(0), 26, 16) + 1;
+
+	x0 = max(vid1x, gfxx);
+	y0 = max(vid1y, gfxy);
+	x1 = min(vid1x + vid1w, gfxx + gfxw);
+	y1 = min(vid1y + vid1h, gfxy + gfxh);
+
+	if (x1 <= x0 || y1 <= y0) {
+		DSSDBG("gfx_window_skip: GFX and VID1 do not overlap\n");
+		return 0;
+	}
+
+	pix_inc = _dispc_get_pix_inc(OMAP_DSS_GFX);
+	row_inc = _dispc_get_row_inc(OMAP_DSS_GFX);
+	ps = color_mode_to_bpp(color_mode) / 8;
+
+	x = x1 - x0;
+	y = y1 - y0;
+
+	DSSDBG("gfx_window_skip: GFX w=%u, VID1 w=%u, "
+	       "x=%u, y=%u, pix_inc=%u, row_inc=%u, ps=%u\n",
+	       gfxw, vid1w, x, y, pix_inc, row_inc, ps);
+
+	if (x == gfxw)
+		/* Skip full lines */
+		skip = y * (x * (pix_inc - 1 + ps) + row_inc - 1);
+	else if (gfxx < vid1x && gfxx + gfxw > vid1x + vid1w)
+		/* Skip the middle of the line */
+		skip = x * (pix_inc - 1 + ps) + 1;
+	else
+		/* Skip the beginning or the end of the line */
+		skip = x * (pix_inc - 1 + ps);
+
+	DSSDBG("gfx_window_skip: skipping %d bytes\n", skip);
+
+	return skip;
+}
+
+void dispc_set_overlay_optimization(void)
+{
+	s32 skip = calc_gfx_window_skip();
+
+	REG_FLD_MOD(DISPC_CONTROL, skip ? 1 : 0, 12, 12);
+	dispc_write_reg(DISPC_GFX_WINDOW_SKIP, skip);
+}
+
 static s32 pixinc(int pixels, u8 ps)
 {
 	if (pixels == 1)
@@ -1144,40 +1400,112 @@ static s32 pixinc(int pixels, u8 ps)
 		BUG();
 }
 
-static void calc_rotation_offset(u8 rotation, bool mirror,
+static void calc_vrfb_rotation_offset(u8 rotation, bool mirror,
 		u16 screen_width,
 		u16 width, u16 height,
 		enum omap_color_mode color_mode, bool fieldmode,
+		unsigned int field_offset,
 		unsigned *offset0, unsigned *offset1,
 		s32 *row_inc, s32 *pix_inc)
 {
 	u8 ps;
-	u16 fbw, fbh;
 
+	/* FIXME CLUT formats */
 	switch (color_mode) {
-	case OMAP_DSS_COLOR_RGB16:
-	case OMAP_DSS_COLOR_ARGB16:
-		ps = 2;
+	case OMAP_DSS_COLOR_CLUT1:
+	case OMAP_DSS_COLOR_CLUT2:
+	case OMAP_DSS_COLOR_CLUT4:
+	case OMAP_DSS_COLOR_CLUT8:
+		BUG();
+		return;
+	case OMAP_DSS_COLOR_YUV2:
+	case OMAP_DSS_COLOR_UYVY:
+		ps = 4;
 		break;
-
-	case OMAP_DSS_COLOR_RGB24P:
-		ps = 3;
+	default:
+		ps = color_mode_to_bpp(color_mode) / 8;
 		break;
+	}
 
-	case OMAP_DSS_COLOR_RGB24U:
-	case OMAP_DSS_COLOR_ARGB32:
-	case OMAP_DSS_COLOR_RGBA32:
-	case OMAP_DSS_COLOR_RGBX32:
-		ps = 4;
+	DSSDBG("calc_rot(%d): scrw %d, %dx%d\n", rotation, screen_width,
+			width, height);
+
+	/*
+	 * field 0 = even field = bottom field
+	 * field 1 = odd field = top field
+	 */
+	switch (rotation + mirror * 4) {
+	case OMAP_DSS_ROT_0:
+	case OMAP_DSS_ROT_180:
+		/*
+		 * If the pixel format is YUV or UYVY divide the width
+		 * of the image by 2 for 0 and 180 degree rotation.
+		 */
+		if (color_mode == OMAP_DSS_COLOR_YUV2 ||
+			color_mode == OMAP_DSS_COLOR_UYVY)
+			width = width >> 1;
+	case OMAP_DSS_ROT_90:
+	case OMAP_DSS_ROT_270:
+		*offset1 = 0;
+		if (field_offset)
+			*offset0 = field_offset * screen_width * ps;
+		else
+			*offset0 = 0;
+
+		*row_inc = pixinc(1 + (screen_width - width) +
+				(fieldmode ? screen_width : 0),
+				ps);
+		*pix_inc = pixinc(1, ps);
 		break;
 
-	case OMAP_DSS_COLOR_YUV2:
-	case OMAP_DSS_COLOR_UYVY:
-		ps = 2;
+	case OMAP_DSS_ROT_0 + 4:
+	case OMAP_DSS_ROT_180 + 4:
+		/* If the pixel format is YUV or UYVY divide the width
+		 * of the image by 2  for 0 degree and 180 degree
+		 */
+		if (color_mode == OMAP_DSS_COLOR_YUV2 ||
+			color_mode == OMAP_DSS_COLOR_UYVY)
+			width = width >> 1;
+	case OMAP_DSS_ROT_90 + 4:
+	case OMAP_DSS_ROT_270 + 4:
+		*offset1 = 0;
+		if (field_offset)
+			*offset0 = field_offset * screen_width * ps;
+		else
+			*offset0 = 0;
+		*row_inc = pixinc(1 - (screen_width + width) -
+				(fieldmode ? screen_width : 0),
+				ps);
+		*pix_inc = pixinc(1, ps);
 		break;
+
 	default:
 		BUG();
+	}
+}
+
+static void calc_dma_rotation_offset(u8 rotation, bool mirror,
+		u16 screen_width,
+		u16 width, u16 height,
+		enum omap_color_mode color_mode, bool fieldmode,
+		unsigned int field_offset,
+		unsigned *offset0, unsigned *offset1,
+		s32 *row_inc, s32 *pix_inc)
+{
+	u8 ps;
+	u16 fbw, fbh;
+
+	/* FIXME CLUT formats */
+	switch (color_mode) {
+	case OMAP_DSS_COLOR_CLUT1:
+	case OMAP_DSS_COLOR_CLUT2:
+	case OMAP_DSS_COLOR_CLUT4:
+	case OMAP_DSS_COLOR_CLUT8:
+		BUG();
 		return;
+	default:
+		ps = color_mode_to_bpp(color_mode) / 8;
+		break;
 	}
 
 	DSSDBG("calc_rot(%d): scrw %d, %dx%d\n", rotation, screen_width,
@@ -1185,7 +1513,7 @@ static void calc_rotation_offset(u8 rota
 
 	/* width & height are overlay sizes, convert to fb sizes */
 
-	if (rotation == 0 || rotation == 2) {
+	if (rotation == OMAP_DSS_ROT_0 || rotation == OMAP_DSS_ROT_180) {
 		fbw = width;
 		fbh = height;
 	} else {
@@ -1193,94 +1521,98 @@ static void calc_rotation_offset(u8 rota
 		fbh = width;
 	}
 
+	/*
+	 * field 0 = even field = bottom field
+	 * field 1 = odd field = top field
+	 */
 	switch (rotation + mirror * 4) {
-	case 0:
-		*offset0 = 0;
-		if (fieldmode)
-			*offset1 = screen_width * ps;
+	case OMAP_DSS_ROT_0:
+		*offset1 = 0;
+		if (field_offset)
+			*offset0 = *offset1 + field_offset * screen_width * ps;
 		else
-			*offset1 = 0;
+			*offset0 = *offset1;
 		*row_inc = pixinc(1 + (screen_width - fbw) +
 				(fieldmode ? screen_width : 0),
 				ps);
 		*pix_inc = pixinc(1, ps);
 		break;
-	case 1:
-		*offset0 = screen_width * (fbh - 1) * ps;
-		if (fieldmode)
-			*offset1 = *offset0 + ps;
+	case OMAP_DSS_ROT_90:
+		*offset1 = screen_width * (fbh - 1) * ps;
+		if (field_offset)
+			*offset0 = *offset1 + field_offset * ps;
 		else
-			*offset1 = *offset0;
+			*offset0 = *offset1;
 		*row_inc = pixinc(screen_width * (fbh - 1) + 1 +
 				(fieldmode ? 1 : 0), ps);
 		*pix_inc = pixinc(-screen_width, ps);
 		break;
-	case 2:
-		*offset0 = (screen_width * (fbh - 1) + fbw - 1) * ps;
-		if (fieldmode)
-			*offset1 = *offset0 - screen_width * ps;
+	case OMAP_DSS_ROT_180:
+		*offset1 = (screen_width * (fbh - 1) + fbw - 1) * ps;
+		if (field_offset)
+			*offset0 = *offset1 - field_offset * screen_width * ps;
 		else
-			*offset1 = *offset0;
+			*offset0 = *offset1;
 		*row_inc = pixinc(-1 -
 				(screen_width - fbw) -
 				(fieldmode ? screen_width : 0),
 				ps);
 		*pix_inc = pixinc(-1, ps);
 		break;
-	case 3:
-		*offset0 = (fbw - 1) * ps;
-		if (fieldmode)
-			*offset1 = *offset0 - ps;
+	case OMAP_DSS_ROT_270:
+		*offset1 = (fbw - 1) * ps;
+		if (field_offset)
+			*offset0 = *offset1 - field_offset * ps;
 		else
-			*offset1 = *offset0;
+			*offset0 = *offset1;
 		*row_inc = pixinc(-screen_width * (fbh - 1) - 1 -
 				(fieldmode ? 1 : 0), ps);
 		*pix_inc = pixinc(screen_width, ps);
 		break;
 
 	/* mirroring */
-	case 0 + 4:
-		*offset0 = (fbw - 1) * ps;
-		if (fieldmode)
-			*offset1 = *offset0 + screen_width * ps;
+	case OMAP_DSS_ROT_0 + 4:
+		*offset1 = (fbw - 1) * ps;
+		if (field_offset)
+			*offset0 = *offset1 + field_offset * screen_width * ps;
 		else
-			*offset1 = *offset0;
+			*offset0 = *offset1;
 		*row_inc = pixinc(screen_width * 2 - 1 +
 				(fieldmode ? screen_width : 0),
 				ps);
 		*pix_inc = pixinc(-1, ps);
 		break;
 
-	case 1 + 4:
-		*offset0 = 0;
-		if (fieldmode)
-			*offset1 = *offset0 + screen_width * ps;
+	case OMAP_DSS_ROT_90 + 4:
+		*offset1 = 0;
+		if (field_offset)
+			*offset0 = *offset1 + field_offset * ps;
 		else
-			*offset1 = *offset0;
+			*offset0 = *offset1;
 		*row_inc = pixinc(-screen_width * (fbh - 1) + 1 +
 				(fieldmode ? 1 : 0),
 				ps);
 		*pix_inc = pixinc(screen_width, ps);
 		break;
 
-	case 2 + 4:
-		*offset0 = screen_width * (fbh - 1) * ps;
-		if (fieldmode)
-			*offset1 = *offset0 + screen_width * ps;
+	case OMAP_DSS_ROT_180 + 4:
+		*offset1 = screen_width * (fbh - 1) * ps;
+		if (field_offset)
+			*offset0 = *offset1 - field_offset * screen_width * ps;
 		else
-			*offset1 = *offset0;
+			*offset0 = *offset1;
 		*row_inc = pixinc(1 - screen_width * 2 -
 				(fieldmode ? screen_width : 0),
 				ps);
 		*pix_inc = pixinc(1, ps);
 		break;
 
-	case 3 + 4:
-		*offset0 = (screen_width * (fbh - 1) + fbw - 1) * ps;
-		if (fieldmode)
-			*offset1 = *offset0 + screen_width * ps;
+	case OMAP_DSS_ROT_270 + 4:
+		*offset1 = (screen_width * (fbh - 1) + fbw - 1) * ps;
+		if (field_offset)
+			*offset0 = *offset1 - field_offset * ps;
 		else
-			*offset1 = *offset0;
+			*offset0 = *offset1;
 		*row_inc = pixinc(screen_width * (fbh - 1) - 1 -
 				(fieldmode ? 1 : 0),
 				ps);
@@ -1292,22 +1624,109 @@ static void calc_rotation_offset(u8 rota
 	}
 }
 
+static struct omap_overlay_manager *
+manager_for_channel(enum omap_channel channel_out)
+{
+	int i;
+
+	for (i = 0; i < omap_dss_get_num_overlay_managers(); ++i) {
+		struct omap_overlay_manager *mgr;
+		mgr = omap_dss_get_overlay_manager(i);
+
+		if (mgr->id == channel_out)
+			return mgr;
+	}
+
+	return NULL;
+}
+
+static u32 get_pixel_clock(enum omap_channel channel_out)
+{
+	struct omap_video_timings t;
+	struct omap_overlay_manager *mgr = manager_for_channel(channel_out);
+
+	if (!mgr || !mgr->display || !mgr->display->get_timings)
+		return 0;
+
+	mgr->display->get_timings(mgr->display, &t);
+
+	DSSDBG("PCLK = %u\n", t.pixel_clock);
+
+	return t.pixel_clock;
+}
+
+static u32 get_display_width(enum omap_channel channel_out)
+{
+	struct omap_video_timings t;
+	struct omap_overlay_manager *mgr = manager_for_channel(channel_out);
+
+	if (!mgr || !mgr->display || !mgr->display->get_timings)
+		return 0;
+
+	mgr->display->get_timings(mgr->display, &t);
+
+	DSSDBG("PPL = %u\n", t.x_res);
+
+	return t.x_res;
+}
+
+static void dispc_get_lcd_divisor(int *lck_div, int *pck_div);
+
+static int check_hblank_len(u16 width, u16 height,
+		u16 out_width, u16 out_height,
+		enum omap_channel channel_out)
+{
+	static const u8 limits[3] = { 8, 10, 20 };
+	int i = 0;
+	int lcd, pcd;
+	struct omap_video_timings t;
+	struct omap_overlay_manager *mgr = manager_for_channel(channel_out);
+
+	if (!mgr || !mgr->display || !mgr->display->get_timings)
+		return -ENODEV;
+
+	mgr->display->get_timings(mgr->display, &t);
+
+	enable_clocks(1);
+
+	dispc_get_lcd_divisor(&lcd, &pcd);
+
+	enable_clocks(0);
+
+	if (out_height < height)
+		i++;
+	if (out_width < width)
+		i++;
+
+	DSSDBG("(hbp + hsw + hfp) * pcd = %u (limit = %u)\n",
+	       (t.hbp + t.hsw + t.hfp) * pcd, limits[i]);
+
+	if ((t.hbp + t.hsw + t.hfp) * pcd <= limits[i])
+		return -EINVAL;
+
+	return 0;
+}
+
 static unsigned long calc_fclk_five_taps(u16 width, u16 height,
-		u16 out_width, u16 out_height, enum omap_color_mode color_mode)
+		u16 out_width, u16 out_height, enum omap_color_mode color_mode,
+		enum omap_channel channel_out)
 {
 	u32 fclk = 0;
-	/* FIXME venc pclk? */
-	u64 tmp, pclk = dispc_pclk_rate();
+	u64 tmp, pclk = get_pixel_clock(channel_out);
+
+	if (!out_height || !out_height)
+		return 0;
 
 	if (height > out_height) {
-		/* FIXME get real display PPL */
-		unsigned int ppl = 800;
+		unsigned int ppl = get_display_width(channel_out);
+		if (!ppl)
+			return 0;
 
 		tmp = pclk * height * out_width;
 		do_div(tmp, 2 * out_height * ppl);
 		fclk = tmp;
 
-		if (height > 2 * out_height) {
+		if (height > 2 * out_height && ppl != out_width) {
 			tmp = pclk * (height - 2 * out_height) * out_width;
 			do_div(tmp, 2 * out_height * (ppl - out_width));
 			fclk = max(fclk, (u32) tmp);
@@ -1328,14 +1747,10 @@ static unsigned long calc_fclk_five_taps
 
 static unsigned long calc_fclk(u16 width, u16 height,
 		u16 out_width, u16 out_height,
-		enum omap_color_mode color_mode, bool five_taps)
+		enum omap_channel channel_out)
 {
 	unsigned int hf, vf;
 
-	if (five_taps)
-		return calc_fclk_five_taps(width, height,
-				out_width, out_height, color_mode);
-
 	/*
 	 * FIXME how to determine the 'A' factor
 	 * for the no downscaling case ?
@@ -1355,8 +1770,7 @@ static unsigned long calc_fclk(u16 width
 	else
 		vf = 1;
 
-	/* FIXME venc pclk? */
-	return dispc_pclk_rate() * vf * hf;
+	return get_pixel_clock(channel_out) * vf * hf;
 }
 
 static int _dispc_setup_plane(enum omap_plane plane,
@@ -1367,7 +1781,9 @@ static int _dispc_setup_plane(enum omap_
 		u16 out_width, u16 out_height,
 		enum omap_color_mode color_mode,
 		bool ilace,
-		u8 rotation, int mirror)
+		enum omap_dss_rotation_type rotation_type,
+		u8 rotation, int mirror,
+		u8 global_alpha)
 {
 	const int maxdownscale = cpu_is_omap34xx() ? 4 : 2;
 	bool five_taps = 0;
@@ -1377,11 +1793,12 @@ static int _dispc_setup_plane(enum omap_
 	s32 row_inc;
 	s32 pix_inc;
 	u16 frame_height = height;
+	unsigned int field_offset = 0;
 
 	if (paddr == 0)
 		return -EINVAL;
 
-	if (ilace && height >= out_height)
+	if (ilace && height == out_height)
 		fieldmode = 1;
 
 	if (ilace) {
@@ -1401,12 +1818,16 @@ static int _dispc_setup_plane(enum omap_
 
 		switch (color_mode) {
 		case OMAP_DSS_COLOR_ARGB16:
-		case OMAP_DSS_COLOR_RGB16:
-		case OMAP_DSS_COLOR_RGB24P:
-		case OMAP_DSS_COLOR_RGB24U:
 		case OMAP_DSS_COLOR_ARGB32:
 		case OMAP_DSS_COLOR_RGBA32:
 		case OMAP_DSS_COLOR_RGBX32:
+			if (cpu_is_omap24xx())
+				return -EINVAL;
+			/* fall through */
+		case OMAP_DSS_COLOR_RGB12U:
+		case OMAP_DSS_COLOR_RGB16:
+		case OMAP_DSS_COLOR_RGB24P:
+		case OMAP_DSS_COLOR_RGB24U:
 			break;
 
 		default:
@@ -1415,7 +1836,7 @@ static int _dispc_setup_plane(enum omap_
 	} else {
 		/* video plane */
 
-		unsigned long fclk;
+		unsigned long fclk = 0;
 
 		if (out_width < width / maxdownscale ||
 		   out_width > width * 8)
@@ -1426,15 +1847,21 @@ static int _dispc_setup_plane(enum omap_
 			return -EINVAL;
 
 		switch (color_mode) {
+		case OMAP_DSS_COLOR_RGBX32:
+		case OMAP_DSS_COLOR_RGB12U:
+			if (cpu_is_omap24xx())
+				return -EINVAL;
+			/* fall through */
 		case OMAP_DSS_COLOR_RGB16:
 		case OMAP_DSS_COLOR_RGB24P:
 		case OMAP_DSS_COLOR_RGB24U:
-		case OMAP_DSS_COLOR_RGBX32:
 			break;
 
 		case OMAP_DSS_COLOR_ARGB16:
 		case OMAP_DSS_COLOR_ARGB32:
 		case OMAP_DSS_COLOR_RGBA32:
+			if (cpu_is_omap24xx())
+				return -EINVAL;
 			if (plane == OMAP_DSS_VIDEO1)
 				return -EINVAL;
 			break;
@@ -1448,23 +1875,30 @@ static int _dispc_setup_plane(enum omap_
 			return -EINVAL;
 		}
 
+		if (check_hblank_len(width, height, out_width, out_height,
+				channel_out))
+			return -EINVAL;
+
 		/* Must use 5-tap filter? */
 		five_taps = height > out_height * 2;
 
-		/* Try to use 5-tap filter whenever possible. */
-		if (cpu_is_omap34xx() && !five_taps &&
-		    height > out_height && width <= 1024) {
-			fclk = calc_fclk_five_taps(width, height,
-					out_width, out_height, color_mode);
-			if (fclk <= dispc_fclk_rate())
+		if (!five_taps) {
+			fclk = calc_fclk(width, height,
+					out_width, out_height, channel_out);
+
+			/* Try 5-tap filter if 3-tap fclk is too high */
+			if (cpu_is_omap34xx() && height > out_height &&
+					fclk > dispc_fclk_rate())
 				five_taps = true;
 		}
 
 		if (width > (2048 >> five_taps))
 			return -EINVAL;
 
-		fclk = calc_fclk(width, height, out_width, out_height,
-				color_mode, five_taps);
+		if (five_taps)
+			fclk = calc_fclk_five_taps(width, height,
+					out_width, out_height,
+					color_mode, channel_out);
 
 		DSSDBG("required fclk rate = %lu Hz\n", fclk);
 		DSSDBG("current fclk rate = %lu Hz\n", dispc_fclk_rate());
@@ -1473,10 +1907,34 @@ static int _dispc_setup_plane(enum omap_
 			return -EINVAL;
 	}
 
-	calc_rotation_offset(rotation, mirror,
-			screen_width, width, frame_height, color_mode,
-			fieldmode,
-			&offset0, &offset1, &row_inc, &pix_inc);
+	if (ilace && !fieldmode) {
+		/*
+		 * when downscaling the bottom field may have to start several
+		 * source lines below the top field. Unfortunately ACCUI
+		 * registers will only hold the fractional part of the offset
+		 * so the integer part must be added to the base address of the
+		 * bottom field.
+		 */
+		if (!height || height == out_height)
+			field_offset = 0;
+		else
+			field_offset = height / out_height / 2;
+	}
+
+	/* Fields are independent but interleaved in memory. */
+	if (fieldmode)
+		field_offset = 1;
+
+	if (rotation_type == OMAP_DSS_ROT_DMA)
+		calc_dma_rotation_offset(rotation, mirror,
+				screen_width, width, frame_height, color_mode,
+				fieldmode, field_offset,
+				&offset0, &offset1, &row_inc, &pix_inc);
+	else
+		calc_vrfb_rotation_offset(rotation, mirror,
+				screen_width, width, frame_height, color_mode,
+				fieldmode, field_offset,
+				&offset0, &offset1, &row_inc, &pix_inc);
 
 	DSSDBG("offset0 %u, offset1 %u, row_inc %d, pix_inc %d\n",
 			offset0, offset1, row_inc, pix_inc);
@@ -1500,13 +1958,16 @@ static int _dispc_setup_plane(enum omap_
 	if (plane != OMAP_DSS_GFX) {
 		_dispc_set_scaling(plane, width, height,
 				   out_width, out_height,
-				   ilace, five_taps);
+				   ilace, five_taps, fieldmode);
 		_dispc_set_vid_size(plane, out_width, out_height);
 		_dispc_set_vid_color_conv(plane, cconv);
 	}
 
 	_dispc_set_rotation_attrs(plane, rotation, mirror, color_mode);
 
+	if (plane != OMAP_DSS_VIDEO1)
+		_dispc_setup_global_alpha(plane, global_alpha);
+
 	return 0;
 }
 
@@ -1573,6 +2034,29 @@ static void _enable_digit_out(bool enabl
 	REG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 1, 1);
 }
 
+void dispc_enable_digit_errors(int enable)
+{
+	unsigned long flags;
+
+	enable_clocks(1);
+
+	spin_lock_irqsave(&dispc.irq_lock, flags);
+
+	if (!enable) {
+		/* When we enable digit output, we'll get an extra digit
+		 * sync lost interrupt, that we need to ignore */
+		dispc.irq_error_mask &= ~DISPC_IRQ_SYNC_LOST_DIGIT;
+	} else {
+		dispc.irq_error_mask = DISPC_IRQ_MASK_ERROR;
+		dispc_write_reg(DISPC_IRQSTATUS, DISPC_IRQ_SYNC_LOST_DIGIT);
+	}
+
+	_omap_dispc_set_irqs();
+	spin_unlock_irqrestore(&dispc.irq_lock, flags);
+
+	enable_clocks(0);
+}
+
 void dispc_enable_digit_out(bool enable)
 {
 	struct completion frame_done_completion;
@@ -1585,13 +2069,6 @@ void dispc_enable_digit_out(bool enable)
 		return;
 	}
 
-	if (enable) {
-		/* When we enable digit output, we'll get an extra digit
-		 * sync lost interrupt, that we need to ignore */
-		dispc.irq_error_mask &= ~DISPC_IRQ_SYNC_LOST_DIGIT;
-		omap_dispc_set_irqs();
-	}
-
 	/* When we disable digit output, we need to wait until fields are done.
 	 * Otherwise the DSS is still working, and turning off the clocks
 	 * prevents DSS from going to OFF mode. And when enabling, we need to
@@ -1622,12 +2099,6 @@ void dispc_enable_digit_out(bool enable)
 	if (r)
 		DSSERR("failed to unregister EVSYNC isr\n");
 
-	if (enable) {
-		dispc.irq_error_mask = DISPC_IRQ_MASK_ERROR;
-		dispc_write_reg(DISPC_IRQSTATUS, DISPC_IRQ_SYNC_LOST_DIGIT);
-		omap_dispc_set_irqs();
-	}
-
 	enable_clocks(0);
 }
 
@@ -1744,9 +2215,9 @@ void dispc_get_trans_key(enum omap_chann
 	enable_clocks(1);
 	if (type) {
 		if (ch == OMAP_DSS_CHANNEL_LCD)
-			*type = REG_GET(DISPC_CONFIG, 11, 11) >> 11;
+			*type = REG_GET(DISPC_CONFIG, 11, 11);
 		else if (ch == OMAP_DSS_CHANNEL_DIGIT)
-			*type = REG_GET(DISPC_CONFIG, 13, 13) >> 13;
+			*type = REG_GET(DISPC_CONFIG, 13, 13);
 		else
 			BUG();
 	}
@@ -1763,8 +2234,44 @@ void dispc_enable_trans_key(enum omap_ch
 		REG_FLD_MOD(DISPC_CONFIG, enable, 10, 10);
 	else /* OMAP_DSS_CHANNEL_DIGIT */
 		REG_FLD_MOD(DISPC_CONFIG, enable, 12, 12);
+	dispc_set_overlay_optimization();
+	dispc_go(ch);
+	enable_clocks(0);
+}
+void dispc_enable_alpha_blending(enum omap_channel ch, bool enable)
+{
+	if (cpu_is_omap24xx())
+		return;
+
+	enable_clocks(1);
+	if (ch == OMAP_DSS_CHANNEL_LCD)
+		REG_FLD_MOD(DISPC_CONFIG, enable, 18, 18);
+	else /* OMAP_DSS_CHANNEL_DIGIT */
+		REG_FLD_MOD(DISPC_CONFIG, enable, 19, 19);
+	dispc_set_overlay_optimization();
+	dispc_go(ch);
 	enable_clocks(0);
 }
+bool dispc_alpha_blending_enabled(enum omap_channel ch)
+{
+	bool enabled;
+
+	if (cpu_is_omap24xx())
+		return false;
+
+	enable_clocks(1);
+	if (ch == OMAP_DSS_CHANNEL_LCD)
+		enabled = REG_GET(DISPC_CONFIG, 18, 18);
+	else if (ch == OMAP_DSS_CHANNEL_DIGIT)
+		enabled = REG_GET(DISPC_CONFIG, 18, 18);
+	else
+		BUG();
+	enable_clocks(0);
+
+	return enabled;
+
+}
+
 
 bool dispc_trans_key_enabled(enum omap_channel ch)
 {
@@ -2377,14 +2884,15 @@ int dispc_get_clock_div(struct dispc_clo
 	return 0;
 }
 
-static void omap_dispc_set_irqs(void)
+/* dispc.irq_lock has to be locked by the caller */
+static void _omap_dispc_set_irqs(void)
 {
-	unsigned long flags;
-	u32 mask = dispc.irq_error_mask;
+	u32 mask;
+	u32 old_mask;
 	int i;
 	struct omap_dispc_isr_data *isr_data;
 
-	spin_lock_irqsave(&dispc.irq_lock, flags);
+	mask = dispc.irq_error_mask;
 
 	for (i = 0; i < DISPC_MAX_NR_ISRS; i++) {
 		isr_data = &dispc.registered_isr[i];
@@ -2396,10 +2904,14 @@ static void omap_dispc_set_irqs(void)
 	}
 
 	enable_clocks(1);
+
+	old_mask = dispc_read_reg(DISPC_IRQENABLE);
+	/* clear the irqstatus for newly enabled irqs */
+	dispc_write_reg(DISPC_IRQSTATUS, (mask ^ old_mask) & mask);
+
 	dispc_write_reg(DISPC_IRQENABLE, mask);
-	enable_clocks(0);
 
-	spin_unlock_irqrestore(&dispc.irq_lock, flags);
+	enable_clocks(0);
 }
 
 int omap_dispc_register_isr(omap_dispc_isr_t isr, void *arg, u32 mask)
@@ -2440,11 +2952,14 @@ int omap_dispc_register_isr(omap_dispc_i
 
 		break;
 	}
-err:
+
+	_omap_dispc_set_irqs();
+
 	spin_unlock_irqrestore(&dispc.irq_lock, flags);
 
-	if (ret == 0)
-		omap_dispc_set_irqs();
+	return 0;
+err:
+	spin_unlock_irqrestore(&dispc.irq_lock, flags);
 
 	return ret;
 }
@@ -2475,10 +2990,10 @@ int omap_dispc_unregister_isr(omap_dispc
 		break;
 	}
 
-	spin_unlock_irqrestore(&dispc.irq_lock, flags);
-
 	if (ret == 0)
-		omap_dispc_set_irqs();
+		_omap_dispc_set_irqs();
+
+	spin_unlock_irqrestore(&dispc.irq_lock, flags);
 
 	return ret;
 }
@@ -2514,11 +3029,15 @@ static void print_irq_status(u32 status)
 void dispc_irq_handler(void)
 {
 	int i;
-	u32 irqstatus = dispc_read_reg(DISPC_IRQSTATUS);
+	u32 irqstatus;
 	u32 handledirqs = 0;
 	u32 unhandled_errors;
 	struct omap_dispc_isr_data *isr_data;
 
+	spin_lock(&dispc.irq_lock);
+
+	irqstatus = dispc_read_reg(DISPC_IRQSTATUS);
+
 #ifdef DEBUG
 	if (dss_debug)
 		print_irq_status(irqstatus);
@@ -2542,15 +3061,15 @@ void dispc_irq_handler(void)
 	unhandled_errors = irqstatus & ~handledirqs & dispc.irq_error_mask;
 
 	if (unhandled_errors) {
-		spin_lock(&dispc.error_lock);
 		dispc.error_irqs |= unhandled_errors;
-		spin_unlock(&dispc.error_lock);
 
 		dispc.irq_error_mask &= ~unhandled_errors;
-		omap_dispc_set_irqs();
+		_omap_dispc_set_irqs();
 
 		schedule_work(&dispc.error_work);
 	}
+
+	spin_unlock(&dispc.irq_lock);
 }
 
 static void dispc_error_worker(struct work_struct *work)
@@ -2559,139 +3078,28 @@ static void dispc_error_worker(struct wo
 	u32 errors;
 	unsigned long flags;
 
-	spin_lock_irqsave(&dispc.error_lock, flags);
+	spin_lock_irqsave(&dispc.irq_lock, flags);
 	errors = dispc.error_irqs;
 	dispc.error_irqs = 0;
-	spin_unlock_irqrestore(&dispc.error_lock, flags);
-
-	if (errors & DISPC_IRQ_GFX_FIFO_UNDERFLOW) {
-		DSSERR("GFX_FIFO_UNDERFLOW, disabling GFX\n");
-		for (i = 0; i < omap_dss_get_num_overlays(); ++i) {
-			struct omap_overlay *ovl;
-			ovl = omap_dss_get_overlay(i);
-
-			if (!(ovl->caps & OMAP_DSS_OVL_CAP_DISPC))
-				continue;
-
-			if (ovl->id == 0) {
-				dispc_enable_plane(ovl->id, 0);
-				dispc_go(ovl->manager->id);
-				mdelay(50);
-				break;
-			}
-		}
-	}
-
-	if (errors & DISPC_IRQ_VID1_FIFO_UNDERFLOW) {
-		DSSERR("VID1_FIFO_UNDERFLOW, disabling VID1\n");
-		for (i = 0; i < omap_dss_get_num_overlays(); ++i) {
-			struct omap_overlay *ovl;
-			ovl = omap_dss_get_overlay(i);
-
-			if (!(ovl->caps & OMAP_DSS_OVL_CAP_DISPC))
-				continue;
-
-			if (ovl->id == 1) {
-				dispc_enable_plane(ovl->id, 0);
-				dispc_go(ovl->manager->id);
-				mdelay(50);
-				break;
-			}
-		}
-	}
+	spin_unlock_irqrestore(&dispc.irq_lock, flags);
 
-	if (errors & DISPC_IRQ_VID2_FIFO_UNDERFLOW) {
-		DSSERR("VID2_FIFO_UNDERFLOW, disabling VID2\n");
-		for (i = 0; i < omap_dss_get_num_overlays(); ++i) {
-			struct omap_overlay *ovl;
-			ovl = omap_dss_get_overlay(i);
+	if (errors & DISPC_IRQ_GFX_FIFO_UNDERFLOW)
+		DSSERR("GFX_FIFO_UNDERFLOW\n");
 
-			if (!(ovl->caps & OMAP_DSS_OVL_CAP_DISPC))
-				continue;
+	if (errors & DISPC_IRQ_VID1_FIFO_UNDERFLOW)
+		DSSERR("VID1_FIFO_UNDERFLOW\n");
 
-			if (ovl->id == 2) {
-				dispc_enable_plane(ovl->id, 0);
-				dispc_go(ovl->manager->id);
-				mdelay(50);
-				break;
-			}
-		}
-	}
+	if (errors & DISPC_IRQ_VID2_FIFO_UNDERFLOW)
+		DSSERR("VID2_FIFO_UNDERFLOW\n");
 
 	if (errors & DISPC_IRQ_SYNC_LOST) {
-		struct omap_overlay_manager *manager = NULL;
-		bool enable = false;
-
-		DSSERR("SYNC_LOST, disabling LCD\n");
-
-		for (i = 0; i < omap_dss_get_num_overlay_managers(); ++i) {
-			struct omap_overlay_manager *mgr;
-			mgr = omap_dss_get_overlay_manager(i);
-
-			if (mgr->id == OMAP_DSS_CHANNEL_LCD) {
-				manager = mgr;
-				enable = mgr->display->state ==
-						OMAP_DSS_DISPLAY_ACTIVE;
-				mgr->display->disable(mgr->display);
-				break;
-			}
-		}
-
-		if (manager) {
-			for (i = 0; i < omap_dss_get_num_overlays(); ++i) {
-				struct omap_overlay *ovl;
-				ovl = omap_dss_get_overlay(i);
-
-				if (!(ovl->caps & OMAP_DSS_OVL_CAP_DISPC))
-					continue;
-
-				if (ovl->id != 0 && ovl->manager == manager)
-					dispc_enable_plane(ovl->id, 0);
-			}
-
-			dispc_go(manager->id);
-			mdelay(50);
-			if (enable)
-				manager->display->enable(manager->display);
-		}
+		DSSERR("SYNC_LOST, going to perform a soft reset\n");
+		dss_schedule_reset();
 	}
 
 	if (errors & DISPC_IRQ_SYNC_LOST_DIGIT) {
-		struct omap_overlay_manager *manager = NULL;
-		bool enable = false;
-
-		DSSERR("SYNC_LOST_DIGIT, disabling TV\n");
-
-		for (i = 0; i < omap_dss_get_num_overlay_managers(); ++i) {
-			struct omap_overlay_manager *mgr;
-			mgr = omap_dss_get_overlay_manager(i);
-
-			if (mgr->id == OMAP_DSS_CHANNEL_DIGIT) {
-				manager = mgr;
-				enable = mgr->display->state ==
-						OMAP_DSS_DISPLAY_ACTIVE;
-				mgr->display->disable(mgr->display);
-				break;
-			}
-		}
-
-		if (manager) {
-			for (i = 0; i < omap_dss_get_num_overlays(); ++i) {
-				struct omap_overlay *ovl;
-				ovl = omap_dss_get_overlay(i);
-
-				if (!(ovl->caps & OMAP_DSS_OVL_CAP_DISPC))
-					continue;
-
-				if (ovl->id != 0 && ovl->manager == manager)
-					dispc_enable_plane(ovl->id, 0);
-			}
-
-			dispc_go(manager->id);
-			mdelay(50);
-			if (enable)
-				manager->display->enable(manager->display);
-		}
+		DSSERR("SYNC_LOST_DIGIT, going to perform a soft reset\n");
+		dss_schedule_reset();
 	}
 
 	if (errors & DISPC_IRQ_OCP_ERR) {
@@ -2705,8 +3113,10 @@ static void dispc_error_worker(struct wo
 		}
 	}
 
+	spin_lock_irqsave(&dispc.irq_lock, flags);
 	dispc.irq_error_mask |= errors;
-	omap_dispc_set_irqs();
+	_omap_dispc_set_irqs();
+	spin_unlock_irqrestore(&dispc.irq_lock, flags);
 }
 
 int omap_dispc_wait_for_irq_timeout(u32 irqmask, unsigned long timeout)
@@ -2790,6 +3200,10 @@ void dispc_fake_vsync_irq(void)
 
 static void _omap_dispc_initialize_irq(void)
 {
+	unsigned long flags;
+
+	spin_lock_irqsave(&dispc.irq_lock, flags);
+
 	memset(dispc.registered_isr, 0, sizeof(dispc.registered_isr));
 
 	dispc.irq_error_mask = DISPC_IRQ_MASK_ERROR;
@@ -2798,7 +3212,19 @@ static void _omap_dispc_initialize_irq(v
 	 * so clear it */
 	dispc_write_reg(DISPC_IRQSTATUS, dispc_read_reg(DISPC_IRQSTATUS));
 
-	omap_dispc_set_irqs();
+	_omap_dispc_set_irqs();
+
+	spin_unlock_irqrestore(&dispc.irq_lock, flags);
+}
+
+void dispc_enable_sidle(void)
+{
+	REG_FLD_MOD(DISPC_SYSCONFIG, 2, 4, 3);	/* SIDLEMODE: smart idle */
+}
+
+void dispc_disable_sidle(void)
+{
+	REG_FLD_MOD(DISPC_SYSCONFIG, 1, 4, 3);	/* SIDLEMODE: no idle */
 }
 
 static void _omap_dispc_initial_config(void)
@@ -2829,7 +3255,6 @@ int dispc_init(void)
 	u32 rev;
 
 	spin_lock_init(&dispc.irq_lock);
-	spin_lock_init(&dispc.error_lock);
 
 	INIT_WORK(&dispc.error_work, dispc_error_worker);
 
@@ -2889,7 +3314,8 @@ int dispc_setup_plane(enum omap_plane pl
 		       u16 out_width, u16 out_height,
 		       enum omap_color_mode color_mode,
 		       bool ilace,
-		       u8 rotation, bool mirror)
+		       enum omap_dss_rotation_type rotation_type,
+		       u8 rotation, bool mirror, u8 global_alpha)
 {
 	int r = 0;
 
@@ -2909,7 +3335,9 @@ int dispc_setup_plane(enum omap_plane pl
 			   width, height,
 			   out_width, out_height,
 			   color_mode, ilace,
-			   rotation, mirror);
+			   rotation_type,
+			   rotation, mirror,
+			   global_alpha);
 
 	enable_clocks(0);
 
@@ -3060,23 +3488,19 @@ void dispc_setup_partial_planes(struct o
 			continue;
 		}
 
+		/* FIXME CLUT formats */
 		switch (pi->color_mode) {
+		case OMAP_DSS_COLOR_RGB12U:
 		case OMAP_DSS_COLOR_RGB16:
 		case OMAP_DSS_COLOR_ARGB16:
 		case OMAP_DSS_COLOR_YUV2:
 		case OMAP_DSS_COLOR_UYVY:
-			bpp = 16;
-			break;
-
 		case OMAP_DSS_COLOR_RGB24P:
-			bpp = 24;
-			break;
-
 		case OMAP_DSS_COLOR_RGB24U:
 		case OMAP_DSS_COLOR_ARGB32:
 		case OMAP_DSS_COLOR_RGBA32:
 		case OMAP_DSS_COLOR_RGBX32:
-			bpp = 32;
+			bpp = color_mode_to_bpp(pi->color_mode);
 			break;
 
 		default:
@@ -3122,8 +3546,15 @@ void dispc_setup_partial_planes(struct o
 				pw, ph,
 				pow, poh,
 				pi->color_mode, 0,
-				pi->rotation, // XXX rotation probably wrong
-				pi->mirror);
+				pi->rotation_type,
+				pi->rotation,
+				pi->mirror,
+				pi->global_alpha);
+
+		if (dss_use_replication(display, ovl->info.color_mode))
+			dispc_enable_replication(ovl->id, true);
+		else
+			dispc_enable_replication(ovl->id, false);
 
 		dispc_enable_plane(ovl->id, 1);
 	}
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/display.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/display.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/display.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/display.c	2012-12-16 13:13:01.704330145 +0100
@@ -49,21 +49,28 @@ static ssize_t display_enabled_show(stru
 static ssize_t display_enabled_store(struct omap_display *display,
 		const char *buf, size_t size)
 {
-	bool enabled, r;
+	bool enabled, r = 0;
 
 	enabled = simple_strtoul(buf, NULL, 10);
 
+	omap_dss_lock();
+
 	if (enabled != (display->state != OMAP_DSS_DISPLAY_DISABLED)) {
 		if (enabled) {
+			omap_dss_maximize_min_bus_tput();
 			r = display->enable(display);
+			omap_dss_update_min_bus_tput();
 			if (r)
-				return r;
+				goto unlock;
 		} else {
 			display->disable(display);
 		}
 	}
 
-	return size;
+unlock:
+	omap_dss_unlock();
+
+	return r ? r : size;
 }
 
 static ssize_t display_upd_mode_show(struct omap_display *display, char *buf)
@@ -164,7 +171,9 @@ static ssize_t display_timings_store(str
 	if ((r = display->check_timings(display, &t)))
 		return r;
 
+	omap_dss_lock();
 	display->set_timings(display, &t);
+	omap_dss_unlock();
 
 	return size;
 }
@@ -239,6 +248,43 @@ struct display_attribute {
 	ssize_t	(*store)(struct omap_display *, const char *, size_t);
 };
 
+static ssize_t display_wss_show(struct omap_display *display, char *buf)
+{
+	unsigned int wss;
+
+	if (!display->get_wss)
+		return -ENOENT;
+
+	wss = display->get_wss(display);
+
+	return snprintf(buf, PAGE_SIZE, "0x%05x\n", wss);
+}
+
+static ssize_t display_wss_store(struct omap_display *display,
+		const char *buf, size_t size)
+{
+	unsigned long wss;
+	int r;
+
+	if (!display->get_wss || !display->set_wss)
+		return -ENOENT;
+
+	if (strict_strtoul(buf, 0, &wss))
+		return -EINVAL;
+
+	if (wss > 0xfffff)
+		return -EINVAL;
+
+	omap_dss_lock();
+	r = display->set_wss(display, wss);
+	omap_dss_unlock();
+
+	if (r)
+		return r;
+
+	return size;
+}
+
 #define DISPLAY_ATTR(_name, _mode, _show, _store) \
 	struct display_attribute display_attr_##_name = \
 	__ATTR(_name, _mode, _show, _store)
@@ -258,6 +304,8 @@ static DISPLAY_ATTR(mirror, S_IRUGO|S_IW
 		display_mirror_show, display_mirror_store);
 static DISPLAY_ATTR(panel_name, S_IRUGO, display_panel_name_show, NULL);
 static DISPLAY_ATTR(ctrl_name, S_IRUGO, display_ctrl_name_show, NULL);
+static DISPLAY_ATTR(wss, S_IRUGO|S_IWUSR,
+		display_wss_show, display_wss_store);
 
 static struct attribute *display_sysfs_attrs[] = {
 	&display_attr_name.attr,
@@ -269,6 +317,7 @@ static struct attribute *display_sysfs_a
 	&display_attr_mirror.attr,
 	&display_attr_panel_name.attr,
 	&display_attr_ctrl_name.attr,
+	&display_attr_wss.attr,
 	NULL
 };
 
@@ -283,6 +332,9 @@ static ssize_t display_attr_show(struct
 	if (!display_attr->show)
 		return -ENOENT;
 
+	if (display->state == OMAP_DSS_DISPLAY_UNINITIALIZED)
+		return -ENODEV;
+
 	return display_attr->show(display, buf);
 }
 
@@ -298,6 +350,9 @@ static ssize_t display_attr_store(struct
 	if (!display_attr->store)
 		return -ENOENT;
 
+	if (display->state == OMAP_DSS_DISPLAY_UNINITIALIZED)
+		return -ENODEV;
+
 	return display_attr->store(display, buf, size);
 }
 
@@ -332,6 +387,13 @@ static void default_configure_overlay(st
 	high = dispc_get_plane_fifo_size(plane) - 1;
 	low = dispc_get_plane_fifo_size(plane) - size;
 
+	if (ovl->info.fifo_threshold_high &&
+	    ovl->info.fifo_threshold_high < high)
+		high = ovl->info.fifo_threshold_high;
+	if (ovl->info.fifo_threshold_low &&
+	    ovl->info.fifo_threshold_low < low)
+		low = ovl->info.fifo_threshold_low;
+
 	dispc_setup_plane_fifo(plane, low, high);
 }
 
@@ -375,10 +437,44 @@ static int default_get_recommended_bpp(s
 	}
 }
 
+/* Checks if replication logic should be used. Only use for active matrix,
+ * when overlay is in RGB12U or RGB16 mode, and LCD interface is
+ * 18bpp or 24bpp */
+bool dss_use_replication(struct omap_display *display,
+		enum omap_color_mode mode)
+{
+	int bpp;
+
+	if (mode != OMAP_DSS_COLOR_RGB12U && mode != OMAP_DSS_COLOR_RGB16)
+		return false;
+
+	if (display->type == OMAP_DISPLAY_TYPE_DPI &&
+			(display->panel->config & OMAP_DSS_LCD_TFT) == 0)
+		return false;
+
+	switch (display->type) {
+	case OMAP_DISPLAY_TYPE_DPI:
+		bpp = display->hw_config.u.dpi.data_lines;
+		break;
+	case OMAP_DISPLAY_TYPE_VENC:
+	case OMAP_DISPLAY_TYPE_SDI:
+		bpp = 24;
+		break;
+	case OMAP_DISPLAY_TYPE_DBI:
+	case OMAP_DISPLAY_TYPE_DSI:
+		bpp = display->ctrl->pixel_size;
+		break;
+	default:
+		BUG();
+	}
+
+	return bpp > 16;
+}
+
 void dss_init_displays(struct platform_device *pdev)
 {
 	struct omap_dss_board_info *pdata = pdev->dev.platform_data;
-	int i, r;
+	int i, r = 0;
 
 	INIT_LIST_HEAD(&display_list);
 
@@ -424,32 +520,37 @@ void dss_init_displays(struct platform_d
 
 		switch (display->type) {
 		case OMAP_DISPLAY_TYPE_DPI:
-			dpi_init_display(display);
+			r = dpi_init_display(display);
 			break;
 #ifdef CONFIG_OMAP2_DSS_RFBI
 		case OMAP_DISPLAY_TYPE_DBI:
-			rfbi_init_display(display);
+			r = rfbi_init_display(display);
 			break;
 #endif
 #ifdef CONFIG_OMAP2_DSS_VENC
 		case OMAP_DISPLAY_TYPE_VENC:
-			venc_init_display(display);
+			r = venc_init_display(display);
 			break;
 #endif
 #ifdef CONFIG_OMAP2_DSS_SDI
 		case OMAP_DISPLAY_TYPE_SDI:
-			sdi_init_display(display);
+			r = sdi_init_display(display);
 			break;
 #endif
 #ifdef CONFIG_OMAP2_DSS_DSI
 		case OMAP_DISPLAY_TYPE_DSI:
-			dsi_init_display(display);
+			r = dsi_init_display(display);
 			break;
 #endif
 		default:
 			BUG();
 		}
 
+		if (r) {
+			DSSERR("failed to init display%d\n", i);
+			continue;
+		}
+
 		r = kobject_init_and_add(&display->kobj, &display_ktype,
 				&pdev->dev.kobj, "display%d", num_displays);
 
@@ -597,7 +698,11 @@ struct omap_display *omap_dss_get_displa
 				goto err3;
 	}
 
+	dss_recheck_connections(display,
+				!strcmp(display->name, dss_get_def_disp_name()));
+
 	display->ref_count++;
+	display->state = OMAP_DSS_DISPLAY_DISABLED;
 	/*
 	if (atomic_cmpxchg(&display->ref_count, 0, 1) != 0)
 		return 0;
@@ -622,6 +727,8 @@ void omap_dss_put_display(struct omap_di
 {
 	if (--display->ref_count > 0)
 		return;
+
+	display->state = OMAP_DSS_DISPLAY_UNINITIALIZED;
 /*
 	if (atomic_cmpxchg(&display->ref_count, 1, 0) != 1)
 		return;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/dpi.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/dpi.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/dpi.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/dpi.c	2012-12-16 13:13:01.704330145 +0100
@@ -367,7 +367,7 @@ static enum omap_dss_update_mode dpi_dis
 		OMAP_DSS_UPDATE_DISABLED;
 }
 
-void dpi_init_display(struct omap_display *display)
+int dpi_init_display(struct omap_display *display)
 {
 	DSSDBG("DPI init_display\n");
 
@@ -380,6 +380,8 @@ void dpi_init_display(struct omap_displa
 	display->get_timings = dpi_get_timings;
 	display->set_update_mode = dpi_display_set_update_mode;
 	display->get_update_mode = dpi_display_get_update_mode;
+
+	return 0;
 }
 
 int dpi_init(void)
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/dsi.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/dsi.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/dsi.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/dsi.c	2012-12-16 13:13:01.708330145 +0100
@@ -274,7 +274,8 @@ static struct
 	enum omap_dss_update_mode user_update_mode;
 	enum omap_dss_update_mode target_update_mode;
 	enum omap_dss_update_mode update_mode;
-	int use_te;
+	bool use_te;
+	bool use_ext_te;
 	int framedone_scheduled; /* helps to catch strange framedone bugs */
 
 	unsigned long cache_req_pck;
@@ -289,9 +290,12 @@ static struct
 
 	bool autoupdate_setup;
 
+	u32		errors;
+	spinlock_t	errors_lock;
 #ifdef DEBUG
 	ktime_t perf_setup_time;
 	ktime_t perf_start_time;
+	ktime_t perf_start_time_auto;
 	int perf_measure_frames;
 
 	struct {
@@ -358,13 +362,16 @@ static void perf_mark_start(void)
 	dsi.perf_start_time = ktime_get();
 }
 
+static void perf_mark_start_auto(void)
+{
+	dsi.perf_start_time_auto = ktime_get();
+}
+
 static void perf_show(const char *name)
 {
 	ktime_t t, setup_time, trans_time;
 	u32 total_bytes;
 	u32 setup_us, trans_us, total_us;
-	const int numframes = 100;
-	static u32 s_trans_us, s_min_us = 0xffffffff, s_max_us;
 
 	if (!dsi_perf)
 		return;
@@ -391,34 +398,57 @@ static void perf_show(const char *name)
 		dsi.update_region.bytespp;
 
 	if (dsi.update_mode == OMAP_DSS_UPDATE_AUTO) {
+		static u32 s_total_trans_us, s_total_setup_us;
+		static u32 s_min_trans_us = 0xffffffff, s_min_setup_us;
+		static u32 s_max_trans_us, s_max_setup_us;
+		const int numframes = 100;
+		ktime_t total_time_auto;
+		u32 total_time_auto_us;
+
 		dsi.perf_measure_frames++;
 
-		if (trans_us < s_min_us)
-			s_min_us = trans_us;
+		if (setup_us < s_min_setup_us)
+			s_min_setup_us = setup_us;
+
+		if (setup_us > s_max_setup_us)
+			s_max_setup_us = setup_us;
 
-		if (trans_us > s_max_us)
-			s_max_us = trans_us;
+		s_total_setup_us += setup_us;
 
-		s_trans_us += trans_us;
+		if (trans_us < s_min_trans_us)
+			s_min_trans_us = trans_us;
+
+		if (trans_us > s_max_trans_us)
+			s_max_trans_us = trans_us;
+
+		s_total_trans_us += trans_us;
 
 		if (dsi.perf_measure_frames < numframes)
 			return;
 
-		DSSINFO("%s update: %d frames in %u us "
-				"(min/max/avg %u/%u/%u), %u fps\n",
-				name, numframes,
-				s_trans_us,
-				s_min_us,
-				s_max_us,
-				s_trans_us / numframes,
-				1000*1000 / (s_trans_us / numframes));
+		total_time_auto = ktime_sub(t, dsi.perf_start_time_auto);
+		total_time_auto_us = (u32)ktime_to_us(total_time_auto);
+
+		printk("DSI(%s): %u fps, setup %u/%u/%u, trans %u/%u/%u\n",
+				name,
+				1000 * 1000 * numframes / total_time_auto_us,
+				s_min_setup_us,
+				s_max_setup_us,
+				s_total_setup_us / numframes,
+				s_min_trans_us,
+				s_max_trans_us,
+				s_total_trans_us / numframes);
 
 		dsi.perf_measure_frames = 0;
-		s_trans_us = 0;
-		s_min_us = 0xffffffff;
-		s_max_us = 0;
+		s_total_setup_us = 0;
+		s_min_setup_us = 0xffffffff;
+		s_max_setup_us = 0;
+		s_total_trans_us = 0;
+		s_min_trans_us = 0xffffffff;
+		s_max_trans_us = 0;
+		perf_mark_start_auto();
 	} else {
-		DSSINFO("%s update %u us + %u us = %u us (%uHz), %u bytes, "
+		printk("DSI(%s): %u us + %u us = %u us (%uHz), %u bytes, "
 				"%u kbytes/sec\n",
 				name,
 				setup_us,
@@ -541,6 +571,9 @@ void dsi_irq_handler(void)
 	if (irqstatus & DSI_IRQ_ERROR_MASK) {
 		DSSERR("DSI error, irqstatus %x\n", irqstatus);
 		print_irq_status(irqstatus);
+		spin_lock(&dsi.errors_lock);
+		dsi.errors |= irqstatus & DSI_IRQ_ERROR_MASK;
+		spin_unlock(&dsi.errors_lock);
 	} else if (debug_irq) {
 		print_irq_status(irqstatus);
 	}
@@ -616,6 +649,17 @@ static void _dsi_initialize_irq(void)
 			-1 & (~DSI_CIO_IRQ_ERRCONTROL2));
 }
 
+static u32 dsi_get_errors(void)
+{
+	unsigned long flags;
+	u32 e;
+	spin_lock_irqsave(&dsi.errors_lock, flags);
+	e = dsi.errors;
+	dsi.errors = 0;
+	spin_unlock_irqrestore(&dsi.errors_lock, flags);
+	return e;
+}
+
 static void dsi_vc_enable_bta_irq(int channel)
 {
 	u32 l;
@@ -719,19 +763,19 @@ static unsigned long dsi_fclk_rate(void)
 	return r;
 }
 
-static int dsi_set_lp_clk_divisor(void)
+static int dsi_set_lp_clk_divisor(struct omap_display *display)
 {
-	int n;
+	unsigned n;
 	unsigned long dsi_fclk;
-	unsigned long mhz;
-
-	/* LP_CLK_DIVISOR, DSI fclk/n, should be 20MHz - 32kHz */
+	unsigned long lp_clk, lp_clk_req;
 
 	dsi_fclk = dsi_fclk_rate();
 
+	lp_clk_req = display->hw_config.u.dsi.lp_clk_hz;
+
 	for (n = 1; n < (1 << 13) - 1; ++n) {
-		mhz = dsi_fclk / n;
-		if (mhz <= 20*1000*1000)
+		lp_clk = dsi_fclk / 2 / n;
+		if (lp_clk <= lp_clk_req)
 			break;
 	}
 
@@ -740,7 +784,7 @@ static int dsi_set_lp_clk_divisor(void)
 		return -EINVAL;
 	}
 
-	DSSDBG("LP_CLK_DIV %d, LP_CLK %ld\n", n, mhz);
+	DSSDBG("LP_CLK_DIV %u, LP_CLK %lu (req %lu)\n", n, lp_clk, lp_clk_req);
 
 	REG_FLD_MOD(DSI_CLK_CTRL, n, 12, 0);	/* LP_CLK_DIVISOR */
 	if (dsi_fclk > 30*1000*1000)
@@ -1380,28 +1424,28 @@ static void dsi_complexio_timings(void)
 	/* 1 * DDR_CLK = 2 * UI */
 
 	/* min 40ns + 4*UI	max 85ns + 6*UI */
-	ths_prepare = ns2ddr(59) + 2;
+	ths_prepare = ns2ddr(70) + 2;
 
 	/* min 145ns + 10*UI */
-	ths_prepare_ths_zero = ns2ddr(145) + 5;
+	ths_prepare_ths_zero = ns2ddr(175) + 2;
 
 	/* min max(8*UI, 60ns+4*UI) */
-	ths_trail = max((unsigned)4, ns2ddr(60) + 2);
+	ths_trail = ns2ddr(60) + 5;
 
 	/* min 100ns */
-	ths_exit = ns2ddr(100);
+	ths_exit = ns2ddr(145);
 
 	/* tlpx min 50n */
 	tlpx_half = ns2ddr(25);
 
 	/* min 60ns */
-	tclk_trail = ns2ddr(60);
+	tclk_trail = ns2ddr(60) + 2;
 
 	/* min 38ns, max 95ns */
-	tclk_prepare = ns2ddr(38);
+	tclk_prepare = ns2ddr(65);
 
 	/* min tclk-prepare + tclk-zero = 300ns */
-	tclk_zero = ns2ddr(300 - 38);
+	tclk_zero = ns2ddr(260);
 
 	DSSDBG("ths_prepare %u (%uns), ths_prepare_ths_zero %u (%uns)\n",
 		ths_prepare, ddr2ns(ths_prepare),
@@ -1807,6 +1851,7 @@ static int dsi_vc_send_bta(int channel)
 static int dsi_vc_send_bta_sync(int channel)
 {
 	int r = 0;
+	u32 err;
 
 	init_completion(&dsi.bta_completion);
 
@@ -1822,6 +1867,13 @@ static int dsi_vc_send_bta_sync(int chan
 		r = -EIO;
 		goto err;
 	}
+
+	err = dsi_get_errors();
+	if (err) {
+		DSSERR("Error while sending BTA: %x\n", err);
+		r = -EIO;
+		goto err;
+	}
 err:
 	dsi_vc_disable_bta_irq(channel);
 
@@ -2285,15 +2337,26 @@ static int dsi_proto_config(struct omap_
 	return 0;
 }
 
-static void dsi_proto_timings(void)
+static void dsi_proto_timings(struct omap_display *display)
 {
-	int tlpx_half, tclk_zero, tclk_prepare, tclk_trail;
-	int tclk_pre, tclk_post;
-	int ddr_clk_pre, ddr_clk_post;
+	unsigned tlpx, tclk_zero, tclk_prepare, tclk_trail;
+	unsigned tclk_pre, tclk_post;
+	unsigned ths_prepare, ths_prepare_ths_zero, ths_zero;
+	unsigned ths_trail, ths_exit;
+	unsigned ddr_clk_pre, ddr_clk_post;
+	unsigned enter_hs_mode_lat, exit_hs_mode_lat;
+	unsigned ths_eot;
 	u32 r;
 
+	r = dsi_read_reg(DSI_DSIPHY_CFG0);
+	ths_prepare = FLD_GET(r, 31, 24);
+	ths_prepare_ths_zero = FLD_GET(r, 23, 16);
+	ths_zero = ths_prepare_ths_zero - ths_prepare;
+	ths_trail = FLD_GET(r, 15, 8);
+	ths_exit = FLD_GET(r, 7, 0);
+
 	r = dsi_read_reg(DSI_DSIPHY_CFG1);
-	tlpx_half = FLD_GET(r, 22, 16);
+	tlpx = FLD_GET(r, 22, 16) * 2;
 	tclk_trail = FLD_GET(r, 15, 8);
 	tclk_zero = FLD_GET(r, 7, 0);
 
@@ -2305,17 +2368,40 @@ static void dsi_proto_timings(void)
 	/* min 60ns + 52*UI */
 	tclk_post = ns2ddr(60) + 26;
 
-	ddr_clk_pre = (tclk_pre + tlpx_half*2 + tclk_zero + tclk_prepare) / 4;
-	ddr_clk_post = (tclk_post + tclk_trail) / 4;
+	/* ths_eot is 2 for 2 datalanes and 4 for 1 datalane */
+	if (display->hw_config.u.dsi.data1_lane != 0 &&
+			display->hw_config.u.dsi.data2_lane != 0)
+		ths_eot = 2;
+	else
+		ths_eot = 4;
+
+	ddr_clk_pre = DIV_ROUND_UP(tclk_pre + tlpx + tclk_zero + tclk_prepare,
+			4);
+	ddr_clk_post = DIV_ROUND_UP(tclk_post + tclk_trail, 4) + ths_eot;
+
+	BUG_ON(ddr_clk_pre == 0 || ddr_clk_pre > 255);
+	BUG_ON(ddr_clk_post == 0 || ddr_clk_post > 255);
 
 	r = dsi_read_reg(DSI_CLK_TIMING);
 	r = FLD_MOD(r, ddr_clk_pre, 15, 8);
 	r = FLD_MOD(r, ddr_clk_post, 7, 0);
 	dsi_write_reg(DSI_CLK_TIMING, r);
 
-	DSSDBG("ddr_clk_pre %d, ddr_clk_post %d\n",
+	DSSDBG("ddr_clk_pre %u, ddr_clk_post %u\n",
 			ddr_clk_pre,
 			ddr_clk_post);
+
+	enter_hs_mode_lat = 1 + DIV_ROUND_UP(tlpx, 4) +
+		DIV_ROUND_UP(ths_prepare, 4) +
+		DIV_ROUND_UP(ths_zero + 3, 4);
+	exit_hs_mode_lat = DIV_ROUND_UP(ths_trail + ths_exit, 4) + 1 + ths_eot;
+
+	r = FLD_VAL(enter_hs_mode_lat, 31, 16) |
+		FLD_VAL(exit_hs_mode_lat, 15, 0);
+	dsi_write_reg(DSI_VM_TIMING7, r);
+
+	DSSDBG("enter_hs_mode_lat %u, exit_hs_mode_lat %u\n",
+			enter_hs_mode_lat, exit_hs_mode_lat);
 }
 
 
@@ -2649,6 +2735,9 @@ static void dsi_update_screen_dispc(stru
 
 	display->ctrl->setup_update(display, x, y, w, h);
 
+	if (dsi.use_ext_te && display->ctrl->wait_for_te)
+		display->ctrl->wait_for_te(display);
+
 	if (0)
 		dsi_vc_print_status(1);
 
@@ -2665,6 +2754,8 @@ static void dsi_update_screen_dispc(stru
 		l = FLD_MOD(l, 1, 31, 31); /* TE_START */
 	dsi_write_reg(DSI_VC_TE(1), l);
 
+	dispc_disable_sidle();
+
 	dispc_enable_lcd_out(1);
 
 	if (dsi.use_te)
@@ -2678,6 +2769,8 @@ static void framedone_callback(void *dat
 		return;
 	}
 
+	dispc_enable_sidle();
+
 	dsi.framedone_scheduled = 1;
 
 	/* We get FRAMEDONE when DISPC has finished sending pixels and turns
@@ -2752,6 +2845,8 @@ static void dsi_start_auto_update(struct
 	dsi.autoupdate_setup = 1;
 
 	dsi_push_autoupdate(display);
+
+	perf_mark_start_auto();
 }
 
 
@@ -2910,19 +3005,24 @@ end:
 
 static void dsi_do_cmd_set_te(struct omap_display *display, bool enable)
 {
-	dsi.use_te = enable;
+	if (!display->hw_config.u.dsi.ext_te)
+		dsi.use_te = enable;
+	else
+		dsi.use_ext_te = enable;
 
 	if (display->state != OMAP_DSS_DISPLAY_ACTIVE)
 		return;
 
 	display->ctrl->enable_te(display, enable);
 
-	if (enable) {
-		/* disable LP_RX_TO, so that we can receive TE.
-		 * Time to wait for TE is longer than the timer allows */
-		REG_FLD_MOD(DSI_TIMING2, 0, 15, 15); /* LP_RX_TO */
-	} else {
-		REG_FLD_MOD(DSI_TIMING2, 1, 15, 15); /* LP_RX_TO */
+	if (!display->hw_config.u.dsi.ext_te) {
+		if (enable) {
+			/* disable LP_RX_TO, so that we can receive TE.
+			 * Time to wait for TE is longer than the timer allows */
+			REG_FLD_MOD(DSI_TIMING2, 0, 15, 15); /* LP_RX_TO */
+		} else {
+			REG_FLD_MOD(DSI_TIMING2, 1, 15, 15); /* LP_RX_TO */
+		}
 	}
 }
 
@@ -3212,7 +3312,7 @@ static void dsi_push_set_mirror(struct o
 
 static int dsi_wait_sync(struct omap_display *display)
 {
-	long wait = msecs_to_jiffies(60000);
+	long wait = msecs_to_jiffies(2000);
 	struct completion compl;
 
 	DSSDBGF("");
@@ -3312,8 +3412,8 @@ static int dsi_display_init_dsi(struct o
 
 	_dsi_print_reset_status();
 
-	dsi_proto_timings();
-	dsi_set_lp_clk_divisor();
+	dsi_proto_timings(display);
+	dsi_set_lp_clk_divisor(display);
 
 	if (1)
 		_dsi_print_reset_status();
@@ -3417,7 +3517,7 @@ static int dsi_display_enable(struct oma
 
 	display->state = OMAP_DSS_DISPLAY_ACTIVE;
 
-	if (dsi.use_te)
+	if (dsi.use_te || dsi.use_ext_te)
 		dsi_push_set_te(display, 1);
 
 	dsi_push_set_update_mode(display, dsi.user_update_mode);
@@ -3550,7 +3650,7 @@ static int dsi_display_enable_te(struct
 
 static int dsi_display_get_te(struct omap_display *display)
 {
-	return dsi.use_te;
+	return dsi.use_te | dsi.use_ext_te;
 }
 
 
@@ -3680,7 +3780,7 @@ static void dsi_configure_overlay(struct
 	dispc_setup_plane_fifo(plane, low, high);
 }
 
-void dsi_init_display(struct omap_display *display)
+int dsi_init_display(struct omap_display *display)
 {
 	DSSDBG("DSI init\n");
 
@@ -3710,12 +3810,17 @@ void dsi_init_display(struct omap_displa
 
 	dsi.vc[0].display = display;
 	dsi.vc[1].display = display;
+
+	return 0;
 }
 
 int dsi_init(void)
 {
 	u32 rev;
 
+	spin_lock_init(&dsi.errors_lock);
+	dsi.errors = 0;
+
 	spin_lock_init(&dsi.cmd_lock);
 	dsi.cmd_fifo = kfifo_alloc(
 			DSI_CMD_FIFO_LEN * sizeof(struct dsi_cmd_item),
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/dss.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/dss.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/dss.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/dss.c	2012-12-16 13:13:01.708330145 +0100
@@ -80,6 +80,17 @@ static inline u32 dss_read_reg(const str
 #define RR(reg) \
 	dss_write_reg(DSS_##reg, dss.ctx[(DSS_##reg).idx / sizeof(u32)])
 
+int dss_check_context(void)
+{
+	if (cpu_is_omap24xx())
+		return 0;
+
+	if (dss_read_reg(DSS_CONTROL) == 0)
+		return -EINVAL;
+
+	return 0;
+}
+
 void dss_save_context(void)
 {
 	if (cpu_is_omap24xx())
@@ -130,8 +141,10 @@ void dss_sdi_init(u8 datapairs)
 	dss_write_reg(DSS_PLL_CONTROL, l);
 }
 
-void dss_sdi_enable(void)
+int dss_sdi_enable(void)
 {
+	unsigned long timeout;
+
 	dispc_pck_free_enable(1);
 
 	/* Reset SDI PLL */
@@ -142,21 +155,48 @@ void dss_sdi_enable(void)
 	REG_FLD_MOD(DSS_PLL_CONTROL, 1, 28, 28); /* SDI_PLL_GOBIT */
 
 	/* Waiting for PLL lock request to complete */
-	while (dss_read_reg(DSS_SDI_STATUS) & (1 << 6))
-		;
+	timeout = jiffies + msecs_to_jiffies(500);
+	while (dss_read_reg(DSS_SDI_STATUS) & (1 << 6)) {
+		if (time_after_eq(jiffies, timeout)) {
+			DSSERR("PLL lock request timed out\n");
+			goto err1;
+		}
+	}
 
 	/* Clearing PLL_GO bit */
 	REG_FLD_MOD(DSS_PLL_CONTROL, 0, 28, 28);
 
 	/* Waiting for PLL to lock */
-	while (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 5)))
-		;
+	timeout = jiffies + msecs_to_jiffies(500);
+	while (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 5))) {
+		if (time_after_eq(jiffies, timeout)) {
+			DSSERR("PLL lock timed out\n");
+			goto err1;
+		}
+	}
 
 	dispc_lcd_enable_signal(1);
 
 	/* Waiting for SDI reset to complete */
-	while (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 2)))
-		;
+	timeout = jiffies + msecs_to_jiffies(500);
+	while (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 2))) {
+		if (time_after_eq(jiffies, timeout)) {
+			DSSERR("SDI reset timed out\n");
+			goto err2;
+		}
+	}
+
+	return 0;
+
+ err2:
+	dispc_lcd_enable_signal(0);
+ err1:
+	/* Reset SDI PLL */
+	REG_FLD_MOD(DSS_PLL_CONTROL, 0, 18, 18); /* SDI_PLL_SYSRESET */
+
+	dispc_pck_free_enable(0);
+
+	return -ETIMEDOUT;
 }
 
 void dss_sdi_disable(void)
@@ -245,7 +285,7 @@ static int _omap_dss_wait_reset(void)
 	return 0;
 }
 
-static int _omap_dss_reset(void)
+int dss_reset(void)
 {
 	/* Soft reset */
 	REG_FLD_MOD(DSS_SYSCONFIG, 1, 1, 1);
@@ -285,6 +325,11 @@ int dss_init(bool skip_init)
 	}
 
 	if (!skip_init) {
+		/* disable LCD and DIGIT output. This seems to fix the synclost
+		 * problem that we get, if the bootloader starts the DSS and
+		 * the kernel resets it */
+		omap_writel(omap_readl(0x48050440) & ~0x3, 0x48050440);
+
 		/* We need to wait here a bit, otherwise we sometimes start to
 		 * get synclost errors, and after that only power cycle will
 		 * restore DSS functionality. I have no idea why this happens.
@@ -293,11 +338,8 @@ int dss_init(bool skip_init)
 		 */
 		msleep(50);
 
-		_omap_dss_reset();
-
+		dss_reset();
 	}
-	else
-		printk("DSS SKIP RESET\n");
 
 	/* autoidle */
 	REG_FLD_MOD(DSS_SYSCONFIG, 1, 0, 0);
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/dss.h kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/dss.h
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/dss.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/dss.h	2012-12-16 13:13:01.708330145 +0100
@@ -163,24 +163,31 @@ void dss_clk_disable(enum dss_clock clks
 unsigned long dss_clk_get_rate(enum dss_clock clk);
 int dss_need_ctx_restore(void);
 void dss_dump_clocks(struct seq_file *s);
+const char *dss_get_def_disp_name(void);
+
 
 int dss_dsi_power_up(void);
 void dss_dsi_power_down(void);
 
+void dss_schedule_reset(void);
+
 /* display */
 void dss_init_displays(struct platform_device *pdev);
 void dss_uninit_displays(struct platform_device *pdev);
 int dss_suspend_all_displays(void);
 int dss_resume_all_displays(void);
 struct omap_display *dss_get_display(int no);
+bool dss_use_replication(struct omap_display *display,
+		enum omap_color_mode mode);
 
 /* manager */
 int dss_init_overlay_managers(struct platform_device *pdev);
 void dss_uninit_overlay_managers(struct platform_device *pdev);
 
 /* overlay */
-void dss_init_overlays(struct platform_device *pdev, const char *def_disp_name);
+void dss_init_overlays(struct platform_device *pdev);
 void dss_uninit_overlays(struct platform_device *pdev);
+void dss_recheck_connections(struct omap_display *display, bool force);
 int dss_check_overlay(struct omap_overlay *ovl, struct omap_display *display);
 void dss_overlay_setup_dispc_manager(struct omap_overlay_manager *mgr);
 
@@ -188,13 +195,16 @@ void dss_overlay_setup_dispc_manager(str
 int dss_init(bool skip_init);
 void dss_exit(void);
 
+int dss_check_context(void);
 void dss_save_context(void);
 void dss_restore_context(void);
 
+int dss_reset(void);
+
 void dss_dump_regs(struct seq_file *s);
 
 void dss_sdi_init(u8 datapairs);
-void dss_sdi_enable(void);
+int dss_sdi_enable(void);
 void dss_sdi_disable(void);
 
 void dss_select_clk_source(bool dsi, bool dispc);
@@ -206,7 +216,7 @@ void dss_set_dac_pwrdn_bgz(bool enable);
 /* SDI */
 int sdi_init(bool skip_init);
 void sdi_exit(void);
-void sdi_init_display(struct omap_display *display);
+int sdi_init_display(struct omap_display *display);
 
 /* DSI */
 int dsi_init(void);
@@ -218,7 +228,7 @@ void dsi_dump_regs(struct seq_file *s);
 void dsi_save_context(void);
 void dsi_restore_context(void);
 
-void dsi_init_display(struct omap_display *display);
+int dsi_init_display(struct omap_display *display);
 void dsi_irq_handler(void);
 unsigned long dsi_get_dsi1_pll_rate(void);
 unsigned long dsi_get_dsi2_pll_rate(void);
@@ -231,7 +241,7 @@ void dsi_pll_uninit(void);
 /* DPI */
 int dpi_init(void);
 void dpi_exit(void);
-void dpi_init_display(struct omap_display *display);
+int dpi_init_display(struct omap_display *display);
 
 /* DISPC */
 int dispc_init(void);
@@ -244,6 +254,9 @@ void dispc_fake_vsync_irq(void);
 void dispc_save_context(void);
 void dispc_restore_context(void);
 
+void dispc_enable_sidle(void);
+void dispc_disable_sidle(void);
+
 void dispc_lcd_enable_signal_polarity(bool act_high);
 void dispc_lcd_enable_signal(bool enable);
 void dispc_pck_free_enable(bool enable);
@@ -254,6 +267,7 @@ void dispc_set_digit_size(u16 width, u16
 u32 dispc_get_plane_fifo_size(enum omap_plane plane);
 void dispc_setup_plane_fifo(enum omap_plane plane, u32 low, u32 high);
 void dispc_enable_fifomerge(bool enable);
+void dispc_set_overlay_optimization(void);
 void dispc_set_burst_size(enum omap_plane plane,
 		enum omap_burst_size burst_size);
 
@@ -269,12 +283,16 @@ int dispc_setup_plane(enum omap_plane pl
 		      u16 out_width, u16 out_height,
 		      enum omap_color_mode color_mode,
 		      bool ilace,
-		      u8 rotation, bool mirror);
+		      enum omap_dss_rotation_type rotation_type,
+		      u8 rotation, bool mirror,
+		      u8 global_alpha);
 
 void dispc_go(enum omap_channel channel);
 void dispc_enable_lcd_out(bool enable);
 void dispc_enable_digit_out(bool enable);
+void dispc_enable_digit_errors(int enable);
 int dispc_enable_plane(enum omap_plane plane, bool enable);
+void dispc_enable_replication(enum omap_plane plane, bool enable);
 
 void dispc_set_parallel_interface_mode(enum omap_parallel_interface_mode mode);
 void dispc_set_tft_data_lines(u8 data_lines);
@@ -290,7 +308,9 @@ void dispc_get_trans_key(enum omap_chann
 		enum omap_dss_color_key_type *type,
 		u32 *trans_key);
 void dispc_enable_trans_key(enum omap_channel ch, bool enable);
+void dispc_enable_alpha_blending(enum omap_channel ch, bool enable);
 bool dispc_trans_key_enabled(enum omap_channel ch);
+bool dispc_alpha_blending_enabled(enum omap_channel ch);
 
 void dispc_set_lcd_timings(struct omap_video_timings *timings);
 unsigned long dispc_fclk_rate(void);
@@ -311,10 +331,10 @@ void dispc_draw_partial_planes(struct om
 
 
 /* VENC */
-int venc_init(void);
+int venc_init(struct platform_device *pdev);
 void venc_exit(void);
 void venc_dump_regs(struct seq_file *s);
-void venc_init_display(struct omap_display *display);
+int venc_init_display(struct omap_display *display);
 
 /* RFBI */
 int rfbi_init(void);
@@ -327,6 +347,6 @@ void rfbi_transfer_area(u16 width, u16 h
 			     void (callback)(void *data), void *data);
 void rfbi_set_timings(int rfbi_module, struct rfbi_timings *t);
 unsigned long rfbi_get_max_tx_rate(void);
-void rfbi_init_display(struct omap_display *display);
+int rfbi_init_display(struct omap_display *display);
 
 #endif
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/manager.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/manager.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/manager.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/manager.c	2012-12-16 13:13:01.708330145 +0100
@@ -70,6 +70,11 @@ static ssize_t manager_display_store(str
 	if (display)
 		DSSDBG("display %s found\n", display->name);
 
+	if (display && display->state == OMAP_DSS_DISPLAY_UNINITIALIZED) {
+		DSSERR("display %s not initialized\n", display->name);
+		return -ENODEV;
+	}
+
 	if (mgr->display) {
 		r = mgr->unset_display(mgr);
 		if (r) {
@@ -98,10 +103,8 @@ static ssize_t manager_display_store(str
 static ssize_t manager_default_color_show(struct omap_overlay_manager *mgr,
 					  char *buf)
 {
-	u32 default_color;
-
-	default_color = dispc_get_default_color(mgr->id);
-	return snprintf(buf, PAGE_SIZE, "%d", default_color);
+	return snprintf(buf, PAGE_SIZE, "%d",
+			mgr->get_default_color(mgr));
 }
 
 static ssize_t manager_default_color_store(struct omap_overlay_manager *mgr,
@@ -111,7 +114,9 @@ static ssize_t manager_default_color_sto
 
 	if (sscanf(buf, "%d", &default_color) != 1)
 		return -EINVAL;
+	omap_dss_lock();
 	dispc_set_default_color(mgr->id, default_color);
+	omap_dss_unlock();
 
 	return size;
 }
@@ -126,7 +131,9 @@ static ssize_t manager_color_key_type_sh
 {
 	enum omap_dss_color_key_type key_type;
 
-	dispc_get_trans_key(mgr->id, &key_type, NULL);
+	omap_dss_lock();
+	mgr->get_trans_key_type_and_value(mgr, &key_type, NULL);
+	omap_dss_unlock();
 	BUG_ON(key_type >= ARRAY_SIZE(color_key_type_str));
 
 	return snprintf(buf, PAGE_SIZE, "%s\n", color_key_type_str[key_type]);
@@ -139,14 +146,32 @@ static ssize_t manager_color_key_type_st
 	u32 key_value;
 
 	for (key_type = OMAP_DSS_COLOR_KEY_GFX_DST;
-	     key_type < ARRAY_SIZE(color_key_type_str); key_type++) {
+			key_type < ARRAY_SIZE(color_key_type_str); key_type++) {
 		if (sysfs_streq(buf, color_key_type_str[key_type]))
 			break;
 	}
 	if (key_type == ARRAY_SIZE(color_key_type_str))
 		return -EINVAL;
-	dispc_get_trans_key(mgr->id, NULL, &key_value);
-	dispc_set_trans_key(mgr->id, key_type, key_value);
+	/* OMAP does not support destination color key and alpha blending
+	 * simultaneously.  So if alpha blending and color keying both are
+	 * enabled then refrain from setting the color key type to
+	 * gfx-destination
+	 */
+	omap_dss_lock();
+	if (!key_type) {
+		bool color_key_enabled;
+		bool alpha_blending_enabled;
+		color_key_enabled = mgr->get_trans_key_status(mgr);
+		alpha_blending_enabled = mgr->get_alpha_blending_status(mgr);
+		if (color_key_enabled && alpha_blending_enabled) {
+			omap_dss_unlock();
+			return -EINVAL;
+		}
+	}
+
+	mgr->get_trans_key_type_and_value(mgr, NULL, &key_value);
+	mgr->set_trans_key_type_and_value(mgr, key_type, key_value);
+	omap_dss_unlock();
 
 	return size;
 }
@@ -156,7 +181,9 @@ static ssize_t manager_color_key_value_s
 {
 	u32 key_value;
 
-	dispc_get_trans_key(mgr->id, NULL, &key_value);
+	omap_dss_lock();
+	mgr->get_trans_key_type_and_value(mgr, NULL, &key_value);
+	omap_dss_unlock();
 
 	return snprintf(buf, PAGE_SIZE, "%d\n", key_value);
 }
@@ -169,8 +196,10 @@ static ssize_t manager_color_key_value_s
 
 	if (sscanf(buf, "%d", &key_value) != 1)
 		return -EINVAL;
-	dispc_get_trans_key(mgr->id, &key_type, NULL);
-	dispc_set_trans_key(mgr->id, key_type, key_value);
+	omap_dss_lock();
+	mgr->get_trans_key_type_and_value(mgr, &key_type, NULL);
+	mgr->set_trans_key_type_and_value(mgr, key_type, key_value);
+	omap_dss_unlock();
 
 	return size;
 }
@@ -178,8 +207,13 @@ static ssize_t manager_color_key_value_s
 static ssize_t manager_color_key_enabled_show(struct omap_overlay_manager *mgr,
 					      char *buf)
 {
-	return snprintf(buf, PAGE_SIZE, "%d\n",
-			dispc_trans_key_enabled(mgr->id));
+	int status;
+
+	omap_dss_lock();
+	status = mgr->get_trans_key_status(mgr);
+	omap_dss_unlock();
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", status);
 }
 
 static ssize_t manager_color_key_enabled_store(struct omap_overlay_manager *mgr,
@@ -190,11 +224,93 @@ static ssize_t manager_color_key_enabled
 	if (sscanf(buf, "%d", &enable) != 1)
 		return -EINVAL;
 
-	dispc_enable_trans_key(mgr->id, enable);
+	/* OMAP does not support destination color keying and
+	 * alpha blending simultaneously.  so if alpha blending
+	 * is enabled refrain from enabling destination color
+	 * keying.
+	 */
+	omap_dss_lock();
+	if (enable) {
+		bool enabled;
+		enabled = mgr->get_alpha_blending_status(mgr);
+		if (enabled) {
+			enum omap_dss_color_key_type key_type;
+			mgr->get_trans_key_type_and_value(mgr,
+					&key_type, NULL);
+			if (!key_type) {
+				omap_dss_unlock();
+				return -EINVAL;
+			}
+		}
+
+	}
+	mgr->enable_trans_key(mgr, enable);
+	omap_dss_unlock();
+
+	return size;
+}
+static ssize_t manager_alpha_blending_enabled_show(
+		struct omap_overlay_manager *mgr, char *buf)
+{
+	int status;
+
+	omap_dss_lock();
+	status = mgr->get_alpha_blending_status(mgr);
+	omap_dss_unlock();
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", status);
+}
+static ssize_t manager_alpha_blending_enabled_store(
+		struct omap_overlay_manager *mgr,
+		const char *buf, size_t size)
+{
+	int enable;
+	if (sscanf(buf, "%d", &enable) != 1)
+		return -EINVAL;
+	/* OMAP does not support destination color keying and
+	 * alpha blending simultaneously.  so if destination
+	 * color keying is enabled refrain from enabling
+	 * alpha blending
+	 */
+	omap_dss_lock();
+	if (enable) {
+		bool enabled;
+		enabled = mgr->get_trans_key_status(mgr);
+		if (enabled) {
+			enum omap_dss_color_key_type key_type;
+			mgr->get_trans_key_type_and_value(mgr, &key_type, NULL);
+			if (!key_type) {
+				omap_dss_unlock();
+				return -EINVAL;
+			}
+		}
+
+	}
+	mgr->enable_alpha_blending(mgr, enable);
+	omap_dss_unlock();
 
 	return size;
 }
 
+static ssize_t reset_show(
+		struct omap_overlay_manager *mgr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", 0);
+}
+static ssize_t reset_store(
+		struct omap_overlay_manager *mgr,
+		const char *buf, size_t size)
+{
+	int enable;
+	if (sscanf(buf, "%d", &enable) != 1)
+		return -EINVAL;
+	if (enable != 0 && enable != 1)
+		return -EINVAL;
+
+	dss_schedule_reset();
+
+	return size;
+}
 
 struct manager_attribute {
 	struct attribute attr;
@@ -217,6 +333,13 @@ static MANAGER_ATTR(color_key_value, S_I
 		manager_color_key_value_show, manager_color_key_value_store);
 static MANAGER_ATTR(color_key_enabled, S_IRUGO|S_IWUSR,
 		manager_color_key_enabled_show, manager_color_key_enabled_store);
+static MANAGER_ATTR(alpha_blending_enabled, S_IRUGO|S_IWUSR,
+		manager_alpha_blending_enabled_show,
+		manager_alpha_blending_enabled_store);
+static MANAGER_ATTR(reset, S_IRUGO|S_IWUSR,
+		reset_show,
+		reset_store);
+
 
 static struct attribute *manager_sysfs_attrs[] = {
 	&manager_attr_name.attr,
@@ -225,6 +348,8 @@ static struct attribute *manager_sysfs_a
 	&manager_attr_color_key_type.attr,
 	&manager_attr_color_key_value.attr,
 	&manager_attr_color_key_enabled.attr,
+	&manager_attr_alpha_blending_enabled.attr,
+	&manager_attr_reset.attr,
 	NULL
 };
 
@@ -288,7 +413,7 @@ static int omap_dss_set_display(struct o
 	for (i = 0; i < mgr->num_overlays; i++) {
 		struct omap_overlay *ovl = mgr->overlays[i];
 
-		if (ovl->manager != mgr || !ovl->info.enabled)
+		if (ovl->manager != mgr)
 			continue;
 
 		r = dss_check_overlay(ovl, display);
@@ -331,7 +456,7 @@ static int omap_dss_mgr_apply(struct oma
 	enum omap_dss_update_mode mode;
 	struct omap_display *display;
 	struct omap_overlay *ovl;
-	bool ilace = 0;
+	bool ilace;
 	int outw, outh;
 	int r;
 	int num_planes_enabled = 0;
@@ -371,8 +496,7 @@ static int omap_dss_mgr_apply(struct oma
 				mode != OMAP_DSS_UPDATE_AUTO)
 			continue;
 
-		if (display->type == OMAP_DISPLAY_TYPE_VENC)
-			ilace = 1;
+		ilace = display->type == OMAP_DISPLAY_TYPE_VENC;
 
 		if (ovl->info.out_width == 0)
 			outw = ovl->info.width;
@@ -395,8 +519,10 @@ static int omap_dss_mgr_apply(struct oma
 				outh,
 				ovl->info.color_mode,
 				ilace,
+				ovl->info.rotation_type,
 				ovl->info.rotation,
-				ovl->info.mirror);
+				ovl->info.mirror,
+				ovl->info.global_alpha);
 
 		if (r) {
 			DSSERR("dispc_setup_plane failed for ovl %d\n",
@@ -405,9 +531,16 @@ static int omap_dss_mgr_apply(struct oma
 			continue;
 		}
 
+		if (dss_use_replication(display, ovl->info.color_mode))
+			dispc_enable_replication(ovl->id, true);
+		else
+			dispc_enable_replication(ovl->id, false);
+
 		dispc_enable_plane(ovl->id, 1);
 	}
 
+	dispc_set_overlay_optimization();
+
 	/* Enable fifo merge if possible */
 	dispc_enable_fifomerge(num_planes_enabled == 1);
 
@@ -427,6 +560,9 @@ static int omap_dss_mgr_apply(struct oma
 		ovl->manager->display->configure_overlay(ovl);
 	}
 
+	/* Try to prevent FIFO undeflows. */
+	omap_dss_update_min_bus_tput();
+
 	/* Issue GO for managers */
 	list_for_each_entry(mgr, &manager_list, list) {
 		if (!(mgr->caps & OMAP_DSS_OVL_MGR_CAP_DISPC))
@@ -457,18 +593,44 @@ static void omap_dss_mgr_set_def_color(s
 	dispc_set_default_color(mgr->id, color);
 }
 
-static void omap_dss_mgr_set_trans_key(struct omap_overlay_manager *mgr,
+static void omap_dss_mgr_set_trans_key_type_and_value(
+		struct omap_overlay_manager *mgr,
 		enum omap_dss_color_key_type type,
 		u32 trans_key)
 {
 	dispc_set_trans_key(mgr->id, type, trans_key);
 }
+static void omap_dss_mgr_get_trans_key_type_and_value(
+		struct omap_overlay_manager *mgr,
+		enum omap_dss_color_key_type *type,
+		u32 *trans_key)
+{
+	dispc_get_trans_key(mgr->id, type, trans_key);
+}
 
 static void omap_dss_mgr_enable_trans_key(struct omap_overlay_manager *mgr,
 		bool enable)
 {
 	dispc_enable_trans_key(mgr->id, enable);
 }
+static void omap_dss_mgr_enable_alpha_blending(struct omap_overlay_manager *mgr,
+		bool enable)
+{
+	dispc_enable_alpha_blending(mgr->id, enable);
+}
+static bool omap_dss_mgr_get_alpha_blending_status(
+		struct omap_overlay_manager *mgr)
+{
+	return dispc_alpha_blending_enabled(mgr->id);
+}
+static u32 omap_dss_mgr_get_default_color(struct omap_overlay_manager *mgr)
+{
+	return dispc_get_default_color(mgr->id);
+}
+static bool omap_dss_mgr_get_trans_key_status(struct omap_overlay_manager *mgr)
+{
+	return dispc_trans_key_enabled(mgr->id);
+}
 
 static void omap_dss_add_overlay_manager(struct omap_overlay_manager *manager)
 {
@@ -505,13 +667,22 @@ int dss_init_overlay_managers(struct pla
 			break;
 		}
 
-		mgr->set_display = &omap_dss_set_display,
-		mgr->unset_display = &omap_dss_unset_display,
-		mgr->apply = &omap_dss_mgr_apply,
-		mgr->set_default_color = &omap_dss_mgr_set_def_color,
-		mgr->set_trans_key = &omap_dss_mgr_set_trans_key,
-		mgr->enable_trans_key = &omap_dss_mgr_enable_trans_key,
-		mgr->caps = OMAP_DSS_OVL_MGR_CAP_DISPC,
+		mgr->set_display = &omap_dss_set_display;
+		mgr->unset_display = &omap_dss_unset_display;
+		mgr->apply = &omap_dss_mgr_apply;
+		mgr->set_default_color = &omap_dss_mgr_set_def_color;
+		mgr->set_trans_key_type_and_value =
+			&omap_dss_mgr_set_trans_key_type_and_value;
+		mgr->get_trans_key_type_and_value =
+			&omap_dss_mgr_get_trans_key_type_and_value;
+		mgr->enable_trans_key = &omap_dss_mgr_enable_trans_key;
+		mgr->get_trans_key_status = &omap_dss_mgr_get_trans_key_status;
+		mgr->enable_alpha_blending =
+			&omap_dss_mgr_enable_alpha_blending;
+		mgr->get_alpha_blending_status =
+			omap_dss_mgr_get_alpha_blending_status;
+		mgr->get_default_color = &omap_dss_mgr_get_default_color;
+		mgr->caps = OMAP_DSS_OVL_MGR_CAP_DISPC;
 
 		dss_overlay_setup_dispc_manager(mgr);
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/overlay.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/overlay.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/overlay.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/overlay.c	2012-12-16 13:13:01.708330145 +0100
@@ -92,8 +92,13 @@ static ssize_t overlay_manager_store(str
 		}
 	}
 
-	if (ovl->manager && (r = ovl->manager->apply(ovl->manager)))
-		return r;
+	if (ovl->manager) {
+		omap_dss_lock();
+		r = ovl->manager->apply(ovl->manager);
+		omap_dss_unlock();
+		if (r)
+			return r;
+	}
 
 	return size;
 }
@@ -134,8 +139,13 @@ static ssize_t overlay_position_store(st
 	if ((r = ovl->set_overlay_info(ovl, &info)))
 		return r;
 
-	if (ovl->manager && (r = ovl->manager->apply(ovl->manager)))
-		return r;
+	if (ovl->manager) {
+		omap_dss_lock();
+		r = ovl->manager->apply(ovl->manager);
+		omap_dss_unlock();
+		if (r)
+			return r;
+	}
 
 	return size;
 }
@@ -165,8 +175,13 @@ static ssize_t overlay_output_size_store
 	if ((r = ovl->set_overlay_info(ovl, &info)))
 		return r;
 
-	if (ovl->manager && (r = ovl->manager->apply(ovl->manager)))
-		return r;
+	if (ovl->manager) {
+		omap_dss_lock();
+		r = ovl->manager->apply(ovl->manager);
+		omap_dss_unlock();
+		if (r)
+			return r;
+	}
 
 	return size;
 }
@@ -188,9 +203,51 @@ static ssize_t overlay_enabled_store(str
 	if ((r = ovl->set_overlay_info(ovl, &info)))
 		return r;
 
-	if (ovl->manager && (r = ovl->manager->apply(ovl->manager)))
+	if (ovl->manager) {
+		omap_dss_lock();
+		r = ovl->manager->apply(ovl->manager);
+		omap_dss_unlock();
+
+		if (r)
+			return r;
+	}
+
+	return size;
+}
+
+static ssize_t overlay_global_alpha_show(struct omap_overlay *ovl, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			ovl->info.global_alpha);
+}
+
+static ssize_t overlay_global_alpha_store(struct omap_overlay *ovl,
+		const char *buf, size_t size)
+{
+	int r;
+	struct omap_overlay_info info;
+
+	ovl->get_overlay_info(ovl, &info);
+
+	/* Video1 plane does not support global alpha
+	 * to always make it 255 completely opaque
+	 */
+	if (ovl->id == OMAP_DSS_VIDEO1)
+		info.global_alpha = 255;
+	else
+		info.global_alpha = simple_strtoul(buf, NULL, 10);
+
+	if ((r = ovl->set_overlay_info(ovl, &info)))
 		return r;
 
+	if (ovl->manager) {
+		omap_dss_lock();
+		r = ovl->manager->apply(ovl->manager);
+		omap_dss_unlock();
+		if (r)
+			return r;
+	}
+
 	return size;
 }
 
@@ -215,6 +272,8 @@ static OVERLAY_ATTR(output_size, S_IRUGO
 		overlay_output_size_show, overlay_output_size_store);
 static OVERLAY_ATTR(enabled, S_IRUGO|S_IWUSR,
 		overlay_enabled_show, overlay_enabled_store);
+static OVERLAY_ATTR(global_alpha, S_IRUGO|S_IWUSR,
+		overlay_global_alpha_show, overlay_global_alpha_store);
 
 static struct attribute *overlay_sysfs_attrs[] = {
 	&overlay_attr_name.attr,
@@ -224,6 +283,7 @@ static struct attribute *overlay_sysfs_a
 	&overlay_attr_position.attr,
 	&overlay_attr_output_size.attr,
 	&overlay_attr_enabled.attr,
+	&overlay_attr_global_alpha.attr,
 	NULL
 };
 
@@ -421,12 +481,12 @@ void dss_overlay_setup_dispc_manager(str
 	mgr->overlays = dispc_overlays;
 }
 
-void dss_init_overlays(struct platform_device *pdev, const char *def_disp_name)
+void dss_init_overlays(struct platform_device *pdev)
 {
 	int i, r;
 	struct omap_overlay_manager *lcd_mgr;
 	struct omap_overlay_manager *tv_mgr;
-	struct omap_overlay_manager *def_mgr = NULL;
+	struct omap_dss_board_info *pdata = pdev->dev.platform_data;
 
 	INIT_LIST_HEAD(&overlay_list);
 
@@ -442,22 +502,43 @@ void dss_init_overlays(struct platform_d
 		case 0:
 			ovl->name = "gfx";
 			ovl->id = OMAP_DSS_GFX;
-			ovl->supported_modes = OMAP_DSS_COLOR_GFX_OMAP3;
+			ovl->supported_modes = cpu_is_omap34xx() ?
+				OMAP_DSS_COLOR_GFX_OMAP3 :
+				OMAP_DSS_COLOR_GFX_OMAP2;
 			ovl->caps = OMAP_DSS_OVL_CAP_DISPC;
+			ovl->info.global_alpha = 255;
+			ovl->info.fifo_threshold_low =
+				pdata->fifo_thresholds[OMAP_DSS_GFX].low;
+			ovl->info.fifo_threshold_high =
+				pdata->fifo_thresholds[OMAP_DSS_GFX].high;
 			break;
 		case 1:
 			ovl->name = "vid1";
 			ovl->id = OMAP_DSS_VIDEO1;
-			ovl->supported_modes = OMAP_DSS_COLOR_VID_OMAP3;
+			ovl->supported_modes = cpu_is_omap34xx() ?
+				OMAP_DSS_COLOR_VID1_OMAP3 :
+				OMAP_DSS_COLOR_VID_OMAP2;
 			ovl->caps = OMAP_DSS_OVL_CAP_SCALE |
 				OMAP_DSS_OVL_CAP_DISPC;
+			ovl->info.global_alpha = 255;
+			ovl->info.fifo_threshold_low =
+				pdata->fifo_thresholds[OMAP_DSS_VIDEO1].low;
+			ovl->info.fifo_threshold_high =
+				pdata->fifo_thresholds[OMAP_DSS_VIDEO1].high;
 			break;
 		case 2:
 			ovl->name = "vid2";
 			ovl->id = OMAP_DSS_VIDEO2;
-			ovl->supported_modes = OMAP_DSS_COLOR_VID_OMAP3;
+			ovl->supported_modes = cpu_is_omap34xx() ?
+				OMAP_DSS_COLOR_VID2_OMAP3 :
+				OMAP_DSS_COLOR_VID_OMAP2;
 			ovl->caps = OMAP_DSS_OVL_CAP_SCALE |
 				OMAP_DSS_OVL_CAP_DISPC;
+			ovl->info.global_alpha = 255;
+			ovl->info.fifo_threshold_low =
+				pdata->fifo_thresholds[OMAP_DSS_VIDEO2].low;
+			ovl->info.fifo_threshold_high =
+				pdata->fifo_thresholds[OMAP_DSS_VIDEO2].high;
 			break;
 		}
 
@@ -482,67 +563,6 @@ void dss_init_overlays(struct platform_d
 	lcd_mgr = omap_dss_get_overlay_manager(OMAP_DSS_OVL_MGR_LCD);
 	tv_mgr = omap_dss_get_overlay_manager(OMAP_DSS_OVL_MGR_TV);
 
-	if (def_disp_name) {
-		for (i = 0; i < omap_dss_get_num_displays() ; i++) {
-			struct omap_display *display = dss_get_display(i);
-
-			if (strcmp(display->name, def_disp_name) == 0) {
-				if (display->type != OMAP_DISPLAY_TYPE_VENC) {
-					lcd_mgr->set_display(lcd_mgr, display);
-					def_mgr = lcd_mgr;
-				} else {
-					lcd_mgr->set_display(tv_mgr, display);
-					def_mgr = tv_mgr;
-				}
-
-				break;
-			}
-		}
-
-		if (!def_mgr)
-			DSSWARN("default display %s not found\n",
-					def_disp_name);
-	}
-
-	if (def_mgr != lcd_mgr) {
-		/* connect lcd manager to first non-VENC display found */
-		for (i = 0; i < omap_dss_get_num_displays(); i++) {
-			struct omap_display *display = dss_get_display(i);
-			if (display->type != OMAP_DISPLAY_TYPE_VENC) {
-				lcd_mgr->set_display(lcd_mgr, display);
-
-				if (!def_mgr)
-					def_mgr = lcd_mgr;
-
-				break;
-			}
-		}
-	}
-
-	if (def_mgr != tv_mgr) {
-		/* connect tv manager to first VENC display found */
-		for (i = 0; i < omap_dss_get_num_displays(); i++) {
-			struct omap_display *display = dss_get_display(i);
-			if (display->type == OMAP_DISPLAY_TYPE_VENC) {
-				tv_mgr->set_display(tv_mgr, display);
-
-				if (!def_mgr)
-					def_mgr = tv_mgr;
-
-				break;
-			}
-		}
-	}
-
-	/* connect all dispc overlays to def_mgr */
-	if (def_mgr) {
-		for (i = 0; i < 3; i++) {
-			struct omap_overlay *ovl;
-			ovl = omap_dss_get_overlay(i);
-			omap_dss_set_manager(ovl, def_mgr);
-		}
-	}
-
 #ifdef L4_EXAMPLE
 	/* setup L4 overlay as an example */
 	{
@@ -574,6 +594,49 @@ void dss_init_overlays(struct platform_d
 #endif
 }
 
+/* connect overlays to the new device, if not already connected. if force
+ * selected, connect always. */
+void dss_recheck_connections(struct omap_display *display, bool force)
+{
+	int i;
+	struct omap_overlay_manager *lcd_mgr;
+	struct omap_overlay_manager *tv_mgr;
+	struct omap_overlay_manager *mgr = NULL;
+
+	lcd_mgr = omap_dss_get_overlay_manager(OMAP_DSS_OVL_MGR_LCD);
+	tv_mgr = omap_dss_get_overlay_manager(OMAP_DSS_OVL_MGR_TV);
+
+	if (display->type != OMAP_DISPLAY_TYPE_VENC) {
+		if (!lcd_mgr->display || force) {
+			if (lcd_mgr->display)
+				lcd_mgr->unset_display(lcd_mgr);
+			lcd_mgr->set_display(lcd_mgr, display);
+			mgr = lcd_mgr;
+		}
+	}
+
+	if (display->type == OMAP_DISPLAY_TYPE_VENC) {
+		if (!tv_mgr->display || force) {
+			if (tv_mgr->display)
+				tv_mgr->unset_display(tv_mgr);
+			tv_mgr->set_display(tv_mgr, display);
+			mgr = tv_mgr;
+		}
+	}
+
+	if (mgr) {
+		for (i = 0; i < 3; i++) {
+			struct omap_overlay *ovl;
+			ovl = omap_dss_get_overlay(i);
+			if (!ovl->manager || force) {
+				if (ovl->manager)
+					omap_dss_unset_manager(ovl);
+				omap_dss_set_manager(ovl, mgr);
+			}
+		}
+	}
+}
+
 void dss_uninit_overlays(struct platform_device *pdev)
 {
 	struct omap_overlay *ovl;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/rfbi.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/rfbi.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/rfbi.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/rfbi.c	2012-12-16 13:13:01.708330145 +0100
@@ -1290,7 +1290,7 @@ static void rfbi_display_disable(struct
 			DISPC_IRQ_FRAMEDONE);
 }
 
-void rfbi_init_display(struct omap_display *display)
+int rfbi_init_display(struct omap_display *display)
 {
 	display->enable = rfbi_display_enable;
 	display->disable = rfbi_display_disable;
@@ -1301,4 +1301,6 @@ void rfbi_init_display(struct omap_displ
 	rfbi.display[display->hw_config.u.rfbi.channel] = display;
 
 	display->caps = OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE;
+
+	return 0;
 }
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/sdi.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/sdi.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/sdi.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/sdi.c	2012-12-16 13:13:01.708330145 +0100
@@ -23,6 +23,8 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/err.h>
+#include <linux/io.h>
+#include <linux/i2c/twl4030.h>
 
 #include <mach/board.h>
 #include <mach/display.h>
@@ -30,12 +32,114 @@
 
 #include "dss.h"
 
+#define CONTROL_PADCONF_BASE	0x48002000
+
+#define OMAP_SDI_PAD_DIS(pe,pu)	((7 << 0)		| /* MODE 7 = safe */ \
+				 (((pe) ? 1 : 0) << 3)	| /* PULL_ENA */      \
+				 (((pu) ? 1 : 0) << 4)	| /* PULL_UP  */      \
+				 (1 << 8))		  /* INPUT_EN */
+
+#define OMAP_SDI_PAD_EN		 (1 << 0)		  /* MODE 1 = SDI_xx */
+
+#define OMAP_SDI_PAD_MASK	OMAP_SDI_PAD_DIS(1, 1)
 
 static struct {
 	bool skip_init;
 	bool update_enabled;
 } sdi;
 
+/* CONTROL_PADCONF_DSS_DATAXX */
+static const u16 sdi_pads[] =
+{
+	0x0f0,		/* 10[ 7..0]:SDI_DAT1N */
+	0x0f2,		/* 10[15..0]:SDI_DAT1P */
+	0x0f4,		/* 12[ 7..0]:SDI_DAT2N */
+	0x0f6,		/* 12[15..0]:SDI_DAT2P */
+	0x0f8,		/* 14[ 7..0]:SDI_DAT3N */
+	0x0fa,		/* 14[15..0]:SDI_DAT3P */
+	0x108,		/* 22[ 7..0]:SDI_CLKN */
+	0x10a,		/* 22[15..0]:SDI_CLKP */
+};
+
+/*
+ * Check if bootloader / platform code has configured the SDI pads properly.
+ * This means it either configured all required pads for SDI mode, or that it
+ * left all the required pads unconfigured.
+ */
+static int sdi_pad_init(struct omap_display *display)
+{
+	unsigned req_map;
+	bool configured = false;
+	bool unconfigured = false;
+	int data_pairs;
+	int i;
+
+	data_pairs = display->hw_config.u.sdi.datapairs;
+	req_map = (1 << (data_pairs * 2)) - 1;		/* data lanes */
+	req_map |= 3 << 6;				/* clk lane */
+	for (i = 0; i < ARRAY_SIZE(sdi_pads); i++) {
+		u32 reg;
+		u32 val;
+
+		if (!((1 << i) & req_map))
+			/* Ignore unneded pads. */
+			continue;
+		reg = CONTROL_PADCONF_BASE + sdi_pads[i];
+		val = omap_readw(reg);
+		switch (val & 0x07) {	/* pad mode */
+		case 1:
+			if (unconfigured)
+				break;
+			/* Is the pull configuration ok for SDI mode? */
+			if ((val & OMAP_SDI_PAD_MASK) != OMAP_SDI_PAD_EN)
+				break;
+			configured = true;
+			break;
+		case 0:
+		case 7:
+			if (configured)
+				break;
+			unconfigured = true;
+			break;
+		default:
+			break;
+		}
+	}
+	if (i != ARRAY_SIZE(sdi_pads)) {
+		DSSERR("SDI: invalid pad configuration\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static void sdi_pad_config(struct omap_display *display, bool enable)
+{
+	int data_pairs;
+	bool pad_off_pe, pad_off_pu;
+	unsigned req_map;
+	int i;
+
+	data_pairs = display->hw_config.u.sdi.datapairs;
+	pad_off_pe = display->hw_config.u.sdi.pad_off_pe;
+	pad_off_pu = display->hw_config.u.sdi.pad_off_pu;
+	req_map = (1 << (data_pairs * 2)) - 1;		/* data lanes */
+	req_map |= 3 << 6;				/* clk lane */
+	for (i = 0; i < ARRAY_SIZE(sdi_pads); i++) {
+		u32 reg;
+		u16 val;
+
+		if (!((1 << i) & req_map))
+			continue;
+		if (enable)
+			val = OMAP_SDI_PAD_EN;
+		else
+			val = OMAP_SDI_PAD_DIS(pad_off_pe, pad_off_pu);
+		reg = CONTROL_PADCONF_BASE + sdi_pads[i];
+		omap_writew(val, reg);
+	}
+}
+
 static void sdi_basic_init(void)
 {
 	dispc_set_parallel_interface_mode(OMAP_DSS_PARALLELMODE_BYPASS);
@@ -59,6 +163,10 @@ static int sdi_display_enable(struct oma
 		return -EINVAL;
 	}
 
+	twl4030_enable_regulator(RES_VAUX1);
+
+	sdi_pad_config(display, 1);
+
 	/* In case of skip_init sdi_init has already enabled the clocks */
 	if (!sdi.skip_init)
 		dss_clk_enable(DSS_CLK_ICK | DSS_CLK_FCK1);
@@ -102,7 +210,9 @@ static int sdi_display_enable(struct oma
 
 	if (!sdi.skip_init) {
 		dss_sdi_init(display->hw_config.u.sdi.datapairs);
-		dss_sdi_enable();
+		r = dss_sdi_enable();
+		if (r)
+			goto err1;
 		mdelay(2);
 	}
 
@@ -122,6 +232,8 @@ err2:
 err1:
 err0:
 	dss_clk_disable(DSS_CLK_ICK | DSS_CLK_FCK1);
+	twl4030_disable_regulator(RES_VAUX1);
+
 	return r;
 }
 
@@ -132,8 +244,10 @@ static void sdi_display_disable(struct o
 	if (display->state == OMAP_DSS_DISPLAY_DISABLED)
 		return;
 
-	if (display->state == OMAP_DSS_DISPLAY_SUSPENDED)
-		sdi_display_resume(display);
+	if (display->state == OMAP_DSS_DISPLAY_SUSPENDED) {
+		if (sdi_display_resume(display))
+			return;
+	}
 
 	display->panel->disable(display);
 
@@ -142,6 +256,9 @@ static void sdi_display_disable(struct o
 	dss_sdi_disable();
 
 	dss_clk_disable(DSS_CLK_ICK | DSS_CLK_FCK1);
+	sdi_pad_config(display, 0);
+
+	twl4030_disable_regulator(RES_VAUX1);
 
 	display->state = OMAP_DSS_DISPLAY_DISABLED;
 }
@@ -159,6 +276,9 @@ static int sdi_display_suspend(struct om
 	dss_sdi_disable();
 
 	dss_clk_disable(DSS_CLK_ICK | DSS_CLK_FCK1);
+	sdi_pad_config(display, 0);
+
+	twl4030_disable_regulator(RES_VAUX1);
 
 	display->state = OMAP_DSS_DISPLAY_SUSPENDED;
 
@@ -167,12 +287,19 @@ static int sdi_display_suspend(struct om
 
 static int sdi_display_resume(struct omap_display *display)
 {
+	int r;
+
 	if (display->state != OMAP_DSS_DISPLAY_SUSPENDED)
 		return -EINVAL;
 
+	twl4030_enable_regulator(RES_VAUX1);
+
+	sdi_pad_config(display, 1);
 	dss_clk_enable(DSS_CLK_ICK | DSS_CLK_FCK1);
 
-	dss_sdi_enable();
+	r = dss_sdi_enable();
+	if (r)
+		goto err;
 	mdelay(2);
 
 	dispc_enable_lcd_out(1);
@@ -183,6 +310,14 @@ static int sdi_display_resume(struct oma
 	display->state = OMAP_DSS_DISPLAY_ACTIVE;
 
 	return 0;
+
+ err:
+	dss_clk_disable(DSS_CLK_ICK | DSS_CLK_FCK1);
+	sdi_pad_config(display, 0);
+
+	twl4030_disable_regulator(RES_VAUX1);
+
+	return r;
 }
 
 static int sdi_display_set_update_mode(struct omap_display *display,
@@ -215,7 +350,7 @@ static void sdi_get_timings(struct omap_
 	*timings = display->panel->timings;
 }
 
-void sdi_init_display(struct omap_display *display)
+int sdi_init_display(struct omap_display *display)
 {
 	DSSDBG("SDI init\n");
 
@@ -226,6 +361,8 @@ void sdi_init_display(struct omap_displa
 	display->set_update_mode = sdi_display_set_update_mode;
 	display->get_update_mode = sdi_display_get_update_mode;
 	display->get_timings = sdi_get_timings;
+
+	return sdi_pad_init(display);
 }
 
 int sdi_init(bool skip_init)
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/venc.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/venc.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/dss/venc.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/dss/venc.c	2012-12-16 13:13:01.708330145 +0100
@@ -31,6 +31,8 @@
 #include <linux/delay.h>
 #include <linux/string.h>
 #include <linux/seq_file.h>
+#include <linux/regulator/consumer.h>
+#include <linux/platform_device.h>
 
 #include <mach/display.h>
 #include <mach/cpu.h>
@@ -263,32 +265,34 @@ static const struct venc_config venc_con
 const struct omap_video_timings omap_dss_pal_timings = {
 	.x_res = 720,
 	.y_res = 574,
-	.pixel_clock = 26181,
-	.hsw = 32,
-	.hfp = 80,
-	.hbp = 48,
-	.vsw = 7,
-	.vfp = 3,
-	.vbp = 6,
+	.pixel_clock = 13500,
+	.hsw = 64,
+	.hfp = 12,
+	.hbp = 68,
+	.vsw = 5,
+	.vfp = 5,
+	.vbp = 41,
 };
 EXPORT_SYMBOL(omap_dss_pal_timings);
 
 const struct omap_video_timings omap_dss_ntsc_timings = {
 	.x_res = 720,
 	.y_res = 482,
-	.pixel_clock = 22153,
-	.hsw = 32,
-	.hfp = 80,
-	.hbp = 48,
-	.vsw = 10,
-	.vfp = 3,
-	.vbp = 6,
+	.pixel_clock = 13500,
+	.hsw = 64,
+	.hfp = 16,
+	.hbp = 58,
+	.vsw = 6,
+	.vfp = 6,
+	.vbp = 31,
 };
 EXPORT_SYMBOL(omap_dss_ntsc_timings);
 
 static struct {
 	void __iomem *base;
 	struct mutex venc_lock;
+	struct regulator *vdac_reg;
+	u32 wss_data;
 } venc;
 
 static struct omap_panel venc_panel = {
@@ -320,7 +324,7 @@ static void venc_write_config(const stru
 	venc_write_reg(VENC_BLACK_LEVEL, config->black_level);
 	venc_write_reg(VENC_BLANK_LEVEL, config->blank_level);
 	venc_write_reg(VENC_M_CONTROL, config->m_control);
-	venc_write_reg(VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data);
+	venc_write_reg(VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data | venc.wss_data);
 	venc_write_reg(VENC_S_CARR, config->s_carr);
 	venc_write_reg(VENC_L21__WC_CTL, config->l21__wc_ctl);
 	venc_write_reg(VENC_SAVID__EAVID, config->savid__eavid);
@@ -399,12 +403,14 @@ static const struct venc_config *venc_ti
 	BUG();
 }
 
-int venc_init(void)
+int venc_init(struct platform_device *pdev)
 {
 	u8 rev_id;
 
 	mutex_init(&venc.venc_lock);
 
+	venc.wss_data = 0;
+
 	venc_panel.timings = omap_dss_pal_timings;
 
 	venc.base = ioremap(VENC_BASE, SZ_1K);
@@ -413,6 +419,14 @@ int venc_init(void)
 		return -ENOMEM;
 	}
 
+	venc.vdac_reg = regulator_get(&pdev->dev, "vdac");
+
+	if (IS_ERR(venc.vdac_reg)) {
+		DSSERR("Can't get vdac regulator as source\n");
+		venc.vdac_reg = NULL;
+		return -ENODEV;
+	}
+
 	venc_enable_clocks(1);
 
 	rev_id = (u8)(venc_read_reg(VENC_REV_ID) & 0xff);
@@ -425,11 +439,16 @@ int venc_init(void)
 
 void venc_exit(void)
 {
+	regulator_put(venc.vdac_reg);
 	iounmap(venc.base);
 }
 
 static void venc_power_on(struct omap_display *display)
 {
+	regulator_enable(venc.vdac_reg);
+
+	dispc_enable_digit_errors(0);
+
 	venc_enable_clocks(1);
 
 	venc_reset();
@@ -454,6 +473,8 @@ static void venc_power_on(struct omap_di
 		display->hw_config.panel_enable(display);
 
 	dispc_enable_digit_out(1);
+
+	dispc_enable_digit_errors(1);
 }
 
 static void venc_power_off(struct omap_display *display)
@@ -467,6 +488,8 @@ static void venc_power_off(struct omap_d
 		display->hw_config.panel_disable(display);
 
 	venc_enable_clocks(0);
+
+	regulator_disable(venc.vdac_reg);
 }
 
 static int venc_enable_display(struct omap_display *display)
@@ -567,6 +590,11 @@ static void venc_set_timings(struct omap
 			struct omap_video_timings *timings)
 {
 	DSSDBG("venc_set_timings\n");
+
+	/* Reset WSS data when the TV standard changes. */
+	if (memcmp(&display->panel->timings, timings, sizeof(*timings)))
+		venc.wss_data = 0;
+
 	display->panel->timings = *timings;
 	if (display->state == OMAP_DSS_DISPLAY_ACTIVE) {
 		/* turn the venc off and on to get new timings to use */
@@ -589,7 +617,38 @@ static int venc_check_timings(struct oma
 	return -EINVAL;
 }
 
-void venc_init_display(struct omap_display *display)
+static u32 venc_get_wss(struct omap_display *display)
+{
+	/* Invert due to VENC_L21_WC_CTL:INV=1 */
+	return (venc.wss_data >> 8) ^ 0xfffff;
+}
+
+static int venc_set_wss(struct omap_display *display,
+			u32 wss)
+{
+	const struct venc_config *config;
+
+	DSSDBG("venc_set_wss\n");
+
+	mutex_lock(&venc.venc_lock);
+
+	config = venc_timings_to_config(&display->panel->timings);
+
+	/* Invert due to VENC_L21_WC_CTL:INV=1 */
+	venc.wss_data = (wss ^ 0xfffff) << 8;
+
+	venc_enable_clocks(1);
+
+	venc_write_reg(VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data | venc.wss_data);
+
+	venc_enable_clocks(0);
+
+	mutex_unlock(&venc.venc_lock);
+
+	return 0;
+}
+
+int venc_init_display(struct omap_display *display)
 {
 	display->panel = &venc_panel;
 	display->enable = venc_enable_display;
@@ -599,6 +658,10 @@ void venc_init_display(struct omap_displ
 	display->get_timings = venc_get_timings;
 	display->set_timings = venc_set_timings;
 	display->check_timings = venc_check_timings;
+	display->get_wss = venc_get_wss;
+	display->set_wss = venc_set_wss;
+
+	return 0;
 }
 
 void venc_dump_regs(struct seq_file *s)
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/omapfb/omapfb.h kernel-2.6.28-20093908+0m5/drivers/video/omap2/omapfb/omapfb.h
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/omapfb/omapfb.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/omapfb/omapfb.h	2012-12-16 13:13:01.708330145 +0100
@@ -53,11 +53,6 @@ struct omapfb2_mem_region {
 	bool		map;		/* kernel mapped by the driver */
 };
 
-enum omapfb_rotation_type {
-	OMAPFB_ROT_DMA = 0,
-	OMAPFB_ROT_VRFB = 1,
-};
-
 /* appended to fb_info */
 struct omapfb_info {
 	int id;
@@ -66,8 +61,8 @@ struct omapfb_info {
 	int num_overlays;
 	struct omap_overlay *overlays[OMAPFB_MAX_OVL_PER_FB];
 	struct omapfb2_device *fbdev;
-	enum omapfb_rotation_type rotation_type;
-	u8 rotation;
+	enum omap_dss_rotation_type rotation_type;
+	u8 rotation[OMAPFB_MAX_OVL_PER_FB];
 	bool mirror;
 };
 
@@ -100,9 +95,6 @@ struct omapfb_colormode {
 	struct fb_bitfield transp;
 };
 
-u32 omapfb_get_region_paddr(struct omapfb_info *ofbi);
-void __iomem *omapfb_get_region_vaddr(struct omapfb_info *ofbi);
-
 void set_fb_fix(struct fb_info *fbi);
 int check_fb_var(struct fb_info *fbi, struct fb_var_screeninfo *var);
 int omapfb_realloc_fbmem(struct fb_info *fbi, unsigned long size, int type);
@@ -116,6 +108,8 @@ int omapfb_ioctl(struct fb_info *fbi, un
 
 int omapfb_mode_to_timings(const char *mode_str,
 		struct omap_video_timings *timings, u8 *bpp);
+int dss_mode_to_fb_mode(enum omap_color_mode dssmode,
+			struct fb_var_screeninfo *var);
 
 /* find the display connected to this fb, if any */
 static inline struct omap_display *fb2display(struct fb_info *fbi)
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/omapfb/omapfb-ioctl.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/omapfb/omapfb-ioctl.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/omapfb/omapfb-ioctl.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/omapfb/omapfb-ioctl.c	2012-12-16 13:13:01.708330145 +0100
@@ -30,6 +30,7 @@
 
 #include <mach/display.h>
 #include <mach/vrfb.h>
+#include <mach/vram.h>
 
 #include "omapfb.h"
 
@@ -71,14 +72,16 @@ static int omapfb_setup_plane(struct fb_
 	info.out_height = pi->out_height;
 	info.enabled = pi->enabled;
 
+	omap_dss_lock();
+
 	r = ovl->set_overlay_info(ovl, &info);
 	if (r)
-		goto out;
+		goto unlock;
 
 	if (ovl->manager) {
 		r = ovl->manager->apply(ovl->manager);
 		if (r)
-			goto out;
+			goto unlock;
 	}
 
 	if (display) {
@@ -93,6 +96,8 @@ static int omapfb_setup_plane(struct fb_
 			display->update(display, 0, 0, w, h);
 	}
 
+unlock:
+	omap_dss_unlock();
 out:
 	omapfb_unlock(fbdev);
 	if (r)
@@ -206,7 +211,9 @@ static int omapfb_update_window(struct f
 		return -EINVAL;
 
 	omapfb_lock(fbdev);
+	omap_dss_lock();
 	display->update(display, x, y, w, h);
+	omap_dss_unlock();
 	omapfb_unlock(fbdev);
 
 	return 0;
@@ -242,7 +249,9 @@ static int omapfb_set_update_mode(struct
 	}
 
 	omapfb_lock(fbdev);
+	omap_dss_lock();
 	r = display->set_update_mode(display, um);
+	omap_dss_unlock();
 	omapfb_unlock(fbdev);
 
 	return r;
@@ -288,7 +297,8 @@ static int _omapfb_set_color_key(struct
 {
 	enum omap_dss_color_key_type kt;
 
-	if(!mgr->set_default_color || !mgr->set_trans_key ||
+	if (!mgr->set_default_color ||
+			!mgr->set_trans_key_type_and_value ||
 			!mgr->enable_trans_key)
 		return 0;
 
@@ -309,9 +319,11 @@ static int _omapfb_set_color_key(struct
 		return -EINVAL;
 	}
 
+	omap_dss_lock();
 	mgr->set_default_color(mgr, ck->background);
-	mgr->set_trans_key(mgr, kt, ck->trans_key);
+	mgr->set_trans_key_type_and_value(mgr, kt, ck->trans_key);
 	mgr->enable_trans_key(mgr, 1);
+	omap_dss_unlock();
 
 	omapfb_color_keys[mgr->id] = *ck;
 
@@ -341,7 +353,8 @@ static int omapfb_set_color_key(struct f
 		goto err;
 	}
 
-	if(!mgr->set_default_color || !mgr->set_trans_key ||
+	if (!mgr->set_default_color ||
+			!mgr->set_trans_key_type_and_value ||
 			!mgr->enable_trans_key) {
 		r = -ENODEV;
 		goto err;
@@ -377,7 +390,8 @@ static int omapfb_get_color_key(struct f
 		goto err;
 	}
 
-	if(!mgr->set_default_color || !mgr->set_trans_key ||
+	if (!mgr->set_default_color ||
+			!mgr->set_trans_key_type_and_value ||
 			!mgr->enable_trans_key) {
 		r = -ENODEV;
 		goto err;
@@ -416,9 +430,11 @@ static int omapfb_memory_read(struct fb_
 
 	omapfb_lock(fbdev);
 
+	omap_dss_lock();
 	r = display->memory_read(display, buf, mr->buffer_size,
 			mr->x, mr->y, mr->w, mr->h);
 
+	omap_dss_unlock();
 	if (r > 0) {
 		if (copy_to_user(mr->buffer, buf, mr->buffer_size))
 			r = -EFAULT;
@@ -431,6 +447,52 @@ static int omapfb_memory_read(struct fb_
 	return r;
 }
 
+int omapfb_get_ovl_colormode(struct omapfb2_device *fbdev,
+			     struct omapfb_ovl_colormode *mode)
+{
+	int ovl_idx = mode->overlay_idx;
+	int mode_idx = mode->mode_idx;
+	struct omap_overlay *ovl;
+	enum omap_color_mode supported_modes;
+	struct fb_var_screeninfo var;
+	int i;
+
+	if (ovl_idx >= fbdev->num_overlays)
+		return -ENODEV;
+	ovl = fbdev->overlays[ovl_idx];
+	supported_modes = ovl->supported_modes;
+
+	mode_idx = mode->mode_idx;
+
+	for (i = 0; i < sizeof(supported_modes) * 8; i++) {
+		if (!(supported_modes & (1 << i)))
+			continue;
+		/*
+		 * It's possible that the FB doesn't support a mode
+		 * that is supported by the overlay, so call the
+		 * following here.
+		 */
+		if (dss_mode_to_fb_mode(1 << i, &var) < 0)
+			continue;
+
+		mode_idx--;
+		if (mode_idx < 0)
+			break;
+	}
+
+	if (i == sizeof(supported_modes) * 8)
+		return -ENOENT;
+
+	mode->bits_per_pixel = var.bits_per_pixel;
+	mode->nonstd = var.nonstd;
+	mode->red = var.red;
+	mode->green = var.green;
+	mode->blue = var.blue;
+	mode->transp = var.transp;
+
+	return 0;
+}
+
 int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 {
 	struct omapfb_info *ofbi = FB2OFB(fbi);
@@ -444,9 +506,11 @@ int omapfb_ioctl(struct fb_info *fbi, un
 		struct omapfb_caps		caps;
 		struct omapfb_mem_info          mem_info;
 		struct omapfb_color_key		color_key;
+		struct omapfb_ovl_colormode	ovl_colormode;
 		enum omapfb_update_mode		update_mode;
 		int test_num;
 		struct omapfb_memory_read	memory_read;
+		struct omapfb_vram_info		vram_info;
 	} p;
 
 	int r = 0;
@@ -461,7 +525,9 @@ int omapfb_ioctl(struct fb_info *fbi, un
 		}
 
 		omapfb_lock(fbdev);
+		omap_dss_lock();
 		r = display->sync(display);
+		omap_dss_unlock();
 		omapfb_unlock(fbdev);
 		break;
 
@@ -545,12 +611,28 @@ int omapfb_ioctl(struct fb_info *fbi, un
 			break;
 		}
 
+		memset(&p.caps, 0, sizeof(p.caps));
 		p.caps.ctrl = display->caps;
 
 		if (copy_to_user((void __user *)arg, &p.caps, sizeof(p.caps)))
 			r = -EFAULT;
 		break;
 
+	case OMAPFB_GET_OVERLAY_COLORMODE:
+		DBG("ioctl GET_OVERLAY_COLORMODE\n");
+		if (copy_from_user(&p.ovl_colormode, (void __user *)arg,
+				   sizeof(p.ovl_colormode))) {
+			r = -EFAULT;
+			break;
+		}
+		r = omapfb_get_ovl_colormode(fbdev, &p.ovl_colormode);
+		if (r < 0)
+			break;
+		if (copy_to_user((void __user *)arg, &p.ovl_colormode,
+				 sizeof(p.ovl_colormode)))
+			r = -EFAULT;
+		break;
+
 	case OMAPFB_SET_UPDATE_MODE:
 		DBG("ioctl SET_UPDATE_MODE\n");
 		if (get_user(p.update_mode, (int __user *)arg))
@@ -594,7 +676,9 @@ int omapfb_ioctl(struct fb_info *fbi, un
 			break;
 		}
 
+		omap_dss_lock();
 		r = display->wait_vsync(display);
+		omap_dss_unlock();
 		break;
 
 	/* LCD and CTRL tests do the same thing for backward
@@ -610,7 +694,9 @@ int omapfb_ioctl(struct fb_info *fbi, un
 			break;
 		}
 
+		omap_dss_lock();
 		r = display->run_test(display, p.test_num);
+		omap_dss_unlock();
 
 		break;
 
@@ -625,7 +711,9 @@ int omapfb_ioctl(struct fb_info *fbi, un
 			break;
 		}
 
+		omap_dss_lock();
 		r = display->run_test(display, p.test_num);
+		omap_dss_unlock();
 
 		break;
 
@@ -642,6 +730,22 @@ int omapfb_ioctl(struct fb_info *fbi, un
 
 		break;
 
+	case OMAPFB_GET_VRAM_INFO: {
+		unsigned long vram, free, largest;
+
+		DBG("ioctl GET_VRAM_INFO\n");
+
+		omap_vram_get_info(&vram, &free, &largest);
+		p.vram_info.total = vram;
+		p.vram_info.free = free;
+		p.vram_info.largest_free_block = largest;
+
+		if (copy_to_user((void __user *)arg, &p.vram_info,
+					sizeof(p.vram_info)))
+			r = -EFAULT;
+		break;
+	}
+
 	default:
 		dev_err(fbdev->dev, "Unknown ioctl 0x%x\n", cmd);
 		r = -EINVAL;
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/omapfb/omapfb-main.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/omapfb/omapfb-main.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/omapfb/omapfb-main.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/omapfb/omapfb-main.c	2012-12-16 13:13:01.708330145 +0100
@@ -147,23 +147,34 @@ static void fill_fb(struct fb_info *fbi)
 }
 #endif
 
-static unsigned omapfb_get_vrfb_offset(struct omapfb_info *ofbi, int rot)
+static unsigned omapfb_get_vrfb_offset(const struct omapfb_info *ofbi, int rot,
+		const struct fb_var_screeninfo *var)
 {
-	struct vrfb *vrfb = &ofbi->region.vrfb;
+	const struct vrfb *vrfb = &ofbi->region.vrfb;
 	unsigned offset;
+	unsigned int yoffset = var->yres_virtual - var->yres + vrfb->yoffset;
+	unsigned int xoffset = var->xres_virtual - var->xres + vrfb->xoffset;
 
 	switch (rot) {
 	case FB_ROTATE_UR:
 		offset = 0;
+		offset += var->yoffset * OMAP_VRFB_LINE_LEN;
+		offset += var->xoffset;
 		break;
 	case FB_ROTATE_CW:
-		offset = vrfb->yoffset;
+		offset = yoffset;
+		offset += var->xoffset * OMAP_VRFB_LINE_LEN;
+		offset -= var->yoffset;
 		break;
 	case FB_ROTATE_UD:
-		offset = vrfb->yoffset * OMAP_VRFB_LINE_LEN + vrfb->xoffset;
+		offset = yoffset * OMAP_VRFB_LINE_LEN + xoffset;
+		offset -= var->xoffset;
+		offset -= var->yoffset * OMAP_VRFB_LINE_LEN;
 		break;
 	case FB_ROTATE_CCW:
-		offset = vrfb->xoffset * OMAP_VRFB_LINE_LEN;
+		offset = xoffset * OMAP_VRFB_LINE_LEN;
+		offset -= var->xoffset * OMAP_VRFB_LINE_LEN;
+		offset += var->yoffset;
 		break;
 	default:
 		BUG();
@@ -174,33 +185,28 @@ static unsigned omapfb_get_vrfb_offset(s
 	return offset;
 }
 
-static u32 omapfb_get_region_rot_paddr(struct omapfb_info *ofbi)
+static u32 omapfb_get_region_rot_paddr(struct omapfb_info *ofbi, int rot,
+		const struct fb_var_screeninfo *var)
 {
-	if (ofbi->rotation_type == OMAPFB_ROT_VRFB) {
-		unsigned offset;
-		int rot;
-
-		rot = ofbi->rotation;
-
-		offset = omapfb_get_vrfb_offset(ofbi, rot);
-
-		return ofbi->region.vrfb.paddr[rot] + offset;
+	if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {
+		return ofbi->region.vrfb.paddr[rot]
+			+ omapfb_get_vrfb_offset(ofbi, rot, var);
 	} else {
 		return ofbi->region.paddr;
 	}
 }
 
-u32 omapfb_get_region_paddr(struct omapfb_info *ofbi)
+static u32 omapfb_get_region_paddr(struct omapfb_info *ofbi)
 {
-	if (ofbi->rotation_type == OMAPFB_ROT_VRFB)
+	if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)
 		return ofbi->region.vrfb.paddr[0];
 	else
 		return ofbi->region.paddr;
 }
 
-void __iomem *omapfb_get_region_vaddr(struct omapfb_info *ofbi)
+static void __iomem *omapfb_get_region_vaddr(struct omapfb_info *ofbi)
 {
-	if (ofbi->rotation_type == OMAPFB_ROT_VRFB)
+	if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)
 		return ofbi->region.vrfb.vaddr[0];
 	else
 		return ofbi->region.vaddr;
@@ -301,7 +307,7 @@ static void assign_colormode_to_var(stru
 	var->transp = color->transp;
 }
 
-static enum omap_color_mode fb_mode_to_dss_mode(struct fb_var_screeninfo *var)
+static int fb_mode_to_dss_mode(struct fb_var_screeninfo *var)
 {
 	enum omap_color_mode dssmode;
 	int i;
@@ -328,6 +334,11 @@ static enum omap_color_mode fb_mode_to_d
 		}
 	}
 
+	/* fail if the colors were specified but the didn't match */
+	if (var->red.length != 0 || var->blue.length != 0 ||
+			var->green.length != 0 || var->transp.length != 0)
+		return -EINVAL;
+
 	/* match with bpp if user has not filled color fields
 	 * properly */
 	switch (var->bits_per_pixel) {
@@ -370,8 +381,175 @@ static enum omap_color_mode fb_mode_to_d
 	return -EINVAL;
 }
 
-static int dss_mode_to_fb_mode(enum omap_color_mode dssmode,
-			       struct fb_var_screeninfo *var)
+static int check_fb_res_bounds(struct fb_var_screeninfo *var)
+{
+	int xres_min = OMAPFB_PLANE_XRES_MIN;
+	int xres_max = 2048;
+	int yres_min = OMAPFB_PLANE_YRES_MIN;
+	int yres_max = 2048;
+
+	/* XXX: some applications seem to set virtual res to 0. */
+	if (var->xres_virtual == 0)
+		var->xres_virtual = var->xres;
+
+	if (var->yres_virtual == 0)
+		var->yres_virtual = var->yres;
+
+	if (var->xres_virtual < xres_min || var->yres_virtual < yres_min)
+		return -EINVAL;
+
+	if (var->xres < xres_min)
+		var->xres = xres_min;
+	if (var->yres < yres_min)
+		var->yres = yres_min;
+	if (var->xres > xres_max)
+		var->xres = xres_max;
+	if (var->yres > yres_max)
+		var->yres = yres_max;
+
+	if (var->xres > var->xres_virtual)
+		var->xres = var->xres_virtual;
+	if (var->yres > var->yres_virtual)
+		var->yres = var->yres_virtual;
+
+	return 0;
+}
+
+static void shrink_height(unsigned long max_frame_size,
+		struct fb_var_screeninfo *var)
+{
+	DBG("can't fit FB into memory, reducing y\n");
+	var->yres_virtual = max_frame_size /
+		(var->xres_virtual * var->bits_per_pixel >> 3);
+
+	if (var->yres_virtual < OMAPFB_PLANE_YRES_MIN)
+		var->yres_virtual = OMAPFB_PLANE_YRES_MIN;
+
+	if (var->yres > var->yres_virtual)
+		var->yres = var->yres_virtual;
+}
+
+static void shrink_width(unsigned long max_frame_size,
+		struct fb_var_screeninfo *var)
+{
+	DBG("can't fit FB into memory, reducing x\n");
+	var->xres_virtual = max_frame_size / var->yres_virtual /
+		(var->bits_per_pixel >> 3);
+
+	if (var->xres_virtual < OMAPFB_PLANE_XRES_MIN)
+		var->xres_virtual = OMAPFB_PLANE_XRES_MIN;
+
+	if (var->xres > var->xres_virtual)
+		var->xres = var->xres_virtual;
+}
+
+static int check_vrfb_fb_size(unsigned long region_size,
+		const struct fb_var_screeninfo *var)
+{
+	unsigned long min_phys_size = omap_vrfb_min_phys_size(var->xres_virtual,
+		var->yres_virtual, var->bits_per_pixel >> 3);
+
+	return min_phys_size > region_size ? -EINVAL : 0;
+}
+
+static int check_fb_size(const struct omapfb_info *ofbi,
+		struct fb_var_screeninfo *var)
+{
+	unsigned long max_frame_size = ofbi->region.size;
+	int bytespp = var->bits_per_pixel >> 3;
+	unsigned long line_size = var->xres_virtual * bytespp;
+
+	if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {
+		/* One needs to check for both VRFB and OMAPFB limitations. */
+		if (check_vrfb_fb_size(max_frame_size, var))
+			shrink_height(omap_vrfb_max_height(
+				max_frame_size, var->xres_virtual, bytespp) *
+				line_size, var);
+
+		if (check_vrfb_fb_size(max_frame_size, var)) {
+			DBG("cannot fit FB to memory\n");
+			return -EINVAL;
+		}
+
+		return 0;
+	}
+
+	DBG("max frame size %lu, line size %lu\n", max_frame_size, line_size);
+
+	if (line_size * var->yres_virtual > max_frame_size)
+		shrink_height(max_frame_size, var);
+
+	if (line_size * var->yres_virtual > max_frame_size) {
+		shrink_width(max_frame_size, var);
+		line_size = var->xres_virtual * bytespp;
+	}
+
+	if (line_size * var->yres_virtual > max_frame_size) {
+		DBG("cannot fit FB to memory\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * Consider if VRFB assisted rotation is in use and if the virtual space for
+ * the zero degree view needs to be mapped. The need for mapping also acts as
+ * the trigger for setting up the hardware on the context in question. This
+ * ensures that one does not attempt to access the virtual view before the
+ * hardware is serving the address translations.
+ */
+static int check_rotation(struct fb_info *fbi)
+{
+	struct omapfb_info *ofbi = FB2OFB(fbi);
+	struct omapfb2_mem_region *rg = &ofbi->region;
+
+	if (rg->size && ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {
+		struct fb_var_screeninfo *var = &fbi->var;
+		struct fb_fix_screeninfo *fix = &fbi->fix;
+		struct vrfb *vrfb = &rg->vrfb;
+
+		/*
+		 * In case of resolution change, one needs to reset the HW
+		 * invalidating the 0 angle view and any existing mapping.
+		 */
+		if ((vrfb->xres != var->xres_virtual ||
+		     vrfb->yres != var->yres_virtual ||
+		     vrfb->bytespp != var->bits_per_pixel >> 3) && vrfb->vaddr[0]) {
+			fbi->screen_base = NULL;
+			fix->smem_start = 0;
+			fix->smem_len = 0;
+			iounmap(vrfb->vaddr[0]);
+			vrfb->vaddr[0] = NULL;
+		}
+
+		if (!vrfb->vaddr[0]) {
+			int r;
+
+			omap_vrfb_setup(&rg->vrfb, rg->paddr,
+					var->xres_virtual,
+					var->yres_virtual,
+					fb_mode_to_dss_mode(var));
+
+			/* Now one can ioremap the 0 angle view */
+			r = omap_vrfb_map_angle(vrfb, var->yres_virtual, 0);
+			if (r)
+				return r;
+
+			/* used by open/write in fbmem.c */
+			fbi->screen_base = ofbi->region.vrfb.vaddr[0];
+
+			fix->smem_start = ofbi->region.vrfb.paddr[0];
+			fix->smem_len = var->yres_virtual * OMAP_VRFB_LINE_LEN *
+				var->bits_per_pixel >> 3;
+		}
+	}
+
+	return 0;
+}
+
+int dss_mode_to_fb_mode(enum omap_color_mode dssmode,
+			struct fb_var_screeninfo *var)
 {
 	int i;
 
@@ -390,22 +568,33 @@ void set_fb_fix(struct fb_info *fbi)
 	struct fb_fix_screeninfo *fix = &fbi->fix;
 	struct fb_var_screeninfo *var = &fbi->var;
 	struct omapfb_info *ofbi = FB2OFB(fbi);
-	struct omapfb2_mem_region *rg = &ofbi->region;
 
 	DBG("set_fb_fix\n");
-
-	/* used by open/write in fbmem.c */
-	fbi->screen_base = (char __iomem *)omapfb_get_region_vaddr(ofbi);
+	DBG("changing rotation to %d\n", var->rotate);
 
 	/* used by mmap in fbmem.c */
-	if (ofbi->rotation_type == OMAPFB_ROT_VRFB)
-		fix->line_length =
-			(OMAP_VRFB_LINE_LEN * var->bits_per_pixel) >> 3;
-	else
+	if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {
+		switch (var->nonstd) {
+		case OMAPFB_COLOR_YUV422:
+		case OMAPFB_COLOR_YUY422:
+			fix->line_length =
+				(OMAP_VRFB_LINE_LEN * var->bits_per_pixel) >> 2;
+			break;
+		default:
+			fix->line_length =
+				(OMAP_VRFB_LINE_LEN * var->bits_per_pixel) >> 3;
+			break;
+		}
+	} else {
+		/* used by open/write in fbmem.c */
+		fbi->screen_base =
+			(char __iomem *)omapfb_get_region_vaddr(ofbi);
+
 		fix->line_length =
 			(var->xres_virtual * var->bits_per_pixel) >> 3;
-	fix->smem_start = omapfb_get_region_paddr(ofbi);
-	fix->smem_len = rg->size;
+		fix->smem_start = ofbi->region.paddr;
+		fix->smem_len = ofbi->region.size;
+	}
 
 	fix->type = FB_TYPE_PACKED_PIXELS;
 
@@ -433,13 +622,6 @@ void set_fb_fix(struct fb_info *fbi)
 
 	fix->xpanstep = 1;
 	fix->ypanstep = 1;
-
-	if (rg->size) {
-		if (ofbi->rotation_type == OMAPFB_ROT_VRFB)
-			omap_vrfb_setup(&rg->vrfb, rg->paddr,
-					var->xres_virtual, var->yres_virtual,
-					var->bits_per_pixel >> 3);
-	}
 }
 
 /* check new var and possibly modify it to be ok */
@@ -447,13 +629,8 @@ int check_fb_var(struct fb_info *fbi, st
 {
 	struct omapfb_info *ofbi = FB2OFB(fbi);
 	struct omap_display *display = fb2display(fbi);
-	unsigned long max_frame_size;
-	unsigned long line_size;
-	int xres_min, yres_min;
-	int xres_max, yres_max;
 	enum omap_color_mode mode = 0;
 	int i;
-	int bytespp;
 
 	DBG("check_fb_var %d\n", ofbi->id);
 
@@ -476,98 +653,11 @@ int check_fb_var(struct fb_info *fbi, st
 	if (var->rotate < 0 || var->rotate > 3)
 		return -EINVAL;
 
-	if (var->rotate != fbi->var.rotate) {
-		DBG("rotation changing\n");
-
-		ofbi->rotation = var->rotate;
-
-		if (abs(var->rotate - fbi->var.rotate) != 2) {
-			int tmp;
-			DBG("rotate changing 90/270 degrees. "
-					"swapping x/y res\n");
-
-			tmp = var->yres;
-			var->yres = var->xres;
-			var->xres = tmp;
-
-			tmp = var->yres_virtual;
-			var->yres_virtual = var->xres_virtual;
-			var->xres_virtual = tmp;
-		}
-	}
-
-	xres_min = OMAPFB_PLANE_XRES_MIN;
-	xres_max = 2048;
-	yres_min = OMAPFB_PLANE_YRES_MIN;
-	yres_max = 2048;
-
-	bytespp = var->bits_per_pixel >> 3;
-
-	/* XXX: some applications seem to set virtual res to 0. */
-	if (var->xres_virtual == 0)
-		var->xres_virtual = var->xres;
-
-	if (var->yres_virtual == 0)
-		var->yres_virtual = var->yres;
-
-	if (var->xres_virtual < xres_min || var->yres_virtual < yres_min)
+	if (check_fb_res_bounds(var))
 		return -EINVAL;
 
-	if (var->xres < xres_min)
-		var->xres = xres_min;
-	if (var->yres < yres_min)
-		var->yres = yres_min;
-	if (var->xres > xres_max)
-		var->xres = xres_max;
-	if (var->yres > yres_max)
-		var->yres = yres_max;
-
-	if (var->xres > var->xres_virtual)
-		var->xres = var->xres_virtual;
-	if (var->yres > var->yres_virtual)
-		var->yres = var->yres_virtual;
-
-	if (ofbi->rotation_type == OMAPFB_ROT_VRFB)
-		line_size = OMAP_VRFB_LINE_LEN * bytespp;
-	else
-		line_size = var->xres_virtual * bytespp;
-
-	max_frame_size = ofbi->region.size;
-
-	DBG("max frame size %lu, line size %lu\n", max_frame_size, line_size);
-
-	if (line_size * var->yres_virtual > max_frame_size) {
-		DBG("can't fit FB into memory, reducing y\n");
-		var->yres_virtual = max_frame_size / line_size;
-
-		if (var->yres_virtual < yres_min)
-			var->yres_virtual = yres_min;
-
-		if (var->yres > var->yres_virtual)
-			var->yres = var->yres_virtual;
-	}
-
-	if (line_size * var->yres_virtual > max_frame_size) {
-		DBG("can't fit FB into memory, reducing x\n");
-		if (ofbi->rotation_type == OMAPFB_ROT_VRFB)
-			return -EINVAL;
-
-		var->xres_virtual = max_frame_size / var->yres_virtual /
-			bytespp;
-
-		if (var->xres_virtual < xres_min)
-			var->xres_virtual = xres_min;
-
-		if (var->xres > var->xres_virtual)
-			var->xres = var->xres_virtual;
-
-		line_size = var->xres_virtual * bytespp;
-	}
-
-	if (line_size * var->yres_virtual > max_frame_size) {
-		DBG("cannot fit FB to memory\n");
+	if (check_fb_size(ofbi, var))
 		return -EINVAL;
-	}
 
 	if (var->xres + var->xoffset > var->xres_virtual)
 		var->xoffset = var->xres_virtual - var->xres;
@@ -632,6 +722,8 @@ static int omapfb_release(struct fb_info
 	DBG("Closing fb with plane index %d\n", ofbi->id);
 
 	omapfb_lock(fbdev);
+
+	omap_dss_lock();
 #if 1
 	if (display && display->get_update_mode && display->update) {
 		/* XXX this update should be removed, I think. But it's
@@ -652,6 +744,8 @@ static int omapfb_release(struct fb_info
 	if (display && display->sync)
 		display->sync(display);
 
+	omap_dss_unlock();
+
 	omapfb_unlock(fbdev);
 
 	return 0;
@@ -665,19 +759,28 @@ static int omapfb_setup_overlay(struct f
 	struct omapfb_info *ofbi = FB2OFB(fbi);
 	struct fb_var_screeninfo *var = &fbi->var;
 	struct fb_fix_screeninfo *fix = &fbi->fix;
-	enum omap_color_mode mode = 0;
-	int offset;
+	int mode;
 	u32 data_start_p;
 	void __iomem *data_start_v;
 	struct omap_overlay_info info;
 	int xres, yres;
 	int screen_width;
-	int rot, mirror;
+	int mirror;
+	int rotation = var->rotate;
+	int i;
+
+	for (i = 0; i < ofbi->num_overlays; i++) {
+		if (ovl != ofbi->overlays[i])
+			continue;
+
+		rotation = (rotation + ofbi->rotation[i]) % 4;
+		break;
+	}
 
 	DBG("setup_overlay %d, posx %d, posy %d, outw %d, outh %d\n", ofbi->id,
 			posx, posy, outw, outh);
 
-	if (ofbi->rotation == FB_ROTATE_CW || ofbi->rotation == FB_ROTATE_CCW) {
+	if (rotation == FB_ROTATE_CW || rotation == FB_ROTATE_CCW) {
 		xres = var->yres;
 		yres = var->xres;
 	} else {
@@ -685,19 +788,16 @@ static int omapfb_setup_overlay(struct f
 		yres = var->yres;
 	}
 
-	offset = ((var->yoffset * var->xres_virtual +
-				var->xoffset) * var->bits_per_pixel) >> 3;
-
-	if (ofbi->rotation_type == OMAPFB_ROT_VRFB) {
-		data_start_p = omapfb_get_region_rot_paddr(ofbi);
+	if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {
+		data_start_p = omapfb_get_region_rot_paddr(ofbi, rotation, var);
 		data_start_v = NULL;
 	} else {
-		data_start_p = omapfb_get_region_paddr(ofbi);
-		data_start_v = omapfb_get_region_vaddr(ofbi);
-	}
+		unsigned int offset = var->yoffset * fix->line_length +
+			((var->xoffset * var->bits_per_pixel) >> 3);
 
-	data_start_p += offset;
-	data_start_v += offset;
+		data_start_p = omapfb_get_region_paddr(ofbi) + offset;
+		data_start_v = omapfb_get_region_vaddr(ofbi) + offset;
+	}
 
 	mode = fb_mode_to_dss_mode(var);
 
@@ -707,17 +807,25 @@ static int omapfb_setup_overlay(struct f
 		goto err;
 	}
 
-	screen_width = fix->line_length / (var->bits_per_pixel >> 3);
+	switch (var->nonstd) {
+	case OMAPFB_COLOR_YUV422:
+	case OMAPFB_COLOR_YUY422:
+		if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {
+			screen_width = fix->line_length
+				/ (var->bits_per_pixel >> 2);
+			break;
+		}
+	default:
+		screen_width = fix->line_length / (var->bits_per_pixel >> 3);
+		break;
+	}
 
 	ovl->get_overlay_info(ovl, &info);
 
-	if (ofbi->rotation_type == OMAPFB_ROT_VRFB) {
-		rot = 0;
+	if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)
 		mirror = 0;
-	} else {
-		rot = ofbi->rotation;
+	else
 		mirror = ofbi->mirror;
-	}
 
 	info.paddr = data_start_p;
 	info.vaddr = data_start_v;
@@ -725,7 +833,8 @@ static int omapfb_setup_overlay(struct f
 	info.width = xres;
 	info.height = yres;
 	info.color_mode = mode;
-	info.rotation = rot;
+	info.rotation_type = ofbi->rotation_type;
+	info.rotation = rotation;
 	info.mirror = mirror;
 
 	info.pos_x = posx;
@@ -753,6 +862,7 @@ int omapfb_apply_changes(struct fb_info
 	struct omapfb_info *ofbi = FB2OFB(fbi);
 	struct fb_var_screeninfo *var = &fbi->var;
 	struct omap_overlay *ovl;
+	struct omap_overlay_manager *mgr = NULL;
 	u16 posx, posy;
 	u16 outw, outh;
 	int i;
@@ -770,14 +880,18 @@ int omapfb_apply_changes(struct fb_info
 		if (ofbi->region.size == 0) {
 			/* the fb is not available. disable the overlay */
 			omapfb_overlay_enable(ovl, 0);
-			if (!init && ovl->manager)
+			if (!init && ovl->manager) {
+				omap_dss_lock();
 				ovl->manager->apply(ovl->manager);
+				omap_dss_unlock();
+			}
 			continue;
 		}
 
 		if (init || (ovl->caps & OMAP_DSS_OVL_CAP_SCALE) == 0) {
-			if (ofbi->rotation == FB_ROTATE_CW ||
-					ofbi->rotation == FB_ROTATE_CCW) {
+			int rotation = (var->rotate + ofbi->rotation[i]) % 4;
+			if (rotation == FB_ROTATE_CW ||
+					rotation == FB_ROTATE_CCW) {
 				outw = var->yres;
 				outh = var->xres;
 			} else {
@@ -801,9 +915,22 @@ int omapfb_apply_changes(struct fb_info
 		if (r)
 			goto err;
 
-		if (!init && ovl->manager)
-			ovl->manager->apply(ovl->manager);
+		/*
+		 * Do not call mgr->apply() for all managers here.
+		 * mgr->apply() will itself go over all the managers so it's
+		 * enough to call it just once after all overlays are setup
+		 * properly.
+		 */
+		if (!mgr)
+			mgr = ovl->manager;
 	}
+
+	if (!init && mgr) {
+		omap_dss_lock();
+		mgr->apply(mgr);
+		omap_dss_unlock();
+	}
+
 	return 0;
 err:
 	DBG("apply_changes failed\n");
@@ -831,6 +958,11 @@ static int omapfb_set_par(struct fb_info
 	DBG("set_par(%d)\n", FB2OFB(fbi)->id);
 
 	set_fb_fix(fbi);
+
+	r = check_rotation(fbi);
+	if (r)
+		return r;
+
 	r = omapfb_apply_changes(fbi, 0);
 
 	return r;
@@ -841,28 +973,26 @@ static int omapfb_pan_display(struct fb_
 {
 	struct omapfb_info *ofbi = FB2OFB(fbi);
 	struct omapfb2_device *fbdev = ofbi->fbdev;
-	int r = 0;
+	struct fb_var_screeninfo new_var;
+	int r;
 
 	DBG("pan_display(%d)\n", ofbi->id);
 
 	omapfb_lock(fbdev);
 
-	if (var->xoffset != fbi->var.xoffset ||
-	    var->yoffset != fbi->var.yoffset) {
-		struct fb_var_screeninfo new_var;
+	if (var->xoffset == fbi->var.xoffset &&
+	    var->yoffset == fbi->var.yoffset) {
+		omapfb_unlock(fbdev);
+		return 0;
+	}
 
-		new_var = fbi->var;
-		new_var.xoffset = var->xoffset;
-		new_var.yoffset = var->yoffset;
+	new_var = fbi->var;
+	new_var.xoffset = var->xoffset;
+	new_var.yoffset = var->yoffset;
 
-		r = check_fb_var(fbi, &new_var);
+	fbi->var = new_var;
 
-		if (r == 0) {
-			fbi->var = new_var;
-			set_fb_fix(fbi);
-			r = omapfb_apply_changes(fbi, 0);
-		}
-	}
+	r = omapfb_apply_changes(fbi, 0);
 
 	omapfb_unlock(fbdev);
 
@@ -1031,11 +1161,15 @@ static int omapfb_blank(int blank, struc
 
 	omapfb_lock(fbdev);
 
+	omap_dss_lock();
+
 	switch (blank) {
 	case FB_BLANK_UNBLANK:
 		if (display->state != OMAP_DSS_DISPLAY_SUSPENDED)
 			goto exit;
 
+		omap_dss_maximize_min_bus_tput();
+
 		if (display->resume)
 			r = display->resume(display);
 
@@ -1044,6 +1178,7 @@ static int omapfb_blank(int blank, struc
 				OMAP_DSS_UPDATE_MANUAL)
 			do_update = 1;
 
+		omap_dss_update_min_bus_tput();
 		break;
 
 	case FB_BLANK_NORMAL:
@@ -1058,6 +1193,7 @@ static int omapfb_blank(int blank, struc
 		if (display->suspend)
 			r = display->suspend(display);
 
+		omap_dss_update_min_bus_tput();
 		break;
 
 	default:
@@ -1065,8 +1201,6 @@ static int omapfb_blank(int blank, struc
 	}
 
 exit:
-	omapfb_unlock(fbdev);
-
 	if (r == 0 && do_update && display->update) {
 		u16 w, h;
 		display->get_resolution(display, &w, &h);
@@ -1074,6 +1208,10 @@ exit:
 		r = display->update(display, 0, 0, w, h);
 	}
 
+	omap_dss_unlock();
+
+	omapfb_unlock(fbdev);
+
 	return r;
 }
 
@@ -1121,10 +1259,11 @@ static void omapfb_free_fbmem(struct fb_
 	if (rg->vaddr)
 		iounmap(rg->vaddr);
 
-	if (ofbi->rotation_type == OMAPFB_ROT_VRFB) {
+	if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {
 		/* unmap the 0 angle rotation */
 		if (rg->vrfb.vaddr[0]) {
 			iounmap(rg->vrfb.vaddr[0]);
+			rg->vrfb.vaddr[0] = NULL;
 			omap_vrfb_release_ctx(&rg->vrfb);
 		}
 	}
@@ -1135,6 +1274,13 @@ static void omapfb_free_fbmem(struct fb_
 	rg->size = 0;
 }
 
+static void clear_fb_info(struct fb_info *fbi)
+{
+	memset(&fbi->var, 0, sizeof(fbi->var));
+	memset(&fbi->fix, 0, sizeof(fbi->fix));
+	strlcpy(fbi->fix.id, MODULE_NAME, sizeof(fbi->fix.id));
+}
+
 static int omapfb_free_all_fbmem(struct omapfb2_device *fbdev)
 {
 	int i;
@@ -1144,8 +1290,7 @@ static int omapfb_free_all_fbmem(struct
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		struct fb_info *fbi = fbdev->fbs[i];
 		omapfb_free_fbmem(fbi);
-		memset(&fbi->fix, 0, sizeof(fbi->fix));
-		memset(&fbi->var, 0, sizeof(fbi->var));
+		clear_fb_info(fbi);
 	}
 
 	return 0;
@@ -1159,7 +1304,6 @@ static int omapfb_alloc_fbmem(struct fb_
 	struct omapfb2_mem_region *rg;
 	void __iomem *vaddr;
 	int r;
-	int clear = 0;
 
 	rg = &ofbi->region;
 	memset(rg, 0, sizeof(*rg));
@@ -1169,7 +1313,6 @@ static int omapfb_alloc_fbmem(struct fb_
 	if (!paddr) {
 		DBG("allocating %lu bytes for fb %d\n", size, ofbi->id);
 		r = omap_vram_alloc(OMAPFB_MEMTYPE_SDRAM, size, &paddr);
-		clear = 1;
 	} else {
 		DBG("reserving %lu bytes at %lx for fb %d\n", size, paddr,
 				ofbi->id);
@@ -1181,7 +1324,7 @@ static int omapfb_alloc_fbmem(struct fb_
 		return -ENOMEM;
 	}
 
-	if (ofbi->rotation_type != OMAPFB_ROT_VRFB) {
+	if (ofbi->rotation_type != OMAP_DSS_ROT_VRFB) {
 		vaddr = ioremap_wc(paddr, size);
 
 		if (!vaddr) {
@@ -1191,35 +1334,14 @@ static int omapfb_alloc_fbmem(struct fb_
 		}
 
 		DBG("allocated VRAM paddr %lx, vaddr %p\n", paddr, vaddr);
-
-		if (clear)
-			memset_io(vaddr, 0, size);
 	} else {
-		void __iomem *va;
-
 		r = omap_vrfb_request_ctx(&rg->vrfb);
 		if (r) {
 			dev_err(fbdev->dev, "vrfb create ctx failed\n");
 			return r;
 		}
 
-		/* only ioremap the 0 angle view */
-		va = ioremap_wc(rg->vrfb.paddr[0], size);
-
-		if(!va) {
-			printk(KERN_ERR "vrfb: ioremap failed\n");
-			omap_vrfb_release_ctx(&rg->vrfb);
-			return -ENOMEM;
-		}
-
-		DBG("ioremapped vrfb area 0 to %p\n", va);
-
-		rg->vrfb.vaddr[0] = va;
-
 		vaddr = NULL;
-
-		if (clear)
-			memset_io(va, 0, size);
 	}
 
 	rg->paddr = paddr;
@@ -1260,7 +1382,7 @@ static int omapfb_alloc_fbmem_display(st
 
 		display->get_resolution(display, &w, &h);
 
-		if (ofbi->rotation_type == OMAPFB_ROT_VRFB) {
+		if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {
 #ifdef DEBUG
 			int oldw = w, oldh = h;
 #endif
@@ -1472,14 +1594,16 @@ int omapfb_realloc_fbmem(struct fb_info
 	if (old_size == size && old_type == type)
 		return 0;
 
-	if (display && display->sync)
-			display->sync(display);
+	if (display && display->sync) {
+		omap_dss_lock();
+		display->sync(display);
+		omap_dss_unlock();
+	}
 
 	omapfb_free_fbmem(fbi);
 
 	if (size == 0) {
-		memset(&fbi->fix, 0, sizeof(fbi->fix));
-		memset(&fbi->var, 0, sizeof(fbi->var));
+		clear_fb_info(fbi);
 		return 0;
 	}
 
@@ -1489,10 +1613,8 @@ int omapfb_realloc_fbmem(struct fb_info
 		if (old_size)
 			omapfb_alloc_fbmem(fbi, old_size, old_paddr);
 
-		if (rg->size == 0) {
-			memset(&fbi->fix, 0, sizeof(fbi->fix));
-			memset(&fbi->var, 0, sizeof(fbi->var));
-		}
+		if (rg->size == 0)
+			clear_fb_info(fbi);
 
 		return r;
 	}
@@ -1520,13 +1642,15 @@ int omapfb_realloc_fbmem(struct fb_info
 			goto err;
 		memcpy(&fbi->var, &new_var, sizeof(fbi->var));
 		set_fb_fix(fbi);
+		r = check_rotation(fbi);
+		if (r)
+			goto err;
 	}
 
 	return 0;
 err:
 	omapfb_free_fbmem(fbi);
-	memset(&fbi->fix, 0, sizeof(fbi->fix));
-	memset(&fbi->var, 0, sizeof(fbi->var));
+	clear_fb_info(fbi);
 	return r;
 }
 
@@ -1534,7 +1658,6 @@ err:
 int omapfb_fb_init(struct omapfb2_device *fbdev, struct fb_info *fbi)
 {
 	struct fb_var_screeninfo *var = &fbi->var;
-	struct fb_fix_screeninfo *fix = &fbi->fix;
 	struct omap_display *display = fb2display(fbi);
 	struct omapfb_info *ofbi = FB2OFB(fbi);
 	int r = 0;
@@ -1543,18 +1666,15 @@ int omapfb_fb_init(struct omapfb2_device
 	fbi->flags = FBINFO_FLAG_DEFAULT;
 	fbi->pseudo_palette = fbdev->pseudo_palette;
 
-	strncpy(fix->id, MODULE_NAME, sizeof(fix->id));
-
 	if (ofbi->region.size == 0) {
-		memset(&fbi->fix, 0, sizeof(fbi->fix));
-		memset(&fbi->var, 0, sizeof(fbi->var));
+		clear_fb_info(fbi);
 		return 0;
 	}
 
 	var->nonstd = 0;
 	var->bits_per_pixel = 0;
 
-	var->rotate = ofbi->rotation;
+	var->rotate = def_rotate;
 
 	/*
 	 * Check if there is a default color format set in the board file,
@@ -1584,10 +1704,12 @@ int omapfb_fb_init(struct omapfb2_device
 
 	if (display) {
 		u16 w, h;
+		int rotation = (var->rotate + ofbi->rotation[0]) % 4;
+
 		display->get_resolution(display, &w, &h);
 
-		if (ofbi->rotation == FB_ROTATE_CW ||
-				ofbi->rotation == FB_ROTATE_CCW) {
+		if (rotation == FB_ROTATE_CW ||
+				rotation == FB_ROTATE_CCW) {
 			var->xres = h;
 			var->yres = w;
 		} else {
@@ -1626,6 +1748,9 @@ int omapfb_fb_init(struct omapfb2_device
 		goto err;
 
 	set_fb_fix(fbi);
+	r = check_rotation(fbi);
+	if (r)
+		goto err;
 
 	r = fb_alloc_cmap(&fbi->cmap, 256, 0);
 	if (r)
@@ -1662,6 +1787,9 @@ static void omapfb_free_resources(struct
 	}
 
 	for (i = 0; i < fbdev->num_displays; i++) {
+		if (!fbdev->displays[i])
+			continue;
+
 		if (fbdev->displays[i]->state != OMAP_DSS_DISPLAY_DISABLED)
 			fbdev->displays[i]->disable(fbdev->displays[i]);
 
@@ -1694,6 +1822,8 @@ static int omapfb_create_framebuffers(st
 			return -ENOMEM;
 		}
 
+		clear_fb_info(fbi);
+
 		fbdev->fbs[i] = fbi;
 
 		ofbi = FB2OFB(fbi);
@@ -1701,9 +1831,8 @@ static int omapfb_create_framebuffers(st
 		ofbi->id = i;
 
 		/* assign these early, so that fb alloc can use them */
-		ofbi->rotation_type = def_vrfb ? OMAPFB_ROT_VRFB :
-			OMAPFB_ROT_DMA;
-		ofbi->rotation = def_rotate;
+		ofbi->rotation_type = def_vrfb ? OMAP_DSS_ROT_VRFB :
+			OMAP_DSS_ROT_DMA;
 		ofbi->mirror = def_mirror;
 
 		fbdev->num_fbs++;
@@ -1864,7 +1993,9 @@ static int omapfb_set_def_mode(struct om
 	if (r)
 		return r;
 
+	omap_dss_lock();
 	display->set_timings(display, &timings);
+	omap_dss_unlock();
 
 	return 0;
 }
@@ -1949,11 +2080,8 @@ static int omapfb_probe(struct platform_
 	for (i = 0; i < t; i++) {
 		struct omap_display *display;
 		display = omap_dss_get_display(i);
-		if (!display) {
-			dev_err(&pdev->dev, "can't get display %d\n", i);
-			r = -EINVAL;
-			goto cleanup;
-		}
+		if (!display)
+			dev_warn(&pdev->dev, "can't get display %d\n", i);
 
 		fbdev->displays[fbdev->num_displays++] = display;
 	}
@@ -1972,83 +2100,70 @@ static int omapfb_probe(struct platform_
 	for (i = 0; i < fbdev->num_managers; i++)
 		fbdev->managers[i] = omap_dss_get_overlay_manager(i);
 
-
-	/* gfx overlay should be the default one. find a display
-	 * connected to that, and use it as default display */
-	ovl = omap_dss_get_overlay(0);
-	if (ovl->manager && ovl->manager->display) {
-		def_display = ovl->manager->display;
-	} else {
-		dev_err(&pdev->dev, "cannot find default display\n");
-		r = -EINVAL;
-		goto cleanup;
-	}
-
 	if (def_mode && strlen(def_mode) > 0) {
 		if (omapfb_parse_def_modes(fbdev))
-			dev_err(&pdev->dev, "cannot parse default modes\n");
+			dev_warn(&pdev->dev, "cannot parse default modes\n");
 	}
 
 	r = omapfb_create_framebuffers(fbdev);
 	if (r)
 		goto cleanup;
 
+	omap_dss_lock();
+
 	for (i = 0; i < fbdev->num_managers; i++) {
 		struct omap_overlay_manager *mgr;
 		mgr = fbdev->managers[i];
 		r = mgr->apply(mgr);
-		if (r) {
-			dev_err(fbdev->dev, "failed to apply dispc config\n");
-			goto cleanup;
-		}
+		if (r)
+			dev_warn(fbdev->dev, "failed to apply dispc config\n");
 	}
 
 	DBG("mgr->apply'ed\n");
 
-	r = def_display->enable(def_display);
-	if (r) {
-		dev_err(fbdev->dev, "Failed to enable display '%s'\n",
-				def_display->name);
-		goto cleanup;
-	}
-
-	/* set the update mode */
-	if (def_display->caps & OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE) {
-#ifdef CONFIG_FB_OMAP2_FORCE_AUTO_UPDATE
-		if (def_display->set_update_mode)
-			def_display->set_update_mode(def_display,
-					OMAP_DSS_UPDATE_AUTO);
-		if (def_display->enable_te)
-			def_display->enable_te(def_display, 1);
-#else
-		if (def_display->set_update_mode)
-			def_display->set_update_mode(def_display,
-					OMAP_DSS_UPDATE_MANUAL);
-		if (def_display->enable_te)
-			def_display->enable_te(def_display, 0);
-#endif
+	/* gfx overlay should be the default one. find a display
+	 * connected to that, and use it as default display */
+	ovl = omap_dss_get_overlay(0);
+	if (ovl->manager && ovl->manager->display) {
+		def_display = ovl->manager->display;
 	} else {
-		if (def_display->set_update_mode)
-			def_display->set_update_mode(def_display,
-					OMAP_DSS_UPDATE_AUTO);
+		dev_warn(&pdev->dev, "cannot find default display\n");
+		def_display = NULL;
 	}
 
-	for (i = 0; i < fbdev->num_displays; i++) {
-		struct omap_display *display = fbdev->displays[i];
+	if (def_display) {
 		u16 w, h;
+		r = def_display->enable(def_display);
+		if (r)
+			dev_warn(fbdev->dev, "Failed to enable display '%s'\n",
+					def_display->name);
 
-		if (!display->get_update_mode || !display->update)
-			continue;
-
-		if (display->get_update_mode(display) ==
-				OMAP_DSS_UPDATE_MANUAL) {
+		/* set the update mode */
+		if (def_display->caps & OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE) {
+#ifdef CONFIG_FB_OMAP2_FORCE_AUTO_UPDATE
+			if (def_display->enable_te)
+				def_display->enable_te(def_display, 1);
+			if (def_display->set_update_mode)
+				def_display->set_update_mode(def_display,
+						OMAP_DSS_UPDATE_AUTO);
+#else /* MANUAL_UPDATE */
+			if (def_display->enable_te)
+				def_display->enable_te(def_display, 0);
+			if (def_display->set_update_mode)
+				def_display->set_update_mode(def_display,
+						OMAP_DSS_UPDATE_MANUAL);
 
-			display->get_resolution(display, &w, &h);
-			display->update(display, 0, 0, w, h);
+			def_display->get_resolution(def_display, &w, &h);
+			def_display->update(def_display, 0, 0, w, h);
+#endif
+		} else {
+			if (def_display->set_update_mode)
+				def_display->set_update_mode(def_display,
+						OMAP_DSS_UPDATE_AUTO);
 		}
 	}
 
-	DBG("display->updated\n");
+	omap_dss_unlock();
 
 	return 0;
 
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/video/omap2/omapfb/omapfb-sysfs.c kernel-2.6.28-20093908+0m5/drivers/video/omap2/omapfb/omapfb-sysfs.c
--- kernel-2.6.28-20091602+0m5/drivers/video/omap2/omapfb/omapfb-sysfs.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/video/omap2/omapfb/omapfb-sysfs.c	2012-12-16 13:13:01.708330145 +0100
@@ -34,8 +34,6 @@
 
 #include "omapfb.h"
 
-#define DSS1_COMPAT_PANEL
-
 static ssize_t show_rotate_type(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
@@ -45,6 +43,45 @@ static ssize_t show_rotate_type(struct d
 	return snprintf(buf, PAGE_SIZE, "%d\n", ofbi->rotation_type);
 }
 
+static ssize_t store_rotate_type(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct omapfb_info *ofbi = FB2OFB(fbi);
+	struct omapfb2_device *fbdev = ofbi->fbdev;
+	enum omap_dss_rotation_type rot_type;
+	int r;
+
+	rot_type = simple_strtoul(buf, NULL, 0);
+
+	if (rot_type != OMAP_DSS_ROT_DMA && rot_type != OMAP_DSS_ROT_VRFB)
+		return -EINVAL;
+
+	omapfb_lock(fbdev);
+
+	r = 0;
+	if (rot_type == ofbi->rotation_type)
+		goto out;
+
+	if (ofbi->region.size) {
+		r = -EBUSY;
+		goto out;
+	}
+
+	ofbi->rotation_type = rot_type;
+
+	/*
+	 * Since the VRAM for this FB is not allocated at the moment we don't need to
+	 * do any further parameter checking at this point.
+	 */
+out:
+	omapfb_unlock(fbdev);
+
+	return r ? r : count;
+}
+
+
 static ssize_t show_mirror(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
@@ -146,6 +183,7 @@ static ssize_t store_overlays(struct dev
 	struct omap_overlay *ovl;
 	int num_ovls, r, i;
 	int len;
+	bool added = false;
 
 	num_ovls = 0;
 
@@ -221,8 +259,10 @@ static ssize_t store_overlays(struct dev
 		if (ovl->manager)
 			ovl->manager->apply(ovl->manager);
 
-		for (t = i + 1; t < ofbi->num_overlays; t++)
+		for (t = i + 1; t < ofbi->num_overlays; t++) {
+			ofbi->rotation[t-1] = ofbi->rotation[t];
 			ofbi->overlays[t-1] = ofbi->overlays[t];
+		}
 
 		ofbi->num_overlays--;
 		i--;
@@ -244,20 +284,102 @@ static ssize_t store_overlays(struct dev
 
 		if (found)
 			continue;
-
+		ofbi->rotation[ofbi->num_overlays] = 0;
 		ofbi->overlays[ofbi->num_overlays++] = ovl;
 
-		r = omapfb_apply_changes(fbi, 1);
+		added = true;
+	}
+
+	if (added) {
+		r = omapfb_apply_changes(fbi, 0);
 		if (r)
 			goto out;
+	}
+
+	r = count;
+out:
+	omapfb_unlock(fbdev);
+
+	return r;
+}
+
+static ssize_t show_overlays_rotate(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct omapfb_info *ofbi = FB2OFB(fbi);
+	ssize_t l = 0;
+	int t;
+
+	for (t = 0; t < ofbi->num_overlays; t++) {
+		l += snprintf(buf + l, PAGE_SIZE - l, "%s%d",
+				t == 0 ? "" : ",", ofbi->rotation[t]);
+	}
+
+	l += snprintf(buf + l, PAGE_SIZE - l, "\n");
+
+	return l;
+}
+
+static ssize_t store_overlays_rotate(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct omapfb_info *ofbi = FB2OFB(fbi);
+	struct omapfb2_device *fbdev = ofbi->fbdev;
+	int num_ovls = 0, r, i;
+	int len;
+	bool changed = false;
+	u8 rotation[OMAPFB_MAX_OVL_PER_FB];
+
+	len = strlen(buf);
+	if (buf[len - 1] == '\n')
+		len = len - 1;
+
+	omapfb_lock(fbdev);
 
-		if (ovl->manager) {
-			r = ovl->manager->apply(ovl->manager);
-			if (r)
+	if (len > 0) {
+		char *p = (char *)buf;
+
+		while (p < buf + len) {
+			int rot;
+
+			if (num_ovls == ofbi->num_overlays) {
+				r = -EINVAL;
 				goto out;
+			}
+
+			rot = simple_strtoul(p, &p, 0);
+			if (rot < 0 || rot > 3) {
+				r = -EINVAL;
+				goto out;
+			}
+
+			if (ofbi->rotation[num_ovls] != rot)
+				changed = true;
+
+			rotation[num_ovls++] = rot;
+
+			p++;
 		}
 	}
 
+	if (num_ovls != ofbi->num_overlays) {
+		r = -EINVAL;
+		goto out;
+	}
+
+	if (changed) {
+		for (i = 0; i < num_ovls; ++i)
+			ofbi->rotation[i] = rotation[i];
+
+		r = omapfb_apply_changes(fbi, 0);
+		if (r)
+			goto out;
+
+		/* FIXME error handling? */
+	}
+
 	r = count;
 out:
 	omapfb_unlock(fbdev);
@@ -329,52 +451,18 @@ static ssize_t show_virt(struct device *
 }
 
 static struct device_attribute omapfb_attrs[] = {
-	__ATTR(rotate_type, S_IRUGO, show_rotate_type, NULL),
+	__ATTR(rotate_type, S_IRUGO | S_IWUSR, show_rotate_type, store_rotate_type),
 	__ATTR(mirror, S_IRUGO | S_IWUSR, show_mirror, store_mirror),
 	__ATTR(size, S_IRUGO | S_IWUSR, show_size, store_size),
 	__ATTR(overlays, S_IRUGO | S_IWUSR, show_overlays, store_overlays),
+	__ATTR(overlays_rotate, S_IRUGO | S_IWUSR, show_overlays_rotate, store_overlays_rotate),
 	__ATTR(phys_addr, S_IRUGO, show_phys, NULL),
 	__ATTR(virt_addr, S_IRUGO, show_virt, NULL),
 };
 
-#ifdef DSS1_COMPAT_PANEL
-/* panel sysfs entries */
-static ssize_t omapfb_show_panel_name(struct device *dev,
-				      struct device_attribute *attr, char *buf)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct omapfb2_device *fbdev = platform_get_drvdata(pdev);
-	const char *panel_name;
-
-	if (fbdev->num_displays < 1 || fbdev->displays[0] == NULL ||
-	    fbdev->displays[0]->panel == NULL) {
-		return -ENODEV;
-	}
-	/* Strip the leading 'panel-' string */
-	panel_name = fbdev->displays[0]->panel->name;
-	if (strncmp(panel_name, "panel-", 6) == 0)
-		panel_name += 6;
-
-	return snprintf(buf, PAGE_SIZE, "%s\n", panel_name);
-}
-
-static struct device_attribute dev_attr_panel_name =
-	__ATTR(name, 0444, omapfb_show_panel_name, NULL);
-
-static struct attribute *panel_attrs[] = {
-	&dev_attr_panel_name.attr,
-	NULL,
-};
-
-static struct attribute_group panel_attr_group = {
-	.name  = "panel",
-	.attrs = panel_attrs,
-};
-#endif	/* DSS1_COMPAT_PANEL */
-
 int omapfb_create_sysfs(struct omapfb2_device *fbdev)
 {
-	int i, t;
+	int i;
 	int r;
 
 	DBG("create sysfs for fbs\n");
@@ -390,17 +478,6 @@ int omapfb_create_sysfs(struct omapfb2_d
 			}
 		}
 	}
-#ifdef DSS1_COMPAT_PANEL
-	r = sysfs_create_group(&fbdev->dev->kobj, &panel_attr_group);
-	if (r) {
-		dev_err(fbdev->dev, "failed to create compat sysfs clk file\n");
-		for (i = 0; i < fbdev->num_fbs; i++) {
-			for (t = 0; t < ARRAY_SIZE(omapfb_attrs); t++)
-				device_remove_file(fbdev->fbs[i]->dev,
-						&omapfb_attrs[t]);
-		}
-	}
-#endif	/* DSS1_COMPAT_PANEL */
 
 	return 0;
 }
@@ -410,9 +487,6 @@ void omapfb_remove_sysfs(struct omapfb2_
 	int i, t;
 
 	DBG("remove sysfs for fbs\n");
-#ifdef DSS1_COMPAT_PANEL
-	sysfs_remove_group(&fbdev->dev->kobj, &panel_attr_group);
-#endif
 	for (i = 0; i < fbdev->num_fbs; i++) {
 		for (t = 0; t < ARRAY_SIZE(omapfb_attrs); t++)
 			device_remove_file(fbdev->fbs[i]->dev,
diff -Nurp kernel-2.6.28-20091602+0m5/drivers/watchdog/twl4030_wdt.c kernel-2.6.28-20093908+0m5/drivers/watchdog/twl4030_wdt.c
--- kernel-2.6.28-20091602+0m5/drivers/watchdog/twl4030_wdt.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/drivers/watchdog/twl4030_wdt.c	2012-12-16 13:13:01.708330145 +0100
@@ -28,6 +28,13 @@
 #include <linux/uaccess.h>
 #include <linux/i2c/twl4030.h>
 
+#define TWL4030_WDT_ENABLE_POWEROFF_ON_SUSPEND 1
+
+
+#ifdef TWL4030_WDT_ENABLE_POWEROFF_ON_SUSPEND
+#include <linux/debugfs.h>
+#endif
+
 #define TWL4030_WATCHDOG_CFG_REG_OFFS	0x3
 
 static int nowayout = WATCHDOG_NOWAYOUT;
@@ -35,8 +42,10 @@ module_param(nowayout, int, 0);
 MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started "
 	"(default=" __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
 
-#define	TWL4030_WDT_STATE_OPEN_BIT	0x1
-#define TWL4030_WDT_STATE_OPEN		0x1
+
+
+#define	TWL4030_WDT_STATE_OPEN_BIT	0x0
+#define TWL4030_WDT_STATE_OPEN		(1 << TWL4030_WDT_STATE_OPEN_BIT)
 #define TWL4030_WDT_STATE_ACTIVE	0x8
 
 static struct platform_device *twl4030_wdt_dev;
@@ -45,6 +54,9 @@ struct twl4030_wdt {
 	struct miscdevice	miscdev;
 	int			timer_margin;
 	unsigned long		state;
+#ifdef TWL4030_WDT_ENABLE_POWEROFF_ON_SUSPEND
+	u8			poweroff_on_suspend;
+#endif
 };
 
 static int twl4030_wdt_write(unsigned char val)
@@ -79,6 +91,10 @@ static int twl4030_wdt_set_timeout(struc
 	return twl4030_wdt_ping(wdt);
 }
 
+#ifdef TWL4030_WDT_ENABLE_POWEROFF_ON_SUSPEND
+static struct dentry *twl4030_wdt_debugfs;
+#endif
+
 static ssize_t twl4030_wdt_write_fop(struct file *file,
 		const char __user *data, size_t len, loff_t *ppos)
 {
@@ -166,6 +182,11 @@ static int twl4030_wdt_release(struct in
 static int twl4030_wdt_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	struct twl4030_wdt *wdt = platform_get_drvdata(pdev);
+#ifdef TWL4030_WDT_ENABLE_POWEROFF_ON_SUSPEND
+	if (wdt->poweroff_on_suspend > 0 && wdt->poweroff_on_suspend < 31)
+		return twl4030_wdt_write(wdt->poweroff_on_suspend + 1);
+#endif
+
 	return (wdt->state & TWL4030_WDT_STATE_ACTIVE) ?
 		twl4030_wdt_disable(wdt) : 0;
 }
@@ -219,6 +240,12 @@ static int __devinit twl4030_wdt_probe(s
 
 	platform_set_drvdata(pdev, wdt);
 
+#ifdef TWL4030_WDT_ENABLE_POWEROFF_ON_SUSPEND
+	twl4030_wdt_debugfs = debugfs_create_dir("twl4030_wdt", NULL);
+	if (!IS_ERR(twl4030_wdt_debugfs) && twl4030_wdt_debugfs)
+		debugfs_create_u8("poweroff_on_suspend", 0644,
+			twl4030_wdt_debugfs, &wdt->poweroff_on_suspend);
+#endif
 	twl4030_wdt_dev = pdev;
 	return 0;
 }
@@ -230,6 +257,11 @@ static int __devexit twl4030_wdt_remove(
 	if (wdt->state & TWL4030_WDT_STATE_ACTIVE)
 		if (twl4030_wdt_disable(wdt))
 			return -EFAULT;
+#ifdef TWL4030_WDT_ENABLE_POWEROFF_ON_SUSPEND
+	if (!IS_ERR(twl4030_wdt_debugfs) && twl4030_wdt_debugfs)
+		debugfs_remove_recursive(twl4030_wdt_debugfs);
+#endif
+
 
 	misc_deregister(&wdt->miscdev);
 
diff -Nurp kernel-2.6.28-20091602+0m5/fs/affs/bitmap.c kernel-2.6.28-20093908+0m5/fs/affs/bitmap.c
--- kernel-2.6.28-20091602+0m5/fs/affs/bitmap.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/affs/bitmap.c	2012-12-16 13:13:01.712330145 +0100
@@ -102,7 +102,7 @@ affs_free_block(struct super_block *sb,
 	*(__be32 *)bh->b_data = cpu_to_be32(tmp - mask);
 
 	mark_buffer_dirty(bh);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	bm->bm_free++;
 
 	mutex_unlock(&sbi->s_bmlock);
@@ -247,7 +247,7 @@ find_bit:
 	*(__be32 *)bh->b_data = cpu_to_be32(tmp + mask);
 
 	mark_buffer_dirty(bh);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 
 	mutex_unlock(&sbi->s_bmlock);
 
diff -Nurp kernel-2.6.28-20091602+0m5/fs/affs/super.c kernel-2.6.28-20093908+0m5/fs/affs/super.c
--- kernel-2.6.28-20091602+0m5/fs/affs/super.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/affs/super.c	2012-12-16 13:13:01.712330145 +0100
@@ -60,9 +60,13 @@ affs_write_super(struct super_block *sb)
 				  &AFFS_ROOT_TAIL(sb, sbi->s_root_bh)->disk_change);
 		affs_fix_checksum(sb, sbi->s_root_bh);
 		mark_buffer_dirty(sbi->s_root_bh);
-		sb->s_dirt = !clean;	/* redo until bitmap synced */
+		/* redo until bitmap synced */
+		if (clean)
+			mark_sb_clean(sb);
+		else
+			mark_sb_dirty(sb);
 	} else
-		sb->s_dirt = 0;
+		mark_sb_clean(sb);
 
 	pr_debug("AFFS: write_super() at %lu, clean=%d\n", get_seconds(), clean);
 }
@@ -518,8 +522,8 @@ affs_remount(struct super_block *sb, int
 	if ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))
 		return 0;
 	if (*flags & MS_RDONLY) {
-		sb->s_dirt = 1;
-		while (sb->s_dirt)
+		mark_sb_dirty(sb);
+		while (is_sb_dirty(sb))
 			affs_write_super(sb);
 		affs_free_bitmap(sb);
 	} else
diff -Nurp kernel-2.6.28-20091602+0m5/fs/bfs/inode.c kernel-2.6.28-20093908+0m5/fs/bfs/inode.c
--- kernel-2.6.28-20091602+0m5/fs/bfs/inode.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/bfs/inode.c	2012-12-16 13:13:01.712330145 +0100
@@ -244,7 +244,7 @@ static void bfs_write_super(struct super
 	mutex_lock(&info->bfs_lock);
 	if (!(s->s_flags & MS_RDONLY))
 		mark_buffer_dirty(info->si_sbh);
-	s->s_dirt = 0;
+	mark_sb_clean(s);
 	mutex_unlock(&info->bfs_lock);
 }
 
@@ -411,7 +411,7 @@ static int bfs_fill_super(struct super_b
 	brelse(bh);
 	if (!(s->s_flags & MS_RDONLY)) {
 		mark_buffer_dirty(info->si_sbh);
-		s->s_dirt = 1;
+		mark_sb_dirty(s);
 	} 
 	dump_imap("read_super", s);
 	mutex_init(&info->bfs_lock);
diff -Nurp kernel-2.6.28-20091602+0m5/fs/eventpoll.c kernel-2.6.28-20093908+0m5/fs/eventpoll.c
--- kernel-2.6.28-20091602+0m5/fs/eventpoll.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/eventpoll.c	2012-12-16 13:13:01.712330145 +0100
@@ -234,8 +234,6 @@ struct ep_pqueue {
 /*
  * Configuration options available inside /proc/sys/fs/epoll/
  */
-/* Maximum number of epoll devices, per user */
-static int max_user_instances __read_mostly;
 /* Maximum number of epoll watched descriptors, per user */
 static int max_user_watches __read_mostly;
 
@@ -261,14 +259,6 @@ static int zero;
 
 ctl_table epoll_table[] = {
 	{
-		.procname	= "max_user_instances",
-		.data		= &max_user_instances,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= &proc_dointvec_minmax,
-		.extra1		= &zero,
-	},
-	{
 		.procname	= "max_user_watches",
 		.data		= &max_user_watches,
 		.maxlen		= sizeof(int),
@@ -491,7 +481,6 @@ static void ep_free(struct eventpoll *ep
 
 	mutex_unlock(&epmutex);
 	mutex_destroy(&ep->mtx);
-	atomic_dec(&ep->user->epoll_devs);
 	free_uid(ep->user);
 	kfree(ep);
 }
@@ -581,10 +570,6 @@ static int ep_alloc(struct eventpoll **p
 	struct eventpoll *ep;
 
 	user = get_current_user();
-	error = -EMFILE;
-	if (unlikely(atomic_read(&user->epoll_devs) >=
-			max_user_instances))
-		goto free_uid;
 	error = -ENOMEM;
 	ep = kzalloc(sizeof(*ep), GFP_KERNEL);
 	if (unlikely(!ep))
@@ -1141,7 +1126,6 @@ asmlinkage long sys_epoll_create1(int fl
 			      flags & O_CLOEXEC);
 	if (fd < 0)
 		ep_free(ep);
-	atomic_inc(&ep->user->epoll_devs);
 
 error_return:
 	DNPRINTK(3, (KERN_INFO "[%p] eventpoll: sys_epoll_create(%d) = %d\n",
@@ -1366,8 +1350,10 @@ static int __init eventpoll_init(void)
 	struct sysinfo si;
 
 	si_meminfo(&si);
-	max_user_instances = 128;
-	max_user_watches = (((si.totalram - si.totalhigh) / 32) << PAGE_SHIFT) /
+	/*
+	 * Allows top 4% of lomem to be allocated for epoll watches (per user).
+	 */
+	max_user_watches = (((si.totalram - si.totalhigh) / 25) << PAGE_SHIFT) /
 		EP_ITEM_COST;
 
 	/* Initialize the structure used to perform safe poll wait head wake ups */
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ext2/balloc.c kernel-2.6.28-20093908+0m5/fs/ext2/balloc.c
--- kernel-2.6.28-20091602+0m5/fs/ext2/balloc.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ext2/balloc.c	2012-12-16 13:13:01.712330145 +0100
@@ -164,7 +164,7 @@ static void release_blocks(struct super_
 		struct ext2_sb_info *sbi = EXT2_SB(sb);
 
 		percpu_counter_add(&sbi->s_freeblocks_counter, count);
-		sb->s_dirt = 1;
+		mark_sb_dirty(sb);
 	}
 }
 
@@ -179,7 +179,7 @@ static void group_adjust_blocks(struct s
 		free_blocks = le16_to_cpu(desc->bg_free_blocks_count);
 		desc->bg_free_blocks_count = cpu_to_le16(free_blocks + count);
 		spin_unlock(sb_bgl_lock(sbi, group_no));
-		sb->s_dirt = 1;
+		mark_sb_dirty(sb);
 		mark_buffer_dirty(bh);
 	}
 }
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ext2/ialloc.c kernel-2.6.28-20093908+0m5/fs/ext2/ialloc.c
--- kernel-2.6.28-20091602+0m5/fs/ext2/ialloc.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ext2/ialloc.c	2012-12-16 13:13:01.712330145 +0100
@@ -81,7 +81,7 @@ static void ext2_release_inode(struct su
 	spin_unlock(sb_bgl_lock(EXT2_SB(sb), group));
 	if (dir)
 		percpu_counter_dec(&EXT2_SB(sb)->s_dirs_counter);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	mark_buffer_dirty(bh);
 }
 
@@ -548,7 +548,7 @@ got:
 	}
 	spin_unlock(sb_bgl_lock(sbi, group));
 
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	mark_buffer_dirty(bh2);
 	inode->i_uid = current->fsuid;
 	if (test_opt (sb, GRPID))
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ext2/super.c kernel-2.6.28-20093908+0m5/fs/ext2/super.c
--- kernel-2.6.28-20091602+0m5/fs/ext2/super.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ext2/super.c	2012-12-16 13:13:01.712330145 +0100
@@ -1094,7 +1094,7 @@ static void ext2_commit_super (struct su
 {
 	es->s_wtime = cpu_to_le32(get_seconds());
 	mark_buffer_dirty(EXT2_SB(sb)->s_sbh);
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 }
 
 static void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es)
@@ -1104,7 +1104,7 @@ static void ext2_sync_super(struct super
 	es->s_wtime = cpu_to_le32(get_seconds());
 	mark_buffer_dirty(EXT2_SB(sb)->s_sbh);
 	sync_dirty_buffer(EXT2_SB(sb)->s_sbh);
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 }
 
 /*
@@ -1135,7 +1135,7 @@ void ext2_write_super (struct super_bloc
 		} else
 			ext2_commit_super (sb, es);
 	}
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 	unlock_kernel();
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ext2/xattr.c kernel-2.6.28-20093908+0m5/fs/ext2/xattr.c
--- kernel-2.6.28-20091602+0m5/fs/ext2/xattr.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ext2/xattr.c	2012-12-16 13:13:01.712330145 +0100
@@ -343,7 +343,7 @@ static void ext2_xattr_update_super_bloc
 		return;
 
 	EXT2_SET_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	mark_buffer_dirty(EXT2_SB(sb)->s_sbh);
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ext3/balloc.c kernel-2.6.28-20093908+0m5/fs/ext3/balloc.c
--- kernel-2.6.28-20091602+0m5/fs/ext3/balloc.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ext3/balloc.c	2012-12-16 13:13:01.712330145 +0100
@@ -649,7 +649,7 @@ do_more:
 		count = overflow;
 		goto do_more;
 	}
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 error_return:
 	brelse(bitmap_bh);
 	ext3_std_error(sb, err);
@@ -1708,7 +1708,7 @@ allocated:
 	if (!fatal)
 		fatal = err;
 
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	if (fatal)
 		goto out;
 
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ext3/ialloc.c kernel-2.6.28-20093908+0m5/fs/ext3/ialloc.c
--- kernel-2.6.28-20091602+0m5/fs/ext3/ialloc.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ext3/ialloc.c	2012-12-16 13:13:01.712330145 +0100
@@ -181,7 +181,7 @@ void ext3_free_inode (handle_t *handle,
 	err = ext3_journal_dirty_metadata(handle, bitmap_bh);
 	if (!fatal)
 		fatal = err;
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 error_return:
 	brelse(bitmap_bh);
 	ext3_std_error(sb, fatal);
@@ -537,7 +537,7 @@ got:
 	percpu_counter_dec(&sbi->s_freeinodes_counter);
 	if (S_ISDIR(mode))
 		percpu_counter_inc(&sbi->s_dirs_counter);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 
 	inode->i_uid = current->fsuid;
 	if (test_opt (sb, GRPID))
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ext3/inode.c kernel-2.6.28-20093908+0m5/fs/ext3/inode.c
--- kernel-2.6.28-20091602+0m5/fs/ext3/inode.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ext3/inode.c	2012-12-16 13:13:01.712330145 +0100
@@ -2924,7 +2924,7 @@ static int ext3_do_update_inode(handle_t
 				ext3_update_dynamic_rev(sb);
 				EXT3_SET_RO_COMPAT_FEATURE(sb,
 					EXT3_FEATURE_RO_COMPAT_LARGE_FILE);
-				sb->s_dirt = 1;
+				mark_sb_dirty(sb);
 				handle->h_sync = 1;
 				err = ext3_journal_dirty_metadata(handle,
 						EXT3_SB(sb)->s_sbh);
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ext3/resize.c kernel-2.6.28-20093908+0m5/fs/ext3/resize.c
--- kernel-2.6.28-20091602+0m5/fs/ext3/resize.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ext3/resize.c	2012-12-16 13:13:01.712330145 +0100
@@ -934,7 +934,7 @@ int ext3_group_add(struct super_block *s
 			   EXT3_INODES_PER_GROUP(sb));
 
 	ext3_journal_dirty_metadata(handle, sbi->s_sbh);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 
 exit_journal:
 	unlock_super(sb);
@@ -1066,7 +1066,7 @@ int ext3_group_extend(struct super_block
 	}
 	es->s_blocks_count = cpu_to_le32(o_blocks_count + add);
 	ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	unlock_super(sb);
 	ext3_debug("freeing blocks %lu through "E3FSBLK"\n", o_blocks_count,
 		   o_blocks_count + add);
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ext3/super.c kernel-2.6.28-20093908+0m5/fs/ext3/super.c
--- kernel-2.6.28-20091602+0m5/fs/ext3/super.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ext3/super.c	2012-12-16 13:13:01.712330145 +0100
@@ -2221,7 +2221,7 @@ static int ext3_load_journal(struct supe
 	if (journal_devnum &&
 	    journal_devnum != le32_to_cpu(es->s_journal_dev)) {
 		es->s_journal_dev = cpu_to_le32(journal_devnum);
-		sb->s_dirt = 1;
+		mark_sb_dirty(sb);
 
 		/* Make sure we flush the recovery flag to disk. */
 		ext3_commit_super(sb, es, 1);
@@ -2264,7 +2264,7 @@ static int ext3_create_journal(struct su
 	EXT3_SET_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL);
 
 	es->s_journal_inum = cpu_to_le32(journal_inum);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 
 	/* Make sure we flush the recovery flag to disk. */
 	ext3_commit_super(sb, es, 1);
@@ -2308,7 +2308,7 @@ static void ext3_mark_recovery_complete(
 	if (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER) &&
 	    sb->s_flags & MS_RDONLY) {
 		EXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);
-		sb->s_dirt = 0;
+		mark_sb_clean(sb);
 		ext3_commit_super(sb, es, 1);
 	}
 	unlock_super(sb);
@@ -2367,7 +2367,7 @@ int ext3_force_commit(struct super_block
 		return 0;
 
 	journal = EXT3_SB(sb)->s_journal;
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 	ret = ext3_journal_force_commit(journal);
 	return ret;
 }
@@ -2382,12 +2382,12 @@ static void ext3_write_super (struct sup
 {
 	if (mutex_trylock(&sb->s_lock) != 0)
 		BUG();
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 }
 
 static int ext3_sync_fs(struct super_block *sb, int wait)
 {
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 	if (wait)
 		ext3_force_commit(sb);
 	else
@@ -2402,7 +2402,7 @@ static int ext3_sync_fs(struct super_blo
  */
 static void ext3_write_super_lockfs(struct super_block *sb)
 {
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 
 	if (!(sb->s_flags & MS_RDONLY)) {
 		journal_t *journal = EXT3_SB(sb)->s_journal;
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ext3/xattr.c kernel-2.6.28-20093908+0m5/fs/ext3/xattr.c
--- kernel-2.6.28-20091602+0m5/fs/ext3/xattr.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ext3/xattr.c	2012-12-16 13:13:01.712330145 +0100
@@ -463,7 +463,7 @@ static void ext3_xattr_update_super_bloc
 
 	if (ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh) == 0) {
 		EXT3_SET_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_EXT_ATTR);
-		sb->s_dirt = 1;
+		mark_sb_dirty(sb);
 		ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);
 	}
 }
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ext4/balloc.c kernel-2.6.28-20093908+0m5/fs/ext4/balloc.c
--- kernel-2.6.28-20091602+0m5/fs/ext4/balloc.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ext4/balloc.c	2012-12-16 13:13:01.712330145 +0100
@@ -544,7 +544,7 @@ do_more:
 		count = overflow;
 		goto do_more;
 	}
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 error_return:
 	brelse(bitmap_bh);
 	ext4_std_error(sb, err);
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ext4/ialloc.c kernel-2.6.28-20093908+0m5/fs/ext4/ialloc.c
--- kernel-2.6.28-20091602+0m5/fs/ext4/ialloc.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ext4/ialloc.c	2012-12-16 13:13:01.712330145 +0100
@@ -261,7 +261,7 @@ void ext4_free_inode(handle_t *handle, s
 	err = ext4_journal_dirty_metadata(handle, bitmap_bh);
 	if (!fatal)
 		fatal = err;
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 error_return:
 	brelse(bitmap_bh);
 	ext4_std_error(sb, fatal);
@@ -778,7 +778,7 @@ got:
 	percpu_counter_dec(&sbi->s_freeinodes_counter);
 	if (S_ISDIR(mode))
 		percpu_counter_inc(&sbi->s_dirs_counter);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 
 	if (sbi->s_log_groups_per_flex) {
 		flex_group = ext4_flex_group(sbi, group);
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ext4/inode.c kernel-2.6.28-20093908+0m5/fs/ext4/inode.c
--- kernel-2.6.28-20091602+0m5/fs/ext4/inode.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ext4/inode.c	2012-12-16 13:13:01.712330145 +0100
@@ -4309,7 +4309,7 @@ static int ext4_do_update_inode(handle_t
 			ext4_update_dynamic_rev(sb);
 			EXT4_SET_RO_COMPAT_FEATURE(sb,
 					EXT4_FEATURE_RO_COMPAT_LARGE_FILE);
-			sb->s_dirt = 1;
+			mark_sb_dirty(sb);
 			handle->h_sync = 1;
 			err = ext4_journal_dirty_metadata(handle,
 					EXT4_SB(sb)->s_sbh);
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ext4/mballoc.c kernel-2.6.28-20093908+0m5/fs/ext4/mballoc.c
--- kernel-2.6.28-20091602+0m5/fs/ext4/mballoc.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ext4/mballoc.c	2012-12-16 13:13:01.716330145 +0100
@@ -2905,7 +2905,7 @@ ext4_mb_mark_diskspace_used(struct ext4_
 	err = ext4_journal_dirty_metadata(handle, gdp_bh);
 
 out_err:
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	brelse(bitmap_bh);
 	return err;
 }
@@ -4647,7 +4647,7 @@ do_more:
 		put_bh(bitmap_bh);
 		goto do_more;
 	}
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 error_return:
 	brelse(bitmap_bh);
 	ext4_std_error(sb, err);
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ext4/resize.c kernel-2.6.28-20093908+0m5/fs/ext4/resize.c
--- kernel-2.6.28-20091602+0m5/fs/ext4/resize.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ext4/resize.c	2012-12-16 13:13:01.716330145 +0100
@@ -938,7 +938,7 @@ int ext4_group_add(struct super_block *s
 	}
 
 	ext4_journal_dirty_metadata(handle, sbi->s_sbh);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 
 exit_journal:
 	unlock_super(sb);
@@ -1072,7 +1072,7 @@ int ext4_group_extend(struct super_block
 	}
 	ext4_blocks_count_set(es, o_blocks_count + add);
 	ext4_journal_dirty_metadata(handle, EXT4_SB(sb)->s_sbh);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	unlock_super(sb);
 	ext4_debug("freeing blocks %llu through %llu\n", o_blocks_count,
 		   o_blocks_count + add);
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ext4/super.c kernel-2.6.28-20093908+0m5/fs/ext4/super.c
--- kernel-2.6.28-20091602+0m5/fs/ext4/super.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ext4/super.c	2012-12-16 13:13:01.716330145 +0100
@@ -2710,7 +2710,7 @@ static int ext4_load_journal(struct supe
 	if (journal_devnum &&
 	    journal_devnum != le32_to_cpu(es->s_journal_dev)) {
 		es->s_journal_dev = cpu_to_le32(journal_devnum);
-		sb->s_dirt = 1;
+		mark_sb_dirty(sb);
 
 		/* Make sure we flush the recovery flag to disk. */
 		ext4_commit_super(sb, es, 1);
@@ -2753,7 +2753,7 @@ static int ext4_create_journal(struct su
 	EXT4_SET_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL);
 
 	es->s_journal_inum = cpu_to_le32(journal_inum);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 
 	/* Make sure we flush the recovery flag to disk. */
 	ext4_commit_super(sb, es, 1);
@@ -2817,7 +2817,7 @@ static void ext4_mark_recovery_complete(
 	if (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER) &&
 	    sb->s_flags & MS_RDONLY) {
 		EXT4_CLEAR_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);
-		sb->s_dirt = 0;
+		mark_sb_clean(sb);
 		ext4_commit_super(sb, es, 1);
 	}
 	unlock_super(sb);
@@ -2876,7 +2876,7 @@ int ext4_force_commit(struct super_block
 		return 0;
 
 	journal = EXT4_SB(sb)->s_journal;
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 	ret = ext4_journal_force_commit(journal);
 	return ret;
 }
@@ -2891,7 +2891,7 @@ static void ext4_write_super(struct supe
 {
 	if (mutex_trylock(&sb->s_lock) != 0)
 		BUG();
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 }
 
 static int ext4_sync_fs(struct super_block *sb, int wait)
@@ -2899,7 +2899,7 @@ static int ext4_sync_fs(struct super_blo
 	int ret = 0;
 
 	trace_mark(ext4_sync_fs, "dev %s wait %d", sb->s_id, wait);
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 	if (wait)
 		ret = ext4_force_commit(sb);
 	else
@@ -2913,7 +2913,7 @@ static int ext4_sync_fs(struct super_blo
  */
 static void ext4_write_super_lockfs(struct super_block *sb)
 {
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 
 	if (!(sb->s_flags & MS_RDONLY)) {
 		journal_t *journal = EXT4_SB(sb)->s_journal;
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ext4/xattr.c kernel-2.6.28-20093908+0m5/fs/ext4/xattr.c
--- kernel-2.6.28-20091602+0m5/fs/ext4/xattr.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ext4/xattr.c	2012-12-16 13:13:01.716330145 +0100
@@ -456,7 +456,7 @@ static void ext4_xattr_update_super_bloc
 
 	if (ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh) == 0) {
 		EXT4_SET_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_EXT_ATTR);
-		sb->s_dirt = 1;
+		mark_sb_dirty(sb);
 		ext4_journal_dirty_metadata(handle, EXT4_SB(sb)->s_sbh);
 	}
 }
diff -Nurp kernel-2.6.28-20091602+0m5/fs/fat/cache.c kernel-2.6.28-20093908+0m5/fs/fat/cache.c
--- kernel-2.6.28-20091602+0m5/fs/fat/cache.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/fat/cache.c	2012-12-16 13:13:01.716330145 +0100
@@ -241,7 +241,7 @@ int fat_get_cluster(struct inode *inode,
 	while (*fclus < cluster) {
 		/* prevent the infinite loop of cluster chain */
 		if (*fclus > limit) {
-			fat_fs_panic(sb, "%s: detected the cluster chain loop"
+			fat_fs_error(sb, "%s: detected the cluster chain loop"
 				     " (i_pos %lld)", __func__,
 				     MSDOS_I(inode)->i_pos);
 			nr = -EIO;
@@ -252,7 +252,7 @@ int fat_get_cluster(struct inode *inode,
 		if (nr < 0)
 			goto out;
 		else if (nr == FAT_ENT_FREE) {
-			fat_fs_panic(sb, "%s: invalid cluster chain"
+			fat_fs_error(sb, "%s: invalid cluster chain"
 				     " (i_pos %lld)", __func__,
 				     MSDOS_I(inode)->i_pos);
 			nr = -EIO;
@@ -285,7 +285,7 @@ static int fat_bmap_cluster(struct inode
 	if (ret < 0)
 		return ret;
 	else if (ret == FAT_ENT_EOF) {
-		fat_fs_panic(sb, "%s: request beyond EOF (i_pos %lld)",
+		fat_fs_error(sb, "%s: request beyond EOF (i_pos %lld)",
 			     __func__, MSDOS_I(inode)->i_pos);
 		return -EIO;
 	}
diff -Nurp kernel-2.6.28-20091602+0m5/fs/fat/dir.c kernel-2.6.28-20093908+0m5/fs/fat/dir.c
--- kernel-2.6.28-20091602+0m5/fs/fat/dir.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/fat/dir.c	2012-12-16 13:13:01.716330145 +0100
@@ -1335,7 +1335,7 @@ found:
 			goto error_remove;
 		}
 		if (dir->i_size & (sbi->cluster_size - 1)) {
-			fat_fs_panic(sb, "Odd directory size");
+			fat_fs_error(sb, "Odd directory size");
 			dir->i_size = (dir->i_size + sbi->cluster_size - 1)
 				& ~((loff_t)sbi->cluster_size - 1);
 		}
diff -Nurp kernel-2.6.28-20091602+0m5/fs/fat/fatent.c kernel-2.6.28-20093908+0m5/fs/fat/fatent.c
--- kernel-2.6.28-20091602+0m5/fs/fat/fatent.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/fat/fatent.c	2012-12-16 13:13:01.716330145 +0100
@@ -345,7 +345,7 @@ int fat_ent_read(struct inode *inode, st
 
 	if (entry < FAT_START_ENT || sbi->max_cluster <= entry) {
 		fatent_brelse(fatent);
-		fat_fs_panic(sb, "invalid access to FAT (entry 0x%08x)", entry);
+		fat_fs_error(sb, "invalid access to FAT (entry 0x%08x)", entry);
 		return -EIO;
 	}
 
@@ -495,7 +495,7 @@ int fat_alloc_clusters(struct inode *ino
 				sbi->prev_free = entry;
 				if (sbi->free_clusters != -1)
 					sbi->free_clusters--;
-				sb->s_dirt = 1;
+				mark_sb_dirty(sb);
 
 				cluster[idx_clus] = entry;
 				idx_clus++;
@@ -517,7 +517,7 @@ int fat_alloc_clusters(struct inode *ino
 	/* Couldn't allocate the free entries */
 	sbi->free_clusters = 0;
 	sbi->free_clus_valid = 1;
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	err = -ENOSPC;
 
 out:
@@ -557,7 +557,7 @@ int fat_free_clusters(struct inode *inod
 			err = cluster;
 			goto error;
 		} else if (cluster == FAT_ENT_FREE) {
-			fat_fs_panic(sb, "%s: deleting FAT entry beyond EOF",
+			fat_fs_error(sb, "%s: deleting FAT entry beyond EOF",
 				     __func__);
 			err = -EIO;
 			goto error;
@@ -578,7 +578,7 @@ int fat_free_clusters(struct inode *inod
 		ops->ent_put(&fatent, FAT_ENT_FREE);
 		if (sbi->free_clusters != -1) {
 			sbi->free_clusters++;
-			sb->s_dirt = 1;
+			mark_sb_dirty(sb);
 		}
 
 		if (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {
@@ -668,7 +668,7 @@ int fat_count_free_clusters(struct super
 	}
 	sbi->free_clusters = free;
 	sbi->free_clus_valid = 1;
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	fatent_brelse(&fatent);
 out:
 	unlock_fat(sbi);
diff -Nurp kernel-2.6.28-20091602+0m5/fs/fat/fat.h kernel-2.6.28-20093908+0m5/fs/fat/fat.h
--- kernel-2.6.28-20091602+0m5/fs/fat/fat.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/fat/fat.h	2012-12-16 13:13:01.716330145 +0100
@@ -17,6 +17,10 @@
 #define VFAT_SFN_CREATE_WIN95	0x0100 /* emulate win95 rule for create */
 #define VFAT_SFN_CREATE_WINNT	0x0200 /* emulate winnt rule for create */
 
+#define FAT_ERRORS_CONT		1      /* ignore error and continue */
+#define FAT_ERRORS_PANIC	2      /* panic on error */
+#define FAT_ERRORS_RO		3      /* remount r/o on error */
+
 struct fat_mount_options {
 	uid_t fs_uid;
 	gid_t fs_gid;
@@ -26,6 +30,7 @@ struct fat_mount_options {
 	char *iocharset;          /* Charset used for filename input/display */
 	unsigned short shortname; /* flags for shortname display/create rule */
 	unsigned char name_check; /* r = relaxed, n = normal, s = strict */
+	unsigned char errors;	  /* On error: continue, panic, remount-ro */
 	unsigned short allow_utime;/* permission for setting the [am]time */
 	unsigned quiet:1,         /* set = fake successful chmods and chowns */
 		 showexec:1,      /* set = only set x bit for com/exe/bat */
@@ -310,7 +315,7 @@ extern int fat_fill_super(struct super_b
 extern int fat_flush_inodes(struct super_block *sb, struct inode *i1,
 		            struct inode *i2);
 /* fat/misc.c */
-extern void fat_fs_panic(struct super_block *s, const char *fmt, ...)
+extern void fat_fs_error(struct super_block *s, const char *fmt, ...)
 	__attribute__ ((format (printf, 2, 3))) __cold;
 extern void fat_clusters_flush(struct super_block *sb);
 extern int fat_chain_add(struct inode *inode, int new_dclus, int nr_cluster);
diff -Nurp kernel-2.6.28-20091602+0m5/fs/fat/file.c kernel-2.6.28-20093908+0m5/fs/fat/file.c
--- kernel-2.6.28-20091602+0m5/fs/fat/file.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/fat/file.c	2012-12-16 13:13:01.716330145 +0100
@@ -213,7 +213,7 @@ static int fat_free(struct inode *inode,
 			fatent_brelse(&fatent);
 			return 0;
 		} else if (ret == FAT_ENT_FREE) {
-			fat_fs_panic(sb,
+			fat_fs_error(sb,
 				     "%s: invalid cluster chain (i_pos %lld)",
 				     __func__, MSDOS_I(inode)->i_pos);
 			ret = -EIO;
diff -Nurp kernel-2.6.28-20091602+0m5/fs/fat/inode.c kernel-2.6.28-20093908+0m5/fs/fat/inode.c
--- kernel-2.6.28-20091602+0m5/fs/fat/inode.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/fat/inode.c	2012-12-16 13:13:01.716330145 +0100
@@ -76,7 +76,7 @@ static inline int __fat_get_block(struct
 		return 0;
 
 	if (iblock != MSDOS_I(inode)->mmu_private >> sb->s_blocksize_bits) {
-		fat_fs_panic(sb, "corrupted file size (i_pos %lld, %lld)",
+		fat_fs_error(sb, "corrupted file size (i_pos %lld, %lld)",
 			MSDOS_I(inode)->i_pos, MSDOS_I(inode)->mmu_private);
 		return -EIO;
 	}
@@ -441,7 +441,7 @@ static void fat_clear_inode(struct inode
 
 static void fat_write_super(struct super_block *sb)
 {
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 
 	if (!(sb->s_flags & MS_RDONLY))
 		fat_clusters_flush(sb);
@@ -828,6 +828,12 @@ static int fat_show_options(struct seq_f
 		seq_puts(m, ",flush");
 	if (opts->tz_utc)
 		seq_puts(m, ",tz=UTC");
+	if (opts->errors == FAT_ERRORS_CONT)
+		seq_puts(m, ",errors=continue");
+	else if (opts->errors == FAT_ERRORS_PANIC)
+		seq_puts(m, ",errors=panic");
+	else
+		seq_puts(m, ",errors=remount-ro");
 
 	return 0;
 }
@@ -840,7 +846,8 @@ enum {
 	Opt_charset, Opt_shortname_lower, Opt_shortname_win95,
 	Opt_shortname_winnt, Opt_shortname_mixed, Opt_utf8_no, Opt_utf8_yes,
 	Opt_uni_xl_no, Opt_uni_xl_yes, Opt_nonumtail_no, Opt_nonumtail_yes,
-	Opt_obsolate, Opt_flush, Opt_tz_utc, Opt_rodir, Opt_err,
+	Opt_obsolate, Opt_flush, Opt_tz_utc, Opt_rodir, Opt_err_cont,
+	Opt_err_panic, Opt_err_ro, Opt_err,
 };
 
 static const match_table_t fat_tokens = {
@@ -876,6 +883,9 @@ static const match_table_t fat_tokens =
 	{Opt_obsolate, "posix"},
 	{Opt_flush, "flush"},
 	{Opt_tz_utc, "tz=UTC"},
+	{Opt_err_cont, "errors=continue"},
+	{Opt_err_panic, "errors=panic"},
+	{Opt_err_ro, "errors=remount-ro"},
 	{Opt_err, NULL},
 };
 static const match_table_t msdos_tokens = {
@@ -945,6 +955,7 @@ static int parse_options(char *options,
 	opts->numtail = 1;
 	opts->usefree = opts->nocase = 0;
 	opts->tz_utc = 0;
+	opts->errors = FAT_ERRORS_RO;
 	*debug = 0;
 
 	if (!options)
@@ -1037,6 +1048,15 @@ static int parse_options(char *options,
 		case Opt_tz_utc:
 			opts->tz_utc = 1;
 			break;
+		case Opt_err_cont:
+			opts->errors = FAT_ERRORS_CONT;
+			break;
+		case Opt_err_panic:
+			opts->errors = FAT_ERRORS_PANIC;
+			break;
+		case Opt_err_ro:
+			opts->errors = FAT_ERRORS_RO;
+			break;
 
 		/* msdos specific */
 		case Opt_dots:
diff -Nurp kernel-2.6.28-20091602+0m5/fs/fat/misc.c kernel-2.6.28-20093908+0m5/fs/fat/misc.c
--- kernel-2.6.28-20091602+0m5/fs/fat/misc.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/fat/misc.c	2012-12-16 13:13:01.716330145 +0100
@@ -12,14 +12,19 @@
 #include "fat.h"
 
 /*
- * fat_fs_panic reports a severe file system problem and sets the file system
- * read-only. The file system can be made writable again by remounting it.
+ * fat_fs_error reports a file system problem that might indicate fa data
+ * corruption/inconsistency. Depending on 'errors' mount option the
+ * panic() is called, or error message is printed FAT and nothing is done,
+ * or filesystem is remounted read-only (default behavior).
+ * In case the file system is remounted read-only, it can be made writable
+ * again by remounting it.
  */
-void fat_fs_panic(struct super_block *s, const char *fmt, ...)
+void fat_fs_error(struct super_block *s, const char *fmt, ...)
 {
 	va_list args;
+	struct msdos_sb_info *sbi = MSDOS_SB(s);
 
-	printk(KERN_ERR "FAT: Filesystem panic (dev %s)\n", s->s_id);
+	printk(KERN_ERR "FAT: Filesystem error (dev %s)\n", s->s_id);
 
 	printk(KERN_ERR "    ");
 	va_start(args, fmt);
@@ -27,13 +32,15 @@ void fat_fs_panic(struct super_block *s,
 	va_end(args);
 	printk("\n");
 
-	if (!(s->s_flags & MS_RDONLY)) {
+	if (sbi->options.errors == FAT_ERRORS_PANIC)
+		panic("    FAT fs panic from previous error\n");
+	if ((sbi->options.errors == FAT_ERRORS_RO) &&
+				!(s->s_flags & MS_RDONLY)) {
 		s->s_flags |= MS_RDONLY;
 		printk(KERN_ERR "    File system has been set read-only\n");
 	}
 }
-
-EXPORT_SYMBOL_GPL(fat_fs_panic);
+EXPORT_SYMBOL_GPL(fat_fs_error);
 
 /* Flushes the number of free clusters on FAT32 */
 /* XXX: Need to write one per FSINFO block.  Currently only writes 1 */
@@ -124,7 +131,7 @@ int fat_chain_add(struct inode *inode, i
 			mark_inode_dirty(inode);
 	}
 	if (new_fclus != (inode->i_blocks >> (sbi->cluster_bits - 9))) {
-		fat_fs_panic(sb, "clusters badly computed (%d != %llu)",
+		fat_fs_error(sb, "clusters badly computed (%d != %llu)",
 			     new_fclus,
 			     (llu)(inode->i_blocks >> (sbi->cluster_bits - 9)));
 		fat_cache_inval_inode(inode);
diff -Nurp kernel-2.6.28-20091602+0m5/fs/fat/namei_msdos.c kernel-2.6.28-20093908+0m5/fs/fat/namei_msdos.c
--- kernel-2.6.28-20091602+0m5/fs/fat/namei_msdos.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/fat/namei_msdos.c	2012-12-16 13:13:01.716330145 +0100
@@ -608,7 +608,7 @@ error_inode:
 		sinfo.bh = NULL;
 	}
 	if (corrupt < 0) {
-		fat_fs_panic(new_dir->i_sb,
+		fat_fs_error(new_dir->i_sb,
 			     "%s: Filesystem corrupted (i_pos %lld)",
 			     __func__, sinfo.i_pos);
 	}
diff -Nurp kernel-2.6.28-20091602+0m5/fs/fat/namei_vfat.c kernel-2.6.28-20093908+0m5/fs/fat/namei_vfat.c
--- kernel-2.6.28-20091602+0m5/fs/fat/namei_vfat.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/fat/namei_vfat.c	2012-12-16 13:13:01.716330145 +0100
@@ -1030,7 +1030,7 @@ error_inode:
 		sinfo.bh = NULL;
 	}
 	if (corrupt < 0) {
-		fat_fs_panic(new_dir->i_sb,
+		fat_fs_error(new_dir->i_sb,
 			     "%s: Filesystem corrupted (i_pos %lld)",
 			     __func__, sinfo.i_pos);
 	}
diff -Nurp kernel-2.6.28-20091602+0m5/fs/fs-writeback.c kernel-2.6.28-20093908+0m5/fs/fs-writeback.c
--- kernel-2.6.28-20091602+0m5/fs/fs-writeback.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/fs-writeback.c	2012-12-16 13:13:01.716330145 +0100
@@ -65,6 +65,24 @@ static void writeback_release(struct bac
 }
 
 /**
+ * enable_pwb - enable periodic write-back after an inode was marked as dirty.
+ * @inode: the inode which was marked as dirty
+ *
+ * This is a helper function for '__mark_inode_dirty()' which enables the
+ * periodic write-back, unless:
+ *   * the backing device @inode belongs to does not support write-back;
+ *   * periodic write-back is already enabled.
+ */
+static void enable_pwb(struct inode *inode)
+{
+	struct backing_dev_info *bdi = inode->i_mapping->backing_dev_info;
+
+	if (bdi_cap_writeback_dirty(bdi) &&
+	    atomic_add_unless(&periodic_wb_enabled, 1, 1))
+		enable_periodic_wb();
+}
+
+/**
  *	__mark_inode_dirty -	internal function
  *	@inode: inode to mark
  *	@flags: what kind of dirty (i.e. I_DIRTY_SYNC)
@@ -164,6 +182,7 @@ void __mark_inode_dirty(struct inode *in
 		if (!was_dirty) {
 			inode->dirtied_when = jiffies;
 			list_move(&inode->i_list, &sb->s_dirty);
+			enable_pwb(inode);
 		}
 	}
 out:
@@ -172,6 +191,28 @@ out:
 
 EXPORT_SYMBOL(__mark_inode_dirty);
 
+/**
+ * mark_sb_dirty - mark super block as dirty.
+ * @sb: the super block to mark as dirty
+ *
+ * This function marks super block @sb as dirty and enables the periodic
+ * write-back, unless it is already enabled. Note, VFS does not serialize the
+ * super block clean/dirty (@sb->s_dirt) state changes, and each FS is
+ * responsible for doing its own serialization.
+ */
+void mark_sb_dirty(struct super_block *sb)
+{
+	sb->s_dirt = 1;
+	/*
+	 * If 'periodic_wb_enabled' is 0, set it to 1 and enable the periodic
+	 * write-back.
+	 */
+	if (atomic_add_unless(&periodic_wb_enabled, 1, 1))
+		enable_periodic_wb();
+}
+
+EXPORT_SYMBOL(mark_sb_dirty);
+
 static int write_inode(struct inode *inode, int sync)
 {
 	if (inode->i_sb->s_op->write_inode && !is_bad_inode(inode))
diff -Nurp kernel-2.6.28-20091602+0m5/fs/gfs2/log.c kernel-2.6.28-20093908+0m5/fs/gfs2/log.c
--- kernel-2.6.28-20091602+0m5/fs/gfs2/log.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/gfs2/log.c	2012-12-16 13:13:01.716330145 +0100
@@ -765,7 +765,7 @@ void __gfs2_log_flush(struct gfs2_sbd *s
 	}
 	gfs2_log_unlock(sdp);
 
-	sdp->sd_vfs->s_dirt = 0;
+	makr_sb_clean(sdp->sd_vfs);
 	up_write(&sdp->sd_log_flush_lock);
 
 	kfree(ai);
@@ -824,7 +824,7 @@ void gfs2_log_commit(struct gfs2_sbd *sd
 	log_refund(sdp, tr);
 	buf_lo_incore_commit(sdp, tr);
 
-	sdp->sd_vfs->s_dirt = 1;
+	mark_sb_dirty(sdp->sd_vfs);
 	up_read(&sdp->sd_log_flush_lock);
 
 	gfs2_log_lock(sdp);
diff -Nurp kernel-2.6.28-20091602+0m5/fs/gfs2/ops_super.c kernel-2.6.28-20093908+0m5/fs/gfs2/ops_super.c
--- kernel-2.6.28-20091602+0m5/fs/gfs2/ops_super.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/gfs2/ops_super.c	2012-12-16 13:13:01.716330145 +0100
@@ -196,7 +196,7 @@ static void gfs2_put_super(struct super_
 
 static void gfs2_write_super(struct super_block *sb)
 {
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 }
 
 /**
@@ -208,7 +208,7 @@ static void gfs2_write_super(struct supe
 
 static int gfs2_sync_fs(struct super_block *sb, int wait)
 {
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 	if (wait && sb->s_fs_info)
 		gfs2_log_flush(sb->s_fs_info, NULL);
 	return 0;
diff -Nurp kernel-2.6.28-20091602+0m5/fs/hfs/extent.c kernel-2.6.28-20093908+0m5/fs/hfs/extent.c
--- kernel-2.6.28-20091602+0m5/fs/hfs/extent.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/hfs/extent.c	2012-12-16 13:13:01.716330145 +0100
@@ -432,7 +432,7 @@ out:
 		if (inode->i_ino < HFS_FIRSTUSER_CNID)
 			set_bit(HFS_FLG_ALT_MDB_DIRTY, &HFS_SB(sb)->flags);
 		set_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);
-		sb->s_dirt = 1;
+		mark_sb_dirty(sb);
 	}
 	return res;
 
diff -Nurp kernel-2.6.28-20091602+0m5/fs/hfs/hfs_fs.h kernel-2.6.28-20093908+0m5/fs/hfs/hfs_fs.h
--- kernel-2.6.28-20091602+0m5/fs/hfs/hfs_fs.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/hfs/hfs_fs.h	2012-12-16 13:13:01.716330145 +0100
@@ -251,7 +251,7 @@ static inline const char *hfs_mdb_name(s
 static inline void hfs_bitmap_dirty(struct super_block *sb)
 {
 	set_bit(HFS_FLG_BITMAP_DIRTY, &HFS_SB(sb)->flags);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 }
 
 static inline void hfs_buffer_sync(struct buffer_head *bh)
diff -Nurp kernel-2.6.28-20091602+0m5/fs/hfs/inode.c kernel-2.6.28-20093908+0m5/fs/hfs/inode.c
--- kernel-2.6.28-20091602+0m5/fs/hfs/inode.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/hfs/inode.c	2012-12-16 13:13:01.716330145 +0100
@@ -194,7 +194,7 @@ struct inode *hfs_new_inode(struct inode
 	insert_inode_hash(inode);
 	mark_inode_dirty(inode);
 	set_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 
 	return inode;
 }
@@ -209,7 +209,7 @@ void hfs_delete_inode(struct inode *inod
 		if (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))
 			HFS_SB(sb)->root_dirs--;
 		set_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);
-		sb->s_dirt = 1;
+		mark_sb_dirty(sb);
 		return;
 	}
 	HFS_SB(sb)->file_count--;
@@ -222,7 +222,7 @@ void hfs_delete_inode(struct inode *inod
 		}
 	}
 	set_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 }
 
 void hfs_inode_read_fork(struct inode *inode, struct hfs_extent *ext,
diff -Nurp kernel-2.6.28-20091602+0m5/fs/hfs/super.c kernel-2.6.28-20093908+0m5/fs/hfs/super.c
--- kernel-2.6.28-20091602+0m5/fs/hfs/super.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/hfs/super.c	2012-12-16 13:13:01.716330145 +0100
@@ -49,7 +49,7 @@ MODULE_LICENSE("GPL");
  */
 static void hfs_write_super(struct super_block *sb)
 {
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 	if (sb->s_flags & MS_RDONLY)
 		return;
 	/* sync everything to the buffers */
diff -Nurp kernel-2.6.28-20091602+0m5/fs/hfsplus/bitmap.c kernel-2.6.28-20093908+0m5/fs/hfsplus/bitmap.c
--- kernel-2.6.28-20091602+0m5/fs/hfsplus/bitmap.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/hfsplus/bitmap.c	2012-12-16 13:13:01.716330145 +0100
@@ -151,7 +151,7 @@ done:
 	kunmap(page);
 	*max = offset + (curr - pptr) * 32 + i - start;
 	HFSPLUS_SB(sb).free_blocks -= *max;
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	dprint(DBG_BITMAP, "-> %u,%u\n", start, *max);
 out:
 	mutex_unlock(&HFSPLUS_SB(sb).alloc_file->i_mutex);
@@ -225,7 +225,7 @@ out:
 	set_page_dirty(page);
 	kunmap(page);
 	HFSPLUS_SB(sb).free_blocks += len;
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	mutex_unlock(&HFSPLUS_SB(sb).alloc_file->i_mutex);
 
 	return 0;
diff -Nurp kernel-2.6.28-20091602+0m5/fs/hfsplus/dir.c kernel-2.6.28-20093908+0m5/fs/hfsplus/dir.c
--- kernel-2.6.28-20091602+0m5/fs/hfsplus/dir.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/hfsplus/dir.c	2012-12-16 13:13:01.716330145 +0100
@@ -305,7 +305,7 @@ static int hfsplus_link(struct dentry *s
 	inode->i_ctime = CURRENT_TIME_SEC;
 	mark_inode_dirty(inode);
 	HFSPLUS_SB(sb).file_count++;
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 
 	return 0;
 }
diff -Nurp kernel-2.6.28-20091602+0m5/fs/hfsplus/inode.c kernel-2.6.28-20093908+0m5/fs/hfsplus/inode.c
--- kernel-2.6.28-20091602+0m5/fs/hfsplus/inode.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/hfsplus/inode.c	2012-12-16 13:13:01.716330145 +0100
@@ -333,7 +333,7 @@ struct inode *hfsplus_new_inode(struct s
 		HFSPLUS_SB(sb).file_count++;
 	insert_inode_hash(inode);
 	mark_inode_dirty(inode);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 
 	return inode;
 }
@@ -344,7 +344,7 @@ void hfsplus_delete_inode(struct inode *
 
 	if (S_ISDIR(inode->i_mode)) {
 		HFSPLUS_SB(sb).folder_count--;
-		sb->s_dirt = 1;
+		mark_sb_dirty(sb);
 		return;
 	}
 	HFSPLUS_SB(sb).file_count--;
@@ -357,7 +357,7 @@ void hfsplus_delete_inode(struct inode *
 		inode->i_size = 0;
 		hfsplus_file_truncate(inode);
 	}
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 }
 
 void hfsplus_inode_read_fork(struct inode *inode, struct hfsplus_fork_raw *fork)
diff -Nurp kernel-2.6.28-20091602+0m5/fs/hfsplus/super.c kernel-2.6.28-20093908+0m5/fs/hfsplus/super.c
--- kernel-2.6.28-20091602+0m5/fs/hfsplus/super.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/hfsplus/super.c	2012-12-16 13:13:01.716330145 +0100
@@ -104,7 +104,7 @@ static int hfsplus_write_inode(struct in
 	case HFSPLUS_EXT_CNID:
 		if (vhdr->ext_file.total_size != cpu_to_be64(inode->i_size)) {
 			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
-			inode->i_sb->s_dirt = 1;
+			mark_sb_dirty(inode->i_sb);
 		}
 		hfsplus_inode_write_fork(inode, &vhdr->ext_file);
 		hfs_btree_write(HFSPLUS_SB(inode->i_sb).ext_tree);
@@ -112,7 +112,7 @@ static int hfsplus_write_inode(struct in
 	case HFSPLUS_CAT_CNID:
 		if (vhdr->cat_file.total_size != cpu_to_be64(inode->i_size)) {
 			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
-			inode->i_sb->s_dirt = 1;
+			mark_sb_dirty(inode->i_sb);
 		}
 		hfsplus_inode_write_fork(inode, &vhdr->cat_file);
 		hfs_btree_write(HFSPLUS_SB(inode->i_sb).cat_tree);
@@ -120,21 +120,21 @@ static int hfsplus_write_inode(struct in
 	case HFSPLUS_ALLOC_CNID:
 		if (vhdr->alloc_file.total_size != cpu_to_be64(inode->i_size)) {
 			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
-			inode->i_sb->s_dirt = 1;
+			mark_sb_dirty(inode->i_sb);
 		}
 		hfsplus_inode_write_fork(inode, &vhdr->alloc_file);
 		break;
 	case HFSPLUS_START_CNID:
 		if (vhdr->start_file.total_size != cpu_to_be64(inode->i_size)) {
 			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
-			inode->i_sb->s_dirt = 1;
+			mark_sb_dirty(inode->i_sb);
 		}
 		hfsplus_inode_write_fork(inode, &vhdr->start_file);
 		break;
 	case HFSPLUS_ATTR_CNID:
 		if (vhdr->attr_file.total_size != cpu_to_be64(inode->i_size)) {
 			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
-			inode->i_sb->s_dirt = 1;
+			mark_sb_dirty(inode->i_sb);
 		}
 		hfsplus_inode_write_fork(inode, &vhdr->attr_file);
 		hfs_btree_write(HFSPLUS_SB(inode->i_sb).attr_tree);
@@ -157,7 +157,7 @@ static void hfsplus_write_super(struct s
 	struct hfsplus_vh *vhdr = HFSPLUS_SB(sb).s_vhdr;
 
 	dprint(DBG_SUPER, "hfsplus_write_super\n");
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 	if (sb->s_flags & MS_RDONLY)
 		/* warn? */
 		return;
diff -Nurp kernel-2.6.28-20091602+0m5/fs/jffs2/fs.c kernel-2.6.28-20093908+0m5/fs/jffs2/fs.c
--- kernel-2.6.28-20091602+0m5/fs/jffs2/fs.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/jffs2/fs.c	2012-12-16 13:13:01.716330145 +0100
@@ -405,7 +405,7 @@ int jffs2_remount_fs (struct super_block
 void jffs2_write_super (struct super_block *sb)
 {
 	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 
 	if (sb->s_flags & MS_RDONLY)
 		return;
diff -Nurp kernel-2.6.28-20091602+0m5/fs/jffs2/os-linux.h kernel-2.6.28-20093908+0m5/fs/jffs2/os-linux.h
--- kernel-2.6.28-20091602+0m5/fs/jffs2/os-linux.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/jffs2/os-linux.h	2012-12-16 13:13:01.716330145 +0100
@@ -147,7 +147,7 @@ void jffs2_nor_wbuf_flash_cleanup(struct
 /* erase.c */
 static inline void jffs2_erase_pending_trigger(struct jffs2_sb_info *c)
 {
-	OFNI_BS_2SFFJ(c)->s_dirt = 1;
+	mark_sb_dirty(OFNI_BS_2SFFJ(c));
 }
 
 /* background.c */
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ocfs2/super.c kernel-2.6.28-20093908+0m5/fs/ocfs2/super.c
--- kernel-2.6.28-20091602+0m5/fs/ocfs2/super.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ocfs2/super.c	2012-12-16 13:13:01.716330145 +0100
@@ -190,7 +190,7 @@ static void ocfs2_write_super(struct sup
 {
 	if (mutex_trylock(&sb->s_lock) != 0)
 		BUG();
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 }
 
 static int ocfs2_sync_fs(struct super_block *sb, int wait)
@@ -199,7 +199,7 @@ static int ocfs2_sync_fs(struct super_bl
 	tid_t target;
 	struct ocfs2_super *osb = OCFS2_SB(sb);
 
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 
 	if (ocfs2_is_hard_readonly(osb))
 		return -EROFS;
diff -Nurp kernel-2.6.28-20091602+0m5/fs/qnx4/inode.c kernel-2.6.28-20093908+0m5/fs/qnx4/inode.c
--- kernel-2.6.28-20091602+0m5/fs/qnx4/inode.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/qnx4/inode.c	2012-12-16 13:13:01.720330146 +0100
@@ -74,7 +74,7 @@ static void qnx4_write_super(struct supe
 {
 	lock_kernel();
 	QNX4DEBUG(("qnx4: write_super\n"));
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 	unlock_kernel();
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/fs/reiserfs/journal.c kernel-2.6.28-20093908+0m5/fs/reiserfs/journal.c
--- kernel-2.6.28-20091602+0m5/fs/reiserfs/journal.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/reiserfs/journal.c	2012-12-16 13:13:01.720330146 +0100
@@ -3251,7 +3251,7 @@ int journal_mark_dirty(struct reiserfs_t
 			       th->t_trans_id, journal->j_trans_id);
 	}
 
-	p_s_sb->s_dirt = 1;
+	mark_sb_dirty(p_s_sb);
 
 	prepared = test_clear_buffer_journal_prepared(bh);
 	clear_buffer_journal_restore_dirty(bh);
@@ -3545,7 +3545,7 @@ int reiserfs_flush_old_commits(struct su
 			do_journal_end(&th, p_s_sb, 1, COMMIT_NOW | WAIT);
 		}
 	}
-	return p_s_sb->s_dirt;
+	return is_sb_dirty(p_s_sb);
 }
 
 /*
@@ -3974,7 +3974,7 @@ static int do_journal_end(struct reiserf
 	 ** it tells us if we should continue with the journal_end, or just return
 	 */
 	if (!check_journal_end(th, p_s_sb, nblocks, flags)) {
-		p_s_sb->s_dirt = 1;
+		mark_sb_dirty(p_s_sb);
 		wake_queued_writers(p_s_sb);
 		reiserfs_async_progress_wait(p_s_sb);
 		goto out;
diff -Nurp kernel-2.6.28-20091602+0m5/fs/reiserfs/resize.c kernel-2.6.28-20093908+0m5/fs/reiserfs/resize.c
--- kernel-2.6.28-20091602+0m5/fs/reiserfs/resize.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/reiserfs/resize.c	2012-12-16 13:13:01.720330146 +0100
@@ -202,7 +202,7 @@ int reiserfs_resize(struct super_block *
 					  (bmap_nr_new - bmap_nr)));
 	PUT_SB_BLOCK_COUNT(s, block_count_new);
 	PUT_SB_BMAP_NR(s, bmap_would_wrap(bmap_nr_new) ? : bmap_nr_new);
-	s->s_dirt = 1;
+	mark_sb_dirty(s);
 
 	journal_mark_dirty(&th, s, SB_BUFFER_WITH_SB(s));
 
diff -Nurp kernel-2.6.28-20091602+0m5/fs/reiserfs/super.c kernel-2.6.28-20093908+0m5/fs/reiserfs/super.c
--- kernel-2.6.28-20091602+0m5/fs/reiserfs/super.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/reiserfs/super.c	2012-12-16 13:13:01.720330146 +0100
@@ -69,11 +69,11 @@ static int reiserfs_sync_fs(struct super
 		if (!journal_begin(&th, s, 1))
 			if (!journal_end_sync(&th, s, 1))
 				reiserfs_flush_old_commits(s);
-		s->s_dirt = 0;	/* Even if it's not true.
-				 * We'll loop forever in sync_supers otherwise */
+		mark_sb_clean(s); /* Even if it's not true.
+				   * We'll loop forever in sync_supers otherwise */
 		reiserfs_write_unlock(s);
 	} else {
-		s->s_dirt = 0;
+		mark_sb_clean(s);
 	}
 	return 0;
 }
@@ -99,7 +99,7 @@ static void reiserfs_write_super_lockfs(
 			journal_end_sync(&th, s, 1);
 		}
 	}
-	s->s_dirt = 0;
+	mark_sb_clean(s);
 	reiserfs_write_unlock(s);
 }
 
@@ -1287,7 +1287,7 @@ static int reiserfs_remount(struct super
 	err = journal_end(&th, s, 10);
 	if (err)
 		goto out_err;
-	s->s_dirt = 0;
+	mark_sb_clean(s);
 
 	if (!(*mount_flags & MS_RDONLY)) {
 		finish_unfinished(s);
diff -Nurp kernel-2.6.28-20091602+0m5/fs/super.c kernel-2.6.28-20093908+0m5/fs/super.c
--- kernel-2.6.28-20091602+0m5/fs/super.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/super.c	2012-12-16 13:13:01.720330146 +0100
@@ -251,7 +251,7 @@ void __fsync_super(struct super_block *s
 	sync_inodes_sb(sb, 0);
 	DQUOT_SYNC(sb);
 	lock_super(sb);
-	if (sb->s_dirt && sb->s_op->write_super)
+	if (is_sb_dirty(sb) && sb->s_op->write_super)
 		sb->s_op->write_super(sb);
 	unlock_super(sb);
 	if (sb->s_op->sync_fs)
@@ -298,7 +298,7 @@ void generic_shutdown_super(struct super
 		invalidate_inodes(sb);
 		lock_kernel();
 
-		if (sop->write_super && sb->s_dirt)
+		if (sop->write_super && is_sb_dirty(sb))
 			sop->write_super(sb);
 		if (sop->put_super)
 			sop->put_super(sb);
@@ -388,7 +388,7 @@ EXPORT_SYMBOL(drop_super);
 static inline void write_super(struct super_block *sb)
 {
 	lock_super(sb);
-	if (sb->s_root && sb->s_dirt)
+	if (sb->s_root && is_sb_dirty(sb))
 		if (sb->s_op->write_super)
 			sb->s_op->write_super(sb);
 	unlock_super(sb);
@@ -406,7 +406,7 @@ void sync_supers(void)
 	spin_lock(&sb_lock);
 restart:
 	list_for_each_entry(sb, &super_blocks, s_list) {
-		if (sb->s_dirt) {
+		if (is_sb_dirty(sb)) {
 			sb->s_count++;
 			spin_unlock(&sb_lock);
 			down_read(&sb->s_umount);
@@ -461,7 +461,7 @@ restart:
 		sb->s_count++;
 		spin_unlock(&sb_lock);
 		down_read(&sb->s_umount);
-		if (sb->s_root && (wait || sb->s_dirt))
+		if (sb->s_root && (wait || is_sb_dirty(sb)))
 			sb->s_op->sync_fs(sb, wait);
 		up_read(&sb->s_umount);
 		/* restart only when sb is no longer on the list */
diff -Nurp kernel-2.6.28-20091602+0m5/fs/sync.c kernel-2.6.28-20093908+0m5/fs/sync.c
--- kernel-2.6.28-20091602+0m5/fs/sync.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/sync.c	2012-12-16 13:13:01.720330146 +0100
@@ -64,7 +64,7 @@ int file_fsync(struct file *filp, struct
 	/* sync the superblock to buffers */
 	sb = inode->i_sb;
 	lock_super(sb);
-	if (sb->s_dirt && sb->s_op->write_super)
+	if (is_sb_dirty(sb) && sb->s_op->write_super)
 		sb->s_op->write_super(sb);
 	unlock_super(sb);
 
diff -Nurp kernel-2.6.28-20091602+0m5/fs/sysv/inode.c kernel-2.6.28-20093908+0m5/fs/sysv/inode.c
--- kernel-2.6.28-20091602+0m5/fs/sysv/inode.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/sysv/inode.c	2012-12-16 13:13:01.720330146 +0100
@@ -30,7 +30,7 @@
 #include <asm/byteorder.h>
 #include "sysv.h"
 
-/* This is only called on sync() and umount(), when s_dirt=1. */
+/* This is only called on sync() and umount(), when the super block is dirty. */
 static void sysv_write_super(struct super_block *sb)
 {
 	struct sysv_sb_info *sbi = SYSV_SB(sb);
@@ -53,7 +53,7 @@ static void sysv_write_super(struct supe
 		mark_buffer_dirty(sbi->s_bh2);
 	}
 clean:
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 	unlock_kernel();
 }
 
@@ -63,7 +63,7 @@ static int sysv_remount(struct super_blo
 	if (sbi->s_forced_ro)
 		*flags |= MS_RDONLY;
 	if (!(*flags & MS_RDONLY))
-		sb->s_dirt = 1;
+		mark_sb_dirty(sb);
 	return 0;
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/fs/sysv/super.c kernel-2.6.28-20093908+0m5/fs/sysv/super.c
--- kernel-2.6.28-20091602+0m5/fs/sysv/super.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/sysv/super.c	2012-12-16 13:13:01.720330146 +0100
@@ -347,7 +347,7 @@ static int complete_read_super(struct su
 		sb->s_flags |= MS_RDONLY;
 	if (sbi->s_truncate)
 		sb->s_root->d_op = &sysv_dentry_operations;
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	return 1;
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/fs/sysv/sysv.h kernel-2.6.28-20093908+0m5/fs/sysv/sysv.h
--- kernel-2.6.28-20091602+0m5/fs/sysv/sysv.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/sysv/sysv.h	2012-12-16 13:13:01.720330146 +0100
@@ -118,7 +118,7 @@ static inline void dirty_sb(struct super
 	mark_buffer_dirty(sbi->s_bh1);
 	if (sbi->s_bh1 != sbi->s_bh2)
 		mark_buffer_dirty(sbi->s_bh2);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 }
 
 
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ubifs/dir.c kernel-2.6.28-20093908+0m5/fs/ubifs/dir.c
--- kernel-2.6.28-20091602+0m5/fs/ubifs/dir.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ubifs/dir.c	2012-12-16 13:13:01.720330146 +0100
@@ -528,6 +528,25 @@ static int ubifs_link(struct dentry *old
 		inode->i_nlink, dir->i_ino);
 	ubifs_assert(mutex_is_locked(&dir->i_mutex));
 	ubifs_assert(mutex_is_locked(&inode->i_mutex));
+
+	/*
+	 * Return -ENOENT if we've raced with unlink and i_nlink is 0.  Doing
+	 * otherwise has the potential to corrupt the orphan inode list.
+	 *
+	 * Indeed, consider a scenario when 'vfs_link(dirA/fileA)' and
+	 * 'vfs_unlink(dirA/fileA, dirB/fileB)' race. 'vfs_link()' does not
+	 * lock 'dirA->i_mutex', so this is possible. Both of the functions
+	 * lock 'fileA->i_mutex' though. Suppose 'vfs_unlink()' wins, and takes
+	 * 'fileA->i_mutex' mutex first. Suppose 'fileA->i_nlink' is 1. In this
+	 * case 'ubifs_unlink()' will drop the last reference, and put 'inodeA'
+	 * to the list of orphans. After this, 'vfs_link()' will link
+	 * 'dirB/fileB' to 'inodeA'. This is a problem because, for example,
+	 * the subsequent 'vfs_unlink(dirB/fileB)' will add the same inode
+	 * to the list of orphans.
+	 */
+	 if (inode->i_nlink == 0)
+		 return -ENOENT;
+
 	err = dbg_check_synced_i_size(inode);
 	if (err)
 		return err;
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ubifs/io.c kernel-2.6.28-20093908+0m5/fs/ubifs/io.c
--- kernel-2.6.28-20091602+0m5/fs/ubifs/io.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ubifs/io.c	2012-12-16 13:13:01.720330146 +0100
@@ -293,13 +293,15 @@ void ubifs_prep_grp_node(struct ubifs_in
  *
  * This function is called when the write-buffer timer expires.
  */
-static void wbuf_timer_callback_nolock(unsigned long data)
+static enum hrtimer_restart wbuf_timer_callback_nolock(struct hrtimer *timer)
 {
-	struct ubifs_wbuf *wbuf = (struct ubifs_wbuf *)data;
+	struct ubifs_wbuf *wbuf = container_of(timer, struct ubifs_wbuf, timer);
 
+	dbg_io("jhead %d", wbuf->jhead);
 	wbuf->need_sync = 1;
 	wbuf->c->need_wbuf_sync = 1;
 	ubifs_wake_up_bgt(wbuf->c);
+	return HRTIMER_NORESTART;
 }
 
 /**
@@ -308,13 +310,16 @@ static void wbuf_timer_callback_nolock(u
  */
 static void new_wbuf_timer_nolock(struct ubifs_wbuf *wbuf)
 {
-	ubifs_assert(!timer_pending(&wbuf->timer));
+	ubifs_assert(!hrtimer_active(&wbuf->timer));
 
-	if (!wbuf->timeout)
+	if (wbuf->no_timer)
 		return;
-
-	wbuf->timer.expires = jiffies + wbuf->timeout;
-	add_timer(&wbuf->timer);
+	dbg_io("set timer for jhead %d, %llu-%llu millisecs", wbuf->jhead,
+	       div_u64(ktime_to_ns(wbuf->softlimit), USEC_PER_SEC),
+	       div_u64(ktime_to_ns(wbuf->softlimit) + wbuf->delta,
+		       USEC_PER_SEC));
+	hrtimer_start_range_ns(&wbuf->timer, wbuf->softlimit, wbuf->delta,
+			       HRTIMER_MODE_REL);
 }
 
 /**
@@ -323,13 +328,10 @@ static void new_wbuf_timer_nolock(struct
  */
 static void cancel_wbuf_timer_nolock(struct ubifs_wbuf *wbuf)
 {
-	/*
-	 * If the syncer is waiting for the lock (from the background thread's
-	 * context) and another task is changing write-buffer then the syncing
-	 * should be canceled.
-	 */
+	if (wbuf->no_timer)
+		return;
 	wbuf->need_sync = 0;
-	del_timer(&wbuf->timer);
+	hrtimer_cancel(&wbuf->timer);
 }
 
 /**
@@ -349,8 +351,8 @@ int ubifs_wbuf_sync_nolock(struct ubifs_
 		/* Write-buffer is empty or not seeked */
 		return 0;
 
-	dbg_io("LEB %d:%d, %d bytes",
-	       wbuf->lnum, wbuf->offs, wbuf->used);
+	dbg_io("LEB %d:%d, %d bytes, jhead %d",
+	       wbuf->lnum, wbuf->offs, wbuf->used, wbuf->jhead);
 	ubifs_assert(!(c->vfs_sb->s_flags & MS_RDONLY));
 	ubifs_assert(!(wbuf->avail & 7));
 	ubifs_assert(wbuf->offs + c->min_io_size <= c->leb_size);
@@ -390,7 +392,7 @@ int ubifs_wbuf_sync_nolock(struct ubifs_
  * @offs: logical eraseblock offset to seek to
  * @dtype: data type
  *
- * This function targets the write buffer to logical eraseblock @lnum:@offs.
+ * This function targets the write-buffer to logical eraseblock @lnum:@offs.
  * The write-buffer is synchronized if it is not empty. Returns zero in case of
  * success and a negative error code in case of failure.
  */
@@ -399,7 +401,7 @@ int ubifs_wbuf_seek_nolock(struct ubifs_
 {
 	const struct ubifs_info *c = wbuf->c;
 
-	dbg_io("LEB %d:%d", lnum, offs);
+	dbg_io("LEB %d:%d, jhead %d", lnum, offs, wbuf->jhead);
 	ubifs_assert(lnum >= 0 && lnum < c->leb_cnt);
 	ubifs_assert(offs >= 0 && offs <= c->leb_size);
 	ubifs_assert(offs % c->min_io_size == 0 && !(offs & 7));
@@ -506,9 +508,9 @@ int ubifs_wbuf_write_nolock(struct ubifs
 	struct ubifs_info *c = wbuf->c;
 	int err, written, n, aligned_len = ALIGN(len, 8), offs;
 
-	dbg_io("%d bytes (%s) to wbuf at LEB %d:%d", len,
-	       dbg_ntype(((struct ubifs_ch *)buf)->node_type), wbuf->lnum,
-	       wbuf->offs + wbuf->used);
+	dbg_io("%d bytes (%s) to jhead %d wbuf at LEB %d:%d", len,
+	       dbg_ntype(((struct ubifs_ch *)buf)->node_type), wbuf->jhead,
+	       wbuf->lnum, wbuf->offs + wbuf->used);
 	ubifs_assert(len > 0 && wbuf->lnum >= 0 && wbuf->lnum < c->leb_cnt);
 	ubifs_assert(wbuf->offs >= 0 && wbuf->offs % c->min_io_size == 0);
 	ubifs_assert(!(wbuf->offs & 7) && wbuf->offs <= c->leb_size);
@@ -533,8 +535,8 @@ int ubifs_wbuf_write_nolock(struct ubifs
 		memcpy(wbuf->buf + wbuf->used, buf, len);
 
 		if (aligned_len == wbuf->avail) {
-			dbg_io("flush wbuf to LEB %d:%d", wbuf->lnum,
-				wbuf->offs);
+			dbg_io("flush jhead %d wbuf to LEB %d:%d",
+			       wbuf->jhead, wbuf->lnum, wbuf->offs);
 			err = ubi_leb_write(c->ubi, wbuf->lnum, wbuf->buf,
 					    wbuf->offs, c->min_io_size,
 					    wbuf->dtype);
@@ -562,7 +564,8 @@ int ubifs_wbuf_write_nolock(struct ubifs
 	 * minimal I/O unit. We have to fill and flush write-buffer and switch
 	 * to the next min. I/O unit.
 	 */
-	dbg_io("flush wbuf to LEB %d:%d", wbuf->lnum, wbuf->offs);
+	dbg_io("flush jhead %d wbuf to LEB %d:%d",
+	       wbuf->jhead, wbuf->lnum, wbuf->offs);
 	memcpy(wbuf->buf + wbuf->used, buf, wbuf->avail);
 	err = ubi_leb_write(c->ubi, wbuf->lnum, wbuf->buf, wbuf->offs,
 			    c->min_io_size, wbuf->dtype);
@@ -695,7 +698,8 @@ int ubifs_read_node_wbuf(struct ubifs_wb
 	int err, rlen, overlap;
 	struct ubifs_ch *ch = buf;
 
-	dbg_io("LEB %d:%d, %s, length %d", lnum, offs, dbg_ntype(type), len);
+	dbg_io("LEB %d:%d, %s, length %d, jhead %d", lnum, offs,
+	       dbg_ntype(type), len, wbuf->jhead);
 	ubifs_assert(wbuf && lnum >= 0 && lnum < c->leb_cnt && offs >= 0);
 	ubifs_assert(!(offs & 7) && offs < c->leb_size);
 	ubifs_assert(type >= 0 && type < UBIFS_NODE_TYPES_CNT);
@@ -819,7 +823,7 @@ out:
  * @c: UBIFS file-system description object
  * @wbuf: write-buffer to initialize
  *
- * This function initializes write buffer. Returns zero in case of success
+ * This function initializes write-buffer. Returns zero in case of success
  * %-ENOMEM in case of failure.
  */
 int ubifs_wbuf_init(struct ubifs_info *c, struct ubifs_wbuf *wbuf)
@@ -845,20 +849,21 @@ int ubifs_wbuf_init(struct ubifs_info *c
 	wbuf->sync_callback = NULL;
 	mutex_init(&wbuf->io_mutex);
 	spin_lock_init(&wbuf->lock);
-
 	wbuf->c = c;
-	init_timer(&wbuf->timer);
-	wbuf->timer.function = wbuf_timer_callback_nolock;
-	wbuf->timer.data = (unsigned long)wbuf;
-	wbuf->timeout = DEFAULT_WBUF_TIMEOUT;
 	wbuf->next_ino = 0;
 
+	hrtimer_init(&wbuf->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	wbuf->timer.function = wbuf_timer_callback_nolock;
+	wbuf->softlimit = ktime_set(WBUF_TIMEOUT_SOFTLIMIT, 0);
+	wbuf->delta = WBUF_TIMEOUT_HARDLIMIT - WBUF_TIMEOUT_SOFTLIMIT;
+	wbuf->delta *= 1000000000ULL;
+	ubifs_assert(wbuf->delta <= ULONG_MAX);
 	return 0;
 }
 
 /**
  * ubifs_wbuf_add_ino_nolock - add an inode number into the wbuf inode array.
- * @wbuf: the write-buffer whereto add
+ * @wbuf: the write-buffer where to add
  * @inum: the inode number
  *
  * This function adds an inode number to the inode array of the write-buffer.
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ubifs/replay.c kernel-2.6.28-20093908+0m5/fs/ubifs/replay.c
--- kernel-2.6.28-20091602+0m5/fs/ubifs/replay.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ubifs/replay.c	2012-12-16 13:13:01.724330146 +0100
@@ -957,7 +957,7 @@ out:
 	return err;
 
 out_dump:
-	ubifs_err("log error detected while replying the log at LEB %d:%d",
+	ubifs_err("log error detected while replaying the log at LEB %d:%d",
 		  lnum, offs + snod->offs);
 	dbg_dump_node(c, snod->node);
 	ubifs_scan_destroy(sleb);
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ubifs/super.c kernel-2.6.28-20093908+0m5/fs/ubifs/super.c
--- kernel-2.6.28-20091602+0m5/fs/ubifs/super.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ubifs/super.c	2012-12-16 13:13:01.724330146 +0100
@@ -796,7 +796,7 @@ static int alloc_wbufs(struct ubifs_info
 	 * does not need to be synchronized by timer.
 	 */
 	c->jheads[GCHD].wbuf.dtype = UBI_LONGTERM;
-	c->jheads[GCHD].wbuf.timeout = 0;
+	c->jheads[GCHD].wbuf.no_timer = 1;
 
 	return 0;
 }
@@ -964,7 +964,7 @@ static int ubifs_parse_options(struct ub
 		switch (token) {
 		/*
 		 * %Opt_fast_unmount and %Opt_norm_unmount options are ignored.
-		 * We accepte them in order to be backware-compatible. But this
+		 * We accept them in order to be backward-compatible. But this
 		 * should be removed at some point.
 		 */
 		case Opt_fast_unmount:
@@ -1646,7 +1646,7 @@ static void ubifs_remount_ro(struct ubif
 
 	for (i = 0; i < c->jhead_cnt; i++) {
 		ubifs_wbuf_sync(&c->jheads[i].wbuf);
-		del_timer_sync(&c->jheads[i].wbuf.timer);
+		hrtimer_cancel(&c->jheads[i].wbuf.timer);
 	}
 
 	c->mst_node->flags &= ~cpu_to_le32(UBIFS_MST_DIRTY);
@@ -1704,10 +1704,8 @@ static void ubifs_put_super(struct super
 
 		/* Synchronize write-buffers */
 		if (c->jheads)
-			for (i = 0; i < c->jhead_cnt; i++) {
+			for (i = 0; i < c->jhead_cnt; i++)
 				ubifs_wbuf_sync(&c->jheads[i].wbuf);
-				del_timer_sync(&c->jheads[i].wbuf.timer);
-			}
 
 		/*
 		 * On fatal errors c->ro_media is set to 1, in which case we do
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ubifs/ubifs.h kernel-2.6.28-20093908+0m5/fs/ubifs/ubifs.h
--- kernel-2.6.28-20091602+0m5/fs/ubifs/ubifs.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ubifs/ubifs.h	2012-12-16 13:13:01.724330146 +0100
@@ -95,8 +95,9 @@
  */
 #define BGT_NAME_PATTERN "ubifs_bgt%d_%d"
 
-/* Default write-buffer synchronization timeout (5 secs) */
-#define DEFAULT_WBUF_TIMEOUT (5 * HZ)
+/* Write-buffer synchronization timeout interval in seconds */
+#define WBUF_TIMEOUT_SOFTLIMIT 3
+#define WBUF_TIMEOUT_HARDLIMIT 5
 
 /* Maximum possible inode number (only 32-bit inodes are supported now) */
 #define MAX_INUM 0xFFFFFFFF
@@ -650,9 +651,12 @@ typedef int (*ubifs_lpt_scan_callback)(s
  * @io_mutex: serializes write-buffer I/O
  * @lock: serializes @buf, @lnum, @offs, @avail, @used, @next_ino and @inodes
  *        fields
+ * @softlimit: soft write-buffer timeout interval
+ * @delta: hard and soft timeouts delta (the timer expire inteval is @softlimit
+ *         and @softlimit + @delta)
  * @timer: write-buffer timer
- * @timeout: timer expire interval in jiffies
- * @need_sync: it is set if its timer expired and needs sync
+ * @no_timer: non-zero if this write-buffer does not have a timer
+ * @need_sync: non-zero if the timer expired and the wbuf needs sync'ing
  * @next_ino: points to the next position of the following inode number
  * @inodes: stores the inode numbers of the nodes which are in wbuf
  *
@@ -678,9 +682,11 @@ struct ubifs_wbuf {
 	int (*sync_callback)(struct ubifs_info *c, int lnum, int free, int pad);
 	struct mutex io_mutex;
 	spinlock_t lock;
-	struct timer_list timer;
-	int timeout;
-	int need_sync;
+	ktime_t softlimit;
+	unsigned long long delta;
+	struct hrtimer timer;
+	unsigned int no_timer:1;
+	unsigned int need_sync:1;
 	int next_ino;
 	ino_t *inodes;
 };
diff -Nurp kernel-2.6.28-20091602+0m5/fs/udf/balloc.c kernel-2.6.28-20093908+0m5/fs/udf/balloc.c
--- kernel-2.6.28-20091602+0m5/fs/udf/balloc.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/udf/balloc.c	2012-12-16 13:13:01.724330146 +0100
@@ -218,7 +218,7 @@ static void udf_bitmap_free_blocks(struc
 	} while (overflow);
 
 error_return:
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	if (sbi->s_lvid_bh)
 		mark_buffer_dirty(sbi->s_lvid_bh);
 	mutex_unlock(&sbi->s_alloc_mutex);
@@ -279,7 +279,7 @@ static int udf_bitmap_prealloc_blocks(st
 out:
 	if (udf_add_free_space(sbi, partition, -alloc_count))
 		mark_buffer_dirty(sbi->s_lvid_bh);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	mutex_unlock(&sbi->s_alloc_mutex);
 	return alloc_count;
 }
@@ -411,7 +411,7 @@ got_block:
 
 	if (udf_add_free_space(sbi, partition, -1))
 		mark_buffer_dirty(sbi->s_lvid_bh);
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	mutex_unlock(&sbi->s_alloc_mutex);
 	*err = 0;
 	return newblock;
@@ -653,7 +653,7 @@ static void udf_table_free_blocks(struct
 	brelse(oepos.bh);
 
 error_return:
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	mutex_unlock(&sbi->s_alloc_mutex);
 	return;
 }
@@ -720,7 +720,7 @@ static int udf_table_prealloc_blocks(str
 
 	if (alloc_count && udf_add_free_space(sbi, partition, -alloc_count)) {
 		mark_buffer_dirty(sbi->s_lvid_bh);
-		sb->s_dirt = 1;
+		mark_sb_dirty(sb);
 	}
 	mutex_unlock(&sbi->s_alloc_mutex);
 	return alloc_count;
@@ -822,7 +822,7 @@ static int udf_table_new_block(struct su
 	if (udf_add_free_space(sbi, partition, -1))
 		mark_buffer_dirty(sbi->s_lvid_bh);
 
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	mutex_unlock(&sbi->s_alloc_mutex);
 	*err = 0;
 	return newblock;
diff -Nurp kernel-2.6.28-20091602+0m5/fs/udf/super.c kernel-2.6.28-20093908+0m5/fs/udf/super.c
--- kernel-2.6.28-20091602+0m5/fs/udf/super.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/udf/super.c	2012-12-16 13:13:01.724330146 +0100
@@ -546,7 +546,7 @@ static void udf_write_super(struct super
 
 	if (!(sb->s_flags & MS_RDONLY))
 		udf_open_lvid(sb);
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 
 	unlock_kernel();
 }
@@ -1924,7 +1924,7 @@ static int udf_fill_super(struct super_b
 	sb->s_op = &udf_sb_ops;
 	sb->s_export_op = &udf_export_ops;
 	sb->dq_op = NULL;
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 	sb->s_magic = UDF_SUPER_MAGIC;
 	sb->s_time_gran = 1000;
 
@@ -2037,7 +2037,7 @@ static void udf_error(struct super_block
 
 	if (!(sb->s_flags & MS_RDONLY)) {
 		/* mark sb error */
-		sb->s_dirt = 1;
+		mark_sb_dirty(sb);
 	}
 	va_start(args, fmt);
 	vsnprintf(error_buf, sizeof(error_buf), fmt, args);
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ufs/balloc.c kernel-2.6.28-20093908+0m5/fs/ufs/balloc.c
--- kernel-2.6.28-20091602+0m5/fs/ufs/balloc.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ufs/balloc.c	2012-12-16 13:13:01.728330146 +0100
@@ -122,7 +122,7 @@ void ufs_free_fragments(struct inode *in
 		ubh_ll_rw_block(SWRITE, UCPI_UBH(ucpi));
 		ubh_wait_on_buffer (UCPI_UBH(ucpi));
 	}
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	
 	unlock_super (sb);
 	UFSD("EXIT\n");
@@ -223,7 +223,7 @@ do_more:
 		goto do_more;
 	}
 
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	unlock_super (sb);
 	UFSD("EXIT\n");
 	return;
@@ -571,7 +571,7 @@ static u64 ufs_add_fragments(struct inod
 		ubh_ll_rw_block(SWRITE, UCPI_UBH(ucpi));
 		ubh_wait_on_buffer (UCPI_UBH(ucpi));
 	}
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 
 	UFSD("EXIT, fragment %llu\n", (unsigned long long)fragment);
 	
@@ -698,7 +698,7 @@ succed:
 		ubh_ll_rw_block(SWRITE, UCPI_UBH(ucpi));
 		ubh_wait_on_buffer (UCPI_UBH(ucpi));
 	}
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 
 	result += cgno * uspi->s_fpg;
 	UFSD("EXIT3, result %llu\n", (unsigned long long)result);
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ufs/ialloc.c kernel-2.6.28-20093908+0m5/fs/ufs/ialloc.c
--- kernel-2.6.28-20091602+0m5/fs/ufs/ialloc.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ufs/ialloc.c	2012-12-16 13:13:01.728330146 +0100
@@ -124,7 +124,7 @@ void ufs_free_inode (struct inode * inod
 		ubh_wait_on_buffer (UCPI_UBH(ucpi));
 	}
 	
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	unlock_super (sb);
 	UFSD("EXIT\n");
 }
@@ -300,7 +300,7 @@ cg_found:
 		ubh_ll_rw_block(SWRITE, UCPI_UBH(ucpi));
 		ubh_wait_on_buffer (UCPI_UBH(ucpi));
 	}
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 
 	inode->i_ino = cg * uspi->s_ipg + bit;
 	inode->i_mode = mode;
diff -Nurp kernel-2.6.28-20091602+0m5/fs/ufs/super.c kernel-2.6.28-20093908+0m5/fs/ufs/super.c
--- kernel-2.6.28-20091602+0m5/fs/ufs/super.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/ufs/super.c	2012-12-16 13:13:01.728330146 +0100
@@ -237,7 +237,7 @@ void ufs_error (struct super_block * sb,
 	if (!(sb->s_flags & MS_RDONLY)) {
 		usb1->fs_clean = UFS_FSBAD;
 		ubh_mark_buffer_dirty(USPI_UBH(uspi));
-		sb->s_dirt = 1;
+		mark_sb_dirty(sb);
 		sb->s_flags |= MS_RDONLY;
 	}
 	va_start (args, fmt);
@@ -269,7 +269,7 @@ void ufs_panic (struct super_block * sb,
 	if (!(sb->s_flags & MS_RDONLY)) {
 		usb1->fs_clean = UFS_FSBAD;
 		ubh_mark_buffer_dirty(USPI_UBH(uspi));
-		sb->s_dirt = 1;
+		mark_sb_dirty(sb);
 	}
 	va_start (args, fmt);
 	vsnprintf (error_buf, sizeof(error_buf), fmt, args);
@@ -1130,7 +1130,7 @@ static void ufs_write_super(struct super
 					UFS_FSOK - fs32_to_cpu(sb, usb1->fs_time));
 		ufs_put_cstotal(sb);
 	}
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 	UFSD("EXIT\n");
 	unlock_kernel();
 }
@@ -1199,7 +1199,7 @@ static int ufs_remount (struct super_blo
 			ufs_set_fs_state(sb, usb1, usb3,
 				UFS_FSOK - fs32_to_cpu(sb, usb1->fs_time));
 		ubh_mark_buffer_dirty (USPI_UBH(uspi));
-		sb->s_dirt = 0;
+		mark_sb_clean(sb);
 		sb->s_flags |= MS_RDONLY;
 	} else {
 	/*
diff -Nurp kernel-2.6.28-20091602+0m5/fs/xfs/linux-2.6/xfs_super.c kernel-2.6.28-20093908+0m5/fs/xfs/linux-2.6/xfs_super.c
--- kernel-2.6.28-20091602+0m5/fs/xfs/linux-2.6/xfs_super.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/xfs/linux-2.6/xfs_super.c	2012-12-16 13:13:01.728330146 +0100
@@ -1162,7 +1162,7 @@ xfs_fs_write_super(
 {
 	if (!(sb->s_flags & MS_RDONLY))
 		xfs_sync(XFS_M(sb), SYNC_FSDATA);
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 }
 
 STATIC int
@@ -1200,7 +1200,7 @@ xfs_fs_sync_super(
 		flags = SYNC_FSDATA;
 
 	error = xfs_sync(mp, flags);
-	sb->s_dirt = 0;
+	mark_sb_clean(sb);
 
 	if (unlikely(laptop_mode)) {
 		int	prev_sync_seq = mp->m_sync_seq;
@@ -1749,7 +1749,7 @@ xfs_fs_fill_super(
 
 	XFS_SEND_MOUNT(mp, DM_RIGHT_NULL, args->mtpt, args->fsname);
 
-	sb->s_dirt = 1;
+	mark_sb_dirty(sb);
 	sb->s_magic = XFS_SB_MAGIC;
 	sb->s_blocksize = mp->m_sb.sb_blocksize;
 	sb->s_blocksize_bits = ffs(sb->s_blocksize) - 1;
diff -Nurp kernel-2.6.28-20091602+0m5/fs/xfs/xfs_trans.c kernel-2.6.28-20093908+0m5/fs/xfs/xfs_trans.c
--- kernel-2.6.28-20091602+0m5/fs/xfs/xfs_trans.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/fs/xfs/xfs_trans.c	2012-12-16 13:13:01.728330146 +0100
@@ -629,7 +629,7 @@ xfs_trans_apply_sb_deltas(
 				  offsetof(xfs_dsb_t, sb_frextents) +
 				  sizeof(sbp->sb_frextents) - 1);
 
-	tp->t_mountp->m_super->s_dirt = 1;
+	mark_sb_dirty(tp->t_mountp->m_super);
 }
 
 /*
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/clockchips.h kernel-2.6.28-20093908+0m5/include/linux/clockchips.h
--- kernel-2.6.28-20091602+0m5/include/linux/clockchips.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/clockchips.h	2012-12-16 13:13:01.728330146 +0100
@@ -76,7 +76,7 @@ enum clock_event_nofitiers {
 struct clock_event_device {
 	const char		*name;
 	unsigned int		features;
-	unsigned long		max_delta_ns;
+	unsigned long long	max_delta_ns;
 	unsigned long		min_delta_ns;
 	unsigned long		mult;
 	int			shift;
@@ -115,7 +115,7 @@ static inline unsigned long div_sc(unsig
 }
 
 /* Clock event layer functions */
-extern unsigned long clockevent_delta2ns(unsigned long latch,
+extern unsigned long long clockevent_delta2ns(unsigned long latch,
 					 struct clock_event_device *evt);
 extern void clockevents_register_device(struct clock_event_device *dev);
 
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/fs.h kernel-2.6.28-20093908+0m5/include/linux/fs.h
--- kernel-2.6.28-20091602+0m5/include/linux/fs.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/fs.h	2012-12-16 13:13:01.728330146 +0100
@@ -1580,6 +1580,19 @@ extern int get_sb_pseudo(struct file_sys
 extern int simple_set_mnt(struct vfsmount *mnt, struct super_block *sb);
 int __put_super_and_need_restart(struct super_block *sb);
 
+extern atomic_t periodic_wb_enabled;
+extern void enable_periodic_wb(void);
+/* Note, VFS does not protect the super block clean/dirty state */
+extern void mark_sb_dirty(struct super_block *sb);
+static inline void mark_sb_clean(struct super_block *sb)
+{
+	sb->s_dirt = 0;
+}
+static inline int is_sb_dirty(const struct super_block *sb)
+{
+	return sb->s_dirt;
+}
+
 /* Alas, no aliases. Too much hassle with bringing module.h everywhere */
 #define fops_get(fops) \
 	(((fops) && try_module_get((fops)->owner) ? (fops) : NULL))
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/i2c/tsl2563.h kernel-2.6.28-20093908+0m5/include/linux/i2c/tsl2563.h
--- kernel-2.6.28-20091602+0m5/include/linux/i2c/tsl2563.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/i2c/tsl2563.h	2012-12-16 13:13:01.728330146 +0100
@@ -0,0 +1,9 @@
+#ifndef __LINUX_TSL2563_H
+#define __LINUX_TSL2563_H
+
+struct tsl2563_platform_data {
+	int cover_comp_gain;
+};
+
+#endif /* __LINUX_TSL2563_H */
+
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/i2c/twl4030.h kernel-2.6.28-20093908+0m5/include/linux/i2c/twl4030.h
--- kernel-2.6.28-20091602+0m5/include/linux/i2c/twl4030.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/i2c/twl4030.h	2012-12-16 13:13:01.728330146 +0100
@@ -294,6 +294,7 @@ int twl4030_i2c_read(u8 mod_no, u8 *valu
 #define MSG_SINGULAR(devgrp, id, state) \
 	((devgrp) << 13 | 0 << 12 | (id) << 4 | (state))
 
+
 /*----------------------------------------------------------------------*/
 
 struct twl4030_bci_platform_data {
@@ -355,14 +356,26 @@ struct twl4030_ins {
 	u8 delay;
 };
 
+#define MAX_EVENTS 4
+
+enum twl4030_event {
+	TRITON_SLEEP 	= 1,
+	TRITON_WAKEUP12 = 2,
+	TRITON_WAKEUP3  = 3,
+	TRITON_WRST 	= 4,
+};
+
+struct twl4030_script_event {
+	/* offset from the start of the script allow overlapping */
+	u8 offset;
+	enum twl4030_event event;
+};
+
 struct twl4030_script {
 	struct twl4030_ins *script;
 	unsigned size;
-	u8 flags;
-#define TRITON_WRST_SCRIPT	(1<<0)
-#define TRITON_WAKEUP12_SCRIPT	(1<<1)
-#define TRITON_WAKEUP3_SCRIPT	(1<<2)
-#define TRITON_SLEEP_SCRIPT	(1<<3)
+	unsigned number_of_events;
+	struct twl4030_script_event events[MAX_EVENTS];
 };
 
 struct twl4030_resconfig {
@@ -370,6 +383,7 @@ struct twl4030_resconfig {
 	int devgroup;
 	int type;
 	int type2;
+	int remap;
 };
 
 struct twl4030_power_data {
@@ -425,6 +439,10 @@ int twl4030_sih_setup(int module);
 #define TWL4030_VAUX4_TYPE		0x24
 #define TWL4030_VAUX4_REMAP		0x25
 #define TWL4030_VAUX4_DEDICATED		0x26
+#define TWL4030_VMMC2_DEV_GRP		0x2b
+#define TWL4030_VMMC2_TYPE		0x2c
+#define TWL4030_VMMC2_REMAP		0x2d
+#define TWL4030_VMMC2_DEDICATED		0x2e
 
 #if defined(CONFIG_TWL4030_BCI_BATTERY) || \
 	defined(CONFIG_TWL4030_BCI_BATTERY_MODULE)
@@ -467,4 +485,6 @@ int twl4030_sih_setup(int module);
 #define TWL4030_REG_VUSB1V8	18
 #define TWL4030_REG_VUSB3V1	19
 
+extern int twl4030_enable_regulator(int res);
+extern int twl4030_disable_regulator(int res);
 #endif /* End of __TWL4030_H */
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/mmc/card.h kernel-2.6.28-20093908+0m5/include/linux/mmc/card.h
--- kernel-2.6.28-20091602+0m5/include/linux/mmc/card.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/mmc/card.h	2012-12-16 13:13:01.728330146 +0100
@@ -40,6 +40,8 @@ struct mmc_csd {
 };
 
 struct mmc_ext_csd {
+	u8			rev;
+	unsigned int		sa_timeout;		/* Units: 100ns */
 	unsigned int		hs_max_dtr;
 	unsigned int		sectors;
 };
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/mmc/core.h kernel-2.6.28-20093908+0m5/include/linux/mmc/core.h
--- kernel-2.6.28-20091602+0m5/include/linux/mmc/core.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/mmc/core.h	2012-12-16 13:13:01.728330146 +0100
@@ -139,6 +139,7 @@ extern unsigned int mmc_align_data_size(
 
 extern int __mmc_claim_host(struct mmc_host *host, atomic_t *abort);
 extern void mmc_release_host(struct mmc_host *host);
+extern int mmc_try_claim_host(struct mmc_host *host);
 
 /**
  *	mmc_claim_host - exclusively claim a host
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/mmc/host.h kernel-2.6.28-20093908+0m5/include/linux/mmc/host.h
--- kernel-2.6.28-20091602+0m5/include/linux/mmc/host.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/mmc/host.h	2012-12-16 13:13:01.728330146 +0100
@@ -51,6 +51,35 @@ struct mmc_ios {
 };
 
 struct mmc_host_ops {
+	/*
+	 * Hosts that support power saving can use the 'enable' and 'disable'
+	 * methods to exit and enter power saving states. 'enable' is called
+	 * when the host is claimed and 'disable' is called (or scheduled with
+	 * a delay) when the host is released. The 'disable' is scheduled if
+	 * the disable delay set by 'mmc_set_disable_delay()' is non-zero,
+	 * otherwise 'disable' is called immediately. 'disable' may be
+	 * scheduled repeatedly, to permit ever greater power saving at the
+	 * expense of ever greater latency to re-enable. Rescheduling is
+	 * determined by the return value of the 'disable' method. A positive
+	 * value gives the delay in jiffies.
+	 *
+	 * In the case where a host function (like set_ios) may be called
+	 * with or without the host claimed, enabling and disabling can be
+	 * done directly and will nest correctly. Call 'mmc_host_enable()' and
+	 * 'mmc_host_lazy_disable()' for this purpose, but note that these
+	 * functions must be paired.
+	 *
+	 * Alternatively, 'mmc_host_enable()' may be paired with
+	 * 'mmc_host_disable()' which calls 'disable' immediately.  In this
+	 * case the 'disable' method will be called with 'lazy' set to 0.
+	 * This is mainly useful for error paths.
+	 *
+	 * Because lazy disble may be called from a work queue, the 'disable'
+	 * method must claim the host when 'lazy' != 0, which will work
+	 * correctly because recursion is detected and handled.
+	 */
+	int (*enable)(struct mmc_host *host);
+	int (*disable)(struct mmc_host *host, int lazy);
 	void	(*request)(struct mmc_host *host, struct mmc_request *req);
 	/*
 	 * Avoid calling these three functions too often or in a "fast path",
@@ -118,6 +147,15 @@ struct mmc_host {
 #define MMC_CAP_SPI		(1 << 4)	/* Talks only SPI protocols */
 #define MMC_CAP_NEEDS_POLL	(1 << 5)	/* Needs polling for card-detection */
 #define MMC_CAP_8_BIT_DATA	(1 << 6)	/* Can the host do 8 bit transfers */
+#define MMC_CAP_DISABLE		(1 << 7)	/* Can the host be disabled */
+#define MMC_CAP_NONREMOVABLE	(1 << 8)	/* Nonremovable e.g. eMMC */
+#define MMC_CAP_NOT_SDIO	(1 << 9)	/* Card cannot be SDIO */
+#define MMC_CAP_NOT_SD		(1 << 10)	/* Card cannot be SD */
+#define MMC_CAP_NOT_MMC		(1 << 11)	/* Card cannot be MMC */
+
+#define MMC_CAP_SDIO_ONLY	(MMC_CAP_NOT_SD | MMC_CAP_NOT_MMC)
+#define MMC_CAP_SD_ONLY		(MMC_CAP_NOT_SDIO | MMC_CAP_NOT_MMC)
+#define MMC_CAP_MMC_ONLY	(MMC_CAP_NOT_SDIO | MMC_CAP_NOT_SD)
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
@@ -142,9 +180,18 @@ struct mmc_host {
 	unsigned int		removed:1;	/* host is being removed */
 #endif
 
+	/* Only used with MMC_CAP_DISABLE */
+	int			enabled;	/* host is enabled */
+	int			nesting_cnt;	/* "enable" nesting count */
+	int			en_dis_recurs;	/* detect recursion */
+	unsigned int 		disable_delay;	/* disable delay in msecs */
+	struct delayed_work	disable;	/* disabling work */
+
 	struct mmc_card		*card;		/* device attached to this host */
 
 	wait_queue_head_t	wq;
+	struct task_struct	*claimer;	/* task that has host claimed */
+	int			claim_cnt;	/* "claim" nesting count */
 
 	struct delayed_work	detect;
 
@@ -183,6 +230,9 @@ static inline void *mmc_priv(struct mmc_
 extern int mmc_suspend_host(struct mmc_host *, pm_message_t);
 extern int mmc_resume_host(struct mmc_host *);
 
+extern void mmc_power_save_host(struct mmc_host *host);
+extern void mmc_power_restore_host(struct mmc_host *host);
+
 extern void mmc_detect_change(struct mmc_host *, unsigned long delay);
 extern void mmc_request_done(struct mmc_host *, struct mmc_request *);
 
@@ -192,5 +242,19 @@ static inline void mmc_signal_sdio_irq(s
 	wake_up_process(host->sdio_irq_thread);
 }
 
+int mmc_card_awake(struct mmc_host *host);
+int mmc_card_sleep(struct mmc_host *host);
+int mmc_card_can_sleep(struct mmc_host *host);
+
+int mmc_host_enable(struct mmc_host *host);
+int mmc_host_disable(struct mmc_host *host);
+int mmc_host_lazy_disable(struct mmc_host *host);
+
+static inline void mmc_set_disable_delay(struct mmc_host *host,
+					 unsigned int disable_delay)
+{
+	host->disable_delay = disable_delay;
+}
+
 #endif
 
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/mmc/mmc.h kernel-2.6.28-20093908+0m5/include/linux/mmc/mmc.h
--- kernel-2.6.28-20091602+0m5/include/linux/mmc/mmc.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/mmc/mmc.h	2012-12-16 13:13:01.728330146 +0100
@@ -31,6 +31,7 @@
 #define MMC_ALL_SEND_CID          2   /* bcr                     R2  */
 #define MMC_SET_RELATIVE_ADDR     3   /* ac   [31:16] RCA        R1  */
 #define MMC_SET_DSR               4   /* bc   [31:16] RCA            */
+#define MMC_SLEEP_AWAKE		  5   /* ac   [31:16] RCA 15:flg R1b */
 #define MMC_SWITCH                6   /* ac   [31:0] See below   R1b */
 #define MMC_SELECT_CARD           7   /* ac   [31:16] RCA        R1  */
 #define MMC_SEND_EXT_CSD          8   /* adtc                    R1  */
@@ -127,6 +128,7 @@
 #define R1_STATUS(x)            (x & 0xFFFFE000)
 #define R1_CURRENT_STATE(x)	((x & 0x00001E00) >> 9)	/* sx, b (4 bits) */
 #define R1_READY_FOR_DATA	(1 << 8)	/* sx, a */
+#define R1_SWITCH_ERROR		(1 << 7)	/* sx, c */
 #define R1_APP_CMD		(1 << 5)	/* sr, c */
 
 /*
@@ -254,6 +256,7 @@ struct _mmc_csd {
 #define EXT_CSD_CARD_TYPE	196	/* RO */
 #define EXT_CSD_REV		192	/* RO */
 #define EXT_CSD_SEC_CNT		212	/* RO, 4 bytes */
+#define EXT_CSD_S_A_TIMEOUT	217
 
 /*
  * EXT_CSD field definitions
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/mtd/mtd.h kernel-2.6.28-20093908+0m5/include/linux/mtd/mtd.h
--- kernel-2.6.28-20091602+0m5/include/linux/mtd/mtd.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/mtd/mtd.h	2012-12-16 13:13:01.728330146 +0100
@@ -219,6 +219,14 @@ struct mtd_info {
 	 * supposed to be called by MTD users */
 	int (*get_device) (struct mtd_info *mtd);
 	void (*put_device) (struct mtd_info *mtd);
+
+	uint32_t read_cnt;
+	uint32_t read_sz;
+	uint32_t write_cnt;
+	uint32_t write_sz;
+	uint32_t erase_cnt;
+	uint32_t erase_sz;
+	uint32_t other_cnt;
 };
 
 
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/mtd/onenand.h kernel-2.6.28-20093908+0m5/include/linux/mtd/onenand.h
--- kernel-2.6.28-20091602+0m5/include/linux/mtd/onenand.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/mtd/onenand.h	2012-12-16 13:13:01.728330146 +0100
@@ -176,6 +176,7 @@ struct onenand_chip {
  * OneNAND Flash Manufacturer ID Codes
  */
 #define ONENAND_MFR_SAMSUNG	0xec
+#define ONENAND_MFR_NUMONYX	0x20
 
 /**
  * struct onenand_manufacturers - NAND Flash Manufacturer ID Structure
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/omapfb.h kernel-2.6.28-20093908+0m5/include/linux/omapfb.h
--- kernel-2.6.28-20091602+0m5/include/linux/omapfb.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/omapfb.h	2012-12-16 13:13:01.728330146 +0100
@@ -22,6 +22,8 @@
 #ifndef __OMAPFB_H
 #define __OMAPFB_H
 
+#include <linux/fb.h>
+
 #include <asm/ioctl.h>
 #include <asm/types.h>
 
@@ -50,6 +52,8 @@
 #define OMAPFB_QUERY_MEM	OMAP_IOW(56, struct omapfb_mem_info)
 #define OMAPFB_WAITFORVSYNC	OMAP_IO(57)
 #define OMAPFB_MEMORY_READ	OMAP_IOR(58, struct omapfb_memory_read)
+#define OMAPFB_GET_OVERLAY_COLORMODE	OMAP_IOR(59, struct omapfb_ovl_colormode)
+#define OMAPFB_GET_VRAM_INFO	OMAP_IOR(61, struct omapfb_vram_info)
 
 #define OMAPFB_CAPS_GENERIC_MASK	0x00000fff
 #define OMAPFB_CAPS_LCDC_MASK		0x00fff000
@@ -182,11 +186,28 @@ struct omapfb_memory_read {
 	void __user *buffer;
 };
 
+struct omapfb_ovl_colormode {
+	__u8 overlay_idx;
+	__u8 mode_idx;
+	__u32 bits_per_pixel;
+	__u32 nonstd;
+	struct fb_bitfield red;
+	struct fb_bitfield green;
+	struct fb_bitfield blue;
+	struct fb_bitfield transp;
+};
+
+struct omapfb_vram_info {
+	__u32 total;
+	__u32 free;
+	__u32 largest_free_block;
+	__u32 reserved[5];
+};
+
 #ifdef __KERNEL__
 
 #include <linux/completion.h>
 #include <linux/interrupt.h>
-#include <linux/fb.h>
 #include <linux/mutex.h>
 
 #include <mach/board.h>
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/serial.h kernel-2.6.28-20093908+0m5/include/linux/serial.h
--- kernel-2.6.28-20091602+0m5/include/linux/serial.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/serial.h	2012-12-16 13:13:01.728330146 +0100
@@ -10,8 +10,9 @@
 #ifndef _LINUX_SERIAL_H
 #define _LINUX_SERIAL_H
 
-#ifdef __KERNEL__
 #include <linux/types.h>
+
+#ifdef __KERNEL__
 #include <asm/page.h>
 
 /*
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/serial_reg.h kernel-2.6.28-20093908+0m5/include/linux/serial_reg.h
--- kernel-2.6.28-20091602+0m5/include/linux/serial_reg.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/serial_reg.h	2012-12-16 13:13:01.728330146 +0100
@@ -111,6 +111,7 @@
 #define UART_MCR_DTR		0x01 /* DTR complement */
 
 #define UART_LSR	5	/* In:  Line Status Register */
+#define UART_LSR_RX_FIFO_STS	0x80 /* RX fifo status */
 #define UART_LSR_TEMT		0x40 /* Transmitter empty */
 #define UART_LSR_THRE		0x20 /* Transmit-hold-register empty */
 #define UART_LSR_BI		0x10 /* Break interrupt indicator */
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/sched.h kernel-2.6.28-20093908+0m5/include/linux/sched.h
--- kernel-2.6.28-20091602+0m5/include/linux/sched.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/sched.h	2012-12-16 13:13:01.728330146 +0100
@@ -631,7 +631,6 @@ struct user_struct {
 	atomic_t inotify_devs;	/* How many inotify devs does this user have opened? */
 #endif
 #ifdef CONFIG_EPOLL
-	atomic_t epoll_devs;	/* The number of epoll descriptors currently open */
 	atomic_t epoll_watches;	/* The number of file descriptors currently watched */
 #endif
 #ifdef CONFIG_POSIX_MQUEUE
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/slub_def.h kernel-2.6.28-20093908+0m5/include/linux/slub_def.h
--- kernel-2.6.28-20091602+0m5/include/linux/slub_def.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/slub_def.h	2012-12-16 13:13:01.728330146 +0100
@@ -139,8 +139,10 @@ static __always_inline int kmalloc_index
 		return KMALLOC_SHIFT_LOW;
 
 #if KMALLOC_MIN_SIZE <= 64
+#if KMALLOC_MIN_SIZE <= 32
 	if (size > 64 && size <= 96)
 		return 1;
+#endif
 	if (size > 128 && size <= 192)
 		return 2;
 #endif
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/spi/tsc2005.h kernel-2.6.28-20093908+0m5/include/linux/spi/tsc2005.h
--- kernel-2.6.28-20091602+0m5/include/linux/spi/tsc2005.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/spi/tsc2005.h	2012-12-16 13:13:01.728330146 +0100
@@ -4,7 +4,6 @@
 #include <linux/types.h>
 
 struct tsc2005_platform_data {
-	s16	reset_gpio;
 	u16	ts_x_plate_ohm;
 	u32	ts_stab_time;	/* voltage settling time */
 	u8	ts_hw_avg;	/* HW assiseted averaging. Can be
@@ -24,6 +23,8 @@ struct tsc2005_platform_data {
 	u32	esd_timeout;    /* msec of inactivity before we check */
 
 	unsigned ts_ignore_last : 1;
+
+	void (*set_reset)(bool enable);
 };
 
 #endif
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/ssi_driver_if.h kernel-2.6.28-20093908+0m5/include/linux/ssi_driver_if.h
--- kernel-2.6.28-20091602+0m5/include/linux/ssi_driver_if.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/ssi_driver_if.h	2012-12-16 13:13:01.728330146 +0100
@@ -33,7 +33,7 @@
 
 #define ANY_SSI_CONTROLLER	-1
 #define ANY_CHANNEL		-1
-#define CHANNEL(channel)	(1 << channel)
+#define CHANNEL(channel)	(1 << (channel))
 
 enum {
 	SSI_EVENT_BREAK_DETECTED = 0,
@@ -52,6 +52,8 @@ enum {
 	SSI_IOCTL_FLUSH_RX,
 	SSI_IOCTL_FLUSH_TX,
 	SSI_IOCTL_CAWAKE,
+	SSI_IOCTL_TX_CH_FULL,
+	SSI_IOCTL_CH_DATAACCEPT,
 };
 
 /* Forward references */
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/swap.h kernel-2.6.28-20093908+0m5/include/linux/swap.h
--- kernel-2.6.28-20091602+0m5/include/linux/swap.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/swap.h	2012-12-16 13:13:01.728330146 +0100
@@ -142,6 +142,21 @@ struct swap_info_struct {
 	struct swap_extent *curr_swap_extent;
 	unsigned old_block_size;
 	unsigned short * swap_map;
+	/*
+	 * swap_remap is dual-purpose. The bottome 31 bits contain the
+	 * re-mapped page number. The top bit determines if the re-mapped page
+	 * itself is in use. e.g.
+	 *     say swap_remap[5] = 0x00000009
+	 *     and swap_remap[9] = 0x80000000
+	 * then page 5 is re-mapped to page 9, which is therefore in use.
+	 * Page 9, on the other hand, is not re-mapped.
+	 */
+	unsigned int *swap_remap;
+	spinlock_t remap_lock; /* Protects swap_remap */
+	struct mutex remap_mutex; /* Protects find_gap() */
+	unsigned int gap_next;
+	unsigned int gap_end;
+	unsigned int gaps_exist;
 	unsigned int lowest_bit;
 	unsigned int highest_bit;
 	unsigned int cluster_next;
@@ -303,7 +318,7 @@ extern void swap_free(swp_entry_t);
 extern void free_swap_and_cache(swp_entry_t);
 extern int swap_type_of(dev_t, sector_t, struct block_device **);
 extern unsigned int count_swap_pages(int, int);
-extern sector_t map_swap_page(struct swap_info_struct *, pgoff_t);
+extern sector_t map_swap_page(struct swap_info_struct *, pgoff_t, int);
 extern sector_t swapdev_block(int, pgoff_t);
 extern struct swap_info_struct *get_swap_info_struct(unsigned);
 extern int can_share_swap_page(struct page *);
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/usb/gadget.h kernel-2.6.28-20093908+0m5/include/linux/usb/gadget.h
--- kernel-2.6.28-20091602+0m5/include/linux/usb/gadget.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/usb/gadget.h	2012-12-16 13:13:01.728330146 +0100
@@ -484,6 +484,17 @@ struct usb_gadget {
 	unsigned			b_hnp_enable:1;
 	unsigned			a_hnp_support:1;
 	unsigned			a_alt_hnp_support:1;
+	/** UGLY UGLY HACK: Windows problems with multiple
+	 * configurations.
+	 *
+	 * We're adding the next three fields in order to:
+	 *	(a) keep track when we get a get_config
+	 *	(b) keep track when we get a set_config
+	 *	(c) keep track of config index.
+	 */
+	unsigned			get_config:1;
+	unsigned			set_config:1;
+	unsigned			cindex;
 	const char			*name;
 	struct device			dev;
 };
@@ -771,6 +782,7 @@ struct usb_gadget_driver {
 	int			(*setup)(struct usb_gadget *,
 					const struct usb_ctrlrequest *);
 	void			(*disconnect)(struct usb_gadget *);
+	void			(*vbus_disconnect)(struct usb_gadget *);
 	void			(*suspend)(struct usb_gadget *);
 	void			(*resume)(struct usb_gadget *);
 
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/usb/musb.h kernel-2.6.28-20093908+0m5/include/linux/usb/musb.h
--- kernel-2.6.28-20091602+0m5/include/linux/usb/musb.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/usb/musb.h	2012-12-16 13:13:01.728330146 +0100
@@ -59,6 +59,16 @@ struct musb_hdrc_config {
 
 };
 
+struct musb_board_data {
+	/* reset the transceiver */
+	int		(*xceiv_reset)(void);
+
+	int		(*xceiv_power)(bool power);
+
+	/* related to omap3 power management */
+	void		(*set_pm_limits)(struct device *dev, bool set);
+};
+
 struct musb_hdrc_platform_data {
 	/* MUSB_HOST, MUSB_PERIPHERAL, or MUSB_OTG */
 	u8		mode;
@@ -86,6 +96,9 @@ struct musb_hdrc_platform_data {
 
 	/* MUSB configuration-specific details */
 	struct musb_hdrc_config	*config;
+
+	/* MUSB board-specific details */
+	struct musb_board_data	*board;
 };
 
 
diff -Nurp kernel-2.6.28-20091602+0m5/include/linux/usb/raw.h kernel-2.6.28-20093908+0m5/include/linux/usb/raw.h
--- kernel-2.6.28-20091602+0m5/include/linux/usb/raw.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/linux/usb/raw.h	2012-12-16 13:13:01.728330146 +0100
@@ -0,0 +1,50 @@
+/*
+ * raw.h -- USB Raw Access Header
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ * Contact: Felipe Balbi <felipe.balbi@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __LINUX_USB_RAW_H
+#define __LINUX_USB_RAW_H
+
+#define MAX_REQUEST_LEN		(128 * 1024)
+#define MAX_NR_REQUESTS		31
+
+#define RAW_FIFO_STATUS		0x01
+#define RAW_FIFO_FLUSH		0x02
+#define RAW_CLEAR_HALT		0x03
+#define RAW_ALLOC_REQUEST	0x10
+#define RAW_QUEUE_REQUEST	0x11
+#define RAW_FREE_REQUEST	0x12
+#define RAW_GET_COMPLETION_MAP	0x13
+#define RAW_GET_REQUEST_STATUS	0x14
+#define RAW_STOP_REQUEST	0x15
+
+struct raw_request_status {
+	int			nr;
+	int			status;
+	unsigned int		nr_bytes;
+};
+
+struct raw_queue_request {
+	int			nr;
+	unsigned int		nr_bytes;
+};
+
+#endif /* __LINUX_USB_RAW_H */
+
diff -Nurp kernel-2.6.28-20091602+0m5/include/media/adp1653.h kernel-2.6.28-20093908+0m5/include/media/adp1653.h
--- kernel-2.6.28-20091602+0m5/include/media/adp1653.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/media/adp1653.h	2012-12-16 13:13:01.732330146 +0100
@@ -80,7 +80,6 @@ struct adp1653_flash {
 
 	struct adp1653_platform_data *platform_data;
 
-	bool dev_init_done;
 	enum v4l2_power power;		/* Requested power state */
 };
 
diff -Nurp kernel-2.6.28-20091602+0m5/include/media/ad5820.h kernel-2.6.28-20093908+0m5/include/media/ad5820.h
--- kernel-2.6.28-20091602+0m5/include/media/ad5820.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/media/ad5820.h	2012-12-16 13:13:01.732330146 +0100
@@ -48,7 +48,6 @@ struct ad5820_device {
 	s32 focus_absolute;		/* Current values of V4L2 controls */
 	s32 focus_ramp_time;
 	s32 focus_ramp_mode;
-	bool dev_init_done;
 	enum v4l2_power power;
 	struct ad5820_platform_data *platform_data;
 	struct v4l2_int_device *v4l2_int_device;
diff -Nurp kernel-2.6.28-20091602+0m5/include/net/bluetooth/hci_core.h kernel-2.6.28-20093908+0m5/include/net/bluetooth/hci_core.h
--- kernel-2.6.28-20091602+0m5/include/net/bluetooth/hci_core.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/net/bluetooth/hci_core.h	2012-12-16 13:13:01.732330146 +0100
@@ -171,6 +171,7 @@ struct hci_conn {
 	__u8             auth_type;
 	__u8             sec_level;
 	__u8             power_save;
+	__u16            disc_timeout;
 	unsigned long	 pend;
 
 	unsigned int	 sent;
@@ -180,7 +181,8 @@ struct hci_conn {
 	struct timer_list disc_timer;
 	struct timer_list idle_timer;
 
-	struct work_struct work;
+	struct work_struct work_add;
+	struct work_struct work_del;
 
 	struct device	dev;
 
@@ -348,9 +350,9 @@ static inline void hci_conn_put(struct h
 		if (conn->type == ACL_LINK) {
 			del_timer(&conn->idle_timer);
 			if (conn->state == BT_CONNECTED) {
-				timeo = msecs_to_jiffies(HCI_DISCONN_TIMEOUT);
+				timeo = msecs_to_jiffies(conn->disc_timeout);
 				if (!conn->out)
-					timeo *= 5;
+					timeo *= 2;
 			} else
 				timeo = msecs_to_jiffies(10);
 		} else
@@ -458,6 +460,7 @@ int hci_recv_fragment(struct hci_dev *hd
 
 int hci_register_sysfs(struct hci_dev *hdev);
 void hci_unregister_sysfs(struct hci_dev *hdev);
+void hci_conn_init_sysfs(struct hci_conn *conn);
 void hci_conn_add_sysfs(struct hci_conn *conn);
 void hci_conn_del_sysfs(struct hci_conn *conn);
 
diff -Nurp kernel-2.6.28-20091602+0m5/include/net/bluetooth/hci.h kernel-2.6.28-20093908+0m5/include/net/bluetooth/hci.h
--- kernel-2.6.28-20091602+0m5/include/net/bluetooth/hci.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/net/bluetooth/hci.h	2012-12-16 13:13:01.732330146 +0100
@@ -103,6 +103,7 @@ enum {
 /* HCI timeouts */
 #define HCI_CONNECT_TIMEOUT	(40000)	/* 40 seconds */
 #define HCI_DISCONN_TIMEOUT	(2000)	/* 2 seconds */
+#define HCI_PAIRING_TIMEOUT	(60000)	/* 60 seconds */
 #define HCI_IDLE_TIMEOUT	(6000)	/* 6 seconds */
 #define HCI_INIT_TIMEOUT	(10000)	/* 10 seconds */
 
diff -Nurp kernel-2.6.28-20091602+0m5/include/net/bluetooth/rfcomm.h kernel-2.6.28-20093908+0m5/include/net/bluetooth/rfcomm.h
--- kernel-2.6.28-20091602+0m5/include/net/bluetooth/rfcomm.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/net/bluetooth/rfcomm.h	2012-12-16 13:13:01.732330146 +0100
@@ -29,6 +29,7 @@
 #define RFCOMM_CONN_TIMEOUT (HZ * 30)
 #define RFCOMM_DISC_TIMEOUT (HZ * 20)
 #define RFCOMM_AUTH_TIMEOUT (HZ * 25)
+#define RFCOMM_IDLE_TIMEOUT (HZ * 2)
 
 #define RFCOMM_DEFAULT_MTU	127
 #define RFCOMM_DEFAULT_CREDITS	7
@@ -154,6 +155,7 @@ struct rfcomm_msc {
 struct rfcomm_session {
 	struct list_head list;
 	struct socket   *sock;
+	struct timer_list timer;
 	unsigned long    state;
 	unsigned long    flags;
 	atomic_t         refcnt;
diff -Nurp kernel-2.6.28-20091602+0m5/include/net/mac80211.h kernel-2.6.28-20093908+0m5/include/net/mac80211.h
--- kernel-2.6.28-20091602+0m5/include/net/mac80211.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/net/mac80211.h	2012-12-16 13:13:01.732330146 +0100
@@ -778,6 +778,9 @@ enum ieee80211_tkip_key_type {
  *	Hardware which has dynamic power save support, meaning
  *	that power save is enabled in idle periods, and don't need support
  *	from stack.
+ * @IEEE80211_HW_BEACON_FILTER:
+ *	Hardware supports dropping of irrelevant beacon frames to
+ *	avoid waking up cpu.
  */
 enum ieee80211_hw_flags {
 	IEEE80211_HW_RX_INCLUDES_FCS			= 1<<1,
@@ -791,6 +794,7 @@ enum ieee80211_hw_flags {
 	IEEE80211_HW_SPECTRUM_MGMT			= 1<<9,
 	IEEE80211_HW_AMPDU_AGGREGATION			= 1<<10,
 	IEEE80211_HW_NO_STACK_DYNAMIC_PS		= 1<<11,
+	IEEE80211_HW_BEACON_FILTER			= 1<<14,
 };
 
 /**
@@ -983,6 +987,24 @@ ieee80211_get_alt_retry_rate(const struc
  */
 
 /**
+ * DOC: Beacon filter support
+ *
+ * Some hardware have beacon filter support to reduce host cpu wakeups
+ * which will reduce system power consumption. It usuallly works so that
+ * the firmware creates a checksum of the beacon but omits all constantly
+ * changing elements (TSF, TIM etc). Whenever the checksum changes the
+ * beacon is forwarded to the host, otherwise it will be just dropped. That
+ * way the host will only receive beacons where some relevant information
+ * (for example ERP protection or WMM settings) have changed.
+ *
+ * Beacon filter support is informed with %IEEE80211_HW_BEACON_FILTER flag.
+ * The driver needs to enable beacon filter support whenever power save is
+ * enabled, that is %IEEE80211_CONF_PS is set. When power save is enabled,
+ * the stack will not check for beacon miss at all and the driver needs to
+ * notify about complete loss of beacons with ieee80211_beacon_loss().
+ */
+
+/**
  * DOC: Frame filtering
  *
  * mac80211 requires to see many management frames for proper
@@ -1812,6 +1834,16 @@ void ieee80211_stop_tx_ba_cb_irqsafe(str
 struct ieee80211_sta *ieee80211_find_sta(struct ieee80211_hw *hw,
 					 const u8 *addr);
 
+/**
+ * ieee80211_beacon_loss - inform hardware does not receive beacons
+ *
+ * @vif: &struct ieee80211_vif pointer from &struct ieee80211_if_init_conf.
+ *
+ * When beacon filtering is enabled with IEEE80211_HW_BEACON_FILTERING and
+ * IEEE80211_CONF_PS is set, the driver needs to inform whenever the
+ * hardware is not receiving beacons with this function.
+ */
+void ieee80211_beacon_loss(struct ieee80211_vif *vif);
 
 /* Rate control API */
 /**
@@ -1880,4 +1912,12 @@ rate_lowest_index(struct ieee80211_suppo
 int ieee80211_rate_control_register(struct rate_control_ops *ops);
 void ieee80211_rate_control_unregister(struct rate_control_ops *ops);
 
+enum ieee80211_rssi_state {
+	IEEE80211_RSSI_STATE_HIGH,
+	IEEE80211_RSSI_STATE_LOW,
+};
+
+void ieee80211_rssi_changed(struct ieee80211_vif *vif,
+			    enum ieee80211_rssi_state state);
+
 #endif /* MAC80211_H */
diff -Nurp kernel-2.6.28-20091602+0m5/include/net/neighbour.h kernel-2.6.28-20093908+0m5/include/net/neighbour.h
--- kernel-2.6.28-20091602+0m5/include/net/neighbour.h	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/net/neighbour.h	2012-12-16 13:13:01.732330146 +0100
@@ -24,6 +24,7 @@
 
 #include <linux/err.h>
 #include <linux/sysctl.h>
+#include <linux/workqueue.h>
 #include <net/rtnetlink.h>
 
 /*
@@ -167,7 +168,7 @@ struct neigh_table
 	int			gc_thresh2;
 	int			gc_thresh3;
 	unsigned long		last_flush;
-	struct timer_list 	gc_timer;
+	struct delayed_work	gc_work;
 	struct timer_list 	proxy_timer;
 	struct sk_buff_head	proxy_queue;
 	atomic_t		entries;
@@ -178,7 +179,6 @@ struct neigh_table
 	struct neighbour	**hash_buckets;
 	unsigned int		hash_mask;
 	__u32			hash_rnd;
-	unsigned int		hash_chain_gc;
 	struct pneigh_entry	**phash_buckets;
 #ifdef CONFIG_PROC_FS
 	struct proc_dir_entry	*pde;
diff -Nurp kernel-2.6.28-20091602+0m5/include/sound/soc.h kernel-2.6.28-20093908+0m5/include/sound/soc.h
--- kernel-2.6.28-20091602+0m5/include/sound/soc.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/include/sound/soc.h	2008-12-25 00:26:37.000000000 +0100
@@ -162,7 +162,6 @@ enum snd_soc_bias_level {
 #define SND_SOC_DAIFMT_DSP_A	3	/* L data msb after FRM or LRC */
 #define SND_SOC_DAIFMT_DSP_B	4	/* L data msb during FRM or LRC */
 #define SND_SOC_DAIFMT_AC97		5	/* AC97 */
-#define SND_SOC_DAIFMT_DSP	6
 
 #define SND_SOC_DAIFMT_MSB 	SND_SOC_DAIFMT_LEFT_J
 #define SND_SOC_DAIFMT_LSB	SND_SOC_DAIFMT_RIGHT_J
diff -Nurp kernel-2.6.28-20091602+0m5/kernel/cgroup.c kernel-2.6.28-20093908+0m5/kernel/cgroup.c
--- kernel-2.6.28-20091602+0m5/kernel/cgroup.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/kernel/cgroup.c	2012-12-16 13:13:01.732330146 +0100
@@ -2942,7 +2942,11 @@ int cgroup_clone(struct task_struct *tsk
 	parent = task_cgroup(tsk, subsys->subsys_id);
 
 	/* Pin the hierarchy */
-	atomic_inc(&parent->root->sb->s_active);
+	if (!atomic_inc_not_zero(&parent->root->sb->s_active)) {
+		/* We race with the final deactivate_super() */
+		mutex_unlock(&cgroup_mutex);
+		return 0;
+	}
 
 	/* Keep the cgroup alive */
 	get_css_set(cg);
diff -Nurp kernel-2.6.28-20091602+0m5/kernel/hrtimer.c kernel-2.6.28-20093908+0m5/kernel/hrtimer.c
--- kernel-2.6.28-20091602+0m5/kernel/hrtimer.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/kernel/hrtimer.c	2012-12-16 13:13:01.732330146 +0100
@@ -333,6 +333,8 @@ ktime_t ktime_add_safe(const ktime_t lhs
 	return res;
 }
 
+EXPORT_SYMBOL_GPL(ktime_add_safe);
+
 #ifdef CONFIG_DEBUG_OBJECTS_TIMERS
 
 static struct debug_obj_descr hrtimer_debug_descr;
diff -Nurp kernel-2.6.28-20091602+0m5/kernel/posix-timers.c kernel-2.6.28-20093908+0m5/kernel/posix-timers.c
--- kernel-2.6.28-20091602+0m5/kernel/posix-timers.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/kernel/posix-timers.c	2012-12-16 13:13:01.732330146 +0100
@@ -202,6 +202,12 @@ static int no_timer_create(struct k_itim
 	return -EOPNOTSUPP;
 }
 
+static int no_nsleep(const clockid_t which_clock, int flags,
+		     struct timespec *tsave, struct timespec __user *rmtp)
+{
+	return -EOPNOTSUPP;
+}
+
 /*
  * Return nonzero if we know a priori this clockid_t value is bogus.
  */
@@ -254,6 +260,7 @@ static __init int init_posix_timers(void
 		.clock_get = posix_get_monotonic_raw,
 		.clock_set = do_posix_clock_nosettime,
 		.timer_create = no_timer_create,
+		.nsleep = no_nsleep,
 	};
 
 	register_posix_clock(CLOCK_REALTIME, &clock_realtime);
diff -Nurp kernel-2.6.28-20091602+0m5/kernel/time/clockevents.c kernel-2.6.28-20093908+0m5/kernel/time/clockevents.c
--- kernel-2.6.28-20091602+0m5/kernel/time/clockevents.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/kernel/time/clockevents.c	2012-12-16 13:13:01.732330146 +0100
@@ -36,7 +36,7 @@ static DEFINE_SPINLOCK(clockevents_lock)
  *
  * Math helper, returns latch value converted to nanoseconds (bound checked)
  */
-unsigned long clockevent_delta2ns(unsigned long latch,
+unsigned long long clockevent_delta2ns(unsigned long latch,
 				  struct clock_event_device *evt)
 {
 	u64 clc = ((u64) latch << evt->shift);
@@ -49,10 +49,10 @@ unsigned long clockevent_delta2ns(unsign
 	do_div(clc, evt->mult);
 	if (clc < 1000)
 		clc = 1000;
-	if (clc > LONG_MAX)
-		clc = LONG_MAX;
+	if (clc > LLONG_MAX)
+		clc = LLONG_MAX;
 
-	return (unsigned long) clc;
+	return (unsigned long long) clc;
 }
 
 /**
diff -Nurp kernel-2.6.28-20091602+0m5/kernel/time/tick-sched.c kernel-2.6.28-20093908+0m5/kernel/time/tick-sched.c
--- kernel-2.6.28-20091602+0m5/kernel/time/tick-sched.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/kernel/time/tick-sched.c	2012-12-16 13:13:01.732330146 +0100
@@ -222,6 +222,15 @@ void tick_nohz_stop_sched_tick(int inidl
 
 	cpu = smp_processor_id();
 	ts = &per_cpu(tick_cpu_sched, cpu);
+
+	/*
+	 * Call to tick_nohz_start_idle stops the last_update_time from being
+	 * updated. Thus, it must not be called in the event we are called from
+	 * irq_exit() with the prior state different than idle.
+	 */
+	if (!inidle && !ts->inidle)
+		goto end;
+
 	now = tick_nohz_start_idle(ts);
 
 	/*
@@ -239,9 +248,6 @@ void tick_nohz_stop_sched_tick(int inidl
 	if (unlikely(ts->nohz_mode == NOHZ_MODE_INACTIVE))
 		goto end;
 
-	if (!inidle && !ts->inidle)
-		goto end;
-
 	ts->inidle = 1;
 
 	if (need_resched())
diff -Nurp kernel-2.6.28-20091602+0m5/kernel/time/timer_list.c kernel-2.6.28-20093908+0m5/kernel/time/timer_list.c
--- kernel-2.6.28-20091602+0m5/kernel/time/timer_list.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/kernel/time/timer_list.c	2012-12-16 13:13:01.732330146 +0100
@@ -204,7 +204,7 @@ print_tickdevice(struct seq_file *m, str
 		return;
 	}
 	SEQ_printf(m, "%s\n", dev->name);
-	SEQ_printf(m, " max_delta_ns:   %lu\n", dev->max_delta_ns);
+	SEQ_printf(m, " max_delta_ns:   %llu\n", dev->max_delta_ns);
 	SEQ_printf(m, " min_delta_ns:   %lu\n", dev->min_delta_ns);
 	SEQ_printf(m, " mult:           %lu\n", dev->mult);
 	SEQ_printf(m, " shift:          %d\n", dev->shift);
diff -Nurp kernel-2.6.28-20091602+0m5/kernel/timer.c kernel-2.6.28-20093908+0m5/kernel/timer.c
--- kernel-2.6.28-20091602+0m5/kernel/timer.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/kernel/timer.c	2012-12-16 13:13:01.732330146 +0100
@@ -930,6 +930,9 @@ cascade:
 		index = slot = timer_jiffies & TVN_MASK;
 		do {
 			list_for_each_entry(nte, varp->vec + slot, entry) {
+				if (tbase_get_deferrable(nte->base))
+					continue;
+
 				found = 1;
 				if (time_before(nte->expires, expires))
 					expires = nte->expires;
diff -Nurp kernel-2.6.28-20091602+0m5/mm/page_io.c kernel-2.6.28-20093908+0m5/mm/page_io.c
--- kernel-2.6.28-20091602+0m5/mm/page_io.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/mm/page_io.c	2012-12-16 13:13:01.732330146 +0100
@@ -20,7 +20,8 @@
 #include <asm/pgtable.h>
 
 static struct bio *get_swap_bio(gfp_t gfp_flags, pgoff_t index,
-				struct page *page, bio_end_io_t end_io)
+				struct page *page, bio_end_io_t end_io,
+				unsigned long rw)
 {
 	struct bio *bio;
 
@@ -30,8 +31,9 @@ static struct bio *get_swap_bio(gfp_t gf
 		swp_entry_t entry = { .val = index, };
 
 		sis = get_swap_info_struct(swp_type(entry));
-		bio->bi_sector = map_swap_page(sis, swp_offset(entry)) *
-					(PAGE_SIZE >> 9);
+		bio->bi_sector =
+			map_swap_page(sis, swp_offset(entry), rw & WRITE) *
+			(PAGE_SIZE >> 9);
 		bio->bi_bdev = sis->bdev;
 		bio->bi_io_vec[0].bv_page = page;
 		bio->bi_io_vec[0].bv_len = PAGE_SIZE;
@@ -103,7 +105,7 @@ int swap_writepage(struct page *page, st
 		goto out;
 	}
 	bio = get_swap_bio(GFP_NOIO, page_private(page), page,
-				end_swap_bio_write);
+				end_swap_bio_write, rw);
 	if (bio == NULL) {
 		set_page_dirty(page);
 		unlock_page(page);
@@ -128,7 +130,7 @@ int swap_readpage(struct file *file, str
 	BUG_ON(!PageLocked(page));
 	BUG_ON(PageUptodate(page));
 	bio = get_swap_bio(GFP_KERNEL, page_private(page), page,
-				end_swap_bio_read);
+				end_swap_bio_read, 0);
 	if (bio == NULL) {
 		unlock_page(page);
 		ret = -ENOMEM;
diff -Nurp kernel-2.6.28-20091602+0m5/mm/page-writeback.c kernel-2.6.28-20093908+0m5/mm/page-writeback.c
--- kernel-2.6.28-20091602+0m5/mm/page-writeback.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/mm/page-writeback.c	2012-12-16 13:13:01.732330146 +0100
@@ -34,6 +34,7 @@
 #include <linux/syscalls.h>
 #include <linux/buffer_head.h>
 #include <linux/pagevec.h>
+#include <linux/hrtimer.h>
 
 /*
  * The maximum number of pages to writeout in a single bdflush/kupdate
@@ -661,11 +662,114 @@ int wakeup_pdflush(long nr_pages)
 	return pdflush_operation(background_writeout, nr_pages);
 }
 
-static void wb_timer_fn(unsigned long unused);
+static enum hrtimer_restart wb_timer_fn(struct hrtimer *timer);
 static void laptop_timer_fn(unsigned long unused);
 
-static DEFINE_TIMER(wb_timer, wb_timer_fn, 0, 0);
+struct hrtimer wb_timer;
 static DEFINE_TIMER(laptop_mode_wb_timer, laptop_timer_fn, 0, 0);
+static DEFINE_SPINLOCK(wb_timer_lock);
+
+/* Whether the atomic write-back is enabled or not */
+atomic_t periodic_wb_enabled;
+
+/*
+ * This is a helper function which sets up the next periodic write-back timer
+ * event. The @wb_timer is set up as a range timer with soft limit 25% less
+ * than @expires and the hard limit equivalent to @expires. This means that the
+ * kernel may group this timer with other events and lessen number of
+ * wakeups.
+ */
+static void setup_wb_timer(unsigned long expires)
+{
+	u64 hardlimit, delta;
+
+	hardlimit = jiffies_to_usecs(expires) * 1000LLU;
+	delta = hardlimit >> 2;
+	if (delta > ULONG_MAX)
+		delta = ULONG_MAX;
+
+	hrtimer_start_range_ns(&wb_timer, ns_to_ktime(hardlimit - delta), delta,
+			       HRTIMER_MODE_REL);
+}
+
+/*
+ * Enable the periodic write-back. This function is usually called when
+ * an inode or a super block becomes dirty.
+ */
+void enable_periodic_wb(void)
+{
+	if (dirty_writeback_interval) {
+		spin_lock(&wb_timer_lock);
+		setup_wb_timer(dirty_writeback_interval);
+		spin_unlock(&wb_timer_lock);
+	}
+}
+
+static int sb_supports_wb(struct super_block *sb)
+{
+	struct inode *inode;
+	struct backing_dev_info *bdi;
+	int res;
+
+	spin_lock(&inode_lock);
+	inode = list_entry(sb->s_inodes.next, struct inode, i_sb_list);
+	bdi = inode->i_mapping->backing_dev_info;
+	res = bdi_cap_writeback_dirty(bdi);
+	spin_unlock(&inode_lock);
+	return res;
+}
+
+static void set_next_wb_timer(unsigned long expires)
+{
+	int all_clean = 1;
+	struct super_block *sb;
+
+	atomic_set(&periodic_wb_enabled, 0);
+
+	spin_lock(&sb_lock);
+restart:
+	list_for_each_entry(sb, &super_blocks, s_list) {
+		sb->s_count++;
+		spin_unlock(&sb_lock);
+
+		if (down_read_trylock(&sb->s_umount)) {
+			spin_lock(&sb_lock);
+			if (is_sb_dirty(sb))
+				all_clean = 0;
+			else if (sb->s_root && sb_supports_wb(sb) &&
+				   sb_has_dirty_inodes(sb))
+				all_clean = 0;
+			up_read(&sb->s_umount);
+		} else {
+			all_clean = 0;
+			spin_lock(&sb_lock);
+		}
+
+		if (__put_super_and_need_restart(sb))
+			goto restart;
+
+		if (!all_clean)
+			break;
+	}
+	spin_unlock(&sb_lock);
+
+	spin_lock(&wb_timer_lock);
+	if (all_clean && !atomic_read(&periodic_wb_enabled)) {
+		/*
+		 * There are no dirty data, and no one marked an inode or
+		 * super block as dirty. The periodic update timer may be
+		 * deleted. Note, if we race with some other task which has
+		 * just marked something as dirty and just set
+		 * 'periodic_wb_enabled' to 1, then this task will call
+		 * 'enable_periodic_wb()' which will re-enable the 'wb_timer'.
+		 */
+		hrtimer_cancel(&wb_timer);
+	} else {
+		atomic_set(&periodic_wb_enabled, 1);
+		setup_wb_timer(expires);
+	}
+	spin_unlock(&wb_timer_lock);
+}
 
 /*
  * Periodic writeback of "old" data.
@@ -719,10 +823,16 @@ static void wb_kupdate(unsigned long arg
 		}
 		nr_to_write -= MAX_WRITEBACK_PAGES - wbc.nr_to_write;
 	}
-	if (time_before(next_jif, jiffies + HZ))
-		next_jif = jiffies + HZ;
-	if (dirty_writeback_interval)
-		mod_timer(&wb_timer, next_jif);
+
+	if (dirty_writeback_interval) {
+		unsigned long expires;
+
+		if (time_before(next_jif, jiffies + HZ))
+			expires = HZ;
+		else
+			expires = next_jif - jiffies;
+		set_next_wb_timer(expires);
+	}
 }
 
 /*
@@ -733,16 +843,17 @@ int dirty_writeback_centisecs_handler(ct
 {
 	proc_dointvec_userhz_jiffies(table, write, file, buffer, length, ppos);
 	if (dirty_writeback_interval)
-		mod_timer(&wb_timer, jiffies + dirty_writeback_interval);
+		setup_wb_timer(dirty_writeback_interval);
 	else
-		del_timer(&wb_timer);
+		hrtimer_cancel(&wb_timer);
 	return 0;
 }
 
-static void wb_timer_fn(unsigned long unused)
+static enum hrtimer_restart wb_timer_fn(struct hrtimer *timer)
 {
 	if (pdflush_operation(wb_kupdate, 0) < 0)
-		mod_timer(&wb_timer, jiffies + HZ); /* delay 1 second */
+		setup_wb_timer(HZ); /* delay 1 second */
+	return HRTIMER_NORESTART;
 }
 
 static void laptop_flush(unsigned long unused)
@@ -835,7 +946,8 @@ void __init page_writeback_init(void)
 {
 	int shift;
 
-	mod_timer(&wb_timer, jiffies + dirty_writeback_interval);
+	hrtimer_init(&wb_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	wb_timer.function = wb_timer_fn;
 	writeback_set_ratelimit();
 	register_cpu_notifier(&ratelimit_nb);
 
diff -Nurp kernel-2.6.28-20091602+0m5/mm/slub.c kernel-2.6.28-20093908+0m5/mm/slub.c
--- kernel-2.6.28-20091602+0m5/mm/slub.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/mm/slub.c	2012-12-16 13:13:01.732330146 +0100
@@ -9,6 +9,7 @@
  */
 
 #include <linux/mm.h>
+#include <linux/swap.h> /* struct reclaim_state */
 #include <linux/module.h>
 #include <linux/bit_spinlock.h>
 #include <linux/interrupt.h>
@@ -1170,6 +1171,8 @@ static void __free_slab(struct kmem_cach
 
 	__ClearPageSlab(page);
 	reset_page_mapcount(page);
+	if (current->reclaim_state)
+		current->reclaim_state->reclaimed_slab += pages;
 	__free_pages(page, order);
 }
 
@@ -1591,6 +1594,7 @@ static __always_inline void *slab_alloc(
 	unsigned long flags;
 	unsigned int objsize;
 
+	might_sleep_if(gfpflags & __GFP_WAIT);
 	local_irq_save(flags);
 	c = get_cpu_slab(s, smp_processor_id());
 	objsize = c->objsize;
@@ -1986,7 +1990,7 @@ static struct kmem_cache_cpu *alloc_kmem
 static void free_kmem_cache_cpu(struct kmem_cache_cpu *c, int cpu)
 {
 	if (c < per_cpu(kmem_cache_cpu, cpu) ||
-			c > per_cpu(kmem_cache_cpu, cpu) + NR_KMEM_CACHE_CPU) {
+			c >= per_cpu(kmem_cache_cpu, cpu) + NR_KMEM_CACHE_CPU) {
 		kfree(c);
 		return;
 	}
@@ -2969,10 +2973,12 @@ void __init kmem_cache_init(void)
 	slab_state = PARTIAL;
 
 	/* Caches that are not of the two-to-the-power-of size */
-	if (KMALLOC_MIN_SIZE <= 64) {
+	if (KMALLOC_MIN_SIZE <= 32) {
 		create_kmalloc_cache(&kmalloc_caches[1],
 				"kmalloc-96", 96, GFP_KERNEL);
 		caches++;
+	}
+	if (KMALLOC_MIN_SIZE <= 64) {
 		create_kmalloc_cache(&kmalloc_caches[2],
 				"kmalloc-192", 192, GFP_KERNEL);
 		caches++;
@@ -2999,10 +3005,17 @@ void __init kmem_cache_init(void)
 	BUILD_BUG_ON(KMALLOC_MIN_SIZE > 256 ||
 		(KMALLOC_MIN_SIZE & (KMALLOC_MIN_SIZE - 1)));
 
-	for (i = 8; i < KMALLOC_MIN_SIZE; i += 8)
+	for (i = 8; i < min(KMALLOC_MIN_SIZE, 192 + 8); i += 8)
 		size_index[(i - 1) / 8] = KMALLOC_SHIFT_LOW;
 
-	if (KMALLOC_MIN_SIZE == 128) {
+	if (KMALLOC_MIN_SIZE == 64) {
+		/*
+		 * The 96 byte size cache is not used if the alignment
+		 * is 64 byte.
+		 */
+		for (i = 64 + 8; i <= 96; i += 8)
+			size_index[(i - 1) / 8] = 7;
+	} else if (KMALLOC_MIN_SIZE == 128) {
 		/*
 		 * The 192 byte sized cache is not used if the alignment
 		 * is 128 byte. Redirect kmalloc to use the 256 byte cache
@@ -3123,8 +3136,12 @@ struct kmem_cache *kmem_cache_create(con
 		s->inuse = max_t(int, s->inuse, ALIGN(size, sizeof(void *)));
 		up_write(&slub_lock);
 
-		if (sysfs_slab_alias(s, name))
+		if (sysfs_slab_alias(s, name)) {
+			down_write(&slub_lock);
+			s->refcount--;
+			up_write(&slub_lock);
 			goto err;
+		}
 		return s;
 	}
 
@@ -3134,8 +3151,13 @@ struct kmem_cache *kmem_cache_create(con
 				size, align, flags, ctor)) {
 			list_add(&s->list, &slab_caches);
 			up_write(&slub_lock);
-			if (sysfs_slab_add(s))
+			if (sysfs_slab_add(s)) {
+				down_write(&slub_lock);
+				list_del(&s->list);
+				up_write(&slub_lock);
+				kfree(s);
 				goto err;
+			}
 			return s;
 		}
 		kfree(s);
diff -Nurp kernel-2.6.28-20091602+0m5/mm/swapfile.c kernel-2.6.28-20093908+0m5/mm/swapfile.c
--- kernel-2.6.28-20091602+0m5/mm/swapfile.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/mm/swapfile.c	2012-12-16 13:13:01.736330146 +0100
@@ -273,22 +273,41 @@ out:
 static int swap_entry_free(struct swap_info_struct *p, unsigned long offset)
 {
 	int count = p->swap_map[offset];
+	unsigned old;
 
-	if (count < SWAP_MAP_MAX) {
-		count--;
-		p->swap_map[offset] = count;
-		if (!count) {
-			if (offset < p->lowest_bit)
-				p->lowest_bit = offset;
-			if (offset > p->highest_bit)
-				p->highest_bit = offset;
-			if (p->prio > swap_info[swap_list.next].prio)
-				swap_list.next = p - swap_info;
-			nr_swap_pages++;
-			p->inuse_pages--;
-		}
-	}
-	return count;
+	if (count >= SWAP_MAP_MAX)
+		return count;
+
+	count--;
+	p->swap_map[offset] = count;
+	if (count)
+		return count;
+
+	spin_lock(&p->remap_lock);
+
+	if (offset < p->lowest_bit)
+		p->lowest_bit = offset;
+	if (offset > p->highest_bit)
+		p->highest_bit = offset;
+	if (p->prio > swap_info[swap_list.next].prio)
+		swap_list.next = p - swap_info;
+	nr_swap_pages++;
+	p->inuse_pages--;
+
+	/* Re-map the page number */
+	old = p->swap_remap[offset] & 0x7FFFFFFF;
+	/* Zero means it was not re-mapped */
+	if (!old)
+		goto out;
+	/* Clear the re-mapping */
+	p->swap_remap[offset] &= 0x80000000;
+	/* Mark the re-mapped page as unused */
+	p->swap_remap[old] &= 0x7FFFFFFF;
+	/* Record how many free pages there are */
+	p->gaps_exist += 1;
+out:
+	spin_unlock(&p->remap_lock);
+	return 0;
 }
 
 /*
@@ -977,14 +996,118 @@ static void drain_mmlist(void)
 	spin_unlock(&mmlist_lock);
 }
 
+/* Find the largest sequence of free pages */
+int find_gap(struct swap_info_struct *sis)
+{
+	unsigned i, uninitialized_var(start), uninitialized_var(gap_next);
+	unsigned uninitialized_var(gap_end), gap_size = 0;
+	int in_gap = 0;
+
+	spin_unlock(&sis->remap_lock);
+	cond_resched();
+	mutex_lock(&sis->remap_mutex);
+
+	/* Check if a gap was found while we waited for the mutex */
+	spin_lock(&sis->remap_lock);
+	if (sis->gap_next <= sis->gap_end) {
+		mutex_unlock(&sis->remap_mutex);
+		return 0;
+	}
+	if (!sis->gaps_exist) {
+		mutex_unlock(&sis->remap_mutex);
+		return -1;
+	}
+	spin_unlock(&sis->remap_lock);
+
+	/*
+	 * There is no current gap, so no new re-mappings can be made without
+	 * going through this function (find_gap) which is protected by the
+	 * remap_mutex.
+	 */
+	for (i = 1; i < sis->max; i++) {
+		if (in_gap) {
+			if (!(sis->swap_remap[i] & 0x80000000))
+				continue;
+			if (i - start > gap_size) {
+				gap_next = start;
+				gap_end = i - 1;
+				gap_size = i - start;
+			}
+			in_gap = 0;
+		} else {
+			if (sis->swap_remap[i] & 0x80000000)
+				continue;
+			in_gap = 1;
+			start = i;
+		}
+		cond_resched();
+	}
+	spin_lock(&sis->remap_lock);
+	if (in_gap && i - start > gap_size) {
+		sis->gap_next = start;
+		sis->gap_end = i - 1;
+	} else {
+		sis->gap_next = gap_next;
+		sis->gap_end = gap_end;
+	}
+	mutex_unlock(&sis->remap_mutex);
+	return 0;
+}
+
 /*
  * Use this swapdev's extent info to locate the (PAGE_SIZE) block which
  * corresponds to page offset `offset'.
  */
-sector_t map_swap_page(struct swap_info_struct *sis, pgoff_t offset)
+sector_t map_swap_page(struct swap_info_struct *sis, pgoff_t offset, int write)
 {
 	struct swap_extent *se = sis->curr_swap_extent;
 	struct swap_extent *start_se = se;
+	unsigned old;
+
+	/*
+	 * Instead of using the offset we are given, re-map it to the next
+	 * sequential position.
+	 */
+	spin_lock(&sis->remap_lock);
+	/* Get the old re-mapping */
+	old = sis->swap_remap[offset] & 0x7FFFFFFF;
+	if (write) {
+		/* See if we have free pages */
+		if (sis->gap_next > sis->gap_end) {
+			/* The gap is used up. Find another one */
+			if (!sis->gaps_exist || find_gap(sis) < 0) {
+				/*
+				 * Out of space, so this page must have a
+				 * re-mapping, so use that.
+				 */
+				BUG_ON(!old);
+				sis->gap_next = sis->gap_end = old;
+			}
+		}
+		/* Zero means it was not re-mapped previously */
+		if (old) {
+			/* Clear the re-mapping */
+			sis->swap_remap[offset] &= 0x80000000;
+			/* Mark the re-mapped page as unused */
+			sis->swap_remap[old] &= 0x7FFFFFFF;
+		} else {
+			/* Record how many free pages there are */
+			sis->gaps_exist -= 1;
+		}
+		/* Create the re-mapping to the next free page */
+		sis->swap_remap[offset] |= sis->gap_next;
+		/* Mark it as used */
+		sis->swap_remap[sis->gap_next] |= 0x80000000;
+		/* Use the re-mapped page number */
+		offset = sis->gap_next;
+		/* Update the free pages gap */
+		sis->gap_next += 1;
+	} else {
+		/* Always read from the existing re-mapping */
+		BUG_ON(!old);
+		offset = old;
+	}
+	spin_unlock(&sis->remap_lock);
 
 	for ( ; ; ) {
 		struct list_head *lh;
@@ -1015,7 +1138,8 @@ sector_t swapdev_block(int swap_type, pg
 		return 0;
 
 	sis = swap_info + swap_type;
-	return (sis->flags & SWP_WRITEOK) ? map_swap_page(sis, offset) : 0;
+#error map_swap_page does not support hibernation
+	return (sis->flags & SWP_WRITEOK) ? map_swap_page(sis, offset, 0) : 0;
 }
 #endif /* CONFIG_HIBERNATION */
 
@@ -1342,6 +1466,7 @@ asmlinkage long sys_swapoff(const char _
 	p->flags = 0;
 	spin_unlock(&swap_lock);
 	mutex_unlock(&swapon_mutex);
+	vfree(p->swap_remap);
 	vfree(swap_map);
 	inode = mapping->host;
 	if (S_ISBLK(inode->i_mode)) {
@@ -1485,6 +1610,7 @@ asmlinkage long sys_swapon(const char __
 	unsigned long maxpages = 1;
 	int swapfilesize;
 	unsigned short *swap_map = NULL;
+	unsigned int *swap_remap = NULL;
 	struct page *page = NULL;
 	struct inode *inode = NULL;
 	int did_down = 0;
@@ -1654,9 +1780,15 @@ asmlinkage long sys_swapon(const char __
 			error = -ENOMEM;
 			goto bad_swap;
 		}
+		swap_remap = vmalloc(maxpages * sizeof(unsigned));
+		if (!swap_remap) {
+			error = -ENOMEM;
+			goto bad_swap;
+		}
 
 		error = 0;
 		memset(swap_map, 0, maxpages * sizeof(short));
+		memset(swap_remap, 0, maxpages * sizeof(unsigned));
 		for (i = 0; i < swap_header->info.nr_badpages; i++) {
 			int page_nr = swap_header->info.badpages[i];
 			if (page_nr <= 0 || page_nr >= swap_header->info.last_page)
@@ -1696,6 +1828,12 @@ asmlinkage long sys_swapon(const char __
 	else
 		p->prio = --least_priority;
 	p->swap_map = swap_map;
+	p->swap_remap = swap_remap;
+	p->gap_next = 1;
+	p->gap_end = p->max - 1;
+	p->gaps_exist = p->max - 1;
+	spin_lock_init(&p->remap_lock);
+	mutex_init(&p->remap_mutex);
 	p->flags = SWP_ACTIVE;
 	nr_swap_pages += nr_good_pages;
 	total_swap_pages += nr_good_pages;
@@ -1734,6 +1872,7 @@ bad_swap_2:
 	p->swap_file = NULL;
 	p->flags = 0;
 	spin_unlock(&swap_lock);
+	vfree(swap_remap);
 	vfree(swap_map);
 	if (swap_file)
 		filp_close(swap_file, NULL);
diff -Nurp kernel-2.6.28-20091602+0m5/net/bluetooth/hci_conn.c kernel-2.6.28-20093908+0m5/net/bluetooth/hci_conn.c
--- kernel-2.6.28-20091602+0m5/net/bluetooth/hci_conn.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/bluetooth/hci_conn.c	2012-12-16 13:13:01.736330146 +0100
@@ -171,10 +171,8 @@ static void hci_conn_timeout(unsigned lo
 	switch (conn->state) {
 	case BT_CONNECT:
 	case BT_CONNECT2:
-		if (conn->type == ACL_LINK)
+		if (conn->type == ACL_LINK && conn->out)
 			hci_acl_connect_cancel(conn);
-		else
-			hci_acl_disconn(conn, 0x13);
 		break;
 	case BT_CONFIG:
 	case BT_CONNECTED:
@@ -215,6 +213,7 @@ struct hci_conn *hci_conn_add(struct hci
 	conn->state = BT_OPEN;
 
 	conn->power_save = 1;
+	conn->disc_timeout = HCI_DISCONN_TIMEOUT;
 
 	switch (type) {
 	case ACL_LINK:
@@ -247,6 +246,8 @@ struct hci_conn *hci_conn_add(struct hci
 	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_ADD);
 
+	hci_conn_init_sysfs(conn);
+
 	tasklet_enable(&hdev->tx_task);
 
 	return conn;
@@ -289,6 +290,8 @@ int hci_conn_del(struct hci_conn *conn)
 
 	hci_conn_del_sysfs(conn);
 
+	hci_dev_put(hdev);
+
 	return 0;
 }
 
@@ -424,12 +427,9 @@ int hci_conn_security(struct hci_conn *c
 	if (sec_level == BT_SECURITY_SDP)
 		return 1;
 
-	if (sec_level == BT_SECURITY_LOW) {
-		if (conn->ssp_mode > 0 && conn->hdev->ssp_mode > 0)
-			return hci_conn_auth(conn, sec_level, auth_type);
-		else
-			return 1;
-	}
+	if (sec_level == BT_SECURITY_LOW &&
+				(!conn->ssp_mode || !conn->hdev->ssp_mode))
+		return 1;
 
 	if (conn->link_mode & HCI_LM_ENCRYPT)
 		return hci_conn_auth(conn, sec_level, auth_type);
@@ -494,7 +494,7 @@ void hci_conn_enter_active_mode(struct h
 	if (test_bit(HCI_RAW, &hdev->flags))
 		return;
 
-	if (conn->mode != HCI_CM_SNIFF || !conn->power_save)
+	if (conn->mode != HCI_CM_SNIFF)
 		goto timer;
 
 	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
diff -Nurp kernel-2.6.28-20091602+0m5/net/bluetooth/hci_event.c kernel-2.6.28-20093908+0m5/net/bluetooth/hci_event.c
--- kernel-2.6.28-20091602+0m5/net/bluetooth/hci_event.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/bluetooth/hci_event.c	2012-12-16 13:13:01.736330146 +0100
@@ -874,8 +874,16 @@ static inline void hci_conn_complete_evt
 	hci_dev_lock(hdev);
 
 	conn = hci_conn_hash_lookup_ba(hdev, ev->link_type, &ev->bdaddr);
-	if (!conn)
-		goto unlock;
+	if (!conn) {
+		if (ev->link_type != SCO_LINK)
+			goto unlock;
+
+		conn = hci_conn_hash_lookup_ba(hdev, ESCO_LINK, &ev->bdaddr);
+		if (!conn)
+			goto unlock;
+
+		conn->type = SCO_LINK;
+	}
 
 	if (!ev->status) {
 		conn->handle = __le16_to_cpu(ev->handle);
@@ -883,6 +891,7 @@ static inline void hci_conn_complete_evt
 		if (conn->type == ACL_LINK) {
 			conn->state = BT_CONFIG;
 			hci_conn_hold(conn);
+			conn->disc_timeout = HCI_DISCONN_TIMEOUT;
 		} else
 			conn->state = BT_CONNECTED;
 
@@ -1063,9 +1072,14 @@ static inline void hci_auth_complete_evt
 				hci_proto_connect_cfm(conn, ev->status);
 				hci_conn_put(conn);
 			}
-		} else
+		} else {
 			hci_auth_cfm(conn, ev->status);
 
+			hci_conn_hold(conn);
+			conn->disc_timeout = HCI_DISCONN_TIMEOUT;
+			hci_conn_put(conn);
+		}
+
 		if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
 			if (!ev->status) {
 				struct hci_cp_set_conn_encrypt cp;
@@ -1483,7 +1497,21 @@ static inline void hci_mode_change_evt(s
 
 static inline void hci_pin_code_request_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
+	struct hci_ev_pin_code_req *ev = (void *) skb->data;
+	struct hci_conn *conn;
+
 	BT_DBG("%s", hdev->name);
+
+	hci_dev_lock(hdev);
+
+	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);
+	if (conn && conn->state == BT_CONNECTED) {
+		hci_conn_hold(conn);
+		conn->disc_timeout = HCI_PAIRING_TIMEOUT;
+		hci_conn_put(conn);
+	}
+
+	hci_dev_unlock(hdev);
 }
 
 static inline void hci_link_key_request_evt(struct hci_dev *hdev, struct sk_buff *skb)
@@ -1493,7 +1521,21 @@ static inline void hci_link_key_request_
 
 static inline void hci_link_key_notify_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
+	struct hci_ev_link_key_notify *ev = (void *) skb->data;
+	struct hci_conn *conn;
+
 	BT_DBG("%s", hdev->name);
+
+	hci_dev_lock(hdev);
+
+	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);
+	if (conn) {
+		hci_conn_hold(conn);
+		conn->disc_timeout = HCI_DISCONN_TIMEOUT;
+		hci_conn_put(conn);
+	}
+
+	hci_dev_unlock(hdev);
 }
 
 static inline void hci_clock_offset_evt(struct hci_dev *hdev, struct sk_buff *skb)
@@ -1658,20 +1700,28 @@ static inline void hci_sync_conn_complet
 		conn->type = SCO_LINK;
 	}
 
-	if (conn->out && ev->status == 0x1c && conn->attempt < 2) {
-		conn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |
-					(hdev->esco_type & EDR_ESCO_MASK);
-		hci_setup_sync(conn, conn->link->handle);
-		goto unlock;
-	}
-
-	if (!ev->status) {
+	switch (ev->status) {
+	case 0x00:
 		conn->handle = __le16_to_cpu(ev->handle);
 		conn->state  = BT_CONNECTED;
 
 		hci_conn_add_sysfs(conn);
-	} else
+		break;
+
+	case 0x1c:	/* SCO interval rejected */
+	case 0x1f:	/* Unspecified error */
+		if (conn->out && conn->attempt < 2) {
+			conn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |
+					(hdev->esco_type & EDR_ESCO_MASK);
+			hci_setup_sync(conn, conn->link->handle);
+			goto unlock;
+		}
+		/* fall through */
+
+	default:
 		conn->state = BT_CLOSED;
+		break;
+	}
 
 	hci_proto_connect_cfm(conn, ev->status);
 	if (ev->status)
diff -Nurp kernel-2.6.28-20091602+0m5/net/bluetooth/hci_sysfs.c kernel-2.6.28-20093908+0m5/net/bluetooth/hci_sysfs.c
--- kernel-2.6.28-20091602+0m5/net/bluetooth/hci_sysfs.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/bluetooth/hci_sysfs.c	2012-12-16 13:13:01.736330146 +0100
@@ -9,8 +9,7 @@
 struct class *bt_class = NULL;
 EXPORT_SYMBOL_GPL(bt_class);
 
-static struct workqueue_struct *btaddconn;
-static struct workqueue_struct *btdelconn;
+static struct workqueue_struct *bt_workq;
 
 static inline char *link_typetostr(int type)
 {
@@ -88,35 +87,20 @@ static struct device_type bt_link = {
 
 static void add_conn(struct work_struct *work)
 {
-	struct hci_conn *conn = container_of(work, struct hci_conn, work);
+	struct hci_conn *conn = container_of(work, struct hci_conn, work_add);
+	struct hci_dev *hdev = conn->hdev;
+
+	/* ensure previous del is complete */
+	flush_work(&conn->work_del);
 
-	flush_workqueue(btdelconn);
+	dev_set_name(&conn->dev, "%s:%d", hdev->name, conn->handle);
 
 	if (device_add(&conn->dev) < 0) {
 		BT_ERR("Failed to register connection device");
 		return;
 	}
-}
-
-void hci_conn_add_sysfs(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("conn %p", conn);
-
-	conn->dev.type = &bt_link;
-	conn->dev.class = bt_class;
-	conn->dev.parent = &hdev->dev;
-
-	dev_set_name(&conn->dev, "%s:%d", hdev->name, conn->handle);
-
-	dev_set_drvdata(&conn->dev, conn);
-
-	device_initialize(&conn->dev);
 
-	INIT_WORK(&conn->work, add_conn);
-
-	queue_work(btaddconn, &conn->work);
+	hci_dev_hold(hdev);
 }
 
 /*
@@ -131,9 +115,15 @@ static int __match_tty(struct device *de
 
 static void del_conn(struct work_struct *work)
 {
-	struct hci_conn *conn = container_of(work, struct hci_conn, work);
+	struct hci_conn *conn = container_of(work, struct hci_conn, work_del);
 	struct hci_dev *hdev = conn->hdev;
 
+	/* ensure previous add is complete */
+	flush_work(&conn->work_add);
+
+	if (!device_is_registered(&conn->dev))
+		return;
+
 	while (1) {
 		struct device *dev;
 
@@ -146,19 +136,40 @@ static void del_conn(struct work_struct
 
 	device_del(&conn->dev);
 	put_device(&conn->dev);
+
 	hci_dev_put(hdev);
 }
 
-void hci_conn_del_sysfs(struct hci_conn *conn)
+void hci_conn_init_sysfs(struct hci_conn *conn)
 {
+	struct hci_dev *hdev = conn->hdev;
+
 	BT_DBG("conn %p", conn);
 
-	if (!device_is_registered(&conn->dev))
-		return;
+	conn->dev.type = &bt_link;
+	conn->dev.class = bt_class;
+	conn->dev.parent = &hdev->dev;
+
+	dev_set_drvdata(&conn->dev, conn);
+
+	device_initialize(&conn->dev);
+
+	INIT_WORK(&conn->work_add, add_conn);
+	INIT_WORK(&conn->work_del, del_conn);
+}
 
-	INIT_WORK(&conn->work, del_conn);
+void hci_conn_add_sysfs(struct hci_conn *conn)
+{
+	BT_DBG("conn %p", conn);
 
-	queue_work(btdelconn, &conn->work);
+	queue_work(bt_workq, &conn->work_add);
+}
+
+void hci_conn_del_sysfs(struct hci_conn *conn)
+{
+	BT_DBG("conn %p", conn);
+
+	queue_work(bt_workq, &conn->work_del);
 }
 
 static inline char *host_typetostr(int type)
@@ -435,20 +446,13 @@ void hci_unregister_sysfs(struct hci_dev
 
 int __init bt_sysfs_init(void)
 {
-	btaddconn = create_singlethread_workqueue("btaddconn");
-	if (!btaddconn)
+	bt_workq = create_singlethread_workqueue("bluetooth");
+	if (!bt_workq)
 		return -ENOMEM;
 
-	btdelconn = create_singlethread_workqueue("btdelconn");
-	if (!btdelconn) {
-		destroy_workqueue(btaddconn);
-		return -ENOMEM;
-	}
-
 	bt_class = class_create(THIS_MODULE, "bluetooth");
 	if (IS_ERR(bt_class)) {
-		destroy_workqueue(btdelconn);
-		destroy_workqueue(btaddconn);
+		destroy_workqueue(bt_workq);
 		return PTR_ERR(bt_class);
 	}
 
@@ -457,8 +461,7 @@ int __init bt_sysfs_init(void)
 
 void bt_sysfs_cleanup(void)
 {
-	destroy_workqueue(btaddconn);
-	destroy_workqueue(btdelconn);
+	destroy_workqueue(bt_workq);
 
 	class_destroy(bt_class);
 }
diff -Nurp kernel-2.6.28-20091602+0m5/net/bluetooth/l2cap.c kernel-2.6.28-20093908+0m5/net/bluetooth/l2cap.c
--- kernel-2.6.28-20091602+0m5/net/bluetooth/l2cap.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/bluetooth/l2cap.c	2012-12-16 13:13:01.736330146 +0100
@@ -2660,8 +2660,11 @@ static int l2cap_recv_acldata(struct hci
 		BT_DBG("Cont: frag len %d (expecting %d)", skb->len, conn->rx_len);
 
 		if (!conn->rx_len) {
+			/* Hack hack - workaround for bcm2048 bug. It sends
+			empty frames every now and then without reason.
 			BT_ERR("Unexpected continuation frame (len %d)", skb->len);
 			l2cap_conn_unreliable(conn, ECOMM);
+			*/
 			goto drop;
 		}
 
diff -Nurp kernel-2.6.28-20091602+0m5/net/bluetooth/rfcomm/core.c kernel-2.6.28-20093908+0m5/net/bluetooth/rfcomm/core.c
--- kernel-2.6.28-20091602+0m5/net/bluetooth/rfcomm/core.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/bluetooth/rfcomm/core.c	2012-12-16 13:13:01.736330146 +0100
@@ -244,6 +244,33 @@ static inline int rfcomm_check_security(
 								auth_type);
 }
 
+static void rfcomm_session_timeout(unsigned long arg)
+{
+	struct rfcomm_session *s = (void *) arg;
+
+	BT_DBG("session %p state %ld", s, s->state);
+
+	set_bit(RFCOMM_TIMED_OUT, &s->flags);
+	rfcomm_session_put(s);
+	rfcomm_schedule(RFCOMM_SCHED_TIMEO);
+}
+
+static void rfcomm_session_set_timer(struct rfcomm_session *s, long timeout)
+{
+	BT_DBG("session %p state %ld timeout %ld", s, s->state, timeout);
+
+	if (!mod_timer(&s->timer, jiffies + timeout))
+		rfcomm_session_hold(s);
+}
+
+static void rfcomm_session_clear_timer(struct rfcomm_session *s)
+{
+	BT_DBG("session %p state %ld", s, s->state);
+
+	if (timer_pending(&s->timer) && del_timer(&s->timer))
+		rfcomm_session_put(s);
+}
+
 /* ---- RFCOMM DLCs ---- */
 static void rfcomm_dlc_timeout(unsigned long arg)
 {
@@ -320,6 +347,7 @@ static void rfcomm_dlc_link(struct rfcom
 
 	rfcomm_session_hold(s);
 
+	rfcomm_session_clear_timer(s);
 	rfcomm_dlc_hold(d);
 	list_add(&d->list, &s->dlcs);
 	d->session = s;
@@ -335,6 +363,9 @@ static void rfcomm_dlc_unlink(struct rfc
 	d->session = NULL;
 	rfcomm_dlc_put(d);
 
+	if (list_empty(&s->dlcs))
+		rfcomm_session_set_timer(s, RFCOMM_IDLE_TIMEOUT);
+
 	rfcomm_session_put(s);
 }
 
@@ -567,6 +598,8 @@ static struct rfcomm_session *rfcomm_ses
 
 	BT_DBG("session %p sock %p", s, sock);
 
+	setup_timer(&s->timer, rfcomm_session_timeout, (unsigned long)s);
+
 	INIT_LIST_HEAD(&s->dlcs);
 	s->state = state;
 	s->sock  = sock;
@@ -598,6 +631,7 @@ static void rfcomm_session_del(struct rf
 	if (state == BT_CONNECTED)
 		rfcomm_send_disc(s, 0);
 
+	rfcomm_session_clear_timer(s);
 	sock_release(s->sock);
 	kfree(s);
 
@@ -639,6 +673,7 @@ static void rfcomm_session_close(struct
 		__rfcomm_dlc_close(d, err);
 	}
 
+	rfcomm_session_clear_timer(s);
 	rfcomm_session_put(s);
 }
 
@@ -1879,6 +1914,12 @@ static inline void rfcomm_process_sessio
 		struct rfcomm_session *s;
 		s = list_entry(p, struct rfcomm_session, list);
 
+		if (test_and_clear_bit(RFCOMM_TIMED_OUT, &s->flags)) {
+			s->state = BT_DISCONN;
+			rfcomm_send_disc(s, 0);
+			continue;
+		}
+
 		if (s->state == BT_LISTEN) {
 			rfcomm_accept_connection(s);
 			continue;
diff -Nurp kernel-2.6.28-20091602+0m5/net/bluetooth/sco.c kernel-2.6.28-20093908+0m5/net/bluetooth/sco.c
--- kernel-2.6.28-20091602+0m5/net/bluetooth/sco.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/bluetooth/sco.c	2012-12-16 13:13:01.736330146 +0100
@@ -359,20 +359,9 @@ static void sco_sock_kill(struct sock *s
 	sock_put(sk);
 }
 
-/* Close socket.
- * Must be called on unlocked socket.
- */
-static void sco_sock_close(struct sock *sk)
+static void __sco_sock_close(struct sock *sk)
 {
-	struct sco_conn *conn;
-
-	sco_sock_clear_timer(sk);
-
-	lock_sock(sk);
-
-	conn = sco_pi(sk)->conn;
-
-	BT_DBG("sk %p state %d conn %p socket %p", sk, sk->sk_state, conn, sk->sk_socket);
+	BT_DBG("sk %p state %d socket %p", sk, sk->sk_state, sk->sk_socket);
 
 	switch (sk->sk_state) {
 	case BT_LISTEN:
@@ -390,9 +379,15 @@ static void sco_sock_close(struct sock *
 		sock_set_flag(sk, SOCK_ZAPPED);
 		break;
 	}
+}
 
+/* Must be called on unlocked socket. */
+static void sco_sock_close(struct sock *sk)
+{
+	sco_sock_clear_timer(sk);
+	lock_sock(sk);
+	__sco_sock_close(sk);
 	release_sock(sk);
-
 	sco_sock_kill(sk);
 }
 
@@ -748,6 +743,30 @@ static int sco_sock_getsockopt(struct so
 	return err;
 }
 
+static int sco_sock_shutdown(struct socket *sock, int how)
+{
+	struct sock *sk = sock->sk;
+	int err = 0;
+
+	BT_DBG("sock %p, sk %p", sock, sk);
+
+	if (!sk)
+		return 0;
+
+	lock_sock(sk);
+	if (!sk->sk_shutdown) {
+		sk->sk_shutdown = SHUTDOWN_MASK;
+		sco_sock_clear_timer(sk);
+		__sco_sock_close(sk);
+
+		if (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime)
+			err = bt_sock_wait_state(sk, BT_CLOSED,
+							sk->sk_lingertime);
+	}
+	release_sock(sk);
+	return err;
+}
+
 static int sco_sock_release(struct socket *sock)
 {
 	struct sock *sk = sock->sk;
@@ -969,7 +988,7 @@ static const struct proto_ops sco_sock_o
 	.ioctl		= bt_sock_ioctl,
 	.mmap		= sock_no_mmap,
 	.socketpair	= sock_no_socketpair,
-	.shutdown	= sock_no_shutdown,
+	.shutdown	= sco_sock_shutdown,
 	.setsockopt	= sco_sock_setsockopt,
 	.getsockopt	= sco_sock_getsockopt
 };
diff -Nurp kernel-2.6.28-20091602+0m5/net/core/neighbour.c kernel-2.6.28-20093908+0m5/net/core/neighbour.c
--- kernel-2.6.28-20091602+0m5/net/core/neighbour.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/core/neighbour.c	2012-12-16 13:13:01.740330145 +0100
@@ -694,75 +694,74 @@ static void neigh_connect(struct neighbo
 		hh->hh_output = neigh->ops->hh_output;
 }
 
-static void neigh_periodic_timer(unsigned long arg)
+static void neigh_periodic_work(struct work_struct *work)
 {
-	struct neigh_table *tbl = (struct neigh_table *)arg;
+	struct neigh_table *tbl = container_of(work, struct neigh_table, gc_work.work);
 	struct neighbour *n, **np;
-	unsigned long expire, now = jiffies;
+	unsigned int i;
 
 	NEIGH_CACHE_STAT_INC(tbl, periodic_gc_runs);
 
-	write_lock(&tbl->lock);
+	write_lock_bh(&tbl->lock);
 
 	/*
 	 *	periodically recompute ReachableTime from random function
 	 */
 
-	if (time_after(now, tbl->last_rand + 300 * HZ)) {
+	if (time_after(jiffies, tbl->last_rand + 300 * HZ)) {
 		struct neigh_parms *p;
-		tbl->last_rand = now;
+		tbl->last_rand = jiffies;
 		for (p = &tbl->parms; p; p = p->next)
 			p->reachable_time =
 				neigh_rand_reach_time(p->base_reachable_time);
 	}
 
-	np = &tbl->hash_buckets[tbl->hash_chain_gc];
-	tbl->hash_chain_gc = ((tbl->hash_chain_gc + 1) & tbl->hash_mask);
+	for (i = 0 ; i <= tbl->hash_mask; i++) {
+		np = &tbl->hash_buckets[i];
 
-	while ((n = *np) != NULL) {
-		unsigned int state;
+		while ((n = *np) != NULL) {
+			unsigned int state;
 
-		write_lock(&n->lock);
+			write_lock(&n->lock);
 
-		state = n->nud_state;
-		if (state & (NUD_PERMANENT | NUD_IN_TIMER)) {
-			write_unlock(&n->lock);
-			goto next_elt;
-		}
+			state = n->nud_state;
+			if (state & (NUD_PERMANENT | NUD_IN_TIMER)) {
+				write_unlock(&n->lock);
+				goto next_elt;
+			}
 
-		if (time_before(n->used, n->confirmed))
-			n->used = n->confirmed;
+			if (time_before(n->used, n->confirmed))
+				n->used = n->confirmed;
 
-		if (atomic_read(&n->refcnt) == 1 &&
-		    (state == NUD_FAILED ||
-		     time_after(now, n->used + n->parms->gc_staletime))) {
-			*np = n->next;
-			n->dead = 1;
+			if (atomic_read(&n->refcnt) == 1 &&
+			    (state == NUD_FAILED ||
+			     time_after(jiffies, n->used + n->parms->gc_staletime))) {
+				*np = n->next;
+				n->dead = 1;
+				write_unlock(&n->lock);
+				neigh_cleanup_and_release(n);
+				continue;
+			}
 			write_unlock(&n->lock);
-			neigh_cleanup_and_release(n);
-			continue;
-		}
-		write_unlock(&n->lock);
 
 next_elt:
-		np = &n->next;
+			np = &n->next;
+		}
+		/*
+		 * It's fine to release lock here, even if hash table
+		 * grows while we are preempted.
+		 */
+		write_unlock_bh(&tbl->lock);
+		cond_resched();
+		write_lock_bh(&tbl->lock);
 	}
-
 	/* Cycle through all hash buckets every base_reachable_time/2 ticks.
 	 * ARP entry timeouts range from 1/2 base_reachable_time to 3/2
 	 * base_reachable_time.
 	 */
-	expire = tbl->parms.base_reachable_time >> 1;
-	expire /= (tbl->hash_mask + 1);
-	if (!expire)
-		expire = 1;
-
-	if (expire>HZ)
-		mod_timer(&tbl->gc_timer, round_jiffies(now + expire));
-	else
-		mod_timer(&tbl->gc_timer, now + expire);
-
-	write_unlock(&tbl->lock);
+	schedule_delayed_work(&tbl->gc_work,
+			      tbl->parms.base_reachable_time >> 1);
+	write_unlock_bh(&tbl->lock);
 }
 
 static __inline__ int neigh_max_probes(struct neighbour *n)
@@ -1444,10 +1443,8 @@ void neigh_table_init_no_netlink(struct
 	get_random_bytes(&tbl->hash_rnd, sizeof(tbl->hash_rnd));
 
 	rwlock_init(&tbl->lock);
-	setup_timer(&tbl->gc_timer, neigh_periodic_timer, (unsigned long)tbl);
-	tbl->gc_timer.expires  = now + 1;
-	add_timer(&tbl->gc_timer);
-
+	INIT_DELAYED_WORK_DEFERRABLE(&tbl->gc_work, neigh_periodic_work);
+	schedule_delayed_work(&tbl->gc_work, tbl->parms.reachable_time);
 	setup_timer(&tbl->proxy_timer, neigh_proxy_process, (unsigned long)tbl);
 	skb_queue_head_init_class(&tbl->proxy_queue,
 			&neigh_table_proxy_queue_class);
@@ -1484,7 +1481,8 @@ int neigh_table_clear(struct neigh_table
 	struct neigh_table **tp;
 
 	/* It is not clean... Fix it to unload IPv6 module safely */
-	del_timer_sync(&tbl->gc_timer);
+	cancel_delayed_work(&tbl->gc_work);
+	flush_scheduled_work();
 	del_timer_sync(&tbl->proxy_timer);
 	pneigh_queue_purge(&tbl->proxy_queue);
 	neigh_ifdown(tbl, NULL);
@@ -1750,7 +1748,6 @@ static int neightbl_fill_info(struct sk_
 			.ndtc_last_rand		= jiffies_to_msecs(rand_delta),
 			.ndtc_hash_rnd		= tbl->hash_rnd,
 			.ndtc_hash_mask		= tbl->hash_mask,
-			.ndtc_hash_chain_gc	= tbl->hash_chain_gc,
 			.ndtc_proxy_qlen	= tbl->proxy_queue.qlen,
 		};
 
diff -Nurp kernel-2.6.28-20091602+0m5/net/core/sock.c kernel-2.6.28-20093908+0m5/net/core/sock.c
--- kernel-2.6.28-20091602+0m5/net/core/sock.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/core/sock.c	2012-12-16 13:13:01.740330145 +0100
@@ -886,8 +886,23 @@ static struct sock *sk_prot_alloc(struct
 	struct kmem_cache *slab;
 
 	slab = prot->slab;
-	if (slab != NULL)
-		sk = kmem_cache_alloc(slab, priority);
+	if (slab != NULL) {
+		sk = kmem_cache_alloc(slab, priority & ~__GFP_ZERO);
+		if (!sk)
+			return sk;
+		if (priority & __GFP_ZERO) {
+			/*
+			 * caches using SLAB_DESTROY_BY_RCU should let
+			 * sk_node.next un-modified. Special care is taken
+			 * when initializing object to zero.
+			 */
+			if (offsetof(struct sock, sk_node.next) != 0)
+				memset(sk, 0, offsetof(struct sock, sk_node.next));
+			memset(&sk->sk_node.pprev, 0,
+			       prot->obj_size - offsetof(struct sock,
+							 sk_node.pprev));
+		}
+	}
 	else
 		sk = kmalloc(prot->obj_size, priority);
 
diff -Nurp kernel-2.6.28-20091602+0m5/net/mac80211/ieee80211_i.h kernel-2.6.28-20093908+0m5/net/mac80211/ieee80211_i.h
--- kernel-2.6.28-20091602+0m5/net/mac80211/ieee80211_i.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/mac80211/ieee80211_i.h	2012-12-16 13:13:01.740330145 +0100
@@ -107,6 +107,7 @@ struct ieee80211_bss {
 	 * otherwise, you probably don't want to use them. */
 	int has_erp_value;
 	u8 erp_value;
+	bool hold;
 };
 
 static inline u8 *bss_mesh_cfg(struct ieee80211_bss *bss)
@@ -274,11 +275,6 @@ struct mesh_config {
 	u16 dot11MeshHWMPnetDiameterTraversalTime;
 };
 
-enum rssi_signal_state {
-	RSSI_SIGNAL_STATE_HIGH,
-	RSSI_SIGNAL_STATE_LOW,
-};
-
 /* flags used in struct ieee80211_if_sta.flags */
 #define IEEE80211_STA_SSID_SET		BIT(0)
 #define IEEE80211_STA_BSSID_SET		BIT(1)
@@ -318,6 +314,8 @@ enum ieee80211_sta_mlme_state {
 struct ieee80211_if_sta {
 	struct timer_list timer;
 	struct work_struct work;
+	struct work_struct beacon_loss_work;
+
 	u8 bssid[ETH_ALEN], prev_bssid[ETH_ALEN];
 	u8 ssid[IEEE80211_MAX_SSID_LEN];
 	enum ieee80211_sta_mlme_state state;
@@ -343,6 +341,7 @@ struct ieee80211_if_sta {
 	unsigned long request;
 
 	unsigned long last_probe;
+	unsigned long last_beacon;
 
 	unsigned int flags;
 
@@ -358,7 +357,7 @@ struct ieee80211_if_sta {
 
 	int num_beacons; /* number of TXed beacon frames by this STA */
 	unsigned int roam_threshold_count;
-	enum rssi_signal_state rssi_signal_state;
+	enum ieee80211_rssi_state rssi_state;
 };
 
 struct ieee80211_if_mesh {
@@ -1038,6 +1037,9 @@ u64 ieee80211_mandatory_rates(struct iee
 void ieee80211_dynamic_ps_enable_work(struct work_struct *work);
 void ieee80211_dynamic_ps_disable_work(struct work_struct *work);
 void ieee80211_dynamic_ps_timer(unsigned long data);
+void ieee80211_sta_rx_notify(struct ieee80211_sub_if_data *sdata,
+			     struct ieee80211_hdr *hdr);
+void ieee80211_beacon_loss_work(struct work_struct *work);
 
 void ieee80211_wake_queues_by_reason(struct ieee80211_hw *hw,
 				     enum queue_stop_reason reason);
diff -Nurp kernel-2.6.28-20091602+0m5/net/mac80211/iface.c kernel-2.6.28-20093908+0m5/net/mac80211/iface.c
--- kernel-2.6.28-20091602+0m5/net/mac80211/iface.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/mac80211/iface.c	2012-12-16 13:13:01.740330145 +0100
@@ -154,6 +154,16 @@ static int ieee80211_open(struct net_dev
 			goto err_del_bss;
 		need_hw_reconfig = 1;
 		ieee80211_led_radio(local, local->hw.conf.radio_enabled);
+		/*
+		 * In the case of IBSS whenever interface is restarted, random
+		 * BSSID should be generated when creating ad-hoc network with
+		 * same ssid. As the bss_list is not cleared anywhere, it uses
+		 * previously cached random BSSID. This is a workaround to
+		 * clear bss_list during interface down and initialize during
+		 * interface up.
+		 */
+
+		ieee80211_rx_bss_list_init(local);
 	}
 
 	/*
@@ -434,6 +444,8 @@ static int ieee80211_stop(struct net_dev
 		 * it no longer is.
 		 */
 		cancel_work_sync(&sdata->u.sta.work);
+		cancel_work_sync(&sdata->u.sta.beacon_loss_work);
+
 		/*
 		 * When we get here, the interface is marked down.
 		 * Call synchronize_rcu() to wait for the RX path
@@ -499,6 +511,11 @@ static int ieee80211_stop(struct net_dev
 			local->ops->stop(local_to_hw(local));
 
 		ieee80211_led_radio(local, 0);
+		/*
+		 * Clear the bss_list so that random BSSID is generated when
+		 * creating ad-hoc network with same bssid.
+		 */
+		ieee80211_rx_bss_list_deinit(local);
 
 		flush_workqueue(local->hw.workqueue);
 
diff -Nurp kernel-2.6.28-20091602+0m5/net/mac80211/mlme.c kernel-2.6.28-20093908+0m5/net/mac80211/mlme.c
--- kernel-2.6.28-20091602+0m5/net/mac80211/mlme.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/mac80211/mlme.c	2012-12-16 13:13:01.740330145 +0100
@@ -34,7 +34,7 @@
 #define IEEE80211_ASSOC_TIMEOUT (HZ / 5)
 #define IEEE80211_ASSOC_MAX_TRIES 3
 #define IEEE80211_MONITORING_INTERVAL (2 * HZ)
-#define IEEE80211_PROBE_INTERVAL (60 * HZ)
+#define IEEE80211_PROBE_IDLE_TIME (60 * HZ)
 #define IEEE80211_RETRY_AUTH_INTERVAL (1 * HZ)
 #define IEEE80211_SCAN_INTERVAL (2 * HZ)
 #define IEEE80211_SCAN_INTERVAL_SLOW (15 * HZ)
@@ -45,8 +45,6 @@
 
 #define IEEE80211_IBSS_MAX_STA_ENTRIES 128
 
-#define IEEE80211_ROAMING_SIGNAL_THRESHOLD -75
-
 #define RSSI_HIGHSIGNAL "HIGHSIGNAL"
 #define RSSI_LOWSIGNAL "LOWSIGNAL"
 
@@ -729,6 +727,8 @@ static void ieee80211_set_associated(str
 		changed |= ieee80211_handle_bss_capability(sdata,
 			bss->capability, bss->has_erp_value, bss->erp_value);
 
+		bss->hold = true;
+
 		ieee80211_rx_bss_put(local, bss);
 	}
 
@@ -743,7 +743,7 @@ static void ieee80211_set_associated(str
 	memcpy(ifsta->prev_bssid, sdata->u.sta.bssid, ETH_ALEN);
 	ieee80211_sta_send_associnfo(sdata, ifsta);
 
-	ifsta->rssi_signal_state = RSSI_SIGNAL_STATE_HIGH;
+	ifsta->rssi_state = IEEE80211_RSSI_STATE_HIGH;
 	ifsta->roam_threshold_count = 0;
 
 	ifsta->last_probe = jiffies;
@@ -817,6 +817,7 @@ static void ieee80211_authenticate(struc
 		       " timed out\n",
 		       sdata->dev->name, print_mac(mac, ifsta->bssid));
 		ifsta->state = IEEE80211_STA_MLME_DISABLED;
+		ifsta->flags &= ~IEEE80211_STA_ASSOCIATED;
 		ieee80211_sta_send_apinfo(sdata, ifsta);
 		return;
 	}
@@ -835,6 +836,8 @@ static void ieee80211_set_disassoc(struc
 				   bool self_disconnected, u16 reason)
 {
 	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_conf *conf = &local_to_hw(local)->conf;
+	struct ieee80211_bss *bss;
 	struct sta_info *sta;
 	u32 changed = BSS_CHANGED_ASSOC;
 
@@ -858,6 +861,15 @@ static void ieee80211_set_disassoc(struc
 
 	ieee80211_sta_tear_down_BA_sessions(sdata, sta->sta.addr);
 
+	bss = ieee80211_rx_bss_get(local, ifsta->bssid,
+				   conf->channel->center_freq,
+				   ifsta->ssid, ifsta->ssid_len);
+
+	if (bss) {
+		bss->hold = false;
+		ieee80211_rx_bss_put(local, bss);
+	}
+
 	if (self_disconnected) {
 		if (deauth)
 			ieee80211_send_deauth_disassoc(sdata,
@@ -949,6 +961,7 @@ static void ieee80211_associate(struct i
 		       " timed out\n",
 		       sdata->dev->name, print_mac(mac, ifsta->bssid));
 		ifsta->state = IEEE80211_STA_MLME_DISABLED;
+		ifsta->flags &= ~IEEE80211_STA_ASSOCIATED;
 		ieee80211_sta_send_apinfo(sdata, ifsta);
 		return;
 	}
@@ -968,69 +981,104 @@ static void ieee80211_associate(struct i
 	mod_timer(&ifsta->timer, jiffies + IEEE80211_ASSOC_TIMEOUT);
 }
 
-static void ieee80211_rx_check_threshold(struct ieee80211_sub_if_data *sdata,
-					 int freq)
+void ieee80211_rssi_changed(struct ieee80211_vif *vif,
+			    enum ieee80211_rssi_state state)
 {
-	struct ieee80211_if_sta *ifsta = &sdata->u.sta;
-	enum rssi_signal_state uninitialized_var(new_state);
-	struct ieee80211_bss *bss;
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+	struct ieee80211_if_sta *ifsta = NULL;
 	const char *event = NULL;
 	union iwreq_data wrqu;
 	char *buf = NULL;
 
-	if (ifsta->state != IEEE80211_STA_MLME_ASSOCIATED)
-		return;
+	ifsta = &sdata->u.sta;
 
-	bss = ieee80211_rx_bss_get(sdata->local, ifsta->bssid, freq,
-				   ifsta->ssid, ifsta->ssid_len);
+	if (!ifsta || ifsta->state != IEEE80211_STA_MLME_ASSOCIATED)
+		return;
 
-	if (!bss)
+	if (ifsta->rssi_state == state)
 		return;
 
-	switch (ifsta->rssi_signal_state) {
-	case RSSI_SIGNAL_STATE_HIGH:
-		if (bss->signal < IEEE80211_ROAMING_SIGNAL_THRESHOLD) {
-			event = RSSI_LOWSIGNAL;
-			new_state = RSSI_SIGNAL_STATE_LOW;
-		}
+	ifsta->rssi_state = state;
+
+	switch (state) {
+	case IEEE80211_RSSI_STATE_HIGH:
+		event = RSSI_HIGHSIGNAL;
 		break;
-	case RSSI_SIGNAL_STATE_LOW:
-		if (bss->signal > IEEE80211_ROAMING_SIGNAL_THRESHOLD) {
-			event = RSSI_HIGHSIGNAL;
-			new_state = RSSI_SIGNAL_STATE_HIGH;
-		}
+	case IEEE80211_RSSI_STATE_LOW:
+		event = RSSI_LOWSIGNAL;
 		break;
 	default:
 		WARN_ON(1);
-		break;
+		return;
 	}
 
-	if (event) {
-		ifsta->roam_threshold_count++;
-		if (ifsta->roam_threshold_count >= 3) {
-			buf = kstrdup(event, GFP_ATOMIC);
-			printk(KERN_DEBUG "%s: roaming threshold exceeded, "
-			       "sending %s\n", sdata->dev->name, buf);
-			memset(&wrqu, 0, sizeof(wrqu));
-			wrqu.data.length = strlen(buf);
-			wireless_send_event(sdata->dev, IWEVCUSTOM, &wrqu,
-					    buf);
-			ifsta->rssi_signal_state = new_state;
-			ifsta->roam_threshold_count = 0;
-			kfree(buf);
-		}
-	} else
-		ifsta->roam_threshold_count = 0;
+	buf = kstrdup(event, GFP_ATOMIC);
+	printk(KERN_DEBUG "%s: roaming signal from driver, sending %s\n",
+	       sdata->dev->name, buf);
+	memset(&wrqu, 0, sizeof(wrqu));
+	wrqu.data.length = strlen(buf);
+	wireless_send_event(sdata->dev, IWEVCUSTOM, &wrqu, buf);
+	kfree(buf);
+}
+EXPORT_SYMBOL(ieee80211_rssi_changed);
+
+void ieee80211_sta_rx_notify(struct ieee80211_sub_if_data *sdata,
+			     struct ieee80211_hdr *hdr)
+{
+	/*
+	 * We can postpone the sta.timer whenever receiving unicast frames
+	 * from AP because we know that the connection is working both ways
+	 * at that time. But multicast frames (and hence also beacons) must
+	 * be ignored here, because we need to trigger the timer during
+	 * data idle periods for sending the periodical probe request to
+	 * the AP.
+	 */
+	if (!is_multicast_ether_addr(hdr->addr1))
+		mod_timer(&sdata->u.sta.timer,
+			  jiffies + IEEE80211_MONITORING_INTERVAL);
+}
+
+void ieee80211_beacon_loss_work(struct work_struct *work)
+{
+	struct ieee80211_sub_if_data *sdata =
+		container_of(work, struct ieee80211_sub_if_data,
+			     u.sta.beacon_loss_work);
+	struct ieee80211_if_sta *ifsta = &sdata->u.sta;
+	struct ieee80211_local *local = sdata->local;
+
+	printk(KERN_DEBUG "%s: driver reports beacon loss from AP %pM "
+	       "- sending probe request\n", sdata->dev->name,
+	       sdata->u.sta.bssid);
+
+	ifsta->flags |= IEEE80211_STA_PROBEREQ_POLL;
 
-	ieee80211_rx_bss_put(sdata->local, bss);
+	if (local->powersave) {
+		/* disable power save before sending the probe request */
+		local->hw.conf.flags &= ~IEEE80211_CONF_PS;
+		ieee80211_hw_config(local);
+	}
+
+	ieee80211_send_probe_req(sdata, ifsta->bssid, ifsta->ssid,
+				 ifsta->ssid_len);
+
+	mod_timer(&ifsta->timer, jiffies + IEEE80211_MONITORING_INTERVAL);
 }
 
+void ieee80211_beacon_loss(struct ieee80211_vif *vif)
+{
+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
+
+	queue_work(sdata->local->hw.workqueue,
+		   &sdata->u.sta.beacon_loss_work);
+}
+EXPORT_SYMBOL(ieee80211_beacon_loss);
+
 static void ieee80211_associated(struct ieee80211_sub_if_data *sdata,
 				 struct ieee80211_if_sta *ifsta)
 {
 	struct ieee80211_local *local = sdata->local;
 	struct sta_info *sta;
-	int disassoc;
+	bool disassoc = false, send_probe = false;
 	DECLARE_MAC_BUF(mac);
 
 	/* TODO: start monitoring current AP signal quality and number of
@@ -1044,38 +1092,59 @@ static void ieee80211_associated(struct
 
 	sta = sta_info_get(local, ifsta->bssid);
 	if (!sta) {
-		printk(KERN_DEBUG "%s: No STA entry for own AP %s\n",
-		       sdata->dev->name, print_mac(mac, ifsta->bssid));
-		disassoc = 1;
-	} else {
-		disassoc = 0;
-		if (time_after(jiffies,
-			       sta->last_rx + IEEE80211_MONITORING_INTERVAL)) {
-			if (ifsta->flags & IEEE80211_STA_PROBEREQ_POLL) {
-				printk(KERN_DEBUG "%s: No ProbeResp from "
-				       "current AP %s - assume out of "
-				       "range\n",
-				       sdata->dev->name, print_mac(mac, ifsta->bssid));
-				disassoc = 1;
-			} else
-				ieee80211_send_probe_req(sdata, ifsta->bssid,
-							 ifsta->ssid,
-							 ifsta->ssid_len);
-			ifsta->flags ^= IEEE80211_STA_PROBEREQ_POLL;
-		} else {
-			ifsta->flags &= ~IEEE80211_STA_PROBEREQ_POLL;
-			if (time_after(jiffies, ifsta->last_probe +
-				       IEEE80211_PROBE_INTERVAL)) {
-				ifsta->last_probe = jiffies;
-				ieee80211_send_probe_req(sdata, ifsta->bssid,
-							 ifsta->ssid,
-							 ifsta->ssid_len);
-			}
-		}
+		printk(KERN_DEBUG "%s: No STA entry for own AP %pM\n",
+		       sdata->dev->name, ifsta->bssid);
+		disassoc = true;
+		goto unlock;
+	}
+
+	if ((ifsta->flags & IEEE80211_STA_PROBEREQ_POLL) &&
+	    time_after(jiffies, sta->last_rx + IEEE80211_MONITORING_INTERVAL)) {
+		printk(KERN_DEBUG "%s: no probe response from AP %pM "
+		       "- disassociating\n",
+		       sdata->dev->name, ifsta->bssid);
+		disassoc = true;
+		ifsta->flags &= ~IEEE80211_STA_PROBEREQ_POLL;
+		goto unlock;
 	}
 
+	/*
+	 * Beacon filtering is only enabled with power save and then the
+	 * stack should not check for beacon loss.
+	 */
+	if (!((local->hw.flags & IEEE80211_HW_BEACON_FILTER) &&
+	      (local->hw.conf.flags & IEEE80211_CONF_PS)) &&
+	    time_after(jiffies,
+		       ifsta->last_beacon + IEEE80211_MONITORING_INTERVAL)) {
+		printk(KERN_DEBUG "%s: beacon loss from AP %pM "
+		       "- sending probe request\n",
+		       sdata->dev->name, ifsta->bssid);
+		ifsta->flags |= IEEE80211_STA_PROBEREQ_POLL;
+		send_probe = true;
+		goto unlock;
+
+	}
+
+	if (time_after(jiffies, sta->last_rx + IEEE80211_PROBE_IDLE_TIME)) {
+		ifsta->flags |= IEEE80211_STA_PROBEREQ_POLL;
+		send_probe = true;
+	}
+
+ unlock:
 	rcu_read_unlock();
 
+	/* config() can sleep so call it after unlock */
+	if (send_probe) {
+		if (local->powersave) {
+			/* disable ps before sending the probe request */
+			local->hw.conf.flags &= ~IEEE80211_CONF_PS;
+			ieee80211_hw_config(local);
+		}
+
+		ieee80211_send_probe_req(sdata, ifsta->bssid, ifsta->ssid,
+					 ifsta->ssid_len);
+	}
+
 	if (disassoc)
 		ieee80211_set_disassoc(sdata, ifsta, true, true,
 					WLAN_REASON_PREV_AUTH_NOT_VALID);
@@ -1453,6 +1522,12 @@ static void ieee80211_rx_mgmt_assoc_resp
 	bss_conf->assoc_capability = capab_info;
 	ieee80211_set_associated(sdata, ifsta);
 
+	/*
+	 * initialise the time of last beacon to be the association time,
+	 * otherwise beacon loss check will trigger immediately
+	 */
+	ifsta->last_beacon = jiffies;
+
 	ieee80211_associated(sdata, ifsta);
 }
 
@@ -1722,6 +1797,7 @@ static void ieee80211_rx_mgmt_probe_resp
 	size_t baselen;
 	struct ieee802_11_elems elems;
 	struct ieee80211_if_sta *ifsta = &sdata->u.sta;
+	struct ieee80211_local *local = sdata->local;
 
 	if (memcmp(mgmt->da, sdata->dev->dev_addr, ETH_ALEN))
 		return; /* ignore ProbeResp to foreign address */
@@ -1742,6 +1818,19 @@ static void ieee80211_rx_mgmt_probe_resp
 		       sdata->dev->name);
 		ieee80211_authenticate(sdata, ifsta);
 	}
+
+	if (ifsta->flags & IEEE80211_STA_PROBEREQ_POLL) {
+		if (local->powersave) {
+			/*
+			 * re-enable power save now that probe response was
+			 * received
+			 */
+			local->hw.conf.flags |= IEEE80211_CONF_PS;
+			ieee80211_hw_config(local);
+		}
+
+		ifsta->flags &= ~IEEE80211_STA_PROBEREQ_POLL;
+	}
 }
 
 
@@ -1800,7 +1889,6 @@ static void ieee80211_rx_mgmt_beacon(str
 					       &bss_info);
 	}
 
-	ieee80211_rx_check_threshold(sdata, rx_status->freq);
 	ieee80211_bss_info_change_notify(sdata, changed);
 }
 
@@ -2407,6 +2495,7 @@ void ieee80211_sta_setup_sdata(struct ie
 
 	ifsta = &sdata->u.sta;
 	INIT_WORK(&ifsta->work, ieee80211_sta_work);
+	INIT_WORK(&ifsta->beacon_loss_work, ieee80211_beacon_loss_work);
 	setup_timer(&ifsta->timer, ieee80211_sta_timer,
 		    (unsigned long) sdata);
 	skb_queue_head_init(&ifsta->skb_queue);
diff -Nurp kernel-2.6.28-20091602+0m5/net/mac80211/rc80211_minstrel.c kernel-2.6.28-20093908+0m5/net/mac80211/rc80211_minstrel.c
--- kernel-2.6.28-20091602+0m5/net/mac80211/rc80211_minstrel.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/mac80211/rc80211_minstrel.c	2012-12-16 13:13:01.740330145 +0100
@@ -389,13 +389,16 @@ minstrel_rate_init(void *priv, struct ie
 {
 	struct minstrel_sta_info *mi = priv_sta;
 	struct minstrel_priv *mp = priv;
-	struct minstrel_rate *mr_ctl;
+	struct ieee80211_local *local = hw_to_local(mp->hw);
+	struct ieee80211_rate *ctl_rate;
 	unsigned int i, n = 0;
 	unsigned int t_slot = 9; /* FIXME: get real slot time */
 
 	mi->lowest_rix = rate_lowest_index(sband, sta);
-	mr_ctl = &mi->r[rix_to_ndx(mi, mi->lowest_rix)];
-	mi->sp_ack_dur = mr_ctl->ack_time;
+	ctl_rate = &sband->bitrates[mi->lowest_rix];
+	mi->sp_ack_dur = ieee80211_frame_duration(local, 10, ctl_rate->bitrate,
+						  !!(ctl_rate->flags &
+						  IEEE80211_RATE_ERP_G), 1);
 
 	for (i = 0; i < sband->n_bitrates; i++) {
 		struct minstrel_rate *mr = &mi->r[n];
@@ -410,8 +413,7 @@ minstrel_rate_init(void *priv, struct ie
 
 		mr->rix = i;
 		mr->bitrate = sband->bitrates[i].bitrate / 5;
-		calc_rate_durations(mi, hw_to_local(mp->hw), mr,
-				&sband->bitrates[i]);
+		calc_rate_durations(mi, local, mr, &sband->bitrates[i]);
 
 		/* calculate maximum number of retransmissions before
 		 * fallback (based on maximum segment size) */
@@ -467,8 +469,8 @@ minstrel_alloc_sta(void *priv, struct ie
 		return NULL;
 
 	for (i = 0; i < IEEE80211_NUM_BANDS; i++) {
-		sband = hw->wiphy->bands[hw->conf.channel->band];
-		if (sband->n_bitrates > max_rates)
+		sband = hw->wiphy->bands[i];
+		if (sband && sband->n_bitrates > max_rates)
 			max_rates = sband->n_bitrates;
 	}
 
diff -Nurp kernel-2.6.28-20091602+0m5/net/mac80211/rx.c kernel-2.6.28-20093908+0m5/net/mac80211/rx.c
--- kernel-2.6.28-20091602+0m5/net/mac80211/rx.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/mac80211/rx.c	2012-12-16 13:13:01.740330145 +0100
@@ -733,12 +733,19 @@ ieee80211_rx_h_sta_process(struct ieee80
 		 * Mesh beacons will update last_rx when if they are found to
 		 * match the current local configuration when processed.
 		 */
-		sta->last_rx = jiffies;
+		if (rx->sdata->vif.type == NL80211_IFTYPE_STATION &&
+		    ieee80211_is_beacon(hdr->frame_control)) {
+			rx->sdata->u.sta.last_beacon = jiffies;
+		} else
+			sta->last_rx = jiffies;
 	}
 
 	if (!(rx->flags & IEEE80211_RX_RA_MATCH))
 		return RX_CONTINUE;
 
+	if (rx->sdata->vif.type == NL80211_IFTYPE_STATION)
+		ieee80211_sta_rx_notify(rx->sdata, hdr);
+
 	sta->rx_fragments++;
 	sta->rx_bytes += rx->skb->len;
 	sta->last_signal = rx->status->signal;
diff -Nurp kernel-2.6.28-20091602+0m5/net/mac80211/scan.c kernel-2.6.28-20093908+0m5/net/mac80211/scan.c
--- kernel-2.6.28-20091602+0m5/net/mac80211/scan.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/mac80211/scan.c	2012-12-16 13:13:01.740330145 +0100
@@ -759,7 +759,12 @@ ieee80211_scan_result(struct ieee80211_l
 	struct iw_event iwe;
 	char *buf;
 
-	if (time_after(jiffies,
+	/*
+	 * we don't return old entries, unless the bss is in hold state due
+	 * to beacon filter
+	 */
+	if (!bss->hold &&
+	    time_after(jiffies,
 		       bss->last_update + IEEE80211_SCAN_RESULT_EXPIRE))
 		return current_ev;
 
diff -Nurp kernel-2.6.28-20091602+0m5/net/mac80211/sta_info.c kernel-2.6.28-20093908+0m5/net/mac80211/sta_info.c
--- kernel-2.6.28-20091602+0m5/net/mac80211/sta_info.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/mac80211/sta_info.c	2012-12-16 13:13:01.740330145 +0100
@@ -538,7 +538,7 @@ static inline int sta_info_buffer_expire
 }
 
 
-static void sta_info_cleanup_expire_buffered(struct ieee80211_local *local,
+static bool sta_info_cleanup_expire_buffered(struct ieee80211_local *local,
 					     struct sta_info *sta)
 {
 	unsigned long flags;
@@ -547,7 +547,7 @@ static void sta_info_cleanup_expire_buff
 	DECLARE_MAC_BUF(mac);
 
 	if (skb_queue_empty(&sta->ps_tx_buf))
-		return;
+		return false;
 
 	for (;;) {
 		spin_lock_irqsave(&sta->ps_tx_buf.lock, flags);
@@ -572,6 +572,8 @@ static void sta_info_cleanup_expire_buff
 		if (skb_queue_empty(&sta->ps_tx_buf))
 			sta_info_clear_tim_bit(sta);
 	}
+
+	return true;
 }
 
 
@@ -579,15 +581,22 @@ static void sta_info_cleanup(unsigned lo
 {
 	struct ieee80211_local *local = (struct ieee80211_local *) data;
 	struct sta_info *sta;
+	bool need_timer = false;
 
 	rcu_read_lock();
-	list_for_each_entry_rcu(sta, &local->sta_list, list)
-		sta_info_cleanup_expire_buffered(local, sta);
+	list_for_each_entry_rcu(sta, &local->sta_list, list) {
+		bool res = sta_info_cleanup_expire_buffered(local, sta);
+		if (res)
+			need_timer = true;
+	}
 	rcu_read_unlock();
 
-	local->sta_cleanup.expires =
-		round_jiffies(jiffies + STA_INFO_CLEANUP_INTERVAL);
-	add_timer(&local->sta_cleanup);
+	/* If the queues are empty, don't add a new timer */
+	if (need_timer) {
+		local->sta_cleanup.expires =
+			round_jiffies(jiffies + STA_INFO_CLEANUP_INTERVAL);
+		add_timer(&local->sta_cleanup);
+	}
 }
 
 #ifdef CONFIG_MAC80211_DEBUGFS
diff -Nurp kernel-2.6.28-20091602+0m5/net/mac80211/tx.c kernel-2.6.28-20093908+0m5/net/mac80211/tx.c
--- kernel-2.6.28-20091602+0m5/net/mac80211/tx.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/mac80211/tx.c	2012-12-16 13:13:01.740330145 +0100
@@ -330,6 +330,7 @@ ieee80211_tx_h_unicast_ps_buf(struct iee
 	struct sta_info *sta = tx->sta;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;
+	struct ieee80211_local *local = tx->local;
 	u32 staflags;
 	DECLARE_MAC_BUF(mac);
 
@@ -367,6 +368,8 @@ ieee80211_tx_h_unicast_ps_buf(struct iee
 
 		info->control.jiffies = jiffies;
 		skb_queue_tail(&sta->ps_tx_buf, tx->skb);
+		mod_timer(&local->sta_cleanup,
+			  round_jiffies(jiffies + STA_INFO_CLEANUP_INTERVAL));
 		return TX_QUEUED;
 	}
 #ifdef CONFIG_MAC80211_VERBOSE_PS_DEBUG
diff -Nurp kernel-2.6.28-20091602+0m5/net/phonet/pep.c kernel-2.6.28-20093908+0m5/net/phonet/pep.c
--- kernel-2.6.28-20091602+0m5/net/phonet/pep.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/phonet/pep.c	2012-12-16 13:13:01.744330144 +0100
@@ -368,6 +368,14 @@ static int pipe_do_rcv(struct sock *sk,
 			break;
 		}
 		pn->rx_credits--;
+		if (pn->rx_fc == PN_MULTI_CREDIT_FLOW_CONTROL) {
+			if (pn->rx_credits == 0)
+				printk(KERN_ERR"pn_pep: RX congestion\n");
+			else if (pn->rx_credits < (CREDITS_MAX - CREDITS_THR))
+				printk(KERN_WARNING
+					"pn_pep: %u RX credits left\n",
+					pn->rx_credits);
+		}
 		queue = &sk->sk_receive_queue;
 		goto queue;
 
diff -Nurp kernel-2.6.28-20091602+0m5/net/phonet/pep-gprs.c kernel-2.6.28-20093908+0m5/net/phonet/pep-gprs.c
--- kernel-2.6.28-20091602+0m5/net/phonet/pep-gprs.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/phonet/pep-gprs.c	2012-12-16 13:13:01.744330144 +0100
@@ -212,8 +212,9 @@ static int gprs_xmit(struct sk_buff *skb
 		dev->stats.tx_bytes += len;
 	}
 
-	if (!pep_writeable(sk))
-		netif_stop_queue(dev);
+	netif_stop_queue(dev);
+	if (pep_writeable(sk))
+		netif_wake_queue(dev);
 	return 0;
 }
 
diff -Nurp kernel-2.6.28-20091602+0m5/net/socket.c kernel-2.6.28-20093908+0m5/net/socket.c
--- kernel-2.6.28-20091602+0m5/net/socket.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/socket.c	2012-12-16 13:13:01.744330144 +0100
@@ -695,7 +695,7 @@ static ssize_t sock_sendpage(struct file
 	if (more)
 		flags |= MSG_MORE;
 
-	return sock->ops->sendpage(sock, page, offset, size, flags);
+	return kernel_sendpage(sock, page, offset, size, flags);
 }
 
 static ssize_t sock_splice_read(struct file *file, loff_t *ppos,
diff -Nurp kernel-2.6.28-20091602+0m5/net/wireless/nl80211.c kernel-2.6.28-20093908+0m5/net/wireless/nl80211.c
--- kernel-2.6.28-20091602+0m5/net/wireless/nl80211.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/net/wireless/nl80211.c	2012-12-16 13:13:01.744330144 +0100
@@ -619,7 +619,7 @@ static int nl80211_get_key(struct sk_buf
 
 	if (IS_ERR(hdr)) {
 		err = PTR_ERR(hdr);
-		goto out;
+		goto free_msg;
 	}
 
 	cookie.msg = msg;
@@ -635,7 +635,7 @@ static int nl80211_get_key(struct sk_buf
 	rtnl_unlock();
 
 	if (err)
-		goto out;
+		goto free_msg;
 
 	if (cookie.error)
 		goto nla_put_failure;
@@ -646,6 +646,7 @@ static int nl80211_get_key(struct sk_buf
 
  nla_put_failure:
 	err = -ENOBUFS;
+ free_msg:
 	nlmsg_free(msg);
  out:
 	cfg80211_put_dev(drv);
diff -Nurp kernel-2.6.28-20091602+0m5/security/device_cgroup.c kernel-2.6.28-20093908+0m5/security/device_cgroup.c
--- kernel-2.6.28-20091602+0m5/security/device_cgroup.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/security/device_cgroup.c	2012-12-16 13:13:01.744330144 +0100
@@ -513,6 +513,9 @@ int devcgroup_inode_mknod(int mode, dev_
 	struct dev_cgroup *dev_cgroup;
 	struct dev_whitelist_item *wh;
 
+	if (!S_ISBLK(mode) && !S_ISCHR(mode))
+		return 0;
+
 	rcu_read_lock();
 
 	dev_cgroup = task_devcgroup(current);
diff -Nurp kernel-2.6.28-20091602+0m5/sound/soc/codecs/tlv320aic3x.c kernel-2.6.28-20093908+0m5/sound/soc/codecs/tlv320aic3x.c
--- kernel-2.6.28-20091602+0m5/sound/soc/codecs/tlv320aic3x.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/sound/soc/codecs/tlv320aic3x.c	2012-12-16 13:13:01.744330144 +0100
@@ -55,6 +55,7 @@
 struct aic3x_priv {
 	unsigned int sysclk;
 	int master;
+	int prepare_reset;
 };
 
 /*
@@ -72,7 +73,7 @@ static const u8 aic3x_reg[AIC3X_CACHEREG
 	0x78, 0x78, 0x78, 0x78,	/* 20 */
 	0x78, 0x00, 0x00, 0xfe,	/* 24 */
 	0x00, 0x00, 0xfe, 0x00,	/* 28 */
-	0x18, 0x18, 0x00, 0x00,	/* 32 */
+	0x00, 0x00, 0x00, 0x00,	/* 32 */
 	0x00, 0x00, 0x00, 0x00,	/* 36 */
 	0x00, 0x00, 0x00, 0x80,	/* 40 */
 	0x80, 0x00, 0x00, 0x00,	/* 44 */
@@ -145,6 +146,10 @@ static int aic3x_read(struct snd_soc_cod
 		      u8 *value)
 {
 	*value = reg & 0xff;
+
+	/* No read access is recommended if the chip is reset after use */
+	printk(KERN_ERR "%s(): Values are may be incorrect!\n", __func__);
+
 	if (codec->hw_read(codec->control_data, value, 1) != 1)
 		return -EIO;
 
@@ -152,6 +157,25 @@ static int aic3x_read(struct snd_soc_cod
 	return 0;
 }
 
+/*
+ * Reset for getting low power consumption after bypass paths
+ */
+static void aic3x_reset(struct snd_soc_codec *codec)
+{
+	u8 *cache = codec->reg_cache;
+	u8 data[2];
+	int i;
+
+	aic3x_write(codec, AIC3X_RESET, SOFT_RESET);
+
+	/* We do not rewrite page select nor reset again */
+	for (i = AIC3X_SAMPLE_RATE_SEL_REG; i < ARRAY_SIZE(aic3x_reg); i++) {
+		data[0] = i;
+		data[1] = cache[i];
+		codec->hw_write(codec->control_data, data, 2);
+	}
+}
+
 #define SOC_DAPM_SINGLE_AIC3X(xname, reg, shift, mask, invert) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
 	.info = snd_soc_info_volsw, \
@@ -257,6 +281,8 @@ static const struct soc_enum aic3x_enum[
 static DECLARE_TLV_DB_SCALE(dac_tlv, -6350, 50, 0);
 /* ADC PGA gain volumes. From 0 to 59.5 dB in 0.5 dB steps */
 static DECLARE_TLV_DB_SCALE(adc_tlv, 0, 50, 0);
+/* HP DAC Output gain values. From 0 to 9.0 dB in 1 dB steps */
+static DECLARE_TLV_DB_SCALE(hpout_tlv, 0, 100, 0);
 /*
  * Output stage volumes. From -78.3 to 0 dB. Muted below -78.3 dB.
  * Step size is approximately 0.5 dB over most of the scale but increasing
@@ -301,6 +327,8 @@ static const struct snd_kcontrol_new aic
 			 0, 118, 1, output_stage_tlv),
 	SOC_DOUBLE_R("HP DAC Playback Switch", HPLOUT_CTRL, HPROUT_CTRL, 3,
 		     0x01, 0),
+	SOC_DOUBLE_R_TLV("HP DAC Output Volume", HPLOUT_CTRL, HPROUT_CTRL, 4,
+			 9, 0, hpout_tlv),
 	SOC_DOUBLE_R_TLV("HP PGA Bypass Playback Volume",
 			 PGAL_2_HPLOUT_VOL, PGAR_2_HPROUT_VOL,
 			 0, 118, 1, output_stage_tlv),
@@ -313,6 +341,8 @@ static const struct snd_kcontrol_new aic
 			 0, 118, 1, output_stage_tlv),
 	SOC_DOUBLE_R("HPCOM DAC Playback Switch", HPLCOM_CTRL, HPRCOM_CTRL, 3,
 		     0x01, 0),
+	SOC_DOUBLE_R_TLV("HPCOM DAC Output Volume", HPLCOM_CTRL, HPRCOM_CTRL,
+			 4, 9, 0, hpout_tlv),
 	SOC_DOUBLE_R_TLV("HPCOM PGA Bypass Playback Volume",
 			 PGAL_2_HPLCOM_VOL, PGAR_2_HPRCOM_VOL,
 			 0, 118, 1, output_stage_tlv),
@@ -350,6 +380,59 @@ static int aic3x_add_controls(struct snd
 	return 0;
 }
 
+static int reset_after_bypass(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *kcontrol, int event)
+{
+	struct aic3x_priv *aic3x = w->codec->private_data;
+	struct soc_mixer_control *mc = NULL;
+	unsigned int reg = 0;
+
+	if (kcontrol)
+		mc = (struct soc_mixer_control *)kcontrol->private_value;
+	if (mc)
+		reg = mc->reg;
+
+	if (reg == PGAL_2_LLOPM_VOL || reg == PGAR_2_RLOPM_VOL ||
+	    reg == PGAL_2_HPLOUT_VOL || reg == PGAR_2_HPROUT_VOL) {
+		if (w->value & 0x80) {
+			/* Prepare reset on the chip */
+			if (reg == PGAL_2_LLOPM_VOL)
+				aic3x->prepare_reset |= 0x01;
+			else if (reg == PGAR_2_RLOPM_VOL)
+				aic3x->prepare_reset |= 0x02;
+			else if (reg == PGAL_2_HPLOUT_VOL)
+				aic3x->prepare_reset |= 0x04;
+			else if (reg == PGAR_2_HPROUT_VOL)
+				aic3x->prepare_reset |= 0x08;
+		} else {
+			if (aic3x->prepare_reset) {
+				if (reg == PGAL_2_LLOPM_VOL)
+					aic3x->prepare_reset &= ~0x01;
+				else if (reg == PGAR_2_RLOPM_VOL)
+					aic3x->prepare_reset &= ~0x02;
+				else if (reg == PGAL_2_HPLOUT_VOL)
+					aic3x->prepare_reset &= ~0x04;
+				else if (reg == PGAR_2_HPROUT_VOL)
+					aic3x->prepare_reset &= ~0x08;
+				/*
+				 * Controls may have now been turned off,
+				 * once they were on, so schedule or
+				 * issue a reset on the chip.
+				 */
+				if (!aic3x->prepare_reset) {
+					if (!((w->codec->bias_level ==
+						SND_SOC_BIAS_ON) ||
+						(w->codec->bias_level ==
+						SND_SOC_BIAS_PREPARE)))
+						aic3x_reset(w->codec);
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
 /* Left DAC Mux */
 static const struct snd_kcontrol_new aic3x_left_dac_mux_controls =
 SOC_DAPM_ENUM("Route", aic3x_enum[LDAC_ENUM]);
@@ -528,14 +611,16 @@ static const struct snd_soc_dapm_widget
 			 MICBIAS_CTRL, 6, 3, 3, 0),
 
 	/* Left PGA to Left Output bypass */
-	SND_SOC_DAPM_MIXER("Left PGA Bypass Mixer", SND_SOC_NOPM, 0, 0,
+	SND_SOC_DAPM_MIXER_E("Left PGA Bypass Mixer", SND_SOC_NOPM, 0, 0,
 			   &aic3x_left_pga_bp_mixer_controls[0],
-			   ARRAY_SIZE(aic3x_left_pga_bp_mixer_controls)),
+			   ARRAY_SIZE(aic3x_left_pga_bp_mixer_controls),
+			   reset_after_bypass, SND_SOC_DAPM_POST_REG),
 
 	/* Right PGA to Right Output bypass */
-	SND_SOC_DAPM_MIXER("Right PGA Bypass Mixer", SND_SOC_NOPM, 0, 0,
+	SND_SOC_DAPM_MIXER_E("Right PGA Bypass Mixer", SND_SOC_NOPM, 0, 0,
 			   &aic3x_right_pga_bp_mixer_controls[0],
-			   ARRAY_SIZE(aic3x_right_pga_bp_mixer_controls)),
+			   ARRAY_SIZE(aic3x_right_pga_bp_mixer_controls),
+			   reset_after_bypass, SND_SOC_DAPM_POST_REG),
 
 	/* Left Line2 to Left Output bypass */
 	SND_SOC_DAPM_MIXER("Left Line2 Bypass Mixer", SND_SOC_NOPM, 0, 0,
@@ -887,7 +972,8 @@ static int aic3x_set_dai_fmt(struct snd_
 {
 	struct snd_soc_codec *codec = codec_dai->codec;
 	struct aic3x_priv *aic3x = codec->private_data;
-	u8 iface_areg, iface_breg, iface_creg = 0;
+	u8 iface_areg, iface_breg;
+	int delay = 0;
 
 	iface_areg = aic3x_read_reg_cache(codec, AIC3X_ASD_INTF_CTRLA) & 0x3f;
 	iface_breg = aic3x_read_reg_cache(codec, AIC3X_ASD_INTF_CTRLB) & 0x3f;
@@ -913,6 +999,8 @@ static int aic3x_set_dai_fmt(struct snd_
 		       SND_SOC_DAIFMT_INV_MASK)) {
 	case (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF):
 		break;
+	case (SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_IB_NF):
+		delay = 1;
 	case (SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF):
 		iface_breg |= (0x01 << 6);
 		break;
@@ -922,10 +1010,6 @@ static int aic3x_set_dai_fmt(struct snd_
 	case (SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_NB_NF):
 		iface_breg |= (0x03 << 6);
 		break;
-	case (SND_SOC_DAIFMT_DSP | SND_SOC_DAIFMT_NB_NF):
-		iface_breg |= (0x01 << 6);
-		iface_creg = 0x01;
-		break;
 	default:
 		return -EINVAL;
 	}
@@ -933,7 +1017,7 @@ static int aic3x_set_dai_fmt(struct snd_
 	/* set iface */
 	aic3x_write(codec, AIC3X_ASD_INTF_CTRLA, iface_areg);
 	aic3x_write(codec, AIC3X_ASD_INTF_CTRLB, iface_breg);
-	aic3x_write(codec, AIC3X_ASD_INTF_CTRLC, iface_creg);
+	aic3x_write(codec, AIC3X_ASD_INTF_CTRLC, delay);
 
 	return 0;
 }
@@ -975,6 +1059,9 @@ static int aic3x_set_bias_level(struct s
 			aic3x_write(codec, AIC3X_PLL_PROGA_REG,
 				    reg & ~PLL_ENABLE);
 		}
+		/* Reset cannot be issued, if bypass paths are in use */
+		if (!aic3x->prepare_reset)
+			aic3x_reset(codec);
 		break;
 	case SND_SOC_BIAS_OFF:
 		/* force all power off */
@@ -1080,7 +1167,7 @@ static int aic3x_suspend(struct platform
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
 	struct snd_soc_codec *codec = socdev->codec;
 
-	aic3x_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	aic3x_write(codec, AIC3X_RESET, SOFT_RESET);
 
 	return 0;
 }
@@ -1381,7 +1468,8 @@ static int aic3x_remove(struct platform_
 	snd_soc_free_pcms(socdev);
 	snd_soc_dapm_free(socdev);
 #if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
-	i2c_unregister_device(codec->control_data);
+	if (codec->control_data)
+		i2c_unregister_device(codec->control_data);
 	i2c_del_driver(&aic3x_i2c_driver);
 #endif
 	kfree(codec->private_data);
diff -Nurp kernel-2.6.28-20091602+0m5/sound/soc/omap/aic34b_dummy.c kernel-2.6.28-20093908+0m5/sound/soc/omap/aic34b_dummy.c
--- kernel-2.6.28-20091602+0m5/sound/soc/omap/aic34b_dummy.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/sound/soc/omap/aic34b_dummy.c	2012-12-16 13:13:01.744330144 +0100
@@ -37,6 +37,13 @@
 #include "../codecs/tlv320aic3x.h"
 
 struct i2c_client *aic34b_client;
+static DEFINE_MUTEX(aic34b_mutex);
+static DEFINE_MUTEX(button_press_mutex);
+static ktime_t button_press_denial_start;
+static int aic34b_volume;
+static int button_press_denied;
+static int aic34b_bias;
+
 
 static int aic34b_read(struct i2c_client *client, unsigned int reg,
 		       u8 *value)
@@ -59,12 +66,71 @@ static int aic34b_write(struct i2c_clien
 	return (i2c_master_send(client, data, 2) == 2) ? 0 : -EIO;
 }
 
+/*
+ * Introduce a derivative FIR filter to detect unnecessary button
+ * presses caused by a change in the MICBIAS. The filter returns
+ * TRUE in the event there has not been a change in MICBIAS within
+ * the time window (500ms). If the rate of change within the window
+ * is >= 1, all button presses are denied. In addition, if bias is
+ * zero, then all button presses are also denied explicitly.
+ */
+int allow_button_press(void)
+{
+	/* If bias is not on, no chance for button presses */
+	if (!aic34b_bias)
+		return 0;
+
+	/* If explicitly granted a button press */
+	if (!button_press_denied) {
+		return 1;
+	} else	{
+		int64_t delta;
+		/* This is the FIR portion with specified time window */
+		mutex_lock(&button_press_mutex);
+		delta = ktime_to_ns(ktime_sub(ktime_get(),
+					button_press_denial_start));
+
+		if (delta < 0) {
+			button_press_denied = 0;
+			/* If the clock ever wraps */
+			button_press_denial_start.tv.sec = 0;
+			button_press_denial_start.tv.nsec = 0;
+			mutex_unlock(&button_press_mutex);
+			return 1;
+		}
+		do_div(delta, 1000000);
+		/* Time window is 500ms */
+		if (delta >= 500) {
+			button_press_denied = 0;
+			mutex_unlock(&button_press_mutex);
+			return 1;
+		}
+		mutex_unlock(&button_press_mutex);
+	}
+
+	/* There was a change in MICBIAS within time window */
+	return 0;
+}
+EXPORT_SYMBOL(allow_button_press);
+
+static void deny_button_press(void)
+{
+	mutex_lock(&button_press_mutex);
+	button_press_denied = 1;
+	button_press_denial_start = ktime_get();
+	mutex_unlock(&button_press_mutex);
+}
+
 void aic34b_set_mic_bias(int bias)
 {
 	if (aic34b_client == NULL)
 		return;
 
+	mutex_lock(&aic34b_mutex);
 	aic34b_write(aic34b_client, MICBIAS_CTRL, (bias & 0x3) << 6);
+	aic34b_bias = bias;
+	deny_button_press();
+	mutex_unlock(&aic34b_mutex);
 }
 EXPORT_SYMBOL(aic34b_set_mic_bias);
 
@@ -75,6 +141,8 @@ int aic34b_set_volume(u8 volume)
 	if (aic34b_client == NULL)
 		return 0;
 
+	mutex_lock(&aic34b_mutex);
+
 	/* Volume control for Right PGA to HPLOUT */
 	aic34b_read(aic34b_client, 49, &val);
 	val &= ~0x7f;
@@ -85,6 +153,9 @@ int aic34b_set_volume(u8 volume)
 	val &= ~0x7f;
 	aic34b_write(aic34b_client, 56, val | (~volume & 0x7f));
 
+	aic34b_volume = volume;
+	mutex_unlock(&aic34b_mutex);
+
 	return 0;
 }
 EXPORT_SYMBOL(aic34b_set_volume);
@@ -96,6 +167,7 @@ void aic34b_ear_enable(int enable)
 	if (aic34b_client == NULL)
 		return;
 
+	mutex_lock(&aic34b_mutex);
 	if (enable) {
 		/* Connect LINE2R to RADC */
 		aic34b_write(aic34b_client, LINE2R_2_RADC_CTRL, 0x80);
@@ -117,16 +189,26 @@ void aic34b_ear_enable(int enable)
 		/* Mute Right ADC-PGA */
 		aic34b_write(aic34b_client, RADC_VOL, 0x80);
 		/* Detach Right PGA from HPLOUT */
-		aic34b_read(aic34b_client, 49, &val);
-		aic34b_write(aic34b_client, 49, val & ~0x80);
+		aic34b_write(aic34b_client, 49, (~aic34b_volume & 0x7f));
 		/* Power down HPLOUT */
 		aic34b_write(aic34b_client, HPLOUT_CTRL, 0x06);
 		/* Detach Right PGA from HPLCOM */
-		aic34b_read(aic34b_client, 56, &val);
-		aic34b_write(aic34b_client, 56, val & ~0x80);
+		aic34b_write(aic34b_client, 56, (~aic34b_volume & 0x7f));
 		/* Power down HPLCOM */
 		aic34b_write(aic34b_client, HPLCOM_CTRL, 0x06);
+		/* Deny any possible keypresses for a second */
+		deny_button_press();
+		/* To regain low power consumption, reset is needed */
+		aic34b_write(aic34b_client, AIC3X_RESET, SOFT_RESET);
+		/* And need to restore volume level */
+		aic34b_write(aic34b_client, 49, (~aic34b_volume & 0x7f));
+		aic34b_write(aic34b_client, 56, (~aic34b_volume & 0x7f));
+		/* Need to restore MICBIAS if set */
+		if (aic34b_bias)
+			aic34b_write(aic34b_client, MICBIAS_CTRL,
+					(aic34b_bias & 0x3) << 6);
 	}
+	mutex_unlock(&aic34b_mutex);
 }
 EXPORT_SYMBOL(aic34b_ear_enable);
 
diff -Nurp kernel-2.6.28-20091602+0m5/sound/soc/omap/omap-mcbsp.c kernel-2.6.28-20093908+0m5/sound/soc/omap/omap-mcbsp.c
--- kernel-2.6.28-20091602+0m5/sound/soc/omap/omap-mcbsp.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/sound/soc/omap/omap-mcbsp.c	2012-12-16 13:13:01.744330144 +0100
@@ -204,8 +204,9 @@ static int omap_mcbsp_dai_hw_params(stru
 	struct omap_mcbsp_data *mcbsp_data = to_mcbsp(cpu_dai->private_data);
 	struct omap_mcbsp_reg_cfg *regs = &mcbsp_data->regs;
 	int dma, bus_id = mcbsp_data->bus_id, id = cpu_dai->id;
-	int wlen, channels;
+	int wlen, channels, wpf;
 	unsigned long port;
+	unsigned int format;
 
 	if (cpu_class_is_omap1()) {
 		dma = omap1_dma_reqs[bus_id][substream->stream];
@@ -233,26 +234,25 @@ static int omap_mcbsp_dai_hw_params(stru
 		return 0;
 	}
 
-	channels = params_channels(params);
+	format = mcbsp_data->fmt & SND_SOC_DAIFMT_FORMAT_MASK;
+	wpf = channels = params_channels(params);
 	switch (channels) {
 	case 2:
-		/* Use dual-phase frames */
-		if ((mcbsp_data->fmt & SND_SOC_DAIFMT_FORMAT_MASK) == \
-			SND_SOC_DAIFMT_DSP) {
-			regs->rcr1	|= RFRLEN1(2 - 1);
-			regs->xcr1	|= XFRLEN1(2 - 1);
-			break;
-		} else {
+		if (format == SND_SOC_DAIFMT_I2S ||
+		    format == SND_SOC_DAIFMT_LEFT_J) {
 			/* Use dual-phase frames */
 			regs->rcr2	|= RPHASE;
 			regs->xcr2	|= XPHASE;
+			/* Set 1 word per (McBSP) frame for phase1 and phase2 */
+			wpf--;
+			regs->rcr2	|= RFRLEN2(wpf - 1);
+			regs->xcr2	|= XFRLEN2(wpf - 1);
 		}
 	case 1:
-		/* Set 1 word per (McBSP) frame */
-		regs->rcr2	|= RFRLEN2(1 - 1);
-		regs->rcr1	|= RFRLEN1(1 - 1);
-		regs->xcr2	|= XFRLEN2(1 - 1);
-		regs->xcr1	|= XFRLEN1(1 - 1);
+	case 4:
+		/* Set word per (McBSP) frame for phase1 */
+		regs->rcr1	|= RFRLEN1(wpf - 1);
+		regs->xcr1	|= XFRLEN1(wpf - 1);
 		break;
 	default:
 		/* Unsupported number of channels */
@@ -274,16 +274,14 @@ static int omap_mcbsp_dai_hw_params(stru
 	}
 
 	/* Set FS period and length in terms of bit clock periods */
-	switch (mcbsp_data->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	switch (format) {
 	case SND_SOC_DAIFMT_I2S:
+	case SND_SOC_DAIFMT_LEFT_J:
 		regs->srgr2	|= FPER(wlen * 2 - 1);
 		regs->srgr1	|= FWID(wlen - 1);
 		break;
 	case SND_SOC_DAIFMT_DSP_A:
-		regs->srgr2	|= FPER(wlen * channels - 1);
-		regs->srgr1	|= FWID(wlen * channels - 2);
-		break;
-	case SND_SOC_DAIFMT_DSP:
+	case SND_SOC_DAIFMT_DSP_B:
 		regs->srgr2	|= FPER(wlen * channels - 1);
 		regs->srgr1	|= FWID(0);
 		break;
@@ -304,6 +302,7 @@ static int omap_mcbsp_dai_set_dai_fmt(st
 {
 	struct omap_mcbsp_data *mcbsp_data = to_mcbsp(cpu_dai->private_data);
 	struct omap_mcbsp_reg_cfg *regs = &mcbsp_data->regs;
+	unsigned int temp_fmt = fmt;
 
 	if (mcbsp_data->configured)
 		return 0;
@@ -327,19 +326,28 @@ static int omap_mcbsp_dai_set_dai_fmt(st
 		regs->rccr	|= RFULL_CYCLE | RDMAEN | RDISABLE;
 		regs->xccr	|= (DXENDLY(1) | XDMAEN | XDISABLE);
 		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		regs->rcr2	|= RDATDLY(0);
+		regs->xcr2	|= XDATDLY(0);
+		regs->spcr1	|= RJUST(2);
+		regs->rccr	|= RFULL_CYCLE | RDMAEN | RDISABLE;
+		regs->xccr	|= (DXENDLY(1) | XDMAEN | XDISABLE);
+		break;
 	case SND_SOC_DAIFMT_DSP_A:
-		/* 0-bit data delay */
-		regs->rcr2      |= RDATDLY(0);
-		regs->xcr2      |= XDATDLY(0);
+		/* 1-bit data delay */
+		regs->rcr2      |= RDATDLY(1);
+		regs->xcr2      |= XDATDLY(1);
 		regs->rccr	|= RFULL_CYCLE | RDMAEN | RDISABLE;
 		regs->xccr	|= (DXENDLY(1) | XDMAEN | XDISABLE);
+		temp_fmt ^= SND_SOC_DAIFMT_NB_IF;
 		break;
-	case SND_SOC_DAIFMT_DSP:
+	case SND_SOC_DAIFMT_DSP_B:
+		/* 0-bit data delay */
 		regs->rcr2      |= RDATDLY(0);
 		regs->xcr2      |= XDATDLY(0);
-		regs->rccr	|= RDMAEN | RDISABLE;
-		regs->xccr	|= (DXENDLY(1) | XFULL_CYCLE | XDMAEN \
-					| XDISABLE);
+		regs->rccr	|= RFULL_CYCLE | RDMAEN | RDISABLE;
+		regs->xccr	|= (DXENDLY(1) | XDMAEN | XDISABLE);
+		temp_fmt ^= SND_SOC_DAIFMT_NB_IF;
 		break;
 	default:
 		/* Unsupported data format */
@@ -363,7 +371,7 @@ static int omap_mcbsp_dai_set_dai_fmt(st
 	}
 
 	/* Set bit clock (CLKX/CLKR) and FS polarities */
-	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	switch (temp_fmt & SND_SOC_DAIFMT_INV_MASK) {
 	case SND_SOC_DAIFMT_NB_NF:
 		/*
 		 * Normal BCLK + FS.
@@ -491,13 +499,13 @@ static int omap_mcbsp_dai_set_dai_sysclk
 	.type = SND_SOC_DAI_I2S,				\
 	.playback = {						\
 		.channels_min = 1,				\
-		.channels_max = 2,				\
+		.channels_max = 4,				\
 		.rates = OMAP_MCBSP_RATES,			\
 		.formats = SNDRV_PCM_FMTBIT_S16_LE,		\
 	},							\
 	.capture = {						\
 		.channels_min = 1,				\
-		.channels_max = 2,				\
+		.channels_max = 4,				\
 		.rates = OMAP_MCBSP_RATES,			\
 		.formats = SNDRV_PCM_FMTBIT_S16_LE,		\
 	},							\
diff -Nurp kernel-2.6.28-20091602+0m5/sound/soc/omap/omap-pcm.c kernel-2.6.28-20093908+0m5/sound/soc/omap/omap-pcm.c
--- kernel-2.6.28-20091602+0m5/sound/soc/omap/omap-pcm.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/sound/soc/omap/omap-pcm.c	2012-12-16 13:13:01.744330144 +0100
@@ -49,6 +49,7 @@ struct omap_runtime_data {
 	struct omap_pcm_dma_data	*dma_data;
 	int				dma_ch;
 	int				period_index;
+	int				dma_op_mode;
 };
 
 static void omap_pcm_dma_irq(int ch, u16 stat, void *data)
@@ -97,7 +98,7 @@ static int omap_pcm_hw_params(struct snd
 	prtd->dma_data = dma_data;
 	err = omap_request_dma(dma_data->dma_req, dma_data->name,
 			       omap_pcm_dma_irq, substream, &prtd->dma_ch);
-	if (!err & !cpu_is_omap1510()) {
+	if (!err && !cpu_is_omap1510()) {
 		/*
 		 * Link channel with itself so DMA doesn't need any
 		 * reprogramming while looping the buffer
@@ -136,7 +137,9 @@ static int omap_pcm_prepare(struct snd_p
 
 	memset(&dma_params, 0, sizeof(dma_params));
 
-	if (cpu_is_omap34xx())
+	/* TODO: Currently, MODE_ELEMENT == MODE_FRAME */
+	if (cpu_is_omap34xx() &&
+			(prtd->dma_op_mode == MCBSP_DMA_MODE_THRESHOLD))
 		sync_mode = OMAP_DMA_SYNC_FRAME;
 	else
 		sync_mode = OMAP_DMA_SYNC_ELEMENT;
@@ -189,9 +192,16 @@ static int omap_pcm_trigger(struct snd_p
 	unsigned long flags;
 	int ret = 0;
 	unsigned int bus_id = *(unsigned int *)rtd->dai->cpu_dai->private_data;
-	u16 samples = snd_pcm_lib_period_bytes(substream) >> 1;
+	u16 samples;
 
 	spin_lock_irqsave(&prtd->lock, flags);
+
+	/* TODO: Currently, MODE_ELEMENT == MODE_FRAME */
+	if (prtd->dma_op_mode == MCBSP_DMA_MODE_THRESHOLD)
+		samples = snd_pcm_lib_period_bytes(substream) >> 1;
+	else
+		samples = 1;
+
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
@@ -245,10 +255,12 @@ static int omap_pcm_open(struct snd_pcm_
 	struct omap_runtime_data *prtd;
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	unsigned int bus_id = *(unsigned int *)rtd->dai->cpu_dai->private_data;
+	int dma_op_mode = omap_mcbsp_get_dma_op_mode(bus_id);
 	int ret;
 	int max_period;
 
-	if (cpu_is_omap34xx()) {
+	/* TODO: Currently, MODE_ELEMENT == MODE_FRAME */
+	if (cpu_is_omap34xx() && (dma_op_mode == MCBSP_DMA_MODE_THRESHOLD)) {
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 			max_period = omap_mcbsp_get_max_tx_threshold(bus_id);
 		else
@@ -256,7 +268,7 @@ static int omap_pcm_open(struct snd_pcm_
 		max_period++;
 		max_period <<= 1;
 	} else {
-		omap_pcm_hardware.period_bytes_max = 64 * 1024;
+		max_period = 64 * 1024;
 	}
 
 	omap_pcm_hardware.period_bytes_max = max_period;
@@ -274,6 +286,7 @@ static int omap_pcm_open(struct snd_pcm_
 		ret = -ENOMEM;
 		goto out;
 	}
+	prtd->dma_op_mode = dma_op_mode;
 	spin_lock_init(&prtd->lock);
 	runtime->private_data = prtd;
 
diff -Nurp kernel-2.6.28-20091602+0m5/sound/soc/omap/rx51.c kernel-2.6.28-20093908+0m5/sound/soc/omap/rx51.c
--- kernel-2.6.28-20091602+0m5/sound/soc/omap/rx51.c	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/sound/soc/omap/rx51.c	2012-12-16 13:13:01.744330144 +0100
@@ -59,6 +59,7 @@ enum {
 	RX51_JACK_TVOUT,	/* stereo output with tv-out */
 };
 
+static int rx51_new_hw_audio;
 static int rx51_spk_func;
 static int rx51_jack_func;
 static int rx51_fmtx_func;
@@ -234,6 +235,8 @@ static void rx51_shutdown(struct snd_pcm
 {
 }
 
+static int pre_events;
+
 static int rx51_hw_params(struct snd_pcm_substream *substream,
 	struct snd_pcm_hw_params *params)
 {
@@ -242,18 +245,27 @@ static int rx51_hw_params(struct snd_pcm
 	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
 	int err;
 
+	if (rx51_new_hw_audio) {
+		if (!pre_events) {
+			pre_events = 1;
+			err = twl4030_enable_regulator(RES_VMMC2);
+			if (err < 0)
+				return err;
+		}
+	}
+
 	/* Set codec DAI configuration */
 	err = snd_soc_dai_set_fmt(codec_dai,
-				  SND_SOC_DAIFMT_DSP |
-				  SND_SOC_DAIFMT_NB_NF |
+				  SND_SOC_DAIFMT_DSP_A |
+				  SND_SOC_DAIFMT_IB_NF |
 				  SND_SOC_DAIFMT_CBM_CFM);
 	if (err < 0)
 		return err;
 
 	/* Set cpu DAI configuration */
 	err = snd_soc_dai_set_fmt(cpu_dai,
-				  SND_SOC_DAIFMT_DSP |
-				  SND_SOC_DAIFMT_NB_NF |
+				  SND_SOC_DAIFMT_DSP_A |
+				  SND_SOC_DAIFMT_IB_NF |
 				  SND_SOC_DAIFMT_CBM_CFM);
 	if (err < 0)
 		return err;
@@ -475,6 +487,62 @@ static int rx51_ear_event(struct snd_soc
 	return 0;
 }
 
+static int rx51_pre_spk_event(struct snd_soc_dapm_widget *w,
+			  struct snd_kcontrol *k, int event)
+{
+	if (!rx51_new_hw_audio)
+		return 0;
+
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		return twl4030_enable_regulator(RES_VMMC2);
+
+	return 0;
+}
+
+static int rx51_post_spk_event(struct snd_soc_dapm_widget *w,
+			  struct snd_kcontrol *k, int event)
+{
+	if (!rx51_new_hw_audio)
+		return 0;
+
+	if (!SND_SOC_DAPM_EVENT_ON(event))
+		return twl4030_disable_regulator(RES_VMMC2);
+
+	return 0;
+}
+
+static int rx51_pre_event(struct snd_soc_dapm_widget *w,
+			  struct snd_kcontrol *k, int event)
+{
+	if (!rx51_new_hw_audio)
+		return 0;
+
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		if (!pre_events) {
+			pre_events = 1;
+			return twl4030_enable_regulator(RES_VMMC2);
+		}
+	}
+
+	return 0;
+}
+
+static int rx51_post_event(struct snd_soc_dapm_widget *w,
+			  struct snd_kcontrol *k, int event)
+{
+	if (!rx51_new_hw_audio)
+		return 0;
+
+	if (!SND_SOC_DAPM_EVENT_ON(event)) {
+		if (pre_events && !w->codec->active) {
+			pre_events = 0;
+			return twl4030_disable_regulator(RES_VMMC2);
+		}
+	}
+
+	return 0;
+}
+
 enum {
        RX51_EXT_API_TPA6130,
        RX51_EXT_API_AIC34B,
@@ -555,15 +623,22 @@ static int rx51_ext_put_volsw(struct snd
 }
 
 static const struct snd_soc_dapm_widget aic34_dapm_widgets[] = {
+	SND_SOC_DAPM_POST("Post event", rx51_post_event),
+	SND_SOC_DAPM_SPK("Post spk", rx51_post_spk_event),
 	SND_SOC_DAPM_SPK("Ext Spk", rx51_spk_event),
 	SND_SOC_DAPM_SPK("Headphone Jack", rx51_jack_hp_event),
 	SND_SOC_DAPM_MIC("Mic Jack", rx51_jack_mic_event),
 	SND_SOC_DAPM_OUTPUT("FM Transmitter"),
 	SND_SOC_DAPM_MIC("DMic", NULL),
 	SND_SOC_DAPM_SPK("Earphone", rx51_ear_event),
+	SND_SOC_DAPM_SPK("Pre spk", rx51_pre_spk_event),
+	SND_SOC_DAPM_PRE("Pre event", rx51_pre_event),
 };
 
 static const struct snd_soc_dapm_route audio_map[] = {
+	{"Post spk", NULL, "LLOUT"},
+	{"Post spk", NULL, "RLOUT"},
+
 	{"Ext Spk", NULL, "HPLOUT"},
 	{"Ext Spk", NULL, "HPROUT"},
 
@@ -578,6 +653,9 @@ static const struct snd_soc_dapm_route a
 
 	{"DMic Rate 64", NULL, "Mic Bias 2V"},
 	{"Mic Bias 2V", NULL, "DMic"},
+
+	{"Pre spk", NULL, "LLOUT"},
+	{"Pre spk", NULL, "RLOUT"},
 };
 
 static const char *spk_function[] = {"Off", "On"};
@@ -601,7 +679,19 @@ static const struct soc_enum rx51_enum[]
  * up. This setting shows -30 dB at minimum, -12.95 dB at 49 % (actual
  * is -10.3 dB) and 4.65 dB at maximum (actual is 4 dB).
  */
-static DECLARE_TLV_DB_SCALE(tpa6130_tlv, -3000, 55, 0);
+static const unsigned int tpa6130_tlv[] = {
+	TLV_DB_RANGE_HEAD(10),
+	0, 1, TLV_DB_SCALE_ITEM(-5950, 600, 0),
+	2, 3, TLV_DB_SCALE_ITEM(-5000, 250, 0),
+	4, 5, TLV_DB_SCALE_ITEM(-4550, 160, 0),
+	6, 7, TLV_DB_SCALE_ITEM(-4140, 190, 0),
+	8, 9, TLV_DB_SCALE_ITEM(-3650, 120, 0),
+	10, 11, TLV_DB_SCALE_ITEM(-3330, 160, 0),
+	12, 13, TLV_DB_SCALE_ITEM(-3040, 180, 0),
+	14, 20, TLV_DB_SCALE_ITEM(-2710, 110, 0),
+	21, 37, TLV_DB_SCALE_ITEM(-1960, 74, 0),
+	38, 63, TLV_DB_SCALE_ITEM(-720, 45, 0),
+};
 
 /*
  * TLV320AIC3x output stage volumes. From -78.3 to 0 dB. Muted below -78.3 dB.
@@ -675,13 +765,13 @@ static int rx51_aic34_init(struct snd_so
 struct snd_soc_dai btcodec_dai = {
 	.name = "Bluetooth codec",
 	.playback = {
-		.stream_name = "Playback",
+		.stream_name = "BT Playback",
 		.channels_min = 1,
 		.channels_max = 1,
 		.rates = SNDRV_PCM_RATE_8000,
 		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
 	.capture = {
-		.stream_name = "Capture",
+		.stream_name = "BT Capture",
 		.channels_min = 1,
 		.channels_max = 1,
 		.rates = SNDRV_PCM_RATE_8000,
@@ -731,6 +821,11 @@ static struct snd_soc_device rx51_snd_de
 
 static struct platform_device *rx51_snd_device;
 
+#define REMAP_OFFSET		2
+#define DEDICATED_OFFSET	3
+#define VMMC2_DEV_GRP		0x2B
+#define VMMC2_285V		0x0a
+
 static int __init rx51_soc_init(void)
 {
 	int err;
@@ -739,6 +834,20 @@ static int __init rx51_soc_init(void)
 	if (!machine_is_nokia_rx51())
 		return -ENODEV;
 
+	if ((system_rev >= 0x08 && system_rev <= 0x13) || /* Macros */
+						system_rev >= 0x1901) {
+		rx51_new_hw_audio = 1;
+		err = twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
+					VMMC2_285V,
+					VMMC2_DEV_GRP + DEDICATED_OFFSET);
+		err |= twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, 0xee,
+					VMMC2_DEV_GRP + REMAP_OFFSET);
+		if (err) {
+			printk(KERN_ERR "%s rx51 audio failed!\n", __func__);
+			return -ENODEV;
+		}
+	}
+
 	if (gpio_request(RX51_CODEC_RESET_GPIO, NULL) < 0)
 		BUG();
 	if (gpio_request(RX51_TVOUT_SEL_GPIO, "tvout_sel") < 0)
diff -Nurp kernel-2.6.28-20091602+0m5/sound/soc/omap/rx51.h kernel-2.6.28-20093908+0m5/sound/soc/omap/rx51.h
--- kernel-2.6.28-20091602+0m5/sound/soc/omap/rx51.h	2012-12-16 13:06:25.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/sound/soc/omap/rx51.h	2012-12-16 13:13:01.744330144 +0100
@@ -22,5 +22,6 @@
 
 int rx51_set_eci_mode(int mode);
 void rx51_jack_report(int status);
+int allow_button_press(void);
 
 #endif /* _RX51_H_ */
diff -Nurp kernel-2.6.28-20091602+0m5/sound/soc/soc-core.c kernel-2.6.28-20093908+0m5/sound/soc/soc-core.c
--- kernel-2.6.28-20091602+0m5/sound/soc/soc-core.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20093908+0m5/sound/soc/soc-core.c	2012-12-16 13:13:01.744330144 +0100
@@ -270,13 +270,14 @@ static void close_delayed_work(struct wo
 {
 	struct snd_soc_device *socdev =
 		container_of(work, struct snd_soc_device, delayed_work.work);
+	struct snd_soc_machine *machine = socdev->machine;
 	struct snd_soc_codec *codec = socdev->codec;
 	struct snd_soc_dai *codec_dai;
 	int i;
 
 	mutex_lock(&pcm_mutex);
-	for (i = 0; i < codec->num_dai; i++) {
-		codec_dai = &codec->dai[i];
+	for (i = 0; i < machine->num_links; i++) {
+		codec_dai = machine->dai_link[i].codec_dai;
 
 		dbg("pop wq checking: %s status: %s waiting: %s\n",
 			codec_dai->playback.stream_name,
@@ -428,51 +429,42 @@ static int soc_pcm_prepare(struct snd_pc
 		}
 	}
 
-	/* we only want to start a DAPM playback stream if we are not waiting
-	 * on an existing one stopping */
-	if (codec_dai->pop_wait) {
-		/* we are waiting for the delayed work to start */
-		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-				snd_soc_dapm_stream_event(socdev->codec,
-					codec_dai->capture.stream_name,
-					SND_SOC_DAPM_STREAM_START);
-		else {
-			codec_dai->pop_wait = 0;
-			cancel_delayed_work(&socdev->delayed_work);
-			snd_soc_dai_digital_mute(codec_dai, 0);
-		}
-	} else {
-		/* no delayed work - do we need to power up codec */
-		if (codec->bias_level != SND_SOC_BIAS_ON) {
+	/* cancel any delayed stream shutdown that is pending */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
+	    codec_dai->pop_wait) {
+		codec_dai->pop_wait = 0;
+		cancel_delayed_work(&socdev->delayed_work);
+	}
 
-			snd_soc_dapm_set_bias_level(socdev,
-						    SND_SOC_BIAS_PREPARE);
+	/* do we need to power up codec */
+	if (codec->bias_level != SND_SOC_BIAS_ON) {
+		snd_soc_dapm_set_bias_level(socdev,
+					    SND_SOC_BIAS_PREPARE);
 
-			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-				snd_soc_dapm_stream_event(codec,
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			snd_soc_dapm_stream_event(codec,
 					codec_dai->playback.stream_name,
 					SND_SOC_DAPM_STREAM_START);
-			else
-				snd_soc_dapm_stream_event(codec,
+		else
+			snd_soc_dapm_stream_event(codec,
 					codec_dai->capture.stream_name,
 					SND_SOC_DAPM_STREAM_START);
 
-			snd_soc_dapm_set_bias_level(socdev, SND_SOC_BIAS_ON);
-			snd_soc_dai_digital_mute(codec_dai, 0);
+		snd_soc_dapm_set_bias_level(socdev, SND_SOC_BIAS_ON);
+		snd_soc_dai_digital_mute(codec_dai, 0);
 
-		} else {
-			/* codec already powered - power on widgets */
-			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-				snd_soc_dapm_stream_event(codec,
+	} else {
+		/* codec already powered - power on widgets */
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			snd_soc_dapm_stream_event(codec,
 					codec_dai->playback.stream_name,
 					SND_SOC_DAPM_STREAM_START);
-			else
-				snd_soc_dapm_stream_event(codec,
+		else
+			snd_soc_dapm_stream_event(codec,
 					codec_dai->capture.stream_name,
 					SND_SOC_DAPM_STREAM_START);
 
-			snd_soc_dai_digital_mute(codec_dai, 0);
-		}
+		snd_soc_dai_digital_mute(codec_dai, 0);
 	}
 
 out:
