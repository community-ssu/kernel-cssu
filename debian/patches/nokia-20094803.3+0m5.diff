diff -Nurp kernel-2.6.28-20094102.6+0m5/arch/arm/configs/rx51_defconfig kernel-2.6.28-20094803.3+0m5/arch/arm/configs/rx51_defconfig
--- kernel-2.6.28-20094102.6+0m5/arch/arm/configs/rx51_defconfig	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/arch/arm/configs/rx51_defconfig	2011-09-04 11:37:54.000000000 +0200
@@ -319,7 +319,7 @@ CONFIG_ALIGNMENT_TRAP=y
 #
 CONFIG_ZBOOT_ROM_TEXT=0x0
 CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="init=/sbin/preinit ubi.mtd=rootfs root=ubi0:rootfs rootfstype=ubifs rootflags=bulk_read,no_chk_data_crc rw console=ttyMTD,log console=tty0"
+CONFIG_CMDLINE="init=/sbin/preinit ubi.mtd=rootfs root=ubi0:rootfs rootfstype=ubifs rootflags=bulk_read,no_chk_data_crc rw console=ttyMTD,log console=tty0 snd-soc-rx51.hp_lim=42 snd-soc-tlv320aic3x.hp_dac_lim=6"
 # CONFIG_XIP_KERNEL is not set
 CONFIG_KEXEC=y
 CONFIG_ATAGS_PROC=y
@@ -689,6 +689,8 @@ CONFIG_OMAP_SSI=m
 CONFIG_SSI_MCSAAB_IMP=m
 CONFIG_SSI_CMT_SPEECH=m
 # CONFIG_SSI_CMT_SPEECH_DEBUG is not set
+CONFIG_SSI_CHAR=m
+# CONFIG_SSI_CHAR_DEBUG is not set
 CONFIG_HAVE_IDE=y
 # CONFIG_IDE is not set
 
@@ -1884,6 +1886,7 @@ CONFIG_FRAME_POINTER=y
 # CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
 # CONFIG_LKDTM is not set
 # CONFIG_FAULT_INJECTION is not set
+CONFIG_PANIC_INFO_BUFF=m
 # CONFIG_LATENCYTOP is not set
 # CONFIG_SYSCTL_SYSCALL_CHECK is not set
 CONFIG_HAVE_FUNCTION_TRACER=y
diff -Nurp kernel-2.6.28-20094102.6+0m5/arch/arm/configs/rx51_tiny_defconfig kernel-2.6.28-20094803.3+0m5/arch/arm/configs/rx51_tiny_defconfig
--- kernel-2.6.28-20094102.6+0m5/arch/arm/configs/rx51_tiny_defconfig	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/arch/arm/configs/rx51_tiny_defconfig	2011-09-04 11:37:54.000000000 +0200
@@ -304,7 +304,7 @@ CONFIG_ALIGNMENT_TRAP=y
 #
 CONFIG_ZBOOT_ROM_TEXT=0x0
 CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="init=/sbin/preinit ubi.mtd=rootfs root=ubi0:rootfs rootfstype=ubifs rootflags=bulk_read,no_chk_data_crc rw console=ttyMTD,log"
+CONFIG_CMDLINE="init=/sbin/preinit ubi.mtd=rootfs root=ubi0:rootfs rootfstype=ubifs rootflags=bulk_read,no_chk_data_crc rw console=ttyMTD,log snd-soc-rx51.hp_lim=42 snd-soc-tlv320aic3x.hp_dac_lim=6"
 # CONFIG_XIP_KERNEL is not set
 CONFIG_KEXEC=y
 CONFIG_ATAGS_PROC=y
diff -Nurp kernel-2.6.28-20094102.6+0m5/arch/arm/mach-omap2/board-rx51.c kernel-2.6.28-20094803.3+0m5/arch/arm/mach-omap2/board-rx51.c
--- kernel-2.6.28-20094102.6+0m5/arch/arm/mach-omap2/board-rx51.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/arch/arm/mach-omap2/board-rx51.c	2011-09-04 11:37:54.000000000 +0200
@@ -84,11 +84,16 @@ static void __init rx51_init_irq(void)
 static void __init rx51_pm_init(void)
 {
 	struct prm_setup_times prm_setup = {
-		.clksetup = 81,
+		.clksetup = 111, /* must equal Volt offset + voltsetup2 */
 		.voltsetup_time1 = 270,
 		.voltsetup_time2 = 150,
-		.voltoffset = 17,
-		.voltsetup2 = 37,
+		/* Time between wakeup event to when the sysoff goes high */
+		.voltoffset = 16,
+		 /* The following is for a 2.25ms ramp time of the oscillator
+		  * Documented 2ms, added .25 as margin. NOTE: scripts
+		  * change as oscillator changes
+		  */
+		.voltsetup2 = 95,
 	};
 
 	omap3_set_prm_setup_times(&prm_setup);
diff -Nurp kernel-2.6.28-20094102.6+0m5/arch/arm/mach-omap2/board-rx51-peripherals.c kernel-2.6.28-20094803.3+0m5/arch/arm/mach-omap2/board-rx51-peripherals.c
--- kernel-2.6.28-20094102.6+0m5/arch/arm/mach-omap2/board-rx51-peripherals.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/arch/arm/mach-omap2/board-rx51-peripherals.c	2011-09-04 11:37:54.000000000 +0200
@@ -415,8 +415,16 @@ static struct twl4030_gpio_platform_data
 static struct twl4030_ins sleep_on_seq[] = {
 /*
  * Turn off everything.
+#define MSG_BROADCAST(devgrp, grp, type, type2, state) \
+	( (devgrp) << 13 | 1 << 12 | (grp) << 9 | (type2) << 7 \
+	| (type) << 4 | (state))
+#define MSG_SINGULAR(devgrp, id, state) \
+	((devgrp) << 13 | 0 << 12 | (id) << 4 | (state))
+	0x14 - Corresponds to 500uSec
  */
-	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, 1, 0, RES_STATE_SLEEP), 2},
+	{MSG_SINGULAR(DEV_GRP_NULL, RES_HFCLKOUT, RES_STATE_SLEEP), 0x14},
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, 4, 1, RES_STATE_SLEEP), 2},
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, 4, 2, RES_STATE_SLEEP), 2},
 };
 
 static struct twl4030_script sleep_on_script = {
@@ -433,7 +441,10 @@ static struct twl4030_ins wakeup_seq[] =
 /*
  * Reenable everything.
  */
-	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, 1, 0, RES_STATE_ACTIVE), 2},
+	/* 0x32= 2.25 max(32khz) delay */
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, 1, 2, RES_STATE_ACTIVE), 0x32},
+	{MSG_SINGULAR(DEV_GRP_NULL, RES_HFCLKOUT, RES_STATE_ACTIVE), 1},
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, 1, 1, RES_STATE_ACTIVE), 2},
 };
 
 static struct twl4030_script wakeup_script = {
@@ -461,14 +472,10 @@ static struct twl4030_ins wrst_seq[] = {
  * Enable sysclk output.
  * Reenable twl4030.
  */
-	{MSG_SINGULAR(DEV_GRP_NULL, RES_RESET, RES_STATE_OFF), 2},
-	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, 0, 1, RES_STATE_ACTIVE),
-		0x13},
-	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_PP, 0, 3, RES_STATE_OFF), 0x13},
-	{MSG_SINGULAR(DEV_GRP_NULL, RES_VDD1, RES_STATE_WRST), 0x13},
-	{MSG_SINGULAR(DEV_GRP_NULL, RES_VDD2, RES_STATE_WRST), 0x13},
-	{MSG_SINGULAR(DEV_GRP_NULL, RES_VPLL1, RES_STATE_WRST), 0x35},
-	{MSG_SINGULAR(DEV_GRP_P3, RES_HFCLKOUT, RES_STATE_ACTIVE), 2},
+	{MSG_SINGULAR(DEV_GRP_NULL, RES_RESET, RES_STATE_OFF), 1},
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, 0, 2, RES_STATE_WRST), 1},
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_PP, 0, 3, RES_STATE_OFF), 0x34},
+	{MSG_BROADCAST(DEV_GRP_NULL, RES_GRP_ALL, 0, 1, RES_STATE_WRST), 1},
 	{MSG_SINGULAR(DEV_GRP_NULL, RES_RESET, RES_STATE_ACTIVE), 2},
 };
 
@@ -490,54 +497,31 @@ static struct twl4030_script *twl4030_sc
 
 static struct twl4030_resconfig twl4030_rconfig[] = {
 
-	{ .resource = RES_VDD1, .devgroup = -1, .type = 1, .type2 = -1,
-		.remap = 0 },
-	{ .resource = RES_VDD2, .devgroup = -1, .type = 1, .type2 = -1,
-		.remap = 0 },
-	{ .resource = RES_VPLL1, .devgroup = -1, .type = 1, .type2 = -1,
-		.remap = 0 },
-	{ .resource = RES_VPLL2, .devgroup = -1, .type = -1, .type2 = 3,
-		.remap = -1 },
-	{ .resource = RES_VAUX1, .devgroup = -1, .type = -1, .type2 = 3,
-		.remap = -1 },
-	{ .resource = RES_VAUX2, .devgroup = -1, .type = -1, .type2 = 3,
-		.remap = -1 },
-	{ .resource = RES_VAUX3, .devgroup = -1, .type = -1, .type2 = 3,
-		.remap = -1 },
-	{ .resource = RES_VAUX4, .devgroup = -1, .type = -1, .type2 = 3,
-		.remap = -1 },
-	{ .resource = RES_VMMC1, .devgroup = -1, .type = -1, .type2 = 3,
-		.remap = -1 },
-	{ .resource = RES_VMMC2, .devgroup = -1, .type = -1, .type2 = 3,
-		.remap = -1 },
-	{ .resource = RES_VDAC, .devgroup = -1, .type = -1, .type2 = 3,
-		.remap = -1 },
-	{ .resource = RES_VSIM, .devgroup = -1, .type = -1, .type2 = 3,
-		.remap = -1 },
-	{ .resource = RES_VINTANA1, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
-		.type = -1, .type2 = -1, .remap = -1 },
-	{ .resource = RES_VINTANA2, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
-		.type = 1, .type2 = -1, .remap = -1 },
-	{ .resource = RES_VINTDIG, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
-		.type = -1, .type2 = -1, .remap = -1 },
-	{ .resource = RES_VIO, .devgroup = DEV_GRP_P3,
-		.type = 1, .type2 = -1, .remap = -1 },
-	{ .resource = RES_CLKEN, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
-		.type = 1, .type2 = -1 , .remap = -1 },
-	{ .resource = RES_REGEN, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
-		.type = 1, .type2 = -1, .remap = -1 },
-	{ .resource = RES_NRES_PWRON, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
-		.type = 1, .type2 = -1, .remap = -1 },
-	{ .resource = RES_SYSEN, .devgroup = DEV_GRP_P1 | DEV_GRP_P3,
-		.type = 1, .type2 = -1, .remap = -1 },
-	{ .resource = RES_HFCLKOUT, .devgroup = DEV_GRP_P3, .type = 1,
-		.type2 = -1, .remap = -1 },
-	{ .resource = RES_32KCLKOUT, .devgroup = -1, .type = 1, .type2 = -1,
-		.remap = -1 },
-	{ .resource = RES_RESET, .devgroup = -1, .type = 1, .type2 = -1,
-		.remap = -1 },
-	{ .resource = RES_Main_Ref, .devgroup = -1, .type = 1, .type2 = -1,
-		.remap = -1 },
+	/* Default p1*/
+	{ .resource = RES_VDD1,		.devgroup = DEV_GRP_P1 | DEV_GRP_P3,	.type = 4, .type2 =  1, .remap =  0 },
+	{ .resource = RES_VDD2,		.devgroup = DEV_GRP_P1 | DEV_GRP_P3,	.type = 3, .type2 =  1, .remap =  0 },
+	{ .resource = RES_VPLL1,	.devgroup = DEV_GRP_P1 | DEV_GRP_P3,	.type = 3, .type2 =  1, .remap =  0 },
+	{ .resource = RES_VPLL2,	.devgroup = -1,				.type = 0, .type2 =  3, .remap =  8 },
+	{ .resource = RES_VAUX1,	.devgroup = -1,				.type = 0, .type2 =  3, .remap =  8 },
+	{ .resource = RES_VAUX2,	.devgroup = -1,				.type = 0, .type2 =  3, .remap =  8 },
+	{ .resource = RES_VAUX3,	.devgroup = -1,				.type = 0, .type2 =  3, .remap =  8 },
+	{ .resource = RES_VAUX4,	.devgroup = -1,				.type = 0, .type2 =  3, .remap =  8 },
+	{ .resource = RES_VMMC1,	.devgroup = -1,				.type = 0, .type2 =  3, .remap =  8 },
+	{ .resource = RES_VMMC2,	.devgroup = -1,				.type = 0, .type2 =  3, .remap =  8 },
+	{ .resource = RES_VDAC,		.devgroup = -1,				.type = 0, .type2 =  3, .remap =  8 },
+	{ .resource = RES_VSIM,		.devgroup = -1,				.type = 0, .type2 =  3, .remap =  8 },
+	{ .resource = RES_VINTANA1,	.devgroup = DEV_GRP_P1 | DEV_GRP_P3,	.type = 1, .type2 =  2, .remap =  8 },
+	{ .resource = RES_VINTANA2,	.devgroup = DEV_GRP_P1 | DEV_GRP_P3,	.type = 0, .type2 =  2, .remap =  8 },
+	{ .resource = RES_VINTDIG,	.devgroup = DEV_GRP_P1 | DEV_GRP_P3,	.type = 1, .type2 =  2, .remap =  8 },
+	{ .resource = RES_VIO,		.devgroup = DEV_GRP_P1 | DEV_GRP_P3,	.type = 2, .type2 =  2, .remap =  8 },
+	{ .resource = RES_CLKEN,	.devgroup = DEV_GRP_P1 | DEV_GRP_P3,	.type = 3, .type2 =  2, .remap =  8 },
+	{ .resource = RES_REGEN,	.devgroup = DEV_GRP_P1 | DEV_GRP_P3,	.type = 2, .type2 =  1, .remap =  8 },
+	{ .resource = RES_NRES_PWRON,	.devgroup = DEV_GRP_P1 | DEV_GRP_P3,	.type = 0, .type2 =  1, .remap =  8 },
+	{ .resource = RES_SYSEN,	.devgroup = DEV_GRP_P1 | DEV_GRP_P3,	.type = 6, .type2 =  1, .remap =  8 },
+	{ .resource = RES_HFCLKOUT,	.devgroup = DEV_GRP_P1 | DEV_GRP_P3,	.type = 0, .type2 =  1, .remap =  8 },
+	{ .resource = RES_32KCLKOUT,	.devgroup = DEV_GRP_P1 | DEV_GRP_P2 | DEV_GRP_P3,	.type = 0, .type2 =  0, .remap =  8 },
+	{ .resource = RES_RESET,	.devgroup = DEV_GRP_P1 | DEV_GRP_P2 | DEV_GRP_P3,	.type = 6, .type2 =  0, .remap =  8 },
+	{ .resource = RES_Main_Ref,	.devgroup = DEV_GRP_P1 | DEV_GRP_P2 | DEV_GRP_P3,	.type = 0, .type2 =  0, .remap =  8 },
 	{ 0, 0},
 };
 
diff -Nurp kernel-2.6.28-20094102.6+0m5/arch/arm/mach-omap2/cpuidle34xx.c kernel-2.6.28-20094803.3+0m5/arch/arm/mach-omap2/cpuidle34xx.c
--- kernel-2.6.28-20094102.6+0m5/arch/arm/mach-omap2/cpuidle34xx.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/arch/arm/mach-omap2/cpuidle34xx.c	2011-09-04 11:37:54.000000000 +0200
@@ -180,8 +180,8 @@ void omap_init_power_states(void)
 	/* C1 . MPU WFI + Core active */
 	omap3_power_states[OMAP3_STATE_C1].valid = 1;
 	omap3_power_states[OMAP3_STATE_C1].type = OMAP3_STATE_C1;
-	omap3_power_states[OMAP3_STATE_C1].sleep_latency = 58;
-	omap3_power_states[OMAP3_STATE_C1].wakeup_latency = 52;
+	omap3_power_states[OMAP3_STATE_C1].sleep_latency = 110;
+	omap3_power_states[OMAP3_STATE_C1].wakeup_latency = 162;
 	omap3_power_states[OMAP3_STATE_C1].threshold = 5;
 	omap3_power_states[OMAP3_STATE_C1].mpu_state = PWRDM_POWER_ON;
 	omap3_power_states[OMAP3_STATE_C1].core_state = PWRDM_POWER_ON;
@@ -190,9 +190,9 @@ void omap_init_power_states(void)
 	/* C2 . MPU WFI + Core inactive */
 	omap3_power_states[OMAP3_STATE_C2].valid = 1;
 	omap3_power_states[OMAP3_STATE_C2].type = OMAP3_STATE_C2;
-	omap3_power_states[OMAP3_STATE_C2].sleep_latency = 73;
-	omap3_power_states[OMAP3_STATE_C2].wakeup_latency = 164;
-	omap3_power_states[OMAP3_STATE_C2].threshold = 30;
+	omap3_power_states[OMAP3_STATE_C2].sleep_latency = 106;
+	omap3_power_states[OMAP3_STATE_C2].wakeup_latency = 180;
+	omap3_power_states[OMAP3_STATE_C2].threshold = 309;
 	omap3_power_states[OMAP3_STATE_C2].mpu_state = PWRDM_POWER_ON;
 	omap3_power_states[OMAP3_STATE_C2].core_state = PWRDM_POWER_ON;
 	omap3_power_states[OMAP3_STATE_C2].flags = CPUIDLE_FLAG_TIME_VALID |
@@ -201,9 +201,9 @@ void omap_init_power_states(void)
 	/* C3 . MPU CSWR + Core inactive */
 	omap3_power_states[OMAP3_STATE_C3].valid = 0;
 	omap3_power_states[OMAP3_STATE_C3].type = OMAP3_STATE_C3;
-	omap3_power_states[OMAP3_STATE_C3].sleep_latency = 90;
-	omap3_power_states[OMAP3_STATE_C3].wakeup_latency = 267;
-	omap3_power_states[OMAP3_STATE_C3].threshold = 113872; /* vs. C2 */
+	omap3_power_states[OMAP3_STATE_C3].sleep_latency = 107;
+	omap3_power_states[OMAP3_STATE_C3].wakeup_latency = 410;
+	omap3_power_states[OMAP3_STATE_C3].threshold = 46057;
 	omap3_power_states[OMAP3_STATE_C3].mpu_state = PWRDM_POWER_RET;
 	omap3_power_states[OMAP3_STATE_C3].core_state = PWRDM_POWER_ON;
 	omap3_power_states[OMAP3_STATE_C3].flags = CPUIDLE_FLAG_TIME_VALID |
@@ -212,9 +212,9 @@ void omap_init_power_states(void)
 	/* C4 . MPU OFF + Core inactive */
 	omap3_power_states[OMAP3_STATE_C4].valid = 0;
 	omap3_power_states[OMAP3_STATE_C4].type = OMAP3_STATE_C4;
-	omap3_power_states[OMAP3_STATE_C4].sleep_latency = 4130;
-	omap3_power_states[OMAP3_STATE_C4].wakeup_latency = 2130;
-	omap3_power_states[OMAP3_STATE_C4].threshold = 619328; /* vs. C2 */
+	omap3_power_states[OMAP3_STATE_C4].sleep_latency = 121;
+	omap3_power_states[OMAP3_STATE_C4].wakeup_latency = 3374;
+	omap3_power_states[OMAP3_STATE_C4].threshold = 46057;
 	omap3_power_states[OMAP3_STATE_C4].mpu_state = PWRDM_POWER_OFF;
 	omap3_power_states[OMAP3_STATE_C4].core_state = PWRDM_POWER_ON;
 	omap3_power_states[OMAP3_STATE_C4].flags = CPUIDLE_FLAG_TIME_VALID |
@@ -223,9 +223,9 @@ void omap_init_power_states(void)
 	/* C5 . MPU CSWR + Core CSWR*/
 	omap3_power_states[OMAP3_STATE_C5].valid = 1;
 	omap3_power_states[OMAP3_STATE_C5].type = OMAP3_STATE_C5;
-	omap3_power_states[OMAP3_STATE_C5].sleep_latency = 596;
-	omap3_power_states[OMAP3_STATE_C5].wakeup_latency = 1000;
-	omap3_power_states[OMAP3_STATE_C5].threshold = 7971;
+	omap3_power_states[OMAP3_STATE_C5].sleep_latency = 855;
+	omap3_power_states[OMAP3_STATE_C5].wakeup_latency = 1146;
+	omap3_power_states[OMAP3_STATE_C5].threshold = 46057;
 	omap3_power_states[OMAP3_STATE_C5].mpu_state = PWRDM_POWER_RET;
 	omap3_power_states[OMAP3_STATE_C5].core_state = PWRDM_POWER_RET;
 	omap3_power_states[OMAP3_STATE_C5].flags = CPUIDLE_FLAG_TIME_VALID |
@@ -234,9 +234,9 @@ void omap_init_power_states(void)
 	/* C6 . MPU OFF + Core CSWR */
 	omap3_power_states[OMAP3_STATE_C6].valid = 0;
 	omap3_power_states[OMAP3_STATE_C6].type = OMAP3_STATE_C6;
-	omap3_power_states[OMAP3_STATE_C6].sleep_latency = 4600;
-	omap3_power_states[OMAP3_STATE_C6].wakeup_latency = 2850;
-	omap3_power_states[OMAP3_STATE_C6].threshold = 2801100; /* vs. C5 */
+	omap3_power_states[OMAP3_STATE_C6].sleep_latency = 7580;
+	omap3_power_states[OMAP3_STATE_C6].wakeup_latency = 4134;
+	omap3_power_states[OMAP3_STATE_C6].threshold = 484329;
 	omap3_power_states[OMAP3_STATE_C6].mpu_state = PWRDM_POWER_OFF;
 	omap3_power_states[OMAP3_STATE_C6].core_state = PWRDM_POWER_RET;
 	omap3_power_states[OMAP3_STATE_C6].flags = CPUIDLE_FLAG_TIME_VALID |
@@ -245,9 +245,9 @@ void omap_init_power_states(void)
 	/* C7 . MPU OFF + Core OFF */
 	omap3_power_states[OMAP3_STATE_C7].valid = 1;
 	omap3_power_states[OMAP3_STATE_C7].type = OMAP3_STATE_C7;
-	omap3_power_states[OMAP3_STATE_C7].sleep_latency = 4760;
-	omap3_power_states[OMAP3_STATE_C7].wakeup_latency = 7780;
-	omap3_power_states[OMAP3_STATE_C7].threshold = 610082;
+	omap3_power_states[OMAP3_STATE_C7].sleep_latency = 7505;
+	omap3_power_states[OMAP3_STATE_C7].wakeup_latency = 15274;
+	omap3_power_states[OMAP3_STATE_C7].threshold = 484329;
 	omap3_power_states[OMAP3_STATE_C7].mpu_state = PWRDM_POWER_OFF;
 	omap3_power_states[OMAP3_STATE_C7].core_state = PWRDM_POWER_OFF;
 	omap3_power_states[OMAP3_STATE_C7].flags = CPUIDLE_FLAG_TIME_VALID |
diff -Nurp kernel-2.6.28-20094102.6+0m5/arch/arm/mach-omap2/mmc-twl4030.c kernel-2.6.28-20094803.3+0m5/arch/arm/mach-omap2/mmc-twl4030.c
--- kernel-2.6.28-20094102.6+0m5/arch/arm/mach-omap2/mmc-twl4030.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/arch/arm/mach-omap2/mmc-twl4030.c	2011-09-04 11:37:54.000000000 +0200
@@ -36,6 +36,12 @@
 #define MMCHS_SYSSTATUS			0x0014
 #define MMCHS_SYSSTATUS_RESETDONE	(1 << 0)
 
+#define OMAP343X_PADCONF_MMC2_CMD	(OMAP2_CONTROL_PADCONFS + 0x12A)
+#define OMAP343X_PADCONF_MMC2_DAT0	(OMAP2_CONTROL_PADCONFS + 0x12C)
+#define OMAP343X_PADCONF_MMC2_DAT2	(OMAP2_CONTROL_PADCONFS + 0x130)
+#define OMAP343X_PADCONF_MMC2_DAT4	(OMAP2_CONTROL_PADCONFS + 0x134)
+#define OMAP343X_PADCONF_MMC2_DAT6	(OMAP2_CONTROL_PADCONFS + 0x138)
+
 static struct platform_device dummy_pdev = {
 	.dev = {
 		.bus = &platform_bus_type,
@@ -599,6 +605,14 @@ static int twl_mmc2_set_power(struct dev
 	 * transceiver is used, DAT3..7 are muxed as transceiver control pins.
 	 */
 	if (power_on) {
+		if (!cpu_is_omap2430()) {
+			/* Pull up */
+			omap_ctrl_writew(    0x118, OMAP343X_PADCONF_MMC2_CMD);
+			omap_ctrl_writel(0x1180118, OMAP343X_PADCONF_MMC2_DAT0);
+			omap_ctrl_writel(0x1180118, OMAP343X_PADCONF_MMC2_DAT2);
+			omap_ctrl_writel(0x1180118, OMAP343X_PADCONF_MMC2_DAT4);
+			omap_ctrl_writel(0x1180118, OMAP343X_PADCONF_MMC2_DAT6);
+		}
 		if (mmc->slots[0].internal_clock) {
 			u32 reg;
 
@@ -608,6 +622,14 @@ static int twl_mmc2_set_power(struct dev
 		}
 		ret = twl_mmc_set_voltage(c, vdd);
 	} else {
+		if (!cpu_is_omap2430()) {
+			/* Pull down */
+			omap_ctrl_writew(    0x108, OMAP343X_PADCONF_MMC2_CMD);
+			omap_ctrl_writel(0x1080108, OMAP343X_PADCONF_MMC2_DAT0);
+			omap_ctrl_writel(0x1080108, OMAP343X_PADCONF_MMC2_DAT2);
+			omap_ctrl_writel(0x1080108, OMAP343X_PADCONF_MMC2_DAT4);
+			omap_ctrl_writel(0x1080108, OMAP343X_PADCONF_MMC2_DAT6);
+		}
 		ret = twl_mmc_set_voltage(c, 0);
 	}
 
@@ -649,12 +671,14 @@ static int twl_mmc2_set_sleep(struct dev
 		return twl_mmc_regulator_set_mode(c->twl_vmmc_dev_grp, sleep);
 
 	if (cardsleep) {
+		struct twl_mmc_controller *c = &hsmmc[1];
+
 		/* VCC can be turned off if card is asleep */
 		c->vsim_18v = 0;
 		if (sleep)
-			err = twl_mmc2_set_power(dev, slot, 0, 0);
+			err = twl_mmc_set_voltage(c, 0);
 		else
-			err = twl_mmc2_set_power(dev, slot, 1, vdd);
+			err = twl_mmc_set_voltage(c, vdd);
 		c->vsim_18v = 1;
 	} else
 		err = twl_mmc_regulator_set_mode(c->twl_vmmc_dev_grp, sleep);
diff -Nurp kernel-2.6.28-20094102.6+0m5/arch/arm/mach-omap2/pm-debug.c kernel-2.6.28-20094803.3+0m5/arch/arm/mach-omap2/pm-debug.c
--- kernel-2.6.28-20094102.6+0m5/arch/arm/mach-omap2/pm-debug.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/arch/arm/mach-omap2/pm-debug.c	2011-09-04 11:37:54.000000000 +0200
@@ -169,7 +169,8 @@ static int pm_dbg_init_done;
 enum {
 	DEBUG_FILE_COUNTERS = 0,
 	DEBUG_FILE_TIMERS,
-	DEBUG_FILE_RESOURCES
+	DEBUG_FILE_RESOURCES,
+	DEBUG_FILE_WAIT_SDRC_COUNT
 };
 
 struct pm_module_def {
@@ -428,9 +429,21 @@ static int pm_dbg_show_timers(struct seq
 	return 0;
 }
 
+static int pm_dbg_show_sdrc_wait_count(struct seq_file *s, void *unused)
+{
+	unsigned int *sdrc_counters = omap3_get_sdrc_counters();
+
+	seq_printf(s, "dll kick count: %u\n", sdrc_counters[0]);
+	seq_printf(s, "wait dll lock count: %u\n", sdrc_counters[1]);
+
+	return 0;
+}
 static int pm_dbg_open(struct inode *inode, struct file *file)
 {
 	switch ((int)inode->i_private) {
+	case DEBUG_FILE_WAIT_SDRC_COUNT:
+		return single_open(file, pm_dbg_show_sdrc_wait_count,
+			&inode->i_private);
 	case DEBUG_FILE_COUNTERS:
 		return single_open(file, pm_dbg_show_counters,
 			&inode->i_private);
@@ -548,6 +561,8 @@ static int __init pm_dbg_init(void)
 		d, (void *)DEBUG_FILE_TIMERS, &debug_fops);
 	(void) debugfs_create_file("resources", S_IRUGO,
 		d, (void *)DEBUG_FILE_RESOURCES, &debug_fops);
+	(void) debugfs_create_file("wait_sdrc_count", S_IRUGO,
+		d, (void *)DEBUG_FILE_WAIT_SDRC_COUNT, &debug_fops);
 
 	pwrdm_for_each(pwrdms_setup, (void *)d);
 
diff -Nurp kernel-2.6.28-20094102.6+0m5/arch/arm/mach-omap2/pm.h kernel-2.6.28-20094803.3+0m5/arch/arm/mach-omap2/pm.h
--- kernel-2.6.28-20094102.6+0m5/arch/arm/mach-omap2/pm.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/arch/arm/mach-omap2/pm.h	2011-09-04 11:37:54.000000000 +0200
@@ -50,6 +50,7 @@ extern void omap3_pm_off_mode_enable(int
 extern int omap3_pm_get_suspend_state(struct powerdomain *pwrdm);
 extern int omap3_pm_set_suspend_state(struct powerdomain *pwrdm, int state);
 extern void omap3_set_prm_setup_times(struct prm_setup_times *setup_times);
+extern unsigned int *omap3_get_sdrc_counters(void);
 #else
 #define omap3_pm_off_mode_enable(int) do {} while (0);
 #define omap3_pm_get_suspend_state(pwrdm) do {} while (0);
diff -Nurp kernel-2.6.28-20094102.6+0m5/arch/arm/mach-omap2/pm34xx.c kernel-2.6.28-20094803.3+0m5/arch/arm/mach-omap2/pm34xx.c
--- kernel-2.6.28-20094102.6+0m5/arch/arm/mach-omap2/pm34xx.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/arch/arm/mach-omap2/pm34xx.c	2011-09-04 11:37:54.000000000 +0200
@@ -127,6 +127,9 @@ static int (*_omap_save_secure_sram)(u32
 
 static void (*saved_idle)(void);
 
+static unsigned int *_sdrc_counters;
+static unsigned int save_sdrc_counters[2];
+
 static struct powerdomain *mpu_pwrdm, *neon_pwrdm;
 static struct powerdomain *core_pwrdm, *per_pwrdm;
 static struct powerdomain *cam_pwrdm, *iva2_pwrdm, *dss_pwrdm, *usb_pwrdm;
@@ -301,7 +304,15 @@ static void omap3_core_save_context(void
 	/* wait for the save to complete */
 	while (!(omap_ctrl_readl(OMAP343X_CONTROL_GENERAL_PURPOSE_STATUS)
 			& PADCONF_SAVE_DONE))
-		;
+		udelay(1);
+
+	/*
+	 * Force write last pad into memory, as this can fail in some
+	 * cases according to errata XYZ
+	 */
+	omap_ctrl_writel(omap_ctrl_readl(OMAP343X_PADCONF_ETK_D14),
+		OMAP343X_CONTROL_MEM_WKUP + 0x2a0);
+
 	/* Save the Interrupt controller context */
 	omap3_intc_save_context();
 	/* Save the GPMC context */
@@ -668,6 +679,8 @@ void omap_sram_idle(void)
 				  OMAP3_PRM_CLKSETUP_OFFSET);
 	}
 
+	memcpy(save_sdrc_counters, _sdrc_counters, sizeof(save_sdrc_counters));
+
 	/*
 	 * omap3_arm_context is the location where ARM registers
 	 * get saved. The restore path then reads from this
@@ -697,6 +710,7 @@ void omap_sram_idle(void)
 			omap3_sram_restore_context();
 			omap2_sms_restore_context();
 			reset_ssi();
+			memcpy(_sdrc_counters, save_sdrc_counters, sizeof(save_sdrc_counters));
 		}
 		omap_uart_resume_idle(0);
 		omap_uart_resume_idle(1);
@@ -802,6 +816,12 @@ err:
 	return ret;
 }
 
+/* return a pointer to the sdrc counters */
+unsigned int *omap3_get_sdrc_counters(void)
+{
+	return _sdrc_counters;
+}
+
 static void omap3_pm_idle(void)
 {
 	local_irq_disable();
@@ -1251,6 +1271,10 @@ void omap_push_sram_idle(void)
 {
 	_omap_sram_idle = omap_sram_push(omap34xx_cpu_suspend,
 					omap34xx_cpu_suspend_sz);
+	/* the sdrc counters are always at the end of the omap34xx_cpu_suspend
+	 * block */
+	_sdrc_counters = (unsigned *)((u8 *)_omap_sram_idle + omap34xx_cpu_suspend_sz - 8);
+
 	if (omap_type() != OMAP2_DEVICE_TYPE_GP)
 		_omap_save_secure_sram = omap_sram_push(save_secure_ram_context,
 				save_secure_ram_context_sz);
diff -Nurp kernel-2.6.28-20094102.6+0m5/arch/arm/mach-omap2/sleep34xx.S kernel-2.6.28-20094803.3+0m5/arch/arm/mach-omap2/sleep34xx.S
--- kernel-2.6.28-20094102.6+0m5/arch/arm/mach-omap2/sleep34xx.S	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/arch/arm/mach-omap2/sleep34xx.S	2011-09-04 11:37:54.000000000 +0200
@@ -40,6 +40,7 @@
 #define PM_PREPWSTST_MPU_V	OMAP34XX_PRM_REGADDR(MPU_MOD, \
 				OMAP3430_PM_PREPWSTST)
 #define CM_IDLEST1_CORE_V	IO_ADDRESS(OMAP3430_CM_BASE + 0x220)
+#define CM_IDLEST_CKGEN_V	IO_ADDRESS(OMAP3430_CM_BASE + 0x520)
 
 /*
  * This is the physical address of the register as specified
@@ -703,35 +704,70 @@ skip_l2_inval:
 
 /* Make sure SDRC accesses are ok */
 wait_sdrc_ok:
+
+/* DPLL3 must be locked before accessing the SDRC. Maybe the HW ensures this. */
+	ldr	r4, cm_idlest_ckgen
+wait_dpll3_lock:
+	ldr	r5, [r4]
+	tst	r5, #1
+	beq	wait_dpll3_lock
+
         ldr     r4, cm_idlest1_core
+wait_sdrc_ready:
         ldr     r5, [r4]
-        and     r5, r5, #0x2
-        cmp     r5, #0
-        bne     wait_sdrc_ok
+        tst     r5, #0x2
+        bne     wait_sdrc_ready
+	/* allow DLL powerdown upon hw idle req */
         ldr     r4, sdrc_power
         ldr     r5, [r4]
         bic     r5, r5, #0x40
         str     r5, [r4]
-wait_dll_lock:
-        /* Is dll in lock mode? */
+is_dll_in_lock_mode:
         ldr     r4, sdrc_dlla_ctrl
         ldr     r5, [r4]
         tst     r5, #0x4
         bxne    lr
         /* wait till dll locks */
+wait_dll_lock_timed:
+	ldr	r4, wait_dll_lock_counter
+	add	r4, r4, #1
+	str	r4, wait_dll_lock_counter
         ldr     r4, sdrc_dlla_status
+        mov     r6, #8 			/* Wait 20uS for lock */
+wait_dll_lock:
+        subs    r6, r6, #0x1
+        beq     kick_dll
         ldr     r5, [r4]
         and     r5, r5, #0x4
         cmp     r5, #0x4
         bne     wait_dll_lock
         bx      lr
 
+        /* disable/reenable DLL if locked */
+kick_dll:
+	ldr     r4, sdrc_dlla_ctrl	/* get dlla addr */
+	ldr     r5, [r4]		/* grab value */
+	mov	r6, r5			/* save value */
+	bic	r6, #(1<<3)		/* disable dll */
+	str	r6, [r4]
+	dsb
+	orr	r6, r6, #(1<<3)		/* enable dll */
+	str	r6, [r4]
+	dsb
+	str	r5, [r4]		/* restore old value */
+	ldr	r4, kick_counter
+	add	r4, r4, #1
+	str	r4, kick_counter
+	b 	wait_dll_lock_timed
+
 phys_offset:
 	.word	PHYS_OFFSET
 page_offset:
 	.word	PAGE_OFFSET
 cm_idlest1_core:
 	.word	CM_IDLEST1_CORE_V
+cm_idlest_ckgen:
+	.word	CM_IDLEST_CKGEN_V
 sdrc_dlla_status:
 	.word	SDRC_DLLA_STATUS_V
 sdrc_dlla_ctrl:
@@ -766,5 +802,10 @@ cache_pred_disable_mask:
 	.word	0xFFFFE7FB
 control_stat:
 	.word	CONTROL_STAT
+	/* these 2 words need to be at the end !!! */
+kick_counter:
+	.word	0
+wait_dll_lock_counter:
+	.word	0
 ENTRY(omap34xx_cpu_suspend_sz)
 	.word	. - omap34xx_cpu_suspend
diff -Nurp kernel-2.6.28-20094102.6+0m5/arch/arm/plat-omap/iovmm.c kernel-2.6.28-20094803.3+0m5/arch/arm/plat-omap/iovmm.c
--- kernel-2.6.28-20094102.6+0m5/arch/arm/plat-omap/iovmm.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/arch/arm/plat-omap/iovmm.c	2011-09-04 11:37:54.000000000 +0200
@@ -47,7 +47,7 @@
  *	'va':	mpu virtual address
  *
  *	'c':	contiguous memory area
- *	'd':	dicontiguous memory area
+ *	'd':	discontiguous memory area
  *	'a':	anonymous memory allocation
  *	'()':	optional feature
  *
@@ -385,14 +385,13 @@ static void sgtable_fill_vmalloc(struct
 	}
 
 	va_end = _va + PAGE_SIZE * i;
-	flush_cache_vmap(_va, va_end);
 }
 
 static inline void sgtable_drain_vmalloc(struct sg_table *sgt)
 {
 	/*
 	 * Actually this is not necessary at all, just exists for
-	 * consistency of the code readibility.
+	 * consistency of the code readability.
 	 */
 	BUG_ON(!sgt);
 }
@@ -420,15 +419,13 @@ static void sgtable_fill_kmalloc(struct
 		len -= bytes;
 	}
 	BUG_ON(len);
-
-	clean_dcache_area(va, len);
 }
 
 static inline void sgtable_drain_kmalloc(struct sg_table *sgt)
 {
 	/*
 	 * Actually this is not necessary at all, just exists for
-	 * consistency of the code readibility
+	 * consistency of the code readability
 	 */
 	BUG_ON(!sgt);
 }
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/dsp/bridge/rmgr/proc.c kernel-2.6.28-20094803.3+0m5/drivers/dsp/bridge/rmgr/proc.c
--- kernel-2.6.28-20094102.6+0m5/drivers/dsp/bridge/rmgr/proc.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/dsp/bridge/rmgr/proc.c	2011-09-04 11:37:54.000000000 +0200
@@ -159,6 +159,8 @@
 #define PWR_TIMEOUT	 500	/* Sleep/wake timout in msec */
 #define EXTEND	      "_EXT_END"	/* Extmem end addr in DSP binary */
 
+#define DSP_CACHE_LINE 128
+
 extern char *iva_img;
 
 /*  ----------------------------------- Globals */
@@ -679,8 +681,48 @@ DSP_STATUS PROC_EnumNodes(DSP_HPROCESSOR
 	return status;
 }
 
+/* Cache operation against kernel address instead of users */
+static int memory_sync_page(struct vm_area_struct *vma, unsigned long start,
+			    ssize_t len, enum DSP_FLUSHTYPE ftype)
+{
+	struct page *page;
+	void *kaddr;
+	unsigned long offset;
+	ssize_t rest;
+
+#ifdef CHECK_DSP_CACHE_LINE
+	if ((start & DSP_CACHE_LINE) || (len & DSP_CACHE_LINE))
+		pr_warning("%s: not aligned: %08lx(%d)\n", __func__,
+			   start, len);
+#endif
+	while (len) {
+		page = follow_page(vma, start, FOLL_GET);
+		if (!page) {
+			pr_err("%s: no page for %08lx\n", __func__, start);
+			return -EINVAL;
+		} else if (IS_ERR(page)) {
+			pr_err("%s: err page for %08lx(%lu)\n", __func__, start,
+			       IS_ERR(page));
+			return IS_ERR(page);
+		}
+
+		offset = start & ~PAGE_MASK;
+		kaddr = page_address(page) + offset;
+		rest = min_t(ssize_t, PAGE_SIZE - offset, len);
+
+		MEM_FlushCache(kaddr, rest, ftype);
+
+		put_page(page);
+		len -= rest;
+		start += rest;
+	}
+
+	return 0;
+}
+
 /* Check if the given area blongs to process virtul memory address space */
-static int memory_check_vma(unsigned long start, u32 len)
+static int memory_sync_vma(unsigned long start, u32 len,
+			   enum DSP_FLUSHTYPE ftype)
 {
 	int err = 0;
 	unsigned long end;
@@ -690,14 +732,19 @@ static int memory_check_vma(unsigned lon
 	if (end <= start)
 		return -EINVAL;
 
-	down_read(&current->mm->mmap_sem);
-
 	while ((vma = find_vma(current->mm, start)) != NULL) {
+		ssize_t size;
+
+		if (vma->vm_flags & (VM_IO | VM_PFNMAP))
+			return -EINVAL;
+
+		if (vma->vm_start > start)
+			return -EINVAL;
 
-		if (vma->vm_start > start) {
-			err = -EINVAL;
+		size = min_t(ssize_t, vma->vm_end - start, len);
+		err = memory_sync_page(vma, start, size, ftype);
+		if (err)
 			break;
-		}
 
 		if (end <= vma->vm_end)
 			break;
@@ -708,8 +755,6 @@ static int memory_check_vma(unsigned lon
 	if (!vma)
 		err = -EINVAL;
 
-	up_read(&current->mm->mmap_sem);
-
 	return err;
 }
 
@@ -734,18 +779,15 @@ static DSP_STATUS proc_memory_sync(DSP_H
 		goto err_out;
 	}
 
-	if (memory_check_vma((u32)pMpuAddr, ulSize)) {
-		GT_3trace(PROC_DebugMask, GT_7CLASS,
-			  "%s: InValid address parameters\n",
-			  __func__, pMpuAddr, ulSize);
+	down_read(&current->mm->mmap_sem);
+
+	if (memory_sync_vma((u32)pMpuAddr, ulSize, FlushMemType)) {
+		pr_err("%s: InValid address parameters %p %x\n",
+		       __func__, pMpuAddr, ulSize);
 		status = DSP_EHANDLE;
-		goto err_out;
 	}
 
-	(void)SYNC_EnterCS(hProcLock);
-	MEM_FlushCache(pMpuAddr, ulSize, FlushMemType);
-	(void)SYNC_LeaveCS(hProcLock);
-
+	up_read(&current->mm->mmap_sem);
 err_out:
 	GT_2trace(PROC_DebugMask, GT_ENTER,
 		  "Leaving %s [0x%x]", __func__, status);
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/bridged_pvr_bridge.c kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/bridged_pvr_bridge.c
--- kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/bridged_pvr_bridge.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/bridged_pvr_bridge.c	2011-09-04 11:37:54.000000000 +0200
@@ -791,25 +791,25 @@ PVRSRVUnmapDeviceMemoryBW(IMG_UINT32 ui3
 }
 
 static int
-FlushCacheDRI(IMG_UINT32 ui32Type, IMG_UINT32 ui32Virt, IMG_UINT32 ui32Length)
+FlushCacheDRI(IMG_UINT32 ui32Type, IMG_VOID *pvVirt, IMG_UINT32 ui32Length)
 {
 	switch (ui32Type) {
 	case DRM_PVR2D_CFLUSH_FROM_GPU:
 		PVR_DPF((PVR_DBG_MESSAGE,
 			 "DRM_PVR2D_CFLUSH_FROM_GPU 0x%08x, length 0x%08x\n",
-			 ui32Virt, ui32Length));
+			 pvVirt, ui32Length));
 #ifdef CONFIG_ARM
-		dmac_inv_range((const void *)ui32Virt,
-			       (const void *)(ui32Virt + ui32Length));
+		dmac_inv_range((const void *)pvVirt,
+			       (const void *)(pvVirt + ui32Length));
 #endif
 		return 0;
 	case DRM_PVR2D_CFLUSH_TO_GPU:
 		PVR_DPF((PVR_DBG_MESSAGE,
 			 "DRM_PVR2D_CFLUSH_TO_GPU 0x%08x, length 0x%08x\n",
-			 ui32Virt, ui32Length));
+			 pvVirt, ui32Length));
 #ifdef CONFIG_ARM
-		dmac_clean_range((const void *)ui32Virt,
-				 (const void *)(ui32Virt + ui32Length));
+		dmac_clean_range((const void *)pvVirt,
+				 (const void *)(pvVirt + ui32Length));
 #endif
 		return 0;
 	default:
@@ -821,18 +821,51 @@ FlushCacheDRI(IMG_UINT32 ui32Type, IMG_U
 	return 0;
 }
 
+PVRSRV_ERROR
+PVRSRVIsWrappedExtMemoryBW(PVRSRV_PER_PROCESS_DATA *psPerProc,
+			   PVRSRV_BRIDGE_IN_CACHEFLUSHDRMFROMUSER *psCacheFlushIN)
+{
+	PVRSRV_ERROR eError;
+	IMG_HANDLE hDevCookieInt;
+
+	PVRSRVLookupHandle(psPerProc->psHandleBase, &hDevCookieInt,
+						   psCacheFlushIN->hDevCookie,
+						   PVRSRV_HANDLE_TYPE_DEV_NODE);
+
+	eError = PVRSRVIsWrappedExtMemoryKM(
+					hDevCookieInt,
+					psPerProc,
+					&(psCacheFlushIN->ui32Length),
+					&(psCacheFlushIN->pvVirt));
+
+	return eError;
+}
+
 static int
 PVRSRVCacheFlushDRIBW(IMG_UINT32 ui32BridgeID,
 		      PVRSRV_BRIDGE_IN_CACHEFLUSHDRMFROMUSER * psCacheFlushIN,
 		      PVRSRV_BRIDGE_RETURN * psRetOUT,
 		      PVRSRV_PER_PROCESS_DATA * psPerProc)
 {
+	PVRSRV_ERROR eError;
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_CACHE_FLUSH_DRM);
 
-	psRetOUT->eError = FlushCacheDRI(psCacheFlushIN->ui32Type,
-					 psCacheFlushIN->ui32Virt,
-					 psCacheFlushIN->ui32Length);
+	down_read(&current->mm->mmap_sem);
+
+	eError = PVRSRVIsWrappedExtMemoryBW(psPerProc, psCacheFlushIN);
+
+	if (eError == PVRSRV_OK) {
+		psRetOUT->eError = FlushCacheDRI(psCacheFlushIN->ui32Type,
+											psCacheFlushIN->pvVirt,
+											psCacheFlushIN->ui32Length);
+	} else {
+		printk(KERN_WARNING
+			": PVRSRVCacheFlushDRIBW: Start address 0x%08x and length 0x%08x not wrapped \n",
+			(unsigned int)(psCacheFlushIN->pvVirt),
+			(unsigned int)(psCacheFlushIN->ui32Length));
+	}
 
+	up_read(&current->mm->mmap_sem);
 	return 0;
 }
 
@@ -987,7 +1020,7 @@ PVRSRVWrapExtMemoryBW(IMG_UINT32 ui32Bri
 	IMG_HANDLE hDevCookieInt;
 	PVRSRV_KERNEL_MEM_INFO *psMemInfo;
 	IMG_UINT32 ui32PageTableSize = 0;
-	IMG_SYS_PHYADDR *psSysPAddr = IMG_NULL;;
+	IMG_SYS_PHYADDR *psSysPAddr = IMG_NULL;
 
 	PVRSRV_BRIDGE_ASSERT_CMD(ui32BridgeID, PVRSRV_BRIDGE_WRAP_EXT_MEMORY);
 
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/buffer_manager.c kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/buffer_manager.c
--- kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/buffer_manager.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/buffer_manager.c	2011-09-04 11:37:54.000000000 +0200
@@ -30,6 +30,8 @@
 #include "ra.h"
 #include "pdump_km.h"
 
+#include <linux/kernel.h>
+
 #define MIN(a,b)       (a > b ? b : a)
 
 static IMG_BOOL
@@ -988,6 +990,34 @@ BM_IsWrapped(IMG_HANDLE hDevMemHeap,
 }
 
 IMG_BOOL
+BM_IsWrappedCheckSize(IMG_HANDLE hDevMemHeap,
+		 IMG_UINT32 ui32Offset,
+		 IMG_SYS_PHYADDR sSysAddr,
+		 IMG_UINT32 ui32ByteSize)
+{
+	BM_BUF *pBuf;
+	BM_CONTEXT *psBMContext;
+	BM_HEAP *psBMHeap;
+
+	IMG_BOOL ret = IMG_FALSE;
+
+	psBMHeap = (BM_HEAP *) hDevMemHeap;
+	psBMContext = psBMHeap->pBMContext;
+	sSysAddr.uiAddr += ui32Offset;
+	pBuf = (BM_BUF *) HASH_Retrieve(psBMContext->pBufferHash,
+			(IMG_UINTPTR_T) sSysAddr.uiAddr);
+
+	if (pBuf != NULL) {
+		if (pBuf->pMapping->uSize >= ui32ByteSize)
+			ret = IMG_TRUE;
+		else
+			ret = IMG_FALSE;
+	}
+
+	return ret;
+}
+
+IMG_BOOL
 BM_Wrap(IMG_HANDLE hDevMemHeap,
 	IMG_UINT32 ui32Size,
 	IMG_UINT32 ui32Offset,
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/buffer_manager.h kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/buffer_manager.h
--- kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/buffer_manager.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/buffer_manager.h	2011-09-04 11:37:54.000000000 +0200
@@ -138,6 +138,12 @@
 			 IMG_UINT32 ui32Offset, IMG_SYS_PHYADDR sSysAddr);
 
 	 IMG_BOOL
+	    BM_IsWrappedCheckSize(IMG_HANDLE hDevMemHeap,
+			 IMG_UINT32 ui32Offset,
+			 IMG_SYS_PHYADDR sSysAddr,
+			 IMG_UINT32 ui32ByteSize);
+
+	 IMG_BOOL
 	    BM_Wrap(IMG_HANDLE hDevMemHeap,
 		    IMG_UINT32 ui32Size,
 		    IMG_UINT32 ui32Offset,
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/devicemem.c kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/devicemem.c
--- kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/devicemem.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/devicemem.c	2011-09-04 11:37:54.000000000 +0200
@@ -34,6 +34,7 @@
 #include "pvr_bridge_km.h"
 
 #include "linux/kernel.h"
+#include "linux/pagemap.h"
 
 static PVRSRV_ERROR AllocDeviceMem(IMG_HANDLE hDevCookie,
 				   IMG_HANDLE hDevMemHeap,
@@ -595,13 +596,92 @@ static PVRSRV_ERROR UnwrapExtMemoryCallB
 	}
 
 	if (hOSWrapMem) {
-		OSReleasePhysPageAddr(hOSWrapMem);
+		OSReleasePhysPageAddr(hOSWrapMem, IMG_TRUE);
 	}
 
 	return eError;
 }
 
 IMG_EXPORT
+    PVRSRV_ERROR IMG_CALLCONV PVRSRVIsWrappedExtMemoryKM(IMG_HANDLE hDevCookie,
+							   PVRSRV_PER_PROCESS_DATA
+							   *psPerProc,
+							   IMG_UINT32
+							   *pui32ByteSize,
+							   IMG_VOID
+							   **pvLinAddr)
+{
+	DEVICE_MEMORY_INFO *psDevMemoryInfo;
+	IMG_UINT32 ui32HostPageSize = HOST_PAGESIZE();
+	PVRSRV_DEVICE_NODE *psDeviceNode;
+	PVRSRV_ERROR eError;
+	IMG_SYS_PHYADDR sIntSysPAddr;
+	IMG_HANDLE hOSWrapMem = IMG_NULL;
+	IMG_HANDLE hDevMemHeap;
+	IMG_UINT32 ui32PageOffset = 0;
+
+	IMG_UINT32 ui32ReturnedByteSize = *pui32ByteSize;
+
+	eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+
+	psDeviceNode = (PVRSRV_DEVICE_NODE *)hDevCookie;
+	PVR_ASSERT(psDeviceNode != IMG_NULL);
+	psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
+
+	hDevMemHeap = psDevMemoryInfo->psDeviceMemoryHeap[SGX_GENERAL_MAPPING_HEAP_ID].hDevMemHeap;
+
+	if (pvLinAddr) {
+		ui32PageOffset = ((IMG_UINT32)*pvLinAddr) & ~PAGE_MASK;
+		*pvLinAddr = (IMG_VOID *)((IMG_UINT32)*pvLinAddr & PAGE_MASK);
+		ui32ReturnedByteSize += ui32PageOffset;
+
+		/* let's start by getting the address of the first page */
+		eError = OSAcquirePhysPageAddr(*pvLinAddr,
+										ui32HostPageSize,
+										&sIntSysPAddr,
+										&hOSWrapMem,
+										IMG_FALSE);
+		if (eError != PVRSRV_OK) {
+			PVR_DPF((PVR_DBG_ERROR, "PVRSRVIsWrappedExtMemoryKM: Failed to alloc memory for block"));
+			eError = PVRSRV_ERROR_OUT_OF_MEMORY;
+			goto ErrorExitPhase1;
+		}
+
+		OSReleasePhysPageAddr(hOSWrapMem, IMG_FALSE);
+		hOSWrapMem = IMG_NULL;
+
+		/* now check if this memory address is already wrapped */
+		if (BM_IsWrappedCheckSize(hDevMemHeap,
+							ui32PageOffset,
+							sIntSysPAddr,
+							*pui32ByteSize)) {
+			/* already wrapped */
+			eError = PVRSRV_OK;
+		} else {
+			/* not mapped in this heap */
+			/* try the alternative heap */
+			hDevMemHeap = psDevMemoryInfo->psDeviceMemoryHeap[SGX_ALT_MAPPING_HEAP_ID].hDevMemHeap;
+
+			if (BM_IsWrappedCheckSize(hDevMemHeap,
+								ui32PageOffset,
+								sIntSysPAddr,
+								*pui32ByteSize)) {
+				/* already wrapped */
+				eError = PVRSRV_OK;
+			} else {
+				eError = PVRSRV_ERROR_BAD_MAPPING;
+			}
+		}
+	}
+
+ErrorExitPhase1:
+
+	*pui32ByteSize = ui32ReturnedByteSize;
+
+	return eError;
+}
+
+IMG_EXPORT
     PVRSRV_ERROR IMG_CALLCONV PVRSRVWrapExtMemoryKM(IMG_HANDLE hDevCookie,
 						    PVRSRV_PER_PROCESS_DATA *
 						    psPerProc,
@@ -631,6 +711,13 @@ IMG_EXPORT
 	IMG_SYS_PHYADDR *pPageList = psExtSysPAddr;
 	IMG_UINT32 ui32PageCount;
 
+	IMG_UINT32 ui32CalculatedPageOffset = ((IMG_UINT32)pvLinAddr) & ~PAGE_MASK;
+	if (ui32CalculatedPageOffset != ui32PageOffset)	{
+		PVR_DPF((PVR_DBG_ERROR,
+			"PVRSRVWrapExtMemoryKM: offset from address not match offset param"));
+		return PVRSRV_ERROR_BAD_MAPPING;
+	}
+
 	psDeviceNode = (PVRSRV_DEVICE_NODE *) hDevCookie;
 	PVR_ASSERT(psDeviceNode != IMG_NULL);
 	psDevMemoryInfo = &psDeviceNode->sDevMemoryInfo;
@@ -657,7 +744,7 @@ IMG_EXPORT
 		/* let's start by getting the address of the first page */
 		eError = OSAcquirePhysPageAddr(pvPageAlignedCPUVAddr,
 					       ui32HostPageSize,
-					       psIntSysPAddr, &hOSWrapMem);
+					       psIntSysPAddr, &hOSWrapMem, IMG_TRUE);
 		if (eError != PVRSRV_OK) {
 			PVR_DPF((PVR_DBG_ERROR,
 				 "PVRSRVWrapExtMemoryKM: Failed to alloc memory for block"));
@@ -667,10 +754,10 @@ IMG_EXPORT
 		/* now check if this memory address is already wrapped */
 		if (BM_IsWrapped(hDevMemHeap, ui32PageOffset, psIntSysPAddr[0])) {
 			/* already wrapped */
-			OSReleasePhysPageAddr(hOSWrapMem);
+			OSReleasePhysPageAddr(hOSWrapMem, IMG_TRUE);
 			hOSWrapMem = IMG_NULL;
 		} else if (ui32PageCount > 1) {
-			OSReleasePhysPageAddr(hOSWrapMem);
+			OSReleasePhysPageAddr(hOSWrapMem, IMG_TRUE);
 			hOSWrapMem = IMG_NULL;
 			/* the memory is going to wrapped for the first time,
 			 * so we need full page list */
@@ -678,7 +765,8 @@ IMG_EXPORT
 						       ui32PageCount *
 						       ui32HostPageSize,
 						       psIntSysPAddr,
-						       &hOSWrapMem);
+						       &hOSWrapMem,
+						       IMG_TRUE);
 			if (eError != PVRSRV_OK) {
 				PVR_DPF((PVR_DBG_ERROR,
 					 "PVRSRVWrapExtMemoryKM: Failed to alloc memory for block"));
@@ -783,7 +871,7 @@ ErrorExitPhase2:
 	}
 
 	if (hOSWrapMem)
-		OSReleasePhysPageAddr(hOSWrapMem);
+		OSReleasePhysPageAddr(hOSWrapMem, IMG_TRUE);
 ErrorExitPhase1:
 	if (psIntSysPAddr) {
 		OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/osfunc.c kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/osfunc.c
--- kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/osfunc.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/osfunc.c	2011-09-04 11:37:54.000000000 +0200
@@ -1126,6 +1126,7 @@ PVRSRV_ERROR OSEnableTimer(IMG_HANDLE hT
 
 	psTimerCBData->bActive = IMG_TRUE;
 
+	psTimerCBData->sTimer.expires = psTimerCBData->ui32Delay + jiffies;
 	add_timer(&psTimerCBData->sTimer);
 
 	return PVRSRV_OK;
@@ -1400,7 +1401,8 @@ exit_unlock:
 	return psPage;
 }
 
-PVRSRV_ERROR OSReleasePhysPageAddr(IMG_HANDLE hOSWrapMem)
+PVRSRV_ERROR OSReleasePhysPageAddr(IMG_HANDLE hOSWrapMem,
+							   IMG_BOOL bUseLock)
 {
 	sWrapMemInfo *psInfo = (sWrapMemInfo *) hOSWrapMem;
 	unsigned ui;
@@ -1415,7 +1417,8 @@ PVRSRV_ERROR OSReleasePhysPageAddr(IMG_H
 		{
 			struct vm_area_struct *psVMArea;
 
-			down_read(&current->mm->mmap_sem);
+			if (bUseLock)
+				down_read(&current->mm->mmap_sem);
 
 			psVMArea = find_vma(current->mm, psInfo->ulStartAddr);
 			if (psVMArea == NULL) {
@@ -1423,7 +1426,9 @@ PVRSRV_ERROR OSReleasePhysPageAddr(IMG_H
 				       ": OSCpuVToPageListRelease: Couldn't find memory region containing start address %lx",
 				       psInfo->ulStartAddr);
 
-				up_read(&current->mm->mmap_sem);
+				if (bUseLock)
+					up_read(&current->mm->mmap_sem);
+
 				break;
 			}
 
@@ -1459,7 +1464,9 @@ PVRSRV_ERROR OSReleasePhysPageAddr(IMG_H
 				       psVMArea->vm_flags);
 			}
 
-			up_read(&current->mm->mmap_sem);
+			if (bUseLock)
+				up_read(&current->mm->mmap_sem);
+
 			break;
 		}
 	default:
@@ -1514,10 +1521,11 @@ PVRSRV_ERROR OSReleasePhysPageAddr(IMG_H
 	return PVRSRV_OK;
 }
 
-PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_VOID * pvCPUVAddr,
+PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_VOID *pvCPUVAddr,
 				   IMG_UINT32 ui32Bytes,
-				   IMG_SYS_PHYADDR * psSysPAddr,
-				   IMG_HANDLE * phOSWrapMem)
+				   IMG_SYS_PHYADDR *psSysPAddr,
+				   IMG_HANDLE *phOSWrapMem,
+				   IMG_BOOL bUseLock)
 {
 	unsigned long ulStartAddrOrig = (unsigned long)pvCPUVAddr;
 	unsigned long ulAddrRangeOrig = (unsigned long)ui32Bytes;
@@ -1538,7 +1546,7 @@ PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_V
 	psInfo = kmalloc(sizeof(*psInfo), GFP_KERNEL);
 	if (psInfo == NULL) {
 		printk(KERN_WARNING
-		       ": OSCpuVToPageList: Couldn't allocate information structure");
+		       ": OSCpuVToPageList: Couldn't allocate information structure\n");
 		return PVRSRV_ERROR_OUT_OF_MEMORY;
 	}
 	memset(psInfo, 0, sizeof(*psInfo));
@@ -1556,7 +1564,7 @@ PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_V
 		    GFP_KERNEL);
 	if (psInfo->psPhysAddr == NULL) {
 		printk(KERN_WARNING
-		       ": OSCpuVToPageList: Couldn't allocate page array");
+		       ": OSCpuVToPageList: Couldn't allocate page array\n");
 		goto error_free;
 	}
 
@@ -1564,21 +1572,26 @@ PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_V
 	    kmalloc(psInfo->iNumPages * sizeof(*psInfo->ppsPages), GFP_KERNEL);
 	if (psInfo->ppsPages == NULL) {
 		printk(KERN_WARNING
-		       ": OSCpuVToPageList: Couldn't allocate page array");
+		       ": OSCpuVToPageList: Couldn't allocate page array\n");
 		goto error_free;
 	}
 
-	down_read(&current->mm->mmap_sem);
+	if (bUseLock)
+		down_read(&current->mm->mmap_sem);
+
 	iNumPagesMapped =
 	    get_user_pages(current, current->mm, ulStartAddr, psInfo->iNumPages,
 			   1, 0, psInfo->ppsPages, NULL);
-	up_read(&current->mm->mmap_sem);
+
+	if (bUseLock)
+		up_read(&current->mm->mmap_sem);
+
 
 	if (iNumPagesMapped >= 0) {
 
 		if (iNumPagesMapped != psInfo->iNumPages) {
 			printk(KERN_WARNING
-			       ": OSCpuVToPageList: Couldn't map all the pages needed (wanted: %d, got %d)",
+			       ": OSCpuVToPageList: Couldn't map all the pages needed (wanted: %d, got %d \n)",
 			       psInfo->iNumPages, iNumPagesMapped);
 
 			for (ui = 0; ui < iNumPagesMapped; ui++) {
@@ -1605,15 +1618,16 @@ PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_V
 	}
 
 	printk(KERN_WARNING
-	       ": OSCpuVToPageList: get_user_pages failed (%d), trying something else",
+	       ": OSCpuVToPageList: get_user_pages failed (%d), trying something else \n",
 	       iNumPagesMapped);
 
-	down_read(&current->mm->mmap_sem);
+	if (bUseLock)
+		down_read(&current->mm->mmap_sem);
 
 	psVMArea = find_vma(current->mm, ulStartAddrOrig);
 	if (psVMArea == NULL) {
 		printk(KERN_WARNING
-		       ": OSCpuVToPageList: Couldn't find memory region containing start address %lx",
+		       ": OSCpuVToPageList: Couldn't find memory region containing start address %lx \n",
 		       ulStartAddrOrig);
 
 		goto error_release_mmap_sem;
@@ -1624,14 +1638,14 @@ PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_V
 
 	if (ulStartAddrOrig < psVMArea->vm_start) {
 		printk(KERN_WARNING
-		       ": OSCpuVToPageList: Start address %lx is outside of the region returned by find_vma",
+		       ": OSCpuVToPageList: Start address %lx is outside of the region returned by find_vma\n",
 		       ulStartAddrOrig);
 		goto error_release_mmap_sem;
 	}
 
 	if (ulBeyondEndAddrOrig > psVMArea->vm_end) {
 		printk(KERN_WARNING
-		       ": OSCpuVToPageList: End address %lx is outside of the region returned by find_vma",
+		       ": OSCpuVToPageList: End address %lx is outside of the region returned by find_vma\n",
 		       ulBeyondEndAddrOrig);
 		goto error_release_mmap_sem;
 	}
@@ -1639,14 +1653,14 @@ PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_V
 	if ((psVMArea->vm_flags & (VM_IO | VM_RESERVED)) !=
 	    (VM_IO | VM_RESERVED)) {
 		printk(KERN_WARNING
-		       ": OSCpuVToPageList: Memory region does not represent memory mapped I/O (VMA flags: 0x%lx)",
+		       ": OSCpuVToPageList: Memory region does not represent memory mapped I/O (VMA flags: 0x%lx)\n",
 		       psVMArea->vm_flags);
 		goto error_release_mmap_sem;
 	}
 
 	if ((psVMArea->vm_flags & (VM_READ | VM_WRITE)) != (VM_READ | VM_WRITE)) {
 		printk(KERN_WARNING
-		       ": OSCpuVToPageList: No read/write access to memory region (VMA flags: 0x%lx)",
+		       ": OSCpuVToPageList: No read/write access to memory region (VMA flags: 0x%lx)\n",
 		       psVMArea->vm_flags);
 		goto error_release_mmap_sem;
 	}
@@ -1662,7 +1676,7 @@ PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_V
 			unsigned uj;
 
 			printk(KERN_WARNING
-			       ": OSCpuVToPageList: Couldn't lookup page structure for address 0x%lx, trying something else",
+			       ": OSCpuVToPageList: Couldn't lookup page structure for address 0x%lx, trying something else\n",
 			       ulAddr);
 
 			for (uj = 0; uj < ui; uj++) {
@@ -1693,7 +1707,7 @@ PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_V
 
 		if ((psVMArea->vm_flags & VM_PFNMAP) == 0) {
 			printk(KERN_WARNING
-			       ": OSCpuVToPageList: Region isn't a raw PFN mapping.  Giving up.");
+			       ": OSCpuVToPageList: Region isn't a raw PFN mapping.  Giving up.\n");
 			goto error_release_mmap_sem;
 		}
 
@@ -1714,10 +1728,11 @@ PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_V
 		psInfo->eType = WRAP_TYPE_FIND_VMA_PFN;
 
 		printk(KERN_WARNING
-		       ": OSCpuVToPageList: Region can't be locked down");
+		       ": OSCpuVToPageList: Region can't be locked down\n");
 	}
 
-	up_read(&current->mm->mmap_sem);
+	if (bUseLock)
+		up_read(&current->mm->mmap_sem);
 
 exit_check:
 	CheckPagesContiguous(psInfo);
@@ -1727,9 +1742,11 @@ exit_check:
 	return PVRSRV_OK;
 
 error_release_mmap_sem:
-	up_read(&current->mm->mmap_sem);
+	if (bUseLock)
+		up_read(&current->mm->mmap_sem);
+
 error_free:
 	psInfo->eType = WRAP_TYPE_CLEANUP;
-	OSReleasePhysPageAddr((IMG_HANDLE) psInfo);
+	OSReleasePhysPageAddr((IMG_HANDLE) psInfo, bUseLock);
 	return PVRSRV_ERROR_GENERIC;
 }
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/osfunc.h kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/osfunc.h
--- kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/osfunc.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/osfunc.h	2011-09-04 11:37:54.000000000 +0200
@@ -291,8 +291,10 @@
 	PVRSRV_ERROR OSAcquirePhysPageAddr(IMG_VOID * pvCPUVAddr,
 					   IMG_UINT32 ui32Bytes,
 					   IMG_SYS_PHYADDR * psSysPAddr,
-					   IMG_HANDLE * phOSWrapMem);
-	PVRSRV_ERROR OSReleasePhysPageAddr(IMG_HANDLE hOSWrapMem);
+					   IMG_HANDLE * phOSWrapMem,
+					   IMG_BOOL bUseLock);
+	PVRSRV_ERROR OSReleasePhysPageAddr(IMG_HANDLE hOSWrapMem,
+					   IMG_BOOL bUseLock);
 
 
 #endif
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/power.c kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/power.c
--- kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/power.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/power.c	2011-09-04 11:37:54.000000000 +0200
@@ -106,12 +106,16 @@ IMG_EXPORT IMG_VOID PVRSRVDvfsUnlock(IMG
 	mutex_unlock(&hPowerAndFreqLock);
 }
 
+static IMG_BOOL IsPowerLocked(void)
+{
+	return mutex_is_locked(&hPowerAndFreqLock) || gbDvfsActive;
+}
+
 IMG_EXPORT
     PVRSRV_ERROR PVRSRVPowerLock(IMG_UINT32 ui32CallerID,
 				 IMG_BOOL bSystemPowerEvent)
 {
-	if ((ui32CallerID == TIMER_ID) &&
-	    (mutex_is_locked(&hPowerAndFreqLock) || gbDvfsActive))
+	if ((ui32CallerID == TIMER_ID) && IsPowerLocked())
 		return PVRSRV_ERROR_RETRY;
 	mutex_lock(&hPowerAndFreqLock);
 	while (gbDvfsActive) {
@@ -553,11 +557,8 @@ IMG_EXPORT IMG_BOOL PVRSRVIsDevicePowere
 		return IMG_FALSE;
 	}
 
-	if (OSIsResourceLocked(&psSysData->sPowerStateChangeResource, KERNEL_ID)
-	    || OSIsResourceLocked(&psSysData->sPowerStateChangeResource,
-				  ISR_ID)) {
+	if (IsPowerLocked())
 		return IMG_FALSE;
-	}
 
 	psPowerDevice = psSysData->psPowerDeviceList;
 	while (psPowerDevice) {
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/pvr_bridge.h kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/pvr_bridge.h
--- kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/pvr_bridge.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/pvr_bridge.h	2011-09-04 11:37:54.000000000 +0200
@@ -307,8 +307,9 @@
 
 	typedef struct PVRSRV_BRIDGE_IN_CACHEFLUSHDRMFROMUSER_TAG {
 		IMG_UINT32 ui32BridgeFlags;
+		IMG_HANDLE hDevCookie;
 		IMG_UINT32 ui32Type;
-		IMG_UINT32 ui32Virt;
+		IMG_VOID *pvVirt;
 		IMG_UINT32 ui32Length;
 
 	} PVRSRV_BRIDGE_IN_CACHEFLUSHDRMFROMUSER;
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/pvr_bridge_km.h kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/pvr_bridge_km.h
--- kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/pvr_bridge_km.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/pvr_bridge_km.h	2011-09-04 11:37:54.000000000 +0200
@@ -186,6 +186,13 @@
 
 	 IMG_IMPORT
 	    PVRSRV_ERROR IMG_CALLCONV
+	    PVRSRVIsWrappedExtMemoryKM(IMG_HANDLE hDevCookie,
+						  PVRSRV_PER_PROCESS_DATA *psPerProc,
+						  IMG_UINT32 *pui32ByteSize,
+						  IMG_VOID **pvLinAddr);
+
+	 IMG_IMPORT
+	    PVRSRV_ERROR IMG_CALLCONV
 	    PVRSRVUnwrapExtMemoryKM(PVRSRV_KERNEL_MEM_INFO * psMemInfo);
 
 	 IMG_IMPORT
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/sgxconfig.h kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/sgxconfig.h
--- kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/sgxconfig.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/sgxconfig.h	2011-09-04 11:37:54.000000000 +0200
@@ -44,10 +44,10 @@
 #define SGX_GENERAL_HEAP_SIZE		(0x05000000-0x00401000)
 
 #define SGX_GENERAL_MAPPING_HEAP_BASE	0x05000000
-#define SGX_GENERAL_MAPPING_HEAP_SIZE	(0x06C00000-0x05001000)
+#define SGX_GENERAL_MAPPING_HEAP_SIZE	(0x06800000-0x05001000)
 
-#define SGX_FB_MAPPING_HEAP_BASE	0x06C00000
-#define SGX_FB_MAPPING_HEAP_SIZE	(0x07000000-0x06C01000)
+#define SGX_FB_MAPPING_HEAP_BASE	0x06800000
+#define SGX_FB_MAPPING_HEAP_SIZE	(0x07000000-0x06801000)
 
 #define SGX_TADATA_HEAP_BASE				0x07000000
 #define SGX_TADATA_HEAP_SIZE				(0x01000000-0x00001000)
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/sgxinit.c kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/sgxinit.c
--- kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/sgxinit.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/sgxinit.c	2011-09-04 11:37:54.000000000 +0200
@@ -225,8 +225,12 @@ static IMG_VOID SGXGetTimingInfo(PVRSRV_
 		}
 		if (psDevInfo->hTimer == IMG_NULL) {
 
+			/*
+			 * the magic calculation below sets the hardware lock-up
+			 * detection and recovery timer interval to ~150msecs
+			 */
 			psDevInfo->hTimer = OSAddTimer(SGXOSTimer, psDeviceNode,
-						       1000 * 50 /
+						       1000 * 150 /
 						       psSGXTimingInfo->
 						       ui32uKernelFreq);
 			if (psDevInfo->hTimer == IMG_NULL) {
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/sysconfig.h kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/sysconfig.h
--- kernel-2.6.28-20094102.6+0m5/drivers/gpu/pvr/sysconfig.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/gpu/pvr/sysconfig.h	2011-09-04 11:37:54.000000000 +0200
@@ -34,7 +34,7 @@
 #define SYS_SGX_CLOCK_SPEED	110666666
 #define SYS_SGX_HWRECOVERY_TIMEOUT_FREQ		(100)
 #define SYS_SGX_PDS_TIMER_FREQ			(1000)
-#define SYS_SGX_ACTIVE_POWER_LATENCY_MS		(500)
+#define SYS_SGX_ACTIVE_POWER_LATENCY_MS		(100)
 
 #define	SYS_OMAP3430_VDD2_OPP3_SGX_CLOCK_SPEED SYS_SGX_CLOCK_SPEED
 #define SYS_OMAP3430_VDD2_OPP2_SGX_CLOCK_SPEED (SYS_SGX_CLOCK_SPEED / 2)
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/media/video/et8ek8.c kernel-2.6.28-20094803.3+0m5/drivers/media/video/et8ek8.c
--- kernel-2.6.28-20094102.6+0m5/drivers/media/video/et8ek8.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/media/video/et8ek8.c	2011-09-04 11:37:54.000000000 +0200
@@ -777,10 +777,11 @@ static int et8ek8_ioctl_s_power(struct v
 				enum v4l2_power new_state)
 {
 	struct et8ek8_sensor *sensor = s->priv;
+	enum v4l2_power old_state = sensor->power;
 	int rval = 0;
 
 	/* If we are already in this mode, do nothing */
-	if (sensor->power == new_state)
+	if (old_state == new_state)
 		return 0;
 
 	/* Disable power if so requested (it was enabled) */
@@ -796,7 +797,7 @@ static int et8ek8_ioctl_s_power(struct v
 	/* Either STANDBY or ON requested */
 
 	/* Enable power and move to standby if it was off */
-	if (sensor->power == V4L2_POWER_OFF) {
+	if (old_state == V4L2_POWER_OFF) {
 		rval = et8ek8_power_on(s);
 		if (rval)
 			goto out;
@@ -806,10 +807,11 @@ static int et8ek8_ioctl_s_power(struct v
 
 	if (new_state == V4L2_POWER_ON) {
 		/* Standby -> streaming */
+		sensor->power = V4L2_POWER_ON;
 		rval = et8ek8_configure(s);
 		if (rval) {
 			et8ek8_stream_off(s);
-			if (sensor->power == V4L2_POWER_OFF)
+			if (old_state == V4L2_POWER_OFF)
 				et8ek8_power_off(s);
 			goto out;
 		}
@@ -820,9 +822,7 @@ static int et8ek8_ioctl_s_power(struct v
 	}
 
 out:
-	if (rval == 0)
-		sensor->power = new_state;
-
+	sensor->power = (rval == 0) ? new_state : old_state;
 	return rval;
 }
 
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isp_af.c kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isp_af.c
--- kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isp_af.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isp_af.c	2011-09-04 11:37:54.000000000 +0200
@@ -194,6 +194,7 @@ void isp_af_config_registers(struct isp_
 		       ~AF_PCR_MASK, pcr);
 
 	isp_af->update = 0;
+	isp_af->stat.config_counter++;
 	ispstat_bufs_set_size(&isp_af->stat, isp_af->buf_size);
 
 	spin_unlock_irqrestore(isp_af->lock, irqflags);
@@ -299,8 +300,8 @@ void isp_af_try_enable(struct isp_af_dev
 }
 
 /* Function to perform hardware set up */
-int omap34xx_isp_af_config(struct isp_af_device *isp_af,
-			   struct af_configuration *afconfig)
+int isp_af_config(struct isp_af_device *isp_af,
+		  struct af_configuration *afconfig)
 {
 	struct device *dev = to_device(isp_af);
 	int result;
@@ -337,14 +338,14 @@ int omap34xx_isp_af_config(struct isp_af
 	/* Success */
 	return 0;
 }
-EXPORT_SYMBOL(omap34xx_isp_af_config);
+EXPORT_SYMBOL(isp_af_config);
 
 /*
  * This API allows the user to update White Balance gains, as well as
  * exposure time and analog gain. It is also used to request frame
  * statistics.
  */
-int omap34xx_isp_af_request_statistics(struct isp_af_device *isp_af,
+int isp_af_request_statistics(struct isp_af_device *isp_af,
 			      struct isp_af_data *afdata)
 {
 	struct device *dev = to_device(isp_af);
@@ -374,7 +375,7 @@ int omap34xx_isp_af_request_statistics(s
 
 	return 0;
 }
-EXPORT_SYMBOL(omap34xx_isp_af_request_statistics);
+EXPORT_SYMBOL(isp_af_request_statistics);
 
 /* This function will handle the AF buffer. */
 int isp_af_buf_process(struct isp_af_device *isp_af)
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isp_af.h kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isp_af.h
--- kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isp_af.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isp_af.h	2011-09-04 11:37:54.000000000 +0200
@@ -131,9 +131,8 @@ void isp_af_suspend(struct isp_af_device
 void isp_af_resume(struct isp_af_device *);
 int isp_af_busy(struct isp_af_device *);
 void isp_af_config_registers(struct isp_af_device *isp_af);
-int omap34xx_isp_af_request_statistics(struct isp_af_device *,
-				       struct isp_af_data *afdata);
-int omap34xx_isp_af_config(struct isp_af_device *,
-			   struct af_configuration *afconfig);
+int isp_af_request_statistics(struct isp_af_device *,
+			      struct isp_af_data *afdata);
+int isp_af_config(struct isp_af_device *, struct af_configuration *afconfig);
 
 #endif	/* OMAP_ISP_AF_H */
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isp.c kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isp.c
--- kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isp.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isp.c	2011-09-04 11:37:54.000000000 +0200
@@ -294,7 +294,7 @@ static void isp_enable_interrupts(struct
 	u32 irq0enable;
 
 	irq0enable = IRQ0ENABLE_CCDC_LSC_PREF_ERR_IRQ
-		| IRQ0ENABLE_CCDC_VD0_IRQ
+		| IRQ0ENABLE_CCDC_VD0_IRQ | IRQ0ENABLE_HS_VS_IRQ
 		| IRQ0ENABLE_CSIA_IRQ
 		| IRQ0ENABLE_CSIB_IRQ | IRQ0ENABLE_HIST_DONE_IRQ
 		| IRQ0ENABLE_H3A_AWB_DONE_IRQ | IRQ0ENABLE_H3A_AF_DONE_IRQ
@@ -711,7 +711,7 @@ int isp_configure_interface(struct devic
 }
 EXPORT_SYMBOL(isp_configure_interface);
 
-void omap34xx_isp_hist_dma_done(struct device *dev)
+void isp_hist_dma_done(struct device *dev)
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
 	struct isp_irq *irqdis = &isp->irq;
@@ -734,7 +734,7 @@ void omap34xx_isp_hist_dma_done(struct d
 static void isp_buf_process(struct device *dev, struct isp_bufs *bufs);
 
 /**
- * omap34xx_isp_isr - Interrupt Service Routine for Camera ISP module.
+ * isp_isr - Interrupt Service Routine for Camera ISP module.
  * @irq: Not used currently.
  * @ispirq_disp: Pointer to the object that is passed while request_irq is
  *               called. This is the isp->irq object containing info on the
@@ -745,7 +745,7 @@ static void isp_buf_process(struct devic
  * Returns IRQ_HANDLED when IRQ was correctly handled, or IRQ_NONE when the
  * IRQ wasn't handled.
  **/
-static irqreturn_t omap34xx_isp_isr(int irq, void *_pdev)
+static irqreturn_t isp_isr(int irq, void *_pdev)
 {
 	struct device *dev = &((struct platform_device *)_pdev)->dev;
 	struct isp_device *isp = dev_get_drvdata(dev);
@@ -755,7 +755,7 @@ static irqreturn_t omap34xx_isp_isr(int
 	unsigned long flags;
 	u32 irqstatus = 0;
 	u32 sbl_pcr;
-	int wait_hs_vs = 0;
+	int wait_hs_vs;
 	int ret;
 
 	if (isp->running == ISP_STOPPED)
@@ -773,6 +773,8 @@ static irqreturn_t omap34xx_isp_isr(int
 	wait_hs_vs = bufs->wait_hs_vs;
 	if (irqstatus & CCDC_VD0 && bufs->wait_hs_vs)
 		bufs->wait_hs_vs--;
+	if (irqstatus & HS_VS && bufs->wait_stats && !bufs->wait_hs_vs)
+		bufs->wait_stats = 0;
 	/*
 	 * We need to wait for the first HS_VS interrupt from CCDC.
 	 * Otherwise our frame (and everything else) might be bad.
@@ -783,12 +785,18 @@ static irqreturn_t omap34xx_isp_isr(int
 		 * Enable preview for the first time. We just have
 		 * missed the start-of-frame so we can do it now.
 		 */
-		if (irqstatus & CCDC_VD0 &&
-		    !RAW_CAPTURE(isp) &&
-		    !(isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR) &
-		      (ISPPRV_PCR_BUSY | ISPPRV_PCR_EN))) {
-			isppreview_config_shadow_registers(&isp->isp_prev);
-			isppreview_enable(&isp->isp_prev, 1);
+		if (irqstatus & CCDC_VD0) {
+			isp_af_try_enable(&isp->isp_af);
+			isph3a_aewb_try_enable(&isp->isp_h3a);
+			isp_hist_try_enable(&isp->isp_hist);
+			if (!RAW_CAPTURE(isp) &&
+			    !(isp_reg_readl(dev, OMAP3_ISP_IOMEM_PREV,
+					    ISPPRV_PCR) &
+			      (ISPPRV_PCR_BUSY | ISPPRV_PCR_EN))) {
+				isppreview_config_shadow_registers(
+								&isp->isp_prev);
+				isppreview_enable(&isp->isp_prev, 1);
+			}
 		}
 	default:
 		/*
@@ -811,6 +819,13 @@ static irqreturn_t omap34xx_isp_isr(int
 
 		goto out_ignore_buff;
 	case 0:
+		if (bufs->wait_stats) {
+			if (irqstatus & (H3A_AWB_DONE | H3A_AF_DONE))
+				irqstatus &= ~(H3A_AWB_DONE | H3A_AF_DONE);
+			if (irqstatus & HIST_DONE)
+				isp_hist_mark_invalid_buf(&isp->isp_hist);
+		}
+
 		break;
 	}
 
@@ -965,7 +980,6 @@ static irqreturn_t omap34xx_isp_isr(int
 				     "busy.\n");
 			/* current and next buffer might have invalid data */
 			isp_hist_mark_invalid_buf(&isp->isp_hist);
-			irqstatus &= ~HIST_DONE;
 			ret = HIST_NO_BUF;
 		}
 		if (ret != HIST_BUF_WAITING_DMA)
@@ -974,7 +988,7 @@ static irqreturn_t omap34xx_isp_isr(int
 			irqstatus &= ~HIST_DONE;
 	}
 
-	if (irqdis->isp_callbk[CBK_CATCHALL]) {
+	if (irqdis->isp_callbk[CBK_CATCHALL] && irqstatus) {
 		irqdis->isp_callbk[CBK_CATCHALL](
 			irqstatus,
 			irqdis->isp_callbk_arg1[CBK_CATCHALL],
@@ -1123,6 +1137,11 @@ static int __isp_disable_modules(struct
 		isp_af_enable(&isp->isp_af, 0);
 		isph3a_aewb_enable(&isp->isp_h3a, 0);
 		isp_hist_enable(&isp->isp_hist, 0);
+
+		/* FIXME: find me a better interface */
+		isp->isp_af.config.af_config = 0;
+		isp->isp_h3a.aewb_config_local.aewb_enable = 0;
+		isp->isp_hist.config.enable = 0;
 	}
 	ispresizer_enable(&isp->isp_res, 0);
 	isppreview_enable(&isp->isp_prev, 0);
@@ -1424,6 +1443,7 @@ static void isp_buf_init(struct device *
 	bufs->queue = 0;
 	bufs->done = 0;
 	bufs->wait_hs_vs = isp->config->wait_hs_vs;
+	bufs->wait_stats = bufs->wait_hs_vs;
 	for (sg = 0; sg < NUM_BUFS; sg++) {
 		if (bufs->buf[sg].vb) {
 			bufs->buf[sg].vb->state = VIDEOBUF_ERROR;
@@ -1528,11 +1548,9 @@ int isp_buf_queue(struct device *dev, st
 		 * receiving a frame.
 		 */
 		bufs->wait_hs_vs++;
+		bufs->wait_stats = 1;
 		isp_enable_interrupts(dev, RAW_CAPTURE(isp));
 		isp_set_buf(dev, buf);
-		isp_af_try_enable(&isp->isp_af);
-		isph3a_aewb_try_enable(&isp->isp_h3a);
-		isp_hist_try_enable(&isp->isp_hist);
 		ispccdc_enable(&isp->isp_ccdc, 1);
 	}
 
@@ -1814,48 +1832,48 @@ int isp_handle_private(struct device *de
 
 	switch (cmd) {
 	case VIDIOC_PRIVATE_ISP_CCDC_CFG:
-		rval = omap34xx_isp_ccdc_config(&isp->isp_ccdc, arg);
+		rval = ispccdc_config(&isp->isp_ccdc, arg);
 		break;
 	case VIDIOC_PRIVATE_ISP_PRV_CFG:
-		rval = omap34xx_isp_preview_config(&isp->isp_prev, arg);
+		rval = isppreview_config(&isp->isp_prev, arg);
 		break;
 	case VIDIOC_PRIVATE_ISP_AEWB_CFG: {
 		struct isph3a_aewb_config *params;
 		params = (struct isph3a_aewb_config *)arg;
-		rval = omap34xx_isph3a_aewb_config(&isp->isp_h3a, params);
+		rval = isph3a_aewb_config(&isp->isp_h3a, params);
 	}
 		break;
 	case VIDIOC_PRIVATE_ISP_AEWB_REQ: {
 		struct isph3a_aewb_data *data;
 		data = (struct isph3a_aewb_data *)arg;
-		rval = omap34xx_isph3a_aewb_request_statistics(&isp->isp_h3a,
+		rval = isph3a_aewb_request_statistics(&isp->isp_h3a,
 							       data);
 	}
 		break;
 	case VIDIOC_PRIVATE_ISP_HIST_CFG: {
 		struct isp_hist_config *params;
 		params = (struct isp_hist_config *)arg;
-		rval = omap34xx_isp_hist_config(&isp->isp_hist, params);
+		rval = isp_hist_config(&isp->isp_hist, params);
 	}
 		break;
 	case VIDIOC_PRIVATE_ISP_HIST_REQ: {
 		struct isp_hist_data *data;
 		data = (struct isp_hist_data *)arg;
-		rval = omap34xx_isp_hist_request_statistics(&isp->isp_hist,
+		rval = isp_hist_request_statistics(&isp->isp_hist,
 							    data);
 	}
 		break;
 	case VIDIOC_PRIVATE_ISP_AF_CFG: {
 		struct af_configuration *params;
 		params = (struct af_configuration *)arg;
-		rval = omap34xx_isp_af_config(&isp->isp_af, params);
+		rval = isp_af_config(&isp->isp_af, params);
 
 	}
 		break;
 	case VIDIOC_PRIVATE_ISP_AF_REQ: {
 		struct isp_af_data *data;
 		data = (struct isp_af_data *)arg;
-		rval = omap34xx_isp_af_request_statistics(&isp->isp_af, data);
+		rval = isp_af_request_statistics(&isp->isp_af, data);
 	}
 		break;
 	default:
@@ -2029,7 +2047,7 @@ static void isp_save_ctx(struct device *
 	ispccdc_save_context(dev);
 	if (isp->iommu)
 		iommu_save_ctx(isp->iommu);
-	isphist_save_context(dev);
+	isp_hist_save_context(dev);
 	isph3a_save_context(dev);
 	isppreview_save_context(dev);
 	ispresizer_save_context(dev);
@@ -2049,7 +2067,7 @@ static void isp_restore_ctx(struct devic
 	ispccdc_restore_context(dev);
 	if (isp->iommu)
 		iommu_restore_ctx(isp->iommu);
-	isphist_restore_context(dev);
+	isp_hist_restore_context(dev);
 	isph3a_restore_context(dev);
 	isppreview_restore_context(dev);
 	ispresizer_restore_context(dev);
@@ -2389,7 +2407,7 @@ static int isp_probe(struct platform_dev
 		goto out_clk_get_l3_ick;
 	}
 
-	if (request_irq(isp->irq_num, omap34xx_isp_isr, IRQF_SHARED,
+	if (request_irq(isp->irq_num, isp_isr, IRQF_SHARED,
 			"Omap 3 Camera ISP", pdev)) {
 		dev_err(isp->dev, "could not install isr\n");
 		ret_err = -EINVAL;
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/ispccdc.c kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/ispccdc.c
--- kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/ispccdc.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/ispccdc.c	2011-09-04 11:37:54.000000000 +0200
@@ -29,6 +29,7 @@
 #include "ispccdc.h"
 
 #define LSC_TABLE_INIT_SIZE	50052
+#define PTR_FREE		((u32)(-ENOMEM))
 
 /* Structure for saving/restoring CCDC module registers*/
 static struct isp_reg ispccdc_reg_list[] = {
@@ -76,1008 +77,905 @@ static struct isp_reg ispccdc_reg_list[]
 };
 
 /**
- * omap34xx_isp_ccdc_config - Sets CCDC configuration from userspace
- * @userspace_add: Structure containing CCDC configuration sent from userspace.
+ * ispccdc_print_status - Prints the values of the CCDC Module registers
  *
- * Returns 0 if successful, -EINVAL if the pointer to the configuration
- * structure is null, or the copy_from_user function fails to copy user space
- * memory to kernel space memory.
+ * Also prints other debug information stored in the CCDC module.
  **/
-int omap34xx_isp_ccdc_config(struct isp_ccdc_device *isp_ccdc,
-			     void *userspace_add)
+static void ispccdc_print_status(struct isp_ccdc_device *isp_ccdc,
+				 struct isp_pipeline *pipe)
 {
-	struct isp_device *isp = to_isp_device(isp_ccdc);
-	struct ispccdc_bclamp bclamp_t;
-	struct ispccdc_blcomp blcomp_t;
-	struct ispccdc_fpc fpc_t;
-	struct ispccdc_culling cull_t;
-	struct ispccdc_update_config *ccdc_struct;
-
-	if (userspace_add == NULL)
-		return -EINVAL;
-
-	ccdc_struct = userspace_add;
-
-	if (ISP_ABS_CCDC_ALAW & ccdc_struct->flag) {
-		if (ISP_ABS_CCDC_ALAW & ccdc_struct->update)
-			ispccdc_config_alaw(isp_ccdc, ccdc_struct->alawip);
-		ispccdc_enable_alaw(isp_ccdc, 1);
-	} else if (ISP_ABS_CCDC_ALAW & ccdc_struct->update)
-		ispccdc_enable_alaw(isp_ccdc, 0);
-
-	if (ISP_ABS_CCDC_LPF & ccdc_struct->flag)
-		ispccdc_enable_lpf(isp_ccdc, 1);
-	else
-		ispccdc_enable_lpf(isp_ccdc, 0);
-
-	if (ISP_ABS_CCDC_BLCLAMP & ccdc_struct->flag) {
-		if (ISP_ABS_CCDC_BLCLAMP & ccdc_struct->update) {
-			if (copy_from_user(&bclamp_t, (struct ispccdc_bclamp *)
-					   ccdc_struct->bclamp,
-					   sizeof(struct ispccdc_bclamp)))
-				goto copy_from_user_err;
-
-			ispccdc_enable_black_clamp(isp_ccdc, 1);
-			ispccdc_config_black_clamp(isp_ccdc, bclamp_t);
-		} else
-			ispccdc_enable_black_clamp(isp_ccdc, 1);
-	} else {
-		if (ISP_ABS_CCDC_BLCLAMP & ccdc_struct->update) {
-			if (copy_from_user(&bclamp_t, (struct ispccdc_bclamp *)
-					   ccdc_struct->bclamp,
-					   sizeof(struct ispccdc_bclamp)))
-				goto copy_from_user_err;
-
-			ispccdc_enable_black_clamp(isp_ccdc, 0);
-			ispccdc_config_black_clamp(isp_ccdc, bclamp_t);
-		}
-	}
-
-	if (ISP_ABS_CCDC_BCOMP & ccdc_struct->update) {
-		if (copy_from_user(&blcomp_t, (struct ispccdc_blcomp *)
-				   ccdc_struct->blcomp,
-				   sizeof(blcomp_t)))
-			goto copy_from_user_err;
-
-		ispccdc_config_black_comp(isp_ccdc, blcomp_t);
-	}
-
-	if (ISP_ABS_CCDC_FPC & ccdc_struct->flag) {
-		if (ISP_ABS_CCDC_FPC & ccdc_struct->update) {
-			if (copy_from_user(&fpc_t, (struct ispccdc_fpc *)
-					   ccdc_struct->fpc,
-					   sizeof(fpc_t)))
-				goto copy_from_user_err;
-			isp_ccdc->fpc_table_add = kmalloc(64 + fpc_t.fpnum * 4,
-						GFP_KERNEL | GFP_DMA);
-			if (!isp_ccdc->fpc_table_add) {
-				dev_err(to_device(isp_ccdc),
-					"ccdc: Cannot allocate memory for"
-					" FPC table");
-				return -ENOMEM;
-			}
-			while (((unsigned long)isp_ccdc->fpc_table_add
-				& 0xFFFFFFC0)
-			       != (unsigned long)isp_ccdc->fpc_table_add)
-				isp_ccdc->fpc_table_add++;
-
-			isp_ccdc->fpc_table_add_m = iommu_kmap(
-				isp->iommu,
-				0,
-				virt_to_phys(isp_ccdc->fpc_table_add),
-				fpc_t.fpnum * 4,
-				IOMMU_FLAG);
-			/* FIXME: Correct unwinding */
-			BUG_ON(IS_ERR_VALUE(isp_ccdc->fpc_table_add_m));
-
-			if (copy_from_user(isp_ccdc->fpc_table_add,
-					   (u32 *)fpc_t.fpcaddr,
-					   fpc_t.fpnum * 4))
-				goto copy_from_user_err;
-
-			fpc_t.fpcaddr = isp_ccdc->fpc_table_add_m;
-			ispccdc_config_fpc(isp_ccdc, fpc_t);
-		}
-		ispccdc_enable_fpc(isp_ccdc, 1);
-	} else if (ISP_ABS_CCDC_FPC & ccdc_struct->update)
-		ispccdc_enable_fpc(isp_ccdc, 0);
+	if (!is_ispccdc_debug_enabled())
+		return;
 
-	if (ISP_ABS_CCDC_CULL & ccdc_struct->update) {
-		if (copy_from_user(&cull_t, (struct ispccdc_culling *)
-				   ccdc_struct->cull,
-				   sizeof(cull_t)))
-			goto copy_from_user_err;
-		ispccdc_config_culling(isp_ccdc, cull_t);
+	DPRINTK_ISPCCDC("Module in use =%d\n", isp_ccdc->ccdc_inuse);
+	DPRINTK_ISPCCDC("Accepted CCDC Input (width = %d,Height = %d)\n",
+			isp_ccdc->ccdcin_w,
+			isp_ccdc->ccdcin_h);
+	DPRINTK_ISPCCDC("Accepted CCDC Output (width = %d,Height = %d)\n",
+			isp_ccdc->ccdcout_w,
+			isp_ccdc->ccdcout_h);
+	DPRINTK_ISPCCDC("###CCDC PCR=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_PCR));
+	DPRINTK_ISPCCDC("ISP_CTRL =0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
+				      ISP_CTRL));
+	switch (pipe->ccdc_in) {
+	case CCDC_RAW:
+		DPRINTK_ISPCCDC("ccdc input format is CCDC_RAW\n");
+		break;
+	case CCDC_YUV_SYNC:
+		DPRINTK_ISPCCDC("ccdc input format is CCDC_YUV_SYNC\n");
+		break;
+	case CCDC_YUV_BT:
+		DPRINTK_ISPCCDC("ccdc input format is CCDC_YUV_BT\n");
+		break;
+	default:
+		break;
 	}
 
-	if (is_isplsc_activated()) {
-		if (ISP_ABS_CCDC_CONFIG_LSC & ccdc_struct->flag) {
-			if (ISP_ABS_CCDC_CONFIG_LSC & ccdc_struct->update) {
-				if (copy_from_user(
-					    &isp_ccdc->lsc_config,
-					    (struct ispccdc_lsc_config *)
-					    ccdc_struct->lsc_cfg,
-					    sizeof(struct ispccdc_lsc_config)))
-					goto copy_from_user_err;
-				ispccdc_config_lsc(isp_ccdc,
-						   &isp_ccdc->lsc_config);
-			}
-			ispccdc_enable_lsc(isp_ccdc, 1);
-		} else if (ISP_ABS_CCDC_CONFIG_LSC & ccdc_struct->update) {
-			ispccdc_enable_lsc(isp_ccdc, 0);
-		}
-		if (ISP_ABS_TBL_LSC & ccdc_struct->update) {
-			if (copy_from_user(isp_ccdc->lsc_gain_table,
-					   ccdc_struct->lsc,
-					   isp_ccdc->lsc_config.size))
-				goto copy_from_user_err;
-			ispccdc_load_lsc(isp_ccdc, isp_ccdc->lsc_gain_table,
-					 isp_ccdc->lsc_config.size);
-		}
+	switch (pipe->ccdc_out) {
+	case CCDC_OTHERS_VP:
+		DPRINTK_ISPCCDC("ccdc output format is CCDC_OTHERS_VP\n");
+		break;
+	case CCDC_OTHERS_MEM:
+		DPRINTK_ISPCCDC("ccdc output format is CCDC_OTHERS_MEM\n");
+		break;
+	case CCDC_YUV_RSZ:
+		DPRINTK_ISPCCDC("ccdc output format is CCDC_YUV_RSZ\n");
+		break;
+	default:
+		break;
 	}
 
-	if (ISP_ABS_CCDC_COLPTN & ccdc_struct->update)
-		ispccdc_config_imgattr(isp_ccdc, ccdc_struct->colptn);
-
-	return 0;
-
-copy_from_user_err:
-	dev_err(isp->dev, "ccdc: Config: copy from user error");
-	return -EINVAL ;
-}
-
-/**
- * Set the value to be used for CCDC_CFG.WENLOG.
- *  w - Value of wenlog.
- */
-void ispccdc_set_wenlog(struct isp_ccdc_device *isp_ccdc, u32 wenlog)
-{
-	isp_ccdc->wenlog = wenlog;
+	DPRINTK_ISPCCDC("###ISP_CTRL in ccdc =0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
+				      ISP_CTRL));
+	DPRINTK_ISPCCDC("###ISP_IRQ0ENABLE in ccdc =0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
+				      ISP_IRQ0ENABLE));
+	DPRINTK_ISPCCDC("###ISP_IRQ0STATUS in ccdc =0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
+				      ISP_IRQ0STATUS));
+	DPRINTK_ISPCCDC("###CCDC SYN_MODE=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_SYN_MODE));
+	DPRINTK_ISPCCDC("###CCDC HORZ_INFO=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_HORZ_INFO));
+	DPRINTK_ISPCCDC("###CCDC VERT_START=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_VERT_START));
+	DPRINTK_ISPCCDC("###CCDC VERT_LINES=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_VERT_LINES));
+	DPRINTK_ISPCCDC("###CCDC CULLING=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_CULLING));
+	DPRINTK_ISPCCDC("###CCDC HSIZE_OFF=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_HSIZE_OFF));
+	DPRINTK_ISPCCDC("###CCDC SDOFST=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_SDOFST));
+	DPRINTK_ISPCCDC("###CCDC SDR_ADDR=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_SDR_ADDR));
+	DPRINTK_ISPCCDC("###CCDC CLAMP=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_CLAMP));
+	DPRINTK_ISPCCDC("###CCDC COLPTN=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_COLPTN));
+	DPRINTK_ISPCCDC("###CCDC CFG=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_CFG));
+	DPRINTK_ISPCCDC("###CCDC VP_OUT=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_VP_OUT));
+	DPRINTK_ISPCCDC("###CCDC_SDR_ADDR= 0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_SDR_ADDR));
+	DPRINTK_ISPCCDC("###CCDC FMTCFG=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_FMTCFG));
+	DPRINTK_ISPCCDC("###CCDC FMT_HORZ=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_FMT_HORZ));
+	DPRINTK_ISPCCDC("###CCDC FMT_VERT=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_FMT_VERT));
+	DPRINTK_ISPCCDC("###CCDC LSC_CONFIG=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_LSC_CONFIG));
+	DPRINTK_ISPCCDC("###CCDC LSC_INIT=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_LSC_INITIAL));
+	DPRINTK_ISPCCDC("###CCDC LSC_TABLE BASE=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_LSC_TABLE_BASE));
+	DPRINTK_ISPCCDC("###CCDC LSC TABLE OFFSET=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_LSC_TABLE_OFFSET));
 }
 
 /**
- * ispccdc_request - Reserves the CCDC module.
- *
- * Reserves the CCDC module and assures that is used only once at a time.
+ * ispccdc_config_black_clamp - Configures the clamp parameters in CCDC.
+ * @bclamp: Structure containing the optical black average gain, optical black
+ *          sample length, sample lines, and the start pixel position of the
+ *          samples w.r.t the HS pulse.
+ * Configures the clamp parameters in CCDC. Either if its being used the
+ * optical black clamp, or the digital clamp. If its a digital clamp, then
+ * assures to put a valid DC substraction level.
  *
- * Returns 0 if successful, or -EBUSY if CCDC module is busy.
+ * Returns always 0 when completed.
  **/
-int ispccdc_request(struct isp_ccdc_device *isp_ccdc)
+static int ispccdc_config_black_clamp(struct isp_ccdc_device *isp_ccdc,
+				      struct ispccdc_bclamp bclamp)
 {
 	struct device *dev = to_device(isp_ccdc);
+	u32 bclamp_val = 0;
 
-	mutex_lock(&isp_ccdc->mutexlock);
-	if (isp_ccdc->ccdc_inuse) {
-		mutex_unlock(&isp_ccdc->mutexlock);
-		DPRINTK_ISPCCDC("ISP_ERR : CCDC Module Busy\n");
-		return -EBUSY;
+	if (isp_ccdc->obclamp_en) {
+		bclamp_val |= bclamp.obgain << ISPCCDC_CLAMP_OBGAIN_SHIFT;
+		bclamp_val |= bclamp.oblen << ISPCCDC_CLAMP_OBSLEN_SHIFT;
+		bclamp_val |= bclamp.oblines << ISPCCDC_CLAMP_OBSLN_SHIFT;
+		bclamp_val |= bclamp.obstpixel << ISPCCDC_CLAMP_OBST_SHIFT;
+		isp_reg_writel(dev, bclamp_val,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CLAMP);
+	} else {
+		if (omap_rev() < OMAP3430_REV_ES2_0)
+			if (isp_ccdc->syncif_ipmod == YUV16 ||
+			    isp_ccdc->syncif_ipmod == YUV8 ||
+			    isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+					  ISPCCDC_REC656IF) &
+			    ISPCCDC_REC656IF_R656ON)
+				bclamp.dcsubval = 0;
+		isp_reg_writel(dev, bclamp.dcsubval,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_DCSUB);
 	}
-
-	isp_ccdc->ccdc_inuse = 1;
-	mutex_unlock(&isp_ccdc->mutexlock);
-	isp_reg_or(dev, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,
-		   ISPCTRL_CCDC_RAM_EN | ISPCTRL_CCDC_CLK_EN |
-		   ISPCTRL_SBL_WR1_RAM_EN);
-	isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,
-		   ISPCCDC_CFG_VDLC);
 	return 0;
 }
 
 /**
- * ispccdc_free - Frees the CCDC module.
- *
- * Frees the CCDC module so it can be used by another process.
+ * ispccdc_enable_black_clamp - Enables/Disables the optical black clamp.
+ * @enable: 0 Disables optical black clamp, 1 Enables optical black clamp.
  *
- * Returns 0 if successful, or -EINVAL if module has been already freed.
+ * Enables or disables the optical black clamp. When disabled, the digital
+ * clamp operates.
  **/
-int ispccdc_free(struct isp_ccdc_device *isp_ccdc)
+static void ispccdc_enable_black_clamp(struct isp_ccdc_device *isp_ccdc,
+				       u8 enable)
 {
-	mutex_lock(&isp_ccdc->mutexlock);
-	if (!isp_ccdc->ccdc_inuse) {
-		mutex_unlock(&isp_ccdc->mutexlock);
-		DPRINTK_ISPCCDC("ISP_ERR: CCDC Module already freed\n");
-		return -EINVAL;
-	}
+	struct device *dev = to_device(isp_ccdc);
 
-	isp_ccdc->ccdc_inuse = 0;
-	mutex_unlock(&isp_ccdc->mutexlock);
-	isp_reg_and(to_device(isp_ccdc), OMAP3_ISP_IOMEM_MAIN,
-		    ISP_CTRL, ~(ISPCTRL_CCDC_CLK_EN |
-				ISPCTRL_CCDC_RAM_EN |
-				ISPCTRL_SBL_WR1_RAM_EN));
-	return 0;
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CLAMP,
+		       ~ISPCCDC_CLAMP_CLAMPEN,
+		       enable ? ISPCCDC_CLAMP_CLAMPEN : 0);
+	isp_ccdc->obclamp_en = enable;
 }
 
 /**
- * ispccdc_free_lsc - Frees Lens Shading Compensation table
+ * ispccdc_config_fpc - Configures the Faulty Pixel Correction parameters.
+ * @fpc: Structure containing the number of faulty pixels corrected in the
+ *       frame, address of the FPC table.
  *
- * Always returns 0.
+ * Returns 0 if successful, or -EINVAL if FPC Address is not on the 64 byte
+ * boundary.
  **/
-static int ispccdc_free_lsc(struct isp_ccdc_device *isp_ccdc)
+static int ispccdc_config_fpc(struct isp_ccdc_device *isp_ccdc,
+			      struct ispccdc_fpc fpc)
 {
-	struct isp_device *isp = to_isp_device(isp_ccdc);
+	struct device *dev = to_device(isp_ccdc);
+	u32 fpc_val = 0;
 
-	if (!isp_ccdc->lsc_ispmmu_addr)
-		return 0;
+	fpc_val = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC);
 
-	ispccdc_enable_lsc(isp_ccdc, 0);
-	isp_ccdc->lsc_initialized = 0;
-	isp_reg_writel(to_device(isp_ccdc), 0, OMAP3_ISP_IOMEM_CCDC,
-		       ISPCCDC_LSC_TABLE_BASE);
-	iommu_vfree(isp->iommu, isp_ccdc->lsc_ispmmu_addr);
-	isp_ccdc->lsc_gain_table = NULL;
+	if ((fpc.fpcaddr & 0xFFFFFFC0) == fpc.fpcaddr) {
+		isp_reg_writel(dev, fpc_val & (~ISPCCDC_FPC_FPCEN),
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC);
+		isp_reg_writel(dev, fpc.fpcaddr,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC_ADDR);
+	} else {
+		DPRINTK_ISPCCDC("FPC Address should be on 64byte boundary\n");
+		return -EINVAL;
+	}
+	isp_reg_writel(dev, fpc_val | (fpc.fpnum << ISPCCDC_FPC_FPNUM_SHIFT),
+		       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC);
 	return 0;
 }
 
 /**
- * ispccdc_allocate_lsc - Allocate space for Lens Shading Compensation table
- * @table_size: LSC gain table size.
- *
- * Returns 0 if successful, -ENOMEM of its no memory available, or -EINVAL if
- * table_size is zero.
+ * ispccdc_enable_fpc - Enables the Faulty Pixel Correction.
+ * @enable: 0 Disables FPC, 1 Enables FPC.
  **/
-static int ispccdc_allocate_lsc(struct isp_ccdc_device *isp_ccdc,
-				u32 table_size)
+static void ispccdc_enable_fpc(struct isp_ccdc_device *isp_ccdc, u8 enable)
 {
-	struct isp_device *isp = to_isp_device(isp_ccdc);
-
-	if (table_size == 0)
-		return -EINVAL;
+	struct device *dev = to_device(isp_ccdc);
 
-	if ((isp_ccdc->lsc_config.size >= table_size)
-	    && isp_ccdc->lsc_gain_table)
-		return 0;
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC,
+		       ~ISPCCDC_FPC_FPCEN, enable ? ISPCCDC_FPC_FPCEN : 0);
+}
 
-	ispccdc_free_lsc(isp_ccdc);
+/**
+ * ispccdc_config_black_comp - Configures Black Level Compensation parameters.
+ * @blcomp: Structure containing the black level compensation value for RGrGbB
+ *          pixels. in 2's complement.
+ **/
+static void ispccdc_config_black_comp(struct isp_ccdc_device *isp_ccdc,
+				      struct ispccdc_blcomp blcomp)
+{
+	struct device *dev = to_device(isp_ccdc);
+	u32 blcomp_val = 0;
 
-	isp_ccdc->lsc_ispmmu_addr = iommu_vmalloc(isp->iommu, 0, table_size,
-						  IOMMU_FLAG);
-	if (IS_ERR_VALUE(isp_ccdc->lsc_ispmmu_addr)) {
-		dev_err(to_device(isp_ccdc),
-			"ccdc: Cannot allocate memory for gain tables\n");
-		isp_ccdc->lsc_ispmmu_addr = 0;
-		return -ENOMEM;
-	}
-	isp_ccdc->lsc_gain_table = da_to_va(isp->iommu,
-					    (u32)isp_ccdc->lsc_ispmmu_addr);
+	blcomp_val |= blcomp.b_mg << ISPCCDC_BLKCMP_B_MG_SHIFT;
+	blcomp_val |= blcomp.gb_g << ISPCCDC_BLKCMP_GB_G_SHIFT;
+	blcomp_val |= blcomp.gr_cy << ISPCCDC_BLKCMP_GR_CY_SHIFT;
+	blcomp_val |= blcomp.r_ye << ISPCCDC_BLKCMP_R_YE_SHIFT;
 
-	return 0;
+	isp_reg_writel(dev, blcomp_val, OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_BLKCMP);
 }
 
 /**
- * ispccdc_program_lsc - Program Lens Shading Compensation table.
- * @table_size: LSC gain table size.
- *
- * Returns 0 if successful, or -EINVAL if there's no mapped address for the
- * table yet.
+ * ispccdc_config_vp - Configures the Video Port Configuration parameters.
+ * @vpcfg: Structure containing the Video Port input frequency, and the 10 bit
+ *         format.
  **/
-static int ispccdc_program_lsc(struct isp_ccdc_device *isp_ccdc)
+static void ispccdc_config_vp(struct isp_ccdc_device *isp_ccdc,
+			      struct ispccdc_vp vpcfg)
 {
-	if (!isp_ccdc->lsc_ispmmu_addr)
-		return -EINVAL;
+	struct device *dev = to_device(isp_ccdc);
+	u32 fmtcfg_vp = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_FMTCFG);
 
-	if (isp_ccdc->lsc_initialized)
-		return 0;
+	fmtcfg_vp &= ISPCCDC_FMTCFG_VPIN_MASK & ISPCCDC_FMTCFG_VPIF_FRQ_MASK;
 
-	isp_reg_writel(to_device(isp_ccdc), isp_ccdc->lsc_ispmmu_addr,
-		       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_TABLE_BASE);
-	isp_ccdc->lsc_initialized = 1;
-	return 0;
+	switch (vpcfg.bitshift_sel) {
+	case BIT9_0:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIN_9_0;
+		break;
+	case BIT10_1:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIN_10_1;
+		break;
+	case BIT11_2:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIN_11_2;
+		break;
+	case BIT12_3:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIN_12_3;
+		break;
+	};
+	switch (vpcfg.freq_sel) {
+	case PIXCLKBY2:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIF_FRQ_BY2;
+		break;
+	case PIXCLKBY3_5:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIF_FRQ_BY3;
+		break;
+	case PIXCLKBY4_5:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIF_FRQ_BY4;
+		break;
+	case PIXCLKBY5_5:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIF_FRQ_BY5;
+		break;
+	case PIXCLKBY6_5:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIF_FRQ_BY6;
+		break;
+	};
+	isp_reg_writel(dev, fmtcfg_vp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG);
 }
 
 /**
- * ispccdc_load_lsc - Load Lens Shading Compensation table.
- * @table_addr: LSC gain table MMU Mapped address.
- * @table_size: LSC gain table size.
- *
- * Returns 0 if successful, -ENOMEM of its no memory available, or -EINVAL if
- * table_size is zero.
+ * ispccdc_enable_vp - Enables the Video Port.
+ * @enable: 0 Disables VP, 1 Enables VP
  **/
-int ispccdc_load_lsc(struct isp_ccdc_device *isp_ccdc, u8 *table_addr,
-		     u32 table_size)
+static void ispccdc_enable_vp(struct isp_ccdc_device *isp_ccdc, u8 enable)
 {
-	int ret;
-
-	if (!is_isplsc_activated())
-		return 0;
-
-	if (!table_addr)
-		return -EINVAL;
+	struct device *dev = to_device(isp_ccdc);
 
-	ret = ispccdc_allocate_lsc(isp_ccdc, table_size);
-	if (ret)
-		return ret;
-
-	if (table_addr != isp_ccdc->lsc_gain_table)
-		memcpy(isp_ccdc->lsc_gain_table, table_addr, table_size);
-	ret = ispccdc_program_lsc(isp_ccdc);
-	if (ret)
-		return ret;
-	return 0;
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG,
+		       ~ISPCCDC_FMTCFG_VPEN,
+		       enable ? ISPCCDC_FMTCFG_VPEN : 0);
 }
 
 /**
- * ispccdc_config_lsc - Configures the lens shading compensation module
- * @lsc_cfg: LSC configuration structure
+ * ispccdc_config_culling - Configures the culling parameters.
+ * @cull: Structure containing the vertical culling pattern, and horizontal
+ *        culling pattern for odd and even lines.
  **/
-void ispccdc_config_lsc(struct isp_ccdc_device *isp_ccdc,
-			struct ispccdc_lsc_config *lsc_cfg)
+static void ispccdc_config_culling(struct isp_ccdc_device *isp_ccdc,
+				   struct ispccdc_culling cull)
 {
 	struct device *dev = to_device(isp_ccdc);
-	int reg;
 
-	if (!is_isplsc_activated())
-		return;
-
-	ispccdc_enable_lsc(isp_ccdc, 0);
-	isp_reg_writel(dev, lsc_cfg->offset, OMAP3_ISP_IOMEM_CCDC,
-		       ISPCCDC_LSC_TABLE_OFFSET);
+	u32 culling_val = 0;
 
-	reg = 0;
-	reg |= lsc_cfg->gain_mode_n << ISPCCDC_LSC_GAIN_MODE_N_SHIFT;
-	reg |= lsc_cfg->gain_mode_m << ISPCCDC_LSC_GAIN_MODE_M_SHIFT;
-	reg |= lsc_cfg->gain_format << ISPCCDC_LSC_GAIN_FORMAT_SHIFT;
-	isp_reg_writel(dev, reg, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_CONFIG);
+	culling_val |= cull.v_pattern << ISPCCDC_CULLING_CULV_SHIFT;
+	culling_val |= cull.h_even << ISPCCDC_CULLING_CULHEVN_SHIFT;
+	culling_val |= cull.h_odd << ISPCCDC_CULLING_CULHODD_SHIFT;
 
-	reg = 0;
-	reg &= ~ISPCCDC_LSC_INITIAL_X_MASK;
-	reg |= lsc_cfg->initial_x << ISPCCDC_LSC_INITIAL_X_SHIFT;
-	reg &= ~ISPCCDC_LSC_INITIAL_Y_MASK;
-	reg |= lsc_cfg->initial_y << ISPCCDC_LSC_INITIAL_Y_SHIFT;
-	isp_reg_writel(dev, reg, OMAP3_ISP_IOMEM_CCDC,
-		       ISPCCDC_LSC_INITIAL);
+	isp_reg_writel(dev, culling_val, OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_CULLING);
 }
 
 /**
- * ispccdc_enable_lsc - Enables/Disables the Lens Shading Compensation module.
- * @enable: 0 Disables LSC, 1 Enables LSC.
+ * ispccdc_enable_lpf - Enables the Low-Pass Filter (LPF).
+ * @enable: 0 Disables LPF, 1 Enables LPF
  **/
-void ispccdc_enable_lsc(struct isp_ccdc_device *isp_ccdc, u8 enable)
+static void ispccdc_enable_lpf(struct isp_ccdc_device *isp_ccdc, u8 enable)
 {
 	struct device *dev = to_device(isp_ccdc);
 
-	if (!is_isplsc_activated())
-		return;
-
-	if (enable) {
-		if (!ispccdc_busy(isp_ccdc)) {
-			isp_reg_or(dev, OMAP3_ISP_IOMEM_MAIN,
-				   ISP_CTRL, ISPCTRL_SBL_SHARED_RPORTB
-				   | ISPCTRL_SBL_RD_RAM_EN);
-
-			isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC,
-				   ISPCCDC_LSC_CONFIG, 0x1);
-
-			isp_ccdc->lsc_state = 1;
-		} else {
-			/* Postpone enabling LSC */
-			isp_ccdc->lsc_enable = 1;
-		}
-	} else {
-		isp_reg_and(dev, OMAP3_ISP_IOMEM_CCDC,
-			    ISPCCDC_LSC_CONFIG, 0xFFFE);
-		isp_ccdc->lsc_state = 0;
-		isp_ccdc->lsc_enable = 0;
-	}
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE,
+		       ~ISPCCDC_SYN_MODE_LPF,
+		       enable ? ISPCCDC_SYN_MODE_LPF : 0);
 }
 
-void ispccdc_lsc_error_handler(struct isp_ccdc_device *isp_ccdc)
+/**
+ * ispccdc_config_alaw - Configures the input width for A-law.
+ * @ipwidth: Input width for A-law
+ **/
+static void ispccdc_config_alaw(struct isp_ccdc_device *isp_ccdc,
+				enum alaw_ipwidth ipwidth)
 {
-	int lsc_enable = isp_ccdc->lsc_state;
-
-	ispccdc_enable_lsc(isp_ccdc, 0);
+	struct device *dev = to_device(isp_ccdc);
 
-	isp_ccdc->lsc_enable = lsc_enable;
+	isp_reg_writel(dev, ipwidth << ISPCCDC_ALAW_GWDI_SHIFT,
+		       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_ALAW);
 }
 
 /**
- * ispccdc_config_crop - Configures crop parameters for the ISP CCDC.
- * @left: Left offset of the crop area.
- * @top: Top offset of the crop area.
- * @height: Height of the crop area.
- * @width: Width of the crop area.
- *
- * The following restrictions are applied for the crop settings. If incoming
- * values do not follow these restrictions then we map the settings to the
- * closest acceptable crop value.
- * 1) Left offset is always odd. This can be avoided if we enable byte swap
- *    option for incoming data into CCDC.
- * 2) Top offset is always even.
- * 3) Crop height is always even.
- * 4) Crop width is always a multiple of 16 pixels
+ * ispccdc_enable_alaw - Enables the A-law compression.
+ * @enable: 0 - Disables A-law, 1 - Enables A-law
  **/
-void ispccdc_config_crop(struct isp_ccdc_device *isp_ccdc, u32 left, u32 top,
-			 u32 height, u32 width)
+static void ispccdc_enable_alaw(struct isp_ccdc_device *isp_ccdc, u8 enable)
 {
-	isp_ccdc->ccdcin_woffset = left + (left % 2);
-	isp_ccdc->ccdcin_hoffset = top + (top % 2);
-
-	isp_ccdc->crop_w = width - (width % 16);
-	isp_ccdc->crop_h = height + (height % 2);
+	struct device *dev = to_device(isp_ccdc);
 
-	DPRINTK_ISPCCDC("\n\tOffsets L %d T %d W %d H %d\n",
-			isp_ccdc->ccdcin_woffset,
-			isp_ccdc->ccdcin_hoffset,
-			isp_ccdc->crop_w,
-			isp_ccdc->crop_h);
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_ALAW,
+		       ~ISPCCDC_ALAW_CCDTBL,
+		       enable ? ISPCCDC_ALAW_CCDTBL : 0);
 }
 
 /**
- * ispccdc_config_datapath - Specifies the input and output modules for CCDC.
- * @input: Indicates the module that inputs the image to the CCDC.
- * @output: Indicates the module to which the CCDC outputs the image.
- *
- * Configures the default configuration for the CCDC to work with.
- *
- * The valid values for the input are CCDC_RAW (0), CCDC_YUV_SYNC (1),
- * CCDC_YUV_BT (2), and CCDC_OTHERS (3).
- *
- * The valid values for the output are CCDC_YUV_RSZ (0), CCDC_YUV_MEM_RSZ (1),
- * CCDC_OTHERS_VP (2), CCDC_OTHERS_MEM (3), CCDC_OTHERS_VP_MEM (4).
- *
- * Returns 0 if successful, or -EINVAL if wrong I/O combination or wrong input
- * or output values.
+ * ispccdc_config_imgattr - Configures the sensor image specific attributes.
+ * @colptn: Color pattern of the sensor.
  **/
-static int ispccdc_config_datapath(struct isp_ccdc_device *isp_ccdc,
-				   struct isp_pipeline *pipe)
+static void ispccdc_config_imgattr(struct isp_ccdc_device *isp_ccdc, u32 colptn)
 {
 	struct device *dev = to_device(isp_ccdc);
 
-	u32 syn_mode = 0;
-	struct ispccdc_vp vpcfg;
-	struct ispccdc_syncif syncif;
-	struct ispccdc_bclamp blkcfg;
-
-	u32 colptn = ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC0_SHIFT |
-		ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP0PLC1_SHIFT |
-		ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC2_SHIFT |
-		ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP0PLC3_SHIFT |
-		ISPCCDC_COLPTN_B_Mg << ISPCCDC_COLPTN_CP1PLC0_SHIFT |
-		ISPCCDC_COLPTN_Gb_G << ISPCCDC_COLPTN_CP1PLC1_SHIFT |
-		ISPCCDC_COLPTN_B_Mg << ISPCCDC_COLPTN_CP1PLC2_SHIFT |
-		ISPCCDC_COLPTN_Gb_G << ISPCCDC_COLPTN_CP1PLC3_SHIFT |
-		ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP2PLC0_SHIFT |
-		ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP2PLC1_SHIFT |
-		ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP2PLC2_SHIFT |
-		ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP2PLC3_SHIFT |
-		ISPCCDC_COLPTN_B_Mg << ISPCCDC_COLPTN_CP3PLC0_SHIFT |
-		ISPCCDC_COLPTN_Gb_G << ISPCCDC_COLPTN_CP3PLC1_SHIFT |
-		ISPCCDC_COLPTN_B_Mg << ISPCCDC_COLPTN_CP3PLC2_SHIFT |
-		ISPCCDC_COLPTN_Gb_G << ISPCCDC_COLPTN_CP3PLC3_SHIFT;
-
-	syn_mode = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE);
-
-	switch (pipe->ccdc_out) {
-	case CCDC_YUV_RSZ:
-		syn_mode |= ISPCCDC_SYN_MODE_SDR2RSZ;
-		syn_mode &= ~ISPCCDC_SYN_MODE_WEN;
-		break;
-
-	case CCDC_YUV_MEM_RSZ:
-		syn_mode |= ISPCCDC_SYN_MODE_SDR2RSZ;
-		isp_ccdc->wen = 1;
-		syn_mode |= ISPCCDC_SYN_MODE_WEN;
-		break;
-
-	case CCDC_OTHERS_VP:
-		syn_mode &= ~ISPCCDC_SYN_MODE_VP2SDR;
-		syn_mode &= ~ISPCCDC_SYN_MODE_SDR2RSZ;
-		syn_mode &= ~ISPCCDC_SYN_MODE_WEN;
-		vpcfg.bitshift_sel = BIT9_0;
-		vpcfg.freq_sel = PIXCLKBY2;
-		ispccdc_config_vp(isp_ccdc, vpcfg);
-		ispccdc_enable_vp(isp_ccdc, 1);
-		break;
-
-	case CCDC_OTHERS_MEM:
-		syn_mode &= ~ISPCCDC_SYN_MODE_VP2SDR;
-		syn_mode &= ~ISPCCDC_SYN_MODE_SDR2RSZ;
-		syn_mode |= ISPCCDC_SYN_MODE_WEN;
-		syn_mode &= ~ISPCCDC_SYN_MODE_EXWEN;
-		isp_reg_and(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,
-			    ~ISPCCDC_CFG_WENLOG);
-		vpcfg.bitshift_sel = BIT11_2;
-		vpcfg.freq_sel = PIXCLKBY2;
-		ispccdc_config_vp(isp_ccdc, vpcfg);
-		ispccdc_enable_vp(isp_ccdc, 0);
-		break;
-
-	case CCDC_OTHERS_VP_MEM:
-		syn_mode &= ~ISPCCDC_SYN_MODE_VP2SDR;
-		syn_mode &= ~ISPCCDC_SYN_MODE_SDR2RSZ;
-		syn_mode |= ISPCCDC_SYN_MODE_WEN;
-		syn_mode &= ~ISPCCDC_SYN_MODE_EXWEN;
-
-		isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,
-			       ~ISPCCDC_CFG_WENLOG, isp_ccdc->wenlog);
-		vpcfg.bitshift_sel = BIT9_0;
-		vpcfg.freq_sel = PIXCLKBY2;
-		ispccdc_config_vp(isp_ccdc, vpcfg);
-		ispccdc_enable_vp(isp_ccdc, 1);
-		break;
-	default:
-		DPRINTK_ISPCCDC("ISP_ERR: Wrong CCDC Output\n");
-		return -EINVAL;
-	};
-
-	isp_reg_writel(dev, syn_mode, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE);
-
-	switch (pipe->ccdc_in) {
-	case CCDC_RAW:
-		syncif.ccdc_mastermode = 0;
-		syncif.datapol = 0;
-		syncif.datsz = DAT10;
-		syncif.fldmode = 0;
-		syncif.fldout = 0;
-		syncif.fldpol = 0;
-		syncif.fldstat = 0;
-		syncif.hdpol = 0;
-		syncif.ipmod = RAW;
-		syncif.vdpol = 0;
-		ispccdc_config_sync_if(isp_ccdc, syncif);
-		ispccdc_config_imgattr(isp_ccdc, colptn);
-		blkcfg.oblen = 0;
-		blkcfg.dcsubval = 64;
-		ispccdc_config_black_clamp(isp_ccdc, blkcfg);
-		if (is_isplsc_activated()) {
-			ispccdc_config_lsc(isp_ccdc, &isp_ccdc->lsc_config);
-			ispccdc_load_lsc(isp_ccdc, isp_ccdc->lsc_gain_table_tmp,
-					 LSC_TABLE_INIT_SIZE);
-		}
-
-		break;
-	case CCDC_YUV_SYNC:
-		syncif.ccdc_mastermode = 0;
-		syncif.datapol = 0;
-		syncif.datsz = DAT8;
-		syncif.fldmode = 0;
-		syncif.fldout = 0;
-		syncif.fldpol = 0;
-		syncif.fldstat = 0;
-		syncif.hdpol = 0;
-		syncif.ipmod = YUV16;
-		syncif.vdpol = 1;
-		ispccdc_config_imgattr(isp_ccdc, 0);
-		ispccdc_config_sync_if(isp_ccdc, syncif);
-		blkcfg.oblen = 0;
-		blkcfg.dcsubval = 0;
-		ispccdc_config_black_clamp(isp_ccdc, blkcfg);
-		break;
-	case CCDC_YUV_BT:
-		break;
-	case CCDC_OTHERS:
-		break;
-	default:
-		DPRINTK_ISPCCDC("ISP_ERR: Wrong CCDC Input\n");
-		return -EINVAL;
-	}
-
-	ispccdc_print_status(isp_ccdc, pipe);
-	isp_print_status(dev);
-	return 0;
+	isp_reg_writel(dev, colptn, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_COLPTN);
 }
 
 /**
- * ispccdc_config_sync_if - Sets the sync i/f params between sensor and CCDC.
- * @syncif: Structure containing the sync parameters like field state, CCDC in
- *          master/slave mode, raw/yuv data, polarity of data, field, hs, vs
- *          signals.
+ * ispccdc_validate_config_lsc - Check that LSC configuration is valid.
+ * @lsc_cfg: the LSC configuration to check.
+ * @pipe: if not NULL, verify the table size against CCDC input size.
+ *
+ * Returns 0 if the LSC configuration is valid, or -EINVAL if invalid.
  **/
-void ispccdc_config_sync_if(struct isp_ccdc_device *isp_ccdc,
-			    struct ispccdc_syncif syncif)
+static int ispccdc_validate_config_lsc(struct isp_ccdc_device *isp_ccdc,
+				       struct ispccdc_lsc_config *lsc_cfg,
+				       struct isp_pipeline *pipe)
 {
 	struct device *dev = to_device(isp_ccdc);
-	u32 syn_mode = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				     ISPCCDC_SYN_MODE);
-
-	syn_mode |= ISPCCDC_SYN_MODE_VDHDEN;
-
-	if (syncif.fldstat)
-		syn_mode |= ISPCCDC_SYN_MODE_FLDSTAT;
-	else
-		syn_mode &= ~ISPCCDC_SYN_MODE_FLDSTAT;
+	unsigned int paxel_width, paxel_height;
+	unsigned int paxel_shift_x, paxel_shift_y;
+	unsigned int min_width, min_height, min_size;
+	unsigned int input_width, input_height;
 
-	syn_mode &= ISPCCDC_SYN_MODE_INPMOD_MASK;
-	isp_ccdc->syncif_ipmod = syncif.ipmod;
+	paxel_shift_x = lsc_cfg->gain_mode_m;
+	paxel_shift_y = lsc_cfg->gain_mode_n;
 
-	switch (syncif.ipmod) {
-	case RAW:
-		break;
-	case YUV16:
-		syn_mode |= ISPCCDC_SYN_MODE_INPMOD_YCBCR16;
-		break;
-	case YUV8:
-		syn_mode |= ISPCCDC_SYN_MODE_INPMOD_YCBCR8;
-		break;
-	};
+	if ((paxel_shift_x < 2) || (paxel_shift_x > 6) ||
+	    (paxel_shift_y < 2) || (paxel_shift_y > 6)) {
+		dev_dbg(dev, "CCDC: LSC: Invalid paxel size\n");
+		return -EINVAL;
+	}
 
-	syn_mode &= ISPCCDC_SYN_MODE_DATSIZ_MASK;
-	switch (syncif.datsz) {
-	case DAT8:
-		syn_mode |= ISPCCDC_SYN_MODE_DATSIZ_8;
-		break;
-	case DAT10:
-		syn_mode |= ISPCCDC_SYN_MODE_DATSIZ_10;
-		break;
-	case DAT11:
-		syn_mode |= ISPCCDC_SYN_MODE_DATSIZ_11;
-		break;
-	case DAT12:
-		syn_mode |= ISPCCDC_SYN_MODE_DATSIZ_12;
-		break;
-	};
+	if (lsc_cfg->offset & 3) {
+		dev_dbg(dev, "CCDC: LSC: Offset must be a multiple of 4\n");
+		return -EINVAL;
+	}
 
-	if (syncif.fldmode)
-		syn_mode |= ISPCCDC_SYN_MODE_FLDMODE;
-	else
-		syn_mode &= ~ISPCCDC_SYN_MODE_FLDMODE;
+	if ((lsc_cfg->initial_x & 1) || (lsc_cfg->initial_y & 1)) {
+		dev_dbg(dev, "CCDC: LSC: initial_x and y must be even\n");
+		return -EINVAL;
+	}
 
-	if (syncif.datapol)
-		syn_mode |= ISPCCDC_SYN_MODE_DATAPOL;
-	else
-		syn_mode &= ~ISPCCDC_SYN_MODE_DATAPOL;
+	if (!pipe)
+		return 0;
 
-	if (syncif.fldpol)
-		syn_mode |= ISPCCDC_SYN_MODE_FLDPOL;
-	else
-		syn_mode &= ~ISPCCDC_SYN_MODE_FLDPOL;
+	input_width = pipe->ccdc_in_w;
+	input_height = pipe->ccdc_in_h;
 
-	if (syncif.hdpol)
-		syn_mode |= ISPCCDC_SYN_MODE_HDPOL;
-	else
-		syn_mode &= ~ISPCCDC_SYN_MODE_HDPOL;
+	/* Calculate minimum bytesize for validation */
+	paxel_width = 1 << paxel_shift_x;
+	min_width = ((input_width + lsc_cfg->initial_x + paxel_width - 1)
+		     >> paxel_shift_x) + 1;
+
+	paxel_height = 1 << paxel_shift_y;
+	min_height = ((input_height + lsc_cfg->initial_y + paxel_height - 1)
+		     >> paxel_shift_y) + 1;
+
+	min_size = 4 * min_width * min_height;
+	if (min_size > lsc_cfg->size) {
+		dev_dbg(dev, "CCDC: LSC: too small table\n");
+		return -EINVAL;
+	}
+	if (lsc_cfg->offset < (min_width * 4)) {
+		dev_dbg(dev, "CCDC: LSC: Offset is too small\n");
+		return -EINVAL;
+	}
+	if ((lsc_cfg->size / lsc_cfg->offset) < min_height) {
+		dev_dbg(dev, "CCDC: LSC: Wrong size/offset combination\n");
+		return -EINVAL;
+	}
+	return 0;
+}
 
-	if (syncif.vdpol)
-		syn_mode |= ISPCCDC_SYN_MODE_VDPOL;
-	else
-		syn_mode &= ~ISPCCDC_SYN_MODE_VDPOL;
+/**
+ * ispccdc_program_lsc - Program Lens Shading Compensation table address.
+ **/
+static void ispccdc_program_lsc(struct isp_ccdc_device *isp_ccdc)
+{
+	isp_reg_writel(to_device(isp_ccdc), isp_ccdc->lsc_table_inuse,
+		       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_TABLE_BASE);
+}
 
-	if (syncif.ccdc_mastermode) {
-		syn_mode |= ISPCCDC_SYN_MODE_FLDOUT | ISPCCDC_SYN_MODE_VDHDOUT;
-		isp_reg_writel(dev,
-			       syncif.hs_width << ISPCCDC_HD_VD_WID_HDW_SHIFT
-			       | syncif.vs_width << ISPCCDC_HD_VD_WID_VDW_SHIFT,
-			       OMAP3_ISP_IOMEM_CCDC,
-			       ISPCCDC_HD_VD_WID);
+/**
+ * ispccdc_config_lsc - Configures the lens shading compensation module
+ **/
+static void ispccdc_config_lsc(struct isp_ccdc_device *isp_ccdc)
+{
+	struct device *dev = to_device(isp_ccdc);
+	struct ispccdc_lsc_config *lsc_cfg = &isp_ccdc->lsc_config;
+	int reg;
 
-		isp_reg_writel(dev,
-			       syncif.ppln << ISPCCDC_PIX_LINES_PPLN_SHIFT
-			       | syncif.hlprf << ISPCCDC_PIX_LINES_HLPRF_SHIFT,
-			       OMAP3_ISP_IOMEM_CCDC,
-			       ISPCCDC_PIX_LINES);
-	} else
-		syn_mode &= ~(ISPCCDC_SYN_MODE_FLDOUT |
-			      ISPCCDC_SYN_MODE_VDHDOUT);
+	isp_reg_writel(dev, lsc_cfg->offset, OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_LSC_TABLE_OFFSET);
 
-	isp_reg_writel(dev, syn_mode, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE);
+	reg = 0;
+	reg |= lsc_cfg->gain_mode_n << ISPCCDC_LSC_GAIN_MODE_N_SHIFT;
+	reg |= lsc_cfg->gain_mode_m << ISPCCDC_LSC_GAIN_MODE_M_SHIFT;
+	reg |= lsc_cfg->gain_format << ISPCCDC_LSC_GAIN_FORMAT_SHIFT;
+	isp_reg_writel(dev, reg, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_CONFIG);
 
-	if (!(syncif.bt_r656_en)) {
-		isp_reg_and(dev, OMAP3_ISP_IOMEM_CCDC,
-			    ISPCCDC_REC656IF, ~ISPCCDC_REC656IF_R656ON);
-	}
+	reg = 0;
+	reg &= ~ISPCCDC_LSC_INITIAL_X_MASK;
+	reg |= lsc_cfg->initial_x << ISPCCDC_LSC_INITIAL_X_SHIFT;
+	reg &= ~ISPCCDC_LSC_INITIAL_Y_MASK;
+	reg |= lsc_cfg->initial_y << ISPCCDC_LSC_INITIAL_Y_SHIFT;
+	isp_reg_writel(dev, reg, OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_LSC_INITIAL);
 }
 
 /**
- * ispccdc_config_black_clamp - Configures the clamp parameters in CCDC.
- * @bclamp: Structure containing the optical black average gain, optical black
- *          sample length, sample lines, and the start pixel position of the
- *          samples w.r.t the HS pulse.
- * Configures the clamp parameters in CCDC. Either if its being used the
- * optical black clamp, or the digital clamp. If its a digital clamp, then
- * assures to put a valid DC substraction level.
- *
- * Returns always 0 when completed.
+ * ispccdc_enable_lsc - Enables/Disables the Lens Shading Compensation module.
+ * @enable: 0 Disables LSC, 1 Enables LSC.
  **/
-int ispccdc_config_black_clamp(struct isp_ccdc_device *isp_ccdc,
-			       struct ispccdc_bclamp bclamp)
+static void ispccdc_enable_lsc(struct isp_ccdc_device *isp_ccdc, u8 enable)
 {
 	struct device *dev = to_device(isp_ccdc);
-	u32 bclamp_val = 0;
 
-	if (isp_ccdc->obclamp_en) {
-		bclamp_val |= bclamp.obgain << ISPCCDC_CLAMP_OBGAIN_SHIFT;
-		bclamp_val |= bclamp.oblen << ISPCCDC_CLAMP_OBSLEN_SHIFT;
-		bclamp_val |= bclamp.oblines << ISPCCDC_CLAMP_OBSLN_SHIFT;
-		bclamp_val |= bclamp.obstpixel << ISPCCDC_CLAMP_OBST_SHIFT;
-		isp_reg_writel(dev, bclamp_val,
-			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CLAMP);
+	if (enable) {
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_MAIN,
+			   ISP_CTRL, ISPCTRL_SBL_SHARED_RPORTB
+			   | ISPCTRL_SBL_RD_RAM_EN);
+
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC,
+			   ISPCCDC_LSC_CONFIG, ISPCCDC_LSC_ENABLE);
 	} else {
-		if (omap_rev() < OMAP3430_REV_ES2_0)
-			if (isp_ccdc->syncif_ipmod == YUV16 ||
-			    isp_ccdc->syncif_ipmod == YUV8 ||
-			    isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-					  ISPCCDC_REC656IF) &
-			    ISPCCDC_REC656IF_R656ON)
-				bclamp.dcsubval = 0;
-		isp_reg_writel(dev, bclamp.dcsubval,
-			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_DCSUB);
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_CCDC,
+			    ISPCCDC_LSC_CONFIG, ~ISPCCDC_LSC_ENABLE);
 	}
-	return 0;
 }
 
 /**
- * ispccdc_enable_black_clamp - Enables/Disables the optical black clamp.
- * @enable: 0 Disables optical black clamp, 1 Enables optical black clamp.
+ * ispccdc_setup_lsc - apply user LSC settings
+ * Consume the new LSC configuration and table set by user space application
+ * and program to CCDC.  This function must be called from process context
+ * before streamon when ISP is not yet running. This function does not yet
+ * actually enable LSC, that has to be done separately.
+ */
+static void ispccdc_setup_lsc(struct isp_ccdc_device *isp_ccdc,
+			      struct isp_pipeline *pipe)
+{
+	ispccdc_enable_lsc(isp_ccdc, 0);	/* Disable LSC */
+	if (pipe->ccdc_in == CCDC_RAW && isp_ccdc->lsc_request_enable) {
+		/* LSC is requested to be enabled, so configure it */
+		if (isp_ccdc->update_lsc_table) {
+			struct isp_device *isp = to_isp_device(isp_ccdc);
+			BUG_ON(isp_ccdc->lsc_table_new == PTR_FREE);
+			iommu_vfree(isp->iommu, isp_ccdc->lsc_table_inuse);
+			isp_ccdc->lsc_table_inuse = isp_ccdc->lsc_table_new;
+			isp_ccdc->lsc_table_new = PTR_FREE;
+			isp_ccdc->update_lsc_table = 0;
+		}
+		ispccdc_config_lsc(isp_ccdc);
+		ispccdc_program_lsc(isp_ccdc);
+	}
+	isp_ccdc->update_lsc_config = 0;
+}
+
+void ispccdc_lsc_error_handler(struct isp_ccdc_device *isp_ccdc)
+{
+	ispccdc_enable_lsc(isp_ccdc, 0);
+}
+
+/**
+ * ispccdc_config_crop - Configures crop parameters for the ISP CCDC.
+ * @left: Left offset of the crop area.
+ * @top: Top offset of the crop area.
+ * @height: Height of the crop area.
+ * @width: Width of the crop area.
  *
- * Enables or disables the optical black clamp. When disabled, the digital
- * clamp operates.
+ * The following restrictions are applied for the crop settings. If incoming
+ * values do not follow these restrictions then we map the settings to the
+ * closest acceptable crop value.
+ * 1) Left offset is always odd. This can be avoided if we enable byte swap
+ *    option for incoming data into CCDC.
+ * 2) Top offset is always even.
+ * 3) Crop height is always even.
+ * 4) Crop width is always a multiple of 16 pixels
  **/
-void ispccdc_enable_black_clamp(struct isp_ccdc_device *isp_ccdc, u8 enable)
+static void ispccdc_config_crop(struct isp_ccdc_device *isp_ccdc,
+				u32 left, u32 top, u32 height, u32 width)
 {
-	struct device *dev = to_device(isp_ccdc);
+	isp_ccdc->ccdcin_woffset = left + (left % 2);
+	isp_ccdc->ccdcin_hoffset = top + (top % 2);
 
-	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CLAMP,
-		       ~ISPCCDC_CLAMP_CLAMPEN,
-		       enable ? ISPCCDC_CLAMP_CLAMPEN : 0);
-	isp_ccdc->obclamp_en = enable;
+	isp_ccdc->crop_w = width - (width % 16);
+	isp_ccdc->crop_h = height + (height % 2);
+
+	DPRINTK_ISPCCDC("\n\tOffsets L %d T %d W %d H %d\n",
+			isp_ccdc->ccdcin_woffset,
+			isp_ccdc->ccdcin_hoffset,
+			isp_ccdc->crop_w,
+			isp_ccdc->crop_h);
 }
 
 /**
- * ispccdc_config_fpc - Configures the Faulty Pixel Correction parameters.
- * @fpc: Structure containing the number of faulty pixels corrected in the
- *       frame, address of the FPC table.
+ * ispccdc_config_outlineoffset - Configures the output line offset
+ * @offset: Must be twice the Output width and aligned on 32 byte boundary
+ * @oddeven: Specifies the odd/even line pattern to be chosen to store the
+ *           output.
+ * @numlines: Set the value 0-3 for +1-4lines, 4-7 for -1-4lines.
  *
- * Returns 0 if successful, or -EINVAL if FPC Address is not on the 64 byte
+ * - Configures the output line offset when stored in memory
+ * - Sets the odd/even line pattern to store the output
+ *    (EVENEVEN (1), ODDEVEN (2), EVENODD (3), ODDODD (4))
+ * - Configures the number of even and odd line fields in case of rearranging
+ * the lines.
+ *
+ * Returns 0 if successful, or -EINVAL if the offset is not in 32 byte
  * boundary.
  **/
-int ispccdc_config_fpc(struct isp_ccdc_device *isp_ccdc, struct ispccdc_fpc fpc)
+static int ispccdc_config_outlineoffset(struct isp_ccdc_device *isp_ccdc,
+					u32 offset, u8 oddeven, u8 numlines)
 {
 	struct device *dev = to_device(isp_ccdc);
-	u32 fpc_val = 0;
-
-	fpc_val = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC);
 
-	if ((fpc.fpcaddr & 0xFFFFFFC0) == fpc.fpcaddr) {
-		isp_reg_writel(dev, fpc_val & (~ISPCCDC_FPC_FPCEN),
-			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC);
-		isp_reg_writel(dev, fpc.fpcaddr,
-			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC_ADDR);
+	if ((offset & ISP_32B_BOUNDARY_OFFSET) == offset) {
+		isp_reg_writel(dev, (offset & 0xFFFF),
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_HSIZE_OFF);
 	} else {
-		DPRINTK_ISPCCDC("FPC Address should be on 64byte boundary\n");
+		DPRINTK_ISPCCDC("ISP_ERR : Offset should be in 32 byte"
+				" boundary\n");
 		return -EINVAL;
 	}
-	isp_reg_writel(dev, fpc_val | (fpc.fpnum << ISPCCDC_FPC_FPNUM_SHIFT),
-		       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC);
-	return 0;
-}
 
-/**
- * ispccdc_enable_fpc - Enables the Faulty Pixel Correction.
- * @enable: 0 Disables FPC, 1 Enables FPC.
- **/
-void ispccdc_enable_fpc(struct isp_ccdc_device *isp_ccdc, u8 enable)
-{
-	struct device *dev = to_device(isp_ccdc);
+	isp_reg_and(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
+		    ~ISPCCDC_SDOFST_FINV);
 
-	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC,
-		       ~ISPCCDC_FPC_FPCEN, enable ? ISPCCDC_FPC_FPCEN : 0);
+	isp_reg_and(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
+		    ~ISPCCDC_SDOFST_FOFST_4L);
+
+	switch (oddeven) {
+	case EVENEVEN:
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
+			   (numlines & 0x7) << ISPCCDC_SDOFST_LOFST0_SHIFT);
+		break;
+	case ODDEVEN:
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
+			   (numlines & 0x7) << ISPCCDC_SDOFST_LOFST1_SHIFT);
+		break;
+	case EVENODD:
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
+			   (numlines & 0x7) << ISPCCDC_SDOFST_LOFST2_SHIFT);
+		break;
+	case ODDODD:
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
+			   (numlines & 0x7) << ISPCCDC_SDOFST_LOFST3_SHIFT);
+		break;
+	default:
+		break;
+	}
+	return 0;
 }
 
 /**
- * ispccdc_config_black_comp - Configures Black Level Compensation parameters.
- * @blcomp: Structure containing the black level compensation value for RGrGbB
- *          pixels. in 2's complement.
+ * ispccdc_set_outaddr - Sets the memory address where the output will be saved
+ * @addr: 32-bit memory address aligned on 32 byte boundary.
+ *
+ * Sets the memory address where the output will be saved.
+ *
+ * Returns 0 if successful, or -EINVAL if the address is not in the 32 byte
+ * boundary.
  **/
-void ispccdc_config_black_comp(struct isp_ccdc_device *isp_ccdc,
-			       struct ispccdc_blcomp blcomp)
+int ispccdc_set_outaddr(struct isp_ccdc_device *isp_ccdc, u32 addr)
 {
 	struct device *dev = to_device(isp_ccdc);
-	u32 blcomp_val = 0;
 
-	blcomp_val |= blcomp.b_mg << ISPCCDC_BLKCMP_B_MG_SHIFT;
-	blcomp_val |= blcomp.gb_g << ISPCCDC_BLKCMP_GB_G_SHIFT;
-	blcomp_val |= blcomp.gr_cy << ISPCCDC_BLKCMP_GR_CY_SHIFT;
-	blcomp_val |= blcomp.r_ye << ISPCCDC_BLKCMP_R_YE_SHIFT;
+	if ((addr & ISP_32B_BOUNDARY_BUF) == addr) {
+		isp_reg_writel(dev, addr, OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_SDR_ADDR);
+		return 0;
+	} else {
+		DPRINTK_ISPCCDC("ISP_ERR : Address should be in 32 byte"
+				" boundary\n");
+		return -EINVAL;
+	}
 
-	isp_reg_writel(dev, blcomp_val, OMAP3_ISP_IOMEM_CCDC,
-		       ISPCCDC_BLKCMP);
 }
 
 /**
- * ispccdc_config_vp - Configures the Video Port Configuration parameters.
- * @vpcfg: Structure containing the Video Port input frequency, and the 10 bit
- *         format.
+ * ispccdc_config_sync_if - Sets the sync i/f params between sensor and CCDC.
+ * @syncif: Structure containing the sync parameters like field state, CCDC in
+ *          master/slave mode, raw/yuv data, polarity of data, field, hs, vs
+ *          signals.
  **/
-void ispccdc_config_vp(struct isp_ccdc_device *isp_ccdc,
-		       struct ispccdc_vp vpcfg)
+static void ispccdc_config_sync_if(struct isp_ccdc_device *isp_ccdc,
+				   struct ispccdc_syncif syncif)
 {
 	struct device *dev = to_device(isp_ccdc);
-	u32 fmtcfg_vp = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_FMTCFG);
+	u32 syn_mode = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
+				     ISPCCDC_SYN_MODE);
 
-	fmtcfg_vp &= ISPCCDC_FMTCFG_VPIN_MASK & ISPCCDC_FMTCFG_VPIF_FRQ_MASK;
+	syn_mode |= ISPCCDC_SYN_MODE_VDHDEN;
 
-	switch (vpcfg.bitshift_sel) {
-	case BIT9_0:
-		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIN_9_0;
-		break;
-	case BIT10_1:
-		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIN_10_1;
+	if (syncif.fldstat)
+		syn_mode |= ISPCCDC_SYN_MODE_FLDSTAT;
+	else
+		syn_mode &= ~ISPCCDC_SYN_MODE_FLDSTAT;
+
+	syn_mode &= ISPCCDC_SYN_MODE_INPMOD_MASK;
+	isp_ccdc->syncif_ipmod = syncif.ipmod;
+
+	switch (syncif.ipmod) {
+	case RAW:
 		break;
-	case BIT11_2:
-		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIN_11_2;
+	case YUV16:
+		syn_mode |= ISPCCDC_SYN_MODE_INPMOD_YCBCR16;
 		break;
-	case BIT12_3:
-		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIN_12_3;
+	case YUV8:
+		syn_mode |= ISPCCDC_SYN_MODE_INPMOD_YCBCR8;
 		break;
 	};
-	switch (vpcfg.freq_sel) {
-	case PIXCLKBY2:
-		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIF_FRQ_BY2;
-		break;
-	case PIXCLKBY3_5:
-		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIF_FRQ_BY3;
+
+	syn_mode &= ISPCCDC_SYN_MODE_DATSIZ_MASK;
+	switch (syncif.datsz) {
+	case DAT8:
+		syn_mode |= ISPCCDC_SYN_MODE_DATSIZ_8;
 		break;
-	case PIXCLKBY4_5:
-		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIF_FRQ_BY4;
+	case DAT10:
+		syn_mode |= ISPCCDC_SYN_MODE_DATSIZ_10;
 		break;
-	case PIXCLKBY5_5:
-		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIF_FRQ_BY5;
+	case DAT11:
+		syn_mode |= ISPCCDC_SYN_MODE_DATSIZ_11;
 		break;
-	case PIXCLKBY6_5:
-		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIF_FRQ_BY6;
+	case DAT12:
+		syn_mode |= ISPCCDC_SYN_MODE_DATSIZ_12;
 		break;
 	};
-	isp_reg_writel(dev, fmtcfg_vp, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG);
-}
 
-/**
- * ispccdc_enable_vp - Enables the Video Port.
- * @enable: 0 Disables VP, 1 Enables VP
- **/
-void ispccdc_enable_vp(struct isp_ccdc_device *isp_ccdc, u8 enable)
-{
-	struct device *dev = to_device(isp_ccdc);
+	if (syncif.fldmode)
+		syn_mode |= ISPCCDC_SYN_MODE_FLDMODE;
+	else
+		syn_mode &= ~ISPCCDC_SYN_MODE_FLDMODE;
 
-	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG,
-		       ~ISPCCDC_FMTCFG_VPEN,
-		       enable ? ISPCCDC_FMTCFG_VPEN : 0);
-}
+	if (syncif.datapol)
+		syn_mode |= ISPCCDC_SYN_MODE_DATAPOL;
+	else
+		syn_mode &= ~ISPCCDC_SYN_MODE_DATAPOL;
 
-/**
- * ispccdc_config_reformatter - Configures the Reformatter.
- * @refmt: Structure containing the memory address to format and the bit fields
- *         for the reformatter registers.
- *
- * Configures the Reformatter register values if line alternating is disabled.
- * Else, just enabling line alternating is enough.
- **/
-void ispccdc_config_reformatter(struct isp_ccdc_device *isp_ccdc,
-				struct ispccdc_refmt refmt)
-{
-	struct device *dev = to_device(isp_ccdc);
-	u32 fmtcfg_val = 0;
-
-	fmtcfg_val = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG);
-
-	if (refmt.lnalt)
-		fmtcfg_val |= ISPCCDC_FMTCFG_LNALT;
-	else {
-		fmtcfg_val &= ~ISPCCDC_FMTCFG_LNALT;
-		fmtcfg_val &= 0xFFFFF003;
-		fmtcfg_val |= refmt.lnum << ISPCCDC_FMTCFG_LNUM_SHIFT;
-		fmtcfg_val |= refmt.plen_even <<
-			ISPCCDC_FMTCFG_PLEN_EVEN_SHIFT;
-		fmtcfg_val |= refmt.plen_odd << ISPCCDC_FMTCFG_PLEN_ODD_SHIFT;
-
-		isp_reg_writel(dev, refmt.prgeven0,
-			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PRGEVEN0);
-		isp_reg_writel(dev, refmt.prgeven1,
-			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PRGEVEN1);
-		isp_reg_writel(dev, refmt.prgodd0,
-			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PRGODD0);
-		isp_reg_writel(dev, refmt.prgodd1,
-			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PRGODD1);
-		isp_reg_writel(dev, refmt.fmtaddr0,
-			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR0);
-		isp_reg_writel(dev, refmt.fmtaddr1,
-			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR1);
-		isp_reg_writel(dev, refmt.fmtaddr2,
-			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR2);
-		isp_reg_writel(dev, refmt.fmtaddr3,
-			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR3);
-		isp_reg_writel(dev, refmt.fmtaddr4,
-			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR4);
-		isp_reg_writel(dev, refmt.fmtaddr5,
-			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR5);
-		isp_reg_writel(dev, refmt.fmtaddr6,
-			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR6);
-		isp_reg_writel(dev, refmt.fmtaddr7,
-			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR7);
-	}
-	isp_reg_writel(dev, fmtcfg_val, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG);
-}
+	if (syncif.fldpol)
+		syn_mode |= ISPCCDC_SYN_MODE_FLDPOL;
+	else
+		syn_mode &= ~ISPCCDC_SYN_MODE_FLDPOL;
 
-/**
- * ispccdc_enable_reformatter - Enables the Reformatter.
- * @enable: 0 Disables Reformatter, 1- Enables Data Reformatter
- **/
-void ispccdc_enable_reformatter(struct isp_ccdc_device *isp_ccdc, u8 enable)
-{
-	struct device *dev = to_device(isp_ccdc);
+	if (syncif.hdpol)
+		syn_mode |= ISPCCDC_SYN_MODE_HDPOL;
+	else
+		syn_mode &= ~ISPCCDC_SYN_MODE_HDPOL;
 
-	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG,
-		       ~ISPCCDC_FMTCFG_FMTEN,
-		       enable ? ISPCCDC_FMTCFG_FMTEN : 0);
-	isp_ccdc->refmt_en = enable;
-}
+	if (syncif.vdpol)
+		syn_mode |= ISPCCDC_SYN_MODE_VDPOL;
+	else
+		syn_mode &= ~ISPCCDC_SYN_MODE_VDPOL;
 
-/**
- * ispccdc_config_culling - Configures the culling parameters.
- * @cull: Structure containing the vertical culling pattern, and horizontal
- *        culling pattern for odd and even lines.
- **/
-void ispccdc_config_culling(struct isp_ccdc_device *isp_ccdc,
-			    struct ispccdc_culling cull)
-{
-	struct device *dev = to_device(isp_ccdc);
+	if (syncif.ccdc_mastermode) {
+		syn_mode |= ISPCCDC_SYN_MODE_FLDOUT | ISPCCDC_SYN_MODE_VDHDOUT;
+		isp_reg_writel(dev,
+			       syncif.hs_width << ISPCCDC_HD_VD_WID_HDW_SHIFT
+			       | syncif.vs_width << ISPCCDC_HD_VD_WID_VDW_SHIFT,
+			       OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_HD_VD_WID);
 
-	u32 culling_val = 0;
+		isp_reg_writel(dev,
+			       syncif.ppln << ISPCCDC_PIX_LINES_PPLN_SHIFT
+			       | syncif.hlprf << ISPCCDC_PIX_LINES_HLPRF_SHIFT,
+			       OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_PIX_LINES);
+	} else
+		syn_mode &= ~(ISPCCDC_SYN_MODE_FLDOUT |
+			      ISPCCDC_SYN_MODE_VDHDOUT);
 
-	culling_val |= cull.v_pattern << ISPCCDC_CULLING_CULV_SHIFT;
-	culling_val |= cull.h_even << ISPCCDC_CULLING_CULHEVN_SHIFT;
-	culling_val |= cull.h_odd << ISPCCDC_CULLING_CULHODD_SHIFT;
+	isp_reg_writel(dev, syn_mode, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE);
 
-	isp_reg_writel(dev, culling_val, OMAP3_ISP_IOMEM_CCDC,
-		       ISPCCDC_CULLING);
+	if (!(syncif.bt_r656_en)) {
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_CCDC,
+			    ISPCCDC_REC656IF, ~ISPCCDC_REC656IF_R656ON);
+	}
 }
 
 /**
- * ispccdc_enable_lpf - Enables the Low-Pass Filter (LPF).
- * @enable: 0 Disables LPF, 1 Enables LPF
- **/
-void ispccdc_enable_lpf(struct isp_ccdc_device *isp_ccdc, u8 enable)
+ * Set the value to be used for CCDC_CFG.WENLOG.
+ *  w - Value of wenlog.
+ */
+void ispccdc_set_wenlog(struct isp_ccdc_device *isp_ccdc, u32 wenlog)
 {
-	struct device *dev = to_device(isp_ccdc);
-
-	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE,
-		       ~ISPCCDC_SYN_MODE_LPF,
-		       enable ? ISPCCDC_SYN_MODE_LPF : 0);
+	isp_ccdc->wenlog = wenlog;
 }
 
 /**
- * ispccdc_config_alaw - Configures the input width for A-law.
- * @ipwidth: Input width for A-law
+ * ispccdc_config_datapath - Specifies the input and output modules for CCDC.
+ * @input: Indicates the module that inputs the image to the CCDC.
+ * @output: Indicates the module to which the CCDC outputs the image.
+ *
+ * Configures the default configuration for the CCDC to work with.
+ *
+ * The valid values for the input are CCDC_RAW (0), CCDC_YUV_SYNC (1),
+ * CCDC_YUV_BT (2), and CCDC_OTHERS (3).
+ *
+ * The valid values for the output are CCDC_YUV_RSZ (0), CCDC_YUV_MEM_RSZ (1),
+ * CCDC_OTHERS_VP (2), CCDC_OTHERS_MEM (3), CCDC_OTHERS_VP_MEM (4).
+ *
+ * Returns 0 if successful, or -EINVAL if wrong I/O combination or wrong input
+ * or output values.
  **/
-void ispccdc_config_alaw(struct isp_ccdc_device *isp_ccdc,
-			 enum alaw_ipwidth ipwidth)
+static int ispccdc_config_datapath(struct isp_ccdc_device *isp_ccdc,
+				   struct isp_pipeline *pipe)
 {
 	struct device *dev = to_device(isp_ccdc);
 
-	isp_reg_writel(dev, ipwidth << ISPCCDC_ALAW_GWDI_SHIFT,
-		       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_ALAW);
-}
+	u32 syn_mode = 0;
+	struct ispccdc_vp vpcfg;
+	struct ispccdc_syncif syncif;
+	struct ispccdc_bclamp blkcfg;
 
-/**
- * ispccdc_enable_alaw - Enables the A-law compression.
- * @enable: 0 - Disables A-law, 1 - Enables A-law
- **/
-void ispccdc_enable_alaw(struct isp_ccdc_device *isp_ccdc, u8 enable)
-{
-	struct device *dev = to_device(isp_ccdc);
+	u32 colptn = ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC0_SHIFT |
+		ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP0PLC1_SHIFT |
+		ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC2_SHIFT |
+		ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP0PLC3_SHIFT |
+		ISPCCDC_COLPTN_B_Mg << ISPCCDC_COLPTN_CP1PLC0_SHIFT |
+		ISPCCDC_COLPTN_Gb_G << ISPCCDC_COLPTN_CP1PLC1_SHIFT |
+		ISPCCDC_COLPTN_B_Mg << ISPCCDC_COLPTN_CP1PLC2_SHIFT |
+		ISPCCDC_COLPTN_Gb_G << ISPCCDC_COLPTN_CP1PLC3_SHIFT |
+		ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP2PLC0_SHIFT |
+		ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP2PLC1_SHIFT |
+		ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP2PLC2_SHIFT |
+		ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP2PLC3_SHIFT |
+		ISPCCDC_COLPTN_B_Mg << ISPCCDC_COLPTN_CP3PLC0_SHIFT |
+		ISPCCDC_COLPTN_Gb_G << ISPCCDC_COLPTN_CP3PLC1_SHIFT |
+		ISPCCDC_COLPTN_B_Mg << ISPCCDC_COLPTN_CP3PLC2_SHIFT |
+		ISPCCDC_COLPTN_Gb_G << ISPCCDC_COLPTN_CP3PLC3_SHIFT;
+
+	syn_mode = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE);
+
+	switch (pipe->ccdc_out) {
+	case CCDC_YUV_RSZ:
+		syn_mode |= ISPCCDC_SYN_MODE_SDR2RSZ;
+		syn_mode &= ~ISPCCDC_SYN_MODE_WEN;
+		break;
+
+	case CCDC_YUV_MEM_RSZ:
+		syn_mode |= ISPCCDC_SYN_MODE_SDR2RSZ;
+		isp_ccdc->wen = 1;
+		syn_mode |= ISPCCDC_SYN_MODE_WEN;
+		break;
+
+	case CCDC_OTHERS_VP:
+		syn_mode &= ~ISPCCDC_SYN_MODE_VP2SDR;
+		syn_mode &= ~ISPCCDC_SYN_MODE_SDR2RSZ;
+		syn_mode &= ~ISPCCDC_SYN_MODE_WEN;
+		vpcfg.bitshift_sel = BIT9_0;
+		vpcfg.freq_sel = PIXCLKBY2;
+		ispccdc_config_vp(isp_ccdc, vpcfg);
+		ispccdc_enable_vp(isp_ccdc, 1);
+		break;
+
+	case CCDC_OTHERS_MEM:
+		syn_mode &= ~ISPCCDC_SYN_MODE_VP2SDR;
+		syn_mode &= ~ISPCCDC_SYN_MODE_SDR2RSZ;
+		syn_mode |= ISPCCDC_SYN_MODE_WEN;
+		syn_mode &= ~ISPCCDC_SYN_MODE_EXWEN;
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,
+			    ~ISPCCDC_CFG_WENLOG);
+		vpcfg.bitshift_sel = BIT11_2;
+		vpcfg.freq_sel = PIXCLKBY2;
+		ispccdc_config_vp(isp_ccdc, vpcfg);
+		ispccdc_enable_vp(isp_ccdc, 0);
+		break;
 
-	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_ALAW,
-		       ~ISPCCDC_ALAW_CCDTBL,
-		       enable ? ISPCCDC_ALAW_CCDTBL : 0);
-}
+	case CCDC_OTHERS_VP_MEM:
+		syn_mode &= ~ISPCCDC_SYN_MODE_VP2SDR;
+		syn_mode &= ~ISPCCDC_SYN_MODE_SDR2RSZ;
+		syn_mode |= ISPCCDC_SYN_MODE_WEN;
+		syn_mode &= ~ISPCCDC_SYN_MODE_EXWEN;
 
-/**
- * ispccdc_config_imgattr - Configures the sensor image specific attributes.
- * @colptn: Color pattern of the sensor.
- **/
-void ispccdc_config_imgattr(struct isp_ccdc_device *isp_ccdc, u32 colptn)
-{
-	struct device *dev = to_device(isp_ccdc);
+		isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,
+			       ~ISPCCDC_CFG_WENLOG, isp_ccdc->wenlog);
+		vpcfg.bitshift_sel = BIT9_0;
+		vpcfg.freq_sel = PIXCLKBY2;
+		ispccdc_config_vp(isp_ccdc, vpcfg);
+		ispccdc_enable_vp(isp_ccdc, 1);
+		break;
+	default:
+		DPRINTK_ISPCCDC("ISP_ERR: Wrong CCDC Output\n");
+		return -EINVAL;
+	};
 
-	isp_reg_writel(dev, colptn, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_COLPTN);
-}
+	isp_reg_writel(dev, syn_mode, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE);
 
-void ispccdc_config_shadow_registers(struct isp_ccdc_device *isp_ccdc)
-{
-	if (isp_ccdc->lsc_enable) {
-		ispccdc_enable_lsc(isp_ccdc, 1);
-		isp_ccdc->lsc_enable = 0;
+	switch (pipe->ccdc_in) {
+	case CCDC_RAW:
+		syncif.ccdc_mastermode = 0;
+		syncif.datapol = 0;
+		syncif.datsz = DAT10;
+		syncif.fldmode = 0;
+		syncif.fldout = 0;
+		syncif.fldpol = 0;
+		syncif.fldstat = 0;
+		syncif.hdpol = 0;
+		syncif.ipmod = RAW;
+		syncif.vdpol = 0;
+		ispccdc_config_sync_if(isp_ccdc, syncif);
+		ispccdc_config_imgattr(isp_ccdc, colptn);
+		blkcfg.oblen = 0;
+		blkcfg.dcsubval = 64;
+		ispccdc_config_black_clamp(isp_ccdc, blkcfg);
+		break;
+	case CCDC_YUV_SYNC:
+		syncif.ccdc_mastermode = 0;
+		syncif.datapol = 0;
+		syncif.datsz = DAT8;
+		syncif.fldmode = 0;
+		syncif.fldout = 0;
+		syncif.fldpol = 0;
+		syncif.fldstat = 0;
+		syncif.hdpol = 0;
+		syncif.ipmod = YUV16;
+		syncif.vdpol = 1;
+		ispccdc_config_imgattr(isp_ccdc, 0);
+		ispccdc_config_sync_if(isp_ccdc, syncif);
+		blkcfg.oblen = 0;
+		blkcfg.dcsubval = 0;
+		ispccdc_config_black_clamp(isp_ccdc, blkcfg);
+		break;
+	case CCDC_YUV_BT:
+		break;
+	case CCDC_OTHERS:
+		break;
+	default:
+		DPRINTK_ISPCCDC("ISP_ERR: Wrong CCDC Input\n");
+		return -EINVAL;
 	}
+
+	ispccdc_print_status(isp_ccdc, pipe);
+	isp_print_status(dev);
+	return 0;
 }
 
 /**
@@ -1199,156 +1097,339 @@ int ispccdc_s_pipeline(struct isp_ccdc_d
 			       OMAP3_ISP_IOMEM_CCDC,
 			       ISPCCDC_VP_OUT);
 
-	if (is_isplsc_activated()) {
-		if (pipe->ccdc_in == CCDC_RAW) {
-			ispccdc_config_lsc(isp_ccdc, &isp_ccdc->lsc_config);
-			ispccdc_load_lsc(isp_ccdc, isp_ccdc->lsc_gain_table,
-					 isp_ccdc->lsc_config.size);
-		}
-	}
+	ispccdc_setup_lsc(isp_ccdc, pipe);
 
 	return 0;
 }
 
 /**
- * ispccdc_config_outlineoffset - Configures the output line offset
- * @offset: Must be twice the Output width and aligned on 32 byte boundary
- * @oddeven: Specifies the odd/even line pattern to be chosen to store the
- *           output.
- * @numlines: Set the value 0-3 for +1-4lines, 4-7 for -1-4lines.
- *
- * - Configures the output line offset when stored in memory
- * - Sets the odd/even line pattern to store the output
- *    (EVENEVEN (1), ODDEVEN (2), EVENODD (3), ODDODD (4))
- * - Configures the number of even and odd line fields in case of rearranging
- * the lines.
+ * ispccdc_enable - Enables the CCDC module.
+ * @enable: 0 Disables CCDC, 1 Enables CCDC
  *
- * Returns 0 if successful, or -EINVAL if the offset is not in 32 byte
- * boundary.
+ * Client should configure all the sub modules in CCDC before this.
  **/
-int ispccdc_config_outlineoffset(struct isp_ccdc_device *isp_ccdc, u32 offset,
-				 u8 oddeven, u8 numlines)
+void ispccdc_enable(struct isp_ccdc_device *isp_ccdc, u8 enable)
+{
+	struct isp_device *isp = to_isp_device(isp_ccdc);
+	int enable_lsc;
+
+	enable_lsc = enable &&
+		     isp->pipeline.ccdc_in == CCDC_RAW &&
+		     isp_ccdc->lsc_request_enable &&
+		     ispccdc_validate_config_lsc(isp_ccdc,
+				&isp_ccdc->lsc_config, &isp->pipeline) == 0;
+	ispccdc_enable_lsc(isp_ccdc, enable_lsc);
+	isp_reg_and_or(isp->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PCR,
+		       ~ISPCCDC_PCR_EN, enable ? ISPCCDC_PCR_EN : 0);
+}
+
+/*
+ * Returns zero if the CCDC is idle and the image has been written to
+ * memory, too.
+ */
+int ispccdc_sbl_busy(void *_isp_ccdc)
 {
+	struct isp_ccdc_device *isp_ccdc = _isp_ccdc;
 	struct device *dev = to_device(isp_ccdc);
 
-	if ((offset & ISP_32B_BOUNDARY_OFFSET) == offset) {
-		isp_reg_writel(dev, (offset & 0xFFFF),
-			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_HSIZE_OFF);
-	} else {
-		DPRINTK_ISPCCDC("ISP_ERR : Offset should be in 32 byte"
-				" boundary\n");
+	return ispccdc_busy(isp_ccdc)
+		| (isp_reg_readl(dev, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_0) &
+		   ISPSBL_CCDC_WR_0_DATA_READY)
+		| (isp_reg_readl(dev, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_1) &
+		   ISPSBL_CCDC_WR_0_DATA_READY)
+		| (isp_reg_readl(dev, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_2) &
+		   ISPSBL_CCDC_WR_0_DATA_READY)
+		| (isp_reg_readl(dev, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_3) &
+		   ISPSBL_CCDC_WR_0_DATA_READY);
+}
+
+/**
+ * ispccdc_busy - Gets busy state of the CCDC.
+ **/
+int ispccdc_busy(struct isp_ccdc_device *isp_ccdc)
+{
+	struct device *dev = to_device(isp_ccdc);
+
+	return isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PCR) &
+		ISPCCDC_PCR_BUSY;
+}
+
+void ispccdc_config_shadow_registers(struct isp_ccdc_device *isp_ccdc)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&isp_ccdc->lock, flags);
+	if (isp_ccdc->shadow_update)
+		goto out;
+
+#if 0	/* FIXME: Do not support on-the-fly-LSC configuration yet */
+	if (isp_ccdc->update_lsc_config) {
+		ispccdc_config_lsc(isp_ccdc);
+		ispccdc_enable_lsc(isp_ccdc, isp_ccdc->lsc_request_enable);
+		isp_ccdc->update_lsc_config = 0;
+	}
+
+	if (isp_ccdc->update_lsc_table) {
+		u32 n = isp_ccdc->lsc_table_new;
+		/* Swap tables--no need to vfree in interrupt context */
+		isp_ccdc->lsc_table_new = isp_ccdc->lsc_table_inuse;
+		isp_ccdc->lsc_table_inuse = n;
+		ispccdc_program_lsc(isp_ccdc);
+		isp_ccdc->update_lsc_table = 0;
+	}
+#endif
+
+out:
+	spin_unlock_irqrestore(&isp_ccdc->lock, flags);
+}
+
+/**
+ * ispccdc_config - Sets CCDC configuration from userspace
+ * @userspace_add: Structure containing CCDC configuration sent from userspace.
+ *
+ * Returns 0 if successful, -EINVAL if the pointer to the configuration
+ * structure is null, or the copy_from_user function fails to copy user space
+ * memory to kernel space memory.
+ **/
+int ispccdc_config(struct isp_ccdc_device *isp_ccdc,
+			     void *userspace_add)
+{
+	struct isp_device *isp = to_isp_device(isp_ccdc);
+	struct ispccdc_bclamp bclamp_t;
+	struct ispccdc_blcomp blcomp_t;
+	struct ispccdc_fpc fpc_t;
+	struct ispccdc_culling cull_t;
+	struct ispccdc_update_config *ccdc_struct;
+	unsigned long flags;
+	int ret = 0;
+
+	if (userspace_add == NULL)
 		return -EINVAL;
+
+	ccdc_struct = userspace_add;
+
+	spin_lock_irqsave(&isp_ccdc->lock, flags);
+	isp_ccdc->shadow_update = 1;
+	spin_unlock_irqrestore(&isp_ccdc->lock, flags);
+
+	if (ISP_ABS_CCDC_ALAW & ccdc_struct->flag) {
+		if (ISP_ABS_CCDC_ALAW & ccdc_struct->update)
+			ispccdc_config_alaw(isp_ccdc, ccdc_struct->alawip);
+		ispccdc_enable_alaw(isp_ccdc, 1);
+	} else if (ISP_ABS_CCDC_ALAW & ccdc_struct->update)
+		ispccdc_enable_alaw(isp_ccdc, 0);
+
+	if (ISP_ABS_CCDC_LPF & ccdc_struct->flag)
+		ispccdc_enable_lpf(isp_ccdc, 1);
+	else
+		ispccdc_enable_lpf(isp_ccdc, 0);
+
+	if (ISP_ABS_CCDC_BLCLAMP & ccdc_struct->flag) {
+		if (ISP_ABS_CCDC_BLCLAMP & ccdc_struct->update) {
+			if (copy_from_user(&bclamp_t, (struct ispccdc_bclamp *)
+					   ccdc_struct->bclamp,
+					   sizeof(struct ispccdc_bclamp))) {
+				ret = -EFAULT;
+				goto out;
+			}
+
+			ispccdc_enable_black_clamp(isp_ccdc, 1);
+			ispccdc_config_black_clamp(isp_ccdc, bclamp_t);
+		} else
+			ispccdc_enable_black_clamp(isp_ccdc, 1);
+	} else {
+		if (ISP_ABS_CCDC_BLCLAMP & ccdc_struct->update) {
+			if (copy_from_user(&bclamp_t, (struct ispccdc_bclamp *)
+					   ccdc_struct->bclamp,
+					   sizeof(struct ispccdc_bclamp))) {
+				ret = -EFAULT;
+				goto out;
+			}
+
+			ispccdc_enable_black_clamp(isp_ccdc, 0);
+			ispccdc_config_black_clamp(isp_ccdc, bclamp_t);
+		}
+	}
+
+	if (ISP_ABS_CCDC_BCOMP & ccdc_struct->update) {
+		if (copy_from_user(&blcomp_t, (struct ispccdc_blcomp *)
+				   ccdc_struct->blcomp,
+				   sizeof(blcomp_t))) {
+				ret = -EFAULT;
+				goto out;
+			}
+
+		ispccdc_config_black_comp(isp_ccdc, blcomp_t);
+	}
+
+	if (ISP_ABS_CCDC_FPC & ccdc_struct->flag) {
+		if (ISP_ABS_CCDC_FPC & ccdc_struct->update) {
+			if (copy_from_user(&fpc_t, (struct ispccdc_fpc *)
+					   ccdc_struct->fpc,
+					   sizeof(fpc_t))) {
+				ret = -EFAULT;
+				goto out;
+			}
+			isp_ccdc->fpc_table_add = kmalloc(64 + fpc_t.fpnum * 4,
+						GFP_KERNEL | GFP_DMA);
+			if (!isp_ccdc->fpc_table_add) {
+				ret = -ENOMEM;
+				goto out;
+			}
+			while (((unsigned long)isp_ccdc->fpc_table_add
+				& 0xFFFFFFC0)
+			       != (unsigned long)isp_ccdc->fpc_table_add)
+				isp_ccdc->fpc_table_add++;
+
+			isp_ccdc->fpc_table_add_m = iommu_kmap(
+				isp->iommu,
+				0,
+				virt_to_phys(isp_ccdc->fpc_table_add),
+				fpc_t.fpnum * 4,
+				IOMMU_FLAG);
+			/* FIXME: Correct unwinding */
+			BUG_ON(IS_ERR_VALUE(isp_ccdc->fpc_table_add_m));
+
+			if (copy_from_user(isp_ccdc->fpc_table_add,
+					   (u32 *)fpc_t.fpcaddr,
+					   fpc_t.fpnum * 4)) {
+				ret = -EFAULT;
+				goto out;
+			}
+
+			fpc_t.fpcaddr = isp_ccdc->fpc_table_add_m;
+			ispccdc_config_fpc(isp_ccdc, fpc_t);
+		}
+		ispccdc_enable_fpc(isp_ccdc, 1);
+	} else if (ISP_ABS_CCDC_FPC & ccdc_struct->update)
+		ispccdc_enable_fpc(isp_ccdc, 0);
+
+	if (ISP_ABS_CCDC_CULL & ccdc_struct->update) {
+		if (copy_from_user(&cull_t, (struct ispccdc_culling *)
+				   ccdc_struct->cull,
+				   sizeof(cull_t))) {
+			ret = -EFAULT;
+			goto out;
+		}
+		ispccdc_config_culling(isp_ccdc, cull_t);
+	}
+
+	if (ISP_ABS_CCDC_CONFIG_LSC & ccdc_struct->update) {
+		if (ISP_ABS_CCDC_CONFIG_LSC & ccdc_struct->flag) {
+			struct ispccdc_lsc_config cfg;
+			if (copy_from_user(&cfg, ccdc_struct->lsc_cfg,
+					   sizeof(cfg))) {
+				ret = -EFAULT;
+				goto out;
+			}
+			ret = ispccdc_validate_config_lsc(isp_ccdc, &cfg,
+						isp->running == ISP_RUNNING ?
+						&isp->pipeline : NULL);
+			if (ret)
+				goto out;
+			memcpy(&isp_ccdc->lsc_config, &cfg,
+			       sizeof(isp_ccdc->lsc_config));
+			isp_ccdc->lsc_request_enable = 1;
+		} else {
+			isp_ccdc->lsc_request_enable = 0;
+		}
+		isp_ccdc->update_lsc_config = 1;
 	}
 
-	isp_reg_and(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
-		    ~ISPCCDC_SDOFST_FINV);
+	if (ISP_ABS_TBL_LSC & ccdc_struct->update) {
+		void *n;
+		if (isp_ccdc->lsc_table_new != PTR_FREE)
+			iommu_vfree(isp->iommu, isp_ccdc->lsc_table_new);
+		isp_ccdc->lsc_table_new = iommu_vmalloc(isp->iommu, 0,
+					isp_ccdc->lsc_config.size, IOMMU_FLAG);
+		if (IS_ERR_VALUE(isp_ccdc->lsc_table_new)) {
+			/* Disable LSC if table can not be allocated */
+			isp_ccdc->lsc_table_new = PTR_FREE;
+			isp_ccdc->lsc_request_enable = 0;
+			isp_ccdc->update_lsc_config = 1;
+			ret = -ENOMEM;
+			goto out;
+		}
+		n = da_to_va(isp->iommu, isp_ccdc->lsc_table_new);
+		if (copy_from_user(n, ccdc_struct->lsc,
+				   isp_ccdc->lsc_config.size)) {
+			ret = -EFAULT;
+			goto out;
+		}
+		isp_ccdc->update_lsc_table = 1;
+	}
 
-	isp_reg_and(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
-		    ~ISPCCDC_SDOFST_FOFST_4L);
+	if (isp->running == ISP_STOPPED &&
+	    (isp_ccdc->update_lsc_table || isp_ccdc->update_lsc_config))
+		ispccdc_setup_lsc(isp_ccdc, &isp->pipeline);
 
-	switch (oddeven) {
-	case EVENEVEN:
-		isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
-			   (numlines & 0x7) << ISPCCDC_SDOFST_LOFST0_SHIFT);
-		break;
-	case ODDEVEN:
-		isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
-			   (numlines & 0x7) << ISPCCDC_SDOFST_LOFST1_SHIFT);
-		break;
-	case EVENODD:
-		isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
-			   (numlines & 0x7) << ISPCCDC_SDOFST_LOFST2_SHIFT);
-		break;
-	case ODDODD:
-		isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
-			   (numlines & 0x7) << ISPCCDC_SDOFST_LOFST3_SHIFT);
-		break;
-	default:
-		break;
-	}
-	return 0;
+	if (ISP_ABS_CCDC_COLPTN & ccdc_struct->update)
+		ispccdc_config_imgattr(isp_ccdc, ccdc_struct->colptn);
+
+out:
+	if (ret == -EFAULT)
+		dev_err(to_device(isp_ccdc),
+			"ccdc: user provided bad configuration data address");
+
+	if (ret == -ENOMEM)
+		dev_err(to_device(isp_ccdc),
+			"ccdc: can not allocate memory");
+
+	isp_ccdc->shadow_update = 0;
+	return ret;
 }
 
 /**
- * ispccdc_set_outaddr - Sets the memory address where the output will be saved
- * @addr: 32-bit memory address aligned on 32 byte boundary.
+ * ispccdc_request - Reserves the CCDC module.
  *
- * Sets the memory address where the output will be saved.
+ * Reserves the CCDC module and assures that is used only once at a time.
  *
- * Returns 0 if successful, or -EINVAL if the address is not in the 32 byte
- * boundary.
+ * Returns 0 if successful, or -EBUSY if CCDC module is busy.
  **/
-int ispccdc_set_outaddr(struct isp_ccdc_device *isp_ccdc, u32 addr)
+int ispccdc_request(struct isp_ccdc_device *isp_ccdc)
 {
 	struct device *dev = to_device(isp_ccdc);
 
-	if ((addr & ISP_32B_BOUNDARY_BUF) == addr) {
-		isp_reg_writel(dev, addr, OMAP3_ISP_IOMEM_CCDC,
-			       ISPCCDC_SDR_ADDR);
-		return 0;
-	} else {
-		DPRINTK_ISPCCDC("ISP_ERR : Address should be in 32 byte"
-				" boundary\n");
-		return -EINVAL;
+	mutex_lock(&isp_ccdc->mutexlock);
+	if (isp_ccdc->ccdc_inuse) {
+		mutex_unlock(&isp_ccdc->mutexlock);
+		DPRINTK_ISPCCDC("ISP_ERR : CCDC Module Busy\n");
+		return -EBUSY;
 	}
 
+	isp_ccdc->ccdc_inuse = 1;
+	mutex_unlock(&isp_ccdc->mutexlock);
+	isp_reg_or(dev, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,
+		   ISPCTRL_CCDC_RAM_EN | ISPCTRL_CCDC_CLK_EN |
+		   ISPCTRL_SBL_WR1_RAM_EN);
+	isp_reg_or(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,
+		   ISPCCDC_CFG_VDLC);
+	return 0;
 }
 
 /**
- * ispccdc_enable - Enables the CCDC module.
- * @enable: 0 Disables CCDC, 1 Enables CCDC
+ * ispccdc_free - Frees the CCDC module.
  *
- * Client should configure all the sub modules in CCDC before this.
+ * Frees the CCDC module so it can be used by another process.
+ *
+ * Returns 0 if successful, or -EINVAL if module has been already freed.
  **/
-void ispccdc_enable(struct isp_ccdc_device *isp_ccdc, u8 enable)
+int ispccdc_free(struct isp_ccdc_device *isp_ccdc)
 {
-	struct isp_device *isp = to_isp_device(isp_ccdc);
-
-	if (enable) {
-		if (isp_ccdc->lsc_enable
-		    && isp->pipeline.ccdc_in == CCDC_RAW)
-			ispccdc_enable_lsc(isp_ccdc, 1);
-
-	} else {
-		int lsc_enable = isp_ccdc->lsc_state;
-
-		ispccdc_enable_lsc(isp_ccdc, 0);
-		isp_ccdc->lsc_enable = lsc_enable;
+	mutex_lock(&isp_ccdc->mutexlock);
+	if (!isp_ccdc->ccdc_inuse) {
+		mutex_unlock(&isp_ccdc->mutexlock);
+		DPRINTK_ISPCCDC("ISP_ERR: CCDC Module already freed\n");
+		return -EINVAL;
 	}
 
-	isp_reg_and_or(isp->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PCR,
-		       ~ISPCCDC_PCR_EN, enable ? ISPCCDC_PCR_EN : 0);
-}
-
-/*
- * Returns zero if the CCDC is idle and the image has been written to
- * memory, too.
- */
-int ispccdc_sbl_busy(void *_isp_ccdc)
-{
-	struct isp_ccdc_device *isp_ccdc = _isp_ccdc;
-	struct device *dev = to_device(isp_ccdc);
-
-	return ispccdc_busy(isp_ccdc)
-		| (isp_reg_readl(dev, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_0) &
-		   ISPSBL_CCDC_WR_0_DATA_READY)
-		| (isp_reg_readl(dev, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_1) &
-		   ISPSBL_CCDC_WR_0_DATA_READY)
-		| (isp_reg_readl(dev, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_2) &
-		   ISPSBL_CCDC_WR_0_DATA_READY)
-		| (isp_reg_readl(dev, OMAP3_ISP_IOMEM_SBL, ISPSBL_CCDC_WR_3) &
-		   ISPSBL_CCDC_WR_0_DATA_READY);
-}
-
-/**
- * ispccdc_busy - Gets busy state of the CCDC.
- **/
-int ispccdc_busy(struct isp_ccdc_device *isp_ccdc)
-{
-	struct device *dev = to_device(isp_ccdc);
-
-	return isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PCR) &
-		ISPCCDC_PCR_BUSY;
+	isp_ccdc->ccdc_inuse = 0;
+	mutex_unlock(&isp_ccdc->mutexlock);
+	isp_reg_and(to_device(isp_ccdc), OMAP3_ISP_IOMEM_MAIN,
+		    ISP_CTRL, ~(ISPCTRL_CCDC_CLK_EN |
+				ISPCTRL_CCDC_RAM_EN |
+				ISPCTRL_SBL_WR1_RAM_EN));
+	return 0;
 }
 
 /**
@@ -1370,129 +1451,6 @@ void ispccdc_restore_context(struct devi
 }
 
 /**
- * ispccdc_print_status - Prints the values of the CCDC Module registers
- *
- * Also prints other debug information stored in the CCDC module.
- **/
-void ispccdc_print_status(struct isp_ccdc_device *isp_ccdc,
-			  struct isp_pipeline *pipe)
-{
-	if (!is_ispccdc_debug_enabled())
-		return;
-
-	DPRINTK_ISPCCDC("Module in use =%d\n", isp_ccdc->ccdc_inuse);
-	DPRINTK_ISPCCDC("Accepted CCDC Input (width = %d,Height = %d)\n",
-			isp_ccdc->ccdcin_w,
-			isp_ccdc->ccdcin_h);
-	DPRINTK_ISPCCDC("Accepted CCDC Output (width = %d,Height = %d)\n",
-			isp_ccdc->ccdcout_w,
-			isp_ccdc->ccdcout_h);
-	DPRINTK_ISPCCDC("###CCDC PCR=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_PCR));
-	DPRINTK_ISPCCDC("ISP_CTRL =0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
-				      ISP_CTRL));
-	switch (pipe->ccdc_in) {
-	case CCDC_RAW:
-		DPRINTK_ISPCCDC("ccdc input format is CCDC_RAW\n");
-		break;
-	case CCDC_YUV_SYNC:
-		DPRINTK_ISPCCDC("ccdc input format is CCDC_YUV_SYNC\n");
-		break;
-	case CCDC_YUV_BT:
-		DPRINTK_ISPCCDC("ccdc input format is CCDC_YUV_BT\n");
-		break;
-	default:
-		break;
-	}
-
-	switch (pipe->ccdc_out) {
-	case CCDC_OTHERS_VP:
-		DPRINTK_ISPCCDC("ccdc output format is CCDC_OTHERS_VP\n");
-		break;
-	case CCDC_OTHERS_MEM:
-		DPRINTK_ISPCCDC("ccdc output format is CCDC_OTHERS_MEM\n");
-		break;
-	case CCDC_YUV_RSZ:
-		DPRINTK_ISPCCDC("ccdc output format is CCDC_YUV_RSZ\n");
-		break;
-	default:
-		break;
-	}
-
-	DPRINTK_ISPCCDC("###ISP_CTRL in ccdc =0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
-				      ISP_CTRL));
-	DPRINTK_ISPCCDC("###ISP_IRQ0ENABLE in ccdc =0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
-				      ISP_IRQ0ENABLE));
-	DPRINTK_ISPCCDC("###ISP_IRQ0STATUS in ccdc =0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
-				      ISP_IRQ0STATUS));
-	DPRINTK_ISPCCDC("###CCDC SYN_MODE=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_SYN_MODE));
-	DPRINTK_ISPCCDC("###CCDC HORZ_INFO=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_HORZ_INFO));
-	DPRINTK_ISPCCDC("###CCDC VERT_START=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_VERT_START));
-	DPRINTK_ISPCCDC("###CCDC VERT_LINES=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_VERT_LINES));
-	DPRINTK_ISPCCDC("###CCDC CULLING=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_CULLING));
-	DPRINTK_ISPCCDC("###CCDC HSIZE_OFF=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_HSIZE_OFF));
-	DPRINTK_ISPCCDC("###CCDC SDOFST=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_SDOFST));
-	DPRINTK_ISPCCDC("###CCDC SDR_ADDR=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_SDR_ADDR));
-	DPRINTK_ISPCCDC("###CCDC CLAMP=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_CLAMP));
-	DPRINTK_ISPCCDC("###CCDC COLPTN=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_COLPTN));
-	DPRINTK_ISPCCDC("###CCDC CFG=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_CFG));
-	DPRINTK_ISPCCDC("###CCDC VP_OUT=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_VP_OUT));
-	DPRINTK_ISPCCDC("###CCDC_SDR_ADDR= 0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_SDR_ADDR));
-	DPRINTK_ISPCCDC("###CCDC FMTCFG=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_FMTCFG));
-	DPRINTK_ISPCCDC("###CCDC FMT_HORZ=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_FMT_HORZ));
-	DPRINTK_ISPCCDC("###CCDC FMT_VERT=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_FMT_VERT));
-	DPRINTK_ISPCCDC("###CCDC LSC_CONFIG=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_LSC_CONFIG));
-	DPRINTK_ISPCCDC("###CCDC LSC_INIT=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_LSC_INITIAL));
-	DPRINTK_ISPCCDC("###CCDC LSC_TABLE BASE=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_LSC_TABLE_BASE));
-	DPRINTK_ISPCCDC("###CCDC LSC TABLE OFFSET=0x%x\n",
-			isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC,
-				      ISPCCDC_LSC_TABLE_OFFSET));
-}
-
-/**
  * isp_ccdc_init - CCDC module initialization.
  *
  * Always returns 0
@@ -1501,24 +1459,34 @@ int __init isp_ccdc_init(struct device *
 {
 	struct isp_device *isp = dev_get_drvdata(dev);
 	struct isp_ccdc_device *isp_ccdc = &isp->isp_ccdc;
+	void *p;
 
 	isp_ccdc->ccdc_inuse = 0;
 	ispccdc_config_crop(isp_ccdc, 0, 0, 0, 0);
 	mutex_init(&isp_ccdc->mutexlock);
 
-	if (is_isplsc_activated()) {
-		isp_ccdc->lsc_gain_table_tmp = kmalloc(LSC_TABLE_INIT_SIZE,
-						       GFP_KERNEL | GFP_DMA);
-		memset(isp_ccdc->lsc_gain_table_tmp, 0x40, LSC_TABLE_INIT_SIZE);
-		isp_ccdc->lsc_config.initial_x = 0;
-		isp_ccdc->lsc_config.initial_y = 0;
-		isp_ccdc->lsc_config.gain_mode_n = 0x6;
-		isp_ccdc->lsc_config.gain_mode_m = 0x6;
-		isp_ccdc->lsc_config.gain_format = 0x4;
-		isp_ccdc->lsc_config.offset = 0x60;
-		isp_ccdc->lsc_config.size = LSC_TABLE_INIT_SIZE;
-		isp_ccdc->lsc_enable = 1;
-	}
+	isp_ccdc->update_lsc_config = 0;
+	isp_ccdc->lsc_request_enable = 1;
+
+	isp_ccdc->lsc_config.initial_x = 0;
+	isp_ccdc->lsc_config.initial_y = 0;
+	isp_ccdc->lsc_config.gain_mode_n = 0x6;
+	isp_ccdc->lsc_config.gain_mode_m = 0x6;
+	isp_ccdc->lsc_config.gain_format = 0x4;
+	isp_ccdc->lsc_config.offset = 0x60;
+	isp_ccdc->lsc_config.size = LSC_TABLE_INIT_SIZE;
+
+	isp_ccdc->update_lsc_table = 0;
+	isp_ccdc->lsc_table_new = PTR_FREE;
+	isp_ccdc->lsc_table_inuse = iommu_vmalloc(isp->iommu, 0,
+					LSC_TABLE_INIT_SIZE, IOMMU_FLAG);
+	if (IS_ERR_VALUE(isp_ccdc->lsc_table_inuse))
+		return -ENOMEM;
+	p = da_to_va(isp->iommu, isp_ccdc->lsc_table_inuse);
+	memset(p, 0x40, LSC_TABLE_INIT_SIZE);
+
+	isp_ccdc->shadow_update = 0;
+	spin_lock_init(&isp_ccdc->lock);
 
 	return 0;
 }
@@ -1531,10 +1499,9 @@ void isp_ccdc_cleanup(struct device *dev
 	struct isp_device *isp = dev_get_drvdata(dev);
 	struct isp_ccdc_device *isp_ccdc = &isp->isp_ccdc;
 
-	if (is_isplsc_activated()) {
-		ispccdc_free_lsc(isp_ccdc);
-		kfree(isp_ccdc->lsc_gain_table_tmp);
-	}
+	iommu_vfree(isp->iommu, isp_ccdc->lsc_table_inuse);
+	if (isp_ccdc->lsc_table_new != PTR_FREE)
+		iommu_vfree(isp->iommu, isp_ccdc->lsc_table_new);
 
 	if (isp_ccdc->fpc_table_add_m != 0) {
 		iommu_kunmap(isp->iommu, isp_ccdc->fpc_table_add_m);
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/ispccdc.h kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/ispccdc.h
--- kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/ispccdc.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/ispccdc.h	2011-09-04 11:37:54.000000000 +0200
@@ -24,8 +24,6 @@
 
 #include <mach/isp_user.h>
 
-#define is_isplsc_activated()		1
-
 /* Enumeration constants for CCDC input output format */
 enum ccdc_input {
 	CCDC_RAW,
@@ -152,6 +150,14 @@ struct ispccdc_refmt {
  * @syncif_ipmod: Image
  * @obclamp_en: Data input format.
  * @mutexlock: Mutex used to get access to the CCDC.
+ * @update_lsc_config: Set when user changes lsc_config
+ * @lsc_request_enable: Whether LSC is requested to be enabled
+ * @lsc_config: LSC config set by user
+ * @update_lsc_table: Set when user provides a new LSC table to lsc_table_new
+ * @lsc_table_new: LSC table set by user, ISP address
+ * @lsc_table_inuse: LSC table currently in use, ISP address
+ * @shadow_update: non-zero when user is updating CCDC configuration
+ * @lock: serializes shadow_update with interrupt handler
  */
 struct isp_ccdc_device {
 	u8 ccdc_inuse;
@@ -166,102 +172,39 @@ struct isp_ccdc_device {
 	u8 ccdcslave;
 	u8 syncif_ipmod;
 	u8 obclamp_en;
-	u8 lsc_enable;
-	u8 lsc_initialized;
-	int lsc_state;
 	struct mutex mutexlock; /* For checking/modifying ccdc_inuse */
 	u32 wenlog;
-	u8 *lsc_gain_table_tmp;
-	unsigned long lsc_ispmmu_addr;
-	u8 *lsc_gain_table;
-	struct ispccdc_lsc_config lsc_config;
 	unsigned long fpc_table_add_m;
 	u32 *fpc_table_add;
-};
-
-int ispccdc_request(struct isp_ccdc_device *isp_ccdc);
-
-int ispccdc_free(struct isp_ccdc_device *isp_ccdc);
-
-void ispccdc_config_crop(struct isp_ccdc_device *isp_ccdc, u32 left, u32 top,
-			 u32 height, u32 width);
-
-void ispccdc_config_sync_if(struct isp_ccdc_device *isp_ccdc,
-			    struct ispccdc_syncif syncif);
-
-int ispccdc_config_black_clamp(struct isp_ccdc_device *isp_ccdc,
-			       struct ispccdc_bclamp bclamp);
-
-void ispccdc_enable_black_clamp(struct isp_ccdc_device *isp_ccdc, u8 enable);
-
-int ispccdc_config_fpc(struct isp_ccdc_device *isp_ccdc,
-		       struct ispccdc_fpc fpc);
-
-void ispccdc_enable_fpc(struct isp_ccdc_device *isp_ccdc, u8 enable);
 
-void ispccdc_config_black_comp(struct isp_ccdc_device *isp_ccdc,
-			       struct ispccdc_blcomp blcomp);
-
-void ispccdc_config_vp(struct isp_ccdc_device *isp_ccdc, struct ispccdc_vp vp);
-
-void ispccdc_enable_vp(struct isp_ccdc_device *isp_ccdc, u8 enable);
-
-void ispccdc_config_reformatter(struct isp_ccdc_device *isp_ccdc,
-				struct ispccdc_refmt refmt);
-
-void ispccdc_enable_reformatter(struct isp_ccdc_device *isp_ccdc, u8 enable);
-
-void ispccdc_config_culling(struct isp_ccdc_device *isp_ccdc,
-			    struct ispccdc_culling culling);
-
-void ispccdc_enable_lpf(struct isp_ccdc_device *isp_ccdc, u8 enable);
-
-void ispccdc_config_alaw(struct isp_ccdc_device *isp_ccdc,
-			 enum alaw_ipwidth ipwidth);
-
-void ispccdc_enable_alaw(struct isp_ccdc_device *isp_ccdc, u8 enable);
-
-int ispccdc_load_lsc(struct isp_ccdc_device *isp_ccdc, u8 *table_addr,
-		     u32 table_size);
-
-void ispccdc_config_lsc(struct isp_ccdc_device *isp_ccdc,
-			struct ispccdc_lsc_config *lsc_cfg);
+	/* LSC related fields */
+	u8 update_lsc_config;
+	u8 lsc_request_enable;
+	struct ispccdc_lsc_config lsc_config;
+	u8 update_lsc_table;
+	u32 lsc_table_new;
+	u32 lsc_table_inuse;
 
-void ispccdc_enable_lsc(struct isp_ccdc_device *isp_ccdc, u8 enable);
+	int shadow_update;
+	spinlock_t lock;
+};
 
 void ispccdc_lsc_error_handler(struct isp_ccdc_device *isp_ccdc);
-
-void ispccdc_config_imgattr(struct isp_ccdc_device *isp_ccdc, u32 colptn);
-
-void ispccdc_config_shadow_registers(struct isp_ccdc_device *isp_ccdc);
-
+int ispccdc_set_outaddr(struct isp_ccdc_device *isp_ccdc, u32 addr);
+void ispccdc_set_wenlog(struct isp_ccdc_device *isp_ccdc, u32 wenlog);
 int ispccdc_try_pipeline(struct isp_ccdc_device *isp_ccdc,
 			 struct isp_pipeline *pipe);
-
 int ispccdc_s_pipeline(struct isp_ccdc_device *isp_ccdc,
 		       struct isp_pipeline *pipe);
-
-int ispccdc_config_outlineoffset(struct isp_ccdc_device *isp_ccdc, u32 offset,
-				 u8 oddeven, u8 numlines);
-
-int ispccdc_set_outaddr(struct isp_ccdc_device *isp_ccdc, u32 addr);
-
 void ispccdc_enable(struct isp_ccdc_device *isp_ccdc, u8 enable);
-
 int ispccdc_sbl_busy(void *_isp_ccdc);
-
 int ispccdc_busy(struct isp_ccdc_device *isp_ccdc);
-
+void ispccdc_config_shadow_registers(struct isp_ccdc_device *isp_ccdc);
+int ispccdc_config(struct isp_ccdc_device *isp_ccdc,
+			     void *userspace_add);
+int ispccdc_request(struct isp_ccdc_device *isp_ccdc);
+int ispccdc_free(struct isp_ccdc_device *isp_ccdc);
 void ispccdc_save_context(struct device *dev);
-
 void ispccdc_restore_context(struct device *dev);
 
-void ispccdc_print_status(struct isp_ccdc_device *isp_ccdc,
-			  struct isp_pipeline *pipe);
-
-int omap34xx_isp_ccdc_config(struct isp_ccdc_device *isp_ccdc,
-			     void *userspace_add);
-
-void ispccdc_set_wenlog(struct isp_ccdc_device *isp_ccdc, u32 wenlog);
-
 #endif		/* OMAP_ISP_CCDC_H */
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isp.h kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isp.h
--- kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isp.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isp.h	2011-09-04 11:37:54.000000000 +0200
@@ -249,6 +249,8 @@ struct isp_bufs {
 	int done;
 	/* Wait for this many hs_vs before anything else. */
 	int wait_hs_vs;
+	/* Ignore statistic's interrupts until first good hs_vs. */
+	int wait_stats;
 };
 
 /**
@@ -361,7 +363,7 @@ struct isp_device {
 	struct iommu *iommu;
 };
 
-void omap34xx_isp_hist_dma_done(struct device *dev);
+void isp_hist_dma_done(struct device *dev);
 
 void isp_flush(struct device *dev);
 
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isphist.c kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isphist.c
--- kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isphist.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isphist.c	2011-09-04 11:37:54.000000000 +0200
@@ -229,6 +229,7 @@ void isp_hist_config_registers(struct is
 	isp_hist_dma_config(isp_hist);
 
 	isp_hist->update = 0;
+	isp_hist->stat.config_counter++;
 	spin_unlock_irqrestore(&isp_hist->lock, irqflags);
 
 	isp_hist_print_status(isp_hist);
@@ -251,7 +252,7 @@ static void isp_hist_dma_cb(int lch, u16
 		isp_reg_and(dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,
 			    ~ISPHIST_CNT_CLR_EN);
 		if (!ret)
-			omap34xx_isp_hist_dma_done(dev);
+			isp_hist_dma_done(dev);
 	}
 	isp_hist->waiting_dma = 0;
 }
@@ -568,8 +569,8 @@ static void isp_hist_update_params(struc
  *
  * Returns 0 on success configuration.
  **/
-int omap34xx_isp_hist_config(struct isp_hist_device *isp_hist,
-			     struct isp_hist_config *histcfg)
+int isp_hist_config(struct isp_hist_device *isp_hist,
+		    struct isp_hist_config *histcfg)
 {
 	struct device *dev = to_device(isp_hist);
 	unsigned long irqflags;
@@ -632,15 +633,15 @@ int omap34xx_isp_hist_config(struct isp_
 }
 
 /**
- * omap34xx_isp_hist_request_statistics - Request statistics in Histogram.
+ * isp_hist_request_statistics - Request statistics in Histogram.
  * @histdata: Pointer to data structure.
  *
  * This API allows the user to request for histogram statistics.
  *
  * Returns 0 on successful request.
  **/
-int omap34xx_isp_hist_request_statistics(struct isp_hist_device *isp_hist,
-					 struct isp_hist_data *histdata)
+int isp_hist_request_statistics(struct isp_hist_device *isp_hist,
+				struct isp_hist_data *histdata)
 {
 	struct device *dev = to_device(isp_hist);
 	struct ispstat_buffer *buf;
@@ -718,17 +719,17 @@ void isp_hist_cleanup(struct device *dev
 }
 
 /**
- * isphist_save_context - Saves the values of the histogram module registers.
+ * isp_hist_save_context - Saves the values of the histogram module registers.
  **/
-void isphist_save_context(struct device *dev)
+void isp_hist_save_context(struct device *dev)
 {
 	isp_save_context(dev, isphist_reg_list);
 }
 
 /**
- * isphist_restore_context - Restores the values of the histogram module regs.
+ * isp_hist_restore_context - Restores the values of the histogram module regs.
  **/
-void isphist_restore_context(struct device *dev)
+void isp_hist_restore_context(struct device *dev)
 {
 	isp_restore_context(dev, isphist_reg_list);
 }
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isphist.h kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isphist.h
--- kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isphist.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isphist.h	2011-09-04 11:37:54.000000000 +0200
@@ -149,11 +149,11 @@ void isp_hist_mark_invalid_buf(struct is
 void isp_hist_config_registers(struct isp_hist_device *isp_hist);
 void isp_hist_suspend(struct isp_hist_device *isp_hist);
 void isp_hist_resume(struct isp_hist_device *isp_hist);
-void isphist_save_context(struct device *dev);
-void isphist_restore_context(struct device *dev);
-int omap34xx_isp_hist_config(struct isp_hist_device *isp_hist,
-			     struct isp_hist_config *histcfg);
-int omap34xx_isp_hist_request_statistics(struct isp_hist_device *isp_hist,
-					 struct isp_hist_data *histdata);
+void isp_hist_save_context(struct device *dev);
+void isp_hist_restore_context(struct device *dev);
+int isp_hist_config(struct isp_hist_device *isp_hist,
+		    struct isp_hist_config *histcfg);
+int isp_hist_request_statistics(struct isp_hist_device *isp_hist,
+				struct isp_hist_data *histdata);
 
 #endif				/* OMAP_ISP_HIST */
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isph3a.c kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isph3a.c
--- kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isph3a.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isph3a.c	2011-09-04 11:37:54.000000000 +0200
@@ -194,6 +194,7 @@ void isph3a_aewb_config_registers(struct
 
 	ispstat_bufs_set_size(&isp_h3a->stat, isp_h3a->buf_size);
 	isp_h3a->update = 0;
+	isp_h3a->stat.config_counter++;
 
 	spin_unlock_irqrestore(isp_h3a->lock, irqflags);
 }
@@ -404,14 +405,14 @@ static void isph3a_aewb_set_params(struc
 }
 
 /**
- * omap34xx_isph3a_aewb_config - Configure AEWB regs, enable/disable H3A engine.
+ * isph3a_aewb_config - Configure AEWB regs, enable/disable H3A engine.
  * @aewbcfg: Pointer to AEWB config structure.
  *
  * Returns 0 if successful, -EINVAL if aewbcfg pointer is NULL, -ENOMEM if
  * was unable to allocate memory for the buffer, of other errors if H3A
  * callback is not set or the parameters for AEWB are invalid.
  **/
-int omap34xx_isph3a_aewb_config(struct isp_h3a_device *isp_h3a,
+int isph3a_aewb_config(struct isp_h3a_device *isp_h3a,
 				struct isph3a_aewb_config *aewbcfg)
 {
 	struct device *dev = to_device(isp_h3a);
@@ -454,7 +455,7 @@ int omap34xx_isph3a_aewb_config(struct i
 
 	return 0;
 }
-EXPORT_SYMBOL(omap34xx_isph3a_aewb_config);
+EXPORT_SYMBOL(isph3a_aewb_config);
 
 /**
  * isph3a_aewb_request_statistics - REquest statistics and update gains in AEWB
@@ -467,8 +468,8 @@ EXPORT_SYMBOL(omap34xx_isph3a_aewb_confi
  * Returns 0 if successful, -EINVAL when H3A engine is not enabled, or other
  * errors when setting gains.
  **/
-int omap34xx_isph3a_aewb_request_statistics(struct isp_h3a_device *isp_h3a,
-					    struct isph3a_aewb_data *aewbdata)
+int isph3a_aewb_request_statistics(struct isp_h3a_device *isp_h3a,
+				   struct isph3a_aewb_data *aewbdata)
 {
 	struct device *dev = to_device(isp_h3a);
 	unsigned long irqflags;
@@ -517,7 +518,7 @@ int omap34xx_isph3a_aewb_request_statist
 
 	return ret;
 }
-EXPORT_SYMBOL(omap34xx_isph3a_aewb_request_statistics);
+EXPORT_SYMBOL(isph3a_aewb_request_statistics);
 
 /**
  * isph3a_aewb_init - Module Initialisation.
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isph3a.h kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isph3a.h
--- kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isph3a.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isph3a.h	2011-09-04 11:37:54.000000000 +0200
@@ -130,11 +130,11 @@ struct isp_h3a_device {
 	struct ispstat stat;
 };
 
-int omap34xx_isph3a_aewb_config(struct isp_h3a_device *isp_h3a,
-				struct isph3a_aewb_config *aewbcfg);
+int isph3a_aewb_config(struct isp_h3a_device *isp_h3a,
+		       struct isph3a_aewb_config *aewbcfg);
 
-int omap34xx_isph3a_aewb_request_statistics(struct isp_h3a_device *isp_h3a,
-					    struct isph3a_aewb_data *aewbdata);
+int isph3a_aewb_request_statistics(struct isp_h3a_device *isp_h3a,
+				   struct isph3a_aewb_data *aewbdata);
 
 void isph3a_save_context(struct device *dev);
 
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isppreview.c kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isppreview.c
--- kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isppreview.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isppreview.c	2011-09-04 11:37:54.000000000 +0200
@@ -184,17 +184,16 @@ static u32 luma_enhance_table[] = {
 #include "luma_enhance_table.h"
 };
 
-static int omap34xx_isp_tables_update(struct isp_prev_device *isp_prev,
-				struct isptables_update *isptables_struct);
+static int isppreview_tables_update(struct isp_prev_device *isp_prev,
+				    struct isptables_update *isptables_struct);
 
 
 /**
- * omap34xx_isp_preview_config - Abstraction layer Preview configuration.
+ * isppreview_config - Abstraction layer Preview configuration.
  * @userspace_add: Pointer from Userspace to structure with flags and data to
  *                 update.
  **/
-int omap34xx_isp_preview_config(struct isp_prev_device *isp_prev,
-				void *userspace_add)
+int isppreview_config(struct isp_prev_device *isp_prev, void *userspace_add)
 {
 	struct isp_device *isp = to_isp_device(isp_prev);
 	struct device *dev = to_device(isp_prev);
@@ -348,32 +347,26 @@ out_config_shadow:
 	isp_table_update.prev_cfa = config->prev_cfa;
 	isp_table_update.prev_wbal = config->prev_wbal;
 
-	if (omap34xx_isp_tables_update(isp_prev, &isp_table_update))
+	if (isppreview_tables_update(isp_prev, &isp_table_update))
 		goto err_copy_from_user;
 
-	spin_lock_irqsave(&isp_prev->lock, flags);
 	isp_prev->shadow_update = 0;
-	spin_unlock_irqrestore(&isp_prev->lock, flags);
-
 	return 0;
 
 err_copy_from_user:
-	spin_lock_irqsave(&isp_prev->lock, flags);
 	isp_prev->shadow_update = 0;
-	spin_unlock_irqrestore(&isp_prev->lock, flags);
-
 	dev_err(dev, "preview: Config: Copy From User Error\n");
 	return -EFAULT;
 }
-EXPORT_SYMBOL_GPL(omap34xx_isp_preview_config);
+EXPORT_SYMBOL_GPL(isppreview_config);
 
 /**
- * omap34xx_isp_tables_update - Abstraction layer Tables update.
+ * isppreview_tables_update - Abstraction layer Tables update.
  * @isptables_struct: Pointer from Userspace to structure with flags and table
  *                 data to update.
  **/
-static int omap34xx_isp_tables_update(struct isp_prev_device *isp_prev,
-			       struct isptables_update *isptables_struct)
+static int isppreview_tables_update(struct isp_prev_device *isp_prev,
+				    struct isptables_update *isptables_struct)
 {
 	struct device *dev = to_device(isp_prev);
 
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isppreview.h kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isppreview.h
--- kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/isppreview.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/isppreview.h	2011-09-04 11:37:54.000000000 +0200
@@ -419,8 +419,7 @@ void isppreview_restore_context(struct d
 static inline void isppreview_restore_context(struct device *dev) {}
 #endif
 
-int omap34xx_isp_preview_config(struct isp_prev_device *isp_prev,
-				void *userspace_add);
+int isppreview_config(struct isp_prev_device *isp_prev, void *userspace_add);
 
 void isppreview_set_skip(struct isp_prev_device *isp_prev, u32 h, u32 v);
 
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/ispreg.h kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/ispreg.h
--- kernel-2.6.28-20094102.6+0m5/drivers/media/video/isp/ispreg.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/media/video/isp/ispreg.h	2011-09-04 11:37:54.000000000 +0200
@@ -1275,6 +1275,7 @@
 
 #define ISPHIST_HV_INFO_MASK			0x3FFF3FFF
 
+#define ISPCCDC_LSC_ENABLE			1
 #define ISPCCDC_LSC_GAIN_MODE_N_MASK		0x700
 #define ISPCCDC_LSC_GAIN_MODE_N_SHIFT		8
 #define ISPCCDC_LSC_GAIN_MODE_M_MASK		0x3800
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/media/video/smia-sensor.c kernel-2.6.28-20094803.3+0m5/drivers/media/video/smia-sensor.c
--- kernel-2.6.28-20094102.6+0m5/drivers/media/video/smia-sensor.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/media/video/smia-sensor.c	2011-09-04 11:37:54.000000000 +0200
@@ -38,7 +38,17 @@
 #include "smia-sensor.h"
 
 #define DEFAULT_XCLK		9600000		/* [Hz] */
-#define DEFAULT_EXPOSURE	33946		/* [us] */
+
+#define SMIA_CTRL_GAIN		0
+#define SMIA_CTRL_EXPOSURE	1
+#define SMIA_NCTRLS		2
+
+#define CID_TO_CTRL(id)		((id) == V4L2_CID_GAIN ? SMIA_CTRL_GAIN : \
+				 (id) == V4L2_CID_EXPOSURE ? \
+					 SMIA_CTRL_EXPOSURE : \
+					 -EINVAL)
+
+#define VS6555_RESET_SHIFT_HACK	1
 
 /* Register definitions */
 
@@ -53,6 +63,50 @@
 #define REG_COARSE_EXPOSURE	0x0202
 #define REG_ANALOG_GAIN		0x0204
 
+struct smia_sensor;
+
+struct smia_sensor_type {
+	u8 manufacturer_id;
+	u16 model_id;
+	char *name;
+	int ev_table_size;
+	u16 *ev_table;
+};
+
+/* Current values for V4L2 controls */
+struct smia_control {
+	s32 minimum;
+	s32 maximum;
+	s32 step;
+	s32 default_value;
+	s32 value;
+	int (*set)(struct smia_sensor *, s32 value);
+};
+
+struct smia_sensor {
+	struct i2c_client *i2c_client;
+	struct i2c_driver driver;
+
+	/* Sensor information */
+	struct smia_sensor_type *type;
+	u8  revision_number;
+	u8  smia_version;
+
+	/* V4L2 current control values */
+	struct smia_control controls[SMIA_NCTRLS];
+
+	struct smia_reglist *current_reglist;
+	struct v4l2_int_device *v4l2_int_device;
+	struct v4l2_fract timeperframe;
+
+	struct smia_sensor_platform_data *platform_data;
+
+	const struct firmware *fw;
+	struct smia_meta_reglist *meta_reglist;
+
+	enum v4l2_power power;
+};
+
 static int smia_ioctl_queryctrl(struct v4l2_int_device *s,
 				struct v4l2_queryctrl *a);
 static int smia_ioctl_g_ctrl(struct v4l2_int_device *s,
@@ -77,6 +131,106 @@ static int smia_ioctl_enum_frameinterval
 					  struct v4l2_frmivalenum *frm);
 static int smia_ioctl_dev_init(struct v4l2_int_device *s);
 
+/* SMIA-model gain is stored in precalculated tables here. In the model,
+ * reg  = (c0-gain*c1) / (gain*m1-m0)
+ * gain = 2^ev
+ * The constants c0, m0, c1 and m1 depend on sensor.
+ */
+
+/* Analog gain table for VS6555.
+ * m0   = 0
+ * c0   = 256
+ * m1   = -1  (erroneously -16 in silicon)
+ * c1   = 256
+ * step = 16
+ */
+static u16 smia_gain_vs6555[] = {
+/*	reg	   EV    gain     */
+	  0,	/* 0.0   1.00000  */
+	 16,	/* 0.1   1.07177  */
+	 32,	/* 0.2   1.14870  */
+	 48,	/* 0.3   1.23114  */
+	 64,	/* 0.4   1.31951  */
+	 80,	/* 0.5   1.41421  */
+	 80,	/* 0.6   1.51572  */
+	 96,	/* 0.7   1.62450  */
+	112,	/* 0.8   1.74110  */
+	112,	/* 0.9   1.86607  */
+	128,	/* 1.0   2.00000  */
+	144,	/* 1.1   2.14355  */
+	144,	/* 1.2   2.29740  */
+	160,	/* 1.3   2.46229  */
+	160,	/* 1.4   2.63902  */
+	160,	/* 1.5   2.82843  */
+	176,	/* 1.6   3.03143  */
+	176,	/* 1.7   3.24901  */
+	176,	/* 1.8   3.48220  */
+	192,	/* 1.9   3.73213  */
+	192,	/* 2.0   4.00000  */
+	192,	/* 2.1   4.28709  */
+	208,	/* 2.2   4.59479  */
+	208,	/* 2.3   4.92458  */
+	208,	/* 2.4   5.27803  */
+	208,	/* 2.5   5.65685  */
+	208,	/* 2.6   6.06287  */
+	224,	/* 2.7   6.49802  */
+	224,	/* 2.8   6.96440  */
+	224,	/* 2.9   7.46426  */
+	224,	/* 3.0   8.00000  */
+	224,	/* 3.1   8.57419  */
+	224,	/* 3.2   9.18959  */
+	224,	/* 3.3   9.84916  */
+	224,	/* 3.4  10.55606  */
+	240,	/* 3.5  11.31371  */
+	240,	/* 3.6  12.12573  */
+	240,	/* 3.7  12.99604  */
+	240,	/* 3.8  13.92881  */
+	240,	/* 3.9  14.92853  */
+	240,	/* 4.0  16.00000  */
+};
+
+/* Analog gain table for TCM8330MD.
+ * m0   = 1
+ * c0   = 0
+ * m1   = 0
+ * c1   = 36 (MMS uses 29)
+ * step = 1
+ */
+static u16 smia_gain_tcm8330md[] = {
+/*	reg	   EV      gain     */
+	 36,	/* 0.0     1.00000  */
+	 39,	/* 0.1     1.07177  */
+	 41,	/* 0.2     1.14870  */
+	 44,	/* 0.3     1.23114  */
+	 48,	/* 0.4     1.31951  */
+	 51,	/* 0.5     1.41421  */
+	 55,	/* 0.6     1.51572  */
+	 58,	/* 0.7     1.62450  */
+	 63,	/* 0.8     1.74110  */
+	 67,	/* 0.9     1.86607  */
+	 72,	/* 1.0     2.00000  */
+	 77,	/* 1.1     2.14355  */
+	 83,	/* 1.2     2.29740  */
+	 89,	/* 1.3     2.46229  */
+	 95,	/* 1.4     2.63902  */
+	102,	/* 1.5     2.82843  */
+	109,	/* 1.6     3.03143  */
+	117,	/* 1.7     3.24901  */
+	125,	/* 1.8     3.48220  */
+	134,	/* 1.9     3.73213  */
+	144,	/* 2.0     4.00000  */
+	154,	/* 2.1     4.28709  */
+	165,	/* 2.2     4.59479  */
+	177,	/* 2.3     4.92458  */
+	190,	/* 2.4     5.27803  */
+	204,	/* 2.5     5.65685  */
+	218,	/* 2.6     6.06287  */
+	234,	/* 2.7     6.49802  */
+	251,	/* 2.8     6.96440  */
+	269,	/* 2.9     7.46426  */
+	288,	/* 3.0     8.00000  */
+};
+
 static struct v4l2_int_ioctl_desc smia_ioctl_desc[] = {
 	{ vidioc_int_enum_fmt_cap_num,
 	  (v4l2_int_ioctl_func *)smia_ioctl_enum_fmt_cap },
@@ -125,13 +279,16 @@ static struct v4l2_int_device smia_int_d
 	},
 };
 
-static struct {
-	u8 manufacturer_id;
-	u16 model_id;
-	char *name;
-} smia_sensors[] = {
-	{ 0x01, 0x022b, "vs6555" },
-	{ 0x0c, 0x208a, "tcm8330md" },
+static struct smia_sensor_type smia_sensors[] = {
+	{ 0, 0, "unknown", 0, NULL },
+	{
+		0x01, 0x022b, "vs6555",
+		ARRAY_SIZE(smia_gain_vs6555), smia_gain_vs6555
+	},
+	{
+		0x0c, 0x208a, "tcm8330md",
+		ARRAY_SIZE(smia_gain_tcm8330md), smia_gain_tcm8330md
+	},
 };
 
 static const __u32 smia_mode_ctrls[] = {
@@ -198,6 +355,47 @@ static int smia_exposure_rows_to_us(stru
 	return (smia_get_row_time(sensor) * rows + (1 << 7)) >> 8;
 }
 
+/* Called to change the V4L2 gain control value. This function
+ * rounds and clamps the given value and updates the V4L2 control value.
+ * If power is on, also updates the sensor analog gain.
+ */
+static int smia_set_gain(struct smia_sensor *sensor, s32 gain)
+{
+	gain = clamp(gain,
+		sensor->controls[SMIA_CTRL_GAIN].minimum,
+		sensor->controls[SMIA_CTRL_GAIN].maximum);
+	sensor->controls[SMIA_CTRL_GAIN].value = gain;
+
+	if (sensor->power == V4L2_POWER_OFF)
+		return 0;
+
+	return smia_i2c_write_reg(sensor->i2c_client,
+				  SMIA_REG_16BIT, REG_ANALOG_GAIN,
+				  sensor->type->ev_table[gain]);
+}
+
+/* Called to change the V4L2 exposure control value. This function
+ * rounds and clamps the given value and updates the V4L2 control value.
+ * If power is on, also update the sensor exposure time.
+ * exptime is in microseconds.
+ */
+static int smia_set_exposure(struct smia_sensor *sensor, s32 exptime)
+{
+	int exposure_rows;
+
+	exptime = clamp(exptime, sensor->controls[SMIA_CTRL_EXPOSURE].minimum,
+				 sensor->controls[SMIA_CTRL_EXPOSURE].maximum);
+
+	exposure_rows = smia_exposure_us_to_rows(sensor, &exptime);
+	sensor->controls[SMIA_CTRL_EXPOSURE].value = exptime;
+
+	if (sensor->power == V4L2_POWER_OFF)
+		return 0;
+
+	return smia_i2c_write_reg(sensor->i2c_client,
+			SMIA_REG_16BIT, REG_COARSE_EXPOSURE, exposure_rows);
+}
+
 static int smia_stream_on(struct v4l2_int_device *s)
 {
 	struct smia_sensor *sensor = s->priv;
@@ -212,6 +410,37 @@ static int smia_stream_off(struct v4l2_i
 				  SMIA_REG_8BIT, 0x0100, 0x00);
 }
 
+static int smia_update_controls(struct v4l2_int_device *s)
+{
+	struct smia_sensor *sensor = s->priv;
+	int i;
+
+	sensor->controls[SMIA_CTRL_EXPOSURE].minimum = 0;
+	sensor->controls[SMIA_CTRL_EXPOSURE].maximum =
+		smia_exposure_rows_to_us(sensor,
+					 sensor->current_reglist->mode.max_exp);
+	sensor->controls[SMIA_CTRL_EXPOSURE].step =
+		smia_exposure_rows_to_us(sensor, 1);
+	sensor->controls[SMIA_CTRL_EXPOSURE].default_value =
+		sensor->controls[SMIA_CTRL_EXPOSURE].maximum;
+	if (sensor->controls[SMIA_CTRL_EXPOSURE].value == 0)
+		sensor->controls[SMIA_CTRL_EXPOSURE].value =
+			sensor->controls[SMIA_CTRL_EXPOSURE].maximum;
+
+	/* Adjust V4L2 control values and write them to the sensor */
+
+	for (i = 0; i < ARRAY_SIZE(sensor->controls); i++) {
+		int rval;
+		if (!sensor->controls[i].set)
+			continue;
+		rval = sensor->controls[i].set(sensor,
+			sensor->controls[i].value);
+		if (rval)
+			return rval;
+	}
+	return 0;
+}
+
 /* Must be called with power already enabled on the sensor */
 static int smia_configure(struct v4l2_int_device *s)
 {
@@ -223,17 +452,6 @@ static int smia_configure(struct v4l2_in
 	if (rval)
 		goto fail;
 
-	rval = smia_i2c_write_reg(sensor->i2c_client, SMIA_REG_8BIT,
-				  REG_ANALOG_GAIN+1,
-				  sensor->ctrl_gain << 4);
-	if (rval)
-		goto fail;
-	rval = smia_i2c_write_reg(sensor->i2c_client,
-		SMIA_REG_16BIT, REG_COARSE_EXPOSURE,
-		smia_exposure_us_to_rows(sensor, &sensor->ctrl_exposure));
-	if (rval)
-		goto fail;
-
 	/*
 	 * FIXME: remove stream_off from here as soon as camera-firmware
 	 * is modified to not enable streaming automatically.
@@ -242,6 +460,10 @@ static int smia_configure(struct v4l2_in
 	if (rval)
 		goto fail;
 
+	rval = smia_update_controls(s);
+	if (rval)
+		goto fail;
+
 	rval = sensor->platform_data->configure_interface(
 		s,
 		sensor->current_reglist->mode.window_width,
@@ -313,21 +535,13 @@ static struct v4l2_queryctrl smia_ctrls[
 	{
 		.id		= V4L2_CID_GAIN,
 		.type		= V4L2_CTRL_TYPE_INTEGER,
-		.name		= "Analog gain",
-		.minimum	= 0,
-		.maximum	= 15,
-		.step		= 1,
-		.default_value	= 0,
+		.name		= "Analog gain [0.1 EV]",
 		.flags		= V4L2_CTRL_FLAG_SLIDER,
 	},
 	{
 		.id		= V4L2_CID_EXPOSURE,
 		.type		= V4L2_CTRL_TYPE_INTEGER,
 		.name		= "Exposure time [us]",
-		.minimum	= 0,
-		.maximum	= DEFAULT_EXPOSURE,
-		.step		= 1,
-		.default_value	= DEFAULT_EXPOSURE,
 		.flags		= V4L2_CTRL_FLAG_SLIDER,
 	},
 };
@@ -336,7 +550,7 @@ static int smia_ioctl_queryctrl(struct v
 			   struct v4l2_queryctrl *a)
 {
 	struct smia_sensor *sensor = s->priv;
-	int rval;
+	int rval, ctrl;
 
 	rval = smia_ctrl_query(smia_ctrls, ARRAY_SIZE(smia_ctrls), a);
 	if (rval) {
@@ -344,16 +558,16 @@ static int smia_ioctl_queryctrl(struct v
 					ARRAY_SIZE(smia_mode_ctrls), a);
 	}
 
-	switch (a->id) {
-	case V4L2_CID_EXPOSURE:
-		if (sensor->current_reglist) {
-			a->maximum = smia_exposure_rows_to_us(sensor,
-				     sensor->current_reglist->mode.max_exp);
-			a->step = smia_exposure_rows_to_us(sensor, 1);
-			a->default_value = a->maximum;
-		}
-		break;
-	}
+	ctrl = CID_TO_CTRL(a->id);
+	if (ctrl < 0)
+		return ctrl;
+	if (!sensor->controls[ctrl].set)
+		return -EINVAL;
+
+	a->minimum       = sensor->controls[ctrl].minimum;
+	a->maximum       = sensor->controls[ctrl].maximum;
+	a->step          = sensor->controls[ctrl].step;
+	a->default_value = sensor->controls[ctrl].default_value;
 
 	return 0;
 }
@@ -362,6 +576,7 @@ static int smia_ioctl_g_ctrl(struct v4l2
 			struct v4l2_control *vc)
 {
 	struct smia_sensor *sensor = s->priv;
+	int ctrl;
 
 	int rval = smia_mode_g_ctrl(smia_mode_ctrls,
 			ARRAY_SIZE(smia_mode_ctrls),
@@ -369,16 +584,13 @@ static int smia_ioctl_g_ctrl(struct v4l2
 	if (rval == 0)
 		return 0;
 
-	switch (vc->id) {
-	case V4L2_CID_GAIN:
-		vc->value = sensor->ctrl_gain;
-		break;
-	case V4L2_CID_EXPOSURE:
-		vc->value = sensor->ctrl_exposure;
-		break;
-	default:
+	ctrl = CID_TO_CTRL(vc->id);
+	if (ctrl < 0)
+		return ctrl;
+	if (!sensor->controls[ctrl].set)
 		return -EINVAL;
-	}
+	vc->value = sensor->controls[ctrl].value;
+
 	return 0;
 }
 
@@ -386,30 +598,13 @@ static int smia_ioctl_s_ctrl(struct v4l2
 			struct v4l2_control *vc)
 {
 	struct smia_sensor *sensor = s->priv;
-	int exposure_rows;
-	int r = 0;
 
-	switch (vc->id) {
-	case V4L2_CID_GAIN:
-		sensor->ctrl_gain = clamp(vc->value, 0, 15);
-		if (sensor->power == V4L2_POWER_ON)
-			r = smia_i2c_write_reg(sensor->i2c_client,
-				SMIA_REG_8BIT, REG_ANALOG_GAIN+1,
-				sensor->ctrl_gain << 4);
-		break;
-	case V4L2_CID_EXPOSURE:
-		sensor->ctrl_exposure = vc->value;
-		exposure_rows = smia_exposure_us_to_rows(sensor,
-							&sensor->ctrl_exposure);
-		if (sensor->power == V4L2_POWER_ON)
-			r = smia_i2c_write_reg(sensor->i2c_client,
-				SMIA_REG_16BIT, REG_COARSE_EXPOSURE,
-				exposure_rows);
-		break;
-	default:
+	int ctrl = CID_TO_CTRL(vc->id);
+	if (ctrl < 0)
+		return ctrl;
+	if (!sensor->controls[ctrl].set)
 		return -EINVAL;
-	}
-	return r;
+	return sensor->controls[ctrl].set(sensor, vc->value);
 }
 
 static int smia_ioctl_enum_fmt_cap(struct v4l2_int_device *s,
@@ -440,13 +635,10 @@ static int smia_ioctl_s_fmt_cap(struct v
 
 	reglist = smia_reglist_find_mode_fmt(sensor->meta_reglist,
 					     sensor->current_reglist, f);
-
-	if (reglist) {
-		sensor->current_reglist = reglist;
-		return 0;
-	}
-
-	return -EINVAL;
+	if (!reglist)
+		return -EINVAL;
+	sensor->current_reglist = reglist;
+	return smia_update_controls(s);
 }
 
 static int smia_ioctl_g_parm(struct v4l2_int_device *s,
@@ -476,12 +668,10 @@ static int smia_ioctl_s_parm(struct v4l2
 	reglist = smia_reglist_find_mode_streamparm(sensor->meta_reglist,
 						    sensor->current_reglist, a);
 
-	if (reglist) {
-		sensor->current_reglist = reglist;
-		return 0;
-	}
-
-	return -EINVAL;
+	if (!reglist)
+		return -EINVAL;
+	sensor->current_reglist = reglist;
+	return smia_update_controls(s);
 }
 
 static int smia_ioctl_dev_init(struct v4l2_int_device *s)
@@ -508,35 +698,56 @@ static int smia_ioctl_dev_init(struct v4
 		goto out_poweroff;
 	}
 
-	sensor->model_id        = model_id;
 	sensor->revision_number = revision_number;
-	sensor->manufacturer_id = manufacturer_id;
 	sensor->smia_version    = smia_version;
 
-	if (sensor->smia_version != 10) {
+	if (smia_version != 10) {
 		/* We support only SMIA version 1.0 at the moment */
 		dev_err(&sensor->i2c_client->dev,
 			"unknown sensor 0x%04x detected (smia ver %i.%i)\n",
-			sensor->model_id,
-			sensor->smia_version / 10, sensor->smia_version % 10);
+			model_id, smia_version / 10, smia_version % 10);
 		rval = -ENODEV;
 		goto out_poweroff;
 	}
 
-	/* Update identification string */
-	for (i = 0; i < ARRAY_SIZE(smia_sensors); i++) {
-		if (smia_sensors[i].manufacturer_id == sensor->manufacturer_id
-		    && smia_sensors[i].model_id == sensor->model_id)
+	/* Detect which sensor we have */
+	for (i = 1; i < ARRAY_SIZE(smia_sensors); i++) {
+		if (smia_sensors[i].manufacturer_id == manufacturer_id
+		    && smia_sensors[i].model_id == model_id)
 			break;
 	}
-	if (i < ARRAY_SIZE(smia_sensors))
-		strncpy(s->name, smia_sensors[i].name, V4L2NAMESIZE);
+	if (i >= ARRAY_SIZE(smia_sensors))
+		i = 0;			/* Unknown sensor */
+	sensor->type = &smia_sensors[i];
+
+	/* Initialize V4L2 controls */
+
+	/* Gain is initialized here permanently */
+	sensor->controls[SMIA_CTRL_GAIN].minimum           = 0;
+	sensor->controls[SMIA_CTRL_GAIN].maximum           =
+				sensor->type->ev_table_size - 1;
+	sensor->controls[SMIA_CTRL_GAIN].step              = 1;
+	sensor->controls[SMIA_CTRL_GAIN].default_value     = 0;
+	sensor->controls[SMIA_CTRL_GAIN].value             = 0;
+	sensor->controls[SMIA_CTRL_GAIN].set               =
+				sensor->type->ev_table ? smia_set_gain : NULL;
+
+	/* Exposure parameters may change at each mode change, just zero here */
+	sensor->controls[SMIA_CTRL_EXPOSURE].minimum       = 0;
+	sensor->controls[SMIA_CTRL_EXPOSURE].maximum       = 0;
+	sensor->controls[SMIA_CTRL_EXPOSURE].step          = 0;
+	sensor->controls[SMIA_CTRL_EXPOSURE].default_value = 0;
+	sensor->controls[SMIA_CTRL_EXPOSURE].value         = 0;
+	sensor->controls[SMIA_CTRL_EXPOSURE].set           = smia_set_exposure;
+
+	/* Update identification string */
+	strncpy(s->name, sensor->type->name, V4L2NAMESIZE);
 	s->name[V4L2NAMESIZE-1] = 0;	/* Ensure NULL terminated string */
 
 	/* Import firmware */
 	snprintf(name, FIRMWARE_NAME_MAX, "%s-%02x-%04x-%02x.bin",
-		 SMIA_SENSOR_NAME, sensor->manufacturer_id,
-		 sensor->model_id, sensor->revision_number);
+		 SMIA_SENSOR_NAME, sensor->type->manufacturer_id,
+		 sensor->type->model_id, sensor->revision_number);
 
 	if (request_firmware(&sensor->fw, name,
 			     &sensor->i2c_client->dev)) {
@@ -585,10 +796,74 @@ out_poweroff:
 	return rval;
 }
 
+#if VS6555_RESET_SHIFT_HACK
+/*
+ * Check if certain undocumented registers have values we expect.
+ * If not, reset sensor and recheck.
+ * This should be called when streaming is already enabled.
+ */
+static int smia_vs6555_reset_shift_hack(struct v4l2_int_device *s)
+{
+	struct smia_sensor *sensor = s->priv;
+	int count = 10;
+	int r381c = 0;
+	int r381d = 0;
+	int r381e = 0;
+	int r381f = 0;
+	int rval;
+
+	do {
+		rval = smia_i2c_read_reg(sensor->i2c_client,
+					 SMIA_REG_8BIT, 0x381c, &r381c);
+		if (rval)
+			return rval;
+		rval = smia_i2c_read_reg(sensor->i2c_client,
+					 SMIA_REG_8BIT, 0x381d, &r381d);
+		if (rval)
+			return rval;
+		rval = smia_i2c_read_reg(sensor->i2c_client,
+					 SMIA_REG_8BIT, 0x381e, &r381e);
+		if (rval)
+			return rval;
+		rval = smia_i2c_read_reg(sensor->i2c_client,
+					 SMIA_REG_8BIT, 0x381f, &r381f);
+		if (rval)
+			return rval;
+
+		if (r381d != 0 && r381f != 0 &&
+		    r381c == 0 && r381e == 0)
+			return 0;
+
+		dev_dbg(&sensor->i2c_client->dev, "VS6555 HW misconfigured--"
+			"trying to reset (%02X%02X%02X%02X)\n",
+			r381c, r381d, r381e, r381f);
+
+		smia_stream_off(s);
+		smia_power_off(s);
+		msleep(2);
+		rval = smia_power_on(s);
+		if (rval)
+			return rval;
+		rval = smia_configure(s);
+		if (rval)
+			return rval;
+		rval = smia_stream_on(s);
+		if (rval)
+			return rval;
+	} while (--count > 0);
+
+	dev_warn(&sensor->i2c_client->dev,
+		"VS6555 reset failed--expect bad image\n");
+
+	return 0;	/* Return zero nevertheless -- at least we tried */
+}
+#endif
+
 static int smia_ioctl_s_power(struct v4l2_int_device *s,
 				enum v4l2_power new_state)
 {
 	struct smia_sensor *sensor = s->priv;
+	enum v4l2_power old_state = sensor->power;
 	int rval = 0;
 
 	/*
@@ -599,7 +874,7 @@ static int smia_ioctl_s_power(struct v4l
 		new_state = V4L2_POWER_OFF;
 
 	/* If we are already in this mode, do nothing */
-	if (sensor->power == new_state)
+	if (old_state == new_state)
 		return 0;
 
 	/* Disable power if so requested (it was enabled) */
@@ -615,7 +890,7 @@ static int smia_ioctl_s_power(struct v4l
 	/* Either STANDBY or ON requested */
 
 	/* Enable power and move to standby if it was off */
-	if (sensor->power == V4L2_POWER_OFF) {
+	if (old_state == V4L2_POWER_OFF) {
 		rval = smia_power_on(s);
 		if (rval)
 			goto out;
@@ -625,23 +900,26 @@ static int smia_ioctl_s_power(struct v4l
 
 	if (new_state == V4L2_POWER_ON) {
 		/* Standby -> streaming */
+		sensor->power = V4L2_POWER_ON;
 		rval = smia_configure(s);
 		if (rval) {
 			smia_stream_off(s);
-			if (sensor->power == V4L2_POWER_OFF)
+			if (old_state == V4L2_POWER_OFF)
 				smia_power_off(s);
 			goto out;
 		}
 		rval = smia_stream_on(s);
+#if VS6555_RESET_SHIFT_HACK
+		if (rval == 0 && sensor->type->manufacturer_id == 0x01)
+			rval = smia_vs6555_reset_shift_hack(s);
+#endif
 	} else {
 		/* Streaming -> standby */
 		rval = smia_stream_off(s);
 	}
 
 out:
-	if (rval == 0)
-		sensor->power = new_state;
-
+	sensor->power = (rval == 0) ? new_state : old_state;
 	return rval;
 }
 
@@ -717,9 +995,6 @@ static int smia_probe(struct i2c_client
 	sensor->i2c_client = client;
 	i2c_set_clientdata(client, sensor);
 
-	sensor->ctrl_gain     = 0;
-	sensor->ctrl_exposure = DEFAULT_EXPOSURE;
-
 	rval = v4l2_int_device_register(sensor->v4l2_int_device);
 	if (rval)
 		i2c_set_clientdata(client, NULL);
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/media/video/smia-sensor.h kernel-2.6.28-20094803.3+0m5/drivers/media/video/smia-sensor.h
--- kernel-2.6.28-20094102.6+0m5/drivers/media/video/smia-sensor.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/media/video/smia-sensor.h	2011-09-04 11:37:54.000000000 +0200
@@ -24,7 +24,6 @@
 #ifndef SMIA_SENSOR_H
 #define SMIA_SENSOR_H
 
-#include <linux/i2c.h>
 #include <media/v4l2-int-device.h>
 
 #define SMIA_SENSOR_NAME	"smia-sensor"
@@ -39,30 +38,5 @@ struct smia_sensor_platform_data {
 	int (*power_off)(struct v4l2_int_device *s);
 };
 
-struct smia_sensor {
-	struct i2c_client *i2c_client;
-	struct i2c_driver driver;
-
-	/* Sensor information */
-	u16 model_id;
-	u8  revision_number;
-	u8  manufacturer_id;
-	u8  smia_version;
-
-	/* V4L2 current control values */
-	s32 ctrl_exposure;
-	s32 ctrl_gain;
-
-	struct smia_reglist *current_reglist;
-	struct v4l2_int_device *v4l2_int_device;
-	struct v4l2_fract timeperframe;
-
-	struct smia_sensor_platform_data *platform_data;
-
-	const struct firmware *fw;
-	struct smia_meta_reglist *meta_reglist;
-
-	enum v4l2_power power;
-};
 
 #endif /* SMIA_SENSOR_H */
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/mfd/twl4030-power.c kernel-2.6.28-20094803.3+0m5/drivers/mfd/twl4030-power.c
--- kernel-2.6.28-20094102.6+0m5/drivers/mfd/twl4030-power.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/mfd/twl4030-power.c	2011-09-04 11:37:54.000000000 +0200
@@ -69,6 +69,11 @@ static u8 triton_next_free_address = 0x2
 #define KEY_1			0xC0
 #define KEY_2			0x0C
 
+#define R_VDD1_OSC		0x5C
+#define R_VDD2_OSC		0x6A
+#define R_VIO_OSC		0x52
+#define EXT_FS_CLK_EN		(0x1 << 6)
+
 /* resource configuration registers */
 
 #define DEVGROUP_OFFSET		0
@@ -467,6 +472,31 @@ int twl4030_disable_regulator(int res)
 }
 EXPORT_SYMBOL(twl4030_disable_regulator);
 
+/**
+ * @brief twl_workaround - implement errata XYZ
+ * XYZ errata workaround requires the TWL DCDCs to use
+ * HFCLK - for this you need to write to all OSC regs to
+ * enable this path
+ * WARNING: you SHOULD change your board dependent script
+ * file to handle RET and OFF mode sequences correctly
+ *
+ * @return
+ */
+static void __init twl_workaround(void)
+{
+	u8 val;
+	u8 reg[]={R_VDD1_OSC, R_VDD2_OSC, R_VIO_OSC};
+	int i;
+	int err = 0;
+	for (i = 0; i < sizeof(reg); i++) {
+		err |= twl4030_i2c_read_u8(TWL4030_MODULE_PM_RECEIVER, &val, reg[i]);
+		val |= EXT_FS_CLK_EN;
+		err |= twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, val, reg[i]);
+	}
+	if (err)
+		pr_warning("TWL4030: workaround setup failed!\n");
+}
+
 void __init twl4030_power_init(struct twl4030_power_data *triton2_scripts)
 {
 	int err = 0;
@@ -502,6 +532,8 @@ void __init twl4030_power_init(struct tw
 		}
 	}
 
+	/* TODO: introduce workaround based on TWL4030 revision */
+	twl_workaround();
 	if (twl4030_i2c_write_u8(TWL4030_MODULE_PM_MASTER, 0, R_PROTECT_KEY))
 		printk(KERN_ERR
 			"TWL4030 Unable to relock registers\n");
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/misc/Kconfig kernel-2.6.28-20094803.3+0m5/drivers/misc/Kconfig
--- kernel-2.6.28-20094102.6+0m5/drivers/misc/Kconfig	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/misc/Kconfig	2011-09-04 11:37:54.000000000 +0200
@@ -523,5 +523,6 @@ source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/ssi/Kconfig"
 source "drivers/misc/mcsaab/Kconfig"
 source "drivers/misc/cmt-speech/Kconfig"
+source "drivers/misc/ssi-char/Kconfig"
 
 endif # MISC_DEVICES
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/misc/Makefile kernel-2.6.28-20094803.3+0m5/drivers/misc/Makefile
--- kernel-2.6.28-20094102.6+0m5/drivers/misc/Makefile	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/misc/Makefile	2011-09-04 11:37:54.000000000 +0200
@@ -38,3 +38,5 @@ obj-$(CONFIG_C2PORT)		+= c2port/
 obj-$(CONFIG_OMAP_SSI)		+= ssi/
 obj-$(CONFIG_SSI_MCSAAB_IMP)	+= mcsaab/
 obj-$(CONFIG_SSI_CMT_SPEECH)	+= cmt-speech/
+obj-$(CONFIG_SSI_CHAR)     += ssi-char/
+obj-$(CONFIG_PANIC_INFO_BUFF)	+= panic_info_buff.o
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/misc/panic_info_buff.c kernel-2.6.28-20094803.3+0m5/drivers/misc/panic_info_buff.c
--- kernel-2.6.28-20094102.6+0m5/drivers/misc/panic_info_buff.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20094803.3+0m5/drivers/misc/panic_info_buff.c	2011-09-04 11:37:54.000000000 +0200
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) Nokia Corporation
+ *
+ * Contact: Atal Shargorodsky <ext-atal.shargorodsky@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/uaccess.h>
+#include <linux/debugfs.h>
+#include <linux/notifier.h>
+
+#define PANIC_BUFFER_MAX_LEN  1024
+static char panic_info_buff[PANIC_BUFFER_MAX_LEN];
+static struct dentry *panic_info_buff_debugfs;
+
+static int panic_info_buff_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static ssize_t panic_info_buff_write(struct file *file,
+		const char __user *buf, size_t len, loff_t *off)
+{
+	if (len >= PANIC_BUFFER_MAX_LEN)
+		return -EINVAL;
+	if (copy_from_user(panic_info_buff, buf, len))
+		return -EFAULT;
+	panic_info_buff[len] = '\0';
+	return len;
+}
+
+static struct file_operations panic_info_buff_fops = {
+	.open   = panic_info_buff_open,
+	.write  = panic_info_buff_write,
+	.llseek = no_llseek,
+	.owner  = THIS_MODULE,
+};
+
+static int panic_info_buff_event(struct notifier_block *this,
+	unsigned long event, void *ptr)
+{
+	if (panic_info_buff[0] == '\0') {
+		printk(KERN_EMERG "Panic info buffer is empty.\n");
+	} else {
+		printk(KERN_EMERG "Panic info buffer:\n");
+		printk(KERN_EMERG "%s\n", panic_info_buff);
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block panic_info_buff_block = {
+	.notifier_call  = panic_info_buff_event,
+	.priority       = 1,
+};
+
+static int __devinit panic_info_buff_init(void)
+{
+	panic_info_buff_debugfs = debugfs_create_file("panic_info_buff",
+		S_IFREG | S_IWUSR | S_IWGRP,
+		NULL, NULL, &panic_info_buff_fops);
+	atomic_notifier_chain_register(&panic_notifier_list,
+		&panic_info_buff_block);
+	return 0;
+}
+module_init(panic_info_buff_init);
+
+static void __devexit panic_info_buff_exit(void)
+{
+	debugfs_remove(panic_info_buff_debugfs);
+	atomic_notifier_chain_unregister(&panic_notifier_list,
+		&panic_info_buff_block);
+
+}
+module_exit(panic_info_buff_exit);
+
+MODULE_AUTHOR("Nokia Corporation");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("panic_info_buff");
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi/ssi_driver.h kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi/ssi_driver.h
--- kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi/ssi_driver.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi/ssi_driver.h	2011-09-04 11:37:54.000000000 +0200
@@ -44,6 +44,8 @@
 
 /* Channel states */
 #define	SSI_CH_OPEN		0x01
+#define SSI_CH_RX_POLL		0x10
+
 /*
  * The number of channels to use by the driver in the ports, or the highest
  * port channel number (+1) used. (MAX:8)
@@ -87,8 +89,8 @@ struct ssi_channel {
 	u8 channel_number;
 	rwlock_t rw_lock;
 	struct ssi_device *dev;
-	void (*write_done)(struct ssi_device *dev);
-	void (*read_done)(struct ssi_device *dev);
+	void (*write_done) (struct ssi_device *dev);
+	void (*read_done) (struct ssi_device *dev);
 	void (*port_event)(struct ssi_device *dev, unsigned int event,
 								void *arg);
 };
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi/ssi_driver_if.c kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi/ssi_driver_if.c
--- kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi/ssi_driver_if.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi/ssi_driver_if.c	2011-09-04 11:37:54.000000000 +0200
@@ -24,6 +24,127 @@
 
 #include "ssi_driver.h"
 
+#define NOT_SET		(-1)
+
+int ssi_set_rx(struct ssi_port *sport, struct ssr_ctx *cfg)
+{
+	struct ssi_dev *ssi_ctrl = sport->ssi_controller;
+	void __iomem *base = ssi_ctrl->base;
+	int port = sport->port_number;
+
+	if ((cfg->mode != SSI_MODE_STREAM) &&
+		(cfg->mode != SSI_MODE_FRAME) &&
+		(cfg->mode != SSI_MODE_SLEEP) &&
+		(cfg->mode != NOT_SET))
+		return -EINVAL;
+
+	if ((cfg->frame_size > SSI_MAX_FRAME_SIZE) &&
+		(cfg->frame_size != NOT_SET))
+		return -EINVAL;
+
+	if ((cfg->channels == 0) ||
+		((cfg->channels > SSI_CHANNELS_DEFAULT) &&
+			(cfg->channels != NOT_SET)))
+		return -EINVAL;
+
+	if ((cfg->timeout > SSI_MAX_RX_TIMEOUT) && (cfg->timeout != NOT_SET))
+		return -EINVAL;
+
+	if (cfg->mode != NOT_SET)
+		ssi_outl(cfg->mode, base, SSI_SSR_MODE_REG(port));
+
+	if (cfg->frame_size != NOT_SET)
+		ssi_outl(cfg->frame_size, base, SSI_SSR_FRAMESIZE_REG(port));
+
+	if (cfg->channels != NOT_SET) {
+		if ((cfg->channels & (-cfg->channels)) ^ cfg->channels)
+			return -EINVAL;
+		else
+			ssi_outl(cfg->channels, base,
+					SSI_SSR_CHANNELS_REG(port));
+	}
+
+	if (cfg->timeout != NOT_SET)
+		ssi_outl(cfg->timeout, base, SSI_SSR_TIMEOUT_REG(port));
+
+	return 0;
+}
+
+void ssi_get_rx(struct ssi_port *sport, struct ssr_ctx *cfg)
+{
+	struct ssi_dev *ssi_ctrl = sport->ssi_controller;
+	void __iomem *base = ssi_ctrl->base;
+	int port = sport->port_number;
+
+	cfg->mode = ssi_inl(base, SSI_SSR_MODE_REG(port));
+	cfg->frame_size = ssi_inl(base, SSI_SSR_FRAMESIZE_REG(port));
+	cfg->channels = ssi_inl(base, SSI_SSR_CHANNELS_REG(port));
+	cfg->timeout = ssi_inl(base, SSI_SSR_TIMEOUT_REG(port));
+}
+
+int ssi_set_tx(struct ssi_port *sport, struct sst_ctx *cfg)
+{
+	struct ssi_dev *ssi_ctrl = sport->ssi_controller;
+	void __iomem *base = ssi_ctrl->base;
+	int port = sport->port_number;
+
+	if ((cfg->mode != SSI_MODE_STREAM) &&
+		(cfg->mode != SSI_MODE_FRAME) &&
+		(cfg->mode != NOT_SET))
+		return -EINVAL;
+
+	if ((cfg->frame_size > SSI_MAX_FRAME_SIZE) &&
+		(cfg->frame_size != NOT_SET))
+		return -EINVAL;
+
+	if ((cfg->channels == 0) ||
+		((cfg->channels > SSI_CHANNELS_DEFAULT) &&
+			(cfg->channels != NOT_SET)))
+		return -EINVAL;
+
+	if ((cfg->divisor > SSI_MAX_TX_DIVISOR) && (cfg->divisor != NOT_SET))
+		return -EINVAL;
+
+	if ((cfg->arb_mode != SSI_ARBMODE_ROUNDROBIN) &&
+		(cfg->arb_mode != SSI_ARBMODE_PRIORITY) &&
+		(cfg->mode != NOT_SET))
+		return -EINVAL;
+
+	if (cfg->mode != NOT_SET)
+		ssi_outl(cfg->channels, base, SSI_SST_CHANNELS_REG(port));
+
+	if (cfg->frame_size != NOT_SET)
+		ssi_outl(cfg->frame_size, base, SSI_SST_FRAMESIZE_REG(port));
+
+	if (cfg->channels != NOT_SET) {
+		if ((cfg->channels & (-cfg->channels)) ^ cfg->channels)
+			return -EINVAL;
+		else
+			ssi_outl(cfg->mode, base, SSI_SST_MODE_REG(port));
+	}
+
+	if (cfg->divisor != NOT_SET)
+		ssi_outl(cfg->divisor, base, SSI_SST_DIVISOR_REG(port));
+
+	if (cfg->arb_mode != NOT_SET)
+		ssi_outl(cfg->arb_mode, base, SSI_SST_ARBMODE_REG(port));
+
+	return 0;
+}
+
+void ssi_get_tx(struct ssi_port *sport, struct sst_ctx *cfg)
+{
+    struct ssi_dev *ssi_ctrl = sport->ssi_controller;
+    void __iomem *base = ssi_ctrl->base;
+    int port = sport->port_number;
+
+    cfg->mode = ssi_inl(base, SSI_SST_MODE_REG(port));
+    cfg->frame_size = ssi_inl(base, SSI_SST_FRAMESIZE_REG(port));
+    cfg->channels = ssi_inl(base, SSI_SST_CHANNELS_REG(port));
+    cfg->divisor = ssi_inl(base, SSI_SST_DIVISOR_REG(port));
+    cfg->arb_mode = ssi_inl(base, SSI_SST_ARBMODE_REG(port));
+}
+
 /**
  * ssi_open - open a ssi device channel.
  * @dev - Reference to the ssi device channel to be openned.
@@ -225,6 +346,38 @@ void ssi_read_cancel(struct ssi_device *
 EXPORT_SYMBOL(ssi_read_cancel);
 
 /**
+ * ssi_poll - SSI poll
+ * @dev - ssi device channel reference to apply the I/O control
+ * 						(or port associated to it)
+ *
+ * Return 0 on sucess, a negative value on failure.
+ *
+ */
+int ssi_poll(struct ssi_device *dev)
+{
+	struct ssi_channel *ch;
+	int err;
+
+	if (unlikely(!dev || !dev->ch))
+		return -EINVAL;
+
+	if (unlikely(!(dev->ch->flags & SSI_CH_OPEN))) {
+		dev_err(&dev->device, "SSI device NOT open\n");
+		return -EINVAL;
+	}
+
+	ch = dev->ch;
+	spin_lock_bh(&ch->ssi_port->ssi_controller->lock);
+	ch->flags |= SSI_CH_RX_POLL;
+	err = ssi_driver_read_interrupt(ch, NULL);
+	spin_unlock_bh(&ch->ssi_port->ssi_controller->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(ssi_poll);
+
+
+/**
  * ssi_ioctl - SSI I/O control
  * @dev - ssi device channel reference to apply the I/O control
  * 						(or port associated to it)
@@ -305,6 +458,33 @@ int ssi_ioctl(struct ssi_device *dev, un
 		}
 		*(unsigned int *)arg = ssi_cawake(dev->ch->ssi_port);
 		break;
+	case SSI_IOCTL_SET_RX:
+		if (!arg) {
+			err = -EINVAL;
+			goto out;
+		}
+		err = ssi_set_rx(dev->ch->ssi_port, (struct ssr_ctx *)arg);
+		break;
+	case SSI_IOCTL_GET_RX:
+		if (!arg) {
+			err = -EINVAL;
+			goto out;
+		}
+		ssi_get_rx(dev->ch->ssi_port, (struct ssr_ctx *)arg);
+		break;
+	case SSI_IOCTL_SET_TX:
+		if (!arg) {
+			err = -EINVAL;
+			goto out;
+		}
+		err = ssi_set_tx(dev->ch->ssi_port, (struct sst_ctx *)arg);
+		break;
+	case SSI_IOCTL_GET_TX:
+		if (!arg) {
+			err = -EINVAL;
+			goto out;
+		}
+		ssi_get_tx(dev->ch->ssi_port, (struct sst_ctx *)arg);
 	case SSI_IOCTL_TX_CH_FULL:
 		if (!arg) {
 			err = -EINVAL;
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi/ssi_driver_int.c kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi/ssi_driver_int.c
--- kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi/ssi_driver_int.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi/ssi_driver_int.c	2011-09-04 11:37:54.000000000 +0200
@@ -25,9 +25,19 @@
 
 void ssi_reset_ch_read(struct ssi_channel *ch)
 {
+	struct ssi_port *p = ch->ssi_port;
+	struct ssi_dev *ssi_ctrl = p->ssi_controller;
+	unsigned int channel = ch->channel_number;
+	void __iomem *base = ssi_ctrl->base;
+	unsigned int port = p->port_number;
+	unsigned int irq = p->n_irq;
+
 	ch->read_data.addr = NULL;
 	ch->read_data.size = 0;
 	ch->read_data.lch = -1;
+
+	ssi_outl(SSI_SSR_DATAAVAILABLE(channel), base,
+			SSI_SYS_MPU_STATUS_REG(port, irq));
 }
 
 void ssi_reset_ch_write(struct ssi_channel *ch)
@@ -145,6 +155,8 @@ static void do_channel_rx(struct ssi_cha
 	unsigned int n_ch;
 	unsigned int n_p;
 	unsigned int irq;
+	int rx_poll = 0;
+	int data_read = 0;
 
 	n_ch = ch->channel_number;
 	n_p = ch->ssi_port->port_number;
@@ -152,7 +164,14 @@ static void do_channel_rx(struct ssi_cha
 
 	spin_lock(&ssi_ctrl->lock);
 
-	*(ch->read_data.addr) = ssi_inl(base, SSI_SSR_BUFFER_CH_REG(n_p, n_ch));
+	if (ch->flags & SSI_CH_RX_POLL)
+		rx_poll = 1;
+
+	if (ch->read_data.addr) {
+		data_read = 1;
+		*(ch->read_data.addr) = ssi_inl(base,
+						SSI_SSR_BUFFER_CH_REG(n_p, n_ch));
+	}
 
 	ssi_outl_and(~SSI_SSR_DATAAVAILABLE(n_ch), base,
 					SSI_SYS_MPU_ENABLE_REG(n_p, irq));
@@ -160,7 +179,13 @@ static void do_channel_rx(struct ssi_cha
 
 	spin_unlock(&ssi_ctrl->lock);
 
-	(*ch->read_done)(ch->dev);
+	if (rx_poll)
+		ssi_port_event_handler(ch->ssi_port,
+					SSI_EVENT_SSR_DATAAVAILABLE,
+					(void *)n_ch);
+
+	if (data_read)
+		(*ch->read_done)(ch->dev);
 }
 
 static void do_ssi_tasklet(unsigned long ssi_port)
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi-char/Kconfig kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi-char/Kconfig
--- kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi-char/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi-char/Kconfig	2011-09-04 11:37:54.000000000 +0200
@@ -0,0 +1,18 @@
+#
+# OMAP SSI kernel configuration
+#
+
+config SSI_CHAR
+	tristate "SSI character driver"
+	depends on OMAP_SSI
+	---help---
+	  If you say Y here, you will enable the CMT character driver.
+	  This driver provides a simple character device interface for
+	  serial communication with the cellular modem over the SSI bus.
+
+config SSI_CHAR_DEBUG
+	bool "Debug CMT character driver"
+	depends on SSI_CHAR && DEBUG_KERNEL
+	default n
+	---help---
+	  Enable the debug information in the CMT character driver.
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi-char/Makefile kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi-char/Makefile
--- kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi-char/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi-char/Makefile	2011-09-04 11:37:54.000000000 +0200
@@ -0,0 +1,8 @@
+#
+# Makefile for SSI CHAR driver
+#
+#EXTRA_CFLAGS := -I$(src)/../../../include
+
+obj-$(CONFIG_SSI_CHAR)	+= ssi_char.o
+
+ssi_char-objs	:= ssi-char.o ssi-if.o
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi-char/ssi-char.c kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi-char/ssi-char.c
--- kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi-char/ssi-char.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi-char/ssi-char.c	2011-09-04 11:37:54.000000000 +0200
@@ -0,0 +1,493 @@
+/*
+ * ssi-char.c
+ *
+ * SSI character device driver, implements the character device
+ * interface.
+ *
+ * Copyright (C) 2009 Nokia Corporation. All rights reserved.
+ *
+ * Contact: Andras Domokos <andras.domokos@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/miscdevice.h>
+#include <linux/file.h>
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/poll.h>
+#include <asm/mach-types.h>
+#include <linux/ioctl.h>
+#include <linux/uaccess.h>
+
+#include <mach/ssi.h>
+#include <linux/ssi_driver_if.h>
+#include <linux/ssi_char.h>
+
+#include "ssi-char-debug.h"
+#include "ssi-char.h"
+
+#define DRIVER_VERSION  "0.1.0"
+
+static unsigned int port = 1;
+module_param(port, uint, 1);
+MODULE_PARM_DESC(port, "SSI port to be probed");
+
+static unsigned int channels_map[SSI_MAX_CHAR_DEVS] = {1};
+module_param_array(channels_map, uint, NULL, 0);
+MODULE_PARM_DESC(channels_map, "SSI channels to be probed");
+
+dev_t ssi_char_dev;
+
+struct char_queue {
+	struct list_head list;
+	u32 *data;
+	unsigned int count;
+};
+
+struct ssi_char {
+	unsigned int opened;
+	int poll_event;
+	struct list_head rx_queue;
+	struct list_head tx_queue;
+	spinlock_t lock;
+	struct fasync_struct *async_queue;
+	wait_queue_head_t rx_wait;
+	wait_queue_head_t tx_wait;
+	wait_queue_head_t poll_wait;
+};
+
+static struct ssi_char ssi_char_data[SSI_MAX_CHAR_DEVS];
+
+void if_notify(int ch, struct ssi_event *ev)
+{
+	struct char_queue *entry;
+
+	spin_lock(&ssi_char_data[ch].lock);
+
+	if (!ssi_char_data[ch].opened) {
+		printk(KERN_DEBUG "device not opened\n!");
+		spin_unlock(&ssi_char_data[ch].lock);
+		return;
+	}
+
+	switch (SSI_EV_TYPE(ev->event)) {
+	case SSI_EV_IN:
+		entry = kmalloc(sizeof(*entry), GFP_ATOMIC);
+		if (!entry) {
+			pr_err("SSI-CHAR: entry allocation failed.\n");
+			spin_unlock(&ssi_char_data[ch].lock);
+			return;
+		}
+		entry->data = ev->data;
+		entry->count = ev->count;
+		list_add_tail(&entry->list, &ssi_char_data[ch].rx_queue);
+		spin_unlock(&ssi_char_data[ch].lock);
+		wake_up_interruptible(&ssi_char_data[ch].rx_wait);
+		break;
+	case SSI_EV_OUT:
+		entry = kmalloc(sizeof(*entry), GFP_ATOMIC);
+		if (!entry) {
+			pr_err("SSI-CHAR: entry allocation failed.\n");
+			spin_unlock(&ssi_char_data[ch].lock);
+			return;
+		}
+		entry->data = ev->data;
+		entry->count = ev->count;
+		ssi_char_data[ch].poll_event |= (POLLOUT | POLLWRNORM);
+		list_add_tail(&entry->list, &ssi_char_data[ch].tx_queue);
+		spin_unlock(&ssi_char_data[ch].lock);
+		wake_up_interruptible(&ssi_char_data[ch].tx_wait);
+		break;
+	case SSI_EV_EXCEP:
+		ssi_char_data[ch].poll_event |= POLLPRI;
+		spin_unlock(&ssi_char_data[ch].lock);
+		wake_up_interruptible(&ssi_char_data[ch].poll_wait);
+		break;
+	case SSI_EV_AVAIL:
+		ssi_char_data[ch].poll_event |= (POLLIN | POLLRDNORM);
+		spin_unlock(&ssi_char_data[ch].lock);
+		wake_up_interruptible(&ssi_char_data[ch].poll_wait);
+		break;
+	default:
+		spin_unlock(&ssi_char_data[ch].lock);
+		break;
+	}
+}
+
+
+static int ssi_char_fasync(int fd, struct file *file, int on)
+{
+	int ch = (int)file->private_data;
+	if (fasync_helper(fd, file, on, &ssi_char_data[ch].async_queue) >= 0)
+		return 0;
+	else
+		return -EIO;
+}
+
+
+static unsigned int ssi_char_poll(struct file *file, poll_table *wait)
+{
+	int ch = (int)file->private_data;
+	unsigned int ret = 0;
+
+	poll_wait(file, &ssi_char_data[ch].poll_wait, wait);
+	poll_wait(file, &ssi_char_data[ch].tx_wait, wait);
+	spin_lock_bh(&ssi_char_data[ch].lock);
+	ret = ssi_char_data[ch].poll_event;
+	spin_unlock_bh(&ssi_char_data[ch].lock);
+
+	return ret;
+}
+
+
+static ssize_t ssi_char_read(struct file *file, char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	int ch = (int)file->private_data;
+	DECLARE_WAITQUEUE(wait, current);
+	u32 *data;
+	unsigned int data_len;
+	struct char_queue *entry;
+	ssize_t ret;
+
+	/* only 32bit data is supported for now */
+	if ((count < 4) || (count & 3))
+		return -EINVAL;
+
+	data = kmalloc(count, GFP_ATOMIC);
+
+	ret = if_ssi_read(ch, data, count);
+	if (ret < 0) {
+		kfree(data);
+		goto out2;
+	}
+
+	add_wait_queue(&ssi_char_data[ch].rx_wait, &wait);
+
+	for ( ; ; ) {
+		data = NULL;
+		data_len = 0;
+
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		spin_lock_bh(&ssi_char_data[ch].lock);
+		if (!list_empty(&ssi_char_data[ch].rx_queue)) {
+			entry = list_entry(ssi_char_data[ch].rx_queue.next,
+					struct char_queue, list);
+			data = entry->data;
+			data_len = entry->count;
+			list_del(&entry->list);
+			kfree(entry);
+		}
+		spin_unlock_bh(&ssi_char_data[ch].lock);
+
+		if (data_len) {
+			spin_lock_bh(&ssi_char_data[ch].lock);
+			ssi_char_data[ch].poll_event &= ~(POLLIN | POLLRDNORM |
+								POLLPRI);
+			if_ssi_poll(ch);
+			spin_unlock_bh(&ssi_char_data[ch].lock);
+			break;
+		} else if (file->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+			goto out;
+		} else if (signal_pending(current)) {
+			ret = -EAGAIN;
+			if_ssi_cancel_read(ch);
+			break;
+		}
+
+		schedule();
+	}
+
+	if (data_len) {
+		ret = copy_to_user((void __user *)buf, data, data_len);
+		if (!ret)
+			ret = data_len;
+	}
+
+	kfree(data);
+
+out:
+	__set_current_state(TASK_RUNNING);
+	remove_wait_queue(&ssi_char_data[ch].rx_wait, &wait);
+
+out2:
+	return ret;
+}
+
+static ssize_t ssi_char_write(struct file *file, const char __user *buf,
+			 size_t count, loff_t *ppos)
+{
+	int ch = (int)file->private_data;
+	DECLARE_WAITQUEUE(wait, current);
+	u32 *data;
+	unsigned int data_len = 0;
+	struct char_queue *entry;
+	ssize_t ret;
+
+	/* only 32bit data is supported for now */
+	if ((count < 4) || (count & 3))
+		return -EINVAL;
+
+	data = kmalloc(count, GFP_ATOMIC);
+
+	if (copy_from_user(data, (void __user *)buf, count)) {
+		ret = -EFAULT;
+		kfree(data);
+	} else {
+		ret = count;
+	}
+
+	spin_lock_bh(&ssi_char_data[ch].lock);
+	ret = if_ssi_write(ch, data, count);
+	if (ret < 0) {
+		spin_unlock_bh(&ssi_char_data[ch].lock);
+		kfree(data);
+		goto out2;
+	}
+	ssi_char_data[ch].poll_event &= ~(POLLOUT | POLLWRNORM);
+	spin_unlock_bh(&ssi_char_data[ch].lock);
+
+	add_wait_queue(&ssi_char_data[ch].tx_wait, &wait);
+
+	for ( ; ; ) {
+		data = NULL;
+		data_len = 0;
+
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		spin_lock_bh(&ssi_char_data[ch].lock);
+		if (!list_empty(&ssi_char_data[ch].tx_queue)) {
+			entry = list_entry(ssi_char_data[ch].tx_queue.next,
+					struct char_queue, list);
+			data = entry->data;
+			data_len = entry->count;
+			list_del(&entry->list);
+			kfree(entry);
+		}
+		spin_unlock_bh(&ssi_char_data[ch].lock);
+
+		if (data_len) {
+			ret = data_len;
+			break;
+		} else if (file->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+			goto out;
+		} else if (signal_pending(current)) {
+			ret = -ERESTARTSYS;
+			goto out;
+		}
+
+		schedule();
+	}
+
+    kfree(data);
+
+out:
+	__set_current_state(TASK_RUNNING);
+	remove_wait_queue(&ssi_char_data[ch].tx_wait, &wait);
+
+out2:
+	return ret;
+}
+
+static int ssi_char_ioctl(struct inode *inode, struct file *file,
+				unsigned int cmd, unsigned long arg)
+{
+	int ch = (int)file->private_data;
+	unsigned int state;
+	struct ssi_rx_config rx_cfg;
+	struct ssi_tx_config tx_cfg;
+	int ret = 0;
+
+	switch (cmd) {
+	case CS_SEND_BREAK:
+		if_ssi_send_break(ch);
+	break;
+	case CS_FLUSH_RX:
+		if_ssi_flush_rx(ch);
+	break;
+	case CS_FLUSH_TX:
+		if_ssi_flush_tx(ch);
+	break;
+	case CS_SET_WAKELINE:
+		if (copy_from_user(&state, (void __user *)arg,
+				sizeof(state)))
+			ret = -EFAULT;
+		else
+			if_ssi_set_wakeline(ch, state);
+	break;
+	case CS_GET_WAKELINE:
+		if_ssi_get_wakeline(ch, &state);
+		if (copy_to_user((void __user *)arg, &state, sizeof(state)))
+			ret = -EFAULT;
+	break;
+	case CS_SET_RX: {
+		if (copy_from_user(&rx_cfg, (void __user *)arg,
+				sizeof(rx_cfg)))
+			ret = -EFAULT;
+		else
+			ret = if_ssi_set_rx(ch, &rx_cfg);
+	}
+		break;
+	case CS_GET_RX:
+		if_ssi_get_rx(ch, &rx_cfg);
+		if (copy_to_user((void __user *)arg, &rx_cfg, sizeof(rx_cfg)))
+			ret = -EFAULT;
+	break;
+	case CS_SET_TX:
+		if (copy_from_user(&tx_cfg, (void __user *)arg,
+				sizeof(tx_cfg)))
+			ret = -EFAULT;
+		else
+			ret = if_ssi_set_tx(ch, &tx_cfg);
+	break;
+	case CS_GET_TX:
+		if_ssi_get_tx(ch, &tx_cfg);
+		if (copy_to_user((void __user *)arg, &tx_cfg, sizeof(tx_cfg)))
+			ret = -EFAULT;
+	break;
+	default:
+		return -ENOIOCTLCMD;
+	break;
+	}
+
+	return ret;
+}
+
+static int ssi_char_open(struct inode *inode, struct file *file)
+{
+	int ret = 0, ch = iminor(inode);
+
+	if (!channels_map[ch])
+		return -ENODEV;
+
+	spin_lock_bh(&ssi_char_data[ch].lock);
+#if 0
+	if (ssi_char_data[ch].opened) {
+		spin_unlock_bh(&ssi_char_data[ch].lock);
+		return -EBUSY;
+	}
+#endif
+	file->private_data = (void *)ch;
+	ssi_char_data[ch].opened++;
+	ssi_char_data[ch].poll_event = (POLLOUT | POLLWRNORM);
+	spin_unlock_bh(&ssi_char_data[ch].lock);
+
+	ret = if_ssi_start(ch);
+
+	return ret;
+}
+
+static int ssi_char_release(struct inode *inode, struct file *file)
+{
+	int ch = (int)file->private_data;
+	struct char_queue	*entry;
+	struct list_head	*cursor, *next;
+
+	if_ssi_stop(ch);
+	spin_lock_bh(&ssi_char_data[ch].lock);
+	ssi_char_data[ch].opened--;
+
+	if (!list_empty(&ssi_char_data[ch].rx_queue)) {
+		list_for_each_safe(cursor, next, &ssi_char_data[ch].rx_queue) {
+			entry = list_entry(cursor, struct char_queue, list);
+			list_del(&entry->list);
+			kfree(entry);
+		}
+	}
+
+	if (!list_empty(&ssi_char_data[ch].tx_queue)) {
+		list_for_each_safe(cursor, next, &ssi_char_data[ch].tx_queue) {
+			entry = list_entry(cursor, struct char_queue, list);
+			list_del(&entry->list);
+			kfree(entry);
+		}
+	}
+
+	spin_unlock_bh(&ssi_char_data[ch].lock);
+
+	return 0;
+}
+
+static const struct file_operations ssi_char_fops = {
+	.owner = THIS_MODULE,
+	.read = ssi_char_read,
+	.write = ssi_char_write,
+	.poll = ssi_char_poll,
+	.ioctl = ssi_char_ioctl,
+	.open = ssi_char_open,
+	.release = ssi_char_release,
+	.fasync = ssi_char_fasync,
+};
+
+static struct cdev ssi_char_cdev;
+
+static int __init ssi_char_init(void)
+{
+	char devname[] = "ssi_char";
+	int ret, i;
+
+	pr_info("SSI character device version " DRIVER_VERSION "\n");
+
+	for (i = 0; i < SSI_MAX_CHAR_DEVS; i++) {
+		init_waitqueue_head(&ssi_char_data[i].rx_wait);
+		init_waitqueue_head(&ssi_char_data[i].tx_wait);
+		init_waitqueue_head(&ssi_char_data[i].poll_wait);
+		spin_lock_init(&ssi_char_data[i].lock);
+		ssi_char_data[i].opened = 0;
+		INIT_LIST_HEAD(&ssi_char_data[i].rx_queue);
+		INIT_LIST_HEAD(&ssi_char_data[i].tx_queue);
+	}
+
+	ret = if_ssi_init(port, channels_map);
+	if (ret)
+		return ret;
+
+	ret = alloc_chrdev_region(&ssi_char_dev, 0, SSI_MAX_CHAR_DEVS, devname);
+	if (ret < 0) {
+		pr_err("SSI character driver: Failed to register\n");
+		return ret;
+	}
+
+	cdev_init(&ssi_char_cdev, &ssi_char_fops);
+	cdev_add(&ssi_char_cdev, ssi_char_dev, SSI_MAX_CHAR_DEVS);
+
+	return 0;
+}
+
+static void __exit ssi_char_exit(void)
+{
+	cdev_del(&ssi_char_cdev);
+	unregister_chrdev_region(ssi_char_dev, SSI_MAX_CHAR_DEVS);
+	if_ssi_exit();
+}
+
+MODULE_AUTHOR("Andras Domokos <andras.domokos@nokia.com>");
+MODULE_DESCRIPTION("SSI character device");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
+
+module_init(ssi_char_init);
+module_exit(ssi_char_exit);
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi-char/ssi-char-debug.h kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi-char/ssi-char-debug.h
--- kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi-char/ssi-char-debug.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi-char/ssi-char-debug.h	2011-09-04 11:37:54.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+ * ssi-char-debug.h
+ *
+ * Part of the SSI character driver. Debugging related definitions.
+ *
+ * Copyright (C) 2009 Nokia Corporation. All rights reserved.
+ *
+ * Contact: Andras Domokos <andras.domokos@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+
+#ifndef _SSI_CHAR_DEBUG_H
+#define _SSI_CHAR_DEBUG_H
+
+#ifdef CONFIG_SSI_CHAR_DEBUG
+#define DPRINTK(fmt, arg...) printk(KERN_DEBUG "%s(): " fmt, __func__, ##arg)
+#define DENTER()	printk(KERN_DEBUG "ENTER %s()\n", __func__)
+#define DLEAVE(a)	printk(KERN_DEBUG "LEAVE %s() %d\n", __func__, a)
+#else
+#define DPRINTK(fmt, arg...)	while (0)
+#define DENTER()		while (0)
+#define DLEAVE(a)		while (0)
+#endif
+
+#endif /* _SSI_CHAR_DEBUG_H */
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi-char/ssi-char.h kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi-char/ssi-char.h
--- kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi-char/ssi-char.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi-char/ssi-char.h	2011-09-04 11:37:54.000000000 +0200
@@ -0,0 +1,36 @@
+/*
+ * ssi-char.h
+ *
+ * Part of the SSI character device driver.
+ *
+ * Copyright (C) 2009 Nokia Corporation. All rights reserved.
+ *
+ * Contact: Andras Domokos <andras.domokos@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+
+#ifndef _SSI_CHAR_H
+#define _SSI_CHAR_H
+
+#include "ssi-if.h"
+
+/* how many char devices would be created at most */
+#define SSI_MAX_CHAR_DEVS	8
+
+void if_notify(int ch, struct ssi_event *ev);
+
+#endif /* _SSI_CHAR_H */
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi-char/ssi-if.c kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi-char/ssi-if.c
--- kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi-char/ssi-if.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi-char/ssi-if.c	2011-09-04 11:37:54.000000000 +0200
@@ -0,0 +1,625 @@
+/*
+ * ssi-if.c
+ *
+ * Part of the SSI character driver, implements the SSI interface.
+ *
+ * Copyright (C) 2009 Nokia Corporation. All rights reserved.
+ *
+ * Contact: Andras Domokos <andras.domokos@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <asm/mach-types.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/ktime.h>
+#include <linux/bitmap.h>
+
+#include <linux/ssi_driver_if.h>
+#include <linux/ssi_char.h>
+
+#include "ssi-char-debug.h"
+#include "ssi-char.h"
+#include "ssi-if.h"
+
+#define SSI_CHANNEL_STATE_UNAVAIL	(1 << 0)
+#define SSI_CHANNEL_STATE_READING	(1 << 1)
+#define SSI_CHANNEL_STATE_WRITING	(1 << 2)
+
+#define PORT1	0
+#define PORT2	1
+
+#define SSI_RX_PARAM(cfg, mod, fsize, n, tmo) \
+	do { \
+		(cfg)->mode = mod; \
+		(cfg)->frame_size = fsize; \
+		(cfg)->channels = n; \
+		(cfg)->timeout = tmo; \
+	} while (0)
+
+#define SSI_TX_PARAM(cfg, mod, fsize, n, div, arb) \
+	do { \
+		(cfg)->mode = mod; \
+		(cfg)->frame_size = fsize; \
+		(cfg)->channels = n; \
+		(cfg)->divisor = div; \
+		(cfg)->arb_mode = arb; \
+	} while (0)
+
+#define RXCONV(dst, src) \
+	do { \
+		(dst)->mode = (src)->mode; \
+		(dst)->frame_size = (src)->frame_size; \
+		(dst)->channels = (src)->channels; \
+		(dst)->timeout = (src)->timeout; \
+	} while (0)
+
+#define TXCONV(dst, src) \
+	do { \
+		(dst)->mode = (src)->mode; \
+		(dst)->frame_size = (src)->frame_size; \
+		(dst)->channels = (src)->channels; \
+		(dst)->divisor = (src)->divisor; \
+		(dst)->arb_mode = (src)->arb_mode; \
+	} while (0)
+
+struct if_ssi_channel {
+	struct ssi_device *dev;
+	unsigned int channel_id;
+	u32 *tx_data;
+	unsigned int tx_count;
+	u32 *rx_data;
+	unsigned int rx_count;
+	unsigned int opened;
+	unsigned int state;
+	spinlock_t lock;
+};
+
+struct if_ssi_iface {
+	struct if_ssi_channel channels[SSI_MAX_CHAR_DEVS];
+	int bootstrap;
+	spinlock_t lock;
+};
+
+static void if_ssi_port_event(struct ssi_device *dev, unsigned int event,
+				void *arg);
+static int __devinit if_ssi_probe(struct ssi_device *dev);
+static int __devexit if_ssi_remove(struct ssi_device *dev);
+
+static struct ssi_device_driver if_ssi_char_driver = {
+	.ctrl_mask = ANY_SSI_CONTROLLER,
+	.probe = if_ssi_probe,
+	.remove = __devexit_p(if_ssi_remove),
+	.driver = {
+		.name = "ssi_char"
+	},
+};
+
+static struct if_ssi_iface ssi_iface;
+
+static int if_ssi_read_on(int ch, u32 *data, unsigned int count)
+{
+	struct if_ssi_channel *channel;
+	int ret;
+
+	channel = &ssi_iface.channels[ch];
+
+	spin_lock(&channel->lock);
+	if (channel->state & SSI_CHANNEL_STATE_READING) {
+		pr_err("Read still pending on channel %d\n", ch);
+		spin_unlock(&channel->lock);
+		return -EBUSY;
+	}
+	channel->state |= SSI_CHANNEL_STATE_READING;
+	channel->rx_data = data;
+	channel->rx_count = count;
+	spin_unlock(&channel->lock);
+
+	ret = ssi_read(channel->dev, data, count/4);
+
+	return ret;
+}
+
+static void if_ssi_read_done(struct ssi_device *dev)
+{
+	struct if_ssi_channel *channel;
+	struct ssi_event ev;
+
+	channel = &ssi_iface.channels[dev->n_ch];
+	spin_lock(&channel->lock);
+	channel->state &= ~SSI_CHANNEL_STATE_READING;
+	ev.event = SSI_EV_IN;
+	ev.data = channel->rx_data;
+	ev.count = channel->rx_count;
+	spin_unlock(&channel->lock);
+	if_notify(dev->n_ch, &ev);
+}
+
+int if_ssi_read(int ch, u32 *data, unsigned int count)
+{
+	int ret = 0;
+	spin_lock_bh(&ssi_iface.lock);
+	ret = if_ssi_read_on(ch, data, count);
+	spin_unlock_bh(&ssi_iface.lock);
+	return ret;
+}
+
+int if_ssi_poll(int ch)
+{
+	struct if_ssi_channel *channel;
+	int ret = 0;
+	channel = &ssi_iface.channels[ch];
+	spin_lock_bh(&ssi_iface.lock);
+	ret = ssi_poll(channel->dev);
+	spin_unlock_bh(&ssi_iface.lock);
+	return ret;
+}
+
+static int if_ssi_write_on(int ch, u32 *address, unsigned int count)
+{
+	struct if_ssi_channel *channel;
+	int ret;
+
+	channel = &ssi_iface.channels[ch];
+
+	spin_lock(&channel->lock);
+	if (channel->state & SSI_CHANNEL_STATE_WRITING) {
+		pr_err("Write still pending on channel %d\n", ch);
+		spin_unlock(&channel->lock);
+		return -EBUSY;
+	}
+
+	channel->tx_data = address;
+	channel->tx_count = count;
+	channel->state |= SSI_CHANNEL_STATE_WRITING;
+	spin_unlock(&channel->lock);
+	ret = ssi_write(channel->dev, address, count/4);
+	return ret;
+}
+
+static void if_ssi_write_done(struct ssi_device *dev)
+{
+	struct if_ssi_channel *channel;
+	struct ssi_event ev;
+
+	channel = &ssi_iface.channels[dev->n_ch];
+
+	spin_lock(&channel->lock);
+	channel->state &= ~SSI_CHANNEL_STATE_WRITING;
+	ev.event = SSI_EV_OUT;
+	ev.data = channel->tx_data;
+	ev.count = channel->tx_count;
+	spin_unlock(&channel->lock);
+	if_notify(dev->n_ch, &ev);
+}
+
+int if_ssi_write(int ch, u32 *data, unsigned int count)
+{
+	int ret = 0;
+
+	spin_lock_bh(&ssi_iface.lock);
+	ret = if_ssi_write_on(ch, data, count);
+	spin_unlock_bh(&ssi_iface.lock);
+	return ret;
+}
+
+void if_ssi_send_break(int ch)
+{
+	struct if_ssi_channel *channel;
+
+	channel = &ssi_iface.channels[ch];
+	spin_lock_bh(&ssi_iface.lock);
+	ssi_ioctl(channel->dev, SSI_IOCTL_SEND_BREAK, NULL);
+	spin_unlock_bh(&ssi_iface.lock);
+}
+
+void if_ssi_flush_rx(int ch)
+{
+	struct if_ssi_channel *channel;
+
+	channel = &ssi_iface.channels[ch];
+	spin_lock_bh(&ssi_iface.lock);
+	ssi_ioctl(channel->dev, SSI_IOCTL_FLUSH_RX, NULL);
+	spin_unlock_bh(&ssi_iface.lock);
+}
+
+void if_ssi_flush_ch(int ch)
+{
+	struct if_ssi_channel *channel;
+
+	channel = &ssi_iface.channels[ch];
+	spin_lock(&channel->lock);
+	spin_unlock(&channel->lock);
+}
+
+void if_ssi_flush_tx(int ch)
+{
+	struct if_ssi_channel *channel;
+
+	channel = &ssi_iface.channels[ch];
+	spin_lock_bh(&ssi_iface.lock);
+	ssi_ioctl(channel->dev, SSI_IOCTL_FLUSH_TX, NULL);
+	spin_unlock_bh(&ssi_iface.lock);
+}
+
+void if_ssi_get_wakeline(int ch, unsigned int *state)
+{
+	struct if_ssi_channel *channel;
+
+	channel = &ssi_iface.channels[ch];
+	spin_lock_bh(&ssi_iface.lock);
+	ssi_ioctl(channel->dev, SSI_IOCTL_WAKE, state);
+	spin_unlock_bh(&ssi_iface.lock);
+}
+
+void if_ssi_set_wakeline(int ch, unsigned int state)
+{
+	struct if_ssi_channel *channel;
+
+	channel = &ssi_iface.channels[ch];
+	spin_lock_bh(&ssi_iface.lock);
+	ssi_ioctl(channel->dev, state, NULL);
+	spin_unlock_bh(&ssi_iface.lock);
+}
+
+int if_ssi_set_rx(int ch, struct ssi_rx_config *cfg)
+{
+	int ret;
+	struct if_ssi_channel *channel;
+	struct ssr_ctx ctx;
+
+	RXCONV(&ctx, cfg);
+	channel = &ssi_iface.channels[ch];
+	spin_lock_bh(&ssi_iface.lock);
+	ret = ssi_ioctl(channel->dev, SSI_IOCTL_SET_RX, &ctx);
+	spin_unlock_bh(&ssi_iface.lock);
+	return ret;
+}
+
+void if_ssi_get_rx(int ch, struct ssi_rx_config *cfg)
+{
+	struct if_ssi_channel *channel;
+	struct ssr_ctx ctx;
+
+	channel = &ssi_iface.channels[ch];
+	spin_lock_bh(&ssi_iface.lock);
+	ssi_ioctl(channel->dev, SSI_IOCTL_GET_RX, &ctx);
+	RXCONV(cfg, &ctx);
+	spin_unlock_bh(&ssi_iface.lock);
+}
+
+int if_ssi_set_tx(int ch, struct ssi_tx_config *cfg)
+{
+	int ret;
+	struct if_ssi_channel *channel;
+	struct sst_ctx ctx;
+
+	TXCONV(&ctx, cfg);
+	channel = &ssi_iface.channels[ch];
+	spin_lock_bh(&ssi_iface.lock);
+	ret = ssi_ioctl(channel->dev, SSI_IOCTL_SET_TX, &ctx);
+	spin_unlock_bh(&ssi_iface.lock);
+	return ret;
+}
+
+void if_ssi_get_tx(int ch, struct ssi_tx_config *cfg)
+{
+	struct if_ssi_channel *channel;
+	struct sst_ctx ctx;
+
+	channel = &ssi_iface.channels[ch];
+	spin_lock_bh(&ssi_iface.lock);
+	ssi_ioctl(channel->dev, SSI_IOCTL_GET_TX, &ctx);
+	TXCONV(cfg, &ctx);
+	spin_unlock_bh(&ssi_iface.lock);
+}
+
+void if_ssi_cancel_read(int ch)
+{
+	struct if_ssi_channel *channel;
+
+	channel = &ssi_iface.channels[ch];
+	spin_lock(&channel->lock);
+	if (channel->state & SSI_CHANNEL_STATE_READING)
+		ssi_read_cancel(channel->dev);
+	channel->state &= ~SSI_CHANNEL_STATE_READING;
+	spin_unlock(&channel->lock);
+}
+
+void if_ssi_cancel_write(int ch)
+{
+	struct if_ssi_channel *channel;
+
+	channel = &ssi_iface.channels[ch];
+	spin_lock(&channel->lock);
+	if (channel->state & SSI_CHANNEL_STATE_WRITING)
+		ssi_write_cancel(channel->dev);
+	channel->state &= ~SSI_CHANNEL_STATE_WRITING;
+	spin_unlock(&channel->lock);
+}
+
+static int if_ssi_openchannel(struct if_ssi_channel *channel)
+{
+	int ret = 0;
+
+	spin_lock(&channel->lock);
+
+	if (channel->state == SSI_CHANNEL_STATE_UNAVAIL)
+		return -ENODEV;
+
+	if (channel->opened) {
+		ret = -EBUSY;
+		goto leave;
+	}
+
+	if (!channel->dev) {
+		pr_err("Channel %d is not ready??\n",
+				channel->channel_id);
+		ret = -ENODEV;
+		goto leave;
+	}
+
+	ret = ssi_open(channel->dev);
+	if (ret < 0) {
+		pr_err("Could not open channel %d\n",
+				channel->channel_id);
+		goto leave;
+	}
+
+	channel->opened = 1;
+
+leave:
+	spin_unlock(&channel->lock);
+	return ret;
+}
+
+
+static int if_ssi_closechannel(struct if_ssi_channel *channel)
+{
+	int ret = 0;
+
+	spin_lock(&channel->lock);
+
+	if (!channel->opened)
+		goto leave;
+
+	if (!channel->dev) {
+		pr_err("Channel %d is not ready??\n",
+				channel->channel_id);
+		ret = -ENODEV;
+		goto leave;
+	}
+
+	/* Stop any pending read/write */
+	if (channel->state & SSI_CHANNEL_STATE_READING) {
+		ssi_read_cancel(channel->dev);
+		channel->state &= ~SSI_CHANNEL_STATE_READING;
+	}
+	if (channel->state & SSI_CHANNEL_STATE_WRITING) {
+		ssi_write_cancel(channel->dev);
+		channel->state &= ~SSI_CHANNEL_STATE_WRITING;
+	}
+
+	ssi_close(channel->dev);
+
+	channel->opened = 0;
+leave:
+	spin_unlock(&channel->lock);
+	return ret;
+}
+
+
+int if_ssi_start(int ch)
+{
+	struct if_ssi_channel *channel;
+	int ret = 0;
+
+	channel = &ssi_iface.channels[ch];
+	spin_lock_bh(&ssi_iface.lock);
+	channel->state = 0;
+	ret = if_ssi_openchannel(channel);
+	if (ret < 0) {
+		pr_err("Could not open channel %d\n", ch);
+		spin_unlock_bh(&ssi_iface.lock);
+		goto error;
+	}
+	if_ssi_poll(ch);
+	spin_unlock_bh(&ssi_iface.lock);
+
+error:
+	return ret;
+}
+
+void if_ssi_stop(int ch)
+{
+	struct if_ssi_channel *channel;
+	channel = &ssi_iface.channels[ch];
+	if_ssi_set_wakeline(ch, 1);
+	spin_lock_bh(&ssi_iface.lock);
+	if_ssi_closechannel(channel);
+	spin_unlock_bh(&ssi_iface.lock);
+}
+
+static int __devinit if_ssi_probe(struct ssi_device *dev)
+{
+	struct if_ssi_channel *channel;
+	unsigned long *address;
+	int ret = -ENXIO, port;
+
+	for (port = 0; port < SSI_MAX_PORTS; port++) {
+		if (if_ssi_char_driver.ch_mask[port])
+			break;
+	}
+
+	if (port == SSI_MAX_PORTS)
+		return -ENXIO;
+
+	address = &if_ssi_char_driver.ch_mask[port];
+
+	spin_lock_bh(&ssi_iface.lock);
+	if (test_bit(dev->n_ch, address) && (dev->n_p == port)) {
+		ssi_set_read_cb(dev, if_ssi_read_done);
+		ssi_set_write_cb(dev, if_ssi_write_done);
+		ssi_set_port_event_cb(dev, if_ssi_port_event);
+		channel = &ssi_iface.channels[dev->n_ch];
+		channel->dev = dev;
+		channel->state = 0;
+		ret = 0;
+	}
+	spin_unlock_bh(&ssi_iface.lock);
+
+	return ret;
+}
+
+static int __devexit if_ssi_remove(struct ssi_device *dev)
+{
+	struct if_ssi_channel *channel;
+	unsigned long *address;
+	int ret = -ENXIO, port;
+
+	for (port = 0; port < SSI_MAX_PORTS; port++) {
+		if (if_ssi_char_driver.ch_mask[port])
+			break;
+	}
+
+	if (port == SSI_MAX_PORTS)
+		return -ENXIO;
+
+	address = &if_ssi_char_driver.ch_mask[port];
+
+	spin_lock_bh(&ssi_iface.lock);
+	if (test_bit(dev->n_ch, address) && (dev->n_p == port)) {
+		ssi_set_read_cb(dev, NULL);
+		ssi_set_write_cb(dev, NULL);
+		channel = &ssi_iface.channels[dev->n_ch];
+		channel->dev = NULL;
+		channel->state = SSI_CHANNEL_STATE_UNAVAIL;
+		ret = 0;
+	}
+	spin_unlock_bh(&ssi_iface.lock);
+
+	return ret;
+}
+
+static void if_ssi_port_event(struct ssi_device *dev, unsigned int event,
+				void *arg)
+{
+	struct ssi_event ev;
+	int i;
+
+	ev.event = SSI_EV_EXCEP;
+	ev.data = (u32 *)0;
+	ev.count = 0;
+
+	switch (event) {
+	case SSI_EVENT_BREAK_DETECTED:
+		ev.data = (u32 *)SSI_HWBREAK;
+		spin_lock_bh(&ssi_iface.lock);
+		for (i = 0; i < SSI_MAX_CHAR_DEVS; i++) {
+			if (ssi_iface.channels[i].opened)
+				if_notify(i, &ev);
+		}
+		spin_unlock_bh(&ssi_iface.lock);
+		break;
+	case SSI_EVENT_SSR_DATAAVAILABLE:
+		i = (int)arg;
+		ev.event = SSI_EV_AVAIL;
+		spin_lock_bh(&ssi_iface.lock);
+		if (ssi_iface.channels[i].opened)
+			if_notify(i, &ev);
+		spin_unlock_bh(&ssi_iface.lock);
+		break;
+	case SSI_EVENT_CAWAKE_UP:
+		break;
+	case SSI_EVENT_CAWAKE_DOWN:
+		break;
+	case SSI_EVENT_ERROR:
+		break;
+	default:
+		printk(KERN_DEBUG "%s, Unknown event(%d)\n", __func__, event);
+		break;
+	}
+}
+
+int __init if_ssi_init(unsigned int port, unsigned int *channels_map)
+{
+	struct if_ssi_channel *channel;
+	int	i, ret = 0;
+
+	port -= 1;
+	if (port >= SSI_MAX_PORTS)
+		return -EINVAL;
+
+	ssi_iface.bootstrap = 1;
+	spin_lock_init(&ssi_iface.lock);
+
+	for (i = 0; i < SSI_MAX_PORTS; i++)
+		if_ssi_char_driver.ch_mask[i] = 0;
+
+	for (i = 0; i < SSI_MAX_CHAR_DEVS; i++) {
+		channel = &ssi_iface.channels[i];
+		channel->dev = NULL;
+		channel->opened = 0;
+		channel->state = 0;
+		channel->channel_id = i;
+		spin_lock_init(&channel->lock);
+		channel->state = SSI_CHANNEL_STATE_UNAVAIL;
+	}
+
+	for (i = 0; (i < SSI_MAX_CHAR_DEVS) && channels_map[i]; i++) {
+		if ((channels_map[i] - 1) < SSI_MAX_CHAR_DEVS)
+			if_ssi_char_driver.ch_mask[port] |= (1 << ((channels_map[i] - 1)));
+	}
+
+	ret = register_ssi_driver(&if_ssi_char_driver);
+	if (ret)
+		pr_err("Error while registering SSI driver %d", ret);
+
+	return ret;
+}
+
+int __exit if_ssi_exit(void)
+{
+	struct if_ssi_channel *channel;
+	unsigned long *address;
+	int i, port;
+
+	for (port = 0; port < SSI_MAX_PORTS; port++) {
+		if (if_ssi_char_driver.ch_mask[port])
+			break;
+	}
+
+	if (port == SSI_MAX_PORTS)
+		return -ENXIO;
+
+	address = &if_ssi_char_driver.ch_mask[port];
+
+	for (i = 0; i < SSI_MAX_CHAR_DEVS; i++) {
+		channel = &ssi_iface.channels[i];
+		if (channel->opened) {
+			if_ssi_set_wakeline(i, 1);
+			if_ssi_closechannel(channel);
+		}
+	}
+	unregister_ssi_driver(&if_ssi_char_driver);
+	return 0;
+}
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi-char/ssi-if.h kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi-char/ssi-if.h
--- kernel-2.6.28-20094102.6+0m5/drivers/misc/ssi-char/ssi-if.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20094803.3+0m5/drivers/misc/ssi-char/ssi-if.h	2011-09-04 11:37:54.000000000 +0200
@@ -0,0 +1,70 @@
+/*
+ * ssi-if.h
+ *
+ * Part of the SSI character driver.
+ *
+ * Copyright (C) 2009 Nokia Corporation. All rights reserved.
+ *
+ * Contact: Andras Domokos <andras.domokos@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+
+#ifndef _SSI_IF_H
+#define _SSI_IF_H
+
+#define SSI_EV_MASK		(0xffff << 0)
+#define SSI_EV_TYPE_MASK	(0x0f << 16)
+#define SSI_EV_IN		(0x01 << 16)
+#define SSI_EV_OUT		(0x02 << 16)
+#define SSI_EV_EXCEP		(0x03 << 16)
+#define SSI_EV_AVAIL		(0x04 << 16)
+#define SSI_EV_TYPE(event)	((event) & SSI_EV_TYPE_MASK)
+
+#define SSI_HWBREAK		1
+#define SSI_ERROR		2
+
+struct ssi_event {
+    unsigned int event;
+    u32 *data;
+    unsigned int count;
+};
+
+int if_ssi_init(unsigned int port, unsigned int *channels_map);
+int if_ssi_exit(void);
+
+int if_ssi_start(int ch);
+void if_ssi_stop(int ch);
+
+void if_ssi_send_break(int ch);
+void if_ssi_flush_rx(int ch);
+void if_ssi_flush_tx(int ch);
+void if_ssi_bootstrap(int ch);
+void if_ssi_set_wakeline(int ch, unsigned int state);
+void if_ssi_get_wakeline(int ch, unsigned int *state);
+int if_ssi_set_rx(int ch, struct ssi_rx_config *cfg);
+void if_ssi_get_rx(int ch, struct ssi_rx_config *cfg);
+int if_ssi_set_tx(int ch, struct ssi_tx_config *cfg);
+void if_ssi_get_tx(int ch, struct ssi_tx_config *cfg);
+
+int if_ssi_read(int ch, u32 *data, unsigned int count);
+int if_ssi_poll(int ch);
+int if_ssi_write(int ch, u32 *data, unsigned int count);
+
+void if_ssi_cancel_read(int ch);
+void if_ssi_cancel_write(int ch);
+
+#endif /* _SSI_IF_H */
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/mmc/card/block.c kernel-2.6.28-20094803.3+0m5/drivers/mmc/card/block.c
--- kernel-2.6.28-20094102.6+0m5/drivers/mmc/card/block.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/mmc/card/block.c	2011-09-04 11:37:54.000000000 +0200
@@ -83,7 +83,14 @@ static void mmc_blk_put(struct mmc_blk_d
 	mutex_lock(&open_lock);
 	md->usage--;
 	if (md->usage == 0) {
+		int devmaj = MAJOR(disk_devt(md->disk));
 		int devidx = MINOR(disk_devt(md->disk)) >> MMC_SHIFT;
+
+		if (!devmaj)
+			devidx = md->disk->first_minor >> MMC_SHIFT;
+
+		blk_cleanup_queue(md->queue.queue);
+
 		__clear_bit(devidx, dev_use);
 
 		put_disk(md->disk);
@@ -312,6 +319,15 @@ static int mmc_blk_issue_rq(struct mmc_q
 
 		mmc_wait_for_req(card->host, &brq.mrq);
 
+		/* Give up early if the card has gone away */
+		if (brq.cmd.error == -ENODEV || brq.data.error == -ENODEV || brq.stop.error == -ENODEV) {
+			req->cmd_flags |= REQ_QUIET;
+			spin_lock_irq(&md->lock);
+			ret = __blk_end_request(req, -EIO, blk_rq_cur_bytes(req));
+			spin_unlock_irq(&md->lock);
+			break;
+		}
+
 		mmc_queue_bounce_post(mq);
 
 		/*
@@ -363,6 +379,11 @@ static int mmc_blk_issue_rq(struct mmc_q
 				cmd.arg = card->rca << 16;
 				cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
 				err = mmc_wait_for_cmd(card->host, &cmd, 5);
+				if (err == -ENODEV) {
+					/* Card was removed so quiet errors */
+					req->cmd_flags |= REQ_QUIET;
+					goto cmd_err;
+				}
 				if (err) {
 					printk(KERN_ERR "%s: error %d requesting status\n",
 					       req->rq_disk->disk_name, err);
@@ -583,8 +604,11 @@ static int mmc_blk_probe(struct mmc_card
 		return PTR_ERR(md);
 
 	err = mmc_blk_set_blksize(md, card);
-	if (err)
-		goto out;
+	if (err) {
+		mmc_cleanup_queue(&md->queue);
+		mmc_blk_put(md);
+		return err;
+	}
 
 	string_get_size((u64)get_capacity(md->disk) << 9, STRING_UNITS_2,
 			cap_str, sizeof(cap_str));
@@ -595,11 +619,6 @@ static int mmc_blk_probe(struct mmc_card
 	mmc_set_drvdata(card, md);
 	add_disk(md->disk);
 	return 0;
-
- out:
-	mmc_blk_put(md);
-
-	return err;
 }
 
 static void mmc_blk_remove(struct mmc_card *card)
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/mmc/card/queue.c kernel-2.6.28-20094803.3+0m5/drivers/mmc/card/queue.c
--- kernel-2.6.28-20094102.6+0m5/drivers/mmc/card/queue.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20094803.3+0m5/drivers/mmc/card/queue.c	2011-09-04 11:37:54.000000000 +0200
@@ -91,9 +91,9 @@ static void mmc_request(struct request_q
 	int ret;
 
 	if (!mq) {
-		printk(KERN_ERR "MMC: killing requests for dead queue\n");
 		while ((req = elv_next_request(q)) != NULL) {
 			do {
+				req->cmd_flags |= REQ_QUIET;
 				ret = __blk_end_request(req, -EIO,
 							blk_rq_cur_bytes(req));
 			} while (ret);
@@ -228,17 +228,18 @@ void mmc_cleanup_queue(struct mmc_queue
 	struct request_queue *q = mq->queue;
 	unsigned long flags;
 
-	/* Mark that we should start throwing out stragglers */
-	spin_lock_irqsave(q->queue_lock, flags);
-	q->queuedata = NULL;
-	spin_unlock_irqrestore(q->queue_lock, flags);
-
 	/* Make sure the queue isn't suspended, as that will deadlock */
 	mmc_queue_resume(mq);
 
 	/* Then terminate our worker thread */
 	kthread_stop(mq->thread);
 
+	/* Empty the queue */
+	spin_lock_irqsave(q->queue_lock, flags);
+	q->queuedata = NULL;
+	blk_start_queue(q);
+	spin_unlock_irqrestore(q->queue_lock, flags);
+
  	if (mq->bounce_sg)
  		kfree(mq->bounce_sg);
  	mq->bounce_sg = NULL;
@@ -250,8 +251,6 @@ void mmc_cleanup_queue(struct mmc_queue
 		kfree(mq->bounce_buf);
 	mq->bounce_buf = NULL;
 
-	blk_cleanup_queue(mq->queue);
-
 	mq->card = NULL;
 }
 EXPORT_SYMBOL(mmc_cleanup_queue);
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/mmc/host/omap_hsmmc.c kernel-2.6.28-20094803.3+0m5/drivers/mmc/host/omap_hsmmc.c
--- kernel-2.6.28-20094102.6+0m5/drivers/mmc/host/omap_hsmmc.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/mmc/host/omap_hsmmc.c	2011-09-04 11:37:54.000000000 +0200
@@ -1058,9 +1058,9 @@ static void omap_hsmmc_request(struct mm
 					;
 				host->reqs_blocked += 1;
 			}
-			req->cmd->error = -EBADF;
+			req->cmd->error = -ENODEV;
 			if (req->data)
-				req->data->error = -EBADF;
+				req->data->error = -ENODEV;
 			enable_irq(host->irq);
 			mmc_request_done(mmc, req);
 			return;
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/net/wireless/wl12xx/wl1251_acx.c kernel-2.6.28-20094803.3+0m5/drivers/net/wireless/wl12xx/wl1251_acx.c
--- kernel-2.6.28-20094102.6+0m5/drivers/net/wireless/wl12xx/wl1251_acx.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/net/wireless/wl12xx/wl1251_acx.c	2011-09-04 11:37:54.000000000 +0200
@@ -1040,6 +1040,34 @@ out:
 	return ret;
 }
 
+int wl1251_acx_bet_enable(struct wl1251 *wl, enum wl1251_acx_bet_mode mode,
+			  u8 max_consecutive)
+{
+	struct wl1251_acx_bet_enable *acx;
+	int ret;
+
+	wl1251_debug(DEBUG_ACX, "acx bet enable");
+
+	acx = kzalloc(sizeof(*acx), GFP_KERNEL);
+	if (!acx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	acx->enable = mode;
+	acx->max_consecutive = max_consecutive;
+
+	ret = wl1251_cmd_configure(wl, ACX_BET_ENABLE, acx, sizeof(*acx));
+	if (ret < 0) {
+		wl1251_warning("wl1251 acx bet enable failed: %d", ret);
+		goto out;
+	}
+
+out:
+	kfree(acx);
+	return ret;
+}
+
 int wl1251_acx_ip_config(struct wl1251 *wl, bool enable, u8 *address,
 			 u8 version)
 {
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/net/wireless/wl12xx/wl1251_acx.h kernel-2.6.28-20094803.3+0m5/drivers/net/wireless/wl12xx/wl1251_acx.h
--- kernel-2.6.28-20094102.6+0m5/drivers/net/wireless/wl12xx/wl1251_acx.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/net/wireless/wl12xx/wl1251_acx.h	2011-09-04 11:37:54.000000000 +0200
@@ -1191,7 +1191,6 @@ struct wl1251_acx_mem_map {
 	u32 num_rx_mem_blocks;
 } __attribute__ ((packed));
 
-
 struct wl1251_acx_wr_tbtt_and_dtim {
 
 	struct acx_header header;
@@ -1222,6 +1221,31 @@ struct wl1251_acx_arp_filter {
 			       bytes of the the address are ignored.*/
 } __attribute__((packed));
 
+enum wl1251_acx_bet_mode {
+	WL1251_ACX_BET_DISABLE = 0,
+	WL1251_ACX_BET_ENABLE = 1,
+};
+
+struct wl1251_acx_bet_enable {
+	struct acx_header header;
+
+	/*
+	 * Specifies if beacon early termination procedure is enabled or
+	 * disabled, see enum wl1251_acx_bet_mode.
+	 */
+	u8 enable;
+
+	/*
+	 * Specifies the maximum number of consecutive beacons that may be
+	 * early terminated. After this number is reached at least one full
+	 * beacon must be correctly received in FW before beacon ET
+	 * resumes. Range 0 - 255.
+	 */
+	u8 max_consecutive;
+
+	u8 padding[2];
+} __attribute__ ((packed));
+
 /*************************************************************************
 
     Host Interrupt Register (WiLink -> Host)
@@ -1384,4 +1408,7 @@ int wl1251_acx_mem_cfg(struct wl1251 *wl
 int wl1251_acx_wr_tbtt_and_dtim(struct wl1251 *wl, u16 tbtt, u8 dtim);
 int wl1251_acx_ip_config(struct wl1251 *wl, bool enable, u8 *address,
 			 u8 version);
+int wl1251_acx_bet_enable(struct wl1251 *wl, enum wl1251_acx_bet_mode mode,
+			  u8 max_consecutive);
+
 #endif /* __WL1251_ACX_H__ */
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/net/wireless/wl12xx/wl1251_boot.c kernel-2.6.28-20094803.3+0m5/drivers/net/wireless/wl12xx/wl1251_boot.c
--- kernel-2.6.28-20094102.6+0m5/drivers/net/wireless/wl12xx/wl1251_boot.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/net/wireless/wl12xx/wl1251_boot.c	2011-09-04 11:37:54.000000000 +0200
@@ -305,7 +305,7 @@ int wl1251_boot_run_firmware(struct wl12
 		ROAMING_TRIGGER_LOW_RSSI_EVENT_ID |
 		ROAMING_TRIGGER_REGAINED_RSSI_EVENT_ID |
 		REGAINED_BSS_EVENT_ID | BT_PTA_SENSE_EVENT_ID |
-		BT_PTA_PREDICTION_EVENT_ID;
+		BT_PTA_PREDICTION_EVENT_ID | PS_REPORT_EVENT_ID;
 
 	ret = wl1251_event_unmask(wl);
 	if (ret < 0) {
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/net/wireless/wl12xx/wl1251_event.c kernel-2.6.28-20094803.3+0m5/drivers/net/wireless/wl12xx/wl1251_event.c
--- kernel-2.6.28-20094102.6+0m5/drivers/net/wireless/wl12xx/wl1251_event.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/net/wireless/wl12xx/wl1251_event.c	2011-09-04 11:37:54.000000000 +0200
@@ -31,10 +31,6 @@
 static int wl1251_event_scan_complete(struct wl1251 *wl,
 				      struct event_mailbox *mbox)
 {
-	wl1251_debug(DEBUG_EVENT, "status: 0x%x, channels: %d",
-		     mbox->scheduled_scan_status,
-		     mbox->scheduled_scan_channels);
-
 	if (wl->scanning) {
 		mutex_unlock(&wl->mutex);
 		ieee80211_scan_completed(wl->hw);
@@ -46,11 +42,36 @@ static int wl1251_event_scan_complete(st
 	return 0;
 }
 
-static void wl1251_event_mbox_dump(struct event_mailbox *mbox)
-{
-	wl1251_debug(DEBUG_EVENT, "MBOX DUMP:");
-	wl1251_debug(DEBUG_EVENT, "\tvector: 0x%x", mbox->events_vector);
-	wl1251_debug(DEBUG_EVENT, "\tmask: 0x%x", mbox->events_mask);
+#define WL1251_PS_ENTRY_RETRIES  3
+static int wl1251_event_ps_report(struct wl1251 *wl,
+				  struct event_mailbox *mbox)
+{
+	int ret = 0;
+
+	wl1251_debug(DEBUG_EVENT, "ps status: %x", mbox->ps_status);
+
+	switch (mbox->ps_status) {
+	case ENTER_POWER_SAVE_FAIL:
+		if (!wl->psm) {
+			wl->ps_entry_retry = 0;
+			break;
+		}
+
+		if (wl->ps_entry_retry < WL1251_PS_ENTRY_RETRIES) {
+			ret = wl1251_ps_set_mode(wl, STATION_POWER_SAVE_MODE);
+			wl->ps_entry_retry++;
+		} else {
+			wl1251_error("Power save entry failed, giving up");
+			wl->ps_entry_retry = 0;
+		}
+		break;
+	case ENTER_POWER_SAVE_SUCCESS:
+	default:
+		wl->ps_entry_retry = 0;
+		break;
+	}
+
+	return 0;
 }
 
 static int wl1251_event_process(struct wl1251 *wl, struct event_mailbox *mbox)
@@ -58,10 +79,7 @@ static int wl1251_event_process(struct w
 	int ret;
 	u32 vector;
 
-	wl1251_event_mbox_dump(mbox);
-
 	vector = mbox->events_vector & ~(mbox->events_mask);
-	wl1251_debug(DEBUG_EVENT, "vector: 0x%x", vector);
 
 	if (vector & SCAN_COMPLETE_EVENT_ID) {
 		ret = wl1251_event_scan_complete(wl, mbox);
@@ -79,7 +97,14 @@ static int wl1251_event_process(struct w
 		}
 	}
 
-	if (vector & SYNCHRONIZATION_TIMEOUT_EVENT_ID && wl->psm) {
+	if (vector & PS_REPORT_EVENT_ID) {
+		wl1251_debug(DEBUG_EVENT, "PS_REPORT_EVENT_ID");
+		ret = wl1251_event_ps_report(wl, mbox);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wl->vif && (vector & SYNCHRONIZATION_TIMEOUT_EVENT_ID)) {
 		wl1251_debug(DEBUG_EVENT, "SYNCHRONIZATION_TIMEOUT_EVENT");
 		/* need to unlock mutex to avoid deadlocking with rtnl */
 		mutex_unlock(&wl->mutex);
@@ -97,11 +122,16 @@ static int wl1251_event_process(struct w
 		}
 	}
 
-	if (vector & ROAMING_TRIGGER_LOW_RSSI_EVENT_ID)
+	if (wl->vif && (vector & ROAMING_TRIGGER_LOW_RSSI_EVENT_ID)) {
+		wl1251_debug(DEBUG_EVENT, "ROAMING_TRIGGER_LOW_RSSI_EVENT");
 		ieee80211_rssi_changed(wl->vif, IEEE80211_RSSI_STATE_LOW);
+	}
 
-	if (vector & ROAMING_TRIGGER_REGAINED_RSSI_EVENT_ID)
+	if (wl->vif && (vector & ROAMING_TRIGGER_REGAINED_RSSI_EVENT_ID)) {
+		wl1251_debug(DEBUG_EVENT,
+			     "ROAMING_TRIGGER_REGAINED_RSSI_EVENT");
 		ieee80211_rssi_changed(wl->vif, IEEE80211_RSSI_STATE_HIGH);
+	}
 
 	return 0;
 }
@@ -121,9 +151,6 @@ void wl1251_event_mbox_config(struct wl1
 {
 	wl->mbox_ptr[0] = wl1251_reg_read32(wl, REG_EVENT_MAILBOX_PTR);
 	wl->mbox_ptr[1] = wl->mbox_ptr[0] + sizeof(struct event_mailbox);
-
-	wl1251_debug(DEBUG_EVENT, "MBOX ptrs: 0x%x 0x%x",
-		     wl->mbox_ptr[0], wl->mbox_ptr[1]);
 }
 
 int wl1251_event_handle(struct wl1251 *wl, u8 mbox_num)
@@ -131,8 +158,6 @@ int wl1251_event_handle(struct wl1251 *w
 	struct event_mailbox mbox;
 	int ret;
 
-	wl1251_debug(DEBUG_EVENT, "EVENT on mbox %d", mbox_num);
-
 	if (mbox_num > 1)
 		return -EINVAL;
 
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/net/wireless/wl12xx/wl1251_event.h kernel-2.6.28-20094803.3+0m5/drivers/net/wireless/wl12xx/wl1251_event.h
--- kernel-2.6.28-20094102.6+0m5/drivers/net/wireless/wl12xx/wl1251_event.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/net/wireless/wl12xx/wl1251_event.h	2011-09-04 11:37:54.000000000 +0200
@@ -75,6 +75,13 @@ enum {
 	EVENT_MBOX_ALL_EVENT_ID                  = 0x7fffffff,
 };
 
+enum {
+	ENTER_POWER_SAVE_FAIL =  0,
+	ENTER_POWER_SAVE_SUCCESS,
+	EXIT_POWER_SAVE_FAIL,
+	EXIT_POWER_SAVE_SUCCESS
+};
+
 struct event_debug_report {
 	u8 debug_event_id;
 	u8 num_params;
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/net/wireless/wl12xx/wl1251.h kernel-2.6.28-20094803.3+0m5/drivers/net/wireless/wl12xx/wl1251.h
--- kernel-2.6.28-20094102.6+0m5/drivers/net/wireless/wl12xx/wl1251.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/net/wireless/wl12xx/wl1251.h	2011-09-04 11:37:54.000000000 +0200
@@ -356,7 +356,7 @@ struct wl1251 {
 	/* Are we currently scanning */
 	bool scanning;
 
-	u32 last_event;
+	unsigned long last_event;
 
 	/* Our association ID */
 	u16 aid;
@@ -381,6 +381,8 @@ struct wl1251 {
 	/* PSM mode requested */
 	bool psm_requested;
 
+	u8 ps_entry_retry;
+
 	u16 beacon_int;
 	u8 dtim_period;
 
@@ -423,6 +425,8 @@ int wl1251_plt_stop(struct wl1251 *wl);
 
 #define WL1251_DEFAULT_CHANNEL 0
 
+#define WL1251_DEFAULT_BET_CONSECUTIVE 10
+
 #define CHIP_ID_1251_PG10	           (0x7010101)
 #define CHIP_ID_1251_PG11	           (0x7020101)
 #define CHIP_ID_1251_PG12	           (0x7030101)
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/net/wireless/wl12xx/wl1251_main.c kernel-2.6.28-20094803.3+0m5/drivers/net/wireless/wl12xx/wl1251_main.c
--- kernel-2.6.28-20094102.6+0m5/drivers/net/wireless/wl12xx/wl1251_main.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/net/wireless/wl12xx/wl1251_main.c	2011-09-04 11:37:54.000000000 +0200
@@ -939,6 +939,7 @@ static void wl1251_op_stop(struct ieee80
 	wl->next_tx_complete = 0;
 	wl->elp = false;
 	wl->psm = 0;
+	wl->ps_entry_retry = 0;
 	wl->tx_queue_stopped = false;
 	wl->power_level = WL1251_DEFAULT_POWER_LEVEL;
 	wl->channel = WL1251_DEFAULT_CHANNEL;
@@ -1092,6 +1093,7 @@ static int wl1251_op_config_interface(st
 	struct wl1251 *wl = hw->priv;
 	struct sk_buff *beacon;
 	DECLARE_MAC_BUF(mac);
+	bool do_join = false;
 	int ret;
 
 	wl1251_debug(DEBUG_MAC80211, "mac80211 config_interface bssid %s",
@@ -1105,23 +1107,21 @@ static int wl1251_op_config_interface(st
 	if (ret < 0)
 		goto out;
 
+	if (!is_zero_ether_addr(conf->bssid))
+		do_join = true;
+
 	memcpy(wl->bssid, conf->bssid, ETH_ALEN);
 
-	ret = wl1251_build_null_data(wl);
-	if (ret < 0)
-		goto out_sleep;
+	if (do_join) {
+		ret = wl1251_build_null_data(wl);
+		if (ret < 0)
+			goto out_sleep;
+	}
 
 	wl->ssid_len = conf->ssid_len;
 	if (wl->ssid_len)
 		memcpy(wl->ssid, conf->ssid, wl->ssid_len);
 
-	if (wl->bss_type != BSS_TYPE_IBSS) {
-		ret = wl1251_join(wl, wl->bss_type, wl->channel,
-				  wl->beacon_int, wl->dtim_period);
-		if (ret < 0)
-			goto out_sleep;
-	}
-
 	if (conf->changed & IEEE80211_IFCC_BEACON) {
 		beacon = ieee80211_beacon_get(hw, vif);
 		wl1251_update_support_rates((struct wl12xx_beacon_template *)
@@ -1142,7 +1142,9 @@ static int wl1251_op_config_interface(st
 
 		if (ret < 0)
 			goto out_sleep;
+	}
 
+	if (do_join) {
 		ret = wl1251_join(wl, wl->bss_type, wl->channel,
 				  wl->beacon_int, wl->dtim_period);
 		if (ret < 0)
@@ -1177,18 +1179,7 @@ static int wl1251_op_config(struct ieee8
 	if (ret < 0)
 		goto out;
 
-	if (channel != wl->channel) {
-		wl->channel = channel;
-
-		ret = wl1251_join(wl, wl->bss_type, wl->channel,
-				  wl->beacon_int, wl->dtim_period);
-		if (ret < 0)
-			goto out_sleep;
-	}
-
-	ret = wl1251_build_null_data(wl);
-	if (ret < 0)
-		goto out_sleep;
+	wl->channel = channel;
 
 	if (conf->flags & IEEE80211_CONF_PS && !wl->psm_requested) {
 		wl1251_debug(DEBUG_PSM, "psm enabled");
@@ -1215,7 +1206,7 @@ static int wl1251_op_config(struct ieee8
 	if (conf->power_level != wl->power_level) {
 		ret = wl1251_acx_tx_power(wl, conf->power_level);
 		if (ret < 0)
-			goto out;
+			goto out_sleep;
 
 		wl->power_level = conf->power_level;
 	}
@@ -1939,6 +1930,7 @@ static int __devinit wl1251_probe(struct
 	wl->elp = false;
 	wl->psm = 0;
 	wl->psm_requested = false;
+	wl->ps_entry_retry = 0;
 	wl->tx_queue_stopped = false;
 	wl->power_level = WL1251_DEFAULT_POWER_LEVEL;
 	wl->beacon_int = WL1251_DEFAULT_BEACON_INT;
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/net/wireless/wl12xx/wl1251_ps.c kernel-2.6.28-20094803.3+0m5/drivers/net/wireless/wl12xx/wl1251_ps.c
--- kernel-2.6.28-20094102.6+0m5/drivers/net/wireless/wl12xx/wl1251_ps.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/net/wireless/wl12xx/wl1251_ps.c	2011-09-04 11:37:54.000000000 +0200
@@ -151,6 +151,11 @@ int wl1251_ps_set_mode(struct wl1251 *wl
 		if (ret < 0)
 			return ret;
 
+		ret = wl1251_acx_bet_enable(wl, WL1251_ACX_BET_ENABLE,
+					    WL1251_DEFAULT_BET_CONSECUTIVE);
+		if (ret < 0)
+			return ret;
+
 		ret = wl1251_cmd_ps_mode(wl, STATION_POWER_SAVE_MODE);
 		if (ret < 0)
 			return ret;
@@ -168,6 +173,12 @@ int wl1251_ps_set_mode(struct wl1251 *wl
 		if (ret < 0)
 			return ret;
 
+		/* disable BET */
+		ret = wl1251_acx_bet_enable(wl, WL1251_ACX_BET_DISABLE,
+					    WL1251_DEFAULT_BET_CONSECUTIVE);
+		if (ret < 0)
+			return ret;
+
 		/* disable beacon filtering */
 		ret = wl1251_acx_beacon_filter_opt(wl, false);
 		if (ret < 0)
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/usb/gadget/file_storage.c kernel-2.6.28-20094803.3+0m5/drivers/usb/gadget/file_storage.c
--- kernel-2.6.28-20094102.6+0m5/drivers/usb/gadget/file_storage.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/usb/gadget/file_storage.c	2011-09-04 11:37:54.000000000 +0200
@@ -606,6 +606,10 @@ enum fsg_buffer_state {
 struct fsg_dev;
 
 struct fsg_buffhd {
+	struct rb_node			rb_node;
+	sector_t			sector;
+	int				sectors;
+
 	void				*buf;
 	size_t				buflen;
 	enum fsg_buffer_state		state;
@@ -694,6 +698,9 @@ struct fsg_dev {
 	struct fsg_buffhd	buffhds[NUM_BUFFERS];
 	int			num_buffers;
 
+	/* Tree to find direct I/O's with overlapping sectors */
+	struct rb_root		bio_tree;
+
 	int			thread_wakeup_needed;
 	struct completion	thread_notifier;
 	struct task_struct	*thread_task;
@@ -1055,6 +1062,58 @@ static struct usb_gadget_strings	stringt
 	.strings	= strings,
 };
 
+/*
+ *	Find overlapped bio in fsg->bio_tree rb tree.
+ */
+static int fsg_rbtree_find(struct fsg_dev *fsg, sector_t s,
+		unsigned int sectors)
+{
+	struct rb_node *n;
+	struct fsg_buffhd *tmp;
+	int found = 0;
+
+	spin_lock_irq(&fsg->lock);
+	n = fsg->bio_tree.rb_node;
+	while (n) {
+		tmp = rb_entry(n, struct fsg_buffhd, rb_node);
+		if (s + sectors <= tmp->sector)
+			n = n->rb_left;
+		else if (s >= tmp->sector + tmp->sectors)
+			n = n->rb_right;
+		else {
+			found = 1;
+			break;
+		}
+	}
+	spin_unlock_irq(&fsg->lock);
+	return found;
+}
+
+/*
+ * Insert a node into the fsg->bio_tree rb tree.
+ */
+static void fsg_rbtree_insert(struct fsg_dev *fsg, struct fsg_buffhd *node)
+{
+	struct rb_node **p;
+	struct rb_node *parent = NULL;
+	struct fsg_buffhd *tmp;
+
+	spin_lock_irq(&fsg->lock);
+	p = &fsg->bio_tree.rb_node;
+
+	while (*p) {
+		parent = *p;
+		tmp = rb_entry(parent, struct fsg_buffhd, rb_node);
+		if (node->sector < tmp->sector)
+			p = &(*p)->rb_left;
+		else
+			p = &(*p)->rb_right;
+	}
+	rb_link_node(&node->rb_node, parent, p);
+	rb_insert_color(&node->rb_node, &fsg->bio_tree);
+	spin_unlock_irq(&fsg->lock);
+}
+
 /** UGLY UGLY HACK: Windows problems with multiple
  * configurations.
  *
@@ -1721,7 +1780,8 @@ static void direct_read_end_io(struct bi
  * or b) more than one bio must be submitted
  */
 /* FIXME: Needs an equivalent of readahead */
-static ssize_t direct_read(struct file *file, char *buf, size_t amount, loff_t *pos)
+static ssize_t direct_read(struct file *file, struct fsg_buffhd *bh,
+		size_t amount, loff_t *pos)
 {
 	DECLARE_COMPLETION_ONSTACK(wait);
 	unsigned max_pages = (amount >> PAGE_SHIFT) + 1;
@@ -1729,7 +1789,8 @@ static ssize_t direct_read(struct file *
 	ssize_t totlen = 0;
 	struct page *page;
 	struct bio *bio;
-	char *p = buf;
+	char *p = bh->buf;
+	int rc;
 
 	if (!amount)
 		return 0;
@@ -1767,6 +1828,15 @@ static ssize_t direct_read(struct file *
 		return -EINVAL;
 	}
 
+	while (fsg_rbtree_find(bh->fsg, bio->bi_sector,
+		bio_sectors(bio))) {
+		rc = sleep_thread(bh->fsg);
+		if (rc) {
+			bio_put(bio);
+			return rc;
+		}
+	}
+
 	submit_bio(READ, bio);
 
 	wait_for_completion(&wait);
@@ -1865,7 +1935,7 @@ static int do_read(struct fsg_dev *fsg)
 		/* Perform the read */
 		file_offset_tmp = file_offset;
 		if (curlun->direct)
-			nread = direct_read(curlun->filp, bh->buf,
+			nread = direct_read(curlun->filp, bh,
 					amount, &file_offset_tmp);
 		else
 			nread = vfs_read(curlun->filp,
@@ -1920,6 +1990,7 @@ static void direct_write_end_io(struct b
 {
 	struct fsg_buffhd *bh = bio->bi_private;
 	struct fsg_dev *fsg = bh->fsg;
+	unsigned long flags;
 
 	if (err) {
 		/* FIXME: how to let host know about this error */
@@ -1927,11 +1998,13 @@ static void direct_write_end_io(struct b
 		clear_bit(BIO_UPTODATE, &bio->bi_flags);
 	}
 
+	/* FIXME: smp barriers are not necessary for this this driver */
 	smp_wmb();
-	spin_lock(&fsg->lock);
+	spin_lock_irqsave(&fsg->lock, flags);
+	rb_erase(&bh->rb_node, &fsg->bio_tree);
 	bh->state = BUF_STATE_EMPTY;
 	wakeup_thread(fsg);
-	spin_unlock(&fsg->lock);
+	spin_unlock_irqrestore(&fsg->lock, flags);
 
 	bio_put(bio);
 }
@@ -1949,6 +2022,7 @@ static ssize_t direct_write(struct file
 	struct page *page;
 	struct bio *bio;
 	char *p = bh->buf;
+	int rc;
 
 	if (!amount)
 		return 0;
@@ -1987,6 +2061,16 @@ static ssize_t direct_write(struct file
 	}
 
 	bh->state = BUF_STATE_BUSY;
+	bh->sector = bio->bi_sector;
+	bh->sectors = bio_sectors(bio);
+	while (fsg_rbtree_find(bh->fsg, bh->sector, bh->sectors)) {
+		rc = sleep_thread(bh->fsg);
+		if (rc) {
+			bio_put(bio);
+			return rc;
+		}
+	}
+	fsg_rbtree_insert(bh->fsg, bh);
 
 	submit_bio(WRITE, bio);
 
@@ -4456,6 +4540,7 @@ static int __init fsg_bind(struct usb_ga
 		bh->next = bh + 1;
 	}
 	fsg->buffhds[fsg->num_buffers - 1].next = &fsg->buffhds[0];
+	fsg->bio_tree = RB_ROOT;
 
 	snprintf(manufacturer, sizeof manufacturer, "%s %s with %s",
 			init_utsname()->sysname, init_utsname()->release,
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/usb/musb/musb_core.c kernel-2.6.28-20094803.3+0m5/drivers/usb/musb/musb_core.c
--- kernel-2.6.28-20094102.6+0m5/drivers/usb/musb/musb_core.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/usb/musb/musb_core.c	2011-09-04 11:37:54.000000000 +0200
@@ -235,6 +235,19 @@ static int musb_charger_detect(struct mu
 			/* we always reset transceiver */
 			check_charger = 1;
 
+			/* HACK: ULPI tends to get stuck when booting with
+			 * the cable connected
+			 */
+			r = musb_readb(musb->mregs, MUSB_DEVCTL);
+			if ((r & MUSB_DEVCTL_VBUS)
+					== (3 << MUSB_DEVCTL_VBUS_SHIFT)) {
+				musb_save_ctx_and_suspend(&musb->g, 0);
+				musb_restore_ctx_and_resume(&musb->g);
+				if (musb->board && musb->board->set_pm_limits)
+					musb->board->set_pm_limits(
+							musb->controller, 1);
+			}
+
 			/* disable RESET and RESUME interrupts */
 			r = musb_readb(musb->mregs, MUSB_INTRUSBE);
 			r &= ~(MUSB_INTR_RESUME | MUSB_INTR_RESET);
@@ -2113,19 +2126,8 @@ static void musb_irq_work(struct work_st
 {
 	struct musb *musb = container_of(data, struct musb, irq_work);
 	static int old_state, old_ma, old_suspend;
-	u8 devctl;
 
 	if (musb->xceiv->state != old_state) {
-		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-		if (musb->xceiv->state == OTG_STATE_B_IDLE &&
-					(devctl & MUSB_DEVCTL_VBUS))
-			goto keep_limit;
-
-		/* clear/set requirements for musb to work with DPS on omap3 */
-		if (musb->board && musb->board->set_pm_limits)
-			musb->board->set_pm_limits(musb->controller,
-				(musb->xceiv->state == OTG_STATE_B_PERIPHERAL));
-keep_limit:
 		old_state = musb->xceiv->state;
 		sysfs_notify(&musb->controller->kobj, NULL, "mode");
 	}
@@ -2457,6 +2459,12 @@ bad_config:
 	if (status)
 		goto fail2;
 
+	/* Resets the controller. Has to be done. Without this, most likely
+	 * the state machine inside the transceiver doesn't get fixed properly
+	 */
+	musb_save_ctx_and_suspend(&musb->g, 0);
+	musb_restore_ctx_and_resume(&musb->g);
+
 	return 0;
 
 fail2:
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/usb/musb/musb_core.h kernel-2.6.28-20094803.3+0m5/drivers/usb/musb/musb_core.h
--- kernel-2.6.28-20094102.6+0m5/drivers/usb/musb/musb_core.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/usb/musb/musb_core.h	2011-09-04 11:37:54.000000000 +0200
@@ -360,6 +360,7 @@ struct musb {
 	struct clk		*clock;
 	irqreturn_t		(*isr)(int, void *);
 	struct work_struct	irq_work;
+	struct work_struct	vbus_work;
 
 /* this hub status bit is reserved by USB 2.0 and not seen by usbcore */
 #define MUSB_PORT_STAT_RESUME	(1 << 31)
diff -Nurp kernel-2.6.28-20094102.6+0m5/drivers/usb/musb/omap2430.c kernel-2.6.28-20094803.3+0m5/drivers/usb/musb/omap2430.c
--- kernel-2.6.28-20094102.6+0m5/drivers/usb/musb/omap2430.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/drivers/usb/musb/omap2430.c	2011-09-04 11:37:54.000000000 +0200
@@ -49,6 +49,17 @@
 
 static struct timer_list musb_idle_timer;
 
+static void musb_vbus_work(struct work_struct *data)
+{
+	struct musb *musb = container_of(data, struct musb, vbus_work);
+	u8 devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+
+	/* clear/set requirements for musb to work with DPS on omap3 */
+	if (musb->board && musb->board->set_pm_limits && !musb->is_charger)
+		musb->board->set_pm_limits(musb->controller,
+					(devctl & MUSB_DEVCTL_VBUS));
+}
+
 static void musb_do_idle(unsigned long _musb)
 {
 	struct musb	*musb = (void *)_musb;
@@ -276,6 +287,7 @@ int __init musb_platform_init(struct mus
 	musb->a_wait_bcon = MUSB_TIMEOUT_A_WAIT_BCON;
 
 	setup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);
+	INIT_WORK(&musb->vbus_work, musb_vbus_work);
 
 	return 0;
 }
@@ -448,6 +460,9 @@ void musb_restore_ctx_and_resume(struct
 
 	/* Restore register context */
 	musb_restore_ctx(musb);
+
+	/* set constraints */
+	schedule_work(&musb->vbus_work);
 	spin_unlock_irqrestore(&musb->lock, flags);
 }
 EXPORT_SYMBOL_GPL(musb_restore_ctx_and_resume);
diff -Nurp kernel-2.6.28-20094102.6+0m5/include/linux/ssi_driver_if.h kernel-2.6.28-20094803.3+0m5/include/linux/ssi_driver_if.h
--- kernel-2.6.28-20094102.6+0m5/include/linux/ssi_driver_if.h	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/include/linux/ssi_driver_if.h	2011-09-04 11:37:54.000000000 +0200
@@ -31,6 +31,10 @@
 /* The number of ports handled by the driver. (MAX:2) */
 #define SSI_MAX_PORTS		1
 
+#define SSI_MAX_FRAME_SIZE	0x1f
+#define SSI_MAX_RX_TIMEOUT	0x1ff
+#define SSI_MAX_TX_DIVISOR	0x7f
+
 #define ANY_SSI_CONTROLLER	-1
 #define ANY_CHANNEL		-1
 #define CHANNEL(channel)	(1 << (channel))
@@ -42,6 +46,7 @@ enum {
 	SSI_EVENT_POST_SPEED_CHANGE,
 	SSI_EVENT_CAWAKE_UP,
 	SSI_EVENT_CAWAKE_DOWN,
+	SSI_EVENT_SSR_DATAAVAILABLE,
 };
 
 enum {
@@ -52,6 +57,10 @@ enum {
 	SSI_IOCTL_FLUSH_RX,
 	SSI_IOCTL_FLUSH_TX,
 	SSI_IOCTL_CAWAKE,
+	SSI_IOCTL_SET_RX,
+	SSI_IOCTL_GET_RX,
+	SSI_IOCTL_SET_TX,
+	SSI_IOCTL_GET_TX,
 	SSI_IOCTL_TX_CH_FULL,
 	SSI_IOCTL_CH_DATAACCEPT,
 };
@@ -142,6 +151,7 @@ int ssi_write(struct ssi_device *dev, u3
 void ssi_write_cancel(struct ssi_device *dev);
 int ssi_read(struct ssi_device *dev, u32 *data, unsigned int w_count);
 void ssi_read_cancel(struct ssi_device *dev);
+int ssi_poll(struct ssi_device *dev);
 int ssi_ioctl(struct ssi_device *dev, unsigned int command, void *arg);
 void ssi_close(struct ssi_device *dev);
 void ssi_set_read_cb(struct ssi_device *dev,
diff -Nurp kernel-2.6.28-20094102.6+0m5/include/linux/ssi_char.h kernel-2.6.28-20094803.3+0m5/include/linux/ssi_char.h
--- kernel-2.6.28-20094102.6+0m5/include/linux/ssi_char.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-2.6.28-20094803.3+0m5/include/linux/ssi_char.h	2011-09-04 11:37:54.000000000 +0200
@@ -0,0 +1,71 @@
+/*
+ * ssi_char.h
+ *
+ * Part of the SSI character device driver.
+ *
+ * Copyright (C) 2009 Nokia Corporation. All rights reserved.
+ *
+ * Contact: Andras Domokos <andras.domokos@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+
+#ifndef SSI_CHAR_H
+#define SSI_CHAR_H
+
+#define SSI_CHAR_BASE		'S'
+#define CS_IOW(num, dtype)	_IOW(SSI_CHAR_BASE, num, dtype)
+#define CS_IOR(num, dtype)	_IOR(SSI_CHAR_BASE, num, dtype)
+#define CS_IOWR(num, dtype)	_IOWR(SSI_CHAR_BASE, num, dtype)
+#define CS_IO(num)		_IO(SSI_CHAR_BASE, num)
+
+#define CS_SEND_BREAK		CS_IO(1)
+#define CS_FLUSH_RX		CS_IO(2)
+#define CS_FLUSH_TX		CS_IO(3)
+#define CS_BOOTSTRAP		CS_IO(4)
+#define CS_SET_WAKELINE		CS_IOW(5, unsigned int)
+#define CS_GET_WAKELINE		CS_IOR(6, unsigned int)
+#define CS_SET_RX		CS_IOW(7, struct ssi_rx_config)
+#define CS_GET_RX		CS_IOW(8, struct ssi_rx_config)
+#define CS_SET_TX		CS_IOW(9, struct ssi_tx_config)
+#define CS_GET_TX		CS_IOW(10, struct ssi_tx_config)
+
+#define SSI_MODE_SLEEP		0
+#define SSI_MODE_STREAM		1
+#define SSI_MODE_FRAME		2
+
+#define SSI_ARBMODE_RR		0
+#define SSI_ARBMODE_PRIO	1
+
+#define WAKE_UP			0
+#define WAKE_DOWN		1
+
+struct ssi_tx_config {
+	u32 mode;
+	u32 frame_size;
+	u32 channels;
+	u32 divisor;
+	u32 arb_mode;
+};
+
+struct ssi_rx_config {
+	u32 mode;
+	u32 frame_size;
+	u32 channels;
+	u32 timeout;
+};
+
+#endif /* SSI_CHAR_H */
diff -Nurp kernel-2.6.28-20094102.6+0m5/lib/Kconfig.debug kernel-2.6.28-20094803.3+0m5/lib/Kconfig.debug
--- kernel-2.6.28-20094102.6+0m5/lib/Kconfig.debug	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20094803.3+0m5/lib/Kconfig.debug	2011-09-04 11:37:54.000000000 +0200
@@ -731,6 +731,12 @@ config FAULT_INJECTION_DEBUG_FS
 	help
 	  Enable configuration of fault-injection capabilities via debugfs.
 
+config PANIC_INFO_BUFF
+	tristate "Buffer to be printed at panic"
+	depends on DEBUG_FS
+	help
+	  Provide a small buffer which will be printed at panic.
+
 config FAULT_INJECTION_STACKTRACE_FILTER
 	bool "stacktrace filter for fault-injection capabilities"
 	depends on FAULT_INJECTION_DEBUG_FS && STACKTRACE_SUPPORT
diff -Nurp kernel-2.6.28-20094102.6+0m5/mm/memory.c kernel-2.6.28-20094803.3+0m5/mm/memory.c
--- kernel-2.6.28-20094102.6+0m5/mm/memory.c	2008-12-25 00:26:37.000000000 +0100
+++ kernel-2.6.28-20094803.3+0m5/mm/memory.c	2011-09-04 11:37:54.000000000 +0200
@@ -1110,6 +1110,7 @@ no_page_table:
 	}
 	return page;
 }
+EXPORT_SYMBOL_GPL(follow_page);
 
 /* Can we do the FOLL_ANON optimization? */
 static inline int use_zero_page(struct vm_area_struct *vma)
diff -Nurp kernel-2.6.28-20094102.6+0m5/mm/swapfile.c kernel-2.6.28-20094803.3+0m5/mm/swapfile.c
--- kernel-2.6.28-20094102.6+0m5/mm/swapfile.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/mm/swapfile.c	2011-09-04 11:37:54.000000000 +0200
@@ -1103,9 +1103,14 @@ sector_t map_swap_page(struct swap_info_
 		/* Update the free pages gap */
 		sis->gap_next += 1;
 	} else {
-		/* Always read from the existing re-mapping */
-		BUG_ON(!old);
-		offset = old;
+		/*
+		 * Always read from the existing re-mapping
+		 * if there is one. There may not be because
+		 * 'swapin_readahead()' has won a race with
+		 * 'add_to_swap()'.
+		 */
+		if (old)
+			offset = old;
 	}
 	spin_unlock(&sis->remap_lock);
 
diff -Nurp kernel-2.6.28-20094102.6+0m5/net/bluetooth/hci_conn.c kernel-2.6.28-20094803.3+0m5/net/bluetooth/hci_conn.c
--- kernel-2.6.28-20094102.6+0m5/net/bluetooth/hci_conn.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/net/bluetooth/hci_conn.c	2011-09-04 11:37:54.000000000 +0200
@@ -211,6 +211,7 @@ struct hci_conn *hci_conn_add(struct hci
 	conn->type  = type;
 	conn->mode  = HCI_CM_ACTIVE;
 	conn->state = BT_OPEN;
+	conn->auth_type = HCI_AT_GENERAL_BONDING;
 
 	conn->power_save = 1;
 	conn->disc_timeout = HCI_DISCONN_TIMEOUT;
diff -Nurp kernel-2.6.28-20094102.6+0m5/net/mac80211/mlme.c kernel-2.6.28-20094803.3+0m5/net/mac80211/mlme.c
--- kernel-2.6.28-20094102.6+0m5/net/mac80211/mlme.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/net/mac80211/mlme.c	2011-09-04 11:37:54.000000000 +0200
@@ -34,7 +34,6 @@
 #define IEEE80211_ASSOC_TIMEOUT (HZ / 5)
 #define IEEE80211_ASSOC_MAX_TRIES 3
 #define IEEE80211_MONITORING_INTERVAL (2 * HZ)
-#define IEEE80211_PROBE_IDLE_TIME (60 * HZ)
 #define IEEE80211_RETRY_AUTH_INTERVAL (1 * HZ)
 #define IEEE80211_SCAN_INTERVAL (2 * HZ)
 #define IEEE80211_SCAN_INTERVAL_SLOW (15 * HZ)
@@ -784,6 +783,7 @@ static void ieee80211_direct_probe(struc
 		printk(KERN_DEBUG "%s: direct probe to AP %s timed out\n",
 		       sdata->dev->name, print_mac(mac, ifsta->bssid));
 		ifsta->state = IEEE80211_STA_MLME_DISABLED;
+		ifsta->flags &= ~IEEE80211_STA_ASSOCIATED;
 		ieee80211_sta_send_apinfo(sdata, ifsta);
 		return;
 	}
@@ -1025,6 +1025,8 @@ EXPORT_SYMBOL(ieee80211_rssi_changed);
 void ieee80211_sta_rx_notify(struct ieee80211_sub_if_data *sdata,
 			     struct ieee80211_hdr *hdr)
 {
+	struct ieee80211_local *local = sdata->local;
+
 	/*
 	 * We can postpone the sta.timer whenever receiving unicast frames
 	 * from AP because we know that the connection is working both ways
@@ -1033,7 +1035,8 @@ void ieee80211_sta_rx_notify(struct ieee
 	 * data idle periods for sending the periodical probe request to
 	 * the AP.
 	 */
-	if (!is_multicast_ether_addr(hdr->addr1))
+	if (!is_multicast_ether_addr(hdr->addr1) &&
+	    !(local->hw.flags & IEEE80211_HW_BEACON_FILTER))
 		mod_timer(&sdata->u.sta.timer,
 			  jiffies + IEEE80211_MONITORING_INTERVAL);
 }
@@ -1046,6 +1049,12 @@ void ieee80211_beacon_loss_work(struct w
 	struct ieee80211_if_sta *ifsta = &sdata->u.sta;
 	struct ieee80211_local *local = sdata->local;
 
+	if (ifsta->state != IEEE80211_STA_MLME_ASSOCIATED) {
+		printk(KERN_DEBUG "%s reports beacon loss when not "
+		       "associated\n", sdata->dev->name);
+		return;
+	}
+
 	printk(KERN_DEBUG "%s: driver reports beacon loss from AP %pM "
 	       "- sending probe request\n", sdata->dev->name,
 	       sdata->u.sta.bssid);
@@ -1112,8 +1121,7 @@ static void ieee80211_associated(struct
 	 * Beacon filtering is only enabled with power save and then the
 	 * stack should not check for beacon loss.
 	 */
-	if (!((local->hw.flags & IEEE80211_HW_BEACON_FILTER) &&
-	      (local->hw.conf.flags & IEEE80211_CONF_PS)) &&
+	if (!(local->hw.flags & IEEE80211_HW_BEACON_FILTER) &&
 	    time_after(jiffies,
 		       ifsta->last_beacon + IEEE80211_MONITORING_INTERVAL)) {
 		printk(KERN_DEBUG "%s: beacon loss from AP %pM "
@@ -1125,11 +1133,6 @@ static void ieee80211_associated(struct
 
 	}
 
-	if (time_after(jiffies, sta->last_rx + IEEE80211_PROBE_IDLE_TIME)) {
-		ifsta->flags |= IEEE80211_STA_PROBEREQ_POLL;
-		send_probe = true;
-	}
-
  unlock:
 	rcu_read_unlock();
 
@@ -1148,7 +1151,7 @@ static void ieee80211_associated(struct
 	if (disassoc)
 		ieee80211_set_disassoc(sdata, ifsta, true, true,
 					WLAN_REASON_PREV_AUTH_NOT_VALID);
-	else
+	else if (!(local->hw.flags & IEEE80211_HW_BEACON_FILTER))
 		mod_timer(&ifsta->timer, jiffies +
 				      IEEE80211_MONITORING_INTERVAL);
 }
diff -Nurp kernel-2.6.28-20094102.6+0m5/net/wireless/reg.c kernel-2.6.28-20094803.3+0m5/net/wireless/reg.c
--- kernel-2.6.28-20094102.6+0m5/net/wireless/reg.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/net/wireless/reg.c	2011-09-04 11:37:54.000000000 +0200
@@ -637,7 +637,7 @@ static void print_rd_rules(const struct
 	const struct ieee80211_freq_range *freq_range = NULL;
 	const struct ieee80211_power_rule *power_rule = NULL;
 
-	printk(KERN_INFO "\t(start_freq - end_freq @ bandwidth), "
+	printk(KERN_DEBUG "\t(start_freq - end_freq @ bandwidth), "
 		"(max_antenna_gain, max_eirp)\n");
 
 	for (i = 0; i < rd->n_reg_rules; i++) {
@@ -648,7 +648,7 @@ static void print_rd_rules(const struct
 		/* There may not be documentation for max antenna gain
 		 * in certain regions */
 		if (power_rule->max_antenna_gain)
-			printk(KERN_INFO "\t(%d KHz - %d KHz @ %d KHz), "
+			printk(KERN_DEBUG "\t(%d KHz - %d KHz @ %d KHz), "
 				"(%d mBi, %d mBm)\n",
 				freq_range->start_freq_khz,
 				freq_range->end_freq_khz,
@@ -656,7 +656,7 @@ static void print_rd_rules(const struct
 				power_rule->max_antenna_gain,
 				power_rule->max_eirp);
 		else
-			printk(KERN_INFO "\t(%d KHz - %d KHz @ %d KHz), "
+			printk(KERN_DEBUG "\t(%d KHz - %d KHz @ %d KHz), "
 				"(N/A, %d mBm)\n",
 				freq_range->start_freq_khz,
 				freq_range->end_freq_khz,
@@ -669,15 +669,15 @@ static void print_regdomain(const struct
 {
 
 	if (is_world_regdom(rd->alpha2))
-		printk(KERN_INFO "cfg80211: World regulatory "
+		printk(KERN_DEBUG "cfg80211: World regulatory "
 			"domain updated:\n");
 	else {
 		if (is_unknown_alpha2(rd->alpha2))
-			printk(KERN_INFO "cfg80211: Regulatory domain "
+			printk(KERN_DEBUG "cfg80211: Regulatory domain "
 				"changed to driver built-in settings "
 				"(unknown country)\n");
 		else
-			printk(KERN_INFO "cfg80211: Regulatory domain "
+			printk(KERN_DEBUG "cfg80211: Regulatory domain "
 				"changed to country: %c%c\n",
 				rd->alpha2[0], rd->alpha2[1]);
 	}
@@ -686,7 +686,7 @@ static void print_regdomain(const struct
 
 void print_regdomain_info(const struct ieee80211_regdomain *rd)
 {
-	printk(KERN_INFO "cfg80211: Regulatory domain: %c%c\n",
+	printk(KERN_DEBUG "cfg80211: Regulatory domain: %c%c\n",
 		rd->alpha2[0], rd->alpha2[1]);
 	print_rd_rules(rd);
 }
@@ -805,7 +805,7 @@ int regulatory_init(void)
 #ifdef CONFIG_WIRELESS_OLD_REGULATORY
 	cfg80211_regdomain = static_regdom(ieee80211_regdom);
 
-	printk(KERN_INFO "cfg80211: Using static regulatory domain info\n");
+	printk(KERN_DEBUG "cfg80211: Using static regulatory domain info\n");
 	print_regdomain_info(cfg80211_regdomain);
 	/* The old code still requests for a new regdomain and if
 	 * you have CRDA you get it updated, otherwise you get
diff -Nurp kernel-2.6.28-20094102.6+0m5/sound/soc/codecs/tlv320aic3x.c kernel-2.6.28-20094803.3+0m5/sound/soc/codecs/tlv320aic3x.c
--- kernel-2.6.28-20094102.6+0m5/sound/soc/codecs/tlv320aic3x.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/sound/soc/codecs/tlv320aic3x.c	2011-09-04 11:37:54.000000000 +0200
@@ -51,6 +51,9 @@
 
 #define AIC3X_VERSION "0.2"
 
+static int hp_dac_lim = 9;
+module_param(hp_dac_lim, int, 0);
+
 /* codec private data */
 struct aic3x_priv {
 	unsigned int sysclk;
@@ -294,6 +297,40 @@ static DECLARE_TLV_DB_SCALE(hpout_tlv, 0
  */
 static DECLARE_TLV_DB_SCALE(output_stage_tlv, -5900, 50, 1);
 
+#define SOC_DOUBLE_R_TLV_TLV320ALC3X(xname, reg_left, reg_right, xshift, xmax,\
+				 xinvert, tlv_array) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
+		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
+	.tlv.p = (tlv_array), \
+	.info = tlv320alc3x_info_volsw, \
+	.get = snd_soc_get_volsw_2r,\
+	.put = snd_soc_put_volsw_2r,\
+	.private_value = (unsigned long)&(struct soc_mixer_control) \
+		{.reg = reg_left, .rreg = reg_right, .shift = xshift, \
+		.max = xmax, .invert = xinvert} }
+
+static int tlv320alc3x_info_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	int max = mc->max;
+
+	if (hp_dac_lim != max && hp_dac_lim >= 2 && hp_dac_lim <= 9)
+		max = hp_dac_lim;
+
+	if (max == 1)
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	else
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = max;
+	return 0;
+}
+
 static const struct snd_kcontrol_new aic3x_snd_controls[] = {
 	/* Output */
 	SOC_DOUBLE_R_TLV("PCM Playback Volume",
@@ -327,8 +364,8 @@ static const struct snd_kcontrol_new aic
 			 0, 118, 1, output_stage_tlv),
 	SOC_DOUBLE_R("HP DAC Playback Switch", HPLOUT_CTRL, HPROUT_CTRL, 3,
 		     0x01, 0),
-	SOC_DOUBLE_R_TLV("HP DAC Output Volume", HPLOUT_CTRL, HPROUT_CTRL, 4,
-			 9, 0, hpout_tlv),
+	SOC_DOUBLE_R_TLV_TLV320ALC3X("HP DAC Output Volume", HPLOUT_CTRL,
+			 HPROUT_CTRL, 4, 9, 0, hpout_tlv),
 	SOC_DOUBLE_R_TLV("HP PGA Bypass Playback Volume",
 			 PGAL_2_HPLOUT_VOL, PGAR_2_HPROUT_VOL,
 			 0, 118, 1, output_stage_tlv),
@@ -341,8 +378,8 @@ static const struct snd_kcontrol_new aic
 			 0, 118, 1, output_stage_tlv),
 	SOC_DOUBLE_R("HPCOM DAC Playback Switch", HPLCOM_CTRL, HPRCOM_CTRL, 3,
 		     0x01, 0),
-	SOC_DOUBLE_R_TLV("HPCOM DAC Output Volume", HPLCOM_CTRL, HPRCOM_CTRL,
-			 4, 9, 0, hpout_tlv),
+	SOC_DOUBLE_R_TLV_TLV320ALC3X("HPCOM DAC Output Volume", HPLCOM_CTRL,
+			 HPRCOM_CTRL, 4, 9, 0, hpout_tlv),
 	SOC_DOUBLE_R_TLV("HPCOM PGA Bypass Playback Volume",
 			 PGAL_2_HPLCOM_VOL, PGAR_2_HPRCOM_VOL,
 			 0, 118, 1, output_stage_tlv),
diff -Nurp kernel-2.6.28-20094102.6+0m5/sound/soc/omap/rx51.c kernel-2.6.28-20094803.3+0m5/sound/soc/omap/rx51.c
--- kernel-2.6.28-20094102.6+0m5/sound/soc/omap/rx51.c	2011-09-04 11:36:23.000000000 +0200
+++ kernel-2.6.28-20094803.3+0m5/sound/soc/omap/rx51.c	2011-09-04 11:37:54.000000000 +0200
@@ -59,6 +59,9 @@ enum {
 	RX51_JACK_TVOUT,	/* stereo output with tv-out */
 };
 
+static int hp_lim = 63;
+module_param(hp_lim, int, 0);
+
 static int rx51_new_hw_audio;
 static int rx51_spk_func;
 static int rx51_jack_func;
@@ -563,8 +566,16 @@ enum {
 static int rx51_ext_info_volsw(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_info *uinfo)
 {
+	int ext_api = (kcontrol->private_value >> 26) & 0x0f;
 	int max = (kcontrol->private_value >> 16) & 0xff;
 
+	if (ext_api == RX51_EXT_API_TPA6130)
+		if (hp_lim != max && hp_lim >= 2 && hp_lim <= 63) {
+			kcontrol->private_value &= ~(0xff << 16);
+			kcontrol->private_value |= (hp_lim << 16);
+			max = hp_lim;
+		}
+
 	if (max == 1)
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	else
